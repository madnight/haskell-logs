00:33:21 <pie_> oh thats funny i was fantasizing about something like this the other day... https://www.reddit.com/r/haskell/comments/caqg1q/i_want_to_come_visit_and_crash_your_couch_and/ :D
00:33:34 <pie_> well, with me being the traveler buy yeah ;P
00:33:44 <pie_> *but
00:37:08 <sm[m]> Start HaskBnb
00:52:17 <Geekingfrog> I'm trying to avoid an orphan instance but I'm getting tangled in the newtypes. Basically, I have code running within a Gen (hedgehog/quickcheck monad to generate random stuff). I want to generate some crypto stuff (generateSecretKey), but that requires a `MonadRandom m`. Currently I have `newtype Foo a = Foo { runFoo :: Gen a}`. I can make the instance, but I'm stuck at how to use it.
00:53:46 <ashesham`> Geekingfrog: wasn't it MonadGen (afaicr)? 
00:54:33 <Geekingfrog> Yes, I have that in the deriving (Functor, Applicative, Monad, MonadGen)
00:55:50 <ashesham`> I'm not sure you can derive MondGen on Foo though. A little more context could help, maybe share a gist of what you're trying to do? 
00:56:04 <Geekingfrog> o
00:56:07 <Geekingfrog> ok, give me a min
00:59:53 <hvr> solonarv: yeah, cabal does like 95% of the stuff my cabal-env proof of concept shell script provided
01:00:26 <Geekingfrog> https://gist.github.com/geekingfrog/8c2420bee858e2ed57b5d026bd44fd53
01:00:31 <Geekingfrog> ^ ashesham` 
01:01:25 <hvr> solonarv: the main thing missing in cabal is listing & deleting shared envs
01:02:50 <hvr> jackdk: have you seen http://hackage.haskell.org/package/cabal-plan already?
01:05:50 <jackdk> hvr: I did not know about this. Thank you.
01:14:22 <bifunc2> How can I create a Channel (Control.Concurrent.Chan) or something similar that accepts *any type*? I simply want to create a channel in order to subsequently run IO actions on them that can return anything.
01:14:57 <bifunc2> it's painful to create a new sum type for this,  and one "run" method for each case
01:15:04 <bifunc2> no more elegant ways?
01:15:05 <Athas> bifunc2: that would not be type safe.
01:16:26 <bifunc2> Athas, i don't see how run :: Channel -> IO Any -> IO Any would not be type safe..
01:16:42 <bifunc2> (assuming i've created this "Channel" type)
01:17:04 <bifunc2> now, the issue is that Any isn't working with stuff like (), strings, etc.
01:17:15 <jackdk> If what arrives on the channel could be anything, how could your run function do anything useful?
01:17:38 <Athas> bifunc2: you can try Data.Dynamic.
01:17:52 <bifunc2> jackdk it doesn't do anything with the thing the IO  action returns, other than return  it back. This is useful if the channel runs the IO action  on a specific thrread
01:17:58 <bifunc2> so the only purpose is to run this on a specific thread
01:18:43 <bifunc2> is there a more elegant solution to creating a thread once and later run some IO actions on that particular thread?
01:18:58 <jackdk> so you pass things of arbitrary unknown type into the channel. how can whatever reads from it do anything useful?
01:19:29 <jackdk> if you just want to ask the thread to do stuff, a Chan (IO ()) might make more sense?
01:19:32 <Athas> jackdk: I think the point is to pass in actions of type 'IO a' for any 'a'.  There is an obvious thing to do with those.
01:20:02 <ski> (perhaps you could create an `MVar a', pass an `IO ()' on the channel to the thread, that will perform the computation and store the result in the `MVar a' for the original thread to retrieve ?)
01:20:28 <Athas> ski: You cannot create an 'MVar a'.  You need to instantiate the 'a' to a specific type.
01:20:44 <ski> Athas : `a' *is* the specific type, in this case
01:20:59 <bifunc2> <jackdk>	so you pass things...
01:21:06 <bifunc2> hehe
01:21:09 <bifunc2> good question!
01:21:12 <ski> @type Control.Concurrent.MVar.newMVar
01:21:14 <lambdabot> a -> IO (GHC.MVar.MVar a)
01:21:31 <ski> that will give you back the `MVar a', for the particular `a' you're talking about
01:21:55 <bifunc2> Athas wow, it's possible that forall is what i was looking for
01:21:59 <bifunc2> solution staring me in the face
01:22:02 <bifunc2> then i can write "run" only  once
01:22:20 <bifunc2> and don't have to bother with a new sum type
01:22:33 <ski> jackdk : iiuc, they also wanted to get back a result of type `a'
01:22:51 <Athas> bifunc2: be careful, 'forall' makes it hard to do anything with the value.
01:23:17 * ski isn't sure how bifunc2 was intending to be using `forall'
01:23:36 <ski> bifunc2 : did my suggestion make any sense, in your situation ?
01:26:31 <bifunc2> actually, no... it doesn't help :S to start a channel, it has to be of specific instance
01:26:38 <bifunc2> so the type must be  known
01:26:47 <ski> yes, so use `Char (IO ())' ?
01:27:31 <ski> bifunc2 : did you want to get back the `a' from the other thread ? or what did you want to do with it ?
01:30:35 <bifunc2> ski i'd like to create a thread. sometime later, i'd like to run IO Dog on that same thread getting a Dog back, and sometime later, i'd like to run IO Cat on that same thread getting a Cat back.
01:31:09 <ski> and you'd like to send those `IO'-actions to it, over a `Chan' ?
01:31:31 <bifunc2> yeah
01:31:56 <ski> and how would you prefer getting the result back ?
01:32:04 <ski> with an `MVar' ?
01:32:48 <bifunc2> yeah, if possible
01:33:20 <ski> so, let's say you have made a `Chan (IO ())', and it's available for both threads, one to send, the other to receive
01:34:49 <ski> then, when you want to transmit your `IO Dog', first make an `MVar Dog'. then make an `IO ()' which will perform the `IO Dog', then put the `Dog' in the `MVar'. now pass that `IO ()' over the `Chan' to the other thread, for it to perform. now, just wait (block) on the `MVar' to get the `Dog' in the first thread
01:35:10 <ski> you should probably be able to generalize this operation from `Dog' to any `a'
01:35:15 <ski> bifunc2 : clear ?
01:38:43 <bifunc2> ski i think that will work!
01:38:46 <bifunc2> thanks
01:38:50 <ski> yw :)
01:38:50 <bifunc2> i was thinking about it  wrong
01:39:44 <bifunc2> i  was thinking the IO Dog should go to the channel loop directly. instead it's way better to first wrap IO Dog in IO () and send that to the chan. This allows me to create a single run function for all  types
01:41:43 <ski> bifunc2 : it's the power of lexical scoping ! :)
03:23:41 * ski . o O ( "unix type systems" )
04:06:30 <Athas> What's the right way to use cabal new-build on NixOS?  Even with 'nix: True' in my configuration, I get complaints that zlib cannot be found.
04:10:37 <Athas> Oh, I see, I probably have to still enumerate what I want.
05:34:47 <libertyprime> hey guys. i noticed that when i search for ":: [String] -> String" on hoogle.haskell.org I get the expected results e.g. "unlines :: [String] -> String" but if I use my local hoogle server then i get incorrect ones e.g. "lines :: String -> [String]"
05:35:47 <libertyprime> perhaps my version of hoogle is a little out of date. i noticed the version is a little older i.e. "5.0.17.3"
05:37:25 <libertyprime> I'm running hoogle server like so: stack exec -- hoogle server
05:37:32 <libertyprime> any way to select a newer version?
05:39:25 <ski> incorrect, how ?
05:40:28 <__monty__> h.h.o and h.o/h both give the same results so maybe it's just because your local hoogle has fewer results that you see the less exact matches?
05:40:32 <libertyprime> string -> "list of string" instead of "list of string -> string"
05:41:05 <__monty__> libertyprime: Note that you'd often want permutations of argument order in the results : )
05:41:27 <ski> i think Hoogle matching is approximate, by design
05:41:37 <__monty__> I know permutation of result type is usually not as desired.
05:41:52 <ski> and istr hearing that they turned off some of that, in newer versions, because of having to search through larger volumes ?
05:42:02 <ski> __monty__ : aye
05:42:43 <ski> @where on-functors
05:42:43 <lambdabot> "On Functors" (in C++,Standard ML,Haskell,Prolog) by Peteris Krumins in 2010-05-17 at <http://www.catonmat.net/blog/on-functors/>
05:42:45 <ski> __monty__ ^
05:43:28 <__monty__> ski: Oh, cool. Almost forgot my question from yesterday : )
05:43:30 <__monty__> ski++
05:43:35 <libertyprime> i see. thanks guys. this is informative
05:43:36 * ski twitches
05:43:51 <__monty__> Ah, lambdabot doesn't do karma?
05:43:55 <ski> it does
05:44:03 <lavalike> hah
05:44:04 <ski> (that's just the issue, see ..)
05:47:14 <libertyprime> just out of curiousity, is the reason for query permutations being desirable that sometimes you dont know what position an argument will take?
05:48:12 <__monty__> libertyprime: Yes, exactly.
05:48:58 <__monty__> But also just the fact that human memory is imperfect.
05:49:42 <ski> @hoogle (a -> b -> c) -> (b,a) -> c
05:49:43 <lambdabot> No results found
05:49:44 <ski> @hoogle (a -> b -> c) -> (a,b) -> c
05:49:45 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
05:49:45 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> (a, b) -> c
05:49:45 <lambdabot> Test.Hspec.Discover uncurry :: () => (a -> b -> c) -> (a, b) -> c
05:49:47 <ski> hah !
05:50:06 <libertyprime> awesome. thanks :)
05:50:24 * ski . o O ( where are your permutations, now ?! )
05:52:25 <__monty__> ski: Everyone knows uncurrying is evil.
05:54:40 <dmwit> fresheyeball: But, like, the default profiling report will tell you much more than which module to look at. It will tell you how much time was spent in each cost center (both with and without including children cost centers). e.g. with auto-all that's every top-level function, which is more fine-grained than by module.
05:56:37 <ski> __monty__ : because the adjunction just yields an isomorphism, not an equality ?
06:01:27 * __monty__ 's eyes glaze over
06:02:48 <cocreature> dmwit: fwiw -fprof-auto-all is not a thing, there is -fprof-auto which is not limited to top-level functions and -fprof-auto-top which does what you described.
06:04:07 <__monty__> Not sure whether permuted tuples would be nice in hoogle results or not. I can see the similarity in the argument.
06:10:12 <ski> wouldn't it be nice if you searched for `(a,b) -> (b,a)', and it suggested `id :: a -> a' ?
06:12:12 <__monty__> Not really.
06:12:49 <__monty__> Otoh, sometimes you might not care about the order of the values in the result.
06:13:09 * ski 's jests falls on deaf ears
06:28:16 <dmwit> cocreature: Thanks for the correction.
06:37:15 <shapr> If anyone knows of a tutorial or more examples for limp ( http://hackage.haskell.org/package/limp ) I'm trying to improve my understanding
06:50:32 <ski> shapr : oh, i first thought it was related to LIMP <https://www.c64-wiki.de/wiki/LIMP>,<https://telarity.com/~dan/cbm/languages.html#LISP>,<https://www.lyonlabs.org/commodore/onrequest/collections.html> ..
06:51:37 * ski . o O ( <https://www.c64-wiki.de/wiki/PROLOG_64> )
06:52:40 <shapr> ski: nah, I'm trying to understand integer linear programming, among other things
06:54:49 <ski> what's the "m" stand for ?
07:21:59 <dmwit> ski: Don't talk back to me, I don't want any LIP from you.
07:25:26 * ski pays LIP service to the categorical imperatives
07:45:17 <maerwald> anyone got cabal-cache working?
07:49:31 <cyris212> Does haskell-ide-engine support cabal's nix-style builds?
07:54:16 <karetsu> cyris212: https://github.com/haskell/haskell-ide-engine#using-hie-with-spacemacs-on-nix-based-projects  relevant?
07:54:41 <karetsu> takes you to: https://github.com/benkolera/spacemacs-hie-nix which gives you cabal commands 
07:57:08 <sicklorkin> cyris212: have you seen https://github.com/Infinisil/all-hies
08:01:25 <cyris212> karetsu: sicklorkin Ah sorry I did mean cabal's new-build, which is called "nix-style local build" in the documentation
08:01:49 <maerwald> kinda
08:04:28 <karetsu> cyris212: yeah, the second link gives an emacs layer which combines hie and cabal
08:04:45 <karetsu> I'm not an elisp kinda guy to help though
08:04:58 <sicklorkin> cyris212: i think it may be more commonly called v2
08:05:10 <sicklorkin> cabal-v2
08:05:35 <halogenandtoast> is there any shorthand for `map (bimap f f) xs`
08:06:18 <maerwald> karetsu: he didn't ask for nix :)
08:08:11 <cyris212> Actually I would like to use hie on a project that uses cabal-v2
08:08:38 <sicklorkin> cyris212: what issue(s) are you running into?
08:09:08 <cyris212> I already have hie installed but it seems so crash whenever I open a file inside the project.
08:09:37 <sicklorkin> what lang-server processor are you using?
08:10:29 <cyris212> lsp-mode with https://github.com/emacs-lsp/lsp-haskell
08:12:15 <sicklorkin> cyris212: i'm not familiar with with lsp-haskell.. I wouldn't know how to help you debug...
08:12:35 * sicklorkin just likes to type with
08:12:48 <karetsu> maerwald: he asked for cabal working with hie, which is exactly what the second link provides a spacemacs layer for>?
08:17:35 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org'
08:17:35 --- topic: set by glguy on [Sat Jan 05 07:21:52 2019]
08:17:35 --- names: list (clog xplat carlomagno fendor xkapastel fmixing FreeBirdLjj jesusabdullah laem nineonine shkesar machinedgod rruizt cyris212 taiite Myhlamaeus halogenandtoast Saukk saurabhnanda zariuq urodna jedws kerru[m] heatsink karetsu merijn SCHAPiE Gurkenglas slack1256 s00pcan yyy- markus1189 ruuns__ Deide Ariakenom ryantrinkle Lord_of_Life Thra11 raichoo oish lucasb jjb2 knupfer jeltsch mostendocrine troydm Xal rfold takuan gwosix hellozee poljar mnrmnaugh)
08:17:35 --- names: list (__monty__ wei2912 acidjnk dddddd barrenba` phreedom ht_ cybai John__ agnki njay0009 Rudd0 thc202 wildlander Ckat catsup plutoniix ephemera_ danvet rotaerk o1lo01ol1o edwel[m] pavonia marmulak asymptotically Wamanuz zacts Tesseraction tromp lprd mjrosenb klntsky jesyspa_ miklcct kqr cynick shutdown_-h_now pie_ bengt_ fresheyeball vlatkoB Sgeo_ descender alx741 gxt gspia forgottenone hive-mind ggole Ranhir Zoddo ilikeheaps justanotheruser otto_s yaewa)
08:17:35 --- names: list (tomboy64 theDon swalladge lagothrix Ulrar tabemann jluttine nullifidian dustinm pfurla uzuki ziyourenxiang_ jackdk Jesin lambdabot AfRc7dIXJ7 ysangkok Enigmagic aarvar aristid eschnett srnty xelxebar dashkal pi4 bergey mkoenig hyuke chindy srid6390803 moldybits lastmanstanding sdx23 gabiruh zweimach[m] abrar thunderrd Jinna khisanth_ nshepperd crobbins acarrico infandum dTal benwr_ Ankhers _deepfire Bergle_2 nfd ahihi petersen ClaudiusMaximus _ashbreeze_)
08:17:35 --- names: list (xff0x phaul t7 OnkelTem opqdonut pdgwien iffsid cp boj ruffy_ revprez revprez_anzio bananagram m0rphism noCheese tomku rembo10 madnight raoul jwynn6 alicemaz nikivi jesyspa andreas303 tombusby kwantam dysfigured ziman ericsagnes tdammers Boarders Natch CSP-SOFTWARE ensyde qzo Jonathan teej duncan kori dan64 atomi kAworu infinity0 _ikke_ aoeupl[m] nbouscal xyggos wtw Entroacceptor seveg phaazon meck sw1nn daissgr_work zzz theorbtwo yahb freeside PLPD-Bot)
08:17:35 --- names: list (perrier-jouet flux DTZUZU Kaivo gaius_ akermu peel hpc mikolaj ajirx krowlan3[m] Sose Zorroness[m] acowley Stanley00 ftop Anthaas ixian stass gentauro sektor rzmt jol marmalodak neat72[m] tabaqui1 gienah_ guygma[m]1 sujeet pierrot Chousuke realloc forell TommyC monokrome hiredman wagle xtsee Velpoman beka mtjmullen bsima rj1 saidinwot1 SquidDev glowpelt jdevlieghere Ring0` nibbling_ sm[m] vk3wtf andromeda-galaxy jrozanski S007 toure dexterfoo abuss)
08:17:35 --- names: list (mountaingoat tstat anishathalye bugrum aruncom2006[m] bbear kingofmemes zerokarmaleft tails MarcelineVQ FlyingChicken[m] _dga cods PierreM aldum nesqi mceier heath leah2 coeus_ lugh pdxleif michalisko ego tigerchops jvanbure luite dstolfa chongliang sagax vaibhavsagar hiptobecubic pingu_ swater sicklorkin hsiktas kapilp Kamuela jsatk Wizek stux|RC xnyhps aib alanz casdr spamlessj scav unsymbol edmundnoble parseval i7c gonz_ ajmcmiddlin dsal typetetris)
08:17:35 --- names: list (ghuntley sebhoss gregberns Randy darthThorik runeks alexelcu feepo rodlogic EduardoBautista cyjiao__ kip coot sppky carter noexcept obfusk jokester Jaxan twk- pong dequbed spinda PyroLagus Blkt v0d1ch datapup_ tazjin joel135 paf31_ underikar metalrain xstill a3f nyuszika7h andreabedini mpickering monad_cat eacameron cemerick fingerzam caasih iravid vqrs_ jzl tsahyt PotatoGim nshepperd1 bjs ryanakca sethetter niko winny vjoki slikts jackhill DigitalKiwi)
08:17:35 --- names: list (Liskni_si bjobjo beaky Cale m1dnight_ Arahael suppenkasper[m] comboy nekomune lachenmayer teehemkay Arguggi dani- chirpsalot sarahzrf stk amuck Guest93415 DrAwesomeCraws yrid fionnan quarters Remy^ waskell magog[m] qz lanelet statusfailed micro kungp sis7 verement jrslepak jdt jonap mobile_x[m] glguy Bish kuttifunk Delyno oats Athas byorgey Majiir fieldmapper MonkeyNOS dcoutts juliendehos tv lassulus jchia gehmehgeh vorbex[m] cyphase cheater averell bydo)
08:17:35 --- names: list (atk linoge Guest9724 Foritus bbear_ Nik05 dolio devopsdeluxe leothrix enragedjam Intensity valdyn wonko7 atraii urdh spion amx Dykam kraem grumble Ewout mulk wildtrees[m] Tom[m]8 vnord[m] triste[m] stormchaser3000[ vpei[m] r2k[m] odd13[m] avocado reedhhw[m] lapav[m] keith[m] kahnpro[m] shanesveller[m] hans[m]4 hbx6 Grgoire[m] talvdav[m] gmips[m] George[m]1 closed-captionin nolep[m] noteventime nullheroes[m] Obscurity[m] tmallard[m] maxdeliso[m])
08:17:35 --- names: list (bohannes[m] jhg_0[m] jeeg[m] vkleen javjarfer[m] hogarth[m] Videled[m] jenkee[m] imdoor[m] themadman[m] hkimhvyh[m] pothyurf[m] AkikoHimenokoji[ pietromrtn[m] nefple[m] petrolifero[m] mykhas[m] Chromad[m] k4l1gr4[m] zeniace[m] Kimani[m] gareth_____[m] godzilla[m] sudoreboot[m] excel_gate[m] midi[m] georgescratcherd RampantLion[m] paulus[m] pagoda_5b[m] pineapple[m] mssx89m[m] cafissimo[m] bt[m] mouse008[m] kicker22004[m] kxra[m] bigblackpanda[m])
08:17:35 --- names: list (limabeans[m] tempaccount1[m] imposs[m] weebull[m] wobbol[m] PifyZ[m] intellection3to3 jonreeve[m] Noughtmare[m] wuxianhuiyi[m] tet[m] jacksap[m] gandi[m] pschooom[m] eightball[m] eckt[m] dxml[m] reconmaster[m] Richy[m] gkobeaga[m] gentlehelm[m] laniu[m] ghastfilms[m] GhostofaConsole[ luftmensch[m] asonixDogHeThey[ grorg[m] luminousnine[m] akhegai[m] bdesham[m] lions[m] bb010g aitzol[m] afontain[m] buster528[m] bobach[m] brevalda[m] cr0gs d1mur4tdj[m])
08:17:35 --- names: list (dag[m] cosson[m] cyclops19[m] Ekho[m] Ericson2314 ChristopherBurg[ fulgjon dontdieych steshaw[m] Panda[m] rizary sielicki sepp2k spherinder[m] siraben simbergm sylvie[m] iceychris[m] jonge[m] alexfmpe[m] kadoban mmynsted[m] josiah_sama stan[m] bee[m]1 kitsune[m] maigel[m] kaychaks[m] lierdakil[m] macerbi[m] marijuanafermion jibby[m]1 giuseppe[m] hgfedcba[m] EuAndreh[m] ClownMaster[m] fgaz humanwire[m] arsdragonfly[m] atopuzov[m] domenkozar[m] hdurer[m])
08:17:35 --- names: list (dmj` bgamari wildsebastian amatecha simony thi newhoggy_ billstclair dukedave higherorder pent nh2 eruditass alexknvl AndreasK integral edwardk dumptruckman ibloom M0ddba11[m] elvishjerricco Lermex aloiscochard[m] Cathy irdr no-n roflik mniip Nikotiini yaroot SrPx Shun131 cheers remexre verlet64 iphy arkeet nil neobrain Geekingfrog mitchellsalad Tuplanolla banjiewen lpsmith Ornedan megaTherion linduxed RecursiveG nitrix dpn` mingc drewbarbs SegFaultAX)
08:17:35 --- names: list (AfC mjuad bspar Moyst mp___664 myme milli lpvb sud0 raid boblehest bertschneider__ hegge_ riatre thoughtpolice affinespaces sbrg_ rootnode_ 21WAAH4XS yorick xacktm hexo haroldwu bandali rizary_ typedrat celphi w1d3m0d3 tsani asm89 srhb sdrodge el cantstanya drewr Franciman dilinger rvenyze sm simplegauss codedmart sukbeom9 agrif mccoyc matheus amiri marble_visions jlamothe raoulb anchpop_ yumh asjo jb55 chin-tastic ski bind Forkk edk dmwit nicoulaj bdw)
08:17:35 --- names: list (teardown hc nurupo orion interruptinuse Axman6 aesi quaestor Philonous sixtyten314 mikolaj_ winkill jameekim dmiles ahri Folkol a3Dman thallada _janne aramiscd Robin_Jadoul DrDuck Knallkopp465 monochrom zmlww int-e TMA albel727 Kiruwa Adeon nek0 jfredett nilOps drbean nckx hjozwiak daGrevis mrus devalot phlym h30 Cthalupa seventh__ TimWolla dxld hvr Xeyame topos vktec johnw haasn rotty tabaqui strangeglyph s4msung APic MindlessDrone joehillen zymurgy)
08:17:35 --- names: list (SlashLife Clint tinwood Patternmaster wrunt Tene yitz Logio cchalmers trebuh korzq datajerk_ otulp cyberlard andyo nyaomi Netwolf Mike2_ kav epta tristanC delYsid fr33domlover Meanirelli ent raatiniemi shadowdaemon CindyLinz dqd alyptik srk Adluc jophish GGMethos tolt totte canta Klumben SolarAquarion telser Jello_Raptor FliiFe d0liver ryzokuken Jabbslad natim87 catern kaol Paks digia lukelau michaelpj __4matter_ jtcs silverneedle Squarism PlasmaStar)
08:17:35 --- names: list (nuxdie ido tehidiot Unode nlofaro stiell griddle cpape @Sigyn Firedancer_ Twey tA- Igloo bcmiller Shockk solonarv AWizzArd anchpop__ restrictedchoice bitemyapp noan tureba hsyl20 Tourist thaumavorio zenzike lemald evilmonads AkhILman phadej Fubar^ absence ion ft defanor xpoqp gaze__ seanparsons cgfbee mou aveltras clever Madars_ Jacoby6000 sterni w1gz lkurusa Liebach greeny__ soncodi deu krystianbajno shapr __name__ brisbin ambrosia_ gothos klugez_)
08:17:35 --- names: list (debugloop gargawel_ aidecoe thebnq intelux uwap_ rslima___ sgraf burp_ dibblego terrorjack__ dongcarl dgpratt ProofTechnique koankeeper infinisil ebutleriv seliopou chkl jonge statusbot MatrixBot3 petermw_ petercommand steve1 jrm Flonk sandman13 nisstyre ekleog bartavelle Profpatsch cocreature darxun m4lvin mrsbear loc mikeplus64 sveit kini Dabo michaelsdunn1_ Ferdirand theophil893 scinawa Peppep_ bendo wayne NinjaTrappeur sqrt2 jix NextHendrix Annihitek)
08:17:35 --- names: list (ynyounuo vzdraz iltiades rkrishnan vodkaInferno gunishozi bradparker systemfault Fabian ranberry__ bs azahi tms_ Vq lyxia anry uplime zxrf graingert adius gilbertw1 tessier_ @ChanServ ereu benl23 avn echoreply tumdedum ldlework devurandom spoonm Heffalump xintron chivay travv0 dminuoso simon Frobozz elcaro stefan-__ nahra koz_ sigmundv- Maxdamantus mimi_vx juri_ Seich johnstein n3t pacak croutons kark Batholith esph divVerent wrengr_away recj akr stvc)
08:17:35 --- names: list (arianvp aweinstock _ht PragCypher bob_twinkles nemesit|znc steell_ shreyasminocha Zemyla lavalike cross mudri JSharp drdo kipras`away zv georgew treehaqr reyu elgot bitonic ullbeking jbetz d6e dh freusque apoc Niamkik irclogger_com mankyKitty andjjj23 ephemeron Jon rootmos Rembane c_wraith betawaffle lstdgtfp joeyh rann m-renaud sclv Nevoic oak ByronJohnson Ekho dfordivam sudden subfacto1 newhoggy kyagrd__ ocharles milessabin glowcoil J_Arcane stilgart)
08:17:35 --- names: list (Guillaum immae jonatan rom1504 Chobbes nopf kubrat oleks adamse mmaruseacph2 cbarrett lightandlight alunduil NemesisD jetpack_joe pasukon bollu nonzen Sparadox Mo0O energizer_ yushyin acro M2tias stylewarning johs so Ke suzu _guios raek_ hongminhee exarkun orzo apeyroux_ ManiacTwister diginet bcoppens obiwahn RusAlex RoguePointer bwe bolverkr ab9rf AJTJ noctux feuerbach Phyx- haveo mupf Taneb greymalkin runawayfive charukiewicz MasseR violeta Hijiri)
08:17:35 --- names: list (cloudhead dredozubov Deadhand noko_ c-rog Tspoon__ michalrus gsingh93 xorpse Firedancer ecx86 Peter_Storm jmsx abbe Hotbees flogfr hodapp Konehaltia heyj mrd [exa] scal PHO connrs_ Jonno_FTW Nascha sphalerite DustyDingo scivola Eliel locallycompact gluegadget polux7 saurik_ ammar2 edwtjo blackdog t36s gambpang hexagoxel deni connrs- sebastianrkg PtxDK lortabac lexi-lambda Reisen exferenceBot moocow lurkless fiQ2 sms [df] Aleksejs coldpress carbolymer)
08:17:35 --- names: list (ycheng vin-ivar exio4 puffnfresh fiddlerwoaroof sivs niklasb_ _flow_ Deewiant lieven tchakka kosmikus barrucadu rodgzilla koala_man eldritch geal luigy jorj Willis maerwald aplainzetakind EvanR implementation_ crooked d3lxa adarshaj eagleflo Xandaros wz1000 duairc HalfEatenPie fiatjaf pharaun sssilver dyl lowryder Kneiva avp _6a68 anderson djanatyn Someguy123 solarus jinblack ezyang markhuge idupree DwarfMaster davean iron_houzi ryjm[payon] wraithm abra0)
08:17:35 --- names: list (kloeri cjay- joeytwiddle adamCS furnost)
08:18:09 <cyris212> https://gist.github.com/winpat/6d022f899b1113bdb62f5aa3a0c26257
08:18:27 <cyris212> Found something in the emacs *Message* buffer looks interesting.
08:18:47 <cyris212> "--with-cabal=cabal" "v1-style"
08:19:15 <sicklorkin> that would be a problem
08:20:11 <nshepperd> halogenandtoast: over (traverse . both)?
08:22:09 <nshepperd> (it requires bitraversable, not bifunctor though. also not really shorter since it's hard to get shorter than 18 chars)
08:24:07 <cyris212> Thank you for your help. I will create an issue on GitHub.
08:28:17 <infinisil> cyris212: I don't think HIE really works with new-style builds yet
08:28:35 <infinisil> Not sure about it though
08:30:40 <sicklorkin> infinisil: Can you just tweak hie-wapper?
08:30:44 <sicklorkin> *wrapper
08:31:08 <infinisil> What do you mean by tweak?
08:33:54 <fendor> hie does not use v2-build yet. Will probably change after hie-bios has been merged
08:35:26 <sicklorkin> infinisil: I don't know what I'm talking about apparently.. my memory has failed me yet again..
08:36:05 <cyris212> fendor: All right. Thank you!
08:37:25 <halogenandtoast> nshepperd: thanks, I'll just stick with the form I wrote, don't really have too much incentive to add lenses just yet
08:48:23 <bachibuzuk> hi, I was trying to compile a .hs file in emacs, but I get the
08:48:23 <bachibuzuk> error "cabal: No cabal file found.
08:48:23 <bachibuzuk> Please create a package description file <pkgname>.cabal". I don't
08:48:23 <bachibuzuk> understand as cabal is in my PATH. Using Fedora. Any idea what's going
08:48:26 <bachibuzuk> on ?
08:48:58 <merijn> bachibuzuk: Cabal is for building packages, presumably you haven't created a cabal file to define a package, so it can't work
08:49:28 <merijn> bachibuzuk: And clearly whatever you're using in emacs wants to use cabal and not ghc
08:50:27 <fendor> where does cabal v2-* place the executable to run? .cabal/store?
08:50:38 <merijn> fendor: In the build directory somewhere
08:50:49 <Athas> bachibuzuk: There are three things called cabal/Cabal: (1) The command line program 'cabal', which is properly called cabal-install (even though that is not the binary name). (2) The library 'Cabal', which is used to implement the cabal-install. (3) The Cabal file format (a file with the extension .cabal, which is likely what you are missing).
08:51:01 <merijn> fendor: You can use hvr's cabal-plan executable to find out, but more realistically you should stop caring
08:51:21 <merijn> fendor: Use v2-run to run programs for testing, or use v2-install to copy them somewhere where you can find them
08:51:35 <fendor> merijn, i want to know how it has been linked since I get run-time errors for c-libs
08:51:40 <fendor> alright, install sounds sensible
08:51:46 <merijn> Athas: I wrote a github gist so you never have to explain that!
08:52:05 <merijn> fendor: For that you might want cabal-plan (which pretty prints plan.json)
08:52:17 <merijn> Athas: https://gist.github.com/merijn/8152d561fb8b011f9313c48d876ceb07
08:52:18 <ldlework> merijn: they did a pretty good job in just a couple lines :D
08:52:19 <bachibuzuk> hum ok :merijn, how do I create a cabal file ? I guess i'll read TFM
08:52:25 <merijn> Athas: I got tired of explaining things ;)
08:52:55 <merijn> ldlework: Sure, but I know from experience that after the first 10 times of writing that it gets old quick ;)
08:54:32 <Athas> merijn: every time I explain that (or every time I link your gist in the future), I wonder whether this was considered at the time Cabal was designed.
08:55:05 <merijn> Athas: I don't think anyone foresaw a split like stack in the commandline tool used
08:55:28 <sicklorkin> bachibuzuk: are you just toying around with Haskell? e.g. you've written a Main.hs and now you just wanna compile it?
08:55:29 <Athas> That's not the confusion.  The confusion is that too many things are called cabal.
08:55:56 <merijn> Athas: Sure, but they used to be rather monolythic in the beginning
08:55:57 <Athas> I remember being mightily confused that the package 'cabal-install' installed a binary called 'cabal', and that the package 'Cabal' did not.
08:55:58 <bachibuzuk> exactly sicklorkin
08:56:19 <merijn> bachibuzuk: Simplest way to get a minimal cabal file is "cabal init" and follow the multiple choice answers :)
08:56:21 <sicklorkin> bachibuzuk: you could use ghc --make and leave cabal for another day
08:56:24 <Athas> Why was Cabal and cabal-install even split up?  Things would have been much easier if they were the same package.
08:56:48 <merijn> bachibuzuk: Alternatively use some other emacs plugin, I don't really know emacs, but I'm sure *something* supports ghc without cabal
08:56:53 <__monty__> Athas: But then stack would've had to reimplement everything.
08:56:56 <Athas> Or maybe if Cabal-the-library had been called libCabal or something, and cabal-install had just been called 'cabal'.
08:57:09 <merijn> Athas: Because Cabal is a GHC tie in and thus has to be conservative with dependencies
08:57:38 <merijn> Athas: Having cabal-install separate means it can more aggressively adopt libraries that make live easier (still not very aggressive, because it needs wide support)
09:01:37 <Athas> Why does GHC depend on Cabal anyway?
09:01:47 <Athas> What happens if the Cabal used by cabal does not match the Cabal used by ghc?
09:02:00 <merijn> Athas: You can't do that
09:02:12 <merijn> Athas: What you get is a compile time error
09:02:23 <merijn> Athas: And GHC depends on it to implement, well, CABAL the spec
09:02:31 <hvr> Athas: https://github.com/haskell/cabal/issues/3965 :-)
09:02:34 <merijn> Athas: i.e. how to find installed packages, etc.
09:02:37 <__monty__> There's *another* cabal?
09:02:53 <Athas> Ugh.  I never really liked that GHC has these wired-in libraries, but that's a more extreme point...
09:03:11 <merijn> Athas: That was for all compilers, though
09:03:19 <Athas> merijn: I thought that was just whatever GHC-specific package database is read by ghc-pkg and its ilk.
09:03:33 <hvr> Athas: fwiw, exe:cabal is not forced to use the very same version of lib:Cabal that's bundled with GHC
09:03:42 <Athas> I mean, I fully understand why GHC and cabal-install need to use the same CABAL file format, but why the same version of Cabal-the-library?
09:03:45 <Athas> hvr: ah, good.
09:05:20 <merijn> Athas: They don't
09:05:31 <merijn> Athas: cabal-install and GHC can used different Cabal versions
09:05:49 <merijn> Athas: But if you link against GHC (the library) you cannot link against a different version of Cabal
09:06:36 <Athas> merijn: that's fine, I suppose.  I can't think very many programs actually wish to link to Cabal.
09:06:40 <hvr> merijn: lib:ghc links against lib:Cabal? :-)
09:07:13 <merijn> hvr: I just remember linking both broke stuff for some reason. Admittedly that was a while ago, so who knows what's changed
09:10:09 <hvr> merijn: well, if there are issues now, I'd like to know; I don't recall having seen such issues w/ v2-* in the last couple years... so
09:52:55 <merijn> hvr: Well, maybe it was fixed by GHC now allowing multiple different versions of the same library to be linked into an executable? I dunno, I'm getting old and things keep changing! *grumble* ;)
09:53:26 <midi[m]> https://github.com/asr/apia
09:53:26 <midi[m]> This is neat
09:55:27 <slack1256> midi[m]: not browser running & heavy system load, what is that?
09:59:22 <sicklorkin> Is anyone familar with https://github.com/haskell/haskell-ide-engine/issues/1059
10:07:40 <fendor> sicklorkin, yeah
10:08:50 <sicklorkin> I've just rebuilt hie on my build machine and wanna deploy the built binarys to a handful of machines.. what files should I be copying?
10:09:56 <fendor> sicklorkin, that will be hardly possible due to a number of run-time dependencies, such as hlint data-dirs, cabal-helper and others
10:10:26 <sicklorkin> humm...so the requirement now is that it must be built on each machine?
10:10:45 <fendor> sicklorkin, currently this is the most reliable way, yes
10:11:04 <sicklorkin> fendor: oh-kay
10:12:33 <sicklorkin> fendor: what's the quickest way to update hie? i've been building from source but maybe there's an alternative now?
10:13:40 <fendor> sicklorkin, nope, building from source is still the way to go, except if you use nix, then you can use prebuilt binaries
10:16:33 <fendor> sicklorkin, if you used one of the cabal targets, normally more packages have been cached than with stack
10:19:27 <sicklorkin> fendor: What are the issues preventing hie being available via `stack install` or `cabal install`
10:20:21 <fendor> sicklorkin, nothing, it is what happens essentially. But hie needs to be built with the same ghc version that you are using on the project that you want to use hie on
10:21:29 <fendor> the install script takes care of git submodules, generating the documentation and installing the executable correctly and label it according how hie-wrapper expects it
10:23:56 <sicklorkin> fendor: Thanks
11:32:07 <crestfallen> hi considering these notes http://sprunge.us/CtgVap a member helped me with the other day, I lost my way with the following minimax program (again) https://github.com/varreli/haskell/blob/master/hutton/84_chapt11/ticTacToe.hs     my question follows:
11:32:58 <crestfallen> please see the two lines of comments in the posted notes. Is that correct?
11:33:41 <crestfallen> the minimax program begins on line 155
11:34:37 <crestfallen> using map drops the root node from the list but I'm not sure how
11:35:52 <crestfallen> or using map is supposed to drop the root node, but I'm getting different results
11:39:08 <crestfallen> so I'm trying to see how line 164 in the where statement works.
11:40:20 <crestfallen> its a case where I thought I understood it 48 hours ago, and on revisiting I got lost
12:12:03 <argent0> crestfallen: should't you have 'map minmax (gametree ...)' and also a Functor instance for Tree?
12:12:26 <argent0> different to 'map minmax [gametree ...]'
12:13:34 <argent0> in the later case there is no root node as: `data Tree a = Node a [Tree a]`
12:13:44 <argent0> and you only have [Tree a]
12:17:31 <crestfallen> argent0, sorry one moment I just closed all my windows. THANKS ....
12:19:47 <crestfallen> argent0, this is a book example Functors haven't been covered yet...
12:19:52 <crestfallen> also
12:21:52 <crestfallen> argent0, please indicate the line number of my error
12:30:51 <ski> crestfallen : i don't see the problem with your first two examples
12:31:16 <ski> crestfallen : however, i think that "the root node is dropped" suggests a misunderstanding about what that example does
12:37:00 <crestfallen> ski really appreciate it hold on please
12:37:10 * ski holds off
12:37:45 <crestfallen> you're saying the root node is not dropped 
12:40:37 <crestfallen> ski the root node needs to be included in the list, since it is getting labeled as well with all the child nodes
12:43:32 <crestfallen> that was "hold on" btw
12:46:42 <nshepperd> crestfallen: at line 164, what is 'ts'?
12:49:33 <crestfallen> a member helped me with this nshepperd the other day. I believe it is ...
12:50:30 <crestfallen> given the 'initial grid' I have commented on line 133 ...
12:53:36 <ski> crestfallen : "the root node" is included in both of the first two examples in your paste
12:55:49 <crestfallen> http://sprunge.us/s8XtGV this is the result I get with map minimax [(gametree [initial grid] O)]
12:56:24 <crestfallen> ski you mean the 2 commented lines in the notes?
12:56:59 <ski> how about with your first example, `minimax (gametree [[O,O,B],[X,X,O],[X,O,B]] O)' ?
12:58:29 <argent0> `map f [a] == [f a]`
12:58:44 <crestfallen> ski nshepperd so yeah I think I see what's happening ...
12:59:02 <ski> can you explain it, in your own words ?
12:59:21 <crestfallen> that's exactly what I want to do, I can ...
13:00:00 <crestfallen> because of the data Tree a definition ...
13:00:52 <crestfallen> there is a pattern match occurring ...
13:01:12 <crestfallen> so ... 
13:02:24 <halogenandtoast> are there any builtins that do something like (a, b, c) -> (a, b) ?
13:02:55 <halogenandtoast> I assume not, but figured I would ask
13:02:59 <halogenandtoast> easy enough function to write
13:03:05 <ski> halogenandtoast : hm, someone asked that recently (as in within the last two weeks)
13:03:07 <fresheyeball> halogenandtoast: what is a builtin?
13:03:19 <halogenandtoast> fresheyeball: something in the base package
13:03:29 <fresheyeball> Then no
13:03:51 <ski> halogenandtoast : i figured out two "advanced" ways to do it (for fun), but i think the conclusion was that a lambda was probably the best way
13:04:07 <halogenandtoast> I essentially want the (year, month) from a UTCTime
13:04:12 <crestfallen> so without map and the gametree argument in brackets, minimax (gametree arguments) leaves out the root node but the Node constructor remains. So we don't want this latter scenario.
13:04:27 <halogenandtoast> toGregorian gives me (y,m,d) but I wanted to drop the d
13:04:29 <ski>   \(year,month,_day) -> (year,month)
13:04:37 <fresheyeball> Does anyone have a good understanding of what GC waiting means in threadscope?
13:04:37 <dmwit> But UTCTime is not a triple?
13:04:40 <crestfallen> ski nshepperd ^
13:04:51 <halogenandtoast> dmwit: toGregorian turns it into one
13:05:07 <halogenandtoast> well toGregorian . utctDay
13:05:13 <ski> crestfallen : "without map and the gametree argument in brackets, minimax (gametree arguments) leaves out the root node" -- no, that's not what's happening
13:05:41 <dmwit> Anyway, \(a,b,c) -> (a,b) is about as good as it gets.
13:05:52 <dmwit> There are other ways, with some libraries, but even those other ways aren't really better.
13:06:02 <halogenandtoast> dmwit, ski: Thanks for the confirmation
13:06:23 <dmwit> And arguably giving meaningful names like \(y,m,d) -> (y,m) is pretty decent documentation of what you're doing.
13:08:04 <crestfallen> it doesn't leave out the root node, but map needs to iterate over the list, so the root node must be included within the brackets
13:08:39 <mpickering> Is there an empty constraint of kind `* -> * -> Constraint` defined in `generics-sop`?
13:08:54 <halogenandtoast> anything I could improve here (given a list of timestamps, I want to find which day occurs the most for each month): https://gist.github.com/halogenandtoast/a98ba6eb28233d50448927ac30e89455
13:12:54 <halogenandtoast> I did find it particularly fun to have a use for uncurry3
13:15:31 <ski> crestfallen : yes
13:16:18 <int-e> Your code traverses the list 12 times. That's a bit wasteful.
13:16:57 <crestfallen> ski ok thanks, there's something wrong though I believe ...
13:17:35 <crestfallen> I changed the initial grid and the behavior looks different
13:17:48 <int-e> halogenandtoast: I would map each timestamp to a (month, day) pair, and then count those (probably using Data.Map.Strict.fromListWith), and then extract the result from that.
13:18:52 <halogenandtoast> int-e: I'll look into using fromListWith
13:20:13 <int-e> (possibly using Vector instead of Data.Map.Strict: https://hackage.haskell.org/package/vector-0.12.0.3/docs/Data-Vector.html#v:accum)
13:23:44 <crestfallen> so ski, on the lhs on line 164, is ts already fully in brackets due to the definition of data Tree a , or does map apply the brackets around (gametree [initial grid] O)    ?
13:23:53 <crestfallen> sorry rhs *
13:27:57 <dmwit> halogenandtoast: I commented with how I'd do it.
13:28:55 <nshepperd2> 'in brackets' is rather the wrong question... is the misunderstanding about how map and lists work?
13:32:18 <crestfallen> nshepperd2, I'm trying to understand exactly what (Node g ts) looks like on line 160, to see how map minimax ts works
13:34:18 <crestfallen> I'm confused about ts , partially because gametree is not passed into minimax explicitly.
13:34:30 <crestfallen> nshepperd2, ^
13:36:05 <halogenandtoast> dmwit: Thanks, definitely interesting to see another approach.
13:40:18 * dmwit ponders writing `data MapWithKey a where MapWithKey :: Map k v -> MapWithKey (k,v)` just to have something to hang a Foldable instance off of
13:41:33 <N3RGY> Hey all, I recently wrote a little minimal Haskell command line tool to perform set/map operations on text files. Would appreciate any comments/suggestions. https://github.com/wyager/smap
13:42:01 <N3RGY> It's basically intended to replace sort, uniq, awk, etc. for my day-to-day text munging
13:46:12 <fresheyeball> holy crap 
13:46:17 <fresheyeball> profiling haskell is so painful
13:46:33 <crestfallen> nshepperd2, I think I see. map is not iterating over the root node, there is only Node remaining before the list begins. The root node is already labeled with O. map iterates once it hits the first bracket and cannot iterate over Node ([initial grid],O)
13:46:36 <fresheyeball> does anyone know where there is a doc that just tells you how to read the report?
13:46:41 <fresheyeball> what does "productivity" mean?
13:46:50 <fresheyeball> I can't even find the basics in the docs
13:46:56 <N3RGY> What are you reading fresheyball? The output of +RTS -s?
13:47:07 <N3RGY> I believe productivity is percent of time not spent GCing
13:47:28 <crestfallen> is that correct nshepperd2 ^   ?
13:47:48 <fresheyeball> N3RGY: yes, but really I want to know where to doc is that describes productivity
13:48:04 <fresheyeball> what is MUT? where is the doc that explains what any of this output actually means?
13:48:54 <N3RGY> fresheyeball: This isn't really intended for in-depth profiling. You should build with profiling enabled and look at the file generated by +RTS -p
13:49:15 <N3RGY> That will give you a really in-depth and easy to understand breakdown
13:50:02 <N3RGY> Well, easy to understand unless the optimizer does its job a bit too well :)
13:51:46 <mastarija> Anyone working on a Windows machine? I'm having a problem when I run my servant project in GHCi (with cabal new-repl). I start my servant server from GHCi for testing, but when I attempt to interrupt it by pressing Ctrl+c I seemingly shut down whole GHCi instead of just servant / warp function and get kicked out into a windows prompt. If I try to type some commands, terminal switches between GHCi and the console and half of a command 
13:51:46 <mastarija> goes to GHCi and half goes to the host windows terminal.
13:52:01 <argent0> N3RGY: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html
13:52:38 <N3RGY> argent0: I think you mean @fresheyeball
13:52:38 <argent0> fresheyeball: ^
13:53:03 <halogenandtoast> dmwit, int-e: based on your suggestions and/or encouragement, I rewrote it to this (which I think looks nicer): https://gist.github.com/halogenandtoast/a98ba6eb28233d50448927ac30e89455
13:53:11 <nshepperd2> crestfallen: maybe, but you've described it strangely so I'm not sure
13:53:25 <halogenandtoast> will probably change some $ around there
13:53:56 <nshepperd2> crestfallen: what map does is: it takes a function, and a list, and it applies the function to each value in the list, and returns a list of the results
13:56:55 <nshepperd2> > let friends = ["moon", "mouse", "house"] in map ("goodnight " ++) friends  -- crestfallen, for example
13:56:59 <lambdabot>  ["goodnight moon","goodnight mouse","goodnight house"]
13:59:13 <int-e> halogenandtoast: looks reasonable to me, except that you almost definitely should use Data.Map.Strict to avoid the accumulation of thunks of the for 1+1+1+...+1 in the map.
14:00:07 <nshepperd2> crestfallen: when you see "map minimax ts", you should think "Ah, ts is a list. But a list of what?"
14:01:51 <halogenandtoast> int-e: I am importing those function from Data.Map.Strict
14:02:36 <crestfallen> nshepperd2, yes that's the trouble .. thanks ...
14:03:18 <crestfallen> it's a list of child nodes, not including the "head" which is the root node
14:03:28 <c_wraith> based on the name "minimax", I'd assume it's possible next moves in a game
14:03:33 <halogenandtoast> int-e: but that is a good point to keep in mind for why to use strict there
14:03:48 <int-e> halogenandtoast: oj. the paste had Data.Map which is the lazy one.
14:04:25 <halogenandtoast> int-e: you must mean the comment from dmwit
14:04:42 <halogenandtoast> I didn't list any imports in my gist
14:06:50 <dmwit> halogenandtoast: Looks a lot better!
14:07:05 <dmwit> halogenandtoast: bimap id = fmap, by the way
14:07:31 <nshepperd2> crestfallen: so 'ts' is the list of child nodes, which means 'map minimax ts' is...? (note: to properly answer this question you will first need to answer "what does minimax do, conceptually? what is its input and output?")
14:07:39 <dmwit> (and likely fmap = map, though I haven't managed to do all the mental type inference needed to be sure yet)
14:08:18 <halogenandtoast> dmwit: right, that's true here (it's on a tuple so I don't think map works since that is specialized to list)
14:08:35 <int-e> halogenandtoast: maybe
14:09:10 <dmwit> map definitely won't work if it's a tuple.
14:09:12 <int-e> halogenandtoast: indeed. paying attention to nicks is hard.
14:09:13 <dmwit> But fmap still will.
14:12:29 <ysangkok> how do i find out why cabal v2-build wants to build a certain package? i found some instructions using ghc-pkg, but that only covers installed stuff, right?
14:13:19 <ysangkok> i am trying to build hie-lsif with cabal-install from master and somehow it is building cabal-doctest (which seems depreacted since cabal now has its own doctest). so i want to find out why this dependency is being built
14:14:02 <__monty__> ysangkok: cabal-plan usually helps with that.
14:14:20 <crestfallen> c_wraith, nshepperd2  still working really appreciate it. it's dawning on me.
14:20:25 <crestfallen> nshepperd2, what it's doing is determining whether to label a child node with 'O' or 'X' 
14:23:02 <crestfallen> so it starts iterations more shallow in the tree, and goes down in depth until the winning base case is reached nshepperd2 
14:23:54 <nshepperd2> crestfallen: it may be a productive exercise to go through every identifier in the definition of 'minimax' and write down 1. its name 2. its type 3. what it means. for example "ts is of type [Tree Grid], and is the list of child nodes (possible next moves) of the input to minimax"
14:24:31 <nshepperd2> crestfallen: so for minimax, the input is _? and the output is _?
14:25:00 <crestfallen> ok, what I wrote above is that correct nshepperd2 ?
14:30:09 <ocharles> Can anyone here remember the name of the package that gives you IO, but with a kind of "data types a la carte" approach to split it up (e.g., IO that can only use IORefs)
14:30:20 <ocharles> it's *somewhere* on Hackage and quite old, but I can't remember the name of the damn thing
14:31:05 <__monty__> ocharles: Something like Free or Freer?
14:31:27 <ocharles> Nothing quite that general
14:31:33 <ocharles> but that idea
14:32:06 <nshepperd2> crestfallen: by 'it' you meant "map minimax ts" in the above?
14:34:39 <crestfallen> yes that is the meat of the program that eventually passes the empty list to the two guards with the wins function nshepperd2 
14:35:08 <crestfallen> for lack of a better way to say it
14:35:55 <ocharles> __monty__: I think it's this: https://hackage.haskell.org/package/base-io-access-0.4.0.0/docs/Access-System-CPUTime.html
14:37:06 <ocharles> Oh no, it's https://hackage.haskell.org/package/IOSpec
14:37:36 <nshepperd2> crestfallen: then yes, sort of. but you've described it in a very imperative way. minimax takes as input a game tree, and produces the same game tree with each node labeled with the winning player, right?
14:39:57 <nshepperd2> crestfallen: ts is the list of children, so map minimax ts is a list of the children labeled with the winning player
14:41:03 <nshepperd2> i think haskell programs are best understood by those sort of "is" statements
14:41:37 <ysangkok> __monty__: thanks, works!
14:42:42 <crestfallen> only the child nodes of the winning player is ultimately returned? nshepperd2 
14:42:48 <crestfallen> are*
14:43:23 <crestfallen> from map minimax ts I mean
14:45:48 <nshepperd2> crestfallen: all of the child nodes are included. i mean that they are labeled with the player that would win if you started from the node's state
14:47:36 <__monty__> ysangkok: np
14:48:11 <nshepperd2> crestfallen: eg. (Node [[X,X,X],[B,O,O],[B,B,O]]] []) would be labeled with X. because that grid is one where X has won
14:52:03 <crestfallen> yes copy that. really appreciate it nshepperd2 . a final remark ... 
14:53:15 <crestfallen> the way data Tree a is structured makes it difficult to see how map is traversing the list. do you agree?
14:55:56 <nshepperd> not really
14:56:08 <nshepperd> are you familiar with list comprehensions?
14:57:10 <crestfallen> yes
14:57:11 <nshepperd> a different way to write 'map minimax ts' which means exactly the same thing is [minimax child | child <- ts]
14:59:34 <crestfallen> thanks kindly I'm going to go over that tonight nshepperd . it looks like a welcome addition 
15:55:00 <slack1256> On https://i.imgur.com/m0YPZpc.png is there a way to further break the MANY band?
15:55:26 <slack1256> maybe there are a pair of related closures that are holding lots of data but get reported as MANY
17:47:02 <dmwit> What's the right cabal stanza to put my README.md in?
17:47:16 <dmwit> (I mean, for it to appear on Hackage.)
17:47:23 <solonarv> dmwit: extra-source-files
17:47:34 <solonarv> or is it spelled extra-src-files? I'm not sure
17:47:42 <dmwit> ok!
17:48:27 <solonarv> that is also where you might mention CHANGELOG.md, for example
17:53:36 <turab> When a language extension description says it implies another extensions, what exactly does it mean?
17:54:26 <turab> I thought it would automatically enable the implied extension
17:54:38 <solonarv> turab: if Foo implies Bar, that means enabling Foo also enables Bar
17:55:10 <turab> Hmm maybe there is typo in my pragma
17:55:55 <solonarv> quite possibly
17:58:54 <turab> Ahh, language pragmas should precede the module keyword
17:59:34 <turab> I was playing around with some type level functions so didn't bother with the module
18:20:07 <dmwit> solonarv: Yay, it worked! https://hackage.haskell.org/package/effect-stack-0.3#readme
18:27:22 <turab> So, I am following the paper "Fun with functional dependencies" by Thomas Hallgren and there is a point where my program behaves differently from the one in the paper. http://www.cse.chalmers.se/~hallgren/Papers/hallgren.pdf
18:28:23 <turab> In the first example that uses fundep, I try (:t isEven (undefined :: Succ (Succ (Succ Zero))) :: T) but that throws an error instead of what the example in the paper shows
18:29:03 <lyxia> what error
18:29:15 <turab> Uploading
18:29:26 <dmwit> But that's not the example they have in the paper?
18:29:38 <dmwit> Their example is `:t isEven :: Three`, not `:t isEven (undefined :: Three)`.
18:31:25 <turab> https://gist.github.com/trajafri/34847b5517307e274c95567efd91e54d
18:31:54 <turab> I think that example is for non fundep type class
18:32:07 <turab> normal typeclass*
18:33:03 <dmwit> You *should* get a type error there, because 4 is indeed even and 3 is indeed odd.
18:33:10 <turab> The error message makes sense, but I don't get why the one in the paper doesn't complain
18:33:11 <dmwit> Did you mean to put T instead of F in both queries?
18:33:29 <dmwit> The one in the paper uses True, not False (analog of your T, not your F).
18:34:28 <turab> The paper also shows :t odd (undefined::Three) :: False
18:35:09 <turab> Hugs returns odd undefined :: Odd (Succ (Succ (Succ Zero))) False => False
18:35:27 <dmwit> Oh, yeah, that one is probably a bug in hugs, or perhaps a difference in what is considered good for context reduction in the presence of MPTCs.
18:35:44 <dmwit> In GHC, constraints without variables are required to be discharged immediately.
18:36:05 <turab> Okay cool, thanks for helping with that!
18:36:20 <dmwit> (In Haskell, constraints without variables are required to be discharged immediately, but there are no MPTCs, so how this generalizes to MPTCs may not have been agreed on by both tools.)
18:37:19 <turab> Can you elaborate on constraints without variables are required to be dischared immediately?
18:37:19 <dmwit> (...and I've sometimes wished that rule weren't in place. At least that I could explicitly include such a context if I wanted to.)
18:37:39 <turab> Or a source where I can study that
18:37:48 <dmwit> Sure.
18:38:12 <dmwit> When you write e.g. `Ord Int`, GHC will immediately look in all the instances it knows about and verify that it does indeed know such an instance.
18:38:26 <dmwit> This is not so for `Ord a`, for example, because how could it? It doesn't know the value of `a` yet.
18:38:38 <dmwit> The difference here being that there is a variable in the second one but not the first.
18:39:02 <dmwit> In *most* cases this is really nice. It generalizes even further, in that if the outermost constructor used in the constraint is monomorphic it will do instance lookup.
18:39:44 <dmwit> So e.g. instead of inferring a type like `Ord (Tree [a]) => ...` it will notice that there's an `instance Ord b => Ord (Tree b)` and reduce that to `Ord [a] => ...`; then it will notice that there's an `instance Ord c => Ord [c]` and reduce it further to just `Ord a => ...`.
18:40:29 <dmwit> The general process of doing this is called "context reduction", and it's a pretty simple process really.
18:41:24 <dmwit> The spec says you must do it when the outermost part of the type is a type constructor (as opposed to a variable). Since `Succ` and `Zero` and `False` are all type constructors, it tries to reduce all the way.
18:41:45 <dmwit> When it finally reaches the context `EvenMP Zero F` it tries to reduce that, doesn't find an instance in its context, and throws its hands up.
18:42:04 <dmwit> This is where I intend to stop talking unless there are questions.
18:42:47 <turab> Nice. Sorry I was reading it slowly so I understand it properly
18:43:05 <dmwit> (err, "doesn't find an instance in its environment/list of instances", not "in its context")
18:43:51 <turab> So, is Hugs not reducing the type properly in the example?
18:44:37 <dmwit> Hm. Well, as I said, the spec only talks about single-parameter typeclasses. It's possible that hugs is reducing according to the rules in its documentation about how it implements this extension to the language spec.
18:45:08 <dmwit> ...and that GHC and hugs may have chosen different ways of extending the language.
18:45:19 <turab> Ahh interesting
18:45:25 <dmwit> So I guess it depends on what you mean by "properly". =)
18:45:54 <turab> I guess up there I meant "not as GHC does it"
18:46:18 <dmwit> Sounds like it.
18:46:19 <turab> Makes me kinda wanna try doing this as my compilers project next sem
18:46:35 <dmwit> That sounds fun!
18:47:03 <turab> So far I have inlining and typeclass stuff on my list and the list keeps growing!
18:54:16 <dmwit> You might like the "Typing Haskell in Haskell" paper by Mark Jones.
18:54:59 <turab> On the topic of this paper, so far I have been trying to find more similarities between functions and type level functions. Is it correct to see a Type class' definition as the type level function's type?
18:56:10 <turab> Cool, I will check it out
18:56:54 <dmwit> I'm sort of squinting at my screen over here, dithering over whether to answer "no" or "sort of".
18:57:16 <dmwit> I think you're onto something relevant, though I'm not sure I understand exactly what you're saying yet.
19:02:33 <turab> Ugh, I am struggling with rephrasing the question. Maybe understanding this topic better will help
19:05:21 <dmwit> Yay, we're both confused!
20:04:19 <fresheyeball> well boy oh boy am I learning a bundle from threadscope
20:05:25 <fresheyeball> apparently parallel gc is not a thing I want
20:19:09 <argent0> hi, you can't do `instance Foo a => Frob a; instance Bar a => Frob a`, can't you?
20:20:57 <solonarv> no, you cannot
20:21:15 <solonarv> when checking whether instances overlap, GHC only looks at the instance head - the part after the =>
20:21:33 <solonarv> your two instances have the same head 'Frob a', so they conflict
20:25:38 <argent0> solonarv: OK, thanks
20:25:56 <fresheyeball> is there a more elgant type theoryish way to model heirachies of overlapping instances instead of the dumb hamer of {-# OVERLAPS #-}
20:25:58 <fresheyeball> ?
20:29:31 <lyxia> 1) instance chains   2) type-level pattern-matching
20:30:54 <ski> 0) explicit records of "methods" ?
20:35:56 <hololeap> couldn't you do it with a singleton and DataKinds?
20:39:20 <fresheyeball> lyxia: Oooo
20:39:30 <fresheyeball> what would type level pattern matching look like?
20:39:36 <fresheyeball> that sounds amazing
20:40:05 <fresheyeball> also I just learned that my program is insanely unreasonably faster if I turn off parallel gc
20:41:49 <dmj`> anyone see this w/ 8.6.5.... ghc-8.6.5/rts/libHSrts_thr.a: error adding symbols: memory exhausted
20:41:56 <dmj`> during linking of an executable
20:45:48 * ski isn't sure what hololeap has in mind
20:46:26 * ski isn't really sure what fresheyeball, or argent0, really wanted to model with the overlapping instances, either, though ..
20:49:01 <fresheyeball> ski: to specify an order of decission
20:49:11 <fresheyeball> a type level pattern match sounds like it
20:49:12 <argent0> ski: `newtype Foo f a = Foo (f a)` ... `instance Monad m => Monad (Foo m)`. Idk, if it is even possible though
20:49:42 <ski> fresheyeball : doesn't tell me anything
20:50:25 <argent0> the thing is that "Foo `Compose` m" overlapped
20:50:26 <ski> argent0 : that looks possible, and is a thing people do, sometimes
20:50:30 <fresheyeball> ski: so lets say we have    instance (Monoid a, Monoid b) => Foobr a b
20:50:33 <fresheyeball> as well as
20:50:37 <ski> hm
20:50:50 <fresheyeball> instance (Monoid a, Monoid b) => Foobr (Maybe a) (Maybe b)
20:51:13 <fresheyeball> and we want to specify that the (Maybe _) version takes precidence 
20:51:23 <fresheyeball> if this was a pattern match, it would simply be north
20:51:33 <ski> do they have different behaviour ?
20:51:41 <fresheyeball> and reversal would render (Maybe _) unreacable
20:51:46 <fresheyeball> ski: yes
20:52:57 <lyxia> fresheyeball: https://blog.poisson.chat/posts/2018-06-06-hlists-dependent-haskell.html
20:54:44 <ski> if `Foobr' (nince name) is your own thing, which doesn't have too many instances whose resolutions you want to automate, you could consider `data Foobr a = MkFoobr {..a..}', and `genericFoobr :: (Monoid a,Monoid b) => Foobr a b' and `maybeFoobr :: (Monoid a,Monoid b) => Foobr (Maybe a) (Maybe b)'
20:55:02 <ski> (er, s/nince/nice/)
21:14:01 <fresheyeball> should I be scared to turn off parallel gc?
21:17:10 <argent0> ski: I'd like to see the `instance Monad m => Monad (Foo m)`
21:22:38 <ski> argent0 : `instance Monoid m => Monoid (Dual m)'
21:24:06 <dmwit> But presenting an order doesn't actually solve the problem originally proposed, which is to use the existence (or not) of a particular instance of *another* class to decide.
21:24:37 <dmwit> There is no order you can put `instance Bar a => Foo a` and `instance Baz a => Foo a` that "fixes" that problem.
21:25:01 * ski nods
21:41:02 * argent0 was missing basicaly `fmap (\(Foo x) -> x)`
21:42:19 <dmwit> err... huh?
21:45:37 <MarcelineVQ> fresheyeball: not if it improves your program
21:47:17 * argent0 instance Monad m => Monad (Foo m) where { (Foo ma) >>= f = Foo $ let q = f <$> ma in (\(Foo x) -> x) =<< q}
21:48:55 <fresheyeball> MarcelineVQ: is there risk of like a massive pause late in execution?
21:49:01 <fresheyeball> are there any risks?
21:49:06 <ski> argent0 : those brackets around the pattern in the operand are redundant
21:50:17 <argent0> ski: yes of course. "	Foo ma >>= f = Foo $ (\(Foo x) -> x) =<< (f <$> ma)
21:52:11 <ski> (also those brackets you just introduced around the call to `(<$>)', fwiw. if you have defined `Foo' with record syntax, you could use the field accessor instead of `\(Foo x) -> x')
21:54:04 <MarcelineVQ> fresheyeball: I'm not sure tbh
21:55:03 <MarcelineVQ> parallel can reduce gc time with large garbage sets but idk much beyond that
21:55:04 <ski> i'm curious about why you would want to do this (defining `(>>=)' in terms of `(>>=)' and `fmap')
21:57:29 <argent0> ski: Well I was playing type-tettris
21:59:44 <turab> Ha, type tetris
21:59:48 <turab> I like that
22:00:33 <MarcelineVQ> why extract x from Foo and wrap that back in Foo
22:02:16 <ski> basically, upto the `newtype', they're doing `\ma f -> id =<< f <$> ma', iow `\ma f -> join (fmap f ma)', with `join' defined as `\mma -> id =<< mma' as usual
22:04:04 <argent0> ski: Yes, but hlint was complaining: "Use =<< Found: join (fmap unFoo (f <$> ma)) Perhaps: (unFoo =<< (f <$> ma))"
22:04:06 <ski> (and hopefully this `fmap' is either defined directly, or in terms of `(<*>)' and `pure', rather than cyclically deferring back to `(>>=)' (and `return') (via `liftM', e.g.))
22:04:35 <ski> argent0 : yes ?
22:04:58 <argent0> yes
22:05:17 <ski> what about it ?
22:08:47 <argent0> nothing
22:09:06 <ski> okay
22:18:06 <fresheyeball> holy crap
22:18:11 <fresheyeball> this speed up my tests as well
22:18:17 <fresheyeball> by like 4x
22:18:30 <fresheyeball> parallel gc was killing it the whole time
22:18:39 <fresheyeball> -g1 ftw
22:19:05 <fresheyeball> so builds just got faster 
22:23:57 <MarcelineVQ> What is -g ?
22:24:19 <MarcelineVQ> Oh I see here, that's not gc realated though is it?
22:24:52 <fresheyeball> https://wiki.haskell.org/Performance/Parallel
22:24:56 <fresheyeball> MarcelineVQ: -g1
22:25:55 <MarcelineVQ> hmm I don't see that in the docs, wonder if it's been squirreled away in a 'related page' like some other rts options :<
22:30:27 <cocreature> MarcelineVQ: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html?highlight=qg#rts-flag--qg%20%E2%9F%A8gen%E2%9F%A9 I think -qg might be the more modern version of that flag and that is documented
22:38:10 <MarcelineVQ> fresheyeball, cocreature: thanks :>
23:00:16 <Vikfret> ski, hi
23:07:07 <ski> hello Vikfret ?
