00:10:56 <Rembane> sethetter: Sweet! IMHO, typed holes are one of the best features of Haskell.
00:26:26 <tdammers> why "typed holes" and not "type holes" btw.?
00:26:45 <tdammers> I've always considered them "holes in the type", not "holes that have a type"
00:29:38 <maerwald> we have to go deeper on the semantics here :>
00:30:35 <dminuoso> suzu: Also thank you, re-reading the MMR section finally made it click for me. :)
00:31:02 <dminuoso> suzu: By the way, notice how I used the term "simple pattern bindings"?
00:31:46 <suzu> yeah
00:32:41 <dminuoso> suzu: There are also general pattern bindings, such as ⌜p | gs2 = eq; | gs2 = e2 ... where { decls }⌝
00:33:53 <dminuoso> suzu: You may frequently see comments that "MMR can be fixed by supplying a type annotation" but that's not exactly true, as the above definition does not talk about non-simple pattern bindings.
00:34:37 <dminuoso> The way I read the report, any declaration group involving a non-simple pattern binding is restricted.
00:34:57 <Rembane> tdammers: I use both variants. :)
00:35:27 <dminuoso> The exact wording of the standard is: We say that a given declaration group is unrestricted if and only if: (a): every variable in the group is bound by a function binding or a simple pattern binding (Section 4.4.3.2), and (b) an explicit type signature is given for every variable in the group that is bound by simple pattern binding.
00:36:20 <dminuoso> So if MMR kicks in undesirably, then turning it into a) ⌜a function binding⌝ or b) ⌜a simple binding with a type signature⌝ are the only ways.
00:36:51 <dminuoso> If its a non-simple binding, you have to turn it into a simple binding (or function binding, if applicable)
00:52:20 <maerwald> it's not possible to overlap an instance with different typeclass constraints?
00:53:10 <maerwald> so same instance declaration, but different typeclass constraints
00:58:32 <Axman6> edwardk: you mention union find in your talk from monadic warsaw on guanxi, do you have a package for that somewhere?
01:06:25 --- mode: ChanServ set +q $a:Sir_Cheer
01:40:39 <asheshambasta> Feedback wanted: which one of these options? https://gist.github.com/asheshambasta/cdf4fc72a13d65cc8dfc00a502a2254e
01:41:58 <asheshambasta> Currently, I'm on Option1. But the major drawback that I see with that is that if 2 instances have the same ID type on the database (due to FK references, for example); I lose the ability to 'equate' their AffectedId types even if the underlying DBId's are the same. 
01:42:50 <asheshambasta> Since that would required `AffectedId a ~ AffectedId b`
01:53:02 <dminuoso> asheshambasta: The examples seem too elaborate at first glance, Im not even sure what you are trying to compare.
01:53:54 <Ariakenom> what are the ! in types? "SubAffectedReportable id => !id -> SubAffected"
01:54:10 <dminuoso> Ariakenom: strictness annotations?
01:55:06 <dminuoso> Ariakenom: Remember these are GADTs.
01:55:27 <Ariakenom> ah makes sense
01:59:13 <asheshambasta> dminuoso: So AffectedId is a type that is used to report ids that were affected. It can be a single level, or can be a tree of affected ids. 
01:59:56 <asheshambasta> in example 1, the AffectedId is parameterised over the type that is stored in the database, that is the type of `DBStorage myStoredType` 
02:00:35 <asheshambasta> in option 2, AffectedId has no relation to /what/ has been stored, but just its ID, that is `DBId myStoredType` 
02:01:38 <asheshambasta> I included the DBStorage class just to exemplify how AffectedId was being used. 
02:01:54 <asheshambasta> (namely in the `transact` etc. methods)
02:04:18 <asheshambasta> What I'd like to know/discuss is which one of these 2 options is a better abstraction. And as an example of why multiple ids can be affected doing a Database update is: say we're updating a User that has some Gallery images, that update would involve changing the name of the user, and adding the new images, deleting old images etc. In this case, your DB operation should be able to report all the ids that were affe
02:04:18 <asheshambasta> and several image ids etc. 
02:14:14 <asheshambasta> An example of what I'm  trying to avoid: https://gist.github.com/asheshambasta/cdf4fc72a13d65cc8dfc00a502a2254e#gistcomment-2962533
02:20:29 <dminuoso> asheshambasta: For me it's too elaborate and specific. A lot about it seems to be tied into the specific design of your application, and without knowing the thought processes that led you there, I personally find it hard to compare.
02:22:46 <solonarv> tdammers: we have both! if you write _hole in a term clearly that is a hole, and it has a type (which you will probably look at to figure out what should go in the hole), so it's a "typed hole"; if you write _hole in a type that is a hole *in* a type, so you could call it a "type hole"
02:23:36 <dminuoso> asheshambasta: e.g. what exactly is an "ID" for you? What is SubAffectedReportable? What's the point of SubAffected?
02:23:53 <solonarv> I suppose you could call the latter "kinded holes", but usually you don't end up playing kind tetris to figure out what should go there - instead you are just asking GHC to tell you, since it has probably figured that out as part of type inference/checking anyway
02:24:12 <dminuoso> asheshambasta: Overall I dont fully understand what AffectedId is trying to solve for you.
02:25:08 <dminuoso> asheshambasta: Also instead of DBIdentity as a class, couldn't you use a type family? 
02:25:32 <asheshambasta> dminuoso: An ID is the haskells side of the stored sqls ID in some DB table. For example; a `newtype UserId = UserId Int` is an integer id for the user, stored as an int in the databse and we have its haskkells equivalent, the newtype. The DBStorage typeclass lets you define all of that. 
02:26:00 <noipmusp> Do I remember correctly that there is a way to embed cabal definition in a .hs file?
02:26:37 <dminuoso> asheshambasta: "stored sqls ID" ?
02:26:40 <noipmusp> I just need a simple Haskell script with single dependency.
02:26:57 <asheshambasta> AffectedId is a way to report the tree of affected ids. SubAffectedReportable is another class that all ids that may be affected underneath a larger update, must implement. And SubAffected is a GADT that wraps that up along with the constraints required to 'report' the affected ids. 
02:27:37 <dminuoso> asheshambasta: I still find the word "id" to be very confusing. Perhaps thats just me.
02:27:38 <asheshambasta> In my user example above, the `DBId Image` will need to be an instance of SubAffectedReportable in ordeer to be reported with the updated user. 
02:27:58 <dminuoso> `id` is a type, which types does it encompass?
02:28:23 <dminuoso> What types yield valid instances of SubAffectedReportable?
02:28:59 <dminuoso> Is `id` meant to represent a database mappable type?
02:29:42 <asheshambasta> dminuoso: yes. In the user example, an ImageId will need to be an instance of SubAffectedReportable 
02:29:51 <dminuoso> asheshambasta: Could Id be also some string?
02:29:58 <asheshambasta> yeah 
02:30:08 <dminuoso> asheshambasta: So the word "id" should rather read "ty" ?
02:31:04 <asheshambasta> I can have: instance DBStorage User where type DBId User = UserId (where UserId is a newtype over Int); as well as instance DBStorage Company where type DBId Company = Text; etc. 
02:31:15 <asheshambasta> dminuoso: why "ty"? 
02:31:31 <dminuoso> asheshambasta: Perhaps its just me, but the word "id" signals "identity"
02:31:40 <dminuoso> or "identifier"
02:31:58 <dminuoso> But what you seem to be on about is just some arbitrary type that somehow relates to a database type.
02:32:08 <hvr> noipmusp: yes, there is
02:32:13 <asheshambasta> I'm using in the latter sense: it is a unique identifier for something that is stored in the dB. 
02:32:26 <dminuoso> asheshambasta: In what sense is it unique?
02:32:36 <noipmusp> hvr: How do I summon this feature?
02:32:39 <dminuoso> asheshambasta: Is there a 1:1 correspondence between haskell type and *table*?
02:32:43 <hvr> noipmusp: it's described here: https://cabal.readthedocs.io/en/latest/nix-local-build.html#cabal-v2-run
02:32:47 <asheshambasta> in the value it contains 
02:33:09 <noipmusp> hvr: Thank you very much! I was unable to Google it.
02:34:20 <dminuoso> asheshambasta: Let ma ask differently. DBIdentity is morally just a type family (why is it not a type family by the way?). What does it map between?
02:36:26 <dminuoso> asheshambasta: The term "id" is still terribly confusing for me.
02:36:42 <asheshambasta> dminuoso: can type families be arbitrarily 'extended'? 
02:37:09 <dminuoso> asheshambasta: Sure, a type family can be open.
02:37:59 <asheshambasta> + DBIdentity is a way to also get the `DBId stored` from `stored`
02:38:04 <dminuoso> asheshambasta: Or if I consider dbId to be useful (which I still dont know what its for), then the whole typeclass boils down to `class Convertible f t where convert :: f -> t`
02:38:10 <dminuoso> So what's the conversion here?
02:38:24 <asheshambasta> I should rename this to `HasDBId` from `DBIdentity` 
02:38:32 <dminuoso> Or class `Convertible f t | f -> t where convert :: f -> t` I guess
02:39:01 <dminuoso> asheshambasta: What kind of database is this?
02:39:12 <asheshambasta> postgres 
02:39:37 <dminuoso> asheshambasta: Can we make it concrete for a moment? What does for example `newtype UserId = UserId Integer` map to in this HasDBId?
02:39:41 <dminuoso> What's an example instance?
02:40:19 <asheshambasta> ok, adding a gist 
02:43:47 <asheshambasta> dminuoso: https://gist.github.com/asheshambasta/cdf4fc72a13d65cc8dfc00a502a2254e#file-example-hs
02:44:58 <dminuoso> asheshambasta: So HasDBI is communicating "the primary key has type int, and `dbId` is how you obtain that key"?
02:45:02 <dminuoso> Sort of?
02:45:10 <asheshambasta> correct 
02:47:12 <dminuoso> asheshambasta: I take it that whatever `DBId` maps to must satisfy extra constraints?
02:47:54 <dminuoso> Oh that's implied by DBStorage. Okay I think I see what this is about.
02:48:35 <dminuoso> asheshambasta: Can you explain what the "hierarchy" is about in AffectedId now?
02:48:49 <dminuoso> What are "top level ids"?
02:50:16 <asheshambasta> In that example, lets assume that a single UserId can have access to multiple companies, represented (and abstracted on the DB) using a join table: Column UserId | Column CompanyId 
02:51:44 <asheshambasta> Say there is a DBUpdate that: 1. updates the user's name, and 2. updates the company names accordingly. Now, the `transact` method, does all of this in a single database transaction. Hoever, since we are operating at the level of `DBStorage User`, and we'd like to report all of these affected ids in the update, we must represent it as a tree of AffectedId: which will, report the user id at the top level, and conta
02:51:44 <asheshambasta> CompanyId list. 
02:53:27 <asheshambasta> dminuoso: https://gist.github.com/asheshambasta/cdf4fc72a13d65cc8dfc00a502a2254e#file-example-hs-L15
02:56:42 <kuribas> Anyone read the little typer?
02:56:50 <kuribas> And proved things in it?
02:57:08 <kuribas> Or formally proved anything in any language?
03:36:09 <Woody88> Hi, anyone understands why this piece of code https://github.com/Woody88/monitoring-tool/blob/master/monitoring-server/src/Database.hs#L29 seem to make this piece of code https://github.com/Woody88/monitoring-tool/blob/master/monitoring-server/src/Application.hs#L64 hang when a user ctrl+c
03:59:26 <Ariakenom> % "hello"
03:59:27 <yahb> Ariakenom: "hello"
04:01:40 <cocreature> What exactly does putting an INLINE pragma on a class method do? Is it equivalent to putting it on every instance?
04:01:44 <cocreature> Or is it just ignored?
04:04:17 <cocreature> ah no it looks like it applies to the default definition
04:18:39 <bitonic> I vaguely remember a library to generically traverse template haskell definitions -- for example to find all types mentioned in a TH Type, which is what I need to do. Did I dream of this or does it actually exist?
04:22:04 <bitonic> with "all types" I mean "all type names" here
04:45:24 <lyxia> there's th-abstraction which normalizes type definitions but that might not be what you want.
04:49:46 <coffeecow> I've started learning Haskell recently according to Learn You a Haskell (of course) and I'm reading the Higher Order Functions section and currying is kind of whopping my ass. Here's what I need help understanding: https://bpaste.net/show/JFh_
04:51:59 <ski> there is no "curried function" in Haskell. functions can be written in "curried style", though
04:52:28 <ski> conceptually, we can think of functions that have multiple parameters, take multiple inputs
04:52:38 <ski> however, in Haskell, all functions take exactly one input
04:52:58 <ski> still, we can *encode* a (conceptually) multiple-argument function, in Haskell
04:53:28 <ski> in face, we can do this in a couple of different ways, one is "curried style", another may be called "tupled style"
04:54:04 <ski> let's say we want to encode a function that takes three integers, and gives back the middle one, after ordering them
04:54:52 <ski> so, given inputs `x',`y',`z', if we order those into `a',`b',`c' (renaming them), so that `a =< b =< c' holds, we want our function to result in `b'
04:56:31 <ski> one way to compute that `b' from `x',`y',`z' is `maximum [min x y,min x z,min y z]'
04:57:16 <ski> (it would also be possible to express this `b' by comparing in turn, two numbers out of `x',`y',`z', and then comparing two other of those, and so on .. but that's not as symmetric, and elegant, as the above, using `min' and `maximum'. btw, one could also use `minimum [max x y,max x z,max y z]')
04:57:51 <ski> so .. encoding this multiple-argument function `x,y,z |-> maximum [min x y,min x z,min y z]' in Haskell
04:58:33 <ski> in "tupled" style, we'd encode the multiple arguments by putting them all into a single, compound, argument, like a tuple (or record, or list, or other compound structure, like perhaps some kind of collection)
04:58:41 <ski> so, we could write
04:59:05 <ski>   tupledMiddle :: (Integer,Integer,Integer) -> Integer
04:59:13 <ski>   tupledMiddle (x,y,z) = maximum [min x y,min x z,min y z]
05:00:10 <ski> really, we have only one argument (formal parameter, aka pattern) here, `(x,y,z)', but by pattern-matching we "take it apart" into three parts, which are our conceptual "three arguments"
05:00:23 <ski> it would also have been possible to write something like
05:01:25 <ski>   tupledMiddle xyz = maximum [min (fst3 xyz (snd3 xyz),min (fst3 xyz) (thd3 xyz),min (snd3 xyz) (thd3 xyz)]
05:01:28 <ski> or
05:01:44 <ski>   tupledMiddle t = maximum [min (fst3 t) (snd3 t),min (fst3 t) (thd3 t),min (snd3 t) (thd3 t)]
05:02:15 <ski> (given obvious selection functions `fst3',`snd3',`thd3' that extracts one of the three components of a triple)
05:02:36 <ski> but these are hardly more readable. using pattern-matching to access parts is commonly preferable
05:03:00 <ski> now, for the "curried style" encoding of multiple-argument functions
05:05:14 <ski> in curried style, you have a function that takes the first of your (conceptual) multiple arguments (or an initial segment of them) as input, and results in an output being a *new* function that will (conceptually) accept all the remaining multiple arguments (this new (possibly) multiple argument function is probably also being encoded in curried style)
05:05:29 <ski> in our example, this could look like
05:05:48 <ski>   curriedMiddle :: Integer -> (Integer -> (Integer -> Integer))
05:05:58 <ski>   curriedMiddle x y z = maximum [min x y,min x z,min y z]
05:07:03 <ski> (notice that `curriedMiddle x y z' means `((curriedMiddle x) y) z'. so you're passing `x' to `curriedMiddle', getting back a new function that you pass `y' to, getting back a new function that you pass `z' to, then finally getting back the middle number of the three inputs, wrt the ordering of them)
05:07:24 <ski> one could have defined `tupledMiddle' as
05:07:35 <ski>   tupledMiddle = \(x,y,z) -> maximum [min x y,min x z,min y z]
05:07:39 <ski> or as
05:07:49 <ski>   tupledMiddle = \t -> maximum [min (fst3 t) (snd3 t),min (fst3 t) (thd3 t),min (snd3 t) (thd3 t)]
05:09:49 <ski> emphasizing that we're defining `tupledMiddle' to be a function (value) described by `\(x,y,z) -> ..x..y..z..' or by `\t -> ..t..', rather than *indirectly* defining the function `tupledMiddle' by defining what result it (`tupledMiddle (x,y,z)' or `tupledMiddle t') will output, for every possible input (`(x,y,z)' or `t')
05:10:01 <ski> similarly, we could have defined `curriedMiddle' as
05:10:12 <ski>   curriedMiddle = \x y z -> maximum [min x y,min x z,min y z]
05:10:21 <ski> however, this is shorthand for
05:10:30 <ski>   curriedMiddle = \x -> \y -> \z -> maximum [min x y,min x z,min y z]
05:10:31 <ski> or
05:10:38 <ski>   curriedMiddle = \x -> (\y -> (\z -> maximum [min x y,min x z,min y z]))
05:10:47 <ski> if you want explicit bracketting
05:12:02 <ski> so, we have a function (that when called is) taking an input, call it `x', outputting a function (that when called is) taking an input, call it `y', outputting a function (that when called is) taking an input, call it `z', outputting the result of a certain expression `..x..y..z..'
05:12:17 <ski> btw, note that the type signature
05:12:23 <ski>   curriedMiddle :: Integer -> (Integer -> (Integer -> Integer))
05:12:29 <ski> can be abbreviated as
05:12:34 <ski>   curriedMiddle :: Integer -> Integer -> Integer -> Integer
05:12:54 <ski> (similarly to how `((curriedMiddle x) y) z' can be abbreviated as `curriedMiddle x y z')
05:14:26 <ski> (it is also possible to mix curried and tupled style. you might e.g. have `foo :: (Int,Int) -> (Int,Int) -> (Int,Int)', packing some of the multiple arguments together into pairs (two-tuples), then taking those pairs "one at a time", in curried style)
05:14:34 <ski> coffeecow : does this ^ make any sense ?
05:15:58 <ski> coffeecow : also, many people here consider LYAH not that good a tutorial / learning material. it has been likened to a four-hour long trailer. it has been criticized for not going deep (or being thorough) enough in its explanations, and also for lacking exercises
05:16:09 <ski> if you want exercises, you could try e.g.
05:16:13 <ski> @where CIS194
05:16:14 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
05:17:15 <ski> there are also textbooks, like "Haskell: The Craft of Functional Programming" by Simon Thompson (which i learned from)
05:17:21 <ski> @where PIH
05:17:21 <lambdabot> "Programming in Haskell" by Graham Hutton in 2007-01-15,2016-09-01 at <http://www.cs.nott.ac.uk/~pszgmh/pih.html>
05:17:31 <ski> @where SOE
05:17:32 <lambdabot> "The Haskell School of Expression: Learning Functional Programming through Multimedia" by Paul Hudak in 2000 at <http://www.cs.yale.edu/homes/hudak/SOE/>,<http://haskell.org/soe/> [broken]
05:17:35 <ski> @where HR
05:17:36 <lambdabot> "The Haskell Road to Logic, Maths and Programming", by Kees Doets,Jan van Eijck, at <http://homepages.cwi.nl/~jve/HR/>
05:17:44 <ski> @where HTAC
05:17:44 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
05:17:55 <ski> @where wikibook
05:17:55 <lambdabot> http://en.wikibooks.org/wiki/Haskell
05:18:25 <ski> @where HPFFP
05:18:26 <lambdabot> "Haskell Programming: from first principles - Pure functional programming without fear or frustration" by Chistopher Allen (bitemyapp),Julie Moronuki at <http://haskellbook.com/>,#haskell-beginners
05:19:06 <nil> HR seems to be a 404
05:21:00 <ski> oh, i wonder what's up with that. ty for noticing !
05:22:12 <ski> @where+ HR "The Haskell Road to Logic, Maths and Programming", by Kees Doets,Jan van Eijck, at <http://homepages.cwi.nl/~jve/HR/> (broken ?),<https://web.archive.org/web/20190528043209/https://homepages.cwi.nl/~jve/HR/>
05:22:12 <lambdabot> It is stored.
05:22:37 <hyperisco> I need to coordinate multiple hosts to operate in lockstep. Is this studied by distributed programming or where else should I look?
05:22:42 <coffeecow> oof
05:23:59 * ski stares at coffeecow
05:24:06 <Ariakenom> coffeecow: this "addTwo = \x -> \y -> x + y" is the same as this "addTwo = \x y -> x + y"
05:28:08 <coffeecow> i am still re-reading it again because i'm trying to hammer this into my head
05:32:44 <Rembane> coffeecow: Has someone told you that ghc evaluates ( addTwo 5 ) to this function: \y -> 5 + y
05:35:12 <Ariakenom> coffeecow: to attack it from another angle: this part "that function takes an anonymous
05:35:13 <Ariakenom> function \x whose [...]" is wrong. x is an argument
05:36:31 <coffeecow> this is helping me understand more
05:38:02 <Ariakenom> "abs x = [...]" is the same as "abs = \x -> [...]"
05:38:06 <coffeecow> i now understand like `addTwo x y` is `((addTwo x) y)` and now that why `addTwo = \x -> \y -> x + y` has x and y defined as uh anonymous functions is because `\x` is the uh partial result of applying `x` to addTwo and then `y` is the anonymous function result of applying `y` to the aforementioned anonymous function?
05:40:09 <halogenandtoast> Is there an obvious way to fix the ambiguity here? https://gist.github.com/halogenandtoast/10db17eeeee8121e20edbe3c64c34ce3
05:41:15 <halogenandtoast> I also might be designing poorly and if that's the case I'd be happy to do it differently
05:42:02 <jgt> halogenandtoast: this is a bit of a non-answer, but have you tried doing this with typed holes instead of undefined?
05:42:14 <dminuoso> halogenandtoast: The problem lies in updateGame
05:42:44 <Ariakenom> coffeecow: no. "\x -> 1" is a function that takes x as an argument and returns 1
05:42:55 <dminuoso> halogenandtoast: What type should `a` be?
05:43:05 <dminuoso> halogenandtoast: What should be inferred for it?
05:43:20 <halogenandtoast> dminuoso: It should just have a constraint of Action
05:43:26 <dminuoso> halogenandtoast: Yeah but which?!
05:43:53 <halogenandtoast> It can be any Action, if it doesn't match the game it's id
05:44:03 <dminuoso> halogenandtoast: And GHC should throw some dice?
05:44:09 <dminuoso> halogenandtoast: And pick a random type?
05:45:06 <halogenandtoast> dminuoso: I tried to tell it forall a, but it wasn't happy about that either.
05:45:27 <halogenandtoast> I want a generic interface for games, i.e. tic tac toe, chess, checkers, etc.
05:45:35 <halogenandtoast> but I might be trying too hard here
05:45:48 <dminuoso> halogenandtoast: Remember in polymorphic values its the *caller* that makes a choice.
05:46:22 <dminuoso> halogenandtoast: Since `updateGame :: Action a => a -> g -> g` the consumer of the return type cant make that choice.
05:46:57 <coffeecow> so  `addTwo = \x -> \y -> x + y` is saying `addTwo` is: an anonymous function that takes `x` and returns another function that takes `y` and gives back the value `x+y`?
05:47:00 <ski> coffeecow : no, `x' and `y' there are not functions
05:47:08 <dminuoso> halogenandtoast: I think that `getAction :: Action a => m a` has the wrong type.
05:47:24 <dminuoso> halogenandtoast: Since that says "Im going to extract a polymorphic action"
05:47:29 <coffeecow> *another anonymous function that takes `y`
05:47:54 <dminuoso> halogenandtoast: can your game contain polymorphic actions?
05:48:07 <dminuoso> halogenandtoast: Where do you want the choice of "which action is chosen" to happen?
05:48:13 <hyperisco> halogenandtoast, have you read https://web.archive.org/web/20150423212235/community.haskell.org/~ertes/hangman/ ?
05:48:30 <halogenandtoast> Each game would have a set of valid Actions, and I see your point, the type wouldn't work
05:48:32 <ski> `\x -> \y -> x + y' and `\y -> x + y' are "anonymous functions". i prefer saying (they (those program phrases) compute) "function values", "functions", or (are) "function expressions", "function abstractions"
05:48:44 <Axman6> coffeecow: That explanation sounds correct to me
05:49:00 <dminuoso> halogenandtoast: so perhaps you mightt want `class RunGame m a | m -> a where ...` ?
05:49:01 <halogenandtoast> hyperisco: I have not
05:49:04 <dminuoso> (or via associated type family)
05:49:11 <ski> coffeecow : fwiw, would you say `[2,3,5,7]' is an "anonymous list" ?
05:50:04 <dminuoso> ski: fwiw "anonymous" is the term coined by programmers not used to the idea of having functions as first class values, since they have the notion of functions having names so deep written into the brains.
05:51:41 <dminuoso> halogenandtoast: Although that wont fit well with Game. there's something off
05:52:01 <halogenandtoast> dminuoso: So that works, but I think I'd want to bind the actual game in there as well
05:52:02 <ski> dminuoso : yes, that's a further reason why i prefer not using that term ;)
05:52:40 <dminuoso> ski: It also begs the question: is `f = \x -> x` an anonymous function? :o)
05:52:45 <halogenandtoast> `class RunGame m g a | m g -> a where` or something like that
05:52:48 <dminuoso> I should ask that the next person.
05:53:03 <dminuoso> halogenandtoast: Why not put it into the Game class?
05:53:13 <ski> (i'd say it also appears that at least some mathematicians (or at least some people doing math more frequently ?) also seem to have it ingrained that functions are to have names, at least if you speak about particular ones)
05:53:21 <halogenandtoast> dminuoso: I'll try that
05:53:48 <ski> dminuoso : it's not an expression (capably of possibly denoting a value, like a function), it's a declaration :)
05:54:04 <dminuoso> ski: well pointing at the innard lambda of course.
05:54:05 <ski> (`f(x) = x^2' is not a function)
05:54:20 <dminuoso> ski: It'd be quite a joke in Haskell since I tend to think of "declarations" as just naming expressions.
05:54:43 <ski> dminuoso : well, that is part of the disambiguation i'd like such people to perform
05:55:06 <dminuoso> ski: My point is, the term "anonymous function" would be appropriate since I have just named it!
05:55:08 <dminuoso> :-P
05:55:19 <ski> appropriate or inappropriate ?
05:55:31 <dminuoso> *inappropriate indeed.
05:56:02 <dminuoso> ski: On that basis, the term "anonymous ..." can be useful if we want to distinguish between things we have bound to identifiers and things we have not bound to identifiers.
05:56:17 <dminuoso> Though I doubt people using the term "anonymous function" are trying to make that particular distinction.
05:56:19 <ski> if you want to name a function, in the privacy of your home, who am i to object, or care ? if it's not being made known to me, it's irrelevant :)
05:56:35 <ski> (and obviously different people may decide to name the same value in different ways)
05:57:03 <dminuoso> halogenandtoast: And at that point, just make it a data type instead.
05:57:04 <ski> dminuoso : maybe .. i'm not really convinced, though :)
05:57:22 <Ariakenom> 2 = 1 -- old hack don't change
05:57:49 <solonarv> > let 2 = 1 in "huh"
05:57:51 <lambdabot>  "huh"
05:58:08 <ski> > let !2 = 1 in "fuh"
05:58:10 <lambdabot>  "*Exception: <interactive>:3:5-10: Irrefutable pattern failed for pattern 2
05:58:40 <coffeecow> wow thanks y'all this really helped me a lot.
05:58:45 <dminuoso> halogenandtoast: data Game m a = Game { runGame :: m (); updateGame :: a -> m (); gameOver :: m Bool }
05:59:13 <coffeecow> i kind of am starting to see what the author said about how in haskell you define what something is instead of how to get it
05:59:23 <dminuoso> halogenandtoast: You know, just to contain the typeclass abuse you are stepping into. ;)
06:00:41 * Ariakenom hands coffeecow a lambda pin and claps
06:00:59 <dminuoso> Ariakenom: Oh yes. Lambda pins, we should get those at Haskell eXchange.
06:01:03 <halogenandtoast> dminuoso: I'll try it out and think about it
06:01:33 <ski> % let (id &&& id -> (~2,~(I# n))) = 1 in "meh"
06:01:33 <yahb> ski: ; <interactive>:62:24: error:; A lazy (~) pattern cannot bind variables of unlifted type.; Unlifted variables:; n :: Int#
06:01:38 <ski> that's a new one
06:01:50 <ski> % let (id &&& id -> (~2,I# n)) = 1 in I# (n -# 1#)
06:01:51 <yahb> ski: 0
06:01:53 <ski> % let (id &&& id -> (2,I# n)) = 1 in I# (n -# 1#)
06:01:53 <yahb> ski: *** Exception: <interactive>:64:5-31: Non-exhaustive patterns in pattern binding
06:02:06 <dminuoso> ski: The diagnostic is self explanatory though.
06:02:23 <ski> indeed. however, one can wonder then why
06:02:32 <ski> % let I# n = 1 in "huh"
06:02:32 <yahb> ski: "huh"
06:02:34 <ski> works
06:02:44 <Ariakenom> dminuoso: apparently there is some lambda cryptocurrency so I cant search for it. I knew cryptos were evil
06:02:49 <Ariakenom> dminuoso: but please do
06:03:15 <dminuoso> ski: My first instinct was "this makes perfect sense", if its unlifted then you can't possibly have any lazy semantics attached to it.
06:04:14 <dminuoso> unlifted means bottom is unrepresentable
06:04:43 <coffeecow> thank you so much Ariakenom :) <3 i really appreciate your help. on another note i'd love to go to a haskell meetup
06:04:55 <coffeecow> i'm afraid im too slow on the uptake of these things and too much of a noob
06:05:02 <alex31415> is there a haskell version of this : https://gist.github.com/lazywithclass/6af94f652cd59796e9592a5ea5772d17
06:05:59 <blairzqg8> hi, we are a world wide pimp pista, we can manage you ladies, boys or lady boys within an hour to your door at any part of the world... with cheapest prices ... warranty no cat fish.... call us NOW on this number +66860962192 !
06:07:01 <halogenandtoast> dminuoso: "typeclass abuse" are you implying that using a data type will allow me to avoid the abuse, or assist with the abuse? I'd like to write something reasonable here
06:07:11 <ski> dminuoso : yes, but `let x = ... in ...' is distinct from `let !x = ... in ...'. so one could assume that the first is `let ~x = ... in ...'. and that this would also hold when `x' is replaced by patterns (but not by definienda, as when defining functions). however, that's apparently not the case
06:07:16 <ski> % let ~(I# n) = 1 in "huh"
06:07:17 <yahb> ski: ; <interactive>:67:6: error:; A lazy (~) pattern cannot bind variables of unlifted type.; Unlifted variables:; n :: Int#
06:07:18 <dminuoso> halogenandtoast: It will let you avoid the abuse.
06:07:26 <ski> @quote R2RS
06:07:26 <lambdabot> R2RS says: Data and procedures and the values they amass, / Higher-order functions to combine and mix and match, / Objects with their local state, the messages they pass, / A property, a package,
06:07:26 <lambdabot> the control point for a catch-- / In the Lambda Order they are all first-class. / One Thing to name them all, One Thing to define them, / One Thing to place them in environments and bind them, / In
06:07:26 <lambdabot> the Lambda order they are all first-class.
06:07:33 <dminuoso> halogenandtoast: In many cases people use typeclasses, a data record works just as well and causes less confusion and pain.
06:07:36 <ski> coffeecow ^
06:08:16 <Axman6> alex31415: what specifically do you want to see of that in haskell?
06:08:38 <halogenandtoast> dminuoso: in your Game example, you had updateGame :: a -> m (), but how would that affect internal state of the game?
06:08:52 <dminuoso> halogenandtoast: Each game would specify.
06:09:09 <dminuoso> Game { updateGame = ... specify here, ... }
06:09:43 <halogenandtoast> sure, but it seems like that data would be lost with a return of m ()
06:09:55 <halogenandtoast> Unless we used a fancier m than IO
06:10:00 <alex31415> Axman6 i was wondering how haskell version would look like, maybe someone have done it
06:10:14 <halogenandtoast> StateT or something, I would assume
06:10:17 <dminuoso> halogenandtoast: It gives you the choice for various monads to run in.
06:10:20 <Axman6> m looks awfully monadic to me, so it can hold the state if it wants
06:10:39 <dminuoso> pokerGame :: Game (StateT CardStack IO); pokerGame = Game { ... }
06:10:50 <dminuoso> Oh well missing the action
06:11:06 <dminuoso> pokerGame :: Game (StateT CardStack IO) PokerAction; pokerGame = Game { ... }
06:12:15 <halogenandtoast> dminuoso: Okay, thanks for your help, I'll want to mess with this for a while
06:19:51 <manek> Hi guys! This is a theoretical question, but assuming lack of MonadFix, is it possible to translate every non tail call recursion to tail call CPSed one?
06:22:47 <coffeecow> ski i'll save that...
06:23:11 <coffeecow> thanks everyone i gotta go to bed.
06:23:38 <ski> manek : yes, for a closed expression/definition / as a global transformation. this is called CPS transformation. if you use free variables, they may also have to be replaced by CPS versions
06:24:03 <Boarders> Is there any way I can use hlint or some similar tool to give a warning when a specific instance of a typeclass function is used
06:24:15 <Boarders> In particular I want to warn against the use of fromList from Data.Vector?
06:24:23 <manek> ski: by "closed" expression you mean compile time known shape of the function right?
06:25:42 <ski> i mean doesn't depend on any free variables
06:26:57 <ski> e.g. `\k -> k x' is not closed, because `x' is a free variable. and `\x -> x + x' is not closed, because `(+)' is a free variable
06:28:55 <ski> you could CPS-transform `\x -> add (add x x) x' to `\x k -> addCPS x x (\y -> addCPS y x k)', where the free variable `add', of say type `Integer -> Integer -> Integer', has been replaced by the free variable `addCPS', of type `forall o. Integer -> Integer -> (Integer -> o) -> o'
06:30:01 <ski> so, if the code you're CPS-transforming depends on a library, you'll (in general, at least) also have to CPS-transform that library (requiring its source)
06:30:08 <manek> ski: makes perfect sense, thank you <3
06:30:34 <manek> I also understand that in case of MonadFix there is not alwasys possible to CPS functions right?
06:30:38 <ski> also, you may need to get CPS versions of the primitive operations (like `addInt :: Int -> Int -> Int') provided by the implementation
06:30:53 <ski> in that case, one could just define `addIntCPS x y k = k (addInt x y)'
06:31:21 <ski> but that'd be harder to do, for a primitive operation that is higher-order
06:31:40 <ski> manek : why not ?
06:34:21 <manek> ski: I dont know tbh. As stupid as it sounds, I was feeling so. I think Ive been reading about some corner cases in the past but I cannot think about concrete examples now. I think that some monad transformer stacks when used with MonadFix was preventing the CPS transformation but I could be totally wrong here
06:35:27 <ski> Boarders : dunno. perhaps check out <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#warning-and-deprecated-pragmas>
06:36:04 <ggole> Primitives are often treated as atomic in CPS form, since there's no interesting control flow at all. I suppose whether you make that choice depends on what you are trying to achieve.
06:36:14 <ski> i'm not sure you can apply it to definitions you don't have control over, though. perhaps one can attach them to rexports, maybe ?
06:36:51 <ski> ggole : how about a primitive like `tabulate :: (Int,Int) -> (Int -> a) -> Array Int a' ?
06:37:10 <ggole> That wouldn't be a primitive.
06:37:36 <ski> it could be ?
06:37:42 <ggole> At least, not from the perspective of CPS transformation.
06:38:11 <ski> what if you don't want to expose an interface where the elements are not initialized ?
06:38:27 <ggole> The issue being that CPS involves adding an argument to functions, including the function which is passed as an argument there.
06:38:39 <ski> (and you don't want to initialize to some "zero" value, because we're being polymorphic in `a', which might be an empty type)
06:38:49 <ski> ggole : exactly my point
06:39:01 <ski> the contravariance screws the wrapping i did in `addIntCPS' up
06:43:08 <manek> ski: thank you so much for the explanation and the help! <3
06:44:10 <ski> np
06:45:40 <afontain[m]> Hi. I've got a question, is it possible to have a type that boxes one of its info inside the same monad as itself ?
06:45:41 <afontain[m]> I tried some variants of, but none did work
06:45:42 <afontain[m]> `data m A = m A B (m C)`
06:46:47 <ski> what is "the same monad as itself" ?
06:47:44 <afontain[m]> well, I can still do `data A = m A B (State Int C)` and that would work for me
06:48:02 <afontain[m]> > what is "the same monad as itself" ?
06:48:03 <afontain[m]> the same monad it is itself in
06:48:06 <lambdabot>  <hint>:1:37: error:
06:48:06 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
06:48:08 <afontain[m]> I'm not sure it makes more sense
06:48:31 <ski> afontain[m] : that doesn't work. the data constructor `m' doesn't start with an upper case letter
06:49:00 <ski> afontain[m] : it doesn't make any more sense to me, at least
06:49:10 <ski> what is "it"
06:49:19 <ski> ?
06:49:21 <ski> why are you even talking about monads ?
06:49:21 <afontain[m]> sorry, meant `data A = A B (State Int C)`, I corrected only the first half
06:50:07 <afontain[m]> the not-so-great thing here, is that the C is in a monad even if the A isn't
06:51:01 <ski> i still have no idea what you're trying to accomplish, or what the perceived problem is
06:51:28 <ski> by "C is in a monad", i assume you mean that you have passed `C' to the monad `State Int'
06:51:51 <afontain[m]> that's what I meant
06:51:56 <afontain[m]> I'm quite unsure about the term
06:52:04 <ski> btw, i'd prefer it if you didn't use the same name for the type constructor as for the data constructor, e.g. say instead `data A = MkA B (State Int C)'
06:52:31 <ski> now, the `A' in "even if the A isn't" .. does it refer to `A' or `MkA', in my renamed version ?
06:54:28 <afontain[m]> I think it would be the A, as there is function with signatures such as:
06:54:29 <afontain[m]> `f :: S A -> …`
06:54:53 <afontain[m]> (with `type S = State Int`)
06:55:24 <dmwit> ?let newtype Weird a = Weird { normal :: State (Weird a) a }
06:55:28 <lambdabot>  Defined.
06:55:31 <dmwit> :t Weird
06:55:33 <lambdabot> State (Weird a) a -> Weird a
06:55:34 <ski> ok, so there you have "A is in a monad"
06:55:36 <dmwit> afontain[m]: Something like that?
06:55:39 <halogenandtoast> dminuoso: When using a data type like you mentioned before, how could I call other functions in that data type, while I have access to the state, I don't have access to the "instance" https://gist.github.com/halogenandtoast/7a7de3315843439c18baa9a489600fc4
06:56:07 <ski> afontain[m] : now, what does `f :: State Int A -> ...' have to do with the definition of `A' ?
06:56:29 <afontain[m]> this `x :: S A` is what you would call a monadic value ?
06:56:39 <ski> yes
06:56:45 <ski> or monadic action, or `S'-action
06:57:13 <halogenandtoast> Would I just pass ticTacToe again, since one instance is as good as another?
06:57:39 <ski> sometimes, (monadic) computation/"recipe" .. in some cases "collection" may be appropriate. i've also heard "context", though i'm not too fond of that
06:57:49 <dmwit> halogenandtoast: fix $ \(Game run update over) -> Game { runGame = ... over, ... }
06:58:18 <dmwit> halogenandtoast: Or `ticTacToe = Game { runGame = ... gameOver ticTacToe, ... }`.
07:00:55 <halogenandtoast> dmwit: thanks, I was thinking of using the second, it just feels weird due to the StateT, it feels like the state would be "lost", but thats the OOP talking
07:01:42 <dmwit> Ah. I can understand why you'd have that gut reaction. But it's not reflective of reality.
07:03:59 <halogenandtoast> dmwit: yup, I know, it's all in the same runStateT
07:06:45 * afontain[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/BEyNbuoaOqHfpCozflEUgBgW >
07:06:50 <afontain[m]> I'm not sure whether this is possible
07:08:12 <afontain[m]> dmwit doesn't seems like it :-/
07:09:22 * ski sends a short message
07:10:25 <afontain[m]> I'm trying to make a short example
07:10:26 <ski> afontain[m] : perhaps you want `data A f = MkA (f (B f))' ?
07:10:49 <ski> then you could say `A S' and `A Identity'
07:15:36 <afontain[m]> That looks much better, I'll play around a bit
07:21:30 <dmwit> afontain[m]: Perhaps `data NotBool = A | B; data S a where MkA :: S B -> S A; MkB :: S A -> S B` with the DataKinds and GADTs extensions?
07:21:47 <dmwit> But, like ski, I don't really understand what problem you're solving. Whatever it is, this probably isn't the right solution.
07:22:40 <dmwit> (In XY-problem situations, my personal preference is to both answer Y and try to figure out what X is. So please read this as an answer to Y, and I encourage you to further describe X.)
07:23:04 * ski nods
08:09:38 <Jinna> I seem to be blind: why does Data.Time.Calendar not export DayOfWeek?   `import Data.Time.Calendar (DayOfWeek)`  <- error
08:10:07 <phadej> Jinna: it's only in time-1.9
08:10:17 <phadej> you probably use something older (bundled with GHC)
08:10:27 <Jinna> phadej: okay, will have a look
08:10:48 <phadej> fwiw, there is https://hackage.haskell.org/package/time-compat
08:10:58 <afontain[m]> > afontain : perhaps you want `data A f = MkA (f (B f))' ?
08:10:59 <afontain[m]> That works, though that's a bit odd to write `:: S (A S)` instead of `:: S A` and (f (A f)) everytime you would put (f A)
08:11:01 <lambdabot>  <hint>:1:30: error: parse error on input ‘data’
08:11:27 <afontain[m]> I think that answers my question, thanks dmwit and ski !
08:11:50 <afontain[m]> (that's indeed a XY question)
08:12:21 <Jinna> phadej: right, on Stackage there are only older versions.
08:12:22 <afontain[m]> ski: out of curiosity, the f stands for functor ?
08:17:58 <phadej> Jinna: if you use stackage, I'd recommend that you'd browser Stackage haddocks; then you wont be tricked the same way as easily (given you look the right snapshot docs)
08:21:11 <Jinna> phadej: sounds good. I just wonder why certain libs are not available on Stackage. Maybe the maintainer of a certain lib has to do it manually and can easily forget about it.
08:22:21 <phadej> Jinna: some maintainers (e.g. me) don't really care if their packages are on Stackage, if someone wants them there; they could act as those packages Stackage maintainers
08:23:20 <argent0> is there something like: ghc-8.6.5-with-packages-with-haddock in nix?
08:28:05 <dmwit> afontain[m]: Yes, f is a common type variable name for a thing we expect will be a Functor instance.
08:28:35 <dmj`> argent0: nix-shell -p 'haskell.packages.ghc865.ghcWithPackages (p: with p; [ haddock ])
08:28:42 <dmwit> afontain[m]: I'm still curious about X, if you're willing/allowed to describe it more.
08:28:56 <argent0> dmj`: thanks
08:29:01 <dmj`> argent0: np
08:29:54 <dmj`> argent0: haddock ships with ghc in nix, so you can simplify to just `nix-shell -p ghc`
08:30:03 <dmj`> `nix-shell -p ghc --run 'haddock --help'`
08:34:16 <argent0> dmj`: I actually have something like that right now. The thing is I'm using `cabal2nix` but when nix fetchs the dependencies, haskell packages come without doucmentation.
08:35:32 <dmj`> argent0: I'd try replacing ghcWithPackages for ghcWithHoogle
08:35:56 <dmj`> per the docs
08:35:58 <dmj`> "This environment generator not only produces an environment with GHC and all the specified libraries, but also generates a hoogle and haddock indexes for all the packages, and provides a wrapper script around hoogle binary that uses all those things. A precise name for this thing would be “ghcWithPackagesAndHoogleAndDocumentationIndexes”, which is, regrettably, too long and scary."
08:37:31 <argent0> dmj`: ok, I'll try that. Thanks again.
08:42:59 <dmj`> argent0: np
09:25:41 <Jinna> Is there an easier way than pattern matching to take a triple and return a pair of just the first two elements of it?     I.e.  (10, 20, 30) => (10, 20)
09:26:59 <c_wraith> Nope, pattern matching is it.  You can stuff it into its own function, of course.
09:27:43 <Jinna> Okay, I’ll just `where` it.
09:27:46 <afontain[m]> <dmwit "afontain: I'm still curious abou"> (simplifying a bit) So I'm trying to make some kind of text adventure, I'm modeling it using Actions and Scenes. A Scene comes with a bit of texte to explain where you are gives you access to several Actions. An Action leads to another Scene, comes with a bit of text so you know whether to choose it, and has an effet on your character.
09:27:47 * afontain[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/wqVfBqYCzPqBLubBlCKwgfoo >
09:28:06 <Shoubit> Jinna: I'm sure there's some lens magic
09:28:24 <c_wraith> Shoubit: in this case, not that beats pattern matching
09:28:42 <c_wraith> Shoubit: mostly because tuples of different sizes are totally unrelated types
09:28:55 <afontain[m]> And then you start wondering whether you can "lift" the type
09:29:14 <afontain[m]> I can give a dummy adventure to explain more if that's usefull
09:30:41 <ski> @let import Data.Composition
09:30:42 <lambdabot>  .L.hs:82:1: error:
09:30:42 <lambdabot>      Could not find module ‘Data.Composition’
09:30:42 <lambdabot>      Use -v to see a list of the files searched for.
09:30:46 <ski> oh
09:31:00 <ski> @let infixr 9 .:; (.:) :: (c0 -> c1) -> (a -> b -> c0) -> (a -> b -> c1); (.:) = (.) . (.)
09:31:02 <lambdabot>  Defined.
09:31:06 <ski> @let import Data.Tuple.Lazy
09:31:08 <lambdabot>  Defined.
09:31:11 <ski> @type uncurry3 (const .: (,))
09:31:13 <lambdabot> (a, b1, b2) -> (a, b1)
09:31:44 <c_wraith> I don't think that beats (\(x,y,_)->(x,y))
09:35:22 <ski> @let import Data.Tuple.Extra
09:35:26 <lambdabot>  Defined.
09:35:27 <ski> @type fst3 Control.Arrow.&&& snd3
09:35:29 <lambdabot> (c1, b, c2) -> (c1, b)
09:35:48 * ski neither
09:39:15 <Jinna> ;-)
09:49:44 <Jinna> Is there a cron-job like lib in which I can specify times at which some action should run, and which resyncs itself with the clock when required (so, not just sleeping 24*60*60 seconds, but syncing this).
09:59:14 <dmj`> > toList (1 :: Int, 1 :: Int)
09:59:16 <lambdabot>  error:
09:59:16 <lambdabot>      Ambiguous occurrence ‘toList’
09:59:16 <lambdabot>      It could refer to either ‘F.toList’,
10:04:58 <ski> @type Lambdabot.Plugin.Haskell.Eval.Trusted.toList
10:05:00 <lambdabot> IsList l => l -> [Item l]
10:05:23 <ski> > F.toList (1,1)
10:05:25 <lambdabot>  [1]
10:06:06 <dmj`> ski: thanks
10:06:34 <ski> `F' is `Data.Foldable'
10:06:44 <ski> @type F.toList
10:06:45 <lambdabot> Foldable t => t a -> [a]
10:08:39 <dmwit> afontain[m]: how about data Scene m = Scene Text (m [Action m]); data Action m = Action Text (m (Scene m))
10:09:30 <dmwit> (or maybe the second field of Scene should be [m (Action m)] depending on what you want)
10:34:25 * delmarxhs5 4,01h7t8t9p3s12:6/4/7s8t9r3e12a6m4a7b8l9e3.12c6o4m7/8d9f3g1276z
10:37:01 --- mode: ChanServ set +o dmwit
10:37:53 --- mode: dmwit set -o dmwit
10:48:39 <butterth_> I'm looking for exercises on monad transformers, similar to the exercises here: https://github.com/data61/fp-course
10:56:12 <shapr> butterth_: "monad transformers step by step" was recommended to me
11:14:48 <shapr> is the ReaderT pattern the most popular way to thread through read-only config and runtime state?
11:17:47 <crestfallen> hi I'm beyond this function but have another question about it. thanks for the help the other day. the first condition of the if statement is xs /= []. however getNat [] does not produce an error. so the empty list [] has a different meaning from "" in this func. http://sprunge.us/zLV3k8
11:18:20 <MarcelineVQ> in getNat [], it's prompt that is []
11:18:26 <MarcelineVQ> not xs
11:19:09 <Rembane> shapr: Yes! Or thread the data as an argument through all the functions that might need it.
11:20:39 <crestfallen> prompt is [] ? please elaborate MarcelineVQ 
11:22:12 <MarcelineVQ> getNat prompt = ... means that the first argument to getNat is called prompt. so if we apply getNat to [], prompt is []
11:24:17 <MarcelineVQ> getNat doesn't parse its String argument into a number, the argument is to create a custom text prompt for the user, you'd know this or at least suspect this if you played with the function in ghci. xs comes from getLine, which accepts input from the user
11:24:55 <crestfallen> that's weird, I've been playing with it. hold on please
11:33:45 <crestfallen> there's no account for prompt in the type declaration... the logical && in the if statement is the condition that xs /= [] . these two points are throwing me off  
11:35:40 <crestfallen> so ' do putStr prompt ' is IO and is not needed in the type signature I guess 
11:36:09 <dmwit> "There's no account for prompt in the type declaration." Yes, there is.
11:36:24 <crestfallen> where/how
11:36:54 <dmwit> getNat :: {- starting here -} String {- ending here -} -> IO Int
11:36:58 <isovector1> glguy: we've run into a problem using th-abstraction where our datacon tyvars get the names of the tycon tyvars. eg `data State s m a where  Get :: State s m s` after some processing gets type `forall a r. MemberWithError (State a) r => Sem r a` rather than `forall a r. MemberWithError (State s) r => Sem r s`. are we just doing something stupid?
11:37:17 <isovector1> * should be `forall s r. MemberWithError (State s) r => Sem r s`
11:38:07 <crestfallen> dmwit thanks working on it
11:38:39 <dmwit> I don't know what "the logical && in the if statement is the condition that xs /= []" means. The logical && combines two conditions, and xs /= [] is one of them. (But why would that throw you off?)
11:39:45 <dmwit> `putStr prompt` has type `IO ()`. I don't know what "is not needed in the type signature" means. Computations never appear in type signatures in Haskell.
11:41:57 <crestfallen> in the if statement [] == "" , but "" causes an error while [] does not
11:42:19 <dmwit> The claim '"" causes an error while [] does not' is unfounded (and incorrect).
11:43:59 <ski> crestfallen : btw, as mentioned last time, you should get into a habit of using `null' in such cases
11:44:32 <dmwit> I suspect crestfallen didn't write this code.
11:44:35 <MarcelineVQ> ski: think this is a book example, huttons iirc
11:44:57 <dmwit> (And anyway I think it's fine here, because the list is monomorphic anyway.)
11:45:02 <ski> mhm
11:45:17 * ski still thinks it's a good habit to cultivate
11:53:23 <crestfallen> thanks ALL still working
11:54:42 <crestfallen> I hope you can at least understand my confusion here
11:55:41 <MarcelineVQ> Well, not by this point, this is a combination of stuff you've been spoonfed many times by this point
11:56:03 <MarcelineVQ> Over many seperate problems
11:56:21 <MarcelineVQ> mmhm
12:04:17 <ski> @where prerequisite
12:04:17 <lambdabot> "Prerequisite for Learning Haskell" <http://www.vex.net/~trebla/haskell/prerequisite.xhtml>
12:05:10 <shapr> wasn't there a recent project to make the haddocks available in ghci?
12:05:25 <shapr> did that get finished? is that in a released version?
12:05:48 <cocreature> shapr: iirc 8.6 has an initial version of a ":doc" command
12:06:04 <cocreature> but you need to compile your deps with some specific flags that I obviously don’t remember :)
12:06:06 <shapr> cocreature: thanks, I'll try it out
12:06:09 <shapr> oh?
12:06:11 <shapr> good to know
12:06:48 <cocreature> ":doc Monad" does seem to work at least in my ghci
12:07:13 <shapr> hurrah! it's already in my ghc 8.6.5 ! thanks for the tip!
12:23:20 <tabaqui> I'm trying to implement test monad similar to monad-mock
12:23:28 <lavalike> how nice
12:23:33 <tabaqui> and have such problem:
12:23:50 <tabaqui> I have some thread, which I want to test
12:24:24 <tabaqui> and this thread should use mvars in release code and some pure storage in test code
12:24:51 <tabaqui> but it is buried in big mtl stack
12:25:55 <tabaqui> So I think of something like "type family Channel st m; type instance (MonadIO m) Channel st m = MVar st; type instance (State TestState) Channel st m = st"
12:26:12 <tabaqui> but this code cannot be compiled, ofc
12:26:33 <tabaqui> *instance (MonadIO m) => Channel...
12:26:54 <tabaqui> what do you think of this?
12:27:19 <dmwit> Are you using IO for anything besides references?
12:27:41 <tabaqui> sure, actually I want to mock filesystem operations
12:28:22 <tabaqui> and I have MonadLogger instance, which is actually build on top of TQueues
12:29:22 <tabaqui> well, I could just drop all mtl constraints and write full transformers stack, but it is ugly
12:30:04 <dmwit> tabaqui: https://hackage.haskell.org/package/primitive perhaps
12:30:34 <tabaqui> do you mean PrimMonad?
12:30:38 <dmwit> I do.
12:30:54 <dmwit> There is even a pre-baked Data.Primitive.MVar.
12:31:45 <dmwit> Although... really that seems weird. I can't imagine that actually working well in ST, since ST doesn't have concurrency at all.
12:32:13 <dmwit> So back to square one, I have no idea what your plan for a non-IO implementation of this thing is.
12:32:27 <tabaqui> I don't care of concurrency now. I will not test the whole application, just one specific thread
12:32:45 <tabaqui> ST is fine, probably
12:33:03 <dmwit> But that one specific thread is going to be reading and writing to MVars which presumably won't be emptied/filled by the other threads you aren't running.
12:33:07 <dmwit> So...?
12:33:33 <tabaqui> I will fill them by myself, and check outputs after the test run
12:34:03 <tabaqui> because is pure code, I don't need to check intermediate state and react on it
12:34:10 <tabaqui> *because it is
12:34:23 * dmwit squints
12:34:27 <dmwit> Well, if you're happy, I'm happy.
12:34:45 <tabaqui> oh, I mean it is not really MVar, it is TQueue
12:34:58 <tabaqui> thanks :)
12:53:43 <butterth_> http://www.scs.stanford.edu/16wi-cs240h/slides/concurrency-slides.html#(12)
12:53:58 <butterth_> I'd appreciate someone verifying my understanding of the code in the slide above. The high-level idea is to run the main computation in a parent thread and use a separate thread to keep track of the timer. When the timer has run out, and the child thread is rescheduled, it throws an exception which interrupts the parent thread [1] causing the handler to run, unless the parent thread has already finished running the action and killed the thread.
12:54:08 <butterth_> I don't understand why we need to use catchJust here instead of just catch, since the handler doesn't care about the type of the exception anyway?
12:58:39 <monochrom> My http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml#subtyping should help.
13:01:19 <fragamus> lens has a way to access named fields of a record but what about data elements in an algebraic data type
13:01:55 <fragamus> for example, data Foo a b = Foo a b
13:01:57 <c_wraith> fragamus: if you're willing to lean on super-magical stuff...  https://hackage.haskell.org/package/generic-lens
13:02:22 <fragamus> really!
13:02:33 <c_wraith> see the "by position" section
13:03:10 <monochrom> Yikes.
13:03:26 <c_wraith> alternatively...  just write some lenses by hand.  :)
13:03:58 <monochrom> In what sense is it super-magical? Is it more magical than Data.Generics?
13:04:23 <c_wraith> Only in that it uses DataKinds for indexing along with GHC.Generics.  (I think that's the package...)
13:04:32 <monochrom> Oh!
13:04:51 <monochrom> And actually I had s/Data/GHC/ in mind too.
13:05:13 <cocreature> it’s magical in that not only is it a very nice use of generics, they also really focused on making it performant to the point where they use inspection-testing to make sure that the generic lenses are equivalent to handwritten lenses
13:05:27 <cocreature> which does require a fair amount of GHC.Generics mastery
13:05:49 <monochrom> OK, performance implies magic. :)
13:06:05 <c_wraith> I wasn't aware of that.  Even more magical!
13:06:20 <fragamus> thats wild magic alright
13:06:33 <cocreature> monochrom: after all we all know that Haskell code is always slow, right :)
13:07:01 <c_wraith> Csonger is doing some *really* cool stuff these days.
13:08:03 <butterth_> Uh, so unbound haskell threads share the same OS thread? Who decides when switching occurs?
13:08:25 <hpc> the RTS
13:08:49 <petercommand> I've been trying to use haskell stack under nix
13:09:06 <monochrom> GHC generates yield points in the generated code so RTS just needs to play "cooperative" multitasking.
13:09:24 <petercommand> and stack is only able to use ghc versions from nixpkgs by default in nix
13:09:25 <c_wraith> butterth_: bound threads can share the same OS thread, too.  the only restriction is that they must always use the same OS thread for FFI calls.
13:09:26 <Ariakenom> butterth_: hm the comment "Create unique exception val (for nested timeouts)" seems wrong. a timeout made at the same time would match
13:09:43 <monochrom> The yields points coincide with heap allocation points so no real slowdown. May as well.
13:09:52 <c_wraith> butterth_: but there's no requirement that different bound threads use different OS threads for FFI calls
13:10:11 <petercommand> and if I specify --no-nix as an argument to stack, stack tells me that I have to install the compiler manually..
13:10:37 <butterth_> c_wraith: so the only distinction between bound and unbound threads is a matter of FFI?
13:10:37 <monochrom> I think "different bound threads may use the same OS thread" is a bit uninformative.
13:11:13 <monochrom> actually I'm thinking s/uninformative/scaremongering/
13:11:23 <petercommand> feels like stack is very hard to use under nixos..
13:11:49 <monochrom> Multiple forkOS associates different bound threads to different OS threads.
13:12:06 <c_wraith> butterth_: yes.
13:12:55 <monochrom> And the only way 5 bound threads are associated to the same OS thread is because you're doing Haskell -> C -> Haskell -> C -> Haskell -> ... so every "C -> Haskell" creates a new bound thread but all of them have to stay on the same OS thread.
13:13:47 <monochrom> I say that "different bound threads may use the same OS thread" is a bit scaremongering because when people read that they default to thinking that it could happen to mere forkOS.
13:14:03 <c_wraith> Can't it?
13:14:11 <monochrom> No. That's my point.
13:14:38 <c_wraith> that's inconsistent with everything else I've read.  testing time, I suppose.
13:15:11 <monochrom> My http://www.vex.net/~trebla/haskell/ghc-conc-ffi.xhtml explains why. TL;DR ....
13:15:33 <monochrom> TL;DR if two forkOS's give you the same OS thread you lose FFI concurrency.
13:16:04 <monochrom> Erratum: TL;DR if two forkOS's gave you the same OS thread you would lose FFI concurrency.
13:16:42 <monochrom> See? Even you were scaremongered.
13:16:47 <c_wraith> testing
13:17:07 <Ariakenom> I don't see what is scary about that
13:17:20 <monochrom> This is why I also had "a bit".
13:17:55 <monochrom> OTOH I could defend my use of "scare" by explaining that I mean it causes people to be pessimistic.
13:18:01 <Ariakenom> "The yields points coincide with heap allocation points" this isn't true with -fno-omit-yield which I believe is default now
13:19:17 <Ariakenom> needing as many os threads as bound threads sounds scarier
13:19:31 <monochrom> Wait, "no-omit" means "yes-generate", no?
13:20:46 <fragamus> regarding the super magical generic lens package, there is a way to get constructor elements b position, but is there some way to get the name of the constructor?
13:22:02 <fragamus> typo above "elements b position" -> "elements by position"
13:22:17 <nshepperd> -fnever-don't-not-omit-yield
13:22:36 <hpc> -f60-percent-of-the-time-work-every-time
13:22:42 <Ariakenom> monochrom: sure. And otherwise it locks when a infinite loop doesn't heap allocate
13:22:47 <c_wraith> monochrom: hmm.  confirmed.  Wow, that destroys concurrency. :P
13:23:07 <c_wraith> wait, no.  I forgot to actually fork.  No wonder there was no concurrency
13:24:11 <Ariakenom> iirc I've helped 2 people in this chat with "try -fno-omit-yield". it (is|was) a subtle issue
13:24:27 <form-data> I am trying to use https://hackage.haskell.org/package/snap-core-1.0.4.0/docs/Snap-Util-FileUploads.html#v:handleMultipart to handle a <form> with a <textarea> but it appears to not be getting any parts on the Haskell side. Does anyone have experience with Snap?
13:25:49 <form-data> I can confirm in browser that the request has a multi-part body with a boundary, but when I put a `print` in my `PartProcessor` function, it is never getting called.
13:26:02 <form-data> Furthermore, the result of handleMultipart is an empty list.
13:26:26 <c_wraith> monochrom: nope, not confirmed after all.  If I forkOS 20k threads, there aren't 20k OS threads spawned.
13:27:05 <monochrom> What if all 20k threads make FFI calls concurrently?
13:27:41 <Ariakenom> anyone here know stm details? fryguybob?
13:27:57 <c_wraith> Is there a convenient FFI function I can use to test with?
13:28:25 <Ariakenom> I believe it also can break stm, but I'm no expert. in stm you can see inconsistent data but it will get checked on context switch and then rolled back. but without -fno-omit-yield it can get into an infinite loop because of inconsistent data. it gets to see parts of transactions, non-atomic commit.
13:28:39 <davean> c_wraith: if you called sleep(3) it would get pretty clear?
13:29:07 <c_wraith> Yes, but I'd need to bind it.  I hate writing ffi bindings, even one-liners.
13:29:13 <monochrom> I wonder if RTS's own use of VT-alarm interferes sleep(3).
13:29:31 <monochrom> But something under System.Posix may help.
13:29:42 <c_wraith> ah, good call
13:31:27 <c_wraith> monochrom: GHC Note: threadDelay is a better choice. Since GHC uses signals for its internal clock, a call to sleep will usually be interrupted immediately
13:31:36 <c_wraith> the docs answer that one!
13:34:15 <monochrom> Yeah, I always worry about that.
13:34:43 <c_wraith> ack, my cat is "helping" me type.  Not the fastest way to get anything done.
13:35:15 <monochrom> Well I'm on IRC when I should be creating homework for students so I'm not in any better shape.
13:35:49 <monochrom> So far I have only done "cp -R template a2" to create the homework directory and skeleton files.
13:36:11 <monochrom> "Be it recorded that I really intend to make Assignment 2"
13:36:25 <hpc> monochrom: just take whatever people are working on here and make your students do it
13:36:28 <hpc> what could go wrong
13:36:36 <Ariakenom> monochrom: Think of the time you saved by not copying it by pen. You deserve a break.
13:36:37 <form-data> I tried using https://hackage.haskell.org/package/snap-core-1.0.4.0/docs/Snap-Core.html#v:readRequestBody to confirm that the body is actually making it to my server. It is. I added some more fields to my form, so there are now 3 parts.
13:36:56 <form-data> But the `handleMultipart` is not actually processing any of the parts.
13:37:04 <form-data> It still thinks there are zero for some reason.
13:39:47 <form-data> I am going to switch to `foldMultipart` and see if it makes any difference.
13:43:43 <form-data> Weird results!
13:44:16 <form-data> foldMultipart :: MonadSnap m => UploadPolicy -> PartFold a -> a -> m ([FormParam], a)
13:44:29 <form-data> When I use that function, the [FormParam] is filled with the parts!
13:44:44 <form-data> But the `PartFold a` function does not seem to be getting called at all.
13:45:53 <form-data> Is it possible that the format that Firefox is proving the <form> to the server is causing problems?
13:47:30 <form-data> Maybe it is distinguising between files and normal parts?
13:47:34 <form-data> I guess that's possible.
13:48:55 <form-data> Weird, it looks like there are "form vars" and "form files" that are treated differently: https://hackage.haskell.org/package/snap-core-1.0.4.0/docs/src/Snap.Internal.Util.FileUploads.html#MultipartState
13:51:00 <c_wraith> yep, the native thread created by forkOS is created lazily.
13:51:19 <monochrom> :)
13:51:56 <monochrom> Did you kill your computer? Because I'm planning to forkOS 20k times and have them all call C to do the ackermann function...
13:52:15 <c_wraith> actually, 100k threads took a little time, but didn't really cause any load.
13:52:46 <monochrom> (Not to say that ackermann in C is really meaningful with merely unsigned long...)
13:55:40 <c_wraith> Heh.  Much like comparisons of algorithms for Fib in C.  "Uh, you only need like 40 entries in a table for int on most compilers"
13:57:45 <doughmouse> a question I asked yesterday but did not get any answers, so I figure it's worth asking once more (but not any further): out of curiosity, I declared `type Lift n t kind m = (MonadTrans t, kind n, m ~ t n)` so that my MTL classes could have default signatures of `(Lift n t) MyMonad m => m <whatever>`. but it seems a bit odd to have n and t in the constraint but not in the body. is there some forall 
13:57:51 <doughmouse> trickery or something that could get rid of those?
14:05:11 <lyxia> t and n are determined by m, in other words, they are *functions* of m
14:06:45 <lyxia> type family Car m where Car (t n) = t;    type family Cdr m where Cdr (t n) = n;    type Lift kind m = (MonadTrans (Car m), kind (Cdr m))
14:08:11 <lyxia> Type families are functions of types, basically.
14:10:10 <doughmouse> oh, neat
14:10:15 * doughmouse thanks lyxia
14:12:08 * lyxia you're welcome doughmouse
14:25:29 <doughmouse> well, it doesn't work because "expecting one more argument to m," but I think I get the idea of it
14:29:38 <butterth_> Can I add default GHC flags to stack?
14:29:47 <butterth_> I.e., flags for GHC that I want to turn on by default
14:37:24 <doughmouse> actually, nothing I have tried makes it work. but regardless, it was helpful to be pointed in the direction of type families
14:52:08 <PotatoRick[m]> hey guys, i'm trying to write my own `Generic` instance, i have to do it manually because deriving for GADTs isn't possible.
14:52:08 <PotatoRick[m]> is there any way to get `Symbol`s of current module and package names? writing my own `Generic` instance is already prone to errors enough, don't want to write module and package names manually too.
14:52:42 <solonarv> PotatoRick[m]: there is a package that use template haskell to write those instances for you
14:52:51 <solonarv> kind-generics I think
14:56:14 <PotatoRick[m]> solonarv thanks, will investigate
15:10:10 <PotatoRick[m]> solonarv: sadly i can't use it, it requires `base` >4.12, i use 8.0.2 in my project (it's pretty big to just easily migrate in few steps)  and current `base` is 4.9
15:13:10 <afontain[m]> > afontain: how about data Scene m = Scene Text (m [Action m]); data Action m = Action Text (m (Scene m))
15:13:11 <afontain[m]> That's what I ended up doing :-) The not-so-great thing is that it means you must give a monad even if you don't use any (say, Identity), or use a second type
15:13:12 <afontain[m]> I believe [m (Action m)] is better than (m [Action m]) because otherwise even actions that you wouldn't select would affect your player, right?
15:13:14 <lambdabot>  <hint>:1:21: error: parse error on input ‘data’
15:13:36 <afontain[m]> there is a reason the function that turns the first into the second is called sequence, I think
15:13:42 <halogenandtoast> So are logs forever broken?
15:17:11 <halogenandtoast> Any good way to shorten this: TicTacToeBoard (\x' y' -> if (x, y) == (x', y') then pure xo else getBoard board x' y')
15:19:01 <halogenandtoast> The full thing for clarity: https://gist.github.com/halogenandtoast/43ec635cbbf2252b692d261a7b1f5062
15:33:59 <lyxia> PotatoRick[m]: it's not just that it's not possible to write, but it's not even possible to write at all for most GADTs.
15:36:16 <lyxia> Hmm, actually, maybe you only need to introduce a few types for existentials, and it's just that you'll need to add the corresponding instances to whatever generic implementation you want to use...
15:37:20 <lyxia> PotatoRick[m]: for the metadata you could make a dummy generic type and steal the metadata from it.
15:39:08 <PotatoRick[m]> lyxia: good idea with that dummy generic type, i wonder why i haven't came with the same idea earlier, thanks
15:39:28 <PotatoRick[m]> simple solution without involving all that TH stuff
15:41:21 <lyxia> and for the rest, there's a lot of parameters that are almost always the same, so you could hide that with some type synonyms.
15:45:36 <lyxia> PotatoRick[m]: it could look like this https://gist.github.com/Lysxia/d0042efff5a3240410bc5e886850956f
15:49:48 <PotatoRick[m]> lyxia: thanks
16:06:05 <gabbiel> how come this (a = [1..3] :: [Int] ; length a) forces evaluation of the elements even though this (b = [1,2,3] :: [Int] ; length b) doesn't
16:07:09 <hpc> to know how many elements there are in [1..3], you need to know what 1 and 3 are
16:08:02 <hpc> more specifically, take a look at the Enum instance for Int, enumFromTo
16:09:02 <gabbiel> where is this instance, :i Enum doesn't list the code
16:12:28 <hpc> look for Enum or Int, and there's an instance list
16:12:38 <hpc> you can click source on the right instance and it'll take you to https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Enum.html#line-464
16:12:54 <hpc> although... maybe that one isn't very informative ;)
16:13:58 <gabbiel> so enumFromTo is strict?
16:16:48 <gabbiel> also, what's the use of foldl not being strict already. it seems that in order to get a real result, foldl must reach the base case in order for the expression to be "returned"
16:17:07 <gabbiel> and then the expression should be evaluated. 
16:19:12 <butterth_> Does anyone know a mirror for Real World Haskell?
16:19:23 <gabbiel> butterth_: check in libgen
16:19:29 <dmwit> afontain[m]: On the flip side, m [Action m] is better because it lets you e.g. randomly choose what next actions are allowed.
16:19:41 <dmwit> afontain[m]: (Or, perhaps, take a look at what is in the player's inventory to decide.)
16:20:09 <DigitalKiwi> https://www.oreilly.com/library/view/real-world-haskell/9780596155339/ch01.html other than this?
16:20:18 <afontain[m]> Oh, that's a fair point
16:20:25 <DigitalKiwi> but also libgen++
16:21:51 <butterth_> DigitalKiwi: is that open access?
16:21:57 <DigitalKiwi> hmm i thought it was but maybe it is not
16:21:59 <dmwit> halogenandtoast: How about `newtype TicTacToeBoard = TicTacToeBoard { getBoard :: Pos -> Maybe Bool }`?
16:22:02 <butterth_> I can view it fine, but it might be because I'm connected through my university right now
16:22:41 <afontain[m]> Well, that's still possible to use (m [m (Action m)]) :P
16:23:12 <DigitalKiwi> butterth_: i tried clicking chapter 2 and it wanted me to signup for safari
16:23:40 <dmwit> halogenandtoast: Then `updateBoard board pos xo = case getBoard board pos of Nothing -> TicTacToeBoard (\pos' -> if pos' == pos then pure xo else getBoard board pos'); _ -> board` is the straightforward refactor (and there's a less straightforward one, one moment).
16:25:00 <dmwit> halogenandtoast: updateBoard board pos xo = TicTacToeBoard (\pos' -> getBoard board pos' <|> if pos == pos' then pure xo else Nothing)
16:25:56 <dmwit> halogenandtoast: Of course even better still would be `newtype TTTB = TTTB (Map Pos Bool)`. ;-)
16:26:05 <MarcelineVQ> else empty why not :>
16:26:31 <dmwit> Sure. Or `xo <$ guard (pos == pos')`.
16:26:52 <dmwit> Yeah, definitely that.
16:27:13 <DigitalKiwi> https://web.archive.org/web/20190509070638/http://book.realworldhaskell.org/read/
16:28:12 <dmwit> halogenandtoast: (With Map, this is `insertWith (\_ old -> old) pos board`.)
16:28:52 <dmwit> halogenandtoast: (Well, `updateBoard (TTTB board) pos xo = TTTB (insertWith (\_ old -> old) pos xo board)`.)
16:30:08 <dmwit> afontain[m]: Since `Action` already contains a description of the `Effect` it produces as a field, why do you want `m Action` in your list?
16:30:40 <afontain[m]> well, I'm considering removing the Effect
16:30:41 <afontain[m]> I'll see
16:30:48 * dmwit nods agreeably
16:32:47 <afontain[m]> but if say, the effect contains a message, like «you somehow dodge through the poison cloud», it may be worthy
16:33:44 <afontain[m]> That's a first draft, that will likely be change quite a bit by the needs of the story
16:33:50 <dmwit> gabbiel: Agreed, foldl is almost never the right fold. foldr is fine, foldl' is fine, foldl sucks.
16:34:26 <dmwit> (lazy and right associative is good, strict and left associative is good, the other two combinations suck.)
16:35:37 <afontain[m]> I'm curious : why that introduces a reversal?
16:36:00 <afontain[m]> > That's a first draft, that will likely be change quite a bit by the needs of the story
16:36:01 <afontain[m]> oh, that's far from a correct sentence --'
16:36:04 <lambdabot>  <hint>:1:21: error: parse error on input ‘,’
16:39:31 <dmwit> gabbiel: I, too, don't understand why a = [1..3]; length a forces the list elements.
16:40:15 <dmwit> It is true that enumFromTo is strict (because the Report says it must be, though I don't know why it says that), but that doesn't actually explain why length a forces the list elements, only why it forces the 1 and the 3 from the initial call to enumFromTo.
16:41:26 <dmwit> There is a rewrite rule that changes `enumFromTo 1 3` into `build (\c n -> eftIntFB c n 1# 3#)`, but that still doesn't explain it, as eftIntFB doesn't appear to force its list elements before calling `c`.
16:41:56 <dmwit> Possibly this is another situation where GHC's desugaring is close enough to the Report rules that nobody noticed it was slightly wrong.
16:42:03 <dmwit> (i.e. perhaps this is a bug)
16:43:31 <solonarv> gabbiel: your moaning about foldl is echoed by much of the community, I think - that is the reason I (and others) tell people to use foldl' not foldl
16:44:03 <solonarv> dmwit: it is simple: to figure out how long the list is, length has to traverse its spine
16:44:23 <dmwit> Yes, that's fine. But traversing the spine doesn't (have to) force the elements.
16:44:27 <solonarv> to produce the output's spine, enumFromTo must look at (at least) the first and last element
16:44:44 <dmwit> No, this I do not believe.
16:45:00 <solonarv> how else should it figure out how long the output list must be?
16:45:03 <dmwit> enumFromTo actually operates on unboxed Int#'s internally, and puts an I# box on each element.
16:45:26 <solonarv> yes. unboxing the arguments forces them!
16:45:26 <dmwit> I don't see why that I# box should have to be forced to decide how long the list is.
16:45:35 <dmwit> Yes, it forces *the arguments*!
16:45:40 <dmwit> Not the *produced list elements*!
16:46:03 <solonarv> hm, I was naively expecting that the arguments would be reused in the output list
16:48:24 <solonarv> wait a minute - how are you even observing the list elements being forced?
16:48:46 <dmwit> :sprint
16:48:56 <solonarv> > let xs = undefined <$ [1..3] in length xs
16:48:58 <lambdabot>  3
16:49:04 <solonarv> hmmm
16:49:38 <dmwit> % [a,b] = [[1,2,3],[1..3]] :: [[Int]]
16:49:38 <yahb> dmwit: 
16:49:44 <solonarv> btw, rewrite rule only fire if optimizations are enabled, which is never the case for code you type into ghci
16:49:45 <dmwit> % (length a, length b)
16:49:45 <yahb> dmwit: (3,3)
16:49:49 <dmwit> % :sprint a
16:49:49 <yahb> dmwit: a = [_,_,_]
16:49:51 <dmwit> % :sprint b
16:49:51 <yahb> dmwit: b = [1,2,3]
16:50:11 <solonarv> hm, interesting
16:50:22 <dmwit> solonarv: Ah, sure, that makes sense. But it doesn't help; I read the non-rewrite version first and was confused before I even discovered there was a rewrite rule.
16:50:58 <dmwit> (It pulls the same trick of looping on an Int# and adding an I# just before calling (:).)
16:52:59 <solonarv> oh, I think I know what's happening: if you write down a constructor-applied-to-enough-arguments no thunk is allocated, and the constructor+fields are just produced immediately
16:53:10 <solonarv> since having a thunk would be pointless anyway
16:53:16 <hpc> % :sprint Just True
16:53:17 <yahb> hpc: 
16:53:27 <solonarv> % jt = Just True
16:53:27 <yahb> solonarv: 
16:53:32 <solonarv> % :sprint jt
16:53:32 <yahb> solonarv: jt = _
16:53:44 <solonarv> % jt `seq` ()
16:53:44 <yahb> solonarv: ()
16:53:46 <solonarv> % :sprint jt
16:53:46 <yahb> solonarv: jt = _
16:53:51 <dmwit> uh?
16:53:55 <solonarv> what??
16:54:01 <solonarv> % :force jt
16:54:02 <yahb> solonarv: jt = Just True
16:54:06 <hpc> might be a yahb thing
16:54:17 <dmwit> local ghci agrees
16:54:21 <dmwit> That *has* to be a bug.
16:54:44 <pie_> manning has some discounts right now so im thinking of splurging a bit, what do you guys think about https://www.manning.com/books/haskell-in-depth 
16:55:01 <PotatoRick[m]> hey guys, is there any guide how to write custom `Generic` instance? i'm stuck with implementing `from` and `to`
16:55:29 <solonarv> yahb really shouldn't disagree with a local ghci, since it is merely ghci in a jail stapled to an IRC bot
16:55:38 <PotatoRick[m]> i need to implement it for some GADT with record syntax
16:55:52 <dmwit> solonarv: I'm filing a bug. It works all the way down to `j = ()`.
16:56:05 <solonarv> dmwit: yeah, that does seem wrong to me as well
16:56:22 <slack1256> PotatoRick[m]: Not that I know how to manually derive generic, but what is wrong with DeriveGeneric?
16:56:31 <solonarv> slack1256: it doesn't work on GADTs
16:56:42 <PotatoRick[m]> yep, that
16:56:56 <slack1256> Oh, I thought it did!
16:59:45 <solonarv> specifically, DeriveGeneric can't handle existentials and constraints
17:00:03 <solonarv> usually the reason you use a GADT is that you want one or both of those
17:00:30 <solonarv> you have the same problem if you write a vanilla-syntax ADT that has an existential and/or constraint
17:01:18 <solonarv> % data Ex = forall s. Ex (IO s) (s -> IO ()) deriving Generic
17:01:18 <yahb> solonarv: ; <interactive>:142:53: error: Not in scope: type constructor or class `Generic'
17:01:28 <solonarv> % import qualified GHC.Generics as GCH
17:01:29 <yahb> solonarv: 
17:01:34 <solonarv> % data Ex = forall s. Ex (IO s) (s -> IO ()) deriving GCH.Generic
17:01:35 <yahb> solonarv: ; <interactive>:144:53: error:; * Can't make a derived instance of `GCH.Generic Ex': You need DeriveGeneric to derive an instance for this class; * In the data declaration for `Ex'
17:02:05 <solonarv> % data Ex = forall s. Ex (IO s) (s -> IO ()) deriving GHC.Generic
17:02:05 <yahb> solonarv: ; <interactive>:147:53: error:; * Can't make a derived instance of `Generic Ex':; Constructor `Ex' has existential type variables in its type; Possible fix: use a standalone deriving declaration instead; * In the data declaration for `Ex'
17:02:53 <solonarv> % data Showy a = Show a => MkShowy a deriving GHC.Generic
17:02:54 <yahb> solonarv: ; <interactive>:148:45: error:; * Can't make a derived instance of `Generic (Showy a)':; Constructor `MkShowy' has constraints in its type; Possible fix: use a standalone deriving declaration instead; * In the data declaration for `Showy'
17:03:06 <PotatoRick[m]> well, in my case, i have 3 constructors, i have two scenarios in both of which i use only 2 constructors, by GADT i'm constraining constructors, making it impossible to use wrong 3rd one
17:03:31 <solonarv> yup, in that case your third constructor has an equality constraint packaged into it
17:04:33 <solonarv> a constructor 'Constr :: blah -> GADT Foo' is (almost) equivalent to 'Constr :: a ~ Foo => blah -> GADT a'
17:04:46 <solonarv> ('a ~ Foo' is an equality constraint)
17:05:05 <PotatoRick[m]> `data Scenario = One Two; data Foo (s :: Scenario) where Foo :: {..} -> Foo s; Bar :: {} -> Foo One; Baz :: {} -> Foo Two`, like that
17:05:16 <solonarv> the "almost" is because GHC's deriving machinery for Foldable (and other things?) will treat these slightly differently
17:05:33 <solonarv> yep, that makes sense
17:06:10 <solonarv> your Bar and Baz constructors carry a 's ~ One' / 's ~ Two' constraint in them, so DeriveGeneric chokes
17:06:20 <dmwit> solonarv: Okay. Suppose I buy your argument that fully-applied constructors don't make thunks.
17:06:40 <solonarv> if you actually have a normal data type that just happens to be written in GADT syntax there are no problems with DeriveGeneric
17:07:07 <dmwit> solonarv: ...never mind. I was going to ask why [1,2,3] :: [Int] makes thunks, but maybe it's because of fromInteger calls? (?)
17:07:26 <solonarv> hmmm
17:07:29 * solonarv is too tired for this
17:08:11 <PotatoRick[m]> can i somehow see what actual code produced for a Generic instance of a datatype by deriving that Generic?
17:08:20 <dmwit> % x = [()]
17:08:20 <yahb> dmwit: 
17:08:24 <dmwit> % length x
17:08:24 <yahb> dmwit: 1
17:08:25 <dmwit> % sprint x
17:08:26 <yahb> dmwit: ; <interactive>:151:1: error:; * Variable not in scope: sprint :: [()] -> t; * Perhaps you meant one of these: `print' (imported from Prelude), `pprint' (imported from Language.Haskell.TH), `S.split' (imported from Data.Set)
17:08:29 <dmwit> % :sprint x
17:08:30 <yahb> dmwit: x = [()]
17:08:34 <dmwit> ok!
17:09:18 <dmwit> halogenandtoast: Did you see my commentary above?
17:12:27 <dmwit> Eh, what the heck, I'll leave a copy on your gist.
17:12:33 <PotatoRick[m]> i think i found an answer https://stackoverflow.com/questions/18538055/how-to-view-the-generated-code-for-derived-instances-deriving-in-haskell
17:12:38 <solonarv> PotatoRick[m]: pass -ddump-deriv to GHC
17:12:41 <solonarv> ah, already found i
17:13:11 <solonarv> you might also want -dsuppress-all (to remove a bunch of almost-always-irrelevant output) and -ddump-to-file (self explanatory)
17:13:15 <dmwit> Will that actually help with generics?
17:13:31 <dmwit> Won't the derived instance just be, like, `gMethodName . toGeneric` or something?
17:13:45 <PotatoRick[m]> in neovim: `:te stack repl --ghci-options=-ddump-deriv %`
17:13:52 <fragamus> regarding generic lenses are there any mjor packages that use it
17:14:06 <fragamus> najor
17:14:14 <fragamus> major even
17:14:24 <dmwit> What's a "major even package"? ;-)
17:14:34 <solonarv> dmwit: they are looking to see the code generated by DeriveGeneric
17:14:49 <dmwit> ...ah
17:15:14 <solonarv> fragamus: I suspect most uses of generic-lens are not library packages, but rather applications/programs
17:15:29 <solonarv> those tend to not be on hackage quite as often
17:17:34 <fragamus> with generic lenses you can grab a piece of data out of an algebraic data type by position and have no idea what its type is 
17:17:52 <fragamus> and yet be totally type safe
17:18:18 <WilliamHamilton> a question about lens idioms: Let's say I have `list :: [(a,b)]` and I want to get the values `(a, f b)` where f is another lens. Ie. I'd like to know the equivalent of `(fmap (\(a,b) -> (a, f b)))` in lens-speak
17:19:05 <WilliamHamilton> fragamus: generic-lens is awesome, if no other reason because you don't need template haskell
17:19:46 <fragamus> I didn't see template haskell in there but I assumed one needed it
17:20:57 <WilliamHamilton> fragamus, no it's done entirely with type-level computations
17:21:14 <fragamus> thats weird voodoo
17:21:39 <WilliamHamilton> fragamus indeed that library is very interesting to study
17:21:44 <solonarv> it's called *generic*-lens because it uses the *Generic* type machinery to do its work
17:22:16 <fragamus> yeah if you want your eyeball to pop out of its socket and dangle on your face
17:23:20 <WilliamHamilton> hahaha, I still have them in my sockets, but I also quite dislike the effects of TH so that's easy for me
17:24:36 <WilliamHamilton> but, how can I combine two lenses in one, not like `alongside`, but more like `(&&&)` from `Control.Arrow`?
17:24:55 <solonarv> you can't, at least not safely
17:25:00 <WilliamHamilton> (even getters are enough though)
17:25:14 <solonarv> ah, if you just want to do that for getters it's not a problem
17:25:24 <WilliamHamilton> solonarv: what's the non-safe option for lenses? What's the correct idiom for getters?
17:25:29 <dmwit> WilliamHamilton: I think what you asked for is `each.alongside id f`, no?
17:25:47 <solonarv> @type Control.Lens.Unsound.lensProduct
17:25:48 <WilliamHamilton> dmwit I have to think about that :D
17:25:50 <lambdabot> error:
17:25:50 <lambdabot>     Not in scope: ‘Control.Lens.Unsound.lensProduct’
17:25:50 <lambdabot>     No module named ‘Control.Lens.Unsound’ is imported.
17:25:54 <solonarv> bah
17:25:59 <solonarv> anyway that is the unsafe function
17:26:10 <WilliamHamilton> thanks solonarv, I'll check that out!
17:26:30 <WilliamHamilton> @type each . alongside id f
17:26:32 <lambdabot> (FromExpr (Control.Lens.Internal.Getter.AlongsideRight f t2 t'), Show s', Typeable b', Typeable t2, Typeable a', Typeable f, Applicative f, Each s1 t1 (s2, s') (t2, t')) => ((s2, a') -> f (t2, b')) -
17:26:32 <lambdabot> > s1 -> f t1
17:26:39 <dmwit> % :t \f -> each . alongside id f
17:26:39 <yahb> dmwit: (Each s1 t1 (s2, s') (t2, t'), Applicative f) => LensLike (Control.Lens.Internal.Getter.AlongsideRight f t2) s' t' a' b' -> ((s2, a') -> f (t2, b')) -> s1 -> f t1
17:27:02 <solonarv> it is unsafe because if the two lenses you give it have overlapping targets, set-then-get doesn't give back what you set, which breaks one of the lens laws
17:27:15 <solonarv> it's perfectly safe to just use as a getter
17:27:19 <dmwit> But this type is much more readable:
17:27:22 <dmwit> % :t alongside id
17:27:23 <yahb> dmwit: LensLike (Control.Lens.Internal.Getter.AlongsideRight f t) s' t' a' b' -> LensLike f (s, s') (t, t') (s, a') (t, b')
17:28:20 <dmwit> "give me a lens that acts on the snd part of a tuple, and I'll give you a lens that operates on the whole tuple"
17:28:39 <solonarv> a very naive implementation is simply: getterProduct f g = to (view f &&& view g)
17:28:53 <solonarv> dmwit: isn't that just composing with _2 ?
17:30:51 <dmwit> :t (_2.)
17:30:53 <lambdabot> (Functor f, Field2 s t a1 b) => (a2 -> a1 -> f b) -> a2 -> s -> f t
17:31:12 <Guest41886> Hi guys, I have question about using guards and cases
17:31:26 <dmwit> solonarv: I don't think so.
17:31:44 <dmwit> er
17:31:52 <Guest41886> When should you use guards, and when should you use cases? I heard that cases is for pattern matching, though what does that mean?
17:32:54 <solonarv> they are not mutually exclusive: a 'case' expression can have guards
17:32:55 <WilliamHamilton> solonarv `getterProduct f g = to (view f &&& view g)` is the semantic I had in mind, but I hoped there was a premade lensy way of saying that
17:32:55 <dmwit> solonarv: Sure, why not? =)
17:33:50 <WilliamHamilton> dmwit: I don't understand how `alongside id f` would work. I assume `each` is because I mentioned a list? Why not `traverse`?
17:34:03 <solonarv> dmwit: oh, of course! (_2.) :: Lens s t a b -> Lens (x, s) (x, t) a b
17:34:04 <jackdk> cases tell you which constructors were used to build the value you were looking at. guard run other expressions to compute a bool
17:34:26 <solonarv> guards can contain pattern matches/bindings too!
17:34:34 <solonarv> ("pattern guards")
17:34:50 <solonarv> and 'let' bindings, though IME that is very rarely needed
17:35:24 <dmwit> WilliamHamilton: traverse would be fine. each is traverse for lists.
17:35:25 <jackdk> this is true but I assume our Guest is looking for newbie-level information
17:35:32 <Guest41886> Yeah I am
17:35:37 <Guest41886> Newbie
17:36:23 <dmwit> Guest41886: Okay, here is my advice for newbies: never use guards.
17:36:45 <dmwit> (WARNING: This advice is for newbies only! Once you graduate to intermediate you should throw this rule out of your head.)
17:37:34 <jackdk> yeah that's actually pretty solid. most newbies seem to try and use guards where they should use cases, and seldom the other way around
17:38:17 <Guest41886> Fair enough, why shouldn't we use guards?
17:38:59 <dmwit> It is actually quite rare for Bool to be the right type for branching on in idiomatic Haskell.
17:39:06 <WilliamHamilton> > let list = [(i, [2*i, 3*i]) | i <- [1..10]] in list ^.. traverse . alongside id (traverse . filtered even)
17:39:09 <lambdabot>  error:
17:39:09 <lambdabot>      • No instance for (Applicative
17:39:09 <lambdabot>                           (Control.Lens.Internal.Getter.AlongsideRight
17:39:17 <solonarv> Guest41886: using guards lets you fall into the trap of checking 'someList == []' when you should be using pattern matching
17:39:18 <dmwit> Haskell makes it so cheap and cheerful to write more descriptive branching types than Bool that reaching for Bool is a code smell.
17:39:25 <WilliamHamilton> dmwit: I didn't understand your solution with alongside
17:40:09 <dmwit> Since guards are intimately tied to branching on Bools, this means it is a code smell to use them instead of using a match on a richer, more descriptive type, that carries not just information about which branch to take, but also about what data is needed to execute that branch correctly.
17:40:31 <solonarv> I do love pattern guards though: they let me do things like 'Just val <- lookup someKey someMap'
17:41:04 <dmwit> I think pattern guards should also be considered an intermediate- (or maybe advanced-) users-only feature.
17:41:08 <solonarv> this is nice and does not fall into the bool trap, since there are no bools involved - but reserve that for a bit later in your Haskell joruney
17:41:20 <dmwit> I agree they are wildly useful. But you can get very, very far without them with only minimal additional pain.
17:41:45 <Guest41886> Ok, noted, thanks guys!
17:41:47 <dmwit> WilliamHamilton: That's okay. solonarv's solution with _2 was simpler and equivalent anyway.
17:42:13 <solonarv> tbh, most of my boolean-guard usage is just checking that a number is in some range
18:08:49 * DigitalKiwi implemented FizzBuzz for the first time the other day and used guards >.>
18:10:13 <DigitalKiwi> one of the only times i've used guards too so heh
18:23:55 <turab> I am trying to replace usage of String with Text and realized that the usual list style pattern matching doesn't work. Is the standard way to pattern match on text is by using the ViewPatterns extension?
18:31:34 <unclechu> lyxia: here is what i came up with https://gist.github.com/unclechu/05f3f0f3aa3c49c51467ec476e91ffcf
18:36:18 <PotatoRick[m]> turab: what exactly you're trying to pattern-match? since `Text` isn't a list, you pattern match usually by whole string (using OverloadedStrings extension)
18:37:24 <PotatoRick[m]> turab: show us an example of what you want to achieve (like in case you would pattern-match just a String)
18:39:15 <turab> function ('(' : cs) = undefined; function (')' : cs) = undefined
18:39:25 <turab> What would be the equivalent of this in Text
18:42:11 <PotatoRick[m]> turab: `function (Data.Text.uncons -> Just ('(', cs)) = undefined; function (Data.Text.uncons -> Just (')', cs)) = undefined`
18:42:27 <turab> Yay, that's what I have right now!
18:42:35 <turab> Thanks for the feedback!
18:46:56 <lyxia> PotatoRick[m]: see unclechu's message ^
18:58:49 <butterth_> I asked this yesterday and someone suggested a nice solution, but I forgot what the suggestion was :(
18:59:10 <butterth_> The problem is that I want to split a Text object into two Texts
18:59:49 <butterth_> One with all the characters at the even indices and one with all characters at the odd indices
19:09:08 <Nevoic> Does anyone have an example of a type constructor with an arity of 1 that is *not* a Monad? I can construct an arbitrary one, but can't think of any real ones I've used. 
19:11:04 <nshepperd1> Predicate
19:12:25 <turab> Nevoic's questions reminds of a question I was thinking of last week and couldn't find the answer to. What's a simple example of a monad where the assoc law doesn't hold?
19:13:02 <Nevoic> Doesn't that law need to hold for it to be a Monad?
19:15:11 <turab> Sorry, I meant an example where the law doesn't hold :)
19:16:35 <turab> (I didn't mean to say a Monad where the law doesn't hold)
19:39:05 <lyxia> There is no Monad that's compatible with the Applicative instance of ZipList
19:39:42 <lyxia> also Const m
19:41:43 <lyxia> Actually I misunderstood, and I don't understand what an example where the law doesn't hold even means.
19:42:20 <lyxia> Ah, there's QuickCheck's Gen
19:48:57 <turab> Sorry for phrasing the question in a confusing way
19:49:37 <turab> I was wondering if there is an example where [m >>= (\x -> k x >>= h) =/= (m >>= k) >>= h]
19:50:45 <halogenandtoast1> dmwit: I am looking at your responses now, sorry I had gone afk
19:53:01 <turab> lyxia: Was Quicheck's Gen an answer to my question?
19:55:06 <lyxia> turab: yes, QuickCheck's Gen breaks the law if you look at how it actually works (a function taking random seeds as inputs), although the point is that it is morally lawful if you view it abstractly as a probability monad.
19:57:03 <turab> Cool, thanks for sharing :D
19:57:41 <turab> If others have other cool examples to share, that would be awesome
20:00:29 <lyxia> the Writer monad is such an example when writing something that's not in a semigroup.
20:07:48 <suzu> anyone here used beam before?
20:07:58 <suzu> I want to use Beam.Query.values_ but i'm not on 8.0.0
20:08:02 <suzu> i'm just one version behind that
20:08:05 <turab> Ahhh nice, I like that example too
20:08:15 <suzu> and nothing like it seems to exist
20:08:30 <suzu> values_ :: forall be db s a. (Projectible be a, BeamSqlBackend be) => [a] -> Q be db s a 
20:08:39 <suzu> http://hackage.haskell.org/package/beam-core-0.8.0.0/docs/Database-Beam-Query.html#v:values_
20:09:07 <suzu> and in 0.7.2.3
20:09:10 <suzu> http://hackage.haskell.org/package/beam-core-0.7.2.3/docs/Database-Beam-Query.html#v:all_
20:09:13 <suzu> it's not here :(
20:09:36 <suzu> i've fetched two sources of foos and i wish to "concatenate" them in the query monad
20:11:28 <halogenandtoast> dmwit: thanks for the advice, using Map simplifies some parts, complicates others, but useful none-the-less
20:11:56 <halogenandtoast> Definitely simplified updateBoard
20:27:47 <turab> Uhh, an easy example of something that is not a semigroup?
20:29:23 <lyxia> data Tree = Empty | Branch Tree Tree ; (<>) = Branch
20:30:42 <turab> Nice, thank you
20:31:05 <blankhart> integers with the subtraction operator
20:34:00 <turab> blankhart: Can't believe I didn't think of that. Thanks
21:18:24 <sofiama> What's the most ergonomic way to use recursion schemes with a set of mutually recursive data types?
21:19:32 <sofiama> For example, data Stmt = Decl Sym Expr | For Expr Stmt; data Expr = Plus Expr Expr | ValOf Stmt
21:21:59 <sofiama> I have 4 types, and I want to build a joint traversal over one that traverses the others, etc. I end up with types "data Expr e s p m = ..." and it gets unwieldy fast. Should I make a class "QuadFunctor" or something?
21:23:34 <heatsink> If the types all vary together in the same way, you could use type families
21:23:54 <heatsink> Have one type parameter, and four type families that give you e, s, p and m in terms of that parameter
21:27:21 <ski> sofiama : it's possible to do a trick with `GADTs' and `DataKinds'
21:28:04 <ski> instead of having `e',`s',`p',`m' as separate parameters, you'd prefer to have them "tupled" together in a single parameter, perhaps a record
21:29:03 <lyxia> sofiama: There's generic-lens + the Plated module from lens without any of the open recursion tricks.
21:29:09 <ski> onw way of achieving that is to declare `data Tag = TStmt | TExpr | TPat | TMod' (or whatever those two last parameters were)
21:31:20 <lyxia> uniplate may be a simpler variant of what I'm talking about.
21:31:22 <ski> then you do `data AST (ast :: Tag -> *) :: Tag -> * where Decl :: Sym -> ast TExpr -> AST ast TStmt; ...; Plus :: ast TExpr -> ast TExpr -> AST ast TExpr; ...', collecting all the constructors in a single data type
21:31:47 <ski> you can define `type ExprF ast = AST ast TExpr' and so on as shorthands
21:33:53 <ski> basically, a type of kind `Tag -> *' here simulates a record with fields named by the types in the kind `Tag', and with (all) types in those fields having kind `*'
21:54:25 <lisbeths> I have made an immutable version of 4chan: https://imgur.com/a/RtLwOoi
21:54:36 <lisbeths> it is literally impossible to censor it without shutting down http lelelelelelellelelelelleel
22:00:08 <sofiama> ski: so far your approach is working pretty well :P
22:00:33 <ski> i dunno how well it will mesh with traversals. haven't tried
23:22:21 <cdepillabout> I've seen a haskell testing library to test that certain expressions generate a compile error, but I can't find it with a quick google.
23:22:33 <cdepillabout> Does anyone know the name of the library?
23:24:33 <dmj`> @package should-not-typecheck
23:24:33 <lambdabot> http://hackage.haskell.org/package/should-not-typecheck
23:28:00 <cdepillabout> @dmj`, Thanks, thats it!
23:28:01 <lambdabot> Unknown command, try @list
23:29:09 <cdepillabout> Oh yeah, it requires defered type errors.  I guess that's why I've never really used it.
23:33:58 <dmj`> cdepillabout: :/
23:34:02 <dmj`> that's no good
23:37:27 <cdepillabout> I'm guessing it only requires deferred type errors for the modules you're using it in.  I guess I'll just create a separate module to hold those tests, and then only turn on defferred type errors for that module.
23:37:43 <cdepillabout> That's not too bad.
23:39:45 <dmj`> yea, sounds reasonable
