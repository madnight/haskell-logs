00:00:15 <dani_> Ok, but why not?
00:01:02 <dminuoso> dani_: ⌜f (g x) y⌝ is just something different than ⌜f (g x y)⌝
00:01:37 <dminuoso> dani_: ⌜f (g x) y⌝ applies ⌜f⌝ first to ⌜g x⌝ and then it applies the resulting function to ⌜y⌝
00:01:49 <dani_> I'm a bit confused, why does the first argument go inside the composed function and not the second one?
00:01:51 <dminuoso> dani_: ⌜f (g x y)⌝ applied ⌜f⌝ to ⌜g χ y⌝
00:02:50 <dani_> So (fmap . fmap . fmap) f x is fmap (fmap (fmap f)) x?
00:03:08 <pyan> Yes.
00:03:18 <dminuoso> dani_: Precisely.
00:03:30 <dani_> Ok, I've got the pattern I guess
00:03:37 <dminuoso> dani_: It may be useful to think of applying multiple arguments as one application at a time.
00:03:37 <dani_> I still don't understand why is it this way
00:03:57 <dminuoso> dani_: Like I said: Apply one argument at a time.
00:04:00 <dminuoso> Let's take your example
00:04:05 <dani_> dminuoso: You mean like I apply them in a nested way?
00:04:05 <dminuoso> ⌜(fmap . fmap . fmap) f x⌝ 
00:04:36 <dminuoso> So let's replace ⌜fmap . fmap . fmap⌝ by ⌜f3⌝ 
00:04:43 <dminuoso> So we have ⌜f3 f x⌝ right?
00:04:58 <dani_> yep
00:05:06 <dminuoso> ⌜f3 f x⌝ is not "f3 applied to f and x", but rather "f3 applied to f, and then the resulting function applied to x"
00:05:20 <dminuoso> So ⌜f3 f x⌝ can be written ⌜(f3 f) x⌝
00:06:12 <Axman6> the thing to take note of is that fmap has type (a -> b) -> (f a -> f b), and (f a -> f b) unifies with (x -> y) in fmap :: (x -> y) -> f x -> f y, where x = f a and y = f b, so you get: fmap (f a -> f b) -> f' (f a) -> f' (f b)
00:06:30 <dminuoso> If we then substitue ⌜f3⌝ with its definition ⌜fmap . fmap . fmap⌝ we obtain ⌜((fmap . fmap . fmap) f) x⌝
00:06:38 <dminuoso> If we then replace (.) with its definition we obtain
00:07:03 <dminuoso> ⌜(fmap (fmap (fmap f))) x⌝
00:07:18 <dani_> aha
00:07:23 <dani_> Ok, this makes sense now
00:07:42 <dani_> I guess I was missing the step that the arguments are applied one by one
00:07:51 <dani_> Which is not really happening in other languages
00:08:01 <dminuoso> dani_: Function application is better understood as "applying to one argument at a time, obtaining the resulting function, and applying that new function to the next argument"
00:08:07 <pyan> All functions take one argument in Haskell. Some functions just happen to return other functions.
00:08:07 <dminuoso> dani_: Indeed.
00:08:38 <dani_> Ok, this makes sense. I just need to change the way I think about functions in haskell
00:08:40 <dminuoso> dani_: This behavior lets you sort of "apply not enough arguments" and obtain a function taking the rest of the arguments. Of course that's just a mental model since again, we dont actually have functions with multiple arguments.
00:09:35 <dani_> What do you compile this half-baked functions to?
00:09:35 <dminuoso> @let oneToEach :: [Int] -> [Int]; oneToEach = map (+1)
00:09:39 <lambdabot>  Defined.
00:09:48 <dminuoso> dani_: New functions.
00:10:17 <dminuoso> dani_: Because again, in reality each function just returns a new function.
00:10:20 <dminuoso> Well, each function that we like to call "having multiple parameters"
00:10:28 <dani_> SO if I partially apply something then in the machine code there will be a function with a subset of the arguments of the original one?
00:10:51 <ski> (s/apply not enough arguments/partially apply/)
00:11:37 <dminuoso> dani_: Well what happens on the compilation level is actually very interesting.
00:12:05 * pyan didn't know machine code had functions.
00:12:13 <dminuoso> dani_: But again remember that this "partial application" is only in your head.
00:12:53 <dminuoso> dani_: If we have a function [f :: Int -> Double -> String⌝, then ⌜f 5 :: Double -> String⌝
00:13:37 <dminuoso> dani_: (+) for example is a function that creates adders. Apply (+) to 1, and you obtain adder functions that add 1 to any number.
00:13:49 <dminuoso> Apply (+) to 6, you obtain an adder functoin that adds 6 to any number
00:14:12 <dminuoso> so ⌜1 + 6⌝ could be thought of as creating a 1-adder and applying that 1-adder to 6.
00:16:18 <dminuoso> Which is why you can write things like ⌜fmap (+1) [1,2,3]⌝ which maps with a 1-adder over a list of numbers.
00:17:57 <dani_> I see
00:18:13 <dani_> I'll be back in an hour. I just have to commute for a bit.
00:18:28 <dani_> Thanks for the explanation dminuoso!
00:18:38 * ski . o O ( "God spake unto the animals, and said “Go forth and multiply !”. But the snake replied “How could I, I'm an adder.”." )
00:19:35 * int-e wonders whether this is a good time to point out that (+1) is equivalent to  flip (+) 1...
00:27:17 <dminuoso> int-e: Caught me with my pants down.
00:27:29 <dminuoso> Commutativity is a blessing.
00:28:30 <dminuoso> int-e: It's interesting how I completely looked over that because to me (+1) and (1+) are the same thing on the basis of commutativity.
00:35:22 <sicklorkin> `+` doesn't work
00:36:07 <dminuoso> sicklorkin: Why not?
00:36:18 <sicklorkin> parse error?
00:36:46 <sicklorkin> hlint doesn't always have the right answer
00:37:48 <sicklorkin> (actually i'm not sure if hlint woudl suggest doing this, but based on it's ruels I suspect it might)
00:38:42 <sicklorkin> let add = (+) ; 5 `add` 2 -- works
00:42:39 * sicklorkin wonders if its' wrong to abuse Maybe's Foldable instance to use `when (null Nothing) $ act`
00:43:55 <sicklorkin> so many unfornately WATs 
00:45:30 <Axman6> sequence (const . act)
00:45:43 <Axman6> uh, maybe not
00:45:59 <Axman6> :t \act -> foldMap (const . act)
00:46:01 <lambdabot> (Foldable t, Monoid a1) => (a2 -> a1) -> t a2 -> b -> a1
00:46:28 <kaol> Cute. Shorter to type than isNothing and it won't require an import.
00:46:38 <sicklorkin> kaol: exactly
00:46:55 <Axman6> :t foldMap @Maybe
00:46:58 <lambdabot> error:
00:46:58 <lambdabot>     Pattern syntax in expression context: foldMap@Maybe
00:46:58 <lambdabot>     Did you mean to enable TypeApplications?
00:47:04 <Axman6> % :t foldMap @Maybe
00:47:04 <yahb> Axman6: Monoid m => (a -> m) -> Maybe a -> m
00:47:14 <sicklorkin> % length Nothing
00:47:15 <yahb> sicklorkin: 0
00:47:33 <Axman6> % :t foldMap @Maybe @(IO ())
00:47:33 <yahb> Axman6: (a -> IO ()) -> Maybe a -> IO ()
00:47:37 <merijn> hose all do something different
00:47:48 <merijn> Those do something when the value is Just
00:47:57 <merijn> sicklorkin's code does something when it's Nothing
00:48:15 <Axman6> uh, yes, of course
00:48:35 <sicklorkin> % null (Just 2)
00:48:35 <yahb> sicklorkin: False
00:48:51 <sicklorkin> % null (Left 1)
00:48:52 <yahb> sicklorkin: True
00:49:00 <sicklorkin> % null (Right 2)
00:49:00 <yahb> sicklorkin: False
00:49:07 <sicklorkin> WAT
00:49:14 <Axman6> :|
00:49:23 <sicklorkin> oh wiat.that's logical
00:49:59 <kaol> % null (1,2)
00:49:59 <sicklorkin> merijn: this is why null can be abused and lead to so much regrest
00:49:59 <yahb> kaol: False
00:50:12 <sicklorkin> null (,)
00:50:17 <sicklorkin> % null (,)
00:50:18 <yahb> sicklorkin: ; <interactive>:16:1: error:; * No instance for (Foldable ((->) a0)) arising from a use of `null'; * In the expression: null (,); In an equation for `it': it = null (,)
00:50:22 <merijn> sicklorkin: What were you expecting?
00:50:28 <sicklorkin> potatoes
00:50:34 <merijn> null reports whether something is empty
00:50:40 <merijn> wrt Foldable
00:53:03 <sicklorkin> >  null reports whether something is empty; empty in what sense?
00:53:06 <lambdabot>  <hint>:1:40: error: parse error on input ‘;’
00:54:34 <ski> > fold ([0],[1,2]) :: [Integer]
00:54:38 <lambdabot>  [1,2]
00:54:42 <merijn> sicklorkin: Foldable applies to types of kind "* -> *" so it only considers the last type parameter
00:54:50 <sicklorkin> ahh
00:55:07 <merijn> sicklorkin: "instance Foldable ((,) e) where ..." so onlyt the second type of "(Int, Bool)" is relevant
00:55:14 <ski> > fold (Left [0]) :: [Integer]
00:55:20 <lambdabot>  []
00:55:21 <ski> > fold (Right [1,2]) :: [Integer]
00:55:23 <lambdabot>  [1,2]
00:55:30 <sicklorkin> > sequenceA ("a",Nothing)
00:55:37 <lambdabot>  Nothing
00:55:59 <sicklorkin> show <$> "ABC"
00:55:59 <merijn> sicklorkin: Consider null as "\x -> Sum 0 == foldMap (const (Sum 1)) x"
00:56:08 <sicklorkin> % show <$> "ABC"
00:56:09 <yahb> sicklorkin: ["'A'","'B'","'C'"]
00:56:18 <merijn> > foldMap (const (Sum 1)) [1..5]
00:56:19 <sicklorkin> % show <$> ["ABC"]
00:56:19 <yahb> sicklorkin: ["\"ABC\""]
00:56:21 <lambdabot>  Sum {getSum = 5}
00:57:01 <sicklorkin> so, going back to my question.. is null (Nothing) considered abusive?
00:57:19 <sicklorkin> wehre am I cannot lose my pants?
00:57:24 <merijn> Naah, but I don't think it's great.
00:57:26 <merijn> I'
00:57:27 <sicklorkin> s/cannot/gonna/
00:57:36 <merijn> I'd probably use maybe/fromMaybe/etc. instead
00:57:45 <merijn> With some convenience wrapper if I need it very often
00:59:19 <sicklorkin> merijn: yeah.. but for that one time where you dont wanna type 29 characters
01:01:15 <sicklorkin> i dont 'think I would ever adopt this.. just wondering what the concensus was
02:10:39 <asheshambasta> With -Wall I'm seeing: ```([-Wunused-do-bind]
02:10:40 <asheshambasta>     A do-notation statement discarded a result of type `Tokens Text'
02:10:40 <asheshambasta>     Suppress this warning by saying `_ <- company <* U.urnSepP')
02:10:40 <asheshambasta> ``` warnings; what is the motivation behind this? And in what ways can it be considered harmful if I don't abide by the warning? 
02:10:53 <sadkapista> Why wouldn't this type check. https://pastebin.com/e7Ww3kTZ
02:11:14 <merijn> asheshambasta: I just disable that warning, tbh
02:11:27 <merijn> asheshambasta: The idea is "if something returns a value, you probably meant to use it"
02:11:31 <sadkapista> I was trying to implement the `withSingDSI` function from this post. https://blog.jle.im/entry/introduction-to-singletons-1.html
02:11:54 <cocreature> asheshambasta: 1. you could be missing an error check. 2. sometimes you can use something more efficient, e.g., a very common example is mapM_ vs mapM
02:12:05 <asheshambasta> merijn: doesn't that go against the fact that do notations explicitly allow you to disregard values? 
02:12:20 <merijn> asheshambasta: yes, no, maybe
02:14:05 <asheshambasta> cocreature: is mapM_ more efficient? 
02:14:42 <asheshambasta> Reason 1 is good; but when I don't care about the value; even if something may cause an error I'm not sure if `_ <- ` offers any more protection 
02:15:12 <merijn> asheshambasta: I agree, hence why I just disable that warning
02:15:29 <merijn> mapM_ is more efficient because it doesn't build an intermediate list for the result
02:15:54 <asheshambasta> merijn: ah true. 
02:15:58 <cocreature> asheshambasta: yep, it doesn’t build up a list only to then GC it (not entirely sure if GHC sometimes manages to optimise it away)
02:16:22 <asheshambasta> and what's the verdict on -Wmissing-signatures? 
02:16:41 <nevere> Why wouldn't this type check. https://pastebin.com/e7Ww3kTZ
02:17:32 <nevere> Why wouldn't this type check. https://pastebin.com/e7Ww3kTZ
02:21:40 <nevere> I was trying to implement the `withSingDSI` function from this post. https://blog.jle.im/entry/introduction-to-singletons-1.html
02:22:49 <nevere> But I can't get this to typecheck, https://pastebin.com/e7Ww3kTZ
02:24:36 <nevere> What does something like "(Num a => r)" even mean?
02:31:17 <dminuoso> nevere: So in a lot of sense => acts as ->
02:31:49 <dminuoso> nevere: ⌜Num a => r⌝ means "given proof of Num a we can produce r"
02:32:30 <dminuoso> nevere: In order to use that ⌜r⌝ you would have to supply proof of ⌜Num a⌝ somehow.
02:35:06 <dminuoso> Im actually wondering right now, what ⌜data D = (forall a. Num a) => D Int⌝ even means.
02:35:43 <dminuoso> nevere: Did you perhaps mean ⌜data D where D :: Num a => a -> D⌝ ?
02:39:44 <phadej> dminuoso: former is valid syntax of latter, using only ExistentialQuantification extension
02:39:52 <phadej> i.e. no GADTs
02:40:27 <dminuoso> phadej: Oh interesting, Ive never ever seen that. :o
02:40:34 <phadej> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#existentially-quantified-data-constructors
02:40:53 <dminuoso> phadej: Ohh wait. I see. The parens completely threw me off.
02:40:56 <dminuoso> Heh.
02:41:03 <nevere> dminuoso, My problem with that explanation ("given proof of Num a we can produce r") is that there is no 'a' in the context?
02:41:37 <dminuoso> nevere: The constructor demands it.
02:42:17 <dminuoso> phadej: If I apply what phadej said, then your data type would be written in GADT style like this: ⌜data D where D :: Num a => Int -> D⌝
02:42:28 <dminuoso> iow: D :: Num a => Int -> D
02:42:42 <dminuoso> That's how I read it.
02:43:15 <dminuoso> Now if you use ⌜D 10⌝, then the constraint of the constructor D is not satisfied.
02:43:58 <nevere> dminuoso, The constraint is satisfied in the case branch, right?
02:44:35 <dminuoso> nevere: Check the error more carefully. I think it points you to ⌜D 10⌝ being the problem.
02:44:55 <dminuoso> % data D where D :: Num a => Int -> D
02:44:56 <yahb> dminuoso: ; <interactive>:22:14: error:; * Could not deduce (Num a0); from the context: Num a; bound by the type of the constructor `D':; forall a. Num a => Int -> D; at <interactive>:22:14-35; The type variable `a0' is ambiguous; * In the ambiguity check for `D'; To defer the ambiguity check to use sites, enable AllowAmbiguousTypes; In the definition
02:45:03 <dminuoso> % :set -XAllowAmbiguousTypes
02:45:03 <yahb> dminuoso: 
02:45:11 <dminuoso> % x :: D; x = D 10
02:45:11 <yahb> dminuoso: ; <interactive>:24:6: error: Not in scope: type constructor or class `D'
02:45:36 <dminuoso> % data D where D :: Num a => Int -> D
02:45:36 <yahb> dminuoso: 
02:45:39 <dminuoso> % x :: D; x = D 10
02:45:39 <yahb> dminuoso: 
02:46:10 <dminuoso> Nevermind I guess.
02:50:35 <ski> nevere : `data D = (forall a. Num a) => D Int' is very different from `data D = forall a. Num a => D Int'
02:51:22 <nil> what's the difference?
02:51:35 <ski> nevere : the former is equivalent to `data D where D :: (forall a. Num a) => Int -> D', while the latter is equivalent to `data D where D :: forall a. Num a => Int -> D' (which means the same as `data D where D :: forall a. (Num a => Int -> D)')
02:52:07 <ski> in the latter case, `D' is a polymorphic data constructor, polymorphic in `a' (which is constrained by `Num a')
02:53:17 <ski> in general, however, if you have a type `forall a. (..a.. -> ...)', where `...' doesn't mention `a', then this is equivalent to `(exists a. ..a..) -> ...' (note that `exists' in pseudo-Haskell. GHC doesn't support this syntax. but it's useful to be able to talk about types, in these terms)
02:53:22 <ski> e.g.
02:53:28 <ski>   length :: forall a. ([a] -> Int)
02:53:32 <ski> amounts to the same thing as
02:53:41 <ski>   length :: (exists a. [a]) -> Int
02:54:23 <ski> the former of these two signatures for `length' says that for all types `a', we can apply `length' to a list of elements of type `a', geting an `Int' back as result
02:55:09 <ski> the latter says that, we'll get an `Int' back as result, when applying `length', as long as there exists *some* type `a' such that the argument is a list of elements of type `a'
02:57:21 <sicklorkin> I'm not sure if I should use phantom types to deal with the broiler plate or someting else.https://pastebin.com/cSwdm6CD 
03:06:29 <ski> nevere : ooh .. i believe `withSingI :: Sing s -> (forall r. SingI s => r) -> r' in that blag is a typo, that it ought to be `withSingI :: Sing s -> (SingI s => r) -> r' ?
03:06:44 <ski> jle` ^ ?
03:09:12 <ski> nevere : anyway, if you wanted to have `withSingI :: Sing s -> (SingI s => r) -> r' be a function that unwraps (to a continuation/callback) a `Sing s', that's not a singleton, just an type that wraps evidence of `SingI s' into a value, then that would be
03:09:33 <ski>   data Sing s = SingI s => MkSingI
03:09:34 <ski> or
03:09:41 <ski>   data Sing s
03:09:43 <ski>     where
03:10:01 <ski>     MkSingI :: SingI s => Sing s
03:10:22 <ski> (er, actually i intended to have `MkSingI' instead named `MkSing' ..)
03:49:24 <statusfailed> Knuth-morriss-pratt searches for a "query" string within a larger string; is there a variant that finds multiple query strings?
03:50:38 <infinisil> statusfailed: Yeah, this library implements such a version: https://hackage.haskell.org/package/KMP-0.2.0.0/docs/Data-Algorithms-KMP.html#v:match
03:51:36 <statusfailed> infinisil: isn't that finding multiple results of the same querystring?
03:51:40 <statusfailed> rather than different query strings
03:51:47 <infinisil> Oh
03:51:59 <infinisil> Yeah you're right
03:52:27 <infinisil> But to match on multiple query strings, just match all of them on their own
03:53:07 <infinisil> OH
03:53:08 <statusfailed> infinisil: true, but I wonder if there is an algorithm with better complexity
03:53:15 <infinisil> Yeah I get it now
03:53:19 <infinisil> Hm..
03:53:31 <statusfailed> sees like it should exist, but I don't really understand how KMP works
03:53:36 <statusfailed> maybe better read up a bit
03:54:24 <infinisil> statusfailed: Yeah should be possible: Instead of having a single Int as a MatchState, use multiple ones
03:54:31 <infinisil> Each of them for a different table
03:54:43 <infinisil> This actually can probably be implemented with the matchSingle function
03:55:24 <infinisil> By writing a `matchSingleMultipattern :: Eq a => [Table a] -> [MatchState] -> a -> ([Bool], [MatchState])`
03:56:25 <infinisil> This way it just keeps track of multiple states, for each of the tables (which correspond to a pattern)
03:57:32 <statusfailed> iswym
03:57:36 <statusfailed> I guess that would work!
03:58:13 <infinisil> I actually PR'd this matchSingle function, and I didn't think of this application of it at the time 
03:58:22 <infinisil> But that's very neat this can be used for that
03:58:25 <statusfailed> ahah :D
04:08:26 <jle`> 🎿 ah, let me look into that
04:09:08 * hpc bets jle` typed that on a phone lol
04:09:22 <jle`> actually i have a plugin on my irc client that converts :codes: to emojis, heh
04:09:37 <jle`> but it does sometimes backfire on names, i wonder if i can disable it...
04:11:47 <jle`> ski : ah yes definitely a typo there, it's supposed to be the same as withSingDSI above
04:14:52 <infinisil> Is there some type family for vectors that give you the best possible vector type for the types you need to store?
04:15:27 <merijn> Tangential Haskell question: Anyone know any (haskell) packages that cite papers in their markdown/rST readme?
04:15:38 <infinisil> So it would choose unboxed vectors if there's an instance for it but fall back to boxed ones if not
04:15:39 <merijn> infinisil: Define "best possible vector type"?
04:16:31 <merijn> infinisil: I would question whether you could sensibly consider "unboxed" as best vector type
04:16:47 <infinisil> Well, yeah, just saw https://github.com/haskell/vector/issues/250 as well
04:17:03 <infinisil> But is there a type family for doing anything like that?
04:17:04 <ski> jle` : great :)
04:17:15 * ski looks at nevere
04:17:28 <infinisil> Seems like a perfect opportunity for a type family
04:17:43 <merijn> infinisil: I think it'd be vairly hard to work with, tbh
04:18:01 <jle`> verily fairly hard
04:18:14 <merijn> Typing is hard >.>
04:18:46 <infinisil> I'm imagining a use case where a library exposes some function over a generic type `a`, but internally needs to use an array over that type
04:19:14 <infinisil> But because the type is generic, it needs to use the boxed version, even though the type might be Int, which could use the unboxed ones
05:13:58 <sicklorkin> what's faster you reckon: ((foldl' (+)  0) &&& (scanl1 (+))) :: [Int] -> (Int,[Int])
05:14:11 <sicklorkin> or  let adds = scanl1 (+) xs in (sum xs, adds) :: [Int] -> (Int, [Int])
05:15:58 <maralorn> sicklorkin: I am very sure that on reddit or haskell weekly there was a mention of a command line tool exactly like you are looking for a few weeks ago.
05:16:20 <maralorn> Something like a haskell based sed/awk
05:16:51 <maralorn> I know this doesn’t help very much because I can’t remember the name.^^
05:16:54 <sicklorkin> maralorn: oh cool.. i recall someting too but I couldn't fin danyting
05:16:59 <sicklorkin> *anything
05:18:30 <sicklorkin> maralorn: I also recall another, but this was several years go
05:18:50 <maralorn> sicklorkin: Found it: https://np.reddit.com/r/haskell/comments/bycoj8/hsp_a_haskell_command_line_text_stream_processor/
05:18:56 <sicklorkin> maralorn: +1
05:19:54 <sicklorkin> maralorn: exactly what I was lookig for
05:20:49 * sicklorkin life just got that much easier 
05:27:30 * ski . o O ( "Haskell Server Pages" (HSP) by Niklas Broberg in 2005-05 (after Eric Meijer,Danny van Velzen in 2000-09-17) at <https://web.archive.org/web/20090225111630/http://www.cs.chalmers.se/~d00nibro/hsp/> )
05:28:17 <ibrox> hi there guys
05:28:24 <sicklorkin> ski are u suggesting hsp was a poor naming decision? 
05:28:50 <ibrox> I wanted to ask what are your thoughts on Haskell as a first language to learn for someone?
05:29:01 <dminuoso> ibrox: I dont think its an issue at all.
05:29:11 <dminuoso> ibrox: Haskell requires no previous knowledge or experience in programming.
05:29:12 <sicklorkin> ibrox: best gift ever
05:29:40 <dminuoso> ibrox: Might I recommend the "Haskell Book" to you perhaps? It's considered a good pick for people new to programming.
05:29:55 <merijn> ibrox: FWIW I've been teaching my girlfriend Haskell as first language (well, she did a little bit of matlab style stuff before) and it's fine
05:30:25 <sicklorkin> ibrox: i'm also buildig a game with my 8yr daughter
05:30:31 <dminuoso> In some sense it could be easier because you won't have to fight the frustration of learning a language all over from scratch again.
05:30:40 <merijn> ibrox: Most of the struggle has been lack of background familiarity with things like the command line, etc.
05:31:15 <merijn> (I mean, learning to program is still hard in Haskell, but not more so than I've seen beginning programmers struggle with other languages)
05:31:16 <ibrox> I mean I learned some python for data science and some study on the side but nothing to write home about. Want to stop messing around and really apply myself 
05:31:16 <ski> sicklorkin : i don't know. that's the first thing i was thinking about, when i saw "hsp". however, i suspect this one is long bit-rotten
05:31:42 <sicklorkin> ibrox: merijn made a very good point.. my kid only knows Ipad so CLI was kinda hard 
05:31:48 <ski> @where prerequisite
05:31:48 <lambdabot> "Prerequisite for Learning Haskell" <http://www.vex.net/~trebla/haskell/prerequisite.xhtml>
05:32:08 <ski> @where HPFFP
05:32:09 <lambdabot> "Haskell Programming: from first principles - Pure functional programming without fear or frustration" by Chistopher Allen (bitemyapp),Julie Moronuki at <http://haskellbook.com/>,#haskell-beginners
05:32:38 <merijn> ibrox: I have to say that Haskell has a bit more of a runway than python (i.e. you can't start writing the first useful program as quickly as you can write your first data science program in python)
05:33:36 * ski started with BASIC
05:33:46 <ski> (then assembler)
05:33:54 <ibrox> I am not a very good programmer, but even I kinda noticed how python kinda seems simplistic and always wondered if there is more to programming than that
05:34:01 <dminuoso> ibrox: Someone once in here told an anecdote how someone said "Im not very smart, so I learned Haskell instead of Python", arguing how Python can be much more difficult to write well, while Haskell makes writing bad code considerably harder. Things like equational reasoning go a really long way.
05:34:49 <dminuoso> ibrox: Most of the "python is easy" is not because the language is actually easy. You get to produce visible results with minimal efforts and no fights from the implementation - but if you ever have to construct non-trivial programs, then Python is one of the hardest languages to do it in.
05:35:08 <ibrox> dminuoso haha, fair enough 
05:35:51 <sicklorkin> ski: I think I would have called it h
05:35:53 <ibrox> I mean the way i saw it is kinda how python is like using a calculator whereas something low level is calculating manually 
05:36:14 <sicklorkin> or hc
05:36:29 <dminuoso> ibrox: That sense of abstraction exists in programming as well. You could construct a program manually by writing assembly, or you just write higher level code.
05:37:07 <ibrox> dminuoso yeah thats what i was trying to say 
05:38:31 <ski> sometimes people suggest BYOB <https://cloud.snap.berkeley.edu/> or Scratch <https://scratch.mit.edu/> for young people
05:38:44 <sicklorkin> ski: how man lines of code do you reckon you wrote in Basic (by the age of 10?)
05:39:03 <ski> (i remember trying Lego Mindstorms <https://www.lego.com/en-us/mindstorms/learn-to-program> a little, at some point)
05:39:24 <ibrox> merijn yeah I mean I heard some of my friends make jokes about haskell, how it is like super hard to learn and stuff, but I want to see it for myself 
05:39:30 <sicklorkin> ski: i started my daughter at 5yrs doing www.code.com
05:39:54 <dminuoso> ibrox: One main advantage you have when learning Haskell as your first language, is that you are not "ruined" by other languages. Things like the `=` sign carry the same meaning as they do in mathematics, its a denotation of equality.
05:39:57 <sicklorkin> 3hrs later she's doing animations Iin codeI
05:40:11 <dminuoso> ibrox: And thats something most people have probably learned in mathematics in highschool.
05:40:28 <ski> sicklorkin : "called it h" ?
05:41:00 <ski> oh, you mean the grep/sed/awk thingie ?
05:41:07 <sicklorkin> oui
05:41:43 <dminuoso> ibrox: So you dont need to unlearn existing mindmodels about what symbols mean, what programs mean..
05:41:55 <ibrox> dminuoso I heard a lot about how functional programming makes you think differently about problems compared to empirical programming. Can you tell me what they usually mean by this statement. 
05:42:10 <dminuoso> ibrox: Consider this:
05:42:13 <ski> sicklorkin : hm, dunno about lines of code. i remember i wrote some simple games, and some utility programs
05:42:41 <ibrox> dminuoso I mean I learned a bit of python, but I am pretty sure I can easily change my mindset 
05:42:47 <ski> (that was on C64. i started at age 6.5, but that was on a programmable calculator, which only had 544 bytes of RAM available for programs ..)
05:43:35 <dminuoso> ibrox: If in math I state I state: ⌜x = 7⌝ and I somewhere reference ⌜x⌝, say in some equation ⌜x + y = 10⌝, would you feel instantly justified by replacing ⌜x⌝ with 7 in that equation? Or equivalently, if you had ⌜10 + 7 = c⌝, would you feel justified in replacing ⌜7⌝ with ⌜x⌝?
05:43:51 <ski> ibrox : presumably you meant "imperative", not "empirical" ;)
05:43:55 <sicklorkin> ski: I wonder if learned pascal next
05:44:20 <ibrox> ski oh lol, sorry didnt sleep last night, my brain is kinda fried right now
05:44:36 <sicklorkin> ski: if _you_ 
05:44:40 <ski> sicklorkin : after (6502) assembler, next i saw (some) Prolog, then "C/C++", Java, Haskell, more Prolog, ...
05:44:55 <sicklorkin> Prolog 4?
05:45:11 <ski> 4 ?
05:45:51 <ski> ibrox : no worry
05:46:23 <ibrox> dminuoso yes
05:46:37 <dminuoso> ibrox: But why does that feel natural and right to you?
05:47:08 <ibrox> because of the equals sign 
05:47:31 <dminuoso> ibrox: Okay! So if we can replace one side with the other, let me present you with a Haskell example:
05:47:35 <sicklorkin> ski: version
05:48:03 <ski> sicklorkin : what do you mean, version ?
05:48:24 <dminuoso> ibrox: In Haskell we prepend an element onto a list using the : operator. So ⌜1 : 2 : 3 : []⌝ is basically a list ⌜[1,2,3]⌝ - that simple enough?
05:48:43 <sicklorkin> ski: I had to do one project in prolog and, sadly, my only recollection was that it needed to be version 4
05:48:50 <ibrox> dminuoso yes 
05:49:02 <dminuoso> ibrox: Using the equational reasoning I talked about above, what happens if I state this: ⌜ones = 1 : ones⌝
05:49:20 <dminuoso> ibrox: (Remember, if you see an equals sign, you can replace one side with the other)
05:49:35 <ski> sicklorkin : sounds like you may be talking about a version of an *implementation* of Prolog ? or are you referring to some specific standard ?
05:49:38 <sicklorkin> ski: it's possible I dreamt it
05:49:58 <ibrox> dminuoso ones = [1, 1 : ones]
05:50:17 <dminuoso> ibrox: Actually, ⌜ones = 1 : 1 : ones⌝
05:50:20 <sicklorkin> ski: i could't say either way..  
05:50:28 <dminuoso> ibrox: But if that holds true, can you perhaps do it again?
05:50:40 <ski> sicklorkin : i see. fair enough
05:51:29 <ibrox> dminuoso hmm I mean i am a bit confused a list that consists of itself and an additional member
05:51:51 <dminuoso> ibrox: Just do the equational reasoning we talked about.
05:52:06 <EvanR> [1, 1:ones] would be nonsense, a list of two items one of which is  a number, one of which is a list
05:52:18 <EvanR> lists consist only of elements of all the same type
05:52:39 <dminuoso> ibrox: If we know that ⌜ones = 1 : ones⌝, then we can equally say: ⌜ones = 1 : 1 : ones⌝, or ⌜ones = 1 : 1 : 1 : ones⌝, and if you follow that line of thought you will realize that this is really just ⌜1 : 1 : 1 : 1 : 1 : 1 ...⌝ ad infinitum
05:52:56 <dminuoso> So this generates an infinite list with 1 set for each element.
05:53:12 <dminuoso> We dont really specify "how we generate" that, we just specify what an infinite list of ones actually is.
05:53:12 <ski> @let ones = 1 : ones
05:53:18 <lambdabot>  Defined.
05:53:27 <ski>   ones  =  1 : ones  =  1 : 1 : ones  =  1 : 1 : 1 : ones  =  1 : 1 : 1 : 1 : ones  =  ...  =  1 : 1 : 1 : 1 : 1 : ...
05:53:46 <ibrox> oh, got it !
05:53:50 <ski> > ones
05:53:51 <ibrox> thanks
05:53:55 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:54:20 <ski> > take 8 ones
05:54:23 <lambdabot>  [1,1,1,1,1,1,1,1]
05:54:34 <dminuoso> ibrox: So we just describe what something is, rather than how it works.
05:54:52 <ski> > take 8 (repeat 1)
05:54:55 <lambdabot>  [1,1,1,1,1,1,1,1]
05:55:04 <ski> > take 8 [1,1 ..]
05:55:08 <lambdabot>  [1,1,1,1,1,1,1,1]
05:55:11 <ski> > take 8 [1,2 ..]
05:55:17 <lambdabot>  mueval-core: Time limit exceeded
05:55:25 <dminuoso> ibrox: Here's another motivating example, that really illustrates the core of declarative programming well in my eyes.
05:55:28 <ski> bah, try again, lambdabot !
05:55:31 <ski> > take 8 [1,2 ..]
05:55:36 <dminuoso> ibrox: What *is* a sorted list? How would you describe what a sorted list is?
05:55:38 <lambdabot>  mueval-core: Time limit exceeded
05:55:45 * ski gives up
05:56:20 <ibrox> a sequence of elements that are sorted according to a predefined rule 
05:56:20 <EvanR> it's like lighting your cigarette in the rain
05:56:39 <dminuoso> ibrox: What could you say about any element then?
05:57:13 <dminuoso> Wouldn't it be fair to say that for any element, it has the lesser elements (themselves sorted too!) to the left, and the greater elements (themselves sorted too!) to the right?
05:57:51 <ibrox> i was going to say that every element is bigger, equal or smaller than any other element in the list 
05:58:03 <EvanR> thats true of any list
05:58:18 <EvanR> not just sorted list
05:58:29 <ibrox> oh right
05:58:38 <ibrox> dminuoso yep 
05:58:52 <dminuoso> ibrox: Without further ado: https://gist.github.com/dminuoso/72673f306a5e63b8b81f5ec42373eaab
05:59:13 <dminuoso> That's an (inefficient) implementation of quicksort in Haskell. This is what declarative programming looks like.
06:00:03 <dminuoso> I used the specification of what a sorted list is to implement a sorting algorithm.
06:00:41 <dminuoso> sort (x:xs) = sort lesser ++ [x] ++ sort greater
06:00:43 <dminuoso> "for any element, it has the lesser elements (themselves sorted too!) to the left, and the greater elements (themselves sorted too!) to the right?"
06:00:54 <ski> > filter odd [0,1,3,6,10,15,21,28]
06:01:00 <lambdabot>  [1,3,15,21]
06:02:00 <dminuoso> ibrox: (I did a small accident flipping greater/lesser around, but a reversed sort is still a sort - so its irrelevant)
06:02:02 <ski> > filter (< 10) [3,10,5,16,8,4,2,1]
06:02:08 <lambdabot>  mueval-core: Time limit exceeded
06:02:29 <ski> > filter (< 10) [3,10,5,16,8,4,2,1]
06:02:36 <lambdabot>  mueval-core: Time limit exceeded
06:02:59 <ibrox> oh I got it
06:03:11 <dminuoso> ibrox: I dont talk about variables, assignment, moving things, returning things or any of that.
06:03:20 <ibrox> thanks ski for the explanation for what filter function does
06:03:32 <dminuoso> ibrox: I just declare what a sorted list is, and that itself is the implementation.
06:04:41 <ibrox> dminuoso I think i am starting to understand 
06:04:45 <ibrox> thank you
06:06:01 <ibrox> dminuoso this is awesome 
06:06:32 * ski idly recalls, when first hearing about FP (Haskell in particular), it being described as sortof like a spreadsheet, immutable values being propagated somehow
06:07:01 <ibrox> i think i understand now
06:08:54 <ibrox> Thanks everyone for taking your time to help me! I will read up on the resources that you guys have shared
06:09:09 <dminuoso> ibrox: If you ever have questions or troubles, feel free to ask. :)
06:09:22 <ibrox> Great! I will :)
06:12:43 <ski> ibrox : the "Prerequisite" link talks a bit about what math can be useful, to learn Haskell (other math, like e.g. calculus doesn't really help). but if you don't feel that confident about some of what it mentions, you can most probably learn along the way
06:14:39 <dminuoso> For a single argument, would you prefer pattern matching with multiple functions over case-of?
06:15:01 <dminuoso> I've started to somewhat dislike using multiple function declarations (is that even the correct technical description) because it's a lot more verbose.
06:16:07 <ski> (s/multiple functions/multiple defining equations/, i'd probably say)
06:16:35 <ski> depends, but i usually prefer multiple defining equations
06:17:07 <dminuoso> ski: Does that perhaps depend on the number of cases?
06:17:15 <ski> because then they can be read as true statements about the operation being defined
06:17:31 <dminuoso> Yeah, it is a bit more declarative, isnt it.
06:17:48 <ski> especially if there's no overlap, since then each equation can be read and understood in isolation from all the other ones
06:18:29 <ski> no, i don't mind having twenty or whatever defining equations
06:19:03 <EvanR> if there is overlap, would you recommend writing it different so there isn't any
06:19:04 <ski> however, if there's several other parameters, that just get repeated, i might sometimes define a local function that has those as nonlocals, rather than as parameters
06:19:14 <ski> and then have that local function do the pattern-matching
06:19:43 <dminuoso> ski: So you try to avoid case-of whenever you can do it with "function pattern matching" (for lack of a better term here)
06:20:03 <dminuoso> *avoid case-of whenever you can and replace it with
06:20:20 <dminuoso> or perhaps "function-case-of" ?
06:20:25 <ski> EvanR : i usually think of whether there's an easy was to make them non-overlapping, without adding many extra cases (or worse, multiplying)
06:20:37 <dminuoso> Does GHC have a name for it?
06:20:51 <ski> (disjunctive patterns could help here, sometimes)
06:21:12 <EvanR> what's a disjunctive pattern
06:21:31 <ski> e.g. sometimes i do `xs@(_:_)', even if i know it can't be empty, just to make the defining equation non-overlapping
06:22:04 <duairc> Is there some way to introspect the runtime from GHCi? Specifically I want to see what threads are running. There is some thread running in the background using 100% CPU and I can't figure out who forks it or what it's doing
06:22:09 <ski> EvanR : aka or-pattern. a pattern that matches if one of the subpatterns match. binds variables that would be bound by each subpattern
06:22:09 <maralorn> Is there somewhere a String-Types conversion Matrix for Haskell?
06:22:21 <duairc> Or do I finally have to learn how to use profiling? :P
06:22:43 <AWizzArd> Looking for a logging lib where I can implement my own function that will write into the destination of my choice (AWS CloudWatch). I guess that this logging lib would offer me a type class where I have to implement some `log` method.
06:22:59 <ski> EvanR : <https://rosettacode.org/wiki/Pattern_matching#OCaml> has a nice example of disjunctive patterns, in OCaml
06:23:14 <ski> there has been talk about adding disjunctive patterns to GHC, iirc
06:25:17 <ski> dminuoso : whenever i can do "matching in the head" of defining equations, without undue code complication, yes
06:25:32 <EvanR> that looks cool
06:26:06 <dminuoso> "function-pattern" perhaps?
06:26:08 <ski> maralorn : hm, what do you mean ?
06:26:12 <dminuoso> ski: I see, thank you.
06:26:22 <dminuoso> AWizzArd: Look into MonadLogger
06:26:41 <ski> dminuoso : by "function-pattern", i mean something else ..
06:27:41 <nshepperd1> It should be possible to define a pattern synonym as a disjunction of patterns using viewpatterns and a helper function
06:27:42 <AWizzArd> dminuoso: danke
06:27:53 <nshepperd1> Not very convenient though
06:29:01 <maralorn> ski: I mean a table with From, To and String, Text, ByteString, LazyText, LazyBytestring, etc.
06:29:43 <ski> hm, i can't recall seeing any such table
06:30:15 <EvanR> i cant imagine whats in the cells if thats the two axes
06:30:29 <EvanR> checkmark or blank?
06:30:54 <nshepperd1> Function name i assume
06:31:07 <ski> nshepperd1 : hm, i was wondering whether it would be possible. any idea how that could work ?
06:31:14 <merijn> maralorn: Only Text and String can be converted sensibly
06:31:15 * ski doesn't see it, atm ..
06:31:18 <EvanR> a graph with those types as nodes and directed edges with a conversion function would be cool
06:31:50 <merijn> maralorn: You can convert Text between lazy and strict, and you can convert both Text types from/to String
06:32:04 <merijn> maralorn: ByteString can't be converted directly
06:32:13 <merijn> At least, not without doing something that will get me to yell at you
06:32:31 <EvanR> like this for time type: http://i.imgur.com/g6rTcZK.png
06:32:35 <merijn> Well, you can convert lazy and strict ByteString to eachother
06:32:57 <EvanR> well similar
06:32:57 <dminuoso> AWizzArd: Equivalently, if you are using monad transformer stacks, monad-logger offers you LoggingT (with a suitable MonadLogger instance)
06:33:28 <merijn> The great thing about monad-logger is that you can later always replace the logging implementation with a custom one if you need it :)
06:33:32 <dminuoso> AWizzArd: Under the hook it's just a ReaderT with a logging function and some convenient methods for logging (especially the TH methods are really great)
06:33:32 <AWizzArd> I am using those, so it might be an interesting integration.
06:33:38 <Lycurgus> YELLING?
06:33:47 <nshepperd1> ski: helper function does the matching and produces Maybe (a,b,c) and the pattern is.. uh.. pattern MyPattern x y z <- (helper -> Just (x, y, z))
06:33:51 <dminuoso> AWizzArd: Because its a different type it wont conflict with any of your ReaderT.
06:33:53 <AWizzArd> merijn: that’s good, because I actually might have to do exactly that.
06:33:58 <nshepperd1> ski: I forget the exact syntax
06:34:16 <dminuoso> AWizzArd: monad-logger and unliftio are perhaps the two greatest things coming out of the snoyman shop :P
06:34:35 <merijn> AWizzArd: LoggingT already lets you provide custom implementations, but you can make them even more custom and eliminate LoggingT entirely if needed
06:34:40 <dminuoso> Well okay, there's also conduit..
06:34:54 <ski> nshepperd1 : perhaps if the pattern synonym defined a helper function (or used a `case'), in terms of the patterns
06:35:05 <merijn> dminuoso: You mean, monad-logger and unliftio-core are what you get from iterating the same problem space for N billions times and finally find a locally optimal sweetspot ;)
06:35:06 <AWizzArd> I’ve seen unliftio a million times but don’t know exactly what it is good for.
06:35:11 * ski isn't quite sure whether that would work, and whether it'd be allowed
06:35:15 <dminuoso> merijn: Indeed. :)
06:35:21 <merijn> AWizzArd: You know bracket?
06:35:33 <AWizzArd> merijn: using it.
06:35:58 <maralorn> merijn: I use decodeUtf8. Does that make you yell at me?
06:36:02 <dminuoso> AWizzArd: In principle its the inverse of liftIO :-P 
06:36:08 <merijn> AWizzArd: "bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c" <- notice how the last argument makes it super freaking hard to run generic code (like transformers over IO inside)
06:36:37 <merijn> maralorn: You should use decodeUtf8' *or* decodeUtf8With
06:36:41 <AWizzArd> dminuoso: I use liftIO to lift an IO value into my AppT. But I am not sure why I would want to go from an AppT value back to IO.
06:36:59 <merijn> AWizzArd: To run AppT inside bracket :)
06:37:10 <merijn> AWizzArd: Or fork it to a new thread, etc.
06:37:17 <dminuoso> AWizzArd: Imagine your favourite library gave you ⌜withHandle :: (Handle -> IO a) -> IO a⌝
06:37:28 <AWizzArd> merijn: hmm hmm, I think it begins to make sense.
06:37:45 <dminuoso> AWizzArd: How would you use such a function in your NotIO stack?
06:38:01 <AWizzArd> dminuoso: wouldn’t I have to liftIO it?
06:38:05 <merijn> AWizzArd: UnliftIO basically only allows ReaderT-like transformers (where you can safely unwrap them to their core) allowing you to wrap bracket like patterns to handle complex stacks
06:38:09 <dminuoso> AWizzArd: Look at the signature of liftIO.
06:38:11 <dminuoso> AWizzArd: It wont work.
06:38:32 <dminuoso> AWizzArd: Essentially the problem is that IO appears in a negative position.
06:38:47 <EvanR> :t unliftIO
06:38:50 <lambdabot> error:
06:38:51 <lambdabot>     • Variable not in scope: unliftIO
06:38:51 <lambdabot>     • Perhaps you meant ‘liftIO’ (imported from Control.Monad.Writer)
06:38:53 <maralorn> merijn: Point taken. But I use it in a script which is supposed to crash when it doesn’t work. (As in I wouldn’t know how to recover from a non unicode nix store Path.^^)
06:38:55 <AWizzArd> dminuoso: ah okay, so this is comparable to the variance stuff and Functors?
06:39:00 <merijn> maralorn: decodeUtf8 can still unexpectedly throw an exception. decodeUtf8' force error handling, but in case you just want to ignore errors decodeUtf8With is strictly better than decodeUtf8 since you can specify how to treat errors
06:39:42 <dminuoso> AWizzArd: what you need is this: withHandle $ \handle -> unliftIO (doThingsInYourMonadWith handle)
06:40:00 <merijn> dminuoso: You also need to liftIO the withHandle result ;)
06:40:07 <dminuoso> Oh yeah.
06:40:10 <dminuoso> Possibly.
06:40:13 <dminuoso> Or perhaps not?
06:40:20 <dminuoso> It depends on what you want to do really
06:40:36 <AWizzArd> dminuoso: got it
06:40:49 <dminuoso> AWizzArd: unliftio gives you this unliftIO utility, not quite as directly because type system reasons.
06:41:06 <dminuoso> withRunInIO $ \unliftIO -> ...
06:41:10 <AWizzArd> merijn: okay, so on the outside I _do_ need liftIO, but inside I will unliftIO.
06:41:16 <merijn> Yeah
06:41:19 <dminuoso> AWizzArd: You may need it, if you want.
06:41:29 <dminuoso> But not necessarily, since perhaps you just want the monad run inside
06:42:11 <dminuoso> But the default use case is "unlift inside, and lift ouside" - and thats precisely what withRunInIO does.
06:42:49 <AWizzArd> k
06:43:41 <dminuoso> AWizzArd: https://gist.github.com/dminuoso/5d4bf6cf079c1355125d865de196597c this is an example of withRunInIO in action.
06:43:46 <dminuoso> (Also monad-logger by the way)
06:44:29 <AWizzArd> dminuoso: and with bits of ldap, which is good because a friend just needs right that :-)
06:45:16 <dminuoso> AWizzArd: Aee you using ldap-client?
06:46:12 <AWizzArd> dminuoso: I myself don’t use any ldap. But a friend who just started a new Haskell project needs to do ldap.
06:46:29 <AWizzArd> I will tell him about ldap-client.
06:47:02 <dminuoso> It's solid, the implementation easily verifiable since its pure haskell..
06:47:31 <dminuoso> I made a fork of it to support connection pooling (using the primitive you have seen), but the maintainer seems to have abandoned the project.
06:47:45 <ski> nshepperd1 : ok, so given some patterns, you can define a pattern synonym which is the disjunctive pattern of those. but i can't see how to define a pattern synonym `Or' so that `Or p0 p1' will be a disjunctive pattern of `p0' and `p1'
06:48:04 <AWizzArd> dminuoso: what is the license on your snippet? (:
06:50:42 <dminuoso> AWizzArd: We're probably going to release a small ldap utils library soon. We're not set on the license yet, but it's probably going to be BSD 2 or 3 clause.
06:52:40 <dminuoso> LDAP is incredibly frustrating to work with though.
06:54:22 <merijn> dminuoso: I've got a good joke for you :D
06:54:32 <merijn> dminuoso: You know what the L in LDAP stands for?
06:54:44 <dminuoso> merijn: If you know its origins it *is* lightweight :P
07:03:53 <wbekntl> test
07:04:59 <Lycurgus> phail
07:09:12 <monochrom> mzero
07:43:24 <wbekntl> :t traverse
07:43:28 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
08:16:44 <jakov2> Hello ! Do You know any way to decode invalid json, that is formatted like that: ("{name:\"hansgros\", age:23}" :: UTF8.ByteString) ?
08:17:26 <nil> is there a difference betwen  forall B. A -> B  and  A -> (forall B. B)  ?
08:17:39 <c_wraith> nil, yes.
08:18:07 <c_wraith> nil, well, assuming you are using lowercase letters, at least.
08:18:17 <nil> oops yeah
08:19:24 <nil> i'm not sure what it is i'm asking precisely, i guess something like "are they isomorphic?"
08:19:37 <vaibhavsagar> jakov2: no
08:19:41 <nil> i'm having trouble reasoning about the latter one
08:19:48 <ski> `... -> (forall a. ..a..)' is iso to `forall a. (... -> ..a..)', yes
08:20:07 <nil> how would you prove something like this?
08:20:27 <ski> it's basically `flip'ping, of a sort
08:20:55 <ski> (and `(exists a. ..a..) -> ...' is iso to `forall a. (..a.. -> ...)', that's basically `curry'ing ..)
08:21:10 <nil> i'm not seeing the connection to flip
08:22:22 <ski> in a dependently typed language `forall (a :: K). F a' becomes `(a :) K -> F a', a dependent function type from an input of type (well, kind in this case) `K', call it `a', to an output of type `F a'
08:23:19 <pong> nil: hi
08:23:28 <ski> and `exists (a :: K). F a' becomes `(a :) K * F a', a dependent pair type, consisting of a value (well, here a type) `a' or type (kind, here) `K', and a value of type `F a'
08:23:30 <nil> hi pong
08:24:50 <nil> ski: i think i see the idea
08:25:09 <ski> iow, we think of e.g. `exitSuccess', of type `forall (a :: Type). IO a' as being a "function" from an input in `Type', call it `a', to an output in `IO a'. in the above notation, `exitSuccess : (a :) Type -> IO a'
08:25:18 <nil> why are we shifting values to types and types to kinds here?
08:25:49 <ski> and then, if you wanted to use `exitSuccess' in a context where say `IO Integer' was expected, you'd not say just `exitSuccess', but `exitSuccess Integer', in order to yield a value of type `IO Integer'
08:26:06 <ski> nil : because we're talking about polymorphism
08:26:45 <ski> we want to feed a *type* `a' (like e.g. `Integer') to `exitSuccess', not a value. but we get a value (an `IO'-action) back
08:26:58 <nil> ah, right.
08:26:58 <ski> so, you can imagine e.g.
08:27:09 <ski>   id : (a :) Type -> a -> a
08:27:13 <ski>   id a x = x
08:28:05 <ski> here `a -> a' (non-dependent function type) can be thought of as short for `(_ :) a -> a', iow a special case of the dependent function type, where we don't care to name the input value (because we don't need to refer to in the result type)
08:28:22 <ski> however, you can also have things like
08:28:32 <ski>   Vec : Type -> Nat -> Type
08:28:53 <ski> where `Vec Integer 3' is the type of vectors/lists of length `3', with `Integer' elements
08:29:05 <ski> then you can consider e.g.
08:29:54 <ski>   replicate : (a :) Type -> (n :) Nat -> a -> Vec a n
08:30:33 <ski> so `replicate Bool 3 False' will compute a `Vec Bool 3', consisting of the three elements `False',`False',`False'
08:31:01 <ski> the first input to `replicate' here is a type, but the second input is a value
08:31:49 <nil> this is enlightening
08:31:57 <ski> in Haskell terms, one could imagine `replicate :: forall (a :: Type) (n :: Nat). a -> Vec a n'
08:32:34 <ski> however, one can't bind *value* variables (like `n') with `forall' (in types), in Haskell. only type variables (like `a')
08:33:13 <ski> also, in the above sketch of a dependent programming language, all these parameters to `exitSuccess',`id',`replicate', whether they are types or values, are *explicit* parameters
08:34:15 <ski> otoh, in Haskell, the type variables that are bound by `forall', in a polymorphic value, will be *implicitly* supplied by the system (which types to use typically comes from type inference)
08:35:11 <ski> you don't write `map Integer Bool odd [0,1,3,6,10,15,21,28]' in Haskell, you just write `map odd [0,1,3,6,10,15,21,28]'
08:35:16 <nil> yeah
08:35:37 <nil> well you might hint the type system with type annotations
08:35:58 <ski> (though, with the `TypeApplications' extension, you can actually write `map @Integer @Bool odd [0,1,3,6,10,15,21,28]')
08:36:36 <ski> yea, you can use type ascriptions (that's why i said "typically"). sometimes you need something like that, to pin down some ambiguity
08:37:21 <ski> anyway, consider the type `(Integer,Bool)'. let me write it in a more ML-style, as `Integer * Bool'. this is a "cartesian product" (see set theory) of the types `Integer' and `Bool'
08:38:12 <ski> (note that `Bool * Ordering' has `2 * 3', iow `6' elements, since `Bool' has two and `Ordering' has three elements. similarly one could write `Either Bool Integer' as `Bool + Integer', since the number of elements here is `2 + 3', iow `5')
08:38:37 <nil> yeah, i'm comfortable with this
08:38:41 <ski> now, consider a value of type `exists a. ..a..', an "abstract value"
08:38:51 <ski> e.g. one might define
08:39:51 <ski>   type QueueOps a = exists q. ({- empty queue -} q,{- enqueue -} a -> q -> q,{- dequeue -} q -> Maybe (q,a))
08:39:59 <ski> for a type of queue implementations
08:40:12 <ski> e.g.
08:40:25 <ski>   listQueue :: forall a. QueueOps a
08:40:47 <ski>   listQueue = (empty,enqueue,dequeue)
08:40:48 <ski>     where
08:40:54 <ski>     empty = []
08:41:11 <ski>     enqueue x q = x : q
08:41:29 <ski>     dequeue [] = Nothing
08:41:39 <ski>     dequeue q  = Just (init q,last q)
08:41:49 <ski> (this is a pretty inefficient implementation, of course)
08:42:24 <ski> here, we have picked `q' to be `[a]'
08:43:18 <ski> `(empty,enqueue,dequeue)' has type `([a],a -> [a] -> [a],[a] -> Maybe ([a],a))'. therefore there exists some type `q' such that it has type `(q,a -> q -> q,q -> Maybe (q,a))'
08:43:48 <ski> and it has type `exists q. (q,a -> q -> q,q -> Maybe (q,a))', or `QueueOps a', for short
08:43:53 <ski> nil : makes sense ?
08:44:38 <ski> instead of enqueing to the front of the list, one could of course add the element to the back. that's not so efficient, but then `dequeue' becomes more efficient instead
08:44:43 <nil> i think so
08:45:08 <nil> to be clear, the "exists" syntax isn't Haskell, right? or is it available through some extension?
08:45:17 <ski> it's pseudo-code, yes
08:45:24 <nil> ok
08:45:56 <ski> (there are/were some Haskell implementations that had partial support for `exists' .. but only in the "not really interesting" situation of using it in argument types ..)
08:47:04 <ski> however, i tend to think it's nicer, when dealing with things like this, to reason about them at this conceptual level, instead of immediately having to much around with how to *encode* an existential type in Haskell (there's *two* ways, with extensions. sometimes one is to be preferred over the other. sometimes the other way around)
08:47:16 <nil> yeah, i guess Haskell lists are more suited for stacks than queues
08:47:23 <ski> yep
08:48:15 <nil> btw, is there a word for this kind of list structure? the  data List a = Nil | Cons a (List a)  kind
08:48:37 <ski> ((single-)linked) list
08:49:06 <ski> there is a "folklore" implementation of queues. the idea is that if you want to represent a queue, consisting of the elements of the list `front ++ back', then we can represent this as the pair `(front,reverse back)'
08:49:25 <nil> oh yeah i've seen this
08:49:50 <nil> enqueue on front, dequeue on back (or the opposite?)
08:49:56 <ski> so for the list `[2,8,5,7,1,4]', we could represent a corresponding queue as e.g. `([2,8,5],[4,1,7)' .. or as `([2],[4,1,7,5,8])', &c.
08:50:44 <ski> there's multiple representations (and so we're really dealing with a factor/quotient type here, which have a custom-defined equality (from an equivalence relation on the representation type))
08:51:03 <ski> anyway, the point here is that we get easy access to both ends of the queue
08:51:09 <nil> yeah
08:51:24 <ski> however, when one of the two lists runs out, we must reverse the other one, and move it over
08:51:45 <ski> but, we still get *amorticized* linear time enqueue and dequeue
08:52:01 <ski> so, we can define
08:52:11 <ski>   folkloreQueue :: forall a. QueueOps a
08:52:15 <ski>   folkloreQueue = ...
08:52:19 <ski> (details omitted)
08:52:53 <ski> the point is here is that we have two values of the same type, `forall a. exists q. (q,a -> q -> q,q -> Maybe (q,a))'
08:53:13 <ski> but they have chosen to use *different* types for the `q' part
08:53:15 <nil> i see
08:54:32 <ski> to use/consume a polymorphic value of type `forall a. ..a..', the caller/user/consumer must pick/choose some particular specific type (say `T') to use in place of `a', and then they can use the polymorphic value as if it had type `..T..'
08:55:57 <ski> to define/produce/construct a polymorphic value of type `forall a. ..a..', the callee/implementor/producer must be able to handle any particular specific type (say `T') that the user decides to pick for `a' (in fact the producer can't even inspect which type was picked)
08:57:17 <ski> to define/produce/construct an "abstract" value of type `exists a. ..a..', the callee/implementor/producer must pick/choose some particular specific type (say `T') to select for `a', and then they must also produce a value of type `..T..'
08:58:36 <ski> to use/consume/deconstruct an "abstract" (/hidden/opaque/forgotten/skolem) value of type `exists a. ..a..', the user/consumer must be able to handle any particular specific type (say `T') that the implementor decides to pick for `a' (in fact the consumer can't even inspect which type was picked)
08:59:25 <ski> nil : so, wrt producer/implementor/caller vs. consumer/user/callee, the behaviour of `forall' and `exists' are opposite, the roles are flipped
09:00:21 <ski> (btw, which type `a' is picked, when constructing a value of type `exists a. ..a..', can depend on run-time inputs)
09:00:24 <ski> e.g.
09:00:42 <ski>   silly :: Bool -> exists a. (a,a -> a,a -> String)
09:01:04 <ski>   silly False = (0 :: Integer,succ,show)
09:01:17 <ski>   silly True  = ("False",reverse,id)
09:01:49 <ski> in the first case, the triple has type `(Integer,Integer -> Integer,Integer -> String)', and therefore it also has type `exists a. (a,a -> a,a -> String)'
09:02:16 <ski> in the second case, the triple has type `(String,String -> String,String -> String)', and therefore it also has type `exists a. (a,a -> a,a -> String)'
09:02:46 <ski> (note that we don't have to "abstract away" all instances of `String', we get to decide which to "hide" behind the existentially quantified tyvar `a')
09:03:45 <nil> i understand
09:03:46 <ski> nil : anyway, i wanted to refresh your knowledge of existentially quantified types, and values of such types a little, before going back to dependent types
09:04:38 <ski> recall
09:04:43 <ski> <ski> anyway, consider the type `(Integer,Bool)'. let me write it in a more ML-style, as `Integer * Bool'. this is a "cartesian product" (see set theory) of the types `Integer' and `Bool'
09:05:04 <ski> in terms of dependent types, a type like `exists (a :: K). F a' corresponds to a dependent pair/product type `(a :) K * F a'
09:05:27 <ski> this is a product of `K' and `F a', where `a' is the value of type `K', in the pairs of this type
09:05:53 <ski> iow, a value of type `exists (a :: K). F a' is to be thought of as a *pair* of a type `a', and a value of typr `F a'
09:06:14 <nil> sure
09:06:15 <ski> but in the pseudo-Haskell above, the first part of this pair is *implicit*, we don't see it
09:07:08 <ski> similarly, as i said before, a value of type `forall (a :: K). F a' can be thought of as a *function* taking as input a type `a', and computing as output a value of type `F a'
09:07:57 <ski> i find it sometimes helpful to think in these terms, about `forall' and `exists', even if the type parameter in the first is implicit, and the type bundled (with a value) in the second is also implicit
09:08:10 <ski> now, let's go back to
09:08:20 <ski> <ski> `... -> (forall a. ..a..)' is iso to `forall a. (... -> ..a..)', yes
09:08:25 <ski> <ski> it's basically `flip'ping, of a sort
09:08:30 <ski> <ski> (and `(exists a. ..a..) -> ...' is iso to `forall a. (..a.. -> ...)', that's basically `curry'ing ..)
09:08:33 <nil> is there, in logic, the same kind of connection between universal quantification and implication, and between existential quantification and conjunction?
09:08:42 <ski> let's say we have
09:09:00 <ski>   foo : T -> (x :) U -> F x
09:09:01 <ski> then
09:09:15 <ski>   flip foo : (x :) U -> T -> F x
09:09:36 <nil> yeah i see that now
09:09:56 <ski> so, we're just reordering the non-dependent and the dependent parameters (in the Haskell case, flipping the order of the value parameter, and the type parameter)
09:10:06 <ski> and say
09:10:27 <ski>   bar : (x : U) * F x -> T
09:10:28 <ski> then
09:10:37 <ski>   curry bar : (x : U) -> F x -> T
09:11:09 <ski> so, instead of taking a pair as input, we, curriedly, take the previous pair components as two separate parameters
09:11:33 <nil> i'm not sure about the formalism used here. does  (x :) U  differ from  (x : U)  ?
09:11:49 <ski> sorry, i meant to write `(x :) U' there
09:11:53 <nil> ok
09:13:03 <ski> (in Agda, the notation is `(x : U) -> ..x..' .. but i tend to prefer writing `(x :) U -> ..x..', when writing notes, since it makes it more clear which are the "main parts" (`U' and `..x..'), and which is the "dependent afterthought" (naming the input `x'))
09:13:12 <ski> (in the Haskell case, instead of taking the type and the value together, we first take the type, then the value)
09:13:27 <nil> i see
09:13:33 <ski> however, as i said, the type passing, and type bundling, with `forall' and `exists' is *implicit*
09:13:50 <ski> so, in terms of producing and consuming values, we don't see any difference between
09:13:57 <ski>   length :: forall a. ([a] -> Int)
09:13:58 <ski> and
09:14:07 <ski>   length :: (exists a. [a]) -> Int
09:14:24 <ski> and similarly also we see no difference between
09:14:37 <ski>   take :: forall a. (Int -> ([a] -> [a]))
09:14:38 <ski> and
09:14:46 <ski>   take :: Int -> (forall a. ([a] -> [a]))
09:17:12 <ski> <nil> is there, in logic, the same kind of connection between universal quantification and implication, and between existential quantification and conjunction?
09:18:07 <ski> yes, the equivalence between `A -> (forall x. P x)' and `forall x. (A -> P x)', and also the one between `(exists x. P x) -> A' and `forall x. (P x -> A)', are *logical* equivalences
09:18:48 <ski> while i'm already talking about this, i could just as well introduce my (pseudo-Haskell) notation `*>'
09:20:11 <ski> a value of type `Cxt => T' is a value such that, if you provide evidence for the constraint `Cxt', then you may use the value as if it had type `T'. when constructing a value of type `Cxt => T', you're free to assume evidence for `Cxt' will be given, when you produce a value of type `T'
09:21:05 <Guest_37> Hi, I'm installing Haskell on Mac thru https://www.haskell.org/ghcup/, when I run the command on terminal it eventually fails, tells me "Following commands are required, but missing, please install:  xz" What am i supposed to be installing?
09:21:49 <Guest_37> pls pardon the ignorance 
09:21:50 <glguy> You should install xz: brew install xz if you're using homebrew
09:21:52 <ski> a value of type `Cxt *> T' is a value such that, when using it, you get to assume evidence for the constraint `Cxt' will be given to you, in addition to a value of type `T'. when constructing a value of type `Cxt *> T', you must both provide evidence for `Cxt', as well as producing a value of type `T'
09:22:15 <ski> nil : does that make sense ?
09:22:16 <glguy> Guest_37: It's not actually necessary but ghcup tries to stay extremely portable and so it does separate decompression step
09:22:41 <merijn> I think macos's tar can extract xzip just fine
09:22:55 <glguy> That's correct, but the ghcup script doesn't know it
09:23:03 <nil> ski: yes, and i'm kind of seeing how *> is to exists what => is to forall
09:23:13 <Guest_37> I see, using this http://macappstore.org/xz/ ?
09:23:35 <glguy> Guest_37: I'd recommend HomeBrew instead
09:23:36 <ski> nil : yes, `forall',`=>',`(->)' compares to `exists',`*>',`(,)'
09:24:02 <glguy> Guest_37: Err, I guess that website just gives you homebrew instructions like I showed above
09:24:25 <glguy> Guest_37: The actual website for Homebrew is homebrew
09:24:29 <glguy> https://brew.sh
09:24:30 <Guest_37> ah right, ok thanks! 
09:24:54 <merijn> glguy: If you're already comfortable with the command line you can also just install the GHC binary distribution for macOS
09:24:57 <merijn> eh
09:25:03 <merijn> s/glguy/Guest_37
09:25:11 <ski> nil : in Haskell, the evidence for `Cxt' is also implicitly propagated. however, in a type erasure implementation, there won't actually be any representation of types shuffled around at run-time, with values of `forall'- and `exists'- type. however, for constraints, there (in general) *will* need to be a run-time representation of the constraint evidence that is shuffled around
09:25:19 <glguy> It's worth having ghcup to make it easy to manage different versions, install cabal, etc
09:25:29 <glguy> and having homebrew around will be useful for other things
09:26:21 <ski> nil : so, in terms of dependent types (or even the simpler System F), you can think of `Cxt => T' as `DictCxt -> T' and `Cxt *> T' as `DictCxt * T'
09:26:27 <merijn> glguy: Managing versions with binary dists isn't particularly hard either, cabal-install also has a binary download these days. But then I'm a stubborn curmudgeon :)
09:27:00 <ski> (where `DictCxt' is a type, where a value of that type represents evidence for the constraint `Cxt')
09:27:57 <ski> nil : e.g. `class Eq a where (==),(/=) :: a -> a -> Bool' will correspond to `data DictEq a = MkDictEq {(==),(/=) :: a -> a -> Bool}'
09:28:27 <dmj`> `\record -> record { field = newFieldValue | predicate }` could Haskell support syntax like this, conditional record updates based on a predicate
09:28:44 <nil> ski: that makes sense
09:29:25 <ski> nil : and `instance Eq a => Eq [a] where ...' will correspond to `instEqList :: forall a. DictEq a -> DictEq [a] ; instEqList instEqA = ...'
09:29:50 <ski> (this is called the dictionary-passing translation, for class constraints)
09:30:13 <ski> nil : now, typically `=>' goes with `forall', and `*>' goes with `exists'
09:30:22 <merijn> dmj`: YOu can trivially write syntactic sugar for that, so why not?
09:30:37 <merijn> dmj`: Whether haskell should add even more very specific sugar for it is another question
09:30:38 <nil> does this mean we can use typeclasses in haskell without ever using the "class" keyword, if we do a bit of gymnastics?
09:32:05 <ski> nil : we'd not be using type classes, but we could simulate them like that, yes. however, we'd get less guarantees (and more verbosity. however we also get more flexibility). there's at most one instance of a type, for a type class. but we can have multiple values of type `DictOrd String', say. this can be both good and bad
09:32:55 <ski> nil : when dealing will collection types which rely on always using the same ordering for elements (or keys), we'd prefer not being able to pass an incompatible ordering relation
09:33:32 <dmj`> merijn: what does the trivial syntactic sugar for this look like
09:33:44 <ski> (one could attempt to store the ordering itself inside the collection. but then we can't (easily, at least) merge two collections of the same type, since they might use different orderings)
09:34:33 <nil> i see
09:35:16 <ski> (it is possible to use existentials in a way to mimic abstract data types, that can handle this merge situation as well. the "store ordering inside collection" is more like an object-oriented solution (which *also* can be described by a (different !) use of `exists'))
09:36:01 <ski> nil : if you want a map indexed by `ID's, where corresponding values should be of any type, as long as it's an instance of `Widget', then that can be expressed as `Map String (exists a. Widget a *> a)'
09:36:39 <ski> (note that `exists a. Widget *> Map String a' is something different. here all elements have the same (unknown/forgotten/hidden/abstract/opaque/skolem) type `a')
09:38:09 <ski> also, note that while having values whose type is an interface `Widget', in Java or C# (or `Widget' being an abstract base class in C++), corresponds to having values of the type `exists a. Widget a *> a'
09:39:02 <ski> the type `exists a. Widget a *> [a]' (say) can't be easily expressed in such a fashion (all the elements of the list have the same type `a')
09:39:27 <merijn> dmj`: "\record -> if predicate then record { ...} else record"?
09:40:36 <ski> also, please don't go overboard with `exists' and `*>' ! existentials is a powerful mechanism, but can also be harder to reason about, and introduce certain problems. don't use it in overkill situations !
09:40:45 <ski> @where existential-antipattern
09:40:45 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
09:41:27 <ski> nil : i've only talked about the conceptual view of `exists' and `*>'. if you'd like to, i could go on to show how one can currently *encode* these in current Haskell (with current extensions)
09:41:54 <ski> nil : .. or, perhaps this is enough to think about, for the moment
09:41:55 <nil> no, i'm not interested in using them practically
09:42:03 <nil> this is more than enough :D
09:42:03 <ski> okay
09:42:13 <nil> i've learned so much today
09:42:22 <nil> thank you for your clear explanations
09:42:42 <ski> btw, i should at least state the following logical equivalences as well (compare to earlier ones with `forall' and `exists') :
09:43:01 <ski> `T -> Cxt => U' is equivalent to `Cxt => T -> U'
09:43:26 <ski> `(Cxt *> T) -> U' is equivalent to `Cxt => T -> U'
09:44:10 <ski> nil : you're welcome
09:44:17 <nil> flip and curry again, this time under the dictionary-passing translation
09:44:25 <ski> yep
09:46:19 <nil> you mentioned "skolem" in the context of "exists", does that have anything to do with skolemisation? (it's the only thing i know Skolem for)
09:49:07 <ski> "skolem (constant/function)" is a term that is sometimes used in place of what GHC (now) called "rigid type variable"
09:49:22 <ski> (i think GHC used to use the term "skolem", at some point)
09:49:56 <ski> (and yes, it is related to skolemization)
09:50:29 <nil> ok, thanks
09:50:59 <ski> when you have a type variable, that you can pick and choose to be anything you like, then you have a meta-variable, or a template variable (called logic variable, in logic programming, and dataflow variable in concurrent logic programming)
09:51:17 <ski> e.g., when you *use* a polymorphic value like `length'
09:52:02 <ski> but also, when you *implement* an abstract value (like `listQueue' above) -- because then you're also entitled to pick whichever type you like
09:53:43 <ski> otoh, when you have a type variable, that you're *not* allowed to pick and choose (or even inspect, check which type it is), that someone else will (conceptually) pass to you, after they've picked it, then you have a rigid type variable, or a skolem (constant/function). (in logic programming, these are more or less called "atoms", although typically you can't quantify them in a local scope there (in lambdaProlog, you can))
09:54:34 <ski> so, e.g. when you *implement* a polymorphic value like `length', you must treat the element type as abstract/opaque/hidden/forgotten .. / rigid / skolem
09:55:26 <ski> also, when you *use* an abstract value, like `listQueue', you must be satisfied with whatever implementation/representation type the implementation picked for the queue type `q' -- so this is still a skolem here
09:56:36 <ski> my point is that the dichotomy "meta-variable" vs. "rigid type variable / skolem" is determined both by whether you're talking about `forall' or `exists', but also which *role* you're considering, whether you're considering a producer or a consumer
09:58:15 <nil> sure
10:01:57 <ski> (the notions "meta-variable" vs. "rigid type variable / skolem" are used during type inference/checking. they are only used for free type variables. bound type variables (by `forall',`exists', or lambda (more or less)) are another thing)
10:02:13 <ski> @where polymorphic-type-inference
10:02:13 <lambdabot> "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <https://cs.au.dk/~mis/typeinf.p(s|df)>,<http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.57.1493>
10:02:19 <ski> @where on-understanding
10:02:19 <lambdabot> "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf>
10:02:35 <ski> might be interesting to take a look at
10:07:10 <AWizzArd> About monad-logger: this `Loc` type.. is this for recording information about _where_ in my source code I placed a log message? If yes, is there some Template Haskell tool which will fill in this information for me?
10:10:34 <jle`> AWizzArd: yes and yes (iirc)
10:23:35 <AWizzArd> How it comes that https://hackage.haskell.org/package/monad-logger-0.3.30/docs/Control-Monad-Logger.html#t:MonadLogger seems to have /two/ methods with the name `monadLoggerLog`? Am I not seeing this correctly?
10:27:02 <jle`> AWizzArd: ah it's an odd quirk (bug?) in haddocks
10:27:34 <cocreature> AWizzArd: one is the signature of the default implementation
10:27:48 <cocreature> https://hackage.haskell.org/package/monad-logger-0.3.30/docs/src/Control.Monad.Logger.html#monadLoggerLog
10:28:19 <jle`> AWizzArd: https://github.com/haskell/haddock/issues/567
10:29:12 <jle`> looks like it should be fixed in the haddock version coming with ghc 8.8
10:30:46 <AWizzArd> jle` and cocreature: okay good, that both makes sense then.
10:31:32 <cocreature> AWizzArd: as for the TH stuff, look at https://hackage.haskell.org/package/monad-logger-0.3.30/docs/Control-Monad-Logger.html#g:4
10:47:14 <AWizzArd> cocreature: okay thanks, this makes sense. Otherwise it would have looked strange, as Loc is an obligatory argument, but it seems impossible to maintain it by hand.
10:56:38 <steve-chavez> Hello. Is there a way to limit GHC memory usage?
10:57:00 <steve-chavez> I'm getting over 4GB usage when compiling a file, and then a crash.
10:57:15 <steve-chavez> You can see this here https://github.com/PostgREST/postgrest/issues/1334#issuecomment-509731567
10:57:18 <___laika> ulimit -v (some number of kb)
10:57:22 <___laika> thats what ive been using
10:57:25 <___laika> facing a similar issue
10:57:48 <___laika> ive had ghc using over 1TB of virtual memory
10:57:49 <koala_man> steve-chavez: do you want it to still work?
10:58:19 <cocreature> GHC always uses 1TB of virtual memory on linux by default
10:58:26 <cocreature> That’s not an issue
10:59:20 <___laika> it was locking my system on osx 
10:59:27 <___laika> err
10:59:29 <___laika> "macos"
11:00:01 <steve-chavez> ___laika: That's a linux setting though, right? Hmmm.. I got that error on Windows and Linux. Do you know of a platform agnostic way?.
11:00:03 <cocreature> I doubt that’s due to the virtual memory usage. the actualt memory usage can also get quite high and that is an issue but it’s unrelated to the 1tb virtual memory usage
11:00:23 <cocreature> steve-chavez: you can limit GHC memory usage but mostly it will just crash once it hits that limit
11:00:53 <cocreature> steve-chavez: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html#rts-flag--M%20%E2%9F%A8size%E2%9F%A9
11:00:55 <steve-chavez> cocreature: Well, it's being an issue for a CI where I'm trying to compile and test, it has limited RAM.
11:00:56 <___laika> fwiw, limiting the virtual memory to either 4 or 8 gb completely eliminated lockups and has produced no crashes for me
11:01:15 <___laika> 4GB
11:02:26 <___laika> (granted im not using ghc for anything particularly heavyweight, i think)
11:03:46 <AWizzArd> steve-chavez: one possible solution could be to run the compiler inside a docker container.
11:04:08 <koala_man> ghc does seem content when denied vspace, but why would vspace usage cause crashes?
11:06:56 <___laika> actually yes, my issue with ghc usage was system hangs
11:06:59 <___laika> im unsure about the crashes
11:07:15 * ___laika sinks into bush
11:08:31 <vaibhavsagar> my kingdom for a way to diff haddocks for two different versions of a package
11:09:35 <geekosaur> either oen can hhappen if you're hitting out of memory conditions. which are usually the linker, but you can (with iirc some not-recommended settings and sufficiently pathological haskell source) convince ghc's typechecker to go nuts
11:12:39 <steve-chavez> geekosaur: The out of memory happens when compiling this particular source file.
11:12:42 <steve-chavez> https://github.com/PostgREST/postgrest/blob/master/src/PostgREST/QueryBuilder.hs
11:13:43 <steve-chavez> Perhaps could you point what seems pathological there?
11:14:01 <glguy> vaibhavsagar: I found this when trying to remember what the website was that had information about changes to hackage packages: http://hackage.haskell.org/package/hackage-diff
11:14:04 <geekosaur> just looking at the extensions, nothing should be … I think
11:14:27 <geekosaur> but it's possible that ghc needs to protect against pathological cases in DuplicateRecordFields or something
11:14:32 <vaibhavsagar> glguy: thanks, that seems like exactly what I'm looking for!
11:14:43 <geekosaur> otherwise it should be limiting itself and throwing an error
11:15:03 <steve-chavez> I'm thinking it could be related to quasiquoting.
11:15:49 <geekosaur> ugh, more LANGUAGE options in a different file I see, I didn't notice the qq
11:16:33 <geekosaur> quasiuotation could do it but I think it'd have to be fairly pathological, like it's somehow inserting the contents of a large table into the AST or something
11:16:57 <geekosaur> generally that's slow, not high memory
11:17:19 <vaibhavsagar> glguy: funnily enough, it doesn't build for me because it uses an older version of cabal
11:17:31 <vaibhavsagar> if only there were some tool to diff versions of the cabal api
11:17:46 <geekosaur> there's some RTS options you can use to try to limit memory. otherwise, I'd poke at debug options in a VM (so it can't take out my actual machine) to see what's exploding
11:18:06 <geekosaur> it's not impossible you've found something that ghc doesn;'t sufficiently guard against
11:18:22 <merijn> vaibhavsagar: The Cabal API isn't particularly stable, so you should avoid depending on it at all costs
11:19:08 <steve-chavez> geekosaur: Thank you.
11:19:13 <merijn> vaibhavsagar: What are you using that needs it?
11:19:24 <cocreature> There are two different issues here: 1. High virtual memory usage. That is usually completely harmless and definitely expected. Apparently GHC handles it gracefully when it runs out of virtual memory. 2. high residual memory usage, you can limit residual memory usage but there isn’t too much GHC can do to limit that so it will crash at some point.
11:19:24 <steve-chavez> Thanks a lot for your help guys. I'll evaluate my options now.
11:19:35 <vaibhavsagar> merijn: https://github.com/blitzcode/hackage-diff
11:19:40 <geekosaur> I think you mean resident
11:20:18 <geekosaur> in any case, most memory tools will lie because they don't expect ghc's way of managing its page tables and will see 1TB constant memory usage or some such
11:20:44 <merijn> geekosaur: GHC is great at convincing people that top might actually be terrible for tracking memory usage ;)
11:20:54 * geekosaur figures
11:21:04 <geekosaur> X11 used to do that, then they hacked top to handle *only* X11
11:21:07 <merijn> geekosaur: GHC doesn't manage page tables. It manages virtual memory
11:21:29 <merijn> Page tables are ring 0/kernel thing you can't touch from userspace
11:21:32 <geekosaur> (mmap-ing video memory into process address space)
11:22:03 <geekosaur> merijn, if you look a level or so deeper, you'll find it's managing pages as directly as the POSIX API will permit and that's why it's useful
11:22:14 <geekosaur> well, pOSIX extension
11:22:45 <geekosaur> which X11 also does as I just described, and Allegro CL, and a few other things
11:22:49 <merijn> geekosaur: It's really not...pagetables are for mapping virtual to physical address/memory pages. What GHC is doing is simply guaranteeing that it's heap is contiguous, because that allows for a more efficient GC
11:23:19 <merijn> By pre-reserving a huge chunk of virtual address space and then incrementally actually allocating/using it
11:23:35 <geekosaur> sigh. I wouldpoint you at the APIs and what they are doingt o provide those guarantees
11:23:57 <geekosaur> but I'm not interested in geek one-upmanship today
11:32:06 <fragamus> foo :: (Blah t -> [Char]) -> [Blah t] -> String
11:32:32 <fragamus> hi I need to make this function where Blah is various types but t is known
11:32:55 <fragamus> I reckon forall is needed but I need some guidance
11:35:36 <fragamus> hi geekosaur
11:35:49 <fragamus> I need some forall help
11:36:24 <fragamus> foo :: (Blah t -> [Char]) -> [Blah t] -> String
11:36:32 <fragamus> I need to make this function where Blah is various types but t is known
11:38:04 <merijn> geekosaur: My point is that it doesn't make sense to talk about pagetables at the level that GHC operates. Anyway, dinner time
11:45:50 <fragamus> ok I solved my problem
11:52:11 <wroathe> Is there way to make a type-level "function" that takes a type as input and "decorates" it with additional fields?
11:52:30 <wroathe> Like if I wanted to automatically add standard id/guid/created at/updated at to my model types
11:52:53 <wroathe> And not have to repeat myself for each data type definition
11:53:25 <wroathe> I should specify that I'd like to avoid using TH for this
11:57:18 <Cale> wroathe: You could create a parametric wrapper type
11:59:01 <wroathe> Hmm, that might be a good way to go
11:59:22 <wroathe> Although ideally we'd have syntax for composing together parts of ADTs
12:02:19 <Geekingfrog> So, I have a project which compiles just fine without optimisations, but with -O2, it seems to loop, and the RAM usage goes up. How can I start to figure out what's wrong?
12:10:14 <Cale> Geekingfrog: That sounds like a really unfortunate situation. I'd probably start by profiling to get at least a vague sense of where things are going wrong
12:10:30 <Cale> Geekingfrog: and then *maybe* that gets you far enough to begin looking at core
12:10:47 <Geekingfrog> how do I profile a build?
12:11:18 <Cale> run GHC with -prof -fprof-auto
12:11:38 <Cale> and then you can run the program with, for example +RTS -p
12:12:02 <Cale> that will generate a .prof file for you which will tell you the number of times that various things get entered
12:12:20 <Cale> (which is probably the most interesting thing in the situation where there seems to be a loop...)
12:12:29 <Cale> You can also do heap profiling
12:12:55 <Cale> There are a bunch of RTS options for doing different kinds of heap profiles
12:12:58 <Geekingfrog> The problem is that the compilation doesn't stop.
12:12:59 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html
12:13:01 <Cale> ohhhhh
12:13:13 <Cale> *Compilation* doesn't stop
12:13:39 <Cale> Maybe the inliner going insane?
12:13:51 <Cale> hmmm
12:14:05 <Geekingfrog> I'm trying to reproduce it on a smaller project
12:15:16 <Cale> try compiling with -ddump-inlinings
12:15:58 <crundar> How does == work on ADTs with infinitely-many constructors? 
12:16:23 <lavalike> can't spell -ddump-inlinings without dinin' dumplings
12:16:31 <Cale> https://downloads.haskell.org/~ghc/7.6.3/docs/html/users_guide/options-debugging.html
12:16:37 <Cale> actually, that's old
12:16:55 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/debugging.html
12:17:25 <Cale> There's lots of flags you can try to get more information out of GHC about what it's presently doing. You might start with a bunch of -v as well
12:17:36 <Cale> crundar: uh, there aren't any?
12:17:55 <EvanR> countably infinite or
12:18:03 <crundar> EvanR countably infinite.
12:18:18 <crundar> Like, strings are presumably, yeah? 
12:18:24 <Cale> The constructor tag in GHC is a single machine word wide
12:18:34 <EvanR> String = [Char]
12:18:39 <Cale> Strings are lists of Char, and Char is builtin
12:18:43 <crundar> Char, then. 
12:19:00 <EvanR> there are only so many unicode chars
12:19:04 <Cale> Or if you want to dig deeper
12:19:06 <Cale> data Char = GHC.Types.C# GHC.Prim.Char#
12:19:18 <crundar> Hrm. Well, that makes sense. 
12:19:18 <Geekingfrog> Thanks Cale, I'll have a look at that and try various things.
12:19:23 <Cale> and then the Char# is an unboxed type representing a Unicode codepoint
12:19:32 <Cale> > maxBound :: Char
12:19:35 <lambdabot>  '\1114111'
12:19:49 <fragamus> Can't find interface-file declaration for type constructor or class Language.Haskell.TH.Lib.DecsQ
12:19:49 <fragamus>       Probable cause: bug in .hi-boot file, or inconsistent .hi file
12:19:49 <fragamus>       Use -ddump-if-trace to get an idea of which file caused the error
12:19:57 <fragamus> WTF is that
12:20:43 <Cale> fragamus: uhhh, that's real weird
12:20:50 <Cale> fragamus: Are you working on TH itself?
12:20:55 <fragamus> no
12:21:22 <wroathe> Ha, it only took a few minutes to find black magic in Beam http://hackage.haskell.org/package/beam-migrate-0.4.0.1/docs/Database-Beam-Migrate-SQL-Tables.html#v:field
12:21:27 <Cale> I wouldn't expect to see that unless the .hi file for that module was somehow out of date or something
12:22:22 <fragamus> I wouldn't expect to see it EVER
12:22:36 <cocreature> given that TH is shipped with GHC it sounds like your GHC installation is messed up in some way
12:23:01 <fragamus> im on stack....
12:23:19 <cocreature> I’d start with stack clean --full :)
12:23:22 <cocreature> which GHC version?
12:23:41 <fragamus> hang on Im initiating my stack clean --full
12:23:50 <Cale> fragamus: It's possible to see an error like that if you accidentally do something dumb with your temporary files when compiling, but you wouldn't ever expect to see it for something that came with GHC.
12:24:19 <Cale> wroathe: What's black magic there? Just the type level hackery?
12:25:07 <Geekingfrog> Cale, I'll be damned, when I removed the explicit export list then the problem went away. The buggy one was seemingly looping with messages like "simplifier [...] finished in ..., allocated XXX Megabytes"
12:25:28 <wroathe> Cale: Yeah. I just haven't seen variadic functions done in Haskell yet
12:25:29 <fragamus> extra-deps: [generic-lens-1.2.0.0,haskell-src-exts-1.21.0,pretty-1.1.3.6,template-haskell-2.14.0.
12:25:31 <fragamus> 0,ghc-boot-th-8.6.5,bifunctors-5.5.4,exceptions-0.10.2,free-5.1.1,lens-4.17.1,tagged-0.8.6,th-abs
12:25:31 <fragamus> traction-0.3.1.0,adjunctions-4.4,kan-extensions-5.2,invariant-0.5.3]
12:25:40 <wroathe> And the type didn't immediately tell me it was a variadic function
12:25:59 <Cale> Ah, yeah, there are a whole bunch of ways of doing it, and this is one of them
12:26:10 <Cale> Did you know that, e.g. foldr is variadic? :D
12:26:20 <fragamus> OK that stack clean --full didn't help
12:26:33 <wroathe> How so?
12:26:35 <wroathe> :t foldr
12:26:40 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
12:27:03 <Cale> > foldr (\x xs s -> (x + s) : xs (s + 1)) (\s -> []) [1..10] 0
12:27:06 <lambdabot>  [1,3,5,7,9,11,13,15,17,19]
12:27:30 <EvanR> languages which make use of variadic functions never have the type system to describe them, which is the point where i feel like i need one to understand the function
12:27:31 <Cale> > foldr (\x xs s t -> (x + s) : t : xs (s + 1) (t + x)) (\s t -> []) [1..10] 0 0
12:27:34 <lambdabot>  [1,0,3,1,5,3,7,6,9,10,11,15,13,21,15,28,17,36,19,45]
12:28:23 <Cale> The key is that since b can be any type at all in foldr's signature, it might also be a function type
12:28:24 <EvanR> "programming in this dynamic language is easy, you don't need a type system really" then the variadic functions begin
12:28:57 <wroathe> Cale: Oh, I see
12:30:24 <fragamus> hmm Im sitting in McDonalds and I can't access haskellstack.org
12:30:37 <fragamus> it seems like they blacklisted it
12:30:48 <Cale> McDonalds prefers Cabal
12:30:48 <wroathe> McDonalds is a Java shop
12:30:54 <fragamus> lol
12:31:02 <EvanR> the DNS filter detected a competing value meal website
12:31:03 <wroathe> See, mine is funny on a few levels
12:31:09 <wroathe> Because they do serve coffee
12:31:34 <fragamus> lol
12:31:40 <EvanR> the 99¢ haskell stack
12:35:06 <fragamus> well I can access it from my iphone on cellular connection
12:35:16 <fragamus> but wifi no workie
12:35:46 <cocreature> fragamus: oh putting template-haskell in extra-deps isn’t going to work
12:35:56 <cocreature> fragamus: template-haskell is tied to GHC
12:36:02 <fragamus> ok 
12:36:03 <cocreature> you can’t just install another version
12:36:52 <wroathe> Cale: Btw, as I think about that foldr example... It wouldn't be technically correct to call that a variadic function though
12:37:00 <cocreature> fragamus: although I’m somewhat surprised you didn’t get a version error. Did you use allow-newer or something like that?
12:37:10 <wroathe> Somewhere along the line you need a function with the appropriate number of parameters
12:42:38 <fragamus> https://gist.github.com/fragamus/249530d5662621138e2db39467234963
12:42:57 <fragamus> I took out the offending template haskell lib
12:43:16 <fragamus> but I guess I need a new version of ghc 
12:43:49 <EvanR> you need a McVPN
12:44:02 <fragamus> yeah
12:44:23 <fragamus> I'm not loving it
12:45:29 <fragamus> so I need to be running a modern version of GHC and it may be new than ships with stack
12:46:48 <fragamus> cocreature: no I did not use allow-newer because that is just asking for trouble
12:46:51 <wildtrees> there's ways to pick versions of ghc with stack, though I forget the details of how to actually do that 
12:47:15 <fragamus> wildtrees is it in some document
12:47:41 <wildtrees> its some command line option, so I think its on the web somewhere 
12:49:03 <fragamus> oh spiffy the docs are all blacklisted
12:49:10 <cocreature> fragamus: yeah either upgrade to GHC 8.6 or you need to figure out what is forcing TH >= 2.14
12:49:29 <fragamus> foxtrot-tango-sierra
12:50:19 <cocreature> if you want to go for the upgrade GHC route, switching your resolver to lts 13.29 (the latest lts) should do the trick
12:50:38 <wildtrees> fragamus, get your coffee at starbucks next time, not mc'ds ? ;) 
12:51:29 <fragamus> ok
13:26:13 <fragamus> ok I changed to resolver: lts-13.29
14:01:42 <maralorn> I‘m having problems with a lazy bracket.
14:02:41 <maralorn> Somehow my cleanup happens before the body of the bracket. I‘m wondering how that is even possible.
14:03:51 <maralorn> Is that possible? Is there a cannonical way not to fall into this trap?
14:04:42 <maralorn> m( I switched the parameters.^^
14:05:06 <maralorn> thx, anyway …
14:07:59 <EvanR> it might happen if your haskell code travels faster than light
14:17:16 <wroathe> This has been my experience trying to get Beam migrations working so far :P https://gist.github.com/JustinChristensen/8704356df6ca066191ab55c97e8e514c
14:17:46 <wroathe> I know what I did wrong, but I'm just pointing out that the compiler errors I'm getting are just hilarious
14:21:23 <maralorn> Is there a nicer version for "fmap f . c" when c is a monad? somthing like "f <operator> c"?
14:21:45 <ski> maralorn : that doesn't make any sense
14:21:56 <ski> `c' there can't be a monad. monads are not values
14:22:11 <maralorn> ski: god point
14:22:20 <ski> `c' could perhaps be a monadic action. or perhaps a function whose result is a monadic action
14:22:33 <maralorn> I mean c :: a -> m b, f :: b -> c
14:22:33 <ski> monads in Haskell live on the type level
14:22:43 <ski> then `m' would possibly be a monad
14:23:10 <maralorn> ski: Could also just be a functor.
14:23:20 <ski> yes. or idiom
14:24:06 <ski> @type \f c -> return . f <=< c
14:24:09 <lambdabot> Monad m => (a1 -> c) -> (a2 -> m a1) -> a2 -> m c
14:24:18 <maralorn> Anyways it happens to me often that I wanna postcompose a pure function on some computation with a monadic result.
14:25:10 <ski> @type \f c -> (f <$>) . c
14:25:13 <lambdabot> Functor f => (a1 -> b) -> (a2 -> f a1) -> a2 -> f b
14:25:26 <maralorn> Aaah
14:25:39 <maralorn> I guess that‘s what I was looking for.
14:25:41 <ski> @hoogle Functor f => (b -> c) -> (a -> f b) -> (a -> f c)
14:25:43 <lambdabot> Control.Applicative.Tools (<.>) :: Functor f => (a -> b) -> (c -> f a) -> c -> f b
14:25:54 <ski> hmf
14:26:04 <maralorn> Why hmf?
14:26:08 <ski> (no idea which packahe that is in)
14:26:12 <maralorn> ^^
14:26:23 <maralorn> I‘ll find out.
14:26:24 <nshepperd1> \x -> fmap f (c x)
14:26:35 <maralorn> But thanks.
14:27:13 <wroathe> That type families trick that Beam does with Columnar is pretty neat
14:27:24 <Guest_6> Hello, I am trying to install haskell for the first time on Mac, but when i use ghcup i n the terminal I get this error: To install and run GHC you need the following dependencies:Following commands are required, but missing, please install:  xz. Any ideas on what's gone wrong?
14:27:32 <maralorn> "yjtools"^^
14:27:38 <maralorn> Never heard.
14:28:52 <koala_man> Guest_6: so.. install xz?
14:28:52 <yushyin> Guest_6: seems like you are missing xz? https://tukaani.org/xz/
14:29:12 <glguy> The easy way to get xz is: brew install xz
14:29:35 <Guest_6> I'd never heard of xz before, now i feel like an idiot. Thanks for the help!
14:29:57 <maralorn> ski: But thanks.
14:32:52 <ski> (maralorn : but the "hmf" was more because of the (arguably) strange name ..)
14:34:03 <maralorn> ski: I think <.> is quite fitting, don‘t you?
14:34:30 <maralorn> <$> lifts application, <.> lifts composition.
14:34:44 <ski> @type \f c -> (f <$>) . c
14:34:46 <lambdabot> Functor f => (a1 -> b) -> (a2 -> f a1) -> a2 -> f b
14:35:40 <ski> hm
14:35:49 <ski> @type \f c -> return . f <=< c
14:35:52 <lambdabot> Monad m => (a1 -> c) -> (a2 -> m a1) -> a2 -> m c
14:35:56 <ski> @type \f c -> f <=< return . c
14:35:59 <lambdabot> Monad m => (b -> m c) -> (a -> b) -> a -> m c
14:36:09 <ski> why one of those (latter two), over the other ?
14:37:03 <ski> the spelling `<.>' doesn't seem to give any mnemotechnic device to help one recall which side has `m' and which hasn't
14:39:40 <maralorn> ski: Because the second one is (.) ?
15:00:08 <vijaytadikamalla> how to run some Haskell code on my website hosted on github(written in HTML,CSS, javascript)?
15:01:34 <rom1504> vijaytadikamalla: are you sure you know what is haskell ?
15:02:05 <rom1504> you could use https://github.com/ghcjs/ghcjs but first make sure you know what you are doing
15:03:10 <vijaytadikamalla> i just want use some haskell library 
15:05:00 <vijaytadikamalla> like aeson
15:05:32 <rom1504> to do what
15:06:16 <vijaytadikamalla> parse some json data
15:07:01 <AWizzArd> Can I somehow run IO during the compilation process? (for example connecting to PG and look something up)
15:07:23 <glguy> You probably shouldn't do that, but you can do it with Template Haskell
15:07:57 <AWizzArd> ok
15:10:58 <rom1504> vijaytadikamalla: JSON.parse will do it
15:11:59 <vijaytadikamalla> well, I specifically have to use aeson only
15:19:19 <rom1504> you're not making sense
15:19:31 <rom1504> explain what problem you are trying to solve
15:45:05 <literall1Crevice> So I have a (gameBoard :: Vector Card) and I want to modify one of a Card's properties using lens. I'm a bit of a newb and can't manage to do it using "at", since it gives a maybe. I know for certain that the index is in the vector. Is there an operator alternative to "at" that errors on failure instead of returning a maybe?
15:45:49 <glguy> You can use ix instead of at
15:46:06 <literall1Crevice> Oh, awesome. Thanks!
15:46:08 <glguy> If you were using at it would be:  over (at i . _Just)
15:46:18 <glguy> with ix it's: over (ix i)
15:53:13 <tabaqui> I hear that types dissapear after compilation
15:53:34 <tabaqui> I dunno, if it is possible to add somewhat dynamic warning
15:53:38 <tabaqui> for example
15:54:30 <tabaqui> instance Storable Foo where peek _ = blabla; poke _ = {-# WARNING "poke shouldn't happen #-}...
15:54:59 <tabaqui> which means, that ones code supposes that we only read Foo from memory
15:55:21 <tabaqui> but if developer tries to *write* Foo in memory, than he will be warned
15:55:57 <tabaqui> what do you think? Does this proposal require additional compile step?
15:59:48 <solonarv> it would certainly require some additional code in the compiler, but not a fundamentally new compile step
16:00:01 <solonarv> but in this particular case I would suggest just not writing the instance at all
16:04:34 <tabaqui> it is common to write a lot of "undefined"s and forget about them later
16:04:52 <hpc> it's certainly common to forget about them later
16:04:54 <hpc> use holes
16:05:09 <EvanR> if you are trying to leave them in, at least use error
16:05:26 <tabaqui> one can forget about "error"s too
16:05:28 <EvanR> if you are trying to remember to fix them later use holes
16:05:37 <tabaqui> holes are fine, probably
16:05:40 <EvanR> at least error comes with a warning
16:05:44 <EvanR> message
16:05:59 <tabaqui> can I write only signature without definition?
16:06:39 <solonarv> nope
16:06:41 <tabaqui> nah, I cannot
16:06:55 <tabaqui> how can I use hole for an entire function?
16:07:15 <glguy> thing = _
16:07:17 <hpc> f = _
16:07:23 <tabaqui> oh, didn't know
16:07:33 <solonarv> you can give the hole a name too, like: f = _implementMe
16:07:33 <hpc> remember currying :D
16:07:37 <tabaqui> still cannot ignore it
16:08:30 <solonarv> you can with -fdefer-typed-holes, which IMO is fine during development
16:09:32 <tabaqui> yeah, thanks, holes solve most of the issues
16:10:04 <tabaqui> but dynamic warnings could be a cool feature still
16:10:31 <EvanR> isn't that what defer-typed-holes does
16:10:56 <solonarv> no, that basically just replaces _hole with error "hole"
16:12:06 <tabaqui> you will receive warning, no matter is your function used anywhere or not
16:12:27 <EvanR> then it will be hard to forget : )
16:12:58 <tabaqui> back to Storable case
16:13:36 <tabaqui> I have such types, which have no poke implemenation
16:13:44 <EvanR> if you really can't implement all of Storable.. seems like a ticking time bomb. Because things expect a certain interface
16:13:51 <solonarv> my recommendation is: do not write that instance
16:13:52 <glguy> Then they shouldn't have Storable instances
16:13:59 <EvanR> machinery will try to poke and you will be sad
16:14:43 <tabaqui> without Storable instance I cannout use "peekArray" for example
16:15:08 <tabaqui> and it is fine, I sure that I will not require "poke" method in next months
16:16:53 <EvanR> if you're leaving it in, then holes wouldn't make sense
16:17:34 <tabaqui> yes, because I will get warning on each compilation
16:18:01 <glguy> warnings on your half-implemented instance wouldn't help much as many definitions are implemented generically in terms of an arbitrary instance
16:18:08 <EvanR> there's the classic error "noone should be here", but to me that only makes sense when you have proof that code can't run
16:18:36 <glguy> so the compiler wouldn't know to look at your instance's warnings when checking uses of poke
16:19:49 <tabaqui> that why I mentioned that "types dissappear after compilation"
16:20:28 <solonarv> that's not the problem: types are erased yes, but you can keep type-based information around
16:20:34 <solonarv> that's exactly what typeclasses do!
16:21:38 <EvanR> you can use something equivalent to peekArray without a Storable instance on the unpokeable thing
16:21:45 <tabaqui> so compiler doesn't know if this monomorphic function has an actual call somewhere?
16:22:09 <EvanR> or you could just cross your fingers
16:24:43 * tabaqui is snoring
16:24:51 <turab> Any one here on an Arch based distro? Just curious how other people on Arch are developing with Haskell
16:25:06 <literall1Crevice> turab: I'm on arch but not too good with haskell
16:25:21 <turab> Same here :)
16:25:43 <turab> So, a few months back when I was playing with Haskell, I installed ghc through pacman
16:26:26 <turab> Turns it that causes issues. I ignored it since I wasn't doing anything serious but now I feel like I am running into issues because of that
16:27:13 <literall1Crevice> My setup is I have ghc installed through pacman for when I just want to quickly script something, and stack-bin from the AUR for any real project
16:27:16 <turab> So the solution I am going for currently is to install ghc from source (mainly also because I have never done that and would like to experience it)
16:28:12 <turab> I considered stack too but it will be p cool if I don't depend on it (also since I have started to get comfy with Cabal)
16:28:42 <EvanR> i would install GHC manually on any system
16:28:55 <turab> EvanR: waiting for my updates to finish to give that a shot!
16:29:20 <EvanR> arch seems to have extra problems, so yeah
16:30:20 <turab> One part I am worried about is needing GHC during build. The build instructions ask Arch users to install ghc from pacman so I am assuming that won't cause issues
16:30:49 <turab> If it doesn't, gonna uninstall what I got from pacman and be free at last!
16:31:19 <literall1Crevice> I have a Lens'ed data Player { playerTeam :: Team, playerRole :: Role }. Both Team and Role are instances of a typeclass which provides (other :: a -> a). How can I set my Game's player instance to the exact opposite of the one it currently has? (i.e game.player = player{other(p.team), other(p.role)})
16:34:24 <solonarv> turab: the usual recommendation is to ignore the aur-provided GHC+cabal entirely and use ghcup to install them instead
16:34:58 <solonarv> literall1Crevice: the operator you're looking for is %~
16:35:04 <solonarv> (the corresponding function is 'over')
16:35:26 <turab> solonarv: Okay. If I struggle with building from source then I will give that a shot
16:35:44 <solonarv> like so: game & player %~ other & role %~ other
16:37:01 <EvanR> you mean distributing your app on arch? yeah i dont' know
16:40:06 <literall1Crevice> solonarv: I probably didn't explain my situation well enough, but you did bring me closer. Is there a more "lensy" way to do `(playerRole %~ other) <$> (playerTeam %~ other)`?
16:41:10 <glguy> literall1Crevice: What solonarv said already
16:42:56 <literall1Crevice> glguy: Maybe I'm doing something wrong, but it doesn't work for me
16:43:28 <literall1Crevice> Oh, I am doing something wrong. Okay, thanks solonarv !
17:00:49 <wroathe> err mer gerd, I've been trying to figure out how to get beam to use the expression uuid_generate_v4() for the DEFAULT clause of a field for like an hour now
17:01:03 <wroathe> I am not smart enough for beam
17:02:26 <turab> EvanR: Just curious. When you say install GHC manually, do you usually do what's suggested here? https://gitlab.haskell.org/ghc/ghc/wikis/building/quick-start
17:03:48 <boj> wroathe: that is an IO action?
17:04:10 <solonarv> EvanR: I don't think so - building GHC from source both a) takes a while, and b) requires a GHC to already be installed
17:04:14 <EvanR> no i wouldn't build it, i would just install binaries
17:04:29 <solonarv> (since GHC is written in Haskell, and also is the only Haskell compiler capable of compiling GHC)
17:04:41 <jackdk> boj: I imagine it's the that he wants beam to generate SQL that includes a call to it: https://www.postgresql.org/docs/current/uuid-ossp.html
17:04:45 <solonarv> use this:
17:04:49 <solonarv> @where ghcup
17:04:49 <lambdabot> https://www.haskell.org/ghcup/
17:05:21 <boj> wroathe: we have some thing like - buildUser :: UUID -> UserT (QExpr PgExpresssionSystem s); buildUser uuid = User uuid
17:05:45 <wroathe> boj: I'm giving beam migrate a shot
17:05:59 <wroathe> I'll gist what I've got so far
17:06:04 <jackdk> I have no idea whether it's a good idea, as I don't know if the DEFAULT clause will generate one UUID and reuse it, or if you get one each time
17:06:27 <boj> you can use `default_` in a beam query builder to use the db DEFAULT value
17:06:29 <wroathe> https://gist.github.com/JustinChristensen/c44a6a987f00ee4896e4e6f13c561110
17:06:46 <wroathe> It's not the query builder though, I'm setting field constraints
17:07:06 <wroathe> i.e DEFAULT uuid_generate_v4() on my GUID field
17:07:56 <wroathe> The documentation shows how to create a val expression, but I don't see where I can just create the QExpr representing uuid_generate_v4
17:08:16 <wroathe> this is for guidField btw
17:08:36 <boj> i believe you just use `default_` there
17:08:36 <wroathe> http://hackage.haskell.org/package/beam-migrate-0.4.0.1/docs/Database-Beam-Migrate-SQL-Tables.html#v:defaultTo_
17:08:46 <turab> EvanR: I see
17:10:28 <literall1Crevice> :t [1..5] ^. at 10 :: Maybe Int
17:10:33 <lambdabot> error:
17:10:33 <lambdabot>     • No instance for (At [Int]) arising from a use of ‘at’
17:10:33 <lambdabot>     • In the second argument of ‘(^.)’, namely ‘at 10’
17:10:39 <wroathe> if this works...
17:11:11 <literall1Crevice> Why is this not working? I'm a bit confused here (obviously it's out of bounds, but at the type level)
17:11:24 <solonarv> lists don't have an At instance
17:12:26 <solonarv> because 'at' would give you a Lens' [a] (Maybe a), which you could also use to *set* to 'Just 5' - but that doesn't make any sense!
17:12:49 <solonarv> if you have a 5-length list you can't just set its nonexistent 42nd element to something
17:13:11 <solonarv> however lists do have an Ix instance
17:13:12 <jackdk> you could use ix, though
17:13:27 <jackdk> solonarv's got it covered, as always :-)
17:13:46 <solonarv> ix instead gives you a Traversal' [a] a, which you can use to read the value (if it's there) or replace it with a different one - but only if there was already a value at that index!
17:14:00 <literall1Crevice> Okay, and another issue: Why can't I `(undefined :: Vector Int) ^. ix 5`?
17:14:33 <solonarv> short, slightly wrong answer: ^. only works with a Lens, but 'ix 5' is not a lens
17:15:05 <literall1Crevice> So how would I achieve what I wanted to here?
17:15:18 <solonarv> I assume you're expecting to get a 'Maybe Int' result?
17:15:20 <literall1Crevice> Just using (!)?
17:15:21 <wroathe> boj: Nope :P
17:15:36 <literall1Crevice> solonarv: just an Int, I know the index is in bounds
17:15:59 <solonarv> ah, in that case the appropriate lens-y operator is ^!?
17:16:10 <solonarv> (the Maybe-returning version is ^?)
17:16:29 <wroathe> boj: I'll figure this out later. This AST builder he's got wrapped up in typeclasses is giving me a headache at the moment :P
17:16:45 <solonarv> obviously if the target actually isn't there then ^!? will give you a runtime error
17:16:56 <literall1Crevice> Awesome, thanks again!
17:17:25 <literall1Crevice> Oh, I dun goofed
17:18:07 <literall1Crevice> I then need to get a property of this item (it's not an actual Int), how do I combine this with another accessor?
17:18:47 <literall1Crevice> What I'm looking at in terms of a procedural language is (Vector Card)[idx].cardRevealed
17:18:55 <solonarv> oh, combining optics (lenses and other stuff) is easy: outer . middle . inner
17:19:00 <solonarv> (and so on, of course)
17:19:28 <solonarv> so in your case it would be: someVector ^!? ix 5 . fooField . barField
17:22:21 <literall1Crevice> Oh god this library is scary
17:26:08 <literall1Crevice> Alright, I think this marks the completion of my game's logic! Thanks so much solonarv, I'm off to bed now since it's getting 3:25AM.
17:37:13 <literall1Crevice> Oh, just one last thing. I often times have functions `f x = case g x of {Nothing -> x, Just x' -> ...}`. Is there a simpler way to write this?
17:39:05 <hpc> (<|>) is probably a good place to start
17:39:14 <hpc> > Just 5 <|> Just 6
17:39:20 <lambdabot>  mueval-core: Time limit exceeded
17:39:24 <hpc> > Nothing <|> Just 6
17:39:27 <hpc> lambdabot: seriously?!
17:39:31 <lambdabot>  mueval-core: Time limit exceeded
17:39:35 <Clint> lambdabot: deep breaths
17:39:38 <turab> ha
17:39:41 <hpc> % Just 5 <|> Just 6
17:39:41 <yahb> hpc: Just 5
17:39:47 <hpc> % Nothing <|> Just 6
17:39:47 <yahb> hpc: Just 6
17:39:59 <jackdk> hpc Nothing -> x is the same as Nothing -> Nothing. This smells more like >>=:
17:40:29 <jackdk> f x = g x >>= \x' -> ..., or, in do notation f x = do { x' <- g x; ... }
17:40:29 <pyan> jackdk: not really, note that x is the argument to g in “case g x of ...”
17:40:30 <pyan>  
17:40:39 <hpc> i was thinking g x <|> Just x
17:40:44 <jackdk> ahhh yes
17:40:47 <turab> :t maybe
17:40:53 <lambdabot> b -> (a -> b) -> Maybe a -> b
17:41:09 <hpc> and then... probably (>>=) anyway if you're doing more than just f
17:42:33 <pyan> Maybe guard patterns can help here?
17:43:09 <pyan> Something like “f x | Just x' <- g x = ... | otherwise = x”.
17:43:44 <literall1Crevice> maybe seems great, thanks
17:54:41 <jackdk> the fact that Maybe is Foldable is often really useful, especially when the a in a Maybe a is Monoid too
18:13:10 <turab> Sigh. I have ran into the same issue I was hoping to solve when I tried to build the source: https://gist.github.com/trajafri/179a4b9ef675c89eed9b327bbbf2b1fc
18:13:22 <turab> Does anyone know why this could happen? 
18:14:31 <turab> There are multiple errors like that, not just the ones I posted
18:39:55 <turab> solonarv: Alright gonna give ghcup a shot now. 
18:51:47 <turab> Why is ghcup not advertised on the haskell website? 
18:52:42 <Axman6> it's quite new
19:05:09 <turab> Oh my god ghcup fixed my isses. My prayers have been answered
19:06:24 <turab> Axman6: I see. Man I am glad I used it.
19:40:10 <H0rnyGirl> I am super horny and already wet. Any men available to chat and talk?? Send me a friend request ------> https://2f4.xyz/c36
20:40:06 <jackdk> Servant-streaming question: what is the Skip constructor used for here? http://hackage.haskell.org/package/servant-0.16.1/docs/Servant-Types-SourceT.html#t:StepT The source says "Note: Not sure about this constructor". Great, neither am I!
20:46:00 <solonarv> I vaguely remember a Skip constructor being useful for 'filter'
20:46:45 <solonarv> something about being able to simply emit a 'Skip' instead of having to demand the next element
20:47:14 <Axman6> yes it's for filtering while avoiding recursion
20:49:00 <Axman6> the point of stream fusion is to write step functions which don't need to be recursive so they can be composed and inline properly. if you always need to produce a value in each stream step, you must then recurs if you're filtering until you find the next element, and all the optimisations break down
20:49:27 <Axman6> stream fusion works by pushing all the recursion to the top level consumers
20:51:59 <sicklorkin> Is there a good reason for not providing Eq, Ord on ZonedTime? The author provides no reason for this decision in the docs from what I can see..
20:53:02 <glguy> Probably because it might not be obvious what would be compared
20:53:49 <sicklorkin> that seems reasonable 
20:54:12 <glguy> But I'd guess its actually just an oversight since a lot of the other typed just derive Eq
20:54:26 <sicklorkin> `There is no Eq instance for ZonedTime. If you want to compare local times, use zonedTimeToLocalTime. If you want to compare absolute times, use zonedTimeToUTC.
20:54:28 <glguy> There is no Eq instance for ZonedTime. If you want to compare local times, use zonedTimeToLocalTime. If you want to compare absolute times, use zonedTimeToUTC.
20:54:33 <sicklorkin> lol
20:54:56 <sicklorkin> so you're right
21:07:27 <sicklorkin> imo there should be an Eq instance and it should use zonedTimeToUTC (comparing absolute times); if someone wants to compare localtimes then it's pretty obvious you should get the localTime from the ZonedTime before comparing it.  
21:09:28 <sicklorkin> ahh https://github.com/haskell/time/issues/16
21:09:53 <glguy> No, if it has an instance of Eq it should be the derived one
21:11:05 <sicklorkin> glguy: as much as I'd like to argue that, you are clearly right.
21:13:32 <EvanR> i am so tired of other time libs "choosing the obvious" for me and being wrong
21:13:50 <EvanR> i'm glad ZonedTime makes you pick. Also UTCTime is not AbsoluteTime
21:19:13 <dmwit> Without even specifying what "it" points to, if it has an Eq instance, it should satisfy "`x == y` implies `f x == f y`".
21:19:23 <dmwit> This is my opinion, and not a documented law.
21:20:55 <dmwit> (For ZonedTime specifically this would entail glguy's stance.)
21:22:58 <EvanR> i am now drilling into the source to figure out how ZonedTime can even be converted to UTC
21:23:34 <EvanR> because some localtimes are ambiguous, during DST change
21:23:37 <jackdk> dmwit: https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Eq it's documented under "Substitutivity", actually
21:24:10 <jackdk> so not report-specified, but at least documented
22:15:36 <mzero> Hiho - I'm trying to remember the name of a package that gives one a combined parsing and building monadSo that, for example, you can build up a parser and a builder for a binary structure (ala binary or cereal packages) - but just build the thing once and get both Put and Get functionality.
22:16:15 <c_wraith> there are several.  the one with a name clever enough for me to remember it is boomerang
22:18:24 <mzero> great - that's a nice start
22:51:05 <Axman6> @hoogle replicateM_
22:51:07 <lambdabot> Control.Monad replicateM_ :: Applicative m => Int -> m a -> m ()
22:51:07 <lambdabot> System.Directory.Internal.Prelude replicateM_ :: Applicative m => Int -> m a -> m ()
22:51:07 <lambdabot> Protolude replicateM_ :: Applicative m => Int -> m a -> m ()
22:51:55 <fresheyeball> data Either1 f g a = Left1 (f a) | Right1 (g a)
22:52:03 <fresheyeball> is there a thing out there like this already?
22:52:07 <dminuoso> fresheyeball: Sum
22:52:11 <Axman6> @hoogle SUm
22:52:12 <lambdabot> module Data.Functor.Sum
22:52:13 <lambdabot> Data.Functor.Sum data Sum f g a
22:52:13 <lambdabot> Data.Monoid newtype Sum a
22:52:24 <dminuoso> fresheyeball: https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Sum.html
22:52:31 <fresheyeball> brillant
22:52:41 <fresheyeball> brilliant
22:52:49 <fresheyeball> whatever I am tired, spelling is hard
22:53:03 <Axman6> I agree
22:53:25 <fresheyeball> wait
22:53:29 <fresheyeball> why no Applicative?
22:53:55 <fresheyeball> oh no I see
22:54:12 <Axman6> what should liftA2 f (Left1 fa) (Right1 gb) do?
22:55:24 <fresheyeball> Axman6: yeah I see
22:55:36 <dminuoso> fresheyeball: Fun fact, if you consider this as your tensor of a monoidal category, there's a neat monoid.
22:56:09 <fresheyeball> dminuoso: !!!
22:56:46 * Axman6 mutters something about Day convolution
22:56:58 <Axman6> %t Day
22:57:01 <Axman6> %:t Day
22:57:03 <dminuoso> Axman6: Not quite.
22:57:19 <Axman6> % :t Day
22:57:19 <yahb> Axman6: ; <interactive>:1:1: error: Data constructor not in scope: Day
22:58:05 <dminuoso> Axman6: The idea is, if the tensor is Compose (with Identity as unit), then the monoid yields Monad. If the tensor is Day (with Identity as unit), the monoid yields Applicative.
22:58:14 <dminuoso> Axman6: But Sum and Product are also interesting tensors.
23:36:51 <dminuoso> TIL. You can specify infix declaration on non-operators too.
23:39:22 <Axman6> yeah, useful for things like a `Cons` b `Cons` c `Cons` Nil
23:46:00 <glguy> elem and div are examples of that from the prelude
