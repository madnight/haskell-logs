00:00:39 <cocreature> yep, hoogle prioritized speed over type search
00:00:43 <cocreature> *hoogle 5
00:09:39 <olligobber> fair enough
00:09:59 <tdammers> my guess would be that in order to make type-directed search, one would need a better way of semantically indexing types
00:10:09 <tdammers> that is, build an index where similar types are close together
00:10:29 <tdammers> e.g. Monad m => a -> m b would have to be close to a -> Maybe b in the index
00:10:41 <tdammers> or even, a -> b would have to be right next to c -> d
00:36:39 <jle`> tdammers: or at least maybe store each type multiple times under its neighbors, like how spell check indices work
00:58:05 <tdammers> right, yeah
00:58:26 <tdammers> I think the problem is that there are more possible types than words in your average dictionary
00:58:58 <dminuoso> Cale: Well yeah, but only if type variables are swapped around.
00:59:13 <abeu> scientists have just announced today that dolphins are second to man in intelligence levels. so that pushes women down to third place
01:00:34 <dminuoso> So `(a -> m b) -> m a -> m b` would not find (>>=), but `a m -> (m -> a b) -> a m -> a b` would.
01:01:12 <dminuoso> The converation there was odd, because I assumed olligobber to have made a mistake and just carried on glancing over it.
01:03:56 <cheston> 4,01s7c8r9e3w 12y6o4u 7S8i9g3y12n
01:05:01 * cheston 4,01s7c8r9e3w 12y6o4u 7S8i9g3y12n
01:05:36 <Taneb> @where ops
01:05:36 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw mniip monochrom quicksilver shachaf shapr ski
01:05:38 <xacktm> this is a channel for haskell discussion, not tirads against the antispam bot
01:05:39 --- mode: ChanServ set +q *!*@59.24.196.115
01:07:31 --- mode: ChanServ set -q *!*@59.24.196.115
01:08:08 <linsmh8> screw you Sigyn
01:09:01 * linsmh8 screw you Sigyn
01:11:59 <erhard> Sigyn screw you
01:13:46 <husseinwry9> Sigyn screw you
01:19:41 <gregg> Sigyn screw you
01:30:59 <cocreature> Is there something like an immutable IORef that I can use for reliable weak ptrs?
01:31:17 <cocreature> It seems weird to wrap an immutable value into an IORef if I never intend to change it
01:31:28 <ski> hm, "reliable weak ptrs" ?
01:31:42 <maddy> screw you Sigyn
01:32:23 <cocreature> ski: the docs in https://hackage.haskell.org/package/base-4.12.0.0/docs/System-Mem-Weak.html warn that finalizers can run too early for primitive values and that you should use the IORef variant if you want to avoid this
01:33:27 <ski> but you still want some kind a weak-ptr behaviour, where the resource can be dropped from under you, by the resource manager ?
01:33:33 <cocreature> yes
01:34:11 <ski> i was thinking of I-var, but they don't have that weak ability
01:35:12 <ski> hmm
01:35:30 <ski> i wonder whether "types that are created explicitly and have identity" would include `IVar'
01:37:24 <roderick> screw you Sigyn
01:37:35 <ski> seems the packages i had in mind doesn't have such specific operations for placing a finalizer on the primitive object inside the `IVar'
01:40:10 <lem> screw you Sigyn
01:44:25 <gordie> screw you Sigyn
01:50:24 --- mode: ChanServ set +q *!*@*.ne.jp
02:10:30 --- mode: ChanServ set -q *!*@*.ne.jp
02:11:58 <jle`> cocreature: maybe something from StateVar ?
02:38:49 <dminuoso> dcoutts: Hey you talked about commuting diagrams in comments to explain tests didn't you?
02:38:56 <dminuoso> I think during last munihac?
02:39:01 <dcoutts> yes
02:39:27 <dminuoso> dcoutts: Cheers for that, Im in a similar spot and could immediately apply what you mentioned. :)
02:39:37 <dcoutts> nice :-)
02:40:01 <dminuoso> dcoutts: Mind my asking, how did you draw the diagrams back then?
02:40:25 <dcoutts> https://github.com/well-typed/cborg/blob/master/cborg/tests/Tests/Properties.hs
02:40:33 <dcoutts> Unicode
02:40:42 <dminuoso> Ah by hand then
02:41:02 <dcoutts> yeah, I didn't find a great tool at the time
02:41:25 <dcoutts> I did subsequently find a box drawing ASCII art tool online
02:41:52 <dcoutts> don't recall the name now, and I have used that for drafts, but it doesn't do diagonal lines, but fine for boxes and lines
02:58:32 <Noughtmare> Does anybody know anything about optimizing concurrent programs? I've written an improved implementation of the fasta benchmark: https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/fasta-ghc-4.html. It runs just as fast as the C implementation on my machine, but it runs 1.5x slower on their older cpu. I have done some tests and discovered that my code performs a lot more context switches, is there a way to 
02:58:32 <Noughtmare> reduce that (or is it not a problem)?
03:08:12 <[exa]> Noughtmare: I guess your code is in haskell?
03:08:24 <Noughtmare> Yes
03:08:32 <[exa]> Noughtmare: btw to reduce context switches you need to reduce syscalls
03:08:55 <Noughtmare> The code is listed here: https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/fasta-ghc-4.html
03:09:58 <Noughtmare> I've removed all code that has to do with output and it still indicated the same number of context switches
03:10:32 <[exa]> Noughtmare: can you run your program in 'strace'?
03:11:45 <[exa]> that should show all syscalls. The second possibility is that the switches are page misses
03:12:22 <[exa]> also also, if you can, avoid MVars for synchronization
03:12:24 <Noughtmare> I get a lot of futex(..)
03:12:35 <[exa]> oh yes, these are MVar-caused mutex locks
03:12:42 <Noughtmare> How can I synchronize without MVars?
03:13:05 <[exa]> in short, your code is probably faster but it's killed this way
03:13:15 <[exa]> hm, what is the reason you need synchronization?
03:13:55 <Noughtmare> The fasta benchmark basically requires you to (1) generate random numbers (using a LCG) (2) sample a cumulative distribution (3) output the result.
03:14:31 <Noughtmare> This all is very sequential, but you can do the sampling and outputting in separate threads.
03:14:35 <[exa]> what par is parallelized?
03:14:40 <[exa]> *part
03:15:00 <Noughtmare> But the rng and outputting still needs to be done in sequence.
03:15:06 <[exa]> oh I see it now. Do batches
03:15:12 <Noughtmare> Yes
03:15:18 <[exa]> you're calling 1 mutex sync for 1 word32
03:15:47 <[exa]> make the source output a serious batch of word32's at once so that the second thread can chew a bit of data without examining the mutex again
03:15:48 <Noughtmare> No I generate an unboxed vector of 1024*60 Word32
03:16:10 <Noughtmare> (That is also what the C implementation does)
03:16:50 <Noughtmare> The 60 is because you have to output in lines of 60 characters
03:17:20 <[exa]> oh that's the M.IOVector Word32 ?
03:17:43 <Noughtmare> Yes
03:18:39 <Noughtmare> In the worker function the line: rnd' <- genSeeds (fromIntegral n) m rnd, generates the block of random numbers.
03:19:19 <[exa]> so one function is just creating blocks of data and the other is consuming them, aggregating all data into one result that is printed on the end?
03:19:31 <[exa]> you probably want some pre-build parallel queue for this
03:19:49 <Noughtmare> No, the output is also split in separate chunks and printed individually.
03:20:02 <[exa]> you print from multiple threads at once?
03:20:06 <Noughtmare> Yes
03:20:18 <Noughtmare> That is why I need synchronization
03:20:26 <[exa]> that's hardly going to improve performance
03:20:40 <Noughtmare> It would be slow to aggregate it all since that would consume a lot of RAM
03:20:52 <[exa]> you can prepare the string for printing in multiple threads but certainly do print by one thread
03:20:53 <Noughtmare> We're talking about gigabytes of data
03:20:58 <[exa]> lazy aggregation doesn't eat ram
03:21:05 <Noughtmare> true
03:21:28 <Noughtmare> But I think it does put load on the garbage collector
03:21:35 <[exa]> certainly do
03:21:40 <[exa]> GC is low-level and very optimized
03:21:42 <Noughtmare> Right now I'm reusing all buffers
03:21:47 <Noughtmare> manually
03:22:07 <Noughtmare> which, I think, does improve performance
03:22:14 <[exa]> it's better to let it do what it does best and avoid simulating that using mutexes
03:22:45 <[exa]> parallel computing rule 1: profile before assuming anything
03:22:57 <Axman6> [exa]: I used to spend a lot of time on the language shootout, and MVars were what made the Haskell thread-ruing benchmark the fastest of all languages until other's started cheating and using "coroutine libraries" instead of what would be considered threads in their langiage
03:23:27 <Axman6> MVars are not exactly slow, and they have the advantage of immediately waking up the first thread waiting to read after a write immediately
03:23:29 <[exa]> Axman6: not saying MVars are slow, but compared to atomic buffer swaps in C they _are_ slow
03:23:59 <lavalike> maybe Marlow's book has some insights into benchmarking, I don't recall
03:24:59 <[exa]> Noughtmare: I'd go with some profiling to see where most time is spent. Also, you can try increasing/decreasing buffer size to see whether the related switching is a bottleneck
03:25:31 <[exa]> 60*1024 words is not very big when compared with thread switch
03:25:53 <[exa]> s/thread switch/futex call/
03:25:59 * [exa] -> afk
03:26:13 <Noughtmare> Yeah, I tried bigger buffers but it only saves a few milliseconds at best
03:30:23 <Taneb> I can't compile the version of happy from GitHub, getting "Setup: The program 'happy' is required but it could not be found" (seems it's needing happy to build happy)
05:39:33 <quchen> Dammit, my Hello World won’t typecheck! Turns out embedding SK into Haskell isn’t that easy :-(
05:39:37 <quchen> https://gist.github.com/quchen/94b01eba72297cfb549730c73fad6634
05:40:01 <Taneb> quchen: I did something along those lines once, you need a few unsafeCoerces
05:40:11 <quchen> I’m not familiar with dynamic typing in Haskell :-|
05:40:16 <quchen> Taneb: Tell me more!
05:40:40 <Taneb> quchen: I made a factorial calculator in a similar style (but I used "pure" and "(<*>)" as my names)
05:40:44 <quchen> There’s this paste of Hello World in Haskell-embedded SK(ICB) on Github, but that one’s handwritten I think
05:41:38 <Taneb> Sadly the only copy that yet remains is in the history of the Haskell page on Uncyclopedia
05:41:51 <Taneb> Mine was also handwritten (took me a few hours)
05:42:35 <quchen> Mine is also handwritten, took me much longer than a few hours, since it includes an interpreter for lambda calculus, along with a compiler to SK ;-)
05:42:38 <Taneb> Oh, uncyclopedia has died, so that code has been lost
05:42:59 <quchen> Dammit.
05:43:22 <quchen> I can’t handle unsafeCoerce well enough to do anything with it here. Presumably it’s sprinkled all over S’ body?
05:45:08 <Taneb> :t (<*>) @(_ -> _)
05:45:10 <lambdabot> error:
05:45:10 <lambdabot>     Pattern syntax in expression context: <*>@(_ -> _)
05:45:10 <lambdabot>     Did you mean to enable TypeApplications?
05:45:21 <Taneb> :t \x y z -> x z (y z)
05:45:25 <lambdabot> (t1 -> t2 -> t3) -> (t1 -> t2) -> t1 -> t3
05:46:07 <Taneb> :t (\x y z -> x z (y z)) (\x y -> x)
05:46:10 <lambdabot> (t1 -> t2) -> t1 -> t1
05:46:23 <Taneb> I can't remember exactly where the error was
05:46:31 <quchen> ? let s x y z = x z (y z)
05:46:33 <quchen> ?let s x y z = x z (y z)
05:46:37 <lambdabot>  Defined.
05:46:38 <Taneb> I started with something quite high level and translated bit by bit
05:46:39 <quchen> ?let k x _ = x
05:46:42 <lambdabot>  Defined.
05:47:15 <quchen> Taneb: Same here, but translation is done automatically – https://github.com/quchen/lambda-ski/blob/master/src/ExamplePrograms.hs#L49
05:48:14 <Taneb> So, any fixed-point combinator won't typecheck
05:50:46 <quchen> I don’t have one in my code though
05:51:22 <quchen> None that I can see at least. And I don’t think one reinvents F by accident.
05:51:41 <quchen> But F is probably not the only combinator that doesn’t work in a typed context.
06:14:26 <absence> what should i use instead of MVar if i want to have a worker thread that continuously updates a value? putMVar blocks until each update is taken
06:16:53 <Noughtmare[m]> absence: IORef?
06:17:50 <dminuoso> absence: TVar?
06:19:41 <dminuoso> Though IORef is also an option (depends a bit on what you need), as long as you use atomicWriteIORef
06:22:34 <phaazon> hello :)
06:22:51 <dminuoso> Hello phaazon.
06:23:56 <absence> thanks, i'll look into them
06:24:35 <dminuoso> absence: Do note that TVar is probably the more robust technique if you have non-trivial things going on.
06:26:30 <absence> it seems like neither IORef or TVar can be empty though
06:26:59 <absence> (i.e. block when reading from it before anything has been written)
06:27:22 <dminuoso> absence: Use Maybe.
06:27:32 <dminuoso> absence: e.g. `TVar (Maybe Int)`
06:28:02 <absence> that doesn't make it block
06:28:15 <dminuoso> absence: You'd retry if it's Nothing
06:28:22 <dminuoso> Let me make an example.
06:30:38 <dminuoso> absence: https://gist.github.com/dminuoso/39347ce6f5875a2b830b9bc20ae45325
06:31:16 <dminuoso> absence: You could wrap this into a small combinator if you like: onJust :: TVar (Maybe a) -> (a -> STM b) -> STM b
06:31:50 <dminuoso> Or maybe even `TVar (Maybe a) -> STM a`
06:32:24 <dminuoso> % :t maybe retry pure =<< readTVar
06:32:25 <yahb> dminuoso: ; <interactive>:1:22: error:; * Couldn't match expected type `STM (Maybe b)' with actual type `TVar a0 -> STM a0'; * Probable cause: `readTVar' is applied to too few arguments; In the second argument of `(=<<)', namely `readTVar'; In the expression: maybe retry pure =<< readTVar
06:32:58 <dminuoso> % :t \s -> maybe retry pure =<< readTVar s
06:32:58 <yahb> dminuoso: TVar (Maybe b) -> STM b
06:33:17 <dminuoso> % waitJust s = maybe retry pure =<< readTVar s
06:33:17 <yahb> dminuoso: 
06:35:03 <dminuoso> Then you'd do: i <- waitJust someTVar; ... use i ... 
06:36:24 <absence> looks nice. is there a way to do something similar with IORef? STM seems a bit heavy handed for something so simple
06:37:03 <dminuoso> absence: It's built into the rts, so...
06:37:05 <dmwit> absence: I should make a package with just https://github.com/dmwit/mcmario/blob/wip/macerole/src/MCMario/STM.hs in it.
06:37:36 <dmwit> absence: With that module (instead of the standard STM ones), you can write `Just foo <- readTVar whatever; whateverElse` and this will block until `whatever` has a `Just` in it.
06:37:44 <dminuoso> dmwit: Oh that's very sensible. I was already annoyed not to find a MonadFail instance..
06:38:00 <dmwit> absence: Until I get off my ass and make that package, I encourage you to copy my code into your own project. =)
06:38:11 <dmwit> If you want a more relaxed LICENSE than BSD3 on it just let me know.
06:38:22 <dminuoso> Seems like this should be trivial to get into base, no?
06:38:31 <dmwit> I'm not sure, and not motivated.
06:38:45 <dmwit> If you'd like it, feel free to kick off the process, I guess.
06:38:59 <dminuoso> I'll take the torch.
06:39:15 <dminuoso> absence: re IORef, I think not.
06:39:38 <dminuoso> absence: Problem will be the "waiting until its initially written to bit" - and that's kind of what STM addresses.
06:42:24 <dminuoso> absence: And if all you want to do is wait for that condition, you'd just have: do { a <- atomically (waitFor x); ... }
06:49:39 <absence> dminuoso: so i just do atomically (newTVar ...) and pass the result to whatever threads, which do atomically (waitJust etc etc) or atomically (writeTVar ..)?
06:50:41 <Axman6> dmwit: all your functions for your Monad instance can just be coerce'd
06:51:07 <Axman6> hmm, you're already using coerce!
07:13:50 <dmwit> Axman6: Good idea! ;-)
07:14:46 <dmwit> (As for why I didn't do that in the Monad instance: I find this more readable than the ungodly type signatures needed to make coerce work there.)
07:15:07 <Taneb> dmwit: hmm, is there scope for a geneal newtype wrapper with "instance MonadPlus m => MonadFail (FailWrapper m)"?
07:15:42 <dmwit> Sounds plausible to me.
07:16:41 <Taneb> (I'd also like one with "instance MonadFail (FailWrapper' m)" where fail = error
07:17:52 <dmwit> (What's the difference between MonadPlus and Alternative again?)
07:18:24 <lavalike> "Monad m =>" :D
07:18:58 <dmwit> Oh, wow, Alternative is a superclass of MonadPlus now, huh?
07:19:21 <dmwit> Are mzero = empty and mplus = (<|>) class laws?
07:19:53 <jumper149> Hi, I have trouble getting data out of IO Monad
07:20:29 <jumper149> I have a list of filepaths and want to read the contents into a list of strings
07:21:02 <jumper149> so basically `f :: [FilePath] -> IO [String]
07:22:18 <dmwit> :t traverse readFile
07:22:21 <lambdabot> Traversable t => t FilePath -> IO (t String)
07:22:55 <jumper149> thank you :)
07:23:00 <dmwit> (Seems at least all the instances in base follow this rule, provided all their parameters do.)
07:23:15 <dmwit> jumper149: Might be worth trying to implement it yourself anyway to get practice.
07:23:37 <dmwit> jumper149: If you took a stab at it and it didn't work, feel free to post it here (or a link if it's more than about two lines) and we'll help you make progress.
07:24:19 <jumper149> dmwit: Ye I will implement it right now and then probably use traverse for better readability :)
07:25:59 <Taneb> dmwit: it doesn't seem that "monadplus ops match alternative ops" is an explicitly written down rule, sadly, but they are the default implementations
07:31:49 <Boarders> does anyone know the easiest way to install the latest version of hlint?
07:32:05 <Athas> Boarders: cabal install hlint
07:32:15 <absence> dminuoso: seems to work, thanks!
07:32:43 <Boarders> athas: does that get you version 2.1.25?
07:32:56 <glguy> cabal v2-install hlint is installing hlint-2.2 for me
07:33:19 <Boarders> ok thanks
07:33:21 <Athas> Boarders: it should get you the newest version on Hackage, modulo the usual weird Cabal constraints.
07:34:17 <Boarders> this says I already have version 2.1.17 installed
07:34:25 <Boarders> do I need to remove that first or?
07:34:49 <jgt> traverse_ can always be used in place of mapM_, right?
07:34:58 <Boarders> jgt: yes
07:35:08 <Athas> Boarders: yes.  I think that's 'ghc-pkg unregister hlint'.
07:35:14 <jgt> Boarders: Cool. Thanks.
07:40:19 <jumper149> I think I got the main part of swapping [] and IO down but could you tell me how I would do it without do-notation?
07:41:19 <jumper149> this is how I did it http://sprunge.us/nrSc2e
07:43:33 <Boarders> with DerivingStrategies if I have deriving (Generic, NFData) are those both stock instances
07:43:35 <Noughtmare[m]> fmap (:[]) a and liftA2 (:) a (swapListIO as)
07:44:54 <Boarders> or is NFData anyclass?
07:45:43 <Noughtmare[m]> jumper149: You function is not total, what should happen when swapListIO gets [] as input?
07:47:11 <lavalike> @undo do { x <- [1,2,3]; return x; } -- jumper149 you could ask the bot
07:47:12 <lambdabot> [1, 2, 3] >>= \ x -> return x
07:47:13 <Noughtmare[m]> Boarders: See https://hackage.haskell.org/package/deepseq-1.4.4.0/docs/Control-DeepSeq.html#v:rnf
07:47:21 <jumper149> Noughtmare[m]: swapListIO [] = return [] should work I guess
07:47:44 <Noughtmare[m]> jumper149: Then you can leave out the case with only one element.
07:48:04 <Noughtmare[m]> Boarders: (it is anyclass)
07:48:11 <jumper149> oh ye I guess you are right... its recursion all over again :D
07:48:28 <Boarders> noughtmare[m]: thanks
07:50:50 <Noughtmare[m]> jumper149: For a version without do notation, maybe this wikibooks article can help you: https://en.wikibooks.org/wiki/Haskell/do_notation.
07:51:53 <jumper149> Thanks, I will read through it later today :)
08:08:47 <tabaqui> oh, that is funny
08:08:49 <tabaqui> https://hackage.haskell.org/package/monad-logger-0.3.30/docs/Control-Monad-Logger.html#t:WriterLoggingT
08:09:07 <tabaqui> Here WriterLoggingT uses LogLine type, which is not exposed by the library
08:09:18 <tabaqui> but is defined just in the same module
08:10:07 <tabaqui> and the same thing with DList :)
08:16:05 <dmwit> jumper149: Here's almost exactly your code, without do notation:
08:16:07 <dmwit> ?src sequence
08:16:07 <lambdabot> sequence []     = return []
08:16:07 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
08:16:07 <lambdabot> --OR
08:16:07 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
08:16:48 <dmwit> jumper149: I agree with you that you should change your base case to [] instead of (a:[]).
08:17:10 <jumper149> I'm already looking at sequence right now :)
08:17:24 <lyxia> Boarders: "stock" instances are for classes in the standard and those from these extensions: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#deriving-instances-of-extra-classes-data-etc
08:17:40 <jumper149> But actually for another purpose lol 
08:17:40 <Boarders> lyxia: thanks!
08:18:17 <dmwit> jumper149: However, in most cases where sequence is useful, you are calling it on a list that was produced by `map`; as in `sequence (map doAThing xs)`. Then you should use `traverse` instead to avoid building an unneeded intermediate list.
08:18:33 <dmwit> ?src mapM
08:18:33 <lambdabot> mapM f as = sequence (map f as)
08:18:43 <dmwit> (and `traverse` is the modern name choice for `mapM`)
08:19:41 <jumper149> ?src traverse
08:19:41 <lambdabot> Source not found. My brain just exploded
08:19:45 <jumper149> uff
08:20:14 <dmwit> You can click the "Source" links to the right of various instances here: https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Traversable
08:20:28 <dmwit> For example, for lists, https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.Traversable.html#line-237
08:21:01 <dmwit> (For the first link, you may have to scroll down a bit past the method documentation to see the instances list.)
08:21:45 <jumper149> I'm usually using hoogle and hoogle --info if Im looking for a function ;)
08:23:19 <jumper149> mapM takes a Monad and traverse takes an Applicative. This is the only difference I can spot.
08:24:39 <jumper149> and Monad is defined as an Applicative, so I guess we can kinda scrap mapM :D
08:25:06 <dmwit> All correct.
08:25:26 <dmwit> mapM persists for backwards compatibility.
08:28:59 <c_wraith> there was a long period (say, the first 20 years or so of Haskell?) where Applicative was not a superclass of Monad.
08:29:15 <c_wraith> mapM dates back to those times.
08:30:00 <int-e> . o O ( I remember Idioms )
08:30:04 <c_wraith> (note that "the first 20 years" is misleading... Monad didn't exist for the first several years, and Applicative came along several years after that)
08:59:05 <int-e> I kind of forgot about the  main :: [Result] -> [Request]  idea
08:59:58 <int-e> (Haskell had monads when I learned the language.)
09:00:18 <bollu> int-e I heard that it was easy to mess up in that model
09:01:03 <int-e> I can imagine.
09:01:56 <int-e> But it is an instructive illustration of the power of laziness :)
09:02:27 <int-e> Because (even today, to me) the type initially doesn't make any sense.
09:03:17 <kuribas> what's a Result?
09:04:03 <kuribas> is there a model besides monads that makes effects in a pure language managable?
09:04:07 <bollu> kuribas the result of whatever request you made?
09:04:14 <kuribas> bollu: I mean the type
09:04:23 <kuribas> or is it user defined?
09:04:37 <bollu> kuribas I always imagined it was a large sum type. I could be wrong :) 
09:04:41 <bollu> kuribas I have no idea
09:05:26 <kuribas> In hindsight having monadic IO makes much sense
09:05:37 <ski> it's not user-defined
09:06:05 <kuribas> Even without having a monad type class
09:06:43 <int-e> kuribas: It's just a basic idea how one can model IO. Request would be an IO request, like PutStrLn "foo" or GetLine; Result (hmm, should've used Reply) would encode the result, if any... say GetLineResult "foo"
09:07:03 <ski>   data Request = GetChar | PutChar Char | ...
09:07:13 <kuribas> int-e: but then it couldn't be extended?
09:07:20 <ski>   data Response = CharGot Char | CharPut | ...
09:07:31 <kuribas> So you only have a fixed set of allowed IO actions.
09:09:32 <ski>   putChar :: Char -> ([Response] -> [Request]) -> [Response] -> [Request]
09:09:34 <int-e> kuribas: well you then can have building blocks like  getLine :: (String -> [Result] -> [Request]) -> [Result] -> [Request]
09:09:35 <ski>   putChar c k ~(CharPut:resps) = PutChar c : k resps
09:09:36 <bollu> kuribas but we already only have a fixed set of IO actions?
09:09:46 <ski>   getChar :: (Char -> [Response] -> [Request]) -> [Response] -> [Request]
09:09:47 <int-e> kuribas: and those compose nicely.
09:10:01 <kuribas> bollu: you can use the ffi to create more 
09:10:12 <ski>   getChar c_k ~(CharGot c:resps) = GetChar : c_k c resps
09:11:13 <int-e> you can even define  newtype IO a = IO ((a -> [Response] -> [Request]) -> [Response] -> [Request])  and make it into a monad.
09:11:40 <ski> of course, `getChar :: Cont Answer Char', and `putChar :: Char -> Cont Answer ()' where `type Answer = [Response] -> [Request]', and then `type IO = Cont Answer'
09:12:31 <ski> yes. i wrote `putChar' and `getChar' in CPS above, for compositionality's sake
09:13:22 <ski> one could inline the continuations in many cases, which gets something a bit more direct, but also less maintainable
09:13:53 <int-e> kuribas: Obviously, I don't want Haskell to go back to that model. But as an illustration of laziness (oh, we can produce the first request before looking at the first response, so some interpreter can produce the responses on demand) I like it.
09:14:31 <kuribas> int-e: sure.  I think curry has something like that with as will, using non-determinism instead of lazyness
09:14:33 <ski> the `~'s in the patterns above are crucial. without them, the program would hang in an infinite loop
09:15:40 <ski> i've seen a similar model to this in LP (one of the early papers about Mercury, by Zoltan Somogyi), using partial instantiation, instead of non-strictness
09:17:23 <bollu> ski what is LP?
09:17:45 <ski> so, when we instantiate the output request parameter to be a cons cell whose head is `get_char' or `put_char(C)', that would cause a coroutine waiting for that to be instantiated to pick up the request, perform the I/O on out behalf, and then instantiate the corresponding cons cell of the input response parameter for us, with `char_got(C)', or with `char_put'
09:18:19 <recursion-ninja> I keep getting SMTP errors from the "haskell.org" domain when sending emails from my "recursion.ninja" domain. Does anyone know why?
09:18:22 <recursion-ninja> Example:
09:18:23 <recursion-ninja> This message was created automatically by mail delivery software.A message that you sent has not yet been delivered to one or more of itsrecipients after more than 4 hours on the queue on bosmailout06.eigbox.net.The message identifier is:     1hlVXQ-00059Y-UfThe subject of the message is: Huffman Library MaintainershipThe date of the message is:   
09:18:24 <recursion-ninja>  Thu, 11 Jul 2019 05:38:48 -0400The address to which the message has not yet been delivered is:  haskell-cafe@haskell.org    Delay reason: H=mail.haskell.org [23.253.242.70]:    SMTP error from remote mail server after RCPT TO:<haskell-cafe@haskell.org>:    450 4.1.7 <SRS0=Di7YQf=VI=recursion.nNo action is required on your part. Delivery attempts w
09:18:24 <recursion-ninja> ill continue forsome time, and this warning may be repeated at intervals if the messageremains undelivered. Eventually the mail delivery software will give up,and when that happens, the message will be returned to you.
09:18:37 <ski> bollu : Logic Programming. as in Prolog,Mercury,Oz,Escher,Curry,Gödel,lambdaProlog,Lolli,Twelf,&c.
09:18:43 <bollu> ahh
09:18:57 <bollu> "LP" for me usually stands for "linear programming" so I was confused :) 
09:19:16 <bollu> ski do you know any papers outside of  WAM about implementing a fast logic programming language? 
09:19:20 <bollu> WAM is incredibly hard to debug
09:19:28 <recursion-ninja> These email issues have persisted since I began trying to send emails to the "haskell.org" domain over 6 months ago.
09:19:53 <recursion-ninja> Does "haskell.org" black list or whitelist certain top level domains?
09:20:37 <ski> there's also CLP, Constraint Logic Programming, which is CP (Constraint Programming) combined with LP. this appears to me to be one of the most natural forms of CP. many Prolog systems have CLP support, in the form of various CLP(X) solvers for various values of `X'. you could check out ECL^{i}PS^{e} for one which is supposed to have quite extensive support
09:21:04 <bollu> ski can you provide me some links? I'd be very grateful
09:23:38 <ski> bollu : Mercury <https://www.mercurylang.org/>. Mercury is faster, but then it's in some ways less flexible, in that you can't (except in some restricted cases) have aliasing ("serious" equality constraints) between logic variables. because it's using static checking of modes and insts (instantiation states). also has static types and determinisms. the type system is similar to Haskell in many ways, including having type classes
09:24:07 <ski> (however, it doesn't have higher-order types, all type variables have kind star, are concrete)
09:24:16 <bollu> ski are there papers / monographs / what have you about how mercury is _implemented_?
09:24:35 <ski> ECL^{i}PS^{e} <http://eclipseclp.org/>
09:24:44 <bollu> " The implementation of Mercury: an efficient purely declarative logic programming language. "
09:24:45 <bollu> nice
09:24:59 <ski> bollu : lots :) <https://www.mercurylang.org/documentation/papers.html>
09:25:07 <Jinna> I have a Data.Map and want to compute a frequencies map. I would like to update the value (count of occurrences) via `succ` (i.e. add 1). But: if that key does not exist I want to insert it instead with a value of 1.
09:25:11 <Jinna> What function am I looking for?
09:25:21 <bollu> yeah, that's sexy
09:25:24 <bollu> begone WAM
09:26:02 <bollu> I really tried to implement WAM: https://github.com/bollu/warren | but it's way too complex to debug, and I don't have those many spare cycles, unfortunately
09:27:37 <ski> bollu : there's also a channel #mercury (in addition to ##prolog). Boney, who's there, was one of the main developer of the Melbourne Mercury Compiler, probably still know a lot of the ropes
09:27:48 <bollu> ah, that's awesome
09:28:15 * ski idly wonders where Fergus Henderson, and Andrew Bromage (aka Pseudonym) went
09:28:35 <ggole> bollu: did you follow that tutorial paper (on the WAM)?
09:28:45 <bollu> ggole "tutorial reconstruction"? yes
09:29:01 <bollu> ggole I got their examples working, but I had a different example where my interpreter bugged out
09:29:13 <bollu> and WAM produces way too much data / indirections on the heap to trace through in a sane way
09:29:18 <ggole> Hmm. I've been meaning to go through that at some point.
09:29:23 <bollu> it's hard to reason about, IMO
09:29:59 <bollu> their presentation also wasn't to my liking. some of it is quite vague. some type signatures and recursion would have helped a lot
09:30:25 <bollu> they often state algorithms in a purely iterative way, which causes them to need to manage stacks of things
09:30:30 <nightbri[m]> .
09:30:35 <bollu> while you could state the algorithm cleanly recursively
09:31:25 <dmwit> recursion-ninja: Might be worth asking on #haskell-infrastructure, where your query is less likely to get drowned out by other discussions before somebody relevant sees it.
09:35:52 <dmwit> Jinna: M.fromListWith (+) [(v,1) | v <- vs]
09:36:33 <dmwit> Jinna: There is also M.insertWith (+) v 1 for one-at-a-time updates.
09:37:13 <dmwit> > M.fromListWith (+) [(c,1) | c <- "hello hi"]
09:37:16 <lambdabot>  fromList [(' ',1),('e',1),('h',2),('i',1),('l',2),('o',1)]
09:53:10 <aozt> hello.
09:53:12 <aozt> in topic of this channel there is a link: Paste code/errors: https://gist.github.com/
09:53:35 <mniip> sure there is
09:53:54 <aozt> can somebody tell me hot to easily get raw view version of the gist.github paste by the URL of the HTML page of a paste?
09:54:54 <aozt> "... tell me how to..."   silly typo
09:55:10 <int-e> Huh I wasn't aware... could we change that to a proper pastebin (that doesn't require an account) like paste.debian.net?
09:55:47 <aozt> paste.debian.net is good.  very easy to use and a very reliable one too.
09:56:27 <int-e> and it works without javascript
09:56:46 <dmwit> aozt: There is a "Raw" link on the HTML page. The transformation is very predictable, so try it on one such HTML page and I can practically guarantee you know how to do it for any other.
09:56:48 <wroathe> So when you install cabal-helper through cabal v2-install it builds the package into a store directory in the ~/.cabal directory, and then it creates a symlink for cabal-helper-wrapper in ~/.cabal/bin. This symlink expects there to be a corresponding bin directory in the store package directory, but cabal-helper has it's executable in libexec instead. Anyone else encounter this?
09:57:21 <aozt> dmwit: ok, thank you.
09:58:53 <dmwit> wroathe: I haven't encountered it, but I would file an issue on the cabal bug tracker.
10:00:19 <dmwit> (Hm, I guess the gist URL transformation is predictable if you start from a particular revision's URL, but not easily predictable just starting from a particular gist's top-level URL.)
10:00:20 <wroathe> Well, I'm thinking this might be a configuration issue on my end
10:00:37 <dmwit> It should not be possible to configure cabal to make an incorrect symlink in the store.
10:00:48 * dmwit puts his foot down
10:01:25 <dmwit> Now, it may indeed be that this bug only appears with certain configuration settings. But that doesn't excuse it from being a bug.
10:05:06 <wroathe> dmwit: I'll get to the bottom of what's going on before I submit an issue
10:06:21 <dmwit> I'm sure they'll appreciate that very much!
10:06:48 <dmwit> If you get down into it and discover you haven't the stamina to reach the bottom, I'm sure they'll appreciate a report with just the first layer of dirt removed, too.
10:07:37 <dmwit> This analogy is stretching a bit thin. All I'm saying is don't let perfect be the enemy of the good on your report.
10:13:11 <wroathe> The first thing I see is that the reason it installs the exeuctable into libexec is because of the semantics of "private" scope https://www.haskell.org/cabal/users-guide/developing-packages.html?highlight=scope#pkg-field-executable-scope
10:13:54 <wroathe> https://github.com/DanielG/cabal-helper/blob/0.8-series/cabal-helper.cabal#L124
10:13:57 <wroathe> So that's fun
10:14:35 <wroathe> So now the question is whether or not it's possible to instruct Cabal to symlink private executables
10:26:05 <jle`> is there any way to specify type roles as a constraint?
10:26:40 <jle`> (m <reprsentational>) => m a -> m b
10:33:21 <dmwit> no =(
10:33:50 <dmwit> I've requested a feature like this in the past, too; but they aren't thinking hard about how to do it because there's some feeling that QuantifiedConstraints will solve the most common use cases.
10:34:03 <dmwit> Which... well. My uses cases aren't common, and maybe yours aren't, too. =P
10:34:57 <Boarders> jle', dmwit: this would be useful for a better coercible-utils style library
10:35:39 <Boarders> currently to automatically coerce ala style along a traversable structure you need to carry around the quantified constraint but in my experience the type inference is quite bad
10:37:21 <Boarders> e.g. my version of ala looked like: https://gist.github.com/Boarders/2fa67b3e892831cf6d998f9bfdf4cf8d
11:06:07 <lyxia> dmwit, jle`: in what case is "forall a b. Coercible a b => Coercible (m a) (m b)" no good?
11:17:26 <int-e> lyxia: whenever m is a type or data family.
11:18:36 <int-e> lyxia: that's not exhaustive. m = Data.Set.Set may be problematic if the Ord instance of a and b are not equivalent... etc.
11:19:15 <int-e> (the compiler will check that the first argument of m is representational, not nominal, before allowing that coercion)
11:21:53 <lyxia> I'm not sure I understand how those are problems.
11:22:08 <dmwit> lyxia: Here is a copy of an email I wrote some time ago carefully motivating a thing that QuantifiedConstraints does not cover: https://gist.github.com/dmwit/6bde753cec246aa5d7e7c97941647537
11:22:27 <dmwit> Or, well, I think the motivation is careful. Maybe you don't, and then you should point out why. =)
11:22:29 <lyxia> Is Set's argument currently representational?
11:23:47 <dmwit> (Or at least, it does not appear to cover it to me.)
11:29:03 <lyxia> That sounds fair. It seems the problem is that some types can't satisfy that constraint even though they should.
11:46:19 <wz1000> Is there any way to normalize tuples of constraints so that every constraint in the tuple can be easily traversed using a type family?
11:47:00 <wz1000> ((a,b),c) and (a,b,c) are distinct, even though they mostly behave the same
11:47:52 <wz1000> so if you want to write a type family that traverses every constraint in a tuple, you have to write cases for all the sizes of tuples you care about
11:57:12 <lyxia> type family Normalize ... where Normalize (a, b) c = Normalize a (Normalize b c) ; Normalize (a, b, c) d = Normalize a (Normalize b (Normalize c d)) ; ... ; Normalize c d = (c, d)
11:58:41 <lyxia> I'm curious to know why you want to traverse constraints and whether you could assume they already have some structure instead of having to normalize them.
12:15:22 <wroathe> Anyone know if there's a way to load a static library file (.a file) in GHCI?
12:25:20 <JappleAck> hi there. can i upload new README page on hackage (and preferably on stackage too) without releasing new version?
12:31:00 <infandum> How can I profile a program without having it complete?
12:31:12 <infandum> Looks like "+RTS -p" needs completion.
12:32:53 <dminuoso> infandum: "completion"?
12:34:54 <infandum> I'm running it on different randomly generated files of equal size. They all take a few seconds, one of them is taking hours, so it's probably some infinite loop or something similar so I want to see where it's spending it's time
12:39:07 <infandum> Weird, I tried "-h" and it's spitting out the expected information, but when it hangs the outputted information stops
12:39:15 <infandum> no more samples
12:43:40 <wroathe> Is there a way to force GHCI to allow importing hidden modules?
12:44:45 <Boarders> wroathe: when you are in ghci can't you just do :l HiddenModule.hs
12:44:52 <Boarders> or is this not what you have in mind?
12:45:35 <wroathe> Well, I'm still trying to debug why cabal helper seems to be trying to load the cabal-helper-wrapper from ~/.cabal/libexec instead of the libexec dir in the ~/.cabal/store directory
12:45:48 <wroathe> and it seems to be getting that location from an autogenerated Paths_cabal_helper module
12:46:05 <wroathe> So I'm trying to get access to that generated module
12:46:33 <wroathe> so I can call getLibExecDir, just to confirm it is pointing to the wrong spot
12:47:00 <wroathe> I can include the cabal-helper package in GHCI, but it doesn't expose that Paths_ module
12:55:31 <dmwit> infandum: Well... you could have your program terminate after a few minutes. =)
12:56:03 <dmwit> infandum: main = forkIO oldMain >> threadDelay 60000000
12:57:06 <dmwit> wroathe: If you cabal v2-repl cabal-helper, it should give you access even to hidden modules of that package.
12:58:52 <wroathe> "cabal: 'repl' doesn't take any extra arguments when outside a project"
12:59:00 <wroathe> I suppose I could just init a random project
13:00:45 <wroathe> Ah, that apparently only works for project dependencies. I'm trying to determine why the global cabal-helper isn't finding it's libexec dir
13:04:48 <glguy> JappleAck: did you try listing the .a file as a command line argument to GHCi?
13:09:07 <JappleAck> glguy: sry? didn't get how it's related to my question
13:10:34 <wroathe> glguy: I think you meant to target me with that
13:10:38 <wroathe> glguy: And yeah, that doesn't work
13:10:51 <wroathe> glguy: But I was on the wrong track with that anyway
13:16:57 <dmwit> wroathe: I mean, you could also patch cabal-helper to expose that module and install the patched version temporarily.
13:21:22 <glguy> Oh yeah. JappleAck , no I don't think you can change the readme without a new release
13:29:48 <fragamus> howdy I am calling parseFileContentsWithMode and I am tripping over #if in the input
13:30:19 <fragamus> I am guessing it can be cured by allowing something in the mode
13:31:12 <Cale> fragamus: Try enabling the CPP extension?
13:31:36 <Cale> I don't know if haskell-src-exts is smart enough to deal with that
13:33:11 <fragamus> I bet it is
13:39:59 <int-e> After a quick scan of the sources I believe running cpp is out of scope for haskell-src-exts
13:40:52 <fragamus> ok that sucks a little bit
13:41:50 <int-e> I'd try the cpphs library.
13:45:30 <fragamus> thanks that looks promising
13:50:34 <fragamus> what does GHC do with #if and the like
13:50:45 <fragamus> I mean how does it handle those
13:51:02 <fragamus> like, does it use cpphs or what
13:52:31 <c_wraith> I don't remember. I know it used to use cpphs, and there were some issues. I know a Haskell replacement was written. I don't remember if that was integrated into ghc.
13:53:07 <c_wraith> (cpphs is really unhappy with the Haskell convention of ending supplementary names with ')
13:54:22 <int-e> Hmm? I thought it uses the C proprocessor by default, and cpphs is the preprocessor that kind of cures the ' problem.
13:54:30 <c_wraith> yeah, I got confused.
13:54:47 <c_wraith> but if you replace the names with the right thing, the history is right.
13:55:17 <int-e> Though in this context the main reason I'm suggesting cpphs is that it is a library... so no spawning of external processes is required.
13:56:20 <int-e> (Note that cpphs is under an LGPL license)
14:18:15 <merijn> fragamus: It uses gcc/clang's CPP mode usually, afaik
14:18:45 <njay0009> Hello! I'm looking for a haskell library to easily write menus in the terminal. I'm hoping to be able to navigate through the menus with tabs/arrows, similar to zsh autocomplete. If I can print multiple boxed menus side-by-side, that would be nice, but not essential. Are there any good libraries out there that could help my cause?
14:19:23 <merijn> brick?
14:19:32 <merijn> Assuming you only care about posix terminals
14:19:34 <lukelau> I’m trying to use generics-deriving to traverse a the U1/V1/Sum/Products of a generic type: https://gist.github.com/bubba/68c215294bb808146eaf14879e937072
14:19:44 <lukelau> But I want it to traverse a type of *, not * -> *
14:20:18 <lukelau> Wrapping it with the Identity newtype causes it to lose the information about the type within
14:20:56 <lukelau> Is it possible to do what I’m thinking of? i.e count the fields in a constructor
14:21:17 <njay0009> merijn: I'm hoping that the package supports tabbing through the menu options, though that might be a little optimistic (is it?). Does brick support that?
14:21:26 <lukelau> Or do I need to write functions that operates on the result of `from`
14:21:58 <Cale> But note that brick will want control over the entire terminal screen, so it's not really like zsh autocomplete in that way
14:22:13 <merijn> njay0009: No clue, I just know it's the successor to vty which was pretty good at doing widgets/terminal UI
14:22:23 <Cale> Well, it's built on top of vty
14:23:04 <njay0009> Alright, I'll give it a spin. Thanks!
14:23:06 <merijn> I meant vty-ui
14:23:12 <Cale> ah
14:23:35 <Cale> I actually wonder if the lower level vty library might have support for controlling only part of the terminal
14:24:41 <glguy> It doesn't and there's a ticket open asking for that
14:27:41 <Lycurgus> wow that was wierd, the vty author's name is very close to mine, funny to see it come up on github like that
14:29:13 <c_wraith> his name is nothing like mine, but we used to work together.
14:29:24 <Lycurgus> if hs was all it's supposed to be you oughta be able to use some hcurses thing with that to get regions, no?
14:29:56 <Lycurgus> well my initials are jedaugherty
14:30:12 <c_wraith> that's certainly close.
14:30:25 <Lycurgus> yeah that's why it was arresting
14:32:13 <Lycurgus> s/supposed/sometimes cracked up/
14:34:14 <Lycurgus> or just use the curses things, there appear to be multiple
14:34:37 <merijn> curses is widely known to have a god awful interface/API
14:34:48 <c_wraith> eh. when you start doing IO you're at the liberty of what the library provides. the language doesn't much matter if the library is a problem
14:34:51 <merijn> (also in C), vty is supposed to be "curses, but with less suck"
14:35:48 <c_wraith> I very much miss writing code for fixed terminal dimensions where I could just write directly to VRAM to control screen contents.
14:38:59 <c_wraith> (just remember that every display character was actually two bytes.. the color byte and the glyph byte)
14:39:56 * solonarv . o O ( killMeIn micros = do me <- myThreadId; forkIO (threadDelay millis >> killThread me) )
14:42:05 <solonarv> bah, typo
14:42:10 <tabaqui> does unsafeCoerce allow to cast into non exposed type?
14:42:26 <c_wraith> tabaqui, sometimes!
14:42:29 <tabaqui> f.e. to FileStatus from System.Posix.Files
14:42:42 <tabaqui> c_wraith: that's enough :)
14:42:47 <solonarv> yes, you just need to somehow make the typechecker infer that type
14:42:58 <c_wraith> but if you corrupt your memory, it's your own fault...
14:43:02 <tabaqui> sure
14:43:17 <tabaqui> well, FileStatus is just newtype over (Ptr ())
14:43:22 <solonarv> and also I think there might be a black magic TH package somewhere that lets you refer to non-imported names
14:43:33 <merijn> @hackage true-name
14:43:34 <lambdabot> http://hackage.haskell.org/package/true-name
14:43:43 <solonarv> that's the one!
14:44:27 <tabaqui> oh, I see what it does
14:44:33 <tabaqui> black magic, indeed
14:46:54 <jle`> lyxia: something like that actually works in my situation, i ended up using it before scrapping the whole thing heh
14:47:13 <tabaqui> thanks, btw
14:51:49 <solonarv> jle`: as I was reading scrollback I typed up the exact same quantified-Coercible suggestion :D
14:53:34 <jle`> ah haha. yeah, it'd be nice to be able to state 'what i meant' instead of using quantified constraints, but it's usable for now
14:53:55 <jle`> my real problem that i couldn't get around was that i needed to use DerivingVia using two newtype wrappers for both type variables in an MPTC
14:54:29 <jle`> deriving Foo Int Bool through Foo (W1 Int) (W2 Bool) 
14:54:46 <jle`> it looks like DerivingVia only unwraps the second type variable and not the first?
15:05:27 <alx741> hello all. I'm having an issue where my project needs transformers-0.5... and need to use 'friday-devil' which, in its latest version, requires transformers < 0.5. How can I address this?
15:10:16 <ClaudiusMaximus> alx741: you could perhaps try `cabal install --allow-newer=transformers`
15:11:32 <alx741> ClaudiusMaximus: yep, just did that and it worked :) thank you
16:16:14 <jackdk> and if it works and you have time, PR friday-devil
16:25:34 <crestfallen> hi on line 164, would someone show me what ts is there precisely, that map minimax is applied to? https://github.com/varreli/haskell/blob/master/hutton/84_chapt11/ticTacToe.hs
16:26:01 <crestfallen> I'm just trying to figure out how minimax works
16:32:40 <crestfallen> I'm trying to get map minimax ( ... ) to work in ghci    so I can see what is happening
16:35:38 <crestfallen> it's mapping over a recursive function so I'm a bit confused about what it would output.
16:54:09 <Dablyon> Is there a way to typecast a [Char] to Text type?
16:56:07 <ski> Dablyon : what do you mean by "typecast" ?
16:57:23 <jackdk> Dablyon: If by "typecast" you mean "convert", you want to look at the function `Data.Text.pack`
16:59:55 * ski looks at Dablyon
17:00:28 <Dablyon> Thank you for help @jackdk, I haven't used IRSSI in awhile.. getting used to it again :P
17:00:56 <Dablyon> That is correct @ski, jackdk informed me of `Data.Text.pack`.
17:01:34 * ski nods
17:01:37 <ski> (i saw that :)
17:03:10 <ski> Dablyon : btw, fwiw, it's not IRC custom to prefix nicknames with sigils like `@' (IRC predates Twitter). if you want to mention, refer to, or address someone specifically, simply mention their nickname. in the last case, e.g. by mentioning it first in the message, followed by a comma or colon, and the remainder of the message :)
17:04:31 <ski> Dablyon : btw, if you write in Haskell e.g. `read "496" :: Double', then that is not a "typecast" (nor a type signature), but a type ascription (type annotation, if you will)
17:05:45 <ski> (it doesn't change the type of anything. it just explicitly says what type it "already is". it can serve to disambiguate, in case the implementation, or the human reader, isn't sure which type is intended)
17:07:04 <ski> > cast False :: Maybe Bool
17:07:08 <lambdabot>  Just False
17:07:10 <ski> > cast False :: Maybe Int
17:07:13 <lambdabot>  Nothing
17:07:24 <solonarv> even that isn't a cast!
17:08:31 <ski> (the `cast' there could be considered a "checked cast", perhaps, but it won't allow one to actually regard the value as being of a different type. it can just be used to check whether the source and target types are the same at run-time, even though they're not (necessarily) known to be the same at compile-time)
17:08:38 <nshepperd> type casts? i don't believe they exist
17:09:06 <hpc> much like real casts, you only need to use type casts when something is broken :D
17:12:37 <solonarv> 'coerce' and its evil friend 'unsafeCoerce' are probably the closest thing to casts we have
17:45:28 <cheater> what's the best way to set env vars for code being run in ghci?
17:45:37 <cheater> in cabal new-repl specifically
18:01:59 <argent0_> cheater: FOO="bar" ghci
18:02:21 <argent0_> idk if "the best"
18:03:09 * ski . o O ( `/usr/bin/env' )
18:05:21 <cheater> argent0_: i meant from within ghci
18:05:30 <cheater> i know you can pass env in from the outside :-)
18:05:32 <cheater> thanks though
18:07:05 <cheater> i should have described my problem better :-)
18:07:42 <ski> there should perhaps be an `withEnv :: [(String,String)] -> IO a -> IO a' ?
18:08:04 <cheater> more like just setEnv
18:08:26 <cheater> (String, String) -> IO ()
18:09:35 <ski> well, that wouldn't be local
18:09:44 <cheater> no, it would not
18:09:51 <cheater> that's fine though
18:09:58 <ski> perhaps there should be a variant of `:main' which could also be passed environment
18:10:12 <cheater> that would be too much
18:10:24 <cheater> btw, if i have two repos with one package each, say a and b, b depends on a, how can i use a cabal.project file to build b and use a as source?
18:10:40 <cheater> someone told me to put both a and b in one dir, and put cabal.project in that dir, but i'm not sure how that should work.
18:12:10 <argent0_> cheater: check the cabal github-repo's cabal.project file.
18:12:38 <cheater> this? https://github.com/haskell/cabal/blob/master/cabal.project
18:13:17 <solonarv> ls . # outputs = a/ b/ cabal.project ; cat cabal.project # outputs = packages: a/ b/
18:13:34 <solonarv> yes, that file is right
18:13:38 <cheater> ok, so let's say i do packages: a/ b/      how do i compile b then? what command do i use? if i try to use cabal it says no .cabal found
18:14:16 <ski> in Scheme systems, there's `with-input-from-file',`with-output-to-file',`with-input-from-string',`with-output-to-string', which, *locally*, redirects `current-input-port' and `current-output-port' from whatever they was before, to refer to a given file or string
18:14:16 <solonarv> ls a/ # -> a.cabal src/ ; ls b/ # -> b.cabal src/
18:14:48 <solonarv> so each of the packages needs a <pkgname>.cabal file which describes the package
18:15:14 <int-e> "if i try to use cabal" - how exactly?
18:15:31 <solonarv> then if you want to build one of these you say: cabal v2-build a ; or: cabal v2-build b
18:16:03 <solonarv> cabal.project describes a project; a project may contain multiple package
18:16:08 <cheater> why v2-build and not build or new-build?
18:16:14 <solonarv> each package is described by a pkgname.cabal file
18:16:34 <solonarv> v2-build and new-build are different names for the same thing
18:17:01 <solonarv> build alone currently refers to v1-build (aka old-build) which knows nothing about cabal.project and is Old And Bad
18:17:13 <cheater> alright
18:17:19 <cheater> thanks a lot solonarv that explains everything
18:17:34 <int-e> In cabal-install 2.4.1.0, build = v1-build, but the default will change with cabal-install 3.0, if I understand things correctly.
18:17:40 <solonarv> yup!
18:18:46 <cheater> hmm
18:18:54 <cheater> i still have cabal 2.2.0.0 installed
18:18:57 <cheater> for some reason :D
18:19:10 <cheater> that might be the problem, right?
18:19:31 <solonarv> that should also have the v2- commands, but they will be missing some features and maybe be buggier
18:19:45 <cheater> gotcha
18:19:47 <int-e> new-build should be fine, new-install still had some trouble in 2.2?
18:20:03 <solonarv> I would certainly recommend upgrading though, always a good idea
18:20:10 <cheater> 2.2.0.0 doesn't know v2-install, only new-install.
18:20:15 <cheater> yeah, i have just upgraded :)
18:25:03 <cheater> thanks for the help guys!
18:29:28 <cheater> solonarv: how do i build inside a sandbox?
18:29:34 <cheater> is new-build always inside a sandbox?
18:29:45 <Axman6> yes
18:30:02 <cheater> thank you
18:30:16 <int-e> not at all... it's using a per-user "store"
18:30:21 <cheater> ah
18:30:24 <cheater> ok
18:30:36 <cheater> can i build from a .project inside a sandbox?
18:30:45 <cheater> i don't want to use a per-user store :/
18:31:29 <int-e> meh I'm using sandboxes... so I manually use  cabal sandbox add-source a/ b/  if a/ b/ are the directories listed in cabal.project
18:31:43 <int-e> (err v1-sandbox to suppress a warning)
18:32:13 <int-e> it should also be possible to set up a local store, probably using cabal.local.config, but I have never done that.)
18:32:30 <cheater> hm.
18:32:39 <int-e> (there's a  store-dir  setting)
18:32:40 <cheater> ok, but then i don't need the cabal.project at all, right?
18:32:47 <cheater> does it even use the cabal.project at that case?
18:33:01 <int-e> right... for sandboxes you don't need a cabal.project.
18:33:03 <cheater> *in that case
18:33:07 <cheater> ugh
18:33:18 <cheater> ugh ugh
18:33:19 <int-e> the store-dir idea would be using v2-install and cabal.project.
18:33:21 <cheater> alright
18:33:34 <cheater> hmm ok
18:33:58 <int-e> (But as I said, I have not tested it yet.)
18:35:47 <cheater> https://cabal.readthedocs.io/en/latest/nix-local-build.html#cmdoption-store-dir
18:36:04 <cheater> there is a command-line option, but not a cabal.project option.
18:37:30 <turab> int-e: Was that "not at all..." for "new-build always inside a sandbox?"
18:39:58 <int-e> turab: yes
18:41:37 <int-e> cheater: okay, so I just put a store-dir: /home/.../lambdabot/.cabal-store  into a cabal.project.local file inside my lambdabot installation and it seems to be putting stuff into .cabal-store as desired.
18:42:15 <cheater> interesting
18:42:39 <cheater> so either the docs are old, or this shouldn't work, and it's a bug that it does
18:42:40 <int-e> (unfortunately it needs to be an absolute path)
18:43:17 <int-e> cheater: the docs explicitely note when an option can *not* be specified in a cabal.project file.
18:43:33 <int-e> explicitly (I'll never learn that spelling)
18:48:02 <int-e> it's not a complete sandbox replacement yet, because there's no 'cabal v1-exec' analogue. I can add symlink-bindir: .../.cabal-store/bin  so all executables can be found in one place. But that's only part of the story.
18:52:21 <cheater> hmm yes
18:52:25 <cheater> thanks int-e :)
18:52:34 <cheater> can you new-* inside a sandbox?
18:52:40 <cheater> or will that ignore the sandbox?
18:52:46 <int-e> afaiui it will ignore the sandbox
18:52:50 <cheater> gotcha
18:53:08 <int-e> (I'm pretty sure I've actually done that and it ignored the sandbox)
18:54:19 <int-e> wait... new-install only symlinks the binaries that I've installed explicitly?!
18:55:21 <maerwald> propellors on-host-compilation is highly unreliable. Is there a way to overwrite how it installs ghc?
20:11:34 <halogenandtoast> I learned the hard way that Control.Monad.Reader /= Control.Monad.Trans.Reader, even though they pretty much export all of the same stuff
20:12:02 <Axman6> does the latter not reexport the former?
20:12:13 <monochrom> Control.Monad.Reader re-exports some stuff of Control.Monad.Trans.Reader.
20:12:17 <monochrom> No.
20:12:34 <monochrom> Control.Monad.Reader adds the type class.
20:13:16 <monochrom> But the type class method will name-clash with a non-method function in Control.Monad.Trans.Reader. This is intentional.
20:27:24 <turab> halogenandtoast: How exactly did you discover? just curious :)
20:28:56 <halogenandtoast> turab: sadly I undid all my code changes and now forget exactly what error I was getting...
20:29:19 <halogenandtoast> turab: so the answer is my code wasn't working, and I just happened to try the other module and it worked
20:30:32 <turab> If you used any reader specific functions (ask, local etc), then Trans might need explicit lifts (depending on what your monad stack looks like)
20:31:35 <turab> I asked cus I was experimenting with both of them and realized that mtl was doing some of the work for me (mtl being the one that exports Control.Monad.Reader)
20:34:28 <halogenandtoast> Can anyone help me solve the mystery behind why I get this error: https://gist.github.com/halogenandtoast/73dd417c01af7a9237570af2d080f8ac
20:35:24 <halogenandtoast> Probably because the type is ConfigM (ScottyT TL.Text ConfigM ()), but not sure what to do since ScottyT is not a MonadTrans
20:41:12 <crestfallen> hi re: the minimax function , in the where clause on line 164 I'm not certain what is the value of ts. thanks for looking     https://github.com/varreli/haskell/blob/master/hutton/84_chapt11/ticTacToe.hs
20:41:56 <crestfallen> say we used the grid listed on line 133
20:43:24 <crestfallen> not sure how '  map minimax ( ... )  ' is working
20:43:39 <Axman6> ts's type must be a list to use map, so its type must be [_something_]. minimax has type Tree Grid -> Tree (Grid,Player) so that means ts must be [Tree Grid], and ts' must then be [Tree (Grid,Player)]
20:44:14 <Axman6> remember that Tree is defined as data Tree a = Node a [Tree a]
20:44:23 <crestfallen> Axman6, thanks ...
20:46:20 <crestfallen> I tried plugging in ' (gametree [[O,B,B],[X,X,O],[X,O,B]] O) '  and then it's results
20:46:24 <crestfallen> Axman6, 
20:46:33 <crestfallen> but kept getting errors
20:46:51 <halogenandtoast> Okay I figured out my issue
20:46:53 <Axman6> that doesn;t look like a Tree to me
20:47:05 <Axman6> mmaybe it is, one sec
20:47:33 <crestfallen> the results of (gametree ...) as well I tried
20:47:54 <Axman6> what does gametree [[O,B,B],[X,X,O],[X,O,B]] O give you?
20:49:18 <crestfallen> a tree of depth 3
20:49:42 <Axman6> what happens when you use minimax (gametree [[O,B,B],[X,X,O],[X,O,B]] O) then?
20:50:39 <crestfallen> yes I get the correct results, with a tuple for each node and leaf
20:51:01 <Axman6> ok... so what errors do you get? you said you got errors when you did that
20:52:04 <crestfallen> no when I tried to use map minimax ( ... ) alone is ghci, which is the full definition of ts'
20:52:13 <crestfallen> in*
20:52:27 <Axman6> remember that ts contains trees
20:52:49 <Axman6> Specifically ts is [Tree Grid]
20:53:09 <crestfallen> so that is where I'm confused
20:53:40 <crestfallen> since not sure what is being mapped over
21:00:43 <crestfallen> Axman6,  just changed the argument , using:      map minimax [(gametree [[O,O,B],[X,X,O],[X,O,B]] O)]
21:01:13 <Axman6> that basically just the same as using minimax (gametree [[O,O,B],[X,X,O],[X,O,B]] O) and wrapping it in a list
21:01:16 <crestfallen> thanks I assume that output is correct Axman6 
21:02:08 <crestfallen> so all map does is wrap the entire Tree Grid into a list Axman6   ?
21:02:20 <Axman6> :t map
21:02:22 <lambdabot> (a -> b) -> [a] -> [b]
21:02:35 <Axman6> it applies a given function to each element in a list
21:02:46 <Axman6> > map f [x,y,z]
21:02:49 <lambdabot>  error:
21:02:49 <lambdabot>      • Ambiguous type variable ‘b0’ arising from a use of ‘show_M688136781122...
21:02:49 <lambdabot>        prevents the constraint ‘(Show b0)’ from being solved.
21:02:58 <Axman6> > map f [x,y,z] :: [Expr]
21:03:03 <lambdabot>  [f x,f y,f z]
21:03:24 <crestfallen> one moment please
21:04:33 <crestfallen> Axman6,  so the output of the following is the value of ts'  right ?      map minimax [(gametree [[O,O,B],[X,X,O],[X,O,B]] O)]
21:04:54 <Axman6> no
21:05:36 <Axman6> gameTree returns a Tree Gris, in the first iteration when you call minimax (gametree [[O,O,B],[X,X,O],[X,O,B]] O), ts is whatever the list in that Node starts as, 
21:06:17 <Axman6> if you do this in GHCI, you'll see what ts': let Node _ignoredHead ts = (gametree [[O,O,B],[X,X,O],[X,O,B]] O) in map minimax ts -- this is what ts' is
21:07:46 <crestfallen> right it doesn't include the root node Axman6 
21:07:52 <Axman6> yes
21:08:18 <Axman6> you wanted to know what ts' was didn't you?
21:08:23 <crestfallen> excellent you rock Axman6   .. play that git fiddle ...
21:08:34 <crestfallen> thanks
21:08:34 <Axman6> =)
21:09:20 <crestfallen> so one thing. you used the constructor Node before ignoredHead
21:09:42 <Axman6> this is pattern matching on the result of the gametree call
21:10:10 <Axman6> you could also write: case (gametree [[O,O,B],[X,X,O],[X,O,B]] O) of Node _ignoredRoot ts -> map minimax ts
21:10:54 <int-e> cheater: https://paste.ubuntu.com/p/M7DhKrYrQw/ is my current sketch for sandbox-ish behavior with cabal's v2 commands. (modulo a cabal-install ticket)
21:11:36 <crestfallen> dang that's tricky. essentially Node has to stay out in its lonesome to indicate the root node
21:13:59 <crestfallen> Axman6, so in the let statement you used, map still wraps the full result including the root Node in a list.
21:19:25 <nullnullnull> Could not find module ‘Control.Concurrent.Async’
21:19:43 <nullnullnull> this error only showsup on macOS, but why?
21:21:25 <crestfallen> ok yeah there is one less set of brackets that makes sense thanks again Ax*man
21:29:20 <fragamus_> hey im seeing a lot of "the impossible happened"
21:29:33 <fragamus> me too
21:34:22 <c_wraith> nullnullnull: did you install the async package on that computer?
21:42:27 <nullnullnull> hmm
21:42:31 <nullnullnull> no i didnt 
21:42:39 <nullnullnull> but how comes, I mean
21:42:50 <nullnullnull> it should come with default installation I think
21:43:01 <nullnullnull> because this thing only happened with macOS
21:43:13 <nullnullnull> worked on Ubuntu and other linux dis
21:43:52 <nullnullnull> same thing with: "import Network" package
21:50:33 <MarcelineVQ> async and network don't come with ghc, you need to install them or have cabal/stack handle getting them for you by putting them as dependencies in your cabal file. They are included if you installed the full haskell platform but you should prefer to use a cabal file anyway.
21:51:14 <nullnullnull> cabal file?
21:52:01 <nullnullnull> sec , you mean that I didn't install haskell completely 
21:52:37 <MarcelineVQ> cabal file https://haskell-at-work.com/episodes/2018-05-13-introduction-to-cabal.html
21:53:41 <nullnullnull> is it like a package-manager?
21:54:47 <MarcelineVQ> I'd call it a project manager, it will get packages for you to build your project
21:55:24 <MarcelineVQ> You don't need anything more than ghc to write haskell programs, along with cabal. But if you had async and network on a different platform it may be that it was installed in a way that included them, such as https://www.haskell.org/downloads/
21:56:36 <nullnullnull> so ghc is a must-have and cabal is for installing more packages right?
21:58:46 <sarahzrf> nullnullnull: no, cabal is a project manager, it does like configuration and building and stuff
21:58:49 <MarcelineVQ> ghc is the compiler so it's a must have yes. I wouldn't think of cabal as being for installing more packages as much as I'd think of it as providing the packages my project needs.
21:58:59 <sarahzrf> this *can include* fetching dependencies
21:59:09 <sarahzrf> it's probably best not to think of it as a package manager
21:59:46 * slack1256 says something something about nix + cabal etc
22:00:25 <nullnullnull> ah, thanks guys ;)
22:00:33 <MarcelineVQ> slack1256: Best to offer solutions before problems ;>
22:00:55 <slack1256> UwU
22:01:30 <MarcelineVQ> as in: I have 2 problrms, I need to learn ghc and cabal. If you offer me nix I now have at least 3 problems.
22:01:53 <MarcelineVQ> Nothing wrong with nix, but the cup runeth over
22:02:10 <Cale> Yeah, it's really annoying how nix is really hard to recommend to beginners
22:02:31 <slack1256> yeah, I am in favor of always solving the smallest problem possible
22:02:41 <slack1256> it was more a joke that an actual recomendation
22:07:13 <Cale> As someone who has been using nix every day for the past few years and has only just really started to understand how everything works, I have to say, the common idiomatic ways of writing nix code really do a lot to subvert the benefits of using a pure functional programming language.
22:08:20 <Cale> The main thing which makes nix hard to work with is that it's nearly impossible to find anything in particular. Even the experts just grep the entirety of nixpkgs for various strings and hope, and usually fail a bunch.
22:09:27 <Cale> and the reason it's hard to find anything is that everything is defined as these "attrsets" (roughly Map) which have hundreds of things in them and are defined by crazy fixed points on top of crazy fixed points
22:10:10 <Cale> and there's no correspondence between the names or locations of files in the directory tree, and the names of anything in the nix code
22:10:49 <Cale> The main benefits of pure functional programming are that it lets you reason equationally and locally in terms of definitions of things in order to understand what they mean
22:11:13 <sarahzrf> there are more good gadgets than there are good conventions, perhaps?
22:11:21 <sarahzrf> in nix
22:12:00 <Cale> If you can't find the relevant definitions, all that goodness breaks down
22:12:13 <sarahzrf> ;_;
22:12:18 <Cale> (and/or if the definitions themselves are spread out over many files)
22:12:58 <slack1256> You usually get used to fixed points (because they are a really neat trick) and then you start seeing the pattern everywhere
22:13:27 <slack1256> plus you usually know where stuff is by repeated usage
22:13:28 <Cale> It's not that I'm not used to them, it's that I think they're harming the ability to reason about the meaning of the programs being written
22:14:26 <Cale> Instead of having clear definitions for each key in an attrset, you have this crazy implicit thing going on where everything is a function of the entire universe
22:14:59 <slack1256> you mean callPackage?
22:15:04 <Cale> yeah, basically
22:15:24 <slack1256> but the definitions themselves are very explicit on what they need
22:16:34 <Cale> By way of pattern matching attributes out of the package set, sure
22:16:49 <slack1256> it is a tradeoff, hackage package incorporate dependencies everyday, so you have to be liberal at call time on what you pass
22:17:32 <Cale> But like, think about how insane it would be if we wrote our Haskell programs as a giant DMap of functions which take the entire DMap of functions and promise to only look up certain keys
22:17:42 <Cale> It's crazy
22:18:05 <slack1256> I know certain haskell projects which define a central ADT which hold all the program information
22:18:17 <slack1256> and just pass it to all functions that have cross cutting concerns
22:18:30 <Cale> But usually not also all the functions and other stuff which acts on that
22:18:41 <slack1256> there is a tradeoff between specific and being practical
22:19:38 <Cale> If everything were just written as a straightforward functional program, we could just read the code to understand how things were being built
22:19:57 <slack1256> yeah not usually all the functions, but that is because fundamentally nixpkgs doesn't control the complexity it recieves, it tries to provide a common way to acess it.
22:21:42 <Cale> also, I really want to start trying to impose some correspondence between directory structure and the attrsets we're building - if not in nixpkgs, then at least I can impose some structure on reflex-platform at some point
22:22:26 <slack1256> BTW reading you commend on the DMap, yeah haskellPackages should only contain packages, not this extra functions on the same tree.
22:24:03 <Cale> One of the things I want to do is write a better library of nix functions which do all the basic data structure manipulation stuff, and which builds itself up from builtins and nothing else, just so that I don't have to feel gross about taking nixpkgs as an argument.
22:25:23 <Cale> (and also because the library which is there often isn't quite how I'd like it to be)
22:27:13 <Cale> reflex-platform would ideally just consist of a handful of top-level directories for the different platforms we support, and each of those would just contain a whole bunch of subdirectories, one per package, which would mostly be thunks, maybe some pointers to Hackage etc.
22:28:16 <Cale> and then we'd build an attrset by using builtins.readDir and importing what we find, enforcing a correspondence between the directory tree and the attrset
22:29:11 <Cale> Instead, what we've got right now is... pretty hard to actually understand.
22:31:37 <Cale> (that'd still involve the fixed point, but at least you could figure out where each package was coming from)
22:32:25 <Cale> instead of the rats' nest of overlays :D
23:46:50 <maerwald> has anyone used cabal-cache? Does it only cache dependencies or also the package itself?
