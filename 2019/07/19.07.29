01:37:52 <libertyprime> could someone help me write a wee bit of haskell? i just need a function which takes a Data.Text, puts it through a given Text -> Text function and returns the result, but no final newline if there was was no final newline to begin with, and ensure final newline if originally there was a final newline
01:38:16 <ddk> hello all
01:38:52 * jgt waves
01:39:01 <ddk> I am having issues when trying to use distributed-process library with stack, can someone help me please ?
01:39:55 <ddk> distributed-process needed, but the stack configuration has no specified version                         (latest matching version is 0.7.4)    distributed-process-simplelocalnet needed, but the stack configuration has no                                       specified version  (latest matching version                                       is 0.2.4)
01:39:56 <ddk>     network-transport-tcp needed, but the stack configuration has no specified                          version  (latest matching version is 0.6.0)
01:40:24 <jgt> ddk: sounds like you need to add that package to extra-deps, no?
01:40:40 <ddk> I saw the LTS and the recent version does not contains distributed-process library
01:41:41 <ddk> I added this and then some packages are prompted to be added and finally it say it can not build it have to change the base version to work
01:42:12 <ddk> :jgt
01:44:55 <jgt> I'm not sure exactly how to help; I don't use Stack
01:45:28 <jgt> maybe you should try using an older LTS which has that package?
01:46:32 <ddk> :jgt yes that worked but with GHC 8.2.2 in that way I loose the advancement in GHC
01:46:54 <ddk> would cabal would be of any help here ?\
01:47:12 <int-e> trying with cabal-install it appears that distributed-process doesn't work with ghc-8.6.5; ghc-8.4.3 seems fine.
01:48:18 <jgt> all my stuff is pretty happily running on 8.4.3
01:48:22 <int-e> (I'm using --dry-run so all I can say that cabal-install finds an install plan with ghc-8.4.3)
01:48:24 <jackdk> libertyprime: sounds like homework. what subproblems do you see?
01:54:17 <libertyprime> jackdk: i have a filter-selector in emacs. it gets a list of shell commands used for filtering text from a file and lets me select them. trouble with them is that many commands operate linewise and lose the info about final newline in the process
01:54:31 <libertyprime> but id rather not do all my string processing in bash, or even python. trying to transition to haskell
01:54:43 <ddk> :jgt I used lts 12.6 for ghc 8.4.3 but not worked
01:55:24 <jgt> ddk: sorry, wish I could help further :-/
01:55:43 <jackdk> libertyprime: ah. makes sense. I see the following subproblems: detect final newline (Text -> Bool), apply function, ensure final newline (Text -> Text), ensure no final newline (Text -> Text)
01:56:04 <ddk> jet: can you tell the way I should proceed except from changing its version ?
01:57:32 <libertyprime> jackdk: hmm breaking down into subproblems is genuinely helpful. need to train myself to think in haskell
01:58:17 <jackdk> libertyprime: genuinely helpful in more fields than just haskell :-)
01:59:09 <Entroacceptor> And a fine way to madness.
01:59:27 <ddk> jgt: can you tell the way I should proceed except from changing its version ?
01:59:48 <ddk> :jgt LTS versions
01:59:52 <Entroacceptor> Why isn't this pile of paper a Functor? I want to map over it!
02:00:11 <jgt> ddk: in my case when I face this problem with Nix, I try jailbreaking some packages, or forking them and fixing some things
02:00:25 <jgt> ddk: but I don't think my advice here is useful to you
02:00:32 <jgt> ddk: as I said, I'm not using Stack
02:00:57 <jgt> not that I don't like it or I think it's bad or anything — I just use Nix for everything
02:01:04 <jneira> ddk: what about translate the install-plan of cabal to extra-deps in stack?
02:01:14 <ddk> :jgt I got it, Thanks 
02:01:47 <ddk> :jneira that also not worked stack solver failed.
02:02:11 <juri_> I just wrote about 50 lines of bad haskell (it works, but the style is terrible). https://github.com/colah/ImplicitCAD/commit/d86398013d09f8ba8f4335afd5053a2cd4cbdc8b . Can i get a review on how to make that look less terrible?
02:03:20 <jneira> ddk: i usually let cabal find the plan with `cabal new-build -w ghc-x.y.z` and then use the versions pinned in `dist-newstyle/cache/plan.json` as extra-deps in stack, using the correlated lts for ghc-x.y.z
02:03:51 <jgt> juri_: I like the spirit of trying to be explicit about where your standard library functions come from, but that'd drive me mad in practice
02:04:02 <dcoutts> jneira: you might find using cabal new-freeze makes that workflow a bit easier
02:04:15 <jgt> juri_: I would just stick a NoImplicitPrelude pragma at the top, and import ClassyPrelude
02:05:40 <jgt> juri_: for complicated looking things like `([OVal] -> ArgParser (IO [OVal]))`, I would write a type alias
02:05:41 <jneira> dcoutts: yeah, i forgot about cabal freeze, it's easier that way
02:06:16 <jackdk> juri_: I don't bother manually importing from Prelude or Control.Lens.Operators (if there's <<%= in your code, you know where it comes from). If there's a single major driving module for a thing (like, say, Reflex or Servant), I will usually allow myself an unqualified import there too
02:06:52 <jgt> juri_: in this construct:
02:06:54 <jgt>         hasDefault = case defval of
02:06:56 <jgt>           Just _  -> True
02:06:58 <jgt>           Nothing -> False
02:07:10 <jgt> why not `let hasDefault = isJust defval`
02:07:21 * juri_ nods.
02:07:28 <juri_> good stuff, keep it coming. :)
02:07:55 <sicklorkin> juri_: I find expectT particularily useful in tehse cases
02:08:06 <jgt> juri_: I think hlint would catch a lot here. Trying running that first.
02:08:28 <jgt> also I'd ditch the blank lines between imports, and run stylish-haskell on everything
02:10:31 <fog> that just cleans the imports and language pragmas right?
02:10:43 <juri_> ok, i now have much more reading to do. thanks. :)
02:11:24 <jgt> fog: it'll also do some operator alignment
02:11:35 <fog> but no code refactoring? 
02:11:45 <jgt> no
02:12:16 <fog> the name kind of gives the impression it might cannonicalise the whole style
02:12:42 <jgt> that's a fair point, but in this case it is one of the more conservative formatting tools
02:12:59 <jgt> in general, I disagree with automatic formatting and/or refactoring
02:13:15 <jgt> and any automatic formatting should be _really_ conservative
02:13:21 <fog> because there is no generally accepted best style?
02:13:28 <jgt> e.g. elm-format is just _wrong_
02:13:43 <jgt> fog: because the shape of code is never that uniform
02:13:53 <jgt> most of it is pretty uniform
02:14:06 <fog> it would be good at least to have a way to check if two functions *could* be formated into the same implementation
02:14:13 <fog> or is that something different
02:14:19 <jgt> but then you'll get some idea somewhere in a file which is far better formatted manually, and an aggressive formatter will completely fuck it
02:14:27 <jgt> fog: that's different
02:14:50 <jgt> changing implementation I'd call a "refactoring"
02:14:59 <jgt> and hlint _suggests_ refactorings, which is great
02:15:04 <fog> oh and this is just reformating, ok
02:16:19 <fog> wow, hlint looks pretty powerful. does it do some kind of compilation?
02:16:31 <fog> to determine possible refactorings 
02:17:39 <sicklorkin> fog: https://hackage.haskell.org/package/hlint
02:17:57 <jgt> it doesn't compile your project, no
02:17:59 <sicklorkin> You should understand the bugs and limitations 
02:18:29 <sicklorkin> fog: you can't always trust it to do the right thing.
02:19:06 <fog> yeah, it mentions something about needing to be checked to see if extra annotations are required
02:19:16 <fog> types*
02:19:50 <sicklorkin> ti doesn't know anything about fixity outside of the base operators too..
02:20:00 <fog> so there was an idea for a linear algebra project this could maybe help with, can I describe? 
02:20:11 <jgt> sicklorkin: I agree with you, and I would go even further and say that you can't trust almost any automatic formatter to do the right thing
02:20:49 <jgt> I've run into fixity issues with hlint and persistent, but luckily hlint allows you to configure this
02:21:09 <fog> jgt: its actually pretty amazing it could work at all! wouldnt it need unit tests to check it didnt break anything, or can it be sure to function the same after reformating?
02:22:01 <fog> (thats all was meant by "compiling", like, does it compare the core or something?)
02:22:02 <sicklorkin> fog: you may also want to consider hie
02:22:17 <sicklorkin> fog:  I thihnk it uses some kinda grammar 
02:23:08 <fog> an ide generation tool?
02:23:32 <sicklorkin> yeah it uses LSP which does compile
02:24:13 <fog> this? https://github.com/alanz/haskell-lsp
02:24:23 <fog> "Microsoft Language Server Protocol"
02:25:25 <sicklorkin> yes, that's correct. Lang. Server Protocol'
02:25:45 <fog> how does that compile>
02:25:45 <sicklorkin> https://github.com/haskell/haskell-ide-engine/
02:27:00 <sicklorkin> fog: Neil Mitchell did a nice write-up on this https://neilmitchell.blogspot.com/2019/07/thoughts-for-haskell-ide.html
02:27:25 <fog> yeah, the lsp.md says; To see this library in use you need to install the haskell-ide-engine This will put the hie executable in your path.
02:28:57 <comerijn> LSP doesn't compile anything, LSP is an attempt to get rid of the n^2 editor-tooling integration problem (and generally a pretty great idea, IMO)
02:29:06 <comerijn> Although support isn't great yet
02:29:43 <fog> ok so its an ide, so it should be able to do partial compilation to see whats in scope for giving suggestions when you hover the cursor over the function, and your saying thats got something to do with this lsp thing somehow 
02:30:30 <fog> whats the n^2 from?
02:30:31 <comerijn> fog: https://langserver.org/
02:31:04 <Taneb> fog: you have n languages, and m editors. Without using something like LSP, you need to write n*m plugins
02:31:10 <Taneb> With LSP you need to write n+m
02:31:48 <fog> oh it autogenerates links to where code is and does autocomplete too, thats nice
02:32:36 <fog> taneb: ah, by being a "standard protocol" so everything goes to and from this central thing, ok
02:32:47 <jgt> fog: hlint _can_ break stuff, which is why I only allow it to suggest refactorings, but not naively automatically apply them everywhere
02:33:17 <fog> well the tool needed was just to compare 2 implementations
02:33:31 <jgt> I use hlint quite a lot, but I _also_ use hspec and version control
02:33:36 <fog> eg, if gathering code from old projects where the same function had been implemented several different ways
02:34:55 <fog> the ultimate version would just need user input as to how to modularise these librarys of gathered functions, or maybe it could use a ven diagram of where the functions were gathered from
02:36:47 <fog> jgt: isnt it also a good idea to use haxl with quickcheck?
02:37:03 <fog> to make reproducable tests from real world applications (or something)
02:37:41 <jgt> fog: I don't know the relation between haxl and quickcheck
02:37:45 <fog> like, if your code breaks while working on a real world IO problem it will have logged the data interactions so that it is reproducable
02:38:07 <jgt> fog: that sounds very sensible, but I don't have experience with it
02:38:07 <fog> i guess the difference is that quickcheck generates the test data algoritmically
02:38:35 <jgt> in general, I believe it's a good strategy to blast as many correctness tools at your code as is financially feasible
02:38:46 <fog> its neat, it abstracts over the data aquisition. there might be a good idea for the opposite, to abstract over the data logging
02:39:06 <fog> (it just dumps everything as a haskell file) 
02:39:31 <fog> like, to use deriving-generic and binary read or other ideas
02:39:46 <jgt> I did watch Marlow's haxl talk, but I haven't managed to use the library yet
02:40:01 <fog> yeah, it uses typable
02:40:30 <fog> which is a problem for use, because of this style of backend. if it just needed a binary instance it might be more user friendly 
02:41:34 <fog> and possibly produce more concise logs, which could be helpful for eg. recovering a crashed server
02:44:35 <fog> oh there is deriving typeble, nvm
02:44:45 <fog> typeable 
02:45:45 <fog> so can ill describe the idea for a linear algebra midway api, just incase anyone has any suggestions 
02:46:37 <fog> basically, there are some blas, or basic linear algebra subroutines. and there are numberous implementations - so it would be a good idea to provide a midway api
02:47:19 <fog> if you want to get repa to do the matrix multiplication for example, but provide you own implementation of approximate matrix inversion 
02:47:57 <fog> then working within the midway api, you just call eg dot, without worrying about which backend was used to provide this
02:48:23 <fog> which would split the development onto two sides, of packages using blas, and packages providing them
02:48:48 <fog> and possibly some confusion to do with providing a backend that used a different backend....
02:48:53 <fog> does that make sense?
02:50:49 <fog> then you could easily convert existing algorithms written using blas to eg a parallel implementation, just by swapping the backend
02:53:29 <fog> im not sure if there is a standard to follow in designing such a thing, like, which functions it should handle, but just starting with obvious things like matrix factorisation etc and then adding things for different use cases... or possibly, starting with a few fairly involved algorithms that make heavy use of a diverse number of blas and working 
02:53:29 <fog> from there
02:54:11 <fog> maybe there is some way to make a least sufficient version for any particular application, but that seems to be a different idea
02:55:27 <fog> like, maybe the reason this doesnt exist yet is that such a standard is difficult to determine, eg. copying everything from cublas might be overkill - and then different backends would struggle to implement the standard...
02:57:19 <fog> i would prefer to be able to use a possibly incomplete blas midway api with switchable backends than to not have such a thing just through fears about if it would be "complete" enough, or going overboard 
03:01:25 <fog> maybe then the real heart of the problem is this idea of developing "midway api's". so eg, someone could just make a midway for matrix multiplication, and then another package could have more specialist things like various diagonlisation routines... the idea would be that they could both be used together and hooked up to the same backend at the sam
03:01:25 <fog> e time, like one library that was distributed over several packages and somehow worked cohesively by following some standard or something
03:34:07 <sicklorkin> is there a language extension for using {..} to update records? 
03:34:31 <sicklorkin> like RecordWildCards but for updates
03:48:42 <__monty__> sicklorkin: Record updates are part of the standard syntax, record {updatedKey = newvalue}.
03:49:44 <sicklorkin> __monty__: Right.. but I want to say; let fooField = 1 in foo { .. } 
03:50:21 <sicklorkin> whree data Foo  = Foo { fooField :: Int }
03:51:39 <comerijn> sicklorkin: RecordWildCards let you do that
03:51:57 <sicklorkin> You can do let Foo {fooField=_,..} ; fooField = 1 in Foo{..}
03:52:18 <comerijn> sicklorkin: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/ingest-src/Parsers.hs#L77-L85
03:52:24 <comerijn> Literally exactly what you wanted :p
03:52:28 <sicklorkin> but you cannot do `let foo = Foo 1 ; fooField = 2 in foo {..}
03:52:38 <comerijn> ah, for updates
03:52:52 <comerijn> I suppose you could do that with creative shadowing?
03:53:01 <sicklorkin> comerijn: see above
03:53:03 <comerijn> % :seti -XRecordWildCards
03:53:04 <yahb> comerijn: 
03:53:30 <sicklorkin> comerijn: I tihink i've covered all the alterantives
03:53:44 <comerijn> sicklorkin: I think I missed those :)
03:54:26 <sicklorkin> i'm sure thre's a good reason this didn't apply to updates
03:54:45 <sicklorkin> but it's not obvious to me
04:11:26 <sicklorkin> How difficult would it be to add a compiler warning for missing explicit fixity for infix functions/operators.. 
04:11:41 <sicklorkin> > let add = (+)
04:11:44 <lambdabot>  <no location info>: error: not an expression: ‘let add = (+)’
04:11:58 <sicklorkin> > define add = (+)
04:12:01 <lambdabot>  <hint>:1:12: error:
04:12:01 <lambdabot>      parse error on input ‘=’
04:12:01 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
04:12:11 <sicklorkin> > define let add = (+)
04:12:14 <lambdabot>  <hint>:1:21: error:
04:12:14 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
04:15:20 <comerijn> sicklorkin: Probably not too hard?
04:19:39 <sicklorkin> Okay.. havn't looked at uch of the source so i'll be a good project for me, even if it leads me nowhere..
04:19:56 <sicklorkin> s/i'll/it'll/
04:20:19 <fog> did anyone get a chance to think about how to do something like abstracting lazy and strict bytestrings to be a midware layer to different backends?
04:20:30 <comerijn> fog: Backpack? ;)
04:20:45 <comerijn> fog: http://blog.ezyang.com/category/haskell/backpack/
04:21:09 <fog> how does that work?
04:22:46 <fog> thought the problem could be thought of in terms of classes of classes which is what it seems to result in...
04:24:01 <fog> eg. for binary; you would just have all the function names that the package provides, and their types. but the types would be different between the modules - so the type signatures would end up being just constrained variables where there used to be type synonyms
04:24:10 <fog> with all the types having been promoted to classes
04:24:39 <fog> eg. for the linear algebra version, where a function might have mentioned a matrix or a vector, now it is Matrix m => ... m
04:24:41 <comerijn> fog: backpack literally provides abstract module signatures that can be instantiated with different types :) See ezyang's blogposts on it
04:25:00 <fog> is it extensible?
04:25:10 <comerijn> extensible how?
04:25:22 <fog> like can we have plugins or toolboxes to extend the basic interface
04:25:36 <comerijn> I don't know what you mean by that
04:25:53 <fog> like, a sparse approximation package to add onto the basic linear algebra routines 
04:26:08 <fog> basically so that a backend wouldnt have to implement every possible toolbox
04:26:36 <fog> or so that, every "addon" would be written just in terms of the most fundamental operations 
04:26:56 <comerijn> You'll have to read up on it and judge whether it's flexible enough for your needs
04:26:57 <fog> like how haskell is basically just midware to some few opperations written in C
04:27:16 <fog> i didnt know if this idea of midware was an existing concept or not
04:27:30 <fog> the basic demand is that it can be able to swap the backend
04:29:35 <fog> comerijn: you didnt like a straitforward way to determine the functionality of the tool you endorse... depending on which of those blog posts i click, i will get a different info. such a stochastic learning process is no good. i will google it instead, to make use of their AI
04:31:46 <fog> oh ok, documentation is pretty bad for this project
04:31:56 <fog> in which case, could you describe it a little better?
04:32:10 <fog> link*
04:34:18 <fog> or, if you know how to use it, is there the chance we can work here on an implementation of an example to link a small module providing matrix multiplication to serve as a template for a larger linear algebra module
04:34:28 <__monty__> fog: Could you put in some more effort? The link merijn gave you has plenty of explanations of backpack.
04:34:51 <fog> im reading the paper now, but a simple explanation is still nice
04:35:58 <fog> if it does exactly what i described previously then that is fortuitous, but if its a case of learning how to use a tool that might not be the correct tool, that would be a waste of time, so expert opinion of if it matches the required thing would be helpful
04:36:47 <fog> obviously the fact it was suggested at all is such an indication, but its absolutely the least possible  
04:37:40 <fog> at the moment im basically having to do a literature review just to determine if this is even something i should be interested in
04:40:28 <fog> here is a better link; https://plv.mpi-sws.org/backpack/
04:41:49 <fog> it links this paper; https://plv.mpi-sws.org/backpack/backpack-paper.pdf
04:41:52 <sicklorkin> does anyone have a link to the reverse depenancies search?
04:42:14 <sicklorkin> I'm curious to know what the adoption rate is for backpack so far? 
04:42:19 <fog> also on the blog there was a "deep learning" thing which describes basically the linear algebra stuff for tensors
04:42:25 <fog> but it used python
04:42:39 <cocreature> sicklorkin: https://packdeps.haskellers.com/reverse
04:43:01 <sicklorkin> cocreature: tnx!
04:43:37 <sicklorkin> nichts
04:44:40 <fog> and then there is this; https://hackage.haskell.org/package/hasktorch-signatures-types
04:45:22 <fog> urgh this sucks
04:52:34 <__monty__> sicklorkin: That doesn't work though, backpack's not just some package you depend on?
05:00:31 <fog> ok, so it seems like backpack works via the cabal file
05:00:32 <fog> https://github.com/haskell-backpack/backpack-str/tree/master/str-sig
05:01:13 <fog> another example here seems to use the FFI for the backend;
05:01:14 <fog> https://hackage.haskell.org/package/hasktorch
05:02:42 <fog> maybe thats how they avoid having to promote modules to classes, which would break at classes of classes
05:04:19 <fog> so then the previous proposal seems to amount to something like making a "sig" around the most basic linear algebra functionality of repa
05:04:58 <sicklorkin> __monty__: yes.. that's right.. i was curious about the ghc-backpack package I thought I read, turns out the font kerning made it look like that, but it was ghc --backpack.. so there are a number of packages alrady using backpack..
05:05:05 <fog> possibly then the "torch" C dependencies could serve as a backend for this
05:06:04 <sicklorkin> fog: what are you trying to acheive in this commentary? i'm having trouble following you.
05:07:49 <fog> well i described something i was calling a midware api, which it was suggested that backpack provides an interface for. i was wondering if the naive ideas about trying to use classes for this is something backpack managed
05:08:23 <fog> the conclusion is that yes, backpack seems to do this, and so then the move is to trying to propose the design for a linear algebra package based on backpack
05:08:59 <fog> where example backends include repa and a subset of the torch functionality backpack already wraps in the hasktorch package
05:09:52 <sicklorkin> fog: https://github.com/danidiaz/streamy/blob/master/streamy-bytes-sig/sig/Streamy/Bytes.hsig
05:10:16 <fog> also this concept seems relavent; "Partial" implementation packages at; https://github.com/haskell-backpack/backpack-str
05:11:07 <fog> which seems to be the opposite of what i was saying about making a backpack sig over just a subset of the backends functionality
05:11:33 <fog> which is a start at talking about the ideas of "extensibility" mentioned above
05:13:57 <fog> sicklorkin: nice! i like how it starts with signature instead of module
05:15:15 <fog> so whats the overall workflow like? seems like at least one complete backend to a signature should be provided
05:15:28 <fog> but then, why not do this for every module?
05:15:58 <fog> is it like a header file in c?
05:16:25 <__monty__> It's a lot like header files from what I understand about either.
05:16:52 <fog> this is awesome
05:17:19 <fog> i wonder about how this extensibility idea works now
05:18:09 <sicklorkin> multiple platform?
05:19:57 <fog> hmm, no, just adding extra modules
05:21:17 <fog> eg if you have like, Data.LinearAlgebra.Basic and you want to define Data.LinearAlgebra.Complicated where this imports the Basic version, and then you would want to "swap out the backend" for both simultaniously
05:21:58 <fog> where obviously, by using the functions of the Basic module, it does something like this already
05:22:11 <sicklorkin> i cannot answer that.. but you can look at the basic stuff
05:23:04 <fog> it just seems complicated because then its the implementation of the backend of the Complicated module which uses implementations provided by the Basic module
05:23:53 <fog> it would be great to get a least sufficient example together to show this
05:25:36 <Athas> Are the status updates for Summer of Haskell collected anywhere?
05:25:40 <sicklorkin> fog: https://gitlab.haskell.org/ghc/ghc/wikis/backpack lists several packages using it already. i would hover towards coda and unpacked-containers
06:39:17 <tchakka> Is there any kind of big-O-like notation/calculus that allows you to also express lazyness?
06:39:33 <comerijn> Not really, I think?
06:39:54 <literall1Crevice> There's this weird issue. I'm doing `import Control.Exception (catch, SomeException)` but I'm unable to use SomeException in my code, and GHC suggests I add it to the import list of Control.Exception. What am I missing here?
06:39:55 <comerijn> We don't even have a big-O notation for imperative languages on real hardware, so...
06:40:13 <comerijn> literall1Crevice: You only imported the SomeException type, not it's constructor
06:40:14 <tchakka> As in: `let (pre,post) = span someProperty list`, here, evaluating post will take O(pre). But evaluating pre takes O(n) in the furthest element of pre you need.
06:40:48 <literall1Crevice> comerijn: Got it now, thanks!
06:40:54 <comerijn> literall1Crevice: If we have "data Foo = Bar | Baz" then "import FooModule (Foo)" only imports Foo (the type)
06:41:27 <comerijn> literall1Crevice: You need to do "import FooModule (Foo(Bar))" (imports the type and Bar constructor) or "import FooModule (Foo(..))" (imports the Foo type and all constructors)
06:41:40 <literall1Crevice> Yeah, I did SomeException(SomeException) and that solved it
06:45:33 <c_wraith> tchakka: I like to talk about big-O for producing constructors.
06:45:51 <c_wraith> tchakka: since those are the concrete stopping points for lazy evaluation
06:55:53 <tchakka> c_wraith: So... functions like span would be O(1), since it immediately produces a tuple-constructor?
06:56:34 <c_wraith> well, when there are interesting details, I like to include all of them.
06:56:40 <tchakka> *nod*
06:57:18 <tchakka> Ideally you'd be able to write stuff like "evaluating these parts of the output requires evaluating such parts of the input". In some composable way.
06:57:41 <c_wraith> also, span doesn't return the (,) constructor immediately.
06:58:12 <c_wraith> if https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.List.html#span is to be trusted
06:59:00 <c_wraith> though I would still call it O(1) to get that constructor back, it's interesting that it could be lazier about it
06:59:18 <tchakka> Oh, right.
07:00:22 <tchakka> Yeah, I tested the (`seq` ())-thing with (span (==1) (repeat 1)) and (span (==2) (repeat 1)), and both came back immediately.
07:01:50 <tchakka> (testing with fst would also return immedately, testing with snd returns immediately in the (==2) case, and hang in the (==1) case, as expected)
07:02:20 <c_wraith> anyway, yeah..  I'd say the (,) constructor is O(1), the first list it return is O(1) per constructor, and the second list is O(n) for the first constructor, then does no work for remaining elements
07:03:08 <c_wraith> > seq (span even undefined) ()
07:03:11 <lambdabot>  *Exception: Prelude.undefined
07:03:27 <c_wraith> span could be written such that that is ()
07:03:39 <c_wraith> but it would be a lot more awkward to write
07:04:33 <tchakka> Heh, *nod*.
07:05:06 <tchakka> Not sure if worth it.
07:05:14 <c_wraith> probably not.
07:05:48 <infinisil> How about using the normal form for expressing complexity?
07:06:30 <c_wraith> infinisil: sometimes the details that throws out matter
07:07:08 <c_wraith> infinisil: like any time your algorithm is always going to produce an infinite data structure.
07:08:17 <infinisil> Yeah, so I guess it's like an upper bound of complexity
07:08:45 <infinisil> Because you can't evaluate it more than normal form
07:09:27 <infinisil> While WHNF is a lower bound in a way?
07:10:06 <c_wraith> yes, that's some sense of a lower bound
07:10:30 <tchakka> > let lazify ~(a,b) = (a,b) in seq (lazify $ span even undefined) ()
07:10:33 <lambdabot>  ()
07:14:05 <c_wraith> though the word "bound" there might be misleading.  Usually a "lower bound" is an estimate.  It describes constraints in the estimation space.  This is more of a description of constraints in the evaluation space.  The phrasing might confuse people a bit.
07:52:09 <duncan> I'm playing around with Haddock. I've got a library where I have only one exposed module. This module imports various other ones, which I. defined the documentation in.
07:53:04 <duncan> I've got various datatypes I;'ve written documentation for. However, it doesn't generate documentation for the different type declaraitons within the datatype.
07:53:24 <duncan> For instance I've got something like data A = B | C where I've written documentation for B and C constructors.
07:54:01 <duncan> It would generate them when the module where they are defined was marked as exposed.
07:54:26 <duncan> Is there some kind of 'trick' to this?
08:07:18 <comerijn> My 01-index.tar got corrupted, how do I get cabal to fetch a new one from scratch? v2-update doesn't seem to work...
08:07:19 <duncan> As best I can tell, my problem is with re-exported modules https://github.com/haskell/haddock/issues/563
08:07:32 <comerijn> I'd prefer to not nuke my entire ~/.cabal and rebuild everything >.<
08:09:00 <dcoutts> comerijn: try just ~/.cabal/packages/hackage.haskell.org/01-*  but if you need more, also ~/.cabal/packages/hackage.haskell.org/*.json
08:09:47 <comerijn> dcoutts: I already tried the first because that fixed things in the past, but now it crashes on being unable to set the modification time on 01-index.tar :\
08:09:53 <comerijn> I'll try nuking the .json too
08:10:21 <comerijn> Ah, now it seems to redownload
08:15:21 <duncan> If I don't specify anything in the import list for the module I'm re-exporting, it builds the documentation as desired
08:33:27 <sicklorkin> duncan: i'm just look at the docs and was wondering if you had tried adding module attributes? specifically ignore-exports
08:41:07 <duncan> sicklorkin: The problem is that I hadn't put (..) after my various datatype imports..
08:43:00 <duncan> I'm not sure how to handle large numbers of imports. Presumably Template-haskell could help :/
08:52:24 <sicklorkin> duncan: https://github.com/brendanhay/gogol/tree/develop/gen does this
08:52:39 <sicklorkin> src/Gen
08:53:25 <c_wraith> duncan, TH can't generate imports.
08:54:29 <c_wraith> (staging issue - it runs after names are resolved. it can't add new ways to resolve names)
09:02:00 <duncan> Ah right, thanks.
09:02:17 <duncan> I decided just to split the module in two instead
09:37:50 <gentauro> hey, anybody know how to get rid of " Probable fix: add INLINABLE pragma on" warnings?
09:38:11 <gentauro> I mean, I get it when using the `tls` package ...
09:38:27 <gentauro> `Could not specialise imported function `tls-1.4.1:Network.TLS.Core.$wsendData'`
09:39:08 <gentauro> I guess there is pretty much nothing I can do with that package ... or does the compiler expect me to just make an inlined "wrapper" funtion calling that method?
09:46:12 <dminuoso> gentauro: Sort of the opposite.
09:49:02 <dminuoso> gentauro: The GHC manual explains why -Wmissed-specialisations emits that warning pretty well.
09:58:06 <dminuoso> gentauro: https://wiki.haskell.org/Inlining_and_Specialisation this also covers some of the details. If you make an INLINABLE wrapper function, it would specialise/inline that wrapper - but it'd fail to work on the actual sendData function (which would be left unspecialised)
09:59:39 <gentauro> dminuoso: so there is nothing I can do really? Unless I download the code and add the PRAGMA to the function?
10:01:29 <dminuoso> gentauro: Perhaps you could compile tls with -fexpose-all-unfoldings?
10:02:05 <dminuoso> (And then compiling your source module with ⌜-fspecialise-aggressively⌝ but reading the wiki article it suggests changing the ⌜tls⌝ package is the safer option.
10:07:04 <gentauro> dminuoso: that compiler flag didn't do anything (still the same compiling output)
10:12:06 <asheshambasta> If one is using Stack with a dependency from private Git repository (remote); is there a way to make Stack use ssh-agent to not prompt me for the RSA key passphrase? 
10:13:09 <asheshambasta> This is not the case by default, at least not on my setup on nixos. 
10:14:07 <asheshambasta> and I cannot really see anything addressing this online 
10:15:08 <asheshambasta> Also, it seems like with ghcid, it just seems to hang during the build phase without ever prompting me for the passphrase at all. 
10:18:52 <asheshambasta> https://gist.github.com/asheshambasta/a8f61687e26e5b551551c04381173727#file-shell-stack-nix-L7 -- this seems to be the reason; so I'm using a specialised git as a dependency; which is probably from my system git.
10:33:48 <argent0> asheshambasta: (idk, you should enable public key authentication in the server(and disable password logins which are unsafe)) https://wiki.archlinux.org/index.php/OpenSSH#Force_public_key_authentication
10:41:05 <justsomeguy> asheshambasta: You can create a new user to run that project as, run a login-scrip that does ssh-add $keyfiles, and retrieves the passphrase for the keyfile from your keychain.
10:42:15 <justsomeguy> asheshambasta: I'm assuming you're already using key files, and the passphrase it to unlock it. As opposed to using the destination users password as a login credential.
11:01:46 <gentauro> dminuoso: by disabling the following flag `- -Wall-missed-specialisations`, all the noize went away ...
11:37:04 <nil> hi, why do we have  getArgs :: IO [String]  and not  main :: [String] -> IO ()  ?
11:38:10 <nil> i suppose you can write  main = getArgs >>= main'  and then use  main' :: [String] -> IO ()  , but why isn't this the default?
11:38:21 <nil> is there anything gained by not passing argv to main?
11:38:39 <boj> does it really matter?
11:38:39 <lavalike> maybe to avoid having to `const $` or `main _ =` most mains that don't use them
11:38:46 <nil> boj: nah
11:39:00 <EvanR> besides hysterical raisins, it does mirror the fact that programs are IO actions and not functions
11:39:04 <nil> lavalike: fair
11:39:21 <Rembane> It could be something about it in the Haksell report
11:39:27 <nil> EvanR: i guess that would make "main" an IO "reaction"
11:39:33 <lavalike> heh
11:40:03 <koala_man> nil: should getArgs then be removed and it would be up to you to pass the string array around to whatever needs it?
11:40:11 <koala_man> s/array/list/
11:40:20 <nil> koala_man: i guess that's a fair point too.
11:40:40 <EvanR> there entire runtime environment, including but not limited to ENVVARS could also be passed in
11:40:40 <lavalike> oh yeah more composable too, in places that aren't main, that's a good point
11:40:44 <EvanR> anything thats a reader-like thing
11:41:07 <jle`> nil: also it's a bit weird because arguments can be dynamically modified at runtime i think
11:41:37 <MarcelineVQ> lavalike's reason is the one I'd pick. not every program cares about args so why force every program to deal with it
11:42:20 <nil> those are all excellent raisins, i am satisfied
12:03:54 <arianvp> Ok so this is my nix-shell
12:04:03 <arianvp> pkgs.mkShell { buildInputs = [ pkgs.go ]; }
12:04:06 <arianvp> even then, go doesn't work
12:04:11 <arianvp> go only works when I type: nix-shell -p go
12:05:11 <cocreature> arianvp: sounds like you probably want to ask this in #nixos?
12:05:19 <arianvp> oh woops
12:05:21 <arianvp> :D
12:05:31 <arianvp> cocreature: wasn't paying attention
12:05:44 <dyl> I'm back!
12:05:55 <dyl> I need to fix my ZNC configuration :/. I let my domain name lapse.
12:06:08 <dyl> I have the money to buy it back now though.
12:18:06 <dminuoso> dyl: Did some domain parker take it from you and sell it back for horrendous prices?
12:21:16 <dyl> Nope, actually when I went to reregister it, it was cheaper.
12:21:25 <dyl> Cost me like $200/y before, now it's ~30% less.
12:21:49 <dminuoso> That's quite expensive. Do you have some fancy TLD?
12:22:00 <dyl> morphi.sm
12:22:02 <dyl> ;p
12:22:05 <merijn> Jesus...200/y
12:22:14 <dyl> It was less before, then it went up, now it went back down.
12:22:27 <merijn> I was thinking my 8 euro/yr was expensive...
12:22:41 <dyl> I'd get a cheaper one if I could think of anything good.
12:22:46 <dyl> I'm just pretty attached to this domain name.
12:22:53 <dyl> It lends itself to all sorts of fun subdomains.
12:23:10 <merijn> Oh, neat! I just noticed my forwarding domain is still functioning fine xD
12:23:10 <dyl> auto.morphi.sm was for a while a redirect loop for no particularly good reason.
12:23:46 <merijn> #haskell meme lore: http://lambdacats.org :D
12:24:02 <merijn> I forgot I owned that to make finding that site easier :p
12:25:10 <dyl> Had to get back on IRC to ask some questions in #python about this horror: 
12:25:11 <dyl> https://github.com/pcarbonn/pyDatalog/blob/0d59ddeaf51b04d902e5b3c1cd8ad95a0e0e7099/pyDatalog/pyDatalog.py#L174
12:25:15 <dyl> (this is heresy)
12:25:25 <dyl> (you do not modify the parent stack frame from a child...)
12:25:28 <dyl> (jesus christ)
12:26:35 <jlamothe> dyl: That sounds more like C shennanigans than Haskell
12:26:38 <dminuoso> dyl: I absolutely love looking at this zoomed out and having not the singlest of all clues what this does.
12:27:00 <dyl> locals_ = stack[1][0].f_locals ⇒ get the stack frame one level up, then get the locals dictionary for it...
12:27:10 <dyl> And then it proceeds to butcher the locals in the caller's frame.
12:27:53 <dminuoso> dyl: Is this some magic shoehorned DSL baked into Python?
12:27:57 <dyl> Yes.
12:28:00 <dyl> It's actually quite neat.
12:28:28 <dyl> You can do: pdl.create_terms('has_car', 'X'); +has_car('Mary'); print(has_car(X)); 
12:28:33 <dyl> and get ['Mary']
12:28:43 <dminuoso> I think I prefer QQ.
12:28:54 <dyl> QQ?
12:28:56 <dyl> Quasiquoting?
12:29:00 <dminuoso> Yeah.
12:29:40 <dyl> I think someone bolted an insane DSL for that into Python too at some point.
12:29:59 <dyl> https://github.com/llllllllll/quasiquotes
12:30:07 <dyl> Excuse me, I need to go find something to throw up in.
12:30:10 <dminuoso> dyl: I think this is the part where Ruby excels at building DSLs.
12:30:23 <merijn> Underappreciated GHC flag appreciation time: -freverse-errors
12:30:27 <dyl> Ruby excels at building DSLs because it allows you to monkeypatch pretty much anything at runtime.
12:30:33 <dminuoso> With that simple method_missing mechanism you can construct DSLs quite easily without screwing with things like the callstack...
12:30:42 <dyl> Ruby is an insane Smalltalk clone disguised as Algol
12:30:46 <dminuoso> dyl: Its not even that, its just method_missing.
12:30:54 <dminuoso> You dont even have to monkey patch anything.
12:31:09 <dyl> http://rubyquiz.com/quiz67.html
12:31:17 <dyl> This is a fun koan :).
12:31:24 <jlamothe> I've always been hesitant to dig into Template Haskell, because it seems to go against my whole reason for liking Haskell in the first place (type safety).
12:31:38 <cocreature> merijn: ohhhh, I had forgotten about lambdacats! Thanks for making my evening much more entertaining :)
12:31:50 <merijn> jlamothe: Typed TH has been a thing for a while now :)
12:32:00 <merijn> jlamothe: That guarantees that generated TH expressions are well-typed
12:32:09 <merijn> (Of course it doesn't guarantee things make sense :p)
12:32:20 <jlamothe> merijn: Something to look into, I guess.  Thanks.
12:32:46 <dminuoso> jlamothe: TH doesnt circumvent type safety though.
12:32:52 <jlamothe> Actually, there are other reasons I like Haskell, type safety just happens to be a big one.
12:32:53 <merijn> jlamothe: You can even abuse Typed TH to abuse things like using an inferred typeclass instance at compile time
12:33:01 <dminuoso> jlamothe: Untyped TH is just somewhat lacking for discovering why something fails to compile.
12:33:15 <dminuoso> So you still have all the guarantees of types. :)
12:33:24 <dyl> Is there a quasiquoter for writing APL in Haskell yet?
12:33:39 <dminuoso> dyl: Sounds like a brilliant acme package.
12:33:58 <dyl> Of course, there's even an entire haskellwiki page on it...
12:33:59 <dyl> https://wiki.haskell.org/APL
12:34:03 <jlamothe> I find that ghc is not good at telling me why things don't compile in the first place.  It's often wrong about the line I've made the mistake on.
12:34:12 <merijn> jlamothe: https://github.com/merijn/validated-literals/blob/master/examples/Examples.hs
12:34:37 <dminuoso> jlamothe: That can be indicative of not using enough type annotations.
12:34:58 <dminuoso> jlamothe: Usually the diagnostics of why something compiles are very good *if* you understand how type inference works.
12:35:04 <dminuoso> *why something does not compile.
12:35:18 <dminuoso> Although admittedly they take some getting used to.
12:35:24 <merijn> jlamothe: GHC doesn't report the line you make a mistake on, it reports where it discovers a mismatch between the code and the specified types. If those two things happen too far apart it's general the result of too few type signatures leaving GHC to infer too many wrong intermediate steps
12:36:22 <dminuoso> So far, GHC has been better at telling me why something is wrong than any other language implementation I know. It should be said that the pool of implementations Ive worked with only spans about a dozen or so.
12:37:18 <Cale> jlamothe: The best applications of TH are ones where you're constructing instances of typeclasses based on the structure of the definition of a datatype
12:37:39 <dminuoso> Cale: Wouldn't Generic be a better fit, in general?
12:37:40 <jlamothe> dminuoso: That hasn't really been my experience, *however* I do like that it does a better job than most languages of telling me *that* something is wrong.
12:37:59 <merijn> dminuoso: Depends on if you care about performanc
12:38:06 <merijn> dminuoso: TH is not going to affect runtime performance
12:38:12 <Cale> dminuoso: Generic doesn't work at all for GADTs, and for some purposes, results in much less efficient code. But yeah, if you can use Generic, it can be nice sometimes.
12:38:23 <dminuoso> jlamothe: Every single binding gets type annotations in my code, and I keep relatively simple bindings - this allows for GHC to fault relativly close to the source of the problem.
12:38:54 <dminuoso> (My rule is: if its worth naming, its worth specifying a type for it)
12:39:18 <jlamothe> dminuoso: Not a bad policy.
12:41:24 <dminuoso> merijn, Cale: From the discussions Ive observed in here I remember that if Generic is possible, then Generic gives me "90% of the performance for 10% of the effort", whereas TH is completely disproportionate in terms of effort to gain the remaining 10% of the performance potential. The figures are just made up to illustrate what I remember.
12:41:47 <merijn> dminuoso: Oh, I'm not saying Generic can't be nice
12:41:55 <merijn> dminuoso: But it's definitely not 90% of the performance
12:42:15 <merijn> It might be fast enough for many use cases, but that's mostly because performance in general isn't that important
12:44:13 <Cale> dminuoso: TH can be mildly annoying, but honestly I think it's comparable with Generic as far as how annoying it can be to write stuff.
12:44:42 <Cale> Of course, if someone has already set up all the Generic instances for you, and they do what you want, then writing empty instances is pretty sweet.
12:44:59 <Cale> But if you're the one who needs to do that in the first place, getting things right may or may not be trivial.
13:13:30 <Guest96599> exit
13:28:50 <xsperry2> hello. is there an extension that allows me to override existing class instance? 
13:30:05 <__monty__> xsperry2: Sounds like a bad idea. Why not just use a newtype?
13:30:16 <EvanR> -XMonkeyPatching
13:30:34 <EvanR> (does not really exist)
13:30:35 <hyperisco> I could use that some days
13:30:56 <dminuoso> Also one might consider it rude to drop into both #haskell and #haskell-offtopic and ask the same question in both channels simultaneously. :)
13:31:06 <xsperry2> __monty__, I want to do this for several layers deep datastructure, so newtype wouldn't be enough. I'd have to create new types
13:31:25 <xsperry2> which would be tedious
13:31:47 <dminuoso> xsperry2: Then it'd be tedious.
13:32:13 <dminuoso> xsperry2: Without knowing more about your program its hard to say, but perhaps a different program/data type design could help.
13:32:46 <EvanR> i can appreciate that some oddball monkey patching might easily solve some problems, if you're creative enough
13:32:56 <EvanR> in the moment
13:33:40 <__monty__> dminuoso: I didn't see any questions repeated in -offtopic.
13:33:50 <xsperry2> my use case is this: I'm migrating aeson database. the code that does the migrating would write temporary fromJSON instance that does all the conversions, that overwrites the original fromJSON instance from the main file
13:33:53 <dminuoso> __monty__: Sorry, bad tab completion. I meant #haskell-beginners 
13:34:38 <__monty__> Ah, apologies.
13:35:26 <xsperry2> I could do this in the main file, but that seems a bit unclean. I'd have to comment/uncomment two different fromJSON instances, depending if I'm loading from a new database or converting an old one
13:36:12 <EvanR> database migrations
13:36:23 <__monty__> xsperry2: Doesn't sound like a good use of the class. Why not just have a migrateXtoY function?
13:36:35 <EvanR> i have seen genuinely new types used for this, old version is a separate type from the new type
13:36:40 <EvanR> new version
13:37:15 <EvanR> as long as old databases exist, code has to still support them
13:37:21 <EvanR> old code
13:37:27 <xsperry2> the problem is that I have 3 layers deep datastructure, and the type of the inner most changed. so I'd have to create three new types, that are nearly identical to the old type
13:37:40 <dminuoso> xsperry2: Yes, but "nearly identical" is still different
13:37:48 <fog> does anyone know how to use backpack with multiple versions of the same interface? ie. converting between strict and lazy bytestrings as is common because of certain libraries preferring the particular performance capabilities of these different backend options... 
13:37:49 <xsperry2> __monty__ aeson uses fromJSON class
13:38:02 <EvanR> you could parameterize the top level type by the bottom most type
13:38:14 <dminuoso> xsperry2: Write a different newtype, it's not as bad really.
13:39:14 <EvanR> in safe-copy they make you come up with an entirely new type every time you change anything about the schema
13:39:53 <EvanR> the realities of database+type system 
13:41:26 <dminuoso> Of course you might complain about "but what about code that only focuses on some part of my large data structure" - and we'd end up in a discussion about "use lens" and how everything would be better if we had good support for row types (or not)
13:42:39 <EvanR> along with a mostly copy of the data type, you could mostly copy all of it's support code, heh
13:43:02 <EvanR> in lieu of row polymorphism
13:44:03 <EvanR> IRL you changed the support code, so you might not need the old version anymore. Hence a mandatory migration
13:44:54 <xsperry2> I don't need to support old version after a one time migration (plus a bit of testing to ensure that everything works correctly)
13:45:16 <fog> wow safecopy is awesome
13:45:52 <EvanR> famous last words, you may need to migrate an old database or old data more than 1 time
13:45:57 <Boarders> what would be the natural way to write the function that takes a bytestring and repeats every input? e.g. 0 1 1 0 would become 0 0 1 1 1 1 0 0
13:46:39 <fog> concat zipWith (\a b -> [a,b])
13:46:43 <fog> $
13:46:54 <fog> .
13:46:58 <fog> sry!
13:47:35 <EvanR> break it into a list of Word8, solve the problem for list, sew it back into a bytestring. Though it won't be as fast as possible
13:47:38 <xsperry2> I'd need to write four new types if I go with new types, that have a total of 30+ fields
13:48:05 <Boarders> how do you do the faster version?
13:48:06 <EvanR> yeah in safecopy you would make a whole new module, and call it MyCoolRecordV2
13:48:41 <EvanR> Boarders: preallocate enough space for the new string, 2x as large as before, then generate the content using a ST action
13:49:04 <xsperry2> that is why i avoided safecopy to begin with. because usually I can get away with editing json manually with vim. but this time the change is too involving
13:49:47 <xsperry2> I think it would be easiest to find some raw json library, in haskell or some other languages, and change the fields there
13:49:51 <xsperry2> easier*
13:51:12 <dminuoso> xsperry2: How would json help at all?
13:51:23 <EvanR> yeesh, and the database is stored as a json file
13:51:34 <xsperry2> aeson uses json
13:52:02 <infinisil> json is not a good format for serialization..
13:52:18 <EvanR> the migration methodology still makes sense, even if your database storage strategy is teetering on disaster
13:52:27 <monochrom> aeson can be used raw. You can work with the Value type directly.
13:53:28 <xsperry2> while json is not my favorite format, it does have several things going for it over safecopy, including the ability for a human to read, debug and edit the database
13:53:47 <xsperry2> monochrom I see
13:54:09 <EvanR> or screw it up. And dumping a database to a file is error prone even for code
13:54:43 <EvanR> the whole file might not make it
13:54:50 <fog> im worried about trying to use backpack for the given project because it seems unclear as to how it manages to interface between different backends...
13:54:57 <dminuoso> xsperry2: JSON has absolutely nothing going for it.
13:55:12 <dminuoso> xsperry2: This "human readability" is just a tooling issue, honestly.
13:55:21 <dminuoso> Having to manually edit serialized data is the problem.
13:55:35 <dminuoso> Or rather, its a symptom of a deeper problem
13:55:40 <dminuoso> Having to manually read serialized data is also a symptom of that problem.
13:56:07 <xsperry2> ability to edit the database in plain text editor allowed me to not deal with this mess of migration for the past 1 year
13:56:27 <EvanR> it must be a pretty small database
13:56:44 <xsperry2> this is the first time I have to deal with it, so it paid itself off already vs safecopy
13:57:18 <monochrom> I would elevate this whole debate to the source code level.
13:57:19 <xsperry2> EvanR, it isn't big. about 1 MB of json file
13:58:23 <monochrom> "I have always got plaintext-human-readable source code to work for the C language..."
13:58:31 <fog> i cant tell if the strict vs lazy bytestring is actually a valid use case for backpack because of this. it the general idea that there should literally be no difference between the backends, so that even if one package uses a particular backend, it should be completely safe to swap it out for one used by a different package - so they are completely
13:58:32 <fog>  interchangeable, unlike strict and lazy bytestrings
13:59:16 <monochrom> vs "having to manually read and edit source code is the problem" >:)
13:59:27 <EvanR> agreed
13:59:35 <dminuoso> monochrom: Or, more appropriately: "I have this human-readable version of assembly code to fix issues that lead to machine code doing the wrong thing"
14:00:03 <dminuoso> As in "I wrote bad code, but instead of fixing the bad code Im patching the resulting  binary"
14:02:21 <monochrom> fog: There is a difference between "everything could benefit from parametrizing over bytestring variants" and "some use cases could benefit from parametrizing over bytestring variants".
14:02:50 <xsperry2> I've updated, changed, or expanded my data types at least a dozen times in the past year. a simple macro/substitution in vim each time in json/aeson, vs having to write migration code and duplicate all the types each time in safecopy.. I know what I prefer, and what would drive me insane
14:03:11 <Welkin> what would be a good game example to teach programming? I'm thinking a match-3 style puzzle game, or maybe a (very simplified) roguelike
14:03:14 <fog> monochrom: it seems that these bystestring variants are incompatible with backpack. im not sure what you mean
14:03:17 <dminuoso> xsperry2: Here's some funny thought.
14:03:28 <Welkin> but of course, match 3 itself is is really overdone
14:03:34 <monochrom> The use case I have in mind is parsing.  Parsing doesn't mind whether the input stream is lazy or strict.  Actually parsing doesn't even mind if you swap out bytestring for text, to a large extent.
14:03:36 <dminuoso> xsperry2: Imagine what happens if you have a double precision floating point number and you serialize it into JSON. And then deserialize it again.
14:03:54 <Welkin> I'm looking at tripletown right now, a game I only found out about from here, but that was supposedly released 9 years ago
14:04:13 <fog> yah, but some libraries *use* a particular varient, so you have no choice but to convert between them
14:04:17 <Welkin> something to showcase how useful ADTs are
14:04:23 <xsperry2> dminuoso, json parses it as a float, or?
14:04:29 <Welkin> probably no physics
14:04:35 <xsperry2> aeson*
14:04:35 <dminuoso> xsperry2: JSON doesnt really specify.
14:04:57 <xsperry2> then aeson should do the right thing. I'd be surprised if it doesn't
14:05:04 <dminuoso> "the right thing"
14:05:31 <dminuoso> xsperry2: JSON demands you serialize into some base10 representation.
14:05:46 <xsperry2> yes. aeson uses haskell types to write json specification. so it should parse it as double precision float
14:06:06 <dminuoso> xsperry2: My point is, if you serialize and deserialize again, you might not even get the same thing back.
14:06:26 <Welkin> javascript can only represent up to 53 bits
14:06:26 <dminuoso> xsperry2: The reason is your implementation might be using some base2 representation internally, and converting into a base10 representation can be lossy.
14:06:32 <Welkin> or was it 51
14:07:01 <dminuoso> One might expect ⌜deserialize . serialize = return⌝ - but it doesn't really hold true in case of json. :)
14:07:08 <Welkin> you can save as a string
14:07:15 <Welkin> or a bytearray
14:07:46 <xsperry2> dminuoso, I see your point. can't say I care about that kind of precision in this particular program (or most programs I write), but it could bite you back in some corner cases
14:08:03 <Welkin> so no one plays games?
14:08:26 <monochrom> Welkin: Are you drunk? Do you know what channel this is?
14:08:52 <Welkin> of course I'm not drunk
14:09:29 <Welkin> I asked for suggestions for games to be used as programming examples, for teaching programming
14:09:35 <EvanR> json isn't restricted in the float representation, it could use more than 52 bits
14:09:40 <Welkin> I have an idea of what would work best
14:10:00 <EvanR> it just needs to be a finite number of digits
14:10:03 <dminuoso> EvanR: The RFC is amusingly very imprecise when it comes to how to serialize numbers.
14:10:17 <fog> i dont think anyone wanted to add anything to that, so it was not on to challenge the channel for a response
14:10:19 <dminuoso> It begs the question whether the authors were just trying to dodge a bullet they didn't fully understand.
14:10:36 <EvanR> i'm glad they did rather than defining something wrong
14:11:31 <fog> isnt that an example of a wider issue about trying to provide a variable interface?
14:11:53 <fog> isnt there more than one valid option?
14:13:05 <fog> or is it then a case about how different functionalities may arise because of the precise choice of specific implementations 
14:14:24 <fog> eg. a pixel in a bitmap can have a different "length" like its representation as a word, but it should still have the same functionality regardless. normally we would then have a pixel class, but backpack provides an alternative
14:14:42 <fog> still not quite sure exactly when to use one and not the other
14:15:35 <fog> i guess it could be when there are a huge number of functions that would end up going in the class which would then end up more like a module
14:18:01 <fog> here is an example of what that looks like in practice; http://hackage.haskell.org/package/JuicyPixels-3.3.3.1/docs/Codec-Picture-Bitmap.html
14:19:25 <fog> it makes it seem quite daunting about exactly how much could be refactored in terms of backpack "signatures" 
14:21:20 <fog> the use case i had in mind was just writing algorithms without having defined maricies or vectors or their basic opperations - because these are provided by various different libraries and backpack seems to give a way to choose between them, without having to write a matrix *class* 
14:24:42 <fog> a user wanting to write in terms of a linear algebra midware layer would have to then eg. choose an instance of this class, instead of importing one of various equivalent implementations eg Data.LinearAlgebra.Repa
14:25:24 <fog> this then becomes a necessity since classes are only an option to abstract over types and functions, not classes...
14:26:15 <fog> not sure what classes would be a good example wrt linear algebra... vector spaces maybe? with an abstract inner product function 
14:26:23 <fog> anyway..
14:27:16 <trcc> Anyone using haskero in vs code? When I create updates a rebuild in terminal, it does not detect it, and I have to restart VS code for it to detect it
14:27:21 <sicklorkin> Affine?
14:27:37 <sicklorkin> fog ^
14:29:36 <sicklorkin> trcc you build w/stack?
14:29:52 <trcc> sicklorkin: yes from terminal
14:35:36 <xsperry2> @hoogle Map a b -> Map c b
14:35:39 <lambdabot> Control.Lens.Combinators retagged :: (Profunctor p, Bifunctor p) => p a b -> p s b
14:35:39 <lambdabot> Control.Lens.Internal.Review retagged :: (Profunctor p, Bifunctor p) => p a b -> p s b
14:35:39 <lambdabot> Control.Lens.Review retagged :: (Profunctor p, Bifunctor p) => p a b -> p s b
14:35:42 <sicklorkin> trcc do you think it's possible the binaries are already loaded in memroy?
14:36:11 <xsperry2> I guess I have to convert to [(c, b)] and then use M.fromList?
14:36:25 <trcc> sicklorkin: well there should be some way to trigger a reload 
14:36:47 <xsperry2> M.fromList . cKeyToBKey . M.toList ?
14:36:54 <sicklorkin> trcc: right.. what's what I"m thinking too
14:37:24 <sicklorkin> trcc: check to see if SIGHUP works
14:37:45 <xsperry2> I could swear there was a way to do it without converting to and from list though
14:38:02 <trcc> sicklorkin: where should I send it to?
14:38:07 <trcc> vscode?
14:38:09 <sicklorkin> the pid
14:38:09 <sicklorkin> yes
14:38:47 <sicklorkin> xsperry2: how would that work?
14:40:05 <xsperry2> sicklorkin the same way
14:44:19 <sicklorkin> trcc: mapKeys?
14:44:40 <trcc> Found an icon in bottom right, where one can change targets
14:44:45 <trcc> I just have to validate every once in a while
14:44:47 <xsperry2> sicklorkin I'm blind.. thanks
14:45:16 <sicklorkin> xsperry2: mapKeysMonotonic as well
14:47:52 <xsperry2> sicklorkin interesting. are they mutating keys behind the scene to make that more efficient?
14:48:44 <sicklorkin> i'm not sure which code you're looking at
14:50:25 <sicklorkin> behind the scene - are you implying ther's a mutable state?
14:50:26 <xsperry2> I'm not, I just can't think of any other way they could make mapKeysMonotonic more efficient
14:50:54 <xsperry2> if there's guarantee that mapKey won't change the order, they can just mutate the keys, instead of building a new tree
14:52:23 <sicklorkin> xsperry2: isnt' that what Monotonic is for?
14:52:39 <xsperry2> I guess?
14:52:43 <sicklorkin> yes
14:53:28 <sicklorkin> that said, i'm usually corrected  :P
14:53:29 <xsperry2> on a second thought, if that is what it does, what happens m1 in  let m2 = M.mapKeysMonotonic ... m1?
14:54:09 <xsperry2> to m1*
15:07:10 <maralorn> Is there a better version of `flip (maybe (return ()))`?
15:07:33 <xsperry2> :t flip (maybe (return ()))
15:07:36 <lambdabot> Monad m => Maybe a -> (a -> m ()) -> m ()
15:07:42 <lyxia> no they're not going to mutate the old map because it might still be used.
15:08:12 <xsperry2> lyxia. yeah. curious how they made it more efficient then. can't really follow their code
15:08:13 <lyxia> the work you save is in computing the structure of the map, but it still needs to be allocated
15:08:33 <sicklorkin> maralorn: I wish
15:08:43 <xsperry2> ah. they don't have to call Ord methods
15:09:14 <lyxia> yes basically
15:10:16 <sicklorkin> maralorn: I have a `maybe'` in my Data.Maybe.Extended module that does exactly that.. sans return ()
15:10:25 <xsperry2> or go through the entire tree when inserting elements one by one
15:10:30 <maralorn> sicklorkin: Which package?
15:10:51 <lyxia> :t for_
15:10:51 <sicklorkin> oh.. it's something local.. 
15:10:55 <lambdabot> (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
15:11:00 <lyxia> maralorn: ^
15:11:26 <lyxia> :t traverse_
15:11:30 <lambdabot> (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
15:11:41 <sicklorkin> maralorn: what type do you want?
15:13:53 <sicklorkin> maralorn: `maybe' :: Maybe a -> b -> (a -> b) -> b`
15:14:30 <sicklorkin> maybe' m n f = maybe n f m
15:15:53 <xsperry2> :t maybe (return ()) print (Just 10)
15:15:55 <lambdabot> IO ()
15:15:56 <sicklorkin> usage goes like:  maybe' m'v mempty $ \v -> ... 
15:16:42 <lyxia> if the Maybe is in front, might as well use case...
15:17:06 <sicklorkin> lyxia: that's a lot more typing forusre
15:17:16 <sicklorkin> but i understand the argument
15:17:24 <sicklorkin> (i think)
15:17:30 * lyxia shrugs.
15:42:11 <maralorn> lyxia: for_ is perfect. thx.
15:50:48 <xsperry2> asdf
15:52:43 <maralorn> How can I tell haskell to set a non-zero status code when I have an uncaptured error in my main::IO?
15:53:10 <xsperry2> see System.Exit
15:53:41 <sicklorkin> $?
15:53:44 <xsperry2> exitWith (ExitFailure code)
15:54:19 <lyxia> or let the exception blow up
15:54:21 <sicklorkin> doesn't error do that alredy?
15:54:32 <maralorn> I would have thought so.
15:54:52 <sicklorkin> die then?
15:55:16 <lyxia> that escalated quickly
15:55:22 <xsperry2> heh
15:55:25 <sicklorkin> lol
15:56:36 <maralorn> Hm
15:57:59 <sicklorkin> are you using unix or windows?
16:00:32 <maralorn> sicklorkin: unix.
16:02:54 <fog> does anyone have any experience implementing convex optimisation algorithms in haskell?
16:04:13 <xsperry2> maralorn you can catch SomeException in main if you want to provide a less scary error message for non-programmers. then existFailure or exitWith
16:04:29 <fog> sicklorkin: i found http://hackage.haskell.org/package/linear-1.20.9/docs/Linear-Affine.html
16:04:51 <sicklorkin> fog: there's also AffineSpace
16:05:02 <oats> how would y'all feel about seing (&) used in code? it looks similar to F#'s |> pipe operator
16:05:05 <oats> :t (&)
16:05:07 <lambdabot> a -> (a -> b) -> b
16:05:16 <fog> couldnt find much similar in repa though...
16:05:18 <xsperry2> I like to use & and <&>
16:05:20 <oats> > 5 & (+1) & (*2) & show
16:05:21 <sicklorkin> oats: I use it a bit.
16:05:23 <lambdabot>  "12"
16:05:53 <oats> I haven't come across it in other people's code yet...
16:06:03 <xsperry2> > getLine <&> map toUpper >>= putStrLn
16:06:04 <sicklorkin> that's unfortuantel.. & and <&> have very low precedcese
16:06:06 <lambdabot>  <IO ()>
16:06:20 <maralorn> xsperry2: Thx, but I am using shh for Haskelly "shell-scripts". It has very nice exceptions which get printed to stderr very nicely and are helpful when a command fails. But then the process exits with 0. Which is weird.
16:06:59 <sicklorkin> (+1) applys as functional application
16:07:02 <fog> i wanted to do a gradient descent...
16:07:06 <xsperry2> maralorn it exits with 0 on uncaught exception?
16:07:29 <maralorn> xsperry2: Sure looks like it. yeah.
16:07:49 <fog> the algorithm needed an opperation that would project a function onto some support set
16:09:29 <sicklorkin> fog: are you trying to fit to something ? 
16:11:03 <fog> its for dictionary learning
16:11:12 <fog> aka basis pursuit 
16:11:27 <fog> for overdetermined frames...
16:11:31 <fog> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.212.2331&rep=rep1&type=pdf
16:11:40 <fog> thats the simplest algorithm i can find
16:11:47 <fog> eqn 2.2
16:12:52 <sicklorkin> fog: what would require me reading the paper...
16:12:54 <fog> it should find a suitably incoherent wavelet decomopsition in a fixed number of iterations 
16:13:01 <sicklorkin> s/what/that/
16:13:11 <fog> sicklorkin. its literally just one equation
16:13:23 <wroathe> Is it me or does the parser combinator approach to parser seem harder to reason about than a more traditional lexer/parser combination?
16:13:26 <sicklorkin> greek to me
16:13:27 <wroathe> to parsing*
16:13:40 <fog> y
16:13:50 <fog> yn+1 = Hλ0.5 (yn + ΦH(x − Φyn))
16:13:53 <fog> sorry
16:13:59 <xsperry2> maralorn, how are you running your haskell "shell-scripts"? I just tested it, and return code is 1
16:15:01 <fog> the phi^H  ΦH is a transpose. not sure why they are using H... something to do with a pseudoinverse that the algorithm is based on
16:15:57 <sicklorkin> fog: still doens't help me.. sorry mate
16:16:08 <fog> and the H opperator that is applied to this error term is "hard thresholding" where it retains only a few nonzero entries in the vector
16:16:46 <fog> oh right yeah its for solving y =  Φx
16:16:53 <fog> pretty essential to mention that
16:17:59 <fog> anyway thats all straitforward, but then there is an extension to include the gradient of the residual at each step and solve using graident descent, which was why i was asking about that
16:19:02 <fog> ( Φ is the "dictionary" and having mostly 0's in the entries of x is it being "sparse", hence sparse optimisation) 
16:20:21 <sicklorkin> fog: -> #math perhaps
16:20:24 <maralorn> xsperry2: Hm, I am compiling them with the nixpkgs writeHaskelBin.
16:20:53 <fog> basically its like a fourier transform but where the basis functions are not all orthogonal... so  Φ could be enormous and y should be represented approximately by only a few of these dictionary entries 
16:21:08 <fog> sicklorkin: i thought you were asking sorry
16:21:33 <fog> anyway, thats all beside the point, im looking for a haskell library to provide these kinds of functions
16:21:55 <maralorn> xsperry2: How did you?
16:22:00 <fog> there are a whole family of algorithms like this and i want to compare some of the recent developments 
16:22:53 <fog> right, instead of finding the simplest algorithm to show you i should have found the exact function i need, one sec
16:23:05 <xsperry2> maralorn, I tried using both ghc directly and stack (which uses ghc anyway)
16:23:20 <sicklorkin> fog: https://hackage.haskell.org/packages/#cat:Math
16:24:28 <fog> on page 4 of this; https://people.maths.ox.ac.uk/tanner/papers/BlTaWe_cgiht.pdf
16:24:35 <fog> it mentions "proj"
16:25:20 <fog> " the residual [] is projected to be conjugate orthogonal to the past search direction"
16:25:46 <fog> i couldnt find anything like that in the linear algebra packages, i guess they have it in matlab.. 
16:27:23 <fog> they also use a "principle support" operator... 
16:27:59 <fog> i guess these things are more common to compressed sensing than to linear algebra as a wider mathematical area
16:31:10 <fog> oh, it says; Projecting onto the principal subspace [] by forming the rank r approximation by computing its singular valued decomposition (SVD),UΣV, setting to zero all but its leading r singular values in Σ, and reforming the product of the three SVD matrices [55]. 
16:31:39 <fog> so i guess the more common thing to look for in an existing haskell package would be a range of techniques for computing the SVD
16:32:47 <fog> i guess by "leading values" it means it sorts the eigenvalues by size and truncates the least significant contributions...
16:32:57 <fog> i guess its computing an approximate inverse or something
16:37:23 <fog> https://hackage.haskell.org/package/hmatrix-0.20.0.0/docs/src/Internal.Algorithms.html#svd
16:37:35 <Welkin> hola
16:41:06 <maralorn> xsperry2: Thx, I can‘t reproduce the problem. I guess I erroneously assumed the wrong return values.
16:52:55 <jabyrwock> It seems like most libraries add inline pragmas to all their function definitions in class instances. Is it therefore a good idea/idiomatic/etc. to do the same for an application? e.g. if I've got instance Ord Foo where compare = comparing fooField, would it be expected to have {-# INLINE compare #-} after
16:54:55 <sim590> WHy does this `map (+) [1,2,3]` gives me an error about Show (INteger -> Integer) ??
16:55:07 <sim590> Shouldn't that just give me the sum?
16:55:35 <jabyrwock> that gives you [(+) 1, (+) 2, (+) 3]
16:55:38 <jabyrwock> because map applies it to each
16:56:23 <oats> sim590: you've partially applied the (+) function to each item of the list
16:56:25 <rubik> sim590: you need a fold if you don't want using sum directly
16:56:29 <oats> so now you have a list of functions
16:56:37 <oats> and haskell doesn't know how to display a function :)
16:56:46 <Welkin> `foldl1' (+)` will give you the sum
16:57:02 <Welkin> > foldl1' (+) [1..5]
16:57:04 <lambdabot>  15
16:57:17 <Welkin> or just
16:57:18 <Welkin> you know
16:57:22 <Welkin> > sum [1..5]
16:57:24 <rubik> Welkin: is this also strict like foldl'?
16:57:24 <lambdabot>  15
16:57:27 <Welkin> yes
16:57:56 <sim590> Why foldl1 and not foldl? :(
16:57:59 <MarcelineVQ> Welkin: why use 1 over supplying the 0
16:58:07 <xsperry2> sim590 map (+) [1,2,3] returns a list of functions
16:58:12 <Welkin> sur you could do that
16:58:16 <xsperry2> [(+1),(+2),(+3)]
16:58:31 <xsperry2> and there's no default Show instance for functions
16:58:34 <EvanR> foldl1 (+) [] would be bad...
16:58:41 <rubik> sim590: this takes the head as initialising element
16:58:46 <EvanR> i'd expect 0 probably
16:59:00 <oats> > foldl1 (+) []
16:59:03 <lambdabot>  *Exception: Prelude.foldl1: empty list
16:59:15 <sim590> rubik: OK.
16:59:19 <sim590> Thanks people.
16:59:23 <rubik> yes, cause head [] throws that error
16:59:37 <oats> yaaay, partial functions \o/
16:59:49 <Welkin> they shouldn't exist in base
16:59:52 <Welkin> but they do
17:00:03 <oats> c'est la vie
17:00:13 <Welkin> :t headMay
17:00:16 <lambdabot> error: Variable not in scope: headMay
17:00:20 <Welkin> something like that
17:00:22 <Welkin> from the safe package
17:00:27 <xsperry2> yes
17:00:43 <oats> @hoogle [a] -> Maybe a
17:00:44 <Welkin> elm has `head : List a -> Maybe a` by default
17:00:46 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
17:00:46 <lambdabot> Test.Framework.Providers.API listToMaybeLast :: [a] -> Maybe a
17:00:46 <lambdabot> Distribution.Compat.Prelude.Internal listToMaybe :: () => [a] -> Maybe a
17:00:50 <oats> ah, listToMaybe
17:01:18 <rubik> in one of my libs i use safeHead, just using Maybe a
17:01:23 <oats> I think there's some alternate preludes that ditch all partial functions
17:01:31 <Welkin> don't use the alternate preludes
17:01:33 <Welkin> they are all dumb
17:01:45 <Welkin> normal prelude is fine for the basic things
17:01:56 <Welkin> just import what you need directly from the other packages
17:02:26 <jabyrwock> normal prelude doesn't give me enough excuses to use ~ in type declarations
17:02:38 <Welkin> that's a good thing
17:03:27 <oats> Welkin: I don't understand, why should one not use an alternate prelude?
17:03:34 <oats> asides from maybe dependency bloat
17:03:48 <rubik> or don't import prelude implicitely, then import just specific funcs or all with hiding some
17:05:19 <Welkin> you can't use it if you write al ibrary
17:05:48 <Welkin> it makes your code much harder to understand by others and won't fit well with other libraries
17:05:52 <EvanR> i appreciate stuff like head, it makes more people feel comfortable
17:06:00 <EvanR> and it's technically possible to use it correctly
17:07:20 <xsperry2> asdfjkl
17:07:29 <oats> aoeuidht
17:07:40 <sicklorkin> EvanR: buyt this requires checking for null everywhere..
17:07:53 <EvanR> what... no
17:08:05 <oats> I try to use exhaustive pattern matching where I can instead of head/tail
17:08:09 * sicklorkin was expecthing that response.
17:08:20 <EvanR> you can technically use it correctly specifically when you know the argument is not empty
17:08:36 <oats> yeh, it's like using fromMaybe
17:09:00 <EvanR> it's just the compiler can't check that for you
17:09:04 <sicklorkin> EvanR: pattern matching?
17:09:16 <EvanR> pattern matching wouldn't work, you would have to handle the impossible case of []
17:09:58 <sicklorkin> EvanR: Can yiu give me an example so I'm on the same page here?
17:10:19 <EvanR> > group [1,1,3,4,4,4]
17:10:22 <lambdabot>  [[1,1],[3],[4,4,4]]
17:10:23 <jabyrwock> groupBy is a good example probabl-
17:10:24 <jabyrwock> yeah
17:10:26 <EvanR> > group []
17:10:29 <lambdabot>  []
17:10:29 <oats> EvanR: sorry, that's what I implied
17:10:43 <oats> explicitly matching (a:as) and []
17:10:53 <EvanR> well without further info group can technically produce []
17:10:55 <oats> instead of checking for null and using head
17:11:02 <oats> a la lisp
17:11:15 <EvanR> checking for null first would definitely qualify as "use pattern matching instead"
17:12:05 <EvanR> ok, my example was supposed to entail the fact that "for all results of group, each result is non-empty"
17:12:16 <EvanR> > map head (group [1,1,3,4,4,4])
17:12:19 <lambdabot>  [1,3,4]
17:12:22 <EvanR> > map head (group [])
17:12:27 <lambdabot>  []
17:12:27 <EvanR> no crashy
17:12:35 <jabyrwock> isn't there a groupby that makes a nonempty in base?
17:13:13 <EvanR> nonempty is also a way to deal with this, of course this falls under the same umbrella as a non-zero number type, or non-negative
17:13:17 <sicklorkin> EvanR: Okay, so technically possible, but in practice a bonkers idea
17:13:19 <EvanR> often not worth the trouble
17:14:09 <EvanR> to first approximation head is a bonkers idea
17:14:24 <sicklorkin> ^.^y
17:14:55 <Welkin> okay winston churchill
17:21:51 <electricityZZZZ> hey i am trying to find a benchmark on the impact of linear types and haven't had luck. can somebody point me in the right direction?
17:55:06 <wildtrees[m]> Rust on the benchmark games
18:24:30 <electricityZZZZ> pardon i meant impact of linear types on haskell perf
18:24:53 <Cale> electricityZZZZ: Runtime perf? None.
18:25:09 <Cale> electricityZZZZ: They might make compilation slower though.
18:26:18 <electricityZZZZ> oh... so the purpose isn't to sorta statically annotate allocation to avoid gc pauses?
18:27:19 <Cale> https://gitlab.haskell.org/ghc/ghc/wikis/linear-types
18:27:46 <electricityZZZZ> thx ill read more
18:48:47 <sethetter> Is it possible to import a module into GHCi with a different name than the defined module name?
18:49:02 <sethetter> I have two `Main` modules I'd like to import into a GHCi session, but alias one as something else.
18:49:34 <monochrom> import X as Y
18:51:59 <sethetter> Within ghci though?
18:53:09 <monochrom> Yes, ghci honours hand-entered imports.
18:59:16 <dmwit> ...but if they're both named Main that won't help.
18:59:35 <dmwit> If they are literally both named Main, I think you may actually be out of luck.
19:00:19 <dmwit> So uh... maybe don't name them both Main?
19:01:08 <dmwit> (You can use cabal's main-is: field in your executable stanza to still be able to build them into executables.)
19:04:14 <z0> is it normal that I'm getting a Non-exaustive pattern warning on an irrefutable pattern?
19:06:41 <lyxia> yes
21:22:40 <Welkin> > 32 * 24
21:22:42 <lambdabot>  768
21:22:57 <Welkin> > 24 * 24
21:22:59 <lambdabot>  576
21:23:17 <EvanR> > 789 * 987
21:23:20 <lambdabot>  778743
21:23:24 <EvanR> > 789 + 987
21:23:27 <lambdabot>  1776
21:24:15 <EvanR> arabs predicted date of america
21:34:44 <EvanR> i wrote some javascript in haskell's immutable style, where i keep generating new data and forget the old
21:35:32 <EvanR> it seems to choke if i leave it running in another tab. I wonder if this is chrome specific or if ghcjs has the same issue
21:39:19 <ysangkok> are you sure you are letting go of the old data? chrome has a nice debugger
21:40:08 <EvanR> it shows flat memory usage... at least theres that
21:40:28 <EvanR> but shows nothing at all for times when another tab is open
21:43:28 <EvanR> nvm it's behavior of requestAnimationFrame, memory is normal
23:21:09 <rsoeldner> Morning, How could I profile my app (using nix & cabal), is this still the right way ? https://stackoverflow.com/questions/47636243/with-nix-how-can-i-specify-haskell-dependencies-with-profiling-enabled
23:45:30 <sicklorkin> rsoeldner: I thought *nix defaults to building with profiling already
23:57:31 * jgt quietly nods good morning to the Haskellers
