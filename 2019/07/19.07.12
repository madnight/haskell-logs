00:59:46 <Vikfret> !topic
01:04:07 <ski> /topic
01:04:11 <ski> Vikfret ^
01:04:43 <Vikfret> yeah I used topic after that :p
01:04:51 <Vikfret> i meant /topic
02:59:05 <maerwald> cabal-cache: ~/.cabal/store/ghc-8.6.5/lib: getDirectoryContents:openDirStream: does not exist (No such file or directory)
03:01:30 <maerwald> seems it's broken
03:40:52 <cheater> int-e: thank you
03:42:21 <adfsdf> how to install fudgets? should be cabal package according to http://www.altocumulus.org/Fudgets/userguide.html but cabal install fudgets fails
03:43:18 <__monty__> adfsdf: Something being packaged with cabal doesn't mean it's available on hackage. Which a quick search reveals it's not.
03:44:30 <__monty__> adfsdf: The instructions on the site aren't very clear but I think the author intends for you to obtain the source code and then run cabal install from the repository.
03:44:57 <adfsdf> __monty__: thanks
03:53:24 <adfsdf> __monty__: cabal install tar.gz package gives error - could not resolve dependencies - hbc-library (not in hackage)?
03:59:20 <maerwald> cabal-cache really seems to not work well
03:59:43 <maerwald> probably easier to just put all of it into a volume and upload that 
04:04:23 <merijn> adfsdf: That code must be so old I'd just give up
04:04:56 <merijn> adfsdf: HBC, if I recall correctly, was Lennart's Haskell compiler (i.e., the first one ever) and I don't think it's been maintained in, well, probably close to two decades
04:05:42 <merijn> ah, no, that website suggest it should work with GHC, so presumably you have to get hbc-library from somewhere
04:06:40 <adfsdf> ok, do you have any recommendations for GUI libraries for haskell newcomers
04:08:06 <merijn> fltkhs is probably the most robust/easiest to built one, but FLTK can look a bit...ugly
04:08:09 <merijn> @hackage fltkhs
04:08:10 <lambdabot> http://hackage.haskell.org/package/fltkhs
04:09:06 <merijn> Honestly, most GUI libraries tend to all be either kinda sucky or hard to install...
04:10:30 <adfsdf> ok, thanks
06:09:37 <ikhwan> ada yang dari indonesia
06:10:09 <ikhwan> hello i'm from indonesia
06:21:20 <halogenandtoast> So I am trying to avoid doing something crazy with MonadTrans here, but I can't figure out how to make something like the indicated line work: https://gist.github.com/halogenandtoast/7b624d4a28c4cb6dfa5224afc6dae1d8#file-lib-hs-L19
06:21:44 <halogenandtoast> line 21 works fine, probably because ActionT has an instance ScottyT doesn't
06:22:14 <merijn> halogenandtoast: Right
06:22:43 <merijn> halogenandtoast: So you either lift the one on line 19, or make ScottyT an instance
06:23:20 <halogenandtoast> lift won't work because ScottyT is not a MonadTrans
06:23:59 <merijn> Really?
06:24:04 <halogenandtoast> Yeah :(
06:24:39 <halogenandtoast> > The monad parameters to ScottyT have been decoupled, causing the type of the ScottyT constructor to change. As a result, ScottyT is no longer a MonadTrans instance, and the type signatures ofscottyT, scottyAppT, and scottyOptsT have been simplified. [ehamberg]
06:24:42 <lambdabot>  <hint>:1:52: error: parse error on input ‘,’
06:25:07 <merijn> halogenandtoast: The constructor is exported though, so you can lift it manually
06:25:19 <merijn> And/or define your own instance
06:26:25 <halogenandtoast> merijn: one issue is that it's defined as newtype ScottyT e m a = ScottyT { runS :: State (ScottyState e m) a } instead of using StateT
06:26:43 <merijn> So?
06:26:51 <merijn> State is just a type alias for StateT over identity
06:26:54 <merijn> Has been for years
06:27:10 <merijn> For exactly this reason :p
06:27:26 <halogenandtoast> Fair enough, thanks merijn
06:27:31 <xcthulhu> I don’t think `ScottyState` has `MonadTrans` either :(
06:27:38 <xcthulhu> https://hackage.haskell.org/package/scotty-0.11.4/docs/src/Web.Scotty.Internal.Types.html#ScottyState
06:29:30 <merijn> xcthulhu: ScottyState is the argument to State, not the transformers
06:31:40 <xcthulhu> You are right, I need another coffee merijn
06:33:43 <xcthulhu> This line is dead code: https://gist.github.com/halogenandtoast/7b624d4a28c4cb6dfa5224afc6dae1d8#file-lib-hs-L19
06:33:58 <xcthulhu> Is there a reason you don’t want to get rid of it @halogenandtoast ?
06:35:18 <elcaro> noob help please. how can i pass the inner lists in [[1,2],[3,4]] to func :: [Int] -> [Int] -> ReturnType
06:36:13 <dminuoso> elcaro: What should that do? Concatenate them?
06:36:24 <xcthulhu> `let [a,b] = innerLists in func a b`
06:36:25 <dminuoso> elcaro: Oh, you mean separately?
06:36:50 <dminuoso> elcaro: Pattern match and handle the cases when the list has not 2 elements. :) 
06:36:57 <elcaro> yeah, i wann the inner lists as separate args. 
06:37:11 <elcaro> ok, yeah can pattern match, was just curious if there's another way.
06:40:13 <dminuoso> elcaro: Yeah we do not have any "splat" type of operator that other languages might have. The type system does not allow for it.
06:40:28 <halogenandtoast> xcthulhu: I plan to do something else there, it's just a placeholder
06:40:45 <halogenandtoast> a simpler case to highlight the issue
06:41:05 <elcaro> dminuoso: yeah that was what i was wondering. ok, will just pattern match. thanks
06:41:34 <halogenandtoast> also only the type ScottyT is exported, not the data constructor, so to get that I'd have to import Web.Scotty.Internal.Types which seems not great
06:42:36 <dminuoso> elcaro: The type system must be able to type check at compile time. Consider a trivial example to see why such an operator would be tough: l :: [Int]; f :: Int -> Int -> Char; What's the type of `f l`?
06:42:55 <dminuoso> elcaro: Try to answer that question as an excercise. :)
06:43:19 <dminuoso> Or rather, `f *l` assuming we had some sort of splat operator named `*`
06:43:21 <dminuoso> Sorry. :)
06:43:32 <xcthulhu> @elcaro - I would just do a pattern match, but you can apparently use Control.Lens to make this pretty evil.  See the comments in https://stackoverflow.com/a/2923574
06:43:32 <lambdabot> Unknown command, try @list
06:44:14 <mniip> which part of that is lens?
06:44:20 <xcthulhu> elcaro: So you could do: `(curry func) (partsOf each .~ innerList)`
06:44:25 <dminuoso> mniip: partsOf
06:44:50 <mniip> ah that bit
06:46:42 <xcthulhu> halogenandtoast: Admittedly in $DAYJOB, if I ran into this kind of trouble in the type system I’d just thead my config around.
06:46:50 <dminuoso> % "Sony Playstation" & partsOf (traverse . filtered isUpper) %~ reverse  
06:46:51 <yahb> dminuoso: ; <interactive>:85:63: error:; Ambiguous occurrence `reverse'; It could refer to either `V.reverse', imported from `Data.Vector'; or `Prelude.reverse', imported from `Prelude' (and originally defined in `GHC.List'); or `Data.Text.reverse', imported from `Data.Text'
06:46:58 <xcthulhu> As an argument I mean, and not bother with the reader monad
06:47:07 <dminuoso> % "Sony Playstation" & partsOf (traverse . filtered isUpper) %~ Prelude.reverse
06:47:08 <yahb> dminuoso: "Pony Slaystation"
06:47:21 <tabaqui> hmm
06:47:27 <Axman6> dminuoso: <3
06:47:28 <tabaqui> how can I make it compilable:
06:47:48 <tabaqui> class Foo a where; type Bar a; func :: Bar a -> Bool
06:47:58 <halogenandtoast> xcthulhu: fair enough, just trying to developer a better understanding of Scotty and what it is doing
06:48:04 <tabaqui> NB: ‘Bar’ is a type function, and may not be injective
06:48:17 <tabaqui> should I add some constraint or so?
06:48:47 <dminuoso> tabaqui: AllowAmbiguousTypes?
06:48:59 <tabaqui> is it safe extension?
06:49:56 <Guest_36> hi, im following a tutorial to learn haskell and it says after installing haskell platform I can open terminal and type ghci to get into ghci but when I do that I only get "command not found", any ideas?
06:50:25 <dminuoso> Guest_36: Hi. What operating system are you on?
06:50:43 <Guest_36> macOS sierra
06:51:14 <dminuoso> tabaqui: Yes. The problem is that func becomes uninferrable if `Bar` is non-injective.
06:51:59 <dminuoso> instance Foo A where type Bar A = Int; ...; instance Foo B where type A = Int; ...; func (1 :: Int) -- which instance?
06:52:14 <tabaqui> oh, ok
06:52:24 <tabaqui> but even if we don't define instance Foo B
06:52:38 <tabaqui> how ghc will know that func (1 :: Int) should use A method?
06:53:10 <dminuoso> Wouldn't GHC have no inference rule if Bar is non-injective?
06:53:27 <dminuoso> I mean that's partially kind of the point of injective type families, to add that inference rule - no?
06:53:49 <merijn> Guest_36: By default the install path of the Platform isn't in your path
06:54:05 <merijn> Guest_36: I forget where things are put, though? I think somewhere under ~/Library/Haskell
06:54:20 <tabaqui> allright, I will just test it. If it doesn't work, then I'll add Proxy in func definition
06:55:14 <dminuoso> tabaqui: With AllowAmbiguousTypes you could use TypeApplications - or just use Proxy.
06:55:21 <dminuoso> It'll be the same effectively
06:55:32 <tabaqui> yeah
06:55:35 <tabaqui> thank you
06:57:11 <dminuoso> tabaqui: https://gist.github.com/dminuoso/6f7c17a1e17d04991f126f9f9ccd70d2
06:57:52 <tabaqui> great!
06:58:08 <dminuoso> tabaqui: Oh here's a reason why what you proposed couldn't work: The open world assumption.
06:59:19 <tabaqui> do you mean to define only one instance with type A = int, but without a Proxy or TypeApplications?
06:59:32 <tabaqui> right, I assumed that
07:01:33 <dminuoso> tabaqui: You could of course also make it an injective type family (if its applicable), that would be an alternative way. :)
07:01:55 <Guest_36> merijn   thank you, I know what a file path is but what is "my path" in this context?
07:02:14 <dminuoso> Then you could just say `f (1 :: Int)` - of course my example wouldn't work since it's non-injective.
07:04:07 <tabaqui> but it will work if `f (1 :: Bar A)`
07:04:16 <tabaqui> oh, dunno
07:04:39 <merijn> Guest_36: In the terminal the programs you can run are determined by the directories listed in the PATH variable (you can inspect this by running "echo $PATH" in the terminal). Executables in other directories are not runnable unless you write out there exact location. Normally you'd want to add the path of (for example GHC and GHCI) to that variable so you can just use them
07:04:51 <tabaqui> `f (1 :: (Num (Bar A)) => Bar A)`
07:04:56 <tabaqui> probably
07:05:16 <dminuoso> tabaqui: are you familiar with what an injective type family is?
07:05:38 <merijn> Guest_36: https://blog.teamtreehouse.com/introduction-to-the-mac-os-x-command-line
07:05:58 <tabaqui> I assume it is the same as injective function
07:06:21 <tabaqui> like there is no input that mapped in the same image value
07:06:28 <tabaqui> *no inputs
07:06:34 <tabaqui> *are no inputs
07:06:59 <tabaqui> so `Bar a != Bar b` for any `a != b`
07:12:49 <dminuoso> tabaqui: Right. So if its injective and we have `Bar A = Int`, whenever we see ⌜func (a :: Int)⌝ we can infer that the instance for A is to be used.
07:13:50 <dminuoso> tabaqui: If its non-injective we cant, because there might be some other instance `Bar X = Int` somewhere else.
07:45:37 <dminuoso> Design question, if you have a typeclass you only use internally - would you try to write the instance at the data declarations or at the class definition site?
07:53:35 <Guest_36> merijn thx for your help, I can make ghci work now by entering . "$HOME/.ghcup/env" first when I open a new terminal window
08:14:29 <asheshambasta> Has anyone used Haskell Friday here? http://hackage.haskell.org/package/friday
08:15:21 <Jinna> dmwit: Thx for the tip, yesterday: M.fromListWith (+) [(v,1) | v <- vs]
08:15:54 <asheshambasta> and if so, have you also noticed that reading/saving a PNG image with a transparent background results in an image with a black background (saved as PNG ofcourse)
08:23:21 <nitrix> Does continuous FRP allows recursive definitions, such as a counter for example where `x = x + 1`?
08:23:58 <nitrix> If so, then how is it controlled such that it's incremented only by 1 everytime and doesn't go into some sort of insane busy loop?
08:24:32 <nitrix> I don't mind if it's explained on a theorical level, semantics of an existing language/framework or even a reference implementation somewhere.
08:25:37 <EvanR> x = x + 1 seems like a busy loop to me
08:25:49 <merijn> nitrix: Well, what is "1" there?
08:26:04 <merijn> nitrix: btw, FRP is, by definition, continuous
08:26:10 <merijn> That's the entire reason conal invented it
08:28:24 <nitrix> I'm read as much material on the subject as I can. I know he advises not to think of it like a graph with propagations, but I'm doing a visual programming interface that ends up looking like one, so bare with me there :)
08:28:40 <merijn> nitrix: Did you read the FRAN and push-pull paper?
08:28:56 <nitrix> The push-pull hybrid only.
08:29:18 <merijn> nitrix: I think the FRAN one is good in terms of giving a good use-case for needing/wanting it
08:30:07 <merijn> nitrix: You asked "why is x = x + 1 not a busy loop?", but afaict it is? That doesn't seem related to FRP at all, though? :)
08:31:06 <nitrix> At the moment, someone is able to connect the graph such that a constant `1` and a variable `x` (starting at 0), are fed to the function `+`, whose output goes back into the `x` input, creating a feedback loop. My `problem` is that this increments infinitely and I hit a road block when I try to extend that to make a counter that simply counts by 1.
08:31:33 <merijn> nitrix: That doesn't sound very FRP to me?
08:31:39 <nitrix> merijn: You're right, it is, but I'd like for it to behave as if it's discrete, in a language that has continuous semantics.
08:32:22 <merijn> nitrix: you seem to be talking about some graph consuming input events, but FRP doesn't let you define that
08:32:38 <nitrix> Maybe I'm on the wrong track. I'll admit I didn't prepare my question at all, kinda rambling really.
08:32:53 <merijn> nitrix: Only behaviour in relation to either 1) continuous time or 2) discrete events (that happen "at some time")
08:33:28 <merijn> nitrix: So in FRP  "x = x + 1" doesn't make sense (or rather, it makes as much sense as it does in Haskell)
08:34:10 <merijn> nitrix: You could define "foo = currentTime + 1" for example, you could even define a stepper that creates an event every time time is a modulo of 10, then use that stepper to increment at that event, etc.
08:34:44 <nitrix> merijn: Okay well, that might be an X/Y problem. Let me backtrack a little. Suppose I build such visual programming language, graph-like, with continuous semantics... how do I model stateful things? Suppose pacman game, with the position of the pacman and ghosts or your score?
08:36:44 <merijn> nitrix: You'll need to define a "gate" like thing in there. That takes the continuous signal and turns it into a boolean value that can trigger things downstream
08:36:54 <merijn> Which raises questions of edge triggered vs level triggered
08:37:21 <merijn> Also, your probably want to support discrete events within your continuous semantics (like FRP) if you want to do this in a way that doesn't suck
08:37:22 <nitrix> The score gives me a hard time because there's an edge in the graph somewhere with your score connected to various sinks like the renderer, then you add a number to the current score and feed it back into the system, suddently the loop causes the score to increment like madness.
08:39:54 <nitrix> merijn: Exactly. I want to stay truthful to conal's idea, but it gets impractical very quickly without /some/ discrete concept.
08:40:13 <wildtrees> nitrix, if you want x = x + 1 (I have only used arrowized frp like netwire) you want roughly newX = (delay (start at some value say 0) oldX) + 1 
08:40:30 <wildtrees> you would need a delay with a starting value on the x 
08:41:50 <nitrix> wildtrees: Mhh, yeah, netwire has this concept of "time frames" and you can obtain the value of the previous frame or delay the computation for the next frame, if I remember...
08:42:44 <nitrix> Mine so far is a simply a directed graph because the papers insisted that I don't try to encode time :/
08:42:52 <nitrix> And I'm stuck.
08:43:27 <wildtrees> nitrix, I did something like netwire, but unarrowized with something like mealy(?) machines
08:44:11 <Jinna> Why doesn’t  `(+) `on` succ 9 19`  work in the repl?
08:44:33 <wildtrees> you have a data Computation a b = runComputation { (a,deltaTime) -> (b,runComputation a b) } 
08:44:53 <wildtrees> you can leave out the deltatime for starters though 
08:44:56 <glguy> > ( (+) `on` succ ) 9 19
08:44:59 <lambdabot>  30
08:45:00 <int-e> Jinna: that requires a Num a => Num (r -> a) instance (and a similar one for Enum), which doesn't exist by default.
08:45:17 <int-e> I'm actually unsure why lambdabot has that one...
08:45:18 <int-e> @undef
08:45:19 <lambdabot> Undefined.
08:45:21 <int-e> > 1 1
08:45:24 <lambdabot>  error:
08:45:24 <lambdabot>      • Could not deduce (Num t0)
08:45:24 <lambdabot>        from the context: (Num (t -> t1), Num t)
08:45:33 <nitrix> wildtrees: That's discrete though :/
08:45:36 <int-e> because somebody helpfully defined it... no preventing that.
08:45:57 <int-e> huh
08:46:12 <Jinna> Aah I see.    (+) `on` succ 9 19    fails   but      ((+) `on` succ) 9 19    works
08:46:13 <nitrix> merijn: wildtrees: He insisted that the whole should stay continuous and only the leaves would "appear" discrete.  http://conal.net/blog/posts/why-program-with-continuous-time
08:46:13 <int-e> I guess glguy is right :)
08:46:41 * int-e really needs to pay more attention. Oh well.
08:47:04 <wildtrees> nitrix, I think the deltaTime ends up making it appear continuous, if you calculate enough discrete steps
08:49:06 <wildtrees> nitrix, from that link, he seems to explain it three paragraphs down , that all streams are discrete, but he want's continuous time built in 
08:58:47 <tombusby> hi all, I have a quick q. Let's say I have [(String, String)], what's the best way to collect that up so that I have [(String, [String])] with the first acting as a key for dups. I'd use a HashMap but I care about key order
09:00:19 <jgt> tombusby: did you try using a fold?
09:00:25 <glguy> tombusby: How about collect up all the key-value pairs with a map and then take a second pass across the input list replacing keys with the elements for that key
09:00:32 <glguy> remove things from your map as you process the list
09:00:43 <glguy> if you encounter a key not in your map it means it was already handled earlier, so skip those
09:02:37 <tombusby> i like that idea, thanks, ill give it a go
09:05:20 <Jinna> In a `where` I want to compute the current UTCTime.   `getCurrentTime :: IO UTCTime`   <-- is this a place to use unsafePerformIO to actually run the computation?
09:06:11 <Taneb> That'll certainly get you *a* time, but it may not be the one you want
09:06:35 <Jinna> Why not?
09:06:52 <Taneb> Because you have no control over when the unsafePerformIO is actually evaluated
09:07:03 <Jinna> I see.
09:07:48 <jgt> Jinna: why do you believe it is necessary for this to happen in a `where`?
09:08:09 <Taneb> Can your function be modified to take the time as an argument?
09:08:53 <Jinna> jgt: I have a function that computes an IO value. Inside that function I want to fold data. The fold function is complex and I want to move it into a where block. Inside the fold function i want to access the current time, as of when my outer function was called.
09:09:29 <jgt> Jinna: why not pass the UTCTime in as an argument to your complex fold function?
09:09:40 <Jinna> I would like to take the current time, but only once. I can’t pass it to the fold function. I would have to add it to the fold-accumulator, which is wasted, as I would be unpacking and repacking the time again and again, even though it stays constant.
09:09:59 <Jinna> jgt: I will probably do this.
09:10:52 <jgt> yeah I'm not super convinced by the "wasted" idea. Between something that _seems_ wasteful and a use of unsafePerformIO, I certainly know which one I'd pick
09:17:39 <int-e> . o O ( unsafeInterleaveIO )
09:17:46 * int-e runs.
09:18:01 <glguy> surpriseIO
09:18:30 <int-e> Though given the choice between not performing the IO immediately, and using unsafePerformIO, this becomes a really attractive third option.
09:38:13 <tdammers> a more interesting concern with unsafePerformIO currentTime is that it may produce different values each time it is evaluated, which means the correctness of the program hinges on optimizations that are supposed to be completely benign
09:38:27 <tdammers> oh wait, that concern was already voiced
09:38:41 <tdammers> note to self: read scrollback before opening virtual mouth
09:44:47 <Henson> does anyone have experience using Servant to receive data to be stored in a file?  I'm aware of the servant-multipart package.  I'm thinking of using a web front end running something like Elm to do file upload, but also upload data from an Android device.  I assume servant-multipart is appropriate for the former, but not sure about the latter.
10:11:11 <worthington> 767deo S3xyL1nux 646tgj
10:12:32 <worthington> 465iku S3xyL1nux the only legend just stepped in 544tcx
10:16:52 <worthington> 189oqw 4,01c7a8n 9y3o12u 6c4a7t8c9h 3t12h6i4s7? 166fwg
10:17:39 <marmulak> wow
10:17:53 <worthington> 911pjt 4,01i 7a8m 9n3o12t 6a 4h7u8m9a3n $rand(111,999)uri
10:19:04 <worthington> 249vxb 4,01o7n8e 9m3o12r6e4.7. 302nbj
10:20:27 <worthington> 327qdo 4,01m7o8r9e3.12. 685tib
10:23:46 <Ariakenom> @ops
10:23:46 <lambdabot> Maybe you meant: pl oeis docs
10:23:50 <Ariakenom> hm
10:23:52 <Ariakenom> &ops
10:24:33 <lavalike> @where ops
10:24:33 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw mniip monochrom quicksilver shachaf shapr ski
10:24:53 <Ariakenom> ah
10:26:21 <worthington> 695dol 4,01m7o8r9e3.12. 792dkf
10:28:35 --- mode: ChanServ set +o Cale
10:28:40 --- mode: Cale set +b *!*@ngn1-ppp1931.fukuoka.sannet.ne.jp
10:28:53 --- kick: worthington was kicked by Cale (worthington)
10:29:14 --- mode: Cale set -o Cale
10:34:49 * sarahzrf claps
10:35:39 <marmulak> why clap
10:35:48 <sarahzrf> for Cale
10:37:39 <poohcjy9> 04,0130730859j3o12n 6S0437x8y9L03112n6u4x 7w8i9l3l 12s6t4a7l8k 9f3r12e6e4n7o8d9e 3t12h6e 4r7e8s9t 3o12f 6S4i7g8y9n 3l12i6f4e 0720820973b12a6u
11:22:13 <tombusby> anyone here know much about Aeson? I'd like to check if a particlar key in an object has a value, then fail without caring what that value is if so
11:22:22 <tombusby> having trouble figuring that one out from docs alone
11:23:24 <tombusby> (this is during parseJSON obviously)
11:23:32 <tabaqui> tombusby: v <- obj .:? value; case v of { Just{} -> fail "bla"; Nothing -> dosmth }
11:23:59 <tombusby> thanks I'll give it try
11:25:44 <tombusby> doesn't work I'm afraid: "Ambiguous type variable ‘a0’ arising from a use of ‘.:?’"
11:25:58 <fragamus> hi I have   d :: DeclHead SrcSpanInfo    and I want to    d ^. typed @(DeclHead SrcSpanInfo)    but no workie
11:26:06 <tabaqui> yeah, it depends on desired value
11:26:14 <tabaqui> add type signature somewhere
11:26:16 <tombusby> similar to prior attempts: the sticking point is that the type system won't turn a blind eye to what type the Maybe is
11:26:34 <tabaqui> f.e. case (v :: Object) of ...
11:26:34 <tombusby> that's the problem, that means I have to define FromJSON which I'd like to avoid
11:26:53 <tabaqui> Object is wide enough, probably
11:26:54 <dmwit> v :: Maybe Value
11:27:02 <tabaqui> oh, Value, right
11:27:16 <bergey> You can write: member "key" obj
11:27:18 <bergey> using https://hackage.haskell.org/package/unordered-containers-0.2.10.0/docs/Data-HashMap-Strict.html#v:member
11:27:33 <dmwit> But yes, just operating on the hashmap directly is probably the right way.
11:27:40 <tombusby> dmwit: thanks mate that's exactly what I needed. also thanks tabaqui for pushing me in the right direction
11:31:58 <ahri> I was just looking at Word64 trying to find a constraint that expresses something like Natural, i.e. non-negative integral numbers, am I looking in the wrong place?
11:32:48 <bergey> https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Natural.html
11:33:15 <bergey> Oh, you said Constraint.  Sorry, reading too fast.
11:33:54 <fragamus> I get a compile error that is really unweildy when I try to use  d ^. typed @(DeclHead SrcSpanInfo)
11:33:59 <pong> .t head . (filter isJust)
11:34:18 <pong> :t head . (filter isJust)
11:34:20 <lambdabot> [Maybe a] -> Maybe a
11:34:35 <ahri> bergey: yeah, I'm really looking to constrain my param to Word* data types, i.e. not Int* or Integer
11:34:58 <fragamus> ooops that one works but this one doesnt: toListOf (types @(DeclHead SrcSpanInfo))
11:35:19 <ahri> It's not a big deal, I can write my own class, just didn't want to duplicate what's there already
11:36:09 <bergey> Yeah.  I don't know of such a class, but it might be out there.
11:38:45 <tabaqui> head is bad function, use listToMaybe instead
11:38:50 <tabaqui> :t listToMaybe
11:38:54 <lambdabot> [a] -> Maybe a
11:39:24 <tabaqui> :t listToMaybe . (>>= maybeToList)
11:39:26 <lambdabot> [Maybe a] -> Maybe a
11:39:35 <tabaqui> (listToMaybe . (>>= maybeToList)) [Nothing]
11:39:42 <tabaqui> % (listToMaybe . (>>= maybeToList)) [Nothing]
11:39:42 <yahb> tabaqui: Nothing
11:39:45 <tabaqui> % (listToMaybe . (>>= maybeToList)) [Nothing, Just 1]
11:39:45 <yahb> tabaqui: Just 1
11:39:47 <lavalike> :t listToMaybe . catMaybes
11:39:48 <lambdabot> [Maybe a] -> Maybe a
11:40:42 <whittle> I’m concerned that I’ve discovered some sort of evil magic: why in the world would `instance MonadCatch Handler where catch = catch` work? 
11:41:15 <merijn> whittle: Because that's just undefined ;)
11:41:28 <merijn> whittle: And it will infinite loop when used
11:41:34 <merijn> > let x = x in x
11:41:38 <lambdabot>  *Exception: <<loop>>
11:41:49 <int-e> that, or the class method is imported qualified only
11:42:15 <whittle> `import Control.Monad.Catch (MonadCatch(..))`. 
11:42:30 <int-e> In which case the lhs is resolved via the MonadCatch class, but the rhs can refer to something defined in the module. (I believe, have not checked.)
11:42:53 <whittle> int-e: That’s what I was thinking, so I checked my imports. 
11:43:15 <whittle> I’m hiding catch from the other module it might be coming from. 
11:43:51 <whittle> merijn: I guess this is one of the problems with hole-driven development. 
11:44:12 <whittle> Thank you, both. 
11:44:22 <whittle> merijn++
11:44:24 <whittle> int-e++
11:45:08 <merijn> whittle: More so it's a problem with "bindings are recursive by default" :)
11:46:24 <int-e> it gets better with default implementations in the mix.
11:46:55 <merijn> int-e: default implementations can be checked via MINIMAL to prevent that, though
11:47:16 <int-e> but only if that pragam is provided and correct :P
11:47:21 <int-e> *pragma
11:51:13 <whittle> So does this mean that the type checker assumes inside an instance definition that the type getting an instance is already an instance? Is that why this passes type-checking? 
11:51:53 <merijn> whittle: The type checker doesn't "assume" it just follows some logic which allows for using class methods within the implementation of said class, yes
11:51:59 <merijn> whittle: Like my x example
11:52:09 <whittle> Okay. 
11:52:18 <merijn> > let x = x in x -- bindings can be recursive, so left hand 'x' is in scope on the right hand
11:52:21 <lambdabot>  *Exception: <<loop>>
11:52:56 <int-e> . o O ( now, let's add a `where` clause to the mix... )
11:53:00 <merijn> whittle: This is nice when writing recursive functions like "let map f (x:xs) = f x : map f xs" (map in scope on the right hand), but annoying in the "x = x" case
11:53:32 <whittle> Got it. 
11:55:28 <int-e> > let x x = x x where x x = x in x 23 42 -- yay.
11:55:35 <lambdabot>  mueval-core: Time limit exceeded
11:56:18 <int-e> hmm. funny. my ghci prints 42.
11:56:38 <int-e> > 1
11:56:43 <lambdabot>  1
11:56:58 <whittle> Whew. 1 still equals 1. 
11:57:10 <int-e> > let x x = x x where x x = x in x 23 42
11:57:13 <lambdabot>  42
11:57:15 <int-e> phew.
11:58:01 <tabaqui> whaat
11:58:12 <tabaqui> % let x x = x x where x x = x in x 23 42
11:58:12 <yahb> tabaqui: 42
11:58:19 <tabaqui> % let x x = x x where x x = x in x 23 42 -- yay.
11:58:19 <yahb> tabaqui: 42
11:58:39 <int-e> most of the 'x' are getting shadowed.
11:58:52 <tabaqui> but white time limit at the first try?
11:58:57 <tabaqui> *why
11:59:38 <int-e> because the time limit is 5 seconds, and evaluation takes 3 seconds already under good circumstances.
12:00:10 <int-e> so sometimes lambdabot just time outs with no good reason :/
12:00:23 <int-e> or times out
12:00:27 <tabaqui> oh could you rewrite it without shadowing?
12:01:02 <int-e> > let a b = c c where c d = d in a 23 42
12:01:04 <lambdabot>  42
12:01:08 <tabaqui> thanks
12:01:38 <tabaqui> oh, that's simple
12:27:18 <fragamus> hi I need some guidance on generic-lens
12:29:26 <fragamus> I have    d :: DeclHead SrcSpanInfo     and I want to     toListOf (types @(DeclHead SrcSpanInfo)) d
12:31:19 <fragamus> but it won't compile and it gives me a horrific compiler error message
12:31:38 <fragamus> what am I doing wrong?
12:32:45 <fragamus> I believe that my usage is exactly that which is intended for toListOf ( types  blah blah blah
12:45:26 <fragamus> well I just tried a traversal for just  SrcSpanInfo   which is in all of the constructors and it worked
12:49:17 <fragamus> so I guess it can't work if one or more constructors don't contain a recursive reference
12:51:12 <fragamus> it begins to look like I need to write a recursive descent thingy
12:54:32 <whittle> Still working on this: I have a type m which is an instance of Monad, MonadIO, and MonadUnliftIO. Is there a way for me to add an (orphan) instance MonadCatch m? 
13:10:02 <whittle> Nevermind. I figured out how to do it using withRunInIO, only to realize that besides unliftio-core, there’s a “batteries-included” package unliftio that provides UnliftIO.Exception.catch. 
13:13:17 <solonarv> fragamus: what is the definition of DeclHead? also, what is the actual error message you got (please use a paste service) ?
13:14:15 <sicklorkin> > > let bzz = accumArray (curry snd) 0 (0,5) $ (0,1) : [(i, bzz ! (i - 1) * 2) | i <- [1..5]] in bzz
13:14:18 <lambdabot>  <hint>:1:1: error: parse error on input ‘>’
13:14:22 <sicklorkin> > let bzz = accumArray (curry snd) 0 (0,5) $ (0,1) : [(i, bzz ! (i - 1) * 2) | i <- [1..5]] in bzz
13:14:25 <lambdabot>  array (0,5) [(0,1),(1,2),(2,4),(3,8),(4,16),(5,32)]
13:15:16 <sicklorkin> why doesn't this work in ghc-8.6.5?
13:16:08 <sicklorkin> Is there a way to tell what version of ghc lambdabot is using?
13:16:33 <sicklorkin> > system("ghc --version")
13:16:35 <lambdabot>  error:
13:16:35 <lambdabot>      Variable not in scope: system :: [Char] -> t
13:17:29 <sicklorkin> > system "ghc --version"
13:17:31 <lambdabot>  error:
13:17:31 <lambdabot>      Variable not in scope: system :: [Char] -> t
13:17:54 <sicklorkin> > ghcVersion
13:17:57 <lambdabot>  error: Variable not in scope: ghcVersion
13:20:10 <solonarv> ?version
13:20:11 <lambdabot> lambdabot 5.1.0.4
13:20:11 <lambdabot> git clone https://github.com/lambdabot/lambdabot
13:20:21 <sicklorkin> solonarv: thanks
13:20:55 <int-e> sicklorkin: sicklorkin it's still on 8.2.2 for no good reason.
13:21:03 <solonarv> although it actually supports a fairly wide range of GHC versions
13:21:12 <int-e> (not sure why I had to use the nick twice?)
13:22:09 <sicklorkin> I suppose there's no way to ask lambdabot to run a expression on a certain version on ghc?
13:23:20 <solonarv> nope
13:23:41 <solonarv> you can use yahb which generally runs the newest GCH version (currently 8.6.5)
13:24:15 <sicklorkin> How do I invoke yahb?
13:24:51 <sicklorkin> (there's a user named yahb here, is that a bot?)
13:24:54 <solonarv> '% ' followed by anything you would type into ghci
13:24:57 <solonarv> yes, that is the bot
13:25:13 <sicklorkin> % let bzz = accumArray (curry snd) 0 (0,5) $ (0,1) : [(i, bzz ! (i - 1) * 2) | i <- 
13:25:14 <yahb> sicklorkin: ; <interactive>:94:83: error: parse error (possibly incorrect indentation or mismatched brackets)
13:25:16 <sicklorkin>                     [1..5]] in bzz
13:25:30 <solonarv> yahb = Yet Another Haskell Bot ;)
13:25:35 <sicklorkin> % ?version
13:25:35 <yahb> sicklorkin: ; <interactive>:95:1: error:; * Unbound implicit parameter (?version::()) arising from a use of `it'; * In the first argument of `print', namely `it'; In a stmt of an interactive GHCi command: print it
13:25:54 <sicklorkin> % let bzz = accumArray (curry snd) 0 (0,5) $ (0,1) : [(i, bzz ! (i - 1) * 2) | i <- [1..5]] in bzz
13:25:54 <yahb> sicklorkin: ; <interactive>:96:61: error:; Ambiguous occurrence `!'; It could refer to either `V.!', imported from `Data.Vector'; or `Data.Array.!', imported from `Data.Array' (and originally defined in `GHC.Arr')
13:26:20 <solonarv> % :m - V
13:26:20 <yahb> solonarv: ; <no location info>: error:; Could not find module `V'; It is not a module in the current program, or in any known package.
13:26:27 <solonarv> one sec let me fix the module imports
13:26:33 <sicklorkin> solonarv: thnx
13:27:53 <solonarv> % :t (Array.!) -- use that
13:27:53 <yahb> solonarv: Ix i => Array i e -> i -> e
13:28:49 <sicklorkin> solonarv: do you know what version of ghc yahb is using?
13:28:53 <sicklorkin> % let bzz = accumArray (curry snd) 0 (0,5) $ (0,1) : [(i, bzz (Array.!) (i - 1) * 2) | i <- [1..5]] in bzz
13:28:53 <yahb> sicklorkin: ; <interactive>:105:11: error:; * Variable not in scope: accumArray :: (a0 -> c0 -> c0) -> Integer -> (Integer, Integer) -> [(t1, b1)] -> (Array i1 e1 -> i1 -> e1) -> t1 -> b1; * Perhaps you meant `Array.accumArray' (imported from Data.Array)
13:29:12 <solonarv> should be 8.6.5
13:29:21 <sicklorkin> % let bzz = Array.accumArray (curry snd) 0 (0,5) $ (0,1) : [(i, bzz (Array.!) (i - 1) * 2) | i <- [1..5]] in bzz
13:29:21 <yahb> sicklorkin: ; <interactive>:106:11: error:; * Couldn't match expected type `(Array i2 e1 -> i2 -> e1) -> i3 -> a1' with actual type `Array i3 a1'; * In the expression: Array.accumArray (curry snd) 0 (0, 5) $ (0, 1) : [(i, bzz (Array.!) (i - 1) * 2) | i <- [1 .. 5]]; In an equation for `bzz': bzz = Array.accumArray (curry snd) 0 (0, 5) $ (0, 1) : [(i, bzz (Array.!) (i - 1) * 2) | i <- [1 .. 5]]; 
13:30:07 <int-e> I've been slowly working towards updating lb to a new ghc version, but it's not going smoothly for various reasons, all stupid.
13:30:14 <sicklorkin> hummmm
13:30:43 <sicklorkin> int-e: what's lb? 
13:30:55 <int-e> lambdabot
13:31:05 * sicklorkin knew that
13:31:47 <shapr> I didn't know lambdabot was ghc version dependent
13:32:45 <int-e> well, only mueval is, really. but there's not point in keeping several ghc's around either
13:32:56 <sicklorkin> % let bzz = GHC.Arr.accumArray (curry snd) 0 (0,5) $ (0,1) : [(i, bzz ! (i - 1) * 2) | i <- [1..5]] in bzz
13:32:56 <yahb> sicklorkin: ; <interactive>:107:69: error:; * Variable not in scope: (!) :: Array i1 a1 -> i1 -> a1; * Perhaps you meant one of these: `Array.!' (imported from Data.Array), `M.!' (imported from Data.Map), `IM.!' (imported from Data.IntMap)
13:33:06 <shapr> int-e: good to know
13:33:11 <sicklorkin> % let bzz = GHC.Arr.accumArray (curry snd) 0 (0,5) $ (0,1) : [(i, bzz (Array.!) (i - 1) * 2) | i <- [1..5]] in bzz
13:33:11 <yahb> sicklorkin: ; <interactive>:108:11: error:; * Couldn't match expected type `(Array i2 e1 -> i2 -> e1) -> i3 -> a1' with actual type `Array i3 a1'; * In the expression: Array.accumArray (curry snd) 0 (0, 5) $ (0, 1) : [(i, bzz (Array.!) (i - 1) * 2) | i <- [1 .. 5]]; In an equation for `bzz': bzz = Array.accumArray (curry snd) 0 (0, 5) $ (0, 1) : [(i, bzz (Array.!) (i - 1) * 2) | i <- [1 .. 5]]; 
13:33:31 <sicklorkin> solonarv: I have no idea why this doesnt' work.. it works fine in GHCi
13:36:26 <int-e> sicklorkin: you need to use Array.!  instead of (Array.!)
13:36:37 <int-e> (qualified infix operators look weird)
13:36:53 <sicklorkin> % let bzz = GHC.Arr.accumArray (curry snd) 0 (0,5) $ (0,1) : [(i, bzz Array.! (i - 1) * 2) | i <- [1..5]] in bzz
13:36:58 <yahb> sicklorkin: array [Timed out]
13:37:00 <sicklorkin> wait for it
13:37:20 <sicklorkin> > let bzz = GHC.Arr.accumArray (curry snd) 0 (0,5) $ (0,1) : [(i, bzz Array.! (i - 1) * 2) | i <- [1..5]] in bzz
13:37:30 <lambdabot>  mueval-core: Time limit exceeded
13:37:45 <sicklorkin> errr.. 
13:37:49 <sicklorkin> > let bzz = accumArray (curry snd) 0 (0,5) $ (0,1) : [(i, bzz ! (i - 1) * 2) | i <- [1..5]] in bzz
13:37:54 <lambdabot>  array (0,5) [(0,1),(1,2),(2,4),(3,8),(4,16),(5,32)]
13:38:53 <sicklorkin> WAT
13:39:44 <sicklorkin> > let bzz = Data.Array.accumArray (curry snd) 0 (0,5) $ (0,1) : [(i, bzz ! (i - 1) * 2) | i <- [1..5]] in bzz
13:39:46 <lambdabot>  array (0,5) [(0,1),(1,2),(2,4),(3,8),(4,16),(5,32)]
13:39:52 <sicklorkin> % let bzz = Data.Array.accumArray (curry snd) 0 (0,5) $ (0,1) : [(i, bzz ! (i - 1) * 2) | i <- [1..5]] in bzz
13:39:58 <yahb> sicklorkin: array [Timed out]
13:40:12 <sicklorkin> ok.. there's the problem.
13:41:25 <sicklorkin> docs say its' a non-strict array 
13:41:44 <int-e> so somebody made accumArray more strict?
13:42:29 <sicklorkin> %  let fibs = (1 :: Int) :1:zipWith (+) fibs (drop 1 fibs) in take 10 fibs
13:42:30 <yahb> sicklorkin: [1,1,2,3,5,8,13,21,34,55]
13:42:36 <sicklorkin> >  let fibs = (1 :: Int) :1:zipWith (+) fibs (drop 1 fibs) in take 10 fibs
13:42:39 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
13:42:53 <sicklorkin> int-e: seems like it
13:43:30 <sicklorkin> % array (0,79) (zip [0..15] xs ++ [(i, rotL 1 $ xxor i) | i<-[16..79]])
13:43:30 <yahb> sicklorkin: ; <interactive>:2:27: error: Variable not in scope: xs :: [e]; <interactive>:2:38: error: Variable not in scope: rotL :: Integer -> t0 -> e; <interactive>:2:47: error:; * Variable not in scope: xxor :: i -> t0; * Perhaps you meant `xor' (imported from Data.Bits)
13:43:53 <sicklorkin> oops.. 
13:44:28 <int-e> sicklorkin: https://github.com/ghc/ghc/commit/08345bd0e8d237ec3929aaee7613c4f76e07e131
13:46:31 <int-e> sicklorkin: of course you should be using `array` instead of accumArray` in this case.
13:47:15 <sicklorkin> int-e: yes.. that's right.. The only reason this came up was 'cause of the Crypto package.. https://hackage.haskell.org/package/Crypto I'll submit a patch
14:00:45 <Mrbuck> hi
14:01:22 <sicklorkin> solonarv: int-e: thanks for your help.. fix submitted
14:27:19 <argent0> any idea why I might be getting `cannot satisfy -package-id doctest-0.16.0.1-5QM106btZJIIkbZZIGQwIC` when using doctest with nix & cabal ?
14:27:38 <argent0> the command was: `doctest src/Foo.hs`
14:33:11 <aristid> is there a nicer equivalent of (x .) . y
14:33:41 <aristid> i want a pointfree version of \a b -> g (f a b)
14:33:50 <Rembane> aristid: dot! 
14:33:55 <Rembane> aristid: (.) . (.)
14:34:00 <Rembane> :t (.) . (.)
14:34:05 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
14:34:34 <__monty__> Aka the blackbird operator.
14:34:41 <aristid> Rembane: like this? (.).(.) x y
14:34:46 <__monty__> :t fmap fmap fmap
14:34:47 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
14:34:54 <__monty__> That's a little more general.
14:34:56 <Rembane> aristid: Yeah, but more parentheses. 
14:35:00 <__monty__> : )
14:35:02 <aristid> not sure if i like that better
14:35:13 <solonarv> (fmap . fmap) is not horrible either
14:35:15 <Rembane> __monty__: Does that work because function is a functor? 
14:35:19 <aristid> solonarv: yes it is horrible :D
14:35:21 <solonarv> Rembane: yup!
14:35:29 <Rembane> solonarv: Sweet! 
14:35:45 <solonarv> 'fmap fmap fmap' is definitely worse than 'fmap . fmap' though, IMO
14:35:49 <__monty__> Rembane: Yes, (->) a is a Functor.
14:36:14 <Rembane> __monty__: Very nice. 
14:36:56 <aristid> solonarv: well i feel like if i would see either in code, i would need to stop and think. i want it to look obvious but yet have no evil \
14:38:23 <__monty__> aristid: I've used ... = (.).(.) as the blackbird operator. Was obvious to me but I doubt you can get any clearer than a lambda if it's not for code only you read.
14:38:50 <aristid> __monty__: i could see using just .. for it :D
14:40:12 <__monty__> No, because (.).(.) is obivously three dots, not two.
14:40:16 <MinnieMouse> Control me during my Live. Free for the next 3 members. Believe me, the fun is guaranteed! Join now: http://18-and-extreme.ga/user=MinneyMouse
14:40:48 <solonarv> .. is syntax, I don't think it's a legal operator
14:40:55 <solonarv> I've also seen .: for that operator
14:40:57 <aristid> solonarv: you're right :D
14:41:19 <aristid> solonarv: man, it's been too long since i've really used haskell, i've become rusty :/
14:43:27 <solonarv> hey, rust is a fine language!
14:46:26 <dmwit> solonarv: fmap fmap fmap requires fewer parens/$s than fmap.fmap does.
14:46:44 <solonarv> yes
14:46:56 <Rembane> :t fmap fmap fmap
14:46:58 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
14:47:03 <Rembane> Lovely.
14:47:11 <solonarv> but when I see (fmap . fmap) I know that we are working through multiple layered functors
14:47:29 <solonarv> and then I can remember "oh, 'take an argument' is a functor" and all is clear to me
14:47:41 <solonarv> if I see fmap fmap fmap I first need to remember fmap = (.)
14:47:46 <dmwit> Yes. This is why we should all use semantic editor combinators and write `result (result f)` instead of all this stuff.
14:48:10 <solonarv> I should note that I also like (liftA2 . liftA2), (traverse . traverse) and similar constructions
14:48:39 <Rembane> dmwit: If you do I cannot read any of the code! :(
14:50:57 <__monty__> What are semantic editor combinators?
15:40:06 <ysangkok> how could one compile a language like Dhall to Simplicity or its Bit Machine? I find it difficult because all the Dhall literature talks about compiling to a language with functions
15:54:59 <davean> ysangkok: never seen simplicity, but looking at their TR it seems to have functions?
15:59:31 <sarahzrf> davean: im looking at this https://blockstream.com/simplicity.pdf and it does not have higher order functions
16:01:18 <ysangkok> davean: sarahzrf: i think https://github.com/ElementsProject/simplicity/blob/pdf/Simplicity-TR.pdf has more detail
16:01:45 <davean> That later one is the TR I refered to
16:02:16 <ysangkok> yep , ok. anyway, i understood that it doesn't have functions since i am looking at section 3.2
16:03:40 <sarahzrf> what is "TR"?
16:04:01 <davean> Technical Report
16:04:20 <sarahzrf> ah
16:04:23 <davean> ysangkok: Ok, so why do you think it doesn't have functions? It sure seems to have functions from section 3.2 and it even goes on to describe TCO
16:04:45 <davean> sarahzrf: are you familiar with Technical Reports in general?
16:05:29 <davean> This one, at my first glance, seems to be above average for a TR in that it is actually technically detailed to some degree and not just heaps of BS which I'm sadly accustomed to.
16:05:47 <sarahzrf> not really no :)
16:06:32 <sarahzrf> it "has functions" in the sense that a solidity term is a function, but like
16:06:46 <sarahzrf> the domain and codomain of the function cannot be function types at all
16:06:54 <sarahzrf> you write a function, but none of the things it operates on are functions
16:07:12 <davean> Sure, so its not higher order. Thats pretty standard for most languages.
16:07:22 <davean> er
16:07:25 <davean> I didn't mean higher order
16:07:31 <davean> I meant functions aren't first order
16:08:13 <ysangkok> davean: the inductive Ty defined in 3.1.2 only enables unit, prod or sum. if i have a dhall program like the identity function, what would that compile to? the language has no terms that can represent functions, right? isn't that what you mean by functions not being first order?
16:08:14 <davean> sarahzrf: technical reports are in the academic variant basicly papers without length limits and without peer review standards and publication.
16:08:40 <davean> sarahzrf: in the commerical sense though ... they're often marketing puff pieces :)
16:08:45 <sarahzrf> oof
16:09:20 <sarahzrf> anyway
16:09:29 <sarahzrf> it seems that simplicity does have function, it just doesnt have function*s*
16:10:25 <sarahzrf> there is no function application operator
16:10:25 <ysangkok> i think i know what you're saying. so by e.g. inlining everything, things should still be able to compile to simplicity, right?
16:10:42 <davean> ysangkok: if you can inline everything than I'd think so.
16:10:43 <sarahzrf> oh no that was aimed at davean
16:10:49 <sarahzrf> ysangkok: im not sure this makes sense, in any case
16:11:01 <sarahzrf> you cant sensibly correspond dhall types to simplicity types, can you?
16:11:06 <davean> ysangkok: you can make a sort of bytecode interpriter
16:11:08 <sarahzrf> simplicity types are all finite
16:11:50 <ysangkok> sarahzrf: can't i build all non-recursive types out of unit/prod/sum?
16:12:07 * sarahzrf tries to remember what's in dhall
16:12:19 <davean> ysangkok: They seem to be worried dhall has infinite somethings
16:12:38 <ysangkok> davean: what makes you think that?
16:12:42 <sarahzrf> it has natural numbers, for sure
16:12:44 <sarahzrf> and lists
16:12:47 <sarahzrf> there we go
16:13:39 <ysangkok> aaah, yeah, i guess the point of simplicity is to have bounds on resource consumption, as shown in section 3.6 "static analysis"
16:14:53 <int-e> updating the hoogle database takes ages...
16:15:46 <ysangkok> but i am just thinking, since Dhall is total, shouldn't i be able to compile it to simplicity?
16:16:29 <davean> ysangkok: uh ... there are MANY ways for things to be total
16:16:40 <davean> There is not a proof that total languages are equivilent to each other
16:16:58 <davean> Turing complete languages are equivilent (module IO)
16:17:00 <sarahzrf> ysangkok: yes, it's quite easy: evaluate the dhall to a value, then generate a literal in simplicit
16:17:02 <sarahzrf> y
16:17:17 <davean> compilation can be evaluation
16:17:36 <davean> but in a sense "()" is a language. Its a VERY boring one.
16:19:10 <ysangkok> well, if i have a dhall program that calculates sha256, i have a sha256 literal for that in simplicity. but what if i take another program? 
16:20:02 <davean> well, we know that SHA256 is total in a way that simplicty can compute (theres a simplity program for it infact)
16:20:09 <ysangkok> i guess i am a bit confused about the definition of function. surely simplicity allows input and output, e.g. simulating sighash_all from bitcoin (section 4.5.8 in the simplicity TR). so one could consider that a function
16:20:18 <davean> Since simplicity is total though we know there exists *some* programs you can't encode though
16:20:26 <davean> if Dhall is total, it also has some programs it can't encode
16:20:33 <davean> we do not know if one is a subset of the other
16:21:29 <ysangkok> but you can't think of any counter-examples, right? :)
16:22:19 <davean> Well I can think of counter examples of tihngs you can't encode in Simplicity immediately
16:22:37 <davean> I'd have to know dhall and simplicity to tell you what the sets look like at all
16:24:03 <ysangkok> davean: i suppose your simplicity example requires recursion or loops?
16:24:07 <wildtrees> if it's dependently typed encode it only terminate if the collatz conjecture is true for all Nats 
16:24:25 <wildtrees> ....encode it to only terminate...
16:25:02 <ysangkok> none of these languages are dependently types though
16:25:09 <ysangkok> *typed
16:25:49 <wildtrees> :( maybe you can encode the collatz conjecture through some other means 
16:29:00 <davean> ysangkok: saying that claims a model of computation, my example of what you can't do is declarative.
16:29:37 <davean> ysangkok: I mean it has to be, right?
16:29:45 <davean> otherwise it owuldn't be a disproof of completeness
16:29:57 <davean> it would just be a proof that a specific component is insufficient
16:31:19 <ysangkok> what would be a 'component' in this case?
16:32:13 <davean> ysangkok: recursion
16:35:08 <ysangkok> well... it might be that there are programs in either languages that can't be expressed in the other. but i suspect that you could express sha256 in dhall, and i know you can express it in simplicity.
16:35:19 <davean> ysangkok: sure
16:35:25 <davean> thats pretty trivial to impliment
16:35:44 <davean> But, I'll point out a reason for that: Its *exceddingly clear* how much "gas" you need to do that computation
16:36:03 <davean> ysangkok: I can tell you up front *exactly* how many operations that takes
16:36:58 <ysangkok> but i just can't figure out why you wouldn't be able to do that for an arbitrary Dhall program? if the Dhall program's type is higher order, it can't be expressed in simplicity, ok, but let's disregard those
16:46:15 <elvishjerricco> Is there any way to enumerate the constructors of a GADT with only nullary constructors?
16:47:31 <elvishjerricco> Really what I need is a one to one mapping between my GADT and a String name for each constructor.
16:47:58 <elvishjerricco> i.e. a parser and a printer
16:48:21 <elvishjerricco> where each constructor corresponds to some hard coded string
16:49:03 <int-e> Oh before I forgot, I upgraded lambdabot to ghc-8.6.5 so please let me know if anything important broke.
16:50:42 <elvishjerricco> I'm trying to encode ZFS property names with some type safety so I can have both `setProp :: Prop a -> a -> IO ()` and `getProp :: Prop a -> IO (Maybe a)`
16:51:54 <solonarv> elvishjerricco: if it's a GADT I guess you would have to use template haskell somewhere :/
16:53:01 <solonarv> or hand-write the mapping I suppose
16:54:34 <solonarv> propName :: Prop a -> String; propName = \case PropFoo -> "PropFoo"; PropBar -> "PropBar"; ... -- this direction is easy
16:55:00 <sarahzrf> oh god oh no the paper just dropped a mention of urbit
16:55:02 <sarahzrf> lmaoo
16:55:58 <elvishjerricco> solonarv: Yea, a redundant case statement to make sure `-Wincomplete-patterns` catches for me is a good idea.
16:57:03 <elvishjerricco> i.e. `parseProp :: String -> Maybe (Some Prop); parseProp = let ans = <actual parsing> in case ans of ...`
16:58:14 <solonarv> since the constructors are all nullary I would write it something like:
16:59:06 <solonarv> parseProp s = asum [ Some PropFoo <$ guard (s == "PropFoo"), Some PropBar <$ guard (s == "PropBar"), ... ]
17:02:37 <elvishjerricco> solonarv: I've just done this: `let ans = case s of "foo" -> Just (Some Foo); ... in case ans of Nothing -> ans; Just (Some Foo) -> ans; ...`
17:05:01 <solonarv> oh right, that works too
17:05:19 <solonarv> wait, what's the second case for?
17:05:47 <elvishjerricco> solonarv: The first case won't throw any warnings if I forget to add a case for a new property. The second case gives me a warning that I've forgotten one. It's operationally redundant
17:05:55 <solonarv> ooh, I see
17:11:34 <___laika> im running into an issue that appears to be related to dynamic linking, but im confused because my cabal file doesn't mention that
17:11:36 <___laika> https://gist.github.com/matthewess/17531755747ec3506388d7402bf1ce8b
17:11:49 <ddellacosta> can anyone tell me what the point of the INLINE gvalidate in this piece? https://reasonablypolymorphic.com/blog/higher-kinded-data/
17:12:21 <___laika> when i run my test suite (but not when i build my main target), i get that error about "mismatched interface file ways"
17:13:29 <solonarv> ddellacosta: it makes sure that function gets inlined, which is crucial to allow GHC to optimize away all the newtype juggling and wrapping/unwrapping
17:13:30 <___laika> also updated my gist to include my project.yaml
17:13:58 <solonarv> 'project.yaml'? it should be called 'package.yaml'
17:14:20 <solonarv> you can have a project.yaml but I don't think that does anything
17:16:29 <___laika> it is package.yaml
17:16:31 <___laika> im just silly
17:16:58 <___laika> i also run hpack manually since im not using stack
17:17:20 <ddellacosta> solonarv: I guess I should clarify, is there anything specifically about generics that dictates that?
17:17:27 <solonarv> ddellacosta: not really
17:17:44 <ddellacosta> solonarv: okay, thanks
17:18:20 <solonarv> it's just that generics-based code tends to involve converting the datatype of interest to its generic representation (which is a deeply nested tree of a bunch of primitives), operating on that, then (maybe) converting back
17:18:30 <solonarv> that is a lot of overhead!
17:18:49 <solonarv> ___laika: interesting, I think that's first time I've heard of someone doing that
17:19:28 <___laika> i like being able to specify whole-project dependencies, options, extensions, and i like not having to keep track of exposed modules
17:19:37 <ddellacosta> solonarv: gotcha, you know I had a little bit of an intuition that using generics on complex data types would produce trees, but past that I wasn't sure how that fit in--but that helps a lot, thanks
17:19:38 <___laika> but i prefer nix to stack for personal work
17:20:22 <solonarv> ___laika: cabal supports all of these by itself, apart from not having to list all the modules
17:21:16 <solonarv> https://cabal.readthedocs.io/en/latest/developing-packages.html#common-stanzas
17:21:52 <jackdk> Is there an easy way to generate a dependency graph for a cabal package? I have searched for phrases like "transitive closure" etc with little luck. Found an internal cabal module but nothing user-facing?
17:22:27 <___laika> solonarv++
17:22:58 <___laika> maybe ill cut hpack out of my workflow now, if i dont find another reason i was using it that i forgot
17:24:46 <Boarders> does anyone know why Codensity from the kan-extensions package takes a monad that is levity polymorphic? in its return type?
17:26:36 <solonarv> Boarders: just to be more general, I suppose
17:26:53 <solonarv> also Codensity m is always a monad, no matter what m is
17:26:58 <Boarders> I was wondering more if there were interesting examples of monads that make use of that
17:27:22 <solonarv> well you can't write a monad instance for something with a non-Type return kind
17:27:38 <Boarders> ah yes, ok
17:28:22 <solonarv> there currently aren't a lot of ways to have (m :: k -> TYPE rep) with rep ≠ LiftedRep
17:28:48 <solonarv> mostly I think it would be primitive arrays or maybe unboxed tuples/sums
17:29:15 <solonarv> once unboxed newtypes land (not sure when that will be) there will be a few more possibilities
17:29:36 <Boarders> kind of dumb question but how does the kind inference go for something like Functor
17:29:48 <Boarders> like how does it know that it must by Type -> Type?
17:30:35 <solonarv> theoretically it could be as general as 'TYPE rep1 -> TYPE rep2' but I think that gets defaulted to 'Type -> Type'
17:31:14 <Boarders> ah ok, I thought it might be something to do with saturation in say (a -> b) or something like that
17:32:37 <solonarv> looking at the type of fmap :: (a -> b) -> f a -> f b, we find a :: TYPE rep_a, b :: TYPE rep_b (this must be the case because of ->'s kind), and similar for f a and f b
17:32:59 <solonarv> then default all the unknown representations to LiftedRep and you get the familiar kind
17:33:13 <Boarders> yes, I just didn't know it was quite a defaulting rule
17:38:31 <solonarv> I'm not sure what exactly the rule is like but it seems sensible to have, and clearly inferred types are not littered with 'TYPE rep' so there must be some defaulting going on
17:42:23 <c_wraith> I'm pretty sure levity polymorphism is never inferred, types that could be polykinded default to Type (unless -XPolyKinds is enabled, then they default to polymorphic), and everything else is inferred from the kinds of concrete types.
17:42:51 <solonarv> sounds about right to me
18:52:22 <halogenandtoast> Is there any way to write this using esqueleto? https://gist.github.com/halogenandtoast/9c46d39b6c4e660b26be4974fb2b8c44
18:52:53 <halogenandtoast> Particularly I think the subselect is not possible.
18:53:36 <halogenandtoast> Might be time to bust out rawSql, but I wanted to be sure
18:58:50 <dmwit> > True > True > True
18:58:52 <lambdabot>  error:
18:58:52 <lambdabot>      Precedence parsing error
18:58:52 <lambdabot>          cannot mix ‘>’ [infix 4] and ‘>’ [infix 4] in the same infix expression
18:59:02 <dmwit> sensible
19:04:15 <cheater> i have f :: (a -> c) -> d, g :: (a -> b -> c), and v :: b. can i somehow use <$> and <*> to mesh f, g, and v together, rather than swapping g's arguments?
19:04:54 <jackdk> I am writing doctests for a package P. I want to say something like "under certain circumstances, you should look at function Q.f instead" and provide a doctest. Q depends on P, so doctest cannot find it. How can I coax doctest into knowing about Q without messing with cabal deps?
19:05:18 <jackdk> (context: P is semialign, Q is semialign-indexed, and both are in a common repo under a cabal.project file, if that helps matters)
19:06:15 <cheater> make a separate package for your tests maybe?
19:07:20 <dmwit> cheater: f (`g` v) -- is fairly standard, if g is actually an identifier
19:08:23 <jackdk> cheater: close enough, I think? if I make a nix shell that depends on both then I should be able to run doctests in that. I don't want to push a pile of testing infra onto a project I'm drive-by contributing to
19:09:14 <dmwit> cheater: Why don't you like swapping g's arguments?
19:18:50 <cheater> dmwit: i was just wondering if it's doable with the p <$> q <*> r pattern, that's all
19:19:17 <cheater> i tried working out the types for when the applicative is (->) r, but that didn't really seem to do much for me
19:20:49 <cheater> (or maybe something similar to that pattern)
19:22:30 <dmwit> :t \g v -> g <*> pure v
19:22:31 <lambdabot> Applicative f => f (a -> b) -> a -> f b
19:22:56 <dmwit> cheater: ^
19:23:39 <dmwit> But `flip g v` sure seems easier to read to me than `g <*> pure v`.
19:25:00 <cheater> hmm
19:25:05 <cheater> interesting
19:25:41 <cheater> thanks dmwit =)
19:26:25 <halogenandtoast> Is there a way to silence compiler warnings for a particular unused top bind?
19:27:09 <solonarv> remove it? :P
19:27:11 <solonarv> or export it
19:27:42 <halogenandtoast> solonarv: thanks, I'll export it
19:28:00 <halogenandtoast> it's just a function I am using for debugging, but it will be useful to have exported anyways
19:34:18 <cheater> is new-build getting sandboxes at some point?
19:34:56 <dmwit> No, but see hvr's cabal-environment tool.
19:35:56 <dmwit> https://github.com/hvr/cabal-env
19:38:58 <solonarv> uh, I don't think that does anything cabal can't do by itself now
19:39:03 <solonarv> I looked at it a few days ago
19:39:17 <cheater> i find that sad
19:39:27 <cheater> sandboxes are the #1 feature of cabal for me
19:39:34 <sclv> It manages env files for you
19:39:39 <sclv> Its a tiny wrapper
19:39:45 <cheater> what are env files?
19:39:49 <cheater> why is that relevant to me?
19:40:11 <solonarv> you can just 'cabal v2-install --lib package-env=MYFILE.env'
19:40:45 <solonarv> and then 'ghc -package-env MYFILE.env' to use it
19:40:55 <solonarv> cheater: what do you use sandboxes for?
19:41:00 <cheater> i don't know what that command line means
19:41:10 <sclv> solonarv: nice :-)
19:41:15 <cheater> i use them so that i don't have dependencies shared with other projects
19:41:23 <cheater> which is the main pain point with haskell builds
19:41:30 <cheater> it *always* goes wrong
19:41:31 <solonarv> right. why do you want dependencies to not be shared?
19:41:38 <solonarv> mismatched versions and that sort of nonsense?
19:41:40 <cheater> i want the whole world to not be shared
19:41:41 <cheater> yes
19:42:05 <solonarv> okay. cabal v2-build shares build products *only if the output would be precisely identical*.
19:42:21 <cheater> when did the old build share them?
19:42:40 <solonarv> whenever the version of that dependency (and flags?) matches, IIRC
19:42:48 <cheater> i don't know what that means
19:43:10 <cheater> i've had the diamond problem most often
19:43:29 <cheater> what does "the version of that dependency matches" mean?
19:43:31 <cheater> matches what?
19:43:40 <cheater> what is "that dependency"?
19:44:13 <solonarv> if there is a 'bytestring-0.10.8.2' already built and your package depends on 'bytestring ==0.10.*' that will be used
19:44:42 <solonarv> without looking at which versions were selected for the dependencies of 'bytestring-0.10.8.2'
19:45:07 <cheater> ok, yeah, that was my problem
19:45:15 <cheater> ok, so it looks like new-build is what i want to use. thanks
19:45:21 <cheater> that was a good explanation :)
19:45:57 <solonarv> with v2-build instead your store contains 'bytestring-0.10.8.2-sd785fga=some-big-hash', and that hash includes the versions that were chosen for bytestring's dependencies
19:46:15 <solonarv> that existing build output is only reused if those hashes match
19:46:32 <solonarv> in effect you get the upsides of sandboxes but without duplicating work unnecessarily
19:48:21 <solonarv> and if you look at your store after using v2-build for a while you might indeed see multiple 'bytestring-0.10.8.2-*' folders
19:57:30 <cheater> thank you
20:40:49 <halogenandtoast> When using ghcid, if my cabal file compiles two executables, is there a way to have it load the Main.hs file for a specific one
20:43:37 <halogenandtoast> I guess I can just run ghcid app/Main.hs
22:29:04 <fresheyeball> how can I use profiling to find bottlenecks/problems in my running program?
22:29:15 <fresheyeball> its running very slow and I can't figure out why
22:31:05 <dmwit> Have you tried looking in the documentation?
22:31:37 <fresheyeball> dmwit: I have
22:31:42 <fresheyeball> and I have done some profiling before
22:31:53 <fresheyeball> but I never get a thing that actually shows me where in the code the problem is
22:33:33 <dmwit> Okay, well, identifying the problem is probably out of scope for these tools. But they can show you which parts of your code are taking the most time, which is usually a pretty good starting place for finding the problem yourself.
22:35:59 <dmwit> I guess I don't really understand what you're asking.
22:37:45 <dmwit> Like, what's an example of a thing you wish it would report but that it doesn't?
22:49:50 <fresheyeball> dmwit: even a rough idea of what module is slowing things down would be great
23:05:52 <jackdk> halogenandtoast: ghcid -c 'cabal new-repl componentname'
23:14:34 <fresheyeball> I think I used a program to view output
23:33:27 <fresheyeball> I recall
23:33:31 <fresheyeball> there was a gui for this
23:33:43 <fresheyeball> that showed HEC contexts and an event log
23:33:46 <fresheyeball> wtf was i called
23:33:52 <fresheyeball> was *it called
23:45:31 <c_wraith> fresheyeball, threadscope?
23:47:38 <fresheyeball> c_wraith: yes!
23:47:49 <fresheyeball> it's been a minute since I have had to profile
23:48:09 <fresheyeball> found a ton of projects that visualize .prof files
23:48:16 <fresheyeball> and they ALL look unsupported
23:48:18 <fresheyeball> ugh
23:49:13 <c_wraith> threadscope needs the event log, not a standard profile file
23:49:37 <c_wraith> I'm sure its instructions will say something about getting the event log.
23:53:51 <fresheyeball> I got threadscope working already
23:53:53 <fresheyeball> nix fts
23:53:56 <fresheyeball> nix ftw
23:56:56 <sm> huh.. nub . sortBy and nubSortBy from extra behave differently
