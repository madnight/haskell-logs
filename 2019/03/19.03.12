00:25:04 <dminuoso> Curious, why isn't there whenM in base?
00:27:35 <ski> @wiki ListT done right
00:27:35 <lambdabot> https://wiki.haskell.org/ListT_done_right
00:27:43 <dibblego> there are a lot of functions like that, where it wasn't really thought of at the time
00:27:56 <ski> mjrosenb : you can compare with that ^
00:28:28 <ski> `whenM :: Monad m => m Bool -> m a -> m ()' ?
00:28:32 <dminuoso> mjrosenb: mtl and transformers are orthogonoal packages that solve different problems.
00:28:34 <dminuoso> ski: Yes.
00:28:52 <dminuoso> mjrosenb: mtl for example has nothing to do with transformer stacks.
00:32:13 <dminuoso> maerwald: mtl is to transformers like Monoid is to Product.
00:33:59 <maerwald> I have no idea what that means
00:34:59 <dminuoso> transformers give rise to valid mtl typeclass instances.
00:35:26 <dminuoso> mtl typeclasses are not limited to transformers.
00:35:45 <maerwald> yes
00:37:17 <dminuoso> Product gives a valid Monoid instance, but Monoid is not limited to Product.
00:37:45 <dminuoso> mtl has just an unfortunate name, something like "monad-effects" might have been more appropriate.
00:38:45 <Cale> Well, mtl wasn't always separate from transformers
00:39:02 <Cale> That separation is relatively recent
00:40:02 <dminuoso> Fair enough.
00:40:51 <Cale> I'm not certain that the separation actually makes complete sense, but in any case, the mtl classes should probably be thought of as convenience classes for their respective transformers to build the primitives you actually want, rather than as something to be used directly most of the time.
00:42:03 <Cale> i.e. It usually turns out better to invent your own new classes defining the operations you're actually interested in, and only use the powers that mtl/transformers get you to implement those.
00:42:10 <dminuoso> I guess for library vendors mtl is a bit problematic since the polymorphism introduced can present optimizatoin challenges.
00:42:24 <Cale> ah, possibly
00:43:09 <dminuoso> (It's something edward discussed at large during a previous talk about monad transformer lenses in Warsaw)
00:44:27 <Cale> Also, there's a bit of (mostly amicable) politics involved regarding the maintainership of the packages, iirc.
00:50:37 * hackage http-conduit 2.3.6.1 - HTTP client package with conduit interface and HTTPS support.  https://hackage.haskell.org/package/http-conduit-2.3.6.1 (MichaelSnoyman)
00:56:07 * hackage conduit 1.3.1.1 - Streaming data processing library.  https://hackage.haskell.org/package/conduit-1.3.1.1 (MichaelSnoyman)
00:57:07 * hackage conduit-extra 1.3.1.1 - Batteries included conduit: adapters for common libraries.  https://hackage.haskell.org/package/conduit-extra-1.3.1.1 (MichaelSnoyman)
01:00:53 <newhoggy_> Does anyone know if the `diagrams` package on hackage will allow me to generate SVG images with CSS classes so I can style my diagram?
01:02:09 <newhoggy_> Also, I was hoping for `withName` to be able to do what I what, which is to find the subdiagram and re-style it, for example by changing its colours, it doesn't seem to work that way.
01:02:45 <newhoggy_> In the sense that `withName` will allow me to style the sub-diagrams parent, but not the sub-diagram itself.
01:10:05 <WereDictionary> Is there any practical advantage to coding in purely functional haskell over just writing functional code in a language that supports multiple approaches, say a lisp dialect? I can see the advantage in enforcing consistency, but are there any practical advantages?
01:10:29 <maerwald> WereDictionary: guarantees
01:10:35 <maerwald> so yes, mainly consistency
01:10:54 <maerwald> You can do functional programming in C++, but you can also do everything else. 
01:11:34 <maerwald> library authors may do whatever, your work colleagues may do whatever
01:14:04 <maerwald> And that is a practical advantage
01:16:40 <Ariakenom> WereDictionary: You get a compiler and libraries adapted to the style. no stack overflows, better performance
01:17:53 <dminuoso> WereDictionary: Haskell supports multiple styles too.
01:18:07 <dminuoso> WereDictionary: You can write full Python style imperative code with dynamic typing in Haskell just fine for example.
01:18:15 <maerwald> wat
01:18:37 <maerwald> please don't say -fdefer-type-errors
01:18:47 <dminuoso> No, Im talking about Dynamic.
01:19:13 <maerwald> That's not anywhere close imo
01:20:09 <maerwald> and python is not as dynamic as most people think :)
01:20:21 <dminuoso> maerwald: How so? In Python you can pretend every object to have type Dynamic. Any runtime checks can be considered fromDyn going into IO a, throwing if necessary.
01:20:43 <ski> in Clean, one can match on the thing corresponding to `toDyn'
01:20:47 <ski> @type dynApply
01:20:47 <maerwald> That's quite theoretical. Have you actually used it that way and compared how the workflow with that is?
01:20:48 <lambdabot> Dynamic -> Dynamic -> Maybe Dynamic
01:21:42 <ski> as if one could define that somewhat like
01:21:43 <Ariakenom> python duck types. and runs more on dicts than Dynamic
01:21:47 <ski>   dynApply (toDyn (f :: a -> b)) (toDyn (x :: a)) = Just (toDyn (f x))
01:21:48 <ski>   dynApply  _                     _               = Nothing
01:22:08 <dminuoso> Ariakenom: I guess thats a fair point.
01:22:40 <Ariakenom> I tested some python in Haskell, not seriously or anything. But it felt like writing a python interpreter
01:23:07 <ski> (by "duck types", what's meant here ?)
01:24:41 <Ariakenom> although if you're gonna write a python interpreter haskell felt like a pleasant choice
01:25:15 <Ariakenom> ski: well first of all I verbed it so that might be misunderstood
01:25:46 <maerwald> WereDictionary: haskell is not multiparadigm.
01:25:58 <WereDictionary> I gathered that much.
01:26:11 * dminuoso considered Haskell to be an excelling imperative language as well as an excellent functional language.
01:26:14 <maerwald> Some people may try odd thing, but those are... odd things.
01:26:35 <Ariakenom> I also think it's a great imperative language
01:26:35 <maerwald> And generally not the perception when you do practical programming as opposed to experiments
01:26:47 <dminuoso> WereDictionary: Haskell lends itself very well to writing highly imperative code. Plenty of large projects make use of this, GHC for example is filled with many imperative parts flinging around IO and IORefs.
01:27:10 <maerwald> haskell is very very tricky for imperative low level programming
01:27:27 <dminuoso> I think Haskell is much cleaner for low level programming than C. But YMMV.
01:27:30 <Ariakenom> ski: I just meant what the wikipedia page says, I think
01:27:50 <tdammers> "imperative" doesn't imply "low-level"
01:27:57 <WereDictionary> I suppose the IO at least clearly marks it as such? it would seem difficult to write imperative code without side-effects.
01:28:02 <maerwald> tdammers: indeed
01:28:03 <dminuoso> WereDictionary: Right.
01:28:15 <Ariakenom> ski: https://en.wikipedia.org/wiki/Duck_typing
01:28:35 <dminuoso> WereDictionary: I mean side-effects and imperative code are a bit orthogonal.
01:29:00 <dminuoso> WereDictionary: It also depends a bit on what you mean by "side-effects"
01:29:12 <WereDictionary> I may have misunderstood, then.
01:29:42 <WereDictionary> As I understand things, any change in state is an example of a side-effect, and imperative programming tends to involve constantly altering state.
01:29:48 <ski> (some people would call the I/O that `IO' execution does, side-effects ..)
01:30:14 <ski> (.. and depending on POV, i'd consider that either good or bad terminology)
01:30:28 <maerwald> WereDictionary: efficient imperative code is hard in haskell, imo. Low-level code is hard, because stdlib is odd and you have the indirection of the RTS, have to think of laziness etc. Much easier in a true imperative language like rust.
01:30:49 <maerwald> But if you are just looking for imperative style, yeah, you can have it
01:31:43 <ski> Ariakenom : i always think that "If it walks like a duck and it quacks like a duck, then it must be a duck" sounds like a structural type system, for OO (in this case), as in O'Caml (statically typed)
01:31:47 <dminuoso> WereDictionary: Imperative code is code that uses a command sequence, where commands somehow modify the state of the machine the code is run on.
01:32:10 <dminuoso> WereDictionary: This part alone can be captured by State in Haskell.
01:32:27 <ski> Ariakenom : but i'm not quite sure whether Python programmers have something like that in mind (except not statically checked, only existing in the minds and expectations of programmers)
01:32:47 <maerwald> Not many people use State in haskell ;)
01:33:10 <Ariakenom> ski: seems like the same thing to me
01:33:10 <ski> even fewer use Church in Haskell ?
01:33:19 <maerwald> ST is much more interesting
01:33:43 <gentauro> State and Church, what are we talking about? :|
01:35:39 <Ariakenom> ski: (I write a bunch of python)
01:36:34 <ski> Ariakenom : ok, ty
01:36:53 <ski> gentauro : Church and State representation, no ?
01:37:15 <dminuoso> maerwald: State/StateT and variants of it are very widely used.
01:37:22 <ski> Church being that `mu r. ..r..' is `forall r. (..r.. -> r) -> r'
01:37:22 <Ariakenom> ski: it was a politics joke :p
01:37:33 <Ariakenom> ... I think
01:37:34 <dminuoso> maerwald: Just as a drop in the bucket: https://codesearch.aelve.com/haskell/search?query=State&filter=Control.Monad.Trans.State.Lazy|Control.Monad.Trans.State.Strict|Control.Monad.State.Lazy|Control.Monad.State.Strict|Protolude|Control.Monad.State.Lazy|Control.Monad.State.Strict&precise=on
01:37:39 <ski> while State being that `nu s. ..s..' is `exists s. s * (s -> ..s..)'
01:37:56 <maerwald> src/full/Agda/Utils/Parser/MemoisedCPS.hs
01:37:57 <maerwald> Err
01:38:07 <ski> .. but perhaps that's not the `State' that maerwald was referring to :)
01:38:32 <maerwald> I'm also not sure such a code search is very useful :P
01:38:40 <maerwald> transformers is a different story
01:38:58 <ski> @quote church.and state
01:38:58 <lambdabot> No quotes for this person. Your mind just hasn't been the same since the electro-shock, has it?
01:39:03 <ski> @quote church.and.state
01:39:03 <lambdabot> GuySteele says: Some people prefer not to commingle the functional, lambda-calculus part of a language with the parts that do side effects. It seems they believe in the separation of Church and
01:39:03 <lambdabot> state.
01:39:13 <ski> bah
01:39:22 <ski> @quote shapr church.and.state
01:39:22 <lambdabot> shapr says: Haskell separates Church and state
01:39:24 <ski> that one
01:39:47 <ski> I'd rather say that in Haskell, Church and State are dual
01:40:45 <gentauro> Ariakenom: I saw you gut it xD
01:40:55 <gentauro> ba dum tsh
01:41:29 * Ariakenom claps hands
01:42:13 <gentauro> s/gut/got
01:42:53 <ski> Ariakenom : my version was a joke, or at least variation, of that joke ;)
01:46:05 <gentauro> 09:38 < ski> @quote church.and.state <- So Haskell is a language that is `political` correct? ba dum tsh
01:46:06 <MarcelineVQ> the real joke were the friends we made along the way
01:46:09 <gentauro> xD
01:47:42 * ski doesn't follow "is `political` correct"
01:55:51 <dminuoso> Say I want a monadic multiway if that short circuits on the first "True" result, say: f :: [(IO Bool, IO ())] -> IO () - whats the idiomatic way to encode this?
01:56:22 <dminuoso> Right now I have taken the approach of providing some using asum over some [MaybeT IO ()]
01:58:19 <merijn> dminuoso: Probably something from monad-loops
01:58:57 <gentauro> ski: https://en.wikipedia.org/wiki/Separation_of_church_and_state
01:59:12 <dminuoso> merijn: Ive been going through it unable to find something obvious.
01:59:16 <gentauro> therefore `political correct` :P
02:00:07 <ski> yea, i know about that concept
02:00:21 <dminuoso> merijn: firstM seems somewhat close though.
02:00:56 <ski> (partly derived from Aristotle's Civitas Dei vs. Civitas Mundi, via Luther, i think)
02:00:58 <dminuoso> % import Control.Monad.Loops
02:00:59 <yahb> dminuoso: ; <no location info>: error:; Could not find module `Control.Monad.Loops'; Perhaps you meant; Control.Monad.Co (from kan-extensions-5.1); Control.Monad.Cont (from mtl-2.2.2); Control.Monad.List (from mtl-2.2.2)
02:02:04 <dminuoso> :t (fmap . fmap $ snd) . firstM fst
02:02:05 <lambdabot> Monad f => [(f Bool, b)] -> f (Maybe b)
02:04:22 <gentauro> ski: please read what I wrote in `#haskell.scandi` ;)
02:10:13 <zincy> Say I define a Closed Type Family called Not and try to return a function which takes a Not Bool and returns a Not Bool I get a compile error https://pastebin.com/BUby3Ufz
02:13:33 <dminuoso> % f f = f 
02:13:33 <yahb> dminuoso: 
02:13:36 <dminuoso> % ;t f
02:13:36 <yahb> dminuoso: ; <interactive>:21:2: error:; Parse error: module header, import declaration; or top-level declaration expected.
02:13:41 <dminuoso> % :t f
02:13:42 <yahb> dminuoso: p -> p
02:14:36 <merijn> zincy: Well yes, that's wrong
02:14:50 <merijn> zincy: That's like trying to use "even Int" instead of "even 2" :)
02:15:13 <merijn> zincy: 'Not' takes 'True or 'False as argument, not 'Bool
02:15:52 <merijn> zincy: Also, that function it doing a lot of weird shadowing of 'f' *and* can't work more fundamentally
02:16:08 <zincy> Ok thanks
02:16:23 <merijn> zincy: All values have a type of kind *, but the result of applying "Not" is a type of kind "Bool"
02:16:35 <zincy> So how do I use the type family :D
02:16:57 <dminuoso> zincy: You could use it on phantom types
02:17:00 <merijn> zincy: You use it in a context of something that expects a type of kind Bool
02:17:24 <dminuoso> % :set -XDataKinds
02:17:25 <yahb> dminuoso: 
02:17:34 <merijn> zincy: Here's some examples of using types with kinds other than *: https://gist.github.com/merijn/39dc86e345e87276c523 https://gist.github.com/merijn/dc00bc7cebd6df012c5e
02:19:04 <zincy> So you can use typefamily constraints in type declarations?
02:19:06 <zincy> index :: (LessThan x n) 
02:19:15 <zincy> index :: (LessThan x n) => Vec n a -> Index x -> a 
02:19:19 <merijn> zincy: With ConstraintKinds, yes
02:20:28 <zincy> What does HList mean?
02:20:35 <merijn> zincy: heterogeneous list
02:20:37 <zincy> Ah
02:21:06 <zincy> So     Cons :: a -> HList l -> HList (a ': l) 
02:21:12 <zincy> a is any type?
02:21:31 <merijn> Cons is a constructor for a value of type "HList (a ': l)"
02:22:45 <zincy> So what is in the parenthesis?
02:22:46 <merijn> zincy: Cons takes a value of type 'a' and a value of type 'HList l' and creates a value of type "HList (a ': l)". That is, it tracks the types of each element in a type level list
02:22:55 <dminuoso> zincy: ': is a type level list constructor
02:23:33 <zincy> Is the tick because of the namespacing imposed by datakinds?
02:23:40 <merijn> zincy: Yes
02:23:43 <dminuoso> zincy: '[Int, Double, IO ()] ~ Int ': (Double ': (IO () ': '[])))
02:24:24 <zincy> This is cool
02:24:35 <merijn> zincy: Look at some of the examples at the bottom
02:24:51 <merijn> zincy: The example lists should help clarify :)
02:25:55 <zincy> :D
02:26:01 <merijn> zincy: The important thing to note is that DataKinds types *can't* describe actual values, as in Haskell values always have kind *. But they're very useful for type-safely tagging things 
02:26:03 <zincy> What is the [*] in zippable
02:26:36 <merijn> zincy: Well, what is '[Int, Bool, Double] ? It's a type level list of types of kind *, so what is the kind of a type like that?
02:26:52 <merijn> It's [*], a list of types of kind * :)
02:27:01 <ski> zincy : the kind "list of concrete types"
02:27:15 <merijn> zincy: The same way the type of "[True,False]" is [Bool]
02:27:29 <zincy> hehe so this is the promotion of types to kinds
02:27:53 * ski thinks the notation of the list type (/kind) is a bit unfortunate
02:28:03 <zincy> So [] is still a list at the kind level?
02:28:16 <ski> it's not a list
02:28:19 <ski> it's the kind of lists
02:28:39 <ski> `[Bool]' is not a singleton list, it's the type of lists, of `Bool's
02:28:56 <merijn> zincy: The problem with [] is that it uses the same syntax on the value and type level (and thus the type and kind level when lifted)
02:28:57 <zincy> Ok
02:28:58 <ski> `[*]' is not a singleton (type) list, it's the kind of lists, of `*'s
02:29:39 <zincy> Ah good example
02:30:47 <zincy> So [Bool, Int] is a type of kind [*]
02:30:56 <merijn> zincy: Right
02:31:52 <zincy> Is this a valid type of that kind - [[Bool, Int] Int] 
02:32:02 <merijn> zincy: Nope
02:32:13 <zincy> But its a heteregenous list :P
02:32:14 <merijn> zincy: Because the kind of [Bool, Int] is not * but [*]
02:32:36 <merijn> zincy: Same reason you can't have [True, [True, False]]
02:33:08 <zincy> Ah ok
02:33:30 <zincy> so ever element of the Hlist must be a *
02:34:08 <zincy> Whereas my example would be a [[*],*] which isn
02:34:14 <zincy> t a valid kind?
02:34:23 <merijn> zincy: Yes, but remember that all values must have kind * anyway, so you can't have a value whose type is something other than * anyway, so how would you put it in the list? :)
02:34:45 <zincy> Haha brilliant
02:35:01 <zincy> This is helping to solidify the basic concepts
02:35:21 <zincy> Im confused about promotion of types to kinds though
02:35:33 <zincy> I mean what does a kind of Bool actually mean?
02:35:46 <ski> there is no kind lists (sans `TypeInType', i suppose)
02:38:04 <merijn> zincy: Define "mean" ;)
02:38:06 <zincy> Is a type family essentially an intersection on multiple types, which is why we need to operate on their promoted data constructors
02:38:25 <merijn> zincy: A type family is, essentially, a type level function
02:38:33 <merijn> zincy: It takes an input type and returns a new type
02:39:16 <merijn> zincy: The kind Bool has two types in it 'True and 'False. It doesn't really have any other meaning, since there are no values with type 'True or 'False
02:39:24 <merijn> zincy: So you can really only use those on the type level
02:39:51 <merijn> zincy: But you can use type families (aka type level functions) to project one of these "useless" types back to a type of kind *
02:40:10 <zincy> Ah
02:40:32 <zincy> So you cant use these new types from type families at the value level you have to project back
02:40:49 <merijn> zincy: Consider "type family If (b :: Bool) :: * where { If 'True = Int; If 'False = Char }"
02:41:43 <merijn> zincy: "data IntOrChar (b :: Bool) where { AChar :: Char -> IntOrChar 'False; ANInt :: Int -> IntOrChar 'True }"
02:42:01 <ski> (in a dependently typed language, one wouldn't distinguish between the type `Bool', and the kind `Bool' used here)
02:42:18 <merijn> zincy: Now I can write "foo :: IntOrChar b -> If b; foo (ANInt i) = i; foo (AChar c) = c"
02:42:40 <ski> (and similarly, not distinguish between the values `False'&`True', and the types `False'&`True' used here)
02:42:44 <merijn> zincy: Now the return computes to "Char" when I pass "AChar 'c'" and to "Int" when I pass "ANInt 2"
02:43:14 <merijn> zincy: You can't write that function without type families, because you'd have no way to talk about a "conditional type"
02:43:23 <MarcelineVQ> ski: your unique quotation marks make your examples a little confusing in the presence of ' being part of DataKind syntax
02:43:29 <merijn> zincy: Similarly, look at the "apply" function in my HList gist
02:43:43 <ski> (hence i didn't explicitly use that here)
02:44:22 <zincy> Oh cool
02:45:23 <zincy> So data families have type constructors but type families dont?
02:45:32 <merijn> zincy: That works for any number of arguments, but that requires you to talk about types of function with an unknown number of arguments and how would you do that?
02:45:37 <merijn> zincy: Right
02:45:47 <merijn> zincy: Also, I highly recommend reading the "Fun with Type Functions" paper
02:46:14 <zincy> Thanks I will
02:46:59 <zincy> type family If (b :: Bool) :: * where  
02:47:06 <zincy> Why is the * there?
02:47:23 <merijn> zincy: To specify what kind of type If returns
02:47:23 <zincy> Return type?
02:47:27 <zincy> ah thanks
02:47:31 <merijn> I think it's optional, because * is default, but still
02:47:45 <ski> return kind
02:47:57 <zincy> Ok its making much more sense
02:48:07 <zincy> Its a kind declaration
02:48:10 <zincy> of the type function
02:48:18 <ski> (it's interesting that we use the C convention for specifying types, here)
02:48:26 <ski> (er, well .. kind, that is :)
02:49:50 <zincy> What is a good first exercise to understand type families and data families?
02:50:34 <merijn> zincy: Honestly, just randomly playing with things like those gists is a good start :p
02:50:43 <zincy> :)
02:50:54 <merijn> zincy: I learned most of this stuff from the Fun With TYpe Functions paper and (trying to) make those gists
02:51:13 <MarcelineVQ> oh hey the paper you mentioned covers associated types
02:53:33 <zincy> Interesting so the difference between ad hoc and parametric polymorphism regards whether the type given needs to be inspected
02:55:04 <merijn> zincy: Another gist I have of type level muckery: https://gist.github.com/merijn/6130082
02:55:07 <zincy> So kind declarations are the mapping described by "functional relations" in the paper
02:55:17 <zincy> Thanks
02:55:24 <ski> functional relations ?
02:55:40 <ski> (sounds like functional dependencies of multi-parameter type classes ?)
02:56:12 <merijn> zincy: Kinds are to types as types are to values
02:56:14 <zincy> whereas type constructors express specifically functional relations,”
02:56:26 <merijn> zincy: So kind signatures are to types as type signatures are to values
02:57:08 <zincy> Neat
02:57:57 <ski>   value ∶ type  ∷  type ∶ kind
03:15:50 <zincy> The use of the type keyword in typeclasses is weird
03:16:07 <zincy> On p.3 of that paper
03:16:46 <merijn> zincy: Because you normally want a resulting type to use within the class (I'm guessing it's about associated type families)
03:16:55 <zincy> Yep
03:17:27 <zincy> Is the associated type families an orthogonal thing?
03:18:34 <merijn> zincy: associated type families are more like a kind of hacky case specific syntax for defining a type family
03:19:29 <merijn> zincy: Anything you can do with associated type families you can do with just the regular ones, but they give you some convenient syntax for indicating they're intended for a specific typeclass
03:20:10 <zincy> What is generic programming?
03:20:23 <ski> the term can mean different things
03:20:41 <ski> (some people mean parametric polymorphism by it, e.g.)
03:21:00 <ski> (together with parameterized data types)
03:21:24 <zincy> Thanks
03:21:51 <ski> sometimes, one intends algorithms that can work on "any" data structure
03:22:42 <ski> like e.g. serialization that is done by reflecting on how many data contructors a data type has, which argument types they have, &c.
03:23:14 <Ariakenom> sometimes called reflection
03:23:17 <ski> (this has also been called "polytypic" programming. the `Generic' and `Data' type classes are related to things like this)
03:23:49 <ski> <http://www.cse.chalmers.se/~patrikj/poly/>
03:24:01 <zincy> What is serialization?
03:24:03 <zincy> :)
03:24:34 <ski> converting an internal data structure into a format that can be stored on disk, sent over a (process or network) pipe, &c.
03:24:54 <zincy> Thanks
03:25:12 <ski> (also the terms "marshalling","pickling" have been used)
03:25:36 <Ariakenom> encoding, unparsing
03:26:14 <ski> (also the associated reverse step, getting it back into an internal representation in the process)
03:26:21 <zincy> So conversion between formats.
03:26:39 <ski> conversion between internal format and external formats
03:26:51 <zincy> Yeah
03:26:53 <ski> or s/internal/native/, if you prefer
03:27:09 <ski> (with s/external/foreign/, i suppose)
03:27:30 <zincy> So the key is that the two systems don't understand each others formats
03:27:50 <ski> usually it involves converting, in some way, to bits
03:27:59 <Ariakenom> "abstract form encoded into concrete form" works for text at least
03:28:28 <ski> (with text regarded as a special case of bits)
03:29:16 <ski> `Show', together with `Read', can be used as a very simple serialization mechanism
03:29:37 <Ariakenom> (I meant Text-abstract and utf8-concrete)
03:29:39 <ski> (not terribly efficient)
03:41:26 <zincy> I am trying to get my head around creating a bound tree
03:41:48 <zincy> Say I wanted to restrict the count of nodes in a tree in the type system
03:42:23 <zincy> Would I first define the natural numbers in the type system and then write a type function which takes a Tree and Nat and returns a Tree Nat
03:54:48 <siraben> How can I combine two monads (say, Maybe and the Parser monad)?
03:55:20 <siraben> I'm writing an evaluator for a simple function language from the textbook Essentials of Programming Languages, and there's various other things that would be modelled with monads later, like store-passing interpreters, continuation-passing interpreters etc.
03:55:48 <siraben> But then combining State, Maybe and so on seem awkward
03:57:01 <merijn> siraben: Why do you need Maybe inside your parser?
03:59:06 <siraben> merijn:  I meant the evaluator
03:59:24 <siraben> Or is it sufficient to define types for each stage? Strings, then expressions, then values
03:59:35 <siraben> eval :: Expr -> Env -> Val
04:00:18 <merijn> siraben: I don't really see why you'd have to mix Maybe and Parser for that, though? Combining State and Maybe can be done via transformers, but also not sure that's necessary for what you want
04:00:50 <siraben> merijn:  for a repl, to signal that the expression was invalid
04:01:01 <siraben> parseExpr :: String -> Maybe Expr
04:01:41 <ski> that's not "inside" your parser, now is it ?
04:01:50 <siraben> Right, I see.
04:02:03 <ski> (and would you need to combine that with `State' ?)
04:02:07 <siraben> Ok, and what about the evaluator?  I want to be able to have a store later but then also have exceptions
04:02:16 <siraben> Nah the parser should be pure
04:02:36 <siraben> eval :: Exn (Store Expr) -> Val
04:02:56 <ski> @unmtl StateT s (ErrorT e m) a
04:02:56 <lambdabot> s -> m (Either e (a, s))
04:02:58 <ski> @unmtl ErrorT e (StateT s m) a
04:02:58 <lambdabot> s -> m (Either e a, s)
04:03:10 <ski> (imagine it said `ExceptT' instead of `ErrorT')
04:04:06 * hackage instrument-chord 0.1.0.11 - Render Instrument Chords  https://hackage.haskell.org/package/instrument-chord-0.1.0.11 (AlanHawkins)
04:05:08 <siraben> :k ErrorT
04:05:09 <lambdabot> error:
04:05:09 <lambdabot>     Not in scope: type constructor or class ‘ErrorT’
04:05:51 <ski> @kind ExceptT
04:05:52 <lambdabot> * -> (* -> *) -> * -> *
04:06:57 <siraben> @type ExceptT
04:06:58 <lambdabot> m (Either e a) -> ExceptT e m a
04:08:49 <siraben> Beautiful.
04:08:56 <siraben> What's the categorical construction of ExcepT?
04:09:01 <siraben> ExceptT*
04:33:28 <LaydaLeyna> hi
04:34:09 <LaydaLeyna> hi
04:41:38 <zincy> hi
05:27:53 <phadej>  /wg hpc 
05:27:55 <phadej> oh
05:52:13 <fen> % :t sort . toList
05:52:13 <yahb> fen: ; <interactive>:1:8: error:; Ambiguous occurrence `toList'; It could refer to either `Data.Foldable.toList', imported from `Data.Foldable'; or `GHC.Exts.toList', imported from `GHC.Exts'
05:52:28 <fen> % :t sort . Data.Foldble.toList
05:52:29 <yahb> fen: ; <interactive>:1:8: error:; Not in scope: `Data.Foldble.toList'; Perhaps you meant one of these: `Data.Foldable.toList' (imported from Data.Foldable), `Data.Foldable.concat' (imported from Data.Foldable); No module named `Data.Foldble' is imported.
05:52:39 <fen> % :t sort . Data.Foldable.toList
05:52:39 <yahb> fen: (Ord a, Foldable t) => t a -> [a]
05:53:21 <dminuoso> Im looking for a function `pack :: Text -> Text -> ByteString` in the sense of perl/python/ruby pack, where I can specify some format string and have the function produce an appropriate ByteString.
05:54:07 <fen> is it reasonable to expect that the cost of traversal is not repeated during sort . toList ?
05:54:34 <fen> dminuoso: like read?
05:55:12 <dminuoso> Maybe it would be more appropriate as String -> ByteString.
05:55:19 <dminuoso> Although not quite.
05:55:48 <dminuoso> fen: For example in Ruby you could do: ["a", "b", "c"].pack("a3a3a3") #= "a\000\000b\000\000c\000\000"
06:00:48 <fen> do you not want to read it into a datatype and the use its Binary instance to "encode" it?
06:00:52 <fen> :t encode
06:00:53 <lambdabot> error: Variable not in scope: encode
06:00:59 <fen> % :t encode
06:01:00 <yahb> fen: ; <interactive>:1:1: error: Variable not in scope: encode
06:01:11 <fen> % :t Data.Binary.encode
06:01:12 <yahb> fen: binary-0.8.5.1:Data.Binary.Class.Binary a => a -> BSL.ByteString
06:02:07 <fen> encode . read wont give a type because its ambiguous which intermediate type you want to encode it as 
06:04:14 <dminuoso> fen: So pack usually receives some kind of "template" string, which is used how to interprete the source string.
06:04:50 <fen> well here that information would be given by the intermediate datatype and its read and binary instances
06:05:04 <dminuoso> fen: Well sure, though Id recover a custom data type for any possible format.
06:05:11 <dminuoso> fen: I dont want to handroll those instances in the first place.
06:05:43 <fen> isnt that easier than writing an interpreter for these template strings?
06:05:54 <fen> idk maybe we have such a thing already 
06:06:00 <dminuoso> fen: Thats what Im hoping for. ;)
06:07:03 <fen> it would seem unhaskell like though
06:08:23 <merijn> dminuoso: What are you trying to do?
06:08:25 <fen> wouldnt it always consist of generating an intermidiate datatype and its read and show instances?
06:08:36 <dminuoso> fen: Why are you presuming there must be any read/show involved?
06:09:02 <Ariakenom> The API reminds me of the "formatting" lib, but that does string output
06:09:07 <fen> not show, binary, sorry
06:09:12 <sshine> I forgot: if I want to fold a Data.Text, is mono-foldable the best way?
06:09:23 <dminuoso> pack "h2h2h2h2h2h2" ["84", "56", "c6", "c6", "f6", "12"] = "Hello!"
06:09:36 <merijn> sshine: There's already a fold in Data.Text iirc?
06:09:46 <merijn> dminuoso: I'm not sure what that's supposed to mean
06:10:43 <Ariakenom> dminuoso: im familiar with struct.pack in python but this seems rather different
06:11:16 <sshine> merijn, there is!
06:11:20 <dminuoso> merijn: A rough sketch is this: The first argument is the formatting string. That specifies how each element in the array is to be interpreted. lower case h means hex string, low nibble first. h2 means we have two units to consume. then we repeat that pattern to let the pack function know how to interpret the rest
06:11:47 <merijn> dminuoso: The goal being what?
06:12:09 <merijn> This just seems like a shitty string based replacement for Data.Binary.Put?
06:12:17 <dminuoso> merijn: producing a binary sequence according to some rules.
06:12:54 <merijn> dminuoso: Right, but that's what Data.Binary.Put already lets you do?
06:13:57 <sshine> dminuoso, this is inspired by Perl, yes?
06:14:03 <fen> oh you just want to choose the format?
06:14:17 <dminuoso> merijn: Put is just about the outputting part, pack has reinterpretation logic builtin. That is `h2` is closer to type punning, where you simply interpret the string as a "2 byte, lower nibble first, hexadecimaal string"
06:14:26 <merijn> dminuoso: Like, presumably you're missing something in binary? But the question is: what?
06:14:28 <sshine> Erlang has some pretty neat binary format pattern matching.
06:14:35 <fen> so its like a list of chars and proxy types ?
06:14:39 <fen> in pairs 
06:15:07 <dminuoso> merijn: And yes, https://perldoc.perl.org/functions/pack.html
06:15:19 <merijn> dminuoso: Your current example just seems "mapM_ putWord8"
06:15:22 <dminuoso> Or this was from sshine actually, couldnt properly read it with these colors.
06:15:29 <fen> is that so useful? why would you want to change the word length for each char?
06:15:55 <dminuoso> merijn: Except ("84" :: String)
06:16:11 <fen> does this interspersed formatting flag give any other functionality?
06:16:19 <dminuoso> fen: well the usefulness stems from having many different reinterpretation rules.
06:16:32 <merijn> dminuoso: Well, that's just a matter of removing the quotes from your list, no?
06:16:34 <sshine> dminuoso, do you know Erlang's bit syntax? http://erlang.org/doc/programming_examples/bit_syntax.html
06:16:48 <dminuoso> sshine: yes.
06:17:41 <merijn> dminuoso: I still don't understand what you want to do and how this string based syntax is supposed to help
06:18:18 <fen> seems like a kind of way of specifying datatypes to be read into as part of the string
06:18:33 <dminuoso> merijn: So for string directives I get to pick "a" for biunary string, "B" for bitstring, "H" for hexadecimal string, m for base64 encoded string.
06:18:37 <dminuoso> and so forth
06:18:39 <fen> if you just focus on that part instead of the subsequent binary encode
06:19:30 <fen> but combining both aspects restricts the specified intermediate datatype via its binary instance only
06:22:48 <dminuoso> merijn: Im just looking for a direct equivalent of the perl/ruby style pack.
06:22:51 <dminuoso> Nothing more.
06:23:05 <fen> something like data BinariesList = BinariesList Binaries BinariesList | Empty; Binaries = Word8 | Word16 ...
06:24:29 <fen> dminuoso: seems like it would need a datatype with a binary instance corresponding to every control char of the desired spec
06:24:36 <fen> we might not even have all those
06:26:26 <fen> the most difficult part seems to be to "read" a proxy type...
06:28:49 <fen> <fen> is it reasonable to expect that the cost of traversal is not repeated during sort . toList ?
06:32:44 <fen> like, suppose (toList) traverse descended through a really long tree to get to just a few values all close together, then would the sorted list have to redecend over the tree each time?
06:32:55 <fen> for each value
06:34:49 <fen> its easy to see how the traverse could use fusion to bring the external function into the result of the toList applying it toeach value as it was encountered. but if the order is changed, this isnt an option, so does the compiler make a copy of each result?
06:35:27 <fen> like, does quicksort force strict evaluation of the toList, which otherwise could be fusioned into
06:57:43 <heath> how do others here hop around a complex haskell program? e.g. does anyone use hasktags?
06:58:25 <Cale> I use hasktags primarily, yeah
06:58:31 <heath> ..or do you use some IDE or IDE-like program functionality which does this for you?
06:58:50 <merijn> Honestly, I use the_silver_searcher mostly in any language :p
06:59:05 <Cale> For another chunk of the functionality an IDE would give me, I use ghcid
06:59:53 <Cale> (Which just watches your project and in the background re-runs a GHCi command every time it changes, reporting any errors and warnings it finds to you.)
07:03:00 <heath> lushtags is new to me
07:08:03 <__monty__> merijn: Even for same-file searches?
07:11:06 <gt[m]> When profiling, is non-cpu time like `threadDelay` included or not?
07:14:02 <dminuoso> __monty__: You should try ripgrep, it makes ag look so slow in comparison. :o)
07:14:23 <__monty__> dminuoso: Shhh, I was building up to that : >
07:14:43 <dminuoso> __monty__: ohh, Im sorry.
07:14:48 <__monty__> No, but really I was wondering whether I should look into integrating it in my vim workflow : )
07:34:12 <merijn> __monty__: In a specific file I'm usually just using vim
07:35:19 <merijn> __monty__: incremental search with / or using */# works well enough within a single file
07:37:48 <sshine> I tried adding mono-foldable-0.1.0.2 to extra-deps in stack.yaml, but it continues to warn that I need base-4.11.1.0, so I figure: this package, mono-foldable, from 2013. does anyone use it with base-4.12.0.0?
07:42:36 * hackage reanimate 0.1.4.1 - Animation library based on SVGs.  https://hackage.haskell.org/package/reanimate-0.1.4.1 (DavidHimmelstrup)
07:43:38 <glguy> sshine: that package is deprecated
07:59:29 <dminuoso> Is GHC giving me linker errors in cabal v2-build when I forget to specify an other-module a feature?
07:59:48 <merijn> dminuoso: As opposed to?
08:00:12 <dminuoso> merijn: Dunno, maybe giving me a diagnostic "Module Blah not found in other-modules in your .cabal file"?
08:00:26 <merijn> dminuoso: That only happens if you import said module in the same codebase
08:00:47 <dminuoso> merijn: I have that problem.
08:01:11 <dminuoso> merijn: Im in project Foo, and inside Foo Im importing from another module - forgot to specify it in my cabal file
08:01:15 <dminuoso> (.data.rel.ro+0x58): undefined reference to `modgudzm0zi1zi0zi0zminplacezmmodgudzmlib_ModgudziUserziAccounting_accountingzq2_closure'collect2: error: ld returned 1 exit status
08:01:27 <dminuoso> (Well and some more)
08:01:28 <merijn> dminuoso: Is that module in the same component/package?
08:02:14 <dminuoso> merijn: Yes. I mean I do get some warning somewhere in the middle between thousands of lines of info output from GHC. Its near impossible to connect the dots unless you already know whats going on.
08:02:29 <dminuoso>  These modules are needed for compilation but not listed in your .cabal file's other-modules: Modgud.User.Accounting
08:02:59 <dminuoso> Depending on the compilation order it might be buried between compiling  hundreds of files
08:03:01 <merijn> dminuoso: Pretty sure that should be an error
08:03:15 <merijn> dminuoso: Do you have a minimal example?
08:03:28 <dminuoso> merijn: Ill prepare one tonight, gotta go run.
08:04:31 <cocreature> dminuoso: if you have a sufficiently new version of cabal and GHC it should give you a decent error
08:04:51 <cocreature> via the home-modules stuff that was added to GHC
08:15:18 <sshine> glguy, ah, I realized. and I realize that mono-traversable has folds, too.
08:22:06 * hackage ghcid 0.7.2 - GHCi based bare bones IDE  https://hackage.haskell.org/package/ghcid-0.7.2 (NeilMitchell)
08:26:00 <leshow> does anyone know if you can use candidate packages from hackage
08:26:06 <kuribas> don't know how recommended against me using a monad stack as parser...
08:26:13 <kuribas> phadej maybe?
08:26:32 <kuribas> so my script kept hanging, I swapped regex-applicative for my monad stack, and now it works again!
08:26:45 <kuribas> not blazingly fast, but good enough
08:28:43 <kuribas> if regex-applicative is supposed to guard me from non-termination, it didn't work...
08:32:17 <merijn> leshow: Not afaik
08:33:17 <merijn> leshow: You can use unreleased packages via git commits using v2-build, though
08:35:18 <bioeth> Just wondering if there is any alternative to text-icu library that doesn't require any extra dll files. I'm using it for a text processing pipeline on Windows that converts cp1252 bytestring into cp1252 unicode, and then into utf8 bytestring (also the opposite direction, i.e. utf8 bytestring -> utf8 unicode -> cp1252 bytestring). 
08:37:01 <merijn> bioeth: "utf8 unicode" isn't really a thing, the intermediate value is just "unicode"
08:37:33 <bioeth> Sorry. yes. that's true.
08:37:37 <merijn> bioeth: Anyway, I don't think there's another package for windows encodings for cp1252
08:38:01 <merijn> Text has encodings for the common utf ones, but I don't think it will add other more obscure ones, because doing that stuff correctly is hard
08:39:14 <bioeth> I think it's one of the limiting factors to use Haskell on windows environment
08:39:42 <bioeth> text-icu library doesn't seem to be maintained for new ghc versions
08:42:21 <merijn> Maintained how? I don't think there's much to update unless it stops building?
08:42:42 <merijn> bos is rather busy, but I don't think any of his packages have stopped working
08:43:00 <Solonarv> side note: managing .dll dependencies should be fairly simple on windows, just plop them net to your .exe
08:43:37 <bioeth> It's a small bug but I don't think text-icu works on ghci any more.
08:46:02 <bioeth> I'm a bit anxious starting from a small bug like that it might suddenly stop working all together one day. 
08:47:37 <Cale> It's probably not *too* hard to write a cp-1252 decoder, given that there are only 27 differences from the first 128 unicode code points.
08:48:23 <merijn> bioeth: Well, I'm sure everyone would welcome someone fixing that bug and keeping on top of it ;)
08:48:33 <Jamie_> I've got a multi-threaded program, with 9 threads, running on a 6 core (12 thread machine). So far, I've found that -N8 provides the best runtime, but garbage collection is a big time sink... Any ideas on what flags to pass to the RTS to improve GC throughput?
08:48:47 <merijn> Jamie_: -qg to disable parallel GC
08:48:53 <bioeth> I wish I could take over the library but I'm not good enough to do so..
08:48:56 <Cale> So you can just start with Data.ByteString.Char8, and then look for those values in the 0x8_ and 0x9_ range which are to be interpreted differently and translate them.
08:48:58 <Jamie_> That made it worse
08:49:13 <merijn> Jamie_: Really? Fascinating
08:49:47 <merijn> Jamie_: Must be the first time I've seen that. If you dive into the GHC user guide RTS section there is some stuff on how to tweak the number of parallel GC threads separate from the number of capabilities
08:49:50 <Jamie_> Yeah, well over 3x as slow
08:50:06 * hackage i3ipc 0.1.0.0 - A type-safe wrapper around i3's IPC  https://hackage.haskell.org/package/i3ipc-0.1.0.0 (leshow)
08:50:08 <bioeth> Thanks Cale for the guide all the time
08:50:53 <dminuoso> % :set -XGeneralizedNewtypeDeriving
08:50:54 <yahb> dminuoso: 
08:50:55 <dminuoso> % newtype List a = List { runList :: [a] }
08:50:56 <yahb> dminuoso: 
08:51:09 <dminuoso> % newtype FList a = FList { runFList :: List a } deriving Monad
08:51:10 <yahb> dminuoso: ; <interactive>:31:57: error:; * No instance for (Monad List) arising from the 'deriving' clause of a data type declaration; Possible fix: use a standalone 'deriving instance' declaration, so you can specify the instance context yourself; * When deriving the instance for (Monad FList)
08:51:21 <dminuoso> Is there a way to do this? Or do I have to really write them out by hand? 
08:53:13 <lyxia> DerivingVia
08:54:06 <fryguybob> Jamie_: You might try adjusting the heap size and stack size parameters depending on your workload.
08:54:23 <dminuoso> lyxia: Mmm, Im sadly on 8.4 still.
08:54:38 <dminuoso> (Project dependencies are preventing the upgrade)
08:55:12 <Jamie_> Well, throughout the execution, I churn through 3.8TB in the heap, with maximum residency 163MB
08:55:31 <Jamie_> 5.3GB per MUT second allocation rate
08:56:03 <lyxia> dminuoso: then you're stuck with the manual way :(
08:56:30 <merijn> Jamie_: The GHC user guide also has a bunch of stuff on tweaking things like heap sizes, etc. if you haven't read it yet
08:56:30 <Ariakenom> Jamie_: what fraction of execution time does it take?
08:56:47 <cocreature> dminuoso: now you have a reason to upgrade :)
08:57:20 <Jamie_> 419/768s, so about 54% of the runtime
08:57:22 <Ariakenom> during adventofcode I think I had 2GB/S with 3% GC time
08:57:25 <Solonarv> dminuoso: of course, you can manually write the instance that DerivingVia would generate
08:57:44 <dminuoso> Solonarv: Well in my case it'd all be just `coerce`
08:57:58 <Solonarv> in this case: instance Monad FList where (>>=) = coerce ((>>=) @[]); return = coerce (return @[])
08:58:04 <Ariakenom> Jamie_: ouch
08:58:04 <Jamie_> In actual CPU time its more like 4492/5219s
08:58:07 <Solonarv> yes indeed, that's what DerivingVia does too
08:58:28 <dminuoso> Solonarv: I think its around 15 instances I'd have to handwrite this way.
08:58:32 <Solonarv> oof.
08:58:45 <Solonarv> perhaps you could have TH generate them
08:59:01 <dminuoso> I think the TH code would exceed writing them by hand.
08:59:42 <Solonarv> hm, probably
08:59:52 <dminuoso> Perhaps its time to rethink my approach.
09:01:56 <Jamie_> ok, -ki10M provided a speedup
09:02:57 <Jamie_> about 15% improvement
09:06:17 <ClaudiusMaximus> Jamie_: my default action when GC is taking too much time (with high "bytes copied in GC" count) is to increase the size of the allocation area with -A (this is per thread, i tend to start with -A16M but i have plenty of RAM)
09:11:00 <mjrosenb> ok, possibly silly question.
09:11:26 <Jamie_> ClaudiusMaximus: Increasing A does improve the garbage collection time, but reduces runtime
09:11:28 <mjrosenb> how do I [a] -> ListT (State foo) a?
09:13:19 <Ariakenom> Jamie_: "This is particularly useful in conjunction with larger -A values, for example -A64m -n4m is a useful combination on larger core counts (8+)." from the user guide
09:13:23 <Ariakenom> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html
09:13:54 <mszh> is this possible in haskell: have two modules, List.hs that has a List constructor, and Collections.hs that exports a factory method for creating Lists. Collections need access to the List constructor, so it has to be exported, but I don't want List's constructor to be publicly accessible, so is it possible to have what java calls package-level access to List? Putting everything in one module is obviously one solution but is it 
09:13:54 <mszh> the only one?  
09:14:56 <tdammers> you can have an "internal" module that you do not expose as part of the package's API (i.e., you put it in "other-modules" instead of "exposed-modules" in the .cabal file)
09:15:15 <merijn> mszh: You can re-exporting existing modules
09:15:32 <tdammers> keep in mind though that this isn't exactly the same as a factory in java
09:15:43 <merijn> mszh: So you could have List.Internal which defines the List constructor then List reexports the safe parts of List.Internal and Constructor imports List.Internal
09:15:59 <Ariakenom> mszh: importing something to Collections does not mean you have to export it
09:17:14 <mjrosenb> no takers on the ListT?
09:18:32 <mszh> when you say List.Internal what's that? another module? I still don't see how this helps
09:18:50 <merijn> mszh: Another module, yes
09:19:00 <Ariakenom> Jamie_: "-H -n4m" might be interesting. I've never used -H so I don't really know
09:19:14 <merijn> mszh: Like I said, you can re-export things from modules that are internal to the package (and can't be imported outside the package)
09:20:01 <Jamie_> Ariakenom: 30% slower
09:20:06 * hackage stratosphere 0.33.0 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.33.0 (jdreaver)
09:20:07 <merijn> mszh: So you move your current code from List to List.Internal and export everything, then List and Constructors import from List.Internal and re-export the relevant safe API
09:20:47 <mszh> i understand that, but i dont see how's that any different from having only List and it exporting only the safe stuff
09:21:08 <mszh> what i want is that List's exports are only visible to my own other module (Collections), but not the whole world
09:21:09 <Ariakenom> Jamie_: -A64m? darn
09:21:10 <merijn> mszh: Well, your problem was that Constructors couldn't access the internals then, no?
09:21:38 <mszh> so perhaps i should look into other-modules vs exposed-modules
09:21:49 <merijn> mszh: The different is that you don't export List.Internal from your package, so no one except modules inside the package can import List.Internal
09:21:54 <merijn> s/different/difference
09:22:15 <mszh> that sounds better 
09:23:23 <mszh> so basically there're 2 kinds of exports- module and package. i would export List as a module, use it in Collections, and then only package-export Collections
09:23:39 <merijn> mszh: For example, yes
09:23:47 <mszh> so there's nothing like Java's package-level access 
09:23:52 <mszh> cool, thanks for the help
09:26:49 <Jamie_> Yeah, increasing A gives a healthy 40% reduction in GC time, but doubles the time taken to actually do the work
09:26:53 <Solonarv> mszh: you can see an example of this in the widely-used 'containers' package - https://github.com/haskell/containers/blob/master/containers.cabal#L51-L90
09:27:19 <Solonarv> although here the .Internal modules are actually available, so that if you really need to you can hack around in the internals
09:27:25 <fryguybob> Jamie_: If you can get threadscope working that can be insightful.  Also (for my own curiosity) what thread level synchronization are you using?  STM, MVars, IORefs?
09:27:48 <Jamie_> fryguybob: I'm using Par monad IVars
09:28:08 <Jamie_> The threads themselves are embarresingly parallel, so no communication until the final reduction
09:29:20 <fryguybob> Jamie_: Do they share unevaluated thunks at the start?
09:30:27 <Jamie_> fryguybob: I don't think so, they are each given one branch of a 9 way tree, each branch is entirely independent from the other branches
09:45:43 <inkbottle> Are elementary Agda questions OK?
09:47:47 <glguy> inkbottle: There's a channel for Agda questions: #agda
09:49:19 <phadej> :)
09:50:39 <inkbottle> glguy: yes, but more people here
09:50:58 <glguy> That's true, but it's not relevant to what's on topic
09:52:02 <inkbottle> (like Agda sort of offspring of Haskell? OK, you win)
10:04:27 <Alibert> Hey, say a standard haskell implementation of quicksort was given: https://gist.github.com/rynkk/d273077d1fb52be03509f03d14f14ca7 , now you are being asked to make this qsort algorithm only use ONE equation, anyone can maybe hint me at how to do that?
10:04:43 <johnw> is this homework?
10:04:59 <johnw> hint: case
10:05:00 <Alibert> no, it is practicing
10:05:17 <Alibert> okay, that is what I was considering, too, I'll have a deeper dig, thanks
10:14:25 <byorgey> also, that version of quicksort is subtly broken if there can be duplicate elements...
10:23:23 <Alibert> byorgey, yeah, this implementation is not supposed to have duplicates in the result
10:23:38 <Alibert> johnw, is this what I was looking for? https://gist.github.com/rynkk/72d1f4064fdccb3643b877f63a09da23
10:25:30 <byorgey> Alibert: no, using guards is a step backwards because you have to use 'head' and 'tail' etc.
10:26:28 <byorgey> Alibert: johnw's hint was a good one.  guards are not the same as 'case'.
10:26:49 <byorgey> Alibert: and gotcha re: duplicates. =)
10:31:01 <Alibert> byorgey, got it (I believe) : https://gist.github.com/rynkk/8411968a49bbcb2ca0b14cc7a7d49a58 Is this more like it?
10:34:10 <Alibert> (replace the qsort with fd ofcourse)
10:35:35 <asheshambasta> I'm looking at http://hackage.haskell.org/package/servant-0.14.1/docs/Servant-API-ContentTypes.html#t:MimeUnrender and I see that `mimeUnrender` also relies on `String` as the error type. Is there a way to use a custom type there to indicate errors? For example, if my Errors are Aeson `Value`, what is the supposed workaround therE?
10:35:39 <asheshambasta> there* 
10:36:16 <byorgey> Alibert: yes, that's it
10:36:28 <Alibert> thanks :)
10:36:53 <byorgey> Alibert: so when you write  qsort [] = ...    qsort (a:xs) = ...    it actually turns into this kind of 'case' expression
10:37:25 <Alibert> yes, kind of abstract to grasp as a beginner but actually pretty simple
10:37:34 <byorgey> yep
10:37:53 <byorgey> Alibert: to be clear, writing it with multiple equations is the nicest way to write it, case is more 'low-level'.  But case does come in handy sometimes and it's good to know about.
10:38:40 <byorgey> case is handy especially when you want to pattern-match on the result of some expression which isn't already a function argument.
10:39:25 <byorgey> f x y = case someComplicatedFunction (3*x + y) of ...
10:39:47 <Alibert> Makes sense
10:39:55 <Alibert> appreciate you
10:40:17 <asheshambasta> actually, I see there's a PR https://github.com/haskell-servant/servant/pull/1053
10:40:34 <__monty__> inkbottle: Agda might be welcome in #haskell-offtopic : )
10:41:30 <__monty__> asheshambasta: That PR wouldn't help you though? You can't override the synonym, can you?
10:41:43 <asheshambasta> __monty__: correct 
10:42:22 <asheshambasta> I'm a bit surprised that "String" is considered a sufficient type to carry error information in so many libraries though; or am I missing something very obvious? 
10:43:10 <dminuoso> Does every Monad in Hask give rise to a monad transformer
10:44:04 <__monty__> asheshambasta: Don't think you're missing anything. Most people probably just go with what seems to work.
10:45:06 <geekosaur> asheshambasta, the biggest problem there is that most useful typeclasses have at most one slot for a user specified type, so at some point one type ends up being "fixed" when you have two.
10:45:34 <Solonarv> dminuoso: I don't think so, but I don't have a counterexample handy
10:45:45 <Cale> dminuoso: I can't see any reason why that ought to be true, but it does hold for most of the practical examples of monads you run into.
10:45:47 <geekosaur> you can't have an Applicative or Monad instance for Either, but you can for Either SomeSpecificTypeHere
10:45:49 <lyxia> dminuoso: IO
10:45:56 <Cale> One which might not work is Behavior from FRP.
10:47:22 <Cale> IO doesn't give a transformer in a practical way, but it could do so in principle, were it defined as a free monad.
10:47:59 <Solonarv> it could with its current (GHC) definition, too - roughly, IO a = State (State# RealWorld) a
10:48:04 <asheshambasta> __monty__, geekosaur: https://gist.github.com/asheshambasta/7c7ae83d3beeba93d0203fc1e2969792, shouldn't something like this suffice though? 
10:48:24 <Cale> Solonarv: Well, that hack likely doesn't keep working nicely
10:48:38 <Cale> You'll end up triggering effects at the wrong times
10:48:53 <asheshambasta> my judgement is that: add methods to serialise errors to String/JSON etc. in IsServantAPIErr and allow users to associate errors with their MimeTypes. 
10:50:39 <Cale> Solonarv: Like, consider what happens with IOT [] for example.
10:50:56 <asheshambasta> AFAICS, String is overly limiting for several reasons: it means that if I'm building anything web facing with Servant, I need to resort to: 1. throwing String errors at my rest API clients; 2. somehow forcefully attaching Content-Type: application/json to the rendered string, and ensure that I render my errors as proper JSON strings; 3. have a user-facing HTTP layer that does the JSON-ing for me. 
10:53:02 <sclv> monads don't typically "give rise" to transformers at all
10:53:16 <sclv> in the sense that you have to equip them with distribution laws
10:53:22 <sclv> and multiple distribution laws are often possible
10:54:17 <sclv> so i think there should be always at least one way in which the composition of monads is a monad (excepting "magic" stuff like IO, STM, etc), but typically there will be many ways
10:54:28 <Cale> Of course, for a given monad M we can consider the set of transformers T for which T Identity ~= M
10:55:58 <Cale> If IO were Free IOF, then we would have FreeT IOF, but even then, that type likely wouldn't be terribly useful.
10:56:22 <johnw> sclv: the exact conditions have been documented
10:56:59 <johnw> and I think there are at least 4 known "classes" of transformers that are known to be lawful in the literature
10:57:07 <Solonarv> % newtype IOT m a = IOT (State# RealWorld -> m (# State# RealWorld, a #))
10:57:08 <yahb> Solonarv: 
10:57:26 <Solonarv> ^ this is definable and can be given a monad instance, but I'm not sure if you can do anything sensible with it
10:57:46 <johnw> for example, if your monad arises from an adjunction (F ⊣ G), you can always insert another monad between: G (M (F A))
10:58:23 <lyxia> Solonarv: IO assumes the RealWord token is used linearly, turning it into a transformer totally breaks that invariant.
10:58:51 <Solonarv> ah, so you can't do anything sensible with it in general
10:59:47 <Solonarv> (of course if you choose m ~ Identity or m ~ ((->) e) there is no problem, but then you just get back IO resp. ReaderT e IO)
11:00:38 <dminuoso> johnw: Where?
11:00:59 <Cale> Solonarv: Yeah, that "->" in there isn't really proper "->", it's impure functions.
11:01:36 <Cale> So if you do what you did there, you'll end up causing effects to occur in crazy orders, and repeatedly, and it'll be a big mess.
11:02:08 <asheshambasta> https://github.com/haskell-servant/servant/issues/999#issuecomment-472114938 this probably better explains my intent.
11:03:29 <sclv> johnw: i'm not sure what you mean?
11:07:28 <sclv> i forgot about this, hm: https://arxiv.org/pdf/1811.06460.pdf
11:07:47 <sclv> for specific compositions of monads you can prove that no appropriate distributive law exists
11:08:31 <dminuoso> Solonarv: My main beef with thinking of IO as a state monad over "the real world" is that its inherently true. It presumes that effects can be undone, or that the entire world cannot change on its own.
11:08:31 <dminuoso> *inherently untrue!
11:09:23 <Solonarv> yeah, of course.
11:10:03 <dminuoso> And even without looking at the entire world, primitves like forkIO ruin that completely.
11:12:01 <mjrosenb> I asked earlier, but it got lost in the backlog...
11:12:35 <mjrosenb> I need an expression that has type [a] -> ListT (State foo) a
11:13:50 <dminuoso> m-renaud: How should it make up `foo`?
11:13:56 <dminuoso> mjrosenb ^-
11:14:12 * geekosaur should write an IO tutorial based on "Give Me The Brain" >.>
11:14:21 <mjrosenb> it is in the middle of a do block whose type is ListT (State foo) a
11:14:57 <mjrosenb> e.g. I have an [a], and I want to bind individual elements of it inside of this block.
11:15:29 <MarcelineVQ> geekosaur: I'd call an IO tutorial "Pass Me The Rock", for no particular reason
11:19:40 <mjrosenb> dminuoso: does that help at all?
11:22:48 <Solonarv> mjrosenb: https://hackage.haskell.org/package/list-t-1.0.3.1/docs/ListT.html#v:fromFoldable
11:23:34 <Cale> mjrosenb: are you really sure you want ListT of State foo? That's not a monad.
11:23:41 <mjrosenb> is that part of mtl?
11:23:44 <Cale> (or is it not the mtl's ListT)
11:24:06 <Cale> Usually StateT of [] is more likely what you want
11:24:18 <mjrosenb> someone tole me to use mtl over the alternatives.
11:24:23 <mjrosenb> s/tole/told/
11:24:55 <Cale> Well, the ListT that's in transformers/mtl is not actually a monad transformer, but it will produce a valid monad only if the monad you apply it to is commutative
11:25:23 <Cale> i.e. if  do u <- x; v <- y; return (u,v)  is always equal to  do v <- y; u <- x; return (u,v)
11:25:35 <mjrosenb> When I looked last night, the result of bar :: StateT foo [] a; runState bar was [(a,foo)], which I don't want.
11:25:43 <Cale> This happens for Reader, and Writer if your monoid is commutative, and not a whole lot else.
11:25:52 <mjrosenb> I have a computation that is currently in the list monad, and I want to thread some state through it
11:26:08 <Cale> mjrosenb: How do you want backtracking to work?
11:26:09 <mjrosenb> preferably without rewriting the code do no longer use do-notation on the list parts of it.
11:26:37 <Solonarv> @hackage list-t -- this is the non-broken one
11:26:37 <lambdabot> http://hackage.haskell.org/package/list-t -- this is the non-broken one
11:26:41 <mjrosenb> there shouldn't be any backtracking.  I'm generating a structure that holds all paths in it.
11:26:45 <Cale> Usually in my experience you'd want it to be so that if your computation backtracks, the state backtracks along with it.
11:26:53 <Cale> Well, what are you using the list monad for?
11:26:55 <Cale> :)
11:27:02 <Cale> okay
11:27:16 <mjrosenb> a) I'm lazy, b) the nodes on the tree are lists of sub-nodes
11:27:20 <mjrosenb> and by I'm lazy
11:27:38 <Cale> Okay, so what's the state exactly?
11:28:10 <mjrosenb> I mean I'm using bind failure to prune invalid states preemptively.
11:28:50 <Cale> aha, so that's what I mean by "backtracking"
11:29:08 <Cale> i.e. one of the lists is empty, so try a different combination of the previous choices
11:29:14 <mjrosenb> yes, but no computation should ever be done on them.
11:29:50 <Cale> But what's the actual state type?
11:30:37 <mjrosenb> so, I have an Array of tiles, some of them have pipes on them, the code currently builds a tree of all pipes reachable from a given source tile.
11:31:05 <mjrosenb> I say there's no backtracking because I use the pattern failure to prune out the tiles that don't have pipes on them.
11:31:14 <mjrosenb> the state is going to be the grid itself.
11:31:24 <Cale> But that's exactly what I meant by backtracking before
11:31:26 <Cale> okay
11:31:31 <mjrosenb> e.g. if I come to a pipe and it is backwards, I want to flip it.
11:31:54 <mjrosenb> yes, but normally backtracking involves discarding some computation, I'm not really discarding any computation.
11:32:15 <Cale> You're discarding the remainder of the computation where you selected the tile with no pipe on it
11:32:46 <mjrosenb> brb, meeting.
11:41:15 <delYsid> How do I set a ghc option in a haskell file?
11:41:41 <glguy> {-# OPTIONS_GHC -flag-here #-}
11:41:56 <delYsid> cool, thanks
11:56:53 <delYsid> hmm, I guess pattern matching a 4000 element sum type isnt a good idea...
11:58:54 <Solonarv> oof
11:59:31 <Solonarv> why would you even have a sum type that big?
11:59:50 <delYsid> autogenerated from ICAOCodes.
12:00:50 <delYsid> I should probably use a Map I guess.
12:06:00 <Cale> delYsid: Yeah, it's hard to say exactly what to do, but usually if you were going to have a very large sum type that would get honestly pattern matched only a few times, it's better to instead make a record type with whatever would go on the right hand side of the "->" in each of those case expressions, and then just define a whole bunch of values.
12:06:50 <Cale> (but the autogeneration makes things a little weird perhaps)
12:08:10 <Cale> For example, there's https://hackage.haskell.org/package/font-awesome-type-0.1/docs/Web-FontAwesomeType.html which does things the wrong way
12:09:33 <nshepperd_> Airport codes? Text+map would have the benefit that your program doesn't need to be recompiled when a new airport is built
12:10:11 <delYsid> Its just prettier to spew things out as a long function, but I guess a Map is the way to go.
12:11:51 <Cale> There are only two pattern matches on that type in the whole world: one in fontAwesomeClass, and the other in fontAwesomeChar -- just storing the class string and the associated Char directly, and defining a whole bunch of individual records would have been way more usable and extensible.
12:12:13 <delYsid> https://blind.guru/ICAO.hs
12:12:49 <dyl> An applicative parsing question: 
12:12:53 <dyl> Let's say I have...
12:12:57 <dyl> AST.Atom :: String -> AST.Term
12:12:59 <dyl> L.Atom :: String -> L.Lexeme
12:13:09 <dyl> and a production (note, this is incorrect): atom <- rule $ Atom <$> satisfy L.isAtom <?> "atom"
12:13:15 <Cale> delYsid: Yeah, that's definitely a Map
12:13:32 <dyl> The issue here being that satisfy L.isAtom is going to produce a L.Lexeme, but what I really want is the internal string.
12:13:58 <dyl> Is there some approach to this that doesn't involve smart-constructors and errors?
12:14:25 <Cale> dyl: where you currently have Atom there, write (\(L.Atom s) -> AST.Atom s) ?
12:14:49 <dyl> Right, but that's not total. I _know_ it's correct but...
12:14:53 <Cale> huh?
12:14:57 <Cale> Oh
12:15:11 <dyl> satisfy L.isAtom :: Prod _ _ Lexeme _
12:15:16 <Cale> right
12:15:21 <dyl> I could potentially add a phantom type parameter to Lexeme?
12:15:41 <dyl> e.g. data Lexeme a where { ... Atom :: String -> Lexeme String } 
12:15:50 <dyl> and then have some Lexeme a -> a thing.
12:16:20 <dyl> https://i.imgflip.com/2vv9j9.jpg
12:16:20 <Cale> You could also write satisfyMaybe :: (Lexeme -> Maybe b) -> Prod b
12:16:30 <dyl> That was my other thought.
12:17:29 <dyl> (and it's not a comonad, becuase duplicate's codomain isn't inhabited)
12:18:55 <dyl> Both approaches seem 1) to have their own advantages, 2) mutually compatible.
12:34:07 <mjrosenb> Cale: Ok, back.  so, assuming that what I'm doing is pruning, I'm pretty sure I want any state updates that happen on pruned branches (there shouldn't be) to be present in the final state output of the function.
12:34:52 <mjrosenb> but fromFoldable seems to do what I want.  is list-t its own package, separate from both mtl and transformers?
12:38:48 <Solonarv> yes
12:39:19 <mjrosenb> so many transformers...
12:39:20 <Cale> mjrosenb: Could you explain what this thing is computing again? If I'm picturing the right thing, I would expect different solutions to want to flip the pipes in different ways
12:39:35 <Cale> in which case, you really do want StateT Board []
12:39:59 <Cale> (you almost always want StateT Board [] of some sort when solving puzzles)
12:40:28 <mjrosenb> not solving puzzles, updating game state in response to user input
12:40:32 <mjrosenb> there should only be one state.
12:40:35 <Cale> ah, okay
12:40:56 <Cale> That's a bit different then, but then I don't understand how the ListT is helpful
12:41:29 <Cale> What are you producing multiple of?
12:43:53 <mjrosenb> each tile can have multiple pipes on it, and one source can split into multiple paths (think T junction), this computes all paths from a source to a sink, or a source out to the void.
12:44:13 <catern> is there a more "modern" (or at least, not in PDF form) paper/article promoting the state machine design found in "Lambda the Ultimate Goto"? I always want to link LTUG to people when they start talking about state machines, but it's too rough-hewn...
12:45:19 <monochrom> That one talks about state machine? I thought it talked about continuation passing style.
12:46:31 <catern> no, I don't think there's any CPS talk in it, it's all about state machine implementation with tail-calls
12:46:42 <catern> quick summary: tail calls are state machine transitions, which neatly keep only the variables that are valid in scope, so it's all nicer and more orderly
12:47:35 <monochrom> I think you should just say that summary next time. It doesn't take 10 pages to explain today.
12:48:11 <monochrom> It took 10 pages back then because it was a long time ago. The same way even Dijkstra needed like 5 pages to convince you to use a while-loop.
12:49:06 <monochrom> (And then it took my thesis supervisor Hehner to take another 5 pages to explain why tail recursion is better than while loops.)
12:49:40 <catern> I disagree that it's so obvious, so I'd still like something that says it
12:51:08 <monochrom> No one said it's obvious. There is nothing to disagree on that.
12:51:57 <monochrom> Instead, I am saying that with today's heightened educational level, you just need your one-sentence summary and maybe a short example to convey the whole thing. 0.5 pages, not 10 pages, and you could have finished writing it by now.
12:52:42 <monochrom> To be frank LTUG was pretty long-winded and rambled on and on. (It was entertaining, to be sure.)
12:54:59 <Cale> 1) Take almost any imperative algorithm you like, label the points of control. 2) Define corresponding functions having arguments the mutable variables that are in scope at each point in your imperative program. 3) Define each function body by applying the corresponding next point of control to the new values of the variables as appropriate.
12:56:11 <Cale> 4) Simplify using equational reasoning.
12:56:26 <Cale> 5) Actually understand what the shit was going on in that horrible imperative program. :D
12:56:38 <monochrom> Hrm! I think every problem can be solved by just #4. >:)
12:57:00 <Solonarv> Only if your language lets you apply equational reasoning!
12:57:20 <Solonarv> steps 1-3 are for transforming the original imperative program into something that lets you reason equationally
12:58:02 <monochrom> Try applying it to http://www.vex.net/~trebla/compsci/imperative-functional.html >:)
12:58:42 <NoidedSuper> I wish there was a Haskell database library that made migrations easy.
12:59:08 <NoidedSuper> Actually I wish there was a Haskell database library that basically wholesale copied how ActiveRecord does migrations tbh
12:59:12 <Cale> monochrom: Only if I get to use IntMap for the "array" :D
12:59:33 <monochrom> You can do that, no problem.
13:04:32 <TomBombadil> Using the haskeline library, I'd like to use a printing function I've previously written which prints a [[Char]] using mapM_. Can I do this? 
13:06:03 <EvanR> if you print while the user is in the middle of advanced line editing you may get wackyiness
13:06:12 <EvanR> depending on what you are printing
13:07:06 <TomBombadil> I get their response to a prompt and use it to "modify" the [[Char]] and then print it out. So it is not occurring during their response
13:07:22 <EvanR> then it will work
13:08:03 <TomBombadil> It is not clear to me how to achieve this since the repl loop I'm writing wants the InputT IO () type
13:09:37 <EvanR> you should be able to execute any IO action you previously wrote as an InputT IO
13:09:43 <EvanR> :t liftIO
13:09:44 <lambdabot> MonadIO m => IO a -> m a
13:10:49 * geekosaur is still unclear as to what's actually being requested here.
13:12:20 <TomBombadil> that looks promising, I'll take a look thanks
13:13:28 <bifunc2> In haskell, is there a more elegant standardized way to do  a <= someNum && someNum <= b ?
13:13:58 <bifunc2> (and as performant)
13:14:08 <Cale> I'd just write what you have there. If I had to do it a lot, I'd define a function locally.
13:15:07 <Cale> between a b x = a <= x && x <= b
13:15:26 <LKoen> x `between` a b
13:15:32 <Cale> hah
13:17:25 <bifunc2> thank you
13:24:06 * hackage inline-r 0.10.1 - Seamlessly call R from Haskell and vice versa. No FFI required.  https://hackage.haskell.org/package/inline-r-0.10.1 (AlexanderVershilov)
13:31:52 <Solonarv> LKoen: sadly that parses as x `between` (a b)
13:32:03 <LKoen> oh
13:32:18 <Solonarv> however you can define: x `between` (a, b) = x >= a && x <= b
13:32:29 <Solonarv> % x `between` (a, b) = x >= a && x <= b
13:32:29 <yahb> Solonarv: 
13:32:39 <Solonarv> % 2 `between` (1, 4)
13:32:40 <yahb> Solonarv: True
13:43:24 <dyl> Cale it turns out that your "satisfyMaybe" is just the definition of `terminal` :p.
13:43:30 <dyl> And is used to implement `satisfy`.
13:43:50 <Cale> dyl: Sounds good
13:43:56 <dyl> Just terminal p = Terminal p $ Pure id
13:44:04 <dyl> It's just*
13:44:17 <dyl> Adding a type param doesn't help, as I would end up having existential nonsense.
13:46:25 <contrun[m]> Anyone has experience using pandoc api? How can I delete an inline element? Currently I transform an undesirable element into Str “”. It seems to work. But it’s ugly. Any better idea?
13:46:28 <dyl> It still feels a little odd to use.
13:47:19 <contrun[m]> Can pandoc walk into sibling elements.
13:47:47 <contrun[m]> I want to do some context sensitive transformation.
13:50:20 <Cale> contrun[m]: Perhaps it's possible to act on the various lists of Inlines instead
13:50:34 <Cale> So that you can filter them
13:52:33 <contrun[m]> <freenode_Cal "contrun: Perhaps it's possible t"> Cale: It seems the list of inlines has to belong to the same block. But sometimes it is not guaranteed.
13:52:35 <Cale> It'd be important to understand what your generic traversal is doing if you want it to perform well though: you probably don't want to continue traversing the tail of your already-filtered list of Inlines
13:53:00 <Cale> I'm assuming you're using generics of some sort to deal with this?
13:54:40 <Cale> There's an instance Walkable [Inline] Pandoc
13:55:44 <Cale> and so you could write something like  walk (filter (not . undesirableInline)) :: Pandoc -> Pandoc
13:55:45 <dyl> Cale: I feel like I've lost the niceness of using Earley with, e.g.
13:55:56 <dyl> atom <- rule $ Atom <$> terminal (\t -> (^.L.name) <$> L.maybeAtom t) <?> "atom"
13:56:17 <dyl> (maybeAtom :: Lexeme -> Maybe Lexeme, and name is a lens on the field)
13:56:37 <Cale> use view instead, it'll be a little more readable
13:57:21 <dyl> Cale kind of helps, but still a lot less nice :( 
13:57:39 <dyl> tbh, the 'nicest' way is probably to bundle up all of the nastiness in a mkAtom type function.
13:57:46 <dyl> Keep the grammar looking relatively pristine.
13:58:00 <contrun[m]> <freenode_Cal "and so you could write something"> This is much better.
13:58:03 <Cale> You could also define atomName :: Lexeme -> Maybe String
13:59:51 <Cale> contrun[m]: btw, in case you can't see it, your client is emitting the weird string "<freenode_Cal \"" at the start of each of your lines -- I assume it's nick-completion gone horribly awry :D
14:00:08 <dyl> This seems nicer: atom <- rule $ Atom <$> satisfyView L.isAtom L.name <?> "atom"
14:00:37 <dyl> satisfyView taking a predicate and a lens (as a projection) essentially.
14:00:55 <Cale> dyl: It seems like there ought to be a prism
14:01:12 <dyl> What do you mean?
14:01:18 <dyl> (Full disclosure: I haven't really used Prisms much)
14:01:40 <Cale> Well, prisms are exactly for this case where something might not match
14:02:10 <johnw> prisms are incredibly handy
14:02:32 <dyl> I should learn them, any thoughts on how they'd apply here?
14:03:38 <johnw> well, a prism use might look like "^? L.name._Atom"
14:03:45 <johnw> but I don't have enough context to make a useful suggestion
14:04:33 <Cale> pls spaces around . 
14:04:40 <Cale> :D
14:04:43 <johnw> no way
14:04:49 <Solonarv> a Prism s a is characterised by two functions match :: Prism' s a -> s -> Maybe a and review :: Prism' s a -> a -> s
14:04:51 <Cale> pls
14:05:02 <johnw> the lack of spaces reminds me that it's lenses and I should right from left to right
14:05:17 <Cale> You should read from left to right anyway :D
14:05:41 <johnw> sorry.cale
14:05:42 <Cale> (I know what you mean)
14:05:46 <johnw> not.going.to.happen
14:05:53 <johnw> :)
14:07:07 <Cale> Lazy evaluation is going to evaluate your functions from left to right, so sometimes it's important to think like that for performance reasons.
14:08:49 <Cale> (but usually it is easier to understand what the intermediate bits of data are along the way)
14:09:28 <Cale> Also, lenses do make sense the other way too, if you think about them in terms of the van Laarhoven interpretation.
14:10:04 <nshepperd> you need to think from left to right and right to left simultaneously, like those aliens in Arrival
14:10:55 <dyl> I don't think that's quite right johnw, but it seems close.
14:12:57 <dyl> Or maybe I'm just having ambient type checking issues.
14:13:25 <Cale> You're composing together a bunch of functions which accept a function acting on the item you're going to focus on, and turn it into a function acting on the whole structure, so the leftmost function should be the one that produces the handler for the largest structure.
14:13:59 * dyl glazes over.
14:14:22 <Cale> sorry, that was aimed more at johnw, but I could try to clarify it
14:14:24 <dyl> "so the leftmost function should be the one that produces the handler for the largest structure."
14:14:40 <Cale> Like, a simple lens is something along the lines of
14:14:43 <dyl> For some reason I assumed it would be more like (^? L._Var . L.name)
14:15:04 <Cale> (Functor f) => (small -> f small) -> (big -> f big)
14:15:04 <dyl> But, I guess that's backwards from standard composition order.
14:15:29 <Cale> So the result of that function is something which acts on the bigger structure
14:17:23 <Cale> So if we're composing two lenses f . g, we can think of g as taking us from (small -> f small) to (middle -> f middle), and then f taking us from (middle -> f middle) to (large -> f large)
14:17:56 <Cale> and we end up with a lens (small -> f small) -> (large -> f large)
14:17:58 <dyl> wait wtf
14:18:04 <dyl> This is what typechecks: atom <- rule $ Atom <$> terminal (^? L._Atom) <?> "atom"
14:18:10 <dyl> I'm even more confused now.
14:18:14 <Cale> yeah, that looks right
14:18:24 <dyl> I didn't even have to focus in on _name?
14:18:25 <Cale> given that your prism produces the String directly
14:18:32 <dyl> (e.g. Atom   :: { _name :: String } -> Lexeme)
14:18:41 <Cale> yeah, there's only one field
14:18:49 <dyl> What would happen with multiple fields?
14:18:52 <Cale> check the type of _Atom
14:18:57 <dyl> Yeah I just saw that.
14:19:04 <Cale> with multiple fields, the prism generator would probably fail
14:19:21 <dyl> So for zero constructors I assume it produces a unit
14:19:23 <Cale> I don't know, I haven't really tried that
14:19:29 <Cale> it could produce a prism to a tuple I guess
14:19:56 <dyl> For zero it is indeed unit. 
14:20:31 <dyl> Anyhow, a large part of this was motivated by "how can I not write boilerplate isFoo or maybeFoos?"
14:20:38 <dyl> and Prisms seem to answer that _and_ do more stuff I want :).
14:22:06 <Cale> Just don't give in to the lens line-noise
14:22:57 <Cale> All the stuff in Control.Lens is best used sparingly when you've come to the conclusion that nothing else is clearer.
14:23:19 <Cale> But there are definite use cases
14:24:33 <dyl> tbh, I like the consistency of using `terminal (^? L._LSomeLexeme)`
14:24:48 <dyl> as in the zero field case it's just like `token L.NullaryLexeme`
14:25:18 <dyl> and in the one field case it Does The Right Thing and handles the maybe and projects the field.
14:25:37 <dyl> terminal (^? L._Atom) vs terminal (^? L._LPar), where Atom :: String -> Lexeme and LPar :: Lexeme for example.
14:28:33 <Cale> Note also that you can write preview in place of ^? if you prefer
14:29:14 <Cale> Personally, I find the names easier to remember than the jumbles of symbol characters
14:29:47 <dyl> Good call.
14:30:09 <dyl> Unfortunately my parser doesn't work now, but at least it typechecks~
14:30:49 <dyl> ... oh, nope.
14:30:57 <delYsid> Cale: https://github.com/mlang/mcp/blob/master/lib/ICAO.hs
14:30:59 <dyl> I just forgot to end my clauses with periods :).
14:31:00 <delYsid> I guess thats better.
14:36:03 <fen> something that unfolds values, a state, can be "fused over" using a church representation. but suppose that eg producing a list of Bools, that the state has a switch, so that it only produces a list of True and then a list of False after the switch is flipped at some point
14:36:56 <fen> then, instead of [Bool] which would need to be folded over by something that would incur cost upon examining each Bool, we should be able instead to represent the output as (Int,Int) 
14:37:09 <fen> but this would loose the fusion property
14:37:32 <fen> what can be done!?
14:39:53 <fen> using ([()],[()]) instead of ([Int],[Int]) allows something like "take", but it should be lazy, which requires the fold fusion
14:40:27 <fen> considering the unfolding via state like build
14:43:56 <fen> also, [Bool] has a (++) which is lazy. so there would have to be some (<>) over ([()],[()])
14:45:55 <fen> suppose this is like ["))))) ... , "((((( ... "] , then when we add them together, the ")))))((((()))))))((((((" can cancel the inward facing parens
14:47:43 <fen> might just have to not evaluate it lazily...
14:50:44 <fen> this corresponds to navigating between leafs of a tree, where you go "up" to the common branch, and then down to the next leaf. if you travel between separated nodes, then there is some amount of reversed navigation, travelling back up from the leafs in-between,
14:51:26 <fen> the reduction of the parenthesis is the same as cancelling this redundant navigation
14:52:39 <delYsid> Fun, the ICAO list from noaa is actually buggy.  WRiting a parser revealed the bugs it has.  Inconsistent CRLF/LF style, and mistyped lat/lon coordinates.  I wonder who does validation at NOAA :-)
14:53:14 <hpc> s/does/used to do/
14:53:20 <hpc> (i bet)
14:53:51 <delYsid> Yeah, its likely a historical list, but I am still sort of shocked that it has such obvious bugs.
14:56:25 <delYsid> "70;291;PAOR;NORTHWAY AIRPORT;AK;United States;4;62-58N;141-56N"
14:56:56 <delYsid> Looks like from an intern :-)
15:06:44 <fen> actually it needs ([()],Free (\a -> ([()],a)) 
15:09:14 <fen> ")))(((())))((()))(((())) ... " === (")))",["(((","((" ...])
15:10:40 <fen> having canceled as may inward facing parens as possible. and reatining the segments, corresponding to taking different branches
15:12:05 <fen> note if you (<> ")))) ...") with enough parens it should cancel everything remaining and add to the first set 
15:13:40 <fen> this is the same as retracing all navigations, going all the way back to the "up" navigation from the first position
15:18:34 <dyl> Does anyone see the issue I'm apparently not seeing with the `query` rule here?
15:18:35 <dyl> https://gist.github.com/DylanLukes/fd28661c95a67043fdea16a866f5c757
15:18:53 <dyl> testLex "?- foo(X)."  ⇒ [Query,Atom {_name = "foo"},LPar,Var {_name = "X"},RPar,Period]
15:18:59 <dyl> and yet, testParse produces nothing.
15:19:12 <dyl> Note, this parses as a fact without the query (?-).
15:19:28 <delYsid> Is there a prefered type for IPv4 addresses in haskell land?  Something I could write instances for?
15:19:50 <hpc> if you want to be a jerk, Word32 :D
15:19:56 <hpc> if you want to be a megajerk, Word
15:20:42 <hpc> actually, apparently that's legit - http://hackage.haskell.org/package/network-3.0.1.0/docs/Network-Socket.html#t:HostAddress
15:21:01 <fen> having obtained this thing, which is isomorphic to (Int,[Int]) it can be mapped over with the tree pointer to get a list of tree pointers, which can be lazily navigated over. its just a shame that the arithmatic for canceling redundent navigation prevents it from fusioning all the way to the original state unfold 
15:21:06 <delYsid> ah, I guess I have a different problem.  Is there a way to write a class that can have a pure and IO result, depending on the instance?
15:21:30 <hpc> http://hackage.haskell.org/package/base-4.12.0.0/docs/Text-Printf.html#v:printf is one way to do it
15:21:50 <fen> delYsid: whats wrong with either?
15:22:39 <hpc> that sounds like an odd enough thing to need that i would be sure that's what you really want
15:22:42 <dyl> What is up with this query production o.0
15:22:52 <dyl> I don't understand why it isn't working, all signs point to "it should work".
15:22:58 <dyl> OH.
15:23:01 <dyl> query/query shadowing perhaps?
15:23:11 <delYsid> hpc: Polyvariadic functions?
15:23:16 <dyl> Yeup.
15:23:32 <hpc> delYsid: it also does printf "foo" :: String and printf "foo" :: IO ()
15:23:46 <hpc> which is a concession to people who think it's annoying to write sprintf
15:24:06 <hpc> which i don't blame them, that name is garbage if you aren't already a few years into C
15:24:32 <delYsid> I want to write a Distance class that can calculate the distance between two pure values, but also have an instance which needs IO to actually fetch the location of the "point"
15:24:54 <hpc> hmm
15:24:59 <delYsid> basically for interactive usage.
15:25:24 <hpc> would they be mutually exclusive, or can you use both on any instance?
15:25:41 <fen> why cant you write an instance for Distance a => IO a ?
15:25:45 <hpc> i can imagine instance Distance PurePoint; instance Distance PointInMyDatabase
15:26:24 <delYsid> hpc: I guess that would be enough.
15:26:46 <hpc> hmm
15:26:58 <hpc> naively, a type family to pick the result type perhaps
15:27:09 <hpc> instance Distance PurePoint where type Result PurePoint = PurePoint
15:27:17 <delYsid> fen: good point.
15:27:25 <hpc> instance Distance PointInMyDatabase where type Result PointInMyDatabase = IO PointInMyDatabase
15:28:04 <delYsid> oh, that would be anice opportunity to learn about type families finally.
15:28:10 <delYsid> I am really just toying to learn stuff.
15:28:38 <Lears> If you have a pure distance function, it doesn't need to care where values come from. I would just apply to pure or impure values applicatively.
15:28:38 <hpc> or a multiparameter type class perhaps
15:28:57 <hpc> class Distance point r where distance :: Point -> Point -> r DistanceType
15:29:05 <hpc> instance PurePoint Identity, etc
15:29:10 <delYsid> Lears: Yeah, but that would require more typing on the interactive prompt
15:29:36 <hpc> although then you'd want a fundep sometimes maybe, and at that point you basically have a type family anyway
15:29:40 <delYsid> oh, Identity!
15:29:50 <delYsid> so much food for thought!
15:29:52 <hpc> i don't write this sort of code very often
15:30:46 <delYsid> hpc: Wouldn't I need to runIdentity somehow then?
15:31:02 <hpc> yeah, that's one disadvantage
15:32:21 <delYsid> instance r ~ (IO Distance) => Distance Point r where ?
15:33:08 <delYsid> instance Distance Point Distance where ?
15:33:13 <delYsid> would that work?
15:33:45 <hpc> i think that overlaps?
15:34:11 <delYsid> I have no idea.
15:34:13 <hpc> you'd want Distance Point (IO Distance), and FlexibleInstances maybe?
15:34:16 <hpc> experiment with it
15:34:41 <hpc> in fact, that's my advice
15:34:59 <hpc> then when you decide to do something completely different, i can still claim it was due to my genius :D
15:41:09 <delYsid> let the extensions come on :-)
15:41:17 <delYsid> TypeSynonymInstances
15:45:00 <delYsid> argh, the simple case already needs a type annotation
15:45:19 <delYsid> ah, fundeps maybe
15:46:04 <delYsid> wow, cool
15:48:22 <boj> f = go $ \a -> g a -- is there a way to partially apply more values to g via f given this construct?
15:48:59 <jackdk> :t flip
15:49:00 <lambdabot> (a -> b -> c) -> b -> a -> c
15:52:52 <lyxia> boj: I don't understand the question
15:53:02 <Solonarv> f = go $ \a -> g x y z a h d j r -- the sky's the limit!
15:53:28 <boj> Solonarv: i was hoping to avoid typing all of those :)
15:53:48 <Solonarv> well, they've got to come from somewhere
15:53:50 <boj> f a b c = go $ \z -> g z a b c
15:54:03 <Solonarv> @pl \z -> g z a b c
15:54:04 <lambdabot> flip (flip (flip g a) b) c
15:54:08 <Solonarv> :D
15:54:12 <boj> oh my
16:06:00 <delYsid> hpc: thanks, works! With just 4 extensions :-)
16:06:39 <delYsid> https://blind.guru/Distance.hs
16:20:16 <fr33domlover> I have many datatypes, all of which have 3 fields they all share, and I'd like to be able to uniformly get the values of these fields. Ideas: (1) Define a dedicated type for those 3 fields (2) Define them in each type and use a typeclass to define uniform access. Hmm how do I pick?
16:21:49 <fen> what, like an archetypal instance for that class?
16:22:36 * hackage cmark-gfm 0.1.7 - Fast, accurate GitHub Flavored Markdown parser and renderer  https://hackage.haskell.org/package/cmark-gfm-0.1.7 (kivikakk)
16:23:19 <fen> depends if its the only instance...
16:24:20 <delYsid> fr33domlover: DuplicateRecordFields?
16:24:40 <fen> eg you could have type Radius = Double, and a class for things which have a radius.
16:24:51 <fen> maybe it would appear as part of a class hierarchy
16:25:07 <Solonarv> I'd usually define a separate type for those fields
16:25:17 <fen> there might be many justifications for promoting a record accessor to a class function
16:25:25 <MarcelineVQ> fr33domlover: both sound pretty reasonable, probably a case of try and see which you prefer. A record of those 3 fields sounds like a good start
16:26:09 <fen> Solonarv: sure, collect them, but the question remains about if its valid to then have a class to return that collection
16:26:21 <Solonarv> sure, you can add a class as well
16:26:32 <fen> the question is why do that?
16:27:36 <ziman> you could also pass around pairs of (SharedFields, UniqueFields) instead :)
16:28:09 <fen> ah, there is a difference about it being a collection, because you can avoid the datatype serving as a grouping, and instead have the record accessors as multiple class functions, instead of just having one class function to return the collection datatype, which would then need to be accessed by its individual record accessors
16:29:49 <fr33domlover> ziman, Solonarv, fen, thanks for the ideas :) I think I'll start with (1) and switch to (2) if it proves needed/useful
16:29:59 <fen> maybe if its a sum datatype, there might be some intrinsic properties to do with the order the types appear? eg (Int,Bool) /= (Bool,Int) though both are instances of class HasBoolAndInt
16:30:05 <Solonarv> keep in mind that they're not mutually exclusive!
16:30:16 <fr33domlover> delYsid, that extension is a different thing, not really relevant I'm afraid :)
16:30:44 <Solonarv> you can have 'data CommonFields = whatever' and then have a 'HasCommonFields' typeclass which all your datatypes are an instance of
16:30:55 <fen> fr33domlover: you can make a constraint from a tuple of Has instances. class Has a b where fromHas :: a -> b
16:31:30 <fen> then you can have a type synonym eg type HasBoolAndInt a = (Has a Bool,Has a Int)
16:31:44 <fr33domlover> Solonarv, yeah sure I mean I was wondering whether or not to use a typeclass
16:31:46 <fen> and that makes it order independent
16:32:04 <Solonarv> I'd start off without it and perhaps add it later
16:32:30 <fr33domlover> I'll do the same :)
16:33:24 <fen> Solonarv: then you would end up with separate has instance for HasCommonFileds over the components. and a Has instance for each component for the HasCommonFileds instance that is a composition of has . has
16:33:49 <Solonarv> I never suggested involving a general Has typeclass
16:34:00 <Solonarv> and I wouldn't suggest it here
16:34:05 <fen> I never suggested you did
16:34:35 <fen> why not, its exactly what was being asked about?
16:35:07 <Solonarv> there's a difference between 'class Has a b where has :: a -> b' and 'class HasCommonFields a :: a -> CommonFields'
16:35:26 <Solonarv> I was suggesting the latter.
16:35:26 <fen> type HasCommonFileds a = Has CommonFileds a
16:35:46 <Solonarv> yeah, but you get worse type inference that way
16:36:07 <Solonarv> especially if you want to have the obvious '(Has a b, Has b c) => Has a c' instance
16:36:57 <fen> no, you have to write them each time
16:37:24 <fen> but you can have a helper function to make writing it easy
16:37:45 <fen> but the compiler needs a specific instance for each composed Has thing
16:37:54 <fen> or `b' is Ambiguous
16:38:50 <fen> even the helper is trivial, its just has . has with some TypeApplications
16:39:20 <Solonarv> yeah, sure
16:39:46 <Solonarv> that's a lot of unnecessary complexity when your data hierarchy is flat, though
16:43:47 <fen> but there are lots of unnsecessart HasSpecificType classes otherwise
16:44:24 <fen> and you dont get the composability from sysnoyms of tuples of constraint 
18:37:05 <fen> if there is a state, eg a (Bool,Int) being used to unfold a list of Bools, which is folded over by an accumulating function taking a Bool, is there a way to share the bool stored in the state with the accumulator?
18:40:36 <fen> eg -1 on the states int, and changing the bool when it becomes negative, and returning the bool 
18:41:35 <fen> is like just returning () if the accumulator knew what value the states Bool wa
18:41:37 <fen> s
18:44:28 <fen> which would save it from having to check the bool each time
18:44:40 <fen> is that possible?
19:22:17 <deech> If I turn a closure into a FunPtr are the resources it closes over also held in memory until freeHaskellFunPtr is called?
19:23:55 <Solonarv> I'd think so, yes
19:24:17 <Solonarv> (or longer if something else still holds a reference to the same closure)
19:25:37 <deech> So if the function pointer is freed on the C side is there any way the Haskell runtime can know about that?
19:26:53 <geekosaur> no
19:27:39 <deech> Thanks! That's unfortunate.
19:27:59 <monochrom> Hell even the C side doesn't know.
19:29:11 <Solonarv> Is the foreign side even allowed to free() a FunPtr, or would that break things?
19:30:14 <Solonarv> (clarification: a FunPtr to a Haskell function)
19:30:19 <deech> Sounds like it can free it but all the stuff in the closure on the Haskell side is retained forever.
19:32:59 <Solonarv> you might be able to cast it to a Ptr and then wrap that in a ForeignPtr
19:34:30 <pingu__> deech: if you can free it and the stuff in the haskell side is still referencing it that doesn't sound right.
19:34:46 <deech> Yeah I guess I could check if it's null, cast it back and free if it is and touch it if not?
19:35:06 <pingu__> Sorry I missed the context. Just got here.
19:36:01 <deech> pingu__: If a callback that closes over resources on the Haskell side is freed on the C side those resources will never be GC'ed ... I think.
19:37:03 <pingu__> deech: For that to be true, haskell's RTS would have to be aware of the memory allocation strategy of the C code, no?
19:38:03 <Solonarv> calling free() on a pointer that wasn't produced by malloc(), calloc() or realloc() is undefined behavior anyway
19:38:26 <glguy> Solonarv: If you want to free a FunPtr generated by by a dynamic wrapper from C you'd use the C function provided by the runtime
19:38:45 <Solonarv> so, don't free() a FunPtr
19:39:05 <glguy> You should only use free with things that explicitly tell you to,basically only things in libc
19:39:35 <glguy> Other libraries that allocate should be providing their own functions to free resources
21:00:45 <dyl> glguy put another way:
21:00:53 <dyl> if you didn't malloc it, don't free it.
21:17:25 <glguy> dyl: I was going to write something that strong, but stuff like strdup uses free, too.
21:18:08 <dyl> To be honest I’d advice no one actually use strdup.
21:18:11 <dyl> advise*
21:18:21 <dyl> Just allocate and memcpy manually.
21:19:01 <glguy> Maybe, but I wouldn't recommend mixing that advise into a statement about when to use free :)
21:19:10 <dyl> The only times you might want to use strdup, you should be using strndup, and in those cases you might as well do yourself the favor of making the allocation visible. 
21:19:24 <dyl> I think it all goes hand in hand. 
21:19:59 <glguy> The strn functions are pretty error prone to use as generic replacements for the str- functions
21:20:09 <dyl> Moreover: if you use a custom allocator you really shouldn’t be using str*dup at all.
21:20:13 <glguy> I'd hope to use strl- instead
21:20:35 <glguy> Look at us, now we're not even talking about allocation!
21:21:02 <dyl> There is no portable strldup.
21:21:12 <dyl> (Unless you write it yourself.) 
21:22:46 <dyl> I struggle to think of one situation in which strndup is inferior to strdup (and analogously for all of the str/strn functions).
21:23:07 <dyl> But anyways: you shouldn’t be using any of them :p.
21:23:53 <dyl> What do you mean by strn___ being error prone?  
21:24:26 <glguy> They don't always null-terminate correctly so you have to manually do it afterward
21:24:42 <dyl> Can you elaborate on what you mean? 
21:24:46 <glguy> They aren't intended as a safer strcpy/strcat
21:24:52 <dyl> Maybe let’s consider str[n]cpy instead.
21:24:53 <glguy> they're for fixed-width buffers
21:25:02 <dyl> Right, which I’m saying you should be using anyways. 
21:25:51 <dyl> Personally I generally just use memcpy and add the \0 myself. 
21:26:03 <dyl> I’ve been burned too many times by string.h
21:26:25 <glguy> I'm referring to thigns like: The strncpy() function is similar, except that at most n bytes of src are copied.  Warning: If there is no null byte among the first n bytes of src, the string placed in dest will not be null-terminated.
21:26:41 <dyl> But, especially when you’re dealing with user input, you should be using stat and allocating fixed size buffers _anyways_. 
21:26:49 <dyl> You should never trust that a user input string doesn’t contain bulls.
21:26:51 <dyl> Nulls*
21:27:11 <dyl> And yeah, that is kind of dumb behavior. 
21:27:41 <dyl> But that’s why strncpy is only intended for when you already know you’re copying from a well formed C string and you are using a strlen from such a string. 
21:28:04 <dyl> Which you could have avoided by keeping tabs on (or at least upper bounding) the length in the first place. 
21:28:23 <glguy> Anyway, Haskell doesn't have this problem
21:28:26 <dyl> Yay!
21:29:16 <dyl> A rule of thumb: only trust that a c string is well formed and doesn’t contain premature \0’s if you built it yourself (and can generate debug symbols for where you did).  
21:29:25 <dyl> Otherwise, it’s nearly always better to track and bound lengths.
21:29:41 <dyl> The performance hit from doing so is practically negligible. 
21:29:50 <dyl> (Unless you’re streaming.) 
21:29:58 <dyl> (And then you’ve got 1+n problems.) 
21:31:19 <dyl> There is no reason to use a function that can 1) segfault unexpectedly, 2) silently behave incorrectly and produce an error far away from the source.
21:31:38 <dyl> (Unless you can prove you’re using it correctly, which... means tracking bounds.) 
21:55:28 <remexre> is there an easy way to get a location from an alex lexer error?
21:58:25 <glguy> remexre: That depends on how you made the lexer
21:58:45 <remexre> I'm using the monadUserState wrapper, if that's what you mean
21:59:30 <glguy> Yeah, the functionality is provided by the wrapper
21:59:46 <glguy> I use my own wrapper to get better Text and unicode support
22:00:02 <remexre> the functionality == to get the location after an error occurred? I'm not seeing it...
22:00:12 <remexre> like a wrapper over the Alex monad?
22:00:45 <glguy> https://www.haskell.org/alex/doc/html/wrappers.html
22:01:16 <glguy> For monadUserState you can look at AlexState's alex_pos field, it seems
22:01:47 <remexre> after an error, I don't have an AlexState though?
22:01:50 <remexre> just a String
22:02:02 <glguy> Make an error rule in your lexer
22:02:18 <remexre> oh, right
22:02:30 <glguy> (getting an example)
22:02:47 <remexre> ok, thx
22:03:34 <glguy> Like in this lexer I have a match any character rule at the bottom: https://github.com/glguy/language-lua/blob/master/src/Language/Lua/Annotated/Lexer.x#L146
22:05:06 <glguy> In this lexer I handle them in the wrapper: https://github.com/glguy/config-value/blob/master/src/Config/Lexer.x#L116 https://github.com/glguy/config-value/blob/master/src/Config/LexerUtils.hs#L82-L83
22:07:58 <remexre> so all the errors are still `Located Token`s and you remove them when you parse?
22:09:08 <glguy> I don't remove them, I generate errors at that point in the parser
22:09:20 <remexre> er, yeah, that's what I maent
22:09:22 <remexre> ok, thanks!
22:17:37 * hackage mixpanel-client 0.2.0 - Mixpanel client  https://hackage.haskell.org/package/mixpanel-client-0.2.0 (domenkozar)
23:28:07 * hackage pandoc-citeproc 0.16.1.3 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.16.1.3 (JohnMacFarlane)
23:52:36 <remexre> Is there a common name for `type Wrapped f a = f (a f)' ?
