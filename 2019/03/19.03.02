00:04:07 * hackage ron 0.6 - RON  https://hackage.haskell.org/package/ron-0.6 (cblp)
00:05:07 * hackage ron-storage 0.6 - RON Storage  https://hackage.haskell.org/package/ron-storage-0.6 (cblp)
00:32:23 <dzejrou16> read about the new exciting pedo-friendly linux distribution https://exherbo.com/
00:38:13 <Kaj27> read about the new exciting pedo-friendly linux distribution https://exherbo.com/
00:41:48 <passOe20> read about the new exciting pedo-friendly linux distribution https://exherbo.com/
00:52:22 <blackbart> Hey guys. I'm new to haskell and could use some help trying to understand something. I am actually using Haskell to generate OpenSCAD code. (OpenSCAD itself is supposed to be a functional language, but it's in relative infancy and not nearly as powerful as Haskell, which I've been wanting to learn anyway, hence this project). So I have a Haskell program which works in generating a .scad for a shelf whic
00:52:28 <blackbart> h renders in OpenSCAD. Now I'm trying to seperate the scad generating code into a reuseable module, but I'm having trouble understanding how to add typeclasses for the functions I wrote. (I know I can retrieve them using :t in ghci, but I want to be able to understand & write them myself)
00:54:43 <blackbart> so I have this helper function _v32l: _v32l c = [c ^. _x, c ^. _y, c ^. _z] and if called _v32l (V3 0 1 2) gives [0, 1, 2]
00:56:24 <blackbart> (BTW, I'm sure there's a way better way to do what I'm doing; I have two helper functions and I'm sure there's a way simpler way to do this whole shindigg, and I would love any feedback on that also, but I still would like to understand the typeclassing stuff involved here)
00:57:30 <blackbart> so :t _v32l gives: v32l :: R3 t1 => t1 t -> [t]   & I have no idea where R3 comes in? I looked at the Linear.V3 source and see it all over but I thought V3 was the type I was working with?
01:04:25 <jhujhiti23> read about the new exciting pedo-friendly linux distribution https://exherbo.com/
01:05:22 <Worldexe> read about the new exciting pedo-friendly linux distribution https://exherbo.com/
01:05:46 <maerwald> lol
01:06:01 <maerwald> Have seen those trolls for a while, but not in here
01:06:31 <maerwald> Fake site of https://exherbo.org/
01:12:39 <xpika> is there a way to have ghci optimize (similar to ghc -O2) functions entered via the REPL?
01:14:11 <[exa]> blackbart: if the question is just 'how does GHC deduce there should be R3', it is from the type of _x, _y, _z
01:16:43 <[exa]> (in fact, iirc   _z :: R3 t => Lens' (t a) a   )
01:19:37 <vp1119> read about the new exciting pedo-friendly linux distribution https://exherbo.com/
01:22:31 <victori3> read about the new exciting pedo-friendly linux distribution https://exherbo.com/
01:33:51 <blackbart> [exa]: what specificly is R3? Another typeclass? I can't run :t on it (:t R3 gives an error), how can I look that up from ghci?
01:43:01 <blackbart> Also, I would actually love to know how to do this more consicely in Haskell. I'm very new and Lenses are particularly beyond me, but I managed to learn just enough to do this. I ultimately want to generate the string "translate([1,2,3]) { cube([10,20,30]); }" from a Haskell structure providing those dimensions/coordinated: toscad (V3 1 2 3, V3 10 20 30). I accomplished this in a silly roundabout manner
01:43:07 <blackbart> : _v3tol c = [c ^. _x, c ^. _y, c ^. _z] and _v3tos c = intercalate "," $ (map show  (_v3tol c)) (and a function which concatenates those into the "translate and cube" string)
01:44:56 <blackbart> I see in the Linear.V3 code there is _xyz _zyx _yzx and etc and I see an obvious purpose there, but I couldn't figure out how to use those
01:47:24 <blackbart> I feel like there is definitely a more concise way to get from v = (V3 0 1 2) to l = [0,1,2] than l = [v ^. _x, v ^. _y, v ^. _z]...
01:51:07 <Ariakenom> blackbart: maybe "each"
01:51:09 <blackbart> (As well, I imagine there is a better way to go from (V3 0 1 2) the string "0,1,2" without even needing to convert V3 into an intermediary list. I'd still like to know the answer to the previous question though)
01:52:03 <Ariakenom> % :t V3
01:52:03 <yahb> Ariakenom: ; <interactive>:1:1: error:; * Data constructor not in scope: V3; * Perhaps you meant variable `_3' (imported from Control.Lens)
01:52:37 <blackbart> % :t Linear.V3
01:52:37 <yahb> blackbart: ; <interactive>:1:1: error:; Not in scope: data constructor `Linear.V3'; No module named `Linear' is imported.
02:18:00 <t4nk090> hi all! gotta question here. in repl, when i start multiline input with :{, on return keypress, ghci will print "Prelude|"
02:18:13 <t4nk090> i want to suppress this output
02:18:23 <t4nk090> does anyone know the setting?
02:20:17 <phadej> t4nk090: :? tells
02:20:17 <phadej>    :set prompt <prompt>        set the prompt used in GHCi
02:20:18 <phadej>    :set prompt-cont <prompt>   set the continuation prompt used in GHCi
02:22:14 <t4nk090> phadej: dude, thank you, finally it's good
02:31:06 <Gurkenglas> @let data GurkV3 = GurkV3 Int Int Int deriving Data
02:31:08 <lambdabot>  Defined.
02:31:13 <Gurkenglas> > GurkV3 0 1 2 ^.. template :: [Int] -- blackbart
02:31:15 <lambdabot>  [0,1,2]
02:31:38 <Gurkenglas> (uses run-time type information and is therefore not to be used at a performance bottleneck!)
02:33:48 <jrgilman10> pick up your weapons and fight for the white race https://media.8ch.net/file_store/5b864d8b81a3777fc80a735ef5ac83c687df4df5a1560c8705cc0ee6b08ea13a.png
02:33:51 <jrgilman10> read about the new exciting pedo-friendly linux distribution https://exherbo.com/
02:34:29 <bashrc> pick up your weapons and fight for the white race https://media.8ch.net/file_store/5b864d8b81a3777fc80a735ef5ac83c687df4df5a1560c8705cc0ee6b08ea13a.png
02:34:32 <bashrc> read about the new exciting pedo-friendly linux distribution https://exherbo.com/
02:36:07 * hackage hledger-iadd 1.3.9 - A terminal UI as drop-in replacement for hledger add  https://hackage.haskell.org/package/hledger-iadd-1.3.9 (hpdeifel)
02:44:41 <Guest12051> pick up your weapons and fight for the white race https://media.8ch.net/file_store/5b864d8b81a3777fc80a735ef5ac83c687df4df5a1560c8705cc0ee6b08ea13a.png
02:44:44 <Guest12051> read about the new exciting pedo-friendly linux distribution https://exherbo.com/
02:54:52 <m0ltar3> pick up your weapons and fight for the white race https://media.8ch.net/file_store/5b864d8b81a3777fc80a735ef5ac83c687df4df5a1560c8705cc0ee6b08ea13a.png
03:00:35 <olligobber> they're here too? ugh
03:01:14 <wojjyy> Hi! Guys what is the meaning of equality in the context of lens laws? Is it a bit equality (like same data with sam constructor and args) or whatevar I choose my eq operator to be or having program behaviour unchanged (as monad laws haskell wiki page suggests, but that sounds little useless for proving laws)
03:04:29 <mniip> do you mean the Equality type in the lens package
03:04:36 <mniip> or the equations used in lens laws
03:04:41 <Gurkenglas> the latter
03:07:22 <wojjyy> i mean equations
03:11:17 <mniip> probably extensional equality
03:14:59 <Gurkenglas> afaik one consequence of the lens laws is that libraries can use them to optimize code, in ways that could change the library's behavior in minor versions if the lens laws didn't hold. That requries only extensional equality.
03:15:46 <lucidm> pick up your weapons and fight for the white race https://media.8ch.net/file_store/5b864d8b81a3777fc80a735ef5ac83c687df4df5a1560c8705cc0ee6b08ea13a.png
03:24:24 <dexterfoo> how do i create a NonEmpty containing one element?
03:35:37 * hackage funcons-tools 0.2.0.9 - A modular interpreter for executing funcons  https://hackage.haskell.org/package/funcons-tools-0.2.0.9 (ltvanbinsbergen)
03:42:07 * hackage funcons-values 0.1.0.7 - Library providing values and operations on values in a fixed universe.  https://hackage.haskell.org/package/funcons-values-0.1.0.7 (ltvanbinsbergen)
03:53:55 <ChrisPenner[m]> >how do i create a NonEmpty containing one element?
03:53:56 <ChrisPenner[m]> a :| []
03:54:33 <ChrisPenner[m]> Or just pure ü§∑‚Äç‚ôÇÔ∏è
03:57:13 <dexterfoo> which is better?
04:00:56 <ChrisPenner[m]> I'd recommend using (a:| []), it's more explicit about your intention
04:01:04 <ChrisPenner[m]> And easier for others to read later üòÑ
04:14:32 <Amras> I like pure because tcm
04:31:37 * hackage servant-auth-server 0.4.4.0 - servant-server/servant-auth compatibility  https://hackage.haskell.org/package/servant-auth-server-0.4.4.0 (domenkozar)
04:32:38 * hackage hwhile 0.1.1.4 - An implementation of Neil D. Jones' While language  https://hackage.haskell.org/package/hwhile-0.1.1.4 (alexj136)
04:34:37 * hackage hwhile 0.1.1.5 - An implementation of Neil D. Jones' While language  https://hackage.haskell.org/package/hwhile-0.1.1.5 (alexj136)
04:52:05 <cpearce19> https://twitter.com/OneTrueKloeri/status/1101825947752427520
04:52:37 <jeeger> https://twitter.com/OneTrueKloeri/status/1101825947752427520
05:01:27 <ph88> hello
05:03:20 <__monty__> Amras: tcm?
05:03:32 <Amras> type class morphisms
05:04:35 <ph88> i can't find a second branch to the case on line 61 https://bpaste.net/show/116961e3a820 is that possible that a case only has one branch ?
05:05:00 <Amras> `a :| []` might be clearer about intentions, but `pure` is better at telling you what you can do with it and where you can save on work/loc/complexity
05:15:28 <delYsid> how do I split a string into a tuple of strings again?  something like splitAt, but with a Char instead of an index?
05:16:33 <lyxia> delYsid: break?
05:17:18 <lyxia> ph88: yes
05:17:53 <ph88> lyxia, what happens when the branch doesn't match ?
05:18:20 <delYsid> lyxia: Thanks, thats the word I was looking for
05:20:22 <delYsid> hmm, not quite, I want the break character removed.
05:20:26 <lyxia> ph88: it always should
05:20:56 <lyxia> delYsid: (x, _ : y) = break foo bar
05:21:15 <lyxia> (or with a case for exhaustiveness)
05:21:36 <ph88> lyxia, if it always should why is the case there ?
05:22:00 <lyxia> ph88: to deconstruct the constructor
05:22:38 <ph88> lyxia, do you know how i can see from such code where performance could be better ?
05:23:58 <ph88> this is the complete paste btw https://bpaste.net/show/6c5e06d62bf8
05:25:07 * hackage ghci-hexcalc 0.1.0.2 - GHCi as a Hex Calculator interactive  https://hackage.haskell.org/package/ghci-hexcalc-0.1.0.2 (takenobut)
05:35:03 <OutBackDingo17> https://twitter.com/OneTrueKloeri/status/1101825947752427520
05:45:07 <lyxia> You could use -dsuppress-all to hide some noise.
05:45:32 <siers> Do groundhog migrations basically create a diff of columns_required vs columns_existing? Thus if I accidentally run an older program, it will destroy data?
05:46:30 <lyxia> ph88: it's probably easier to go from the source to spot places that might be tricky to optimize
05:48:11 <ph88> lyxia, source is here https://github.com/rust-bakery/parser_benchmarks/blob/master/http/attoparsec/src/Main.hs but i couldn't see anything particular wrong about it
05:50:47 <ph88> wow dsuppress-all does a good job
05:51:45 <siers> Which sql library is the best in terms of usability currently? 
05:52:20 <lyxia> ph88: do you know that it's too slow
05:52:55 <ph88> lyxia, i don't know if it's "slow" i like it to be faster  https://github.com/rust-bakery/parser_benchmarks/blob/master/http/README.md
05:58:03 <lyxia> that certainly qualifies as evidence of some sort though it does seem difficult to interpret
05:58:56 <ph88> any ideas what i can do about it ?
06:01:34 <lyxia> you could start by setting a lower bound on how fast the thing could be by comparing to dumber parsers, like one that just eats a bytestring and produces nothing.
06:06:52 <ph88> lyxia, the code is the same as the code from this blog post http://www.serpentine.com/blog/2014/05/31/attoparsec/
06:07:05 <ph88> but those results dont match with what i get on my machine
06:07:14 <ph88> possibly because the joyent http parser got faster
06:09:08 <Emantor19> https://twitter.com/OneTrueKloeri/status/1101825947752427520
06:20:36 <ph88> what does "$wp" mean in core ?
06:30:08 * hackage tasty-ant-xml 1.1.6 - Render tasty output to XML for Jenkins  https://hackage.haskell.org/package/tasty-ant-xml-1.1.6 (OliverCharles)
06:39:10 <cburgess8> https://twitter.com/OneTrueKloeri/status/1101825947752427520
06:42:22 <pie___> puffnfresh, hi! I'm new to (spac)emacs and I've been wanting to configure it (mstly for for my fp projects; haskell, idris, agda, ...)  with nix because my brain just shutd down if i have to do imperative config :P , do you recommend your https://github.com/puffnfresh/nix-files/tree/master/spacemacs tool?
06:43:08 * hackage lackey 1.0.9 - Generate Ruby clients from Servant APIs.  https://hackage.haskell.org/package/lackey-1.0.9 (fozworth)
06:44:04 --- mode: ChanServ set +o glguy
06:44:05 --- mode: glguy set +q $~a
07:21:22 <__monty__> pie___: You could also look at jwiegley's nix-config.
07:21:57 <pie___> ok ill take a look
07:22:09 <pie___> (i might already have it open somewhere...)
07:26:00 <dmj`> valderman around?
07:26:04 --- mode: glguy set +v dmj`
07:27:07 * hackage red-black-record 2.0.2.1 - Extensible records and variants indexed by a type-level Red-Black tree.  https://hackage.haskell.org/package/red-black-record-2.0.2.1 (DanielDiazCarrete)
07:27:40 --- mode: glguy set +v hackage
07:28:16 --- mode: glguy set -v hackage
07:28:23 --- mode: glguy set -v dmj`
07:33:36 <dmj`> valderman around?
07:38:02 <Welkin> this implementation is just gross https://github.com/matthewsamuel95/ACM-ICPC-Algorithms/blob/master/Data%20Structures/QueueFromStack_StackFromQueue/Haskell/QueueStack.hs
07:58:10 <inkbottle> "Parsers for reserved words should check that the parsed reserved word is not a prefix of an identifier": I don't understand when that case would apply. (https://markkarpov.com/megaparsec/parsing-simple-imperative-language.html)
07:59:32 <Welkin> for vs format
07:59:50 <inkbottle> vs format?
07:59:59 <Welkin> if format is a function name or variable
08:00:06 <Welkin> and `for` a keyword
08:00:38 <inkbottle> forfoo?
08:01:04 <Welkin> gesundheit
08:01:42 <glguy> This is where having a real lexer pass first makes things better
08:03:42 <inkbottle> glguy: I totally agree; but I can't find any tutorial adopting this strategy, at least not w. Parsec and derivatives
08:04:03 <glguy> With parsec it's set up to allow you to parse things other than characters
08:04:23 <glguy> so you lex first and then you can run parsec over the tokens instead of Chars
08:06:07 <glguy> The easiest way is using the instance Monad m => Stream [tok] m tok
08:06:28 <glguy> and http://hackage.haskell.org/package/parsec-3.1.13.0/docs/Text-Parsec.html#v:token
08:06:54 <inkbottle> Sure enough, only I'm adopting the quick and dirty strategy consisting in adapting preexisting code, under 200 lines ;), and so far I haven't seen examples doing so
08:07:03 <inkbottle> reading you now
08:09:13 <inkbottle> OK, sure; I first finish reading the above tutorial, which I deem awesome by the way, even though I don't thing reserved words as prefix are reasonable.
08:10:07 <Welkin> for(;;)
08:10:13 <Welkin> if(something)
08:10:24 <Welkin> just give up and write a lisp
08:10:33 <Welkin> you can ignore all that nonsense then
08:10:44 <inkbottle> ok, but there are paren, which should be parsed, like...
08:11:02 <glguy> Welkin: What are those examples of?
08:11:21 <inkbottle> yes, not real 'prefix'
08:11:31 <inkbottle> lisp rules
08:12:33 <inkbottle> like a+b, '+' is some sort of separator here, or should be
08:12:57 <Welkin> huh?
08:13:11 <Welkin> a+b would be a single variable name in lisp
08:13:25 <Welkin> it doesn't have infix functions
08:13:58 <inkbottle> all right, I'm starting to understand your point ;)
08:15:21 <inkbottle> OK, so I understand now what you said above. By the way, is "vs" acronym I can find a definition of on the net?
08:15:53 <Welkin> versus
08:15:56 <Welkin> in comparison to
08:16:06 <inkbottle> OK ;)
08:16:14 <Welkin> you wink too much
08:18:31 <inkbottle> "for versus format" doesn't make much more sense; anyway, thanks for the 'lisp' example.
08:22:10 <monochrom> I totally used (define x+y (+ x y)) on my students. >:)
08:23:36 <monochrom> How about "the word 'for' vs the word 'format'"?
08:24:07 <inkbottle> What is nice is that you probably don't get an "variable out of scope 'x'", at least not before running it
09:30:47 <talqu> hi, with haskell-mode in emacs i always see this Could not find module ‚ÄòSome.Module‚Äô Use -v to see a list of the files searched for.
09:53:38 * hackage red-black-record 2.0.2.2 - Extensible records and variants indexed by a type-level Red-Black tree.  https://hackage.haskell.org/package/red-black-record-2.0.2.2 (DanielDiazCarrete)
10:01:53 <POGtastic> hi guys, professor showed us a "state" monad yesterday - the idea being that you make an entity that, when "run," produces a value and the "next" state. I think I understand the Monad implementation, but the implementation to make it an Applicative and a Functor is baffling me. code is here: https://gist.github.com/mbottini/984289fd65a70a2a4472bb3889f3d46a
10:03:30 <POGtastic> with the Monad implementation, return creates an ST with a function that doesn't alter any state, and returns the value. and the bind operator applies the first state function, takes the value, discards the first altered state, and applies f on the result value.
10:03:49 <POGtastic> but I have no idea what the applicative ap operator is doing.
10:08:33 <phadej> POGtastic: your >>= is invalid
10:08:40 <tombusby> hey, quick q: what's the difference between `~(IntVal i1)` and `IntVal i1` in a pattern matching context
10:08:51 <Welkin> lazy pattern matching
10:08:53 <phadej> POGtastic: you should have run (f x) s'
10:09:01 <tombusby> when I remove it I get errors related to No instance for (Control.Monad.Fail.MonadFail Identity
10:09:06 <tombusby> but I don't see the relevance
10:09:38 <POGtastic> phadej: that makes more sense to me - I was wondering why it was discarding the first function's state
10:11:02 --- mode: glguy set +v lightstep
10:11:12 <lightstep> tombusby, the ~ pattern doesn't fail on pattern matching time, only when you use the value i1
10:11:21 <MarcelineVQ> ~(IntVal i1) won't be evaluated unless i1 is actually used somewhere. Did you mean to write (IntVal i1) for the second case? (IntVal i1) is one argument whereas IntVal i1 parses as two.
10:11:49 <phadej> tombusby: non-matching pattern matches are desugared into `fail` call
10:11:58 <phadej> for e.g. Maybe it's ok, because
10:12:02 <tombusby> lightstep: hmm, thanks I'm just reading the manual page on it, haven't grokked it yet, but thanks for pointing me in the right direction
10:12:03 <phadej> > fail "foo" :: Maybe Int
10:12:05 <lambdabot>  Nothing
10:12:09 <tombusby> phadej; ah-ha, that makes sense
10:12:39 <POGtastic> i'm mostly confused as to what exactly an Applicative of STs is, since STs themselves *must* contain functions, and I'm used to stuff like the Maybe applicative, where they don't have to.
10:12:40 <tombusby> phadej: thanks, I get it now
10:13:03 <Welkin> POGtastic: I think you want State
10:13:05 <Welkin> not ST
10:13:12 <phadej> Welkin: the name is irrelevant
10:13:19 <Solonarv> specifically, they are desugared into a call to Control.Monad.Fail.fail if the MonadFailDesugaring extension is enabled, which it is by default in ghc 8.6
10:13:31 <phadej> look at the pasted code in the gist
10:13:32 <Solonarv> Welkin: they're defining it themselves, not using the existing one
10:13:36 <Welkin> long story short: haskell is too complicated
10:13:57 <monochrom> Welkin: The prof chose to call it ST and actually that was a popular name for this two decades ago.
10:13:59 <phadej> and in GHC-8.8 there won't be `fail` in Monad class!
10:14:06 <c_wraith> POGtastic: the type parameters of something don't determine what data type it actually is.
10:14:27 <Welkin> monochrom: so your point is that professors are really outdated
10:15:02 <monochrom> No, my point is that open-mindedness and awareness of history are preferred.
10:16:01 <Solonarv> phadej: oh, that soon? cool!
10:16:35 <phadej> Solonarv: "soon", it was ongoing project since 8.0
10:16:58 <phadej> Solonarv: https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail#Transitionalstrategy
10:17:13 <cocreature> Thanks to everyone that worked on making it happen!
10:18:05 <Solonarv> yeah, I was just expecting the schedule to be longer than that
10:18:11 <Solonarv> it's great that it isn't!
10:18:21 <fr33domlover> Hmmm I have a monadic action with ExceptT at the top of the stack, I want to use unliftio on some part (for withMVar), are there dangers if I do this: ExceptT $ withMVar v $ runExceptT action
10:19:33 <fr33domlover> (Is this a dangerous thing, essentially bypassing the fact ExceptT doesn't have a MonadUnliftIO instance?)
10:19:44 <monochrom> Instead of bland meaningless "dangers" I would ask what does it actually do, as opposed to what you wish it to do.
10:22:50 <POGtastic> so in the Applicative implementation, I'm thinking that the type of cf is ST (s -> (a, s)). And now the type of cx needs to be ST ((a, s) -> (b, (a, s))). Is that right?
10:23:49 <_ceb> why isn't this code compiling?
10:23:51 <_ceb> https://gist.github.com/zohaad/6f224fe82ce617c2f5fe30af56555549
10:24:31 <lemmih> _ceb: What's the error message?
10:24:47 <POGtastic> _ceb: I think you want `div` if you're working with Ints.
10:25:02 <POGtastic> :t (/)
10:25:04 <lambdabot> Fractional a => a -> a -> a
10:25:04 <_ceb> Line 6: Couldn't match expected type ‚ÄòExpr‚Äô with actual type ‚ÄòMaybe a0‚Äô
10:25:13 <_ceb> :t `div`
10:25:14 <MarcelineVQ> POGtastic: no, the type of cf is ST s (a -> b) and the type of cx is ST s a this follows from the type of (<*>) :: Applicative f => f (a -> b) -> f a -> f b where your f is (ST s)
10:25:15 <lambdabot> error: parse error on input ‚Äò`‚Äô
10:25:20 <_ceb> :t div
10:25:21 <lambdabot> Integral a => a -> a -> a
10:27:15 <POGtastic> MarcelineVQ: ohhhhhh, so the s is already made, and the a is what's in question.
10:27:21 <POGtastic> s/made/declared
10:27:30 <POGtastic> thank you so much, that was confusing me
10:27:33 <_ceb> It's fixed now thanks
10:28:10 <_ceb> How do I run the eval function? eval 6 3 doesn't work
10:28:36 <_ceb> Couldn't match expected type ‚ÄòInteger -> t‚Äô with actual type ‚ÄòMaybe Int‚Äô
10:28:37 <lemmih> _ceb: Try: eval (Div (Val 10) (Val 2))
10:28:42 <monochrom> What is the type of eval again? (Guiding question.)
10:29:20 <_ceb> eval :: Expr -> Maybe Int
10:29:27 <_ceb> lemmih, thanks 
10:29:45 <monochrom> Yeah so you give one parameter, not two, and it needs to have type Expr
10:30:49 <_ceb> monochrom, and "Val" and "Div" are "codewords" for what kind of type within the type you're going to use?
10:31:01 <_ceb> Because Expr isn't a type
10:31:02 <_ceb> It's data
10:31:33 <monochrom> I don't know what "codeword" means.  Supposedly by this point you already know what data constructors are for and how to use them.  And how to work with an algebraic data type generally.
10:32:02 <fr33domlover> monochrom, well it does to what I wish, it's just that theoretically there's supposedly some loss of state or something. Now it seems it only happens when more than 1 action is unlifted, so, I think maybe my code is ok :p
10:32:55 <geekosaur> _ceb, "type within the type" is confused. would you call 'c' a "type within the type" of Char?
10:33:07 <_ceb> monochrom, what's an algebraic type?
10:33:25 <monochrom> Everything defined by the "data" keyword.
10:33:46 <monochrom> Actually let me make it even better.
10:33:54 <monochrom> Every type defined by the "data" keyword.
10:34:29 <_ceb> So algebraic type is a collection of types
10:34:34 <_ceb> Which is what I meant
10:35:06 <_ceb> geekosaur, idk what you mean
10:35:39 <geekosaur> that is why you are confused
10:35:45 <monochrom> I think that's geekosaur's point.  If you speak of "type within type" you get a lot of meaningless sentences.
10:35:48 <geekosaur> 'c' constructs a Char value
10:35:57 <geekosaur> Div constructs an Expr value
10:36:51 <geekosaur> True constructs a Bool value
10:36:59 <monochrom> And what do you make of: "data M = C1 | C2 Int | C3 Int | C4 Int | C5 Int Int | C6 Int Int"
10:37:51 <geekosaur> or even: data Maybe a = Nothing | Just a
10:37:58 <monochrom> I'm actually OK with "dude we just disagree on terminology let's not be pedantic".  OK, just make sure you get working code.
10:39:11 <_ceb> monochrom, I think you're misunderstanding: I don't know anything about terminology or Haskell in general and working code isn't a priority (although it would be nice)
10:39:29 <monochrom> What is your priority?
10:39:37 <hyperisco> realtime
10:39:38 <_ceb> Also "constructs" is very vague, I only know of it in the context of OOP
10:39:53 <_ceb> monochrom, to learn this
10:40:15 <POGtastic> from an OOP perspective, I like to think of "data Expr" as defining an abstract base class, and each of the constructors define a subclass.
10:40:20 <hyperisco> interjecting myself, did you read the wiki on ADTs, or a Haskell book?
10:40:37 <monochrom> OK, then working code is a pass/fail test of whether learning is succesful or not.
10:40:43 <_ceb> POGtastic, I would prefer to not make analogies to OOP
10:40:47 <_ceb> monochrom, exactly
10:40:59 <_ceb> hyperisco, no, I'm working through upenn's course
10:41:26 <hyperisco> interesting, I've only heard of them for game dev
10:41:46 <geekosaur> POGtastic, except that leads you to try to use a data constructor as a type, and you'll get a highly misleading error message from ghc (‚Ä¶sigh)
10:41:50 <_ceb> CIS 194 it's called
10:42:09 <hyperisco> why not read the wiki or a Haskell book then
10:42:17 <_ceb> I don't like books
10:42:36 <monochrom> The upenn course also mentions "algebraic data type" no?
10:42:51 <_ceb> I tried Haskell programming from first principles but found it very dryp
10:43:00 <_ceb> monochrom, maybe, I'm not there yet. I'm at week 1
10:43:01 <__monty__> _ceb: It's a lot more streamlined than reading irc though.
10:43:15 <POGtastic> geekosaur: that's a good point, hadn't thought about that. you can't make a function that only takes a Div, for example. it has to be in terms of Expr.
10:43:32 <__monty__> _ceb: Maybe lyah is suitable for you? It has some jokes.
10:43:36 <hyperisco> if your question is as big as "what is an ADT?" then the most practical way to get that answer is to read a chapter on that very subject
10:43:55 <hyperisco> sure you could find a YT video about it, maybe an online lecture
10:45:25 <_ceb> The first ADT I made looked like: data LightColor = G | Y | R deriving(Eq)
10:45:51 <_ceb> Here the difference is that between every | sign there's only one "word" and not two
10:45:56 <Cale> Also it can be good to try the old haskell.org/tutorial -- it's a bit rapid and the "gentle" descriptor is perhaps not entirely appropriate, but it's good for getting an overview of a lot of different things
10:46:10 <hyperisco> also practically speaking I think you'd do yourself a favour to find a way to enjoy reading more, because a lot of materials are in written form
10:46:33 <oo_miguel> I understand that if my programm is too lazy it might suffer from memory problems. But will excessvie laziness also affect speed in general?
10:46:39 <monochrom> Week 1 doesn't have this Expr and eval exercise.  That's like Week 5.
10:47:03 <Cale> oo_miguel: Excessive laziness or strictness can affect both time and space behaviour
10:47:04 <monochrom> But Week 2 has algebraic data types.
10:47:33 <c_wraith> oo_miguel: it can.  sometimes being too lazy leads to O(n^2) runtime, if garbage collection costs become significant
10:47:50 <_ceb> monochrom, I'm struggling (very hard) with week 1's homework
10:48:00 <_ceb> It feels like being thrown to the wolves
10:48:19 <Cale> _ceb: in Brent Yorgey's course?
10:48:19 <c_wraith> oo_miguel: in particular, the time the garbage collector takes to run is proportional to the current live set of the program.  If laziness has caused the live set to be O(n) instead of O(1), that can hurt a lot.
10:48:24 <monochrom> Week 1's homework is just numbers and lists and Hanoi.
10:48:48 <Cale> http://www.cis.upenn.edu/~cis194/spring13/lectures.html -- this version?
10:48:54 <MarcelineVQ> Cale: no fall16
10:48:54 <hyperisco> oo_miguel, sometimes a program suffers from memory problems because it is not lazy enough.
10:48:55 <monochrom> Hanoi is the wrongly-perceived hard one but still no Expr.
10:49:01 <monochrom> Yeah spring13.
10:49:02 <_ceb> Cale, https://www.seas.upenn.edu/~cis194/fall16/
10:49:04 <Cale> There are some other iterations of the course which are quite different
10:49:17 <Cale> ahhh
10:49:26 <c_wraith> oo_miguel: and yes, as others are telling too, not lazy enough *also* sometimes can mean the live set is O(n) instead of O(1). :)
10:50:05 <Cale> ahh, it was actually run by Joachim, nice
10:50:16 <monochrom> fall16's week 1 and 2 are full of Picture but still no Expr.
10:52:24 <geekosaur> back up and figure out how you ended up trying to do week 5's homework for week 1. because jumping ahead like that won't work, as you've discovered
10:52:34 <oo_miguel> Cale: c_wraith: hyperisco: ok, thank you all. I am checking the garabage collection (GC) time and (max?) memory usage with -sstderr frequently. 
10:53:10 <oo_miguel> can the laziness affect the speed beside GC?
10:53:24 <c_wraith> oo_miguel: -s gives you both max concurrent and total allocated memory.  Both useful numbers, but don't mix them up. :)
10:53:27 <_ceb> geekosaur, oh I tried copying some computerphile video's code
10:53:29 <hyperisco> Hell yeah :)
10:54:02 <_ceb> geekosaur, this is my week 1 homework: https://gist.github.com/zohaad/83916fd22b5fde2b55903d7dc1e4333c
10:54:10 <Cale> oo_miguel: If you build thunks for things that you are certain to need later, that incurs a small constant time cost. If you force the evaluation of things that you end up not needing to compute later, that also does.
10:54:12 <_ceb> Which I pretty much don't understand (but got help from IRC)
10:54:14 <hyperisco> oo_miguel, if strict then  const 0 doExpensiveThing  is expensive and if lazy then  const 0 doExpensiveThing  is cheap
10:54:25 <_ceb> And IRC told me to refactor, so idk I did that
10:54:34 <Cale> (though in the latter case, the time cost is arbitrarily large)
10:55:13 <Cale> oo_miguel: So it always depends -- getting the optimal performance always requires thinking about when and where things get evaluated.
10:55:50 <_ceb> I just need something that forces me to make a mental model
10:56:11 <_ceb> I havent read one book to date (for any programming language) that did this: only struggle did this
10:56:23 <Cale> oo_miguel: The general rule of thumb is that you want strictness where you're taking many separately-evaluatable bits of data and combining them together into something with few separately-evaluatable parts.
10:56:30 <Cale> e.g. summing a bunch of numbers
10:57:19 <Cale> In all other cases, laziness either provides some benefit, or it's roughly a tie.
10:57:25 <c_wraith> _ceb: I've found with Haskell, the greatest challenges to my mental model didn't come from big projects.  They came from small "that's funny" bits.
10:59:29 <c_wraith> _ceb: For instance, one time I came across this code for trimming spaces from the end of a string:   foldr (\c r -> if c == ' ' && null r then "" else c : r) ""
11:00:24 <monochrom> Hey maybe I could use that on my midterm!
11:00:26 <c_wraith> _ceb: Understanding *that*, especially its behavior on infinite strings, really forced me to learn a big new chunk of how laziness works.
11:01:06 <c_wraith> monochrom: what would you ask about it?
11:01:16 <POGtastic> monochrom: i'm now convinced that FP professors are all sadists. very charming, well-spoken sadists, but sadists
11:01:22 <POGtastic> :)
11:01:39 <monochrom> I think I'll give the direct-recursion version and say "re-express it as foldr".
11:02:14 <monochrom> No I think it's the imperative programms and profs that are masochists.
11:05:11 <oo_miguel> hyperisco: Cale: thanks a lot. and thank you for the examples~
11:08:11 <POGtastic> .... i just looked up the professional version of the ST stuff that i was working with, and surprise, it's based on a paper that my professor wrote. lol
11:08:54 <Cale> Who is your prof?
11:08:59 <POGtastic> mark jones
11:09:11 <Cale> oh cool!
11:09:54 <POGtastic> best prof at the college, but his classes make me feel very stupid
11:10:32 <Ariakenom> From my point of view, the Jedi are evil.
11:10:33 <dyl> Even just hearing mention of a professor at PSU makes me want a croissant from St Honor√®... 
11:11:15 <jmcarthur> :t rewrite $ \s -> "" <$ guard (s == " ")
11:11:17 <lambdabot> [Char] -> [Char]
11:11:26 <POGtastic> :t rewrite
11:11:27 <lambdabot> Plated a => (a -> Maybe a) -> a -> a
11:11:38 <POGtastic> huh, never seen a "plated" before.
11:11:46 <jmcarthur> It's from lens.
11:12:24 <POGtastic> :t (<$)
11:12:26 <lambdabot> Functor f => a -> f b -> f a
11:12:30 <jmcarthur> That is a version of the function c_wraith shared a few minutes ago.
11:13:09 <jmcarthur> If you are new, rewrite might be more difficult to understand than the foldr version.
11:13:58 <POGtastic> I've seen "guard" before from describing how list comprehensions work, but the rest is new to me.
11:15:55 <jmcarthur> Read it as 'rewrite the argument by replacing every " " with "" until there are none left', nothing that the pattern " " only matches spaces at the /end/ of the string containing it.
11:16:15 <jmcarthur> *noting that
11:16:45 <farkr> hey, I'm trying to build haskell Connection library but GHC is throwing a type error and I'm not sure why. I think there's some kind of version incompatibility
11:16:56 <farkr> https://bpaste.net/show/d8d0be2ad523
11:17:05 <farkr> again, this isn't my code
11:17:49 <jmcarthur> I don't think my version is lazy like c_wraith's
11:18:56 <glguy> farkr: that looks like the library you're building is missing some version bounds
11:19:19 <farkr> @glguy: it's this https://github.com/vincenthz/hs-connection
11:19:19 <lambdabot> Unknown command, try @list
11:20:15 <farkr> oh, I figured it out
11:20:20 <farkr> I'm on 8.0
11:20:41 <farkr> this library needs 8.2+
11:20:53 <glguy> farkr: yeah, that library is missing a bunch of version bounds
11:22:29 * Solonarv shakes their fist
11:27:39 <jmcarthur> Ah!
11:27:42 <jmcarthur> :t  transform (\s -> if s == " " then "" else s)
11:27:43 <lambdabot> [Char] -> [Char]
11:27:46 <jmcarthur> is lazy
11:29:11 <dmwit> :t transform
11:29:12 <POGtastic> :t transform
11:29:12 <lambdabot> Plated a => (a -> a) -> a -> a
11:29:13 <lambdabot> Plated a => (a -> a) -> a -> a
11:29:18 <POGtastic> lol @dmwit
11:29:18 * dmwit high fives POGtastic 
11:29:41 <Solonarv> % :i Plated
11:29:42 <yahb> Solonarv: class Plated a where; plate :: Traversal' a a; default plate :: Data a => Traversal' a a; -- Defined in `Control.Lens.Plated'; instance Plated [a] -- Defined in `Control.Lens.Plated'; instance Plated (Tree a) -- Defined in `Control.Lens.Plated'
11:29:45 <dmwit> How could that possibly work.
11:29:58 <dmwit> > transform (\s -> if s == " " then "" else s) "a b c"
11:30:00 <lambdabot>  "a b c"
11:30:05 <dmwit> ...?
11:30:07 * hackage fib 0.1 - fibonacci algebra  https://hackage.haskell.org/package/fib-0.1 (chessai)
11:30:13 <jmcarthur> It's only supposed to trim trailing whitespace
11:30:14 <POGtastic> > transform (\s -> if s == " " then "" else s) "a b c        "
11:30:16 <lambdabot>  "a b c"
11:30:43 <POGtastic> "Transform every element in the tree, in a bottom-up manner."
11:31:39 <dmwit> Okay. Like this?
11:31:41 <dmwit> > foldr (\c cs -> if c:cs == " " then cs else c:cs) "" "a b c    "
11:31:43 <lambdabot>  "a b c"
11:31:45 <jmcarthur> Yes
11:32:55 <jmcarthur> I was just trying to make it look more like a rewrite rule than a fold.
11:33:01 * dmwit nods
11:45:04 <delYsid> heh, I just wrote an experimental repl/shell in 300 lines of haskell.  It is amazing what can happen if you combine a number of libraries (haskeline, hint, shh).
11:50:27 <Gurkenglas> delYsid, link? I claimed a shell with a few features they named could be done in ~50 lines, that could help
12:00:42 --- mode: glguy set +v gent
12:03:37 * hackage strongswan-sql 1.1.0.0 - Interface library for strongSwan SQL backend  https://hackage.haskell.org/package/strongswan-sql-1.1.0.0 (erick)
12:06:45 --- mode: glguy set +v sariyar_
12:11:46 --- mode: glguy set -v sariyar_
12:11:53 <_ceb> Okay the 2013 version is about 100x better than 2016
12:26:04 <SoundLogic> Is there a way to unsafely define instances? Like, if I could write code that would make a function (using unsafe functions but would work) of type Dict a -> Dict b to get it instead as an instance a => b?
12:47:43 <__monty__> _ceb: Could you say why? We've had people ask about this fairly recently so it'd be good to know why you think so.
12:49:31 <MarcelineVQ> for one the other years have links to relevant learning materials at the top of each lesson that the latest lacks afaik
12:50:39 <_ceb> __monty__, the 2016 version has you dealing with graphics and types without explaining much. The 2013 version goes much more in depth in the beginning
12:52:02 <_ceb> Also MarcelineVQ's point
12:52:33 <_ceb> There's links to chapters from real world haskell and learn you a haskell
12:52:58 <_ceb> e.g. "Haskell (like Python) also has list comprehensions; you can read about them in LYAH."
12:53:04 <_ceb> LYAH is a blue link
12:53:26 <MarcelineVQ> It is important to note that all of these are notes for actual classes, a place where you'd get resources and be able to ask questions of the teacher, these just happen to be available online. They're not intended to teach you all on their own.
12:53:48 <_ceb> That being said
12:54:07 <_ceb> The 2013 version does a much better job of teaching you all on its own
12:56:40 <monochrom> I can see there are people who have the opposite opinion on this.  The debate will never end.
12:57:14 <monochrom> For example Hudak's book also does graphics first and explains later.
12:57:49 <monochrom> There are people who want the underlying theory upfront, gratifying demos later.  And there are people who want the reverse.
12:57:54 <_ceb> The graphics is not the real issue here
12:58:09 <_ceb> That is a fair point
12:58:19 <_ceb> But 2013 is in quality better than 2016
12:58:32 <monochrom> The same way there are also people who keep saying "I learn best by dive-in projects".
12:58:47 <_ceb> Graphics would be fine if sufficient explanation was given, which was not
12:58:58 <_ceb> Haven't read the book of this Hudak fellow
12:59:15 --- mode: glguy set +v rios
13:00:19 <monochrom> I think maybe Hudak interleaved demo and theory well enough.
13:00:20 <delYsid> Gurkenglas: https://github.com/mlang/mcp
13:00:22 <_ceb> bitemyapp shares my opinion I think
13:00:40 * _ceb is following his plan on github
13:01:23 <_ceb> Well executed demo + theory > well executed theory > poorly executed theory > poorly executed demo + theory
13:03:18 <TuringMachine> What is the current standard answer for people asking how to learn Haskell?
13:04:43 <sm> "what kind of people, and preferring what kind of learning material ?"
13:04:50 <dmj`> TuringMachine: the typeclassopedia is great
13:05:02 <dmj`> @google typeclassopedia
13:05:03 <lambdabot> https://wiki.haskell.org/Typeclassopedia
13:05:16 <__monty__> TuringMachine: In true haskell fashion it's a multitude of answers: LYAH, RWH (both kinda fallen out of favor though), cis 194, hutton's book, haskellbook, the wikibook, etc.
13:05:40 <_ceb> TuringMachine, do you mean for complete beginners?
13:05:42 <TuringMachine> That's fair. 
13:05:51 <__monty__> The typeclassopedia *is* great imo but I'd hardly call it a tutorial for learning haskell. You already have to know haskell to read the typeclassopedia.
13:06:04 <_ceb> __monty__, is the wikibook nice?
13:06:05 <TuringMachine> How about someone with a lot of experience with c++ and python?
13:06:34 <dmj`> TuringMachine: learn a bunch of data types, typeclasses (their laws) and memorize their instances, including writing them by hand.  Being able to identify the instances in your head when looking at typeclass member functions in random code is most of the learning.
13:06:50 <dmj`> Typeclassopedia is great for that
13:07:26 <__monty__> _ceb: I'm not sure. I've encountered it when googling stuff and it's always been good info but I never read it to learn the language.
13:07:36 <tdammers> TuringMachine: I came from a similar background, and found Real World Haskell useful. I'd also recommend keeping Stephen Diehl's "What I Wish..." bookmarked. Biggest caveat with RWH is that it's quite old, and hasn't been updated to reflect modern Haskell programming practices or the current state of the library and tooling ecosystem.
13:07:46 <tdammers> @where what
13:07:46 <lambdabot> I know nothing about what.
13:07:49 <tdammers> hmm
13:08:01 <_ceb> __monty__, how about: The Haskell School of Expression: Learning Functional Programming through Multimedia
13:08:02 <tdammers> http://dev.stephendiehl.com/hask
13:08:08 <_ceb> Assuming that's what you meant by Hudak
13:08:15 <tdammers> there's also "Write Yourself A Scheme"
13:08:17 <tdammers> @where scheme
13:08:18 <lambdabot> https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
13:08:18 <_ceb> He also has a Haskell + music book?
13:08:23 <sm> TuringMachine: I always suggest https://leanpub.com/haskell-cookbook as a quick way to get up to speed. As you see there's no standard answer
13:09:33 <TuringMachine> I have been enjoying reading Real World Ocaml. Then I started reading Xavier Leroy's The ZINC Experiment.
13:09:35 <__monty__> _ceb: Never heard of that one so I can't say.
13:09:58 <TuringMachine> Made a lot of sense, but it wasn't exactly a substitute for RWO.
13:10:57 <monochrom> _ceb: Haskell School of Expression is the Hudak book I was talking about.  (OK maybe you already know.)
13:11:08 <sm> good stuff at https://haskell.fpcomplete.com also
13:11:09 <TuringMachine> Also, sometimes the "standard answers" are not very good ones.
13:12:02 <Cale> TuringMachine: The version of CIS 194 run by Brent Yorgey is often quite recommended. Graham Hutton's book is also a good intro.
13:12:07 <_ceb> monochrom, that's the one I asked about right?
13:12:42 <_ceb> TuringMachine, don't do the CIS 194 2013 version imo it's trash
13:12:52 <sm> probably out of date but don't overlook: https://en.wikibooks.org/wiki/Haskell
13:13:15 <MarcelineVQ> _ceb: 2013 was the one you liked
13:13:22 <Cale> _ceb: are you talking about this one? http://www.cis.upenn.edu/~cis194/spring13/
13:13:28 <Cale> What was wrong with it?
13:14:03 <Cale> This is the one most people like, anyway
13:14:31 <Cale> I know it has a few little flaws, and wish it were in wiki or git repo form so that they could get corrected :)
13:14:52 <Cale> But overall, it's a pretty good course
13:15:17 <TuringMachine> So Simon Peyton Jones was very kind to scan in a higher quality copy of The Implementation of Functional Programming Languages when I asked him.
13:15:45 <_ceb> Oh oops
13:15:48 <_ceb> My bad
13:15:58 <_ceb> MarcelineVQ, Cale meant 2016 was trash
13:16:04 * _ceb needs to go to bed
13:16:18 <TuringMachine> I don't know if there is interest in that text here, but it's still cited in the literature.
13:16:26 <_ceb> TuringMachine, DO do the 2013, don't do the 2016 version
13:16:39 <TuringMachine> Ok, I will take a look.
13:16:40 <Cale> It's a good text
13:17:17 <Cale> Well, maybe do the 2016 version, it kind of looks fun to me, but don't do it first ;)
13:17:28 <TuringMachine> Ha!
13:17:38 --- mode: glguy set +v zachk
13:17:50 --- mode: verne.freenode.net set +v zachk
13:17:51 --- mode: glguy set -v zachk
13:17:55 <glguy> zachk: traverse
13:17:56 <_ceb> Why do the Glasgow and Utrecht universities keep popping up the more I look into haskell
13:18:01 <_ceb> Glasgow makes sense
13:18:05 <_ceb> But Utrecht???
13:18:10 <glguy> zachk: or the self-contained version: mapAccumL
13:18:42 <hpc> _ceb: look up UHC
13:19:08 <TuringMachine> Simon Peyton Jones was at Glasgow when we wrote GHC. Dunno about Utrecht.
13:20:28 <_ceb> hpc, hmm their website seems to be down though: 
13:21:16 <hpc> yeah, it's not maintained anymore iirc, but historically they have done a lot
13:22:17 * sm admires the "we" in that sentence
13:22:22 <TuringMachine> The last commit is a year old: https://github.com/UU-ComputerScience/uhc
13:24:08 <sm> are you an early GHC dev, TuringMachine ?
13:24:33 <TuringMachine> No, I just have an interest in compilers and programming languages.
13:24:43 <sm> ah
13:27:45 <Cale> There are/have been a lot of researchers at UU who publish Haskell-related papers.
13:31:25 <byorgey> Cale: but it is in git repo form, https://github.com/byorgey/haskell-course  It's just that the git repo can no longer influence what is on upenn.edu =)
13:32:30 <TuringMachine> I just looked on Amazon at the Haskell books on a whim and discovered the greatest textbook cover I've ever seen: https://www.amazon.com/dp/1979788782/ref=cm_sw_em_r_mt_dp_U_RxVECb6DNAXKV
13:33:11 <TuringMachine> I have no clue if the book is any good, but with a cover like that... can it be bad?
13:35:17 <monochrom> haha
13:35:27 <monochrom> would be a great movie poster
13:35:34 <Cale> byorgey: ahh :)
13:36:29 <TuringMachine> That you everyone. I've bookmarked a few of your suggestions. Gotta go.
13:36:34 <Cale> byorgey: I was just thinking it would be neat to have a book about Haskell developed in the same fashion as the homotopy type theory book.
13:40:31 <byorgey> Cale: that would be super cool
13:48:05 <__monty__> This one? https://homotopytypetheory.org/book/
13:50:20 <[exa]> can we call the book #haskell?
13:51:07 * hackage grid-proto 0.1.0.0 - Grid-based prototyping framework  https://hackage.haskell.org/package/grid-proto-0.1.0.0 (jxv)
13:52:39 <isovector1> can i use a quantified constraint in a type family?
13:53:10 <isovector1> (i know i can't put a type family IN a quantified constraint due to #14860 --- but the converse seems like it should be doable?)
13:53:29 <isovector1> ghc complains: Illegal polymorphic type: forall (m :: * -> *) a. Show (t m a)
13:54:31 <isovector1> given by the instance:   ShowAll (t ': ts) = (forall m a. Show (t m a), ShowAll ts)
13:57:07 <__monty__> Cale: ^
13:57:31 <Cale> __monty__: yes
14:00:09 <__monty__> Thanks, I'll check it out. Is it readable with minory TT background?
14:03:22 <_ceb> I'm completely stuck on a recursive approach to this problem:
14:03:35 <_ceb> I need to double every 2 digits from right to left in a list. So [1,2,3] becomes [1,4,3] but [1,2,3,4] becomes [2,2,6,4]
14:03:50 <_ceb> Every time I try to use reverseList everything gets messed up
14:04:39 <hpc> _ceb: this might be an easier intermediate function to write:
14:04:56 <hpc> given a list, f, and g - apply f and g to alternating elements of the list
14:05:33 <hpc> alternate f g [] = ?
14:05:39 <hpc> alternate f g (x:xs) = ?
14:06:46 <hpc> there's a trick to it that's easier to see when it's more generic, because there's fewer things that typecheck
14:06:57 <hpc> once you have that, alternate between (*2) and id
14:07:30 <koz_> hpc: That's pretty clever.
14:24:24 <hololeap> would these examples produce faster code than what GHC would produce from their equivalents using pure code? https://wiki.haskell.org/Monad/ST#A_few_simple_examples
14:26:22 <hyperisco> I would hope the difference is insignificant so long as you use foldl' in the case of summing.
14:29:04 <monochrom> Going through an STRef is slower than just passing parameters.
14:31:23 <monochrom> Not to mention that modifySTRef n (+x) incurs the same unwanted laziness problem as foldl
14:31:27 <Solonarv_> indeed
14:32:05 <Solonarv_> if I had to guess, the big wins from using ST come from being able to modify a small part of e.g. an STArray without having to copy the whole thing
14:33:43 <monochrom> Yes.
14:34:30 <monochrom> I totally use ST for random shuffling. Marshal list into mutable array, shuffle there, marshal back to new list.
14:58:07 * hackage haeredes 0.5.0 - Confirm delegation of NS and MX records.  https://hackage.haskell.org/package/haeredes-0.5.0 (MichaelOrlitzky)
14:59:54 <hpc> that's an interesting tool
15:14:43 --- mode: glguy set +v Boarders
15:14:56 --- mode: glguy set -v Boarders
15:15:11 <Boarders> does anyone know how to write the function:
15:15:33 <Boarders> hoist (Monad m, Monad n) => (forall a. m a -> n a) -> RandT g m a -> RandT g n a
15:15:48 <Boarders> give that the module doesn't export its constructors?
15:17:42 <c_wraith> depends on what other tools you have, then.
15:18:24 <c_wraith> that RandT is probably identical (in implementation) to StateT
15:18:33 <rotaerk> hmm, why are my trace messages not being displayed when I run cabal new-test
15:19:24 <rotaerk> not entirely sure if it's specific to new-test
15:19:59 <lukelau> I‚Äôm getting ‚Äútruncated tar archive‚Äù when doing any `cabal new-*` commands, I presume something went wrong with one of the cached packages. What folder should I delete to clear the global cache?
15:20:44 <Solonarv_> RandT g m a is a newtype over StateT g m a
15:22:52 <Solonarv_> you could simply unsafeCoerce your 'RandT g m a' to 'StateT g m a', use mapStateT to change 'm' to 'n', and then unsafeCoerce the 'StateT g m a' back to 'RandT g m a'
15:23:15 <Solonarv_> (if the RandT constructor was in scope you could use 'coerce' instead of 'unsafeCoerce')
15:23:43 <_ceb> Is this towers of Hanoi implementation correct? https://gist.github.com/zohaad/d0f4d59530e1e40dee48f473e95b778c
15:23:52 <_ceb> I have no clue why it works, but it does
15:24:28 <rotaerk> oh guess trace is for ghci
15:24:33 <Boarders> Solonarv_: good idea, it is frustrating that modules don't export constructors because it means you can't use tools like deiving via 
15:24:35 <Boarders> deriving*
15:24:39 <Boarders> similarly you can't use coerce
15:24:50 <Boarders> I think its a bit mistake even if you want a safe interface
15:24:56 <Solonarv_> yeah
15:25:00 <Boarders> just have an unsafe internal module where you do expose the constructor
15:25:05 <Solonarv_> at least export them from a .Internal module!
15:25:32 <_ceb> No I get it
15:25:35 <_ceb> It's genius
15:25:38 <_ceb> Wow 
15:25:51 <Solonarv_> well, in this case you can at least unsafeCoerce your way through the constructor
15:26:05 <Boarders> that is true
15:26:28 <Boarders> but if we are to have safe coercions then we might as well design things around them
15:26:40 <Solonarv_> yeah!
15:27:05 <Solonarv_> doing cool stuff with coerce > doing the same stuff with unsafeCoerce
15:27:59 <hpc> it's cooler because it's safe
15:28:55 <hpc> although sometimes it's fun to do the reverse, and be needlessly unsafe
15:29:05 <hpc> eitherToMaybe = unsafeCoerce -- :D
15:29:39 <Solonarv_> that's why I specified "the same stuff" :P
15:30:03 <hpc> void = unsafeCoerce
15:30:17 <hpc> null = not . unsafeCoerce
15:30:33 <Solonarv_> so efficient!
15:30:56 <hpc> almost as fast as C++!
15:32:03 <hpc> _ceb: that's a neat function
15:33:11 <_ceb> hpc, thanks :D
15:34:18 --- mode: glguy set +v Ulbrec
15:34:20 <hpc> although if you were a mathematician: "i have no clue why it works, but it does ... no i get it ... it's trivial"
15:34:40 <_ceb> It *is* trivial though :p
15:34:56 <_ceb> A "middle-out" approach
15:35:25 <_ceb> Now I need to do this with 4 sticks
15:35:30 <_ceb> As optimally as possible
15:36:56 <hpc> i guess you can think of it as, move most of the tower, then move just the bottom piece, then move the tower again
15:43:09 <_ceb> hpc, yeah
15:43:38 * hackage haeredes 0.5.1 - Confirm delegation of NS and MX records.  https://hackage.haskell.org/package/haeredes-0.5.1 (MichaelOrlitzky)
15:48:07 * hackage texmath 0.11.2.1 - Conversion between formats used to represent mathematics.  https://hackage.haskell.org/package/texmath-0.11.2.1 (JohnMacFarlane)
15:50:02 <_ceb> My head hurts thinking of Hanoi with 4 poles
16:08:20 <_ceb> hpc, do you know how you'd do towers of Hanoi with 4 poles instead of 3?
16:09:26 <hpc> i would alternate between the two spare poles in some way, i think
16:10:31 <hpc> imagine you had n=4 and 4 poles, i think
16:11:03 <hpc> or n=3 rather
16:11:06 <_ceb> Why can't you imagine n-=3
16:11:22 <hpc> you'd put the top two pieces on alternate poles, move the bottom element, and restack
16:11:26 <_ceb> I got: a-d, a-c, a-b, c-b, d-b
16:11:28 <hpc> and you're done with no fiddly bits
16:11:36 <_ceb> That moves from a to b
16:12:21 <hpc> with 4 pieces you'd do the same opening, but move the smallest onto the other spare peg after, then move the second-largest
16:12:25 <_ceb> Turning this into recursive code is the hard part
16:12:32 <hpc> then move the smallest back to the start and you're basically done
16:12:35 <hpc> yeah
16:17:12 <_ceb> This exercise is optional
16:17:14 <_ceb> I'm skipping it
16:35:07 * hackage geodetic-types 0.0.3 - Types for geodetic operations  https://hackage.haskell.org/package/geodetic-types-0.0.3 (qfpl)
16:51:19 <nfd> Hey, I'm trying to get HIE working in ALE. It's silently failing to load, and when I try to run hie, it can't find GHC
16:51:39 <nfd> Possibly in part because I only have GHC installed through stack
16:52:45 <nfd> I'm also not working inside a stack/cabal project (just a little scratch file); does HIE require that or something?
16:53:16 <Solonarv_> nfd: there should be a hie-wrapper executable which looks for a stack/cabal project file and figures out the appropriate hie invocation for you
16:54:01 <nfd> Ah, ok, so I can go set up a skeleton of a Stack project and tell ale to instead launch hie-wrapper?
16:54:06 <nfd> i'll give that a shot
17:02:44 <dmwit> _ceb: Just so you know, I believe that's still an open problem. So no sweat if you come up with something pretty good but can't prove it optimal.
17:06:06 <nfd> Solonarv_: awesome, that got me about halfway there
17:06:47 <nfd> it's still not working with ALE though, apparently
17:07:54 <nfd> insofar as i wrote something with an obvious type error and it didn't complain
17:07:57 <suzu> anyone know about the generic stack builder in nix?
17:08:47 <suzu> its failing with error 1 and no info :(
17:10:29 <nfd> ...ah, it's getting another GHC now, apparently
17:11:05 <nfd> i guess i actually need to learn how to use Stack, hahaha
17:12:57 <nfd> it'd be nice if ale failed a little more aggressively, i guess
17:27:43 --- mode: glguy set -q $~a
17:43:07 * hackage libarchive 0.2.1.2 - Haskell interface to libarchive  https://hackage.haskell.org/package/libarchive-0.2.1.2 (vmchale)
17:48:00 <slaterr> just figured that BlockArguments was implemented in 8.6.1.. neat :)
17:50:07 * hackage pandoc-citeproc 0.16.1.1 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.16.1.1 (JohnMacFarlane)
17:51:08 * hackage cpkg 0.1.1.0 - Build tool for C  https://hackage.haskell.org/package/cpkg-0.1.1.0 (vmchale)
18:49:55 <inkbottle> Welkin, monochrom: "for vs. format", completely missed it! How dumb of me! Of course, prefix. How silly.
18:52:14 <drew> hello frens
18:52:31 <Guest3704> is it possible to use type holes on the left of an arrow?
18:52:41 <Guest3704> _mything <- func x1 x2
18:52:51 <Guest3704> and have ghcid tell me the type of the expression?
18:54:54 <glguy> Try: _mything <- func x1 x2 :: _
18:55:17 <Guest3704> that type hole at the end tells me the return of (func x1 x2)
18:55:38 * hackage kafka-device 1.0.2.0 - UI device events via a Kafka message broker  https://hackage.haskell.org/package/kafka-device-1.0.2.0 (BrianBush)
18:56:39 <pavonia> Guest3704: What about `(_mything :: _) <- func x1 x2`?
18:57:19 <Guest3704> forbidden
18:57:28 <Guest3704> Type signatures are only allowed in patterns with ScopedTypeVariables
18:57:55 <pavonia> You need to enable an extension, IIRC
18:59:11 <Guest3704> yeah doesn't like it even with ScopedTypeVariables extension enabled
18:59:14 <Guest3704> lol this is strange
18:59:22 <Guest3704> is this not a requested functionality?
19:00:08 * hackage kafka-device-glut 1.0.1.0 - GLUT events via a Kafka message broker  https://hackage.haskell.org/package/kafka-device-glut-1.0.1.0 (BrianBush)
19:01:48 <MarcelineVQ> % (foo :: _) <- pure 3
19:01:48 <yahb> MarcelineVQ: ; <interactive>:58:9: error:; * Found type wildcard `_' standing for `Integer'; To use the inferred type, enable PartialTypeSignatures; * In a pattern type signature: _; In the pattern: foo :: _; In a stmt of an interactive GHCi command: (foo :: _) <- GHC.GHCi.ghciStepIO :: forall a. IO a -> IO a (pure 3)
19:01:58 <MarcelineVQ> seems to work
19:02:19 <Guest3704> interesting?
19:02:43 <Guest3704>   (_splitted :: _) <- T.splitOn "," row
19:02:50 <Guest3704> that's the exression
19:02:55 <MarcelineVQ> But it's not like you learn anything more than you do with glguy's example
19:02:56 <Guest3704> it uses Data.Text
19:03:30 <Guest3704> is it anything to do with me using `stack exec ghcid`?
19:03:40 <Guest3704> is it a different version or something?
19:03:49 <MarcelineVQ> I don't think that's a valid use of <-
19:04:14 <MarcelineVQ> you probably wanted let splitted = T.splitOn "," row
19:04:16 <Guest3704> it compiles?
19:04:22 <Guest3704> well
19:04:27 <Guest3704> splitOn returns a list
19:04:31 <Guest3704> i want a single element of it
19:04:38 <MarcelineVQ> Oh fair, silly me\
19:04:47 <Guest3704> so x <- splitOn a b :: [Text]
19:04:50 <Guest3704> and x :: Text
19:04:58 <Guest3704> that's what I'm expecting the compiler to tell me
19:05:01 <Guest3704> and it doesn't want to
19:05:11 <Solonarv_> if you want ghcid to tell you the type of something, make it correct you
19:05:37 <Solonarv_> write '(x :: ()) <- splitOn a b'
19:05:59 <Solonarv_> now ghcid will happily tell you "no, x's type isn't (), it's <whatever x's type is>"
19:06:13 <Guest3704> it doesnt for me
19:06:26 <Guest3704> Type signatures are only allowed in patterns with ScopedTypeVariables
19:06:29 <Guest3704> that's what it says
19:06:37 <Guest3704> for (x :: ()) <- splitOn a b
19:06:37 <Solonarv_> well yes, you need to enable ScopedTypeVariables
19:06:42 <Guest3704> i did
19:06:54 <Guest3704> {-# LANGUAGE ScopedTypeVariables          #-}
19:07:22 <Guest3704> does that require me to run `stack install`?
19:07:25 <Solonarv_> ...and ghcid still thinks STV isn't enabled?
19:07:27 <Guest3704> this is in ghcid
19:07:29 <Guest3704> yeah
19:07:34 <Solonarv_> try restarting it I guess
19:07:50 <Guest3704> wowwwwww
19:07:55 <Guest3704> it's a christmas miracle
19:07:59 <Guest3704> damn, thanks guys
19:08:04 <Guest3704> that was driving me crazy
19:08:12 <Guest3704> any downside to keeping that enabled?
19:08:23 <Guest3704> like, does it introduce some other effect that is unwanted?
19:08:31 <MarcelineVQ> Not that I'm aware of
19:08:44 <MarcelineVQ> To use it's other functionality you have to be using excplicit foralls in your type sigs
19:21:09 <inkbottle> Welkin, monochrom: However there usually is no ambiguity between for and format, because the tokenization hopefully relies on rules excluding prefix check. All the "try" in the example seem contrary to the rule that the parser shouldn't fail, and must be computationally bad. But I understand some languages do that...
19:57:38 * hackage fakedata 0.1.0.0 - Library for producing fake data  https://hackage.haskell.org/package/fakedata-0.1.0.0 (psibi)
20:35:38 * hackage hpack 0.31.2 - A modern format for Haskell packages  https://hackage.haskell.org/package/hpack-0.31.2 (SimonHengel)
20:37:38 * hackage glob-posix 0.2.0.0 - Haskell bindings for POSIX glob library.  https://hackage.haskell.org/package/glob-posix-0.2.0.0 (rdnetto)
21:36:07 * hackage glob-posix 0.2.0.1 - Haskell bindings for POSIX glob library.  https://hackage.haskell.org/package/glob-posix-0.2.0.1 (rdnetto)
22:34:31 <xpika> is there a way to construct a constructor via it's name? like  mkConstructor "Nothing" == Nothing ,  mkConstructor "True" == True 
22:34:45 --- mode: glguy set +v nivpgir36
22:45:37 * hackage haskell-dap 0.0.12.0 - Haskell implementation of the DAP interface data.  https://hackage.haskell.org/package/haskell-dap-0.0.12.0 (phoityne_hs)
22:46:04 <koz_> > read "Nothing" :: Maybe Int
22:46:07 <lambdabot>  Nothing
22:46:19 <koz_> > read "True" :: Bool
22:46:21 <lambdabot>  True
22:46:25 <koz_> xpika: ^
22:46:36 <jmcarthur> But it's probably not what you are looking for because
22:46:41 <jmcarthur> > read "True"
22:46:43 <lambdabot>  *Exception: Prelude.read: no parse
22:46:56 <koz_> jmcarthur: Yeah, there is that slight inference problem.
22:57:47 <Lears> That's mostly just a repl issue; actually using the value tends to tie down its type.
22:57:53 <Lears> > not (read "True")
22:57:55 <lambdabot>  False
22:58:11 <Lears> > read "True" && read "False"
22:58:13 <lambdabot>  False
23:17:08 * hackage ghci-dap 0.0.11.0 - ghci-dap is a GHCi having DAP interface.  https://hackage.haskell.org/package/ghci-dap-0.0.11.0 (phoityne_hs)
23:56:02 <abiduzz420> hello is this channel active ? All I see people leaving and joining (PS: I am quite new to IRC)
23:59:27 <Eduard_Munteanu> abiduzz420, one of the most active on the network, although like most channels here it depends on the time of day. 
