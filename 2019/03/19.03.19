00:01:26 <dminuoso> Interesting, it appears that one can write: instance (MonadUnliftIO m, MonadUnliftIO n) => Monad (m :.: n) where
00:02:40 <dminuoso> Well. Not with that exact newtype, but in spirit.
00:13:44 <dminuoso> Library question. When you ship a library that has has some sum types, would you ship lens optics in the same package (requiring lens for makePrism), or would you rather make a seperate package for just the lenses?
00:16:16 <MarcelineVQ> somehow I thought you could leave that up to the user, maybe just by having the field names _foo and letting them makeLens if they want to
00:17:06 <MarcelineVQ> e.g. https://hackage.haskell.org/package/directory-tree-0.12.1/docs/System-Directory-Tree.html#g:12 where the src has the comment: --makeLensesFor [("name","_name"),("err","_err"),("contents","_contents"),("file","_file")] ''DirTree
00:18:05 <MarcelineVQ> probably a little unwieldy compared to a separate package, if you have enough to warrant one
00:18:56 <dminuoso> MarcelineVQ: Well I'd rather ship a seperate package because internally we depend on the package and lenses across a few projects.
00:19:10 <dminuoso> Creating them in the final projects is what I have been doing so far.
00:24:08 <Phyx-> @bioeth why doesn't it work in ghci? 
00:24:08 <lambdabot> Unknown command, try @list
01:58:37 * hackage main-tester 0.2.0.1 - Capture stdout/stderr/exit code, and replace stdin of your main function.  https://hackage.haskell.org/package/main-tester-0.2.0.1 (igrep)
02:32:17 <TimoMeijer> I'm getting 'type variable `stat0` is ambiguous' error on line 8 in this code: https://gist.github.com/TimoMeijer/37a9e61084862fb9cd05b3abd2e9aca5 And I'm not sure why, or how I could redesign my API to circumvent that
02:33:55 <TimoMeijer> I suspect it's because Layer "hides" the actual typeclasses, but as I'd like to put multiple in a list, I'm not sure how to modify the design to allow for that. Or would I need to add type variables to Layer and use a HList instead?
02:39:51 <TimoMeijer> Rewriting Layer using ExistentialQuantification results in the same error
02:52:54 <asheshambasta> Hi all: quick question about formatting. I'm using Brittany and I see sometimes that it indents the "where" clause by 1 space only, why is that? Is that an aesthetic choice or is there something I'm missing out
02:52:57 <asheshambasta> ?
02:53:44 <phadej> asheshambasta: it indents where by half-indent
02:53:58 <asheshambasta> phadej: why?  
02:55:33 <int-e> asheshambasta: I do that as well; my reason is that it interacts nicely with do syntax (or case expressions), as in http://paste.debian.net/1073727/
02:55:49 <phadej> asheshambasta: https://gist.github.com/phadej/7e290c2d9cb91aa9e1a4c7516d4d8187 because first variant is "ugly" as in irregular
02:56:03 <int-e> (hmm, that's using indent depth 3 by accident; my default is actually 4)
02:57:06 <int-e> it also makes the 'where' stand out from the function body
02:57:31 <int-e> But there's no hard reason, I think... it comes down to taste.
02:58:44 <phadej> double indent of bindings in where **is** out of question for depth=4 people
02:58:57 <phadej> using small depth makes you tolerate inconsistencies :)
02:59:05 <phadej> so: don't use small depth
02:59:22 <phadej> (you are free to disagree)
03:00:10 <asheshambasta> also, what is the consensus on 2 vs 4 spaces? 
03:00:27 <TimoMeijer> asheshambasta: Personal preference ;)
03:00:50 <phadej> asheshambasta: there aren't
03:02:04 <avn> phadej: I found that by-one indentation increment (1 space for where, and one for next line -- make it too smooth, and hard to read. But probably is a my python background)
03:02:12 <NK97> https://chat.stackoverflow.com/rooms/110313/haskell-and-other-functional-languages
03:02:23 <NK97> ^ no one ever visits
03:02:50 <NK97> i assume that's because you didn't know it existed
03:03:28 <d1010> is a normal chat but on stackoverflow?
03:03:50 <phadej> avn: I agree; and I personally use 4 space indentation; so half-indents aren't problem
03:04:11 <avn> phadej: I use 4 for all, but 2 for where usually ;)
03:05:03 <NK97> d1010: yeah, SO is where most good chats are. Transcripts are public too. Easy access to convos.
03:05:14 <NK97> jmorris: are u traversy media?
03:05:36 <NK97> my best friend's name was joseph monnis. lol
03:05:37 <jmorris> NK97: ?
03:05:43 <jmorris> No
03:05:54 <NK97> jmorris: traversy's name is also morris. that's wy i asked
03:07:00 <NK97> wait, google says that's brad traversy
03:07:03 <NK97> mhh..
03:07:12 <NK97> jmorris: i know u. do u have a yt channel?
03:07:16 <d1010> oks, nice. I'll go to see
03:07:26 <jmorris> No I dont NK97 
03:07:27 <NK97> https://en.wikipedia.org/wiki/John_Morris_(actor) <-- google says you're ANDY!! woah.
03:07:41 <NK97> maybe that's why i feel i know u
03:07:55 <NK97> it's funny to feel dejavu about people uv nvr met b4
03:08:54 <d1010> You must have 20 reputation on Stack Overflow to talk here (sad story) on stackov
03:09:01 <NK97> jmorris: are you from cleveland
03:09:15 <NK97> d1010: lol, yeah. that's there.
03:09:27 <jmorris> Not really haskell relevant NK97 
03:09:35 <NK97> 20 points is easy though. Just answering a few questions well gets you a lot.
03:09:50 <NK97> jmorris: ok, monads then.
03:09:51 <NK97> lol
03:09:57 <NK97> sorry, to diverge.
03:10:08 <d1010> lol crazy stack
03:23:39 <superlinux> hello
03:28:50 <superlinux> hello. I am getting this error when i try to use the regex class [:alpha:] :  Exception: user error (Text.Regex.PCRE.String died: (0,"POSIX named classes are supported only within a class")) 
03:29:05 <superlinux> so how can I fix it?
03:31:09 <kuribas> @hoogle IO Bool -> IO () -> IO ()
03:31:10 <lambdabot> Graphics.UI.SDL.WindowManagement rawSetCaption :: Maybe String -> Maybe String -> IO ()
03:31:10 <lambdabot> System.Random.Mersenne.Pure64.Base c_next_genrand64_block :: Ptr a -> Ptr a -> IO ()
03:31:10 <lambdabot> Control.Concurrent.PooledIO.Independent runLimited :: Int -> [IO ()] -> IO ()
03:39:16 <Ariakenom> TimoMeijer: maybe less typeclasses. Geom and Stat could just records? {Aesthetics -> Diagram b, Stat}, {Aesthetics -> Aesthetics, Geom}
03:44:00 <[exa]> TimoMeijer: oh noes, you're porting ggplot to Haskell? :]
03:45:01 <TimoMeijer> [exa]: Trying to, for my advanced functional programming class ;)
03:45:41 <TimoMeijer> Ariakenom: That... might actually work
03:45:50 <TimoMeijer> I'm still curious as to what causes the error though
03:45:59 <[exa]> oh great
03:46:39 <Ariakenom> TimoMeijer: like you said, the type stat disappears from the type but is polymorphic
03:48:26 <Ariakenom> the code looked a bit like using type-classes as OOP-classes. rule of thumb is don't define type classes :p
03:49:32 <TimoMeijer> Ye, I'm still struggling with how the possibilities to extend datatypes, or in what cases you even need to do that
03:50:37 <[exa]> Ever thought of GOG as lenses?
03:51:19 <TimoMeijer> But shouldn't the type stat be known during the function call, as it is technically defined by with what geom you call the function with
03:52:25 <TimoMeijer> [exa]: Yes, this is far from what I'd like to do with the design, but we now want to work towards a working prototype first, before diving back into the infinite possibilities of design ;P
03:52:35 <Ariakenom> that's not what "defaultStat :: Stat stat => geom -> stat" means
03:53:07 <Ariakenom> that means given the specific geom you can produce any stat
03:53:35 <TimoMeijer> Ahh, of course, that isn't what I want
03:54:04 <[exa]> TimoMeijer: well, in Haskell it's actually simpler to do the data manipulation by hand so you don't need to fall back to R's "everything's a data frame"
03:54:55 <TimoMeijer> [exa]: I've already separated the data representation from the actual grammar, whereas in R those are practically interleaved
03:55:39 <[exa]> oh nice. What are you using as references? (eg. as in aes(Col1, Col2) )
03:56:59 <TimoMeijer> [exa]: For the prototype I had to fixate Aesthetics as simple a record datatype, as I couldn't figure out extensible records and the typelevel stuff in time for the deadline
03:58:20 <TimoMeijer> [exa]: I'd like to use Vinyl and typelevel magic to make it so that each Geom relies on some Aesthetics, which then need to be provided by the Mapping, but that'll take some significant effort to get to work
03:59:22 <TimoMeijer> Will probably keep working on it even after the course, as I quite like the subject, and would love to develop a better understanding of those advanced topics
03:59:39 <Ariakenom> a common beginner mistake is to use classes where first class functions and IO would be simpler
04:05:07 <TimoMeijer> Ye, I arrived at this design from different iterations, and didn't consider that differen Geoms don't /have/ to be their own datatypes anymore
04:08:42 <superlinux> hello. I am getting this error when i try to use the regex class [:alpha:] :  Exception: user error (Text.Regex.PCRE.String died: (0,"POSIX named classes are supported only within a class")) 
04:08:43 <superlinux> so how can I fix it?
04:09:42 <superlinux> what I am doing is : "to be matched string" =~ "regexp formula" . that's all
04:10:04 <superlinux> but in the regexp I am getting the error above
04:10:22 <hpc> i think it needs to be [[:alpha:]]
04:10:47 <hpc> "[:" and ":]" say it's a character class, "alpha" is which one it is
04:10:57 <hpc> and the outer "[]" are because it needs to be in a bracket group
04:11:03 <hpc> like [a-z]
04:12:08 <superlinux> ah right!!
04:12:23 <superlinux> hpc, thanks.
04:12:27 <hpc> :D
04:12:31 <hpc> also TIL about man 7 regex
04:15:59 <superlinux> hpc, i think it's the pressure of my job made me forget
04:16:02 <superlinux> thanks
04:17:11 <hpc> i have never used it before at all, so i think it's fine to forget
04:17:16 <hpc> in perl you just say \w wherever you want
04:17:33 <superlinux> :)
04:20:37 * hackage aern2-mp 0.1.4 - Multi-precision ball (interval) arithmetic  https://hackage.haskell.org/package/aern2-mp-0.1.4 (MichalKonecny)
04:21:37 * hackage aern2-real 0.1.2 - Exact real numbers via Cauchy sequences and MPFR  https://hackage.haskell.org/package/aern2-real-0.1.2 (MichalKonecny)
04:38:53 <ocharles> Does anyone know of some function that gives me the time a program has been running, such that it would line up with the x-axis in a heap profile?
04:39:10 <ocharles> I'm performing a manual GC, and I want to report the time that this occurs to see if it's making a dent in the heap profile
04:47:37 <phadej> ocharles: isn't elapsed_ns in http://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Stats.html that time?
04:47:59 <ocharles> Ah nice, it might be that
04:58:25 <zincy> When someone asks you what functional programming is what do you say?
04:58:30 <zincy> Programming with functions?
04:59:29 <bor0> in my opinion this Tweet captured it nicely https://twitter.com/PaniczGodek/status/1107629481064316928 -- although you may get different answers from different people :)
05:01:29 <zincy> Is equational reasoning basically being able to substitute expressions with values?
05:01:36 <hpc> yes
05:01:56 <zincy> That is a much stricter definition than most people hold.
05:02:07 <hpc> it's what you do in high school algebra when you substitute stuff around to put equations in the most convenient form
05:02:21 <zincy> Many say that the use of map and reduce in Javascript is functional programming. :P
05:03:04 <zincy> I like the equational reasoning explanation. It is very simple.
05:03:08 <__monty__> Weird how that tweet seems negative about haskell while its definition of FP excludes practically anything but haskell...
05:03:10 <hpc> it is, if you think about using it in replacement of a for loop
05:03:38 <hpc> you're going from thinking about "do these steps multiple times" to "this list equals this list with something applied to each element"
05:04:07 <hpc> it's not if you think about it as "i can write this for loop in fewer lines"
05:04:09 <zincy> Isn't that just more declarativity?
05:04:30 <hpc> there's a lot of overlap
05:05:16 <zincy> Yeah true.
05:05:43 <bor0> __monty__, well one can argue whether side-effects represent the essence of FP or not :)
05:06:01 <hpc> in any event, it's necessary overlap
05:06:18 <hpc> effectful programming with lots of callbacks and function pointers and mutation in specific threads isn't functional programming
05:06:28 <hpc> but you see that a lot in say, game code
05:06:49 <zincy> I hope Rust takes off for games. 
05:07:07 <zincy> I am kinda worried about working for an OO focused company.
05:07:25 <__monty__> bor0: They don't really matter to whether something is FP imo. Not calling racket/guile/clojure, scala, F#, ocaml and plenty more FP makes the term pretty useless imo.
05:07:48 <__monty__> They're all FP, haskell I'd call pure FP.
05:08:00 <zincy> Just because after learning Haskell you see all these problems with imperative code and you probably have unrealistic expectations :)
05:08:40 <zincy> I mean the amount of times people just access array elements without checking if the list is empty.
05:08:48 <hpc> __monty__: they're FP in the same way perl is OO - it's an afterthought or something they half-implemented on the way to doing something else
05:09:26 <hpc> to varying degrees, in the languages you mention
05:09:35 <__monty__> I disagree and I don't see why restricting FP to what we can already simply call pure FP is useful.
05:09:38 <hpc> F# from what i understand is very close to pure FP
05:10:24 <zincy> Its a useless term indeed if it only refers to a couple of languages
05:10:36 <hpc> it's a useless term if it applies to every language too
05:10:42 <zincy> You could restrict the term to languages whereby the only first class value is a function.;
05:10:54 <hpc> having a definition that keeps in mind the "end goal" is useful
05:11:10 <hpc> and letting things not quite reach that definition gives you nuance
05:11:15 <zincy> Exactly.
05:11:23 <__monty__> There's tons of languages that clearly don't fall in the FP category even if you don't restrict it to pure FP.
05:12:33 <hpc> mostly i don't want the term to turn into "object oriented programming", which has a dozen different mutually exclusive definitions
05:12:34 <bor0> I don't see anything wrong with defining FP as equational reasoning and substitution - after all that's what lambda calculus is all about. anything after that is just an extension
05:12:43 <aldum> any news about F*?
05:12:58 <hpc> to the extent that as a programmer hearing a new language is "object oriented", all i know is it has object.method() syntax
05:13:20 <hpc> if i don't know anything about a language other than that it's "functional", i know a lot more
05:14:02 <zincy> What is dependency injection?
05:14:12 <zincy> I hear OO programmers talking about it a lot.
05:14:30 <hpc> if the definition of OOP was better-constrained to some principled ideal like smalltalk (whether it's a good ideal is to be debated)
05:14:38 <hpc> it would be a lot more useful as an informative term
05:14:51 <hpc> and maybe language designers would have hewed closer to that ideal
05:15:03 <Entilo> Hello. If i've got a function which takes in an input such as "aaabbbccc" and outputs this like [("aaa","bbb","ccc")] , is it then possible to access only the first part of it and do something with it, i.e. just the "aaa" bit, do something with it, drop it, then the "bbb" bit and so on ?
05:15:28 <bor0> Entilo, do you maybe want `map`?
05:15:48 <bor0> (oh it's a 3-tuple, sorry)
05:15:51 <hpc> zincy: a very oversimplifying example would be, say you have foo = do {x; y; externalThing; z}
05:16:06 <hpc> zincy: dependency injection would be more or less, foo externalThing = do {x; y; externalThing; z}
05:16:16 <hpc> except with objects
05:16:38 <Entilo> bor0: there would be a different amount of tuples each time of varying lengths as well :/
05:16:44 <hpc> your database-manipulating code takes a database object that you call the methods of, instead of saying psql_query("select foo from ...")
05:16:58 <hpc> then you can pass it a mock database, or mariadb, or whatever
05:17:16 <opqdonut> Entilo: you can't put tuples of different lengths in a list. use a list of lists instead
05:17:20 <bor0> Entilo, I think it can be done in a dependently typed language. not sure whether it can be done in Haskell though
05:17:22 <hpc> and the code with the dependency injection written into it technically no longer has that dependency
05:17:30 <zincy> So the use of a mock server would be an example of dependency injection?
05:17:45 <zincy> I guess the key is that side effects are used to control the external thing
05:17:51 <hpc> not using the mock server specifically, but dependency injection enables it
05:18:12 <hpc> you don't need side effects for it either
05:18:27 <hpc> you just need to parameterize over something that has more-than-usual influence over control flow
05:18:42 <zincy> So you could have a function which say takes a stream 
05:18:58 <zincy> and because you can change the source of the stream you can control the depencency?
05:19:18 <hpc> or you can change what type of stream it is
05:19:32 <hpc> if all it knows about the stream is it has get :: Stream a -> IO a
05:19:40 <zincy> So it is the externalisation of a dependency?
05:19:45 <hpc> the stream could be a file stream, or a network connection, or a tree traversal in memory
05:19:49 <hpc> exactly
05:19:55 <zincy> Ah thanks
05:29:46 <oo_miguel> dmwit: a few days ago, concerning parsing, you told me that I can achieve (for example) Alternative effects without making my Parser an instance of this typeclass, depending on the choice of my primitives. While I now understand this in general, you also pointed out, as a little pettifoggery ;), that even for parsing constant string literals an Applicative will be to weak. I was re-thinking this recently and
05:29:48 <oo_miguel> wonder if you meant that I will need more than an Applicative to parse a single character (provide something like: satisfy :: (Char->Bool) -> Parser String Char) or you were adressing something else?
05:30:36 <Entilo> I'll try to explain what im trying to do, maybe im thinking about it incorrectly. I have to create a function (as well as use another function that I've made already) which will take a string of characters such as "aabbcc" and it'll output them in the format [('a',2),('b',2),('c',2)]
05:30:39 <Entilo> My already made function takes a string of characters such as "aaaabbbbcccc" and outputs them in a list, e.g. ["aaaa","bbbb","cccc"], so I was thinking of firstly running that, then taking the head of each chunk and putting it as a in the output, then taking the lenght of each chunk, and putting it as b in the output.
05:31:00 <Entilo> I've got my already made a function and my idea for the second function along with some examples here: https://pastebin.com/RfENLCJC
05:32:51 <c_wraith> Entilo: all told, that's pretty close. but length doesn't return a list, and <- in a list comprehension is for grabbing elements one at a time from a list
05:33:22 <c_wraith> Entilo: actually, head doesn't return a list either.
05:33:44 <Entilo> so I guess i cant use list comprehension for this
05:34:00 <c_wraith> you can, if you want.
05:34:14 <c_wraith> Just move most of the logic to the left of the |
05:34:45 <Entilo> would you say a list comprehension is the easiest way of approaching this or is there something easier?
05:35:30 <c_wraith> I'd probably just use map
05:35:56 <c_wraith> I think list comprehensions are a massive pile of syntax for just doing a simple map or filter.  They're only worth it if things get complex.
05:36:33 <Entilo> ahh okay
05:37:13 <c_wraith> are you familiar with using anonymous functions?
05:37:25 <Entilo> in java yeah not in haskell
05:37:56 <c_wraith> well, as in most comparisons, Haskell's syntax is a lot more compact. :)
05:38:17 <c_wraith> > map (\x -> (show x, 3 * x)) [1..10]
05:38:19 <lambdabot>  [("1",3),("2",6),("3",9),("4",12),("5",15),("6",18),("7",21),("8",24),("9",2...
05:39:01 <c_wraith> The middle part there is an anonymous function that takes a parameter named x, and produces a pair
05:40:33 <c_wraith> the general syntax is \ patterns -> exp
05:41:00 <c_wraith> :t \x y z -> x + y * z
05:41:01 <lambdabot> Num a => a -> a -> a -> a
05:41:14 <Entilo> ohh is that what the \ operator is for?
05:41:54 <c_wraith> It's supposed to look like the character "lambda", as in "lambda calculus", which is the study of computation as all anonymous functions
05:42:08 <Entilo> ahh yeh
05:43:19 <Entilo> that's actually pretty cool to be honest, makes sense
05:43:54 <c_wraith> syntactically, the body of a lambda tries to extend right as far as possible.  that's why the whole thing is in parens in my map example above
05:46:25 <Entilo> how could i apply that to my function? since it still uses the -> operator so i dont think head/length would work, and they might not work anyway since you were saying that they dont return lists 
05:48:20 <c_wraith> Your solution has the right idea - for each element of the output of stringToList, produce the head and the length.
05:48:44 <c_wraith> map takes care of "for each element".  that's literally exactly what it does.  :)
05:49:36 <c_wraith> And then note that the <- in a list comprehension is not the same as -> in a lambda expression.  They point different directions!
05:49:50 <Entilo> ooh true
05:49:54 <c_wraith> You can think of <- as "extract from" in all the places it appears
05:50:08 <c_wraith> whereas -> is more like "goes to"
05:50:54 <c_wraith> A bit fuzzy because both pieces of syntax are reused in a couple different contexts, but that's a good first understanding.
06:10:22 <zincy_> How are types with nullary data constructors represented in memory?
06:11:42 <Solonarv> zincy_: evaluated ADTs are represented as a tag saying which constructor it is, followed by that constructor's fields
06:11:52 <Solonarv> if there are no fields it's just the tag itself
06:12:08 <zincy_> So a string essentially?
06:12:16 <zincy_> For the tag
06:12:28 <tdammers> int, I'd think
06:12:47 <zincy_> Would you then need a lookup table from int to string?
06:12:56 <zincy_> I guess int for performance reasons?
06:13:02 <tdammers> the name gets erased
06:13:36 <zincy_> So does the Haskell code get compiled into Assembly?
06:13:46 <tdammers> machine code, usually
06:14:05 <zincy_> Is machine code usually represented in Hex?
06:14:05 <tdammers> though you can also go via LLVM bytecode
06:14:10 <Solonarv> the tag is a machine word, specifically
06:14:30 <tdammers> machine code is binary; you can represent that in hexadecimal, yes
06:14:30 <Solonarv> so 8 bytes on a 64-bit machine
06:15:28 <zincy_> Is a machine word just an arbitrary number of bytes?
06:15:34 <zincy_> Depending on the arch?
06:15:41 <tdammers> yes, pretty much
06:15:42 <Solonarv> pretty much
06:15:53 <zincy_> Cool
06:16:05 <tdammers> a machine word is whatever binary type fits in a general-purpose CPU register, usually
06:16:09 <Solonarv> as an optimization, if there are few constructors (less than 4 on 32bit, 8 on 64bit) then GHC will store the tag in the pointer's low bits
06:16:13 <zincy_> So is the machine code executed by loading it into registers?
06:16:22 <tdammers> no
06:16:26 <tdammers> well, not directly
06:16:49 <tdammers> machine code is executed by loading it into RAM, and pointing the CPU's instruction pointer register to the beginning of the block of RAM
06:16:51 <bor0> in the machine language abstraction every sequence of bytes is a valid program(/data). thus the birth of programming languages
06:17:09 <maerwald> tdammers: have you worked with ixset-typed?
06:17:18 <tdammers> maerwald: no, whence the question?
06:17:50 <maerwald> Trying to find a way to have unique keys
06:17:51 <bor0> zincy_, a little bit off-topic for Haskell but implementing a CHIP-8 interpreter really clicked for me: http://github.com/bor0/chip-8. maybe you can do that in Haskell as an exercise :)
06:18:00 <maerwald> http://hackage.haskell.org/package/ixset-typed-0.4.0.1/docs/Data-IxSet-Typed.html#v:getOne is scary and problematic
06:18:11 <maerwald> Cannot ensure data consistency properly
06:18:40 <zincy_> What is chip-8? A simple vm?
06:18:46 <bor0> pretty much
06:19:11 <zincy_> I guess it covers most of the main points of a register based architecture?
06:19:52 <bor0> it has a display memory, registers, stack, RAM, program counter, etc https://github.com/bor0/chip-8/blob/master/include/cpu.h#L23-L58
06:20:17 <zincy_> Awesome I will build one
06:20:32 <zincy_> Is there a guide for building one that leaves the implementation to the imagination?
06:21:11 <bor0> I built it in C based on a reference manual. for example, reference manual would say "if you encounter hex FExx, increase register N by xx"
06:21:31 <bor0> so you would just "translate" that into Haskell code
06:21:49 <zincy_> Does it have a concept of the heap?
06:21:55 <zincy_> Trying to learn about stack vs heap
06:22:06 <zincy_> Both areas of memory I guess
06:22:34 <bor0> IIRC it didn't have a way to do dynamic allocation. but once you get through the basics implementing additional features should be easier
06:23:08 <zincy_> Thanks
06:23:10 <bor0> there seems to be a Haskell implementation, too (by quick googling) https://github.com/soupi/chip-8
06:23:46 <bor0> luckily in Haskell you don't have to think too much about all of these things -- you only think about functions :)
06:24:00 <bor0> (and monads probably at some point)
06:24:12 <bor0> ((which are again, functions :D))
06:24:18 <zincy_> I am actually learning C
06:24:31 <zincy_> So I might use the haskell source as a guide to build in C
06:24:37 <zincy_> Now really off topic
06:28:07 <heebo> what are good streaming libraries to use with haskell, i want to read prices from multiple exchanges and process them
06:29:20 <heebo> im thinking about pipes but i dont know if its made to process data synchronously within memory bounds
06:29:55 <zincy_> conduit?
06:30:36 <__monty__> Popular ones seem to be conduit, pipes and machine(s?)
06:31:03 <heebo> will those handle concurrent producers ?
06:31:19 <__monty__> Haven't the foggiest.
06:31:36 <heebo> ok thanks, ill do some investigation
06:32:44 <dmwit> oo_miguel: I was indeed addressing exactly that concern.
06:33:36 <phadej> two concurrent producers (of `x` and `y`) ~ a single producer of `Either a b`
06:34:49 <phadej> but iirc all three libraries are "pull" processing, i.e. when you want a result you "pull for input"
06:35:10 <phadej> when the input is pushed at you, there might be problems
06:35:14 <dmwit> oo_miguel: "You *also* need at least a few primitives for matching individual tokens" was me trying to say that (but not clearly enough, I guess).
06:36:00 <heebo> thanks phadej i like the idea of pulling information, for me it will scale better
06:36:03 <oo_miguel> dmwit: I think I was confused (And still am) by the *also* ;)
06:36:15 <oo_miguel> why I not *just* need the primitves?
06:36:30 <dmwit> Err, well.
06:36:56 <oo_miguel> Just a bunch of primitives and the operations I get from the Applicative
06:36:57 <dmwit> If your primitives offer ways to build bigger parsers out of smaller ones, you are technically right that they wouldn't necessarily have to form an Applicative instance, say.
06:37:34 <dmwit> The "also" was "in addition to an Applicative and Alternative instance". Perhaps that's the bit that was unclear and therefore confusing.
06:38:07 <dmwit> "You need Applicative, Alternative, and also some primitives for parsing individual tokens."
06:38:09 <oo_miguel> dmwit: aah allright, makes perfect sense. thank you
06:38:37 <dmwit> (...or at least, that's the standard design these days.)
06:39:03 <oo_miguel> so Applicative + Alternatvie + "also" some primitve as "satisifies" would work for many many secearios right?
06:39:11 <dmwit> Yes indeed.
06:39:24 <oo_miguel> dmwit: thank you very much. I got it now. thanks for your patience ;)
06:39:31 <dmwit> For example, regex-applicative basically offers only those, and it turns out to be useful for me surprisingly often.
06:40:03 <oo_miguel> I would even assume this would be sufficient for context-free languages
06:40:35 <oo_miguel> which are more demanding than RE iirc.
06:41:33 <oo_miguel> dmwit: ah "regex-applicative" is a lirbary, ok. right.
06:42:18 <oo_miguel> thanks again
06:42:59 <dmwit> CFG needs satisfy, Applicative, Alternative, and recursion.
06:43:43 <dmwit> Which is such a latent part of Haskell programming that you forget to think about it as a feature even. =P
06:44:22 <c_wraith> Yes, too often.
06:44:37 <oo_miguel> dmwit: ah, exactly. such obvious I missed to IDENTIFY it as a feature. good you pointed this one out
06:46:32 <oo_miguel> In fact a very nice and straightforward recursive implemenation of word (matching a constant string literal), I cam acrosss today, made me rethink all this.
06:46:42 <oo_miguel> s/cam/came
06:47:15 <oo_miguel> it just uses satsify (char), applicative .... AND recursion obviously ;)
06:50:52 <oo_miguel> havning sorted this out, my next dream is to see working examples of how, allowing only this restricted realm I can "easier reason/proof" what my programm will do. Most articles/blogs I came across just state this as a fact. Any suggestions for further reading?
07:00:01 <oo_miguel> >  map (\x->(length x,head x)) . groupBy (==) $ "aabbcc"
07:00:02 <lambdabot>  [(2,'a'),(2,'b'),(2,'c')]
07:00:23 <c_wraith> oo_miguel: as a very simple example, compare map to foldr (restricted to lists)
07:00:52 <c_wraith> oo_miguel: map is much more restricted.  It's easy to see that it can do far fewer things.
07:00:57 <cchct> @djinn a -> a
07:00:57 <lambdabot> f a = a
07:01:04 <cchct> @djinn (a -> b) -> (b -> a)
07:01:05 <lambdabot> -- f cannot be realized.
07:01:33 <cchct> @djinn (a -> b) -> (b -> c) -> (a -> c)
07:01:33 <lambdabot> f a b c = b (a c)
07:01:45 <cchct> @djinn a -> b
07:01:45 <lambdabot> -- f cannot be realized.
07:01:52 <cchct> @djinn (a -> a) -> a
07:01:52 <lambdabot> -- f cannot be realized.
07:02:26 <cchct> @djinn (a -> b) -> (a -> c) -> (b -> c)
07:02:26 <lambdabot> -- f cannot be realized.
07:03:58 <cchct> > let {-- f cannot be realized.} in f 3
07:04:00 <lambdabot>  <hint>:1:5: error: unterminated `{-'
07:04:30 <cchct> @djinn (a -> b) -> (b -> c) -> (c -> a)
07:04:30 <lambdabot> -- f cannot be realized.
07:04:57 <cchct> @djinn Monad m => m (m a) -> m a
07:04:57 <lambdabot> -- f cannot be realized.
07:05:21 <cchct> @djinn (a -> b) -> (c -> b) -> Either a c -> b
07:05:21 <lambdabot> f a b c =
07:05:22 <lambdabot>     case c of
07:05:22 <lambdabot>     Left d -> a d
07:05:22 <lambdabot>     Right e -> b e
07:06:01 <cchct> @djinn (a -> b) -> a
07:06:01 <lambdabot> -- f cannot be realized.
07:06:10 <cchct> @djinn a
07:06:10 <lambdabot> -- f cannot be realized.
07:06:21 <cchct> @type let {x = x} in x
07:06:23 <lambdabot> t
07:06:44 <cchct> @type let {x = x} in x !! 2
07:06:45 <lambdabot> a
07:06:51 <cchct> > let {x = x} in x !! 2
07:06:53 <lambdabot>  *Exception: <<loop>>
07:07:53 <Solonarv> cchct: btw, you can play with lambdabot in /query too
07:08:08 <cchct> Solonarv: thanks
07:08:10 <oo_miguel> c_wraith: allright I see that... also I see that the restricted set of "functions" I ask about, can do fewer things than a monad (which in fact can do everything, right?)
07:08:26 <c_wraith> in computational terms, yeah
07:09:03 <cchct> why doesn't djinn infer type class functions?
07:09:13 <c_wraith> Well.  More specifically in terms of assembling "effects" in whatever way you want.
07:09:32 <c_wraith> just plain functions can do "anything" as far as computations that don't involve "effects"
07:09:46 <Cale> It can, if it knows about them and you don't need recursion, but it has a very small library.
07:12:01 <oo_miguel> c_wraith: I guess I have to read something about "proofs"  what a programs does, in general... Until now I was simply using the complete freedoms I have and did some unit testing.. never proved anything/reasoned about formally... 
07:16:47 <c_wraith> oo_miguel: I still almost never reason formally.  I rely on the same techniques, but I rarely put things down in terms of the formal systems.  This means I only use the simplest techniques, like parametricity, but that's enough to get a long way in Haskell
07:25:07 <oo_miguel> I understand what you mean. For me the sole fact of using Haskell (coming from classic imperative languages) reduces the probablity of encountering many classes of bugs and errors... I do not think I will ever reason formally about my programs in practice. But I am still curious and looking for working "toy" examples... 
07:31:18 <maerwald> I found this property holds rarely true if your system is sufficiently complex. There is only so much you can express in types and the more you express in types, the harder it actually becomes to reason about it. Paradox, isn't it.
07:31:52 <Cale> oo_miguel: Well, equational reasoning is useful even if you don't reason formally. Many of our expectations about how things work can be expressed in an equational way. For example, perhaps I want to know that if I encode something and then decode it again, I get Just whatever it was that I encoded initially.
07:32:01 <maerwald> It's more that maintainability in general becomes singificantly better, but in the end the main thing that matters is architecture, not programming language.
07:32:25 <tdammers> maerwald: though some programming languages are more suitable for certain architectural styles than others
07:32:31 <Cale> That property is useful even if you never actually use it to simplify your program by removing an encoding/decoding step.
07:33:15 <tdammers> anyway, my main strategy for scalable productivity is keeping my working memory footprint small, and haskell does a really good job at that for me
07:33:17 <maerwald> tdammers: yeah, and if you buy into tech, because the language makes it easier to express, then..
07:33:31 <maerwald> e.g. go people tend to use microservices, because there is ecosystem coverage for it and blog posts lol
07:33:37 <maerwald> but they still have no idea why they are doing it
07:33:41 <tdammers> yeah, I'm not really like that
07:33:58 <tdammers> "just dockerize it"
07:34:30 <Cale> I wrote a comment on reddit the other day which expresses what I think about microservices...
07:34:33 <Vulfe> why do I keep disconnecting ._____.
07:34:50 <Cale> https://www.reddit.com/r/programming/comments/b0p82d/give_me_back_my_monolith/eii1qqx/
07:37:38 <tdammers> microservices don't solve communication problems, if anything, they solve deployment problems
07:38:10 <Cale> I don't see how they do that either :)
07:38:19 <tdammers> if you use them to solve the problem that your team can't come up with a good scalable architecture, or with a nondisruptive way of agreeing on things to do and how to do them, then you're doing it horribly wrong
07:38:27 <tdammers> they solve *some* deployment problems
07:38:35 <tdammers> deployment problem, I might add, that you probably don't have
07:38:44 <Cale> Well, that's the only way I've ever actually seen them used in the wild: companies with *horrifying* politics
07:39:24 <tdammers> specifically, they solve the problem where you have to ship a continuous stream of updates to a large, complex system without any noticable downtime or performance impact
07:39:34 <tdammers> or rather, they are part of some solutions to that problem
07:39:34 <e> to some extent they insulate failures from each other
07:39:53 <Cale> Like, "we can't even agree on what programming language this will be written in, and nobody has the authority to demand we all work in the same language"
07:40:39 <tdammers> microservices are just one of those "fuck it all, we're just gonna ____" knee-jerk reactions
07:40:54 <tdammers> in this case, "architecture is hard, let's just not do it"
07:41:25 <tdammers> a bit like using a dynamically-typed programming language because when you try to reason about the constraints and properties of your APIs, your brain hurts too much
07:41:42 <tdammers> so you just don't reason about them at all, let the world burn and put out fires as they aris
07:42:20 <Cale> Rather than deploying multiple copies of the same program which does everything, we'll deploy many tiny programs which don't do everything, and hopefully none of them end up being too important somehow.
07:43:18 <tdammers> I'm not at all opposed to splitting things up into separate processes and binaries
07:43:25 <tdammers> WHERE AND WHEN THAT MAKES SENSE
07:43:37 <tdammers> e.g., the classic three-tier setup
07:43:38 <e> well, suppose one of them is too important. it's still more protected should one of the unimportant things randomly break
07:44:06 <tdammers> or even just a "domain service" that handles all the domain logic and persistence and all that, and a bunch of frontends connecting to it
07:46:04 <Cale> e: sort of, except that there are still probably lots of dependencies. It's rare for these systems to actually end up designed in a way that their parts are truly independent of one another, and even if that's the case, it doesn't make much difference whether those were separate processes or separate threads.
07:46:41 <e> sure it does. processes have separate limits for a bunch of stuff
07:46:43 <Cale> It introduces a lot of opportunities for programmers not to fully understand what's going on
07:47:21 <tdammers> I'm more concerned about people underestimating the overhead
07:47:22 <Cale> because you have an abstraction barrier between the code you're working on and a lot of code whose behaviour you constantly rely on
07:47:48 <Cale> That's always true, when it comes to stuff like the OS
07:48:02 <Cale> But it doesn't have to be true for the other parts of a single application backend
07:48:48 <c_wraith> also, it's usually not a real abstraction.  You usually need to know what it's doing, so it's just a "see other process" instead of a black box.
07:48:58 <Cale> yeah
07:49:00 <tdammers> that abstraction barrier can be helpful though. it's called "encapsulation", and it allows you to reason about code you depend on in terms of its external API and its promises, which, in a good design, is much smaller than the implementation
07:49:41 <tdammers> then again, you can have such abstractions without physically implementing them as network or process boundaries
07:49:49 <Cale> Encapsulation isn't always good -- sometimes it is good, when there is a simpler mental model for what's being encapsulated than its implementation.
07:50:35 <tdammers> yes, that was kind of implied - if the API isn't significantly smaller (or simpler, same thing really) than the implementation, then the abstraction is worthless
07:51:47 <maerwald> tdammers: sounds like a C API xD
07:52:03 <tdammers> mwahaha
07:52:32 <tdammers> there's also this common pattern where the API is smaller and simpler than the implementation, but also somehow crippled
07:52:40 <Cale> At least for us, working in Haskell, it seems to work out so much more smoothly when we have engineers who build features end-to-end, work on every part of the code, and nobody "owns" anything.
07:52:56 <tdammers> I totally believe you
07:53:07 <tdammers> ("nobody owns anything" is good btw)
07:53:22 <tdammers> programmers have this unhealthy tendency to identify with their code
07:53:34 <maerwald> Cale: if you have engineers who build features end-to-end and nobody owns anything, then the language is irrelevant :)
07:53:38 <maerwald> You can do anything in any tech
07:53:52 <tdammers> but facing the demon, going naked in front of the team, and watching your teammates butcher your code can be cathartic
07:54:04 <Cale> maerwald: We probably wouldn't be able to do it in another language. At the very least, I wouldn't be able to put up with that.
07:54:07 <maerwald> Finding programmers is easy, finding engineers is not
07:54:14 <tdammers> maerwald: in theory, yes, but actual human engineers have to first learn the language in question
07:54:37 <Cale> GHC telling me everything that's got to change in code that I didn't write is a huge part of it.
07:54:42 <maerwald> I want to work with people who have the mindset of engineers, I don't care about language wizards!
07:54:57 <bor0> tdammers, what does it mean to "watch your teammates butcher your code"?
07:55:05 <Cale> I'd never be able to get anything done if it weren't for good type errors.
07:55:21 <maerwald> Cale: do you program C and would you consider yourself a good C programmer?
07:55:23 <bor0> tdammers, maybe if someone is watching someone else doing that, they're in the wrong team?
07:55:27 <tdammers> bor0: you wrote something, someone else on the team changes it in a way that makes you go "wait! no! that's not what I meant!"
07:55:47 <Cale> maerwald: I used to, back around 2000-ish
07:55:55 <maerwald> Interesting
07:56:02 <Cale> It's been a long time
07:56:23 <bor0> tdammers, they should've at least put me as a reviewer :) we use GitHub and it's really helpful that the last commiter shows as a reviewer
07:56:38 <cr3> tdammers: any advice on coping and eventually accepting people butchering your code? I might have a problem :)
07:57:06 <bor0> cr3, I noticed for myself I'm tolerant to a certain degree, but if something really sucks I'd put it in nice words
07:57:06 <Cale> cr3: Use types to set them up for success
07:57:23 <MarcelineVQ> get payed each time it happens
07:57:25 <Cale> and review each other's code
07:57:40 <Cale> and/or pair program a lot
07:59:10 <Cale> Pairing is weirdly effective a lot of the time -- you can create motivation and focus where otherwise it would be easy to get distracted, and you learn a lot from each other about various parts of the code. You spend less time looking things up and trying to understand unfamiliar things.
07:59:17 <maerwald> Cale: don't you sometimes miss the roughness of C?
07:59:43 <Cale> maerwald: Can't say that I do. I've only grown more intolerant of that roughness.
07:59:57 <Cale> There are fewer and fewer excuses for allowing it.
08:00:38 <Cale> (and even the things which demand it often would prefer something yet lower level than C)
08:00:46 <Cale> Like LLVM exists now.
08:01:49 <tabaqui> do you know something like psutil in Python?
08:02:23 <tabaqui> I need a tool to collect cpustat from different subprocesses
08:03:57 * shapr hops randomly
08:04:58 <shapr> noobie question: when I added -fllvm to my ghc-options, cabal told me to install llvm6 I think. Does ghc need changes to support specific versions? Does LLVM need changes to support GHC?
08:05:12 <shapr> I guess I could read the ghc manual, perhaps there's something in there.
08:05:29 <Cale> shapr: I think there are version restrictions, yeah
08:05:31 <cocreature> shapr: a bit of both
08:06:24 <cocreature> LLVM has special support for GHC (mostly a custom calling convention). GHC uses LLVM so if LLVM breaks their “API” (mostly the CLI interface and the textual IR format), GHC needs changing
08:06:35 <Cale> The user's guide says "Note that this GHC release expects an LLVM version in the 6.0 release series."
08:06:49 <shapr> ah, so later versions might use llvm7 instead?
08:06:54 <shapr> good to know
08:08:46 <stepcut> Anyone got a link to a tutorial on why `MonadError` was not included in `transformers` and what to do instead? 
08:10:27 <tabaqui> it is deprecated in favor of MonadExcept
08:11:25 <tabaqui> stepcut ↑
08:13:04 <RedNifre> Idris: yay or nay?
08:13:13 <bor0> RedNifre, yay
08:13:22 <Entilo> Hi. I need to make a function which will take in a string such as "aabbcc" and output it in the format [('a',2),('b',2),('c',2)] using a function I made previously. I've got that function made previously along with some examples in a pastebin here: https://pastebin.com/RfENLCJC 
08:13:27 <Entilo> The function that I need to use takes in a string such as "aaabbbccc" and returns ["aaa","bbb","ccc], so I was thinking of running this, and then having the format [(a,b)], where a would be the head of the particular chunk, such as "aaa" , and b would be the length of this chunk. This would then be repeated.  I was in here earlier and someone told me that I have the right idea, but I should use map instead, however, I am kind of confu
08:13:30 <bor0> or well, not Idris specifically but dependent types :)
08:13:47 <RedNifre> hm
08:14:15 <RedNifre> Is there any statically typed language that can do zipWithN ?
08:14:18 <tabaqui> Entilo: fmap length . Data.List.group
08:14:46 <tabaqui> oh, not really, but check out group function
08:15:01 <stepcut> tabaqui: transformers provides Control.Monad.Trans.Except -- but that seems to lack a `MonadExcept` class. Supposedly because it obsoletes the need for a `MonadError`-like class. But I am not quite sure how that works...
08:15:07 * hackage too-many-cells 0.1.4.0 - Cluster single cells and analyze cell clade relationships.  https://hackage.haskell.org/package/too-many-cells-0.1.4.0 (GregorySchwartz)
08:15:29 <kuribas> RedNifre: haskell
08:15:30 <tabaqui> transformers has no monadic classes, you have to look for them in "mtl" library
08:15:33 <tabaqui> stepcut:
08:15:47 <bor0> > map (\x -> (x, length x)) $ Data.List.group "aaabbb"
08:15:48 <RedNifre> kuribas how do you do a zipWith on arbitrary numbers of input lists?
08:15:49 <lambdabot>  [("aaa",3),("bbb",3)]
08:16:09 <RedNifre> > show (undefined :: Void)
08:16:11 <lambdabot>  "*Exception: Prelude.undefined
08:16:15 <tabaqui> > map (head *** length) $ Data.List.group "aabb"
08:16:17 <lambdabot>  error:
08:16:17 <lambdabot>      • Couldn't match type ‘([c], [a0])’ with ‘[Char]’
08:16:17 <lambdabot>        Expected type: [Char] -> (c, Int)
08:16:22 <kuribas> RedNifre: you could abuse typeclasses
08:16:25 <tabaqui> > map (head &&& length) $ Data.List.group "aabb"
08:16:27 <lambdabot>  [('a',2),('b',2)]
08:16:53 <Entilo> wait seriously lmao 
08:17:07 * hackage stratosphere 0.35.0 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.35.0 (jdreaver)
08:17:59 <Entilo> tabaqui: what is the ` $ Data.List.group "aabb" ` part for? or is that just importing a library and giving an input?
08:18:07 <monochrom> MonadError is in mtl's Control.Monad.Error.Class.  Note: This is not obsoleted.  Only Control.Monad.Error is.
08:18:16 <Cale> > group "aabb"
08:18:19 <lambdabot>  ["aa","bb"]
08:18:26 <monochrom> Or rather s/obsoleted/deprecated/
08:18:30 <Cale> > group "mississippi"
08:18:32 <lambdabot>  ["m","i","ss","i","ss","i","pp","i"]
08:18:43 <tabaqui> Entilo: if you use qualified imports then you cannot call a function by its name
08:18:51 <tabaqui> import Data.List -> group
08:18:52 <Cale> > group . sort $ "mississippi"
08:18:54 <lambdabot>  ["iiii","m","pp","ssss"]
08:18:57 <tabaqui> import qualified Data.List -> Data.List.group
08:19:04 <tabaqui> import qualified Data.List as D -> D.group
08:19:13 <stepcut> tabaqui: ah. I have vague memories. transformers was created because mtl uses fundeps and people wanted to experiment with TFs instead ? But mtl is not 'deprecated'?
08:19:28 <monochrom> mtl is not deprecated.
08:19:49 <tabaqui> It is widely used, I think it will never be deprecated
08:19:58 <Solonarv> stepcut: no, the "experiment with TFs instead" library is mtl-tf
08:20:19 <Solonarv> (and it's deprecated)
08:21:05 <Solonarv> 'transformers' provides the concrete monad transformers (ReaderT, StateT, ...) as well as the MonadTrans class
08:21:09 <stepcut> Solonarv: but doesn't http://hackage.haskell.org/package/monads-tf provide mtl-like classes using TFs, but uses tranformers underneath so the types are compatible with mtl?
08:21:59 <monochrom> Also transformers was created not to free up for experimenting with TF.  transformers and mtl were duplication of effort at the beginning.  Then one day they sat down and agreed on a division of labour.
08:22:03 <Solonarv> 'mtl' provides classes (MonadReader, MonadState, ...) and instances corresponding to the transformers in transformers
08:22:18 <Solonarv> oh, I didn't know about monads-tf
08:24:26 <Cale> It's mildly upsetting that none of the approaches to constructing monads piecemeal actually seem to have the asymptotics you'd want. Someday we'll have to do a good monad library, and while we're at it, get things like the pair order, and the order of arguments to the run functions right
08:25:03 <monochrom> Namely, the peace treaty stated that mtl would change "newtype State s a = ..." to "type State s = StateT s Identity" (because transformers preferred that), and transformers would cede the classes to mtl.
08:26:11 <dminuoso> stepcut: mtl and transformers are orthogonal packages.
08:26:24 <Solonarv> Cale: well, one of the libraries in the freer zoo is actually reasonably fast
08:26:48 <Solonarv> but IIRC they all have trouble with some types of effects (most notoriously 'bracket' and its ilk)
08:27:11 <dminuoso> stepcut: MonadState is as much about transformers as Monoid is about numbers.
08:27:40 <Cale> okmij.org/ftp/Haskell/extensible/more.pdf -- many of them are better than MTL, but still become linear in the number of transformers depending on how you order in which you apply them.
08:28:14 <tabaqui> oh, yeah, extensions look very promising
08:28:45 <Cale> I mean, so long as I'm not incurring non-uniform memory access, adding any number of layers of Reader and State shouldn't affect the performance of any one layer.
08:28:54 <tabaqui> I dunno, they are something similar with Free, right?
08:30:07 <Cale> (there are nice graphs in that paper)
08:31:37 * hackage brick 0.47 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.47 (JonathanDaugherty)
08:31:42 <Cale> also, lol, the next page where MTL is winning again for the Pythagorean triples benchmark
08:32:16 <Cale> We're just lucky that most of the time, these costs are irrelevant
08:35:50 <stepcut> I guess the answer is 'its complicated'. At one point in time there were many competing monad libraries, and at some point someone split an H98 compatible transformers package out of mtl. That allowed mtl-tf and mtl-fd to coexist and mtl-fd because mtl-2. But it is not clear that transformers was created for that purpose -- maybe it was created because JHC could only compiled H98 code? So -- what happened in the end doe
08:35:50 <stepcut> s not necessarily reflect the original motivations?
08:36:43 <Cale> stepcut: I seem to remember that experimentation with mtl-tf and mtl-fd being the original motivation
08:37:12 <Cale> Now I guess the motivation for keeping them split is just that different people work on them...
08:39:03 <Cale> As much as I don't like seeing the mtl classes showing up directly outside of the implementation of other monad transformers, they're still always quite useful for that purpose, so I'm not sure it entirely makes sense to put them in a different package.
08:39:37 <vaibhavsagar> so why does mtl depend on transformers?
08:40:03 <vaibhavsagar> (based on the history you just recounted)
08:40:13 <Cale> instances?
08:40:40 <vaibhavsagar> maybe I missed this part, but did transformers come first?
08:40:48 <Cale> mtl came first
08:40:49 <vaibhavsagar> I assumed it must have
08:40:55 <Cale> transformers was split out of it
08:41:06 <vaibhavsagar> oh, hmm
08:41:29 <vaibhavsagar> and then mtl was rebased on top of this new transformers library?
08:42:12 <Cale> Well, it provided instances of its MonadFoo classes for the new transformers library's monad transformers.
08:42:23 <Cale> well, both mtl-fd and mtl-tf did
08:42:37 <stepcut> vaibhavsagar: mtl-1 came first, then transformers was created and mtl-2 was built on top of transformers
08:42:41 <stepcut> found the origin thread, https://mail.haskell.org/pipermail/libraries/2009-January/011062.html
08:42:49 <vaibhavsagar> okay, I think I understand
08:43:43 <vaibhavsagar> so transformers is `mtl-data`?
08:43:46 <Cale> yes
08:44:58 <vaibhavsagar> cool
08:45:05 <stepcut> yeah
08:45:08 <vaibhavsagar> I'm glad they made that decision 20 years ago
08:45:15 <Cale> It also appears that mtl-tf predates the split, but the earlier versions of it would have defined their own data types.
08:45:45 <vaibhavsagar> the other day I found out that GHC 6.12 is newer than Python 3.0 (and also Python 3.1)
08:45:57 <Cale> That sounds right
08:45:59 <vaibhavsagar> we've come such a long way
08:46:30 <vaibhavsagar> my introductory computing course probably used 6.12, because it was in early 2010
08:46:54 <vaibhavsagar> I was super angry that nobody told me about typed holes
08:47:04 <vaibhavsagar> but then I realised they hadn't been implemented in GHC yet
08:47:16 <Cale> haha
08:47:35 <stepcut> I think what happened is mtl-1 existed. Then type functions came along and someone said 'cool' and forked mtl-1 to make mtl-tf. But then you had the unfortunate situation where mtl-1 and mtl-tf both defined types like `StateT` that were defined the same, but were considered to be different since they were defined in different packages. So people did the sensible thing and split out transformers. 
08:47:46 <Cale> I think my first GHC version was 5.02 -- I started learning Haskell before it came out, but I'd only used hugs up to that point.
08:48:08 <CelestialLake> GHC develops at some insane pace.
08:48:20 <Solonarv> indeed, it's quite stunning
08:48:27 <vaibhavsagar> I've been thinking about what we could do to make GHC bootstrappable, which is how this came up
08:48:32 <Cale> https://downloads.haskell.org/~ghc/5.02.3/docs/set/book-hslibs.html -- here's the library documentation from that time
08:48:36 <stepcut> I think I started with GHC 5.04 -- I think we did not even high hierarchical module names at that point?
08:48:43 <Cale> like... practically all the libraries which existed
08:48:46 <Cale> yeah, we didn't
08:48:53 <CelestialLake> Majority of languages can't release the new major while GHC basically does it every couple of years or so lately.
08:49:20 <Cale> The hierarchical modules addendum was so ridiculous
08:49:37 <stepcut> By the time I finally get everything built with the latest GHC they've already released a new version. I never have time to develop new code :)
08:49:56 <Cale> Like, "let's allow dots in module names" -> wake up next morning -> everything is under Control.* and Data.* at random
08:50:06 <vaibhavsagar> hahaha
08:50:10 <vaibhavsagar> I think that was a mistake
08:50:24 <vaibhavsagar> not the dots, but the introduction of the Control and Data namespaces
08:50:37 <vaibhavsagar> very annoying to use
08:50:50 <Cale> https://downloads.haskell.org/~ghc/5.02.3/docs/set/set.html -- this is what turned into Data.Set
08:50:56 <Cale> how do you like our documentation?
08:51:03 <Cale> pretty good, eh?
08:51:03 <Solonarv> yeah, the Control/Data namespaces are weird
08:51:18 <Cale> https://downloads.haskell.org/~ghc/5.02.3/docs/set/finitemap.html
08:51:19 <Solonarv> "documentation"
08:51:23 <Cale> there's Data.Map
08:51:28 <Solonarv> I assume this predates haddock?
08:51:32 <Cale> yes
08:51:41 <vaibhavsagar> I see where the `types as documentation` meme came from
08:51:56 <Cale> That's literally all the documentation people would bother to write :D
08:52:41 <Cale> "Guess what? The implementation uses balanced trees."
08:54:17 <Cale> https://downloads.haskell.org/~ghc/5.02.3/docs/set/sec-concurrency-abstractions.html
08:54:24 <Cale> "A Channel is an unbounded channel"
08:54:37 <Cale> and then the type isn't even called Channel
08:54:37 <Cale> lol
08:55:39 <Cale> A channel variable (CVar) is a one-element channel, as described in the paper: (no reference to paper, just some relevant types)
08:55:43 <CelestialLake> vaibhavsagar: That's a good meme but in majority of cases you can just avoid bothering yourself with the docs for your functions. If they do a single thing and don't go for IO *, type annotation + short comment explaining the name is enough.
08:55:53 <Cale> I guess it's assumed you knew which paper was being referred to?
08:56:59 <Cale> tbh, I didn't really get into the concurrency side of things that early though
08:57:42 <stepcut> mistakes were made...
08:57:49 <CelestialLake> Cale: -threaded
08:59:02 <Cale> I don't think -threaded existed back then
09:00:24 <Cale> https://downloads.haskell.org/~ghc/5.02.3/docs/set/flag-reference.html -- doesn't look like it
09:03:14 <CelestialLake> Sure it may have not. Though it exists now and everything is more convenient than ever, so we (in majority of cases) may not bother implementing concurrency manually.
09:03:38 <CelestialLake> Well, we still may want to fork IO
09:03:52 <CelestialLake> Sometimes.
09:04:01 <Cale> Yeah, I've just been looking at old documentation from when I started programming in Haskell
09:05:49 <slack1256> What year was ghc 5.02?
09:07:09 <CelestialLake> 2002 by the looks of it
09:07:25 <Cale> yep
09:07:29 <maerwald> it probably had less bugs
09:07:55 <slack1256> and less users
09:08:01 <Cale> I started learning Haskell in 2001, but just using the Hugs interpreter.
09:08:07 <maerwald> so more bugs = more users
09:08:11 <CelestialLake> And manual concurrency
09:08:30 <CelestialLake> maerwald: It's the other way around
09:09:01 <CelestialLake> and probably with implication instead of equality
09:09:41 * CelestialLake Hugs Cale 
09:10:44 <Taneb> ...GHC 5.02 is almost as old now as I was when I started learning Haskell
09:11:23 <shreyasminocha> GHC 5.02 is almost as old as i am (and as old as i was when i started learning haskell)
09:11:44 <arturas> ? ? ? ^
09:11:44 <Taneb> shreyasminocha: following in my footsteps ;)
09:12:09 <Taneb> shreyasminocha: how are you finding it?
09:12:27 <shreyasminocha> very different and also fun
09:14:02 <Taneb> :D that's how I got hooked
09:14:30 <shreyasminocha> it's almost like re-learning programming
09:16:24 <ski> Cale : "get things like [..] the order of arguments to the run functions right" -- hm, what did you have in mind ?
09:18:57 * ski is also missing `evalCont :: Cont o o -> o' and `evalContT :: Monad m => ContT o m o -> m o' from `Control.Monad.Cont'
09:20:07 * hackage shake-cabal 0.2.1.1 - Shake library for use with cabal  https://hackage.haskell.org/package/shake-cabal-0.2.1.1 (vmchale)
09:20:16 <Peppep> So how old is 5.0.2? haskell.org and HaskellWiki don't include releases before 6.10.1
09:21:03 <merijn> OLD :p
09:21:25 <ski> <slack1256> What year was ghc 5.02?  <CelestialLake> 2002 by the looks of it
09:25:05 <Peppep> Just found it: https://mail.haskell.org/pipermail/glasgow-haskell-users/2001-September/002309.html
09:25:11 <Peppep> Sep 21 2001
09:29:15 <Peppep> I tried finding the ghc version which is as old as me. It does not exist. :sadface:
09:30:19 <merijn> Peppep: There's other Haskell implementations which are older :p
09:32:41 <Cale> ski: It always seems that it would be more convenient if runWhatever took its action argument last. You're usually composing a chain of these in order to run a monad built of a bunch of composed transformers
09:33:10 <Cale> ski: At least I end up flipping them essentially 100% of the time
09:34:13 <ski> hm, i suppose so
09:34:17 <Cale> runStateT :: s -> StateT s a -> (s,a)  would be much more convenient, even if it obscures the isomorphism between StateT s a and s -> (s,a) a bit
09:34:19 <ski> i tend to use sections
09:34:47 <Cale> Perhaps what we have now should be unStateT :)
09:35:02 <Peppep> merijn: Apparently I'm more a Tcl guy
09:35:02 <vaibhavsagar> CelestialLake: the 'types as documentation' advice breaks down in the presence of invariants
09:35:09 <vaibhavsagar> e.g. `fromList` vs. `fromListAsc`
09:35:27 <kuribas> isn't (s -> (s, a)) a reader monad?
09:35:42 <Cale> no, reader is e -> a
09:35:46 <tdammers> state
09:36:00 <kuribas> s can be e, and a (a, a)
09:36:00 <tdammers> s -> (s, a) -- can return a modified s
09:36:01 <Peppep> merijn: Hmm. No, I prefer being A+. ;) https://en.wikipedia.org/wiki/A%2B_(programming_language)
09:36:10 <Cale> oh, I'm writing T, and not writing m :)
09:36:28 <Cale> runStateT :: s -> StateT s m a -> m (s,a)
09:36:44 <vaibhavsagar> I thought it was `a -> (s, a)`?
09:36:47 <Cale> (StateT s m a) ~= (s -> m (s,a))
09:36:55 <ski> @hoogle parse
09:36:56 <lambdabot> Data.Aeson.Types parse :: (a -> Parser b) -> a -> Result b
09:36:56 <lambdabot> Text.Parsec parse :: (Stream s Identity t) => Parsec s () a -> SourceName -> s -> Either ParseError a
09:36:56 <lambdabot> Text.Parsec.Prim parse :: (Stream s Identity t) => Parsec s () a -> SourceName -> s -> Either ParseError a
09:37:04 <Cale> vaibhavsagar: right, I'm just explaining what I'd like it to be
09:37:15 <ski> that doesn't seem to take the parser last, for some reason
09:37:26 <Cale> (s,a) makes more sense, because of the Functor instance
09:37:48 <delYsid> Woha, Barbarossa built with lts-3.5 is then times faster compared to a lts-13.13 build.  What could that be?
09:38:19 <kuribas> Cale: (s -> (s, a)) would be the reader monad with reader s, and returning a value (s, a)
09:38:32 <kuribas> :i (->)
09:38:43 <delYsid> I am guessing the code is pretty optimized, but a drop of factor ten for upgrading the compiler seems pretty sharp.
09:38:54 <kuribas> instance Monad ((->) r) -- Defined in ‘GHC.Base’
09:38:58 <Cale> kuribas: Uhh, that wouldn't be a monad if you don't do something with the resulting s
09:39:19 <ryouba> hi
09:39:20 <Cale> kuribas: and if your answer is "plug that s in to the next computation", then that's exactly the State monad
09:39:40 <kuribas> Cale: I mean, it could be a monad, but isn't in haskell ?
09:39:42 <ryouba> i'm trying to use "cabal" (cabal install pandoc) but it errors out on the first dependency with "<command line>: cannot satisfy -package-id text-1.2.3.0" ... what does that mean?
09:40:22 <vaibhavsagar> hi!
09:40:41 <Cale> kuribas: You'
09:40:55 <Cale> You'll want to have return v >>= f = f v
09:41:01 <Cale> and I'm not sure that will be satisfied
09:41:12 <ryouba> sorry, hi! :-P
09:41:20 <[exa]> ryouba: probably it can't find/install a dependency?
09:41:22 * ski isn't sure what kuribas is suggesting
09:41:27 <Cale> Either that unit law, or the other one: x >>= return = x
09:41:38 <Cale> Depending on what your >>= is doing
09:41:58 <kuribas> ski: I am suggesting it's only a monad when you wrap state
09:42:01 <kuribas> :t state
09:42:02 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
09:42:08 <ryouba> [exa]: when i say "cabal install text" it does install it, but 1.2.3.1 ...
09:42:08 <ski> "it" being ?
09:42:09 <vaibhavsagar> ryouba: have you run `cabal update`?
09:42:12 <ryouba> vaibhavsagar: yes!
09:42:59 <vaibhavsagar> ryouba: can you paste the full error log into a gist?
09:43:04 <ryouba> vaibhavsagar: yes, second
09:43:15 <[exa]> ryouba: what's your cabal/ghc version? (yeah full error helps)
09:43:18 <ryouba> (still building "text" now ... i'm only one a Core 2 Duo)
09:43:42 <Cale> kuribas: I thought you were suggesting that (s -> (s,a)) was reader, which doesn't seem right.
09:44:00 <ryouba> [exa]: cabal-install 2.0.0.1, cabal library 2.0.1.0, ghc 8.2.2
09:44:08 <Cale> There's no way to interpret that as some sort of ReaderT over something, unless s happens to be a monoid
09:44:24 <ryouba> wow, ghc is *very* CPU hungry on the poor X200
09:44:26 <Cale> in which case it might be ReaderT s (Writer s a)
09:44:30 <Cale> ooops
09:44:33 <Cale> in which case it might be ReaderT s (Writer s) a
09:45:38 <Cale> but yeah, (,) s / Writer s is only a monad if s is a monoid.
09:45:41 <ryouba> vaibhavsagar: [exa]: https://gist.github.com/sixtyfive/78a5c047160771520d943e87c20f386d
09:46:40 <Cale> and so if your plan is to quietly discard some of the results of type s or something, that's only a semigroup and not a monoid operation, so you don't quite satisfy the monad laws -- one of the unit laws will fail
09:47:03 <ski> a monad is a type function, together with some operations satisfying some laws. it's not clear to me what the suggested type function would be wrt `s -> (s,a)', thinking of it as an environment monad, in some fashion
09:47:34 <[exa]> ryouba: if you try installing text-1.2.3.0 by hand, what does it say?
09:48:01 <ryouba> [exa]: "All the requested packages are already installed:"
09:48:12 <ryouba> (and then text-1.2.3.0)
09:48:36 <ryouba> i'm confused by that "BcISmLFYuX48LxJqafTQTN" thing
09:48:49 <[exa]> probably a temporary directory or something
09:48:55 <ski> sure, you can think of that as `Reader s (s,a)', the type of `Reader s'-actions, computing results that are pairs of an `s' with an `a' .. but then the instance of `MonadReader s' for that monad has nothing to do with the `s' in `(s,a)'
09:49:19 <[exa]> ryouba: added to prevent name collisions
09:49:23 <ryouba> hmm
09:49:47 <[exa]> can you try `ghc-pkg list` ?
09:50:25 <ryouba> [exa]: https://gist.github.com/sixtyfive/3d843b9d4dfa4a4f06c25daac4299664
09:50:42 <vaibhavsagar> ryouba: can you try with GHC 8.4?
09:51:07 <ryouba> vaibhavsagar: not offered by my distro, i'll try to build from source
09:51:33 <[exa]> ryouba: what distro do you have?
09:51:39 <ryouba> [exa]: Solus
09:51:54 <ryouba> oh!
09:51:55 <ryouba> wait!
09:52:10 <ryouba> ghc-pkg recache helped and now i was able to cabal install HsYAML!
09:52:25 <[exa]> oh nice
09:52:58 <ryouba> let's see about pandoc
09:53:44 <Solonarv> clearly 's -> _' is the reader/environment monad; and just as clearly you're free to instantiate _ to whatever type you want, including one involving s
09:54:54 <Solonarv> ryouba: btw, I'd recommend using ghcup instead of your distro packages for installing ghc/cabal
09:55:06 <Solonarv> as you've seen the distro packages tend to lag behind a bit
09:56:01 <koz_> I would second this recommendation - I've started doing it a few months back and have not looked back ever.
09:56:09 <koz_> cabal new-install is pretty darned good like that.
09:56:19 <koz_> (well, and cabal new-build)
09:57:01 <isovector1> is there any way to use a type family to distinguish an unconstrained type variable? eg the difference between `read` and `read @Int`?
09:57:43 <isovector1> specifically i'm trying to give good custom type errors if a variable is ambiguous vs if it is actually the wrong type
09:58:20 <koz_> \query isovector1 Hi! I was just wondering if your book got any updates from its initial release? I sent a bunch of corrections to you a while ago, you responded, but I've not been notified that there's a new version out.
09:58:23 <koz_> Argh.
09:58:26 <koz_> Slashes.
09:58:46 <isovector1> koz_ the pdf? when did you get a copy?
09:59:01 <isovector1> (ps thanks for the support!)
09:59:12 <Solonarv> for good errors, you can use a 'instance TypeError ( error message here ) => SomeClass Wrong where...'
09:59:46 <Solonarv> or perhaps 'instance {-# overlappable #-} TypeError (error message here) => SomeClass a'
09:59:50 <isovector1> Solonarv: sure, but can i differentiate between wrong types and ambiguous types?
10:00:02 <Solonarv> I can't think of a way
10:00:19 <Solonarv> perhaps you can do something hacky with stuck type families
10:00:48 <isovector1> that's the exact question i'm trying to ask :)
10:01:20 <koz_> Solonarv: What are stuck type families?
10:01:25 <Solonarv> type familly ErrWhenStuck err (a :: k) :: k where
10:01:25 <Solonarv>   ErrWhenStuck err Int = Int -- can be whatever, doesn't need to be Int
10:01:25 <Solonarv>   ErrWhenStuck err a = a
10:01:26 <isovector1> i want to distinguish between `SomeFamily Int` and `SomeFamily a0`
10:01:40 <Solonarv> koz_: a type family is "stuck" when there isn't enough information to reduce it
10:01:58 <isovector1> except where `Int` is any type variable that is unified to something other than itself
10:02:36 <Solonarv> I think it'll take some playing around that I'm too lazy to do right now
10:02:48 <Solonarv> there's a tangentially relvant blog post, let me see if I can find it
10:02:55 <isovector1> i read csongor's post 
10:03:00 <isovector1> on detecting stuck type families
10:03:24 <Solonarv> ah yeah, that's the one I was thinking of
10:03:50 <isovector1> yeah
10:04:10 <isovector1> i'm working on an mtl-esque thing, but without the fundeps
10:04:17 <isovector1> so you can have multiple `MonadState`s in a stack
10:04:36 <isovector1> trying to give an error for "you used `get` ambiguously" vs "you used `get` for a type you don't have a constraint for"
10:05:08 <Solonarv> I see
10:05:09 <Solonarv> hmm
10:05:13 <geekosaur> I think this is not really possible using only a type family. it'd require an inequality witness. compile time stuff liek type families can only handle the case where it can be proven that two type variables always are the same.
10:05:18 * ski . o O ( `StateT s (StateT s m) a' )
10:05:56 <geekosaur> so now you need something like an H(N)Eq class, and its dictionary is the witness
10:06:15 <isovector1> is there such a thing as HNEq? 
10:06:16 <vaibhavsagar> ski: stop making sense :)
10:06:32 <isovector1> i guess i could cheat with a `eqT` that is `Nothing`
10:06:59 <ryouba> Solonarv: thank you for the suggestion. I didn't know about it so far. Functional programming is too different for me from the procedural/object-oriented style that I'm used to. I hadn't even known Pandoc was Haskell-based until I needed a newer version yesterday...
10:07:13 <isovector1> i'd ALSO be happy going through my list of constraints, seeing if any partially unify, and then give different errors in the two cases
10:07:13 <koz_> geekosaur: What's the 'H' and 'N' in 'HNEq' stand for?
10:07:37 <geekosaur> isovector1, not in a standard lib that I know of, but variants of this kind of question come up often enough and it's often created on the fly in irc and/or email
10:07:50 <geekosaur> koz_, "heterogeneous"
10:07:51 <Solonarv> H = Heterogenous (might not be needed here), N = Not
10:07:54 <geekosaur> see HList
10:07:57 <koz_> Ah.
10:08:00 <geekosaur> which uses a variant of this
10:08:22 <isovector1> alternatively is it possible to get my hands on all of the given constraints in context?
10:08:23 <geekosaur> looking at hw HList works might give you some idea of what you can do here and how
10:08:26 <geekosaur> and what uou can't
10:09:26 <ski> vaibhavsagar : well, imho, you'd really want to refer to the transformer( occurance)s by identifier -- or at least, i'd like to experiment with such an approach
10:09:59 <isovector1> i could do this with a typechecker plugin....
10:10:21 <koz_> isovector1: From the sound of it, you might just have to.
10:10:40 <isovector1> if i have a tc plugin i can just unify them myself if it's ambiguous
10:10:46 <geekosaur> and yeh, the "H" isn't doing anything here, but this derives originally from HList so the naming convention was kinda set by this
10:10:47 <isovector1> COME WHAT MAY
10:11:11 <isovector1> okay that sounds like a yak shave for another day
10:11:42 <koz_> All yaks must be shaved.
10:56:07 * hackage hmatrix-banded 0.0.0.3 - HMatrix interface to LAPACK functions for banded matrices  https://hackage.haskell.org/package/hmatrix-banded-0.0.0.3 (HenningThielemann)
11:33:06 * cocreature looks at the package that was just uploaded. Ah a typeclass called C. I know who wrote that package :)
11:46:39 <koz_> Why does this person use this convention?
11:46:42 <koz_> It seems subpar.
11:47:29 <ski> @quote modules.M
11:47:29 <lambdabot> shachaf says: Henning should call all his modules M
11:48:34 <ski> i think in the ML world, it's relatively common to name the "main" type exported from a module `t'
11:48:53 <koz_> Isn't that horribly confusing?
11:50:36 <Cale> koz_: It's terrible in Haskell. It's less bad if you always use qualified names by convention.
11:53:46 <cocreature> which is why henning is also the author of https://wiki.haskell.org/Import_modules_properly :)
11:54:48 <Cale> I wouldn't mind so much if he just did this to his own personal code
11:55:07 <Cale> But it's upsetting when he takes over maintainership on stuff like Haskore and does this kind of thing to it
11:56:38 <cocreature> I mostly find it somewhat sad since he does write quite a bit of code that could be very useful to the Haskell ecosystem
11:57:07 * hackage dom-lt 0.2.0 - The Lengauer-Tarjan graph dominators algorithm.  https://hackage.haskell.org/package/dom-lt-0.2.0 (AndreasK)
12:00:50 <cr3> if I do: pow :: Int -> Int -> Int; pow x 0 = 1; pow x (y + 1) = x * (pow x y) I get: Parse error in pattern y + 1. The reason I don't do: pow x y = x * (pow x (y - 1)) is to only match positive numbers, am I missing something?
12:02:10 <cocreature> cr3: n+k patterns have been gone from Haskell for quite some time. presumably you got this from a fairly old Haskell resource?
12:03:14 <cocreature> if you only want to match positive numbers do something like pow x n | n > 0 = …
12:03:19 <cr3> cocreature: sounds right :) is there a recommended way to not match negative numbers then?
12:03:36 <cr3> thanks, I'll play with that!
12:04:01 <cocreature> note that your type still allows for negative numbers so you have to handle them in someway (e.g. by crashing)
12:04:24 <Solonarv> vaguely related question: are guards allowed in pattern synonyms?
12:05:04 <cr3> cocreature: right, I could also play with a Nat type for natural numbers.
12:05:18 <cocreature> Solonarv: I don’t think you can use them directly but you can combine pattern synonyms + view patterns which lets you do the same thing
12:05:31 <Solonarv> there is one in base as of somewhat recently, in Numeric.Natural
12:05:46 <cr3> cocreature: will | n > 0 be caught at compile-time somehow or run-time?
12:05:51 <Solonarv> cocreature: yeah, I was just wondering if a more elegant way was available
12:05:53 <cocreature> run-time
12:13:07 * hackage text-show 3.8 - Efficient conversion of values into Text  https://hackage.haskell.org/package/text-show-3.8 (ryanglscott)
12:15:07 * hackage generic-aeson 0.2.0.10 - Derivation of Aeson instances using GHC generics.  https://hackage.haskell.org/package/generic-aeson-0.2.0.10 (ErikHesselink)
12:20:42 <ski> the "Compatibility" point under the "Clashing of module name abbreviations" section on that wiki page appears to be incorrect (or at least a bit incomplete) : isn't it the case that if an identifier is reexported, and you import it from two modules, in both cases originally coming from the same source of definition, there is no ambiguity problem ?
12:21:53 <ski> .. hm, i suppose perhaps it was taken to be understood that the definition of `intercalate' would be copied, rather than it being reexported by the other module ?
12:50:03 <dmwit> I think that was the intention, yeah. I'm imagining Data.List.Extra being from some Hackage package and Data.List being from base, where it wouldn't be sensible/possible for Data.List to re-export something from Data.List.Extra.
12:50:30 <dmwit> (Of course shortly afterwards Data.List.Extra might start re-exporting Data.List's version!)
12:54:40 <abhayps> Hi! I am interested in Algebraic Graph library project. I have been using scala from last one and a half year and haskell from last 3 months. I have read the relevant papers. I was planning to contribute something to it. Can anyone guide me on it? 
12:55:22 <dmwit> That's... a bit nebulous.
12:56:18 <cocreature> abhayps: I don’t think the author frequents this channel so writing them an email might be a better option
12:56:31 <dmwit> Are you asking for ideas of work to do, or asking about how to submit patches for inclusion/review, or something else?
12:57:52 <abhayps> I am asking for ideas of work to do.
12:58:39 <kadoban> I seem to recall there was some info in google summer of code for that project.
12:58:44 <kadoban> Probably some ideas in that.
13:02:39 <dmwit> abhayps: https://github.com/snowleopard/alga/issues looks like it has a lot of ideas
13:03:37 <Entilo> Hey, I've got the function `chomp :: String -> String; chew xs = takeWhile (== head xs) xs` and I want to make it more efficient, I found out that it would be the equivalent of writing ' chew = takeWhile (== head xs) ' however, when I input this, it tells me that 'xs' is out of scope, what am I doing wrong here?
13:04:28 <dmwit> How did you find out that (wrong, by the way) fact?
13:04:53 <dmwit> Eta reduction -- the move from `\x -> f x` to `f` -- is only correct when `x` is not free in the expression `f`.
13:05:18 <koala_man> Entilo: eta reduction is not an optimization. it won't make anything more efficient
13:05:19 <dmwit> Whereas in `\xs -> takeWhile (== head xs) xs`, we do have a free occurrence of `xs` in `takeWhile (== head xs)`.
13:05:24 <Entilo> dmwit: I learnt it in lesson on a different example which had a very similiar format
13:05:54 <Entilo> So can it not be done then due to the xs?
13:06:18 <dmwit> That depends on what "it" is.
13:06:31 <Entilo> the eta reduction
13:06:41 <dmwit> You *can* write this without naming `xs`. But no, there is no eta reduction to be done here.
13:06:59 <kadoban> Biggest thing that comes to mind in that is that knowing the length (and the repeated element) is a much more compact representation than having the whole list. For most instances of Eq anyway.
13:07:08 <kadoban> Not sure that's actually going to improve speed any
13:07:41 <Solonarv> koala_man: actually, it can end up being an optimization because (in GHC) it can affect inlining and sharing
13:07:55 <kadoban> That and   chew (x:xs) = takeWhile (== x) xs -- is a tad nicer, though you still have to handle the empty list case
13:08:16 <koala_man> Solonarv: really? why?
13:08:28 <kadoban> Woop, that's off by one element, w/e.
13:08:45 <dmwit> koala_man: Only fully-saturated applications are inlined.
13:09:13 <Solonarv> (where a function's arity is simply the number of arguments to the left of the = in its definition)
13:09:30 <dmwit> Not sure what Solonarv is thinking of with the sharing comment; probably imagining a more complicated function where some computation is done on some arguments before the others are needed.
13:09:34 <kadoban> Entilo: Oh, what about chew = head . group
13:09:38 <Solonarv> dmwit: yes, something like that
13:10:16 <Solonarv> also stuff defined in 'where' clauses possibly
13:11:24 <Solonarv> for example, prefer
13:11:24 <Solonarv> f . g = \x -> f (g x)
13:11:24 <Solonarv> over: (.) f g x = f (g x)
13:11:26 <koala_man> does that mean that e.g.  map f list and map (\x -> f x) list  will codegen differently?
13:11:51 <geekosaur> they can under some circumstances
13:12:01 <Solonarv> it might, but I wouldn't be surprised to see GHC eta-reduce the lambda in some situations
13:12:10 <geekosaur> depending on what RULEs and inlinings happen between the source and core
13:12:16 <Solonarv> they also have different semantics wrt strictness
13:12:40 <Solonarv> ...actually I'm not sure about that in the case of 'map' specifically
13:13:07 <dmwit> Yeah, probably not different semantics.
13:13:20 <geekosaur> consider what happens with map foo . map (\x -> f x), in the presence of a rewrite that turns it into map (foo . (\x -> f x)). then consider whatever foo is being inlined, triggering further rule firings and rewrites
13:13:36 <ski> having proper tail calls can be thought of as continuations being (properly) eta-reduced
13:13:46 <geekosaur> looking at what actual code does as it goes through rewrites can be fairly surprising
13:14:11 <geekosaur> depending on the rules in scope and what can be inlined under what circumstances
13:42:36 * hackage HsHTSLib 1.9.0 - Bindings to htslib.  https://hackage.haskell.org/package/HsHTSLib-1.9.0 (kaizhang)
13:51:25 <zuserm> Is there a command like "cabal repl" but that loads the tests instead of the library?
13:53:24 <geekosaur> I think you can specify the target to load with -t?
13:54:52 <zuserm> it's just cabal repl (name of component)
13:55:20 <geekosaur> hm, looks liek that's only new-repl
13:55:27 <geekosaur> which means time to switch :)
13:55:54 <geekosaur> (note that the old stuff will become v1-* in the next version, and "cabal repl" will be what is currently "cabal new-repl")
13:56:12 <geekosaur> the v1 stuff can't really support targets
13:58:40 <zuserm> seemed to work ¯\_(ツ)_/¯
14:02:07 * hackage HsHTSLib 1.9.0.1 - Bindings to htslib.  https://hackage.haskell.org/package/HsHTSLib-1.9.0.1 (kaizhang)
14:34:26 <bgavran> Hi, if I have a class constraint "type Allowed a = Constraint" for some class C, can I make GHC automatically infer "Allowed (a, a), Allowed (a, (a, a), Allowed ((a, a), a)..." ie, all possible products?
14:34:43 <bgavran> For example, I have a code snipper here that shows how I'm currently solving this: https://pastebin.com/Au7eArZz
14:35:42 <bgavran> but it doesn't seem like a scalable endeavour, because adding further class hierarchy just prompts the compiler that some constraint (always a product of existing constraints) is missing
14:37:37 <dmwit> Certainly not. For example, `Num a` does not imply `Num (a, a)`.
14:38:20 <dmwit> But... what are the definitions of Allowed{3,4,6,7}?
14:38:45 <bgavran> they're just convenience definitions: "type Allowed3 k a b c = (Allowed2 k a b, Allowed k c)"
14:38:58 <cjay-> how does cabal know whether to link statically or dynamically with "extra-libs:" and "frameworks:"?
14:39:16 <bgavran> and for my constraint, Allowed, it does mean Allowed a => Allowed (a,a)
14:39:34 <dmwit> bgavran: Perhaps you would like `type family AllowedN k as where AllowedN k [] = (); AllowedN k (a:as) = (Allowed k a, AllowedN k as)`.
14:40:03 <dmwit> There's probably some library that provides something like this parameterized over the constraint, even.
14:40:10 <bgavran> dmwit: right, but the problem is even worse tha njust adding N constraints!
14:40:54 <bgavran> dmwit: here is an example of an error I'm getting: https://pastebin.com/SuJt66jx
14:41:22 <dmwit> Hm. I wonder whether the new QuantifiedConstraints stuff would be helpful here.
14:42:23 <dmwit> Maybe you can `class (forall a b. (Allowed k a, Allowed k b) => Allowed k (a, b), Category k) => Monoidal k where ...`
14:42:56 <dmwit> Dunno. Haven't played with it enough to have a solid intuition for what works and doesn't.
14:43:03 <dmwit> You'll need a very new GHC.
14:43:05 <bgavran> dmwit: I've tried QuantifiedConstraints! In exactly the same way you just posted, but it doesn't seem to work
14:44:40 <bgavran> dmwit: when I try doing your suggestion, I'm getting the following error: https://pastebin.com/huxKey8y
14:45:01 <dmwit> You gotta show the code, too, dude.
14:45:05 <dmwit> or dudette
14:47:47 <bgavran> It should only try to deduce "Allowed (a, b)" if "Allowed a" and "Allowed b" are defined, right? 
14:47:55 <bgavran> sure, let me push this stuff
14:48:27 <dmwit> My instance for (->) seems to work alright.
14:49:08 <bgavran> here is the part with the quantified constraint https://github.com/bgavran/Compositional_Deep_Learning/blob/master/src/CategoricDefinitions.hs
14:49:09 <bgavran> hmm
14:49:35 <bgavran> and the problematic part is here: https://github.com/bgavran/Compositional_Deep_Learning/blob/master/src/Autodiff/Dual.hs
14:49:59 <bgavran> problematic part=error shows up when I try to compile with this new changes
14:50:32 <bgavran> dmwit: can you copy the snippet for the (->) instance? There doesn't seem to be many examples of QuantifiedConstraints online and it would definitely help in understanding!
14:52:37 <dmwit> ttps://gist.github.com/dmwit/a09f1535e499c5a8a675795bee8e75fb
14:52:44 <dmwit> irssi--
14:56:11 <dmwit> Interesting. Seems like `Monoidal k, Allowed (DualType k) a, Allowed (DualType k) b` ought to be enough to determine `Allowed k (a,b)`.
14:56:56 <dmwit> Since `Allowed (DualType k) a` can reduce to `Allowed k a`, hence you have `Monoidal k, Allowed k a, Allowed k b` and therefore `Allowed k (a,b)`.
14:57:52 <bgavran> Right, that was my reasoning as well
14:58:44 <bgavran> I'm just not sure if QuantifiedConstraint can really be reduced to implication "constraint a => constraint b": it seems GHC expects constraint b to be there iregardless
15:01:20 <cjay-> hmm the cabal documentation search fails me most of the time, i.e. https://www.haskell.org/cabal/users-guide/search.html?q=ld-options&check_keywords=yes&area=default
15:02:03 <cjay-> seems to be a property of sphinx though, so no way to fix it in the documentation on github
15:08:29 <dmwit> bgavran: Here's a minimized version which I think would be suitable for starting a discussion (as a bug report on GHC Trac), if you're into trying that route. https://gist.github.com/dmwit/47a3435d1c16a532e24c9f156da0dae6
15:09:10 <dmwit> (Error included as a comment now.)
15:10:49 <bgavran> Interesting, so you think this is definitely unexpected behavior?
15:12:10 <dmwit> I don't understand the theory enough to claim that. But I do think it's reasonable to expect it to work, and I think GHC HQ will by sympathetic to that, and so if the theory doesn't support that, they will want to know so they can think about how to fix the theory.
15:12:46 <dmwit> Of course it's possible they give you an answer of the form, "Yeah, we know, see section 5.2 of our paper for why it's hard/impossible to support.".
15:13:22 <shmendrik> is anyone here use Org-Mode (in emacs) to execute haskell code? because i have a function that when i save it to .hs file and load it to ghci, i can run it without a problem. but in Org-Mode i get error: non-exhaustive patterns... here is a screen shot from org mode with the error: https://pastebin.com/jRSCGXik
15:13:24 <dmwit> But it's also possible they hadn't thought through the interactions with type families all the way, and this will be news to them. As I said, I'm not familiar enough with the theory to make a solid guess about which side you'll land on.
15:13:35 <c_wraith> as I understand it, QuantifiedConstraints has some.. known flaws.
15:14:17 <dmwit> shmendrik: Perhaps that's being sent to ghci line by line, in which case the later cases create a new `qs`, shadowing the old ones, with just one clause.
15:14:23 <shmendrik> soryy this is not a screenshot. it is the code block. 
15:14:27 <dmwit> shmendrik: Try `:{\nqs [] = []\n...\n:}`
15:14:49 <shmendrik> dmwit: where to put this?
15:15:07 <dmwit> Add a line above your current line 2 with `:{`; add a line before your current line 6 with `:}`.
15:15:34 <dmwit> Sorry.
15:15:36 <dmwit> Correction
15:15:47 <dmwit> The `:}` should go above your current line 5, not 6.
15:16:24 <dmwit> I've got to run, but there are certainly others around that can speculate further on what's gone wrong, so keep us posted.
15:16:36 <shmendrik> dmwit: thank you very much!
15:16:50 <shmendrik> ill try of course :)
15:16:52 <bgavran> dmwit: thank you!
15:17:08 <bgavran> dmwit: I'm definitely out my depth here, but if I can help by posting this report, I will do it!
15:17:39 <isovector1> is it possible to write a typefamily that pulls `a` out of an arbitrarily long `a b c d e f`?
15:18:34 <isovector1> the obvious `type family GetHead (wanted :: k) :: k' where { GetHead (e a) = GetHead e; GetHead a = a }` gets stuck in the `a = a` case
15:21:07 * hackage pattern-matcher 0.1.0.0 - A library for compiling pattern-matching to decision trees  https://hackage.haskell.org/package/pattern-matcher-0.1.0.0 (GuerricChupin)
15:22:35 <shmendrik> dmwit: you are great. it is working!!!1
15:22:52 <shmendrik> dmwit: hope you will see it late. thank you very much :-)
15:23:01 <shmendrik> *late
15:23:04 <shmendrik> later*
15:26:49 <Solonarv> isovector1: it shouldn't get stuck if the head is a specific type constructor
15:26:56 <Solonarv> otherwise it will get stuck, yes
15:33:11 <isovector1> Solonarv: it gets stuck: `GetHead (Maybe Int) = GetHead Maybe` :(
15:33:40 <isovector1> ghc 8.6.3
15:33:43 <Solonarv> really? that's strange...
15:33:51 <isovector1> yeah. i think it's because the two cases have different kinds
15:33:58 <isovector1> so technically it's getting stuck on a kind error
15:34:08 <Solonarv> % type family AppHead a where AppHead (f a) = AppHead f; AppHead a = a
15:34:09 <yahb> Solonarv: ; <interactive>:34:53: error:; * Occurs check: cannot construct the infinite kind: k1 ~ k0 -> k1; * In the first argument of `AppHead', namely `f'; In the type `AppHead f'; In the type family declaration for `AppHead'
15:34:28 <Solonarv> % type family AppHead (a :: k1) :: k2 where AppHead (f a) = AppHead f; AppHead a = a
15:34:28 <yahb> Solonarv: ; <interactive>:35:43: error:; * Variable `k' occurs more often in the type family application `AppHead f' than in the instance head `AppHead (f a)'; (Use UndecidableInstances to permit this); * In the equations for closed type family `AppHead'; In the type family declaration for `AppHead'
15:34:48 <Solonarv> % :set -XUndecidableInstances
15:34:48 <yahb> Solonarv: 
15:34:50 <Solonarv> % type family AppHead (a :: k1) :: k2 where AppHead (f a) = AppHead f; AppHead a = a
15:34:50 <yahb> Solonarv: 
15:34:58 <Solonarv> % :kind! AppHead (Maybe Int)
15:34:58 <yahb> Solonarv: AppHead (Maybe Int) :: k2; = AppHead Maybe
15:35:04 <Solonarv> yikes
15:35:28 <isovector1> cool hey?
15:35:40 <Solonarv> maybe you can use a bunch of auxiliary type families to help the kinds line up
15:36:47 <isovector1> can you set -fprint-explicit-kinds and try the `GetHead` again?
15:36:57 <isovector1> (i don't know how yahb works)
15:37:10 <Solonarv> % :set -fprint-explicit-kinds
15:37:10 <yahb> Solonarv: 
15:37:15 <Solonarv> % :kind! AppHead (Maybe Int)
15:37:15 <yahb> Solonarv: AppHead (Maybe Int) :: k2; = AppHead k2 (* -> *) Maybe
15:37:34 <isovector1> so i think what's stuck here is the k2?
15:37:49 <Solonarv> yeah I think this is fixable with some additional cleverness
15:38:33 <Solonarv> (yahb is just an interface to ghci, by the way - pretty much everything that works in ghci works in yahb)
15:38:56 <isovector1> coool :) thanks
15:39:08 <isovector1> i gotta run, i'll ponder this deeply during dinner
15:39:20 <Solonarv> good luck!
15:39:26 <isovector1> thanks!
17:38:11 <concaveirc> Hello all, I am using XMonad and I am trying to set up a golden ratio brighness incrementer/decrementer.
17:38:22 <concaveirc> The key functions are here: https://pastebin.com/cDaHPkBh
17:38:55 <concaveirc> From ghci, calling incBrightness and decBrightness change the brightness as desired
17:39:18 <concaveirc> However, called by a key binding to  "liftIO incBrightness" does nothing
17:39:41 <concaveirc> I believe the culprit is getBrightness not working when called internally for some reason.
17:40:44 <concaveirc> However, if I copy incBrightness to another file's main method and spawn it via a key binding to `spawn "~/tmp/inc-brightness"`, the desired outcome happens.
17:41:09 <slack1256> What is popular for ML on haskell? It doesn't have to be production ready but interesting
17:41:17 <concaveirc> The question is how do I get incBrightness/decBrightness to do what I want within just the `xmonad.hs`
17:42:09 <concaveirc> slack1256: I have never used it before, but grenade seems to have a good amount of activity.
17:42:23 <pacak> concaveirc: I'd do something like "getBrightness = fromMaybe 0 . readMaybe <$> shelly (run .... )"
17:42:39 <pacak> You'll need Data.Maybe and Text.Read
17:43:13 <pacak> You should also be able to test if it works in ghci
17:43:14 <concaveirc> pacak: I'll give that a shot
17:43:50 <concaveirc> pacak: currently, getBrightness always works in ghci, but the whole implementation does not when bound to a key
17:44:32 <pacak> Next. You get 0 when there's something wrong with it. 0 multiplied by ratio is still 0...
17:45:47 <pacak> 19th line... simplify a bit with min/max?
17:47:12 <concaveirc> pacak: Oh, yeah, I will do that
17:49:22 <dmwit> concaveirc: Likely culprit is that xmonad does nasty stuff with signal handlers.
17:49:40 <dmwit> concaveirc: Using other mechanisms than `spawn` for starting things (like `shelly`...) isn't really supported.
17:50:48 <concaveirc> dmwit: Is there another way to grab the output of "xbacklight"?
17:53:11 <dmwit> You can try using XMonad.Core.uninstallSignalHandlers (and X.C.installSignalHandlers) manually.
17:53:34 <dmwit> Normally spawn also forks a separate process, so that waiting on the result of the call doesn't block xmonad's main loop.
17:53:53 <dmwit> So if you do this yourself, and it breaks, you get to keep both pieces... ;-)
17:54:21 <concaveirc> pacak: I get 0 when replacing the implementation with readMaybe
17:54:50 <pacak> > fromMaybe 0 (readText "123\n")
17:54:51 <lambdabot>  error:
17:54:51 <lambdabot>      • Variable not in scope: readText :: [Char] -> Maybe a
17:54:51 <lambdabot>      • Perhaps you meant ‘readHex’ (imported from Numeric)
17:54:59 <pacak> > fromMaybe 0 (readMaybe "123\n")
17:55:01 <lambdabot>  error:
17:55:01 <lambdabot>      Variable not in scope: readMaybe :: [Char] -> Maybe a
17:55:17 <MarcelineVQ> slack1256: interesting? https://hackage.haskell.org/package/grenade
17:55:32 <concaveirc> dmwit: That can be a final effort. I will probably separate the functions into separate files for now before doing that though.
17:55:32 <pacak> concaveirc: Worked for me in ghci, maybe output is more strange than I tested.
17:55:56 <concaveirc> pacak: Same here in ghci.
17:56:06 <concaveirc> pacak: The issue is when I bind a key with spawn
17:56:27 <dmwit> concaveirc: Also, there's an #xmonad that might interest you for future xmonad questions. =)
17:56:41 <concaveirc> dmwit: Thanks
17:57:15 <dmwit> (Oh, since it's not documented: the protocol would be 1. uninstallSignalHandlers 2. launch your process and await its results 3. installSignalHandlers.)
17:57:38 <dmwit> (I can see how that might seem backwards from a library user perspective.)
17:58:11 <concaveirc> dmwit: Yeah, that will require more buffer time than I currently have
18:00:33 * dmwit nods sympathetically
18:01:11 <dmwit> I use a crappy window manager written in C instead of xmonad these days because I'm never tempted to make it work better.
18:06:03 <sshine> when would a list zipper be useful?
18:06:12 <bburd> Hello. I’m seeing dependency errors trying to run a GTK example with new-build. What do you need to see in order to help me out?
18:07:12 <geekosaur> bburd, to start with, the errors (to a pastebin of some kind)
18:07:55 <geekosaur> ntoe that gtk is a C library and you need the development headers from it, which on fedora or debian/ubuntu means -devel or -dev packages, not just the runtime
18:09:37 <jackdk> sshine: https://www.youtube.com/watch?v=IcgmSRJHu_8
18:09:44 <concaveirc> dmwit: nevermind, that was just adding two lines of code and now things work
18:09:59 <bburd> @geekosaur, I’m not familiar with the -devel option. I’m running on a Mac.
18:09:59 <lambdabot> Unknown command, try @list
18:10:24 <dmwit> gtk2hs on Mac is notoriously tricky
18:10:47 <dmwit> The wiki page has some experience reports from other users that got it working that you might want to check.
18:11:20 <dmwit> https://wiki.haskell.org/Gtk2Hs/Mac
18:11:47 <geekosaur> it's not an option, it's a set of packages in various the Linux distributions I mentioned. since you hadn't said which OS and this issue often comes up, I mentioned it
18:12:04 <bburd> I’m following the instructions at https://www.youtube.com/watch?v=Xfu-Mt4YDWQ    …   It mentions nothing about -devel. I suppose I can try it on Linux instead of Mac.
18:12:07 <geekosaur> on mac you proabbly need to install gtk via homebrew or macports before you can do anything with it
18:12:47 <dmwit> Oh, haskell-gi is another thing still.
18:13:08 <geekosaur> and might need to point cabal to it with options
18:13:55 <dmwit> There are some pretty bare-bones instructions in haskell-gi's readme.
18:13:59 <dmwit> Have you followed them?
18:14:24 <bburd> I haven’t followed the instructions in haskell-gi’s readme.
18:16:38 <adarqui> hey. how do you download a tarbell revision on hackage? trying to download revision 0 of semigroupoids
18:16:47 <adarqui> semigroupoids 5.0.1 rev 0
18:19:47 <bburd> I’ll save the GTK project for an evening when I have more spare time. Thanks.
18:27:13 <geekosaur> adarqui, http://hackage.haskell.org/package/semigroupoids-5.0.0.1/revisions/
18:27:57 <geekosaur> note that this gives you a cabal file you'd need to "cabal get semigroupoids-5.0.0.1" and then copy the cabal file from the above over its existing file
18:28:22 <geekosaur> this isn't made easy because usually a metadata revision means the previous revision had been unbuildable on some configurations
18:30:22 <geekosaur> (the UI to find the above: select version 5.0.0.1 from the version list, scroll down to "metadata revisions", click on that link)
18:33:37 * hackage persistent-relational-record 0.3.0 - relational-record on persisten backends.  https://hackage.haskell.org/package/persistent-relational-record-0.3.0 (TakahiroHimura)
18:47:06 * hackage HsHTSLib 1.9.1 - Bindings to htslib.  https://hackage.haskell.org/package/HsHTSLib-1.9.1 (kaizhang)
18:49:24 <adarqui> ah ya i could only find the cabal file. ok cool thanks geekosaur 
18:49:47 <geekosaur> a revision only can change the package version dependencies in the cabal file
18:49:59 <adarqui> im trying to build some old ghcjs repos and it's breaking on semigroupoids-5.0.1, some issue created by a revision or something
18:50:05 <geekosaur> a new release is needed for anything else
18:50:06 <adarqui> can't get my old code to build. rough.
18:54:50 <adarqui> i'll get it to build eventually.
18:59:37 <geekosaur> if you're trying to get it to build on anything beyond 8.0, I think it's doomed? and may not work on 8.0 if they're too old.
19:00:03 <geekosaur> (there was an 8.0 branch of ghcjs, not sure there's a later one)
19:10:07 <sshine> jackdk, thanks!
19:10:19 <jackdk> yw
19:21:24 <adarqui> nah trying to get it to build on 7.10.3
19:21:35 <adarqui> i think it doesn't like my cabal 2.4
21:50:45 <c50a326> data Sheep = Sheep Sheep Sheep -- this doesn't make a compiler error, but it's not usable is it?
21:51:11 <kadoban> It looks difficult to construct a value of it at least.
21:51:37 <maerwald> constructing should be easy, forcing not, lol
21:52:47 <kadoban> Heh, I suppose.
21:53:27 <glguy> % data Sheep = Sheep Sheep Sheep
21:53:28 <yahb> glguy: 
21:53:39 <glguy> % let sheep = Sheep sheep sheep
21:53:39 <yahb> glguy: 
21:53:47 <glguy> % sheep `seq` ()
21:53:47 <yahb> glguy: ()
21:54:11 <glguy> baaa
21:57:26 <iamyohann> #join haskell.au
21:57:58 <iamyohann> (my bad, new to IRC ignore)
22:04:41 <DigitalKiwi> glguy: now do it with buffalo
22:05:20 <DigitalKiwi> https://en.wikipedia.org/wiki/Buffalo_buffalo_Buffalo_buffalo_buffalo_buffalo_Buffalo_buffalo
22:05:57 <jackdk> c50a326: before GHC allowed `data Void`, I think it was defined in a similar way
22:07:23 <glguy> jackdk: Yeah: "data Void = Void !Void" and then later "newtype Void = Void Void"
22:07:57 <jackdk> that was before I got seriously into hakell, so I didn't gaze too deeply into the `Void`
22:08:15 <kadoban> xD
22:08:32 <kadoban> data Void = Void !Void is pretty clever
22:10:12 <remexre> is there a way to dual-license a cabal pkg?
22:10:27 <remexre> (specifically Apache-2.0/MIT)
22:25:21 <jle`> are licenses closed under dualing like that?
22:28:13 <c50a326> oh cool, you can use record syntax in ADT's...
22:32:04 <jackdk> c50a326: but be careful: that's usually a bad idea because your field accessors are now partial
22:36:43 <c50a326> ah yeah, so data Sheep = Sheep { mother :: Sheep } | None; mother None -- makes an exception...
22:36:49 <c50a326> jackdk: is that what you mean by partial?
22:36:56 <jle`> that should compile
22:36:58 <jle`> but 'mother' would be partial
22:37:02 <jle`> as in, it's not defined on all input
22:38:02 <c50a326> ah yeah
22:38:18 <jackdk> I tend to never use record fields in sum types for that reason. I remember _wanting_ to do it, when I first started with OO and was carrying subclassing intuitions onto sum types
22:45:59 <remexre> jle`: yeah, per SPDX; Cabal doesn't implement SPDX (although there is a bug)
22:46:05 <remexre> I was hoping there was another mechanism
22:46:48 <remexre> SPDX has both "and" (e.g. has a GPL component and an AGPL component), and "or" (it's "really" MIT licensed, but the Apache-2.0 patent grant is good)
22:48:03 <c50a326> in "All About Monads", it talks about "one-way" monads, IO specifically... And that Maybe and List are not "one-way", you can "get out" of them... What is it about the implementations of Maybe and List etc that make them not one-way?
22:48:54 <remexre> I can write a function (Maybe a -> a) or (List a -> a)
22:49:00 <remexre> I can't write a function (IO a -> a)
22:49:09 <kadoban> c50a326: The constructors are public
22:49:37 <c50a326> ah so you can pattern match against them?
22:49:42 <c50a326> whereas you can't with IO?
22:49:59 <remexre> kadoban: That's stronger than necessary; you could have a monad with private constructors but a `runMyMonad :: MyMonad a -> a` and it'd be "not one-way"
22:50:18 <kadoban> Ya, that's true ^
22:50:32 <kadoban> But yes, that's the idea. You can deconstruct them, with pattern matching or some other way.
22:51:53 <dminuoso> c50a326: You can't get out of List and Maybe.
22:52:06 <dminuoso> c50a326: Please write a function `f :: [a] -> a` that is total.
22:54:38 <dminuoso> c50a326: One interesting case is NonEmpty, which doubles as both Monad and Comonad, so you get `pure :: a -> NonEmpty a` and `extract :: NonEmpty a -> a`, as well as (=<< :: NonEmpty a -> (a -> NonEmpty b) -> NonEmpty b) and (extend :: NonEmpty a -> (NonEmpty a -> b) -> NonEmpty b)
22:54:44 <dminuoso> Plus coherence laws.
22:56:09 <remexre> side question wrt comonads
22:56:16 <remexre> is coapplicative a useful notion?
22:56:25 <dminuoso> remexre: Not in Haskell.
22:59:36 <dminuoso> remexre: The problem is that Haskell does not have any interesting non-trivial comonoids.
23:00:16 <remexre> where a comonoid would be something like an infinite binary tree?
23:00:50 <remexre> (full disclosure I know zero category theory)
23:01:55 <dminuoso> remexre: wait I mixed something up there.
23:03:27 <dminuoso> remexre: I think edward pointed out in order to have Coapplicative you would need to collapse all of Haskell into a poset.
23:03:43 <remexre> huh, ok
23:04:22 <dminuoso> remexre: Ah I found the quote: "It'd make the language boring to have them in full generality, though, as having arbitrary coexponentials and exponentials collapses the world down to a poset, leaving at most one arrow between any two types!"
23:05:41 <remexre> exponential == function, coexponential == having an (a -> b) -> b -> a function?
23:17:53 <c50a326> fathersMaternalGrandmother sheep = father sheep >>= mother >>= mother    -- why can't we just remove the "sheep" to be point-free here? (`mother` and `father` are like (a -> Maybe b))
23:18:45 <c_wraith> c50a326: you need a different operator than (>>=), but you can.  try (>=>) 
23:19:01 <c_wraith> :t (>=>)
23:19:02 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
23:37:01 <fen> % let g f = (<*>) . (fmap f) . pure 
23:37:01 <yahb> fen: 
23:37:16 <fen> % g (g (g (:))) 0 (Identity ("hello",[[1,2],[4]]))
23:37:16 <yahb> fen: Identity ("hello",[[0,1,2],[0,4]])
23:37:20 <fen> !?
23:39:45 <fen> % :t g
23:39:45 <yahb> fen: Applicative f => (a1 -> a2 -> b) -> a1 -> f a2 -> f b
23:40:11 <fen> g :: Applicative f => (a1 -> b -> b) -> a1 -> f b -> f b
23:40:33 <fen> :t (:)
23:40:35 <lambdabot> a -> [a] -> [a]
23:41:20 <fen> we can pattern match on (:) as it is a datatype constructor, but how can we pattern match on a list interspersed with `g' ?
23:53:47 <fen> if an applicative is lazy then it can be left as a thunk like (:) ?
23:55:32 <fen> ie when we traverse, we go from 1 : 2 : 3 .... to 1 `g` 2 `g` 3 ....
23:56:43 <fen> sorry, should be; 1 `g (:)` 2 `g (:)` 3 ...
23:56:54 <fen> % :t g (:)
23:56:54 <yahb> fen: Applicative f => a -> f [a] -> f [a]
23:57:14 <fen> % :t g (g (:))
23:57:14 <yahb> fen: (Applicative f1, Applicative f2) => a -> f1 (f2 [a]) -> f1 (f2 [a])
23:58:27 <fen> so can we build up these interspersed nested applicative constructors lazily? so that you could do e.g. take, and it wouldnt evaluate them all?
23:59:05 <fen> like, 1 `g1 (g2 (:))` 2 `g1 (g2 (:))` 3 ...
23:59:15 <fen> etc
