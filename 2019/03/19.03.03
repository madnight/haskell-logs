00:00:55 <Eduard_Munteanu> It's 10am here, but in US it's late at night.
00:24:40 <abiduzz420> Eduard_Munteanu, Yeah you are probably right 
01:10:38 <Jerry> Hi
01:11:37 --- mode: glguy set +v t4nk191
01:13:29 <t4nk191> hey! why ist this function  reverseWords = unwords . map reverse . words not equal to reverseWords xs = map reverse xs. thanks for your help
01:22:03 <sternmull> The documentation uses a sql function for quasi quoting. Could anyone tell from where is this function is imported? I can't find it.
01:22:22 <sternmull> ment to say: the documentation of posgresql-simple
01:30:00 <dmwit> sternmull: Where do you see that?
01:30:12 <dmwit> There's... a lot of modules.
01:30:30 <sternmull> dmwit: for example here: https://hackage.haskell.org/package/postgresql-simple-0.6/docs/Database-PostgreSQL-Simple.html#v:executeMany
01:30:58 <dmwit> Click "Index" at the top, then "S".
01:31:59 <sternmull> dmwit: Oh, thanks! Didn't know that way to find functions.
01:32:10 <phadej> sternmull: https://hackage.haskell.org/package/postgresql-simple-0.6/docs/Database-PostgreSQL-Simple-SqlQQ.html
01:55:10 <akerl> Not sure where the right place to report this is, but on https://www.haskell.org/ghc/download.html there appears to be a typo: the link correctly points to 8.6.3, but the text of the link says “8.6.2”
02:09:05 --- mode: glguy set +v sariyar_
02:09:38 * hackage haskell-debug-adapter 0.0.29.0 - Haskell Debug Adapter.  https://hackage.haskell.org/package/haskell-debug-adapter-0.0.29.0 (phoityne_hs)
02:52:26 <cocreature> another day, another time I got screwed over by [0::CUInt .. n - 1]
03:06:17 <Tuplanolla> I know this flavor of pain.
03:06:33 <Tuplanolla> Is there any language, where integer overflows are given the attention they deserve?
03:10:23 <fr33domlover> In a typeclass instance, if I want to define a function that has a default implementation, but I want to reuse that default implementation, is there a nice way to do that? Or do you generally just copy the code into your modified definition?
03:12:24 <lemmih> fr33domlover: I would copy the code. You could also create a newtype that uses the default implementation but that seems convoluted.
03:13:27 <cocreature> fr33domlover: do you have control over the typeclass?
03:13:39 <bonz060> Hi guys :) I've been on an endless loop of trying to learn Haskell. I tried to read "Learn you a haskell", but the book, unfortunately, in its attempt at making things simple made things more complicated. I built a simple tic-tac-toe game and that helped me alot in learning a bunch of things. I realised that aiming to "learn Functional Programming in Haskell" was too abstract. So I've decided to be break things into
03:13:39 <bonz060>  more actionable items, like "Go through typoclassepedia". Haskellers in the house, what was your learning path?
03:13:50 <fr33domlover> cocreature, it's a typeclass defined in an existing library
03:14:11 <fr33domlover> lemmih, yeah I considered the newtype but it seems weird, I've never seen anyone do that
03:14:23 <cocreature> yeah then copying is probably the easiest solution
03:14:39 <cocreature> otherwise I would suggest to make it a separate top-level definition so that people can reuse it
03:15:23 <lemmih> bonz060: I do project-euler problems with my friends as a way of teaching them functional programming.
03:23:37 <bonz060> lemmih: I thought Project Euler was more of an exercise in Maths and algorithm implementation, which you could then express(or rather try to solve) in a way you felt comfortable.
03:24:32 <lemmih> bonz060: A lot of the problems are so simple that you know exactly what you want to do. The problem then becomes how to express it in Haskell code.
03:34:58 <dmwit> fr33domlover: Wait, why do you want to explicitly define the function to be its default implementation?
03:35:03 <dmwit> (What's wrong with letting it default?)
03:36:00 <dmwit> Oh, I see. You want to use the default implementation as a small piece of a larger, non-default implementation.
03:36:13 <dmwit> Took me a few tries to understand, sorry. =P
03:41:19 <sternmull> bonz060: Pick up simple problems and try to solve them with Haskell. In my experience it is very tempting to try to understand the theory and libraries of Haskell. But for me it always ended with only a few lessens learned and a bunch of new open questions. I usually make significantly more progress with Haskell when i do actual practical programming-problems and then look up the obstacles that i encounter while doing that.
03:42:00 <__monty__> bonz060: The AoC exercises are less mathy and pretty fun imo. Though they ramp up really hard.
03:54:16 <talqu> join #reflex-dom
04:08:18 <syniseth> How do I specify the step value for a sequential list, i.e., [10, 20, ... , 120]?
04:09:55 <[exa]> > [10,20..120] -- syniseth
04:09:58 <lambdabot>  [10,20,30,40,50,60,70,80,90,100,110,120]
04:11:04 <[exa]> syniseth: (btw it's a syntactic sugar, equivalent to calling 'enumFromThenTo 10 20 120' by hand)
04:11:15 <syniseth> I see, [10, 20..120]
04:11:35 <syniseth> ty exa
04:25:38 * hackage reanimate-svg 0.7.0.0 - SVG file loader and serializer  https://hackage.haskell.org/package/reanimate-svg-0.7.0.0 (DavidHimmelstrup)
05:06:49 <OmegaDoug> In Haskell
05:07:01 <OmegaDoug> https://stackoverflow.com/a/21505363
05:07:37 <OmegaDoug> Regarding that question, if we isolate the DB functions to one part of the code (instead of using the single pattern as in OOP), how would we access a database connection?
05:08:52 <OmegaDoug> I'm looking at writing a logging library (I know some exist) that provides a (thread) channel to write to. But what are some ways for functions in other parts of the code base to access that channel without having to add it as a parameter to every function?
05:13:18 <phadej> Control.Monad.Reader
05:17:45 <OmegaDoug> Thanks for the pointer. Am I going to have to wire this reader throughout the code base to each spot it's needed?
05:18:48 <OmegaDoug> It would be nice to be able to access a sort of registry where I can just grab the reader and use it,
05:21:13 <lyxia> I'm not sure you can do that without making your language impure.
05:21:45 <[exa]> OmegaDoug: wiring the Reader is usually nicer than just wiring the extra argument(s) everywhere. Moreover, later you will be able to (without much effort) wire in some State, Writer for logging, etc.
05:24:27 <[exa]> btw, from the software engineering perspective-- if you need to broadcast the connection object to too many places, separation of concerns in your code should be improved
05:26:28 <OmegaDoug> I can see that for a DB connection. All access to the DB should be contained in one module. But other modules would need to write to the database as well. So does a "create new user" module need to supply the database connection information to the database module?
05:26:52 <OmegaDoug> Otherwise, how would the database module obtain the connection information?
05:28:13 <OmegaDoug> It would seem that the "new user module" should just supply it's information to the database module without having to concern itself with any backend details.
05:30:52 <OmegaDoug> If I want to change the backend storage to something else I think I should only need to change the DB module, and not every function which calls it, as the rest of the code base is only producing data.
05:31:04 <OmegaDoug> Maybe I'm minsunderstanding the implementation in Haskell though.
06:13:07 <slaterr> hi. I want to create my own html generator for fun, in the spirit of blade html and lucid, but I'm stuck at how to write a monad that lets me use do syntax. I tried looking at the source of those libraries but I can't follow it
06:13:29 <slaterr> I have this: data Tag = Tag { tagName  :: String , tagAttrs :: [Attr] , tagChildren :: [Tag] }
06:13:37 <slaterr> and this: type TagMonad = Identity Tag
06:16:13 <[exa]> slaterr: what do you want to happen if you have 2 commands that produce Tag and write them to a single 'do' block?
06:17:27 <slaterr> my code compiles, and I thought it worked. but if I have more than one child everything is ignored except the last one. so  html $ do body [] $ do p "first paragraph" p "second paragraph"  will give me:  <html><body><p>second paragraph</p></body></html>
06:17:48 <[exa]> slaterr: side question -- how do you encode 'test<b>test</b>' in your Tag ?
06:19:15 <slaterr> <b>test</b> would be  (b (String "test")), and with overloaded strings it would be (b "test"). I can't encode test <b>test</b>, in Tag, I'd have to use [Tag].
06:20:09 <slaterr> just noticed that pasted partial type. my complete type is:  data Tag = Tag { tagName  :: String , tagAttrs :: [Attr] , tagValue :: [Tag] } | String String
06:20:23 <[exa]> ok, that being said, how would you encode the result of:   do { p "test"; p "test" }
06:21:10 <[exa]> (because you will need a method to encode that if you expect monads to return something meaningful
06:21:48 <slaterr> I think I see where you're going with this. I'd need to be able to store that as Tag, not as [Tag]?
06:22:31 <[exa]> yeah. You could circumvent it using some trickery but having a first-class tag concatenation helps quite a bit, especially if you want your monad to do concatenation... :]
06:22:41 <slaterr> that's what I want
06:22:57 <slaterr> so adding Tags [Tag]  would work in a pinch?
06:23:34 <[exa]> semi-related: observe difference between Tree and Forest here https://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Tree.html
06:23:39 <slaterr> do I need to write my own monad, or can I use identity monad?
06:24:11 <[exa]> you will be able to reuse some monads, but certainly not identity
06:25:15 <[exa]> btw just adding Tags [Tag] can add quite a bit of ambiguity, for example I wouldn't want my type to be able to encode Tags [Tags [Tags [ ...]]]
06:25:25 <slaterr> I thought so as well. but how is Lucid using this type alias: type Html = HtmlT Data.Functor.Identity.Identity :: * -> *
06:25:38 <hpc> weird - when stack installs ghc the reason it takes so long is it runs strip over it
06:25:39 <slaterr> monad transformer of identity monad??
06:26:01 <slaterr> [exa], what would be better?
06:26:03 <[exa]> slaterr: oh, that's exact opposite of what you did -- you used Identity that contains HTML, he used Identity as a bottom case for HTML
06:26:14 <[exa]> slaterr: see the Data.Tree
06:26:26 --- mode: glguy set +v stoarmy
06:26:51 <[exa]> they have type Forest = [Tree]; and data Tree=Tree itemtype [Forest]
06:27:24 <[exa]> that way you force there's always at least 1 tag between the tag list structures
06:28:36 <stoarmy> hello everyone
06:28:49 <[exa]> slaterr: (oh I added redundant [] around the second Forest, sorry)
06:31:11 <slaterr> hmm, not sure I fully understand those types
06:31:41 <[exa]> slaterr: so I'd recommend newtype Tags=Tags [Tag]; data Tag=Text String | Tag {....}
06:31:46 <slaterr> probably not helped by the fact that I don't know rose tree datastructure
06:32:10 <[exa]> rosetree is like a binary tree, except it's not binary but any-number-ary
06:32:30 <slaterr> so each node has many leafs, not just two
06:33:43 <amosbird> Hi, is there a static build of this https://github.com/jtdaugherty/tart
06:34:19 <slaterr> I understand newtype Tags=Tags [Tag]; data Tag=Text String | Tag {....}. but not sure what to do from there. I'd need a Monadic type, and neither Tags or Tag can be it, as they have wrong kind
06:34:41 <[exa]> slaterr: yeah. Also I wrote newtype there, 'type' is probably sufficient
06:34:54 <slaterr> I tried to do something like this data Tag a = Tag { tagDummy :: a ...}, so that it can be a monad, but quickly realized that won't lead anywhere
06:35:19 <[exa]> slaterr: the distinction now is that Tags can behave like what you want, but Tag can not (it doesn't support concatenation)
06:35:43 <slaterr> yes
06:36:23 <[exa]> slaterr: and, long story short, your magic monad is then just a Writer
06:36:43 <slaterr>  I never used Writer monad :P
06:37:05 <slaterr> I used State, and StateT transformer
06:37:56 <[exa]> oh, you'll have no trouble with Writer then. Instead of get/set it only has 'tell' which appends a value to a monoid (e.g. to your list) and you can collect the result after that
06:38:21 <slaterr> I see
06:38:32 <[exa]> you will need to produce a bit of the wrapping for hiding the 'tell' in 'div' and 'p' and similars
06:40:37 <[exa]> also there are special functions for nesting Writers, eg. https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Writer-Lazy.html#v:listen
06:40:43 <[exa]> which should make it quite simple
06:40:56 <amosbird> heh
06:40:59 <[exa]> so you don't need to run a new Writer for each sub-tag
06:41:05 <slaterr> so I'll have something like this instead of Identity Tag I had earlier:  MonadWriter Tags Identity?
06:41:39 <[exa]> 'Writer Tags' is a monad
06:41:51 <slaterr> ah
06:42:02 <[exa]> you don't need identity, that's for transformers (eg. 'WriterT Tags Identity == Writer Tags')
06:49:05 <slaterr> ok! I think I understand how it should all fall together. I'll update my data structures first, and then try Writer monad
06:49:38 <slaterr> would type Html = Html [Tag]  be a good name?
06:50:00 <slaterr> it can contain invalid Html, so I'm not sure
06:52:57 <amosbird> is there a way to get a static build of this https://github.com/jtdaugherty/tart  without having cabal?
06:53:45 <hpc> see if it's in your os package manager
06:54:04 <hpc> or do what cabal does, but manually
06:57:37 * hackage html-entities 1.1.4.3 - A codec library for HTML-escaped text and HTML-entities  https://hackage.haskell.org/package/html-entities-1.1.4.3 (NikitaVolkov)
06:58:03 <gentauro> is anybody from `haskellweekly` here?
06:58:17 <gentauro> I mean, how do you get in contact with them if you don't have Twitter?
06:58:18 <gentauro> :|
06:58:39 <[exa]> slaterr: you don't need to add name to the 'type' synonym (it would be necessary for newtype but you most likely don't need newtype)
06:58:54 <[exa]> just type Html=[Tag]
06:59:36 <gentauro> [exa]: so a type alias?
06:59:41 <amosbird> curl -s "https://downloads.haskell.org/~ghc/"
06:59:56 <amosbird> why does this command return binary output now?
07:00:40 <hpc> does it recognize it as a directory listing and download recursively perhaps?
07:01:13 <[exa]> amosbird: looks like it's gzipped
07:01:19 <amosbird> hmm
07:01:48 <slaterr> type Html = Html [Tag]  gives me Cycle in type synonym declarations
07:01:53 <[exa]> kindof seems like curl failed to interpret the http header about compression
07:02:02 <slaterr> so it seems like I need newtype
07:02:03 <[exa]> slaterr: yeah, without the second 'Html'
07:02:11 <amosbird> [exa]: so what's the fix?
07:02:12 <slaterr> oh, right!
07:02:28 <[exa]> amosbird: you can do curl ... | gzip -d, but it will break again when they fix curl
07:02:34 <amosbird> ............
07:02:36 <slaterr> my brain is a complete lbank from trying to figure this out for the past several hours, I forgot basic syntax :P
07:03:01 <amosbird> [exa]: is there a command line check if the output is a zip stream?
07:03:04 <slaterr> good name?   type HtmlMonad = Writer Tags
07:03:52 <[exa]> amosbird: they're sending correct content-encoding: gzip, so it depends whether you can instruct curl to read and unzip that for you
07:06:05 <[exa]> slaterr: HtmlWriter explains what it does better, but anything goes
07:07:36 <slaterr> you're right
07:11:00 <[exa]> the biggest awful part of it will be the conversion of all your 'p' and 'div' to accept HtmlWriter and produce the same.. But it usually looks pretty nice in types and you can just follow them for implementation
07:11:04 <[exa]> like:
07:11:10 <[exa]> text :: String -> HtmlWriter()
07:11:32 <slaterr> yes, that's what I'm trying to do now
07:11:35 <[exa]> div :: HtmlWriter a -> HtmlWriter a
07:12:40 <[exa]> thinking about what would be the the most reasonable name for the runWriter wrapper... perhaps writeHtml?
07:13:21 <slaterr> is a necessary there? I thought I'd have div :: HtmlWriter () -> HtmlWriter ()
07:13:38 * hackage hsdev 0.3.3.1 - Haskell development library  https://hackage.haskell.org/package/hsdev-0.3.3.1 (AlexandrRuchkin)
07:14:28 <hpc> either works
07:14:48 <[exa]> passing the value through is sometimes handy and the implementations will basically be same
07:16:37 * hackage zeromq4-haskell 0.8.0 - Bindings to ZeroMQ 4.x  https://hackage.haskell.org/package/zeromq4-haskell-0.8.0 (ToralfWittner)
07:17:15 <amosbird> hmmmmmmm
07:17:22 <amosbird> cabal is not official?
07:17:50 <amosbird> can I build this project using stack ?
07:17:52 <amosbird> https://github.com/jtdaugherty/tart
07:19:56 <hpc> cabal is maintained by haskell.org, so if that's not official i don't know what is
07:20:59 <amosbird> how can I install cabal using ghc?
07:21:14 <amosbird> there is a command          $local_bin/stack --install-ghc setup   
07:21:22 <amosbird> I'm not sure what does it do
07:21:30 <phadej> https://www.haskell.org/cabal/download.html
07:21:35 <hpc> https://www.haskell.org/cabal/
07:21:44 <phadej> download it, don't build yourself (waste of time)
07:23:09 <hpc> fwiw as well, stack is maintained by a commercial company that attempted a hostile takeover of haskell.org a few years back by copying its theme and hosting a deceptive site at haskell-lang.org
07:23:16 <hpc> so you should avoid becoming dependent on it
07:23:54 <amosbird> https://la.wentropy.com/pR27
07:23:56 <amosbird> ............
07:24:47 <amosbird> is there a fix for this?
07:25:02 <hpc> don't install it with stack
07:25:09 <hpc> follow the official install directions
07:25:47 <slaterr> works :P
07:26:20 <slaterr> putStr $ render $ execHtml (html (body [] $ do p (text "first"); p (text "second")))
07:26:25 <amosbird> hpc: well...
07:26:30 <amosbird> I need to use asdf..
07:26:47 <slaterr> gives me <html><body><p>first</p><p>second</p></body></html>
07:27:57 <slaterr> [exa] thanks for setting me on the right track! I was going insane trying to figure this out.
07:30:18 <kosmikus> fwiw, I don't think there's any problem in building tart with stack. doesn't "stack init && stack build" work?
07:30:22 <slaterr> tagValue :: [Tag] <- would tagChildren be a better name?
07:30:55 <amosbird> gee
07:31:06 <amosbird> this is the first time that rm fixes things
07:32:37 * hackage glabrous 2.0.0 - A template DSL library  https://hackage.haskell.org/package/glabrous-2.0.0 (MichelBoucey)
07:34:33 <amosbird> is haskell the fastest fp language?
07:34:46 <amosbird> I see a lot of profilers
07:35:01 <amosbird> which only makes sense that performance is a main goal?
07:36:24 <slaterr> I like how clean it looks with BlockArguments extension.  https://bpaste.net/show/ed1b7f561dca
07:41:47 <yatuway[m]> amosbird: Maybe it depends on implementation
07:41:48 <yatuway[m]> https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/ocaml-ghc.html
07:42:43 <amosbird> hm, Warning: The update command is a part of the legacy v1 style of cabal usage.
07:44:50 <geekosaur> v1-update
07:51:05 <amosbird> https://la.wentropy.com/sMQH
07:51:22 <amosbird> does that mean I have a newer version of haskell and that package cannot be installed anymore?
08:02:37 * hackage error-codes 0.1.0.0 - Error code functions  https://hackage.haskell.org/package/error-codes-0.1.0.0 (andrewthad)
08:11:56 <oo_miguel> I just discovered the BangPatterns and wonder if "foo !n = sum n" is equivalent to "foo n = n `seq` sum n" ?
08:12:37 <oo_miguel> eh, guess it is not
08:12:42 <slaterr> it isn't?
08:12:52 <oo_miguel> yeah, sorry. just realized it is NOT
08:12:58 <slaterr> what's the difference?
08:13:33 <oo_miguel> in the first case n is evaluted to WHNF . heh
08:13:39 <oo_miguel> and in the second case too
08:13:41 <oo_miguel> ah
08:14:28 --- mode: glguy set -vv nivpgir36 sariyar_
08:14:44 <oo_miguel> and sum is _NOT_ strictly evaluated right? so they are equivalent indeed
08:14:46 <oo_miguel> right?
08:15:52 <Solonarv> strictness of sum depends on the Foldable and Num instances involved
08:16:04 <slaterr> my understanding is that the two are completely the same
08:16:05 <oo_miguel> I also always get confused with seq, and wonder why I never encounter experssions like "x`seq`x"
08:16:42 <oo_miguel> slaterr: yeah, sorry (once again). my initial assumption seems correct and matches your understanding
08:17:14 <Solonarv> well, seq's special property is as follows: seq a b = b, but whenever seq a b is in WHNF, a and b are both in WHNF
08:17:42 <oo_miguel> Solonarv: Let's replace "sum" with some arbitrary non-strict function (I thought sum is non-strict, per definition)
08:17:57 <Solonarv> applying this to seq x x: the value of that expression is x, and when it's in WHNF then x is also in WHNF... of course it is, because that expression's value is x !
08:18:19 <Solonarv> yes, bang patterns are equivalent to seq calls IIRC
08:18:32 <hpc> @src seq
08:18:33 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
08:18:39 <hpc> aw :P
08:18:40 <Solonarv> i.e. 'f !n = body' is the same as 'f n = n `seq` body'
08:19:37 <siers> https://clbin.com/bomNS how could I turn [(a, IO (Maybe b))] into IO [Maybe (a, b)]? I can do it with mapM and fmap in two gos with _2, but can I do it in a single go?
08:20:20 <phadej> Solonarv: the order is trickier, e.g. f !acc [] = acc
08:20:38 <phadej> f acc xs = acc  `seq` case xs of [] -> ...
08:21:07 <Solonarv> oh, I see
08:21:26 <oo_miguel> Solonarv: ah right. makes perfect sense. I like you explanation of seq's 'special/magic' property. 
08:22:02 <oo_miguel> I was not sure what "it is strict in its frist argument" I encountered beofre, meant
08:22:25 <oo_miguel> but I understand this is equivalent with your definition/explanation
08:23:02 <oo_miguel> bringing (seq a b) to WHNF forces a and b to WHNF
08:23:19 <oo_miguel> or at least
08:23:21 <oo_miguel> a
08:23:28 <phadej> b too
08:23:37 <Solonarv> well, b too, because that's the value of seq a b
08:23:49 <oo_miguel> aaah, right! 
08:23:57 <oo_miguel> obvious ;)
08:24:08 <oo_miguel> Solonarv: phadej: thanks a lot
08:40:05 <PapaDinkle> hi guys 
08:40:24 <PapaDinkle> i am pretty new to functional programming and i want to implement a heap 
08:40:33 <PapaDinkle> i am wondering how i would do that conceptually in a language like haskell
08:40:52 <PapaDinkle> heap data structure
08:41:54 <hpc> fundamentally, a heap is a tree with some properties
08:42:11 <hpc> so i'd start by writing a tree shaped like what a heap is shaped like
08:42:25 <hpc> and then write your operations on that tree so they adhere to the properties
08:42:52 <PapaDinkle> true. complete binary tree with the parent-child relationship intact
08:43:15 <PapaDinkle> so, am i right in saying that i would need to recreate the entire tree anytime i wanted to modify the tree?
08:43:46 <hpc> you'd only be recreating the parts of the tree that change
08:44:01 <PapaDinkle> hmm ok 
08:44:10 <PapaDinkle> so if a sub-tree needed to be modified i would only be modifying that sub-tree
08:44:15 <hpc> so like if you add a new root to the tree, you're basically just doing one cons-like operation
08:44:22 <hpc> and the entire subtree is unmodified and reused
08:44:27 <edmundnoble> Maybe start with linked lists, yeah, consider how much you need to copy if you change the first element of a list
08:44:54 <hpc> if you modify something deep in the tree, every node from that element up to the root needs to be modified
08:45:05 <hpc> but the other subtrees hanging off those nodes are unchanged
08:45:17 <hpc> so modifying a deep element is a log n operation
08:46:54 <PapaDinkle> i am really glad this channel exists... i am probably going to be coming back here a lot. i love haskell but nobody i knows teaches/uses it!
08:47:03 <PapaDinkle> thanks for advice
08:48:51 <[exa]> slaterr: sorry I was afk, great it worked!
08:53:01 <PapaDinkle> have a good'n 
09:04:59 <zincy> Will going to do a MSc in Comp Sci (no previous technical degrees) make me a better programmer?
09:05:56 <merijn> zincy: Depends on the kind of programming and where you do the degree :)
09:05:58 <__monty__> zincy: It obviously will. That's not to say it's the most efficient way of becoming a better programmer : )
09:06:32 <zincy> Exactly I am not sure if its the most efficient vs self teaching the theory
09:07:03 <zincy> merijn: Was looking at Nottingham uni in the UK. They have quite the FP speciality it seems which interests me.
09:07:20 <zincy> The problem is I have no idea what kind of programming I want to specialise in the future
09:08:18 <zincy> Im just thinking that the advantage over self teaching would at least be a piece of paper
09:09:29 <merijn> zincy: I learned a lot from my CS degree, including a bunch of knowledge I commonly find missing in self-taught programmers. Which is not to say you can't be a good self-taught programmer, but it's hard compared to a structured curriculum
09:10:24 <zincy> merijn: Did you find that the knowledge helped you in day to day programming?
09:10:44 <zincy> Im the classic self taught programmer with knowledge gaps
09:11:08 <[exa]> zincy: you will get a complete overview of what people have already done wrong, allowing you to not repeat much more mistakes. :D
09:11:52 <[exa]> zincy: but what merijn says is right; self-taught people sometimes have surprising gaps, esp. in the most important data structures and generally building blocks
09:11:59 <merijn> zincy: Yes, but it depends on the sorta programming you end up doing
09:12:27 <merijn> [exa]: tbh, I think the biggest gap amongst self-taught programmers is a lack of knowledge about modern computer architecture and OSes
09:12:50 <zincy> Problem is the basics of that aren't usually taught at postgraduate :/
09:12:58 <Chousuke> I think having a teacher always helps, but only if you actually utilize one properly.
09:13:16 <zincy> At least by starting at the deep end you are forced to learn the basics.
09:13:42 <Chousuke> I think going through an university education won't automatically help, but it will give you plenty of opportunities to learn more about what you don't know
09:14:30 <zincy> I am trying to do a breadth first search to see what kind of programming I want to specialise in
09:14:50 <zincy> So I was thinking a strong foundation would be a good idea regardless.
09:15:03 <Chousuke> If you're self-taught, it's usually tough to realize that you don't know something you probably should.
09:15:22 <zincy> Nottingham's course has a fair bit of Haskell and Agda on it.
09:15:38 <zincy> They have Graham Hutton working there so ...
09:17:01 <zincy> merijn: What is your plan for after studying?
09:17:09 <zincy> tell me if this is too off topic
09:17:26 <[exa]> zincy: tbh, specialization is a wasted effort in programming industry that completely changes every ~5 years
09:18:10 <[exa]> zincy: getting the foundations is something that saves you a _lot_ of learning later
09:18:25 <zincy> exa: Be a generalist but market yourself as a specialist is good advice
09:18:59 <zincy> I am trying to weigh up the pros of cons of self teaching vs uni.
09:19:09 <[exa]> zincy: I'm actually always surprised that tis exact approach works
09:19:11 <zincy> The only drawback I can think of uni is that it costs money
09:19:20 <zincy> but that is fine for me
09:19:22 <merijn> zincy: I've been done with studying for almost 8 years now :p
09:19:40 <zincy> merijn: so what do you do now?
09:19:53 <merijn> At least in the "student going to classes" sense
09:20:15 <Welkin> zincy: there is nothing to weigh. You don't go to uni to learn, you go to meet people and grow as a person
09:20:24 <merijn> Welkin: Well, also to learn :p
09:20:26 <Welkin> you can learn anything on your own with good books and talking to people
09:20:41 <Welkin> it's worth it
09:20:42 <merijn> Welkin: In theory yes, in practice that only works for a number of people
09:20:43 <Welkin> go to uni
09:21:01 <Welkin> but not necessarily "to learn"
09:21:18 <Welkin> meet lots of people and have fun, buikd relationships
09:21:33 <zincy> Yeah I could self teach but what is the advantage?
09:21:40 <Welkin> what?
09:21:47 <Welkin> I just told you you should go to uni
09:21:53 <Welkin> you will be self-teaching anyway
09:21:58 <Welkin> how do you think people learn?
09:21:59 <zincy> Yeah 
09:22:03 <merijn> zincy: I work in a research organisation that supports university researchers on computer/programming related research
09:22:05 <Welkin> they don't spoon feed you the information
09:22:09 <Welkin> you don't gain it through osmosis
09:22:22 <zincy> I agree 
09:22:22 <Welkin> you have to do the work yourself
09:22:32 <Welkin> so studying in uni or on your own makes no difference
09:22:37 <merijn> zincy: my current projects involve working on climate/ocean modeling and doing FPGA stuff for radio astronomy
09:22:54 <zincy> ah interesting
09:23:07 <[exa]> zincy: self-teaching is good for problem solving; but seriously you won't be able to press yourself into learning the whole enumerability theory alone
09:23:34 <isaac_clarke> hey does anyone here know how to set editMode: Vi with haskeline?
09:23:46 <isaac_clarke> I'd like vi bindings in ghci, but I can't firgure it out
09:23:49 <zincy> Could just spend the uni fees on 1 to 1 tutoring with an expert.
09:23:54 <zincy> haha
09:23:55 <isaac_clarke> is it as simple as touching a ~/.haskeline file?
09:24:08 <isaac_clarke> or do i need a `stack install haskeline`?
09:24:10 <Welkin> zincy: like I said, uni is not about learning, it's about community
09:24:16 <Welkin> that's an important point I think most people miss
09:24:37 <Welkin> only you can learn, no one else can make you learn
09:24:38 <[exa]> zincy: in other words, 1 to 1 tutoring with an expert doesn't make a party of that magnitude
09:24:56 <Welkin> learning is something you do your whole life
09:25:02 <Welkin> it's not something you do for 4 years and then stop
09:25:17 <isaac_clarke> haskeline?
09:28:37 <geekosaur> isaac_clarke, it's already installed sufficiently if you have ghci
09:28:54 <isaac_clarke> so I'm trying to get vi bindings
09:29:06 <isaac_clarke> and i saw a stackoverflow saying the settings are in ~/.haskeline
09:29:08 <geekosaur> it should be enough to add that line to ~/.haskeline per https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#the-haskeline-file
09:29:23 <isaac_clarke> ok cool, so I can just touch a ~/.haskeline?
09:29:24 <[exa]> isaac_clarke: just setting editMode=Vi in .haskeline should certainly work
09:29:28 <isaac_clarke> i dont have one currently
09:29:30 <geekosaur> and specifically https://github.com/judah/haskeline/wiki/UserPreferences
09:29:33 <[exa]> create one?
09:29:39 <isaac_clarke> ok awesome thanks friends
09:30:35 <isaac_clarke> any idea what menuCompletion does?
09:36:45 <[exa]> isaac_clarke: you will probably have to try it
09:37:22 <isaac_clarke> yea vi mode is great
09:37:25 <isaac_clarke> no delay at all
09:37:27 <isaac_clarke> v fast
09:37:40 <isaac_clarke> can ghci do breakpoints?
09:37:42 <isaac_clarke> debugging?
09:37:46 <Welkin> yes
09:38:21 <Welkin> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#ghci-debugger
09:38:37 <isaac_clarke> nice
09:39:15 <isaac_clarke> kinda looks like gdb
09:57:18 <Welkin> is there an easy way to profile (i.e. runtime, allocations, memory use) without recompiling everything with profiling turned on?
09:57:54 <Welkin> like in ghci you can :set +s
10:08:35 <c_wraith> Welkin: as long as you compiled with rts options enabled, there's at least a couple options available. 
10:10:31 <c_wraith> Welkin: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html#rts-options-for-profiling and https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html#rts-options-to-produce-runtime-statistics
10:12:08 * hackage hpack-dhall 0.5.2 - hpack's dhalling  https://hackage.haskell.org/package/hpack-dhall-0.5.2 (philderbeast)
10:22:38 <zincy> Is type level programming only possible in dependently typed languages?
10:22:44 <c_wraith> No
10:22:58 <c_wraith> You only need dependent types if you want your type-level programs to depend on values as well as types
10:23:07 <zincy> Is type level programming just running computations at compile time?
10:23:20 <c_wraith> By definition, yes.
10:23:50 <zincy> can you ever get side effects at compile time?
10:23:53 <zincy> :P
10:23:57 <c_wraith> At least in a language that erases types at runtime, like Haskell.  Not all languages erase types
10:24:01 <cocreature> sure you can with TH
10:24:20 <mniip> haskell doesn't erase contexts though
10:24:20 <c_wraith> Usually type-level programming isn't about getting output.  It's about calculating more precise types.
10:24:26 <mniip> whcih are a byproduct of type level programming
10:24:28 <Solonarv> Haskell also lets you retain type info at runtime with Typeable / TypeRep / GADTs
10:24:31 <zincy> So could I read a file and which has an int, parse it and then construct a type which bounds a vector by said int?
10:24:43 <Solonarv> yes, but you'd have to use template haskell
10:24:54 <mniip> yes but you will be judged
10:24:59 <zincy> That is some crazy advanced stuff
10:25:41 <zincy> Is template haskell just like lisp macros?
10:25:44 <Welkin> no
10:25:47 <Welkin> it's worse
10:25:53 <c_wraith> The basics of type-level programming aren't that advanced.
10:26:21 <zincy> So what is considered advanced?
10:26:24 <zincy> Laziness?
10:26:27 <c_wraith> things like singletons
10:26:33 <zincy> What re they?
10:26:36 <mniip> pff
10:26:41 <c_wraith> which let you fake dependent typing with GADTs
10:26:52 <c_wraith> (and classes, and other stuff)
10:27:01 <mniip> and some questionable type families
10:27:11 <geekosaur> tangling them all together and trying to trace the result :p
10:27:29 <c_wraith> yeah, no one part of singletons are complex.  it's the whole combined thing that makes me go "what?"
10:27:42 <geekosaur> (conceptually, not e.g. Debug.Trace)
10:28:32 <zincy> So are the basics of type programming DataKinds and TypeFamilies?
10:28:48 <zincy> Would those extensions give you most of the tour?
10:28:50 <mniip> imo the only worthwhile thing singletons puts on the table is tangible apartness constraints
10:28:56 <mniip> which makes (~) more boolean
10:29:08 <c_wraith> zincy: DataKinds isn't even necessary
10:29:14 <zincy> What are tangible apartness constraints?
10:29:16 <c_wraith> zincy: GADTs and TypeFamilies
10:29:38 <Solonarv> zincy: constraints that let you say "these two types are definitely 100% not the same"
10:29:55 <mniip> if you have   type family x == y where x == x = True; x == y = False
10:29:55 <Solonarv> (which you can't to with ~)
10:30:00 <zincy> Why would you want to do that?
10:30:09 <mniip> there isn't a thing you can say to convince the compiler that (x == y ~ False)
10:30:17 <mniip> other than providing concrete (enough) instantiations of x and y
10:30:22 <zincy> Ah right
10:30:31 <Welkin> for dependent types look at idris and agda
10:30:40 <mniip> singletons has a mechanism for this
10:30:45 <mniip> the "If" type family
10:30:49 <mniip> I forget the exact name
10:31:07 <mniip> to implement it you of course need unsafeCoerce
10:38:18 <fendor> how can I get the `TyCon` from a `Name` using the ghc library?
10:40:27 <c_wraith> zincy: for reference, https://gist.github.com/chowells79/13a3349f94dcdac1d8648762b0935643 is just about the simplest possible use of type-level programming
10:42:00 <Welkin> really, the vector length example
10:42:01 <Welkin> haha
10:42:10 <Welkin> what about type-level strings and heterogeneous lists?
10:42:15 <c_wraith> way more complicated.
10:42:19 <c_wraith> I said *simplest*
10:42:24 <Solonarv> you can make this a little nicer by enabling DataKinds and replacing 'Z' and 'S' with 'data N = Z | S N'
10:42:32 <c_wraith> Solonarv: more complex
10:42:41 <Solonarv> oh yes, I know that
10:42:53 <c_wraith> I'm trying to demonstrate how little is required for something to be type-level programming
10:43:01 <c_wraith> and that you don't need to get hung up in complex stuff
10:44:27 <Solonarv> I pointed out this improvement because it's still fairly simple, and stops you from writing silly things like 'Vec (IO Bool) Foo'
10:44:40 <Welkin> I never really learned type families
10:44:43 <Welkin> or data families
10:45:02 <c_wraith> Solonarv: There's no constructor that gives you that type anyway.  So while you can write the type, you can't have usable values of the type.
10:45:15 <Solonarv> True.
10:45:38 <Solonarv> ...but it also makes for a simple example of DataKinds ;)
10:45:59 <fendor> nvm, i think i got it
10:46:13 <Welkin> will haskell get dependent types like idris?
10:46:22 <Welkin> and do away with the singleton mess?
10:46:35 <Solonarv> it's certainly planned
10:46:42 <c_wraith> I doubt Haskell will ever add a termination checker
10:46:46 <c_wraith> So it won't be like Idris
10:46:57 <MarcelineVQ> to a degree, there won't be totality unless you implement it yourself as a restriction of your own dsl
10:47:11 <Solonarv> yeah, a termination checker *isn't* part of the dependent haskell plan AFAIK
10:48:05 <Welkin> of course there is still the issue of types and values living in different namespaces
10:48:46 <Solonarv> that's probably just going to sort of stick around, too much breakage to merge the namespaces
10:49:23 <Welkin> so we're stuck with ticks (') everywhere?
10:49:54 <Solonarv> I think the goal is that you'll be able to leave out the ticks when the identifier is unambiguous
10:50:00 <Solonarv> (which is how DataKinds already work)
11:13:45 <delYsid> Gurkenglas: https://github.com/mlang/mcp
11:33:07 * hackage pandoc 2.7 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-2.7 (JohnMacFarlane)
11:48:37 * hackage sgd 0.5.0.0 - Stochastic gradient descent  https://hackage.haskell.org/package/sgd-0.5.0.0 (JakubWaszczuk)
12:07:28 <EvanR> 2019: i doubt haskell will ever have a termination checker
12:07:43 <EvanR> 2013: i doubt haskell will ever have dependent types
12:08:10 <Solonarv> hey, liquid haskell includes a termination checker :>
12:09:06 <monochrom> 2000: I doubt haskell will ever solve P vs NP.
12:09:15 <Solonarv> I can imagine a termination checker that doesn't reject nonterminating programs, and is instead used to notice when proof terms can be erased
12:10:56 <monochrom> Also:
12:11:02 <hpc> 1640: I doubt haskell will ever be a four function calculator
12:11:33 <monochrom> 2025: I doubt haskell will ever have native dependent types as opposed to the current encoding of dependent types.
12:12:29 <MarcelineVQ> 2030: The robots are winning, we should have known what we did was wrong, it's our fault, it was always going to be our fault. mo-
12:12:34 <monochrom> Oh heh let's go back further!
12:12:35 <hpc> feature request: in 2098, publish a haskell standard that's still named haskell 98
12:12:48 <monochrom> 1500 BC: I doubt haskell will suppose any base other than 60.
12:13:07 <monochrom> 2000 BC: I doubt haskell will ever be.
12:13:13 <monochrom> s/suppose/support/
12:14:18 <hpc> 6M BC: I doubt dino-haskell will ever have dependent types
12:21:36 <fresheyeball> hey out there
12:21:49 <fresheyeball> I need to render the following in a hakyll site
12:21:52 <fresheyeball> \$HOME
12:22:02 <fresheyeball> if I write 
12:22:22 <fresheyeball> \$$HOME 
12:22:25 <fresheyeball> I just get
12:22:27 <fresheyeball> \
12:22:30 <fresheyeball> I I write
12:22:32 <fresheyeball> if I write
12:22:36 <fresheyeball> \ $$HOME
12:22:38 <fresheyeball> I get 
12:22:40 <fresheyeball> \ $HOME 
12:22:44 <fresheyeball> as expected
12:22:50 <fresheyeball> is it posslbe to render out
12:22:53 <fresheyeball> \$HOME ?
12:23:05 <[exa]> what about \\$$HOME ?
12:23:09 <[exa]> (just guessing)
12:23:34 <fresheyeball> [exa]: I get
12:23:37 <fresheyeball> \\$HOME
12:24:12 <[exa]> so the logical choice now would be \$$$HOME?
12:24:23 <hpc> or $\$$HOME
12:24:32 <[exa]> $ is an escape char?
12:24:45 <fresheyeball> exa it is a variable signifier for the template
12:24:53 <fresheyeball> the docs say to escape a dollar with $$
12:27:13 <[exa]> that way I'd expect your try with \$$HOME to work right.
12:36:54 <fen> how does this work? http://hackage.haskell.org/package/conduit-1.3.1/docs/Data-Conduit-Internal-Fusion.html#t:Stream
12:37:10 <sternmull> what is a good way to discard the result of a monadic action that i want to use with "when" or "unless"? They expect m () as result and doing "unless foo $ bar >> return ()" looks stupid.
12:37:32 <Cale> fen: http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.104.7401
12:37:54 <marvin2> sternmull, void
12:37:57 <marvin2> :t void
12:37:58 <lambdabot> Functor f => f a -> f ()
12:38:13 <sternmull> thanks!
12:38:22 <monochrom> It is possible that "void bar" looks stupid too.
12:39:08 <sternmull> i which "when" and "unless" would discard the result on their own.
12:39:15 <monochrom> Yeah.
12:39:18 <fen> Cale: its not just build fold fusion like; https://gist.github.com/fen-hs/a71ab735bf977d9b948a62416662fe57#file-church_i-hs-L27
12:39:46 <fen> wondering what the `m' was for in Stream (s -> m (Step s o r)) (m s)	
12:40:59 <fen> basically, not sure about trying to make monad transformers for this library
12:41:01 <Cale> Well, that would be because ConduitT is a monad transformer, so there are interleaved m-actions to deal with
12:41:30 <Cale> The paper I linked doesn't quite go that far, but it should be a reasonably straightforward extension
12:41:52 <fen> would a fairly low level library then have to give similar monad transformers if other libs such as conduit could be able to use it?
12:42:25 <Cale> hard to say?
12:42:38 <Cale> Depends on what the library is doing and what "use it" means
12:43:14 <fen> well it seems like it might make a competing scenario where there isnt a standard at the lowest level...
12:43:32 <Cale> I'm not sure what we're talking about here
12:43:40 <monochrom> "ListT m" also allows (and anticipates) interleaved m-actions.
12:43:44 <fen> unless such a library would at least manage to offer everything conduit streamsdoes
12:44:46 <Cale> You might also be interested in looking at pipes
12:44:51 <fen> that too
12:44:59 <fen> there are a few approaches to streams
12:45:00 <Cale> there's also machines :D
12:45:35 <fen> they had strange combinators iirc
12:46:01 <fen> but this is just a linear containers library
12:46:16 <fen> which is why conduit streams seemed relevant 
12:46:49 <fen> a good way to test if the functionality offered is sufficient to build conduit on top of
12:46:49 <Cale> The conduit streams thing is specifically for stream fusion
12:46:58 <fen> so are these
12:47:05 <Cale> It's not required for conduit itself, just an optimisation
12:47:08 <fen> and they use the same kind of unfolding
12:47:11 <EvanR> linear containers?
12:47:48 <fen> which the library also offers for nonempty-like and shaped containers with empty
12:48:01 <roads1010> hello, I am trying to use the threepenny gui, and I'm stuck.
12:48:10 <fen> EvanR: https://gist.github.com/fen-hs/9772c2ce27a355984add2e5b7d352fbb
12:48:31 <hpc> roads1010: you need more pennies - microtransactions have really gotten out of hand :P
12:48:35 <roads1010> i want to use a simple timer to display the tick time on a canvas and I can't seem to figure out how to do it
12:48:45 <roads1010> haha
12:49:09 <chickendan> Hello, everyone! Quick newbie question: I'm trying to read signed numbers from a file, but it seems to be choking on the plus signs: `map read ["+1", "-2", "+3"] :: [Int]`. How do I handle this?
12:49:34 <roads1010> I am following the threepenny example here: https://github.com/HeinrichApfelmus/threepenny-gui/blob/master/samples/DrumMachine.hs
12:49:39 <fresheyeball> chickendan: I would remove the plus signs
12:49:52 <fen> there are naming conflicts with conduit, so there would be qualified imports, but maybe can consider refactoring a branch of conduit built over these first in first out containers
12:50:00 <roads1010> and in that threepenny example, on line 46 they create a timer,
12:50:15 <fresheyeball> chickendan: map (read . removePlus) ["+1", "-2"]
12:50:42 <roads1010> but they don't just use the timer, they create some kind of FRP-like stream (which I don't want to do if I don't have to)
12:50:56 <fen> maybe the extension to monad transformers is enough, maybe there is more to it...
12:50:57 <EvanR> you could also put an optional plus combinator first, but it would result in allowing +-2
12:51:06 <fen> thats the question
12:51:31 <roads1010> on line 47.  I want to use the timer more like they do with the keydown event on line 56
12:51:54 <fendor> with the ghc lib, how can I convert a `Type` to a `Name` such that I can find the `srcSpan`?
12:52:25 <chickendan> fresheyeball: alright, fresheyeball, not quite as elegant as I hoped but I will try that. Thank you. :)
12:52:37 <fresheyeball> chickendan: what had you hoped?
12:52:56 <[exa]> Anyway, question about comonoids. Monoids have mempty :: a; mappend :: a->a->a; I've seen some code where Comonoids have comappend::a->(a,a); comempty::a->(). Are there any better names for comappend and comempty? Also, would there be any existing (possibly linearity-inspired) names for the 'orthogonal' classes with {mappend,comempty} and {comappend,mempty} ?
12:53:05 <chickendan> Coming from scheme and lisp I thought a simple read wrapper would do.
12:53:18 <fendor> with `getName` *facepalm*
12:54:26 <EvanR> read as a serious parser? eh?
12:54:28 <Cale> [exa]: Well, they're called the comultiplication and counit in mathematics. Comonoids aren't usually all that interesting in the category of sets (or Haskell types) though, so I'd be curious where they're coming up.
12:54:44 <fen> exa: comappend is sometimes called split, and comempty is destroy
12:54:59 <monochrom> [exa]: I may like to say "split :: a -> (a,a)"
12:55:04 <EvanR> copy and destroy?
12:55:10 <[exa]> yeah that's from linearity
12:55:25 <fen> its unusual to have a default for split
12:55:30 <Cale> The counit might as well not be there, because it's effectively unique
12:55:42 <fen> there are normally many choices
12:55:42 <monochrom> I would keep "coempty" as "coempty" because it is degenerate anyway.
12:56:08 <monochrom> err, comempty!
12:56:12 <fen> consider 1+1 = 2, you can "split" 2 = a + b into many things
12:56:36 <fen> cryptography is based on this
12:56:36 <[exa]> Cale: mathematically unique, yes. I was planning to add some monads there
12:56:40 <Cale> note that your split has to be coassociative though
12:56:54 <monochrom> There are also a ton of other things also called "counit", so it is pretty bland after a while. Comonad has a counit :: m a -> a
12:57:10 <fen> :t extract
12:57:12 <lambdabot> error: Variable not in scope: extract
12:57:15 <fen> % :t extract
12:57:15 <yahb> fen: Comonad w => w a -> a
12:57:16 <[exa]> comultiplication sounds good
12:57:42 <hpc> it could be called copure, or impure
12:57:44 <fen> well * is even worse!
12:57:46 <hpc> ooh, it could be called "unsafe"
12:57:49 <Cale> let (u,y) = split x; (v,w) = split y in (u,v,w) needs to be the same as let (y,w) = split x; (u,v) = split y in (u,v,w)
12:57:56 <[exa]> fen: yeah comonad is the same thing with that 'a'
12:58:16 <reallymemorable> Does anyone know why my Quandl test call isn't working?  I tried even with the exact example in the Hackage docs and I still get `Nothing` back.  https://stackoverflow.com/questions/54964875/cant-understand-why-my-haskell-api-call-script-returns-nothing
12:58:16 <fen> at least there is (1,n-1) as a default for Sum.
12:58:29 <monochrom> The problem is that M a -> a is safe for a comonad M. So it is misleading to say "unsafe". But I'm open to "safeUnsafe". >:)
12:58:37 <Cale> There aren't many situations where that happens, apart from the diagonal map (\x -> (x,x))
12:58:49 <fen> actually, maybe \n -> (mempty,n) is the only real way to undo monoids mappend
12:59:09 <fen> which is not useful
13:00:02 <[exa]> Cale: anyway, I was surprised by how well the 4 functions describe various extensions of the usual drop/copy linearity. So I'm still just scanning for any extra ideas
13:00:24 <Cale> Yeah, in a linear setting, it's more interesting
13:00:42 <monochrom> Which are the other 2 functions?
13:00:43 <[exa]> Cale: the thing is that there are 2 ways to drop resources (one from monoid and other co-) and 2 corresponding ways to create them
13:00:53 <fen> Ints are like [()], and (():xs) <-> ([()],xs) is a kind of "decrement" split... like (1,n-1)
13:00:53 <monochrom> Oh, that.
13:01:52 <[exa]> and nothing serious yet, I'm trying to find a matching name for the 2 corresponding typeclasses that would be orthogonal to monoid/comonoid
13:02:26 <fen> what, swapping the functions?
13:02:44 <monochrom> BigBang and BigCrunch :)
13:03:05 <fen> mempty + split and destroy + mappend ... 
13:03:11 <fen> what are those for?
13:04:05 <monochrom> NeutronStar and Supernova
13:04:20 <fen> destroy is basically always available, so thats just comonoid + default and semigroup
13:04:34 <[exa]> Cale: in particular, capturing the split operation in types is super useful if you have some kind of limited resource that you need to carefully divide
13:04:45 <fen> so the only thing interestingthenis comonoidDefault ?
13:05:27 <monochrom> Oh! Fusion and Fission!
13:05:50 <[exa]> I'm starting to see the potential energy of that
13:05:51 <[exa]> :D
13:05:55 <Cale> [exa]: except that coassociativity means it can't be limited
13:06:51 <[exa]> Cale: why not?
13:07:06 <[exa]> ooh get it
13:07:35 <[exa]> you can divide it forever, but you can nicely carry the information about how tiny the slice actually is
13:08:18 <Cale> Also, if you split something once, and then split either of the two "halves", it doesn't matter which half you split
13:08:30 <Cale> the sequence of three things you're left with have to be the same
13:09:19 <[exa]> oh that's interesting
13:09:40 <[exa]> hm, good point
13:10:25 <fen> not sure if build is redundant and should just have fold/unfold fusion...
13:10:43 <[exa]> doesn't that kindof imply that the original 'a' should also be the same?
13:11:00 <Cale> In Sets, it implies that the comultiplication is (\x -> (x,x))
13:11:10 <fen> oh so then its more like copy than split
13:11:15 <Cale> and I expect it implies the same about most ordinary type theories
13:11:31 <[exa]> so 'copy' will be a matching name
13:11:32 <Cale> It's only in stranger categories that you get interesting comonoids
13:11:42 <[exa]> any example?
13:12:53 <fen> cant think of anything that can be split and be the same as itself if its not copy
13:13:44 <fen> just have to relax coassociativity like relaxing associativity to get more general monoid
13:13:49 <Cale> With the category of algebras there are interesting ones...
13:14:27 <Cale> For example, if you have power series in a countably infinite number of indeterminates, you can partition the indeterminates into two infinite sets
13:14:49 <Cale> and get a map to the tensor product of that power series ring with itself
13:15:17 <fen> argh!
13:15:28 <nfd> is there any particularly nice way to store a type for a fixed point of the list combinator? i.e. values like [[[...[]...]]]
13:15:54 <nfd> i figure left-recursive types like that are a bad idea and i'll probably end up using some other structure to break it up
13:16:02 <[exa]> nfd: IIRC there's Mu type (or some of its relatives) that does that
13:16:10 <[exa]> (or is it Mu?)
13:16:19 <Cale> https://en.wikipedia.org/wiki/Coalgebra#Examples -- there are some more examples of coalgebras here
13:16:21 <nfd> i remember a Fix type
13:16:30 <[exa]> Cale: great, thanks a lot
13:17:15 <Cale> Basically, the fact that it's no longer pairs, but tensor products makes a big difference in the freedom you have
13:17:25 <nfd> [exa]: https://en.wikibooks.org/wiki/Haskell/Fix_and_recursion#Fix_as_a_data_type i suppose?
13:18:35 <fen> ah, that makes sense
13:18:41 <nfd> (i know this isn't exactly a practical question, ha)
13:18:46 <[exa]> nfd: yes that would be it. So it's Nu, 1 bit edit distance. :]
13:20:25 <nfd> started learning Parsec, and someone suggested I parse the Dyck language
13:20:37 <nfd> i thought it might be fun to actually model it as a nesting of lists
13:20:44 <fresheyeball> sclv: you around?
13:21:28 <nfd> it was pretty easy to parse it to ()
13:21:55 <[exa]> nfd: you can do that with the extension that allows forall in datatypes, but I can suggest parsing data to data, not data to types. :D
13:24:24 <nfd> Oh, yeah, I didn't want to pull a https://aphyr.com/posts/342-typing-the-technical-interview
13:25:24 <nfd> I'm pulling to data, but I wasn't sure how to get [], [[]], [[[][]]], etc. to be the same type
13:26:48 <nfd> if your solution to a problem involves busting out UndecidableInstances and isn't just to make yourself laugh a little/show off/whatever, it's probably worth carefully considering what you're doing again XD
13:29:47 <Solonarv> dangit ed, finish MoreDecidableInstances already! :P
13:30:11 <Solonarv> let me destructure a type-level list without having to take out the footgun
13:30:38 <[exa]> what's wrong with a bit of GADTs?
13:30:49 <hpc> they should split UndecidableInstances into TheseInstances and ThoseInstances
13:31:02 * [exa] adding footgun to the dictionary
13:32:36 <[exa]> Cale: anyway my favorite examples of undecidable stuff look like they should pass as well. Thanks again!
13:36:37 <Cale> nfd: UndecidableInstances isn't a problematic one
13:37:00 <Cale> nfd: It's more OverlappingInstances, and the ones that imply it which one should worry about.
13:37:35 <nfd> i'll be honest, i'm way less than a haskell type system/extension guru
13:37:41 <Cale> UndecidableInstances, you'll know if you got something wrong as soon as you try to compile and it takes forever :)
13:37:52 <Cale> (well, it runs out of steps)
13:38:17 <Cale> But usually it's totally harmless
13:38:35 <tswett[m]> I'm reading the manual for Agda. Because the best way to learn a programming language is to read through all of its features in alphabetical order. :D
13:38:40 <Cale> Unless you're actively trying to use it to do type-level computation or something
13:38:51 <Cale> tswett[m]: lol
13:38:56 <nfd> Cale: see also the link I pasted above
13:38:56 <nfd> hah
13:39:30 <tswett[m]> (Actually, it's because I'm already more or less familiar with Agda and I want to learn about all the features I don't already know about.)
13:46:38 * hackage these 0.8 - An either-or-both data type & a generalized 'zip with padding' typeclass  https://hackage.haskell.org/package/these-0.8 (phadej)
14:15:08 * hackage haskell-ci 0.2 - Cabal package script generator for Travis-CI  https://hackage.haskell.org/package/haskell-ci-0.2 (phadej)
14:17:08 * hackage postgresql-simple 0.6.1 - Mid-Level PostgreSQL client library  https://hackage.haskell.org/package/postgresql-simple-0.6.1 (phadej)
14:55:52 <Hi-Angel> How can I make this expression work: (++) $ show
14:56:28 <Hi-Angel> It's supposed to be a → String → String
14:57:17 <__monty__> Hi-Angel: Looks like you want (.), not ($).
14:57:38 <Hi-Angel> Oh, thank you!
15:01:42 <__monty__> Hi-Angel: (.) composes functions, it makes a function that applies one function to the result of another. That's subtly different from ($) which is *just* function application with a flipped associativity. The right associativity makes it look like applying a function after applying another function but really you're just applying a function to a value. Think of a $ b c as a (b c), which is equal to (a 
15:01:48 <__monty__> . b) c but not equivalent to (a . b)
15:07:01 <Hi-Angel> Well, thanks… Although I should say, I was still confused until I looked up in ghci the :t (.) and :t ($) 
15:07:27 <jackdk> I am getting a warning in my .cabal file at 0:0, "version with tags", but my version: field is set to `0.1.0.0`. What gives?
15:08:07 <monochrom> "0:0" sounds like first line first column.
15:36:34 <Arahael> What's the most popular web framework? I'm thinking yesod looks pretty good.
15:37:00 <dmwit> I've enjoyed snap. Others have told me scotty is nice, too.
15:38:57 <hpc> snap's pretty decent, but i like yesod's templating better
15:39:06 <hpc> shakespeare vs heist
15:39:16 <hpc> fortunately you can mix them
15:39:55 <Arahael> What's attracting me to Yesod, is warp.
15:40:04 <Arahael> But it seems yesod has so many other nice things.
15:41:49 <phadej> scotty runs on warp too
15:42:10 <hpc> i also don't like that yesod chose have is hackage docs just point to stackage
15:47:06 <Arahael> Yeah, it seems to be a contrast between "really really simple", and "all the bells and whistles".
15:47:29 <Arahael> yesod seems more appropriate for a larger scale website.  While scotty looks simpler and lower level.
15:47:58 <Arahael> The yesod book seems to suggest that yesod itself can effectively do the same as scotty though - effectively just warp itself.
16:07:27 <sclv> Arahael: it also depends what you want to do. e.g. if you want something that basically wraps a whole bunch of APIs in a safe way, and maybe interacts with purescript bindings for them, then servant is a good choice too (if with a lot of ramp-up to learn how it works)
16:08:35 <Arahael> Yeah, I'm not interested in a "lot of ramp-up". :(
16:10:02 <hpc> servant is for writing REST APIs, and has basically nothing to help you write html
16:12:14 <phadej> it's quite simple to start writing HTML with servant-lucid or servant-blaze
16:12:41 <hpc> ah, didn't know that was a thing
16:13:06 <Arahael> The way yesod lets you provide several different representations for your response is interesting, and veyr nifty.  It picks which representation is the one to use based on the requested content type.
16:13:14 <phadej> personally I found yesod requiring more "ramp up" than for servant
16:13:29 <Arahael> phadej: I've been reading the yesod book online.
16:13:30 <linarcx> Hi guys. Why prezto does not exists in 18.09 channel
16:13:32 <phadej> Arahael: that's one of ideas of  HTTP, "content negotation"
16:13:45 <phadej> negotiation
16:13:45 <Arahael> phadej: Right, except yesod seems to abstract it nicely.
16:14:19 <phadej> Arahael: I don't know, I won't be surprised if yesod allows (easily) only single content-type per route
16:14:33 <phadej> as said, I don't know yesod, I found it difficult
16:14:41 <phadej> some TH magic happens, and ...
16:14:53 <Arahael> You can definitely provide more than one content-type per route.
16:15:08 <phadej> servant OTOH uses "type-level magic", which is more explicit :)
16:15:10 <hpc> linarcx: you're referring to stack?
16:15:29 <Arahael> From memory, it was something like fooR = withSomething $ do htmlVersion; jsonVersion
16:15:43 <Arahael> And withSomething will magically pick the html or json version as required.
16:16:26 <phadej> in servant you don't need "withSomething", it does it for you
16:16:52 <phadej> given your route "value" can be rendered as JSON, and as HTML
16:17:20 <Arahael> Yeah - servant probably separates the view from the route rendering.
16:17:35 <Arahael> (Which is probablyb etter)
16:26:32 <oo_miguel> should compiling my programm with -threaded and running with +RTS -N8 not already let haskell utlize smp?
16:26:58 <oo_miguel> yet my programm still occupies only one single core
16:27:27 <ClaudiusMaximus> do you use any concurrency or parallelism constructs?  (it's not automagic)
16:28:00 <oo_miguel> ClaudiusMaximus: oh, I thought/remembered there is some automagic invovled
16:28:25 <ClaudiusMaximus> there is parallel GC, but in my experience it isn't that great, especially with high -N
16:29:40 <oo_miguel> in my case it is not great at all, since all cores, but one are idle ;). Guess I have a look at Control.Parallel maybe
16:29:48 <oo_miguel> thanks
16:30:30 <oo_miguel> (for now I am only intereseted in parallelizing non-io computations)
16:32:22 <Arahael> Processor affinity complicates this as well, iirc.
16:33:35 <MarcelineVQ> there is no automatic parallelism of your haskell code, you have to ask for it, https://www.oreilly.com/library/view/parallel-and-concurrent/9781449335939/pt01.html
16:36:47 <oo_miguel> yeah, just realized I need at least par/pseq. thank you
16:42:29 <roads1010> hello, I've got a question.  I'm trying to follow an opengl GLFW example where I have a function of type keyPressed :: GLFW.KeyCallback
16:43:12 <roads1010> where GLFW.KeyCallback is of type type KeyCallback = Window -> Key -> Int -> KeyState -> ModifierKeys -> IO () 
16:43:51 <roads1010> but I would like to add another argument to the beginning of keyPressed so that I can curry it
16:44:13 <roads1010> but when I tried
16:44:15 <roads1010> keyPressed :: MS.MVar Integer -> GLFW.KeyCallback
16:44:47 <roads1010> it is clearly not the right type.  Is there a way to add an additional argument to a function that is defined by a "type" definition?
16:45:40 <roads1010> basically I'm trying to add an MVar to keyPressed so that it can set it to a value when the ESC key is pressed.  The main thread is waiting on this MVar and will exit nicely once the MVar is set.
16:54:26 <lyxia> 2
16:54:30 <lyxia> oops
16:55:52 <MarcelineVQ> how dare you
16:57:21 <monochrom> Base 2 is the smallest natural-number base that admits log-space representations of natural numbers.
16:59:27 <hpc> https://youtu.be/2IPAOxrH7Ro?t=158
17:01:30 <monochrom> "director of photography Patrick Stewart"??!!
17:02:11 <monochrom> "Captain, the camera is ready, the film is rolling."  "Engage!"
17:02:36 <MarcelineVQ> patrick stewart likes cars not lights :>
17:02:44 <hpc> no way, i never noticed that
17:02:54 <tswett[m]> 2 is a pretty important number. It's the smallest natural number that isn't its own square.
17:05:51 <isaac_clarke> is there a techinical name/term for "<-"
17:05:55 <isaac_clarke> inside a do notation?
17:06:17 <monochrom> I use "gets".
17:06:17 <Solonarv> 'bind' ?
17:06:49 <isaac_clarke> so i would say `x <- func b` as "x gets func b"?
17:07:01 <monochrom> Yes.
17:07:23 <shachaf> I wonder what's going on with that extension that would let you write it as "let x = (<- func b)".
17:08:42 <monochrom> That conflicts with "let" being a let-rec.  Either that, or it would require MonadFix.
17:09:28 <monochrom> Or change "let" inside a do-block to be like Racket's let* or something.
17:09:39 <monochrom> Err, Scheme!
17:09:40 <shachaf> Well, more generally with allowing expressions to use (<- e)
17:10:01 <shachaf> You could forbid it in the case of recursion, or use MonadFix.
17:11:03 <Axman6> roads1010: that looks fine to me, what's not working?
17:11:49 <Axman6> isaac_clarke: "drawn from" isn't a terrible way to read it
17:12:38 <hpc> perhaps "is the result of"
17:12:45 <Solonarv> hpc++
17:12:50 <Solonarv> that's how I read it when I have to
17:13:06 <Solonarv> (which is not often :p)
17:13:13 <hpc> same... ish
17:13:28 <hpc> i think of it more in (>>=) order
17:13:47 <hpc> "read a line from stdin, the result is blahblah, do stuff with blahblah"
17:13:47 <jmcarthur> monochrom, hpc: I'm thinking it's probably https://www.imdb.com/name/nm0829716/ rather than the Patrick Stewart we
17:13:50 <jmcarthur> 're thinking of
17:14:18 <hpc> jmcarthur: that's obviously a wig
17:15:32 <hpc> Solonarv: now that i think about it, that way of phrasing it separates the side effects from the result rather nicely
17:16:07 <roads1010> axman6: I think you're right... it turns out I wasn't naming the variable in my function definition and the compiler was complaining about that.  I misread that error and assumed I was doing something wrong...  thanks...
17:18:07 * hackage kafka-device 1.0.2.1 - UI device events via a Kafka message broker  https://hackage.haskell.org/package/kafka-device-1.0.2.1 (BrianBush)
17:20:40 * hackage kafka-device-glut 1.0.2.1 - GLUT events via a Kafka message broker  https://hackage.haskell.org/package/kafka-device-glut-1.0.2.1 (BrianBush)
17:21:38 * hackage kafka-device-joystick 1.0.2.1 - Linux joystick events via a Kafka message broker  https://hackage.haskell.org/package/kafka-device-joystick-1.0.2.1 (BrianBush)
17:22:38 * hackage kafka-device-leap 1.0.2.1 - Leap Motion events via a Kafka message broker  https://hackage.haskell.org/package/kafka-device-leap-1.0.2.1 (BrianBush)
17:23:38 * hackage kafka-device-spacenav 1.0.2.1 - Linux SpaceNavigator events via a Kafka message broker  https://hackage.haskell.org/package/kafka-device-spacenav-1.0.2.1 (BrianBush)
17:24:38 * hackage kafka-device-vrpn 1.0.2.1 - VRPN events via a Kafka message broker  https://hackage.haskell.org/package/kafka-device-vrpn-1.0.2.1 (BrianBush)
17:25:51 <Solonarv> woof, that hackage spam
17:28:08 * hackage net-mqtt 0.2.4.1 - An MQTT Protocol Implementation.  https://hackage.haskell.org/package/net-mqtt-0.2.4.1 (dustin)
17:28:33 * dsal is doing his part
17:29:06 <MarcelineVQ> service guarantees citizenship
17:32:20 <jackdk> I'd like to know more.
17:32:48 <Solonarv> about?
17:33:29 <jackdk> nm, it's the other half of the starship troopers reference
17:33:41 <Solonarv> oh :D
17:35:07 * hackage riak-protobuf 0.24.0.0 - Haskell types for the Riak protocol buffer API  https://hackage.haskell.org/package/riak-protobuf-0.24.0.0 (lambda_foo)
18:01:07 * hackage riak 1.1.2.6 - A Haskell client for the Riak decentralized data store  https://hackage.haskell.org/package/riak-1.1.2.6 (lambda_foo)
18:02:08 * hackage riak-protobuf-lens 0.24.0.0 - Lenses for riak-protobuf  https://hackage.haskell.org/package/riak-protobuf-lens-0.24.0.0 (lambda_foo)
18:47:37 * hackage skews 0.1.0.2 - A very quick-and-dirty WebSocket server.  https://hackage.haskell.org/package/skews-0.1.0.2 (igrep)
18:56:21 <slack1256> using the async library, I got a supervisor thread `wait`ing on a tree of `Async` via `withAsync`. If I `cancel` the supervisor thread, the whole tree is also canceled via the `withAsync`s?
18:57:28 <Solonarv> that's what the docs imply
19:01:10 <slack1256> I was reading the docs of `withAsync` incorrectly. When they mean "the function returns" they refer to the "action" parameter, not the "inner" one.
19:02:01 <tswett[m]> So in Coq, I can declare an implicit conversion from a type A to a type B, and then wherever a term of type B is expected, I can use a term of type A instead and it'll automatically insert the conversion.
19:02:02 <tswett[m]> Can I do that with Agda?
19:02:37 <tswett[m]> In particular, I'm defining a "Category" record, so can I make it so that if C and D are categories, I can just write "C \to D" instead of "Object C \to Object D"?
19:19:37 * hackage aip 0.1.2 - Aeronautical Information Package (AIP)  https://hackage.haskell.org/package/aip-0.1.2 (qfpl)
19:20:37 * hackage hath 0.5.0 - Hath manipulates network blocks in CIDR notation.  https://hackage.haskell.org/package/hath-0.5.0 (MichaelOrlitzky)
19:21:31 <shapr> I'm a fan of these contact addresses: Queensland Functional Programming Lab <oᴉ˙ldɟb@llǝʞsɐɥ>
19:22:36 <Solonarv> haha
19:26:10 <slack1256> Oh god
19:27:02 <glguy> That's not anti-spam; it's just Australian.
19:30:44 <Arahael> Can confirm: Am australian.
19:31:53 <slack1256> It would be awesome it were an actual email address.
19:35:23 <Arahael> slack1256: It's in username@host format, so it should be, yes.
19:43:39 <geekosaur> technically valid, perhaps, but suspect NXDOMAIN for an MX lookup
19:44:01 <Arahael> Well, and a default domain.
19:49:08 * hackage aip 0.1.3 - Aeronautical Information Package (AIP)  https://hackage.haskell.org/package/aip-0.1.3 (qfpl)
19:51:07 * hackage mongoDB 2.4.0.1 - Driver (client) for MongoDB, a free, scalable, fast, documentDBMS  https://hackage.haskell.org/package/mongoDB-2.4.0.1 (VictorDenisov)
19:53:43 <dibblego> it's a valid email address
19:59:37 * hackage yam-datasource 0.5.14 - Yam DataSource Middleware  https://hackage.haskell.org/package/yam-datasource-0.5.14 (leptonyu)
20:00:38 * hackage yam 0.5.14 - Yam Web  https://hackage.haskell.org/package/yam-0.5.14 (leptonyu)
21:56:08 * hackage hsforce 0.1.0.0 - Salesforce API Client  https://hackage.haskell.org/package/hsforce-0.1.0.0 (tzmfreedom)
21:57:38 * hackage hsforce 0.1.0.1 - Salesforce API Client  https://hackage.haskell.org/package/hsforce-0.1.0.1 (tzmfreedom)
