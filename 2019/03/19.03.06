00:39:24 <jollygood2> hi. I'm having some parsing issues. here's a test case and error: https://bpaste.net/show/1f178c2eb88f
00:48:43 <MarcelineVQ> Looks like it's working as written. in intLine you skip as many comments as you're able to, then you read digits. That whole input parses as a comment so there's nothing to reads digits from.
00:50:56 <dminuoso> MarcelineVQ: Why does the whole input parse as a comment? line shouldn't consume beyond a newline.
00:51:07 <dminuoso> Oh wait heh.
00:51:11 <MarcelineVQ> since there's no more input it's not clear which parser is would have continued to parse, more of the comment parser or the digit parser, thus "expecting "#" or digit"
00:53:44 <dminuoso> jollygood2: Also note that your parser is not quite correct. If you attempt to parse a number that doesn't fit into Int you'll get garbage numbers.
00:54:00 <dminuoso> % read (replicate 100 "1") :: Int
00:54:00 <yahb> dminuoso: ; <interactive>:187:21: error:; * No instance for (IsString Char) arising from the literal `"1"'; * In the second argument of `replicate', namely `"1"'; In the first argument of `read', namely `(replicate 100 "1")'; In the expression: read (replicate 100 "1") :: Int
00:54:09 <dminuoso> % read (replicate 100 '1') :: Int
00:54:09 <yahb> dminuoso: 8198552921648689607
00:54:11 <dminuoso> % read (replicate 101 '1') :: Int
00:54:11 <yahb> dminuoso: 8198552921648689607
00:54:40 <MarcelineVQ> I cheat and use read for toy things :>
00:57:49 <dminuoso> It's interesting that read behaves this way for Int, instead of error'ing out.
00:58:54 <MarcelineVQ> yeah, it's not even maxBound
01:00:53 <MarcelineVQ> replicate 61, 62, 63, 64 are particularly interesting
01:04:11 <dminuoso> % [read (replicate n '1') :: Int | n <- [45..48] ]
01:04:11 <yahb> dminuoso: [89153289498423751,891532894984237511,8915328949842375111,-3080430870124006969]
01:07:18 <MarcelineVQ> at 64 the operation becomes monotonic, to make it sound fancy while not being correct
01:08:34 <dminuoso> % import GHC.Int
01:08:34 <yahb> dminuoso: 
01:08:40 <dminuoso> % :t integerToInt
01:08:40 <yahb> dminuoso: ; <interactive>:1:1: error: Variable not in scope: integerToInt
01:08:54 <dminuoso> % :t integerToInt
01:08:54 <yahb> dminuoso: ; <interactive>:1:1: error: Variable not in scope: integerToInt
01:08:59 <dminuoso> Oh!
01:09:01 <dminuoso> % import GHC.Integer
01:09:01 <yahb> dminuoso: 
01:09:03 <dminuoso> % :t integerToInt
01:09:03 <yahb> dminuoso: Integer -> Int#
01:09:22 <dminuoso> % smallInteger (integerToInt 1111111111111111111111111111111111)
01:09:22 <yahb> dminuoso: 8643332055420924359
01:11:49 <dminuoso> That appears to be using bigNatToWord underneath.
01:12:01 <dminuoso> Or bigNatToInt actually
01:33:54 <jchia> For joining two lists, do you prefer (++) or (<>)? Pros and cons? I usually just use (<>).
01:34:56 <Taneb> jchia: (++) out of habit from before <> was in Prelude (or base)
01:35:34 <MarcelineVQ> pro ++, tells the reader you're talking about lists. pro <>, if you change the types later to something else you don't need to change operators just imports.
01:35:36 <Taneb> Ideologically, I think I prefer <>, or sometimes Control.Applicative.<|> if that's what I think is more likely to help generalization (eg. if I'm also using map/fmap)
01:38:08 <jchia> OK
01:49:10 <kuribas> how do I delete a package?
01:49:21 <kuribas> I accidentally installed hlist instead of HList
01:50:50 <phadej> with `cabal install`
01:50:55 <phadej> i'd say you are ~screwed
01:51:00 <Taneb> ghc-pkg unregister hlist
01:51:32 <phadej> luckily, hlist doesn't pull dependencies, so yeah, unregistering will work
01:51:37 <phadej> or you can just let it be
01:51:38 <kuribas> Taneb: yay, that worked, thanks!
02:12:12 <dminuoso> Do you tolks think that satisfying laws is fine up to isomorphism? Or should they be satisfied completely? Im thinking about Monoid right now.
02:14:52 <phadej> if the type has `Eq` then up to `Eq`
02:15:02 <phadej> if it doesn't have `Eq`, you can wave hands a little more
02:15:42 <phadej> or, if for some instance you use wider equivalence, you have to mention that in documentation
02:17:14 <dminuoso> phadej: Regarding your "Eq" reasoning, is that actually done in the wild?
02:18:28 <phadej> that's what I think
02:18:42 <phadej> and I violate that myself in few libraries
02:23:16 <jollygood2> dminuoso, if I give an empty string to parser I get []. how do I also get [], instead of error, when there are only comments in the string?
02:25:06 <dminuoso> jollygood2: What is the type of your parser?
02:25:31 <jollygood2> Parser [Int]
02:25:46 <dminuoso> jollygood2: If an empty list is not allowed, you could use NonEmpty instead of []
02:26:18 <Taneb> dminuoso: I think you misunderstood jollygood2's question
02:26:39 <jollygood2> my problem is that I am getting parsing error. I want an empty list, when there are no ints in a file, but only comments
02:26:40 <dminuoso> Taneb: Oh. Mmm.
02:27:23 <jollygood2> I asked the question a while ago, so here's the link again, https://bpaste.net/show/1f178c2eb88f
02:27:26 <dminuoso> jollygood2: Can you show how your parser is constructed?
02:30:20 <jollygood2> I don't understand why I'm getting this behavior. many should return [] when parser fails to parse
02:31:05 <dminuoso> jollygood2: Because you specified that behavior in intLine.
02:31:18 <jollygood2> how so?
02:32:47 <dminuoso> jollygood2: Because Parsec will not simply backtrack.
02:33:54 <dminuoso> jollygood2: The Monad/Applicative instance is not wired to automatically backtrack on failure.
02:35:14 <jollygood2> so what do I have to do to make this work?
02:36:45 <tdammers> use try
02:37:31 <dminuoso> Or you could change the parser so you dont need it.
02:37:45 <dminuoso> You could for example first consume comments before you start your parser.
02:39:29 <jollygood2> I have tried something like that
02:39:41 <jollygood2> parse (many (optional comment *> intLine) "" "#comment\n"
02:39:51 <jollygood2> but I guess that is the same as what I have (and it fails in the same way)
02:40:13 <jollygood2> and consuming comment just once, at the start, won't work, as there could be comments in between valid lines
02:40:41 <jollygood2> this also fails:  parse (many (try comment *> intLine)) "" "#comment\n"
02:41:04 <jollygood2> wait, let me try skipMany instead
02:41:34 <jollygood2> yes, it fails.  parse (many (try (skipMany comment) >> intLine)) "" "#comment\n"
02:42:58 <oo_miguel> I added some parallelism (via parMap) and as I increase the number of processors via -N the time spent in GC drastically increaeses 
02:43:09 <jollygood2> my current code: https://bpaste.net/show/6904c9e1fc68
02:43:29 <dminuoso> jollygood2: Let me prepare a gist for you.
02:44:06 <oo_miguel> IS GC running on a single cpu? (I think I read this somwehere)
02:44:23 <merijn> oo_miguel: Depends on the runtime
02:44:35 <merijn> oo_miguel: Oh, wait you use -N
02:44:42 <oo_miguel> merijn: is it bad?
02:44:50 <oo_miguel> compiled with -threaded
02:44:52 <merijn> oo_miguel: The threaded runtime will do parallel GC, however this is generally a terrible idea
02:45:15 <merijn> oo_miguel: Because, as you notice, with high levels of parallelism the GC spends more time synchronising than it spends GCing
02:45:46 <oo_miguel> merijn: yeah i get 99% productiivy with one core but only 50% with 3
02:45:49 <oo_miguel> etc..
02:46:17 <jollygood2> dminuoso, ok
02:46:48 <merijn> oo_miguel: Try running with "+RTS -qg"
02:47:27 <oo_miguel> I am reading Simon Marlow's PArallel and Concurrent Haskell.. 
02:47:59 <oo_miguel> I like it very much. hope it is not outdated
02:48:18 <oo_miguel> he is using this -threaded runtime (at least in the first chapter ;))
02:51:07 <oo_miguel> merijn: hmmm with: -qg -N4 I get 99% producktivity but the total time is the same as with -N4 only (and 75% time spent in GC) :P
02:51:17 <dminuoso> jollygood2: By the way, the `ints <- ..; return ints` part is unnecessary.
02:51:30 <dminuoso> jollygood2: `read <$> many1 digit` is the same. :)
02:52:22 <jollygood2> I know
02:52:41 <jollygood2> my current version is intLine = read <$> many1 digit <* line
02:53:02 <jollygood2> but my main is still there
02:53:07 <jollygood2> +issue
02:55:00 <jollygood2> parse (many (skipMany comment >> try intLine)) "" "# comment\n"   <- still errors.. this is getting frustrating
03:23:47 <kuribas> @hoogle Int -> Text
03:23:48 <lambdabot> Data.Text length :: Text -> Int
03:23:48 <lambdabot> Data.Text.Foreign lengthWord16 :: Text -> Int
03:23:48 <lambdabot> Data.Text.Unsafe lengthWord16 :: Text -> Int
03:24:28 <opqdonut> hah
03:28:08 * hackage datadog-tracing 1.2.0 - Datadog tracing client and mock agent.  https://hackage.haskell.org/package/datadog-tracing-1.2.0 (fommil)
03:28:47 <mikeplus64> does {-# UNPACK #-} do anything when used on a sum type as of ghc 8.(something) ?
03:29:40 <mikeplus64> ghci no longer shows {-# UNPACK #-} pragmas at all in :info, and Core does not show anything different, but maybe there is some lower level transform?
03:29:48 <mikeplus64> i'm not sure how far UnboxedSumTypes got
03:31:41 <lyxia> where are you using this pragma
03:31:54 <lyxia> it works on fields
03:36:52 <mikeplus64> as in data X = A !Int | B | C; Y = XY {-# UNPACK #-} !X
03:37:07 <osa1> mikeplus64: you can't UNPACK sum types yet. it's easy to implement and I have a patch for this, but it needs more work and I'm too busy for other stuff these days.
03:37:40 <osa1> mikeplus64: https://phabricator.haskell.org/D2424
03:37:45 <mikeplus64> osa1, ah nw :-)
03:38:53 <mikeplus64> if i have time i may try to have a squiz (eta ... a month from now ... maybe)
03:39:44 <osa1> that patch is badly bitrot though, I'd probably start from scratch if we were to make it happen.
03:39:48 <osa1> it's from 2016 :)
03:41:34 <mikeplus64> does using unboxedsums directly work to do the 'unpack'-ing? e.g. data Y = XY (# Int ||| #) [i'm not desperate enough to try, but just curious]
03:42:17 <osa1> if I understand you correctly, yes, that unpacks your sum type in the constructor XY
03:42:30 <osa1> it stores the Int directly, with a tag
03:42:38 <mikeplus64> yeah, that's what i mean. neat
03:46:54 <Axman6> osa1: it's sad to hear that unboxed sums are so close but not here yet - I was so excited to have them
03:47:44 <Axman6> I used to have a project that had like 60 Maybe fields, all containing unboxable types, the thought of the amount of indirection overhead made me cry
03:47:56 <osa1> Axman6: they're here, but just not automatically used by GHC when you enable optimisations. you can always use them manually, there are no problems (bugs or otherwise) with that
03:49:19 <osa1> two missing things to make GHC use them implicitly are: (1) UNPACK support (2) extending demand analysis and worker/wrapper transformations
03:49:36 <osa1> (1) is easy, I can do it in a few days if there's enough demand
03:50:03 <osa1> (2) is more tricky, requires a few months of work probably. mostly becuase I'm not an expert in demand (aka. strictness) analysis
03:50:58 <osa1> perhaps I should've posted a GSoC idea for (1)
04:16:45 <ProofTechnique> I have a type like https://gist.github.com/jhenahan/c2c950aca4a0de8253c6334d2e7ff9d9, and I'm trying to derive Functor, Traversable, and Foldable, but I get an error that I can't derive via newtype because it can't eta-reduce the representation type enough. Is there something obvious I'm missing?
04:17:37 * hackage haskell-ci 0.2.1 - Cabal package script generator for Travis-CI  https://hackage.haskell.org/package/haskell-ci-0.2.1 (phadej)
04:18:07 <merijn> ProofTechnique: "IntMap (Maybe a)" seems redundant?
04:18:37 <merijn> ProofTechnique: Anyway, I suspect it's because your Functor would have to go through both the IntMap *and* the Maybe
04:19:13 <merijn> ProofTechnique: If you change it to "series :: Compose IntMap Maybe a" does it work then?
04:19:24 <ProofTechnique> I'll give that a shot!
04:19:25 <merijn> :t Data.Functor.Compose.Compose
04:19:27 <lambdabot> forall k1 k (f :: k -> *) (g :: k1 -> k) (a :: k1). f (g a) -> Data.Functor.Compose.Compose f g a
04:19:34 <merijn> That's a horrible type...
04:19:48 <merijn> Just ignore everything before the .
04:20:26 <Ariakenom> :D juicy type
04:21:18 <fgw> Isn't that just A = B = C, distribution(?)
04:21:19 <ProofTechnique> It's not complaining about Functor, now, though it's less happy about Semigroup and Monoid
04:22:12 <ProofTechnique> Maybe I'll just reformulate as IntMap a. That seems simplest.
04:23:12 <fgw> ProofTechnique: it is mentioned on the hackage page for Data Semigroup that Semigroup conflicts with an operator (<>) defined in Data Monoid
04:23:41 <fgw> and to use both, you should just import Data.Semigroup. Is this the cause of your issue? 
04:25:36 <ProofTechnique> No, I don't think so. I don't think derived Monoids even define (<>), just `mappend`
04:40:51 <ocharles> It'll probably be simpler if you use deriving via Compose IntMap Maybe
04:40:58 <ocharles> Simpler/tidier
04:42:39 <ProofTechnique> As it turned out, just changing my representation to IntMap a was the tidiest
04:43:48 <ProofTechnique> Representing the Maybe in the type wasn't necessary, and I get all my instances for free :)
04:44:12 <ProofTechnique> I even got to delete an entire function in the process :)
04:51:56 <lortabac> hello, do you know of any resources about parametricity? not as a mathematical concept, but more from a programmer's point of view, how it helps reasoning about the code etc.
04:53:10 <dminuoso> lortabac: Well Typed has a decent tutorial https://www.well-typed.com/blog/2015/05/parametricity/
04:53:38 <dminuoso> lortabac: Another good article might be Bartosz Mileswkis:   
04:53:41 <dminuoso> https://bartoszmilewski.com/2014/09/22/parametricity-money-for-nothing-and-theorems-for-free/
04:57:43 <lortabac> dminuoso: thanks, that's the kind of resources I was looking for
04:59:38 * hackage cabal2nix 2.14.2 - Convert Cabal files into Nix build instructions.  https://hackage.haskell.org/package/cabal2nix-2.14.2 (PeterSimons)
05:12:07 * hackage cmt 0.2.0.0 - Write consistent git commit messages  https://hackage.haskell.org/package/cmt-0.2.0.0 (smallhadroncollider)
05:17:58 <ProofOfPizza> Hi folks... at the risk of being impatient: I have a question about the use of curl-runnings.. see https://www.reddit.com/r/haskell/comments/axxj4c/small_curl_runnings_question/ Anyone here maybe that can help out?
05:24:23 <__monty__> ProofOfPizza: Have you tried without the quotes?
05:27:12 <ProofOfPizza> Yes, I tried any combination of quotes and non-quotes... it keeps just returning empty. I know it does at least register the file, because if I provide an invalid filename it will throw an exception ..
05:32:34 <mjrosenb> oh god
05:32:45 <mjrosenb> is that package a pun on cool runnings?
05:33:00 <ProofOfPizza> haha must be!
05:41:46 <int-e> ProofOfPizza: does it work if you add a / at the end of https://swapi.co/api/people/1? (that avoids a 301 reply)
05:49:15 <tabaqui> How can I get warnings for bad pattern matching use like this: "Just x <- foo", where `foo` can return Nothing?
05:49:25 <tabaqui> -Wall doesn't report about this
05:51:23 <Unhammer> Hi, is it possible to depend on .so files on macos? I'm getting 
05:51:25 <Unhammer> ld: can't link with bundle (MH_BUNDLE) only dylibs (MH_DYLIB) file
05:51:27 <Unhammer> from cabal configure -v3
05:51:32 <Ariakenom> tabaqui: maybe -Wmissing-monadfail-instances     https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html
05:55:10 <tabaqui> Ariakenom: nope
05:55:50 <tabaqui> Ariakenom: it is -Wincomplete-uni-patterns
05:55:52 <tabaqui> thanks anyway
05:56:28 <tabaqui> -Weverything warns and annotates with specific flag
05:56:32 <ProofOfPizza> .
06:01:04 <Ariakenom> tabaqui: so which type were you using? something with MonadFail?
06:01:52 <tabaqui> well, it's not about monads actually, it is about data constructors
06:02:31 <tabaqui> f.e. you have a function of type "foo :: Maybe Int" and you write "case foo of { Just a -> bla; Nothing -> blabla }"
06:02:41 <tabaqui> It is ok, pattern matching cannot fail here
06:02:54 <tabaqui> but it can if you write "let (Just a) = foo in" 
06:03:22 <tabaqui> and -Wall on ghc-8.4.4 doesn't report here
06:03:51 <Ariakenom> You had a "<-" so I assumed it was in a do block. Which would desugar using MonadFail.
06:04:11 <tabaqui> yeah, it was overcomplicated example
06:04:27 <tabaqui> I assumed pattern matching fail there
06:10:01 <isovector1> is there any constraint i can add to ensure an existential functor is at role representational?
06:10:35 <isovector1> or any workarounds to the same end?
06:23:40 <Axman6> you might be able to hack something like that using the safe coersions stuff, but I don't thint there's any way to do that... possibly using Generic maybe?
06:23:53 <tabaqui> s/assume/allude
06:42:46 <lprd> Cheers everyone
07:00:07 <AndroUser> hi. is there a way to use a statement in lambda in python?
07:04:12 <ProofOfPizza> ok.... so i found out that using the achors does work: specifying in defaults--->   naam: &naam 'Luke' and then referencing with *naam .... but the normal interpolation using ${naam} still does not.. and that is too bad because this would enable me to create a string like somethinf/${naam}/somethingelse , which is not possible using the *naam
07:04:15 <kadoban> AndroUser: Probably ask #python ?
07:04:45 <ProofOfPizza> for anyone recently joined: I am looking for some help with this: https://www.reddit.com/r/haskell/comments/axxj4c/small_curl_runnings_question/
07:05:00 <AndroUser> I meant to do that, my mistake!
07:06:16 <AndroUser> Sharon22 is spamming porn site
07:47:22 <reallymemorable> I am plugging away at building a Quandl API library that will allow me to request from different datasets.  I am interested in some high level advice on whether to structure it as two versions of tableFetch, two versions of getTableWith, or put it all in one tableFetch/getTableWith and request different things out of that function?  Here is the code I'm working on / considering: 
07:47:28 <reallymemorable> https://paste.ofcode.org/jFfFn8EJZqsRiptsJG8LR8
07:58:34 <habbah> https://github.com/pvdbrand/quandl-api/blob/master/Data/Quandl.hs#L181-L192
07:58:41 <habbah> what is happening in these lines?
07:59:51 <reallymemorable> I have no idea.  Seeing that for the first time.
08:00:13 <habbah> my first guess is that Metadata is being prepended to each of the lookups
08:00:29 <habbah> since <$> is the fmap operator
08:00:59 <reallymemorable> So I create one of those `instance`s for each type of request I would want to do?
08:01:31 <habbah> oh, you're looking at Quandl too :) 
08:01:39 <reallymemorable> oh lol
08:01:44 <reallymemorable> I thought you were answering my question
08:02:02 <reallymemorable> You are building a library for the API?
08:02:12 <reallymemorable> I have what I believe to be most of a script working
08:02:18 <habbah> I have about 5 minutes and was just reading that codebase to see if I could spot something new
08:02:22 <habbah> and I did!
08:04:10 <reallymemorable> do you have any insight on my question by chance?
08:04:25 <sdaasd> k
08:04:45 <sdaasd> what was it ?
08:05:01 <sdaasd> i just arrive
08:05:05 <reallymemorable> https://stackoverflow.com/questions/55027196/building-an-api-library-in-haskell-that-can-request-different-data
08:05:54 <habbah> reallymemorable: sorry, I thought I was late for a meeting, but I've got time
08:06:06 <reallymemorable> awesome 
08:06:29 <reallymemorable> Basically I need to build a library that can handle different kinds of requests to Quandl
08:06:54 <habbah> man, that is some funky code reallymemorable :) 
08:06:55 <reallymemorable> and not sure how to approach it at a basic level.  I've built a script that can request one dataset, but now I need to make it handle different scenarios.
08:07:07 <reallymemorable> http://hackage.haskell.org/package/quandl-api
08:07:17 <reallymemorable> i just basically replicated what was in the docs
08:07:25 <reallymemorable> (also i am 2 weeks into using Haskell)
08:08:05 <habbah> oh I see. Context, in this case the hackage docs, helps
08:10:13 <habbah> reallymemorable: I would try the simplest path
08:10:26 <habbah> separate it out into 2 separate function calls
08:10:26 <reallymemorable> which is two different getTableWith functions?
08:10:37 <habbah> and then when that doesn't work for you, refactor
08:10:56 <reallymemorable> ok so 2 different versions of tableFetch
08:11:03 <reallymemorable> and some kind of sum type that decides which one to use
08:11:48 <habbah> here, let me play with quandl, one sec
08:12:01 <reallymemorable> I will post my full code -- 1 sec
08:13:24 <reallymemorable> https://paste.ofcode.org/SqfV9aBFFL6qb5BnbLCVtj
08:14:22 <EvanR> reallymemorable: on the subject of "many features through one function" and "many functions to access the same guts different ways" i would go with the latter
08:14:45 <EvanR> the former can really make the API ugly
08:14:52 <reallymemorable> so create two versions of tableFetch that are both Producers
08:15:00 <EvanR> if they have different arguments, yes
08:15:05 <EvanR> thats better ime
08:15:13 <reallymemorable> ok
08:15:19 <reallymemorable> and a sum type that sits above them?
08:15:30 <EvanR> they could just be wrappers over some more complicated internal thing
08:15:45 <EvanR> a sum type for what?
08:15:55 <reallymemorable> to indicate which function to invoke?
08:16:05 <EvanR> no thats the 2nd option 
08:16:20 <reallymemorable> didnt you just recommend the second option?
08:16:23 <EvanR> no
08:16:28 <reallymemorable> latter = second
08:16:31 <EvanR> i mean thats the first option
08:16:42 <reallymemorable> oh
08:16:53 <EvanR> f :: Either A B -> Producer, or f1 :: A -> Producer and f2 :: B -> Producer
08:17:05 <EvanR> the Either really isnt helping here
08:17:33 <reallymemorable> so how does the program receive instructions on which to run?
08:18:09 <EvanR> so your API is like an instruction set for an interpreter?
08:18:22 <reallymemorable> it will receive requests from another codebase
08:18:30 <reallymemorable> and get the relevant info from Quandl
08:18:37 <EvanR> well, f1 and f2 are now in the API, that was your question
08:18:48 <EvanR> two different kinds of requests
08:19:03 <reallymemorable> sorry can you elaborate
08:19:07 <reallymemorable> i dont quite follow you
08:19:10 <EvanR> like instead of CPU having "+", it has "int+" and "float+" separate
08:19:29 <reallymemorable> I dont think we are talking about the same thing
08:19:43 <reallymemorable> there are two different time series datasets in Quandl that I need to access
08:19:54 <reallymemorable> and i need to make my library be able to receive instructions to go to one or the other
08:20:20 <EvanR> well, so its the same function with an argument for which dataset?
08:20:28 <EvanR> not two different functions?
08:20:36 <reallymemorable> thats what im trying to figure out
08:20:45 <reallymemorable> i dont know the proper way to set this up
08:20:51 <reallymemorable> i have been doing haskell for 2 weeks
08:20:51 <EvanR> if the dataset is the only difference, that makes it simple
08:21:35 <reallymemorable> i just need to be able to retreive instructions like: go to this dataset and get values between STARTDATE and ENDDATE
08:21:45 <reallymemorable> there are only 2 datasets i need to deal with
08:22:07 <EvanR> if you only ever really have 2 datasets ever (seems an odd limitation), your argument could be of the type data DataSet = Set1 | Set2. but seems more likely you have a URL for the dataset or something?
08:22:31 <reallymemorable> http://hackage.haskell.org/package/quandl-api
08:22:48 <reallymemorable> From the Hackage docs it seems I just indicate with text codes
08:22:57 <EvanR> there you go
08:22:58 <reallymemorable> i have gotten a version working that just grabs from a single dataset
08:23:15 <EvanR> the name of the table could just be an argument in your API
08:23:39 <reallymemorable> so how would I factor out "WIKI" to use the Hackage docs example
08:23:44 <reallymemorable> to be an argument
08:23:47 <reallymemorable> rather than a fixed value
08:24:06 <EvanR> you do a classic lambda wrapper 
08:24:44 <EvanR> instead of getFromTable 1 "Y" 'z', make a function myFunc x = getFromTable 1 x 'z', only with better names
08:25:16 <habbah> https://gist.github.com/mcbahson/82eff1c6ea51406a4402869fe802686b
08:25:30 <EvanR> not the original code could be written myFunc "Y"
08:25:32 <habbah> I think you might be asking how to do this
08:25:32 <EvanR> now*
08:26:08 <EvanR> exactly, make a function for it
08:26:18 <EvanR> (except you will need to indent line 3)
08:26:24 <reallymemorable> ah
08:26:36 <reallymemorable> and then I pass in startDate and endDate as arguments
08:26:44 <EvanR> and table name
08:27:03 <reallymemorable> I dont see where tablename appears in that
08:27:17 <reallymemorable> or you are saying I add it even though its not in that code
08:27:55 <EvanR> getTableWith takes a second argument
08:28:09 <reallymemorable>  [("FRED", "LIOR3M", Maybe 4)]
08:28:11 <reallymemorable> that part
08:28:11 <habbah> oops
08:28:20 <EvanR> right
08:28:43 <reallymemorable> and i put this function inside of my existing tableFetch function?
08:29:00 <EvanR> this lib is a little weird in that area, but databases are weird
08:29:26 <habbah> https://gist.github.com/mcbahson/82eff1c6ea51406a4402869fe802686b
08:29:42 <EvanR> if you put the function inside another function... almost noone can use it
08:30:04 <EvanR> if its generally useful you put it at the top level
08:30:10 <reallymemorable> tableFetch :: Producer (Maybe Dataset) IO r
08:30:10 <reallymemorable> tableFetch = forever $ do 
08:30:21 <reallymemorable> but how do i make all of this still a producer?
08:30:52 <EvanR> whats the problem?
08:31:39 <reallymemorable> I see how IO (Maybe Dataset) is preserved
08:31:56 <reallymemorable> but for Pipes.Concurrency to work
08:31:56 <habbah> quickly, I'm wanting to know what the <*> operators are doing in https://github.com/pvdbrand/quandl-api/blob/master/Data/Quandl.hs#L181-L192
08:31:57 <EvanR> are you looking to make `tableFetch' a function too? with parameters?
08:31:59 <reallymemorable> it needs a producer
08:32:09 <EvanR> taking all the arguments including table name
08:32:22 <habbah> I'll wait my turn though :) 
08:32:55 <EvanR> habbah: that looks like a "parser"
08:33:16 <EvanR> its building the Metadata record field by field while "implicitly" checking for missing data and bailing out, thats the <*>
08:33:42 <reallymemorable> https://paste.ofcode.org/uDjDhUdvszg7SsKiHkNMvA
08:33:46 <reallymemorable> can i do that
08:34:27 <EvanR> sure, and you can refactor it later if it makes more sense
08:35:10 <habbah> maybe I should read the aeson source code. I understand the general gist after looking at the aeson readme
08:35:19 <habbah> I don't understand how
08:35:25 <EvanR> the [("foo", "bar", Maybe 4)] API is weird enough i would try to wrap that and make it easier to use
08:35:48 <reallymemorable> ok i will look into wrappers
08:35:52 <reallymemorable> have not encountered them yet
08:36:20 <EvanR> like, with more params you could put [(dataset, table, Just column)] in your "foo" function and take those extra 3 params
08:36:45 <EvanR> then youre not speaking this weird [(A,B,Maybe C)] thing everywhere
08:37:53 <reallymemorable> https://paste.ofcode.org/grgPXaUmiXtgvbByh96zzV
08:37:56 <EvanR> habbah: <*> is from Applicative, which is a kind of Functor. one use for this interface is for parsers/validators
08:37:57 <reallymemorable> like the secnd thing here?
08:38:04 <EvanR> so read about Applicative
08:38:58 <EvanR> reallymemorable: i use lowercase variable names there for a reason... since thats required in haskell
08:39:40 <reallymemorable> https://paste.ofcode.org/dCFktnFDVd6gKS35zEnUMG
08:39:49 <EvanR> and third argument was "specific column" wasnt it, at this point i am going to have to understand your lib
08:40:26 <EvanR> but other than forgetting to include the arguments in your function def, yeah you have the idea
08:40:44 <reallymemorable> https://paste.ofcode.org/KkYwg5b42te4dh5xFUWkZj
08:40:55 <reallymemorable> I haven't fully integrated the stuff we just talked about into this
08:41:01 <reallymemorable> but that is roughly my script
08:41:16 <EvanR> you now leveled up to procedural programmer
08:41:31 <reallymemorable> what do you mean
08:41:46 <reallymemorable> i am so new to this that i dont know if thats a joke
08:41:50 <EvanR> factoring out repetitive code into parameterized functions
08:42:06 <reallymemorable> ah ok
08:42:16 <EvanR> only step to become functional programmer is take functions as arguments as well as strings and stuff, good luck :)
08:42:28 <reallymemorable> lol thanks
08:50:37 * hackage katip-logzio 0.1.1.0 - Logz.IO scribe for the Katip logging framework  https://hackage.haskell.org/package/katip-logzio-0.1.1.0 (MichaelXavier)
09:12:08 * hackage decidable 0.1.5.0 - Combinators for manipulating dependently-typed predicates.  https://hackage.haskell.org/package/decidable-0.1.5.0 (jle)
09:14:29 <zincy_> So in Haskell all data is immutable. How then can threads change shared state?
09:16:16 <phadej> by using mutable reference types, i.e. IO
09:16:53 <zincy_> What is a `reference` type?
09:17:13 <byorgey> zincy_: data is immutable by default, but there are unsafe backdoors that allow mutability.  These can then be packaged up into safe interfaces for working with mutable data.
09:17:42 <gt[m]> How do you use RecordWildCards like `SwaggerPetstoreBackend{..} <- createSwaggerPetstoreClient (ServerConfig "localhost" 8080)` (as seen in https://github.com/swagger-api/swagger-codegen/tree/master/samples/server/petstore/haskell-servant) in a monad that wraps the IO monad? I'm using `ReaderT e IO a`
09:18:01 <byorgey> zincy_: there are things like IORef, STRef, MVar, TVar ...
09:18:29 <tdammers> "in Haskell all data is immutable" is a matter of what you consider "in" Haskell
09:18:53 <zincy_> Okay lets say you have a TChan and TVars, how is the TVar updated without mutation?
09:18:58 <zincy_> (loaded question)
09:19:06 <__monty__> gt[m]: liftio $ createSwaggerPSC...?
09:19:09 <tdammers> well, again, that depends on what you consider "in" Haskell
09:19:31 <tdammers> the answer is either "it's not updated", or "it's not updated without mutation"
09:19:56 <zincy_> That reminds me of the quote "well that depends on what your defintion of *is* is"
09:20:08 <tdammers> yes, but it's not that esoteric
09:20:14 <zincy_> :)
09:20:37 <zincy_> By in Haskell I mean in purely functional languages (immutability)
09:20:52 <fryguybob> zincy_: In GHC, TVars are special heap objects that are mutated.  You cannot make mutable heap objects using `data` declarations in Haskell.
09:20:57 <tdammers> one interpretation is that Haskell the language is pure, and thus doesn't provide mutations (or any other effects for that matter); it can only handle pure, symbolic values that *represent* effectful computations, and manipulate those in a pure fashion
09:21:20 <tdammers> the actual effects, in this interpretation, are performed by the (impure) RTS, which we consider "not part of Haskell"
09:22:00 <gt[m]> __monty__:  I get `Couldn't match expected type 'IO (SwaggerPetstoreBackend m0)' with actual type 'SwaggerPetstoreBackend SwaggerPetstoreClient'`
09:22:03 <zincy_> Ah gotcha
09:22:31 <tdammers> the other interpretation is that the impure runtime *is* part of Haskell, but we're explicit about what is effectful and what isn't
09:22:53 <byorgey> gt[m]: what's the type of createSwaggerPetstoreClient ?
09:23:09 <phadej> zincy_: broadly speaking, reading/writing IORef isn't much different than reading/writing files
09:23:41 <gt[m]> byorgey: `'SwaggerPetstoreBackend SwaggerPetstoreClient'`
09:24:04 <phadej> communicating with "outside world" using IO
09:24:17 <byorgey> gt[m]: it doesn't even have a function type?
09:24:28 <tdammers> so: "Haskell-the-pure-language" doesn't mutate TVars at all, it just purely constructs actions that, when fed to the impure RTS, will mutate values through references represented by TVars. Or: "Haskell" does mutate TVars, but can only do so through IO actions, which are values representing effectful calculation, and which we can construct using pure expressions
09:24:42 <zincy_> I don't know why I am confused about the concept of thread communication using shared state
09:25:09 <zincy_> Is it because it is an example of something which cannot be achieved without mutation at some level
09:25:27 <zincy_> But then again that applies to any computation
09:25:41 <byorgey> gt[m]: in the example code you pasted you were passing it a (ServerConfig ...) so I would expect it to have a type like   createSwaggerPetstoreClient :: Config -> ...
09:26:10 <phadej> zincy_: but you don't experience any confusion with reading / writing files?
09:26:18 <phadej> or `print` ?
09:27:07 <zincy_> Correct
09:27:10 <__monty__> And the example code's in IO (), so I'd expect createSwaggerPC :: Config -> IO something.
09:27:54 <zincy_> Perhaps I am overthinking it
09:29:43 <gt[m]> byorgey: __monty__ : Sorry I linked the wrong example version, here is better: https://github.com/OpenAPITools/openapi-generator/tree/v4.0.0-beta2/samples/server/petstore/haskell-servant 
09:30:18 <gt[m]> But fundamentally the same issue of trying to use the record wildcard bit in `ReaderT e IO a`
09:31:23 <zincy_> Also what does Haskell code get compiled into by GH?C
09:31:26 <phadej> zincy_: one confusion point might be how threads work in general in GHC RTS
09:32:02 <__monty__> gt[m]: SwaggerPetstoreClient's already a monad transformer stack with IO at the bottom. So I don't see what's different about the stack you want to use.
09:32:18 <zincy_> phadej: Thats something I don't know anything about
09:32:20 * gt[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/AwQDOfqoLPPLujIqYnMwcVWw >
09:32:22 <__monty__> gt[m]: Except of course that createSPC doesn't have the right type for your new stack.
09:32:25 <mpickering> How do I get stack to stop producing output? LIke cabal's -v0 flag
09:33:20 <fryguybob> zincy_: I'm not sure I follow.   "How then can threads change shared state?" "... something which cannot be achieved without mutation at some level".  Change is mutation.  You can certainly model it without mutation by making a function with a time parameter, for instance.
09:33:21 <phadej> zincy_: but that could be reduced to "when impure RTS gets forkIO action, it spawns another evaluation unit which works on that new IO-action"
09:34:07 <phadej> and then writing/reading to IORef isn't different than two programs reading/writing to the some file/socket/whatever
09:35:38 * hackage sgd 0.6.0.0 - Stochastic gradient descent  https://hackage.haskell.org/package/sgd-0.6.0.0 (JakubWaszczuk)
09:35:50 <zincy_> fryguybob: So then I was confused about two things how IO actually works and how channels work
09:36:36 <gt[m]> Ah I think I've got it to work with `let OpenAPIPetstoreBackend{..} = API.createOpenAPIPetstoreClient`
09:36:57 <fryguybob> zincy_: Sure.  As others have been saying, you can talk about that on many levels.  You can model things in IO and have the same (or close) semantics as IO implemented using GHC with a runtime system on real hardware.
09:37:40 <zincy_> I guess the MVar is a ``mutable`` variable and TVar is a ``transactional`` variable. But both would refer to a mutable variable, the latter with extra bookkeeping.
09:38:10 <zincy_> Yeah I think I am trying to understand the different levels of abstraction at once.
09:38:14 <fryguybob> zincy_: Those are both primitives with well defined concurrent semantics.
09:39:15 <fryguybob> zincy_: MVar is like a single cell concurrent queue and TVars are the transactional variables of Haskell's transactional memory.
09:39:17 <EvanR> zincy_: i think of IORef and TVar, which are both references to something, as the immutable reference, a pointer. that cant be mutated
09:39:55 <EvanR> your program controls the runtime system which is a thing in the normal mutable universe
09:40:04 <EvanR> the references go to mutable cells there
09:41:02 <EvanR> using this mental trickery you can even call C a purely functional language
09:41:38 <phadej> except there's everything is in IO
09:41:55 <EvanR> well, C preprocessor perhaps
09:42:07 <zincy_> So you have to use TDammers first mental model in order to be able to call Haskell purely functional?
09:42:35 <EvanR> its mental models all the way down
09:42:42 <zincy_> Because if you say the RTS is part of Haskell and IO just makes effects explicit then it is not purely functional no?
09:42:56 <EvanR> IO actions are also immutable
09:43:07 <EvanR> they just control a runtime system, this thing in the mutable universe
09:43:11 <phadej> zincy_: explicit effects is what makes language pure
09:43:20 <phadej> purity comes from referential transparency
09:43:55 <EvanR> also, if you are careful not to confuse immutability and purity, you can get away with purely functional stuff that uses mutation behind the scenes. See IVars
09:44:19 <EvanR> or ST
09:45:41 <zincy_> what is referential transparency?
09:46:11 <EvanR> depends who you ask
09:47:15 <zincy_> What about asking you :P
09:47:25 <phadej> it's something which makes possible to reason that g (f x) (f x) = let y = f x in g x x
09:47:28 <phadej> it's something which makes possible to reason that g (f x) (f x) = let y = f x in g y y
09:48:05 <EvanR> it's a thing in linguistics which makes references, like those variables above, work right
09:48:05 <reallymemorable> I'm getting an error on line 10 of this code that I don't understand: https://paste.ofcode.org/yrQtnwPhR4ypYKsrqFYaw
09:49:27 <zincy_> Lower cased first letter type names  arent valid
09:49:28 <EvanR> in C, x = 5, x += 1, return x+1; does not do the same thing as return 5+1
09:49:40 <EvanR> so you don't have referential transparency in C
09:49:52 <zincy_> So ref transparency means you can replace expressions with values
09:50:05 <zincy_> because you have pure functions
09:50:09 <EvanR> thats a consequence yeah
09:50:14 <zincy_> ahh
09:50:15 <phadej> it might make you click when you think about `do { print "foo"; print "foo" }` and `do { let p = print "foo"; p; p }` are the same program
09:51:52 <zincy_> So that is the trick of the IO monad to `control` side effects - we replace them with a value which represents the effect and then we maintain purity.
09:52:00 <EvanR> yes!
09:52:08 <zincy_> :D yay
09:52:17 <EvanR> note it doesn't have much to do with monads
09:52:19 <fryguybob> :D
09:52:31 <EvanR> you could have any algebra of 'actions' represent what to do
09:52:33 <__Myst__> Can I somehow define an instance separately for [a] and String?
09:53:14 <fryguybob> __Myst__: You may want a newtype.
09:53:26 <phadej> __Myst__: might be easier to use Text
09:53:32 <phadej> to avoid whole problem
09:53:45 <__Myst__> yeah i actually remembered that i have a newtype over string
09:53:47 <__Myst__> my bad
09:55:29 <mpickering> Does anyone know how I can get a path to the package db that stack uses?
09:55:41 <zincy_> No wonder I was confused when reading these kind of things "Another interesting effect of referential transparency is that it eliminates side-effects from your code."
09:55:41 <mpickering> It isn't passed in the `stack ghci` command
09:55:57 <phadej> mpickering: GHC_PACKAGE_DB
09:56:04 <phadej> or whatever that env var is
09:56:22 <mpickering> how does it set that?
09:56:23 <zincy_> It is quite a crude treatment of how side effects are managed
09:56:25 <EvanR> you will see people using purity and referential transparency interchangably, but it's arguably wrong
09:56:37 <mpickering> I want to run a command like "stack foo" and have it print out the package db path ideally
09:56:44 <mpickering> perhaps `stack exec`
09:56:49 <phadej> stack exec env
09:56:51 <phadej> is a good start
09:57:22 <EvanR> its funny that all these wild concepts seem to meld together in the brain
09:57:22 <sm> or stack path
09:57:50 <sm> stack path --ghc-package-path even
09:58:09 <phadej> too clean :)
09:58:13 <mpickering> sm: that is perfect thanks
09:58:18 <sm> or one of those flags, there's a bunch
09:58:23 <mpickering> stack is a lot better than cabal at this, it has to be said.
09:58:26 <MarcelineVQ> also stack path --snapshot-pkg-db
09:58:42 <zincy_> Evanr: Depends which definition you are using though right?
09:58:46 <mpickering> MarcelineVQ: What is the difference?
09:58:52 <MarcelineVQ> no idea
09:58:59 <EvanR> if you even have definitions yeah
09:59:14 <sm> stack path --help for descriptions
09:59:32 <MarcelineVQ> just mentioned it since it also refers to packages and a db, so it could be relevant
10:00:25 <mpickering> I probably wnt the `ghc-package-path` one
10:00:33 <mpickering> and now just need to work out how to turn that into a ghc flag, thanks all
10:01:00 <MarcelineVQ> mpickering: why do you need to do this?
10:01:12 <sm> the snapshot pkg db corresponds to the resolver, local is this project's local packages, global is, uh global, not sure what's in global with stack these days
10:01:19 <mpickering> I'm working on making haskell-ide-engine work better
10:01:37 * hackage structured-cli 2.5.1.0 - Application library for building interactive console CLIs  https://hackage.haskell.org/package/structured-cli-2.5.1.0 (erick)
10:01:49 <sm> mpickering: thank you
10:02:17 <mpickering> So my fork now works for every build tool you can imagine. cabal, stack, rules_haskell, obelisk etc
10:02:19 <MarcelineVQ> oh I​ mean what is the issue you're trying to work around via paths
10:02:40 <mpickering> I need to know how to make a GHC API session
10:02:58 <zincy_> So would C be "pure" if you added an IO type which represents mutations in assembly?
10:03:03 <mpickering> so I need to know the right package database to use
10:03:19 <hth313> what is the status of GHC on AArch64? (there are no downloads since 8.4.2)
10:03:34 <zincy_> And added immutability, small asks
10:04:20 <EvanR> zincy_: http://conal.net/blog/posts/the-c-language-is-purely-functional
10:04:52 <zincy_> Wait you don't need immutability for purity right?
10:04:56 <MarcelineVQ> mpickering: oh ok, be aware there's a "--[no-]ghc-package-path" flag for some stack commands in case you run into the tooling complaining about that being set or not set.
10:05:16 <mpickering> what does that flag do?
10:05:30 <EvanR> immutable just means objects cant be mutated, how that implies anything is not clear to me
10:05:44 <MarcelineVQ> does or does not set the GHC_PACKAGE_PATH env variable
10:06:11 <mpickering> I think my actually problem here is that I'm setting the wrong libdir when making the ghc api session
10:06:16 <MarcelineVQ> I've only seen to come up as an issue for for stack ghc and stack exec, particuarly when combining stack and cabal
10:06:18 <mpickering> because I am calling `ghc` not `stack/ghc`
10:10:10 <zincy_> People say that purity makes code easier to reason about surely what they are referring to is immutability. Whereas purity makes your functions composable.
10:11:29 <MarcelineVQ> reallymemorable: afaict the error is saying that "yield table" results in the type "Producer (Maybe Dataset) IO ()" but you've claimed tableFetch results in "Producer (Maybe Dataset) IO r" so there's a mismatch between () and r
10:11:59 <__monty__> zincy_: Purity gives you referential transparency which makes reasoning about code easier.
10:12:25 <zincy_> Without purity you cannot compose though right?
10:13:22 <reallymemorable> MarcelineVQ: thanks.  how would i go about having them agree?
10:13:42 <MarcelineVQ> reallymemorable: That's about all I can say since I've never used pipes so I don't know what parts a person needs to keep or discard, others could possibly have better ideas about fixing this
10:13:55 <mreh> is it possible to lift a Monad `m` into `ServerT api m` in servant?
10:14:39 <reallymemorable> MarcelineVQ, ok thanks
10:14:46 <phadej> mreh: what would be the type be?
10:14:56 <phadej> m a -> ServerT api m ? -- not that's not possible
10:15:08 <MarcelineVQ> As a start I guess you can change the type of tableFetch to Producer (Maybe Dataset) IO () and try it out but idk if that's correct
10:15:26 <__monty__> zincy_: Don't see why. You can define a python function that prints or calls another function that prints, that's composition.
10:15:30 <mreh> phadej I guess a is unbound
10:15:32 <reallymemorable> hmm yeah that got rid of the error
10:15:39 <reallymemorable> fingers crossed it doesnt break anything else
10:15:49 <phadej> mreh: what are you trying to do?
10:16:29 <mreh> phadej, check every session in an `Authenticated sess :: AuthResult` belongs to a valid user
10:16:37 * hackage spectral-clustering 0.3.0.2 - Library for spectral clustering.  https://hackage.haskell.org/package/spectral-clustering-0.3.0.2 (GregorySchwartz)
10:16:39 <mreh> I have to do it over and over in my handlers
10:18:10 <zincy_> __monty__: good point, composition feels weird though without a strong type system
10:18:30 <zincy_> because you think to yourself what am I composing?
10:19:26 <phadej> mreh: why you don't check that in the authentication handler?
10:19:58 <mreh> phadej: I do, but sometimes sessions are invalidated
10:20:24 <phadej> aren't you validating session on every request?
10:20:55 <mreh> phadej, yes, where the routes are protected, but I'd like to validate it in one place
10:21:41 <phadej> I'm not understanding the problem. I'd setup things so, that implementation of authentication combinator would setup everything, so I don't need to care in the handler anymore
10:22:17 <phadej> i.e. "if i get a user, it's valid"
10:22:59 <mreh> phadej, do you have an example to hand?
10:25:26 <phadej> mreh: https://haskell-servant.readthedocs.io/en/stable/cookbook/jwt-and-basic-auth/JWTAndBasicAuth.html is the best we have
10:25:36 <phadej> but there authCheck does all the validation, in one place IIRC
10:29:15 <zincy_> So are purely functional languages just ones where all functions are pure?
10:29:41 <zincy_> I.e has all the traits of functional style plus purity
10:30:26 <zincy_> Which then makes me wonder if immutability is necessary to maintain purity
10:30:44 <zincy_> I guess it is
10:30:55 <adjofun> zincy_: You are forgetting about ST monad
10:31:14 <adjofun> mutability can coexist with purity, it just needs to be local
10:31:56 <zincy_> What is ST?
10:32:22 <zincy_> Right so as long as the mutation is local to the function itself you maintain purity
10:33:43 <day> it looks like i can't use guards in a 'let in' statement and i cant nest where statements. http://dpaste.com/0HPR827
10:33:58 <day> whats the right way to solve this?
10:34:25 <day> i really like my 2nd solution 
10:34:39 <day> if it wasn't for the fact of it not working :^)
10:34:56 <lyxia> otherwise = ef
10:35:29 <day> oh
10:35:48 <lyxia> https://gist.github.com/Lysxia/68c9ccf7e9465e91a1e3299a9740fa67
10:36:20 <day> ty. that was rather simple~
10:36:50 <lyxia> :)
10:37:01 <adjofun> So, I am trying to make my regex match certain number of times, using *regex-applicative*. I am given an usual combinators for Applicatives and Alternatives, _some_ acts like r"*", _many_ acts like r"+". I want to write a function `qty :: Int -> RE s a -> RE s [a]`, but can't figure out it.
10:37:37 <adjofun> take "3" <*> many regexp has right type sig, but wrong semantics
10:37:46 <adjofun> take 3, ffix
10:38:13 <merijn> :t replicateM
10:38:14 <lambdabot> Applicative m => Int -> m a -> m [a]
10:38:17 <merijn> :t replicateM_
10:38:19 <lambdabot> Applicative m => Int -> m a -> m ()
10:38:31 <merijn> adjofun: ^^
10:39:42 <zincy_> If monads are for sequencing computations what are applicatives for?
10:40:37 <geekosaur> "parallelism" in some sense: these things must happen, but you don't care what order.
10:42:12 <geekosaur> applicatives are multiple independent actions, monads are multiple actions which depend on earlier actions in the sequence
10:42:39 <geekosaur> for some monad/applicative-specific definition of "action"
10:42:44 <zincy_> So applicative computations are in a sense self contained
10:42:52 <zincy_> :t (<*>)
10:42:53 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
10:43:15 <adjofun> merijn: well, that was easy. I totally forgot about `replicateM`. There is a harder one: I want to specify regexp bounds, like r"{3,5}.", which will match any symbol between 3 and 5 times. I think this can be done with (<|>) in terms of replicateM, but that solution is surely inefficient
10:43:28 <adjofun> applicatives change structure in a static way
10:43:35 <adjofun> monads do so in a dynamic way
10:44:10 <zincy_> But both are used for sequencing computations
10:44:23 <geekosaur> combining, not sequencing
10:44:36 <geekosaur> monads sequence and combine, applicatives only combine
10:45:03 <zincy_> ah okay because you cant (<*>) . (<*>)
10:47:04 <zincy_> So is the combine action derived from the monoid instance of the f in fa
10:47:07 * hackage too-many-cells 0.1.3.1 - Cluster single cells and analyze cell clade relationships.  https://hackage.haskell.org/package/too-many-cells-0.1.3.1 (GregorySchwartz)
10:48:07 * hackage yesod-ip 0.5.1 - Code for using the ip package with yesod  https://hackage.haskell.org/package/yesod-ip-0.5.1 (andrewthad)
10:49:30 <geekosaur> that's Alternative, not Applicative? (…although this might be "rightish" if you instead say semigroup?) this said, it's at a different level of abstraction than monoid / semigroup
10:50:17 <adjofun> Alternatives are monoids on functors.
11:19:16 <jjb1> i have been trying to figure out how to get Tasty to test a single QuickCheck property with a nonstandard set of QuickCheck options (specifically, number of tests to run). so far i have completely failed and would love pointers to a solution if there is one!
11:29:15 <jjb1>  /infO
11:29:23 <jjb1> sigh
11:32:36 <davean> jjb1: if you do --help on the test executable it'll explain it to you
11:33:43 <jjb1> oh thanks! i'm looking for something programmatic, but maybe that's what you mean or where it will lead -- much appreciated!
11:34:42 <davean> jjb1: oh you want a configuration local to that one test in your test tree?
11:34:51 <jjb1> yes, exactly
11:35:57 <day> is there any way to avoid name collisions when defining a data type aside from putting it into its own file/module?
11:36:34 <davean> jjb1: http://hackage.haskell.org/package/tasty-1.2.1/docs/Test-Tasty-Ingredients.html http://hackage.haskell.org/package/tasty-1.2.1/docs/Test-Tasty-Options.html
11:37:13 <jjb1> thanks, i will check that!
11:37:57 <davean> jjb1: the tricky thing I guess is that tasty has the methods for setting it, the values to set it with are in tasty-quickcheck
11:39:07 <Solonarv> day: there is DuplicateRecordFields if the collisions are record field names
11:39:09 <Solonarv> otherwise no
11:42:19 <day> Solonarv: thanks
11:42:38 <MarcelineVQ> !list
11:48:08 * hackage easytest 0.3 - Simple, expressive testing library  https://hackage.haskell.org/package/easytest-0.3 (joelb)
11:57:22 <sternmull>  i use "x <- foo; let _ =  :: SomeType" inside my do-blocks to add type annotations. Is there a better way?
11:57:54 <sternmull> should have been "x :: SomeType" of course
11:58:12 <lyxia> x :: SomeType <- foo       with ScopedTypeVariables
11:58:30 <Solonarv> lyxia++
11:58:47 <Ariakenom> also "x <- foo :: SomeType"
11:59:00 <Solonarv> that needs to be: x <- foo :: IO SomeType
11:59:09 <Solonarv> (or whatever monad you're in, instead of IO)
11:59:31 <kadoban> Ya. Which is kind of awkward. Isn't there some newish thing where you can specify part of a type in GHC now?
11:59:34 <sternmull> lyxia: Thanks thats exactly the syntax i hoped for
12:00:02 <kadoban> Like with wildcards, like :: _ Int   maybe ? probably not exactly that though
12:00:15 <Solonarv> exactly like that, actually
12:00:32 <Solonarv> you need to enable PartialTypeSignatures for that to not be an error, though
12:01:05 <kadoban> Huzzah. Oh, that kind of ruins it then, might as well just do the scoped one
12:01:09 <Ariakenom> ah yes I see
12:01:42 <Solonarv> I'm not a big fan of PartialTypeSignatures anyway, I prefer being explicit
12:03:43 <Solonarv> STVs on the other hand I am a big fan of - it lets you write more type signatures!
12:04:11 <notzmv> single transferable votes?
12:04:30 <Solonarv> scoped type variables :D
12:04:41 <Solonarv> (they were mentioned above, and the name is a mouthful)
12:16:09 <koz_> I agree with Solonarv - ScopedTypeVariables are very very useful.
12:16:19 <koz_> (I actually think this is _more_ sensible than the default)
12:18:31 <reallymemorable> Is it valid to put args inside parentheses like this, and refer to them by a single constructor name on the next line?
12:18:34 <reallymemorable> mainLoop :: (Bool -> (Maybe Day) -> (Maybe Day) -> (Maybe Frequency) -> (Maybe Transformation) -> String -> String -> (Maybe Int)) -> (Maybe Dataset -> IO ()) -> IO ()
12:18:37 <reallymemorable> mainLoop tableFetch handlerFn = do
12:25:02 <Solonarv> yes, that looks valid and well-typed to me
12:25:23 <reallymemorable> ok thank you
12:25:26 <Solonarv> although the parentheses around each of the 'Maybe Foo' are unnecessary
12:25:38 <reallymemorable> got it
12:25:41 <Solonarv> another nitpick: those aren't "constructor names", they're just variables
12:25:49 <reallymemorable> understood thanks
12:25:57 <reallymemorable> still getting used to the vocab :P
12:27:42 <mpickering> What is the default target for `stack repl` ?
12:27:55 <mpickering> It seems to get confused by multiple executables
12:28:13 <mpickering> but I would expect it to load the library
12:30:10 <reallymemorable> https://paste.ofcode.org/6MbUMt5eEMcaZiiKpvTgLR
12:30:23 <reallymemorable> I understand enough here to know that tableFetch has the wrong signature
12:30:34 <reallymemorable> but i dont know how to get it to the correct one
12:34:10 <mpickering> `--no-load` seems to work around this problem for me
12:34:22 <mpickering> RIP my computer installing 200 haskell dependencies I already installed with cabal
12:36:04 <MarcelineVQ> mpickering: it's confused by multiple Main's, you can use --no-load or a specific --main-is I think
12:36:23 <mpickering> right I don't actually want to load anything into the repl so --no-load seems perfect
12:47:53 <fvr> :t (>->)
12:47:54 <lambdabot> error:
12:47:55 <lambdabot>     • Variable not in scope: >->
12:47:55 <lambdabot>     • Perhaps you meant one of these:
12:52:24 <fvr> reallymemorable: Are you using the pipes package?
12:53:40 <reallymemorable> fvr: yes
12:53:47 <reallymemorable> Pipes.Concurrency
12:56:12 <fvr> reallymemorable: from looking at only that code, runEffect takes a `Proxy X () () X m r`
12:56:27 <fvr> and (>->) has different type signature
12:57:47 <reallymemorable> so `>->` is the wrong operator?
12:58:15 <fvr> you can look up the documentation on hackage, https://hackage.haskell.org/package/pipes-4.3.9/docs/Pipes.html#v:-62--45--62-
12:58:29 <reallymemorable> im looking at that page now
12:59:24 <fvr> reallymemorable: It depends what you want to do, what's the type of `handler`
12:59:56 <reallymemorable> https://paste.ofcode.org/gUCzEenCu8FNKGmcLbqxec
13:02:58 <fvr> reallymemorable: you can see in the second line, you have `tableFetch handler` and handler doesn't match the argument type to tableFetch
13:03:23 <reallymemorable> _               <- forkIO $ runEffect $ fromInput input >-> toOutput output
13:03:30 <reallymemorable> I did this and HIE seems to like it
13:04:36 <fvr> reallymemorable: Yes, fromInput and toOuput give a Proxy and that typechecks with >->
13:04:46 <fvr> i.e. if input and output are also of appropriate types
13:52:41 <micahjam97> Hey I would like some help. I have a separate file with numbers listed in it in one line, separated by a single space, like "2 3 5 7 11". How can I turn that into a list of numbers?
13:53:41 <micahjam97> https://pastebin.com/hbs0hHF0 this is the equivalent python code I use
13:53:58 <c_wraith> what have you tried?
13:54:24 <codedmart> Can you derive Generic with existiential quantification -> `data SBox = forall a. Show a => SBox a; deriving instance Generic SBox`
13:55:03 <micahjam97> wwell honestly I dont now where to start with it. Im new to Haskell, and I get a little confused with Haskell I/O. I guess I'd just like an example piece so I can experiment and pick it apart myself
13:55:27 <c_wraith> codedmart, I doubt it. generic needs to know the shape of the data, and that explicitly throws that information away.
13:56:12 <codedmart> That makes sense. I was seeing if I was missing something.
13:56:40 <c_wraith> micahjam97, I would start by treating this as two entirely separate tasks. reading the file into a string, and converting a string into a list of numbers.
13:57:52 <c_wraith> micahjam97, this has the advantage that you can work with the second part in ghci easily.
13:58:37 <c_wraith> micahjam97, and then the first part is just readFile
13:59:36 <micahjam97> c_wraith, ok. so like "map (read) (words line)" kind of deal?
13:59:44 <c_wraith> exactly
13:59:54 <micahjam97> gucci stuff. thankss
14:01:11 <micahjam97> map (\n -> read n :: Int) (words lis)     works awesome
14:08:11 <fryguybob> I'm trying to use the cabal Nix-style local builds in a way that I was always able to do with cabal sandboxes where I install the dependencies I need then cabal exec and work with plain .hs files.  Is there a similar workflow supported now?
14:11:14 <c_wraith> fryguybob, supposedly, but I've encountered some bad bugs.
14:11:49 <c_wraith> fryguybob, in theory, you should be able to say cabal v2-repl --build-depends whatever
14:12:08 <c_wraith> but it had some issues last time I tried to use it.
14:12:17 <fryguybob> v2-repl is the same as new-repl right now right?
14:12:23 <c_wraith> yes
14:12:42 <c_wraith> I've just internalized the immutable names :)
14:14:16 <c_wraith> so, for the time being, I'm still v1-install ing packages for that use case. not the prettiest, but it's what worked.
14:16:25 <fryguybob> c_wraith: Ok.  The complaint I keep getting is that the projects I have do not contain any compnents.
14:17:18 <c_wraith> oh, are you doing this in a directory that already has a cabal project? that will probably never work.
14:18:38 <c_wraith> I guess I didn't mention that part. I was doing this from outside of any cabal project
14:20:08 <fryguybob> Well I wanted to do that, but then I how do I tell GHC which packages I want to load?
14:23:15 <c_wraith> that's what the --build-depends flags to cabal are about 
14:24:33 <fryguybob> Hummm maybe what I want is v2-install to spit out a ghc environment file?
14:25:09 <c_wraith> that's an interesting direction. I haven't looked into those.
14:26:20 <fryguybob> When I tried just command-line options I got this amusing error: Ambiguous module name Diagrams.Backend.SVG.CmdLine: it was found in multiple packages: diagrams-svg-1.4.2 diagrams-svg-1.4.2
14:26:28 <Solonarv> 'cabal v2-install --lib' is already supposed to do that, I think
14:26:34 <Solonarv> I don't know how well it works though
14:40:35 <lyxia> codedmart: kind-generics can do that
14:41:19 <lyxia> of course you have to be a bit more creative to write generic instances that work with those
14:43:20 <codedmart> lyxia: Thanks I will take a look.
14:44:25 <fryguybob> Solonarv, c_wraith: This worked: cabal v2-install ... --lib --package-env .
14:44:59 <fryguybob> (although it put the wrong path to the store in the file, but I could manually fix that.)
14:47:44 <c_wraith> interesting. thanks for the update
15:01:19 <delYsid> Thats counterintuitive.  I just added diagrams as a dependency to a project, and after rebuilding executable size stayed the same.  How can that be?
15:02:02 <MarcelineVQ> did you also actually use diagrams?
15:03:08 * hackage genvalidity 0.7.0.2 - Testing utilities for the validity library  https://hackage.haskell.org/package/genvalidity-0.7.0.2 (Norfair)
15:04:08 * hackage genvalidity-hspec 0.6.2.3, genvalidity-bytestring 0.4.0.0 (Norfair): https://qbin.io/scan-filed-8oyi
15:09:05 <LunarJetman2> wow; lots of users.. Haskell seems to be quite popular.
15:09:55 <hpc> we're all bots
15:09:57 <hpc> beep boop
15:10:23 <LunarJetman2> yes I think I will implement Haskell too.
15:10:26 <lambdabot> I'm not.
15:11:20 <hpc> lambdabot: <3
15:16:45 <c_wraith> very, very Life of Brian-esque response there. but we're not python!
15:21:19 <kadoban> Maybe we're monty
15:21:31 <hpc> the full monty?
15:21:49 <ski> or nothing but the monty ?
15:28:15 <ProofTechnique> Just Monty
15:32:57 * ski . o O ( <https://monte.readthedocs.io/> )
15:33:11 <LunarJetman2> implementing Haskell should be fun as it is a bit of a paradigm shift for me who isn't used to functional programming beyond C++ template metaprogramming.
15:34:41 <c_wraith> Haskell isn't the easiest functional language to implement.
15:35:13 <LunarJetman2> more the reason to do it
15:35:22 <c_wraith> things like the context-sensitive grammar and unusual evaluation model can be tricky to handle efficiently.
15:35:46 <LunarJetman2> I have to support that anyway
15:35:48 <ski> LunarJetman2 : perhaps see (the first paragraph of) "The story of jhc" by John Meacham at <http://www.repetae.net/computer/jhc/jhc.shtml#the-story-of-jhc>
15:37:04 <Solonarv> do you mean "implement Haskell" as in "write a Haskell compiler", or simply as in "use/learn Haskell" ?
15:37:21 <ski> (i'd put that in a lambdabot quote, except that it's slightly too long for that)
15:37:21 <kadoban> ski: That's a nice paragraph xD
15:37:38 * hackage fltkhs-themes 0.1.0.7 - A set of themed widgets that provides drop in replacements to the ones in FLTKHS.  https://hackage.haskell.org/package/fltkhs-themes-0.1.0.7 (deech)
15:37:42 <ski> kadoban, yes :)
15:38:19 <kadoban> "It takes ridiculous amounts of memory and CPU. A gigabyte of RAM usage is not unheard of." <-- also nice
15:40:12 <LunarJetman2> Solonarv: I mean add Haskell to the list of languages my universal compiler can compile
15:40:20 <Solonarv> oh, I see
16:00:39 <LunarJetman2> ski: what's the gist?
16:01:20 <ski> it's just seven sentences
16:03:01 <LunarJetman2> ski: yeah people also think I am crazy; my universal compiler: https://neos.dev
16:13:18 <mightybyte> Hi Everyone, the New York Haskell meetup is streaming a talk "Implementing Caches in Haskell" by Jasper Van Der Jeugt now at https://www.youtube.com/watch?v=Ni2QPZ-VU2k
16:13:55 <mightybyte> This is our first time streaming, so we're still working out the kinks, but we wanted to put the link out there so we can get some people watching and giving us feedback.
16:18:17 <LunarJetman2> I've added Haskell to the list: https://neos.dev/ \o/
16:23:08 * hackage geodetic-types 0.0.4 - Types for geodetic operations  https://hackage.haskell.org/package/geodetic-types-0.0.4 (qfpl)
16:24:55 <michalrus> Hey, with this error, can I make it choose the more concrete one?
16:24:56 <michalrus>     • Overlapping instances for ToSchema (Set (Unrestrictable Int))
16:24:56 <michalrus>         instance ToSchema a => ToSchema (Set a)
16:24:56 <michalrus>         instance ToSchema (Set (Unrestrictable Int))
16:26:06 <michalrus> Oh, `instance {-# OVERLAPPING #-}`? :p
16:27:58 * ski . o O ( <https://stackoverflow.com/questions/10942136/whats-so-bad-about-overlappinginstances> )
16:29:31 <michalrus> But this is just for Swagger docs…
17:04:16 <phadej> using overlapping instance is admitting to yourself: "I won't be able to abstract over this class"
17:14:12 <reallymemorable> I'm trying to work through some exercises a friend gave me
17:14:28 <reallymemorable> how would I use a fold to get the average of a list of integers?
17:15:55 <koala_man> reallymemorable: fold to find the sum and count, then divide afterwards
17:16:16 <slack1256> @type sum
17:16:17 <lambdabot> (Num a, Foldable t) => t a -> a
17:16:21 <slack1256> @type length
17:16:22 <lambdabot> Foldable t => t a -> Int
17:16:29 <slack1256> those two functions ought to help you out
17:16:52 <reallymemorable> a can be a list?
17:16:59 <reallymemorable> in the first example?
17:17:11 <slack1256> `a` can be `Integer`
17:17:16 <reallymemorable> foldl (+) [2,5]
17:17:17 <reallymemorable> ?
17:17:21 <ski> `t a' can be `[Integer]'
17:17:22 <slack1256> `t` can be `[]`
17:17:22 <geekosaur> reallymemorable, t can be list
17:17:38 <slack1256> you are missing the "base case" of the fold
17:17:48 <slack1256> > foldl (+) 0 [2,5]
17:17:50 <lambdabot>  7
17:17:55 <slack1256> @type foldl
17:17:56 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
17:18:56 <slack1256> @type foldl @[]
17:18:57 <lambdabot> error:
17:18:57 <lambdabot>     Pattern syntax in expression context: foldl@[]
17:18:57 <lambdabot>     Did you mean to enable TypeApplications?
17:19:46 <ski> % :t foldl @[]
17:19:46 <yahb> ski: (b -> a -> b) -> b -> [a] -> b
17:20:01 <ski> % :t sum @[]
17:20:01 <yahb> ski: Num a => [a] -> a
17:20:05 <ski> % :t length @[]
17:20:05 <yahb> ski: [a] -> Int
17:20:19 <slack1256> % :t length @[] @Integer
17:20:20 <yahb> slack1256: [Integer] -> Int
17:20:24 <ski> @hackage folds
17:20:24 <lambdabot> http://hackage.haskell.org/package/folds
17:20:36 <slack1256> probably an overkill though
18:00:36 <Zemyla> Are there any good libraries that store text in fingertrees?
18:09:17 <p0a> Hello, is emacs a good software to use to write haskell in?
18:09:50 <silverneedle> probably. ive used vscode and it works alright too
18:11:23 <p0a> alright
18:15:17 <butterthebuddha> https://gist.github.com/anrddh/acb4ff3bde4faf702624581fedaec8f4
18:15:47 <butterthebuddha> This is my solution to part 2 of the first day of the 2015 advent of code challenge (link: https://adventofcode.com/2015/day/1)
18:16:11 <butterthebuddha> I'm not particularly happy with it and was wondering if people had other solutions and/or improvements on my solution?
18:19:59 <Welkin> can you submit solutions for past years?
18:20:25 <butterthebuddha> Yes
18:20:38 * hackage selective 0.1.0 - Selective applicative functors  https://hackage.haskell.org/package/selective-0.1.0 (snowleopard)
18:20:38 <p0a> butterthebuddha: ) is -1 and ( is +1 ?
18:20:47 <p0a> butterthebuddha: what's the catch? looks like a simple sum
18:21:25 <butterthebuddha> p0a: It works, I just don't particularly like it. I also think that my solution to part two will recurse unnecessarily even after it has found the solution
18:22:01 <p0a> I'm asking about the puzzle itself
18:22:15 <Welkin> when I see parentheses, I think about stacks
18:22:17 <p0a> it looks like ( is 1 and ) is -1. Right? and the 'instructions' are a series of parentheses?
18:22:21 <butterthebuddha> Yep
18:22:30 <butterthebuddha> Part 1 is simply a sum
18:22:38 <aplainzetakind> butterthebuddha: It won't keep going unnecessarily.
18:22:44 <p0a> Okay I need to be authenticated for part 2 I suppose
18:23:00 <p0a> I just don't know what puzzle your code solves
18:23:00 <butterthebuddha> Part 2 is find  the first parenthesis that causes the sum to become negative
18:24:13 <butterthebuddha> aplainzetakind: Can you explain?
18:25:35 <aplainzetakind> f is not strict in the second argument, when the first argument is of the form you need, laziness will stop evaluating.
18:26:15 <aplainzetakind> Sorry, the "not strict..." statement is not completely accurate.
18:26:55 <aplainzetakind> What I mean is, when the terminating pattern is matched, the second argument is not needed, so won't be evaluated.
18:27:30 <butterthebuddha> My impression was that the function would still recurse n level deeps, the last m levels would just return immediately
18:30:27 <aplainzetakind> Scratch that, what I said would be the case with foldr, but foldl doesn't do that.
18:31:43 <ankh_> :q
18:31:45 <ankh_> :q!
18:31:47 <p0a> How can I install everything in debian? for haskel
18:32:26 <p0a> the haskell platform
18:32:34 <maerwald> ghcup
18:32:46 <maerwald> https://github.com/haskell/ghcup#installation
18:33:05 <maerwald> you might need to install libnuma, depends on the ghc version
18:33:27 <p0a> maerwald: it said that the haskell platform is already in the repo of the distribution on haskell.org and I should just use apt 
18:33:36 <maerwald> You can also do that
18:33:38 <p0a> maerwald: the #debian people say I should prefer packages over other stuff 
18:33:43 <maerwald> True
18:33:49 <p0a> maerwald: I'm just afraid of breaking the system (because I've done it to many systems))
18:34:01 <maerwald> Then I don't understand your question :>
18:34:11 <maerwald> use your distro packages if they suffice
18:34:27 <p0a> Yeah I asked it before I looked up the answer on haskell.org 
18:34:43 <aplainzetakind> ghcup doesn't mess with your system.
18:34:52 <aplainzetakind> It stays in its own folder.
18:35:04 <aplainzetakind> And it's pretty neat and convenient.
18:35:07 <maerwald> not sure what ghc version debian will give you
18:35:13 <p0a> is that important?
18:35:18 <maerwald> might be
18:35:22 <p0a> why?
18:35:31 <p0a> I'm only looking to learn - I'm using a 2010 book anyway
18:35:50 <aplainzetakind> If you want to build some stuff other people wrote, with system packages you might find yourself in dependency hell.
18:35:52 <maerwald> what debian version?
18:35:56 <p0a> latest
18:36:28 <maerwald> sid?
18:37:03 <aplainzetakind> butterthebuddha: Is the second part asking to find the position of the first closing parenthesis without a matching opening?
18:37:11 <maerwald> sid has 8.4.4, that is a good choice, especially for editor tooling
18:37:57 <butterthebuddha> aplainzetakind: no - it's asking for the parenthasis that causes you to "go into the basement". I.e., the first parenthesis after which the running sum becomes negative
18:39:25 <p0a> maerwald: sid?
18:42:04 <xpika> is there any way to automatically derive Data for all existing datatypes ?
19:01:47 <michalrus> phadej: yes, I won’t be… but I need to add something to Swagger’s examples… but in array context.
19:02:15 <p0a> Does anyone understand how to setup haskell-mode for emacs?
19:02:27 <p0a> It's extremely frustrating lol
19:02:48 <silverneedle> then dont do it
19:02:50 <michalrus> So I want to define an `instance {-# OVERLAPPING #-} ToSchema [MyType]`… to be able to add N examples, not just one, that I could add to `instance ToSchema MyType`.
19:02:51 <silverneedle> vscode!
19:03:38 <michalrus> p0a: I basically just use `(use-package haskell-mode)` and that’s it. :o
19:04:00 <p0a> michalrus: I want it to automatically be there for .hs files
19:04:13 <michalrus> I didn’t do anything in that regard and mine is
19:04:18 <p0a> alright let me try 
19:04:28 <p0a> michalrus: the docs didn't tell me to do this btw 
19:05:07 <geekosaur> the docs have to deal with multiple emacs versions and the instructions differ for different versions
19:05:08 <michalrus> Maybe it’s assumed in the community that you’ll try `(use-package my-new-lang-mode)`. ¯\_(ツ)_/¯
19:05:15 <geekosaur> plus how you installed it, e.g. melpa
19:05:40 <geekosaur> vs. distro package
19:05:45 <p0a> michalrus: use-package is not defined for me
19:05:56 <p0a> geekosaur: I'm just following manuals, etc. 
19:06:06 <Welkin> just use M-x tetris
19:06:24 <p0a> Welkin: yeah well what can I say, maybe I should.
19:06:35 <silverneedle> just use vscode
19:06:37 <michalrus> p0a: uhhh, maybe you’d rather try http://spacemacs.org/ or some other pre-configured ‘distribution’
19:06:40 <silverneedle> i swear im not a shill
19:06:42 <p0a> silverneedle: buy it for me
19:06:48 <silverneedle> done!
19:06:49 <cfraz89> its free lol
19:06:50 <silverneedle> its free
19:06:56 <p0a> still refusing
19:07:02 <silverneedle> why though
19:07:04 <p0a> you probably couldn't pay me to use it
19:07:16 <silverneedle> afraid youll like it? ;)
19:07:20 <cfraz89> @p0a what version emacs are you using
19:07:20 <lambdabot> what version emacs are you using
19:07:26 <cfraz89> must be ancient to not have use-package
19:07:26 <p0a> cfraz89: 24.6
19:07:34 <cfraz89> ok its ancient
19:07:35 <notzmv> lel vs code
19:07:45 <cfraz89> better update your emacs first
19:07:52 <p0a> cfraz89: I'm using debian
19:07:57 <notzmv> nice
19:08:10 <notzmv> p0a: just wait a couple years then I guess :^)
19:08:31 <silverneedle> u gotta switch to arch now
19:08:38 <Welkin> vscode is spyware
19:08:45 <Welkin> stay free
19:08:54 <notzmv> silverneedle is right
19:08:59 <silverneedle> is that tinfoilhattery
19:09:00 <notzmv> wait no
19:09:02 <silverneedle> or u got a source
19:09:04 <notzmv> use nixos :^)
19:09:16 <Welkin> p0a: to use haskell-mode just install it
19:09:19 <michalrus> p0a: emacs, like vscode, is also using a silly single-thread language, if that’s your concern maybe
19:09:39 <Welkin> make sure you install a recent version
19:10:07 <Welkin> silverneedle: it is true, vscode sends tracking data back to microsoft
19:10:10 <p0a> michalrus: single-thread ?
19:10:30 <cfraz89> didn't they introduce threading in 26.1?
19:10:45 <Welkin> I want emacs written in erlang
19:11:06 <Welkin> true concurrency that can use my 16 core machine (that I don't have yet, but will)
19:11:14 <cfraz89> 26.0 sorry
19:11:18 <notzmv> Welkin: you misspelled clojure
19:11:24 <notzmv> :^)
19:11:25 <Welkin> notzmv: I did not
19:11:39 <cfraz89> https://www.gnu.org/software/emacs/manual/html_node/elisp/Threads.html#Threads
19:11:44 <Welkin> clojure uses the outdated model of threads
19:11:45 <silverneedle> Welkin erlacs
19:11:50 <silverneedle> write it
19:12:28 <notzmv> Welkin: aight can we settle for LFE? :P
19:12:36 <Welkin> sure, it's still erlang
19:12:52 <cfraz89> p0a: http://emacs.secretsauce.net/ if you don't mind running bleeding edge
19:12:53 <notzmv> yeah but I need parens to survive
19:13:11 <michalrus> Is there ~ constraint, but meaning “not equal to”?
19:13:17 <michalrus> `/~`?
19:13:18 <p0a> cfraz89: I'm going with debian for now
19:13:29 <cfraz89> those are debian packages
19:13:31 <Welkin> p0a: compiling from source is really easy
19:13:35 <Welkin> I've done it on mac
19:13:40 <Welkin> it's fast too
19:13:50 <p0a> it breaks ssystems, I'm using debian
19:15:08 <apersonalive> hey guys. i would like to build a data pipeline. anyone made something like this in haskell before? i would prefer to be writing in haskell for this task instead of using something like apache beam and golang
19:17:26 <silverneedle> damn now vscode feels dirty
19:19:44 <maerwald> vscode has good hie support afaik
19:20:23 <p0a> Well I don't care for the spyware to be honest
19:21:50 <Welkin> there is vscodium if you want a tracking-free version of vscode
19:23:31 <maerwald> another binary blob :>
19:23:33 <p0a> It's simply about the fact the software is not free 
19:23:35 <Welkin> nothing is better than emacs for me, no matter what I try. But I'm also a minimalist
19:23:51 <Welkin> maerwald: you can build it yourself if you wish from source
19:23:56 <maerwald> p0a: vscode is free 
19:23:59 <silverneedle> now i know i gotta get vscodium damn
19:24:02 <silverneedle> thanks
19:24:08 <p0a> maerwald: 'free' in a different sense 
19:24:12 <silverneedle> i wanna try emacs cuz the lisp 
19:24:15 <maerwald> p0a: no, free in GNU sense
19:24:26 <silverneedle> but its so inconvenient to switch editors 
19:24:34 <Welkin> vscode is open source, but has tracking code enabled in the binaries. vscodium is a binary release with the tracking disabled
19:24:50 <p0a> maerwald: I still refuse out of principle
19:25:11 <maerwald> p0a: I wasn't suggesting vscode
19:25:19 <p0a> np I know
19:25:29 <Welkin> maerwald: vscode is MiT licensed, not gpl
19:25:47 <p0a> Welkin: I'm not that extreme though
19:25:48 <Welkin> I remember compiling emacs from source taking just seconds
19:25:57 <p0a> it would break the system though
19:25:58 <p0a> potentially 
19:26:03 <Welkin> why?
19:26:26 <maerwald> Welkin: irrelevant https://www.gnu.org/licenses/license-list.en.html#Expat
19:26:37 <maerwald> MIT is free software license
19:27:34 <Welkin> whatever you say, I'm not going to waste any energy on this
19:28:46 <maerwald> Well, that's from FSF, who made GPL :>
19:29:08 <maerwald> and they are literally saying it is a free software license
19:41:44 <apersonalive> spacemacs is such a nice experience
19:42:30 <apersonalive> ive recently (in the last 2 weeks) compared both vscode and spacemacs. the grass is not greener with vscode
19:42:45 <silverneedle> how steep is that learning curve
19:42:46 <cfraz89> not a fan of spacemacs actually
19:42:54 <cfraz89> found it really slow compared to vanilla emacs
19:43:25 <maerwald> It has a few thousand keybindings. Hope you never mistype anthing
19:53:03 <travv0> i use spacemacs but it's definitely painfully slow
20:07:37 <p0a> I'm reading "Haskell: The craft of functional programming" v3 and I'm seriously confused on chapter 2, the author says open PicturesSVG.hs"
20:07:49 <p0a> I'm confused, there's no mention of this file before, where is it? 
20:07:53 <p0a> I'm reading the book from the beginning
20:09:35 <rotaerk> p0a, maybe it's these downloadable resources? http://catalogue.pearsoned.co.uk/catalog/academic/product?ISBN=9780201882957#downlaoddiv
20:09:56 <p0a> rotaerk: maybe, I just find it absurd that it wasn't mentioned so far anywher 
20:10:26 <p0a> rotaerk: oh wow, they want me to sign it (not doing that)
20:10:50 <p0a> downloadable resources *with a twist!
20:11:06 <silverneedle> ive been reading 'Programming in Haskell' by Graham Hutton, highly recommend so far 
20:11:18 <silverneedle> so far no downloadable resources 
20:11:20 <p0a> darn shitty book holding me hostage
20:11:36 <rotaerk> yeah just get a better book I guess
20:11:38 <p0a> I hate these slow paced books
20:11:38 * hackage b9 0.5.65 - A tool and library for building virtual machine images.  https://hackage.haskell.org/package/b9-0.5.65 (SvenHeyll)
20:11:46 <silverneedle> the one i mentioned is def not slow paced
20:11:50 <p0a> just give me a break I *don't* want to know about 2+3 = 5
20:11:57 <silverneedle> cuts to the chase
20:12:07 <p0a> it's the equivalent of a professor rambling 
20:12:47 <p0a> I'll try a different book maybe or just skip chapters or something
20:12:51 <rotaerk> hmm I have defined `type GLenum = Word32` and I have a bunch of pattern synonyms like `pattern GL_FOO = 0x1234 :: Word32`, though I can change this to have proper type specs.  I now want to generalize these patterns so they work for any numeric type, but I'd rather that type be represented by GLenum
20:13:10 <rotaerk> I've tried: type GLenum = forall a. (Num a, Eq a) => a
20:13:52 <silverneedle> p0a: chec my rec bro
20:14:27 <rotaerk> but then the patterns default to type Integer
20:14:32 <p0a> silverneedle: thanks
20:16:14 <rotaerk> wondering if I need to do something like making a constraint synonym, like type GlEnum a = (Num a, Eq a), and then just use `GlEnum a => a` as the type
20:18:01 <byorgey> rotaerk: that sounds more likely.  GLenum = forall a. (Num a, Eq a) => a  is highly unlikely to be what you want
20:18:23 <rotaerk> k
20:33:53 <p0a> Why is :type isEOFError giving me an error about it not being defined?
20:34:01 <p0a> variable not in scope it says 
20:34:08 <p0a> :type userError works though 
20:34:31 <p0a> whops, it's in IO. sorry
20:38:33 <p0a> It appears that "A gentle introduction to Haskell" is out of date? 
20:38:53 <p0a> https://www.haskell.org/tutorial/io.html Trying the getChar' example I get errors on "Ambiguous type variable 'e0' arising from a use of 'catch'"
20:39:02 <Cale> It's the oldest tutorial probably
20:39:17 <Cale> So you can probably expect a few things which aren't quite the same
20:39:18 <p0a> alright, anything up to date?
20:39:33 <Cale> ah, well, we can just fix that
20:40:39 <p0a> It really looks hard to find something good to learn Haskell  from 
20:40:41 <p0a> lol
20:41:32 <Cale> ah, well, have you tried the CIS 194 course with Brent Yorgey here? http://www.cis.upenn.edu/~cis194/spring13/
20:42:19 <Cale> p0a: You can fix that issue with catch pretty easily by either defining the handler separately and giving it an explicit type signature: IOError -> IO Char
20:42:58 <Cale> or you could turn on ScopedTypeVariables (which will let you give type signatures to variables in patterns), and write the lambda like (\(e :: IOError) -> return '\n')
20:43:12 <p0a> what do you mean by turn on?
20:43:18 <p0a> is it some optional GHC feature?
20:43:24 <Cale> {-# LANGUAGE ScopedTypeVariables #-}
20:43:31 <Cale> add that to the top of your file
20:43:34 <fosterite> it's a language pragma, put it at the top of the file
20:43:42 <p0a> is the language pragma compiler-dependent?
20:43:44 <Cale> or if you're just playing in GHCi, you can :set -XScopedTypeVariables
20:43:59 <p0a> pragmas are also a thing in C++ so I'm familiar with the term 
20:44:05 <Cale> The LANGUAGE pragma itself is standard, and this extension I believe is supported by most implementations
20:44:44 <p0a> Cale: the course looks good
20:44:48 <p0a> Right, so it's not standard :P 
20:44:49 <Cale> Past a certain point, the language itself is fairly modularised, so that new implementations don't have to implement everything all at once
20:44:56 <cansis> @dmj`: ✌️
20:44:56 <lambdabot> Unknown command, try @list
20:45:06 <Cale> and as they implement more of the features, more libraries can be supported
20:45:44 <Cale> some of the "extensions" are really basic things that every implementation has supported from before language extensions were even a thing (just things that didn't make it into the Report)
20:45:51 <Cale> and others are quite involved
20:45:54 <p0a> I'm a Report person
20:45:56 <p0a> sorry
20:46:29 <fosterite> that reminds me did people start working on haskell2020 yet
20:46:29 <Cale> If you want to do anything practical, you won't be for very long -- a lot of libraries pretty much demand that you turn on a half dozen extensions :)
20:46:40 <p0a> that's a bit strange 
20:46:52 <p0a> well I'll try to have *my* stuff not using extensions
20:46:53 <yushyin> Give up on writing standard haskell it is impossible. We all write ghc haskell nowadays
20:47:01 <p0a> that's lame
20:47:07 <p0a> although it makes sense for a new language 
20:47:24 <dmj`> cansis: that you boy ? ;)
20:47:29 <Cale> Despite the fact that there was a Haskell Report in 2010, it didn't actually document all that many new things
20:47:30 <Lears> It's not lame at all; quite the opposite. Haskell is a testbed for functional programming ideas; so the report follows the implementation rather than the reverse.
20:47:38 <Lears> Also, Haskell is ~30 years old.
20:48:06 <cansis> @dmj`: yessir
20:48:07 <lambdabot> Unknown command, try @list
20:48:23 <Cale> and is mostly Haskell 98 + the FFI addendum which came out shortly after the original Report + a handful of minor tweaks + a description of {-# LANGUAGE ... #-} and some unimportant extensions
20:48:41 <cansis> silly old irc client dropping these @ characters
20:48:41 <p0a> When the report follows the implementation it means that it is a relatively new language
20:48:44 <p0a> or still developing 
20:48:48 <MarcelineVQ> haskell is eternally new
20:48:50 <cansis> dmj`: there fixed that
20:48:51 <Cale> It would be really good if Haskell 2020 manages to document more of the extensions
20:48:54 <Lears> Eternally developing, hopefully.
20:49:12 <Cale> I think the Report should *always* follow the implementation
20:49:23 <Cale> Otherwise you're documenting something which doesn't exist and that never works
20:49:30 <fosterite> the report had some flaws too like Arrows are baked in when no one uses them anymore and they're viewed as a flawed attempt at applicatives
20:49:53 <Cale> A few minor changes to Arrow makes it much more useful
20:50:04 <fosterite> I think closed cartesian category people might care about them
20:50:57 <Cale> Before Reflex came along, a lot of the early attempts at functional reactive programming I worked on with Ryan Trinkle used a modified Arrow type class.
20:52:12 <Cale> Also, I don't think Arrows are in the Report
20:52:26 <Cale> are they?
20:52:45 <Cale> I don't see them -- it would surprise me
20:54:25 <Cale> welcome back everyone on the other side of the split
20:55:14 <MarcelineVQ> But what if we were on the wrong side all along..
20:56:15 <Cale> Anyway, even if there's a new Report at this point, it's very likely that the new bits are mostly focused on documenting further extensions
20:56:37 * hackage dhall 1.21.0 - A configuration language guaranteed to terminate  https://hackage.haskell.org/package/dhall-1.21.0 (GabrielGonzalez)
20:57:37 * hackage dhall-json 1.2.7 - Compile Dhall to JSON or YAML  https://hackage.haskell.org/package/dhall-json-1.2.7 (GabrielGonzalez)
20:58:13 <p0a> How can I have a pattern match for one or less items?
20:58:31 <Cale> You can pattern match for [] and for [x]
20:58:38 * hackage dhall-text 1.0.16, dhall-bash 1.0.19 (GabrielGonzalez): https://qbin.io/laden-xbox-7xg2
20:58:47 <p0a> so it's two expressions, no shortcuts?
20:58:51 <Cale> or you can pattern match on (x:y:xs) first, and then have a fall through
20:58:58 <p0a> What's a fall through?
20:59:13 <Cale> I mean, like the next pattern just matches with _ or a simple variable
20:59:24 <Cale> The patterns are in priority order
20:59:27 <p0a> ah, so you're saying since it failed it
20:59:28 <p0a> got you
20:59:44 <Cale> That case doesn't come up too often it seems
21:00:00 <Cale> Usually your patterns when working with lists are exactly [] and (x:xs)
21:00:10 <Cale> but occasionally you'll want something more
21:00:45 <p0a> yeah it can happen 
21:01:02 <p0a> this exercise wants me to double the numbers in the even indices for example
21:01:55 <Cale> If you want to handle two patterns in the same way, it may be useful to do the pattern matching with a case expression so that you can define the common bits in a (let ... in ...) expression or a where clause attached to your declaration
21:02:47 <Cale> yeah, that exercise does kind of look for pattern matching two at a time
21:03:00 <Cale> There are other solutions as well, but you'd be unlikely to know them at that point :)
21:03:15 <p0a> not sure what you're thinking of
21:03:24 <Cale> > zipWith ($) (cycle [id, (*2)]) [1..10]
21:03:26 <lambdabot>  [1,4,3,8,5,12,7,16,9,20]
21:03:35 <p0a> so it's a lazy solution 
21:03:42 <p0a> and you know what cycle does :P you're right. I wouldn't know
21:04:07 <p0a> also zipWith and application ($)... 
21:04:10 <Cale> > cycle [1,2]
21:04:13 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
21:04:16 <Cale> > cycle [1,2,3]
21:04:18 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
21:04:27 <p0a> cycle [cycle]
21:04:35 <Cale> :t cycle [cycle]
21:04:36 <lambdabot> [[a] -> [a]]
21:04:59 <Cale> :t cycle [cycle, reverse, id]
21:05:00 <lambdabot> [[a] -> [a]]
21:05:01 <p0a> just me being silly
21:05:31 <Cale> zipWith takes a function and two lists, and combines the lists elementwise with the function
21:05:45 <Cale> > zipWith (+) [1..] [10,20..]
21:05:47 <lambdabot>  [11,22,33,44,55,66,77,88,99,110,121,132,143,154,165,176,187,198,209,220,231,...
21:06:04 <Cale> ($) is just function application:
21:06:06 <Cale> f $ x = f x
21:06:54 <Cale> (its reason to be is that it has very low precedence, i.e. it binds very weakly to its arguments, and so is a bit like putting parens around either side of itself
21:06:56 <Cale> )
21:07:31 <p0a> yup 
21:07:31 <Cale> You'll often see people write things where they'll compose a bunch of functions together with (.) and then apply the resulting composite function to an argument with ($)
21:07:39 <Cale> like  f . g . h $ x
21:07:41 <p0a> honestly I'm familiar with some basic stuff with haskell
21:07:55 <p0a> and if I would forget something about precedence and stuff like that I'd just test it on ghci quickly before using t 
21:08:08 <p0a> the part I'm hvaing trouble with is IO, monads, modules, data types 
21:08:15 <Cale> So zipWith ($) takes a list of functions and a list of values, and applies each function to the corresponding value
21:08:22 <p0a> and ignorance of the standard library and utilities
21:08:40 <p0a> yeah you had a list of functions and a list of integers and you applied each to each
21:08:45 <Cale> and cycle [id, (*2)] is the list of functions which alternates between the identity function  id x = x  and the function which multiplies by 2
21:08:46 <p0a> which looks like a zipper
21:09:34 <Cale> Yeah, a bit like a literal zipper (though the term zipper is also used as a technical term for a different sort of data structure)
21:10:31 <Cale> anything in particular you'd like to ask about IO or any of that other stuff?
21:11:17 <p0a> hm...  
21:11:21 <Cale> The main thing to wrap your head around with IO isn't really monads, though it will help you to learn some of the Monad operations eventually, the more mind-bending thing is just that IO actions are values.
21:11:35 <Cale> i.e. that IO a is a type at all
21:11:42 <p0a> I'm a bit comforable with that 
21:11:49 <p0a> I see that putChar 'a' for example is a value
21:12:05 <p0a> the way I see it, at the end, they go like action >> return and that does something 
21:12:05 <Cale> yeah, it's a value which describes the action of printing the letter 'a' on the screen
21:12:23 <Cale> Well, return is specifically a function that produces an action which does nothing
21:12:45 <Cale> i.e. for any value v, the action  return v  does nothing, and produces v as its result
21:13:19 <Cale> The thing which makes IO actions happen in a compiled program is that 'main' is an IO action, and it is executed.
21:13:39 <p0a> ah okay 
21:13:48 <p0a> and in the interpreter IO actions are executed 
21:13:53 <p0a> as they're encountered 
21:14:06 <Cale> This execution, the carrying out of the instructions described by IO actions, is a separate (though intertwined) process from evaluation (the reduction of expressions to values, for the purposes of matching patterns)
21:14:07 <benzrf> p0a: you can think of it almost as if haskell is a macro language for some object language - the macro language cannot cause effects, but it can produce a program that causes effects
21:14:13 <Cale> yeah
21:14:24 <p0a> well the point is, you /have/ to 'end' with an IO action value 
21:14:34 <p0a> so that's why usually you have stuff >> return or something else that returns IO 
21:14:42 <Cale> In GHCi, if it sees that you've given it an IO action, it executes it immediately, and then it checks if it can print the result as well, and if it can, it prints it.
21:15:02 <benzrf> the trick is that there is, as Cale mentioned, some interleaving going on - where you can use haskell code to operate on user input, so it's not really valid to think of it in terms of macros, ultimately
21:15:24 <Cale> Well, tacking on a return like that lets you decide what the result of your IO action will be, rather than leaving it up to the last action in your chain of actions
21:15:30 <p0a> what I'm interested in is making a video game 
21:15:32 <Cale> e.g.
21:15:49 <Cale> do x <- getLine; y <- getLine; return (x ++ y)
21:15:50 <p0a> It's not a very complicated one, maybe a text game even or at most a 2D SDL game 
21:16:10 <p0a> so I'd definitely need some data type knowledge.In C++ I'd be using classes
21:16:38 <Cale> Yeah, definitely learn about 'data'
21:16:41 <p0a> Cale: Yeah
21:17:22 <Cale> So, do-notation like that is a way of gluing together smaller IO actions into larger ones
21:17:55 <Cale> This do-expression I wrote above denotes the action which will execute getLine twice, and produce the concatenation of the lines typed as its result
21:18:17 <Cale> When we write  v <- x  inside a do-block, it means "execute the action x, and call its result v"
21:18:22 <Cale> If x :: IO a, then v :: a
21:18:44 <Cale> and you'll have access to that result throughout the rest of the do-block
21:19:00 <Cale> The result of the combined IO action is the result of the last action in it
21:19:27 <Cale> We use 'return' to make an action which will have no further effect, but produces the result we want
21:20:09 <Cale> Note that return isn't a keyword, and doesn't have any of the control effects you might expect from imperative languages -- if it occurs in the middle of a do-block, it's a no-op
21:21:17 <p0a> right 
21:21:20 <p0a> it's an action with no effect 
21:21:26 <Cale> right
21:23:56 <Cale> One thing which is really nice about this way of doing things is that it becomes really easy to define our own control structures recursively
21:24:20 <Cale> For example, suppose we didn't already have a for-each loop in the libraries, we could write one by recursion on a list
21:24:42 <Cale> Say, forEach :: [a] -> (a -> IO b) -> IO [b]
21:25:05 <Cale> i.e. it takes a list of values of type a, and some function which given a value of type a will produce an action having a result of type b
21:25:22 <Cale> and it's going to glue all the actions together somehow into a single action producing a list of all the results
21:25:38 <Cale> forEach [] = ... -- we'll start with the empty list
21:25:58 <Cale> oops
21:26:11 <Cale> forEach [] f = ... -- need the loop body argument :)
21:26:31 <Cale> forEach [] f = return [] -- but we won't use it here, just going to produce an action which does nothing
21:26:51 <Cale> forEach (x:xs) f = ... -- if the list is nonempty
21:27:03 <p0a> Cale: right now I'm seriously confused as to how 4012888888881881 is a valid card number 
21:27:20 <Cale> forEach (x:xs) f = do v <- f x; ... -- first, we'll apply f to the first element of it, and run that action, the first iteration of the loop
21:27:22 <p0a> (by luhn check). I follow the algo and I get 135. Mod 10 that is 5... not zero 
21:28:02 <Cale> p0a: what does your doubleEveryOther look like?
21:28:17 <p0a> I manually did the luhn check and it's 135
21:28:25 <p0a> so my algorithm does what *I* think is right
21:28:34 <p0a> I must be misreading the problem?
21:28:46 <Cale> Did you double them starting from the end?
21:28:52 <p0a> yeah 
21:29:02 <p0a> I used reverse $ show n 
21:29:03 <Cale> It's kind of necessary to reverse the list and then reverse again to make it convenient
21:29:06 <Cale> ah
21:29:14 <p0a> it's not necessary to reverse again since you take a sum right?
21:29:29 <Cale> oh, fair enough
21:29:32 <Cale> yes
21:29:35 <p0a> websites tell me the card checks btw - so I'm confused.
21:30:08 * hackage list-witnesses 0.1.0.0 - Witnesses for working with type-level lists  https://hackage.haskell.org/package/list-witnesses-0.1.0.0 (jle)
21:30:47 <p0a> https://pastebin.com/fmLth8ui -- sorry not sure how to use gist.github.com
21:31:15 <p0a> also my function names are different unfortunately I sort of ignored that part of the exercise
21:31:31 <p0a> aah
21:31:37 <p0a> I'm dropping the last number. I just saw it 
21:31:44 <p0a> _ = _ should've been. not _ = []
21:31:46 <p0a> oh dear
21:32:53 <Cale> modding by 10 isn't quite what you want
21:33:18 <p0a> remainder right?
21:33:26 <Cale> you want to mod the individual numbers by 9 (i.e. 10 = 1)
21:33:32 <p0a> (btw I caught a mistake but that wasn't the problem since the number has an even number of digits)
21:33:36 <Cale> er, I'm not even sure that's right ;)
21:33:42 <Cale> probably 9 is just left as 9
21:33:59 <p0a> Cale: but the exercise ssays to sum the digits 
21:34:08 <Cale> but, e.g. 16 contributes 1 + 6
21:34:12 <Cale> not just 6
21:34:13 <p0a> and mod the sum by 10 
21:35:07 <p0a> right. It's only clarified in the example. "[2,3,16,6] becomes 2+3+1+6+6"
21:35:11 * p0a is triggered
21:37:28 <MarcelineVQ> luckily you've already written a function that turns 16 into [1,6], if I recall the exercises
21:40:14 <p0a> yeah I did it 
21:40:17 <p0a> thankyou 
21:40:46 <p0a> Im so triggered lol
21:41:03 <p0a> I wasted like 5 hours setting up emacs+haskell and doing 1 exercise
21:42:07 <p0a> and what's up with this exercise anyway
21:42:13 <Cale> There are many yaks yet to be shaven
21:42:42 <Cale> I think it's just something to help you get used to lists and the syntax
21:43:13 <p0a> yeah I think I learned a bit a bout the pattern matching thing 
21:43:24 <p0a> It's just that having so much experience in programming in general I get frustrated with these things
21:43:35 <p0a> where everyone assumes I'm a complete newbie and I should be doing fizzbuzzes 
21:44:17 <p0a> and you skip ahead a few chapters and now everything depends on things said 3 chapters ago (but carefully hidden in verbose rambling paragraphs and menial examples)
21:44:38 <p0a> 1 + 2 = 3 ...by the way we define 'foo' to be this... 2 + 3 = 5
21:44:45 <Cale> Yeah, when I started programming in Haskell, I knew like 15 or so other programming languages already, and it took me a couple months to feel like I could really get anything useful done
21:44:56 <Cale> and then about a year to be comfortable, for some value of comfortable
21:45:07 <p0a> can't say I'm anywhere close to that honestly
21:45:20 <Cale> It's sort of like learning your first programming language again
21:45:52 <p0a> I guess I don't like toy examples
21:45:54 <p0a> or ramblings 
21:45:59 <Cale> which can be a bit offputting at first, but there are advantages to almost every difference that will trip you up
21:46:19 <Cale> at least the ones which will really be annoying the first time you run into them ;)
21:46:36 <p0a> "Like many programming languages, Haskell allows programmers to create their own enumeration types. " Like, that sentence is of no value 
21:46:59 <Cale> what do you mean?
21:47:01 <p0a> I was not expecting Haskell to be one of /those other/ languages that can't do anything
21:47:05 <Cale> haha
21:47:37 <Cale> Well, give it a minute
21:47:43 <Cale> because they're not just enumerations
21:47:48 <Cale> they're something better
21:48:37 <p0a> im just so sad for spending 5 hours on this 
21:48:55 <p0a> I couldn't set up haskell correctly because I misspelled 'haskel' in my .emacs
21:49:51 <p0a> I feel like such a whiner
21:50:00 <ski> @where haskel
21:50:00 <lambdabot> <http://web.archive.org/web/20070703001910/http://www.cs.chalmers.se/~augustss/pics/haskel.gif>
21:51:12 <MarcelineVQ> haskel, that's a weird name for a maus
21:51:54 <p0a> lol that rings a bell. are you referencing some show?
21:52:10 <ski> maybe it's more common among schemers ?
21:52:55 <MarcelineVQ> it's from the graphic novel Maus :>
22:04:26 <p0a> anyway, sorry for all the whining, thank you Cale for your patience & help and cheers for the upenn website, it definitely looks good
22:58:09 <p0a> Hello I have a file Log.hs from upenn's second lecture exercise 
22:58:11 <p0a> that loads fine
22:58:27 <p0a> I also have a LogAnalysis.hs that has ``module LogAnalysis where <newline> import Log''. 
22:58:52 <p0a> But when I load it, it says "Failed to load interface for 'Log'"
22:58:55 <p0a> any hints on what is going on?
23:04:06 <p0a> Even the simplest modules I can't import actually
23:04:22 <p0a> like I have two files Test.hs and Test2.hs but I can't say "module Test where ... import Test2" 
23:05:51 <clever> p0a: goes Log.hi exist?
23:06:00 <clever> does*
23:06:16 <p0a> yeah 
23:06:25 <clever> what are the permissions on it? its size?
23:06:44 <p0a> I made a simple testcase with Test.hs and Test2.hs where Test2.hs has "module Test2 where ..." and Test.hs has "module Test where ... import Test2"
23:06:47 <p0a> but it won't work
23:06:51 <p0a> let me check permissions
23:07:35 <p0a> clever: chmod 777 does nothing 
23:07:43 <p0a> still the same error 
23:08:36 <p0a> clever: https://pastebin.com/dfFUSNdU
23:08:51 <clever> not sure what else it could be
23:09:02 <p0a> so that code looks good?
23:09:14 <clever> yeah
23:09:22 <p0a> extremely frustrating 
23:09:31 <clever> how are you running ghc on it?
23:09:40 <p0a> through haskell-mode
23:09:44 <p0a> I just hit C-c C-l in emacs 
23:09:49 <clever> try just the raw ghc binary
23:09:54 <p0a> okay what's the command?
23:10:00 <clever> ghc Test.hs
23:10:24 <p0a> oh that worked
23:10:35 <p0a> sorry about this... it's really late and I'm tired
23:10:45 <clever> then the problem is somewhere in haskell-mode
23:10:53 <yushyin> it's a pity, 5 hours of haskell and you don't know how to invoke the compiler? :(
23:11:19 <p0a> yushyin: well I'm just trying to work out an environment in which I code
23:11:29 <clever> i learned bare ghc first, and didnt bother with cabal or stack for months
23:11:49 <p0a> yushyin: in C++ I use Makefile, in common lisp I have SLIME and the image is just loaded with all the stuff 
23:12:01 <p0a> I guess ghc works a bit different. every time I hit C-c C-l, previous definitions are erased
23:12:09 <p0a> also not sure what's up with this import stuff 
23:12:58 <p0a> I agree it's a pity though
23:13:58 <p0a> clever: so you're saying just learn how ghc/ghci work and use those for now?
23:14:14 <clever> p0a: thats how i learned it
23:15:20 <p0a> clever: to load it in ghci I'd do the same with ghci?
23:15:32 <yushyin> maybe haskell-mode works better with a cabal file? maybe it's some problem with the cwd if no cabal file is present.
23:15:36 <clever> yeah, ghci Test.hs
23:16:44 <p0a> yushyin: I wrote C for years using just gcc 
23:17:05 <p0a> yushyin: and manically alt-tabbing between windowses. Now I had the fine idea to actually setup some sort of IDE before I begin 
23:17:06 <p0a> :P 
23:17:19 <p0a> back to just using ghc 
23:17:30 <clever> p0a: i set my linux machines to focus-follows-mouse
23:17:36 <clever> p0a: so i can swap windows without alt+tab
23:17:50 <Cale> p0a: Yeah, just keep ghci and your editor open at the same time
23:18:00 <p0a> clever: it's a good idea. Right now I don't use the mouse much, I actually do most things in emacs 
23:18:04 <p0a> and it's just keystrokes
23:18:06 <Cale> p0a: and whenever you update your code, you can :r to reload in ghci
23:18:12 <p0a> aah, :r. nice
23:18:18 <clever> oh yeah, ghcid
23:18:31 <clever> just run ghcid Test.hs, and it will :r automatically every time a file is changed
23:18:41 <Cale> There's also ghcid, which is just something that will load ghci and reload for you whenever your source changes
23:18:54 <Cale> and it only displays the errors/warnings
23:19:43 <clever> ghcid -c "cabal repl" also works, for when you switch to cabal
23:19:47 <Cale> right
23:20:01 <Cale> (and then you can also do that from inside a nix-shell ;)
23:20:36 <clever> i run nixos on all of my machines
23:20:41 <Cale> But yeah, it's really useful for being able to do stuff like use a _ in an expression, and GHC will tell you the type of thing which should go there.
23:21:15 <clever> ghcid can also eval an IO expression every time it loops
23:21:16 <clever> and i have used that before, to test file parsing logic
23:22:40 <Cale> For web applications, we have a new-ish tool called obelisk, which has a command "ob run" which basically gives you a ghcid until the build is all good, and then it runs your application backend in the resulting interpreter
23:23:12 <Cale> (and it reloads no matter whether you're changing the backend or frontend)
23:23:14 <clever> Cale: ive had countless problems with threading in ghci
23:23:27 <clever> Cale: the background threads dont always exit cleanly, and then the backend is running, while the ghci prompt is up
23:23:53 <Cale> Yeah, that's a bit of an issue.
23:23:56 <clever> and i cant run the new code, because the old instance (that leaked in ghci) is consuming the pot
23:24:19 <Cale> You can use async in place of forkIO to try to improve the situation.
23:24:32 <p0a> thanks for ghcid
23:36:25 <maerwald> consuming the pot? xD
23:37:47 <p0a> it's a well known concurrency problem
23:40:55 <delYsid> Dependency hell, gah!
23:53:49 <gentauro> yeah, async (a clever way to use `forkFinally` which it actually doesn't use, but similar, to ensure `atomicity`)
23:53:56 <gentauro> is the way to go
23:54:57 <gentauro> I actually looked into Simon Marlows code in order to make my own `poor-mans-concurrency` lib for this code `snippet` (Control.Asynchronous.hs) -> http://blog.stermon.com/articles/2019/02/09/haskell-bitonic-sorter-concurrent.html
23:55:15 <gentauro> I like the simplicity as well as te warranties
23:55:43 <gentauro> Haskell is such an elegant language (clap, clap, clap)
