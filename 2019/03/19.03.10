00:21:39 <janat08> how would you actually use: y = y + 1 in haskell
00:22:07 <janat08> it's just recursive function that doesn't take variables?
00:22:16 <janat08> therefore relatively useless
00:22:25 <merijn> janat08: If you had a num instance with lazy addition it'd work as infinity
00:22:33 <merijn> janat08: It's not a function, though
00:24:29 <janat08> what an enlightening question then, that the course proposed to me (infinite variable)
00:25:16 <merijn> % data Peano = Zero | Succ Peano deriving (Show)
00:25:16 <yahb> merijn: 
00:26:27 <cocreature> it might also be worth pointing out explicitly that most Num instances are _not_ lazy and then this is just an infinite loop
00:28:50 <merijn> % instance Num Peano where { x + Zero = x; x + Succ y = Succ (x + y); x * Zero = Zero; x * Succ y = x + (x * y)l abs x = x; signum Zero = Zerol signum _ = Succ Zero; fromInteger 0 = Zero; fromInteger i = Succ (fromInteger (i-1)); negate x = x; }
00:28:50 <yahb> merijn: ; <interactive>:76:118: error:; parse error on input `='; Perhaps you need a 'let' in a 'do' block?; e.g. 'let x = 5' instead of 'x = 5'
00:29:06 <merijn> hmmm
00:29:18 <merijn> oh, I can't type
00:29:35 <merijn> % instance Num Peano where { x + Zero = x; x + Succ y = Succ (x + y); x * Zero = Zero; x * Succ y = x + (x * y); abs x = x; signum Zero = Zero; signum _ = Succ Zero; fromInteger 0 = Zero; fromInteger i = Succ (fromInteger (i-1)); negate x = x; }
00:29:35 <yahb> merijn: 
00:29:42 <merijn> > 1 + 1 :: Peano
00:29:44 <lambdabot>  error:
00:29:44 <lambdabot>      Not in scope: type constructor or class ‘Peano’
00:29:56 <merijn> % 1 + 1 :: Peano --duh
00:29:56 <yahb> merijn: Succ (Succ Zero)
00:30:08 <merijn> janat08: And now for the interesting magic bit:
00:30:15 <merijn> % let y = y + 1 in y
00:30:20 <yahb> merijn: [Timed out]
00:30:24 <merijn> awww
00:30:31 <merijn> yahb doesn't do limited output?
00:30:43 <merijn> oh, wait
00:30:46 <merijn> % let y = y + 1 in y :: Peano
00:30:47 <yahb> merijn: ; <interactive>:1:23: error: Not in scope: type constructor or class `Peano'
00:31:11 <merijn> % let y = y + (1 :: Peano) in y
00:31:11 <yahb> merijn: ; <interactive>:2:19: error: Not in scope: type constructor or class `Peano'
00:31:18 <merijn> % Zero
00:31:19 <yahb> merijn: ; <interactive>:3:1: error: Data constructor not in scope: Zero
00:31:28 <merijn> % data Peano = Zero | Succ Peano deriving (Show)
00:31:28 <yahb> merijn: 
00:31:34 <merijn> % instance Num Peano where { x + Zero = x; x + Succ y = Succ (x + y); x * Zero = Zero; x * Succ y = x + (x * y); abs x = x; signum Zero = Zero; signum _ = Succ Zero; fromInteger 0 = Zero; fromInteger i = Succ (fromInteger (i-1)); negate x = x; }
00:31:35 <yahb> merijn: 
00:31:39 <merijn> % let y = y + (1 :: Peano) in y
00:31:45 <yahb> merijn: Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ
00:31:57 <merijn> There we go :)
00:32:45 <janat08> merijn: I believe it's still basically useless
00:33:18 <merijn> janat08: Mostly, yes :p
00:33:51 <merijn> janat08: But the same type of recursion also lets you do useful things
00:34:08 <merijn> > let ones = 1:ones in ones -- like constant space infinite lists!
00:34:10 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
00:34:38 <merijn> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs -- or neat fibnacci sequences!
00:34:40 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
00:58:16 <perspicus> Hi all - having trouble understanding the second snippet in this tutorial on the Writer monad: https://kseo.github.io/posts/2017-01-21-writer-monad.html. 
00:58:40 <perspicus> type sig for the "calc" variable is calc :: Writer [LogEntry] Integer
00:58:55 <perspicus> however printing out in ghci shows: *Main λ> calc WriterT (Identity (500000500000,[LogEntry {msg = "start"},LogEntry {msg = "500000500000"},LogEntry {msg = "done"}]))
00:59:06 <perspicus> ie - the type is WriterT, not Writer
00:59:53 <perspicus> I understand that this is the monad transformer for Writer, however why is this mismatch between declaration and actual type tolerated, and why does it occur?
01:01:16 <merijn> perspicus: Writer is just a typesynonym
01:01:46 <merijn> perspicus: Writer/Reader/State, etc. used to exist as separate types, but are nowadays just type aliases for "WriterT w Identity", etc.
01:03:20 <perspicus> merijn: thanks for the tip, makes sense.
03:20:08 * hackage grids 0.4.0.0 -   https://hackage.haskell.org/package/grids-0.4.0.0 (ChrisPenner)
03:46:14 <bolverkr> Hi guys, I have a question. I have a Main module that imports another module. However, this module only exports a couple of its functions like so: ‘module Level02.Core (runApp, app) where…’ . Does someone know if there is a way to run ‘cabal new-repl executable’ so that I can test all the functions from ghci? Or do I have to temporarily remove the scope definition and just leave it as ‘module Level02.Core where’
03:59:37 * hackage chronos-bench 0.2.0.1 - Benchmarking tool with focus on comparing results.  https://hackage.haskell.org/package/chronos-bench-0.2.0.1 (knupfer)
04:02:06 <Lears> bolverkr: if you load a module directly from its source code with `:l Path/To/Module.hs` rather than importing it, you should have its entire top-level scope.
04:02:07 <thebigj> Me and codingquark are learning Haskell from Learn you a Haskell from great good!
04:02:11 <thebigj> We are live streaming here https://www.twitch.tv/jaysinhp
04:02:42 <thebigj> If you want to be a part of it, then join us https://meet.jit.si/LearnHaskell
04:14:37 * hackage hcheckers 0.1.0.0 - Implementation of checkers ("draughts") board game - server application  https://hackage.haskell.org/package/hcheckers-0.1.0.0 (IlyaPortnov)
04:18:45 <maerwald> https://gitlab.haskell.org/ what's with the certificate
04:44:06 <portnov1> hi all.
05:04:12 <thebigj> I am learning haskell from Learn you a Haskell for great good!
05:04:18 <thebigj> I am stuck at comparing list operator.
05:04:23 <thebigj> https://dpaste.de/Bcaj/raw
05:04:32 <thebigj> Here, this comparision [3,2,1] > [2,10,100] is returning True
05:04:37 <thebigj> We are confused how is it returning True?
05:04:43 <thebigj> The book is not giving any explaination on how to comparision s are handled inside
05:04:48 <thebigj> Though it tells it is comparing heads first and move forward
05:04:53 <thebigj> but What are the heads here?
05:04:56 <thebigj> Thanks!
05:05:12 <__monty__> thebigj: Looks like lexical comparison.
05:05:28 <thebigj> __monty__: What is lexical comparision?
05:05:29 <__monty__> So just compare the first two, if equal compare the next two, etc.
05:05:53 <maerwald> It's a pretty useless operator for lists, yeah
05:05:55 <thebigj> So here 3 > 2 will be compared first/
05:05:55 <thebigj> ?
05:06:02 <__monty__> Do you know the function `head`?
05:06:04 <__monty__> :t head
05:06:05 <lambdabot> [a] -> a
05:06:09 <chkl[m]1> The 'head' of a list is the first element of a list. (e.g. in Haskell  `> head [1,2,3]` evaluates to `1`).
05:06:15 <__monty__> > head [3, 4, 2]
05:06:17 <lambdabot>  3
05:06:26 <thebigj> OKay.
05:06:54 <thebigj> Let me explain, [3,2,1] > [2,10,100] here  3 > 2 will be compared first
05:06:58 <thebigj> Which is True
05:07:12 <thebigj> Is it comparing 2 > 10 then?
05:07:18 <thebigj> Which isn't looking True to me
05:07:30 <thebigj> So shouldn't it return False?
05:08:04 <thebigj> __monty__: ^^
05:08:09 <__monty__> thebigj: No, you only compare the next elements if the first weren't conclusive.
05:08:36 <__monty__> 3 > 2 implies [3,2,1] > [2, a million]
05:08:44 <Entroacceptor> > [2,3,2] > [2,2,2]
05:08:46 <lambdabot>  True
05:10:03 <__monty__> thebigj: Lexical order is like a dictionary is ordered. Aardvark is first because the first two letters are 'a', the rest of the word doesn't matter.
05:16:45 <__Myst__> hi, haskell-ide-engine does not seem to observe the cabal file?
05:17:01 <__Myst__> it says that module X belongs to hidden package Y 
05:17:11 <__Myst__> but it package Y is listed in the cabal file
05:17:18 <__Myst__> (this is the test-suite not the main program)
05:24:47 <__monty__> __Myst__: You mean HIE and not intero?
05:27:03 <__Myst__> __monty__: i am running the hie-wrapper binary so i think so
05:37:09 <jollygood2> hi. I'm using mapConcurrently from async to download several pages at once, and every once in a while I get HttpExceptionRequest. I want to try to recover and attempt to download several times before giving up. are there any functions in async that can assist me in this, or do I have to manually catch the exception and retry?
05:42:43 <jollygood2> something like this would work. retryCountDelay :: Int -> Int -> IO a -> IO a . it would be nice if I could give it the type of exception to intercept, but I'm not sure how. dummy argument, and then pass undefined?
05:49:52 <Solonarv> I'd go with something like 'retryCountDelay :: Exception e => Int -> Int -> (e -> Bool) -> IO a -> IO a'
05:51:00 <Solonarv> if you want to retry on any HttpException, you can pass '\(_ :: HttpException) -> True' for the 'e -> Bool' argument
05:51:40 <Solonarv> but you're also free to (for example) inspect the HttpException and check the status code; for some status codes it doesn't make sense to just keep retrying
05:51:41 <jollygood2> what is the Bool for? 
05:51:50 <jollygood2> oh
05:52:04 <jollygood2> good idea
05:55:48 <jollygood2> how do I rethrow exception? just throwIO e?
05:55:57 <Solonarv> yup
06:04:34 <jollygood2> I like the bool thing, but I'd also like to give a version that doesn't require it, or the ScopedTypeVariables extension. what is the usual method of passing a type without the function accepting argument of that type?  I recall typeOf or similar function in some functions I used a while ago
06:04:42 <jollygood2> typeOf = undefined?
06:04:55 <jollygood2> actually that would require a dummy argument
06:05:00 <hpc> a proxy?
06:05:27 <jollygood2> Data.Proxy?
06:06:02 <hpc> yes
06:12:48 <jollygood2> :type asProxyTypeOf 123 (Just (undefined :: Word8))   <- that looks a bit noisy
06:14:20 <hpc> use the data type
06:14:28 <hpc> Proxy :: Proxy (Void, Int -> Int)
06:15:05 <hpc> then to use it, you'd pass it as a parameter to stuff like foo :: Proxy a -> a
06:15:15 <jollygood2> ah
06:15:18 <hpc> (except not that exact type, it's impossible)
06:19:52 <jollygood2> I need to reuse e typevariable in the inner function for this to work. am I doing something wrong? ScopedTypeVariables are on, and I declared the function like this: retryCountDelay :: (Exception e) => forall a e. Int -> Pico -> IO a -> IO a
06:20:12 <jollygood2> declaration of inner function: retry :: e -> IO a   
06:20:17 <dmwit> jollygood2: For pre-TypeApplications tech, I like Tagged in place of Proxy for many things.
06:20:31 <dmwit> jollygood2: Post-TypeApplications, I like type applications best.
06:21:03 <jollygood2> dmwit, I like it too, but I'm not sure I like the idea of having to turn the language feature on just to call a function
06:22:08 <dmwit> Okay. If you don't want to use AAT+TA, then you should either `retryCountDelay :: forall a e. Exception e => Tagged e (Int -> Pico -> IO a -> IO a)` or `retryCountDelay :: forall a e. Exception e => proxy e -> Int -> Pico -> IO a -> IO a`.
06:22:27 <dmwit> err
06:22:37 <dmwit> that latter one should be `forall proxy a e. ...`, of course
06:27:43 <jollygood2> wth, I'll go with typeapplication
06:27:57 <jollygood2> having some issues satisfying the types though:
06:28:53 <jollygood2> https://bpaste.net/show/5572508710eb
06:29:05 <jollygood2> error is at line 12
06:30:56 <jollygood2> oh, I need type application there?
06:31:16 <jollygood2> why can't it figure out that it is the same e?
06:31:22 <dmwit> Why should it be the same e?
06:31:48 <dmwit> And yes, you need one of type applications, proxy, or Tagged, as we've now told you three times...
06:32:23 <jollygood2> because I'm using ScopedTypeVariables and forall syntax, precisely to tell the compiler that it is the same way. 
06:32:41 <jollygood2> it is the same e*
06:32:44 <dmwit> All you've *actually* said is that handle's e is the same e.
06:32:53 <dmwit> You haven't mentioned e at all in the call to retryCountDelay.
06:33:16 <dmwit> (And before you ask: no, you can't fix it by giving a type signature there.)
06:33:55 <jollygood2> ok, this worked. retryCountDelay @_ @e (count-1) delaySec action
06:34:54 <jollygood2> maybe a bit more readable: retryCountDelay @a @e 
06:38:19 <siers> Can I make ghc offer me a type? Like expression :: ABigType Something _fillthis SomethingElse
06:38:33 <siers> like partially constrain a type
06:38:48 <jollygood2> type hole?
06:38:59 <jollygood2> expression :: ABigType Something _ SomethingElse
06:39:15 <dmwit> :t [] :: _ Int
06:39:16 <lambdabot> error:
06:39:16 <lambdabot>     • Found type wildcard ‘_’ standing for ‘[]’
06:39:16 <lambdabot>       To use the inferred type, enable PartialTypeSignatures
06:39:23 <siers> oooh!
06:39:45 <siers> so I guess I didn't look at compiler's output closely enough
06:40:22 <jollygood2> it can be used in expressions too. "hello" ++ _
06:40:37 <dmwit> :t [] :: _canYouNameIt Int -- ? can't recall
06:40:38 <lambdabot> error:
06:40:38 <lambdabot>     • Couldn't match type ‘_canYouNameIt1’ with ‘[]’
06:40:38 <lambdabot>       ‘_canYouNameIt1’ is a rigid type variable bound by
06:40:57 <dmwit> Hah, no, although the error still suggests a replacement, funnily enough.
06:41:07 <jollygood2> :)
06:47:52 <emacstheviking_> I thought I understood but obv. not... I have been trying to use the first command line argument as an argument to a function that reads in the lines of that file and then classifies each line of that file (reading markdown) and I thought I could manage it as a one liner. x <- (map lineType) <$> splitFile <$> head <$> getArgs     but I am getting IO ( IO [String])....I smell join but I think I have misunderstood something abo
06:49:18 <jollygood2> that usually means you are using fmap (which is what <$> is) instead of =<<
06:49:24 <dmwit> You cut off at "misunderstood something abo".
06:49:31 <dmwit> But presumably `splitFile` does some IO.
06:49:43 <emacstheviking_> splitFile :: String -> IO [String]
06:49:44 <jollygood2> try (untested): x <- map lineType . splitFile . head =<< getArgs
06:50:02 <emacstheviking_> lineType :: String -> LineType
06:50:09 <dmwit> And if that's correct, then `(<$>)` probably isn't the right combinator to use with it, because `(<$>) :: (a -> b) -> IO a -> IO b` -- note no `IO` on `b`.
06:50:12 <jollygood2> oh, that probably won't work
06:50:47 <dmwit> fmap head getArgs >>= fmap (map lineType) . splitFile -- perhaps
06:51:29 <dmwit> fmap (map lineType) . splitFile =<< fmap head getArgs -- might be more readable, since the eye travels in the same direction for the entire control flow
06:52:17 <dmwit> Breaking this down:
06:52:30 <dmwit> head <$> getArgs -- so far so good, and has type IO String
06:53:19 <emacstheviking_> :dmwit I have three scribbled pages of A4 following the types and I still got confused
06:53:22 <dmwit> splitFile <$> head <$> getArgs -- not good at this point; since splitFile :: String -> IO [String], then (splitFile <$>) :: IO String -> IO (IO [String])
06:53:36 <emacstheviking_> that's where it blew up on my brain!
06:53:50 <dmwit> Choices at this moment are
06:54:03 <dmwit> 1. join (splitFile <$> head <$> getArgs)
06:54:21 <dmwit> 2. (head <$> getArgs) >>= splitFile
06:54:35 <emacstheviking_> yes, I had join but failed to make it play
06:54:58 <dmwit> N.B. one way of defining (>>=) is `m >>= f = join (f <$> m)`, so those two choices are intimately related.
06:55:04 <phadej> getArgs >>= splitFile . head
06:55:15 <phadej> splitFile . head =<< getArgs
06:55:31 <jollygood2> you are missing map lineType
06:55:58 <jollygood2> fmap (map lineType) . splitFile . head =<< getArgs
06:56:31 <emacstheviking_> but fmap is <$> isn't it so I tried (map lineType) <$> .....
06:56:52 <emacstheviking_> sigh, somedays I think I am too think to actually understand haskell, not being a maths dude
06:57:06 <jollygood2> (map lineType <$>) . splitFile . head =<< getArgs
06:58:15 <jollygood2> I'm not sure if this is an improvement.. :)  ((lineType<$>) <$>) . splitFile . head =<< getArgs
06:58:40 <phadej> let ffmap f = fmap (fmap f) in ffmap lineType . splitFile . head =<< getArgs
07:00:01 <emacstheviking_> I am going to cut and paste out all the suggestions and think it through. Thanks again all of you! :)
07:01:08 <phadej> those rewrites are "just" applications of monad and functor laws
07:02:06 <jollygood2> here's one more: getArgs <&> head >>= splitFile <&> map lineType
07:02:27 <phadej> jollygood2: that doesn't work for sure
07:02:32 <jollygood2> it works
07:02:42 <phadej> :i <&>
07:02:47 <phadej> % :i <&>
07:02:48 <yahb> phadej: (<&>) :: Functor f => f a -> (a -> b) -> f b -- Defined in `Data.Functor'; infixl 1 <&>
07:02:55 <dmwit> emacstheviking_: And, to complete the spectrum, it might be interesting to see it in do notation as well: `do { args <- getArgs; lines <- splitFile (head args); return (map lineType lines) }`
07:03:27 <phadej> % :i >>=
07:03:27 <yahb> phadej: class Applicative m => Monad (m :: * -> *) where; (>>=) :: m a -> (a -> m b) -> m b; ...; -- Defined in `GHC.Base'; infixl 1 >>=
07:03:31 <jollygood2> it's a flipped <$>
07:03:34 <dmwit> (This is the most readable of them all for me.)
07:03:55 <dmwit> jollygood2: Have you tested in ghci that this works? It looks super sure not to work to me.
07:04:00 <jollygood2> dmwit, yes
07:04:08 <dmwit> jollygood2: The thing on the right does IO, no?
07:04:09 <phadej> jollygood2: getArgs <&> head >>= \ arg -> splitFile arg <&> map lineType
07:04:10 <phadej> would work
07:04:18 <dmwit> jollygood2: Or does it bind as (getArgs <&> head) >>= ... ?
07:04:27 <phadej> dmwit: to the left
07:04:37 <phadej> see my % :i :)
07:05:07 <phadej> ah true, (getArgs <&> head >>= splitFile) <&>  map lineType
07:05:17 <phadej> well, it's a little head scratcher already
07:05:47 <jollygood2> https://bpaste.net/show/ce541da86474
07:06:32 <dmwit> wild
07:07:04 <phadej> makes sense it's "getArgs ??? head ??? splitFile ??? map lineType" pipeline
07:07:17 <phadej> and then you ask what those operators should be for types to match
07:08:27 <phadej> but I'd rather use `do` notation
07:09:48 <thebigj> Me and codingquark just ended our live session. Here is the video https://www.twitch.tv/videos/393317028##
07:09:51 <thebigj> Me and codingquark just ended our live session. Here is the video https://www.twitch.tv/videos/393317028##
07:09:54 <thebigj> Please share your comments. Thanks!
07:18:32 <finnkauski> hey folks. learning haskell here. i get concepts of recursion within functions and the ideas of folds and scans but for some darn reason this confuses me: `fibs = 1 : scanl (+) fibs`
07:18:37 * hackage grids 0.5.0.0 -   https://hackage.haskell.org/package/grids-0.5.0.0 (ChrisPenner)
07:19:09 <finnkauski> ther fasct that it recurses back onto the list itself but continues to scan just breaks my brain a bit. any quick help to get my hed round whats happening there 
07:19:11 <finnkauski> ?
07:20:38 <cocreature> finnkauski: try expanding the definition of scanl a few times and you should see how this works
07:22:32 <ski> finnkauski : how about `fibs = 0 : 1 : zipWith (+) fibs (tail fibs)' ?
07:22:41 <ski> do you grok that ?
07:22:46 <finnkauski> i did: for something like `scanl (+) [1..3]` i can unfurl it into [1, 1 + 1, (1 + 1) + 2, ((1+1)+2) + 3] but when it comes to how does fibs come into play on itself is what breaks my mind 
07:22:58 <finnkauski> ski: lemme jsut comprehend :D 
07:24:15 <cocreature> do it for this exact definition, not some other expression
07:24:44 <ski> finnkauski : i think the one you pasted is missing a starting state argument to `scanl'
07:25:01 <ski> (unless `scanl1' was meant, but it looks like that would give a different sequence)
07:25:11 <finnkauski> ski: yes sorry 1 is the starting point for that one 
07:25:14 <ski> (btw, my version starts at `0', since `F(0) = 0')
07:25:17 * ski thought so
07:25:23 <finnkauski> ski: i didn't paste it. just write it at 
07:25:29 <finnkauski> wrote*
07:25:44 <ski> did you construct your example, or did you read it somewhere ?
07:25:48 <finnkauski> im reading the haskell programming from first principles and like 30 % in
07:25:53 <ski> ok
07:26:28 <cocreature> fibs = 1 : scanl (+) fibs -> fibs = 1 : scanl (+) 1 (1 : scanl (+) 1 fibs) -> fibs = 1 : 1 : scanl (+) (1 + 1) (scanl (+) 1 fibs) -> …
07:26:42 <ski> (imho, it makes more sense to start at `0'. in any case, you should *certainly* not start by defining `F(0) = 1',`F(1) = 1')
07:26:49 <finnkauski> sorry well, the question of `fibs` how does it recurse back onto itself is the key bit i wanna comprehend, but the scanl example i said after was just to show i can unfurl and comprehend that but not the fibs one 
07:27:13 <finnkauski> cocreature: thanks, gonna copy paste and try mind compiling that :D 
07:27:47 <ski> (iow, if you want to start the sequence at `1', then you need to start at `F(1) = 1',`F(2) = 2' (or i suppose `F(2) = 1',`F(3) = 2', if you want an injective sequence, iow without repetition. i think some applications may want that)
07:28:01 <cocreature> finnkauski: don’t copy it, grab a piece of paper and work through it yourself
07:28:34 <jollygood2> re my earlier question about retryCountDelay, is it possible to supply the type of more than one exception in one call, either with TypeApplication or Proxy? or do I need one call per exception?
07:28:52 <finnkauski> cocreature: the first bit of scanl is missing a starting value though 
07:28:54 <jollygood2> I guess I need one call per exception
07:29:00 <finnkauski> dammit, i need a pen and paper 
07:30:01 <ski> finnkauski : yea, *don't* copy (or substitute) `1 : scanl (+) 1 fibs' into the place of `fibs'. instead give the existing `scanl (+) 1' a name, say `fibs2', giving you `fibs = 1 : fibs2 where fibs2 = scanl (+) 1 fibs', *then* expand `fibs' into `fibs2' and compute `scanl' one step
07:30:21 <ski> finnkauski : you can do this in an editor, if you prefer
07:30:34 <finnkauski> ski:  good idea! sorry, that definitely is pretty obvious
07:30:57 <ski> (i'd do in here, except that could spoil you the fun and insight of working the details out for yourself)
07:31:12 <finnkauski> ski: but also the definition by cocreature makes sense, the first iteration adds another 1 in the front of it, in which case then the proper scan can kick in and do the summations further down 
07:31:25 <finnkauski> ski: yeah, don't. I'm keen to do it!
07:31:48 <finnkauski> in general, this whole getting some haskell in my system has melted my brain and helping it rebuild 
07:32:31 <ski> finnkauski : btw, giving it a name (think : new allocated location) represent sharing the result of the thunk, in the lazy aka by-need operational semantics
07:32:43 <ski> also, if you haven't yet, you could take a look at
07:32:45 <ski> @where lazy
07:32:45 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
07:32:47 <ski> at some point
07:32:53 <ski> (that's by monochrom)
07:33:39 <finnkauski> thanks for that ski
07:34:14 <jollygood2> there's no way to rewrite this so that I can make it accept more than one exception type per call, is there?   retryCountDelay :: forall a e. Exception e => (Int -> Pico -> IO a -> IO a)
07:34:34 <jollygood2> it doesn't have to use TypeApplication
07:34:38 <ski> "the question of `fibs` how does it recurse back onto itself" -- giving the subcomputation (tail of `(:)' here) will help understand that
07:34:45 <ski> we, giving it a name
07:35:54 <finnkauski> bookmarked. 
07:35:54 <ski> jollygood2 : hm, i suppose not, without some kind of way to make a "disjunctive exception" (perhaps one could write such a thing, or maybe someone already did)
07:36:27 * ski isn't really that satisfied with how `Exception' and the related instances work
07:36:42 <ski> (in particular, e.g. `SomeException')
07:40:11 <cocreature> jollygood2: you could go for a signature like catchJust 
07:47:33 * ski idly wonders what the point/deal with the exception would be in `retryCountDelay' -- retry (with delay, a maximum number of times), until it doesn't reach an exception of type `e' ?
07:48:14 <ski> (and shouldn't it then have `IO (Maybe a)' as result type, in case it reaches the maximum number of retries ?)
07:49:19 <ski> (one could also imagine wanting to provide a handler for the exception to try to restore some part of the state before retrying again)
07:49:36 <jollygood2> ski, it intercepts exception of type e, retries action supplied number of  times, and if it is thrown on the last attempt, it rethrows it again
07:50:01 <ski> (say `e -> IO (IO ())', perhaps. the outer `IO' happening in the handler, and the inner just before the retry, after the delay)
07:50:13 <finnkauski> in the case of 1 : scanl (+) 2 [1..2] the right hands side of cons is evaluated first. Is that fair to say? given its infixr for (:)?
07:50:29 <ski> oh, of course it rethrows last time. for some reason didn't think of that
07:50:54 <ski> finnkauski : no
07:51:06 <ski> neither sider is reduced first
07:51:14 <ski> s/sider/side/
07:52:04 <__Myst__> Do ByteStrings not support multi-byte UTF-8 chars?
07:52:06 <ski> you need an external computation to force the list, e.g. `take 12' or `show' or `show . take 12' or `sum . take 12' or something
07:52:24 <ski> hm, actually not just `take 12', that's the same issue
07:52:47 <Solonarv> __Myst__: bytestrings are just a dumb sequence of bytes, they don't know anything about text encodings
07:52:51 <finnkauski> ski: I mean, i am aware that the values wont get evaluated 
07:53:00 <__Myst__> Solonarv: yeah but shouldn't pack take care of 'em?
07:53:42 <Solonarv> Eh, maybe? I don't consider it a huge problem that it doesn't
07:53:54 <ski> finnkauski : you could first force the outer cons cell, then, as a *separate* reduction say that, *if* someone later forces the tail, then the computation continues as ... and then, *if* someone forces the tail of that, then the continues as ...
07:53:59 <Solonarv> there should be a function somewhere to utf8-encode some text that spits out a bytestring
07:54:23 <Solonarv> @hackage text/docs/Data-Text-Encoding.html
07:54:23 <lambdabot> http://hackage.haskell.org/package/text/docs/Data-Text-Encoding.html
07:54:24 <ski> so you'd get a sequence of separate reduction traces (each one depending on the previous one to have terminated)
07:55:10 <ski> finnkauski : but if you want a single reduction trace, i suggest adding some extra computation around, that will compute the result down to e.g. an `Integer'
07:55:56 <finnkauski> ski: i'll show you why i asked, but lemme just stare at it a bit more haha 
07:56:10 <Solonarv> __Myst__: also, ByteString's 'pack' takes a [Word8], not a [Char] !
07:57:11 <__Myst__> Solonarv: i meant bytestring.char8
07:58:07 <Solonarv> __Myst__: as the module description says, that's only for 8-bit characters
07:58:26 <Solonarv> if you want proper unicode handling then bytestrings are not the correct approach
07:59:51 <__Myst__> i need a binary format that i can convert UTF-8 strings to
08:00:40 <cwraith> UTF-8 is a binary format.
08:00:42 <__monty__> UTF-8 *is* a binary representation though.
08:01:19 <Solonarv> banish String from your program, use 'text' for representing unicode, use 'bytestring' to represent binary data, and use the functions in Data.Text.Encoding to convert between them
08:01:56 <finnkauski> why is Text and Scientific not part of prelude btw?
08:02:03 <finnkauski> I was surprised. 
08:02:08 * hackage llvm-hs-pure 8.0.0 - Pure Haskell LLVM functionality (no FFI).  https://hackage.haskell.org/package/llvm-hs-pure-8.0.0 (cocreature)
08:02:31 <Solonarv> lots of things aren't in the prelude or aren't in base
08:02:34 <__monty__> Why would Scientific be part of prelude? Hardly seems like something that should be implicitly available to everyone.
08:04:32 <c_wraith> Scientific isn't really what most people think.  It's a very poor representation for arithmetic.  It's just a serialization format.
08:05:14 <c_wraith> Like, it's infinite precision, but only supports decimals.
08:05:18 <c_wraith> 1/3 diverges
08:05:45 <Solonarv> continued fractions! :p
08:06:34 * ski assumed it was about showing numbers in scientific format ..
08:06:47 <Solonarv> it is not
08:06:53 <ski> (or maybe something with scientific units of measure)
08:06:54 <c_wraith> ski: showing is serialization, of a sort!
08:07:03 <ski> sure
08:07:09 <Solonarv> in fact showing numbers in various ways facility is in base:Numeric
08:07:19 <ski> (but i meant of standard existing types, like `Double')
08:07:30 <ski> yes
08:07:41 <ski> (but perhaps someone wanted something more fancy ?)
08:07:48 <finnkauski> ski: http://dpaste.com/1JKFHRP thats why I asked about evaluation. i was wondering how these got constructed, but by staring at it long enough I got it. 
08:08:18 <__monty__> I assumed units too for some reason. Even though I think Scientific'd be a bad name for such a library : )
08:08:28 <finnkauski> cocreature, ski: thanks for the tips, managed to wrap my head round it. 
08:08:49 <ski> finnkauski : where did `[]' come from ?
08:09:03 <cocreature> finnkauski: nice!
08:09:56 <finnkauski> ski: it would just get returned by scanl as it returns a list with just the initial value if you pass it an empty list to scan over 
08:10:40 <finnkauski> ski: so just needed it to break it apart into multi line bits as a starting point. 
08:10:44 <ski> finnkauski : you didn't start with `fibs = "<" : scanl (++) "i" fibs', then ?
08:11:05 <finnkauski> ski: no that would basically define an infinite list right ? 
08:11:15 <Solonarv> yes, and? infinite lists are fine!
08:11:18 <finnkauski> ski: in that dpaste i just broke it apart into the steps 
08:11:34 <ski> yes, i thought the point was to investigate the feedback behaviour constructing such an infinite list ?
08:11:38 * hackage llvm-hs 8.0.0 - General purpose LLVM bindings  https://hackage.haskell.org/package/llvm-hs-8.0.0 (cocreature)
08:11:43 <finnkauski> nono, Solonarv they are! but i was just breaking it down for understanding, the bit i wanted to understand was the bit ski posted. 
08:11:59 <finnkauski> ski: yes, and by breaking it down into each step sort of, helped me get the process. 
08:12:03 * ski didn't paste anything at a paste site
08:12:38 <finnkauski> so now i'm fairly happy with a general understanding of fibs = 1 : scanl (+) 1 fibs :) 
08:12:43 <ski> investigating a finite process which looks similar to such an infinite process can help, sure
08:13:09 <ski> but i wouldn't stop there, instead going back to the infinite one proper, and see how it works, without something like `[]' to end it all
08:14:43 <ski> (perhaps you already understand most or all of it. i just want to say that you don't have to take a finite approximation, you can look at the infinite process itself (as long as you at some point cut off continuing the reduction trace (or sequence of them), since that's not going to stop itself)
08:15:09 <finnkauski> yeah, i could have left it running and checked. 
08:15:10 <ski> )
08:15:26 <finnkauski> point taken.
08:15:49 <finnkauski> but also i never think about writting it out like I did in a finite approximation, its a helpful tool for me. 
08:16:18 <ski> in domain theory, they'd do finite approximations like you did, but using `_|_' instead of `[]'
08:16:36 <juri_> ok, two days trying to write one line. HELP.
08:16:36 <finnkauski> makes sense though. 
08:16:49 <ski> `_|_' (bottom/undefined/nontermination/no-answer) is commonly thought of as something that will never produce any information
08:17:04 <delYsid> I never actually used scanl, what does it do?
08:17:05 <ski> but you can also view it as a (possibly) temporary state of knowledge
08:17:06 <finnkauski> yeah the first bit in the post you sent mentioned bottom 
08:17:19 <Solonarv> > scanl f z [a, b, c]
08:17:21 <lambdabot>  [z,f z a,f (f z a) b,f (f (f z a) b) c]
08:17:26 <Solonarv> delYsid: ^
08:17:29 <ski> in that sense, every computation starts off at `_|_', and later, *perhaps*, clims to higher knowledge degrees
08:17:42 <finnkauski> Solonarv: thats sick, how do you even use lambdabot
08:18:11 <ski> that's using the package
08:18:16 <ski> @hackage simple-reflect
08:18:16 <lambdabot> http://hackage.haskell.org/package/simple-reflect
08:18:21 <Solonarv> finnkauski: "> " followed by some Haskell expression, then lambdabot will evaluate that expression
08:18:23 <ski> (if i didn't misspell the name)
08:18:47 <finnkauski> > scanr f z [a, b, c]
08:18:49 <Solonarv> the fancy 'f z [a, b, c]' stuff is just a regular package (which ski already linked)
08:18:49 <lambdabot>  [f a (f b (f c z)),f b (f c z),f c z,z]
08:18:53 <juri_> I'm using vectorspace, and i'm trying to use Ratios with it. first problem was magnitude using sqrt, so i implimented my own rational sqrt function. now i'm trying to duplicate 'normalized', but running into constraint issues.
08:19:21 <delYsid> @type z
08:19:22 <lambdabot> Expr
08:19:23 <finnkauski> sick. 
08:19:24 <ski> > scanl f z [var ("a" ++ show n) | n <- [0 ..]]
08:19:26 <lambdabot>  [z,f z a0,f (f z a0) a1,f (f (f z a0) a1) a2,f (f (f (f z a0) a1) a2) a3,f (...
08:20:20 <delYsid> wow, that symbolic expansion thing is suddenly much more interesting than knowing what scanl does was :-)
08:20:24 <rcshm> hi, i am learning to use lens and just like to find out how i can pick two fields in the sub rescords in one traverse and leaving out those empty Text fields. can anyone point me to a tutorial or a blog showing how this can be done?  thanks for your help.
08:20:43 <ski> delYsid : it's pretty dumb
08:20:52 <Solonarv> @let a_vars = [var ("a" ++ show n) | n <- [0 ..]]
08:20:53 <lambdabot>  Defined.
08:21:02 <Solonarv> > scanl (+) z a_vars
08:21:04 <lambdabot>  [z,z + a0,z + a0 + a1,z + a0 + a1 + a2,z + a0 + a1 + a2 + a3,z + a0 + a1 + a...
08:21:18 <delYsid> ski: Simple things can be very effective.
08:21:24 <finnkauski> i wonder, could you write a piece of software this way ? 
08:21:24 <ski> sure
08:21:31 <finnkauski> like just communally in chat
08:22:11 <ski> you used to be able to use `letlpaste' to get lambdabot to import a paste on <lpaste.net> .. but now that site's dead (afaiui) :/
08:22:50 * ski . o O ( Sic transit gloria mundi )
08:22:51 <finnkauski> so bang bang 
08:22:59 <juri_> https://gist.github.com/julialongtin/1dc09151a4ee2430732a592f64557462
08:23:06 <finnkauski> can uyou do type signatures with lambdabot?
08:23:13 <finnkauski> >:t (!!)
08:23:17 <finnkauski> nope ok. 
08:23:19 <jmcarthur> :t (!!)
08:23:20 <ski> @type (!")
08:23:20 <lambdabot> [a] -> Int -> a
08:23:21 <lambdabot> error:
08:23:21 <lambdabot>     lexical error in string/character literal at end of input
08:23:24 <ski> @type (!!)
08:23:25 <lambdabot> [a] -> Int -> a
08:23:26 <finnkauski> isee. 
08:23:45 <finnkauski> so the question there is, why is it using a bounded value for indexing ? 
08:24:01 <juri_> anyone good with type classes got a clue on what i'm running into?
08:24:14 <ski> @let cograph :: (a -> b) -> (Either a b -> b); cograph = (`either` id)
08:24:15 <lambdabot>  Defined.
08:24:29 <jmcarthur> What do you mean by a bounded value? You mean because Int is bounded?
08:24:33 <finnkauski> yeah, 
08:24:47 <portnov> https://github.com/portnov/hcheckers
08:24:47 <finnkauski> what if I ran into a list that would exceed that ?
08:24:47 <ski> @type genericIndex
08:24:48 <lambdabot> Integral i => [a] -> i -> a
08:24:55 <finnkauski> ski: got it 
08:25:01 <Solonarv> finnkauski: indexing into a list is not a great idea anyway - what if the index is out of range? also, [] is a linked list, which is slow to index
08:25:04 <delYsid> finnkauski: Memory is also bounded
08:25:06 <cocreature> juri_: looks like something is forcing specific types but you have a polymorphic type signature
08:25:31 <juri_> It looks like vectorspace has an instance for instance [safe] Integral a => AdditiveGroup (Ratio a)
08:25:31 <jmcarthur> On 64 bit architectures at least, Int is large enough that nothing that either fits in memory or can be computed on reasonable time scales is ruled out.
08:25:38 <cocreature> juri_: hard to say what exactly is the problem without seeing the types of all definitions involved
08:26:05 <jmcarthur> Since (!!) takes linear time anyway
08:26:07 <finnkauski> Solonarv: yeah, ofcourse i wouldn't use lists for massive computations i suppose. just was wondering from a curiosity perspective 
08:26:08 <juri_> cocreature: the funny looking R is just a rational.
08:26:18 <juri_> er. a ratio integer, rather.
08:26:19 <Solonarv> > repeat 0 !! maxBound
08:26:26 <lambdabot>  mueval: ExitFailure 1
08:26:41 <jmcarthur> Using Int for this isn't an especially forward looking decision, but I doubt it's going to bite us here.
08:26:49 <juri_> cocreature: yeah, this has had me stuck for two days. :(
08:26:53 <Solonarv> juri_: fwiw, rationals are usually written ℚ; ℝ is used for reals
08:27:05 <Solonarv> this is just a nitpick though, doesn't solve your problem
08:27:11 <juri_> Solonarv: thanks for that. ;)
08:27:21 <ski> juri_> :t (^*)
08:27:24 <jmcarthur> Of course, everything I just said is why it's okay, not why it's desirable. I guess it's desirable just because it's efficient.
08:27:55 <cocreature> juri_: I’m more interested in Fastℕ and rawSqrt
08:28:13 <juri_> ski :: VectorSpace v => v -> Scalar v -> v
08:28:29 <ski> oh, so scaling
08:28:33 <juri_> cocreature: Int, and ratio integer, respectively.
08:29:03 <cocreature> juri_: you’d make it a lot easier for people to help you if you could turn this into a self-contained example
08:29:16 <ski> juri_> :t magnitudeSq
08:29:22 <ski> juri_> :t rawSqrt
08:29:51 <ski> juri_> :t precision
08:30:31 <cocreature> but "ratio integer" sounds like that’s probably what’s causing your error
08:30:39 <ski> oh, `precision' is an argument. sorry, missed that
08:31:14 <juri_> magnitudeSq :: InnerSpace v => v -> Scalar v
08:31:16 <ski> the question is who invited `Ratio Integer'
08:31:34 <finnkauski> i had another sort of question. I presume this can be answered with something like: you shouldn't structure your solution in a way that would neeed this, but: How would you do default arguments to functions? 
08:31:54 <juri_> rawsqrt:: |rawSqrt :: Fastℕ -> ℝ -> ℝ
08:31:55 <finnkauski> My first language was python, where its super common practice for that. 
08:32:17 <Solonarv> finnkauski: the straightforward solution is to simply have multiple versions of the function
08:32:36 <ski> finnkauski : `Maybe' is one common way. providing a `default' value (often a record), ior a version that is partially applied to such a value is another
08:32:37 <juri_> so, that's Int -> Rational -> Rational
08:32:38 <cocreature> finnkauski: a common solution is to accept a record and then have a default value for that record.
08:32:41 <finnkauski> Solonarv: one with the argument not provided, and one where it matches to something being provided for it ? 
08:33:03 <Solonarv> e.g. 'sortBy :: (a -> a -> Ordering) -> [a] -> [a]', and 'sort :: Ord a => [a] -> [a]; sort = sortBy compare'
08:33:25 <juri_> Rational being Ratio Integer is a bit messy.
08:33:45 <Solonarv> how's that "messy"? what else should it be?
08:33:50 <cocreature> juri_: there’s your problem: recip (rawSqrt …) has type Ratio Integer so "recipe (rawSqrt …) ^* …" will also have type Ratio Integer
08:33:54 <ski> finnkauski : iow, either `fooMaybeWithConfig :: Maybe Config -> ...; fooMaybeWithConfig Nothing = fooMaybeWithConfig (Just defaultConfig)' or `fooWith :: Config -> ...' and `foo :: ...; foo = fooWith defaultConfig'
08:33:57 <cocreature> juri_: but your type signature claims it has type v
08:34:07 <cocreature> so you get an error stating that v must match Ratio Integer
08:34:52 <ski> juri_ : ok, so `rawsqrt' (together with the stated signature of `normalizeℝp') is the culprit, the clash
08:35:23 <jmcarthur> Solonarv: I suspect juri_ means it really should be  Integer/Natural
08:35:35 <ski> juri_ : you need to change at least one of those, or insert some extra stuff in the code to handle the impedance mismatch (or some more involved rewrite)
08:35:51 <finnkauski> ski: thanks, makes sense, following up from that -> what is the best practice in haskell to provide a config file. I used to use yaml and toml as well as json in python for my projects. So far I tried doing it in haskell as part of my whatsapp message parser (https://github.com/finnkauski/whaskupp) and gettign the config ingested and using it was quite hard. 
08:36:25 <Solonarv> usually for a library you wouldn't have it implicitly use a config file
08:36:41 <ski> juri_ : the problem is that `rawsqrt' *insists* working on a `ℝ', while `normalizeℝp' *promises* to work on *any* `v' that is an instance of `InnerSpace', not just `ℝ'
08:36:55 <finnkauski> sure, but often for a production system or something along those lines you'd want a nice way to provide settings for it without recompiling the code.
08:37:16 <juri_> ski, cocreature: ok, i think that's been useful.
08:37:50 <juri_> it almost makes sense. reading through vectorspace hasn't been easy for me. ;)
08:38:05 <Solonarv> at a guess, yaml is probably the most widely-used config format, but json and toml work just as well - there are good libraries for all of those
08:38:24 <finnkauski> yeah, i used one of them, but i did struggle defining a Config datatype 
08:38:29 <ski> juri_ : it's a common newbie mistake to not fully realize the "promise" nature of declaring a polymorphic operation like `normalizeℝp'
08:38:48 <finnkauski> most likely coz i wasn't really clear on what the hell i was doing Solonarv though 
08:39:12 <Solonarv> finnkauski: the Config type I see in your repo is just a bunch of strings, that doesn't seem right
08:39:45 <finnkauski> Solonarv: yeah, i mean, like that code was my first ever thing I tried writting in haskell as a hobby project. 
08:40:01 <ski> (for some reason, people seem to think : ok, so i got a value having a type that's an instance of `InnerSpace'. i know, `ℝ' is an instance of `InnerSpace', so i'll apply an operation that works on `ℝ' !)
08:40:06 <ski> (and this doesn't work)
08:40:48 <finnkauski> Solonarv: it gets populated by making it an instance of FromJSON that comes with YAML (god i hope that makes sense)
08:41:19 <Solonarv> yeah I saw that, my criticism isn't about how you're producing it but what it is
08:41:27 <ski> (the callee, the function `normalizeℝp' doesn't get to pick *which* instance `v' of `InnerSpace' is used. that's the privilege of the *caller* of `normalizeℝp'. the callee, i.e. you, when you're implementing `normalizeℝp', must be satisfied with whatever instance you get to work on. also you can't (in the general case) discover which instance was picked, either)
08:41:32 <ski> juri_ ^
08:41:39 <finnkauski> just a collections of string. you could almost have a association list Solonarv
08:41:49 <Solonarv> that's exactly my problem with it!
08:41:49 <finnkauski> Solonarv: and use lookup for it.
08:42:16 <Solonarv> clearly "fgsuyf" isn't a valid date, so why am I able to put it into the 'date' field of your Config type?
08:42:25 <finnkauski> Solonarv: well now it seems dumb. but also i wasn't sure how you would get a assoc list from the FromJSON 
08:42:27 <ski> juri_ : also, fwiw, i don't really understand how `InnerSpace' works (though i can guess). i'm just applying general knowledge of polymorphism to your particular error message
08:42:47 <finnkauski> Solonarv: oh i see 
08:43:02 <finnkauski> Solonarv: the config in that respect holds different Regex patterns for each of the things it needs to parse
08:43:34 <finnkauski> Solonarv: which are contained in a config file that lets people change them slightly without, like i said recompiling the code 
08:44:56 <finnkauski> Solonarv: I had a python fun project where I wrote a parser for the text of whatsapp messages you can export from whatsapp and then embedded them in sort of a contextual representation to see if I could unpick any topics that me and my friends talk about 
08:45:21 <finnkauski> Solonarv: So this was me trying to get a start at replicating that in haskell, running before i can walk.
08:45:47 <Solonarv> usually it's a good idea to use actual types, instead of sloshing strings around :>
08:46:24 <finnkauski> Solonarv: So defininig specific types for DateRE, TimeRE etc. 
08:46:24 * ski idly recalls hearing of children of nomadic (horse) people sometimes learning to ride a horse before learning to walk
08:46:34 <ski> (presumably this is an exaggeration, though)
08:46:48 <finnkauski> ski: i mean where am i get a horse on a sunday. 
08:46:54 <finnkauski> gonna get*
08:47:14 <ski> (perhaps you could use an elephant instead)
08:47:31 <Solonarv> finnkauski: I would've done something like 'data Config = Config { lineRE :: Regex, nameRE :: Regex, ... }'
08:47:53 <finnkauski> i only started using irc after like years and years yesterday when i refreshed my doom-emacs setup and decided to add the package for irc. and to be fair, sitting around going through my haskell-book with people to help has been much more social. magic
08:48:30 <finnkauski> Solonarv: Would you just type Regex = String it?
08:49:26 <Solonarv> finnkauski: Regex is exported from Text.Regex.PCRE
08:50:34 <finnkauski> Solonarv: I'd need to check how it is defined i suppose. And would it just slot into the Config? given that the fromJSON probably just parses the config into Strings 
08:51:21 <Solonarv> finnkauski: if all your fields' types have a FromJSON instance then the deriving mechanism will use those instances
08:51:52 <Solonarv> Regex doesn't have a FromJSON instance (as far as I can see), so you will have to write the FromJSON Config instance yourself
08:52:47 <finnkauski> yeah, even now like a month on, i get what you're saying, but in practice it would take me a while. Makes sense though, general message is to be a bit more explicit and self disciplined in the types
08:52:56 <Solonarv> yep
08:53:24 <Solonarv> although honestly I don't think it makes too much sense to grab "how to parse this format" regexes from a config file at runtime
08:54:04 <finnkauski> it makse sense to do it at compile time when you're confident how the messages are goign to look like. 
08:54:09 <finnkauski> agreed. 
08:54:36 <Solonarv> and if they're exported from a well-known service then surely they will have a consistent format
08:55:07 <finnkauski> but 2 points there: I wasn't sure what regex got me the result I wanted so I was changing it super often until I got it and 2. It was more about understanding how i'd implement a config file 
08:55:11 <finnkauski> Solonarv: yep. 
08:56:11 <finnkauski> Solonarv: but often for other stuff like: "Oh where is this 9 gb ML model on your drive" is a good use of config in my head. i don't want to type paths or go into my code and recompile it just to change which model I use or use a command line interface to provide a path everytime i run it 
08:56:33 <Solonarv> that's more "a reason not to use regexes" than "a reason to grab regexes from a config file"
08:56:54 <Solonarv> yeah, stuff like where to find some needed files is a good use of config files
08:57:36 <Solonarv> ("what do I use instead of regexes?", you may ask - use parser combinators!)
08:57:50 <finnkauski> your message 
08:57:52 <finnkauski> my head
08:58:18 <finnkauski> there is a section on that in the haskell book i'm going through, i might get to it look back and go AHHH ok . . . 
08:58:28 <Solonarv> probably :D
09:00:44 <raka> hey guys, newbie problem here
09:00:51 <raka> I've been using the apt installed version of ghc which was 7.something and I googled how to get 8
09:01:00 <raka> SO said to use stack
09:01:03 <[exa]> raka: what's your debian?
09:01:12 <raka> ubuntu
09:01:20 <[exa]> oh. :D
09:01:44 <Solonarv> raka: I'd recommend using ghcup to get ghc + cabal
09:01:56 <finnkauski> Solonarv: thats what i use. super.
09:02:00 <Solonarv> https://github.com/haskell/ghcup
09:02:16 <sternmull> I have database-objects with an id and wrote a module that uses an ObjectId type and takes care such ids are only constructed for existing objects. Now i need a "getObject :: t -> Maybe Object" that is used when a user wants to see an object whose id matches an Int. Any suggestion what i should use for t? I could use Int and allow a ObjectId -> Int conversion (is there already typeclass for things that can be converted to integers?). Or
09:02:16 <sternmull>  i could create a new wrapper type "MaybeInvalidObjectId" that can be constructed from ObjectId or Int. What is a good way to solve this?
09:02:18 <raka> ok, I'm gonna do that
09:02:35 <[exa]> okay, anyway -- you can use stack to get a complete ghc for one user, but I'd recommend going with simple solution with less stuff to go wrong. The suggested ghcup is great
09:02:49 <[exa]> raka: and you can use APT pinning if you want ghc from newer ubuntu
09:02:58 <Solonarv> stack is only simpler if you were going to use stack anyway
09:03:01 <Gurkenglas> > ("a","b","c","d","e") &~ (,) <$> (_2 <<.= "") <*> (_4 <<.= "") -- rcshm, like so?
09:03:02 <lambdabot>  ("a","","c","","e")
09:03:30 <Gurkenglas> > runState ((,) <$> (_2 <<.= "") <*> (_4 <<.= "")) ("a","b","c","d","e")
09:03:32 <lambdabot>  (("b","d"),("a","","c","","e"))
09:03:56 <raka> I can use both right? stack will use a seperate install
09:04:03 <rcshm> thanks Gurkenglas: it is more like list of [Record { type1 :: Record1, type2 :: Record2 }], and Record2 { field1 :: Text, field2 :: Text }
09:04:19 <rcshm> how do i use lens to have [field1 or fields2] filtered out empty string?
09:04:39 <Gurkenglas> rcshm, what type signature would you like the function I shall give you to have?
09:04:42 <Solonarv> raka: yes; stack handles its own ghc installs and doesn't touch or interfere with whatever "global" install you may have
09:04:49 <rcshm> i do have over traverse (type2 . field1) list.  but i do not know how i compose this with of field2 and filter. 
09:05:26 <rcshm> Traversal' Record [T.Text]
09:05:56 <[exa]> raka: btw this is the pin from debian if you'd need that https://bpaste.net/show/91fd61a1e7ea (on Ubuntu you will just need to swap a few release names and the URL of the repository)
09:06:08 <raka> when I used stack ghci and loaded my module I got a Could not find module ‘System.Random’ error
09:06:12 <rcshm> i am looking to traverse only once and pick out the sub record fields without those empty basically.
09:06:13 <raka> thanks exa
09:06:30 <Gurkenglas> rcshm, what if only one of the two Texts in a Record2 is empty?
09:06:32 <[exa]> raka: but seriously, use ghcup, it's the most straighforward and surprise-less way
09:06:41 <rcshm> just leave that out.
09:07:09 <Solonarv> raka: 'stack ghci' in a project will only load packages that are a dependency of your project; outside a project, it won't load any packages
09:07:10 <rcshm> it would be great if you can show me how to compose the two traversals together.
09:07:33 <Solonarv> you can specify additional packages with 'stack ghci --package foo --package bar' 
09:07:47 <Solonarv> but really I'd recommend using ghcup and ignoring stack for now
09:08:00 <Gurkenglas> filter (allOf (field1 <> field2) (not . null)) :: [Record] -> [Record]
09:08:01 <raka> Solonarv: ahh, got you, thanks
09:08:07 <finnkauski> yes. i found stack confusing and overengineered. 
09:08:16 <raka> ok, I will use ghcup then
09:08:17 <Gurkenglas> filter (allOf (type2 . (field1 <> field2)) (not . null)) :: [Record] -> [Record] that is
09:08:22 <raka> thanks guys!
09:08:24 <finnkauski> cabal though needs to get itself sorted out with the new-repl and repl stuff 
09:08:30 <Solonarv> you can do a similar thing with cabal: cabal v2-repl -b foo -b bar 
09:08:40 <Solonarv> finnkauski: the new-* commands will become the default very soon
09:08:54 <finnkauski> Solonarv: not soon enough, my dante package in emacs uses the repl command for cabal. 
09:09:05 <Solonarv> finnkauski: surely it's configurable?
09:09:09 <finnkauski> Solonarv: i could go and patch it but i cba so i just use a terminal with cabal running 
09:09:25 <finnkauski> Solonarv: don't know if its super straighforward, but it is patchable i would have thought. 
09:09:33 <Gurkenglas> "rcshm, filter (allOf (type2 . (field1 <> field2)) (not . null)) :: [Record] -> [Record]" that is
09:09:45 <Solonarv> that's the sort of thing that should be pretty straightforward to configure
09:09:48 <finnkauski> Solonarv: probs somewhere in the code. but atm my set up works. i have a terminal buffer running and just :r 
09:10:03 <Solonarv> finnkauski: you can automate that with ghcid !
09:10:11 <rcshm> thanks, let me try that out. Gurkenglas.
09:10:24 <finnkauski> Solonarv: presume thats like a diff thing that refreshes?
09:10:44 <Solonarv> finnkauski: it's basically just a thin wrapper around ghci that automatically does :r when a file changes
09:10:50 <finnkauski> Solonarv: in which case then how do i do that within cabal new-* 
09:11:02 <finnkauski> Solonarv: does it propogate into new-repl?
09:11:11 <finnkauski> or v2-repl or whatever 
09:11:13 <Solonarv> ghcid --command 'cabal v2-repl' # that's the command
09:11:19 <finnkauski> sick. 
09:11:44 <Solonarv> yeah, ghcid is cool :D
09:11:48 <finnkauski> where do i get it ?
09:11:59 <finnkauski> i'll need to set up a alias for that 
09:12:07 <Solonarv> https://www.parsonsmatt.org/2018/05/19/ghcid_for_the_win.html <- here's a blog post about it
09:12:52 <finnkauski> cabal update && cabal install ghcid
09:12:56 <finnkauski> is the answer :D 
09:13:10 <Solonarv> yep (or v2-install instead of install)
09:13:30 <finnkauski> nah, i'm happy having it global 
09:13:47 <Solonarv> v2-install will also make it global
09:14:02 <finnkauski> hmm, in which case i might be confused. 
09:14:17 <Solonarv> it just won't mess up or get messed up by other already-installed packages
09:14:19 <finnkauski> i thought the way you'd localise installation of packages is by using the new style commands with cabal 
09:14:47 <finnkauski> meaning that the installed packages are specific for that location on the filesystem (not really but you know, they are project specific )
09:14:51 <rcshm> Gurkenglas, so the filter will pick out all the Records that have either of the subfields present correct?
09:14:57 <Solonarv> 'v2-install' means roughly 'build and symlink the executable to ~/cabal/bin'
09:15:30 <rcshm> i am just looking to pick out the values of the sub fields and just not include empty string.
09:15:43 <sm> finnkauski: ghcid provides an executable, those are always "global" unlike libraries
09:16:59 <rcshm> rather [Record] -> [T.Text] Gurkenglas:
09:17:17 <finnkauski> sm: makes sense sort of, thanks. 
09:17:54 <Solonarv> v2-* commands will build stuff in isolation, as if in a fresh sandbox
09:18:26 <__monty__> But a sandbox that's still kinda globally available.
09:18:32 <Solonarv> (but more efficient, because they are able to share already-built things if they are going to be identical anyway)
09:18:33 <finnkauski> so not confusing at all 
09:18:48 <sm> yes I'm glad we cleared that up 
09:19:01 <finnkauski> Solonarv: yeah ok. fine, so the installions are global but reused if the version specs match. 
09:19:06 <Solonarv> "almost as safe as a sandbox, as efficient as shared global installs"
09:20:08 <finnkauski> im used to stuff like Pipenv and pyenv in python (pyenv is basically ghcup). pipenv is local in that respect so each folder has tons of packages in there, which i suppose is not space/time efficient. 
09:20:15 <Solonarv> indeed
09:20:25 <finnkauski> so you can see why i didn't get the whole 'oh its localobal'
09:20:47 <c_wraith> that matters a lot more in Haskell, too.  compiling isn't free, whereas installing a python package is just copying files
09:20:58 <finnkauski> yeah. true 
09:21:02 <finnkauski> very very true 
09:21:03 <merijn> finnkauski: The way v2-* works is to tag everyone dependency with a hash of it's transitive dependencies, guaranteeing things match EXACTLY
09:21:37 <finnkauski> merijn: so its not even the version number, its a hash of its dependency graph in a way ? 
09:21:46 <merijn> finnkauski: For exact matches it will reuse the existing install. If a version differs in anything the hash won't match up and you'll get a uniquely named version
09:21:58 <merijn> finnkauski: Even of compile flags used to build, for the flags that matter
09:22:18 <merijn> finnkauski: It's inspired by Nix, which does exactly this.
09:22:21 <finnkauski> merijn: i see. wow so basically a hash of all dependencies, their compilation instructions etc. 
09:22:36 <Solonarv> yup
09:22:38 <finnkauski> merijn: this seems like quite sensible way to do things. 
09:22:38 <merijn> finnkauski: Right, so two independent projects can never conflict in a meaningful way
09:22:56 <merijn> finnkauski: But if they happen to have matching (parts) you can just reuse those
09:23:16 <finnkauski> When I started with haskell, i realised that the whole ecosystem is absolutely confusing as hell. 
09:23:20 <Solonarv> and in practice that happens fairly often, so you do get a lot of sharing
09:23:26 <finnkauski> wish i was in this channel then 
09:23:43 <finnkauski> i also defaulted to cabal mainly coz it looks much more lightweight 
09:23:43 <sm[m]> don't worry, it still would been confusing
09:24:27 <Solonarv> certainly a sensible default - stack doesn't save you from learning cabal in the long term, anyway
09:25:09 <finnkauski> has anyone here used python? stack to me seems like the equivilent of Anaconda for python ?
09:25:57 <Solonarv> I've used python, but I know very little about its package management
09:26:13 <finnkauski> https://xkcd.com/1987/ explains it very well 
09:26:44 <sternmull> finnkauski: Stack is much like pip with virtualenv
09:26:55 <monochrom> I like the recent one about calculus better. :)
09:26:58 <finnkauski> yeah, so basically pipenv. 
09:27:22 <finnkauski> The only reason i said it was like Anaconda because anaconda has its own way and its own snapshots for resolving 'what works together '
09:27:36 <finnkauski> and it is also both pip and venv 
09:27:59 <sternmull> finnkauski: If that is so then it sounds very much like the equivalent to stack
09:28:20 <finnkauski> to be fair -> pipenv is quite sexy as you can run it to check for publish volunabilities in your dependency tree. so you can check whenever you want. 
09:28:35 <finnkauski> yeah sternmull, its curated by some organisation. 
09:29:29 <finnkauski> sternmull: has its advantages, things like tensorflow and a lot of libraries with complex dependencies are easy to install as the installation of them from their repo basically means you get a latest compiled version that will work. 
09:29:45 <finnkauski> and is self encompasing with respect to its dependencies that aren't python. 
09:30:11 <finnkauski> (but i still dislike it being bloated, opinionated and curated)
09:30:16 <Solonarv> yeah, that sounds a lot like stack
09:30:59 <finnkauski> well, if anyone wants to get a good ecosystem for python in the future, or for you linux distros, use pyenv and pipenv is my recommendation. Thanks for clearing up cabal, thats been super useful. 
09:33:21 <delYsid> I love stack.
09:33:37 * hackage nvim-hs 2.0.0.0 - Haskell plugin backend for neovim  https://hackage.haskell.org/package/nvim-hs-2.0.0.0 (saep)
09:34:31 <finnkauski> https://xkcd.com/378/
09:35:26 <__monty__> finnkauski: What's wrong with the stdlib venv?
09:35:35 <finnkauski> nothing. __monty__
09:35:54 <finnkauski> literally, just convenience. I've had this discussion yesterday in #python. 
09:36:14 <finnkauski> most of the stuff that pipenv does could be done via aliases in your zshrc or a script 
09:36:41 <finnkauski> i just like: 1. downlaod pyenv, 2. pip install pipenv -> move on with your life + you get a nice Pipfile detailing your environment
09:37:01 <ahri> is there a way to specify build tools and fake tasks in cabal files to e.g. depend on "ghcid" and to execute it via cabal? (or stack)
09:37:25 <finnkauski> Pipenv in itself is bloated __monty__ and sometimes also slow to 'lock' its dependency graph. so swings and roundabouts
09:37:50 <sm> ahri: not really, a makefile or shakefile is better for that
09:38:14 <delYsid> oh, I didnt realize xkcd has accessible comics these days, pretty cool!
09:38:14 <sm> if I understood what you're asking
09:38:49 <ahri> sm: that's fine - just didn't want to branch out if I didn't need to :)
09:38:50 <finnkauski> sm: haha, didn't realise Shakefile was a thing
09:39:09 <ahri> Shake is nice
09:39:44 * ski . o ( make shake bake cake )
09:40:14 <Solonarv> I know what the rest is, but what's cake?
09:40:24 <delYsid> ski: Next thing will be fakefiles :-)
09:40:31 <cocreature> Solonarv: it’s very tasty!
09:40:33 <finnkauski> snake 
09:40:39 <__monty__> Your build system is fake!
09:40:46 <ahri> fake is the F# tool - already exists!
09:40:48 <finnkauski> blake, take
09:40:58 <Martin333[m]> rake
09:40:59 <maerwald> Shake is weird :P
09:41:13 <maerwald> it also locks itself
09:41:17 <finnkauski> ekam ekaf ekahs
09:41:26 <finnkauski> thats the future. 
09:41:52 <__monty__> Locks itself?
09:42:05 <maerwald> Yes, you can't execute it twice (no matter what target)
09:42:20 <maerwald> With make you can do some naive parallelization if you know it's correct
09:42:43 <ski> Solonarv : "Cake: a fifth generation version of make" by Zoltan Somogyi (the Mercury guy) in 1987-04 at <https://web.archive.org/web/20091020082712/http://www.cs.mu.oz.au/~zs/papers/cake.ps.gz>
09:42:47 <sm> maerwald: yes that's getting in my way a bit.. for good reason I assume
09:42:50 <Solonarv> ah ha!
09:43:12 <ahri> maerwald: isn't that because it parallelizes its own tasks?
09:43:16 <__monty__> Can't you program that into your build system? With some async library or whatever?
09:43:32 <Solonarv> (bake is the proposed Dependent Haskell -> PICO algorithm)
09:44:00 <maerwald> probably lots of reasons you can't do that, but there are cases where you have a running shake target (e.g. execution of docker container), but another run of the same target will be completely isolated
09:44:16 <maerwald> Make doesn't care
09:44:25 <ahri> maerwald: I see, good to know
09:44:34 <maerwald> And in fact, combining shake and docker feels useless to me, because docker already has its own caching etc mechanism
09:44:46 <maerwald> Same with combining shake and cabal
09:45:00 <maerwald> Shake is useful if the underlying tool (if any) doesn't have those features
09:45:01 <ski> @where applicative-vs-monadic
09:45:01 <lambdabot> "Applicative vs Monadic build systems" by ndm in 2014-07-23 at <https://neilmitchell.blogspot.se/2014/07/applicative-vs-monadic-build-systems.html>. (cf. "static sequencing" vs. "dynamic sequencing")
09:45:02 <Solonarv> shake + cabal makes sense when your project isn't pure haskell
09:45:19 <maerwald> Solonarv: even then depends
09:45:35 <sm> shake isn't just about caching and dependencies, it's also useful as a scripts repository with a real programming language (unlike Make)
09:45:38 * hackage nvim-hs-contrib 2.0.0.0 - Haskell plugin backend for neovim  https://hackage.haskell.org/package/nvim-hs-contrib-2.0.0.0 (saep)
09:45:46 <maerwald> Make has functions
09:45:54 <Solonarv> exampe of what I mean: https://github.com/Solonarv/call-rust-from-haskell
09:46:09 <ahri> maerwald: still, it's relevant to me as I have in the past used make/rake/npm as a small list of common project tasks that I often want to run in parallel, e.g. "watch" + "lint"
09:46:14 <sm> shake also has the most usable shell integration I've seen (cmd etc.)
09:46:46 <maerwald> Solonarv: sure, but cargo also has its own caching
09:46:48 <maerwald> no?
09:46:57 <Solonarv> indeed, and I let cargo handle that
09:47:03 <maerwald> So there is no point either
09:47:04 <ahri> sm: but if it self-locks I can't run a long-running script, like "watch" whilst still utilising the other scripts in that repository?
09:47:07 * ski . o O ( "embargo" )
09:47:36 <sm> correct AFAIK, you wouldn't use it for a background task (though I'm sure there's some way round it)
09:47:50 <Solonarv> the shake script just makes sure to call cargo and cabal in the right order, and put the build artifacts (the dynamic library generated from rust, and the exe generated from haskell) in the right places
09:48:02 <maerwald> Solonarv: make can do that too
09:48:14 <sm> so I end up using both a Makefile and Shake.hs
09:48:16 <Solonarv> maerwald: sure, but I don't know make :p
09:48:29 <maerwald> Solonarv: my point was that people use shake without needing its features
09:48:33 <maerwald> so you just proved my point
09:48:41 <sm> simple stuff in the makefile, migrating to shake when it gets tricky
09:48:54 <maerwald> Yeah
09:49:17 <maerwald> But I would probably prefer writing cmake even
09:49:48 <sternmull> if i have a type parameter for which i am sure it is a newtype... is there a generic way to match on its one constructor? I am sure the answer is no, but maybe there is a way to get close to it.
09:50:23 <maerwald> Shake documentation is in some parts also lacking and the type magic is also bewildering sometimes
09:50:32 <ski> sternmull : what would you do with the innards, even if you could do it ?
09:50:32 <Solonarv> sternmull: you can do some stuff with Coercible constraints & coerce
09:50:33 <sm> needs more users hammering on it
09:50:41 <maerwald> And upgrading shake versions is also not always easy
09:51:01 <Solonarv> The biggest hurdle for me was actually not being able to get cabal's script thingy to work
09:51:13 <__monty__> I upgrading versions of any haskell software easy? : >
09:51:38 <__monty__> *is
09:51:46 <sm> one other shake advantage: cross platform
09:52:00 <maerwald> sm: hmm?
09:52:22 <sm> it can just work on windows, unlike pretty much everything else
09:52:25 <maerwald> Can you run shake without ghc and cabal?
09:52:34 <maerwald> Not very cross platform imo :P
09:52:45 <Solonarv> no, but can you build a haskell project without ghc & cabal? also no
09:53:01 <maerwald> So basically no one uses it who doesn't write haskell
09:53:05 <sm> you make it a stack script, so only stack is required. That's pretty much a given and doesn't make it not cross platform
09:53:11 <sternmull> ski, Solonarv: Here is what i try to do: https://pastebin.com/uCC0Xn63
09:53:36 <maerwald> huge dependency chain for just a script, if you're not interested in haskell dev
09:53:46 <Solonarv> yeah, I guess
09:54:00 <__monty__> maerwald: GHC is a pretty big dependency to pick up for a build system *but* you can provide compiled shakefiles, so for large teams it's still an option.
09:54:26 <maerwald> "help, my build system is a binary"
09:54:55 <__monty__> Not many ghc hackers ever touch its build system so I don't see the problem.
09:55:09 <sm> I'm not saying it's free of dependencies or available out of the box on every platform, obviously. I mean that it can run on unix/mac/windows by running a single command, unlike Make, shell scripts, etc.
09:55:22 <__monty__> I said large teams, where there's a subset of people that actually work on the build system.
09:55:32 <maerwald> sm: shell scripts and make these days work on all 3 platforms
09:55:47 <sm> not out of the box, ie in a CMD window
09:55:55 <maerwald> mac was never a problem
09:55:57 <maerwald> only windows
09:56:20 <maerwald> so yeah, if you count WSL
09:56:32 <__monty__> Shake isn't just a make replacement. It solves a problem make can't. The table from build systems à la carte is enlightening.
09:56:54 <ski> sternmull : i dunno whether it would be very useful, but one could do `class ID a where fromID :: a -> Int', with instances `ID CatId',`ID DogId',`forall a. ID a => ID (IntOrId a)'
09:57:18 <Solonarv> "just use wsl" isn't really a good answer IMO - for one, it only works on win10, and for another while it's more permeable than a VM it's not quite native either (from what I hear)
09:57:18 <maerwald> Yes, and if computer science has taught us anything: use the simplest possible solution/tool, unless you really need more complexity ;)
09:57:20 <__monty__> Maybe I should've qualified "make can't without jumping through hoops."
09:58:07 <__monty__> maerwald: That's why I said it doesn't intend to replace make. For haskell projects it might as well though, since you'll have ghc available anyway.
09:58:08 <maerwald> Solonarv: I have never really tried wsl, except running ghcup inside
09:58:15 <maerwald> which worked, surprisingly, but was awfully slow
09:58:16 <sternmull> ski: I don't want to allow the conversion of concrete IDs to Int because then you can do CatID to Int to DogId
09:58:29 <Solonarv> I haven't tried it either, on account of not having win10 and therefore not having wsl
09:58:45 <maerwald> I stole a laptop from a work colleague and just did that
09:58:47 <maerwald> You should too
09:58:48 <Solonarv> This is also why I get annoyed at statements along the lines of "just use WSL lol"
09:58:55 <ski> sternmull : ok, so i suppose i don't understand the aim
09:59:04 <maerwald> Solonarv: well, who said that in this discussion?
10:00:01 <Solonarv> nobody - I was responding to your "if you count WSL", stating that I don't count WSL
10:00:13 <Solonarv> (rather more verbosely than that, though)
10:00:13 <maerwald> Sure, it's weighing options
10:00:30 <maerwald> shake for me is only interesting if the underlying tool really has no proper caching
10:00:43 <maerwald> I would never have imagined to use it for cross-platform reasons :P
10:00:48 <sternmull> ski: I have a bunch of newtypes that represent IDs for database objects. And i make sure you only get them if there is an object for the id. But now i need a "getObjectWithId"function that may be called with a number that comes from the user or with a concrete ID (a specific newtype).
10:01:22 <maerwald> I mean, if you are doing haskell dev and a few of your devs use linux and a few other windows? Err, stop right there!
10:02:01 <sm> maerwald: what if you're shipping a FOSS project ?
10:02:21 <Solonarv> Or if the project you're working on is supposed to work on linux & windows both? :p
10:02:22 <maerwald> Make it ass easy to install as possible (no shake)
10:02:26 <maerwald> oops
10:02:29 <maerwald> s/ass/as/
10:03:02 <Solonarv> I'd guess that users mostly don't mind getting binaries, so your build system doesn't really matter if that's true
10:03:09 <maerwald> Shake is cool for internal development where you really want faster cycles, because your tools are not smart enough
10:03:35 <maerwald> Otherwise it will mostly be a burden for users trying to figure out how to run it 
10:03:36 <sm> maerwald: I don't need shake for installing, but if a contributor wants to start doing dev tasks on windows say, shake can make that more possible 
10:04:09 <maerwald> if you do FOSS and want contributors... use common tools
10:04:27 <sm> php ? :)
10:04:27 <phadej> http://simonmar.github.io/bib/papers/shake.pdf worth reading
10:04:37 <phadej> before "build systems a la carte"
10:04:38 * hackage chronos-bench 0.2.0.2 - Benchmarking tool with focus on comparing results.  https://hackage.haskell.org/package/chronos-bench-0.2.0.2 (knupfer)
10:04:44 <phadej> make just doesn't "scale" for GHC
10:06:20 <ski> sternmull : hm, so you're saying constructing `CatID' or `DogID' from `Int' is to be avoided except by special code, but surely extracting the `Int' would be ok to have public ?
10:08:04 <sternmull> ski: Constructing CatID and DogID should be only possible inside a specific module. Outside of it i don't even want you can see the Int inside those IDs. But i need a function that accepts an Int or an ID of a specific type.
10:08:34 <c_wraith> why are you creating type-safe wrappers and then not using them safely?
10:08:58 <sternmull> I think a typeclass for the ID-to-Int conversion would help, but only if i can prevent it from beeing exported. Is that possible when i export types that have an instance for it?
10:09:13 <Solonarv> yes, just don't put the typeclass in your module's export list
10:09:33 <sternmull> c_wraith: I want to keep the unsafe stuff inside that module.
10:09:41 <sternmull> Solonarv: Oh, nice! Will try that.
10:15:08 <rcshm> hi, how do we get a proper [Text] back with the use of traverse like λ> view (traverse.posts.traverse.title) users which gives "helloworldfoobar"?
10:15:40 <c_wraith> :t preview
10:15:42 <lambdabot> MonadReader s m => Getting (First a) s a -> m (Maybe a)
10:15:57 <c_wraith> Nope, not that one.  Whatever the named form of (^..) is
10:16:51 <cocreature> toListOf
10:17:44 <rcshm> you mean toListOf view (traverse.posts.traverse.title) users? cocreature:?
10:17:51 <c_wraith> no.  don't use view
10:18:07 <rcshm> i see. let me try that.  thanks.
10:30:42 <Solonarv> Does anyone have an idea why cabal might be failing to recognize the {- cabal: -} comment in a cabal script? minimal reproduction here: https://gist.github.com/Solonarv/cd8a1247384c330252ca8407624d3317
10:33:06 <rcshm> c_wraith: how do i use toListOf with something like over traverse (f <> g <> k) [records], where f, g, k picks out subfields of records.
10:33:45 <rcshm> subfields of subrecords i mean.
10:35:19 <c_wraith> I'm not sure how over fits into that.
10:36:08 <rcshm> i could pick out strings in the subfields but they all come in like "helloworld"
10:38:14 <rcshm> with over traverse (f <> g <> k) [records] i mean.
10:38:30 <c_wraith> but over is for editing.  I don't see how that fits in
10:38:37 <rcshm> but i am just not able to fit in toListOf here.
10:38:47 <rcshm> ah.
10:40:15 <rcshm> but i could pick out values using over traverse.
10:40:54 <c_wraith> That still doesn't make sense.
10:41:10 <c_wraith> over is for editing.  it should return the same shape structure as you started with, not pick out anything.
10:45:39 <rcshm> i must misunderstood over to be applying traverse f,g,k over the list of records.
10:46:52 <rcshm> how do we pick out values in sub record fields like [Record { type1 :: Record1, type2 :: Record2 }], and Record2 { field1 :: Text, field2 :: Text }?
10:47:02 <c_wraith> Do you want to return fields or edit structures?
10:47:24 <rcshm> where i like to have [field1 or fields2] filtered out empty string?
10:47:27 <rcshm> no
10:47:38 <rcshm> just picking out the values as list.
10:47:51 <c_wraith> then the answer isn't "no", it's "return fields"
10:48:18 <rcshm> sorry not edit anything i meant.
10:48:41 <c_wraith> > toListOf (traverse . (_1 <> _3)) [(1,2,3),(4,5,6),(7,8,9)]
10:48:42 <lambdabot>  [1,3,4,6,7,9]
10:49:09 <rcshm> let me try that out.  thanks.
10:53:51 <rcshm> i could not do traverse . (type2.field1 <> type2.field2) though.
10:54:44 <c_wraith> why couldn't you?  also, why would you need to?  that should be the same as traverse . type2 . (field1 <> field2)
10:54:55 <rcshm> Couldn't match type `T.Text' with type2.field1.
10:54:59 <c_wraith> As long as the optics are lawful, anyway
10:55:07 <c_wraith> Oh!  that's a precedence error
10:55:15 <rcshm> i see.
10:55:21 <rcshm> let me retry it.
10:59:31 <rcshm> hmm, still couldn't match `T.Text' with Record though.
11:03:48 <rcshm> with this traverse . type2 . (field1 <> field2) it complains Expected type2 -> record but actual type2 -> T.Text
11:44:02 <rcshm> c_wraith: now i finally got it to work. toListOf (traverse . type2 . (field1 <> field2)) lst
11:44:29 <rcshm> how do i filter out the empty string? or just have it picking out non empty string?
11:48:40 <OmegaDoug> Is there any way I can use only the constant One in another data type?
11:48:43 <OmegaDoug> data Const = Zero | One
11:48:48 <OmegaDoug> data PrefixOp = Negate One
11:49:15 <jollygood2> OmegaDoug, only use it in the sense that Negate Zero gives you compile error?
11:49:33 <jollygood2> if so, no
11:49:58 <OmegaDoug> https://gist.github.com/DouglasBrunner/48e93420a52c34eec52bbea4ce12c55b
11:50:19 <OmegaDoug> jollygood2: I was hoping for applying only part of another data type,
11:50:36 <OmegaDoug> But, I had a feeling that would be the case.
11:51:16 <cocreature> rcshm: haven’t read all the backlog so sorry if I’m missing context but maybe try adding "filtered (not . null)"?
11:51:34 <jollygood2> you need dependent types  (or something close to it) to do what you want.
11:51:39 <rcshm> ah. it is filtered
11:51:50 <rcshm> i was trying filter and it didn't compile.
11:51:54 <rcshm> thanks let me try that.
11:52:21 <cocreature> rcshm: you can also use filter on the result, e.g. "filter (not . null) (toListOf … lst)"
11:53:06 <rcshm> is there a way to specify to just pick out non empty fields in the first place?
11:53:36 <rcshm> instead of picking out and filter.
12:00:47 <sternmull> I use PostgreSQL.Simple and have a custom type t with a RowParser that works fine. But now i have a Maybe t in another type and can't figure out how to reuse the the row parser... or whatever i am supposed to do. I don't have the impression that i am expected to "manually" write a FromField instance in that case.
12:02:38 <finnkauski> does ghci have a way to benchmark code? 
12:02:56 <finnkauski> like time mainly 
12:03:16 <[exa]> finnkauski: you might want to take a look at criterion package
12:03:33 <[exa]> (not sure if there's something in ghci, but criterion is certainly worth seeing)
12:03:48 <finnkauski> :set +s
12:03:53 <finnkauski> does what I wanted! 
12:04:03 <finnkauski> but i'll have a look 
12:08:16 <shapr> alanz: thanks for all your work on HIE!
12:12:02 <finnkauski> Is there a more beginner haskell channel, im sort of hesitant of spamming quite perhaps beginner questions here 
12:13:14 <cocreature> asking beginner questions is perfectly fine
12:13:26 <alanz> shapr, its weird, your message shows up on my bouncer notification, but not in this channel
12:13:47 <cocreature> a lot of us started out by asking beginner questions here :)
12:14:34 <finnkauski> cocreature: i have this question, when I use :set +s in ghci and time the execution of `memrev` and `myReverse'` from here http://dpaste.com/048W0Z5 the later uses much more memory looking at it, by a factor of 10 
12:15:48 <finnkauski> (0.73 secs, 3,666,592 bytes) vs 
12:15:49 <finnkauski> (0.75 secs, 31,694,584 bytes)
12:16:02 <finnkauski> on [1..1000]
12:16:43 <geekosaur> 1. ghci does no optimization, so you tend to see intermediate allocations that would normally vanish.
12:17:18 <geekosaur> 2. explicit init and last will tend to be a bit inefficient compared to direct pattern matching
12:17:20 <finnkauski> geekosaur: so avoid overreliance of the +s flag in ghci for benchmarking 
12:17:55 <geekosaur> avoid ghci if you really want to see time or memory usage, unless ghci/runghc is how you'll always be using it
12:18:12 <finnkauski> geekosaur: +1 good to know 
12:18:31 <geekosaur> even code with -O0 is a bit smarter than ghci, plus it's native code instead of internal bytecode
12:20:06 <geekosaur> I will also note that while the pattern matching version uses less memory, it's also more strict — and sometimes you care about strictness. (Although evne then there are better ways than switching to init / last.)
12:20:10 <monochrom> I have seen some easy code optimizations done by -O0.
12:20:27 <cocreature> finnkauski: note also that this is allocations not max residency
12:20:46 <cocreature> you can get ghci to do optimizations with :set -fobject-code and then :set -O1
12:23:12 <monochrom> +s is extremely misleading.
12:25:58 <monochrom> +s is like you want to interview a professional, 10-year-experience programmer, and suddenly they decide "as it happens my child is taking 1st-year CS courses, I'll send him/her to you for the interview on my behalf".
12:27:48 <finnkauski> even the sheer time comparisons are unreliable i presume due to the optimisation points made earlier 
12:28:22 <finnkauski> hmm well i thought i had a quick win to have a bit of feedback going on
12:28:46 <finnkauski> no objections to +t thought right? 
12:32:41 <Solonarv> that shows the type of every expression right?
12:32:50 <finnkauski> yeah after evaluation 
12:32:54 <Solonarv> I don't usually have that on but there's nothing wrong with it
12:33:18 <Solonarv> cocreature: I thought -fobject-code only affected code you :load, not stuff typed into the prompt?
12:34:13 <finnkauski> reason i asked is i am weary of certian crutches. like I had a variable explorer in pytho where i could click around my arrays and inspect them in the IDE i used, as it turns out when you swap to coding in something that doesn't have that you feel a bit lost if you were used to it 
12:34:54 <cocreature> Solonarv: not quite sure about that but you’re probably right. I rarely type anything significant at the prompt so I don’t really care about that :)
12:43:47 <ibloom>  What is the best way to rotate the elements of a Data.Vector.Storable by a certain number of elements.
12:44:32 <cocreature> ibloom: do you really need to rotate the elements? I would try to avoid that and instead shift the indices for access after the rotation
12:45:54 <ibloom> How would you do that?
12:46:52 <cocreature> add some offset to the indices and `mod` by the length
12:48:05 <ibloom> I see.  I was just going to do:
12:48:39 <ibloom> rotateVectorLeft vs i = VS.drop i vs (VS.++) VS.take i vs
12:49:21 <ibloom> VS is Data.Vector.Storable
12:50:09 <cocreature> right that works too but will actually create a new vector so it’s more expensive than just shifting the indices by which you access elements
12:53:34 <ibloom> I see, mod can actually be pretty expensive.
12:53:50 <ibloom> There are always warnings about it in optimization talks for GPU stuff.
12:54:45 <cocreature> sure but compared to allocating a whole new vector, mod will usually still be quite a bit cheaper
12:54:53 <cocreature> but as usual benchmark if you care about performance
12:55:30 <siers> Will errors be reported from a "async $ action"?
12:56:18 <hpc> what sort of errors
12:56:27 <hpc> do you mean like Either foo bar?
12:56:29 <finnkauski> here's a question, what language do you think is most useful to know alongside haskell? in terms of just self development. Im on the long road of become sufficiently profficient with haskell but i'm already eyeing stuff ahead.
12:57:14 <hpc> finnkauski: rust is a nice turn back towards low-level concerns, especially static memory management
12:57:23 <hpc> dependent types are a good way to get deeper in type system stuff
12:57:34 <siers> hpc, errors like "error "1""
12:57:37 <finnkauski> hpc: i was looking at it. i heard it borrows some type stuff from haskell
12:57:56 <siers> actually that is rather easy to test
12:58:29 <hpc> error works by throwing an exception outside of IO
12:58:41 <hpc> so it'd act like exceptions, except harder to catch
12:58:55 <cocreature> siers: `wait` will rethrow exceptions
12:58:56 <hpc> (you have to make sure the /evaluation/ happens when you expect, not the /execution/)
12:59:59 <siers> I've a lot of async (not a dynamic count, though)
13:00:11 <hpc> finnkauski: rust has a lot going for it that makes it comfortable coming from haskell - its {} code blocks are basically IO do-notation
13:00:11 <siers> waitAny!
13:00:28 <hpc> they parse as expressions, and return the value of the last line of code
13:00:41 <hpc> and ADTs
13:00:44 <Ariakenom> hpc: what did you mean by "static" memory management?
13:00:47 <siers> I need wait+catch all, then continue
13:01:11 <Ariakenom> I'm guessing not static as in the C keyword
13:01:14 <hpc> Ariakenom: static/dynamic in the sense of say, static analysis
13:01:25 <hpc> where you know what's going to happen before the code is run
13:01:36 <hpc> in C, you know because you have where all the malloc and free lines are
13:01:40 <hpc> assuming you don't have bugs
13:01:42 <cocreature> siers: "traverse waitCatch"
13:01:57 <hpc> static types are where you know the types of expressions without having to run them
13:02:08 <hpc> in rust, the static type system includes memory management information
13:02:21 <cocreature> “assuming you don’t have bugs” I could have saved myself a lot of time if that assumption would hold :)
13:02:50 <hpc> garbage collectors are dynamic memory management - you don't know when memory will be freed even if you run the same program twice in a row, sometimes
13:02:57 <Ariakenom> hpc: yeah ok. note that static memory means memory allocated for the entire program
13:02:57 <siers> cocreature, If I mapM_ print the errors from the [Either], then if the middle one returns, will it call print before the first async finishes?
13:03:11 <hpc> ah, that's a good point
13:03:32 <hpc> there's not really a good term for it, and i don't think "manual" is the right one even though C is described that way
13:04:08 <cocreature> siers: depends if you do "traverse print <=< traverse waitCatch" it will first execute all of them and then start printing. if you do "traverse (print <=< waitCatch)" it will print each of them as they finish
13:04:38 <shapr> @remember cocreature “assuming you don’t have bugs” I could have saved myself a lot of time if that assumption would hold :)
13:04:38 <lambdabot> Good to know.
13:04:45 <Ariakenom> hpc: wont Garbage Collection fit as a term?
13:05:31 <cocreature> C-style memory management can be summarized as “your program will segfault regardless of how hard you try to avoid it”
13:05:35 <hpc> it's not really garbage collection though - memory never gets into a "garbage" state, the frees are just automatic
13:05:38 <siers> cocreature, :D:D
13:05:44 <siers> about the C bashing
13:05:52 <siers> cocreature, hm, I'll try that
13:06:00 <hpc> siers: bash is a different language entirely :P
13:06:05 <siers> :P
13:06:14 <siers> cocreature, I do have to visit friends now, so I'll have to try that in about a day
13:06:16 <finnkauski> only the nerdiest of jokes allowed :D 
13:06:24 <siers> cocreature, thank you for the feedback!
13:06:30 <cocreature> siers: np, have fun :)
13:07:03 <cocreature> bash on its own isn’t even too bad but once the bash you execute is the result of 5 layers of string interpolation in various languages it gets really weird
13:07:07 * hackage parsix 0.1.0.3 - Parser combinators with slicing, error recovery, and syntax highlighting  https://hackage.haskell.org/package/parsix-0.1.0.3 (OlleFredriksson)
13:07:34 <ibloom> cocreature: I’m realizing that mod can be really fast if you know it’s 1 cycle or less.
13:08:12 <ibloom> Just one comparison and one addition.
13:08:48 <Ariakenom> hpc: oh yes. I got confused about what term we were talking about
13:14:07 <Ariakenom> ibloom: I've run into that "mod" case several times
13:14:18 <Ariakenom> in situations I don't really wan't a full mod too
13:16:11 <Ariakenom> "nt" with apostrophe is too common :p muscle memory
13:18:09 <cocreature> ibloom: iirc there was some cppcon talk by chandler carruth where he had some benchmark that got faster by changing llvm to replace every mod by an if-clause that first checks if the mod is actually required and only applies it in that case :)
13:18:27 <shapr> sounds like the TIS-100 code I was working on yesterday
13:22:43 <cjay-> does cabal new-build apply --extra-include-dirs and --exta-lib-dirs to all dependencies?
13:25:37 * hackage string-interpolate 0.0.1.0 - Haskell string interpolation that just works  https://hackage.haskell.org/package/string-interpolate-0.0.1.0 (williamyaoh)
13:26:44 <finnkauski> what are these hackage strings? 
13:26:56 <hpc> package updates
13:27:00 <finnkauski> thoughts so
13:27:04 <finnkauski> awesome 
13:27:42 <cjay-> has anyone gotten vulkan-api to work with MoltenVK on macOS?
13:28:51 <[exa]> cjay-: any specific issue?
13:29:38 <cjay-> [exa]: I try to get vulkan-examples to run, and always get the error "GLFW reports that vulkan is not supported!"
13:30:07 <cjay-> I tried --extra-lib-dirs and --extra-include-dirs to use the vulkan sdk, didn't work
13:31:03 <cjay-> I also looked at glfw source code, which is included in bindings-GLFW. I don't fully understand it.
13:31:37 <cjay-> building the C code with cabal seems to exclude the possibility to link with the MoltenVK framework, because cmake stuff is omitted
13:32:04 <cjay-> unless cabal calls cmake on its own
13:33:18 <cjay-> the file in glfw that does the dlopen call doesn't specify the right name for the .dylib, it only decides between .dll and .so.1
13:33:23 <cjay-> maybe I should try modifying it
13:33:36 <cjay-> but the vulkan-api author claimed that his stuff is tested with moltenvk
13:34:30 <cjay-> I guess I have to bother the author then. Have tried enough stuff and failed 
13:34:38 <[exa]> cjay-: can you try some LD_PRELOAD or LD_LIBRARY_PATH trick to smuggle the correct library in?
13:35:05 <[exa]> I don't recall how MoltenVK dodges the issue with glfw, but I thought they just have their own libs
13:35:54 <[exa]> (also, check version of glfw)
13:36:59 <cjay-> hmm LD_PRELOAD equivalent is called DYLD_INSERT_LIBRARIES on macOS. trying that now
13:38:18 <cjay-> doesn't change the error message. hmm.
13:38:49 <cjay-> glfw c-code is included in bindings-GLFW. I could try to tell it to use the glfw from homebrew though
13:39:34 <cjay-> how do I set flags for a cabal package that is a dependency?
13:43:19 <monochrom> onoes, I didn't notice GHC 8.6.4 is out.
13:43:52 <finnkauski> whats the speed of releases for ghc and how major are the changes ? 
13:44:03 <hpc> quick, someone tell monochrom that 8.6.4 is out!
13:44:48 <hpc> finnkauski: new stuff is added pretty regularly
13:44:50 <cjay-> damn. rejecting: bindings-GLFW:-system-glfw (constraint from command line flag requires opposite flag selection)
13:45:39 <hpc> it doesn't show itself the way that most other language changes would, because of haskell's extension mechanism
13:46:05 <finnkauski> yeah thats another massive area to explore i suppose 
13:46:09 <finnkauski> gosh, tons of reading 
13:48:25 <cjay-> ok glfw from homebrew doesn't help either
14:05:11 <sternmull> i build with "stack build --fast --profile" and run with "+RTS -xc" and get stacktraces for unhandled exceptions... but they have no line numbers. Can i switch them on?
14:09:21 <hololeap> is it possible to run a (ReaderT r (ST s) a) ?
14:09:37 <hpc> yes
14:09:46 <hpc> @unmtl ReaderT r (ST s) a
14:09:46 <lambdabot> r -> ST s a
14:10:15 <monochrom> runST (runReaderT ??? initial_something)
14:10:17 <hpc> oh wait, it's ST
14:10:17 <hpc> hmm
14:11:09 <monochrom> @type \x y -> runST (runReaderT x y)
14:11:10 <lambdabot> error:
14:11:10 <lambdabot>     • Couldn't match expected type ‘ReaderT p1 (ST s) a’
14:11:10 <lambdabot>                   with actual type ‘p’
14:11:34 <monochrom> Ah, I have to re-think.
14:11:53 <hpc> :t runReaderT
14:11:54 <lambdabot> forall k r (m :: k -> *) (a :: k). ReaderT r m a -> r -> m a
14:12:18 <hololeap> it's saying in GHCi that type s would escape its scope, but i don't see how that is true
14:13:02 <monochrom> Possibility unimpredicativity kicks in.
14:13:10 <hpc> would it need to be ReaderT r (forall s. ST s) a?
14:13:31 <monochrom> "ReaderT r (forall s. ST s) a" may have a better chance, yeah.
14:13:57 <monochrom> err, s/may/would/   (you can't have that)
14:15:00 <hololeap> @type runReaderT @_ @_ @(forall s. ST s)
14:15:01 <lambdabot> error: parse error on input ‘@’
14:15:29 <hololeap> it says in my GHCi: GHC doesn't yet support impredicative polymorphism
14:16:37 * hackage hdevtools 0.1.8.0 - Persistent GHC powered background server for FAST haskell development tools  https://hackage.haskell.org/package/hdevtools-0.1.8.0 (ch1bo)
14:17:58 <Solonarv> % let runReaderST :: (forall s. ReaderT e (ST s) a) -> e -> a; runReaderST rst e = runST (runReaderT rst)
14:17:58 <yahb> Solonarv: ; <interactive>:8:89: error:; * Couldn't match expected type `ST s a' with actual type `e -> ST s0 a'; * Probable cause: `runReaderT' is applied to too few arguments; In the first argument of `runST', namely `(runReaderT rst)'; In the expression: runST (runReaderT rst); In an equation for `runReaderST': runReaderST rst e = runST (runReaderT rst); * Relevant bindings include
14:18:00 <Cale> It also seems unlikely for a polytype like that to have an instance of Monad
14:18:08 * hackage gi-gio 2.0.19 - Gio bindings  https://hackage.haskell.org/package/gi-gio-2.0.19 (inaki)
14:18:10 <Solonarv> % let runReaderST :: (forall s. ReaderT e (ST s) a) -> e -> a; runReaderST rst e = runST (runReaderT rst) e
14:18:11 <yahb> Solonarv: ; <interactive>:9:89: error:; * Couldn't match expected type `ST s (e -> a)' with actual type `e -> ST s0 a'; * Probable cause: `runReaderT' is applied to too few arguments; In the first argument of `runST', namely `(runReaderT rst)'; In the expression: runST (runReaderT rst) e; In an equation for `runReaderST': runReaderST rst e = runST (runReaderT rst) e; * Relevant bindin
14:18:18 <Solonarv> bah!
14:18:23 <Solonarv> % let runReaderST :: (forall s. ReaderT e (ST s) a) -> e -> a; runReaderST rst e = runST (runReaderT rst e)
14:18:23 <yahb> Solonarv: 
14:18:29 <Solonarv> % :t runReaderST
14:18:29 <yahb> Solonarv: (forall s. ReaderT e (ST s) a) -> e -> a
14:18:35 <Solonarv> there we go ^
14:18:44 <Solonarv> no impredicative stuff needed
14:18:55 <Solonarv> hololeap^
14:19:04 <hololeap> thanks Solonarv 
14:19:07 * hackage grids 0.5.0.1 -   https://hackage.haskell.org/package/grids-0.5.0.1 (ChrisPenner)
14:20:18 <Cale> ah, yeah, if you want to define the thing which runs it, that needs to be rank-2 as well of course
14:20:33 <Cale> (and GHC won't infer a higher-rank type, you have to write it)
14:21:07 <Solonarv> note that it takes a (forall s. ReaderT e (ST s) a), not a ReaderT e (forall s. ST s) a
14:21:24 <Solonarv> that's where the impredicativity error came from
14:21:53 <hpc> :t runST (runReaderT undefined undefined)
14:21:54 <lambdabot> a
14:22:10 <hpc> ah, good call
14:22:51 <Solonarv> :t \x y -> runST (runReaderT x y)
14:22:52 <lambdabot> error:
14:22:52 <lambdabot>     • Couldn't match expected type ‘ReaderT p1 (ST s) a’
14:22:52 <lambdabot>                   with actual type ‘p’
14:30:48 <mszh> hi guys, total haskell noob here. i'm trying to apply the idea that "illegal states should be impossible to represent in the (type) system", but can't figure it out how to design types to enforce this. here's the problem: i have a board with a single chess figure (knight for example). is it possible to design the types so that they would prevent illegal moves? knight moves by jumping to squares horizontally and one vertically, or two v
14:32:04 <finnkauski> haskell noob here as well, but feels like the type of move allowed for each piece can be defined
14:32:22 <phadej> it can, but it might not be pleasant to work with
14:32:23 <finnkauski> you could presumably even make a typeclass of Moves 
14:32:46 <finnkauski> and make instance Move Knight 
14:32:56 <finnkauski> and define what it has to be inside? 
14:35:14 <mszh> khm, thanks, will think about it
14:35:31 <mszh> karma finnkauski
14:35:34 <finnkauski> im surprised no one corrected me. 
14:36:09 <finnkauski> mszh: thanks haha, don't thank me until the idea bears fruit 
14:36:10 <mszh> :prefix karma finnkauski
14:36:26 <mszh> just tryin' :) 
14:36:37 <mszh> preflex: karma finnkauski
14:36:44 * ski looks curiously at mszh
14:36:54 <ski> preflex is long gone ?
14:37:16 <mszh> @karma finnkauski
14:37:16 <lambdabot> finnkauski has a karma of 0
14:37:18 <ski> @help karma+
14:37:19 <lambdabot> karma+ <nick>. Increment someone's karma
14:37:38 <mszh> @karma+ finnkauski
14:37:38 <lambdabot> finnkauski's karma raised to 1.
14:37:47 <ski> there's also the <nick>++ shorthand, i think
14:38:15 <ski> (not that i would suggest using it)
14:39:32 * ski doesn't even recall preflex had karma facilities
14:39:46 <ski> preflex: xseen mmorrow
14:40:22 <mszh> a move would be a type, and there could be a special type of move for each piece. there're max 8 possible movies for a knight, so when "a move is applied to a knight piece", then it could return possible legal landing positions
14:40:26 <mszh> something like that?
14:41:11 <Cale> mszh: In order to do something like that, the type of the board that the function acts on would need to include information about what pieces were on it, so that the legality of the move could be checked statically. This might be a property that you would rather enforce at a module boundary.
14:41:47 <mszh> i still don't see how to write this so that illegal moves would get caught by the compiler. i mean, it would catch errors where one tries to move a knight like a rook
14:42:06 <Cale> i.e. don't expose the raw data constructor for boards, but instead, provide a bunch of functions for manipulating boards which ensure the resulting board is valid if the input is.
14:42:12 <phadej> start with `data Location = Location Int Int` is won't help
14:42:27 <phadej> you'd need `data Location = Location OneToEight OneToEight`
14:42:37 <Cale> So you'd have something like movePiece :: Location -> Location -> Board -> Maybe Board
14:42:39 <delYsid> chess at the type level?
14:42:43 <ski> Cale : but that's cheating, not ? ;)
14:42:52 <mszh> i know how to achieve that by using encapsulation (and OOP), but was just wondering if it's possible to have static type checking on something like this
14:42:57 <Cale> ski: sure, but it's the right kind of cheating for Haskell.
14:43:03 * ski smiles
14:43:15 <Cale> If you want to do more, then you really need something dependently typed.
14:43:28 * ski thinks what mszh is after would be easier in what Cale said
14:43:51 <mszh> what does that mean? think i heard "dependent types" in some talk, is that what you're suggesting?
14:44:00 <phadej> don't go there
14:44:04 <phadej> you will be only confused
14:44:33 <Cale> Haskell is nearly dependently typed, so you can maybe, with a lot of effort, encode the contents of the board at the type level, and ensure that the functions which move pieces can only perform valid moves, but that's a lot of type-level programming to do, and the end result probably won't be very useful.
14:44:53 <phadej> nods
14:45:04 * ski ponders a type class with sixtyfour arguments
14:45:12 <Cale> Because the next thing you'll want is to write code that operates on arbitrary boards, so now you need a way to say "oh, but such and such piece needs to be on the board"
14:45:20 <mszh> got it, thanks!
14:45:28 <hpc> ultimately, chess is probably not a good match for type-level stuff
14:45:30 <Cale> (and you need a way to know that *at compile time*
14:45:31 <Cale> )
14:45:32 <mszh> @karma+ Cale
14:45:32 <lambdabot> Cale's karma raised to 92.
14:45:59 <hpc> you're generally looking for some property that simplifies things, and chess doesn't have that
14:46:02 <hpc> pretty much by design
14:46:10 <Cale> It's possible, but really complicated, and the example you've chosen is probably more complicated than I'd be comfortable attempting in Haskell.
14:46:27 <hpc> say you get knight moves working
14:46:38 <hpc> now you need to handle intervening pieces, which is maybe not too hard
14:46:47 <hpc> then you need to do pawns, well how do you handle en passant
14:46:48 <hpc> and castling
14:47:01 <hpc> castling moves two pieces and has loads of conditions on when it's legal
14:47:08 <Cale> and knowing that you can't move a knight out of the way when it would put your own king in check... at the type level
14:47:10 <delYsid> And eliminating moves which would end up in check...
14:47:14 <Cale> lol
14:47:33 <Cale> It's a bit much to put into the types
14:47:34 <hpc> a good term i heard elsewhere that i think applies well here is "simplifying assumption"
14:48:09 <mszh> thanks a lot, really needed to hear what's your intuition on this
14:48:20 <hpc> given some larger problem space, like "all numbers", is there a simplifying assumption you can make in your problem, like "the numbers are positive"
14:48:28 <hpc> if so, then you make a type capturing the assumption
14:49:28 <delYsid> And once you are done with all of it, you realize performance is so bad that it isn't even practical to typecheck say, a PGN file...
14:49:31 <Cale> mszh: In Haskell, just asking for natural-number arithmetic at the type level is already a bit of a stretch -- Everything is okay so long as you're working with constant numbers
14:50:19 <Cale> But when you get to numerical variables at the type level, you end up with problems like (n + 0) and n not unifying with each other, because they're not literally the same expression, and then you need to talk about properties of numbers.
14:50:41 <Cale> and even this is possible, but a little cumbersome still
14:51:39 <finnkauski> again, noob here but thought somethign like this might work?? http://dpaste.com/1YE6BJM where the legal then would check if the entries in a list match the Eight possible ones and don't go over the edges of the board?
14:51:53 <ziman> i think it's useful to use types to model properties that help you catch programming errors, rather than rules of your game, which cost a lot of effort but won't make your program more reliable
14:52:16 <ziman> or assist you in writing it
14:53:11 <ski> allowing user to perform invalid moves would be a programming error, no ?
14:53:39 <Cale> What ought to be encoded in types is always a balancing act. Just because it's possible to guarantee a property that ought to hold, doesn't always mean it's worth the cost of guaranteeing that thing.
14:53:42 <mszh> i know what you're trying to say, i'm not a noob programmer, got 10yrs of OO, but new to haskell and FP, so just wondering how much could be accomplished by the type system
14:53:47 <ziman> that classification is of course up to interpretation :)
14:54:24 <Cale> mszh: Eventually you'll want to check out languages such as Coq, Agda and Idris, which go farther in regard to what they allow types to guarantee.
14:55:09 <Cale> mszh: Coq and Agda are designed such that types are effectively mathematical propositions, and the programs you write to satisfy them are effectively proofs of those.
14:55:40 <ski> @quote warded.off
14:55:40 <lambdabot> Pseudonym says: Olegs can be warded off by adding a note claiming that it's impossible to implement in the type system.
14:55:50 <Cale> Idris is similar, but tries to be a little more pragmatic about allowing you to write programs with general recursion when you want to.
14:56:27 <Cale> (and isn't really aimed at being a system in which to encode mathematics)
14:57:46 <Cale> But this is only *slightly* out of Haskell's reach, and most of the ways that Haskell has changed over the last decade or so can be viewed as moves in that direction.
14:59:00 <Cale> Even *if* you have dependent types though, if your goal is to write programs that do stuff, rather than just prove whether or not something is true, you still have to answer these questions about whether encoding any given thing in the types is going to pay off.
14:59:00 <Solonarv> there's work actively being done on moving Haskell towards having full dependent types; but since they're being added to an existing language there's a lot more work to do than if one were designing a dependently-typed language from scratch
14:59:58 <Cale> How many bugs do I prevent, and is preventing them worth the up-front cost of extra type-level complexity?
15:00:13 <Cale> (often it is, but sometimes not!)
15:00:26 <monochrom> My take is that I put it as "expression" vs "encoding", and then I always welcome expressions and reject encodings.
15:01:12 <Cale> monochrom: Is that another one for your list though?
15:01:20 <monochrom> What list?
15:01:25 * ski encodes expressions
15:01:37 <Cale> The list of possibly-tautological statements
15:02:13 <monochrom> No, it is still subjective and full of grey areas how to draw the line between expression and encoding.
15:03:09 <monochrom> But we have as much consensus as for example what counts as "tea".
15:03:46 <Cale> We determine if a type is an expression or encoding based on whether it's the sort of type which will be welcomed.
15:03:47 <finnkauski> Tea is life. 
15:03:50 <ziman> you mean that you "encode" stuff that the target language wasn't meant for, while you "express" the rest?
15:03:55 <MarcelineVQ> tea must contain tea, other opinions are heretical.
15:04:08 <finnkauski> MarcelineVQ: +1
15:04:21 <MarcelineVQ> flowers in hot water isn't tea, it's dirty water
15:04:26 <monochrom> For example I'm pretty sure most agree that on http://www.vex.net/~trebla/compsci/imperative-functional.html the imperative version is an encoding of an otherwise easily-expressed recursive algorithm.
15:04:38 <finnkauski> MarcelineVQ: -1
15:04:57 <MarcelineVQ> finnkauski: note that adding tea to the flowers restores the tea property
15:05:10 <ski> lambdabot doesn't grok those messages, i think
15:05:11 <finnkauski> MarcelineVQ: Maybe 1
15:05:16 <mszh> wasn't there a talk by P. Wadler on that topic, types as propositions? 
15:06:05 <Cale> It wouldn't surprise me at all. This is a big idea in this part of computer science and logic generally
15:06:19 <finnkauski> MarcelineVQ: also just realised what your name stands for 
15:06:28 <Cale> It's called the Curry-Howard correspondence
15:06:34 <mszh> https://www.youtube.com/watch?v=aeRVdYN6fE8
15:06:43 <Cale> To give a sense of it, I think it helps to look at implication
15:07:20 <Cale> In logic, when you want to prove that A implies B, it suffices to assume that A is true, and having done so, find a way to manage to conclude B
15:07:47 <monochrom> Expression is when you directly write what you mean. Encoding is when you can't directly write what you mean, but you go "ah but I can use the Turing tarpit" and jump through hoops, and your audience have to jump through the same hoops.
15:08:23 <Cale> In lambda calculus, if you want to construct a function f: A -> B, it suffices to assume that you have a variable x: A, and from it, construct an expression y: B, and then you can conclude (\x -> y) : A -> B
15:08:24 <monochrom> For another example: How mathematicians say "a tuple (x,y) is the set {{x}, {x,y}}" or something like that.
15:08:44 <Cale> In logic, if you know that A -> B, and you know that A, then you may conclude B (modus ponens)
15:09:10 <Cale> In lambda calculus, if you have f: A -> B, and you have x: A, then you may construct f x: B
15:09:23 <Cale> (i.e. function application)
15:09:29 <ski> monochrom : i wrote a somewhat similar program (re using an array), in C, except it did backtracking, and so used `goto' to jump into and out of a `for' loop
15:09:54 <Cale> similarly, the rules of logic governing AND are structurally identical to the rules of lambda calculus governing a pair type
15:10:00 <Cale> and OR with Either
15:11:45 <Cale> This shouldn't really come as such a surprise: type theory and lambda calculus started out in attempts at formalisation of mathematics.
15:12:25 <monochrom> We need to marry them and say "typed lambda calculus theory".
15:12:37 * ski . o O ( "Locus Solum: From the rules of logic to the logic of rules" by Jeav-Yves Girard in 2001 at <http://girard.perso.math.cnrs.fr/0.pdf> )
15:12:46 <MarcelineVQ> monochrom: that's just madness
15:12:52 <monochrom> haha
15:12:55 <Cale> ski: that's just madness
15:13:10 <Cale> (had to do it)
15:13:54 <Solonarv> I mean, typed lambda calculi already exist - Haskell is based on them!
15:14:24 <MarcelineVQ> Solonarv: that's just silly
15:15:01 * [exa] arrives at #haskell
15:15:08 <[exa]> is it sunday evening again?
15:15:16 <monochrom> Yes.
15:16:09 <monochrom> Whereas everyone else has Monday don't-want-to-go-to-work symptoms, I have Sunday evening don't-want-to-work symptoms.
15:17:05 <ski>   1900-1930, the time of illusions :  Naive foundational programs, like Hilbert's, refuted by Gödel's theorem.
15:17:19 <monochrom> Because basically I have to release lab exercises for the week on Sunday evenings.  Sometimes also assignments.  On the bright side, after getting over that, my Mondays are my holidays!
15:17:23 <ski>     1930-1970, the time of codings :  Consistency proofs, monstrous ordinal notations, /ad hoc/ codings, a sort of voluntary bureaucratic self-punishment.
15:17:42 <ski>   1970-2000, the time of categories :  From the mid sixties the renewal of natural deduction, the Curry-Howard isomorphism, denotational semantics, System F ... promoted (with the decisive input of computer science) an approach in which the objects looked natural and reasonably free from foundational anguish.
15:18:44 * ski likes the formulation of the middle period
15:20:59 <[exa]> "free from foundational anguish" yay
15:22:17 <Cale> "voluntary bureaucratic self-punishment" haha
15:23:17 <[exa]> monochrom: programming lab? I've recently been creating exercises just by encoding random well-known problems into a first usable thing that comes from wiki's random article link
15:36:21 <sm> is there a tool for bulk-adding upper-bound revisions to a bunch of package versions on hackage ?
15:36:53 <sm> if I do it right, I should do this one on 10 versions, which is too much clicking
15:45:38 <slack1256> cabal new-freeze?
15:47:51 <sm> I don't think so slack1256. I've been told about hackage-cli
15:48:10 <MarcelineVQ> if the bounds all need the same update there's sed :>
15:55:40 <MarcelineVQ> eh, maybe not, I guess >= and <= and the like can appear in any order, but tend to appear with > before <
15:56:50 <fragamus> Howdy I’m making a higher order function that normalizes a function such that it’s integral is equal to 1. It is done numerically. How do I make sure the computationally intensive numerical operation doesn’t happen every time somebody calls the normalized function?
15:58:05 <slack1256> fragamus: Checkout how Data.Ratio does it. It too doesn't normilize at every step
15:58:30 <fragamus> Okie
16:00:37 <fragamus> I wish I could do it analytically but I don’t think that math exists yet
16:01:00 <sm> soo, I used to read haskell mail lists with thunderbird and gmane, but my gmane groups have disappeared. Just me ? Or did gmane finally go offline ?
16:01:53 <monochrom> I think gmane is no more.
16:02:46 <monochrom> gmane has been like "we're renovating, come back later" for like 5 years.
16:03:36 <monochrom> Every restaurant that posts "we're renovating, come back later" for more than 6 months are always gone permanently, in my experience.
16:03:43 <fen> is there a version of cofree that has "end" aswell?
16:03:58 <monochrom> s/are/is/
16:03:58 <sm> yes, but it has been working fine.. until quite recently
16:04:15 <fen> like, for a tree with different values at the leafs than at the branches
16:04:21 * sm has no other NNTP client to test with
16:04:28 <hpc> s/restaurant/thing
16:06:11 <fen> cofree' g f a = f (cofree g f a) | g a
16:06:25 <fen> s/cofree/cofree'
16:06:48 <fen> must have a better representation...
16:06:51 <sm> ha, actually that was a lie.. I have gnus. But I'm not quite over my former gnus- tweaking addiction. Still I fired it up and it's loading the haskell groups just fine
16:09:43 <fen> cofree'' f a b = f (cofree'' f a b) | b, then cofree' g f a = cofree'' f a (g a)
16:11:39 <fen> it allows generalisation of a zipper f a = ([f a -> f a],f a). instead of a list of differences, you have a cofree [] of them
16:12:18 <fen> well, with the "forward" portion (the rest of the zipper) needing to be placed at the "end" of the cofree
16:14:24 <fen> which allows the reuse of the common previous paths of pointers to different leafs of a tree
16:21:13 <fen> just feel slightly uneasy about just adding an extra constructor to cofree because it seems like it must have some dual 
16:23:48 <fen> it could be made using something other than list, but it seems more straitforward to add the extra constructor
16:24:28 <fen> rather than trying to handle the "end" case by altering the `f' of cofree f.
16:25:16 <fen> maybe a better way to answer is to ask what is dual to cofree'' f a b = f (cofree'' f a b) | b ?
16:26:56 <fen> not really sure how to understand cofree f a = f (cofree f a) as dual to free f a = f (free f a) | a
16:27:40 <fen> its just turning a sum datatype into a product datatype?
16:28:33 <fen> doesnt seem like that can be inverted after adding another sum constructor to cofree...
16:29:16 <fen> perhaps cofree'' above has another name
16:29:53 <fen> ee
16:30:36 <fen> seems oddly to be its own dual under that changing of product to sum...
16:31:24 <fen> oh no, had written it wrong;
16:31:56 <fen> data Cofree'' f a b = Cofree a (f (cofree'' f a b)) | End b
16:32:34 <Solonarv> fen: cofree f a = a * f (cofree f a), which indeed dual to free f a = a | f (free f a)
16:33:24 <fen> so this is like x * y + z <-> x + y * z 
16:34:29 <fen> cofree'' f a b <-> cofree'' f b a
16:35:04 <fen> Solonarv: ever heard of that?
16:35:28 <fen> fix + end = Free. cofree + end = ?
16:36:08 <fen> it needs the extra param `b'. normally we would just use f = Maybe
16:36:17 <Solonarv> I don't know if that's anything particularly sensible or well-behaved, tbh
16:36:24 <fen> or, f with `end'
16:37:24 <fen> Solonarv: there are properties of Free which kind of establish it as special, its monad instance from Functor f in particular
16:37:31 <fen> maybe this has some properties
16:38:05 <fen> what would we expect it to have? something to do with Comonad?
16:38:53 <fen> 2 params kind of messes that up
16:39:40 <Solonarv> Consider the following: Free f a = Fix (Compose (Either a) f); Cofree f a = Fix (Compose ((,) a) f)
16:40:01 <fen> and the possibility of f having end also means it might not end using end, which is not good. maybe it needs a nonempty f constraint
16:41:01 <Solonarv> or using (.) for Compose: Free f a = Fix (Either a . f); Cofree f a = Fix ((,) a . f)
16:41:09 <fen> so this is like compose compose ((,) a) (Either b) ?
16:42:35 <fen> ? f a b = Fix ((Either b . (,) a) f)
16:42:37 <Solonarv> It then becomes obviousthat there are two ways to combine those:
16:42:37 <Solonarv>  - Fix (Either a . (,) b . f) which is = Free ((,) b . f) a
16:42:37 <Solonarv>  - Fix ((,) a . Either b . f) which is = Cofree (Either b . f) a
16:42:52 * ski . o O ( `Mu' vs. `Nu' )
16:43:40 <fen> Solonarv: nice
16:43:55 <Solonarv> ski: shhh
16:44:08 <fen> Mu + Nu ?
16:44:28 * ski smiles
16:44:53 <fen> can we retain any of the monad / comonad aspects of free / cofree ?
16:49:33 <fen> well anyway, its a tree with different things at the leaves than at the branches. and its not dual to free or cofree and seems at least to have some nice symmetric properties wrf Fix so maybe is a valid 3rd thing to free / cofree? 
16:49:36 * ski . o O ( cofree + coend = ? )
16:50:23 <fen> co end is not the same as end as in [] ?
16:51:37 <ski> a coend is a terminal wedge
16:52:09 <fen> doesnt seem like it shouldnt have occured before. but maybe it doesnt have good properties for category theory to have studied it. plenty of literature on free/cofree
16:53:39 <fen> ski: oh, like a co-fixed point or something, like initial conditions to repeated application of some profunction morphism or something...
16:53:45 <orzo> I want a tool (preferably command-line but i use vim) to automatically add inferred type signatures to my source file.  Anybody know one?
16:54:19 <Solonarv> as I pointed out, there's two ways to construct it - do you put the sum or the product on the outside? - and I don't see how either of them retain any properties of the other
16:54:56 <fen> that just switches the role of a and b though right?
16:54:57 <Solonarv> simply put: if you put the sum on the outside you can't write 'extract', so you don't get a comonad; if you put the product on the outside you can't write 'return', so you don't get a monad
16:55:28 <ski> `forall a. [a] -> [a]' is an end. `exists a. (a,a -> a,a -> Bool)' is a coend
16:56:14 <Solonarv> fen: No, this is about the difference between μ r. (a, Either b (f r)) and μ r. Either a (b, f r)
16:57:18 <fen> oh, like, does the leaf value also have the a value of the type held at the branches
16:57:26 <Solonarv> shuffling the order of type parameters doesn't matter here
16:57:42 <ski>   Free f a  =  Mu ((a +) . f)  =  mu r. a + f r  =  forall r. (a + f r -> r) -> r  =  forall r. (a -> r) * (f r -> r) -> r  =  forall r. (a -> r) -> (f r -> r) -> r
16:58:39 <ski>   CoFree f a  =  Nu ((a *) . f)  =  nu s. a * f s  =  exists s. s * (s -> a * f s)  =  exists s. s * (s -> a) * (s -> f s)
17:00:20 <fen> and this new thing?
17:00:36 <fen> not that those continuations are easy to parse
17:01:33 <fen> yeah, actually cant read any of that
17:01:56 <stevenxl> Hi folks. Hi have the type "newtype T6 a = T6 ((a -> Int) -> Int)". A is in positive position, so it should be possible to create a valid instance of Functor for this type. When I get down to implementing such an instance, though, I get stuck: https://gist.github.com/StevenXL/e0f70e100d1b212163765806d043599e
17:02:19 <ski> generally, `mu r. ..r..' is `forall r. (..r.. -> r) -> r', while `nu s. ..s..' is `exists s. s * (s -> ..s..)'
17:02:32 <Axman6> stevenxl: style holes can help a lot here
17:02:39 <ski> (the latter is "OO")
17:02:42 <stevenxl> Axman6: I'm not familiar.
17:03:03 <Axman6> % netypew T6 1 = T6 ((a -> Int) -> Int)
17:03:03 <yahb> Axman6: ; <interactive>:12:9: error:; Not in scope: data constructor `T6'; Perhaps you meant variable `_6' (imported from Control.Lens); <interactive>:12:20: error: Pattern syntax in expression context: (a -> Int) -> Int
17:03:10 <Axman6> % netypew T6 a = T6 ((a -> Int) -> Int)
17:03:10 <yahb> Axman6: ; <interactive>:13:9: error:; Not in scope: data constructor `T6'; Perhaps you meant variable `_6' (imported from Control.Lens); <interactive>:13:20: error: Pattern syntax in expression context: (a -> Int) -> Int
17:03:21 <Axman6> % newtype T6 a = T6 ((a -> Int) -> Int)
17:03:21 <yahb> Axman6: 
17:03:23 <Solonarv> "typed holes", not "style holes"
17:03:33 <Axman6> %type T6
17:03:48 <Axman6> uh, yes, how did I even type that
17:03:59 <Axman6> % :t T6
17:03:59 <yahb> Axman6: ((a -> Int) -> Int) -> T6 a
17:04:06 <Solonarv> quick, blame autocorrect!
17:04:12 <Axman6> yeah...
17:05:41 <Axman6> anyway, using them you can write: fmap f (T6 g) = T6 _wut and ghc will tell you need ((b -> Int) -> Int). not super helpful, but we do know we need a function
17:06:17 * ski . o O ( "Follow the types of the terms, follow the types of the terms ; Follow, follow, follow, follow, follow the types of the terms." )
17:07:43 <stevenxl> @Axman6 I'm with you so far, and the type holes is a great. 
17:07:43 <lambdabot> Unknown command, try @list
17:07:57 * ski finds using holes to be a bit cheating ;)
17:07:58 <Axman6> so we can write fmap f (T6 g) = T6 (\x -> _wut) and ghc will tell us we need Int, and we have x :: b -> Int and f :: a -> b, and g :: ((a -> Int) -> Int)
17:08:44 <Axman6> I'll give you a few minutes to see if you can connect those pieces together to reach the goal
17:09:01 <stevenxl> Axman6: thanks. brb
17:09:15 <ski> stevenxl : the idea is to view it like a puzzle, and try to fit the jigsaw pieces (or lego, if you prefer) together, to make a complete picture
17:09:21 <Axman6> (Remembering the goal is ((b -> Int) -> Int))
17:10:44 <fen> ski: thats pretty cool the way it get the type of the constructors at the end of the expansion. r = a + f r almost.
17:11:27 <ski> fen : not a coincidence. Church representation
17:11:51 <ski> (the latter one, with `exists', is the State representation)
17:12:11 <fen> the exists is just completely baffling 
17:13:35 * ski . o O ( "We believe in the duality of Church and State." )
17:13:40 <ski> consider
17:13:47 <ski> @type unfoldr
17:13:48 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
17:14:23 <ski> now, this may produce an infinite list, so `[a]' here is really `PotentiallyFiniteStream a', where
17:14:41 <ski>   PotentiallyFiniteStream a = nu s. 1 + a * s
17:14:59 <ski> now
17:15:26 <fen> oh wait, its not the constructors, its the monad and comonad class functions
17:15:38 <Axman6> stevenxl: any luck so far?
17:15:58 <ski>   nu s. 1 + a * s  =  exists s. s * (s -> 1 + a * s)
17:16:04 <ski> also consider
17:16:40 <ski>   unfoldr :: forall a b. (b -> Maybe (a,b)) -> b -> [a]
17:17:02 <ski>            = forall a b. (b -> 1 + a * b) -> b -> PotentiallyFiniteStream a
17:17:10 <stevenxl> Axman6: No. I understand that I have "f :: a -> b", "g : : (a -> Int) -> Int" and "x :: (b -> Int)
17:17:11 <ski>            = forall a. (exists b. b -> 1 + a * b) -> b -> PotentiallyFiniteStream a
17:17:31 <ski> er, sorry, that should be
17:17:39 <ski>            = forall a b. b * (b -> 1 + a * b) -> PotentiallyFiniteStream a
17:17:50 <ski>            = forall a. (exists b. b * (b -> 1 + a * b)) -> PotentiallyFiniteStream a
17:17:56 <stevenxl> But I'm struggling to compose these so that I get an int at the end. I can compose (x . f) which would have the type (a -> Int), but that still gives me a function
17:18:14 <stevenxl> that's not the right type given that we want _wut :: Int.
17:18:20 <ski> so going from `exists b. b * (b -> 1 + a * b)' to `PotentiallyFiniteStream a' is one direction of the isomorphism above
17:18:59 <ski> fen ?
17:19:03 <fen> yep
17:19:20 <stevenxl> oh wait
17:19:21 <stevenxl> dang
17:19:23 <stevenxl> it's right there
17:19:30 <stevenxl> g (x . f)
17:19:39 <stevenxl> Axman6: got it!
17:19:49 <ski> stevenxl : congrats :)
17:20:04 <stevenxl> ski:  thank you
17:20:09 <ski> stevenxl : with a little practice, you should be able to follow the types of the terms, in your head !
17:20:09 <stevenxl> Axman6: 
17:20:30 <stevenxl> Axman6:  thanks! The type holes trick is very very seufl.
17:20:31 <stevenxl> useful*
17:20:33 <ski> fen : "its not the constructors, its the monad and comonad class functions" ?
17:21:27 <Axman6> hooray!
17:21:30 <Axman6> well done :)
17:22:04 <fen_> still not sure about the free + cofree thing from before
17:25:57 * ski . o O ( "Initial is initial, terminal is terminal, and never the two shall meet (except at zero)." )
17:27:02 <fen> so we have μ r. (a, Either b (f r)) and μ r. Either a (b, f r)
17:27:13 <fen> can we write them using nu instead?
17:27:47 <ski> no
17:28:13 <ski> (unless you identify `Mu' and `Nu', as in Haskell)
17:29:00 <ski> `Mu' is least fixed point. `Nu' is greatest fixed point
17:29:41 <fen> CoFree f a  =  Mu ((a *) . f)  =  ...
17:29:59 <Solonarv> yeah, I was being a bit improper and mixed up mu and nu
17:30:30 <fen> mu s. a * f s  =  forall s.  (a * f s -> s) -> s
17:30:44 <fen> ?
17:30:44 <ski> any value of type `mu r. ..r..' has "finite depth" in the number of recursive uncoverings. for `nu s. ..s..' gets "infinite depth"
17:31:33 <fen> if ..r.. is a sum type?
17:31:43 <fen> with one part not mentioning r
17:31:44 <ski> doesn't matter, but often it is, yes
17:32:07 <ski> e.g. a value of type `[a]', considered in terms of `mu', will be finite
17:32:07 <fen> otherwise f = 1 + somethig
17:32:29 <ski> a value of type `Stream a', considered in terms of `nu', will be infinite
17:33:06 <ski> a value of type `PossiblyFiniteStream a', considered in terms of `nu', will possibly be infinite (and possibly be finite). the point is that infiniteness is allowed
17:33:26 <fen> we want cofree of (1+ something)
17:33:30 <ski> (but it's really about finite vs. infiniteness in "depth". but in these cases, it's the same thing)
17:34:10 <fen> ok
17:34:49 <ski> if you consider `mu r. a + Stream r', then you can think of those as "infinitely *wide*(-branching)" trees, that are nevertheless finite in depth
17:36:01 <fen> μ r. Either a (b, f r) 
17:36:36 <ski> that'd be trees with `a'-leaves, `b'-internal nodes, with `f'-branching
17:36:38 <fen> not sure what happens when the mu is expanded, are we supposed to get class functions it satisfies
17:37:36 <fen> forall r. (a + (b, f r)) -> r) -> r
17:38:15 <ski> (hm, to clarify. "that are nevertheless finite in depth" there means that if you traverse down the tree along any path, you'll eventually get to a leaf. that doesn't mean that the tree has a *global* finite depth, just that every branch is finite)
17:38:53 <fen> forall r. (a -> r) -> ((b, f r) -> r) -> r
17:39:04 <ski> (s/branch/branch path/)
17:39:25 <ski> forget about "class functions", i think
17:39:51 <ski> you get types of data constructor, basically. Church encoding
17:40:20 <fen> ah, but they were obvious anyway
17:40:46 <fen> [23:58] <ski>   CoFree f a  =  Nu ((a *) . f)  =  nu s. a * f s  =  exists s. s * (s -> a * f s)  =  exists s. s * (s -> a) * (s -> f s)
17:41:00 <ski> yes ?
17:41:10 <fen> that 3 way product type at the end doesnt seem like the constructors for cofree
17:41:26 <ski> destructors
17:41:37 <fen> hmm
17:41:41 <fen> ok
17:42:21 <fen> they are like extract and duplicate?
17:42:28 <ski> (but you don't count the initial `s *', just like you don't count the final `-> r' in the `mu' case)
17:42:40 <fen> oh, so thats just why it ends up being a comonad maybe
17:42:43 <ski> record fields
17:43:22 <fen> right ok
17:43:35 <ski> `s' is an "internal state"
17:44:03 <ski> think of an OO object, with "this" passed implicitly to the methods (the destructors/fields/selectors)
17:44:25 <fen> like how a continuation has a hidden value it implicitly stores 
17:44:44 <ski> it doesn't need to have
17:44:59 <ski> `NotNot (Either a (Not a))' doesn't
17:45:24 <ski> @djinn NotNot (Either a (Not a))
17:45:24 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
17:45:41 <ski> `NotNot' is a continuation monad (specifically `Cont Void')
17:45:50 <fen> forall r. (a -> r) -> r implies there was an `a' stored implicitly to apply the a -> r to
17:46:05 <ski> there is no value of type `Either a (Not a)' hiding inside that program
17:46:21 <fen> its the only way to return the forall r.
17:46:28 <ski> fen : yes. because of the `forall r.'
17:46:34 <ski> this is a special case of Yoneda
17:47:28 <ski> according to general Yoneda, `f a  =  forall r. (a -> f r) -> f r', assuming `f' is a (covariant) functor
17:48:22 <ski> er, sorry, it should be
17:48:27 <ski> according to general Yoneda, `f a  =  forall r. (a -> r) -> f r', assuming `f' is a (covariant) functor
17:48:37 <fen> right
17:49:02 <ski> (and CoYoneda similarly says that `f a  =  exists s. f s * (s -> a)', still assuming `f' is a (covariant) functor)
17:49:14 <ski> you can formulate contravariant variations of these, easily
17:50:07 * hackage arbor-monad-logger 0.1.0.0 - Simple logging library  https://hackage.haskell.org/package/arbor-monad-logger-0.1.0.0 (arbornetworks)
17:50:49 <fen> thats still more like a way to understand exists...
17:51:10 <ski> (`forall r. (a -> f r) -> f r' otoh is `CoDensity f a', the codensity monad. while `exists s. f s * (f s -> a)' is `Density f a', the density comonad)
17:52:55 <fen> that is just the same as the the (co)yoneda though
17:53:21 <fen> or is it, that by the (co)yoneda lemma, these both equal f a
17:53:52 <ski> hm, i think the adjunction expressing equivalence between `(exists s. ..s..) -> ...' and `..s.. -> ...' is more like a way to understand `exists'
17:54:41 <fen> oh, commuting it with parens gives a forall?
17:55:14 <ski> similarly, `... -> (forall r. ..r..)' is `... -> ..r..'
17:55:42 <ski> (with implicit quantifier `forall' over `s'/`r' in the right sides of those equivalences)
17:55:59 <ski> `CoDensity f' is `f', if `f' is already a monad. otherwise `CoDensity f' is not `f'
17:56:16 <ski> similarly for `Density f', and `f' a comonad
17:56:19 <fen> so, is any of this going to help understand the cofree'' thing above?
17:56:27 <ski> i dunno
17:56:35 <ski> (i've already forgotten what it was)
17:56:48 <fen> μ r. Either a (b, f r)
17:57:02 <fen> μ r. a + (b, f r)
17:57:08 * hackage wshterm 0.1.0.0 - Terminal emulator over websockets.  https://hackage.haskell.org/package/wshterm-0.1.0.0 (lukec)
17:57:20 <ski> <ski> that'd be trees with `a'-leaves, `b'-internal nodes, with `f'-branching
17:57:23 <fen> μ r. a + b * f r
17:57:59 <fen> yeah, but all this extra machinery to try to get at what it is
17:58:35 <fen> maybe its a member of some class like free/monad cofree/comonad
17:58:54 <ski> it's certainly a monad in `a'
17:58:57 <Solonarv> ski: that's actually not true - Codensity ((->) e) a = forall r. (a -> e -> r) -> e -> r = forall r. e -> ((e, a) -> r) -> r = e -> (forall r. ((e, a) -> r) -> r) = e -> (e, a) = State e a
17:59:04 <ski> (assuming `f' is a functor)
17:59:31 <Solonarv> or more succintly: Codensity ((->) e) = State e ≠ ((->) e)
17:59:48 <fen> ski: what about b?
18:00:05 <fen> if they werent the same under join
18:02:07 * hackage wshterm 0.1.0.1 - Terminal emulator over websockets.  https://hackage.haskell.org/package/wshterm-0.1.0.1 (lukec)
18:02:39 <fen> like, replacing the [] of the cotail of zipper with cofree gives a way to reuse common cotails of similar pointers, which correspond to paths which only diverge after some depth
18:02:42 <ski> Solonarv : oh, ty. so i must be misremembering (probably with the talk about `Yoneda' and `CoYoneda' ?) -- you should get translations in one direction, at least
18:03:14 <fen> but, it needs to be annotated at the end of the cofree (and certainly not be infinite) to contail the tail of the corresponding zipper
18:03:18 <ski> Solonarv : hmm .. i wonder whether one can fix this
18:03:28 <Solonarv> you can translate in both directions, but the 'Condensity f a -> f a' translation can be lossy
18:03:29 <fen> (cofree [] as the cotail instead of [])
18:03:58 <Solonarv> in the f ~ ((->) e) case I think it works out to just dropping the new state on the floor
18:05:17 <ski> (well, one direction requires `f' to be a monad (or at least pointed), no ?)
18:06:41 <ski> fen : hm, now you're going off talking about "cotail" and "pointer" again, and i don't follow
18:07:18 <Solonarv> ski: you need Pointed for the Codensity f ~> f direction
18:07:26 <ski> right
18:08:53 <Solonarv> lifting should only need Functor, I think
18:09:03 <Solonarv> % import Control.Monad.Codensity
18:09:03 <yahb> Solonarv: 
18:09:53 * ski . o O ( `CoDensity . CoDensity' )
18:09:59 <fen> ski: fair enough, but i though this was supposed to help answer that
18:10:02 <Solonarv> ah, nope - needs Monad
18:10:10 <Solonarv> % liftCodensity fa = Codensity $ \k -> k =<< fa
18:10:10 <yahb> Solonarv: 
18:10:14 <fen> otherwise, not really sure whats the use of learning this stuff
18:10:35 <ski> fen : just saying that i still don't really know what you mean by these terms
18:10:53 <fen> cotail of a zipper just being the opposite of the tail
18:11:11 <fen> the previously visited values of a suspended traversal
18:11:14 <ski> Solonarv : yea, i thought `(>>=)' was used somewhere as well
18:11:19 <ski> (couldn't recall where)
18:11:35 <Solonarv> I just typed-hole'd my way into it
18:11:55 <ski> @type ContT . (>>=)
18:11:57 <lambdabot> Monad m => m a -> ContT r m a
18:12:40 <fen> the idea is that using vertical zippers over free nonempty representing a tree, many of these will share some part of the path taken
18:12:42 <Solonarv> that explains why there's no 'liftCodensity' exported from Control.Monad.Codensity: it's just the usual 'lift' from MonadTrans
18:13:03 <ski> @type ContT . forM  -- doesn't work, without allowing the answer type to change, iow an indexed (continuation) monad
18:13:04 <lambdabot> error:
18:13:04 <lambdabot>     • Occurs check: cannot construct the infinite type: r ~ t r
18:13:04 <lambdabot>       Expected type: t a -> (a -> m r) -> m r
18:13:28 <fen> and we can save renavigating to the end of the common path using this version of zipper with the cotail as cofree''
18:13:35 <ski> `Free NonEmpty' ?
18:13:41 <fen> yeah
18:14:19 <ski> so `mu. a + r^+'
18:14:39 <fen> Tree a = Branches (Nonempty (Tree a)) | Leaf a = Free Nonempty
18:14:48 <fen> Free Nonempty a
18:14:49 <ski> yes, ok
18:14:56 <ski> (not the `Tree' in `Data.Tree')
18:15:06 <fen> well its a rose tree
18:15:14 <ski> yes
18:16:09 <fen> so then we have a tree pointer as; Zipper (Free (Zipper Nonempty)) a
18:16:21 <ski> and what's a "vertical zipper" ?
18:16:28 <fen> the zipper over free
18:16:56 <fen> ([Free f a -> Free f a],Free f a)
18:17:11 <fen> here, list is used as the cotail
18:18:15 <ski> i don't follow
18:18:22 <fen> and the other version of zipper using cofree'' (still needs a better name) is; Cofree'' Nonempty (f a -> f a) (f a)
18:18:25 <ski> how is `Zipper' defined ?
18:18:53 <fen> data Zipper = Zipper [Free f a -> Free f a] (Free f a)
18:19:04 <fen> data Zipper = Zipper [f a -> f a] (f a)
18:19:06 <fen> sorrt
18:19:21 <ski> why are there functions from `f a' to `f a' in there ?
18:19:31 <fen> its a "difference list"
18:20:13 <ski> doesn't look like difflists i've seen
18:20:23 <ski> so you have a list of "difference lists" ?
18:21:05 <fen> if we have class Set_r r f | f -> r; set_r r f:: (r a,f a) -> f a, then data Zipper f a where Set_r r f => Zipper :: [r a] -> f a -> Zipper f a
18:21:29 <fen> *set_r :: 
18:21:35 * ski sighs at the introduction of yet another type class
18:21:58 <fen> well it allows us to construct differences
18:22:30 <fen> its not a list of difference lists, its a list of differences
18:22:35 <ski> is `r' supposed to act on `f' ?
18:23:08 <fen> r a is everything that was placed behind while navigating forwards
18:23:30 <fen> navigating backwards you apply set
18:23:39 <ski> the "outer layers", or "context" ?
18:23:42 <fen> to the head of the cotail
18:24:02 <ski> "cotail" being ?
18:24:06 <fen> yeah, for f Free, r a = Free f a
18:24:39 <fen> cotail was explained before, its refering to the part of the zipper storing things placed in the rear portion of the zipper
18:24:59 <ski> i dunno what you mean by "rear"
18:25:20 <fen> the [r a] of Zipper :: [r a] -> f a -> Zipper f a
18:25:24 <ski> ok
18:25:41 <fen> you move forwards, placing things behind you
18:25:49 <ski> what i called "the context" then, i suppose
18:26:20 <fen> its a generalisation over a more basic version of zipper over nonempty, ([a],Nonempty a)
18:26:52 <ski> why thinking about `Nonempty' in particular ?
18:26:58 <fen> anyway. if instead of [r a] we want to use Cofree Nonempty (r a)
18:27:23 <fen> Nonempty because its a one hole context, it always needs a value to point to, a head of the tail
18:27:57 <fen> the terminology "context" would make more sense as the thing at the head of the tail
18:28:23 <fen> the tail being the f a of; Zipper :: [r a] -> f a -> Zipper f a
18:29:18 <fen> so, with Cofree Nonempty as the cotail, we need actually that each different path has a tail at the end...
18:29:24 <fen> so we need cofree''
18:29:43 <ski> `[r a]' can contain zero `r a's. `CoFree NonEmpty (r a)' must contain at least one `r a'
18:29:59 <ski> (i don't see why you want a tree of them, instead of a list)
18:29:59 <fen> Cofree'' f a b = Fix ((Either b . (,) a) f)
18:30:17 <fen> well because we have a "Pointer" over a tree
18:30:24 <fen> and there are many paths
18:30:39 <ski> do you want to point to more than one thing at a time ?
18:30:52 <fen> so we can consider a collection of pointers to different leaves, but they would share a common part of the cotail
18:31:26 <ski> seems the answer is "yes"
18:32:53 <fen> so to reduce storage, instead of having [Zipper (Free (Zipper Nonempty)) a], where the "vertical" zippers [] cotail will have many duplicate values between each of these pointers, that is, the paths to each leaf have a common part
18:33:11 <fen> we can use cofree to share these common cotails
18:34:32 <ski> i still don't get `Zipper (Free (Zipper Nonempty)) a'
18:35:14 <fen> one vertical zipper over the Free, where r a = Free f a, and one Zipper over Nonempty where r a = Identity
18:35:39 <fen> (horizontal zipper over the branches)
18:35:47 <ski> i dunno what "vertical" is meant to signify
18:36:05 <fen> that it goes "up and down" over the free container, which has "depth"
18:36:47 <fen> while the horizontal zipper goes left and right between the branches
18:37:34 <fen> its a pointer over the tree, it has vertical pointer and horizontal pointers at each layer
18:37:56 <fen> vertical & horizontal zippers rather
18:38:48 <fen> so, if you consider the path from the top of the tree to 2 nodes which share some common path, like, they can get to depth n along the same path
18:39:21 <fen> then it would be wasteful to store pointers to both positions, as they would share some common part of the cotail
18:39:41 <fen> the vertical navigation is the same for some number of downward navigations
18:40:36 <ski> hm, in `Free (Zipper Nonempty) a', you have a tree with positive (finite) branching, `a' at leaves, and each node has a "currently focused/selected subnode"
18:41:30 <fen> yeah, like a grid, where you have a row and column number. thats a depth 2 free nonempty zipper
18:41:44 <ski> (so, you not only have a "current path, to a particular leaf" from the root, you have one such path, for each node .. hmm)
18:42:18 * ski is still not sure why it should be `NonEmpty' rather than say `[]'
18:42:48 <fen> the Cofree'' tailed zipper under construction could be considered to be a subsection of the tree, consisting of covering the tree incompletely by paths
18:43:14 <ski> in the grid example, it's not like you have a current row and a current column, giving a current location/cell
18:43:18 <fen> the tails at the end of each partial path consist of the rest of the unnavigated tree below 
18:43:38 <ski> it's like you have a current row, and then *each* row has a current position
18:44:02 <fen> ski: no, there are 2 cases, the grid case requires all adjacent zippers to be updated simulatiously
18:44:12 <ski> more like if you have multiple buffers open in an editor, and you have a current buffer, but not onlt that, but every buffer, has a current position
18:44:21 <ski> oic
18:44:26 <fen> the fact is that most of the zippers in a tree navigation are fully rewound
18:44:36 <ski> so this is just a first approximation to the grid you want
18:45:16 <fen> the grid was just to demonstrait how sometimes many zippers would be partially navigated
18:45:31 <fen> whereas for a tree, only along the current path would they be
18:46:01 <fen> if you did that to a grid it would slide the rows past each other and ruin local neighbourhoods
18:46:29 <ski> "the vertical navigation is the same for some number of downward navigations", ok
18:46:36 <fen> so never mind about grids for now, not sure how they fit into the idea of cofree cotails
18:46:59 <ski> ("ruin local neighbourhoods" ?)
18:47:33 <fen> you must update all rows simultaniously, to have a kind of collum number
18:47:53 <ski> or implement some kind of sharing behaviour
18:48:31 <ski> what you said about sharing prefices of paths makes sense .. but i'm not sure how it fits into the narrative
18:48:42 <fen> navigating along only one row would truncate it from the front, so the values surrounding each of the row of the adjacent rows, would change
18:49:04 <ski> hm, btw ..
18:50:17 <ski> .. perhaps we should move to another channel, since this is getting length, and probably only tangentially interesting (if at all) to most people of the channel. e.g. #haskell-overflow
18:51:14 <fen> the shared prefices are the in cofree'' nonempty. you could go from each leaf, which contains various different tails, corresponding to trees below the end of each path, and rewind each zipper, consuming for each leaf, the path above it. and recover a list of trees from the cofree'' zipper
18:51:46 <ski> if you type
18:51:48 <ski> /join #haskell-overflow
18:51:53 <fen> ski: the description is exhauted
18:51:58 <ski> you should get into that channel
18:52:15 <fen> thanks for the questions, they helped it be so
18:52:26 <fen> shall return with an implementation
18:52:31 <fen> ciao!
18:52:36 <ski> oh, ok
20:58:13 <hs_newb> hello, is it good to use rio for a new project?
20:59:21 <hs_newb> also is there an alternative to merlin for haskell?
20:59:56 <pacak> hs_newb: merlin - like ocaml's merlin?
21:00:04 <hs_newb> pacak: yes
21:00:29 <pacak> there's haskell-ide-engine, you can get it working in vim with coc
21:00:44 <pacak> there's hdevtools but it's not very alive.
21:00:58 <hs_newb> pacak: okay i will look into it thanks
21:01:15 <hs_newb> do you have any details about rio for newbie?
21:01:44 <glguy> hs_newb: It's not common to use rio, but if you want to experiment it could be interesting
21:02:42 <hs_newb> i heard it's an efficient and safe replacement for stdlib
21:02:54 <hs_newb> ocaml also has a similar problem with its stdlib
21:03:09 <pacak> Well, the best way to prevent me from contributing to a haskell opensource project would be using non-standard stdlib.
21:03:38 <hs_newb> pacak: why so? people use alternative stdlib in ocaml all the time?
21:04:16 <pacak> stdlib in haskell is not that bad.
21:04:37 <maerwald> :>
21:04:48 <hs_newb> okay, i just want to get up to speed fast 
21:05:10 <hs_newb> i will use the default one then thanks for the input
21:49:01 <mikeplus64> is this type defined anywhere? newtype FixT f a = FixT (f (Base a (FixT f a)))
21:49:14 <mikeplus64> w/ Base  from recursion-schemes
22:03:16 <ski> `Base' is `Either' ?
22:04:36 <ski> oh, it's a family
22:06:59 <heptahedron> What's a good way to see if I've successfully tied the knot in a data structure?
22:07:59 <mikeplus64> ski Base a :: * -> * gives a non-recursive version of a, paramaterised by the recursive bits, so e.g. (Base [a] x) ≡ Either a x
22:08:09 <mikeplus64> so Fix (Base a) ~ a
22:08:13 <maerwald> heptahedron: without breaking laziness?
22:08:21 <ski> yea, i think i see what you wanted with `FixT'
22:08:48 <mikeplus64> i mean, what i wrote works fine, but i'm wondering if anyone has already made the kitchen sink and all for it :D
22:08:57 <ski> e.g. `FixT f (mu r. 1 + r)' is meant to be `mu r. f (1 + r)', i assume
22:09:01 <heptahedron> maerwald: er, not sure what you mean by breaking laziness--I kind of had to use laziness to get the data structure in the first place, right
22:09:39 <mikeplus64> i don't know what mu r. means
22:09:41 <heptahedron> I can't exactly just print the node structure because it will go on infinitely and I wouldn't be able to tell if the nodes were actually shared or not, is my problem, at least the way I see it
22:09:44 <ski> (i first misread what you wrote as trying `Base (FixT f a)' .. which seemed a bit circular, in this context)
22:09:59 <mikeplus64> ahh, i think FixT = Cofree
22:10:02 <ski> `mu r. ..r..' is `Mu (\r -> (..r..))'
22:10:48 <mikeplus64> err no
22:10:52 <ski> no `Cofree' doesn't decompose one of its arguments into a "base functor"
22:11:41 <mikeplus64> sorry, brainfart. it is 'just' FixT f a = Fix (f `Compose` Base a)... which is probably a bunch of other things
22:11:42 <ski> the idea is that `Base (mu r. f r)' should be `f', afaiui
22:11:53 <ski> .. except that's not uniquely defined
22:12:00 <maerwald> heptahedron: just because you are tying something doesn't mean it's lazy 
22:12:13 <ski> or, if you will, that `Base (Mu f)' ought to be `f'
22:13:26 <ski> e.g. `Natural' is `Mu Maybe' .. but it's also `Mu (Compose Maybe Maybe)'
22:13:33 <heptahedron> maerwald: here I'll just put it in a gist, it's very simple code I'm just unused to dealing with data structures like this
22:13:38 <ski> mikeplus64 : you know `Mu', yes ?
22:13:44 <maerwald> so your concern is that it's a constantly expanding tree instead of an actual graph
22:13:57 <maerwald> I guess you could just monitor memory consumption?
22:14:17 <heptahedron> maerwald: https://gist.github.com/heptahedron/a6c465143895f024f75c864b9cf347b3
22:14:18 <mikeplus64> ski: no
22:15:03 <mikeplus64> Mu is church-encoded Fix?
22:15:05 <ski> mikeplus64 : `Mu f' is the least type `r' satisfying `r = f r'
22:15:10 <heptahedron> For what I'm trying to do, I don't even think tying the knot will be necessary, but I figured I'd try to in order to test my understanding of it since this is just a hobby throwaway thing
22:15:52 <mikeplus64> how is Mu f different from f Void?
22:16:15 <ski> `Mu Maybe' is `Natural', but `Maybe Void' is `()'
22:17:35 <ski> `Mu' is `Fix', but with the intension that we're after the *least* fixed point. so `Mu (Compose Maybe ((,) a))' is to be thought of as the *finite* lists with elements of type `a'
22:18:00 <heptahedron> Oh that's embarrassing
22:18:04 <ski> in Haskell, there is, strictly speaking, no difference. we can still have this difference in mind, though
22:18:13 <ski> @type unfoldr
22:18:15 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
22:18:20 <heptahedron> I forgot to make the nodes actually form a circular reference lol
22:18:38 <ski> `[a]' here really means "possibly finite streams", not "(definitely finite) lists"
22:19:44 <ski> mikeplus64 : in case we don't care about this, we can treat `Fix',`Mu',`Nu' all as the same thing
22:20:10 <mikeplus64> i think i understand
22:20:31 <ski> (`Nu' is the greatest fixed point. `Stream a' is `Nu ((,) a)')
22:21:12 <ski> and the notation `mu r. ..r..' resp. `nu s. ..s..' are just handy pointful versions of `Mu (\r -> ..r..)' and `Nu (\s -> ..s..)'
22:22:05 <ski> anyway, the Church-encoding of `mu r. ..r..' is `forall r. (..r.. -> r) -> r', as you indicated
22:22:23 <ski> while the State-encoding of `nu s. ..s..' is `exists s. s * (s -> ..s..)'
22:23:23 <ski> mikeplus64 : anyway, i think that `Base' is intended as a (post-)inverse of `Mu'
22:23:31 <mikeplus64> quite mind-bending
22:23:55 <mikeplus64> i basically use Base to give me Traversable/Foldable/Plated over very large hairy types "for free"
22:24:19 <mikeplus64> as well as annotate nodes in a language with e.g. source locations
22:24:39 <ski>   unfoldr :: forall s. (s -> Maybe (a,s)) -> s -> FinStream a
22:24:49 <ski>   unfoldr :: forall s. (s -> 1 + (a * s)) -> s -> FinStream a
22:24:49 <mikeplus64> and keep the "core" language as simple as possible, and compilation steps basically stripping away the 'f' in FixT f a
22:24:55 <ski>   unfoldr :: forall s. s * (s -> 1 + (a * s)) -> FinStream a
22:25:05 <ski>   unfoldr :: (exists s. s * (s -> 1 + (a * s))) -> FinStream a
22:25:42 <ski> this is one direction of the isomorphism `FinStream a  =  nu s. 1 + a * s  =  exists s. s * (s -> 1 + a * s)'
22:26:00 <ski> (`Fin' here meant "potentially finite")
22:26:23 * ski nods to mikeplus64
22:26:48 <ski> mikeplus64 : anyway, did you get my point with "base functor" not being uniquely specified ?
22:27:17 <mikeplus64> i don't know what 'uniquely specified' means :)
22:27:39 <ski> (the Church-encoding for `Mu' is btw just the fold/`cata'. while the one for `Nu' is the unfold/`ana')
22:28:49 <ski> what i mean is that we could attempt to specify that `Base a' should be *the* `f' (if any) such that `a' is `Mu f'
22:28:58 <ski>        Base a = f
22:29:04 <ski>   <=> a = Mu f
22:29:55 <mikeplus64> ah, ok ... i think so
22:30:20 <ski> however, both `Mu Maybe' and `Mu (Compose Maybe Maybe)' are `Natural'. so which of those two (distinct) functors should `Base Natural' be ?
22:30:35 <ski> (any composition of a positive number of `Maybe's work)
22:31:00 <mikeplus64> neat, recursion-schemes does actually provide these instances
22:31:09 <mikeplus64> that Base (Mu f) = f
22:31:12 <ski> iow, we're attempting to "wound up" the type `Natural' into "cycles" going around
22:31:40 <ski> but we don't have to keep a single cycle as `Maybe', it could just as well be `Maybe . Maybe', or `Maybe . Maybe . Maybe', &c.
22:32:15 <ski> another attempt would be to say that `Base a' should be the *least* `f' (in some sense) such that `Mu f' is `a'
22:32:29 <ski> but .. i'm not sure how to actually make the "least" part here precise
22:33:03 <ski> (perhaps kmett knows how one can do it. i haven't read that package in detail)
22:33:55 <ski> so, at least from my current POV, `Base a' means "give me *some* `f' such that `Mu f' is `a'", where one expects that the one that is given is "reasonable" in some vague sense
22:36:19 <ski> "so e.g. (Base [a] x) ≡ Either a x" -- itym `Maybe (a,x)'
22:36:25 <ski> going back to your `FixT'
22:36:59 <mikeplus64> yes. concretely Base a x replaces recursive use of a in a with x. (forall x. Base a x) / (Base a Void) is only the terminal parts of 'a'
22:37:40 <ski> `/' ?
22:37:49 <ski> oh
22:38:04 <mikeplus64> i just mean or haha
22:38:13 * ski was wondering what kind of division that was
22:38:48 <ski> iiuc, you want `FixT f (Mu g)' to be `Mu (f . g)'
22:39:13 <ski> (at least when `g' is the reasonably choice for `Mu g')
22:39:41 <ski> so `FixT f Natural' is meant to be `Mu (f . Maybe)' (and not, say, `Mu (f . Maybe . Maybe)')
22:39:44 <ski> correct ?
22:40:25 <ski> @where IndirectComposite
22:40:25 <lambdabot> <http://web.archive.org/web/20051126141834/http://haskell.org/hawiki/IndirectComposite>
22:40:30 <mikeplus64> yes ... i think
22:41:02 <mikeplus64> that is very similar to what i am doing
22:41:15 <ski> it's from the old hawiki
22:41:37 * ski misses it
22:42:26 <ski> hmm ..
22:42:48 <ski> sometimes i wonder whether one could use a comonad at the type level, for this kind of thing
22:43:44 <ski> we want to have a type `mu r. f r', but "keep it open for later extension"
22:44:16 <ski> this is actually very similar to what people do in OO, with class types, which can be instantiated to object types
22:44:26 <ski> (see e.g. O'Camls OO system)
22:44:42 <ski> essentially, we want to have "open recursion"
22:48:21 <ski> (if you specify a class type/interface, where you have some methods specified to take an input of type `Self'/`This'; then if you instantiate this to get an object type, and (presumably) an object of this type, then `Self' refers to that particular type. but if you instead extent the class type, e.g. with more methods, and then instantiate, then `Self' will instead refer to this new type)
22:48:57 <ski> (note that by extending a class type like this, you don't necessarily get a subtype, in this case because of the "binary methods")
22:50:15 <ski> (if we also talk about actual class implementations, then we'd also like a method in the parent class that called another method to be able to call that method in the subclass, in case it was overridded. so here's also value-level open recursion)
22:51:16 <ski> now, in your case, the recursive places in the nodes in your AST data structure plays the role of the `Self'/`This' type in the OO scenario
22:52:02 <ski> one could imagine adding another branch (data constructor). you had a more general thing of adding an arbitrary `f' layer around, though
22:52:14 <ski> it still seems like a quite similar notion
22:54:38 <mikeplus64> yep. previously i did use, e.g., for renaming, `data AST a = Var !Id | FreeVar a  | ...many more Free... branches go here... | SrcLocated SrcLoc (AST a) | ...`
22:54:57 <ski> hmm .. pondering what would be the analogy in the open recursion, on the value level
22:55:00 <mikeplus64> but those other branches are simply not relevant at all when actually interpretting
22:55:21 <mikeplus64> so just added code bloat
22:55:36 <ski> yes, and perhaps you'd like every ordinary node to wrapped in a `SrcLocated'
22:56:53 <ski> (if your `f' is a `Comonad', or at least `Copointer', then you could relatively easily skip the extra level, when you're not interested in it. `Functor' would allow you to preserve it)
22:57:24 <ski> (er, `Copointed')
22:57:38 <mikeplus64> exactly, you can guarantee every single node is wrapped in SrcLocated by quite trivially wrapping your ordinary parsers in a boilerplate f :: Parser x -> Parser (Ann x)
22:57:57 <mikeplus64> where Ann has the base functor equivalent of the 'annotation' branches of the original type
22:58:19 <mikeplus64> like data Ann a = SrcLoc SrcLoc a | Pure a | Name !Name
22:58:20 <ski> another version is wrapping every (expression) node with the (inferred) type of that node
22:59:11 <ski> hm, what would `x' be there ?
22:59:28 <ski> oh, ok
22:59:30 <mikeplus64> anything :-)
23:00:17 <ski> (i was wondering whether that parser operation would be expected to instrument (by some kind of open recursion ?) every layer of an existing tree parser, or just a single layer)
23:00:23 <mikeplus64> where you use 'f' dictates which nodes actually get a SrcLoc. (the Pure branch there defeating Fix)
23:00:24 <ski> (but now i see it's a single layer)
23:00:38 * hackage memorable-bits 0.1.0.1 - Generate human memorable strings from binary data.  https://hackage.haskell.org/package/memorable-bits-0.1.0.1 (lukec)
23:01:17 <mikeplus64> because i am using a Pure branch like that i think my FixT ought to really be FreeT
23:01:25 <mikeplus64> or just Free
23:01:25 * ski recalls reading someone playing around with OO class representations in Haskell
23:01:27 <mikeplus64> i guess
23:01:30 <ski> .. possibly Oleg
23:02:00 <koz_> Quite possibly.
23:03:11 <ski> yea, why do you want a `Pure' there ?
23:03:42 <mikeplus64> because not every single node in practise needs a location, and it is inconvenient actually wrapping every single parser with it
23:04:02 <ski> ok .. and `Name' ?
23:04:25 <mikeplus64> for renaming
23:04:34 <ski> i don't understand
23:05:43 <mikeplus64> like during renaming e. Plus x (Name a) → Plus x (VarId i) where i is a proper debrujin index
23:05:46 <mikeplus64> e.g.*
23:06:25 <mikeplus64> Fix (PlusF x (Ann (Name a)) → Plus x (Id i)
23:06:27 <mikeplus64> or something
23:06:36 <ski> ok, handling bound variables in some fashion
23:07:07 <ski> i would possibly abstract over `Name'
23:07:26 <ski> (as in `data Ann n a = ... | Name !n')
23:08:07 <ski> (because then one can make this into a monad, in `n'. but perhaps you don't care about that)
23:09:23 <mikeplus64> i did previously because it gave an easy way to use [bi]traverse to ensure an expression uses no variables
23:09:36 <ski> ok
23:09:55 <ski> (yea, one could use `Void' there)
23:10:43 <mikeplus64> i now have quite a few different namespaces entirely for ids [it is quite a complex language :'(] so that would require many type variables and much spooky boilerplate
23:11:22 <ski> hm, yea :/
23:11:38 <ski> there ought to be nice records on the type level
23:11:50 <ski> do you have mutually recursive ASTs ?
23:12:07 <mikeplus64> and enshrining bound variables to proper branches in the AST is at least one less pointer indirection
23:12:09 <mikeplus64> yes
23:12:49 <ski> i recall i showed Peaker a trick for how to simulate a record of types, in some sense
23:13:49 <ski> if one assumes
23:14:20 <ski>   data Expr = Let [Decl] Expr | ...
23:14:38 <ski>  data Decl = Val Id Expr | ...
23:14:44 <ski> then one could instead do
23:14:53 <ski>   data Tag = E | D
23:15:04 <ski>   data Expr :: Tag -> *
23:15:07 <ski>     where
23:15:32 <ski>     Let :: [AST D] -> AST E -> AST E
23:15:36 <ski>     ...
23:15:49 <ski>     Val :: Id -> AST E -> AST D
23:15:51 <ski>     ...
23:15:54 <dyl> Did you mean data AST :: Tag -> *?
23:16:00 <ski> (sorry, that should be `data AST ...', yes)
23:16:22 <ski> so, this is merging all the mutually recursive ASTs into a single type
23:16:54 <ski> `Tag' here is `2', so `Tag -> *' is `*^2' is `(*,*)', a pair of types, indexed by `Tag'
23:17:23 <ski> so, this is a way to simulate a record of types (all of the same kind), which can occasionally be useful
23:19:21 <dyl> One question about such a construction: what would you do if you wanted a function that allows either a Tag D or Tag E? 
23:19:36 <dyl> (And you want to be able to case the implementation by type.) 
23:19:39 <dyl> Typeclass?
23:19:58 <ski> you could have `Let :: [AST D] -> AST tag -> AST tag' if that's what you mean
23:20:19 <ski> iow, allowing `Let's in all syntactic classes categorized by `AST'
23:20:29 <ski> (all of them would have the same kind of declarations, in this case)
23:20:36 <ski> and similarly with `If' and `Case'
23:21:13 <ski> hm, "case the implementation by type"
23:21:22 <ski> well, you could use a singleton
23:21:33 <ski>   data TagIs :: Tag -> *
23:21:35 <ski>     where
23:21:38 <dyl> One theme I run into a lot with such constructions is wanting to, in some manner, case on a type. 
23:21:46 <ski>     IsE :: TagIs E
23:21:51 <ski>     IsD :: TagIs D
23:21:54 <dyl> With minimal ugliness, namespace pollution, and overhead.
23:22:09 <ski> and then your function can have type `TagIs tag -> AST tag -> ..tag..'
23:23:10 <ski> i suppose you could just directly look at the top constructor of the input of `AST tag' (unless you have polymorphic constructors like `Let', or even worse, existentials)
23:23:37 <ski> type class could also be one potential solution, i suppose
23:24:13 <ski> but a singleton is the general (though perhaps a bit unrefined and crude) way to do it, i suppose
23:24:51 <dyl> What’s the decided on eventual replacement for singletons? 
23:24:59 <dyl> Some new pi quantifier I thought? 
23:25:18 <ski> you mean in Dependent Haskell ? i dunno
23:25:30 <ski> something like that, possibly
23:26:05 <ski> well, i suppose you may want to put singletons also in data structures, not just have them as arguments
23:26:27 <ski> (in that case, presumably a corresponding existential ?)
23:31:59 <MarcelineVQ> a pi quantifier is proposed, as well as an additional forall, because we don't have enough places to use that word already :>
23:33:07 <yushyin> isn't the new name foreach not pi?
23:33:31 <MarcelineVQ> could be, or that could be the name for the new forall form, not sure, it's pi on the proposal page
23:37:19 <yushyin> 'proposed to be spelled foreach, not pi' -- https://github.com/goldfirere/ghc-proposals/blob/pi/proposals/0000-pi.rst#quantifiers-for-dependent-haskell
23:37:24 <yushyin> I thought they changed that
