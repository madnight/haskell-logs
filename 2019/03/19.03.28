00:00:07 <ski> now, you need to produce a `CM ()' to plug in that holw
00:00:13 <ski> s/holw/hole/
00:00:20 <ski> where could you possible get one from ?
00:00:24 <koz_> The only way I see is by calling g somehow.
00:00:46 <koz_> Or calling the callback I guess.
00:01:02 <ski> yes, there's a fork in the road
00:01:07 <ski> .. but ?
00:01:16 <koz_> I get the feeling I need to call g somehow.
00:01:24 <ski> yes, and .. ?
00:01:39 <koz_> I can't call it - I don't have the right sort of callback to give it.
00:01:49 <ski> if you were to call `callback' here, could you produce its arguments ?
00:02:06 <ski> (you'd first write them as two new holes, then try to plug those)
00:02:27 <koz_> It wants an Int and a b
00:02:35 <koz_> I have a way of cooking up a b, given an a.
00:02:39 <ski> yes
00:02:55 <ski> and do you have access to, or can cook up, an `a' ?
00:03:22 <koz_> Not directly, as far as I can see.
00:03:35 <ski> yes, it appears we're at an impasse
00:03:45 <koz_> So clearly calling callback isn't the way to go.
00:03:54 <ski> so, perhaps backtrack back to the fork in the road, and try exploring the other branch of the tree a bit ?
00:04:02 <koz_> OK, so try to call g.
00:04:18 <ski> what is then the type of the new hole ?
00:04:21 <koz_> So g demands an Int -> a -> CM ()
00:04:38 <ski> how to plug that hole ?
00:04:43 <koz_> Wait, I can cook a new function for that.
00:04:56 <ski> yes, just as when you started, just inside `Push'
00:04:57 <koz_> I basically grab the Int and the a, cook the a into a b... and then something?
00:05:03 <ski> it wants a function type, you can write a function
00:05:13 <ski> try it and see ?
00:05:33 <koz_> Got it.
00:06:02 <mniip> speaking of
00:06:10 <koz_> fmap f (Push g) = Push (\callback -> g (\i x -> callback i (f x)))
00:06:18 <mniip> has anyone considered topologies as algebras of the double powerset profunctor
00:06:27 <ski> koz_ : and you're done :)
00:06:35 <koz_> My mind rebels at what this is doing.
00:07:00 <ski> mniip : "algebras" in which sense. also "powerset profunctor" ?
00:07:20 <mniip> koz_, fmap f (Push g) = Push (dimap (dimap (dimap id f) id) id g)
00:07:24 <ski> koz_ : with a little bit of practice, you'll be doing this in your head before breakfast :)
00:07:40 <koz_> mniip: ... ??!
00:08:01 <koz_> I'm trying to get a grasp in my head of what exactly this instance is doing.
00:08:07 <mniip> ski, well presumably you are familiar with F-algebras?
00:08:14 <ski> yes
00:08:56 <koz_> What amazes me is that Haskell can actually derive that instance.
00:09:05 <koz_> (I checked, though I have no idea precisely what Haskell derives in this case)
00:09:21 <koz_> GHC is officially better at functors than I am. :P
00:09:28 <ski> mniip : `dimap (dimap id (dimap f id)) id g' ?
00:09:47 <mniip> idk I haven't checked it but it seems correct
00:10:37 <mniip> yup, it is correct
00:10:43 <mniip> anyway back to algebras
00:11:09 <mniip> the commutative square  h . f1 = f2 . Fh
00:11:21 <mniip> can be also considered as a wedge on Hom(F-, -)
00:11:52 <koz_> ski and mniip: Thank you for blowing my mind. I'll probably be pondering this one for a few days. :P
00:11:54 <mniip> in the sense that Hom(Fh, -) . i1 = Hom(F-, h) . i2
00:12:11 <mniip> where i1 : * |--> f1
00:12:13 <koz_> Am I right in feeling that this is somehow related to Cont?
00:12:23 <ski> koz_ : it just attaches a "postprocessing step" `a -> b' on the `a's that the input pusher would pass to its callback, producing the `b's that the output pusher will pass to *its* callback. in other words, the `b'-accepting callback that the output pusher receives will get a "preprocessing step" `a -> b' attached, making it into an `a'-accepting callback, which is the callback that is passed to the input pusher
00:12:34 <mniip> koz_, kind of, you're getting a covariant functor from a composition of two contravariant ones
00:12:57 <koz_> ... wait, does this bring us back around to what dminuoso was just talking about in response to my first question(s)?
00:13:36 <ski> mniip : so you're considering an NT from `F' to `Id' ?
00:13:55 * ski recalls (re)reading about dinatural transformations, recently
00:14:24 <ski> koz_ : yes, `Push' is more or less a CPS thingy
00:14:41 <mniip> I guess
00:15:06 <mniip> the thing is this generalizes to general profunctors not of the form Hom(F-, =)
00:15:09 <koz_> So, in a sense, you 'cook up' a function which can, given any index, 'write in' the appropriate element, then when you execute that function, it does that for you?
00:15:41 <mniip> e.g if you consider the profunctor (X, Y) |--> PPX
00:15:49 <mniip> (PPX has the type of a topology on X)
00:16:03 <ski> @unmtl WriterT Int (ContT () (State Integer)) a
00:16:03 <lambdabot> (a -> Int -> Integer -> ((), Integer)) -> Integer -> ((), Integer)
00:16:04 <ski> @unmtl WriterT Int (ContT () (State_ Integer)) a
00:16:04 <lambdabot> (a -> Int -> State_ Integer ()) -> State_ Integer ()
00:16:39 <koz_> ...
00:16:42 <koz_> Woo, I'm speechless.
00:17:01 <mniip> koz_, the reason I brought up dimap is because any functor/contravariant instance can be generated procedurally
00:17:02 <ski> koz_ : a value of type `Push a' is something that produces `a's, not something that consumes them
00:17:42 <ski> mniip : and `Y' being ?
00:17:46 <koz_> mniip: What does the algorithm look like?
00:18:02 <ski> mniip : `P' being the covariant, or the contravariant, powerset functor ?
00:19:51 * ski always wonders what's the difference between a profunctor and a difunctor ..
00:23:43 * ski just notices the NT from `F' to `Id' might be related to the `F'-algebra here
00:23:49 <ski> (sorry, a bit tired)
00:23:56 <ski> what's `i1' and `i2' there ?
00:26:24 <ski> hm, a wedge would be a dinatural transformation, either from that difunctor, to a constant one, or in the other direction (i can never recall which)
00:26:38 <ski> in this case, i suspect it would be to a constant one
00:28:16 <ski>   delta_A : Hom(F A,A) >---> exists X. Hom(F X,X)
00:28:17 <ski> presumably
00:31:34 <ski> and then the hexagon law would amount to `delta_A . Hom(F h,A) = delta_B . Hom(F B,h)' each side being a morphism from `Hom(F B,A)' to said `exists X. Hom(F X,X)') ?
00:32:15 <ski> hmm
00:35:56 <ski> i suppose the shape of "Hom(Fh, -) . i1 = Hom(F-, h) . i2" suggests that you're thinking of a dinatural transformation to `Hom(F -,=)', not from it
00:36:40 <ski>   iota_A : * >---> Hom(F A,A)
00:36:42 <ski> perhaps
00:37:54 <mniip> uh sorry
00:38:00 <mniip> P is contravariant
00:38:09 <mniip> Y is ignored
00:38:33 <ski> getting `Hom(F A,h) . iota_A = Hom(F h,B) . iota_B', where `iota_A' is your `i2' and `iota_B' is your `i1' ??
00:38:40 <mniip> it's just that instead of considering morphisms in Hom(FA, A), you can consider points in P(A, A)
00:39:05 <ski> (hm, perhaps i got those crossed)
00:39:29 <mniip> and morphisms from a1 to a2 would be functions A -> B such that P(f, B)(a1) = P(A, f)(a2)
00:39:44 <mniip> no wait that's backwards
00:39:47 <mniip> from a2 to a1
00:39:54 <mniip> a2:P(A, A)  a1:P(B, B)
00:40:55 <ski> this `P' being ?
00:41:04 <ski>   P(X,Y) = P (P X)
00:41:05 <ski> ?
00:49:53 <dminuoso> ski: difunctor is, AFAIK, just an informal synonym for profunctor.
00:50:50 * ski vaguely recalls reading "difunctor" in some paper (Wadler ?)
00:51:05 <ski> i only heard people mention "profunctor", many years later
00:51:23 <dminuoso> ski: https://hackage.haskell.org/package/compdata-0.7/docs/Data-Comp-Param-Difunctor.html suggests that it was perhaps Meijer, Hutton, FPCA '95
00:51:37 * hackage asif 5.0.2 - Library for creating and querying segmented feeds  https://hackage.haskell.org/package/asif-5.0.2 (arbornetworks)
00:52:09 <MarcelineVQ> daniel pepperoni
00:52:13 <dminuoso> Which I presume to refer to "Bananas in space: extending fold and unfold to exponential types"
00:52:15 <ski> (i also vaguely recall people talking about the codomain of a profunctor always being `Set' (or whatever category you're enriching over). not sure whether that's a hard requirement, or whether that's only what one typically has)
00:52:26 <dminuoso> ski: Its a hard requirement.
00:52:30 <dminuoso> ski: But it can be generalized.
00:52:31 <ski> which ?
00:52:37 <dminuoso> ski: That the codomain is Set.
00:52:51 <ski> ok. i never recall reading any such for difunctor
00:53:17 <ski> in fact, i think i recall reading that a category having exponentials would be an example of a difunctor
00:53:28 <dminuoso> ski: Take an enriched category V equipped with a tensor *.*, then you get V-profunctors from D^op *.* C -> V.
00:53:47 <ski> ok. so it seems difunctor is a more general concept, in that case ?
00:53:52 <dminuoso> ski: So the plain profunctor is an enriched profunctor where D and C are enriched over Set, where the cartesian product is the tensor.
00:54:37 <dminuoso> (You can think of regular categories as Set-enriched)
00:54:40 * ski nods
00:56:03 <ski> so is there a reason why the type class name in Haskell is `Profunctor' rather than `Difunctor' ?
00:56:07 <dminuoso> ski: I dont know about "difunctor being the general term", Id say that enriched profunctors is the generalizsation.
00:56:21 <dminuoso> ski: Perhaps because the term in category theory is profunctor *shrugs*
00:57:07 <ski> e.g. is the monoidal structure (of the codomain) relevant ?
00:57:23 <dminuoso> ski: Yes.
00:57:54 <dminuoso> This is quickly escaping my understanding now though.
00:58:24 <ski> it seems to me that any old functor `F : C^op * D >---> E' is more general than the (non-enriched case) `F : C^op * D >---> Set', at least
00:58:25 <dminuoso> ski: Its at least presumed that V be some symmetric closed monoidal category afaik.
00:58:45 <dminuoso> Or `E` as it is in your example.
00:59:29 <ski> no, in my case `E' was just any old category. not something that one would need to enrich over
01:01:16 <ski> (e.g. all of `C',`D',`E' could be the category of directed graphs, which is cartesian closed)
01:01:29 <dminuoso> ski: Is it possible that the monoidal structure is relevant so you can recover a Bicategory?
01:01:48 <ski> remind me what a bicategory is ?
01:02:28 <dminuoso> ski: Well consider your construction F : C^op * D >---> E
01:02:34 <dminuoso> ski: How would you compose two such functors?
01:03:15 <ski> if `G : E >---> E2', then `G . F : C^op * D >---> E2', just ordinary functor composition
01:03:52 <ski> not doing the relational composition thing
01:04:08 <ski> (compare with bifunctors)
01:04:20 <dminuoso> ski: No I mean let's call your functor construction `F : C^op * D >---> E' f-functor, how would you compose two f-functors?
01:04:33 <ski> answer : no
01:04:36 <ski> i wouldn't
01:04:58 <ski> that's something you do with profunctors, afaiui, yes ?
01:05:13 <ski> (basically a kind of relational composition, iiuc)
01:05:14 <dminuoso> ski: You can compose enriched profunctors, yes.
01:05:25 <dminuoso> ski: For the Set-enriched profunctor its kind of relational composition, yes.
01:06:03 <dminuoso> Consider https://ncatlab.org/nlab/show/Prof as an example of a category you can obtain from profunctors
01:06:13 <ski> isn't it a coend over a tensor of the two things ?
01:06:56 <ski> right
01:07:16 <dminuoso> ski: So I was just wondering whether the monoidal restriction is picked so you can talk about categories in these things.
01:07:48 <ski> so, i'm wondering about the relevancy of this, to the Haskell applications using `Profunctor' (iiuc, in lens ? i haven't really tried to grok those)
01:09:03 <dminuoso> `type Optic s t a b = forall p . (C0 p, ..., CN p) => p a b -> p s t`, so an optic is a profunctor transformer of some kind.
01:10:11 <dminuoso> ski: `lens` itself does not use profunctor optics though
01:10:22 <ski> is one of those constraints `Profunctor' ?
01:10:37 * hackage salak 0.2.4 - Configuration Loader  https://hackage.haskell.org/package/salak-0.2.4 (leptonyu)
01:10:54 <ski> (say common extensions, in that case)
01:11:01 <dminuoso> ski: It can be, or perhaps a bit more constrained.
01:12:15 <dminuoso> ski: The way that the profunctor is constrained then defines the kind of optic (whether its say a prism or a lens)
01:12:54 <ski> and, afayk, this relies on or uses the monoidal structure (such as the relational composition) (ior the enrichedness ?), somehow ?
01:15:50 <ski> (hm, still seems to me difunctor is the more general concept, if you allow talking about enriched difunctors, which would be natural, if we're talking about enrichedness)
01:15:51 <dminuoso> ski: Well profunctors in Haskell as rather blant since they are just `Hask^op x Hask -> Hask. I think the way they are used are rather to generalize functions than functors.
01:15:57 <dminuoso> But I dont know the full details here.
01:16:37 * hackage salak 0.1.9 - Configuration Loader  https://hackage.haskell.org/package/salak-0.1.9 (leptonyu)
01:16:44 <ski> yea, i'm just trying to determine whether there's a particular reason why these applications don't use (the name, say) `Difunctor', rather than `Profunctor'
01:17:32 <dminuoso> ski: https://hackage.haskell.org/package/profunctors-5.2/docs/Data-Profunctor-Composition.html
01:17:56 <dminuoso> So it seems that profunctor composition is a thing even in Haskell.
01:18:24 <ski> (cf. with how we can talk about a functor from `Hask -> Hask' to `Hask', in Haskell, although it won't be captured by the `Functor' type class. similarly, one could probably talk about other profunctors than ones captured by `Profunctor'. the question is whether the applications would suggest that we want to talk about profunctors, or merely difunctors)
01:19:46 <ski> dminuoso : anyway, ty for shedding some light on the difference
01:21:12 <dminuoso> ski: type PrismP s t a b = ∀p . Cocartesian p ⇒ Optic p s t a b
01:21:32 <dminuoso> type LensP s t a b = ∀p . Cartesian p ⇒ Optic p s t a b
01:21:35 <dminuoso> Etc...
01:21:58 <dminuoso> I dont fully grasp it, but looks very exciting. :)
01:23:51 <ski> hmm .. `Cocartesian'
01:25:20 <dminuoso> ski: Edward calls them `Strong` and `Choice` respectively. Ive chosen to pick the names that mpickering used in his profunctor lens paper/thesis.
01:29:36 <ski> just wondering whether it's meant to signify a cocartesian closed category, or ..
01:35:00 <dminuoso> ski: According to the paper the name was suggested by Paul Levy to imply "cartesianly strong" and "co-cartesianly strong"
01:35:18 <dminuoso> (Where strong is meant in the tensorial strength sense)
01:36:53 <_ceb> What does it take to work with SPJ in Cambridge at microsoft?
01:37:23 <_ceb> As an intern
01:37:38 <Athas> They make calls semi-frequently, don't they?
01:37:52 <dminuoso> ski: I guess the justification is that the name `Strong` is poorly chosen in the same sense that `Functor` is poorly chosen.
01:38:31 <JoeCordingley> Hi, I was wondering, can you capture type parameters of functions as concrete types once you are inside the function?
01:39:42 <dminuoso> That is, if you had some `class Functor f => Strong t f where beta :: t v (f w) -> f (t v w)` perhaps this would be fine.
01:40:31 <dminuoso> No idea how you would encode that with a Profunctor though.
01:41:08 <dminuoso> % class Functor f => Strong t f where beta :: t v (f w) -> f (t v w)
01:41:08 <yahb> dminuoso: 
01:41:48 <dminuoso> % instance Functor f => Strong (,) f where beta (v, fw) = fmap ((,) v) fw
01:41:48 <yahb> dminuoso: 
01:42:36 <ski> JoeCordingley : `ScopedTypeVariables'
01:43:15 <JoeCordingley> Thanks I'll look into that.
01:43:22 <ski> JoeCordingley : but you can't check, at run-time, whether such a type is, e.g., `Integer' (without say a `Typeable' constraint, or some other evidence such as a GADT)
01:44:00 <dminuoso> JoeCordingley: What exactly are you trying to do?
01:44:50 <dminuoso> ski: So I guess the problem is that `Strong` just implies that your functor has (canonical cartesian product) strength, rather than arbitrary strength.
01:45:10 <dminuoso> Or *profunctor as it is.
01:54:25 <ski> dminuoso : ok
01:58:33 <gentauro> anybody has any experience with `XML + Haskell`? I'm looking for something like to generate data types from `xsd` (I just need it to serialize from xml).
02:02:20 <gentauro> http://hackage.haskell.org/package/HaXml <- there you go
02:11:59 <dminuoso> Is there an optic I can compose onto `folded . _Just` so I can `view` through the fold and see the first result?
02:15:39 <dibblego> @type (^?)
02:15:40 <lambdabot> s -> Getting (First a) s a -> Maybe a
02:19:44 <dminuoso> dibblego: Mmm, I was hoping for a way to do this without using preview/firstOf
02:19:57 <dibblego> not sure what you might want exactly
02:20:06 <dibblego> "the first result of?
02:20:10 <dminuoso> % [Nothing, Just 'c'] ^. folded._Just._First
02:20:12 <yahb> dminuoso: ; <interactive>:1:1: error:; GHC internal error: `Ghci71.$trModule' is not in scope during type checking, but it passed the renamer; tcl_env of environment: []
02:20:19 <dminuoso> dibblego: ^- something along these lines
02:21:58 <dminuoso> % :t folding
02:21:58 <yahb> dminuoso: (Foldable f1, Contravariant f2, Applicative f2) => (s -> f1 a) -> (a -> f2 a) -> s -> f2 s
02:23:17 <dminuoso> % [Nothing, Just 'c'] ^. folded._Just.singular _head
02:23:17 <yahb> dminuoso: ; <interactive>:189:1: error:; * No instance for (Cons Char Char () ()) arising from a use of `it'; * In the first argument of `print', namely `it'; In a stmt of an interactive GHCi command: print it
02:23:24 <dminuoso> Gah. :<
02:28:39 <ski> @yhjulwwiefzojcbxybbruweejw
02:28:39 <lambdabot> Just 'J'
02:28:56 <dminuoso> What magic is that?
02:29:28 <dminuoso> Anyway. dibblego is what I want even fundamentally possible?
02:29:58 <dibblego> yeah for sure, I'll look in a bit mate sorry
02:30:45 <dminuoso> % :t (folded._Just)
02:30:45 <yahb> dminuoso: (Indexable Int p, Contravariant f1, Foldable f2, Applicative f1) => p a (f1 a) -> f2 (Maybe a) -> f1 (f2 (Maybe a))
02:33:14 <dminuoso> % :t pre
02:33:14 <yahb> dminuoso: (Conjoined p, Contravariant f, Functor f) => Getting (First a) s a -> p (Maybe a) (f (Maybe a)) -> p s (f s)
02:33:36 <dminuoso> % :t pre (folded . _Just)
02:33:36 <yahb> dminuoso: (Conjoined p, Contravariant f1, Foldable f2, Functor f1) => p (Maybe a) (f1 (Maybe a)) -> p (f2 (Maybe a)) (f1 (f2 (Maybe a)))
02:33:54 <dminuoso> % [Nothing, Just 'c', Just 'd'] ^. pre (folded . _Just)
02:33:54 <yahb> dminuoso: Just 'c'
02:34:19 <dminuoso> Okay this is pretty close, probably enough for me. Though still curious whether an optic is also possible
02:45:36 <absence> @pl \(_, _, a) -> a
02:45:36 <lambdabot> (line 1, column 9):
02:45:36 <lambdabot> unexpected "a"
02:45:36 <lambdabot> ambiguous use of a non associative operator
02:45:48 <absence> is it trying to say there's no function for that?
02:46:13 <Taneb> It might be saying it doesn't understand three-tuples
02:46:21 <Taneb> @pl \(_, (_, a)) -> a
02:46:21 <lambdabot> snd . snd
02:46:41 <Taneb> @pl \(_, (_, a)) -> b
02:46:41 <lambdabot> const b
02:46:48 <Taneb> @pl \(_, (_, a -> a)) -> a
02:46:48 <lambdabot> (line 1, column 12):
02:46:49 <lambdabot> unexpected "-"
02:46:49 <lambdabot> expecting operator, "," or ")"
02:47:06 <Taneb> Don't mind that last one
02:47:22 <ski> @hoogle (a,b,c) -> c
02:47:22 <lambdabot> Data.Tuple.Utils fst3 :: (a, b, c) -> a
02:47:22 <lambdabot> Data.Tuple.HT fst3 :: (a, b, c) -> a
02:47:22 <lambdabot> Text.Regex.TDFA.Common fst3 :: (a, b, c) -> a
02:47:44 <ski> @hoogle thd3
02:47:44 <lambdabot> Data.Tuple.Utils thd3 :: (a, b, c) -> c
02:47:44 <lambdabot> Data.Tuple.HT thd3 :: (a, b, c) -> c
02:47:44 <lambdabot> Text.Regex.TDFA.Common thd3 :: (a, b, c) -> c
02:47:46 <ski> @hoogle trd3
02:47:46 <lambdabot> Data.Label.Base trd3 :: ArrowApply arr => Lens arr ((a, b, c) -> (a, b, o)) (c -> o)
02:47:46 <lambdabot> Yi.Utils trd3 :: (a, b, c) -> c
02:47:46 <lambdabot> Trace.Hpc.Coveralls.Util trd3 :: (a, b, c) -> c
03:03:34 <absence> if i have a set of functions like e -> a -> b -> c -> r (different number of parameters a b c in the middle) and want to turn them into a -> b -> c -> ReaderT e m r, is there some nifty trick to do that (even with TH), or just boilerplate?
03:10:17 <mniip> how would you know where to stop
03:15:53 <ziman> what if (r = f -> g -> h)?
03:28:47 <merijn> You could do it with a typeclass and some type families abuse, but I'm not convinced it's worth it
03:29:04 <merijn> absence: Why do you have a lot of functions like that in the first place?
03:32:52 <absence> merijn: they're a bunch of servant handlers, and i use TH to inject the name of the handler (the e parameter), but i'd like to have it in a reader rather than in a handler
03:34:21 <absence> i guess writing some blah1, blah2, bhal3 etc helpers and calling the right one depending on the number of arguments is the easiest. i agree that type families might be a bit heavy handed :)
03:35:20 <absence> mniip, ziman: yes, that's where a "nifty trick" would enter the picture ;) i guess it's not (easily) possible
03:50:33 <fen> whats the difference between foldl and foldr?
03:50:36 <fen> :t foldl
03:50:38 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
03:50:40 <fen> :t foldr
03:50:41 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
03:50:47 <fen> (other than the type obviously)
03:53:23 <fen> there also seems to be foldl' and foldr' where these are defined interms of foldr and foldl respectively 
03:54:06 <Taneb> > foldl f x [x,y,z]
03:54:08 <lambdabot>  f (f (f x x) y) z
03:54:11 <MarcelineVQ> foldr hands control of the recursion over to the function you passed it, foldl recurses immediately. foldr is also the catamorphism for list, where : becomes (a -> b -> b) and [] becomes b, they also associate differently hence the l and r
03:54:12 <Taneb> > foldl f b [x,y,z]
03:54:13 <lambdabot>  f (f (f b x) y) z
03:54:16 <Taneb> > foldl r b [x,y,z]
03:54:18 <lambdabot>  error:
03:54:18 <lambdabot>      • Couldn't match expected type ‘Expr -> Expr -> Expr’
03:54:18 <lambdabot>                    with actual type ‘Expr’
03:54:23 <Taneb> > foldr f b [x,y,z]
03:54:25 <lambdabot>  f x (f y (f z b))
03:55:10 <Taneb> fen: foldl is sort of "left to right", foldr is sort of "right to left"
03:55:19 <fen> the reason for asking is because with "fold/unfold" fusion you can basically get the state that was used to unfold a list. alternatively there is the option of using "get" to turn the list into a state, which can be unfolded, where the difference is that the original state produces the rightmost value first, while the get/list/state unfold produces the leftmost value first 
03:55:22 <MarcelineVQ> The real answer though is that the difference is just their definition
03:58:06 <fen> so that there is then a question of how to use these unfoldl and unfoldr to mimic the difference between foldl foldr... that the original state could somehow "use the last value it returns first" ... 
03:59:06 <fen> which would allow the costly get-unfold to fuse down to the original state unfold, but that just uses the leftmost value first
03:59:41 <fen> instead of unfolding the whole list from the right using the original state, and then unfolding it again from the left using the get unfold
04:00:30 <fen> probably there is something like how foldl forces evaluation of the whole state unfold... so that it cant be used lazily... 
04:38:47 <t3rtius> @help
04:38:48 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:38:58 <t3rtius> @help list
04:38:58 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
04:39:43 <t3rtius> list
04:39:47 <t3rtius> @list
04:39:47 <lambdabot> What module?  Try @listmodules for some ideas.
04:40:06 <t3rtius> @listmodules
04:40:06 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
04:40:06 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
04:44:31 <shapr> I wish cabal init had an option to add test-suite and common stanzas upon creation
04:44:41 <shapr> but I guess if I really want it, I'll add it.
04:47:24 <shapr> @quote Cale
04:47:24 <lambdabot> Cale says: That should be fine then. <mar77a> woah <mar77a> now it works
05:18:59 <adnathanail> ?src (map)
05:18:59 <lambdabot> Source not found. My brain just exploded
05:19:05 <adnathanail> ?src ($)
05:19:05 <lambdabot> f $ x = f x
05:19:07 <adnathanail> ?src (.)
05:19:07 <lambdabot> (f . g) x = f (g x)
05:19:09 <adnathanail> ?src (+)
05:19:09 <lambdabot> Source not found. Are you on drugs?
05:19:13 <adnathanail> ?src (filter)
05:19:14 <lambdabot> Source not found. It can only be attributed to human error.
05:20:16 <shapr> @src filter
05:20:17 <lambdabot> filter _ []     = []
05:20:17 <lambdabot> filter p (x:xs)
05:20:17 <lambdabot>     | p x       = x : filter p xs
05:20:17 <lambdabot>     | otherwise = filter p xs
05:20:21 <shapr> @src map
05:20:21 <lambdabot> map _ []     = []
05:20:21 <lambdabot> map f (x:xs) = f x : map f xs
05:22:07 * hackage Chart 1.9.1 - A library for generating 2D Charts and Plots  https://hackage.haskell.org/package/Chart-1.9.1 (TimDocker)
05:24:07 * hackage Chart-cairo 1.9.1 - Cairo backend for Charts.  https://hackage.haskell.org/package/Chart-cairo-1.9.1 (TimDocker)
05:25:07 * hackage Chart-diagrams 1.9.1, Chart-gtk 1.9.1 (TimDocker): https://qbin.io/argue-sorry-4ov3
05:49:48 <Phyx-> @tell Solonarv 00:43:26 < Solonarv> it would be very strange for that to just fail silently, though
05:49:48 <lambdabot> Consider it noted.
05:49:54 <Phyx-> whoops
05:51:28 <Phyx-> @tell Solonarv 00:43:26 < Solonarv> it would be very strange for that to just fail silently, though <-- not if you're using mintty as your shell. Because of the std handle redirections that mintty does sometimes the signal handlers which are running in kernel mode print to the original console handlers. using winpty, strace or a native Windows shell will likely get you the error if one was generated
05:51:28 <lambdabot> Consider it noted.
05:52:20 <Phyx-> @tell Solonarv also the RTS can generate a coredump with +RTS --generate-crash-dumps
05:52:20 <lambdabot> Consider it noted.
06:00:49 --- mode: ChanServ set +o Sigyn
06:08:07 * hackage salak 0.2.5 - Configuration Loader  https://hackage.haskell.org/package/salak-0.2.5 (leptonyu)
06:10:07 * hackage salak 0.1.10 - Configuration Loader  https://hackage.haskell.org/package/salak-0.1.10 (leptonyu)
06:13:47 <jsjolen> Hi! Is there a typeclass that generalizes list :: a -> [a] and append :: [a] -> [a] -> [a] ?
06:14:15 <jsjolen> (and then some laws about preserving ordering in append I guess)
06:16:02 <phadej> jsjolen: http://hackage.haskell.org/package/reducers-3.12.3/docs/Data-Semigroup-Reducer.html#t:Reducer
06:18:59 <ski> jsjolen : if you're ok with more operations, then you could take `Alternative' or `MonadPlus'
06:19:07 * hackage flow 1.0.18 - Write more understandable Haskell.  https://hackage.haskell.org/package/flow-1.0.18 (fozworth)
06:21:13 <jsjolen> Cool! Thanks :-)
06:32:27 <dminuoso> Why am I getting this error? https://gist.github.com/dminuoso/49636e03a6f05ddbf061a9efd883de87
06:32:47 <phadej> dminuoso: NoMonomorphismRestriction
06:32:53 <dminuoso> phadej: Oh wow.
06:33:10 <dminuoso> phadej: I have been staring at it for nearly 30 minutes. Thanks. :)
06:33:25 <phadej> or user f = _packetAttributes f
06:34:17 <phadej> (or type annotation)
06:34:20 <dminuoso> phadej: Mmm no luck. I should mentoin that `_packetAttributes` is a classy lens perhaps.
06:34:49 <phadej> `Probable fix: use a type annotation to specify what ‘c0’ should be`
06:35:21 <dminuoso> phadej: `c0` is leaked in the return type, it shouldnt be ambiguous
06:35:32 <phadej> if that's where clause, than it isn't
06:35:43 <phadej> it it is in
06:35:55 <dminuoso> phadej: Its not, its a top level binding.
06:36:37 <dminuoso> phadej: Wait.. Why would it matter whether its in a `where` clause
06:38:01 <phadej> dminuoso: what's :t of _packetAttributes
06:39:43 <dminuoso> _packetAttributes:: (HasPacket c, Functor f) =>([Attribute] -> f [Attribute]) -> c -> f c
06:43:37 <dminuoso> Interesting, so explicitly giving it that signature seems to work. 
06:43:38 <phadej> https://gist.github.com/phadej/2ed808ede0dde00bc3c3a4381d2894ac
06:44:08 <phadej> what i said, either eta-expand (i.e. 'user f`); or add a type signatures
06:44:13 <phadej> that's what GHC told you to do
06:44:18 <phadej> (latter)
06:44:53 <dminuoso> phadej: Ohh, this could be a weird bug. Apparently I left a type hole during the `user f = _packetAttributes f` experiment. As long as I have `user :: _` I still get the ambiguous type error.
06:44:57 <dminuoso> This appears to be a diagnostic bug.
06:45:26 <dminuoso> phadej: The thing is, I dont understand why I need a type signature in the first place (since there is no ambiguous type)
06:45:39 <phadej> dminuoso: MonomorhismRestriction
06:45:49 <phadej> lenses as in `lens` are polymorphic objects
06:45:56 <phadej> forall f. Functor f => ...
06:46:32 <phadej> https://wiki.haskell.org/Monomorphism_restriction
06:46:40 <dminuoso> phadej: Okay. I rejected the idea because I still got the error (since I had forgotten to remove the typed hole)
06:46:49 <dminuoso> (Which I think could be an actual bug)
06:47:11 <dminuoso> phadej: Thank you very much. I owe you a cookie.
06:47:41 <phadej> no worries :)
06:53:03 <dminuoso> I guess Im still a bit baffled because I kept the following definition in mind: We say that an expressione has an ambiguous type if, in its type ∀u_. cx ⇒ t, there is a type variable u in u_ that occurs in cx but not in t. Such types are invalid
07:06:46 <Cale> dminuoso: The monomorphism restriction more or less says that when you have a *pattern binding* (as distinct from a function binding that provides explicit arguments), and it has no explicit type signature, any constrained type variables in its type are not allowed to be generalised (forall'ed)
07:09:09 <Cale> dminuoso: So if it remains unclear when you compile the module what those types are, they're regarded as ambiguous, because we're not allowed to leave them as type variables (just because of the MR)
07:11:37 * hackage yam-datasource 0.5.15 - Yam DataSource Middleware  https://hackage.haskell.org/package/yam-datasource-0.5.15 (leptonyu)
07:12:37 * hackage yam 0.5.15 - Yam Web  https://hackage.haskell.org/package/yam-0.5.15 (leptonyu)
07:14:37 * hackage Naperian 0.1.1.0 - Naperian Functors for APL-like programming  https://hackage.haskell.org/package/Naperian-0.1.1.0 (DominicSteinitz)
07:17:40 <dminuoso> Cale: What is the rationale of that rule 2? "Any monomorphic type variables that remain when type inference for an entire module is complete, are considered ambiguous, and are resolved to particular types using the defaulting rules"
07:18:15 <dminuoso> (Though based on what you said, it seems Im tripping into Rule 1 rather)
07:19:09 <phadej> the idea is to not generalise things which don't like "polymorphic"
07:19:35 <phadej> but then there's
07:19:39 <phadej> :t 1
07:19:40 <lambdabot> Num p => p
07:19:53 <phadej> which would be PITA to annotate
07:20:01 <phadej> though, the default to Integer which might be bad as well
07:20:18 <siraben> I can't seem to expand type synonyms in GHC 8.6.4, with :kind!
07:21:31 <Cale> dminuoso: If you write some expression like x = product [1..1000] you might not expect that each occurrence of x gets recomputed, but if its type remains polymorphic that's exactly what must happen.
07:21:31 <c_wraith> siraben: works for me.  what's happening on your end?
07:22:02 <Cale> dminuoso: The defaulting rules bit helps numeric expressions not all be sources of the compiler complaining at you.
07:22:31 <c_wraith> the type of (^) is pretty annoying with -Wall
07:22:55 <phadej> :t (^)
07:22:56 <lambdabot> (Num a, Integral b) => a -> b -> a
07:23:06 <phadej> it's without as well
07:24:52 <siraben> c_wraith:  let's say I write type Foo = (Int, String)
07:24:52 <siraben> Running :kind! Foo
07:24:55 <siraben> doesn't give me back (Int, String)
07:25:39 <c_wraith> interesting.  I tested with a type family, which was expanded
07:26:06 <c_wraith> but simple type synonyms don't seem to be.
07:26:30 <phadej> does even type family Id a = a -- reduce?
07:27:20 <phadej> it does
07:27:24 <c_wraith> yep
07:27:30 <phadej> I'd like to know why such difference :)
07:27:48 <c_wraith> siraben: ok, that's interesting
07:28:03 <c_wraith> Not sure whether that's a bug or intended behavior
07:28:05 <phadej> GHC tries not to expand type aliases to not make type errors terribly large
07:28:08 <phadej> so it might be related
07:28:39 <siraben> Hm I should look into type familes
07:28:40 <siraben> families*
07:28:52 <siraben> Any recommended resources on that?
07:34:14 <dmwit> siraben: It's been that way for ages, by the way. I believe I've suggested a feature to expand them on the bug tracker, though I'd have to search a bit to find it.
07:34:25 <dmwit> I've also wished for a version that just took "one step" at a time.
07:35:00 <siraben> I had to expand a function called hold :: L -> K -> C by hand to get the type signature hold :: L -> ([E] -> [(E, T)] -> A) -> [(E, T)] -> A
07:35:09 <siraben> It can't be done automatically?
07:35:38 <dmwit> Not with the current state of tooling, sorry.
07:35:51 <siraben> Bummer
07:35:52 <dmwit> If you use hasktags, you can jump to the definitions of type synonyms, which may be helpful.
07:36:21 <siraben> But it feels like it should be something easy to implement, is there something preventing its development?
07:36:25 <dmwit> Even if you don't, :info will expand a single synonym.
07:36:38 <dmwit> As far as I know, the only thing blocking development is will.
07:54:22 <dminuoso> Cale: Okay that makes sense. The part about constrained type variables is fairly interesting since it seems rather simple to trigger, but it's very elusive as to why this is.
07:54:35 <dminuoso> I mean it invalidates bindings like `f = fmap`
07:54:43 <dminuoso> Or even `x = 5`
07:54:59 <dminuoso> Though that would get type defaulted.
08:00:54 <alpha_sh> Bored? Call the official freenode IRC partyline at +4521137886
08:01:46 <misspwn_27> Bored? Call the official freenode IRC partyline at +4521137886
08:02:00 <gernot26> Bored? Call the official freenode IRC partyline at +4521137886
08:02:03 <Ariakenom_> dminuoso: note that it only applies to top level bindings
08:02:42 <ShapeShifter499> Bored? Call the official freenode IRC partyline at +4521137886
08:10:01 <o1lo01ol1o> What's the partyline?
08:10:09 <glguy> It's spam, you can ignore it
08:10:12 <merijn> o1lo01ol1o: It's spam
08:10:27 <o1lo01ol1o> Yea, I assume, but I wonder if anyone has called
08:10:34 <glguy> It's off-topic here
08:10:39 <merijn> o1lo01ol1o: Freenode fairly regularly gets hit by spam, (D)DOS attacks, etc. 
08:11:06 <merijn> o1lo01ol1o: Also, I expect that number leads to scams or excessive phone fees
08:11:38 <aplainzetakind> pipl.com resolved that number to a certain developer, who seems to be thoroughly hacked.
08:14:56 <Taneb> How can I express something like scanl with recursion-schemes? Ideally with no explicit recursion or corecursion
08:16:30 <tsizz> sorry very new to haskell whats abs :: Int -> Int mean?
08:16:43 <dminuoso> tsizz: It means `abs has type Int to Int`
08:16:50 <tsizz> i mean i know it means input int output int for function
08:16:53 <dminuoso> tsizz: That is, abs is a function taking an Int and returning an Int
08:17:05 <tsizz> but im confused when you define that
08:17:22 <dminuoso> tsizz: What do you want to know then? :)
08:17:37 <tsizz> like i thought function would be addTwo x = x + 2
08:17:45 <dminuoso> tsizz: It is a type annotation.
08:17:47 <tsizz> which would be addTwo :: Int -> Int?
08:17:54 <tsizz> hm what is that
08:18:09 <dminuoso> tsizz: Explicitly telling GHC what type `addTwo` has.
08:18:39 <dminuoso> tsizz: Haskell has type inference, so if you dont tell it explicitly then Haskell will try to infer the type. For various reasons you can make the type known explicitly.
08:18:41 <Taneb> tsizz: abs for Int is a bit of a special function, it's defined as a primitive to be handled by the compiler
08:18:52 <Taneb> tsizz: the "abs" function returns an absolute value
08:18:58 <Taneb> > abs (-10)
08:19:00 <lambdabot>  10
08:19:01 <tsizz> dminuoso: hm okay whats the point of that? you dont have to provide the type of the function right
08:19:02 <Taneb> > abs 42
08:19:04 <lambdabot>  42
08:19:16 <dminuoso> tsizz: For one, documentation.
08:19:27 <dminuoso> tsizz: It's very frequently helpful to just see what kind of type some parts of your program has.
08:19:46 <dmwit> Taneb: I'm actually not sure there can be an analog, though scanl1 might be possible.
08:19:48 <tsizz> so its like 1 line: function type 2 line: function and its body?
08:20:07 <tsizz> dminuoso: true i haven't coded in static type language in a while so i forgot how it can be really useful
08:20:16 <dminuoso> tsizz: For example, yes.
08:20:23 <dmwit> tsizz: That's a very common style, yes.
08:20:40 <dmwit> The language allows the type declaration and the definition to be separated, though it's rare to use that feature.
08:20:46 <tsizz> hm okay thanks. sorry i have a test in liek an hour and we only brushed haskell but i barely looked at it hah
08:20:51 <dminuoso> tsizz: Another useful property is that the way type inference works in Haskell it can sometimes lead to very hard to interpret errors if too much type is not annotated.
08:21:02 <dminuoso> tsizz: When you annotate your bindings errors pop up closer to the source of a problem.
08:21:07 * hackage streamly 0.6.1 - Beautiful Streaming, Concurrent and Reactive Composition  https://hackage.haskell.org/package/streamly-0.6.1 (harendra)
08:21:09 <tsizz> ah
08:21:22 <tsizz> also type constructor will be aksed about
08:21:43 <tsizz> from what ive looked at it esems likes like data variable = object
08:21:44 <tsizz> ?
08:22:17 <dminuoso> tsizz: And last but not least, Haskellers frequently enjoy writing out a type first, and then writing code to match that type. So it can help you write down the "framework" of the function, and then fill in the details by implementing it.
08:22:55 <tsizz> dminuoso: hm yeah much more thought into it than dynamic typed 
08:22:57 <tsizz> languages
08:23:16 <tsizz> is type constrcutor basically same as a object constructor in java
08:24:35 <dmwit> Data constructors in Haskell and object constructors in Java have some similarities.
08:24:59 <dmwit> Type constructors in Haskell and generic containers in Java have some similarities.
08:25:39 <tsizz> data Color = Red| Blue |
08:25:42 <tsizz> seems simple enough
08:25:48 <tsizz> But what is Red and Blue in here...?
08:25:58 <tsizz> i would think if they were values they would be a string
08:26:14 <dmwit> Red and Blue are new data constructors, created by that declaration; each has type Color.
08:26:28 <tsizz> oh
08:26:37 * hackage haskoin-store 0.12.0 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.12.0 (xenog)
08:26:38 <tsizz> then where you define Color's attributes
08:26:52 <dminuoso> tsizz: The data definition style is very terse.
08:26:54 <dmwit> That declaration would be the place.
08:27:05 <dmwit> The current declaration indicates that there are no attributes.
08:27:10 <dminuoso> You could write: `data Color = Red Int | Blue Int | Green Int`
08:27:14 <dmwit> (If I am understanding what you mean by "attributes" correctly.)
08:27:39 <dminuoso> It's very comfortable to read if you are used to Haskell, but it can be very difficult to read since it mixes types and data level constructs visually.
08:27:51 <tsizz> well from what dmwit said it seems like in java terms data Color = new Color(Red) and data Color = new Color(Blue)
08:28:06 <tsizz> but like what is Red then
08:28:13 <dminuoso> tsizz: here you could just create the data directly using `Red` or `Blue`
08:28:22 <dminuoso> % data Color = Red | Green | Blue
08:28:22 <yahb> dminuoso: 
08:28:28 <dmwit> In Java terms, it would be class Color { bool isRed; }
08:28:30 <dminuoso> % x = Red
08:28:30 <yahb> dminuoso: 
08:28:36 <tsizz> i mean like ok i have data Car = Mercedes | BMW
08:28:42 <dmwit> (With the understanding that if it isn't red, it's blue.)
08:28:47 <tsizz> but like wheres Car.yearCreated 
08:28:48 <tsizz> or whatever
08:28:53 <dmwit> Doesn't exist.
08:28:56 <dmwit> If you want it, you must
08:29:11 <dmwit> data Car = Mercedes { yearCreated :: Int } | BMW { yearCreated :: Int }
08:29:29 <tsizz> dmwit: hm okay. so data Car = Mercedes | BMW 
08:29:31 <tsizz> does nothing really
08:29:33 <dmwit> or: data Model = Mercedes | BMW; data Car = Car { model :: Model, yearCreated :: Int }
08:29:45 <tsizz> dmwit:  i liike that way better
08:29:59 <dminuoso> Or you start with `data CarDetalis = { yearCreated :: Int, price :: Int }`, `data CarMake = BMW | Mercedes` and then have some `data Car = Car { details :: CarDetails, make :: CarMake }
08:30:10 <dmwit> No, it is not accurate to say that it does nothing. data Car = Mercedes | BMW declares three new entities (one type constructor and two data constructors), which is hardly nothing.
08:30:51 <tsizz> dmwit: okay but i mean Mercedes | BMW are Cars, but they don't have attributes so you cant really do much with them i mean
08:31:03 <dminuoso> tsizz: Sure you can.
08:31:04 <dmwit> You can check whether they are Mercedes or BMWs.
08:31:07 <dminuoso> tsizz: you can use them somewhere else.
08:31:27 <tsizz> dminuoso: im confused bc its like your using an object for something that you dont know if it can do
08:31:44 <dmwit> tsizz: Think of data Bool = False | True. Basically the same type, but surely you wouldn't claim that booleans aren't useful. =)
08:32:02 <dminuoso> tsizz: Here is a more technical example: data SockState = Opened | Named | Readable | NotWritable | Closed
08:32:11 <dminuoso> tsizz: Do you see the value in having such a SockState?
08:32:32 <tsizz> dminuoso: hm true. so thats more not like an object tho. more like a state 
08:32:43 <dminuoso> tsizz: You can add information.
08:33:13 <tsizz> dminuoso: can you just declare normal variables like that
08:33:14 <dmwit> Indeed, you can add information only in some "states" and not others.
08:33:33 <dmwit> data SockState = Opened { byWhom :: String } | Named | Readable | NotWritable | Closed
08:33:36 <tsizz> like data x = 1 | 3 | 5 
08:33:48 <tsizz> dmwit: hm okay thats useful
08:34:06 <dmwit> That isn't syntactically correct. But you could write data SmallOddNumber = One | Three | Five.
08:34:11 <tsizz> i feel like javascript really helped me pick up these more functional languages
08:34:21 <tsizz> dmwit: but is that normal for a variable
08:34:28 <tsizz> or is data more reserved for objects
08:34:28 <dmwit> No variables here.
08:34:37 * hackage aeson-casing 0.2.0.0 - Tools to change the formatting of field names in Aesoninstances.  https://hackage.haskell.org/package/aeson-casing-0.2.0.0 (andrewrademacher)
08:34:45 <dmwit> Ah, perhaps this is the core of your confusion.
08:35:01 <dmwit> This is creating new *types*, not defining a variable.
08:35:53 <dmwit> By comparison to Java: a `class` declaration doesn't actually bring into being any special memory arrangement. You must declare a variable, and construct an instance of that object, and store it into the variable, before the contents of memory changes.
08:36:10 <tsizz> dmwit: mhm so whats declaring a variable in  haskell
08:36:15 <tsizz> like int x = 5 in java
08:36:18 <dmwit> `x = 5`
08:36:20 <tsizz> or is not a thing
08:36:23 <dmwit> % x = 5
08:36:23 <yahb> dmwit: 
08:36:25 <dmwit> % x
08:36:25 <yahb> dmwit: 5
08:36:32 <tabaqui> pssst, TypeFamilies
08:36:37 <tsizz> but then you cant reassign x right
08:36:40 <dmwit> % data Color = Red | Blue | Green
08:36:40 <yahb> dmwit: 
08:36:44 <dmwit> % c = Red
08:36:44 <yahb> dmwit: 
08:36:45 <dmwit> % c
08:36:45 <yahb> dmwit: ; <interactive>:213:1: error:; * No instance for (Show Color) arising from a use of `print'; * In a stmt of an interactive GHCi command: print it
08:36:59 <dmwit> % data Color = Red | Blue | Green deriving (Eq, Ord, Read, Show, Enum, Bounded)
08:36:59 <yahb> dmwit: 
08:37:02 <dmwit> % c = Red
08:37:02 <yahb> dmwit: 
08:37:03 <dmwit> % c
08:37:03 <yahb> dmwit: Red
08:37:32 <dmwit> tsizz: Correct, to a first approximation.
08:38:02 <dmwit> You can shadow old variables; I have an SO answer on why that's not the same thing as changing a variable's value if you're interested.
08:38:12 <tsizz> % map (+0) [1,2,3,4,5]
08:38:12 <yahb> tsizz: [1,2,3,4,5]
08:38:15 <tsizz> wut
08:38:27 <dmwit> What output did you expect?
08:38:37 <tsizz> 15
08:38:40 <tsizz> oh
08:38:41 <tsizz> woops
08:38:42 <tsizz> wrong function
08:38:47 <dmwit> % sum [1,2,3,4,5]
08:38:47 <yahb> dmwit: 15
08:39:07 <tsizz> % foldr (+0) [1,2,3,4,5]
08:39:07 <yahb> tsizz: ; <interactive>:220:1: error:; * No instance for (Show ([[Integer] -> [Integer]] -> [Integer])) arising from a use of `print'; (maybe you haven't applied a function to enough arguments?); * In a stmt of an interactive GHCi command: print it
08:39:12 <tsizz> WUT
08:39:17 <dmwit> % foldr (+) 0 [1,2,3,4,5]
08:39:17 <yahb> dmwit: 15
08:39:22 <tsizz> o
08:39:34 <dmwit> (But for summing, you should use foldl' and not foldr.)
08:39:42 <tsizz> oh whats foldr for then
08:39:52 <adjofun> Did I join MMORPG GHCi session? =)
08:39:56 <tsizz> i only know reduce really from javasript
08:40:03 <dmwit> ?wiki fold
08:40:03 <lambdabot> https://wiki.haskell.org/fold
08:40:13 <dminuoso> tsizz: In Haskell variables are more like variables in the mathematical sense, where you name an equivalence between some name `x` and some `right hand side` and you can freely swap out one for the other everywhere without changing the meaning.
08:40:33 <dmwit> ?wiki foldr_foldl_foldl%27
08:40:33 <lambdabot> https://wiki.haskell.org/foldr_foldl_foldl%27
08:40:40 <dmwit> Oops.
08:40:48 <dmwit> ?wiki Foldr_Foldl_Foldl%27
08:40:48 <lambdabot> https://wiki.haskell.org/Foldr_Foldl_Foldl%27
08:40:54 <tsizz> dminuoso: isn't that every programming language variable...?
08:40:55 <Rembane> Is it because foldr can't fold infinite lists?
08:41:05 <tsizz> ok so fold right vs fold left
08:41:20 <tsizz> ah god i can't wrap my head around that right now. why can't it just be 1 reduce :)
08:41:40 <adjofun> why cant everything be a monoid =)
08:41:41 <Rembane> They are good at different things, or so I have been told. 
08:41:43 <dmwit> I think you'd be perfectly fine skipping that discussion for now.
08:41:51 <tsizz> foldr seems more like normal recursion?
08:41:57 <tsizz> or like lambda normal form calculus 
08:41:59 <tsizz> or idk
08:42:04 <tsizz> trying to combine the context of the course 
08:42:14 <dmwit> They are both relatively normal recursion.
08:42:22 <dmwit> Never heard of "lambda normal form calculus".
08:42:58 <tsizz> dmwit: oh laziness in haskell...
08:43:02 <tsizz> simple example ?
08:43:05 <tsizz> to show difference from java
08:43:10 <tsizz> or if you know js or python im better with those
08:43:25 <dmwit> https://stackoverflow.com/q/7868507/791604
08:43:27 <dminuoso> tsizz: Imagine this pseudo ruby code: `x = 1; x.increment!; puts x` - do you think you can replace `x` with `1` in all parts of that program without changing the meaning?
08:44:25 <tsizz> dminuoso: well isnt that point of scopes
08:44:33 <dminuoso> tsizz: But thats not a scope issue.
08:44:40 <dminuoso> tsizz: In Ruby that x would be the same.
08:44:52 <dminuoso> tsizz: In Haskell `x = foo bar` is a statement of equality. It's stating that `x` is equal to `foo bar`. In other words, if somewhere in your program (within the rules of scope/shadowing) you find an `x` you can replace it with `foo bar` without changing the meaning
08:45:07 <dminuoso> Just like you could in math when you specify `x = 1`
08:45:30 <tsizz> dminuoso: mhm 
08:46:01 <tsizz> dminuoso: that description bit confusing
08:46:02 <vaibhavsagar> has anyone tried to update nhc98 for 64-bit architectures?
08:46:41 <tsizz> how come i didn't have to declare variable type?
08:46:46 <tsizz> if its staticlly typed
08:47:11 <tsizz> ok so it type inference. 
08:47:15 <tsizz> except function signatures o.O?
08:47:26 <merijn> tsizz: Functions can be inferred too
08:47:32 <dmwit> tsizz: https://stackoverflow.com/a/44407798/791604 <- a demonstration of the difference between Haskell variables and Python variables
08:47:38 <geekosaur> function signatures can be inferred. but typeclasses can make for confusing errors
08:47:45 <dminuoso> tsizz: No you can type annotate everything.
08:47:46 <dminuoso> % x :: Int; x = 5
08:47:46 <yahb> dminuoso: 
08:47:55 <geekosaur> since inference may only detect a conflict at a use site
08:48:27 <tsizz> now im confused about type inference in haskell vs. dynamic typed languages
08:48:30 <dmwit> tsizz: It is best practice to document top-level declarations. But the language itself doesn't require it (except in a few special circumstances that exist for practicality, not because the theory says they have to).
08:48:50 <dmwit> tsizz: So if your question is stemming from observing that everybody annotates their function types, that is the likely explanation.
08:49:07 <dmwit> tsizz: That is, it's not that the type *can't* be inferred. It's that there are reasons to write down the type yourself.
08:49:11 * dminuoso annotates every top level binding and where bindings. all of them
08:49:32 <tsizz> dminuoso: yeah i gotchu. so thats why im confused now about type inference in static typed language vs how typing works in dynamic languages
08:49:39 <dmwit> "Why do my top level functions need signatures?" https://stackoverflow.com/q/19626801/791604
08:49:42 <geekosaur> dynamic typing means it finds out while running. type inference means it finds out before it runs (and possibly has e.g. made changes to files or databases that you might need to undo afterward)
08:49:45 <tsizz> bc to me type inference IS dynamic languages
08:49:57 <adjofun> System F versus duck typing =)
08:50:19 <tsizz> so java doesn't type infereerence, but why
08:50:25 <tsizz> as a static language
08:50:26 <adjofun> it has
08:50:36 <adjofun> but very poor in comparison to haskell
08:50:48 <tsizz> but i mean you can't be like x = 5
08:50:57 <tsizz> or x = 's'
08:51:27 <dmwit> Are you asking what features of Java lead us to say "it doesn't have type inference", or are you asking what caused the Java language designers to choose not to use type inference?
08:52:08 <dminuoso> tsizz: Type inference makes static type systems very comfortable indeed.
08:52:58 <adjofun> you write "var x = 5" in recent versions of java, but it sucks
08:53:48 <adjofun> dont mistake type inference in compile-time, and in runtime
08:54:02 <dminuoso> tsizz: Type inference can be complicated to implement depending on the semanics of your language/type system. It also might not work in all cases.
08:54:17 <tsizz> adjofun: wait really?
08:54:19 <dminuoso> Even Haskells type inference is not perfect, there are situations where you must hold your compilers hand and simply tell what some bindings type is.
08:54:24 <tsizz> javascript stop using var lol
08:54:37 <maerwald> and sometimes type inference causes compile errors xD
08:54:37 <dminuoso> But a lot of thought went into Haskell and its type system to ensure a high degree of freedom in type inference.
08:55:00 <tsizz> one disadvantage of lazy evaluation?
08:55:02 <dminuoso> So you could say that Haskell was designed with type inference in mind. Not many languages have this property.
08:55:07 <tsizz> is itmemory issue?
08:58:41 <dminuoso> tsizz: It can be a mindbenber when learning certain recursive algorithms.. so there's that. :o)
08:58:41 <adjofun> dynamic languages practice so called "duck typing", when type of a variable is resolved in runtime by looking at methods call to it, efectifely coercing it to be given type. Static languages do that in compile-time, looking at variable declarations, and catch you, if there is a type mismatch. Haskell can infer type far better, so we can omit type signatures in most situations.
08:59:44 <tsizz> i can't seem to understand currying
08:59:48 <tsizz> adjofun: and okay that makes sense
09:00:09 <dminuoso> tsizz: Id say take one step at a time and dont overload yourself with information.
09:00:24 <dminuoso> tsizz: take your time practicing your knowledge, writing out code, experimenting, solving problems
09:01:32 <adjofun> also, there is a very good book for beginners in haskell: http://haskellbook.com/
09:02:48 <tsizz> hm from what i understand every haskell function takes one argument, but can take more bc of currying
09:03:44 <dminuoso> tsizz: Imagine `f x y z = ...` being a shorthand for `f = \x -> \y -> \z -> ...`
09:04:44 <adjofun> every haskell function is curried by default. It always takes one argument, but can return either a result, or another function, which consumes next argument.
09:05:05 <dminuoso> tsizz: So `f 1 2 3` can be thought of as three different application steps
09:05:28 <dminuoso> So `f 1 2` gives you a function back...
09:05:34 <maerwald> adjofun: the book is proprietary
09:05:40 <tsizz> so in haskell all functions are curried.
09:05:47 <tsizz> under the hood
09:05:55 <tsizz> ?
09:05:57 <dminuoso> tsizz: Above the hood.
09:06:16 <tsizz> hm okay
09:06:19 <yushyin> maerwald: do we have a good open book?
09:06:19 <dminuoso> tsizz: Subtly it's somewhat more complicated, but you dont need to concern yourself with it.
09:06:27 <tsizz> alright i have to go. thanks for all the help
09:06:28 <dminuoso> tsizz: You can really safely pretend that all functions are curried.
09:06:33 <tsizz> it helped a lot
09:06:48 <maerwald> yushyin: I don't think so, real world haskell is too old
09:07:01 <dminuoso> yushyin: CIS194 is currently the favoured resource
09:07:10 <maerwald> it's not really a book
09:07:13 <dminuoso> (if you go by frequency of recommendation in #haskell)
09:07:21 <adjofun> maerwald: what? It costs money. Or did i, by inclusion of this forsaken link, summon all the demons, and partyvans on my poor head? =)
09:07:29 <dminuoso> maerwald: What else is a book than having sections, explaining things and giving you assignments/homework.. ;)
09:07:54 <Taneb> dminuoso: a cover by which we may judge it
09:08:03 <maerwald> adjofun: no, I mean it is proprietary. If I buy it and upload it on my own server and link it here for other people to download, I will get in trouble ;)
09:08:04 <dminuoso> Taneb: Touche.
09:08:54 <yushyin> a community written book with a proper open source license would be nice indeed
09:09:18 <dminuoso> yushyin: I consider cis194 to be such a resource.
09:09:34 <maerwald> Except it's not really a book
09:09:41 <adjofun> It is a good book, however. One guy just did it, because community didn't.
09:09:43 <maerwald> It's lecture notes and exercises
09:09:57 <dminuoso> It's open and I consider Joachim Breitner and Brent Yorgey to be peers from this community. :)
09:10:13 <maerwald> A book is more consistent and detailed 
09:10:31 <maerwald> cis194 was a course
09:12:37 * hackage constraints-deriving 1.0.1.0 - Manipulating constraints and deriving class instances programmatically.  https://hackage.haskell.org/package/constraints-deriving-1.0.1.0 (achirkin)
09:15:40 <DigitalKiwi> soo the book is bad because it's propietary, the course is bad because it's not a book, haven't suggested an alternative, guess nobody should learn haskell
09:16:41 <maerwald> the book is proprietary because it's proprietary, the course is a course, because it is a course :)
09:16:45 <vaibhavsagar> is it still possible to build nhc98 today? I've tried it a couple of times and haven't gotten it to work
09:16:58 <maerwald> And the course is great indeed
09:17:12 <maerwald> The book I don't know, because I don't have it
09:17:18 <yushyin> I don't think the book is bad, I read some of the chapters and was pleased with those
09:17:32 <DigitalKiwi> and fwiw the book (from the parts i've read, and from what i've heard) is a good book. the hutton book is really good 
09:26:48 <MarcelineVQ> https://en.wikibooks.org/wiki/Haskell
09:29:08 <DigitalKiwi> that has some good stuff
09:29:58 <dminuoso> DigitalKiwi: I guess the relevant part of the story is: Different people have different backgrounds and tastes.
09:30:06 <DigitalKiwi> also http://dev.stephendiehl.com/hask/
09:30:26 <dminuoso> The Haskell Book is very easy going making no presumptions about any programming knowledge. It's not very accurate or formal either.
09:30:37 <dminuoso> I liked the Gentle Introduction to Haskell.
09:30:51 <dminuoso> But that is for a difference audience.
09:31:46 <DigitalKiwi> if i were to recommend one book and one alone it'd be the hutton book
09:32:28 <dminuoso> DigitalKiwi: Hutton brought his book to London at the Haskell eXchange, I wish I had peeked a look inside. :/
09:32:57 <yushyin> DigitalKiwi: yeah I do like that hask page, full of information and not so wordy
09:33:33 <DigitalKiwi> (based largely on that of all of the books i've tried to read that's been the most helpful one of few i've actually finished and i don't like recommending stuff if i haven't read it in full)
09:35:56 <DigitalKiwi> i also like richard bird books and maybe one day i'll be smart enough to finish one >.>
09:40:12 <maerwald> Usually intelligence doesn't increase over time, but energy and skill may :) (and so intelligence is over-valued)
09:45:14 <Cale> maerwald: You know, I'm really unsure that the distinction between intelligence and skill is so clear.
09:45:18 <DigitalKiwi> smart is working over time there. smart in the sense of "if i was smart i'd invest the time/energy to do this thing that would be beneficial" as well as that they make my head hurt but in a good way :|
09:46:27 <boj> you've got this
09:46:53 <Cale> Intelligence seems for the most part to just be the aggregation of many individual skills.
09:47:47 <DigitalKiwi> LOL https://www.atamo.com/articles/how-to-read-pearls-by-richard-bird/
09:47:53 <reallymemorable> Can anyone see what I'm doing wrong here?  runReq in line 23 needs an HttpConfig as an input, but downloadFile is not, so I am trying to use defaultHttpConfig from the Req docs, but it's saying variable not in scope even though I'm importing everything from that library.
09:47:57 <reallymemorable> https://gist.github.com/reallymemorable/09ac0a04799b1464435e134b8208b0a5
09:48:36 <DigitalKiwi> that specifically is the one that i like but makes my head hurt so i'm glad to see i'm not the only one
09:51:40 <maerwald> Cale: IME intelligence is a "mechanical" property of the brain, part of which is "focus" or "concentration", another part is "speed" and things like how complex a thought or problem can be that the person can still have it in his mind with sufficient clarity. This does not improve over time.
09:51:41 <DigitalKiwi> i liked the parts of thinking functionally with haskell by him too but again i haven't read all of it so ymmv dtmwfi
09:51:58 <maerwald> Skill, experience and energy is different and has a way higher ceiling
09:52:41 <Cale> maerwald: Focus and concentration are skills that can be worked on though.
09:52:47 <maerwald> I agree
09:52:55 <Cale> and speed comes from already knowing solutions to things, usually
09:53:11 <maerwald> Yeah
09:53:13 <Cale> (or something similar enough)
09:53:28 <maerwald> But sometimes you talk to people and you just know they think faster than you :)
09:53:48 <Cale> Well, yeah, but usually I attribute it not to something innate, but to how they'd previously spent their time
09:54:35 <maerwald> That leaves the property of clarity only maybe (most people probably thing of it as the "chess thing")
09:55:41 <maerwald> Not sure that's something you can reasonably work on.
09:59:15 <asthma[m]> <Cale "Well, yeah, but usually I attrib"> @cale2:matrix.org: so all of intelligence is learned?
09:59:34 <maerwald> haha
10:00:01 <maerwald> I think that is easily falsified when you talk to some overly gifted people :)
10:00:04 <Cale> asthma[m]: Most of it. There can be physical differences, but I kind of feel like most able adult humans are not so different in terms of what their potential was.
10:00:38 <maerwald> Cale: maybe because you are at the higher end of it? ;)
10:00:39 <asthma[m]> @cale2:matrix.org: study some biology
10:00:39 <lambdabot> Unknown command, try @list
10:00:41 <Cale> I was always regarded as "gifted", but really, it was just a matter of what I spent my time on.
10:02:58 <Cale> If you spend a lot of time programming or reading textbooks or thinking about mathematics or something like that instead of, e.g. going to parties and drinking, you're going to come away with that seeming a whole lot smarter, when really it was just that you put in more time.
10:03:05 <maerwald> I think it's also the preservation of curiosity and the balance of challenge and finding a solution. Which brings me back to mechanical properties. If these are high enough, the balance of challenge and finding a solution is more likely to be good, so energy and skill increases constantly without too many frustrational events
10:04:10 <Cale> I don't play piano, so I suck at it, but I obviously could be a lot better at it, were I to spend my time trying to play piano.
10:04:28 <maerwald> I was good at accordeon, but I had no motivation lol
10:04:47 <maerwald> So mechanical skills were high, motivation lol
10:04:57 <maerwald> *low
10:06:10 <maerwald> and you can't learn those mechanical things. These are evident before you even figure out how to play the instrument properly. To any good teacher
10:07:54 <Cale> I can't help but disagree. Every hour I spent practicing clarinet in highschool made me better at playing clarinet.
10:08:13 <Cale> It's obviously going to be awkward and unnatural feeling at first
10:09:20 <Cale> But then you practice a whole lot and eventually you'll have played so many similarly-shaped phrases of music before that you don't have to think about the individual notes or the mechanics of playing a phrase
10:09:26 <Cale> You develop muscle memory for it
10:09:28 <maerwald> Yes, you increase your skill, but the ceiling and the speed of learning is defined by obsession and mechanical properties
10:09:48 <Cale> Mostly by obsession, I'd say.
10:10:02 <Cale> Sure, some people have longer fingers
10:10:10 <Cale> and stuff like that
10:10:34 <Cale> but I have a hard time being convinced that it's really a big factor
10:10:38 <maerwald> My experience is different. I had no obsession with music 
10:10:44 <Cale> It's more "am I motivated enough?"
10:11:08 <Cale> You certainly have to *want* to play music to become really good at it
10:11:13 <Cale> but that's sort of my point
10:11:41 <Cale> It's less about some innate talent and more about what it is that you've wanted to do, integrated over time
10:12:27 <maerwald> So we are just disagreeing on weight of the mechanical property I guess
10:13:31 <Cale> It's also somewhat about socioeconomic opportunity to spend your time on stuff
10:14:03 <maerwald> So would you say I could become as proficient with CT as edward just because I want to? :>
10:14:07 <Cale> yes
10:14:10 <maerwald> hahaha
10:14:17 <Cale> There's nothing magic about it
10:14:24 <Cale> He just spends every day working on that kind of stuff
10:14:41 <maerwald> I think his mind just has a different level of clarity
10:14:55 <Cale> and it helps that he has all the time in the world to work on it because he's being paid not to write certain graphics software
10:15:06 <__monty__> You can probably reach his current level but you may not be able to ever surpass him : )
10:15:30 <__monty__> Depends on respective rates of learning and lifespan.
10:15:30 <maerwald> Magnus Carlsen was a rather undisciplined chess player, yet he surpassed everyone 
10:15:52 <Cale> I bet he played a lot of chess though
10:16:13 <maerwald> As did Kasparov and many others
10:16:13 <DigitalKiwi> watching edwardk stream him coding on twitch is quite motivating
10:16:35 <Cale> The margins between top chess players are pretty small, and magnified by the competition
10:18:12 <maerwald> Cale: I would rather say that improving the mechnical properties of your brain is not a learning process, but an attitude issue. If at all. Skill can be improved by learning, knowledge too, many things. But this one is different.
10:18:28 <Taneb> DigitalKiwi: I sometimes put an edwardk stream on in the background while I work
10:18:33 <Cale> I think the extent to which Ed thinks more clearly than you is a function of his experience. He knows the solutions to certain problems already, because he's spent time thinking about similar things before.
10:18:47 <DigitalKiwi> it's easy to look at a completed work or talk or what someone says on irc and think wow this person is amazing i could never do that. but if you watch them work you see oh they don't always know 100% what they're doing, they make mistakes too, they're figuring out stuff as they go, they have to look up stuff too, they're just as human as the rest of us
10:19:06 <maerwald> Cale: sad that's it's so hard to verify any of our opinions and assumptions
10:19:06 <Cale> So it might look like he gets to a novel solution much faster than you did, but really he's just remembering the 3 or 4 other things he's come across in the past.
10:19:12 <Cale> Yeah
10:20:29 <DigitalKiwi> and as cale says he spends a lot of time and gets payed for it and gets to meet a lot of people and has been doing what he does for what..10-20-30 years?
10:20:59 <maerwald> But coming back to your comment 20 minutes ago... spending your time on parties instead of haskell might be more worthwhile ;D
10:21:06 <Cale> I can only relate my experience with stuff. When I'm stupid or incapable in some area, it's usually explainable by way of how I spent my time. As I spend more time on things, I improve at them and similar problems solve themselves more easily.
10:21:08 <__monty__> Taneb: That's the only way to go. 10h streams for god's sake : )
10:21:34 <DigitalKiwi> one of my favorite edwardk talks https://www.youtube.com/watch?v=j0XmixCsWjs
10:22:08 <dminuoso> DigitalKiwi: ^- I was just about to quote the same talk.
10:22:08 <Cale> I don't really feel like there are hard limits on my ability at anything, just soft ones that always get pushed back by continued persistence, if I choose to spend my energy on doing that.
10:22:24 <ProofTechnique> I feel like a lot of his motivation also comes from how annoyed he is at how hard it is to express the problems he wants to solve in other languages :D
10:22:26 <dminuoso> DigitalKiwi: I strongly believe that this talk is core of what makes Edward appear like such a genius.
10:22:29 <maerwald> Cale: maybe you should party more :P
10:22:31 <DigitalKiwi> and if you've never seen this or even if you have but it's been a while https://www.youtube.com/watch?v=ji5_MqicxSo
10:24:56 <DigitalKiwi> my college *english* teacher assigned it as homework lol (it's randy pausch ftr if you don't click random links)
10:26:51 <Cale> maerwald: Maybe, I'm pretty bad at it. :D
10:28:26 <maerwald> Cale: I can teach you.
10:28:30 <maerwald> xD
10:36:09 <hpyCdr> is anyone resolving the acid-state issues? or is it just broken due to them?
10:37:07 <dminuoso> hpyCdr: Which issue in particular is a blocker for you?
10:37:56 <hpyCdr> https://github.com/acid-state/acid-state/issues/79 noted in https://www.reddit.com/r/haskell/comments/a7jy8e/acid_state_anti_recommendation/  looks pretty bad 
10:38:54 <dminuoso> 18:11:19            Cale | It's less about some innate talent and more about what it is that you've wanted to do, integrated over time
10:39:19 <dminuoso> Cale: ^- the main issue is that, when comparing the worlds top class musicians, which is probably just few dozens, then innate talens and the starting age becomes highly relevant.
10:39:31 <dminuoso> On the world stage you will rarely see people that have not started to play their instrument as a very young child.
10:40:12 <dminuoso> But as long as your goal is not to become a world class musician, Im going to argue that any motivated person could become proficient enough to amaze your friends with some years.
10:42:07 * hackage katip 0.8.2.0 - A structured logging framework.  https://hackage.haskell.org/package/katip-0.8.2.0 (MichaelXavier)
10:43:23 <Cale> dminuoso: Sure, but the question then is really whether you have sufficient time to reach a given level now.
10:43:40 <dminuoso> Cale: With increasing age learning becomes slower, sure.
10:44:00 <dminuoso> It just means that you must adapt your expectations.
10:44:25 <Cale> I'll also say there are also certain abilities like perfect pitch which if you don't learn them when you're very young, it's very difficult or perhaps impossible to pick them up later.
10:44:30 <nshepperd_> Innate talons
10:45:06 <ddellacosta> perfect pitch is of dubious value
10:45:26 <Cale> yes
10:45:53 <Cale> Relative pitch seems learnable by anyone even later, and it's the more useful one
10:47:43 <DigitalKiwi> https://en.wikipedia.org/wiki/Amusia#Congenital_amusia
10:47:46 <Cale> Still, if you were one of those children lucky enough to have learned to parse chords into their notes at an early age, you have so much more information at your disposal later -- all the music you'll have listened to will have been heard differently.
10:47:48 <dminuoso> Cale: This quickly puts us onto a path of unrealistic expectations though. If you take pianists for example, I have not identified any crucial aspect to becoming a world reknown professional player other than "starting playing in your youth and practice *a* *lot*"
10:48:03 <ddellacosta> it seems like this convo started by talking about edwardk and really excellent programmers and how to get there? While I see some similarities I think comparing to composers (or jazz improvisers) is probably a better place to start. Concert instrumentalists in the Europen classical tradition are like racehorses or something
10:48:19 <ddellacosta> *European
10:48:30 <dminuoso> ddellacosta: I dont think it matters really, at the core it all breaks down to motivation and practice.
10:48:52 <dminuoso> And absorbing new information/experience.
10:49:02 <dminuoso> So as long as you have that, then gradually you can become an expert in any field.
10:49:27 <ddellacosta> dminuoso: yeah, I don't disagree. As someone who studied music I just find it easy to get into the weeds on this topic, lol
10:50:08 <ddellacosta> the overlap between music and programming is very much there and also very much different than most people think. But I see that is not really the important part as far as this conversation is concerned
10:50:43 <DigitalKiwi> http://www.cs.yale.edu/homes/hudak/Papers/HSoM.pdf
10:51:12 <ddellacosta> also, to your one point dminuoso , one interesting result I read about a little while ago was how the really elite instrumentalists practice _less_ than those who are not as elite 
10:51:50 <dminuoso> ddellacosta: I guess learning efficiently is rather important too. :)
10:51:56 <dminuoso> So learning how to learn is key.
10:52:00 <ddellacosta> yeah I guess that's the takeaway
10:53:28 <hpyCdr> dminuoso, thoughts on the acid issue(s)?
10:53:30 <DigitalKiwi> i wonder how much family wealth and social status comes into it
10:53:39 <ddellacosta> yeah there's that too
10:53:55 <ddellacosta> but now I feel like we are definitely in the #haskell-offtopic realm
11:03:06 <cjay-> I wonder why Foreign.Marshal.Array converts between C arrays and Haskell lists, instead of Haskell arrays
11:03:37 <cjay-> is there any chance that the intermediate list gets optimized out in a combination of peekArray and pokeArray?
11:03:49 <cjay-> I suppose not, because of IO
11:04:25 <Solonarv> cjay-: there aren't any arrays in base, so the FFI stuff in there certainly can't use them
11:05:46 <cjay-> poor base :/
11:06:30 <cjay-> is there a lib to make FFI with actual arrays?
11:06:45 <Solonarv> sure, both 'array' and 'vector' let you do that
11:10:05 <Solonarv> the functions you want are in Data.Array.Storable + Data.Array.MArray for 'array', or Data.Vector.Storable.Mutable for 'vector'
11:10:28 <cjay-> thanks
11:15:35 <Cale> hpyCdr: hmm, having read through that thread, it doesn't sound like the end of the world? If you interrupt your server while it's in the middle of appending to the transaction log, sometimes that makes the last entry in the log unreadable because it's not distinguishable from a file that was incompletely copied from elsewhere. They could probably stand to make it easier to write programs that wait for the write to be complete before 
11:15:35 <Cale> terminating due to user input, though that wouldn't fix the case of a power outage or something. They could also make it more straightforward to ignore truncation.
11:17:15 <Cale> hpyCdr: In any case, it's not like all your data is gone or something.
11:17:55 <hpyCdr> I read it like the read would fail completely
11:17:58 <hpyCdr> let me double check
11:18:42 <Cale> Yeah, the read fails, but that's just because there's truncated garbage at the end of the file that was partially written when you killed the server in the middle of a write
11:20:13 <Cale> It would be possible to ignore the error, which is a somewhat reasonable thing to do, in this case. It's just hard to know that it's the right thing to do.
11:21:24 <Cale> Now, what I'm not sure about is whether they currently give you an easy way to do that
11:21:37 <Cale> But in principle, there's nothing so difficult about it
11:22:36 <wolfman154> import XMonad is throwing an error when I do xmonad—recompile?
11:24:18 <wolfman154> This is in xmonad.hs
11:24:59 <wolfman154> I tried the xmonad irc but no one is there 
11:25:10 <Cale> What error?
11:25:32 <Cale> (maybe put the error and your xmonad.hs into a gist or something)
11:28:29 <Mrbuck> Hi
11:28:42 <wolfman154> Http://hastebin.com/uzamijopop.sql
11:28:59 <wolfman154> Cale: here’s the link 
11:30:04 <wolfman154> Cale: you might have to make the http lower case, I typed it on my phone 
11:32:38 <hpyCdr> Cale, seems like it could only be resolved within acid state? since it's gonna error on me. There seem to be some good proposals / forks but none got merged, hm  :/
11:32:40 <Cale> huh, odd
11:33:45 <wolfman154> https://hastening.com/uzamijopop.sql    Why is xmonad throwing this error?
11:33:46 <Cale> wolfman154: I'm not an XMonad user, so I don't know what would cause this, but that means that the xmonad package isn't being included as a dependency
11:34:23 <Cale> I would have expected xmonad itself to give the appropriate package flag to GHC
11:34:59 <Cale> hpyCdr: There's probably some things which could be done to make the user experience better here, I agree.
11:35:06 <reallymemorable> whats the best function to go from [Char] -> [String]?
11:35:08 <wolfman154> Cale: in xmonad irc no one is there so I am trying here 
11:35:11 <reallymemorable> I fmap something in right?
11:35:40 <Cale> reallymemorable: What do you want that function to do?
11:35:49 <Cale> (:[]) is such a function
11:36:12 <reallymemorable> fmap (:[]) somethingThatIsListOfChars
11:36:15 <reallymemorable> like that?
11:36:16 <Cale> no
11:36:28 <Cale> [Char] = String
11:36:44 <reallymemorable> <interactive>:22:33: error:
11:36:44 <reallymemorable>     • Couldn't match type ‘Char’ with ‘[Char]’
11:36:44 <reallymemorable>       Expected type: [String]
11:36:44 <reallymemorable>         Actual type: [Char]
11:36:46 <Cale> So really you're looking at [Char] -> [[Char]]
11:36:48 <Solonarv> note that '[Char]' is the same thing as 'String', so perhaps it would be a good idea to ask about functions going from [Char] -> [[Char]]; or String -> [String]
11:36:52 <reallymemorable> I'm trying to deal with that error
11:37:02 <Cale> Yeah, but which list of strings do you want?
11:37:09 <Cale> Don't think about it only on the type level
11:37:11 <reallymemorable> Sorry, I don't understand the question
11:37:18 <Cale> You have *a* string
11:37:21 <reallymemorable> yes
11:37:22 <Cale> and you need a *list* of strings
11:37:29 <Cale> Do you want [myString] ?
11:37:51 <reallymemorable> I will try it.  Doesn't show results on Hoogle: https://hoogle.haskell.org/?hoogle=myString
11:37:53 <Cale> It's not obvious, without knowing what the list of strings means
11:38:02 <Cale> myString just being the String that you have.
11:38:04 <Solonarv> there are many ways to do this:
11:38:04 <Solonarv> @let mystr = "a test string"
11:38:05 <lambdabot>  Defined.
11:38:08 <reallymemorable> the list of strings is a list of URLs
11:38:16 <Cale> and you have a single URL?
11:38:46 <Cale> Or do you have many URLs and you want a single one?
11:39:00 <reallymemorable> https://gist.github.com/reallymemorable/2126b8348283b1a6c0eac73a87034cf9
11:39:05 <reallymemorable> this is what im trying to deal with
11:39:38 <Cale> haha, you really like parens
11:39:56 <reallymemorable> im super new to this
11:40:04 <o1lo01ol1o> reallymemorable: This is not Lisp.
11:40:05 <reallymemorable> and have been experimenting like a mad man
11:40:06 <Cale> an important rule to keep in mind is that whitespace binds tighter than any infix operator
11:40:13 <Cale> So  f x ++ g y
11:40:13 <ddellacosta> eatChunks <- my favorite function name so far today
11:40:20 <Cale> always means (f x) ++ (g y)
11:40:42 <Cale> (no matter if it's ++ or any other infix operator)
11:40:49 <reallymemorable> ddellacosta: I also have `wtf` in there
11:40:54 <Cale> also, it's never necessary to put parens around a single symbol
11:40:58 <ddellacosta> reallymemorable: I just saw that too :-D
11:41:01 <Cale> (5) doesn't mean anything different from 5
11:41:08 <reallymemorable> got it
11:41:20 <Cale> and (show chunkLinks) doesn't mean anything different from ((show chunkLinks))
11:41:42 <reallymemorable> yeah that was an artefact from when i tried other stuff
11:41:47 <Cale> But it doesn't look like chunkLinks is a list
11:41:56 <Cale> If it's the thing you defined above
11:41:58 <reallymemorable> its a list of list of strings
11:42:01 <Cale> no
11:42:07 <Cale> It's not a list of list of strings either
11:42:18 <o1lo01ol1o> chunkLinks :: IO [[String]]
11:42:25 <Cale> It's an IO action, which if you were to run it, it would give you a list of lists of strings each time.
11:42:47 <Cale> You can't apply take 5 to that
11:42:55 <Cale> because it's not a list
11:43:00 <reallymemorable> hmm
11:43:08 <reallymemorable> i wonder why the compiler didnt throw an error on that
11:43:15 <Cale> It really should.
11:43:26 <reallymemorable> so i should change the signature for chunkLinks?
11:43:30 <Cale> no
11:43:33 <Cale> probably not
11:43:37 <reallymemorable> fmap into IO?
11:43:44 <Cale> I don't know what filterNonGz is
11:43:57 <Cale> but if it does I/O, it's probably meant to be an IO action
11:44:04 <reallymemorable> filterNonGz returns a list of list of strings
11:44:11 <Cale> You probably just want to run chunkLinks
11:44:13 <reallymemorable> sorry no
11:44:14 <reallymemorable> filterNonGz :: IO [String]  
11:44:20 <Cale> yeah, does it do IO?
11:44:28 <Cale> Or is it spuriously an IO action?
11:44:56 <Cale> If it actually does any I/O, that's a fine type
11:44:57 <reallymemorable> https://gist.github.com/reallymemorable/babea81f8e3e1e17e083f43521fc1fc7
11:45:01 <reallymemorable> here is more of the code
11:45:44 <Cale> grabAllLinksFromWebPage
11:45:49 <Cale> sounds enough like I/O to me
11:46:05 <reallymemorable> grabAllLinksFromWebPage :: String -> IO [Maybe [String]]
11:46:05 <reallymemorable> grabAllLinksFromWebPage linkForScrape = do 
11:46:05 <reallymemorable>     (thing :: [String]) <- fmap concat $ scrapeURL linkForScrape $ concat <$> allLinks2
11:46:08 <reallymemorable>     return $ (flip scrapeStringLike (innerHTMLs "a")) <$> thing
11:46:16 <Cale> So, yeah, it's actually hitting the web for stuff
11:46:22 <Cale> Good enough
11:46:51 <Cale> So you probably just wanted to run that
11:47:05 <Cale> links <- filterNonGz
11:47:26 <Cale> (well, I'm not sure if more of the work of filterNonGz should be pared away... its name is weird)
11:47:44 <reallymemorable> there are some links that get picked up that i dont want
11:47:45 <Cale> but whatever
11:47:51 <reallymemorable> and i filter out the ones that dont end in gz
11:48:13 <Cale> It should have a name like  getGZipLinks
11:48:17 <Cale> or something
11:48:20 <reallymemorable> yeah
11:48:22 <reallymemorable> true
11:48:38 <Cale> It's an action, which if you run it, will go read some web pages, and extract gzip links from them
11:48:47 <reallymemorable> no
11:48:51 <Cale> yes
11:48:52 <reallymemorable> that action happens previously
11:48:54 <Cale> Nope
11:48:55 <reallymemorable> producing a list
11:48:57 <Cale> Nope
11:49:01 <reallymemorable> oh
11:49:02 <Cale> Look at its type
11:49:06 <Cale> IO [String]
11:49:13 <reallymemorable> ok yeah
11:49:14 <reallymemorable> youre right
11:49:17 <Cale> It's an IO action, which, if you were to run it, would produce a list of Strings
11:49:35 <reallymemorable> yeah
11:50:20 <Cale> That IO action, in turn, runs iterateThruLinks
11:50:28 <Cale> and then just modifies its result
11:50:33 <reallymemorable> got it
11:51:32 <Cale> So probably chunkLinks isn't something you really want to define separately, it can just be part of eatChunks or whatever
11:51:48 <Cale> You just want to be sure to first *run* filterNonGz
11:51:55 <Cale> (which you might want to choose a different name for)
11:52:13 <Cale> and then transform its *result*, which will be a list of Strings
11:52:24 <reallymemorable> why can't i just fmap take 5
11:52:32 <reallymemorable> over chunkLinks
11:52:36 <Cale> You could
11:52:43 <Cale> fmap (take 5)
11:52:48 <reallymemorable> https://gist.github.com/reallymemorable/386d8d6a425af5442a0364fb436b1457
11:53:02 <Cale> But if anything is confusing to you right now, I'd say just stick to do-notation.
11:53:38 <reallymemorable> ok
11:53:49 <Cale> So you'd have
11:54:14 <Cale> Well, let's just write this thing in one go, starting from iterateThruLinks
11:54:26 <Cale> do links <- iterateThruLinks
11:54:47 <Cale>    let gzipLinks = filter (endsInGz links)
11:55:11 <Cale>        chunks = chunksOf 10 gzipLinks
11:55:26 <Cale>    forM chunks $ \chunk -> do
11:55:48 <Cale> Well, I don't know what we're actually trying to do here ...
11:56:03 <tuhensossim> hello there! i am working on a programming assignment i will get input like "1-i, 2+5i" how can a turn them to [[(1:+1),(2:+5)]]
11:56:12 <Cale> oh, right, you want this to be concurrent
11:56:21 <Cale> So forConcurrently in place of forM
11:56:33 <tuhensossim> actually wrote a function that getComplex [a,b] = (a:+b) but dont know how to play with inputs
11:56:44 <bjs> tuhensossim: what have you got so far?
11:56:47 <Cale> and then you can just forM over the chunk and download each of the links
11:57:07 * hackage reflex 0.6.1 - Higher-order Functional Reactive Programming  https://hackage.haskell.org/package/reflex-0.6.1 (abrar)
11:57:20 <reallymemorable> ok thanks -- i pasted what you wrote in a text editor and will work through it
11:57:23 <Cale> tuhensossim: That's not entirely straightforward, you'd have to write a parser.
11:57:56 <tuhensossim> so parser is the thing that i need to search?
11:57:58 <Cale> tuhensossim: Is that the point of the assignment?
11:58:04 <Cale> What does the assignment say?
11:58:21 <tuhensossim> no it is actually getting complex numbers and making some unitary transformations on them
11:58:29 <tuhensossim> quantum computing course assignment
11:58:35 <tuhensossim> i defined the quantum gates
11:58:47 <Cale> Oh, I see
11:58:49 <tuhensossim> but don't have any idea about working with inputs
11:59:07 <Cale> Are the inputs to your program in a specified format?
11:59:20 <tuhensossim> yes
11:59:34 <Cale> Right, so we really will have to parse them, I suppose.
11:59:36 <tuhensossim> on the example program
11:59:40 <tuhensossim> first line looks like this
11:59:52 <tuhensossim> Enter the amplitudes of the initial state: 1-i, 2+5i
12:00:01 <tuhensossim> 1 qubit system
12:00:32 <tuhensossim> so i guess inputs will be like "1-i, 2+5i"
12:01:07 * hackage fused-effects 0.2.0.2 - A fast, flexible, fused effect system.  https://hackage.haskell.org/package/fused-effects-0.2.0.2 (robrix)
12:03:17 <bjs> tuhensossim: if the inputs are uniform enough then you might not need a crazy parser, but just some simple hackery (with read and some pattern matching). 
12:04:56 <tuhensossim> the thing confused me is input might be 0,1 maybe or with just i's maybe or even - and + sign in between real and imaginary part
12:05:05 <tuhensossim> am i going in the right direction?
12:05:44 <tuhensossim> so pattern match and read should depend on those cases?
12:06:43 <Solonarv> ehhh, actually I think mucking about with read and pattern matching would be an exercise in frustration here
12:07:14 <kadoban> It seems possible, but annoying. I'd probably reach for an actual parser combinator thing, like megaparsec.
12:07:40 <Solonarv> yep, I was going to recommend that one too
12:08:15 <indomitable> Megaparsec is a measure of distance, dammit!
12:08:45 <Rembane> But you can still do the Kessler run in under fifteen Parsec.
12:08:51 <o1lo01ol1o> Yea, I'd just go with megaparsec, you'll save lots of headache on stupid stuff.
12:09:30 <lyxia> Haskell is a name, and Curry is a sauce!
12:09:48 <o1lo01ol1o> The tutorials are fairly good; plus, parsers are funnnn with haskell-sauce
12:10:12 <Taneb> lyxia: I don't know if I've ever met anyone called Haskell
12:10:19 <tuhensossim> thank you for keywords to search
12:10:21 <indomitable> lyxia, A delicious sauce
12:10:39 <indomitable> Taneb, You should seek them out, and make them love Haskell
12:10:46 <indomitable> So that they both love themselves and the language
12:11:11 <Solonarv_> @hackage megaparsec
12:11:11 <lambdabot> http://hackage.haskell.org/package/megaparsec
12:11:40 <tuhensossim> :')
12:33:02 <pezubi> Hey guys :D
12:34:49 <pezubi> Hello?
12:34:58 <Cale> hi
12:35:38 * pezubi waves hello
12:35:54 <pezubi> Is there anyone, who could help me?
12:36:05 <Cale> Not if they don't know what you need help with
12:36:53 <reallymemorable> I'm hitting some weird character encoding issue
12:36:54 <reallymemorable> https://gist.github.com/reallymemorable/38f6a022b59096ab72d6fff6e19d3da3
12:37:14 <reallymemorable> the `/` in my URLs are initially fine but somewhere they are not getting escaped properly
12:38:35 <pezubi> That's my issue: https://pastebin.com/1sfkH1TA
12:39:12 <pezubi> I don't know how to handle the output of the function 'bmi'
12:39:23 <Cale> pezubi: I can spot one bug in this...
12:39:37 <Cale> > all (`elem` "0123456789") ""
12:39:38 <lambdabot>  True
12:39:44 <Cale> > read "" :: Int
12:39:46 <lambdabot>  *Exception: Prelude.read: no parse
12:40:07 <Cale> You might want to use readMaybe from Text.Read
12:40:16 <Cale> > readMaybe ""
12:40:18 <lambdabot>  Nothing
12:40:20 <Cale> > readMaybe "" :: Maybe Int
12:40:22 <lambdabot>  Nothing
12:40:24 <Cale> > readMaybe "43" :: Maybe Int
12:40:27 <lambdabot>  Just 43
12:41:38 <pezubi> where do I have to put this?
12:41:39 <Cale> pezubi: Since bmi takes an Integer (or an Int, I suppose?) and produces a Double or Float, you'll need to convert the Int to Double or Float or whatever it is that you're trying to deal with
12:41:54 <pezubi> I am just very new to Haskell so sorry for my 'dumbness'
12:42:11 <Cale> You could write:
12:42:34 <Cale> parseString :: String -> Int
12:42:42 <Cale> parseString x = case readMaybe x of
12:42:47 <Cale>   Just n -> n
12:42:49 <Cale>   Nothing -> 0
12:43:34 <Cale> (Of course, in a real program, if parsing failed you might prefer to tell the user that you didn't understand them rather than assuming they meant 0, but whatever)
12:44:10 <Cale> oh, another mistake you're making
12:44:21 <pezubi> yes, you're right, but this part came from my teacher
12:44:35 <Cale> bmi (ge ho)  means "apply the function ge to the value ho, and then apply bmi to the result"
12:44:40 <Cale> but here, ge isn't a function
12:44:51 <Cale> You probably meant to write bmi ge hi
12:45:00 <Cale> bmi ge ho
12:45:01 <Cale> rather
12:45:49 <pezubi> That's the error:
12:46:40 <pezubi> D:\\haskell\HA\BMI.hs:5:22: error:
12:46:40 <pezubi>     Variable not in scope: readMaybe :: String -> Maybe Int
12:46:51 <Cale> import Text.Read
12:46:54 <pezubi>   |
12:46:54 <pezubi> 5 | parseString x = case readMaybe x of
12:46:54 <pezubi>   |                      ^^^^^^^^^
12:46:56 <Cale> at the top of your file
12:47:23 <Cale> another option would be to use "reads" which is in the Prelude, but its type is a little more confusing
12:48:33 <pezubi> D:\\haskell\HA\BMI.hs:19:37: error:
12:48:33 <pezubi>     * Couldn't match expected type `[Char]' with actual type `Int'
12:48:34 <pezubi>     * In the first argument of `(++)', namely `bmi ge ho'
12:48:34 <pezubi>       In the second argument of `(++)', namely `bmi ge ho ++ ""'
12:48:34 <pezubi>       In the first argument of `putStrLn', namely
12:48:36 <pezubi>         `("Dein BMI beträgt: " ++ bmi ge ho ++ "")'
12:48:38 <pezubi>    |
12:48:40 <pezubi> 19 |   putStrLn ("Dein BMI beträgt: " ++ bmi ge ho ++ "")
12:48:42 <pezubi>    |                                     ^^^^^^^^^
12:49:33 <Cale> So, right, bmi is going to give you some sort of number
12:49:45 <Cale> you're going to want to apply show to the result of that
12:49:58 <Cale> in order to get a String
12:50:13 <Cale> However, we should decide what sort of number BMI gives
12:50:24 <pezubi> it might be a float
12:50:25 <tabaqui> Either String is not an instance of MonadFail
12:50:26 <tabaqui> hmm
12:50:30 <Cale> yeah
12:50:37 <Cale> So, bmi :: Int -> Int -> Float
12:50:39 <Cale> would be reasonable
12:50:48 <pezubi> eg : 25.737081414967538
12:51:02 <Cale> Or we could decide that the inputs were floats as well, and change what type parseString was parsing
12:51:13 <Cale> (or Doubles, might as well use Double)
12:52:02 <Cale> If we want to go with Int -> Int -> Float, that would mean that we need to use fromIntegral to convert the numbers before dividing
12:52:07 * hackage fused-effects 0.3.0.0 - A fast, flexible, fused effect system.  https://hackage.haskell.org/package/fused-effects-0.3.0.0 (robrix)
12:52:09 <Cale> (/) requires numbers of a fractional type
12:52:20 <Cale> Integer division in Haskell is called  div
12:52:26 <Cale> > div 10 4
12:52:28 <lambdabot>  2
12:52:37 <Cale> > 10 / 4
12:52:38 <lambdabot>  2.5
12:52:49 <Cale> :t div
12:52:50 <lambdabot> Integral a => a -> a -> a
12:52:53 <Cale> :t (/)
12:52:54 <lambdabot> Fractional a => a -> a -> a
12:53:04 <Cale> There aren't any types which are both Integral and Fractional
12:53:43 <Cale> But either way, these both take two numbers of the same type, and produce a result of that same type
12:53:46 <tabaqui> becuase Integral is an Euclidean ring?
12:53:53 <Cale> yeah, pretty much
12:54:21 <tabaqui> *because
12:54:35 <Cale> Haskell never does implicit *conversion* of numbers
12:54:50 <Cale> But numeric literals are polymorphic
12:54:52 <Cale> :t 5
12:54:53 <lambdabot> Num p => p
12:55:01 <Cale> ^^ this could be specialised to any type of number at all
12:55:08 <Cale> > 5 :: Integer
12:55:10 <lambdabot>  5
12:55:15 <Cale> > 5 :: Double
12:55:17 <lambdabot>  5.0
12:55:22 <Cale> > 5 :: Complex Double
12:55:24 <lambdabot>  5.0 :+ 0.0
12:55:56 <Cale> The two most important functions for converting between types of numbers are fromIntegral:
12:55:59 <Cale> :t fromIntegral
12:56:01 <lambdabot> (Num b, Integral a) => a -> b
12:56:12 <Cale> which converts from any integer-like type to any type of number
12:56:19 <Cale> and realToFrac
12:56:24 <Cale> :t realToFrac
12:56:25 <lambdabot> (Fractional b, Real a) => a -> b
12:56:48 <Cale> which converts from a non-complex (i.e. "real") numerical type to any fractional type
12:57:13 <Cale> It's not entirely cromulent conceptually, but very useful in practice :)
12:58:41 <Cale> (e.g. if you were converting from computable real numbers to rationals, the type of realToFrac means you have to round things to some unmentioned precision...)
13:00:26 <pezubi> got it...
13:01:04 <pezubi> That was my fault: "parseString :: String -> Float "
13:01:22 <pezubi> I just wrote "Int" instead of "Float"
13:02:33 <pezubi> Thank u a lot!
13:10:19 <reallymemorable> Someone on Slack mentioned that my problem described in the link is because my "hostname has a path mashed into it, causing an NXDOMAIN from DNS", but they signed off before they could tell me how to resolve it.  Does anyone here have an idea? https://stackoverflow.com/questions/55405735/hitting-weird-character-encoding-issue-with-haskells-req-web-scraping-library
13:47:47 <adetokunbo> hello
13:47:58 <Cale> hi
13:53:37 * hackage stern-brocot 0.1.0.0 - Positive rational numbers represented as paths in the Stern-Brocot tree  https://hackage.haskell.org/package/stern-brocot-0.1.0.0 (MatthewFarkasDyck)
13:54:38 <adetokunbo> I have a question about newtyping a monad stack
13:56:19 <Cale> adetokunbo: You should just go ahead and ask :D
13:56:26 <adetokunbo> I start with `type MultiReader  = ReaderT Outer (ReaderT Inner) IO`
13:56:38 <Cale> Yeah, that's awkward
13:56:40 <adetokunbo> Cale: thanks!
13:56:53 <Cale> (but also your parens seem off)
13:57:41 <adetokunbo> oh sorry:  `type MultiReader = ReaderT Outer (ReaderT Inner IO)`
13:57:47 <Cale> If you're going to be doing something like that, what I'd recommend is to use a newtype around ReaderT itself to define yourself a new monad transformer
13:58:34 <Cale> and then give it its own MonadInner or whatever typeclass which has operations that correspond to having that Inner environment
13:58:42 <adetokunbo> Cale: both ReaderTs or just the inner one?
13:58:49 <Cale> Quite possibly both
13:59:14 <Cale> I try not to use ReaderT directly, but instead use it to get hold of operations that I want
13:59:30 <Cale> Another option would be to use ReaderT (Outer, Inner) IO
13:59:47 <Cale> and then implement operations which select things from that pair
14:00:06 <Cale> Ideally, the users of your monad shouldn't need to know or care that you used ReaderT
14:00:07 <adetokunbo> Cale: thanks - I will give both ideas a try!
14:00:12 <Cale> and shouldn't care about MonadReader
14:02:07 * hackage aeson-gadt-th 0.2.0.0 - Derivation of Aeson instances for GADTs  https://hackage.haskell.org/package/aeson-gadt-th-0.2.0.0 (abrar)
14:02:29 <adetokunbo> Cale: when trying the first approach, in order to make the newtyped ReaderT compose properly, I suppose I'll need to make instances of the other MTL monads ?
14:26:58 <v0d1ch> phadej: does your lib github provide a way to push a repo ?
14:29:31 <v0d1ch> erm create a repository I mean
14:29:58 <v0d1ch> oh think this is it `https://hackage.haskell.org/package/github-0.20/docs/GitHub-Endpoints-Repos.html#v:createOrganizationRepoR`
14:52:41 <one2three4five> I'm using stack for a project that makes use of the foreign function interface. I have one file which has #include <my_file.h>, which stack can't seem to find unless i give it the direct path to the file, i.e #include</home/foldrs/src/my_file.h>
14:52:55 <one2three4five> is there some config I'm missing to help stack find my header files?
14:53:37 <Solonarv_> one2three4five: 'extra-include-dirs' in blah.cabal
14:54:08 <Solonarv_> I'm pretty sure there's a corresponding field you can add to package.yaml too
14:55:30 <one2three4five> i've seen extra-include-dirs thrown around on various websites, but stack doesn't recognize it
14:55:53 <Solonarv_> where are you putting it?
14:56:11 <one2three4five> the header file is in the same folder as my .hsc file, the src folder
14:58:47 <Solonarv_> no, I mean the 'extra-include-dirs' entry
15:00:56 <one2three4five> oh in package.yaml i've tried putting it at the op level or in the libraries section but either way it gives me an warning about not recognizing it
15:01:43 <Solonarv_> hm, I'd actually recommend ditching package.yaml
15:02:06 <Solonarv_> it's just a thin front-end over blah.cabal
15:02:16 <Cale> adetokunbo: You only need to make lifting instances for MTL classes as you find that you need them
15:03:12 <Cale> adetokunbo: What's more important is making instances of your type class for other monad transformers that you use.
15:03:32 <one2three4five> i'll try doing the .cabal file and see if that works
15:04:08 <Solonarv_> you can simply run 'stack build' and then delete package.yaml
15:04:26 <Solonarv_> (or rename it to something like 'package.yaml.old')
15:05:21 <one2three4five> i put the extra-include-dirs in the .cabal file and it still didn't recognize it
15:05:33 <adetokunbo> Cale: thanks, that's good to know
15:07:19 <Solonarv_> one2three4five: what's the output of 'stack --version' ?
15:07:48 <one2three4five> this is the full output: Version 1.7.1, Git revision 681c800873816c022739ca7ed14755e85a579565 (5807 commits) x86_64 hpack-0.28.2
15:08:20 <Solonarv_> hm, I think extra-include-dirs is fairly new
15:08:39 <Solonarv_> try running 'stack upgrade' to update to the latest version
15:09:02 <glguy> one2three4five: Are you using <> or "" for including local headers?
15:09:28 <one2three4five> i've tried both with the same results.
15:10:00 <bbear> hello
15:10:02 <Solonarv_> hm I think you're supposed to use "" for local headers
15:10:16 * Solonarv_ doesn't actually have any experience withthis
15:10:29 <bbear> Let say I have a function f :: a ->b -> c
15:10:37 <adetokunbo> Cale: I'm not sure how to implement operations in my monad which rely on Reader operations without deriving MonadReader on my newtype
15:11:03 <bbear> I want to create a function g :: b -> c that combine the results of f for several arguments of type a.
15:11:07 <bbear> How would you do that ?
15:11:35 <one2three4five> do you have any way to combine `c`
15:11:42 <bbear> for example g x = (f 1 x) + 3 * (f 2 x)
15:11:51 <bbear> how would you do to avoid repeating x ?
15:11:59 <Cale> adetokunbo: something like   query q = DatabaseT $ do conn <- ask; liftIO $ queryConn conn q
15:12:15 <bbear> one2three4five: yes let's assume it's some kind of algebra
15:12:21 <Cale> adetokunbo: One you're underneath your newtype's data constructor, you're just back to writing a ReaderT action
15:12:24 <bbear> you got teh idea
15:13:06 <one2three4five> Solonarv_: I'm going to try updating stack and see if I get any results
15:13:15 <adetokunbo> Cale: thank you, that's the bit I was missing :)
15:13:17 <Cale> bbear: I'm not sure what you mean "avoid repeating x"
15:13:24 <one2three4five> bbear: pointfree.io gives `g = ap ((+) . f 1) ((3 *) . f 2)`, so make what you will of that
15:13:31 <Cale> bbear: Can you give an example closer to the actual program you're trying to write?
15:14:57 <bbear> Cale: http://vpaste.net/lhe4h
15:15:02 <bbear> but one2three4fiveanswered
15:15:11 <bbear> though the syntax is awkward
15:15:35 <Cale> > let f x y = y*x in (do v <- f 1; w <- f 2; return (v + 3 * w)) 100
15:15:37 <lambdabot>  700
15:15:49 <Cale> > let f x y = y+x in (do v <- f 1; w <- f 2; return (v + 3 * w)) 100
15:15:51 <lambdabot>  407
15:16:16 <one2three4five> Solonarv_: upgraded to stack 1.9.3 and extra-include-dirs is still unrecognized
15:16:21 <Cale> but yeah, what you have there in that program looks pretty sensible
15:16:32 <bbear> ok, couldn't it be done with some kind of operator ?
15:16:39 <Cale> Except I would rewrite isDivisibleBy to have an additional argument
15:16:50 <Cale> You're just making it harder to read that way
15:17:03 <Cale> At least, in my opinion
15:17:14 <bbear> I don't understand
15:17:27 <Cale> isDivisibleBy n m = rem m n == 0
15:17:36 <Cale> Isn't that easier?
15:17:43 <bbear> ok you would invert the stuff
15:17:46 <bbear> the arguments 
15:17:55 <Cale> No, that's the same convention you have
15:17:56 <bbear> yes it would make more sense
15:18:08 <Cale> It's just I got rid of the flip
15:18:19 <bbear> yes
15:18:27 <Cale> and I'm not awkwardly trying to avoid mentioning the second argument of the function
15:18:40 <bbear> ha yes linter somehow do suggest that
15:18:41 <Cale> Sometimes points-free is nicer, and this isn't one of those times
15:18:56 <Cale> Don't listen to everything the linter says, it's insane
15:19:39 <monochrom> Yeah, C's lint is widely agreed upon by the C community, but hlint is more personal.
15:20:20 <Solonarv_> anecdotally, I strongly prefer (`func` x) over (flip func x)
15:20:32 <monochrom> Plus, C's lint is good for both beginners and professionals, but hlint can be anti-beginner.
15:20:39 <Solonarv_> especially for functions like `rem` which are often used infix anyway
15:20:58 <Rembane> I love it when hlint obfuscates my code.
15:21:23 <Solonarv_> so if I wanted to be less pointful I might write: isDivisibleBy n = (==0) . (`rem` n)
15:22:01 <monochrom> Yeah, me too, `rem` is infix, I don't care it's alphabetical. :)
15:22:17 <one2three4five> Solonarv_: extra-include-dirs is mentioned in stack's source code on github, at least
15:23:32 <one2three4five> and i'm theoretically on the most up to date version of stack, so i'm not sure what's up at this point
15:23:57 <Solonarv_> try seeing if it's mentioned in the docs, I guess
15:24:02 <Solonarv_> haskellstack.readthedocs.io
15:27:56 <one2three4five> by all accounts extra-include-dirs appears to be part of stack, according to documentation
15:29:20 <mpickering> dmwit: Another version of my problem for you today. My keys are filepaths [foo/, bar/, baz/] => 1. When I do a lookup, I want to find the "best" match for a key; for example "foo/qux" matches foo/ and returns Just 1
15:29:41 <mpickering> [foo/bar] => 2 [foo/] => 1 lookup "foo/bar/baz" => Just 2
15:30:17 <monochrom> Is there ever a no-match?
15:30:42 <mpickering> yes
15:31:55 <kadoban> How are we defining "best" ? So far it mostly seems to be picking the longest prefix that matches
15:32:38 <mpickering> yes longest prefix
15:32:52 <kadoban> Oh. Then use a trie
15:33:12 <monochrom> Nice
15:33:25 <mpickering> which package provides the best trie?
15:33:31 <monochrom> I made my students code up tries for homework.
15:33:48 <mpickering> the students I teach probably do as well
15:33:55 <monochrom> Actually just deletion. Enough to give them headaches.
15:34:13 <c_wraith> I just wrote up something using a trie. I used Cofree (Map Char). don't be like me. use something efficient.
15:34:26 <monochrom> A lot of them ended up seriously XY-problemming it.
15:34:40 <monochrom> Haha
15:35:01 <monochrom> And they thought monadic parsing was hard.
15:35:20 <kadoban> I'm actually trying to do a trie in rust at the moment. It's not going terribly well.
15:36:08 <mpickering> my officemate is working on a parser combinator library which is orders of magnitude faster than any existing library
15:36:20 <mpickering> that's only applicative parsing though.. monadic parsing really is hard
15:36:46 <c_wraith> still, I don't of any trie library that suits my exact requirements.
15:37:02 <monochrom> Oh, I only asked them to understand String -> Maybe (String, a). No advanced CPS speedup advanced theory.
15:37:54 <monochrom> So it merely came down to "instance Monad Parser is hard". And here we freely bring up Cofree.
15:37:59 <Cale> Not even String -> [(String, a)]
15:38:32 <Cale> A parser for things is a function from strings, to lists of pairs of strings and things
15:38:59 <Cale> The Dr. Seuss parser
15:39:09 <mpickering> the denotation of this library is 6 different stacks, slightly faster, slightly more complicated
15:40:05 <c_wraith> see, I basically never think of Cofree as a theoretical thing. its Monad instance is terrifying to me. it's just "make this data structure contain itself and an annotation"
15:40:43 <monochrom> Ah, that sounds nicer.
15:42:02 <Rembane> c_wraith: how did you arrive at that? 
15:42:05 <monochrom> Should I take a nap now? Or should I start looking at Cofree?
15:42:18 <kadoban> Cale: Nice
15:42:33 <Rembane> monochrom: Nap! 
15:43:02 <monochrom> I'm wondering if "best of both worlds, take a look and fall asleep" will work...
15:43:19 <c_wraith> Rembane, I think is just started experimenting with applying it to lots of common types and seeing what I got back.
15:43:28 <c_wraith> *I just
15:44:15 <c_wraith> like, Cofree Identify is an infinite stream. Cofree Maybe is a non-empty list. Cofree [] is a rose tree
15:44:35 <Rembane> c_wraith: Nice! I think it shows up in recursion schemes too. 
15:44:37 <c_wraith> *Identity
15:44:57 <Rembane> monochrom: If your brain is well behaved that is the optimal course of action.
15:45:04 <c_wraith> and then I started experimenting with using it for game trees.
15:45:45 <c_wraith> because it turns out coiter transforms "what are legal next moves" into "here is the whole game tree"
15:46:10 <monochrom> Oh!  "x = a + f x" (free) vs "y = a * f y" (cofree).
15:46:33 <c_wraith> and I just got really comfortable it as a data structure in the process of building tic-tac-toe
15:46:37 <c_wraith> monochrom, yep
15:47:21 <Rembane> Does this mean that you get a rainbow table for tic-tac-toe?
15:47:46 <monochrom> Haha I gave game tree search as the second homework, and my hint was "code up legal next move, then it's easy to get the game tree".
15:49:02 <c_wraith> Rembane, https://gist.github.com/chowells79/dbc7c6df2af8f1e00aa6a037c1cfc3d8
15:49:45 <Rembane> c_wraith: Nice! I like the type on line 60. 
15:49:55 <monochrom> I don't think Cofree (Map Char) (Maybe a) is any less efficient than my solution.
15:50:06 <c_wraith> oh, that size function isn't necessary anymore. I got it added as the length instance for Cofree
15:50:12 <pie_> does anyone here know anything about how to call the frege compiler?
15:50:24 <c_wraith> err. length in the Foldable instance
15:50:34 <monochrom> I merely did "Trie a = (Maybe a) * Map Char (Trie a)"
15:51:16 <monochrom> But maybe you get to say that Map Char is too much overhead or something.
15:51:17 <c_wraith> oh, and telescoped_ also eventually made it into the free package
15:51:36 <monochrom> Oh haha I now get the rainbow joke. I think.
15:51:39 <c_wraith> monochrom, yeah, for something with so few entries (in my case) it was a lot of overhead
15:52:12 <monochrom> My motivation was "too lazy to code my own lookup over [(k,v)]"
15:54:38 <monochrom> OK time to go to class. See you later.
15:59:46 <ProofTechnique> reallymemorable: I answered your SO question
16:01:29 <bbear> what would be the more idiomatic way to filter a list with all numbers that are both <10 and >2 ?
16:01:41 <reallymemorable> thanks!
16:02:14 <reallymemorable> i actually just arrived at that solution
16:02:21 <reallymemorable> the parseUrlHttps
16:03:38 <ProofTechnique> bbear: filter ((&&) <$> (<10) <*> (>2))
16:04:22 <ProofTechnique> or filter (liftA2 (&&) (<10) (>2)), if you're counting characters
16:04:29 <bbear> ha yeah
16:04:36 <bbear> so what means the <*> ?
16:05:39 <ProofTechnique> :t (<*>)
16:05:40 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
16:06:08 <ProofTechnique> It's like `fmap`, except that the function you're mapping is in the same applicative context as the value you're mapping over
16:06:11 <bbear> : t  ((<10) <*> (>2))
16:06:22 <bbear> :t  ((<10) <*> (>2))
16:06:23 <ProofTechnique> https://mmhaskell.com/blog/2017/2/6/applicatives-one-step-further
16:06:24 <lambdabot> error:
16:06:24 <lambdabot>     • Couldn't match type ‘Bool’ with ‘Bool -> b’
16:06:24 <lambdabot>       Expected type: a -> Bool -> b
16:06:28 <bbear> why did it fail ?
16:07:07 <Rembane> :t (>)
16:07:08 <lambdabot> Ord a => a -> a -> Bool
16:07:11 <Rembane> :t (>2)
16:07:11 <lambdabot> (Num a, Ord a) => a -> Bool
16:07:33 <Rembane> I think that (>2) needs to be of type f b for it to not fail.
16:07:59 <bbear> should I use applicative or lift ?
16:08:52 <ProofTechnique> :t (&&) <$> (<10)
16:08:53 <lambdabot> (Num a, Ord a) => a -> Bool -> Bool
16:09:12 <ProofTechnique> :t (<*> (>2))
16:09:13 <lambdabot> (Num a, Ord a) => (a -> Bool -> b) -> a -> b
16:09:50 <Cale> bbear: If you really want, you can use liftM2 (&&) or whatever, but really, you probably want to define your own combinators if you're going that route
16:10:27 <ProofTechnique> liftA2 is really just a shortcut. I'd recommend the explicit operators until you're comfortable with applicatives
16:10:30 <bbear> I can't
16:10:33 <bbear> ok
16:10:43 <bbear> :t (<$>)
16:10:44 <lambdabot> Functor f => (a -> b) -> f a -> f b
16:10:46 <Cale> Yeah, don't struggle to make things points-free
16:10:54 <ProofTechnique> Also, note that (<$>) is just `fmap`
16:11:04 <bbear> infix version
16:11:14 <Cale> There's a reason why we have lambda and function parameters and stuff
16:11:34 <Cale> It's often easier to understand code which names the things it's working with
16:12:11 <Cale> Sometimes it's easier to understand when things are unnamed too, but if it's harder to write like that, it's also probably harder to read it.
16:12:26 <ProofTechnique> So you can write `fmap (&&) (<10) <*> (>2)`. You could also use a list comprehension like `[ x | x <- myList, x < 10, x > 2]`
16:12:37 <bbear> Cale, now to make the question more difficulte, how would you filter a list of elements for elements that are ((>3) and (<10)) or (multiple of 5)
16:13:10 <bbear> hA BUT I DIDN'T see the parenthesis
16:13:14 <bbear> really application order matters
16:13:20 <bbear> ok thanks
16:14:21 <ProofTechnique> [ x | x <- myList, x < 10 || x `mod` 5 == 0, x > 2 ]
16:14:35 <ProofTechnique> Oh, whoops, not that
16:17:45 <ProofTechnique> > filter ((||) <$> ((&&) <$> (<10) <*> (>3)) <*> ((== 0) . (`mod` 5))) [1..20]
16:17:47 <lambdabot>  [4,5,6,7,8,9,10,15,20]
16:17:56 <ProofTechnique> bbear: Like that?
16:18:59 <bbear> ho my
16:19:03 <bbear> it's horrid
16:19:31 <ProofTechnique> Or the equally awful
16:19:34 <ProofTechnique> > filter (liftA2 (||) (liftA2 (&&) (<10) (>3)) ((== 0) . (`mod` 5))) [1..20]
16:19:36 <lambdabot>  [4,5,6,7,8,9,10,15,20]
16:20:30 <bbear> no better suggestion for this function ?
16:20:41 <bbear> The a->Bool part
16:20:51 <Rembane> I think a list comprehension can clear up things. 
16:21:27 <Solonarv_> > filter (\x -> (x < 10 && x > 3) || x `mod``5) [1..20]
16:21:29 <lambdabot>  <hint>:1:43: error: parse error on input ‘`’
16:21:38 <Solonarv_> > filter (\x -> (x < 10 && x > 3) || x `mod` 5 == 0) [1..20]
16:21:40 <lambdabot>  [4,5,6,7,8,9,10,15,20]
16:21:46 <ProofTechnique> The lambda is definitely the nice way to do it
16:22:20 <Cale> Oh, where'd he go?
16:22:41 <Rembane> Internet took him.
16:22:48 <ProofTechnique> I pointfree'd eir brain into catatonia
16:58:44 <Axman6> Why are we trying to scare people off like that? I wouldn't call any of the answers to bbear's question idiomatic until the lambda after they left...
16:59:03 <Axman6> pointfree /= idiomatic
16:59:50 <jackdk> +1 Axman6
17:00:36 <glguy> The list comprehension is a fine solution while bbear was still in channel
17:00:41 <jackdk> er, I mean `head $ [(+)] <$> pure 1 <*> return Axman6`
17:02:38 <shapr> -- pure Cale: denotes the need to throw contract money at Cale for further improvements
17:03:11 <dibblego> omg it's shapr!!
17:03:27 <shapr> howdy dibblego! How's life?
17:03:35 <dibblego> bladdy alrite m8, how's you?
17:03:55 <shapr> pretty good, having fun with hedgehog
17:04:01 <dibblego> nice nice
17:04:03 <shapr> thinking of using it to test a bunch of work code
17:04:07 <dibblego> we use it a lot
17:04:36 <shapr> I was real stuck on a failing round trip test until I discovered my custom Show instance was obscuring the problem
17:04:45 <shapr> │ -         (1858 - 11 - 17) (00 : 00 : 00.000064) UTC
17:04:45 <shapr> │ +         (1858 - 11 - 17) (00 : 00 : 00) UTC
17:05:04 <shapr> I was displaying log line entries in the same format as they were being parsed
17:05:09 <shapr> props to dmwit and lyxia for help
17:05:11 <dibblego> I have had this problem, and the rule "only derive Show" seems to have prevented it from recurring
17:05:23 <shapr> yeah, agreed
17:05:47 <shapr> I never did get monadic QuickCheck figured out, but monadic hedgehog is easier than writing an Arbitrary instance
17:06:10 <dibblego> Well, a bunch of us whinged about QuickCheck for years, then somebody went and fixed it, and called it hedgehog
17:06:16 <shapr> yeah, I'm a fan
17:08:22 <shapr> I wonder if I could hook hedgehog up to one of the Haskell protobuf libs and find a bunch of exciting bugs?
17:17:38 <dibblego> probably, see also state machine testing with hedgehog
18:06:16 <dmwit> :t filter (inRange (3,9))
18:06:18 <lambdabot> (Num a, Ix a) => [a] -> [a]
18:08:11 <dmwit> Too bad I wasn't here at the right time.
18:13:06 <Solonarv_> I keep forgetting that Ix exists and that you're allowed to use it for something other than indexing Array
18:23:44 <habbah> how do you run a yesod app within RIO? https://gist.github.com/mcbahson/0e8e61e927a55c4eca00857c99bc397d
20:13:10 * hackage salak 0.1.11 - Configuration Loader  https://hackage.haskell.org/package/salak-0.1.11 (leptonyu)
20:14:07 * hackage salak 0.2.6 - Configuration Loader  https://hackage.haskell.org/package/salak-0.2.6 (leptonyu)
20:15:41 <Gurkenglas> In "t = sort [ m | bs@(a:_) <- tails n7s, m <- takeWhile (<= 11*last n7s) $ map (a*) bs]", the 'last' won't be shared between the tails, right?
20:17:37 * hackage hw-prim 0.6.2.23 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.6.2.23 (haskellworks)
20:29:07 * hackage yam-datasource 0.5.16 - Yam DataSource Middleware  https://hackage.haskell.org/package/yam-datasource-0.5.16 (leptonyu)
20:30:07 * hackage yam 0.5.16 - Yam Web  https://hackage.haskell.org/package/yam-0.5.16 (leptonyu)
20:38:53 <adamCS> f I am only using hashmap to do grouping, f :: (Hashable k, Eq k) => [(k, c)] -> [(k,[c])]; f = toList . fromListWith (<>) . fmap (second $ pure @[]), is there likely a better (faster) way? 
20:39:00 <adamCS> If
21:39:07 * hackage hw-bits 0.7.0.6 - Bit manipulation  https://hackage.haskell.org/package/hw-bits-0.7.0.6 (haskellworks)
22:22:19 <ongy> Cale: https://github.com/Ongy/netlink-hs/issues/5#issuecomment-475565191 <-- afaik netlink doesn't truncate but doesn't actually throw in the last datagram if there's not enough size. Also yes, recvOne was supposed to recv a single packet before, but of course that doesn't work without allocating a correctly sized buffer (where correctly sized is undetermined at compile time) so the uglyness that exists came to be. Honestly I want to redesign the entire 
23:00:38 * hackage QuickCheck 2.13.1 - Automatic testing of Haskell programs  https://hackage.haskell.org/package/QuickCheck-2.13.1 (NickSmallbone)
23:10:07 * hackage pidfile 0.1.0.4 - Run an IO action protected by a pidfile  https://hackage.haskell.org/package/pidfile-0.1.0.4 (petterb)
23:19:28 <dminuoso> x `foo` y = x + y
23:19:30 <dminuoso> % x `foo` y = x + y
23:19:30 <yahb> dminuoso: 
23:19:50 <dminuoso> Fancy, just learned that you could use `infix` notation for bindings too. :)
23:22:18 <ongy> Yea, but IMO it's only more readable for the operator kind of function names
23:22:48 <ongy> '(==) x y = ...' vs. 'x == y = ...'
23:23:25 <dminuoso> ongy: Just didn't know you could do this with ticks too. Just had this: x `comma` y = x <> ", " <> y
23:27:45 <dminuoso> Sadly I couldnt make some (<,>) operator.
23:30:38 <akr> dminuoso: by the way, you can also do that with data constructors (in case you didn't know)
23:31:17 <akr> data Tree a = Node (Tree a) (Tree a) | Leaf a
23:31:31 <akr> let ex = (Leaf 5) `Node` (Leaf 4)
23:38:06 <dminuoso> akr: Oh that's very nice as well. :)
23:39:50 <akr> huh, you can use it in the definition as well
23:39:53 <akr> data Tree a = (Tree a) `Node` (Tree a) | Leaf
23:39:56 <akr> I did not know this :)
23:40:46 <akr> and also apparently the derived Show instance then prints Node's in infix format
23:40:54 <dminuoso> No way.
23:41:13 <dminuoso> % data Quux = Int `Quux` Int deriving (Eq, Show)
23:41:13 <yahb> dminuoso: 
23:41:19 <dminuoso> % Quux 10 10
23:41:19 <yahb> dminuoso: 10 `Quux` 10
23:41:30 <dminuoso> This is lovely. :)
23:42:50 <akr> seems a bit magicky, but ok :)
23:43:07 <akr> maybe it's just some unintended consequence of how TH is used to generate the instance
23:44:12 <dminuoso> akr: I wonder whether the same holds true for operators
23:44:29 <dminuoso> % data Foo = (<||>) Int Int
23:44:29 <yahb> dminuoso: ; <interactive>:248:12: error: Not a data constructor: `<||>'
23:44:45 <dminuoso> % data Foo = (:>>) Int Int 
23:44:45 <yahb> dminuoso: 
23:45:01 <dminuoso> % data Foo = (:>>) Int Int deriving Show
23:45:01 <yahb> dminuoso: 
23:45:04 <dminuoso> % (:>>) 1 1 
23:45:04 <yahb> dminuoso: (:>>) 1 1
23:45:13 <dminuoso> % data Foo = Int :>> Int deriving Show
23:45:13 <yahb> dminuoso: 
23:45:15 <dminuoso> % (:>>) 1 1 
23:45:15 <yahb> dminuoso: 1 :>> 1
23:45:36 <dminuoso> akr: ^- this seems like it might be more intentional actually.
23:45:43 <akr> yeah, I agree
23:51:05 <dminuoso> How does one specify fixity for data operators?
23:51:43 <dminuoso> % infixr 6 :>>
23:51:43 <yahb> dminuoso: ; <interactive>:279:10: error:; The fixity signature for `:>>' lacks an accompanying binding; (The fixity signature must be given where `:>>' is declared)
23:57:55 <geekosaur> I think it inherits from the data constructor's fixity, and that can have a standard *fix declaration?
23:59:36 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#infix-type-constructors-classes-and-type-variables
23:59:40 <geekosaur> confirms
