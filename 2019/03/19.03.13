00:00:29 <xpika> has anyone made a library where you can chain function f $ g $ h but they execute on separate processors?
00:00:44 <xpika> or separate cores I should say
00:01:02 <c_wraith> that usually doesn't work well for chained computation
00:02:08 <c_wraith> Unless you've got a lazy data structure as the result of each, but that then puts you in real danger of being too strict accidentally and still taking longer to run.
00:03:05 <kadoban> A lot of the time it would work, you'd rather split it up a different way anyway I'd think. (like a list, you'd probably want to split into blocks per core)
00:04:05 <kadoban> I'm sure there's some library that would let you do it if you want to, but I question if it's a common enough use-case to have a nice name.
00:09:36 <c_wraith> for the closest thing to that which actually seems useful, there's https://hackage.haskell.org/package/speculation
00:10:18 <c_wraith> and it's useful specifically because it lets you guess your way past the linearity otherwise inherent
00:11:06 <kadoban> That's rather clever
00:11:39 <kadoban> Wonder how often something like that comes up.
00:11:56 <c_wraith> the paper probably describes a few cases
00:27:03 <xpika> i've found streamly on hackage which looks interesting...
00:28:38 <MarcelineVQ> it's pretty neat
00:28:44 <shachaf> Is there some recent change with how ghci loads ~/.ghci?
00:28:56 <shachaf> Or maybe with : commands in .ghci?
00:29:48 <shachaf> If I write a identifier it says it's out of scope, but it seems to be ignoring ":set prompt" lines and maybe other : lines.
00:30:35 <shachaf> This is GHC 8.6.3. If I make a file containing just ":set prompt ...", it seems to ignore it, when typing the same line into ghci works fine.
00:30:58 <shachaf> Wait, hmm, no.
00:31:10 <shachaf> It's... A problem with UTF-8?
00:32:29 <shachaf> I'm a bit confused about this.
00:32:42 <shachaf> Maybe it's a Nix issue.
00:34:10 <shachaf> Yep.
01:08:37 <delYsid> How does :doc in GHCi work, or, IOW, what do I need to do for docs to be available?
01:10:03 <dminuoso> I have about 120 attributes for which Im writing prisms like this: https://gist.github.com/dminuoso/400731088efa106b3be2918db1953571
01:10:24 <dminuoso> Should I consider using TH here? Or is there some lens utility that can generate these lenses for me?
01:10:31 <dminuoso> (Well. Prisms)
01:10:42 <dminuoso> Traversals in fact. :)
01:13:26 <[exa]> dminuoso: CPP macros?
01:13:29 <MarcelineVQ> oh my, that is painfully redundant isn't it
01:13:33 * [exa] ducks
01:14:43 <[exa]> anyway there should be a way that constructs this generically from the primitive attribute prisms
01:15:09 <dminuoso> MarcelineVQ: What can I say, I have this big bonking [PacketAttribute] list where PacketAttribute is one extraordinarily large sum type.
01:15:37 <[exa]> you can autogenerate prisms for the PacketAttr, right?
01:21:29 <dminuoso> [exa]: Yes.
01:26:19 <[exa]> dminuoso: what makes them unsuitable for being converted to the filtered traversal? (perhaps I missed something in the code)
01:28:43 <dminuoso> [exa]: Now knowing how to: `Prism' Attribute VSA -> Prism' [Attribute] VSA` using the "find the first" semantics?
01:29:22 <[exa]> oh you want prisms not traversals?
01:29:43 <dminuoso> [exa]: Mmm one moment.
01:29:57 <[exa]> btw there was something that was actually named 'first'
01:30:38 <dminuoso> [exa]: That actually depends. Here's the context: Some attributes must only appear once, other attributes might appear multiple times.
01:30:57 <dminuoso> So for some attributes a Prism' is sufficient, for others a Traversal' is needed.
01:31:26 <[exa]> distinguishing that typo-logically would probaby help a bit
01:31:35 <dminuoso> [exa]: What do you mean?
01:32:00 <[exa]> this way your code will need to repetitiously specify which one is a traversal and which one is a prism; you want something to avoid that
01:32:19 <[exa]> does the ordering of the values in the list matter?
01:32:30 <dminuoso> [exa]: No.
01:32:52 <[exa]> if not, I'd convert that to a big structure that contains tagged lists and maybes
01:33:12 <dminuoso> What is a tagged list?
01:33:39 <[exa]> like, Packet = SourceAddrs [a] | DestAddrs [b] | StatusTypes [c] ...
01:33:41 <dminuoso> [exa]: (Also note that because I compose that prism with a lens, I get a traversal either way - so it doesnt really matter in the end)
01:33:52 <dminuoso> (They all end up as Traversal')
01:34:32 <[exa]> I've got to go afk, sorry
01:34:49 <dminuoso> [exa]: Heh I was trying to avoid that by writing optics instead. :P
01:35:07 <[exa]> but my general feeling is that the data structure is a bit too loose to behave in such a precise manner :]
01:35:31 <[exa]> btw ping me if you find some good solution, /me interested
01:37:37 <mjrosenb> https://gist.github.com/mjrosenb/bb24d601a8e8a9f1ee061094c05cedf8
01:55:13 <mpickering> Does anyone know what the "dim" style does in vty?
01:55:45 <reygoch> Makes things dim?
01:55:50 <reygoch> Inactive?
01:57:34 <mpickering> What does "dim" mean? and how does it interact with other styling?
01:57:41 <mpickering> it doesn't seem to do anything for me
02:00:22 <mpickering> https://misc.flogisoft.com/bash/tip_colors_and_formatting
02:00:40 <mpickering> apparently it should do what I want but it seems my other styling makes the dim not do anything
02:03:06 <Ariakenom> mpickering: is it supported? https://misc.flogisoft.com/bash/tip_colors_and_formatting#terminals_compatibility
02:05:47 <tdammers> maybe it's a dark theme. reddit has decided that not having a dark theme is now unacceptable, effective March 1st 2019.
02:07:51 <Cale> mpickering: "dim" means "not shining brightly"
02:08:37 <Cale> mpickering: It's possible that your terminal doesn't support the control code? It seems to work in MATE Terminal (which is a fork of Gnome terminal) for me.
02:09:06 <Cale> oh, or I guess it's possible that it doesn't combine well with everything else.
02:09:46 <mpickering> ah apparently my terminal (rxvt) doesn't support it
02:10:38 <Ariakenom> seemed to be unsupported in many widely used ones
02:40:29 <andreabedini> anyone good with QuickCheck? I'm writing a shrink function for a data type but I can't get QuickCheck to shrink anything at all. Running verboseCheck with a bogus property finds a counterexample with no problem, but it doesn't seem to shrink it (numShrinks is aways 0)
02:41:34 <lyxia> andreabedini: how did you tell it to shrink
02:41:53 <Cale> Are you sure that one of the shrinks is a counterexample?
02:42:15 <andreabedini> lyxia: :sweat smile: do I need to tell it to shrink? :D
02:43:53 <andreabedini> if I take the counterxample and run shrink on it I get what I expect
02:44:38 <andreabedini> Cale: I am not sure I understand, I don't see any shrink attempt at all
02:48:15 <Cale> andreabedini: What I mean is, if you take the list of shrinks that you got from the counterexample, are any of them also counterexamples?
02:48:44 <Cale> andreabedini: That's what QuickCheck is going to try to do, and if none of them are also counterexamples, it will just stop.
02:48:44 <andreabedini> Cale: gotcha, yes
02:48:49 <Cale> hmm
02:49:45 <andreabedini> I am just calling verboseCheck $ forAllShrink arbitrary $ \x -> sillyProp x
02:50:08 <andreabedini> but I see there's a forAllShrink too
02:50:23 <Cale> hmm
02:51:12 <Cale> verboseCheck is defined in terms of quickCheck which uses stdArgs as its Args, one of which is maxShrinks = maxBound
02:52:07 <andreabedini> yup so I expect it to try to shrink
02:52:54 <Cale> try  quickCheck (verboseShrinking prop)
02:52:58 <andreabedini> wut, verboseCheck $ forAllShrink arbitrary shrink does the shrinking 
02:53:35 <andreabedini> where I had to pass shrink like it was a custom one
02:54:17 <andreabedini> quickCheck $ verboseShrinking  $ forAll arbitrary doesn't shrink
02:54:27 <dminuoso> :t Packet
02:54:28 <lambdabot> Int -> [Either Int Char] -> Packet
02:54:58 <dminuoso> > Packet 42 [Right 'a', Right 'b', Left 1] ^. attrs
02:54:59 <lambdabot>  [Right 'a',Right 'b',Left 1]
02:55:13 <dminuoso> How do I combine this with a fold to collect only the _Right elements?
02:55:40 <Taneb> > Packet 42 [Right 'a', Right 'b', Left 1] ^.. attrs.folded._Right
02:55:42 <lambdabot>  "ab"
02:56:25 <Taneb> dminuoso: is this what you were after?
02:56:35 <dminuoso> Taneb: Possibly. Is there a way to construct a Fold instead?
02:56:49 <dminuoso> Oh wait. attrs.folded._Right is that fold, isnt it?
02:56:52 <Cale> You could also use a list comprehension
02:56:53 <Taneb> wwYup
02:56:57 <Taneb> *-ww
02:57:05 <dminuoso> :t attrs.folded._Right
02:57:07 <lambdabot> (Applicative f, Contravariant f, Indexable Int p) => p Char (f Char) -> Packet -> f Packet
02:57:50 <MarcelineVQ> :t rights
02:57:51 <lambdabot> [Either a b] -> [b]
02:57:57 <Cale> ^^ or indeed, that
02:58:13 <dminuoso> Oh it was a lens specific question, my case is a bit more elaborate. :-)
02:59:23 <dminuoso> Taneb: What's with that (Indexable Int p) constraint there? It seems that this is not just `Fold Packet Char`
02:59:43 <dminuoso> @let rs :: Fold Packet Char; fs = attrs.folded._Right
02:59:44 <lambdabot>  .L.hs:164:1: error:
02:59:44 <lambdabot>      The type signature for ‘rs’ lacks an accompanying binding
02:59:45 <lambdabot>      |
02:59:49 <dminuoso> @let rs :: Fold Packet Char; rs = attrs.folded._Right
02:59:51 <lambdabot>  Defined.
02:59:55 <dminuoso> Huh.
03:00:11 <delYsid> Hmm, ByteString.split takes a Word8 argument, and the example seems to suggest I can pass a char literal (like ',' to it, however, that doesnt work.  Do I need an extension for this, or is the example wrong?
03:00:18 <Taneb> > Packet 42 [Right 'a', Right 'b', Left 1] ^@.. attrs.folded._Right
03:00:20 <lambdabot>  [(0,'a'),(1,'b')]
03:00:31 <Taneb> dminuoso: you can get the index if you need it, too
03:02:06 <Taneb> > Packet 42 [Right 'a', Right 'b', Left 1, Right 'c'] ^@.. attrs.folded._Right
03:02:08 <lambdabot>  [(0,'a'),(1,'b'),(3,'c')]
03:02:47 <dminuoso> :t rs
03:02:49 <lambdabot> (Applicative f, Contravariant f) => (Char -> f Char) -> Packet -> f Packet
03:03:12 <dminuoso> Taneb: Ohh I see. So Fold is actually more specific than what the composition gives me.
03:03:29 <dminuoso> So in truth Im getting an IndexedFold.
03:03:50 <dminuoso> Taneb: Okay I think Im wrapping my head around it.
03:06:42 <MarcelineVQ> delYsid: I don't think there's an OverloadedStrings sort of thing for Char's so the example is using Char possibly just to be more readable
03:07:38 <Taneb> dminuoso: Indexable is a weird typeclass, but the thing to remember is there's an instance Indexable i (->)
03:13:44 <siraben> I'm rewriting an `eval` function monadically, it has the type eval :: Expr -> Env -> Maybe Val, any suggestions on what I should name M in eval :: Expr -> M Val?
03:14:20 <siraben> Something shorter than "WaitingForEnv", maybe?
03:14:42 <siraben> I thought about calling it "Naked"
03:15:06 <byorgey> you could call it 'Eval'
03:15:26 <siraben> Eval Val?
03:15:33 <siraben> eval :: Expr -> Eval Val
03:16:04 <siraben> would there be any confusion in reading the code if the type constructor has the same name as the function?
03:16:07 <siraben> Or is this normal?
03:23:44 <dminuoso> siraben: What is Eval supposed to do?
03:24:00 <siraben> Take an expression, environment and return a value
03:24:07 <siraben> But the language I'm implementing is dynamically typed
03:24:11 <siraben> So there may be an error
03:25:07 <dminuoso> So (Eval ~ ReaderT Env Maybe) ?
03:25:08 <Ariakenom> "Eval a `isomorphicTo` Env -> Maybe a" ?
03:25:35 <siraben> Hm?
03:25:54 * dminuoso hands Ariakenom some squirly lines ~~~
03:26:10 <siraben> https://dpaste.de/Mrhi
03:26:30 * Ariakenom points dminuoso to newtypes
03:26:36 <dminuoso> siraben: You might be interested in GADTs by the way.
03:26:47 <siraben> I wrote newtype Unevaled a = Unevaled (Env -> Maybe a)
03:26:58 <siraben> But I'm trying to find a monad instance...
03:27:01 <dminuoso> siraben: Your Expr type admits things like: Add (BoolL True) (NumLiteral 10)
03:27:22 <siraben> dminuoso:  yes
03:27:29 <siraben> So I want to eval that and return nothing
03:27:56 <siraben> Imagine a Scheme, I suppose. It's basically the same language
03:28:06 <siraben> dminuoso:  GADTs how?
03:28:54 <siraben> dminuoso:  I wrote an interpreter for this language in SML https://github.com/siraben/eopl/blob/master/letrec.sml
03:29:14 <siraben> Many parts are verbose, especially the parser, and there's a bunch of impure stuff so I'm rewriting it
03:30:05 <dminuoso> siraben: https://en.wikibooks.org/wiki/Haskell/GADT
03:31:34 <siraben> dminuoso:  ah I see, reading it now.
03:33:02 <siraben> dminuoso:  but I don't want to parametrize on the type of expressions
03:33:04 <siraben> As the example did
03:34:05 <Ariakenom> % () :: (String -> Maybe Int) ~ (ReaderT String Maybe Int) => () -- dminuoso
03:34:05 <yahb> Ariakenom: ; <interactive>:18:1: error:; * Couldn't match type `String -> Maybe Int' with `ReaderT String Maybe Int' arising from an expression type signature; * In the expression: () :: (String -> Maybe Int) ~ (ReaderT String Maybe Int) => (); In an equation for `it': it = () :: (String -> Maybe Int) ~ (ReaderT String Maybe Int) => ()
03:34:57 <dminuoso> Ariakenom: Mmm. I should have used ~~~ or ~= I guess.
03:35:24 <dminuoso> But being a Haskeller I have the right to be handwavy. All my statements are up to isomorphism.
03:36:16 <Ariakenom> Surely only mathematicians are allowed such rights :p
03:36:37 * hackage failable 1.2.0.0 - A 'Failable' error monad class to unify failure across monads that can fail  https://hackage.haskell.org/package/failable-1.2.0.0 (erick)
03:37:37 <dminuoso> Ariakenom: Oh I dont know. The frequency at which we pretend bottom to not be a thing...
03:39:26 <dminuoso> siraben: Ah so you want to defer any such "type errors" to runtime errors?
03:39:31 <Ariakenom> moral bottoms is definitely allowed
03:40:25 <siraben> dminuoso:  yes
03:40:28 <siraben> I have a REPL
03:41:17 <dminuoso> > dat ^.. (attrs . folded . _Right . to toUpper)
03:41:19 <lambdabot>  error:
03:41:19 <lambdabot>      • Variable not in scope: dat :: Packet
03:41:19 <lambdabot>      • Perhaps you meant one of these:
03:41:32 <dminuoso> >  Packet 42 [Right 'a', Right 'b', Left 1] ^.. (attrs . folded . _Right . to toUpper)
03:41:34 <lambdabot>  "AB"
03:41:38 <dminuoso> Taneb: This is pretty cool. :)
03:41:56 <dminuoso> Only `folded` is.. quite magical here.
03:45:16 <siraben> dminuoso:  this is the current version of the evaluator, quite ugly
03:45:18 <siraben> https://paste.debian.net/1072970/
03:45:47 <siraben> I feel like appProc :: (Val -> Maybe Val) -> Maybe Val -> Maybe Val is almost a monad
03:45:48 <siraben> Like =<<
03:46:17 <dminuoso> siraben: I like you to look at lines 57 through 59
03:46:21 <dminuoso> siraben: And stare at it really long.
03:46:40 <siraben> Ok
03:46:52 <siraben> it's just id, oops
03:47:07 <siraben> dminuoso:  thanks
03:47:17 <dminuoso> siraben: The monad you are looking at is called Maybe.
03:47:30 <siraben> Right
03:48:02 <siraben> But eval takes an expression and environment
03:48:29 <siraben> dminuoso:  it looks similar to the parser, which has
03:48:30 <siraben> newtype Parser a = Parser (String -> [(a, String)])
03:48:42 <siraben> The "String" is like an environment of sorts
03:48:53 <dminuoso> Parser ~= StateT []
03:49:17 <siraben> Mm isomorphism
03:49:57 <dminuoso> siraben: So its not an environment, its the state of a parser.
03:50:21 <dminuoso> Reader env/ReaderT env/((->) env)
03:50:26 <dminuoso> These give you environment.
03:50:35 <dminuoso> (As in "readonly environment")
03:50:54 <dminuoso> siraben: As for your appProc, that's just (>>=)
03:50:57 <siraben> For now, yes.
03:51:09 <dminuoso> So you could have written: appProc = (>>=) 
03:51:15 <siraben> :k (->)
03:51:16 <lambdabot> TYPE q -> TYPE r -> *
03:51:30 <dminuoso> Pretend that reads: * -> * -> *
03:52:11 <siraben> What does the arrow mean?
03:52:28 <dminuoso> siraben: Consider `Maybe`
03:52:42 <dminuoso> siraben: Maybe could be considered some type level construct that takes an argument of kind * and gives you a type of kind *
03:52:48 <dminuoso> Maybe :: * -> *
03:52:58 <siraben> I see.
03:53:03 <dminuoso> Either takes two arguments, so it has the kind:
03:53:07 <dminuoso> Either :: * -> * -> *
03:53:13 <siraben> Why isn't it labelled with names like "p", "q" etc?
03:53:13 <dminuoso> (->) :: * -> * -> *
03:53:19 <siraben> Only *
03:53:37 <dminuoso> siraben: the `TYPE q/TYPE r` are newer things for something called levity polymorphism. You can glance over it and pretend it says * instead.
03:53:59 <dminuoso> (This polymorphism allows for more than just *)
03:54:42 <dminuoso> siraben: Just pretend that:  (->) :: * -> * -> *
03:54:56 <siraben> Ok
03:55:32 <dminuoso> siraben: (->) is just an infix type constructor, but you can use it in prefix position too:
03:55:47 <siraben> dminuoso:  does this help me rewrite "eval"?
03:56:10 <Cale> dminuoso: You forgot to explain that (->) is the type constructor for functions
03:56:33 <Cale> A -> B is the type of functions accepting an argument of type A, and producing a result of type B
03:57:00 <dminuoso> Or, in prefix notation: ((->) A B)
03:57:06 <dminuoso> These two are fully equivalent.
03:57:55 <siraben> dminuoso:  in my "eval" there's a lot of "case X of Y ...", but I can't seem to find a monad instance
03:57:58 <siraben> To simplify it
03:58:59 <dminuoso> siraben: ReaderT Env Maybe
03:59:14 <dminuoso> siraben: This gives rise to a monad where you can have failure anywhere while dragging an environment implicitly through.
03:59:34 <siraben> What does ReaderT do?
03:59:42 <siraben> And Env is defined as what?
03:59:46 <dminuoso> siraben: Whatever you want.
04:00:15 <dminuoso> siraben: You dont really need ReaderT though. It just turns "passing arguments explicitly" into "passing arguments implicitly"
04:00:57 <dminuoso> siraben: Anyway. Just use the Maybe monad.
04:01:14 <dminuoso> siraben: Or perhaps `Either Text` rather, and get rid of your `error` invocations.
04:01:30 <siraben> dminuoso:  could you show an example? Maybe one or two guards of "eval"
04:01:47 <dminuoso> Sure.
04:03:50 <dminuoso> siraben: https://gist.github.com/dminuoso/266a1ff1605a8e8e25367e8c77700ccf
04:05:00 <dminuoso> siraben: You could do the same with `Either Text` and then use `Left "..."` to fail with meaningful error messages.
04:11:51 <siraben> dminuoso:  ok it's much shorter now https://paste.debian.net/1072974/
04:13:14 <siraben> dminuoso:  can I wrap an exception monad around Maybe Val?
04:13:23 <siraben> Or would an Either be better
04:14:18 <siraben> Now, changing the type to eval :: Expr -> Env -> Either (Maybe Val) (Exception String) raises typerrors
04:22:55 <siraben> :k MaybeT
04:22:56 <lambdabot> error:
04:22:56 <lambdabot>     Not in scope: type constructor or class ‘MaybeT’
04:22:56 <lambdabot>     Perhaps you meant ‘Maybe’ (imported from Data.Maybe)
04:23:29 <dminuoso> siraben: You should really get rid of that `error`
04:23:40 <siraben> dminuoso:  Yeah, how?
04:26:13 <dminuoso> siraben: eval :: Expr -> Env -> Either Text Val
04:26:21 <dminuoso> siraben: You could start with this.
04:33:46 <kuribas> is a compiled windows .exe file distributable?
04:34:32 <hpc> in what sense?
04:34:47 <kuribas> that it runs on another computer
04:34:52 <hpc> ah, yes
04:35:00 <dminuoso> kuribas: It depends.
04:35:00 <kuribas> do you need to distribute dlls?
04:35:03 <dminuoso> kuribas: Yes.
04:35:07 <hpc> only if you link to them
04:35:26 <kuribas> I'm ok with static linking
04:37:09 <ClaudiusMaximus> GMP might not be ok with static linking
04:52:46 <kuribas> it's only for internal use
04:53:03 <kuribas> licencing is not problem
05:26:07 * hackage futhark 0.9.1 - An optimising compiler for a functional, array-oriented language.  https://hackage.haskell.org/package/futhark-0.9.1 (TroelsHenriksen)
05:26:35 <siraben> dminuoso:  https://github.com/siraben/eopl/blob/master/letrec.hs
05:26:45 <siraben> dminuoso:  Got rid of that error :)
05:28:47 <siraben> Would it be possible to stop passing the environment around?
05:29:02 <dminuoso> siraben: ReaderT gives you that.
05:29:17 <siraben> dminuoso:  can you give an example?
05:29:43 <dminuoso> siraben: Also are you sure you want to rely on ErrorT?
05:30:14 <dminuoso> siraben: Ohh nevermind, I got sidetracked by your usage of throwError.
05:41:05 <Athas> How often are Nix packages synchronised with Hackage?  Is it automatic?
05:41:58 <cocreature> Athas: it’s semiautomatic iirc in the sense that it’s a script but someone still needs to run it and make a PR
05:42:27 <cocreature> and it’s also a weird mix of Stackage and Hackage so it won’t get all the latest versions by default
05:43:27 <Athas> Lovely.
05:44:11 <siraben> Anyone able to install hindent from cabal?
05:44:25 <siraben> It fails for me
05:44:39 <siraben> Or, what's a widely use autoformatter for Haskell?
05:45:18 <siraben> stylish-haskell?
05:46:56 <__monty__> siraben: There's also brittany.
05:47:37 <__monty__> Stylish only does imports afaik, hindent mostly function bodies and brittany does both afaik but with a difference in philosophy.
05:49:17 <hvr> siraben: please file an issue at https://github.com/haskell-infra/hackage-trustees/issues about hindent
05:51:09 <__monty__> Athas: Re the weird mix, iiuc it's latest stackage + head.hackage for things not in stackage + regular hackage if that doesn't cover everything.
05:51:23 <siraben> hvr:  I'm checking to see if it's caused by my build environment
05:51:39 <hvr> siraben: it's not your build environment; I see it too
05:51:59 <hvr> that package has faulty metadata
05:52:43 <siraben> What's the difference between installing with stack and installing with cabal?
05:52:59 <hvr> they're two different ecosystems
05:53:10 <siraben> hvr:  is brittany failing too?
05:53:24 <siraben> "After searching the rest of the dependency tree exhaustively, these were the goals I've had most trouble fulfilling: base, brittany"
05:53:30 <Athas> siraben: different version resolver, different location of output binaries.
05:53:35 <hvr> siraben: e.g. see  https://matrix.hackage.haskell.org/#/package/hindent/
05:53:44 <siraben> Are there advantages to either?
05:53:49 <Athas> Yes.
05:54:03 <Athas> It's a complex and controversial choice.
05:54:08 <Athas> Different hackers have different preferences.
05:54:11 <hvr> siraben: if you want all the features, pick cabal
05:54:26 <siraben> cabal: The program 'happy' version >=1.19 is required but it could not be found.
05:54:33 <siraben> This seems to be happening across many different packages
05:54:47 <hvr> siraben: ok, which version of cabal are you using? and are you using install or v2-install ?
05:55:07 <siraben> hvr:  just install
05:55:09 <siraben> hindent-5.2.7-6luyw2kVIkaKlbqBxYUcTa depends on hindent-5.2.7 which failed to
05:55:09 <siraben> install.
05:55:19 <siraben> That's a circular dependency, no?
05:55:42 <hvr> siraben: no, it just means it has an intra-package dependency between the executable and the intra-package library
05:55:44 <hvr> that's fine
05:56:34 <hvr> siraben: as for brittany, there isn't currently a build-plan for GHC 8.6 as can be seen at https://matrix.hackage.haskell.org/#/package/brittany
05:56:43 <hvr> siraben: but if you use GHC 8.4, you should be fine
05:57:04 <siraben> should I be using v2-install?
05:57:35 <hvr> siraben: yes, v2-install shouldn't have those issues you saw with 'happy'
05:57:46 <hvr> siraben: also, are you on windows or non-windows?
05:57:50 <siraben> What's "happy"?
05:57:56 <hvr> a parser generator
05:57:57 <siraben> macOS
05:58:30 <hvr> ideally, you should be using cabal 2.4.1
05:58:40 <hvr> i.e. the latest release of cabal
06:00:25 <siraben> hvr:  I ran "cabal update"
06:01:14 <siraben> Is it normal to be compiling this much?
06:01:37 <hvr> for which package?
06:02:10 <hvr> it depends on the package; some tools/packages have like a dependency-tree of ~100 packages
06:02:48 <hvr> e.g. if you build something like "hakyll" you can easily experience that
06:05:18 <maerwald> freeze files don't work well across different GHC versions it seems
06:05:35 <hvr> maerwald: is it surprising? :-)
06:05:42 <maerwald> Partly
06:06:10 <maerwald> But I guess a command that tries to bump only ghc-shipped libraries and keeps the others untouched would be quite involved
06:06:44 <hvr> not that much actually
06:07:08 <hvr> the problem is though that it's still likely that it's not going to be enough to just mask out the non-reinstallable ones
06:07:38 <maerwald> would you consider that good practice to remove those ghc libs from a freeze file?
06:08:07 <hvr> not sure; it depends on your goal
06:08:36 <hvr> the purpose of freezing is to end up with a forzen build-plan, and that implies a frozen toolchain
06:09:00 <siraben> I failed to build hindent with "cabal v2-install hindent"
06:09:00 <siraben> http://ix.io/1Do3/text
06:10:08 <hvr> siraben: yeah, that was expected though; you're confirming the build failures recorded at https://matrix.hackage.haskell.org/#/package/hindent/
06:10:33 <hvr> siraben: this is due to incorrect metadata; something that'll be fixed asap if you file an issue at  https://github.com/haskell-infra/hackage-trustees/issues
06:11:29 <siraben> hvr:  alright I'll open up an issue
06:21:37 <siraben> dminuoso:  Say I'm adding eval (Add n1 m1) env = do { (Num n) <- eval n1 env; (Num m) <- eval m1 env;  return $ Num $ n + m } to my language
06:21:44 <siraben> It only returns "Nothing" on a type error
06:23:11 <Henson> hey folks, I'm working on a machine vision library in Haskell.  One function with type "(CameraBus b) => (b -> IO a) -> IO a" get the camera bus and does some action with it.  I have different camera busses for different vendors.  I've written a test suite for one vendor and it works.  Now I'm trying to make it generic.  The only thing that is specific among the different vendors is the type...
06:24:11 <Henson> signature of the bus that is created.  In the vendor-specific tests that wasn't a problem, but now in the generic tests it is.  I'm trying to pass in a vendor-specific bus-getting function to the generic tests and have all of the vendor specific tests just be the generic tests but with their own bus getting function with their own vendor-specific type signature...
06:25:15 <Henson> but when I do this, the type "a" of the function I mentioned above gets set and doesn't work with all of the different output types that the different tests have.  Does anybody have any suggestions on how I could do this, or the proper way I should be doing this?
06:38:16 <Ariakenom> Henson: I didn't quite follow. A small code example of the problem would probably get you help.
06:49:35 <dminuoso> siraben: This is why Im suggesting something like `Either Blah`, so you can communicate sensible error messages.
06:49:41 <dminuoso> siraben: Maybe ~= Either ()
06:50:56 <dminuoso> siraben: So in that sense, try to pick a more suitable error type than ()
06:51:14 <dminuoso> Perhaps `Text` would be sufficient to start with.
06:53:58 <dminuoso> [exa]: So I ended up just using `_packetAttributes . folded . _AttrUserName` by the way, and then requiring the user to pick `preview` or `toListOf` 
06:57:34 <siraben> dminuoso:  you mean https://hackage.haskell.org/package/base-4.12.0.0/docs/Text-Read.html ?
06:59:43 <siraben> dminuoso:  but then what about handling type errors?
07:00:11 <siraben> Ah it says nothing right now, I should have an error type
07:04:14 <siraben> dminuoso:  then it would simplify the types more right? Because I would only have, say, "Exceptional Val" instead of "ExceptT Exception Maybe"
07:05:17 <__monty__> Henson: Maybe you want TypeSynonymInstances?
07:05:58 <__monty__> No, that's not what I had in mind.
07:06:32 <Henson> Ariakenom: I'll see if I can put something together, but I might not get time
07:07:59 <Henson> __monty__: thanks for thinking about it :-)
07:08:40 <__monty__> I seem to remember type synonyms being defined in classes, can't find it now though.
07:10:47 <dminuoso> siraben: I do not understand.
07:11:20 <tomsen> (Just x) <- a raises error and exits if a is nothing. can i raise with custom error message somehow?
07:11:27 <siraben> dminuoso:  what were you suggesting?
07:11:48 <siraben> I see
07:12:25 <siraben> What about the use of ExceptT? Is that redundant?
07:15:36 <Solonarv> tomsen: no - do { Just x <- a; stuff } always desugars to a >>= \_a -> case _a of Just x -> stuff; _ -> fail "pattern match failure"
07:15:51 <Solonarv> (well, the error string is bit more descriptive than that)
07:16:33 <Solonarv> the 'fail' there is from Control.Monad.Fail with the MonadFailDesugaring extension (which is on by default in recent GHCs)
07:17:19 <tomsen> ExceptT looks nice, i could convert the maybe i get from the library.
07:18:38 <tomsen> Solanarv if I try case x of Nothing -> fail "" i'll get type error. is there a "fail" that doesnt get typechecked or how they do it?
07:19:05 <tomsen> because result will either be type a, or type of failure
07:19:10 <Solonarv> read my code again carefully
07:19:50 <tomsen> ah, your point is that is does not work ^^
07:21:28 <tabaqui> you should enable -Wincomplete-uni-patterns or -Wmissing-monadfail-instances to get warnings for such cases
07:21:35 <tabaqui> I higly recommend you to do so
07:22:07 <Solonarv> tomsen: https://gist.github.com/Solonarv/878c0f96b5e0b59c7f5d60d1d4b06fe2
07:22:47 <Solonarv> tabaqui: no need; if you enable MonadFailDesugaring (it's on by default in 8.6+) then that simply won't typecheck without a MonadFail instance
07:23:17 <tabaqui> ah, I still use lts-11.22
07:23:24 <tabaqui> it is on ghc-8.2.2
07:23:51 <gentauro> we seriously need this (forget about `ghcjs`, we need a `ghcjsf`) -> https://dev.to/winduptoy/a-javascript-free-frontend-2d3e
07:23:53 <Solonarv> you can still turn on MonadFailDesugaring yourself ;)
07:24:06 <tabaqui> anyway, will it throw an error here if there is MonadFail instance?
07:24:15 <dminuoso> % char :: Int -> Either Text Char; char x | x < 0 = throwError "Negative number"; char x | otherwise = pure (intToDigit x)
07:24:15 <yahb> dminuoso: 
07:24:18 <dminuoso> % char (-7)
07:24:18 <yahb> dminuoso: Left "Negative number"
07:24:20 <gentauro> Haskell to HTML + CSS (but no JS) That would be the `dream`
07:24:25 <dminuoso> % char (50)
07:24:25 <yahb> dminuoso: Right *** Exception: Char.intToDigit: not a digit 50
07:24:39 <dminuoso> Okay bad example.
07:24:48 <dminuoso> % char :: Int -> Either Text Char; char x | x < 0 = throwError "Negative number"; char x | otherwise = pure (chr x)
07:24:48 <yahb> dminuoso: 
07:24:50 <dminuoso> % char (50)
07:24:50 <yahb> dminuoso: Right '2'
07:24:53 <dminuoso> siraben: ^-
07:25:11 <gentauro> % :i Text
07:25:14 <yahb> gentauro: data Text = Data.Text.Internal.Text {-# UNPACK #-}Data.Text.Array.Array {-# UNPACK #-}Int {-# UNPACK #-}Int -- Defined in `Data.Text.Internal'; instance Eq Text -- Defined in `Data.Text'; instance Monoid Text -- Defined in `Data.Text'; instance Ord Text -- Defined in `Data.Text'; instance Semigroup Text -- Defined in `Data.Text'; instance Show Text -- Defined in `text-1.2.3.0:Data.Text.Show'; instance 
07:25:39 <Solonarv> tabaqui: well, depends on your definition of "throw an error"
07:25:49 <tabaqui> compile error I mean
07:25:55 <dminuoso> siraben: Either is just a Maybe where the Nothing side can have information tacked to it. :)
07:26:17 <Solonarv> No, why would that be a compile error? MonadFail exists precisely to desugar partial pattern matches in do notation.
07:26:56 <tabaqui> will it show a warning then?
07:27:01 <Solonarv> (well, almost precisely - you are of course free to call 'fail' directly to report other kinds of error)
07:27:05 <dminuoso> tabaqui: Why would it?
07:27:17 <dminuoso> tabaqui: If you use patterns in do-notation be prepared for MonadFail.
07:27:25 <tabaqui> I dunno, incomplete-uni-patterns does
07:28:16 <dminuoso> tabaqui: What exactly are you trying to protect yourself against?
07:28:17 <tabaqui> It is a common mistake, especially in IO monad, to forget about patterns
07:28:56 <siraben> dminuoso:  so then: type Result = ExceptT Exception (Either String)
07:29:00 <siraben> Right?
07:29:02 <tabaqui> dminuoso: I sometimes forget about complete such patterns
07:29:03 <Solonarv> incomplete-uni-patterns doesn't say anything about patterns in do notation, actually
07:29:24 <tabaqui> like "Just x <- foo; ..." can throw an exception in IO monad
07:29:31 <siraben> Hm then why am I using throwError
07:29:53 <siraben> dminuoso:  is throwError redundant and can be replaced by using Left, for instance?
07:29:56 <dminuoso> siraben: Yes.
07:30:05 <dminuoso> siraben: Well, it depends.
07:30:24 <tabaqui> Solonarv: yeah, but it works in do notation
07:30:33 <dminuoso> siraben: throwError is just the generic mtl interface for monads that can throw and catch errors.
07:30:39 <tabaqui> actually, it covers any pattern bindings
07:30:50 <siraben> dminuoso:  but in this case, it's overkill?
07:30:52 <Solonarv> tabaqui: hmm, that seems like a hole in the documentation then
07:31:04 <dminuoso> siraben: If you are using ExceptT, then you need to either use throwE or throwError
07:31:08 <shapr> This git-remote-ipfs is really cool: https://github.com/oscoin/ipfs
07:31:21 <dminuoso> siraben: You cant use `Left` for ExceptT because you get a newtype in your face.
07:31:35 <dminuoso> That is, you must produce something of type `ExceptT ...`
07:31:37 <dminuoso> % :t Left
07:31:37 <yahb> dminuoso: a -> Either a b
07:31:51 <siraben> dminuoso:  So I should do another rewrite?
07:31:56 <tabaqui> Solonarv: I don't think so, you can imply that it works for do-notation
07:32:08 <siraben> Hm structuring things is tricky
07:32:24 <dminuoso> siraben: Why do you want two layers? Wouldn't a single `Either ErrorCondition Val` do?
07:32:45 <dminuoso> siraben: Well structuring programs is tricky indeed, Im not sure this is a Haskell problem right now.
07:32:50 <tabaqui> maybe one should add it as an example
07:32:53 <Solonarv> it's still a bit unclear, especially because it seems odd to both:
07:32:53 <Solonarv>  - have a mechanism for desugaring partial pattern matches safely
07:32:53 <Solonarv>  - warn about partial pattern matches
07:32:55 <siraben> dminuoso:  Yeah it should, I'll do that
07:33:01 <intothefire412> I installed xmonad via cabal new-install, but it can't find the module XMonad when trying to compile. How should I run it so that it has access to the libraries? My setup is through ghcup.
07:33:10 <dminuoso> Solonarv: For what its worth, it would be useful to have a flag that warns you about MonadFail desugaring.
07:33:22 <dminuoso> Solonarv: I can perfectly symphathize with accidentally tripping into it.
07:33:40 <Solonarv> It should definitely be possible to suppress that warning *at a single use site*, though.
07:34:19 <dminuoso> MonadFail is a bit quirky because it's not obvious that it happens.
07:34:32 <tabaqui> I agree
07:34:45 <tabaqui> Obvious is better than non-obvious
07:34:59 <tomsen> Solonarv: thank you very much for the snippets! They made me figure it out
07:35:09 <tabaqui> *Explicit is better than implicit.
07:36:00 <dminuoso> intothefire412: What is "it" in "but it can't find the module XMonad when trying to compile"?
07:37:58 <dminuoso> intothefire412: Did you perhaps mean to create your own cabal project and running xmonad through `cabal new-run`?
07:38:32 <Solonarv> actually this seems like a good use case for cabal's script feature
07:38:53 <dminuoso> intothefire412: https://github.com/xmonad/xmonad-testing should give you a good hint how to use cabal with new-style commands.
07:39:28 <Solonarv> ooh, that's helpful
07:40:10 <dminuoso> (It boils down to just having some your-xmonad.cabal file and some xmonad.hs that you specify under main-is: xmonad.hs
07:42:05 <juri_> can someone tell me why my implementation of a taylor series approximation of arcsin doesn't converge? https://gist.github.com/julialongtin/d6681ff9fd453ba3f37f89366fd4983b
07:42:49 <Solonarv> You might even be able to do this in a single file by starting the file with something like https://gist.github.com/Solonarv/2af68bc5ec7de2435ce77f70d3b665a9
07:44:03 <freusque> is there a way I could rewrite this in a more concise/pleasant manner? (\(EnvVar x,y) -> (T.unpack x,T.unpack y))
07:44:54 <freusque> actually, with some more context that's Just $ (\(EnvVar x,y) -> (T.unpack x,T.unpack y)) <$> vars 
07:45:14 <Solonarv> juri_: "floating point rounding issues" is my guess
07:45:28 <freusque> of type [(EnvVar Text, Text)] -> Maybe [(Text,Text)]
07:45:36 <freusque> where data EnvVar = EnvVar Text
07:45:38 <Solonarv> what you typed into ghci is polymorphic, so it'll default to Double
07:46:53 <Cale> freusque: Apart from potentially pulling a definition out and giving it a name, I don't really know. There's almost certainly some lensy stuff you can do, but it's probably not worth the trouble.
07:47:15 <freusque> thanks for your answer
07:47:43 <freusque> I was wondering if it was possible to get some more sugar
07:48:08 <Cale> :t both
07:48:10 <lambdabot> (Applicative f, Data.Bitraversable.Bitraversable r) => (a -> f b) -> r a a -> f (r b b)
07:48:25 <juri_> Solonarv: I thought so. thanks.
07:48:26 <freusque> "functional" control flow in R for instance (I know, I know..) has sugar like (EnvVar$T.unpack . , T.unpack .)
07:48:54 <Cale> :t over both T.unpack
07:48:55 <lambdabot> error:
07:48:55 <lambdabot>     Not in scope: ‘T.unpack’
07:48:55 <lambdabot>     Perhaps you meant ‘BS.unpack’ (imported from Data.ByteString)
07:49:28 <Solonarv> juri_: if you force the type to Rational (i.e. [[ ... stuff ...]] :: [[Rational]]) you'll get unbounded precision, but of course it's much slower
07:49:29 <freusque> I see. lensy stuff. :)
07:49:54 <Solonarv> % :t over both T.unpack
07:49:54 <yahb> Solonarv: ; <interactive>:1:11: error:; Not in scope: `T.unpack'; Perhaps you meant `BS.unpack' (imported from Data.ByteString); No module named `T' is imported.
07:49:59 <Solonarv> % :t over both Text.unpack
07:49:59 <yahb> Solonarv: Data.Bitraversable.Bitraversable r => r Text Text -> r String String
07:50:35 <Solonarv> % :t bimap Text.unpack Text.unpack -- works too
07:50:35 <yahb> Solonarv: Bifunctor p => p Text Text -> p String String
07:50:45 <Solonarv> (and doens't need lens)
07:50:47 <Cale> It's sort of like... do I really want to use this complicated machinery to solve a problem which is handled by simple pattern matching and a lambda?
07:51:08 <Cale> :t join bimap
07:51:09 <lambdabot> Bifunctor p => (c -> d) -> p c c -> p d d
07:51:10 <Cale> lol
07:51:43 <freusque> yeah I see. I'm happy with it, just was curious :)
07:52:32 <freusque> thanks to the both of you.
07:58:02 <intothefire412> dminuoso: sorry I'm trying to set up a new system and got sidetracked by unexpected issues. "it" is just `xmonad --recompile`. Is the way to go cloning the repo and doing new-install?
08:00:49 <dminuoso> intothefire412: when you use cabal with new-style builds you have to use `cabal new-run`
08:00:58 <dminuoso> intothefire412: so `cabal new-run your-app-name -- --recompile` probably?
08:01:27 <dminuoso> intothefire412: And no, you just need two files really. A cabal file (you can take inspiration from the xmonad-testing.cabal file from the repository) and then your haskell file containing the xmonad stuff.
08:01:41 <dminuoso> intothefire412: xmonad is just a regular haskell program, nothing special about it.
08:01:59 <dminuoso> intothefire412: in particular its what building your xmonad.hs produces that you want.
08:02:40 <Solonarv> actually a cabal script really should be enough then, you don't even need a full project
08:03:13 <siraben> dminuoso:  what would it take to implement something that signalled the specifics of the type error?
08:03:27 <Solonarv> (cabal's script feature compiles the script, it doesn't use runghc)
08:03:44 <siraben> Something like "Type error: expected expression of type Int but got type String instead"
08:05:15 <siraben> I could have a typeOf function :: Val -> String that gives the type of the variable, hm.
08:09:37 * hackage libraft 0.4.1.0 - Raft consensus algorithm  https://hackage.haskell.org/package/libraft-0.4.1.0 (sdiehl)
08:33:17 <siraben> How do I have a "forever" loop that's inside of main?
08:33:32 <siraben> So, do { foo; forever do { ... } }
08:33:38 <siraben> Because I want foo to run once
08:33:41 <Taneb> :t Control.Monad.forever
08:33:42 <lambdabot> Applicative f => f a -> f b
08:34:14 <Taneb> Pretty much exactly as you wrote :D
08:34:15 <siraben> Hm looks like it works now
08:34:20 <siraben> It was just a matter of putting in braces
08:44:12 <tomsen> Would method chaining (in e.g. rust or ruby) where you do sth like myStruct.fcn1().fcn2() while allowing side-effects be described as myStruct being an IO Monad?
08:49:23 <dminuoso> tomsen: The IO Monad instance is what sequences side effects in Haskell.
08:50:14 <dminuoso> tomsen: In Ruby or Rust you can pretend every method to return something wrapped in IO.
08:50:26 <Henson> tomsen: not necessarily.  It depends what you put in and get out.  If you're expecting to mutate the thing you put it, then yes.  But if you're getting out a new thing that is a mutated version of the thing you put in, then not necessarily.
08:51:32 <dminuoso> tomsen: So for example some fictoinal Array#length from such a language would have a Haskellized type like: Array -> IO Integer
08:51:43 <Henson> tomsen: in the latter case method chaining is similar to Haskell's function composition, or just chaining a bunch of function calls together.  But they each produce a new thing which is then passed in as an argument to the next function, in the end producing a transformed version of the thing you put it.
08:53:33 <tomsen> Ok I see, the restrictions of Monads do not fit. So it is pretty much unrelated. Cool thanks :-)
08:54:25 <dminuoso> tomsen: Monad is just an abstract interface that is actually very prevalent in proramming in many forms.
08:55:26 <dminuoso> tomsen: 
09:02:24 <dminuoso> Is using a `Pool ()` from connection-pool a thing just to limit the amount of concurrent HTTP requests Im making to an external web service?
09:09:31 <fresheyeball> hey haskellers
09:09:37 <[exa]> ey
09:09:49 <fresheyeball> I see some code out there with `deriving (..., Generic, NFData)`
09:09:53 <gimbiss> I have a testing question and eventhough I am not sure this is the right place to ask, I thought I would start here, when writing quickCheck, HSpec test suites for a module, should I write test for the derived instances of custom types ?
09:10:10 <fresheyeball> and when I try to derive NFData it says "not without DeriveAnyClass you dont`
09:10:40 <fresheyeball> so usually I just make an empty instance NFData and let Generic handle it
09:10:42 <fresheyeball> but not today
09:10:46 <fresheyeball> no today is a different day
09:10:56 <fresheyeball> today I ask the IRC, what in the butt does DeriveAnyClass do?
09:11:10 <fresheyeball> How are others using deriving syntax to get NFData from Generic
09:11:22 <fresheyeball> and is DeriveAnyClass as dangerous and unsafe as it sounds?
09:12:54 <geekosaur> it just derives an empty instance (all methods defaulted)
09:13:11 <[exa]> fresheyeball: iirc it's just for simplifying the programs; docs says this: http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#deriving-any-other-class
09:13:13 <geekosaur> it's generally used with classes with default method implementations that use generics
09:14:52 <fresheyeball> geekosaur: sounds perfect!
09:15:11 <fresheyeball> hmm, it's not playing well with generalized newtype deriving
09:15:24 <geekosaur> no, that's why there's deriving strategies now
09:15:28 <geekosaur> so you can specify which one gets used
09:15:55 <fresheyeball> geekosaur: yeah, but if I have to have 2 deriving lines, I don't save any code with derive any class
09:16:33 <geekosaur> they can be combined, but yes, all of this machinery has its shortcomings and annoyances
09:18:39 <fresheyeball> geekosaur: yeah, ok
09:18:41 <fresheyeball> I get it
09:18:47 <fresheyeball> actually I lose a line with derive any
09:18:54 <fresheyeball> because now I need 3 lines of derving
09:19:01 <fresheyeball> one for Generic as stock
09:19:08 <fresheyeball> then one for Eq Ord Num as newtype
09:19:17 <fresheyeball> then one for NFData as anyclass
09:19:28 <geekosaur> should be possible to combine them
09:19:49 <fresheyeball> geekosaur: if you see a way, let me know
09:20:43 <geekosaur> hm, no, I'm misremembering the syntax for multiple deriving via. thought they'd used similar syntax :/
09:20:54 <geekosaur> maybe that'll come at some point
09:21:42 <geekosaur> nom that doesn't look right either. maybe it was a proposal. ah, well
09:22:00 <geekosaur> I recall a syntax that added more parentheses but allowed everything to be done in a single deriving stanza
09:23:32 <reallymemorable> I'm working on a case statement, and I don't know how to return the results of both fmaps: https://paste.ofcode.org/sYvKKDGGrCqWxtdLpZCEuF
09:23:35 <reallymemorable> can anyone advise?
09:26:21 <geekosaur> wouldn't that be ++ing both?
09:26:23 <Henson> reallymemorable: what's the output type of this case statement?  A list?
09:26:32 <reallymemorable> yes
09:27:32 <Henson> reallymemorable: and are the results themselves lists?  Do you want to get two separate things out, or one thing that is the combination of both of them?
09:27:52 <reallymemorable> one thing that is a combination of both
09:27:59 <reallymemorable> yes they return lists
09:28:07 <geekosaur> it'd have to be that, or there's a logic error in the rest
09:28:28 <NickSeagull> Any idea why a program would work on GHCi but not when compiled?
09:28:32 <Henson> reallymemorable: ok.  So as geekosaur suggested, you can just ++ the two results together
09:28:59 <geekosaur> NickSeagull, define "work"
09:29:00 <reallymemorable> (M1Map <$> selectM1C) ++ (M2Map <$> selectM2C)?
09:29:22 <Henson> NickSeagull: in what way is it not working?  I think GHCi probably disables optimization and has some other operational-differences compared to a compiled function.
09:29:39 <[exa]> dminuoso: btw user picking preview/toListOf sounds quite reasonable to me; thanks for letting me know :]
09:29:55 <NickSeagull> geekosaur: calling main from GHCi has the expected behaviour, while calling the binary gets stuck when running a transformer (InterpreterT from Hint)
09:30:06 <Henson> reallymemorable: what monad is this working in?  I see you are using <$>.  Are selectM1C and selectM2C in IO or some other monad?
09:30:10 <NickSeagull> Henson: so in theory compiling with -O0 whould work?
09:30:31 <dminuoso> [exa]: The types are incredibly hairy though..
09:30:44 <reallymemorable> selectM1C etc. are returned postgres queries
09:30:49 <reallymemorable> so yes IO right?
09:30:54 <Henson> NickSeagull: hmm, it would be worth a try.  I'm not too familiar with the differences in the environments, honestly.
09:30:54 <geekosaur> there's also trickier things, like it's on unix and doing terminal input, and implicitly relying on ghci using haskeline whereas a compiled program runs in standard unix line mode
09:31:31 <kuribas> why does cassavo parse into a vector instead of a list?
09:31:57 <Henson> reallymemorable: so in your do block, just do something like "list1 <- M1Map <$> selectM1C; list2 <- M2Map <$> selectM2C; return $ list1 ++ list2" where you can replace ";" with newlines.
09:31:57 <geekosaur> there are severl obscure differences in terminal IO, there's some differences in FFI vs. bound threads, etc.
09:32:06 <dminuoso> [exa]: sadly the user has to explicitly turn it into a fold by composing with folded too (because you cant specify LensRules for classy lenses while maintaining the default rules)
09:32:10 <NickSeagull> geekosaur: I'm actually using ansi-terminal for log coloring, perhaps that might be the problem? Sounds unrelated tbh
09:32:25 <geekosaur> you could start by seeing if the same difference happens with runghc
09:32:54 <reallymemorable> https://paste.ofcode.org/V5kxe5xjpU7H4Sqv9jVYyz
09:32:56 <reallymemorable> like that?
09:33:11 <Henson> reallymemorable: yeah, that should work
09:33:17 <reallymemorable> awesome thank you so much
09:33:23 <kuribas> cassava will have to parse into a string first anyway
09:33:28 <kuribas> why go to a vector then?
09:33:43 <NickSeagull> geekosaur: hmm, its quite a big project, I'm not sure how would it work to run it with runghc
09:33:44 <geekosaur> optimization is another difference, it's disabled in the bytecode backend and optimization can chnage strictness (but this should proabbly be treated as a compiler bug, if you can narrow it down)
09:34:20 <geekosaur> if you can run it in ghci, you should be able to run it with runghc?
09:35:33 <NickSeagull> I run ghci through cabal new-repl
09:36:00 <NickSeagull> geekosaur: is there an equivalent to runghc with cabal? never needed to use it :)
09:36:43 <geekosaur> I think it would have to be cabal exec -- runghc ...
09:37:04 <NickSeagull> I see, let me try it
09:38:52 <NickSeagull> geekosaur: works with runghc
09:39:21 <NickSeagull> Tried to disable optimization with -O0, still doesnt work
09:40:35 <geekosaur> mmh. I think at this point I start instrumenting with Debug.Trace. these can be tricky to track down
09:41:13 <NickSeagull> I narrowed it down to a call to `runInterpreter :: (MonadIO m, MonadMask m) => InterpreterT m a -> m (Either InterpreterError a)`
09:41:32 <NickSeagull> It basically gets stuck there
09:41:43 <NickSeagull> runInterpreter spins up a GHCi
09:42:49 <NickSeagull> I have a feeling that this might be related to NixOS, gonna try building it in another system to see if this works
09:52:25 <reallymemorable> is there something inherently wrong with `(True,True) -> pure []` that would cause this error: `parse error on input '->'`?
09:53:29 <fen> is there a varient of build for things like Int, that were created by accumulating a state?
09:53:52 <NickSeagull> geekosaur: apparently it runs on OSX with no issue
09:54:11 <fen> you dont exactly "unfold" an int, is its not a foldable container of anything, its just [()]. the contents of the list are fixed
09:54:45 <fen> but the you should be able to do something like fold over the [()] with a (() -> () -> b) function
09:55:00 <fen> and this should fuse into the original state "unfold" ...
09:55:06 <geekosaur> reallymemorable, not directly. but you could get that from an indentation issue meaning ghc thinks it's not "inside" the case
09:55:16 <NickSeagull> :t build
09:55:17 <lambdabot> error:
09:55:17 <lambdabot>     • Variable not in scope: build
09:55:17 <lambdabot>     • Perhaps you meant ‘buildG’ (imported from Data.Graph)
09:55:23 <fen> what are these foldable and unfoldable and build like things for containers with fixed contents?
09:55:50 <fen> % :t GHC.Exts.build
09:55:50 <yahb> fen: (forall b. (a -> b -> b) -> b -> b) -> [a]
09:56:25 <lyxia> replace a with () and [()] with Nat
09:57:15 <Taneb> Does lambdabot have recursion-schemes?
09:57:20 <Taneb> :t Data.Functor.Foldable.ana
09:57:20 <reallymemorable> geekosaur: i am 99% certain it's not indentation
09:57:21 <lambdabot> error:
09:57:21 <lambdabot>     Not in scope: ‘Data.Functor.Foldable.ana’
09:57:21 <lambdabot>     No module named ‘Data.Functor.Foldable’ is imported.
09:57:25 <Taneb> :(
09:57:41 <lyxia> % :t Data.Functor.Foldable.ana
09:57:41 <yahb> lyxia: Corecursive t => (a -> Base t a) -> a -> t
09:57:41 <reallymemorable> ive tried multiple permutations -- single line and 2 lines indented
09:57:50 <fresheyeball> lets say we have a type isomorphic to maybe
09:58:00 <fresheyeball> and we want to use maybe's instances
09:58:07 <fresheyeball> but provide semantic patterns
09:58:19 <fresheyeball> I was thinking we should be able to do something like this
09:58:20 <Taneb> % :t Data.Functor.Foldable.ana @Numeric.Natural.Natural
09:58:20 <yahb> Taneb: (a -> Maybe a) -> a -> GHC.Natural.Natural
09:58:42 <lyxia> fancy
09:59:01 <geekosaur> reallymemorable, at this point I think we'd need to see a runnable example in a pastebin
09:59:03 <fresheyeball> newtype Foo = Foo (Maybe Int)
09:59:07 <fresheyeball> then
09:59:12 <Taneb> % :t Data.Functor.Foldable.apo @Numeric.Natural.Natural
09:59:12 <yahb> Taneb: (a -> Maybe (Either GHC.Natural.Natural a)) -> a -> GHC.Natural.Natural
09:59:38 <fresheyeball> pattern PortNumer :: Int -> Foo
09:59:40 <fresheyeball> and 
09:59:49 <fresheyeball> pattern NoPortNumber :: Foo
10:00:06 <fresheyeball> this works
10:00:21 <fresheyeball> but now the compiler can't figure out that if we use both of these, its exhuasitve
10:00:50 <geekosaur> I think that's a known bug in the checker?
10:00:52 <fresheyeball> do PatternSynonyms usually hurt exhaustivity?
10:00:59 <geekosaur> in short, yes
10:01:01 <fen> Taneb: will that fuse?
10:01:13 <fresheyeball> geekosaur: has it been fixed?
10:01:14 <Taneb> fen: I've got no idea
10:01:29 <geekosaur> I don't think so
10:02:30 <fen> if there were unfold / fold / build for containers of fixed contents it would
10:02:39 <reallymemorable> geekosaur: i figured it out
10:02:47 <reallymemorable> it was within a case statement but not indented properly
10:15:07 <fen> there are no fusion rewrite rules or inline pragmas, can we expect it to inline anyway?
10:18:58 <NickSeagull> geekosaur: apparently is has something to do with Nix and the way it handles GHC paths, given that if I build it with Stack on OSX, it works
10:19:12 <NickSeagull> If I build it with Nix it doesnt
10:19:19 <NickSeagull> (inside a nix-shell that is)
10:19:35 <NickSeagull> thanks for your time and help :)
10:41:00 <dmwit> fresheyeball: There is a pragma you can use. {-# COMPLETE PortNumber, NoPortNumber #-}
10:41:40 <fresheyeball> oh really
10:42:13 <dmwit> % :t Data.Functor.Foldable.apo
10:42:13 <yahb> dmwit: Corecursive t => (a -> Base t (Either t a)) -> a -> t
10:42:55 <dmwit> I see.
10:44:37 <fresheyeball> dmwit: can I lie to that pragma?
10:45:16 <dmwit> You can, yes.
10:46:02 <fresheyeball> dmwit: so we can break the type system there, good to know
10:46:12 <dmwit> No?
10:46:14 <phadej> you can introduce run-time error
10:46:16 <phadej> that's different
10:46:59 <phadej> "breaking type system" is usually considered deriving non-looping `a -> b`; which would cause seg faults
10:47:04 <dmwit> The type system guarantees that a term of one type is never given to a context expecting a term of a different type. It makes no guarantees at all about case completeness.
10:47:32 <phadej> i.e. unsafeCoerce
10:48:04 <fresheyeball> I should have said, introduce a runtime error
10:48:12 <fresheyeball> that is more correct I agree
10:48:40 <fresheyeball> still it seems unfortunate and fixable
10:49:07 <fresheyeball> maybe keep the pragma
10:49:19 <fresheyeball> but construct the contents in the pragma to a case
10:49:21 <fresheyeball> and check it
10:49:26 <fresheyeball> so we can't lie in the pragma
10:50:26 <fresheyeball> or maybe there is some value in the ability to lie
10:51:32 <dmwit> fresheyeball: COMPLETE is sometimes used with GADTs where it can be quite difficult indeed to establish the veracity of the claim.
10:51:52 <dmwit> As far as I know there is no proposal for a sound and complete completeness checker in the presence of GADTs.
10:52:13 <fresheyeball> interesting
10:52:17 <fresheyeball> just not possible?
10:52:33 <dmwit> I'm not sure I've seen a claim that it's impossible. Just that nobody knows how to do it.
10:53:50 <dmwit> Ah, no, here's a paper that claims it. "We also show that the exhaustiveness problem is undecidable for GADTs".
10:53:55 <dmwit> https://www.math.nagoya-u.ac.jp/~garrigue/papers/gadtspm.pdf
10:53:56 <ziman> is that not undecidable? :) i imagine you could model the collatz conjecture or something in the indices and then coverage would depend on it
10:54:14 <dmwit> "GADTs and exhaustiveness: looking for the impossible" by Jacques Garrigue and Jacques Le Normand
10:55:13 <c_wraith> nothing in collatz hypothesis appears undecidable. I guess it could be, but it seems more likely to just be unknown.
10:55:38 <ziman> fair enough :)
10:55:47 <ziman> they argue with a turing machine instead
10:56:02 <c_wraith> still something you don't want to ask the type checker to solve. :)
10:56:09 <ziman> collatz is just a good example of an "arbitrary" thing to decide
10:57:40 <__monty__> Does shadowed dependencies sound familiar to anyone? (Using cabal new-test.)
10:58:51 <phadej> fwiw, Agda simply forbids you to match on such cases
10:59:17 <phadej> but that's falling on the other side of the fence
10:59:36 * hackage cmark 0.5.6.3 - Fast, accurate CommonMark (Markdown) parser and renderer  https://hackage.haskell.org/package/cmark-0.5.6.3 (JohnMacFarlane)
11:01:25 <phadej> https://www.microsoft.com/en-us/research/wp-content/uploads/2016/08/gadtpm-acm.pdf is more comprehensible paper on the topic for Haskell people
11:11:37 * hackage generics-eot 0.4.0.1 - A library for generic programming that aims to be easy to understand  https://hackage.haskell.org/package/generics-eot-0.4.0.1 (SoenkeHahn)
11:48:06 * hackage cornea 0.2.0.0 - classy optical monadic state  https://hackage.haskell.org/package/cornea-0.2.0.0 (tek)
11:51:54 <shapr> so corny
12:38:37 <trcc> Could someone give me an approach to solving this? I can make it work, but it is a really ugly solution. https://gist.github.com/CThuleHansen/dfc0f614f34f4c10eee1390d92fc6248
12:42:01 <Solonarv> I'd be tempted to use MaybeT, I'll leave a comment on your gist
12:42:26 <trcc> Solonarv: thank you.
12:45:44 <Solonarv> trcc: left a comment
12:45:47 <trcc> Solonarv: I will go through it. Maybe I ahve some questions
12:45:51 <trcc> Thank you
12:49:18 <dminuoso> trcc: You could also write a guardM combinator on the spot.
12:49:29 <trcc> if am completely unfamiliar with the guard construct
12:49:32 <trcc> so I will look it up
12:50:57 <dminuoso> trcc: Also you could simply get its FileStatus and discriminate on that.
12:51:02 <trcc> Solonarv: I updated the gist with the error I am getting - I will try to fix it
12:51:47 <trcc> dminuoso: that might be more simple
12:53:12 <dminuoso> trcc: Depending on your usecase, your entire function might be replaceable by:
12:53:21 <dminuoso> % import System.Posix.Files
12:53:21 <yahb> dminuoso: 
12:53:25 <dminuoso> % :t getFileStatus
12:53:25 <yahb> dminuoso: FilePath -> IO FileStatus
12:53:30 <trcc> yes, that is what I am looking up
12:53:38 <trcc> I did not know that
12:53:40 <trcc> thanks
12:54:35 <slack1256> What is the difference between yahb and lambdabot?
12:54:47 <dminuoso> slack1256: yahb is bolted ontop of GHCi, lambdabot is special.
12:56:16 <slack1256> Cool
12:56:20 <dminuoso> slack1256: Also lambdabot is far more than just a Haskell repl frontend, it houses many different plugins.
12:56:56 <Solonarv> a notable consequence of this:
12:57:02 <Solonarv> > putStrLn "hello"
12:57:04 <lambdabot>  <IO ()>
12:57:08 <Solonarv> % putStrLn "hello"
12:57:08 <yahb> Solonarv: hello
12:57:51 <slack1256> How do you know what is in scope for yahb? $ :imports doesn't work
12:58:12 <dminuoso> % :imports
12:58:12 <yahb> dminuoso: unknown command ':imports'; use :? for help.
12:58:18 <Solonarv> %% :show imports
12:58:18 <yahb> Solonarv: http://qp.mniip.com/y/4
12:58:34 <slack1256> Nice
12:58:42 <dminuoso> slack1256: :imports is not a valid GHCi command either AFAICT
12:59:04 <kuribas> :t fmap (join . fmap sequence)
12:59:05 <lambdabot> (Functor f, Traversable t, Monad m) => f (m (t (m a))) -> f (m (t a))
12:59:20 <kuribas> is there a better way to write this?
12:59:59 <dminuoso> kuribas: join . fmap smells like =<<
13:00:17 <Solonarv> trcc: I noticed that type error right after posting my comment, I edited it with a fix
13:00:18 <kuribas> :t \f -> join . fmap f
13:00:19 <lambdabot> Monad m => (a1 -> m a2) -> m a1 -> m a2
13:00:44 <Solonarv> :t fmap (>>= sequence)
13:00:46 <lambdabot> (Functor f, Traversable t, Monad m) => f (m (t (m a))) -> f (m (t a))
13:01:47 <kuribas> right :-)
13:02:54 <kuribas> I am trying to write "linkGraph :: IntMap (f Int) -> Maybe (IntMap (Fix f))"
13:03:10 <kuribas> well Traversable f
13:03:52 <trcc> Solonarv: thank you. I think I will stick to this, as filestat will not work on windows I guess
13:04:19 <kuribas> connecting the links in the graph directly, instead of using the map.
13:16:05 <__monty__> Still stuck on my shadowed dependencies issue: http://ix.io/1DpI Why does this happen/how do I go about fixing it?
13:22:25 <kuribas> is there a shorter way to write "traverse (fmap Rec . sequence)" ?
13:23:34 <utdemir> If I want to compile an executable with '-fllvm'; shouldn't the libraries it depends on be compiled with 'llvm'?
13:25:08 <kuribas> utdemir: I don't think so
13:25:17 <kuribas> it's binary compatible
13:32:11 <reallymemorable> in a definition like the following, what sort of element is `a`?  data TypeName a = TypeName
13:36:25 <glguy> a is a type variable
13:36:34 <glguy> It will default to having kind *
13:37:36 <Solonarv> it's similar to the 'T' in (java) 'class Foo<T> { ... }' or (c++) 'template<typename T> class foo { ... }'
13:41:36 * hackage dfinity-radix-tree 0.6.0 - A generic data integrity layer.  https://hackage.haskell.org/package/dfinity-radix-tree-0.6.0 (EnzoHaussecker)
13:49:22 <dmwit> It's funny calling it an "element", too, since it's not used on the RHS. =)
13:56:36 * hackage dfinity-radix-tree 0.6.1 - A generic data integrity layer.  https://hackage.haskell.org/package/dfinity-radix-tree-0.6.1 (EnzoHaussecker)
13:59:50 <reallymemorable> ok so its just an undefined type 
13:59:52 <reallymemorable> thanks
14:04:47 <Boarders> hey I have some property tests with quickcheck but if I do cabal new-run project:tests then it just uses the previous results rather than rerunning
14:04:53 <Boarders> is there anyway I can get it to rerun the tests
14:04:56 <Boarders> I am using tasty
14:05:07 <Solonarv> reallymemorable: it's not "undefined" any more than the 'x' in 'f x = x * 2' is undefined
14:17:09 <reallymemorable> I'm having trouble composing some functions: https://paste.ofcode.org/V65uBXUTzsTr3DV2pEH6ku
14:17:29 <delYsid> Gah, the xillion string types of haskell are a real turnoff
14:17:32 <reallymemorable> I want to compose such that First (Maybe) end up around MConfig
14:17:36 <reallymemorable> not the entire expression
14:18:10 <kuribas> delYsid: there are only 4
14:18:16 <Boarders> there are not only 4
14:18:39 <kuribas> delYsid: in fact only 2 in 2 variants (lazy and strict)
14:18:43 <Boarders> String, Text (Lazy, Strict), ByteString (Lazy, Strict), ShortText, ShortByteString just off the top of my head
14:18:52 <kuribas> Boarders: ByteString isn't a string
14:18:55 <kuribas> it's a binary blob
14:18:59 <Boarders> yes well
14:19:02 <Rembane> ...with an unfortunate name.
14:19:09 <kuribas> sure
14:19:11 <Boarders> the claim holds
14:19:20 <Boarders> I could still say UTF-8 vs UTF-16
14:19:23 <delYsid> kuribas: at least 5 I know of, considering all the lazy/strict crazyness
14:19:27 <Boarders> but either way there are not only 4
14:19:36 <Boarders> but the thing is there are that many because strings are complicated!
14:20:15 <kuribas> delYsid: it's not crazy.  Lazyness gives you streaming variants.
14:20:20 <delYsid> kuribas: Nice, but when I do a web request, I still get a bytestring, which I need to convert somehow. bah
14:20:40 <delYsid> yeah, but it feels totally random what a library imposes on me
14:21:02 <kuribas> delYsid: yes, because what you get from the request isn't interpreted yet.
14:21:14 <delYsid> how do I go from ByteString to String again, and please, dont lecture me on not using String.
14:21:29 <Boarders> toString?
14:22:02 <Boarders> is thre such a function
14:22:16 <kadoban> Well, what encoding is it?
14:22:39 <delYsid> utf8 or ascii.
14:22:41 <kuribas> delYsid: one of the encoding libraries.  And yes, I'd use Text
14:23:10 <delYsid> kuribas: I'd want to use Text too.  But the next function I want to pass the result to actually takes a String!
14:23:12 <Boarders> there is this: http://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString-Char8.html#v:unpack
14:23:45 <kuribas> delYsid: for example: http://hackage.haskell.org/package/encoding
14:24:07 <kuribas> the only redundancy is String/Text
14:24:32 <delYsid> OK, last try, and if I get another compile error, I'll just leave it at that for now.
14:24:43 <delYsid> Just said, its a turnoff.  I (used to) do this for fun.
14:25:19 <kuribas> I agree that it's a turnoff
14:25:41 <Boarders> I think it is just being honest that you use textual data for different purposes
14:26:44 <kuribas> ByteString/Text makes total sense
14:26:48 <kuribas> lazy/strict also
14:27:12 <kuribas> much better than treating binary data as text with an encoding
14:28:48 <delYsid> With all the quaalification, its hard to see what you will get.  Everything is named ByteString, but once you compile your stuff, the compiler throws Data.ByteString.Lazy.Internal.ByteString is not a Data.ByteString.Internal.ByteString at you.  That is just horrible!
14:29:51 <delYsid> And why do I have to read Internal, just because the package designer was fond of artifically hiding stuff, if it ends up in the compiler messages anyway!
14:30:22 <delYsid> Gah, I should leave it at that for today.  Sorry for ranting.
14:31:11 <kuribas> delYsid: IMO what sucks the most is that a lot is still based around String, like error, show, etc..
14:32:01 <delYsid> Yeah, had that also today.  Switched to Text, just to realize that I would need to depend on a whole package just to get a show function which emits Text.
14:32:45 <kuribas> OTOH maybe show isn't intended for program output...
14:32:52 <kuribas> rather for debugging
14:33:17 <delYsid> I disagree.  I was generating haskell code, which is something where show actually shines!
14:33:34 <utdemir> If I want to compile an executable with '-fllvm'; shouldn't the libraries it depends on be compiled with 'llvm'?
14:33:35 <Rembane> How do you print an Int without using show? 
14:33:46 <kuribas> utdemir: no
14:33:51 <Rembane> Or ... Int -> Text
14:34:11 <utdemir> Rembane: Text.Printf?
14:34:21 <Rembane> utdemir: Good point. Thank you! 
14:35:07 <utdemir> kuribas: So, in the end you can have an executable partly compiled with NCG, and partly with LLVM?
14:35:31 <delYsid> Couldn't match expected type ‘Data.ByteString.Internal.ByteString’ with actual type ‘Data.ByteString.Lazy.Internal.ByteString’
14:35:34 <delYsid> Wonderful, again!
14:36:44 <kuribas> Rembane: Data.Text.Lazy.Builder.Int?
14:37:00 <kuribas> delYsid: are you mixing lazy with strict?
14:37:22 <kuribas> delYsid: otherwise this could be a dependency issue.
14:37:27 <delYsid> kuribas: Sure I do.  I keep forgetting what Wreq.get actually returns.
14:37:35 <kuribas> delYsid: conflicting versions
14:37:53 <delYsid> nah, it used to work, I am just to dumb.
14:38:20 <kuribas> Rembane: toLazyText . decimal
14:38:33 <kuribas> delYsid: maybe just tired and need a break?
14:38:40 <kuribas> :t toLazyText . decimal
14:38:41 <lambdabot> error:
14:38:41 <lambdabot>     Variable not in scope: toLazyText :: p String (f String) -> c
14:38:59 <delYsid> kuribas: You're right.
14:39:30 <kuribas> but yeah, the module system can be confusing
14:39:40 <kuribas> I don't think thats entirely related to String
14:44:27 <kuribas> They should have named ByteString BinaryBlob
14:46:06 <shapr> whoa, this is really fun: https://tech.channable.com/posts/2019-03-13-how-we-made-haskell-search-strings-as-fast-as-rust.html
14:47:32 <utdemir> Yeah, but it's sad that LLVM is faster for some use cases, but also slower for some. Does anyone know what kind of code benefits from LLVM codegen more?
14:48:06 <delYsid> ghc: sorry! (unimplemented feature or known bug)
14:48:11 <delYsid> OK, now I really go to sleep
14:49:24 <shapr> utdemir: I want to compare -fllvm on my advent of code solutions, curious which ones will be faster
14:50:24 <utdemir> shapr: I would love to read a blog post about it :)
14:52:11 <kuribas> utdemir: math heavy code?
14:53:09 <utdemir> kuribas: I thought about that, but the wiki page for LLVM backend mentions that CloudHaskell tests also got a lot faster. I wouldn't consider those as math heavy.
14:56:56 <Solonarv> I think the llvm compiler performs optimizations as well; it doesn't surprise me that adding more optimizations would make code go faster
14:57:27 <kuribas> lower level optimizations, so I think lower level code will benefit from it
15:00:52 <shapr> I keep meaning to set up a blog again...
15:02:10 <Solonarv> I have one using hakyll+github pages but it was a bit of a pain to set up
15:02:53 <Solonarv> I'm not sure if I'd recommend that particular combinatin
15:04:04 <shapr> Solonarv: I had one of those too, also a bit painful
15:04:55 <Solonarv> On reflection, most of the pain actually came from hakyll, which is a bit saddening
15:06:21 <reygoch> Is it possible to turn on something in GHCi so that types in error messages are always fully evaluated?
15:09:09 <remexre> for some reason Happy isn't recognizing my EOF token as an EOF anymore; does this mean I broke my grammar, or is there something subtle I might've broken instead?
15:10:06 <Ariakenom> shapr: in that blog. is the first automaton diagram missing an arrow 6->12 ?
15:12:33 <hpc> remexre: just use an infinite stream :P
15:13:27 <remexre> an infinite stream of EOFs?
15:14:08 <remexre> my issue is that I'm getting the EOF as an unexpected token to my happyError function
15:20:08 <Lears> utdemir: This is just what I gather from reading the GRIN paper, but low level optimisation of code generated from lazy functional languages is thwarted by indirection and unknown control flow, the latter of which CloudHaskell probably needs to restrict for its own reasons.
15:21:15 <utdemir> Lears: Really interesting. I'll take a look at it.
15:27:19 <remexre> ohhhhhhh nvm I messed my lexer up
15:27:23 <remexre> unrelatedly
15:27:44 <remexre> is there a `class Functor f => Foo f where bar :: f a -> a` ?
15:28:10 <remexre> for e.g. writer monads, Identity, (a,), etc
15:31:20 <Solonarv> remexre: that's half of Comonad
15:31:34 <Solonarv> it also exists "standalone" as Copointed
15:31:36 * hackage fixed-timestep 0.1.0.0 - Pure Haskell library to repeat an action at a specific frequency.  https://hackage.haskell.org/package/fixed-timestep-0.1.0.0 (Solonarv)
15:31:50 <Solonarv> % :i Comonad
15:31:50 <yahb> Solonarv: class Functor w => Comonad (w :: * -> *) where; extract :: w a -> a; duplicate :: w a -> w (w a); extend :: (w a -> b) -> w a -> w b; {-# MINIMAL extract, (duplicate | extend) #-}; -- Defined in `Control.Comonad'; instance [safe] (a ~ b) => Comonad (Context a b) -- Defined in `Control.Lens.Internal.Context'; instance [safe] (a ~ b, Conjoined p) => Comonad (Bazaar1 p a b) -- Defined in `Control
15:32:05 <ocharles> Does anyone know something I can drop into GHCI to measure the heap size of a value?
15:32:09 <remexre> huh, I haven't actually done anything (including reading about them) with comonads before
15:32:21 <ocharles> E.g., `:magic Data.Map.Strict.FromList [(True, 'a'), (False, 'b')]`
15:32:48 <Solonarv> ocharles: perhaps compact regions might help?
15:33:16 <ocharles> Hmm, perhaps - there is `compactSize`
15:33:52 <ocharles> maybe ghc-heap-view can do this
15:57:58 <Henson> hi all, here's a follow up from a question I asked earlier today, with code examples!
15:58:33 <Henson> I have a bracket function that I'm trying to use in a set of generic tests, but I'm having problem with the type inference fixing the output of the bracket function I'm trying to pass in
15:58:48 <Henson> here's an example that does work: https://hastebin.com/zuladicoga.rb
15:59:02 <Henson> where "withFunction" is the bracket function and testFunction is the test suite
15:59:19 <Henson> here's an example of what I'm trying to do that doesn't work: https://hastebin.com/eyeluyojef.coffeescript
15:59:59 <Henson> I'm trying to make testFunction accept a "withFunction" that may change.  The generic test suite ideally would accept different bracket functions that change
16:14:00 <lyxia> Henson: what you intend is that testFunction takes a polymorphic function.
16:15:08 <lyxia> But in standard Haskell that's not possible. You need to enable RankNTypes and use  testFunction :: (forall b. (Int -> IO b) -> IO b) -> IO ()
16:16:57 <Henson> lyxia: awesome!  that worked!
16:16:58 <lyxia> Actually you can also avoid rankntypes, by using a typeclass instead, that's an indirect way of passing polymorphic functions around.
16:17:33 <lyxia> e.g., whenever you're carrying a Functor constraint, that hides a polymorphic fmap
16:18:33 <Henson> lyxia: yeah, I considered making it a typeclass, but all of the individual test functions would have to be implemented individually, instead of just passing in a single withFunction
16:19:48 <lyxia> I'm not sure I understand that
16:20:58 * Henson thinks
16:22:24 <Henson> lyxia: in my test suite, there's one function that calls a whole bunch of sub functions.  Each of those sub functions uses a resource bracket and I use a "withResource" function that is similar to the "withFunction" in my example.
16:22:38 <orion> Hi. I am building an application with Persistent. I would like to use mtl style for my functions (i.e. foo :: MonadTime m => m () as opposed to foo :: App ()). Unfortunately, functions like "get" (https://www.stackage.org/haddock/lts-13.12/persistent-2.9.1/Database-Persist-Class.html#v:get) have typed in terms of ReaderT. As a result, I am finding myself using "flip runReaderT dbConn $ do ..." all over the 
16:22:38 <orion> place. This is despite the fact that I have defined an AppEnv that includes the dbConn.
16:23:24 <Henson> lyxia: if I were to implement the test suite as a class, I still wouldn't be able to pass in a specific withResource function to override the generic one in the class without running into the same output type problem that I'm currently experiencing
16:23:40 <orion> In other libraries there are classes such as, "HasEnv a" which I can use to avoid using runReaderT everywhere.
16:23:47 <lyxia> Henson: https://gist.github.com/Lysxia/9646a3a009cab563def73dd46e88c939 this is what I mean
16:23:49 <orion> But in Persistent that doesn't seem to be the case.
16:23:56 <Henson> lyxia: unless I were to specify every function in the test suite as a function in the class, and then implement all of them in the more specific version of the tests
16:23:57 * Henson looks
16:26:15 <Henson> lyxia: hmm, that's an interesting way of doing it.
16:26:48 <Henson> lyxia: but it's not as clear to me as the RankNTypes way of doing it.  Is there a reason to avoid RankNTypes and do the class method instead?
16:27:12 <Henson> lyxia: also, can you explain further what you meant by "whenever you're carrying a Functor constraint, that hides a polymorphic fmap"
16:28:06 <fen> not really a well formed question, but everywhere Ints are used there are now [()], and even now (s,s -> ((),s))   
16:28:32 <fen> is this exessive use of state encoding ok?
16:28:45 <Solonarv> any time you have 'func :: Functor f => ...; func = ... fmap ...', you "really" have 'func :: (forall a b. (a -> b) -> f a -> f b) -> ...; func fmap = ... fmap ...'
16:31:12 <fen> Solonarv: like saying a constraint implicitly provides the functions of the corresponding class as arguments to the constrained function?
16:31:48 <lyxia> Henson: there's no reason, I just found it a fun observation that we already have the expressiveness of RankNTypes like that :)
16:33:04 <Solonarv> fen: yes - well, really for typeclasses with more than one method it's a record instead (in GHC), but that's the idea
16:35:24 <Henson> well, I still have a lot to learn about Haskell types!
16:35:41 <fen> actually there is a question, by using the state encoding instead of the list it would unfold, this makes the function the state is passed into *demand* value from the state, like, it has to do the unfolding. then it could have the option of returning a partially consumed state
16:35:55 <Henson> thanks for the explanation lyxia, and additional commenting Solonarv
16:37:39 <fen> just not used to this idea of using something that would "unfold" an Int, and the extra control this gives.
16:39:47 <fen> as, in, if states are thought of as being unfolded, then they just keep producing values, as unfold does not control the production, or, equivalently, it just keeps getting values from the state
16:46:46 <fen> for example Nat - Nat could return a remainder, and its implementation would be const tail as a consumer of () 
16:54:09 <fen> there must be some abstraction for this pattern, of recursions matching a producer and consumer of () to repeatedly do something, and with the generalisation to use something more than ()
16:57:58 <Henson> so what's the difference between RankNTypes and ExistentialQuantification?  They both seem to use the forall keyword.
17:01:11 <lyxia> RankNTypes could be said to be "UniversalQuantification" (but it's much more powerful than the duality might suggest), and the main reason ExistentialQuantification uses forall is to avoid sitting on one more keyword.
17:02:49 <lyxia> ExistentialQuantification allows you to declare data types which forget the types of their fields.   data Useless = forall a. Useless a
17:03:38 <lyxia> RankNTypes makes polymorphic functions first-class (you can pass them around).
17:09:08 <Solonarv> lyxia: I like the name you gave that type ;)
17:09:30 <Henson> lyxia: how did you learn about all this advanced type stuff?
17:31:48 <lyxia> Henson: I had very nice classes on compilers, type systems and functional programming. And did lots of random hacking to try out various features.
17:32:34 <lyxia> Henson: The book Types and Programming Languages is pretty good reading.
17:35:11 <hpc> the ghc manual explains how to use the extensions fairly well too, mainly from a perspective of "here's how you put this in your code"
17:35:42 <hpc> combined with experimentation and some choice googling to get comfortable using it, then the pure theory isn't as intimidating
17:41:06 * hackage massiv 0.2.8.0 - Massiv (Массив) is an Array Library.  https://hackage.haskell.org/package/massiv-0.2.8.0 (lehins)
17:42:40 <lukelau> How can I get forkIO to throw all exceptions on the child thread onto the parent thread?
17:45:10 <geekosaur> forkIO itself won't. async provides abstractions that should let you do that. (If you hve to do it yourself, forkIO a wrapper that catches all exceptions and rethrows them to the parent thread's ID; you'll need to fetch that before the forkIO.)
17:52:09 <phadej> async doesn't rethrow exceptions though
17:52:20 <phadej> it makes an ref which you can wait on
17:52:34 <phadej> (and either get an exception or a value)
17:52:50 <phadej> if you can avoid async exceptions, please do
17:55:45 <Solonarv> async also lets you ask for exceptions to be re-thrown, but it doesn't happen by default
17:56:04 <Solonarv> you can use 'link' to get them re-thrown
17:57:08 <Solonarv> % forkRethrowing inner = do parent <- myThreadId; forkIO (inner `catch` \(e :: SomeException) -> throwTo parent e)
17:57:08 <yahb> Solonarv: 
17:57:14 <Solonarv> % :t forkRethrowing
17:57:14 <yahb> Solonarv: IO () -> IO ThreadId
17:57:52 <Solonarv> you'll need some extra masking/unmasking noise, so please don't actually use that.
17:58:31 <Solonarv> % forkRethrowing (print (1/0))
17:58:31 <yahb> Solonarv: ThrIenafdiIndi t1y0; 3
17:58:40 <Solonarv> Yikes.
17:58:47 <MarcelineVQ> looks legit
17:59:23 <Solonarv> haha
17:59:26 <Solonarv> yeah just use async
17:59:36 <Solonarv> it Does The Right Thing™
18:04:34 <Boarders> could someone tell me how I get cabal to not suppress warnings when building?
18:16:16 <Henson> lyxia: what does polymorphism in the RankNTypes context mean?  The withFunction example I had earlier with type ((a -> IO b) -> IO b) is already polymorphic in the C++ sense, but in what sense is (forall b. ((a -> IO b) -> IO b)) different?
18:19:11 * Henson reads the GHC manual
18:20:05 <Solonarv> Henson: roughly speaking, the difference is who gets to pick what the type variables are specialized to
18:20:31 <Solonarv> (and a polymorphic function must work for all types that the variables could be instantiated with)
18:22:46 <Henson> Solonarv: could you briefly describe the "who"s in the different cases?
18:22:58 <lyxia> Henson: "forall" is implicit in the signature of withFunction,  withFunction :: forall b. (Int -> IO b) -> IO b
18:24:44 <Solonarv> Henson: sure, there is only one case: for a function 'foo :: forall a b c. stuff', the caller of 'foo' gets to instantiate the type variables
18:25:16 <Solonarv> and 'foo' must work for any choice of a, b, c
18:27:18 <Henson> lyxia: so in my example that didn't work, why does Haskell add an implicit forall in the withFunction case, and not in the testFunction case?  Or is the problem that the implicit forall isn't nested inside the withFunctionIn signature?
18:28:01 <Solonarv> in 'useBracket :: forall m. (forall a b. m a -> (a -> m ()) -> (a -> m b) -> m b) -> whatever', the argument of 'useBracket' has the type 'forall a b. stuff', so the argument must work for any choice of a, b
18:28:23 <Solonarv> and 'useBracket' is calling its argument, so 'useBracket' gets to pick a, b
18:29:11 <Solonarv> 'useBracket' itself has the type 'forall m. stuff', so it must work for any choice of m
18:29:35 <Solonarv> (note: there should be a Monad m => constraint there, I forgot to add it)
18:30:37 <Henson> Solonarv: but if "forall a b." wasn't in there, then who gets to pick a and b?
18:31:01 <Solonarv> Henson: well, the type variables need to come from somewhere
18:31:41 <Solonarv> for any type signature 'func :: stuff', there is an implicit 'forall' which lists all the free type variables in 'stuff'
18:31:56 <lyxia> Henson: the "forall" only gets inserted implicitly at the left end of the type, just after ::.
18:32:17 <Solonarv> e.g. 'map :: (a -> b) -> [a] -> [b]' is really 'map :: forall a b. (a -> b) -> [a] -> [b]'
18:42:40 <Henson> so if I have testFunction :: ((a -> IO b) -> IO b) that's really testFunction :: forall a b. ((a -> IO b) -> IO b)
18:43:29 <Solonarv> yep
18:44:08 <Solonarv> ...well, if that's a type signature on the declaration for testFunction
18:44:24 <Henson> oops, that type signature was wrong, let me try again
18:44:47 <Henson> testFunction :: ((a -> IO b) -> IO b) -> IO () that's really testFunction :: forall a b. (((a -> IO b) -> IO b) -> IO ())
18:44:58 <dmwit> Henson: You might like the discussion at the beginning of https://stackoverflow.com/a/42821578/791604 for your "could you briefly describe the 'who's in the different cases?" question
18:44:59 <Solonarv> yes
18:45:25 <Solonarv> also, in 'forall a b. stuff', you don't need parentheses around 'stuff'
18:45:26 <Henson> so what's the critical difference when the signature changes (without the implicit forall) to testFunction :: (forall b. ((a -> IO b) -> IO b)) -> IO ()
18:45:31 <dmwit> It doesn't cover existentials, but it does cover universals.
18:47:45 <Henson> Solonarv: did you see the hastepaste stuff I posted about 2.5 hours ago describing my problem?  I don't want you to be missing context of my core problem for which lyxia suggested using RankNTypes.
18:49:07 <dmwit> (The four bullet points, if taken slowly, should be enough to answer your question about the difference between `forall a b. ((a -> IO b) -> IO b) -> IO ()` and `forall a. (forall b. (a -> IO b) -> IO b) -> IO ()`.)
18:49:41 <Henson> dmwit: ok, I'll read it now
18:49:43 * Henson reads
18:50:01 <dmwit> In the language used there: for `forall a b. ...`, the caller gets to choose `b`, while for `forall a. (forall b. ...) ...`, the implementer gets to choose `b`.
18:50:50 <Solonarv> testFunction :: forall a b. ((a -> IO b) -> IO b) -> IO ()
18:50:50 <Solonarv>  - whoever calls 'testFunction' can pick whatever they want for 'a' and 'b'; the implementation of 'testFunction' can't use its argument in a way that would constrain 'a' or 'b' in any way
18:50:50 <Solonarv> testFunction :: (forall a b. (a -> IO b) -> IO b) -> IO ()
18:50:50 <Solonarv>  - whoever calls 'testFunction' must pass it a 'func :: forall a b. (a -> IO b) -> IO b' that works for any 'a' and 'b'; 'testFunction' can pick whatever it wants for 'a' and 'b', even multiple different things if it's called multiple times
18:59:51 <Henson> Solonarv, dmwit, lyxia: thanks for your help on this.  I have a better understanding of this now, and some resources to read over to understand it even better.
19:40:06 * hackage cmark-gfm 0.1.8 - Fast, accurate GitHub Flavored Markdown parser and renderer  https://hackage.haskell.org/package/cmark-gfm-0.1.8 (kivikakk)
20:47:01 <stevejb> Greetings, I am trying to use HODBC to connect to a mssql server. I am running into an issue as described here: https://github.com/hdbc/hdbc-odbc/issues/28
20:47:25 <stevejb> It seems that there are other issues like that with ODBC. Is there a better way to connect to an MSSQL database?
20:48:59 <stevejb> Ah, nevermind. Just found https://www.stackage.org/lts-13.12/package/odbc-0.2.2
21:25:54 <jgt1> if my application depends on lens anyway, is there anything wrong with using (&) for left-to-right function composition?
21:29:59 <Solonarv> jgt1: that isn't even from lens, it's defined in base
21:30:04 <Solonarv> % :i &
21:30:16 <yahb> Solonarv: (&) :: a -> (a -> b) -> b -- Defined in `Data.Function'; infixl 1 &
21:30:33 <jgt1> oh right
21:30:36 <Solonarv> also, it's not function composition - it's function application
21:30:45 <jgt1> yeah I just realised that too
21:31:03 <kadoban> <<< is close to function composition, but it's more general (and the precedence is weird compared to (.))
21:31:21 <kadoban> I personally give it a new name when I use it
21:31:30 <kadoban> s/<<</>>>/
21:31:55 <jgt1> basically I thought a certain function I have would be written a little nicer composing left to right — if this were Elm I'd be using (|>) — but I didn't want to pull in the Flow package as a dependency just for that
21:32:27 <kadoban> You can just name it yourself, it's two lines
21:33:00 <Solonarv> well, three with the fixity declaration
21:33:19 <kadoban> Oh I forgot the type annotation
21:35:04 <jgt1> that's a good point
21:35:08 <jgt1> thanks for the help everyone :)
