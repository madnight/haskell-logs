01:21:09 <delYsid> runStmt $ "let externalPrint = read " <> show (show wFd) <> " :: Fd" -- Thats it, took me a while to punch a hole into the interpreter/runtime separation!
01:38:54 <merijn> ugh, packages hosted on darcs are annoying, no easy way to provide patches
01:40:38 * hackage fedora-haskell-tools 0.7 - Building and maintenance tools for Fedora Haskell  https://hackage.haskell.org/package/fedora-haskell-tools-0.7 (JensPetersen)
01:41:16 <Adeon> is it because there is no good medium to send patches into or that darcs doesn't take in diff format propoerly?
01:41:42 <merijn> Adeon: I don't wanna download and install darcs just to be able to checkout a repo and submit a trivial patch
01:41:52 <Adeon> oh I see
01:42:11 <merijn> Also, unclear how/where to send patches
02:42:48 <merijn> ugh...I wish there was a "standard" zipWith for unequal length lists
02:47:03 <reygoch> merijn: What do you mean?
02:47:40 <merijn> reygoch: zipWith truncates the result to the shortest list
02:47:54 <reygoch> merijn: yes, that's what I'd call standard, no?
02:48:07 <merijn> reygoch: I want one that doesn't
02:48:23 <reygoch> merijn: how do you imagine that would work?
02:48:43 <merijn> reygoch: Padding with a default element
02:49:17 <reygoch> merijn: seems like easy enough to do with default class.
02:49:43 <merijn> Default is a terrible class, but looks like these's Data.Align has what I want
02:50:04 <reygoch> or mempty?
02:50:57 <reygoch> or just pass what ever as an argument to padd with :D
03:29:46 <fr33domlover> Hi people! For my web app I need a thread pool, I looked at existing packages and none fits so I think I'll write my own. The primary reason existing stuff doesn't work for me is that in resource-pool and other packages the choice of resource/thread is arbitrary (pick any free resource), while in my case each worker thread is attached to some data and I need to choose based on that
03:30:05 <fr33domlover> Just saying in case anyone has other suggestions ^_^
03:36:23 <TMA> fr33domlover: shouldn't you have a pool for each data?
03:36:33 <reygoch> TMA: my thought exactly
03:37:14 <reygoch> fr33domlover: use map with your data as a key and pool as a value?
03:37:45 <reygoch> fr33domlover: would that fit your use case?
04:02:30 <fr33domlover> TMA, hmmm idk I'll describe the use case and let's see: A part of my database can be thought of as split into multiple independent pieces (e.g. it's a database about countries and each countries' data doesn't have links to the others). And I need (some of) each piece's database queries and some related HTTP requests to be serialized. So the idea is, if I need to schedule a job on a piece X and there's
04:02:33 <fr33domlover> already a thread working on it, I want to queue the job to that thread. And if there's no thread working on piece ֶX, just start/pick any worker thread
04:04:23 <fr33domlover> (Hmmm I guess instead of a thread pool I could simply use an MVar per piece, perhaps that's easier)
04:16:07 <zincy> Can someone check my a proof I am trying to write to show curry . uncurry is equivalent to id?
04:17:17 <TMA> zincy: I'll look into it; I do not promise I'll understand your symbolism // notation
04:17:18 <owhit> If I want to set a default flag for ghc, how would i do that?
04:17:42 <sicklorkin> zincy: ditto
04:18:10 <merijn> owhit: "default flag" in what sense?
04:18:10 <zincy> https://pastebin.com/piiJMTnd
04:18:51 <zincy> I show that  curry . uncurry and the inverse both always return the fst element of a tuple but this doesn't feel like the identity function as it ignore the second argument
04:19:26 <owhit> merijn: I want to set the -no-keep-hi-files to true by default when I go to compile, if possible
04:19:40 <owhit> Rather than type it in each time
04:20:22 <merijn> owhit: Normally I'd put that in my cabal file/cabal.project, depending on how you build
04:20:59 <owhit> merijn: I'll look into that. I haven't used cabal. Been calling ghc directly
04:21:19 <merijn> owhit: Also, why do you wanna stop it from making .hi files?
04:21:53 <TMA> zincy: I do see you demonstrate that "(uncurry . curry) fst (1,2)" yields 1 and that "(curry . uncurry) const 8 6" yields 8
04:22:40 <TMA> zincy: but that's not by any means a proof that either (uncurry . curry) or (curry . uncurry) is the same function as id
04:22:46 <owhit> merijn: I'm not doing anything serious in hs right now, and didn't want the extra files taking up space in my folder. Probably a silly reason...
04:23:15 <TMA> zincy: so far it is an unsuccessful attempt to find a counterexample
04:23:31 <merijn> owhit: GHC needs those to link between files, though, so you can't do that as soon as your code is >1 module
04:24:02 <merijn> owhit: Also, I'd just use cabal to build things, than all build artifacts are in dist/dist-newstyle and you can just nuke those when you don't want/need them anymore
04:24:15 <TMA> zincy: you need to show that  (uncurry . curry) x  yields x for any value of x
04:24:49 <TMA> zincy: and do the same for (uncurry . curry)
04:24:52 <zincy> TMA: thanks trying to work that our now
04:24:53 <zincy> out
04:24:58 <owhit> merijn: Oh for real? Point taken!
04:25:51 <Guest37> hey
04:30:02 <owhit> merijn: much thanks
04:30:12 <TMA> zincy: if you need to prove that f a = g b, show the steps evaluating both sides ;; it is not the same as running it, because you can show the equivalence even for nonterminating or otherwise bothersome expressions
04:31:16 <zincy> what about (uncurry . curry) fst = fst
04:31:29 <zincy> and (curry . uncurry) const = const
04:32:04 <TMA> zincy: well, writing it this way, you just claim it, you do not show it
04:33:51 <TMA> zincy: a proof is something where all the steps are so basic as you are reluctant to show them out of fear the reader will conclude you are thinking the reader is an idiot
04:33:52 <zincy> Ok try this
04:34:03 <zincy> b = (uncurry . curry)
04:34:22 <zincy> tup = (1 ::Int, 2::Int)
04:34:29 <zincy> (b fst) tup = 1
04:34:36 <zincy> fst tup = 1
04:34:51 <zincy> (b fst) tup = fst tup
04:35:00 <zincy> 1 = 1
04:35:10 <TMA> (b fst) tup = 1 still needs to be proven
04:35:31 <TMA> or (b fst) tup = fst tup
04:36:24 <zincy> So if I wrote (b fst) tup = 1 then would that complete it
04:36:25 <TMA> zincy: basically you need to demonstrate that (b x) = x
04:37:09 <TMA> zincy: if you wrote it, it would be another claim
04:37:52 <TMA> zincy: something that is neither given, nor immediately follows from things given or alreade proved
04:39:13 <TMA> zincy: let's step backwards. given peano arithmetic, prove that 1 + 1 = 2
04:39:57 <zincy> 1 + 1 = 2 thus 1 + 1 = 1 + 1
04:40:09 <zincy> 1 + 1 therefore = 2
04:40:25 <TMA> zincy: you'll need just the (forall x) x+0 = x and (forall x)(forall y) x + Sy = Sx + y
04:40:43 <TMA> and that 1 = S0 and 2 = SS0
04:41:49 <TMA> you cannot use 1 + 1 = 2 to expand the 2 into 1 + 1, because you are trying to prove it. 1 + 1 = 2 is not given
04:42:01 <zincy> right
04:44:24 <TMA> sorry, the second axiom is (forall x)(forall y) x + Sy = S(x+y)  -- not that it matters much, but the parenthesis is there for similarity with multiplication x * Sy = x + (x * y)
04:46:09 <TMA> zincy: in your task what are the givens? (1) the definitions of any functions used (2) the rules of evaluation
04:46:56 <zincy> So do I have to show how we apply the rules to get 2 from 1
04:47:03 <TMA> yes
04:47:18 <zincy> So start with the steps of evaluation to get 1 from 0?
04:48:43 <TMA> 1 is a shorthand notation for S0 .... 1 = S0 and 2 = SS0 are your givens, as is (forall x) x+0 = x and (forall x)(forall y) x + Sy = S(x+y)
04:48:43 <zincy> x + 0 = 1 and 1 + 0 = 1 which using Peano is S0 + 0 = S0
04:48:51 <TMA> yes
04:49:52 <zincy> Is that correct?
04:49:56 <TMA> yes
04:50:18 <TMA> you have proved that 1+0 = 1 successfully
04:50:23 <zincy> yay
04:50:37 <zincy> First ever proof
04:50:47 <TMA> now for the 1+1 = 2 ;
04:51:59 <TMA> first get rid of the ones and the two by using the givens
04:52:23 <zincy> S0 + S0 = SS0
04:52:40 <zincy> Then I guess I should explain each term there
04:55:11 <TMA> you have the S0 + S0 .... does it remind you of something given, that you can use to convert it to some different form?
04:55:34 <zincy> S0 + S0 is that second axiom
04:55:41 <TMA> correct
04:55:50 <merijn> zincy: Incidentally, if this sorta proofs interest you, you might wanna look at
04:55:52 <merijn> @where sf
04:55:53 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages",
04:55:53 <lambdabot> "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof assistant."
04:55:56 <merijn> ^^ that
04:56:07 <zincy> Awesome thanks!
04:56:20 <hpc> another way of phrasing it, that maybe makes the next step more obvious, the RHS matches the pattern S(_) - can you make the LHS match the same pattern
04:56:37 <hpc> then you have S(x) = S(y) and you solve for x=y
04:56:40 <TMA> zincy: or https://www.people.vcu.edu/~rhammack/BookOfProof/
04:59:40 <TMA> zincy: you have identified, that the second axiom can be used on S0 + S0. use it and show the result
05:00:31 <zincy> x + Sy = S(x+y) and S0 + S0 = SS0   x = S and y = 0   ... S + S(0) = S(S + 0)
05:00:49 <TMA> x = S0 actually
05:01:24 <TMA> lone S has no meaning in this theory
05:01:38 <zincy> x = S0 and y = 0 .... S0 + S(0) = S (S0 + 0)
05:01:47 <TMA> excellent!
05:01:52 <zincy> Is that it?
05:02:21 <TMA> still one step remaining. but you have already proven it in the 1+0=1 case
05:03:40 <TMA> zincy: < zincy> x + 0 = 1 and 1 + 0 = 1 which using Peano is S0 + 0 = S0
05:03:42 <zincy> Do we need to swap the variables round
05:03:56 <zincy> so x = 0 and y = S0 ?
05:04:11 <TMA> I do not understand;
05:04:38 <zincy> Ah
05:04:41 <hpc> try writing the whole equation, with your progress up to now on modifying the LHS
05:05:48 <zincy> S(0) + S(0) = S(S + 0)
05:05:57 <TMA> now you have S0 + S(0) = S (S0 + 0) ; S0 + 0 = S0 ; (forall x) x+0 = x ; (forall x)(forall y) x + Sy = S(x+y) ... you can treat all those as givens, because you have already proved them or they were given in the first place
05:06:09 <hpc> the right side is still the same, it's the left side you've been working with
05:07:21 <zincy> So what are the steps left to complete the proof?
05:07:49 <TMA> zincy: show that S (S0 + 0) = SS0
05:08:08 <hpc> so, you started with S0 + S0 = SS0, then showed that S0 + S0 is the same as S (S0 + 0)
05:09:13 <hpc> or, show that S (S0 + 0) = S (S0)
05:09:30 <TMA> so the last step is to show that S (S0 + 0) = SS0 ; you can use that S0 + 0 = S0, because you have already prooved that
05:09:46 <zincy> Ah I think I see
05:11:18 <zincy> SS0 = S0 + S0
05:11:37 <zincy> S (S0 + 0) = S0 +S0
05:12:13 <zincy> S (S0 + 0) = S0 + S0
05:13:15 <zincy> S0 + S0 = SS0
05:13:22 <merijn> Ok, there *has* to be a way to refactor this without all the redundancy: http://dpaste.com/2FFBHB1
05:13:47 <zincy> S0 +S0 = S0 +S0
05:18:19 <TMA> zincy: if you need to prove S (S0 + 0) = SS0 you can start with the left hand side and show that you can legally transform it into the right hand side, or you can start with tre right hand side and transform it into the left (using some legal transformation)
05:19:21 <kuribas> why is there no asum in base?
05:19:27 <kuribas> :t asum
05:19:28 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
05:19:30 <zincy>   S0 + S(0) = S ( S0 + 0) therefore S0 + S(0) = SS0
05:19:54 <zincy> SS0 = S (S0 + 0)
05:20:03 <merijn> kuribas: There is?
05:20:07 <zincy> S0 + S(0) = S (S0 +0)
05:20:41 <kuribas> ah, it's in Foldable...
05:21:09 <zincy> S0 (S0 + 0) = S0 (S0 +0)
05:21:26 <zincy> Think I got there if you replace all the S's with S0's :P
05:22:01 <TMA> zincy: well, I (and the grader) would like to hear: S0 + S(0) = S ( S0 + 0) AND S0 + 0 = S0 therefore I can plug the S0 in place of S0 + 0 giving S0 + S(0) = S(S0) which is the thing I wanted to prove all along
05:22:50 <merijn> Dammit, this code would be trivial if we had first class patterns :\
05:23:45 <TMA> zincy: generally in each step you need to state which assumptions you are using (those can be givens or already proved) and state ALL of them; then you need to state the rule under which you are using them
05:24:35 <zincy> Ah right without the identity axiom you can't get rid of the 0 in     ...  S0 (S0 + 0) = S0 (S0 +0)
05:26:08 <zincy> Are there any other good exercises for learning proofs?
05:26:21 <zincy> Also say you were being graded on proofs
05:26:35 <zincy> Is the mark based on the cumulative total of what you have proven?
05:27:12 <merijn> zincy: The book I learned has a bunch of stuff about proofs about programs including exercises
05:27:56 <__monty__> *linked, I guess?
05:29:28 <merijn> eh, linked, yeah
05:29:31 <merijn> Typing is hard
05:29:39 <zincy> Cool and does it have worked solutions?
05:30:30 <merijn> zincy: It uses the Coq theorem prover, so "worked solutions" are "proofs that Coq accepts" ;)
05:30:44 <zincy> TMA: Do you have an email address you could share?
05:31:30 <zincy> Are things like Coq and Agda not much faster for learning proofs then the traditional math method?
05:31:50 <zincy> Since you don't have to get a person to manually tell you where you went wrong?
05:32:54 <__monty__> merijn: The paste you linked looks a lot like `groupBy (\x y -> case (x,y) of (First, First) -> True; ...)` then traversing to bring the constructors out.
05:32:56 <merijn> zincy: Depends, you still have to figure out how to prove things :)
05:34:00 <__monty__> Yeah, I wouldn't say using a proof assistant is easier. You get away with a lot of handwaving in manual proofs.
05:38:31 <zincy> :)
05:40:55 <TMA> https://pastebin.com/3qPUEF9c
05:41:00 <TMA> zincy: https://pastebin.com/3qPUEF9c
05:41:26 <TMA> zincy: now back to your original problem
05:41:52 <merijn> __monty__: the groupBy solution would also still require me to do some form of partial projection function to "fix" things
05:42:48 <TMA> zincy: you have b = (uncurry . curry) and uncurry = ... and curry = ... and (.) = ...
05:42:48 <__monty__> merijn: Doesn't have to be partial but I see what you mean.
05:43:22 <merijn> __monty__: It does, otherwise groupBy won't help ;)
05:43:30 <Lears> merijn: https://gist.github.com/LSLeary/d39b8a8c2e1e31f19924dc81c08ee209
05:44:18 <zincy> TMA: Do I need to ever go into the value level or can I stay in types land for proofs with programs?
05:44:34 <zincy> I guess you can't use values
05:45:02 <TMA> zincy: you can do both
05:45:02 <__monty__> merijn: It could be First -> [something]; Second -> []; Both -> [], that's still a total function and less duplication than you have now : >
05:48:00 <__monty__> merijn: How about implementing your own groupBy that combines with <> rather than :?
05:48:19 <oo_miguel> I just use "stack ghc -- --make foo.hs" to build my simple toy-programm that makes use of libraries I obtained via "stack install .." however once I try to build my exe with profiling ghc 'compains' abot mitting profiling libraries. I forgot how to get them and can not find an answer. I am also unsure if it is possible without a proper standalone stack project?
05:48:22 <merijn> __monty__: <> is slow compared to DList concatenation
05:48:48 <merijn> oo_miguel: "--make" for ghc has been the default (and thus redundant) for, like, a decade by now :)
05:48:54 <Lears> (<>) can be DList concatenation
05:49:14 <Lears> With Endo [a]
05:49:23 <merijn> Lears: If I first wrap and implement that, yes
05:49:39 <oo_miguel> merijn: heh, ok I just copied it from somehwere (did not use it before). but if it is redundant it does not change my question :)
05:49:56 <merijn> oo_miguel: You'll have to rebuild your dependencies with profiling enabled, but I dunno how to do that with stack
05:50:02 <fen> thought this might be worth thinking of in terms of a higher order functional paradigm; https://atos.net/wp-content/uploads/2018/09/atos-reuse-method-for-quantum-circuit-synthesis-allouche.pdf
05:51:11 <oo_miguel> merijn: allright. I will keep on searching. But thank you for confirming that I need to have _all_ my dependandancies built with profiling.
05:53:07 <TMA> zincy: I have reread the paste you made. It can be interpreted in a way, that does not want you to prove anything, except to check the given proof
05:53:41 <__monty__> merijn: I actually meant folding along the way. So <> doesn't really fit.
05:53:56 <zincy> TMA: (.) curry :: (a1 -> (a2, b) -> c) -> a1 -> a2 -> b -> c    and (.) uncurry :: (a1 -> a2 -> b -> c) -> a1 -> (a2, b) -> c
05:54:12 <zincy> See the common (a1 -> a2 -> b -> c) 
05:54:31 <zincy> and a1 -> (a2, b) -> c
05:54:37 <TMA> zincy: on the other way it requires you to implement curry and uncurry on your own
05:54:45 <zincy> they are typewise the inverse of each other
05:55:16 <zincy> So you don't think that question from the book I pasted is actually asking for a proof?
05:55:46 <TMA> well, it is -- but not for you to construct but for you to check
05:56:48 <zincy> I guess I checked it then to show the proof is true
05:56:52 <TMA> zincy: sorry, this will sound harsh, it feels that the level of understanding proofs they assume is quite a bit higher than you currently posses
05:57:19 <zincy> That sounds about right
05:58:52 <zincy> But If it is not asking your to construct the proof then does your claim still hold?
06:01:14 <TMA> zincy: I think so. you cannot verify a proof just by plugging in some example values (unless you can plug in all possible values, which is generally impossible for the bumber of possible values is infinite)
06:01:51 <zincy> Ah right so there is an overlapping skill in construction and verification?
06:02:01 <TMA> zincy: on the contrary it is not futile -- you can _refute_ a proof by plugging in some values for which it does not hold
06:02:41 <zincy> Would the books linked earlier be a better starting point for learning
06:04:00 <TMA> basically verification is either mechanical (you look at the steps and find that they are allowed) or it involves proof construction (because for each step in the proof to be verified, you need to see that the step is correct, which can be not obvious)
06:04:40 <TMA> s/can/might/
06:06:16 <oo_miguel> should anybody care I found the answer (just by reading the stack cli help) "stack install --profile somelibrary" gives me the library I need 
06:07:19 <sm> oo_miguel: always a last resort :)
06:08:36 <TMA> zincy: the book of proof starts on a very basic level and builds up; I have not looked into the other
06:10:21 <oo_miguel> sm: heh, exactly. I prefer googling and molesing people in irc before reading the built-in manual
06:10:37 <zincy> Thanks I'll look at that one
06:12:19 <zincy> How directly useful are proof skills for type level programming in haskell?
06:12:37 <TMA> zincy: I have looked at the beginning of the other... it is more oriented towards coq and somewhat dense for a beginner to whom the formal-proof-thinking is not yet natural
06:13:07 <TMA> that being said, it is on my to-read list now :)
06:14:43 <lyxia> zincy: not very
06:15:31 <TMA> zincy: I would guess that you can dabble even without the skills, but to fix mistakes you will soon need to understand what is going on (and that includes understanding the limits of what can haskell compiler prove on its own and what needs to be force fed to it)
06:21:11 <zincy> You know when you hit the limits of Haskells type system you have gone pretty far down the rabbit hole
06:55:32 <kuribas> understanding proofs is mostly handy for doing equational reasoning and rewriting.
06:56:13 <kuribas> The basic idea you can rewrite code based on some simple laws rather than a deep and thorough understanding of the structure of the whole program.
07:25:14 <merijn> hmm, are there any functions for changing endianness of numeric values?
07:28:19 <c_wraith> like.. reversing byte order of a fixed size type?
07:28:42 <merijn> c_wraith: Like I have a Word16 and I wanna convert to/from network byte order
07:30:55 <stevenxl> Hello. Is there any way for me to write this expression in point-free form?
07:30:56 <stevenxl> attemptAssignment issueId = assignToIssue issueId >>= either printError finish
07:31:06 <c_wraith> the binary package has lots of utilities for de/serializing in particular byte orders, buy I don't think that's what you really mean..
07:31:09 <merijn> stevenxl: >=> ?
07:31:18 <stevenxl> merijn: let me look that up
07:31:34 <merijn> stevenxl: It's just >>= where the first argument is a function :)
07:32:31 <stevenxl> merijn: woot woot
07:32:45 <stevenxl> worked beautifully; I think I'll use the reverse one since it seems to mesh better with me
07:32:50 <stevenxl> thank you
07:40:07 * hackage ghc-exactprint 0.6 - ExactPrint for GHC  https://hackage.haskell.org/package/ghc-exactprint-0.6 (AlanZimmerman)
07:40:50 <shapr> @pl attemptAssignment issueId = assignToIssue issueId >>= either printError finish
07:40:51 <lambdabot> attemptAssignment = (either printError finish =<<) . assignToIssue
07:45:07 <stevenxl> Folks, I am trying to upgrade a package from `github-0.20` to `github-0.21`. The project is located here (https://github.com/kowainik/hit-on). How is it possible that `github-0.20` is available for use in that project, when the resolver that that project uses (https://www.stackage.org/nightly-2019-02-24) does not list `github` package and `github` is not in the extra-deps stanza of the `stack.yaml`?
07:49:27 <ph88> why is hayoo offline ?
07:50:29 <__monty__> ph88: Not sure why but saw something pass about it maybe being permanent. Though someone was trying to get hold of it or something.
07:50:38 <ph88> :(
07:50:58 <stevenxl> what's the url?
07:51:06 <ph88> https://hayoo.fh-wedel.de/
07:51:18 <ph88> by the way is there a repository for haskell.org website source files ?
07:54:12 <ph88> oh i guess it's this one https://github.com/haskell-infra/hl
07:54:40 <ph88> that's a bit strange that it's on github and ghc on gitlab, no ?
07:55:37 * hackage fused-effects 0.2.0.1 - A fast, flexible, fused effect system.  https://hackage.haskell.org/package/fused-effects-0.2.0.1 (robrix)
08:09:17 <__monty__> ph88: haskell.org is the *haskell* steering committee, not the GHC committee though?
08:09:45 <ph88> ah ok
08:12:10 <delYsid> Is Daniel Martí sometimes on this channel?
08:12:52 <delYsid> I am having trouble catching an exception thrown from within InterpreterT/GhcT
08:22:04 <geekosaur> hayoo is part of a university research project and possibly a course. if the course goes away or changes focus, or the research grant expires, one has a problem
08:23:04 <geekosaur> I think the software behind it is on github, but someone would have to adopt it and provide a machine or pay for hosting to run it on
08:24:36 <geekosaur> "holumbus" is the underlying software iirc
09:15:52 <inkbottle> In rwh, ch16, is there a rationale (even shallow) behind "p_pair", "p_pair_app" instead of theirs camelCase counterparts? All identifiers qualified w. fst letter "p", have been chosen snake_case. Is it aesthetic reason?
10:38:23 <oo_miguel> I am trying to manipulate some binary data on byte level but my approach is painfully slow (once again). I found out that already the way I read in the data is my first bottleneck. What is wrong with my approach: http://paste.debian.net/1070898/
10:41:01 <Solonarv> you're unpacking and re-packing, why not just 'map' directly?
10:43:29 <oo_miguel> Solonarv: hmm good point, this example is flawed.. In my real encoding function I use chunksOf which works on Lists.
10:52:27 <oo_miguel> I could try using folds
11:09:56 <dmwit> oo_miguel: You can write a ByteString-specific chunking function.
11:10:06 <dmwit> It's not too hard, and should be much faster than unpacking and repacking.
11:13:42 <oo_miguel> dmwit: would I use the monads from Data.Binary for that (just found something about binary parsing on the haskell wiki) ?
11:13:57 <dmwit> um
11:13:59 <dmwit> You could?
11:14:20 <dmwit> But I would just use ByteString's slicing functions. take, drop, splitAt, you know, the usual suspects but on ByteString instead of []
11:14:55 <oo_miguel> dmwit: aaah, allright, I will go for your suggestion and see how much that improves perforamnce. thank you very much!
11:18:27 <dmwit> ?tell inkbottle I think there's no real rationale for using snake case instead of camel case for parsers in RWH Chapter 16.
11:18:27 <lambdabot> Consider it noted.
11:21:07 * hackage servant-auth-wordpress 1.0.0.1 - Authenticate Routes Using Wordpress Cookies  https://hackage.haskell.org/package/servant-auth-wordpress-1.0.0.1 (lysergia)
11:23:38 <dyl> Are there any other active Haskell compilers still?
11:24:25 <dyl> It looks like UHC is stale, LHC is new.
11:25:03 <dmwit> I think not in public usage.
11:25:17 <zachk> @src chunksOf
11:25:17 <lambdabot> Source not found. I've seen penguins that can type better than that.
11:25:32 <Solonarv> none that aren't ghc-derived
11:25:33 <zachk> is jhc still around?
11:25:36 <dyl> dmwit are there secret private Haskell compilers?
11:25:52 <zachk> mu haskell at standard chartered iirc
11:26:19 <Solonarv> if you count ghc derivatives: eta (compiles to jvm), and two webasm backends
11:26:26 <Solonarv> oh and ghcjs
11:26:26 <dyl> zachk but that's a strict dialect no?
11:26:38 <dyl> I guess the Haskell Report doesn't really say it can't be strict :p.
11:27:08 <zachk> I  have heard mu haskell is strict
11:27:08 <dyl> Ah wait, the 2010 report now does as an offhand remark in 6.2.
11:27:14 <dyl> "Function application in Haskell is non-strict; that is, a function argument is evaluated only when required."
11:27:30 <nfd> anyone have any recommendations for resources to learn parsec aside from/in supplement to what the wiki has?
11:27:38 <nfd> i've never personally used parser combinators
11:27:50 <dyl> nfd I suggest writing a toy parser/interpreter :).
11:27:57 <zachk> dyl, idris is kind of like a haskell compiler, but with dependent types and strict
11:27:58 <nfd> that's my goal
11:27:58 <dyl> Learning by doing!
11:28:10 <nfd> i'm basically setting out to write a weird little esolang
11:28:23 <nfd> good opportunity to learn parsec
11:28:23 <dyl> It might help to look up other people's work on github!
11:28:30 <zachk> try parsing arithemetic expressions first 
11:28:38 <dyl> just search for the parsec/attoparsec/megaparsec import.
11:28:52 <zachk> or the dyck language
11:29:06 <nfd> sounds like a good idea
11:29:25 <nfd> my language was to have very simple semantics anyway, so it would be possible to start there
11:30:08 <dyl> zachk I've heard it said that it's best to defer the Dyck language until one has intuition and familiarity with the Cox-Zucker machine and hairy ball theorem.
11:32:09 <zachk> its it pronounced that way, or like something to stop water?
11:32:21 <dyl> ¯\_(ツ)_/¯ 
11:32:30 <dyl> nfd in all seriousness, I would suggest:
11:32:44 <dyl> 1. Parser for a calculator with + and * (positive integers only).
11:32:54 <dyl> 2. Then add negation, negative numbers, and subtraction.
11:33:04 <dyl> 3. Then add decimals and e-notation.
11:33:24 <dyl> Each of these poses an incremental challenge :).
11:34:22 <nfd> dyl: nice one
11:34:42 <dyl> 1. left-recursion and stratifying exprs/terms.
11:34:59 <dyl> 2. handling ambiguity from (x - 10) vs (-10).
11:35:02 <dyl> 3. etc...
11:35:20 <nfd> the dyck language seems really simple
11:36:30 <zachk> try it, its easy to mess up 
11:36:43 <nfd> dyl: that'd definitely do it. i have written a parser or two or three before, just with finite state machines
11:36:53 <nfd> simple != not easy to mess up
11:39:11 <dyl> zachk: have you seen edwardk’s stuff on Monoidal parsing? 
11:42:08 * hackage hierarchical-spectral-clustering 0.4.0.0 - Hierarchical spectral clustering of a graph.  https://hackage.haskell.org/package/hierarchical-spectral-clustering-0.4.0.0 (GregorySchwartz)
11:42:30 <nfd> dyl: would you suggest anything to read beyond the docs themselves? i remember looking at parsec's docs once and getting overwhelmed pretty quickly
11:43:05 <dyl> I learned from cobbled together out of date tutorials tbh. 
11:43:21 <dyl> I would suggest just playing with the combinators and testing stuff out in GHCI. 
11:43:35 <dyl> Also take a look at the parser-combinators library.
11:43:47 <dyl> Those are general purpose and defined over all Alternatives.
11:43:58 <dyl> (Alternative is like Applicative but with <|>, kinda.)
11:44:34 <nfd> Yeah, set-representable functors
11:45:08 <sm> nfd: megaparsec tutorials
11:45:19 <nfd> which?
11:45:45 <sm> on the megaparsec site
11:45:46 <dyl> nfd: tutorials aren’t always optimal 
11:45:56 <dyl> I suggest starting with a very small grammar you can implement. 
11:46:14 <nfd> makes enough sense
11:46:16 <dyl> And then extend it bit by bit and structure your searches around how to build the next extension. 
11:46:29 <dyl> It’s way easier to learn when you know what you’re trying to learn to do :) 
11:46:36 <dyl> And easier to search.
11:46:41 <nfd> i'm maybe not looking for tutorials so much as i'm looking for a sensible starting point to learn to approach the libraries
11:46:56 <dyl> Start with a calculator for integers with + 
11:46:58 <dyl> Then add * 
11:47:03 <dyl> Then add - and (-)
11:47:06 <dyl> Etc 
11:47:10 <dyl> That’ll get you a long way.
11:47:43 <dyl> A calculator for positive integers under + should be pretty straightforward to start off :). 
11:47:45 <nfd> yeah
11:48:07 <nfd> i'm looking for a focal point to get started learning this library
11:48:27 <nfd> the specific language i reach for first to try it doesn't specifically matter so much to me
11:48:57 <dyl> All of the *parsec family of libraries are mostly the same. They vary in focus and derails.
11:49:18 <dyl> Attoparsec for efficiency. Megaparsec for user friendliness. Trifecta for being Edward Kmett.
11:49:44 <nfd> hahah
11:49:50 <dyl> But in practice they all overlap substantially in how you use them.
11:49:54 <nfd> i'll probably go for megaparsec for the time being
11:50:10 <nfd> i'm implementing a language that isn't supposed to be especially performant, so
11:50:13 <dyl> Megaparsec is probably the best bet for learning as it has nicer error messages. 
11:50:35 <dyl> Trifecta has sexy errors, but it also depends upon the entire kmettiverse.
11:51:40 <nfd> i'll KISS with megaparsec I think
11:51:42 <shapr> kmetto-senpai recognize me!
11:52:11 <nfd> https://markkarpov.com/megaparsec/megaparsec.html looks like a sensible starting point
11:53:00 <shapr> there's a newer one I haven't read yet: https://markkarpov.com/megaparsec/megaparsec.html
11:53:11 <shapr> from like, last week 
11:53:23 <nfd> that link looks familiar...
11:53:32 <shapr> oh look
11:53:36 <shapr> nfd: good point
11:53:40 <nfd> haha
12:01:24 <EvanR> dang that megaparsec tutorial is nice looking
12:02:24 <nfd> why the Proxy s in tokensToChunk? Looks to me like it already has all the type information you'd need
12:02:37 <nfd> doesn't look like a Token can be, say, higher-kinded
12:03:16 <nfd> oh, i guess it's a common pattern through the library
12:03:18 <nfd> i'll keep reading
12:03:53 <phadej> nfd: type family (i.e. type alias) might not be injective
12:04:39 <sm> megaparsec is usually perceived as slower, but there are some benchmarks in the readme showing it comparable to attoparsec
12:04:46 <sm> just saying
12:04:53 <phadej> injectivity is required so type-checker to reason "backwards"
12:05:22 <nfd> what, injectivity from type-family to type?
12:05:44 <phadej> e.g. imagine you use tokensToChunk with type of  [Char] -> String -- what's the `s` GHC need to pick to find an instnace matching that 
12:05:54 <phadej> Token s = Char, Tokens s = String
12:05:57 <phadej> but what's s ?
12:06:35 <nfd> i guess i don't know how exactly it deduces those types, yeah
12:06:51 <phadej> that why there's Proxy s argument
12:06:55 <phadej> it tells what the `s` is
12:06:57 <nfd> i see it could take an arbitrarily long time to unwrap type aliases until they begin to make sense
12:07:05 <nfd> and that would complicate the compiler
12:07:21 <nfd> and maybe wouldn't be guaranteed to produce results that make sense anyway
12:07:23 <nfd> okay
12:08:21 <phadej> anyway, you probably don't need to define Stream instance anytime soon
12:08:51 <nfd> wasn't planning on it 
12:09:15 <nfd> no sense letting something go non-understood
12:09:26 <phadej> if it helps, you may think Proxy x argumetns as explicit type application
12:09:47 <phadej> and in that case it's required to make things unambiguous
12:21:34 <fr33domlover> I have a TVar holding some list of MVars in it, and I want to write an STM transaction that examines the list and possibly inserts a new MVar. But I need the transaction to be atomic i.e. has to happen in STM monad right? Problem is, to create a new MVar I need to be in IO. Option 1: Use TMVar instead. What are the use cases for TMVar by the way? Option 2: Always create a new MVar before the STM transaction,
12:21:36 <fr33domlover> that works but wasteful, because creating one before every single transaction. Option 3: Idk are there better options? :)
12:26:23 <dyl> shapr: I still can’t believe you remembered that pizza lol 
12:26:27 <dyl> I had honestly forgotten.
12:29:01 <shapr> dyl: I remember almost everything people tell me, with all the good and bad points that come with that.
12:29:19 <dyl> As I get older (still only 24...) I realize how not great my memory is.
12:29:28 <dyl> Or rather, inconsistent. 
12:29:50 <dyl> I’ll remember exactly where someone put a certain cassette tape a month after they lost it, but not which meal we had on what day during that time.
12:30:21 <dyl> My brain is a repository of mostly useless trivia. 
12:43:07 * hackage slack-web 0.2.0.11 - Bindings for the Slack web API  https://hackage.haskell.org/package/slack-web-0.2.0.11 (EmmanuelTouzery)
12:43:51 <dmj`> I have some hspec tests that do quickcheck things, when a failure is encountered the process still exits 0. How can I get it to fail the process
12:44:15 <EvanR> fr33domlover: well, creating one any any attempt will work and not strictly be a memory leak. because unused mvars will be collected
12:44:41 <EvanR> alternatively you can create a crazy delayed-creation mvar thing
12:45:34 <EvanR> but the naive way i imagine that involves a(n implicit) check every time its used to make sure its initialized
12:46:02 <EvanR> TVar (Maybe (MVar A)) vs TVar (MVar a)
12:47:22 <EvanR> another way would be to insert an unsafePerformIO newEmptyMVar :: MVar A into the thing and hope for the best
12:49:21 <c_wraith> you can probably unsafeInterleaveIO instead
12:49:33 <c_wraith> which is at least slightly better.
12:50:45 <EvanR> well, the idea is you don't have IO at the moment in question
12:51:00 <EvanR> only STM
12:52:21 <EvanR> but in any case i can see how unsafePerformIO newEmptyMVar used in pure code could be twisted against you by compiler transformations
12:53:05 <EvanR> GHC is like monkey's paw wishes
12:54:44 <Ariakenom> fr33domlover: option 1 seems nice
12:56:21 <dmj`> seems like this is a very bad thing...
13:10:33 <reygoch> Is it possible to make ghci reload local packages in my project? Currently if I have multiple packages in my project and P2 depends on P1, if I load P2 in GHCi and then change something in P1 I have to exit GHCi and start it again which is a bit annoying.
13:11:54 <phadej> reygoch: you cannot, either you have to hack and make them "same package", or then reload as you do
13:12:13 <reygoch> phadej: bollocks I say!
13:12:43 <phadej> reygoch: ghc(i) can compile/interpret only single package at the time
13:13:21 <reygoch> phadej: well, it definitely compiles and loads packages used in the "current" package
13:13:35 <phadej> reygoch: they are compiled before, and loaded
13:13:37 <reygoch> so I was hoping there was a possibility
13:13:39 <phadej> _before_
13:14:02 <reygoch> shame
13:14:20 <reygoch> well, I guess I'll have to make them the same package
13:14:46 <phadej> if you have to edit them a lot together, then they aren't probably "two separate packages" yet
13:16:27 <monochrom> Debate topic: Do package boundaries perpetuate the waterfall model? >:)
13:16:38 <cocreature> well it holds even for two components in the same package like a test suite and a library
13:38:09 <dmwit> fr33domlover: TMVar is for when you want an MVar, but in STM. So... I'd say option 1 is the cleanest by far.
13:44:39 <Leo_Verto[m]> I'm really stuck here, is there seriously no way to collect QuickCheck props from multiple modules and run them all at once?
13:55:31 <dmwit> Leo_Verto[m]: Seems there's nothing in QuickCheck premade. Looks like it shouldn't be too hard to add to the TH gimmicks available, though; allProperties is basically "figure out the name of this file, then run some specific TH on that file name", so you should be able to hijack the second part.
13:56:32 <sm> phadej: you can do it.. just include the other package src dirs with -i
13:57:26 <phadej> sm: it's not the same, you have to be careful. e.g. default-extensions have to be same, ghc-options etc.
13:57:41 <phadej> PackageImports won't work if you happen to use those
13:57:51 <sm> maybe so, but it basically works, I use it daily
13:58:00 <sm> change a file in any package, :r reloads it
13:58:01 <phadej> yes, but `cabal` should work _always_
13:58:24 <sm> I don't think reygoch cared about always
13:58:38 <sm> never mind, they left too soon
13:58:54 <phadej> sm: it's easier to explain "no this is not possible", the nto explain why "this doens't work in this scenario"
13:58:58 <sclv> i didn't know the -i trick, its nice!
13:59:18 <sclv> like for reygoch's scenario it does work
13:59:19 <sm> real world example: make ghci -> stack exec -- ghci  -rtsopts -Wall -fno-warn-unused-do-bind -fno-warn-name-shadowing -fno-warn-missing-signatures -fno-warn-orphans -fno-warn-type-defaults  -ihledger-lib -ihledger-lib/other/ledger-parse -ihledger -ihledger-ui -ihledger-web -ihledger-web/app -ihledger-api    -DPATCHLEVEL=96 -DDEVELOPMENT -DVERSION="\"1.13.99\""  hledger/Hledger/Cli/Main.hs
13:59:46 <phadej> but doesn't stack ghci loads whole project as single package anyway?
13:59:58 <sm> no
14:00:00 <phadej> at least it used to (and I got an issue to remove default-extensions to make it work)
14:00:04 <sm> just one package, by default
14:00:17 <phadej> ok, maybe it's changed since
14:00:40 <Leo_Verto[m]> dmwit: yeah, that's what I've done so far: getting allProperties from each module and concatenating them and then running `runQuickCheckAll props props quickCheckResult` where runQuickCheckAll is a blatantly copied unexported QC function. Problem is, it passes and says "1 of 1 test suites (1 of 1 test cases) passed." even when tests have failed
14:03:18 <sm> phadej: I take it back about stack ghci & one package - I don't know what it does. I'm not using stack ghci
14:07:17 <zachk> dyl, I have not seen edwardk's monoidal parsing stuff, have you seen his logic programming stuff https://github.com/ekmett/guanxi thought I do not know how to use it :( might interest you, whilst you working on a prolog and all
14:08:53 <ddellacosta> Anyone using NixOS know how to work around this? https://github.com/commercialhaskell/stackage/issues/4289 (I've already asked on #nixos fwiw, no response)
14:11:25 <orion> The C2 wiki lists _|_ as the "uninhabitedIs the Void type just as
14:11:33 <orion> The C2 wiki lists _|_ as the "uninhabited" type. Is the Void type just as inhabited as bottom?
14:11:43 <orion> uninhabited*
14:13:22 <Solonarv> yes, those are two names for the same thing
14:13:41 <Solonarv> also, _|_ isn't a legal name for a Haskell type :p
14:16:42 <orion> Cool.
14:17:18 <orion> Unrelated: I wish servant-server didn't treat 3XX codes as failures.
14:17:52 <orion> https://hackage.haskell.org/package/servant-server-0.16/docs/Servant-Server.html#v:err302 <-- The example literally says, "failingHandler = throwError err302"
14:18:08 <zachk> you could un tar and un gzipped the package change its cabal file a bit and hack its internals
14:18:17 <zachk> and make your own version of it orion 
14:18:22 <orion> zachk: I could submit a PR also. ;)
14:18:31 <zachk> that too :)
14:20:52 <phadej> sm: --load-local-deps        Load all local dependencies of your targets
14:21:08 <phadej> if i % stack ghci --stack-yaml=stack-ghc8.4.yaml hledger-ui --load-local-deps, it loads 93 modules for me
14:21:28 <phadej> seems to work for hledger
14:24:28 <sm> phadej: thanks, I didn't know about it
14:31:24 <freusque> what's the standard haskell technique for manipulating record updates ?
14:31:49 <dmj`> freusque: what do you mean, "manipulating record updates"
14:31:59 <freusque> I'd like to load some fields from a yaml file and update a record with them, somehow.
14:33:01 <freusque> I currently handle values of type R -> R around, where R is my record type.
14:33:15 <freusque> but it's clearly overkill.
14:33:38 <freusque> I just don't know what to use instead that would be pleasant
14:33:39 <dmj`> \f -> do { result <- decodeYaml <$> L.readFile "/path/to/file.txt"; case result of { Right x -> x { foo = f (foo x) }; Left e -> putStrLn e; }
14:33:47 <dmj`> freusque: is this a partial record update?
14:33:51 <freusque> yes
14:33:58 <Lears> ddellacosta: it looks like the change in the argument order of `cover` from QuickCheck 2.11 to 2.12. You can override Diff with a patched version easily enough, but since this is in a test suite it should suffice to disable its tests haskell.lib.dontCheck.
14:34:29 <Lears> tests using*
14:35:33 <freusque> this always replaces the foo field, right?
14:35:54 <freusque> I want to replace some subset of the fields (unknown in advance).
14:39:26 <freusque> I don't know what datatype people typically use for that purpose
14:40:00 <oo_miguel> still struglling with IO. my test haskell programm  (that just adds together all input bytes `mod` 256) is now _only_ 3 times slower than my reimplemenation in c. I just use "Data.ByteString.Lazy.foldl1' (+)" to get the result. Is this overhead/difference I should just live with, or are there any ways to improve this?
14:40:57 <freusque> I can write a function that does the update, but I'd like to pass that information around. An association list/tree would work but it's disgusting of course
14:41:07 <oo_miguel> (It is already a huge improvement compared to what I did before with packing and unpacking)
14:41:14 <freusque> (thanks for your answer dmj` )
14:41:28 <dmj`> freusque: np
14:43:26 <zachk> oo_miguel, have you tried using strict bytestrings yet?
14:44:53 <oo_miguel> zachk: oh, just tired it. that even slightly outperforms the c version.. 
14:45:09 <zachk> strictness for the win! :D 
14:45:13 <oo_miguel> but I WANT to keep the laziness
14:45:19 <zachk> :(
14:45:41 <oo_miguel> I have to chunk it then to read lazily , strict chunks i suppose
14:46:00 <zachk> I think you are probably building up a huge chain of thunks with that foldl1 being lazy or something along those lines 
14:46:46 <zachk> oo_miguel, can a foldr work for you? 
14:46:47 <oo_miguel> zachk: aah probably. I will keep on trying thanks for poiting out the problem is about laziness and not haskell IO in general ;)
14:47:14 <zachk> haskell io is pretty lazy, im not totally informed on how lazy it is
14:47:20 <zachk> i have had lazy io problems before
14:47:31 <zachk> switched to bytestring.strict and my problems went away 
14:48:12 <oo_miguel> zachk: ok thanks. I will focus on the fold I guess. and try to turn back to lazy
14:48:31 <zachk> you might want a foldr 
14:48:49 <zachk> if you code can allow it 
14:49:21 <oo_miguel> allright ... I will reread the wiki about folds.. once again ;)
14:53:15 <sm> would anyone know why GHC 7 gives a non-exhaustive pattern match error here, when GHC 8 does not ? Perhaps some missing language extension ? https://gist.github.com/simonmichael/5ed0ad2c76b2f3452d0c260343d0a542
14:53:35 <zachk> that is a pretty bad netsplit
14:56:32 <c_wraith> sm, my best guess would be that the view pattern isn't checked for exhaustiveness
14:57:24 <sm> c_wraith: that makes sense.. seems I might have to avoid using that if I want to build with ghc 7
14:57:35 <c_wraith> sm, if you reverse those two guards, so that the view pattern for Just is first, then use an otherwise instead for the last one, it should have the same result
14:58:30 <c_wraith> sm, alternatively, you could replace the view patterns with a case in the body.
14:58:47 <ddellacosta> Lears: yeah that was all in the issue I linked to, what I'm trying to figure out is how to do that with nix
14:59:14 <c_wraith> err. pattern guards. darn it, wrong feature name.
15:01:20 <sm> c_wraith: nice, thanks!
15:01:58 <c_wraith> sm, did it make ghc 7 happy?
15:02:02 <Cale> oo_miguel: The next step would be using unboxed addition
15:02:02 <sm> yup
15:02:12 <c_wraith> cool
15:02:17 <sm> and it's clearer
15:02:37 <Cale> oo_miguel: (but before you go there, to stare at the core after optimisation and make sure that's worthwhile)
15:02:48 <Cale> (it probably is)
15:03:57 <Cale> oo_miguel: This is the part which starts to get a bit painful, so you'd normally want to make sure you actually give a shit about how fast you're adding those numbers ;)
15:04:49 * sm thinks about dropping GHC 7 support for other reasons
15:05:12 <oo_miguel> Cale: heh, but the problem seems not to be in the addition itself since it works fast when I switch to Strict Bytestrings (as zachk) suggested.
15:05:28 <Cale> oo_miguel: Is that the entire program?
15:05:33 <oo_miguel> yes
15:05:40 <Cale> oh, I see
15:05:47 <Cale> what is the C program doing?
15:05:58 <Cale> just a loop?
15:06:18 <oo_miguel> http://paste.debian.net/1070944/
15:06:23 <oo_miguel> yeah
15:06:35 <oo_miguel> jsut read some chungs of bytes and loop over them
15:06:41 <oo_miguel> chunks
15:06:43 <Cale> It might be worth emulating that with strict bytestrings, yeah
15:07:06 <Cale> though tbh, I'm not sure why
15:07:15 <Cale> it shouldn't be very different
15:07:27 <oo_miguel> on the other hand WIHTOUT addition it is also fast with Lazy Bytestrings
15:07:29 <Cale> But Data.ByteString has lost a lot of the tricks it used to pull
15:07:42 <oo_miguel> wehn i simply write the same bytes on the output for instance
15:07:48 <Cale> ah
15:08:18 <Cale> well, my first thought was that you're going to be building those Int boxes
15:08:20 <oo_miguel> the combination of the fold WITH the laziness introduces the "problem"
15:08:51 <Cale> It might be that an optimisation gets triggered when you use a simple strict bytestring that doesn't happen for .Lazy
15:09:08 <Cale> We'd have to stare at the core to be sure
15:09:15 <Cale> -ddump-simpl
15:11:46 <oo_miguel> http://paste.debian.net/1070946/
15:11:48 <oo_miguel> horrible :(
15:11:50 <oo_miguel> :P
15:12:05 <oo_miguel> ..but I am not used to reading it. just looked once or twice 
15:16:08 <oo_miguel> and this is what I have written in haskell: http://paste.debian.net/1070947/ 
15:19:46 <ph88> what's the go-to http parser ?
15:20:29 <Cale> oo_miguel: oh, nice, it does look like it's doing something cleverer than I thought it would be already
15:20:52 <oo_miguel> Cale: ooh,  you are reading this "core" , seriously :).. respect!
15:20:57 <shapr> aw, godbolt.org doesn't show GHC core
15:21:48 <Cale> er, no, my bad, it's using the ordinary + for boxed Word8's
15:22:31 <Cale> oo_miguel: yeah
15:22:39 <Cale> oo_miguel: It's not hard once you learn to ignore all the noise
15:22:44 <reallymemorable> I am super new to Haskell.  I ran `cabal install quandl-api` successfully and loaded my main.hs in ghci but when I try `:l main` I get an error: https://paste.ofcode.org/KnbpAN5jFRxUYVV7nmiZm6
15:23:07 <oo_miguel> Cale: did you see my original file (last link I posted). There is nothing obvioulsy wrong about my fold I hope?
15:23:36 <Cale> oo_miguel: It's not wrong, it's just a question of how well GHC is going to be able to pull it apart
15:24:59 <sclv> reallymemorable: you can see what packages are available in your system by running `ghc-pkg list` at the console
15:25:02 <shapr> reallymemorable: are you able to use :m + Data.Quandl in ghci?
15:25:18 <oo_miguel> Cale: I also do not want to steal you too much time... I love the lazy part and I love how haskell can process transofrm big data files/streams.. but I am worried about this performacne overhead.
15:25:28 <sclv> also your main.hs doesn't have a main function?
15:25:34 <Cale> oo_miguel: I mean, it always depends on what you're doing.
15:25:39 <reallymemorable> shapr that command did not work
15:25:48 <reallymemorable> so i guess it's somehow not loaded
15:25:57 <Cale> oo_miguel: Keep in mind that most of the world is accepting of the performance of Javascript most of the time :D
15:26:18 <Cale> oo_miguel: Haskell can do a lot better than *that* without much effort, at least
15:26:49 <oo_miguel> Cale: heh, yeah. I could also live with the answer that I have just sacrifice speed and get only 30% throuput for all this beuaiful haskell powers and laziness
15:27:01 <Cale> The trickier part is just getting a feel for what's going to perform acceptably, and what's terrible. A lot of your intuitions are reversed when you start out programming under lazy evaluation
15:27:06 <oo_miguel> but It seeems that this is NOT the answer,rgiht?
15:27:10 <Lears> ddellacosta: The best way to do it depends on what you're actually trying to do, and what the relevant default.nix & shell.nix look like, if they exist. If you give more detail I can be more helpful, but for now I'll just link you to: https://nixos.org/nixpkgs/manual/#users-guide-to-the-haskell-infrastructure
15:27:57 <Cale> oo_miguel: Well, the answer to how to make the Haskell program faster is going to make it look probably at least as ugly as the C program (but I'm fairly confident we could get there with some unboxed numbers)
15:28:06 <shapr> reallymemorable: your file will most likely have "module Main where \n import Data.Quadl \n \n main = print (getTable "EOD" "AAPL" (Just "mykey")  "
15:28:14 <Lears> ddellacosta: "override" is the keyword
15:28:31 <oo_miguel> Cale: my more complex toy programm is a base64 encoder/decoder and I was very proud and happy about its beauty until I figured out it is performs 10 time slower then the base64 cli utility on my os.
15:28:32 <Cale> oo_miguel: So, usually the right answer is to sacrifice the speed in favour of maintainability
15:28:38 <reallymemorable> you're saying i need to replace the contents of main.hs with that?
15:28:45 <oo_miguel> this is why I started to dig deeper in the first place
15:28:49 <Cale> ah
15:29:03 <Cale> well, again, you might be able to bring that factor down a bit
15:29:24 <Cale> but something like that basically consists of a tight loop with lots of bitwise operations in it
15:29:47 <Cale> It's hard to beat C at things like that.
15:29:58 <oo_miguel> I do not expect to get the same performace as from assmeber or c. just want to get a feeling what I can realisticly expect.. without causing to much pain. (reading core is a pain for me for now)
15:30:03 <julianleviston> oo_miguel: I find a lot of the ideas from haskell translate to rust very well, which *is* stupendously fast at low level stuff. Might help.
15:30:38 <shapr> reallymemorable: something like this I think: https://pastebin.com/cvNbfXTv
15:30:38 <Cale> Note also that you *can* call C functions really easily in Haskell.
15:31:14 <shapr> reallymemorable: your life will be easier if you use create a new directory, run cabal init, and then add quandl-api to the build-dependencies
15:31:19 <julianleviston> oo_miguel: a lot of the things from rust that they got from haskell help improve the semantics of rust code, which means the compiler understands more about the code than equivalent C code which often means it gets some of the benefits of haskell’s optimisations.
15:32:25 <reallymemorable> shapr, is that print statement formatted correctly?
15:32:32 <reallymemorable> vscode doesnt seem to like it
15:33:19 <oo_miguel> Cale: yeah, throwing out all this "bit shifting" already improved the throuput from a factor 10 to a factor 3 handicap  
15:33:56 <oo_miguel> but guess I will just live with that. and might decide to depart to other langauges if I have some real problem where time becomes a factor
15:34:18 <oo_miguel> reallymemorable: thank you for the insights. might even look into rust one day
15:34:29 <julianleviston> oo_miguel: “depart” ? there might be an inclusive way of looking at things :)
15:34:31 <reallymemorable> uh what?
15:34:36 <oo_miguel> aah sry
15:34:38 <reallymemorable> lol
15:34:38 <oo_miguel> julianleviston: 
15:34:41 <oo_miguel> :)
15:34:51 <ddellacosta> Lears: I'm trying to figure out how to patch a transitive dependency in a Haskell package in Nix, let me know if I'm still not being clear enough
15:34:52 <reallymemorable> i was like ive been doing this for 1 week and definitely not had anything resembling an insight
15:34:55 <julianleviston> no need for sorry, just saying I don’t think one can ever depart from haskell :)
15:35:07 <shapr> reallymemorable: does that paste work for you?
15:35:15 <shapr> I can get out my personal laptop and see if it works
15:35:16 <Cale> oo_miguel: Yeah, Haskell FFI is super-easy, especially if you're just importing a few small functions.
15:35:27 <oo_miguel> julianleviston: you can check out anytime you want, but you can never leave ;)
15:36:00 <oo_miguel> julianleviston: (and i was sorry for confusing your nick with reallymemorable) 
15:36:04 <julianleviston> oo_miguel: after a while you might realise that the thing you like about haskell isn’t actually necessarily about haskell, but haskell was the tool the people came to use who were researching these interesting things, and it often continues to be :) so it can help you get to a meta language that is beyond the haskell, idris, agda, rust or the anything else — towards the same language math points at. Just my two 
15:36:05 <julianleviston> cents.
15:36:10 <reallymemorable> shapr it uncomments comments that come after it, it looks like it doesnt terminate the print
15:36:24 <reallymemorable> lexical error in string/character literal at character '\n'
15:36:25 <oo_miguel> anyway, by depart I did mean departing to solve parts of a bigger problem
15:36:40 <reallymemorable> at the end of the line that starts `result...`
15:36:53 <reallymemorable> oh
15:36:57 <reallymemorable> missing quote mark
15:37:29 <Lears> ddellacosta: I get that, I mean that you're trying to build something, or produce an environment, and it matters how you're doing that.
15:38:13 <ddellacosta> Lears: I am trying to build a package using a default.nix file generated from running cabal2nix. Am I getting warmer?
15:38:22 <johnw> has anyone on Mac seen a -threaded Haskell problem cause this diagnostic report: 45001 wakeups over the last 6 seconds (7761 wakeups per second average), exceeding limit of 150 wakeups per second over 300 seconds
15:38:31 <ddellacosta> sorry, not default, I should say, repo-name.nix
15:39:47 <Lears> ddellacosta: Yes, closer, do you have a default.nix to build the project using that repo-name.nix?
15:39:53 <ddellacosta> yes
15:39:58 <Lears> Can you share it?
15:40:22 <shapr> reallymemorable: did you see the pastebin link?
15:41:24 <oo_miguel> julianleviston: I understand, thank you for that insights. Coming from an object oriented and structured programming background haskell is the first and only functional language I tried to look deeper into so far. It might be worth playing with others a bit as well.
15:42:53 <ddellacosta> Lears: https://nixos.org/nixpkgs/manual/#how-to-create-nix-builds-for-your-own-private-haskell-packages, substitute the ghc version for  8.4.4
15:43:17 <reallymemorable> shapr yes working through some cabal init thing I dont understand
15:43:46 <reallymemorable>     Package name? [default: co-quandl-library] quandl-api
15:43:46 <reallymemorable>     This package name is already used by another package on hackage. Do you want to choose a different name? [default: y] 
15:44:57 <ph88> guys, can you help me? i'm looking for all the functions that parse HTTP request headers, but i don't find any
15:45:49 <julianleviston> ph88: what have you tried? I did a quick google search and found https://hackage.haskell.org/package/salvia-protocol-1.0.1/docs/Network-Protocol-Http-Parser.html
15:46:18 <ddellacosta> Lears: nevermind
15:46:28 <julianleviston> ph88: there seems to be quite a few 
15:46:39 <fr33domlover> EvanR, dmwit, how about the following: read the TVar, see if I want to use an existing MVar (most cases) or insert a new one (rare cases). If use existing, just use withMVar on it. Otherwise, create a new MVar, and then inside STM transaction check again and insert it if nothing changed in that moment in between. Is that better? Or still pick option 1 which was to use TMvar?
15:47:00 <ph88> julianleviston, that package you linked is last updated in 2010. I saw it too but ignored it. I'm looking for the modern stuff
15:47:12 <julianleviston> ph88: http2?
15:47:21 <ph88> no just http1 will do
15:47:28 <julianleviston> ph88: was http1 updated after 2010?
15:47:34 <ph88> i'm digging into warp and wai docs
15:48:03 <julianleviston> ph88: just curious why a parser library for an existing standard would need to change if there aren’t bugs in it.
15:48:06 <ph88> modern as a recently updated and frequently used haskell library/package not a webserver that's stuck in 2010
15:48:32 <julianleviston> ph88: “I don’t want to use this addition function, coz it hasn’t been updated in centuries"
15:48:52 <ph88> julianleviston, look at this package https://hackage.haskell.org/package/salvia
15:49:10 <ph88> carefully
15:49:41 <ph88> look at your own link too
15:49:44 <julianleviston> ph88: I was just trying to help. Wai is going to definitely be the best. Seems like you don’t need help. :)
15:49:50 <ph88> i need help
15:49:57 <ph88> but salvia is not the answer
15:50:07 <Solonarv> ph88: the 'base' library has changed since 2010, so code from then may simply not work with a modern compiler
15:50:07 <Squarism> anyone know of an easy way to do QT using haskell. Found 2 packages "qtah" that seems to be global package cabal oriented (i only use stack) and hsqml that use mercurial. 
15:50:18 <Solonarv> er, that was meant for julianleviston
15:50:37 <Squarism> ...and mercurial is not a route im eager to try
15:50:37 <Solonarv> Squarism: there is no such thing as a "cabal oriented package"
15:50:37 <julianleviston> Sorry, you said you coudln’t find *anything*, so I was illustrating that there are quite a few things out there. I apologise.
15:51:10 <ph88> here seems to be something interesting  https://hackage.haskell.org/package/wai-extra-3.0.25/docs/Network-Wai-Parse.html#v:parseRequestBodyEx  i just don't understand it
15:51:15 <Solonarv> Lots of libraries say "install using `cabal install this-package`", that doesn't mean you must install them this way
15:51:18 <Squarism> Solonarv, well the install procedure is set up for global cabal build 
15:51:25 <Solonarv> in fact that is usually a terrible idea!
15:51:35 <ph88> julianleviston, ok no worries, i should have nuanced that
15:52:19 <Squarism> Solonarv, i guess i could fix it. But if i found a no worries get started in 5 minutes, id take that route instead.
15:52:44 <julianleviston> ph88: all good. What don’t you understand about parseRequestBodyEx?
15:53:13 <ph88> If i go to the source code, https://hackage.haskell.org/package/wai-extra-3.0.25/docs/src/Network.Wai.Parse.html#parseRequestBodyEx
15:53:22 <ph88> then dive into getRequestBodyType
15:53:26 <ph88> i see requestHeaders
15:53:29 <ph88> ok looks interesting
15:53:36 <Lears> ddellacosta: I'm not 100% sure it's seen by dependencies, but I think you can just use callPackage's final argument, giving it { Diff = nixpkgs.haskell.lib.dontCheck stuff.${compiler}.Diff; } rather than {}.
15:53:39 <ph88> i can't click it, i don't find it anywhere else in the source
15:53:52 <sclv> Squarism: you should be able to depend on the qtah packages from hackage just like any other packages on hackage
15:54:02 <Solonarv> ^
15:54:06 <ph88> i go on hoogle, i type  requestHeaders   i find a bunch more stuff i don't know what it is
15:54:26 <ph88> i mean i can go through source code and source code, but i was asking here to see if anyone just knows where it is
15:54:42 <sclv> Squarism: same for hsqml too. the fact that it uses the mercurial vcs is irrelevant
15:54:43 <julianleviston> ph88: why do you need to undersatnd the source in order to use it?
15:55:03 <ph88> if i want to use it i must know from which package to import it
15:55:06 <Squarism> sclv, i would prefer stack(age) though. 
15:55:14 <sclv> well those packages aren't on stackage
15:55:19 <sclv> but stack can use packages from hackage
15:55:22 <Squarism> no, i saw that
15:55:23 <julianleviston> ph88: Network.Wai.Parse no?
15:55:28 <sclv> there's no problem adding deps outside of a stackage snapshot
15:55:28 <Squarism> oh ok
15:55:44 <julianleviston> ph88: it’s at the top of the module you linked to. I’m kinda missing what’s tricky here.
15:56:11 <julianleviston> ph88: wai-extra is the package name, and what I just said is the module.
15:56:40 <ph88> i was asking about a function to parse HTTP headers .. what are you referring to ?
15:56:55 <ph88> parseRequestBodyEx - Parse the body of an HTTP request, limit resource usage. The HTTP body can contain both parameters and files. This function will return a list of key,value pairs for all parameters, and a list of key,a pairs for filenames. The a depends on the used backend that is responsible for storing the received files.
15:56:57 <ph88> ???
15:57:45 <julianleviston> ph88: sorry, I think I need another coffee :) I’m not helping :) I’ll be quiet now :)
15:57:58 <ph88> ok np
15:58:26 <Solonarv> Squarism: if the package you're depending on isn't in the snapshot you're using you will have to add it to the 'extra-deps' section of your stack.yaml, but that is not really difficult ;)
15:59:05 <Squarism> Solonarv, ok ill try that 
15:59:34 <Solonarv> stack's error message will mention that as well, IIRC
15:59:40 <Solonarv> (I haven't used stack in a while)
16:06:51 <julianleviston> ph88: ok, so http://hackage.haskell.org/package/HTTP-4000.3.12/docs/Network-HTTP-Base.html has parseRequestHead — is that what you want? 
16:07:07 * hackage log-effect 1.2.0 - An extensible log effect using extensible-effects  https://hackage.haskell.org/package/log-effect-1.2.0 (sickmind)
16:08:35 <ph88> julianleviston, yes that would be one alternative. But it takes string. I think modern code uses ByteString for this
16:22:22 <ph88> I think i found it https://github.com/yesodweb/wai/blob/master/warp/Network/Wai/Handler/Warp/RequestHeader.hs#L25-L38
16:22:39 <ph88> after one hour of searching o_O
16:23:06 <julianleviston> nice.
16:25:07 * hackage log-effect-syslog 0.2.0 - Syslog functions for log-effect  https://hackage.haskell.org/package/log-effect-syslog-0.2.0 (sickmind)
16:26:02 <ph88> it'
16:26:11 <ph88> it's not being exported i think ?
16:48:45 <xpika> Is there a way to get ghci to optimize code that's executed in the REPL?
16:50:17 <hpc> load compiled code
16:52:37 * hackage haskell-dap 0.0.11.0 - Haskell implementation of the DAP interface data.  https://hackage.haskell.org/package/haskell-dap-0.0.11.0 (phoityne_hs)
16:56:17 <energizer`> what does the second line do?:    square = (^2) ; (one:four:nine:_) = map square [1..]    
16:58:04 <energizer`> one, four, and nine are defined to values, and then the rest of the numbers never get evaluated?
16:58:46 <Solonarv> exactly
17:00:19 <energizer`> are the parens (one:four:nine:_) doing anything?
17:01:09 <Solonarv> % (one:four:nine:_) = map (^2) [1..]
17:01:10 <yahb> Solonarv: 
17:01:16 <Solonarv> % one:four:nine:_ = map (^2) [1..]
17:01:17 <yahb> Solonarv: 
17:01:29 <Solonarv> looks like they're not necessary
17:09:57 <EvanR> % (x,y) = (y,x)
17:09:58 <yahb> EvanR: 
17:10:21 <EvanR> the ying yang
17:11:08 * hackage openapi-petstore 0.0.4.0 - Auto-generated openapi-petstore API Client  https://hackage.haskell.org/package/openapi-petstore-0.0.4.0 (jonschoning)
17:24:35 <sicklorkin> How does one take a [[JSONValue
17:24:59 <sicklorkin> ]] and decode it into some [[Int]]
17:25:35 <sicklorkin> (transcode)
17:28:02 <xpika> as in optimise the code that's typed into the repl
17:29:23 <sicklorkin> xpika: I have some table that I fetch from a spread sheets and I'm given [[JSONValue]] and I want to convert this to my [MyTable].. 
17:30:25 <Solonarv> xpika: I don't know of a way to do that
17:30:32 <Solonarv> but why would you need to?
17:30:37 <EvanR> you can hope to directly convert [[JSONValue]] to [[Maybe Int]]
17:31:11 <sicklorkin> EvanR: fromJSON?
17:31:21 <xpika> Solonarv: so expressions evaluate faster
17:31:32 <Solonarv> xpika: but compilation takes time too!
17:31:50 <xpika> Solonarv: heavy computations for example
17:31:57 <Solonarv> especially with optimizations enabled (which are needed to make code truly fast_
17:32:16 <sicklorkin> EvanR: I'm just confused how this wo9rks for JSONValues, for bytestrings it's fairly straightforward
17:32:19 <EvanR> sicklorkin: decode is more like it
17:32:38 <Solonarv> additionally, heavy computation tends to be more than a simple one-liner, so you really should put it in a source file anyway
17:32:40 <sicklorkin> ahh.. but decode doesn't do what I want..
17:32:44 <EvanR> oh yeah
17:33:17 <sicklorkin> EvanR: decode gives me a string
17:33:35 <EvanR> you mean it takes a string (a bytestring). you can still use fromJSON
17:35:14 <EvanR> Value -> Result Int
17:38:03 <sicklorkin> (JSON.fromJSON. Data.Aeson.decode (view vrValues z)) :: Either String [[Int]]
17:38:18 <sicklorkin> vrValues returns [[JSONValues]]
17:38:36 <EvanR> if you want that, the whole thing fails if anything cant be decoded
17:39:36 <sicklorkin> EvanR: sure, I just want to get the correct combination of glue first.. 
18:00:23 <ph88> when using hpack should i commit the cabal file to the repository or is that not needed ?
18:01:07 * hackage strict-list 0.1 - Strict linked list  https://hackage.haskell.org/package/strict-list-0.1 (NikitaVolkov)
18:02:08 <Solonarv> ph88: when using hpack you should stop using hpack ;)
18:02:15 <ph88> ??
18:02:44 <Solonarv> if you must use hpack, then commit the cabal file as well so people can build your project without having to use hpack
18:04:27 <Solonarv> But really I would recommend just deleting package.yaml and editing the cabal file directly
18:07:43 <Welkin> make sure to delete the win32 folder
18:09:09 <Solonarv> you can 'stack build' first to be really extra sure the cabal file has been generated
18:11:08 * hackage hledger-lib 1.14 - Core data types, parsers and functionality for the hledger accounting tools  https://hackage.haskell.org/package/hledger-lib-1.14 (SimonMichael)
18:12:08 * hackage hledger-api 1.14, hledger-web 1.14, hledger-ui 1.14, hledger 1.14 (SimonMichael)
18:13:54 <sm> ph88: yes, commit the cabal file as well for maximum tool compatibility
18:14:59 <Welkin> if it doesn't have a cabal file it doesn't belong in your face
18:15:08 <Welkin> erm, I mean
18:15:13 <Welkin> it's useless
18:15:33 <Solonarv> Note that you don't lose any tool compat by removing package.yaml - stack doesn't care
18:15:41 <Welkin> throw out stack too
18:16:21 <Solonarv> Welkin: I knew you'd say that, I considered a quip along the lines of "oh, you logged on just in time"
18:16:25 * sm carefully avoids the small mob of zealots
18:16:38 <Welkin> Just In Time :D
18:16:41 * Solonarv is not a tool zealot
18:16:44 <Welkin> the best compilation method
18:16:48 <EvanR> Welkin -- a mob of 1
18:17:24 <Welkin> you don't know my multiplicity
18:17:28 <Welkin> how rude
18:17:48 <EvanR> i just checked for other Welkin's on this network
18:19:38 <Welkin> do we need to have multiplicity badge now to go along with our pronoun badges?
18:26:08 * hackage deque 0.3.1 - Double-ended queues  https://hackage.haskell.org/package/deque-0.3.1 (NikitaVolkov)
18:30:13 <Welkin> > let (∘) = (.) in chr ∘ (+1) ∘ ord $ '🐩'
18:30:15 <lambdabot>  '\128042'
18:30:21 <Welkin> show the emoji lambdabot!!
18:30:39 <EvanR> > text 
18:30:41 <lambdabot>  <[Char] -> Doc>
18:30:46 <EvanR> > text "\128042"
18:30:48 <lambdabot>  🐪
18:30:51 <Welkin> > let (∘) = (.) in text . chr ∘ (+1) ∘ ord $ '🐩'
18:30:53 <lambdabot>  error:
18:30:53 <lambdabot>      Precedence parsing error
18:30:53 <lambdabot>          cannot mix ‘.’ [infixr 9] and ‘∘’ [infixl 9] in the same infix expre...
18:31:11 <Welkin> > let (∘) = (.) in text . pure . chr ∘ (+1) ∘ ord $ '🐩'
18:31:13 <lambdabot>  error:
18:31:13 <lambdabot>      Precedence parsing error
18:31:13 <lambdabot>          cannot mix ‘.’ [infixr 9] and ‘∘’ [infixl 9] in the same infix expre...
18:32:37 <Welkin> > let (∘) = (.) in text ∘ pure ∘ chr ∘ (+1) ∘ ord $ '🐩'
18:32:39 <lambdabot>  🐪
18:32:41 <Solonarv> huh, I wonder where that fixity decl came from
18:32:57 <Welkin> I used the *real* compose operator ∘
18:33:08 <Solonarv> btw: chr . (+1) . ord = succ
18:33:36 <Solonarv> > text . pure . succ $ '🐩'
18:33:38 <lambdabot>  🐪
18:33:59 <Welkin> > let (∘) = (.) in text ∘ pure ∘ succ ∘ succ $ '🐩'
18:34:01 <lambdabot>  🐫
18:34:12 <Welkin> > let (∘) = (.) in text ∘ pure ∘ succ ∘ suc  ∘ succ $ '🐩'
18:34:14 <lambdabot>  error:
18:34:14 <lambdabot>      • Variable not in scope: suc :: Char -> Char
18:34:14 <lambdabot>      • Perhaps you meant one of these:
18:34:19 <Welkin> Mega Evolve!
18:34:25 <Welkin> > let (∘) = (.) in text ∘ pure ∘ succ ∘ succ ∘ succ $ '🐩'
18:34:26 <EvanR> stop unicoding in anger
18:34:27 <lambdabot>  🐬
18:34:47 <Welkin> I can't stop
18:34:47 <MarcelineVQ> all unicoding is done in anger, that's the only way to make it through.
18:34:54 <Welkin> julia enables me to use unicode everywhere o.o
18:34:57 <MarcelineVQ> κ
18:35:03 <Welkin> I even use subscripts
18:35:11 <MarcelineVQ> you absolute monster
18:35:19 <MarcelineVQ> You better only use it for numbers I swear to the jesuses
18:35:34 <EvanR> yeah, the limited subset of latin that has subscripts in unicode
18:35:47 <EvanR> for whatever reason
18:35:53 <Welkin> I tried using f, no luck
18:36:00 <Welkin> decimal numbers work though
18:36:10 <Welkin> and most of the alphabet
18:36:15 <Welkin> except f,d and some others
18:36:24 <Solonarv> I only use the subset of unicode that I know how to type :p
18:36:54 <Welkin> haha
18:36:55 <Welkin> τᵦ
18:37:05 <Welkin> tau_beta
18:38:17 <EvanR> from now on all my source code will be in KOI-8
18:38:49 <EvanR> since we are all being so progressive tonight
18:38:52 * Solonarv spills their ∀α → β everywhere, oh no!
18:38:53 <Welkin> 草ᵦ²
18:39:50 * EvanR marvels that all that shows up in a terminal going through ssh going through screen
18:40:02 <MarcelineVQ> ​
18:40:37 <EvanR> no fair using black foreground
18:40:54 <MarcelineVQ> 1,1wot
18:40:54 <Solonarv> I have a white background and can't see it either
18:40:58 <Solonarv> MarcelineVQ: you witch!
18:41:01 <EvanR> lol
18:41:05 <Welkin> 草ᵦ²ᵝⁱ₍ₕᵢ₋ₘₒₘ₎
18:41:08 <Welkin> I typed that by hand
18:41:37 * hackage hledger 1.14.1 - Command-line interface for the hledger accounting tool  https://hackage.haskell.org/package/hledger-1.14.1 (SimonMichael)
18:41:38 <EvanR> in the old days you had deadbeef, now you have whatever you can spell with unicode subscripts
18:42:07 <MarcelineVQ> Is there a codepoint for displaying the symbol fonts display when they don't have a symbol for a codepoint?
18:42:24 <Welkin> the boxes of shame?
18:42:29 <EvanR> the replacement character?
18:42:46 <EvanR> fffd
18:43:01 <Solonarv> > text "\xfffd"
18:43:03 <lambdabot>  �
18:43:26 <EvanR> (i've already seen that symbol several times tonight, e.g. Welkin's emojis)
18:43:41 <MarcelineVQ> oh, I thought you were expressing an emotion when you wrote fffd
18:43:58 <EvanR> U+FFFFFFFUUUUUUUUUUUUUUUUUUU
18:44:21 <Welkin> you don't have poodles and camels and dolphins on your screen?
18:44:23 <Welkin> what a shame
18:45:02 <EvanR> unicode is going to get filled up with emojis before they have time to encode all the ancient languages
18:45:31 <EvanR> what a waste
18:45:35 <MarcelineVQ> I have them, but I can't see them well enough to disinguish them, which is currently my main issue with unicode in source, when open source is for sharing with humans
18:46:31 <Welkin> unicode has over 4 billion codepoints though
18:46:34 <EvanR> indeed open source implies humans = 1960s americans
18:47:05 <Welkin> get a better editor
18:47:20 <Welkin> editors need to support unicode and make it easy to read and use
18:47:56 <EvanR> are you prepared for the possibility of extraterrestial intelligence? we don't even know if they support ASCII!
18:48:05 <Solonarv> you should still make sure not to use easily-confused unicode symbols, though
18:48:13 <Welkin> it's cool that you can write an entire program in chinese, or devanagari
18:48:28 <Welkin> or in emojis!
18:48:31 <Solonarv> (much like you shouldn't use 'Ian' and 'lan' together)
18:48:46 <Welkin> I often find code will all of the comments in japanese or chinese already
18:48:48 <Welkin> wiht*
18:48:51 <Welkin> with*
18:48:51 <EvanR> human language gets in the way of abstract language, we need less of it not more
18:51:47 <Solonarv> then again, unicode can make abstract languages easier to read and write
18:53:11 <EvanR> true
18:54:17 <Solonarv> compare:
18:54:17 <Solonarv> replicateV :: ∀a. ∏(n :: ℕ) -> a -> Vec n a
18:54:17 <Solonarv> replicateV :: forall a. foreach (n :: Nat) -> a -> Vec n a
18:54:50 <Welkin> you forgot the unicode arrows
18:54:55 <Welkin> and ::
18:55:02 <Solonarv> curses, I always forget the unicode arrows
18:55:15 <Welkin> that forall is so small o.o
18:55:34 <Solonarv> I don't have the unicode variant of :: in my xcompose setup and I couldn't be bothered to go find it
18:55:50 <Solonarv> ∀ isn't small on my screen, it's the same size as A
18:55:55 <Welkin> →
18:55:55 <Welkin> ?
18:56:14 <Solonarv> yeah, → I simply forgot about
18:56:47 <Welkin> I don't even have a special compose thing
18:57:07 <Welkin> it's just part of the julia repl and language mode
18:57:58 <Welkin> I assume mostly for typing in complicated math formulas
18:58:06 <Solonarv> copy-pasting from a repl (which I don't even have installed!) is significantly less convenient than a compose key though
20:17:40 <hololeap> what's the easiest way to get the maximum Finite, given a Nat?
20:23:52 <MarcelineVQ> subtract 1 from the nat? not quite sure what you're askin
20:25:24 <MarcelineVQ> Oh sorry, I've assumed you were asking about Fin(ite) but you could be asking about something else
20:26:01 <MarcelineVQ> probably https://hackage.haskell.org/package/linear-1.20.8/docs/Linear-V.html#t:Finite in fact
20:26:28 <hololeap> i was talking about finite-typelits
20:26:42 <hololeap> for instance the maximum (Finite @15) could hold is 14
20:27:49 <Lears> maxBound?
20:28:16 <hololeap> Lears: oh, i missed the Bounded instance. thanks
22:04:53 <abiduzz420> Hello. I would like to install ghc using haskell-platform. Wanted to make sure if it is using the latest stable release 8.6.2
22:05:17 <abiduzz420> I am sorry 8.6.3*
22:35:41 <baikal_> read about the new exciting pedo-friendly linux distribution https://exherbo.com/
22:37:38 <PtxDK6> read about the new exciting pedo-friendly linux distribution https://exherbo.com/
22:38:38 <bass_goon_> read about the new exciting pedo-friendly linux distribution https://exherbo.com/
22:38:43 <MarcelineVQ> glguy: might be time for your big hammer solution :(
22:41:21 <ramsesHD12> read about the new exciting pedo-friendly linux distribution https://exherbo.com/
22:41:30 <adamf> read about the new exciting pedo-friendly linux distribution https://exherbo.com/
22:43:32 <asjo13> read about the new exciting pedo-friendly linux distribution https://exherbo.com/
22:47:42 <ChOcO-Bn23> read about the new exciting pedo-friendly linux distribution https://exherbo.com/
22:54:38 <Guest57458> read about the new exciting pedo-friendly linux distribution https://exherbo.com/
23:08:38 <auxesis23> read about the new exciting pedo-friendly linux distribution https://exherbo.com/
23:14:09 <wloncom> read about the new exciting pedo-friendly linux distribution https://exherbo.com/
23:18:38 <celyr17> read about the new exciting pedo-friendly linux distribution https://exherbo.com/
23:27:43 <cenourinha> read about the new exciting pedo-friendly linux distribution https://exherbo.com/
23:46:43 <asdfffdsa29> read about the new exciting pedo-friendly linux distribution https://exherbo.com/
23:47:08 * hackage download 0.3.2.7 - High-level file download based on URLs  https://hackage.haskell.org/package/download-0.3.2.7 (psibi)
