00:31:25 <mjrosenb> I think I've backed myself into a corner with lenses.  I have somthing that I thought would be Maybe [Coord], but it is actually Maybe (Maybe a), and I have no clue why
00:31:43 <mjrosenb> and it typechecked because I only matched on Nothing in this branch.
00:43:37 * hackage erd 0.2.0.0 - An entity-relationship diagram generator from a plain text description.  https://hackage.haskell.org/package/erd-0.2.0.0 (mmzx)
00:47:07 * hackage monadacme 0.1.0.0 - The Acme and AcmeT monads  https://hackage.haskell.org/package/monadacme-0.1.0.0 (ThomasEding)
01:54:56 <merijn> So, are selective functors basically a more general/principled version of Witherable?
02:00:03 <akr> how can I examine the call stack when an exception is thrown?
02:01:14 <akr> okay maybe I can use https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Stack.html#g:1
02:01:51 <merijn> akr: If you build with profiling enabled call stacks are maintained automatically
02:02:25 <akr> merijn: is it advisable to run an executable with profiling enabled in production?
02:03:37 <merijn> akr: Probably not. Mostly due to profiling having a non-trivial performance impact
02:04:53 <dminuoso> If your application is trivial however and has no meaningful performance constraints it might be an option though.
02:05:51 <akr> it might work if there was a selective way to enable profiling for some functions / modules and not others
02:07:26 <akr> I guess I would have to maintain the call stack myself then
02:12:55 <scav> Having played around with StateT I am still not able to figure out how I can have A { b :: String, c :: [] } and use this type in a recursive main where I continuously print out the result of every iteration while re-using my type with the updated data for the next iteration. 
02:16:06 <merijn> scav: What did you try and how did it fail?
02:19:47 <scav> merijn: I tried to create my own type to hold my state: type VmState a = StateT Vm IO a
02:21:57 <scav> I also tried something along the lines of 'Vm -> StateT Vm IO ()', but I am not sure how I could modify the internal state of Vm . I tried 'modify' from the mtl package, but so far I only succeed if i try to modify an Intl
02:22:45 <merijn> scav: So how did you attempt to use "VmState"? What did or didn't work? etc.
02:24:23 <scav> So far, I am having trouble modifying its state in my main loop (in lack of a better word)
02:24:50 <dminuoso> scav: Please share the code you have tried with us.
02:24:58 <dminuoso> And use it to explain what difficulties you have.
02:25:06 <dminuoso> We won't judge. :-)
02:29:12 <scav> I was not worried about that, I just don't fully grasp Monads yet, and wanted a simple skeleton like this while I explore it more writing something I actually need.
02:29:32 <scav> ill try to wrap up an example.
02:41:37 <Unhammer> Does anyone know of a replacement for regex-genex that's maintained / works with recent versions of base? I just want to create all strings matcihng very simple regexes like "[A-Z][a-z]{3,3}"
02:41:53 <Unhammer> could do it by hand, I guess
03:41:00 <scav> dminuoso: im not able to provide any example, because i simply cannot get past 5 lines of working code for this problem (likely because i have no idea what i should actually be doing to solve this), but thanks for replying earlier.
03:41:42 <dminuoso> scav: Then dont show us working code, show us what you are trying. ;)
03:43:41 <merijn> scav: The problem is that you're only mentioning small (but correct) snippets, and it's hard for us to extrapolate what "doesn't work" for you when you're trying things
03:44:45 <dminuoso> scav: Just show us what you naturally tried and didn't work or even compile. We might be able to get an idea of where your thought process went wrong.
03:54:09 <scav> dminuoso: https://pastebin.com/Df3fmHBd
03:55:50 <scav> I am able to make "run" work id my input and output is Int, but not when I try to use my own type (perhaps I need to derive more things for Vm?)
03:55:56 <merijn> scav: You shouldn't write a "run" function "Vm -> StateT ..."
03:56:24 <merijn> scav: You should implement "myStuff :: StateT Vm IO ()" and then you *run* that via runStateT/execStateT
03:58:34 <scav> thats what i dont understand, dont i have to provide myStuff with Vm?
03:59:12 <merijn> scav: That's what runStateT/execStateT do
03:59:37 <merijn> scav: The entire point of StateT is there is a "Vm" that you can access without explicitly passing it into a function
03:59:51 <scav> oh okay
04:00:08 <scav> you can probably tell by now why it was hard for me to even describe my problem...
04:01:19 <piyush-k`> is the hackage website down ? I am getting a Unexpected 403 error when I do a cabal new-update (version 2.4.0.0)
04:02:31 <dminuoso> % :t runStateT
04:02:31 <yahb> dminuoso: StateT s m a -> s -> m (a, s)
04:02:45 <dminuoso> scav: ^- see how it takes two parameters? The stateful computation and the initial state. :)
04:02:46 <fendor> piyush-k`, looks fine to me
04:03:10 <dminuoso> scav: And it returns a value with whatever the final resulting state is.
04:04:17 <scav> dminuoso: right, i guess i can wrap my head around that, but perhaps I am not even on the right path here. i want to do the equivalent of a while loop which pattern matches and output data for each iteration. is this "the way"?
04:04:44 <dminuoso> scav: Is that loop stateful?
04:05:15 <piyush-k`> fendor: okey I tried a cabal update and then cabal new-update. Seems to have fixed it for now
04:05:50 <scav> dminuoso: in a way yes, some of the functions it would call update state
04:09:04 <akersof> hi all. I was reading http://mutanatum.com/posts/2017-01-12-Browser-FP-Head-to-Head.html and the true is at the end i still don't know if i have to start with elm, purescript or ghcjs + reflex
04:09:38 <akersof> i am sure there is no a silver bullet in the list, but i am just curious to get feedback from you if you use them
04:11:50 <akersof> my opinion is elm is really easy, i was unable to make something running in purescript yet, and i didn't use ghcjs-reflex yet too. Do you have some advice or feedback about elm, purescript or ghcjs-reflex ?
04:12:22 <dminuoso> "Elm drags Javascript 20% of the way towards Haskell. Purescript drags Haskell 20% of the way towards Javascript."
04:12:39 <akersof> As i am learning haskell, i tought reflex would be the way to go, but i am not sure
04:13:01 <srk> try miso as well
04:13:16 <akersof> dminuoso: indeed, purescript looks more haskellish in the syntax for sure
04:13:21 <dminuoso> akersof: I have been disgusted by Elm all the way.
04:13:49 <CelestialLake> dminuoso: Is that because they've scrapped their typeclasses? ;)
04:14:40 <akersof> srk: i read about miso, maybe still use now, but apprently reflex is a newer alternative ?
04:14:58 <akersof> dminuoso: the good point i can give to elm is it is simple
04:15:23 <dminuoso> CelestialLake: No, but its a factor as well.
04:15:41 <dminuoso> akersof: You spend so little time being a beginner in a language.
04:16:09 <dminuoso> akersof: You spend a lot of time being somewhere in the intermediate to expert level. I prefer a language that focuses on being useful for intermediate/expert programmers.
04:16:43 <dminuoso> So I don't buy the "but its simple" argument attached to Go or Elm.
04:17:19 <dminuoso> My issues with Elm lie elsewhere though.
04:17:59 <akersof> i am thinking about reflex in fact
04:18:04 <CelestialLake> dminuoso: One of my factors to avoid it is the fact that their community is not very educated, 'ports' are quite clunky and there's that guy who bans infix operators for some reason.
04:18:22 <CelestialLake> Well, collectively, a community factor.
04:18:24 <dminuoso> CelestialLake: https://github.com/elm-lang/elm-make/issues/71
04:19:31 <akersof> did you try reflex yet ?
04:20:00 <CelestialLake> >"but its simple" argument attached to Go or Elm
04:20:14 <CelestialLake> Which leads to lots of unnecessary boilerplate, of course.
04:21:02 <CelestialLake> dminuoso: mother of god...
04:22:44 <Boomerang> Hi! What would be a good way to decode a CBOR map into a Haskell record? I am currently using the cborg library (I don't think serialise is suited to the level of control I need).
04:24:05 <Boomerang> For a bit more context, I know exactly what keys to expect in the map (and the size of the map), I just don't know in which order they'll come
04:24:30 <Boomerang> I am parsing CBOR generated using Python cbor2 library
04:25:18 <akersof> Boomerang: i don't know if its help but there is haskell implementation of cbor i read
04:25:28 <akersof> https://cbor.io/impls.html
04:26:18 <Boomerang> Thanks, I'm already using cborg which I think is the main Haskell implementation :)
04:26:29 <akersof> ok :)
04:26:55 <Taneb> Boomerang: can you use the Serialise class in serialise to get a Map, and then do something with the Map?
04:28:18 <Boomerang> I don't think I can use Serialise and then get the rest of the ByteString that's left to parse. So as I can probably switch to Serialize for the leafs of the data tree?
04:29:28 <avn> Folks, does a common practice to separate a unit/prop tests, from long running tests, which require databases, etc.
04:29:34 <Taneb> Boomerang: the deserialiseIncremental function gives you the remainder of the ByteString
04:30:39 <Boomerang> Thanks, I'll have a look at that. Maybe going via Map is the simplest way to do this
04:31:31 <avn> Also any good idea to bring up/shutdown test database? (I though about temporary docker with pgsql)
04:32:29 <hpc> it's less about fast/slow and more about testing individual units of code vs testing the entire thing
04:33:43 <hpc> i don't think there's much value in trying to make a complicated half-real test environment the way you're likely thinking
04:34:08 <hpc> just set it up as if it was what you were actually going to use, but point it away from public apis and production databases
04:34:30 <hpc> then your big tests are "an automated user gets expected results"
04:34:54 <hpc> and your small tests are written only for the absolutely most complicated single pieces
04:35:40 <hpc> see also: quickcheck
04:39:07 * hackage futhark 0.10.1 - An optimising compiler for a functional, array-oriented language.  https://hackage.haskell.org/package/futhark-0.10.1 (TroelsHenriksen)
04:40:03 <Athas> As the bot just announced, I have a package on Hackage.  It is primarily an executable.  Further, there is a Nix derivation based on it.  I would like to somehow make the manpages available.  They are not currently part of the sdist on Hackage.  What would be a good way of making them available?
04:40:32 <Athas> Complication: the manpages are not written in roff, but in .rst, and processed with Sphinx (itself a large moving part).
04:40:54 <avn> hpc: we have a lot of small tests, but I like to check API codepaths as well, as opaleye stuff
04:41:07 <hpc> Athas: when in doubt, do what everyone else does and provide a way to make an rpm or deb or something
04:42:13 <Athas> hpc: sure, it's available through various other means (most seem to use Homebrew), but I'd also like to make the Nix derivation nicer.
04:42:50 <Athas> One solution is of course to base that derivation directly on the Git sources, rather than the Hackage sdist.
04:44:06 <dmwit> Athas: The cabal field extra-source-files can be used to include additional files in the sdist.
04:44:09 <avn> hpc: biggest problem, that significant amount of code rely on opaleye, and I not sure how to mock it properly
04:44:11 <hpc> ah - https://www.haskell.org/cabal/users-guide/cabal-projectindex.html#cap-package.cabal%20fields
04:44:18 <hpc> dmwit: beat me by a hair lol
04:44:46 * dmwit takes a bow
04:45:26 <hpc> avn: set up the database the exact same way it's set up when you're running it for real
04:45:34 <hpc> you have scripted that, right? wink wink nudge nudge
04:45:34 <Athas> dmwit: can it include an entire directory, or do I need to list every file?
04:45:42 <Athas> Oh, extra-doc-files... what's that?
04:49:00 <avn> hpc: partially ;)  So I plan to create docker with db, load in schema dump, then shutdown on exit
04:49:46 <dmwit> Athas: You must list every file. However, I think you may `foo/*.rst` to include every file that has extension `rst`.
04:50:07 <dmwit> (No, `foo/*` does not work.)
04:50:32 <dmwit> (Well, I mean, it works as documented: it includes every file with no extension in `foo`.)
04:53:47 <Athas> dmwit: hm, thanks.  It's a bit annoying, because the entire doc generation setup contains 35 files.
04:54:13 <Athas> Most of those are .rst files, so at least *.rst should work.  I'll try!
05:00:42 <hpc> i wish cabal's documentation wasn't readthedocs style
05:00:58 <hpc> i always find navigating to what i want is weirdly difficult
05:13:45 <Axman6> avn: A small tip when testing against a database running in docker, make sure you turn off settings for the database that ensure the data is written to disk before returning results (generally this means just run an in memory database). It can greatly improve the speed of your DB tests
05:14:16 <Axman6> avn: see https://pythonspeed.com/articles/faster-db-tests/
05:15:33 <avn> Axman6: I will. I look now how to organize tests/discovery/running (ofc I can do just make blue-smoke subroject inside)
05:17:33 <avn> Axman6: ty for link, section about docker is exactly what I planned
05:17:58 <Axman6> Boomerang: How'd you go with your CBOR stuff? You might find you have to do something like deocde a HashMap <keytype> Term and then decode those into the types you need for each field
05:20:41 <Axman6> avn: If you happen to be doing this on AWS, there's a great post on that blog about speeding up builds by using EC2 instances with NVMe drives; we started doing it here and made our builds about 50% faster
05:25:11 <Axman6> Boomerang: it turns out what you want to do is surprisingly difficult
05:27:06 <avn> Axman6: sure, but I also want to have ability run testsuite locally
05:28:16 <Axman6> that's somewhat orthogonal the instance type you'd run your tests on when not running it locally though - sounds like you want something like docker compose
05:28:51 <fendor> where is the database of hoogle located?
05:30:31 <Axman6> looks like ~/.hoogle
05:31:28 <avn> Axman6: well, I'd like sort of docker compose built-in right to testsuite probably
05:32:38 <Axman6> just use eocker compose to setup your database and run your tests :\
05:33:03 <avn> tasty have `withResource :: IO a -> (a -> IO ()) -> (IO a -> TestTree) -> TestTree` so I can write function to bring up dockers here
05:34:22 <fendor> Axman6, I see there are a bunch of files, but are there the documentations?
05:34:59 <avn> compose also an option, although if I setup db schema programmaticaly, I can call docker as well ;) But yes, probably just drop in compose file can be a compromise
05:36:38 <avn> Axman6: how I can run real-db tests, if I in "composed" environment, and only regular unit/props otherwise?
05:36:39 <Axman6> fendor: no idea, you'd have to check the docs/source for hoogle
05:37:22 <Axman6> avn: out tests are split into unit/property tests and integration tests, and the integration tests can only be run when there's a database to connect to
05:39:20 <Axman6> our*
05:40:19 <avn> Axman6: sure. Is any way to decrate them as "conditionally enabled"? (we use Tasty/Hedgehog combination)
05:40:27 <avn> *declare even
05:41:30 <fendor> Axman6, ok, thanks!
05:43:22 <Axman6> avn: you can you a flag in cabal if you want
05:43:23 <fendor> Axman6, it is the default-haskell-5.0.17.hoo file, fyi
05:49:26 <avn> Axman6: I prefer conditional runtime flag/environment variable if it possible
05:49:37 <asheshambasta> Is there something I'm supposed to be aware of with ApplicativeDo expecting Monad instances? 
05:50:11 <asheshambasta> https://gitlab.haskell.org/ghc/ghc/issues/12666 is what I'm experiencing even with later versions of GHC 
05:52:27 <asheshambasta> there seem to be workarounds like these: https://stackoverflow.com/questions/41210599/applicativedo-not-working-with-sequencing but that still doesn't seem to work for me 
05:58:25 <Boomerang> Axman6: I am using serialize to get the Map as Taneb suggested. And I basically ended up doing what you're suggesting with `Map Text Term`.
05:58:53 <Boomerang> It's a bit of a shame to not be able to use the decoders from serialise or cborg once I'm in Term land
05:59:33 <Boomerang> I'm starting to wonder if I shouldn't just `decodeTerm` at the beginning and then do everything in plain Haskell
06:00:55 <Boomerang> What's missing is an aeson like field lookup function. But I understand it might have been left out for efficiency reasons?
06:02:07 * hackage withdependencies 0.2.4.3 - Run computations that depend on one or more elements in a stream.  https://hackage.haskell.org/package/withdependencies-0.2.4.3 (SimonMarechal)
06:03:37 * hackage fastparser 0.3.1.2 - A fast, but bare bones, bytestring parser combinators library.  https://hackage.haskell.org/package/fastparser-0.3.1.2 (SimonMarechal)
06:04:37 * hackage exceptions 0.10.1 - Extensible optionally-pure exceptions  https://hackage.haskell.org/package/exceptions-0.10.1 (ryanglscott)
06:28:27 <stevenxl> Hi folks. What is the cardinality of list? Because the type "[Bool]" can be an infinite number of possible values, is it fair to say that the cardinality of the type [Bool] is infinite?
06:30:31 <Solonarv> stevenxl: sure
06:30:46 <stevenxl> Solonarv: thanks; just making sure. 
06:30:58 <stevenxl> I don't have a strong math background; don't want to get the wrong conclusions.
06:31:29 <Solonarv> algebraically: [a] = 1 + a * [a]
06:33:18 <Solonarv> this gives you |[a]| = 1 + |a| * |[a]|, which clearly means |[a]| = ∞ when |a| >= 1
06:33:40 <Solonarv> (I use |T| to mean "the cardinality of the type T")
06:34:49 <e> assuming there's one infinity
06:34:59 <stevenxl> Solonarv: thanks. I was able to follow that. ;)
06:35:22 <Solonarv> (indeed, assuming a single infininity)
06:35:45 <Solonarv> stevenxl: they're called ADTs for a reason! ("Algebraic Data Types") :D
06:39:43 <dminuoso> stevenxl: You could think about how list is defined:
06:39:51 <dminuoso> data List a = Cons a (List a) | Nil
06:41:33 <fendor> Solonarv, does that mean that |[Void]| = 0? since |Void| = 1?
06:42:21 <Solonarv> fendor: the other way around
06:42:31 <fendor> yeah, riht
06:42:53 <fendor> that's cool
06:42:54 <Solonarv> |Void| = 0, so |[Void]| = 1 + |Void| * |[Void]| = 1 + 0 * _ = 1
06:43:28 <Solonarv> this makes sense intuitively: if there are no values of type Void, then the only way to have a list of Void is an empty list
06:43:46 * dminuoso passes Solonarv the bag with a bottom
06:43:55 <dmwit> For this reason, I've been tempted to add an Empty typeclass to universe, so that I could have instance Empty a => Finite [a]
06:44:14 <Solonarv> yeah, ignoring bottoms
06:44:30 <Solonarv> bottoms sneak in and vomit '+ 1' everywhere
07:11:07 * hackage aws-lambda-haskell-runtime 1.0.10 - Haskell runtime for AWS Lambda  https://hackage.haskell.org/package/aws-lambda-haskell-runtime-1.0.10 (NickSeagull)
07:14:07 * hackage xmlbf 0.5 - XML back and forth! Parser, renderer, ToXml, FromXml, fixpoints.  https://hackage.haskell.org/package/xmlbf-0.5 (RenzoCarbonara)
07:15:07 * hackage xmlbf-xmlhtml 0.2, xmlbf-xeno 0.2 (RenzoCarbonara): https://qbin.io/latex-exempt-an9n
07:31:46 <fendor> how does the ghci `:type-at` command work? I am trying to use the example in the docs, but it claims that it doesnt know the module
07:34:26 <scav> merijn and dminuoso thanks for the help earlier, I made it work!
07:35:20 <fendor> nvm, got it
07:40:15 <ski> fendor : care to tell about it ?
07:41:25 <fendor> ski, after using `:set +c` and reloading the module, you can use `:type-at <module-name> 1 0 1 1` to get the type at the src span (1,0) - (1,1).
07:41:38 <fendor> however, I was not able to supply a src span that ghci seems to understand
07:41:56 <fendor> to see available modules, the command :show modules, is quite useful
07:43:02 <ski> and it worked after `+c' being set ?
07:43:50 <fendor> and reloading
07:44:57 <ski> ok. ty
07:45:04 <fendor> but now, it claims that there "<no location info>: error: not an expression: ‘’"
07:54:43 <o1lo01ol1o> Is there any way to get GHC to dump or print the non-well-typed code it attempts generate from a `standalone deriving` instance?
07:55:58 <Solonarv> does -ddump-deriv work?
07:56:19 <o1lo01ol1o> What's the syntax?  I can't find that flag
07:56:45 <Solonarv> that's a command-line option to pass to GHC
07:59:38 <Solonarv> you can pass it via cabal or stack by adding --ghc-options=-ddump-deriv to the command
07:59:58 <o1lo01ol1o> Where is the output?  
08:00:08 <Solonarv> dumped to standard output
08:00:24 <Solonarv> you can add -ddump-to-file to output to a file instead
08:17:29 <o1lo01ol1o> Solonarv:  stack build --force-dirty --ghc-options=" -ddump-deriv -fforce-recomp" <-- doesn't print anything to stdout
08:18:43 <merijn> -ddump-deriv dumps to a file
08:19:12 <o1lo01ol1o> Where would I find that file?  I don't immediately see anything generated
08:19:28 <merijn> That depends on where stack puts it, and I can't tell you that
08:21:09 <Solonarv> actually it does dump to stdout by default, but it seems like stack is passing -ddump-to-file or otherwise capturing it
08:21:22 <Solonarv> should be somewhere in .stack-work/
08:22:01 <o1lo01ol1o> ah: .stack-work/dist/<arch>/<cabal>/build/projname/projname-tmp/src/
08:22:10 <o1lo01ol1o> thx
08:52:31 <scav> What would be the best "things" to install for Haskell development on macOS? I prefer to use VSCode, but I am open for suggestions.
08:52:31 <akr> I'm looking for a library for editing PDFs
08:52:55 <akr> I found HPDF and easyrender, but those seem to be only capable of creating PDFs from scratch
08:53:22 <dminuoso> scav: Use whatever editor you are most comfortable with.
08:53:39 <phadej> editing PDF is tricky, as PDF can contain a lot of stuff
08:53:47 <dminuoso> phadej: *crazy stuff
08:53:49 <dminuoso> :)
08:54:06 <dminuoso> I've managed to crash at least 2 PDF readers trying to open the PDF specs..
08:54:49 <akr> yeah I know it's not ideal, however there isn't really a way around it
08:55:16 <phadej> I mean, it's fine to "search text" or "rasterize", but editing; err...
08:55:30 <dminuoso> phadej: Even searching text is pretty complicated.
08:55:37 <scav> Sure, but I would like to hear what other people prefer and use (including things like haskelly if applicable), because my primary editor is IDEA and I did not like the Haskell plugin there.
08:55:53 <dminuoso> scav: The haskell tooling is pretty bad no matter what you are going to pick.
08:56:05 <dminuoso> scav: So the choice is going to be about personal editor preference.
08:56:11 <phadej> there are vim and emacs and whatever users
08:56:17 <scav> Hehe, fair enough answer :)
08:56:18 <akr> phadej: it's not exactly editing, more like, slapping some more elements on top or appending files
08:56:40 <dminuoso> scav: If you are comfortable with VSCode feel free to use it.
08:56:40 <phadej> akr: as in adding annotations?
08:56:44 <berndl> I'm a vim user.
08:56:59 <akr> phadej: they're not really annotations, but yes, something to that effect
08:57:06 <akr> copyright notice stuff
08:57:31 <phadej> akr: you know that they can be as easily removed as you add them? :)
08:57:45 <akr> sure, it's more of a legality I think
08:57:48 <akr> it's not waterprint
08:58:23 <akr> just some text
08:59:08 <phadej> researchgate just prepends a page
08:59:18 <phadej> I'd do that with calling out to gs
08:59:41 <phadej> maybe it can even slap stuff to the pages arxiv style
08:59:52 <phadej> i.e. won't try to do that in "pure haskell"
09:00:04 <akr> why not?
09:00:26 <phadej> gs does it; and is probably better for the task that anything else
09:00:48 <phadej> also "if gs cannot do it, probably none of the Haskell libs either"
09:00:54 <phadej> so at least it's good PoC
09:01:50 <phadej> I did use gs in one app to compress PDFs (i.e. reduce image size quality from "best" to OnScreen)
09:02:47 <akr> hmm
09:02:55 <akr> alright, I'll think about it some more
09:03:01 <akr> thanks for the suggestions, phadej!
09:03:45 <akr> though in the meantime I found pdf-toolbox-* libraries which seem like might be able to accomplish the stuff I want
09:03:57 <phadej> https://gist.github.com/phadej/2cf8f41c4e3a83e9ad25df261116a890
09:04:02 <phadej> it's not hard ^
09:04:43 <phadej> i mean, you'll probably find the gs command spell on SO, for what you need to do
09:05:43 <akr> yeah, true
09:06:16 <phadej> ... and gs is not texlive
09:06:49 <akr> what's wrong with texlive?
09:07:05 <phadej> akr: if you need it on a server, it's many GB of deployment bulk :)
09:07:21 <akr> ah, right
09:07:23 <akr> that
09:07:49 <phadej> so if you need to *generate* PDF, than HPDF is an option
09:07:52 <phadej> it worked well enough for me
09:08:05 <phadej> as I hadn't any specific font requirements e.g.
09:08:56 <phadej> (I'm not sure if HPDF can embed fonts)
09:09:52 <asheshambasta> Any ideas about this will help: https://github.com/haskell-servant/servant/issues/999#issuecomment-472114938; basically, we'd like to be able to use JSON "strings" to return to the clients 
09:34:14 <whittle> I’m trying to better understand when the type checker allows values to be polymorphic, and when it insists that they must be concrete types. I’m having trouble Googling for more information; is there a Googlable name for this? 
09:43:48 <glguy> whittle: Do you have an example of what behavior your interested in understanding? Is it related to the "monomorphism restriction"?
09:44:07 * hackage datadog-tracing 1.3.0 - Datadog tracing client and mock agent.  https://hackage.haskell.org/package/datadog-tracing-1.3.0 (fommil)
09:51:03 <coldpress> is it possible to define a GADT without a phantom type?
09:51:40 <Taneb> coldpress: why do you think that GADTs need phantom types?
09:52:45 <pie_> do either Eta or Frege provide jar files that can be embedded in an application?
09:53:35 <coldpress> Taneb: otherwise there is no type equality constraint, like in the Expr data: https://en.wikibooks.org/wiki/Haskell/GADT#Phantom_types
09:54:16 <Taneb> coldpress: GADTs are a generalization of the ADTs I presume you're familiar with (it's what the G stands for)
09:54:36 <coldpress> or rather, I have to declare `data Expr a ...` in order for my `Expr` to be of kind `* -> *`
09:54:43 <coldpress> Taneb: yup, I'm familiar with that
09:55:16 <Taneb> Ah, I think you may have picked up the wrong definition of "phantom type"
09:55:44 <whittle> coldpress: Not all type arguments are phantom types. 
09:56:23 <whittle> Phantom types are a sort of nickname for type arguments that aren’t used. 
09:56:50 <coldpress> so the `a` in `data Expr a` is not a phantom type, but the `a` in `Add (Expr a) ...` is a phantom type?
09:57:02 <whittle> Or rather, aren’t referred to at the value level. 
09:57:21 <whittle> It depends on what happens on the other side of the definition. 
09:57:50 <byorgey> coldpress: no.  If `a` in `data Expr a` isn't phantom, then it isn't in `Add (Expr a)` either.
09:59:25 <whittle> My understanding is that in `data Unused a = Int` a would be considered a phantom type, while `data IsUsed a = (Int, a)` a is just a type argument. 
10:00:14 <whittle> The example you mention is a little weird to me, because the type variable is referenced on the right-hand side, but only recursively. 
10:01:02 <whittle> I wouldn’t personally think of that as a phantom type, but my undestanding is that phantom types are a somewhat informal usage, and may not have a strict definition. 
10:02:53 <coldpress> i see, thanks for the clarification
10:03:07 <whittle> No problem. 
10:03:07 * hackage datadog-tracing 1.3.1 - Datadog tracing client and mock agent.  https://hackage.haskell.org/package/datadog-tracing-1.3.1 (fommil)
10:06:37 * hackage lambda-options 1.0.0.0 - Declarative command-line parser using type-driven pattern matching.  https://hackage.haskell.org/package/lambda-options-1.0.0.0 (ThomasEding)
10:06:55 <Solonarv> whittle: there actually is a strict definition of what "phantom" means
10:07:28 <whittle> Solonarv: Ah, my mistake. 
10:07:33 <Solonarv> each parameter of a parameterized type can have one of three roles: nominal, representational or phantom
10:09:00 <whittle> Thank you, Solonarv, that’s good to know. 
10:09:19 <whittle> Is there somewhere you would suggest I go to learn more about that? 
10:09:53 <Solonarv> there should be a section on type roles in the GHC user's guide
10:10:31 <Solonarv> but broadly speaking, the role of a type parameter tells you how the data type's representation changes when the type parameter changes
10:11:54 <Solonarv> (trying to whip up an example, please hold on for a while)
10:13:41 <whittle> I apologize, coldpress, I seem to have given you a folk definition. Now the real knowledge gets dropped on both of us. 
10:14:29 <Solonarv> ah, I found a blog post: https://reasonablypolymorphic.com/blog/roles/
10:15:14 <Solonarv> a type parameter can be used on the right hand side of a data definition and still have a phantom role; example:
10:15:22 <Solonarv> % data Phantom a = Phantom Int Bool
10:15:22 <yahb> Solonarv: 
10:15:45 <Solonarv> % data AlsoPhantom a = AlsoPhantom Char (Phantom a)
10:15:45 <yahb> Solonarv: 
10:16:53 <whittle> Ah; the latter is like what coldpress ran into, and where I ran headlong into murky water. 
10:20:47 <whittle> Thank you for the clarification, Solonarv. I’m only slowly working my way through Pierce; hopefully I will some day have a better grounding. 
10:23:19 <Solonarv> the intuition of "phantom = isn't used" is mostly right, the reality is just a bit more general
10:23:43 <coldpress> thanks Solonarv
10:23:46 <whittle> Understood. Thank you. 
10:24:13 <coldpress> great resource
10:24:34 <Solonarv> see also the GHC docs for role annotations: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-RoleAnnotations
10:25:57 <fendor> :t \a b -> a + b 
10:25:58 <lambdabot> Num a => a -> a -> a
10:32:38 <whittle> glguy: I apologize, I somehow missed your response to my question earlier. Between the coffee kicking in and coldpress and Solonarv jump-starting my brain, I’m a little more awake now. I was asking GHC to do something dumb, but now I’m over it. 
10:32:38 <whittle> Solonarv++
10:32:46 <dmwit> Seems like it could be nice to have a way to (unsafely) force a role for a parameter somehow.
10:33:14 <dmwit> e.g. think of data IsItPhantom k a = IsItPhantom (If k a Int)
10:33:56 <dmwit> or data IsItPhantom2 m a = IsItPhantom2 (m a)
10:34:33 <Solonarv> I believe you can write role constraints using Coercible and quantified constraints
10:35:27 <Solonarv> for example I think 'forall x y. Coercible (IsItPhantom False x) (IsItPhantom False y)' should get solved just fine
10:35:46 <dmwit> It gets solved iff the data constructor is in scope.
10:38:48 <royal_screwup21> what are least fixpoints?
10:39:03 <royal_screwup21> I'm trying to figure out how to do this: https://prnt.sc/n392oy
10:39:07 * hackage cpsa 3.6.2 - Symbolic cryptographic protocol analyzer  https://hackage.haskell.org/package/cpsa-3.6.2 (mliskov)
10:39:50 <dmwit> royal_screwup21: Do you know what a fixpoint is?
10:40:18 <dmwit> (This isn't really a Haskell question, by the way.)
10:40:39 <royal_screwup21> sort of, but now sure I can totally explain it :( I'll read up on it again
10:40:43 <royal_screwup21> not*
10:40:54 <dmwit> A fixpoint of function f is a value x for which f x = x.
10:41:53 <royal_screwup21> ah ok, so like id
10:41:57 <dmwit> If you have some partial ordering on the domain of f, then a least fixpoint is a fixpoint x such that all other fixpoints y satisfy x <= y in your partial order.
10:42:04 <dmwit> "like id"?
10:42:19 <dmwit> No, you don't get to choose f. You get to choose x.
10:43:17 <dmwit> Well, I mean.
10:43:22 <dmwit> Choose whatever you want.
10:44:14 <dmwit> But if somebody asks you, "what is the least fixpoint of \x -> sqrt ((x+1)/2)?" they're going to be pretty upset if you answer "there is no least fixpoint of the identity function" because that's unrelated to the question they asked.
10:44:40 <royal_screwup21> right I see
10:45:09 <royal_screwup21> so basically it's just a math question; find x if f(x) = x
10:45:16 <royal_screwup21> or find the least x
10:45:27 <dmwit> Yes.
10:45:54 <royal_screwup21> thanks for the explanation! :)
10:52:22 <dnlkrgr> What's the best way to play audio files in Haskell? Is it possible to do it with the `sdl2` library? I saw the function `openAudioDevice` in the `SDL.Audio` module, but I didn't see any way to choose and play audio files in there.
10:52:45 <Solonarv> dnlkrgr: try sdl2-mixer
10:53:40 <Solonarv> although, hmm - the package by that name might not be super well maintained
10:55:21 <dnlkrgr> Solonarv: yeah I also found it, but I couldn't install it with Stack, might try cabal / nix instead
10:56:11 <dmwit> system "mpv filename.wav" -- ;-)
10:56:57 <flebron_> Hi. Getting used to lenses. If I have something like foo^.bar.baz, where the result is a [(a, [b])], how can I say "And now give me the number of b in the second components of each tuple in the list."?
10:57:19 <flebron_> I assume it'll involve _2 somehow, but can't quite figure out the syntax :)
10:59:17 <Solonarv> dnlkrgr: "couldn't install it with stack" ? what error did you get?
11:00:08 <glguy> maerwald: You around?
11:01:06 <flebron_> Ah, .traverse._2 gets me pretty close :)
11:03:36 <Solonarv> dnlkrgr: sdl2-mixer seems to be in all Stackage snapshots since around early 2017, which snapshot are you using?
11:04:41 <dnlkrgr> Solonarv: when running `stack ghci I get this error: https://pastebin.com/raw/LKiD3k4N
11:05:04 <dnlkrgr> Solonarv: my cabal executable section: https://pastebin.com/raw/jKymSQ6H
11:05:37 <Solonarv> dnlkrgr: I was pointing you to sdl2-mixer, not SDL-mixer
11:05:54 <Solonarv> link: https://www.stackage.org/lts-13.14/package/sdl2-mixer-1.1.0
11:05:55 <dnlkrgr> Solonarv: my stack.yaml: https://pastebin.com/KRa1nbdZ
11:06:36 <royal_screwup21> I'm trying to figure out if this is a total function or partial function https://prnt.sc/n39ia7 as I understand it, totaly functions are functions defined on all inputs, partial are those defined only on some inputs. So, do I have to look at the grammar for While to figure this out?
11:10:24 <dnlkrgr> Solonarv: right, I mistakenly said I was using sdl2-mixir. I thought SDL-mixer is better because I saw it being used here (https://stackoverflow.com/a/14011063) and it seems to be more actively maintained. But I can also try sdl2-mixer
11:13:27 <dnlkrgr> Solonarv: putting sdl2-mixer in my depends works. Will try it with that. Thanks :)
11:14:14 <Solonarv> nice!
11:16:12 <bjs> royal_screwup21: the question is whether the function S_ds is not defined for any particular input.  You should ask "are there any inputs missing?" and "are all of the outputs defined" (think about the FIX ...)
11:16:24 <dmwit> flebron_: You might like `to length` as a next piece of the chain.
11:17:25 <royal_screwup21> bjs: I was also thinking: a statement could evaluate to "undefined" when evaluated against a given state. For eg, divsion. Thus it seems like it should be a partial function
11:19:43 <bjs> royal_screwup21: but that would mean that there is some input to the semantic function which doesn't have a value.  the easiest way to see is to actually implement it, write some Haskell and see if you run into any cases that might not be defined by this function.
11:22:36 <royal_screwup21> bjs: I was thinking of a statement like so; if (True) { 3/0; }. It satisfies the 4th semantics, but the resulting is state would be undefined
11:22:47 <royal_screwup21> resulting state*
11:23:16 <bjs> royal_screwup21: I don't see a division operator here, but yes that could be one case
11:25:06 <royal_screwup21> bjs: ah that "a" there is an arithmetic expression. A[a]s evaluates it, and it also covers division
11:25:44 <bjs> ah okay.  Then maybe A is a partial function, which would make S_ds a partial function too.
11:26:11 <royal_screwup21> S_ds is defined like so: Stm -> (State -> State), so yeah
11:26:47 <royal_screwup21> bjs: i think the bottom line is it's partial function because of the division edge case; the ouput for all total functions need to defined, in this case it's not
11:27:06 <bjs> royal_screwup21: what about `while True do skip`
11:28:17 <royal_screwup21> bjs: so Skip is a statement that does nothing. So S_ds [while b do S] covers it I think
11:28:27 <bjs> royal_screwup21: but what is the value?  
11:29:06 <royal_screwup21> hmm yeah I'm not totally sure (I'm a complete beginner to all this btw)
11:29:14 <royal_screwup21> I guess it would have no value?
11:29:52 <bjs> royal_screwup21: and if it has no value then ... that's another place you could say it's partial. 
11:30:31 <royal_screwup21> ah got it, thanks!
11:30:58 <bjs> royal_screwup21: so there are 2 ways something can be partial like this:  for some input there's no definition (a failure) or maybe it just doesn't finish (divergence).  There are ways to add these back into a denotational semantics to make it total again if you really want.
11:32:34 <royal_screwup21> bjs: ah how would that be?  I'm guessing you need to use a Maybe or something, for undefined values? Not sure how you'd combat failures tho.. (the while true do skip)
11:35:34 <bjs> royal_screwup21: well you could say (for example) that [[ while true do skip ]] doesn't return a value but instead returns a pair (Maybe value, Boolean diverged)  (it's more complicated than that, the point was that you can decide whether it's partial or not depending on the exact model and values)
12:11:11 <royal_screwup21> I'm trying to figure out why of these g's are fixpoints on F for the while loop. https://prnt.sc/n3a66i So (a) is definitely not a fixed point. Because when x = 0, the (F g) s = s , whereas g (s) = undefined. (b) and (c) seem like fixpoints. I know I haven't posted all the info (it builds on top of the previous chapter sadly), but if  anyone has an
12:11:11 <royal_screwup21> y idea how to do it I'd love a pointer or two in the direction!
12:34:37 * hackage curl-cookiejar 0.1.0.0 - Parsing and pretty-printing of cURL/wget cookie jars  https://hackage.haskell.org/package/curl-cookiejar-0.1.0.0 (eamsden)
13:17:37 * hackage csound-catalog 0.7.3 - a gallery of Csound instruments.  https://hackage.haskell.org/package/csound-catalog-0.7.3 (AntonKholomiov)
13:26:20 <sam_> join
13:27:16 <sam_> Hi, I am doing my basic research in figuring out how to implement an idea that i have. 
13:27:18 <sam_> 0   I want to build a DSL, which can access data in an immutable log like kafka and in some data store that saves events (eg., Cassandra). I want to DSL to be able to answer questions like:  What events occurred from time t1 - t5 for some user.  What was the last event that occurred for some user.  etc.,  My questions is which language has good support for writing DSL's?
13:27:43 <sam_> https://softwarerecs.stackexchange.com/questions/57140/dsl-for-accessing-kafka-and-data-store
13:31:03 <shapr> sam_: I've heard Haskell is good for DSLs
13:33:07 * hackage b9 0.5.68.2 - A tool and library for building virtual machine images.  https://hackage.haskell.org/package/b9-0.5.68.2 (SvenHeyll)
13:33:52 <sam_> shapr_: I have heard that too and Attoparsec and parsec I've heard are good libs to build DSL's. But what I dont know is how well I can integrate with Kafka and a data store in Haskell. 
13:34:07 * hackage network 3.0.1.1 - Low-level networking interface  https://hackage.haskell.org/package/network-3.0.1.1 (dukerutledge)
13:40:37 * hackage cmt 0.5.0.0 - Write consistent git commit messages  https://hackage.haskell.org/package/cmt-0.5.0.0 (smallhadroncollider)
13:53:16 <shapr> sam_: looks like there are several options http://hackage.haskell.org/packages/search?terms=kafka and more on github
13:58:59 <letrec> Hey! Re: https://pastebin.com/mwjanBeB If the getResult function forks (using forkIO) works that manipulates the state, what will happen? Will a change of the state from one worker be visible by another one?
13:59:20 <letrec> Hey! Re: https://pastebin.com/mwjanBeB If the getResult function forks (using forkIO) workers that manipulates the state, what will happen? Will a change of the state from one worker be visible by another one?
14:09:55 <sam_> shapr_: thanks! this is helpful
14:28:52 <sternmull> I use Web.Scotty.Trans with a ReaderT as base monad. I want to add additional context to some of my actions (but not all). Is there a chance i can have a different ReaderT for some actions and run it when a route is handled?
14:32:59 <MarcelineVQ> would local suit your ened?
14:33:02 <MarcelineVQ> *need
14:35:26 <sternmull> MarcelineVQ: Yeah, looks ok. I hoped i could get different ReaderT-types for the different parts of my code, but having just one type that returns Nothing for things that are not there should be ok too.
14:36:34 <c_wraith> sternmull: there's also the standard approach - you write classes for extracting the values you need from the context, then you never write anything except the outermost layer in terms of a concrete context type
14:36:45 <sternmull> Oh wait, there is also withReaderT and others.
14:37:04 <c_wraith> sternmull: then you can vary the constraints on places you use it, and know they can't access more than the constraints let them
14:38:31 <sternmull> c_wraith: I think that is the ideal outcome. But wouldn't i have to do a lot of stuff to be able to run Scotty actions?
14:38:59 <c_wraith> they should just be a lift away, at worst
14:41:17 <sternmull> ok. Will see if i can figure that out. Don't have much experience with monad transformers.
14:43:29 <sternmull> Thanks guys. I will try to take the classes approach. And if that fails i will fall back to local or similar until i have a better understanding.
14:48:07 * hackage hs-functors 0.1.3.1 - Functors from products of Haskell and its dual to Haskell  https://hackage.haskell.org/package/hs-functors-0.1.3.1 (MatthewFarkasDyck)
14:53:37 * hackage hs-functors 0.1.4.0 - Functors from products of Haskell and its dual to Haskell  https://hackage.haskell.org/package/hs-functors-0.1.4.0 (MatthewFarkasDyck)
14:55:07 * hackage chessIO 0.0.0.0 -   https://hackage.haskell.org/package/chessIO-0.0.0.0 (mlang)
14:56:19 <hhefesto> \reconnect
15:14:50 <royal_screwup21> this a bit off topic but I'm trying to determine a fixed point for this piece of code:  while(x !=1) do (y := y⋆x; x := x−1). I know a fixed point is of the form f x = x, but I'm not sure how to map that concept to this snippet of code. I'd love a pointer or two in the right direction
15:20:40 <lyxia> (while b do c) = (if b then (c ; while b do c) else ())
15:20:51 <lyxia> let x = while b do c
15:21:01 <lyxia> x = (if b then (c ; x) else ())
15:21:14 <lyxia> let f x = if b then (c ; x) else ()
15:21:16 <lyxia> x = f x
15:22:24 <royal_screwup21> lyxia: I feel this is just a factorial function, but since the explicit question doesn't specify a starting value for y I'm not sure
15:22:46 <royal_screwup21> the precise question doesn't state any starting values for y though; it gives the code snipper and says: Determine the functional F associated with this statement. Determine at least 
15:22:46 <royal_screwup21> two different fixed points for F .
15:24:17 <lyxia> isn't there an explanation of how to calculate a functional? (I have little idea of what a functional is)
15:28:29 <__monty__> Yeah, seems like niche terminology. I never heard of them in my CS courses.
15:31:24 <Tuplanolla> I just wrote this Hakyll snippet with only a vague idea of what I want, not even bothering to check the documentation. Somehow the types checked and the code worked perfectly on the first try. http://tuplanolla.no-ip.org/tmp/wtf.hs
15:31:58 <Tuplanolla> I wanted to tell you this, because it is such a rare occurrence.
15:33:47 <lyxia> <3
15:33:55 <__monty__> You must be at the apex of the Balmer peak. Quick, write some really significant code!
15:34:39 <Tuplanolla> Quick, throw some open problems at me.
15:35:00 <__monty__> Does P = NP?
15:35:15 <dmj`> probably not
15:45:52 <ddellacosta> is there any way in haskell to make a new sum type out of the values of a sum type you've already created? Like if I have data Foo = A | B | C is there any way to make a subset of Foo like Bar = A | C? I feel like I run into this a lot, which suggests to me I'm thinking about it the wrong way
15:47:30 <royal_screwup21> is anyone here familiar with denotation semantics? I'm trying to answer question 4.2 https://imgur.com/a/MzTN8Rn
15:47:35 <jle`> ddellacosta: the standard haskell way is to redefine Foo in terms of Bar
15:47:42 <jle`> as in Foo = Bar | B
15:47:53 <jle`> er, Foo = FooBar Bar | B
15:48:10 <ddellacosta> jle`: that makes sense. Unfortunately I'm dealing with "someone else's Foo" if that makes sense, so I may not be able to use that approach 
15:48:30 <jle`> there are some fancy things you can do with extensible records/sums that make adt's "first-class" in a sense
15:48:42 <jle`> ddellacosta: ah. no, you can't really do anything if you don't have control over the definition of Foo
15:48:47 <jle`> at least, not structurally
15:49:09 <jle`> hm. actually there might be something you can do with some type-level trickery, but it's probably not worth it
15:49:13 <ddellacosta> right, okay. Yeah I guess what I really want to be able to do is to make statements (e.g. define typeclass instances) for subsets of Foo
15:49:44 <jle`> if you want a disciplined approach, you can try using something like the `refined` library, which may let you define types that are "restricted Foo's"
15:49:49 <jle`> ddellacosta: ah, you're talking about DataKinds ?
15:49:58 <ddellacosta> I probably have to step back and rethink how I'm approaching this problem, and yeah I am both not knowledgeable enough about type-level programming nor do I think this problem is worth the trouble... 
15:50:03 <ddellacosta> oh am I? lol
15:50:12 * ddellacosta goes to re-read about DataKinds
15:50:18 <jle`> the refined type would allow you work with a newtype over Foo so that you can only construct values of that newtype if it isn't B
15:50:25 <jle`> with a 'smart constructor'
15:50:34 <ddellacosta> oh, and let me add another fun constraint: I can only use base
15:50:41 <jle`> ddellacosta: DataKinds would be writing typeclass instances for data constructors, like A, B, or C in your example
15:50:52 <jle`> normally you can't write typeclass instance for data constructors, since they only exist at value level
15:50:53 <ddellacosta> ah okay, that sounds promising actually
15:51:03 <jle`> i mean to ask, that is what you are asking about, right?
15:51:23 <jle`> oh wait, i misunderstood
15:51:28 <jle`> you don't mean to write typeclass instances for A, B, C
15:51:33 <ddellacosta> jle`: I mean, I think so--I hadn't thought it through to that level, as I've described it above is the level of depth I've gotten so far
15:51:37 <jle`> you meant write typeclass instances for types where you would only allow A, or C
15:51:41 <jle`> as values
15:51:43 <ddellacosta> yes, that is it, exactly
15:52:02 <jle`> yeah, one standard haskell way that is somewhat idiomatic would be to use a smart constructor over a newtype
15:52:05 <ddellacosta> like A and C can be constrained by (FooSubSet a =>) kind of thing, although that's a terrible typeclass
15:52:12 <jle`> newtype Bar = UnsafeMkBar Foo
15:52:20 <jle`> and you'd have mkBar :: Foo -> Maybe Bar
15:52:20 <ddellacosta> interesting, okay
15:52:42 <jle`> or like mkBarA :: Bar; mkBarA = UnsafeMkBar A
15:52:54 <jle`> mkBarC :: Bar; mkBarC = UnsafeMkBar C
15:53:14 <jle`> the 'refined' library abstracts over this smart constructor pattern, but you could also just do it by scratch like what i just described
15:53:31 <jle`> then you'd hide the UnsafeMkBar constructor so that the user can't ever create a Bar with B
15:54:04 <jle`> you'd also have to make sure that all of the functions you write using UnsafeMkBar preserve the invariant; GHC won't be able to help you
15:55:04 <ddellacosta> I think I get it but, how do you do the "hide the UnsafeMkBar constructor" bit?
15:55:27 <Solonarv> you just don't export it
15:55:39 <ddellacosta> ah okay, I see, thanks Solonarv 
15:55:49 <Solonarv> (or you do export it and let the scary name tell people that they shouldn't use it willy-nilly :P)
15:55:55 <ddellacosta> haha, right
15:56:11 <ddellacosta> okay jle` , thanks a lot for your thoughts, I'm going to poke at this a bit and see if it works for me
15:56:36 <jle`> UnsafeMkBarDoNotUsePlease
15:56:41 <ddellacosta> lol
15:58:21 <delYsid> that reminds me, I blew on the smart constructor design I just wrote and accidentally exported something that could result in unsafe usage. :-(
15:58:59 <ddellacosta> royal_screwup21: I've gotten help with those kinds of questions from folks in ##dependent before, fwiw--may be another place to ask 
15:59:23 <royal_screwup21> ah cool okay
15:59:45 <ddellacosta> (not that there aren't people in here who could answer it too)
16:00:09 <jle`> ddellacosta: a really overkill thing you could also do is attach a type-level proof that the Foo isn't B, but using this practically would require singletons for Foo, heh. 
16:01:23 <ddellacosta> oh man that sounds like overkill, although I look forward to the day where I understand type-level stuff well enough that I could entertain those sorts of ideas. I gotta finish reading some of your posts I think...haha
16:01:42 <ph88> ski, i finished that algorithm, looks pretty good now
16:01:44 <jle`> it's probably a bad idea in general, but maybe if you're making many different variations of Foo, it could be useful
16:02:26 <ddellacosta> ha, okay, I'll file it away then. May be fun at the leats
16:02:29 <ddellacosta> *least
16:02:32 <jle`> it'd look like data Bar = forall (a :: Foo). Bar (Sing a) (Refuted (a :~: 'B))
16:03:09 <jle`> hm, actually that didn't seem as messy as I thought it would
16:03:19 <ddellacosta> wow, so is :~: some kind of type arg to value-level equality stated at the type-level?
16:03:27 <ddellacosta> type variable I should say
16:03:42 <jle`> a value of type `a :~: b` is a witness that a is equal to b 
16:03:53 <ddellacosta> I see
16:04:06 <jle`> Refuted here is a synonym, expanded it'd be `data Bar = forall (x :: Foo). Bar (Sing x) (x :~: 'B -> Void)
16:04:19 <ddellacosta> yeah that's pretty nice actually, I could roughly get the sense of it without knowing all that syntax
16:04:47 <ddellacosta> huh, what does that require in terms of extensions/libraries?
16:05:09 <jle`> hm. well, it's an existential type, so it requires -XExistentialQuantification
16:05:28 <Solonarv> DataKinds, obviously
16:05:32 <jle`> :~: is a GADT, so it requires -XGADT to manipulate.  but, it's included in base, so it dopesn't require any extra packages
16:05:39 <Squarism> ive been digging into different RPC schemes lately. Thrift, gRPC, graphql and openapi. None of these lets you define your own type constructors (types taking type as argument). >
16:05:55 <Solonarv> TypeOperators so the parser doesn't choke on :~:
16:06:03 <jle`> the heaviest part of this would be the fact that you'd have to generate singletons for Foo constructors.  singletons library would give you TH to do that automatically
16:06:19 <ddellacosta> I see, so sounds like that's something I could do myself but with a lot of boilerplate?
16:06:19 <Squarism> I wonder if there are any RPC scheme that lets your express type constructors?
16:06:30 <jle`> yeah, the main boilerplate would be defining the singleton for Foo
16:06:43 <jle`> which is O(n) LOC on the number of constructors of Foo
16:06:54 <ddellacosta> oh I see, yuck
16:07:04 <ddellacosta> no wonder that uses TH huh
16:07:25 <jle`> yeah. ideally some time within the next few years we wouldn't need it anymore
16:07:43 <jle`> but that's the reality for now :)
16:07:50 <ddellacosta> why is that--because of dependent Haskell, or something more specific coming down the pike?
16:08:03 <jle`> dependent haskell, yeah, so singletons become obsolete
16:08:26 <jle`> the basic usage of singletons is to combat type erasure, and let us manipulate types as first-class values
16:08:43 <jle`> but with dependent haskell, types will already be first-class citizens of the language
16:08:53 <jle`> so there would be no need
16:09:10 <jle`> it's kind of like how lambdas eliminated the need for dummy function classes in Java
16:09:31 <ddellacosta> alright so now I have to ask stupid questions (I understood that last bit about Java at least): in what sense are types _not_ first-class now?
16:10:44 <jle`> one big thing is type erasure, where you can't access and pattern match on the types that your functions are instantiated with
16:11:22 <jle`> which we observe as parametric polymorphism
16:11:39 <reallymemorable> I have a list of strings that are links directly to files online.  Is there a Haskell module / library that I can feed this list of strings to download the files locally?  I see the getURL function constructed here: https://stackoverflow.com/questions/14323265/running-parallel-url-downloads-in-haskell
16:11:45 <jle`> a big example is for fixed-length vector types, like i talk about here https://blog.jle.im/entry/fixed-length-vector-types-in-haskell.html
16:11:47 <reallymemorable> but that seems to be for returning strings 
16:11:59 <jle`> you can't write a general `replicate :: forall n a. a -> Vector n a` function
16:12:16 <jle`> because to generate a vector of n elements, you need to access "n"
16:12:44 <jle`> but because of type erasure, n and a get erased at compiletime, so they only exist in the language for the purpose of typechecking
16:12:53 <Solonarv> reallymemorable: sure, there are a handful of libraries for making HTTP requests
16:13:08 <ddellacosta> jle`: so when I hear "combat type erasure" I think = having information about the types of values at runtime. Is it that simple, or is there more subtlety to it?
16:13:20 <jle`> that's pretty much it :)
16:13:28 <reallymemorable> Solonarv: any one in particular you recommend?
16:13:39 <Solonarv> reallymemorable: yes, but I forget which one
16:13:40 <jle`> i guess i could have stopped here, but i was trying to think of a motivating example where type erasure becomes annoying
16:13:43 <ddellacosta> okay. I see, and I think I get the rest now
16:13:52 <jle`> type erasure is honestly one of the biggest benefits of Haskell
16:13:55 <reallymemorable> lol
16:13:58 <jle`> but there are cases where we might not want it
16:14:01 <Solonarv> jle`: the thing is, we can already combat type erasure
16:14:09 <jle`> yeah, there are already methods to combat it
16:14:15 <jle`> but they all require boilerplate, like i mentioned
16:14:33 <jle`> when dependent haskell lands, types will become first-class, and we won't need any tricks to get around it
16:15:17 <jle`> we've been "combating" it since the beginning, and the Typeable typeclass is even a Haskell98 way to get around it
16:15:20 <Solonarv> reallymemorable: I'd recommend 'req'
16:15:28 <ddellacosta> jle`: interesting...so then my question is, will type erasure then be on a case-by-case basis, depending on what functionality you use? (vs. doing whatever we do now, which I assume is some kind of hack that creates values that explicitly encode the types?)
16:15:50 <jle`> yeah, in languages like idris, it's something you can turn on and off explicitly
16:16:05 <Solonarv> ddellacosta: the current plan has you specifying "don't erase this type, I want to pattern-match on it"
16:16:16 <jle`> i think the method in idris is syntax like `forall {n} a. a -> Vector n a`
16:16:20 <ddellacosta> jle`, Solonarv gotcha, that makes sense
16:16:28 <jle`> which says don't erase n, but erase a
16:16:59 <Solonarv> in Richard Eisenberg's paper a new keyword 'foreach' is introduced, which says "don't erase this"
16:17:49 <ddellacosta> Solonarv: got a link?
16:18:02 <jle`> right now, singletons basically lets explicitly expect or provide a type variable instantiation at runtime by taking it as a GADT value
16:18:08 <Solonarv> so then you could write:
16:18:08 <Solonarv> replicateV :: foreach (n :: Nat) -> a -> Vec n a
16:18:24 <jle`> so right now we have `replicate :: Sing n -> a -> Vector n a`
16:18:50 <Solonarv> ddellacosta: https://cs.brynmawr.edu/~rae/papers/2016/thesis/eisenberg-thesis.pdf
16:19:02 <ddellacosta> oh maybe this? https://github.com/goldfirere/thesis
16:19:03 <jle`> which we can make a little cleaner with typeclass boilerplate as `replicate :: SingI n => a -> Vector n a`.  but this requires writing a typeclass instance for each constructor, which is again pretty hacky
16:19:04 <ddellacosta> oh thanks!
16:19:51 <reallymemorable> Solonarv: thanks!
16:20:09 <Solonarv> also a handful of issues on the GHC repo and several proposals on https://github.com/ghc-proposals/ghc-proposals
16:20:23 <jle`> ^ a very fun repo to Watch
16:21:22 <ziman> idris infers what it can erase so in principle there's no explicit annotation
16:21:51 <ziman> but there are ways to influence what you'd prefer to erase and to get warnings if something you'd expect to be erased isn't
16:23:13 <jle`> ah, thanks :)
16:36:42 <delYsid> jle`: Reading thorugh 0042-record-set-field.rst from ghc-proposals, I notice there is no HasField *extension*, but the proposal mentions it.  Is that a thinko, or am I confused?
16:37:25 <jle`> it might also be an extension in a different proposal, heh
16:37:31 <jle`> i'm nto completely sure
16:38:31 <delYsid> "The ``HasField`` extension defined in the already-implemented `Overloaded Record Fields proposal <https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0002-overloaded-record-fields.rst>`_ introduced ``HasField``, to allow type-based resolution of field names and polymorphism over record selectors."   That sentence looks wrong, as the linked proposal explicitly mentions it does *not* implement a new extension.
16:39:11 <Solonarv> perhaps it's a typo and they meant "The 'HasField' typeclass" ?
16:39:56 <delYsid> They mention the typeclass later in the sentence.  I would have sent a PR, but the sentence looks wrong in two places, so I dont feel like shouting.
16:40:15 <Guest84895> ciao
16:40:58 <Guest84895> !list
16:40:58 <monochrom> Guest84895: http://hackage.haskell.org/packages/
16:41:04 <delYsid> I can see how even people deeply into GHC dev get confused with the sheer number of existing extensions.
16:43:07 * hackage constraints-extras 0.2.3.4 - Utility package for constraints  https://hackage.haskell.org/package/constraints-extras-0.2.3.4 (abrar)
16:44:56 <geekosaur> I think at one point it may have been separate, or renamed
16:46:14 <mouse07410>  I have a string. What's the best way to print it, inserting a space after every two characters (or every three, depending on input parameter)?
16:46:18 <ssobhan> hi
16:47:08 <slack1256> mouse07410: just print it you can use the putStrLn function
16:47:34 <slack1256> % :t putStrLn
16:47:34 <yahb> slack1256: String -> IO ()
16:47:53 <ssobhan> i was trying to solve this https://www.codewars.com/kata/finally-tagless-interpreter/haskell but i really can't figure out what does it mean if something has type `a b c`
16:48:11 <ssobhan> this seems to be valid `let f :: a b c; f = undefined`
16:48:38 <ssobhan> does this mean that a is something polymorphic like Either?
16:48:46 <slack1256> ssobhan: think of an example `a = (->), b = Int, c = String`
16:48:52 <mouse07410> slack1256: I didn't explain - I need to add spaces to the string, every two characters. I don't know how to tell putStrLn to do that.
16:49:13 <ssobhan> slack1256: (->) is a type??
16:49:29 <slack1256> Then `a b c = (->) Int String = Int -> String`
16:49:35 <slack1256> Yep, it's a type constructor
16:49:57 <ssobhan> slack1256: oh, i see; thanks, let me think for a while
16:50:39 <slack1256> mouse07410: String is a `list of char` quite literally in haskell. `String = [Char]`, you can use list manipulation functions to modify that string and the print it with putStrLn ?
16:51:11 <ssobhan> slack1256: but assuming there is a class Language r somewhere defined, type Term a = forall r h . Language r => r h a, r can't be (->) right?
16:52:36 <slack1256> You have to see what are the instances of Language such that `r` can be replaced
16:53:30 <ssobhan> slack1256: can you imagine anything other than (->) that might fill `a b c`?
16:53:37 <slack1256> Usually there is a "prototypical" instance of each class, which is the most important and which intuition the class tries to model. Replace that as an `r` and work
16:53:45 <slack1256> ssobhan: Sure, any type constructor with two parameters
16:53:50 <slack1256> % :t Either
16:53:50 <yahb> slack1256: ; <interactive>:1:1: error:; * Data constructor not in scope: Either; * Perhaps you meant variable `either' (imported from Prelude)
16:53:58 <slack1256> % :k Either
16:53:58 <yahb> slack1256: Either :: * -> * -> *
16:54:03 <slack1256> Either works
16:54:22 <slack1256> % :k (,)
16:54:22 <yahb> slack1256: (,) :: * -> * -> *
16:54:25 <slack1256> The product works
16:55:26 <slack1256> % State
16:55:26 <yahb> slack1256: ; <interactive>:118:1: error:; * Data constructor not in scope: State; * Perhaps you meant one of these: `StateT' (imported from Control.Monad.State), variable `state' (imported from Control.Monad.RWS)
16:55:31 <slack1256> % :k State
16:55:31 <yahb> slack1256: State :: * -> * -> *
16:55:49 <ssobhan> slack1256: i think i have an idea
16:55:53 <ssobhan> thanks!
16:56:04 <slack1256> Also works, as `State s a` is basically `s -> (a, s)` which is (->), returning  a product (a,s)
16:58:44 <ssobhan> then there is this `type Term a = forall r h . Language r => r h a`
16:59:13 <slack1256> yep
16:59:22 <ssobhan> i just don't get it
16:59:36 <orzo> > foldr (\x c st -> case 3 - st of { 0 -> ' ':x:c 1 ; _ -> x : c (succ st) }) (const "") "AlphaBetaGama" 0
16:59:38 <lambdabot>  "Alp haB eta Gam a"
16:59:49 <ssobhan> if something is :: Term a, what is it's type
16:59:57 <slack1256> Term a
17:00:10 <ssobhan> but why forall r.?
17:00:10 <orzo> mouse07410: See my foldr.
17:00:38 <Solonarv> orzo: much simpler using 'chunksOf'
17:00:48 <orzo> is that a prelude function?
17:00:48 <ssobhan> slack1256: assuming there is more than one r that has implemented Language
17:01:14 <slack1256> ssobhan: you don't care what r or h you are given, if the r implements the Language type class the it is of type `Term a`
17:01:30 <slack1256> That is an existential type
17:02:06 <Solonarv> % spaceEvery3 = intercalate " " . chunksOf 3
17:02:06 <yahb> Solonarv: 
17:02:20 <Solonarv> % spaceEvery3 "AlphaBetaGamma"
17:02:20 <yahb> Solonarv: "Alp haB eta Gam ma"
17:02:44 <Solonarv> orzo: there is an implementation in 'split' or in 'extra'
17:02:54 <Solonarv> don't think it's in base but I could be misremembering
17:02:55 <orzo> well, my way is more instructive
17:03:17 <shapr> anyone familiar with hedgehog round trip property? I have this error, but I don't see the difference: https://pastebin.com/ZEsuML5Q
17:04:43 <orzo> chunksOf is nicer by far, but it'd mean bringing a dependency in to avoid a one liner
17:07:32 <Solonarv> you could just copy-paste the implementation from 'extra'
17:07:53 <orzo> yeah
17:07:59 <orzo> probably would tbh
17:08:27 <orzo> unless they refer to a bunch of custom types
17:08:42 <Solonarv> 'extra' is quite lightweight IIRC
17:09:11 <ziman> what's a dependency?
17:09:14 <ziman> you already depend on foldr
17:10:43 <orzo> a dependency is another hackage package to add to your cabal file
17:11:14 <Solonarv> https://hackage.haskell.org/package/extra-1.6.14/docs/src/Data.List.Extra.html#chunksOf
17:11:38 <Solonarv> uses a helper function and is therefore very simple
17:11:55 <orzo> yeah i'd take it
17:12:52 <ziman> ah, i see
17:12:55 <lyxia> shapr: I bet it's in the date
17:13:43 <orzo> repeatedly looks a lot like unfoldr though
17:14:07 <lyxia> shapr: whats the type of a and -a
17:14:52 <shapr> lyxia: Text https://github.com/shapr/httplogmonitor/blob/master/Test.hs#L27
17:17:51 <ziman> > concat . zipWith id (cycle [pure,pure,(:" ")]) $ "alpha beta gamma"  -- can we golf it more? :)
17:17:53 <lambdabot>  "alp ha  bet a g amm a"
17:19:10 <mouse07410> slack1256: the whole question is exactly how to manipulate that [char] before feeding it to putStrLn
17:19:59 <mouse07410> orzo: could you point me at that foldr example you mentioned?
17:20:06 <Solonarv> ooh, zipping - neat!
17:20:58 <orzo> mouse07410: there's about 3 suggestions now that are decent, but mine was: > foldr (\x c st -> case 3 - st of { 0 -> ' ':x:c 1 ; _ -> x : c (succ st) }) (const "") "AlphaBetaGama" 0
17:21:34 <orzo> where 3 and "AlphaBetaGama" should be replaced with inputs
17:22:26 <Solonarv> is there a reason for 'case 3 - st of { ... }' instead of 'if st == 3 ...' ?
17:22:41 <orzo> so i could pattern match the 0
17:22:45 <mouse07410> Thanks! I see that I'm too green to even fully comprehend this example. But I'll copy it and experiment
17:22:46 <orzo> heh
17:22:52 <slack1256> mouse07410: read the documentation for the Data.List module, search it on google
17:24:00 <orzo> when i was writing it, i thought i wanted to keep the result for the next iteraiton
17:24:17 <orzo> but i also wanted to pattern match it, so those desires conflicted i guess
17:24:59 <jle`> > takeWhile (not.null) . unfoldr (Just.splitAt 3) $ "AlphaBetaGamma"
17:25:01 <lambdabot>  error:
17:25:01 <lambdabot>      Not in scope: ‘Just.splitAt’
17:25:01 <lambdabot>      No module named ‘Just’ is imported.
17:25:09 <jle`> > takeWhile (not.null) . unfoldr (Just .splitAt 3) $ "AlphaBetaGamma"
17:25:11 <lambdabot>  ["Alp","haB","eta","Gam","ma"]
17:25:20 <jle`> but i guess you have to intercalate again
17:25:47 <Solonarv> ah yeah, that's another chunksOf implementation
17:26:18 <ondrejs> Hello. I am using servant, servant-auth and servant-websockets. Do you please know a way to auth the user on the websocket endpoint? It does not support Servant.Auth.Server.Internal.AddSetCookie.AddSetCookieApi.
17:27:06 <ondrejs> Which makes sense because the browser won't probably send the cookie to an url on a different protocol.
17:38:39 <shapr> lyxia: you were right
17:38:43 <shapr> │ -         (1858 - 11 - 17) (00 : 00 : 00.000064) UTC
17:38:43 <shapr> │ +         (1858 - 11 - 17) (00 : 00 : 00) UTC
17:40:59 <ondrejs> for anyone interested in my question, for the lack of better alternative, I'll go -- for now -- with my original design: I'll create an endpoint for retrieving temporary tokens, user will connect to ws, sends token and I check it.
17:45:25 <reallymemorable> Solonarv: in req, am I using a GET request in a `req` function to download a file?
17:45:39 <Solonarv> yes
17:46:09 <reallymemorable> how would I specify which directory to send it to?
17:47:01 <Solonarv> it doesn't get sent into any directory
17:47:12 <Solonarv> you get the data in memory
17:47:24 <Solonarv> you can write it to a file yourself if you want to
17:47:44 <reallymemorable> I am trying to use this to scrape a bunch of .gz files onto my client
17:50:43 <reallymemorable> would i write them into memory with req GET, then pull them from memory to my machine?
17:51:08 <Solonarv> yes
17:52:16 <Solonarv> I'm checking if there's a library which handles this for you
17:52:31 <reallymemorable> thanks so much
17:52:37 <reallymemorable> im pretty lost on how to approach this
17:54:34 <Solonarv> hm, there doesn't seem to be a library that just handles "shove the thing at this URL into that file"
17:55:32 <reallymemorable> so i need to write a function that creates an empty .gz file, then pushes the .gz file at the URL into that container?
17:56:15 <Solonarv> you don't need to create the file first, here is some pseudocode:
17:58:17 <Solonarv> do contents <- req GET someUrl ...
17:58:18 <Solonarv>    BSL.writeFile "output.gz" contents
17:59:13 <reallymemorable> ok thanks so much
17:59:29 <Solonarv> (using 'import qualified Data.ByteString.Lazy as BSL')
18:05:07 * hackage hinterface 0.10.0 - Haskell / Erlang interoperability library  https://hackage.haskell.org/package/hinterface-0.10.0 (SvenHeyll)
18:06:07 * hackage massiv-scheduler 0.1.1.0 - Work stealing scheduler for Massiv (Массив) and other parallel applications.  https://hackage.haskell.org/package/massiv-scheduler-0.1.1.0 (lehins)
18:06:09 * hackage dependent-sum 0.5 - Dependent sum type  https://hackage.haskell.org/package/dependent-sum-0.5 (abrar)
18:06:56 <jle`> Solonarv: hm, i usually use wreq or curl for that kind of thing
18:07:12 <jle`> but actually what you already have is great too
18:07:22 <jle`> i guess nothing really gets you around "composition" :)
18:09:09 <Solonarv> yeah it's going to look pretty similar no matter which library you use
18:25:37 * hackage scheduler 1.0.0 - Work stealing scheduler.  https://hackage.haskell.org/package/scheduler-1.0.0 (lehins)
18:27:55 <cads> Hey all, not really a haskell specific problem, but if I wanted to build a /really/ high quality numerical brownian motion simulator, what book or articles should I read?
18:30:59 <cads> on the one hand it seems really easy to simulate brownian motion. Even though brownian motion has guassian increments, one article I read claims (sadly without proof) that it doesn't matter how the increments are distributed, so long as they are independent, mean zero, and with standard deviation proportional to the time step
18:35:22 <cads> This book http://www.columbia.edu/~ad3217/fbm/thesisold.pdf has a whole bunch of results, but about fractal brownian motion, which seems way harder
18:49:48 <[Leary]> cads: sounds like they're invoking Donsker's theorem.
18:57:41 <cads> is it strange that I find donsker's theorem unnacountably wierd?
18:57:58 <cads> like... hey, that's convenient. and spooky.
18:59:03 <shapr> kolmogorov had his hands in everything around that time
19:00:41 <mjrosenb> the 1d variant makes total sense to me, and the extension to higher dimensions does not seem outrageous.
19:03:00 <cads> so theres just some rescaling that sends any random walk to the brownian motion in the limit, and it takes O(n) memory and and time to construct and store that signal for further processing
19:03:38 <cads> it really feels like reaching up into the sky with a jar, and bringing it back with lighting inside it
19:10:25 <mouse07410> jle`: I tried splitStr n s = takeWhile (not.null) . unfoldr (Just .splitAt n) $ s
19:10:45 <mouse07410> But it filled to compile. I am missing something there.
19:11:15 <mouse07410> orzo: thank you - your folder suggestion works perfectly:
19:11:53 <mouse07410> d8d8d8splitStr n z = foldr (\x c st -> case n - st of { 0 -> ' ':x:c 1 ; _ -> x : c (succ st) }) (const "") z 0
19:16:40 <geekosaur> this somehow strikes me as "if it's random, it's random"
19:17:10 <geekosaur> i.e. would be tautological if it were equality instead of isomorphism?
19:21:30 <cads> well, it's classified as a limit theorem, so I guess the it's just that idea that the brownian motion plays a role similar to a normally distributed variable
20:02:37 <adarqui> hi. any haskell persistent folks? any idea how to insert a record with a specified primary key id? ie, if the model has an implicit id, how to set that? or do i need to create an "idAlias sql=id" field and use that?
20:04:48 <adarqui> trying to insert a record with primary key id = 1
20:28:53 <mjrosenb> possibly a silly question: filter (is _Right) (foo ^. bar) -- is there a lensy-way to do that filter?
20:32:00 <glguy> Do you actually want to keep the Either type?
20:32:36 <mjrosenb> yes.
20:33:00 <glguy> It's not better, but you can write: toListOf (bar . folded . filtered (is _Right)) foo
20:33:25 <glguy> or the less lensy version: filter isRight (bar foo)
20:36:14 <mjrosenb> I think I'm just going to forgo lenses for this operation until I have a better grasp on them
20:39:42 <dmwit> You might also like partitionEithers.
20:51:37 * hackage hw-ip 2.3.1.0 - Library for manipulating IP addresses and CIDR blocks  https://hackage.haskell.org/package/hw-ip-2.3.1.0 (haskellworks)
20:58:10 <jle`> mouse07410: what was the compile error?
21:11:12 <remexre> is there a category/group/etc -theory term for an "unconsable functor," i.e. class Functor f => Unconsable f where uncons :: f a -> Maybe (a, f a) ?
21:26:32 <jle`> remexre: hm, not math, but that's essentially the Cons typeclass from the lens library, except `Cons` would also have an equivalent of `cons :: a -> f a -> f a`
21:27:14 <jle`> hm actually nvm, lens's Cons is not higher-kinded
21:27:52 <remexre> so it you can do a lens from a Char into a Text and such, right?
21:27:59 <jle`> it's essentially the same, but for specific types
21:28:01 <jle`> yeah
21:28:39 <jle`> so for Char and Text it has uncons :: Text -> Maybe (Char, Text) and cons :: Char -> Text -> Text
21:28:44 <remexre> yeah
21:29:06 <jle`> actually lens Cons has functions with those exact names heh, i didn't realize
21:29:23 <remexre> I guess it'd make sense to do class (Functor f, forall a. Cons a (f a)) => ConsableFunctor f ?
21:30:11 <jle`> you could just have (Functor f, forall a. Cons a (f a)) as a constraint wherever you want to use cons/uncons
21:30:18 <jle`> actually you don't even need Functor f
21:30:22 <jle`> depends on what you're doing
21:30:36 <remexre> I'm mostly looking for what laws need to hold in practice, so it's useful to require either a Functor or Foldable (or Traversable) instance
21:30:53 <remexre> I came here since I know people here know category theory :Pz
21:31:38 <jle`> what is your final goal?
21:32:27 <remexre> I'm considering making a thing that takes a definition and properties/proofs/tests about it, tries to weaken constraints, then suggest a more efficient data structure for it
21:33:13 <remexre> so e.g. a tokenization function (in a NLP sense, not a PL sense) could be written in terms of String but should be suggested to be Text/ByteString
21:34:15 <remexre> and ideally sufficiently intelligent heuristics would note that a (BTree Char) would be a poor choice and not suggest it
22:07:07 <inkr> hey guys
22:12:41 <inkr> what do you call it when a single value gives multiple results
22:13:01 <inkr> generally, when a query produces a list of objects or something.
22:15:12 <jle`> mathematically? sometimes it's called a multivalued function
22:19:13 <inkr> jle`: i want to develop a multivalued function. how do i start?
22:19:47 <jle`> well, do you have any idea what you would want the function to do?
22:20:04 <inkr> in limits and derivitives, i've seen split functions but those are single values given a specific condition
22:20:21 <inkr> jle`: I'd want my function to answer questions
22:20:42 <inkr> deepthought('answer') => 42
22:20:54 <osa1> anyone know how to do treeStoreSetColumnTypes on initialization in gi-gtk? for some reason `new TreeStore [ #columnTypes := ... ]` doesn't work
22:21:12 <jle`> inkr: there's no general process of creating a function to match certain relationships
22:21:21 <inkr> deepthought('answer') => [42, 'what is the question', 'earth', '6/2']
22:21:46 <jle`> inkr: however, if you have specific questions, we can look at how to develop a functino for a specific question
22:22:03 <inkr> jle`: how do i make a recommender or question answering system?
22:22:18 <jle`> there is no general process of building one
22:22:30 <jle`> for general questions and answers
22:22:33 <inkr> more specifically a recommender, because then i wouldn't have to think up questions, just queries.
22:22:48 <jle`> but if you know specific questions or patterns, then you can look at trying to find functions for those specific types of problems
22:23:37 <inkr> jle`: are you saying if question in question bank, return answer
22:23:54 <inkr> that's just if-statements matching what is known
22:24:11 <inkr> i think search algorithms would be a starting point.
22:24:16 <inkr> i think..
22:24:20 <mjrosenb> that's really all that computers can do.
22:24:23 <inkr> is search a function?
22:24:36 <jle`> i'm saying that you can't start building such a function until you have more details in the types of questions you are trying to answer
22:24:44 <inkr> mjrosenb: how about probabilistic rather than deterministic outputs
22:25:08 <inkr> jle`: i want to build the question too xD
22:25:42 <inkr> ok, the question is an item
22:25:43 <mjrosenb> as it turns out, computers are deterministic.
22:26:05 <jle`> is this ... related to haskell?
22:26:30 <inkr> jle`: i think it can be modelled in haskell. I'm still learning the language.
22:26:57 <inkr> the question is an item with a description, title, category and keyword tags
22:27:10 <remexre> this sounds like a prolog problem tbh
22:27:23 <remexre> or mercury, if you want something with types
22:28:32 <inkr> remexre: well, I have to finish this soon, hopefully in a few hours today so I have something to tickle my professors with.
22:28:49 <inkr> i like haskell because it's functional, and I like that word.
22:29:05 <inkr> hearing about mercury for the first time
22:29:09 <inkr> will look into it
22:29:56 <inkr> what type of problem is haskell best for, actually?
22:30:06 <remexre> yeah, in the same way Haskell is like Scheme/Lisp, Mercury is like Prolog
22:31:34 <remexre> tbh that's like asking what type of problem java is best for
22:33:12 <suzu> typing as much as you can
22:33:44 <remexre> :P
22:34:12 <remexre> a friend actually had a great remark, "Java is a fairly readable IR for the Eclipse programming language"
22:34:19 <suzu> loll
22:35:49 <jle`> haskell is a general-purpose language
22:36:05 <jle`> in practice i think it's great where correctness and long-term maintainability are priorities
22:36:05 <jackdk> suzu I use Haskell in order to do as much typing as I can
22:36:31 <jle`> its biggest weakness might be real-time computing domains
22:36:58 <jle`> it's also good at manipulating denotations :)
23:03:03 <energizer> is there a name for when the string representation of an object will eval to that object
23:07:12 <nshepperd> you mean when you can take the output of 'show x' and put it in your source code to get x back?
23:07:54 <nshepperd> i dunno if there's a particular name for it, but that's supposed to usually be the case
23:09:04 <energizer> thats what i mean yeah
23:24:29 <inkr> reminder: https://chat.stackoverflow.com/rooms/110313/haskell-and-other-functional-languages exists
