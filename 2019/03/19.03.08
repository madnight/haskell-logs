00:23:11 <sicklorkin> what's a good method for detecting outliers in non normal distributions?
00:28:29 <fuzzy_id> i'm currently reading https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#kind-polymorphism
00:28:42 <fuzzy_id> i don't quite get what `Type' stands for
00:28:50 <fuzzy_id> can someone point me to the docs?
00:29:19 <Cale> Type stands for the kind of ordinary types with values
00:29:34 <opqdonut> AKA * ?
00:29:39 <Cale> yes
00:30:06 <Cale> It's a little bit funny for the docs to say "In Haskell 98, the inferred kind of App is (Type -> Type) -> Type -> Type" because Type wasn't around in Haskell 98
00:30:11 <fuzzy_id> so, why don't they use `*'?
00:30:51 <Cale> Well, the long term plan I believe is for * to go away as a notation.
00:31:21 <Cale> But that's not about to happen immediately.
00:36:30 <[exa]> sicklorkin: do you know the distribution in advance?
00:43:32 <Mazhar> Hi Haskell lovers, how are you all?
00:46:38 * hackage genvalidity-property 0.4.0.0 - Standard properties for functions on `Validity` types  https://hackage.haskell.org/package/genvalidity-property-0.4.0.0 (Norfair)
00:47:38 * hackage genvalidity-vector 0.3.0.0 - GenValidity support for vector  https://hackage.haskell.org/package/genvalidity-vector-0.3.0.0 (Norfair)
00:49:53 <merijn> Mazhar: Still waking up with our morning coffee, most likely ;)
01:02:04 <v0d1ch> yes correct :)
01:13:34 <Aleksejs> hello, which is the best way to pause execution until specific file is changed? 
01:14:10 <merijn> Aleksejs: That's OS specific, so it depends on how portable you wanna be
01:14:29 <Aleksejs> merijn: basically linux and macos
01:15:13 <Aleksejs> but isn't there a way to make some recursion using System.Directory.getModificationTime?
01:15:14 <tdammers> inotify
01:15:19 <merijn> Aleksejs: Something like libinotify is probably what you want
01:15:20 <tdammers> not sure if that's a thing on osx though
01:15:27 <merijn> Aleksejs: No, because you'd have to poll
01:15:30 <merijn> tdammers: I think it is
01:15:58 <merijn> Else you'd have to use kqueue
01:16:26 <tdammers> also I've never used it from within haskell, so I'm not sure whether there's a good haskell library for it, but seeing how a few things out there seem to do exactly that, I would reckon they do exist
01:16:32 <merijn> ok, there's kqueue wrappers for inotify, but not sure how they play with the RTS
01:30:08 * hackage bustle 0.7.5 - Draw sequence diagrams of D-Bus traffic  https://hackage.haskell.org/package/bustle-0.7.5 (WillThompson)
01:36:53 <jusss> how I can get 3 from Just 3?
01:38:39 <merijn> jusss: Well, what should happen if you have Nothing?
01:38:52 <Aleksejs> tdammers: I don't really understand how can I execute some code once file is changed, using this lib http://hackage.haskell.org/package/system-inotify-0.1/docs/System-Inotify.html
01:39:37 <jusss> merijn: I don't know, like this value Just 3 is not like in other languages, they don't have this value, they have string and integer
01:40:07 <jusss> Just 3 is a value in haskell is really blow up my mind
01:40:54 <merijn> jusss: What you have is a value of type "Maybe Int", which means you either *have* an Int (like "Just 3") or you have Nothing. The best way to get the three depends on how you plan to use it
01:41:14 <merijn> jusss: For example, if you want "the number or some default value" there is:
01:41:17 <merijn> :t fromMaybe
01:41:18 <lambdabot> a -> Maybe a -> a
01:41:26 <merijn> > fromMaybe 0 (Just 3)
01:41:28 <lambdabot>  3
01:41:32 <merijn> > fromMaybe 0 Nothing
01:41:33 <lambdabot>  0
01:41:49 <merijn> jusss: If you wanna apply a function, but only IF you have a number, there's fmap
01:41:57 <merijn> > fmap (+1) (Just 3)
01:41:58 <lambdabot>  Just 4
01:42:03 <merijn> > fmap (+1) Nothing
01:42:05 <lambdabot>  Nothing
01:42:26 <merijn> > fmap even (Just 3)
01:42:28 <lambdabot>  Just False
01:42:37 <jusss> merijn: put value and Nothing into Just?
01:43:01 <merijn> Not sure what you mean by that? :)
01:43:10 <jusss> merijn: my bad English
01:43:48 <jusss> merijn: put value into a box, and operate value by operate box,
01:44:12 <merijn> :t pure
01:44:13 <lambdabot> Applicative f => a -> f a
01:44:13 <jusss> I don't box if it's a proper express
01:44:23 <merijn> > pure 3 :: Maybe Int
01:44:25 <lambdabot>  Just 3
01:46:15 <jusss> :t Just
01:46:16 <lambdabot> a -> Maybe a
01:46:36 <jusss> :t Maybe
01:46:37 <lambdabot> error:
01:46:37 <lambdabot>     • Data constructor not in scope: Maybe
01:46:37 <lambdabot>     • Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
01:46:56 <jusss> :t Maybe a
01:46:57 <lambdabot> error:
01:46:58 <lambdabot>     • Data constructor not in scope: Maybe :: Expr -> t
01:46:58 <lambdabot>     • Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
01:47:21 <Ariakenom> jusss: You can compare to a list that has zero or one element
01:48:02 <jusss> Ariakenom: Just 3 is 3 or Nothing?
01:48:35 <merijn> jusss: No, "Maybe Int" means something is "Just 3" or "Nothing"
01:49:23 <jusss> merijn: is there a value "Maybe 3"?
01:49:27 <merijn> jusss: "Just" is a constructor that takes a value of type 'a' to make a value of type 'Maybe a' and Nothing is a constructor that has no arguments and makes values of type 'Maybe a'
01:49:39 <Ariakenom> "Just 3 :: Maybe Int", "Nothing :: Maybe Int" "[3] :: [Int]"
01:56:27 <tdammers> Aleksejs: seems fairly straightforward to me. Create an Inotify object, add a watch, and then use `next` to block until the next event arrives
01:56:52 <tdammers> a "watch" is kind of like a subscription to a particular type of change to a specific file
02:03:37 * hackage shh 0.2.0.6 - Simple shell scripting from Haskell  https://hackage.haskell.org/package/shh-0.2.0.6 (lukec)
02:25:27 <HasGonads> hey, I'm learning Haskell for the first time. In general, what does it mean when ghci says some "module" is missing? and what should I do?
02:26:13 <merijn> HasGonads: If it says a module is missing it generally means something is *badly* broken
02:26:16 <merijn> HasGonads: Which OS?
02:26:33 <HasGonads> merijn Mac
02:26:59 <HasGonads> I'm reading the books "Haskell - The craft of functional programming"
02:27:03 <merijn> What's the exact error and how did you install things?
02:27:04 <Taneb> HasGonads: a module you've written or another module?
02:27:27 <HasGonads> This is an excersice in chapter 2 of the book
02:28:06 <HasGonads> this is the error:
02:28:14 <HasGonads> Pictures.hs:18:1: error:
02:28:15 <HasGonads>     Could not find module ‘Test.QuickCheck’
02:28:15 <HasGonads>     Use -v to see a list of the files searched for.
02:28:15 <HasGonads>    |
02:28:15 <HasGonads> 18 | import Test.QuickCheck
02:28:15 <HasGonads>    | ^^^^^^^^^^^^^^^^^^^^^^
02:28:16 <HasGonads> Failed, no modules loaded.
02:31:30 --- mode: ChanServ set +o mniip
02:31:39 --- mode: mniip set -o mniip
02:32:22 <mniip> does anyone have a link to that thing where (N -> 2) -> 2 = N,  in Hask?
02:32:53 <mniip> HasGonads, please use a pastebin next time
02:33:10 <HasGonads> ok
02:33:26 <v0d1ch> HasGonads: I guess you can do `:m + Test.QuickCheck`, you need to have `quickcheck` dep in you .cabal file also
02:33:31 <HasGonads> I think i was disconnected, received no answers to my question.
02:34:07 <HasGonads> v0d1ch how do I do these?
02:34:54 <HasGonads> what is a .cabal file?
02:35:13 <Ariakenom> HasGonads: you were automatically kicked because you pasted a lot of text. see mniip's comment
02:35:38 <v0d1ch> ok here is one link https://www.haskell.org/cabal/
02:35:50 <v0d1ch> with cabal you can build your haskell project
02:36:41 <HasGonads> v0d1ch so this is about modules yes? I need to have Test.QuickCheck in the same directory my own module is?
02:36:42 <v0d1ch> and in yourProject.cabal file you can specify dependencies for your project which in your case is quickcheck
02:37:07 <v0d1ch> you need to `import Test.QuickCheck` in order to use it
02:37:41 <HasGonads> I have done it. but ghci tells me it's missing
02:38:03 <HasGonads> i haven't used cabal for this, I just started writing some Haskell code in a file.
02:38:16 <mniip> then you need to install quickcheck
02:38:23 <HasGonads> just like the codes in the book
02:38:34 <HasGonads> mniip how?
02:39:18 <v0d1ch> you can do cabal init in you project root and that will ask you some questions and generate cabal file at the end
02:39:42 <mniip> it's not the best practice but you can just `cabal install quickcheck`
02:40:16 <phadej> QuickCheck
02:40:25 <HasGonads> No, i don't want anything global. I just want QuickCheck in this module.
02:40:48 <phadej> `cabal v2-repl -b QuickCheck`
02:41:47 <HasGonads> can someone please explain how to create a new project using cabal from scratch?
02:42:04 <phadej> `cabal inti`
02:42:05 <phadej> init
02:42:21 <HasGonads> (and how to install QuickCheck only in that project)
02:42:59 <phadej> after you initialised a cabal project, you can say `cabal v2-build` and stuff happens
02:44:00 <HasGonads> look, Haskell is my first programming language. I have never programmed before, so these "project root" and other words are strange for me.
02:44:28 <phadej> HasGonads: you have some material you follow, a book, a course, something?
02:45:01 <HasGonads> phadej Yes, the book "Haskell - The craft of functional programming, 3rd"
02:45:10 <alieniasty> Good morning :)
02:45:36 <phadej> hmm, I'm not familiar with that book :(
02:46:09 <phadej> and it's quite old, so even if thas some tooling appendix it's badly outdated
02:46:48 <Athas> Wow, 1996.  I'm not sure Cabal even existed then.
02:46:56 <phadej> 3rd is 2011
02:47:04 <Athas> Ah, OK, that's more reasonable.
02:47:08 * HasGonads No guys, the 3rd edition is 2011
02:47:12 <HasGonads> No guys, the 3rd edition is 2011
02:47:32 <phadej> but 7-8 years is still quite old
02:47:40 <phadej> a lot have changed sicne
02:47:52 <HasGonads> I've tried other books, but this book is awesome for me, the author explains very well.
02:48:09 <HasGonads> my problem is only how to create a project using this cabal thing
02:48:31 <HasGonads> and how to install that QuickCheck only for that project.
02:48:58 <phadej> what's your cabal --version says?
02:49:46 <HasGonads> it says <interactive>:1:1: error: Variable not in scope: cabal
02:52:54 <v0d1ch> HasGonads: when I say project root I mean the root folder, folder where you created that haskell file
02:53:21 <phadej> I'd suggest to find some local Haskell person to show you the very basics
02:53:42 <HasGonads> v0d1ch got it.
02:54:09 <HasGonads> phadej I'm from Iran, I think I'm the only on in Iran learning Haskell.
02:54:23 <mniip> that's probably false
02:54:37 <phadej> but still there might not be local meetup
02:55:09 <HasGonads> Even if there is one, I'm not living in the capital, where these things can happen.
02:55:33 <phadej> HasGonads: so, you need to exit your GHCi / repl session
02:55:42 <phadej> and run `cabal --version` as you run `ghci`
02:55:57 <phadej> "in the shell" as we say
02:56:07 <phadej> (terminal, command line)
02:57:28 <HasGonads> I'm doing my masters in Mathematics, I have a lot of friends who are professional programmers but no one has even heard about Haskell, only C++, Java, Python, Ruby, JavaScript, PHP. the thing is I absolutely hate that imperative way of programming. that's why I really like Haskell.
02:57:50 <HasGonads> phadej I did it, but it says no variable in scope
02:58:39 <phadej> that <interactive>:1:1 ... error says that you are in GHCi, you have to get out
02:59:10 <phadej> how you run it? in a terminal or some editor integration?
02:59:10 <HasGonads> oh
02:59:24 <HasGonads> cabal-install version 2.2.0.0
02:59:24 <HasGonads> compiled using version 2.2.0.1 of the Cabal library
02:59:30 <phadej> good
02:59:41 <phadej> and you are running windows, linux or what?
02:59:46 <HasGonads> Mac
03:00:15 <phadej> ok, so you are probably in a directory with your source file, you can check that with `ls` which would list the contents of current directory
03:00:35 <HasGonads> ok, I know this.
03:00:46 <phadej> now there, you could say `cabal init`
03:00:53 <phadej> which is a wizard which will ask couple of questions
03:01:00 <phadej> you may skip one you don't know answer for
03:01:50 <HasGonads> Ok, so can I create a folder on desktop, put my module there and then use cabal init in that folder?
03:02:23 <phadej> yes, `cabal init` will make a skeleton of so called "cabal package"
03:02:39 <phadej> which you can then build using `cabal new-build`, or get into REPL with `cabal new-repl`
03:03:12 <phadej> https://cabal.readthedocs.io/en/latest/concepts-and-development.html <- is something you might want to read through
03:03:24 <phadej> in fact, it explains cabal init
03:03:41 <HasGonads> ok, so we use this `cabal new-repl` instead of that ghci command?
03:04:25 <phadej> yes. cabal will look at the dependencies you declared in your-package.cabal file, and setup the environment properly
03:06:38 <phadej> you'll need to add `build-depends: QuickCheck` to .cabal file
03:08:49 <HasGonads> got it.
03:09:15 <HasGonads> I'm going to read that link and try my best.
03:09:17 <HasGonads> thanks.
03:09:35 <phadej> HasGonads: you're welcome
03:30:40 <im0nde> Hey fellow haskellers! Just getting into the language, can you recommend any haskell specific vim-plugins?   Especially looking for a good linter and autoformatter to use with vim
03:37:12 <zincy> /msg NickServ SENDPASS zincy
03:37:27 <zincy> oops
03:40:22 <phadej> zincy: syntactic can run hlint for you
03:40:53 <phadej> autoformatters are something the community probably will never agree on :)
03:42:36 <phadej> neither i know any which doesn't choke on some Haskell code in the wild
03:49:22 <im0nde> phadej: you mean this one https://github.com/vim-syntastic/syntastic ?
03:50:35 <im0nde> Using vim-autoformat for other languages, but it messes up haskell guards, the '|' are not correctly indented
03:54:48 <Rembane> im0nde: I am very fond of Brittany, it lets me not think.
03:57:25 <phadej> im0nde: yes
03:57:47 <phadej> im0nde: stephen diehl has an article on vin setup too
03:58:00 <phadej> google should find it too
03:58:21 <phadej> you may pick something from there
03:58:40 <im0nde> phadej:Thanks, just found it. That seems really helpful
03:59:03 <phadej> i use something from there, not all
04:21:02 <fen> data Cycle i f a where Pointer i f => f (Either a (i,i -> Cycle i f a))
04:21:49 <fen> this way, its up to the user to place `i -> Cycle i f a' at the cyclic references
04:22:14 <fen> this is important, since different navigation schemes can be more efficient in different settings
04:24:38 <fen> for example partially applying navigate to the completed version can be faster than selecting from a lookup of stored pointers navigated to the location corresponding to the lookup returned during accumulation during duplicate
04:25:13 <fen> returned from*
04:26:16 <fen> this is the case for pointers with several directions of navigation, since it might be faster not to visit every location on the traversal path to get to some location
04:28:10 <fen> however, if the number of cyclic references is large enough, then it might be faster to visit every location, so accumulating cyclic nodes during traversal used in duplicate might be faster, that is, its faster to navigate over each location between cyclic nodes than to start from the top each time
04:29:26 <fen> this difference in performance means that fixing the implementation of accessing cyclic references should be left to the user, which is why the (i -> Cycle i f a) appears in the definition of the Cycle datatype
04:32:07 * hackage cmt 0.3.0.0 - Write consistent git commit messages  https://hackage.haskell.org/package/cmt-0.3.0.0 (smallhadroncollider)
04:59:38 * hackage reflex 0.5.0.1 - Higher-order Functional Reactive Programming  https://hackage.haskell.org/package/reflex-0.5.0.1 (luigy)
05:27:51 <Wizek> I take it that regular StateT monad transformers cannot handle changing of the state type. Do we need indexed monad to have that? Or is there another way?
05:28:20 <merijn> Wizek: How does the state type change?
05:32:24 <Wizek> merijn: In the specific case, I was thinking of having trees-that-grow style records that could be written to and read from. E.g. `data Foo a b = Foo {a :: a, b :: b}`, and I was wondering if I could make sure that at certain points we have `Foo () ()`, at another `Foo Int _` and another `Foo _ Bool`, etc.
05:33:08 * hackage random-access-file 0.1.0.0 - Random file access methods, supporting application-level page cache.  https://hackage.haskell.org/package/random-access-file-0.1.0.0 (IlyaPortnov)
05:34:40 <dminuoso> Wizek: newtype IStateT m i o a = IStateT { runIState :: i -> m (o, a) }
05:35:11 <lyxia> you can change the state type by using runState in the middle of your program with the different state type.
05:35:55 <Wizek> dminuoso: Will I need IMonad for that? Or would that work with Monad just as well?
05:37:36 <dminuoso> Wizek: Yes, and you can also add some helper IMonadTrans for lifting from regular monads into the indexed monad.
05:38:31 <Wizek> lyxia: would that work if I have something like this? `modify (a .~ () & b .~ ()) >> modify (a .~ 1) >> modify (b .~ True)`
05:39:47 <Wizek> dminuoso: that sounds scary. Are there caveats? Will I need lots of instances? Can it have a MonadFix instance?
05:40:17 <lyxia> that does look like an IMonad thing, so what I said wouldn't work.
05:52:51 <dminuoso> Wizek: Its not particularly scary. As for the instances, I dont know what you are doing.
05:53:07 <dminuoso> Wizek: You could transform your stack into an indexed monad locally, do your thing, and get back.
05:57:34 <Wizek> dminuoso: It would be part of a reflex-dom app. There are a lot of instances for MonadWidget, MonadHold, DomBuilder, EventWriter, etc... `mdo` is also sometimes required, hence my question about MonadFix. Here is a list of what MonadWidget needs: https://hackage.haskell.org/package/reflex-dom-0.3/docs/Reflex-Dom-Class.html
05:57:39 <HasGonads> Hi. Haskell is my first programming language guys. I'm doing a masters in mathematics and have no experience in programming. I have read a lot about computers and programming, I know some stuff but I haven't done anything in practice but I want Haskell to be my first language (I hate imperative and OOP), but the problem is I don't have a good basic knowledge. can you suggest some books so that I can learn about the basics of
05:57:39 <HasGonads>  software development? 
05:58:03 <dmwit> ?wiki tutorials
05:58:03 <lambdabot> https://wiki.haskell.org/tutorials
05:58:52 <HasGonads> Particularly the words like "projects", "project root", working with the terminal etc.
05:59:34 <HasGonads> I was thinking about the book "Invitation to computer science", is it good?
06:07:27 <gentauro> is this equivalent? (do notaion) `.. = do foo (); return bar` with `.. = foo () >> return bar`?
06:07:42 <opqdonut> yes, exactly
06:08:10 <opqdonut> https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
06:08:42 <dminuoso> gentauro: You can also use <$ or $>
06:08:57 <gentauro> opqdonut: thx for the link
06:09:19 <dminuoso> % :t getLine $> ["foo", "bar"]
06:09:19 <yahb> dminuoso: IO [[Char]]
06:09:49 <ent-> HasGonads: looking at the contents, it looks like a more general 
06:09:49 <gentauro> I guess `;` is only used in `do notation` when people want to make one-lines. It's not needed with multi-line code
06:10:17 <ent-> HasGonads: more general intro to computer science (which might be nice), but the things you list probably won't be covered
06:10:21 <dmwit> Yes, there is always a choice between layout and explicit ;.
06:10:45 <dminuoso> gentauro: It's also used by some people in multi-line do-notation
06:10:50 <gentauro> but `>>` will always be needed, no matter `one-liners` or `multi-liners`
06:10:55 <dminuoso> gentauro: In those cases its frequently used as a prefix.
06:10:58 <dmwit> (Well, not quite, I guess. If you use braces then layout is disabled. That's very uncommon.)
06:11:22 <HasGonads> ent- So how do I learn about those?
06:12:22 <ent-> for projects (in haskell), I'd take some beginner resource on haskell
06:13:33 <ent-> if you want a book, this is often recommended http://haskellbook.com/
06:14:59 <HasGonads> ent- thanks. is there a book about these concepts in general? I want to learn about how to put together files and folders for building a software.
06:16:04 <ent-> there's really no general way to do that, the conventions are different between programming languages and frameworks
06:16:46 <ent-> so a beginner resource on a given language would usually tell you how things are done there
06:18:37 * hackage reanimate-svg 0.8.2.0 - SVG file loader and serializer  https://hackage.haskell.org/package/reanimate-svg-0.8.2.0 (DavidHimmelstrup)
06:19:44 <__monty__> HasGonads: How do you know you hate both OOP and imperative programming if you don't know any programming languages?
06:19:59 <__monty__> There's plenty of books on software engineering, none of them are great.
06:21:18 <__monty__> Hutton's book is another good book about haskell, CIS 194 seems the most popular resource currently and there's also the venerable LYAH and RWH, not great pedagogy in the former and some outdatedness in the latter according to most.
06:22:56 <dminuoso> If you are completely new, the haskellbook might be attractice too.
06:23:01 <dminuoso> It's very easy going.
06:25:28 <HasGonads> __monty__ I "know" a lot of languages, I read a lot about them and I have seen a lot of programs and the way they program and also about different paradigms but I haven't actually programmed myself.
06:26:19 <HasGonads> __monty__ but I'm sure I absolutely hate the imperative way of thinking.
06:27:35 <dminuoso> HasGonads: The imperative way is not worse really.
06:27:42 <dminuoso> It's a useful model in many ways.
06:28:18 <dminuoso> I'd argue that imperative programming is done in Haskell just as much as in most other languages.
06:29:15 <dminuoso> Some people like SPJ have argued that Haskell may in fact be the best imperative language. ;)
06:30:46 <HasGonads> dminuoso you're right, but not for me really. I love the idea of functions, composition, specially types and typeclasses. 
06:31:00 <HasGonads> do we have these in imperative languages?
06:31:14 <opqdonut> (rust has something like type classes?)
06:31:53 <__monty__> Traits, right? I'm not sure how similar it is to type classes.
06:32:53 <HasGonads> they just have 1 million variables, step by step telling it how to do it. I hate these. I love function composition and the neat organization of Haskell
06:33:41 <openheavens> is there any haskell study plan out there that shows the various topics you need to cover from beginner to expert? 
06:33:56 <dminuoso> openheavens: CIS194 is a good course.
06:34:07 <HasGonads> __monty__ Not sure, you know much more than me. of course i can't argue with you :)
06:34:08 <dminuoso> openheavens: After that it's just writing code on your own.
06:34:30 <dminuoso> openheavens: Being an "expert" is the result of having years of practical experience.
06:35:33 <openheavens> dminuoso: thanks
06:35:37 <merijn> openheavens: There are many different ways in which you can be a haskell expert, tbh
06:35:48 <merijn> openheavens: It depends what sorta thing you're interested in
06:38:21 <openheavens> merijn: Would like to be proficient enough to build scalable production-grade web and mobile applications using haskell
06:39:37 <dminuoso> openheavens: Im not sure whether Haskell is the right technology if your goal is to write mobile applications.
06:40:32 <fen> % newtype Cycle i a = Cycle (Cofree (i -> Cycle i a) a)
06:40:32 <yahb> fen: ; <interactive>:32:28: error: Not in scope: type constructor or class `Cofree'
06:40:41 <merijn> I think it certainly could be, your initial experience will just be a bit more rough
06:41:47 <dminuoso> merijn: JNI? NDK?
06:41:54 <fen> % :m + Control.Comonad.Cofree
06:41:55 <yahb> fen: 
06:41:57 <fen> % newtype Cycle i a = Cycle (Cofree (i -> Cycle i a) a)
06:41:57 <yahb> fen: ; <interactive>:34:36: error:; * Expected kind `* -> *', but `i -> Cycle i a' has kind `*'; * In the first argument of `Cofree', namely `(i -> Cycle i a)'; In the type `(Cofree (i -> Cycle i a) a)'; In the definition of data constructor `Cycle'
06:42:14 <zincy> openheavens: The first step is to understand the topics in HaskellBook by Chris Allen
06:42:16 <dminuoso> merijn: The AJHC project has been shut down, no real development on the JNI front afaik either.
06:42:36 <merijn> dminuoso: Cale worked on an action RPG on mobile
06:42:47 <zincy> After you understand monad transformers you can go back and master the basics and then there are lots of different routes.
06:42:55 <merijn> dminuoso: I heard it worked fine from a technical point of view, they just ran out of funding to finish it
06:43:21 <zincy> The bulk of the work from then is understanding the web dev libraries if you want to build apps
06:43:25 <merijn> dminuoso: So it's demonstrably possible, if you're willing to accept investing more time/effort up front due to the lack of polished dev experience
06:43:38 <dminuoso> merijn: Fair enough.
06:44:20 <fen> % newtype Cyclic i a = Cyclic (Cofree (Cycle i) a);newtype Cycle i a = Cycle (i -> Cyclic i a)
06:44:20 <yahb> fen: 
06:44:28 <fen> whats that?
06:45:36 <fen> what properties does it have? how can it be used?
06:46:26 <fen> its supposed to be a generalisation of a multiple linked list
06:46:46 <fen> maybe i = Int ?
06:47:04 <merijn> fen: 'i' seems like the index, yes
06:47:27 <fen> itcant be Num a => a?
06:49:07 <fen> seems like it could be the lookup of a Map. like, we could have a 2d square of "branches" and have an (Int,Int) accessor 
06:49:46 <fen> or like, ingoing branches and outgoing branches, so (Bool,Int)
06:50:34 <fen> would RealFrac i be like a manifold or something?
06:52:43 <fen> could be like `i' is an element of a group "acting" on a value in some space, like a lie group or vector field or something
06:53:18 <Ariakenom> zincy: by Chris Allen and Julie Moronuki
06:53:21 <bec> Does anyone has experience with variable success responses in Servant ? i.e. I would like to be able to return either 200 or 208 response, but as far as I understand, the success code is embeded in the endpoint (i.e. Post is 200, PostAccepted is 202). Am I missing something here ?)
06:55:34 <fen> is there something that can be understood about it just using formal methods?
06:56:34 <merijn> fen: The Num hierarchy is pretty unrelated to any form of formal mathematical definition
06:56:34 <fen> like, some similarity with a loeb like thing or something commonly studied?
06:56:56 <fen> yeah, thats why real or fractional seemed more like what was trying to be said
06:57:12 <fen> basically just mean compact
06:58:10 <fen> like an infinitesimal lie group generator
06:58:50 <fen> well, actually it could be any value of the lie group, it doesnt just need to refer to the infinitely close locations
06:59:17 <fen> just thinking about it like that because graphs are like with edges between nearest neighbours 
07:00:21 <fen> where the continuous limit of infinite edges then seems like a dense circle or sphere 
07:00:50 <fen> but if it can also make edges to any other place its kind of complicated to envisage 
07:01:17 <fen> thats why it would be good to just try and think about what we can understand about it based on the types
07:03:32 <fen> either that or actually try to formalise that concept / difficult intuitive thing in terms of manifolds 
07:04:21 <fen> i know nothing about atlases or coverings and frames being glued together or any of that topology stuff
07:06:03 <fen> abstracting over the type of the index of the edge seems crazy to understand 
07:09:11 <fen> seems like the most general thing to do with values is to partition them into collections, maybe, labelling (pairing?) them with other types
07:09:28 <fen> dare not try to imagine what would happen if it was a function...
07:09:45 <fen> though maybe thats just something to do with pairs and currying
07:11:13 <fen> think that generally trying to return values from functions without providing arguments is called a continuation?
07:13:55 <fen> or maybe that also needs proof that you can actually return a value. like, (((a ->b) -> i) -> i)
07:14:25 <fen> totally lost here sorry
07:24:43 <fen> i = ((i -> i) -> i) as an index !? its supposed to store an index as a continuation, and recieve as an index a way to update it...
07:27:06 <fen> hmm, maybe its a tangent bundle
07:27:47 <fen> but that wouldnt capture its ability to connect finitely separated points
07:30:37 <fen> its probably just a worm hole or something
07:37:52 <fen> well, if you connect 2 arbitrary points on a manifold you get a higher genus surface. just not sure what happens if you connect every point to every other point... 
07:38:46 <fen> newtype Cyclic i a = Cyclic (Cofree (Cycle i) a);newtype Cycle i a = Cycle (i -> Cyclic i a)
07:39:03 <fen> wtf
07:42:45 <fen> can get quite a nice markov process from i = (forall a. -> Cycle i a)
07:42:59 <fen>  i = (forall x. -> Cycle i a)
07:48:07 * hackage reanimate 0.1.0.0 - Animation library based on SVGs.  https://hackage.haskell.org/package/reanimate-0.1.0.0 (DavidHimmelstrup)
08:18:04 <fen> %  newtype Cycle i a = Cycle (Cofree ((->) i) a);
08:18:04 <yahb> fen: 
08:18:13 <fen> this is the correct version^
08:18:34 <fen> maybe easier to find where else it appears
08:19:54 <fen> data Cycle i a = Cycle a (i -> Cycle i a)
08:20:07 <fen> thats what it expands to
08:20:31 <fen> "cofree reader" ?
08:37:08 * hackage intero 0.1.39 - Complete interactive development program for Haskell  https://hackage.haskell.org/package/intero-0.1.39 (ChrisDone)
08:41:50 <ski> fen : that's an "odd" synchronous stream processor, from `a' to `i'
08:44:59 <freusque> sometimes I want to use fwarn-unused-do-bind, but ghc seems to do a code transformation step before that and doesn't detect the unused bind. If I write "return 3" in between two operation in a raw IO monad, I get the -Wtype-defaults warning with "_ <- return 3"
08:45:25 <freusque> in other projects, I get both errors, and the -Wtype-defaults warning shows "return 3" instead of the transformed version
08:46:11 <freusque> all warnings are identical and propagated through cabal, one difference is the use of 'library' vs 'executable'
08:46:30 <freusque> am I not understanding something correctly, or does this strike as odd? 
08:46:46 <freusque> I'll make the minimal repro example otherwise
08:55:40 <lyxia> that sounds odd indeed
08:57:40 <freusque> yeah. I'll come back with a minimal example or an explanation
08:59:41 <fen> ski: I cant find any reference using those terms
09:00:08 <fen> its supposed to be a generalisation of a linked list
09:00:47 <fen> eg DblLnk a = Cofree (,)
09:01:40 <fen> instead of supplying various containers to cofree, instead the index they are accessed via is supplied to a partially applied accessor function
09:02:09 <fen> eg for Cofree [], Int would be the index
09:02:42 <fen> this gives a choice to the user of which container they want to use to make a Cyclic thing
09:03:27 <fen> as the "shape of the branches" is governed by the index, regardless of which container is accessed by it
09:03:58 <ski> fen : consider `Stream a -> Stream b', each output `b' can potentially depend on any (finite) prefix of the input stream
09:04:56 <ski> if we think of the items in a stream as progressing through time, iow at the stream as a kind of discrete signal, then this may be undesirable
09:06:12 <ski> you can do `data ASP a b = Get (a -> ASP a b) | Put b (ASP a b)', an asynchronous stream processor, that decides at each time instant whether it now wants to look at the next input, or produce the next output
09:06:52 <ski> or, you can do `data SSP a b = GetPut (a -> (b,SSP a b))', which proceeds in lockstep, one input, one output, repeat
09:07:26 <ski> and i would call that "even", since it start with the input. whereas your version was the opposite, started with the output, then the input, hence "odd"
09:07:40 <freusque> lyxia: found the problem
09:07:51 <freusque> this warning does not work when applicativeDo is enabled
09:08:10 <fen> newtype Cycle i a = Cycle (Cofree ((->) i) a)
09:08:22 <fen> data Cycle i a = Cycle a (i -> Cycle i a)
09:08:54 <fen> thats like the lhs of ASP, but not much like SSP
09:10:05 <ski> the "even" vs. "odd" terminology comes from the Wadler paper "How to Add Laziness to a Strict Language Without Even Being Odd" by Philip Wadler,Walid Taha,David MacQueen in 1998-09 at <http://homepages.inf.ed.ac.uk/wadler/topics/language-design.html>
09:10:35 <ski> fen : it's the opposite order of composing `(i ->)' and `(a,)'
09:10:50 <fen> oh yeah
09:10:51 <ski> (you can also compare with Mealy vs. Moore machines)
09:12:11 <lyxia> freusque: that sounds like a good candidate for a bug report
09:12:49 <freusque> yeah, I'll submit that. the protocol is to use trac for this ?
09:12:56 <freusque> or is the gitlab used nowadays?
09:12:57 <fen> Mealy a b = Mealy (a -> (b, Mealy a b)); Moore a b = Moore b (a -> Moore a b)
09:13:47 <fen> oh, so SSP is a mealy machine, and Cyclic is a Moore machine
09:13:47 <Solonarv> freusque: I'm not 100% sure but I think you want to go to gitlab now
09:13:50 <geekosaur> it might be worth waiting a few days because the cutover is scheduled for tomorrow
09:14:12 <geekosaur> and both will be read-only during it
09:14:34 <freusque> okay I'll wait thanks
09:16:52 <fen> cant easily see what that has to do with our lazy semantics from http://www.diva-portal.org/smash/get/diva2:413532/FULLTEXT01.pdf
09:17:17 <fen> whats wrong with the moore "odd" encoding?
09:18:57 <fen> its not like its producing values, they are stored in a container. maybe its just a different setting where one version is more intuitive
09:21:57 <fen> using a mealy machine to encode list would be like saying you cant get at the head until you read the tail
09:24:24 <ski> it doesn't encode a list, it encodes (or can be viewed as encoding) a stream processor, from an input stream to an output stream
09:25:04 <fen> yeah, thats the other setting, where the input output view is more intuitive
09:25:15 <ski> so the question, assuming that we want to ensure that "any output can't depend on future inputs", is the corner case : can the first output depend on the first input, or not ?
09:25:42 <ski> > scanl (+) 0 [2,5..]  -- here, the first output is always `0', regardless of the input stream
09:25:44 <lambdabot>  [0,2,7,15,26,40,57,77,100,126,155,187,222,260,301,345,392,442,495,551,610,67...
09:26:08 <ski> it's just that, often (not always), i think the "even" way makes more sense
09:26:36 <fen> do we move to that setting when instead of saying eg Cofree Identity = stream, using Cofree ((->) () )
09:28:17 <fen> no, the value at the top of a tree does not depend on which branch you navigate down
09:28:30 <ski> i suppose
09:28:45 <ski> the difference between labelling the nodes, and labelling the edges/branches
09:29:51 <fen> the nodes are labled with values? and the edges by the `i' that would be used to navigate over them?
09:31:42 <fen> so a pointer is a stream processor accepting navigational directions and returning stored values
09:33:42 <fen> isnt the problem with this the idea of one thing placing values into another, with the notion of blocking
09:33:58 <fen> not sure how this notion of concurrency is relavent
09:35:14 <fen> a container just waits to be read... it doesnt have this idea of a sink 
09:36:42 <fen> not sure if all of machines is relevant then.
09:36:43 <fen> http://hackage.haskell.org/package/machines-0.6.4/docs/Data-Machine-Type.html#t:Step
09:39:31 <fen> yield makes it seem like it has only a tail, no branches
09:39:54 <fen> data Step k o r   = Stop   | Yield o r   | forall t. Await (t -> r) (k t) r
09:40:00 <fen> and what does Await do?
09:40:48 <fen> if t is supposed to be the input edge label to get to the next node, it shouldnt be forall t. and whats up with returning (k t) ?
09:42:08 <fen> newtype Machine k o = Machine (Step k o (MachineT m k o))
09:42:21 <fen> newtype Machine k o = Machine (Step k o (Machine k o))
09:43:14 <ski> if `k' is a (covariant) functor, then `exists t. (t -> r) * k t' is just `k r' (by Coyoneda)
09:44:20 <Solonarv> so this forall t. Await (t -> r) (k t) r constrctor is roughly equivalent to Await (k r) r
09:44:29 <ski> yes
09:44:46 <fen> so k is the container of branches. like Cofree k for a tree
09:45:27 <ski> (probably Coyonedaed, for efficiency, i assume ?)
09:45:38 <fen> guess its "await" because its waiting for the user to do that fmap. a bit like (forall x. x -> a)
09:45:56 <fen> needs a forall x. to be supplied
09:46:00 <ski> rather waiting for the user to select an `r' ?
09:46:33 <ski> `forall x. x -> a' is `(exists x. x) -> a' is `1 -> a' is `a'
09:46:50 <fen> a bit like saying a stream is () -> Stream a -> (a,Stream a)
09:47:38 <fen> is it somehow encoding the idea that it needs to be prompted to return a value
09:48:25 <fen> and even without that complication, whats; Await (k r) r
09:48:56 <Solonarv> so, inlining Step, we have: data Machine k o = Stop | Yield o (Machine k o) | Await (k (Machine k o)) (Machine k o)
09:49:07 <fen> i dont want "a value and a tail, or a collection of tails and another tail"
09:49:12 <fen> whats that doing?#
09:50:25 <fen> probably this collection of tails and a tail is just incase k is empty, like proxy or something, ensuring its nonempty
09:51:23 <fen> so its either "a value and a tail (yield)" or "a nonempty collection of tails/branches (await)"
09:51:52 <fen> why not just have "a value and a nonempty collection of branches"
09:53:20 <fen> data CycleF f a = Cycle :: Nonempty f => a -> (f (CycleF f a)) -> CycleF f a
09:53:50 <stevenxl> Hi folks. Can anyone check my math on this problem, figuring out the cardinality of "Either Bool (Bool, Maybe Bool -> Bool)"
09:53:50 <stevenxl> https://gist.github.com/StevenXL/096712d256b4d514d677e2554ab86001
09:54:05 <Solonarv> you can instantiate k to e.g. '((->) i)' and get data Step ((->) i) o r = Stop | Yield o r | Await (i -> r) r
09:54:40 <fen> oh
09:54:41 <fen> nice
09:54:43 <fen> thanks
09:56:01 <fen> but still, why not just Stop | Something o (i -> r)
09:57:23 <fen> argh, its like a graph that navigates itself
09:57:26 <Solonarv> because then you aren't able to encode a machine that says "I don't actually need to look at any input, I can just give you a bunch of values"
09:57:28 <fen> thats no good at all
09:58:13 <fen> i would really prefer the pointers which require instructions before a navigation occurs
09:58:14 <Solonarv> e.g. 'Yield 1 (Yield 2 (Yield 3 Stop))' (newtype wrappers elided)
09:58:58 <fen> oh so you can grow the tail only so far, and then it requires an input to choose which branch to take
09:59:14 <fen> a bit like the "stemTree"
09:59:25 <Solonarv> or: 'map f = Await (\i -> Yield (f i) map) Stop' -- this actually needs all three constructors!
10:00:02 <fen> so whats wrong with removing the special case of a one branch node
10:00:49 <fen> actually, for this multiple linked application, this Yield is impossible, there are always at least 2 edges, excpet if there is only one node
10:01:00 <Solonarv> another example: 'filter p = Await (\i -> if p i then Yield i (filter p) else (filter p)) Stop'
10:02:41 <fen> Yield gives the possibility of an irrevesable navigation
10:03:29 <fen> its no good for pointers, where on the other end of the edge is a complete copy of the graph, just in a different position
10:03:41 <fen> well, this is the multiple linked idea. 
10:04:11 <fen> these tail calls of yield are smaller machines
10:04:28 <fen> the size of the pointer needs to be preserved during navigation
10:04:49 <ski> (hm, i suppose fen hadn't seen machines before)
10:06:30 <fen> ski: the Stack,Linear,Stream were not cyclic. they only had tails, no double link. a zipper is effectivly a way of carrying the extra information, but DblLnk a = Cofree (,) compresses the zipper and f datatypes into one
10:07:29 <fen> trying to extend this to pointers of multiple orthogonal navigational directions gives a Moore machine on the lookup of the branches (edge label)
10:08:44 <fen> which is the generalisation over multiple linked lists where the branches container is abstracted away instead by referenceto its lookup
10:09:54 * ski at best, only understands a third of what fen is talking about
10:10:12 <fen> a machine with Yield breaks this by not having enough branches to container a reference to the cotail, or reverse portion of the zipper
10:10:56 <ski> hm, by "cotail", do you mean the context around the current node, like its parent, and further ancestors ?
10:11:33 <fen> exactly
10:11:49 <fen> the previously navigated part of the tree
10:12:17 <fen> the "double" link
10:12:45 <fen> basically, the Moore machine is not representable in terms of that machine type above
10:13:59 <ski> would that also include the context in which the whole tree is possibly situated ?
10:14:28 <fen> this whole idea of something that ocasionally produces values and the rest of the time needs inputs to progress, is wrong for pointers, which always need navigational instructions to be changed
10:14:52 <fen> ski: what do you mean by that? what is this "context"?
10:16:07 <fen> which is why they appear in "odd" form, not requiring input to return a value, they can always be read using extract to get the value currently pointed at, the navigational input is only required to change the location
10:16:36 <fen> (ie they are not mealy machines)
10:17:04 <ski> fen : this tree might be part of another kind of structure (unknown to the tree), which in turn may be part of yet another structure, &c.
10:17:50 <fen> what?
10:17:56 <fen> its just a graph
10:18:16 <fen> that can have where it currently points to changed
10:18:32 <fen> that pointer cant be moved off the tree to point to some other thing!
10:19:13 <ski> if `f' is one container, and `g' another, then `d (f (g a)) / d a' is `(let b = f a in d (f b) / d b)  *  d (g a) / d a'
10:19:25 <fen> unless they are composable somehow, but this is unsettling 
10:19:55 <ski> iow, you can decompose the compound container `f . g' into two parts, outer and inner
10:20:17 <fen> right, as if mapping over the Zipper to add to the tail
10:20:33 <ski> e.g. you in a tiling window manager, you could have a collection of workspaces, and each workspace contains a collection of windows
10:21:08 <ski> there is a current (focused) workspace. and at least the current workspace has a current window (or do the rest of them also have one ?)
10:21:38 <fen> fmap (((+++)::Linear_r r f => f a -> f a) (xs :: ::Linear_r r f => f a)) :: ::Linear_r r f => Zipper f a -> Zipper f a
10:21:47 <ski> so, you can make something zipperish to represent the focus, both for the workspaces, and for the windows in each workspace
10:21:50 <fen> oops no :: ::
10:22:29 <ski> so, if we've navigated to a particular window, we ought to keep around not only the rest of the windows (in the current workspace), but also the remaining workspaces
10:22:51 <ski> so the "remaining workspaces" would be the "context" around the current workspace (the current "graph", if you will)
10:22:56 <fen> ski: are you talking about the duplicate? in which case yes, each of the pointers in a pointer point to some part of the inner pointer
10:23:26 <ski> .. but perhaps the collection of workspaces belongs to a particular user session, and there may be other user sessions ?
10:23:33 <fen> otherwise its not a pointer 
10:23:38 <fen> its got to have the same a
10:23:41 <ski> and so on. one could incorporate more and more of the context
10:23:46 <ski> (cf. composable continuations)
10:23:48 <fen> its just a container after all
10:24:03 <fen> it cant have one value being a pointer and the others not
10:24:17 <fen> like, if you need that it can be done 
10:24:39 * ski can't read that `Linear_r' thing
10:24:41 <fen> but its some crazy other thing. we are just talking about a constraint on f a
10:24:48 <fen> on f :: * -> *
10:25:19 * ski also isn't sure what exactly fen means by "pointer"
10:25:40 <ski> (so i can't parse "each of the pointers in a pointer point to some part of the inner pointer")
10:26:19 <fen> ski: with f = [] its fmap (++ (xs :: [a])) ([a],[a])
10:27:00 <fen> ski: its a duplicate of a pointer, which is a container having navigate :: i -> f a -> fa
10:27:26 <fen> so its Pointer i f => f (f a)
10:28:13 * ski haven't grokked the elaborate abstractions fen appears to have set up, mentioning `navigate' without explaining it doesn't help
10:28:43 <Solonarv> ski: I admire your persistence, I gave up long ago
10:28:50 <fen> even if it was Pointer i f => g (f a), each of the separate f would still be pointers. there is not just *one* pointer that could move over g to point to locations within different f
10:29:10 <fen> ski: like Store
10:29:44 <fen> Zipper has a pointer instance with i = Bool corresponding to forwards and backwards navigation
10:30:21 <ski> sorry, as i said, i don't know what you mean by "pointer", which includes not understanding what you want to capture by the `Pointer' class
10:30:47 <ski> (let alone remembering what its methods would be, and what the laws of them are)
10:31:12 <fen> Solonarv: ski has an idea about trying to point to parts of the contents of a pointer, but that means that the pointer would need a different type for the focused value, ie it would be a pointer,butthe others would not be
10:31:19 <ski> Solonarv : well, sometimes there appears to be method to the madness ;)
10:32:19 <monochrom> I am just concerned about noise that would better be in PM.
10:32:54 <ski> ok, perhaps we should take this to #haskell-overflow or something
10:33:08 <fen> { [1,2,3] , [4,5,6] , < 7 | 8 , 9 > , [10,11,12] }
10:33:11 <fiddlerwoaroof> Is a maintainer of Ranged-sets still around?
10:33:13 <ski> btw, wb monochrom
10:34:09 <fen> yeah, after long it becomes unlikely that anyone will read enough of the scrollback to have any idea what we are talking about
10:34:29 <ski> true that
10:36:05 <fen> basically just trying to commute a general pointer over f into a componded datastructure. zipper becomes double linked list, arbitrary pointer becomes a moore machine 
10:36:38 <fiddlerwoaroof> I'd like to add a semigroup instance to Data.Ranged.RangedSet so I can compile postgrest with the latest haskell
10:36:40 <fen> to achieve "pointers over cyclic graphs"
10:39:28 <cocreature> fiddlerwoaroof: they seem to be reasonably active on github https://github.com/PaulJohnson maybe try sending them an email?
10:39:38 * hackage fakedata 0.2.0 - Library for producing fake data  https://hackage.haskell.org/package/fakedata-0.2.0 (psibi)
10:41:39 <Kluysses> hello
10:41:57 <Kluysses> is this the right place for a beginner to ask questions?
10:42:08 <cocreature> yes
10:42:16 <Solonarv> Kluysses: yes! you can also try #haskell-beginners
10:43:09 <ski> (but beginner questions are also welcome here, mind)
10:43:22 <glguy> haskell-beginners isn't the beginner version of #haskell, it's just a different channel with fewer people
10:43:32 <Kluysses> Alright, thanks :)
10:44:04 <fen> probably there are also problems from traversable pointers via nested fifo containers not translating easily into traversable moore machines,...
10:46:34 <Kluysses> So I'm working through "Get Programming with Haskell" by Will Kurt and I'm having some troubles understanding the intention behind the solution for one of the examples, namely writing the "cycle" function from scratch
10:46:57 <Kluysses> https://pastebin.com/FB4yQ3P5 This is how I did it (top), vs. what the book did (bottom)
10:47:03 <NemesisD> i'm implementing the Random instance for an alphanumeric string that allows undescores. i'm trying to figure out a way to use the range feature in a way that isn't too "fair". meaning i could do (ignoring passing around gen) random = do len <- randomR (1, 1024); alphas <- randomRs ('a','z'); nums <- randomRs ('0','9'); take len (zip alphas nums)
10:47:07 * hackage haskoin-store 0.11.1 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.11.1 (xenog)
10:47:23 <NemesisD> but that wouldn't be ideal because it would always follow the pattern of an alpha char followed by a number char
10:48:12 <monochrom> Kluysses: I think that yours is better than the book's.
10:49:12 <monochrom> In fact I believe that the book's is born out of making an XY problem out of a simple problem.
10:50:09 <Kluysses> monochrom: Well that's reassuring, thank you :)
10:51:29 <lyxia> NemesisD: first write a generator of a single alphanum-or-underscore char, then replicateM it?
10:52:06 <NemesisD> lyxia: i see. so it'd basically coin toss between randomR on alphas and on nums?
10:52:34 <NemesisD> i feel like an Alternative would be nice to have here
10:53:37 <zachk> @src cycle
10:53:37 <lambdabot> cycle [] = undefined
10:53:37 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
10:55:17 <lyxia> NemesisD: that's right.
11:00:22 <zuserm> what's the syntax for creating instances of multiple [] levels? instance C [[]] where doesn't seem to work.
11:00:45 <ski> Kluysses : see alternative (cyclic) definition ^
11:01:05 <ski> zuserm : what's `C' ?
11:01:13 <zuserm> C is some class
11:01:23 <ski> accepting a type of which kind ?
11:01:36 <zuserm> * -> *
11:01:42 <ski> you can use `Compose [] []'
11:01:59 <ski> (there's no type lambdas in Haskell, unfortunately)
11:02:20 <ski>   newtype Compose f g a = MkCompose {runCompose :: f (g a)}  -- basically
11:02:35 <benzrf> ski: unfortunate depending on what you want from your language!
11:02:44 <ski> (or you could make a custom type, if you prefer)
11:02:48 <benzrf> system F has undecidable typechecking, right?
11:02:56 <ski> type inference
11:02:59 <benzrf> oof, right
11:03:03 <ski> rather not checking, i'd hope :)
11:03:12 <benzrf> well, those are equivalent if you don't have annotations on every subterm, rihgt
11:03:21 <benzrf> which isnt so practical
11:04:04 <lyxia> right, to be pedantic you would say whether you're talking about the annotated version or not.
11:04:06 <ski> hm, not sure what some reasonable low amount of signatures and ascriptions would be
11:04:28 <benzrf> er wait, i guess... is there sth between HM and F?
11:04:37 <lyxia> although it's usually implied by "inference" vs "checking"
11:04:43 <benzrf> like, type lambdas but not higher rank types?
11:04:47 <benzrf> is that possible
11:04:54 <benzrf> seems like it ought to be
11:08:59 <fen> benzrf: there is some work on type level lambdas, and even a ghc branch, but no stable support
11:09:13 <fen> the general workaround is to use typefamilies
11:09:22 <fen> which can act like type level functions
11:09:26 <benzrf> oh, im not suggesting as a language feature :)
11:09:33 <benzrf> im just wondering abt what kind of type systems exist
11:10:14 <fen> well, the type checker does not like lambdas. it requires the type family to solve stuff... 
11:10:36 <fen> also, there is some madness called defunctionalisation to work around partially applied type familes
11:10:53 <fen> therein lies the sought after typelevel functions
11:15:06 <fen> yeah, the higher levity kinds are also implemented by typefamilies. so probably it needs the name to solve the recursion
11:16:32 <fen> probably you would want your lambda to work at all levities
11:16:51 <fen> wonder if type familes solve for what levity they are being used at
11:17:52 <fen> cant remember if all type families need to be at top level
11:18:05 <fen> must be something up with scoping them
11:23:33 <johnw> if anyone wants to play around with a WebAssembly interpreter in Haskell, we've made our port of the OCaml reference interpreter open source (MIT license): https://github.com/dfinity/winter
11:23:53 <johnw> the floating-point support isn't done yet, but that should only be a few hours more work
11:33:40 <zuserm> is there a better way to do: https://gist.github.com/bacchanalia/e150ae080094140b7dcc2d6ac15a181f
11:36:54 <ski> zuserm : perhaps you can write something like `instance OnCutPath ps fs n b => OnCutPath [ps] [fs] n b where ...' ?
11:37:18 <ski> (or if not, maybe if you generalize `onCutPath')
11:39:48 <stevenxl> Hi. I'm trying to learn type-level programming and want to make sure I get my terminology correct. Maybe is a higher-kinded type, is that correct? It's kind is (* -> *) because Maybe the type constructor needs to be applied to a type of kind (*) to be "fully saturated".
11:40:10 <ski>   onCutPath ps fs = mconcat (zipWith onCutPath ps fs)  -- perhaps ?
11:40:14 <ski> zuserm ^
11:40:21 <lyxia> zuserm: it's the same code with three different Applicative and Foldable instances
11:40:26 <ski> (of course, scrap all the instances in that paste)
11:40:59 <lyxia> stevenxl: Maybe is a unary type constructor, but it's not higher kinded.
11:41:15 * ski . o O ( "higher-order" )
11:41:18 <stevenxl> lyxia: thank you; what is an example of a higher-kinded type?
11:41:20 <lyxia> stevenxl: MaybeT :: (* -> *) -> (* -> *)
11:41:25 <lyxia> Fix :: (* -> *) -> *
11:41:55 <ski> stevenxl : `Maybe' is a type function (in fact a type constructor, just like `Int'). `MaybeT' is a higher-order type (function)
11:42:06 <lyxia> higher-kinded types are those parameterized by type constructors.
11:42:16 <ski> or other type functions
11:42:18 <stevenxl> lyxia: I was just about to say. 
11:42:24 <ski> (`Either String' is not a type constructor)
11:42:42 <stevenxl> Maybe is parameterized by a type constant, as opposed to maybeT and its type constructor.
11:42:47 <stevenxl> MaybeT*
11:43:08 * ski would not use the term "higher-kinder", preferring the established "higher-order", fwiw
11:43:14 <stevenxl> ski: `Either String` is not a type constructor? But it's kind is (*-> *); wouldn't that be the definition of type constructor? 
11:43:41 <stevenxl> I like higher-order because it has an analog with higher-order functions, but I see everyone using HKT.
11:43:46 <lyxia> I'd say the terminology is a bit overloaded
11:43:51 <ski> stevenxl : there's two schools. in the one i subscribe to, only "atomic" things like `Either',`Int' are type constructors, not `Maybe Int' or `Either String'
11:44:08 <ski> stevenxl : compare with how `Just False' is not a data constructor, but `Just' (and `False') are data constructors
11:44:35 <stevenxl> lyxia: Understood; I think for now parameterized by type constructor = hkt works. As i learn more maybe that will change.
11:44:37 <ski> stevenxl : in the other school, a "type constructor" is any type having kind of the shape `... -> ...' (i'd call such a type a "type function")
11:44:37 <stevenxl> Thank you!
11:45:00 <stevenxl> ski: Ah yes, I think right now I'm in that second school, but who knows as I learn more.
11:45:01 <stevenxl> ;)
11:45:24 <ski> (from the other school derives the name "constructor classes" for classes like `Functor',`Monad'. nowadays, we tend to group those in with the rest of the type classes)
11:45:52 <ski> (and that term "constructor classes" isn't really used much nowadays, from what i can gather)
11:46:26 <geekosaur> I think it's been more or less consigned to Gofer
11:46:29 <ski> stevenxl : "but I see everyone using HKT" -- i'm not ;)
11:46:39 <ski> sounds plausible
11:46:55 <ski> (i think i've seen it in some old papers, probably from those days)
11:47:52 <geekosaur> I mean in later thinking. Haskell is sort of what happened when Gofer and Miranda met
11:48:24 <lyxia> I'm sure you can give a precise meaning to every word, and a word to every meaning, but you're not going to create consensus overnight.
11:48:25 <ski> that's a cute picture
11:48:38 <lyxia> So the pragmatic choice is to be flexible
11:48:57 <ski> one step at a time :)
11:50:26 <lyxia> although a newcomer might not realize that there is no consensus, so it's important to clarify that
11:52:07 <Kluysses> is there something like a rule of thumb when to use pattern matching and when it's okay to use ifs (style wise)?
11:53:48 <Solonarv> yes: use 'if' (or guards) when you already have a boolean, otherwise prefer pattern matchin
11:53:52 <geekosaur> Kluysses, they're somewhat different things. pattern matches operate on structure, if/then on values
11:54:07 <geekosaur> if a value happens to be expressible as a constructor then a pattern match is reasonable
11:54:16 <Solonarv> e.g. 'case x > 0 of True -> ...; False -> ...' is silly, just use if
11:54:24 <geekosaur> but if it's an expression then you have to use if./then or a guard
11:54:51 <Solonarv> OTOH don't do 'if null xs then ... else ... (head xs) ... (tail xs)...'
11:56:04 <Kluysses> I see, thanks guys
11:57:06 <geekosaur> yeh, if you're not only inspecting but using the structure, the pattern match makes more sense because it gives you both the test and the deconstructed parts; doing them separately sometimes makes sense from a laziness perspective, but even then using ~ in the pattern is often clearer
12:06:37 * hackage cmt 0.4.0.0 - Write consistent git commit messages  https://hackage.haskell.org/package/cmt-0.4.0.0 (smallhadroncollider)
12:07:45 <ski> well, `~' avoids the test
12:10:20 <shapr> johnw: is dhc still active?
12:13:01 <johnw> no
12:13:40 <shapr> oh, ok
12:13:54 <johnw> how did you know about dhc?
12:14:09 <shapr> I looked at https://github.com/dfinity
12:14:16 <johnw> ah
12:14:46 <shapr> compiling to wasm sounds like a fun thing, figured if you had some easy/simple failing tests I could fix some stuff
12:29:56 <ostara> hello :)
12:31:12 <shapr> hi ostara, guten tag!
12:35:15 <ostara> shapr: whats going on
12:36:38 <shapr> ostara: writing code! what's up with you?
12:37:05 <ostara> ditching class to irc
12:37:12 <ostara> what u writing
12:39:49 <shapr> ostara: datadog metrics at this exact moment, but was also reading about clash: https://clash-lang.org/
12:39:53 <shapr> ostara: are you learning Haskell?
12:40:04 <ostara> no lol .. too stupid
12:40:24 <shapr> ostara: eh, it's just time spent learning
12:40:35 <shapr> :t add
12:40:37 <lambdabot> error:
12:40:37 <lambdabot>     • Variable not in scope: add
12:40:37 <lambdabot>     • Perhaps you meant one of these:
12:40:52 <shapr> > map (\x -> x + 1) [1,2,3]
12:40:54 <lambdabot>  [2,3,4]
12:40:56 <ski> @type subtract
12:40:57 <lambdabot> Num a => a -> a -> a
12:41:33 <shapr> ostara: see, map gets two things, a piece of code, and a collection of things to run that code on
12:42:00 <ostara> ben shapr o
12:42:41 <shapr> so \x -> x + 1 means "give me a thing, I'll call it 'x' inside this code. Now I'll add 1 to that x, and give back the result"
12:43:18 <ostara> i c
12:43:22 * ski idly remembers explaining `map' on a handkerchief at a funeral, once
12:43:30 <shapr> the name of the thing has to match, but it can be other things like: \a -> a + 1
12:43:41 <shapr> > (\hi -> hi + 1) 1
12:43:43 <lambdabot>  2
12:44:28 <ostara> can you use non-decimal radices
12:44:49 <shapr> ostara: like what?
12:45:03 <shapr> > 0x8
12:45:05 <lambdabot>  8
12:45:09 <shapr> > 0xF
12:45:11 <lambdabot>  15
12:45:23 <Solonarv> octal and binary literals are also supported
12:45:24 <shapr> > (\x -> x + 0xF) 1
12:45:27 <lambdabot>  16
12:45:31 <Solonarv> > 0o10
12:45:33 <lambdabot>  8
12:45:38 <Solonarv> > 0b1010
12:45:40 <lambdabot>  error: Variable not in scope: b1010
12:45:45 <Solonarv> bah, not in lambdabot
12:45:49 <Solonarv> %ob101
12:45:54 <Solonarv> % 0b1010
12:45:55 <yahb> Solonarv: ; <interactive>:37:2: error: Variable not in scope: b1010
12:45:59 <ostara> want dozenals 
12:45:59 <shapr> aw
12:46:09 <Solonarv> % :set -XBinaryLiterals
12:46:09 <yahb> Solonarv: 
12:46:10 <shapr> ostara: how would you write the code to do that?
12:46:17 <Solonarv> % 0b1010
12:46:17 <yahb> Solonarv: 10
12:46:19 <ostara> shapr: dunno am stoopud
12:46:26 <shapr> ostara: what might be the first step?
12:46:47 * ostara sweats
12:46:59 * ski never understood why floating-point or fixed-point fractions never seem to support presenting in any other base than ten
12:47:16 <ostara> ikr ..
12:47:30 <Solonarv> you can use this function to parse integers from a string (in whatevever base you want): https://hackage.haskell.org/package/base-4.12.0.0/docs/Numeric.html#v:readInt
12:47:32 <shapr> ostara: if you want to learn Haskell, a friend of mine wrote an intro: https://www.seas.upenn.edu/~cis194/spring13/lectures/01-intro.html
12:47:50 <ski> Solonarv : i want that, for `Rational'
12:48:15 <ski> (or perhaps `Double')
12:48:30 <Solonarv> yeah, that would be nice. Guess there's not enough need for it though?
12:48:35 <shapr> ostara: how would you do one step of the fibonacci sequence in Haskell?
12:49:27 * shapr discovers a list of fibonacci numbers written in base 12
12:49:57 <ski> "fibonacci base" is interesting
12:50:04 <ski> and factoriadic
12:51:07 <Solonarv> % import Natural
12:51:07 <yahb> Solonarv: ; <no location info>: error:; Could not find module `Natural'; It is not a module in the current program, or in any known package.
12:51:13 <Solonarv> % import Numeric
12:51:13 <yahb> Solonarv: 
12:52:08 <ostara>  > map (\x -> x!) 3
12:52:30 <ski> drop the initial space
12:52:39 <ostara> > map (\x -> x!) 3
12:52:41 <lambdabot>  <hint>:1:14: error: parse error on input ‘)’
12:52:48 <ski> there you go :)
12:52:49 <ostara> ok
12:52:54 <ostara> bye
12:53:01 <ski> ok
12:53:08 <ostara> <3
12:53:58 <Solonarv> % let fibs = 0:1:zipWith(+)fibs(tail fibs); showDigit i | i < 10 = chr (ord '0' + i) | otherwise = chr (ord 'a' + i) in take 15 [showIntAtBase 12 showDigit x "" | x <- fibs ]
12:53:58 <yahb> Solonarv: ["0","1","1","2","3","5","8","11","19","2k","47","75","100","175","275"]
12:54:35 <Solonarv> Interesting.
12:56:27 <geekosaur> k?
12:56:48 <Solonarv> dunno
12:57:06 <dmj`> how do I parseTimeM into a NominalDiffTime or UTCTime given the string "99999999.99999"
12:57:07 <Solonarv> oh of course
12:57:11 <geekosaur> oh. you forgot to subtract 10
12:57:14 <Solonarv> % let fibs = 0:1:zipWith(+)fibs(tail fibs); showDigit i | i < 10 = chr (ord '0' + i) | otherwise = chr (ord 'a' + i + 10) in take 15 [showIntAtBase 12 showDigit x "" | x <- fibs ]
12:57:23 <Solonarv> yup
12:57:39 <Solonarv> % let fibs = 0:1:zipWith(+)fibs(tail fibs); showDigit i | i < 10 = chr (ord '0' + i) | otherwise = chr (ord 'a' + i - 10) in take 15 [showIntAtBase 12 showDigit x "" | x <- fibs ]
12:57:57 <Solonarv> uh oh, yahb's dead?
12:58:17 <ski> .. evidently
12:58:23 <geekosaur> yep
12:58:31 <ski> who killed it ?
12:58:38 * ski looks around suspiciously
13:01:25 <Solonarv> mniip: ping
13:01:36 <monochrom> Professor Plum, with a candlestick, in the kitchen.
13:13:56 <gentauro> dmj`: did you get an answer on your parsing of parseTime?
13:15:05 <dmj`> gentauro: nah, I was going to just do readMaybe into a Fixed E5, and then translate that to DiffTime -> NominalDiffTime -> UTCTime
13:15:20 <dmj`> gentauro: but I'm using the old time library, which doesn't have that level of precision (just integers)
13:15:26 <dmj`> gentauro: which is fine
13:15:35 <gentauro> but that is a `Julia time` right?
13:15:36 <dmj`> gentauro: but I'm now back to square one
13:15:49 <gentauro> or `time representation` iirc?
13:16:28 <dmj`> it's an epoch time
13:16:36 <dmj`> number of seconds since 1970
13:16:48 <gentauro> not Julia, but Julian -> https://en.wikipedia.org/wiki/Julian_day
13:16:54 <gentauro> ahh, my bad
13:17:30 <gentauro> I just recognized the "decimal" number as a Julian date -> https://en.wikipedia.org/wiki/Julian_day#Variants
13:17:33 <gentauro> nevermind then ;)
13:18:22 <dmj`> gentauro: I don't think I can parseTimeM into NominalDiffTime either, since this time value has decimal places, and my version of time doesn't support that
13:21:28 <gentauro> What about a UniversalTime -> https://hackage.haskell.org/package/time-1.9.2/docs/Data-Time-Clock.html#t:UniversalTime
13:21:31 <gentauro> ?
13:21:46 <gentauro> that would keep your decimals :-)
13:21:55 <monochrom> Actually what is your version?
13:55:07 <johnw> ski: fibonacci base makes me think of exponential time estimates
13:56:10 <shapr> fibonacci base has a lot of cool properties
14:08:47 <dmj`> monochrom: was that directed at me? regarding the version of time?
14:09:05 <dmj`> I can't use the lastest time since quickcheck-instances doesn't work with it
14:12:19 <dmj`> guess I could just copy them over...
14:13:43 <phadej> for the record, I only got PRs to bump time bound in quickcheck-instances
14:13:53 <phadej> not to add instances for new data types
14:14:00 <phadej> latter would be so much easier to accept
14:14:41 <phadej> there are no SystemTime instances for eg. :(
14:16:59 <reallymemorable> Does anyone see what I'm doing wrong in lines 43 - 45 that would cause it to throw errors?
14:17:02 <reallymemorable> https://paste.ofcode.org/UvZLvnCwgSdviqw4W88Whe
14:17:18 <reallymemorable> I'm getting variable not in scope errors
14:19:02 <dminuoso> reallymemorable: Can you please include the full error message you are getting?
14:19:18 <reallymemorable> `[ghcmod] Variable not in scope: source :: String
14:19:29 <reallymemorable> same for each line
14:19:33 <johnw> that's never passed to that function
14:19:46 <johnw> it's only an argument to tableFetch
14:19:52 <gentauro> reallymemorable: give sense `source` is not accesible from that part of the code ;)
14:20:33 <gentauro> reallymemorable: can we se your `where` clause?
14:20:34 <reallymemorable> but don't have to evaluate tableFetch with each of those
14:21:01 <reallymemorable> https://paste.ofcode.org/f8qkaqzUztH8RRsTqjfmhW
14:21:04 <gentauro> I'm guessin you forgot to `copy/paste` that one
14:21:05 <reallymemorable> thats my full code
14:21:21 <dminuoso> reallymemorable: Where should `source` come from?
14:22:05 <reallymemorable> I guess from line 15?
14:22:16 <gentauro> reallymemorable: non of these vars `startDate,endDate,frequency,source,timeseries,period` are available from mainLoop
14:22:31 <gentauro> you need to pass them as parameters or define them in a `where` below
14:22:40 <reallymemorable> ah
14:22:49 <dminuoso> reallymemorable: "Variable not in scope: source :: String" basically means "look, I dont know what `source` is - it's not a binding/variable that exists right here"
14:22:51 <reallymemorable> in line 71?
14:23:10 <gentauro> reallymemorable: 
14:23:15 <gentauro> reallymemorable: found the error
14:24:24 <gentauro> you can deconstruct `quandlRequester` as `(QuandlRequester _ _ startDate endDate frecuency)`
14:24:49 <gentauro> but you are still missing `source, timeseries and period`
14:25:36 <ddellacosta> before I give up entirely for the evening, anyone have any idea what basic thing I'm doing wrong with nix in this repo, where I'm trying to use ghc863 instead of the defaults? https://github.com/ddellacosta/servant-pt1
14:28:36 <gentauro> reallymemorable: could you tell where you expect the vars `source, timeseries, period` to come from?
14:29:40 <dminuoso> ddellacosta: Im not quite sure what you expect.
14:30:24 <ddellacosta> dminuoso: for it to build when I call `cabal build` inside of nix-shell...am I missing something really obvious? Could be, it's been a long week... 
14:30:39 <dminuoso> ddellacosta: It seems to me as if you have base-4.12.0.0 installed, but constrained base to base^>=4.11.1.0
14:30:54 <ddellacosta> oh, maybe I don't understand how to read that then
14:31:19 <dminuoso> ddellacosta: https://www.haskell.org/cabal/users-guide/developing-packages.html#build-information
14:31:32 <oo_miguel> Reading through the base64-bytestring encoder I encountered this construct on the two encodeWith "parameters" and do not understand what PS and ET are: http://hackage.haskell.org/package/base64-bytestring-1.0.0.2/docs/src/Data.ByteString.Base64.Internal.html#encodeWith 
14:33:14 <ddellacosta> dminuoso: oh I see, so I'm telling it implicitly `< 4.12.0.0` huh? Well, that would do it...
14:33:28 <gentauro> oo_miguel: `PS` and `ET` are just constructors that are beeing `deconstructed` when passed as parameters so you can access the fields
14:33:41 <ddellacosta> that's what I get for auto-generating it and not carefully noting that caret I guess
14:33:48 <ddellacosta> dminuoso: thanks!
14:33:59 <gentauro> if you click on them, it will bring you too -> `data EncodeTable = ET (ForeignPtr Word8) (ForeignPtr Word16)` for `ET`
14:35:08 <oo_miguel> gentauro: ah right, thanks. I tried klicking the other one only which I am interested in even more, but it does not work for the PS
14:35:24 <dminuoso> oo_miguel: PS is the name of the data constructor of ByteString
14:35:34 <dminuoso> oo_miguel: It's not part of the public interface.
14:36:17 <oo_miguel> oh, explains why I could not find it via hoogle either I guess
14:36:31 <dminuoso> oo_miguel: http://hackage.haskell.org/package/bytestring-0.10.8.2/docs/src/Data.ByteString.Internal.html#ByteString
14:37:07 <oo_miguel> dminuoso: allright thank you. 
14:37:17 <gentauro> dminuoso: isn't it like really `bad practice` to call an `Internal` instance?
14:37:29 <gentauro> I mean there is a reason for naming it `Internal` amirite?
14:37:47 <oo_miguel> gentauro: I began digging there, because I wanted to find out why thie encoder is so much faster then my toy encoder...
14:37:55 <oo_miguel> s/thie/this
14:38:24 <gentauro> oo_miguel: yeah, been there done that -> http://blog.stermon.com/articles/2018/08/13/haskell-safe-base64-only-depending-on-prelude.html
14:39:01 <gentauro> guessing from you `irc tag` you will probably get the following reference: "My base64 encoder/decoder is slower than the bad guys horses" ;)
14:39:05 <gentauro> (jaarrrllll)
14:39:37 <gentauro> (no puedo no puedo)
14:39:38 <dminuoso> gentauro: Strictly speaking its part of the public interface.
14:39:53 <oo_miguel> gentauro: heh, good to know others struggle with that too ;)
14:39:57 <dminuoso> gentauro: The name is irrelevant, what matters is that the cabal file declares Data.ByteString.Internal as exposed.
14:40:15 <gentauro> dminuoso: Ok, so it's `usable` then
14:40:27 <gentauro> then the naming is pretty bad indeed
14:40:30 <dminuoso> gentauro: Yes, for those who are fine with fiddling with ByteString internals.
14:40:47 <dminuoso> It enables for libraries like base64-bytestring to exist.
14:40:57 <gentauro> oo_miguel: yeah, if Haskell (safe) was fast, we will all be developing with it ;)
14:42:44 <oo_miguel> maybe my computer is too slow ;)
14:45:01 <gentauro> oo_miguel: nah, if you try to code `Haskell` the "beautiful way", you will soon realize that it's pretty slow. Then you dig a bit into `libs` and you see that they all make `nasty tricks` for the sake of `speed`
14:45:33 <dminuoso> That holds true for any language, really.
14:45:44 <gentauro> `Base64 encode Debian 9.5.0 net-install ISO file (291MB)` in +50 seconds is pretty bad, performance wise
14:45:55 <oo_miguel> gentauro: yeah, I admit beeing a little dissapointed seeing the performUnsafeIO in the very beginning..
14:45:58 <dminuoso> Writing fast code requires catering for hardware and making assumptions about data.
14:46:18 <gentauro> oo_miguel: all what they sold you about `Haskell` is a lie
14:46:25 <gentauro> sorry to burst your bubble xD
14:47:09 <oo_miguel> gentauro: For now I only found out about the mismatch between speed and beauty.. 
14:47:27 <gentauro> oo_miguel: yeah, can relate
14:47:34 <oo_miguel> which I am fine to live with. most of functionality does not really depend on performance
14:47:51 <oo_miguel> and for the low parts I can fall back to ugly code or even C
14:48:02 <gentauro> but now and then, you stumble upon some really well written `libs` and you get amazed
14:48:37 <sclv> `Internal` isn't necessarily about safety or unsafety
14:48:43 <dminuoso> oo_miguel: You can without much work FFI into C code if you have special requirements.
14:48:43 <sclv> it often is a convention for "not api stable"
14:48:56 <gentauro> oo_miguel: you should be able to code some `fast` Haskell code without falling into the `nasty and disgusting code` -> http://blog.stermon.com/articles/2019/02/09/haskell-bitonic-sorter-concurrent.html
14:49:07 <gentauro> (jep, it's `safe` and `fast`) ;)
14:50:23 <gentauro> but it will take you sometime to realize how to `dance with haskell` and mostly `with the communities packages` ;)
14:51:01 <gentauro> and what you can compromize on (as you say, if you want fast code and you can't get the warranties in Haskell, well then just code in C)
14:51:42 <oo_miguel> gentauro: nice, thanks for sharing!
14:52:50 <gentauro> oo_miguel: you can still get some `reasenable` safe code in `C` if you actually know about their `const` atrribute -> http://dpaste.com/34875FY
14:53:26 <gentauro> (Note: don't use the -O3 compiler flag, as it will optimize this `restriction` away)
14:53:49 <oo_miguel> oh, did not know that
14:54:22 <gentauro> many people working with `C` on low-leverl and on a daily-basis don't know that ;)
14:54:48 <gentauro> but don't expect it to work like in `Haskell` thougt ;)
14:54:59 <gentauro> s/thougt/though
14:58:11 <oo_miguel> still wonder if there is _any_ benefit in writing something as this encodeWith (posted before) in Haskell and NOT falling back to C. If I give up beauty, brevity and safety anyway. 
14:58:52 <oo_miguel> (not sure how much safety is given up there as opposed to writing it in C)
14:58:59 <gentauro> oo_miguel: my answer would be "No"
14:59:35 <gentauro> I would still use the `C` version in that case
14:59:37 <oo_miguel> yeah, I just treat as an interersting proof of concept, that it CAN be done in haskell
15:00:12 <Cale> gentauro: re: the nasty tricks, it's really a good thing that this is possible -- you get to take advantage of libraries which do all sorts of low-level trickery on your behalf, and yet expose an interface which is as-if none of that is going on.
15:01:05 <gentauro> Cale: which in my case, it's not good enough (I understand it's for the most)
15:01:07 <Cale> You don't need to go and edit the compiler in order to make the right low-level tricks happen, and you also don't necessarily have to give up on presenting a tidy interface.
15:01:22 <gentauro> if you do something under the hood, please mark it in the signature and I will handle with it locally
15:01:33 <oo_miguel> Cale: this does not imply that the library itself would be easier and shorter to write and easier to maintain with some inner parts not written in hask
15:02:00 <Cale> oo_miguel: Sure, if you want to call some C code, that's fine.
15:02:25 <gentauro> Cale: in my case, search for `trust = unsafePerformIO . sort` at http://blog.stermon.com/articles/2019/02/09/haskell-bitonic-sorter-concurrent.html
15:02:46 <gentauro> let me decide if I trust your method or not, don't take that decision for me
15:03:41 <Cale> eh
15:03:51 <gentauro> Cale: macarena?
15:03:53 <Cale> There are libraries like ByteString where that would make the whole thing pointless
15:04:12 <gentauro> my `pointless` xD
15:04:29 <gentauro> ba dum tss!
15:04:57 <Cale> (ByteString is doing all sorts of direct manipulation of chunks of memory via unsafePerformIO)
15:05:53 <gentauro> yes, and it can be marked as `Trustworthy`
15:05:57 <Cale> Of course, a lot of care needed to be taken to ensure that everything it was doing was actually ok
15:06:11 <oo_miguel> I just think this moves the problem 
15:06:12 <gentauro> but for example `text` does as well, but can't be marked as `Trustworthy`
15:06:14 <oo_miguel> ?
15:06:28 <oo_miguel> in the moment I call C it should be marked UN-trhustworthy, right?
15:06:38 <oo_miguel> independently if there is any unsafePerformIO involved
15:06:39 <Cale> huh?
15:06:41 <oo_miguel> not?
15:06:50 <Cale> Data.Text is marked Trustworthy
15:07:00 <Cale> Unless you have some personal issue with it :)
15:07:33 <oo_miguel> Cale: oh
15:08:08 <oo_miguel> I did not know this is some real "tag". thought you just used it as a word in a conversation :P
15:08:20 <gentauro> Cale: Well, it's not me having the issue, it's rather `stack` ;)
15:08:40 <Cale> weird
15:08:45 <gentauro> tell me about it
15:08:48 <Cale> I don't use stack, so I'm not sure
15:08:54 <gentauro> all libs that use `text`, I can't use :(
15:09:07 <oo_miguel> what does 'Trusthworthy' imply?
15:09:18 <Cale> Not a heck of a lot, honestly
15:10:03 <Cale> "Trustworthy — Means that while this module may invoke unsafe functions internally, the module’s author claims that it exports an API that can’t be used in an unsafe way. This doesn’t enable the safe language. It does however restrict the resolution of overlapping instances to only allow safe overlapping instances. The trust guarantee is provided by the module author, not GHC. An import statement with the safe keyword 
15:10:03 <Cale> results in a compilation error if the imported module is not trusted. An import statement without the keyword behaves as usual and can import any module whether trusted or not."
15:10:12 <oo_miguel> heh
15:11:19 <oo_miguel> every function that internally calls C needs to live in the IO() monad OR call unseafePerformIO, right?
15:11:33 <gentauro> Cale: adding `text` as `-trust=text` will give me a `build` error -> http://dpaste.com/2H9GFK6
15:11:48 <Cale> Yeah, or you can foreign import at a non-IO type, which just applies the unsafePerformIO for you
15:12:31 <oo_miguel> so if any 'Thrustworthy' package depends on C, this can be just reduced to "trusting the author" ;)
15:12:41 <gentauro> oo_miguel: exactly
15:12:42 <oo_miguel> Cale: which is quite weak as you already pointed out 
15:12:58 <oo_miguel> hmmm
15:13:13 <Cale> hm, the entire text *package* probably isn't Trustworthy, but Data.Text is marked as such
15:13:17 <oo_miguel> on the other hand thousands of libraries work fine.. anyway. I will not think about this anymore :P
15:13:41 <geekosaur> there are internals modules that aren't Trustworthy, iirc
15:14:10 <gentauro> oo_miguel: you are doing like most people here. Realize that there is a big `trust` issue and just look away as everybody else xD
15:14:32 <Cale> Actually, is there even any Safe-Haskell stuff going on at the package level?
15:14:37 <Cale> I thought it was all module-level
15:14:41 <oo_miguel> gentauro: I admit. And I apply this strategy in other places as well ;)
15:15:05 <Cale> at least the Trustworthy flag
15:15:06 <gentauro> oo_miguel: yeah, otherwise you would go all `loco` (sadly, I chose Dalís path)
15:15:16 <Cale> There's -trust <pkg>
15:15:55 <gentauro> Cale: I just posted that ... http://dpaste.com/2H9GFK6
15:16:08 <gentauro> 00:11 < gentauro> Cale: adding `text` as `-trust=text` will give me a `build` error -> http://dpaste.com/2H9GFK6
15:16:10 <oo_miguel> gentauro: I do not expect my complete computer down to the hardware give me the same guarantees ghc gives me
15:16:19 <oo_miguel> including drivers and the os
15:16:36 <Cale> ah, that's because of -fpackage-trust apparently
15:17:04 <Cale> -fpackage-trust
15:17:04 <Cale>     When enabled, turn on an extra check for a trustworthy module M, requiring the package that M resides in be considered trusted, for M to be considered trusted.
15:17:30 <Cale> It makes the checking more coarse for some reason. I'm not sure what advantage that would have
15:17:34 <gentauro> nah, but I like how Haskell is meant to work. We always take the sarting point in a `nasty` world (all apps main :: IO ()) and from there you built your small and `pure` worlds you can reason about
15:17:57 <geekosaur> extra paranoia. but if you're that paranoid, you probably have bigger problems than the Text package to worry about
15:18:16 <geekosaur> like FFI-related bugs in ghc (there were several in 8.4 and early 8.6)
15:18:33 <oo_miguel> gentauro: you cant reason about them, given they run on some real hardware and real elecric wires anyway
15:18:42 <Solonarv> Cale: I assume the advantage is being able to be less verbose when you want to trust an entire package anyway
15:18:58 <oo_miguel> you can just reason about how you put all this untrustworthy parts together in haskell
15:19:03 <oo_miguel> but not about the parts itself
15:19:07 <gentauro> oo_miguel: that's true, to some sense
15:19:10 <Cale> Solonarv: It only seems to add an additional requirement
15:19:10 <oo_miguel> this is how I explain it to me
15:19:20 <Solonarv> oh, nevermind then
15:19:29 <oo_miguel> after my todays little dissapointments ;)
15:19:36 * Solonarv doesn't know much about SafeHaskell
15:19:38 <geekosaur> other way around, I'd think: it doesn't extend trust to an entire package, it requires you to say you trust every module in the package and not just the ones you name
15:19:57 <geekosaur> er, use directlt
15:20:15 <Cale> So yeah, just turn off -fpackage-trust and it should solve the problem for you
15:20:27 <Cale> (that's a silly flag, I don't see how it really helps anything)
15:21:06 <Cale> I guess maybe if you're worried about TH that will be encountered while compiling other modules in the package?
15:21:29 <gentauro> oo_miguel: that's true. I went to a talk from a `research director` from INRIA. His summary slide -> https://imgur.com/a/ww0Bd4n
15:23:02 <gentauro> they reason about the code, but they actually use `Coq` to go through the `binary` file
15:23:15 <gentauro> and do the proof.
15:25:02 <gentauro> Cale: I use that flag cos of "To control the use of trustworthy modules it is recommended to use the -fpackage-trust flag. This flag adds an extra requirement to the trust check for trustworthy modules, such that for trustworthy modules to be considered trusted, and allowed to be used in -XSafe compiled code, the client C compiling the code must tell GHC that they trust the package the trustworthy 
15:25:08 <gentauro> module resides in. This is essentially a way of for C to say, while this package contains trustworthy modules that can be used by untrusted modules compiled with -XSafe , I trust the author(s) of this package and trust the modules only expose a safe API. The trust of a package can be changed at any time, so if a vulnerability found in a package, C can declare that package untrusted so that any future 
15:25:14 <gentauro> compilation against that package would fail."
15:25:15 <gentauro> https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/safe-haskell.html
15:26:04 <oo_miguel> gentauro: interesting, never played with any proof assitants. Will definietly look at these someday
15:26:56 <gentauro> oo_miguel: I was in Marrakech for the MirageOS hang-out. I saw PhDs from INRIA writing `coq-proof` and I was like: "Nope, not for me" xD
15:27:43 <gentauro> but I really appreciate they do it ;)
15:28:30 <gentauro> I understand that all lines of code that goes to `Airbus` planes are `proven` with `Coq`. That's make me a bit more `safe` when I have to catch a plane :-)
15:33:17 <MarcelineVQ> agda might be more approachable if you have interest in proofing and find that coq is obtuse or that using tactics for proofs is somewhat arcane. there's many other assistants as well
15:34:37 <MarcelineVQ> sometimes it seems like you can't wave a stick in here without leaving a welt on somebody who uses a proof assistant
15:40:25 <gentauro> MarcelineVQ: does Agda work on `binary` level? Or is it just reasoning (proving) the source code?
15:42:19 <gentauro> my knowledge to Agda is very limited (just seen a few talks about it and it hasn't really catched on to me)
15:43:20 <MarcelineVQ> I'm not sure what that's asking ehe, are you asking about proofs of compiled code?
15:44:19 <MarcelineVQ> If you model the execution of a machine you can prove things about it yes, on that route one could probably leverage something like compcert to make things easier
15:46:15 <MarcelineVQ> Or are you just asking about whether you can compile your agda programs?
15:46:32 <gentauro> MarcelineVQ: I have no experience neither with Coq nor Agda, I just saw a recent INRIA talk (live, not on Youtube) and his slides showed (at the end) that in order to `prove` something, it all had to be done on the `binary`. Everything else was useless
15:50:08 <MarcelineVQ> Sure, if you prove something and then some compiler does an optomization on it it might no longer reflect what you proved. But if you can prove each step of the transformation of the code you have proved the binary correct, which I think was compcert's goal
15:52:49 <gentauro> MarcelineVQ: that gives sense. Thx for the explanation
15:55:42 <geekosaur> well, and no matter how carefully you craft your proofs, there may still be bugs; proof checkers can't replace tests
15:56:31 <geekosaur> ("logic is an organized way of going wrong with confidence". for starters, what if you proved something which turns out to not be what's actually needed in a particular situation?)
15:57:16 <Solonarv> to be fair, that can happen with tests too - but tests are much easier to write than proofs, so you can cover more potential bugs with them
15:59:45 <MarcelineVQ> That's a good point, tests can check axioms, which aren't checkable otherwise since such things are assumed to be true
16:00:12 <LunarJetman> axioms shouldn't need checking if they are genuine axioms.
16:00:48 <shapr> AXE THE AXIOM
16:00:56 <geekosaur> and relevant axioms
16:01:38 --- mode: ChanServ set +o shapr
16:01:43 --- kick: shapr was kicked by shapr (off-topic Kicked by shapr)
16:01:53 <geekosaur> (the problem with formal systems is that, somewhere along the line, they exist because of external actions that can't be modeled within them. == Gödel)
16:02:41 <dyl> _inhales_ let me tell you about, like, the greatest formal system ever invented maaaan _coughs violently_
16:02:47 <dyl> It’s called real life, my dude.
16:02:57 <shapr> informally
16:03:36 <s00pcan> wow, only kicked for off-topic? 
16:03:36 <shapr> Is there a really good list of probabilistic data structures somewhere? or an especially good book on the subject?
16:03:44 <shapr> s00pcan: I'll do better! I promise!
16:03:53 <s00pcan> shapr: I'm saying this as someone who once had to appeal a ban
16:04:01 <s00pcan> for talking about pencils here
16:04:07 <MarcelineVQ> geekosaur: the godel issue is under some contention lately as well
16:04:25 <shapr> s00pcan: I'll try to stay on topic!
16:04:25 <Solonarv> s00pcan: you'll note that shapr kicked themselves :>
16:04:34 <shapr> Solonarv: shh!
16:04:44 <s00pcan> eh I just switched to this and hadn't read further up
16:04:48 <MarcelineVQ> about whether godel and hilbert were quite talking about the same thing
16:05:00 <s00pcan> I'm the type that just randomly picks a channel and starts talking
16:05:24 <geekosaur> saw that. still leaves that at some point you're faced with the equivalent of euclid's fifth posulate
16:05:43 <s00pcan> (if I could hide the topic line in irssi without hacking on the source, I would. And I did try that)
16:06:21 <s00pcan> …back to work
16:06:45 <glguy> s00pcan: That's what happened 4 years ago, right? Jumped in channel and started offtopic. Without a history of being on-topic the patience can be less
16:07:18 <gentauro> shapr: `01:03 < shapr> Is there a really good list of probabilistic data structures somewhere?` Probabilisty programming?
16:07:23 <s00pcan> glguy: what, did you check logs?
16:08:12 <s00pcan> mine only go back to 2015; lost them at some point
16:13:20 <s00pcan> the reason I'm in here is because I use xmonad but can barely write haskell. Yet I haven't learned it since 2012. Not sure when it's going to happen but I wish it would
16:16:50 <s00pcan> geekosaur: time to learn how to umlaut with my compose key
16:17:31 <LunarJetman> s00pcan: I am implementing haskell even though I don't know any haskell.
16:17:34 <geekosaur> compose with double quote
16:18:00 <s00pcan> ¨ well I guess, but over an o? Let's guess: ö
16:19:23 * ski thought you just pressed the `ö' key on the keyboard ..
16:19:57 <MarcelineVQ> φ on that I say
16:21:43 <s00pcan> not sure why my ~/.Xcompose isn't getting loaded; I added ⸮ but it doesn't work anymore
16:23:12 <s00pcan> wait, is it ~/.XCompose now?
16:23:52 <Solonarv> I think so?
16:23:58 <benzrf> thats whati have
16:24:14 <s00pcan> not sure if it changed or I just renamed it accidentally at some point
16:24:38 <s00pcan> I mean, ~/.Xresources doesn't have R
16:28:33 <geekosaur> X11 is not known for consistency >.>
16:29:17 <Solonarv> it's ~/.XCompose for me, but then again I'm on windows so who really knows :p
16:29:36 <wroathe> So I'm pretty amazed by the bones of optparse-applicative: https://www.paolocapriotti.com/blog/2012/04/27/applicative-option-parser/
16:31:02 <wroathe> For the functor and applicative definition of Parser, do you guys think he just intuited that implementation, or is there a standard way people "think" about code that makes use of currying and uncurrying?
16:32:36 <c_wraith> wroathe, I think it's mostly the result of practice.
16:33:01 <Solonarv> it also helps that for any given type there is at most one lawful fmap implementation
16:33:33 <wroathe> c_wraith: I was afraid you'd say that :P. It's amazing what people come up with.
16:34:32 <Solonarv> Additionally, 'Parser' as given in that post is just 'Ap Option', where Ap is from Control.Applicative.Free in the free package
16:37:35 <wroathe> Solonarv: How do you go about finding that lawful fmap definition?
16:38:40 <Solonarv> it's fairly mechanical
16:39:38 <c_wraith> Solonarv, I think there are actually multiple possibilities when you start abstracting over higher-kinded types. you can write instances that are lawful but different with different constraints on those types.
16:41:24 <c_wraith> like, you could have an instance (Contravariant f, Contravariant g) => Functor (Compose f g), instead of what's in the library.
16:41:33 <Solonarv> oh, true
16:41:34 <wroathe> So if the value the functor contains is the result of a function, rather than just being a standard field, you'd probably need to use composition as he's doing here
16:41:40 <Solonarv> yes
16:41:56 <wroathe> Essentially delaying the "mapping" step of fmap until the function is actually invoked
16:42:03 <Solonarv> fields which don't mention the type parameter are simply passed along
16:42:04 <oo_miguel> just a quick question: what is the offset inside the internal represantion of the ByteString used for?
16:42:17 <c_wraith> oo_miguel, O(1) slices
16:42:39 <Solonarv> (e.g. imagine data AndAnInt a = AndAnInt Int a; fmap would pass the Int field along unchanged)
16:44:19 <Solonarv> c_wraith: but those separate implementations necessarily coincide whenever they're both defined, right?
16:45:01 <wroathe> and apply the function to map a to b, but if that field is a function that returns an a, i.e. Int -> a, you'd just need to compose them to get Int -> b
16:45:08 * hackage katip 0.8.1.0 - A structured logging framework.  https://hackage.haskell.org/package/katip-0.8.1.0 (MichaelXavier)
16:45:24 <Solonarv> and if the field is itself a functor, you apply fmap recursively
16:46:10 <c_wraith> Solonarv, in that particular case, both are defined iff the type variable a is phantom in f and g... which would imply they're the same, yes.
16:46:16 <oo_miguel> c_wraith: thanks
16:46:33 <Solonarv> c_wraith: yeah, I was wondering about the general case
16:48:09 <c_wraith> Solonarv, I think a more general phrasing would be "Functor implementations are unique after a choice of instances they depend on." but I wouldn't say anything more specific about it.
16:48:31 * Solonarv nods
16:49:42 <Solonarv> unique up to equivalence, of course
16:50:11 <c_wraith> sure. all the standard provisos apply.
17:06:12 <blauson> a
17:55:41 <cryptomonad> Anyone familiar with python? I'm looking for the conceptual equivallent of `lens` in python. It looks like Generator is a good candidate but I don't understand neither concept too well
17:56:59 <Solonarv> cryptomonad: generators aren't really related to lenses at all
17:57:41 <Solonarv> or at least not in any straightforward fashion
17:58:07 <Solonarv> I'm not aware of any python equivalent of 'lens'; if it exists, I would guess it's quite niche and not used much
17:58:20 <cryptomonad> errr sorry; I meant `pipes`
17:58:30 <cryptomonad> duh.
17:59:11 <Solonarv> oh lol
17:59:24 <Solonarv> yes, generators are pretty similar to that
18:00:11 <cryptomonad> It looks like with the send and "yield from" additions it is very similar in functionality and composability
18:04:50 <texasmynsted> anybody happen to know if either haskelly or haskero work with cabal based projects (vs. stack based)
18:06:39 <Solonarv> I know haskero doesn't (it uses intero as its backend, which is stack-only), I haven't heard of haskelly
18:06:52 <Solonarv> Am I correct in assuming you're looking for a VSCode plugin?
18:12:04 <Solonarv> texasmynsted: ^
18:12:22 <inkbottle> intero trying to kill my computer, again (https://github.com/chrisdone/intero/issues/84); After emacs has been closed; I had to C-Alt-f1 because x-session was frozen by not enough cpu remaining.
18:17:03 <texasmynsted> yes
18:18:30 <Solonarv> texasmynsted: try using 'Simple GHC (Haskell) Integration' for something more lightweight, or Haskell Language Server for a more fully-featured integration
18:18:50 <texasmynsted> okay
18:18:51 <Solonarv> both should work on any type of project
18:19:34 <Solonarv> ah, it looks like Haskelly also uses intero as the back end
18:19:41 <Solonarv> so it won't work on non-stack projects
18:19:43 <texasmynsted> hakelly used itero also 
18:20:36 <Solonarv> yes
18:45:12 <HaskellHelp> Hello
18:46:09 <glguy> HEllo
18:47:41 <Welkin> > map char [104,101,108,108,111]
18:47:43 <lambdabot>  error:
18:47:43 <lambdabot>      • No instance for (Num Char) arising from the literal ‘104’
18:47:43 <lambdabot>      • In the expression: 104
18:47:45 <Welkin> > map chr [104,101,108,108,111]
18:47:47 <lambdabot>  "hello"
18:47:49 <Welkin> :D
18:48:28 <c_wraith> if you throw a text in, lambdabot won't print the quotes...
18:48:43 <c_wraith> > text "Hello!"
18:48:45 <lambdabot>  Hello!
19:20:30 <eacameron> How can I construct a Lens (traversal?) that projects two values out of a many-itemed container?
19:21:24 <eacameron> something like thing `^.. items . traverse . _ item_name item_id`
19:22:30 <eacameron> Essentially I want to turn two Getters into a single Getter that returns a tuple (or similar)
19:24:19 <Solonarv> that's unsound to do in general (what if the two lenses' targets overlap?), but there is a function you can us
19:24:27 <Solonarv> https://hackage.haskell.org/package/lens-4.17/docs/Control-Lens-Unsound.html#v:lensProduct
19:24:34 <glguy> You can build that with ReifiedGetter
19:25:27 <glguy> % [(1,2,3),(4,5,6)] ^.. folded . runGetter (liftA2 (,) (Getter _1) (Getter _3))
19:25:27 <yahb> glguy: [(1,3),(4,6)]
19:25:51 <glguy> In the case of Getters lensProduct can't be unsound
19:25:57 <Solonarv> oh yeah, if you're just using the result as a getter it's always sound
19:26:15 <eacameron> Yes I'm only using it as getter
19:27:43 <eacameron> glguy: Interesting...
19:28:10 <eacameron> I've used ReifiedGetter before but why is it necessary to do this product-projection?
19:28:45 <glguy> Because it allows you to use ReifiedGetter _'s Applicative instance
19:28:52 <eacameron> Ahh
19:30:56 <eacameron> Yes that works wonderfully thank you.
19:36:34 <siraben> Anyone have uses for type-level computation other than solving the eight queens problem, insertion sort and factorial?
19:37:21 <siraben> https://wiki.haskell.org/wikiupload/d/dd/TMR-Issue8.pdf , page 21
19:38:12 <Solonarv> those aren't really "uses", they're examples
19:38:30 <Solonarv> practical uses include: lists/vectors whose length is known at the type level
19:38:51 <Solonarv> generic access to record fields using something like generic-lens
19:39:19 <koz_> Seconding what Solonarv said.
19:39:41 <koz_> Fixed-length vectors are a very good use of this kind of stuff.
19:39:50 <Welkin> I've seen someone solve the eight queens problem before entirely in the python garbage collector
19:39:59 <siraben> Ah, I've heard lens mentioned before, what's the motivation behind them, just getting and setting parts of data structures?
19:40:22 <Solonarv> very roughly yes
19:40:34 <siraben> Although I'm still confused on how to derive lens
19:40:53 <siraben> i.e. categorical construction
19:40:58 <koz_> siraben: Edward had a good talk on this topic.
19:41:01 <koz_> (probably one of many)
19:41:11 <koz_> You can also check out phadej's Glassery post.
19:41:15 <siraben> https://www.youtube.com/watch?v=cefnmjtAolY I presume?
19:41:33 <koz_> I _think_ so? It's been a while.
19:41:43 <koz_> But yeah, phadej's Glassery would probably be a good read too.
19:41:56 <siraben> koz_:  https://gist.github.com/phadej/c32503efd3274e83196d549eaae28a1a ?
19:42:30 <koz_> Yup. Although it used to live somewhere else which has now vanished.
19:42:33 <siraben> In which cases you've encountered where lens are a good abstraction?
19:42:41 <koz_> Personally? Never.
19:42:47 <koz_> Others may have different opinions here.
19:43:47 <Solonarv> I have yet to do anything where it seemed like I *needed* lens, but I also haven't really done much "real world" haskell
19:44:00 <koz_> I'm pretty much in Solonarv's boat/
19:44:32 <siraben> I see.
19:45:00 <Solonarv> they tend to be useful when you're working with deeply-nested records, for example
19:45:21 <siraben> I learned about Contravariant functors recently, where is  having (a -> b) -> f b -> f a a useful property?
19:45:24 <koz_> I think jle` mentioned that lenses make working with the State monad much more tolerable too.
19:45:26 <siraben> Solonarv:  I'll read up on lenses
19:45:40 <glguy> I used them pretty extensively in my IRC client as there's lots of records of maps of records of lists of ....
19:45:48 <koz_> siraben: A good example of a non-trivially useful contravariant functor is 'Comparison'.
19:45:52 <glguy> But in other projects I get by not depending on the library at all
19:46:05 <koz_> 'Equality' too I guess.
19:46:11 <siraben> Can't one use coproducts to compose state monads?
19:46:28 <koz_> siraben: You can ask jle` to clarify his point when he rematerializes.
19:46:49 <koz_> I remember he mentioned it in one of his posts, but I can't recall which one, and delving for it right now would take too long.
19:47:06 <siraben> koz_:  I see.
19:47:11 <Solonarv> another good example is a 'PrettyPrinter'
19:47:36 <ski> (`Equivalence' ?)
19:47:42 <koz_> ski: Yeah that one.
19:47:53 <siraben> Knowing Standard ML has made Haskell much easier, typeclasses are amazing! 
19:47:54 <koz_> I've clearly spent too long away from Haskell. :P
19:48:04 <siraben> SML lacks typeclasses but has this awkward module system
19:48:21 * ski misses `local'-`in'-`end' from SML
19:48:23 <Solonarv> clearly if you can prettyprint an 'a' (i.e. you have a 'PrettyPrinter a' value) and you can turn a 'b' into an 'a' (i.e. you have a function 'b -> a') you can prettyprint a 'b' !
19:48:34 <ski> (and obviously module functors, but that goes without saying)
19:48:59 <koz_> Op is another interesting (and potentially quite useful) contravariant functor.
19:49:17 <ski> what's that ?
19:49:19 <koz_> (Well, 'Op a' to be precise)
19:49:36 <ski> oh, reverse function type, yes ?
19:49:39 <Solonarv> siraben: more generally, if 'Foo' is a contravariant functor that means roughly that a 'Foo a' takes 'a' as *input* in some sense
19:49:43 <Solonarv> ski: yes
19:49:55 <Solonarv> newtype Op a b = Op (b -> a)
19:50:01 <siraben> I see.
19:50:02 <koz_> ski: http://hackage.haskell.org/package/contravariant-1.5/docs/Data-Functor-Contravariant.html#t:Op
19:50:06 <ski> SML/NJ has a type of (non-composable) continuations. they are contravariant
19:50:08 <koz_> Although Solonarv beat me to the punch.
19:50:47 <ski> one can also define read-only vs. write-only views on mutable boxes, or channels. they can be made covariant respectively contravariant
19:51:22 <ski> koz_ : ok, as i guessed, then
19:51:26 <Solonarv> you can even pack them together and get a profunctor :p
19:51:36 <ski> `Flip (->)'
19:51:57 * ski would like a definition of "profunctor"
19:52:07 <siraben> Is PrettyPrinter related to Wadler's paper "A prettier printer"?
19:52:23 <koz_> ski: http://hackage.haskell.org/package/profunctors-5.3/docs/Data-Profunctor.html#t:Profunctor
19:52:39 <ski> koz_ : i mean, a mathematical definition
19:52:42 <koz_> Ah.
19:52:50 <ski> is it required that the codomain always be `Set', e.g. ?
19:52:53 <koz_> In that case, maybe light the Kmett Signal?
19:52:59 <Solonarv> siraben: only very loosely; as far as this example is concerned you can think of 'PrettyPrinter a' as simply a function 'a -> String'
19:53:28 <siraben> Right.
19:53:58 <Solonarv> ski: generally, a profunctor is simply a bifunctor C^op x D -> Set
19:54:06 * ski has pondered the difference between covariant and contravariant powerset function a little, lately (with the help of Lawvere's and Rosebrugh's nice book "Sets for Mathematics")
19:54:18 <Solonarv> you can also talk about "enriched" profunctors where the target category is something other than Set, e.g. Hask
19:54:25 <ski> Solonarv : any extra laws, properties ?
19:54:31 <ski> Solonarv : yeah, i was suspecting so
19:54:47 <Solonarv> just the usual well-behavedness stuff for functors IIRC
19:55:07 <ski> Solonarv : e.g. if you use `Ab' as codomain, would the domain have to be an abelian category ?
19:55:21 <Solonarv> I have no idea!
19:55:27 <koz_> ski: I was thinking of reading that book. Is it good?
19:55:28 <Solonarv> they're useful because they generalize the Hom-functor
19:55:41 <Solonarv> whch in the context of Haskell means: they're useful because they generalize (->)
19:55:57 <ski> koz_ : you should probably start with "Conceptual mathematics: a first introduction to categories", by Lawvere and Schanuel
19:56:17 <ski> koz_ : "Sets for Mathematics" is more fast-paced
19:56:29 <koz_> ski: Noted, thanks.
19:56:35 <siraben> ski:  how does that compare with "Category Theory for Programmers"?
19:57:34 <ski> siraben : haven't read that, but what i've seen of Bartosz Milewski's talks, i mostly like
19:58:03 <siraben>  Bartosz Milewski's talk on profunctor optics at a conference was over my head
19:58:12 <siraben> but he goes into much more detail in his lectures, which I like as well.
19:58:54 <ski> e.g., i liked his analogy of limits as optimal answers to search queries
19:58:55 <siraben> ski: What does conceptual mathematics build up to?
19:59:53 <ski> (he may have gotten that from somewhere else, since i've ran across more or less the same idea in a philosophical paper arguing that one can better understand (or rethink) Plato's theory of Forms in terms of CT rather than set theory)
20:00:36 <ski> siraben : toposes, more or less. an understanding of set theory (and some other simple math), from a categorical perspective
20:00:44 <siraben> Btw I noticed that type-level programming looks a lot like Prolog
20:00:45 <siraben> I wonder if there's some sort of connection there
20:00:59 <ski> which type-level programming ?
20:01:09 <siraben> In Haskell
20:01:18 <ski> with type classes, or with data types ?
20:01:24 <siraben> type classes
20:01:35 <ski> type classes are predicates. data types can also be seen as predicates
20:01:36 <Solonarv> yeah, there's some common ground there
20:01:39 <siraben> ski:  Re: toposes Hm.  I see.
20:01:44 <Solonarv> I'm not very good at explaining it though :p
20:01:47 <ski> also we have functional dependencies
20:01:55 * Solonarv doesn't really know prolog
20:01:59 <siraben> Prolog people like to talk about their modal logic
20:02:11 <texasmynsted> I need to search using partial equality. What would be a good reference for me to check out?
20:02:20 <ski> siraben : well, you may not know much of what toposes is about, so perhaps that part of what i said doesn't help much
20:02:28 <koz_> texasmynsted: What is 'partial equality'? What are you searching?
20:02:41 <siraben> toposes is Greek to me
20:02:44 <koz_> ski: Also, is it 'toposes' or 'topoii'?
20:03:16 <ski> Solonarv : if you're interested in different programming paradigms, different approaches to computation, then you should, at some point, imho, look into logic/relational programming (and then also into constraint programming, which is often combined with the former, as CLP)
20:03:45 <siraben> The microkanren paper was enlightening
20:03:50 <ski> Solonarv : both FP and LP are classified as declarative programming. FP uses functions as main vehicle for computation. LP uses predicates/relations
20:04:22 <texasmynsted> oh nm. I think I can just create a search predicate
20:04:33 <ski> there's a lot of overlap (you can't assign after initialization, looping (mostly) via recursion, pattern-matching)
20:04:52 <ski> but also some interesting differences, and unique capabilities/strengths
20:05:05 <siraben> ski:  So could one just "lift" a value into the category of types, perform type-level programming (kind of like LP), and reify that back into a value?
20:05:05 <Solonarv> I see! do you perhaps have some material you'd recommend as a good entry point?
20:05:15 <ski> koz_ : i've seen both
20:05:26 <ski> koz_ : actually just "topoi" for the latter
20:05:54 <Solonarv> siraben: ehh, not really - "lifting" a value like that requires dependent types, which we don't have in Haskell
20:05:55 <siraben> Solonarv:  If you're interested in implementing a mini logic programming DSL (without disequality or impure operations like "cut") see http://webyrd.net/scheme-2013/papers/HemannMuKanren2013.pdf
20:06:04 <ski> siraben : heh, must only be some Prolog people (re modal logic). Prolog itself doesn't have modalities
20:06:31 <siraben> What are the algorithms behind typeclass instantiation?
20:07:15 <ski> Solonarv : Mercury is a modern LP language with a proper module system, static typing (with type classes) .. but i'd suggest learning Prolog in any case, if for no other reason that most resources are in terms of Prolog (and it's more flexible in some ways)
20:07:29 <Solonarv> Makes sense/
20:08:32 <ski> Twelf is a "dependent logic programming language"
20:08:33 <siraben> Solonarv:  and could one add dependent types to the language?
20:08:39 <ski> (as in dependent types)
20:08:48 <siraben> I see that haskell has less expressive type system than Coq
20:08:53 <siraben> a less expressive*
20:08:54 <Solonarv> siraben: sure! in fact work is being done on that already
20:09:14 <koz_> There is the singletons library.
20:09:23 <Solonarv> but it requires a lot of work, especially because adding dependent types should not degrade non-dependently-typed code
20:09:31 <ski> siraben : in what context are you asking your question ?
20:09:45 <siraben> ski:  which question
20:09:50 <ski> the lift one
20:12:02 <siraben> ski:  https://dpaste.de/gvyE
20:12:31 <siraben> I was wondering if I could convert, say, 3 into the "value" undefined :: Succ (Succ (Succ Zero))
20:12:46 <siraben> What type would such a function even have?
20:12:55 <ski> siraben : (topoi) traditionally, to the extent that mathematicians have found a need for appeal to foundations at all (which is very little, possibly due to the foundations fight and the anti-climax by Gödel in the first half of the 1900s), they have referred to ZF set theory (which could be thought of as akin to assembly or machine language programming. most people don't enjoy working at this level for any extended length of time)
20:12:59 <siraben> Ah that's why one needs dependent types, because it makes a new type for each value
20:13:36 <siraben> ski:  IIRC there are still foundation attempts right?
20:13:38 <siraben> metamath et al.
20:14:05 <ski> siraben : (some) categorists claim that the language of categories can be used as a better foundation, that's closer to the actual practice of how maths done and thought about. also changing a bit the idea of what is expected from a foundation
20:14:27 <siraben> Hm, there's also the Univalent Foundations project
20:14:39 <siraben> Which sort of combines type theory and topology
20:15:17 <MarcelineVQ> ye homotopy (and cubical type theory) aim to be a foundation
20:15:30 <ski> siraben : Lawvere pioneered describing set theory categorically (people thought he was crazy at first), you get ETCS, the Elementary Theory of the Category of Sets, which is just a first-order theory, not presupposing any ambient notion of sets. there's also an axiomatization of the Category of Categories
20:16:40 <siraben> ski:  re: dependent types, but does adding dependent types to the language (so for instance, I could define a function that only takes the head of a list of length 5 or more) not require adding propositions and proofs à la Coq?
20:16:58 <ski> siraben : a Topos is a category that's "sufficiently" like the old category of `Set's we all love, similar enough that we can "do set theory inside it" (except it turns out that the natural logic to use inside it is a constructive/intuitionistic logic, to the surprise of both classical and constructive mathematicians)
20:17:08 <siraben> ski:  re: categories If you have some links on that it would be helpful
20:17:10 <siraben> Sounds interesting.
20:17:14 <ski> yea, univalent foundations is cool
20:18:13 <ski> siraben : e.g. there's a category of all graphs. this is actually a topos. all toposes contain a "truth-value object", an object that behaves as a "type of truth-values", for the topos in question
20:18:50 <ski> siraben : in this case, the graph has two nodes, `true' and `false', and five edges :
20:19:00 <ski>   true : true >---> true
20:19:17 <ski>   in : false >---> true  -- aka `target'
20:19:28 <ski>   out : true >---> false  -- aka `source'
20:20:03 <Solonarv> siraben: in some sense Haskell already has those (via Curry-Howard), but they're allowed to be bogus (i.e. 'undefined' and similar non-values), so they would have to be evaluated to make sure they aren't bogus
20:20:12 <ski>   foray : true >---> true  -- aka `endpoints'
20:20:17 <ski>   false : false >---> false
20:20:46 <siraben> ski:  in the category of all graphs, the morphisms are graph homomorphisms?
20:21:24 <ski> siraben : if you pick any graph, and select a subgraph of it (compare to selecting a subset of a set), you can then ask, for any node or edge in the whole graph, whether it's inside or outside the subgraph. the corresponding "truth-value" is a node or edge of this "truth-value graph"
20:21:30 <Solonarv> siraben: if you want a (big!) paper to read, Richard Eisenberg's thesis outlines how Dependent Haskell might be accomplished - https://cs.brynmawr.edu/~rae/papers/2016/thesis/eisenberg-thesis.pdf
20:21:31 <ski> siraben : yep
20:21:44 <Solonarv> Some of the ideas in there are already implemented in today's GHC
20:21:46 <koz_> Solonarv: That's basically the basis on which they're rolling singletons, right?
20:21:53 <ski> for nodes, the truth-value assignment is obvious
20:22:28 <Solonarv> koz_: Richard Eisenberg is the author of 'singletons'!
20:22:52 <siraben> ski:  hang on, so let's say I have graphs A and B where A > B, and I have a vertex C in A, how do I map this property to the "truth value"?
20:22:59 <siraben> it would have to leave the category right?
20:23:00 <Solonarv> so yes, they're related - in some sense 'singletons' lets us pretend that we have dependent types in some situations
20:23:16 <ski> for edges, you get `true' if it's completely in the subgraph, `false' if it's completely outside. `in'/`target' if its target node is inside, but the edge itself and its source is outside. `out'/`source' is the reverse of that. `foray'/`endpoints' if both endpoints are in, but the edge is not itself inside
20:24:23 <ski> siraben : if the node/vertex `C', picked from `A', is inside `B', then you get the node `true' in `Omega' (the truth-value object, aka a subobject classifier). if it's not in the subgraph `B', you get `false'
20:24:41 <ski> siraben : "leave the category" ?
20:24:56 <siraben> I mean the mapping would be from C to an object not in the category of graphs
20:25:17 <ski> no, `Omega', the object of truth-values, is itself a graph, that's the whole point !
20:25:37 <siraben> O.o the object of truth values as a graph???
20:25:50 <ski> just like a subset `S' of a set `A' can be exactly described by a function from `A' to the set (ordinary) of truth-values
20:25:56 <siraben> And that object is arbitrarily chosen?
20:26:04 <siraben> Ah so the "graph" of truth
20:26:11 <ski> no, it has to satisfy a particular condition
20:27:15 <ski> there can be only one truth-value object (up to isomorphism, obviously. everything in category theory is up to isomorphism (roughly speaking. it's a bit more subtle with 2-categories, and so on. homotopy type theory is an attempt to make this more clear))
20:27:59 <ski> siraben : yes
20:28:00 <siraben> But if the object of truth Omega is a graph, then I can make a graph H such that H > Omega and then ask whether a vertex C picked from H is in Omega, and would this be a mapping from Omega to Omega?
20:28:13 <siraben> If C is in Omega
20:28:40 <ski> no, that subobject would have as classifying morphism a morphism from `H' to `Omega'
20:29:44 <ski> but yes, if you take e.g. `Omega * Omega', and take the point `(true,true)' in that, then that specifies a (singleton) subobject, whose classifying morphism, from `Omega * Omega' to `Omega', turns out to be conjunction of truth-values
20:29:49 <ski> you can define conjunction like this
20:29:51 <siraben> How can you make a "special" graph without it being isomorphic to another graph in the category of graphs?
20:30:06 <ski> i don't know what you mean ?
20:30:12 <siraben> Omega
20:30:24 <siraben> Is it not isomorphic to an ordinary graph in the category already?
20:30:47 <ski> it *is* an "ordinary" graph, i just specified it as a graph, above
20:31:02 <ski> just a bunch of nodes, and a bunch of edges between them
20:31:09 <siraben> So it could be, say, the graph containing one vertex and no edges?
20:31:27 <ski> (note that i'm talking about directed multi-graphs, with loops allowed, here. one could also consider other variations of graphs)
20:31:50 <siraben> Oh I wasn't imagining multi-graphs
20:31:51 <ski> that's an important special case "trivial" graph, yes
20:31:57 <siraben> I see.
20:32:22 <ski> (note that the edges `true' and `foray' are parallel edges. also both are loop on a singl node, `true')
20:32:34 <siraben> Hm. So all toposes/topoii contain a special object representing "truth"
20:32:38 <ski> yes
20:32:55 <siraben> What's the smallest possible topos?
20:33:02 <ski> here's another example. take any set, and any function from that set to itself, an "endofunction"
20:33:27 <ski> hm, the category with one object and one (identity) morphism, i think, written `1'
20:33:37 * ski ponders
20:33:58 <ski> hm, i'd have to check the axioms, but i think it probably fits the bill
20:34:50 <ski> anyway, a pair `(A,alpha)' with `A' a set, and `alpha : A >---> A' a function on that set, is called a (discrete) dynamical system
20:35:16 <ski> (`alpha' doesn't need to be a bijection / set isomorphism. in some cases one might only be interested in that special case)
20:35:19 <siraben> I see.
20:35:41 <siraben> ski: are you a mathematician/graduate student, by any chance?
20:35:42 <ski> you can think of it as each element of the set has a specified "next" element, "after one time step"
20:36:05 <ski> i study math and computing science
20:36:51 <ski> starting from any element, you get a "trail", as you "progress time". either you might eventually go into a loop, or you continue indefinitely (only possible in case the set is infinite)
20:37:15 <ski> each loop could have several "hairs" protruding from it, that eventually lead into the loop
20:37:20 <siraben> Right.
20:37:39 <ski> (and the hairs could be branching, or joining, if you think of it in the forward direction)
20:38:33 <ski> a morphism from `(A,alpha)' to `(B,beta)' is a function `f : A >---> B' that "respects time", iow it doesn't matter if you take a step before or after applying `f' : `f . alpha = beta . f'
20:38:55 <ski> there is an obvious notion of sub-dynamical-system
20:39:55 <ski> it turns out that the subobject classifier, `Omega', can be described as `(|N u {oo},pred)', where `|N' is the natural numbers, and `oo' is an extra "infinity" point added to it, `pred' is defined as
20:40:00 <ski>   pred(0) = 0
20:40:04 <ski>   pred(n+1) = n
20:40:08 <ski>   pred(oo) = oo
20:40:40 <ski> `0' means truth. `oo' means falsity, any positive number `n' means "currently, false, but true after `n' time steps"
20:40:50 <ski> so `0' is eternally true, and `oo' is eternally false
20:41:38 <ski> if you pick a point that is not in your subsystem, but will be (in no less than) two steps, its assogned membership truth-value will be `2'
20:41:39 <siraben> Does this have an analogue construction in Haskell/Coq?
20:42:04 <ski> `0' if it's already inside. `oo' if it never enters. by def. of subsystem, once you enter, you can never leave
20:42:28 <siraben> ski:  what about in the category of types?
20:42:33 <siraben> There must be a topos there then
20:42:52 <ski> well, the objects of a category (at least a "large" category) can be thought of as "types" of some sort
20:43:11 <siraben> Hm what is the difference between a large and small category?
20:43:20 <siraben> Since they both could be infinite
20:43:27 <siraben> I mean, uncountably infinite
20:43:40 <ski> in this case, the type `(A,alpha)' incorporates both an (ordinary) set/type `A', and also a (from Haskell or TT POV) value-level entity, `alpha', so you need something like dependent types
20:44:15 <koz_> siraben: A 'small' category's morphisms form a set.
20:44:19 <koz_> A 'large' category's don't.
20:44:24 <koz_> (or, more exactly, _can't_)
20:44:39 <siraben> Hm?
20:44:41 <siraben> Can't?
20:44:53 <koz_> siraben: There are collections which cannot be sets.
20:44:58 <koz_> For example: the collection of all sets.
20:45:02 <koz_> (or the world asplode)
20:45:27 <ski> (one can also consider "small" categories, just like i specified a "small" graph above. which you could model as `data Obj = ObjA | ObjB | ...' and `data Mor :: Obj -> Obj -> * where Id :: Mor a a; Comp :: Mor b c -> Mor a b -> Mor a c; MorAB :: Mor A B; ...'. you could do a free construction to not have to repeat the `Id' and `Comp' parts ..)
20:45:47 <siraben> koz_:  Oh, Russell's paradox
20:45:48 <slack1256> Anyone using hadoop with haskell?
20:45:55 <slack1256> how was your experience?
20:45:57 <koz_> siraben: You'd be surprised how easy it is to trigger.
20:46:05 <koz_> For example: the collection of all groups? Not a set.
20:46:15 <siraben> koz_:  What other things aren't sets?
20:46:16 <ski> the category `Set' contains *all* sets, and *all* (total) functions between them
20:46:25 <koz_> siraben: The collection of all singleton sets.
20:46:38 <siraben> And you can have a category of all sets because the category is not a set!
20:46:49 <siraben> Wow, so there is a small and large category
20:47:00 <koz_> siraben: Small and large categor_ies_.
20:47:06 <koz_> A related notion: local smallness.
20:47:18 <siraben> Yes.
20:47:27 <siraben> Very mind-bending stuff.
20:47:52 <ski> the category `Cat' contains all small categories. `Cat' itself is not small, but large. you could add a hierachy so that you get a large-large (or how to phrase it) category that contains all large categories, like e.g. `Cat'
20:48:02 <koz_> ski: Huge?
20:48:20 <ski> anyway, plain ZF set theory isn't enough to describe this
20:48:53 <koz_> Or perhaps Large1?
20:48:58 <siraben> I like mathematics and all, but what about applying this?
20:49:00 <ski> there are various alternatives, that people have suggested, either talking both about sets and (proper) classes. or introducing a hierarchy of them (one for each natural number)
20:49:52 <ski> category was invented to be applied in algebraic topology, iirc, but has since spread, since it's also useful in other fields
20:50:00 <ski> s/category/categories/
20:50:20 <ski> ZF set theory focuses on constructions/definitions/implementations
20:50:58 <ski> CT focuses on *specifications* and relations between things, doesn't really care what something "is", but care how it "behaves" or "relates" to other things of the same kind
20:51:13 <siraben> I see.
20:51:58 <ski> from the POV of CT, an object has no internal structure, you are forbidden to "look inside" it. you're supposed to "probe" it only via morphisms from/to other objects, that may be more well-understood
20:52:12 <koz_> I think Awodey's book on category theory has a nice table illustrating how categorical ideas connect a bunch of seemingly-unrelated things in a bunch of fields.
20:52:40 <siraben> ski:  on page 5 of http://www.informatik.uni-bremen.de/~cxl/papers/icfp02.pdf what does the author mean by algebra monad?
20:52:42 <ski> (of course, if you build a category from parts, you can look at its implementation, including internal structure of the object, e.g. in order to prove categorical properties of certain objects and morphisms)
20:52:46 <siraben> Right column
20:54:13 <MarcelineVQ> idk but it's "term algebra, monads" fwiw
20:54:20 <ski> hm, i suspect they're talking about what's often called an "expression monad"
20:54:33 <ski> ("term" is often synonymous with "expression")
20:54:36 <ski> e.g. consider
20:54:41 <ski>   data Expr var = Var var
20:54:50 <ski>                 | Lit Integer
20:54:57 <ski>                 | Add (Expr var) (Expr var)
20:55:09 <ski> i've parameterezed on the type of variable identifiers
20:55:17 <siraben> Ok.
20:56:15 <ski> this is actually a monad, `return = Var', and `join :: Expr (Expr var) -> Expr var' takes an expression tree whose leaves/"variables" (not counting `Lit's which are considered to be internal nodes with zero children) are themselves expression trees (in some variable type `var')
20:57:01 <ski> and it just removes those "intemediate" `Var' data constructors, grafting the "expression-as-a-variable" in place of the variable leaf `Var v'
20:57:33 <ski> now, `(>>=) :: Expr var0 -> (var0 -> Expr var1) -> Expr var1' turns out to be variable substitution, in this monad
20:57:37 <ski> if you say
20:57:45 <ski>   do var <- expr
20:57:50 <ski>      ..var..
20:58:17 <ski> then that means : navigate down to each variable `var' in the expression `expr', and replace that variable with the expression computed by `..var..'
20:58:42 <siraben> I see.
20:58:44 <ski> note that since there may be several variables, this may perform `..var..' many times, for different choices of the value `var'
20:59:26 <ski> it's a kind of non-determinism monad, like the list monad, only you don't have something like list concatenation flattening the results, they stay structured in the tree
20:59:47 <ski> and the tree has extra information, like the `Lit' case above, that is left in place
20:59:51 <ski> then you can define
21:00:22 <ski>   fullSubst :: Expr var -> (var -> Expr var) -> Expr v
21:00:37 <ski>   fullSubst expr env = do
21:00:45 <ski>     var <- expr
21:00:58 <ski>     fullSubst (env var) env
21:01:43 <siraben> Hm.
21:01:49 <ski> this looks like a nonterminating recursion, but is just fine, it reapplies the same variable substitution, until there's no variables left (and so we are polymorphic in the result variable type, we could have used `Void' instead of `v')
21:03:28 <Solonarv> it is indeed non-terminating if you pass the wrong kind of 'var -> Expr var' argument, but even then laziness will often save us
21:03:45 <ski> anyway, in the paper, when they say "signature" i think they mean a particular specification of internal nodes (including how many subtrees they should have) in an expression data type of some sort (without bound variables, and without mutual recursion between different kinds of phrases, say)
21:04:17 <ski> well, yes. if you have a cycle in your substitution, obviously you'll get stuck
21:04:52 <ski> and the term algebra monad is the construction that makes a data type for this, adding the `Var' case, and makes this into a monad in the way i described
21:07:46 <ski> siraben : anyway. there's lots of constructions in different fields of math that look sortof similar to each other. like direct product of groups, rings, vector spaces, topological product, &c. .. all these turn out to the special cases of the same single concept "categorical product" (which also includes conjunction and also intersection)
21:08:13 <ski> so it's economical to have a single unified overarching view
21:08:58 <ski> category theory is perhaps foremost a unified language for describing and comparing features in different parts of math with each other, also allowing to translate from one area to another
21:09:30 <ski> (e.g. translating one problem in topology into a related problem in group theory, where it may be simpler or more obvious to solve, then translating the solution back)
21:10:35 <ski> there's even books about how to apply categories in database theory, and in software engineering
21:11:46 <ski> (if you have two module signatures, which are both derived from a single module (both extending it), you may want to "recombine" ("diamond"). this is a case of a standard categorical construction called "pushout" which is a bit like unions)
21:12:49 <ski> hm, and iirc unification of expressions (e.g. types), is an example of the "equalizer" concept
21:13:37 <ski> there are a few books about categories in the context of computing science
21:14:47 <ski> Awodey's book is more like a general introduction, but doesn't require much mathematical backgroups (it assumes sets, basic logic, and goes a bit into monoids, and some into groups in a chapter)
21:15:00 <ski> (it's available on-line)
21:16:06 <ski> but i'd say the Lawvere&Schanuel book, which is slow-going and nice, may perhaps be the nicest to start with, if you're at all interested in the more mathematical view, rather than a more narrow CS view
21:17:07 <ski> (and as i said, it doesn't require much mathematical background, unlike e.g. the classic "Category Theory for the Working Mathematician" by McLane (one of the two founders of CT), and several other "intro" books)
21:17:47 <ski> (the problem there is that you may need examples to understand the examples. you're in some sense one abstraction level above what's going on in particular math fields)
21:19:08 <texasmynsted> I should be able to install a package "globally" by doing this from my home dir right?  "cabal new-install foo"
21:20:25 <ski> siraben : if you want to, i could try to dig up the names and authors of a few books about CT in the context of CS, that i've looked at
21:20:32 <Solonarv> texasmynsted: if you want it as a library you'll want to add '--lib' to that command, IIRC
21:21:08 <Solonarv> otherwise you'll just get executables in ~/.local/bin (by default)
21:21:41 <siraben> ski:  Right. Category theory is general enough to have connections between everything
21:22:49 <texasmynsted> okay. Thank you
21:24:23 <ski> siraben : re implementation vs. specification : in ZF, an ordered pair `(a,b)' is usually (Kuratowski) *defined* to be the set `{{a,b},{a}}', so that you can ask silly questions like whether `{3}' is an element of `(x,y)', that obviously has nothing to do with the abstract idea of pair, but is tied to this particular more or less arbitrary way of *encoding* a pair in terms of (nested) set (which only ever contain other sets, nothing else)
21:25:40 <ski> siraben : in category theory, we don't care about the implementation (as long as we have one), as long as (handwaving slightly) we get properties like `(fst p,snd p) = p',`fst (x,y) = x',`snd (x,y) = y',`(x0,y0) = (x1,y1) => x0 = x1 /\ y0 = y1'
21:26:54 <ski> (handwaving, because we don't talk about elements of objects/types. but we can instead use morphisms from the object `1', which commonly works just as well. also, in a topos, there's an "internal language", which looks like a type theory, with ordinary terms and so on, which can be translated into the "external language" of morphisms)
21:27:29 <texasmynsted> I looked at the latest `fail` in Hackage is 4.9.0.0. but I keep getting this error "https://gist.github.com/mmynsted/cd218900a3b5cc95d9825b3a9fef90c4"
21:27:42 <texasmynsted> failed to build documentation
21:28:08 <texasmynsted> I tried just installing fail with --enable-documentaion, which also fails
21:28:10 <ski> in `Set', you can talk about elements of a set `A' in terms of the morphisms of "type" `1 >---> A'. where `1' is any singleton set, e.g. the set containing the empty tuple. `1' is called a terminal object, a general categorical concept, which happens to be the singleton, in `Set'
21:29:15 <ski> in `Set', two morphisms `f,g : A >---> B' are equal (`f = g') iff for any "element" (a morphism) `x : 1 >---> A', `f . x = g . x'. `1' is called a "generator" object in `Set'
21:29:59 <ski> in `Graph', it's not enough to look at morphisms from the graph `1' (which has one node, and one loop-edge on that node). you also need the graph `D' that you mentioned, that has only one node, no edges
21:32:40 <ski> (in `DynSys', the category of discrete dynamical systems, the terminal object `1' consists of one point, and the "next" function sends it to itself. so it's just one self-loop. `1' is not a separator in `DynSys', you need an object `(|N,succ)' to be able to "point to" all elements)
21:34:53 <ski> Solonarv : one of the nicest things in logic programming is that there's no inherent division between input and output, among the arguments of a relation/predicate. you could, in one call, pass in some arguments as input/known, and others as output/unknown, solving (like in an (in)equation, or (in)equation system) for the unknowns. that's called a query (question)
21:37:13 <texasmynsted> nm. Trying an update and rebuild reinstall.
21:59:51 <kaychaks[m]> siraben:  miniKanren builds upon Oleg's `LogicT` which introduced backtracking for continuation monads thereby extending Haskell to do idiomatic relational / logic programming (ref: [Backtracking, Interleaving, and TerminatingMonad Transformers](http://okmij.org/ftp/papers/LogicT.pdf))
22:04:40 <kaychaks[m]> and edwardk was last seen enhancing those same concepts as a pure Haskell implementation (with some lower level stuff in C) in [guanxi](https://github.com/ekmett/guanxi)
22:10:17 <ski> also perhaps take a look at "Embedding Prolog into Haskell" by Silvija Seres,J. Michael Spivey at <http://www.silvija.net/0000OxfordPublications/seres_haskell99.pdf>, and "Typed Logical Variables in Haskell" by Koen Claessen,Peter Ljunglöf in 2000 at <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.2565>
22:13:14 <ski> (the latter uses a continuation monad. if i'm not mistaken, that predates Oleg's `LogicT')
22:16:06 <ski> (i did a small project, building partly on ideas of the latter paper, to implement a small embedded logic programming system in Haskell, the main novelty was (arbitrarily-left-nested) goal implications, which i did via arbitrary many `ContT' layers, so that i could backtrack backtracking backtracking ...)
22:53:45 <texasmynsted> Hmm. I can not see to install fail-4.9.0.0. I do not see an active ticket for the problem. Here is the message I get https://gist.github.com/mmynsted/5537f4d41bd8d7916dca6ab01fdeea96
22:58:59 <c_wraith> texasmynsted: can you run cabal with -v, so that the actual error gets printed?
22:59:33 <texasmynsted> okay https://gist.github.com/mmynsted/5527ffebd925f475494066afbf3c47ea
23:02:54 <texasmynsted> I updated the gist. The first time I think it was missing a few lines.
23:09:38 * hackage unbeliever 0.9.2.0 - Opinionated Haskell Interoperability  https://hackage.haskell.org/package/unbeliever-0.9.2.0 (AndrewCowie)
23:14:11 <texasmynsted> any ideas?
23:15:56 <cocreature> texasmynsted: iirc that error was fixed in a newer version of cabal and/or haddock
23:16:18 <cocreature> oh wait that’s fl, not fail right?
23:16:38 <cocreature> not sure then
23:16:51 <texasmynsted> It was building fail.
23:17:05 <texasmynsted> I do not know why it says fl in the verbose errors
23:17:09 <cocreature> ah right
23:17:34 <cocreature> the error with fail that I’m remembering was due to the fact that in some configurations it has no modules which broke things
23:34:38 * hackage b9 0.5.67 - A tool and library for building virtual machine images.  https://hackage.haskell.org/package/b9-0.5.67 (SvenHeyll)
23:35:59 <texasmynsted> I suppose it would not hurt to upgrade cabal.
23:55:28 <p0a> Hello, how can I read the documentation of a function? For example, `iterate'. If possible, in my setup without the internet.
23:55:49 <p0a> :? doesn't show any related commands, and :i does not give any documentation
23:56:29 <c_wraith> I can't recall if :doc is released or not
23:56:41 <p0a> says unknown command
23:58:45 <c_wraith> well, as an alternative, you can set cabal to always build docs when it installs a package
23:58:52 <c_wraith> and just use your browser on the local docs
