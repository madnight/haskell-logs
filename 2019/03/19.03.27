00:08:37 * hackage servant-rawm 0.3.1.0 - Embed a raw 'Application' in a Servant API  https://hackage.haskell.org/package/servant-rawm-0.3.1.0 (cdepillabout)
00:18:13 <remexre> how much do people actually use recursion-schemes?
00:19:38 <glguy> Not so much in actual projects
00:20:06 <remexre> hm, okay
00:20:44 <remexre> I'm finding myself wanting something that's pretty close to Data.Fix.Fix
00:22:18 <remexre> but more like newtype FixAnnot s p f = Fix { unFix :: (Either s (f (FixAnnot s p f)), p) }
01:15:53 <jusss> what's wrong with this code? https://paste.ubuntu.com/p/x7crFYgBqb/
01:18:27 <Ariakenom> jusss: what's the type of main and what's the type of fib 3
01:18:34 <Ariakenom> jusss: but you should include the error your having trouble with too.
01:22:22 <jusss> Ariakenom: https://paste.ubuntu.com/p/3jJGrJsXRk/
01:23:41 <Ariakenom> jusss: "fib n-1" parses to (fib n) - 1
01:23:58 <Ariakenom> not "fib (n-1")
01:24:28 <Ariakenom> sry, I mean not "fib (n-1)"
01:24:34 <eiGHttt> fib n = n + (fib $ n - 1)
01:24:51 <jusss> Ariakenom: ok, why sometimes it can be without () , sometimes not
01:26:19 <Ariakenom> jusss: function application binds with "higher priority" than operators
01:27:10 <Ariakenom> so if you want to read, you can start with function applications and put parenthesis around it
01:27:29 <jusss> ok
01:27:35 <Ariakenom> f a b+1 = (f a) b+1 = ((f a) b)+1
01:29:46 <Ariakenom> jusss: using more parenthesis than necessary isn't a problem. if it's confusing just use parenthesis :)
01:30:28 <jusss> Ariakenom: I see
01:35:11 <jusss> Ariakenom: is t :: Int -> Int eqal to t Int :: Int?
01:36:23 <Ariakenom> jusss: no but if "t :: Int -> Int" then "t 3 :: Int"
01:36:28 <eiGHttt> likes (+) and (+ 1).
01:37:38 <jusss> Ariakenom: eiGHttt how I can make t to a type constructor so I can use it like a function,   data t Int = Int?
01:38:26 <jusss> Int can not be the right side of '=' ?
01:40:31 <ziman> you might want to google for "type families" or "closed type families" if you want type-level "functions"
01:40:39 <jusss> my mistake, value constructor is like a function,
01:40:43 <jusss> not type constructor
01:41:03 <Ariakenom> @src Maybe
01:41:03 <lambdabot> data Maybe a = Nothing | Just a
01:41:06 <eiGHttt> data MyInt a = Int?
01:41:24 <eiGHttt> @src Proxy
01:41:24 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
01:41:59 <Ariakenom> jusss: I don't understand the question. But I would advice following a tutorial to learn the basics
01:42:00 <jusss> eiGHttt data MyInt a =Int? is in valid I think
01:42:23 <jusss> 'cause Int is a type constructor
01:43:48 <inkrelease> is haskell useable for web?
01:43:57 <inkrelease> like web programming?
01:44:14 <jusss> inkrelease: Elm? Clay?
01:44:19 <tdammers> inkrelease: yes.
01:45:04 <tdammers> inkrelease: server-side, it's great IMO; client-side, it can be great but requires quite some hoop-jumping to get it working, and it's still a bit of an ongoing research area
01:45:10 <koz_> There's like, at least one all-singing, all-dancing web framework.
01:45:17 <koz_> (I think)
01:45:53 <tdammers> koz_: you mean yesod? if you like "big" frameworks, then that's the one to use, otherwise, you can also use lighterweight libraries, or even just code directly against WAI
01:51:28 <koz_> tdammers: Yeah, I meant yesod. I have no feelings either way, as web _anything_ is something I have chosen to consciously avoid.
01:55:34 <tdammers> haha, I feel your pain
01:56:01 <tdammers> there's also servant, which isn't a web framework by any means, but a fairly slick choice for SPA-style and other API-heavy apps
02:19:21 <delYsid> Hmm, how do I translate a regexp to a parser?  In particular, something like (optional $ char 'a') <*> char 'a'  How do I avoid the optional matching if the input only consists of "a"?
02:21:12 <delYsid> Or is that even possible with applicative parsers?
02:21:13 <Axman6> in that case make the optional the second parser
02:21:26 <Axman6> char 'a' <*> optional (char 'a')
02:21:44 <Axman6> or string "aa" <|> char 'a'
02:21:55 <delYsid> no, thats just the example. In the real world, it is indeed the first parser that is optional, and the second one is not.
02:23:01 <Axman6> can you provide another example then? that one is pretty simple to fix
02:26:36 <delYsid> Afraid of geeting misunderstood :-)  I basically have (,) <$> ((,) <$> optional p <*> optional q) <*> (combine <$> p <*> q)
02:27:28 <delYsid> but that doesnt work, becuase the optional p fires and doesnt allow the non-optional p to consume its required input.
02:27:36 <delYsid> In regexp land, this is pretty easy to express.
02:29:27 <delYsid> I need a non-greedy parser somehow.
02:29:33 <dminuoso> Is it safe to have concurrent builds reuse the same cabal store?
02:31:07 <phadej> in theory yes
02:31:44 <phadej> you might rebuild the same package though, as concurrent builds don't communicate
02:35:25 <dminuoso> phadej: Oh yeah thats fine. I intend on using the gitlab caching feature to cache the cabal store across multiple runners so that builds are sped up accordingly.
02:36:01 <delYsid> Axman6: Or do I have to use Alternative and write all teh possibilities out by hand?
02:36:40 <pavonia> delYsid: What parser library are you using?
02:37:11 <delYsid> pavonia: Not committed yet.  Playing with Megaparsec, but can switch if that makes these patterns easier.
02:37:55 <pavonia> Isn't megaparsec backtracking automatically?
02:38:34 <delYsid> apparently not.
02:39:27 <delYsid> I guess those two optionals behave like two bits.  So I could write a sum type with four constructors and write all the alternatives out by hand.  But this feels so strange compared to the regexp version.
02:41:09 <pavonia> Perhaps backtracking doesn't work here because the first partial parser is already accepting
02:43:38 <Unhammer> If I did `stack build --profile` when first building a project, will the stuff in ~/.stack end up as profiling libs? They don't get rebuilt when I do `stack build` without -profile later
02:44:36 <delYsid> I am trying to parse short algebraic notation from chess.  things like e4 vs de4 vs d3e4.  The source square coordinates are optional, but the target square coordinates always needs to be complete.
02:46:01 <phadej> dminuoso: aren't runners execute in isolated environments?
02:47:14 <dminuoso> phadej: You can bind mount things into them.
02:48:53 <phadej> dminuoso: Ok, I'm not aware what self-run runners can do :)
02:49:00 <phadej> self-hosted*
02:49:05 <phadej> good to know
03:10:21 <Axman6> dminuoso: do you just need to use try on the first parser?
03:11:06 <Axman6> uh, delYsid*
03:11:37 * hackage syntactic 3.8 - Generic representation and manipulation of abstract syntax  https://hackage.haskell.org/package/syntactic-3.8 (EmilAxelsson)
03:16:16 * utonx[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/fwXUFurpmUOstukOsbEkPmoi >
03:16:40 <utonx[m]> sorry, the first line is
03:16:41 <utonx[m]> ```reverse_taps p@(DaPhone xs) c
03:16:55 <utonx[m]> ```
03:16:56 <utonx[m]> reverse_taps p@(DaPhone xs) c
03:16:57 <utonx[m]> ```
03:20:53 <dminuoso> utonx[m]: Interesting question. The haskell report suggests that the idea is possible.
03:21:21 <__monty__> Really? I thought it was one where per equation?
03:21:53 <dminuoso> 4.4.3 Function and Pattern Bindings
03:22:10 <dminuoso> rhs  →  = exp [where decls] | gdrhs [where decls] 
03:22:17 <dminuoso> gdrhs  →  guards = exp [gdrhs]
03:22:51 <dminuoso> Ohh you are right __monty__ 
03:23:03 <dminuoso> utonx[m]: The where binding comes after all the guards.
03:23:15 <dminuoso> You can use `let` if you want local bindings though.
03:23:55 <__monty__> Yes, `let in` after the `=` or `, let` as part of the guard.
03:24:57 <utonx[m]> alright, I knew about the usage after guards but thought this should be possible too.
03:25:01 <utonx[m]> thanks
03:27:38 <Ariakenom> % f x | x == 1, let y | let z = y = z, y == 1 = y
03:27:38 <yahb> Ariakenom: 
03:28:01 <Ariakenom> clearly expressed :p
03:30:07 * hackage imperative-edsl 0.8 - Deep embedding of imperative programs with code generation  https://hackage.haskell.org/package/imperative-edsl-0.8 (EmilAxelsson)
03:38:54 <akersof> hi guys, i would like to install servant.. but i have no clue on how to install if from hackage
03:39:19 <akersof> i just can't runhaskell Setup configure and build cause of dependencies and it fails
03:40:07 <tdammers> servant is a library
03:40:13 <akersof> what is the "normal" way for installing new package , like servant?
03:40:22 <tdammers> depends on your workflow
03:40:37 <tdammers> if you're working on some project, the usual approach is to write a .cabal file for it that lists all dependencies
03:40:53 <tdammers> and then you use cabal new-build (or, if that's your thing, stack install) to build it
03:41:47 <tdammers> cabal used to install things globally, and it can still do that, though with the v2 set of commands, the project-based workflow seems a much saner choice to nme
03:42:16 <akersof> tdammers: ok so i have to check how to init a project with cabal
03:44:14 <akersof> tdammers: thx
03:44:37 * hackage raw-feldspar 0.3 - Resource-Aware Feldspar  https://hackage.haskell.org/package/raw-feldspar-0.3 (EmilAxelsson)
04:28:07 * hackage typerep-map 0.3.2 - Efficient implementation of a dependent map with types as keys  https://hackage.haskell.org/package/typerep-map-0.3.2 (shersh)
04:44:16 <ph88> hey guys, i'm trying to upgrade a project to latest lts and i get an error i'm not sure what to do with  No instance for (Control.Monad.Trans.Control.MonadBaseControl) from the use of withResource  in https://github.com/TechEmpower/FrameworkBenchmarks/blob/master/frameworks/Haskell/yesod/yesod-mysql-mongo/src/yesod.hs#L180
04:51:40 <ph88> something chancel with MonadFail and/or MonadBaseControl .. i'm not sure what it is
05:48:25 <mouse07410> What does the error "... in a hidden module..." mean? I have network-2.8.0.0 and -3.0.1.0 installed (different apps need different versions), and interior good to build with this message. If -3.0.1.0 is not present at all - it seems to build ok.
05:48:50 <mouse07410> ^interior -> intero
05:49:10 <mouse07410> ^good -> fails
06:00:08 <ph88> mouse07410, i think you have to put the module you want in your cabal file
06:06:21 <stevenxl> Hi folks. I am learning about "First Class Families". In the book I am reading, we have a "kind synonym" Exp, declared like so: "type Exp a = a -> Type". I have a few questions on this. Is there a typo in this somewhere? I would have read this as a type synonym. Second, the kind Type is not available in the version of GHC that I am using, and I am getting a parsing error for "type Exp a = a -> *". Is there a way around this?
06:20:11 <dmwit> tdammers++ for excellence
06:21:21 <Unhammer> … but if I first build with `stack build` from a clean .stack, and then `stack build --profile`, it does rebuild the libraries in ~/.stack. Won't that give me slow libraries?
06:21:29 <dmwit> mouse07410: The full error would be nice.
06:24:22 <maerwald> anyone knows off-hand where stack downloads its ghc tarballs from? I skimmed through the sourcecode and it's so much indirection I was only able to figure out it must be some json file with meta info
06:24:25 <maerwald> or even that is wrong
06:25:03 <dmwit> stevenxl: I think in the latest GHCs, there is no longer a distinction between kinds and types (internally at least).
06:25:32 <dmwit> stevenxl: I think you'll have to upgrade GHC to use this stuff.
06:25:41 <mniip> what's your version though
06:25:47 <mniip> you might be missing imports/extensions
06:26:26 <stevenxl> @dmwit  / @mniip  I was missing "import Data.Kind (Type)". 
06:26:26 <lambdabot> Unknown command, try @list
06:27:01 <stevenxl> Thank you both!
06:30:20 <dmwit> Hm. I took you at your word when you said "Type is not available in the version of GHC that I am using". =P
06:31:36 <dmwit> maerwald: Perhaps sufficient verbosity will announce it. If not, there's always wireshark...
06:32:12 <stevenxl> dmwit: Yup. Misleading and wrong statement on my part. 
06:37:03 <maerwald> dmwit: well, I don't just want to know what it downloads on my machine ;)
06:38:23 <dmwit> I'm willing to bet the URL is pretty hackable.
06:38:40 <dmwit> And if you have one URL, it will certainly make it easier to search the code to find how that URL is built.
06:38:54 <dmwit> (In case it isn't completely obvious anyway, which I bet it will be.)
06:40:09 <maerwald> I don't think the urls are hardcoded anywhere :)
06:44:07 * hackage DPutils 0.1.0.0 - utilities for DP  https://hackage.haskell.org/package/DPutils-0.1.0.0 (ChristianHoener)
06:51:07 * hackage SciBaseTypes 0.1.0.0 - Base types and classes for statistics, sciences and humanities  https://hackage.haskell.org/package/SciBaseTypes-0.1.0.0 (ChristianHoener)
06:52:23 <_ceb> Does Haskell have good econometrics libraries?
07:00:37 * hackage PrimitiveArray 0.9.1.0 - Efficient multidimensional arrays  https://hackage.haskell.org/package/PrimitiveArray-0.9.1.0 (ChristianHoener)
07:00:47 <nshepperd> maerwald: https://github.com/commercialhaskell/stackage-content/blob/master/stack/stack-setup-2.yaml looks like the file
07:06:04 <maerwald> nice
07:17:07 <glguy> maerwald: Now that ghcup's install-cabal install the current version, do we still need to build it from source in the ghcup-bootstrap script?
07:26:29 <kuribas> are there people who are proficient in haskell, but decided on another language for their project?
07:27:37 <Aquazi> me, cuz there's no jobs for haskell in Italy at all
07:28:09 <Aquazi> I'm considering switching to F# to ride some of this azure and fp hype, but the jobs are missing too
07:28:26 <_ceb> Who's going to monadic.party?
07:32:12 <glguy> kuribas: Yeah, there are reasons to use lots of languages
07:33:04 <Aquazi> besides writing functional code is more or less the same on pretty much all fp languages I'd say
07:33:27 <Aquazi> it's imho easier to switch from Haskell to most of other fp languages than Java to C#, jm2c
07:34:36 <kuribas> there are quite a few success stories for haskell, I wonder if there are failure stories
07:35:16 <kuribas> glguy: true, but I mean when haskell is a good fit
07:35:21 <kuribas> glguy: for example backend work
07:44:23 <Aquazi> haskell is a good fit when you have proficient functional programmers
07:44:37 <Aquazi> I know it's used a lot for C++ templates, e.g.
07:46:28 <_ceb> Is Haskell a good language for trading?
07:46:33 <maerwald> glguy: the idea was to install the latest cabal-install (tarballs sometimes take longer)
07:46:40 <maerwald> so it wasn't due to the lack of a binary
07:46:42 <Aquazi> that being said, maybe, it's not as good at specific backend work like elixir or scala
07:46:44 <dmwit> ?faq Is Haskell a good language for trading?
07:46:44 <lambdabot> https://wiki.haskell.org/FAQ
07:46:47 <dmwit> aww
07:47:03 <maerwald> but I guess you could make a case that it's not strictly necessary
07:47:07 * hackage BiobaseTypes 0.2.0.0 - Collection of types for bioinformatics  https://hackage.haskell.org/package/BiobaseTypes-0.2.0.0 (ChristianHoener)
07:47:30 <_ceb> dmwit, cmd+F trading gives no results
07:47:49 <dmwit> _ceb: Yeah. ?faq used to do something different, and I didn't know it had changed. Sorry.
07:48:04 <dmwit> Even if it had done what I expected, it would have been a dumb and unhelpful joke.
07:48:05 <maerwald> tarballs for 2.4.1.0 took weeks afair
07:49:03 <dmwit> That said, I don't really know what would make a language "good for trading".
07:49:19 <dmwit> If it's a question about library availability, well... you've got just as much Google access as we do, presumably.
07:50:06 <__monty__> _ceb: It's used at some big finance company. Standard & Poors? But it's not GHC haskell, they implement their own strict version of haskell.
07:50:25 <__monty__> Not sure if it's used there for trading though.
07:51:42 <tabaqui> is there a way to use a function with such signature: "f :: (MonadState Int m, MonadState Char m) :: m ()"?
07:52:09 <tabaqui> I mean not even use, but to write and pass the typechecker
07:52:34 <tabaqui> * f :: (MonadState Int m, MonadState Char m) => m ()
07:53:28 <mouse07410> I think the "is it good for ..." question is about (a) whether the language is expressive enough, (b) whether language makes it easier or harder to write correct/reliable programs, (c) whether it has a rich enough at of libraries so less has to be re-invented, and finally (d) stability of API/ABI.
07:55:41 <mouse07410> After having a little of exposure to Haskell, is say that for (a) and (b) it is great, for (c) I don't know enough to judge yet, and for (d) Haskell ecosystem gets a resounding "F". In my opinion, of course.
07:56:10 <dmwit> tabaqui: No, there is a functional dependency that prevents that from being possible.
07:56:20 <dmwit> class MonadState s m | m -> s
07:58:06 <dmwit> You are of course free to make your own new class that does not have that fundep. Then you can have what you want. But you will soon find out why mtl chose the more restrictive way. ;-)
08:07:52 <the_true_potato> Is anyone here using haskell-ide-engine? I've been trying to get this issue https://github.com/haskell/haskell-ide-engine/issues/1130 resolved, but I haven't gotten any responses. Ideas?
08:20:37 <pie_> the_true_potato, they have an irc channel surprisingly
08:21:33 <the_true_potato> I tried there and it's pretty dead
08:41:06 <tabaqui> dmwit: oh, I forgot about fundeps
08:41:08 <tabaqui> thank you
08:41:29 <tabaqui> iirc, effects allow such behavior
08:42:36 <tabaqui> (oh, new reason to refactor the whole project in favor of effects)
08:49:40 <mouse07410> ph88: the module was in it's cabal file, but without specifying version restrictions. And it's not my cabal file - it's whatever intero happens to have (I'm not the author/maintainer of intero).
08:52:07 * hackage generic-data 0.6.0.0 - Deriving instances with GHC.Generics and related utilities  https://hackage.haskell.org/package/generic-data-0.6.0.0 (lyxia)
08:52:59 <mouse07410> dmwit: the full error is: src/InteractiveUI.hs:116:1: error: Could not load module 'Network' It is a member of the hidden package 'network-2.8.0.0'. Perhaps you need to add 'network' to the build-depends in your .cabal file.
08:53:28 <mouse07410> Line 116 is "import qualified Network"
08:57:34 <mouse07410> Question: is it possible to override dependencies parameters via command line invokation of cabal? Reason: I don't want to have to clone the source tree of every package whose dependencies are specified with wrong versions (like intero). So I want to be able to tell cabal "install X using network-2.8.0.0 instead of the latest you find on this machine"
09:01:37 * hackage vulkan-api 1.1.4.0 - Low-level low-overhead vulkan api bindings  https://hackage.haskell.org/package/vulkan-api-1.1.4.0 (achirkin)
09:11:18 <CelestialLake> mouse07410: It's easier to just add the specific version you want to 'build-depends' field of your project's .cabal file. Not sure why would you want to do the stuff you've described above.
09:22:19 <ski> ph88 : ok
09:35:37 * hackage BiobaseFasta 0.3.0.0 - streaming FASTA parser  https://hackage.haskell.org/package/BiobaseFasta-0.3.0.0 (ChristianHoener)
09:39:25 <mouse07410> CelestialLake: the key is "of YOUR project's .cabal". As I said, this is an attempt to install SOMEBODY ELSE's project, intero in this particular case. And the only way to modify their .cabal is to clone that whole project source - which is what I'd like to avoid. Is this explanation clear, and does it make sense?
09:43:53 <ClaudiusMaximus> mouse07410: cabal install --constraint "network == 2.8.0.0" or similar, not sure of the exact syntax
09:45:48 <dmwit> mouse07410: Uh? intero already lists network as a dependency.
09:46:24 <dmwit> mouse07410: Sounds like something bizarre is going on. Can you include the details of the exact command you're running? Maybe add one level of verbosity to each and include the output?
09:57:30 <__monty__> mouse07410: In principle, you could do this with nix.
10:02:37 <mouse07410> dmwit: yes intero does list network as a dependency - but doesn't state the version boundaries. So, with both network-3.0.1.0 and -2.8.0.0 being present on my machine (hsdev and something else require 3.0.0.0+), the build was getting confused. The exact command was "cabal install intero". As for stack - it simply fails horribly, falling on the libiconv problem.
10:03:23 <sclv> mouse07410: you can pass --constraint "network=etc" to cabal
10:03:51 <sclv> and also --allow-newer can be configured for certain packages, or all packages to bypass constraints that are too tight
10:04:13 <sclv> https://cabal.readthedocs.io/en/latest/installing-packages.html?highlight=constraint#cmdoption-setup-configure-constraint
10:04:42 <mouse07410> ClaudiusMaximus: and sclv: thank you! That command parameter sounds exactly like what I need.
10:04:43 <sclv> https://cabal.readthedocs.io/en/latest/installing-packages.html?highlight=constraint#cmdoption-setup-configure-allow-newer
10:06:00 <Solonarv> my question is: why are you installing intero via <not stack> ? it only works in stack projects anyway!
10:06:57 <mouse07410> sclv: in this case, I'm trying to restrict the constraints for some packages. But to know how to relax constraints for selected packages write be great too.
10:11:38 <mouse07410> Solonarv:  Because, as I already said, stack really sucks when it comes to conflict between the two libiconv.dylib. Some packages (including intero, ghc-paths, and a few others I personally stumbled upon - not an exhaustive list by any means) just plain CANNOT be built by stack in my environment  - fail on the linking phase. Cabal manages. As for "why intero" - only because Intellij Haskell plugin requires it.
10:17:03 <mouse07410> sclv: checked the docs your referred to - cabal rocks!! Thanks!
10:23:12 <Darwin226> Is there a monad transformer that can't have a MFunctor instance?
10:24:29 <Darwin226> Hmm, probably ContT
10:26:22 <Taneb> @djinn (forall b. b -> a) -> a
10:26:22 <lambdabot> -- f cannot be realized.
10:26:26 <mouse07410> Solonarv: I must add that for *my* projects (which at this stage are rather small toy-like experiments) with rather few dependencies - stack respects the config I give it, and builds the stuff ok. Which allows me to use that Haskell Intellij plugin successfully. But big packages that more likely than not use a ton of dependencies - more often than not trigger that linking problem and fail to build. Stack support was of no
10:26:26 <mouse07410> help.
10:26:46 <ski> Djinn doesn't understand higher-rank
10:26:51 <Taneb> Darn
10:26:54 <Solonarv> mouse07410: if stack doesn't work right for you, I'd suggest moving away from it altogether (and using something other than IntelliJ)
10:29:39 <ski> (which is also why it doesn't understand type classes with polymorphic methods, like `RealFrac',`Functor',&c. -- but does understand "monomorphic" classes like `Eq',`Ord',`Floating',&c.)
10:30:00 <mouse07410> Solonarv: alas, that's impossible. I'd happily move away from stack (especially since I think it sucks), but there's no way I'd drop Intellij - it's the best IDE I've ever used so far, and it serves me well for Rust, Ruby, Python, Java, C++. I'm not giving it all up for one lousy component of one semi-lousy ecosystem.
10:32:53 <mouse07410> Forgot to mention that Intellij Haskell plugin in general is fine, as long as they problem I described can be circumvented.
10:33:10 <mouse07410> ^they -> the
10:33:29 <fendor> :t typeOf
10:33:30 <lambdabot> Typeable a => a -> TypeRep
10:33:44 <fendor> > typeOf (error "Ooops.")
10:33:46 <lambdabot>  error:
10:33:46 <lambdabot>      • No instance for (Typeable a0) arising from a use of ‘typeOf’
10:33:46 <lambdabot>      • In the expression: typeOf (error "Ooops.")
10:33:58 <fendor> > show (typeOf (error "Ooops."))
10:34:00 <lambdabot>  error:
10:34:00 <lambdabot>      • No instance for (Typeable a0) arising from a use of ‘typeOf’
10:34:00 <lambdabot>      • In the first argument of ‘show’, namely
10:35:13 <fendor> > show (typeOf (error "Ooops." :: SomeException))
10:35:16 <lambdabot>  "SomeException"
10:35:18 <ski> > typeOf (error "Ooops." :: ())
10:35:20 <lambdabot>  ()
10:35:23 <fendor> dammit
10:35:39 <fendor> Can I get the type of an exception at run-time?
10:36:45 <Solonarv> sure, and typeOf is the right function for it too
10:37:06 <Solonarv> it's just that 'error "foo"' doesn't return an exception
10:37:48 <Solonarv> % evaluate (error "boom") `catch` \(SomeException e) -> print (typeOf e)
10:37:48 <yahb> Solonarv: ErrorCall
10:38:03 <ski> > case error "Ooops." of SomeException e -> typeOf e  -- try something along these lines ?
10:38:05 <lambdabot>  *Exception: Ooops.
10:38:25 <ski> (replacing the `error' call with a proper value of type `SomeException')
10:38:27 <fendor> thats nice, thx! 
10:39:04 <Solonarv> % evaluate (1/0) `catch` \(SomeException e) -> print (typeOf e)
10:39:04 <yahb> Solonarv: ; <interactive>:151:11: error:; * No instance for (Num ()) arising from the literal `1'; * In the first argument of `(/)', namely `1'; In the first argument of `evaluate', namely `(1 / 0)'; In the first argument of `catch', namely `evaluate (1 / 0)'; <interactive>:151:11: error:; * No instance for (Fractional ()) arising from a use of `/'; * In the first argument of `evaluate'
10:39:18 <Solonarv> % evaluate (1/0 :: Double) `catch` \(SomeException e) -> print (typeOf e) >> throwIO e
10:39:18 <yahb> Solonarv: Infinity
10:39:28 <Solonarv> % evaluate (1/0 :: Rational) `catch` \(SomeException e) -> print (typeOf e) >> throwIO e
10:39:28 <yahb> Solonarv: ArithException; *** Exception: Ratio has zero denominator
10:39:56 <fendor> wait, should 1.0/0.0 be positive infinity? Or is the result of 1/0 handled as a double?
10:40:01 <fendor> > 1.0/0.0
10:40:01 <Solonarv> fendor: keep in mind that you really really shouldn't catch SomeException without also rethrowing it
10:40:03 <lambdabot>  Infinity
10:40:14 <merijn> fendor: It's Infinity for Double, yes
10:40:18 <ski> > 1/0 :: Rational
10:40:20 <lambdabot>  *Exception: Ratio has zero denominator
10:40:23 <Solonarv> indeed, that's why my first attempt (with ::Double) didn't fail
10:40:28 <ski> > fix SomeException
10:40:35 <lambdabot>  mueval: ExitFailure 1
10:40:39 <fendor> Solonarv, ideally I'll learn the real exception type and catch only that
10:40:39 <ski> (that's silly, imho)
10:41:21 <fendor> oh, right
10:42:28 <Solonarv> fendor: you can already do that
10:42:42 <fendor> Solonarv, ok, how?
10:42:55 <Solonarv> % evaluate (1/0 :: Rational) `catch` \(e :: ArithException) -> pure 0
10:42:56 <yahb> Solonarv: 0 % 1
10:43:13 <fendor> what kind of exception is "IO SomeException"? 0.o
10:43:32 <Solonarv> catch :: Exception e => IO a -> (e -> IO a) -> IO a
10:43:34 <ski> it's not the type of an exception
10:43:46 <Solonarv> 'e' is the type of exception you want to catch
10:44:08 <fendor> Solonarv, but I dont actually know what my e is?
10:44:21 <merijn> fendor: Use Typeable
10:44:28 <Solonarv> wait, what are you even trying to do? I'm very confused now
10:44:40 <merijn> Solonarv: He's getting an exception, but doesn't know which one
10:44:52 <merijn> Solonarv: So he doesn't know which type he wants to catch yet
10:45:04 <fendor> I have a piece of code, that throws some kind of exception. I want to catch the exception this piece of code throws and ignore it/log it
10:45:28 <merijn> fendor: Exception instance requires Typeable as superclass, so you can use typeable to introspect what type it is at runtime
10:45:46 <Solonarv> if you only know that it's "some exception" and nothing else then that is a terrible idea, because you end up swallowing async exceptions
10:46:46 <merijn> Solonarv: Dude...he wants to figure out what the exception is so he can avoid doing that...
10:47:13 <Solonarv> well if you have some known-ahead-of-time set of exception types you want to catch you can do that with 'catches'
10:47:20 <merijn> fendor: Use typeOf + print
10:47:36 <orion> Hi. Is an API defined via Servant combinators isomorphic to a Free Applicative?
10:47:42 <fendor> Solonarv, i dont know the type of the exception yet, but this my goal
10:47:52 <merijn> Solonarv: He's getting an exception that's not documented, he needs to know what it is before he can do any of the things you keep suggesting
10:48:02 <Solonarv> oooh now I get it, okay
10:48:04 <fendor> merijn, but this seems to throw SomeException?
10:48:12 <gentauro> is there a reason a package is not on `stackage` but on `hackage`? For example `pdf-toolbox` -> https://hoogle.haskell.org/?hoogle=pdf-toolbox
10:48:19 <merijn> fendor: Pattern match on SomeException, typeOf the internals
10:48:25 <fendor> ok, thnks!
10:48:33 <Solonarv> yeah in that case `catch` \(SomeException e) -> print (typeOf e) is fine
10:48:36 <merijn> "\(SomeException e) -> print (typeOf e)"
10:49:04 <fendor> thanks, trying it right now!
10:49:21 <Solonarv> you can even make it safe-to-keep by changing it to \(SomeException e) -> print (typeOf e) >> throwIO e
10:49:30 <Solonarv> (i.e. re-throwing the exception)
10:49:43 <Solonarv> then you definitely won't break anything
10:51:07 <ski> % evaluate (1/0 :: Rational) `catch` \DivideByZero -> pure 0
10:51:07 <yahb> ski: *** Exception: <interactive>:161:36-58: Non-exhaustive patterns in lambda
10:51:28 <ski> % evaluate (1/0 :: Rational) `catch` \RatioZeroDenominator -> pure 0
10:51:28 <yahb> ski: 0 % 1
10:51:45 <ski> % catchBind (evaluate (1/0 :: Rational)) (\(e :: ArithException) -> pure (Left e)) (pure . Right)
10:51:45 <yahb> ski: Left Ratio has zero denominator
10:51:52 <fendor> yeeaaah, IOException!
10:52:03 * ski frowns at `Show' instance
10:52:05 <fendor> to be honest, that was to thanks guys!
10:52:50 <Solonarv> yeah exceptions tend to have wonky Show instances
10:52:59 <fendor> s/to thanks/to be expected, thanks!/
10:53:14 <merijn> Show for IOException is wonky, yes
10:53:36 <merijn> Although exceptions generally don't print Show anyway, they use displayException in the top level handler
10:54:34 <Solonarv> indeed, but 'displayException = show' is the default implementation
10:54:39 <fendor> is it safe to catch IOExceptions for a code block?
10:54:51 <Solonarv> yes
10:55:12 <dminuoso> Solonarv: Even further, it seems that the majority of implementations explicitly picks `displayException = show` too.
10:55:13 <Solonarv> shouldn't break anything
10:55:21 <fendor> thanks!
10:55:27 <dminuoso> fendor: whether it's "safe" kind of depends on what you mean and hope to do.
10:55:45 <dminuoso> fendor: (And what you mean by "safe")
10:56:06 <Solonarv> dminuoso: I was talking earlier about how you really shouldn't catch async exceptions (without re-throwing them)
10:56:08 <fendor> dminuoso, safe in the sense, nothing else might break, except my one code
10:56:20 <fendor> IOExceptions are synced, though?
10:56:25 <fendor> *own
10:57:16 <Solonarv> yeah you should only get an IOException in your thread from something you did
10:57:35 <Solonarv> other threads can throw one at you of course but that's a rather silly thing to do
10:57:42 <fendor> then I think this will work good enough
10:59:16 <ph88> hey guys, i'm trying to upgrade a project to latest lts and i get an error i'm not sure what to do with  No instance for (Control.Monad.Trans.Control.MonadBaseControl) from the use of withResource  in https://github.com/TechEmpower/FrameworkBenchmarks/blob/master/frameworks/Haskell/yesod/yesod-mysql-mongo/src/yesod.hs#L180
11:00:07 * hackage libarchive 1.0.4.0 - Haskell interface to libarchive  https://hackage.haskell.org/package/libarchive-1.0.4.0 (vmchale)
11:10:01 <dminuoso> ph88: Im pretty sure that the error message got modified by you.
11:12:14 <dminuoso> ph88: So can you show us the complete, unchanged error message?
11:12:24 <reallymemorable> Does anyone have insight on this question I posted on SO? https://stackoverflow.com/questions/55383935/saving-contents-of-urls-in-string-to-client-haskell-scalpel-question
11:13:28 <Cale> reallymemorable: I'm not sure I understand the question -- which file name would you like to use? Something corresponding to the name in the URL?
11:13:39 <dminuoso> % :t traverse
11:13:39 <yahb> dminuoso: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
11:13:42 <dminuoso> % :t traverse_
11:13:42 <yahb> dminuoso: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
11:13:46 <reallymemorable> The list of lists contain 10 URLs each
11:13:56 <dminuoso> reallymemorable: ^- these two can be used to encode loops like you want to.
11:13:58 <reallymemorable> so i want to go through each of those chunks
11:14:23 <dminuoso> reallymemorable: Use the `traverse_` variant if you want to discard the result of each "iteration"
11:14:28 <reallymemorable>     contents <- req GET (traverse chunkLinks) NoReqBody bsResponse mempty
11:14:31 <reallymemorable> like that?
11:15:06 <Cale> reallymemorable: forM (concat xss) $ \url -> do
11:15:11 <Cale> like that?
11:15:16 <dminuoso> (note that `forM` is just traverse with flipped arguments)
11:15:26 <Cale> (or forM_)
11:15:36 <dminuoso> Or `for`/`for_` rather?
11:15:51 <reallymemorable> what is xss?
11:15:55 <Cale> your list of lists
11:16:00 <reallymemorable> got it
11:16:09 <ph88> dminuoso, https://bpaste.net/show/4d64d3bb96ee
11:16:11 <Cale> (it's doubly plural)
11:16:30 <Cale> I never really found a reason to use for/for_
11:16:46 <dminuoso> reallymemorable: What is that `Handler` type? Where is it from?
11:17:03 <reallymemorable> so then my next line would be: contents <- req GET xss NoReqBody bsResponse mempty
11:17:09 <dminuoso> Sorry, I meant ph88 ^-
11:17:12 <Cale> reallymemorable: no
11:17:20 <dminuoso> reallymemorable: No. Think of `for_` as just encoding a loop.
11:17:35 <Cale> You're binding each of the urls to the variable url
11:17:41 <reallymemorable> oh
11:17:48 <dminuoso> reallymemorable: for_ ["http://...", "http://..."] $ \url -> do ... here goes body of the loop
11:17:51 <reallymemorable> contents <- req GET url NoReqBody bsResponse mempty
11:17:54 <Cale> yeah
11:18:00 <ph88> dminuoso, i don't know much about this code base. I use hoogle for a few things and got https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Exception.html#t:Handler https://hackage.haskell.org/package/resource-pool-0.2.3.2/docs/Data-Pool.html https://hackage.haskell.org/package/monad-control-1.0.0.1/docs/Control-Monad-Trans-Control.html#t:MonadBaseControl
11:18:13 <Cale> and then you need to work out what filename you want to write to based on the url, I suppose
11:18:19 <reallymemorable> yeah
11:18:21 <ph88> it's some exception / control mechanism what has changed since lts 6.3 ...
11:18:30 <reallymemorable> i could just use the url again
11:18:35 <reallymemorable> so the filename would be the url
11:18:39 <dminuoso> ph88: The funky think here is, if this is servant's Handler then there should be a `MonadBaseControl IO Handler` instance.
11:18:40 <ski> Cale : would you only use `for'/`for_' if you're in an idiom that's not a monad (and where you want a custom body) ?
11:18:42 <Cale> sure
11:18:42 <reallymemorable> it would be messy but i can  clean that up clientside
11:18:48 <Cale> ski: yeah
11:19:12 <Cale> ski: Somehow in those Applicatives which are not Monads, I rarely find cause to iterate like that.
11:19:15 <dminuoso> ph88: So either you are using an old version of servant where, presumably, this instance did not exist, or there's something Im not seeing.
11:19:23 <Cale> (but it might come up someday)
11:19:24 * ski suspected something like that, yes
11:19:37 <reallymemorable> thanks everyone
11:19:39 <reallymemorable> super helpful
11:19:44 * dminuoso prefers to not use forM* at all
11:19:47 <delYsid> How do I divide an Integer by a NominalDiffTime?
11:20:03 <Cale> I only use Applicative stuff if I actually need it.
11:20:13 <Cale> delYsid: fromIntegral
11:20:13 <dminuoso> delYsid: what should the semantics of that be?
11:20:19 <Cale> (in one direction or the other)
11:20:21 <dminuoso> delYsid: How do you divide an Integer by a "time difference"?
11:20:53 <delYsid> divide by seconds, but do not round to seconds.
11:21:07 <Cale> also, maybe realToFrac on the NominalDiffTime?
11:21:14 <Cale> You probably don't want a NominalDiffTime result
11:21:34 <Cale> So you're probably converting the Integer to a Double or something
11:21:39 <delYsid> tdiv :: Integer -> NominalDiffTime -> Integer
11:21:59 <Cale> What kind of division do you want?
11:22:12 <dminuoso> delYsid: nominalDiffTimeToSeconds?
11:22:13 <Cale> Integer division with a remainder?
11:22:19 <Cale> Or (/)
11:22:35 <ski> hmm .. is there a standard notation for the free (commutative) monoid on a set (and for its inhabitants) ?
11:22:36 <delYsid> I have a number of events occuring in a certain time, and I want the rate per seconds.
11:22:37 <Cale> fromIntegral and realToFrac will treat NominalDiffTime as seconds
11:22:55 <dminuoso> ski: By what logic did you put the `commutative` into parens?
11:22:59 <Cale> So yeah, you probably want to convert your Integer to some fractional type like Double
11:23:06 <Cale> and your NominalDiffTime as well
11:23:08 <dminuoso> Is that an "optional" or "implied"?
11:23:36 <Cale> ski: In mathematics?
11:24:51 <dminuoso> ph88: Yeah my assumption is that your dependency on servant is too old.
11:25:15 <dminuoso> ph88: So either bump your servant dependency or bite the sour apple and write an orphan instance for MonadBaseControl IO Handler.
11:25:32 <ski> Cale : yes
11:26:01 <delYsid> the number typeclasses confuse me
11:26:15 <lyxia> I would denote a free monoid with a Kleene star.
11:26:25 <lyxia> not sure about commutative
11:26:42 <lyxia> but in both cases the elements can be written as words (finite sequences)
11:26:44 <dminuoso> delYsid: http://academic.udayton.edu/saverioperugini/courses/cps343/lecture_notes/images/typeclass.png
11:26:56 <ski> Cale : if the set is `X', then i was pondering using `Pi_x x^alpha' for inhabitants (where each `alpha' is a natural number depending on `x', which is an inhabitant of `X')
11:27:07 <Cale> ski: If it was not commutative, given the set A, people write A* for the free monoid on A. For the free commutative monoid, you're probably more likely to see N[A], where N would be written blackboard bold.
11:27:11 <delYsid> dminuoso: Sorry, I am blind, images dont help me the least.
11:27:21 <Cale> That's also notation for the monoid ring.
11:27:21 <ski> i suppose one could also consider `Sigma_x alpha*x', if one wants additive notation (since it's after all, commutative)
11:27:34 <dminuoso> delYsid: Ah. Would an ASCII imitation help?
11:27:52 <ski> Cale : yea, i'm pondering monoid rings atm
11:27:58 <delYsid> dminuoso: I can read ASCII diagrams, at least some, yeah.
11:28:10 <lyxia> sigma looks pretty good to me.
11:28:15 <dminuoso> delYsid: Ill transcribe it for you then.
11:29:10 <ski> Cale : i think i've seen `R^(X)' for free `R'-vector space (or `R'-module, `R' being commutative) over the set `X'. would `|N^(X)' be too weird for free commutative monoid ?
11:30:38 <ski> Cale : so, a polynomial ring with scalars/coefficients `R', over unknowns `X', would be `R[|N[X]]', with that notation ?
11:31:12 <Cale> That's also reasonable.
11:31:25 <dminuoso> delYsid: Any particular tips what make ASCII diagrams readable for you?
11:31:32 <Cale> er wait
11:31:41 <ski> lyxia : yeah, commutative, because i'm thinking about polynomials, where, afaik, one typically assumes the unknowns commute with each other, and with the scalars/coefficients (perhaps the base ring doesn't need to be commutative itself, not sure)
11:31:48 <Cale> You could just write R[X] in that case
11:32:11 <ski> Cale : yes, but considering it as an instance of a monoid ring, over a free (commutative) monoid on a set
11:32:21 <Cale> okay, then yeah
11:32:45 <ski> what do you think about `R^(X)' and `|N^(X)' ?
11:33:02 <Cale> Just being aware that the commutative monoid operation will not interact at all with your ring operations
11:33:42 <ski> well, for multiplication, don't you get something convolutiony ?
11:33:53 <delYsid> dminuoso: I guess I better walk my way through hackage, I am really not sure if your work will actually end up being helpful to me.  Some diagrams work for me, some just confuse me :-)
11:34:18 <Cale> Oh, I suppose it's all a bit funny -- have to be careful about what the brackets mean
11:34:32 <dminuoso> delYsid: The thing is there is this lattice of typeclasses. But perhaps I could phrase it into words for you?
11:35:06 <Cale> There's some inherent ambiguity when you write R[N[X]] whether that's the polynomial ring with indeterminates in the *set* N[X]
11:35:27 <Cale> have to be careful about which adjoint you're taking :D
11:35:35 <ski> i tend to think of "function with finite support" as "array" in some rough sense. one important point is that we get covariant, not contravariant, in the "index"
11:36:13 <ski> Cale : yea, that's one reason i was looking for something else than `R[...]', if possible
11:38:24 <dminuoso> delYsid: https://gist.github.com/dminuoso/3e01669d0986ec0b97cfaf253d8f4a42
11:38:24 <Cale> But it's true, people do use that notation for the monoid ring. Some clarifying text around it should make it easier to understand what object it is that you're after.
11:38:49 <ski> Cale : btw, i was also ponderin attempting to extend monoid ring to something formal-power-seriesy .. iow, we allow infinite sums of scaled monoid elements. but since we only have finite sums in the ring, we'll have to require each monoid element only factoring (in two factors), in finitely many ways, iiuc
11:39:10 <Cale> yeah
11:39:27 <ski> Cale : that notation being the `R[|N[X]]' one, or something like `R^(|N^(X))' ?
11:39:46 <Cale> If you want to generalise all this you can talk about two different constructions of a category algebra :)
11:39:49 <delYsid> Ahh, I guess what I want is floor (realToFrac (fromIntegral n) / realToFrac  (diffUTCTime e s))
11:40:06 <ski> Cale : a category algebra being ?
11:40:11 <Cale> ah, usually people use double brackets for the power-series thing
11:41:41 * ski isn't really fond of using "algebra" for specific structures (like a monoid in the monoidal category of vector spaces)
11:41:59 <Cale> Given a ring R and a category C, we can construct R[C] to be the free R-module with basis the arrows of C, together with a multiplication defined effectively by convolution, with the product of non-composable arrows being 0
11:42:24 <Cale> Yeah, I would prefer to say "category ring", but people do seem to use the word "algebra" more here.
11:42:28 <ski> oh, yes. i suppose i wasn't really asking about formal-power-series notation. that's just something i was thinking about, related to all this
11:43:14 <ski> and `R[C]' is a ring, then ?
11:43:23 <ski> hm, `R'-module, you said
11:43:46 <ski> or can one make it into a ring, using that multiplication (like for monoid/group rings, iiuc) ?
11:43:52 <Cale> It's an R-module which we extend to a ring by defining multiplication, yeah
11:43:58 * ski nods
11:44:22 <Cale> We define the product of two arrows to be their composite if it exists, and 0 otherwise, extended linearly over the whole module
11:44:29 <__monty__> Wow, GHCi can handle some large literals.
11:44:45 <ski> "if it exists" meaning if they're composable ?
11:44:48 <Cale> Yeah
11:45:02 <ski> what happens with the objects of the category ?
11:45:15 <dminuoso> delYsid: Does that lattice I described make any sense to you?
11:45:29 <Cale> Well, we're taking formal R-linear combinations of arrows
11:45:31 * ski has a vague memory of letting a category act on a structure, rather than a group or a monoid acting
11:45:41 <Cale> the objects only help us to know whether arrows are composable
11:46:27 <ski> so one couldn't view this as getting a collection of rings, one for each pair of objects ?
11:46:29 <Cale> Now, if C is a one-object category, this is the same thing as the monoid ring (of which a special case is the polynomial ring, when you pick the natural numbers)
11:46:39 <ski> (yes, of couse)
11:47:08 <Cale> If C is the discrete category on a set X, then this is the product of X-many copies of R.
11:47:56 <Cale> If C is the indiscrete category on a (finite) set X, this is the matrix ring of |X|-by-|X| matrices with coefficients in R.
11:48:22 <Cale> If C is a partially ordered set, then this is what's known as an incidence algebra
11:48:46 <ski> (i was recently taking a peek at graded ring/module, and wondering why they had an infinite direct sum, such that multiplication corresponds to adding the indices, rather than simply have collection indexed by that index set)
11:49:29 <Cale> The path algebra of a quiver is also a special case of this construction, by taking the free category on the quiver.
11:50:06 <ski> (i'm not familiar with "quiver", nor "incidence algebra")
11:50:13 <Cale> and then if the category is "locally finite" or has finite factorisation
11:50:52 <Cale> we can define R[[C]] in a similar way, but starting from maps Arr(C) -> R instead of the free R-module (which would only consist of such functions with finite support)
11:51:49 <Cale> and then since each arrow factors in only finitely many ways, we can define (f * g)(a) = sum over a = b . c of f(b) g(c)
11:51:52 * ski is still wondering about defining a collection of rings, indexed by pairs of objects, instead
11:51:56 * ski nods
11:52:18 <Cale> and that gets you all the "power series like" constructions
11:52:35 <ski> "all", in what sense ?
11:52:53 <Cale> Well, "all" in the sense of corresponding to the previous examples
11:53:33 <Cale> So the ordinary power series ring is obtained by regarding the natural numbers as a one-object category for a monoid, and then taking R[[N]]
11:53:55 <ski> hm, ok
11:54:10 <Cale> and you get a power-series-like construction for other monoids or groups similarly
11:55:07 * hackage cpkg 0.1.1.1 - Build tool for C  https://hackage.haskell.org/package/cpkg-0.1.1.1 (vmchale)
11:55:23 <ski> did you have any notation suggestion for the inhabitants of the free (commutative) ring. did my `Pi_x x^alpha' sound ok ? .. i was also (previously) considering `<alpha>_x', but then that doesn't as clearly indicate the finite support, i think
11:57:31 * ski was pondering how to prove equivalence between `R[|N[X]]' and `forall S | R >---> S. S ^ (X >--->_Set | S |)'
11:57:55 <reallymemorable> I'm trying to test a URL splitter so I can grab the filename out of the path, but it's reading the final string here as [Char] rather than Text.  How can I get the compiler to see it as Text? 
11:57:59 <reallymemorable> splitOn "/" "http://www.google.com/test/url.csv"
11:58:19 <Cale> Perhaps turn on OverloadedStrings
11:58:30 <Cale> If you're in ghci already, you can :set -XOverloadedStrings
11:58:33 <reallymemorable> ah
11:58:34 <reallymemorable> yep
11:58:35 <reallymemorable> that did it
11:58:37 <reallymemorable> thanks again
11:59:04 <Cale> ski: I'm not sure how to make sense of that bit of notation.
11:59:20 <ski> it's probably an end of some sort
11:59:40 <Cale> ski: Regarding the elements as sums of monomials is probably most standard.
12:00:50 <ski> the idea is that to apply a polynomial with scalars in `R' and unknowns in `X', we pick some (commutative) ring `S', and a way to translate from `R' to `S'. then, given a valuation/environment which says which value in `S' each unknown in `X' will be interpreted as, we should get back a result in `S'
12:01:16 <Cale> ah, sure
12:01:24 <ski> (the translation from `R' to `S' should be a ring homomorphism, of course. i forgot to add `_CRing' to that arrow)
12:01:59 <ski> while `R[|N[X]]' would here be the sums-of-monomials thing
12:02:39 <ski> the other would, i think, be what's required (more or less) to show that the former is actually the *free* ring-over-`R', on the set `X' ?
12:03:00 <ski> (or is that s/over/under/ ? i can never keep track of which is which)
12:04:16 <ski> (`S ^ (X >--->_Set | S |)' is the `X >--->_Set | S |'-fold (constant) product of `S's. sometimes called a "power", i think)
12:06:21 <ski> Cale : does that make any sense to you ?
12:07:40 <Cale> yeah, this is basically going to reduce to the commutative polynomial ring with indeterminates in X
12:09:16 <ski> in one direction, we just substitute and reinterpret the "formal" operations, as operations in `S', inserting the translation from `R' for the coefficients, and interpreting the indeterminates (sorry, i was missing that word) as per the valuation
12:10:05 <ski> in the other direction, i think we could take derivatives (but where ? "formal derivatives" over polynomials, or something else), to recover the coefficients
12:10:17 <ski> (but perhaps there's another way to do it ?)
12:10:39 <__monty__> When you accidentally try to generate a 2 EB file.
12:11:33 <ski> (and then the next step would be to generalize from the free (commutative) monoid over `X', to any old (commutative) monoid, with some restrictions on the valuation, probably)
12:12:15 <delYsid> dminuoso: Thanks!  That is a pretty helpful summary.
12:12:31 <int-e> __monty__: hah. how far did you get? :)
12:13:33 <delYsid> wow, I get 46M nps on a 20 core machine with my simple chess move generation library.  Impressive, I really wouldn't have thought haskell can be that fast.
12:14:01 <delYsid> https://github.com/mlang/chessIO
12:14:17 <ski> dminuoso : sorry, missed your question. well, saying "commutative monoid" might suggest that i'm thinking about it "additively", wanting an "additive" notation. but i wanted a "multiplicative" notation (while multiplication in the ring is still commutative)
12:14:33 <__monty__> int-e: I realized about 2GB in. Thank god I don't have access to serious resources : )
12:15:01 <delYsid> Real chess programs have about 20M nps on the same machine, although they do *a lot* more stuff like evaluating a position to a score.
12:15:21 <ski> a free commutative monoid over a set is basically a multi-set / bag with elements drawn from that set
12:15:39 <ski> (hm, is there a notion of multi-set, where you can have infinite multiplicity ?)
12:16:03 <kadoban> ski: Yes
12:16:33 <phadej> data Multiplicity = Finite Natural | Infinite
12:16:35 <ski> when is that used/studied ?
12:16:53 <flebron_> Hi folks. Say I have a f :: State -> Input -> (State, Output). Is there a pattern for feeding [Input] to f repeatedly, collecting Output, updating the State each time?
12:17:33 <flebron_> (It's a couple lines, but if there was an existing pattern, so much the better :))
12:17:56 <Cale> flebron_: Start by using the State monad, so that becomes a function  Input -> State MyState Output
12:18:13 <ski> (s;is basically a multi-set / bag;consists basically of multi-sets / bags;)
12:18:31 <Cale> and then you can use foldM, for example, or just write the loop straightforwardly
12:18:32 <ski> (in that case, the free commutative monoid consists only of multi-set with only finite multiplicities of elements)
12:18:44 <flebron_> Righto. And is there a "Feed input repeatedly" known thing for State?
12:18:56 <flebron_> Ah I see
12:19:08 <ski> @type mapAccumL
12:19:09 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
12:19:12 <ski> @type mapAccumR
12:19:13 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
12:19:16 <kadoban> ski: I came across it in combinatorics, where you're picking items from a multiset and can pick an infinite number of some, but a possibly finite number of others.
12:19:40 <flebron_> Well, foldM would only give me the last State, not the intermediate Outputs, no?
12:20:15 <Cale> flebron_: You could make the fold do that...
12:20:17 <ski> @type \f -> runState . mapM (state . f)
12:20:18 <lambdabot> Traversable t => (a -> s -> (b, s)) -> t a -> s -> (t b, s)
12:20:24 <ski> flebron_ ^
12:20:39 <Cale> ah, yeah, mapM might be all you want
12:21:43 <ski> that last is the same as `mapAccumL' (modulo a couple of `flip's)
12:22:05 <ski> kadoban : interesting, ty
12:22:11 <flebron_> Thanks!
12:22:54 <ski> flebron_ : depending, it might be clearer to just use `mapAccumL' (or `mapAccumR', if that's what you want), rather than `mapM'/`traverse' on `State'
12:24:33 <dmwit> :t mapM
12:24:34 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
12:24:50 <dmwit> (I disagree with the recommendations to look at foldM.)
12:24:55 <ski> phadej : well, presumably one might want to allow different infinities :)
12:25:09 <Cale> Yeah, that was just momentary confusion / distractedness on my part
12:25:16 <dmwit> Oh, I've been beaten even to that observation.
12:25:29 <dmwit> I really do need to learn to finish reading before wailing on.
12:25:47 <kadoban> ski: Hehe, maybe. data Mult = Finite | Aleph Int
12:25:51 <Cale> I wasn't thinking hard about what "collecting Output" meant
12:26:15 <ski> kadoban : heh, what's `Aleph (-1)' ;) ?
12:26:18 <Cale> If you wanted to do something other than obtaining your output in a list, then foldM might do
12:26:22 <flebron_> (I was pretty unclear about that too :))
12:26:40 <kadoban> ski: :( nothing good
12:26:44 <dminuoso> % :t foldM
12:26:44 <yahb> dminuoso: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
12:26:56 <dminuoso> % :t traverse
12:26:57 <yahb> dminuoso: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
12:28:08 <Squarism> noone know of a of Interface Description Language (IDL) that supports functional constructs like union types and type constructors? Seems theres a ton (protobuffers, thrift, wsdl, and more) but all seems happy with simple object oriented type systems. 
12:28:35 <Cale> Haskell's type system
12:28:43 <Cale> :D
12:28:46 * ski isn't sure how union types would be considered to be typically functional
12:28:55 <Cale> discriminated union types
12:29:01 <Cale> i.e. sum types
12:29:09 * ski misses sum types in relational data bases :/
12:29:17 <ski> (i saw some paper about that, iirc)
12:29:18 <Squarism> yeah i guess sum types
12:29:22 <Cale> There's nothing especially functional about them, it's just that non-FP languages always forget to implement them.
12:30:01 <Cale> (typically because the people who design those languages just haven't followed the last 30-40 years of programming language research)
12:30:20 <ski> partly i think "everything is an object" and "don't hardcode a dispatch" in OO is to blame
12:30:57 <ski> (but non-OO languages also don't tend to incorporate sum types. at least Pascal and Ada has variant records)
12:32:16 <Squarism> sum types or just Either a b would be great for RPC 
12:32:32 <Cale> ski: I not only miss sum types in databases, but now I'm starting to wish I had dependent telescopes
12:33:01 <Cale> I want the values of previous columns to determine the types of later columns :D
12:33:11 <flebron_> Is there a nice (a -> b) -> (z, a) -> (b, a)? i.e. discard first, and apply f to a to get b, which becomes first.
12:33:20 <Cale> (but yeah, just having sums would be awesome)
12:33:45 <Cale> flebron_: n... no
12:33:59 <Cale> :t bimap
12:34:00 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
12:34:01 <flebron_> Haha
12:34:13 <Cale> That is the closest thing you're going to get
12:34:31 <flebron_> I guess that's 1) Drop the first, then triangle, then apply f on first.
12:34:32 <Cale> and it's not terribly close
12:34:48 <flebron_> (Triangle? Diagonal? I forget the standard name for a -> (a, a))
12:34:53 <Cale> I would just write the lambda
12:34:59 <flebron_> Fair enough :)
12:35:00 <Cale> Lambda exists for a reason
12:35:55 <dmwit> :t \f -> (f&&&id) . snd
12:35:56 <lambdabot> (b -> c) -> (a, b) -> (c, b)
12:37:29 <ski> i think i had "Modelling Large Datasets Using Algebraic Datatypes: A Case Study of the CONFMAN Database" in 2002-05-15 at <http://www.ofai.at/cgi-bin/get-tr?paper=oefai-tr-2002-27.pdf>,"Using Algebraic Datatypes as Uniform Representation for Structured Data" in 2003 at <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.13.5712>, both by Markus Mottl, in mind
12:38:20 <dmwit> > (length "\\f -> (f&&&id) . snd", length "\\f (_,x) -> (f x, x)")
12:38:22 <lambdabot>  (20,20)
12:39:01 <dmwit> I know which one *I* think is more readable. =)
12:39:17 <ski> `id &&& f' aka `graph f' (and `cograph f' is `f ||| id')
12:40:20 <flebron_> The context is I've started doing Haskell professionally after only ever playing with it, so I want to see what is considered Decent Style(tm) and what's just abuse :)
12:40:25 <ski> > length "(. snd) . (&&& id)"  -- why settle for the lesser evil ?
12:40:28 <lambdabot>  18
12:42:55 <ski> (the pointful one is merely one character longer, though five tokens longer)
12:43:37 <dmwit> flebron_: Anything but the lambda is flagrant abuse in a professional setting.
12:45:40 <ski> (and diagonal would be one common name for it, yes)
12:46:09 <ski> (would a codiagonal be like `Either a a -> a' (or `(Bool,a) -> a'), then ?)
12:46:36 <flebron_> Ah yeah. The name is "diagonal", but the symbol is \Delta, so it looks like a triangle in my head :)
12:47:03 <ski> ah, ok
12:47:07 * hackage morley 0.1.0.0 - Developer tools for the Michelson Language  https://hackage.haskell.org/package/morley-0.1.0.0 (gromak)
12:48:53 <dmwit> ski: yep
12:49:22 <dmwit> :t (|||id)
12:49:23 <lambdabot> (b -> c) -> Either b c -> c
12:49:47 <dmwit> odd
12:50:51 <ski> either you have the result already (cached, say), or you need to convert the input
12:51:34 <jle`> > listens negate (1,2)
12:51:36 <lambdabot>  error:
12:51:36 <lambdabot>      • No instance for (MonadWriter Integer ((,) Integer))
12:51:36 <lambdabot>          arising from a use of ‘e_112’
12:51:44 <ski> a table, associating possible inputs of a function with corresponding outputs, can be thought of as a cograph (an equivalence relation over the sum of the domain and the codomain)
12:51:46 <manjaroi3__> hi! can somebody help me with an exercise for my functional programming class?
12:51:56 <jle`> > listens reverse ("hello", "goodbye")
12:51:58 <lambdabot>  error:
12:51:58 <lambdabot>      • No instance for (MonadWriter [()] ((,) [Char]))
12:51:59 <lambdabot>          arising from a use of ‘e_1’
12:52:01 <jle`> :'(
12:52:04 <ski> @type listens
12:52:05 <lambdabot> MonadWriter w m => (w -> b) -> m a -> m (a, b)
12:52:17 <jle`> manjaroi3__: sure, just ask your question :)
12:54:04 <jle`> the docs seem to mention that the instance has existed since ghc 8.0
12:54:22 <jle`> % listens reverse ("hello", "goodbye")
12:54:22 <yahb> jle`: ; <interactive>:168:1: error:; * No instance for (MonadWriter [()] ((,) [Char])) arising from a use of `it'; * In the first argument of `print', namely `it'; In a stmt of an interactive GHCi command: print it
12:54:43 <manjaroi3__> right, thanks in advance. i need to write a function that, given an integer and a list of integers, it pops out a list with the integers that, if summed gives the given integer 
12:54:45 <manjaroi3__> for example
12:55:05 <manjaroi3__> if i give 25 [5,10,10,3,4]
12:55:19 <manjaroi3__> the output woud be [5,10,10] because 25 = 5+10+10
12:55:24 <jle`> ah, the ol' knapsack problem
12:55:38 <manjaroi3__> how can i approach this?
12:55:56 <ski> @let instance Monoid w => MonadWriter w ((,) w) where tell w = (w,()); listen (w,a) = (w,(a,w)); pass (w,(a,f)) = (f w,a)
12:55:57 <lambdabot>  Defined.
12:56:02 <ski> > listens reverse ("hello","goodbye")
12:56:04 <lambdabot>  ("hello",("goodbye","olleh"))
12:56:09 <ski> > listens (Sum . negate . getSum) (Sum 1,2)
12:56:11 <lambdabot>  (Sum {getSum = 1},(2,Sum {getSum = -1}))
12:56:25 <jle`> manjaroi3__: given the context, i think the professor is looking for something where you make a list out of all "combinations" of the items in the list
12:56:44 <jle`> manjaroi3__: and then use find or filter to find the first combination that gives the right sum
12:57:02 <jle`> if i were to approach this in a haskelly manner, knowing that the number of items in the list is reasonably small
12:57:39 <jle`> hm, what level is the course at, currently? is this near the beginning, middle, or end
12:58:09 <jle`> 🎿 ah, so definitely not what i was thinking
12:58:50 <manjaroi3__> well this is an exercise for the first exam which covers eveyrthing from the beginning to higher-rank functions (not inclusive) so it is pretty basic stuff
12:59:12 <jle`> do you understand the approach I mentioned, though?
12:59:36 <jle`> the tricky thing will be generating that list of combinations, which there are many different ways to do depending on what level of haskell the class might be at
12:59:41 <manjaroi3__> yes i do . 
12:59:54 * ski suspects s/higher-rank/higher-order/
13:00:00 <manjaroi3__> yup. i'm scratching my head a bit on how to generate the list of combinations 
13:00:15 <jle`> hm, one basic way i can think of would be to use explicit recursion
13:00:15 <ski> it can be done recursively
13:00:24 <jle`> this can be done inductively
13:00:32 <jle`> listOfCombos :: [a] -> [[a]]
13:00:37 <jle`> listOfCombos [] = ????
13:00:43 <jle`> listOfCombos (x:xs) = ????
13:00:49 <ski> if you have the list of combinations of the *tail* of the input list, how can you from that get to the list of combinations of the full list ?
13:02:06 <jle`> at this basic level, for a lot of list functions you write (map, foldr, filter, find, etc.) you can just basically start out using that template
13:02:14 <jle`> "what to do with []?" and "what to do with (x:xs)?"
13:02:27 <ski> "learning to think recursively"
13:03:16 <jle`> after writing enough of these you start to see common similarities between a lot of such functions, and then you can think about refactoring them using higher order functions, instead, which capture common patterns
13:03:31 <jle`> but writing the explicit version first can be a good way to guide your thought
13:04:10 <manjaroi3__> alright, i think you gave me enough hints to start digging this up 
13:04:14 <manjaroi3__> thank you very much! 
13:04:22 <ddellacosta> there is also ye olde filterM trick but not sure that's useful at this point 
13:04:49 <ddellacosta> > filterM (const [True, False]) [1,2,3]
13:04:50 <monochrom> Yeah I'm totally doing this to my students in my exam.  "Write a recursive function for this.  Hint: What's the difference between foo xs and foo (x:xs)?  Part (b): foo can also be implemented as a foldr!"
13:04:51 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
13:06:50 <monochrom> Also in my lecture I advocate and show "write the induction proof skeleton first.  Then filling in the blanks helps you write code.  Oh you also get a complete correctness proof along the way.  Buy 1 get 1 free, why don't people don't this?"
13:19:37 * hackage morley-prelude 0.1.0.0 - A custom prelude used in Morley  https://hackage.haskell.org/package/morley-prelude-0.1.0.0 (gromak)
13:20:37 * hackage libarchive 1.0.5.0 - Haskell interface to libarchive  https://hackage.haskell.org/package/libarchive-1.0.5.0 (vmchale)
13:29:32 <oliver_> if i define a funtion like this f x = [x,x,x] what is the correct type definition?
13:29:55 <oliver_> i tried Float -> Float -> Float -> Float -> [] but it doesnt work
13:30:07 <jle`> oliver_: there is more than one correct type you can give to it
13:30:17 <jle`> but all of them are of the form `a -> [a]`
13:30:25 <jle`> so `Float -> [Float]` would be valid
13:30:46 <jle`> it takes a single value (x) of type 'a' and returns a list of values of type 'a'
13:31:25 <oliver_> wegberechnung :: Float -> [Float]
13:31:27 <oliver_> wegberechnungen geschwindigkeit = [reaktionsweg geschwindigkeit, bremsweg geschwindigkeit, anhalteweg geschwindigkeit]
13:31:33 <oliver_> it doesnt compile
13:31:58 <oliver_> The type signature for ‘wegberechnung’
13:32:00 <oliver_>       lacks an accompanying binding
13:32:37 <oliver_> reaktionsweg, bremsweg and anhalteweg are other funktions
13:32:45 <monochrom> Put the two lines in a file and load the file.  Don't enter directly by hand.
13:33:15 <monochrom> If you enter by hand, two separate lines are considered unrelated.
13:33:43 <monochrom> Also using an editor and a file actually scales.  You can always revise.
13:34:40 <oliver_> which editor?
13:36:06 <monochrom> Any editor you like.
13:36:08 <oliver_> may i send anyone my code ?
13:36:28 <monochrom> Put it on a paste bin on the web. Post the URL.
13:36:32 <oliver_> i use kate on kde
13:37:14 <oliver_> paste bin???
13:38:13 <monochrom> Do you know how to use Google to ask about paste bins?
13:38:36 <oliver_> i try
13:41:07 * hackage hoogle 5.0.17.6 - Haskell API Search  https://hackage.haskell.org/package/hoogle-5.0.17.6 (NeilMitchell)
13:41:14 <CelestialLake> oliver_: I hope you're not trolling... So, look closer: your type signature describes 
13:41:31 <oliver_> https://pastebin.com/xxkkZEss
13:41:33 <CelestialLake> "wegberechnung"
13:41:58 <CelestialLake> While your binding binds to other name
13:42:12 <CelestialLake> "wegberechnungen"
13:42:29 <ski> monochrom : induction proof of what ?
13:42:36 <CelestialLake> Remove "en", go to next similar error, voila.
13:43:10 <oliver_> omg sorry iam so stupid
13:43:20 <CelestialLake> np
13:43:43 <monochrom> ski: induction proof for the recursive function to be written.
13:44:01 <CelestialLake> So the error basically says that there's such signature but no such binding. That's all.
13:46:01 <ski> monochrom : yes, but of which property of the recursive function ? of it being equivalent to some (possibly more informal) specification ?
13:46:16 <monochrom> Yes.
13:46:44 <ski> oliver_ : note that you can call `wegberechnung' later, to avoid having to repeat code
13:47:01 <ski> ok
13:48:26 <oliver_> ski : dont understand
13:48:27 <CelestialLake> Also it's easier to do something like `map ($ geschwhatever) [func1, func2, func3]` since they have the same type.
13:48:56 <ski> oliver_ : look at your definition of `tripel', it's basically a repetition of the body of `wegberechnung'
13:49:07 <CelestialLake> Which is (Float -> Float)
13:50:00 <oliver_> the def of tripel is only for me to understand that i can do it step by step
13:50:07 * hackage morley 0.1.0.1 - Developer tools for the Michelson Language  https://hackage.haskell.org/package/morley-0.1.0.1 (gromak)
13:50:41 <oliver_> tripel and print tripel should be out commented
13:50:46 <ski> oliver_ : also, instead of using `all' (and then `read') in `parseString' (which still doesn't exactly capture the non-error cases, try e.g. `"1..2..3"' as input), you could use `reads', check if the result is of the form `[(n,"")]', in that case your number is `n'
13:51:04 <ski> oliver_ : oh, ok
13:51:35 <oliver_> thx a lot u r very helpful!!
13:51:53 <phadej> :t readMaybe
13:51:54 <lambdabot> error: Variable not in scope: readMaybe
13:51:59 <phadej> :m Text.Read.readMaybe
13:52:04 <phadej> :t Text.Read.readMaybe
13:52:05 <lambdabot> Read a => String -> Maybe a
13:52:29 <phadej> > traverse readMaybe ["1", "2", "3"] :: Maybe [Int]
13:52:31 <lambdabot>  error:
13:52:31 <lambdabot>      Variable not in scope: readMaybe :: [Char] -> Maybe Int
13:52:36 <phadej> > traverse Text.Read.readMaybe ["1", "2", "3"] :: Maybe [Int]
13:52:38 <lambdabot>  error:
13:52:38 <lambdabot>      Not in scope: ‘Text.Read.readMaybe’
13:52:38 <lambdabot>      No module named ‘Text.Read’ is imported.
13:52:44 <phadej> :(
13:52:46 <dmwit> :(
13:53:20 <Solonarv> @let import Text.Read
13:53:21 <lambdabot>  Defined.
13:53:23 <dmwit> % traverse readMaybe ["1","2","3"] :: Maybe [Int]
13:53:23 <yahb> dmwit: Just [1,2,3]
13:53:44 <phadej> dmwit: thanks! 
13:53:55 <phadej> I never remember yahb is here
14:06:30 <mpickering> Is there a function in Data.Map which is a generalised lookup
14:06:42 <mpickering> so I can give a function (k -> Bool) which decides whether a key matches or not
14:06:56 <mpickering> I want `k = [a]` and `x `elem`` to be the function
14:07:12 <Solonarv> I'm not aware of one, and it doesn't make much sense to have one since it would devolve to a linear search
14:07:58 <mpickering> Do you have an idea for a data structure which I could use here?
14:08:45 <Solonarv> if your keys can be sets instead of lists then perhaps some sort of trie would work
14:09:26 <mpickering> the precise problem is I have a set of paths which map to a value
14:09:41 <mpickering> so given a path, I want to lookup the value associated with it
14:11:09 <pie_> sounds like a trie...
14:11:34 <dmwit> I mean, you can just insert all the paths.
14:11:46 <dmwit> If I'm reading this right.
14:12:13 <Solonarv> so you have something like 'Map (Set Path) Value' ? yeah, I'd just "explode" that to 'Map Path Value'
14:12:23 <dmwit> But I'll admit I'm more than unusually uncertain about what you're asking for.
14:14:52 <mpickering> I am a bit nervous about duplicating the values though
14:15:14 <mpickering> perhaps that's fine actually 
14:15:50 <mpickering> duplicating in the sense that updating a key will mean they get out of sync
14:15:53 <mpickering> not in terms of memory usage
14:16:28 <mpickering> I'll just do that then and see if it works
14:23:33 <ph88> dminuoso, it's a yesod project, not sure what servant has to do with it
14:24:09 <ph88> dminuoso, i'm using a new version of yesod but the code is writing against an old version. i want to upgrade that code
14:26:28 <Solonarv> ph88: ah! in that case you probably have some call to 'bracket' or 'finally' or whatever involving a Handler, using the functions from lifted-base?
14:27:26 <dmwit> mpickering: You could `Map Path (Value, Set Path)` and write an update function wrapper which updates all the keys in the set it finds.
14:27:31 <ph88> Solonarv, perhaps   "withResource" ?
14:27:53 <Solonarv> I don't actually know that function
14:28:01 <dmwit> mpickering: ...it does seem a bit ugly, though.
14:28:03 * dmwit ponders
14:28:32 <ph88> Not sure if you saw this earlier, but i was talking about upgrading this code to work with lts-13.14 instead of lts-6.2 https://github.com/TechEmpower/FrameworkBenchmarks/blob/master/frameworks/Haskell/yesod/yesod-mysql-mongo/src/yesod.hs  these were the errors i got  https://bpaste.net/show/4d64d3bb96ee
14:28:53 <dmwit> mpickering: Perhaps the ixset package would be interesting to you.
14:29:03 <mpickering> dmwit: I am just trying to avoid a situation where I insert [a,b] => 0 into the map as a => 0 and b => 0
14:29:04 <ph88> https://hackage.haskell.org/package/resource-pool-0.2.3.2/docs/Data-Pool.html#v:withResource 
14:29:10 <mpickering> then later if I insert [a] => 1
14:29:14 <Solonarv> (my laptop has decided to thrash the pagefile again, hold on for a while)
14:29:25 <mpickering> then is the mapping b => 0 correct? I would prefer to invalidate it
14:29:26 <ph88> hhmm that doesn't directly involve Handler i suppose ..
14:29:46 <Solonarv> oh I see, my guess was off
14:30:09 <dmwit> mpickering: Right. A `Map Path (Value, Set Path)` would help with that bookkeeping.
14:30:35 <dmwit> mpickering: Though you'd probably want to newtype wrap and hide that, and expose only operations that carefully inspect and use those Set Paths.
14:30:48 <mpickering> your suggestion is to iterate over the set to invalidate the other entries?
14:30:53 * dmwit nods
14:32:20 <mpickering> Not the worst idea
14:32:41 <Solonarv> ph88: it looks like yesod switched to UnliftIO instead of monad-control, which is what broke your code
14:33:29 <ph88> Solonarv, ah that's valueble advice !  how did you figure that out ?
14:34:21 <Solonarv> ph88: I was already aware of UnliftIO as a "better" alternative to monad-control, and suspected it might be that
14:34:41 <Solonarv> then I checked the changelog of 'yesod' and 'yesod-core' and found my suspicion confirmed
14:35:45 <ph88> ok great, i found a blog post too https://www.fpcomplete.com/blog/2017/07/announcing-new-unliftio-library so i'll read this first
14:37:31 <phadej> oh, was it already 1.5 years ago
14:37:44 <phadej> feels like just yesterday I did some monad-control -> unliftio migrations
14:38:40 <Solonarv> withResource pool inner = bracket (takeResource pool) (inner . fst) (\(a, localPool) -> putResource localPool a) -- ph88: this should be a drop-in replacement for the 'withResource' from resource-pool
14:39:07 <Solonarv> using 'import Data.Pool hiding (withResource)' and 'import UnliftIO.Exception'
14:39:12 <ph88> ah thanks :D
14:42:37 * hackage nimber 0.1.4 - Finite nimber arithmetic  https://hackage.haskell.org/package/nimber-0.1.4 (AndersKaseorg)
14:43:34 <Solonarv> it seems like there is no 'MonadFail' instance for HandlerFor, which is causing some of the other errors
14:43:39 <ph88> Solonarv, this is the current state now https://bpaste.net/show/6af284b1231a https://bpaste.net/show/34fee61ada08
14:43:41 <Solonarv> I'm not actually sure wh that's the case
14:47:51 <Solonarv> ph88: oh, sprinkle some 'liftIO' on that withResource implementation
14:48:28 <Solonarv> its type should be: withResource :: MonadUnliftIO m => Pool a -> (a -> m b) -> m b
14:48:46 <ph88> great that part works now
14:49:21 <ph88> ignore that last sentence xD
14:51:43 <ph88> when i just put liftIO in front of the function i get   Expected type: m b  Actual type: m ()
14:54:02 <Solonarv> it should look something like:
14:54:02 <Solonarv> withResource pool act = bracket (liftIO $ takeResource pool) (act . fst) (\(a, localPool) -> liftIO $ putResource localPool a)
14:54:56 <ph88> i tried that too, but it gives the same error
14:55:19 <Solonarv> ...apparently I should check docs before saying things
14:55:34 <Solonarv> swap the last two arguments to 'bracket'
14:55:43 <ph88> i think that code is equavalent if you do liftIO's in inner stuff or just on start of function
14:56:06 <ph88> hurray !
14:56:32 <Solonarv> if you put the liftIO on the outside you get 'withResource :: MonadIO m => Pool a -> (a -> IO b) -> m b', which isn't right ;)
15:03:24 <Solonarv> the missing MonadFail you could easily fix by defining an orphan MonadFail instances:
15:03:24 <Solonarv> instance MonadFail (HandlerFor s) where fail = liftIO . fail
15:05:19 <Solonarv> ph88: ah, found the relevant discussion on the yesod repo: https://github.com/yesodweb/yesod/issues/1569
15:16:37 * hackage pandoc-pyplot 2.0.0.0 - A Pandoc filter for including figures generated from Matplotlib  https://hackage.haskell.org/package/pandoc-pyplot-2.0.0.0 (LaurentRDC)
15:34:07 * hackage graphmod 1.4.3 - Present the module dependencies of a program as a "dot" graph.  https://hackage.haskell.org/package/graphmod-1.4.3 (IavorDiatchki)
15:42:17 <nivpgir> hello everyone
15:42:27 <nivpgir> haskell noob here
15:42:42 <Clint> go on
15:43:26 <nivpgir> trying to use Data.Stream thinking it would be lazy, but it blocks infinitely
15:43:47 <nivpgir> i'll arrange a paste, just a sec
15:47:54 <nivpgir> https://gist.github.com/nivpgir/1a374ace68f062773d110b6d1baa8abe
15:47:57 <nivpgir> this is my code
15:48:31 <nivpgir> I ran it with a debugger and as far as I can tell it blocks on "Stream.repeat Empty"
15:49:39 <geekosaur> that sounds like you have something that's overly strict and trying to consume the entire Stream all at once
15:49:50 * geekosaur has not looked yet, a little busy elsewhere
15:51:17 <nivpgir> but I didn't use any "!" anywhere
15:52:51 <geekosaur> oh, you're trying to show a Configuration, which includes a Stream, which may try to dump the entire Stream
15:54:05 <geekosaur> "Note that show returns an infinite String."
15:54:19 <geekosaur> so yes, that's going to be an infinite loop
15:54:50 <geekosaur> you may need to write a custom Show instance for Configuration that doesn't try to show the Stream itself but shows a placeholder
15:55:26 <geekosaur> or a custom displayer of some kind, since it's generally a mistake to use Show as a prettyprinter
15:55:50 <nivpgir> oh of course...
15:56:26 <nivpgir> the sad part is that the only reason the configuration is shown is because I was debugging... :-(
15:56:37 <nivpgir> why not use show as a pretty printer?
15:58:27 <geekosaur> in general SHow and Read instances are intended to produce and consume valid Haskell code
15:58:44 <geekosaur> which is useful when debugging. sounds like the Stream instance of Show violates this
15:59:34 <Solonarv> well to be fair there is no way for it to *not* violate this
15:59:41 <geekosaur> which is itself an example of why this shouldn't be done; granting that it would be difficult for it to produce the original source, since it can't ask its value to produce its source code
15:59:41 <lyxia> you're never going to show a full stream so you might as well hijack Show for this
15:59:46 <lyxia> and nobody uses Read
16:00:24 <Solonarv> more generally I'm fine with non-canonical Show instances if a canonical one isn't possible
16:01:41 <geekosaur> right, but a noncanonical instance that's nonterminating is kinda unexpected
16:02:18 <Solonarv> well, it really shouldn't be too surprising that the string representation of an *infinite* data structure is also infinite
16:02:25 <Solonarv> that is in fact entirely expected!
16:02:43 <Solonarv> (and the same thing happens if you 'show' a list that happens to be infinite)
16:03:27 <dmwit> nivpgir: Although Stream is beautiful, consider for practicality instead storing finite tapes, expanding them on the fly when you reach the end.
16:03:53 <Solonarv> it also helps that this is a productive form of nontermination, instead of looping forever and never producing anyoutput
16:03:54 <lyxia> I think if TM is the name of your file practicality is the last of your concenrs
16:03:57 <Solonarv> dmwit++
16:04:51 <dmwit> One can keep practicality in mind even when building research prototypes or toys.
16:08:12 <nivpgir> I still kinda lean towards creating a custom Show for Tape which terminates (or some other pretty printing function instead), keeping track of where the tape ends sounds like a hassle I don't want to get into
16:08:30 <lyxia> nivpgir++
16:09:51 <dmwit> If we are ignoring practicality, then presumably we would want the Show instance for Tape not to terminate until it's shown all the things stored on the tape. How are you going to ensure that without keeping track of where the tape ends?
16:14:56 <lyxia> not optimizing for practicality /= optimizing for impracticality  :)
16:19:46 <nivpgir> dmwit: I thought I'd just print some finite amount of chars from it for now...
16:35:37 * hackage base64-bytestring-type 1.0.1 - A newtype around ByteString, for base64 encoding  https://hackage.haskell.org/package/base64-bytestring-type-1.0.1 (phadej)
16:38:07 * hackage msgpack 1.0.1.0 - A Haskell implementation of MessagePack  https://hackage.haskell.org/package/msgpack-1.0.1.0 (HerbertValerioRiedel)
16:52:08 <ph88> hey guys, i'm reading this article on contravariant  https://www.fpcomplete.com/blog/2016/11/covariance-contravariance  it looks simple explained (which is good). I can observe the difference between a -> b and b -> a .. but i still don't get why it's now b -> a instead of a -> b
16:52:49 <ph88> i'm also not so familiar with a record that holds a function .. i mean i've seen it before, but i don't use that myself
16:53:08 <ph88> polymorphic record holding a single function eehh
16:55:38 <phadej> ph88: you could try https://typeclasses.com/contravariance too
16:55:50 <phadej> maybe reading another explanation will make it click for you
16:55:54 <ph88> ah thanks, i'll check it out
16:56:41 <ph88> wow nice website, never saw that before
16:56:47 <jackdk> ph88: https://www.youtube.com/watch?v=JZPXzJ5tp9w is a good talk, if you tend to learn better with your ears than your eyes
16:57:03 <ph88> ok
16:59:43 <ph88> "my slides are in haskell, because it's the only way to make it fit on the slide"
16:59:52 <Rembane> The best joke. 
17:00:16 <bandali> lol
17:06:35 <Rembane> "This function takes more than one day to run." :D :D :D 
17:08:06 <mikail_> How do I interpret/read this typeclass?
17:08:09 <mikail_> class Semigroupoid c where
17:08:09 <mikail_>   o :: c j k -> c i j -> c i k
17:08:51 <mikail_> I am not sure what the c j k is
17:09:04 <mikail_> c is the type that the typeclass takes
17:09:11 <lyxia> c is a type constructor with two parameters
17:09:32 <lyxia> i j k are such parameters
17:09:32 <mikail_> OH
17:09:40 <Rembane> Where does the i come from? 
17:09:47 <Rembane> Teleporter magic?
17:09:55 <lyxia> alien technology
17:09:57 <mikail_> they are parameters
17:10:09 <Solonarv> no, they're type variables in the definition of o
17:10:34 <mikail_> I get it now
17:10:50 <Solonarv> a more explicit type signature would be: o :: forall i j k. c j k -> c i j -> c i k
17:10:50 <Rembane> So if you have something that looks like that but with the type variables replaced with something else you can create an instance of Semigroupoid? 
17:11:12 <Solonarv> you can compare this to Functor:
17:11:15 <Solonarv> @src Functor
17:11:15 <lambdabot> class Functor f where
17:11:15 <lambdabot>     fmap :: (a -> b) -> f a -> f b
17:11:33 <mikail_> yes
17:12:03 <mikail_> so for c j k , the type is constructed from j and k
17:12:31 <mikail_> ie c take j and k to construct the type of the first argument of "o"
17:12:53 <Solonarv> yes
17:13:03 <mikail_> :+1
17:13:11 <YongJoon> Hello, does anyone knows about that why ghc-8.6.4 Windows binary release(https://downloads.haskell.org/~ghc/8.6.4/ghc-8.6.4-x86_64-unknown-mingw32.tar.xz) drop profiling library?
17:13:31 <YongJoon> I tried to compile/install some packages(hie) with profiling option on Windows machine yesterday, and it always said that I didn't install profiling libraries for package 'base-4.12.0.0'. And I finally figure it out that 8.6.4 does not release profiling library.
17:13:40 <YongJoon> Was there any announces about this issue?
17:14:50 <Solonarv> for example you could imagine c = (->); then we have o :: (->) j k -> (->) i j -> (->) i k
17:14:50 <Solonarv> we can also write this as: o :: (j -> k) -> (i -> j) -> (i -> k)
17:14:50 <Solonarv> (this is simply function composition)
17:15:19 <Solonarv> YongJoon: there is some problem with the profiling libs on windows, I don't remember what exactly
17:15:46 <YongJoon> Thanks.
17:16:27 <mikail_> :+1 Solonarv 
17:16:43 <Solonarv> I'll see if I can find an actual issue report
17:16:59 <YongJoon> Thanks, @Solonarv.
17:18:52 <ph88> jackdk, the video was most helpful i get it now
17:19:13 <jackdk> you're welcome. gwils is a very good speaker
17:29:01 <Solonarv> YongJoon: from the 8.6.4 announcement email: "A regression resulting in segmentation faults on Windows introduced by the fix for #16071 backported in 8.6.3. This fix has been reverted, meaning that 8.6.4 is once again susceptible to #16071. #16071 will be fixed in GHC 8.8.1. "
17:29:06 <ph88> bifunctor but then contravariant in both arguments, is that a thing ?
17:29:28 <YongJoon> Thanks a lot,  Solonarv!
17:29:36 <Solonarv> here is the issue: https://gitlab.haskell.org/ghc/ghc/issues/16071
17:30:15 <Solonarv> ph88: sure, but I don't know if the corresponding typeclass is defined anywhere
17:33:07 <Solonarv> and it's not clear to me what such a typeclass would be useful for
17:33:35 <barryburd> Hi. A student of mine is trying to run an NCurses program on his Linux laptop. He keeps getting build errors, apparently because cabal can’t find the ncurses package. I’ve copied all the material concerning his attempts to a file with URL https://users.drew.edu/bburd/ncursesAttempt.1.zip   Can anyone take a look and tell me what we can do to get his program going?
17:37:05 <ph88> barryburd, which OS ?
17:37:27 <barryburd> I’m not sure which distribution of Linux.
17:38:20 <dmwit> barryburd: I'm not sure I understand. That terminal log looks like it ended successfully to me.
17:39:00 <barryburd> dmwit, which file are you looking at?
17:39:25 <dmwit> TerminalSession.txt
17:40:22 <Solonarv> yeah, I don't actually see any error message there
17:40:23 <ph88> barryburd, where is the actual error, i can't find it either
17:40:28 <barryburd> At the very end of the session, the student types ‘cabal new-repl’ and the repl doesn’t open. Instead, he gets a few lines of text and then another Terminal prompt.
17:41:04 <barryburd> I posted this material earlier and was asked that he try again with -v3 as a setting. That’s what’s in the verboseBuildAttempt file.
17:41:07 <Solonarv> oh, hm - that's very strange indeed
17:42:19 <ph88> barryburd, which ghc version actually ?
17:42:19 <dmwit> I wonder if he may have an old enough cabal that it didn't support build-tool-depends or whatever that field is called.
17:42:26 <dmwit> ph88: must be 8.0.x
17:42:32 <dmwit> ph88: from the base dependency in the cabal file
17:43:03 <dmwit> barryburd: I notice that the dependency tree eventually involves alex and happy as build tools.
17:43:12 <ph88> barryburd, maybe some people will not like this advice. But what about using stack with ghci and latest version of ghc compiler ?
17:43:23 <dmwit> barryburd: Perhaps it's attempting to run those and failing, because he hasn't installed them and cabal is too old to be smart enough to build them itself.
17:43:49 <Solonarv> it would be very strange for that to just fail silently, though
17:44:02 <dmwit> Well, it does say "Redirecting build log to {...}".
17:44:08 <dmwit> And I don't think that file was included.
17:44:09 <Solonarv> oh yeah
17:44:47 <dmwit> barryburd: Anyway, you could try either upgrading cabal or installing alex+happy manually and see if that helps.
17:45:00 <dmwit> Other than that I'm not too sure what could be happening here.
17:45:12 <Solonarv> barryburd: could you also include the file '/home/casper/.cabal/logs/ncurses-0.2.16.log', if the other suggestions don't help?
17:45:55 <barryburd> OK. I’ll have him try these suggestions. 
17:46:07 <dmwit> Sorry this is so difficult!
17:46:12 <dmwit> Bummer of an intro to the language.
17:46:20 <barryburd> Package management is never simple.
17:47:00 <Solonarv> this is actually a particularly mystifying error
17:47:13 <barryburd> At least the language itself is elegant. The package management part is completely separate. One doesn’t have to appreciate the management part.
17:47:27 <Solonarv> I've had similarly mystifying failures, but I'm on windows which tendsto have more problems
17:47:54 <dmwit> Yeah, failing silently is a bit unusual in my experience.
17:48:00 <Solonarv> when it works (which is the norm) haskell's package management is actually very nice IMO
17:48:16 <dmwit> Terse error messages I've seen. Misleading error messages I've seen. But silent is new to me.
17:48:54 <Rembane> Does echo $? give 0?
17:49:27 <monochrom> I think when cabal is silent it is because unimplemented command.  For example cabal new-run was a no-op for a while.
17:50:45 <Solonarv> yeah, but this is clearly doing *something*
17:50:53 <monochrom> Ah OK
17:51:58 <Solonarv> the strange thing here is that 'cabal new-repl' seems to build the package & its dependencies, and then just exits silently
17:53:33 <barryburd> In a way, I’m happy that it’s not a trivial problem to solve. It’s a mystery of sorts.
17:54:12 <ph88> https://youtu.be/H01dw-BMmlE?t=119 haskell joke night
18:09:30 <aplainzetakind> cabal: repl failed for test-0.1.0.0. The build process segfaulted (i.e. SIGSEGV).
18:11:14 <suzu> lol
18:11:16 <aplainzetakind> On my machine this happens, but after the repl runs and I call main, which is strange since seemingly the build is complete already.
18:11:34 <suzu> whats your machine?
18:12:37 <aplainzetakind> That's a broad question, in what sense?
18:13:10 <aplainzetakind> I just tried to see what happens with that problematic ncurses thing.
18:14:36 <suzu> your os?
18:14:40 <suzu> how did you install cabal?
18:14:44 <suzu> and ghc?
18:15:16 <suzu> oh hold on
18:15:21 <suzu> i didnt read the whole story that's going on here
18:19:13 <aplainzetakind> Yeah, my machine isn't really relevant.
18:20:05 <aplainzetakind> cabal is 2.4.1 though
18:22:47 <Solonarv> mine is 3.0 ;)
18:23:00 <Solonarv> (I'm running cabal HEAD)
18:26:09 <mouse07410> How different is GHC-8.6.4 from 8.6.3? Is it really worth upgrading? If so, what's the best tool to do the upgrade with? I tried "ghcup upgrade", but it seemed to only upgrade itself.
18:28:20 <shapr> mouse07410: "ghcup list" will show you the versions of ghc it can install
18:28:52 <shapr> mouse07410: "ghcup show" will show you which versions are installed, and which is set to active
18:29:11 <Solonarv> mouse07410: 8.6.4 fixes some bugs in 8.6.3, you can view the release notes here: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/8.6.4-notes.html#release-notes-for-version-8-6-4
18:29:47 <Solonarv> nothing super critical (unless you're on windows, which you aren't) but also no reason not to upgrade
18:29:50 <shapr> mouse07410: so you could do "ghcup install 8.6.4" and then "ghcup set 8.6.4" to have that as the active version
18:51:34 <dmwit> aplainzetakind: What evidence leads you to believe "the build is complete already"?
18:52:22 <dmwit> If the evidence is "I can run main in the repl", the conclusion does not follow. ghci is an interpreter; it doesn't need GHC to have built the module before it can start doing its thing.
18:52:40 <dmwit> (Of course this does nothing to explain why you're seeing a segfault.)
18:52:50 <dmwit> (But perhaps it will explain other parts of your observations.)
19:07:46 <aplainzetakind> dmwit: My understanding was that new-repl hands over the repl prompt after building the project. By the way you sound, that's incorrect.
19:10:05 <aplainzetakind> But cabal new-build also merrily completes with no sign of segfaulting with exit status 0. Is that also not really building?
19:11:32 <mouse07410> Solonarv: and shapr: thank you! So to upgrade I must tell ghcup exactly what version I sent it to install? If I install 8.6.4 - would it invalidate everything I've compiled and installed with 8.6.3? Will it require a new cabal and stack?
19:12:35 <Solonarv> no, you shouldn't need a new cabal/stack
19:13:04 <aplainzetakind> mouse07410: You can switch versions with ghcup set
19:13:23 <mouse07410> Excellent. Then, as you said - no reason to hold off on the upgrade.
19:13:24 <Solonarv> if you have a cached package that was built with 8.6.3, it will not be re-used when compiling with 8.6.4, but that is correct behavior!
19:13:46 <Solonarv> (also - stack manages ghc on its own, and doesn't care which ghc you have installed system-wide)
19:14:32 <mouse07410> aplainzetakind: I prefer to keep one working version of the compiler, ideally the latest - unless it would cause you big a headache, like recompiling all the pkgdb.
19:15:15 <Solonarv> there is virtually no ABI compatibility in GHC, so packages definitely have to be recompiled when changing compiler version
19:16:05 <mouse07410> Solonarv: what is "cached package"? Every dependency that cabal installed when, e.g., it installed "hsdev"?
19:16:59 <aplainzetakind> mouse07410: The use-case when this feature of ghcup is handy is when you pull some not-too-up-to-date repo and want to play with it. Then you just do something like ghcup set 8.0.2, play around, and switch back when you go back to your own thing.
19:17:01 <Solonarv> mouse07410: packages which have already been compiled, and might perhaps be re-used when building something
19:19:24 <mouse07410> Solonarv: no ABI compatibility even between 8.6.3 and 8.6.4?! Also, already-compiled packages - would cabal have to re-download them, or does it keep their sources as well?
19:19:50 <Solonarv> it should keep the source, assuming of course that it's the same source
19:21:08 <mouse07410> Yeah... But that it probably checks, right? And it wouldn't need to rebuild binaries like "hsdev" or "happy", correct?
19:22:40 <Solonarv> it shouldn't rebuild executables, no
19:23:33 <Solonarv> and package sources are reused assuming the version is the same
19:23:55 <mouse07410> I think I'll upgrade one machine (probably the fastest one) and see what kind of havoc with my installation the upgrade would cause. Based on that, I'll deal with my other machines.
19:28:05 <mouse07410> Are there any decent crypto packages for Haskell? Hashes, HMAC, symmetric encryption, public key, RNG? Perhaps a wrapper for OpenSSL?
19:31:09 <Solonarv> cryptonite is a big kitchen sink of crypto primitives, if you look through its reverse dependencies you'll probably get a decent overview
19:40:13 <mouse07410> Solonarv: thanks. I'd settle for a kitchen sink if it saves me the need to dig up a dozen of other packages, and it's implementation is reasonable.
19:40:46 <Solonarv> the documentation on 'cryptonite' says not to use it directly unless you're implementing a crypto package
19:41:13 <Solonarv> I'm far from an expert in that area tbh, but the broad answer to your original question is "yes"
19:42:37 <mouse07410> Oh?  Darn... Here goes my hope for a simple solution. Although I wonder what the mean by "you're implementing a crypto..."
19:43:02 <mouse07410> ^they
19:44:41 <mouse07410> And I just realized- your said "reverse dependencies", which means packages that depend on 'cryptonite', not the other way around.
19:44:42 <Solonarv> well, you didn't really specify what it is you want to do
19:44:47 <Solonarv> yes indeed
19:45:10 <Solonarv> ah, it appears I forgot to link them: http://packdeps.haskellers.com/reverse/cryptonite
19:45:30 <Solonarv> there's actually a lot of packages in there, so I'm not entirely sure how useful it is
19:45:45 <Solonarv> you can also use hackage's search feature to get an overview
19:45:55 <Solonarv> * of crypto-related packages
19:48:59 <mouse07410> Very useful, thanks! For some I can tell immediately what they do (assuming their authors chose the names wisely ;), and the others I can look up.
20:17:00 <Arahael> I'm not yet up to speed with constraints, and I'm wondering why I can't do this: f :: (Num a, Num b) => a -> b -> c; where f = (+)
20:17:14 <Arahael> Erm: f :: (Num a, Num b) => a -> b -> a
20:18:21 <Arahael> The reason I'm confused is because it should be enough that (+) takes two argumetns, both which have to belong to the Num typeclass.  And it returns a third which has to belong to the Num typeclass, and I'm not sure why it isn't enough to manually specify that they all have that same typeclass?
20:19:03 <Solonarv> Arahael: look at type signature of (+)
20:19:06 <Solonarv> :t (+)
20:19:07 <lambdabot> Num a => a -> a -> a
20:19:16 <Arahael> Just worked it out - the caller has to provide the type, and it may have an instance of Num, but could be a different typeclass.
20:19:30 <Arahael> Solonarv: Right - all argumetns and result belong to Num typeclass.
20:19:39 <Solonarv> you are allowed to replace 'a' with any type you want (so long as there is a Num instance)
20:19:52 <Solonarv> but you must replace all occurences of 'a' with the *same* type!
20:20:15 <Arahael> Solonarv: That's the confusion I had, it's not enough that there is a Num instance for each parameter, but it has to be the *same* typeclass with a Num instance.
20:20:58 <Solonarv> for an analogy, consider this equation: 2 * x = x + x
20:21:15 <Solonarv> you can replace 'x' with whatever you want, but you must replace all occurences of 'x' with the same thing!
20:21:25 <Arahael> Right, so lets say 2 is an Integer type, and x is a Floating type, I was thinking: It's valid, they both have a Num instance!
20:21:38 <Arahael> But I was mistaken, has to be the same type, as you have pointed out.
20:21:56 <Arahael> Parametric polymorphism, not subtype polymorphism.
20:21:59 <Solonarv> yup
20:22:22 <Solonarv> some languages will automatically insert appropriate conversions, but Haskell does not do this
20:22:43 <Arahael> I'm wondering how I'd do some sort of appropriate conversion.
20:22:51 <Solonarv> :t fromIntegral
20:22:52 <lambdabot> (Num b, Integral a) => a -> b
20:23:06 <Arahael> But what if I want to allow floats?
20:23:23 <Solonarv> this converts from anything "integer-ish" to anything "number-ish'
20:23:36 <Arahael> Right, but what if I want something that adds a number-ish to another number-ish?
20:24:01 <Arahael> Example: 0.2 + 0x0badbeef
20:24:15 <Solonarv> > 0.2 + 0x0badbeef
20:24:17 <lambdabot>  1.959359832e8
20:24:45 <Arahael> > let a = 0.2; b = 0x0badbeef; in a + b
20:24:47 <lambdabot>  1.959359832e8
20:24:51 <Arahael> How does that work?
20:25:01 <Solonarv> literals are polymorphic, instead of having some fixed type
20:25:02 <Arahael> > let a = 0.2 :: Float; b = 0x0badbeef :: Int; in a + b
20:25:04 <lambdabot>  error:
20:25:04 <lambdabot>      • Couldn't match expected type ‘Float’ with actual type ‘Int’
20:25:04 <lambdabot>      • In the second argument of ‘(+)’, namely ‘b’
20:25:10 <Arahael> There we go.  Lets say we have that
20:25:32 <Arahael> Purely hypothetical, mind you.  I don't actually need this...
20:25:50 <Solonarv> > let a = 0.2 :: Float; b = 0x0badbeef :: Int; in a + fromIntegral b
20:25:52 <lambdabot>  1.9593598e8
20:26:19 <Arahael> Lets say we're defining a :+.
20:27:09 <Arahael> I suppose it doesn't really make sense.
20:27:16 <Arahael> (My question, that is)
20:27:57 <Solonarv> no, you can totally write something like that
20:28:19 <Solonarv> it just turns out to be very annoying to use, because type inference doesn't really work when you're being that general
20:28:45 <Solonarv> (this is also why Haskell doesn't automagically insert numeric conversions)
20:31:44 <Arahael> Right, I actually prefer the wya haskell does it, I was just thinking of how to write an example function that has a type a -> b -> c that just demonstrates that 'flip ff' results in b -> b -> c
20:31:53 <Arahael> *sigh*.  Results in b -> a -> c :)
20:36:16 <Arahael> Anyway, all good - thanks for helping me think it through. :)
20:36:41 <Solonarv> well, you don't actually need to involve polymorphism at all there; you can just do something with Int, Bool, Char, ...
20:37:16 <Solonarv> for example:
20:37:57 <Solonarv> @let letter upper index = chr $ index - 1 + if upper then ord 'A' else ord 'a'
20:37:58 <lambdabot>  Defined.
20:38:03 <Solonarv> letter False 3
20:38:08 <Solonarv> > letter False 3
20:38:10 <lambdabot>  'c'
20:38:15 <Solonarv> > letter True 3
20:38:17 <lambdabot>  'C'
20:38:20 <Solonarv> :t letter
20:38:21 <lambdabot> Bool -> Int -> Char
20:38:24 <Arahael> > letter "true" 3
20:38:26 <lambdabot>  error:
20:38:26 <lambdabot>      • Couldn't match expected type ‘Bool’ with actual type ‘[Char]’
20:38:26 <lambdabot>      • In the first argument of ‘letter’, namely ‘"true"’
20:39:20 <Arahael> I suspect I'd need to somehow implement it more like: a -> (a -> c) -> b -> (b -> c) -> c
20:39:40 <Arahael> (Or rather: (a -> c) -> (b -> c) -> a -> b -> c
20:40:30 <Solonarv> what's that meant to do?
20:41:26 <Arahael> Solonarv: Allow defining a function that takes 'a', 'b', and returns 'c'.
20:41:37 <Arahael> I ended up using: f :: a -> b -> c; f = undefined
20:41:50 <Solonarv> that is actually the only possible implementation ;)
20:42:01 <mouse07410> Solonarv: ghcup days that 8.6.4 is the latest, but 8.6.3 is *recommended*. At what point does the latest becomes also "recommended"?
20:42:17 <Solonarv> mouse07410: no idea tbh
20:42:43 <Arahael> Solonarv: This means that you can show `:t f` in the repl, and then do `:t (flip f)` and show how the arguments are flipped.
20:42:57 <Arahael> Solonarv: And *that* was the ultimate thing I wanted to do! That's it! :)
20:43:02 <Solonarv> :D
20:43:33 <Solonarv> yeah, if you just want to look at types you can freely throw around 'undefined' all over the place
20:44:01 <Arahael> Right, and I would've preferred to just put in '+' instead. Afterall, a number + a number is generally pretty widely understood.
20:44:41 <Solonarv> yeah, but there 'flip' doesn't really do anything
20:44:50 <ski> (what's a polynomial plus a matrix ?)
20:44:54 <Solonarv> after all it's generally true that x+y = y+x
20:45:28 <Arahael> Solonarv: It's barely relevant, though!
20:45:48 <Arahael> Solonarv: I mean, it becomes relevant when you then talk about monoid instances...  But I was just. Talking. About. Flip!
20:45:50 <Solonarv> it doesn't do anything to the type either, as we discussed above :D
20:46:00 <ski> @djinn a -> (a -> c) -> b -> (b -> c) -> c
20:46:00 <lambdabot> f _ _ a b = b a
20:47:37 <mniip> I see 2 possible implementations here
20:48:07 <Solonarv> indeed
20:48:15 <Solonarv> this is just Bool in a trenchcoat!
20:48:30 <ski> (how do you prove that ?)
20:49:01 * Solonarv in a spooky voice: parametricity~!
20:49:06 <ski> (`Coyoneda' gets you partway. then parametricity, somehow ?)
20:50:00 <Cale> ski: haha, does the polynomial get implicitly multiplied by an identity matrix, or do its coefficients?
20:50:07 <jle`> i spy with my eyes a hidden Bool
20:50:17 <Cale> (do you end up with a matrix of polynomials, or a polynomial with matrix coefficients)
20:50:36 <jle`> or a polymatrix of matonomials
20:51:07 <Solonarv> curry & rearrange args to get (a, a -> c) -> (b, b -> c) -> c
20:51:07 <Solonarv> apply coyoneda twice to get c -> c -> c
20:51:07 <Solonarv> now we have the well-known church encoding of bools
20:51:16 <Solonarv> or something like that anyway
20:51:25 <jle`> nice
20:54:24 <dmwit> aplainzetakind: Right. v2-repl will make sure all dependencies are built before entering the repl, but will drop into ghci even if it doesn't succeed at building the local packages. This helps during development, when some modules may not yet build but you still want to experiment with other modules.
20:55:29 <dmwit> hold up
20:56:12 <dmwit> Why do we believe `(a, a -> c)` is isomorphic to `c`?
20:56:28 <ski> rather `exists a. (a,a -> c)'
20:56:32 <dmwit> Or, I guess my question more precisely is: where *exactly* are the quantifiers here?
20:57:46 <ski> note that `forall a. (a -> ((a -> c) -> ...))' is `forall a. ((a,a -> c) -> ...)' is `(exists a. (a,a -> c)) -> ...', assuming `a' doesn't occur free in `...'
20:57:55 <dmwit> (It certainly isn't true that for all types c, `forall a. (a, a -> c)` is isomorphic to `c`.)
20:58:01 <Solonarv> ah, ski saved me some typing
20:58:36 <Solonarv> no, but 'exists a. (a, a -> c)' is iso to 'c'
20:58:43 <Solonarv> (with a not free in c)
20:58:44 <ski> the quantifier flips around
20:59:02 <dmwit> Even with exists, it isn't true that for all types c, `exists a. (a, a -> c)` is isomorphic to `c`.
20:59:03 <ski> (or, with `c' not depending on `a')
20:59:19 <ski> yea, modulo some bottom handwaving
20:59:38 <Solonarv> yea I also forgot to mention the handwaving wrt bottoms
20:59:49 <ski> obviously `(_|_,_|_)' isn't `_|_', but on the other side of the fence both of those correspond to just `_|_'
20:59:54 <Arahael> bottom-waving.
20:59:57 <dmwit> Oh, it actually is isomorphic. Okay.
21:00:14 <dmwit> I had a bug in my thinking.
21:01:06 * ski . o O ( not a thunk in your 'bigging' )
21:01:50 <Solonarv> Coyoneda says that (exists a. (f a, a -> r)) ~ f r; here we use the special case with f = Identity
21:02:00 <ski> indeed (was just about to mention :)
21:02:23 <ski> let's also mention `Yoneda', for comparision
21:03:47 <ski> (oh, and one should say that that equivalence depends on `f' being a (covariant) functor. otherwise it doesn't work)
21:04:07 <Solonarv> Yoneda says (forall x. (a -> x) -> f x) ~ f a; the special case with f = Identity is (forall x. (a -> x) -> x) ~ a
21:04:36 <ski> aka CPS (with generic answer/result type)
21:04:58 <ski> (related to minimal logic)
21:05:43 <Solonarv> (co)yoneda is really quite cool :D
21:07:33 <ski> i derived `List a = forall o. (exists s. (s,s -> o,s -> a -> s)) -> o' once. later i realized i could `Yoneda' that into `List a = forall s. (s,s -> a -> s) -> s' (basically `foldl')
21:09:07 <ski> (i also had some meta-programming thown in the mix, in the actual thing)
21:17:27 <ddellacosta> Are there any kinds of graph algorithms that address graphs which change structure as you traverse them, in particular when a vertex has been visited and subsequently "disappears," such that vertices that were previously not accessible become accessible? In other words essentially if we are using an adjacency list representation of a graph, we'd have to recalculate it every time we visit a vertex
21:18:16 <ddellacosta> more specifically related to Haskell, I'm wondering if there's an algebraic approach to talking about this type of relationship between vertices that I could leverage here
21:29:18 <dmwit> By "disappears", do you mean that all its neighbors become connected to each other?
21:29:57 <dmwit> What does "accessible" mean?
21:35:36 <dmwit> (Is this a "graph minor" thing, or are you awkwardly describing fgl's model of inductively describing graphs, or some third alternative...?)
22:01:51 <ddellacosta> sorry dmwit. by disappears, yeah it means that vertex essentially is no longer present on the graph in terms of allowing the creation of edges with other vertices. As far as the last thing you asked, I don't have enough knowledge about those libraries/concepts to answer, but I'd love to know more! 
22:04:12 <ddellacosta> oh I looked up graph minor--yes, this qualifies as that, absolutely. Thanks, I didn't know that term!
22:22:17 <fen> do we have something isomorphic to \ a b -> (a,Maybe b) ?
22:23:07 * hackage asif 5.0.1 - Library for creating and querying segmented feeds  https://hackage.haskell.org/package/asif-5.0.1 (arbornetworks)
22:23:21 <Cale> do you mean \a b -> (a, Just b) ?
22:23:36 <Cale> or was that a type level lambda?
22:23:39 <fen> no, using type level lambdas
22:24:00 <fen> it could be written \ a b -> Either a (a,b)
22:26:51 <Cale> Yeah, I can't think of anything
22:26:58 <fen> [a] = Fix ((\a b -> Either a (a,b)) a)
22:27:00 <fen> right?
22:27:37 <Cale> \a -> Fix (\b -> Either a (a,b))
22:27:54 <fen> right, yeah
22:28:20 <fen> its appearing because of the "Skip" container
22:29:35 <fen> having classified get which returns something of exactly one value as ((,) i), it needs a Maybe in the rhs of the pair to say that it can have one or zero values
22:31:36 <fen> if we have containers defined by equivalence to various States; s -> (r a,s), s -> (r a,Maybe s),s -> Maybe (r a,s), this is the case where r = (i,Maybe a)
22:32:51 <fen> was wondering if the r a= (i,Maybe a) could be given a common name
22:35:35 <fen> its annoying to have yet another category of get/set things, but having made one for _i being "exactly one value per segment" it seems reasonable to have something for "at most one vale per segment"
22:36:07 <fen> data Skip a = Skip (Skip a) | SkipValue a (Skip a) | SkipEnd
22:37:59 <fen> is an instance of such, as it could have an empty section at the front or at the end. if we only had set_i :: ((Int,a),Skip a) -> Skip a, it would not be able to make eg set_e ((1::Int,Nothing),SkipEnd) === Skip SkipEnd
22:39:06 <fen> this idea of being able to grow shaped empty containers becomes a way to generate complicated shaped trees consisting of branches without values at the end...
22:40:51 <zincy> Does the call stack function under recursion similarly between Haskell and C?
22:41:51 <benzrf> not at all
22:42:07 <benzrf> well, strictly speaking "haskell" as a language doesn't have a call stack, but if you're asking about ghc...
22:43:55 <zincy> I tried to reverse a linkedlist recursively in C after being used to haskell
22:44:06 <zincy> And it had me stumped for a while.
22:44:11 <benzrf> haha
22:44:18 <zincy> Is that to be expected?
22:45:17 <zincy> You never have to think about the call stack in Haskell
22:45:39 <zincy> Whereas in C the order of the stack frames really seems to affect the program behaviour.
22:45:42 <zincy> Not sure why
22:48:48 <dminuoso> 06:46:37           zincy | [05:44:55] You never have to think about the call stack in Haskell
22:48:52 <dminuoso> That's not correct.
22:49:55 <dminuoso> zincy: Consider the effect of using `foldr (+) 0` on a big list.
22:50:53 <glguy> zincy: This is how I would have done it in C. https://gist.github.com/glguy/3ea9bc9071c0d69fa0bd286c4c326e91
22:51:14 <glguy> It's not that much different than I'd want to write it in Haskell other than tail-call instead of while loop
22:52:43 <dminuoso> zincy: So even in Haskell you can cause stack overflows if you are not careful, the reasons just tend to be a little different.
22:52:45 <koz_> If Functor is covariant, and it's contravariant analogue is Contravariant, and the contravariant analogues to Applicative and Alternative are Decidable and Divisible, is there a contravariant analogue to Monad?
22:52:57 <dminuoso> koz_: Comonad
22:53:19 <dminuoso> koz_: Oh wait.
22:53:20 <koz_> dminuoso: Doesn't Comonad have a Functor prerequisite though?
22:53:26 <koz_> So it's covariant right?
22:53:46 <dminuoso> koz_: There's no notion of "contravariance" in monads.
22:54:09 <dminuoso> koz_: Are you familiar with the "A monad is just a monoid ..." perspective of monads?
22:54:16 <koz_> dminuoso: Vaguely.
22:54:26 <osa1> zincy: GHC's uses a stack too during execution, but in a different way (sometimes called "continuation stack"). you can also overflow it. tail-recursive calls don't cause pushes to that stack, non-tail-calls do.
22:54:28 <koz_> I can't say I grok all the theory.
22:55:13 <osa1> zincy: in addition, GHC's stacks are linked and allocated on the stack.
22:55:17 <dminuoso> koz_: The idea is that you have monoidal structure in the composition of endofunctors, i.e. you have some "monoid" that acts on the (:.:) in: join :: (m :.: m) a -> m a
22:55:42 <koz_> Yeah - basically you 'smash together' sequential effects to get one bigger effect, right?
22:55:56 <dminuoso> koz_: So the problem here is that if `m` was a contravariant functor, then the composition would produce a covariant functor.
22:55:58 <dminuoso> koz_: Sure.
22:56:26 <dminuoso> Also Im not sure whether "contravariant endofunctors" can even exist.
22:56:59 <koz_> Yeah - but isn't the analogy between, say, Divisible and Applicative fairly thin anyway?
22:57:14 <koz_> As in, it's not like Divisible is literally Applicative but with a different prerequisite.
22:57:26 <dminuoso> koz_: It is.
22:57:36 <koz_> Wait what?
22:58:00 <Cale> dminuoso, zincy: the way I like to explain it is that the stack in Haskell/GHC is pretty much not a call stack. Most of the stack entries consist of pattern matches waiting for their scrutinee to be sufficiently evaluated to match a pattern.
22:58:42 <dminuoso> koz_: Think of Applicative as `class Functor f => Monoidal f where (><) :: f a -> f b -> f (a, b); unit :: f ()`
22:58:51 <koz_> Oh, right, now I see it.
22:59:08 <koz_> I keep forgetting about that presentation.
22:59:43 <koz_> So in short, the answer to my original question is 'no'.
22:59:45 <Cale> (It also consists of functions waiting to be evaluated into a lambda, but I've only ever seen contrived examples of such stack entries causing a stack overflow, since usually you can figure out which function you have in a smallish number of steps.)
23:00:17 <koz_> OK, a different question: is a -> b -> c covariant in b, contravariant in b, invariant in b, or something else?
23:00:23 <koz_> (modulo appropriate newtype of course)
23:00:23 <Cale> Or, rather, it's rare to have recursion of that sort at all.
23:01:52 <zincy> Thanks everyone. So reverse traversing a structure in O(N) is possible in both Haskell and C?
23:02:53 <Cale> sure
23:03:00 <zincy> The solution to reversing a linked list recursively in C confused me. Especially since it is O(N). You add stack frames until the end of the list and then pop them off in reverse.
23:03:13 <Cale> That's kind of what you do in Haskell too
23:03:28 <zincy> Maybe I just dont understand recursion as well as I thought I did
23:03:38 <Cale> Okay, so let's write the bad Haskell program
23:03:42 <Cale> and then improve it
23:03:47 <Cale> reverse [] = []
23:03:58 <Cale> reverse (x:xs) = reverse xs ++ [x]
23:04:01 <dminuoso> zincy: Better yet, it's also θ(N) in time. =P
23:04:02 <Cale> Why is this bad?
23:04:22 <Cale> It's bad because xs ++ ys takes O(length xs) steps to fully reduce
23:04:25 <zincy> Prepending to a linked list?
23:04:32 <zincy> O(N)?
23:04:57 <zincy> Oh its appending
23:04:58 <zincy> Sorry
23:05:01 <Cale> So you'll pay a total of O(n^2) steps to fully evaluate the result if your list is length n
23:05:05 <dibblego> I teach people foldl (a loop), then foldr (constructor replacement), then how to solve lots of problems with foldr until they are comfortable with it, then ask them to reverse a list, and by then, they've forgotten what foldl does [which is a good thing]
23:05:52 <Cale> How do we fix this? Well, there's a couple ways we could do it, but I'll show you the tricky one (but it's a good trick to remember)
23:06:14 <zincy> switch the order of args?
23:06:23 <Cale> Well, there's only one arg :)
23:06:27 <zincy> args to the (++) that is?
23:06:38 <Cale> Well, then we wouldn't be reversing
23:06:46 <zincy> :)
23:07:20 <Cale> So we have these expensive concatenations, which cost O(n)
23:07:38 <ski> koz_ : you don't need to `newtype' it. it's contravariant in `b' (and in `a', and covariant in `c')
23:08:02 <Cale> We'd like to speed them up. One thing we can do is instead of producing a list of type [a], we can produce a function of type [a] -> [a] which will add elements to the beginning of any list we give it.
23:08:17 <Cale> [] will correspond to id (the identity function)
23:08:39 <Cale> [x] will correspond to (x:) (the function which adds x to the beginning of any list)
23:08:55 <Cale> and, most importantly, (++) will correspond to (.) (function composition)
23:09:02 <koz_> ski: Hmm, OK. I suspected as much - just wanted to check.
23:09:03 <Cale> (++) is recursive, it's O(n)
23:09:09 <Cale> while (.) is constant time
23:09:17 <koz_> (I first derived it how Sandy Maguire suggests in his book, but I wasn't sure if I'd done it correctly)
23:09:18 <Cale> (f . g) x = f (g x)
23:09:20 <Cale> one step
23:09:24 <Cale> right?
23:09:35 <Cale> So we can translate our naive reverse like this:
23:09:38 <zincy> Im not clear on that bit
23:09:48 <dminuoso> koz_: You could have tried it out yourself. Consider some `f :: a -> b -> c`, given a function `b -> x`, could you turn this into `f :: a -> x -> c`?
23:09:49 <Cale> oh, what's not so clear?
23:10:01 <zincy> (.) being in constant time
23:10:07 <dminuoso> koz_: Or, given a function `x -> b`.. so the question is which is it.. :-)
23:10:11 <Cale> ah, well, you can see the definition there
23:10:20 <Cale> (f . g) = (\x -> f (g x))
23:10:37 * ski would perhaps posit that a "call stack" in a strict language needn't be a *call* stack, either. in case you have proper tail calls
23:10:44 <Cale> that's exactly one rewrite -- it's not recursive at all
23:10:45 <koz_> dminuoso: Point taken.
23:10:49 <dminuoso> koz_: The simplest way would be to recognize that `f :: a -> b -> c` is isomorphic to `f' :: b -> a -> c` (by using flip)
23:10:57 <koz_> Ah, I see.
23:11:07 <Cale> ski: Though each of the things on your stack came from a call, at least
23:11:09 <koz_> So you can basically 'move' any of the parameters to any position?
23:11:11 <zincy> Is the idea of a step in O notation just the scaling between input elements and steps taken?
23:11:19 <koz_> (well, any but the last)
23:11:37 <Cale> zincy: We're using reduction steps as a good approximation of time that functions will take
23:12:06 <ski> Cale : they come from putting aside some work to do later, after a subcomputation (which could be a call)
23:12:06 <Cale> The O notation just lets us throw away detailed information and only look at how the number of steps grows as a function of the input size
23:12:20 <dminuoso> zincy: O notation is about describing limiting behavior of any function.
23:12:30 <zincy> The O notation just drops the constants right?
23:12:32 <dminuoso> zincy: Sadly big-O is widely misused (with most people meaning big-theta instead)
23:12:33 <Cale> ski: Yeah, I suppose if you had some things other than calls, it might be more general :)
23:12:41 <Cale> zincy: yeah
23:12:45 <Cale> zincy: pretty much
23:12:47 <dminuoso> zincy: For example: quicksort has O(n!) time in sorting a list.
23:12:52 <ski> the stack is for "remembering things to do later"
23:12:53 <Cale> what
23:13:10 <Cale> quicksort is worst case O(n^2) and average case O(n log n)
23:13:25 <Cale> Did you mean bogosort? :)
23:13:36 <koz_> Cale: Both yours and dminuoso's statements are correct.
23:13:42 <koz_> O is an asymptotic upper bound.
23:13:45 <Cale> oh, sure
23:13:48 <koz_> You can take as loose a bound as you seek.
23:14:10 <Cale> But usually we're not so generous :)
23:14:14 <dminuoso> Cale: No.
23:14:15 <dminuoso> Cale: My point is that big-O is an upper boundary. So to state that "quicksort has O(n!) time" is to say that its definitely not slower (on average) than than O(n!).
23:14:20 <zincy> ski: Call stack is the state of a function in memory right>
23:14:24 <Cale> Right, I get what you were aiming at now.
23:14:46 <koz_> I'm with dminuoso on this - I prefer Theta too.
23:14:51 <Cale> It's just uninteresting to say that quicksort's running time is in O(n!), because lots of things are
23:14:54 <ski> zincy : i would not say "function" there. and, i wouldn't say "*call* stack", as mentioned :)
23:15:10 <koz_> Cale: Agreed.
23:15:11 <ski> zincy : let's say it's the "control state of a computation"
23:15:11 <zincy> ski: "subroutine"?
23:15:32 <dminuoso> Cale: Right, which is why people should refrain from using O when they mean θ 
23:15:42 <Cale> Eh, it's easier to type :)
23:15:43 <zincy> Cale: Ok sorry for the detour.
23:15:48 <ski> zincy : think of the whole of the computation, not merely just a single computation abstraction, like a function, procedure, or subroutine
23:16:05 <Cale> zincy: Anyway, we can avoid big-O notation and count reduction steps exactly
23:16:26 <Cale> xs ++ ys takes length xs + 1 reduction steps of (++) to fully evaluate the resulting list
23:16:38 <Cale> (one more for the empty list at the end of xs)
23:16:38 <zincy> ski: Ah ok since the stack frame uses data from outside of those particular absatractions.
23:16:48 <Cale> while (f . g) takes exactly one reduction step
23:17:02 <Cale> right?
23:17:07 <koz_> dminuoso: Thanks for all the help. I was investigating push versus pull arrays, and discovered, to my amusement, that pull arrays are covariant in the type of their data, but push arrays are _contra_variant.
23:17:25 <zincy> So we have used (.) to return a new function which pattern matches on those three cases?
23:17:25 <ski> zincy : if you're simplifying an expression, thinking of the expression as a tree, and you're currently focused on rewriting some subexpression (subtree), then the stack is the path from the root to this subtree, also including all the other subtrees on the side of this path
23:17:32 <Cale> zincy: So if we make the substitutions I mentioned above, [] -> id, [x] -> (x:) and (++) -> (.)
23:17:40 <Cale> We obtain the following function:
23:17:48 <Cale> reverse' :: [a] -> ([a] -> [a])
23:17:52 <Cale> reverse' [] = id
23:18:03 <Cale> reverse' (x:xs) = reverse' xs . (x:)
23:18:12 <Cale> This is now linear time again
23:18:15 <ski> koz_ : "pull arrays" and "push arrays" being ?
23:18:33 <Cale> and all we have to do to recover reverse is to apply the result to an empty list
23:18:39 <Cale> reverse :: [a] -> [a]
23:18:46 <Cale> reverse xs = reverse' xs []
23:18:48 * ski . o O ( accumulator-passing-style )
23:19:03 <dminuoso> koz_: So the more I think about it, I dont think a contravariant endofunctor can even exist.
23:19:04 <Cale> This is the same thing as accumulator passing, but thought of in a different way
23:19:12 <koz_> ski: A pull array is a function from indices to elements. A push array is a function of the form (ix -> a -> CM ()) -> CM (), where ix is an index type, a is the element type, and CM is a 'compilation monad', which is basically a stack of state and writer (for unique identifiers and the program being constructed to build the array).
23:19:14 <dminuoso> koz_: well. in any category worth thinking about anyway.
23:19:24 <Cale> Let's put the accumulator in
23:19:43 <Cale> Note that the type of reverse' was [a] -> ([a] -> [a])
23:19:46 <ski> koz_ : `(ix -> a -> CM ()) -> CM ()' is *co*variant in both `ix' and `a'
23:19:55 <Cale> -> is right associative anyway, so those parens are unnecessary
23:20:05 <Cale> reverse' :: [a] -> [a] -> [a]
23:20:16 <Cale> reverse' [] ys = ys
23:20:30 <koz_> ski: Why is it _co_variant in a? I must be misunderstanding something.
23:20:30 <Cale> reverse' (x:xs) ys = reverse' xs (x : ys)
23:20:50 <Cale> This is the exact same function as above, written differently
23:21:01 <Cale> Just making that extra argument explicit
23:21:39 <Cale> and here, we're effectively accumulating a new list as we walk through our input list
23:21:43 <Cale> ys starts out as []
23:21:57 <Cale> and we keep adding elements to the beginning of it
23:22:09 <Cale> until we reach the end of the input
23:22:13 <ski> koz_ : a function of type `(ix -> a -> CM ()) -> CM ()' takes as input a callback of type `ix -> a -> CM ()'. then it calls this callback some number of times, each time with an index of type `ix', and an element of type `a'. note how it's the main (higher-order) function, *not* the callback, which provides the `a's (and the `ix'es). so, the main function is a producer of `a's, not a consumer. hence it's covariant
23:22:15 <Cale> at which point it's our result
23:22:23 <Cale> zincy: make sense?
23:22:43 <zincy> Cale: Just parsing it in my mind
23:22:50 <zincy> Cale: That is a really cool trick
23:22:52 <ski> koz_ : a consumer of a consume is an (indirect) producer
23:23:09 <koz_> ski: Let me try and write the Functor instance for this one sec.
23:23:09 <ski> s/consume /consumer /
23:23:13 <koz_> That may convince me.
23:23:24 <zincy> Cale: Thanks for the explanation! :D
23:23:25 <ski> should be a piece of cake :)
23:24:24 <koz_> ski: Let's hope so, or my Haskell has really rusted.
23:24:24 <Cale> zincy: My point is, this is attainable without so much thinking about what additional argument you're going to use -- instead, thinking of it in terms of using a different type to accomplish your task, one which supports analogous but cheaper operations, and where the solution is cheaply translated back
23:24:42 <Cale> (it's just that the other type is a function type)
23:25:16 * ski . o O ( Cayley representation )
23:25:55 <Cale> You'll see this sometimes called the worker/wrapper transformation
23:26:06 <Cale> I'm not a huge fan of that name, but it's something to look up
23:26:23 <ski> (do you have a preferred name ?)
23:26:29 <zincy> awesome
23:26:34 <zincy> Will read more
23:26:41 <Cale> I don't really, I just picture a category-theoretical square in my head :D
23:26:57 <Cale> A --> A'
23:27:08 <Cale> |     |
23:27:15 <Cale> v     v
23:27:20 <Cale> B --> B'
23:27:22 <Cale> oops
23:27:26 <Cale> B <-- B'
23:27:29 <Cale> lol
23:27:33 <dminuoso> theThing :: Contramonad c => c a -> (c b -> a) -> c b
23:27:34 <dminuoso> koz_: Just imagine the funky type signatore of the =<< equivalence
23:27:35 <ski> was just going to ask about whether it was a down vs. across square, or a forward and back one
23:27:49 <Cale> It's definitely the forward and back one
23:27:55 <zincy> Cale: So the worker/wrapper transformation essentially evaluates the different cases differently and reduces the reduction steps needed?
23:28:21 <Cale> zincy: Look at my schematic diagram there (but note my correction)
23:28:27 <Cale> We're trying to write some function A -> B
23:29:06 <Cale> and instead of doing that directly, we might first convert the input to some A', write a cheaper function A' -> B', and then translate the result back B' -> B
23:29:28 <Cale> and if the translations and cheaper function add up to less than the cost of our original function, we win
23:29:42 <zincy> :)
23:29:51 <Cale> So in this case, we didn't do the initial translation -- we went directly from the input list
23:30:00 <Cale> But we targeted a different type of result
23:30:13 <Cale> Producing a function [a] -> [a] instead of a list of type [a]
23:30:26 <koz_> dminuoso: Let me try and write that Functor instance, then I'll give it a whirl.
23:30:54 <Cale> and then we translated back ([a] -> [a]) -> [a] just by applying the resulting function to the empty list
23:31:54 <Cale> and out of that kind of thinking, we got the same algorithm as the imperative program which accumulates a reversed result
23:32:30 <Cale> To show how this generalises, let's look at trees for a moment
23:32:46 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
23:33:07 <Cale> i.e. a binary tree of values of type a is either the empty tree called Tip
23:33:14 <p0a> Hello 
23:33:16 <koz_> ski: Maybe I _am_ that rusty, but when I try to write this, I get _contra_variance in a.
23:33:38 <Cale> or it's of the form Branch x l r, where x is some value of type a, and l and r are left and right subtrees of values of type a
23:33:54 <Cale> zincy: good with that?
23:34:03 <Cale> (I don't know how new you are)
23:34:10 <p0a> I have a function that looks like `tag :: (Monoid m) => JoinList m a -> m'
23:34:28 <zincy> Yeah that makes sense. A tree is a recursive data structure right?
23:34:29 <p0a> when I do ``tag (Single 1 'a')" I'm expecting the output to be 1. But I get a type instead 
23:34:32 <Cale> right
23:34:42 <p0a> Of course it is 1 but it is not shown. Why is that?
23:35:10 <Cale> So for example, we might have a value of type Tree Integer like  Branch 1 (Branch 0 Tip Tip) (Branch 2 Tip Tip)
23:35:35 <Cale> Now, let's suppose we want to write a function of type Tree a -> [a]
23:36:02 <zincy> I see a fold
23:36:04 <Cale> which flattens out a tree by putting the value at the root node between all the elements from the left subtree and the right subtree, recursively
23:36:14 <Cale> i.e.
23:36:20 <Cale> we might write naively
23:36:26 <Cale> inorder :: Tree a -> [a]
23:36:31 <Cale> inorder Tip = []
23:36:44 <Cale> inorder (Branch x l r) = inorder l ++ [x] ++ inorder r
23:37:18 <Cale> But hey, it's our expensive friend (++) again -- if the left subtrees are large, this is going to end up being expensive
23:37:44 <Cale> We can pull the exact same trick though
23:38:07 <Cale> replace [a] with [a] -> [a], [] with id, [x] with (x:) and (++) with (.)
23:38:19 <Cale> inorder' :: Tree a -> [a] -> [a]
23:38:23 <Cale> inorder' Tip = id
23:38:37 <Cale> inorder' (Branch x l r) = inorder' l . (x:) . inorder' r
23:38:49 <ski> koz_ : show your code ?
23:38:53 <Cale> and this is worst case linear time in the size of the tree, instead of quadratic
23:39:12 <Cale> and we recover the function we actually want in exactly the same way
23:39:23 <Cale> inorder t = inorder' t []
23:40:02 <Cale> It's not just lists -- you can do the same trick with ByteString
23:40:15 <Cale> That's more or less what ByteString's Builder type is
23:40:23 <Cale> It's a little fancier, but not by much
23:40:24 <zincy> Oh cool so essentially you are swapping the x in each node of the tree with a (:) partially evaluated with the x?
23:40:39 <ski> s/partially evaluated/partially *applied*/
23:41:00 <zincy> Yes sorry applied partially?Not evaluated at all.
23:41:10 <ski> p0a : how's `JoinList' defined ?
23:41:12 <Cale> It also happens to be fully evaluated :D
23:41:21 <Cale> (because it's a data constructor)
23:41:27 <Cale> But yeah
23:41:34 <koz_> ski: https://gist.github.com/kozross/164c28dc27f82c5f3e7b7ce82063e404
23:41:35 <ski> (partial evaluation is something else, not that closely related to partial application)
23:41:51 <zincy> I thought (:) was a binary not unary operator?
23:42:23 <Cale> Well, that's true
23:42:26 <ski> koz_ : i mean like, the code in which it seems to you it would be contravariant ?
23:42:47 <Cale> Though every function is secretly unary... with data constructors it's a little funny. Maybe it'll end up a lambda
23:42:53 <koz_> ski: One second.
23:43:14 <Cale> But yeah, the important thing is that (x:) is a function
23:43:17 <ski> koz_ : oh, and your `Push' there is certainly *contra*variant
23:43:31 <zincy> gotcha
23:43:32 <Cale> it's the function which adds the single element x to whatever list it's given
23:43:38 <ski> koz_ : but that's different from the `(ix -> a -> CM ()) -> CM ()' you mentioned earlier
23:43:47 <Cale> so it's our function analogue to [x]
23:43:58 <koz_> ski: I had the parentheses before, but HLint told me they didn't matter.
23:44:05 <zincy> So we are simply replacing the (++) with (:)
23:44:07 <ski> which of them ?
23:44:10 <Cale> (++) with (.)
23:44:23 <Cale> concatenation of lists becomes composition of functions
23:44:26 <koz_> Never mind, I'm just daft.
23:44:28 <koz_> Let me try again.
23:44:34 <Cale> [x] becomes (x:)
23:44:39 <Cale> and [] becomes id
23:45:12 <p0a> ski: JoinList m a = Empty | Single m a for example
23:45:16 <Cale> We're taking the function we get from doing inorder' l -- it's some function that adds some elements to whatever list it's given
23:45:23 <Cale> and compose it with the function which adds x
23:45:26 <p0a> ski: and `tag (Single m _) = m'
23:45:34 * ski . o O ( let's subtract lists )
23:45:39 <Cale> and then the function inorder' r which adds all the elements in the right subtree
23:46:00 <ski> p0a : that should work, afaiui
23:46:16 <Cale> and then once we've composed all these functions together, each composition costing only O(1)
23:46:29 <Cale> we'll apply the resulting function to an empty list
23:46:32 <p0a> ski: it works, it just doesn't show the value 
23:46:42 <p0a> ski: when I evaluate `tag (Single 1 'a')' I don't get 1 
23:46:52 <ski> p0a : in the interactor ?
23:46:56 <p0a> ski: yeah 
23:47:00 <Cale> zincy: We can again take another perspective on this, adding an explicit accumulator argument:
23:47:18 <p0a> ski: I get `tag (Single 1 'a') :: (Monoid m, Num m) => m'
23:47:18 <ski> p0a : what do you get, then ?
23:47:20 <Cale> (effectively just writing the parameter to the function we're producing)
23:47:33 <Cale> inorder' Tip xs = xs
23:47:41 <ski> p0a : an error ?
23:47:51 <Cale> inorder' (Branch x l r) xs = inorder' l (x : inorder' r xs)
23:47:57 <Cale> same program
23:48:09 <Cale> but I've unfolded the definition of (.) and id
23:48:19 <ski> p0a : hm, ok. try `tag (Single "1" 'a')'
23:48:25 <Cale> The compiler would do this inlining anyway
23:49:21 <p0a> ski: that shows "1" 
23:49:27 <Cale> zincy: So I think this way of writing the program is much less obvious than the way I wrote it first with composition.
23:49:34 <ski> (Cale : is that actually the same, now ? what about partially applying that (say on a list with bottom tail), and forcing the resulting function)
23:49:35 <p0a> ski: Is `1' treated as something general that doesn't have `Show' ?
23:49:56 <Cale> ski: All I did was inline (.) and id, so it had better be
23:50:09 <ski> p0a : i think the problem is that it wants an instance of `Monoid', but (e.g.) `Integer' is not an instance of `Monoid'
23:50:29 <Cale> Lazy evaluation is outermost first
23:50:38 <Cale> So this will end up traversing the left subtree first
23:50:43 <Cale> looking for an element
23:50:49 <ski> p0a : if you tried `tag (Single (Sum 1) 'a')', then probably that would work
23:51:04 <ski> (if you had `Sum' from `Data.Monoid' imported)
23:51:14 <koz_> ski: OK, I'm still lost, lol.
23:51:31 <Cale> The (x : inorder' r xs) will sit and wait until we're done with the whole left subtree
23:51:38 <koz_> I have no idea how to construct a (Int -> b -> CM ()) given a -> b and (Int -> a -> CM ())
23:51:43 <ski> > let myid :: Monoid m => m -> m; myid x = x in myid (1 :: Integer)
23:51:45 <lambdabot>  error:
23:51:45 <lambdabot>      • No instance for (Monoid Integer) arising from a use of ‘myid’
23:51:45 <lambdabot>      • In the expression: myid (1 :: Integer)
23:51:58 <ski> > let myid :: Monoid m => m -> m; myid x = x in myid (Sum 1 :: Sum Integer)
23:52:00 <lambdabot>  Sum {getSum = 1}
23:52:03 <Cale> zincy: Not sure how clear I'm being, but hopefully that makes sense
23:52:10 <Cale> zincy: I have to get to sleep
23:52:24 <ski> koz_ : that's backwards
23:52:32 <Cale> zincy: Remind me to tell you about folds of trees sometime
23:53:00 <koz_> ski: Sorry I'm so dense, but I think I might need this from first principles. I am _totally_ lost now.
23:53:02 <ski> koz_ : are you trying with `(Int -> a -> CM ()) -> CM ()' currently ? trying to make it a covariant or contravariant functor in `a' ?
23:53:09 <Cale> I did have a discussion about replacing data constructors (catamorphisms) on my stack :)
23:53:10 <zincy> Cale: Thanks!
23:53:23 <koz_> ski: Let me paste what I have.
23:53:31 <zincy> Calse: Will do, it makes sense now I remembered that l and r are also trees :D
23:53:32 <ski> sounds like a plan
23:53:34 <p0a> ski: why didn't I get an error then?
23:53:39 <Cale> Quite welcome!
23:53:44 <ski> p0a : i dunno
23:54:26 <koz_> ski: https://gist.github.com/kozross/164c28dc27f82c5f3e7b7ce82063e404
23:55:56 <ski> koz_ : ok, that should work
23:56:07 <koz_> ski: I have no idea what to write though.
23:56:16 <ski> what is the expected type of that hole ?
23:56:56 <ski> (you could write a signature on that `fmap'. maybe that'd help with the typed hole, not sure)
23:57:04 <koz_> (Int -> b -> CM ()) -> CM ()
23:57:12 <koz_> (well, s/CM/State Integer/ but who's counting)
23:57:19 <ski> given which types for `f' and `g' ?
23:57:52 <koz_> f :: a -> b, g :: (Int -> a -> CM()) -> CM (), right?
23:58:01 <ski> yes, good
23:58:21 <ski> so, that hole must be a function. so start by writing a function there
23:58:43 <koz_> So something like '\callback -> _' ?
23:59:01 * ski idly recalls doing typed holes in this channel, before typed holes was an extension
23:59:05 <ski> yes
23:59:18 <ski> what's the type of `callback', and what's the type of the new hole ?
23:59:46 <koz_> callback :: Int -> b -> CM (), new hole :: CM ()
23:59:53 <ski> right
