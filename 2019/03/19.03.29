00:48:26 <akr> what is the most accepted syntax for an operator standing for `flip (.)`?
00:57:20 <ongy> https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Function.html#v:-38- iirc
00:57:41 <ongy> wait, no. that's flip ($), sorry
00:59:13 <dminuoso> :t (>>>)
00:59:14 <lambdabot> forall k (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
00:59:17 <dminuoso> akr: ^-
00:59:40 <akr> dminuoso: ah, neat
00:59:44 <akr> thanks! :)
00:59:50 <akr> by the way
01:00:04 <akr> can someone link me some code that uses Category in practice?
01:00:20 <akr> or, just tell me what is a good use of it
01:00:46 <akr> maybe if you're defining some embedded DSL and you want to compose some expressions?
01:01:30 <akr> ongy: also useful to know, thank you :)
01:10:26 <one2three4five> For anyone who happened to be here when I could figure out how to tell stack where my header files are, it turns out you have to put the extra-include-dirs field in stack.yaml, not project.yaml or the .cabal file
01:18:36 <absence> is vinyl the go-to choice for extensible records, or are there other popular solutions?
01:19:58 <Cale> ongy: hey :)
01:20:19 <Cale> ongy: Yeah, I was pretty confused about what was supposed to be going on there :D
01:20:40 <Cale> absence: Depending on what you need, perhaps consider dependent-map
01:24:07 * hackage elm-street 0.0.1 - Crossing the road between Haskell and Elm  https://hackage.haskell.org/package/elm-street-0.0.1 (shersh)
01:35:27 <absence> Cale: thanks. not quite sure what i need, beyond variants of a core record with some extra fields
01:36:35 <ongy> Cale: yea, some old code, some me trying around and a lot of assumptions (that afaik are all valid) due to the nature of netlink sockets. Though your guesses were pretty good for missing the hours of research I did around the interface
01:41:42 <Cale> absence: Basically, with DMap, you define some GADT to be your keys, whose members are effectively your "field names", and then their type indices tell you what type of value goes at that key in the map
01:43:39 <Cale> and it supports the better part of Data.Map's interface, so you have lots of operations to work with
01:50:37 * hackage fungll-combinators 0.1.0.1 - GLL parser with simple combinator interface  https://hackage.haskell.org/package/fungll-combinators-0.1.0.1 (ltvanbinsbergen)
02:04:53 <absence> the old links to ghc.haskell.org now redirect to gitlab.haskell.org with a 500 error. do i have to rewrite the url somewhat, or is the server just down at the moment?
02:08:41 <merijn> absence: gitlab went down earlier today
02:08:55 <merijn> absence: It should be back according to mailing list, but I and two others have the same 500 issue
02:09:32 <merijn> absence: So I'm assuming the server just went tits up
02:11:33 <absence> ok, thanks
02:15:40 <fendor> does cabal new-repl :test:tests reload the library if i make changes to it?
02:15:54 <merijn> fendor: It should
02:16:08 <fendor> merijn, it should, but seems like it doesnt :/
02:17:18 <fendor> well, on the other hand, stack ghci just fails the test
02:17:49 <fendor> at some point, haskell tooling could be considered a comedy. 
02:18:37 <merijn> fendor: Haskell tooling has always been orders of magnitude more reliable and robust then any other language I've used, tbh. But what's the output if you use cabal new-repl?
02:19:36 <fendor> merijn, and to be fair, I never dove into anything quite as deep as with haskell
02:20:18 <fendor> i am tryign to load the tests of a project, that works fine. Then I change the lib, for more debugging output and debugging in general. If I reload, it only reloads the tests files.
02:21:33 <fendor> Should I load tests and the lib? maybe that makes sense?
02:21:42 <merijn> fendor: Can you link your cabal file?
02:23:16 <fendor> merijn, https://github.com/haskell/haskell-ide-engine
02:24:24 <merijn> hmm, I guess the dependency tracking between components isn't up to snuff
02:41:20 <Unhammer> Why does resident memory usage remain high (e.g. 63M) at step 3 of  { () <- useSomeMemory; performGC; print "step3" } ? 
02:41:24 <Unhammer> or, why would it
02:41:51 <Unhammer> I don't see how laziness should account for it, when I'm just returning ()
02:42:15 <dminuoso> Unhammer: What does `useSomeMemory` do exactly?
02:42:36 <Unhammer> parses some xml with xml-conduit and prints some numbers from the parse
02:42:46 <Cale> It's not laziness, it's just possibly not releasing memory back to the operating system.
02:42:58 <Unhammer> (working on a minimal example)
02:43:05 <Cale> Try doing the () <- useSomeMemory again
02:43:16 <Cale> and see if the memory usage continues to rise
02:44:08 <dminuoso> How does GHC manage memory allocations?
02:44:45 <dminuoso> Or rather.. where would I have to dig into to figure this out in the sources?
02:44:52 <Unhammer> it does
02:46:20 <Unhammer> but what's really strange is that now it uses 236M the first time, then I performGC and res is at 278M and then I useSomeMemory again and RES rises to 311M
02:46:37 <Cale> Unhammer: You probably want to use the heap profiler
02:47:09 <Unhammer> I've run with -hc and gotten graphs, but they didn't tell me much
02:47:15 <Cale> Perhaps useSomeMemory involves evaluating a bunch of CAFs?
02:47:32 <merijn> dminuoso: "manage" in what sense?
02:48:13 <Cale> But it's hard to say without really knowing the details.
02:48:22 <Unhammer> Cale, that's like a top-level variable?
02:49:07 <Unhammer> I can't imagine where that would happen. guess I should make a minimal enough example
02:49:17 <Cale> yeah, or something which ended up as such after compiler optimisations
02:49:18 <merijn> Unhammer: Where are you getting RES from?
02:49:22 <Unhammer> htop
02:49:33 <Cale> CAF = "constant applicative form"
02:49:43 <Unhammer> but also /usr/bin/time 
02:49:48 <merijn> I don't expect the RTS to ever release pages back to the OS (there's not really much point and a lot of work)
02:50:00 <Unhammer> aha
02:50:14 <merijn> Unhammer: What is the resident size reported by running your application with "+RTS -sstderr"
02:51:20 <merijn> Unhammer: That should give you a far more useful/accurate report of *actual* resident memory according to the RTS
02:51:37 <merijn> Unhammer: Also, is this perchance in ghci?
02:52:15 <Unhammer> not ghci, compiled with ghc -O3 --make
02:52:23 <Unhammer> ok, so 28M says RTS
02:52:33 <Unhammer> max residency
02:52:42 <Unhammer> uh
02:52:45 <Unhammer> wtf
02:53:19 <merijn> Sounds like something interesting happened :p
02:53:28 <Unhammer> 124M with twice ()<-doit
02:53:40 <Unhammer> or, ()<- useSomeMemory
02:53:57 <Unhammer> soryr, my actual code is even more incomprehensible 
02:55:31 <merijn> Unhammer: So, some comments: 1) Since GHC uses a "copy+compact" GC the memory pages allocated by the RTS will be 2x "highest RES during a GC", 2) generally once a program has allocated a page from the OS, there's is usually not much reason to ever deallocate it. If it becomes unused the OS can page it out of RAM and if you ever need the memory again (not unlikely) you don't have to reallocate it
02:56:05 <merijn> Unhammer: (h)top are notoriously unreliable for profiling memory usage because of these reasons
02:56:06 <Unhammer> https://i.imgur.com/KRXkDDQ.png ← hp2ps
02:56:31 <merijn> Unhammer: You want the plot that has a legend telling you what the red part is :)
02:56:38 <merijn> I forgot what the flag for that one was, though
02:57:13 <merijn> Also, what's the code doing? (I missed the start)
02:57:14 <Unhammer> it's something in attoparsec text
02:57:17 <Unhammer> xml-conduit
02:57:46 <EmilKarlson> merijn: I would believe that majority of devices do not have swap nowadays
02:58:13 <merijn> EmilKarlson: Only if configured by idiots
02:58:24 <EmilKarlson> thanks
02:59:07 <merijn> EmilKarlson: Swap is *not* a hacky workaround for "I don't have enough RAM" that can be abandonned now that every machine has >4 GB. Swap is *always* useful
02:59:12 <EmilKarlson> even if you set swappiness to 100 linux is still very reluctant to push anything there
02:59:53 <merijn> EmilKarlson: If nothing is getting pushed to swap, then there's also no point in releasing pages back to the OS, since there's apparently no memory pressure
03:00:12 <merijn> Unhammer: Oh, that makes sense
03:00:28 <merijn> Unhammer: You're just using the regular cursor API?
03:00:37 <EmilKarlson> that's not completely true either, but did not profile
03:01:44 <merijn> Unhammer: The regular cursor API parses the entire file, so it has to actually read the entire file into memory
03:02:02 <Unhammer> https://i.imgur.com/Q3qBr5f.png
03:02:11 <EmilKarlson> if you have ever read more than total ram amount of files, there is memory pressure
03:02:14 <merijn> Unhammer: So I would expect exactly a graph like you showed: Keep inflating until everything is loaded, then free things
03:03:08 <Unhammer> oh,the profiling build still shows 28M max residency with ()<-useSomeMemory;performGC;()<-useSomeMemory, while regular build shows 128M, so I guess regular knows better than me how much to allocate …
03:03:36 <merijn> Unhammer: Profiling can affect optimisation
03:03:45 <Unhammer> well, I am trying to get to the bottom of a memory fault on windows
03:03:56 <merijn> Unhammer: "+RTS -sstderr" also works without profiling, btw
03:04:09 <Unhammer> yeah I know
03:05:08 <Unhammer> https://hackage.haskell.org/package/xml-conduit-1.8.0/docs/Text-XML-Stream-Parse.html#v:parseBytes is this cursor?
03:05:31 <merijn> Unhammer: Ah, no, that should stream. But I'm not really sure how that affects memory consumption
03:05:43 <merijn> OTOH, 28MB seems a totally reasonable RES?
03:05:50 <Unhammer> oh, this is the tiny test file
03:06:01 <Unhammer> the real ones use gigs
03:06:06 <merijn> Ah...
03:06:25 <Unhammer> from that attoparsec thing in  https://i.imgur.com/Q3qBr5f.png 
03:07:05 <merijn> I wonder if it's the backtracking buffer of attoparsec keeping things live
03:16:28 <Unhammer> I do wish the profile builds would run a bit faster =P
03:30:07 * hackage hwormhole 0.2.0.1 - magic-wormhole client  https://hackage.haskell.org/package/hwormhole-0.2.0.1 (rkrishnan)
03:37:06 <rkrishnan> hmm.. while trying to do 'cabal upload' for the haddock documentation, I get a compilation error: "Building executable 'script' for fake-package-0.. Main.hs:1:1: error: lexical error at character '\US'". This is with cabal 2.4.1.0
03:37:57 <__monty__> rkrishnan: You might wanna ask in #hackage
03:38:13 <rkrishnan> __monty__: thanks.
03:46:27 <__monty__> rkrishnan: How thin a wrapper around the Transit library is the hwormhole exe?
03:47:57 <phadej> rkrishnan: what's your command
03:49:01 <phadej> `script` indicates that you tell cabal some command it doesn't know
03:49:16 <phadej> as in `cabal somescript.hs`
03:51:41 <rkrishnan> __monty__: the exe is pretty thin. It just sets up the Env and populates the commandline options and calls the app.
03:52:25 <__monty__> Yeah, took a look at the code : )
03:52:26 <rkrishnan> phadej: thanks. It looks like I had a typo in my command (--public instead of --publish).
03:53:22 <rkrishnan> __monty__: feedback and suggestions welcome. I am still learning how to structure haskell applications..
03:53:32 <phadej> rkrishnan: next cabal release will be a bit smarter
03:53:37 <phadej> rkrishnan: but good you sorted it out
03:53:53 <rkrishnan> phadej: thanks.
03:57:33 <tabaqui> uhm, hello
03:57:45 <tabaqui> can anyone help me with FunDeps issue?
03:58:02 <tabaqui> it's a shame, but I work with mtl for a long time, but cannot understand the problem here
03:58:04 <tabaqui> https://pastebin.com/JHy4deKq
03:58:39 <tabaqui> I remind you, that m1 and m2 cannot be the same type, because of functional dependencies in MonadState
03:59:37 * hackage easytensor 1.0.1.0 - Pure, type-indexed haskell vector, matrix, and tensor library.  https://hackage.haskell.org/package/easytensor-1.0.1.0 (achirkin)
04:01:08 <tabaqui> btw, it's a ghc-8.2.2
04:01:13 <__monty__> rkrishnan: Not really any advice on the code. I *would* recommend having a look at `croc` though. It's a magic-wormhole-like written in go but it has a great philosophy about UX.
04:01:52 <Unhammer> oh wow
04:01:54 <Unhammer> found it
04:02:21 <Unhammer> I was returning an attribute
04:02:26 <Unhammer> and that was a Text
04:02:39 <Unhammer> if I do T.copy, that avoids the memory buildup
04:04:36 <tabaqui> ghc-8.6.4 returns the same error
04:05:20 <rkrishnan> __monty__: I have looked a little bit at the internals of croc but not the UX. Thanks, I will have a look.
04:06:22 <Taneb> tabaqui: the error's to do with the way that GHC resolves constraints. It sees it needs something of the form "MonadConsole m", and then takes the (hopefully) only instance that matches that shape, without looking any further at constraints on m
04:07:48 <tabaqui> Taneb: but why it doesn't discard the first matches if it doesn't satisfy the constraints?
04:08:01 <Taneb> Because it's not very smart
04:08:36 <Taneb> I don't know if there's a techical reason why not, I'm afraid, but I suspect their might be
04:08:49 <tabaqui> ok, I hope I get it
04:08:49 <tabaqui> thank you
04:09:20 <__monty__> rkrishnan: It's mostly the core philosophy. Magic-wormhole's super useful, technically proficient users can already achieve what it does with other means usually, so a focus on fairly non-technical users is not out of place. What are they most likely to do? Try to receive a file. So the command for receiving something is just `croc worm-hole-code`. Sending is still `croc send`. This may seem minor but 
04:09:26 <__monty__> it means people can use an exe on windows to receive files just by double-clicking and entering the wormhole code. That's a lot less friction than having to open a command prompt manually.
04:09:50 <__monty__> A simple GUI can take care of the problem as well of course.
04:14:41 <dminuoso> Another logic bug caught by phantom types flowing through my application and causing a type error..
04:14:43 * dminuoso lights the candle
04:25:09 <rkrishnan> __monty__: Yes. That is pretty nice. 
04:26:16 <rkrishnan> __monty__: I have a very early prototype of an Android app (which uses a Rust version of the library) as well. File transfers are not yet supported there. But working on it.
04:29:03 <dminuoso>  % (1,2,3,4,5) & (lensProduct _1 _5) .~ (10,50) -- phadej this is nifty! Thanks. :)
04:29:11 <dminuoso> % (1,2,3,4,5) & (lensProduct _1 _5) .~ (10,50)
04:29:11 <yahb> dminuoso: (10,2,3,4,50)
04:31:13 <phadej>  % (1,2,3,4,5) & _1 ,~ 10 & _5 .~ 50
04:31:17 <phadej>  % (1,2,3,4,5) & _1 .~ 10 & _5 .~ 50
04:31:21 <phadej> % (1,2,3,4,5) & _1 .~ 10 & _5 .~ 50
04:31:21 <yahb> phadej: (10,2,3,4,50)
04:31:30 <phadej> is better though
04:31:31 <dminuoso> :t (,~)
04:31:32 <lambdabot> error: parse error on input ‘)’
04:33:20 <dminuoso> phadej: Well the primary idea is to have something like this:
04:33:22 <dminuoso> % (1,2,3,4,5) ^. (lensProduct _1 _5) . to sum
04:33:22 <yahb> dminuoso: 6
04:33:44 <dminuoso> (My use case is a bit more elaborate than this, but in principle this is it)
04:44:03 <kuribas> how can I represent in mathematics a set with a possible error value?
04:44:12 <kuribas> like the real numbers + _|_ ?
04:44:23 <kuribas> or undefined value
04:45:05 <Cale> Just union in another element like that
04:45:15 <Cale> R union {_|_} is fine
04:45:31 <kuribas> is bottom correct for an error value?
04:45:45 <Cale> Correct with respect to what?
04:45:56 <kuribas> the established meaning of _|_
04:46:46 <dminuoso> kuribas: What is the "established" meaning of _|_ according to you?
04:46:54 <Cale> Well, using _|_ suggests that there's some sort of implied partial order of which it's going to be the least element, which there is
04:47:15 <dminuoso> kuribas: https://en.wikibooks.org/wiki/Haskell/Denotational_semantics might be of some interest to you.
04:47:50 <Cale> But it doesn't really matter which symbol you use. Choose whatever you like.
05:04:28 <phadej> % toSumOf (_1 <> _5) (1,2,3,4,5)
05:04:29 <yahb> phadej: ; <interactive>:290:1: error: Variable not in scope: toSumOf :: ((a0 -> f0 b0) -> s0 -> f0 t0) -> (Integer, Integer, Integer, Integer, Integer) -> t
05:04:33 <phadej> % sumOf (_1 <> _5) (1,2,3,4,5)
05:04:33 <yahb> phadej: 6
05:04:37 <phadej> dminuoso: ^
05:04:41 <phadej> you can compose folds with <>
05:04:51 <phadej> no need to go into unsafe lands
05:07:37 * hackage record-dot-preprocessor 0.2 - Preprocessor to allow record.field syntax  https://hackage.haskell.org/package/record-dot-preprocessor-0.2 (NeilMitchell)
05:36:57 <dmwit> Oh my.
05:37:59 <dmwit> Is that... actually better?
05:41:18 <c_wraith> as long as you use it as a Fold, sure
05:44:26 <Phyx-> phadej: Hi, heard you were looking to refactor the CI script to support other CI than travis?
05:45:24 <phadej> c_wraith: you cannot use it as anything else
05:46:09 <phadej> Phyx-: you heard right, and it is refactored to the stage that it's not impossible to add other CI "backends"
05:47:05 <Phyx-> phadej: ah great, I was looking to add AppVeyor and Azure Pipelines, but since you're already refactoring I'll wait till that is done :)
05:47:34 <phadej> Phyx-: well, my plans include to add gitlab and then "wait"
05:47:41 <c_wraith> phadej: for that particular case, true.  Not always true when composing with <>
05:47:43 <c_wraith> > [1,2] & (ix 0 <> ix 1) +~ 1
05:47:44 <lambdabot>  [2,2,1,3]
05:47:48 <c_wraith> ^ don't do that!
05:48:22 <phadej> c_wraith: oh, that's nasty indeed
05:48:43 <Phyx-> phadej: lol, do you happen to be doing this on a public fork that I can use? or do you plan much churn still?
05:48:56 <phadej> Phyx-: it's all there in haskell-ci/haskell-ci
05:49:59 <phadej> Phyx-: there's HaskellCI.Travis module which puts bash into `data Travis`
05:50:14 <phadej> or actually posix sh, but anyway
05:51:27 <Phyx-> phadej: ahh ok, I looked last like 2 weeks ago so I didn't notice the merge
05:51:35 <Phyx-> phadej: thanks I can work with that
05:51:39 <phadej> my next challenge is how to reuse reusable sh-bits, but with PowerShell there aren't such problem
05:51:50 <phadej> neither there is ShellCheck :)
05:51:56 <phadej> *PowerShellCheck
05:52:04 <Phyx-> hehe
05:52:19 <Phyx-> I don't expect much scripting to be required though
05:52:37 <phadej> Phyx-: it depends how much of features of haskell-ci you want to support
05:53:04 <Phyx-> phadej: can you give me an example of what would require scripting?
05:53:51 --- mode: ChanServ set +o Sigyn
05:54:43 <phadej> Phyx-: it's relatively simple sh; but I just don't know how to even cat << EOF\ncontents to the file\nEOF in PowerShell :)
05:55:43 <phadej> and there are a little of conditioanls, as sometimes you don't want to run tests with particular GHC and so on
05:57:37 * hackage hspec-core 2.7.1 - A Testing Framework for Haskell  https://hackage.haskell.org/package/hspec-core-2.7.1 (SimonHengel)
05:57:56 <phadej> the trickiest part is probably how ot sdist files, find them, untar and continue
05:58:38 * hackage hspec 2.7.1, hspec-discover 2.7.1 (SimonHengel): https://qbin.io/music-butter-u4sl
05:59:02 <Phyx-> phadej: ah, first one I don't know off the top of my head, but the second one I usually do using the conditionals on the CI system itself. e.g. I specify it as constraints in appveyor
05:59:39 <phadej> Phyx-: there _a lot_ of small pieces which are conditional
06:00:01 <phadej> running tests, making haddocks, package set itself
06:00:16 <phadej> I mean, enough that if [ ... ]; then cmd; fi makes cleaner output
06:00:21 <phadej> but whatever works
06:01:01 <phadej> gitlab e.g. supports (or rather requires) writing separate scripts per job
06:01:12 <phadej> so it might be ok to just generate n copies
06:01:26 <absence> is there a better way to obtain the (Maybe) result in bracket's release action than using something like MVar? an alternative to bracket perhaps?
06:02:08 <merijn> absence: ENOCONTEXT :)
06:02:45 <absence> merijn: you want more context for the question?
06:03:02 <dminuoso> % (ala Min . foldMapOf) (_1 <> _2 <> _4) (1,2,3,4)
06:03:02 <yahb> dminuoso: 1
06:03:10 <merijn> absence: "the Maybe" which maybe are you talking about? bracket doesn't have "maybe"
06:03:10 <dminuoso> phadej: Okay this is truly fancy. :)
06:03:41 <dminuoso> % _Left <> _Right
06:03:41 <yahb> dminuoso: ; <interactive>:309:1: error:; * No instance for (Show (p0 b0 (f0 b0) -> p0 (Either b0 b0) (f0 (Either b0 b0)))) arising from a use of `print'; (maybe you haven't applied a function to enough arguments?); * In a stmt of an interactive GHCi command: print it
06:03:44 <dminuoso> % :t _Left <> _Right
06:03:44 <yahb> dminuoso: (Semigroup (p (Either b b) (f (Either b b))), Choice p, Applicative f) => p b (f b) -> p (Either b b) (f (Either b b))
06:03:49 <dminuoso> Wew. :o
06:03:59 <absence> merijn: ah yes, i said maybe because the action to run might throw an exception, in which case there's no result to hand to the release action
06:04:13 <dminuoso> That context though...
06:04:18 <merijn> absence: The release doesn't run if the allocation fails
06:04:28 <merijn> absence: Because there's not to release if the allocation fails
06:04:59 <absence> merijn: that's fine. but the actual action to run (third argument) can complete or throw an exception
06:05:14 <absence> merijn: the release action would run either way
06:05:19 <merijn> absence: Right
06:05:31 <merijn> absence: So, what's the question?
06:05:48 <absence> and in the release action i want the result of the actual action, if there is a result
06:06:17 <merijn> absence: I would recommend not wanting that :p Because that way lies madness and impossible to debug code
06:06:26 <merijn> absence: What do you plan to use that for?
06:06:32 <absence> logging
06:06:58 <merijn> absence: So just log the result just inside the main action?
06:07:13 <absence> merijn: then i don't get a log if the main action fails before it logs
06:07:29 <merijn> absence: You can log in two places, though?
06:07:41 <absence> then i get double logging
06:07:59 <absence> if the main action succeds, both it and the release action will log
06:08:39 <merijn> Doesn't seem like a huge issue?
06:08:55 <dmwit> Indeed, it seems desirable.
06:10:01 <absence> how is it desirable? it means i can't produce a log message that says whether it succeded or failed
06:10:40 <merijn> Actually you can just log inside the action for both the failure and success case
06:11:04 <merijn> absence: You can just log inside "onError" for failure and have the "success" log after that
06:11:04 <absence> merijn: i don't follow..
06:11:22 <merijn> So if the action throws, it will trigger onError, then exist the bracket
06:11:34 <merijn> If it doesn't error, the onError is a no-op and the final success log triggers
06:11:42 <absence> merijn: what onError? do you mean to catch the exception inside the main action?
06:11:52 <merijn> absence: onError doesn't catch exceptions
06:12:00 <merijn> It just runs an action in case one happens
06:12:48 <merijn> bracket alloc free $ \resource -> (myAction resource `onError` logFailure) >> logSuccess
06:12:51 <merijn> Done
06:14:17 <dexterfoo> Is there a version of Data.Unique that works in STM instead of IO?
06:16:12 <kuribas> Cale: yeah, makes sense
06:17:02 <dmwit> dexterfoo: I think unsafeIOToSTM will get you there.
06:17:09 <dmwit> dexterfoo: Check out this comment in the source of Data.Unique:
06:17:20 <absence> merijn: hm.. is that in the exceptions package? i don't use it currently, but i guess onExceptions would do the trick as well
06:17:29 <dmwit> "IORef version can be used with unsafeIOToSTM inside STM, because if the transaction retries then we just get a new Unique."
06:17:45 <merijn> absence: onError is just from Control.Exception, should be in exceptions oo
06:18:16 <merijn> oh, wait it's onException
06:18:25 <merijn> I blame stupid naming inconssitency
06:18:35 <merijn> (since it's bracketOnError, but onException)
06:18:50 <absence> merijn: there is an onError in the exceptions package though, to make it confusing :)
06:19:14 <kuribas> dminuoso: could I define S_{_|_} as S `union` {_|_}
06:19:15 <dexterfoo> dmwit: cool thanks. would be cool if the next version of Data.Unique would directly include a function newUniqueSTM :: STM Unique
06:19:20 <absence> merijn: anyway, that looks like what i want. thanks!
06:19:22 <kuribas> dminuoso: that would be easier to read
06:19:37 <kuribas> dminuoso: (S subscript _|_ )
06:27:26 <fryguybob> dexterfoo: I think the unsafe is appropriate in this case as  unsafeIOToSTM newUnique  introduces observable non-determinism that is not transactional.
06:31:37 * hackage dlist 0.8.0.6 - Difference lists  https://hackage.haskell.org/package/dlist-0.8.0.6 (SeanLeather)
06:33:36 <dminuoso> kuribas: You can define whatever notation you want.
06:33:57 <dexterfoo> fryguybob: how is it observable?
06:34:15 <fryguybob> dexterfoo: hashUnique
06:34:53 <dexterfoo> fryguybob: but isn't that non-deterministic even with regular (non-STM) usage of Unique?
06:35:30 <fryguybob> dexterfoo: For as silly example:  atomically $ do x <- unsafeIOToSTM newUnique ; if odd (hashUnique x) then retry else return x
06:35:40 <fryguybob> This will cause an exception
06:35:54 <fryguybob> But if `newUnique` was transactional it would not.
06:36:24 <fryguybob> Implementation details are leaking through and the unsafe gives a hint that that might happen.
06:36:52 <fryguybob> That said, I can't think of a program that you would want to write in this particular case that would have a problem.
06:37:19 <dexterfoo> i don't understand. whate exception will that code raise?
06:37:57 <fryguybob> dexterfoo: If you try to retry with an empty read-set it will never wake up so you get a blocked indefinately on STM.
06:38:06 <fendor> in ghc library, how can I get a Name from a Type?
06:39:13 <phadej> fendor: if type is TyCon yes
06:39:19 <phadej> but "Maybe Int" doesn't have a name
06:39:20 * fryguybob has to run.
06:39:22 <dexterfoo> fryguybob: now i understand. thank you
06:39:40 <fendor> phadej, but "Int" is?
06:39:48 <phadej> fendor: yeah, it's a TyCon
06:40:07 <fendor> so, pattern match on whether it is a TyCon?
06:42:07 * hackage MiniAgda 0.2019.3.29 - A toy dependently typed programming language with type-based termination.  https://hackage.haskell.org/package/MiniAgda-0.2019.3.29 (AndreasAbel)
06:44:21 <Solonarv> haha, that versioning scheme
06:44:42 <Solonarv> that's not PvP-compliant!
06:44:50 <phadej> fendor: i'd try tcRepSplitAppTy_maybe
06:45:07 <fendor> i remember... 
06:45:28 <fendor> isnt there also something for typedefs? 
06:45:44 <phadej> fendor: you mean type Foo = Int ?
06:45:48 <phadej> and you want `Foo` ?
06:45:57 <fendor> yeah, for example
06:46:06 <phadej> that I don't know :(
06:46:07 * hackage fakefs 0.1.0.0 - Extensible fake file system for testing.  https://hackage.haskell.org/package/fakefs-0.1.0.0 (igrep)
06:46:38 <fendor> i will see, thank you a lot!
06:46:45 <phadej> fendor: it also depends in which stage you are
06:47:14 <phadej> as e.g. type-checker doesn't "care" about typedefs anymore, so recovering them might be hard
06:47:37 <phadej> but yet, in renamer it's all different
06:48:06 <fendor> phadej, I dont think i need to recover them, I have the sources, so maybe someone knows them? we will see, in the worst case, it doesnt work for type defs
06:48:32 <phadej> fendor: I mean
06:48:34 <phadej> :t _1
06:48:35 <lambdabot> (Functor f, Field1 s t a b) => (a -> f b) -> s -> f t
06:48:38 <phadej> no more "Lens"
06:49:02 <Solonarv> sure, the typedefs are in scope and you could search through them
06:49:24 <phadej> but then _1 :: ALens (Int, Bool) Int
06:49:29 <phadej> :t _1 :: ALens (Int, Bool) Int
06:49:30 <lambdabot> error:
06:49:30 <lambdabot>     • Expecting two more arguments to ‘ALens (Int, Bool) Int’
06:49:30 <lambdabot>       Expected a type, but ‘ALens (Int, Bool) Int’ has kind ‘* -> * -> *’
06:49:34 <phadej> :t _1 :: ALens' (Int, Bool) Int
06:49:35 <lambdabot> ALens' (Int, Bool) Int
06:49:40 <phadej> that's not expanded
06:49:50 <phadej> so you might be lucky, or might not :)
06:50:15 <Solonarv> but if I write 'theAnswer :: Int; theAnswer = 42' and there happens to be a 'type Offset = Int', do you want to get back 'Int' or 'Offset' when looking up the type of theAnswer ?
06:50:50 <fendor> I think I want the declared type, so theAnswer should give me "Int"
06:54:34 <gentauro> Anybody in CPH the 2019-04-25? Please come by to listen to Simon Marlow :-) -> https://www.meetup.com/MoedegruppeFunktionelleKoebenhavnere/events/rqbcdlyzgbnc/
07:09:25 <dminuoso> % ('a', [Just 'c', Just 'd']) ^.. (_1 <> _2 . singular (each . _Just))
07:09:25 <yahb> dminuoso: "ac"
07:09:39 <dminuoso> phadej: Okay this Monoid instance is quite amazing. :)
07:09:50 <dminuoso> Or I guess Semigroup rather.
07:10:47 <lavalike> % :t singular
07:10:47 <yahb> lavalike: (Conjoined p, Functor f) => Traversing p f s t a a -> Over p f s t a a
07:12:25 <dminuoso> % (ala Product . foldMapOf) (_1 <> _2 . singular (each . _Just)) (1, [Just 2, Just 3])
07:12:26 <yahb> dminuoso: 2
07:13:53 <ProofTechnique> I swear that took a good 30 seconds to grok, but now that I get it it's quite neat
07:15:40 <dminuoso> I guess the `singular (each ...` is a bit silly, since you could just use 
07:15:58 <dminuoso> % (ala Product . foldMapOf) (_1 <> _2 . ix 1 . _Just)) (10, [Just 20, Just 30])
07:15:58 <yahb> dminuoso: ; <interactive>:324:52: error: parse error on input `)'
07:16:04 <dminuoso> % (ala Product . foldMapOf) (_1 <> _2 . ix 1 . _Just) (10, [Just 20, Just 30])
07:16:04 <yahb> dminuoso: 300
07:19:11 <absence> is HasField meant to be used directly in apps for extending records, or for implementing libries like vinyl?
07:23:14 <dmwit> Solonarv: Bumping the A in A.B.C.D on every release is PVP compliant, no matter what changes were made to the library.
07:24:15 <dmwit> I don't *know* if the author maintained the discipline necessary to make sure they bumped A each time the modified date wasn't enough of a bump, but it would certainly be *possible* to use that versioning scheme and still be PVP-compliant.
07:25:07 <Solonarv> dmwit: well, this is not the first version and it starts with a 0
07:25:20 <Solonarv> (I checked)
07:25:24 <dmwit> Yep. That still doesn't mean it's not PVP-compliant.
07:25:35 <Solonarv> the versions are all 0.YEAR.MONTH.DAY
07:25:41 <dmwit> With only 2-3 releases per year, it's possible that there's never been a situation yet where a major bump was needed within a single year.
07:26:05 <dmwit> (And that there's never been a situation yet where a minor bump was needed within a single month.)
07:26:26 <Solonarv> I guess that's PvP-compliant if you break API at most once a year, yeah
07:26:33 <ProofTechnique> I mean, if they had one, they could just do `1.2019.MONTH.DAY`
07:26:41 <dmwit> ProofTechnique: Yes, this was my original point.
07:27:56 <dmwit> (s/at most once a year/only on the first release of any year/)
08:01:37 * hackage flush-queue 1.0.0 - Concurrent bouded blocking queues optimized for flushing. Both IO and STM implementations.  https://hackage.haskell.org/package/flush-queue-1.0.0 (lehins)
08:41:22 <tabaqui> oh, I have an idea for new extension
08:41:47 <tabaqui> sometimes one must repeat the same code in different contexts
08:41:50 <tabaqui> like 
08:42:17 <tabaqui> dunno
08:42:44 <tabaqui> firstFunction ctx = let release = doSmthWith ctx in ...
08:42:55 <tabaqui> secondFunction ctx = let release = doSmthWith ctx in ...
08:43:36 <tabaqui> and you cannot move release into the global scope because it requires `ctx` binding
08:44:24 <tabaqui> Proposal: release :: (&Promised Context ctx) => Context -> a; release = ...
08:44:42 <Cale> That feature exists, it's called implicit parameters
08:44:55 <tabaqui> nah, it sucks mostly
08:45:32 <tabaqui> hm, but I cannot make it much more convenient
08:46:10 <tabaqui> we can avoid just these "let ?ctx = ctx in", but it is not a big deal
08:46:19 <tabaqui> ok, I'll think about it :)
08:49:28 <Cale> Perhaps we could allow implicit parameters to be bound by lambdas (and argument patterns in a function binding)
08:49:41 <Cale> So that you could write  firstFunction ?ctx = ...
08:50:48 <Cale> However, I'm not sure this is really the right solution to this problem.
08:53:11 <tabaqui> it is something at least, I think it can be used not in lambdas only
08:53:26 <tabaqui> f :: Int -> (); f ?in = ...
08:54:01 <tabaqui> so f doesn't read ?in from higher scope, but will send it's argument in lower scopes
08:54:12 <Cale> Yeah, that's what I was referring to by "argument patterns in a function binding"
08:54:30 <fr33domlover> o/ my web app uses PostgreSQL and I need to give it a delivery mechanism (running http POSTS in the background). This could be in-memory but in case of app restart/error etc. I need incomplete deliveries to persist. One way to do this is simply add a DB table. Are there better/recommended ways? 
08:55:04 * tabaqui is learning how to read a text inside brackets
08:55:11 <fr33domlover> (Each delivery starts by storing the payload, doing the http request, and deleting from DB once done etc.)
08:55:58 <fr33domlover> I wonder if this is a kind of thing people do with red is?
08:56:01 <fr33domlover> *redis
08:57:07 * hackage haskoin-store 0.13.0 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.13.0 (xenog)
08:57:54 <Cale> fr33domlover: I didn't tell you this existed, I was never here. (It's a mostly-unsupported, but technically open source library from Obsidian) https://github.com/obsidiansystems/rhyolite/blob/develop/backend-db/Rhyolite/Backend/TaskWorker.hs
08:59:13 <Cale> As you can see at the top, there are a bunch of caveats still, but this is the kind of thing we typically do for that.
09:00:12 <Cale> Oh, this relies on groundhog, that's a bit unfortunate...
09:00:51 <Cale> You could do the same stuff with postgresql-simple though
09:01:29 <merijn> FLTKHS looks amazingly usable, too bad it looks so...retro >.>
09:09:39 <lyxia> tabaqui:  have you seen this https://github.com/ghc-proposals/ghc-proposals/pull/40
09:10:17 <fr33domlover> Cale, I already use persistent/esqueleto and if I store that stuff in PostgreSQL I'll just use what I already use :)
09:10:54 <tabaqui> lyxia: nope, let me check it out
09:12:28 <Cale> fr33domlover: yeah, it's just unfortunate you'll probably not be able to just import that library
09:14:07 <fr33domlover> Cale, what would that library do for me though?
09:14:30 <fr33domlover> I mean, in my case the DB queries are trivial, I'm just wondering which DB to use
09:15:19 <tabaqui> lyxia: well, it looks promising but doesn't solve my specific problem
09:15:33 <Cale> fr33domlover: It just manages a table of tasks which have an associated action to asynchronously perform like your http requests
09:15:51 <tabaqui> If understood correctly, one has to group all functions involved in a context together
09:16:09 <Cale> That proposal is... probably never happening
09:16:49 <tabaqui> I actually don't know how ghc is evolving
09:17:37 <tabaqui> I think that author can be passionate enough to develop this feature and push into the master
09:17:37 * hackage lentil 1.1.2.0 - frugal issue tracker  https://hackage.haskell.org/package/lentil-1.1.2.0 (fffaaa)
09:18:33 <hawnzug> quit
09:21:25 <Cale> tabaqui: Well, read the thread ;)
09:25:46 <Cale> fr33domlover: Oh, is there any reason you'd actually want to use something other than your existing database?
09:31:50 <fr33domlover> Cale, I don't have performance problems so it's definitely easiest to just use the existing DB. But I noticed many projects out there use stuff like redis for job queues etc. and also the nature of the data is that most of it will be inserted, and then deleted again after a few seconds, so I'm just wondering about best practices, in particular ones specific to Haskell. For example I saw Haskey which is a
09:31:53 <fr33domlover> key-value store written in Haskell; I wonder if such things (and LMDB etc.) would be more idiomatic solutions (gather old failed work once on program startup and later once an hour or so, not care if that rare query is a bit slow; otherwise most of the time you just insert a JSON object and delete it by its unique ID)
09:43:37 * hackage datadog-tracing 1.3.2 - Datadog tracing client and mock agent.  https://hackage.haskell.org/package/datadog-tracing-1.3.2 (fommil)
09:47:34 <fresheyeball> hey folks
09:47:48 <fresheyeball> so the #1 thing my computer does is GHC and Nix
09:48:09 <fresheyeball> is there a CPU or general hardware configuration you would recommend?
09:48:10 <dminuoso> Congratulations, that makes you officially a functional nerd.
09:48:38 <fresheyeball> I am build a new desktop, and since my computer is so single purpose, I wonder if there is a hardware config that is ideal
09:48:38 <dminuoso> fresheyeball: Not really.
09:48:47 <fresheyeball> more cores? less cores?
09:48:52 <hpyCdr> should the votes / rating be removed from hackage? There's packages with > 10k downloads and 1 vote
09:49:03 <fresheyeball> hpyCdr: yes
09:49:53 <fresheyeball> more L2 cache? I was thinking of going AMD
09:50:13 <fresheyeball> dminuoso: I know, its happened
09:50:28 <fresheyeball> I just want to shrink those build times
09:50:33 <dminuoso> fresheyeball: There's not really any reasons to pick hardware particularly suited to nix or GHC as long as the hardware is supported by GHC.
09:50:51 <dminuoso> fresheyeball: Is it going to be a desktop computer or a laptop?
09:50:58 <fresheyeball> dminuoso: so I should consider a dual core just as good? I think not.
09:51:00 <fresheyeball> Desktop
09:51:10 <fresheyeball> I have free reign to get what I need
09:51:33 <dminuoso> fresheyeball: Then it matters not, really.
09:52:11 <fresheyeball> dminuoso: I am positive that if I testing build times on different hardware configurations, there would be a winner
09:52:27 <fresheyeball> I can't do that, so I am asking if anyone has advice
09:52:39 <dminuoso> fresheyeball: The reasons for picking some particular hardware would be orthogonal to Haskell or Nix. Say I would pick AMD for a processor because Intel has a recent history of design issues leaking into security problems.
09:53:16 <dminuoso> fresheyeball: As long as you have enough RAM for the projects you work on and run off an SSD, there's not much to optimize.
09:54:18 <dminuoso> But since its a desktop PC, upgrading RAM if the need arises is trivial (if you let it have spare slots)..
09:54:31 <deathcap> LYAH question here: I'm on the recursive data structures chapter, and I totally understand the "data List a = Empty | Cons a (List a)" bit
09:55:10 <deathcap> but with either no introduction or a missed introduction, the book startsu sing :-: as an infix Cons
09:55:26 <deathcap> ...what is :-: ?
09:55:42 <dminuoso> deathcap: Which chapter?
09:55:59 <deathcap> 8
09:56:03 <dminuoso> deathcap: Ah, it says right above
09:56:19 <dminuoso> deathcap: So equivalently to operators, you can define "operator" data constructors.
09:56:34 <dminuoso> % f >< g = f - g
09:56:34 <yahb> dminuoso: 
09:56:39 <dminuoso> % 7 >< 4
09:56:39 <yahb> dminuoso: 3
09:56:52 <dminuoso> (><) is just an infix function.
09:57:12 <dminuoso> % data List a = Empty | a :-: (List a) deriving (Show, Read, Eq, Ord); infixr 5 :-:  
09:57:12 <yahb> dminuoso: 
09:57:46 <dminuoso> % :t (:-:)
09:57:46 <yahb> dminuoso: a -> List a -> List a
09:57:59 <dminuoso> Do you notice that this is just Cons but disguised as an operator?
09:58:30 <deathcap> yeah, i see that it's just cons described as an operator. And I know that ":" is just cons.
09:58:39 <deathcap> but where does the remaining "-:" come from?
09:58:58 <dminuoso> deathcap: :-: is unrelated (well...) to :
09:59:11 <deathcap> is it a standard function though?
09:59:17 <dminuoso> deathcap: No, it was defined on the spot
09:59:21 <deathcap> ...how
09:59:22 <dminuoso> data List a = Empty | a :-: (List a) deriving (Show, Read, Eq, Ord)  
09:59:23 <dminuoso> deathcap: ^- here
09:59:37 <dminuoso> deathcap: There's an intermediate step you could have taken:
09:59:45 <dminuoso> data List a = Empty | a `Cons` (List a) deriving (Show, Read, Eq, Ord)
09:59:50 <deathcap> but how does the compiler know that that :-: is an infix cons?
10:00:00 <dminuoso> deathcap: Because it was specified in the data declaration right there.
10:00:11 <dminuoso> data List a = Empty | a :-: (List a) deriving (Show, Read, Eq, Ord)
10:00:50 <deathcap> I'm not understanding how that specifies it.
10:00:59 <dminuoso> deathcap: Lets consider a simpler example:
10:01:03 <deathcap> like i understand what Cons is from my time doing lisp.
10:01:07 <dminuoso> data Pair x y = Pair x y
10:01:15 <dminuoso> We could replace the Pair data constructor with an operator
10:01:19 <geekosaur> deathcap, if you mean syntactically, infix constructors all start with a colon
10:01:32 <dminuoso> data Pair x y = (:<>) x y
10:01:37 <geekosaur> and infix operators in general are symbols or are names wrapped in backticks
10:02:07 <dminuoso> And we are given the freedom to move this into infix position without changing the meaning
10:02:15 <dminuoso> data Pair x y = x :<> y
10:02:26 <dminuoso> Then we can construct pairs by specifying: 1 :<> 2
10:02:40 <dminuoso> Now we have handrolled our own version of (,)
10:02:44 <deathcap> okay, that bit is making sense to me.
10:03:23 <deathcap> so "Cons a (List a)" is equivalent to (:-:) a (List a)?
10:04:01 <dminuoso> Yes.
10:04:28 <deathcap> so starting with a colon means it's an infix constructer per haskell syntax.
10:04:31 <dminuoso> deathcap: https://gist.github.com/dminuoso/ede5134b26328375e022e4b269a6028a
10:04:43 <deathcap> and the ending colon is the cons operator?
10:05:59 <Axman6> data List a where   Nil :: List a;   (:-:) :: a -> List a -> List a;
10:06:13 <Solonarv> no - :-: is a single operator, you can't "pull it apart" into : and -: any more than you can pull apart Cons into C and ons
10:06:27 <dminuoso> deathcap: You could have written it as :<> too
10:06:34 <dminuoso> deathcap: Or any other set of characters you liked.
10:06:59 <deathcap> Solonarv I get that, I'm just trying to understand the meaning of the notation.
10:07:08 <dminuoso> deathcap: There's no meaning attached to it.
10:07:11 <Axman6> deathcap: in Haskell, we can name our constructions either any work beginning with a capital letter, or as an infix constructor as long as it starts with :, so we can have data List a = a :@%#$#%@#%$%^#%$#^ List a | Nil if we want
10:07:13 <dminuoso> Its a completely arbitrary infix operator name.
10:07:15 <Solonarv> when we write 'data Pair x y = MkPair x y' we are defining the constructor MkPair
10:07:16 <Solonarv> when we write 'data Pair x y = x :<> y' we are defining the constructor :<>
10:07:41 <dminuoso> deathcap: We have the ability to make up data construtor operators with (somewhat) arbitrary names.
10:07:49 <dminuoso> deathcap: They just need to start with a colon :, that's all.
10:08:07 <dminuoso> % data List a = a :% List a | Nil
10:08:07 <yahb> dminuoso: 
10:08:11 <dminuoso> % data List a = a :! List a | Nil
10:08:11 <yahb> dminuoso: 
10:08:18 <dminuoso> % data List a = a :- List a | Nil
10:08:18 <yahb> dminuoso: 
10:08:21 <dminuoso> % data List a = a :-: List a | Nil
10:08:21 <yahb> dminuoso: 
10:08:38 <dminuoso> Its all the same. The choice of :-: is relatively arbitrary. It was probably chosen because of convention and the authors preference.
10:08:51 <deathcap>  I feel like I'm on an alien planet. 
10:09:05 <deathcap> ...and need to re-read some stuff a bit more closely.
10:09:17 <dminuoso> deathcap: :%, :!, :- and :-: all take the role of Cons.
10:09:26 <deathcap> yes, i see that.
10:09:40 <Axman6> deathcap: are you happy that the expression data List a = Nil | Cons a (List a) _defines) both Nil and Cons? where Nill has the type List a, and Const has the type a -> List a -> List a?
10:10:20 <deathcap> ...
10:10:21 <deathcap> wait.
10:10:23 <deathcap> ....
10:10:24 <deathcap> OH!
10:10:30 <deathcap> OHHHHHHHHHH
10:10:42 <Axman6> uh, Nil and Cons*
10:11:15 <deathcap> Cons is a value constructor
10:11:18 <deathcap> yes?
10:11:20 <Axman6> yes
10:11:27 <deathcap> (lightbulb came on)
10:11:30 <dminuoso> deathcap: The only specialty is that if you want an infix operator, it *has* to start with a colon. But that fact does not make it related to the list (:) cons at all (it's perhaps an artifact of making lexing/parsing easier *shrugs*)
10:11:42 <deathcap> I get it now.
10:12:02 <deathcap> I was thinking Cons had some special meaning.
10:12:08 <Axman6> List <A> Nil(); List<A> Cons(A a, List<A> as); if you prefer something a little more Java-y =)
10:12:14 <Axman6> nope
10:12:32 <deathcap> yep, that was my conceptual issue!
10:12:45 <Axman6> there's very in Haskell which you can't define yourself. Bool is just data Bool = False | True
10:12:47 <deathcap> cause when I see cons I think of it as something like this
10:12:47 <dminuoso> deathcap: The beauty is, this `List` data type that is created there is the list itself!
10:13:04 <dminuoso> deathcap: And it turns out that this is, more or less, precisely how lists are implemented in GHC too. That is, lists in Haskell are not builtin special magic.
10:13:17 <dminuoso> (Only the syntax to create them is slightly special, you can think of it as syntax sugar)
10:13:20 <Axman6> @src []
10:13:20 <lambdabot> data [] a = [] | a : [a]
10:13:51 <Axman6> (the sybtax for lists are full od syntax sugar though, you aren't allower to actually write that yourself)
10:14:06 <deathcap> (cons 5 '(1 2 3 4)) ; (5 1 2 3 4)
10:14:07 <Axman6> seems I have a cold tonight
10:14:23 <deathcap> my clojure past is assigning meaning there that isn't.
10:14:24 <dminuoso> deathcap: we think of cons *slightly* differently
10:14:52 <dminuoso> deathcap: A list [1,2,3] is just `1 : (2 : (3 : []))` in disguise.
10:15:23 <deathcap> which makes sense.
10:15:34 <Axman6> Cons always has exactly one a and one List a inside it
10:15:35 <dminuoso> And that : is just a data constructor.
10:15:36 <deathcap> syntactic sugar is great for writing but seems to always trip me up when learning new concepts.
10:16:10 <dminuoso> deathcap: Indeed it can be confusing. And Haskell being very terse in many areas can trip you up many times. :(
10:17:03 <deathcap> It's funny cause i started my programming life in Perl: completely different but filled with all sorts of arcane incantations.
10:17:47 <deathcap> so i've gone terse -> verbose -> terse (but completely unrelated)
10:18:23 <dminuoso> deathcap: The consequence of what I told you, is that since (:) is just a data constructor, you can pattern match on it.
10:18:35 <dminuoso> Just like you can pattern match on any data constructor.
10:18:39 <deathcap> :O
10:19:21 <dminuoso> deathcap: You have probably done it already: f (x:xs) = ...
10:20:11 <dminuoso> Or with the List a constructoin: f (Cons x xs) = ...
10:20:17 <deathcap> absolutely! which, well, i've been thinking of similar to Clojure's (let [[x & xs] arbitrary-seq])
10:20:55 <dminuoso> deathcap: They are so equivalent, that you can unsafeCoerce one representation into the other (and it usually works). (The point is not that you should do this, but to recognize that a user created List a is equivalent to what GHC does)
10:21:29 <dminuoso> That for me was quite a revelation.
10:22:28 <Athas> GHC is in the weird position that ':' is standard, but '$' is magic!
10:23:41 <deathcap> % :t :
10:23:41 <yahb> deathcap: ; <interactive>:1:1: error: parse error on input `:'
10:24:03 <deathcap> % :t List
10:24:03 <yahb> deathcap: IsList l => [Item l] -> l
10:25:04 <deathcap> Hm. I must read more.
10:25:07 <Cale> Athas: There's apparently a sensible way to make $ less magic
10:25:34 <deathcap> $ is the function applicator, right?
10:25:40 <deathcap> (i'm still in review mode)
10:25:46 <Cale> yeah
10:25:50 <Cale> f $ x = f x
10:25:54 <Athas> Cale: couldn't it just be given a more complex type?  I thought the only reason for the magic was to let it work with runST while lying about the type.
10:26:07 <Cale> but with the lowest possible precedence
10:26:16 <Cale> Athas: It's not that the type is wrong
10:26:29 <Cale> it's that you can't infer an instantiation of a type variable at a polymorphic type
10:26:38 <Cale> :t ($)
10:26:39 <lambdabot> (a -> b) -> a -> b
10:26:49 <Athas> Oh yeah, that's it.
10:26:52 <Cale> :t runST
10:26:53 <lambdabot> (forall s. ST s a) -> a
10:27:21 <Cale> Type inference will never try a ~ (forall s. ST s a0)
10:27:24 <deathcap> so in the source, is there an infixl $ -1098498273847239487
10:27:27 <deathcap> or something akin to that
10:27:27 <dminuoso> deathcap: No.
10:27:34 <dminuoso> deathcap: ($) itself is very simple.
10:27:45 <dminuoso> deathcap: What they are talking about is a dark deep edge case you do not need to concern yourself with
10:27:52 <dminuoso> deathcap: ($) = id
10:27:55 <dminuoso> deathcap: Plain and simple.
10:27:58 <deathcap> okie dokie
10:28:13 <Cale> hm?
10:28:15 <dminuoso> deathcap: Plus a fixity declaration (which is what makes ($) useful)
10:28:21 <Cale> No, there's definitely a fixity declaration
10:28:30 <Cale> That's what deathcap was asking about
10:29:00 <Cale> It's sadly not infixl though, it's infixr 0
10:29:00 <dminuoso> deathcap: You can discover this yourself
10:29:14 <Cale> It always should have been infixl 0
10:29:22 <Cale> But too late to change that now
10:29:24 <deathcap> and that concept is somethging i'm still wrapping my brain around
10:29:28 <dminuoso> deathcap: https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html
10:29:35 <geekosaur> : as prefix for infix constructors derives from the (:) operator, but more as "since it's already there", there otherwise being no obvious "uppercase symbol character"
10:29:35 <deathcap> maybe i ought to get mad to reading before i get lost again.
10:29:37 <dminuoso> deathcap: Search for "infixr 0  $"
10:29:54 <dminuoso> Cale: Mmm, why would infixl make more sense?
10:30:19 <geekosaur> people argue about this :)
10:30:25 <Cale> Well, a couple reasons. First of all, it lets you remove more parens
10:30:34 <dminuoso> geekosaur: I have never heard this bikeshedding before, so Im curious. ;)
10:30:47 <Cale> Currently, you can always write  f $ g $ h $ x  as f . g . h $ x
10:30:48 <Athas> Just define £ as an infixl variant.  There's plenty of currency symbols to go around.
10:31:02 <Cale> But there's nothing to be done about  f (g x) (h y)
10:31:21 <dminuoso> Oh so with infixl you could write: f $ g x $ h y
10:31:21 <Cale> With left associativity, you would have f $ g x $ h y
10:31:24 <Cale> yeah
10:31:24 <dminuoso> Right. 
10:31:25 <geekosaur> the current setup is for symmetry with function application and partial application. which is defensible, but as Cale says the other lets you get rid of more parentheses.
10:31:33 <Cale> and then the real reason: $!
10:31:44 <geekosaur> that said, a lot of people think getting rid if more parentheses is inviting more difficult to read code
10:31:44 <dminuoso> % :t ($!)
10:31:44 <yahb> dminuoso: (a -> b) -> a -> b
10:31:49 <Cale> Have you ever tried to use $! with a multiparameter function?
10:31:53 <geekosaur> *of
10:32:06 <dminuoso> Cale: Cant say I have, since I have not really consciously seen this before.
10:32:07 <Cale> If you have f x y z and you want to make the first application strict
10:32:20 <Cale> you have to write (f $! x) y z
10:32:54 <dminuoso> geekosaur: Curiously I have started to re-embrace writing parens, simple code and pointful code ever since I touched GHC code.
10:33:04 <shapr> deathcap: how would you compare/contrast Perl and Haskell?
10:33:24 <dminuoso> Cale: Fair enough, I can see why that would be useful there too.
10:33:42 <deathcap> similarities: they're both very expressive and terse.
10:34:10 <Cale> dminuoso: of course, you'd end up writing f $! x $ y $ z
10:34:16 <deathcap> differences: almost everything else, from what i can tell. :p
10:34:25 <Cale> But if your application already looked like that, it'd be easy to make anything strict
10:34:52 <Cale> But yeah, there's no way to change $ at this point
10:35:09 <dminuoso> deathcap: Interestingly it's especially Haskellers who I found to consider Perl the most enjoyable "scripting language" in the realm of Perl, Ruby, Python et al.
10:35:22 <deathcap> I HATE Python
10:35:23 <dminuoso> deathcap: Based on various discussions on #haskell and reddit.
10:35:52 <Cale> I hate all of those, but maybe Python the least? I don't know.
10:35:53 <deathcap> nothing about it is convenient, they say it's "more readable" but it's mostly just frustrating and I really don't like the mandated whitespace.
10:36:05 <deathcap> Ruby doesn't bother me much.
10:36:11 <deathcap> because it reminds me of my first love.
10:36:35 <Solonarv> thinking about it, I think my favorite dynamic/scripting language is probably lua
10:37:06 <dminuoso> deathcap: I consider myself a Ruby expert, which is why I know about the dark and bad secrets about the language. I absolutely loathe it.
10:38:15 <ProofTechnique> .oO(I can't wait for affine types to hit so someone can write a truly bizarre type-level regex library)
10:38:34 <dminuoso> ProofTechnique: Curious, is there a relationship between the two?
10:40:05 <Cale> I can wait
10:40:29 <ProofTechnique> I was watching SPJ's linearity talk at Haskell eXchange and he mentioned affine types with multiplicities {0or1, Exactly1, ω}, and it seemed like a cute idea for an unusable library
10:40:44 <Cale> I was there as well, and that proposal scares me
10:41:09 <dminuoso> I was there too.. cant recall. :)
10:41:38 <ProofTechnique> 55 minutes in on the recording. Very brief
10:42:00 <Cale> The whole thing is going to result in all kinds of requests to make various libraries more linear and hence way less readable
10:42:26 <Cale> For reasons of dubious value
10:44:40 <Athas> I agree.  Linear types does not belong in Haskell.  It's too heavy and complicated a feature.
10:44:55 <Cale> The proposal doesn't get us the performance benefit of uniqueness types, and you basically can't have linearity and exception handling.
10:45:00 <Athas> And I'm not convinced Haskell is a good choice for the kinds of programs where linearity matters.
10:47:40 <c_wraith> yeah, my reaction to adding linear arrows is pretty much "well, I won't be using those or anything using them..."
10:52:28 <Unhammer> hm, can hp2ps show the biggest cost center at the bottom?
10:54:07 <dmwit> ProofTechnique: https://hackage.haskell.org/package/regex-type
10:54:36 <ProofTechnique> Oh, boy
10:56:55 <deathcap> Well, I've gotta head out of here: just got roped into a high visibility email exchange through my organization. Nothing to do with Haskell though. :p Thanks for all the help!
10:58:49 <dmwit> Cale: When you say "There's apparently a sensible way to make $ less magic" are you thinking of BlockArguments or something else?
10:59:00 <dmwit> (I don't think you ended up saying what the sensible way was!)
11:06:37 <Solonarv> I believe Cale was referring to a new-ish paper
11:06:45 <Solonarv> https://www.microsoft.com/en-us/research/publication/guarded-impredicative-polymorphism/
11:06:51 <Solonarv> dmwit: ^
11:13:14 <ProofTechnique> Is there some obvious reason that `coerce` isn't happy here? https://pastebin.com/5ybFh8F9
11:14:08 <ProofTechnique> I'm writing a tiny time series library for a talk at work, and I just want to transparently treat it like an IntMap, but the typechecker doesn't want to let coerce work, and I'm not sure why
11:14:23 <Solonarv> ProofTechnique: yeah, it doesn't know what type you want to 'coerce' from
11:15:17 <Cale> dmwit: Oh, right, I forgot to link the paper...
11:15:37 * hackage curl-runnings 0.11.0 - A framework for declaratively writing curl based API tests  https://hackage.haskell.org/package/curl-runnings-0.11.0 (aviaviavi)
11:16:06 <ProofTechnique> Solonarv: `coerce @(M.Key -> TimeSeries _ -> Maybe _) M.lookup` did get me a different error, at least
11:16:31 <Solonarv> ProofTechnique: try:
11:16:31 <Solonarv> lookup :: forall a. M.Key -> TimeSeries a -> Maybe a
11:16:31 <Solonarv> lookup = coerce (M.lookup @a)
11:17:26 <Solonarv> ProofTechnique: well, that's not the right type to coerce from - what you did is roughly equivalent to 'coerce (M.lookup :: M.Key -> TimeSeries _ -> Maybe _)'
11:17:34 <Cale> hmm, where did I get that link... there was a new paper on generalising the inference rule to allow inferring polytypes under certain circumstances
11:17:41 <Solonarv> Cale: I already linked it above :D
11:17:45 <Solonarv> https://www.microsoft.com/en-us/research/publication/guarded-impredicative-polymorphism/
11:18:41 <ProofTechnique> Solonarv: That did it. I didn't know `forall` would bring type variables into scope for application. Neato. Thanks!
11:19:06 <Solonarv> ProofTechnique: you need the ScopedTypeVariables extension for that, it's not default behavior ;)
11:19:27 <ProofTechnique> Ah, that makes sense. I always have that on, anyway :D
11:19:28 <Solonarv> (but I assume you already had it enabled, or did it after GHC told youto)
11:19:54 <Cale> Solonarv: ah, cool
11:21:29 <Solonarv> I read the paper but I was tired and I'm not very good at reading inference rules, so I didn't retain much
11:26:37 * hackage beam-migrate 0.4.0.1 - SQL DDL support and migrations support library for Beam  https://hackage.haskell.org/package/beam-migrate-0.4.0.1 (TravisAthougies)
11:31:26 <pezubi> LoL
11:52:36 <ski> DigitalKiwi : "dtmwfi" ?
11:56:25 <asthma[m]> @ski down to model world financial information
11:56:25 <lambdabot> Maybe you meant: wiki src ask
11:58:33 <gbd_628> Hi all. Is there a way to have *inductive* type-level literals? Namely, can I have literals for `data Nat = Z | S Nat` at the type level? The GHC.TypeLits package uses builtin, non-inductive stuff—I can't pattern match on it.
12:00:25 <c_wraith> gbd_628, best you can do is use a type family to convert literals to an inductive representation when needed.
12:00:45 <cocreature> gbd_628: you can if you enable DataKinds and use 'Z and 'S
12:00:57 <cocreature> but generally GHC handles the builtin literals a lot better in most cases
12:01:40 <gbd_628> cocreature: Yeah, I know about those, and that's what I've been using when needed. Literals are more convenient though.
12:01:47 <gbd_628> c_wraith: Okay, thanks.
12:09:09 <DigitalKiwi> ski: don't take my word for it
13:26:14 <dmwit> Solonarv: Thanks!
13:26:17 <dmwit> Cale: You too. =)
13:27:24 <dmwit> In `A -> B`, are both `A` and `B` considered "under" the "type constructor" (->)?
13:27:42 <dmwit> For the purposes of "impredicative instantiation in an application is allowed for type variables that occur under a type constructor".
13:29:51 <sternmull> I use Scotty and have "type ActionM = ActionT TL.Text (ReaderT AppState IO)" and want to use local (from Control.Monad.Trans.Reader) inside a function of type "RoutePattern -> ActionM () -> ScottyM ()". How do i do that? I suspect i have  to insert a lift or liftIo somwhere, but can't figure it out.
13:30:59 <dmwit> (Answer: yes.)
13:40:44 <Cale> sternmull: Either there's an instance of MonadReader for ActionT, or you can't.
13:41:25 <Welkin> ExceptT there's an instance
13:42:04 <sternmull> Cale: Hm, ok. I guess then this is the way to go https://stackoverflow.com/a/28367915 But that will make me put "lift" everywhere in my handlers where i have to run Scotty actions.
13:43:00 <Welkin> you can use a natural transformation I believe
13:43:51 <Welkin> scotty's monad transformer interface is not nice since you ned to put your monad inside of ScottyT instead of wrapping around it
13:43:54 <flebron_> Hi folks. Blanking out a bit. If I have an fs :: F (a -> b), and an x :: G (F a), where G and F are Applicatives, how can I get a G (F b)? (a and b here are fixed)
13:44:11 <Cale> If scotty were designed a bit better, you wouldn't, because there would be a MonadAction / MonadScotty or whatever, and then there would be a lifting instance of that for ReaderT
13:44:20 <Cale> But yeah, the way things are...
13:44:22 <sternmull> Welkin: I have no idea whata "naural transformation" is
13:44:35 <Welkin> sternmull: you swap out the monad for another
13:44:53 <Cale> flebron_: pure fs :: G (F (a -> b))
13:44:56 <Welkin> (Monad m, Monad n) => m a -> n a
13:45:01 <Cale> flebron_: and then apply Compose to both
13:45:07 <Cale> flebron_: and use its <*>
13:45:14 <flebron_> What do you mean by "apply Compose"?
13:45:27 <Cale> So  Compose (pure fs) <*> x
13:45:31 <Cale> oops
13:45:34 <Cale> So  Compose (pure fs) <*> Compose x
13:45:51 <Cale> (and then you can getCompose)
13:46:12 <flebron_> Oh there's literally a thing called Compose
13:46:24 <Cale> There's an instance (Applicative f, Applicative g) => Applicative (Compose f g)
13:46:39 <sternmull> Welkin: I have no idea how to do that. Also... if there is something that is better designed and similar to Scotty then i would just switch to that. But not Spock, tried that before and decided i don't want the few magic/automatic things it does.
13:46:42 <flebron_> Compose ((<*>) <$> f <*> x)
13:47:05 <Welkin> sternmull: I was unhappy with the options in haskell for web servers so I switched to erlang for all my web stuff
13:47:05 <dmwit> flebron_: Or, without Compose, you can directly `fmap (fs<*>) x`.
13:47:06 <flebron_> OK, cool. Is it idioamtic to use this type when composing functors?
13:47:25 <Welkin> I've scotty, servant, yesod, and others
13:47:29 <Cale> flebron_: It's normal to use it if you want the Applicative instance
13:47:31 <Welkin> used*
13:47:46 <dmwit> I think Compose is probably overkill if this is the only thing you're going to use it for.
13:47:50 <Welkin> servant is great if you have a pretty basic json web api
13:48:11 <Welkin> if you need something custom, just use wai and build your own abstractions on top
13:48:15 <dmwit> But if you plan to do other Applicative stuff with this type, then yeah, go for it.
13:48:16 <Welkin> wai/warp
13:48:35 <sternmull> Welkin: Thats the first time i hear such a story. I had the impression that webdev in Haskell is nice. And i definitely don't want to switch to Erlang (or Elixir).
13:49:06 <Welkin> sternmull: it's better than the mainstream options, that's for sure, but some of the libraries suck, and marshalling data around really sucks
13:49:27 <Cale> sternmull: Where I work, we use mostly Snap, and we only really use about 5% of it.
13:49:42 <Cale> (for the webserver)
13:49:57 <Cale> Well, really we use obelisk :)
13:49:58 <Welkin> if you are dealing with basic crud apps (front-end servers consuming json and spitting out json or html) then haskell doesn't give you much advantage
13:50:09 <Welkin> haskell would be good for actual backend services that don't deal with that stuff
13:50:23 <Cale> https://github.com/obsidiansystems/obelisk
13:50:41 <sternmull> i have my database stuff with PostgreSQL.Simple and are happy with it. Now i wanted to add generic login/authentication handling and then continue with the actual application. But now this monad-transformer complexity is blocking my way...
13:51:04 <Welkin> I have found that webmachine (or now, cowboy with rest handlers) is the best way to write web servers
13:51:09 <Welkin> it is the most declarative
13:51:15 <Welkin> in erlang
13:51:23 <Cale> sternmull: Well, hang on... do you have to write the entire handler in this monad?
13:51:41 <Cale> sternmull: You can presumably get to some point and just liftIO and be back in plain IO again.
13:51:51 <Cale> and then from there, build your application-specific monad.
13:52:12 <Welkin> in scotty you can entirely avoid a monad stack
13:52:15 <Welkin> I did it
13:52:19 <Welkin> just use plain old IO
13:52:24 <Welkin> and ScottyM, not ScottyT
13:52:30 <Welkin> run your database handlers in IO
13:52:53 <Welkin> just pass your configuration around from the top-level
13:53:04 <Welkin> that's all the transformers are doing (for ReaderT)
13:53:07 <sternmull> Cale: My idea was to have a ReaderT that has a data with some Maybe-records inside it to carray session information and error messages to the handlers. But i fail to update the damn records in the function that i made to wrap my handlers.
13:53:29 <Welkin> ReaderT is read only
13:53:50 <Cale> Yeah, I'm not sure that makes sense... what session information?
13:53:57 <Cale> Stuff you got from the cookies?
13:54:05 <sternmull> Welkin: I intended to use "local" to pass on modified state to the actions
13:54:20 <Welkin> that sounds too complicated, overengineered
13:54:35 <sternmull> Cale: Exactly, i look up an authenticated user by inspecting a session cookie.
13:54:38 <Cale> Yeah, why not just start by passing function parameters.
13:54:40 <Welkin> what is your actual goal?
13:54:53 <Cale> Anything you can do with ReaderT, you can do with functions
13:55:06 <Cale> So, maybe that will clarify the issue a bit
13:55:29 <Cale> and then you can sort out whether you need/want a monad transformer at all
13:56:10 <sternmull> The idea was to wrap all my get and post handles with a generic function that handles a login/logout form that is present on all sites and that checks a CSRF token. So i have exactly one place with that logic and use ReaderT instead of passing around a bunch of parameters.
13:56:12 <Cale> "local" is just passing a modified version of your own parameter as an argument to another function
13:56:13 <Welkin> sternmull: I already wrote all this without any monad transformers
13:56:17 <Welkin> take a look if you want https://github.com/ericnething/roll2d6-server-haskell/blob/338d99d3d5886de4812bce9080848142d1e99065/src/Auth.hs
13:56:36 <Welkin> that is using Scotty, and then I have latter commits in the tree where I converted to servant
13:57:30 <sternmull> I have i working with function. But i thought it would be good to move that stuff into one function so my handlers are cleaner.
13:58:03 <Welkin> notably the `checkAuth` function
13:58:21 <Welkin> that looks up the session using the cookie data to get the user id
13:58:40 <Welkin> and it takes the entire handler as an argument
13:58:54 <Welkin> it's not my favorite way of handling this, but it works pretty well
13:59:02 <sternmull> thats very similar to what i had so far
13:59:09 <Welkin> in erlang/cowboy I don't need to do this because it uses a state machine to handle all the boilerplate
14:02:47 <Thyringer> binomT (m, x, n) = (m * x) + n
14:02:47 <Thyringer> y = (\m x n -> (m * x) + n)
14:02:47 <Thyringer> Hello, I'm wondering; why in Haskell these two different possibilities are allowed? I know the first variant allows pattern matching, but could not the syntax be unified with lambda expressions?
14:03:08 <Cale> Thyringer: those aren't equivalent
14:03:20 <Cale> The first variant requires a triple
14:03:25 <Cale> the second is a function of three arguments
14:03:34 <Cale> Perhaps you meant to write
14:03:45 <Cale> binomT m x n = m * x + n
14:03:48 <Thyringer> oh sorry, i mean:  binom m x n =  (m * x) + n
14:03:58 <Thyringer> yes
14:05:35 <dminuoso> Thyringer: There's subtle differences wrt to monomorphism restriction and strictness.
14:05:35 <Cale> There isn't a fantastic reason that what's allowable in each syntax isn't more unified. Functions in the first form allow for a lot of fall-through possibilities that are tricky to express with a simple case expression though.
14:05:56 <Cale> Oh, also yeah, there's the monomorphism restriction, but that's not really a great excuse of any kind.
14:06:07 <dminuoso> Cale: The strictness part is relevant though.
14:06:23 <Rembane> Hm... bla currying...
14:06:35 <dminuoso> Though.. mmm.
14:06:41 <dminuoso> Im actually not sure whether there's a difference here.
14:07:17 <dminuoso> let f = \!x y -> undefined in f undefined `seq` ()
14:07:19 <dminuoso> > let f = \!x y -> undefined in f undefined `seq` ()
14:07:21 <lambdabot>  <hint>:1:9: error: parse error on input ‘\!’
14:07:59 <dminuoso> Interesting, I did not expect this.
14:08:00 <dminuoso> I take it back.
14:09:07 <Cale> There is not
14:09:16 <Cale> Where there's a difference is when you write things like
14:09:18 <Thyringer> mh ok thx
14:09:23 <Cale> f x = let ... in \y -> ...
14:09:48 <Cale> Or otherwise interleave definitions of things with the lambda parameters
14:10:22 <Cale> Because evaluating the function applied to less than its full complement of arguments can result in things being bound and reused between multiple applications of the resulting function
14:10:53 <Cale> For example, if you were writing a function to parse regular expressions
14:11:06 <Cale> matchRegex regex string =
14:11:24 <Cale>   let automaton = compileRegex regex
14:11:30 <Cale> oops
14:11:40 <Cale>   in runAutomaton string
14:11:45 <Cale> well, let's just write it that way
14:12:01 <Cale> this will recompile the automaton for each new string you give it
14:12:09 <Cale> but we can move the argument
14:12:15 <Cale> matchRegex regex =
14:12:19 <Cale>   let automaton = compileRegex regex
14:12:40 <Cale>   in \string -> runAutomaton automaton string
14:12:57 <Cale> (I also left out the automaton argument above)
14:13:32 <Cale> anyway, you can then write something like  f = matchRegex "some regular expression here"
14:13:42 <Cale> and then use f many times, and it'll reuse the same automaton
14:16:05 <Thyringer> So lambda expressions serve more only to quickly pass a literal function as a parameter, if this is needed anyway only once.
14:16:23 <Cale> Typically, yeah
14:17:00 <dminuoso> Thyringer: One example would be sort of "callback" functions: withLdap $ \ldap -> ..
14:17:17 <Cale> Note that it'd be perfectly okay to move the regex argument to just the other side of the = sign as well, particularly if you were giving an explicit type signature or had the monomorphism restriction turned off
14:17:29 <flebron_> One more Applicative question. Say I have a Q (M [a]). Each [a] has the same length. Is there a ZipList-like way to get a [Q M a]?
14:17:50 <flebron_> Q (M a), I mean.
14:17:55 <Cale> (Haskell has a somewhat silly and arbitrary restriction on type class polymorphism in the face of pattern bindings -- i.e. definitions of things without syntactic function arguments)
14:18:19 <Cale> flebron_: Seems impossible
14:18:26 <Cale> Unless you know something special about Q and M
14:19:10 <flebron_> They're "containers", for some notion of that. You could do that if these were, say, Q v = M v = (v, v) for example, no?
14:20:18 <Cale> Yeah, maybe
14:20:20 <flebron_> (For each tuple, grab one element from each of the lists, and make a new tuple with those)
14:20:32 <Cale> If one of them is Traversable
14:20:36 <Cale> :t sequence
14:20:37 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
14:20:59 <Cale> well, you'd need both to be, if you want to move the list all the way to the outside
14:21:24 <dminuoso> :t sequence . sequence
14:21:25 <lambdabot> (Monad t, Monad m, Traversable m, Traversable t) => m (t a) -> m (t a)
14:21:26 <Cale> So the fact that they were Applicative wouldn't be so useful
14:21:28 <flebron_> Yeah, they are.
14:21:29 <Cale> :t sequenceA
14:21:30 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
14:21:44 <flebron_> OK, so maybe sequence . sequence can work :) *tries it*
14:21:45 <Cale> So, you'll actually want to fmap (fmap ZipList) first
14:21:56 <dminuoso> flebron_: I dont think that would do what you think it would.
14:21:57 <Cale> and then sequenceA . fmap sequenceA
14:22:20 <flebron_> Ah. because the sequence instance for [] would take from each list one time, creating all combinatiomns?
14:22:21 <Cale> :t sequenceA . fmap sequenceA . fmap (fmap ZipList)
14:22:22 <lambdabot> (Traversable t2, Traversable t1) => t1 (t2 [a]) -> ZipList (t1 (t2 a))
14:22:23 <dminuoso> I was just trying to think what `sequence . sequence` even means.
14:22:37 <Cale> sequence . sequence is definitely wrong
14:22:51 <flebron_> That has the right type, therefore it must be right. Thanks :)
14:22:55 <Cale> You need to swap the list out of the inner layer, and then out of the outer one
14:22:58 <Cale> lol
14:23:03 <Cale> Don't think like that
14:23:09 <Cale> actually make sure it does what you want
14:23:18 <flebron_> Yeah, got ghci in another window trying it :_
14:23:20 <flebron_> :)
14:23:36 <dminuoso> Cale: If you make it to next Haskell eXchange, I need to buy you a beer by the way.
14:23:47 <merijn> With new-install how do I make it clobber existing symlinks?
14:24:19 <Cale> dminuoso: any particular reason? :)
14:24:42 <dminuoso> Cale: Just for the various insights you have given me. I think Im finally getting a handle on Profunctors now! :-)
14:24:46 <Cale> nice
14:24:53 <Cale> I don't even really use profunctors
14:24:57 <Cale> haha
14:25:59 <Cale> (but I might, if I were to undertake some sort of arrowized FRP project)
14:26:35 <dminuoso> Well Profunctor in Haskell is rather blant since it's just Hask^op x Hask -> Hask
14:27:00 <dminuoso> (Though Im sure you can have arbitrary profunctors if you pick one of those categories libraries)
14:27:11 <Cale> yeah
14:27:42 <Cale> A library on top of Profunctor which gives all the stuff from Arrow in a piecemeal fashion would let you do all the Arrow stuff, but better.
14:28:15 <dminuoso> Cale: What bits and pieces are you looking for exactly?
14:28:36 <Cale> Basically all the monoidal category stuff
14:29:07 <dminuoso> You mean like Strong?
14:29:35 <Cale> That's a good start
14:31:03 <Cale> You'd also want a bunch more of the isomorphisms from the definition of a monoidal category explicitly, so that you can avoid having 'arr' be too important
14:31:19 <Cale> The thing that kills Arrow as an abstraction isn't exactly 'arr'
14:31:21 <Cale> :t arr
14:31:23 <lambdabot> Arrow a => (b -> c) -> a b c
14:31:36 <Cale> But the fact that its existence is used to avoid needing things like
14:32:08 <Cale> assocR :: Arrow p => p ((a,b),c) (a,(b,c))
14:32:34 <Cale> (and its inverse, assocL, and units on the left and right, and swap)
14:33:53 <Cale> Every occurrence of arr is a black box -- the advantage of Arrow, if it's to be had, is that it makes all binding explicit, so you can, at runtime, determine your computation graph and simplify it
14:34:24 <Cale> but arr makes that impossible locally -- an arbitrary function was applied and you can't tell what happened across it
14:34:38 <boi> Hello, maybe someone can clear up my confusion? Wikiepda gives this definition: "algebraic data type is a kind of composite type, i.e., a type formed by combining other types" and then provides this delcaration as an example: data List a = Nil | Cons a (List a). But how is List combination of types, if neither Nil, nor Cons are types?
14:34:58 <dminuoso> boi: Consider the | in the data definition to act as a sum.
14:34:59 <Cale> boi: That's sort of an awkward description
14:35:07 * hackage email-validate 2.3.2.11 - Email address validation  https://hackage.haskell.org/package/email-validate-2.3.2.11 (GeorgePollard)
14:35:09 <dminuoso> boi: And consider having multiple type arguments for a data constructor to act as a product
14:35:33 <dminuoso> boi: `data Pair a b = Pair a b` multiplies two types `a` and `b`
14:35:50 <dminuoso> boi: data Either a b = Left a | Right b` adds two types `a` and `b` in a disjoint sum fashion.
14:35:57 <Cale> boi: But yeah, it's kind of like saying that List a is a disjoint union of some one-element type (and we'll mark this case with Nil), and the product of the type a with List a
14:36:18 <Cale> (and we mark the latter with Cons)
14:37:42 <boi> dminuoso: but if we have something like data Color = R | G | B, then there are no types, just values. Same with List declaration above, Nil isn't a type, right?
14:37:56 <dminuoso> boi: R corresponds to a singleton type
14:38:05 <dminuoso> boi: Its isomorphic to ()
14:38:10 <dminuoso> boi: So you can consider it `1`
14:38:21 <dminuoso> In some pseudo code: Color = 1 + 1 + 1
14:38:39 <Cale> Yeah, with respect to the description, you're meant to think of that as a sort of union of unnamed one-element types
14:38:52 <Cale> (tagged union)
14:39:29 <Cale> but yeah, that case isn't exactly showing off how good a description it was, haha
14:40:01 <dminuoso> boi: And equivalently you have a `0` which is the empty/uninhabitated type called Void
14:40:28 <dminuoso> boi: `Either Void Int` corresponds to `0 + Int` which is isomorphic to just `Int`
14:41:03 <dminuoso> boi: And for multiplication you have () acting as the identity, where `Pair () Int` is equivalent to `1 * Int` which is equivalent to `Int`
14:42:59 <dminuoso> boi: Some other interesting construction is `Maybe`, which you can consider as `Either ()`, so it adds 1 to an arbitrary type
14:43:44 <Cale> It may or may not be helpful to think in terms of this arithmetic though. If it doesn't make sense to you, then just ignore it for now, I'd say
14:44:24 <Cale> The important thing to understand is that in the syntax of a data declaration, you have a bunch of cases after the = sign, separated by |
14:44:48 <Cale> and each case consists of the name of a data constructor (a value-level thing which will be used to make values of your newly defined type)
14:45:03 <Cale> followed by a sequence of types for its arguments, separated by spaces
14:45:31 <Welkin> | is "or", "," is "and"
14:46:05 <Welkin> it reminds me a bit of prolog and erlang with all the punctuation that has actual meaning: , ; .
14:46:41 <Welkin> or I suppose a space is "and" if you don't use record syntax
14:47:05 <boi> /
14:48:29 <boi> dminuoso , Cale thanks for your explanations. Imho, this mixing of value and type levels is really confusing.
14:54:24 <koz_> boi: It gets easier.
14:55:36 <Welkin> where is gurl?
15:04:03 <remexre> is there any way to partially specify the value I'm computing in an mfix expression?
15:05:25 <remexre> I'm trying to write a typechecker for a language with mutually recursive type declarations: https://p.acm.umn.edu/WnLezfd9wAA=
15:05:56 <remexre> and I know the keys of newDecls, and the values up to WHNF
15:08:01 <merijn> irrefutable pattern matches are labeled with a source location, right?
15:13:13 <Cale> > (\~(x:xs) -> x) []
15:13:15 <lambdabot>  <hint>:1:11: error: parse error on input ‘->’
15:13:19 <Cale> yeah
15:13:31 <Cale> er
15:13:36 <Cale> > (\(~(x:xs)) -> x) []
15:13:38 <lambdabot>  *Exception: <interactive>:3:2-16: Irrefutable pattern failed for pattern x : xs
15:13:42 <Cale> yeah :D
15:14:37 <Welkin> > \(x:xs) -> ":D" $ undefined
15:14:38 <lambdabot>  error:
15:14:39 <lambdabot>      • Couldn't match expected type ‘t0 -> t’ with actual type ‘[Char]’
15:14:39 <lambdabot>      • The first argument of ($) takes one argument,
15:14:55 <Welkin> > (\(x:xs) -> ":D") undefined
15:14:57 <lambdabot>  "*Exception: Prelude.undefined
15:15:01 <Welkin> > (\(x:xs) -> ":D") []
15:15:03 <lambdabot>  "*Exception: <interactive>:3:2-16: Non-exhaustive patterns in lambda
15:15:18 <Cale> > (\(~(x:xs)) -> ":D") []
15:15:20 <lambdabot>  ":D"
15:15:24 <Welkin> what
15:15:30 <Cale> It's irrefutable
15:15:47 <Welkin> I don't get it
15:15:53 <Cale> That pattern always matches, and if you use the variables when it didn't match, then it's an error
15:15:53 <Welkin> I neve used lazy pattern matching
15:16:12 <Cale> But only when the bound variables are actually evaluated
15:16:15 <Welkin> what is it good for?
15:17:29 <Cale> Well, the only short example I can think of off the top of my head is something like using fix in order to define mutually recursive things
15:18:05 <Cale> > fix (\(evens, odds) -> (0 : map (+1) odds, map (+1) evens))
15:18:07 <lambdabot>  *Exception: <<loop>>
15:18:13 <Cale> > fix (\~(evens, odds) -> (0 : map (+1) odds, map (+1) evens))
15:18:14 <lambdabot>  <hint>:1:22: error: parse error on input ‘->’
15:18:15 <Cale> oops
15:18:19 <Cale> that *always* gets me
15:18:24 <Cale> > fix (\(~(evens, odds)) -> (0 : map (+1) odds, map (+1) evens))
15:18:26 <lambdabot>  ([0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
15:18:31 <geekosaur> Welkin, pattern matches are normlly strict, so recursive pattern matching can force an entire list or etc.
15:18:55 <geekosaur> you'd use ~ to force it to be lazy instead of forcing the entire spine of the list up front
15:18:57 <Cale> > bimap (take 5) (take 5) $ fix (\(~(evens, odds)) -> (0 : map (+1) odds, map (+1) evens))
15:18:59 <lambdabot>  ([0,2,4,6,8],[1,3,5,7,9])
15:19:40 <Cale> geekosaur: Of course, it only defers by one step
15:20:07 <Cale> But it might be just enough :)
15:20:17 <geekosaur> sure, but it means "take 5 (expression that produces a lazy infinite list)" works
15:20:39 <geekosaur> well, take would itself be lazy there
15:21:04 <geekosaur> and if you stop one step you also don't get the steps after until forced, so choosing that one step wisely still wins
15:21:38 <Cale> If you're matching a list like ~(x:xs) it's the same thing roughly as matching it as l and using head l and tail l
15:21:52 <Cale> which is, you know, not great unless you know that the list is nonempty for sure
15:22:12 <Cale> But at least this version will tell you what line it happened on if it goes wrong :P
15:22:50 <Cale> and when the data constructor is something like a pair
15:22:59 <Cale> there's no way that the pattern match is going to fail anyhow
15:23:06 <merijn> Another specific example where it's useful is that in my current code there is a pattern match on Just that I *know* will always be just, but I can't prove that to GHC, so I use an irrefutable match to make it work in the presence of MonadFail
15:23:14 <Cale> so causing evaluation to happen early is sometimes really bad
15:24:12 <Cale> Like, imagine if the computation up to producing a pair constructor is really a lot of hard work, but you don't know whether you'll need both parts
15:24:28 <Cale> It might make your performance better if you pattern match it as ~(x,y)
15:24:45 <Cale> (or use let, which implicitly does the same thing)
15:31:43 <merijn> Anyone here an expert on Haddock markup? >.>
15:32:38 <Cale> Is anyone an expert on Haddock markup?
15:32:46 <merijn> Cale: Ssh
15:33:01 <glguy> Is anyone here?
15:33:11 <Welkin> no
15:33:12 <Welkin> go away
15:33:52 <merijn> Ah! I now the solution to my problem!
15:33:56 <merijn> Zero-width space!
15:33:58 <Cale> https://www.haskell.org/haddock/doc/html/markup.html -- this document is the closest thing to an expert. Despite the fact that it is not that long, nobody has ever managed to internalise the rules described within.
15:34:10 <hpc> another problem solved by the best minds in #haskell
15:34:24 <merijn> Cale: The problem I have is it's 'clever' disambiguation of quotes
15:34:44 <merijn> I'm trying to link an identifier, while also using possesive 's
15:35:13 <merijn> And it "cleverly" interprets 'Foo''s as linking to Foo'
15:35:15 <Cale> Is that possessive "it's"? If so, you can just remove the apostrophe.
15:35:27 <pie_> merijn, [very christian exclamation]
15:35:46 <Cale> Foo\'s
15:35:48 <merijn> Cale: I'm tired and my brain doesn't distinguish its and it's when I am :p
15:35:59 <Cale> Or perhaps 'Foo'\'s
15:36:05 <pie_> also i was going to say, is tehre seriously no escape character? :p
15:36:06 <Welkin> merijn: mongolian vowel separator to the rescue yet again!
15:36:07 <merijn> Cale: You'd think that, but no!
15:36:14 <pie_> oh no
15:36:15 <Cale> whaaaaaaat
15:36:19 <Cale> but the documentation
15:36:25 <Cale> THE DOCUMENTATION
15:36:33 <merijn> \ is the escape character but it just ends up literally inserting 'Foo'\'s instead
15:36:41 <Cale> hahahaha
15:36:48 <pie_> \\
15:36:55 <merijn> But I'm guessing a zero-width space between the quotes will fix it
15:36:59 <pie_> \\\\\\
15:37:02 <Welkin> use a mongolian vowel separator
15:37:09 <pie_> you guys are horrible
15:38:20 <merijn> Whoo! It works!
15:38:30 <glguy> merijn: How about "'Foo' constructor's" in absence of another solution
15:38:38 * glguy punts the ball
15:39:01 <merijn> glguy: Why do that if you can fix it with obscure unicode? :D
15:39:32 <glguy> If you're using unicode how about the less obscure ’
15:39:53 <merijn> Ok, next question
15:40:08 * glguy puts his hand over his buzzer
15:40:48 <merijn> I was using the trick of defining a type alias identical to a DataKinds lifted type (which avoids the need to enable DataKinds in libraries importing my code), as of 8.6 that triggers a haddock warning about the name being ambiguous, but I'm not sure how to fix that...
15:42:21 <glguy> merijn: Is that related to https://github.com/haskell/haddock/issues/667 ?
15:42:37 * hackage coerce-role 0.1.0.0 - Having trouble deriving instances because of type roles? Solve it here!  https://hackage.haskell.org/package/coerce-role-0.1.0.0 (parsonsmatt)
15:42:49 <merijn> glguy: Maybe?
15:42:49 <glguy> merijn: Where you can use:    t'Foo' and v'Foo'
15:45:30 <merijn> glguy: Is that already in a released version of Haddock? I don't see it in the documentation?
15:45:43 <merijn> glguy: Also, the problem is both my Foo are types :)
15:47:15 <Welkin> name one of them Quux
15:49:26 <merijn> glguy: Yeah, the ideas suggested by hvr there don't appear to be implemented
15:50:42 <jle`> i don't envy the job of haddock. it's hard to even figure out what identifiers mean what without invokign full ghc
15:50:55 <merijn> jle`: That's why it uses ghc now :p
15:51:04 <jle`> ooh
15:51:23 <jle`> but i mean, for identifiers in documentation, it's going to be tricky no matter what
15:51:46 <jle`> since documentation identifiers can't always be given a proper context
15:52:15 <merijn> jle`: The problem I have is: rijn/broadcast-chan/blob/master/broadcast-chan/BroadcastChan/Internal.hs#L18-L27
15:52:33 <Welkin> has anyone made a JackieChan yet?
15:52:44 <merijn> jle`: There's two "In" types so it's ambiguous for Haddock which one it should be
15:55:15 <merijn> Annoyingly it's not insisting on generating docs where 'In' gets linked as Direction, so now it's completely unreadable :\
15:58:16 <jle`> :/
15:58:35 <jle`> hm, could you try using the qualified names?
15:58:44 <merijn> qualified how?
15:58:53 <jle`> if one of the Ins comes from a different module
15:59:06 <merijn> They're in the same module
15:59:14 <Welkin> "fat", "small", "expensive"
15:59:26 <jle`> how would you distinguish it within normal haskell code?
15:59:44 <Welkin> just be careful about making value judgements on your types
15:59:48 <merijn> jle`: You don't :p
16:00:17 <merijn> jle`: The problem is that if you lift a datatype via DataKinds then everyone who tries to import and use it is stuck enabling DataKinds in their modules
16:00:43 <jle`> oh, i see the link now
16:00:51 <Solonarv> Yes you do - use a tick when referring to the lifted constructor, no tick when referring to the alias
16:00:58 <jle`> you use that dedatakinding trick
16:01:00 <merijn> jle`: Someone discovered a hack, years ago, that GHC will happily let you define a type alias with the same name as a datakinds lifted type and then you don't have to enable DataKinds in modules that use it
16:01:19 <jle`> yeah, i've seen it before
16:01:21 <merijn> Solonarv: Haddock doesn't understand prefix ticks
16:01:28 <jle`> i'm not sure if it resonates with me on a personal level
16:01:53 <Solonarv> merijn: yeah, I meant in code
16:02:00 <Welkin> it doesn't vibrate at your frequency?
16:02:06 <Welkin> doesn't jive?
16:02:22 <jle`> it doesn't stimulate my fundamental harmonics
16:02:39 <jle`> what's wrong with enabling datakinds?
16:02:57 <Welkin> it's what is wrong with haskell itself at the moment
16:03:08 <Welkin> here, take this huge bag of ghc pragmas
16:03:10 <merijn> jle`: If you use a module in 20 other modules enabling DataKinds in all 20 is a hassle
16:03:18 <glguy> jle`: the data kinds route polutes the value namespace when all you wanted was a type
16:03:28 <jle`> you should enable DataKinds if you use DataKinds
16:03:50 <jle`> there's no getting around using DataKinds in this case. here you're just using the extension without explicitly enabling it
16:03:54 <merijn> jle`: Users of this code don't use DataKinds, though
16:04:13 <glguy> It's more important to keep things out of the value namespace than it is to avoid turning on the extension
16:04:15 <Welkin> I find that very annoying with servant
16:04:19 <Welkin> and other libraries
16:04:31 <Welkin> where to use them I need to enable all kinds of extensions even if I am not using them
16:04:58 <jle`> i think i'd say they are using DataKinds. if you're giving 'In to something that expects something of kind Direction, you're already datakinding
16:05:06 <jle`> whether or not you're using the actual constructor
16:05:17 <merijn> jle`: Users aren't really expected to do that
16:05:34 <merijn> jle`: But without it they can't write down the type of a channel for their functions
16:06:09 <jle`> yeah, if you make BroadcastChan :: Direction -> Type -> Type, you're already in datakind land
16:06:37 <Welkin> merijn: you should add a JackieChan type just for fun
16:06:44 <jle`> well, unless you make Direction a type synonym for Type, just like they did in the good old days
16:07:14 <jle`> you already are exporting an outwards-facing datakinds api
16:07:40 <jle`> i guess one way you can get around datakinds at all in the external api is do type BroadcastChanIn = BradcastChan 'In
16:07:49 <jle`> type BroadcastChanOut = BroadcastChan 'Out
16:08:00 <merijn> jle`: How is that any better from the current approach
16:08:09 <jle`> that way you have two `Type -> Type` haskell98 type constructors
16:08:32 <jle`> and datakinds never leaks
16:08:38 <merijn> No, you just have an alias that adds nothing but indirection
16:08:47 <merijn> jle`: How does it leak now?
16:09:00 <jle`> because BroadcastChan is parameterized on a literal data Kind
16:09:10 <jle`> the Kind comes from DataKinds
16:10:25 <merijn> jle`: I'm not interested in arguing semantics of words, can you name a concrete example of where things break/work different from expected?
16:12:43 <jle`> i just think that enabling/disabling datakinds doesn't make much of a difference because the user is already exposed to datakinds either way
16:13:24 <merijn> Agree to disagree :p
16:14:08 <jle`> in the old days we'd just make BroadcastChan :: Type -> Type -> Type, and then create data In, data Out
16:15:43 <jle`> (i provide that as an example of a haskell98, datakindless method)
16:22:37 * hackage morley-prelude 0.1.0.2 - A custom prelude used in Morley  https://hackage.haskell.org/package/morley-prelude-0.1.0.2 (gromak)
16:23:37 * hackage morley 0.1.0.2 - Developer tools for the Michelson Language  https://hackage.haskell.org/package/morley-0.1.0.2 (gromak)
16:29:29 <Zer000> If I want to go from a generic object representing xml or json or some other structured data to my own program's objects, is that still parsing or a job for a parser?
16:30:01 <Rembane> Zer000: Yes. It's a very good job for a parser.
16:30:07 <Zer000> in an imperative langauge I just write a function with a bunch of ugly nested if conditions based on matching keys or values
16:30:21 <Zer000> Rembane, so everything I've read about Parsec so far has been focused on parsing text
16:31:23 <Rembane> Zer000: Yes. If you want to parse json there's aeson that does it for you.
16:31:32 <Rembane> Zer000: https://hackage.haskell.org/package/aeson
16:32:03 <Rembane> Zer000: And for XML there are a couple of different packages. My taste in XML parsers is esoteric though, so ask someone else for what they prefer.
16:33:51 <Zer000> I want to parse bencoded data
16:34:40 <Zer000> i'm using the bencoding for parsing it but that doesn't go as far as to help you transform it to your own objects. I'll see how aeson does it
16:35:26 <geekosaur> aeson uses (and can generate, or you can) FromJSON and ToJSON instances, or you can parse a raw Value and convert it yourself
16:37:44 <geekosaur> you can either specify an empty instance (with DeriveAnyClass extension) and let it use a default via generics, or there's TH that can generate instances at compile time
16:40:27 <delYsid> I am trying to interface to a runtime-typed sum type.  Any hints on how to approach this?  getValue is easy, as I simply return my sum type, but how do I do setValue correctly?  One function for every constructor?  Or something else? like setStringValue, setBoolValue, so on?
16:41:27 <jle`> what is a runtype-typed sum type?
16:41:55 <jle`> type MySUm = Either String Bool ?
16:42:32 <delYsid> I mean, I am getting the info which value have which type at runtime.
16:42:48 <jle`> what mechanism are you using?
16:43:01 <jle`> note that the type i gave also fits that description
16:43:19 <delYsid> Its basically an key/value store that I communicate with via IO, where value is a sum type.  I wonder how to do sanity checking when setting values.
16:43:41 <jle`> what is the sum type in question?
16:44:08 <jle`> if it's Either, you can just setValue :: Either String Bool -> IO (), for instance
16:44:29 <delYsid> Something like data Option = Bounded Int Int Int | Boolean Bool | String String
16:44:42 <jle`> note that due to type algebra, (Either a b -> r) is the same as (a -> r, b -> r)
16:45:00 <jle`> so having one function on Option, vs. a separate function for every constructor, are both valid and equivalent :)
16:45:29 <jle`> so Option -> IO () is the same as ((Int,Int,Int) -> IO (), Bool -> IO (), String -> IO ())
16:45:41 <jle`> having one "write an Option" is the same as having a separate "write" function for every constructor
16:45:58 <jle`> r^(a+b) = r^a * r^b
16:48:50 <delYsid> I guess what confuses me is Bounded, since it carries min/max, which isn't settable.  So just writing setOption :: Option -> IO () looks very strange, as passing Bounded 0 0 1 would be strange, the client would need to copy the min/max values around.
16:50:04 <jle`> that sounds like an issue with the semantics of your data type, then, if it isn't quite algebraic like that
16:50:17 <delYsid> So I was thinking setBoundedOption :: Int -> IO (), but how should that fail then?  Throw an exception, or return IO Bool, or what?
16:51:17 <jle`> do you already have the bounds stored somewhere?
16:51:50 <delYsid> They are part of what I get when I fetch the available options, yes.
16:52:42 <delYsid> But I dont know the bounds at compile time, so its not like an Int or something.
16:54:38 <delYsid> I just dont remeember having seen such a data type in Haskell code yet.  Maybe if I knew an example of such a beast I could just look how other people treat it.
16:54:47 <reallymemorable> does locking my computer stop the compiler
16:54:50 <reallymemorable> im using osx
16:55:09 <reallymemorable> ive been building a project but its taking hours and i need to go get food :P
16:56:34 <c_wraith> reallymemorable, no, but sleeping will.
16:56:45 <reallymemorable> ok thanks
16:56:49 <c_wraith> reallymemorable, so make sure you set it to not sleep. :)
16:56:59 <reallymemorable> great thx
16:57:10 <jle`> delYsid: you might be thinking about 'refined'
16:57:40 <jle`> delYsid: or more specifically, `Refined (FromTo a b) Int`
16:57:58 <jle`> but, here, it might not make too much sense
16:58:24 <jle`> Option is a sum type, so you might not even have bounds
16:59:35 <delYsid> jle`: You mean the refinde package?
16:59:52 <jle`> yeah :)
17:00:48 <delYsid> ok, let me read up on that, looks interesting
17:02:23 <jle`> but yeah, your issues might be deeper than that :)
17:17:52 <delYsid> jle`: aw, very neat, but doesnt look like it covers the case of runtime bounds.  But I get a clearer picture of the problem now.
17:44:45 <dmwit> delYsid: "The bounds can't be set" and "the bounds can't be known until runtime" seems like a weird combination.
17:46:13 <dmwit> But given those constraints, I'd consider `Option -> IO ()` anyway.
17:46:39 <dmwit> Sorry, actually `Option -> IO Bool`.
17:47:08 <dmwit> For `Bounded`, I'd check that the bounds given match what the database says, then write the value if they do.
17:47:17 <dmwit> The `Bool` can be used to report whether the value was written.
17:48:06 <dmwit> Or you could consider something like `ExceptT BoundsMismatch IO ()` with a new type `BoundsMismatch` which lets you describe what went wrong.
17:48:33 <dmwit> Later, if it turned out there were other ways the write could fail, you could generalize the type and its name.
17:48:56 <dmwit> (e.g. `BoundsMismatch` could say not just that it failed, but which bound wasn't right, and what the right value was.)
18:10:25 <koz_> dmwit: So basically a stack of Except and IO?
18:12:32 <koz_> What do I need to put in my cabal file to have 'cabal new-test' run me some Hedgehog tests?
18:19:14 <koz_> Never mind, figured it out I think.
18:24:02 <deathcap> I just want to say thanks to y'all for the help over the past couple weeks. My attemps to learn this language are going way better than they did back in 2013 the first time i tried.
18:24:25 <koz_> deathcap: No problem - we are all here to help and give hugs.
18:25:35 <deathcap> Who doesn't like a good hug?
18:26:58 <int-e> deathcap: stay away from me
18:27:11 <koz_> int-e: LOL
18:44:34 <mouse07410> I need stack to pass a linker option to every dependency it pulls. However it looks like for some packages it did not do it, or it is ignored. Anybody knows why is this, and how to enforce that option for absolutely everything stack builds on my machine? Putting it in "ghc-options" in ~/.stack/config.yaml appears only effective sometimes. For ghc-paths pulled by intero build, or for hie it seems ignored. ???
18:47:00 <pie_> mouse07410, hie has an irc channel btw so if you dont get a reply you could also try asking there
18:48:05 <pie_> also you might want to be more specific about those options you're passing, who knows, maybe its important
18:48:39 <mouse07410> pie_: thanks. I created a GitHub issue for hie, but it looks like a stack problem - unless one can define a package in such a way that its build options are "frozen"
18:51:41 <mouse07410> I need the linker to use /usr/lib/libiconv.dylib *first*, then all the other libraries it needs. Tried to pass it via "ghc-options" as "-optL=/usr/lib/libiconv.dylib", and directly - for the majority of packages it works, for some it doesn't. Unfortunately, those are what I really need to build. 
19:03:30 <koz_> Is there a contravariant analogue of selective applicative functors, in a similar way how Decidable is an Applicative analogue?
19:09:37 <delYsid> Does attoparsec have a manyTill that doesn't consume the till?
19:09:55 <delYsid> or how would I parse arbitrary strings separated by a keyword?
19:10:11 <delYsid> "foo bar sep bar sep last"
19:10:23 <koz_> Does a test-suite section in a cabal file allow an other-modules line?
19:11:03 <Cale> delYsid: There's sepBy
19:11:40 <delYsid> many1 ((manyTill anyChar " sep ") <|> takeByteString) will likely not work I guess
19:12:07 * hackage massiv 0.3.0.0 - Massiv (Массив) is an Array Library.  https://hackage.haskell.org/package/massiv-0.3.0.0 (lehins)
19:12:27 <delYsid> Cale: Yeah, but which parser would I pass? I need to consume everything between the separators, no matter what.
19:12:38 <Cale> I don't think there's a particularly good reason not to have a lookAhead p
19:12:49 <Cale> It just doesn't seem to be there
19:13:52 <delYsid> so I just hoping to use manyTill, but then I dont know how to consume the last element
19:14:53 <delYsid> ahh, many (manyTill anyChar " sep ") <*> takeByteString and fmap it togehter?
19:15:29 <delYsid> that could work I guess
19:30:49 <Cale> delYsid: Why not sepBy?
19:31:09 <Cale> delYsid: I'm pretty sure your problem is what sepBy is for.
19:40:19 <stylewarning> hey haskell folks. This isn't really a Haskell question, but more of a typed functional prog. question. I've been reading about implementing pattern matching, and I've had trouble finding material that really presents it simply. SPJ's 1987 book is not bad, but also doesn't give a lot of insight into how to build these things in a nice way without a lot of work.
19:41:08 <stylewarning> It seems that if you want nested patterns, guards, wildcards, type checking with reasonable error messages, etc.; it really is just a lot of work to grind through.
19:43:42 <stylewarning> My question is: Does anybody have any references that discuss a more "meat and potatoes" approach to implementing pattern matching, that include how matching should work with, say, H-M type inference?
19:52:54 <delYsid> wow, System.Timeout.timeout is pretty useful.
19:54:29 <delYsid> Cale: If I would use sepBy, what would I pass as p?  I need to match everything between sep.
19:54:54 <davean> delYsid: Yah, but I don't like its signature. Its an annoying way to define time.
19:55:18 <delYsid> davean: That applies to threadDelay as well.
19:55:20 <lucca> normally you would do something like myWordParser `sepBy` mySeparator
19:55:38 <davean> delYsid: I know, which is why I ahve my own package which provides both with better interfaces :-p
19:56:04 <davean> Which I renamed to something vaugely polite when I uploaded it
19:56:08 <delYsid> lucca: Yes, but word is not defined, and (many anyChar) likely doesnt work.
19:56:50 <delYsid> davean: I find the Units story of time values also a bit unpretty.
19:56:57 <lucca> well, do you mean just anything not matching your separator?
19:57:09 <delYsid> lucca: yes.
19:57:16 <davean> delYsid: "Units"?
19:57:23 <delYsid> manyTill consumes the till, so sep will not match...
19:57:51 <delYsid> davean: Yes, like, Int vs something that defines the unit at typelevel.
19:58:19 <davean> Thats an interesting way to term it. I just gave options as my design
19:58:29 <davean> second-based by default
19:59:13 <davean> From Int and Double to DiffTime and dimensional's Time 
19:59:52 <davean> but I included timeoutAt and such to use UTCTime
20:00:02 <davean> (though I should push a 0.1 with TAI support)
20:00:51 <lucca> Usually it's easier to specify what is valid, but you could likely do something (quite possibly less performant) via many $ (notFollowedBy sep) *> char
20:01:36 <lucca> er anyChar, whatev
20:02:53 <delYsid> lucca: AFAIK, attoparsec has no notFollowedBy
20:03:35 <lucca> then specify your contents accordinly
20:04:00 <delYsid> lucca: I am coding for an existing spec, which is pretty loose.
20:05:23 <delYsid> "default Some Text var First Item var Second Item var Some Text" is what I need to handle, I cant change that.
20:05:24 <lucca> well, if your separator is |, then you can start by matching things that are not |
20:05:54 <delYsid> my separator is a string, not a char.. :-)
20:06:08 <koz_> I have a 'newtype CM a = CM (StateT Integer (Writer Code) a', where 'Code' is some Monoid. I'm trying to write a Monad instance for CM, but >>= has me stumped.
20:06:24 <koz_> Is there some way to use lift to define it?
20:06:27 <delYsid> anyway, I think I have a solution already.  Was just trying to figure out if Cale know something I dont understand yet.
20:08:57 <Solonarv> koz_: well, you can just re-use the Monad instance for StateT s m
20:10:33 <koz_> Solonarv: Signature for >>= in this case is 'CM a -> (a -> CM b) -> CM b', but the >>= for StateT s m would be something like 'StateT s m a -> (a -> StateT s m b) -> StateT s m b', so my function has the wrong type.
20:10:40 <Solonarv> instance Monad CM where CM ma >>= k = CM $ do a <- ma; case k a of CM x -> x
20:10:43 <koz_> Unless I'm missing something.
20:11:06 <koz_> Wait, hold on, what?
20:11:32 <Solonarv> or if you have 'newtype CM a = CM { runCM :: StateT ... }' you can write:
20:11:32 <Solonarv> instance Monad CM where CM ma >>= k = CM (ma >>= runCM . k)
20:11:45 <koz_> Oh, right, _that_ I get.
20:12:06 <Solonarv> which makes it clearer that we're only adding/removing newtype constructors
20:12:23 <koz_> That makes it _much_ easier to see, yeah.
20:12:45 <Solonarv> even more concise:
20:12:45 <Solonarv> instance Monad CM where (>>=) = coerce ((>>=) @(StateT Integer (Writer Code)))
20:12:58 <koz_> Oooh, sneaky.
20:13:14 <Solonarv> or you can just ask GHC to write this for you:
20:13:36 <Solonarv> newtype CM a = CM (StateT ...) deriving Monad
20:13:42 <Solonarv> (needs GeneralizedNewtypeDeriving)
20:14:06 <koz_> Yeah, that'd work too.
20:16:15 <Solonarv> that's the solution I would prefer, personally
20:16:35 <koz_> I keep forgetting GND is a thing.
20:17:48 <Solonarv> yeah, it's very neat
20:18:05 <Solonarv> and now we have DerivingVia aka 'GND on steroids'
20:19:12 <koz_> EvenMoreGeneralizedNewtypeDeriving?
20:19:18 <Solonarv> yes :D
20:19:29 <koz_> GeneralizederNewtypeDeriving
20:19:52 <Solonarv> DerivingVia is not even restricted to newtypes
20:20:26 <davean> koz_: I'd say its less general and more specific really :)
20:20:39 <Solonarv> well, DerivingVia subsumes GND
20:22:23 <Solonarv> GND works when you have 'newtype Foo = MkFoo (Bar)', and allows you to re-use Bar's instances for Foo
20:23:18 <Solonarv> DerivingVia works for any two types 'A' and 'B' where 'Coercible A B' holds, and allows you to re-use A's instances for B (or vice versa)
20:25:07 <Solonarv> for example, I could write the following:
20:25:07 <Solonarv> newtype Size = Size Int deriving (Eq, Ord, Semigroup, Monoid) via (Sum Int)
20:25:15 <Solonarv> % newtype Size = Size Int deriving (Eq, Ord, Semigroup, Monoid) via (Sum Int)
20:25:15 <yahb> Solonarv: ; <interactive>:350:1: error:; Illegal deriving strategy: via; Use DerivingVia to enable this extension
20:25:22 <Solonarv> % :set -XDerivingVia
20:25:23 <yahb> Solonarv: 
20:25:25 <Solonarv> % newtype Size = Size Int deriving (Eq, Ord, Semigroup, Monoid) via (Sum Int)
20:25:25 <yahb> Solonarv: 
20:25:32 <Solonarv> % Size 5 <> Size 3
20:25:32 <yahb> Solonarv: ; <interactive>:353:1: error:; * No instance for (Show Size) arising from a use of `print'; * In a stmt of an interactive GHCi command: print it
20:25:48 <Solonarv> % Size 5 <> Size 3
20:25:48 <yahb> Solonarv: Size 8
20:42:31 <delYsid> Would it work to pass -fllvm in a library, and link to that in a program that doesn't use -fllvm?
20:44:22 <Solonarv> I would assume so, going via llvm still produces plain old native code in the end
20:46:09 <nisstyre> Question: is there a specific pattern (or convenient library functions?) to help with this sort of situation: I'm running an async task (potentially a bunch of them), $SERVICE starts rate-limiting me, therefore I want to cancel the task, and exponentially back off until it lets me continue
20:46:40 <nisstyre> I know the async library has stuff that can do parts of this, just curious if there is a good approach that I don't know of
20:47:34 <Solonarv> there is async-pool which should be a simple way to not run into the rate-limit in the first place
20:47:44 <nisstyre> ok I will check that out
20:49:25 <nisstyre> Solonarv: yeah this looks useful, thanks for the pointer
20:49:55 <delYsid> I am hooked to Haskell.  Better get some sleep.  Thanks for all your helpful input, it continues to be a fantastic ride!
20:51:18 <delYsid> (I never should have given up in 2002, it was really worth it to take it up some 10 years later)
20:52:40 <nisstyre> delYsid: I started in 2011 and then didn't even do much programming at all for a couple years before getting back into it heavily in the past year or so
20:53:55 <delYsid> I went crazy trying to learn Monads in 2002, and then just gave up.  I should have persisted, would have saved me a lot of dabbling in untyped languages.
20:54:47 <nisstyre> delYsid: I picked up "Real World Haskell" from a store, not knowing anything except Python and JS, and having no clue what FP was at all really
20:54:54 <nisstyre> in retrospect, not a great way to learn Haskell
20:54:58 <delYsid> I learnt the hard way that, while Python has a nice ecysystem, programs longer then a few thausand lines just start to fall apart.
20:55:45 <delYsid> nisstyre: I came from Lisp, so FP concepts were not really alien to me, however, purity was.
20:56:07 <nisstyre> the most mind bending aspect (that you have to understand sooner or later) is probably type unification
20:56:33 <nisstyre> and I don't think that would be intuitive unless you had a bit of background in logic programming or other things
20:56:47 <delYsid> dont get me started on type inference, its just beautiful!
20:57:09 <nisstyre> the HM algorithm is really nice and concise
20:57:36 <nisstyre> I think the actual algorithm that Haskell uses is much more complex due to all of the extensions and other stuff
20:57:52 <delYsid> HM?
20:57:59 <nisstyre> and it's SystemF obviously
20:58:05 <nisstyre> delYsid: hindley-milner
20:58:21 <nisstyre> it's the name of a type system / algorithm for inference of types
20:58:28 <nisstyre> https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system
20:58:30 <delYsid> I am not deep enough into theory to know.
20:58:42 <nisstyre> it's not required really, just an interesting CS thing
20:58:53 <delYsid> I mostly learn by doing.
20:59:49 <delYsid> A ton of code golf combined with a sense of aesthetics.  Luckily, I dont have to deliver anything, so I can learn by making things pretty.
21:00:40 <delYsid> Anyway, time to hit the sack, finally.
21:01:01 <delYsid> its 5AM after all.
21:02:20 * Solonarv glances at the clock
21:04:06 <Solonarv> definitely not 5 am here, no no
21:28:03 <monochrom> Unification should be intuitive.  Reading or writing very formal, detailed code for unification can be non-intuitive just by getting bogged down by technicalities and book-keeping, but performing unification mentally and informally should be intuitive.
21:29:14 <monochrom> For example, pattern matching is already unidirectional unification. Full unification is bidirectional, that's all. Don't tell me pattern matching is unintuitive.
21:30:13 <monochrom> Unification is also pervasive.  If you have been in any math course, have used any formula for any calculation, (does not even have to be proof-intensive), you have done unification.
21:32:35 <monochrom> Unification simply means: There are some variables and you know you have to plug something into them, but no one tells you what, you have to figure out.  That's it.  That's unification.
21:40:55 <nisstyre> monochrom: oh, yeah I agree you can easily explain it to someone just with the idea of "it generates constraints and then checks them"
21:41:29 <nisstyre> I guess I'm assuming a much higher level of depth than is necessary
21:44:13 <davidlopez> In data B = B !Int !Int deriving (Eq, Show). What does the '!' mean?
21:45:31 <monochrom> It kills some laziness.
21:45:43 <monochrom> http://www.vex.net/~trebla/haskell/strict-field.xhtml
21:46:15 <davidlopez> i see, thanks for the link!
22:35:07 * hackage fakefs 0.2.0.0 - Extensible fake file system for testing.  https://hackage.haskell.org/package/fakefs-0.2.0.0 (igrep)
23:00:07 * hackage TaskMonad 1.0.0 - A collection of tools which can be used to access taskwarrior from xmonad.  https://hackage.haskell.org/package/TaskMonad-1.0.0 (mmagorsc)
