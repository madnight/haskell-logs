02:39:22 <zincy> What is the alternative to multidimensional arrays in Haskell?
04:10:19 <tdammers> mapping multiple dimensions onto one? nested arrays?
04:10:27 <tdammers> same as in any other language really
04:14:51 <zincy> Vectors are Haskell's answer to random access data structures right?
04:15:02 <zincy> well random access arrays
04:20:04 <Rembane> zincy: Yes. There is something that looks like it in Data.Array too, but they aren't as ergonomical.
04:21:56 <Ariakenom> There's also things like Map and Sequence
04:23:34 <Ariakenom> that add a log factor
04:29:53 <Ariakenom> . o O (add a factor ...)
04:48:03 <dminuoso> Are there folks here who us nix to actually build their haskell packages?
04:48:50 <fendor> I have a library that depends at runtime on data-files. How can I distribute a binary of my project? E.g. I dont want to install it from source.
04:49:21 <dminuoso> fendor: Extract the executable and ship it?
04:49:42 <dminuoso> fendor: Or wait. You said it's a library, what binary are you talking about?
04:50:20 <fendor> dminuoso, I have an executable that depends on a library that has data-files
04:50:30 <fendor> now I think the sentence is correct :D 
04:52:06 <fendor> If I distribute my executable, the library expects the data-files to be in some location known at compile time, right?
04:53:42 <sternmull> can't you make it locate the files at runtime? The executable could pass the path of the files to the library.
04:58:26 <fendor> sternmull, yes, however, then I have to distribute these files as well, right?
04:59:14 <fendor> where should I should expect these files to be? I thought I could file-embed them and write them to $XDG_DIRECTORY/my-exe/
05:01:03 <sternmull> don't know. You could document that applications that depend on your library have to provide the files in some way an then tell the library where to find them. But thats a bit ugly for applications developers.
05:02:02 <fendor> I think that does not work, because then either the user has to supply the location, or I demand a specific location for them. Neither seems optimal.
05:02:08 <nai> hi, i am failing to understand the Example section at https://wiki.haskell.org/Applicative_functor#Example
05:02:45 <nai> specifically how a monad cannot be used for the initialization scenario and how an applicative functor can
05:03:27 <nai> the code samples are a bit terse and i think the last one is wrong -- liftA2 is only passed two arguments
05:04:32 <nai> what would help me is to see an example implementation of liftToCleanup, runAndCleanup and initializeAndRun
05:09:29 <sternmull> fendor: I think demanding the user to supply the location is not so bad.
05:11:09 <fendor> sternmull, if I try to distribute binaries, I think it is. It either forces a script to install it correctly or a convoluted readme.
05:22:25 <sternmull> nai: I can't answer your questions. But maybe this helps if you want to learn about applicative functors: https://en.wikibooks.org/wiki/Haskell/Applicative_functors
05:24:30 <nai> well i've read and understood this page already
05:24:50 <nai> but thanks
05:43:51 <cocreature> dminuoso: I’ve definitely used nix to build Haskell packages
05:50:23 <drew> hey does anyone here use nvim + ale? I'm trying to figure out how to pass ghc options to it
05:50:27 <Guest35313> https://github.com/w0rp/ale/commit/e273f678fffe190ba3b22995ca8d91ab60fcf88d
05:50:42 <Guest35313> that commit shows that it can somehow take options
05:50:54 <Guest35313> but it's not clear how. Was curious if anyone had figured it out
06:05:31 <Guest35313> :q
06:09:40 <dmwit> nai: `Compose Writer IO` gets you those features.
06:12:25 <ahNg9yei> Hey guys, could you recommend me some reading on linear types + exceptions? My intuition says they shouldn't work together, so I'd like to understand it a bit better.
06:18:31 <dmwit> nai: https://gist.github.com/dmwit/c764c9b46b08c9aa88fd2d3a5f1f010a
07:02:04 <ibloom> If I put "profiling: True" in my cabal.project file I should be able to use "+RTS -p -RTS" but cabal is saying that I need the option "-prof". Am I missing something?
07:03:17 <adarqui> hey. quick q maybe someone knows: i have two libraries, A & B. A uses "html-entities", and i have it in extra-deps etc. B uses A, and also has html-entities in extra-deps. For some reason when I build B, it tells me: "Failed to load interface for ‘HTMLEntities.Decoder’" / "There are files missing in the ‘html-entities-1.1.4.2’ package," ... A builds fine. B which depends on A gives me that error. any idea?
07:03:53 <adarqui> says same version of cabal/ghc/html-entities/lts release/& stack etc.
07:09:36 * hackage read-bounded 0.1.1.2 - Class for reading bounded values  https://hackage.haskell.org/package/read-bounded-0.1.1.2 (ThomasEding)
07:24:22 <adarqui> when in doubt rm .stack-work.
07:27:20 <WilliamHamilton[> a question on haskell ecosystem: if I have a type level list [A,B,C], how do I express the type for the function `A -> B -> C -> R` using common idioms? I can roll my typeclass to do this, but I wonder if there's a commonly used library
07:28:32 <phadej> WilliamHamilton[: there isn't, Uncurry/Curry exist in many libraries; but AFAIK there is no "go to library"
07:29:46 <WilliamHamilton[> thanks phadej , so would you just write the typeclass?
07:30:09 <phadej> As we don't have higher-order type families (yet?), so we cannot write e.g Map family making type-level list library is somewhat limited
07:30:59 <phadej> WilliamHamilton[: or type family, yes. Depends what's handier in that case
07:31:05 <WilliamHamilton[> phadej: even with lyxia's http://hackage.haskell.org/package/first-class-families ?
07:32:05 <phadej> WilliamHamilton[: no, but it uses defunc... trick, which works but i ugly
07:32:18 <phadej> same as with singletons
07:33:12 <WilliamHamilton[> phadej: indeed, thanks for the help!
07:36:14 <phadej> cheers
08:03:52 <dmwit> It would be nice if the GHC manual's entry for each language pragma said which version introduced it.
08:07:14 <phadej> dmwit: iirc it does for recent additions
08:08:59 <phadej> e.g. https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#deriving-any-other-class
08:09:03 <phadej> since 7.10.1
08:09:07 * hackage japanese-holidays 0.2.0.0 - Japanese holidays utility  https://hackage.haskell.org/package/japanese-holidays-0.2.0.0 (cohei)
08:09:30 <phadej> dmwit: and there's reverse list in wiki: https://gitlab.haskell.org/ghc/ghc/wikis/language-pragma-history
08:13:48 <WilliamHamilton[> sorry, a type-level question https://gist.github.com/aea5dbc19524d235bb7957c5f8c294da
08:14:37 <WilliamHamilton[> can I use defunctionalization to partially apply a type family? Could you show me how in this example? ^
08:15:16 <dmwit> phadej: Ah, having it in one place is already very nice, thanks for that link!
08:21:37 <WilliamHamilton[> I
08:21:57 <WilliamHamilton[> I'd also like to see the solution with the typeclasses for the question above
08:28:34 <d34df00d> Hi!
08:29:24 <d34df00d> I'm trying to do some very basic numeric computations — namely, finding the sum of all the divisors for each number up to N.
08:29:30 <d34df00d> This is what I've come up with:
08:29:35 <d34df00d> https://bpaste.net/show/754caabc03f8
08:31:24 <d34df00d> It works awesome for n == 1e6 (0.2 MUT time, 0.0 GC time, less then a meg of memory, no gen-0 GCs), but it gets worse for bigger Ns: for example, for 1e7 it's 3 s MUT time and 4 s GC time. And 240 megs maximum residency.
08:31:28 <d34df00d> Can I do better?
08:32:08 <zuserm> does anyone have any idea why I'm getting "Ambiguous occurrence ‘star’" on 51/52 despite hiding/importing qualified? https://github.com/bacchanalia/lasercuts/blob/WIP/pentagramearrings.hs
08:34:06 <zuserm> d34df00d: Try using Data.Vector. it does fancy fusion stuff that might help.
08:34:29 <d34df00d> zuserm: oh, that's worth trying, thanks!
08:35:00 <d34df00d> Would something like repa help? I never really used it, but I heard it might be useful for this kind of applications.
08:35:59 <zuserm> I haven't used it either, but I think so, yes.
08:38:54 <lyxia> zuserm: what's the whole error message
08:41:23 <lyxia> WilliamHamilton[: newtype Unroll_ r as = Unroll_ (Unroll r as) ; ex :: NP (Unroll_ Char) (Code Foo)
08:44:24 <runeks> Is there a Hoogle that will let me search by kind signature?
08:46:54 <runeks> I'm looking for the "Void" constraint, of kind `* -> Constraint` (a constraint that imposes no constraint on the type given as argument)
08:47:33 <WilliamHamilton[> lyxia: thank you very much as always! I have yet to let it sink that `Unroll a` doesn't really have kind `[*] -> *`, while if I put it in a newtype, of course it has it; Thank you again!
08:48:03 <zuserm> lyxia: https://gist.github.com/bacchanalia/c10cfc37f7947c18a5ec72093f3120af
08:48:56 <lyxia> zuserm: that says that you're importing star from Diagrams.Prelude, line 9.
08:49:36 <zuserm> right, thanks
08:49:55 <ChrisPenner[m]> Anyone know a good lib for doing bitmasking? Specifically I need to perform ops over large ranges of bits; e.g. `setBits bitArray (100, 300) False` or something like that
08:51:03 <ChrisPenner[m]> I've found a lot of options, most are for working with bits of integers, and none of them seem to have good generation functions; e.g. I have to construct the bitvector using [Bool] which seems really inefficient to me
08:51:47 <zuserm> lyxia: reading comprehension is hard sometimes
08:52:48 <lyxia> zuserm: :)
09:00:38 <d34df00d> zuserm: yay, Data.Vector.Unboxed is awesome.
09:00:55 <d34df00d> Four times faster than Data.Array even for 1e6 elems (without GC affecting it).
09:01:30 <d34df00d> Incredibly faster on 1e7 — 3 ms GC overhead, 0.3 s MUT.
09:01:58 <d34df00d> Great! Thanks for the advice! For some reason I assumed that Array is as fast on tasks like this. Now I wonder how exactly does Vector manage to be so memory-friendly.
09:03:23 <d34df00d> Ah, nope, dammit, I was wrong. It's slower MUT-wise, but way better GC-wise.
09:07:43 <dmwit> (I sort of expect UArray to also show a comparable improvement over Array that unboxed vectors do over vectors.)
09:09:37 <dmwit> runeks: I don't know of such a tool.
09:10:11 <dmwit> runeks: I also don't know of a library providing that. But you can write `type Unconstrained a = ()` if you don't need partial application; `class Unconstrained a; instance Unconstrained a` if you do.
09:10:47 <dmwit> (The price of the latter is that the (empty) dictionary will probably be passed around at runtime; this could block memoization and the like in surprising ways.)
09:11:25 <dmwit> I guess you need `type Unconstrained a = () :: Constraint` to tell it you don't mean the type `()`.
09:14:06 <d34df00d> dmwit: is UArray autoparallelizing or what? My stuff is running with -N12, and I get 0.04s total / 0.04s elapsed for smaller workloads (a considerable improvement over both plain Array and Data.Vector.Unboxed), but 17s / 2s for larger ones
09:14:36 <zuserm> d34df00d: vector fusion means it can avoid explicitly building some of the data structures, therefore better memory/gc usage
09:15:09 <dmwit> I don't think so. Perhaps you have some other paralellism in your code that's paying off.
09:15:24 <d34df00d> Well, UArray is clearly a winner even with -N1 right now.
09:15:41 <zuserm> d34df00d: yeah, array/vector has no auto parallelization, for that I think you need repa.
09:16:47 <zuserm> or at least I didn't think so?
09:16:51 <d34df00d> Hmm, interesting. elapsed time doesn't differ for -N1 or -N12. So it looks like it's just hogging all the CPUs it can reach.
09:16:52 <d34df00d> Or HECs.
09:24:11 <dmwit> ChrisPenner[m]: Did you get an answer?
09:24:49 <dmwit> ChrisPenner[m]: If not, consider unboxed arrays of Bool. For construction, mutable unboxed arrays of Bool.
09:24:51 <ChrisPenner[m]> Nope, I'm seeing if I can make it work with Bitvector
09:25:04 <dmwit> (Unboxed arrays of Bool are bit-packed.)
09:25:33 <ChrisPenner[m]> Ahh, makes sense. So I'd just use the "arrays" package for all that?
09:25:54 <dmwit> Err, array, but yes.
09:28:13 <ChrisPenner[m]> Gotcha.
09:28:45 <ChrisPenner[m]> I might actually end up needing Word8; so in that case I'd try switching to Data.Vector.Unboxed probably
09:44:30 <d34df00d> Ok, so the algorithm with UArray is performing awesome, both MUT and GC-wise. Here it is:
09:44:38 <d34df00d> https://bpaste.net/show/78bb7e7ed676
09:44:54 <d34df00d> (disregard the output being a singe int, it's just for comparison with other implementations)
09:45:22 <d34df00d> But... Out of curiosity, I've coded up something very similar in C++, and that one is twice as fast on average for various `n`s. Can I do better in Haskell?
09:48:18 <dmwit> You can `quot` instead of `div`.
09:48:41 <dmwit> Then after that, if you still want more speed, you're going to have to lose the beauty and idiomatic nature.
09:48:54 <dmwit> e.g. by hand-writing your loops on unboxed Int#s
09:49:02 <d34df00d> Hmm, quot vs div don't make much difference.
09:49:17 <d34df00d> dmwit: yeah, I probably don't want to go that route... Or working with ST.
09:49:35 <d34df00d> I'm curious how fast can it get while being more or less idiomatic.
09:49:52 <dmwit> I would guess this is just about it.
09:50:06 * hackage cryptostore 0.2.0.0 - Serialization of cryptographic data types  https://hackage.haskell.org/package/cryptostore-0.2.0.0 (OlivierCheron)
09:50:21 <d34df00d> Hmm, maybe Data.Array could use unsafeAccum, since I guess it does some bounds checking inside.
10:34:32 <bbear> hello
10:34:49 <bbear> I try to use map (Data.Array.! myArray) but I fail
10:38:05 <Welkin> yes you fail
10:38:17 <Welkin> `map` only works on lists
10:38:20 <Welkin> chekc the type
10:38:21 <Welkin> :t map
10:38:22 <lambdabot> (a -> b) -> [a] -> [b]
10:38:29 <Welkin> you need fmap
10:40:36 * hackage trasa-client 0.4 - Type safe http requests  https://hackage.haskell.org/package/trasa-client-0.4 (chessai)
10:42:06 <bbear> that's not what I want to say
10:42:19 <bbear> i'm trying to use the `Data.Array.! myArray` currified function
10:43:28 <bbear> http://vpaste.net/2wCEa
10:44:25 <Welkin> it tells you your problem at the very top
10:44:30 <Welkin> you didn't import Data.Array
10:44:49 <Welkin> or you have a syntax error
10:44:56 <Welkin> (Data.Array.!)
10:45:10 <bbear> i did `import qualified Data.Array`
10:45:19 <bbear> it's more like a syntax problem
10:46:09 <Welkin> I gave you the answer above
10:46:12 <d34df00d> dmwit: JFYI what really made a difference is using usnafeAccumArray instead of accumArray (that I wished for, and that turns out to be existing, just not documented.
10:46:15 <d34df00d> )
10:46:35 <mjrosenb> is there a lens combinator that will take a function that returns a tuple, and update the focused element with one of them, and returns the other?
10:46:37 <d34df00d> So it's even faster than C++ now, lol (just a bit, but the difference is stable).
10:46:46 <monochrom> haha
10:47:31 <d34df00d> unsafeAccumArray is handling the bounds funnily, though — even though I'm passing, say, (1, n) as the bounds, it behaves as if I passed (0, n - 1)
10:48:08 <mjrosenb> so like ("test",2) & _2 <<.~~ (\x -> (x+1, x-1) evaluates to (("test", 1),3) (possibly swapping the 1 and the 3)
10:49:47 <Solonarv> mjrosenb: that seems like it should exist, let me see if I can find it
11:13:54 <rotaerk> friend's trying to get haskell working on Windows, and this is what they get https://gist.github.com/Roy-Fokker/6d38285786a70ded10fafebba5808f2b#file-terminal-output-log
11:14:21 <rotaerk> it's not symlinking (because it thinks that's not possible in Windows)
11:14:32 <rotaerk> anyone here use Haskell on Windows and has worked around this?
11:15:10 <rotaerk> just seems like a pretty big usability issue
11:15:11 <Welkin> I thought you meant the tv show Friends
11:15:17 <Solonarv> rotaerk: fixed in the next (not-yet-released) cabal version
11:15:18 <Welkin> they use haskell now?
11:15:21 <Welkin> they're back on air?
11:15:51 <Welkin> solution: delete windows and install linux
11:15:58 <rotaerk> Solonarv, okay, cool; in the meantime, what do people do?
11:16:03 <Welkin> you can't complain because linux is free
11:16:32 <Solonarv> rotaerk: you can grab cabal head from here: https://www.myget.org/feed/mistuke/package/nuget/cabal-head
11:16:32 <Welkin> or develop in a VM (or whatever that windows subsystem for linux thing is, if that even works)
11:16:48 <Welkin> really though, just delete windows
11:17:11 <Welkin> you can't even make the terrible excuse of "but I need it to run application X or game Y"
11:17:19 <Welkin> because those all run on linux now, especially under steam
11:17:50 <rotaerk> I'm not even going to entertain your suggestion, Welkin
11:18:06 <MarcelineVQ> yes all of 25% of my steam library runs under linux, that's close enough I'm sure
11:18:10 <rotaerk> but I do want to comment on your remark about needing Windows to run games/applications
11:18:42 <rotaerk> I'll do so in blah
11:18:53 <rotaerk> or not, you're not there...
11:18:56 <Welkin> MarcelineVQ: proton
11:20:23 <bbear> any advance in your plan to conquer the world ?
11:21:57 <rotaerk> I wonder if things get broken if you've installed the haskell platform, and then you install the cabal head
11:22:14 <bbear> using stack is best
11:22:42 <rotaerk> on Windows?
11:22:43 <bbear> rotaerk: I would suggest you checkout the exercism.io platform
11:22:54 <Solonarv> I installed ghc + cabal via chocolatey
11:23:04 <rotaerk> haskell-platform is the official one and it's maintained, so I would hope that it would work
11:23:06 <bbear> they give a portable way to build things, I think it should work on windows, they have a step by step process to get things working.
11:23:17 <Solonarv> that let me simply remove the "normal" cabal before installing cabal-head
11:23:49 <rotaerk> I see
11:24:22 <Solonarv> I haven't figured out how to do multiple ghc versions yet, but fortunately haven't needed to (I can just stay on the latest one)
11:25:45 <rotaerk> I use nix to handle that, myself
11:25:49 <rotaerk> but that's linux-only
11:26:13 <rotaerk> I suppose stack would be the way to go on Windows, for multiple GHC versions
11:26:53 <Solonarv> stack works okay but I find being tied to the resolver mildly annoying
11:27:11 <Solonarv> (I know I can add extra packages to them; that's precisely what's annoying!)
11:27:44 <Welkin> I don't like wllaed gardens, so stack is a no-no
11:28:13 <rotaerk> on Linux, I have no use for stack; I just haven't tried out haskell dev on Windows
11:28:30 <Solonarv> it used to be really really terrible without stack
11:28:35 <Solonarv> but I've been managing for some months now
11:29:27 <cocreature> except for GHC 8.6 being generally somewhat broken on Windows :)
11:30:26 <Solonarv> yeah, 8.6.3 is virtually unusable and is the one you get from the haskell platform ;)
11:31:24 <Solonarv> the chocolatey package is on 8.6.2 still; there are some issues with that version, but I haven't personally run into them and don't remember what they are
11:32:01 <Welkin> Solonarv: are you being forced at gunpoint to use windows?
11:32:05 <cocreature> I think 8.6.2 has at least broken profiling like 8.6.4
11:32:10 <Welkin> is steve balmer in your house?
11:32:35 <monochrom> Welkin: Are you being forced at gunpoint to harass people who use Windows?
11:32:41 <Solonarv> Welkin: I'm not, but I don't have backups and don't want to risk bricking my only working computer
11:32:55 <Solonarv> I'm also not really interested in having this discussion
11:32:58 <monochrom> Like, drop it already.
11:33:26 <cocreature> monochrom++
11:36:44 <Phyx-> rotaerk: new-install does not support windows yet in 2.4
11:36:47 <Phyx-> it will in 3.0
11:38:36 <Phyx-> rotaerk: if you really want to use new-install, you can install cabal-head from my nightlies from chocolatey https://hub.zhox.com/posts/chocolatey-introduction/ explains how, or compile from source
11:38:37 <Solonarv> Phyx-: I said that already, and pointed them at the cabal-head binaries ;)
11:38:45 <Phyx-> Solonarv: ah ok :)
11:39:01 <Phyx-> I was scrolling through the history :P should have kept going
11:39:09 <Solonarv> :D
11:39:36 <Solonarv> v2 commands being default in 3.0 is also very nice
11:40:03 <Phyx-> cocreature: somewhat broken is an overstatement. it lacks profiling libraries yet, but that's about it
11:40:20 <Phyx-> it's more stable, and fixes a plethora of issues that 8.4 and 8.6.2 had.
11:40:50 <Phyx-> and profiling will be back in 8.8. GHC just got too fat to fit into the standard COFF format
11:41:11 <hpc> hah, nice
11:41:15 <cocreature> Phyx-: the bindist is also a bit broken in some ways iirc (I think ben mentioned that he accitentally produced it from a "quick" build rather than a proper release build)
11:41:57 <Phyx-> cocreature: we have different definition of broken. So me, broken means segfaults, doesn't work, gives wrong results.
11:42:14 <Phyx-> e.g. 8.6.3 is broken because it has alignment faults
11:42:20 <cocreature> That’s fair, I should have phrased it differently. Sorry about that!
11:42:32 <cocreature> Also thanks for all the work you put into making GHC on Windows better!
11:43:42 <Phyx-> cocreature: thanks :) no worries, I was just pointing out that it's not the "world is burning" as it seems :)
11:45:02 <rotaerk> Phyx-, Solonarv, k thanks guys
11:45:12 <Phyx-> Solonarv: you can install multiple versions of ghc by giving chocolatey the -m flag
11:45:19 <Phyx-> -m stands for multiple
11:45:44 <Solonarv> ah, makes sense - I figured there would be something like that
11:46:18 <Phyx-> Solonarv: also if you don't want to have to remove the stable cabal, you can just request it not be install, e.g. choco install ghc --ignore-dependencies
11:46:27 <Phyx-> won't install stable cabal first
11:46:33 <Solonarv> nice!
11:50:09 <ddellacosta> monad-logger (using fast-logger) is a/the most standard choice when adding logging to a stack? Is that even a meaningful question?
11:50:48 <cocreature> ddellacosta: it’s at least one fairly popular choice
11:50:52 <monochrom> It is a meaningful question. But I don't know the answer.
11:51:01 <ddellacosta> that seems to get mentioned the most but I also see e.g. katip, di, etc.
11:51:08 <ddellacosta> okay, thanks cocreature, monochrom 
11:51:50 <Phyx-> rotaerk: cabal-head should work fine with platform, however the choco packages are designed to be conservative. they append to PATH and not prepend, so cabal from platform will still be found first in that case
11:52:26 <barryburd> Hello. I have a student who’s trying to run a simple program using NCurses. When he types “cabal new-repl” the project builds but the repl doesn’t start. I’ve posted a copy of his Terminal session and his project directory at https://users.drew.edu/bburd/ncursesAttempt.zip. Can anyone tell me what’s going wrong and how he can fix it? Thanks.
11:52:31 <merijn> ddellacosta: I like monad-logger but 
11:52:41 <merijn> ddellacosta: but "the standard choice", probably not...
11:53:10 <ddellacosta> merijn, cocreature: also, it seems like monad-logger exists on a bit higher level of abstraction, is that fair to say?
11:53:20 <merijn> ddellacosta: I except it's that standard choice in some specific corners of the ecosystem (i.e. the FPComplete corner) and plenty of people outside that corner like it too, but still
11:53:23 <ddellacosta> I mean, compared to a number of other libs
11:53:36 <merijn> s/except/expect/
11:53:58 <ddellacosta> merijn: yeah, as I've been digging in further I'm getting a sense that I'm kind of choosing between "the fpcomplete choice" and "everything else"
11:54:06 <merijn> That said, I do like the API and how easily it can be swapped with a more custom implementation
11:54:08 <ddellacosta> which doesn't seem bad or anything, it just seems to be the shape of the ecosystem
11:54:14 <merijn> I do wish it was slightly lighter in terms of dependencies
11:54:15 <cocreature> ddellacosta: doesn’t seem particularly high-level when you compare it with the other choices you mentioned, e.g., katip, die, …
11:55:01 <ddellacosta> cocreature: ah, fair enough--I guess maybe it's better to say, it seems to be less focused on providing an actual implementation
11:55:18 <ddellacosta> but I guess maybe even that is a grey area
11:55:36 <sclv> barryburd: taking a look
11:55:38 <cocreature> well it provides 4 different implementations :)
11:55:55 <cocreature> but yeah it tries to make it easy to write your own as merijn mentioned
11:56:17 <sclv> barryburd: the thing is its actually failing on the configure step of ncurses and its just not getting logged
11:56:20 <ddellacosta> cocreature: ha, okay I'll stop talking myself into a corner now...but yeah, I guess mostly it seems like it's got a pretty clean interface, even if I just want to do things mtl-style
11:56:26 <sclv> so the build isn't completing
11:56:35 <sclv> if ncurses actually built you'd see a lot more output!
11:56:48 <ddellacosta> alright well, cocreature and merijn and other folks, thanks for the help--I guess I'll start there
11:56:59 <barryburd> sclv: These steps seem to work fine when I do it on my Mac. Can you tell what he’s missing? I don’t see it.
11:57:07 <sclv> its a build error
11:57:14 <sclv> they should run with -v3 or something to get more logs
11:57:21 <sclv> and also ensure they're on a recent enough ghc and cabal
11:57:26 <barryburd> OK. Thanks.
11:57:33 <sclv> also are they on mac or windows or?
11:57:38 <barryburd> Linux
11:57:41 <sclv> hrm
11:57:58 <sclv> so my guess is they're missing the system libs necessary for ncurses to link against or something
11:58:03 <sclv> but the failure is hidden
11:58:23 <sclv> like they might need to apt-install ncurses-dev or whatever the appropriate library is?
11:58:36 <barryburd> I’ll have him run it with -v3 and take a look at the results.
11:59:05 <Phyx-> 18:31:00 < Solonarv> the chocolatey package is on 8.6.2 still; <-- I just pushed 8.6.4 today. I was waiting for GHC HQ to sort some things out before that
11:59:17 <Solonarv> yeah I just saw
12:00:35 <Phyx-> I'm finishing some patches to cabal and I'll have another package for the next release of GHC which should make installing a Windows dev environment one choco command, and some extra goodies
12:00:40 <cocreature> Phyx-: btw since you’re here. What is the status of your great work on the new IO manager? Will we get that in 8.8?
12:00:54 <Phyx-> hence the size differences in the packages on -head suddenly :)
12:01:35 <Phyx-> cocreature: no, 8.8 is too far along at this point, it'll likely be 8.10, it's a 7k lines patch so will take some time to review unfortunately.
12:02:05 <Phyx-> cocreature: it's about 90% finished, just working on stabilizing and documentation atm
12:02:13 <cocreature> Phyx-: nice, thanks for the update!
12:12:19 <slack1256> new IO manager? I feel "mio" was released just a while ago
12:14:07 <Phyx-> slack1256: mio was 2013, but it's also less then optimal on Windows.
12:14:37 * hackage trasa-server 0.4 - Type safe web server  https://hackage.haskell.org/package/trasa-server-0.4 (chessai)
12:20:36 <dminuoso> merijn: I wish monad-logger wasn't as restrictive when it comes to logging levels though.
12:26:27 <merijn> dminuoso: How so?
12:26:57 <merijn> dminuoso: You can add arbitrary levels via LevelOther
12:33:17 <c0mrade> I've made an IRC bot that prints to a dot matrix Star printer on its serial port at ##robot, everything you type there is printed to it and it's on Live Stream on YouTube at https://youtu.be/zwRL5V0XWQY
12:33:49 <Rembane> c0mrade: Good stuff. Is the code open source?
12:35:34 <sternmull> oh no, he is killing trees just for fun!
12:54:36 * hackage libarchive 1.0.3.0 - Haskell interface to libarchive  https://hackage.haskell.org/package/libarchive-1.0.3.0 (vmchale)
12:57:36 * hackage splitmix 0.0.2 - Fast Splittable PRNG  https://hackage.haskell.org/package/splitmix-0.0.2 (phadej)
13:01:37 * hackage trasa-th 0.4 - Template Haskell to generate trasa routes  https://hackage.haskell.org/package/trasa-th-0.4 (chessai)
13:12:29 * sm[m] wonders why such little paypal API support on hackage
13:13:24 <sm[m]> just http://hackage.haskell.org/package/paypal-rest-client and the even more ancient http://hackage.haskell.org/package/paypal-api
13:13:43 <sm[m]> if you know of anything better, please let me know! Trying to automate transaction fetching
14:05:36 <mjrosenb> Solonarv: no luck?
14:06:04 <Solonarv> mjrosenb: didn't find anything that does exactly what you want, no
14:06:37 <mjrosenb> I guess I can take a look at the implementation of <.~ and <<.~ and crib off of those.
14:06:41 <mjrosenb> shouldn't be all that hard.
14:36:20 <__Myst__> Is there any way to make a function take a record, a field, and update that field?
14:37:32 <mjrosenb> sounds like you want lenses!
14:38:00 <suzu> !
15:02:22 <dminuoso> % data Rec = Rec { fieldA :: Int, fieldB :: Char }
15:02:22 <yahb> dminuoso: 
15:02:32 <dminuoso> % foo = Rec 1 'c'
15:02:32 <yahb> dminuoso: 
15:03:02 <dminuoso> % modify r x = r { fieldB = x }
15:03:02 <yahb> dminuoso: 
15:03:10 <dminuoso> % modify foo 'd'
15:03:10 <yahb> dminuoso: ; <interactive>:64:1: error:; * No instance for (Show Rec) arising from a use of `print'; * In a stmt of an interactive GHCi command: print it
15:03:20 <dminuoso> __Myst__: ^- this?
15:03:58 <dminuoso> % modify foo 'd'
15:03:58 <yahb> dminuoso: Rec {fieldA = 1, fieldB = 'd'}
15:04:37 <dminuoso> lenses are not needed if all you want is a simple "setter" type of function.
15:15:42 <orzo> I don't like to use -Wincomplete-patterns normally, but it'd be nice to turn it on for specific functions where I do not want updates to upstream types to go unnoticed by my code.  Is there a way to mark a specific pattern match as intended to be complete?
15:16:38 <gentauro> dminuoso: lenses are very useful with nested record update. With basic records, you can get away with your example
15:20:07 * hackage circuit-breaker 0.1.0.0 - An implementation of the "circuit breaker" pattern to disable repeated calls to a failing system  https://hackage.haskell.org/package/circuit-breaker-0.1.0.0 (ChrisCoffey)
15:20:31 <lyxia> orzo: I don't think so, but it's a feature that has been mentioned quite a few times.
16:11:30 <Eromenos> Hi all. Is there a name for the mathematical property of a function where, (where a and b are the same type)  f(a) + f(b) = f (a + b) holds as true? Do we say something like the arguments are 'commutative over f'?
16:11:51 <lyxia> f is a homomorphism.
16:11:58 <lyxia> f commutes with +
16:12:14 <Eromenos> excellant ,thank you 
16:12:21 <hpc> that also looks like the distributive property
16:12:29 <hpc> f = (* some constant)
16:14:50 <Eromenos> and, further, if we have an inverse function that can extract a or b from f (a+b), do we call that an isomorphism?
16:15:56 <Eromenos> for instance, with the fourier transform we can isolate individual pure signals from a composed signal?
16:19:57 <ddellacosta> hi folks, I'm trying to implement some Katip instances for myself, but getting stuck on an error about MonadIO and superclasses. I'm confused about what I
16:20:03 <ddellacosta> 'm missing, any ideas? https://gist.github.com/ddellacosta/38f959fc8af5454974b28163bb259342
16:20:21 <ddellacosta> ^ tried to make that as simple as possible
16:28:56 <fr33domlover> In lazy record fields (which is the default), GHC emits a warning on missing fields, not an error, and sometimes I miss a field and I'd like the build to fail
16:29:14 <fr33domlover> Is there a way to make GHC emit an error even for lazy fields?
16:29:36 * hackage bisc 0.2.0.0 - A small tool that clears qutebrowser cookies.  https://hackage.haskell.org/package/bisc-0.2.0.0 (rnhmjoj)
16:29:47 <fr33domlover> (It does for strict fields - tbh I never used ! in any code though)
16:32:51 <hpc> -Werror perhaps
16:33:49 * hpc is trying out -Wall -Werror and it's been fairly straightforward so far
16:33:56 <Lears> ddellacosta: The error is fairly explicit. `Katip m` has superclass constraint `MonadIO m` hence the instance `Katip (App m)` requires `MonadIO (App m)`, but ghc can't infer that from what it has: `MonadIO m`. You can probably use GeneralisedNewtypeDeriving (might need StandaloneDeriving too) to get `MonadIO m => MonadIO (App m)`, since `ReaderT` should have the instance.
16:38:40 <ddellacosta> Lears: sorry I'm not 100% following you--you're saying it's telling me that it's missing a MonadIO instance for Katip?
16:39:19 <ddellacosta> btw sorry, I removed that gist, but here's a new one: https://gist.github.com/ddellacosta/e80759d1d6d5f91550ee148d14714642
16:39:40 <Nevoic> Hey, I'm messing around with Haskell, and I've come across some pretty simple things at compile time that don't get caught, and am curious about people's thoughts on them. Specifically referring to non-exhaustive pattern matching being allowed and the tendency to return errors when doing simple things like grabbing a `tail` which might not exist on
16:39:41 <Nevoic>  a List.
16:39:50 <ddellacosta> I guess even if it's explicit, I'm not understanding what "MonadIO (App m)" means here
16:40:25 <Nevoic> Does Liquid Haskell solve some of these problems? And if not, are there libraries that do?
16:41:45 <Nevoic> Can you guys see my messages? They're gray on my client.
16:41:52 <yushyin> yes we can
16:42:00 <Nevoic> Cool.
16:42:12 <ddellacosta> Nevoic: I can see them, I just don't know the answer other than to use an alternate prelude to avoid partial functions...otherwise not sure if Liquid Haskell could help
16:44:07 <ddellacosta> Lears: okay I realized now that it was indeed a MonadIO instance for (App m) that it was complaining about, I guess I was just confused because I was assuming I only needed it for 'm' I guess
16:44:17 <ddellacosta> thanks for restating the obvious I guess, lol
16:44:33 <ddellacosta> would be nice if they made that explicit in the example
16:47:55 <Lears> The example looks mistaken, they probably meant to derive MonadIO.
16:48:26 <ddellacosta> Lears: yeah, that was exactly what I did to solve it once I finally understood your comment
16:51:21 <yushyin> Nevoic: did you try '-fwarn-incomplete-patterns -Werror'?
16:55:35 <yushyin> Nevoic: http://hackage.haskell.org/package/safe-0.3.17/docs/Safe.html#g:2 maybe you want to use this safe wrapper
16:56:39 <yushyin> sometimes you can ditch the regular list for Data.List.NonEmpty
17:00:39 <Nevoic> yushyin I googled the `-fwarn-incomplete` thing, and found `{-# OPTIONS_GHC -Wall #-}` which has the advantage of integrating with Atom, so I can see the warnings inline and that's pretty awesome.
17:01:15 <Nevoic> It actually helped me catch a typo too, I might look at more of those options, that was awesome, thanks!
17:01:47 <yushyin> 'integrating with atom'?
17:02:36 <Nevoic> Yeah, just shows the warnings inline. I assumed your suggestion was a command line flag.
17:02:54 <yushyin> yes of course cli flags
17:29:44 <xpika> join #objective-c
17:57:45 <systemfault> So... I'm basically looking at a way to do the builder pattern in Haskell, tried Googling a little but could only find some comonad article that wasn't too clear for me.
17:58:21 <systemfault> Anyone has a suggestion oh how I should proceed? Or some good library I could use for inspiration?
18:10:07 * hackage th-orphans 0.13.7 - Orphan instances for TH datatypes  https://hackage.haskell.org/package/th-orphans-0.13.7 (MichaelSloan)
18:11:49 <ddellacosta> systemfault: why do you want to use the builder pattern? It's possible that whatever problem you're trying to solve may have an approach that is more natural in Haskell. But if you just want to straightforwardly import an OO design pattern into Haskell, it may be tough
18:14:28 <systemfault> ddellacosta: The end goal is being able to assemble some kind of  AST (JSONSchema) by composition of types.. some of them could be user-defined.
18:17:40 <ddellacosta> systemfault: okay, well working with an AST is definitely something Haskell excels at, I'd say, but it may involve a different approach--what prompted you to start with the builder pattern in this case?
18:18:04 <systemfault> ddellacosta: Unfortunately, probably my familiarity with OOP.
18:18:18 <ddellacosta> systemfault: heh, well you wouldn't be the first
18:20:48 <ddellacosta> systemfault: unfortunately I don't have a good suggestion without knowing more details of what you're trying to do, but if you're starting with JSON you may want to take a look at e.g. aeson https://hackage.haskell.org/package/aeson
18:21:56 <ddellacosta> if you're trying to build up an AST, there is a lot out there to review--for example: http://www.stephendiehl.com/llvm/#chapter-2-parser-and-ast
18:22:10 <ddellacosta> not sure if either of those are helpful but maybe they'll give you more ideas
18:22:39 <systemfault> Thank you :)
18:22:48 <ddellacosta> sure thing!
18:36:37 * hackage primitive-containers 0.3.3 - containers backed by arrays  https://hackage.haskell.org/package/primitive-containers-0.3.3 (andrewthad)
19:03:07 * hackage ordered-containers 0.2 - Set- and Map-like types that remember the order elements were inserted  https://hackage.haskell.org/package/ordered-containers-0.2 (DanielWagner)
19:09:26 <dmwit> d34df00d: Where's unsafeAccumArray? I would be willing to bet the "oddity" you're observing is that it's using Int directly rather than using the Ix instance of whatever index type you chose (which happens to also be Int in your case, possibly contributing to the confusion).
19:11:30 <d34df00d> dmwit: that's one of the methods of IArray (undocumented, though, yet exported from .Base).
19:11:48 <dmwit> (...after all, it *is* supposed to be the closest to bare-metal speed you can get, so any Ix indirection could hurt that.)
19:11:59 <d34df00d> Looking at the source of `accumArray`, it does some extra checks to make sure the indices are valid and stuff like that. I'm surprised that gives that much of performance drop, but that's it.
19:12:32 <d34df00d> Also, +1 reason one dependent types are useful. There is no need to be unsafe here, I can surely prove that k_1 * k_2 is always within (1, n) bounds.
19:12:37 <dmwit> Ah, yep, compare the types of accumArray and unsafeAccumArray:
19:12:51 <dmwit> accumArray :: Ix i => ... -> [(i, a)] -> Array i e
19:13:04 <dmwit> unsafeAccumArray :: ... -> [(Int, a)] -> a i e
19:13:12 <d34df00d> Hmm, shouldn't gcc specialize?
19:13:15 <d34df00d> ghc, meh
19:13:48 <dmwit> So, yeah, bounds checks and conversion from index to Int are both elided by unsafeAccumArray -- that's your job as the caller, if it will be done at all.
19:14:03 <dmwit> Like, conversion from logical index to physical index.
19:14:32 <dmwit> This has nothing to do with specialization, I don't think.
19:14:42 <d34df00d> Hmm, that explains it too.
19:14:45 <dmwit> Even if you specialize to the Int instance of Ix, there still needs to be some minimal computation to do the conversion.
19:15:01 <d34df00d> So the fact that I have to adjust the indexing to happen from 0 is explained! Neat!
19:15:15 <dmwit> (Subtracting the logical index of interest from the lowest logical index used to make the array.)
19:16:15 <d34df00d> Alright, expecting ghc to constant-propagate zero lower bound (if I have my bounds as (0, n - 1)) is perhaps a bit too much.
19:16:46 <dmwit> It's not a constant, though, which is kind of the point.
19:16:53 <d34df00d> Yeah, thanks for clarifying the difference!
19:16:55 <dmwit> It's a value stored in the UArray data structure.
19:17:16 <d34df00d> dmwit: hmm, even for accumArray? I pass the bounds to it explicitly, right?
19:17:31 <dmwit> Ah, okay, maybe for unsafeAccumArray, yeah.
19:17:33 <dmwit> Fair enough.
19:45:59 <fen> whats this pattern? 
19:46:46 <fen> data A a => A :: a ~ b => 
19:46:57 <fen> where b is some globally available datatype
19:47:31 <fen> and `a' or `b' does not appear to the right of the constraint
19:48:03 <fen> that is, `a' is a phantom type, other than that it is constrained to equal some other type
19:48:35 <Lears> It's a weird way to write a GADT.
19:48:50 <fen> it seems like this can be used almost like a non-parametric type family, ie a mapping from some type to another 
19:50:07 <fen> such as, B b => B :: b ~ Bool => Int -> B b
19:50:33 <fen> is like type family B b where B Bool = Int
19:51:40 <fen> this only works because b does not appear on the rhs, ie it is a non-parametric mapping, just associating *one* type to another
19:52:13 <fen> Lears: thats not exactly the answer I was going for...
19:56:55 <fen> while we can use a defunctionalised type family as the parameter of a class, it seems that we can also use this kind of dataype when the type family is not parametric on the input type
19:58:16 <fen> maybe there are some things to be wary of when doing this, not really sure as it seems to be an unfamiliar pattern
20:23:33 <remexre> is there a nice Int -> Word function?
20:23:59 <remexre> (also, why do all the length functions return ints...)
20:24:11 <dibblego> @type genericLength
20:24:12 <lambdabot> Num i => [a] -> i
20:24:47 <geekosaur> fromIntegral
20:24:58 <geekosaur> hm, maybe
20:25:04 <geekosaur> fromEnum/toEnum
20:25:07 <geekosaur> :t fromIntegral
20:25:08 <lambdabot> (Num b, Integral a) => a -> b
20:25:11 <geekosaur> yeh
20:25:14 <remexre> oh, nice
20:25:40 <remexre> also dibblego: Yeah, but not for like Text, ByteString, etc
20:27:23 <glguy> genericLength is for when you want to do the length computation at a different type, not just to save yourself a fromIntegral at the end
20:28:50 <glguy> remexre: The length functions use Int because it's almost always big enough and can be efficient
20:30:47 <remexre> more efficient than word?
20:31:09 <remexre> and what do you mean "at a different type"?
20:31:12 <glguy> Oh, probably same as that, but Word tends to be error prone to use and is more focused on bit-fiddling than arithmetic
20:31:47 <glguy> genericLength is for when you want the accumulator to use a non-Int type
20:31:53 <remexre> wait how? wrt error-prone
20:32:14 <remexre> oh, like doing it directly on e.g. Word32 to save a couple cycles? makes sense
20:32:45 <glguy> except genericLength is more likely to be slower than save a couple cycles unless you're sure it's going to inline
20:32:49 <glguy> and recursive functions don't
20:33:28 <glguy> The real use for it is for lazy-nats as a cute demo
20:33:53 <glguy> genericLength []        =  0
20:33:53 <glguy> genericLength (_:l)     =  1 + genericLength l
20:34:11 <geekosaur> Word has the problem that you often want to compute with the result of e.g. length, and if you force Word and then subtract too large a value, it isn't a runtime error, it wraps around
20:34:48 <glguy> You can basically forget that genericLength exists other than to be wary if you see it in use
20:34:56 <remexre> glguy: alright
20:35:24 <remexre> geekosaur: in practice (during development), wouldn't indexing to element 2^64-1 error out too?
20:35:34 <glguy> It's easy to think that Word makes for a better type for indexing until you notice that it has the same number of invalid indexes for most types as Int does
20:35:47 <glguy> and hides mistakes by wrapping around to large values instead of negative ones
20:36:10 <remexre> my main liking of unsigned>signed is from "hey this is the group Z/(2^64Z)"
20:36:28 <geekosaur> if you're indexing with it, yes. if you're doing something else, maybe not
20:36:32 <geekosaur> liek read that many elemnts from a network stream
20:37:01 <remexre> eh, I'
20:37:15 <remexre> d probably have trapping subtraction in RemexreLang instead :P
20:44:57 <mjrosenb> :t <&>
20:44:58 <lambdabot> error: parse error on input ‘<&>’
20:45:03 <mjrosenb> :t (<&>)
20:45:04 <lambdabot> Functor f => f a -> (a -> b) -> f b
20:46:50 <mjrosenb> how do I ask lambdabot where that's defined?
20:47:10 <dibblego> ya can't, :info in ghci
20:47:13 <geekosaur> @index (<&>)
20:47:13 <lambdabot> bzzt
20:47:21 <geekosaur> ah, well
20:47:25 <geekosaur> nobody's updated that db, I guess
20:47:31 <glguy> % :info <&>
20:47:31 <yahb> glguy: (<&>) :: Functor f => f a -> (a -> b) -> f b -- Defined in `Data.Functor'; infixl 1 <&>
20:48:11 <mjrosenb> :info would help me if it were in scope in ghci.
20:48:37 <geekosaur> hoogle's decent for that kind of search
20:48:53 <geekosaur> @hoogle (<&>)
20:48:53 <lambdabot> Control.Lens.Lens (<&>) :: Functor f => f a -> (a -> b) -> f b
20:48:54 <lambdabot> Control.Lens.Operators (<&>) :: Functor f => f a -> (a -> b) -> f b
20:48:54 <lambdabot> Lens.Micro (<&>) :: Functor f => f a -> (a -> b) -> f b
20:49:02 <geekosaur> except when it gets too many hits...
20:49:24 <dmwit> remexre: Eh, Word is not Z/(2^64Z). It includes elements like 2 that are not coprime to 2^64, and doesn't implement the group inverse operation.
20:49:53 <remexre> dmwit: additive group? unary -
20:50:08 <dmwit> That's a different group. And Int is also that group (up to isomorphism).
20:50:36 <remexre> -INT_MIN = INT_MIN, though?
20:52:03 <dmwit> So? INT_MIN + -INT_MIN = 0, as required.
20:52:39 <remexre> I was under the impression that there was some property of groups that needed identity to be the only x = -x
20:52:52 <dmwit> Yeah, that sounds right.
20:52:54 * dmwit ponders
20:55:16 <dmwit> I retract "is also that group up to isomorphism".
20:55:35 <dmwit> But it does seem to satisfy all the group laws.
20:56:20 <dmwit> Hah.
20:56:31 <dmwit> > negate (2^63 :: Word64) == 2^63
20:56:33 <lambdabot>  True
20:56:58 <dmwit> Perhaps you're thinking of the property that says that there's only one element that acts as the identity.
20:57:20 <remexre> maybe...
20:57:56 <dmwit> Anyway this doesn't seem to be a good reason to prefer unsigned over signed.
20:59:14 <dmwit> ?quickCheck \x -> fromIntegral (negate (fromIntegral (x :: Word64)) :: Int64) == negate x
20:59:14 <lambdabot> Unknown command, try @list
20:59:22 <dmwit> ?check \x -> fromIntegral (negate (fromIntegral (x :: Word64)) :: Int64) == negate x
20:59:24 <lambdabot>  +++ OK, passed 100 tests.
21:00:00 <dmwit> ?check \x y -> fromIntegral (fromIntegral (x :: Word64) + fromIntegral y :: Int64) == x + y
21:00:02 <lambdabot>  +++ OK, passed 100 tests.
21:00:28 <dmwit> There you have it. P. good evidence that they are isomorphic as groups.
21:00:56 <remexre> right, yeah, that makes sense
21:01:02 <remexre> since there's only one add instruction
21:01:29 <remexre> and only one zero flag etc
21:11:36 <Nevoic> How do you guys get around the readability loss of lacking default parameters? For example, something like: `maybe 0 (+ 2) x`, which I just saw, as opposed to `maybe(x, default = 0) { it + 2 }`.
21:12:45 <Nevoic> You could take it to the extreme level too `maybe(item=x, default=0, blockToApplyIfExists={ it + 2 })`.
21:14:01 <glguy> Named parameters like that in small cases are verbose enough to hide the meaning of the code, but in larger examples we use records
21:14:30 <Nevoic> Yeah I'm using records for a larger example right now, they're definitely helpful.
21:14:34 <Nevoic> I don't follow though.
21:14:45 <Nevoic> "in small cases are verbose enough to hide the meaning of the code"
21:15:12 <Nevoic> Verbosity, at least in my understanding, never hides code meaning. It's sometimes redundant, or unnecessary entirely, but if it's good for anything, it's readability.
21:15:36 <glguy> It hides the meaning of the code by creating noise that's always the same
21:15:38 <Nevoic> I want to stress "if it's good for anything". Sometimes it's entirely useless (boilerplate).
21:15:47 <glguy> instead of focusing on the important values
21:17:06 <Nevoic> I don't understand. Why is a named parameter noise if it tells me something I didn't already know?
21:17:41 <Nevoic> I read someone's code, `maybe 0 (+ 2) x`, and because I don't have the type definition of every standard library function memorized, I didn't know which values pertained to what.
21:18:04 <glguy> Because you only don't know it at the very beginning, and if you don't know what you're looking at there's probably other important things about it you should be reading in the documentation anyway that isn't captured in the argument names
21:18:43 <Nevoic> Ah okay, so your argument is I'll memorize all the important things, and until then I should be reading documentation?
21:19:54 <Nevoic> I might actually not be smart enough to use Haskell then. I've never really tried to develop my skill of memorizing which values correspond to what thing based on purely position.
21:20:10 <glguy> It's worth giving it a shot
21:20:41 <Nevoic> Is that just the case though? Haskell is for more clever people, and if you can't comprehend it you have to go back to some more descriptive language?
21:20:59 <glguy> Having named parameter means you have even more to memorize
21:21:17 <glguy> now you have to memorize the names of the parameters. This works in a language like ObjC where you're always writing it in XCode and the editor is helping out
21:21:38 <Nevoic> That's not the case, I don't know if you've ever worked in a statically typed imperative language that has good tooling, but in Kotlin/Swift/Java/C# etc. you'd have the compiler to tell you the name of things.
21:21:38 <glguy> without that it would be quite a bit more challenging for these people you're describing who don't know any of the definitions
21:22:10 <Nevoic> Even in Python/Ruby they can often find which function you're running and suggest the named parameters (in Pycharm and Rubymine) although it's not as reliable obviously because it's guessing.
21:22:41 <Nevoic> Like every other language i use has the tooling you're describing from Objective C.
21:22:55 <Nevoic> If you're using like C or something else made more than 40 years ago you might be screwed, I guess.
21:23:27 <Nevoic> But I don't even think C has named parameters. I don't remember.
21:23:35 <glguy> It doesn't
21:24:03 <mjrosenb> so, as far as I can tell, naming parameters, and currying don't really get along.
21:24:17 <Nevoic> Oh yeah, totally. That's why I didn't ask for named parameters.
21:24:26 <Nevoic> I asked how you guys solved the problem of losing the readability of named parameters.
21:25:04 <Nevoic> The first answer I got was "well you'll memorize all the important things", which isn't really reassuring. That means the learning curve for any new codebase will be intense, and I'll have to wait for developers to memorize all the various things in my code base. 
21:25:38 <Nevoic> The learning curve on a new project is tough enough with the help of well documented meaning.
21:28:39 <glguy> That statement just doesn't resonate with me because I've worked on lots of codebases without named parameters and haven't experienced the consequences you're describing
21:29:41 <Nevoic> How many have you worked with, in comparison, with named parameters (in an environment that uses the information to help you).
21:29:50 <Nevoic> Out of curiosity, I'm guessing quite a few.
21:32:44 <mjrosenb> I've used C, C++, Java, and a bit of python.  I don't really feel like the named parameters in python really helped me over the other languages.
21:33:50 <Nevoic> Me neither, if we're talking Python specifically. Like I said before, before the program runs, all the linter (as it's not the compiler) can do is guess as to what method you're trying to call, and it seldom does a good job unless you're working in a small script.
21:34:46 <Nevoic> If you use a modern static language (something built in the last 15 years) then the compiler really comes in and helps you a lot. You can autocomplete to a method, and then tab through the named parameters. You don't have to type them out, and it tells you explicitly the name of the thing you need to put there, instead of just the type.
21:35:33 <Nevoic> I'd say like 95% of the time I don't care, but the other 5% means instead of it just telling me, I'd have to look up the documentation for the method.
21:35:45 <Nevoic> Which feels like a bit of a reversion to the sad times of Python/Ruby.
21:36:58 <Nevoic> I should mention it obviously tells you the type too, you just don't need to specify it out in code.
21:43:49 <Nevoic> I do want to mention, I think people generally agree with me on this point more than they'd like to admit, that's why records exist. Person :: String -> String -> String -> String -> String -> String would be hard to keep track of.
21:44:06 <Nevoic> For some people Person :: String -> String -> String is hard to keep track of. Or even Person :: String -> String.
22:15:07 * hackage asap 0.0.1 - Atlassian Service Authentication Protocol  https://hackage.haskell.org/package/asap-0.0.1 (puffnfresh)
22:24:07 * hackage hw-ip 2.2.0.0 - Library for manipulating IP addresses and CIDR blocks  https://hackage.haskell.org/package/hw-ip-2.2.0.0 (haskellworks)
22:40:15 <dminuoso> gentauro: Im fully aware. But if someone comes into this channel asking just how to write a simple accessor I don't blindly presume they have an ulterior motive where they look for `lens`. I just base my answer on what has been asked. ;)
22:50:06 * hackage asap 0.0.2 - Atlassian Service Authentication Protocol  https://hackage.haskell.org/package/asap-0.0.2 (puffnfresh)
22:51:06 * hackage hw-ip 2.3.0.0 - Library for manipulating IP addresses and CIDR blocks  https://hackage.haskell.org/package/hw-ip-2.3.0.0 (haskellworks)
22:56:37 * hackage jwt 0.10.0 - JSON Web Token (JWT) decoding and encoding  https://hackage.haskell.org/package/jwt-0.10.0 (puffnfresh)
23:55:38 <koz_> Can someone help me figure out this question involving Data.Finite? https://gist.github.com/kozross/cba8a5d4c55fb5dba87019fe55dd2632
