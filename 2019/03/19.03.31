00:51:37 * hackage password-instances 0.3.0.0 - typeclass instances for password package  https://hackage.haskell.org/package/password-instances-0.3.0.0 (cdepillabout)
01:03:09 <teeghee> Hi all I have a question
01:03:56 <teeghee> let's say I have functions f :: a -> b and g :: a -> c.  How can I make a function a -> (b, c) which is effectively (f, g)
01:04:44 <teeghee> ?
01:06:12 <teeghee> of course i can make it like (\x -> (f x, g x))
01:06:28 <teeghee> but is there more elegant way to make this?
01:07:49 <kaol> :t (&&&)
01:07:50 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
01:08:47 <kaol> > ((+1) &&& show) 5
01:08:49 <lambdabot>  (6,"5")
01:09:42 <teeghee> Wow thanks!
02:07:31 <mr971[m]> > ((+1) &&& show) >>> ((+10) *** (++ "...")) >>> right ("..." ++) $ 5
02:07:33 <lambdabot>  error:
02:07:33 <lambdabot>      • Couldn't match type ‘Either d [Char]’ with ‘(Integer, [Char])’
02:07:33 <lambdabot>        Expected type: (Integer, [Char]) -> Either d [Char]
02:08:17 <mr971[m]> > ((+1) &&& show) >>> ((+10) *** (++ "...")) >>> Control.Arrow.right ("..." ++) $ 5
02:08:19 <lambdabot>  error:
02:08:19 <lambdabot>      • Couldn't match type ‘Either d [Char]’ with ‘(Integer, [Char])’
02:08:19 <lambdabot>        Expected type: (Integer, [Char]) -> Either d [Char]
02:11:32 <kaol> > ((+1) &&& show) >>> ((+10) *** (++ "...")) >>> snd >>> ("..." ++) $ 5
02:11:34 <lambdabot>  "...5..."
02:13:52 <mr971[m]> ((+1) &&& show) >>> ((+10) *** (++ "...")) >>> second ("..." ++) $ 5
02:14:26 <mr971[m]> dammit, it's `second`, not `right`
02:14:27 <mr971[m]> > ((+1) &&& show) >>> ((+10) *** (++ "...")) >>> second ("..." ++) $ 5
02:14:30 <lambdabot>  (16,"...5...")
02:17:43 <mr971[m]> > ((+1) &&& show) >>> ((+10) *** (++ "...")) >>> second ("..." ++) >>> first show >>> arr (uncurry (++)) $ 5
02:17:44 <lambdabot>  "16...5..."
02:50:00 <mniip> mr971[m], liftA2 (++) (liftA2 (++) (liftA2 (++) (show . (+10)) (pure "...")) (show . (+1))) (pure "...")
03:46:52 <yuuki_> I want to improve my understanding of certain Haskell topics through short blog posts. It would be incredibly helpful if someone could go over the first such post and let me know if I made any mistakes. It's a fairly short post and I like to think that I'm generally good at dealing with criticism so don't hold back <3. https://fbrs.io/applicative-compose/
03:49:52 <ph88> how do i get the core file dump from dependencies ?
03:50:30 <delYsid> yuuki_: I would write theclass definition first.  Type signatures on instance definitions are sort of uncommon to do.
03:50:59 <yuuki_> Good point thanks
03:55:11 <ph88> yuuki_, i private message you
04:00:33 <Tuplanolla> This is not related to the content, but your website is almost unreadable due to WCAG F24 and F83, yuuki_.
04:00:42 <Tuplanolla> Details are here: https://www.w3.org/TR/2016/NOTE-WCAG20-TECHS-20161007/F24
04:01:40 <yuuki_> oh wow thanks
04:10:04 <ph88> yuuki_ ?
04:11:16 <yuuki_> Sorry was making eggs :P thanks a lot for your messages, I'll revise the post and incorporate the things you mentioned @ph88
04:11:33 <ph88> cool
04:11:34 <ph88> good luck
04:13:25 <delYsid> Nice to see someone quote WCAG
04:53:19 <Axman6> Does anyone know of any techniques for parsing things which may occur in any permutation? I'm thinking about parsing things with well typed key-value pairs where the values may be of different types, and I want them to be parsed into a structure; data Foo = Foo {x :: Int, y :: String, z :: Double}; parseFoo = Foo <$> kv "x" <*> kv "y" <*> kv "z"; -- input may look like z: 1.234, x: 7, y: "hello"
04:53:59 <Axman6> preferably avoiding the Aeson approach opf parsing into an intermediate strcuture representing the underlying format
04:57:38 <Axman6> I was thinking of something like: data ParseKV keyType outerType = ParseKv keyType (forall field; Serialise field => outerType -> field -> outerType) would allow me to gather all the field parsers, and select the correct one based on the key, but the problem is I need an empty outerType initally which has its fields updated, and doesn't let me take advantage of Applicative
04:58:43 <Axman6> I feel like this must already be a solved problem
05:04:57 <Athas> Does anyone here know of a Nix-based setup for building static Haskell binaries, and which also works well in a normal CI setting (like Travis)?
05:05:20 <Athas> I found https://github.com/nh2/static-haskell-nix, but their example for building Stack statically took hours.
05:06:00 <Athas> The development version of cabal has --static, but they mention that statically linking against glibc may not be a good idea.
05:20:37 <gentauro> Athas: ask in `#nixos` (srhb will probably know it) ;-)
05:31:28 <Axman6> Stackoverflow is beautiful at the moment
05:32:55 <__monty__> It is?
05:49:44 <gentauro> Axman6: in the sense ...?
05:50:20 <gentauro> oh `Back to the future! Just like the '90s, good things have to come to an end. If you want to switch to the current site, you'll find the option here.`
06:06:18 <__monty__> Just an early april 1st?
06:29:50 <__monty__> Hmm, is there an easy way to get a Rational formatted as a fixed point decimal?
06:31:15 <Thyringer> I've read this page and wonder if EVERYTHING in Haskell is actually an expression?
06:31:15 <Thyringer> http://www.haskellforall.com/2013/07/statements-vs-expressions.html
06:32:02 <__monty__> Thyringer: If you check out the report you'll find that's true.
06:33:26 <f_n> is there a pattern for something like state encoding but with the possibility to require a "restart" function to change the state so that it can keep producing values?
06:33:49 <mikail_> Need some help interpreting this function from the Arrow typeclass
06:33:50 <mikail_> first :: a b c -> a (b, d) (c, d)
06:34:05 <mikail_> (b,d) is a 2-tuple?
06:34:09 <f_n> and, if so, how does it relate to the church encoding?
06:34:24 <f_n> mikail_, yes, or "pair"
06:34:30 <mikail_> ta
06:35:22 <Thyringer> letztlich kann man 
06:35:30 <Thyringer> is not the entire x = 1 construct a statement?
06:35:30 <Thyringer> as well as declarations name :: DT -> ...
06:37:09 <c_wraith> the only things called "statements" in haskell are lines in a "do" block.
06:37:21 <lyxia> Thyringer: these are declarations
06:38:50 <fen> not sure if this is the same concept as a "restarted state" but there can also be nested states, states returning other states, so that unfold x2 produces a list of lists
06:39:11 <fen> is it a zygomorphism or paramorphism or something?
06:39:57 <fen> build with the church encoding of such would retain a state, or be able to return a new state on calling the "restart" function...
06:40:24 <fen> not sure if thats confused as normally the build (church encoding) hides the actual state...
06:41:20 <fen> how confusing is that!? might be able to have a nested build fusion, but having quite some trouble comprehending such a thing
06:43:28 <fen> basically, have `(d,s) -> Maybe (a,Maybe (d,s))' where d are "directions". and have a loop which produces from this a regular state; s -> (a,Maybe s)
06:44:13 <fen> when the directions cause the loop to halt, returning Nothing, then the next to last value can be used with "new directions" to "restart" the loop
06:44:55 <fen> this halting loop seems to have input from the user in terms of new directions, so it would not be reasonable to expect fusion to commute through this...
06:45:09 <fen> unless maybe the directions were always the same and available via a default...
06:46:39 <fen> so thats maybe where the church encoding can help, by "hiding" the internal state, and possibly also this restarting mechanism
06:46:52 <Thyringer> Are not declarations statements (to the compiler)?
06:47:56 <fen> maybe a good way to picture this is using set builder notation like [a|a<-b,b<-c]
06:48:32 <fen> so basically, am seeking a nested version of church encoding...
06:49:12 <fen> hence wondering if any of these other recursion schemes - paramorphism etc, could help
06:50:00 <fen> as it seems they are built up of internal loops that should return additional information as opposed to a regular anamorphism
07:00:09 <lyxia> Thyringer: the standard defines precisely something called "declaration" https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-620004 and something else called "statement" https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
07:00:55 <lyxia> Thyringer: every programming languages uses these words in a different way (or doesn't).
07:01:43 <Thyringer> yes, That's why I'm asking! thanks for the links.
07:07:19 <Thyringer> a bond is ultimately not evaluated; and can not be tied to other names like an expression, so I find the statement that everything in haskell is an expression somewhat confusing.
07:07:19 <Thyringer> Prelude> x = 10
07:07:19 <Thyringer> Prelude> 10
07:07:19 <Thyringer> 10
07:07:44 <Thyringer> Prelude> y = (x = 10)
07:07:44 <Thyringer> <interactive>:4:8: error:
07:07:44 <Thyringer>     parse error on input ‘=’
07:07:44 <Thyringer>     Perhaps you need a 'let' in a 'do' block?
07:07:44 <Thyringer>     e.g. 'let x = 5' instead of 'x = 5'
07:07:44 <Thyringer> Prelude> 
07:07:46 <Thyringer> Prelude> y = (x = 10)
07:07:50 <Thyringer> <interactive>:4:8: error:
07:07:52 <Thyringer>     parse error on input ‘=’
07:07:54 <Thyringer>     Perhaps you need a 'let' in a 'do' block?
07:07:56 <Thyringer>     e.g. 'let x = 5' instead of 'x = 5'
07:07:58 <Thyringer> Prelude> 
07:08:00 <Thyringer> Prelude> y = (x = 10)
07:08:02 <Thyringer> <interactive>:4:8: error:
07:08:04 <Thyringer>     parse error on input ‘=’
07:08:06 <benzrf> pls no more
07:08:06 <Thyringer>     Perhaps you need a 'let' in a 'do' block?
07:08:08 <Thyringer>     e.g. 'let x = 5' instead of 'x = 5'
07:08:10 <Thyringer> Prelude> 
07:08:12 <Thyringer> Prelude> y = (x = 10)
07:08:14 <Thyringer> <interactive>:4:8: error:
07:08:16 <Thyringer>     parse error on input ‘=’
07:08:20 <Thyringer>     Perhaps you need a 'let' in a 'do' block?
07:08:22 <Thyringer>     e.g. 'let x = 5' instead of 'x = 5'
07:08:24 <Thyringer> Prelude> 
07:10:52 <lyxia> Thyringer: you are spamming the channel
07:12:05 <Thyringer> copying mistakes, that was not my intention.
07:12:40 <fen> Thyringer: whats the question?
07:13:46 <Thyringer> The question is, is really ALL in haskell an expression.
07:13:57 <lyxia> no it's not to be taken literally
07:17:41 * Ariakenom once posted a image, but the image data was in the url
07:17:46 <Ariakenom> now that's spam :/
07:18:45 <Athas> Let me repeat just how good ghcid is.
07:18:48 <Athas> That is how tools should be made.
07:20:21 <Ariakenom> Athas: Do I need to find a haskell project just so I get to use it?
07:20:41 <Athas> Sure!  Why not!
07:28:56 <fen> no ideas about nested state or church unfold fusion as described above?
07:33:13 <Big_G> Morning all. What fun Haskell'in have you been up to?
07:37:28 <asthma[m]> @Big_G I Haskell'ed myself into a hangover. I really wish I was stateless rn
07:37:28 <lambdabot> Unknown command, try @list
07:38:38 <Iceland_jack> lhi
07:38:42 <Iceland_jack> *hi
07:40:51 <lyxia> Iceland_jack: o/
07:41:14 <Iceland_jack> howdy lyxia :]
07:41:31 <lyxia> Iceland_jack: are you (still) on the path to a PhD
07:41:43 <maerwald> asthma[m]: state or monad stream, what is the difference :>
07:42:08 <Iceland_jack> Hm I can't say I am at the moment, although I want to
07:43:48 <heebo> hello what package is the best for manipulating timestamps 
07:46:12 <heebo> time seems apt. :-/
07:52:51 <[exa]> heebo: afaik there was a wrapper around unix `date` somewhere
07:53:10 <[exa]> or generally the underlying functions (was it strftime?)
07:54:07 * hackage slist 0.0.0 - Sized list  https://hackage.haskell.org/package/slist-0.0.0 (vrom911)
08:08:10 <dexterfoo> I have a char* pointer from C code. How can i send this data as an HTTP response using wai, without making a copy of it into a new ByteString?
08:10:01 <[exa]> dexterfoo: will the char* pointer be available through the entire lifetime of the response-sending process?
08:11:23 <dexterfoo> [exa]: yeah. but i need to know when that all finishes so that i can call free() on the ptr
08:11:52 <[exa]> dexterfoo: is the response super-huge?
08:12:47 <[exa]> I guess there is a way to make some tangible bytestring-like thing even with transferring the memory management responsibility
08:15:08 <dexterfoo> it's a few kilobytes, but very high throughput of this response. it doesn't look like i can use ByteString without making a copy. and i couldn't find a way to use Builder directly with a pointer. i think i will just make a copy of the data into a new ByteString :/
08:15:34 <[exa]> dexterfoo: anyway, what about creating the space with unsafeUseAsCString and fill the memory from C?
08:16:52 <[exa]> oh wow there's unsafePackMallocCStringLen, that's probably what you want
08:17:01 <dexterfoo> oh, i didn't see those unsafe functions!! looks like `unsafePackCStringLen` will do the trick
08:17:26 <dexterfoo> i need to call a custom free function
08:18:03 <dexterfoo> looks like `unsafePackCStringFinalizer` should work perfectly!
08:18:13 <[exa]> unbelievable. :D
08:20:07 * hackage barbies 1.1.2.0 - Classes for working with types that can change clothes.  https://hackage.haskell.org/package/barbies-1.1.2.0 (DanielGorin)
08:27:07 * hackage barbies 1.1.2.1 - Classes for working with types that can change clothes.  https://hackage.haskell.org/package/barbies-1.1.2.1 (DanielGorin)
08:29:16 <dmwit> oh dear
08:36:37 * hackage dynamic 0.0.1 - A dynamic type for Haskell  https://hackage.haskell.org/package/dynamic-0.0.1 (ChrisDone)
08:38:40 <[exa]> dmwit: it's evolving.
08:39:45 <jusss> parseInt :: String -> Maybe Int
08:39:53 <jusss> how I can define this function?
08:40:35 <dmwit> parseInt = readMaybe
08:41:37 <jusss> dmwit:  Variable not in scope: readMaybe :: String -> Maybe Int
08:41:41 <dmwit> ?index readMaybe
08:41:41 <lambdabot> Text.Read
08:42:10 <jusss> ok
08:43:03 <jusss> dmwit: parseInt 3 still get error
08:43:12 <dmwit> Correct. 3 is not a String.
08:43:30 <dmwit> String literals have quotes.
08:43:57 <jusss> dmwit: can I use Maybe String?
08:44:09 <jusss> parseInt :: Maybe String -> Maybe Int
08:44:23 <dmwit> :t (>>= readMaybe)
08:44:24 <lambdabot> Read b => Maybe String -> Maybe b
08:44:38 <jmcarthur> Does anybody know of anything I can read to kick off this line of thought?:  IVar (write-once) is to laziness (force-once) as LVar (monotonic write-many) is to <what> (monotonic force-many)
08:45:40 <dmwit> IVar is to deepseq as LVar is to seq?
08:45:41 <jmcarthur> An example of that last one might be one of Okasaki's queue implementations, where a node in the tree can be evaluated in one of two ways, updating it in place, but once you have evaluated it both ways then it has converged.
08:46:41 <jmcarthur> This one http://www.aladdin.cs.cmu.edu/papers/pdfs/y2000/catenable.pdf
08:46:47 <jusss> dmwit:  how I create a type, it can be Int or String?
08:47:08 <dmwit> :t [Left 3, Right "not 3"]
08:47:09 <lambdabot> Num a => [Either a [Char]]
08:47:13 <dmwit> oh go on
08:47:18 <dmwit> :t [Left (3 :: Int), Right "not 3"]
08:47:20 <lambdabot> [Either Int [Char]]
08:47:46 <jmcarthur> dmwit: Yeah, I see what you're saying there, which is that you can view seqing different parts of a data structure as a kind of monotonic force-many.
08:48:18 <jmcarthur> dmwit: But I'm interested in exploring things that can be done more conveniently and efficienctly by updating the same reference multiple times.
08:48:19 <dmwit> jmcarthur: Yeah. From your followup I see it's not really where you were hoping to go, though.
08:48:29 <jmcarthur> *efficiently
09:55:06 <fen> whats; x -> (a -> b -> b) -> b -> (y,b)            ?
09:58:23 <fen> its supposed to be some kind of church encoding with extra input and output, as in, it needs `x' to produce the implicitly stored Foldable f => f a, and during the folding to produce b, it also produces an output `y'.
09:59:33 <fen> does that work? like, is that a valid approach? to abstract away the way that `y' is produced in particular seems dubious
10:00:35 <fen> not sure why, just seems like saying "when this is folded, it also returns `y'"... but without even knowing how to fold something and it also produce a `y', is it a valid abstraction to make?
10:02:44 <fen> its some form of continuation encoding right? not quite sure how to understand what can be meant by them, as in, does the encoding have undesired flexibility? or does it basically work as described, as a way to encode this extra folding correctly
10:30:43 <fen> the idea is that by using this abstraction instead of just Foldable f => f a, which wouldnt be able to return `y' upon folding, that it forces some other encoding, such as (s,s -> Maybe (a,s)) where then `s' could be returned as `y' or something more complicated to also have a way to produce a different `y' possibly from a different kind of encoding of the container of `a'
10:32:24 <lunabo> fen: how would you ensure that you can get an a from x in that encoding?
10:32:31 <fen> the problem is however, that by abstracting away the precise implementation of the way the container, and "extra folding function" that also produces an output `y', is that without a concrete realisation of this, there is nothing to use for a fusion rule...
10:32:49 <fen> lunabo: how do you mean?
10:33:46 <lunabo> fen: maybe I'm not understanding your notation, but do you mean forall x a b y (the type you wrote)
10:33:46 <fen> its supposed to be like (a -> b -> b) -> b -> b as an encoding of Foldable f => f a
10:34:29 <fen> probably only b should be foralled
10:35:14 <fen> its definatly a container of a, so it would be like type Encoding a x y = forall b. x -> (a -> b -> b) -> b -> (y,b)    
10:36:13 <fen> actually not sure, maybe with provision of different arguments it could produce a different y..
10:36:23 <fen> maybe not though as y does not appear in any of the arguments!
10:37:29 <fen> anyway, the problem is still trying to find the inverse of this, like if a "folding function partially applied to a foldable container" is a church encoding, then a "something function partially applied to something" is this encoding
10:38:13 <fen> well, ok not *is* but at least, is "one realisation of", and that allows the fusion rule to be written
10:39:45 <fen> basically, not understanding how to write this "extra foldable" typeclass, this encoding seems to be the closest to express what is meant
10:41:04 <lunabo> fen: what do you mean by extra foldable? Couldn't you simply choose the type b to be (y, b') in the ordinary Foldable class?
10:41:40 <fen> no thats the point, its supposed to be forcing some extra information, to make it not just foldable
10:43:05 <fen> eg, it could be a state encoding (s,s -> Maybe (a,s)), which includes both an encoding of a redundant intermidiate foldable container of `a' and some "extra information" in the form of some values of type `s' which can be used to construct this additional returned value thats not just the folded up `a's into `b'.
10:46:11 <fen> maybe its just class ExtraFoldable f x y where extraFoldr :: f x y -> x -> (a -> b ->  b) -> b -> (y,b)..... hmm that might not be good, not sure about the first input
10:46:32 <fen> f x y a perhaps, but not sure what that is supposed to represent
10:46:53 <fen> maybe its not a good idea to have it as a typeclass, its very confusing anyway
10:47:59 <lunabo> fen: do you have a concrete example of where this class would be useful? It's not entirely clear to me what the x and y are supposed to represent
10:48:42 <fen> (d,s) -> Maybe (a,Maybe (d,s))
10:50:11 <fen> this can take a "new direction" d to stop it returning Nothing... that would be x. the `y' would be the "penultimate" s, just before it returned Nothing. when it returns (a,Nothing) that is the complete recursion
10:52:21 <fen> so basically we have one initial s, which could be a eg a random number generator, which fails when it returns a number below some bound, and it returns a random number `a' and can be given a new seed value `d' to restart it when it jams
10:53:55 <lunabo> fen: that makes some sense
10:54:05 <lunabo> so then the outer Maybe is for when the RNG "fails"
10:54:15 <lunabo> But what is the inner Maybe for?
10:54:50 <fen> yeah, and maybe its somehow storing a counter within the RNG so that after its produced a certain number of values it returns (a,Nothing)
10:55:02 <fen> the RNG `s' ...
10:55:18 <lunabo> And this seems more like unfolding because you are producing a sequence from a value instead of reducing a sequence to a value
10:56:07 <dexterfoo> what happened to the brittany web service? it says: "backend: unavailable"
10:56:10 <fen> well its just a state encoding of a foldable container of `a', as opposed to the church encoding, which is obtained by applying the function fold
10:58:37 <fen> hmm, maybe it is a forall on the x and y... they are arguments to the container?
10:58:47 <fen> class ExtraFoldable f where extraFoldr :: f x y -> x -> (a -> b ->  b) -> b -> (y,b); 
10:58:53 <fen> class ExtraFoldable f where extraFoldr :: f x y a -> x -> (a -> b ->  b) -> b -> (y,b); 
10:59:01 <fen> instance ExtraFoldable (\d s a -> (d,s) -> Maybe (a,Maybe (d,s))) where ... 
11:01:24 <fen> lunabo: ok its not exactly supposed to be an unfolding specifically, its just thats an example of an instance, as by unfolding the values strait into the folding function (a -> b -> b) then there is at least some other value to return as y, namely the state
11:01:42 <fen> basically there is this example, and a desire to represent the general abstration 
11:02:36 <fen> the example is just supposed to illustrait the concept of "something that can be folded which has extra information which can be returned, and may take some additional information aswell" 
11:03:43 <fen> so the *example* is an unfolding, the RNG produces values, but basically what we have is something like a foldable instance for it. 
11:04:07 <fen> and there may be other things that can be instances which might not be unfoldings.
11:04:43 <lunabo> fen: do you have an example where you would use extraFoldr, but ordinary foldr would not work? If I understand correctly, you can have additional information in the input by letting the accumulator function refer to things in the surrounding scope, without explicitly passing them to the accumulator
11:04:50 <fen> the point is that when we partially apply this folding function to the state encoding of the example, we get something like a church encoding, where the original way the values were produced is hidden
11:06:57 <fen> lunabo: this example of a "state taking directions" with the 2 maybes for if the directions are exhausted, or if the state is exhausted, has 2 loops over it, for each direction supplied it can be looped until in halts, and given a supply of directions this can be repeatedly done until the `s' is exhausted
11:07:33 <fen> extraFoldr is the function applied to return a state to be unfolded as the second of these
11:10:47 <fen> well, ok sorry the types dont quite work because it keeps expecting new directions... its more like a state that is "zipped" with a state returning directions...
11:13:39 <lunabo> lunabo: but is there some concrete function on a concrete data structure that you are trying to write a type class for or are you just looking at the types? Because in your examples you refer to state and directions, but it is not clear what this would ultimately end up being
11:14:29 <lunabo> fen: I mean if you would like to abstract something into a type class it's nice to have at least two entirely concrete instances first
11:15:46 <fen> lunabo: here is the way those 2 nested loops work for this example; https://pastebin.com/raw/A6RuU2Qd
11:17:36 <fen> lunabo: well, here its just trying to have something that can be "fusioned over", see the comment in the paste, normally we would use "build" to access the fusion, but because this nesting of state loops means the inner unfolding has to return the penultimate state as well, means it is definatly not foldable and cant use build fold fusion
11:18:03 <fen> so its something like build, over something like foldable... 
11:19:54 <lunabo> fen: ha, think that might be a bit too much bananas and barbed wire for me ;)
11:21:36 <fen>  its not any of those recursion schemes... maybe it captures a few of them, seems to be much more abstract
11:22:38 <fen> eg it seems to cover foldable with x = y = ()
11:22:50 <fen> up to isomporphism 
11:24:57 <fen> ok so in the paste, superLoop is like extraFoldr crossed with build, ie it does not take (a -> b -> b) and `b' but instead uses (:) []
11:25:55 <fen> so hyloList of superLoop must be extraFold, and then we should have extraFold / superLoop fusion
11:26:04 <fen> !!!
11:26:21 <fen> implementation of*
11:28:20 <rotaerk> superLoop? is that better or worse than the hyperloop
11:29:19 <fen> rotaerk: check the paste: https://pastebin.com/raw/A6RuU2Qd
11:30:48 <fen> its just supposed to be a way of making a "state of states" where each state requires the previous state to be unfolded to get the input required to produce the next inner state via the outer state...
11:31:38 <fen> such as providing a new seed to a RNG that has an internal counter 
11:33:02 <fen> the question is as to the validity of the ExtraFoldable class
11:33:20 <fen> [18:58] <fen> class ExtraFoldable f where extraFoldr :: f x y a -> x -> (a -> b ->  b) -> b -> (y,b)
11:34:19 <fen> and the associated fusion rule
11:42:15 <dmwit> Awwwww. STM's fail isn't const retry.
11:42:30 <dmwit> That's a shame, because it means I can't write e.g. `Nothing <- readTVar x` to block until `x` is Nothing.
11:42:47 <dmwit> That syntax would just feel so right and natural, and the alternative is so awful.
11:43:48 <Ariakenom> dmwit: really? waht is it?
11:44:23 <cocreature> is it even MonadFail?
11:45:51 <slack1256> dmwit: `readTVar x` didn't fail, it was the binding that did :-)
11:46:39 <Ariakenom> is there any way to get "fail" to be Alternative's "empty"?
11:46:46 <dmwit> slack1256: I'm aware of that, and it doesn't seem to contradict anything I said.
11:46:49 <EvanR> Nothing <- readTVar x, code only a haskeller could love :)
11:46:50 <dmwit> Ariakenom: It's throwSTM.
11:47:25 <EvanR> the equivalent in C would be 5 = 2 + 2;
11:47:30 <dmwit> cocreature: I don't know that my GHC is new enough to be able to answer that, to be honest. Anyway `Just x <- readTVar y` is accepted by GHC here.
11:47:33 <EvanR> which would cause it to block
11:47:43 <dmwit> > let 2 + 2 = 5 in 2 + 2
11:47:45 <lambdabot>  5
11:48:22 <EvanR> it should be 10, you assigned 5 to the value of 2, then did basically 5 + 5
11:48:25 <cocreature> dmwit: fails on my GHC (8.6) which uses the new MonadFail desugaring by default
11:48:29 <EvanR> depending on sequencing
11:48:40 <cocreature> so in that case you could add your own instance that does what you want
11:48:56 <Solonarv> dmwit: MonadFailDesugaring exists as an opt-in for earlier ghc 8.x
11:49:00 * dmwit is currenttly in the process of making a newtype that fixes this issue and gives atomically a MonadIO-y type
11:49:38 <Solonarv> EvanR: that doesn't assign anyything to '2' or '5'; instead it defines a function named '(+)' which returns 5 when passed the arguments 2 and 2
11:50:36 <EvanR> thanks for establishing that for posterity
11:51:49 <EvanR> man, implicit STM everything in C would be interesting
11:52:07 * hackage dynamic 0.0.2 - A dynamic type for Haskell  https://hackage.haskell.org/package/dynamic-0.0.2 (ChrisDone)
11:52:51 <Ariakenom> this transaction touches 5000 variables, so it may complete as long as nothing else happens :p
11:54:22 <EvanR> good way to explain the weakness of STM
11:55:13 <delYsid> I communicate with an external process via a stdin/out Handle pair.  Reading from stdout is done via a background thread which parses output and feeds parsed data to a TChan.  So far, so good.  The protocol has a way for checking that the process is ready to take more commands.  I send a "isready" command, and wait for a "readyok" response.  I currently handle this via an MVar, which worsk fine.  However, I am wondering how to handle
11:55:13 <delYsid> exceptions, like, if the process died unexpected.  As I understand it, just doing takeMVar will hang if the MVar is never written to because the process died.  How do I handle this?  Are there other primitives to use, or what would I need to do to get the exception from the background thread to the thread that waits on takeMVar?
11:56:20 <fen> is that blocking com like yield and await of machines?
11:56:41 <cocreature> delYsid: you probably want to look at the async package for that
11:57:36 <cocreature> it has variuos ways of making sure that exceptions propagate to the parent thread, e.g., withAsync
11:58:00 <fen> we have zip fusion for states and if this extraFold / state await zip fusion thing works that should give arbitrarily composable pipes strait from fold/unfold/zip/halt fusion...  
11:58:05 <cocreature> eh that’s the wrong one, "wait" will rethrow
11:59:07 * hackage yesod-csp 0.2.5.0 - Add CSP headers to Yesod apps  https://hackage.haskell.org/package/yesod-csp-0.2.5.0 (boblong)
11:59:29 <fen> and something to do with traversable composition fusion where the applicative used can capture arbitrary recursion schemes and anything you might like conduit to do...
11:59:45 <dminuoso> delYsid: Im curious, what IRC client do you use?
12:00:13 <fen> wouldnt this be more in the haskell idiom via its use of fold / traverse as the fundamental higher order abstractions?
12:01:27 <MarcelineVQ> dminuoso: wondering what client actually managed to figure out how to break lines sanely despite clients having decades to get it right and most still not?
12:03:42 <delYsid> dminuoso: ERC from Emacs.  I wrote most of it myself back in 2003 or so, these days it is part of GNU Emacs.
12:05:01 <Ariakenom> Nice invariant: Threads form a tree, where exceptions bubble up. A parent does not die before it has killed its children.
12:05:45 <delYsid> cocreature: Interesting.  However, I am struggling to see how I would use this with my existing setup.  I already have a background thread that is responsible for reading all incoming data via hGetLine.  So my current isready function just sends a string to the stdin Handle, and does a takeMVar to wait for the background thread having seen the reply...
12:06:58 <delYsid> dminuoso: In fact, ERC is likely the biggest contribution to Free Software I ever did.
12:08:34 <dminuoso> delYsid: I see. Is text-to-speech the main technique for you, or do you have some type of braille keyboard you can use to read IRC or from Emacs in general?
12:08:53 <dminuoso> delYsid: (By text-to-speech I not only refer to ERC-Speak but Emacs in general)
12:09:15 <cocreature> delYsid: you could go for 3 threads: 1 parent thread that monitors both child threads, i.e., the background thread and the thread that calls takeMVar using waitAnyCancel
12:09:23 <delYsid> dminuoso: I very rarely use TTS.  I am a braille person.  And btw, its called Braille display, not Braille keyboard :-)
12:09:31 <delYsid> I wonder why almost everyone gets this wrong.
12:10:39 <dminuoso> delYsid: Honestly, I actually googled about it for a while, didn't find the actual name but figured you'd know what I was referring to. :)
12:10:58 <delYsid> cocreature: Hmm, I'll have to think about that.  I dont really have control over the thread that is doing takeMVar, since its part of my API.
12:11:46 <delYsid> dminuoso: I am just wondering why everyone not into assistive technologies insists on calling an output device a keyboard :-)
12:12:09 <delYsid> Its not just you, its everyone who asks me such things.  Just wondering where the thinko comes from.
12:12:38 <cocreature> delYsid: maybe replace the takeMVar by a "race (takeMVar …) (wait …)"?
12:13:17 <dminuoso> delYsid: In my mind Im thinking of a combination of a braille line and a keyboard, so the amalgation gives me "braille keyboard". A bit naive, I admit.
12:14:01 <delYsid> dminuoso: Yeah, I get that.  However, I type on a normal keyboard...  Braille keyboards are notoriously slow to use.
12:15:04 <delYsid> IOW, there are input devices that make use of braille.  They typically have 8 keys and a spacebar, and you enter characters by pressing the various keys simulatenously.  But thats a drag.
12:16:05 <delYsid> cocreature: Oh, I could of course use timeout, thats a good hint.
12:16:28 <delYsid> and in the Nothing case check the ProcessHandle if its still alive.
12:17:06 <delYsid> I guess that could work.  I still loose the exception, but thats not really important I guess.
12:18:52 <delYsid> cocreature: Thanks, that was a helpful exchange.
12:19:38 <delYsid> I keep learning very interesting things.  Today was the first time I made use of an MVar, and it worked immediately.
12:23:23 <dminuoso> It wouldn't be much of a feature if MVars dont work immediately. :-P
12:33:19 <__monty__> delYsid: That sounds a bit like the chorded input device in the mother of all demos, looked like piano keys. Are there Moon displays?
12:35:53 <dminuoso> delYsid: How many rows/columns do you personally have on your display?
12:42:26 <heebo> Day constructor for Haskell?
12:44:18 <dminuoso> % data Day f g a = forall b c. Day (f b) (g c) (b -> c -> a)
12:44:18 <yahb> dminuoso: 
12:44:21 <dminuoso> heebo: ^-
12:45:32 * dminuoso mumbles about Applicative being simply a Monoid in the monoidal category of endofunctors equipped with the Day convolution as its tensor...
12:46:02 <Solonarv> Applicative is a lot of things!
12:46:21 <heebo> thanks?
12:46:47 <heebo> ah I see , it works cheers
12:48:37 * hackage hledger-makeitso 0.9.0.1 - An hledger workflow focusing on automated statement import and classification.  https://hackage.haskell.org/package/hledger-makeitso-0.9.0.1 (apauley)
12:53:16 <dminuoso> % undefined :: Int `Either` Float
12:53:16 <yahb> dminuoso: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:365:1 in interactive:Ghci158
12:53:45 <dminuoso> akr: ^- look!
12:54:06 <dminuoso> Why did I never think of using `` on type constructors before
12:55:35 <dminuoso> (It requires TypeOperators though, but why wouldn't you have this flipped on)
13:15:08 <talqu_> https://pastebin.com/qxyV7g6v inside a do syntax is there a shorter better way to get values from Either type and bind it in let expression as in my example?
13:15:26 <dminuoso> % :t either
13:15:26 <yahb> dminuoso: (a -> c) -> (b -> c) -> Either a b -> c
13:15:57 <dminuoso> talqu_: Also depending on your needs, ExceptT can be useful too.
13:16:00 <gentauro> dminuoso: I sometimes miss the ``Long type description`` from F#
13:16:00 <talqu_> :) thanks
13:16:09 <Ariakenom> Finally, dynamically typed programming in Haskell made easy! https://github.com/chrisdone/dynamic
13:16:13 <dminuoso> talqu_: And then there's also a style involving `note`
13:17:12 <dminuoso> Where `noteE` would lift the Left case into an exception of some kind (perhaps an IO exception, or perhaps just using MonadThrow) and yield the right case back.
13:19:54 <dminuoso> % note :: MonadError e => a -> Maybe a -> m e; note = flip maybe pure . throwError
13:19:54 <yahb> dminuoso: ; <interactive>:367:9: error:; * Expecting one more argument to `MonadError e'; Expected a constraint, but `MonadError e' has kind `(* -> *) -> Constraint'; * In the type signature: note :: MonadError e => a -> Maybe a -> m e
13:20:05 <dminuoso> % note :: MonadError m e => a -> Maybe a -> m e; note = flip maybe pure . throwError
13:20:05 <yahb> dminuoso: ; <interactive>:368:43: error:; * Expected kind `(* -> *) -> *', but `m' has kind `*'; * In the type signature: note :: MonadError m e => a -> Maybe a -> m e
13:20:28 <dminuoso> % note :: MonadError e m => a -> Maybe a -> m e; note = flip maybe pure . throwError
13:20:28 <yahb> dminuoso: ; <interactive>:369:55: error:; * Couldn't match type `a' with `e'; `a' is a rigid type variable bound by; the type signature for:; note :: forall e (m :: * -> *) a. MonadError e m => a -> Maybe a -> m e; at <interactive>:369:1-45; `e' is a rigid type variable bound by; the type signature for:; note :: forall e (m :: * -> *) a. MonadError e m => a
13:21:16 <dminuoso> % note :: MonadError e m => e -> Maybe a -> m a; note = flip maybe pure . throwError
13:21:16 <yahb> dminuoso: 
13:21:29 <dminuoso> Well. That. :)
13:31:31 <mk_> HELP
13:34:07 * hackage z3 408.0 - Bindings for the Z3 Theorem Prover  https://hackage.haskell.org/package/z3-408.0 (IagoAbal)
13:35:37 * hackage key 0.1.0.0 - Type-safe unconstrained dynamic typing  https://hackage.haskell.org/package/key-0.1.0.0 (MatthewFarkasDyck)
13:36:35 <kadoban> Today is like dynamic typing day on hackage
13:43:06 <Uniaika> yeah, I've read the Dynamic! blog post
13:43:49 <akr> dminuoso: don't go overboard with it :) I prefer prefix Either to be honest
13:45:29 <dmj`> yo what https://stackoverflow.com/questions/1885630/whats-the-difference-between-varchar-and-char/15553059, is it really april 1st already
13:46:45 <akr> maybe a off-by-one error is part of the joke, idk
13:47:23 <delYsid> dminuoso: 1 row, 80 columns.
13:47:54 <delYsid> At least on the desktop.
13:48:09 <delYsid> 40 columns when mobile. see https://blind.guru/brlpi.html
13:55:37 * hackage key 0.1.1.0 - Type-safe unconstrained dynamic typing  https://hackage.haskell.org/package/key-0.1.1.0 (MatthewFarkasDyck)
14:20:17 <delYsid> Does haskell have a way to explicitly silence a particular shadowing warning?
14:20:43 <Solonarv> not as far as I know
14:25:41 <geekosaur> not yet. fine-tuned warnings is a work in progress
14:49:46 <delYsid> Hmm, chessIO finally starts to be useful.  I just played a game against stockfish with my own haskell based text-mode chess frontend.  Woohoo!
14:50:13 <Solonarv> nice!
14:52:30 <delYsid> The haskeline getExternalPrint feature really made me going.  I always wanted something like that.  printing to the console without disturbing the prompt is really useful.
14:53:44 <delYsid> I wish GHCi had a way to use it in IO actions.
14:54:14 <delYsid> I should probably submit a feature request one day.
14:54:53 <delYsid> I basically wrote my own uGHCi to make this feature available, but I'd rather not reinvent the wheel and just use GHCi.
14:56:11 <merijn> delYsid: Why not implement it in ghci yourself? :)
14:57:02 <delYsid> merijn: I am just too dumb to do that.
14:57:29 <merijn> delYsid: What makes you say that? Hell, ghci already uses haskeline, afaik
14:57:30 <delYsid> I use a pretty strange hack to make it work, which is surely not portable or anything.
14:58:20 <delYsid> I use a pipe to send the string from within the interpreter to the outside haskell, hell, I dont even know the correct terminology.
14:59:06 <delYsid> Problem is, you can't have a function that is defined by the outside haskell in the interpreter directly.
14:59:11 <merijn> delYsid: Can't hurt to try, ghci can always use more love, I think :p
14:59:23 <merijn> What is "the outside haskell"?\
14:59:41 <delYsid> I'd really love to have it, it opens the door for really cool background thread things that report ot the console.
15:00:06 <delYsid> merijn: Good question.  You know, there is a separation between the code that runs the interpreter, and the interpreter itself.
15:00:40 <delYsid> You cant just pass a function that is already defined to the interpreter.
15:01:34 <delYsid> Haskeline is not run in the interpreter, so getExternalPrint is just not available inside.
15:02:23 <merijn> Bed time
15:02:34 <delYsid> I basically setup a thread that reads from a pipe, calling externalPrint whenever it receives text.  And in the interpreter, I define a fake externalPrint that just writes to the pipe.  Luckily, a FD is simple to serialize.
15:02:46 <delYsid> right, same here, actually.
15:34:07 * hackage language-ats 1.7.1.0 - Parser and pretty-printer for ATS.  https://hackage.haskell.org/package/language-ats-1.7.1.0 (vmchale)
15:42:37 * hackage language-ats 1.7.1.1 - Parser and pretty-printer for ATS.  https://hackage.haskell.org/package/language-ats-1.7.1.1 (vmchale)
16:25:58 <Nevoic> Hey, does anyone know of a concurrent alternative to `sequence`?
16:26:43 <Axman6> check the async package
16:26:44 <Nevoic> I currently have:
16:26:44 <Nevoic> _ <- sequence x
16:26:44 <Nevoic> where
16:26:44 <Nevoic> x :: [IO]
16:26:59 <Solonarv> there are a few variants of that in async, yes
16:27:01 <Nevoic> I took a look, I found mapconcurrently, but couldn't figure out how to use it.
16:27:21 <Axman6> mapConcurrently id x
16:27:49 <Axman6> since you already have IO b, the function you need to provide is just something of type IO b -> IO b
16:27:59 <Nevoic> Ah, clever. map it to itself concurrently. Is there a less hacky way to do it? lol
16:28:08 <Solonarv> this isn't hacky at all, so no :P
16:28:47 <hpc> try (mapConcurrenty id)
16:28:51 <hpc> @src sequence
16:28:51 <lambdabot> sequence []     = return []
16:28:51 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
16:28:51 <lambdabot> --OR
16:28:51 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
16:29:05 <hpc> blah
16:29:08 <hpc> :t mapM id
16:29:09 <lambdabot> (Monad m, Traversable t) => t (m b) -> m (t b)
16:29:32 <hpc> mapConcurrently looks like mapM, i think it should work
16:29:40 <Solonarv> yup
16:29:57 <hpc> oh, i was too slow
16:32:31 <mr971[m]> `async` package is cool, an usage example: `runConcurrently $ (,,,) <$> Concurrently fooIO <*> Concurrently barIO <*> Concurrently bazIO`
17:00:57 <dmwit> Oh, neat, TArray exists now!
17:01:06 <dmwit> I was wishing for that a few months ago.
17:02:08 <ph88> hey guys, i'm trying to build my project and stack is stuck at   Progress 6/8: Cabal-2.4.1.0   for the last 15 minutes or so .. i don't remember it taking this long.
17:02:22 <ph88> maybe i should abort the build and try again with some verbose/debug flags ?
17:02:36 <ph88> lol just as i say that it's done -____-
17:02:44 <ph88> on linux it's faster  :P
17:05:13 <Nevoic> Probably another dumb question, but does anyone know how to sort of "flatten" an `[IO]` into a single IO via `>>`?
17:05:52 <Solonarv> that's exactly what sequence_ does
17:06:39 <Solonarv> (well, actually it's a bit more general)
17:06:43 <Solonarv> :t sequence_
17:06:45 <lambdabot> (Monad m, Foldable t) => t (m a) -> m ()
17:06:48 <Nevoic> Ah okay, thanks!
17:18:16 <ph88> what's the right way to see if there is whitespace in a string ?
17:18:58 <Clint> depends how you define whitespace
17:19:15 <Solonarv> and depends on what kind of string you have (is it a String, or a Text)?
17:20:35 <Solonarv> for a String:
17:20:36 <Solonarv> > any Data.Char.isSpace "123 hello"
17:20:37 <lambdabot>  True
17:21:05 <ph88> that will do :)
17:21:17 <Cenion[m]> Is there any web framework in production except yesod?
17:21:41 <Solonarv> for a Text, it's the same; just use Data.Text.any instead of Prelude.any
17:21:43 <jackdk> depends on what you're trying to do with your web service. I've used servant for a few projects
17:26:01 <Cenion[m]> jackdk: some website with postgresql and HTML page.
17:34:47 <ph88> i'm in a do block and i have a   let myList = []  after creating this list how can i check if a parameter of type Maybe String  is  Just and then append this item to the list ?
17:40:19 <ph88> ah i have an idea
17:48:07 * hackage elocrypt 2.0.1 - Generate easy-to-remember, hard-to-guess passwords  https://hackage.haskell.org/package/elocrypt-2.0.1 (sgillespie)
17:55:20 <hpc> haha, the description on this package is great
18:01:54 <dmwit> Feature request: an interface where I say how much entropy I want the password to have, rather than how long the password is.
18:04:28 <dmwit> Ah, I see the site describing the tool this descends from acknowledges this issue pretty explicitly (...but apparently without offering my requested feature anyway).
19:58:07 * hackage hs-profunctors 0.1.0.0 - Profunctors from Haskell to Haskell  https://hackage.haskell.org/package/hs-profunctors-0.1.0.0 (MatthewFarkasDyck)
20:05:35 <MarcelineVQ> hs-profunctors?
20:06:57 <MarcelineVQ> seems like an oddly redundant thing, and that mattew guy wouldn't be unaware of the profunctors package
20:08:00 <slack1256> maybe is Haskell98 compilant?
20:08:19 <slack1256> or has very little dependencies
20:08:29 <slack1256> mmm it depends on hs-functors...
20:10:11 <MarcelineVQ> There's an additional Related and Corelated class as the difference, not sure if there's a similar in profunctors so that could be all the difference needed.
20:11:03 <glguy> MarcelineVQ: See http://hackage.haskell.org/user/MatthewFarkasDyck
20:11:04 <slack1256> It just needs a good README explaining the motivation
20:11:28 <slack1256> holy sh**
20:11:41 <MarcelineVQ> glguy: ehe I did see that, that's how I knew he wouldn't be unaware of profunctors :>
20:12:38 <glguy> He likes to make lots of partial-functionality clones of things without comments and explanation
20:13:07 <MarcelineVQ> slack1256: good readme's are awesome, I'm of the radical an completely unachievable opinion that after reading your libraries documentation I should be able to both implement it myself and use it in a real world problem.
20:13:50 <MarcelineVQ> This is in line with my forlorne hope that someday people will realize that comment text always should be more visible than code text, not less
20:14:02 <slack1256> That isn't radical in my view
20:14:19 <slack1256> although I would add that those two objective should be in different documents
20:17:25 <dmwit> This fellow's packages feel like learning how a thing works by doing an exploratory, proof-of-concept reimplementation yourself. But then uploading it to Hackage.
20:17:59 <slack1256> he must be a mathematician, lol
20:18:44 <MarcelineVQ> different documents? oh eh I don't mean having a tutorial, though I also think tutorial modules are totally wizard, rather the documentation should make it so clear what is happening that the understanding of implementation or use just follows
20:19:36 <MarcelineVQ> On the tut subject though the streamly tutorial is really quite good in terms of taking you through things https://hackage.haskell.org/package/streamly-0.6.1/docs/Streamly-Tutorial.html
20:40:48 <slack1256> I don't see how would that work except for certain cases
20:41:07 <slack1256> I think it is better to establish a conceptual model with the user
21:40:20 <electricityZZZZ> so i am trying to understand the wisdom of haskell's nonstrict-by-default approach,... which i guess simon peyton jones now thinks is a bad idea? i am getting confused about, in a variety of practical situations, whether i would want my code to default to a more strict behavior or lazy...
21:42:17 <electricityZZZZ> i understand the basic idea that lazy can eliminate some unnecessary computation with the downside of more unpredictable resource usage,
21:42:32 <c_wraith> I think it's the right default
21:42:48 <c_wraith> I also think it's not that hard to deal with in practice.
21:42:55 <dibblego> when you concede to not being liberated from von Neumann e.g. length returns Int not [()]
21:43:26 <c_wraith> like, I see complaints that resource usage is unpredictable.
21:43:31 <c_wraith> But that's not my experience.
21:43:44 <dibblego> neither
21:43:47 <c_wraith> My experience is that if you write each part correctly, their composition will be correct.
21:43:50 <electricityZZZZ> but i want to understand better whether that elimination of needless computation is a "parlor trick" or whether there are "very common, ubiquitous, and real situations" where i benefit
21:43:52 <dibblego> same
21:44:10 <dibblego> the elimination of computation is a consequence; the goal is better program composition
21:44:27 <electricityZZZZ> yeah i've heard the composition benefit but i dont think i understand it
21:44:40 <dibblego> map f = foldr ((:) . f) [] -- this does not work if the argument to foldr is strict in its arguments
21:45:00 <dibblego> you have to write map out again by hand, repeating the source code foldr
21:46:38 <c_wraith> all f = and . map f
21:47:36 <c_wraith> the pieces are tiny and just work together
21:47:51 <electricityZZZZ> that line says that i am making a list where the elements are iteratively f, then f applied twice, then thrice, and so on?
21:48:55 <c_wraith> > all (> 3) [1, 4, 5]
21:48:57 <lambdabot>  False
21:49:00 <c_wraith> > all (> 3) [4, 5]
21:49:05 <lambdabot>  True
21:49:34 <c_wraith> > all (> 3) [1..]
21:49:35 <lambdabot>  False
21:49:50 <c_wraith> Short-cutting for free, thanks to laziness!
21:50:18 <c_wraith> you didn't need to rewrite a single fused computation for and and map
21:50:25 <c_wraith> just composing them does the job.
21:50:40 <electricityZZZZ> so i am referring to the most recent things you've done as "parlor tricks"
21:50:58 <c_wraith> but they're not.
21:51:12 <c_wraith> They're *code reuse*
21:51:39 <electricityZZZZ> i didnt understand the foldr line, was i correct about it iteratively applying f in a list?
21:51:48 <c_wraith> no, it's just the definition of map
21:51:57 <electricityZZZZ> ah ok
21:53:12 <slack1256> Another one that is subtler for laziness: make functions writing seem more definitional than computational
21:53:21 <electricityZZZZ> ok?
21:53:29 <slack1256> you define all the variables (via let) for your problem, and them combine them
21:54:06 <slack1256> on a strict lang you would have to decide in which order define your variables (intermediary steps) and then combine
21:54:45 <c_wraith> heck, you can even define values that aren't defined on every input.  as long as you don't use them when they're not defined, that's acceptable.
21:55:30 <c_wraith> (though it can be an invitation to bugs in later refactoring)
21:55:46 <electricityZZZZ> right this is related to the issue of exceptions and when they manifest
21:55:47 <slack1256> Exactly, I like to de-structure `Maybe`-s as where clauses `where Just val = expr`. I just don't use until I check that will be a valid branch
22:00:01 <electricityZZZZ> i had a great experience writing some elm, so i got started with haskell... ran into quite a bit of trouble so i moved to rust, shipped some rust code into production, and now i am trying to take another look at haskell
22:00:02 <slack1256> The thing I want to say is: laziness means that the evaluation order only depends on the data dependency between the expressions, while on a strict lang apart from that you also have the order imposed by the syntax (line by line) or some extra rule specified. If your goal is to do a pure functional programming language, with lot of equations and definitions, do you really want have that extra order?
22:00:37 <electricityZZZZ> something rust does pretty well (though not totally so) is that it is fairly opinionated and clear on best practices, with haskell i have a hard time understanding what that is
22:01:51 <Welkin> "best practices" are for lazy people who can't be bothered to think for themselves
22:01:57 <electricityZZZZ> slack1256: this is a good point,... i guess at some point it comes down to questions of scheduling...?
22:02:16 <Welkin> it's a way to disclaim responsibility when something goes wrong, even if it is your fault
22:02:21 <electricityZZZZ> like in some situations it makes sense to wait as long as possible in wall-clock time to begin computing sometihng
22:02:40 <electricityZZZZ> whereas in others it is best to get them out of the way right away
22:02:59 <electricityZZZZ> and then in others maybe somewhere inbetween,... it's like there is some kind of variable backpressure parameter
22:03:48 <slack1256> so far I've been talking on how evalution for expression can be done only taking the data dependencies between them as the guide
22:04:05 <slack1256> What actually happens is what the RTS determines it's best
22:04:09 <Welkin> laziness is not something you should be concerned with
22:04:12 <Welkin> I don't see what the issue is
22:04:17 <Welkin> just write your program
22:04:33 <electricityZZZZ> welkin: haha well there's that attitude too, which is fine
22:04:37 <Welkin> the only advice is, use foldl' instead of foldl
22:05:05 <electricityZZZZ> right,... except there seem to be a bunch of gotchas like that in haskell,... string types,...
22:05:12 <dibblego> (in some cases)
22:05:12 <Welkin> there are no gotchas
22:05:14 <slack1256> another trick haskell uses: what if we piggy back on the data dependency between the expressions to guide when we do (sometimes simulated) effects?
22:05:28 <Welkin> String is [Char], which is not really a "string"
22:05:31 <Welkin> you use Text
22:05:36 <Welkin> or ByteString (for binaries)
22:05:40 <slack1256> then you enter the M-*gasp* M-monad!
22:06:10 <zabaniya> just using foldl' won't help in every case, so understanding of laziness is still important
22:06:34 <electricityZZZZ> i found a practical construction of the monad concept which i might have gotten me over the hump,...
22:06:41 <Welkin> 99.99% you don't need to know about how the laziness works
22:07:02 <electricityZZZZ> heh interesting point i suppose
22:07:16 <Welkin> electricityZZZZ: a monad is an interface that includes a mapping functions and a function to put something into a context/container
22:07:31 <glguy> Anyone know about bidi unicode markers? I'm trying to figure out how to cope with right-to-left text messing up my VTY user interface
22:07:32 <Welkin> it's really just messing around with the types
22:07:43 <Welkin> nothing special
22:07:52 <slack1256> glguy: glirc2 related? :-)
22:08:12 <glguy> I tried adding \x200e at boundaries between elements, and that works in a lot of cases but not all and I don't quite understand
22:08:15 <glguy> slack1256: Yeah
22:08:38 <slack1256> let me guess, it's related to the borders when `split`ing vertically?
22:08:52 <glguy> The two-column view, yeah
22:08:53 <slack1256> I don't know anything about bidi unicode markers though...
22:09:12 <slack1256> I was trying to figure out what was happening too, heh
22:09:16 <glguy> Hewbrew text can "reach out" and grab the numbers from the time-stamps
22:09:25 <slack1256> yes
22:10:11 <electricityZZZZ> glyguy: wat
22:10:15 <slack1256> also when the motd of a channel has long urls can do that too, but that is another problem
22:10:24 <electricityZZZZ> unicode is terrifying
22:10:49 <glguy> > text "\1513\1500\1493\1501 \1506\1493\1500\1501. 42"
22:10:50 <lambdabot>  שלום עולם. 42
22:10:54 <glguy> > text "\1513\1500\1493\1501 \1506\1493\1500\1501. \x200e42"
22:10:56 <lambdabot>  <hint>:1:57: error:
22:10:56 <lambdabot>      numeric escape sequence out of range at character '2'
22:11:00 <glguy> > text "\1513\1500\1493\1501 \1506\1493\1500\1501. \x200e\&42"
22:11:02 <lambdabot>  שלום עולם. ‎42
22:11:24 <glguy> depending on how much bidi support your client or terminal has, one of those will have the 42 on the left of the text and one on the right
22:13:02 <slack1256> at least on uxterm that works as intended, what are you using urvxt?
22:13:19 <glguy> Intended means how I described?
22:13:27 <Welkin> you mean indented
22:13:34 <Welkin> or indentured?
22:14:09 <glguy> macOS's Terminal.app behaves as I described. It's aware of the bi-directional text stuff
22:14:11 <slack1256> as you described glguy
22:14:39 * slack1256 native tongue showed
22:14:46 <Welkin> iterm2 should work right?
22:15:28 <glguy> iTerm2 doesn't work as described
22:15:52 <glguy> at least at the default settings it ignores the fact that hebrew is right-to-left
22:16:40 <glguy> even worse it renders the 0-width \x200e has 1-width
22:16:47 <glguy> so if I use it in my layouts it will break on iTerm2
22:16:47 <Welkin> check gnome terminal
22:16:50 <Welkin> and otherl inux ones
22:16:55 <Axman6> for me, both those have 42 on the left (using glirc)
22:17:04 <Axman6> in Terminal.app
22:17:09 <glguy> Axman6: That's odd...
22:17:14 <slack1256> I will nix-shell a gnome terminal to see
22:17:21 <glguy> macOS 10.14.4?
22:18:02 <Welkin> I imagine iterm2 has support for this, since it seems like a basic feature, especially since it has so much extra crap added to it
22:18:31 <Axman6> 10.14.3
22:18:39 <glguy> https://imgur.com/a/UIQwuuQ
22:19:04 <glguy> for whatever reason I truncated the first input where I didn't have \x200e in there
22:19:05 <Welkin> iterm version?
22:19:22 <glguy> 3.2.8
22:19:30 <Axman6> I might be looking at the wrong lines
22:20:13 <Cenion[m]> hey
22:20:51 <Axman6> https://imgur.com/a/E3Ara3A
22:21:16 <glguy> Axman6: Weird... that's Terminal.app?
22:21:20 <Welkin> https://gitlab.com/gnachman/iterm2/issues/1611
22:21:20 <glguy> or iTerm
22:21:30 <Axman6> Terminal.app
22:21:33 <Welkin> iterm has an open issue regarding full bidirectional support
22:22:08 <glguy> Welkin: https://gitlab.com/gnachman/iterm2/issues/1611#note_1163480 I agree with this!
22:23:34 <Welkin> I never use trl languages in my terminal, so I've never encountered any issues
22:23:39 <Welkin> rtl*
22:23:52 <glguy> I only use them when someone sends such a message to IRC chat
22:24:15 <Welkin> hebrew, arabic, farsi, maybe a few other languages
22:25:18 <slack1256> Ok, now I am on gnome-terminal (although I tmux attached to the same session)
22:26:39 <Cenion[m]> how can Haskell easy to deploy on server like golang?
22:28:00 <slack1256> Cenion[m]: you can static link haskell libraries easily (that is the default). But the C-side library usually must be dynamic linked as glibc usually won't work statically unless you change to musl
22:28:41 <slack1256> Go cheats by not using the libc, as a tradeoff the ioctl their way to interfaces on linux and do they on syscall stuff
22:29:04 <dmwit> glguy: I used to know a bit about bidi stuff, though it's fuzzier now than it used to be for sure. What's confusing you?
22:29:20 <slack1256> you have great alternative though, I love nixpkgs as a universal way to pack a program and deploy them declaratively
22:29:47 <glguy> dmwit: My question is: How to I make terminal apps that don't disolve when rtl text is side-by-side with non-rtl text
22:29:53 <slack1256> https://imgur.com/a/B1DHOIh bidi stuff on gnome-terminal
22:30:06 <dmwit> Oh, terminals lol.
22:30:11 <dmwit> They're all broken.
22:30:29 <glguy> dmwit: https://imgur.com/a/UIQwuuQ second image
22:30:58 <glguy> Because the screen goes:   hewbrew text   space space spaces timestamp, the terminal poops itself
22:31:38 <glguy> Oh, maybe I should just put an A in the divider and then render it as white on white :)
22:32:29 <glguy> slack1256: regarding long URLs, glirc will give up if the url is longer than the render-width and not try to keep it together, but /url will still recognize it
22:32:58 <dmwit> This is what the output looks like with an \x200e after the Hebrew text?
22:33:02 <slack1256> yeah, that is why I knew it was a separate problem
22:33:15 <glguy> dmwit: This is what it looks like with no mitigations
22:33:24 <Cenion[m]> slack1256: thx
22:33:27 <dmwit> Oh, sure.
22:33:31 <dmwit> But that's not confusing you.
22:33:45 <glguy> dmwit: if I put the \x200e in the divider it causes the last line to behave like two lines (seems like a terminal bug)
22:33:54 <glguy> and then every change causes the last line to scroll up
22:35:56 <dmwit> Maybe you are just looking for some commiseration.
22:36:10 <dmwit> In which case you definitely have it.
22:38:46 <dmwit> (I can't really understand your description.)
22:39:04 <glguy> I was hoping that what I tried was a hack and not the right solution, actually
22:39:20 <glguy> and that there was some other "correct" solution that wouldn't break the same way
22:41:42 <dmwit> Well, there's a bunch of different directional controls that you could try.
22:42:45 <dmwit> There's the LTR marker, but you could also try a LTR embedding+pop around the message, or use the isolate characters.
22:43:21 <dmwit> I don't think any of this is necessarily more "correct", though.
22:43:28 <glguy> what's an isolate character, and what's LTR embedding + pop? Do those admit a simplie explanation?
22:44:10 <dmwit> So there's LTR and RTL markers. These act like invisible characters which have a definite direction (to guide characters that don't have a definite direction, like spaces, periods, parentheses, Arabic numerals, and the like).
22:44:57 <dmwit> Then there's LTR and RTL embeddings. These have to be paired up with a "pop" character. The RTL embedding character begins RTL mode, then the pop character returns to whatever mode was in effect before the RTL embedding character.
22:45:22 <dmwit> (These can be nested, and yes if you screw it up you have a space leak in the renderer of your text.)
22:46:41 <dmwit> Then there's isolates, and I think they only say that the bidi behavior before and after the marker shouldn't interact.
22:47:15 <dmwit> So characters that don't have a definite direction (spaces, etc.) won't look past an isolate to choose their direction.
22:47:46 <glguy> I like the sound of that
22:47:46 <dmwit> I'm much less familiar with the isolates, though, so you might want to get a second opinion from the web on exactly what they do.
23:37:07 * hackage dynamic 0.0.3 - A dynamic type for Haskell  https://hackage.haskell.org/package/dynamic-0.0.3 (ChrisDone)
23:44:07 * hackage dynamic 0.0.4 - A dynamic type for Haskell  https://hackage.haskell.org/package/dynamic-0.0.4 (ChrisDone)
