00:04:11 <p0a> Hello can someone explain what `map (==) [1,2,3]' is?
00:05:34 <shachaf> Do you know what map f [1,2,3] is?
00:05:47 <p0a> yeah
00:06:41 <dminuoso> :t (==)
00:06:42 <lambdabot> Eq a => a -> a -> Bool
00:07:35 <dminuoso> p0a: == is a function. We call functions that dont use alphanumeric identifiers operators, to refer to them as a first-class citizen you can put them inside parens.
00:07:57 <p0a> that much I understand
00:08:20 <dminuoso> p0a: What part is confusing you?
00:09:54 <p0a> Let f = map (==) [1,2,3]. I was hoping f 2 would be [False, True, False]
00:10:08 <p0a> instead I am getting a type error. I was hoping f 2 === map (2 == ) [1,2,3]
00:10:30 <pavonia> :t (==) 1
00:10:31 <lambdabot> (Num a, Eq a) => a -> Bool
00:10:33 <p0a> oh I see now 
00:10:39 <dminuoso> p0a: The result of that initial expression is [(1 `==`), (2 `==`), (3 `==`)]
00:10:46 <p0a> map (==) [1,2,3] <=> [(1==), (2==), (3==)]
00:10:50 <dminuoso> p0a: Yup.
00:11:07 <dminuoso> p0a: Except you need to use `` to write a section.
00:11:21 <p0a> so what I want is map (.) . map (==) [1,2,3]
00:11:41 <p0a> or something like that :P
00:11:51 <dminuoso> p0a: ($) rather than (.)
00:12:22 <dminuoso> % preds = map (==) [1,2,3]
00:12:23 <yahb> dminuoso: 
00:12:26 <dminuoso> % :t preds
00:12:26 <yahb> dminuoso: (Eq a, Num a) => [a -> Bool]
00:12:37 <dminuoso> % map ($3) preds
00:12:37 <yahb> dminuoso: [False,False,True]
00:12:56 <p0a> pointfree?
00:13:16 <p0a> nevermind I get it now. Thank you. I confuse . and $ though...
00:13:20 <dminuoso> That is point free.
00:13:33 <p0a> I guess Imeant argument-free
00:14:42 <dminuoso> p0a: If you want a pointful version, you could write: map (\x -> x 3) preds
00:15:14 <p0a>  I'm trying to transform `preds' to be Number -> [Bool]
00:16:01 <dminuoso> :t \x -> map (x `==`) [1,2,3]
00:16:02 <lambdabot> error: parse error on input ‚Äò==‚Äô
00:16:07 <dminuoso> :t \x -> map (x ==) [1,2,3]
00:16:08 <lambdabot> (Num a, Eq a) => a -> [Bool]
00:16:14 <ski> > (`map` [1,2,3]) [1,2,3] 2
00:16:16 <lambdabot>  error:
00:16:16 <lambdabot>      ‚Ä¢ Couldn't match expected type ‚ÄòInteger -> t‚Äô
00:16:16 <lambdabot>                    with actual type ‚Äò[b0]‚Äô
00:16:44 <ski> > ((`map` [1,2,3]) . (==)) 2  -- sorry
00:16:46 <lambdabot>  [False,True,False]
00:17:04 <p0a> thank you 
00:17:09 <eiGHttt> :t flip map [1, 2, 3] . (==)
00:17:10 <lambdabot> (Eq a, Num a) => a -> [Bool]
00:17:18 <ski> that's the same thing, yes
00:17:24 <unyu> Whoa, do you guys really program like this?
00:17:26 <p0a> What's `map` ?
00:17:33 <ski> infix
00:17:41 <ski> unyu : "like this" ?
00:17:45 <dminuoso> unyu: The frequent IRC members frequently play Haskell golf.
00:17:47 <p0a> ah you are flipping the arguments, got it 
00:17:58 <dminuoso> unyu: Most of it is rather trivial though.
00:18:49 * ski often finds the infix right section (left section) to be more readable than a use of `flip'
00:18:58 <dminuoso> Agreed.
00:19:01 <p0a> new question: why do I get an error "can't create infiite type t ~ (t,t)" in this code? https://pastebin.com/wH4qpYW0
00:19:29 <p0a> oh nevermind now it works
00:19:35 <p0a> lol I forgot I fixed it
00:20:38 <p0a> Are you all proud of me? I've been going through homework sets 1-4 so far! 
00:20:43 <unyu> btw your ‚ÄúcartProd xs ys‚Äù prod is just ‚Äú(,) <$> xs <*> ys‚Äù
00:20:46 <ski> > (`runState` 1) . replicateM 4 $ do n <- get; put (2 * n); return n  -- example
00:20:48 <lambdabot>  ([1,2,4,8],16)
00:21:03 <p0a> unyu: no doubt! that is the only part of the code I'm not responsible for though :P
00:21:07 <unyu> oh
00:21:13 <p0a> unyu: what is <$> ?
00:21:19 <dminuoso> p0a: infix fmap
00:21:19 <unyu> fmap
00:21:26 <dminuoso> p0a: and fmap is the generalization of map
00:21:32 <p0a> in what way?
00:21:41 <ski> and `(,) <$> xs <*> ys' is `liftA2 (,) xs ys'
00:21:47 <dminuoso> p0a: map works only on lists, fmap works on trees, IO, async, etc..
00:21:56 <ski> @type map
00:21:57 <lambdabot> (a -> b) -> [a] -> [b]
00:21:58 <ski> @type fmap
00:21:59 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:22:00 <dminuoso> p0a: fmap is the real primitive you are using, it was just specialized to list for beginners.
00:22:13 <unyu> I keep forgetting about liftA<n>.
00:22:52 <p0a> that's pretty cool but I don't know about Functors yet
00:23:06 <dminuoso> p0a: dont think about it really.
00:23:19 <p0a> :P
00:23:32 <p0a> one at a time
00:23:39 <dminuoso> p0a: Seriously, just focus on using specific instances. The [] instance of fmap applies a function to every element. :)
00:24:37 <dminuoso> Functor just captures the family of things you can map over sensibly.
00:25:25 <p0a> dminuoso: I just finished Week 4 and looks like Functors are on Week 9 
00:25:39 <p0a> dminuoso: so it's something I might eventually get around to doing
00:26:26 <ski> > (fmap . fmap . fmap) (10 *) [Just [0,1,2,3],Nothing,Just [7,8],Just [9]]  -- p0a, can you, roughly speaking, follow this ?
00:26:28 <lambdabot>  [Just [0,10,20,30],Nothing,Just [70,80],Just [90]]
00:27:24 <ski> (by "roughly speaking", i mean, see what it does, and how that corresponds roughly to what i wrote. not including the details of how that actually achieves the result)
00:28:08 * hackage hmm-lapack 0.3.0.3 - Hidden Markov Models using LAPACK primitives  https://hackage.haskell.org/package/hmm-lapack-0.3.0.3 (HenningThielemann)
00:29:13 <p0a> yeah roughly speaking 
00:29:28 <p0a> not sure why there's three fmaps 
00:29:45 <p0a> actually, what is going on?!! I've no idea. sorry
00:29:50 <dminuoso> p0a: There is a `list` of `maybe` things of `lists`.
00:29:53 <ski> there's "three levels" in the thing on the right
00:29:55 <eiGHttt> :t fmap . fmap . fmap
00:29:56 <lambdabot> (Functor f3, Functor f2, Functor f1) => (a -> b) -> f1 (f2 (f3 a)) -> f1 (f2 (f3 b))
00:29:57 <ski> there's an outer list
00:30:00 <dminuoso> p0a: So you are mapping over the numbers inside lists inside maybes inside lists.
00:30:06 <eiGHttt> Orz
00:30:10 <ski> then there's `Just's and `Nothing's
00:30:18 <p0a> I think the third fmap applies the second fmap or something
00:30:19 <dminuoso> eiGHttt: yeah that might not be helpful if functor is 5 chapters away for him :-)
00:30:29 <ski> finally, inside those (only `Just's, since `Nothing's are "empty"), there's a further layer of lists
00:30:34 <koz_> Wow, such map, very covariance, amaze.
00:30:55 <dminuoso> koz_: we could introduce some contramap if you like.
00:30:59 <eiGHttt> :t [Just [1..3]]
00:31:00 <lambdabot> (Enum a, Num a) => [Maybe [a]]
00:31:07 <ski> p0a : the three `fmap's corresponds to these three layers, basically saying that we should step inside all three layers, before applying `(10 *)'
00:31:09 <dminuoso> koz_: and then to top it off, we do some bimap and dimap.
00:31:16 <koz_> dminuoso: All the map.
00:31:41 <p0a> ski: you are tricky, I didn't realize Maybe is a layer 
00:31:42 <ski> p0a : here's an equivalent way to do it
00:31:58 <ski> > fmap (fmap (fmap (10 *))) [Just [0,1,2,3],Nothing,Just [7,8],Just [9]]
00:31:59 <dminuoso> p0a: You could think of Maybe as a list that can have only 1 or 0 elements.
00:32:00 <lambdabot>  [Just [0,10,20,30],Nothing,Just [70,80],Just [90]]
00:32:01 <dminuoso> p0a: If that helps.
00:32:18 <p0a> dminuoso: yeah I think I familiarized myself with Maybe somewhat 
00:32:29 <p0a> dminuoso: it's my favorite thing so far, the types I can make with `data'. 
00:32:31 <dminuoso> p0a: Its in that sense that you can map over it. :)
00:32:38 <ski> p0a : `(fmap . fmap . fmap) (10 *)' is the same thing as `fmap (fmap (fmap (10 *)))'. but the former has fewer brackets, may be more readable (and modifiable)
00:32:40 <p0a> dminuoso: makes working with trees the easiest I've experienced in a programming language
00:33:11 <p0a> fmap . fmap . fmap . (*) 10 ?
00:33:20 <ski> no
00:33:30 <ski> `(10 *)' is `(*) 10'
00:33:41 <p0a> foldr (.) id $ take 3 $ cycle [(fmap)]
00:33:42 <ski> but, yes, you could say `(fmap . fmap . fmap . (*)) 10'
00:33:54 <ski> (i suspect that's what you meant/indended)
00:34:15 <ski> p0a : heh, that won't work, because $REASONS
00:34:21 <p0a> lol
00:34:30 <ski> (good idea, though :)
00:35:30 <p0a> okay now that I have received your compliment I believe I can resign a happy person for the day
00:35:35 <dminuoso> You need to rattle the type checkers cage a bit, turn on a few language extensions, and do type trickery to allow for something like that to work.
00:35:45 <ski> > reverse [[[0,1,2],[3,4],[5]],[[6,7],[8]],[[9]]]
00:35:47 <lambdabot>  [[[9]],[[6,7],[8]],[[0,1,2],[3,4],[5]]]
00:35:48 <ski> > map reverse [[[0,1,2],[3,4],[5]],[[6,7],[8]],[[9]]]
00:35:50 <p0a> thanks for the chat, all
00:35:50 <lambdabot>  [[[5],[3,4],[0,1,2]],[[8],[6,7]],[[9]]]
00:35:53 <ski> > map (map reverse) [[[0,1,2],[3,4],[5]],[[6,7],[8]],[[9]]]
00:35:55 <lambdabot>  [[[2,1,0],[4,3],[5]],[[7,6],[8]],[[9]]]
00:36:04 <ski> p0a : follow these ^ ?
00:37:40 <dminuoso> % getConst . forwards . traverse (Backwards . Const) $ ["foo", "bar", "quux"]
00:37:40 <yahb> dminuoso: "quuxbarfoo"
00:38:35 <koz_> I love the forwards and Backwards in that.
00:39:23 <ski> one could do a last case, like
00:39:37 <ski> > map (map (map (10 *))) [[[0,1,2],[3,4],[5]],[[6,7],[8]],[[9]]]
00:39:39 <lambdabot>  [[[0,10,20],[30,40],[50]],[[60,70],[80]],[[90]]]
00:40:02 <ski> but then one can't use `reverse', since you can't call that on `Integers'
00:40:23 * ski notices p0a fell off
00:40:36 <dminuoso> koz_: I find the Backwards applicative instance interesting because it invalidates some MonadPlus instances.
00:41:26 <ski> > (reverse . map reverse . (map . map) reverse) [[[0,1,2],[3,4],[5]],[[6,7],[8]],[[9]]]
00:41:28 <lambdabot>  [[[9]],[[8],[7,6]],[[5],[4,3],[2,1,0]]]
00:41:43 <ski> koz_ : all levels reversed ^
00:42:05 <koz_> dminuoso: Which ones?
00:42:30 <ski> (in this case, all those three functions composed commute with each other, order doesn't matter. because they are natural transformations
00:43:14 <ski> )
00:48:05 <ski>   reverseThreeLayers (| l0,l1,l2 |) = (| reverse l0,reverse l1,reverse l2 |)
00:49:17 <ski> @free reverse
00:49:18 <lambdabot> $map f . reverse = reverse . $map f
00:56:09 <ski> > (reverse |.| reverse) [[0,1,2],[3,4],[5]]
00:56:11 <lambdabot>  [[5],[4,3],[2,1,0]]
00:56:16 <ski> > (reverse |.| reverse |.| reverse) [[[0,1,2],[3,4],[5]],[[6,7],[8]],[[9]]]
00:56:18 <lambdabot>  error:
00:56:18 <lambdabot>      ‚Ä¢ Couldn't match type ‚Äòa1‚Äô with ‚Äò[a0]‚Äô
00:56:18 <lambdabot>        ‚Äòa1‚Äô is a rigid type variable bound by
00:56:21 <ski> too bad
00:59:34 <WereDictionary> Pardon me, I'm a CS student doing a presentation on concurrency in Haskell as part of a university course.
00:59:55 <Cale> You are pardoned. :D
01:00:51 <WereDictionary> I keep seeing references to haskell being good for concurrency due to its side-effect free/pure functional nature. But trying to wrap my head around it has not always worked too well.
01:01:01 <WereDictionary> Thank you.
01:01:27 <Cale> Well, did you have any particular questions about it?
01:01:37 <Cale> I could provide some examples of where that helps
01:01:56 <Cale> One place is with STM
01:02:30 <WereDictionary> Would it be entirely correct, sort of correct to say that "has no side-effects" and "has no mutable state" as in "shared mutable state is the root of all evil" are roughly equivalent?
01:02:44 <WereDictionary> Or would that be entirely mistaken?
01:03:26 <WereDictionary> As I understand it, one of the advantages of a purely functional language is that you normally don't have to worry about, e.g., race conditions.
01:03:29 <Cale> Well, to be clear Haskell is capable of describing effects, it's just that evaluation of Haskell expressions doesn't cause those effects to occur.
01:04:13 <ski> Haskell separates (execution of) effects from evaluation
01:04:18 <WereDictionary> Yes, I gathered as much.
01:04:32 <Cale> So there's a wide class of computations you can meaningfully describe where no effects are allowed, and then we have various types whose values describe effects, and the carrying out of those effects is separated from the evaluation of the expressions which encode them.
01:04:56 <Cale> So, for example, in addition to the IO type you've probably already seen
01:05:24 <Cale> there's a type STM such that values of type  STM a  describe memory transactions (having a result of type a)
01:05:43 <Cale> and there's a function  atomically :: STM a -> IO a
01:05:52 <ski> it's a similar idea as wanting to separate user interface from internal computation machinery -- in this case enforced (in some sense) by the language
01:06:36 <ski> (user interface here being defined as something that necessarily does Input/Output communication with the rest of the world, typically via the OS)
01:06:54 <Cale> which produces an IO action that, when you run it, will attempt to carry out the memory transaction -- writes that the transaction performs go into a log, and get committed when the transaction is complete (taking a global lock for a short time). If any of the things that the transaction read have had their values changed in the meantime, the transaction retries.
01:07:34 <Ariakenom> a function "a -> b" will not have a race condition, which it could in other languages. which is nice
01:07:56 <Cale> The overall effect of this is that it's as if the action of type STM a occurs atomically
01:08:15 <Cale> (even though really it's attempting to run concurrently)
01:08:31 <ski> (`STM' stands for "Software Transactional Memory")
01:08:36 <Cale> right
01:08:44 <dminuoso> koz_: Sorry that was phrased wrong.
01:09:26 <WereDictionary> So as I understand, race conditions can only occur using when using monads, allowing you not to worry about it for most of your code, and clearly marking where it is a risk?
01:09:29 <Cale> Since it's fairly unpredictable whether and when a transaction might retry (and in fact, we'd like implementations to be able to be more intelligent about things like that in the future), it's really unfortunate if anything happens during an STM transaction which couldn't be rolled back
01:09:34 <WereDictionary> -using
01:09:53 <Cale> So we need to keep IO out of STM transactions -- only reads and writes to transactional memory are allowed
01:10:08 <Cale> but that's easy, because IO actions have a different type from STM actions
01:10:15 <Ariakenom> WereDictionary: replace monad with IO and that sounds good
01:10:41 <Cale> WereDictionary: IO happens to be an example of a monad, but it's a very special example.
01:10:43 <WereDictionary> I'm afraid I haven't read up on STM. I'm currently reading up on the basic advantages of purely functional in regards to concurrency.
01:10:55 <WereDictionary> I see.
01:10:56 <Cale> WereDictionary: Right, STM is a big part of that
01:10:56 <dminuoso> WereDictionary: Are you familiar with database transactions?
01:11:14 <WereDictionary> Yes, although it's been a while since I read up on them.
01:11:14 <Cale> https://simonmar.github.io/bib/papers/stm.pdf
01:11:18 <ski> WereDictionary : part of the utility of monads in Haskell is that you know when you're *not* using them
01:11:23 <Cale> ^^ the original paper on STM, I highly recommend it
01:11:34 <WereDictionary> Thank you.
01:12:01 <Ariakenom> STM is not unique to haskell but in haskell the type system helps avoid a bunch of errors. like nesting stm-transactions or performing effects before a commit
01:12:03 <WereDictionary> So data race conditions can only occur when using the IO monad?
01:12:04 <dminuoso> WereDictionary: So just like inside a database transaction you get to see a consistent view of your database (you cant see any concurrent writes of other transactions), STM gives you a consistent and atomic view of memory.
01:12:24 <Cale> Yeah, STM basically hasn't become very popular in other settings, and there's a good reason for that
01:12:39 <ski> @quote whyfp
01:12:39 <lambdabot> No quotes match. Do you think like you type?
01:12:45 <ski> @where whyfp
01:12:45 <lambdabot> "Why Functional Programming Matters" by John Hughes in 1984 at <http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html>
01:12:59 <ski> WereDictionary : perhaps ^ that would also be interesting to check
01:13:14 <Cale> The moment you have any little effect which isn't transactional going on inside of a transaction, you have a bug from hell that will be very annoying to figure out.
01:13:37 <Cale> Haskell lets us prevent that
01:13:55 <dminuoso> And GHC gives us the primitives avoiding the prevention.
01:14:01 * dminuoso eyeballs unsafePerformIO
01:14:04 <Cale> haha
01:14:15 <tdammers> someone combined the I word and the M word again
01:14:42 <Cale> Well, those are things which if you use them, you're basically admitting that you'd otherwise have extended the compiler
01:15:02 <Cale> and you're taking on the same responsibility
01:15:12 <ski> (proof obligations)
01:15:22 <tdammers> IMO those are things where we are being intellectually honest and admit that the Incompleteness Theorem applies to type systems too
01:15:31 <ski> ("if you lie to the compiler, the compiler will get its revenge !")
01:15:54 <dminuoso> Cale: Im not convinced that's the full side of it.
01:16:06 <dminuoso> Cale: If I use a library and it exposes some `STM Foo` to me. Does it do IO? I dont know really..
01:16:27 <Cale> dminuoso: Well, you have to trust the library's author, sure.
01:16:39 <dminuoso> And any transitively used library's author.
01:16:53 <Ariakenom> tdammers: it sure is a common phrase. lets make list the offending blogs and send upset notes :)
01:17:02 <dminuoso> In Haskell we seem to be in a good spot in that it doesn't seem common place that unsafePerformIO is abused.
01:17:12 <dminuoso> But that's a rather weak contract.
01:17:19 <Cale> Right, using unsafePerformIO is usually more hassle than it's worth.
01:17:27 <Cale> and it's usually unnecessary
01:17:52 <tdammers> also, I'd wager that almost 50% of unsafeXXXX usages are performance hacks, and the other almost-50% arise when you're dealing with code that uses IO but is morally pure, typically due to naive FFI bindings
01:18:13 <Cale> But there are various places where you know what you're doing, and you'd really rather put something in a library rather than have to make pull requests against GHC
01:18:35 <tdammers> Ariakenom: yes, lets! Someone on the internet is wrong!
01:18:36 <dminuoso> tdammers: I mean consider that bytestring has a history of really strange bugs due to wrong usage of accursedUnutterablePerformIO.
01:19:08 <Cale> dminuoso: Those bugs could just as easily have been compiler bugs had we made ByteString primitive
01:19:12 <Cale> which is the other option
01:19:25 <Cale> or there's the third option of just never having programs with reasonable performance
01:19:26 <tdammers> dminuoso: yes, it does; but I don't see how else you'd write a performant byte-array implementation in Haskell, short of baking them into the compiler
01:19:47 * ski . o O ( "Mathematics, morally" by Eugenia Cheng in 2004-01 at <https://cheng.staff.shef.ac.uk/morality/morality.pdf> )
01:19:58 <tdammers> so yes, in hindsight, having byte array primitives in the compiler may have been the better approach
01:20:15 <Cale> Maybe? I'm not even sure about that.
01:20:34 <Cale> There are some unboxed byte array primitives for sure.
01:21:41 <tdammers> point in case, being able to have bytestring be a library is pretty damn neat
01:21:51 <Cale> But so long as GHC is good enough at compiling code which uses unsafePerformIO, it's a reasonably good way to not need to put the implementation of low-level basic data structures into the compiler.
01:22:36 <Cale> There always might be some new low-level bit of hackery that we want to put a pure interface on, and not needing GHC to know about all of those up front is convenient.
01:22:58 <WereDictionary> Well, I have some reading to do. Thank you for your help.
01:23:30 <tdammers> also helps keep the core language small
01:23:33 <tdammers> ish
01:25:51 <Ariakenom> you said core language and did not mean Core language :p
01:26:20 <mszh> ah, my laptop got disconnected last night üò§ is there a way i could get the previous X messages?
01:26:49 <dminuoso> mszh: If you check the topic, you will see that the contents of this channel are logged.
01:28:15 <mszh> this: Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D  
01:28:36 <mszh> awesome @karma+ dminuoso 
01:28:40 <mszh> @karma+ dminuoso 
01:28:40 <lambdabot> dminuoso's karma raised to 4.
01:29:02 <tdammers> Ariakenom: 
01:29:03 <tdammers> ues
01:29:05 <tdammers> yes
01:34:22 <kuribas> is it possible to implement last in terms of foldr?
01:35:12 <kuribas> or fromLast :: a -> [a] -> a
01:36:31 <kuribas> it's easy from foldr1
01:36:35 <kuribas> > foldr1 (flip const) [1, 2, 3]
01:36:37 <lambdabot>  3
01:37:19 <Ariakenom> > foldr1 undefined (flip const) [1, 2, 3]
01:37:21 <lambdabot>  error:
01:37:21 <lambdabot>      ‚Ä¢ Could not deduce (Foldable ((->) b0))
01:37:21 <lambdabot>          arising from a use of ‚Äòfoldr1‚Äô
01:37:22 <Ariakenom> > foldr undefined (flip const) [1, 2, 3]
01:37:24 <lambdabot>  error:
01:37:24 <lambdabot>      ‚Ä¢ No instance for (Typeable b0)
01:37:24 <lambdabot>          arising from a use of ‚Äòshow_M490140437178746285824013‚Äô
01:38:37 <Ariakenom> > (foldr undefined (flip const) :: [a] -> a) [1,2,3]
01:38:39 <lambdabot>  error:
01:38:39 <lambdabot>      ‚Ä¢ Couldn't match type ‚Äòa1‚Äô with ‚Äòb0 -> c0 -> c0‚Äô
01:38:39 <lambdabot>        ‚Äòa1‚Äô is a rigid type variable bound by
01:39:34 <Ariakenom> oh argument order, ha
01:39:58 <mszh> @karma+ ziman
01:39:58 <lambdabot> ziman's karma raised to 1.
01:43:26 <cfraz89> lastFoldr = fromJust (foldr last' Nothing [1, 2, 3])
01:43:28 <cfraz89>   where last' a b = case b of
01:43:30 <cfraz89>           Nothing -> Just a
01:43:32 <cfraz89>           Just c -> Just c
01:43:36 <cfraz89> havent tested it
01:44:49 <kuribas> cfraz89: that might work!
01:47:25 <mszh> @help
01:47:25 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
01:47:26 <kuribas> why isn't there a safe index in prelude?
01:47:33 <mszh> @help list
01:47:33 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
01:47:44 <cfraz89> yeah it works :D
01:47:49 <kuribas> @hoogle [a] -> i -> Maybe a
01:47:50 <lambdabot> Data.Maybe.HT alternatives :: a -> [Maybe a] -> a
01:47:50 <lambdabot> Agda.Utils.List mcons :: Maybe a -> [a] -> [a]
01:47:50 <lambdabot> Trace.Hpc.Coveralls.Util mcons :: Maybe a -> [a] -> [a]
01:47:55 <kuribas> @hoogle [a] -> Int -> Maybe a
01:47:55 <lambdabot> Safe atMay :: [a] -> Int -> Maybe a
01:47:55 <lambdabot> Agda.Utils.List (!!!) :: [a] -> Int -> Maybe a
01:47:55 <lambdabot> CLaSH.Util indexMaybe :: [a] -> Int -> Maybe a
01:48:32 <cfraz89> complete version point-free, for posterity :)
01:48:49 <cfraz89> https://paste.gnome.org/pqrqkwyy8
01:48:54 <dminuoso> Mmm, I have a nix.shell that gives me GHC and cabal-install and some libraries, however these libraries are not discoverable by the linker (because nix uses NIX_LDFLAGS). What is the canonical way to feed the nix environment to cabal v2-build?
01:50:45 <stevejb> hello, I am looking at modernising some code which is using conduit, which I haven't used before. I am running into this error:
01:50:51 <stevejb> No instance for (MonadUnliftIO (StateT Settings IO))
01:51:13 <stevejb> It seems based on the documentation to MonadUnliftIO that this is by design, but I am not sure what to do about it
01:51:27 <dminuoso> stevejb: Not use StateT?
01:51:44 <dminuoso> stevejb: You could use a ReaderT and drag some IORef around in your environment.
01:51:53 <cocreature> or just pass them around manually
01:52:05 <stevejb> dminuoso: Yeah, I suppose so. I guess this will be a arger refactor than I was anticipating
01:52:23 <stevejb> *larger
01:52:27 <stevejb> thanks
01:52:46 <MarcelineVQ> kuribas: \ys -> head $ foldr (\x xs -> xs . ([x] ++)) id ys []
01:58:41 <mszh> @quote Cale "types as propositions" (and programs as proofs) https://www.youtube.com/watch?v=aeRVdYN6fE8 just watched the talk, that's exactly what he's talking about
01:58:41 <lambdabot> No quotes match. Whoa.
01:59:43 <mszh> also mentioned dependent types, coq, ... 
01:59:51 <Cale> yep
02:00:11 <mszh> the same think in text form: https://homepages.inf.ed.ac.uk/wadler/papers/propositions-as-types/propositions-as-types.pdf
02:03:29 <MarcelineVQ> kuribas: which is silly looking to be sure, and not actually faster for this problem since we're just racing to the end anyway, but is pretty useful otherwise. in this form we can build the list up backwards without repeating work with ++. a ++ (b ++ c) does less work than (a ++ b) ++ c as the latter has to traverse a twice due to the definition of ++
02:04:20 <Cale> (Which is not really the fault of (++), but just the nature of what lists are)
02:04:29 <mszh> there're a couple of great points last night:  "use types to model properties that help you catch programming errors, rather than rules of your game", "is it worth the cost of encoding it in types"
02:05:37 <Cale> mszh: Yeah, the nice thing about using languages with expressive type systems is that you have the luxury of making those engineering decisions
02:05:57 <MarcelineVQ> also by faster I mean compared to the other definition of a reversed list with foldr, foldr (\x xs -> xs ++ [x]) [] this builds up in (a ++ b) ++ c form since the recursion is happening from xs
02:06:01 <Cale> (rather than being forced not to express very much)
02:06:02 <mszh> if i had to go this way: `data Location = Location OneToEight OneToEight` that feels like this whole thing in haskell is not expressive enough
02:06:21 <Cale> I wouldn't even represent the OneToEight type
02:06:38 <Cale> Probably just an Int will do.
02:07:03 <delYsid> Wow, 10 hours later you're still on the same chess discussion?
02:07:10 <Cale> no, it just came back
02:07:39 <mszh> anyways, thanks for the help, now i've got a bunch of papers and books to read (about HC isomorphisms, logic, lambda calculus...)
02:09:48 <kuribas> MarcelineVQ: [x] ++ ?
02:09:55 <kuribas> MarcelineVQ: why not (x:) ?
02:11:48 <MarcelineVQ> Just to keep the ++ idea in sight, but also because I didn't think of it, mostly the latter.
02:24:38 * hackage Ranged-sets 0.4.0 - Ranged sets for Haskell  https://hackage.haskell.org/package/Ranged-sets-0.4.0 (PaulJohnson)
03:08:27 <schrammc> hi, I was wondering where in the base source can I find the source code for the foldr/build rewrite rules?
03:08:41 <schrammc> They don't seem to be in either Data.Foldable or Data.List
03:08:52 <schrammc> going by ctrl+F "RULES"
03:11:05 <Taneb> schrammc: it's in GHC.Exts
03:11:49 <schrammc> thanks Taneb
03:12:01 <MarcelineVQ> http://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#foldr
04:07:20 <reygoch> Does anyone knows how to properly use ToJSON and FromJSON classes from ghcjs-base package?
04:07:49 <reygoch> I can't automatically derive those classes no matter what.
04:07:58 <dminuoso> reygoch: Do you have a specific error message?
04:08:01 <reygoch> yes
04:08:04 <reygoch> just a sec
04:09:48 <reygoch> dminuso: this GFromJSON and GToJSON classes are the main problem
04:09:52 <reygoch> dminuso: https://pastebin.com/snSmmhd1
04:10:44 <reygoch> dminuoso: Here I've tried using the manual parsing approach with generics but it still gives me the same error.
04:10:55 <dminuoso> reygoch: please include your code
04:11:21 <reygoch> It's kinda large. Gimme a sec to make a small example
04:11:28 <dminuoso> reygoch: In particular, did you derive an instance Generic for CookBook.Client.Model?
04:13:04 <MarcelineVQ> this exists in base somewhere doesn't it? I feel like I'm taking crazy pills, apMap :: Functor f => f (a -> b) -> a -> f b
04:14:31 <lyxia> I don't think so.
04:15:08 <MarcelineVQ> Oh well, it's not exactly hard to write but it just looks really common somehow
04:15:38 <dminuoso> MarcelineVQ: I guess in the space of ($), <$>, =<< and <*> it's that one bit we dont have.
04:16:05 <reygoch> dminuoso: yes, of course
04:16:44 <MarcelineVQ> dminuoso: funnily enough I need to because I'm doing a thing that fits in between those spaces :> https://www.staff.ncl.ac.uk/andrey.mokhov/selective-functors.pdf
04:18:09 <dminuoso> MarcelineVQ: Are you one of the authors?
04:18:17 <phadej> :t ??
04:18:18 <lambdabot> error: parse error on input ‚Äò??‚Äô
04:18:19 <MarcelineVQ> Oh no no :>
04:18:23 <phadej> :t (??)
04:18:24 <lambdabot> Functor f => f (a -> b) -> a -> f b
04:18:25 <MarcelineVQ> But it's caught my eye
04:18:30 <phadej> lens has it
04:18:36 <Lears> I would use `fatob <*> pure a` without a second thought.
04:18:46 <Taneb> phadej: seems a very small thing to depend on lens for
04:18:51 <Lears> It's pretty much what pure is for.
04:18:57 <MarcelineVQ> phadej: yeah, thank you, just thought it might have lived in base
04:19:00 <dminuoso> Taneb: People have depended on lens for less.
04:19:01 <phadej> Taneb: well, `lens` have a name for it :)
04:19:05 <reygoch> dminuoso: here's the code and the errors https://pastebin.com/JS4QY3E9
04:19:08 <Taneb> phadej: fair
04:19:49 <MarcelineVQ> dminuoso: particularly because I've been thinking of parallelism recently
04:19:50 <phadej> % :i ??
04:19:50 <yahb> phadej: (??) :: Functor f => f (a -> b) -> a -> f b -- Defined in `Control.Lens.Lens'; infixl 1 ??
04:20:19 <dminuoso> reygoch: Give me a moment to read through this.
04:20:20 <phadej> fab ?? a = fmap ($ a) fab
04:21:55 <Taneb> If you like wanton generality, there's also distribute
04:21:56 <phadej> note that for ((->) r): ?? = flip
04:22:00 <phadej> that's kind of cool
04:22:01 <Taneb> :t Data.Distributive.distribute
04:22:02 <lambdabot> (Functor f, Data.Distributive.Distributive g) => f (g a) -> g (f a)
04:22:30 <reygoch> dminuoso: it also doesn't work when I do "instance ToJSON Example" instead of deriving it
04:22:55 <dminuoso> reygoch: Im looking through the library to make sense of it.
04:24:12 <Taneb> ...is it possible to have a cycle of class dependencies?
04:24:22 <Taneb> Like "class Foo a => Bar a; class Bar a => Foo a"
04:25:06 <hpc> what you want is one type class
04:25:10 <lyxia> Taneb: sure
04:25:14 <dminuoso> reygoch: Ah it's quite easy. Unlike aeson, it seems like ghcjs-base is not tying ToJSON to some generic thing by default.
04:26:13 <reygoch> dminuoso, what does that mean?
04:26:14 <lyxia> there is a Javascript.JSON.Types.Generic module though
04:26:31 <lyxia> reygoch: import that ^
04:26:41 <reygoch> lyxia, ok, cool
04:28:04 <lyxia> hmm shouldn't it already be exported
04:28:07 <reygoch> lyxia, dminuoso : lol, I was banging my head into the wall last night
04:28:22 <reygoch> lyxia, I've noticed a lot of orphans in JSON modules
04:28:45 <reygoch> is this because of performance / js code generation reasons perhaps?
04:30:00 <lyxia> no idea
04:30:11 <dminuoso> lyxia: Fancy, the implementation has IncoherentInstances *and* Overlapping instances pragmas turned on.
04:30:43 * dminuoso shudders
04:32:16 <reygoch> shudders
04:33:37 <dminuoso> reygoch: What happens if you import the entire module JavaScript.JSON.Types.Class instead of cherry picking identifiers and importing the Generic module?
04:35:02 <reygoch> Hm.. I think the same thing cos I did that before.
04:35:55 <reygoch> I mean, instances should be imported regardless of whether I've cherripicked or not from the module.
04:36:36 <dminuoso> Oh I can see why.
04:36:47 <dminuoso> This is truly weird.
04:39:54 <lyxia> They even have a toplevel empty Javascript.JSON, that would be such a good place to export stuff from
04:49:37 * hackage http-conduit 2.3.6 - HTTP client package with conduit interface and HTTPS support.  https://hackage.haskell.org/package/http-conduit-2.3.6 (MichaelSnoyman)
04:50:46 <svipal> Yo, sorry to ask here but haskell stack is seemingly dead. 
04:50:48 <svipal> https://friendpaste.com/5x5kSiTBetH0lpWFJW6xAm
04:51:02 <svipal> where am I supposed to place that .so ?
04:53:26 <svipal> I meant ..  #haskell-stack channel is seemingly dead. lol
05:08:08 * hackage b9 0.5.68 - A tool and library for building virtual machine images.  https://hackage.haskell.org/package/b9-0.5.68 (SvenHeyll)
05:08:10 <[exa]> svipal: man, pastebin that references pastebin... :]
05:09:02 <[exa]> do you have the sfml-window.so library somewhere?
05:29:16 <Ariakenom> I found this list of blogs with summaries interesting https://guide.aelve.com/haskell/popular-blogs-dila2lox
05:40:11 <svipal> <[exa]> : yeah I do !
05:40:18 <svipal> that's why I'm bamboozled
05:42:57 <svipal> [exa]: woops
05:49:17 <[exa]> svipal: where is the .so now?
05:49:44 * [exa] is astonished by the nature of word "bamboozled"
05:51:13 <[exa]> svipal: you need to get the .so to any place where the involved compiler can see it. I'd first try placing it manually into the folder where the library referenced in the error message is (libHSSFML); if not, /usr/lib is a good place for it (can you install some kind of libsfml-dev from a package manager?)
06:45:10 <svipal> [exa]: will try placing it in usr/lib
06:46:28 <svipal> [exa]: currently in the project/lib folder and in usr/local/lib. there's no libcsfml-dev in my distrib, (the problematic .so is csfml not sfml)
06:49:27 <[exa]> libsfml-devel or something? (what's your distribution?)
06:53:01 <svipal> solus. I have already SFML-devel installed
06:53:08 <milesrout> okay kind of a weird question I guess
06:53:15 <milesrout> is there a monad for functions that look like
06:53:20 <milesrout> [a] -> (x, [a])
06:53:29 <milesrout> that consume only part of a stream and return a result
06:53:34 <dminuoso> milesrout: State
06:53:40 <milesrout> oh my god 
06:53:41 <milesrout> >.<
06:53:44 <svipal> hahaha
06:53:45 <milesrout> 3am coding
06:54:00 <ski> milesrout : `Supply' iirc ?
06:54:25 <fen> there is a problem with cyclic pointers based on zippers, which is that a cyclic reference is a stored zipper navigated to some position
06:54:49 <svipal> [exa]: it worked when I changed the cmake install script to install in /usr/ instead of usr/local and stopped using the custom lib folder
06:55:03 <svipal> cmake install script for csfml I mean
06:55:45 <fen> this creates a situation where the zipper itself seems invalid as a pointer, compared with a linked list, where every node contains such cyclic references 
06:56:00 <Ariakenom> let map m–∞—Ä ma—Ä = m–∞—Ä : map m–∞—Ä ma—Ä; m–∞p m–∞—Ä = map m–∞—Ä m–∞—Ä in m–∞p "map"
06:56:05 <Ariakenom> % let map m–∞—Ä ma—Ä = m–∞—Ä : map m–∞—Ä ma—Ä; m–∞p m–∞—Ä = map m–∞—Ä m–∞—Ä in m–∞p "map"
06:56:12 <yahb> Ariakenom: ["map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","map","ma
06:56:28 <milesrout> yikes
06:56:35 <milesrout> supply looks perfect btw thanks
06:56:36 <fen> and then there is a struggle in trying to justify the use of zippers for cyclic pointers compared to a linked representation
06:56:51 <dminuoso> ski: I presume `Supply` would be some indexed variant of State that only allows for consuming (but not pushing pack or modifying) parts of the stream?
06:58:18 <fen> should we only work with difference representations when considering cyclic pointers?
06:58:39 <dminuoso> milesrout: Which `supply` does look perfect to you? What package is it from?
06:58:46 <milesrout> monad-supply
07:00:32 <dminuoso> milesrout: Ah yes, that appears to be just a wrapper around StateT [s] :)
07:00:50 <dminuoso> (Assuming you are looking at SupplyT)
07:01:01 <milesrout> mhm
07:01:23 <milesrout> but by calling it Supply you make it a little more obvious what the idea is. harder to make mistakes. strong types!
07:01:41 <dminuoso> Absolutely, not trying to argue against it.
07:02:53 <dminuoso> MonadSupply looks somewhat interesting.
07:03:35 <ski> dminuoso : yes
07:04:39 <dminuoso> ski: Then Supply has no such guarantees, sadly.
07:05:05 <dminuoso> ski: Im not sure you can even do it without an IMonad.
07:05:13 <ski> (not sure what you mean by index variant, though)
07:05:45 <dminuoso> ski: Well say some IStateT where the state is parametrized over type level naturals.
07:05:47 <Boarders> when I try to do: cabal v2-install sdl2-cairo-image I get "(conflict: pkg-config package sdl2>=2.0.4, not found in the pkg-config database)"
07:05:53 <Boarders> does anyone know what I need to install for that
07:05:56 <Boarders> I am on linux
07:06:18 <ski> dminuoso : only allowing it to decrease ?
07:06:47 <dminuoso> ski: Or increase, but yeah.
07:10:03 <dminuoso> ski: Im not sure how you would enforce monotonicity though.
07:10:18 <shapr> GOOD MORNING Haskellers!
07:10:26 <Solonarv> Boarders: you need SDL2; I'm not sure what exactly it's named but I would expect something like libSDL2 or perhaps libSDL2-devel
07:11:31 <Boarders_> Solonarv: thanks!
07:11:54 <Boarders_> I do have that installed but I think I need to set an environment var according to this: https://stackoverflow.com/questions/25713200/cant-install-sdl2-via-cabal
07:13:38 <Solonarv> ah yes, that could be the case
07:20:24 <fen> dminuoso: monotonicity? what does it mean, like there is a fixed order of traversal?
07:22:44 <Ariakenom> shapr: hi
07:24:39 <milesrout> why do i forget everything about haskell when i dont use it for 2 months
07:24:46 <shapr> hi Ariakenom !
07:25:44 <maerwald> milesrout: you think that is specific to haskell or does it happen with any language?
07:25:57 <dminuoso> milesrout: For how long have you been learning Haskell?
07:26:22 <milesrout> I don't know it seems to happen to Haskell in particular. I first wrote Haskell some time in 2015 I think
07:26:50 <milesrout> I haven't used it for 2 months and I've forgotten completely how my monad transformer stack works in this particular bit of code. just a bit of getting back into the flow of things I'm sure
07:26:58 <milesrout> :) lovely community though
07:27:07 <maerwald> because monad transformers are maybe not very intuitive
07:27:14 <maerwald> nor declarative
07:27:21 <Boarders_> when I try to do: cabal v2-install sdl2-cairo-image I get the error "Failed to load interface for 'SDL.Cairo.Canvas'
07:27:41 <Boarders_> anyone have any ideas how you fix that?
07:30:02 <milesrout> okay here's an odd question: why would one use Freer over Free?
07:30:28 <milesrout> which is a proxy for 'why did I use freer over free in this code'
07:32:16 <fen> to get fmap "for free" ?
07:34:27 <dminuoso> milesrout: One thing I wish I had read about in the beginning, is that monad transformers are not needed in Haskell.
07:35:15 <maerwald> dminuoso: why did you think they are? 
07:35:51 <dminuoso> Because this channel as well as learning resources are eager to teach you "monad transformer stacks" and how they are necessary to solve problem X/Y/Z in Haskell.
07:36:11 <maerwald> Yeah, people hype all sorts of things ;P
07:36:24 <maerwald> these days you cannot do without dependent types, apparently
07:36:39 <fen> milesrout: http://okmij.org/ftp/Computation/free-monad.html
07:36:50 <milesrout> one of my friends has done a lot of agda for his thesis and he's starting to convince me of it
07:37:56 <fen> dminuoso: there is a need to translate things into monad transformers to allow them to be used in such settings 
07:39:18 <dminuoso> fen: Fundamentally you can write any program without a single MaybeT/StateT/ReaderT/ListT just fine though.
07:39:30 <fen> similarly, functions should be written alongside type level versions, to allow them to be incorporated into such settings 
07:39:40 <maerwald> dminuoso: and they usually become easier to reason about then
07:39:51 <maerwald> because implementation details are not hidden in instances anymore
07:40:13 <dminuoso> Well I find monad transformers easy to reason about because Id like to think that I understand them well.
07:40:25 <dminuoso> But I spend quite a bit of time using them.
07:40:49 <fen> dminuoso: its the other way round, other libs that do use transformers exist, and then code should be written to be compatible with it
07:42:13 <fen> take https://wiki.haskell.org/New_monads/MonadSupply for instance 
07:42:41 <dminuoso> fen: Fair enough.
07:44:12 <fen> actually that lib is slightly confusing by its use of lists, it could as well be any shaped linear container
07:44:39 <fen> but then there would be an `r' to contend with as well as `m' and it might become complicated
07:46:26 <fen> seems actually quite strange to use the "get" instance of list to give a state. get is basically a state anyway! but then it gives a transformer via this wrapper so maybe its worth it, specifically encapsulating the get instance
07:47:12 <fen> probably there is something similar with storeT / set
07:48:49 <fen> wait, why is it (StateT [s] m a) and not (StateT [a] m a) ?
07:51:15 <fen> does it implicitly have s -> a ?
07:51:24 <dminuoso> fen: It couldn't be a Monad if it was `StateT [a] m a`
07:51:27 <fen> like, states that just return one value?
07:52:15 <fen> cant understand how this is turning a state into a list of states
07:52:32 <fen> a state is already going to produce a list of values
07:52:43 <dminuoso> fen: The result is unrelated to the internal state.
07:53:33 <dminuoso> fen: Imagine Supply being used for writing monad parser combinators, then `[a]` would be the token stream.
07:53:36 <fen> but when you return the new [s] you can take the tail, or add to it or change the contents or whatever
07:53:45 <dminuoso> Yup.
07:53:54 <fen> so why use a list?
07:54:16 <fen> its nothing to do with having lists get instance be used to give state like bahavious?
07:54:36 <dminuoso> fen: the list is just to allow for the MonadSupply interface.
07:55:40 <fen> oh, so thats the part that enforces the returned updated [s] is just a tail
07:55:55 <dminuoso> fen: Well yes and no.
07:56:20 <dminuoso> fen: I guess its the only way you get to see the content (since you dont get to put/modify the state)
07:56:38 <dminuoso> Though that's not entirely true, since you can use the monad interface to inject a new Supply
07:57:06 <fen> yeah, seems like a confusing double state kind of thing going on
07:57:26 <fen> like, why not just use a state encoding of the [s] ?
07:57:54 <fen> (s',s'->(s,s'))
07:58:06 <fen> (s',s'->Maybe (s,s'))
07:58:45 <fen> and of course, if your doing it twice you might as well consider the recursion
07:59:56 <dumptruckman> So... I know this isn't Haskell but you guys tend to be friendly functional programmers. Isn't there a better, more functional way of writing something like this (java) https://hastebin.com/nucaxuzevo.cpp ? I'm open for a haskell implementation or how I could do such in haskell
08:00:19 <dumptruckman> I feel like there some kind of mathematical approach that I am not able to see
08:00:24 <dumptruckman> A series or something
08:01:11 <fen> that should be pretty easy to write in haskell, have you tried?
08:01:47 <dumptruckman> Well I'm not looking to write it as is in Haskell, but I agree, it wouldn't be too bad
08:02:08 <dumptruckman> Really, I'm wondering if there's a more mathematical approach
08:02:14 <dumptruckman> without recursion perhaps
08:02:25 <dumptruckman> though I guess a series must be programmed with recursion..
08:02:51 <dumptruckman> So I guess I'm wondering if it can be represented as a non-recursive function
08:04:05 <fen> your taking the length of the list produced by the iteration of a function updating an input depending on the iteration number
08:05:02 <fen> in haskell we usually try and create recursive implementations, not unroll them into something where we could solve it algebraically 
08:05:12 <dumptruckman> fair
08:05:51 <fen> but if what you want is to find the common resursive function and factor that out using this higher order function
08:05:53 <mgalese> I would break it into pieces and take advantage of lazyness.   Make neededXP be the result of mapping your function over an open ended integer range
08:05:57 <fen> thats something we like in haskell
08:06:35 <mgalese> then scan summing over that neededXP and take until you get to a number over the getLevel threshold
08:07:03 <Solonarv> btw, I'm tinkering with generalized Supply monad right now
08:07:32 <Solonarv> the current version is basically 'SupplyT f s m a = StateT (Cofree f s) m a'
08:08:14 <dumptruckman> mgalese: makes sense, thanks
08:08:38 <Taneb> > snd . last . takeWhile (\p -> fst p <= 8) . flip zip [1..] $ scanl (+) 0 [1,2,3,4]
08:08:40 <lambdabot>  4
08:09:00 <fen> Solnarv: why? isnt state what your after?
08:09:21 <fen> like, [] and cofree f are just geing used for their get instance right?
08:09:45 <fen> so why not consider this wider class?
08:10:20 <fen> hmmm, guess cofree requires an input to decide which state to return
08:10:42 <dumptruckman> I guess what would be simpler is if the neededXp function calculated the total xp needed for a given level rather than the amount needed for leveling up to that level
08:11:46 <fen> but you just implemented that
08:11:48 <Taneb> dumptruckman: you can use something like scanl (+) 0 to go from amount for one level to total amount
08:12:58 <fen> get/set vs retrive/insert
08:13:08 <dumptruckman> hmm
08:14:07 <fen> if its a pointer you can have those as navigations before get and set
08:14:41 <fen> like, a pointer over cofree could be modified to point down the correct branch so regular get could be used
08:16:03 <mgalese> @dumptruckman : Something like this https://hastebin.com/mebasivadu.js
08:16:03 <lambdabot> Unknown command, try @list
08:16:09 <mgalese> dumptruckman : Something like this https://hastebin.com/mebasivadu.js
08:18:00 <fen> Solonarv: that is, the pointer for \f->Cofree (Zipper f), as opposed to \f -> Zipper (Cofree (Zipper f)) which would also have vertical navigation
08:19:52 <mgalese> dumptruckman: typo fixed: https://hastebin.com/cuxuxekoca.js
08:20:27 <dumptruckman> thanks
08:20:53 <Boarders_> does anyone know if there is a good way to interface between diagrams and juicy?
08:21:05 <Boarders_> as in using an Image type from juicy with diagrams?
08:22:02 <fen> diagram?
08:22:50 <mgalese> Maybe this? https://github.com/diagrams/diagrams-input
08:26:32 <WilliamHamilton[> hmm, why is ghc not doing exaustiveness check on a `SOP Foo (Code Bar)`? I was under the impression that it did!
08:28:51 <Ariakenom> WilliamHamilton[: I don't think the warning is on by default. Are you running -Wall?
08:30:16 <WilliamHamilton[> Ariakenom: I'm seeing this in dante, which I *think* enables -Wall by default. But my point is, why is not ghc seeing that I'm describing all cases?
08:32:52 <WilliamHamilton[> if I have a datatype Bar with two constructors, then a `SOP Something (Code Bar)` should be exaustively split in `SOP (Z _)` and `SOP (S (Z _))`, but this doesn't seem the case as far as ghc is concerned
08:36:57 <WilliamHamilton[> kosmikus_: ^
08:43:27 <kosmikus_> WilliamHamilton[: that's because NS is currently not spine-strict, which is arguably a mistake
08:43:58 <kosmikus_> WilliamHamilton[: S (S undefined) is a valid value, and is not matched
08:44:37 <kosmikus_> WilliamHamilton[: you can fix this by explicitly refuting it though
08:44:48 <WilliamHamilton[> kosmikus_: I see, thank you! So there's nothing that can be done on the user part, right?
08:44:57 <WilliamHamilton[> kosmikus_: how so?
08:44:58 <kosmikus_> WilliamHamilton[: f (S (S x)) = case x of {}   -- using -XEmptyCase
08:46:54 <WilliamHamilton[> kosmikus_: I see, but then `case x of {}` would be non exaustive, right?
08:47:18 <kosmikus_> WilliamHamilton[: no, it isn't. empty case is strict in the expression being analyzed
08:48:22 <WilliamHamilton[> kosmikus_: I see, I'll try that as soon as I'm back to code than; thanks for your help!
08:48:22 <kosmikus_> WilliamHamilton[: the effect is that if you really pass this a partial value, then the exception embedded in that value will get triggered, not a "non-exhaustive patterns" exception.
08:48:31 <kosmikus_> you're welcome.
08:58:22 <mgalese> Is there a variation of sendM in freer-simple that allows for evaluation in a monad other than IO?  I have a library-provided monad that carries some state, and I would like to define a freer effect handler in terms of that monad.
08:59:29 <Solonarv> mgalese: sendM isn't specialized to IO
08:59:49 <Solonarv> its type is '(Monad m, LastMember m effs) => m a -> Eff effs a'
09:00:50 <Solonarv> also, it's identical to 'send :: Member eff effs => eff a -> Eff effs a', it just has a less general type
09:04:51 <mgalese> Thanks Solonarv. It's that LastMember constraint that is the issue.  Some code in my stack will want to run in IO and some in the library provided Session monad which wraps IO
09:06:41 <Solonarv> you could just use 'send' and write a function to collapse the 'Session' and 'IO' effects into a single Session effect if you need to
09:06:41 <mgalese> Session is an instance of MonadIO, so that should work, but I can't seem to figure out the interpreter structure that makes the types work out
09:08:52 <adamCS> mgalese: Can you use (sendM . liftIO)  with (MonadIO m, LastMember m effs) to interpret the Session part? 
09:09:47 <Solonarv> you would then have Session instead of IO at the end of your 'effs'; IO wouldn't be in there at all
09:11:10 <adamCS> Solonarv: Yes.  I've done that to wrap the Pandoc Monad for freer-simple.
09:12:12 <Solonarv> another option is to use 'send' for IO, and use 'interpret (send . liftIO) :: Eff (IO : Session : effs) ~> Eff (Session : effs)' as part of your interpreter
09:12:17 <adamCS> mgalese: Also, if you have MonadIO, you don't need the lastMember bit: https://github.com/adamConnerSax/Frames-utils/blob/master/src/Control/Monad/Freer/Random.hs#L48 
09:12:50 <Solonarv> indeed - you don't need 'sendM . liftIO', you can actually just 'liftIO' directly
09:12:55 <Solonarv> very convenient!
09:12:55 <byorgey> Boarders_: Look in Diagrams.TwoD.Image.   (image . embeddedImage) will take a DynamicImage (from JuicyPixels) and turn it into a Diagram.
09:13:22 <Boarders_> byorgey: that is excellent, thank you!
09:13:35 <Boarders_> thanks for writing diagrams, I find it very nice and extremely useful
09:13:51 <byorgey> Boarders_: if you have an Image you can turn it into a DynamicImage by just wrapping it in the appropriate constructor
09:14:00 <byorgey> Boarders_: sure, glad you enjoy it!
09:15:16 <mgalese> Thanks Solonarv adamCS, will try those approaches out!
09:45:07 * hackage stratosphere 0.31.0 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.31.0 (jdreaver)
10:24:08 * hackage cmark 0.5.6.1 - Fast, accurate CommonMark (Markdown) parser and renderer  https://hackage.haskell.org/package/cmark-0.5.6.1 (JohnMacFarlane)
10:39:15 <dumptruckman> Can someone help me interpret this error? https://hastebin.com/vopecudico.coffeescript
10:43:41 <glguy> :t (^^)
10:43:42 <lambdabot> (Integral b, Fractional a) => a -> b -> a
10:43:49 <glguy> :t (**)
10:43:50 <lambdabot> Floating a => a -> a -> a
10:43:57 <glguy> dumptruckman: Use ** in place of ^^
10:44:10 <dumptruckman> oh
10:48:53 <dumptruckman> that function is not producing the expected values...
10:48:59 <dumptruckman> oh wait
10:49:29 <dumptruckman> nevermind
10:54:44 <ais> how does this work https://paste.ubuntu.com/p/rzYwdSzXXT/ ? It seems like this should end up in endless recursion calls.
10:55:20 <ais> how does this work https://paste.ubuntu.com/p/rzYwdSzXXT/ ? It seems like this should end up in endless recursion calls.
10:55:49 <glguy> ais: It works out due to non-strict evaluation order
10:58:18 <ais> so when the lambda is called, what happens with the 'evaluate' call inside?
10:59:52 <glguy> "let act = evaluate tree" this just names the expression 'evaluate tree' as 'act', it doesn't actually start evaluating that expression
11:01:24 <glguy> ais: I would expect there to be some other case missing, however, as there's no base case for the Double to actually be created here
11:01:59 <ais> i got this example from: https://www.schoolofhaskell.com/user/bartosz/basics-of-haskell/12-State-Monad
11:02:05 <ais> trying to figure out how it works
11:05:40 <dmwit> I think glguy's explanation here is misleading.
11:05:58 <dmwit> Because the case you are showing here does in fact always demand the result of the recursive call.
11:06:08 <dmwit> The real answer is that there are other cases to evaluate which don't make a recursive call.
11:06:18 <dmwit> (Not shown here.)
11:06:20 <glguy> That depends on how much result you needed, of course
11:07:04 <glguy> The blog post is incomplete and doesn't show the rest of the definition and the list to the "last tutorial" is broken
11:07:36 <glguy> https://www.schoolofhaskell.com/user/bartosz/basics-of-haskell/10_Error_Handling
11:08:08 * hackage stratosphere 0.32.0 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.32.0 (jdreaver)
11:08:09 <glguy> has the definition of UnaryNode
11:08:25 <dmwit> For example, see the `NumNode` case, which bottoms out the recursion: `evaluate (NumNode x) symTab = Right (x, symTab)` does not call `evaluate` recursively on the RHS.
11:08:52 <EvanR> the algebra of the thing you are evaluating is... a list of + or -, with no end in sight
11:09:01 <dmwit> So the reason it doesn't end in endless recursive calls is that it eventually reaches a part of the expression tree which does not require further recursive calls.
11:09:02 <EvanR> evaluating it doesn't seem possible
11:10:18 <ais> so then the evaluation function is missing other pattern match cases? 
11:10:30 <dmwit> The snippet you pasted is missing other cases, yes.
11:10:41 <EvanR> the data structure Tree is missing cases
11:11:46 <dmwit> EvanR: Have you looked at the definition of Tree? If not, how have you concluded that it's missing cases?
11:12:27 <dmwit> (In fact, even if you have looked at it, how have you concluded that it's missing cases?)
11:12:34 <EvanR> going by data Tree = in the original link
11:12:55 <EvanR> ah at the bottom theres a more complete definition
11:13:28 <dmwit> Ah, I see. Yeah, the 12-State-Monad page has elided some things in a really unfortunate way.
11:13:31 <EvanR> the first half of the blog post has some curiously incomplete stuff
11:14:41 <ais> hm, well i made it this far, so i guess i will just skip the paragraph with this example
11:15:04 <dmwit> The full code from the previous installment of this tutorial may clear things up for you.
11:15:28 <dmwit> It might be worth revisiting it if you had already read the previous installment, or reading it now if you hadn't.
11:15:37 <dmwit> (glguy linked it)
11:16:23 <ais> i had, but evaluate was originally 'evaluate :: Tree -> SymTab -> (Double, SymTab)'
11:19:17 <ais> anyway, thanks for clearing things up a bit
11:37:08 * hackage sgd 0.7.0.0 - Stochastic gradient descent  https://hackage.haskell.org/package/sgd-0.7.0.0 (JakubWaszczuk)
11:37:21 <dumptruckman> is there some way to do a takeWhile and then take 1 more than that?
11:37:31 <dumptruckman> some convenient way*
11:38:50 <glguy> dumptruckman: build that using: span
11:58:39 <dmwit> You may also like `find`.
11:58:41 <dmwit> :t find
11:58:42 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
12:36:08 * hackage topograph 1 - Directed acyclic graphs.  https://hackage.haskell.org/package/topograph-1 (phadej)
12:58:04 <zincy> What is the Constraint kind?
13:04:29 <matheus> It's the kind of things to the left of (=>) in a type. Eq Int :: Constraint, for example
13:08:08 <zincy> Thanks
13:19:37 * hackage sgd 0.7.0.1 - Stochastic gradient descent  https://hackage.haskell.org/package/sgd-0.7.0.1 (JakubWaszczuk)
13:43:33 <reallymemorable> is `==.` a valid symbol?  
13:44:01 <finnkauski> hey, quick questions (which will probably not quick) -> Why is it important to understand the difference between sum and product datatypes and in general things like Algebraic Datatypes?
13:44:27 <reallymemorable> finnkauski: arent they totally different?
13:44:48 <zincy> :t (==) .
13:44:50 <lambdabot> error:
13:44:50 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
13:45:02 <zincy> :t (.) (==)
13:45:02 <Rembane> You can express one type in terms of the other if you really want to.
13:45:03 <lambdabot> Eq a1 => (a2 -> a1) -> a2 -> a1 -> Bool
13:45:15 <finnkauski> Yeah, i am aware. 
13:45:36 <finnkauski> You can shift the two round 
13:45:53 <zincy> finnkauski: Do you know what cardinality is?
13:45:58 <finnkauski> yep 
13:46:07 <finnkauski> am aware now that I'm reading the chapter 
13:46:07 <Rembane> finnkauski: IMO it's good to know what they are and what names they have, and that's about it.
13:46:28 <tdammers> IMO it's not so much the difference between the two that you need to understand, the main beef is understanding that algebraic data types are a useful and fundamental formalization of some aspects of types and type systems
13:46:28 <finnkauski> but do you think about things like cardinality when you code zincy?
13:46:40 <zincy> finnkauski: Nope
13:46:59 <zincy> finnkauski: I think about it when I try and understand what is going on at the type level.
13:47:05 <finnkauski> So you'd say put it in a good to know bin for now. 
13:47:09 <zincy> Say if I am learning a new concept.
13:47:19 <finnkauski> ok. fair 
13:47:37 <zincy> Are you aware of the data constructor  and type constructor distinction?
13:47:51 <finnkauski> i feel like that will come with time for me, but atm i'll read the chapter and won't lose any sleep over not being ultimately familiar with them to the nitty gritty detail 
13:47:57 <finnkauski> yep 
13:48:12 <finnkauski> this haskell-book is great to be fair and it drilled it into my brain 
13:48:14 <zincy> finnkauski: Yes don't lose sleep - revisit it later
13:48:38 <zincy> I find that I peel layers of understanding by revisiting concepts time and time again
13:48:53 <zincy> Ok so that distinction is crucial. 
13:49:03 <finnkauski> honstly, is it just me or the learnyouahaskell is just aimed at small attention span indivduals?
13:49:17 <finnkauski> i found it liek just throws things at you, really not giving me a good grasp of what the hell i'm typing 
13:49:41 <finnkauski> (which is suprising that I didn't internalise stuff it showed me coz my attention span is abysmal >.>)
13:50:01 <zincy> lyah is a weird book
13:50:07 <zincy> I would say its a taster
13:50:14 <finnkauski> zincy: also thanks for that though
13:50:39 <zincy> What do you feel you don't understand well yet?
13:50:49 <finnkauski> i'd agree. i think it works for people who are curious about haskell or FP and just wanna have a go. its like a drug dealer luring you in haha 
13:51:15 <dmwit> ADTs + pattern matching is fantastic.
13:51:26 <dmwit> Once you get used to them you're going to wonder how you ever got along in languages that don't have them.
13:51:38 <zincy> dmwit: Yes!
13:51:42 <finnkauski> well i mean Im only 693/1956 in this "Haskell Programming from First Principles" book. 
13:52:04 <zincy> Well done that is good going
13:52:08 <dmwit> So I want to register my strong opposition to the "you don't need to understand sum and product types" vibe that I'm seeing here.
13:52:16 <finnkauski> i've gotten through like 300 pages last weekend 
13:52:32 <zincy> ^ listen to him
13:52:33 <tdammers> I didn't say you don't need to understand them
13:52:34 <zincy> or her
13:52:41 <tdammers> you do
13:53:02 <tdammers> I was just trying to say that it's not as massive a concept to understand as it may seem
13:53:04 * dmwit points no fingers
13:53:09 <finnkauski> Im sort of dreading Monads. And don't get me wrong I don't think they are magic. I watched the amazing Philip Wadler talk on them (insane guy, fair play)
13:53:20 <finnkauski> he did in scala so i was coding along in haskell. 
13:53:33 <finnkauski> but still, its that little incling, that they Just Don't Click. 
13:53:45 <zincy> finnkauski: UK?
13:53:48 <Rembane> Code using them. Read the types. 
13:53:56 <finnkauski> zincy:  live in the UK yes 
13:54:13 <finnkauski> Rembane: I mean they aren't any different conceptually from a list in my brain 
13:54:16 <tdammers> don't dread monads
13:54:35 <tdammers> mistake #1: trying to understand Monad before typeclasses, and Functor in particular
13:54:39 <finnkauski> https://www.youtube.com/watch?v=yjmKMhJOJos&t=2007s
13:54:40 <zincy> Monads have a bad rep because they rely on a knowledge of a few different concepts in Haskell and brings them together.
13:54:42 <Rembane> finnkauski: They are in real life, but not by much. :)
13:54:43 <finnkauski> this one was super useful 
13:54:47 <tdammers> mistake #2: reading monad tutorials. I mean it, don't.
13:55:02 <finnkauski> the wadler one was sort of mocking the whole buritto thing 
13:55:17 <finnkauski> the link i linked was one of the best things to be fair. 
13:55:26 <tdammers> @where what
13:55:26 <lambdabot> I know nothing about what.
13:55:30 <tdammers> hmm
13:55:32 <tdammers> @where hask
13:55:32 <lambdabot> I know nothing about hask.
13:55:54 <finnkauski> and also tdammers, completely agree, I sort of understand functors and applicatives as well as monads, at least i've memorised the type signatures 
13:56:04 <tdammers> http://dev.stephendiehl.com/hask/#monad-tutorials this is basically it
13:56:17 <zincy> Am I correct in saying that the general abstraction of Monads is to sequence computations?
13:56:19 <tdammers> http://dev.stephendiehl.com/hask/#eightfold-path-to-monad-satori this, rather
13:56:24 <tdammers> zincy: no.
13:56:33 <zincy> oh what is it then?
13:56:40 <tdammers> bind and return
13:56:57 <zincy> Is that a general abstraction?
13:57:06 <tdammers> as it turns out, yes
13:57:07 <zincy> I am talking across languages in a very general sense
13:57:07 <finnkauski> as far as I understand Monad is a type that just implements bind and return 
13:57:27 <tdammers> finnkauski: yes, pretty much. that, plus the Monad laws.
13:57:31 <finnkauski> and the way you use it for computation is that you create a monad that does some sideeffect stuff 
13:57:44 <finnkauski> tdammers: associativity of the stuff etc etc 
13:58:00 <ddellacosta> I am a fan of this thread, I like how people are being nice and helping this person, and they are succeeding, apparently: https://www.reddit.com/r/haskell/comments/ayyq3a/installed_haskell_i_think_now_how_do_i_open_it/
13:58:07 <tdammers> no, not side effects. not even effects. the effects are entirely orthogonal, you can represent effects without Monad, and you have Monads without effects
13:58:34 <finnkauski> tdammers: yes a list is monadic. 
13:58:36 <zincy> tdammers: Why not sequencing computations :P
13:59:11 <finnkauski> tdammers: I sort of meant wether a monad is a computation of some kind will depend on its implementation rather than the word 'Monad' implying its side effect heavy 
13:59:12 <tdammers> zincy: because not all Monad instances imply sequencing. not in a meaningful sense anyway
13:59:35 <zincy> Bind seems to?
13:59:44 <tdammers> zincy: however, a certain notion of "dependency" is what sets Monad apart from Applicative
13:59:50 <finnkauski> only if monads its binding are actions right zincy ?
14:00:08 <c_wraith> well, there is an implied sequencing, but there's no reason that sequence had to match evaluation order.
14:00:09 <tdammers> so in that sense, yes, "sequencing" is part of the abstraction, in a very generous sense
14:00:10 <sternmull> i think bind can ignore the input from the first argument, which allows non-sequential evaluation
14:00:27 <dmwit> No, it can't do that.
14:00:45 <c_wraith> I mean, look at []. it's evaluation order is all over the place.
14:00:47 <dmwit> You must have `return x >>= f = f`, which guarantees that `(>>=)` does not ignore its first input.
14:00:50 <sternmull> oh, then how can it be non-sequential?
14:00:56 <c_wraith> *its
14:00:58 <dmwit> Sorry, `return x >>= f = f x`.
14:01:20 <dmwit> (*except* for the trivial monad, Proxy)
14:01:37 <Rembane> What about ContT?
14:01:42 <Rembane> Can it do non-sequential stuff?
14:01:54 * Rembane knows all the right words
14:02:23 <Logio> I would prefer "fancy composition" instead of sequencing
14:02:24 <tdammers> IO can do non-sequential stuff, but that's a bit of a red herring
14:02:29 <c_wraith> Rembane, the important question is whether >>= does non-sequential stuff.
14:02:31 <finnkauski> One of the coolest things that helped me 'get it' a bit better was restating `Monad m => m b -> (b -> m c) -> m c` as `\a -> M b >>= \b -> M c`
14:02:34 <Rembane> c_wraith: Aha! Got it. 
14:02:50 <finnkauski> that example sort of restored the symmetry and showcased the composition aspect of it 
14:03:03 <Rembane> I want the counterexample monad.
14:03:23 <c_wraith> but, like...
14:04:10 <c_wraith> > [1..] >>= \x -> [x, x+1]
14:04:12 <lambdabot>  [1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16...
14:04:28 <tdammers> :t (>=>)
14:04:29 <c_wraith> obviously the evaluation order is all over the place.
14:04:29 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
14:04:53 <tdammers> ^ finnkauski I think this is what you're after, it's called Kleisli composition
14:05:11 <finnkauski> tdammers: the fish thing yeah 
14:05:34 <tdammers> oh cool, I'm not the only one who reads >=> as "fish"
14:05:38 <finnkauski> i wasn't per say after it, but I am enjoying all this stuff 
14:06:01 <finnkauski> coz my buddy does that when he preaches haskel; 
14:06:13 <tdammers> anyway, Kleisli composition is an alternative way of defining Monad, and if you write the Monad Laws in terms of >=> rather than >>=, they make a lot more sense
14:06:28 <tdammers> so that may be enlightening
14:06:49 <finnkauski> i need to add a todo for that, thanks
14:07:04 <c_wraith> I think (<=<) is the better approach, just for how its type lines up with (.) 
14:07:43 <finnkauski> @type (<=<)
14:07:44 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
14:08:02 <finnkauski> i see 
14:08:06 <finnkauski> yes
14:08:25 <finnkauski> well, again. This stuff I'm slowly internalising. 
14:08:30 <c_wraith> and in the same way, return is roughly id
14:08:33 <finnkauski> BUT, im waiting for the lightbulb moment 
14:08:41 <c_wraith> and congratulations, Kleisli categories.
14:09:13 <finnkauski> I'm not scared easily, but I can see why people say you need a PHD in maths to get haskell 
14:09:28 <finnkauski> (obviously harmful for the language)
14:09:30 <c_wraith> pfft. I have no math degree at all!
14:09:47 <sternmull> i still don't get it. You say bind guarantees evaluation order but does not guarantee sequential evaluation?
14:09:49 <finnkauski> yeah, and I mean, I'm keen enough to learn and It'll click at some point 
14:10:14 <c_wraith> (on the other hand, I have math tattoos, so it's not like I don't like math...)
14:10:54 <finnkauski> c_wraith: a great book to get people into maths as pop science thing is Alexes adventures in numberland btw. Oh and what got me originally into appreciating maths was Journey through Genius 
14:10:57 <zincy> finnkauski: You really dont
14:10:59 <c_wraith> sternmull, bind creates a dependency, but that dependency doesn't imply evaluation order.
14:11:15 <finnkauski> zincy: don't worry. I feel like its all a bit overblown. 
14:11:35 <zincy> Yep
14:11:35 <c_wraith> sternmull, at least, not in its entirety. it just provides some constraints on it.
14:12:22 <zincy> finnkauski: Have you written any largish projects yet?
14:12:26 <finnkauski> zincy: my first language was python. when i started i couldn't differentiate method from function. 
14:12:36 <sternmull> c_wraith: I don't get it how it can avoid sequential evaluation in presence of the dependency.
14:12:45 <finnkauski> zincy: it took ages until it clicked. and my next thing for python is to get a good grasp of the data model 
14:12:47 <tdammers> sternmull: non-strict evaluation
14:12:57 <c_wraith> sternmull, did you see my example above?
14:13:12 <finnkauski> zincy: also not really. I had basically a project that parses my whatsapp messages exported fromwhatsapp. and i redid it in haskell very cruedly. 
14:13:26 <finnkauski> zincy: so the answer is no. I'm doing it for fun at home. 
14:13:38 <zincy> When you create a decent project in Haskell the pieces will fall into place
14:13:45 <zincy> The compiler is a teacher.
14:13:56 <tdammers> might actually take two or three decent projects, but yeah, that's the best way to learn
14:14:09 <sternmull> c_wraith: You mean the list?
14:14:21 <finnkauski> do you find that letting the compiler infer a type than you assessing it and setting the type yourself is a good practice?
14:14:25 <__monty__> finnkauski: This is my favorite explanation of monads (since you mentioned the composition aspect): https://youtu.be/ZhuHCtR3xq8
14:14:43 <finnkauski> __monty__: I watched all of it 
14:14:48 <tdammers> start building stuff with what you understand so far, keep reading about stuff you don't understand, and sooner or later you will run into the problems that those things you don't understand solve, and when your brain goes "click", matching one of the solutions to its problem, you'll have made some progress
14:14:53 <__monty__> Oh.
14:14:56 <finnkauski> __monty__: I think the explanation of monoids as a watch face was great 
14:15:22 <zincy> I built stuff and asked here when stuck. 
14:15:47 <tdammers> I prefer the explanation of monoids where you implement a bunch of monoidal types and their monoid operations, and then discover the common pattern between them
14:16:02 <finnkauski> tdammers: yes! that has happened. I was basically extracting values from IO running functions on them and returning IO in the most awkward way. Like Raymon Hettinger says: THERE MUST BE A BETTER WAY 
14:16:12 <tdammers> yes
14:16:15 <zincy> I tried to write the type declaration myself and then get the compiler to check it is correct.
14:16:19 <c_wraith> sternmull, yes. evaluation bounces around in a sort of depth-first traversal of the elements of each list
14:16:19 <tdammers> a.k.a. the "Problem-Solution Ordering"
14:16:44 <finnkauski> https://github.com/finnkauski/whaskupp thats the only thing i've built. 
14:16:47 <finnkauski> so far. 
14:17:02 <finnkauski> I struggled for a project to do when I was lyah 
14:17:09 <finnkauski> reading lyah*
14:17:29 <finnkauski> but lyah really was not great, so i splashed out for the haskel from first principles. 
14:17:39 <sternmull> c_wraith: Is your point that the evaluation of the list elements can be delayed while thunks for the next result elements are produced?
14:17:54 <finnkauski> and the only project for that is at the end. so i feel i need to go through it, write stuff in haskell, then go through it again 
14:18:04 <tdammers> lyah is probably not the best book out there
14:18:23 <zincy> Good project is a web server.
14:18:35 <zincy> Covers a lot of ground.
14:18:42 <finnkauski> no idea about anything web related. completely disconnected from my background. BUT 
14:18:45 <c_wraith> sternmull, more broadly - that evaluation order need not match dependency order when laziness comes into play.
14:18:45 <finnkauski> i heard that a few times. 
14:18:51 <finnkauski> So i'll do it zincy 
14:19:02 <tdammers> web might be a bit too harsh if you haven't done it before in a language you were more comfortable with
14:19:10 <tdammers> but maybe implementing a lisp interpreter could work
14:19:12 <tdammers> @where scheme
14:19:12 <lambdabot> https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
14:19:15 <zincy> My second project was a poker site with authentication, postgres and websockets etc
14:19:28 <finnkauski> we need to go simpler here folks.
14:19:35 <finnkauski> i work with data. 
14:19:40 <zincy> Note I said second :)
14:19:42 <finnkauski> if that helps spitball ideas 
14:19:55 <sternmull> c_wraith: Ok, thanks. I think i understand what you mean.
14:20:17 <tdammers> fwiw, my first project was a music notation thing, similar to lilypond
14:21:04 <zincy> It is hard to find a non-trivial project which doesnt cover a lot of conceptual ground in Haskell.
14:21:41 <finnkauski> under pressure of my coworker that does haskell we built a python libarary that basically is a meta api for a lot of Natural LAnguage processing tasks. So you can compose a parser with any sort of text embeding model with anything else. So we basically wrote a ton of wrappers for different libarary methods in a functional way in python 
14:22:28 <zincy> You are gonna have fun going back to python after Haskell
14:22:49 <zincy> Might scare said coworker though
14:22:52 <finnkauski> zincy: mate my god. My code atm in python is completely unpythonic 
14:23:08 <zincy> Lots of Haskellers like clever code. (So its called)
14:23:41 <finnkauski> i basically reduced 20 lines of someones code into a anonymous function mapped over a list of values and a reduce 
14:23:44 <zincy> Unpythonic Python :)
14:24:00 <finnkauski> functional programming in python is an afterthought 
14:24:32 <finnkauski> toolz is a good python library, bringing a lot of the really useful tools, basically a whole suite of functional programing tools in one. 
14:24:47 <finnkauski> don't leave home without it if they let me use external dependencies. 
14:24:50 <zincy> Over a year in Haskell and your brain is changed forever.
14:25:01 <zincy> ;)
14:25:03 <finnkauski> I came up with an analogy for that. 
14:25:10 <zincy> 5 years who knows
14:25:33 <finnkauski> incomprehensible jibberesh while wheeling a shopping trolly and swearing about types at people 
14:25:44 <finnkauski> and throwing maths books at peopel 
14:27:14 <finnkauski> learning haskell so far: 
14:27:29 <finnkauski> First, the caterpillar digests itself, releasing enzymes to dissolve all of its tissues. If you were to cut open a cocoon or chrysalis at just the right time, caterpillar soup would ooze out. But the contents of the pupa are not entirely an amorphous mess. 
14:27:35 <finnkauski> And then it rebuilds itself. 
14:27:41 <finnkauski> :D 
14:28:07 <zincy> :)
14:28:21 <finnkauski> funny, wikipedia notes that butterflies are polymorphic 
14:28:30 <finnkauski> maybe they should have used that as a spirit animal for haskell 
14:28:39 <zincy> I like it
14:28:54 <finnkauski> who do i send an email to ? 
14:28:57 <finnkauski> heh
14:29:14 <zincy> finnkauski: What is the cardinality of Maybe Bool?
14:29:29 <zincy> Fun exercise
14:29:34 <finnkauski> 3 ?
14:29:51 <zincy> Yep
14:29:53 <finnkauski> [Nothing, Just True, Just False]
14:30:06 <zincy> now Maybe (Maybe Bool)
14:30:15 <finnkauski> zincy: what is the cardinality of String ?
14:30:40 <finnkauski> uff 
14:30:49 <zincy> Ok so
14:31:01 <finnkauski> product type my first instinct was 3 * 2 
14:31:55 <finnkauski> 4 
14:32:45 <finnkauski> [Nothing, Just Nothing, Just Just True, Just Just False]
14:34:44 <zincy> Whats the type of Just Nothing?
14:35:37 <finnkauski> Maybe (Maybe Bool)
14:35:42 <finnkauski> in that case. 
14:36:03 <zincy> Good
14:36:07 <finnkauski> So its fully evaluated. 
14:36:37 <finnkauski> aka cant remember the term of a Type construtor that isn't * -> * 
14:37:05 <finnkauski> Concrete? 
14:37:21 <zincy> Yes but it may be a contentious point
14:37:21 <geekosaur> some use it that way but there's not a lot of consistency
14:37:47 <finnkauski> i c 
14:37:54 <geekosaur> "value type" or "inhabited type" might be better if you mean kind * (or, these days, Type)
14:38:10 <finnkauski> value type. 
14:38:18 <finnkauski> and the * -> * 
14:38:29 <finnkauski> (i just read the chapter, perhaps the brain said, i don't need this term for now )
14:39:51 <zincy> Its the type of types where you give a "value type" and get back another "value type"
14:40:01 <zincy> finnkauski: What is the type of Nothing?
14:40:13 <finnkauski> Maybe a 
14:40:19 <finnkauski> suppose. 
14:40:25 <zincy> Correct
14:40:59 <zincy> So it can't be a type of (Maybe (Maybe Bool)) right?
14:41:04 <zincy> Sorry a value of 
14:41:58 <finnkauski> hmm 
14:42:14 <finnkauski> Nothing can be of that type. 
14:42:20 <finnkauski> wait. 
14:42:47 <finnkauski> i guess if you function expects to return Maybe (Maybe Bool) it could still return Nothing 
14:42:55 <finnkauski> ?
14:43:18 <LKoen> Nothing or Some Nothing or Some True or Some False
14:43:25 <LKoen> err
14:43:31 <LKoen> Some Some True or Some Some False
14:44:16 <finnkauski> No i see what you're saying zincy 
14:45:18 <finnkauski> but i think fn :: Maybe (Maybe Bool); fn = Nothing would compile. 
14:45:30 <zincy> Try it?
14:45:37 <finnkauski> it does. 
14:46:08 <finnkauski> i think its coz the type a with respect to nothing is called `phantom`?
14:46:38 <zincy> (Nothing :: Maybe (Maybe Bool)) Does compile
14:46:53 <finnkauski> (much nicer way of doing it there)
14:47:25 <finnkauski> I think the book used the word phantom value for `darta MyMaybe a = Nothing`
14:47:31 <zincy> I am confused about how a data constructor can be in multiple different types?
14:47:36 <finnkauski> meaning a is never validated for what it is 
14:50:32 <finnkauski> are you confused? 
14:50:37 <finnkauski> coz i sure am
14:50:46 <zincy> yep
14:50:57 <finnkauski> but more at your confusion about it 
14:50:59 <finnkauski> :D 
14:51:37 <zincy> I don't understand how a single nullary data constructor can inhabit multiple types.
14:51:47 <finnkauski> it only inhabits maybe.  
14:51:52 <finnkauski> right?
14:51:56 <Amras> has anyone here had success configuring haskell-ide-engine with vim recently?
14:52:02 <Lears> `Nothing :: forall a. Maybe a` just has the same kind of polymorphism as, say, `id :: forall a. a -> a`.
14:52:16 <finnkauski> But because maybe is polymorphic in its first argument 
14:52:31 <Lears> It doesn't need to know anything about the chosen `a`, so it's not restricted by it.
14:53:14 <finnkauski> In the same way if I had a type `data Sneaky a = Where` where would inhabit sneaky regardless of the type of A 
14:53:16 <travv0> % :t (>=>)
14:53:17 <yahb> travv0: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
14:53:39 <zincy> Ah right
14:53:57 <zincy> Would that still be the case without the forall a ?
14:54:30 <Lears> The `forall`s are always there, secretly, they're just left implict.
14:55:19 <finnkauski> heres a common type 
14:55:19 <finnkauski> that might help you 
14:55:19 <finnkauski> data [] a = [] | a : [a]
14:55:19 <finnkauski> :D 
14:55:29 <zincy> :D
14:55:33 <finnkauski> [] is agnostic of the a 
14:55:41 <zincy> Good example.
14:56:06 <finnkauski> I think the term for the thing is phantom constructor 
14:56:14 <finnkauski> ok, coffee shop is closing. 
14:56:36 <finnkauski> gotta bounce. thanks for the good convo. Love this channel so far. :thumbsup"
14:56:42 <zincy> see you
14:59:19 <zincy> So Bool has cardinality 2 and Maybe a has cardinality 1 + a. Am I right in saying the cardinality of 100 nested Maybe Bools would be 103? 
14:59:43 <zincy> Actually 102
15:01:41 <slack1256> yep
15:01:54 <slack1256> excluding bottoms though
15:05:16 <siers> cocreature, hm, I'm not sure that "traverse (print <=< waitCatch)" works
15:06:12 <slack1256> pattern LitUD a <- LitX _ a where LitUD a = LitX void a
15:06:30 <slack1256> correct me if I am wrong, is the `where` there to make the pattern bidirectional?
15:13:10 <siers> cocreature, do { x <- async (error "test"); y <- async (threadDelay 1000000); traverse (print <=< waitCatch) [y,x] }
15:15:41 <zincy> What is the difference between open and closed type families?
15:17:35 <slack1256> closed type families have all the equations they will satisfy on a single place and you can't add to them from another place.
15:17:40 <hpc> "open" means it can be extended by things you don't know about, "closed" means it can't
15:17:40 <hpc> data types are closed, type classes are open
15:17:40 <hpc> for instance
15:18:08 <slack1256> open type families you can add equations from other places
15:18:39 <zincy> Ok so it refers to 'extendability'
15:22:35 <zincy> So type families rely on the promotion of data constructors to types using DataKinds?
15:23:12 <zincy> So its is a family in the sense that we are mapping multiple types to a new type
15:23:14 <zincy> ?
16:02:48 <nfd> aight, back at it again for another hour or whatever
16:04:10 <nfd> so i've got a package here that isn't on hackage/stackage that I'd like to use
16:04:41 <nfd> seeing as it hasn't been updated in 4 years, I figured the easiest way to deal with it would just to be to roll it directly into my Stack project (it's freely licensed)
16:06:26 <nfd> so i've plopped it into a subdir of my project, tried to add its dependencies to my global stack.yaml, and point to that directory as a package
16:07:45 <nfd> that alone isn't doing it, though: the build fails because it can't find the Network package that I think I should have at this point
16:21:34 <sm> Network or network ?
16:38:35 <delYsid> nfd: You can also point extra-deps at a github repo.
16:39:08 <delYsid> For instance
16:39:09 <delYsid> extra-deps:
16:39:09 <delYsid> - github: judah/haskeline
16:39:09 <delYsid>   commit: master
16:40:29 <Solonarv> (although you probably shouldn't point at 'master', and instead point at a specific commit0
16:40:50 <delYsid> yeah, agreed.
16:48:18 <delYsid> I wish GHCi would make the externalPrint function from haskeline available, it makes for pretty nice background job output.  I currently wrote my own little uGHCi to play with that, but I'd rather just use stock GHCi and not duplicate things like completion...
16:49:04 <delYsid> https://github.com/mlang/mcp
16:49:10 <nfd> sm: network is the dep in the library's cabal file, it's trying to import Network
16:50:04 <nfd> delYsid: i'm probably gonna tweak the library a little anyway, so ¬Ø\_(„ÉÑ)_/¬Ø
16:50:22 <nfd> get a working config together and make it all pretty later
17:04:24 <nfd> could there be some Stack or Cabal bug keeping it from finding network?
17:09:30 <nfd> oh, I see, it's actually broken because the APIs it picked for Network were removed
17:09:31 <nfd> Fun
17:09:42 <nfd> Guess I'll actually go fork this thing and fix it then
17:13:08 * hackage typesafe-precure 0.7.3.1 - Type-safe transformations and purifications of PreCures (Japanese Battle Heroine)  https://hackage.haskell.org/package/typesafe-precure-0.7.3.1 (igrep)
17:52:21 <slack1256> How many of you are using glirc2/irc-core?
18:37:52 <novum> how would you compute all of the disjunctive normal forms for a 3-var proposition. eg (1+1+1), (1+1+1)*(1+1+0), (1+1+1)*(1+0+1), ... for all permutations
18:38:07 <novum> + is disjunction and * is conjunction
18:44:43 <slack1256> list comprehensions
18:46:12 <slack1256> > [ ((a,b,c), a && b && c) | a <- [True, False], b <- [True, False], c <- [True, False] ]
18:46:13 <lambdabot>  [((True,True,True),True),((True,True,False),False),((True,False,True),False)...
18:46:26 <slack1256> > [ (a && b && c) | a <- [True, False], b <- [True, False], c <- [True, False] ]
18:46:28 <lambdabot>  [True,False,False,False,False,False,False,False]
18:46:38 <slack1256> > [ (a || b || c) | a <- [True, False], b <- [True, False], c <- [True, False] ]
18:46:39 <lambdabot>  [True,True,True,True,True,True,True,False]
18:47:07 <novum> eh ... no it's either 3^8 or 8^3 which is a lot of values
18:47:16 <novum> trying to figure out which one
18:47:32 <novum> maybe the first one ..
18:47:34 <slack1256> you can adapt it
18:47:53 <novum> I am aware of how haskell works. I am not sure how to logically implement it
18:48:09 <slack1256> the point is you use list comprehension to generate the cases and operate on each case individually
18:48:22 <novum> the first one has length of eight. the others are shorter
21:34:38 * hackage miv 0.3.0 - Manage Vim plugins with command  https://hackage.haskell.org/package/miv-0.3.0 (itchyny)
22:00:34 <mjrosenb> so, I have a function which uses do notation in the [] monad, and now I need to add state to it.
22:01:04 <mjrosenb> but the type of runStateT doesn't look right to me.
22:07:34 <adamCS> mjrosenb: why?  
22:09:29 <mjrosenb> so, if I have foo :: StateT state [] a, and runStateT :: s -> m (a, s), then I'm going to get back a list of states,
22:09:47 <mjrosenb> I want s -> (m a, s)
22:11:35 <slack1256> @unmtl ListT (State s) a
22:11:36 <lambdabot> s -> ([] a, s)
22:12:10 <adamCS> Yeah.  It's late and I am thinking slowly.  But reversing the order makes sense...
22:12:40 <mjrosenb> now, I get to decide transformer or mtl
22:14:11 <maerwald> mtl
23:20:22 <cocreature> siers: oh right, try mapConcurrently instead of traverse
