01:05:18 <Ariakenom> can I check version from inside ghci?
01:10:47 <Ariakenom> oh it does print it at top
01:59:00 <delYsid> How do I pass mutliple RTS options to GHC in my cabal file?
02:00:21 <phadej> "--ghc-options=+RTS .... -RTS"
02:00:30 <phadej> ah, cabal file
02:00:37 <phadej> ghc-options: +RTS ... -RTS should just work?
02:01:46 <delYsid> Sorry, not to GHC, but as default to the compiled executable.
02:02:01 <delYsid> I know about -with-rtsopts=, but I cant get it to take more then just one
02:02:28 <delYsid> must be some sort of quoting issue I dont understand
02:03:28 <phadej> ghc-options: "-with-rtsopts=-M1G -s"
02:03:46 <phadej> you have to quote whole token
02:04:11 <phadej> i.e. -with-rtsopts="-M1G -s" won't work
02:04:23 <delYsid> ah
02:05:04 <delYsid> ghc: unrecognised flag: -s
02:05:05 <delYsid> nope
02:05:14 <delYsid> I want to pass -N and -s
02:06:41 <phadej> I see
02:06:43 <phadej> ... -Wall '-with-rtsopts=-M1G -s'  ...
02:07:11 <phadej> when I run cabal v2-build -v 
02:07:49 <delYsid> ghc: unrecognised flag: -s'
02:08:04 <delYsid> damn
02:08:13 <delYsid> this stuff is broken
02:08:19 <delYsid> (using package.yaml)
02:08:51 <MarcelineVQ> use multiple - -with-rtsopts=foo one opt per entry
02:09:05 <phadej> in package.yaml you probably need to double escpate it
02:09:16 <phadej> so the generated .cabal file has the quotes too
02:09:18 <delYsid> MarcelineVQ: Tried that, but then only the last one is in effect.
02:09:32 <phadej> ghc-options: "somestring"
02:09:34 <phadej> is the same as
02:09:37 <phadej> ghc-options: somestring
02:09:38 <phadej> in yaml
02:09:41 <phadej> so yaml: sucks
02:10:00 <phadej> maybe it will work, if you do
02:10:17 <phadej> ghc-options: -Wall "-with-rtsopts=-M1G -s"
02:10:22 <delYsid> My cabal file now has ghc-options: -Wall -O2 -threaded -rtsopts '-with-rtsopts=-N -s'  but it still doesnt work
02:10:40 <phadej> quotes
02:10:43 <phadej> double
02:10:44 <phadej> not single
02:10:59 <MarcelineVQ> phadej: afaik this multiple arguments to -with-rts-opts is a cabal issue, it has come up recently
02:11:03 <delYsid> ahhh!
02:11:05 <delYsid> now I got it
02:11:19 <phadej> just don't use package.yaml
02:11:23 <delYsid> I need to double-quote
02:11:24 <phadej> you fight YAML now
02:12:04 <delYsid> phadej: Nope, wasn't a yaml problem.
02:12:31 <delYsid> ghc-options: -Wall -O2 -threaded -rtsopts "-with-rtsopts=-N -s"
02:12:34 <delYsid> works
02:12:49 <delYsid> and package.yaml and .cabal contain the same thing, so there is no wrapping problem
02:13:23 <phadej> delYsid: but if you remove the 4 first options, it will break
02:13:27 <phadej> it's a quirk
02:14:01 <delYsid> 1,203,431,585,328 bytes allocated in the heap
02:14:02 <delYsid> fun
02:52:37 * hackage failable 1.2.0.1 - A 'Failable' error monad class to unify failure across monads that can fail  https://hackage.haskell.org/package/failable-1.2.0.1 (erick)
02:53:03 <dminuoso> Huh. Isnt that MonadFail?
02:57:10 <MarcelineVQ> dminuoso: check the readme :>
02:57:48 <dminuoso> Ah so MonadCatch! I see.
03:14:45 <royal_screwup21> so  I'm looking the applicative instane for Parser here http://dev.stephendiehl.com/fun/002_parsers.html Is the "f" in <*> method a functor, or a function? :(
03:14:49 <royal_screwup21> instance*
03:15:40 <dminuoso> royal_screwup21: Do a mechanical substitution
03:16:08 <dminuoso> royal_screwup21: If you replaced that f with `Maybe` or `Int`, is it in the right universe?
03:17:36 <royal_screwup21> dmiles: so if we replace it with Maybe, then the first parser parses and returns (Maybe, string) -- that doesn't quite look right...
03:17:55 <royal_screwup21> referring to this line: (f, s1) <- cs1 s
03:18:32 <dminuoso> royal_screwup21: If you replaced that f with say (+), would it be in the right universe?
03:18:51 <dminuoso> (Whether its actually correct is not my point)
03:20:06 <royal_screwup21> hmm...I'm not totally sure, thinking
03:20:15 <dminuoso> royal_screwup21: So the word Functor refers to type constructors, all of which have kind (* -> *). `[]` is a Functor. `Maybe` is a Functor. `IO` is a Functor.
03:20:25 <dminuoso> Well, to some of them anyway.
03:20:54 <dminuoso> so functors are a type level construct.
03:21:19 <royal_screwup21> I mean yeah, so if functors have kind * -> *, then simply (f, s) doesn't make sense I guess...it needs to take an argument
03:21:24 <dminuoso> royal_screwup21: No.
03:21:30 <dminuoso> royal_screwup21: DIfferent universes.
03:21:39 <dminuoso> royal_screwup21: Do you understand between `1` and `Int`?
03:21:49 <dminuoso> Would `(Int, 5)` make sense?
03:22:28 <royal_screwup21> nope...the first element refers to the things parsed, so (1, 5) would make more sense
03:22:32 <royal_screwup21> thing*
03:22:48 <dminuoso> royal_screwup21: Ignore your parser for a moment. Values and types live in different universes.
03:22:56 <royal_screwup21> ah okay
03:23:08 <royal_screwup21> but it needs to be value
03:23:11 <dminuoso> There's a universe of values. In this universe you have functions and non-functions.
03:23:15 <dminuoso> (+) is a value
03:23:18 <dminuoso> 1 is a value
03:23:22 <dminuoso> (Just 3) is a value
03:24:01 <dminuoso> royal_screwup21: The important part here, is that functions too are just values.
03:24:23 <royal_screwup21> yup...I think I'm starting to see that the 'f" there is a function then
03:25:00 <royal_screwup21> so, the parser, cs1, is parameterized on a function...
03:25:04 <dminuoso> royal_screwup21: So now we leave the universe and enter the next plane. This is the universe of types.
03:25:14 <royal_screwup21> ah okay, following
03:25:18 <dminuoso> In this universe we have `Int`, `Maybe`, `Maybe Int`
03:25:46 <dminuoso> All these things exist in the type universe.
03:26:26 <royal_screwup21> yup...
03:26:28 <dminuoso> Maybe is a type constructor. We also have type-level functions (where you can put a type in and it computes a new type in a sense) through an extension. Its not relevant you know more about this, just know that the type level is its own universe.
03:26:55 <dminuoso> type constructors are also kind of type functions, except they take 0 or more arguments and construct a brand new type.
03:27:39 <royal_screwup21> wait, Maybe is a type constructor? I thought Nothing and Just were type constructors, for data Maybe x = Nothing | Just x
03:27:48 <dminuoso> royal_screwup21: Nothing and Just are data constructors.
03:27:52 <dminuoso> Maybe is a type constructor.
03:27:53 <royal_screwup21> oh okay
03:28:01 <dminuoso> Nothing and Just belong to the value universe.
03:28:08 <dminuoso> In the type universe we have `Maybe`
03:28:38 <royal_screwup21> yup...
03:29:22 <royal_screwup21> so I'm certain the "f" there is a value...it can't be a type constructor then.
03:29:35 <dminuoso> royal_screwup21: Now. Functor is the name of a particular set of type constructors, all of which must be unary (that is they all take one argument) and they must satisfy some laws.
03:30:24 <dminuoso> Functor just refers to that group of things. Saying that `Maybe is a Functor` means that `Maybe` belongs to that set of special type constructors.
03:30:37 <royal_screwup21> yup okay...
03:30:37 * hackage antiope-athena 7.0.0 - Please see the README on Github at <https://github.com/arbor/antiope#readme>  https://hackage.haskell.org/package/antiope-athena-7.0.0 (alexeyraga)
03:31:16 <dminuoso> royal_screwup21: If we leave this universe we are in right now and go to the next, we end up in the kind universe by the way.
03:31:28 <dminuoso> Where you have `*`, `* -> *`,  etc..
03:31:37 * hackage antiope-contract 7.0.0 - Please see the README on Github at <https://github.com/arbor/antiope#readme>  https://hackage.haskell.org/package/antiope-contract-7.0.0 (alexeyraga)
03:31:37 <royal_screwup21> ok, so values  -> types -> kinds...
03:31:41 <dminuoso> Exactly.
03:32:03 <Uniaika> yep
03:32:34 <dminuoso> royal_screwup21: values have types, types have kinds.
03:32:37 * hackage antiope-sqs 7.0.0, antiope-sns 7.0.0, antiope-s3 7.0.0, antiope-messages 7.0.0, antiope-dynamodb 7.0.0, antiope-core 7.0.0 (alexeyraga)
03:32:43 <dminuoso> royal_screwup21: its also interesting to know that not all types have values.
03:33:01 <dminuoso> We call such types "uninhabitated", because those types are not inhabitated by any values.
03:33:08 <dminuoso> For example `Maybe` is uninhabitated.
03:34:13 <royal_screwup21> yup I see....
03:34:17 <dminuoso> royal_screwup21: So you might ask yourself, how do we know which types are inhabitated and which are not?
03:34:33 <dminuoso> Since kinds classify types, we can use kinds to figure out whether a type can have values or not.
03:34:43 <dminuoso> So the rule is very simple: All types of kind * are inhabitatable.
03:34:59 <Ariakenom> Void?
03:35:07 <dminuoso> Ariakenom: _|_
03:35:31 <Ariakenom> how immoral
03:35:49 <dminuoso> Its very moral. If we randomly pretend bottom doesnt exist, its just as moral to randomly pretend it does!
03:36:12 <dminuoso> royal_screwup21: And equivalently, all types whose kind is not * are uninhabitable.
03:36:26 <dminuoso> royal_screwup21: Since `Maybe :: * -> *`, we can determine based on the kind that `Maybe` has no values
03:36:29 <dminuoso> We can even test this:
03:36:32 <royal_screwup21> what does it means for a type to inhabited?
03:36:33 <dminuoso> % undefined :: Maybe
03:36:33 <yahb> dminuoso: ; <interactive>:37:14: error:; * Expecting one more argument to `Maybe'; Expected a type, but `Maybe' has kind `* -> *'; * In an expression type signature: Maybe; In the expression: undefined :: Maybe; In an equation for `it': it = undefined :: Maybe
03:36:39 <royal_screwup21> to be*
03:36:39 <dminuoso> royal_screwup21: That there exist values of that type.
03:37:04 <royal_screwup21> so why is Maybe uninhabited? Just x is of type Maybe
03:37:10 <dminuoso> Nope it is not.
03:37:11 <royal_screwup21> :t Just 3
03:37:12 <lambdabot> Num a => Maybe a
03:37:22 <dminuoso> :t Just (3 :: Int)
03:37:23 <lambdabot> Maybe Int
03:37:28 <dminuoso> royal_screwup21: ^- see that `Int` bit? :)
03:37:33 <royal_screwup21> oh
03:37:56 <dminuoso> royal_screwup21: Maybe is a kind of type level function, that is it computes a new type.
03:38:05 <dminuoso> royal_screwup21: Maybe is applied to Int, and that construction produces a completely new type.
03:38:20 <royal_screwup21> ok that makes it sense...
03:38:28 <royal_screwup21> data Result = Success | Failure
03:38:35 <royal_screwup21> is Result uninhaibted?
03:38:42 <dminuoso> royal_screwup21: Are there values of type Result?
03:38:47 <dminuoso> royal_screwup21: First do the kind check
03:38:53 <dminuoso> See whether Result *could* have inhabitants.
03:38:57 <Ariakenom> % :kind Maybe
03:38:57 <yahb> Ariakenom: Maybe :: * -> *
03:39:10 <royal_screwup21> so the kind for Result is *
03:39:15 <royal_screwup21> it takes no args
03:39:22 <dminuoso> royal_screwup21: What does it mean for a type to have kind *?
03:40:11 <royal_screwup21> the datatype takes no args
03:40:24 <dminuoso> 11:34:21        dminuoso | So the rule is very simple: All types of kind * are inhabitatable.
03:40:42 <royal_screwup21> oh ok so it's inhabirtable
03:40:46 <dminuoso> So the kind system allows for Result to have values. Whether it has values depends on whether there is ways to construct values of that type.
03:40:52 <dminuoso> Result has two data constructors
03:40:57 <dminuoso> % data Result = Success | Failure
03:40:57 <yahb> dminuoso: 
03:41:00 <dminuoso> % :t Success
03:41:00 <yahb> dminuoso: Result
03:41:11 <dminuoso> So we have two values, so its not just inhabitatable, its also inhabitated.
03:41:34 <royal_screwup21> okay yup I see it
03:42:02 <royal_screwup21> Maybe is not inhabitable since its values depend on the type of argument passed to Maybe
03:42:14 <dminuoso> royal_screwup21: Maybe is not inhabitatable for simple reason that it does not have kind *
03:42:28 <royal_screwup21> yup...
03:43:03 <dminuoso> royal_screwup21: There exists a way to have a type of kind * without any (apparent) inhabitants though:
03:43:05 <dminuoso> % data Empty
03:43:05 <yahb> dminuoso: 
03:43:33 <dminuoso> royal_screwup21: This is an empty type with no (apparent) inhabitants. `Empty :: *` but you still cant construct any (meaningful) values of type Empty.
03:43:57 <royal_screwup21> dminuoso: yup...
03:44:24 <royal_screwup21> trying to see all this fits into the applicative instance of parsre
03:46:34 <dminuoso> royal_screwup21: I was just taking a detour and explaining in more depth what we talked about yesterday, since your question indicated you were a bit confused about the universes involved.
03:46:53 <royal_screwup21> oh no worries
03:47:30 <dminuoso> royal_screwup21: So. Can `f` in [(f a, s2) | (f, s1) <- cs1 s, (a, s2) <- cs2 s1] be a functor? Justify your answer.
03:49:13 <royal_screwup21> Functor is the name of a particular set of type constructors, all of which must be unary (that is they all take one argument) and they must satisfy some laws. The "f" in (f, s1) doesn't take any argument, so it can't be a functor
03:49:31 <dminuoso> royal_screwup21: Bad reason.
03:49:39 <dminuoso> royal_screwup21: Try to identify the universe you are in.
03:50:32 <royal_screwup21> I feel like it's the value universe? like, I know s -> is a value,  cs is a fuction::String -> [(a, String)]...
03:50:40 <royal_screwup21> s is a string
03:50:46 <dminuoso>   (Parser cs1) <*> (Parser cs2) = Parser (\s -> [(f a, s2) | (f, s1) <- cs1 s, (a, s2) <- cs2 s1])
03:51:00 <dminuoso> This is a method declaration. This is value level.
03:51:16 <royal_screwup21> yup
03:51:20 <dminuoso> Parser is a data-constructor, which is value level. cs1 is an irrefutable pattern binding, which is value level.
03:51:24 <dminuoso> So everything here is value level.
03:51:41 <dminuoso> The lambda is value level. list comprehension, value level.
03:51:53 <dminuoso> A lot of strong indicators that you are looking at value level code.
03:52:04 <royal_screwup21> ah yup makes sense
03:52:41 <royal_screwup21> if I replace f with a Maybe (a functor), it just doesn't make sense to me
03:52:50 <royal_screwup21> Maybe isn't a value
03:52:56 <dminuoso> Good.
03:54:09 <dminuoso> royal_screwup21: Are you familiar with list comprehensions at all?
03:55:47 <royal_screwup21> yup
03:56:36 <royal_screwup21> wait, am I  on the right track thinking that it isn't a functor? It's a function
03:56:47 <dminuoso> royal_screwup21: Yes.
03:56:48 <royal_screwup21> and it sort of kind of makes sense
03:56:57 <royal_screwup21> :t Just (+) <*> JUst 3
03:56:58 <lambdabot> error:
03:56:58 <lambdabot>     • Data constructor not in scope: JUst :: Integer -> Maybe a
03:56:58 <lambdabot>     • Perhaps you meant ‘Just’ (imported from Data.Maybe)
03:57:01 <royal_screwup21> :t Just (+) <*> Just 3
03:57:02 <lambdabot> Num a => Maybe (a -> a)
03:57:08 <royal_screwup21> > Just (+) <*> Just 3
03:57:10 <lambdabot>  Just <Integer -> Integer>
03:57:12 <royal_screwup21> > Just (+1) <*> Just 3
03:57:14 <lambdabot>  Just 4
03:57:21 <royal_screwup21> yup...
03:57:35 <royal_screwup21> in the same vein, parser cs1 is parmaterized on a function
03:57:49 <dminuoso> royal_screwup21: Let me rename things to help
03:57:51 <royal_screwup21> so it returns a function parse, which maps from a String -> [Function, String]
04:02:21 <dminuoso> royal_screwup21: https://gist.github.com/dminuoso/bdcdbe50cb1d97109b6c446d1d717660
04:02:43 <dminuoso> royal_screwup21: Ive taken the liberty to rewrite small things. Note that the `do-notation` there uses the list monad, which is equivalent to list-comprehensions.
04:02:57 <dminuoso> Perhaps its a bit easier to read.
04:04:07 <dminuoso> royal_screwup21: The `f` there has type `a -> b`
04:04:29 <royal_screwup21> yup got it...
04:07:37 * hackage capability 0.2.0.0 - Extensional capabilities and deriving combinators  https://hackage.haskell.org/package/capability-0.2.0.0 (aherrmann)
04:16:45 <absence> can i use template haskell to annotate a function call with its name, e.g. f x y is turned into f "f" x y?
04:21:00 <tdammers> that should be possible, though you will have to somehow feed the expression to TH in the first place, so it will look something like [annCall|f x y|] or $(annCall 'f ['x, 'y]) or some such
04:21:52 <tdammers> or maybe, at the top level, you could say f = $(annotate f')
04:22:34 <tdammers> and that would generate a function definition something like f = f' "f"
04:22:40 <tdammers> not difficult to write at all
04:24:52 <absence> tdammers: sounds good, i'll poke around with a tutorial. thanks!
04:32:36 <__monty__> Wouldn't something like the reflection package do this?
04:34:16 <lseactuary> anyone here good with CSPM? happy to pay for some mentoring also.
05:06:29 <absence> __monty__: hmm, i'm not sure it can do that
05:13:37 * hackage weigh 0.0.14 - Measure allocations of a Haskell functions/values  https://hackage.haskell.org/package/weigh-0.0.14 (ChrisDone)
05:35:46 <sshine> I am tempted to think there are bots inhere.
05:36:20 <merijn> sshine: Why?
05:37:34 <pie___> where does stack install ghc?
05:38:28 <sshine> merijn, because of the many "n -> n_", "n_ -> n" renames. maybe this is an auto-away feature catching popularity?
05:38:50 <pie___> ok maybe i dont have ghc installed yet
05:38:54 <sshine> pie___, in ~/.stack?
05:39:23 <merijn> sshine: Looks like a netsplit and auto-reconnect to me
05:39:24 <sshine> pie___, my ~/.stack is 21G and my ~/.ghc is 8K, so I think ~/.stack is where it puts the stuff. :-)
05:39:59 <sshine> merijn, oh! possible.
05:40:58 <__monty__> absence: Yeah, looking more closely it's about reification/reflection between values and types. Not completely in line with what little I know about reflection in other languages.
05:42:27 <vfaronov> hi! is there a "typical" way to express a NominalDiffTime of "2 hours" or "3 days" without hard-coding the number of seconds? like can I import day::NominalDiffTime from somewhere?
05:46:35 <gentauro> sshine: I only have 15 GB in my ~/.stack (programs and snapshots take the most)
06:12:07 <dminuoso> vfaronov: You could write simple combinators on the spot.
06:12:38 <vfaronov> sure, that's what I'm doing right now
06:15:20 <asheshambasta> So a strange problem: I'm unable to insert Int64 types from the Haskell side; the Postgresql side is bigint. Any clues? https://imgur.com/a/J73lMM2
06:15:20 <asheshambasta>  
06:15:58 <asheshambasta> in the screenshot on the LHS I have my Haskell application running that outputs the error data; on the RHS is when I try to run the logged SQL statement on the PG CLI client; which succeeds. 
06:27:32 <__monty__> That does seem weird.
06:29:01 <dminuoso> asheshambasta: Perhaps dont trust the log output?
06:31:45 <asheshambasta> actually, this is SQL biting me again. And the error message is also unhelpful. One of the join tables I was also inserting into in my Haskell side had an `integer` key that was referencing the bigint on the `member` table. When I had absent-mindedly altered the member table, PG had not protested. 
06:32:01 <asheshambasta> This is a classic case of database insanity. 
06:32:28 <dminuoso> asheshambasta: Dejavu! I had this exact issue too once, a lot of time spent debugging.
06:32:53 <asheshambasta> Apparently, PG is also not logging the offending query; it just logs the last query within a transaction that didn't cause errors. 
06:33:00 <asheshambasta> which makes the logs rather useless for me. 
06:34:06 <asheshambasta> basically, lesson here: do `\d <table>` before modifying any of its columns to see if you're unintentionally also affecting references. 
06:35:06 <asheshambasta> how ` integer ≡ bigint ` in PG-land is beyond me. 
06:37:16 <dminuoso> asheshambasta: What do you mean? Its not.
06:38:16 <sshine> gentauro, I don't know how I ended up with this much, but presumably many versions of GHC.
06:38:17 <asheshambasta> dminuoso: I was able to reference a bigint column from an integer column; which, to me feels a little wonky 
06:40:16 <dminuoso> asheshambasta: Not everyone has the same sense of type safety that we Haskellers prefer. :(
06:40:43 <dminuoso> Are there relational databases with a type system?
06:41:41 <asheshambasta> dminuoso: well, I'm no db expert, but the presence of "Typed" columns where integer's and bigint's behave differently led me to believe that it does. 
06:42:26 <asheshambasta> if the ranges of your integer types are different; they are, per se, different types no? 
06:42:45 <dminuoso> asheshambasta: Not necessarily.
06:43:09 <dminuoso> asheshambasta: Between subtyping and promotion rules there's various degrees to have such a concept in a language.
06:43:26 <dminuoso> asheshambasta: Consider how C lets you fling around numerics without ever considering size/matchyness.
06:43:44 <dminuoso> Drag a float through an int through a char, into an unsigned and back into a double.
06:44:02 <asheshambasta> C is not a standard when it comes to type safety is it :-)
06:44:50 <dminuoso> asheshambasta: Well even in Haskell we have primitives to completely circumcent the type system..
06:48:54 <asheshambasta> dminuoso: fair point, I guess. 
07:00:09 <absence> i want to put "show n" inside [|  |] but instead of lifting the resulting String, it tries to lift the "n" which doesn't have a lift instance. do i have to write something like "let n' = show n in [| ... n' |]", or can i somehow make it evaluate show n before lifting?
07:00:52 <dminuoso> absence: You have to bind it outside, otherwise it needs to quote the application
07:01:32 <c_wraith> just remember, everything inside the [| |] is lifted, whether it could theoretically have been reduced or not.
07:02:26 <dminuoso> Its not the result that is quoted but the AST that you supply.
07:03:01 <absence> i see, thanks!
07:10:05 <absence> does TH stuff have to be in a different module from where it's used?
07:10:56 <absence> "is used in a top-level splice, quasi-quote, or annotation, and must be imported, not defined locally"
07:12:00 <absence> or can i somehow import it?
07:16:24 <glguy> Write your TH in one module and import it into the one where you want to use it
07:24:18 <absence> ok! another beginner question: is this kind of nesting necessary, or can i avoid it? $( [| $(thtest 'h1) <> $(thtest 'h2) |] )
07:24:54 <absence> thtest :: Name -> Q Exp
07:27:22 <Cheery> I got types such as Half, One, Two.
07:27:27 <Cheery> multiplication defined over them
07:27:42 <Cheery> well. partially
07:27:55 <Cheery> I wonder if there's a way to handle this in haskell type system?
07:28:08 <Cheery> eg. Half -> One -> Half,   Half -> Two -> One
07:29:23 <Solonarv> absence: I cant't think of a situation where '$( [| stuff |] )' can't simply be replaced by 'stuff'
07:38:52 <absence> Solonarv: oh right, haha
07:58:37 * hackage netpbm 1.0.3 - Loading PBM, PGM, PPM image files  https://hackage.haskell.org/package/netpbm-1.0.3 (NiklasHambuechen)
08:22:38 <zincy> In my c debugger I see that a function has an address. Is this address in the data/text segment of memory as opposed to the heap, stack or static sections?
08:23:24 <zincy> Sorry not text/data but text, data segment is where static variables are stored
08:25:29 <c_wraith> is that a Haskell question or a C question? because the answer varies.
08:30:09 <zincy> Oops I am in the haskell room
08:30:29 <zincy> Both viewpoints would interest me however
08:31:57 <c_wraith> in general, object code is in the text segment. a C function pointer points to object code. in Haskell, a function value can be more than just object code. a closure, for instance. and those are heap-allocated
08:32:46 <c_wraith> (with dynamic loading of libraries, object code can be places other than the text segment)
08:45:05 <lseactuary> anyone who can help me with CSPM or point me to the right channel? 
08:46:05 <lseactuary> just really stuck on some part of a question and unable to move fowards.
08:46:28 <zincy> c_wraith: What is object code?
08:50:22 <c_wraith> zincy, the binary code that is actually sent to the processor. (as opposed to structuring data or interpreted code)
08:52:03 <zincy> Ah ok
08:53:18 <zincy> So is the reason why you store the return address in each stack frame so that you can update the program counter register with the the value of the address of the function from which to resume execution?
08:54:20 <Cale> zincy: Yeah, the stack explains where your program is going once it is finished its current task
08:54:23 <c_wraith> yep. it's how you can call the same function from different places and know where to return to afterwards... even in the presence of recursion
08:55:13 <zincy> So what writes the return address when the stack frame is constructed?
08:55:14 <Cale> zincy: In Haskell's case, the items on the stack primarily correspond to pattern matches that are waiting for their scrutinee to be sufficiently evaluated to match a pattern.
08:55:58 <zincy> How can you have pattern matches at the stack level?
08:55:59 <c_wraith> zincy, it's part of the calling convention used by the language. usually handles by the compiler behind the scenes
08:56:00 <Cale> (they may also be function applications which are waiting for the function itself to be effectively a lambda)
08:56:38 <ski> a return address passed to a function invocation is like writing a "reply-to" address on a mail envelope
08:56:53 <Cale> zincy: Well, a pattern match consists of entering the code for an expression and waiting for it to return a constructor to you, so that you can check the integer tag and decide which branch to take.
08:57:08 <Phyx-> make -j 220
08:57:19 <ski> (and tail calling corresponds to forwarding the mail, posibly after some work and change of the contents, and let the forwardee reply directly to the OP)
08:58:27 <zincy> Are data constructors just integer tags?
08:58:41 <ski> zincy : the stack is for "remembering things to do later". if you have `case f x of True -> ...; False -> ...', then the branches of that `case' is "things to do later", wrt the call to `f x'
08:58:45 <Cale> yeah, pretty much, integer tags followed by pointers to the arguments
08:59:11 <ski> (in this particular case, it's "several things to potentially do later, out of which you pick one alternative")
08:59:20 <Cale> https://www.microsoft.com/en-us/research/publication/implementing-lazy-functional-languages-on-stock-hardware-the-spineless-tagless-g-machine/?from=http%3A%2F%2Fresearch.microsoft.com%2Fapps%2Fpubs%2Fdefault.aspx%3Fid%3D67083
08:59:33 <Cale> ^^ this is a really good paper to read if you want to understand the details better
08:59:34 <ski> yes, tagging is the usual implementation of sum/variant types
08:59:40 <Cale> It's not entirely accurate now
08:59:42 <zincy> Ooh thanks
08:59:47 <Cale> But it's close enough :)
09:00:02 <zincy> For the branches of a case statement which would be the things to do later?
09:00:09 <Cale> yeah
09:00:30 <reallymemorable> can anyone tell me which of the two approaches at the bottom of this script is better?
09:00:31 <Cale> So you can imagine that it's the case expression itself which is waiting on the stack
09:00:33 <reallymemorable> https://paste.ofcode.org/LxLEiQu6FrUnwWggLza92u
09:00:35 <reallymemorable> neither is completely right
09:00:47 <reallymemorable> but I dont know which is better to pursue
09:01:34 <Cale> reallymemorable: Currently you have  runWeb = targetUrl
09:01:47 <reallymemorable> yes
09:01:54 <reallymemorable> i know that function is too verbose
09:02:33 <zincy> So the case expression translates to the following instructions at the machine level: evaluate this expression and see which integer tag is returned then follow the function pointed to by that integer tag?
09:03:47 <Cale> zincy: Yeah, there will be some branching based on the integer tag to determine what code to continue with.
09:04:13 <zincy> So where is the implementation of the branching logic, in GHC I guess?
09:04:25 <ski> zincy : "So what writes the return address when the stack frame is constructed?" -- when the function is invoked, the caller/invoker must pass the desired return address, according to some calling convention. that could be pushing it on the stack (or storing it in the newly constructed stack frame)
09:04:33 <Cale> Yeah, in the code generator where it's translating Core to cmm probably.
09:04:33 <ski> zincy : or it could be putting it in a register reserved for that. but then, if the called function calls some other function, it'll have to evacuate that register to the stack, before instating its own return address
09:05:31 <ski> zincy : hm, i don't follow the "then follow the function pointed to by that integer tag" part
09:05:34 <Cale> reallymemorable: There's no way that return Nothing and return (map ...) have the same type
09:05:45 <zincy> ski: I don't follow it either :)
09:05:52 <zincy> Thanks cale and ski
09:06:12 <Cale> reallymemorable: But using a case expression to match on the result of targetUrl makes sense.
09:06:31 <ski> zincy : hmm .. i see, you mean the section of code that the `case' expression associates with the tag. sure. i was thinking you was thinking the tag returned was accompanied by a "function pointer (say code address), which was followed, but that's not what would happen
09:06:58 <reallymemorable> Cale: are you saying the produceStateLinks2 is the better approach?
09:07:03 <zincy> What is the role of the Haskell RTS? I would have thought that GHC would just output assembly code for the particulate arch?
09:07:06 <ski> zincy : also note that tagging isn't the only way to do sum/variant types. it's the most obvious, though
09:07:24 <Cale> reallymemorable: I don't really see how the two are equivalent? None of this entirely typechecks anyway.
09:07:30 <reallymemorable> yeah
09:07:31 <reallymemorable> its WIP
09:07:40 <reallymemorable> (also im 4 weeks into haskell)
09:08:28 <Cale> reallymemorable: But yeah, dealing with the failure case up-front is usually a good plan.
09:08:49 <Cale> reallymemorable: Then you have an honest list of strings you can work with.
09:08:50 <ski> zincy : one thing it does is multiplex I/O over the green threads
09:08:56 <reallymemorable> what is the proper way to format that append
09:09:01 <lseactuary> anyone who can help with CSPM please? i am very tuck :(
09:09:02 <reallymemorable> appending the string to the URLs
09:09:19 <zincy> What is CSPM?
09:09:20 <lseactuary> wasting a lot of time just going round and round in circles, really want to show what i have done and move forward
09:09:30 <lseactuary> zincy: https://www.cs.ox.ac.uk/projects/fdr/manual/cspm/
09:09:47 <zincy> I can't access
09:09:49 <Cale> reallymemorable: The map expression you have there makes sense
09:10:03 <lseactuary> zincy https://www.cs.ox.ac.uk/projects/fdr/
09:10:05 <Cale> concatMap probably isn't what you want, because that would concatenate all the results.
09:10:05 <lseactuary> its public
09:10:16 <Cale> (which would no longer be a valid URL)
09:10:22 <reallymemorable> so i have to fix that Nothing -> case
09:11:02 <Cale> reallymemorable: More likely, you want to return (Just (map (...) urls))
09:11:25 <Cale> reallymemorable: you can also move the return outside the case expression to avoid having to write it in each branch
09:11:26 <reallymemorable> but what about the Nothing case
09:11:37 <Cale> Well, what would you like to do in that case?
09:11:46 <Cale> It looks like you're returning a Maybe from here
09:11:49 <reallymemorable> do nothing i suppose
09:11:52 <zincy> Are green threads generally just an OS thread simulation in a high level language?
09:11:57 <reallymemorable> i thought i had to include a case for that
09:12:21 <lseactuary> zincy - did it work?
09:12:23 <Cale> But if you'd prefer, you can instead write the code for what actual I/O you're going to do with these URLs
09:12:30 <zincy> Second link worked
09:12:36 <Cale> and maybe in the Nothing case, you'd like to display an error message
09:12:43 <reallymemorable> so just like
09:12:47 <reallymemorable> return "Error"
09:12:49 <lseactuary> cool is it something you can help me with? like i can help with syntax, im just stuck on the logic.
09:12:57 <zincy> lseactuary: Not sure what exactly you want help with.
09:13:12 <lseactuary> i am working through a question from the book and its sectioned in parts
09:13:18 <lseactuary> i am solving it but i think its not 100% correct
09:13:26 <lseactuary> i can show you the question and what i have done perhaps?
09:13:48 <Cale> reactormonk: Well I was thinking  putStrLn "Error: couldn't scrape census data"  or something
09:13:52 <Cale> oops
09:13:56 <Cale> reallymemorable: ^
09:14:33 <Cale> reallymemorable: and then in the other case, you have a bunch of urls, what did you plan to do with them?
09:14:54 <reallymemorable> the next step will be to navigate to those pages and download the contents
09:15:09 <Cale> Right, so you might just write that in-place
09:15:27 <Cale> Something like  forM urls $ \url -> do ...
09:16:23 <reallymemorable> ok
09:16:26 <reallymemorable> thanks
09:17:03 <reallymemorable> Nothing -> return putStrLn "Error!"
09:17:07 <reallymemorable> what is wrong with that
09:17:15 <reallymemorable> its not typechecking and i cant figure out whats wrong
09:17:21 <reallymemorable> I've tried parenthesis and $
09:18:03 <Uniaika> return takes only one argument
09:18:18 <Uniaika> so wrap the putStrLn inside parens, or use a `$` after return
09:18:33 <Uniaika> which you should replace by `pure` actually, so it doesn't give the wrong idea 
09:18:38 <Uniaika> (it's not like C's return at all)
09:18:59 <reallymemorable>         Nothing -> pure $ putStrLn "Error!"
09:18:59 <reallymemorable>         Just urls -> pure (map ("https://lehd.ces.census.gov/data/lodes/LODES7/" ++) urls)
09:19:10 <reallymemorable> yeah but then the other line doesnt typecheck
09:20:12 <Uniaika> could we see the message?
09:20:24 <reallymemorable>  Couldn't match type ‘[[Char]]’ with ‘IO ()’
09:20:24 <reallymemorable>   Expected type: IO (IO ())
09:20:24 <reallymemorable>     Actual type: IO [[Char]]
09:20:32 <reallymemorable> in reference to the second line
09:23:47 <Cale> Uniaika: please don't recommend that people generalise return to pure for no reason. :)
09:24:06 <zincy> Whats the difference?
09:24:22 <zincy> Between pure and return that is
09:24:23 <Cale> If you *know* that you're working with something that is a monad, you might as well use return. This is IO specifically, which we know is an instance of Monad.
09:25:06 <Cale> Whenever someone writes 'pure', I have to wonder which Applicative functor we're using that isn't a Monad in order to demand that level of abstraction.
09:25:29 <zincy> Ok thanks
09:25:35 <Cale> and then usually when I find out it's something specific which was already known to be a monad, I'm mildly annoyed
09:26:14 <ski> in an alternate reality (perhaps to become the actual future at some point ?), one could have `Applicative' as a superclass of `Monad', and `return' not existing
09:26:16 <Cale> It doesn't *really* matter, it's just like, this extra out of band data that you're providing through the level of generality
09:26:28 <Cale> and which if it's incorrect, it's annoying
09:26:36 <zincy> So is the function of the stack to keep track of the future operations that a process is to run
09:26:49 <zincy> And every language requires that bookkeeping
09:26:53 <Cale> yeah, pretty much
09:27:07 <ski> but seeing as it does exist, is seems reasonable to me to be able to point out the specificity of the situation, by using `return' rather than `pure', just like if you're dealing with lists, `map' is more concrete than `fmap'
09:27:13 <zincy> So where is the stack persisted between context switches?
09:27:20 <ski> (nevermind that in the past, `map' actually *was* `fmap')
09:27:26 <Cale> right
09:27:52 <ski> some people might prefer to use `pure' anyway, which sounds a reasonable standpoint as well, to me
09:28:09 <jlamothe> If you ask me, map should've been defined at the Functor level.
09:28:13 <Cale> I just like to have the extra hints regarding what types of things the program is working with, when it's easy to provide them, and there's no benefit to using the more general functions.
09:28:14 <ski> but i don't think one should dismiss the specificity argument
09:28:22 <ski> jlamothe : it was, then it was changed
09:28:25 <Cale> jlamothe: In Haskell 1.4, it was.
09:28:49 <jlamothe> What was the reason for the change?
09:29:07 <Cale> Students being confused and professors not wanting to explain Functor on day 1
09:29:40 <jlamothe> :/
09:29:43 <ski> zincy : somewhere in address space ?
09:30:38 <jlamothe> I keep forgetting that Haskell is largely seen as an academic language.
09:30:43 <Cale> Well, it was
09:30:44 <lyxia> are there any records of that old state of things
09:30:58 <ski> i think there are docs, somewhere
09:31:02 <Cale> At the time, essentially all of Haskell's users were academic. You couldn't write practical software with it.
09:31:10 <ski> (perhaps on <archive.org>)
09:31:18 <Cale> Well, it was starting to get there
09:31:32 <Cale> ByteString didn't exist, for instance, which severely limited the scope of applications.
09:41:10 <royal_screwup21> could someone help me figure out what this combinator is doing? 
09:41:10 <royal_screwup21> < (<*) :: Applicative f => f a -> f b -> f a
09:41:10 <royal_screwup21> < px <* py = const <$> px <*> ? px and py are parsers defined here: http://hackage.haskell.org/package/yoda
09:41:48 <royal_screwup21> these parser combinators are killing me :(
09:41:58 <merijn> royal_screwup21: Runs both effects, but throws away the result of the second
09:42:24 <royal_screwup21> merijn: can I ask how you arrived at that that SO fast??
09:42:44 <ski> in monadic terms, that's `do x <- px; y <- py; return x'
09:43:04 <merijn> royal_screwup21: 1) I already know <* because it's fairly common (especially in parsers), 2) that's literally what the definition you pasted does ;)
09:43:14 <merijn> > const True 'c'
09:43:16 <lambdabot>  True
09:43:48 <merijn> royal_screwup21: (<*) is from Control.Applicative
09:44:02 <ski> royal_screwup21 : `f <$> act0 <*> act1' is `liftA2 f act0 act1', which in monadic terms corresponds to `liftM2 f act0 act1' which is `do x0 <- act0 ; x1 <- act1; return (f x0 x1)' -- now set `f' to `const'
09:44:18 <merijn> Alternatively, ski's explanation :p
09:45:08 <Cale> haha, the same things go through my mind as well
09:45:27 <Cale> I suspect it's a property of having started programming Haskell at a time when Applicative didn't exist
09:45:34 <dminuoso> I prefer to think of it as an `applicative const`. :)
09:45:55 <ski> (after a while you can intuit `f <$> act0 <*> act1 <*> ...' directly, not having to go via a monadic interpretation)
09:45:59 <ski> yes
09:49:09 <royal_screwup21> ski: what is the "non-mathematical" version of this statement? `f <$> act0 <*> act1 <*> ...'  I appreciate the monadic interpretation but I've tried hard, and I just can't grok this language :( The way merijn said - "runs both effects ..." -- that sounded way easier to digest
09:49:57 <Cale> royal_screwup21: Well, look at the final do-notation there
09:50:12 <royal_screwup21> yup, do x <- px; y <- py; return x'
09:50:29 <dminuoso> royal_screwup21: It may be helpful to perhaps just try out (<$) and then later backtrack and understand it.
09:50:31 <Uniaika> Cale: regarding the pure/return thing, I recommend them to beginner because, well, they highly tend to mistake return for the imperative keyword (and in practice I've never seen it cause any kind of damage)
09:50:44 <Uniaika> but I'll follow your recommendation for this channel ;)
09:51:00 <dminuoso> royal_screwup21: Trying to learn these abstract combinators before using them is going to be very hard. Your lack of intuition is probably caused by trying to focus too much on understanding the abstraction before having a feel for the concrete.
09:51:14 <ski> royal_screwup21 : perform the effects of the actions, `act0',`act1',..., in order, then call `f' on the respective results
09:51:26 <Cale> Uniaika: Well, if someone is confusing return for a keyword, it's good to explain that it's a function which makes an action that does nothing except to return the given value as its result
09:52:17 <ski> royal_screwup21 : if you see `actf <*> act0 <*> act1 <*> ...', then that's : perform all the effects of `actf',`act0',`act1',..., in order, then apply the (function) result of the first, to the (respective) results of the latters
09:53:22 <ski> royal_screwup21 : and `pure f <*> act0 <*> act1 <*> ...' is the same as `f <$> act0 <*> act1 <*> ...'. `pure x' is "no (non-trivial) effects to perform, just yield `x' as result"
09:54:32 * ski thinks one needs an interplay of what dminuoso is suggesting, and some kind of conceptual image/framework to fit things into
09:54:37 <royal_screwup21> hmm okay, I think I'm sort of seeing it, but I need to try out some examples
09:54:56 <ski> (probably either can come first, and probably it's partly a temperamental thing, which you'd prefer coming first)
09:55:18 <nai> > const <$> [42] <*> [43]
09:55:20 <lambdabot>  [42]
09:55:33 <Cale> Uniaika: I also like to point out that because the resulting action is effectively a no-op, any return occurring in the middle of a do-block can be removed. I still think return is a good name for the thing which it is, it's just that it doesn't quite agree with the "call the continuation of this definition" version that people might be familiar with
09:55:38 <nai> > [42] <* [43]
09:55:40 <lambdabot>  [42]
09:56:01 <ski> having some kind of (probably very incomplete, partly wrong) image of what to expect, how to categorize ones experience, helps, imho
09:56:02 <nai> > [42] <* [43, 44]
09:56:04 <lambdabot>  [42,42]
09:56:43 <ski> then you iterate between updating your experience, and adjusting your conceptual map
09:57:28 <ski> (the latter often being known as "staring out the window", or "daydreaming", or "useless philosophical quabbling")
09:59:41 <dminuoso> ski: That conceptual map adjustment is a really pleasent process for me. The day Applicative completely clicked for me, was when I started thinking of it in terms of Monoidal - that "function application" interference always seemed to arbitrary and inexplicable..
10:00:40 * ski nods
10:00:46 <ski> could you elaborate on that ?
10:01:41 <dminuoso> ski: Which part exactly?
10:02:09 <ski> "thinking of it in terms of Monoidal", and "that \"function application\" interference"
10:02:23 <dminuoso> % class Functor f => Monoidal f where unit :: f (); (><) :: f a -> f b -> f (a, b)
10:02:23 <yahb> dminuoso: 
10:02:24 <nai> all told, an applicative functor is just a monoid in the category of... wait
10:02:41 <dminuoso> ski: ^- this is what Applicative really looks like.
10:02:45 <ski> ok .. and the second part
10:02:47 <ski> ?
10:02:49 * ski nods
10:03:34 <dminuoso> ski: So Applicative has this implied notion of being about function application. Things like <* are fragments that defy this notion.
10:04:14 <nai> so <* could be thought of in terms of function application with const, or in terms of (a, b) with fst? nice
10:04:22 <ski> yea .. perhaps that is one reason i don't really like the term "applicative" (i often use the earlier term "idiom" instead ..)
10:04:30 <ski> nai, aye
10:05:36 <Cale> dminuoso: Well, const is a function that can be applied :P
10:05:40 <royal_screwup21> so I know what const does: give two args, it outputs the first one. I'm trying to understand how this works:  const <$> [42] <*> [43]. I have a feel for how <*> works: Just (\x -> x+1) Just 3 == Just 4. Not quite able to join the dots here
10:05:54 <Cale> dminuoso: But yeah, perhaps having special notation for that is a little weird
10:06:12 <ski> sometimes i say things like idioms being about "static sequencing of effects", and monads being about "dynamic sequencing of effects"
10:06:18 <Cale> dminuoso: Until you realise that these are not simply functions, but functions with effects.
10:06:25 <ski> royal_screwup21 : `42' and `43' is passed to `const'
10:06:27 <berndl> const <$> [42] <*> [43] == [const 42 43]
10:06:37 <dminuoso> Cale: Right, and at that point you would realize that the "functions" part can be elided by just throwing const and id into it.
10:06:39 <Cale> Or perhaps "effects with functions" would be the right way around :D
10:06:49 <dminuoso> Cale: So it all boils down to "it's just effects"
10:07:04 <nai> const <$> [42] <*> [43] = [const 42] <*> [43] = [const 42 43] = [42]
10:07:14 <Cale> dminuoso: You could say the same about Monad as wlel
10:07:16 <Cale> well*
10:07:22 <ski> royal_screwup21 : for lists, `[x] = pure x'. so `const <$> [42] <*> [43]' is `const <$> pure 42 <*> pure 43', which (by law) is `pure (const 42) <*> pure 43', which (by law) is `pure (const 42 43)'
10:07:36 <dminuoso> Cale: Indeed! I tend to prefer the kleisli construction. However it just so happens that Applicative and Monad has the nicer interface for the most common problems.
10:07:36 <Cale> But of course, the real explanation is just reading the type class itself
10:07:58 <nai> royal_screwup21: don't forget that functions in haskell are currified. const can be thought of as taking ONE argument, and producing the constant function associated with that argument
10:07:59 <dminuoso> (By kleisli construction I mean in terms of >=> rather than =<<)
10:08:17 * ski nods
10:08:20 <Cale> I find <=< more useful than >=> most of the time
10:08:32 <Cale> Fits in with composition better
10:08:39 <ski>   x <- foo <=< bar <=< baz =<< quux
10:08:45 <Cale> and do-notation, yeah
10:08:49 <dminuoso> Sure, whether you pick (<=<) or (>=>) is besides the point though. :P
10:09:29 <dminuoso> (I accidentally pressed > first, so I decided to conclude it with a left-to-right composition rather than spend the split second fixing my typo)
10:09:41 <Cale> haha
10:09:51 <Cale> Yeah, usually it's nice to have names for things
10:10:15 <ski> nai : also don't forget that there is no currying in the Haskell language ;)
10:10:31 <nai> ski: what do you mean?
10:10:42 <Cale> There's a tendency, when you have all these operators under your belt, to initially try to simplify everything to a perfect crystalline points-free form
10:10:57 <dminuoso> Although recently Ive played with Free quite a bit, and Im starting to really enjoy the `Monads are just monoids..` mental model for that.
10:11:16 <ski> i mean that currying is a (human) *convention*, and *encoding*, to express "multiple-argument functions" inside a system (Haskell), which *only* has "single-argument functions"
10:11:37 <dminuoso> Cale: And then when you become proficient you start with pointful notation everywhere, writing things out and making small bindings for readability. :-P
10:11:44 <nai> ski: sure
10:11:54 <ski> there is also another convention, sometimes called tupling, where you pack the multiple arguments into some structure, like a tuple, record, list, or other thing, and pass that
10:12:19 <ski> and Haskell supports both conventions (you can pattern-match on tuples, pretending that you're passed multiple arguments)
10:12:42 <ski> but the syntax of Haskell definitely is made so that currying will be a natural convention to commonly use
10:12:46 <dmwit> People say "use =<< and <=< instead of >>= and >=> to fit in with composition better" but nobody ever says "maybe we should have a more convenient backwards composition"
10:13:05 <nai> > const' = fst; const'(42, 43)
10:13:05 <ski> (and also the performance of the implementation, so that we don't pay overly much by currying rather than tupling)
10:13:07 <lambdabot>  <hint>:1:8: error:
10:13:07 <lambdabot>      parse error on input ‘=’
10:13:07 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
10:13:13 <nai> oopsie
10:13:33 <dmwit> > let const' = fst in const'(42, 43)
10:13:34 <lambdabot>  42
10:13:43 <nai> i'm too used to ghci
10:13:45 <ski> nai : so i'm pointing out that "currying" exists in our heads (or in our community culture), not in the language itself, though it certainly enables and encourages it
10:13:54 <dmwit> % const' = fst; const'(42, 43)
10:13:54 <yahb> dmwit: ; <interactive>:48:15: error:; Parse error: module header, import declaration; or top-level declaration expected.
10:14:09 <dmwit> nai: Doesn't seem to work in ghci, either. =P
10:14:10 <nai> % const' = fst
10:14:10 <yahb> nai: 
10:14:13 <nai> % const'(42, 43)
10:14:13 <yahb> nai: 42
10:14:22 <nai> dmwit: i'm too bad :D
10:14:29 <portnov> @hoogle m [a] -> [m a]
10:14:29 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
10:14:29 <lambdabot> GHC.OldList transpose :: [[a]] -> [[a]]
10:14:29 <lambdabot> Data.List.HT shear :: [[a]] -> [[a]]
10:14:37 <nai> ski: understood
10:14:42 <ski> royal_screwup21 : the above discussion with nai may perhaps be of interest to you, as well
10:15:02 <dminuoso> dmwit: I think both have their roles. When you are inside do-notation then you are already biased because the `<-` strongly indicates an exising order, but I've seen quite a few (>=>) and (>>=) in the wild.
10:15:10 <nai> Cale: if you like point-free, try playing with lambdabot's @pointless command
10:15:55 <Cale> I... I know about that :)
10:16:08 <Cale> dminuoso: Yeah, that was the point I was going to make, but I got distracted :)
10:16:11 <nai> cool
10:17:19 <Cale> For real world work, code which makes you feel clever often ends up making you look dumb
10:17:25 <royal_screwup21> ski: so I'm trying to translate the english verision of `actf <*> act0 <*> act1 <*> ...', which is: "perform all the effects of `actf',`act0',`act1',..., in order, then apply the (function) result of the first, to the (respective) results of the latters" -- and apply it to my use case:
10:17:27 <ski> dmwit : well, with backwards-composition, we get `(f ; g) x = g (f x)', which tends to confuse people, to some extent (more than `(g . f) x = g (f x)'). so it has to do with writing `f x' rather than `x f', and i think that's (a) because in a definition `f x = ..x..', you get the thing to be defined, first; and (b) (which is related) in a general call `f x', `x' tends to more often be a large expression than `f', so you tend to want to read `f' before `x'
10:17:31 <royal_screwup21> const <$> [42] <*> [43]
10:17:41 <ski> (also, `f' is what connects `f x' to its context)
10:18:10 <nai> talking about "effects" probably isn't that helpful for lists
10:18:10 <Cale> Also, for "business logic", it makes almost no sense to try to mathematically simplify things -- even if they fit the mathematical abstraction for a day, there's no guarantee that will continue to be the case.
10:18:19 <dminuoso> nai: it absolutely is.
10:18:23 <ski> royal_screwup21 : well, that is `.. <$> .. <*> .. <*> ...', not only with `<*>'s
10:18:25 <dminuoso> nai: The effect is called non-determinism.
10:18:35 <nai> dminuoso: oh that's right
10:18:37 <royal_screwup21> ah okay
10:18:39 <Cale> So just leaving case expressions around and trying to explain things with names isn't the worst idea.
10:18:47 <dminuoso> nai: This is exactly why Parser ~ StateT []
10:18:50 <ski> royal_screwup21 : but, as i said before, `const <$> [42] <*> [43]' is the same as `pure const <*> [42] <*> [43]', and now it's of the requisite form
10:19:11 <Cale> Writing things in a very basic style which would be comprehensible to a beginner in Haskell is actually usually good.
10:19:28 <dminuoso> nai: I meant `Parser ~ StateT String []`
10:19:56 <Cale> Of course, it's still worth having all the extensions and fanciness for when you really need it.
10:20:48 <ski> nai : i tend to lean on the side of "if it's an idiom, or a monad, then it expresses an effect (however strange it may initially seem)"
10:21:03 <nai> i see
10:21:47 <nai> so in this case, picking a slightly different example:  const <$> [42] <*> [43, 44]  is "non-deterministically choose a value in [42], then non-deterministically choose a value in [43, 44], then apply const to those two values"
10:21:52 <ski> (because experience has taught me that a lot of things that one wouldn't first categorize under "effect" can usefully be categorized like that)
10:21:54 <nai> > const <$> [42] <*> [43, 44]
10:21:56 <lambdabot>  [42,42]
10:21:57 <Cale> nai: yes
10:22:04 <royal_screwup21> > [42] <* [45, 43]
10:22:06 <lambdabot>  [42,42]
10:22:09 <portnov> @hoogle [m [a]] -> [m a]
10:22:10 <lambdabot> Test.LeanCheck listsOf :: [[a]] -> [[[a]]]
10:22:10 <lambdabot> Test.LeanCheck setsOf :: [[a]] -> [[[a]]]
10:22:10 <lambdabot> Test.LeanCheck bagsOf :: [[a]] -> [[[a]]]
10:22:17 <Cale> It's more obvious if you choose lists of slightly longer length
10:22:27 <nai> > const <$> [42, 41] <*> [43, 44]
10:22:30 <lambdabot>  [42,42,41,41]
10:22:38 <stevenxl> Hi everyone. I am trying to create a script in Haskell, and I want to specify that it use a particular version of a package that is NOT in the LTS.  Right now, the top of my file looks like this:
10:22:47 <stevenxl> https://www.irccloud.com/pastebin/ICRG7MsY/
10:22:47 <royal_screwup21> const <$> [42, 41] <* [43, 44]
10:22:50 <ski> nai : as regards to list / non-determinism effects, sequencing roughly means "nested loops, trying out every combination, backtracking"
10:22:51 <royal_screwup21> > const <$> [42, 41] <* [43, 44]
10:22:53 <lambdabot>  error:
10:22:53 <lambdabot>      • No instance for (Typeable b0)
10:22:53 <lambdabot>          arising from a use of ‘show_M36051784441038252713760’
10:23:09 <Cale> royal_screwup21: you meant to remove the "const <$>"
10:23:11 <dmwit> portnov: Can't be done. Can't even be done (in a total way) if you add `Monad m` as a constraint. You'll need to know something pretty special about `m` to be able to do that.
10:23:14 <stevenxl> but that is uses version 0.20 of the github package, and I want to use version 0.21 (which is not in the resolver)
10:23:19 <royal_screwup21> >  [42, 41] <* [43, 44]
10:23:21 <lambdabot>  [42,42,41,41]
10:23:40 <dmwit> :t concatMap sequence
10:23:41 <lambdabot> (Foldable t2, Traversable t1) => t2 (t1 [a]) -> [t1 a]
10:23:43 <ski> nai : so, each notion of effect (static or dynamic), comes with its own notion of sequencing (in addition to, or perhaps expanding on, what the "primitive/atomic" effects are)
10:24:06 <dmwit> portnov: `Traversable m` would be enough, see above.
10:24:07 <nai> i see
10:24:12 <royal_screwup21> ok, so I'm interpreting correctly, <* means replace every occurence in the second list with with first list, then concat into one big list
10:24:21 <royal_screwup21> or not no
10:24:32 <dmwit> portnov: Though whether that does what you wanted it to do is another question entirely.
10:25:09 <ski> royal_screwup21 : pick a value in the first list, pick a value in the second list, in every possible way. for each possibility, report only the first value
10:26:03 <nai> royal_screwup21: according to what ski is saying, you could translate it as:  for a in [42, 41]: for b in [43, 44]: return a
10:26:16 <nai> where a is const a b
10:26:17 <royal_screwup21> ski: I genuinely don't know how to go about learning this lol.  My goal is to figure out how to use a parser combinator library. Is it worth it to use lists and play around with these <*, <$> etc? Or should I use actual strings and try to parse them with the library
10:26:20 <ski> s/return/yield/, if you think in terms of generators
10:26:43 <nai> yep
10:27:44 <ski> royal_screwup21 : by "use lists and play around with these <*, <$> etc" do you mean learning how list effects work, or do you mean something about using lists with parsers ?
10:28:14 <ski> royal_screwup21 : in case of the former, i definitely think learning how list effects work will help, e.g. with better understanding backtracking for parsers
10:28:29 <royal_screwup21> ah okay
10:28:43 <ski> (lists are simpler than parsers. it probably helps much to first have seen lists and state, before tackling parsers)
10:29:20 <ski> also don't forget to compare to list comprehensions, realizing how it's basically the same thing
10:29:44 <nai> by the way, i read on some stack overflow answer that list comprehension was defined in terms of monad, but then i read in the source of the list monad instance that bind is defined with a list comprehension. chicken or egg?
10:30:02 <ski> list comprehensions are not defined in terms of monadic constructs
10:30:49 <nai> (https://stackoverflow.com/questions/44965/what-is-a-monad/194207#194207 vs https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#line-984)
10:31:10 <nai> "It turns out this is really just syntactic sugar for some operations within the List monad." sounds dubious
10:31:39 <ski> > do z <- [1 .. 20]; y <- [1 .. z]; x <- [1 .. y]; guard (x^2 + y^2 == z^2); return (x,y,z)  -- Pythagorean triples
10:31:41 <lambdabot>  [(3,4,5),(6,8,10),(5,12,13),(9,12,15),(8,15,17),(12,16,20)]
10:31:49 <ski> @undo do z <- [1 .. 20]; y <- [1 .. z]; x <- [1 .. y]; guard (x^2 + y^2 == z^2); return (x,y,z)
10:31:49 <lambdabot> [1 .. 20] >>= \ z -> [1 .. z] >>= \ y -> [1 .. y] >>= \ x -> guard (x ^ 2 + y ^ 2 == z ^ 2) >> return (x, y, z)
10:32:19 <royal_screwup21> ski: the explanation for <* made a  satisfying amount of sense, I've figured out how *> works too. I'm wondering if it's possible to link this explanation to how <*> works?
10:32:22 <ski> > [(x,y,z) | z <- [1 .. 20],y <- [1 .. z],x <- [1 .. y],x^2 + y^2 == z^2]  -- same thing, in list comprehensions
10:32:24 <lambdabot>  [(3,4,5),(6,8,10),(5,12,13),(9,12,15),(8,15,17),(12,16,20)]
10:32:31 <ski> @undo [(x,y,z) | z <- [1 .. 20],y <- [1 .. z],x <- [1 .. y],x^2 + y^2 == z^2]
10:32:31 <lambdabot> concatMap (\ z -> concatMap (\ y -> concatMap (\ x -> if x ^ 2 + y ^ 2 == z ^ 2 then [(x, y, z)] else []) [1 .. y]) [1 .. z]) [1 .. 20]
10:32:37 <nai> my question is, does something like [x*2 | x<-[1..10], odd x] effectively get desugared into something like what you showed, or is it an internal language construct
10:33:06 <nai> wait let me read that
10:33:42 <geekosaur> effectively, yes. (in ghc there are multiple equivalent ways to desugar it, and which you get depends on which extensions are in use)
10:33:52 <ski> however, the expansion of list comprehensions is still "basically the same thing" as the corresponding monadic expansion of the `do'-expression
10:34:03 <ski> @src [] (>>=)
10:34:03 <lambdabot> xs >>= f = concatMap f xs
10:34:26 <nai> o_O that's not what the link above says
10:34:31 <nai> is it GHC-specific
10:34:46 <nai> i would guess so from the GHC word in the url
10:35:34 <ski> royal_screwup21 : `<*>' is "execute both actions / perform the effects of both actions, in order, then apply the function resulting from the first, to the result coming from the second"
10:35:52 <nai> -- See Note: [List comprehensions and inlining]
10:35:58 <nai> well there's what seems like my answer
10:38:23 * ski ponders which example to take
10:38:52 <ski> > (+) <$> [1,2,3] <*> [400,500]
10:38:53 <nai> maybe Maybe
10:38:54 <lambdabot>  [401,501,402,502,403,503]
10:39:00 <ski> royal_screwup21 : consider this example
10:39:05 <royal_screwup21> yup
10:39:16 <geekosaur> what ghc actually does and the conceptual understanding of what's going on often differ, because ghc generally does trickier things that play better with optimization.
10:39:21 <ski> let's, for simplicitys sake, assume that all the numbers are `Integer's
10:39:27 <royal_screwup21> yep...
10:39:34 <ski> so, it may help to follow the types here
10:40:10 <ski> first, recall that `(+) <$> [1,2,3] <*> [400,500]' really means `((+) <$> [1,2,3]) <*> [400,500]' (and if you had more `<*>'s at the end, it would still be "associated to the left", in this fashion)
10:40:11 <geekosaur> but the way list comprehensions line up with do notation for monads is the root of the MonadComprehensions extension, which allows "list comprehension" syntax for any Monad instead of being specific to lists
10:40:15 <ski> so
10:40:25 <ski>   (+) :: Integer -> Integer -> Integer
10:40:31 <ski> note that this is really
10:40:34 <ski>   (+) :: Integer -> (Integer -> Integer)
10:40:45 <ski> and we have
10:41:27 <ski>   (<$>) :: (a -> b) -> f a -> f b  -- in this case `f' is `[]', so `f a' is `[] a' is `[a]', similarly with `f b'
10:42:03 <ski> so passing the first argument to `(<$>)' (the left operand to `<$>', via a section e.g.) will result in
10:42:33 <ski>   (<$>) (+) :: [Integer] -> [Integer -> Integer]
10:42:34 <ski> or
10:42:41 <ski>   ((+) <$>) :: [Integer] -> [Integer -> Integer]
10:42:53 <ski> because `a' becomes `Integer' and `b' becomes `Integer -> Integer'
10:43:04 <ski> so, when we now pass the first list, like
10:43:19 <ski>   (<$>) (+) [1,2,3] :: [Integer -> Integer]
10:43:20 <ski> iow
10:43:27 <ski>   (+) <$> [1,2,3] :: [Integer -> Integer]
10:43:51 <royal_screwup21> cool thanks for the explanation...
10:43:53 <ski> we've "satisfied" the first argument of `(+)', but the second is still waiting for values
10:44:03 <ski> next is the `<*>', which has signature
10:44:14 <nai> geekosaur: tl;dr i'll keep my sanity and stop looking into gory implementation details :D
10:44:18 <ski>   (<*>) :: f (a -> b) -> f a -> f b  -- again, `f' is `[]' here
10:44:40 <royal_screwup21> yeah that's how I'm visualizing it's a curried function expecting one more arg and it's "waiting" for the values from the list
10:45:03 <ski> so, applying `(<*>)' to what we had before, `f (a -> b)' is matched with `[Integer -> Integer]', so that `f' becomes `[]' (we knew that), and `a' and `b' both becomes `Integer', yielding
10:45:23 <ski>   (<*>) ((<$>) (+) [1,2,3]) :: [Integer] -> [Integer]
10:45:24 <ski> or
10:45:40 <ski>   ((+) <$> [1,2,3] <*>) :: [Integer] -> {Integer]
10:45:52 <ski> er, s/{/[/
10:46:12 <ski> finally, passing the other argument/operand to `<*>' gives us
10:46:28 <ski>   (<*>) ((<$>) (+) [1,2,3]) [400,500] :: [Integer]
10:46:29 <ski> or
10:46:41 <ski>   (+) <$> [1,2,3] <*> [400,500] :: [Integer]
10:46:59 <royal_screwup21> cool thanks a lot! I'll play around with this on ghci
10:47:07 <ski> now, my intervening explanations of what's happening here makes this a bit noisy, so i'll repeat it, with just the types
10:47:20 <ski>   (+) :: Integer -> (Integer -> Integer)
10:47:30 <ski>   [1,2,3] :: [Integer]
10:47:44 <ski>   (+) <$> [1,2,3] :: [Integer -> Integer]
10:47:50 <ski>   [400,500] :: [Integer]
10:48:03 <ski>   (+) <$> [1,2,3] <*> [400,500] :: [Integer]
10:48:43 <ski> now, compare this with what happens if we had used `pure' and `<*>' in place of the `<$>' "shortcut" :
10:48:46 <ski>   (+) :: Integer -> (Integer -> Integer)
10:48:57 <ski>   pure (+) :: [Integer -> (Integer -> Integer)]
10:49:04 <ski>   [1,2,3] :: [Integer]
10:49:16 <ski>   pure (+) <*> [1,2,3] :: [Integer -> Integer]
10:49:25 <ski>   [400,500] :: [Integer]
10:49:35 <ski>   pure (+) <*> [1,2,3] <*> [400,500] :: [Integer]
10:50:15 <ski> instead of `pure (+)', you could consider e.g. `[(+),(*)]'
10:50:35 <ski> and, you could also go on to contemplate a slightly more advanced case like
10:50:37 <ski> > zipWith <$> [(+),(*)] <*> [[0,1,2],[3,4]] <*> [[500,600,700],[800,900]]
10:50:39 <lambdabot>  [[500,601,702],[800,901],[503,604],[803,904],[0,600,1400],[0,900],[1500,2400...
10:51:01 <ski> keeping track of the types as i just did above, now for this example
10:51:08 <ski> royal_screwup21 : does this help ?
10:51:17 <royal_screwup21> yeah I'm just re-reading it...
10:54:22 <mniip> @djinn ((((a -> b) -> b) -> b) -> b) -> (a -> b) -> b
10:54:22 <lambdabot> f a b = a (\ c -> c b)
10:57:16 * ski . o O ( they all continue to join )
10:58:37 * hackage git-annex 7.20190322 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-7.20190322 (JoeyHess)
10:59:03 <dyl> 	@djinn ((((((a -> b) -> b) -> b) -> b) -> b) -> b) -> (a -> b) -> b
10:59:10 <dyl>  @djinn ((((((a -> b) -> b) -> b) -> b) -> b) -> b) -> (a -> b) -> b
10:59:32 <ski> remove that white space
10:59:43 <dyl> Gah, how'd that end up in there.
10:59:48 <dyl> @djinn ((((((a -> b) -> b) -> b) -> b) -> b) -> b) -> (a -> b) -> b
10:59:48 <lambdabot> f a b = a (\ c -> c (\ d -> d b))
10:59:59 <dyl> Interesting. 
11:00:16 <ski> (and yes, obviously that works. it's merely `Cont o (Cont o (Cont o)) a -> Cont o a', rather than `Cont o (Cont o) a -> Cont o a'. it's like asking for `x + y + z', after you've mastered `x + y')
11:01:18 <dyl> ski I know it 'works' :p
11:01:52 <ski> (and `x + y + z' can be understood as either `(x + y) + z' or as `x + (y + z)' (and by law, these give the same result, so we tend to forget about the difference). similarly, there's two ways to do what Djinn did above, but (by law), they're equivalent)
11:02:45 <dyl> @pl f a b = a (\ c -> c b)
11:02:45 <lambdabot> f = (. flip id)
11:02:49 <dyl> @pl f a b = a (\ c -> c (\ d -> d b))
11:02:49 <lambdabot> f = (. (flip id . flip id))
11:03:16 <ski> (er, sorry, my types were wrong. i should have said `Cont o (Cont o (Cont o a)) -> Cont o a', and `Cont o (Cont o a) -> Cont o a' -- confusing myself with `ContT' a bit there ..)
11:04:59 <ski> @type cont . flip all
11:05:00 <lambdabot> Foldable t => t a -> Cont Bool a
11:05:27 <ski> @type cont . (>>=)
11:05:28 <lambdabot> Monad m => m a -> Cont (m b) a
11:05:31 <ski> @type ContT . (>>=)
11:05:32 <lambdabot> Monad m => m a -> ContT r m a
11:06:18 <nai> wait, how is  flip id  well typed?
11:06:33 <ski>   id :: a -> a
11:06:38 <nai> flip takes  a -> b -> c  and id :: a -> a
11:06:43 <ski>   id :: (b -> c) -> (b -> c)
11:06:54 <nai> ah.
11:06:59 <nai> right
11:07:00 <ski>   flip :: (x -> y -> z) -> (y -> x -> z)
11:07:18 <ski>   flip :: ((b -> c) -> b -> c) -> ((b -> c) -> b -> c)
11:07:31 <ski> er
11:07:39 <nai> messed that up
11:07:40 <ski>   flip :: ((b -> c) -> b -> c) -> (b -> (b -> c) -> c)  -- rather
11:07:48 <ski>   flip id :: b -> (b -> c) -> c
11:07:55 * ski nods
11:08:00 * nai nods back
11:09:03 <Solonarv> 'flip id' AKA 'flip ($)'
11:09:40 <dminuoso> Cale: Were you involved in the @pointless plugin?
11:09:42 <nai> oooh so flip... yeah, that
11:09:56 <nai> flip id x y = id y x = y x
11:10:14 <nai>  = ($) y x = flip ($) x y
11:10:33 <nai> i have to think about this now
11:11:22 <ski> @let evalCont :: Cont o o -> o; evalCont = (`runCont` id); evalContT :: Monad m => ContT o m o -> m o; evalContT = (`runContT` return)
11:11:23 <lambdabot>  Defined.
11:11:29 <dminuoso> dmwit: By the way, thank you for pointing out the real meaning of "referential transparency" the other day.
11:11:52 <ski> @let forEach,forAny :: Foldable t => t a -> Cont Bool a; forEach = cont . flip all; forAny = cont . flip any
11:11:53 <lambdabot>  Defined.
11:12:17 <ski> @let divides :: Integral a => a -> a -> Bool; d `divides` n = n `mod` d == 0
11:12:18 <lambdabot>  Defined.
11:12:36 <ski> > evalCont (do n <- forEach [1 .. 10]; p <- forAny [2,3,5,7]; return (p `divides` n))
11:12:38 <lambdabot>  False
11:12:41 <ski> > evalCont (do n <- forEach [2 .. 10]; p <- forAny [2,3,5,7]; return (p `divides` n))
11:12:43 <lambdabot>  True
11:12:50 <ski> > evalCont (do n <- forAny [2 .. 10]; p <- forEach [2,3,5,7]; return (p `divides` n))
11:12:52 <lambdabot>  False
11:13:19 <ski> dyl : ^ that's a little continuation play, which you might enjoy
11:13:45 <ski> dminuoso : i'm curious about that, elaborate ?
11:14:40 <dminuoso> ski: Are you familiar with Quines or Stracheys works?
11:15:39 <ski> i'm a bit familiar with the notion of referential opacity/transparency, in analytical philosophy (basically about language, and descriptions of things) .. but i'm interested in learning more, getting more useful references
11:15:55 <ski> i'm not sure what work of Strachey you're thinking of, though
11:16:40 <dminuoso> ski: The paper "Fundamental Concepts in Programming Languages" in particular.
11:17:19 <dminuoso> ski: And relatedly: http://www.itu.dk/people/sestoft/papers/SondergaardSestoft1990.pdf
11:17:36 <Cale> dminuoso: Not really, I did work on lambdabot generally a little bit, as I was the one running it for some time.
11:17:48 <ski> (i tend to suggest people perhaps looking at "Referential Transparency, Definiteness and Unfoldability" by Harald Søndergaard,Peter Sestoft in 1987-11-30 - 1990-01-04
11:17:58 <ski> at <http://www.cs.tufts.edu/~nr/cs257/archive/peter-sestoft/ref-trans.pdf>)
11:18:19 <ski> hah, that's the same paper :)
11:18:29 <ski> also, there's
11:18:34 <ski> @where purely-functional
11:18:34 <lambdabot> "What is a Purely Functional Language?" by Amr Sabry in 1993-01 at <https://www.cs.indiana.edu/~sabry/papers/purelyFunctional.ps>
11:19:13 <ski> (also there's <http://stackoverflow.com/questions/210835/what-is-referential-transparency>,<http://www.reddit.com/r/haskell/comments/x8rr6/uday_reddy_on_referential_transparency_and_fp/>,<http://www.reddit.com/r/haskell/comments/xgq27/uday_reddy_sharpens_up_referential_transparency/>)
11:19:53 <nai> god. so much to read.
11:20:23 <ski> you could start with the latter links, if you just want to get a basic gist
11:21:23 <mniip> hmm
11:22:32 <mniip> I should stop using djinn and start using
11:22:36 <mniip> Check ltac:(intuition) : forall p, ~~~~p -> ~~p.
11:22:38 <ski> dminuoso : ty for the paper suggestion. i don't recall reading this one before. any particular section you had in mind ?
11:22:56 <mniip> :)
11:23:19 <ski> mniip : already `forall p, ~~~p -> ~p'
11:23:57 <mniip> sure but I was having a discussion with someone
11:24:04 * ski nods
11:24:14 <ski> `~~' as a monad ?
11:24:16 <mniip> yes
11:24:23 <mniip> actually,
11:24:30 <mniip> is there an elementary adjunction this arises out of?
11:24:33 <ski> @djinn-add type NotNot a = Not (Not a)
11:24:44 <mniip> constructive as a coreflective subcategory of classical?
11:25:06 <ski> hm, maybe a contravariant adjunction, in that case ?
11:25:11 <mniip> hmm
11:25:14 <mniip> I was thinking that
11:25:22 <mniip> but it doesn't quite work
11:25:35 <nai> is ~ curry-howard-isomorphic to negation?
11:25:42 <ski> yes
11:25:50 <nai> what is it?
11:26:03 <ski> or rather, negation corresponds to continuations
11:26:43 <mniip> I mean you do have a functor A |-> A from constructive to classical
11:26:52 <mniip> and a functor A |-> ~~A from classical to constructive
11:26:57 <ski> in SML/NJ, which has continuation side-effects, negation is spelled `cont'
11:27:03 <mniip> are they adjoint? I think so
11:27:05 <ski> negation-elimination is
11:27:18 <ski>   val throw : 'a cont -> 'a -> 'b
11:27:26 <ski> and you can easily prove
11:27:40 <ski>   val lem : unit -> ('a cont,'a) either
11:27:54 <mniip> ~a = a -> False
11:28:00 <ski> yes
11:28:08 <mniip> where False is the uninhabited type, sometimes spelled _|_
11:28:24 <ski> (or `Void', in Haskell, ignoring partiality/bottoms)
11:28:26 <mniip> another possible spelling is  ~a = (forall b, a -> b)
11:28:46 <mniip> which kinda generalizes double negation to Cont
11:28:51 <mniip> ~~ = Cont Void
11:29:04 <ski> (in Djinn, `type Not a = a -> Void'. also there's absurd-elimination, `void :: Void -> a')
11:29:16 <nai> mniip: i see
11:29:20 <mniip> though sadly not all classical tautologies can be proved in a Cont r for arbitrary r
11:29:24 <mniip> you do need the Void occasionally
11:29:44 <ski> mniip : minimal logic vs. intuitionistic logic
11:29:44 <nai> because in logic, not a <=> a -> bottom
11:30:01 <mniip> ski, what's the difference?
11:30:13 <ski> minimal logic has no absurd-elimination
11:30:15 <mniip> does minimal logic not  have EFQ or something?
11:30:16 <mniip> o
11:30:28 <ski> `Absurd' is just "an arbitrary proposition, not known to be provable"
11:30:28 <mniip> paraconsistency :^)
11:30:37 * hackage checkers 0.5.0 - Check properties on standard classes and data structures.  https://hackage.haskell.org/package/checkers-0.5.0 (ConalElliott)
11:30:47 <ski> while `void :: Void -> a' is exactly absurd-elimination (as i already mentioned :)
11:31:37 <mniip> so I think the double negation monad does come from coreflectivity of the embedding of constructive inside intuitionistic
11:31:59 <ski> because of this, one can do tricks like interpreting in a non-standard interpretation, where `Absurd' is set to something particular, in order to extract constructive content out of (some) classical proofs
11:32:11 <mniip> right
11:32:32 <ski> iirc, Chet Murthy and someone has written about this
11:32:40 <anna_> Hi everyone, I'm new to Haskell so bear with me. How do I get an 'Int' value from an expression that returns a 'Maybe Int' value? 
11:32:58 <ski> anna_ : you have to specify what's to happen if there's `Nothing' there
11:32:59 <Cale> anna_: One of the most basic ways would be to use a case expression:
11:33:07 <Cale> case myMaybeInt of
11:33:13 <Cale>   Nothing -> ... handle this case ...
11:33:20 <Cale>   Just n -> ... n :: Int ...
11:33:26 <ski> anna_ : do you want to use some default value ? do you want to take an alternative path in the program )do you just want the program to abort ?
11:33:31 <ski> s/)/? /
11:33:48 <ski> Cale is showing the middle alternative
11:33:59 <ski> (the other ones can be expressed in terms of this one, fwiw)
11:34:02 <anna_> ski: I think I would just want to throw an error (sorry if this is the wrong terminology for Haskell). The expression I'm using is one to find the index of a char in a string
11:34:31 <nai> mniip: ski: may i inquire about your respective academic backgrounds? where/how did you learn math/logic/philosophy/computer science?
11:34:31 <ski> anna_ : do you expect to never get a `Nothing', in a (bug-free) program ?
11:35:52 <ski> anna_ : in that case, you can use `fromJust'. but in case there is actually an unexpected error, that will probably not tell you the line number, so if you (or you and a library together) have used `fromJust' in several places, it might be harder to determine where the error is coming from
11:36:22 <anna_> ski: Okay, thank you. It's only a small program I'm writing, so I think this should be fine for me
11:36:23 <ski> anna_ : an alternative is to use `fromMaybe (error "the impossible happened in module `Foo', function `bar' !")'
11:36:38 <anna_> I'll try both
11:37:08 <ski> anna_ : `fromMaybe' is for supplying a default value. in this case the default value is to raise a particular (more informative) error. the default value won't be evaluated unless you get a `Nothing'
11:37:38 <anna_> ski: sounds like fromMaybe is the more suitable solution for me,tthen
11:37:43 * ski nods
11:38:51 <ski> anna_ : there's also `maybe', which you can use if you either want to use a default value, or immediately supply some function to the `Just' value. in this case the type of the default value can differ from the `Just'ed value
11:39:56 <Cale> > case findIndex (== 'r') "abracadabra" of Nothing -> error "whoops!"; Just n -> 100 * n
11:39:58 <lambdabot>  200
11:40:12 <ski> > [maybe "---" show m | m <- [Just 2,Just 3,Nothing,Just 7]]  -- using a list comprehension to loop through a list of `Maybe' things
11:40:14 <lambdabot>  ["2","3","---","7"]
11:40:51 <ski> > [fromMaybe 0 m | m <- [Just 2,Just 3,Nothing,Just 7]]
11:40:53 <lambdabot>  [2,3,0,7]
11:40:58 <ski> > [fromJust m | m <- [Just 2,Just 3,Nothing,Just 7]]
11:41:00 <lambdabot>  [2,3,*Exception: Maybe.fromJust: Nothing
11:42:18 <mniip> nai, mostly on my own
11:42:19 <Cale> > [ m | Just m <- [Just 2,Just 3,Nothing,Just 7]]
11:42:21 <lambdabot>  [2,3,7]
11:42:26 <mniip> as a hobby
11:42:32 <Cale> ^^ worth noting that you can pattern match there :)
11:43:38 <ski> nai : i started being interested in math at a young age (like around first three years in school, say), because my older brother showed me cool things with equations, complex numbers, primes and factorization, congruences, &c.
11:43:57 <mniip> I am an undergrad in maths and physics
11:43:58 <nai> mniip: nice
11:44:05 <mniip> but I study a lot outside of the curricculum
11:46:17 <ski> nai : i also started programming early (age 6.5, (BASIC) programmable calculator with 544 bytes of RAM available for programs). later BASIC, and assembler on the Commodore 64. i remember reading a book about assembler programming that talking about round-robin queues, sorting, linked lists, thinking "i want to learn more about this" (not knowing the name of the topic)
11:46:20 <nai> i feel like i *only* study outside of the curriculum, and was wondering if it was different for you. seems like you're just advanced hobbyists :D
11:46:34 <nai> ski: that resembles my story so far
11:47:45 <ski> nai : later still, Prolog, C/C++ (sic !), Java, Haskell, Scheme, SML, &c. .. starting to read Haskell papers (linked from <news:comp.lang.functional>, and HaWiki), then type theory papers, then logic papers (and then also category theory, &c.)
11:48:15 <ski> (i had also borrowed logic books at the library, previously, some of them going a bit into related philosophical issues as well)
11:48:41 <nai> i think the next step for me is to start reading papers instead of haphazardly skimming over wikipedia articles and blog posts
11:49:08 <ski> i suggest starting with Wadler papers, and other early, important, papers related to Haskell
11:49:18 <ski> Simon Peyton-Jones
11:49:45 <ski> and other people that i can't pick out immediately from memory
11:50:02 <nai> suggestions taken
11:50:19 <ski> also, if you don't understand something, skip it for the time being. perhaps try later again, after seeing example sections
11:50:57 <ski> if you need to, try to find some paper references in the bibliography, which goes more into basic details or which surveys things
11:51:16 <ski> be bold
11:58:02 <ski> Mark Jones,Graham Hutton are at least two other persons i had in mind
12:25:29 <sicklorkin> I have a function that was type Stream (Of a) m () and I wanted to modify it to instead return `Stream (Of (Either String a)) m ()` so that I could wrap decoding errors up to the callers.  The code I added was yield a -> yield $ Right a; and `error msg` to yield $ Left msg.  Here's the type error https://pastebin.com/vPzr1nBv
12:26:48 <sicklorkin> I don't understand why it thinks a in (Either String a) is an infinite type
12:39:01 <absence> with a type like "data Test a = forall s. Test (s, State s a)", is it impossible to extract the s?
12:40:57 <cocreature> absence: depends on what you mean by “extract”
12:41:33 <cocreature> you can pass the s to evalState
12:42:14 <absence> cocreature: right, but not runState?
12:42:43 <cocreature> you can’t write anything like "Test a -> s"
12:43:02 <cocreature> that would mean that the caller gets to choose "s" but you cannot provide an arbitrary "s"
12:44:06 <absence> yeah, that makes sense. interesting that you can have values that are "locked" inside a scope :)
12:44:42 <cocreature> you can also write something like "eliminate :: (forall s. s -> State s a -> r) -> Test a -> r
12:45:03 <cocreature> so if the caller gives you something that can handle an arbitrary "s" then you can call it and give them back the result
12:47:32 <vaibhavsagar> absence: this is how the ST machinery works
12:48:14 <vaibhavsagar> `runST` gets to choose the `s`, so you have to pass it a computation that will work for an arbitrary `s`
12:48:53 <vaibhavsagar> and then it doesn't matter which `s` it chooses
12:49:13 <vaibhavsagar> like a baton in a relay race
12:49:34 <vaibhavsagar> where the baton itself is unimportant, but it enforces an ordering which is
12:51:40 <ski> conceptually, you can think of the `s' chosen as a tuple `(Int,Int,[Char],Array Int Double,...)', that corresponds to the `newSTRef' and `newSTArray' operations that you execute in that state thread
12:52:37 <ski> (the main problem with that interpretation is that it's not statically / a priori determined, beforehand, which allocations a state thread will perform. a better model would be to change the state type as we go .. but that would require an indexed monad)
12:54:17 <ski> absence : `Test a' is iso to `exists s. (s,State s a)', or to `exists s. (s,s -> (a,s))', which is iso to `[a]' (infinite list, iow a stream)
12:54:58 <ski> (you can feed the output `s' back through the state transformer, getting a new `a' and a new `s', and so on. so in the end, you get an infinite list of `a's)
12:57:01 <ski> anyway, the above conceptual view should explain to you that `STRef's (and `STArrays') doesn't (conceptually) "contain" the values they reference. they are only like array indices, or finite map keys, or, indeed, like memory addresses, that you can't do much with, without a corresponding array to index, a finite map to lookup a corresponding value in, or a memory to address
12:57:34 <ski> however, it *does* explain why there's `Eq' instances for `STRef s a' and `STArray s i a' that *doesn't* require / depend on `Eq a'
12:59:24 <ski> (you can compare the indices/keys/addresses themselves, without comparing what they reference (which would entail being able to indirect through them, which is not possible in this context, since you don't get access to the state in which those values reside))
13:02:55 <reallymemorable> Does anyone on here have much experience with scalpel?  I am trying to pull all of the strings inside links that end with `.csv.gz` -- from elements like this: <a href="al_od_main_JT05_2015.csv.gz">
13:13:27 <absence> thanks for the explanations!
13:23:12 <sicklorkin> reallymemorable: looks like some combination of "a" @: [ "href" @=~ YourRegEx ]
13:24:03 <jkachmar> Hey all, I'm hitting a _particularly_ uncomfortable edge case with linking and I've run out of resources within GHC to turn to
13:24:35 <jkachmar> Anyone familiar with how one might go about _selectively_ statically linking in libraries when compiling an application with GHC?
13:25:27 <jkachmar> For context: I'm building my application with a version of GHC that supports musl, and I'd like to statically link in everything _except_ for libgmp (since that would put me in violation of the LGPL if I want to distribute a closed source binary)
13:26:09 <vaibhavsagar> and you can't use integer-simple for performance reasons?
13:26:43 <jkachmar> The closest I've gotten so far is the following set of `ghc-options`
13:26:43 <jkachmar> `-rtsopts -threaded -fPIC -optl=-pthread -optl=-static -optl=-Wl,-Bdynamic,-lgmp,-Bstatic`
13:26:43 <jkachmar> ... but for whatever reason this hoses up the linker _bad_
13:26:49 <reallymemorable> sicklorkin: yes but I'm having trouble selecting partial strings
13:26:56 <reallymemorable> `(TagString "a") @: [(AttributeString "href") @= "*.gz"]`
13:27:00 <reallymemorable> i need something like that
13:27:08 <reallymemorable> but `*` notation isn't in scalpel
13:27:24 <jkachmar> vaibhavsagar: Yeah, it turns out that `cryptonite` uses GMP heavily to optimize its cryptographic ops, so if you make a lot of calls using `http-client-tls` then the performance really tanks with `integer-simple`
13:28:28 <jkachmar> With that set of `ghc-options`,  I _do_ get a dynamically linked `libgmp`, but it loses the ability to "find" `musl` libc when linking the application
13:28:36 <jkachmar> I get something like:
13:28:36 <jkachmar> ```
13:28:36 <jkachmar> 	/lib/ld64.so.1 (0x7f5b607f5000)
13:28:36 <jkachmar> 	libgmp.so.10 => /usr/lib/libgmp.so.10 (0x7f5b60790000)
13:28:36 <jkachmar> 	libc.musl-x86_64.so.1 => /lib/ld64.so.1 (0x7f5b607f5000)
13:28:36 <jkachmar> ```
13:28:55 <jkachmar> and `./my-exe` just gives me a "No such file or directory" result
13:29:28 <jkachmar> Every other combination of `-optl=-static`, `-Wl,-Bdynamic,-Bstatic`, etc. just doesn't work
13:29:31 <vaibhavsagar> could you use `patchelf` to make the executable find `musl`?
13:30:32 <vaibhavsagar> https://github.com/NixOS/patchelf
13:30:37 * hackage servant-namedargs 0.1.1.1 - Combinators for servant providing named parameters  https://hackage.haskell.org/package/servant-namedargs-0.1.1.1 (CullinPoresky)
13:31:03 <jkachmar> Well, I don't want `musl` to actually _be_ dynamically linked in
13:31:18 <jkachmar> Because the target machine might not have `musl` installed
13:31:40 <jkachmar> But my understanding of `patchelf` might be flawed
13:32:20 <jkachmar> My goal here is just to find some way to make GHC produce an executable which _only_ depends on `libgmp` when one runs `ldd` on it
13:38:24 <vaibhavsagar> I just asked my colleague and apparently this is doable with nixpkgs
13:38:40 <ski> absence, np
13:38:51 <vaibhavsagar> but my other colleague is not so sure
13:39:14 <jkachmar> Really? I figured this would be entirely within the realm of GHC's linker options.
13:39:46 <jkachmar> The only thing I can think of w/ nixpkgs would be if I could bundle up a closure that has all the dynamic stuff inside of it
13:39:48 <vaibhavsagar> their explanation was that you would have to finely control the available libraries
13:39:58 <jkachmar> but from the user's perspective it's as if everything is in one package, opaquely
13:40:38 <vaibhavsagar> i.e. all libraries are available statically and not dynamically except libgmp, which is only available dynamically
13:41:36 <vaibhavsagar> but you could also do the closure thing with Nix
13:41:37 * hackage servant-server-namedargs 0.1.1.1 - Automatically derive API server functions with named and optional parameters  https://hackage.haskell.org/package/servant-server-namedargs-0.1.1.1 (CullinPoresky)
13:42:37 * hackage servant-client-namedargs 0.1.1.1 - Automatically derive API client functions with named and optional parameters  https://hackage.haskell.org/package/servant-client-namedargs-0.1.1.1 (CullinPoresky)
13:43:30 <jkachmar> Hmm... so if I'm understanding this, even with `-optl=-static`, if `libgmp.a` just wasn't available anywhere GHC would throw its hands up and dynamically link it?
13:44:45 <vaibhavsagar> possibly, although we haven't tried this
13:52:37 <jkachmar> vaibhavsagar: no dice, I think. If I purge `libgmp.a` from my system the linker complains about not being able to find `-lgmp` when `-optl-static` is enabled
13:58:22 <geekosaur> the only way to do this is to explicitly link in libgmp.so with a full pathname to it. it's not a ghc limitation, ghc ultimately hands this to ld (via the C compiler, usually) and ld has no other way to do it
13:59:07 <jkachmar> geekosaur: When you say "explicitly link in", what do you mean though? `optl=-static` _aggressively_ attempts to statically link everything
13:59:23 <jkachmar> I've tried providing the full path to `ghc-options` and it doesn't seem to be picking it up
13:59:32 <jkachmar> hence all these weird `-Bstatic`, `-Bdynamic` incantations
13:59:51 <geekosaur> it's passed to ld, which ignores .so when searching for libraries if that option is set
14:00:03 <geekosaur> but it will link in anything given via a full pathname instead of -l...
14:01:21 <jkachmar> Just so I understand what you're getting at, something like this should work:
14:01:21 <jkachmar> ```
14:01:21 <jkachmar> ghc-options: "-rtsopts -threaded -fPIC -optl=/usr/lib/libgmp.so -optl=-pthread -optl=-static"
14:01:21 <jkachmar> ```
14:01:21 <jkachmar> ?
14:01:35 <vaibhavsagar> jkachmar: https://stackoverflow.com/a/809821
14:02:06 <vaibhavsagar> basically pass in `-l:libgmp.so`
14:03:00 <fragamus> Hi does gRPC get much use in the Haskell community
14:03:07 * hackage reflex 0.6 - Higher-order Functional Reactive Programming  https://hackage.haskell.org/package/reflex-0.6 (abrar)
14:05:19 <jkachmar> vaibhavsagar: I don't think that works, at least if I try the following I _don't_ get a statically linked `libz`:
14:05:19 <jkachmar> ```
14:05:19 <jkachmar> ghc-options: "-rtsopts -threaded -fPIC -optl=-pthread -optl=-l:libgmp.so -optl=-l:libz.a"
14:05:19 <jkachmar> ```
14:06:37 * hackage reflex-dom-core 0.5 - Functional Reactive Web Apps with Reflex  https://hackage.haskell.org/package/reflex-dom-core-0.5 (abrar)
14:07:17 <vaibhavsagar> jkachmar: I think the way that option works is confusing
14:07:21 <vaibhavsagar> see https://sourceware.org/binutils/docs-2.18/ld/Options.html
14:07:41 <vaibhavsagar> "If namespec is of the form :filename, ld will search the library path for a file called filename, otherise it will search the library path for a file called libnamespec.a. "
14:08:14 <vaibhavsagar> so you probably want -optl=-lz
14:08:23 <fragamus_> Gah I keep losing my connection so I can’t tell if anyone answered about grpc
14:08:34 <jkachmar> fragamus_: 
14:08:50 <jkachmar> `grpc` doesn't see much use in Haskell, awakesecurity has a library but it's not widely used outside of their organization
14:08:52 <vaibhavsagar> "On systems which support shared libraries, ld may also search for files other than libnamespec.a. Specifically, on ELF and SunOS systems, ld will search a directory for a library called libnamespec.so before searching for one called libnamespec.a. (By convention, a .so extension indicates a shared library.) Note that this behavior does not apply to :filename, which always specifies a file called filename. "
14:09:07 * hackage reflex-dom 0.5 - Functional Reactive Web Apps with Reflex  https://hackage.haskell.org/package/reflex-dom-0.5 (abrar)
14:09:24 <vaibhavsagar> this matches what my colleague was telling me about finely controlling libraries
14:10:01 <jkachmar> Right, but even if I finely control my library structure it looks like I'm hosed
14:10:17 <vaibhavsagar> why?
14:10:38 <vaibhavsagar> use `-l:libgmp.so` for GMP, and `-l<library>` for everything else
14:11:18 <vaibhavsagar> make sure you don't have `.so`s for any libraries you want linked statically
14:15:45 <jkachmar> Looks like `libz.so.1` is needed for `musl/cc1`...
14:15:45 <jkachmar> ugh
14:27:37 * hackage HsHTSLib 1.9.2 - Bindings to htslib.  https://hackage.haskell.org/package/HsHTSLib-1.9.2 (kaizhang)
14:30:07 * hackage approveapi 0.1.0.0 - ApproveAPI Haskell Client  https://hackage.haskell.org/package/approveapi-0.1.0.0 (kcking)
14:58:49 <nek0> hi folks. I am laying out tools for a oncoming project. What library would you use to interface a postgres database from Haskell?
14:59:18 <nek0> so far I found opaleye, which looks rather nice, but unfortunately does not create tables bvy itself.
15:03:27 <Clint> nek0: persistent creates tables but isn't very good with relational stuff
15:04:06 <nek0> Clint: I used persistent in the past. It has indeed the elegance of a shotgun.
15:04:34 <tdammers> call me old fashioned, but I prefer creating the tables with SQL
15:05:05 <tdammers> in fact, basic application security says your normal application user shouldn't even have permissions to execute DDL queries
15:07:07 <nek0> tdammers: you are right...
15:10:07 <sternmull> nek0: I use postgresql-simple and am quite happy with it. I create my database with simple shell script from outside Haskell and do only queries inside the program. Personally i never got happy wih ORM stuff. I am not an SQL expert but i find it simpler to write my queries directly in SQL syntax than learning a highly abstract API that does that for me and that introduces additional complexity and limits.
15:10:42 <slack1256> Spoken like a true ORM survivor
15:12:41 <koz_> A somewhat-related piece of writing: http://blogs.tedneward.com/post/the-vietnam-of-computer-science/
15:17:42 <ski> SQL is sortof both heaven and hell
15:17:45 <hpc> that post is great
15:20:43 <hpc> i am increasingly convinced the database should be treated the same way you would any other external service
15:21:13 <hpc> treat it completely in isolation, make its api as small and regular as you can
15:21:25 <hpc> and do whatever you do to all your other apis
15:23:51 <phadej> well... for some web APIs people provide schemas (!) so you can generate clients
15:24:04 <phadej> protobuf, thrift, swagger
15:42:17 <jkachmar> vaibhavsagar: I've gotten profiling info back for this, on the off chance you're curious. `integer-simple` absolutely ruins `cryptonite`'s performance for a bunch of operations
15:43:22 <jkachmar> This application in particular is using the _extremely_ bad practice of spawning a new `Manager` per `http-client` call (which appears to be where a lot of the cost is bundled up), but it goes from spending no significant amount of time in `cryptonite` to spending _half_ of all execution time in `Crypto.Number.ModArithmetic expSafe`
15:44:37 * hackage bioinformatics-toolkit 0.6.0 - A collection of bioinformatics tools  https://hackage.haskell.org/package/bioinformatics-toolkit-0.6.0 (kaizhang)
16:41:34 <bsima> can anyone see why this xmonad config doesn't spawn rofi? I have no idea why it doesnt' work https://git.sr.ht/~ben/config/tree/master/xmonad.hs#L32-34
16:42:45 <Shockk> maybe what I want to do can't be done, but I'm trying to use the following type alias:
16:42:58 <Shockk> type Analysis = Show a => Either (String, a)
16:43:24 <Shockk> I'm wanting to use this so that I can return some value that's a Show, in the event of a failure, but without worrying about what type that value is
16:43:30 <Shockk> is this kind of thing possible?
16:44:17 <bsima> Shockk: you want 'Either String a' without the parens
16:44:24 <bsima> and maybe a newtype?
16:44:53 <__Myst__> Hi. I'm getting some surprising behavior from the StateT monad transformer. I'd expect the Alternative instance to use <|>, however it seems to use mplus?
16:45:14 <Shockk> bsima: hmm, I mean, I want `a` to be constrained by Show though
16:45:45 <mniip> Shockk, that should work
16:45:54 <mniip> but mind that you cannot use this alias outside of implicatoins
16:46:00 <mniip> because that would require impredicativity
16:46:02 <Shockk> hmm
16:46:06 <mniip> which GHC doesn't do
16:46:09 <mniip> consider an existential
16:46:28 <Shockk> existential sounds familiar, might be what I'm wanting
16:46:51 <Shockk> like, I have multiple functions that I'd like to be of type Show a => Either (String, a) r
16:47:14 <Shockk> but each of them would be returning a different a, but I want to.. err, I'm not sure exactly how to describe what I want tbh lol
16:48:20 <Shockk> forgive my likely incorrect terminology but I think what I want is a polymorphic type constrained by Show, so that these functions can all coexist within the same Either (String, a) monad context, but outside of that context, the value I get back is just something that I can call `show` on
16:50:04 <Shockk> does that make sense/
17:00:04 <mniip> Shockk, that sounds like an existential
17:00:08 <Shockk> ahh okay
17:00:18 <Shockk> I'll look into that, I have some memory of it
17:00:44 <Shockk> I need to define my own existential type for it right? and then use that like `Either (String, MyExistential)` right?
17:01:25 <mniip> you could use that yes
17:02:37 * hackage b9 0.5.68.1 - A tool and library for building virtual machine images.  https://hackage.haskell.org/package/b9-0.5.68.1 (SvenHeyll)
17:02:42 <Shockk> great, thanks very much
17:06:12 <Shockk> (for context, I just want to be able to return a contextual showable value along with an error msg, so that I can then pretty-print it in a single place in my actual executable)
17:28:57 <ski> Shockk : btw, note that your `Analysis' type (or rather, the type you intended to express with that) is expressing (is isomorphic to) the type `exists a. Show a *> Either (String,a) r'
17:30:57 <ski> (hm, i should probably say, the type `Analysis r', since you need/want to parameterize by that tyvar, unless you're fixing a particular `r', rather than allowing different ones in different contexts)
17:32:05 <ski> (also, note that i said, `*>', not `=>'. that's part of the point i wanted to draw your attention to)
17:32:34 <ski> (there's also another issue here, namely whether there is much *point* in using an existential here, in this situation)
17:34:41 <Solonarv_> IMO the answer is "probably not"
17:34:54 * ski smiles
17:35:07 <Solonarv_> you have a value, but the only thing you can do with it is to cáll 'show' on it (which gives you back a string)
17:35:18 <Solonarv_> why not just store said string directly?
17:35:18 <ski> hm, if you go for the `Either (String, MyExistential) r' route (i missed this at first), then that's expressing `Either (String,exists a. Show a *> a) r', rather than what i expressed above, which is almost the same thing (and this is related to what Solonarv_ is saying)
17:35:31 * ski waits for Shockk to respond
17:38:18 * ski . o O ( `Either Int Natural -> ShowS' )
18:12:14 <sicklorkin> ignore #anime! QUITS
18:12:16 <sicklorkin> ignore #anime! QUITS
18:13:57 <sicklorkin> phadej: do you know of a good swagger client generator? the one on swagger does a terrible job
18:54:05 <Shockk> sorry, I was busy for a while
18:54:16 <Shockk> "Solonarv_ | why not just store said string directly?"
18:54:56 <Shockk> Solonarv: my reasoning is just that I want to call a pretty print function that operates on a Show a => a
18:55:38 <Solonarv> there is only one way to write such a function, which is to parse the output of 'show'
18:56:06 <Solonarv> all the libraries for that which I know of also let you directly pass a string to prettify
18:56:10 <Shockk> oh hmm
18:56:15 <Shockk> I'll take a look for that then
19:15:46 <sm> pretty-show ?
19:15:58 * ski notices Shockk reappeared
19:16:09 <sm> or what's the latest one
19:17:48 <ski> Solonarv : btw, one reason i was thinking of was that, *maybe*, you want to only get stuff that's actually in instances of `Show', rather than arbitrary `String's (otoh, you could always make a silly custom type, breaking expectations (though i suppose you couldn't construct that instance at run-time, depending on run-time input, without a trick like in `reflection' ..))
19:18:15 <Solonarv> ski: there's a very easy way to produce arbitary strings...
19:18:26 <Solonarv> % newtype ShowId = ShowId String
19:18:26 <yahb> Solonarv: 
19:18:54 <Solonarv> % instance Show ShowId where show (ShowId s) = s
19:18:54 <yahb> Solonarv: 
19:19:04 <ski> Solonarv : yes, .. as i mentioned :)
19:19:39 <Solonarv> and it's not like there are restrictions on the output of 'show' that are actually consistently obeyed in practice
19:20:29 <ski> well, imho, we should strive towards getting more consistency there, more consensus
19:22:19 <ski> (as examplified by the "`Show' is intended for debugging / interactor sessions" claims)
19:23:17 <Shockk> I might be wrong but I was under the impression that the output of Show should usually be readable into the same value by a Read instance
19:24:07 <ski> yes, that is (imho) the proper way to make a `Show' instance
19:24:07 <Solonarv> yes, but that's only meaningful when there is a Read instance as well
19:24:26 <Shockk> true
19:24:29 <Solonarv> more precisely, a 'Show' instance is supposed to output valid Haskell that will reconstruct the original value
19:24:45 <Shockk> ah okay
19:25:10 <ski> (also, it should, imho, emit a textual representation (in Haskell syntax) of an expression that, when evaulated in an appropriate environment (with modules in scope, say), gives back the original value)
19:25:36 <ski> (within reasonable constraints, of course. infinite values, and partial values, would be hard to get that behaviour for)
19:26:20 <ski> (there also ought to be a methodless common subclass of `Show' and `Read')
19:27:33 <ski> commonly, this means that it should output the data constructors (namely, in case they are exported). using `showsPrec',`showParen' correctly in the implementation (and `readsPrec',`readParen', for `Read')
19:27:49 <Shockk> has anyone tried creating a class that can be used to define both serialization and deserialization at once, without needing conceptually asymmetric instances for read/show?
19:28:06 <ski> (you should almost always define `showsPrec' and `readsPrec', not `shows' and `reads', if you do make manual instances of `Show' and `Read')
19:28:21 <Solonarv> also, if a type contains e.g. functions, IORefs and other such types it's IMO fine to have a technically-incorrect Show implementation
19:28:42 <Solonarv> (since a correct one is impossible to write, but it's still nice to get debugging output)
19:28:59 <ski> > listArray (0,9) [n^2 | n <- range (0,9)]  -- this is an example of when there is no exported data constructors. `Array' is an abstract data type
19:29:01 <lambdabot>  array (0,9) [(0,0),(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81)]
19:29:31 <ski> (so in this case what should be done is to represent the value, in terms of the exported abstract data type operations)
19:30:05 <Shockk> like, I wonder if it would be possible to define a class that can be used to define serialization/deserialization behaviour both at once, using lenses perhaps
19:30:46 <ski> people have been pondering that problem situation before
19:31:20 <ski> @hackage boomerang
19:31:20 <lambdabot> http://hackage.haskell.org/package/boomerang
19:31:46 <ski> (there may well be more, i haven't closely kept track)
19:32:06 <ski> in Prolog, you can (at least in theory), do this, with DCGs
19:32:34 <Shockk> hmm ah interesting so it does it with th
19:33:22 <ski> (in practice, often this is not so practical, at least if one doesn't plan for it from the start, and also in some cases make separate implementations of (sub-)parsers/printers)
19:34:42 <ski> sometimes i wonder whether an on-line debugger/shower thingy, like `Browse' in Oz, would be better
19:35:29 <Shockk> somewhat unrelated but I'm finally making strides of progress implementing my type system
19:36:07 <ski> any novel aspects or features of it ?
19:36:38 <Shockk> can now parse and semantically analyse stuff like `bool = <>  true = <>:bool  false=<>:bool`, it just doesn't resolve the "bool" in those kind sigs yet
19:37:15 <ski> i don't understand those three declarations
19:37:18 <Shockk> going to do name resolution in a later pass because I need to at least do an initial pass to build a picture of all the defined names before I can resolve everything
19:38:19 <ski> what is that `<>' thing ?
19:38:20 <Shockk> the idea is that bool=<> sets the name "bool" equal to a new type with no type parameters and no context values held within it
19:38:38 <ski> hm. so generative types ?
19:38:38 <Shockk> er let me show you what my WIP syntax for maybe is, and it might be a bit clearer
19:39:05 <Shockk>  maybe = t -> <t>    just = t -> <t> : maybe <- t    nothing = t -> <> : maybe <- t
19:40:20 <Shockk> might change because I'm not exactly sure if making `just` and `nothing be types of kind `maybe` is the way to go 
19:40:55 <Shockk> but the idea partially comes from DataKinds in haskell
19:45:53 <ski> Shockk : hm, ok
19:46:04 <ski> no ordinary data types ?
19:46:11 <Shockk> errr, that's the question I guess, lol
19:46:24 <Shockk> I guess my goal right now is to see if this is a viable type system or not
19:46:44 <ski> (seems a bit strange to me, to have data kinds, but not (?) data types. but perhaps there could be a use case)
19:47:15 <ski> (well, you said `bool' before was a type, not a kind. so that is a data type ?)
19:47:26 <Shockk> oh, I didn't really explain that I guess
19:47:42 <Shockk> `bool=<>` defines bool as a type, but types can be used as a kind
19:47:57 <ski> so `maybe' is also a type ?
19:48:03 <Shockk> yes
19:48:13 <ski> and `true' and `false' are values, as well as types ?
19:48:22 <ski> (and similarly for `nothing' and `just')
19:48:30 <Shockk> errr, well with the current method of thinking, true/false and nothing/just are types, not values
19:48:38 <ski> ok
19:48:42 <Shockk> but like I said I'm not really sure it's the right way of thinking
19:48:47 <ski> are there any values at all, in the language ?
19:49:23 <Shockk> true <- () would create a new true value
19:49:36 <Shockk> but that seems a little absurd now that I'm actually thinking about it a lot
19:49:52 <Shockk> it might make more sense just to have some way of defining true/false as data constructors of a type
19:49:56 <ski> what seems a little absurd ?
19:50:03 <Shockk> the premise
19:50:08 <ski> being ?
19:50:49 <Shockk> I mean, thinking about it more, it might make more sense just to do them as data constructors rather than types of a data kind
19:51:14 <ski> what was the line of thought that led you towards wanting them to be types of a data kind ?
19:51:45 <Shockk> hmm, I guess I thought it would allow more flexibility to kind of use types in a higher-kinded way
19:52:48 <ski> well, there are situations where one can argue that data kinds make sense (otherwise they wouldn't have been included in GHC)
19:52:50 <Shockk> it probably would but I'm trying to think about how I would even define some function to take a `maybe` and then be able to match if it's `just` or `nothing`, if just/nothing are types
19:53:04 <ski> but is there an argument for not including data types, in that case ?
19:53:32 <ski> well, you could have such a *type* function, certainly
19:53:48 <ski> (but probably not a value function, without having data types, or something like that)
19:56:28 <Shockk> hmm what you said just now gave me an idea, perhaps I can say, `bool=<>` defines bool to be a value of generic kind, so then it would mean I could use bool as the only value of a single type if I wanted to, or I could use bool as the type of some other value
19:56:55 <Shockk> doing it that way would then implicitly also allow bool to be used as a data kind as well
19:58:24 <Shockk> that gives me ideas for then also being able to write functions that operate on values of generic kind, so that they would theoretically be able to operate at the type level
20:00:42 <Shockk> Solonarv: wow I have a comment in my code from like half a year ago that mentions you
20:00:49 <Shockk> "-- t hanks to Solonarv from #haskell for this gem"
20:00:55 <Solonarv> o_O
20:01:00 <Shockk> lol
20:01:05 <Solonarv> I remember no such thing!
20:01:27 <Shockk> it's just a definition:  locally :: MonadState s m => m a -> m a    locally action = (action <*) . put =<< get
20:01:32 <Solonarv> oooh I remember now
20:01:35 <Shockk> haha
20:04:15 <rotaerk_> hmm resourcet is kind of annoying when you frequently build monad transformers...
20:04:51 <ski> Shockk : ok, hmm ..
20:04:54 <rotaerk_> end up having to add a dependency on unliftio-core just to make it an instance of MonadUnliftIO so that it doesn't break when ResourceT pops up in your stack
20:05:03 <ski> .. not sure what "value of generic kind" means, though
20:05:23 <Shockk> ski: I mean like how with datakinds you can use a type as a type or as a kind
20:05:55 <Shockk> so I mean like, x=<> would declare x as a value of a new type, with no data in it
20:06:23 <Shockk> but I could also use x as a type of some other value like:  y = <> : x
20:06:38 <Shockk> and y = <5> : x would fail as it doesn't match the type
20:07:01 <Shockk> and then I could also do z = <> : y, hence using y as a type, so therefore x would actually be the kind of y there
20:08:03 <ski> well, i more think of `DataKinds' as allowing (say) `data Bool = False | True' to be interpreted both as a data type definition, and as a data kind definition, so that one gets a data type `Bool' with constructors `False',`True', and *also* get *unrelated* data kind `Bool' with constructors `False',`True'
20:08:33 <ski> what would be the type of your `x' there ?
20:08:34 <Shockk> that's kind of what I mean
20:09:02 <ski> (i don't know what you intend `<5>' to mean)
20:09:07 <Shockk> i.e. x would be a defined value of a new unique type, but if I use the name x anywhere as a type, then it'd be used as a type
20:09:48 <ski> which type is that new unique type ? also, what is the kind of that type ?
20:10:34 <redpunch> https://hastebin.com/usuhocesud.cs I receive that error despite having a constraint `, hsc2hs  == 0.68.3` in my cabal.project file. Any idea why the constraint is being ignored?
20:10:52 <Shockk> sorry hold on got to go afk
20:10:59 <ski> Solonarv : hm, so like a state-to-reader-to-state roundtrip ..
20:11:50 <Solonarv> ski: not quite - the inner action can modify the state, and later parts of the inner action will see the modified state
20:11:56 <Solonarv> it'll just be reset at the very end
20:13:33 <keep_learning_M> Hi Everyone, what is equivalent command of ghc -i/Users/keep_learning/.gettc/include/haskell -outputdir ../../build/haskell -o ../../build/haskell/DigitHolesSolver DigitHolesSolver.hs  for using stack ghc. (I figured out -i could be replaced by --extra-lib-dirs  and -output could be replaced by --local-bin-path but I can't figured out -o )
20:14:15 <Solonarv> this is different from going through Codensity ((->) e) which I think completely discards any 'put's
20:15:26 <keep_learning_M> Or any other solution would also be great help. 
20:16:10 <Solonarv> keep_learning_M: is there a particular reason you're using 'stack ghc' instead of 'stack build' ? in other words, why invoke ghc directly? a large part of stack's purposeis handling that for you
20:16:59 <ski> Solonarv : how's that different from what i said ?
20:17:39 <ski> hm, i don't see why you mention `Codensity (e ->)'
20:17:45 <keep_learning_M> Solonarv, I am using a tool to solve some programming contest problems in Haskell , and it generates a Makefile which assumes system-level ghc 
20:18:57 <keep_learning_M> I can install system-level ghc but I am just curious if it can be done with stack ghc 
20:19:57 <Solonarv> keep_learning_M: you can use 'stack exec -- SOME_COMMAND' to run SOME_COMMAND with ghc & related stuff in its path
20:20:01 <geekosaur> in general if you're using stack ghc you are not going to be able to use options like -outputdir. this said, you may be able to do it with 'stack ghc -- ...'
20:20:17 <geekosaur> you will be fighting stack though, since it wants to control some of those options
20:20:23 <Solonarv> or even 'stack exec -- bash' to drop into a bash shell with ghc&friends on the path
20:20:31 <keep_learning_M> Solonarv, Thank you 
20:21:01 <geekosaur> you can also try that or adding stack's private ghc to $PATH but that's another way to potentially confuse stack if things get installed into its private storage without telling it
20:22:07 <Solonarv> actually, adding one of stack's GHCs to $PATH seemed to work just fine for me; I used that to install ghc for quite some time
20:23:55 <Solonarv> ski: I mentioned Codensity (e->) because it relates Reader and State to each other
20:24:45 <Solonarv> (specifically, liftCodensity lifts 'Reader e' into 'State e' using the obvious method, and 'lowerCodensity' lowers 'State e' to 'Reader e' by discarding every 'put')
20:24:45 <geekosaur> Solonarv, yes, it'll work until you accidentally install something into its package db, and then stack will be confused because it doesn't know it's there but its ghc does
20:25:09 <geekosaur> and at some point ghc will then use that instead of the one stack intends it to use
20:25:12 <Solonarv> Ah, dang
20:28:31 <redpunch> https://hackage.haskell.org/package/bytestring has a dependency on integer but integer is not a package on hackage. What is this sorcery?!
20:31:23 <redpunch> I also noticed that in haskell-gi-base's cabal file hsc2hs is under build-tools and not build-depends, could that be why it ignores my constraints?
20:31:30 <Solonarv> redpunch: looking at its cabal file, that dependency is only needed for ghc >= 6.9 and < 6.11
20:31:44 <Solonarv> https://hackage.haskell.org/package/bytestring-0.10.8.2/bytestring.cabal
20:31:48 <geekosaur> redpunch, try the [details] link. it was needed for one specific ghc revision
20:31:53 <redpunch> Yea but I was still expected to find the package on hackage
20:32:05 <redpunch> Was that not the case back then?
20:32:14 <geekosaur> I think it was briefly there as a boot library provided as part of ghc
20:32:30 <Solonarv> I don't know why hackage is picking up that dependency though
20:32:30 <geekosaur> and not all of those are necessarily hackage-able
20:32:46 <geekosaur> (which is proabbly why it went away subsequently, since that does cause confusion)
20:33:19 <redpunch> geekosaur, got any other examples of libraries that arent on hackage off the top of your head?
20:33:33 <geekosaur> not off the top of my head, no. will probably be similar
20:33:43 <Solonarv> I actually think all the boot libraries are on hackage nowadays
20:33:48 <redpunch> nw, was simply curious about it
20:33:50 <Solonarv> let me check
20:33:59 <geekosaur> I think the idea was a wrapper for the integer stuff, since thrre are two possible implementations: integer-gmp and integer-simple
20:34:26 <geekosaur> the latter being very slow but doesn't bring a GPLish license into it, which some commercial entities prefer
20:35:42 <redpunch> cool. Any thoughts about the hsc2hs issue?
20:36:13 <geekosaur> I poked a little but didn't see where it came from, specifically not why it wants base >= 4.12
20:36:19 <geekosaur> that may come from some other dependency
20:37:01 <redpunch> http://hackage.haskell.org/package/hsc2hs-0.68.4 if you see this, it depends on base > 4.12
20:37:30 <geekosaur> hm, thought I checked that one.
20:37:36 <geekosaur> hm, no, I looked at the one you named
20:37:47 <redpunch> So i tried to constrain it to 0.68.3 and I guess since its a build-tool It has to be constrained in a different way?
20:37:51 <geekosaur> so you have something explicitly requiring that version, and overriding it won't work
20:38:32 <redpunch> I dont think that is what is happening. I think haskell-gi-base lists it under build-tools and the solver is fetching the latest
20:38:34 <geekosaur> also hsc2hs comes with ghc and I'm not sure a different version can be installed
20:39:05 <redpunch> and the latest depends on base outside what I have in my project (8.4.3 -> >=4.9 && <4.12)
20:43:09 <redpunch> What is that `exe.` syntax in haskell-gi-base:hsc2hs:exe.hsc2hs I have never seen dependencies listed like that
20:43:16 <geekosaur> dunno. build-tools are somewhat difficult to deal with and in general you can't select a version except via a versioned executable name
20:43:32 <geekosaur> there is no way to tell 'hsc2hs' which version to be, it *is* some particular version
20:43:51 <geekosaur> that's a target in cabal 2+ syntax
20:44:13 <geekosaur> as distinct from a library target
20:44:25 <geekosaur> or a test target etc.
20:45:38 <Solonarv> I thought those were <package>:<component-type>:<component-name> ?
20:45:51 <redpunch> Hmm, doing  $hsc2hs gives back `Install package 'ghc-compiler' to provide command 'hsc2hs'? [N/y]` 
20:46:09 <geekosaur> that is because it's inside stack
20:46:14 <redpunch> maybe ghcup misses installing it?
20:46:21 <geekosaur> that is, it's where stack's ghc is, because it's installed along with ghc
20:46:30 <redpunch> I dont use stack, I am using ghcup + cabal
20:46:36 <geekosaur> wait, sorry, you;re not that peron
20:46:45 <Solonarv> haha
20:46:49 <geekosaur> I don't know ghcup, don't know if it's around
20:47:04 <geekosaur> it may need to be separately installed because cabal assumes it came with ghc
20:47:29 <redpunch> Solonarv, by your classification, hsc2hs would become the component-type. That sounds like a name to me
20:47:46 <Solonarv> that's why I'm confused!
20:48:32 <geekosaur> I think hsc2hs:exe(cutable component, named)hsc2hs
20:49:06 <geekosaur> classical cabal has one library component and zero or more library components. cabal 2+ allows multiple lib components as well, one default / unnamed
20:49:15 <geekosaur> er, zero ro more exe components
20:49:18 <Solonarv> but what does the 'haskell-gi-base:' on the front mean?
20:49:21 <geekosaur> plus test and benchmark components
20:49:38 <geekosaur> that the dependency came from the haskell-gi-base package
20:49:53 <Solonarv> oh that makes sense
20:50:05 <geekosaur> (which you will see if you look at its cabal file)
20:51:01 <redpunch> https://hastebin.com/celasazote.sql
20:51:12 <redpunch> maybe I should go ahead and install it like ^
20:51:21 <redpunch> doing it without the fixed version results in the same error
20:51:45 <redpunch> Is it undoable if I install it?
20:52:04 <geekosaur> with new-install it's installed in a "compartment" and won't affect anything else
20:52:23 <geekosaur> it'd only be visible within other "compartments" that declared a dependency on that version of it
20:52:33 <geekosaur> this said, build-tools doesn't support versioning, as you noted
20:52:49 <redpunch> I dont yet understand what levels these compartments sit at. Only thing I know is that it will put that on my path
20:52:53 <geekosaur> you migth want to ask about this in #hackage since the cabal experts hang there
20:52:55 <redpunch> and will be available everywhere
20:53:15 <Solonarv> redpunch: specifically, new-install puts a *symlink* on your path
20:53:18 <geekosaur> yes, which will be a problem if you need a different version for some other package
20:54:04 <Solonarv> remove that symlink and the package is gone (well, it's cached and therefore still takes up space on your filesystem, but it won't affect anything)
20:54:36 <redpunch> I wish there was an accompanying uninstall command
20:54:48 <redpunch> gonna try this. fingerscrossed
20:55:54 <redpunch> welp, still searches for 0.68.4
20:57:17 <geekosaur> you wouldn;t uninstall it normally, just remove the symlink. I think both cabal and stack have plans for gc-ing unused "compartments" in the future
20:57:35 <geekosaur> (the problem being, how do they know it's unused?)
20:58:03 <koz_> geekosaur: #cabal-philosophy? :P
20:58:14 <geekosaur> at this point I'm going to suggest you ask in #hackage because the cabal experts hang out there
20:59:51 <redpunch> I'll move there but before i do another interesting thing i noticed. http://hackage.haskell.org/package/hsc2hs The cabal file lists different bounds for base than what is under Dependencies
21:01:36 <geekosaur> did you notice the link "revised"?
21:01:42 <geekosaur> http://hackage.haskell.org/package/hsc2hs-0.68.4/revisions/
21:02:05 <geekosaur> a revision is made by adding an extra cabal file outside the package
21:03:01 <redpunch> Oh
21:06:35 <ski> Solonarv : ok. i don't see why "discarding every 'put'" would be the case, though. iiuc, that (`lift . lowerCodensity') would do precisely what i had in mind
21:06:57 <Solonarv> hm, could be
21:07:33 <ski> ty for mentioning `State s' as `Codensity (Reader s)', though. hadn't thought about / seen that
21:08:40 <Solonarv> it's interesting because it's a concrete example that 'Codensity m' is not always isomorphic to 'm' even when 'm' is a monad
21:08:51 <ski> (iow, the `lowerCodensity' would discard the final state of the action, when converting to environment-distribution, then `lift' would (naturally) just replicate the environment as the next state after the action)
21:08:58 * ski nods
21:09:07 <koz_> :t Codensity
21:09:08 <lambdabot> error: Data constructor not in scope: Codensity
21:10:06 <Solonarv> % :i Codensity
21:10:06 <yahb> Solonarv: ; <interactive>:1:1: error: Not in scope: `Codensity'
21:10:07 <ski>   newtype Codensity f a = BindLower (forall b. (a -> f b) -> f b)
21:10:16 <Solonarv> ^ there it is
21:10:25 <Solonarv> there are a crapload of instances
21:10:42 <koz_> Is that the thing that's always a Monad regardless of what f is?
21:10:49 <Solonarv> hackage link: https://hackage.haskell.org/package/kan-extensions-5.2/docs/Control-Monad-Codensity.html
21:11:12 <Solonarv> indeed, it is always a monad
21:11:18 <ski> Solonarv : hm, i suppose it's a bit similar to coproduct of two groups being different from coproduct of abelian groups, even if the two given groups happen to be abelian
21:18:50 <ski> (er, sorry, actually the deconstructor was what i had in mind being called `bindLower'. so i suppose the data constructor would be the inverse of that .. hmm, maybe `CallWithContinuationLift' ??)
21:18:54 * ski ponders
21:19:16 <redpunch> Adding `build-tools: hsc2hs == 0.68.3` to my cabal file seems to have changed the error to a pkg-config error
21:19:20 <redpunch> progress?
21:21:55 <geekosaur> pkg-config error meaans some C library is missing. probably a gtk lib
21:22:07 <geekosaur> you need the devel packages for your OS
21:24:02 <redpunch> yea, i learned that during my attempts to use Oscar's gi-gtk-declarative library
21:24:16 <redpunch> cabal's doing stuff now. The build may pass!
21:25:18 <redpunch> to confirm, pkg-config is a haskell independent, universal way to talk about C libs?
21:25:41 <redpunch> gobject-introspection-devel was the missing package for anyone interested
21:26:29 <geekosaur> haskell independent, yes. but not all C libraries use it; its a relatively recent invention
21:26:43 <geekosaur> because otherwise C has no way to specify how random programs should use libraries
21:27:42 <geekosaur> most other languages have some kind of library registry with that kind of information (including ghc, via ghc-pkg), but for C you have to read docs. or, more recently, use pkg-config --- but that means someone has to write the .pc file for the library
21:32:48 <redpunch> ah, thanks
21:32:56 <redpunch> (that build is taking a while, still going on!)
21:34:09 <redpunch> it seems to be compiling entire ghc rn
22:11:27 <redpunch> The build now fails with https://hastebin.com/wezoyazaja.sql
22:11:56 <redpunch> not sure if I will work on solving that tonight
22:12:04 <redpunch> ty for the help everyone
23:23:14 <p0a> @pl x + y + z
23:23:14 <lambdabot> x + y + z
23:23:25 <p0a> :(
23:24:50 <Cale> @pl \x y z -> x + y + z
23:24:50 <lambdabot> ((+) .) . (+)
23:25:09 <Cale> p0a: ^^
23:31:58 <p0a> thank you :)
23:32:19 <p0a> I think I sort of get it now 
23:32:41 <p0a> Cale: not sure if it was you who recommended the upenn course but it's great
23:32:57 <p0a> proudly can say I'm at lecture 7 now
23:34:32 <Cale> nice
23:39:46 <p0a> I've done most of the exercises but some details have me confused
23:39:52 <p0a> that's okay though I'm not set on doing everything 100%
23:40:25 <p0a> anyhow got to go! bye
23:41:07 <mjrosenb> is there anything like <%~, but allows me to pass in a function that both calculates a new value, and a return value?
23:42:45 <mjrosenb> so like ... ("test", [1,2,3]) & _2 <<<%~ (\(h:t) -> (h,t))
23:43:09 <mjrosenb> should return (1,("test", [2,3]))
