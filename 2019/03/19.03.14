00:02:43 <remexre> Is there a `class Foo f g where bar :: f a -> g a`?
00:03:10 <remexre> MonadBase sounds like the closest thing, but I've just got functors
00:04:44 <Cale> There might be a natural transformation class around somewhere, but it's less useful than just taking an argument of that type most of the time
00:05:15 <Cale> (you may wish to turn on RankNTypes, so that you can have arguments of type (forall a. f a -> g a)
00:05:16 <Cale> )
00:07:22 <remexre> oh, right, those have a math name; I'd not remembered that
00:07:26 <remexre> I found a lib for that, yeah
00:07:42 <remexre> thanks!
00:26:06 * hackage dfinity-radix-tree 0.6.2 - A generic data integrity layer.  https://hackage.haskell.org/package/dfinity-radix-tree-0.6.2 (EnzoHaussecker)
00:51:36 * hackage dfinity-radix-tree 0.6.3 - A generic data integrity layer.  https://hackage.haskell.org/package/dfinity-radix-tree-0.6.3 (EnzoHaussecker)
01:28:23 <jackm> hello, I have this "classic" example :)
01:28:31 <jackm> class Collects c a | c -> a where   empty :: c   insert :: a -> c -> c  
01:28:33 <jackm> instance Collects [a] a where   empty = []   insert = (:)
01:29:13 <jackm> why is invalid? insert 1 empty
01:30:41 <petercommand> what's the error that you got?
01:31:30 <jackm> No instance for (Collects () Integer) arising from a use of ‘it’     • In the first argument of ‘print’, namely ‘it’
01:31:38 <jackm> but insert 1 [] works
01:32:07 <mniip> insert 1 empty :: (Collects c a, Num a) => c
01:32:13 <mniip> where c and a are unknown
01:32:15 <mniip> so defaulting happens
01:32:27 <dminuoso> jackm: because [] :: [a]
01:32:29 <mniip> and a is defaulted to Integer
01:34:08 <jackm> hmm. makes sense. so what would be the correct usage in this case?
01:36:23 <dminuoso> mniip: where does the defaulting to () come from? Is that just extended defaulting rules from GHCi presumably?
01:36:39 <mniip> not sure
01:36:47 <merijn> dminuoso: GHCI has extended defaulting for (), yes
01:37:10 <mniip> I have a feeling this might be a bug because
01:37:18 <mniip> I've had ghci default to () in kinds (!) for me
01:48:21 <jackm> https://gist.github.com/jackmalkovick/c6e6d3c5a586d1819d004291782e810f
01:48:31 <jackm> I've tried it outside GHCi
01:49:00 <jackm> I get : Ambiguous type variables ‘c0’, ‘a0’ arising from a use of ‘empty’
01:49:52 <jackm> how can I correctly compose insert and empty?
01:52:00 <merijn> jackm: Add a type signature
01:52:21 <merijn> jackm: "Ambiguous type variable" means "this thing is polymorphic and I don't have enough information to infer what the type should be"
01:52:39 <merijn> :t maxBound
01:52:40 <lambdabot> Bounded a => a
01:52:47 <merijn> > maxBound
01:52:49 <lambdabot>  ()
01:52:52 <merijn> bah
01:52:58 <merijn> Extended default messing up my example
01:54:06 <dminuoso> merijn: you could use yahb and disable extended defaulting?
01:54:10 <merijn> jackm: maxBound can be *any* type that is an instance of Bounded. However, to (for example) print maxBound you have to specific maxBound to print, somehow. Normally GHC infers what type you meant, but if there's insufficient information it will report "ambiguous type variable
01:54:26 <merijn> jackm: i.e. "this type variable could be one of many things and you need to tell me which you meant"
01:54:27 <dminuoso> % :set -XNoExtendedDefaultRules
01:54:27 <yahb> dminuoso: 
01:54:32 <dminuoso> % maxBound
01:54:32 <yahb> dminuoso: ; <interactive>:9:1: error:; * Ambiguous type variable `a0' arising from a use of `print'; prevents the constraint `(Show a0)' from being solved.; Probable fix: use a type annotation to specify what `a0' should be.; These potential instances exist:; instance Show a => Show (ZipList a) -- Defined in `Control.Applicative'; instance Show NestedAtomically -- Defined in `
01:55:12 <jackm> merijn like this right? insert 1 (empty :: [int])
01:55:23 <merijn> jackm: [Int], but yes that should work
01:55:47 <merijn> jackm: Alternatively, adding a type signature for 'i' would also let GHC infer what empty should be
01:57:56 <jackm> merijn cool. it worked
02:47:47 <c50a326> I'm trying to play around with the ((->) e) thing... how do I define my own type for this? I can't define Functor, Applicative, Monad etc. instances because of duplications...
02:48:08 <Taneb> c50a326: you could define a newtype wrapper
02:48:22 <c50a326> I've tried like: newtype F a = F { runF :: ((->) a) } 
02:48:25 <Taneb> Like "newtype MyFunc e a = MyFunc {getMyFunc :: e -> a}"
02:48:42 <Taneb> You'd need to fully saturate (->) in the newtype definition
02:48:43 <c50a326> ah yeah because of the kind
02:49:20 <c50a326> Taneb: saturate?
02:49:33 <Taneb> Give it as many type variables as it can take
02:49:56 <Taneb> (->) is unsaturated, ((->) e) is unsaturated, ((->) e a) ~ e -> a is saturated
02:50:10 <Taneb> I'm not sure if this is standard terminology
02:50:16 <c50a326> and then I can do like: instance Functor (F e) where
02:50:19 <Taneb> Yeah
02:50:24 <c50a326> cool thanks
02:50:32 <Taneb> Happy Haskelling :)
02:52:36 * hackage haskoin-store 0.11.2 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.11.2 (xenog)
03:23:31 <kuribas> why is cassava so strict?  I'd rather have it tread non existing cells as the empty string, than give an error.
03:24:13 <dminuoso> kuribas: Because writing correct software is hard.
03:24:31 <merijn> dminuoso: what makes you say that that behaviour is not correct?
03:24:51 <dminuoso> merijn: Oh I think I phrased it wrongly.
03:25:01 <kuribas> well, I can write my own instances...
03:25:10 <kuribas> I guess it's just the default for generated instances
03:27:22 <kuribas> considering how spreadsheets write csv's, I'd say it's the wrong default
03:32:29 <tdammers> correctly implementing a non-standardized file format for which no proper specs exist is even harder
03:40:40 <kuribas> what does correct even mean in the context of CSV?
03:40:46 <kuribas> I'd rather have pragmatic defaults...
03:41:28 <tdammers> well exactly
03:41:35 <tdammers> "correct" isn't a thing when there's no spec to match
03:41:49 <Ariakenom> kuribas: doesn't the "pragmatic" default depend on the source?
03:42:33 <kuribas> Ariakenom: in the context of CSV being more permissive
03:44:22 <Ariakenom> aha, that's a better word
03:44:36 <amx> there is a standard for CSV
03:45:24 <merijn> amx: It just doesn't specify very much
03:51:29 <amx> also, I think in general you cannot meaningfully parse a record when fields are missing
03:52:38 <kuribas> amx: you can when you can parse the empty string?
03:54:25 <amx> when parsing foo,bar into (Text,Text,Text) which Text should be empty?
04:05:13 <dmwit> amx: The correct one, obviously.
04:09:28 <tdammers> filling rows from the left is pretty uncontroversial
04:09:45 <tdammers> if you wanted an empty cell to the left, you would write ,foo,bar
04:14:40 <kuribas> amx: the right one
04:14:48 <kuribas> amx: that's how spreadsheets work
04:15:15 <kuribas> :t \f -> fmap join . traverse f
04:15:17 <lambdabot> (Applicative f, Traversable m, Monad m) => (a1 -> f (m a2)) -> m a1 -> f (m a2)
04:18:36 <kuribas> :t \f x -> fmap x . traverse f
04:18:37 <lambdabot> (Applicative f, Traversable t) => (a -> f b1) -> (t b1 -> b2) -> t a -> f b2
04:19:12 <kuribas> is there a law for this?
04:19:29 <phadej> law for what
04:19:59 <kuribas> rewriting fmap and traverse?
04:20:30 <kuribas> :t \f x ->  traverse (fmap x . f)
04:20:31 <lambdabot> (Applicative f, Traversable t) => (a1 -> f a2) -> (a2 -> b) -> t a1 -> f (t b)
04:20:44 <kuribas> :t \f x ->  traverse (x . f)
04:20:45 <lambdabot> (Applicative f, Traversable t) => (a -> b1) -> (b1 -> f b2) -> t a -> f (t b2)
04:20:55 <phadej> fmap = fmapDefault = \f x -> runIdentity (traverse (Identity . f) x
04:21:00 <phadej> )
04:21:50 <kuribas> traverse f . traverse g == ?
04:22:09 <kuribas> traverse (f >=> g) ?
04:22:19 <phadej> http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Traversable.html#t:Traversable
04:22:34 <phadej> traverse f . traverse g is meaningless
04:23:16 <phadej> but there is t . traverse f = ... laws
04:23:34 <phadej> and composition, which might be what you are after
04:23:59 <kuribas> :t \f -> traverse (fmap join . f)
04:24:00 <lambdabot> (Applicative f, Monad m, Traversable t) => (a1 -> f (m (m a2))) -> t a1 -> f (t (m a2))
04:24:10 <kuribas> :t \f -> fmap join . traverse f
04:24:11 <lambdabot> (Applicative f, Traversable m, Monad m) => (a1 -> f (m a2)) -> m a1 -> f (m a2)
04:29:40 <Zvpun> I come across `data F f x = F (f x)`. I am confused about the `(f x)` part. Does that mean `f` is a function? What is going on here?
04:30:46 <dminuoso> Zvpun: f :: * -> *
04:31:17 <Zvpun> ok, that helps
04:31:52 <phadej> F (Just 'a') :: F Maybe Char
04:31:57 <dminuoso> Zvpun: You could, using KindSignatures, also write this as: data F (f :: * -> *) (x :: *) = F (f x)
04:32:08 <__monty__> Hmm, I'm getting an error about a constructor being unavailable but it's in my imports: http://ix.io/1Dug
04:32:23 <dminuoso> __monty__: Did you save your buffer? ..
04:32:34 <__monty__> Yep, several times now : )
04:32:37 <dminuoso> __monty__: Oh wait! That does not import the data constructor.
04:32:44 <dminuoso> __monty__: Number is just the type constructor.
04:32:49 <__monty__> Oh, right only the type.
04:33:06 <__monty__> Hmm, (..) didn't work because Lex only exports the type : /
04:34:03 <dminuoso> __monty__: Lexeme(Number) perhaps?
04:34:43 <dminuoso> __monty__: Number :: Number -> Lexeme
04:34:47 <dminuoso> Confusingly.
04:34:49 <__monty__> Ah, of course.
04:35:06 <__monty__> Thank you, guess I was staring myself blind.
04:36:37 <AxiomaticEspress> Hi. Is anyone using the Haskell Language Server extension for vscode? It is crashing my ubuntu 18 system pretty often to the point it freezes and I need to reboot. I am not 100% sure if that's the reason but it only happens when I work on Haskell code. And it's not my machine.
04:41:43 <hololeap> AxiomaticEspress: you might be running out of ram and forcing the use of swap memory until the system becomes unresponsive. memory leaks are probably the number one bug that haskell programs run into
04:43:54 <AxiomaticEspress> hololeap: so you're saying the haskell ide engine has memory leaks? or my program?
04:46:34 <hololeap> i'm saying that running out of ram is a possibility. are you able to reproduce the problem? if so, run a system monitor and watch your memory before the system freezes.
04:48:49 <AxiomaticEspress> I can't reproduce it, I just noticed it happens with Haskell projects only, but sort of randomly
04:51:51 <hololeap> if it is indeed a process hogging all the memory, you might also be able to kill the process with the magic sysrq key. if your system recovers and becomes usable again, it would be a major clue that a memory leak is the issue
04:52:01 <hololeap> see this: https://www.reddit.com/r/linux/comments/75gyrz/a_tribute_to_altsysrqf/
04:53:55 <hololeap> (i sometimes have to hit it a few times, but this has worked for me in the past, especially when i had 4GB of ram)
04:54:19 <AxiomaticEspress> thanks
04:55:25 <AxiomaticEspress> hololeap: I do Have the REISUB sysrq enabled but usually sysrq + e / i kills everything, including the x server; and then I can't even get a tty working with ctrl+alt+f(n) so I have to reboot anyways. I didn't know about the sysrq+f tho. 
04:55:26 <hololeap> if it turns out to be your haskell code causing a space leak, people here can help you
04:56:54 <hololeap> yeah, E and I send SIGTERM and SIGKILL to all processes, respectively. it's not something that is supposed to be recovered from without a reboot
04:57:25 <hololeap> alt+sysrq+f selectively kills processes that are hogging the memory
04:57:53 <AxiomaticEspress> I disabled the vscode extension, if it happens again it's most likely my program leaking, right? I'll come back then
04:58:37 <hololeap> my bet is on a space leak in the code, not the extension to the IDE
05:00:33 <hololeap> lazy evaluation makes space leaks easier to run into if you're not aware of the danger, because of a buildup of "thunks"
05:00:35 <AxiomaticEspress> thing is, how can space leaks happen if it's garbage collected?
05:01:20 <c_wraith> they're not garbage
05:01:55 <c_wraith> they are still reachable.  There's just no reason for them to be unevaluated.
05:03:45 <hololeap> AxiomaticEspress: this might give you a bit of information. as the gurus wake up in this channel, they can give you a much more detailed explaination: https://wiki.haskell.org/Memory_leak
05:04:16 * hololeap bows to the haskell gurus
05:05:57 <hololeap> https://wiki.haskell.org/Thunk
05:07:06 <slack1256> Are we even sure it is a memory why vscode haskell server isn't working? 
05:10:00 <AxiomaticEspress> gurus
05:10:12 <AxiomaticEspress> :)
05:11:02 <AxiomaticEspress> HIE is working, but my system just randomly freezes sometimes; we're not sure if it's because of that
05:11:09 <AxiomaticEspress> (because of HIE I mean)
05:11:45 <slack1256> Are you on windows?
05:12:42 <AxiomaticEspress> ubuntu
05:12:44 <slack1256> When you aren't using HIE, does vscode exhibit the same behaviour?
05:13:35 <AxiomaticEspress> only freezes when working on Haskell projects (and not only my machine, another machine with Ubuntu 18 installed exhibits the same behavior)
05:14:00 <AxiomaticEspress> I disabled HIE now, we'll see if it still freezes
05:14:09 <slack1256> Yeah, but if you open the haskell project without HIE, bare vscode, does it still freeze?
05:14:11 <AxiomaticEspress> I can't predict since it was happening randomly
05:14:36 <AxiomaticEspress> Idk, that's what I'm waiting to see
05:16:23 <AxiomaticEspress> hololeap: so using `let` can be pretty harmful? 
05:17:22 <hololeap> not really, no. it's just that if you have a cumulative operation over a huge set of data, and it's consuming it lazily, you get a huge buildup of unevaluated terms in memory
05:18:55 <hololeap> but if it does turn out to be a space leak in your code, others can offer a lot more help than i can
05:19:26 <AxiomaticEspress> hololeap: can unsafePerformIO cause memory leaks as well? I'm using that at some point for debugging.
05:25:41 <hololeap> i don't think any one part of the haskell language is a definite cause of space leaks. we don't even know if that is the issue yet.
05:26:46 <slack1256> Yeah, lets not debug blindly
05:34:33 <matheus23> Hi is ndmitchell anywhere or someone who maintains hoogle?
05:35:36 <matheus23> In firefox hoogle reloads the page on every keystroke to update the search. This is a cool feature, however it really pollutes the history. Isn't is possible to pushState the url without updating the history? Only updating it on enter would be great. Or updating it in a debounced way would also help lots! :)
05:35:53 <matheus23> Just felt like this was too little feedback for an issue
05:38:01 <shader> is it possible (and how) to have a function that returns an infix function? Or to use the results of a function application as an infix operation?
05:38:40 <merijn> shader: Fun fact, binding operators is perfectly legal
05:38:54 <merijn> > let (+) = elem in 1 + [1..5]
05:38:56 <lambdabot>  True
05:39:28 <merijn> shader: "being infix" is a property of names/bindings, not of the actual code
05:39:34 <slack1256> more over, every function can be called on infix form if it takes at least two parameters
05:39:43 <slack1256> > 5 `elem` [5,6,7]
05:39:45 <lambdabot>  True
05:39:56 <matheus23> shader: yes, you can refer to infix operators by putting them in parenthesis: (+) 1 2 behaves like a normal function
05:40:38 <merijn> shader: All operator names are always infix and you can assign arbitrary things to them
05:40:53 <merijn> > let (+) = True in (+) -- I wonder?
05:40:56 <lambdabot>  True
05:41:04 <shader> I have parameterized equivalence relation '~_p' that I was wondering if I could somehow make look something like that in haskell... so, P (~ p) Q
05:41:04 <merijn> Ah, glorious consistency :)
05:41:43 <merijn> shader: that won't quite work as 'p' is not a valid operator character and thus can't be part of an operator
05:41:56 <shader> it's a parameter
05:42:16 <shader> so, I was hoping I could apply the function, and be able to use the result as infix
05:42:42 <shader> I guess I could temporarily bind an operator, but as you say, letters are apparently not valid in operators
05:42:57 <merijn> shader: It'd be legal to define:
05:43:10 <merijn> > let (~~) = (+) in 5 ~~ 3
05:43:11 <lambdabot>  8
05:43:25 <merijn> shader: Single tilde isn't allowed as it's reserved for non-strict pattern matches
05:43:52 <shader> ok
05:44:18 <shader> I can do without it, I was just hoping there might be more magic hidden somewhere
05:45:50 <shader> but I guess it's not really reasonable to expect values to affect syntax :P
05:53:52 <michalrus> Hey, is there a library like `statistics` but for iterative calculations? I just need iterative mean and stdev (for now)
05:55:52 <michalrus> Hummm, is this the one? https://hackage.haskell.org/package/online-0.3.0.0
06:03:36 <dminuoso> decodeASCII :: ByteString -> Text -- Deprecated: Use decodeUtf8 instead
06:04:27 <dminuoso> Mmm. This deprecation notice is weird, shouldn't it rather be decodeUtf8With?
06:05:23 <merijn> dminuoso: No, because decodeASCII was also unsafe
06:05:38 <merijn> dminuoso: decodeUtf8With is not a drop in replacement
06:05:42 <merijn> dminuoso: decodeUtf8 is
06:06:07 <dminuoso> merijn: Ah.
06:12:57 <shader> what are good reasons for making a wrapper type instead of just an alias "type Things = [Thing]"?
06:13:36 <merijn> shader: That's not a wrapper type, that's just an alias
06:13:46 <shader> yes, that's the alias
06:14:17 <shader> the wrapper would be "data Things = {elements :: [Thing]}"
06:14:23 <merijn> shader: I would generally advise against aliases anyway :)
06:15:13 <shader> but then every function where I could just operate on [Thing] with map, etc. I have to wrap/unwrap ad nauseum
06:15:24 <merijn> shader: The main reason would be "if/when you want to hide the implemntation"
06:15:54 <merijn> shader: I recommend against aliases *in general*, I didn't say I recommend wrapping in this scenario :p
06:16:12 <shader> ok
06:16:33 <shader> so, any reasons for wrapping in this scenario?
06:16:57 <shader> or better ways of handling the wrap/unwrap process?
06:16:59 <merijn> shader: I don't think so, but I dunno the context :)
06:17:12 <shader> hehe
06:19:54 <unsymbol> can anyone recommend a package, other than statgrab, which coredumps on my target platform, for getting linux system info (memory usage, cpu usage, etc)?
06:21:00 <Axman6> is querying /proc not enough?
06:22:50 <unsymbol> Axman6: it's definitely enough but was hoping someone had written a package that wrapped querying proc so i didn't have to. 
06:23:10 <Ariakenom> merijn: Does "in general" mean "without exception" in some contexts?
06:23:18 <dminuoso> shader: type aliases give you a false sense of security and make diagnostics a bit harder.
06:24:04 <dmwit> shader: Generally: wrappers give you a place to hang an instance, and a way to create an abstraction barrier.
06:24:34 <unsymbol> look's like some has: https://hackage.haskell.org/package/system-linux-proc, https://hackage.haskell.org/package/meminfo, etc.
06:24:41 <merijn> Ariakenom: There are some times I do think aliases are useful, if used to shorten long types
06:24:54 <merijn> Ariakenom: I think all aliases that try to be "semantic" are bad without exception
06:25:11 <Ariakenom> oh haha, I meant the phrase "in general"
06:25:24 <dminuoso> Type aliases are kind of useful when you are writing out long types and you have some repetitive components in some local region of code.
06:25:33 <merijn> Ariakenom: "in general" means the opposite of without exception
06:25:50 <monochrom> Type aliases are like macros.
06:25:50 <merijn> Ariakenom: It means "always, except in some exceptional circumstances"
06:25:56 <Ariakenom> in general is the opposite of ina  specific case
06:26:00 <dminuoso> Lens' is an example of a useful type alias. 
06:26:43 <dminuoso> merijn: ^- so this I present as an exception to your rule.
06:27:39 <monochrom> Yes, even mathematicians say "a natural number is not 5 in general".
06:28:05 <Ariakenom> if someone says "the general case" of an algorithm or similar then I would expect it to handle everything. I feel like the phrase has very different meanings in everyday usage vs math usage. But I may be wrong, trying to figure that out
06:28:06 <monochrom> This is why I actually avoid saying "in general".
06:28:10 <merijn> monochrom: "In general even mathematicians say" ;)
06:28:19 <monochrom> haha
06:28:45 <Ariakenom> "the number is 5" is false for some numbers so that works with "without exceptions"
06:28:54 <monochrom> Yes, Ariakenom, they are wrong, but they are the majority too, they decide what this stupid English language means, what can you do?
06:29:14 <Ariakenom> if you interpret the statement a certain way
06:29:29 <monochrom> And by the time even the majority of mathematicians do it, the cause is lost.
06:29:55 <monochrom> The only way to win is to help robots rule the world.
06:31:16 <shader> mathematicians sometime use "without loss of generality" to mean the case their considering is not an exception, and therefore applies to all cases
06:31:39 <shader> but that's not the same as saying "in general" - I don't think mathematician would use that phrase
06:34:13 <Ariakenom> "a natural number is not 5 in general" -> "(number is 5) is not a general rule for natural numbers"
06:36:07 <merijn> Ariakenom: No, that parses as "most natural numbers are not 5"
06:37:32 <merijn> In natural language "in general, X" means "X in the vast majority of cases", i.e. I would expect X to hold for >90% of cases
06:40:26 <Ariakenom> in general, that is the current usage, yes
06:41:00 <dmwit> #haskell is a silly place in general
06:45:02 <kuribas> how to tell ghc to use a sandbox?
06:47:30 <kuribas> nvm, I found it.  
06:48:51 <kuribas> how to get rid of the pesky HasCallStack messages?
06:49:04 <merijn> kuribas: Eh, which ones?
06:49:19 <kuribas> the one when I use error
06:49:28 <kuribas> CallStack (from HasCallStack): error, called at pvassetcheck.hs:74:9 in main:Main
06:49:40 <kuribas> I don't want that, only the message I give
06:50:25 <merijn> kuribas: Handle the exception yourself to do pretty printing, I think?
06:50:46 <kuribas> why does error do that?  I didn't use to
06:51:18 <merijn> kuribas: Because it's throwing with callstacks enabled?
06:53:03 <kuribas> I didn't enable them
06:54:38 <merijn> The library you're using maybe did? Or is this a profiling build?
06:54:48 <kuribas> no...
06:57:10 <nshepperd_> In general, a natural number is not 5. In particular, 32
07:24:11 <lortabac> hello, do you know if there are other packages similar to glambda, but more recent? glambda hasn't been updated for 2 years
07:25:30 <merijn> lortabac: It'd probably help to tell us what it does :p
07:27:00 <lortabac> merijn: it's an interpreter for simply-typed lambda calculus. Since its Exp type is a GADT, type-checking is given for free by Haskell
07:27:56 <merijn> lortabac: So why is the fact that it hasn't been updated for 2 years be relevant? Seems to me that if it still builds it's fine?
07:28:33 <lortabac> merijn: fair point
07:28:43 <ziman> what do you intend to use it for?
07:30:32 <lortabac> ziman: building a prototype interpreter for a toy language
07:33:36 * hackage dejafu 2.0.0.1 - A library for unit-testing concurrent programs.  https://hackage.haskell.org/package/dejafu-2.0.0.1 (barrucadu)
07:39:32 <siraben> cabal install stylish-haskell succeeded for me in a nix-shell, but I can't seem to invoke stylish-haskell from the command line?
07:42:38 <ziman> do you have ~/.cabal/bin (or wherever your cabal installs executables) in your $PATH?
07:44:24 <dmwit> kuribas: errorWithoutStackTrace
07:45:52 <dmwit> (GHC is really breaking with the Report these days, huh? That one is directly in the Prelude.)
07:49:29 <siraben> ziman:  http://ix.io/1Dv8/text
07:49:31 <siraben> Doesn't seem like it
07:50:33 <dmwit> So... add it?
07:50:36 <ziman> i'm not sure how $PATH is managed on nix but you could first locate the executable itself (try running ~/.cabal/bin/stylish-haskell, for example) and then add that directory to $PATH somehow, according to the nix doc
07:51:07 <ziman> on other distros, you'd just extend $PATH in ~/.bashrc or ~/.profile
07:51:29 <sclv> i mean likely this isn't nixos, but another distro just using nix incidentally :-)
07:51:43 <sclv> in which case its exactly as described
07:52:00 <sclv> if you're using nixos proper then there's a whole other "proper" way of installing stuff in overlays
07:52:13 <goranb> :1
07:52:35 <sclv> Ok, no modules loaded.
07:56:44 <dmwit> sclv: botsnack
07:57:23 <sclv> :-)
08:01:50 <siraben> If I add stylish-haskell as a dependency to my cabal file, running nix-shell lets me see it
08:01:51 <siraben> But I get an exception: http://ix.io/1Dvd/text
08:04:01 <siraben> Ah looks like I needed to run stylish-haskell --defaults > .stylish-haskell.yaml
08:06:49 <merijn> ls
08:09:05 <siraben> But making it a dependency isn't the ideal way
08:20:47 <siraben> Ah, from a little bit of doc-reading, I got : nix-shell -p "haskellPackages.ghcWithPackages (pkgs: [pkgs.stylish-haskell ])"
09:09:06 <iqubic> I feel like there's got to be a way to rewrite this so it doesn't use a let.
09:09:17 <iqubic> "Main = let nums = map numToFizzBuzz [1..] in print nums"
09:09:38 <iqubic> Like use an applicative function like <*> or <$> instead.
09:09:46 <iqubic> But I'm not sure how to make that work.
09:09:54 <Taneb> iqubic: if it's not recursive you can always inline a let, by copying its definition to where it's used
09:10:01 <Solonarv> you can simply inline the definition of nums
09:10:08 <iqubic> Oh. right.
09:10:17 <Solonarv> main = print (map numToFizzBuzz [1..]) -- no fanciness needed
09:10:22 <iqubic> right.
09:11:39 <iqubic> So I just wrote FizzBuzz in haskell to prove that I could.
09:11:40 <iqubic> http://dpaste.com/1TNPP5D
09:12:02 <iqubic> Wait... That has an error.
09:12:08 <iqubic> A rather gross one.
09:13:00 <iqubic> "1, 2, Fizz3, 4, Buzz5, Fizz6..."
09:13:32 <Taneb> iqubic: you're not far off! Keep going :)
09:13:38 <iqubic> I know.
09:15:13 <iqubic> What's the right way to check if a string is length 0?
09:15:36 <Solonarv> > null ""
09:15:37 <tdammers> Data.Text.null
09:15:37 <NickSeagull> iqubic: null?
09:15:38 <lambdabot>  True
09:15:45 <Taneb> iqubic: pattern matching or null
09:15:51 <Solonarv> > null "Fizz"
09:15:53 <lambdabot>  False
09:16:32 <iqubic> This is better.
09:16:33 <iqubic> http://dpaste.com/3MENSPN
09:16:38 <iqubic> I think that works now.
09:17:25 <iqubic> bool x y p = if p then y else x
09:17:40 <iqubic> so it goes "bool false true predicate"
09:18:20 <iqubic> And I think that's a working fizzbuzz now.
09:18:57 <Taneb> :)
09:19:05 <iqubic> Can you guys look over it and tell me if I'm missing something obvious that would prevent that from working?
09:19:30 <Taneb> iqubic: only thing I can spot is you've spelt "import" with a capital I
09:19:51 <iqubic> oh. Yeah. I'm sure my editor would catch that.
09:20:06 <pong> why bool over ifthenelse though?
09:20:27 <iqubic> I'm using a school computer now, and not my personal Linux Laptop with an emacs + haskell set-up.
09:20:50 <iqubic> pong: I'm not sure why. I think I just went with the first thing that came to my mind.
09:21:07 <nshepperd> error: Variable not in scope: x
09:21:23 <pong> oh right I guess bool makes makes more sense for some cases
09:21:51 <pong> bool "yay" "nooo" for example is Bool -> String
09:22:45 <iqubic> There.
09:22:58 <iqubic> I just went ahead and rewrote the code.
09:22:59 <iqubic> http://dpaste.com/341D63M
09:23:18 <iqubic> Also, I'm aware I could have used ++ instead of <>.
09:23:27 <iqubic> I just think <> looks better.
09:23:34 <merijn> pong: It's named bool for symmetry with all the other eliminators
09:23:38 <merijn> pong: Like:
09:23:40 <merijn> :t maybe
09:23:41 <lambdabot> b -> (a -> b) -> Maybe a -> b
09:23:42 <merijn> :t either
09:23:43 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
09:23:51 <iqubic> :t cons
09:23:51 <Taneb> iqubic: when you're satisfied with your program, read https://themonadreader.files.wordpress.com/2014/04/fizzbuzz.pdf :)
09:23:52 <lambdabot> Cons s s a a => a -> s -> s
09:24:21 <iqubic> Taneb: I did finish my program. See here: http://dpaste.com/341D63M
09:24:21 <nshepperd> i don't really like bool because it's a pain remembering the order of the arguments
09:24:38 <nshepperd> > bool "false" "true" True
09:24:39 <iqubic> nshepperd: I just rewrote my code to avoid that.
09:24:40 <lambdabot>  "true"
09:24:50 <merijn> iqubic, Taneb: Also my "generalized FizzBuzz" (don't look before you're done, because massive spoilers): https://gist.github.com/merijn/cd0e7918a96fe913cf7d66833e8da354
09:25:03 <merijn> I'm pretty sure that's the most general form of FizzBuzz possible :p
09:25:06 <iqubic> What is the goal of that program?
09:25:12 <iqubic> How is it supposed to work?
09:25:32 <iqubic> Like what challenge were you solving when you wrote that?
09:25:59 <merijn> iqubic: My fizzbuzz gist? I was solving "How do I write the most general solution to FizzBuzz?" :p
09:25:59 <iqubic> Exscuse me??? What is that doing?
09:26:10 <iqubic> What is that program even doing?
09:26:23 <merijn> It works for any input type and any output that happens to be a Semigroup
09:26:45 <iqubic> Why am I using "print" when "putStrLn" is the better choice?
09:26:52 <pong> eliminators hmm
09:27:14 <pong> so if you partially feed an eliminator sufficiently many arguments it defines a the morphism from your functor type back into b?
09:27:26 <iqubic> pong: Think of it as the church encoding for "data Bool = True | False"
09:27:30 <merijn> pong: Most of type theory deals with datatypes as having introduction rules (aka constructors) and eliminators (aka taking them apart)
09:27:57 <dminuoso> merijn: Mmm, you should encode it using continuations to yield better performance.
09:28:06 <iqubic> Am I right when I say that bool is the church encoding for "data Bool = True | False"
09:28:13 <pong> ohhh ok makes sense
09:28:24 <dminuoso> I mean imagine you are running a high performance FizzBuzz server that nuclear missles depend on.
09:28:44 <iqubic> so how does the generalized FizzBuzz program work?
09:28:47 <nshepperd> iqubic: 'data Bool = False | True' may be better
09:29:10 <iqubic> Why would it be better with the order of the constructors swapped?
09:29:41 <nshepperd> because False < True and also the order of the arguments of 'bool' is false then true
09:29:42 <merijn> iqubic: generalised FizzBuzz is basically a "FizzBuzz solution generator"
09:30:09 <merijn> iqubic: You pass it a function that says how to handle the "default" case (i.e. no predicate matches), usually that means showing the input
09:30:17 <e> i almost want to argue that any general FizzBuzz solution generator is a UTM
09:30:31 <iqubic> I don't even understand the type signature of the generalizedFizzBuzz function.
09:31:37 * hackage pandoc 2.7.1 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-2.7.1 (JohnMacFarlane)
09:32:01 <merijn> iqubic: It takes 3 arguments: 1) the default case (so printing a number that's not divisible by 3 or 5, for example), then it takes a predicate that checks whether something is matched (for example "isDivisibleBy")
09:32:26 <merijn> iqubic: Then it takes a collection of things to check the predicate against and their result
09:32:47 <merijn> iqubic: So regular fizzbuzz shows any number not divisible by 3 or 5, so the default case is "show"
09:32:48 <dminuoso> iqubic: You could start by looking how it is used.
09:33:03 <merijn> iqubic: The predicate for FizzBuzz is "is x divisible by y" which is the 2nd argument
09:33:51 <merijn> iqubic: The 3rd argument says "if divisble by 3 then "Fizz", if divisible by 5 then "Buzz"" then checks and concatenates all those in order
09:35:34 <merijn> dminuoso: Which part did you think should be CPS encoded?
09:36:20 <iqubic> merijn: Why are you using fromMaybe?
09:36:35 <merijn> To detect whether any of the predicates matched or not
09:37:31 <dminuoso> 1
09:38:12 <iqubic> But it seems like you are applying the default handler to a thing of type "f (a, m)" Which doesn't make any sense.
09:38:38 <iqubic> Wait no. x :: a
09:38:42 <merijn> Right
09:38:56 <merijn> x is "the element to check"
09:39:11 <iqubic> I understand that.
09:39:27 <wroathe> Can someone post the gist you guys are debating?
09:39:52 <merijn> wroathe: https://gist.github.com/merijn/cd0e7918a96fe913cf7d66833e8da354
09:39:59 <wroathe> merijn: gracias
09:40:47 <iqubic> This is the most generalized FizzBuzz there ever was.
09:40:59 <merijn> iqubic: Well, that was the goal, yes ;)
09:41:23 <Logio> couldn't you generalize it slightly more by having the list contain pairs (predicate, value_to_show)?
09:42:01 <tdammers> there is one obvious further generalization
09:42:19 <iqubic> Consider the FizzBuzzHissHowl problem, where hiss and howl are printed for multiples of 7 and 11 respectively. 
09:42:31 <tdammers> this version uses the same function to express the predicate for each entry in the conditions list
09:43:02 <iqubic> merijn: How hard would it be to amend your code to support hiss and howl as explained above?
09:43:12 <tdammers> so you cannot express, say, "if it contains the digit '3' in decimal notation or is divisible by 3, say 'Skip'"
09:43:52 <tdammers> iqubic: easy. [(3, "Fizz"), (5, "Buzz"), (7, "Hiss"), (11, "Howl")]
09:43:59 <iqubic> Oh. I see.
09:44:02 <iqubic> Clever.
09:44:23 <iqubic> What's the smallest number that would need all 4 identifiers?
09:44:26 <merijn> tdammers: Yes, I think I originally had that, but it's unclear whether that's still expressing the same algorithm
09:44:38 <iqubic> > 3 * 5 * 7 * 11
09:44:40 <lambdabot>  1155
09:44:51 <iqubic> Is that the smallest number require all 4?
09:45:02 <iqubic> Or is there something smaller I'm missing?
09:45:28 <tdammers> merijn: yeah, at some point the question is not "what else can you generalize", but "how much do you need to keep before it stops being the same problem"
09:45:29 <iqubic> I currently have a guess at the lower bound, but not a proof that it is in fact the lowest.
09:48:54 <merijn> tdammers: Also, this way required less writing to instantiate a given problem, else you have to duplicate the predicate all the time 
09:49:35 <glguy> > foldl1 lcm [3, 5, 7, 11]
09:49:37 <lambdabot>  1155
09:49:47 <iqubic> lcm is a thing?
09:49:49 <iqubic> How so?
09:50:07 <iqubic> @src lcm
09:50:08 <lambdabot> lcm _ 0 = 0
09:50:08 <lambdabot> lcm 0 _ = 0
09:50:08 <lambdabot> lcm x y = abs ((x `quot` (gcd x y)) * y)
09:50:14 <iqubic> Oh cool.
09:50:28 <iqubic> That's euler's method, isn't is?
09:53:10 <iqubic> I can write wonderful Haskell without so much as missing a beat,but I’d have a genuinely hard time writing a FizzBuzz program in Java
09:54:35 <Rembane> iqubic: write some Haskell code that generates Java code
09:55:42 <iqubic> Rembane: That kinda already exists
09:56:08 <iqubic> Rembane: See this
09:56:12 <iqubic> https://github.com/Frege/frege
09:56:33 <kuribas> eta?
09:58:39 <Rembane> iqubic: Good stuff! 
10:00:19 <nshepperd_> @src gcd
10:00:19 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
10:00:19 <lambdabot> gcd x y = gcd' (abs x) (abs y)
10:00:19 <lambdabot>    where gcd' a 0 = a
10:00:19 <lambdabot>          gcd' a b = gcd' b (a `rem` b)
10:00:31 <nshepperd_> That's Euler's method
10:01:39 <int-e> oh another out-of-date entry
10:01:45 <int-e> > gcd 0 0
10:01:47 <lambdabot>  0
10:01:51 <int-e> (as it should be)
10:03:29 <iqubic> gcd 1 2
10:03:37 <iqubic> > gcd 3 4
10:03:39 <lambdabot>  1
10:03:46 <wroathe> iqubic: That generates JVM bytecode. Your challenge, should you choose to accept it, is to write a Haskell -> Java compiler. Godspeed.
10:04:20 <iqubic> wroathe: I dislike OOP with a fiery passion. Challenge Declined.
10:04:33 <int-e> wroathe: Are you quoting CI - Challenge Impossible?
10:05:57 <wroathe> int-e: I thought I was being original /s
10:08:05 <nshepperd_> gcd 0 0 is 0, huh
10:08:32 <iqubic> I didn't know that.
10:09:20 <Rembane> I thought it was 1.
10:09:30 <Rembane> 0/1 = 0 
10:09:39 <Rembane> 0 / 0 = oh god
10:09:56 <merijn> Rembane: Naah, that's NaN :p
10:09:57 <nshepperd_> All of the integers divide 0, so i don't think there really is a greatest
10:09:59 <Rembane> merijn: :D
10:10:07 <Rembane> Infinite integer? 
10:10:30 <Rembane> But! 
10:10:31 <iqubic> > 0/0
10:10:31 <Rembane> > 0/0
10:10:34 <lambdabot>  NaN
10:10:34 <lambdabot>  NaN
10:10:34 <Taneb> 0's the greatest number according to the divides partial order
10:10:35 <Rembane> :D
10:10:49 <merijn> > 1/0 -- on the other hand
10:10:51 <lambdabot>  Infinity
10:10:52 <Rembane> Ah. Good stuff. 
10:10:55 <Rembane> Huh.
10:10:59 <Taneb> eg. 2 | 4 | 8 | 24 | 0
10:11:21 <merijn> > -1/0 -- What's confusing you, Rembane? :p
10:11:23 <lambdabot>  -Infinity
10:11:39 <iqubic> > round (1/0)
10:11:41 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
10:11:51 <iqubic> > round (-1/0)
10:11:52 <Rembane> merijn: All them edge cases. They just don't make sense. But that's alright. 
10:11:52 <lambdabot>  -179769313486231590772930519078902473361797697894230657273430081157732675805...
10:12:06 <iqubic> > round (0/0)
10:12:08 <lambdabot>  -269653970229347386159395778618353710042696546841345985910145121736599013708...
10:12:19 <merijn> Rembane: They make sense if you realise / just defaults to Double and these cases are all explicitly defined in IEEE-754 :p
10:12:44 <iqubic> > abs $ round $ -1/0 == abs $ round $ 1/0
10:12:46 <lambdabot>  error:
10:12:46 <lambdabot>      • Couldn't match expected type ‘Integer -> Double’
10:12:46 <lambdabot>                    with actual type ‘Bool’
10:13:01 <dmwit> Taneb: In what partial order is 0 the least common multiple of 0 and 1 (say)?
10:13:14 <iqubic> > abs (round (1/0))== abs (round (-1/0))
10:13:16 <lambdabot>  True
10:13:21 <dmwit> Taneb: ...but not the least common multiple of 1 and 2.
10:13:23 <iqubic> That's interesting.
10:13:39 <dmwit> Hm. Same order, I guess.
10:13:43 <dmwit> Taneb: Okay, question retracted.
10:13:58 <iqubic> Rounding (1/0) and (-1/0) does weird things.
10:14:32 <dmwit> > round (1/0) == -(round (-1/0))
10:14:34 <lambdabot>  True
10:14:59 <iqubic> dmwit: I kinda just proved that with my 'abs' example.
10:15:15 <Taneb> dmwit: :)
10:16:38 <Rembane> merijn: Well, I wouldn't say that that is making sense, just that they are what they are by definition. :)
10:16:47 <nshepperd_> Taneb: that makes sense. I'll take it
10:16:53 <Rembane> merijn: I see no system, I just see definitions. 
10:16:57 <dmwit> > round (1/0) == 2^1024 -- why?
10:16:59 <lambdabot>  True
10:20:13 <dmwit> The official documentation answer is that the value of decodeFloat (1/0) is unspecified, and round calls decodeFloat.
10:21:05 <dmwit> I never knew this before. I assumed round/ceiling/floor were primitives that could be compiled to a single hardware instruction.
10:22:03 <hyperisco> Four years ago I created a ticket about higher-order type-level programming, and today I get sent the research paper on how to do it. Not that bad for turnaround time I'd say.
10:30:18 <cryptomonad> hyperisco: Was it a new paper initiated by that or did it take 4 years for someone to find it?
10:35:01 <hyperisco> Came out last year but the idea would have existed long before I ever found a compiler bug
10:37:43 <int-e> dmwit: 2^1024 is what you get if you treat the representation of +Inf as a normal floating point number instead... 1.mantissa (which is 0) * 2^(2047-1023)
10:38:46 <int-e> > fromInteger (round (1/0))
10:38:48 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
10:38:53 <int-e> > fromInteger (round (1/0)) :: Double
10:38:55 <lambdabot>  Infinity
10:39:29 <iqubic> :t fromInteger
10:39:30 <lambdabot> Num a => Integer -> a
10:39:31 <hyperisco> Ah, so infinity starts with a 1
10:39:57 <iqubic> How do we know that?
10:40:03 <int-e> hyperisco: in binary!
10:40:49 <iqubic> In Binary all numbers start with a 1, once you trim the leading 0s that don't change the number.
10:41:11 <int-e> > fromInteger (round (1/0 :: Float)) -- in decimal it's less clear
10:41:13 <lambdabot>  340282366920938463463374607431768211456
10:42:07 <iqubic> That seems like a very very very small number to be infinity.
10:42:10 <hyperisco> So, I trimmed all the 0s, and now I have no digits left. What number is that?
10:42:17 <int-e> iqubic: So 0 is not a number?
10:42:25 <iqubic> > fromInteger (round (1/0 :: Float)) + 1
10:42:27 <lambdabot>  340282366920938463463374607431768211457
10:42:31 <iqubic> I see.
10:43:00 <iqubic> So inifinity isn't even the largest number Haskell can repersent. LOL.
10:43:29 <hyperisco> Seems like another variant of 1's complement where the empty bitstring and 0 are different representations of the same number
10:44:09 <iqubic> What's the largest float haskell can repersent?
10:44:23 <iqubic> > round (1/0 :: Float)
10:44:25 <lambdabot>  340282366920938463463374607431768211456
10:44:43 <iqubic> fromInteger isn't needed there.
10:44:47 <int-e> iqubic: if that gets you excited you should acquaint yourself with ordinal numbers
10:44:58 <iqubic> I know of the ordinals.
10:46:53 <iqubic> Omega + 1 doesn't have a larger value than any of the cardinals, it just comes after all the cardinals when you order the numbers.
11:01:07 * hackage render-utf8 0.1.0.0 - Simple Utf8 wrapper for ByteString Builder with conversion classes  https://hackage.haskell.org/package/render-utf8-0.1.0.0 (ChrisDornan)
11:43:00 <akr> Hello, I'm trying to use the emacs haskell mode with an ancient ghc-mod. I'm getting "unexpected response from haskell process" whenI try to load a file. Is there anything I can do about this?
11:45:20 <akr> "ancient" means ghc-mod version 1.10.2, ghc version 6.12.3
11:47:56 <phadej> that's a feat to have such old ghc running :)
11:48:51 <phadej> I think that old ghc-mod's had to be compiled with the same ghc they are used with
11:49:03 <akr> ghc-mod works fine, that's not a problem
11:49:21 <akr> but my haskell mode in emacs is probably made to work with newer version of it
11:49:39 <akr> I'm guessing that the "api" changedalong the way quite a bit
11:51:51 <phadej> for sure
11:52:13 <phadej> Version 6.12.1 (released 14 December 2009)
11:52:24 <akr> yeah :)
11:53:23 <akr> I can try using the .el files from that ghc-mod release
11:53:39 <akr> though I'm not sure how it's going to interact with the haskell layer I use in spacemacs
11:53:45 <wroathe> Say I've got a function, Foo :: Int -> String -> Bool -> Foo, I can compose a function with the first field, like so: Foo . (^2) :: Int -> String -> Bool -> Foo. Is there a way to compose functions with the String and Bool parameters in a "point-free" way?
11:54:12 <wroathe> (Not that writing code like this is a good idea. I'm just experimenting with composition)
11:54:17 <phadej> wroathe: @package http://hackage.haskell.org/package/composition-1.0.2.1/docs/Data-Composition.html
11:54:33 <phadej> fun pun, composition is the package you could try
11:54:41 <phadej> but I never seen it used anywhere
11:56:32 <wroathe> phadej: Thanks. I'll take a look. What I'm really looking for is a way to derive this definition in a systematic way. 
11:59:05 <phadej> wroathe: not really
11:59:23 <phadej> I mean you can, but it won't be convinient to use
11:59:52 <phadej> if it's not . then I'd not try to be too clever
12:00:03 <phadej> it will backfire when you'll try to understand what happens
12:00:34 <wroathe> Yeah, this is just for educational purposes. Trying to level up my composition understanding.
12:00:36 <phadej> it's better to assume that a person reading the code won't be able to hover on a term to see its type
12:02:17 <phadej> @pf \x -> f (g x)
12:02:17 <lambdabot> Maybe you meant: pl bf
12:02:20 <phadej> @pl \x -> f (g x)
12:02:20 <lambdabot> f . g
12:02:21 <Solonarv> @pl \x y z -> Foo x (bar y) z
12:02:21 <lambdabot> (. bar) . Foo
12:02:27 <phadej> @pl \x  y-> f (g x y)
12:02:27 <lambdabot> (f .) . g
12:02:39 <phadej> ^ that one I have seen few times
12:02:47 <phadej> anything beyond is just too cryptic
12:03:17 <phadej> I personally not able to type-check that in my head
12:03:27 <phadej> am not*
12:03:57 <phadej> :t \f g -> (f .) . g
12:03:58 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
12:04:42 <zincy> Thewse are kind signatures right not type signatures? type family Or (x :: Bool) (y :: Bool) :: Bool where
12:04:55 <wroathe> I suppose what I'm trying to write is an expression in terms of just composed functions that uses a (a -> b), (c -> d), and a (e -> f) to turn b -> d -> f -> g into a -> c -> e -> g
12:06:12 <wroathe> Solonarv: Oh, wait, you're a genius
12:06:16 <wroathe> Solonarv: Yet again
12:06:47 <Solonarv> zincy: indeed, they are kind signatures
12:06:59 <zincy> Solonarv: Thanks
12:07:00 <dmwit> wroathe: See `arg and result in this post: http://conal.net/blog/posts/semantic-editor-combinators
12:07:55 <dmwit> err, `argument` and `result`
12:08:18 <zincy> What are closed type families useful for?
12:08:33 <dmwit> ?let result = (.); argument = flip (.)
12:08:34 <wroathe> dmwit: I'll check it out. Thanks.
12:08:35 <lambdabot>  Defined.
12:08:51 <Solonarv_> @pl \x y z -> foo (i x) (j y) (k z)
12:08:52 <zincy> I can't think of any uses since they don't give you a new type constructor
12:08:54 <lambdabot> flip flip k . ((.) .) . (. j) . foo . i
12:08:58 <dmwit> :t \f g h -> argument f . argument (result g) . argument (argument (result h))
12:08:59 <lambdabot> error:
12:09:00 <lambdabot>     Ambiguous occurrence ‘argument’
12:09:02 <lambdabot>     It could refer to either ‘Lens.argument’,
12:09:03 <Solonarv_> wroathe: ^
12:09:08 <dmwit> ?undefine
12:09:08 <lambdabot> Undefined.
12:09:19 <dmwit> :t let result = (.); argument = flip (.) in \f g h -> argument f . argument (result g) . argument (argument (result h))
12:09:20 <lambdabot> (a1 -> (a2 -> c1) -> b1) -> (b1 -> c2) -> (b2 -> c1) -> (((a2 -> b2) -> c2) -> c3) -> a1 -> c3
12:11:01 <dmwit> :t let result = (.); argument = flip (.) in \f g h -> argument f . result (argument g) . result (result (argument h))
12:11:04 <lambdabot> (a1 -> b1) -> (a2 -> b2) -> (a3 -> b3) -> (b1 -> b2 -> b3 -> c) -> a1 -> a2 -> a3 -> c
12:11:07 <dmwit> There we go.
12:11:26 <dmwit> It's even relatively readable.
12:11:31 <Solonarv_> Huh.
12:14:02 <wroathe> Solonarv_: So I see that Thomas Yaegar wrote that @pl plugin. There must be some theory that it's built on for deriving that result expression.
12:14:03 <dmwit> :t \f g h -> dimap f (dimap g (dimap h id))
12:14:04 <lambdabot> (Profunctor p3, Profunctor p2, Profunctor p1) => (a1 -> b1) -> (a2 -> b2) -> (a3 -> b3) -> p1 b1 (p2 b2 (p3 b3 d)) -> p1 a1 (p2 a2 (p3 a3 d))
12:14:09 <dmwit> wroathe: ^
12:14:15 <wroathe> dmwit: stahp
12:14:56 <dmwit> There's only an id there because you didn't demand a way to modify the output. =P
12:15:24 <xKetjow> hey, is anyone able to help me with a function that splits a string into a list of runs of repeated characters, with each run comprising at most nine characters? from what i've gathered it's basically the group function but written differently, and I have to use a previously created function called munch to create it, munch :: String -> String
12:15:32 <xKetjow> damn is it possible to post code here
12:15:45 <Solonarv_> wroathe: the SKI calculus
12:15:54 <dmwit> xKetjow: No, use a pastebin, and send us a link.
12:16:05 <xKetjow> dmwit: ok
12:16:15 <wroathe> Thanks
12:16:30 <dmwit> :t group >=> chunksOf 9
12:16:32 <lambdabot> Eq e => [e] -> [[e]]
12:17:19 <dmwit> > group >=> chunksOf 9 $ "aaaaaaaaaaaaaabbb"
12:17:21 <lambdabot>  ["aaaaaaaaa","aaaaa","bbb"]
12:19:27 <xKetjow> ok i'll repost stuff, I need to make a function that splits a string into a list of runs of repeated characters, with each run comprising at most nine characters. from what i've gathered its basically the group function. i've got an idea for it to run munch on each unique character, i.e. if the string is "aaabbbccc" it'll run once on a, once on b, once on c to split them up, and then put them together. i've got all my code here: http
12:19:53 <dmwit> Your message got cut off right before the link.
12:20:13 <dmwit> (IRC has a maximum message size that isn't super enormous.)
12:20:21 <xKetjow> https://pastebin.com/674ZLekz is it there now?
12:20:23 <zincy> What is "defunctionalization"?
12:21:58 <lyxia> zincy: https://typesandkinds.wordpress.com/2013/04/01/defunctionalization-for-the-win/
12:22:08 <dmwit> xKetjow: Consider modifying `munch` to return two Strings instead of one, with the invariant that if `(x,y) = munch s` then `x++y = s`.
12:22:19 <dmwit> xKetjow: You can use `splitAt` instead of `take` for this purpose.
12:22:47 <xKetjow> dmwit: is it possible to do without modifying munch, as I don't think im able to modify the type and it has to stay as it is :/
12:23:21 <dmwit> Sure, it's possible. Write a counterpart, `antimunch :: String -> String` which returns the "rest of the string" compared to what `munch` does.
12:23:34 <dmwit> There are other ways, too.
12:24:05 <xKetjow> is there any easier ways or is that the easiest? i'm honestly not very good at haskell 
12:24:47 <dmwit> You could compute the length of the string returned by `munch` to determine how much of the original to `drop`.
12:28:18 <sebastianrkg> this sounds a lot like homework :)
12:28:40 <sebastianrkg> you don't need to modify the type signature of munch, just have it use a helper function (or helper functions) with the types you want
12:28:57 <xKetjow> yeah it is homework ;d
12:29:10 <xKetjow> can i not ask homework related stuff here or?
12:29:27 <sebastianrkg> it's totally fine, I did the same
12:29:37 <dmwit> You can. We will help as much as we can without feeling we're doing something immoral.
12:30:35 <xKetjow> good to hear at least, as i'm extremely lost on what i'm supposed to do. 
12:32:07 * hackage constraints-deriving 1.0.0.0 - Manipulating constraints and deriving class instances programmatically.  https://hackage.haskell.org/package/constraints-deriving-1.0.0.0 (achirkin)
12:32:30 <sebastianrkg> Did dmwit's post not actually solve the problem, though? The composition of group and chunksOf?
12:33:04 <wroathe> So is aaabbbccc supposed to map to ["aaa", "bbb", "ccc"]?
12:33:12 <xKetjow> yes
12:33:16 <zincy> How do saturated vs unsaturated type families relate to functional dependencies?
12:33:28 <wroathe> and what about aaabbbbbbbbbbc?
12:33:42 <wroathe> ["aaa", "bbbbbbbbb", "b", "c"]?
12:34:04 <xKetjow> yes
12:34:57 <dmwit> sebastianrkg: It seems there is a teacher-created requirement that munch be used, so no, group+chunksOf isn't enough.
12:35:28 <dmwit> But I do think we've given enough hints that xKetjow should be able to make progress. So if that's not the case, I feel the ball is in xKetjow's court to explain more about what's got him confused and stuck.
12:35:52 <dmwit> ...or her
12:35:54 <xKetjow> and yeah sorry didnt see your message, I have to use munch to create it unfortunately, I came up with an idea on how to use munch but my problem is that i have no actual idea how to write it
12:36:34 <xKetjow> like this is my first time ever doing haskell, i was fine with it up until the point when we started writing functions which is when i got totally confused 
12:38:00 <zincy> What is listToMaybe for?
12:38:48 <zincy> It just seems to wrap the head of a list in Just? Why would I want to do that?
12:41:01 <Solonarv_> zincy: perhaps you want a version of 'head' that doesn't crash when given an empty list?
12:41:33 <dmwit> zincy: I feel the same way.
12:41:47 <dmwit> That said, occasionally some functions demands a Maybe as an argument and you've got a list instead.
12:41:58 <zincy> Thanks I was just really confused as to its use.
12:42:20 <kadoban> It can come up a few places. If you think of the list as 0 to possibly many solutions to some question, and you only want one, that's a good case.
12:42:55 <zincy> So is defunctionalization just when you replace a polymorphic function with a type.
12:43:07 <zincy> And then say implement the functions behaviour in a type class
12:44:33 <zincy> Also is the right of the "|" the return value?  class Eval l t | l -> t
12:45:08 <zincy> Where l is the return type and is determined by t?
12:45:31 <zincy> other way round I think
12:54:16 <lyxia> t is determined by l
12:58:50 <zincy> lyxia: Thanks
13:00:22 <zincy> Trying a defunctionalization exercise here but I am not sure where i am going wrong
13:00:23 <zincy> https://pastebin.com/XKYe7xJV
13:22:23 <day> why is foldl's Type so long? '(a -> b -> a) -> a -> [b] -> a' it takes a function 'a', an argument 'b', and a list 'c' and returns a list, which too me would be 'a -> b -> [c] -> [?]'
13:24:08 <zincy> The first function takes two arguments (Current and Previous values)
13:24:16 <zincy> Also takes an initial value
13:24:40 <zincy> Thinking of it as a combining computation which starts with an initial value
13:26:57 <day> foldl (+) 1 [1,2] == [1+1,2+1] ?
13:28:01 <zincy> 1 + 1 + 2 = 4
13:28:40 <day> ah i think im mixing things up here
13:31:57 <zincy> foldl f z []     = z                  
13:31:57 <zincy> foldl f z (x:xs) = foldl f (f z x) xs
13:33:16 <Solonarv_> > fold (+) z [a, b, c]
13:33:18 <lambdabot>  error:
13:33:18 <lambdabot>      • Couldn't match type ‘[Expr] -> t’ with ‘Expr’
13:33:18 <lambdabot>        Expected type: ([Expr] -> t) -> Expr -> [Expr] -> t
13:33:26 <Solonarv_> > foldl (+) z [a, b, c] 
13:33:28 <lambdabot>  z + a + b + c
13:33:32 <zincy> If you really want to understand a recursive function write out its expansion
13:34:34 <zincy> Solonarv: What does > do?
13:34:55 <Solonarv_> zincy: it tells lambdabot to evaluate the following expression
13:35:02 <zincy> oh cool
13:36:42 <phadej> (and it works in private too)
13:36:48 <Solonarv_> the a, b, c stuff is from https://hackage.haskell.org/package/simple-reflect-0.3.3/docs/Debug-SimpleReflect.html
14:06:37 * hackage ip 1.4.2 - Library for IP and MAC addresses  https://hackage.haskell.org/package/ip-1.4.2 (chessai)
14:52:07 * hackage persistent-typed-db 0.0.1.0 - Type safe access to multiple database schemata.  https://hackage.haskell.org/package/persistent-typed-db-0.0.1.0 (parsonsmatt)
15:38:33 <bor0> I'm going through TAPL and I was wondering why does a context usually just hold types of terms, and not terms themselves?
15:39:05 <bor0> (not sure if this is the best channel to ask, too. the examples in the book are in OCaml but I like rewriting them in Haskell :)
16:08:32 <lyxia> You assign types to variables so that you can give a type to a term mentioning those variables.
16:10:59 <lyxia> You could certainly imagine a language where the value of a variable is relevant to typing a term containing it.
16:11:48 <lyxia> But that doesn't quite serve the purposes of TAPL, which is to study idealized languages to make the theory as crisp as possible.
16:15:06 <bor0> lyxia, I see. so that design is very suitable I'd guess for type inference algorithm?
16:15:20 <bor0> s/for/for e.g./
16:17:21 <bor0> lyxia, I have one more question :D I understand `E-PredZero` and `E-PredSucc` (Pred O = O and Pred (Succ k) = k respectively). but what on earth is `E-Pred` useful for? eval (Pred t1) = let t' = eval t1 in Pred t'
16:19:59 <bor0> well, I see the inference rule being useful for "constructing" `Pred`s, but does that eval really make sense? it's also in TAPL
16:26:45 <bor0> I think I get it. it's so that we can chain other expressions (e.g. Pred (IfThenElse ...))
16:27:12 <bor0> (sorry #haskell for being my rubber duck)
16:28:58 <hpc> you haven't truly #haskell rubber-ducked until you ask a question and then solve it yourself 5 seconds later :D
16:30:51 <bor0> :D
16:31:07 <hpc> i will never admit to how often i have done that
16:50:22 <dmwit> bor0: I have a slightly different answer than lyxia does to your contexts question.
16:50:36 <dmwit> Type systems are a lightweight static analysis.
16:51:25 <dmwit> During the type-checking phase, you may not *know* what values are going to be held in those variables.
16:52:23 <dmwit> For example, consider `let f x = x+3 in if collatzConjectureIsTrue then f 5 else f 6`; would you want `x=5` or `x=6` in the context when checking the type of `x+3`?
16:52:35 <dmwit> There's no good way to decide, and you might even have situations where `f` gets called multiple times.
16:53:39 <dmwit> On the other hand, it's easy to overapproximate the set of all values that might be passed to `f` by saying it's certainly going to be an `Int`, so putting `x :: Int` is well within the powers of a static analysis.
16:53:59 <dmwit> (...so putting `x :: Int` [in the context] is well within the powers...)
17:59:27 <aplainzetakind> How can I make libraries available to ghc(i) when called on .hs files outside projects when my setup is ghcup + pretty much always new-style project folders? Do I have to create a project even for short sketches?
18:00:36 <Solonarv_> aplainzetakind: 'cabal v2-repl -b package1 -b package2'
18:01:36 <Solonarv_> also I think you can 'cabal v2-install --lib whatever' and that will make the package available to a "raw" ghc(i), but I haven't tried that myself
18:02:14 <aplainzetakind> Solonarv_: Cool, I'll read up on that --lib, thanks.
18:02:52 <Solonarv_> aplainzetakind: finally, there is also cabal's script feature which lets you start a fie with a #!/usr/bin/env cabal shebang and make cabal compile & run them
18:02:58 <stevenxl> Hi folks. I am having trouble understanding what we are trying to express  with a type signature "applyToFive :: forall a. (a -> a) -> Int" versus the type signature "applyToFiveFixed :: (forall a. a -> a) -> Int".  What is the relationship of the type variable a in the "forall" versus the stuff after the period? 
18:03:40 <Solonarv_> you will need a special comment at the top of the file to specify dependencies, the cabal docs have details
18:04:03 <Solonarv_> (section 5, in the docs for the 'new-run' subcommand)
18:04:56 <Solonarv_> stevenxl: the difference is in who gets to pick what type 'a' is instantiated to
18:05:29 <Solonarv_> in the first variant, the caller of 'applyToFive' gets to pick what 'a' should be, and 'applyToFive' must work for all possible choices
18:07:25 <Solonarv_> in the second variant, the caller of applyToFiveFixed's argument gets to pick 'a', so the argument must work for all possible choices of 'a'
18:07:54 <Solonarv_> (the caller of applyToFiveFixed's argument is, of course, the implementation of applyToFiveFixed)
18:09:11 <stevenxl> Solonarv_:  Thank you that is a great explanation of what is going on here. 
18:58:07 * hackage timeconsole 0.1.0.5 - time each line of terminal output  https://hackage.haskell.org/package/timeconsole-0.1.0.5 (AlanHawkins)
22:06:07 * hackage ascii-table 0.3.0.2 - ASCII table  https://hackage.haskell.org/package/ascii-table-0.3.0.2 (mitchellwrosen)
22:17:39 <royal_screwup21> I'm trying to split a number into its digits like so:
22:17:57 <royal_screwup21> helper num
22:17:57 <royal_screwup21>   |num<= 0 = []
22:17:57 <royal_screwup21>   |otherwise = (num `mod` 10): toDigits (num `div` 10)
22:18:37 <royal_screwup21> when I do helper 1234, I get [4,2,1,3], but I was expecting 4321...where am I going wrong?
22:21:23 <royal_screwup21> ah nvm
22:32:07 <Rembane> :t divMod 
22:32:08 <lambdabot> Integral a => a -> a -> (a, a)
22:32:17 <Rembane> royal_screwup21: Check out divMod too, it's quite nice. 
22:33:44 <mud> Kind of awkward usually, honestly, but more efficient.
22:36:42 <Rembane> I use it in combination with the arrow operators which let me write my functions pointfree.
22:36:46 <Rembane> :t (&&&)
22:36:47 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
22:36:54 <Rembane> Hm... or was it the other one...
22:41:10 <royal_screwup21> Rembane: oh cool thanks
22:41:37 <royal_screwup21> say I want to pass the ouput of the result of a function to another function. For eg: foo ( bar (3) ). What's the idiomatic way to do this in haskell?
22:43:57 <Rembane> royal_screwup21: Parenthesis are nice, if you think you have too many of them, you can instead use a $ sign. 
22:44:16 <Rembane> royal_screwup21: For instance: negate (8+4)
22:44:24 <Rembane> royal_screwup21: Or: negate $ 8 + 4 
22:53:37 <mud> foo . bar . baz $ thing  is a pretty common form used to chain function calls together
23:05:44 <dminuoso> Is there some easy to determine the appropriate type alias for a given lens optic?
23:06:23 <dminuoso> Right now Im staring at a typed hole `(Indexable Int p) => ((a -> Const (First a) a) -> p Attribute (Const (First a) Attribute)`, wondering what this actually is in the most generic sense.
23:08:11 <dminuoso> It seems that this is just some `Getting First Attribute a`, is there another description?
23:13:37 <royal_screwup21> is this an invalid way to pattern match?
23:13:46 <royal_screwup21> oddOrEven::Int -> String
23:13:47 <royal_screwup21> oddOrEven x = case x of
23:13:47 <royal_screwup21>   x `mod` 2 == 0 = "even"
23:13:47 <royal_screwup21>   otherwise = "dodd"
23:14:29 <royal_screwup21> actually nvm, figured it out
23:15:32 <dminuoso> royal_screwup21: In Haskell pattern matching happens on data constructors, not on arbitrary expressions.
23:16:30 <dminuoso> Oh and my above should have been `Getting (First a) Attribute a`, the thing that just confuses me is how the First arrives there.
23:18:01 <dminuoso> Nevermind!
