00:00:08 <davean> So yah, large number math is slow
00:00:12 <kadoban> If nothing else, it makes your error messages *so* much better
00:00:12 <davean> arbitrarily slow
00:00:26 <davean> It'll massively change the performance
00:00:44 <kadoban> Probably like 5-10x if my memory is right
00:00:59 <davean> It'll just change the performance because its doing something different - but in this case more what the writer probably intended
00:01:00 <dtnsb> Alright, I'll do that.
00:01:16 <dtnsb> Here's my python function: https://pastebin.com/zn0dn1fi
00:01:39 <Rembane> Putting types also helps you think which is even more important.
00:01:56 <dtnsb> Rembane: that's very true
00:01:59 <kadoban> dtnsb: How long does that take to run on the same problem, out of curiosity?
00:03:07 <dtnsb> kadoban: the python?
00:03:10 <kadoban> Ya
00:03:50 <dtnsb> 0.16s
00:04:14 <davean> also, how are you running the Haskell?
00:04:16 <kadoban> Huh, faster than I thought
00:04:26 <dtnsb> davean: ghci
00:04:37 <davean> ok, so no optimizations at all then
00:04:44 <Rembane> ghc -O2 is a good start
00:05:22 <davean> and stopping at the sqrt
00:05:37 <kadoban> Stopping at the sqrt is going to be massively more important than anything else
00:06:16 <davean> eh, his N is small I think I could beat stopping at the sqrt with other techniques for a beter but ... yes
00:06:17 <dtnsb> So we've a new problem, ghc could not find module "prelude'
00:06:41 <davean> Well because you typed it wrong
00:06:44 <dtnsb> but ghci runs fine
00:07:00 <davean> well no
00:07:08 <davean> I suppose you're just running ghc?
00:07:13 <davean> Its Prelude, not prelude
00:07:20 <davean> but also you don't need to type it so ...
00:07:24 <davean> Its implicite
00:07:59 <dtnsb> I'm not typing it, that's the problem
00:08:06 <dtnsb> Just "ghc <filename>"
00:08:39 <kadoban> Hm, I never run ghc myself. Isn't it something like ghc --make <filename> though? Or does it not matter for this?
00:09:17 <dtnsb> this is just a stack problem, I'll solve that mess later
00:09:33 <davean> a stack problem?
00:09:43 <dtnsb> Yeah stack, as opposed to cabal
00:09:52 <davean> oh uh, you're using stack? No idea then
00:09:57 <dtnsb> I'm assuming that's the issue anyway
00:10:01 <kadoban> If you can use ghci, just doing that is fine. I suspect optimizations won't matter a ton in this.
00:10:13 <dtnsb> Right.
00:12:24 <dtnsb> So I know how to stop the factors function in haskell at the square root, but how do I add the partner factor to the list as well?
00:14:25 <kadoban> One way, kind of minimalish change is something like  factors x = concat [[i, x `div` i] | i <- [1..whatever], stuff]
00:16:55 <kadoban> Which builds up a list of lists, and then flattens it
00:17:17 <kadoban> So it'd be something like [[1, 10], [2, 5]] before it gets flattened
00:19:51 <dtnsb> That's an interesting idea, I'll look into that
00:31:36 <dtnsb> Alright, I've gotten it working, but it's long: factors x = concat [[i, x `div` i] | i <- [1..floor (sqrt (fromIntegral x)) + 1], x `mod` i == 0]
00:32:46 <dtnsb> Is there a way to make it more concise? Is a line that long considered bad style or is that more acceptable in Haskell?
00:41:55 <Lears> I would break it across a few lines.
00:42:40 <dtnsb> Can I use . to link together floor, sqrt, and fromIntegral?
00:44:11 <Lears> Probably refactor it to use do-notation sugar rather than list-comprehension sugar too, but that's just my taste. And yeah, you're applying a big composition (+1) . floor . sqrt . fromIntegral $ x, but I don't think that's actually an improvement over what you've written.
00:45:35 <ion> (floor . sqrt . fromIntegral) x
00:48:21 <dtnsb> I was messing up the precedence of x so I was getting a type error. I'll break it into two lines
00:52:46 <c50a326> \x -> f x $ g x  -- is there a shorter way to write this?
00:53:35 <Rembane> c50a326: f *** g 
00:53:42 <Rembane> iirc
00:53:45 <ion> @pl \x -> f x (g x)
00:53:45 <lambdabot> ap f g
00:54:03 <ion> a.k.a. f <*> g
00:54:28 <ion> Note that shorter might not mean better. :-P
00:54:48 <c50a326> yeah I was just writing <*> for Reader
00:55:13 <c50a326> I wondered if my definition was normal
00:56:19 <Rembane> Applicative instead of Arrow is better imo.
00:57:08 <ion> @type \f g x -> (f *** g) x
00:57:10 <lambdabot> (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
00:57:55 <Rembane> Hm... maybe I didn't recall correctly. 
00:58:26 <Rembane> I wonder if it was arr I was looking for 
00:58:59 <Rembane> Nope
00:59:11 <Rembane> @type \f g x -> app . (f *** g)
00:59:12 <lambdabot> (b1 -> b2 -> c) -> (b' -> b2) -> p -> (b1, b') -> c
00:59:23 <Rembane> @type \f g -> app . (f *** g)
00:59:24 <lambdabot> (b1 -> b2 -> c) -> (b' -> b2) -> (b1, b') -> c
00:59:28 <Rembane> Hm...
01:01:36 <Rembane> Nevermind. :D
01:06:05 <dtnsb> :q
01:06:09 <dtnsb> sorry, this isn't vim
01:47:25 <pyggins> Hello, I asked a question regarding some Haskell code that I was having trouble with not long ago. I have continued to work on it, however I have run into a new error that I am having difficulty with.
01:47:40 <pyggins> Code: http://dpaste.com/38SEQHG and http://dpaste.com/36DXWDF
01:47:51 <pyggins> GHC Output: http://dpaste.com/3E52FA3
01:49:58 <pyggins> I have tried to make it so that instances of the Charge class must implement a field method that produces a VectorField as output. Unfortunately, it appears that there is an issue with how I have instantiated VectorField.
01:50:28 <pyggins> I have tried playing around with the type signature of field within the class and instance, which hasn't worked.
01:50:46 <pyggins> (Hence why InstanceSigs is present in field.hs)
01:52:35 <akr> Hi!
01:53:16 <akr> Can anyone explain to me why Network.URI does not properly enforce the special characters?
01:53:19 <akr> for example:
01:53:27 <akr> λ> (fromJust $ parseURI "http://www.kek.com") {uriPath = "path.json"}
01:53:30 <akr> http://www.kek.compath.json
01:53:32 <akr> λ> uriPath <$> parseURI "http://www.kek.compath.json"
01:53:34 <akr> Just ""
01:54:15 <akr> why doesn't it insert a '/' automatically before the path
01:54:49 <akr> the current implementation leads to data being lost if you print then read a URI
01:55:37 <Lears> pyggins: `field c :: forall f. VectorField f => f` ... That's a problem. According to that signature you need to need to produce a value that is entirely agnostic as to which `VectorField` instance is chosen, but you have no way of constructing values like that; the class doesn't have any methods.
01:58:20 <pyggins> So I need to add methods to my typeclass, why is that? I thought there was a mismatch between Vector v, RealFloat n => v n -> v n and VectorField f => f
01:58:46 <Lears> There is.
01:58:55 <pyggins> Though I have an instance VField f s which should be the same as v s -> v s
01:59:42 <pyggins> What are you referring to? Could you please elaborate as I can't quite understand
02:00:49 <Lears> There is a mismatch. Typeclasses are open, so the compiler needs to assume that other instances may exist; it won't decide that the two types are equivalent because that instance is the only one in scope.
02:04:28 <Lears> Re the typeclass, I'm not saying you /should/ add methods, I'm saying that's the only way to satisfy the type signature `field` has. I don't really know what you're trying to do, but the empty class is unlikely to give you anything besides trouble. I would remove it and use the other type signature for `field`.
02:05:28 <pyggins> So I've tried removing VectorField and changing the type signatures to just VField, though I'm getting a different error now. I will paste it soon.
02:07:34 <pyggins> http://dpaste.com/2A1RR7S
02:07:42 <pyggins> for the updated field.hs
02:08:23 <pyggins> http://dpaste.com/332A3Y6
02:08:29 <pyggins> for the updated GHC output
02:15:17 <Lears> Looks like you have a similar problem to earlier, where the out-type depends on the in-type, but the details of that are hidden inside the `c`.
02:17:01 <Lears> You either need to be able to implement `field` in such a way that the `v` and `s` in `VField v s` bear no relation to the `v` and `n` in `PointCharge v n`, or expose those type variable in the signature of `field` like `(...) => c v s -> VField v s`.
02:17:06 <Lears> That's my best guess anyway.
02:19:19 <pyggins> So I changed it such that instances of Charge has the kind * -> *, and it works
02:19:25 <pyggins> (compiles)
02:20:42 <pyggins> I think I understand this a bit better after looking into it for a while.
02:20:48 <pyggins> Thank you for your help.
02:26:01 <akr> how can I find out which version of package was chosen by cabal in the end?
02:26:13 <akr> especially, which 'base'
02:27:37 <Rembane> akr: Which base depends on which version of GHC you use. 
02:28:56 <akr> Rembane: ah cool, I see
02:28:58 <Lears> pyggins: Np. Though I should point out that when you have trouble encoding something in typeclasses, it's usually time to step back and reconsider whether typeclasses are the right tool for the job. Everything ends up as regular functions in the end, and most things are better off starting that way.
02:29:03 <akr> https://wiki.haskell.org/Base_package
02:29:05 <akr> Rembane: thanks!
02:30:40 <pyggins> I see, I'm quite new to Haskell, so I'm not too familiar with concepts like typeclasses before. I wasn't too sure whether using typeclasses for VectorField was a good idea. Thanks for clearing up some of my confusion.
02:41:31 <akr> https://pastebin.com/raw/Hu7ewTjy
02:41:41 <akr> why doesn't it see this one? https://hackage.haskell.org/package/mime-mail-0.4
02:43:35 <akr> don't tell me that 4.0.0 > 4.0
02:44:03 <Lears> I seem to recall there being an embarrassing behaviour like that, I don't know if it's still around.
02:44:13 <Lears> But it sounds like it.
02:44:25 <akr> geez
02:44:35 <akr> well this is GHC 6.12
02:44:51 <Lears> Oh, if your cabal is ancient it wouldn't surprise me at all.
02:45:26 <akr> :(
02:46:01 <akr> guess I can always patch the library
02:52:36 * hackage tidal 1.0.9 - Pattern language for improvised music  https://hackage.haskell.org/package/tidal-1.0.9 (AlexMcLean)
02:54:31 <akr> yay, it compiles
02:54:36 <akr> take that, Cabal
02:54:50 * akr : 1; The Ancient One: 0
02:55:23 <akr> aaand there's a compilation error
02:55:23 <royal_screwup21> how is the "in" keyword supposed to be used?
02:55:55 <akr> royal_screwup21: let f = x in [... can refer to f here ...]
02:56:06 <c_wraith> royal_screwup21: it's it's part of let ... in ...
02:56:18 <c_wraith> royal_screwup21: let <decls> in <exp>
02:56:23 <akr> > let f = (+1) in f (f 0)
02:56:25 <lambdabot>  2
02:56:51 <royal_screwup21> ah I see
02:56:54 <akr> yeah you can also have more declarations
02:57:16 <akr> > let f = (+1); g = (*2) in g (f (f 0))
02:57:18 <lambdabot>  4
02:57:34 <akr> usually you'd separate them by newline though
02:59:15 <royal_screwup21> is there an equivalent to "in", in oop langauges?
02:59:53 <c_wraith> it's just a way of doing local bindings.  The equivalent in imperative languages is just multiple statements.
03:03:05 <Ariakenom> royal_screwup21: like python's? No, you'd use a function
03:03:13 <Ariakenom> > 1 `elem` [1,2]
03:03:14 <lambdabot>  True
03:03:41 <c_wraith> let/in is the sort of construct you find in expression-oriented languages, rather than statement-oriented languages.  It's the way you name things locally and have the whole thing still be an expression
03:05:46 <akr> also, note that `let a = x; b = y in f` is just syntactic sugar for `let a = x in let b = y in f`
03:06:21 <akr> which is a bit instructive regarding the "have the whole thing still be an expression"
03:06:23 <c_wraith> akr: that's not true, given mutually recursive bindings
03:06:57 <akr> oh yeah right
03:07:06 <akr> forgot it can do that as well
03:07:40 <c_wraith> > let x = 0 : y ; y = 1 : x in x
03:07:41 <lambdabot>  [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1...
03:30:05 <dminuoso> pyggins: Using preexisting typeclasses is fine, but writing your own typeclasses is frequently the wrong approach.
03:30:50 <pyggins> I see, well this was ultimately a learning exercise.
03:31:11 <pyggins> I would have used a proper library for vectors had it been more serious.
03:38:06 <delYsid> What is your favourite Hackage package?
03:39:06 <royal_screwup21> how do I filter a list filled with Maybe Ints? For eg: I have [Just 3, Nothing]. I want to get [3]
03:41:59 <c_wraith> > catMaybes [Just 3, Nothing]
03:42:01 <lambdabot>  [3]
03:42:56 <royal_screwup21> ah cool
03:43:02 <TimoMeijer> What language extension do I need to be able to call a polymorphic twice, but with different types? Do I need RankNTypes for this, or is there something specific to this?
03:44:08 <c_wraith> TimoMeijer: if it's an argument to a function, yes, you need RankNTypes to indicate it
03:46:33 <c_wraith> > let foo :: (forall a. a -> a) -> (Int, String) ; foo f = (f 0, f "") in foo id
03:46:34 <lambdabot>  (0,"")
03:49:14 <TimoMeijer> c_wraith: Hmm, how would this work if you need to constrain a with a class, for example Show a? Then it is no longer quite forall a, but you'd still like to express something like the example you just gave, except with Show a
03:49:28 <c_wraith> TimoMeijer: not too different
03:50:41 <c_wraith> > let foo :: (forall a. Show a => a -> String) -> (String, String) ; foo f = (foo (0 :: Int), foo ()) in foo show
03:50:43 <lambdabot>  error:
03:50:43 <lambdabot>      • Couldn't match type ‘(String, String)’ with ‘[Char]’
03:50:43 <lambdabot>        Expected type: String
03:50:55 <c_wraith> > let foo :: (forall a. Show a => a -> String) -> (String, String) ; foo f = (f (0 :: Int), f ()) in foo show
03:50:57 <lambdabot>  ("0","()")
03:51:07 <c_wraith> there we go.  helps to use the right name :)
03:51:54 <c_wraith> TimoMeijer: but yeah, you can specify constraints after the forall
03:52:03 <TimoMeijer> Ahh, that's pretty neat!
03:53:37 * hackage tidal 1.0.10 - Pattern language for improvised music  https://hackage.haskell.org/package/tidal-1.0.10 (AlexMcLean)
03:56:55 <TimoMeijer> Oh, but of course that doesn't work with lists, as then you'd be trying to stuff differently typed variables into a single list
03:57:08 <c_wraith> that part is certainly true
03:57:46 <dminuoso> % :set -XImpredicativePolymorphism
03:57:46 <yahb> dminuoso: Some flags have not been recognized: -XImpredicativePolymorphism
03:58:03 <dminuoso> % :set -XImpredicativeTypes
03:58:03 <yahb> dminuoso: 
03:59:07 <dminuoso> % ls :: [Show a => a ]; ls = [];
03:59:07 <yahb> dminuoso: 
04:01:52 <dminuoso> % data Showable = forall a. Show a => Showable a
04:01:52 <yahb> dminuoso: 
04:02:13 <dminuoso> % q = [Showable 'c', Showable (1 :: Int)]
04:02:13 <yahb> dminuoso: 
04:02:20 <TimoMeijer> That looks awful and amazing at the same time, I'm impressed
04:02:52 <dminuoso> TimoMeijer: That first one is just for giggles, you probably don't want ImpredicativeTypes turned on. But that second one is using ExistentialQuantification, it's pretty useful.
04:03:47 <dminuoso> % :t q
04:03:47 <yahb> dminuoso: [Showable]
04:04:48 <TimoMeijer> I can imagine, it feels more in the direction of an object-oriented superclas
04:04:50 <c_wraith> > let { foo :: (forall a. Show a => a -> String) -> [String] ; foo f = let { (%%) :: Show b => b -> [String] -> [String] ; x %% xs = f x : xs ; infixr 1 %% } in 13 %% () %% "hi" %% [] } in foo show
04:04:52 <lambdabot>  ["13","()","\"hi\""]
04:05:53 <c_wraith> TimoMeijer: You can use a helper like that to simplify creating a list from multiple types
04:06:19 <c_wraith> (Did you know you can put a fixity declaration inside of a let/where? fun stuff!)
04:08:20 <dminuoso> % hl = [Showable 1, Showable 'c', Showable "foo"]
04:08:20 <yahb> dminuoso: 
04:08:32 <dminuoso> % fmap (show . coerce) hl
04:08:32 <yahb> dminuoso: ; <interactive>:22:14: error:; * Couldn't match representation of type `()' with that of `Showable' arising from a use of `coerce'; * In the second argument of `(.)', namely `coerce'; In the first argument of `fmap', namely `(show . coerce)'; In the expression: fmap (show . coerce) hl
04:08:39 <TimoMeijer> Wow, amazing! Thanks for the insights, although in my specific usecase it's easier to avoid the list ;)
04:08:48 <dminuoso> % fmap (\(Showable a) -> show a) hl
04:08:48 <yahb> dminuoso: ["1","'c'","\"foo\""]
04:08:49 <c_wraith> that happens too. :)
04:09:20 <dminuoso> How are existentials implemented? Do they use the same type refinement mechanisms that GADTs use?
04:09:35 <c_wraith> existentials throw away type information
04:10:04 <dminuoso> c_wraith: The dictionary is preserved though.
04:10:06 <c_wraith> if they close over a class, the implementation ghc uses is to just store the class dictionary as an argument to the constructor
04:10:38 <dminuoso> c_wraith: Ah I remember. Pattern matching brings dictionaries back into scope, its the mechanism that Kmetts constraints library is based on.
04:11:07 <dminuoso> c_wraith: It just kind of feels like "refinement"
04:11:25 <c_wraith> yep.  pattern matching creates a skolem type variable that the type checkers knows has an instance, but nothing else about
04:11:36 <c_wraith> *checker
04:12:02 <c_wraith> I only know about skolem types thanks to ghc's wonderful "The skolem would escape" error
04:12:19 <dminuoso> I think the error message was toned down a bit in 8.4.
04:12:20 <c_wraith> which makes me assume they're some terrible monster that must be kept locked away forever
04:12:30 <dminuoso> Heh.
04:12:35 <c_wraith> probably related to a golem
04:13:38 <dminuoso> c_wraith: I think the error message is particularly confusing because of the implicit type inference. In the value world the equivalent would be "variable not in scope", which is not scary at all.
04:14:20 <dminuoso> Admittedly I dont understand what a skolem type variable really is though.
04:15:00 <c_wraith> it's essentially a rigid type variable that is confined to a particular scope
04:15:15 <c_wraith> which is yet another term I learned only from ghc error messages.
04:15:29 <c_wraith> a rigid type variable being one that isn't allowed to unify with any concrete type
04:15:34 <dminuoso> Oh yes, rigid types are those type variables that are not wobbly!
04:15:48 <dminuoso> GHC doesnt actually use the term "wobbly" though, does it?
04:15:51 * dminuoso ripgreps
04:15:54 <c_wraith> not that I've seen
04:16:04 <c_wraith> only explanations of where "rigid" comes from do
04:16:57 <dminuoso> c_wraith: Shouldn't that read "a type variable that is not allowed to unify with other type variables" (because its bound by an outside context)?
04:18:11 <c_wraith> well, no..  It's allowed to unify with wobbly type variables
04:18:29 <c_wraith> I guess that's the thing.  It's not allowed to unify with concrete types or other rigid type variables
04:19:34 <dminuoso> I need to implement this myself for once.
04:19:50 <c_wraith> I guess you could see that the other way around, as the wobbly type variable unifying with it, but I prefer to think of unification as undirected
04:54:10 <cocreature> dminuoso: GADTs are implemented as existentials with (a ~ Int)-like constraints so yeah they use the same mechanism but it’s the other way around :)
05:10:40 <royal_screwup21> could someone help me understand what's wrong with example? (it's about defining instance with constraints). So, I want to define an instance of Listable, parameterized on a, AND constrain a to be a Num.
05:10:45 <royal_screwup21> https://repl.it/repls/SpecializedUnfinishedAbstractions
05:16:17 <royal_screwup21> ok, flexible isntances
05:25:20 <philippD> royal_screwup21
05:25:20 <philippD> royal_screwup21. You have to be careful though. When resolving instances Haskell doesn't check for Constraints. That means that you have defined a `Listable` instance for all `a`. So even if you define an instance on a more concrete type like `Bool` you will get an overlapping instances error since both instances match.
05:32:59 <thebigj> https://www.twitch.tv/events/G9Wcy51VQg-aqRf2L5dYoQ
06:21:21 <Uniaika> hello! I'm currently following this tutorial: https://wespiser.com/writings/wyas and I am trying to replace its use of Parsec with Megaparsec. Especially, Text.Parsec.Token seems covered in the transition manual, but not Text.Parsec.Language, for which I cannot seem to find an alternative.
06:21:42 <Uniaika> (the tutorial is from 2016, if anyone has a more recent resource, I'll gladly take it!)
06:39:02 <c50a326> hey is there a way to load modules by passing command line arguments to the ghci command?
06:41:14 <Uniaika> c50a326: I'm pretty sure you can only do it with `:load` once you're in the repl
06:45:27 <akr> I'm trying to use `stack solver`: https://pastebin.com/raw/DRNWRNeH
06:45:34 <akr> should I try downgrading cabal-install?
06:45:49 <__monty__> Uniaika: No, :load/:l can be substituted for by passing an argument `ghci path/to/load.hs`
06:46:03 <__monty__> :m + or import otoh I don't know.
06:46:56 <akr> c50a326: you can use a .ghci file to instruct ghci to load certain modules
06:47:52 <akr> beware that they are a huge pain to use with docker, as docker has non-standard ownership of the file and ghci refuses to load .ghci unless it's owned by the current user and not writable by anyone else, or somesuch
06:50:28 <__monty__> c50a326: Another thing that might help is C-r, lets you reverse search for commands you've entered before so it could reduce the work to C-rText<CR>
06:58:24 <dminuoso> cocreature: That makes much sense now. :)
06:59:59 <Uniaika> __monty__: ah indeed
07:00:04 <Uniaika> I had forgotten about that
07:02:19 <akr> I don't understand the output from cabal-install
07:02:28 <akr> probably because stack cut off the important bits
07:03:34 <__monty__> akr: Can you repaste. Not available anymore.
07:04:38 <akr> __monty__: huh. this one?
07:04:39 <akr> https://pastebin.com/raw/DRNWRNeH
07:04:41 <akr> I can open it
07:05:05 <__monty__> Ah, may have copied the timestamp with it. Confusing 404 thoug.
07:05:32 <akr> oh, right
07:05:38 <__monty__> The issue is on stack's side.
07:05:46 <__monty__> So yeah, try downgrading.
07:05:59 <akr> alright, will do
07:06:01 <akr> thanks!
07:06:38 <__monty__> Stack's not exactly on top of the ball here though, cabal-install 2.5 is being worked on afaik so that's two major versions?
07:07:07 * hackage ENIG 0.0.0.2 - Auto Korean conjugator/adjustor/adopter/converter  https://hackage.haskell.org/package/ENIG-0.0.0.2 (yongjoon)
07:07:16 <akr> yeah, what version of cabal-install should I try with?
07:07:43 <akr> 2.4 or 2.2. I guess
07:13:08 <akr> ok it's complaining that even cabal-install 2.2.0.0 hasn't been tested and is too new
07:13:13 <akr> and yeah, same error
07:18:33 <__monty__> Maybe you should pursue updating stack instead?
07:19:44 <akr> well it's version 1.9.3, which seems to be the latest?
07:20:01 <akr> https://hackage.haskell.org/package/stack
07:20:09 <akr> I have no idea what 9.9.9 is supposed to be
07:22:38 <CelestialLake> Not sure but it's probably a tip version of it. At least, it's failing in CI, so yeah, 1.9.3 is the latest.
07:25:37 <thebigj> https://www.twitch.tv/jaysinhp
07:25:38 <thebigj> Learn you a haskell for great good! Starting soon
07:26:14 <akr> lol, stack complains that even cabal 2.0 is too new
07:26:23 <akr> but at least it doesn't crash anymore
07:26:23 <__monty__> Surely stack 1.9.3 should work with cabal 2.0 then? Maybe something else going on?
07:26:38 <akr> well, it seems to work
07:26:43 <CelestialLake> Can you elaborate on what do you get there?
07:26:45 <CelestialLake> Ah.
07:26:47 <akr> though it is, apparently, "untested"
07:28:42 <akr> hmm
07:28:53 <akr> when you run the solver, why does it lock some package versions
07:29:13 <akr> and then acts surprised when it can't find a build plan
07:33:01 <akr> well it's best not to use the solver it seems
07:34:15 <dmj`> HsOpenSSL and tls don't support using the Handle interface ? Would be nice to not have to worry about buffering
07:35:40 <royal_screwup21> could someeone explain to me how fmap is used here? https://repl.it/repls/SpecializedUnfinishedAbstractions Specifically, how is something of type Maybe being produced at all?
07:37:54 <dminuoso> royal_screwup21: You could eta-extend it, it might help.
07:38:46 <dminuoso> royal_screwup21: The Maybe is probably introduced in case of a failed parse.
07:38:59 <dminuoso> But without seeing a bit more context, it
07:39:02 <dminuoso> But without seeing a bit more context, it's hard to say.
07:40:10 <royal_screwup21> dminuoso: ah okay, I have the code for the parser here: https://repl.it/repls/SpecializedUnfinishedAbstractions
07:41:00 <akr> oh god, what is going on with the instances here http://hackage.haskell.org/package/haskelldb-2.2.4/docs/Database-HaskellDB-BoundedList.html
07:42:14 <dminuoso> akr: It's just hard wired type level naturals without peano construction.
07:42:22 <akr> well I can see that :P
07:42:31 <akr> i'm just commenting on how terrible it is
07:42:32 <akr> besides
07:42:41 <akr> it doesn't compile with GHC 8.4
07:43:03 <dminuoso> royal_screwup21: parseExp :: (Integer -> a) -> (a -> a -> a) -> (a -> a -> a) -> String -> Maybe a
07:43:21 <dminuoso> So:
07:43:50 <dminuoso> parseExp ExprT.Lit ExprT.Add ExprT.Mul :: String -> Maybe Integer
07:44:42 <dminuoso> akr: Mmm, possibly a hack from before Nat was a thing?
07:44:44 <deathcap> 6 years ago I tried reading through learnyouahaskell when completely foreign to FP...coming from a mostly Perl background. I'm rereading it after getting fluent in both Java 8 and Clojure and y'know, this isn't nearly as opaque as I remember it being.
07:45:01 <dminuoso> Not sure for how long Nat has existed really.
07:45:09 <royal_screwup21> oh okay hmm...shouldn't it be Maybe ExprT as the return type?
07:45:40 <dminuoso> royal_screwup21: Oops! Good catch.
07:45:45 <dminuoso> royal_screwup21: Just making sure you were paying attention, of course.
07:45:56 <akr> dminuoso: that seems plausible, that package is quite old... any tips on how to fix this compile error? https://pastebin.com/raw/VgubqCCB
07:46:04 <akr> maybe just some GHC extension
07:46:54 <royal_screwup21> dminuoso: I'm not sure how exactly is fmap is coming into play here...is it unwrapping the Maybe T to be a T?
07:47:01 <dminuoso> royal_screwup21: It is not.
07:47:04 <dminuoso> royal_screwup21: fmap cannot do that.
07:47:24 <dminuoso> royal_screwup21: Notice what mistake I just made?
07:48:15 <dminuoso> royal_screwup21: You just correctly determined that:  parseExp ExprT.Lit ExprT.Add ExprT.Mul :: String -> Maybe ExprT
07:48:24 <royal_screwup21> yup
07:48:34 <dminuoso> royal_screwup21: Now you have a function that goes: ExprT -> Integer
07:48:49 <dminuoso> How do you apply that to some `e :: Maybe ExprT` ?
07:49:38 <royal_screwup21> dminuoso: pattern match? If it's a Nothing, then output NOthing, if it's Just expr, then eval on the expr
07:49:53 <dminuoso> royal_screwup21: Correct.
07:50:09 <dminuoso> royal_screwup21: Maybe has a Functor instance, where fmap is from, that does exactly that.
07:50:55 <dminuoso> % fmap (+1) (Just 6)
07:50:55 <yahb> dminuoso: Just 7
07:51:00 <dminuoso> % fmap (+1) Nothing
07:51:00 <yahb> dminuoso: Nothing
07:51:11 <royal_screwup21> ah I see, thanks for clarifying
07:51:59 <Nevoic> I don't know if anyone here knows F#, but this seems to be common in most functional languages except Haskell, why is it common to see code like this: `["one"; "two"] |> List.map (fun x -> x.length) |> List.iter (fun x -> printf "Testing %s" x)`
07:51:59 <Nevoic> In languages don't even advertise as functional (Kotlin/Swift) doing this is much more concise `["one", "two"].map { it.length }.forEach { println("Testing $it}") }`
07:51:59 <Nevoic> My main issue is the fact that `List.` can't be inferred by the fact that the argument passed into it is a List.
07:53:14 <dminuoso> Nevoic: Because overloading can be complicated to implement and have plenty of consequences.
07:53:35 <dminuoso> Nevoic: It begins with the question, what type does `map` have really?
07:55:03 <Nevoic> I know in some languages, it's inferred based on what it's called on. `listOf().map` and `arrayOf().map` would refer to different methods in Kotlin, I'd assume the same could in theory be done in F# with `[] |> map`
07:56:35 <dminuoso> Nevoic: So `map` has no clear identifiable type then?
07:57:01 <dminuoso> Nevoic: In Haskell we use typeclasses to implement such overloading, so we have this generic thing
07:57:03 <dminuoso> % :t fmap
07:57:03 <yahb> dminuoso: Functor f => (a -> b) -> f a -> f b
07:57:47 <dminuoso> Typeclasses are a weird breed though. You can have only one instance per type, and we have the open world assumption.
07:58:01 <Nevoic> I don't see how in my example there would be no clear identifiable type.
07:58:21 <Nevoic> I'm talking about inferring the type. Does that not make sense?
07:58:59 <Nevoic> `List.map` is well typed. If you are passing a map in through `|>` then you could (in theory) infer `List`.
07:59:05 <Nevoic> passing a list in through *
08:02:04 <dminuoso> Nevoic: I dont have any complete answer in the end, I just know that it's a complicated design space with no "best answer"
08:02:39 <dminuoso> Nevoic: http://homepages.inf.ed.ac.uk/wadler/papers/cochis/cochis.pdf might be an interesting paper talking about some of the problems.
08:03:39 <dminuoso> Nevoic: So the choice of overloading mechanism depends on what properties you want your type system to have. To really know why F# is the way it is, you could perhaps contact someone from Microsoft Research on the F# team.
08:03:56 <Nevoic> Sure, I might just like a different language more. I think I'd enjoy Haskell more than F#, but I spent like an hour trying to get Haskell autocomplete working effectively in Atom/Intellij/Vim and none of them worked. I was able to install Rider and get the F# toolset running fully in 10 minutes.
08:04:51 <dminuoso> Nevoic: The Haskell tooling is not very good indeed, it's probably largely because there's no corporate backing in tooling currently.
08:04:58 <Nevoic> I'm coming from the JVM, so I'm used to really good tooling, like inline error highlighting (underlining the error), debugging, autocomplete (not text based, compile-time autocomplete) etc.
08:05:05 <Nevoic> Yeet, that's what I assumed.
08:05:28 <dminuoso> Nevoic: As far as I understand, things are getting better though. haskell-lsp seems promiising
08:05:32 <Nevoic> I think I'd really like to dive into Idris/Haskell, but I'd practically have to go back to what I had to do in dynamic languages (read docs).
08:05:48 <Nevoic> A lot of different engines seem promising, but none of them are there yet, like you said.
08:06:08 <dminuoso> Nevoic: Yeah it's not very good indeed. :(
08:06:24 <dminuoso> The language more than makes up for the lack of tooling, however.
08:06:31 <Nevoic> How so?
08:08:26 <Nevoic> Do you just mean you like programming in Haskell despite the poor tooling? Or that the language does something in place of the tooling?
08:08:36 <dminuoso> Nevoic: The former.
08:08:45 <Nevoic> Ah okay.
08:10:24 <dminuoso> Nevoic: Since you have an F# background, you should at least give it a try. Not to convince you it's a better pick, but to get a taste for a extensible type system - one that supports an overloading mechanism you long for..
08:12:22 <royal_screwup21> isn't reification possible with the visitor pattern in oop? I'm looking at this here for what reification means https://github.com/bschwb/cis194-solutions/blob/master/05-typeclasses/05-type-classes.pdf and the idea, we don't know how to evaulate something because we don't it's concrete type -- we just know that implements a type class
08:12:31 <royal_screwup21> the idea is*
08:13:38 <royal_screwup21> don't know*. I bring it up cuz people say reification isn't possible in java, but if this definition of reification is correct, then it is very much possible to do so with the visitor pattern....
08:13:39 <dminuoso> royal_screwup21: reification is taking an abstract concept and making it concrete.
08:13:54 <dminuoso> royal_screwup21: reflection is taking something concrete and generating an abstraction.
08:14:58 <dminuoso> (so they are inverses of another)
08:15:41 <royal_screwup21> in java I'd do: abstract class Expr () { <T> void accept(ExpressionVisitor visitor<T>) { return visitor.visit(this); } }
08:15:43 <dminuoso> royal_screwup21: So to say "reification isnt possible in java", you need to be much more precise what exactly you are trying to reify.
08:15:54 <dminuoso> That is, what exact "abstract concept" do you want to reify?
08:16:28 <royal_screwup21> hmm...this is slightly confusing
08:16:37 <royal_screwup21> ignore that java code
08:18:44 <dminuoso> royal_screwup21: Unrelatedly, it might be helpful to understand that many "OOP design patterns" are not "best practices" on the basis of being "well designed things", but they are frequently ways to shoehorn basic concepts into a language with no first-class support for said features.
08:19:06 <dminuoso> For example the Java factory pattern is an artifact of the language not supporting top level functions and partial application.
08:19:44 <dminuoso> It's how you gain very rudimentary functional programming features into a language without such features.
08:24:19 <dminuoso> royal_screwup21: So what kind of reification are you talking about?
08:25:31 <CelestialLake> dminuoso: sounds borderline Greenspun-ish
08:26:23 <royal_screwup21> dminuoso: I'm just re-reading a few posts again about what reification actually means :)  As I understand it, in java, if I parameterize a method on T, I can't check if an object is of instance T...
08:29:54 <royal_screwup21> eg: <T> bool is_it_a_T(T:myType, Thing:Object) { return thing instanceOf T; } -- would not be possible
08:31:29 <dminuoso> royal_screwup21: Okay I think I can see what you are getting at.
08:33:05 <dminuoso> royal_screwup21: This would be called reflection, not reification.
08:35:09 <CelestialLake> Is it about reifying the type of an object belonging to some typeclass or so? Can't get the complete context.
08:36:31 <fmsbeekmans> I'm trying to implement `Comonad` for `Traced` as an exercise but I'm getting a contstraint resolution error that I don't know how to resolve https://gist.github.com/fmsbeekmans/50daf47810f6bc2b6e233a7da1c6fb4c
08:36:57 <royal_screwup21> huh, for some reason this tab consumed 100% of one my cores, had to disconnect
08:37:42 <fmsbeekmans> From this I derive that GHC doesn't 'remember' the constraint `Monoid b` on the newtype `Mempty`.
08:37:59 <dminuoso> fmsbeekmans: You need to add the constraint (Monoid a) to the instance declaration.
08:38:08 <dminuoso> fmsbeekmans: Consider what you are claiming right now:
08:38:46 <dminuoso> Oh wait, I misunderstood.
08:38:50 <dminuoso> fmsbeekmans: Yes, its forgotten.
08:39:15 <dminuoso> fmsbeekmans: The Monoid is on the wrong side though, it should be on the domain of the function.
08:39:36 * hackage enum-text 0.5.0.0 - A text rendering and parsing toolkit for enumerated types  https://hackage.haskell.org/package/enum-text-0.5.0.0 (ChrisDornan)
08:39:43 <dminuoso> (And then you can integrate it into the instance, by specifying: instance (Monoid a) => Comonad (Traced a) where ...
08:39:57 <fmsbeekmans> Oh really? extract should be runTraced mempty?
08:40:20 <fmsbeekmans> Ah, that simplifies things.
08:41:42 <dminuoso> fmsbeekmans: The extend/duplicate portion is fun though. :-)
08:41:54 <fmsbeekmans> Ah yes, that works.
08:42:25 <dminuoso> fmsbeekmans: I did not even know that what you wrote was legal syntax.
08:42:29 * Solonarv sees a context on a datatype
08:42:32 * Solonarv hisses
08:42:38 <dminuoso> % newtype Traced a b = Traced { runTraced :: a -> b }
08:42:38 <yahb> dminuoso: 
08:42:44 <dminuoso> % newtype (Monoid b) => MTraced a b = MTraced { runMTraced :: Traced a b }
08:42:44 <yahb> dminuoso: ; <interactive>:29:9: error: Illegal datatype context (use DatatypeContexts): (Monoid b) =>
08:42:55 <fmsbeekmans> @dminuoso: Thanks! I'll let you know how it goes.
08:42:55 <lambdabot> Unknown command, try @list
08:43:16 <dminuoso> fmsbeekmans: Once you are done, implement TracedT too for good measure. ;)
08:43:33 <dminuoso> Comonad transformers are an undiscovered art.
08:43:39 <fmsbeekmans> Should the constraint have been on runMTraced?
08:44:08 <Solonarv> I'm of the opinion that it shouldn't be in the type declaration at all
08:44:09 <fmsbeekmans> I know I should but there are so many things that I still want to explore :D Maybe this is the correct next step to make sure it sinks in.
08:45:13 <fmsbeekmans> Solonarv: In this context it wasn't needed, is that what you're referring to or is it a general style issue?
08:45:14 <Solonarv> if you must, you can do this:
08:45:14 <Solonarv> data MTraced a b where
08:45:14 <Solonarv>   MTraced :: Monoid a => { runMTraced :: Traced a b } -> MTraced a b
08:45:24 <Solonarv> fmsbeekmans: both!
08:45:50 <Solonarv> You can stuff a constraint into a *constructor* (as I've shown above), but that can't be a newtype
08:46:17 <Solonarv> and there's usually not much of a point
08:46:35 <fmsbeekmans> Is that because the newtype gets compiled away?
08:47:04 <dminuoso> fmsbeekmans: Putting constraints on newtypes is just overly restrictive.
08:47:51 <ilya_b> Hello!
08:47:53 <fmsbeekmans> dminuoso: Do you mean that it's generally not useful?
08:47:57 <dminuoso> fmsbeekmans: Correct.
08:48:22 <ilya_b> What do I need to change in this short Alex lexer to compile it for ByteStrings? https://pastebin.com/47FiHDWE
08:48:22 <dminuoso> fmsbeekmans: If, for some reason, you need those constraints to maintain invariants hide the data constructor and make a smart constructor.
08:48:30 <fmsbeekmans> I'm still new to the language, I haven't quite gotten used to the idioms
08:48:34 <dminuoso> fmsbeekmans: Otherwise just put the constraints on the implementation that requires a consraint.
08:48:53 <dminuoso> fmsbeekmans: For example, just putting it on the Comonad instance is enough.
08:49:10 <dminuoso> fmsbeekmans: You dont need to care whether (Monoid a) is satisfied if the user does not actually use the Comonad instance.
08:49:25 <dminuoso> It's just overly restrictive and prevents other uses.
08:49:38 <fmsbeekmans> dminuoso: I did it with a newtype because I thought I needed it on the other type parameter, the one which is not named in the class declaration.
08:49:58 <dminuoso> fmsbeekmans: If that was the case, then a superclass constraint would have been appropriate.
08:50:09 <dminuoso> Though.. wait. Not possible in your case.
08:50:24 <dminuoso> fmsbeekmans: In that case, putting it on the method.
08:51:01 <fmsbeekmans> Would that be allowed? Adding a constraint to a instance method that is not on the class method?
08:51:22 <dminuoso> fmsbeekmans: Ah no.
08:51:51 <Solonarv> % :i Traversable -- yes! on the class *definition*
08:51:51 <yahb> Solonarv: ; <interactive>:1:3: error: parse error (possibly incorrect indentation or mismatched brackets)
08:51:55 <Solonarv> whoops
08:51:59 <Solonarv> % :i Traversable
08:52:00 <yahb> Solonarv: class (Functor t, Foldable t) => Traversable (t :: * -> *) where; traverse :: Applicative f => (a -> f b) -> t a -> f (t b); sequenceA :: Applicative f => t (f a) -> f (t a); mapM :: Monad m => (a -> m b) -> t a -> m (t b); sequence :: Monad m => t (m a) -> m (t a); {-# MINIMAL traverse | sequenceA #-}; -- Defined in `Data.Traversable'; instance [safe] Traversable f => Traversable (WriterT w
08:57:49 <fmsbeekmans> What are some of the use cases for `Env` and `Traced`, separate from `Store`
08:57:57 <fmsbeekmans> ?
09:19:06 <thebigj> I just ended my live session of Learn you a Haskell for great good Chapter 3. You can watch video here https://clips.twitch.tv/RefinedAmericanJaguarBudBlast
09:19:09 <thebigj> I just ended my live session of Learn you a Haskell for great good Chapter 3. You can watch video here https://clips.twitch.tv/RefinedAmericanJaguarBudBlast
09:19:14 <thebigj> Please write back if you want to be a part of this group reading session
09:19:16 <thebigj> Please follow to not miss next announcements
09:19:18 <thebigj> Thanks :)
09:21:57 <ilya_b> Why don't lazy ByteStrings have getLine?
09:26:07 * hackage betris 0.2.0.0 - A horizontal version of tetris for braille users  https://hackage.haskell.org/package/betris-0.2.0.0 (mlang)
09:31:36 * hackage hit-on 0.0.0 - Haskell Git Helper Tool  https://hackage.haskell.org/package/hit-on-0.0.0 (vrom911)
09:39:31 <fmsbeekmans> dminuoso: How does `TraceT` relate to `Trace`? I haven't wrapped my head around comonad transformers yet.
10:00:43 <mniip> ilya_b, just covert a strict one to a lazy one
10:00:49 <mniip> it's not like you can getline lazily anyway
10:10:23 <dmwit> I don't see why not.
10:17:06 <akr> how do I use a patched library with stack? do I need to build it beforehand or can I have stack build it for me?
10:22:06 <lyxia> you can have stack build it for you
10:22:47 <lyxia> akr: https://docs.haskellstack.org/en/stable/yaml_configuration/#packages-and-extra-deps
10:24:47 <akr> lyxia: hmm that's what I was trying, for some reason stack doesn't build the package I list in packages
10:27:36 * hackage arbtt 0.10.2 - Automatic Rule-Based Time Tracker  https://hackage.haskell.org/package/arbtt-0.10.2 (JoachimBreitner)
10:48:40 <akr> ahh okay I think I'm stating the dependency incorrectly in extra-deps
10:57:36 * hackage lens-labels 0.2.0.3 - Integration of lenses with OverloadedLabels.  https://hackage.haskell.org/package/lens-labels-0.2.0.3 (JudahJacobson)
10:58:37 * hackage proto-lens-arbitrary 0.1.2.2.1, proto-lens-protoc 0.3.1.3, proto-lens 0.3.1.3 (JudahJacobson)
11:02:36 * hackage proto-lens-protobuf-types 0.3.0.3 - Basic protocol buffer message types.  https://hackage.haskell.org/package/proto-lens-protobuf-types-0.3.0.3 (JudahJacobson)
11:03:37 * hackage proto-lens-combinators 0.1.0.12 - Utilities functions to proto-lens.  https://hackage.haskell.org/package/proto-lens-combinators-0.1.0.12 (JudahJacobson)
11:04:07 <akr> how can I tell `stack build` to not stop compilation on the first file where it encounters an error?
11:07:39 <sternmull> stack build --keep-going
11:20:59 <dmj`> Does anybody know if a Handle-based interface exists for Context from HsOpenSSL or tls packages?
11:27:20 <nshepperd_> Why the heck is cabal new-repl telling me that the package whose I'm invoking it in is a "hidden package"?
11:27:42 <nshepperd_> Why i try to import its modules
11:27:52 <nshepperd_> When
11:29:53 <nshepperd_> Also throws "cc1: fatal error: dist/build/autogen/cabal_macros.h: no such file or directory", maybe that has something to do with it
11:30:54 <fen> % join [[1,2],[1,2]]
11:30:54 <yahb> fen: [1,2,1,2]
11:31:06 <fen> is duplicate the opposite of join?
11:31:42 <fen> like, is the monad instance for nonempty actually fmap extract?
11:32:37 <fen> guess thats not available for lists as extract would fail for []
11:33:08 <fen> so is this "concat" style of join particular to lists very much to do with its lack of comonad instance?
11:34:05 <fen> so that monads which *are* comonads must have a duplicate that is the inverse of join...
11:34:20 <fen> well, thats the question anyway
11:34:52 <Solonarv> I don't think duplicate and join have to be inverses
11:35:54 <Solonarv> % import Data.List.NonEmpty
11:35:54 <yahb> Solonarv: 
11:36:23 <Solonarv> % :set -XOverloadedLists
11:36:23 <yahb> Solonarv: 
11:36:39 <Solonarv> % join [[1, 2], [3, 4]] :: NonEmpty Int
11:36:39 <yahb> Solonarv: 1 :| [2,3,4]
11:37:05 <Solonarv> % duplicate @NonEmpty [1, 2, 3, 4]
11:37:05 <yahb> Solonarv: (1 :| [2,3,4]) :| [2 :| [3,4],3 :| [4],4 :| []]
11:37:14 <Solonarv> see, they aren't inverses
11:38:07 <fen> yeah but thats because join is using the concat version like list
11:38:10 <fen> of join
11:38:20 <fen> if it were fmap extract...
11:38:21 <Solonarv> that's the only valid version, so of course it is
11:38:31 <Solonarv> pretty sure fmap extract is law-breaking
11:39:01 <fen> % fmap extract (1 :| [2,3,4]) :| [2 :| [3,4],3 :| [4],4 :| []]
11:39:02 <yahb> fen: ; <interactive>:37:1: error:; * Could not deduce (Comonad w0); from the context: (Comonad w, Num b, Num (w b)); bound by the inferred type for `it':; forall (w :: * -> *) b. (Comonad w, Num b, Num (w b)) => NonEmpty (NonEmpty b); at <interactive>:37:1-60; The type variable `w0' is ambiguous; * In the ambiguity check for the inferred type for `it'; 
11:39:18 <fen> % fmap extract @Nonempty (1 :| [2,3,4]) :| [2 :| [3,4],3 :| [4],4 :| []]
11:39:18 <yahb> fen: ; <interactive>:38:15: error:; Not in scope: type constructor or class `Nonempty'; Perhaps you meant one of these: `NonEmpty' (imported from Data.List.NonEmpty), `NonEmptyF' (imported from Data.Functor.Base)
11:39:26 <fen> % fmap extract @NonEmpty (1 :| [2,3,4]) :| [2 :| [3,4],3 :| [4],4 :| []]
11:39:26 <yahb> fen: ; <interactive>:39:1: error:; * Cannot apply expression of type `f0 (w0 b0) -> f0 b0'; to a visible type argument `NonEmpty'; * In the first argument of `(:|)', namely `fmap extract @NonEmpty (1 :| [2, 3, 4])'; In the expression: fmap extract @NonEmpty (1 :| [2, 3, 4]) :| [2 :| [3, 4], 3 :| [4], 4 :| []]; In an equation for `it': it = fmap extract @NonEmpty (1 :| [2, 3, 4]) :| 
11:39:29 <fen> !!!!
11:39:30 <Solonarv> % fmap extract $ (1 :| [2,3,4]) :| [2 :| [3,4],3 :| [4],4 :| []]
11:39:30 <yahb> Solonarv: 1 :| [2,3,4]
11:39:42 <fen> see then its the inverse
11:39:51 <Solonarv> yes, it's the inverse of duplicate
11:39:58 <Solonarv> because that's one of the laws for Comonad
11:40:13 <fen> well it could be for Comonads which are also Monads
11:40:22 <fen> we dont have laws for those
11:40:26 <fen> so there is a choice
11:40:32 <fen> could make it so if desired
11:40:36 <Solonarv> I'm not aware of any law relating the Monad and Comonad operations
11:40:45 <fen> right, well we could make this one
11:40:47 <Solonarv> okay, back in a bit - food
11:41:04 <fen> k cheers
11:42:24 <fen> still cant see why fmap extract isnt a lawful duplicate implementation
11:42:30 <fen> pretty sure it is
11:43:11 <fen> join implementation*
11:43:32 <nshepperd_> fmap extract throws away all effects of the inner action
11:43:53 <nshepperd_> It can't be law abiding unless the type has no effects
11:43:56 <fen> hmm, but then to get the inverse it would have to be duplicate = fmap return
11:44:05 <nshepperd_> Which means it's Identity
11:44:31 <fen> nsepperd_: not even Zipper?
11:45:15 <fen> extract gets the current value being "pointed" to
11:45:33 <nshepperd_> Not even zipper
11:45:35 <fen> (thats why it has to be over nonempty)
11:46:32 <fen> i thought tails was a valid duplicate for nonempty? and then so fmap head is join...
11:46:41 <fen> fmap extract*
11:47:22 <fen> not sure what is meant by "effects" for containers
11:48:32 <fen> so not really sure how thats a proogf
11:49:15 <akr> sternmull: thanks!
11:49:57 <fen> % fmap extract $ (1 :| [2,3,4]) :| [2 :| [3,4],3 :| [4],4 :| []]
11:49:57 <yahb> fen: 1 :| [2,3,4]
11:50:11 <fen> sheooerd_: thats lawful no?
11:51:41 <nshepperd_> join (return m) = m -- monad law
11:52:42 <nshepperd_> fmap extract (return m) = return (extract m) -- other monad law
11:53:02 <fen> % fmap extract $ (1 :| [2,3,4]) :| []
11:53:02 <yahb> fen: 1 :| []
11:53:05 <fen> !!!
11:53:07 <fen> oh no!
11:53:25 <nshepperd_> Hence if the monad is lawful and join = fmap extract, then forall m. m = return something
11:55:03 <fen> huh, ok, join and duplicate definitely are not inverses then
11:55:27 <fen> except for Identity
11:55:48 <fen> thanks
11:57:35 <shmuel666> Hi! suppose I have some "dynamic" type a, and I want to define a function: foo s1 s2 = show $ (read s1 :: a) + (read s2 :: a). Is it possible in any way?
12:06:09 <delYsid> Well, a would be Num here.
12:08:17 <delYsid> > let foo s1 s2 = read s1 + read s2
12:08:19 <lambdabot>  <no location info>: error:
12:08:19 <lambdabot>      not an expression: ‘let foo s1 s2 = read s1 + read s2’
12:08:39 <hpc> you need something extra that you can use to tell foo what numeric type to use
12:08:48 <hpc> since it doesn't show up in the type
12:09:03 <delYsid> if you leave out the show, type inference will do the rest.
12:09:43 <hpc> presumably you don't want it to always use Double?
12:16:25 <delYsid> ahem, why did the let above not work with lambdabot?  It works in GHCi.
12:17:04 <hpc> lambdabot only does expressions
12:17:48 <delYsid> OK, then I must be confused, as I seem to remember it once allows let binding functions.
12:18:18 <hpc> with @let
12:18:26 <delYsid> ah, thats it
12:18:41 <hpc> ghci works like a giant do-block, and @let works like appending to a .hs file
12:18:49 <hpc> and "> " works like expressions
12:21:11 <delYsid> Is there author of hmt around here sometimes?
12:21:51 <delYsid> (Rohan Drape)
12:26:10 <cocreature> delYsid: I don’t think so
12:27:15 <shmuel666> I want to pass a "type variable" somehow, like Int or Double.
12:30:31 <shmuel666> Is  there any way to pass foo some extra argument so that the read will be correct (Int / Double etc)?
12:30:49 <Solonarv> you don't actually need to pass an extra argument
12:30:56 <Solonarv> % :set -XScopedTypeVariables
12:30:57 <yahb> Solonarv: 
12:31:31 <Solonarv> % let { foo :: forall a. (Read a, Num a) => String -> String -> a; foo s1 s2 = read s1 + read s2 }
12:31:32 <yahb> Solonarv: 
12:31:36 <Solonarv> % :t foo
12:31:36 <yahb> Solonarv: (Read a, Num a) => String -> String -> a
12:32:27 <Solonarv> % foo "1" "2" :: Int
12:32:27 <yahb> Solonarv: 3
12:32:49 <shmuel666> Thanks!
12:32:59 <Solonarv> (actually, you can even leave out the 'forall a. ', and you don't need the extension either)
12:35:41 <delYsid> Thats what I said, leave out the show, and it will deduce.
12:36:19 <Solonarv> oh right, if you want String -> String -> String it gets a bit more complicated
12:36:32 <delYsid> Or, quite crazy, use ScopedTypeVariables and TypeApplications.
12:36:41 <shmuel666> Actually, yes, this is what I  wanted
12:36:45 <delYsid> let {f :: forall a. (Num a, Read a, Show a) => a -> String -> String -> String; f _ s1 s2 = show ((read s1 :: a) + (read s2 :: a))}
12:36:53 <delYsid> foo @Int undefined "1" "2"
12:37:01 <Solonarv> ew, undefined
12:37:42 <delYsid> yeah
12:37:50 <Solonarv> % let { foo :: forall a. (Num a, Read a, Show a) => Proxy a -> String -> String -> String; foo _ s1 s2 = show (read s1 + read s2 :: a) }
12:37:50 <yahb> Solonarv: 
12:38:07 <Solonarv> % foo (Proxy :: Proxy Int) "1" "2"
12:38:08 <yahb> Solonarv: "3"
12:38:18 <shmuel666> Ok. Thanks again...
12:38:21 <Solonarv> that's the "old-school" approach
12:38:29 <Solonarv> or the fancy approach:
12:38:43 <Solonarv> % :set -XAllowAmbiguousTypes -XTypeApplications
12:38:43 <yahb> Solonarv: 
12:39:22 <Solonarv> % let { foo' :: forall a. (Num a, Read a, Show a) => String -> String -> String; foo' s1 s2 = show (read s1 + read s2 :: a) }
12:39:22 <yahb> Solonarv: 
12:39:32 <Solonarv> % foo' @Int "1" "2"
12:39:32 <yahb> Solonarv: "3"
12:39:51 <delYsid> oh
12:39:55 <shmuel666> nice
12:39:57 <delYsid> thats how it is supposed to be used.
12:46:55 <rotaerk> given this context: https://github.com/achirkin/vulkan/blob/master/vulkan-api/src/Graphics/Vulkan/Marshal.hs
12:47:18 <rotaerk> I'm trying to implement a helper function that will allow me to use getFieldArray with an index determined at runtime
12:47:44 <rotaerk> here is my attempt, with a GHC error below: https://gist.github.com/Rotaerk/1247b87a21d749c87f56db4e6bd04f1d
12:47:55 <rotaerk> really not sure how to handle this
12:49:51 <rotaerk> it *compiles* if I change the constraint of the second argument of my function to IndexInBounds instead of CanReadFieldArray
12:51:41 <zincy> A little off topic. Can anyone recommend any UK based companies that have a good engineering culture and perhaps have a functional slant?
12:53:10 <rotaerk> though even if it compiles, when I do this: atIdx 5 (\proxy -> getFieldArray @"memoryTypes" @_ @VkPhysicalDeviceMemoryProperties undefined)
12:54:30 <rotaerk> oh, I think the error I get when I do that might be because I'm not tying the idx type of the proxy to the idx type within the getFieldArray constraint
13:06:25 <zincy> Is the difference between variable binding and assignment that the first is giving a identifier to a value and the second is setting a value to an identifier
13:06:47 <zincy> Because if that is correct it seems like variable bindings are just like constants in imperative langagues
13:06:51 <zincy> i.e cant be reassigned
13:07:01 <zincy> Oh I guess constants are initially assigned
13:07:15 <zincy> Whereas bound variables have never been assigned.
13:11:21 <delYsid> How do I communicate with an external process via stdin/out reading input concurrently with the ability to write commands to it?
13:13:00 <phadej> delYsid: hackage.haskell.org/package/async-2.2.1/docs/Control-Concurrent-Async.html#v:race
13:13:14 <delYsid> I have used process a little, but only for writing a string and reading the result till the process terminates.  What I need is something like scripting a repl.  Is there a library I should look at?
13:13:22 <hpc> https://hackage.haskell.org/package/process-1.6.5.0/docs/System-Process.html
13:13:39 <hpc> createProcess gives you total control
13:14:15 <Cale> phadej: Shouldn't need to race...
13:14:21 <phadej> race waitProcess communicationAction
13:14:44 <Cale> You can just read from the process in one thread and write to it in another.
13:15:16 <phadej> Cale: race with waitProcess manages all of thread business
13:15:18 <Cale> I guess race gives either thread the ability to stop both, which is okay
13:16:33 <delYsid> The docs say race cancels the looser.  Not knowing much about Async, I guess that doesnt mean I loose data, rather it would be restarted/continued on next attempt?
13:17:14 <Cale> race is weirdly not actually about Async, it's just randomly in the Async module.
13:17:46 <Cale> It runs two IO actions concurrently, and whichever one finishes first gets to deliver its result, and the other thread is killed.
13:18:24 <Ariakenom> the looser thread gets an asynchronous exception
13:18:36 <Cale> lose* / loser*
13:19:48 <Ariakenom> loose thread, badly woven :)
13:20:40 <hpc> if you combine enough threads, they become a string
13:20:59 <hpc> ... brb making a new language
13:21:22 <DigitalKiwi> that's string theory
13:31:29 <zachk> what about string cheese theory? 
13:33:21 <c_wraith> we don't talk about that since the incident.
13:37:31 <delYsid> I guess what I am asking is how to deal with sending commands and reading responses, and keep current state of the protocol.  For instance, I am supposed to send an init command, waiting / reading a number of possible responses.  If in a certain time a certain response never arrives, I know the other end isn't talking our protocol.  How would I structure that?
13:38:49 <hpc> i'd structure it exactly like that
13:38:57 <delYsid> A state with a timestamp?
13:39:25 <hpc> it's all sequential, so you can just write it sequentially
13:40:00 <hpc> do {p <- start the process; sendinit p; wait sometimeout (getresponse p); ...}
13:40:28 <delYsid> wait
13:42:08 <c_wraith> :t System.Timeout.timeout
13:42:09 <lambdabot> Int -> IO a -> IO (Maybe a)
13:43:30 <delYsid> ah
14:00:01 <delYsid> hmm, like this? https://blind.guru/UCI.hs
14:00:50 <delYsid> It doesnt work though.  I would expect to see unhandled input, but no output and Nothing is returned
14:09:06 * hackage hedn-functor 0.1.0.0 - Base functor for EDN AST  https://hackage.haskell.org/package/hedn-functor-0.1.0.0 (AlexanderBondarenko)
14:13:41 <delYsid> ah, LineBuffering
14:18:37 <fen> the fmap and traverse instances for tree are similar, in that they recurse over the lower layers (thinking of tree as Free Nonempty) but there are fusion rules for fmap f . fmap g = fmap (f . g), but what about fmap f . traverse g ?
14:19:12 <fen> because the traverse has a similar kind of recursion to fmap, a similar sort of fusion should be avaialable?
14:19:38 <fen> is this automatic? maybe via Inlining? or would it need a special rewite rule?
14:20:40 <dmwit> There are laws about traverse g . fmap f.
14:21:07 <dmwit> fmap f . traverse g... the Functor the fmap operates on has no relation to the shape the traverse operates on, so it's hard to imagine anything sensible happening there.
14:21:45 <hpc> https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Traversable has "t . traverse f = traverse (t . f) for every applicative transformation t" but i don't know what "applicative transformation" means here
14:22:06 <Solonarv> it's a natural transformation that also preserves Applicative operations
14:22:08 <fen> dmwit: fmap (fmap) sorry.. meant to act inside the applicative 
14:22:55 <Solonarv> i.e. t is an applicative transformation if
14:22:55 <Solonarv>  - t is a natural transformation
14:22:55 <Solonarv>  - t . pure = pure
14:22:55 <Solonarv>  - t f <*> t x = t (f <*> x)
14:22:57 <dmwit> fen: Then what hpc said applies.
14:23:12 <fen> hpc: thats a law though, does it also have an associated rule?
14:23:37 <dmwit> I doubt it.
14:23:52 <Solonarv> I'd guess no, because going from t . traverse f to traverse (t . f) is often a pessimization
14:24:28 <Solonarv> naively, t . traverse f only calls t once, but traverse (t . f) mightcall it many times
14:24:32 <fen> there are inlines for each of the class functions, and apparently acording to the notes that for mapM is important...
14:25:27 <fen> also, not sure if this is actually the same rule as would use the similarity in implementation of fmap and traverse for Traversable t => Free t
14:25:54 <TimoMeijer> What is the most up-to-date library or way to work with sized lists? I'd like to be able to create two sized lists, where I do not know the size at compiletime, but I know that they will be the same size, and want to statically verify that they remain the same size
14:26:20 <Heffalump> TimoMeijer: I take it that just passing around a single list of tuples won't cut it?
14:26:29 <fen> thats a type equality constraint on a HList? #
14:26:41 <fen> TimoMeijer: ^
14:27:48 <dmwit> Heffalump++
14:29:48 <TimoMeijer> fen: A HList is a bit overkill, as the contents are of the same type, but how'd you do type equality in that case?
14:29:48 <fen> so, imagine there was a newtype at each level of a tree (actually its a zipper.. we need to rewind the zipper, unwrap the newtype, traverse it, and then rewrap it in a newtype.. or just fmap over the zipper) so we can fmap Newtype . traverse f . fmap (runNewtype)
14:30:53 <dmwit> TimoMeijer: If you have a list type indexed by its size, say `List n a` for lists of length `n` containing values of type `a`, then you could write `data TwoListsOfSameSize a where TwoListsOfSameSize :: List n a -> List n a -> TwoListsOfSameSize a`.
14:31:11 <fen> TimoMeijer: sorry thought a HList was just a lengthed list... anyway, you said there was this idea of 2 list being the same length, which is a type equality constraint on the length of the list (which is a type)
14:31:24 <dmwit> But it's going to be frustrating to work with, and to me seems to have little benefit over `type TwoListsOfSameSize a = [(a,a)]`.
14:31:41 <dmwit> Either one of these options can easily be generalized to handle different element types in the two lists.
14:32:09 <dmwit> `data TLOSS a b where TLOSS :: List n a -> List n b -> TLOSS a b` for the one, `type TLOSS a b = [(a,b)]` for the other.
14:32:10 <TimoMeijer> The tuple way /might/ work in my case, but wanted to check that there isn't a more convenient dependently typed way of doing it
14:32:27 <dmwit> "convenient" is typically not the selling point of dependent types.
14:32:50 <TimoMeijer> Duly noted ;P
14:33:35 <TimoMeijer> So that implies there also isn't a commonly used library for that kind of functionality? Most of the things I could dig up were quite old
14:33:54 <dmwit> I don't imply that, no. I don't know the answer, so I didn't address that part.
14:34:57 <TimoMeijer> Okay, thanks anyway, with some clever utility functions, the tuples way might cut it!
14:35:56 <fen> the dependent types stuff is more new than a standardised approach
14:36:07 <fen> like, more tutorials than libraries atm
14:37:01 <TimoMeijer> Hmm, I might even be able to convert a great tutorial I found into a library myself
14:39:21 <fen> so, fmap is always like traverse? because fmapDefault should provide the same if slower implementation of fmap?
14:39:54 <fen> and then (fmap (fmap Newtype)) . traverse f . fmap runNewtype
14:40:19 <fen> can easily do the lhs to make traverse (f . runNewtype) ?
14:40:24 <Solonarv> yes, in fact the correspondence between fmap and fmapDefault is a law of traversable
14:41:01 <Cale> Also, for things where you can write the instance of Monad, you can get fmap = liftM
14:41:07 <fen> ah no because that acts on the values not the newtype wrapper on each layer of Traversable f => Free f
14:42:09 <fen> maybe this is something special to do with the recursive structure of the traversable instance for Free
14:42:30 <fen> so it might not be right to try and find a rewrite rule for more general traversables
14:43:27 <fen> anyway, the aim is still to be able to have a kind of thing that unwraps the newtype on each layer, does the traversal and then wraps the layers again.
14:43:51 <fen> but its not actually fmap at all! its something that acts on the containers at each layer, wait, will see if the free lib has that
14:45:06 <fen> something like (f a -> g a) -> Free f a -> Free g a
14:45:13 <fen> cant find it...
14:45:31 <fen> nvm, its hard to see how to even phrase this properly
14:48:13 <srk> <K1;5Do=
14:48:20 <srk> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\j~
14:53:44 <srk> sry, cat :)
15:15:02 <oo_miguel> can I search on hoogle (or somehwere) functions by the typeclass of its arguments? (e.g. all functions that require one of its argument to be a Functor)
15:58:37 <fen> ok wrote up the problem a bit better
15:59:17 <fen> https://pastebin.com/raw/JRmdemMX
16:14:42 <fen> hmmm, can RULES pragmas have constraints?
16:19:13 <fen> this might be completely wrong but it shows the errors; https://pastebin.com/raw/Ac7z7cuX
16:19:33 <fen> well, it throws the errors...
16:33:08 <dmwit> https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.Fixed.html#line-114
16:33:14 <dmwit> fa@(MkFixed a) / (MkFixed b) = MkFixed (div (a * (resolution fa)) b)
16:33:22 <dmwit> Doesn't this systematically underestimate the result?
16:33:57 <dmwit> Perhaps ```div (a * resolution fa + resolution fa `div` 2) b``` would be better...?
16:37:50 <Forty-Bot> what's the difference between old and new style cabal commands?
16:38:07 <sclv> old style use a global package db
16:38:14 <sclv> new style keep everything in a hashed store
16:38:22 <Forty-Bot> ok
16:38:27 <sclv> so that no two projects overlap
16:38:33 <sclv> but you still share commonalities when possible
16:39:08 <hpc> it's a bit like nix, if you've ever used that
16:39:15 <Forty-Bot> I haven't
16:39:30 <dmwit> Getting a tad more specific: in the old style, you can only have one copy of a library per version number. In the new style, you can have many copies, each with differing dependency trees.
16:40:13 <dmwit> This solves some rather annoying problems where end-user packages could fight with each other for control of dependency packages' dep trees.
16:43:13 <Forty-Bot> ok, what's the equivalent of cabal install?
16:43:45 <sclv> Forty-Bot: v2-install, but it still sort of has some warts, especially if you're not on latest-latest
16:44:02 <sclv> you can always just v2-build the exe and then copy it or manually make a symlink to it
16:44:17 <sclv> note you only need to `install` exes
16:44:29 <sclv> you just depend on other packages and when you new-build they get brought into the store on demand
16:44:52 <Forty-Bot> eh, I want to actually install something
16:44:59 <Forty-Bot> locally at least
16:45:42 <Solonarv> what for?
16:46:21 <Solonarv> (I'm not trying to dissuade you; the best way to do whatever-it-is-you-want-to-do depends on what your goal is!)
16:46:47 <Forty-Bot> trying to get clash set up
16:47:10 <Forty-Bot> afaik it comes with some executables
16:48:33 * Solonarv looks up clash
16:48:45 <Forty-Bot> https://clash-lang.org/
16:49:06 <hpc> looks like you just need to build it, then copy clash and clashi onto your path
16:49:36 <Solonarv> which cabal v2-install should pretty much do for you
16:50:03 <Solonarv> (it'll put a symlink to the built executables into ~/cabal/bin, which is close enough)
16:50:10 <Forty-Bot> that breaks whenever I run it
16:50:27 <sclv> how does it break
16:50:35 <Forty-Bot> complaining that '/home/user/.cabal/store/ghc-8.6.3/package.db' does not exist
16:50:36 <Solonarv> "it"? what are you running, and what's breaking?
16:51:05 <fen> managed to get something to compile https://pastebin.com/raw/evppbSut 
16:51:08 <Forty-Bot> https://paste.fedoraproject.org/paste/FqXTEaY~VWeeDrlTIo54Yg
16:51:14 <fen> anyone could check it over?
16:51:58 <dmwit> (Whoops, should be div b 2, not div (resolution fa) 2.)
16:52:04 <sclv> Forty-Bot: https://github.com/haskell/cabal/issues/5516
16:52:11 <sclv> gives the workaround
16:52:27 <sclv> (new-build creates the store-dir, but new-install used to assume it until the bug was fixed)
16:53:06 <fen> and comment about what "what" is doing?
16:53:24 <fen> seems like some kind of extra structure to the recursive traverse of Free...
16:53:33 <fen> (and maybe a better name for that function...)
16:54:35 <Forty-Bot> ok, now it fails with this http://ix.io/1DII
16:56:06 <sclv> Forty-Bot: try passing the --allow-newer flag
16:56:18 <sclv> clash can't yet build with latest ghc due to template-haskell incompats
16:56:26 <sclv> but you can ask it to try and see if it works anyway :-)
16:56:35 <Forty-Bot> ok, that seems to be working
16:56:41 <dmwit> My read is that this means you need GHC 8.2 or older.
16:57:02 <Solonarv> but allow-newer might work anyway :D
16:57:09 <dmwit> Yes, maybe.
16:57:17 <dmwit> TH is famously finicky, though.
16:57:17 <Forty-Bot> cabal: symlink-bindir is not defined. Set it in your cabal config file or use --symlink-bindir=<path>
16:57:23 <Forty-Bot> what does that mean?
16:57:32 <Forty-Bot> do I have to tell it how to ln -s ?
16:57:45 <Solonarv> it means cabal doesn't know where it is supposed to put the symlinks
16:57:47 <dmwit> No, you have to tell it what directory you want ln -s to target.
16:58:00 <dmwit> Which... seems kind of dumb to me?
16:58:02 <Forty-Bot> ah, so make something like ~/.share/bin
16:58:03 <Forty-Bot> ?
16:58:04 <dmwit> There ought to be a default for that.
16:58:10 <dmwit> Forty-Bot: I think so, yes.
16:58:14 <Forty-Bot> or ~/.cabal/bin
16:58:18 <sclv> i think that newest cabal does default it, but this is a slightly older version
16:58:26 <Forty-Bot> which is probably where I'll look in 6 months
16:58:29 <Solonarv> Yeah, it's a bit odd. I was assuming it would default to ~/cabal/bin
17:00:57 <Forty-Bot> ok, now it complains about prelude being missing http://ix.io/1DIL
17:01:15 <Forty-Bot> ghc-pkg check says docs are missing but nothing else
17:02:57 <Forty-Bot> I am very tempted just to install from the package manager and skip mucking with cabal
17:03:21 <sclv> Forty-Bot: what distro?
17:03:26 <Forty-Bot> arch
17:03:29 <sclv> oh no
17:03:39 <sclv> arch doesn't package proper tools for building haskell
17:03:39 <Forty-Bot> yeah
17:03:53 <Forty-Bot> I had been using a special repo for haskell stuff
17:03:58 <dmwit> Do we have an FAQ page on Arch yet?
17:03:58 <Forty-Bot> but it died last year
17:04:08 <dmwit> Seriously, this comes up so freaking often.
17:04:20 <sclv> dmwit: we really should create one on the wiki and just have a bot command for it
17:04:22 <Solonarv> nuclear solution: remove the system-installed ghc&cabal, and install them through ghcup instead
17:04:26 <sclv> right
17:04:27 <Forty-Bot> can't
17:04:35 <Forty-Bot> system packages depend on haskell libs
17:04:37 <sclv> Forty-Bot: actually you don't need to remove them
17:04:49 <sclv> just install through ghcup and use those for building your own stuff
17:05:16 <sclv> https://github.com/haskell/ghcup
17:05:23 <Welkin> gh cup
17:05:29 <sclv> it installs and symlinks into its own place on the tree so it doesn't overlap
17:05:42 <Forty-Bot> ok, so aside from the nuclear option
17:05:47 <sclv> dmwit: a year ago there were too many possible solutions for arch so it was hard to pick
17:05:50 <Welkin> I only recently realized that ghcup is a reference to rustup
17:05:51 <sclv> now i'd say always just do that
17:06:07 <sclv> Forty-Bot: you can try to set a bunch of stuff to  build only dynamic in your system
17:06:13 <Forty-Bot> is there any way to fix that build?
17:06:15 <sclv> but in my experience that works for people until it breaks
17:06:43 <sclv> Also i think there's some static stuff arch provides but its semi random and incomplete
17:07:07 * hackage xmobar 0.29.5 - A Minimalistic Text Based Status Bar  https://hackage.haskell.org/package/xmobar-0.29.5 (JoseAntonioOrtegaRuiz)
17:07:23 <sclv> Forty-Bot: their own page explains the ghc-dynamic workarounds and also the ghc-static aur https://wiki.archlinux.org/index.php/haskell
17:07:42 <sclv> but honestly just having a not stupid ghc installed in a not-stupid way seems much cleaner
17:08:01 <sclv> also easier to get help with because people aren't familiar with all the corner cases their solutions can induce
17:09:34 <rotaerk> what's this syntax called?  I can tell (# Int#, Int#, ByteArray# #) is an unboxed tuple, but what's the (# t | #)? https://github.com/achirkin/easytensor/blob/master/easytensor/src/Numeric/DataFrame/Internal/Array/Family/ArrayBase.hs#L40-L48
17:10:59 <dmwit> unboxed sum
17:11:11 <sclv> ooh, pretty: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unboxed-sums
17:11:41 <rotaerk> hmm thanks
17:24:21 <mouse07410> sclv: I fit one deeply sympathize with a distro that decided to enforce dynamic-only for it's GHC installation/package. Because I've spent way too much time fighting with libHSbase.a that kept picking the wrong libiconv.dylib - and while I was able to fix this problem for the majority of the packages pulled from Hackage and installed, some (e.g., ghc-paths) turned out to be beyond repair. So, my definition of "non-stupid"
17:24:21 <mouse07410> would probably differ from yours.
17:25:37 <dmwit> > (0.9*1.1 :: Double, 0.9*1.1 :: Data.Fixed.Fixed Data.Fixed.E1)
17:25:39 <sclv> mouse07410: you don't understand what dynamic-only means in this context
17:25:39 <lambdabot>  (0.9900000000000001,0.9)
17:25:49 <sclv> it means dynamic-only linking of ghc-built things
17:25:53 <sclv> not linking to syslibs
17:25:54 <Forty-Bot> why don't haskell tools like cabal and stack have man pages?
17:26:10 <dmwit> They do...
17:26:11 <Welkin> why not woman pages?
17:26:15 <sclv> mouse07410: and dynamic-only linking of ghc built things is _not fully supported_ by ghc
17:26:26 <dmwit> At least on my machine they do.
17:26:28 <Forty-Bot> stack doesn't on my system...
17:26:38 <dmwit> Oh, I don't know about stack. But cabal has a man page.
17:26:49 <Forty-Bot> cabal appears to now that I've checked
17:26:59 <Forty-Bot> but uh
17:27:11 <Forty-Bot> it looks like a bunch of man pages pasted together
17:27:33 <mtb34> Good evening. Is there a good page for Haskell source code? I'd like to see how the standard library is implemented
17:27:35 <Forty-Bot> presumably it should have man pages like it's
17:27:50 <sclv> you get fake dynamic-only by asking it to build dynamic (which it usually doesn't) and then asking it not to build object code -- which is inteeded to speedup the compiler during typecheck cycles, not intended to only build partial output
17:28:13 <dmwit> Forty-Bot: https://cabal.readthedocs.io/en/latest/
17:28:33 <Forty-Bot> I know html docs exist, I was just wondering about man pages
17:28:37 <dmwit> mtb34: I usually use Hackage for that.
17:28:39 <sclv> mtb34: you can browse the source by clicking "source" links in the haddocks: https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html
17:28:41 <dmwit> ?hackage base
17:28:41 <lambdabot> http://hackage.haskell.org/package/base
17:29:02 <geekosaur> mtb34, the language report has generic implementations of the Prelude, but ghc's often differs (and is not the best place to look at for language understanding because it's a weird combination of heavy optimization and heavy abstraction, sometimes at cross purposes)
17:29:29 <geekosaur> (sum being an example of said cross purposes)
17:30:11 <sclv> honestly i just don't think any work went into a good cabal man page
17:30:28 <sclv> it would be a third place to keep up to date (along with html docs and flags)
17:30:44 <sclv> and it can't be nicely generated just from either since it sits in between in terms of output size
17:31:42 <mtb34> Thanks for the replies. I'll then postpone looking into the source until I'm finished with learnyouahaskell
18:00:09 <rotaerk> in this, he is allocating a new pinned MutableByteArray#, and then *freezing* it before running the `f` action on it: https://github.com/achirkin/vulkan/blob/41fe88b415b963d8085442364bd5c45dabe628c0/vulkan-api/src/Graphics/Vulkan/Marshal/Internal.hs#L115-L128
18:00:55 <rotaerk> however, in this, that action will write to the array: https://github.com/achirkin/vulkan/blob/master/vulkan-examples/05-GraphicsPipeline.hs#L227-L244
18:01:13 <rotaerk> how is that legal? if the array has been frozen, how is he able to write to it?
18:01:48 <rotaerk> writeFieldArray just uses pokeByteOff on it
18:05:36 <rotaerk> are (immutable) `ByteArray#`s able to be mutated if accessed through a pointer poke rather than using a `MutableByteArray#` write operation?
18:15:43 <Forty-Bot> ok, so I tried installing clash with stack
18:15:55 <Forty-Bot> worked fine until it failed while compiling clash-lib
18:17:41 <Forty-Bot> trying again with ghc 8.4.4...
18:41:17 <Forty-Bot> also failed
18:41:25 <Forty-Bot> 8.6.3 failed as well
18:42:51 <Axman6> have you tried asking in #clash-lang?
18:43:03 <Solonarv> it was suggested earlier to use 8.2
18:43:34 <Forty-Bot> ah, even earlier...
18:43:42 <Forty-Bot> Axman6: I have not
18:43:50 <Forty-Bot> I'll ask there if 8.2 fails
18:51:49 <Forty-Bot> failed with 8.2.2 as well
18:51:51 <Forty-Bot> oof
18:56:58 <fen> whats up with all these "this other rule might fire first" warnings? https://pastebin.com/raw/4MhQMbCi
18:57:16 <fen> is the other rule going to fire first?
18:57:31 <fen> is it something wrong with the inline precedence?
18:57:58 <fen> the other rules are class functions of prelude, cant change their precedence 
19:02:09 <fen> which way round do they go?
19:02:22 <fen> higher vs lower inline precedences
19:04:30 <fen> well, it doesnt matter what level the precedence is set at, it still complains
19:06:04 <fen> would have to set up some kind of test to see if this fires, and that would be probably more code than could expect to read...
19:10:33 <Solonarv> fen: the number isn't a precedence, it states during which phase(s) the rule is enabled
19:10:52 <Solonarv> I don't remember the details though, check the ghc manual for those
19:19:03 <texasmynsted> what do you use for project templates? I have been using this https://hackage.haskell.org/package/file-templates 
19:19:36 <koz_> texasmynsted: I've been using Cookiecutter.
19:19:38 <texasmynsted> But I wonder if there is something different that is more common. (I do not use stack. I use cabal, if that makes a difference.)
19:19:40 <koz_> This seems really good though.
19:20:01 <texasmynsted> I have used cookiecutter for other things. 
19:20:18 <texasmynsted> Just curious what others use
19:20:22 <fen> hmmm. really not sure what to make of this code
19:20:41 <sclv> http://hackage.haskell.org/package/summoner
19:20:45 <sclv> texasmynsted: 
19:20:49 <Solonarv> oh yeah I was going to mention that
19:21:30 <texasmynsted> oh wow. I will check that out. Thank you
19:21:33 <fen> idea is that a traversable instance for a free thing can be written by casting each level to some other functor
19:21:46 <sclv> Forty-Bot: clash-lib should build with 8.4.4 https://matrix.hackage.haskell.org/#/package/clash-lib
19:21:57 <fen> like, you cant traverse a zipper, but you can rewind it and traverse, and then renavigate
19:22:11 <fen> this extendis this to nested zippers
19:22:33 <fen> so that the same proceadure (to . traverse . from) can also be used for the whole nesting, as well as for the levels
19:22:41 <fen> and that it should all fuse into one
19:31:36 <fen> like, converting each layer requires an fmap, and these should fuse into the traverse that happens over the free structure
19:31:56 <fen> anyway, doesnt look like much can be understood about if its going to work or not without an example
19:31:57 <fen> so
19:55:56 <texasmynsted> hmm this is the second time I have gotten this kind of error in a week. Not sure the _correct_ fix. "Failed to build documentation for tomland-1.0.0 (which is required"
19:56:53 <texasmynsted> last time I re-installed cabal
19:59:30 <sclv> texasmynsted: there was a cabal version that would fail when docs wouldn't build
19:59:37 <sclv> latest doesn't fail when docs don't build
19:59:38 <sclv> just warns
20:00:08 <sclv> the easiest thing is to just set `documentation: False` in your ~/cabal/config 
20:05:22 <texasmynsted> cabal-install version 2.4.1.0
20:05:33 <texasmynsted> compiled using version 2.4.1.0 of the Cabal library
20:05:51 <sclv> so does the doc failure screw up the entire installation?
20:05:58 <sclv> or just fail on the docs?
20:06:26 <texasmynsted> for me it fails the entire installation
20:07:27 <sclv> is it new-install or new-build that fails?
20:07:27 <texasmynsted> does Documentation: false prevent all docs from building or keep build from fail when docs fail?
20:08:05 <sclv> prevents all docs from building
20:08:15 <sclv> here's the ticket -- it should have been fixed with 2.4 https://github.com/haskell/cabal/pull/5459
20:11:42 <texasmynsted> don't know. I am doing a new-install. I suppose I should try new-build and see if that also fails
21:00:38 <Forty-Bot> sclv: it *should* but it fails with http://ix.io/1DJD
21:03:09 <sclv> oh sigh. singletons 2.5.1 requires ghc 8.6 or later
21:03:18 <sclv> if you're passing --allow-newer to stack that'll break it
21:03:30 <sclv> because insanely --allow-newer for stack actually allows older too!
21:07:25 <slack1256> Is anyone capable of building taffybar from nix?
21:07:58 <texasmynsted> If I set documentation: False then I "cabal user-config update" the new config keeps documentation: False. Perhaps 2.4 just sets the flag to False
21:08:08 <texasmynsted> I had not upgraded my config
21:35:44 <texasmynsted> anybody happen to know how shellmet works compared with something like turtle?
21:36:01 <texasmynsted> https://github.com/kowainik/shellmet
21:52:14 <Forty-Bot> sclv: I am passing allow newer, because that got it to stop yelling at me so much :P
21:52:48 <luke-clifton[m]> texasmynsted: It uses overloaded strings to convert a string to an [String] -> IO()
21:53:15 <sclv> well, allow-newer is allowing an incompatible combination of base and singletons
21:53:30 <luke-clifton[m]> If you want to do shell programming in Haskell, you should also check out my shh library on Hackage.
21:54:13 <texasmynsted> is shh better? I read a bunch of comparisons and finally had to shrug and think that I have no idea which one I should try.
21:54:40 <Forty-Bot> hmm
21:54:41 <luke-clifton[m]> I wrote shh, so I think it's better :)
21:55:14 <texasmynsted> lol
21:55:32 <texasmynsted> Well I guess I would hope so.
21:55:35 <luke-clifton[m]> The readme is fairly comprehensive. Check it out.
21:56:08 <texasmynsted> okay
22:05:37 <texasmynsted> I am looking for something specifically for script use. The readme is less _comprehensive_ on that topic. https://github.com/luke-clifton/shh#script-usage
22:10:16 <texasmynsted> ;-)
22:34:37 <mtb34> Good morning. In word navigation in VSC, how can I ignore punctuation characters? (And is this type of question already considered #haskell-offtopic?)
22:42:16 <mjrosenb> lens question:
22:46:53 <mjrosenb> (simplified for brevity) I have data Simple = A (Int, Foo) | B (Foo, Bool) | C; I'd like an object, bar that can be used like (obj ^? bar) and also (obj & bar .~ foo) to get either Foo, or update the Foo.
22:47:10 <mjrosenb> is this possible, and if so, what on earth is it called?
22:48:22 <mjrosenb> I don't think I can get this just by composing the prisms _A, _B and lenses _2, _1 in simple ways.
22:48:57 <mjrosenb> and I tried to construct one using prism, but I don't think the types quite line up for use in prism.
23:07:09 <glguy> (_A . _2) `failing` (_B . _1)
23:07:23 <glguy> It's not a Prism, you can't construct a Simple from only a Foo
23:13:56 <mjrosenb> I am not at all surprised.
23:17:11 <mjrosenb> glguy: that isn't working with a slightly more complex type (but let me try with the exact example I gave you)
23:26:49 <mjrosenb> ahh, my bad.  I stuck the two arguments to failing into a new variable, and apparently changed their type.
