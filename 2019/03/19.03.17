00:12:54 <mjrosenb> blah.  this works like 90%
00:15:40 <mjrosenb> I forgot, it isn't Foo, it is like Foo Char in one branch and Foo Integer in the other branch
00:15:53 <mjrosenb> and Foo a has a bunch of fields which don't depend on a
00:16:36 <mjrosenb> so I can manually access the fields, but I can't write a function which takes a lens and attempts to insert it on both sides of `failing`
00:16:51 <c_wraith> You could take an ALens
00:17:16 <c_wraith> wait, no, it's polymorphic in the wrong spot.
00:17:21 <c_wraith> Ok, RankNTypes to the rescue!
00:22:07 <blackandblue> god damn it
00:22:19 <blackandblue> arch linux has a lot of haskell packages updates everyday
00:22:23 <blackandblue> I am tired of it
00:22:53 <blackandblue> how do you guys manage haskell on arch
00:24:12 <kadoban> blackandblue: Just don't use the system package manager at all for haskell
00:24:32 <blackandblue> then what to use
00:24:48 <kadoban> I personally use stack, others use cabal or nix
00:24:53 <blackandblue> and ops. I insstalled so many haskell packagess with sysstem pkg manager. how do I deal with them
00:25:38 <kadoban> No idea, probably remove them somehow, though I'd have no idea how to do so without breaking something. Only thing I know about arch is that it generates a ton of annoying bug reports because their haskell setup seems to be a complete trainwreck.
00:25:56 <blackandblue> arch sucks it seems
00:26:08 <blackandblue> why do you use arch if it suck for haskell? kadoban 
00:26:15 <kadoban> I've otherwise heard good things about it. I think just their haskell setup isn't great.
00:26:25 <kadoban> I don't use arch.
00:26:33 <blackandblue> then what do you use
00:26:40 <kadoban> mint, at the moment
00:26:50 <blackandblue> god damn it tons of old packages in mint
00:26:51 <blackandblue> :(
00:28:01 <blackandblue> dont you feel annoyed with old libraries and packages in mint? kadoban 
00:28:30 <kadoban> No. I mostly like stability more than I need the absolute newest things.
00:28:57 <kadoban> Anything I need bleeding edge, I'm probably building from source anyway regardless of what distro.
00:29:18 <blackandblue> I see
00:29:23 <blackandblue> you have used arch before? kadoban 
00:29:29 <kadoban> No
00:29:38 <qualiaqq> have you tried nixos?
00:31:34 <qualiaqq> I'm not sure how it compares to arch in terms of rolling updates, but I really enjoy the features that set it apart.
00:33:50 <blackandblue> qualiaqq, do you use nixxxOS?
00:36:57 <qualiaqq> blackandblue: yea, I'm not an expert by any means, but I have been using it for a while.
00:37:23 <mtb34> Good morning. In word navigation in VSC, how can I ignore punctuation characters? (And is this type of question already considered #haskell-offtopic?)
00:37:33 <blackandblue> qualiaqq, as main OS?
00:39:40 <qualiaqq> I dual boot Windows 10 and nixos. Unfortunately, I have to keep windows 10 around for work and games. Usually, when I'm at home, I use nixos for everything.
00:39:49 <Peppep> Are anyone here familiar with Anatomy of Programming Languages or similar books? I'm using it for a Uni course where we build interpreters, typecheckers etc, and using the book I just not able to do it intuitively. Are there any other resources you could recommend to learn these topics?
00:51:23 <thebigj> I will continue the group reading session of Learn you a Haskell for great good today at https://www.twitch.tv/events/8OsO-0grQs2CW2FJWzPCzA
00:51:26 <thebigj> Please ping me if you are interested in joining
00:51:27 <thebigj> Thanks!
01:14:51 <mjrosenb> so, speaking of lenses, is there a reason I can't just compose some lenses and bind it to a type?
01:15:36 <mjrosenb> when I try, I get a bunch of type errors.
01:16:14 <mjrosenb> Ambiguous type variable.
01:16:45 <mjrosenb> I'm guessing it is related to the use of type classes in Len's definition?
01:37:03 <Ariakenom> mjrosenb: bind it to a _type_?
01:37:36 <mjrosenb> err, variable
01:37:38 <mjrosenb> words.
01:38:24 <Ariakenom> that should work fine. you can paste a code example to some site
01:42:39 <mjrosenb> https://gist.github.com/mjrosenb/318a28401c579aae95f5e96d5fa276ac
01:43:19 <mjrosenb> gives https://gist.github.com/mjrosenb/33a255cc39acec1fc4a520bddab55200
01:44:35 <mjrosenb> If I uncomment the type signature there's no problem.
01:53:20 <Ariakenom> mjrosenb: is that the type you get if you ask ghc?
02:15:36 * hackage yesod-core 1.6.13 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-core-1.6.13 (MichaelSnoyman)
03:07:37 * hackage simple-cmd 0.1.3.1 - Simple String-based process commands  https://hackage.haskell.org/package/simple-cmd-0.1.3.1 (JensPetersen)
04:03:38 <zincy> Is there any other language like Haskell which challenges the way you think and makes everything else seem easier  after?
04:04:15 <zincy> Don't say javascript :P
04:05:03 <zincy> I guess Agda and Rust are the main contenders.
04:05:18 <zincy> Or maybe Assembly
04:05:20 <Heffalump> and Idris
04:05:58 <Heffalump> The way F# integrates functional style with the object system is also quite nice for thinking about classes (I haven't used Scala, it may do something similar)
04:06:11 <zincy> Interesting
04:07:18 <hc> I think haskell incorporates all the new, challenging ideas and is constantly evolving, so it's probably not easy to find anoher one.. Correct me if I'm wrong?
04:07:58 <zincy> Right, but you can't compare it to assembly?
04:08:20 <zincy> You won't understand how the machine works by just using Haskell
04:09:49 <zincy> Am I correct in saying that the functional approach to compilers is fundamentally different from the imperative one?
04:10:00 <zincy> Or do they rest on the same theory?
04:14:08 <Heffalump> I don't think there's any fundamental differences between a compiler written in a functional language and one written in an imperative language
04:14:19 <Heffalump> any more so than between other kinds of code written in functional/imperative
04:15:12 <Heffalump> I guess that algebraic datatypes are a good fit for the parse trees and intermediate representations of a compiler, but you can express those in an imperative language with a bit more boilerplate too
04:15:59 <zincy> To learn compilers which approach should be started with>?
04:18:21 <yushyin> with a book about the fundamentals? the dragon book, I guess
04:33:04 <zincy> Thanks
04:33:13 <zincy> Have you read it?
04:35:06 * hackage httpd-shed 0.4.1.0 - A simple web-server with an interact style API  https://hackage.haskell.org/package/httpd-shed-0.4.1.0 (GaneshSittampalam)
04:39:03 <dimsuz> hi! Trying to practise Applicative composition. I have the situation where I have "data Module = Module FilePath Text Text". Given path I can construct a Module like this: "Module fp (extractProp1 fp) (extractProp2 fp)". Now I have a list of [FilePath], trying to figure out how to construct a list of modules
04:39:15 <gentauro> zincy: you could read Torbens book (free) "Basics of Compiler Design" -> http://hjemmesider.diku.dk/~torbenm/Basics/
04:39:44 <gentauro> that's the book we used at University of Copenhagen (Faculty of Computer Science aka DIKU)
04:39:54 <dimsuz> I suspect I must use "Module <$> extractProp1 <*> extractProp2", but I'm stuck on the exact shape this should take... fp is the same one for all args
04:40:27 <zincy> gentauro: Thanks
04:41:19 <gentauro> zincy: the main point many of us found it so usefull was that we used `ML` (MoscowML) for the exercises, which makes it really easy to reason about of what you are doing
04:41:42 <gentauro> I always find compilers written in C'ish languages so damn hard to read ...
04:42:06 <zincy> Everything is harder at a lower level though right?
04:43:10 <zincy> dimsuz: Can you share code? (pastebin perhaps)
04:43:33 <dimsuz> yes, one moment
04:48:07 * hackage HTTP 4000.3.13 - A library for client-side HTTP  https://hackage.haskell.org/package/HTTP-4000.3.13 (GaneshSittampalam)
04:48:54 <dimsuz> zincy: here it is: http://pastebin.it/5451. I'm still learning to apply these skills. I have a strong feeling I could write mapping in a more concise way, but a bit stuck :)
04:49:53 <dimsuz> oops there is a typo: last argument of map should be "manifests"
04:54:05 <zincy> Does it work as is?
04:56:33 <dimsuz> yes :)
04:57:02 <dimsuz> I'm just trying to train myself into a more deep understanding of <$> and <*>
04:59:01 <zincy> At the moment you are using map which is the name for <$> on the type []
04:59:39 <zincy> :t (<$>)
04:59:40 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:00:06 <zincy> :t (<$>) . (<*>)
05:00:07 <lambdabot> (Functor f2, Applicative f1) => f1 (a -> b) -> f2 (f1 a) -> f2 (f1 b)
05:00:34 <zincy> See the above functions do not have same type signature so they are not interchangeable
05:00:54 <zincy> :t (<*>)
05:00:56 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
05:01:04 <zincy> :t (<$>)
05:01:05 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:02:17 <zincy> Do you have HaskellBook? If so go through the functor and applicative exercises.
05:03:25 <dimsuz> Don't have it. I know that <$> is fmap and map for lists is fmap too. Something didn't fully click here...
05:04:24 <dimsuz> In my example all 3 constructor parameters use 'mf', so I started to think how do I remove it from there completely
05:05:41 <dimsuz> in first position it is transformed by "id" function, in second by extractRootPath, in third by extractPackage. But for some reason I can't at the moment derive my next step from this observation :)
05:06:47 <zincy> I get the feeling just using flip and (.) may enable you to drop the lambda
05:07:48 <zincy> Then you would get a function which takes 3 arguments which would be the same value
05:08:20 <zincy> Oh replicate
05:08:23 <zincy> :t replicate
05:08:24 <lambdabot> Int -> a -> [a]
05:08:51 <dimsuz> aha. replicate it 3 times and use that function. Thanks, will try it
05:10:26 <zincy> Yeah if you replicate the arg three times you can then use the list as arguments to the composed function (Module . extractRootPath . extractPackage)
05:15:02 <zincy> :t (uncurry . uncurry)
05:15:03 <lambdabot> (a -> b1 -> b2 -> c) -> ((a, b1), b2) -> c
05:15:59 <zincy> :t (uncurry . (fst . uncurry))
05:16:00 <lambdabot> error:
05:16:00 <lambdabot>     • Couldn't match type ‘(a, b) -> c’ with ‘(a1 -> b1 -> c1, b0)’
05:16:00 <lambdabot>       Expected type: (a -> b -> c) -> (a1 -> b1 -> c1, b0)
05:18:41 <dimsuz> I see, will try that, thank you
05:56:47 <fgfgd> lol
05:58:04 <owhit> When using the State monad, and 'put x' is called, is everything copied and then allocated into new memory? Does this just grow the stack with each call?
06:00:25 <owhit> Anyone?
06:00:34 <lyxia> neither
06:01:30 <owhit> lyxia, so put overwrites the old memory? But that would be a side effect no?
06:01:48 <lyxia> it doesn't overwrite old memory
06:02:22 <lyxia> State is a function type
06:02:37 <lyxia> so under the hood it's all function composition
06:02:42 <owhit> true
06:03:50 <hpc> basically, put :: s -> (s -> (s,a))
06:03:59 <hpc> er, a = ()
06:04:05 <owhit> so 'put 3 >> put 4 >> put 5' isn't actually storing anything?
06:04:10 <hpc> put s = \_ -> (s, ())
06:04:17 <lyxia> right
06:04:26 <owhit> this is mind boggling
06:05:36 <owhit> but what if I'm calling my 'stateful' function recursively...
06:06:06 <lyxia> in a way it's just notation for    \ _s -> let (_, s1) = ((), 3) {- put 3 -} in let (_, s2) = ((), 4) {- put 4 -} in ((), 5) {- put 5 -}
06:06:52 <lyxia> then you're defining a recursive function, subject to the same rules as regular, explict, recursive functions.
06:08:53 <owhit> right, but I think this is my confusion. If I have a recursive StateT / IO function, and I'm continually modifying the state, how is that not creating a bunch of copies and using up memory
06:13:15 <owhit> I guess I'm not thinking in the right terms. I don't know
06:19:04 <Eduard_Munteanu> owhit, it depends, there are two variants of State, one is lazy and the other is strict.
06:19:04 <lyxia> it's true that in more complex programs you have to pass those integers around via the memory
06:19:34 <Eduard_Munteanu> If your state is strict, you probably want the strict State.
06:21:27 <owhit> eduard_munteanu, Is lazy the default for Control.Monad.State? Is strict pure or impure?
06:22:37 <owhit> i see
06:22:44 <Eduard_Munteanu> Yeah, it reexports Control.Monad.State.Lazy. And it's pure anyway.
06:22:56 <owhit> ok
06:29:04 <Eduard_Munteanu> The actual difference is the state tuple is deconstructed with an irrefutable pattern or not, so if everything else is strict it shouldn't get in your way.
06:32:46 <Eduard_Munteanu> (it doesn't mean it actually forces the state value, in case I wasn't clear)
06:38:26 <owhit> eduard_munteanu, if I have `runStateT $ forever ....`, wouldn't that would eventually lead to a space leak?
06:38:46 <owhit> if I repeatedly do `modify foo`
06:41:25 <lyxia> not if the old states get garbage collected.
06:49:44 <Eduard_Munteanu> Actually the strict/lazy stuff above has nothing to do with this.
06:50:14 <owhit> lyxia thanks
06:53:15 <owhit> Eduard_Muneanu, does the old 'modify foo' results get garbage collected then?
07:02:46 <owhit> CTCP VERSION
07:05:41 <Eduard_Munteanu> owhit, if you discard the old state, yeah.
07:16:48 <owhit> Thanks for the help, btw
07:23:46 <dminuoso> zincy: Regarding your question about "different languages" earlier, I think it's not just languages that make things seem "easier", but languages that change how you think about problems.
07:24:16 <dminuoso> zincy: You might be interested in learning Prolog, it can give fresh new insights into problem solving or programming approaches.
07:32:22 <unyu> dminuoso: What's so insightful about DFS minus the remembering which nodes you already visited?
07:35:06 * hackage email-validator 1.0.0 - Perform basic syntax and deliverability checks on email addresses.  https://hackage.haskell.org/package/email-validator-1.0.0 (MichaelOrlitzky)
07:44:16 <akr> any tips on how to parse a CalendarTime from old-time?
07:45:03 <akr> do I need to write a parser myself?
07:45:15 <akr> there used to be a function called parseTime which handled this
07:45:20 <akr> bow it's gone, it seems
07:45:22 <akr> now*
07:46:35 <akr> sorry, parseCalendarTime*
07:50:44 <glguy> akr: are you actually using old-time and not time?
07:51:10 <akr> glguy: yup, the package haskelldb is using CalendarTime
08:27:05 <gentauro> akr: the `time` package is pretty nice :)
08:29:57 <delYsid> What data structure would you recommend for a relatively simple (not really performance bound) chess move generation module?  I am toying with Array, but I suspect it will be pretty slow and wasteful in terms of memory.  The classical bitboard (12 Word64) comes to mind, but this feels pretty unhaskelly.  Any alternatives in between, or other suggestions?
08:31:51 <gentauro> delYsid: you could create your own datatype like: `data Chess = Table !Word64 !Word64 ... !Word64` (12 times !Word64)
08:32:56 <gentauro> that should be pretty memory efficient (based on how Haskell works)
08:34:40 <gentauro> and you can easily deconstruct / construct it like (it's inmutable): `foo (Table r1 r2 .. r12) = Table r1 r2' .. r12 where r2' = 0xFF`
08:37:54 <delYsid> Yes, that would be a bitboard based data structure.
08:39:01 <delYsid> Does using a record slow things down, or is it just syntactic sugar?
08:39:28 <Akii> Having a problem with lazy evaluation again. I was under the assumption that `force` really forces evaluation? However, whatever I do, the program seems to evaluate only after the first request made to the servant server.
08:40:03 <Akii> Even put in a "putStrLn" to see if it reaches the part where I force evaluation but still, nothing
08:40:51 <cocreature> Akii: can you show us some code?
08:40:54 <Akii> ah wait, mistook that for `deepseq`
08:41:12 <cocreature> deepseq and evaluate are orthogonal
08:41:37 <cocreature> evaluate let’s you say “if this IO action is executed (which is easier to reason about than when something is evaluated), evaluate this thing to whnf”
08:42:03 <cocreature> deepseq let’s you say, “when this thing is evaluated to whnf also evaluate this other thing to nf”
08:44:11 <Akii> I don't have any non trivial code to share
08:44:20 <Akii> if it were trivial I'd probably see it myself
08:47:44 <Akii> infuriating I have this for months now
08:48:03 <Akii> every new solution I implement has the exact same problem
08:51:53 <Akii> rofl
08:51:55 <reactormonk> Anyone got some good documentation on fix-point recursion? I've been hacking around with it for a few days now, got things to compile, but I don't understand it.
08:51:59 <Akii> I used `deepseq const`
08:52:09 <Akii> types are a lie
08:57:05 <hpc> reactormonk: i don't have a link off the top of my head, but it's surprisingly simple
08:57:12 <hpc> reactormonk: say you have some recursive definition
08:57:18 <hpc> ones = 1 : ones
08:57:45 <hpc> to define that with fix, you make it take the definition name as a parameter
08:57:51 <hpc> fix (\ones -> 1 : ones)
08:58:08 <hpc> and that's it
08:58:59 <hpc> if you don't understand something written in fixed-point form, first expand the parameter to fix so it's in that second form
08:59:03 <hpc> then translate it to the first form
08:59:33 <hpc> (in the case where something is written more tersely, like fix (1:)
08:59:34 <hpc> )
09:00:44 <reactormonk> hpc,good point
09:07:01 <rotaerk> hmm what determines the PATH variable when running `cabal new-build`?
09:07:49 <rotaerk> I'm in a nix-shell, and if I `echo $PATH`, it shows one thing, but if I setup my project to print the PATH during compilation, and run cabal new-build, the path is missing some things
09:07:52 <srid> What's a good way to `map` over a list, with the function taking not only the item as parameter but also the result of the previous item's function application as a 2nd parameter?
09:08:10 <glguy> :t scanl
09:08:11 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
09:08:53 <srid> :t scanr
09:08:54 <lambdabot> (a -> b -> b) -> b -> [a] -> [b]
09:10:46 <srid> glguywhat if the function is monadic? (b -> a -> m b)
09:11:38 <srid> Like traverse, but pass the intermediary `b` to next function call
09:12:52 <rotaerk> srid, there's a scanM in pipes/conduits and some other places
09:14:30 <glguy> :t ala StateT traverse
09:14:31 <lambdabot> (Monad m', Traversable t) => t (s' -> m' (a', s')) -> s' -> m' (t a', s')
09:15:01 <glguy> I don't know any premade scanM function in base
09:15:13 <glguy> :t alaf StateT traverse
09:15:14 <lambdabot> (Monad m', Traversable t) => (a -> s' -> m' (a', s')) -> t a -> s' -> m' (t a', s')
09:16:32 <glguy> :t \f xs z -> fst <$> alaf StateT traverse (\x prev -> do y <- f x prev; return (y,y)) xs z -- yikes...
09:16:34 <lambdabot> (Monad m', Traversable t) => (a -> s' -> m' s') -> t a -> s' -> m' (t s')
09:17:34 <shapr> :t for
09:17:35 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
09:17:46 <srid> :t foldlM
09:17:47 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
09:19:36 <akr> gentauro: I know. Like I said, it's a dependency of another package, that also happens to be central to this project.
09:20:06 <akr> I still don't understand why parseCalendarTime disappeared 
09:20:25 <akr> this is why people in industry don't want to use Haskell :/
09:21:36 <monochrom> I think it's replaced by a more general parsing function?
09:21:56 <akr> which one? CalendarTime has no relevant instances
09:23:34 <shapr> akr: people in industry don't want to use Haskell because hero culture :-P
09:24:40 <monochrom> I think I would parse to UTCTime or LocalTime. What's CalenderTIme?
09:24:57 <glguy> monochrom: He's trying to use an old package that uses old-time
09:24:58 <rotaerk> people in industry don't want to use haskell because it's not on their radar
09:25:15 <akr> glguy: https://hackage.haskell.org/package/old-time-1.1.0.3/docs/System-Time.html#t:CalendarTime
09:25:43 <shapr> Eh, lots of people in industry using Haskell
09:26:08 <akr> yeah, no
09:26:16 <shapr> akr: citations?
09:26:49 <akr> look at the ration of job postings for haskell positions to other positions
09:27:00 <c_wraith> why do you think good jobs need postings?
09:27:00 <akr> I doubt it's more than 0.1%
09:27:35 <akr> c_wraith: I don't think I said that?
09:27:51 <monochrom> OK, are you trying to complain or are you trying to solve a problem?
09:27:58 <akr> both :>
09:28:37 <shapr> akr: complaints can be taken to #haskell-offtopic unless you have specific suggestions for improvement?
09:28:55 <glguy> akr: It's more likely that you were wrong about that function existing in old-time than that someone went back and removed it from all the previous releases
09:28:56 <shapr> I complain, then I try to do something to improve those things.
09:29:09 <akr> shapr: thanks, but I think I'm done complaining :P
09:29:21 <monochrom> At old-time 1.0.0.0 I still don't see a  parser function, so what does it mean to say "disappear" when it did not exist in the first place?
09:29:28 <akr> glguy: unlikely, as I used it yesterday
09:29:35 <akr> monochrom: yeah this was before old-time was a thing
09:29:45 <akr> I think, anyway
09:29:49 <akr> think GHC 6.12
09:29:56 <glguy> akr: Well it was never in old-time. Maybe you found it somewhere else
09:30:13 <akr> that's possible
09:30:27 <akr> but it doesn't look like it's anywhere on hackage anymore
09:30:47 <monochrom> This is why Haskell doesn't try to please industry.
09:31:14 <shapr> industry can't be pleased?
09:31:44 <shapr> Industry is certainly pleased at the things I do in Haskell.
09:31:55 <shapr> that is, my job benefits from small useful utilities I write in Haskell
09:32:20 <rotaerk> hmm if I run ghci and then do System.Environment.getEnv "PATH", it shows the same path I see when I run `echo $PATH` from the commandline
09:32:27 <rotaerk> but if I run cabal new-build, it doesn't see the same path
09:32:32 <shapr> akr: got any thoughts on what you think would help Haskell be more popular in industry?
09:33:25 <cocreature> rotaerk: in TH? otherwise I’m not sure how you end up executing that code by calling "cabal new-build"
09:33:29 <rotaerk> yeah in TH
09:33:59 <rotaerk> the path it gets is missing some things, so I'm wondering what determines that
09:34:02 <sclv> T
09:34:17 <akr> shapr: less breaking changes (think cabal hell, base version being tied to compiler version, breaking api changes in libraries all the time) would go a fair way. Other than that, some material on dispelling myths about functional programming with clear & concise examples
09:34:43 <shapr> akr: as far as I can tell, cabal hell is gone with the new-build and new-install commands
09:35:27 <shapr> akr: if you're working on a codebase from ghc 6.10, I think api changes are just gonna be a thing.
09:35:31 <rotaerk> with the new-* stuff, I see no point in using stack
09:35:32 * shapr looks up the release date for ghc 6.10
09:35:54 <shapr> rotaerk: I still used stack because it was the easiest way to install ghc, but now there's ghcup!
09:36:03 <shapr> ghcup + cabal new-build is GREAT
09:36:15 <akr> shapr: sure, the thing is the reason why nobody updated in small steps is that each small step can potentially break many things
09:36:23 <rotaerk> ah, I hadn't heard of that.  I use nix-shell to get ghc, cabal, etc
09:36:31 <akr> shapr: plus, this was before stack etc.
09:36:54 <shapr> GHC 6.10.1 Released! 4 November 2008
09:37:25 <akr> you can probably compile C written in 1980 with today's compilers
09:37:27 <shapr> akr: maybe property tests would help?
09:37:27 <akr> ... just saying
09:38:15 <akr> shapr: I don't see how, in this context?
09:38:31 <shapr> well, then you know if things were broken?
09:38:41 <akr> by broken I just meant not compiling
09:39:06 <akr> probably should've made that clearer, sorry
09:39:11 <cocreature> not updating in small steps because they may break things isn’t going to make the upgrade easier when you eventually do have to do it
09:39:20 <shapr> yeah, I'm with cocreature on this one.
09:39:34 <akr> try to explain that the guy who has to deliver a new feature by friday evening :)
09:39:55 <shapr> akr: if you were just assigned this task, then I'm gonna blame management
09:40:07 <cocreature> you don’t have to tell it to that guy, you have to explain it to their manager
09:40:18 <shapr> akr: realize that you always have the option to tell your manager "no"
09:40:43 <akr> fair point, I will better not comment on the management in my current firm
09:41:15 <shapr> I've been on death march projects, I got much better at saying "no" to tasks that were gonna eat my life or interfere with my relationships outside of work.
09:41:37 <akr> oh well I don't work outside of my working hours :) 
09:41:44 <shapr> glad to hear that
09:41:48 * shapr hugs akr
09:41:54 <shapr> good choice! you are more sensible than many :-)
09:41:55 <akr> thanks :)
09:42:10 <shapr> than me, years before :-/
09:43:01 <akr> glad to hear it got better
09:43:32 <shapr> Right now I'm the primary person responsible for a chunk of code that's required for a ... probably ten million dollar contract.
09:43:49 <shapr> I'm sad to say that not everyone in my company is as relaxed as I am.
09:44:10 <shapr> akr: what does that ten year old Haskell codebase do for your company?
09:44:44 <akr> it's very central, it's backend for a web app
09:44:54 <shapr> eh, I should probably stop distracting you if that thing needs to be done for Friday
09:45:32 <akr> nah actually I just finally have some time now to work on updating the project to a newer GHC
09:45:44 <akr> management doesn't really care
09:45:49 <shapr> oh, ok
09:46:33 <shapr> Last year We convinced management getting off of ubuntu 12 for our base image was worth the pain.
09:47:26 <akr> good for you :)
09:47:34 <rotaerk> ah I see... the PATH I see from commandline is stored in the HOST_PATH variable of the environment the TH code sees
09:47:51 <lseactuary> anyone used FDR4.0 (https://www.cs.ox.ac.uk/projects/fdr/manual/) or know about CSP process? little bit stuck in understanding something from the book. 
09:48:29 <rotaerk> wonder if that's a cabal thing, a cabal new-* thing, or a nix thing
09:53:55 <sclv> Nix i think?
10:03:24 <akr> ok I figured it out I think, I can 'toClockTime . parseUnixTime'
10:14:09 <royal_screwup21> could someone help me understand why this isn't working? https://repl.it/languages/haskell
10:15:47 <glguy> Did you mean to share a link to some code?
10:15:49 <royal_screwup21> I'm trying to define an a Dog Instance, whose parameter is constrained to Show
10:15:57 <royal_screwup21> ah yes sorry!
10:16:04 <royal_screwup21> https://repl.it/repls/UnderstatedJuvenileProjections
10:17:29 <royal_screwup21> actually nvm nvm
10:17:32 <cocreature> that looks fine?
10:17:50 <monochrom> repl.it wants a main.
10:18:05 <royal_screwup21> yup, just tried it on my local machine, it works okay
10:22:12 <hpc> getting an odd error new-building unix-2.7.2.2
10:22:17 <hpc> mv: cannot move './conf8thdFK/out' to 'unix.buildinfo': Numerical result out of range
10:22:50 <hpc> at the configure step
10:29:28 <sternmull> hm, looks like stack does not complain when i set unknown flags for a package in stack.yaml :(
10:31:13 <rotaerk> figured out my problem; don't fully understand why it is but, I needed to run: cabal new-clean
10:31:41 <rotaerk> basically, it seems to have cached what ends up in the PATH from the perspective of TH code
10:32:00 <rotaerk> and the PATH had changed between new-build runs
10:35:06 <heebo> hello is there a standard workaround for the duplicate record field problem yet?
10:36:22 <sternmull> no
10:37:10 <hpc> there's a language extension
10:37:40 <sternmull> most people use type-specific prefixes for their field names
10:37:43 <hpc> but it's "contagious"
10:39:41 <royal_screwup21> does  fmap have anything to do with Maybe? I'm looking at  a function defined like so: https://repl.it/repls/UnderstatedJuvenileProjections I'm not sure  I fully understand how fmap is coming into play here...
10:40:57 <hpc> > fmap (+1) Nothing
10:40:59 <lambdabot>  Nothing
10:41:03 <hpc> > fmap (+1) (Just 5)
10:41:05 <lambdabot>  Just 6
10:41:23 <hpc> (your link isn't loading for me)
10:41:27 <sternmull> royal_screwup21: Maybe has a Functor instance
10:43:00 <sternmull> royal_screwup21: https://wiki.haskell.org/Typeclassopedia#Functor
10:43:14 <royal_screwup21> ah okay, here's a link that should work fwiw
10:43:22 <royal_screwup21> craftinginterpreters.com
10:43:27 <royal_screwup21> https://ideone.com/63Iwks
10:44:20 <royal_screwup21> ah okay yup, I see the functor instance defined for Maybe
10:48:15 <hpc> hmm, cabal wants the same version that the os packages
10:48:20 <hpc> yum install ghc-unix-devel lololol
10:50:24 <dmwit> I don't like repl.it links for sharing code. They let you change the code after sharing it much too easily.
10:52:12 <Akii> I'm having an endless stream in form of a TChan and I want to chunk items by number or timeout. So let's say, ever 1000 items or 10 seconds, whatever comes first. Sounds like a problem some abstract library can help with?
10:53:52 <heebo> ah ive seen the extension thanks
10:54:07 <heebo> ive been away from Haskell for a while but the language develops so fast
10:54:25 <heebo> Anyone reading "Thinking with types" by Sam Maquire?
10:54:30 <heebo> awesome read.
10:54:40 <hpc> fedora's repo mirrors are all either slow or down :(
10:54:42 <dmwit> Akii: I don't know of a library for that, but it shouldn't be hard to cook one up yourself. Check out `timeout`, which seems like just about all you need in addition to the TChan API.
10:54:44 <hpc> i should just use centos vms
10:54:46 <heebo> * for a short while
10:55:23 <Akii> dmwit this? http://hackage.haskell.org/package/base-4.12.0.0/docs/System-Timeout.html
10:55:36 <dmwit> that
10:57:04 <Akii> ah I see, so I'd atomically try to take n items and if that runs into a timeout I just take whatever is in the channel
10:57:24 <Akii> which would then nicely be the IO Alternative
10:57:32 <Akii> almost
10:57:33 <dmwit> I think it's probably safer to atomically take one at a time, with an ever-decreasing timeout.
10:57:47 <dmwit> Otherwise in case the timeout hits you get no events.
10:58:06 <dmwit> Oh, I see your plan. Yeah, that sounds good.
10:58:14 <royal_screwup21> so I have a typcalss, Expr, with 3 methods. I've  parmeterized it on Integer and Bool, like so: https://repl.it/repls/UnderstatedJuvenileProjections This compiles, but when I do something like: ` lit 3` on ghci, it gives me 3 -- why did it select the Integer instance over the Boolean instance?
10:59:02 <dmwit> royal_screwup21: The keyword to search for in the GHC documentation is "defaulting".
10:59:10 <Akii> cool, thanks!
11:00:07 <dmwit> royal_screwup21: You'll also want to read the section on the ExtendedDefaulting extension, which is turned on by default in ghci and is needed to observe that behavior.
11:00:28 <royal_screwup21> ah okay thanks :)
11:01:20 <dmwit> You can turn of ExtendedDefaulting in ghci with :set -XNoExtendedDefaulting; you can turn off defaulting entirely for a module by including `default ()` somewhere in it.
11:01:50 <dmwit> Uh. And ghci probably maintains its own default list, but I don't know off-hand whether you can use the `default` declaration from inside ghci.
11:02:16 <dmwit> (Quick testing suggests yes, at least in ghci 8.4.3.)
11:03:43 <CelestialLake> dmwit: GHCi compiles on load, so it's probably safe to assume that you can do whatever is possible without GHC compile flags there.
11:04:45 * dmwit shrugs
11:05:14 <dmwit> It certainly doesn't follow logically. There was certainly a time within my memory where many of what the Haskell Report calls "statements" were not accepted by ghci.
11:05:33 <dmwit> (Even though it could handle them perfectly fine from within a file.)
11:06:25 <dmwit> It goes the other way, too; ghci is more lax than ghc about some things. e.g. you can do `s <- getLine` alone in ghci, even though that's not suitable as a last line in a do block in a compiled file.
11:06:27 <CelestialLake> Oh, yes, my statement doesn't hold for prompt entries.
11:07:00 <CelestialLake> But any :load-s are safe in that regard.
11:07:32 <dmwit> Even there it turns out GHC is complicated enough to have edge cases. =)
11:07:49 <dmwit> There's funny things you can do with dynamic linking and object files that ghci doesn't (yet?) understand, but ghc compilation itself does.
11:09:49 <cocreature> dmwit: that sounds interesting, anything specific you have in mind there?
11:10:00 <CelestialLake> A bit off the topic: is there anything remotely resembling SLIME/SWANK in Haskell world?
11:11:27 <rotaerk> I don't know the details of SLIME but emacs has a haskell mode
11:12:29 <CelestialLake> Using it but it seems to lack that capability. It's possible that I may use another look at it in order to find it.
11:12:43 <rotaerk> I'm not really a fan of the haskell integration for emacs/vim; personally I can never get it to consistently work right
11:13:16 <dmwit> cocreature: I dunno. It's some weird FFI thing that I've never really understood, and every time it comes up I just stop trying to use ghci on that project. =P
11:13:19 <rotaerk> instead of editor integration, I just use an editor with syntax coloration, and then I run ghcid in a separate window
11:13:31 <rotaerk> that's almost as good as an IDE
11:13:55 <CelestialLake> dmwit: GHCi is more lax in regard of `<-` for a reason, I think.
11:14:27 <dmwit> CelestialLake: I agree.
11:14:44 <CelestialLake> You definitely want to `<-` without `do` in interactive mode. I suppose that it assumes `do` if it trips over such IO statemets.
11:14:54 <dmwit> In fact I have several coworkers that wish there was a way to hijack ghci's special handling to work for other monads, too. =P
11:15:00 <CelestialLake> And terminates them with return ()...
11:15:02 <delYsid> Is there some way I could switch GHCi to show NUm values as hex?
11:15:05 <geekosaur> yes. (originally, ghci pretended to be the inside of an "infinite" do block
11:15:13 <geekosaur> which is why it didn't hande "statements")
11:15:16 <delYsid> (guessing no, but hopeful)
11:15:26 <cocreature> dmwit: heh :)
11:15:44 <geekosaur> delYsid, there's a way to override the default printer, but it's a PITA to use
11:16:07 <dmwit> delYsid: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#using-a-custom-interactive-printing-function
11:16:25 <geekosaur> basically you have to come up with your own "show"-like class, remembering you can't reliably make it default to Show
11:16:52 <geekosaur> plus what dmwit linked to activate it
11:17:00 * geekosaur on slow connection, the manual is still loading...
11:17:03 <dmwit> delYsid: Probably simpler to make a newtype with a suitable Show instance and apply it to `it` any time you discover you wanted a hex output.
11:17:49 <dmwit> % newtype Hex a = Hex { bless :: a }
11:17:49 <yahb> dmwit: 
11:18:01 <delYsid> ah, 'it' might help, yes.  The custom printer just confuses me.
11:18:14 <dmwit> % instance (Integral a, Show a) => Show (Hex a) where show (Hex a) = Numeric.showHex a ""
11:18:14 <yahb> dmwit: 
11:18:26 <dmwit> % Hex 32
11:18:26 <yahb> dmwit: 20
11:18:50 <delYsid> heh, Hex it :-)
11:18:57 <dmwit> yeah =)
11:19:07 <dmwit> And its inverse, bless it. =D
11:19:34 <CelestialLake> Praise it
11:19:47 <dmwit> ...twist it, bop it, technologic
11:20:39 <shapr> dmwit: aw man, now that's stuck in my head
11:20:48 <CelestialLake> Same here
11:21:02 <geekosaur> heh
11:21:10 <delYsid> dmwit: Very cool solution, thanks!
11:23:14 <dmwit> dependency injection. we oop now bois
11:24:57 <mjrosenb> Ariakenom: yeah.
11:25:42 <royal_screwup21> I was all hyped up to learn haskell after reading about how it can used for creating DSLs, its  ad-hoc polymorphism, its nice syntax....and then I saw the haskell implementation of the knapsack problem :( https://www.seas.upenn.edu/~cis194/spring13/lectures/06-laziness.html looks pretty unreadable to me, although I'm just a beginner, but definitely
11:25:42 <royal_screwup21>  a bit of a a turn off
11:26:09 <CelestialLake> dmwit: s/oop/create ad-hoc solutions to trivial problems/
11:26:55 <hpc> royal_screwup21: that's a pretty gnarly function - i think you have to already know what algorithm it is to make sense of that
11:27:21 <hpc> simpler problems will have simpler code
11:28:31 <royal_screwup21> hpc: yeah, tbh though if you were writing it in an imperative style, it'd be pretty readable even if you didn't know the alg. I guess it's a spectrum...
11:29:07 <hpc> i think you're just supposed to read it at a high level
11:29:17 <hpc> knapsack01 = index into the array m
11:29:24 <hpc> where m = this big recurrence relation
11:31:49 <royal_screwup21> I'm just wondering....if learning the language well and being productive in it is going to amount to writing code like that, not totally sure if I should invest the time :( My primary motivation, coming from an oop/imperative background, was to learn how to simplify code with interesting functional design patterns.
11:32:14 <CelestialLake> rotaerk: IMO, haskell-mode is neat in regards of indentation control and highlighting, and that's enough for a happy life. Didn't use any completion and whatnot either.
11:32:37 <hpc> you won't be writing code like that
11:33:15 <hpc> you'll be writing code more like...
11:33:53 <CelestialLake> hpc: Well, in real world...
11:34:25 <hpc> http://hackage.haskell.org/package/ShellCheck-0.6.0/src/shellcheck.hs
11:35:05 <CelestialLake> Jesus.
11:35:28 <hpc> that's a good example of more straightforward haskell
11:35:41 <dmwit> royal_screwup21: I think if you implemented *that* algorithm in an imperative language, you would find it unreadable, too.
11:35:42 <hpc> it's long, but that's just because it's got a lot of options, and no particular part of it is that complicated
11:36:08 <dmwit> royal_screwup21: In particular, I would bet that the algorithm you would naively implement would populate every cell of the array in some pre-arranged order.
11:36:19 <hpc> (also try it out, shellcheck is a great tool to have around)
11:36:22 <dmwit> royal_screwup21: Which may waste computation on cells that are never used by the final answer.
11:36:40 <dmwit> royal_screwup21: Whereas this one populates cells in the order they're discovered to be needed, possibly skipping some cells entirely.
11:37:05 <royal_screwup21> dmwit: ah I see, still n^2 though time complexity wise?
11:38:02 <dmwit> of course
11:38:05 <delYsid> Hmm, I should have spent more time doing bit twiddling.  Whenever I need to work with bits, I feel very stupid.
11:38:06 <dmwit> (nW)
11:38:18 <royal_screwup21> but yeah I see what you mean...I know the naive dp algorithm, I've written it a few times in an imperative style, but I could barely recognize it looking at the haskell impl
11:39:09 <dmwit> I think if you squint you can see most of the pieces you think of as the easily-understandable algorithm.
11:39:30 <dmwit> The line beginning `[((-1,w),0)` would be a for loop initializing one row of the array.
11:39:45 <dmwit> The line beginning `[((i,0),0)` would be a for loop initializing one column of the array.
11:40:17 <dmwit> Then the lines that start with `[((i,w),best)` would be the for loop that walks through the remaining cells, doing a nested for loop for comparisons.
11:42:07 <Akii> dmwit looks kinda ugly but could work https://gist.github.com/Akii/eef3b75258c1c721d22260b171075210
11:42:35 <dmwit> Akii: Better read the docs of `timeout` again. =)
11:43:01 <dmwit> Its argument is in microseconds, so you want to multiply timeoutSeconds by 1000000, not 60000.
11:43:12 <Akii> yeah ignore that lol
11:43:28 <Akii> good to know it's wrong, I was just assuming it would be
11:44:21 <Akii> the use-case is that I have a TChan that produces a rather high amount at the beginning and then drops to nearly nothing over time 
11:44:34 <Akii> and the consumer can work efficiently in batches
11:45:22 <dmwit> Akii: One thing to consider: you might atomically read one element from the TChan, and start the timer then.
11:45:39 <dmwit> This would eliminate the need to recurse as you're doing here if the list is empty.
11:45:57 <dmwit> (Whether this is acceptable or not depends on the intended semantics, of course.)
11:46:29 <Akii> I was also thinking about having all of this inside an stm transaction
11:46:39 <dmwit> I don't think STM does timing.
11:46:50 <Akii> no but you could add a tvar boolean
11:46:56 <Akii> maybe
11:47:17 <Akii> ah well that will do
11:47:35 <Akii> blocking on an empty channel is a good idea though
11:47:48 <dmwit> Ah, I see. Set the TVar to False when time is up, you mean?
11:48:05 <Akii> yep but that would probably require more setup
11:48:16 <dmwit> Yeah. If you think this version is awkward... =)
11:48:40 <Akii> you could then accumulate as inside the transaction and then `readTChan a <|> timeoutReached` or smth like that
11:49:19 * CelestialLake appreciates the promotional material
11:50:19 <dmwit> Akii: By the way, you might like the monad-loops package.
11:50:50 <dmwit> Akii: With it, `emptyChannel = unfoldM . tryReadTChan`, short enough to inline entirely.
11:51:16 <Akii> nifty
11:52:15 <deltasquared> hi all, does anyone know an elegant way to check the following: given a type A, some function A -> B (where B can be thought of some sub-field of A for this use case), and a list of A's, how could I ensure that no two A's in the list have the same B property when it is retrieved?
11:52:38 <deltasquared> I think the problem probably reduces to fmap func As, in which case it becomes ensuring the list of B's is unique I guess
11:53:25 <Solonarv> perhaps there's a nubOn somewhere?
11:53:37 <slack1256> compare `on` is probably what you want
11:54:13 <deltasquared> :t compare
11:54:14 <lambdabot> Ord a => a -> a -> Ordering
11:54:28 <dmwit> Akii: I posted a comment with all those changes. It looks quite nice in the end, I think!
11:54:31 <deltasquared> slack1256: not sure I follow.
11:54:49 <deltasquared> unless you're still talking about the other problem, in which case I'll shut up for a bit
11:54:52 <Solonarv> :t \f -> fmap head . groupBy ((==) `on` f) . sortOn f
11:54:53 <lambdabot> Ord b1 => (b2 -> b1) -> [b2] -> [b2]
11:55:12 <slack1256> ^
11:55:15 <Akii> lol wat ` (a:) <$> case mas of` xD
11:55:20 <Solonarv> this seems like it'll do what you want
11:55:30 * deltasquared stares at it for a moment
11:55:41 <deltasquared> thing about haskell is it takes a while to parse in one's head...
11:55:45 <Akii> dmwit but yes, not bad
11:56:21 <slack1256> > (compare `on` fst) (1, "perro") (2, "gato")
11:56:23 <lambdabot>  LT
11:56:35 <Solonarv> I'mnot sure how order-preserving this is, in case that matters
11:56:52 <dmwit> :t \f vs -> M.elems $ M.fromList [(f v, v) | v <- vs]
11:56:54 <lambdabot> Ord k => (a -> k) -> [a] -> [a]
11:57:44 <dmwit> deltasquared: ^
11:57:50 <isovector1> are there any good resources on optimizing generated core?
11:57:57 <Solonarv> that one's definitely not order-preserving, though
11:58:02 <deltasquared> Solonarv: not particularly. the use case is checking some unit files I'm generating for systemd; in general I don't want an input config error to result in two units that try to point at the same path, as they have to be named based on said path
11:58:02 <dmwit> pah
11:58:16 <Solonarv> ah, so order doesn't matter anyway
11:58:23 <deltasquared> Solonarv: nope :>
11:58:26 <Solonarv> I'd use dmwit's version then
11:58:28 <deltasquared> as long as they all get there in the end
11:58:28 <slack1256> isovector1: there is a search box on r/haskell. Look there for previous post on reading generated core
11:58:46 <deltasquared> (I/O errors notwithstanding of course, but systemd would catch a dying generator.)
11:59:03 <slack1256> isovector1: cool intuition, core only allocates on `let` and the evalation is driven by `case of`
11:59:23 <slack1256> everything is desugared onto it, so you can have a clearer cost model
11:59:26 <dmwit> ?hackage ordered-containers if you need to keep the order
11:59:26 <lambdabot> http://hackage.haskell.org/package/ordered-containers if you need to keep the order
12:00:00 <deltasquared> dmwit: I assume "M" is defined to be map as far as the bot is concerned?
12:00:04 <deltasquared> err Map rather
12:00:09 <deltasquared> the module
12:00:12 <dmwit> \f v -> toList . fromList $ [(f v, v) | v <- vs] -- using that package
12:00:19 <dmwit> deltasquared: Data.Map, yes
12:01:12 <deltasquared> random side note, does ghci have a way to bring up associated docs from source at the prompt, or is that information not retained anywhere
12:01:21 <dmwit> New feature in the next release.
12:01:24 <dmwit> I don't think it's out yet.
12:01:27 <deltasquared> oof.
12:01:32 <slack1256> :browse kind of does that
12:01:56 <slack1256> I have a little script that brings up the local documentation from a package when needed though
12:02:16 <dmwit> ?hackage haskell-docs -- see also
12:02:16 <lambdabot> http://hackage.haskell.org/package/haskell-docs -- see also
12:02:28 <deltasquared> slack1256: I have the base package source unpacked for that purpose, I was just hoping to have it streamlined
12:02:29 <Solonarv> deltasquared: dmwit: it's in 8.6, actually
12:02:31 <dmwit> It's pretty old, though. Who knows if it works any more. Not me
12:02:38 <Solonarv> just :doc THING
12:02:51 <Solonarv> that'll show you the haddocks for THING
12:02:52 <cocreature> isovector1: the STG paper is a pretty good start imho
12:03:03 <cocreature> isovector1: https://www.microsoft.com/en-us/research/wp-content/uploads/1992/04/spineless-tagless-gmachine.pdf
12:03:05 <Solonarv> very incomplete/experimental though
12:03:28 <deltasquared> Solonarv: it's enough to remind me roughly what is does.
12:03:40 <remexre> Are there currently agreed-upon best practices for error handling in largish programs? In Rust, I normally do something like data Error = forall a. Show a => Error { _kind :: ErrorKind, _cause :: a }, but the existential seems to be more frowned upon in Haskell than trait objects are in Rust
12:04:23 <deltasquared> if I had to take a guess, probably something in a monad transformer stack. but I would know buck all about that on account of not being able to comprehend them to begin with
12:04:29 <cocreature> remexre: the reason the existential is frowned upon (for this usecase) is that you can just as well use "data Error = Error ErrorKind String"
12:04:35 <slack1256> remexre: https://www.fpcomplete.com/blog/2016/11/exceptions-best-practices-haskell
12:05:11 <deltasquared> (on the subject of multiple effects, freer-simple looks intriguing, but it seems to have some performance issues. not to mention it can't do bracketing elegantly.)
12:05:24 <remexre> cocreature: er yeah, in the Rust one I can downcast the trait object back to an Option<OtherType>
12:05:32 <remexre> slack1256: I'll give that a read
12:05:49 <Solonarv> in Haskell you need Typeable to rediscover a type at runtime (which is needed for casting)
12:06:13 <Solonarv> and then: congratulations, you've reinvented half of GHC's dynamic exception system! :p
12:06:50 <remexre> ok :P
12:06:55 <deltasquared> I have yet to really try out a more elegant method than simple sum types for errors...
12:07:22 <dmwit> remexre: Doesn't Haskell's built-in exception stuff do essentially that already?
12:08:00 <Solonarv> indeed
12:08:02 <dmwit> remexre: `throwIO :: Exception e => e -> IO a` and `catch :: Exception e => IO a -> (e -> IO a) -> IO a` lets you define your own cause types no problem.
12:08:06 <CelestialLake> Solonarv: Typeable seems like a lot of unnecessary hassle...
12:08:13 <cocreature> with the difference that Haskell’s exception system doesn’t force you to check for an error each time
12:08:13 <slack1256> @type catches
12:08:14 <lambdabot> error:
12:08:14 <lambdabot>     Ambiguous occurrence ‘catches’
12:08:14 <lambdabot>     It could refer to either ‘Control.Exception.catches’,
12:08:15 <remexre> I was unaware of Haskell's built-in exception stuff, it's been a few years since I wrote a Haskell program > 100 lines
12:08:27 <cocreature> which has advantages and downsides :)
12:08:42 <dmwit> remexre: Start here, then: https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Exception.html
12:08:57 * slack1256 has grown to love exceptions on haskell
12:09:34 <deltasquared> gtg, dinner's ready.
12:09:58 <Solonarv> CelestialLake: "unnecessary hassle"? it's not much hassle in the first place, and it's pretty much necessary if you want a type to be knowable at runtime without restricting it to a predefined set
12:10:11 <monochrom> Actually mine is a more orienting starting point: http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml
12:10:24 <dmwit> Without even reading it, I too now recommend monochrom's article.
12:10:32 <monochrom> haha
12:10:38 <isovector1> slack1256 cocreature: thanks! i'm more curious about how to write haskell that generates good core though. like after i've determined which core is bad, how do i *fix* it?
12:10:50 <remexre> okay I'll read that before the docs link then
12:11:30 <shapr> isovector1: perhaps this has some useful bits? https://tech.channable.com/posts/2019-03-13-how-we-made-haskell-search-strings-as-fast-as-rust.html
12:12:26 <remexre> side question, is there a list of what OS keys are available for stack somewhere convenient? whenever I google for it, I get issues people are having with it instead of what OS keys work...
12:12:35 <shapr> criterion is the popular benchmarking library
12:12:44 <shapr> remexre: what's an OS key?
12:12:54 <remexre> e.g. linux32-ncurses6
12:13:01 <shapr> oh, I don't know
12:13:07 <remexre> it's the terminology used in the Stack error
12:13:23 <shapr> I use ghcup to manage ghc and cabal, and I use cabal's new-build and new-install commands
12:13:42 <remexre> is that a stack replacement, or is it higher-level?
12:13:52 <shapr> it's roughly equivalent
12:13:55 <shapr> stack wraps cabal
12:13:57 <CelestialLake> Solonarv: I'm not very fluent with the language itself but what's the use case? In vast majority of cases you can just throw in some type constraints and work with fitting types without caring too much about what type you could get at runtime.
12:14:19 <CelestialLake> How do you get your free theorems if you need to determine the type at runtime? :(
12:14:21 <shapr> remexre: if you want a short history lesson I can tell you what motivated stack, and why it's not really required at this point
12:14:45 <remexre> shapr: ok, sure!
12:14:48 <dmwit> CelestialLake: The use case is exceptions, where you can't predict at exception-library-creation-time what operations folks might want to do on their custom exception types, and so can't design a sane, complete method list for the Exception class.
12:14:59 <dmwit> And yes, free theorems are Right Out.
12:15:22 <dmwit> (Or rather, the free theorems you get are pretty uninteresting.)
12:15:27 <gentauro> basic question with regard of `phantom types`. How do I ensure that only some specific `a` is used in `data Foo a = String`. Can I limit `a` to only be, for example `Char and Word`?
12:15:45 <shapr> remexre: already familiary with dependency hell?
12:15:46 <dmwit> gentauro: You can do something similar with DataKinds.
12:16:07 <dmwit> gentauro: data PossibleArgs = Char | Word; then `data Foo (a :: PossibleArgs)` will restrict `a` to be `'Char` or `'Word`.
12:16:21 <remexre> shapr: Yeah, I did Python before pipenv was best-practices :P
12:16:32 <dmwit> If needed, you can use a type family to reflect `'Char` and `'Word` back to `Char` and `Word`.
12:17:04 <gentauro> dmwit: PossibleArgs = Char | Word; then `data Foo (a :: PossibleArgs)` will restrict `a` to be `'Char` or `'Word`. <- Just what I needed, thx
12:17:09 <shapr> remexre: ok so that was the problem that motivated stack, you could easily end up not being able to build something because one of your dependencies had a minor upgrade that meant it no longer worked with what you had installed
12:17:16 <sternmull> what can i do when stack rebuilds some dependencies from time to time even if i didn't change anything that should cause this? Can i ask stack what is going on?
12:17:46 <andrei> What can I put in my package.yaml to check if a shell script returns true at configuration time? I want the build to fail if an external library is missing.
12:17:52 <shapr> remexre: the solution stack chose is to have a narrow slice of library versions guaranteed to work with each other
12:18:50 <dmwit> andrei: For simple stuff, use `pkg-config-depends` in your cabal file. For more complicated stuff, consider a custom `Setup.hs`.
12:19:14 <shapr> remexre: the downside with stack/age is that library/app creators don't need to add version bounds to figure out what versions are actually required
12:19:29 <cocreature> there is also build-type: configure if you really love autoconf (does anyone?)
12:19:34 <shapr> and if you choose to use a niche library that's not supported in your stackage version, it's lots of extra work
12:19:49 <shapr> it's not always lots of extra work, but sometimes it's near impossible
12:20:14 <CelestialLake> dmwit: That's what the 'fork' button was for, I thought... Well yeah, I get the use case but it still feels way too uncomfortable.
12:20:44 <andrei> dmwit: Sadly this is more complicated, but I can't fidn an example of a Setup.hs that checks the return value of some command and aborts the build if it doesn't succeed
12:20:49 <shapr> remexre: so the cabal new-* commands took the ideas of the nix package manager, for each build, you have a clean slate and only fetch/build the library versions you need for that build
12:20:55 <andrei> dmwit: Do you know where I should look?
12:21:27 <shapr> remexre: even then, stack was great for me when I was teaching classes, because stack will install ghc for you. But nowadays I prefer ghcup for that purpose.
12:21:39 <remexre> Okay!
12:21:41 <shapr> remexre: hopefully that wasn't a wall of text :-)
12:21:58 <dmwit> andrei: xmonad has a whole autotools setup; you might take a look there.
12:22:32 <remexre> Nah, it's good to know what the latest best practices are :)
12:22:42 <dmwit> CelestialLake: You're gonna fork the base library built into the compiler every time you write a new app with a new interesting exception type? I don't think so...
12:23:00 <andrei> dmwit: I think I'm missing something: https://github.com/xmonad/xmonad/blob/master/Setup.lhs
12:23:03 <dmwit> CelestialLake: Your app isn't good enough to make me want to rebuild the compiler to use it. =P
12:23:11 <shapr> remexre: are you building something interesting? just curious what got you back to writing Haskell
12:23:38 <remexre> I'm writing a compiler for a dependent language with effects
12:23:44 <shapr> oh neat
12:24:04 <remexre> Compiler is currently in rust but the typechecker is like half Arc::new(foo.bar()) by weight
12:24:05 <shapr> fun spare time project? forking Idris?
12:24:07 <cocreature> dmwit: if you’re not recompiling GHC at least 3 times a day you’re not a proper Haskell programmer! ;)
12:24:25 <dmwit> andrei: You're not missing something, I'm just an idiot. It's X11 that uses autotools, not xmonad.
12:24:36 <remexre> shapr: mostly spare time
12:25:00 <dmwit> andrei: But it uses `build-type: configure`, which I didn't remember.
12:25:00 <remexre> I'm leaning pretty heavily on the Idris papers tbh
12:25:02 <CelestialLake> dmwit: You underestimate my app. You really want to.
12:25:06 <CelestialLake> :(
12:25:17 <dmwit> andrei: Let me think if I can remember a package that uses `build-type: custom`.
12:25:22 <cocreature> llvm-hs
12:25:40 <shapr> remexre: edwin used to be active on the #idris irc channel, but I've not visited in a year or more
12:25:53 <cocreature> (disclaimer: I’m responsible for some of the custom Setup.hs mess in llvm-hs)
12:26:05 <dmwit> Nice!
12:26:05 * shapr hugs cocreature
12:27:04 <remexre> shapr: yeah, I'm in there, but I mostly lurk
12:27:12 <dmwit> andrei: llvm-hs might be a bit more than you bargained biting off, but... =P
12:27:31 <andrei> dmwit: cocreature: Hah, thanks! I'll check it out
12:27:57 <cocreature> our custom Setup.hs isn’t that bad. we mostly call llvm-config in variuos ways to figure out the right flags to pass to the C compiler
12:35:34 <kuribas> is there an easy to use library for quickly generating dialogs?
12:35:37 <kuribas> for scripts etc...
12:36:30 <dmwit> http://hackage.haskell.org/package/wizards claims to be that, though I've never used it myself.
12:36:38 <Akii> dmwit apparently that makes the STM transactions explode xD
12:36:56 <dmwit> I have used brick, and liked it, though it doesn't really seem suitable for a scripting scenario.
12:37:15 <dmwit> Akii: Oops, that's my cue to disappear!
12:37:16 <dmwit> =D
12:37:27 <dmwit> (I'll be back in an hour or two, leave me some messages.)
12:37:29 <Akii> I thought that, when cloning/duping a tchan, each cloned/duped channel would be separate from the others
12:37:46 <Akii> I'll be in bed by then, maybe tomorrow! Thanks again for your help
12:38:20 <kuribas> dmwit: thanks, that's what I wanted!
12:44:13 <Akii> apparently taking 100k items from a TChan within one transaction is a bad idea
12:44:56 <ddellacosta> is there any consensus on how people do DB migrations in Haskell-land, in particular for postgres?
12:45:00 <mouse07410> dmwit: I also found that applying a brick can often resolve a problem that programming techniques appear powerless against 😄
12:45:50 <remexre> oof, ghcup dies with no-space-left-on-device when installing
12:46:03 <remexre> I don't have much tmpfs, so probably that
12:46:31 <remexre> is there a way to tell it "actually, use ~/tmp/ as tmpfs" instead?
12:53:33 <Akii> is there a way to abort a computation after some time and just get "what has been computed until then"?
12:54:06 <Akii> like timeout but instead of Maybe a a subset of the computation is returned
12:55:09 <kuribas> Akii: store the temporary results in a IOVar?
12:55:12 <kuribas> or MVar
12:55:29 <Akii> yeah
12:57:27 <__monty__> Akii: That was a proffered solution, not a question for whether that was what you meant. (A I read it.)
12:59:18 <Akii> I don't understant __monty__ 
13:00:25 <__monty__> Akii: Every iteration update an IOVar then when the computation times out you can read that intermediate result.
13:00:55 <Akii> yup, that's what kuribas wrote, or not?
13:01:04 <__monty__> Yes.
13:01:59 <__monty__> I understood your "yeah" as "yes, that sounds like a good rephrasing of my question, now give me a satisfactory answer."
13:03:16 <Akii> ah sorry, meant "yup, that might work"
13:03:25 <Akii> at that point I had a similar idea
13:04:29 <__monty__> If you can write the function accumulator style you could just add a counter to bound the number of steps and return whatever the value of the accumulator is.
13:07:18 <deltasquared> you know, I just realised, imperative languages kind of want you to write things the opposite way around to (lazy) functional languages...
13:07:49 <deltasquared> in haskell one tends to pull data from lazy computations. in imperative languages I've found it more ergonomic to push to consumers.
13:08:02 <deltasquared> (other differences aside of course)
13:10:20 <kuribas> deltasquared: you can push also using streams (pipes, conduit, etc...)
13:10:53 <kuribas> but for pure computations that's true
13:11:28 <deltasquared> kuribas: true, but they are higher order abstractions. I'm thinking structures in general. idk it just feels like the base language properties guide you to different solutions. which in general is not surprising, but this particular case gave me pause for thought
13:12:25 <kuribas> one of the most basic differences is that there is no "next computation".
13:12:53 <deltasquared> kuribas: I don't follow...
13:13:28 <kuribas> what matters in haskell is what the input and output is, not the order in which are computed.
13:13:39 <kuribas> Which can be weird for people coming from other languages
13:14:52 <Akii> __monty__ kuribas it works! https://gist.github.com/Akii/eef3b75258c1c721d22260b171075210#gistcomment-2864640
13:14:59 <kuribas> great!
13:15:19 <Cale> deltasquared: Yeah, when you're starting out, all your intuitions are exactly backwards :D
13:15:38 <Cale> (with regard to how to make things perform well)
13:18:33 <Shockk> quick question; I'm trying to debug some haskell code using lldb but I can't see any source-level debug symbols (as far as I can tell, at least)
13:18:48 <Shockk> is there some option that I should pass to `stack build` in order to generate source-level debug syms?
13:24:47 <delYsid> Gah, sometimes I hate translating procedural code to FP.
13:24:48 <Cale> Shockk: there are -optlc and -optlo options to GHC for passing flags through to the LLVM compiler and optimiser respectively
13:25:07 <Cale> Shockk: but... that sounds like a painful way to try to debug your Haskell code, what's the bug?
13:26:20 <Shockk> Cale: I'm not exactly sure, I picked up my code after like 3 months of not working on it at all, made some basic changes just to let it build properly, but it seems to be just not finishing execution and the longer I leave it to run, the longer ctrl-c will take to kill it
13:26:28 <Shockk> i.e. it seems to be in a loop or something
13:27:16 <deltasquared> delYsid: I doubt all classes of programs are really designed for a straightforward translation
13:27:24 <Cale> You might try turning on profiling, and see where it seems to be spending most of its time
13:27:30 <deltasquared> I imagine there would be some that would require an architectural rethink.
13:27:40 <Cale> Shockk: Is it consuming a lot of CPU while doing that, or is it just blocking?
13:27:51 <delYsid> Any hints on how to do the nested loop in https://github.com/official-stockfish/Stockfish/blob/master/src/position.cpp (const string Position::fen() const)?
13:28:45 <deltasquared> oh, chess. hmm
13:29:01 <deltasquared> gah, nope my firefox just imploded, somebody else do it :D
13:29:19 <Cale> delYsid: Well, that probably depends on your board representation a little
13:29:36 <Cale> delYsid: But I'd probably start thinking about list comprehensions to start with.
13:30:21 <Shockk> Cale: not sure, I'm restarting the system right now in case it's something to do with system and xcode command line tools updates lol
13:32:35 <deltasquared> sweet celestia. I didn't know the linux console could send a PC speaker beep via a bell character while I'm in an X11 session. that scared the magikarp out of me. be right back...
13:34:35 <deltasquared> "what's that?" "kettle's done!" :D
13:38:53 <delYsid> Cale: The problem is skipping over empty squares.  The rest is pretty simple lookup.
13:40:34 <delYsid> i.e., not every square results in a Char, consequtive empty sqaures are summed up as a digit.
13:40:54 <delYsid> And I cant think of a way to do that functionally.
13:41:05 <Cale> delYsid: Well, every square produces some sequence of Chars
13:41:14 <Cale> some of those sequences are empty
13:41:30 <Cale> oh, I see
13:41:35 <Cale> it's grouping first
13:41:35 <delYsid> hmmm
13:41:37 * hackage matplotlib 0.7.0 - Bindings to Matplotlib; a Python plotting library  https://hackage.haskell.org/package/matplotlib-0.7.0 (AndreiBarbu)
13:41:47 <Cale> and then converting groups
13:42:02 <Cale> (ignore my previous remark)
13:42:27 <Cale> > map (head &&& length) . group $ "mississippppppppi"
13:42:29 <lambdabot>  [('m',1),('i',1),('s',2),('i',1),('s',2),('i',1),('p',8),('i',1)]
13:43:19 <Cale> obviously not exactly what you're looking for, but you get the idea
13:43:35 <dmwit> deltasquared: I agree; in fact I think this is the core selling point of laziness. Namely: it provides a separation of concerns between the producer of data and the consumer. I have a bit of writing expounding on this concept here: https://stackoverflow.com/a/7868790/791604
13:44:37 <delYsid> I gotta check out group
13:45:17 <Cale> > groupBy (\x y -> x == y && x == ' ') "     p  "
13:45:19 <lambdabot>  ["     ","p","  "]
13:46:29 <delYsid> ah, I could just write '1' for an empty sqaure, and sum them up later I guess?
13:46:34 <dmwit> > groupBy (\x y -> x == y && x == ' ') "   ppp   "
13:46:36 <lambdabot>  ["   ","p","p","p","   "]
13:46:44 <dmwit> (To see how that's actually different than `group` itself.)
13:47:11 <gentauro> > :t groupBy
13:47:13 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
13:47:15 <Cale> > map (\(xxs@(x:_)) -> if x == ' ' then show (length xxs) else xxs) . groupBy (\x y -> x == y && x == ' ') $ "     p  "
13:47:17 <dmwit> :t groupBy
13:47:17 <lambdabot>  ["5","p","2"]
13:47:18 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
13:47:26 <Cale> > concatMap (\(xxs@(x:_)) -> if x == ' ' then show (length xxs) else xxs) . groupBy (\x y -> x == y && x == ' ') $ "     p  "
13:47:26 <gentauro> % :t groupBy
13:47:27 <yahb> gentauro: ; <interactive>:1:1: error:; Ambiguous occurrence `groupBy'; It could refer to either `Data.List.NonEmpty.groupBy', imported from `Data.List.NonEmpty'; or `Data.List.groupBy', imported from `Data.List' (and originally defined in `base-4.12.0.0:Data.OldList')
13:47:28 <lambdabot>  "5p2"
13:47:44 <gentauro> % :t Data.List.groupBy
13:47:44 <yahb> gentauro: (a -> a -> Bool) -> [a] -> [[a]]
13:47:51 <Cale> > concatMap (\(xxs@(x:_)) -> if x == ' ' then show (length xxs) else xxs) . groupBy (\x y -> x == y && x == ' ') $ " Q   p  "
13:47:53 <lambdabot>  "1Q3p2"
13:48:37 * hackage matplotlib 0.7.1 - Bindings to Matplotlib; a Python plotting library  https://hackage.haskell.org/package/matplotlib-0.7.1 (AndreiBarbu)
13:48:44 <dmwit> > groupBy (\x y -> [x,y] == "  ") " Q  ppp  "
13:48:46 <lambdabot>  [" ","Q","  ","p","p","p","  "]
13:49:02 <dmwit> Cale: Your condition can be made way cuter. ^_^
13:49:07 <Cale> indeed
13:49:20 <gentauro> shouldn't `groupBy` signature be `groupBy :: (Ord k) => (a -> k) -> [a] -> [(k,[a])]`?
13:49:26 <dmwit> ?pl \x y -> "  " == [x,y]
13:49:26 <lambdabot> (("  " ==) .) . (. return) . (:)
13:49:31 <Cale> :t groupBy
13:49:32 <dmwit> beautiful
13:49:32 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
13:49:44 <dmwit> gentauro: Why `Ord`, and not `Eq`?
13:49:46 <Cale> gentauro: it doesn't sort
13:49:59 <Cale> gentauro: and in this case, that property of not sorting is crucial
13:50:06 * hackage easytensor-vulkan 1.0.1.0 - Use easytensor with vulkan-api  https://hackage.haskell.org/package/easytensor-vulkan-1.0.1.0 (achirkin)
13:50:08 <dmwit> gentauro: Oh, I see what you're thinking. No, things that are not adjacent are not grouped together.
13:50:15 <gentauro> I expect my keys to be different
13:50:24 <Cale> (because we're trying to summarize a chess board using run length encoding for blank squares)
13:50:30 <gentauro> and `ordable` (I use `Data.Map`)
13:50:44 <gentauro> dmwit: I have worked with `LINQ` to long then ...
13:50:52 <Cale> Obviously, if you want that, it's possible to just stick everything into a Map
13:50:59 <dmwit> gentauro: But if you want that, I use `\f vs -> M.fromList (++) [(f v, [v]) | v <- vs]` all the time.
13:51:33 <dmwit> err, fromListWith, not fromList
13:52:11 <dmwit> related: https://stackoverflow.com/q/12398458/791604
13:52:12 <gentauro> dmwit: seems legit
13:52:34 <gentauro> but you store in a Map (exposing it in the signature) right?
13:52:42 <dmwit> Sure, why not?
13:52:47 <gentauro> for the `O(log n)` lookups amirite?
13:52:52 <dmwit> It's almost always a better representation for the consumer anyway.
13:53:19 <gentauro> normally I just iterate thought it all, so a `Map` or `list` is no biggy for me
13:53:46 <gentauro> and that's why I like to keep the `signature` "clean" for others to use (so they don't have to use `Map`)
13:54:28 <dmwit> It's easy to toss an `M.assocs` on the front if you're nervous about it.
13:57:19 <gentauro> dmwit: mine is similar to yours -> `\f -> Dict.toAscList . Dict.fromListWith (++) . map (\a -> (f a, [a]))`
13:57:48 <dmwit> Damn near identical, yup.
13:58:11 <Akii> dmwit https://gist.github.com/Akii/eef3b75258c1c721d22260b171075210
13:58:14 <dmwit> What, no `map (f &&& pure)`? ;-)
13:58:36 <gentauro> dmwit: I get to much heat in here when I use `pure` ;-)
13:58:51 <Akii> lol I used `map (f &&& pure)` today
13:59:50 <gentauro> `(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c)` that some grown up stuff :|
14:00:14 <dmwit> Akii: Looks good mate.
14:00:19 <Akii> I'm not saying I understood it, but I used it!
14:00:27 <gentauro> I'm only allowed to use `Control.Arrow` when my parents are present
14:00:36 <dmwit> gentauro: (&&&) :: (b -> c) -> (b -> c') -> b -> (c, c')
14:00:38 <Akii> dmwit and works great! :D I'm so happy I've solved this problem that has bugging me for months
14:01:06 <dmwit> gentauro: Looks a lot less mysterious when you substitute in the only Arrow instance anyone ever actually uses. ;-)
14:01:12 <hpc> learning Arrow is more a test of notation than abstraction
14:01:21 <Akii> oh, yes, now that I look at it lol
14:01:35 <hpc> (which in some ways makes it harder...)
14:01:46 <dmwit> (f &&& g) x = (f x, g x)
14:03:33 <Rembane> It has a friend that's also quite useful. 
14:03:35 <Rembane> :t (***)
14:03:36 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
14:04:03 <Rembane> (f *** g) (a, b) = (f a, g b)
14:04:19 <dmwit> Not that useful now that Bifunctor is a thing.
14:04:28 <dmwit> Which also replaces (+++).
14:04:51 <Rembane> True that
14:05:21 <Rembane> But if you already use &&& you don't have to import another module to get the *** functionality
14:05:42 <Akii> lol
14:05:48 <Akii> plus it looks cool and consistent!
14:05:54 <Rembane> I'm all for the small victories! 
14:08:20 <p0a> Hello 
14:09:07 <p0a> Suppose I have a function f :: a -> a. Then I can let g = f. This means g x = f x. However, when writing a function that is more complicated, I have noticed that even if my definition looks like `let g x = ... x', removing the `x' does not result in correct code 
14:09:40 <p0a> For example, `sumDigits xs = sum $ map (sum . toDigits) xs' works, but `sumDigits = (sum . map) (sum . toDigits)' does not.
14:10:04 <p0a> here toDigits 1234 == [1,2,3,4] and sumDigits [12,3,4] == 1 + 2 + 3 + 4. 
14:10:17 <p0a> (no typo in forgetting the comma)
14:10:43 <hpc> sum . map (sum . toDigits)
14:11:00 <hpc> should fix it
14:12:22 <p0a> what is the issue with my code?
14:12:43 <hpc> you translated to function composition incorrectly
14:12:45 <p0a> I get that it's some sort of operator precedence 
14:13:18 <hpc> if you split apart the translation (g x = f x => g = f), you have
14:13:19 <p0a> but map takes 2 arguments and returns 1. sum takes 1 and returns 1. So sum . map should take 2 and retunr 1? no? (I get that all functions take 1 argument and return 1 argument)
14:13:26 <hpc> g x = (f . h . i) x
14:13:28 <hpc> or
14:13:32 <hpc> g x = f . h . i $ x
14:14:05 <p0a> What's h and i?
14:14:06 <hpc> if you translate your original function, it's sum . map (sum . toDigits) $ xs
14:14:26 <hpc> p0a: just extra functions for illustrative purposes
14:15:08 <p0a> but g(f(x)) = (g o f)(x) right?
14:15:14 <p0a> I'm not sure what the parentheses are doing 
14:15:35 <hpc> so, let's take your original translation and take out the function composition
14:15:43 <hpc> (sum . map) (sum . toDigits)
14:16:10 <hpc> let's let x = (sum . toDigits) to save me some typing ;)
14:16:14 <hpc> g = sum, f = map
14:16:15 <p0a> yeah that's a good idea
14:16:34 <hpc> (g . f) x = g (f x)
14:16:35 <p0a> (g . f) x then.
14:16:52 <hpc> so you have sum (map (sum . toDigits))
14:16:59 <p0a> yeah
14:17:04 <hpc> so you're taking the sum of a function
14:17:14 <p0a> ah got you 
14:17:28 <p0a> yeah i've been doing this mistkae a lot
14:17:39 <p0a> but why can't I partially apply to it?
14:18:04 <unyu> p0a: you can
14:18:09 <unyu> but you've been doing it incorrectly
14:18:16 <p0a> and why?>
14:18:24 <unyu> “\xs -> sum $ map (sum . toDigits) xs” is equivalent to “sum . map (sum . toDigits)”
14:18:34 <unyu> note that there are no parentheses around “sum . map”
14:18:49 <unyu> because you want to compose “sum” with “map (sum . toDigits)”
14:19:52 <unyu> in “(g . f) x = g (f x)” substitute “g” with “sum” and “f” with “map (sum . toDigits)”, and you'll see how everything works nicely
14:19:56 <p0a> so if you imagine map as a function of two arguments, map(f, l). Then (sum . map)(f, l) should work, right?
14:20:07 <unyu> no
14:20:14 <hpc> (sum . map f) l
14:20:26 <unyu> p0a: I mean, it would work if the two arguments were tupled.
14:20:30 <unyu> But they are curried.
14:20:45 <p0a> alright I will keep this in mind and try to figure it out
14:20:57 <dmwit> p0a: https://gist.github.com/dmwit/18f199735123728bd40525eebc5d65a7
14:20:57 <p0a> I think that's where my misconception comes from, I'm used to thinking of arguments as tupled
14:21:09 <unyu> p0a: Note that “g (f x y)” and “(g . f) x y” are *not* the same.
14:22:01 <p0a> ah yeah because f :: a->b->c means a->(b->c) right?
14:22:07 <hpc> yep
14:22:24 * p0a got it. maybe.
14:22:30 <p0a> dmwit: thanks, checking 
14:22:31 <hpc> :t \f g x y -> f (g x y)
14:22:31 <lambdabot> (t1 -> t2) -> (t3 -> t4 -> t1) -> t3 -> t4 -> t2
14:22:42 <hpc> :t \f g x y -> f (g x) y
14:22:43 <lambdabot> (t1 -> t2 -> t3) -> (t4 -> t1) -> t4 -> t2 -> t3
14:23:02 <hpc> that couldn't have been abcd? :(
14:23:14 <gentauro> anybody here really skilled in media design?
14:23:24 <p0a> *crickets*
14:23:26 <gentauro> (I'm asuming no right? xD)
14:23:30 <hpc> heh, probably not
14:23:45 <dmwit> Maybe? But what comes next is... *probably* not a Haskell question, so...
14:24:27 <gentauro> somebody told me (I'm the organizer of the FP Meetup in Copenhagen) that why I don't use the `little mermaid` as it's clearly a Lambda
14:24:52 <p0a> dmwit: what's an eta reduction? removing the argument?
14:25:09 <hpc> eta reduction is function application
14:25:18 <slack1256> that's beta
14:25:36 <hpc> it comes from https://en.wikipedia.org/wiki/Lambda_calculus#Reduction
14:25:37 <gentauro> I was just. Fuck off and then ... https://imgur.com/a/AybRR0A
14:25:39 <gentauro> :| 
14:25:40 <p0a> dmwit: thanks, I understand your file
14:25:41 <gentauro> WTF
14:25:46 <p0a> also unyu thanks for helping me out
14:25:48 <gentauro> she is posing like a `lambda` :o
14:26:11 <p0a> gentauro: for an organizer you sound a little off 
14:26:38 <gentauro> p0a: don't you have `whiskey` at your place :|
14:26:41 <dmwit> p0a: Yes, eta reduction is the move from `\x -> f x` to `f`.
14:27:33 <unyu> p0a: np
14:27:42 * slack1256 thinks λ is just inverted y
14:28:12 <Akii> needs a lot of ImaginationM for that to be a lambda
14:28:14 <dmwit> I just turned my head upside down to check.
14:28:18 <dmwit> Nope, the tail goes the wrong way.
14:28:46 <slack1256> Mmm on my font (droid sans mono) on uxterm looks the same
14:29:00 <gentauro> slack1256: I was at a meeting with Swedish Company called `Synch`. When I look through the mirror and saw the reflection, obvioly the `h` is a `λ`
14:29:11 <p0a> when you're moving your head upside down you're looking at an inversion + flip, but lambda and y are mirror images
14:29:39 <p0a> well, `mirror', right? So in a mirror, letters appear inverted. anyway
14:30:05 <dmwit> Is an inversion a rotation or a reflection?
14:30:07 <dmwit> IDK
14:30:10 <gentauro> synch logo for reference -> https://synchlaw.se/da/presse/
14:30:18 <slack1256> das it mane?
14:34:01 <gentauro> dmwit: They had the logo on a window, looking from the other side `h` become `λ`. I don't think it will work with a mirror though
14:36:27 <monochrom> I propose to call the h version of lambda "hambda". :)
14:38:09 <int-e> dmwit: http://mathworld.wolfram.com/Inversion.html is neither of that
14:38:13 <dmwit> What meat do you get from a stupid pig? Ham, duh.
14:39:00 <dmwit> int-e: I just turned my eye inside out to check, λ looks nothing like an inverted y.
14:39:38 <int-e> I think you'll just want a mirror in that case
14:41:36 <monochrom> The English word "invert" is used by everyone to mean whatever different unspecified involution they have in mind.
14:42:38 <MarcelineVQ> or, co, or dual, or...
14:43:10 <monochrom> opposite
14:43:12 <int-e> ...such complementary language
14:43:27 <Clint> coinverted
14:43:30 <delYsid> Cale: Thanks, that works.
14:48:18 <gentauro> dmwit: why not use Polyas formula :P
14:48:57 <gentauro> https://en.wikipedia.org/wiki/P%C3%B3lya_enumeration_theorem
14:50:13 <gentauro> I was looking for my old math tasks from uni (`Algebra 1`) and I remember doing these tasks. The `terms` you might be looking for are `rotate` and `reversed` ;)
14:50:24 <dmwit> I'm into that theorem. But what, exactly, are you proposing I use it for?
14:51:00 <gentauro> `h` is a `λ`
14:51:01 <gentauro> :P
14:51:14 <dmwit> IDGI
15:11:37 * hackage ocaml-export 0.13.0 - Convert Haskell types in OCaml types  https://hackage.haskell.org/package/ocaml-export-0.13.0 (mchaver)
15:19:10 <Shockk> Cale: I figured out what my issue is, I'm a bit rusty so I'm unsure how to solve it:
15:20:03 <Shockk> the grammar of my language right now specifies that I can write something like:   square = x -> { x * x }
15:20:43 <Shockk> the issue is that the rhs of that expression is defined as a block, which is a type of primary in my grammar
15:21:01 <Shockk> however, a block looks for an optional (primary "->") at the start of it
15:21:23 <Shockk> so then it gets stuck in a loop, continuously trying to look for (primary "->") and entering the block primary path
15:23:00 <delYsid> OK, that was a fun sunday evening: https://blind.guru/Chess.hs
15:23:16 <Shockk> do you think it'd make more sense to have a separate grammar term for 'function argument' that I look for in my block grammar?
15:23:20 <delYsid> far from finished, but I think I can go on like this.
15:23:42 <p0a> How can I `let' a function? let f x = x, for example 
15:24:02 <p0a> oh that works. nevermind I misread my error lol
15:24:07 <Shockk> p0a: that's exactly how you do it lol
15:24:18 <p0a> that was lame
15:24:45 <mtb34> Good evening. How can I make VSC ignore punctuation characters in word navigation? ie. when I do ctrl+leftArrow it shall not jump to the next dot, comma or paranthesis but word..
15:25:55 <p0a> mtb34: look up 'control arrow VSC' online and see how to modify it 
15:31:00 <mtb34> I searched a lot but was unable to find something already. Maybe I'm lacking the right keywords. I couldn't even find a page of people asking the same question
15:42:43 <shapr> mtb34: I think that's specific to vscode, and I've never used that :-(
15:43:20 <shapr> hm, I think a test-suite stanza in my cabal file requires a library section
15:43:29 <shapr> I think that's obvious after a second considering
15:44:07 * hackage string-interpolate 0.1.0.0 - Haskell string/text/bytestring interpolation that just works  https://hackage.haskell.org/package/string-interpolate-0.1.0.0 (williamyaoh)
15:49:07 * hackage glue-core 0.6.3 - Make better services and clients.  https://hackage.haskell.org/package/glue-core-0.6.3 (seanparsons)
15:50:07 * hackage glue-example 0.6.3, glue-ekg 0.6.3, glue-common 0.6.3 (seanparsons)
15:56:37 * hackage matplotlib 0.7.2 - Bindings to Matplotlib; a Python plotting library  https://hackage.haskell.org/package/matplotlib-0.7.2 (AndreiBarbu)
16:18:36 * hackage shake-cabal 0.2.1.0 - Shake library for use with cabal  https://hackage.haskell.org/package/shake-cabal-0.2.1.0 (vmchale)
16:20:07 * hackage shake-ats 1.10.2.1, shake-c 0.4.1.0 (vmchale): https://qbin.io/wb-msgid-o77i
16:56:06 * hackage shake-c 0.4.2.0 - Library for building C code with shake  https://hackage.haskell.org/package/shake-c-0.4.2.0 (vmchale)
16:57:37 * hackage matplotlib 0.7.3 - Bindings to Matplotlib; a Python plotting library  https://hackage.haskell.org/package/matplotlib-0.7.3 (AndreiBarbu)
17:02:24 * CelestialLake shrugs
17:05:07 * hackage ats-pkg 3.2.5.6 - A build tool for ATS  https://hackage.haskell.org/package/ats-pkg-3.2.5.6 (vmchale)
17:16:07 * hackage matplotlib 0.7.4 - Bindings to Matplotlib; a Python plotting library  https://hackage.haskell.org/package/matplotlib-0.7.4 (AndreiBarbu)
17:16:26 <owhit> How do i do something like: `let (loop :: MyType) = do ...`
17:17:50 <Cale> owhit: There's nothing invalid about that syntax as you wrote it, but MyType had better be of the form (m a) for some monad m if you intend to use do-notation to define one.
17:18:29 <owhit> Cale: what I really have is `let (loop :: StateT GameState IO ()) = do`
17:18:39 <Cale> sure, that works
17:18:43 <owhit> But it says Type signatures are only allowed in patterns with ScopedTypeVariables
17:18:52 <Cale> ah, well, turn that extension on
17:19:03 <Cale> {-# LANGUAGE ScopedTypeVariables #-}
17:19:14 <Lears> It's better to write `let loop :: MyType; loop = do ...`. `(loop :: MyType) = do ...` has some restrictions, even with STV.
17:19:15 <owhit> ah. Why isn't this the default?
17:19:38 <Cale> Yeah, you could also write the signature separately like that
17:19:51 <Cale> It's just that Haskell 98's syntax was very restrictive
17:20:15 <owhit> Ok. Well, that was super helpful. Thank you
17:20:17 <Cale> There are a lot of easy extensions to it which most people will turn on pretty quickly.
17:21:27 <Cale> ScopedTypeVariables probably should have been the default, but it's not entirely conservative
18:08:55 <royal_screwup21> are there any good serverless deployment services that are NOT part of amazon?
19:04:37 * hackage relude 0.5.0 - Custom prelude from Kowainik  https://hackage.haskell.org/package/relude-0.5.0 (shersh)
19:23:57 <unyu> Hello. Does anyone know of a good purely functional priority deque data structure?
19:24:42 <unyu> The only thing I could find so far is an adaptation of binary heaps called “min-max heaps”, but that is very much an imperative data structure.
19:25:15 <lyxia> what do you think of Map
19:25:45 <lyxia> I think there's also something in fingertrees
19:26:59 <unyu> Map works, but one would hope that there is a data structure with amortized O(1) merges.
19:27:15 <unyu> The thing with finger trees is... what would I use as the summarizing monoid?
19:40:57 <lyxia> min and max?
19:41:21 <lyxia> But I mean, there's a PriorityQueue module https://hackage.haskell.org/package/fingertree-0.1.4.2/docs/Data-PriorityQueue-FingerTree.html
19:43:01 <lyxia> What is a merge for you? I'm not sure how it can be amortized O(1).
19:45:12 <unyu> lyxia: A priority deque gives you access to both the least and greatest element in it, as well as the possibility to remove them. A merge combines the elements of two priority queues.
20:15:27 <POGtastic> hi guys - I have a LocalTime. I want to make a function that takes a LocalTime and returns a (UTCTime, String) where the String is the tzdata on my machine ("America/Los_Angeles"). I'm kinda stumped on how to do this in a haskell-ish way.
20:16:06 <POGtastic> i suppose it should be an IO (UTCTime, String), as i'll be accessing a file
20:17:34 <glguy> POGtastic: There's getCurrentTimeZone and localTimeToUTC, but I don't know of a way to get the timezones in that particular string-format using the time package
20:18:39 <glguy> Perhaps a package like: http://hackage.haskell.org/package/tzdata-0.1.20181026.0/docs/Data-Time-Zones-DB.html
20:20:48 <POGtastic> @glguy: that looks like what I'm looking for. I guess I just need to figure out a way to get that TZLabel.
20:20:48 <lambdabot> Unknown command, try @list
20:21:31 <Thyringer> hello
20:22:27 <glguy> o/
20:27:02 <Thyringer> data Vec2D_ = Vec_ (Int, Int)
20:27:03 <Thyringer> data Vec2D = Vec Int Int
20:27:03 <Thyringer> Can someone explain to me what the difference between these two types is? Somehow I do not see any sense in that both are possible.
20:30:17 <c_wraith> the former is less efficient in practice
20:30:45 <c_wraith> In order to have correct semantics, it needs a lazy (,) constructor inside the lazy Vec_ constructor
20:31:25 <c_wraith> But I suppose you *might* want that, but 99.9% of the time, you don't
20:32:41 <Thyringer> mh ok. thx
20:32:41 <Thyringer> it still confuses me, because you can not do something like that:
20:32:47 <Thyringer> data Matrix = Matr Vec Vec
20:33:08 <c_wraith> You can do that as long as Vec is a defined type
20:34:15 <Thyringer> ah ok. thx
20:37:50 <Thyringer> x = Matrix (Vec 2 3) (Vec 3 4)
20:37:51 <Thyringer> I've previously programmed in C, and I wonder why in haskell you have to write the name of the data after the equals sign:
20:38:43 <geekosaur> because it has no idea what type you want otherwise. C tries to hande that for you — and can easily do things you didn't intent as a result
20:38:47 <c_wraith> There's two reasons, depending on the sense in which you're asking the question.
20:39:01 <c_wraith> One is what geekosaur said - different constructors imply different types.
20:39:12 <c_wraith> The other is that a type can have multiple constructors.
20:39:19 <c_wraith> data Bool = False | True
20:39:39 <c_wraith> So you can't just automatically use the type name as the constructor
20:40:11 <dmwit> In short: you don't have to write the name of the data after the equals sign.
20:40:28 <dmwit> You do have to write *a* name, but it doesn't have to be the same as the name of the type.
20:44:23 <Thyringer> ok, ok in C I would specify a variable type for the variable: x :: Matrix = (2 3) (3 4)
20:44:52 <Thyringer> XD Haskell seems a bit more complicated
20:49:00 <c_wraith> There's certainly a higher up-front burden of knowledge.  It's easier to get something that looks like it's working in C
20:49:39 <c_wraith> The problem is making something that's actually *correct* in C is ridiculously harder.  (Undefined Behavior is a curse)
20:54:21 <habbah> https://hackage.haskell.org/package/rio-0.1.8.0/docs/RIO.html#g:2
20:54:29 <Thyringer> I just think that such a literal value is ultimately applied somewhere by a function, so ghc could actually automatically find compatibility based on the structure (without specifying the constructors)?
20:54:31 <habbah> where is App defined in this withLogFunc example?
20:57:05 <c_wraith> Thyringer: constructors are an important part of inference, though.  You always know what type a value is if you can see its constructors.  That gives you lots of flexibility.
20:57:36 <c_wraith> habbah: the comment right after it suggests it's some application-specific type
20:57:49 <c_wraith> habbah: ie, a stand-in for your own code's environment type
21:00:48 <Thyringer> In the example: data Bool = False | true
21:00:48 <Thyringer> So are False and True something like parameterless constructors / functions?
21:01:06 <c_wraith> They are constructors that don't take arguments, yes
21:02:20 <Thyringer> Then in haskell really (almost) everything is a function, even data?
21:02:32 <c_wraith> no, most things aren't functions
21:02:45 <c_wraith> Only things with (->) at the top-level type constructor are functions.
21:02:50 <c_wraith> *as
21:03:34 <c_wraith> > True ()
21:03:36 <lambdabot>  error:
21:03:36 <lambdabot>      • Couldn't match expected type ‘() -> t’ with actual type ‘Bool’
21:03:36 <lambdabot>      • The function ‘True’ is applied to one argument,
21:03:55 <c_wraith> haha, great messaging there ghc.  True is not a function!
21:04:03 <Thyringer> :D
21:04:41 <c_wraith> It's trying to say "the expression `True', which is being used as a function syntactically..."
21:07:32 <Thyringer> I try to understand this sum type and think that it is a set, with two symbols as elements; therefore, it is strange to see these two symbols as constructors / functions at the same time.
21:08:43 <dmwit> Why is it strange to see False as both an element and a constructor?
21:09:20 <c_wraith> They're sets, but not just arbitrary sets.  The set of values in some specific type is disjoint from the set of values in any other type.
21:10:37 * hackage checkers 0.4.13 - Check properties on standard classes and data structures.  https://hackage.haskell.org/package/checkers-0.4.13 (ConalElliott)
21:11:00 <c_wraith> this isn't to say that an expression can't be polymorphic.  Just that when you make an expression monomorphic, it's no longer valid as any other type
21:25:12 <Thyringer> data Configuration = Config {
21:25:13 <Thyringer> 	username      :: String,
21:25:13 <Thyringer> 	isGuest       :: Bool,
21:25:13 <Thyringer> 	timeConnected :: Integer
21:25:13 <Thyringer> }
21:25:13 <Thyringer> config = Config "ER" False 90
21:25:15 <Thyringer> config_ = (Config "ER", False, 90)
21:25:17 <Thyringer> why are these two ways of writing possible here?
21:25:39 <jle`> Thyringer: those are two different things
21:25:44 <dmwit> They're both possible, but they don't mean the same thing.
21:25:48 <jle`> Thyringer: the first one has type 'Configuration'
21:26:02 <jle`> Thyringer: the second one has type (Bool -> Integer -> Configuration, Bool, Integer)
21:26:06 <jle`> it's a 3-tuple
21:27:01 <Thyringer> config_ = (Config "ER" False 90, False, 90)
21:27:23 <Thyringer> ok, I see it.
21:28:15 <jle`> (x,y,z) is syntax for writing a 3-tuple, where 'x' is the first item, 'y' is the second item, and 'z' is the third item
21:28:49 <Thyringer> only in this variant, config missing two elements / arguments?
21:28:49 <Thyringer> config_ = (Config "ER", False, 90)
21:29:13 <jle`> Thyringer: 'Config' is actually a function here
21:29:21 <jle`> Config :: String -> Bool -> Integer -> Configuration
21:29:41 <jle`> or, String -> (Bool -> Integer -> Configuration)
21:29:53 <jle`> so what you're doing here is partially applying with "ER"
21:30:10 <jle`> to get the resulting Bool -> Integer -> Configuration
21:31:30 <Thyringer> ah ok.  I understand. 
21:43:37 <Thyringer> data Configuration = Config {
21:43:38 <Thyringer> 	username      :: String,
21:43:38 <Thyringer> 	isGuest       :: Bool,
21:43:38 <Thyringer> 	timeConnected :: Integer
21:43:38 <Thyringer> }
21:43:38 <Thyringer> config = Config "ER" False 90
21:43:40 <Thyringer> name = config.username
21:44:23 <Thyringer> how do you do that right? Records seem to me particularly complicated
21:45:16 <glguy> Thyringer: You'd want to indent the last } a little further
21:45:28 <glguy> name = username config
21:48:32 <Thyringer> mh Haskell searches here automatically from the variable "config" the appropriate value of "username"+
21:48:54 <Thyringer> ?
21:50:14 <jle`> Thyringer: ah, `name` isn't quite what you think it is
21:50:28 <jle`> '.' is actually just a normal operator here, it doesn't do anything special
21:50:32 <jle`> it's like 3 + 5
21:50:42 <jle`> here it's `config . username`
21:51:07 <jle`> Thyringer: here, username is a function, `username :: Configuration -> String`
21:51:41 <jle`> records are kind of like syntactic sugar for generating convenient functions like that
21:56:32 <Thyringer> here it seems as if "username" will be fed as a function with the parameter "config" and automatically fish out the appropriate value from the expression "Config" ER "False 90".
21:56:49 <glguy> username is a function
21:57:16 <glguy> When you apply it to a value with type Configuration, it returns the username field of that value
21:57:44 <glguy> as a shorthand you can skip specifying the fieldnames when building a Configuration value
22:02:15 <Thyringer> OK thanks. but honestly that is not very catchy.
22:02:32 <Thyringer> records in haskell.
22:04:16 <jle`> Thyringer: 'username' is a function, defined as:
22:04:24 <jle`> Thyringer: username (Config u _ _) = u
22:04:51 <jle`> so the record syntax here is kind of like sugar to auto-generate that function
22:04:57 <jle`> so you don't have to write it by hand
22:07:15 <Thyringer> username (Config u _ _) = u
22:07:16 <Thyringer> what does that mean exactly why u?
22:08:23 <jle`> it's a placeholder
22:08:27 <jle`> are you familiar with pattern matching?
22:08:32 <jle`> like, `head (x:_) = x
22:09:23 <Thyringer> a little bit
22:34:13 <mjrosenb> if I have foo :: X -> State Y Z, and I want to be able to call foo both so it updates the state and so it doesn't, is it better to add a boolean argument to foo that controls whether or not it writes back to the state, or is it better to just discard the state when I'm done with it?
22:58:34 <dminuoso> Mmm, is there a convention to expose test modules so that library users can use existing Arbitrary instances?
23:00:22 <figurelisp> is monad a design pattern which can be implemented in any language even if language is not pure functional?
23:00:45 <dminuoso> figurelisp: Monad is an abstract interface rather than a design pattern.
23:01:31 <figurelisp> ok
23:01:42 <figurelisp> and it can be implemented in any language right
23:01:53 <jle`> figurelisp: technically it can be possible with enough discipline, but the language won't be helping you along the way necessarily
23:01:59 <dminuoso> figurelisp: Yeah, but with varying degrees of succeess.
23:02:35 <jle`> there'll be a lot of caveats that aren't natural necessary in a given language
23:02:52 <figurelisp> i see a lot of blogposts with title monads in javascript, so i was thinking is that necessary in JS
23:03:17 <dminuoso> figurelisp: Also some languages sometimes have the primitves built in already.
23:03:34 <dminuoso> figurelisp: JavaScript for example comes with monadic interface for async out of the box
23:03:34 <dminuoso> Although its not exactly lawful.
23:03:39 <jle`> JS makes it someone easier, since we have first-class functions in javascript. but using them in a way that is useful requires a lot of disciplined restrictions about what you are allowed to write
23:05:21 <dminuoso> Also the monadic interface requires a toolbox of related combinators to be really useful.
23:05:50 <dminuoso> So in JavaScript you would be lacking those combinators, you would have to write them yourself. And without a strong type system, like jle` has pointed out, it requires a very high discipline.
23:07:07 <figurelisp> ok, i have never read monads so i don't understand them and the use case of them.
23:09:07 * hackage hnix 0.6.0 - Haskell implementation of the Nix language  https://hackage.haskell.org/package/hnix-0.6.0 (JohnWiegley)
23:10:29 <dminuoso> figurelisp: Are you learning Haskell at the moment?
23:11:24 <figurelisp> trying to
23:12:58 <dminuoso> figurelisp: Then dont focus on understanding monad. It will come on its own automatically.
23:13:27 <figurelisp> ok :)
23:14:01 <figurelisp> do you use haskell at work?
23:14:04 <dminuoso> Yes.
23:14:26 <figurelisp> do i need to be very good in maths to become a good programmer
23:14:45 <dminuoso> No.
23:14:51 <dminuoso> Basic high school math is perfecty sufficient.
23:15:08 <figurelisp> nice
23:15:53 <figurelisp> what kind of work do you do with haskell
23:17:58 <dminuoso> I work for an ISP, so it's mostly networking related.
23:18:40 <figurelisp> cool!
23:18:42 <figurelisp> thanks
23:49:21 <remexre> I asked earlier about best practices for error handling, and I got pointed to exceptions; does the "this is best-practices" include using imprecise exceptions in pure code, or should I be doing something else?
23:50:25 <dibblego> I think you'll find that opinion is not widely shared
23:50:27 <remexre> for reference, my this-is-what-I-do-in-Rust error type is roughly data Error = Error { kind :: ErrorKind, cause :: forall a. (Show a, Typeable a) => a, ... }
23:50:52 <remexre> opinion that exceptions are good, or that imprecise exceptions are good?
23:51:02 <dibblego> "use exceptions"
23:52:24 <remexre> is there a better/nicer solution than putting (ExceptT Error) in my monad transformer stack?
23:52:38 <remexre> where "nicer" really means "avoiding the existential" I guess
