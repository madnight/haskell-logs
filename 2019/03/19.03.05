00:07:54 <fr33domlover> When you import a module, how do you decide whether to import just specific symbols or the whole module? My rule of thumb usually is: Import specific symbols until the list of them reaches the end of the line (column 80) and then just import the whole module. Or sometimes I just import the module when it's a common one that feels safe and non confusing (say, Data.Maybe, Data.Proxy, etc.)
00:15:01 <Cale> fr33domlover: It depends on the particular module. Certain modules (Data.Text, Data.Map, Data.Set) always get imported qualified, and only the types get separately imported unqualified. Certain modules (stuff like Control.Monad) get imported completely and unqualified from the start.
00:15:31 <Cale> fr33domlover: If it's going to be hard to figure out which module a thing came from, then that thing will get imported explicitly
00:15:57 <fr33domlover> Cale, sounds smart ^_^
00:25:08 * hackage eventstore 1.2.2 - EventStore TCP Client  https://hackage.haskell.org/package/eventstore-1.2.2 (YorickLaupa)
00:31:46 <dminuoso> fr33domlover: GHC as a counterexample asks authors to always import entire modules and only resort to import lists in order to resolve name clashes.
00:32:06 <dminuoso> fr33domlover: You can find a list of reasons at https://ghc.haskell.org/trac/ghc/wiki/Commentary/CodingStyle#Imports
00:32:42 <fr33domlover> dminuoso, thanks, I'll take a look
00:35:14 <fr33domlover> Hmmm those are good points
00:35:33 <fr33domlover> I mean, keeping a minimal import list can be annoying
00:37:58 <dminuoso> fr33domlover: I think it's useful to consider where much of your time is spend and how a given coding style is going to help with that.
00:38:32 <dminuoso> I do not see "minimal import lists" helping with much other than a neurotic sense of cleanliness and a noble desire to be very explicit.
00:38:56 <dminuoso> But YMMV.
00:39:12 <merijn> It depends on whether your imports are internal or external
00:39:33 <merijn> I use explicit import lists for external modules, for internal modules I don't
00:40:02 <merijn> dminuoso: Without an explicit import list the PVP becomes less useful for avoiding breakage
00:40:44 <dminuoso> merijn: Qualified imports can address that too.
00:41:51 <merijn> dminuoso: Sure, but that can be very verbose to type out if you use some functions a lot
00:43:33 <dminuoso> merijn: It would be wonderful if you could bring a qualified module locally into scope without qualifiers.
00:44:15 <dminuoso> Well. Perhaps not wonderful, it was just a random thought that just popped into my head.
00:46:47 <dminuoso> merijn: at any rate, I dont think there's "the right solution" when it comes to this portion of coding style.
00:47:09 <dminuoso> Consistency is probably key.
00:52:05 <merijn> dminuoso: I'm not sure what you mean by "bring a qualified module locally into scope without qualifiers"?
00:53:29 <dminuoso> merijn: Okay lets say more general local imports.
00:53:39 <dminuoso> `let import Foo in ... `
01:33:07 <arjen-jonathan> Can I combine ST with ErrorT?
01:34:01 <arjen-jonathan> In the order that doesn't do state backtracking obviously
01:34:27 <Cale> Sure
01:34:32 <Cale> You can apply ErrorT to ST
01:35:25 <wuffie> i did a complete fresh reinstall of stack and im still unable to build gi-glib and gi-cairo
01:35:53 <wuffie> the logs end at linking, no errors pop up or anything
01:36:42 <arjen-jonathan> Cale: I have this beast 'ReaderT (Env s) (StateT (Solver s) (ErrorT Error (ST s)))'
01:36:49 <arjen-jonathan> Lets call it M
01:36:59 <arjen-jonathan> I don't understand how I can implement runM
01:37:45 <Cale> wuffie: I don't know anything about stack, but I was able to get into a nix-shell with a GHC having those libraries installed just now.
01:37:50 <merijn> arjen-jonathan: You just apply "runX" in reverse order of your stack
01:38:23 <merijn> arjen-jonathan: ReaderT is the outer layer, so you use "runReaderT" to unwrap it and get "StateT ...", then you apply runStateT (or eval, or exec) to unwrap that layer, etc.
01:38:25 <wuffie> oh i forgot to mention, im on windows
01:38:31 <wuffie> probably a big thing lol
01:38:38 <Cale> ah
01:38:50 <Cale> Well, that's likely to make it a good deal more difficult, yeah
01:39:20 <merijn> wuffie: Are you sure those packages support building on windows? :)
01:39:24 <arjen-jonathan> merijn: Yeah, but somehow the state rank 2 typing is getting in the way
01:39:31 <arjen-jonathan> Couldn't match type ‘s’ with ‘s0’
01:39:33 <wuffie> merijn thats a VERY good question
01:40:03 <wuffie> i just kind of assumed they did
01:40:32 <wuffie> either way, heres the insanely small log for gi-cairo
01:40:34 <wuffie> https://pastebin.com/25QBK8sN
01:40:45 <wuffie> its more or less the same for gi-glib
01:40:51 <merijn> arjen-jonathan: Having the ST 's' in the ReaderT and StateT: 1) looks wrong and 2) probably can't work
01:40:52 <wuffie> i really dont understand what would be going wrong
01:41:13 <merijn> wuffie: Run cabal with -v3 to get a less small log ;)
01:41:24 <wuffie> am i able to do that through stack?
01:41:36 <merijn> wuffie: No clue, but presumably stack has a verbosity switch too
01:42:14 <wuffie> i get a HUGE amount of visual noise from using -v but it doesnt really give any extra information on the failure
01:42:28 <Cale> arjen-jonathan: It's preventing unsafe stuff from happening
01:42:50 <arjen-jonathan> Cale: I understand the use of s, I don't understand the type-checking and inference that is going on.
01:43:10 <merijn> arjen-jonathan: The problem is that "runST" requires the ST action to have a completely free 's' variable
01:43:40 <Cale> arjen-jonathan: You should at least be able to write runM e s x = runErrorT (runStateT (runReaderT x e) s)
01:43:41 <merijn> arjen-jonathan: But runReaderT has to pass a "Env s" as input, which fixes the 's' variable, which means runST can't/won't accept the action
01:44:34 <Cale> :t runST
01:44:35 <lambdabot> (forall s. ST s a) -> a
01:44:54 <Cale> ^^ argument is required to be polymorphic in s, so you can't pick a particular s at all
01:45:16 <Cale> Even one which is yet another variable from an outer scope
01:46:55 <Cale> But that doesn't mean that this monad is unusable.
01:47:18 <arjen-jonathan> merijn: I think I got it
01:47:20 <arjen-jonathan> runST (runErrorT (evalStateT (runReaderT c Map.empty) emptySolver))
01:47:46 <arjen-jonathan> The problem was that runStateT returns the state, projecting out the return value using evalStateT does the trick.
01:47:56 <merijn> Cale: Looks like there's at least one ST transformer on hackage :p
01:48:06 <arjen-jonathan> That prevents the thread variable from escaping the forall scope.
01:48:28 <merijn> arjen-jonathan: That looks reasonable, assuming it type-checks ;)
01:48:49 <arjen-jonathan> The type errors where really unhelpful throughout this.
01:49:04 <arjen-jonathan> For these higher rank types I prefer my Agda type checker ;-)
01:49:50 <dminuoso> arjen-jonathan: It's somewhat equivalent to a lambda function `\x -> x + 1` - you simply cant refer to the `x` outside the function.
01:49:55 <dminuoso> It's just a silly thing to conceive.
01:50:03 <Cale> arjen-jonathan: ah, good enough, I thought the initial conditions were somehow a little less empty -- which would be okay, it would just mean that you'd have to set up your STRefs for your environment and state before running the monad transformers (all inside the runST)
01:52:42 <nshepperd> it would be cool if the s in ST s had its own kind
01:52:53 <arjen-jonathan> Cale: Yeah, that makes sense.
01:53:04 <nshepperd> like, ST :: Thread -> * -> *
01:55:08 <arjen-jonathan> dminuoso: the 'model' makes complete sense to me; it is just that I'm used to type parameters being visible ;-)
01:56:56 <dminuoso> arjen-jonathan: Do you mean type applications?
01:59:38 <arjen-jonathan> No, also type abstractions
02:00:10 <arjen-jonathan> \s . (...) :: forall s . (...)
02:07:30 <slaterr> is there a not . null function?
02:08:06 <slaterr> if not (null xs) looks odd, and I can't use when, or pattern matching (I'm using multi-way-if)
02:08:41 <merijn> slaterr: What's odd about "not (null xs)"?
02:09:24 <merijn> erikd: ping?
02:10:08 * hackage BlogLiterately 0.8.6.3 - A tool for posting Haskelly articles to blogs  https://hackage.haskell.org/package/BlogLiterately-0.8.6.3 (BrentYorgey)
02:10:15 <slaterr> double negation
02:10:30 <slaterr> not no elements
02:10:35 <merijn> slaterr: Well, how else would you call it?
02:11:10 <slaterr> merijn, I'll think about that if such a function doesn't already exist in base (does it?)
02:11:25 <byorgey> no, it doesn't
02:11:48 <merijn> slaterr: That seems like a classical case of "below Fairbairn threshold"
02:12:32 <dminuoso> arjen-jonathan: forall introduces the type variable
02:12:49 <dminuoso> arjen-jonathan: so it already fulfills the purpose of \s
02:14:23 <merijn> Anyway know any neat tricks for doing sliding windows over a vector?
02:15:32 <arjen-jonathan> dminuoso: one is the type, one is the term.
02:15:35 <slaterr> <merijn> slaterr: Well, how else would you call it? <- hasElements seems like a good candidate
02:16:12 <Cale> That's longer than just writing not . null
02:16:20 <slaterr> but reads nicer
02:16:25 <Cale> does it?
02:17:07 <merijn> slaterr: So define hasElements in your code, then use that?
02:17:17 <dminuoso> arjen-jonathan: I guess this only makes sense in a dependently typed language?
02:17:48 <slaterr> Cale, yes.
02:19:38 <Cale> slaterr: I dunno, I'm really used to seeing not . null
02:21:04 <Cale> Somewhat foolishly, we have notElem to go along with elem
02:22:12 <Cale> Though it's trickier to compose elem the right way with not and a particular element, unless you just use a lambda
02:22:14 <slaterr> I don't mind not . elem.. it's double negation (a pet peeve of mine) that bothers me in not . null
02:22:25 <Cale> How is null negation?
02:22:50 <Cale> null is an adjective describing a particular list
02:23:13 <slaterr> null -> no elements. it reads as not (noElements xs) to me
02:23:21 <Cale> null xs means that xs is exactly the empty list []
02:23:55 <Cale> If it were called noElements, you might have a point there ;)
02:24:04 <Taneb> Clearlywe should define ull :: [a] -> Bool, ull = not . null ;P
02:24:19 <Taneb> (I do not seriously advocate for this)
02:24:30 <merijn> I wish Haskell/GHC/Cabal had a better story for migrating module hierarchies so we wouldn't be stuck with historical mistakes forever in the name of backwards compatibility...
02:25:02 <byorgey> doesn'tNotHaveNoElements xs = not . not . null
02:25:15 <byorgey> uh, but without the xs =)
02:26:36 <Cale> merijn: What, you don't like having two miscellaneous junk drawers?
02:26:48 <merijn> Cale: I wasn't even referring to Control vs Data
02:27:26 <merijn> Cale: I was referring to the atrocity of vector-algorithms having "everything" in Data.Vector.Algorithms and then having "everything" only be sorting algorithms
02:28:22 <merijn> Cale: Now that someone is maintaining it on github instead of darcs and I can easily submit patches I have a bunch of things I wanna add, however none of those are sorting algorithms. It would be nice to group them by "algorithm (type)" but then all the current sorting ones are odd ones out
02:29:28 <Taneb> merijn: it also has one module for searching algorithms!
02:29:46 <merijn> Taneb: Like I said, confusing atrocity!
02:29:46 <Taneb> But yes
02:30:26 <Cale> merijn: Move them to a submodule and have Data.Vector.Algorithms just re-export everything?
02:30:26 <Taneb> Maybe I should make a PR with "Data.Vector.Algorithms.Bogo"
02:30:34 <slaterr> Cale, btw, notElem probably exists for infix use
02:31:03 <Cale> slaterr: Well, if it was only for that, it would be kind of funny
02:31:44 <slaterr> I see no other point for it existing
02:32:25 <Taneb> (it would be nice if we could infix longer expressions like `((.) not . elem)` )
02:32:30 <Cale> actually nevermind
02:32:40 <Cale> I was thinking that it might make some points-free expressions simpler
02:32:53 <Cale> But (`notElem` xs) is an unusual case
02:33:35 <Cale> More often, the section you want would be (x `notElem`), which can also just be written (notElem x), or (not . elem x)
02:33:50 <Cale> so notElem really doesn't have much of an excuse for existing
02:35:45 <Cale> (elem itself is also rather funny, in that it's almost an admission that you've used the wrong data structure)
02:38:13 <merijn> Cale: You can't move those modules without breaking all existing libraries importing them, so the odds of people agreeing to refactor like that is unlikely :)
02:45:07 <arjen-jonathan> dmiles: No, this is just explicit type abstraction a la System F, which is not dependently typed.
02:45:21 <arjen-jonathan> uh, sorry, dminuoso 
02:47:44 <dminuoso> arjen-jonathan: Well, if its just that then forall does introduce them sort of. You can capture them with @ in the value level.
02:48:08 * hackage cached 0.1.0.0 - Cache values to disk.  https://hackage.haskell.org/package/cached-0.1.0.0 (GuillaumeCherel)
02:48:26 <dminuoso> arjen-jonathan: f :: forall s. ...; f = ... @s ...
02:48:35 <Cale> merijn: I mean, move the actual code, but make it so that the existing module re-exports the stuff from the moved module
02:48:44 <dminuoso> arjen-jonathan: It's not as "direct", but it's there.
02:48:50 <Cale> merijn: (and potentially the other new stuff you're adding underneath there)
02:49:36 <merijn> Cale: The stuff I wanna add is unrelated to the sorting algorithms (I want things like sliding windows, aggregations, Fisher-Yates shuffle, etc.)
02:50:00 <Cale> sure, I'm just thinking that Data.Vector.Algorithms can be an aggregation module
02:50:16 <Cale> and then you can make a Data.Vector.Algorithms.Sorting which has the sorting functions
02:50:39 <Cale> and Data.Vector.Algorithms.Window
02:50:40 <dminuoso> arjen-jonathan: GHC just infers these type applications automatically. But if you ever want to take the driving seat and manually apply types, you can do that with TypeApplications.
02:50:41 <Cale> etc. etc.
02:51:09 <Cale> and Data.Vector.Algorithms will just re-export everything, and existing packages will remain relatively happy
02:51:26 <Cale> (unless you trample on a name and they imported unqualified)
02:51:28 <dminuoso> arjen-jonathan: So the "System F nature" can be exposed completely if you want.
02:51:43 <merijn> Cale: It can't re-export everything, though. Because all the sorts use the same names :)
02:52:25 <Cale> oh, what?
02:52:38 * hackage BlogLiterately-diagrams 0.2.1 - Include images in blog posts with inline diagrams code  https://hackage.haskell.org/package/BlogLiterately-diagrams-0.2.1 (BrentYorgey)
02:52:39 <Cale> ah, I see
02:52:42 <merijn> Cale: They all use sort, sortBy, etc.
02:52:52 <Cale> They're all immediate submodules
02:52:58 <Cale> Yeah, that's annoying
02:53:12 <Cale> dolio: pls
02:53:24 <Cale> :D
02:54:43 <arjen-jonathan> dminuoso: cool, didn't know about that extension, thanks
04:16:24 <Digit> it strikes me there's no open source libre f-zero alike game.  and i wonder... how well that could be made in haskell.  
04:16:44 <tdammers> are you sure it doesn't exist? or have you just not found it?
04:16:55 <tdammers> in any case, I guess it should be fairly doable in Haskell
04:17:22 <tdammers> mode-7 emulation entirely on a consumer-grade CPU has been perfectly feasible for at least a decade
04:17:28 <Digit> well, https://alternativeto.net/browse/search?q=f-zero my search was not that extensive.   fast moving simple vectors, seems doable.
04:17:50 <tdammers> and f-zero doesn't require a lot of allocation activity and the like, so Haskell's GC is probably not going to be prohibitive
04:18:22 <tdammers> instead of emulating mode-7 properly, you could also just cheat and use opengl
04:18:43 <tdammers> one huge quad for the ground, and then one billboarding sprite for each item and car
04:18:52 <tdammers> and then a few more for effects
04:20:00 <__monty__> It could be a cool series of videos, like what puffnfresh's doing with sonic 2.
04:21:08 <tdammers> now if only I didn't have several dozen side projects going nowhere already, I'd dive right in
04:21:52 <__monty__> Ah, the old Zeno's Side projects ; )
04:22:06 <Digit> ah.  n there i thought my lack of familiarity/skill/aptitude would be my limiting factor.  likewise already spread too thin over too many projects.
04:23:33 <tdammers> it's worse than Zeno's Paradox, because it is multi-dimensional
04:23:58 <tdammers> at least Achilles only suffers along one dimension; my side projects lead to spin-offs, detours, and library development
04:24:34 <__monty__> It's side projects all the way down, and to the sides, and up?
04:24:58 <hpc> tdammers: i think you're being a little... hyperbolic :D
04:27:03 <tdammers> step 1: decide to make an F-Zero clone. step 2: notice that this requires some sort of 3D framework. decide to make that. step 3: notice that your 3D framework needs some sort of resource manager. decide to make that into a library. step 4: decide that your freshly-minted library needs a website. step 5: observe that all tools for building project websites suck; decide to make a better one. step 6: notice
04:27:05 <tdammers> that you will need an HTML template engine. so build that. step 7: your HTML template engine accidentally turns into a turing-complete scripting language. your desire to compile it down to Haskell, PHP, or JavaScript, grows. step 8: observe that in order to compile your highly dynamic template language, you need a novel kind of type checker in order to make is somewhat performant. so start working on that.
04:27:43 <tdammers> so we went from "clone a simple game from the late 1980s" to "let's build a type checker for a dynamic language" in 8 simple and perfectly logical steps
04:28:00 <hc> :)
04:28:37 <hc> tdammers: didn't read the backlog much; have you got a link to your project?
04:29:01 <tdammers> hc: which one of them? :D
04:29:07 <hc> the type checker for a dynamic language
04:29:16 <tdammers> oh, right
04:29:54 <tdammers> https://ginger.tobiasdammers.nl/ <- is the language in question; the typechecker hasn't made any progress since zurihac 2018, but maybe I'll muster the courage to pick it back up
04:30:03 <hc> thanks!
04:30:34 <tdammers> https://github.com/tdammers/ginger/tree/wip/const-analysis is where the type-checker stuff lives, IIRC
04:31:13 <tdammers> main goal is not a full type check, because the language is too dynamic for that; instead, what I want out of it is to just infer certain properties of certain values and expressions that allow me to optimize more aggressively
04:31:20 <hc> ah ok
04:31:41 <tdammers> for example, knowing that a certain key always exists in a dictionary (or never exists) allows me to skip some checks
04:31:55 <hc> I am interested in type- (or otherwise) checking dynamic languages, so I am curious mainly about any new ideas you might have there
04:31:56 <tdammers> or knowing that something is always going to be an integer, I can unbox it
04:32:30 <tdammers> I think the main idea behind this is that of, hmm, not sure how to call it, "partial type checking", or maybe "conditional" or "speculative" type checking
04:33:00 <tdammers> that is, I want to be able to encode things in the type system like "if x exposes property A, then the expression e(x) exposes property B"
04:33:13 <hc> interesting
04:33:18 <hc> I'll have a closer look at your project
04:33:31 <tdammers> for example, "f(x) is a pure expression iff x is a pure expression"
04:33:55 <hexagoxel> tdammers: the term is "gradual typing" i believe
04:34:22 <tdammers> hexagoxel: I thought that referred to having only part of your program typed, leaving other parts un/uni-typed
04:35:46 <tdammers> maybe a better example is map(f, [1,2,3]) - without knowing the type of f, we cannot fully infer or check the type of the entire expression; but in Ginger, f may be injected from the host application, so its type can be anything
04:36:40 <tdammers> and because it is possible to even override built-in functions and variables from outside, and even most operators, there are very very few things of which we can infer meaningful types at compile time
04:37:01 <tdammers> 1 + 2 may be pure, or it may not, depending on whether the host application overrides the + operator
04:37:49 <tdammers> but we can still make useful statements about this expression, as long as we qualify them: as long as the + operator is pure, the expression 1 + 2 is going to be pure and constant
04:38:51 <tdammers> likewise, assuming that we have the complete definition of map() at hand, without any injectable dependencies, then we still can't say whether map(f, [1,2,3]) is pure; but we can say that if f is pure, so is map(f, [1,2,3])
04:39:55 <tdammers> so the idea for this type checker is to infer and check such properties in a conditional way; then the output of the type inference is not "these are the types of your expressions", but rather, "these are the properties of the type of your expressions under these conditions"
04:40:40 <tdammers> and then from there, I can make the host application tell me which conditions are met, insert that information into the type inference output, and infer optimization opportunities from that
04:40:45 <tdammers> that's the grand plan, anyway
04:48:07 <__monty__> tdammers: Sounds like contracts, no?
04:50:18 <__monty__> Cabal curl cert chaos: http://ix.io/1CCv Help?
04:50:42 <tdammers> __monty__: somewhat, yes
04:52:52 <__monty__> Ah, the solution was button mashing.
05:02:07 * hackage reanimate-svg 0.8.0.0 - SVG file loader and serializer  https://hackage.haskell.org/package/reanimate-svg-0.8.0.0 (DavidHimmelstrup)
05:11:02 <pacak> Anyone uses haskell ide engine? How do I get it to add imports?
05:14:32 <__monty__> Hmm, I figure writing a test to see whether reading a float after showing it would be easy but apparently it's not: http://ix.io/1CCF
05:14:48 <__monty__> Shouldn't readFloat work for any valid float?
05:14:54 <__monty__> At least.
05:15:44 <merijn> __monty__: The show instance for float isn't exact
05:16:05 <merijn> __monty__: (de)serialising floats via pretty printing like show is not safe
05:16:14 <merijn> > show 0.3
05:16:16 <lambdabot>  "0.3"
05:16:29 <merijn> That's not right, because Double can't correctly represent 0.3
05:16:46 <__monty__> And this holds for showFloat too?
05:16:47 <merijn> > show (0.1 + 0.2)
05:16:49 <lambdabot>  "0.30000000000000004"
05:17:01 <lemmih> __monty__: Which 'readFloat' is this?
05:17:12 <__monty__> The one from Numeric
05:17:17 <merijn> __monty__: There's exactly one way to safely/consistently serialise/deserialise floats via String
05:17:27 <merijn> __monty__: That's via floating point hex syntax
05:17:48 <merijn> __monty__: But, Numeric is currently missing a function to read those back in (a MR is in progress)
05:18:04 <merijn> __monty__: https://gitlab.haskell.org/ghc/ghc/merge_requests/268
05:18:07 <__monty__> merijn: I figured I'd write a test for regular floats first to be more certain of my test for HexFloats : )
05:18:15 <merijn> __monty__: Ah
05:18:26 <merijn> __monty__: Yeah, no, that's not going to work :)
05:18:31 <lemmih> __monty__: That one doesn't read any negative floats, I think.
05:18:38 <tdammers> that approach is kind of finicky in that it requires a reliable binary representation of your floats on both ends - which is typically a given, but that's a happy little accident more than anything
05:18:39 <merijn> __monty__: That is, in fact, why I needed HexFloat reading in the first place :)
05:19:00 <merijn> tdammers: Hmm?
05:19:01 <lemmih> __monty__: readFloat "-1" = []
05:19:13 <merijn> tdammers: HexFloat does *not* rely on same representation of floats
05:19:31 <merijn> tdammers: It is explicitly defined as a portable string based representation of IEEE-754 floats
05:19:34 <__monty__> lemmih: Hmm, interesting let's see if positive floats do always roundtrip.
05:19:37 <tdammers> I mean in general. you need a well-defined binary (or hexadecimal) encoding of floats
05:19:41 <lemmih> __monty__: Maybe you want: readSigned readFloat
05:19:51 <merijn> tdammers: HexFloats refers to a specfic well-defined format
05:19:53 <tdammers> yes
05:19:58 <tdammers> right
05:21:10 <merijn> __monty__: btw, you might wanna drop in #numerical-haskell
05:21:26 <merijn> __monty__: carter and several other people familiar with IEEE-754 are there
05:23:54 <akersof> hi all, i have a little question, about auxilliary functions that help to make tail recursive function and pattern matching
05:24:03 <akersof> https://gist.github.com/akersof/851dd0c2aec54cd0c319e50c6544acd8#file-ex-hs in this code are the line 2 and 3 needed?
05:25:06 <lemmih> akersof: I think it's fine (modulo the typo, of course).
05:25:49 <akersof> lemmih: indeed there is a typo error. These lines are no needed
05:25:57 <lemmih> akersof: Oh, hm. I'd omit line 4.
05:25:59 <slaterr> akersof, guarded recursion is preferred over tail recursion in functions like yours
05:26:37 <akersof> slaterr: humm why do y ou mean by guarded recursion ?
05:26:42 <slaterr> @src take
05:26:43 <lambdabot> take n _      | n <= 0 = []
05:26:43 <lambdabot> take _ []              = []
05:26:43 <lambdabot> take n (x:xs)          = x : take (n-1) xs
05:27:15 <slaterr> > take 10 [1..]
05:27:17 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
05:27:22 <slaterr> this won't work with your function
05:27:30 <__monty__> lemmih: Seems like you hit the nail on the head in this case. Though I can't rule out merijn's point about show pretty printing.
05:27:35 <akersof> slaterr: ok, so i use tail recursion for efficiency in fact
05:28:04 <Rembane> akersof: Can't you just inline the go-function? 
05:28:19 <akersof> i learnt this from lisp, tail recursive function are "more efficient" because we passed the final result over the recursive call so.. 
05:28:45 <akersof> Rembane: i would like if i know how to do this :), i am still a beginner
05:28:48 <__monty__> Rembane: Well, worker-wrapper is a common optimization in haskell, no?
05:29:17 <slaterr> akersof, but it isn't any more efficient with function like yours. it is actually less efficient. and, in the line I gave to lambdabot, your function will consume all the memory and then crash the program
05:29:18 <__monty__> Doesn't haskell turn any recursive function into a tail recursive function though?
05:29:29 <merijn> akersof: Tail recursion is emphasised in Lisp/Scheme because tail call optimisation avoids increasing the call stack every recursion and running out of call stack
05:29:41 <merijn> akersof: However, GHC Haskell doesn't *have* a callstack, so that's not a concern
05:29:55 <merijn> __monty__: Yes, no, it depends on your point of view :)
05:30:08 <akersof> merijn: ohh, i am happy to read this
05:30:35 <merijn> __monty__: STG is a very CPS style representation, so you could argue every function call is a tail call, or you could argue none of them are because there is no traditional "function calls"
05:30:46 <Rembane> __monty__: I wouldn't do anything in Haskell to make it faster until I see a need for it. 
05:30:51 <akersof> so i should just stick to normal recursion ?
05:31:02 <merijn> akersof: In most case, probably, yes
05:31:14 <Rembane> akersof: Use the style that you think is the most clear one or the prettiest one. 
05:32:30 <WilliamHamilton[> hi, I have a question about C FFI: I'd like to update a library which contains some slightly outdated bindings for a C API, what tools do I have to help me in understanding which functions in the C API are not in my bindings?
05:32:38 <akersof> thx all
05:33:15 <__monty__> Rembane: But don't we all aspire to be kmett? He often writes worker-wrapper style from the get-go : )
05:34:10 <akersof> merijn: i am curious to read more about haskell that don't *have* a call stack
05:34:29 <akersof> if it doesn't dive too much into compiler theory ofc :)
05:34:51 <tdammers> there's not much theory there, really; it's just that Haskell's execution model doesn't really feature "function calls"
05:34:55 <tdammers> and without calls, there's no call stack
05:34:57 <Rembane> __monty__: That is indeed true. But why do you aspire to be him? :)
05:35:08 <akersof> tdammers: indeed
05:35:21 <dminuoso> akersof: Haskell's evaluation is closer to a graph reduction machine.
05:36:15 <akersof> dminuoso: ok sound logic for me
05:36:37 <__monty__> Rembane: So people will want to aspire to be me : >
05:37:10 <Rembane> __monty__: Watch him become a god, his metal brain corrodes?
05:38:55 <dminuoso> akersof: There's a nice and approachable paper by SPJ about the STG machine that explains how Haskell's evaluation model is implemented in GHC. Perfectly readable for non-experts: https://www.microsoft.com/en-us/research/wp-content/uploads/1992/04/spineless-tagless-gmachine.pdf
05:39:09 <dminuoso> akersof: I'd say its one of the "must reads" for Haskell programmers.
05:39:44 <maerwald> dminuoso: why? what does it give you in daily work?
05:40:27 <tdammers> depends on what your daily work entails
05:41:04 <tdammers> but I would agree that for many Haskell programmers, the implementation details can be safely ignored, as long as you understand the general concepts
05:41:16 <akersof> dminuoso: thx i will read it
05:41:47 <slaterr> isn't ghc using stack for pattern matching?
05:43:34 <dminuoso> maerwald: I consider a working knowledge of how GHC executes your code to be very beneficial.
05:44:07 <maerwald> For regular programming work?
05:45:22 <tdammers> dminuoso: how it executes code, yes; how exactly that is implemented in GHC, no, not universally.
05:45:29 <akersof> maerwald: understanding your tools is always good i think
05:45:44 <maerwald> akersof: well, then you could argue start by reading the entire kernel code :P
05:46:02 <akersof> maerwald: i did, but just some part ofc
05:46:07 <maerwald> Time is precious
05:46:08 <Taneb> maerwald: only once you've finished reading documentation on x86-64
05:46:19 <tdammers> you need a mental model of how your code gets run that is accurate enough to make correct predictions. but that doesn't require understanding all of GHC.
05:46:31 <Taneb> I'm of the view that all learning is useful so learn what you find interesting first
05:46:32 <e> but hold up! how would the kernel work without a cpu? how would the cpu work without the field effect? how would the field effect work without quantum electrodynamics? ...
05:46:38 * hackage pipes-ordered-zip 1.0.0.1 - merge two ordered Producers into a new Producer  https://hackage.haskell.org/package/pipes-ordered-zip-1.0.0.1 (stephan_schiffels)
05:46:45 <maerwald> Just because I enjoy a paper doesn't mean I think it's a must read. I liked the paper about economical interpretation of attack surface in software systems
05:46:53 <maerwald> But I think it's rather useless for most programmers
05:47:05 <e> in more seriousness: meh, it's kind of aggravating that you bump into implementation details in really simple cases
05:47:11 <akersof> maerwald: i think you can do this because 1) this is your hobby, 2) an investissement for the future
05:47:15 <dminuoso> maerwald: At least the first part of the paper is not very technical - it gives a very rough description of the STG which is really useful to learn what thunks are and how they work.
05:47:22 <e> like, i don't understand why foldr is bad and the monomorphism restriction is good, and i don't want to understand
05:47:25 <dminuoso> maerwald: It explains how memoization/sharing works.
05:47:27 <e> they feel like concerns of another layer of abstraction
05:47:36 <maerwald> dminuoso: ok, maybe I'll look at that
05:47:37 <akersof> maerwald: but indeed if it is too complicated probably doesn't worth to waste too much time into it
05:47:40 <maerwald> akersof: hobby? :>
05:48:21 <dminuoso> akersof: Just read as much as you can, the entire first part should be approachable.
05:48:32 <dminuoso> akersof: The rest is very technical though.
05:48:48 <__monty__> e: foldr's not bad.
05:48:58 <akersof> dminuoso: sure 
05:49:24 <maerwald> tdammers: turns out evaluation isn't all that easy to reason about, indeed
05:49:33 <dminuoso> e: well some abstractions cant be hidden away.
05:49:39 <maerwald> so there goes one of the biggest selling points out of the window ;P
05:49:44 <e> __monty__: however you want to describe the problem with it, the point is that it quickly involves diving into mechanical details
05:50:15 <tdammers> maerwald: I think there is a tendency towards gross exaggeration and black-and-white arguing in this area
05:50:35 <tdammers> evaluation isn't easy to reason about, but it's still easier than evaluation intertwined with execution
05:51:01 <tdammers> just because the equational reasoning approach doesn't give you 100% certainty doesn't mean it's as bad as the alternatives
05:51:04 <maerwald> tdammers: I would rather debug memory consumption in C project, than a haskell one, where you have to figure out what is happening, what is lazy, etc
05:51:20 <maerwald> turns out it's more challenging in haskell imo
05:51:23 <tdammers> yes. that's a price you pay
05:51:32 <maerwald> ixset for example
05:51:44 <__monty__> e: I didn't mean anything deep. Just that foldl's the bad one. foldl that is not foldl'.
05:52:09 <akersof> maerwald: so the debuging process in big haskell program can be a pain ?
05:52:13 <tdammers> however, in C you have to do that stuff all the time, and you have to do a lot of other equally annoying reasoning all the time too, whereas in haskell, the number of times you have to actually figure out memory leaks and such is fairly small usually
05:52:27 <e> __monty__: i'm given to understand that foldl makes lots of thunks, whereas foldr makes lots of irreducible expressions, which are two things i don't want to think about
05:52:43 <maerwald> akersof: yes and tooling isn't comparable to C
05:53:33 <maerwald> precisely because people don't do it all the time
05:53:35 <__monty__> e: Not even sure what the latter means.
05:53:35 <e> tdammers: i suppose worrying about implementation details feels like part and parcel of C
05:53:38 <maerwald> but when you do, good luck
05:53:52 <e> whereas in haskell it's somehow jarring
05:53:55 <dminuoso> e: for example not many people know what cache colors are, but writing cache color aware code can be such a huge performance gain..
05:54:13 <tdammers> e: yeah. C is implementation details through and through, Haskell successfully shields you from many of them in many situations - just not at all times, and not from all details
05:54:25 <dminuoso> thats CPU details that general purpose implementation cant just "use"
05:54:49 <e> tdammers: there's also the fact that C's execution model is exceedingly simple (if not *quite* as simple as many people think)
05:55:15 <tdammers> well yes; C's execution model is roughly "like, you know, a PDP-11"
05:55:41 <dminuoso> e | __monty__: i'm given to understand that foldl makes lots of thunks, whereas foldr makes lots of irreducible expressions, which are two things i don't want to think about 
05:55:45 <dminuoso> You cant just pretend that code is for free.
05:56:42 <dminuoso> Now I know there's plenty of programmers who strongly believe that "performance concerns" are just compiler author problems...
05:56:44 <tdammers> dminuoso: no, but you can rely on the fact that in a decent high-level programming language, naive code will usually perform adequately, thus allowing you to skip the "reason about implementation details" part for large parts of your application
05:57:19 <tdammers> the purpose is not to *never* have to think about that stuff; just to *rarely* have to do it
05:57:45 <dminuoso> tdammers: But that's just a specific point of view. If I was a haskell programmer all my live, I wouldn't want to think that I couldn't make infinite vectors in C++ either.
05:57:50 <e> yeah, it wouldn't bother me if the implementation details only leaked in when you wanted to write high-performance stuff
05:58:02 <dminuoso> I'd argue "look implementation, just do the reasonable thing and make this vector infinitely large without cost"
05:58:56 <dminuoso> And in the C world you constantly have to live with such a small call stack size that any attempt at recursion will very rapidly overflow your call stack.
05:59:05 <e> no you don't
05:59:24 <maerwald> tdammers: the difference between naive implementation and performant implementation tends to be huge in haskell though, ime
05:59:41 <akersof> @src drop
05:59:41 <lambdabot> drop n xs     | n <= 0 = xs
05:59:42 <lambdabot> drop _ []              = []
05:59:42 <lambdabot> drop n (_:xs)          = drop (n-1) xs
05:59:44 <dminuoso> e: What is the default stack size on the majority of linux machines?
05:59:54 <e> no idea. i set mine to unlimited
06:00:22 <opqdonut> 8k or so?
06:00:28 <dminuoso> e: But isn't that "having to deal with internal details" already?
06:00:41 <tdammers> maerwald: idk about you, but the code I write *usually* performs adequately. 
06:00:46 <dminuoso> e: And if you want to write portable code, you need to expect to run it on 1-8MiB stack size.
06:00:49 <e> as i said, dealing with implementation details feels pretty normal when you're writing C
06:00:55 <dminuoso> Heh
06:00:56 <maerwald> tdammers: haha
06:00:56 <e> megabytes? what world do you live in?
06:01:24 <opqdonut> seems like the linux default is 2 megs these days?
06:01:28 <opqdonut> wow
06:01:31 <maerwald> maybe it's because when I write C or rust, half of my concerns are already on performance anyway 
06:01:34 <dminuoso> opqdonut: I think Ubuntu ships with 8MiB stacks.
06:01:47 <e> i've spent half-day-long sessions arguing to be allowed to increase my stack size from 512B to 1K
06:01:54 <dminuoso> Haha.
06:01:57 <opqdonut> dminuoso: 8M is the "soft limit", 2M is the initial size
06:01:59 <tdammers> I'm more interested in maintainability, understandability, clean design, and all that
06:02:02 <dminuoso> opqdonut: Ohh right.
06:02:02 <opqdonut> I have no idea how these actually work
06:02:11 <dminuoso> Neither do I.
06:02:24 <dminuoso> I just expect linux to "do the right thing"
06:02:30 <dminuoso> Sadly it doesn't much.
06:02:40 <e> the soft limit is the working limit, the hard limit is what you can raise it to without being privileged
06:03:35 <maerwald> tdammers: I'd rather not have intero crash my laptop though
06:03:57 <maerwald> at which point I don't really care about clean design anymore ;P
06:03:59 <e> anyway, the point is that C is patently terrible at hiding implementation details, and no C programmer expects that
06:04:10 <e> heck, it's *why* people write so much stuff in C
06:04:27 <dminuoso> e: And yet its intermingled with so many bizarre rules on the abstract machine..
06:04:31 <e> in haskell, otoh, i really don't want to think about exactly what the implementation is doing
06:04:37 <maerwald> or GHC spike up my memory up to 12gb ram for HTTP package
06:04:42 <dminuoso> e: C gives you the feeling of "almost bare metal" while actually having very strange rules.
06:04:49 <dminuoso> Point in case: strict aliasing rules.
06:05:07 <dminuoso> Case in point even! But Im not a native speaker.
06:06:28 <e> dminuoso: i would rather not talk about C in #haskell. i do know most of the spec, and i'm aware of a great many weird corners, but in general it's a langauge whose main advantage is its... i saw some author call it "porosity"
06:07:43 <e> people write C because they want the implementation to leak through so severely you can barely tell what's C and what's implementation
06:08:05 <e> whereas at least in my case, i want the exact opposite in haskell, so i don't think comparing to C is super useful
06:08:41 <maerwald> with all the language extensions you pretty much got your porosity already no? ;)
06:10:37 * hackage sequence-formats 1.1.4.1 - A package with basic parsing utilities for several Bioinformatic data formats.  https://hackage.haskell.org/package/sequence-formats-1.1.4.1 (stephan_schiffels)
06:14:07 <tdammers> maerwald: GHC spiking to 12 GB RAM usage for some packages is, AFAIK, due to sacrificing clean design here and there in order to make the average case performant, or even just possible
06:14:17 <tdammers> maerwald: at least that's my experience with GHC development so far
06:21:37 * hackage tonatona-servant 0.1.0.2 - tonatona plugin for servant.  https://hackage.haskell.org/package/tonatona-servant-0.1.0.2 (arowM)
06:23:49 <__monty__> Hmm, anyone have good advice on spotting fraudulent github accounts?
06:28:46 <merijn> __monty__: Fraudulent how?
06:29:36 <merijn> e: The problem is that you can't safely let those details leak through C, doing so in Haskell is honestly much easier :)
06:30:50 <__monty__> Do you remember the commotion about the npm package that was taken over by a fake github account introduced a vulnerability then patched it to hide things? Since then I've had like 3 github users follow me for seemingly no reason. The accounts often have only a couple forked repos, lots of starred projects and very little activity.
06:31:07 <e> that might just be what those people are like
06:31:18 <__monty__> I suspect they follow people at random as well and I don't want to lend credibility to such accounts by having them follow me.
06:31:53 <__monty__> I also don't want to report real users that actually want to follow my work though : )
06:32:24 <e> merijn: i don't really know why we started talking about C, and i still don't want to do it. i know how to handle C and i don't think my use cases for C have any intersection with my uses of haskell
06:33:10 <merijn> __monty__: Oh, I don't even pay attention to accounts on github in that sense
06:33:40 <e> i'm just feeling a bit annoyed that i can't understand things that feel like they should be simple without understanding an enormously complicated evaluation model
06:34:32 <jhrcek> Could someone give me an example of using recursion schemes to build a recursive structure in monadic context? Say I have a Tree data structure and want to build it by traversing filesystem..?
06:35:02 <jhrcek> *traversing directory tree
06:35:05 <merijn> e: I missed the original context, what was the issue?
06:35:40 <e> merijn: i don't understand why the monomorphism restriction and one of the folds being bad are things
06:36:14 <dminuoso> e: The MMR is done so users dont get frustrated with very poor performance in many cases.
06:36:20 <dminuoso> It's exactly what you ask for.
06:36:26 <merijn> e: monomorphism restriction is the only sane alternative to a tricky ambiguous situations
06:36:30 <e> so i've heard
06:37:05 <merijn> e: foldl not being foldl' is historical accident combined with stubborn conservativism, worried about maybe potentially breaking something
06:37:47 <e> but i don't understand why it should have worse performance
06:38:00 <dminuoso> e: That's the price for lazyness.
06:38:02 <opqdonut> with modern ghc it doesn't
06:38:06 <maerwald> merijn: which is weird, because the rest of the ecosystem has the opposite attitude, haha (wrt stubborn conservativism)
06:38:08 <merijn> e: The MMR comes from the following, suppose I write "foo = [expensiveComputation x | x <- [1..1000]]"
06:38:15 <merijn> dminuoso: That's really not the issue
06:38:18 <opqdonut> strictness analysis handles foldl just fine these days ISTR
06:39:11 <merijn> e: Now, "foo" being a value you'd assume "expensiveComputation" is only evaluated (max) 1000 times, yes? Since the list sticks around after being evaluated
06:39:39 <e> merijn: okay. so if expensiveComputation :: ... -> a is polymorphic in a, it can't just be evaluated once. that makes sense
06:40:07 <merijn> e: Well, it could, but you'd have to keep a copy of a 1000 element list for each possible type 'a'
06:40:19 <merijn> e: Which is clearly undesirable, so you have to reevaluate every time
06:40:24 <dminuoso> merijn: I think it was a miscommunication. It seemed as if e switched to foldl/foldl'
06:40:52 <e> i'm equally frustrated at not understanding both of them
06:41:03 <e> if i understand one, i will be half as frustrated. or twice as happy, if we want to be optimistic
06:41:21 <merijn> e: The MMR basically says "if I have something that looks like a value" (aka there are no arguments on the left hand side of =" we monomorphise this value to a single specific type, so we can guarantee we evaluate just once
06:42:00 <merijn> e: On the assumption that you, as programmer, expect things that look like values (as opposed to functions) to only be evaluated once
06:42:31 <merijn> e: Now, clearly if you try and use "foo" as both [Int] and [Double] this helpful optimisation becomes impossible
06:42:43 <e> yeah
06:43:38 <merijn> e: There are two solutions: 1) We never monomorphise, if someone was expecting single evaluation they get tricky to debug performance degradation at runtime due to repeat evaluation, or 2) we monomorphise to a single type and if people use the value as more than 1 different type we fail at compile time with an explicit error
06:44:16 <merijn> e: To me, option 2, having an obvious, simple, compile time error as infinitely preferable to 1
06:46:02 <merijn> e: Especially since the MMR is trivial to fix/workaround since it only applies to top-level "values" (i.e. no arguments on left hand side) that have no explicit type signature
06:46:06 <e> i think i agree with you, but at the same time it feels a bit weird to have the language take the initiative and constrain types
06:46:37 <e> (also because it breaks the un-distinction between values and zero-argument functions)
06:46:52 <e> not that i can think of a better solution :)
06:47:34 <merijn> e: That's basically the reason for the MMR, after lots of hard thinking, no one has come up with a better solution :)
06:48:53 <dminuoso> merijn: As I have just learned recently, the MMR does not just apply to top level bindings.
06:48:58 <dminuoso> merijn: It applies to any declaration group.
06:49:15 <dminuoso> (And I still wonder why I also believed that it only applied to top level)
06:50:13 <__monty__> merijn: But others like that original js maintainer do. And I don't wanna help fake accounts gain credibility through passivity.
06:50:45 <dminuoso> merijn: also another fun fact: even with an explicit type annotation you can be subject to MMR. =P
06:50:53 <merijn> __monty__: tbh, if your tooling assumes arbitrary github repos are trustworthy you have bigger problems...
06:51:11 <vaibhavsagar> can I set a flag to be enabled on a particular OS?
06:51:36 <Solonarv> a cabal flag, you mean?
06:51:45 <vaibhavsagar> yup
06:52:00 <vaibhavsagar> I want to do a CPP thing, and I want a flag for it
06:52:13 <Solonarv> should be possible using something like if os(windows): -- enable flag
06:52:14 <vaibhavsagar> and I would like this flag to be automatically set on Windows
06:52:27 <Solonarv> but you can also check for the OS directly in the CPP stuff
06:52:52 <Solonarv> iirc it's #ifdef mingw32_HOST_OS
06:53:07 <merijn> vaibhavsagar: Don't use a cabal flag for that, you can just have OS based conditionals directly in the cabal description
06:53:25 <gentauro> does anybody know if `ghcjs
06:53:36 <gentauro> can compile to `SVG`?
06:53:41 <__monty__> merijn: I agree wholly. But this is like aiding spammers by not taking action against them.
06:53:50 <vaibhavsagar> merijn: I want to be able to set the flag separately as well
06:53:56 <gentauro> (SVG usually contain some JS iirc)
06:54:24 <dminuoso> % f :: Num a => a -> a -> a; g :: Num a => a -> a -> a; (f,g) = ((+),(-))
06:54:25 <yahb> dminuoso: ; <interactive>:167:1: error: Overloaded signature conflicts with monomorphism restriction f :: forall a. Num a => a -> a -> a
06:54:56 <merijn> vaibhavsagar: Then do "if os(windows) || flag(foo)"
06:56:22 <merijn> gentauro: Eh, I would certainly dispute the "usually" part of that
06:56:33 <vaibhavsagar> that seems harder to implement though
06:56:42 <merijn> vaibhavsagar: Why?
06:56:44 <vaibhavsagar> because I was planning on having some CPP
06:56:55 <merijn> vaibhavsagar: Like...that line is literally everything
06:57:09 <vaibhavsagar> if I had a #define
06:57:35 <merijn> vaibhavsagar: You can just do "ghc-options: -DFOO" to define FOO if either Windows or that flag is true
06:57:35 <vaibhavsagar> then I would need to somehow set that if the OS is windows
06:57:47 <vaibhavsagar> oh, I see
06:57:50 <vaibhavsagar> interesting
06:58:07 <merijn> vaibhavsagar: Within an if block in cabal file you can add arbitrary extra flags/arguments to your config
06:58:15 <vaibhavsagar> thanks!
07:07:49 <gentauro> merijn: Why? Many `svg` on websites have `JS` for interaction
07:07:58 <gentauro> I'm looking to `mimic` something like that :)
07:08:05 <gentauro> (without using `elm` ofc) ;)
07:08:15 <merijn> gentauro: Yes, but saying that describes "most" svg's is stretching it
07:08:39 <gentauro> merijn: `semantics` :P
07:09:48 <Solonarv> afaik ghcjs just spits out a blob of js, surely you can just shove that into an svg
07:10:12 <gentauro> Solonarv: https://package.elm-lang.org/packages/elm-lang/svg/latest/
07:10:19 <gentauro> I have used that lib before
07:10:35 <merijn> Anyone know what sort of second argument https://hackage.haskell.org/package/vector-sized-1.2.0.0/docs/Data-Vector-Unboxed-Sized.html#v:knownLength expects?
07:12:27 <gentauro> Solonarv: but yes, it's compiled to `js` which actually makes the `svg` onload
07:12:42 <gentauro> that's why I asked if there was a `svg` lib for `ghcjs`
07:12:44 <gentauro> :)
07:14:59 <Solonarv> merijn: safeIndex vec i = knownLength vec (fmap (index vec) packFinite i)
07:15:01 <Solonarv> is an example
07:16:47 <Solonarv> or: rtLength vec = knownLength vec (length vec)
07:21:08 * hackage google-server-api 0.3.1.1 - Google APIs for server to server applications  https://hackage.haskell.org/package/google-server-api-0.3.1.1 (arowM)
07:22:38 * hackage tonatona-google-server-api 0.1.2.0 - tonatona plugin for google-server-api  https://hackage.haskell.org/package/tonatona-google-server-api-0.1.2.0 (arowM)
07:30:35 <asheshambasta> If I'm using stack, can I load my test suite in the REPL? I'm running stack ghci core:core-test (names are correct), am I missing something? 
07:31:14 <Solonarv> try being even more explicit: stack repl core:test:core-test
07:32:56 <asheshambasta> doesn't work, stack then complains it cannot find my dir. 
07:34:48 <nSeagull> Is there a way of disabling name mangling when writing a GHC preprocessor? So instead of outputting something like `ghc20989_0/ghc_13.hspp` it outputs something set by the preprocessor?
07:41:40 <fr33domlover> When launching a tiny web server in a test suite (say, of an HTTP client), do I just pick some constant port number (like 12345 or whatever)? is that future proof, like, if hackage/stackage/whatever runs the tests etc.?
07:41:54 <asheshambasta> its `stack ghci --test` from what I see 
07:58:26 <merijn> Ah...rats
07:58:50 <Solonarv> hm?
07:59:15 <merijn> My own bitpacking code works fine, but I forgot I also need to redo my ByteString -> Vector Bit code to work "the right way"
08:20:38 <merijn> argh...this will end up either super inefficient or super hard to write >.<
08:29:01 <vaibhavsagar> merijn: array correctly stores unboxed booleans as a bitvector
08:29:21 <merijn> vaibhavsagar: So do unboxed Vectors if you use the Unbox instance from bitvec
08:29:31 <merijn> vaibhavsagar: The problem is that it stores them in the wrong order
08:30:10 <merijn> vaibhavsagar: It uses "bit 0 = least significant bit" while all this networking stuff assumes "bit 0 = most significant bit"
08:30:43 <merijn> vaibhavsagar: So to go from ByteString to a Vector Bit with the right representation I need to invert all bits in every word
08:31:03 <merijn> vaibhavsagar: I was just using fromWords to type pun the ByteString's pointer, but that doesn't work
08:31:13 <sternmull> merijn: If you are talking about little endian vs. big endian then its just byteorder, bitorder is the same
08:31:36 <vaibhavsagar> ooh, I haven't heard of bitvec
08:32:21 <merijn> vaibhavsagar: It's actually super cool
08:32:59 <merijn> vaibhavsagar: Since it just uses the interface from vector it works correctly with other vector wrapping libraries like vector-sized too
08:33:14 <merijn> sternmull: Big endian vs little endian is ALSO a thing, but not what I'm talking about
08:33:37 <merijn> sternmull: Consider this table: https://en.wikipedia.org/wiki/IPv4#Header
08:34:15 <merijn> sternmull: The IPv4 Version is "bit 0 through 3", but the interpretation is that bit 0 == most significant bit
08:34:37 * hackage spline3 1.0.0 - A parallel implementation of the Sorokina/Zeilfelder spline scheme.  https://hackage.haskell.org/package/spline3-1.0.0 (MichaelOrlitzky)
08:34:58 <merijn> Suppose I write version 4 aka 0b0100, in networking the non-zero bit is bit 1
08:35:02 <merijn> However
08:35:11 <sternmull> merijn: Why not just invert your bit indices? Or use appropriate masks?
08:35:16 <merijn> > 0b0100 `testBit` 1
08:35:18 <lambdabot>  error: Variable not in scope: b0100
08:35:30 <merijn> % :set -XBinaryLiterals
08:35:30 <yahb> merijn: 
08:35:39 <merijn> % 0b0100 `testBit 1
08:35:39 <yahb> merijn: ; <interactive>:169:17: error: parse error on input `1'
08:35:43 <merijn> % 0b0100 `testBit` 1
08:35:43 <yahb> merijn: False
08:35:47 <merijn> % 0b0100 `testBit` 3
08:35:47 <yahb> merijn: False
08:35:51 <merijn> % 0b0100 `testBit` 2
08:35:52 <yahb> merijn: True
08:35:59 <gentauro> %:t testBit
08:36:03 <gentauro> % :t testBit
08:36:04 <yahb> gentauro: Bits a => a -> Int -> Bool
08:36:10 <gentauro> % :doc testBit
08:36:10 <yahb> gentauro: ghc: Can't find any documentation for Data.Bits.; This is probably because the module was compiled without '-haddock',; but it's also possible that the module contains no documentation.; Try re-compiling with '-haddock'.
08:36:18 <gentauro> % :d testBit
08:36:18 <yahb> gentauro: ; <no location info>: error: not an expression: `'
08:36:22 <gentauro> % :docs testBit
08:36:23 <yahb> gentauro: unknown command ':docs'; use :? for help.
08:36:26 <gentauro> % :doc testBit
08:36:26 <yahb> gentauro: ghc: Can't find any documentation for Data.Bits.; This is probably because the module was compiled without '-haddock',; but it's also possible that the module contains no documentation.; Try re-compiling with '-haddock'.
08:36:42 <merijn> sternmull: How would I invert the indices starting from a ByteString?
08:37:00 <Solonarv> gentauro: the docs aren't there, asking about them in slightly different ways won't magically make them appear :/
08:37:21 <gentauro> % :GIVE_ME_DOCS !!! testBit
08:37:21 <merijn> sternmull: I mean, I can create a new Vector Bit by looping over every byte and correctly setting each bit, but that's obviously not very fast
08:37:22 <yahb> gentauro: unknown command ':GIVE_ME_DOCS'; use :? for help.
08:37:26 <sternmull> merijn: I did my own little IPv4 stack not so long ago on a little-endian platform and i had no need to swap the bitorder.
08:38:09 <gentauro> > :doc testBit
08:38:12 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
08:38:16 <gentauro> :(
08:38:26 <merijn> sternmull: The problem is that I'm using Vector bit to work with things at a logical level, but the mapping to binary data is different between the actualy raw ByteString and memory representation of Vector Bit
08:38:39 <sternmull> merijn: I used 32bit-words and just shifted and masked the values to get/set the individual fields. I would also expect this to be more efficient than to pretend that you can efficiently address single bits.
08:38:47 <merijn> sternmull: So yes, if you don't want to manipulate bits via a vector then it's fine
08:39:16 <merijn> sternmull: I don't care too much about efficiency, it's just that looping over literally every bit is the other extreme...
08:39:23 <Solonarv> gentauro: lambdabot isn't an interface to ghci, so ghci commands won't work for it in general
08:40:13 <merijn> Solonarv: Even if it was, ":docs" is not a command in ghci (well, maybe in the most recent one, but certainly not mine)
08:40:28 <Solonarv> :doc is though
08:40:38 <merijn> Solonarv: Not in my ghci
08:40:57 <merijn> And lambdabot is unlikely to be GHC-bleeding-edge
08:41:01 <Solonarv> it's very new indeed, but yahb uses the newest version
08:42:37 <merijn> sternmull: The bit mask + shift approach is super annoying to work with
08:43:13 <Solonarv> :doc was added in 8.6.1 and is still experimental
08:43:49 <sternmull> merijn: Its fine if you create a few utility-functions that do the bit operations for you
08:43:59 <merijn> I wonder if I can simply newtype Bit and define a trivial Vector instance that just wraps "Vector Bit" with one that fixes the bit addressing within a byte
08:44:58 <sternmull> and if performance does not matter then you could just extract all the information into a data with explicit fields for all the header-fields.
08:45:37 <merijn> sternmull: I have to construct all sorts of different packets myself, so "high level records" don't help me much
08:45:37 <sternmull> so basically just deserialize the heder into something that is easy to work with
08:46:00 <bah> I installed lambdabot with my stack project
08:46:12 <bah> I don't know where the executable is located though
08:46:12 <merijn> sternmull: I'm building lots of them, I don't need high-performance, but I do need sane way of working with all those fields
08:46:17 <bah> I'm trying to use it with ghci
08:46:20 <bah> tips?
08:46:32 <merijn> sternmull: But it'd help to not be completely stupid about performance :)
08:46:44 <sternmull> merijn: You could use a different data for every protocol you have to support.
08:47:03 <merijn> sternmull: I'd still have to implement the serialisation from high level to bit level
08:47:16 <merijn> sternmull: Which is exactly what I'm using the bit vectors for :p
08:47:42 <Solonarv> bah: 'stack exec <thing you installed>' should do it
08:48:04 <Solonarv> you can make a ghci command for that if you want
08:48:23 <sternmull> merijn: i have no proof but i would expect performance to be pretty stupid if bitvectors don't allow efficient extraction of ranges of bits... don't know if they do
08:49:03 <merijn> sternmull: It does, but as I was saying earlier: It uses a different index interpretation
08:49:15 <sternmull> hm, ok
08:49:20 <merijn> sternmull: It uses "0 = least significant" instead of "0 = most significant"
08:49:32 <sm> bah: ~/.local/bin
08:49:38 <sm> stack install will have told you
08:49:49 <merijn> sternmull: So I'd have to reverse the bits in every word to get the "right" interpretation
08:50:16 <Solonarv> if you're using stack you should probably have ~/.local/bin on your path anyway
08:50:20 <merijn> sternmull: But I think there might be hope
08:50:52 <sternmull> merijn: You could create a utility function that does the bit-index translation
08:51:02 <merijn> sternmull: A quick look around suggest I should be able to wrap it with a custom instance that just changes the offset calculation
08:51:27 <sternmull> thats what i was thinking about
08:56:57 --- mode: ChanServ set +o glguy
08:56:57 --- mode: glguy set +q $~a
09:17:39 <dminuoso> Why do profunctors have Set as their codomain? Couldn't one think of a functor `P : D^op x C -> E` for some category E?
09:17:45 --- mode: glguy set +v dminuoso
09:17:51 <dminuoso> Why do profunctors have Set as their codomain? Couldn't one think of a functor `P : D^op x C -> E` for some category E?
09:18:38 <c_wraith> by "profunctors" do you mean the Profunctor class specifically?
09:18:43 --- mode: glguy set +v c_wraith
09:18:48 <dminuoso> c_wraith: No I mean profunctors in the category theory sense.
09:19:08 <Cale> dminuoso: See "enriched profunctor"
09:19:13 --- mode: glguy set +v Cale
09:19:21 <Cale> dminuoso: See "enriched profunctor"
09:20:27 <MarcelineVQ> I don't think voice mode is even on hehe
09:20:38 <dminuoso> glguy: Either the channel needs an additional modification, or your script is wrongly turned on.
09:25:04 <dminuoso> Cale: Mmm, nlab does not appear to have a concrete definition of enriched profunctor.
09:25:22 <dminuoso> Surely I must be looking at the wrong article.
09:25:44 <Cale> dminuoso: Ah, hmm
09:26:34 <dminuoso> Curiously the only definition I can find, is actually provided by Bartosz Milewski on his blog. This is amusing.
09:26:55 <Cale> dminuoso: It's just the obvious thing
09:27:23 <Cale> Like, the whole motivation behind the definition of profunctor in the first place is "what is this Hom thing?"
09:27:38 <Cale> So the reason it goes to Set is because Hom does
09:28:04 <Cale> But in V-enriched categories, Set is replaced by some other category V
09:28:19 <Cale> and so you'd have some corresponding notion of V-enriched profunctor
09:28:37 <Cale> (or E-enriched in the above :)
09:29:02 <dminuoso> Right. On some level that makes sense. Do you happen to have some reading material on that "motivation" you mentioned?
09:29:34 <dminuoso> I've been trying to wrap my head around profunctors only understanding them half way. My desk is filled with diagrams but Im no closer to an intuition.
09:30:17 <dminuoso> Are you saying that in some way a profunctor is a generalization of the hom functor?
09:32:53 <Solonarv> exactly!
09:32:54 <unyu> dminuoso: I don't think in general the source and target category have to be the same.
09:32:59 --- mode: glguy set +v unyu
09:33:01 <Cale> dminuoso: Well, your Hom functors are the relevant identity arrows
09:33:36 <unyu> dminuoso: I don't think in general the source and target category have to be the same.
09:33:51 <Cale> Haha, everyone's getting tricked by the bot
09:34:01 <unyu> Wait, is it a prank?
09:34:05 <Solonarv> after all C(-, =): C^op x C -> Set is a profunctor
09:34:10 <Cale> It's probably not intended to be
09:34:26 <Cale> But the channel isn't moderated right now, but the bot is accidentally active
09:35:05 <dminuoso> Cale: So the enriched profunctor seems really dead simple. Given an enriched category V equipped with a tensor *.*, then we get V-profunctors from D^op *.* C -> V. This seems simpler.
09:36:07 <Cale> yeah
09:36:18 <Cale> But also less specific
09:37:38 <dminuoso> Cale: I find it interesting that you talk about Hom by the way. Ive been trying to take this from the relation angle that Bartosz is trying to explain (I must have read his article about 10-12 times now), but its just not clicking.
09:39:12 <Cale> The relation angle actually is probably a better direction, given that you immediately have some details about what the mappings ought to look like there.
09:40:54 <Cale> Like, how should we motivate the definition of profunctor composition?
09:42:07 <Cale> http://www.mathematik.tu-darmstadt.de/~streicher/FIBR/DiWo.pdf -- this reference might be useful as well
09:48:38 <unyu> So, in practice, profunctor is just Haskell-ese for “contravariant in the first argument, covariant in the second”?
09:49:23 <c_wraith> yes, it's just one specific bifunctor. a different one than Bifunctor exposes
09:49:50 <c_wraith> it's convenient because (->) is an instance.
09:55:39 <dminuoso> unyu: Well that's the Haskell notion.
09:55:50 <dminuoso> unyu: Just like in Haskell we tend to think of Functor as just Endofunctors acting on Hask
09:58:08 <dminuoso> Cale: So based on the paper I take it that even a regular profunctor is an enriched profunctor where D and C are enriched over Set (using cartesian product as the tensor)
10:00:34 <Cale> dminuoso: An ordinary category is a Set-enriched category
10:00:36 <Cale> and yeah
10:01:36 --- mode: glguy set -vvvv Cale dminuoso c_wraith unyu
10:01:46 <glguy> (I forgot to populate the logged-in users list)
10:10:38 * hackage deque 0.4 - Double-ended queues  https://hackage.haskell.org/package/deque-0.4 (NikitaVolkov)
10:16:59 --- mode: glguy set -q $~a
10:17:37 * hackage deque 0.4.0.1 - Double-ended queues  https://hackage.haskell.org/package/deque-0.4.0.1 (NikitaVolkov)
10:40:34 <WilliamHamilton[> how do you keep your haskell bindings in sync with a changing C API?
10:41:30 <WilliamHamilton[> https://github.com/IagoAbal/haskell-z3/issues is a little behind the C API and I'm trying to understand what's the best way to contribute
10:42:00 <WilliamHamilton[> also, that bindings uses hsc2hs, should I try to use c2hs? Would that make the task easier?
10:45:07 * hackage util 0.1.12.0 - Utilities  https://hackage.haskell.org/package/util-0.1.12.0 (MatthewFarkasDyck)
10:46:38 * hackage reanimate-svg 0.8.1.0 - SVG file loader and serializer  https://hackage.haskell.org/package/reanimate-svg-0.8.1.0 (DavidHimmelstrup)
10:48:54 <bsima> one place where clojure really shines over haskell is when i'm building up a data type through successive steps
10:49:12 <bsima> i haven't figured out a way to cleanly represent the intermediate records in haskell
10:49:31 <bsima> doing "Person1", "Person2" and so on is not great
10:49:45 <bsima> if anyone has advice on this i would be pleased to hear it...
10:50:00 <glguy> Is the correlary to that that Haskell since in not having incomplete record values accidentally created?
10:50:15 <gentauro> bsima: you know that Haskell is actually pretty good to have `partial` types right?
10:50:18 <glguy> shines*
10:50:42 <gentauro> `data FooBar = FooBar Int String`
10:50:43 <EvanR> trying to imagine wanting to have incomplete records on purpose
10:50:59 <gentauro> you can actually write `let meh = FooBar 42 in ..`
10:51:06 <gentauro> and then `meh "42"`
10:51:17 <EvanR> if you are trying to literally translate some other code, i can see that
10:51:21 <gentauro> you can't do that in OCaml or F# for example, which is pretty `meh`
10:51:51 <bsima> a concrete example might help
10:52:04 <Cale> Of course, you can do it in those languages with an explicit lambda, so it's not *that* different, but syntax does matter.
10:52:13 <bsima> i parse a csv file to get some name and address info for a person
10:52:27 <bsima> then i hit some endpoints tto validate the data
10:52:37 <gentauro> bsima: have you heard of `parserCombinators`? xD
10:52:43 <gentauro> that's where they shine ;)
10:53:12 <Cale> bsima: If it's just a few fields, I would stick to more traditional solutions -- use Maybe, factor types in a sensible way, use parametric types, etc. etc.
10:53:15 <bsima> this happens in two separate steps, so i have 'CsvRow' and 'Person' data types
10:53:23 <bsima> 'Person' is basically a superset of 'CsvRow'
10:53:25 <EvanR> building the final record would be the "now validated" step, prior to that you have some less specific pile of values, [[ByteString]] 
10:53:33 <gentauro> bsima: have a look at this `open banking` project where I parse `CSV` files and I place them in nice `Haskell` types ;)
10:53:36 <Cale> bsima: If it's a convoluted mess of hundreds of fields of varying types which may be missing, look into using DMap
10:53:36 <gentauro> https://gitlab.com/spisemisu/openbanking-sparnord
10:54:13 <bsima> DMap = dependent map?
10:54:23 <bsima> tthanks gentauro, will look at that code
10:54:30 <gentauro> u welcome
10:57:14 <bsima> gentauro: that's just parsing? In my case I do the parsing, then a number of "data pipeline" functions that involve IO
10:57:29 <bsima> and involve a multiple database queries
10:57:37 <gentauro> and somebody in here showed me how to use `{-# LANGUAGE RecordWildCards   #-}` (see lines 238 - 333) -> http://dpaste.com/3WPAR04
10:57:38 <EvanR> on the subject of validation, the mode of validation failure (beyond returning a big Nothing) seems to really depend on your surrounding tooling for realing with errors
10:58:19 <gentauro> bsima: ehh, I read the file (IO) then I parse it, and then I "work" with the data (IO again)
10:58:20 <EvanR> returning a list of problems might not play nice with your planned way to deliver logs to whoever needs to read them
10:58:36 <EvanR> i'm not sure a record of problems is always good either
10:59:37 * hackage strict-list 0.1.0.1 - Strict linked list  https://hackage.haskell.org/package/strict-list-0.1.0.1 (NikitaVolkov)
10:59:46 <Cale> bsima: Yeah, DMap is a dependent map type, it lets you define a GADT (or system of GADTs) whose values will be the keys of the Map-like structure, and the types of the keys will tell you the corresponding types of the values
10:59:54 <EvanR> theres so much work involved in non-golden path
11:00:28 <Cale> bsima: and it has all the operations you'd want on extensible records, like union and intersection and difference and such
11:01:18 <bsima> thanks Cale, that might be a fuure refactor...
11:01:26 <bsima> future*
11:01:31 <Cale> bsima: If you decide to go down that road, I have a bunch of code which is potentially helpful, starting with the constraints-extras package, which, given such a key type, lets you say things like  Has ToJSON MyKey
11:01:53 <Cale> which means that for any value x :: MyKey a, there will be an instance ToJSON a
11:02:04 <Cale> (this is a constraint level thing)
11:02:48 <Cale> This is really important if you want to do serialisation and such. It's also useful for things like Has Semigroup MyKey if you want to be able to compose records with each other.
11:03:26 <bsima> tthat would be cool, i'll keep this in my back pocket, tthanks!
11:05:45 <Cale> I originally came up with this stuff alongside a couple of my coworkers while we were trying to deal with a client project that demanded we store a typically-small subset of potentially thousands of different individual fields of data from a complicated application form, depending on the path that the user took.
11:07:26 <Cale> The GADTs both gave us a way to key our frontends -- we could write a handful of functions like providing i18n'ed descriptions of the fields, and determine from their type what sort of widgets to present the user to input a value
11:07:46 <Cale> and a way to look up and operate on the data in some processing rules later
11:28:30 <leshow> in aeson, if I write an aeson instance for SomeType, then derive an instance for data Foo = Foo { key :: SomeType }, aeson will use my handwritten instance for SomeType when ser/de Foo?
11:29:17 <Solonarv> yes
11:30:01 <leshow> Solonarv: thanks
11:34:37 * hackage strongswan-sql 1.2.0.0 - Interface library for strongSwan SQL backend  https://hackage.haskell.org/package/strongswan-sql-1.2.0.0 (erick)
11:42:13 <sm> what a name!
11:43:49 <sm> descendant of FreeS/WAN. Nice
11:58:16 <reallymemorable> so I know this is in horrible shape, but I am new to this and trying to hack my way through a Quandl integration using Pipes.Concurrency.  From what I understand, I need a Producer (which I think I have created?) and a Consumer (which I'm not sure how to create), to handle data in multiple threads.  What is the next thing I should be focusing on in this script? 
11:58:21 <reallymemorable> https://paste.ofcode.org/pSPwNE3ehSqiP2qsbqX8WT
11:58:33 <reallymemorable> I am cycling back and forth between the Pipes.Concurrency tutorial and this script
12:05:34 <habbah> where is the definition of the list type located?
12:05:52 <reallymemorable> habbah: are you talkign to me?
12:06:03 <habbah> to anyone who knows :) 
12:06:21 <reallymemorable> then not me, i thought you were talking about my question
12:06:43 <reallymemorable> a list is a monad i think
12:06:46 <reallymemorable> but i am new to this
12:07:16 <habbah> That is correct.
12:07:35 <habbah> I am looking for the source code of the list type
12:07:41 <reallymemorable> ah ok
12:07:43 <habbah> I should try GHC.Base
12:08:46 <cocreature> habbah: list is somewhat special as the syntax is builtin
12:09:47 <habbah> https://hackage.haskell.org/package/ghc-prim-0.5.3/docs/src/GHC.Types.html#Bool
12:10:00 <habbah> data [] a = [] | a : [a]
12:11:13 <c_wraith> there is no real source for [] because it's not syntactically valid for library-defined code.
12:11:34 <c_wraith> it has to be special cases in the compiler.
12:12:05 <c_wraith> (but its functionality has nothing special, just the syntax)
12:13:02 <cocreature> minus the syntax it’s equivalent to "data List a = Nil | Cons a (List a)" which is something that you can actually define yourself
12:22:37 <dminuoso> While this is not a guarantee, you can unsafeCoerce between that representation and list and it (mostly) works.
12:23:26 <dminuoso> Seeing that list was not special and essentially user-constructable was a major revelation for me.
12:32:07 * hackage distribution-nixpkgs 1.2 - Types and functions to manipulate the Nixpkgs distribution  https://hackage.haskell.org/package/distribution-nixpkgs-1.2 (PeterSimons)
12:43:07 <ottidmes> can you use @var with view patterns?
12:46:11 <lyxia> yes you can
12:48:49 <ottidmes> lyxia: I have tried: go ((splitExtension -> (nameX, ".lhs"))@name, (splitExtension -> (nameY, ".hs")) : names) | nameX == nameY = name : go names, but it gives me a syntax error on the @name
12:50:09 <ottidmes> guess I can only do it on the pattern as a whole, i.e. the whole list
12:50:32 <ottidmes> nope, same error
12:53:37 <ottidmes> ah, now I remember, it is name@(...) not (...)@name
13:06:55 <imdoor> hi, i built a haskell FFI library using cabal 2.0's foreign-library stanza. checked the resulting .so file with nm, and i see that it doesn't provide symbols for hs_init nor hs_exit. i thought that the results of foreign-library were supposed to be self-contained. what other stuff should i be linking against in a downstream project (it's c++ in this instance)?
13:07:24 <phadej> imdoor: you need to link against haskell RTS
13:08:10 <phadej> but iirc .so does refer to librts.so (or whatever it's called)
13:11:41 <imdoor> phadej: what do you mean by "does refer to librts.so"?
13:13:06 <geekosaur> it has a load command for it, and the RTS shared object provides the symbols
13:13:21 <geekosaur> so anyone linking against your .so also gets the command to load the RTS
13:13:22 <phadej> try `ldd your-library.so`
13:15:33 <phadej> IIRC, it even loads all package dependencies from separate shared objects
13:16:01 <phadej> and one need to do some tricks to make single "all Haskell inside" .so
13:16:12 <phadej> (and even the C-libraries are still in .so)
13:16:18 <phadej> it's tricky
13:17:23 <phadej> https://github.com/haskell/cabal/issues/4827 <- tricks include making own GHC with special flags
13:19:07 * hackage esqueleto 2.7.0 - Type-safe EDSL for SQL queries on persistent backends.  https://hackage.haskell.org/package/esqueleto-2.7.0 (parsonsmatt)
13:20:29 <imdoor> geekosaur phadej: thanks this makes things clearer 
13:21:17 <imdoor> part of the reason i'm struggling with this thing so much is that i'm trying to make this thing work within my Nix packages
13:22:36 <gentauro> https://www.staff.ncl.ac.uk/andrey.mokhov/selective-functors.pdf <- anybody looked into this?
13:23:12 <imdoor> and i haven't found the right way to provide ghc's libs to my downstream project as build dependencies (in a way that nix's g++ wrapper picks up all the LD flags n stuff)
13:27:10 <imdoor> looking at the output of ldd i see that my .so file does indeed have a dependency on libHSrts-ghc8.6.3.so and it points to the ghc's lib folder in nix's store, but i guess the downstream project doesn't have access to it or something (gotta figure this part out)
13:31:43 <phadej> then at least in your shell LD_LIBRARY_PATH (or whatever makes dynamic linker find stuff) is setup in the right way
13:39:33 <reallymemorable> I want to put a threadDelay in this function, but everywhere I have tried putting it results in not being able to compile.  Does anyone have any thoughts on where to insert it?  https://paste.ofcode.org/LRM3GELpgNut6LHJJ3qu8c
13:40:21 <geekosaur> imdoor, one thing you might want is https://nixos.org/patchelf.html
13:41:21 <geekosaur> it's normally used in the other direction but you should be able to patch a .so or executable to point into nix's store (this has its own problems including upgrades since nix won't know it has such references)
13:41:41 <Solonarv> reallymemorable: 'threadDelay n' has type 'IO ()', but your do block has type 'Producer _ IO r'
13:41:52 <Solonarv> you need to use liftIO
13:41:54 <geekosaur> reallymemorable, if Producer has either MonadTrans or MonadIO instances there are ways to do it
13:42:05 <geekosaur> (lift and liftIO, respectively)
13:42:16 <reallymemorable> leftIO $ getTable...?
13:42:18 <geekosaur> if not, you need to find out how Producer gives you access to the IO
13:42:19 <reallymemorable> lift*
13:42:28 <geekosaur> getTable needs to be in Producer
13:42:35 <geekosaur> threadDelay needs to be in IO
13:42:58 <Solonarv> looks like both would work here
13:43:46 <reallymemorable> so I am going to modify the line that starts `table <- ...` right?
13:44:13 <geekosaur> I have no idea what exactly yiu are doing, but my guess is no
13:44:29 <reallymemorable> It's just pinging an API to get a Dataset
13:44:31 <geekosaur> you want the threadDelay either before or after that line, and it's probably liftIO $ threadDelay (whayever)
13:44:41 <geekosaur> that tells me nothing really
13:44:59 <reallymemorable> ah ok
13:45:02 <reallymemorable> yes that worked
13:45:11 <reallymemorable> sorry I am super new to all this
13:45:18 <reallymemorable> definitely do not have the vocabulary down yet
13:45:49 <reallymemorable> so liftIO lifts threadDelay into IO
13:46:51 <geekosaur> no, it lifts IO actions so that they are Producer ... IO actions
13:46:52 <Solonarv> no, threadDelay is already "in IO"
13:47:11 <geekosaur> because Producer has a MonadIO instance that tells it how to do so
13:47:29 <reallymemorable> so where is liftIO lifting the threadDelay to?
13:47:49 <geekosaur> Producer (Maybe Dataset) IO
13:47:57 <reallymemorable> oh
13:48:04 <reallymemorable> so its lifting it out of merely the IO realm
13:48:11 <reallymemorable> into the top level function
13:48:46 <Solonarv> liftIO takes something that is "in IO" and allows it to run "in" some more complicated monad
13:48:53 <reallymemorable> got it
13:49:13 <reallymemorable> and you always need to use that specific version of lift when dealing with something in IO
13:50:03 <geekosaur> you use it when the type (here, Producer) has a MonadIO instance, and the specific type is of the form (Producer somethinghere IO)
13:50:27 <reallymemorable> ok thanks
13:50:43 <reallymemorable> instance = typeclass?
13:51:39 <geekosaur> an instance of the typeclass MonadIO. the class itself is a framework; an instance implements that framework for a particular type
13:51:57 <reallymemorable> ok awesome
13:55:26 <imdoor> geekosaur: thanks. i should read up on the ELF format and how dynamic loading  actually works. that might help figure out which part of the process is broken right now
13:56:13 <geekosaur> nix plays lots of weird games with dynamic loading machinery, that being a large part of why it's meddling in parameters to various compilers; this kind of situation is not uncommon
13:56:28 <geekosaur> patchelf is a Big Hammer of sorts, for when the normal tweaks don't work
14:02:38 * hackage deque 0.4.0.2 - Double-ended queues  https://hackage.haskell.org/package/deque-0.4.0.2 (NikitaVolkov)
14:34:24 <Amras> is there an overview of hackage module naming conventions? What goes in Data, what in Math, etc?
14:35:41 <c_wraith> there's more contention than convention.
14:44:10 <lyxia> Amras: just use MyLibraryName.Stuff
14:44:39 <WilliamHamilton[> hi, does anyone have a working link for the c2hs paper?
14:52:04 <reallymemorable> I have a function that uses spawn and currently it's unbounded.  I need to limit it to 2 or 3 connections. I see in the docs that there is pool :: Int -> IO (IO a -> IO a), but I don't know how to combine it with my current function: https://paste.ofcode.org/322jxFrY9jFKXJWrAB3NwJX
14:55:06 <c_wraith> that's a weird api.
14:55:32 <c_wraith> what package is pool from?
14:56:07 <reallymemorable> http://hackage.haskell.org/package/spawn-0.3/docs/Control-Concurrent-Spawn.html
14:56:44 <reallymemorable> the first two lines in there are taken from my .hs
14:57:16 <c_wraith> well, OK. having looked at the source... that's still a weird api. :)
14:57:20 <Solonarv> I'd suggest using async/async-pool instead, tbh
14:57:45 <reallymemorable> what are the advantages of that
15:01:49 <reallymemorable> also, supposing I wanted to stay with spawn / pool, how would I combine the two to limit the number of connections?
15:02:14 <c_wraith> ah, I see why I think that api is so weird. it really wants impredicative polymorphism
15:02:47 <Solonarv> honestly I don't immediately see how to use pool corectly
15:03:14 <Solonarv> because the entire library just slings IO around, instead of, y'know, defining new types
15:03:53 <Cale> It seems reasonably obvious to me
15:04:14 <Cale> If you execute pool n, you get a function IO a -> IO a
15:04:21 <c_wraith> new types would also let you recover the polymorphism lost by not being impredicative
15:04:26 <Cale> you apply that function to IO actions
15:04:39 <Cale> at most n of those IO actions will be in flight at once
15:04:59 <Solonarv> I guess, but that's still a weird way to go about it
15:05:29 <Cale> It's sort of a conclusion of setting up an MVar or whatever hangs on to the number of in-flight actions
15:07:11 <Cale> Yeah, defining an intermediate rank-2 datatype would let you get a forall a. IO a -> IO a as the result of pool
15:07:37 <c_wraith> oh. naming it "pool" is weird. it doesn't create a pool. it's just an access barrier.
15:08:41 <Cale> yeah... or it's a pool of integer?
15:08:42 <Cale> lol
15:09:40 <Cale> I suppose it could be a key component in making a pool
15:12:43 <reallymemorable> ok i will investigate this stuff
15:12:45 <reallymemorable> thanks 
15:12:55 <reallymemorable> sorry its a lot for me to take in at my very low skill level
15:24:38 * hackage tidal 1.0.8 - Pattern language for improvised music  https://hackage.haskell.org/package/tidal-1.0.8 (AlexMcLean)
15:39:07 * hackage drifter 0.2.4 - Simple schema management for arbitrary databases.  https://hackage.haskell.org/package/drifter-0.2.4 (MichaelXavier)
16:13:37 * hackage monad-logger-prefix 0.1.11 - Add prefixes to your monad-logger output  https://hackage.haskell.org/package/monad-logger-prefix-0.1.11 (parsonsmatt)
16:14:44 <Axman6> with that API, you end up writing code like: do { limit <- pool 10; parMapIO (limit . f) } which is fine as long as everything executes in the right order; it looks like it could deadlock
16:15:12 <Axman6> (with an xs in there somewhere)
16:54:06 <CuriousErnestBro> A very inefficient inverse function:
16:54:07 <CuriousErnestBro> invert x | x == 0 = 0 | x > 0 = pred ( invert ( pred x ) ) | otherwise = succ ( invert ( succ x ) )
16:54:15 <CuriousErnestBro> Is this efficient for Peano numbers?
17:13:28 <edmundnoble> Which formulation of peano numbers
17:14:06 <edmundnoble> What exactly is this supposed to do? Seems like it will just return the same number it's passed
17:15:19 <edmundnoble> Oh it's a `negate` function
17:15:40 <edmundnoble> But yeah I'm still curious which encoding of the integers you're using
17:20:04 <slack1256> After using the async library I got problems seeing where bare forkIO + MVars is better.
17:20:55 <slack1256> Does anybody got any example where that can be?
17:21:18 <c_wraith> well, they're useful for implementing async. :P
17:21:28 <davean> slack1256: what if you're doing a server that sums state? 
17:22:35 <slack1256> sums state? as watching over multiple MVars?
17:22:43 <davean> async does does exactly one thing
17:22:56 <c_wraith> sometimes you also end up in situations where you need more bidirectional communication than just "this will eventually produce a value"
17:22:57 <davean> there are a lot more multithreaded/mvar computations
17:23:03 <MarcelineVQ> expresses concurrency as a tree?
17:25:46 <slack1256> c_wraith: both forkIO threads and async thread can be augmented via extra TVar or TMVar for more bidirectional communication. Async threads just recognize you mostly want the end value of the thread be different that `IO ()` though
17:26:50 <slack1256> Actually expressing concurrency as a tree is easier via the async library as the `withAsync` combinator handles the cases of async exceptions spurring, so you can create surpervisor trees. That is why now I feel weird using just forkIO threads...
17:27:46 <MarcelineVQ> No I​ mean async's job is to expresses concurrency as a tree
17:29:16 <slack1256> Oh, you're right then
17:36:55 <jusss> about type constructor and value constructor, I'm confused,   data Maybe a = Nothing | Just a,   Maybe is a type constructor and it takes one type then construct this type with Nothing and Just a, and what is the a in Just a?
17:37:26 <slack1256> Just (5 :: Int) :: Maybe Int
17:37:29 <lyxia> jusss: it's the type of the only field of the Just data constructor
17:38:30 <jusss> lyxia: Just is a value constructor, and put Just in the type parameter a, that's ok?
17:38:42 <jusss> or the a after = is not a type , is a value?
17:40:40 <c_wraith> the syntax for data declarations does mix types and values, yes
17:41:01 <c_wraith> data Foo a = Bar String Int a
17:41:21 <c_wraith> Bar is a value, String, Int and a are all types.
17:41:43 <jusss> what?
17:42:07 <c_wraith> data constructors are values.
17:42:13 <jusss> c_wraith: what it means? Bar String Int a
17:42:47 <c_wraith> you can't just extract that one portion in a meaningful way.
17:42:54 <c_wraith> you need the whole line.
17:43:39 <c_wraith> it is declaring a data type named Foo. the type takes one parameter, named a within the scope of the declaration.
17:44:24 <jusss> c_wraith: Bar String Int a, is what I don't understand, 
17:44:25 <c_wraith> the type is defined as the constructor Bar with 3 arguments. in order, the arguments have the types String, Int, and a
17:47:28 <c_wraith> that's just the syntax for a (non-record) data declaration. constructor name followed by the types of the arguments of the constructor. if there are multiple constructors, they each have the same syntax with a | separating them.
17:49:50 <c_wraith> it's a very concise syntax, but it definitely has some clarity issues for beginners.
17:52:28 <jusss> it really makes me confused, the type stuff in haskell
17:53:41 <c_wraith> well, we could simplify a lot. here's an actual definition from the standard library:
17:54:05 <c_wraith> data Bool = False | True
17:54:49 <c_wraith> the Bool data type has two constructors. neither takes an argument.
17:55:43 <c_wraith> is that a thing that makes sense?
17:58:28 <jusss> Bool is a type constructor, it doesn't take one type parameter, and it constructs two type by False and True, and False and True is what?
17:58:37 <jusss> type constructor or value constructor
17:58:57 <jusss> and what 's the different between value and value constructor?
17:59:32 <jusss> type constructor ,follow the name, it should consturct a type, so Bool should construct a type
17:59:48 <c_wraith> well, um.. type constructors make types. data constructors make values of a particular type.
17:59:53 <x77686d> A friend is looking for some paid tutoring in Haskell for guidance on one of several projects relating to formal languages.  One is implementation of the Earley parsing algorithm.  Another is implementing "the inside-outside algorithm for assigning probabilities to a FSA/CFG based on some unparsed text".  If you might be able to help, let me know.  I believe pay would be >= $60/hr.
18:00:57 <c_wraith> types exist at compile time - they let you specify which values are possible in different places.
18:01:16 <c_wraith> values are the things that actually exist in memory when the program runs.
18:02:44 <slack1256> x77686d: Your first friend will be helped by reading about https://hackage.haskell.org/package/Earley . Maybe he can mail the author too for questions?
18:03:12 <jmcarthur> jusss: One could imagine a syntax more like some imperative languages.  Bar("string", 42, True) would have type Foo<Bool>
18:03:29 <x77686d> @slack1256: I'll pass that along.
18:03:29 <lambdabot> Unknown command, try @list
18:03:46 <x77686d> slack1256: I'll pass that along.
18:03:49 <c_wraith> slack1256, the Earley package introduces a lot of extra sophistication to work with parser combinators.
18:04:35 <c_wraith> slack1256, I mean, the whole Grammar type exists only to capture sharing information that would otherwise be invisible in a combinator-based system.
18:04:35 <slack1256> maybe reading the first commits of the project? Usually that is a simple version of the main ideas.
18:11:26 <dyl> slack1256 'initial commit', 'fleshed out a bit', 'refactored', 'skeleton code'
18:11:40 <dyl> :p
18:18:02 <slack1256> heh
18:18:49 <slack1256> 'initial commit', 'refactored', 'skeleton code', 'fill with undefined', 'fix', 'fix 2', 'real fix'
18:41:41 <dyl> slack1256: ’fix’, ‘fix actually’, ‘fuck’, ‘actually fixed’, ‘DO NOT PULL’
19:20:59 <infinisil> I've seen a repository where they only use commits for new releases..
19:21:27 <infinisil> So the commits are named "v4.5.107", "v4.5.108", ...
19:21:43 <infinisil> And every commit changes almost every file
19:22:30 <infinisil> Oh I actually think they didn't use semver, the version numbers were just integers
19:24:19 <MarcelineVQ> mniip: what was your repo with yahb's sandboxing-tooling? Can't recall your github atm
19:24:40 <mniip> https://github.com/mniip/sandbox
19:25:04 <MarcelineVQ> I like date-based version suffixed, but commits which are whole versions? that's a bit monolithic
19:25:06 <MarcelineVQ> mniip: thank you
19:25:18 <MarcelineVQ> wonder why that didn't pop up in my google search
19:25:48 <road4400> hello, I'm trying to use sdl2-ttf, and I've got it in my stack.yaml file, but I'm getting an error I don't understand from stack:
19:26:10 <road4400>     Configuring sdl2-ttf-2.1.0...     Cabal-simple_mPHDZzAJ_2.2.0.1_ghc-8.4.3: The pkg-config package 'SDL2_ttf'     version >=2.0.12 is required but it could not be found.
19:26:55 <road4400> I'm not sure what that error means -- version 2.1.0 should be >= 2.0.12, correct?
19:28:14 <jackdk> looks like it's complaining about a missing native dependency. what is your uname -a?
19:29:40 <road4400> Linux ubuntu 4.4.0-142-generic #168-Ubuntu SMP Wed Jan 16 21:00:45 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux
19:30:08 <road4400> oh - so maybe I need to install a native sdl-ttf library through my package manager?
19:30:15 <slack1256> exactly
19:30:17 <geekosaur> it wants a C library with pkg-config data (think of it as ghc-pkg for C libraies)
19:30:36 <slack1256> probably some sdl-dev stuff (if ubuntu still does that distinction)
19:30:37 <road4400> oh i see -- ok I'll give that a try...
19:30:39 <geekosaur> or in this case, actually C++ because SDL
19:30:50 <geekosaur> and yes, you need the ubuntu  -dev package
19:31:59 <road4400> that was it... thank you all :)
19:32:32 <slack1256> pkg-config related stuff is always related to the system libraries not being avalaible
19:46:58 <maerwald> or it can be an error in the .cabal file
19:47:10 <maerwald> e.g. when not checking whether a pkgconfig file was added downstream
20:14:24 <hololeap> if i wanted multiple keys in a Map to point to the same list, and i wanted any changes on that list to be reflected no matter which key was used, what are some options?
20:15:49 <hololeap> would i have to use STRef or IORef?
20:16:50 <slack1256> I don't think so
20:17:20 <Lears> hololeap: I tried to write this at some point. You can probably do it a bit easier impurely, or you can use an outer map from external keys to internal Int keys, and an internal IntMap from those to your values.
20:17:47 <Lears> Some of the operations get a bit involved though, at it's hard to keep it efficient.
20:17:51 <Lears> and*
20:18:05 <hololeap> Lears: oh, interesting idea
20:18:57 <Lears> I can probably gist what I had written if you want? Though I don't know if it's in a working state.
20:19:27 <hololeap> no, it's ok. i think i could write that on my own.
20:24:37 <Lears> It sounds simpler than it is. Honestly, since the pure version is possible, if I were to have another go at it I would write the impure version with unsafeCoerce and try to prove that's it's just a simplification and optimisation.
20:34:16 <isTofu> Hey, what's a good 'debugger' for haskell ? Something like prologs gtrace. 
20:35:52 <slack1256> You have two options mostly, ghci can set break and do basic debugger stuff
20:36:12 <slack1256> The other is use the DWARF output done by the runtime system and load that onto gdb
20:36:41 <isTofu> Which is more friendly to use for some one new to haskell ?
20:36:54 <slack1256> ghci
20:37:06 <isTofu> :D alright, that's what i figured. 
20:37:08 <isTofu> that's slack1256
20:37:20 <shapr> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#the-ghci-debugger
20:37:20 <isTofu> 'thanks'
20:37:48 <isTofu> Thanks. 
20:38:04 <shapr> I've never used the ghci debugger... though I've used debuggers in other languages. I tend to write property tests.
20:38:10 <shapr> I should really learn the debugger
20:38:27 <isTofu> The first thing i do with a new language is understand the debuggers. 
20:38:45 <isTofu> It saves me so much headache in the long run. 
20:38:53 <slack1256> I use Debug.Trace.trace to debug "printf-style".
20:40:14 <Lears> I've used it, but never actually figured out a bug with it. I always end up fixing my bugs by thinking about my program and constructing test values. Honestly I've barely had to think about debugging since I switched from python to Haskell.
20:40:34 <isTofu> interesting. 
21:11:20 <mjrosenb> Is there a way to get cabal build to dump the cabal file it is using? I'm seeing something weird, where it looks like it is ignorning the file in my directory.
21:12:06 <sclv> mjrosenb: do you maybe have a ghc environment file lying around?
21:12:28 <mjrosenb> not in the directory that I'm in.
21:12:31 <sclv> also you can use "-v" and related flags
21:12:43 <sclv> env files can be in a few difft directories iirc
21:14:05 <mjrosenb> the thing that I'm seeing is that cabal is complaining about modules that I depend on which are not listed in other-modules
21:14:09 <mjrosenb> but they *are* there.
21:14:17 <sclv> hrm
21:14:27 <sclv> have you tried a "clean" and a "configure"?
21:14:29 <MarcelineVQ> got more than one section they might apply to?
21:14:35 <sclv> it should notice a changed cabal and reconfig automatically
21:15:24 <mjrosenb> cabal reconfigure --ghcjs; cabal build did not change anything
21:21:12 <mjrosenb> there's also a decent chance that this is an issue with nix.
21:21:23 <mjrosenb> nix confuses me a surprising amount considering how logical it is.
21:21:46 <maerwald> well, nix is confused
21:24:07 <maerwald> Just trying to find useful documentation is already hard enough
21:24:21 <maerwald> Or one that is not outdated
21:24:47 <maerwald> And even then you need an encyclopedia of quirks
21:33:21 <sclv> t
22:37:15 <jusss> Just 3 is a value? and its type is Maybe Int?
22:38:08 <cocreature> jusss: technically integer literals are polymorphic so it’s type is Num a => Maybe a
22:38:29 <cocreature> but since Int is an instance of Num you can use it as type Maybe Int
22:39:41 <jusss> cocreature: and Just 3 is a value?
22:39:59 <Axman6> yes
22:40:30 <jusss> cocreature: in other languages, I know String Int can be value, but in haskell this type stuff really blow up my mind
22:41:22 <jusss> Axman6:  Just 3 is a value and it's a value of the type Maybe Int, right?
22:41:40 <Axman6> yep
22:42:51 <jusss> data Point = Point Int Int,      let p1 = Point 1 1, and p1 is Point 1 1,    this Point 1 1 is a value too?
22:43:11 <jusss> and Point 1 1's type is ?
22:43:21 <jusss> is Point Int Int?
22:43:26 <Axman6> it's worth exploring a little further; 1 is a value of type Int (which can be written more concisely as 1 :: Int). Just is a _function_ of type a -> Maybe a, a.k.a, Just :: a -> Maybe a. since a can be anything, when Just, which is a function, is applied to 1 which is an Int, Just 1, the a is chosen to be Int, and you get Just 1 :: Maybe Int
22:43:55 <Axman6> Point 1 2 :: Point - Point does not have any type parameters
22:44:15 <cocreature> using different names for the constructor and the type might be more helpful
22:44:23 <cocreature> "data PointTy = PointConstr Int Int"
22:44:29 <cocreature> PointConstr 1 1 :: PointTy
22:44:29 <Axman6> you could have data Tuple a = Tuple a a, and in that case, Tuple 1 2 :: Tuple Int
22:44:39 <jusss> Axman6: Point 1 1 is a value and its type is Point, right?
22:44:43 <Axman6> yep
22:46:33 <jusss> data Point a b = Point { what = a, ever = b}      let x = Point 3 5 
22:48:48 <jusss> Axman6: so I can define any types if I want in haskell?
22:51:07 <dminuoso> jusss: The syntax is slightly off, but yes you can create custom data types - and you should.
