00:03:23 <dminuoso> When I generate a typeclass with TH, splice it into a module and write an instance for that typeclass lexicographically before the splice I get "Not in scope" for the typeclass.
00:03:27 <dminuoso> Why exactly is that?
00:04:29 <dminuoso> If I hadn't been able to write an instance for that typeclass at all Id have dismissed this under stage restriction, but this seems different.
00:20:13 <jle`> dminuoso: it sounds like a similar thing? if you use a TH splice, nothing 'before' can refer to any declarations generated by the TH
00:38:39 <dminuoso> jle`: Thanks, that helped. So it seems that the manual on TH talks about it in the paragraph about declaration groups: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#template-haskell
00:41:59 <dminuoso> Each declaration group is mutually recursive only within the group. Declaration groups can refer to definitions within previous groups, but not later ones.
00:42:27 <dminuoso> This has some interesting consequences wrt to mutual recursion bindings. There cant be a top level splice between them, it seems.
01:00:37 * hackage winery 1.0.1 - Sustainable serialisation library  https://hackage.haskell.org/package/winery-1.0.1 (FumiakiKinoshita)
01:12:11 <utdemir> Hey. Does anyone know if there's a bounded priority queue implementation in Hackage? None of the priority queue libraries I was able to find does not have a bounded version? My use case is getting the max N elements from an M element array efficiently, where N << M.
01:57:46 <newbie_Mark> t
01:57:59 <newbie_Mark> Can someone helps to understand error related to stack and gcc:  ```     collect2: error: ld returned 1 exit status     `gcc' failed in phase `Linker'. (Exit code: 1)      /usr/bin/ld.gold: error: cannot open  ghci: No such file or directory     /usr/bin/ld.gold: error: cannot open  modules: No such file or directory     /usr/bin/ld.gold: error: cannot open  compile: No such file or directory     /usr/bin/ld.gold: error: cannot 
02:01:12 <dminuoso> newbie_Mark: What did you do to provoke that error?
02:05:36 <rfold> There are various tools for finding unused functions. However, all those tools consider functions used if they are exported from an exposed module. Is there a tool that even reports those functions as unused, if they are not used inside the package?
02:13:30 <tdammers> not that I know of. considering "exported from an exposed module" "used" is correct IMO, because you cannot be sure that it's *not* going to be used
02:15:39 <rfold> Yes, but in this case I am aware of all users of the package, so it would be nice to have. Perhaps a tool that can work with multiple packages, assuming they form a closed universe.
02:19:35 <tdammers> that is an assumption we like to pretend doesn't make sense ever
02:20:16 <rfold> More specifically, it is a library that is used by an executable and by a test suite, and not anywhere else.
02:24:48 <sshine> rfold, you could make the module export nothing and see how many functions fail to be imported. then the "dead" functions are the complement.
02:24:58 <tdammers> yeah, so basically none of the Haskell tooling is designed with this situation in mind - the assumption is generally that a library that exists is going to be used by code that is not under the library author's control
02:28:13 <rfold> sshine: it's about 300 modules so going through this by manually toggling exports is rather painful üòÖ
02:28:26 <rfold> Thank you guys, I will see if I can find anything!
02:32:04 <Unhammer> can -ddump-simpl show line numbers?
02:32:06 <MarcelineVQ> you can work top-down with https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/separate_compilation.html#ghc-flag--ddump-minimal-imports
02:32:12 <Unhammer> in the original source code
02:40:54 <MarcelineVQ> rfold: so you could use that pragma to assemble a list of thing that are actually truly used, and then compare that to what all is exported
03:08:00 <akersof> hi all, is it the same to write map toUpper . takeWhile (/= '#') $  "hello#you" , and takeWhile (/= '#') . map toUpper $  "hello#you"
03:08:55 <ski> @free takeWhile
03:08:56 <lambdabot> $map f . takeWhile (g . f) = takeWhile g . $map f
03:09:30 <akersof> ski: what does that mean ?
03:10:25 <ski> and `(/= '#') . toUpper' should be equal to `(/= '#')' since
03:10:29 <ski> > toUpper '#'
03:10:31 <lambdabot>  '#'
03:10:52 <akersof> ski: indeed, my question was more about efficiency
03:11:05 <ski> and `toUpper' of some `Char' that's not `#' shouldn't be `#'
03:11:25 <ski> ok, i was answering the question of equivalent behaviour
03:11:42 <akersof> ski: sorry, i wasn't enough clear
03:12:21 <akersof> ski: i read code, from probably someone who is better in haskell than me, and he us takeWhile pred . map f
03:12:45 <akersof> but my point of view, is it is more logic to map f . takeWhile pred
03:13:01 <akersof> but maybe cause of lazy evaluation it is the same ?
03:13:05 <ski> i think probably there is no big difference, if any noticable one
03:13:36 <akersof> ski: ok was just curious :)
03:13:54 <ski> yes, in any case `f' won't be called for `Char's beyond where `takeWhile' cutoffs
03:14:07 <akersof> another point, yesterday i release on github my first haskell program.. just a raw haskell script file
03:14:29 <akersof> ski: but from what i read i should use cabal ?
03:14:35 <akersof> or stack ?
03:15:19 <ski> anyway, the free theorem is about `takeWhile' not caring about the elements of the list itself, the only way it decides what to do with them is by passing them to the callback
03:15:41 <akersof> humm ok
03:16:10 <ski> and therefore, to `takeWhile', it doesn't matter if you `map f' before passing the list to `takeWhile', or, otherwise, `map f' afterwards (but also call `f' before calling the previous callback, though in this case that was unnecessary)
03:16:45 <ski> afaiui, you'll have to learn about cabal at one point or another anyway
03:16:47 <akersof> ok :) so nothing to worry about it
03:17:04 <akersof> ski: oh?
03:17:21 <ski> (stack uses cabal)
03:17:36 <phadej> stack uses Cabal-the-library
03:17:37 <akersof> i see some cabal vs stack post, but as far as understand it, they are not designed for the same goal
03:17:39 <phadej> be specific
03:17:48 <phadej> cabal-install the executable is different
03:17:57 <phadej> stack doesn't use the executable
03:18:21 <akersof> humm ok
03:18:59 <ski> yes
03:19:11 <phadej> Q: "should i use cabal", A: "Yes, you should consider using some dependency-manager/build-tool"
03:20:00 <akersof> ok and apprently stack is more "project" oriented ?
03:20:12 <akersof> like a project manager?
03:20:24 <akersof> and cabal a "package" manager?
03:20:34 <akersof> (for developpement i mean)
03:20:45 <merijn> akersof: Not really, tbh
03:21:00 <akersof> ok :)
03:21:27 <akersof> well if i have to make a synthesis of all what i read, the conclusion would be, if you don't know just use stack
03:21:30 <merijn> akersof: The main difference between stack and cabal is "stack defaults to building against a fixed set of packages maintained by stackage" and "cabal does dependency resolution against the newest releases on hackage"
03:21:58 <merijn> akersof: So the main heuristic is "how much do I want to work against the bleeding edge?"
03:22:16 <akersof> ok make sense for me
03:22:41 <akersof> merijn: what do you use and why ?
03:23:05 <merijn> akersof: I use cabal (technically cabal-install), because that's what I've been using since before stack ever existed :p
03:23:23 <merijn> And I'm too lazy/don't have any incentive to switch
03:23:33 <phadej> for small toy projects it doesn't really matter
03:24:03 <akersof> ok, as a new haskeller in 2019, should i use stack ?
03:24:10 <phadej> no
03:24:35 <phadej> but that's my parsonal opinion, and internet may disagree
03:24:39 <merijn> akersof: Honestly, I'd say "just pick one" and you can always decide to switch later without too much opinion
03:25:01 <merijn> akersof: There's really not much reason to spend much time worrying about the "right choice"
03:25:09 <phadej> +1
03:25:13 <akersof> lol ok
03:25:20 <merijn> akersof: Both tools work of .cabal files specifying packages, so migrating from one to the either should be relatively little effort
03:26:01 <fr33domlover> Is it a good idea to write (x,y,z) == (a,b,c) as a possibly clearer version of x==a && y==b && z==c ? Especially if one of the tuples is assigned a single symbol e.g. t==(a,b,c) vs ta==a && tb==b && tc==c
03:26:25 <merijn> akersof: My only recommendation is that if you use stack, it has integration for hpack (package.yaml files). Don't use that. Because that will make switching later more difficult
03:26:25 <akersof> ok :) thx i will try both on my toy project and choose what fit better for my mind 
03:27:00 <merijn> fr33domlover: Yeah, that seems fine to me
03:27:04 <akersof> merijn: indeed i read about this package.yaml
03:27:54 <merijn> akersof: Most of the features it used to have over .cabal are already in .cabal now and it's actually incapable of expressing somethings you can do with .cabal files. (Also, as I said added bonus of both stack and cabal supporting the .cabal files directly)
03:30:07 * hackage network-uri-lenses 0.2.1.0 - Lenses for network-uri  https://hackage.haskell.org/package/network-uri-lenses-0.2.1.0 (Jappie)
03:39:19 <cocreature> merijn: it isn‚Äôt hard to switch even if you do have a package.yaml file. run hpack one time to get the cabal file, throw away package.yaml and you‚Äôre done
03:40:04 <merijn> cocreature: Sure, but I recommend against hpack *in general* :p
03:45:49 <cocreature> That‚Äôs fine but ‚Äúit‚Äôs hard to switch is a pretty bad argument‚Äù for that as that is simply not true imho
03:49:58 <__monty__> cocreature: It's hard in the sense that you have to learn to understand a new config format.
03:52:48 <rfold> And it's YAML
03:53:13 <cocreature> Right, that‚Äôs somewhat true although I think ‚Äúhard‚Äù might be an overstatement. Most of the knowledge should carry over quite easily
03:55:11 <cocreature> Just to be clear, I‚Äôm not trying to advocate for hpack here. I just don‚Äôt think ‚Äúhard to switch‚Äù is a good reason to avoid. The main reason I would avoid it is that usually it is an additional layer of complexity that doesn‚Äôt bring much benefit.
04:15:42 <Gurkenglas> What do you call a t that has "(a -> t b) -> t (a -> b)"?
04:19:19 <hpc> hard to say without knowing the laws, or some concrete example to extrapolate from
04:19:51 <Gurkenglas> one example that comes to mind is (c ->)
04:19:55 <lyxia> cotraversable?
04:20:18 <Gurkenglas> lyxia, that would be Distributive afaik
04:20:26 <Gurkenglas> ie the inverse of the above
04:21:00 <Gurkenglas> actually, not the inverse
04:21:09 <Gurkenglas> it's just Distributive, and lyxia is right :D
04:21:19 <lyxia> :)
04:21:28 <Gurkenglas> I thought of it, too, and then dismissed it as the wrong way round ._.
04:23:25 <Gurkenglas> (Why I wanted this: Now I can say there's "Distributive g => LensLike g (Coyoneda f a) (Coyoneda f b) a b")
04:25:51 <therealwaphire[m> Hey, guys! Completely new Haskeller here. Looking for a few answers to get me going. What are the usecases of Haskell? Where is it and where can it be used?
04:26:11 <hpc> it's a general purpose language
04:27:01 <hpc> facebook used it for antispam (and still might, who knows what goes on there)
04:27:04 <hpc> pandoc is written in it
04:27:07 <hpc> so is shellcheck
04:27:25 <Uniaika> backend services when you need strong guarantees that it won't crash
04:27:56 <_ceb> Pandoc is pretty lit
04:28:02 <hpc> or where you need the language's help to make sure you've written it right
04:28:03 <arianvp> therealwaphire[m: I think Haskell excels in places where you want to write high assurance software quickly whilst being able to reuse a lot of code easily
04:28:10 <hpc> (which is pretty much everywhere for me)
04:28:10 * _ceb uses it in Rmarkdown, amazing tool
04:28:33 <Uniaika> RMarkdown is fantastic
04:28:44 <arianvp> Both Facebook and standard chartered seem to use Haskell for similar reasons
04:29:20 <Uniaika> S-C even implemented a haskell compiler of their own
04:29:34 <arianvp> SC writes Haskell for their trading tools that need to be implemented within days . 
04:29:49 <arianvp> They have an enormous library of reusable components that they compose, to ship things quickly
04:30:17 <arianvp> Same for Facebook. Lots of small little utilities for data aggregation and pattern recognition. And then people compose these and deploy them immediately to write spam fighting rules
04:31:37 <arianvp> Another place where Haskell really excels is any time you need to parse and process data.   We used it at work for parsing all kinds of obscure document and b2b formats into a uniform interface. Lots of libraries for efficiently streaming and parsing data are available
04:31:52 <hpc> haskell is also good for weird stuff, where you can't properly express the problem otherwise
04:32:03 <hpc> there's a few music synthesis libraries out there for instance
04:32:33 <hpc> and a DJ that uses it to edit songs live on stage
04:32:54 <arianvp> Domain modelling is very nice in Haskell. So indeed lots of nice DSLs are written in Haskell like music synthesis programs or bookkeeping software like hdledger
04:33:19 <Martin333[m]> Wow, that DJ thing sounds very cool.
04:33:38 <arianvp> Algoraves
04:33:41 <arianvp> :p
04:36:58 <hpc> ah, here it is - https://www.youtube.com/watch?v=smQOiFt8e4Q&list=PLybSFICi4UliK17U6rxPneXAyxvmGAe5T&index=4
04:47:36 * hackage language-docker 8.0.2 - Dockerfile parser, pretty-printer and embedded DSL  https://hackage.haskell.org/package/language-docker-8.0.2 (lorenzo)
04:48:09 <kritzefitz> If I have a list of bytes `bytes :: [Word8]` that produces the list in a way that can be fused, can I convert that to a bytestring in a way that fuses away the list? Data.ByteString.pack didn't fuse in my tests.
04:50:26 <lyxia> maybe there is a way going through Builder
04:52:32 <lyxia> actually, if pack doesn't already do it, maybe not.
04:54:04 <nai> hi. i read somewhere that it is impossible to construct a function with type a -> b (and therefore, according to the Curry-Howard equivalence, the logical proposition a -> b is not a theorem). however, in haskell, i can do the following:
04:54:09 <nai> f :: a -> b
04:54:13 <nai> f _ = undefined
04:54:24 <lyxia> kritzefitz: "in a way that can be fused" do you mean that it could only "in principle"? Stream fusion currently relies on rewrite rules, which requires you to write your functions in a particular way (i.e. with build/foldr or functions built on those)
04:54:24 <nai> what am i missing?
04:54:39 <hpc> nai: what you've demonstrated there is that haskell is not logically consistent
04:54:47 <hpc> which corresponds to it being turing complete
04:54:48 <hpc> :D
04:54:52 <nai> oh
04:55:07 <e> FSVO consistent
04:55:18 <lyxia> FSVO Turing complete
04:55:24 <nai> oh, does CH only apply to simply typed LC?
04:55:38 <nai> and haskell is not so simply typed?
04:55:43 <hpc> it applies to all type systems
04:56:03 <hpc> there are many type systems, and many logical frameworks
04:56:05 <kritzefitz> lyxia, specifically I mean, that when I consume the list with `sum` instead of `pack` the list is fused away, so I concluded that `pack` the pack is ‚Äúat fault‚Äú here.
04:56:27 <nai> what is FSVO?
04:56:33 <e> For Some Value Of
04:56:38 <nai> ok
04:56:44 <hpc> the most interesting use of CH currently is dependent type systems that correspond to intuitionistic logic
04:57:24 <hpc> in one of those, you wouldn't have been able to write that f, because there isn't an undefined
04:57:46 <hpc> (or technically you could, but you'd have to use "postulate" which is sort of like unsafe* functions)
04:58:10 <nai> so would a definition like  undefined = undefined  be illegal/badly typed?
04:58:10 <e> you could make haskell specifically forbid (a -> b) but you can't extend it to cover every impossible case, because it would have to reason about the behaviour of turing-complete programs
04:58:22 <e> no, that's the canonical definition of undefined
04:58:39 <nai> i mean, in such a type system that hpc mentions
04:58:42 <hpc> it would fail the termination checker
04:58:54 <hpc> it's not illegal to have things like x = f x, but they have to be "constructive"
04:58:59 <hpc> like, ones = 1 : ones
04:59:22 <hpc> "productive" is a better word actually
04:59:28 <lyxia> do you consider the termination checker not a type system
04:59:53 <hpc> i think it's part of it
05:00:10 <hpc> but worth calling out specifically here, because it's not very common
05:00:23 <lyxia> fair enough
05:01:19 <e> it should be obvious, but in case it isn't to anybody, there must be terminating programs that cannot be proved to terminate by any given such system
05:01:25 <nai> ok, i'll clearly need to read more about type systems and models of calculus 
05:01:31 <e> and in practice you hit this limitation quite quickly
05:02:16 <nai> e: isn't that just the undecidability of the halting problem?
05:02:21 <hpc> nai: definitely start with "dependent types"
05:02:35 <e> nai: a consequence thereof
05:02:43 <nai> ok
05:02:44 <hpc> and if you're more practically minded, it's a nice transition into affine types, which rust uses for its memory model
05:03:02 <nai> i'm more theory minded
05:03:09 <hpc> once you have learned DTs a bit, affine types should be super easy
05:03:15 <nai> but ok
05:03:25 <nai> thanks
05:04:25 <e> idris uses an assert_smaller in its example quicksort implementation :(
05:04:51 <hpc> heh
05:13:28 <dminuoso> hpc: Affine types feel, conceptually, easier than DTs.
05:21:01 <ziman> there should be a version somewhere that does it properly with views
05:55:27 <rfold> TIL with -XDataKinds you can write things like data Foo = Bar * | Baz * *
05:56:42 <dminuoso> % :set -XDataKinds
05:56:42 <yahb> dminuoso: 
05:56:46 <dminuoso> % data Foo = Bar * | Baz * *
05:56:46 <yahb> dminuoso: 
05:56:50 <dminuoso> % :k 'Baz
05:56:50 <yahb> dminuoso: 'Baz :: * -> * -> Foo
05:56:55 <dminuoso> rfold: This is pretty neat.
05:57:00 <dminuoso> % data Foo = Bar * | Baz * * Int
05:57:00 <yahb> dminuoso: 
05:57:06 <dminuoso> % :k 'Baz
05:57:06 <yahb> dminuoso: 'Baz :: * -> * -> Int -> Foo
05:57:10 <dminuoso> % :t Baz
05:57:10 <yahb> dminuoso: * -> * -> Int -> Foo
05:57:22 <dminuoso> o.o
05:57:22 <bor0> what is the difference between lambdabot and yahb?
05:57:23 <rfold> However, when you write data Foo = Bar | Baz *; then bar :: Foo -> (); bar Bar = (), then you do get a warning that you're not matching on Baz _, but that value can never be constructed I think.
05:57:34 <dminuoso> rfold: ^- check that out, this is truly bizarre. :)
05:57:49 <dminuoso> This looks TypeInType'ish
05:57:52 <kritzefitz> rfold, AIUI Without DataKinds you can Write `Foo = Bar Data.Kind.Type | Baz Data.Kind.Type Data.Kind.Type` which should mean the same.
05:57:58 <rfold> Nice :)
05:58:36 <rfold> Previously had data Foo a = Bar a | Baz a a, and used Foo (*) everywhere.
05:59:38 <dminuoso> Does DataKinds imply TypeInType then?
06:00:13 <rfold> I don't think TypeInType is needed here.
06:00:28 <dminuoso> rfold: Are you sure about that?
06:00:31 <dminuoso> % :t Baz
06:00:31 <yahb> dminuoso: * -> * -> Int -> Foo
06:00:41 <dminuoso> rfold: ^- explain this type signature without TypeInType to me.
06:00:41 <rfold> TypeInType means that * :: *; but that is different from a data constructor of kind * storing a type of kind * inside of it.
06:00:52 <rfold> Just like data Foo = Foo Int doesn't mean Int :: Foo
06:01:06 <rfold> Sorry, 42 :: Foo
06:01:06 <dminuoso> rfold: Or is there some type *? What are its inhabitants?
06:02:09 <dminuoso> Not bad, I managed to crash GHC.
06:02:22 <dminuoso> % :q
06:02:22 <yahb> dminuoso: 
06:02:26 <dminuoso> % :set -XDataKinds
06:02:27 <yahb> dminuoso: 
06:02:31 <dminuoso> % data Foo = Bar * | Baz * *
06:02:31 <yahb> dminuoso: 
06:02:41 <dminuoso> % Baz _ 1
06:02:45 <yahb> dminuoso: ; <interactive>:1:1: error:; GHC internal error: `Ghci1.it' is not in scope during type checking, but it passed the renamer; tcl_env of environment: []
06:03:34 <dminuoso> rfold: There's something iffy going on, since this * also exists for the data constructor (which suggests some sense of TypeInType going on here)
06:03:44 <rfold> Say you do not enable TypeInType. Given data "Foo = Bar *" then "Bar :: * -> Foo" and "*, Foo :: BOX".
06:03:45 <dminuoso> I dont know how you would construct such a Baz 
06:04:12 <dminuoso> rfold: `Bar` is a value level construction. How do you pass a type as a value?
06:04:33 <rfold> You cannot construct a value with the data constructor Bar.
06:04:43 <rfold> But you can construct a type with the data constructor Bar. For example: Bar Int :: Foo
06:04:57 <rfold> Here, Bar Int is a type, and Foo is a kind.
06:05:25 <dminuoso> Mmm, perhaps its not TypeInType
06:06:06 <rfold> DataKind says that you can define your own kinds, and the syntax happens to coincide with that of ADTs.
06:06:51 <rfold> TypeInType says that * :: *.
06:07:38 <dminuoso> Mmm.
06:10:35 <rfold> I think without TypeInType, all kinds fall into a sort called BOX.
06:10:53 <dminuoso> rfold: Nah, with TypeInType you conflate the infinite tower into a flat level.
06:11:02 <royal_screwup21> could someone explain to me what the error is here? https://repl.it/repls/IndolentConventionalProfessionals I'm trying to write a functor instance for a simple datatype
06:11:04 <rfold> So Bar :: * -> Foo, and * -> Foo :: BOX
06:11:12 <dminuoso> rfold: So instead of having `1 :: * :: Box :: ...` you'd have `1 :: Type :: Type :: Type :: ...`
06:11:39 <rfold> royal_screwup21: you have to write this as "instance Functor Animal where ..." because fmap will decide the a
06:11:49 <dminuoso> royal_screwup21: Do you know what kinds are?
06:12:03 <rfold> dminuoso: yes indeed, hence "I think *without* TypeInType, ..."
06:12:14 <lyxia> Functor Animal... hmmm...
06:12:16 <dminuoso> royal_screwup21: Ohh I misread. :)
06:12:34 <dminuoso> lyxia: You didn't know animals were functors, did you?
06:12:54 <dminuoso> I can see someone conjuring an aprils fool paper already.
06:13:29 <rfold> royal_screwup21: if you take the signature of fmap, and specialize it to your situation, you will see: fmap :: (b -> c) -> Animal a b -> Animal a c. This is obviously wrong: Animal takes only one type argument, not two.
06:13:54 <rfold> You would want fmap :: (b -> c) -> Animal b -> Animal c. So instead of Functor (Animal a) you would write Functor Animal.
06:14:05 <royal_screwup21> oh I see okay, that makes sense...
06:14:40 <dminuoso> royal_screwup21: In Haskell, types too have types - except we call them *kinds*. One example for such a kind is `*`, many types have kind `*`, namely all "finished types" that have values. Int :: *, Float :: *, Double :: *, etc..
06:15:03 <royal_screwup21> following so far
06:15:12 <dminuoso> royal_screwup21: Maybe is a type constructor, it takes a type argument and returns a type. So Maybe has the kind * -> *
06:15:29 <dminuoso> Either takes two type arguments, so: Either :: * -> * -> *
06:15:49 <royal_screwup21> and in my case, Animal::* -> *
06:15:54 <dminuoso> royal_screwup21: Exactly!
06:15:55 <dminuoso> royal_screwup21: Now:
06:16:10 <dminuoso> % :i Functor
06:16:10 <yahb> dminuoso: class Functor (f :: * -> *) where; fmap :: (a -> b) -> f a -> f b; (<$) :: a -> f b -> f a; {-# MINIMAL fmap #-}; -- Defined in `GHC.Base'; instance [safe] Functor Q.Gen -- Defined in `Test.QuickCheck.Gen'; instance [safe] Functor (Magma i t b) -- Defined in `Control.Lens.Internal.Magma'; instance [safe] Functor (Level i) -- Defined in `Control.Lens.Internal.Level'; instance [safe] Functor (Bazaa
06:16:22 <dminuoso> royal_screwup21: Do you see this `class Functor (f :: * -> *) ...` part?
06:16:33 <dminuoso> This means that whatever instance you write, it *must* have the kind * -> *
06:16:46 <dminuoso> Animal a :: *
06:16:59 <dminuoso> (Since it's already applied to a type)
06:17:02 <royal_screwup21> ah I see okay...
06:17:21 <dminuoso> royal_screwup21: Would it be valid to write: instance Functor Either where ... ?
06:17:50 <royal_screwup21> I don't think so, cause Either :: * ->  * -> *
06:18:21 <dminuoso> royal_screwup21: Good. Another question: What would be valid arguments to Either?
06:19:22 <royal_screwup21> dmiles: both args must have the same type?
06:19:35 <royal_screwup21> oh no
06:19:47 <dminuoso> royal_screwup21: Int -> Int -> Bool, do both Ints need to be the same value?
06:19:59 <royal_screwup21> ah nope
06:20:29 <dminuoso> royal_screwup21: Same thing. So Either can take two different type arguments, as long as both have kind *.
06:20:50 <dminuoso> `Either Int Double` would be well kinded for example, because `Int :: *` and `Double :: *`
06:21:00 <royal_screwup21> dminuoso: is the Either datatype imported in Prelude?
06:21:11 <dminuoso> royal_screwup21: Yes.
06:21:16 <realtechnerd> helo
06:21:23 <dminuoso> realtechnerd: Would `Either Maybe Int` be valid?
06:21:29 <dminuoso> Oops. I meant royal_screwup21. :)
06:21:38 <realtechnerd> ok lol
06:22:10 <royal_screwup21> dminuoso: I don't think so...Either (Maybe Int) would be valid
06:22:16 <royal_screwup21> Either (Maybe Int) Int*
06:22:20 <dminuoso> royal_screwup21: Very good.
06:22:37 <dminuoso> royal_screwup21: Now interestingly: `Either (Maybe Int)` is a valid construction by itself.
06:22:54 <dminuoso> royal_screwup21: What is the kind of `Either (Maybe Int)`?
06:23:04 <royal_screwup21> dminuoso: how do I see the type arguments for either on ghci? I tried ghci Either but it's not in scope
06:23:07 <royal_screwup21> :t Either
06:23:09 <lambdabot> error:
06:23:09 <lambdabot>     ‚Ä¢ Data constructor not in scope: Either
06:23:09 <lambdabot>     ‚Ä¢ Perhaps you meant variable ‚Äòeither‚Äô (imported from Data.Either)
06:23:19 <dminuoso> royal_screwup21: :t works on *data* level constructs. Either is a type level construct, use :k instead
06:24:45 <royal_screwup21> * -> *
06:25:01 <dminuoso> royal_screwup21: Good. Do you think it would be valid to write: instance Functor (Either (Maybe Int)) ?
06:25:22 <royal_screwup21> yup, since the expected kind matches
06:26:20 <dminuoso> royal_screwup21: And indeed it gives a valid Functor instance. It turns out, that the choice of the first argument is irrelevant, so you could write `instance Functor (Either a)` which means semantically that you get an instance for *every* choice of type a
06:26:33 <royal_screwup21> dminuoso: btw what's the "contract" that specfies that a functor instance needs to have kind * -> *?
06:26:43 <merijn> royal_screwup21: The class definition requires it
06:26:57 <dminuoso> royal_screwup21: It is inferred by the type of fmap
06:27:06 <dminuoso> (Insice the class definition)
06:27:17 <merijn> royal_screwup21: "class Functor f where fmap :: (a -> b) -> f a -> f b" <- 'f :: * -> *' is inferred from 'f a'
06:28:03 <royal_screwup21> is it just me or is it confusing how "f" sometimes stands for functions, sometimes for functor?
06:28:15 <dminuoso> royal_screwup21: the `f` is chosen to hint at functor.
06:28:27 <dminuoso> royal_screwup21: Oh but yeah. Haskellers tend to be very terse.
06:28:33 <rfold> You will eventually get used to the same letter being used in values and types for different purposes. But sometimes it is indeed confusing.
06:28:58 <dminuoso> royal_screwup21: Its frequently confusing how we use the same identifier for type and data constructors (which is fine because they are in different scopes)
06:29:07 <dminuoso> royal_screwup21: Just as a final test of your acquired kind knowledge
06:29:13 <dminuoso> % :k StateT
06:29:13 <yahb> dminuoso: StateT :: * -> (* -> *) -> * -> *
06:29:25 <dminuoso> royal_screwup21: ^- name a fully saturated type based on StateT.
06:29:28 <rfold> For equational reasoning, it is only the structure that matters; the names are only there because they have to be there, and as mnemonics.
06:31:13 <royal_screwup21> Either (Int) (Animal) (Int)?
06:31:31 <dminuoso> royal_screwup21: Yup, this would be well kinded. Very good.
06:33:35 <royal_screwup21> cool thanks folks
06:33:58 <dminuoso> royal_screwup21: Oh I just noticed a mistake. Did you mean to write StateT instead of Either?
06:34:14 <dminuoso> (I only checked the arguments initially)
06:36:08 <royal_screwup21> oh right yeah
06:44:07 * hackage focuslist 0.1.0.2 - Lists with a focused element  https://hackage.haskell.org/package/focuslist-0.1.0.2 (cdepillabout)
06:49:07 * hackage record-hasfield 1.0 - A version of GHC.Records as available in future GHCs.  https://hackage.haskell.org/package/record-hasfield-1.0 (NeilMitchell)
07:09:00 <akersof> i was reading http://www.cantab.net/users/antoni.diller/haskell/units/unit08.html and there is 2 versions of a function cap3 and cap4
07:09:14 <akersof> here the snippet https://gist.github.com/akersof/43a662bad3125869ad34a1250fc2958b
07:10:25 <akersof> the article explains: It is straightforward to modify cap3 so that every character entered is echoed as soon as it is typed. All that we have to is to put the function that tests the input line to see if it consists of three ampersands and nothing else inside a local definition as follows: 
07:11:34 <akersof> but i can't understand why cap4 get rid of lazyness expressed in cap3
07:12:32 <Cale> what are the definitions of before and after?
07:13:13 <akersof> oh sorry let me rewrite the snippet.. this is a kind of takeWile wrapper
07:13:52 <akersof> Cale: https://gist.github.com/akersof/43a662bad3125869ad34a1250fc2958b 
07:14:25 <Cale> Anyway, it seems like these are not actually the same function... cap3 is looking for &&& right at the start
07:14:45 <Cale> cap4 only begins looking for &&& following a newline
07:15:32 <akersof> Cale: If you enter any character other than an ampersand, it is immediately echoed to the screen as it is typed. When you type a single ampersand, it is not echoed. This may seem strange, but it is what you would expect because of lazy evaluation. 
07:15:37 <akersof> i am quoting the article
07:15:53 <c_wraith> they aren't quite the same function, but it probably doesn't matter.
07:16:17 <akersof> so to correct this the article show the cap4 version
07:17:25 <akersof> so i can't understand why cap4 doesn't check for "&&&" the lazy way
07:18:31 <akersof> and indeed for cap3 when you enter just 1, 2 or 3 '&' they aren't printed on the screen yet "it is what you would expect because of lazy evaluation"..
07:19:51 <Cale> Well, yeah, because cap3 "&&&" = []
07:20:17 <Cale> So if the start of the input is an ampersand, there's no way to tell that this pattern won't match
07:20:24 <Cale> so no output could possibly be produced
07:20:52 <akersof> indeed
07:21:12 <akersof> i am fully OK with cap3 :) i mean my little brain can understand it
07:21:36 <ski> `cap4' is odd, while `cap3' is even
07:21:40 <Cale> cap4 only checks whether the previous line was &&& after emitting whatever that line was
07:22:12 <c_wraith> cap4 is also really poorly written.
07:22:14 <Cale> cap4 "&&&" = "&&&\n"
07:23:06 <Cale> It's perhaps worth mentioning that pretty much nobody these days actually writes Haskell programs using interact
07:23:33 <c_wraith> Like, the first thing that stands out to me is "why does cap4' take two arguments?"
07:23:46 * ski thought the idea with `cap4' would be to simulate line buffering
07:24:14 <ski> (but that's apparently not the case)
07:24:22 <Cale> It takes the second argument because it's checking the previous line to see if it should stop
07:24:35 <Cale> Or rather, it takes the first for that reason
07:24:37 <ski> it could just do `line == "&&&"'
07:24:37 <Cale> :)
07:24:39 <c_wraith> Cale: but it's only ever called with line, which is already in scope
07:24:43 <akersof> Cale: indeed.. this is a post check
07:24:54 <Cale> That's true
07:24:55 <akersof> while cap3 is a "pre" check ?
07:24:57 <lseactuary> anyone familiar with this notation please: https://www.cs.ox.ac.uk/projects/fdr/manual/cspm/prelude.html?highlight=diff
07:25:11 <lseactuary> i am writing a process, i have almost got it, i am just missing one small thing but just cannot see the issue
07:25:28 <akersof> Cale: explained this way this is really clear! thx
07:27:23 <ski> lseactuary : that seems to not be Haskell
07:28:48 <lseactuary> ski ye but thinking is similar (functional)
07:29:02 <ski> (you should probably say in more detail what small thing you're tripping oveR)
07:29:26 <akersof> well reading this thing about lazy evalation, now i start worrying for my future program
07:29:48 <akersof> lazy evalation seems hard to predict, in some case.
07:30:14 <lseactuary> https://pastebin.com/UgVT0GVK
07:30:42 <lseactuary> this issue is see?c:C?d:diff(C,{c}). when i just do see?c:C?d it does compile but when i graph it, it is wrong, you cannot 'see yourself'
07:30:53 <lseactuary> so i am trying to remove 'yourself' in the diff(C,{c}) part
07:31:21 * dminuoso smiles at lseactuary seeking help about CSPm in #haskell
07:31:25 <lseactuary> see is the action, ?c:C means we can choose anyone present to perform this action ?d means the list of people they can see
07:31:37 <lseactuary> dminuoso you know CSPm?
07:31:50 <dminuoso> I do now.
07:32:00 <lseactuary> can you help me? we can move to another channel if better for you?
07:32:18 <dminuoso> No.
07:32:54 <Cale> akersof: It usually only has a performance impact. interact/getContents are weird and magical
07:33:55 <akersof> Cale: oh.. i was writting a kind of command line client, and to get everything from input i used s <- getContents
07:34:02 <ski> lseactuary : seems like you're confusing a `CustomerID' with a set of them, in some way
07:34:16 <Cale> akersof: But also, it's not that hard to predict. It's important to understand that functions are evaluated outermost-first, and evaluation is driven by pattern matching.
07:34:34 <akersof> ok
07:34:44 <lseactuary> ski - ye - just cant get my head around how to fix thsi
07:35:04 * ski doesn't know this process receive(?) syntax
07:35:11 <Cale> akersof: But I also wouldn't say that lazy evaluation had much to do with the reason for the behaviour we were seeing -- it was also just what the functions themselves did
07:35:47 <Cale> akersof: cap4 isn't just lazier or something, it's actually producing different output
07:36:14 <akersof> Cale: ok thx.. i just closed this tab anyway :) and i came back to more "academic" supports like the wiki
07:36:52 <akersof> Cale: yes, it was "bad" explained in the article, i am agree
07:36:53 <lseactuary> ski - the channel 'see' is cartesian product i.e A.{A}, A.{B}, A.{}, B.{}, B.{A}, B{B} - taking customers A and B. I want to remove A.{A} and B{B} options basically.
07:37:02 <akersof> this is why my brain was bugging
07:40:03 <lseactuary> dminuoso if you know another channel where i am supposed to ask this i would welcome this option also
07:42:04 <ski> lseactuary : hm, i think i see
07:43:37 <ski> lseactuary : instead of `diff(C, {c})' there, having type `{CustomerID}', you want something of type `{{CustomerID}}', enumerating all the relevant *sets* that don't include `c'
07:43:56 <lseactuary> yeah
07:44:06 <ski> (perhaps you only want at most singleton sets, i'm not sure)
07:44:21 <lseactuary> https://www.cs.ox.ac.uk/projects/fdr/manual/cspm/prelude.html?highlight=diff - this says diff is a set \ set
07:44:29 <ski> yes
07:44:55 <lseactuary> hence i also tried see?c:C?d:diff({C},{c})
07:45:24 <ski> what set is `C' ?
07:45:31 <ski> (typically)
07:45:34 <lseactuary> C = customers present in the shop
07:45:50 <ski> hm, i suppose `{A,B,C,D}', initially
07:45:59 <lseactuary> hence the c:C part - only a customer in the shop can see someone else in the shop
07:46:09 <lseactuary> well A/B/C/D are available 
07:46:14 <lseactuary> but first they enter the shop
07:46:20 <lseactuary> hence enter?c:diff(CustomerID,C) -> Present(union(C,{c}))
07:46:21 <ski> hm, sorry. the other way around
07:46:25 <ski> it starts out empty
07:46:29 <lseactuary> yes
07:46:43 <lseactuary> henece within     Present({})
07:46:56 <lseactuary> hence C is a set already
07:46:59 <ski> ok, but at most it could be `{A,B,C,D}'
07:47:00 <asheshambasta> Is there a known Read-like typeclass for reading from the Text type? 
07:47:02 <lseactuary> yup
07:47:15 <ski> (not sure if that is ever possible. but apriori, it can't be more than that)
07:47:42 <ski> so, your example above suggested you only wanted sub-singletons in `d' ?
07:48:13 <lseactuary> well see is a cartesian - channel see : CustomerID . Set(CustomerID)
07:48:17 <merijn> asheshambasta: Use a parser library?
07:48:36 <lseactuary> so for a given customer ID we want to know who else they can see from the other CustomerID's present
07:48:42 <merijn> asheshambasta: I mean, you could use Data.Text.unpack and then use Read, but the performance of Read is shit
07:48:56 <asheshambasta> merijn: yeah, that bites me time and again. 
07:49:03 <ski> "the channel 'see' is cartesian product i.e A.{A}, A.{B}, A.{}, B.{}, B.{A}, B{B} - taking customers A and B. I want to remove A.{A} and B{B} options basically." -- this suggested to me you only wanted subsingletons, is that correct, yes or no ?
07:49:07 * hackage vulkan-api 1.1.3.1 - Low-level low-overhead vulkan api bindings  https://hackage.haskell.org/package/vulkan-api-1.1.3.1 (achirkin)
07:49:14 <merijn> asheshambasta: The real solution is to just use attoparsec/megaparsec
07:49:31 <lseactuary> ski - not sure what you mean subsingletones - i basically want a reduced set of options yes
07:49:44 <asheshambasta> and in this case, I'm relying on something like this for reading from a DB column we're mapping to type on our side. 
07:49:56 <asheshambasta> but it looks like the only way out. 
07:50:03 <ski> a subsingleton is a subset of a singleton set, iow being a set having at most one member
07:50:16 <asheshambasta> http://hackage.haskell.org/package/ulid-0.2.0.0/docs/Data-ULID.html
07:50:17 <lseactuary> sure
07:50:28 <ski> so you suggested `{A}',`{B}',`{}' as possible values for `d'
07:50:38 <lseactuary> yes
07:50:42 <ski> i was wondering whether `{A,B}' should also be a possible value for `d' ?
07:50:54 <lseactuary> nope its always 1:1
07:51:08 <ski> well, in `A.{}', it's not a singleton set, but an empty set
07:51:14 <lseactuary> because of channel see : CustomerID . Set(CustomerID)
07:51:18 <lseactuary> its a matrix basically
07:51:22 <lseactuary> customerId x customerID
07:51:47 <lseactuary> sure, if the shop has 1 customer, there is no one else to see
07:51:50 <lseactuary> hence A.{}
07:52:01 <lseactuary> A can still 'see' but there is no one to see here
07:52:08 <ski> should `A.{B,C}' be possible ?
07:52:13 <lseactuary> nop
07:52:17 <lseactuary> channel see : CustomerID . Set(CustomerID) is a matrix
07:52:18 <lseactuary> 1:1
07:52:36 * ski doesn't understand what lseactuary means by that
07:52:48 <lseactuary> A, B, C x A, B, C 
07:52:52 <lseactuary> so A can see A, B, C 
07:52:57 <lseactuary> B can see A, B, C 
07:52:58 <lseactuary> etc
07:53:00 <lseactuary> one at a time
07:53:25 <lseactuary> im saying A cant 'see' A as its himself, B cant see B etc 
07:53:30 <lseactuary> hence i am trying to remove those
07:53:38 * ski has no idea of the significance, in the problem model, of `c' and `d' arriving on this `see' channel, would be
07:53:56 <lseactuary> think about it 
07:53:58 <lseactuary> i come in the shop 
07:54:00 <lseactuary> its empty 
07:54:09 <lseactuary> so when i perform the see action the output is 
07:54:12 <lseactuary> L.{} 
07:54:18 <ski> if you didn't want to impose this "can't see oneself" restriction, what set would you restrict `d' with ?
07:54:23 <lseactuary> now you enter the shop
07:54:26 <lseactuary> and i see 
07:54:37 <lseactuary> now the output is L.{S}
07:54:49 <lseactuary> if you execute see then your output is S.{L}
07:54:56 <lseactuary> now a third person - K - comes inside 
07:55:10 <lseactuary> to 'see' i execue the action and my output is L.{K}
07:55:25 <lseactuary> if i want to 'see' you again i execute see again and my output is L.{S}
07:55:28 <ski> not `L.{S,K}', then ?
07:55:36 <lseactuary> i dont 'generically see' and have L.{s,K}
07:55:40 <lseactuary> a single action for a single result
07:55:43 <lseactuary> just like 'enter' 
07:55:48 <lseactuary> 10 people cant enter at the same time 
07:55:57 <ski> who decides whether you get `L.{K}' or `L.{S}' ?
07:55:57 <lseactuary> so its not enter.{a,b,c}
07:56:40 <lseactuary> oh wait
07:56:41 <lseactuary> you are right
07:56:43 <lseactuary> i just tested
07:56:45 <lseactuary> ignore what i said
07:56:51 <lseactuary> yes you can have L.{S,K}
07:56:52 <ski> i'm right in what ?
07:56:52 <lseactuary> sorry
07:56:56 <ski> oh, ok
07:57:13 <lseactuary> my mistake was only running the simulation with 1 not 2 people
07:57:15 <lseactuary> now i checked
07:57:45 <lseactuary> but the concept remains the same, im trying to remove the same person who is 'seeing' form that {} list
07:57:49 <ski> so i think then you want `?d:{D | D subset C,c notin D}' ?
07:58:03 <lseactuary> ye
07:58:10 <ski> (expressed however is appropriate in this CSPm language)
07:58:28 <ski> (did i say i don't really understand CSP ?)
07:59:01 <lseactuary> yeah this is what i am struggling with
07:59:06 <c_wraith> any ideas on how to discuss metaprogramming in a way that isn't language-specific? my first impression says "no", but maybe I'm missing something
07:59:09 <lseactuary> as the langugae doesnt seem to have 'not'
07:59:23 <lseactuary> except for diff
07:59:24 <ski> so, i suppose you need to generate the set of all subsets of `C', then filter out the subsets that contain `c'
07:59:54 <lseactuary> but C is a set right
08:00:03 <lseactuary> not a.b just a
08:00:27 <ski> `C' may be something like `{A,B,D}'
08:00:42 <lseactuary> yeah
08:00:57 <ski> taking the powerset of that, you get `{{},{A},{B},{D},{A,B},{A,D},{B,D},{A,B,D}}'
08:01:31 <ski> then, assuming `c' was `B', you want to filter out all the subsets containing `B', giving `{{},{A},{D},{A,D}}'
08:01:59 <ski> .. and, i suppose you could do that simpler and more efficiently by taking the powerset of `diff(C,{c})', to begin with
08:02:06 <ski> (obvious in hindsight)
08:02:51 <lseactuary> see?c:C?d:set(diff(C, {c})) and see?c:C?d:diff(set(C, {c}))
08:02:55 <lseactuary> both return errors
08:03:09 <lseactuary> which would you like to see?
08:03:12 <ski> what is this `set(..,..)' construction ?
08:03:21 <lseactuary> https://www.cs.ox.ac.uk/projects/fdr/manual/cspm/prelude.html?highlight=powerset
08:03:27 <lseactuary> function Set :: (Set a) => ({a}) -> {{a}} Returns the powerset of the input set.
08:04:02 <lseactuary> qq - can i not write this in haskell, and save it and run it as .csp? 
08:04:11 <ski> hm, yea, just saw that in the docs
08:04:23 <ski>   see?c:C?d:Set(diff(C,{c}))
08:04:24 <ski> try that
08:04:30 <ski> (with capital `S')
08:04:48 * ski has no idea what this has to do with Haskell ..
08:05:35 <lseactuary> whoa
08:05:35 * ski wonders about what kind of context c_wraith is thinking about ..
08:05:37 <lseactuary> that works
08:06:42 <ski> all good and dandy ?
08:06:51 <lseactuary> yeah!
08:07:04 <ski> great !
08:07:36 <lseactuary> many thanks :)
08:07:54 <ski> c_wraith : hm .. maybe mietek in ##dependent would have something to say about that question ?
08:11:21 <lseactuary> ski - you think i should use this? http://hackage.haskell.org/package/CSPM-cspm
08:11:32 <ski> no idea
08:12:08 <ski> (i don't know CSP, and certainly not CSPm, let alone that package)
08:12:43 <lseactuary> many thanks! i will continue, at least i am unblocked now :) 
08:13:06 <lseactuary> i will pay more attention to the capitals also now
08:29:22 <Rag> https://www.reddit.com/r/haskell/comments/144biy/pretty_output_in_ghci_howto_in_comments/
08:29:37 <Rag> I would like to get pretty output in ghci
08:30:02 <Rag> stack install fails on IPPrint
08:30:10 <Rag> are there any workarounds?
08:59:37 <Myzzler> This might be a rather naive question, but why do both return values of an if-then-else statement have to be of the same type?
09:00:48 <dminuoso> Myzzler: Consider binding the result to a variable
09:00:49 <EvanR> if-then-else is an expression not a statement
09:00:55 <dminuoso> a = if True then 1 else 'c'
09:00:57 <dminuoso> Myzzler: What type would a have?
09:00:59 <EvanR> all expressions have a single type
09:01:23 <dminuoso> Myzzler: Think of `if/then/else` as the following function
09:01:41 <dminuoso> % ifThenElse b t e = if b then t else e
09:01:41 <yahb> dminuoso: 
09:01:45 <dminuoso> % :t ifThenElse
09:01:46 <yahb> dminuoso: Bool -> p -> p -> p
09:02:04 <Myzzler> Oooh that makes sense
09:02:05 <bor0> > [ if x then (Left "hey") else (Right 123) | x <- [ True, False ] ] -- you can do something like this if that's what you need
09:02:06 <EvanR> (in haskell, variables aren't assignment a type in particular, its expressions. variables just refer to things)
09:02:07 <lambdabot>  [Left "hey",Right 123]
09:02:24 <Myzzler> Thank you guys :)
09:02:25 <ski>   if True  then x else y  =  x
09:02:26 <ski>   if False then x else y  =  y
09:02:33 <bor0> it's still the same type. Either String Int
09:06:28 <bor0> > [ Left (Left 'a'), Left (Right 1), Right (Left "a"), Right (Right 3.14) ] -- left and right can be juggled in an interesting way, here's a list "containing" a char, an integer, a string, and a double
09:06:30 <lambdabot>  [Left (Left 'a'),Left (Right 1),Right (Left "a"),Right (Right 3.14)]
09:06:37 * hackage safe-money 0.8 - Type-safe and lossless encoding and manipulation of money, fiatcurrencies, crypto currencies and precious metals.  https://hackage.haskell.org/package/safe-money-0.8 (RenzoCarbonara)
09:07:38 * hackage safe-money-xmlbf 0.1.1, safe-money-store 0.1.1, safe-money-serialise 0.1.1, safe-money-cereal 0.1.1, safe-money-aeson 0.1.1 (RenzoCarbonara): https://qbin.io/fair-adware-i6qd
09:10:27 <dminuoso> bor0: The reason this works is because `Either` creates a sum type between two arbitrary types. 
09:10:48 <dminuoso> So you could think of (,) as multiplying two types and Either as adding two types.
09:11:09 <dminuoso> Which is why our data types are called algebraic data types. :)
09:11:18 <bor0> <3 algebraic data types
09:11:51 <Uniaika> Sandy's book explains that quite well
09:15:54 <asheshambasta> another question: are libraries like these okay to use in projects? https://github.com/ad-si/ulid, I'm not trying to ridicule the library or anything (in fact, my team might want to maintain it and add things to it), but it seems like a real pain to write custom parsers for it since it's modules don't export some data constructors. Moreover, looking at the commits, it doesn't seem to be maintained. 
09:20:19 <Uniaika> yeaaah‚Ä¶ honestly if the disadvantage of UUIDv4 doesn't bother you, I would go with that
09:20:28 <Uniaika> or FlakeIDs (for which I need to write a lib)
09:20:31 <lyxia> legally you can just fork it and do whatever you want.
09:21:48 <lyxia> A nicer thing to do might be to ask the author what their plans for it are.
09:22:53 <Uniaika> that too yeah
09:26:09 <asheshambasta> lyxia: well yeah, I'd love to contribute to that; but I'll try to get in touch with the author.  
09:31:05 <EvanR> what is the disadvantage of uuidv4 you speak o
09:33:35 <c_wraith> from my pov, the main disadvantage to UUIDv4 is that it's too small. you'd want about twice the entropy to have high odds of not colliding in a birthday attack.
09:34:58 <Uniaika> EvanR: check the README of the lib. it says something weird that I don't fully understand, but probably that the UUID aren't scoped
09:35:09 <Uniaika> like, there no inherent context in them
09:37:37 <EvanR> seems like you'd want specific mission criteria before choosing uuid designs
09:38:18 <EvanR> the flakeID thing seems to be solving "unique" + 3 other issues
09:39:03 <EvanR> (a benefit of doing the mission analysis is you may not need uuids at all!)
09:39:08 <lseactuary> ski - do you know where i can get a little more CSPM help? bit stuck again.
09:39:11 <p0a> Hello 
09:39:20 <p0a> Is it ok to name a constructor the same name as the data type?
09:39:46 <EvanR> c_wraith: really... what are the odds of picking the same uuidv4
09:39:51 <glguy> It's pretty common for the type and value level constructors to have the same name
09:39:57 <p0a> thank you 
09:40:08 <EvanR> as a function of set size i guess
09:40:34 <Solonarv> EvanR: look up "birthday problem"
09:40:41 <royal_screwup21> what's the difference between a newtype vs a datatype?
09:40:42 <c_wraith> EvanR, expected number of duplicates generated is 1 after generating about 2^61
09:40:43 <Solonarv> in a nutshell: it's more likely than you'd think!
09:41:09 <EvanR> i figured that much
09:41:21 <c_wraith> which is a plausible number to generate
09:41:28 <c_wraith> in some use cases
09:41:33 <ski> p0a : i tend to use `data Foo = MkFoo ...', unless some more sensible name suggests itself
09:41:43 <ski> (i've also seen `FooOf')
09:41:47 <Solonarv> royal_screwup21: runtime representation
09:42:13 <Solonarv> with 'newtype Foo = MkFoo Bar', 'Foo' has the exact same representation as 'Bar'
09:42:46 <Solonarv> (also, newtypes must have exactly one constructor and that constructor must have exactly one field)
09:42:47 <ski> royal_screwup21 : `newtype' data constructor is an `O(0)' operation
09:43:21 <p0a> ski: will keep it in mind. for now I just wanted to know if it is ok or not in the language
09:43:23 <EvanR> so construction and destruction is free
09:45:39 <p0a> the fibonacci exercise is pretty cool
09:46:25 <p0a> where you write your 2x2 matrix type and get the n-th fib number by log-multiplication because Haskell optimizes (^). 
09:48:37 <tiny_lambda> hi, i am trying to compile a self written package using cabal under windows. On Linux and MacOS X it builds fine. On windows, the build seems to hang in the network-2.8.0.0 package. The build output contains the "Downloading", "Downloaded", and "Starting" for package network-2.8.0.0 - but not "Building" or "Completed". As far as i can see, all other packages seem to be build up to there.
09:49:19 <Solonarv> tiny_lambda: what ghc version are you on?
09:49:37 <tiny_lambda> Solonary, i am using ghc-8.6.4
09:49:56 <tiny_lambda> sorry, Solonarv
09:50:00 <p0a> tiny_lambda: a 2010 post: http://neilmitchell.blogspot.com/2010/12/installing-haskell-network-library-on.html
09:50:24 <p0a> they say use cygwin to install network and then never use cygwin again
09:50:56 <Solonarv> p0a: the post you linked links to an updated post
09:51:03 <Solonarv> https://neilmitchell.blogspot.com/2016/12/installing-haskell-network-library-on.html
09:52:05 <p0a> Solonarv: I typically do not read sentences on odd-numbered lines. duh!
09:52:13 <p0a> :P
09:52:16 <Solonarv> also, that's not the error that tiny_lambda was getting, so I don't think it's relevant
09:52:38 <p0a> maybe not ; the author in the '10 post just said `installing with cabal is tricky'
09:53:13 <Solonarv> installing *anything* with cabal was tricky before nix-style builds, AIUI
09:53:31 <sclv> don't use cygwin
09:53:32 <p0a> I will leave tiny_lambda to the experts I'm just a newbie myself
09:53:40 <sclv> don't follow those posts
09:53:42 <sclv> those posts are old
09:53:53 <sclv> tiny_lambda: how did you install ghc on windows
09:54:03 <sclv> and what version is it
09:57:06 <sclv> oh i see its 8.6.4
09:57:27 <pie_> does anyone know if it would be possible to patch Frege into an existing java application?
09:57:57 <dyl> pie_: what‚Äôs the benefit of doing so?
09:58:06 <tiny_lambda> sclv, i used stack for all the other stuff that are runtime deps of my package, so i did stack --stack-root ... --resolver lts-13.2 --compiler ghc-8.6.4 ABC
09:58:08 <dyl> And for what value of ‚Äúpatch‚Äù?
09:58:14 <pie_> being able to poke it with haskell as opposed to java
09:58:44 <sclv> tiny_lambda: and it never gives an error, just hangs?
09:58:51 <pie_> well i guess technically i have the source code but its a big thing so im not sure how easy it would be to get the two integrated
09:58:55 <dyl> pie_: if there‚Äôs an existing Java codebase, working with it isn‚Äôt going to feel much like Haskell.
09:59:02 <sclv> you should see if you can pass a flag to get more verbose output
09:59:20 <pie_> i dont really have any details in mind, jsut the though "well it might be nice if i could use haskell with this java thing"
09:59:26 <EvanR> pie_: theres at least 1 or 2 java-bridge things for haskell
09:59:41 <dyl> He mentioned Frege.
10:00:04 <EvanR> mention 1 frege mention 2 and 3 are haskell
10:00:09 <EvanR> in the haskell channel
10:00:37 <dyl> pie_: the way Scala and Clojure work is that they are (jars) libraries you can embed in other applications. I assume Frege is similar. 
10:00:55 <EvanR> java-bridge has different levels of excruciating pain for interfacing with java libs and apps
10:01:00 <tiny_lambda> sclv, thereafter i did cabal v1-update, cabal v1-install --with-compiler C:\Users\...\AppData\Local\Programs\stack\x86_64-windows\ghc-8.6.4\bin\ghc.exe (i retrieved this value via stack path)
10:01:12 <tiny_lambda> sclv, yes it still hangs no error
10:01:21 <sclv> oof
10:02:35 <tiny_lambda> what i am wondering about - why doesn't cabal use the packages that stack already compiled?
10:02:46 <sclv> they don't share package repos
10:02:48 <Solonarv> an extra data point: 'cabal v2-repl -b network' worked just fine for me
10:02:49 <sclv> they do things in a different way
10:02:58 <sclv> glad that v2 works!
10:03:10 <Solonarv> (also, I would recommend against using cabal v1-* commands if you can help it at all)
10:03:22 <sclv> oh wait, it works for someone else, sorry that doesn't help :-)
10:03:56 <sclv> tiny_lambda: for the "cabal way" even if you haven't installed via the platform, the extra steps to your cabal config may help
10:03:57 <sclv> https://www.haskell.org/platform/windows.html
10:04:20 <sclv> but you need to find the path where msys/mingw are on your system
10:04:33 <sclv> however if it just hangs without even hitting the typical error about missing libs, then its worse
10:04:34 <Solonarv> *definitely* don't use the Haskell platform on windows
10:04:50 <sclv> Solonarv: whether or not you do (and I claim it works fine), the steps are not about hte platform
10:04:55 <Solonarv> 8.6.3 is horribly broken: it hangs forever when compiling TH, among other issues
10:04:59 <sclv> they're about documenting where cabal looks to find msys/mgw libs
10:05:00 <sclv> right
10:05:07 <Solonarv> yeah, I was just making sur your advice wasn't taken incorrectly
10:05:21 <sclv> my guess was going to be that this is a general problem with the 8.6 series even though the user says they're using 8.6.4
10:05:39 <sclv> because hanging on build sounds suspiciously like a real ghc error :-/
10:05:54 <sclv> tiny_lambda: you can pass verbosity values to cabal too when you build to try to get better logs
10:06:30 <Solonarv> addendum: network-3.0 compiled fine for me, but it took quite a while
10:06:51 <Solonarv> currently trying network-2.8 which is taking a while but does not appear to be stuck
10:07:34 <Solonarv> most of the CPU time seems to be spent on cc1.exe, not ghc.exe
10:07:46 <Solonarv> tiny_lambda: ^
10:09:20 <Solonarv> pie_: from a cursory look, frege seems to deviate from GHC-haskell a lot more than the other large haskell-to-JVM compiler I know of, which is Eta
10:09:42 <sclv> yeah, its not really haskell at all anymore
10:10:07 <sclv> its just a haskell-like language
10:10:51 <pie_> i didnt really have any good reason for not using eta, it just said its a didactic language so i figured its engineered less or something
10:11:01 <pie_> so i could use eta i guess
10:11:56 <Solonarv> its approach to java FFI seems very reasonable
10:17:48 <tiny_lambda> Solonarv, did you succeed to build network-2.8.0.0 using ghc-8.6.4?
10:18:17 <Solonarv> apparently I'm still on 8.6.2, but network-2.8.0.0 worked fine
10:18:26 <__monty__> pie_: If anything eta is the more production focused haskell-on-jvm afaik.
10:18:55 <__monty__> There's also inline-java from tweag I think. Depending on what you're looking for.
10:19:01 <tiny_lambda> sclv, i cannot use haskell platform - i tried already to build all the stuff using ghc-8.6.3 but that stuck somewhere else (yesterday)
10:19:30 <Solonarv> ghc-8.6.4 doesn't seem to be on chocolatey yet so I'm not going to mess around trying to install it
10:19:35 <tiny_lambda> ok, so should i retry using ghc-8.6.2? did you run on windows 10?
10:19:46 <Solonarv> tiny_lambda: yeah - as I mentioned earlier ghc-8.6.3 is horribly broken
10:19:53 <sclv> the whole 8.6 series on windows has been a mess
10:19:58 <Solonarv> I'm on win8.1 but that really shouldn't matter
10:20:05 <pie_> hmm actually...I guess the situation is that I can run java scripts in this larger app, and I could call out to Eta/Frege from these scripts
10:21:00 <sclv> tiny_lambda: right i wasn't saying to use the platform. i was just pointing you to the cabal config settings on that page, since you need something analagous on windows regardless
10:21:06 <sclv> but it sounds like you already have them
10:21:35 <rag> hello - how do I enable colorful output from stack ghci?
10:21:54 <rag> similar to https://i.imgur.com/t6hOx.png
10:24:40 <lseactuary> ski you still here>
10:32:51 <tiny_lambda> sclv, ok got you, i should find out the settings for extra-prog-path and the like, right?
10:33:08 <tiny_lambda> sclv, ok, i will try this later
10:33:28 <sclv> tiny_lambda: right. for cabal to build anything that has a configure script and links against c libs those need to be right
10:33:36 <sclv> but the error you're getting is not about that!
10:34:00 <sclv> the problem is that "hangs forever" is really not a failure mode any of us are familiar with in terms of why network might not build on windows
10:34:02 <tiny_lambda> sclv, i am wondering - isn't there a way to pass all the settings from stack to cabal? And can't cabal be taught to use the same database as stack?
10:34:11 <sclv> stack has its own settings
10:34:19 <sclv> they're different
10:34:24 <tiny_lambda> sclv, i had a look into the log file but there is nothing of relevance
10:34:32 <sclv> and it manages the database in a different way -- that's why it exists
10:35:11 <tiny_lambda> ok, how can i tell cabal to build network pkg and be verbose on it?
10:35:49 <royal_screwup21> what is the this " <$>" here  https://en.wikibooks.org/wiki/Haskell/Applicative_functors ?
10:36:10 <Solonarv> royal_screwup21: it's 'fmap' as an operator
10:36:15 <royal_screwup21> oh ok
10:36:22 <Solonarv> meaning: 'f <$> x' = 'fmap f x'
10:36:33 <sclv> tiny_lambda: cabal v1-install network-2.8.0.0 -v2
10:36:38 <sclv> the `-v2` sets verbosity to 2
10:36:49 <sclv> as opposed to as a prefix, where it says which version of the command to use :-)
10:40:53 <royal_screwup21> could  someone explain to me how the <*> method is useful, and why it's used at all? I'm reading this https://en.wikibooks.org/wiki/Haskell/Applicative_functors but its not making sense to me. I know what functors are.
10:41:38 <dminuoso> royal_screwup21: So imagine that <$> is function application.
10:41:54 <dminuoso> With some stuff extra.
10:41:56 <sclv> royal_screwup21: with a monad you can write liftM2 :: (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
10:42:04 <dminuoso> And in the same sense, <*> generalizes for multiple arguments
10:42:05 <sclv> with a functor you can't
10:42:19 <sclv> but with applicative functor, you can write liftA2, liftA3 etc for any N
10:42:25 <dminuoso> liftA1 even!
10:42:29 <dminuoso> (which is pure)
10:42:47 <sclv> liftA1 is fmap, liftA0 is pure :-)
10:42:58 <Solonarv> ah, sclv beat me to it :D
10:43:17 <dminuoso> sclv: Oh mm. Yes. :)
10:43:28 <dminuoso> royal_screwup21: That's one way to think about it anyway.
10:43:53 <dminuoso> royal_screwup21: I didnt properly understand the point of Applicative until I took the Monoidal route.
10:44:32 <royal_screwup21> the applicative Maybe Instance instance on that page looks deliberately confusing...so many 'f's, all of them mean something different
10:44:57 <dminuoso> royal_screwup21: Maybe can be thought of adding "failure" to computation.
10:44:58 <AndreasK> Is there an equivalent for Data.Vector.Mutable.unsafeRead for Array?
10:45:35 <dminuoso> % :t liftA2 (,)
10:45:35 <yahb> dminuoso: Applicative f => f a -> f b -> f (a, b)
10:45:46 <dminuoso> royal_screwup21: ^- this can be thought of the essence of Applicative.
10:45:57 <slack1256> AndreasK: I think just (!), Array is inmuttable so there isn't a problem to begin with
10:46:47 <royal_screwup21> dminuoso: as I understand, this <*> is used when you have two same functors: the first one needs to hold a function (a->b), the other one has a value of type a. <*> then applies the function on the value, to give a new functor holding the result
10:47:12 <dminuoso> royal_screwup21: Maybe its helpful to start from a motivation perspective.
10:47:18 <AndreasK> slack1256: I should have been clearer I'm using mutable arrays. There is readArray but it performs bounds checks.
10:47:23 <dminuoso> royal_screwup21: Lets consider IO because its a good mindmodel here.
10:47:35 <dminuoso> royal_screwup21: So lets say you have a function `Int -> Bool`, how do you apply that to `IO Int`?
10:47:50 <tiny_lambda> sclv and Solonarv, another question please: what about changing the cabal configuration for compiler to simply "stack ghc" - wouldn't that help?
10:48:00 <dminuoso> You'd say `f <$> x` where <$> kind of takes the role of "application" but in the context of IO.
10:48:22 <royal_screwup21> dminuoso:  not sure :( tbh I'm not super use how IO works in haskell either
10:48:23 <nai> or  (pure . f) =<< x
10:48:32 <sclv> tiny_lambda: what would that help
10:48:37 <sclv> you're describing installing network hanging, no?
10:48:39 <dminuoso> nai: No, not helpful. Trying to make a different point.
10:49:05 <dminuoso> royal_screwup21: Then `Maybe Int`.
10:49:11 <royal_screwup21> ah okay
10:49:27 <sclv> tiny_lambda: that hanging occurs regardless of if you're using stack or cabal, right?
10:49:28 <royal_screwup21> dmiles: unwrap it?
10:49:37 <royal_screwup21> dminuoso: whoops, so I'd unwrap it with a cusom function
10:49:43 <royal_screwup21> or just fmap I guess
10:49:43 <dminuoso> royal_screwup21: You cant. What if its Nothing?
10:49:47 <dminuoso> right. fmap
10:50:03 <dminuoso> % val = 5
10:50:04 <yahb> dminuoso: 
10:50:08 <dminuoso> % odd <$> val
10:50:08 <yahb> dminuoso: ; <interactive>:14:1: error:; * Could not deduce (Integral a0); from the context: (Functor f, Integral a, Num (f a)); bound by the inferred type for `it':; forall (f :: * -> *) a. (Functor f, Integral a, Num (f a)) => f Bool; at <interactive>:14:1-11; The type variable `a0' is ambiguous; * In the ambiguity check for the inferred type for `it'; To
10:50:21 <dminuoso> % val = (Just 5)
10:50:21 <yahb> dminuoso: 
10:50:22 <dminuoso> % odd <$> val
10:50:23 <yahb> dminuoso: Just True
10:50:58 <tiny_lambda> sclv, well, you told me to adjust configuration values for extra-prog-path and so on. So that seems to tell cabal where cabal can find the toolchain. My toolchain, however, came with stack and is managed by stack. So why not tell cabal to use stack the stack trampoline instead of the naked paths to msys2/usr/bin and so on?
10:51:10 <dminuoso> royal_screwup21: So in some sense `<$>` lifts the function `Int -> Bool` to `Maybe Int -> Maybe Bool` and applies it to the `Maybe Int`
10:51:39 <dminuoso> royal_screwup21: However, what happens if we had a function taking not 1 but 2 arguments? Say (+)
10:51:50 <dminuoso> % :t fmap
10:51:50 <yahb> dminuoso: Functor f => (a -> b) -> f a -> f b
10:51:58 <AndreasK> Found Data.Array.Base (unsafeRead) that will do. Sadly it doesn't have haddocks so was hard to find
10:52:01 <dminuoso> % :t liftA2
10:52:01 <yahb> dminuoso: Applicative f => (a -> b -> c) -> f a -> f b -> f c
10:52:10 <dminuoso> % :t liftA4
10:52:10 <yahb> dminuoso: ; <interactive>:1:1: error:; * Variable not in scope: liftA4; * Perhaps you meant one of these: `liftA2' (imported from Control.Applicative), `liftA' (imported from Control.Applicative), `liftA3' (imported from Control.Applicative)
10:52:13 <dminuoso> % :t liftA3
10:52:13 <yahb> dminuoso: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
10:52:17 <sclv> tiny_lambda: but you need to tell _cabal_ where to find it
10:52:18 <sclv> not ghc
10:52:20 <sclv> so it doesn't help
10:52:29 <dminuoso> royal_screwup21: So Applicative just generalizes this to functions of arbitrary length.
10:52:38 <royal_screwup21> dminuoso:  ah okay...hmm
10:52:45 <tiny_lambda> sclv, ah ok - that's what i wanted to know
10:52:52 <Solonarv> tiny_lambda: if you want, you can 'stack exec --no-ghc-package-path bash' and that will make all the stack-installed stuff available on $PATH
10:53:12 <dminuoso> royal_screwup21: Now <*> gives you a little tool that does not require you to encode all the liftAn in the world.
10:53:28 <royal_screwup21> dminuoso: is this a valid use case then? Say I have function :: Int -> Int -> Bool, I want to change it to:: Maybe Int -> Maybe Int -> Maybe Bool?
10:53:43 <dminuoso> royal_screwup21: Yes. That's precisely what liftA2 does.
10:54:11 <dminuoso> % f :: Int -> Int -> Bool; f = (==)
10:54:11 <yahb> dminuoso: 
10:54:37 <tiny_lambda> Solonarv, ok, great, but will that be already sufficient for cabal?
10:54:40 <dminuoso> % f' :: Maybe Int -> Maybe Int -> Maybe Bool; f' = liftA2 f
10:54:40 <yahb> dminuoso: 
10:54:53 <dminuoso> % f' (Just 3) (Just 5)
10:54:53 <yahb> dminuoso: Just False
10:55:25 <royal_screwup21> okay I see it yup..
10:55:40 <dminuoso> royal_screwup21: Now the reason that Applicative is defined in terms of `pure` and (<*>) is that its a bit more comfortable. So instead you'd just write `f <$> x1 <*> x2`
10:55:42 <royal_screwup21> so we want to generalize over any size of arg
10:55:49 <dminuoso> royal_screwup21: Yup.
10:56:29 <dminuoso> or `f <$> x1 <*> x2 <*> x3`, `f <$> x1 <*> x2 <*> x3 <*> x4` ...
10:56:33 <Solonarv> tiny_lambda: it might, I used cabal that way for a while
10:56:51 <dminuoso> royal_screwup21: And `pure` gives you the case of "0-argument" 
10:57:26 <royal_screwup21> dminuoso: not sure I understand this `f <$> x1 <*> x2`  could you write in terms of fmap? Not sure which operator gets more precedence...
10:57:31 <dminuoso> royal_screwup21: No you cannot.
10:57:35 <dminuoso> royal_screwup21: Feel free to try though.
10:57:53 <royal_screwup21> but isn't <$> = fmap?
10:57:56 <dminuoso> royal_screwup21: Yes.
10:58:02 <dminuoso> royal_screwup21: But <*> is not.
10:58:25 <dminuoso> royal_screwup21: And equivalently you couldn't implement pure in terms of fmap either.
10:58:46 <Solonarv> tiny_lambda: I have a handy bash function for this in my ~/.bashrc: https://gist.github.com/Solonarv/5271a56bd2091adf52c2715077c2ed51
10:59:33 <royal_screwup21> dminuoso: oh okay...I was just confused, which gets executed first: is it (f <$> x1) <*> x2.. or is it f <$> (x1 <*> x2)
10:59:58 <dminuoso> royal_screwup21: That's a good question. Do you have your GHCi shell opened?
11:00:12 <royal_screwup21> yup I'll try it out
11:00:17 <dminuoso> royal_screwup21: Use :i
11:00:25 <dminuoso> royal_screwup21: It will tell you the fixity of the operator.
11:02:09 <c_wraith> though types also tell you how that has to work.
11:02:52 <c_wraith> > (+) <$> Just 1 <*> Just 2
11:02:54 <lambdabot>  Just 3
11:02:55 <dminuoso> royal_screwup21: As a sidenote: It's best not to think of this as "order of execution", it's just a question of precedence. :)
11:03:38 <c_wraith> in order for that to type check, it has to be parsed as ((+) <$> Just 1) <*> Just 2
11:03:58 <c_wraith> so... that's a hint as to parsing. :)
11:04:33 <royal_screwup21> > (+) <$> Just 1
11:04:34 <lambdabot>  Just <Integer -> Integer>
11:04:43 <dminuoso> Oh that is new.
11:05:10 <royal_screwup21> ok I see why the precedence order makes sense..
11:05:21 <royal_screwup21> :t <*>
11:05:23 <lambdabot> error: parse error on input ‚Äò<*>‚Äô
11:05:40 <dminuoso> % :t (<*>)
11:05:40 <yahb> dminuoso: Applicative f => f (a -> b) -> f a -> f b
11:06:53 <royal_screwup21> I'm still not fully convince how this works though
11:07:01 <royal_screwup21> specifically the ((+) <$> Just 1) part
11:07:19 <royal_screwup21> so when I execute this, Just is holding a function
11:07:25 <royal_screwup21> of type (Integer -> Integer)
11:07:29 <Solonarv> indeed! that is perfectly valid
11:07:51 <Solonarv> functions are values, you can pass them around just as easily
11:08:48 <royal_screwup21> but what is this function? I get that it just increments the input by 1...but what if it was subtraction
11:08:57 <royal_screwup21> ((-) <$> Just 1)
11:09:04 <c_wraith> why would that change anything?
11:09:19 <dminuoso> royal_screwup21: Think back about liftA2
11:09:20 <royal_screwup21> does it substract one from the input, or is the input subtracted from 1
11:09:28 <c_wraith> > (-) <$> Just 1 <*> Just 2
11:09:30 <lambdabot>  Just (-1)
11:09:50 <c_wraith> > (-) 1 2
11:09:52 <lambdabot>  -1
11:10:02 <c_wraith> its just a function.
11:10:13 <royal_screwup21> ok, so it's a function, like: 1 - _, where it's waiting for "_"
11:10:49 <dminuoso> royal_screwup21: If it helps, you could also do it with one extra hoop:
11:11:04 <dminuoso> pure (-) <*> (Just 3) <*> (Just 4)
11:12:11 <royal_screwup21> dminuoso: no I mean, what if I wanted to switch the order of subtraction? (-) <$> Just 1 <*> Just 2   --> this is basically doing 1 -2, what if I wanted an expression that does 2 -1
11:12:22 <dminuoso> royal_screwup21: then you flip the arguments.
11:12:30 <dminuoso> royal_screwup21: squint a bit and imagine <$> and <*> away
11:12:34 <dminuoso> then it just looks like function applicatoin right?
11:13:01 <tiny_lambda> sclv and Solonarv, thank you very much for your help - i will continue tomorrow
11:13:12 <royal_screwup21> yup...
11:14:13 <royal_screwup21> was just slightly bothered that <$> "tacks" the subtraction operator the right of 1...it could have just as easily put it to the left
11:14:29 <Solonarv> royal_screwup21: no, it couldn't
11:15:13 <c_wraith> its type actually prevents that.
11:17:33 <royal_screwup21> hmm okay...so I'm starting to see how <*> can be used with <$> together
11:18:50 <c_wraith> if I had a bunch of time, I'd try to put together a bunch of tutorials on type-driven reasoning. types contain so much information that isn't immediately obvious, and there's a lot of advantages in learning how to extract that information
11:24:31 <dmwit> > pure (=) <*> Just 3 <*> Just 4
11:24:33 <lambdabot>  <hint>:1:7: error:
11:24:33 <lambdabot>      parse error on input ‚Äò=‚Äô
11:24:33 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
11:24:36 <dmwit> > pure (-) <*> Just 3 <*> Just 4
11:24:38 <lambdabot>  Just (-1)
11:24:45 <dmwit> > pure (flip (-)) <*> Just 3 <*> Just 4
11:24:47 <lambdabot>  Just 1
11:46:45 <royal_screwup21> is <|> part of haskell syntax?
11:48:37 <Celestia`> > :t (<|>)
11:48:39 <lambdabot>  <hint>:1:1: error: parse error on input ‚Äò:‚Äô
11:48:47 <Solonarv> royal_screwup21: no, it's just a regular operator
11:48:49 <Celestia`> ah, it's unable to
11:48:56 <Solonarv> (that happens to be defined in the standard library)
11:49:13 <Solonarv> Celestia`: lambdabot doesn't accept arbitrary ghci commands after the >
11:49:19 <Solonarv> :t (<|>)
11:49:20 <lambdabot> Alternative f => f a -> f a -> f a
11:49:40 <Celestia`> Oh, I see.
11:50:19 <Celestia`> why the hell am I 'Celestia`' tho
11:51:40 <CelestialLake> Way better.
12:02:33 <ph88> hi mniip
12:08:11 <Cheery> could use some advice with this https://www.doc.ic.ac.uk/exact-computation/Haskell
12:08:42 <Cheery> studying it and wanting to understand the 'sem' and 'app' functions, but they got this silly decision-variable -stuff in place
12:08:56 <Cheery> making it really hard to understand what's actually going on there.
12:09:22 <Cheery> well.. started opening it up.
12:23:37 * hackage valid 0.1.0.0 - Type isomorphic to `Either` with `Applicative` instance which combines errors  https://hackage.haskell.org/package/valid-0.1.0.0 (MatthewFarkasDyck)
12:27:07 <cocreature> huh, why do we need yet another validation package
12:28:00 <Solonarv_> I was wondering the same
12:29:38 <Solonarv> it's not even different, just a strict subset of validation
12:30:13 <Solonarv> ah, but validation has a few more dependencies (notably, lens)
12:32:07 <Ariakenom> lens comic that you've probably seen https://ro-che.info/ccc/23
12:33:24 <cocreature> Solonarv: "either" is bit more lightweight on dependencies
12:33:52 <cocreature> not as lightweight as that package but I‚Äôm not convinced that‚Äôs a sufficient reason to add yet another package
12:39:59 <lyxia> This guy has done this for a lot of packages.
12:54:12 <koz_> Could someone explain to me the humour behind this comic? https://ro-che.info/ccc/10
12:55:01 <cocreature> koz_: a multi-argument function call, clearly not curried :)
12:55:10 <koz_> Ah.
12:55:13 <koz_> Derp, thanks.
13:02:18 <srnty> join ##C
13:03:26 <kadoban> I don't wanna
13:04:35 <dyl> Can anyone recommend a library that just does reasonably sane pretty printing of a Show instance?
13:04:41 <dyl> `pretty` has nice combinators but I'm lazy.
13:06:15 <lyxia> dyl: pretty-simple and pretty-show?
13:07:19 <dyl> Do you recommend one or the other in particular?
13:10:45 <Cheery> I got a thing like type Vector     = (Integer, Integer)
13:10:58 <Cheery> how to give this a class instance?
13:11:23 <royal_screwup21> anyonoe know of any good tutorials that teach you how to build a parser from the ground up? Almost every tutorial I've seen uses parsec.
13:12:56 <lyxia> dyl: pretty-simple for the nice README and the colors
13:14:21 <royal_screwup21> IS <*> a combinator?
13:14:48 <royal_screwup21> > Just (\x -> x+1) <*> Just 3
13:14:50 <lambdabot>  Just 4
13:15:13 <geekosaur> "combinator" is a bit slippery
13:16:38 <isovector1> Cheery: you're going to have a bad time doing it like that. make a new type for it and give that the instance
13:16:42 <royal_screwup21> in the context of parsers
13:17:10 <cocreature> dyl: I‚Äôve never used pretty-simple so can‚Äôt comment on that but pretty-show has certainly be quite useful for me
13:18:07 * hackage reflex-sdl2 0.3.0.0 - SDL2 and reflex FRP  https://hackage.haskell.org/package/reflex-sdl2-0.3.0.0 (SchellScivally)
13:19:48 <Solonarv> ooh now that's a package that gets me interested
13:24:23 <zuserm> Let's say I have to local packages a and b, with a depending on b. I can build them both in the same sandbox with cabal install a/ b/, but I can't figure out how to get a repl to work for a. 
13:25:05 <Solonarv> zuserm: I have no idea how cabal sandboxes work, but I would recommend switching to cabal's nix-style builds
13:26:14 <zuserm> Solonarv: do you know a tutorial for that?
13:26:55 <Solonarv> zuserm: I just look at the official docs when I don't remember how to do something
13:27:14 <royal_screwup21> in this defintion of the moand type class https://wiki.haskell.org/Monad where did the "a" come from??
13:27:29 <royal_screwup21> the typclass is parameterized on m
13:27:53 <geekosaur> royal_screwup21, you can think of the typeclass as being partially applied
13:28:02 <lyxia> royal_screwup21: it's a parameter of each function
13:28:10 <MarcelineVQ> which a
13:28:13 <Solonarv> zuserm: https://cabal.readthedocs.io/en/latest/nix-local-build.html#configuring-builds-with-cabal-project
13:28:14 <geekosaur> for example, you have "instance Monad IO where", but there are no values of type "IO"; they're always "IO x" for some x
13:28:23 <royal_screwup21> fo eg:   (>>=)  :: m a -> (  a -> m b) -> m b
13:28:35 <zuserm> Solonarv: thanks
13:28:55 <royal_screwup21> oh man...
13:29:02 <geekosaur> what this accomplishes is ensuring that a Monad implementation can't be conditionalized on the type a
13:29:13 <geekosaur> because that would violate the Monad laws
13:34:53 <dminuoso> royal_screwup21: It may be best to fix `m` to some specific instance. The general form is rather abstract. Besides, you will gain intuition passively by simply using the respective instances.
13:35:18 <dminuoso> Say by fixing `m ~ IO` or `m ~ Maybe~
13:35:21 <dminuoso> Say by fixing `m ~ IO` or `m ~ Maybe`
13:44:31 <dminuoso> royal_screwup21: Anyway. Regarding your question earlier, http://dev.stephendiehl.com/fun/002_parsers.html is a pretty good tutorial. It has some minor "errors" but overall it gives a good introduction into making simple parsers from scratch.
13:44:59 <royal_screwup21> oh cool thanks!
13:45:28 <royal_screwup21> "We'll effectively ignore the gritty details of parsing and lexing from now on." lol
13:45:41 <royal_screwup21> but yeah it looks like it does some stuff from scratch at least
13:53:44 <zuserm> I can't figure out how to get cabal new-install to work.
13:53:58 <sclv> zuserm: which system, and what are you trying to do?
13:54:14 <sclv> new-install is just for installing binaries fwiw
13:54:22 <sclv> you just build your projects with new-build for lib deps
13:55:45 <zuserm> sclv: I'm trying to install a executable that I'm building against local versions of diagrams-*
13:56:32 <royal_screwup21> %sum x y = (+); sum 3 4
13:56:40 <royal_screwup21> % sum x y = (+); sum 3 4
13:56:40 <yahb> royal_screwup21: ; <interactive>:25:16: error:; Parse error: module header, import declaration; or top-level declaration expected.
13:57:17 <sclv> ok and whats the problem?
14:01:47 <MarcelineVQ> royal_screwup21: did you have a question about sum there?
14:01:52 <zuserm> sclv: cabal new-install  exits successfully but doesn't actually do anything
14:01:55 <royal_screwup21> could someone give me a pointer or two on why this doesn't work? https://repl.it/languages/haskell (+) is of type:: a-> a->a. My thought process is takes in two arguments and returns their sum
14:02:10 <royal_screwup21> MarcelineVQ: ah yes
14:02:28 <royal_screwup21> https://repl.it/languages/haskell
14:02:31 <Solonarv> royal_screwup21: your link doesn't point to any code
14:02:37 <royal_screwup21> whoops https://repl.it/repls/SpecializedRealisticDigit
14:02:42 <sclv> zuserm: pass  verbosity flag?
14:03:07 <sclv> also are you sure it hasn't put the executable somewhere that's not part of your standard path?
14:03:20 <zuserm> roya_screwup21: s = (+) or s a b = a + b
14:03:25 <sclv> (note -- you can always just new-build the source dir yourself and manually create the symlink if its too confusing)
14:03:25 <MarcelineVQ> royal_screwup21: you declare sum as taking two arguments, x y, but you don't use them. as written sum takes 4 arguments, two it doesn't use, and two for (+)
14:04:53 <zuserm> sclv: I'm passing --symlink-bindir=., and nothing is showing up.
14:05:22 <royal_screwup21> MarcelineVQ: oh...I remember reading that if a function foo has just one argument,  and you want to apply another bar to it, you can do: foo = bar ...guess it works only for 1 arg; not all functions are commutative
14:05:25 <sclv> hrm maybe it doesn't like that path
14:05:33 <sclv> like its too relative
14:05:51 <Solonarv> zuserm: what are your cabal files, can you upload them somewhere?
14:06:03 <Solonarv> (gist.github.com allows multiple files)
14:06:43 <Cheery> is there shorthand for this? if mrefine n then Just $ ExpM n e else Nothing
14:07:12 <Solonarv> Cheery: 'ExpM n e <$ guard (mrefine n)'
14:07:41 <Cheery> mm.. ok.
14:08:26 <zuserm> sclv: using abs path didn't help
14:08:47 <Cheery> now I got this: rapp1 :: Lft -> Expression -> Maybe Expression
14:08:59 <Solonarv> zuserm: can you post your cabal files? specifically, blahblah.cabal and cabal.project
14:10:53 <Cheery> got lft1,n1, lft2,n2, lft3,n3, and wanting to try those on (rapp1 lft expr), and return result n1(dem(rapp1 lft1 expr) if successful
14:10:59 <zuserm> Solonarv: https://gist.github.com/bacchanalia/4a57ed82058d9e461d619853cda5c3cf
14:11:00 <Cheery> if all fails, then want to do sem (semdem e)
14:12:17 <Solonarv> zuserm: what happens if you run 'cabal v2-build -v' ?
14:12:18 <Cheery> well.. could just write a chaining combinator there.
14:14:30 <zuserm> Solonarv: new-build is working, it's just new-install that isn't.
14:15:14 <Solonarv> zuserm: hm, odd
14:15:17 <zuserm> I'm just going to give up and manually link it for now.
14:15:26 <Solonarv> yeah
14:15:46 <Solonarv> if you just want to it you can also simply 'cabal v2-run'
14:21:00 <zuserm> Solonarv: true
14:21:28 <Solonarv> I don't have much experience with v2-install, it doesn't really work on windows currently :/
14:23:23 <MarcelineVQ> royal_screwup21: I'm not quire sure what you mean, you seemed to have intended to write sum = (+) but this is not sum x y = (+) as zuserm said above. sum x y = (+) is like sum x y = (\a b -> a + b) which is like sum x y a b = a + b
14:24:09 <Phyx-> v2-install will be supported in the next release
14:24:22 <Phyx-> it's currently supported in master already
14:25:12 <Solonarv> oh, that;s good to hear
14:25:33 <Solonarv> I tried building from source a few days ago but my poor laptop couldn't handle it
14:27:00 <MarcelineVQ> royal_screwup21: If I've misunderstood what you're asking let me know, it's not entirely clear to me what you want sum to do
14:27:42 <Phyx-> Solonarv: I build the nightlies from source every night, https://www.myget.org/feed/mistuke/package/nuget/cabal-head the binaries are published there and can be installed with chocolatey
14:27:55 <MarcelineVQ> bbiab
14:28:07 <Solonarv> oooh very nice!
14:31:15 <aztex> I am writing a recursive function like foldmap over vectors something like this: https://paste.ofcode.org/aNNyWifiu93jp7NNa9Euf4
14:31:25 <aztex> But I am running into a stack overflow
14:31:40 <aztex> it looks like I am accumulating thunks somewhere
14:32:08 <aztex> Can someone help me by pointing where is the thunk accumulation happenning?
14:39:20 <lyxia> aztex: line 9 maybe?
14:39:59 <lyxia> > let f x = x where ((), ()) = undefined in f ()
14:40:01 <lambdabot>  ()
14:40:03 <lyxia> > let f x = x where !((), ()) = undefined in f ()
14:40:04 <lambdabot>  *Exception: Prelude.undefined
14:40:08 <ziman> isn't it caused by always recursing on left and right, even in the base case?
14:40:31 <lyxia> oh that's a good point
14:41:46 <aztex> ziman: sorry missing your point
14:42:21 <ziman> gol and gor are evaluated to whnf even if xs is null
14:43:21 <ziman> so recursion will never stop
14:43:44 <ziman> maybe try let-binding gol and gor in the non-null branch
14:44:08 <ph88> hey guys does anyone know what this is ? https://github.com/ekmett/coda
14:44:15 <ph88> is it a new frontend language for ghc ?
14:44:18 <ziman> there may be other reasons why this is misbehaving, though, this was just the most conspicuous to me
14:44:37 <ziman> e.g. whnf not being deep enough
14:50:14 <aztex> ziman: thanks. I was writing foldmap but didn't even use the f function, now when I inspect the base case and apply the function it doesn't overflow
14:51:25 <Solonarv> ph88: "an entertaining series of crashes and confusing error messages", clearly :p
14:51:36 <ph88> clearly
14:53:44 <Solonarv> a very superficial look suggests that it's a standalone language/compiler, not a ghc frontend
15:15:30 <ziman> aztex: yeah, that's a good point :)
15:19:47 <ziman> making up values out of thin air smells after non-termination ;)
15:34:56 <monochrom> The beauty of parametric polymorphism is that you don't even have the tools to make up values out of thin air.  All you can do is make up new ways to non-terminate.
15:41:05 <EvanR> can we have a more positive jargon word for "to non-terminate" :)
15:43:32 <Solonarv> "bottom"
15:43:36 <monochrom> There is "hang", but a vocal minority will make a big fuzz about it being morbid.  There is "diverge", but no one would understand you apart from theorists.
15:44:03 <monochrom> There is the absolutely positive optimistic utopian "live forever", but it is not jargon.
15:44:28 <EvanR> diverge, right
15:45:18 <EvanR> youd think insofar as "con" means negate, converge would work, but it doesnt
15:45:40 <Solonarv> "converge" means "terminate" ;)
15:45:49 <EvanR> analytically diverge would make me think things are going in two directions
15:46:06 <monochrom> But "con" doesn't always mean negate.
15:47:02 <monochrom> For example concurrency and conspire.
15:51:39 <nai> wtf
15:52:07 <nai> when does con mean negate? it means something like "with" in latin
15:52:52 <monochrom> One case I know is "congress is the opposite of progress" >:)
15:55:05 <nai> well that's just a pun :D
15:57:10 <geekosaur> short for "contra"
15:59:19 <geekosaur> this is even more confusing when everyday language likes "co-" as a short form of "with ...", whereas math usually (but not always) uses "co-" in the "contra" sense
15:59:30 <keegans> hello ! i am looking to  find all the possible permutations of a list with potentially repeating elements . so for example, I wish to start with `[("AA", "AB"), ("AB", "BB"), ("B", "AA")]`, and then get all possible organizations of this list INCLUDING repeated portions of variable size length
15:59:47 <nai> geekosaur: in what instance is "con" short for "contra"?
15:59:47 <keegans> so for example `[("AA", "AB"),("AA", "AB"),("AA", "AB"),("AA", "AB")]` is a valid member of that set 
16:00:38 <geekosaur> nai, it's not that common, but consider "pro and con"
16:01:08 <ddellacosta> holy crap, trying to understand how to best integrate exception-handling into a non-trivial Haskell app (in my case a web app) seems like a huge rabbit hole. There really isn'
16:01:15 <ddellacosta> t a ton of consensus, is there?
16:01:35 <geekosaur> not only not a lot of consensus, but also not a lot of ways to boilerplate or automate it
16:01:45 <nai> geekosaur: oh yeah ok; i was talking about con- as a prefix
16:01:49 <ddellacosta> geekosaur: alright, glad to know at least that I'm not completely crazy
16:02:30 <ddellacosta> guess I'll start with figuring out how to best integrate ExceptT ¬Ø\_(„ÉÑ)_/¬Ø
16:03:00 <geekosaur> nai, I've seen it, it's not that common as I said. sometimes the n sneaks in to separate the "o" from another vowel
16:03:22 <geekosaur> but there are no real conventions there
16:03:42 <geekosaur> (alternatives are hyphens, and just jamming them together like e.g. "coend")
16:05:16 <nai> wiktionary doesn't seem to give contra as an etymology for either co- or con- prefixes
16:05:47 <keegans> is it possible to do something like https://stackoverflow.com/a/53158058, but only for lists of size 4 ? 
16:17:30 <fen> can anyone talk me through this example? https://pastebin.com/raw/usXbQeQh
16:19:19 <f_n> can anyone talk me through this example? https://pastebin.com/raw/usXbQeQh
16:19:47 <keegans> if i have `a,b` and i want to get the combinations `a,b,a` and `a,b,b`, what is the best way for me to do this ? [a] -> [[a]]
16:21:16 <EvanR> oy why do they always want to append to the end of a list :)
16:22:34 <f_n> is that called snoc?
16:23:11 <EvanR> when you can reasonably append to either side, theres a snoc
16:23:33 <f_n> but thats as slow as dropFromEnd right?
16:23:48 <EvanR> it isn't reasonable for lists
16:24:04 <EvanR> unless they are really short
16:24:17 <f_n> what if you reverse them first?
16:24:32 <EvanR> try it
16:25:07 <f_n> > % (reverse . drop 5 . reverse) "hello world"
16:25:08 <lambdabot>  <hint>:1:1: error: parse error on input ‚Äò%‚Äô
16:25:13 <f_n> % (reverse . drop 5 . reverse) "hello world"
16:25:13 <yahb> f_n: "hello "
16:25:19 <f_n> seems to work
16:25:29 <EvanR> with benchmarks
16:25:40 <f_n> and then you could do the snoc etc while it was still reversed
16:26:07 <f_n> EvanR: how could any other implementation be faster!? using foldl?
16:26:22 <EvanR> other datastructures can be faster
16:27:47 <f_n> but you could have a (++) that preserved the backwardsness so was just as fast as (++) over the forwards version, as long as there was much done while it was still backwards, whouldnt it eventually be faster
16:28:26 <EvanR> if everything is always backwards, youre good
16:28:31 <EvanR> then you can just use list as normal
16:28:54 <f_n> well what if it was a cofree or free thing instead
16:29:22 <f_n> like, a tree with one of the leafs selected... then you could grow that branch etc and always still point to the leaf
16:29:39 <f_n> but it wouldnt be the same upside down
16:29:53 <f_n> just saying this snoc list thing has legs
16:30:43 <f_n> EvanR: what about this "state encoding fusion" ? https://pastebin.com/raw/usXbQeQh
16:32:00 <EvanR> looks cool
16:32:11 <dmwit> keegans: \xs -> map (\x -> xs ++ [x]) xs
16:32:30 <nai> i'm really liking lambdabot's features. especially pointless and djinn
16:32:59 <keegans> dmwit: ! thank you
16:33:45 <dmwit> keegans: For the previous question, `replicateM 4` should suffice.
16:34:15 <keegans> i'll give it a try -- thanks again
16:34:27 <dmwit> Yeesh, the answers at that question are... awful.
16:34:29 <f_n> EvanR: but will it work? not sure about the datatype wrapper around the function "get". not used to the rewrite "RULES" environment, can it really pattern match on functions by name!? thats pretty impressive 
16:35:54 <dmwit> > [0..] >>= flip replicateM "abc"
16:35:56 <lambdabot>  ["","a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aa...
16:36:18 <f_n> and is the concept a good idea? like "unfolding" a list using get to be passed into a consumer, should be rewritten to a fold over the list, to avoid using get which may be slower than the actual foldable implementation#
16:38:05 <f_n> is the style in introduces, of passing state encoded foldables that have "get" a good idea? allowing functions to be written using "get/state unfold" which translates to a normal fold?
16:38:15 <f_n> is this a reasonable style?
16:41:21 <f_n> guess what its doing is unfolding the get instance into some arbitrary foldable but kind of implicitly just using the Foldable instance of the original container
16:41:49 <f_n> the idea is to allow "unfolding" from state to be as valid as folding, but is that totally redundant!?
16:43:07 * hackage japanese-holidays 0.1.2.0 - Japanese holidays utility  https://hackage.haskell.org/package/japanese-holidays-0.1.2.0 (cohei)
16:46:25 <royal_screwup21> how is concatMap really different from map?
16:46:40 <royal_screwup21> > map (\x -> [(x, x+1)] )  $[1,23]
16:46:42 <lambdabot>  [[(1,2)],[(23,24)]]
16:46:46 <royal_screwup21> concatMap (\x -> [(x, x+1)] )  [1,2,3
16:46:51 <royal_screwup21> > concatMap (\x -> [(x, x+1)] )  [1,2,3]
16:46:53 <lambdabot>  [(1,2),(2,3),(3,4)]
16:46:59 <royal_screwup21> err
16:47:09 <royal_screwup21> > map (\x -> [(x, x+1)] )  $[1,23]
16:47:11 <lambdabot>  [[(1,2)],[(23,24)]]
16:47:25 <royal_screwup21> > concatMap (\x -> [(x, x+1)] )  $[1,23]
16:47:27 <lambdabot>  [(1,2),(23,24)]
16:51:37 <pie___> chrpape ping :P
16:51:37 <jle`> royal_screwup21: the difference is that you can return more than one element per input
16:51:55 <jle`> > concatMap (\x -> [x-1, x+2]) [0,10,20]
16:51:57 <lambdabot>  [-1,2,9,12,19,22]
16:52:35 <jle`> royal_screwup21: but one thing you might be getting at is that yes, it's possible to implement 'map' in terms of concatMap
16:52:46 <jle`> it's also possible to implement filter, and mapMaybe :)
16:52:57 <rotaerk> > [0,10,20] >>= \x -> [x-1, x+2]
16:52:59 <lambdabot>  [-1,2,9,12,19,22]
16:53:41 <jle`> instance Monad [] where (>>=) = flip concatMap
16:53:43 <royal_screwup21> ah I see
16:54:10 <jle`> you can kind of order these sort of list functions in a "can implement the other" hierarchy
16:54:15 <royal_screwup21> I'm trying to wrap my head around bind:: defined here http://dev.stephendiehl.com/fun/002_parsers.html
16:54:27 <jle`> foldr > concatMap > mapMaybe > (filter, map)
16:54:31 <rotaerk> wrap your mind around bind *for one specific type at a time*
16:54:40 <rotaerk> e.g. understand bind for lists for now
16:54:43 <im0nde> https://www.youtube.com/watch?v=RqvCNb7fKsg
16:55:01 <rotaerk> after a few types you'll start to develop an intuition for the generalization
16:55:31 <royal_screwup21> cool okay :)
16:56:24 <royal_screwup21> :t >>=
16:56:25 <lambdabot> error: parse error on input ‚Äò>>=‚Äô
16:56:39 <boj> :t (>>=)
16:56:40 <lambdabot> Monad m => m a -> (a -> m b) -> m b
16:58:18 <royal_screwup21> ok, so the monad instance for lists is a concatMap
16:58:37 * hackage fix-imports 2.2.0 - Program to manage the imports of a haskell module  https://hackage.haskell.org/package/fix-imports-2.2.0 (EvanLaforge)
17:00:43 <rotaerk> royal_screwup21, one way to think of bind is as a map, followed by a join.  compare the above signature to:
17:00:46 <rotaerk> :t map
17:00:47 <lambdabot> (a -> b) -> [a] -> [b]
17:00:54 <rotaerk> :t fmap
17:00:55 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:01:59 <rotaerk> imagine b being equal to f c, so the type becomes:  Functor f => (a -> f c) -> f a -> f (f c)
17:02:24 <rotaerk> that looks similar to (=<<), except the final result has two fs in it
17:02:45 <rotaerk> the second step of bind, the join, converts an `m (m a)` into an `m a`
17:03:44 <rotaerk> in the case of lists, join takes a list of lists and collapses them into a single list
17:04:12 <royal_screwup21> yup I see it...
17:05:11 <royal_screwup21> I have to play around with record syntax to see how the "parse" in newtype Parser a = Parser { parse :: String -> [(a,String)] } works...
17:05:50 <rotaerk> one thing that's slightly confusing about record syntax is that the type of the fields is incomplete
17:06:11 <ski> it would possibly be simpler to first have `type Parser a = String -> [(a,String)]', and then `returnP :: a -> Parser a' and `bindP :: Parser a -> (a -> Parser b) -> Parser b'
17:06:14 <rotaerk> the type of parse isn't `String -> [(a,String)]`, but rather `Parser a -> String -> [(a, String)]`
17:06:31 <ski> that way, you don't have to deal with the `newtype' data constructor and selector noise
17:06:57 <royal_screwup21> ah gotcha
17:07:02 <ski> (but if you want an instance of `Monad', defining the methods `return' and `(>>=)', you'll have to make a new data type)
17:07:41 <ski> (yea, record syntax is confusing and inconsistent)
17:07:57 <royal_screwup21> so basicaly, Parser is a contructor and its fields is a function that takes a string and gives out [(a,String])
17:08:03 <royal_screwup21> basically*
17:08:11 <royal_screwup21> field
17:08:15 <ski> s/its fields/its (only) field/
17:08:20 * ski nods
17:09:37 <ski> royal_screwup21 : <http://www.willamette.edu/~fruehr/haskell/seuss.html>
17:10:26 <royal_screwup21> lol
17:10:53 <royal_screwup21> I think the tradition view though is that Parser is a thing that takes in a stream of tokens, and converts it to an AST...
17:11:14 <ski> doesn't have to be an AST, though that's the most common case
17:11:18 <dmwit> Sure, no conflict between that traditional view and the one being espoused here.
17:11:32 <Solonarv> royal_screwup21: in this case the "stream of tokens" is String
17:11:48 <ski> `a' could be picked as whatever particular parsing result type you like, e.g. an AST type
17:11:57 <royal_screwup21> Solonarv: hmm...it's interesting because it kind of means you're tokenizing and parsing at the same time...
17:12:25 <royal_screwup21> although idk, I've barely started the tutorial
17:12:28 <Solonarv> an alternative view is that the tokens are simply individual characters
17:12:40 <ski> instead of `[Char]', you could use `[tok]', for some type `tok' (which could be set to a custom token type, say)
17:12:51 <ski> `Char' is just for simplicity
17:13:09 <royal_screwup21> ski: ah but what if a tok is more than one character long? Like for eg: "func" or "class"
17:13:10 <Solonarv> (and indeed several parser-combinator libraries do make this generalization)
17:13:46 <ski> royal_screwup21 : so you preprocess your `[Char]' (or `Text' or whatever) into a `[tok]', before feeding it to your parser
17:13:46 <royal_screwup21> but yeah they're simplifying with chars I guess
17:13:58 <rotaerk> hmm why is `type Parser a = String -> [(a, String)]` and not `type Parser a = String -> Maybe (a, String)`
17:14:24 <ski> ambiguous parsers is the first answer
17:14:28 <rotaerk> ah
17:14:51 <ski> the second is to allow more backtracking
17:14:55 <rotaerk> interesting
17:15:24 <rotaerk> I made a Parsec-like thing in C# before, and I didn't think to do that
17:15:25 <ski> (the second can be a double-edged sword. and the first isn't done that often in computer languages. as opposed to fragments of natural language, say)
17:16:37 <ski> (the second being related to the whole story with `try' and `(<|>)' in parsec, e.g.)
17:17:46 * ski thinks `try' comes close to being as annoying (in the respective contexts), as the cut, in logic programming
17:20:12 <royal_screwup21> out of curiosity, why doesn't haskell have an inbuilt lru cache to cache the outputs of a function against previously encountered inputs? Seeing as everything is all pure with no side effects, I think it's plausible to have that functionality...
17:20:37 <royal_screwup21> python has a native  @lru_cache
17:21:21 <royal_screwup21> s/plausible/useful
17:21:34 <kadoban> You can do it in a library, doesn't have to be built in. There's memoization libraries, though I don't know of one that's LRU.
17:22:56 <kadoban> If you're asking why it isn't done automatically, turns out figuring out when that would improve things is hard to do.
17:24:03 <royal_screwup21> kadoban: hmm I see...yeah, I was thinking of a utility function where  the programmer could opt in to use it if they wanted
17:24:23 <kadoban> Yeah, there's a few libraries for that. They're pretty handy once in a while.
17:26:16 <ski> (fwiw, in Mercury, there's a pragma you can put on a predicate/function, to request such memoization/tabling. (i think some Prolog systems also do this))
17:34:07 <royal_screwup21> so this compiles on my machine: https://repl.it/repls/ScaredUnpleasantTags I then ran runParser  item "abcd", exepcting to get 'a', but it error out "parse error"
17:34:27 <royal_screwup21> I'm not totally sure why
17:34:50 <royal_screwup21> item is parser parameterized on char, and so should return [('a', "bcd")]
17:35:47 <royal_screwup21> ah nvm I figured it out
17:35:56 <royal_screwup21> I haven't consumed the entire input stream, so the error is valid
18:04:00 <f_n> is there anyone here that knows how to use DerivingVia, that could help refactor this;
18:04:22 <f_n> from nonempty to [], using DeriveVia of something
18:04:46 <f_n> https://pastebin.com/raw/i7yc99R8
18:06:55 <f_n> not really sure how DerivingVia works in order to do that
18:09:45 <f_n> basically all the defaults are available to anything providing any of stream/linear/stack varients of get/set
18:10:10 <f_n> does this mean it should DeriveVia a datatype that has those methods?
18:22:18 <reallymemorable> can anyone see what im doing wrong in my bottommost function?
18:22:19 <reallymemorable> https://paste.ofcode.org/37EDF9PJ8TVwgrTbJZS4eyk
18:22:32 <reallymemorable> runWeb outputs  a list of strings
18:22:46 <reallymemorable> and I am trying to append that other url string to the front of each
18:29:03 <dmwit> reallymemorable: No, runWeb does not output a list of strings. It doesn't return a list of strings either.
18:29:24 <dmwit> It is an IO action which Maybe computes a list of strings.
18:29:55 <reallymemorable> So i need to not make it an IO  action?
18:30:11 <dmwit> (by the by, `do { thing <- targetUrl; return thing }` is *exactly* the same as `targetUrl`, so the whole `runWeb` definition is completely redundant)
18:30:23 <dmwit> No, you need to say how to handle the Maybe-ness.
18:30:44 <dmwit> And how to handle the fact that there are multiple URLs, not just one.
18:31:12 <dmwit> For example, you could do something like this:
18:32:06 <dmwit> `produceStateLinks = do { murls <- targetUrl; case murls of { Nothing -> return {- TODO -}; Just urls -> return (map ("https://"++) urls) } }
18:32:09 <dmwit> `
18:33:15 <dmwit> I stand by my suggestion on SO to read sigfpe's excellent IO tutorial, too.
18:34:18 <reallymemorable> ok thank you
18:36:16 <royal_screwup21> > foo = \x -> concatMap (\(a, b) -> (a+1, b+1)) x
18:36:18 <lambdabot>  <hint>:1:5: error:
18:36:18 <lambdabot>      parse error on input ‚Äò=‚Äô
18:36:18 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
18:37:11 <f_n> here are the list instances, to go with the Nonempty ones above; https://pastebin.com/raw/Yk9zj0Lv
18:37:16 <royal_screwup21> I have a list of tuples, each consistion of two nums. I want to incremement both by one
18:37:22 <royal_screwup21> consisting*
18:37:48 <royal_screwup21> > foo = \x -> map (\(a, b) -> (a+1, b+1)) x
18:37:50 <lambdabot>  <hint>:1:5: error:
18:37:50 <lambdabot>      parse error on input ‚Äò=‚Äô
18:37:50 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
18:38:17 <royal_screwup21> it compiles on my ghci :(
18:38:33 <f_n> > @let foo = map (\(a, b) -> (a+1, b+1))
18:38:35 <lambdabot>  <hint>:1:1: error: parse error on input ‚Äò@‚Äô
18:38:50 <f_n> > let foo = map (\(a, b) -> (a+1, b+1))
18:38:52 <lambdabot>  <no location info>: error:
18:38:52 <lambdabot>      not an expression: ‚Äòlet foo = map (\(a, b) -> (a+1, b+1))‚Äô
18:39:08 <f_n> % let foo = map (\(a, b) -> (a+1, b+1))
18:39:08 <yahb> f_n: 
18:39:09 <royal_screwup21> > let foo = \x -> map (\(a, b) -> (a+1, b+1)) x
18:39:11 <lambdabot>  <no location info>: error:
18:39:11 <lambdabot>      not an expression: ‚Äòlet foo = \x -> map (\(a, b) -> (a+1, b+1)) x‚Äô
18:39:27 <royal_screwup21> let foo = \x -> map (\(a, b) -> (a+1, b+1)) x
18:39:36 <royal_screwup21> > let foo = \x -> map (\(a, b) -> (a+1, b+1)) x
18:39:37 <lambdabot>  <no location info>: error:
18:39:37 <lambdabot>      not an expression: ‚Äòlet foo = \x -> map (\(a, b) -> (a+1, b+1)) x‚Äô
18:39:44 <f_n> >foo = \x -> map (\(a, b) -> (a+1, b+1)) x
18:39:47 <f_n> > foo = \x -> map (\(a, b) -> (a+1, b+1)) x
18:39:49 <lambdabot>  <hint>:1:5: error:
18:39:49 <lambdabot>      parse error on input ‚Äò=‚Äô
18:39:49 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
18:39:51 <MarcelineVQ> k
18:39:52 <MarcelineVQ> so
18:39:59 <MarcelineVQ> if it didn't work the firsxt 3 times :>
18:40:04 <Solonarv> lambdabot ‚â† ghci
18:40:29 <Solonarv> if you can't remembe how lambdabot works, use yahb instead - that's actually a ghci
18:41:01 <royal_screwup21> % let foo = \x -> map (\(a, b) -> (a+1, b+1)) x
18:41:01 <yahb> royal_screwup21: 
18:41:12 <royal_screwup21> yikes
18:41:14 <Solonarv> there we go!
18:41:21 <f_n> @let foo = map (\(a, b) -> (a+1, b+1))
18:41:22 <lambdabot>  .L.hs:172:1: error:
18:41:22 <lambdabot>      Multiple declarations of ‚Äòfoo‚Äô
18:41:22 <lambdabot>      Declared at: .L.hs:171:1
18:41:34 <royal_screwup21> foo [(3,4), (5,6)]
18:41:40 <royal_screwup21> % foo [(3,4), (5,6)]
18:41:40 <yahb> royal_screwup21: [(4,5),(6,7)]
18:41:52 <royal_screwup21> that works...but if I change it to concatMap it doesn't work
18:42:05 <royal_screwup21> change map to concatMap that is
18:42:15 <Solonarv> royal_screwup21: indeed. why do you think this is?
18:42:17 <f_n> % :t concatMap
18:42:17 <yahb> f_n: Foldable t => (a -> [b]) -> t a -> [b]
18:42:23 <geekosaur> er why would you think that would work
18:42:30 <f_n> you want to cocat the tuples?
18:42:56 <royal_screwup21> I'm trying to make sense of this bind function described here http://dev.stephendiehl.com/fun/002_parsers.html
18:44:56 <ddellacosta> royal_screwup21: what part is not making sense? I think it's not clear to folks what exactly you are confused by
18:45:58 <royal_screwup21> so parse p s return a list of tuples...
18:46:24 <royal_screwup21> bind p f = Parser $ \s -> concatMap (\(a, s') -> parse (f a) s') $ parse p s ...the first "s" to be seen is that list of tuples right?
18:46:29 <royal_screwup21> ^ this one
18:46:45 <royal_screwup21> err it trims spaces
18:46:45 <MarcelineVQ> royal_screwup21: importantly the type of parse is: parse :: Parser a -> (String -> [(a,String)])
18:46:53 <f_n> trying to simplify these instances using DerivingVia is possible ? https://pastebin.com/raw/i7yc99R8 , https://pastebin.com/raw/Yk9zj0Lv
18:47:30 <royal_screwup21> MarcelineVQ: yup...it gives out a [(a, String) ]
18:48:19 <royal_screwup21> hmm actually nvm I think I got it
18:55:26 <p0a> Hello is there a way to pattern match half the arguments of a symmetric function?
18:55:56 <p0a> I.e. I want f x y == f y x and I want to pattern match `f A B = True' only; not `f B A = True'.
18:56:02 <ski> make a catch-all (recursive) defining equation at the end ?
18:56:25 <p0a> What if I also have a default f _ _ = False
18:56:45 <ski> perhaps you could sort the inputs first ?
18:57:09 <p0a> right, it'd require Ord. Okay, just wondering 
18:57:25 <ski> @type (liftA2 . liftA2) (,) min max
18:57:26 <lambdabot> Ord a => a -> a -> (a, a)
18:58:31 <ski> i suppose another hacky way would be to have an extra flag that told you whether you had already swapped or not
18:58:40 <ski>   f = g False
18:58:41 <ski>     where
18:59:02 <p0a> so with an auxiliary function 
18:59:04 <ski>     g _ A B = True
18:59:09 <p0a> yeah you're right -- that is probably the right way to do it
18:59:13 <ski>     g False x y = g True y x
18:59:23 <ski>     g True _ _ = False
18:59:40 <p0a> now is there a right way to abstract away this property?
18:59:52 <ski> it would be nice
18:59:54 <p0a> of being symmetric
19:00:49 <p0a> Symmetric (a -> b)? As a type?
19:01:13 <p0a> no, I mean as a class
19:01:21 <ski> well, i suppose one could consider something like `UnorderedPair a -> b', perhaps
19:01:43 <ski> i don't think a type class would be of much use, here
19:01:47 <p0a> Ok so you're thinking of the argument; don't you mean UnorderedPair a b?
19:02:21 <ski> well, i was assuming the pattern was `f :: a -> a -> b' (for some particular `a' and `b', i'm not assuming `f' is polymorphic in those here)
19:02:31 <p0a> the pattern is f :: a -> b -> c
19:02:52 <p0a> no wait, I'm silly
19:02:59 <ski> but that's basically (uncurrying/tupling) the same as `f :: (a,a) -> b' -- but this allows distinguishing between the different ways to ordering a pair
19:02:59 <p0a> you're right 
19:03:31 <p0a> I guess what I'm asking is, by using flags I can hack a symmetric pattern matching function
19:03:39 <p0a> but if I were to do this to many functions, how can I abstract it?
19:03:54 <p0a> I think you're saying that I should just use an UnorderedPair?
19:03:57 <ski> hence replacing `(a,a)' by some type `UnorderedPair a' (which would probably have to be an abstract type, and i'm not sure how useful in practice that would be (in the absence of say dependent types, or at least quotient types))
19:04:13 <unyu> are there really such things as unordered pairs in programming?
19:04:13 <unyu>  
19:04:13 <unyu>  
19:05:05 <unyu> Defining nontrivial functions that are perfectly symmetric in their arguments is actually hard.
19:05:07 <ski> there are (finite) (sub)sets, which tend to be regarded as unordered (regardless of representation, which typically would have some internal notion of ordering)
19:05:38 <ski> yes, that's probably part of the problem
19:05:52 <unyu> The problem is handling the case when the inputs are inequivalent representations of equal values.
19:06:05 <ski> merely having an abstract data type isn't that much use, if it doesn't compose well
19:06:10 <unyu> Right.
19:07:18 <ski> (well, obviously there are cases where there isn't much of a need of composition. but i think this would be a case where one'd really want useful composition)
19:07:41 <f_n> this encoding of natural numbers uses build/fold fusion! https://pastebin.com/GjFuKa7q
19:07:43 <ski> (s/cases/abstract data types/, for clarity)
19:08:08 <unyu> Is there a Haskell library for finger-tree-like data structures that is parametric on the number of knuckles in a finger. Maybe it could be a higher-kinded type parameterized by the node type and the finger type.
19:09:44 <f_n> sorry, its easier to read the raw version; https://pastebin.com/raw/GjFuKa7q
19:10:55 <unyu> It takes a Haskeller to actually want to use Peano naturals...
19:11:28 <f_n> unyu: you mean, "data EdgeTree a b = Edges [(a,EdgeTree a b)] | Leaf b" ?
19:11:34 * ski doesn't see `Church' used there
19:12:18 <unyu> ski: no, you see, the whole point is just to bring the class instances defined there! :-p
19:12:58 <ski> hm, which instances would those be ?
19:13:32 * unyu is joking
19:14:34 <p0a> f_n: toZ has me baffled
19:14:52 * ski was suspecting that, yes
19:14:58 <p0a> f_n: looks like for negative arguments you call toNPlus but then it should error?
19:15:43 <ski> f_n : `| n < 0 = ZMinus $ toNPlus (- n)' ?
19:16:09 <p0a> also `| n < 1 = "error n < 0"' is a misleading error lol
19:16:50 <p0a> (because n == 0 gives an error that n < 0)
19:17:15 <f_n> thanks for catching that typo
19:17:36 <p0a> np 
19:17:42 <ski> where do you see that error ?
19:17:49 <f_n> i see it
19:17:54 <p0a> ski: toNPlus 
19:17:58 <f_n> but is it slow to do negate on an int?
19:18:12 <f_n> should it have a different `f' that does +1 until it reaches 0 ?
19:18:15 <p0a> ski: If `toNPlus' assumes n /= 0 then I guess it's fine 
19:18:18 <ski> ok, sorry. you meant `toNPlus n | n < 1 = error "toNPlus n | n < 0"'
19:18:27 <p0a> right, I truncated it
19:18:32 * ski was thrown off my the mismatching error string
19:18:37 <p0a> hehe
19:20:02 <p0a> well you're basically using () as a cons
19:20:07 <p0a> and `Nothing' as a terminator
19:20:18 <p0a> so this is implementing positive integers as lists right?
19:20:29 <ski> i suppose i might use e.g. `error ("toN " ++ showsPrec 11 n "")', and mutatis mutandis for the other case
19:20:39 <ski> not only positive
19:20:47 <p0a> well the negative integers are implemented by a flag 
19:21:14 <ski> (no Grothendieck construction ..)
19:21:23 <p0a> I'm just saying that it's a lot of fluff for what is basically [[[]]] == 2
19:21:41 <ski> no, `[(),()]', rather
19:21:52 <ski> it's not `Mu []'
19:22:01 <p0a> Right 
19:22:16 <f_n> ski: the imports are from https://gist.github.com/fen-hs
19:22:23 <f_n> loop is from Church
19:22:36 <ski> f_n seemed to suggest that perhaps one'd get some loop fusion for this that would be worthwhile
19:22:47 <ski> f_n : ok, i was wondering. ty
19:23:39 <p0a> alrihgt, I guess all that is more than I can handle then 
19:23:59 * ski idly wonders whether f_n wants to do an alternative prelude
19:24:02 <p0a> anyway, thank you for the chat and help
19:24:17 <f_n> yeah, instead of like, say doing repeatedly :: Int -> (a -> a) -> a -> a, it would have N as an arg, and it would fold over the [()] and use the build fold fusion
19:25:13 <f_n> this way, the unfold that produces the [()] is only ever done once, and there is no reuse of the arithmetic decriment on an Int 
19:25:53 <f_n> we just reuse the same [()] and fold over it
19:26:34 <f_n> it ensures the calculation of the successive Ints is only done once
19:27:42 <f_n> there is probably also a fast thing resulting from duplicate if the values of the "for loop index" are needed
19:28:18 <f_n> ski: certainly not!
19:29:38 <f_n> hmm, better to give the correct link to the gists! https://gist.github.com/fen-hs
19:29:52 <f_n> oh, nvm
19:30:27 <f_n> and the instances from; [01:46] <f_n> trying to simplify these instances using DerivingVia is possible ? https://pastebin.com/raw/i7yc99R8 , https://pastebin.com/raw/Yk9zj0Lv
19:34:55 <f_n> ski: slightly worried about using these Nat encodings everywhere though. is that reasoning about the reuse a valid justification?
19:35:37 <unyu> btw why does haskell still need the ‚Äúerror‚Äù function when it has such fancy types?
19:36:06 <f_n> yes!
19:36:32 <Cale> unyu: Well, firstly, it doesn't have sufficiently fancy types to actually express every condition one might want.
19:36:36 <unyu> I understand having IO exceptions. But I don't understand having fancy types *and* still needing to guard against invalid inputs for ordinary pure functions at runtime.
19:36:38 <f_n> oh, why...
19:37:40 <Cale> It's Turing complete, so you might as well have a way to say "okay, I know at this point that things have gone wrong", rather than just looping forever as you're allowed to do
19:38:01 <unyu> Cale: Standard ML has less fancy types than even Haskell 98, and I have managed to write error-free (well, in SML it's called ‚Äúraise‚Äù rather than ‚Äúerror‚Äù, but same difference) implementations of nontrivial data structures.
19:38:23 <Cale> Sure, there's nothing preventing you from doing the same.
19:38:37 <unyu> All of this is perfectly doable in Haskell 98, not to mention Haskell as used today.
19:39:01 <f_n> corrected the typo; https://pastebin.com/gdHKZXFE
19:39:52 <f_n> unyu: you think it should use Maybe to catch the exceptions?
19:40:06 <Cale> unyu: For example, the property that an integer is nonzero is hard to express at the type level, and even if it were reasonably easy, you might not want to deal with it that way just to be able to use `div` for example.
19:40:40 <unyu> f_n: Nah, you think super hard how to design your data structures so you don't need spurious case analyses. For example, pairing heaps should not be allowed to be empty.
19:40:59 <f_n> eh?
19:41:24 <unyu> Cale: Okay, I'm trying to be reasonable. Of course I understand the division by zero exception.
19:41:58 <unyu> (Although I wouldn't mind simply having an unspecified result.)
19:43:16 <Cale> I'd usually much rather be made aware that there is a problem than having my program just continue and produce garbage.
19:43:52 <unyu> f_n: As in, the smallest pairing heaps should be singletons. A key invariant of pairing heaps is that child heaps aren't empty. So just don't have empty heaps in the first place. If you have a type of nonempty heaps, creating a type of potentially empty heaps is trivial: Maybe the original type.
19:44:07 <Cale> error is for those exceptions one would usually rather not catch, for cases that ought never to happen unless some assumption that your program was based on fails.
19:44:40 <Cale> Anything that can go wrong will, though.
19:45:01 <Cale> However, pattern match failure is often a better alternative when you can get it
19:45:36 <Cale> Like, using head is misguided when you could write (\(x:_) -> x), and get a nice error message with a line number in it when the pattern match fails.
19:46:10 <Cale> There are still a few idiomatic places where I'll use head though, but there aren't so many of those.
19:46:22 <Cale> map head . group . sort  is one of them
19:47:21 <Cale> (It's safe because group only ever produces a list of nonempty lists)
19:47:36 <Cale> This could be handled by use of a more precise type though
19:48:31 <Cale> It's just a matter of whether we really want a separate type for nonempty lists.
19:48:41 <f_n> certainly do!
19:48:46 <Cale> Sometimes, for sure
19:49:02 <f_n> oh, you mean in the type signature of group
19:49:04 <f_n> hmm...
19:49:13 <f_n> could see how that could be confusing
19:49:48 <f_n> but then, if it better expresses the predicable behaviour it might be worth it
19:49:52 <Cale> group :: (Eq a) => [a] -> [Nonempty a] would be more accurate
19:50:07 <Cale> but then it's more annoying to put the pieces back together again
19:50:21 <f_n> and then the user says "damn, whats that Nonempty type, how do i pattern match on it"
19:50:28 <Cale> In the case where we're doing map head, it would be fine
19:50:58 <f_n> but then head would have to take [] or Nonempty
19:51:04 <f_n> wouldnt it be better to use; https://gist.github.com/fen-hs/9772c2ce27a355984add2e5b7d352fbb#file-fifo-hs-L40
19:51:43 <f_n> could write a polymorphic "head" using that
19:52:20 <f_n> \(x:::xs) -> x :: Stream f => f a -> a
19:52:22 <Cale> It also wouldn't be terrible just to use NE.head
19:52:46 <Cale> (there is a separate head for NonEmpty)
19:52:58 <f_n> yeah but then you end up writing the prelude list functions for every new type
19:53:14 <f_n> and importing qualified
19:53:20 <f_n> thats what classes are for!
19:54:15 <f_n> you just write the correct stream, linear or stack instance, where as this forms a class hierarchy, you can always use head as defined above
19:56:35 <Solonarv> 'foldr1 const' -- there's your "generalized head"
19:56:40 <Solonarv> > foldr1 const [1, 2, 3]
19:56:42 <lambdabot>  1
19:57:02 <Solonarv> % foldr1 const $ V.fromList [1, 2, 3, 4]
19:57:02 <yahb> Solonarv: ; <interactive>:34:16: error:; Not in scope: `V.fromList'; Perhaps you meant one of these: `S.fromList' (imported from Data.Set), `M.fromList' (imported from Data.Map), `IM.fromList' (imported from Data.IntMap); No module named `V' is imported.
19:57:07 <Solonarv> bah
19:57:56 <f_n> *Data.Nonempty> (\(x:::xs) -> x) ((Last 0) :: Nonempty Int)
19:57:58 <f_n> *Data.Nonempty> 0
19:58:15 <f_n> *Data.ListInstances> (\(x:::xs) -> x) (empty :: [Int])
19:58:23 <f_n> *** Exception: get1_r Empty
19:58:47 <f_n> not the best error admittedly 
19:59:08 <Cale> Weird naming scheme :)
20:00:07 <f_n> yeah, might have to make the get methods not just synonyms of get_r
20:00:31 <f_n> or, rather, ways of handling the Identity newtype
20:01:30 <f_n> https://gist.github.com/fen-hs/9772c2ce27a355984add2e5b7d352fbb#file-fifo-hs-L89
20:03:58 <f_n> could shift the Get_r constraint down into a DefaultSignature, cant recall if there was a reason not to do so
20:03:59 <f_n> oh, right, it was to force it to use Get_r!
20:03:59 <f_n> that way the traversable default via convert can be used
20:04:48 <f_n> ok, will change that...
20:04:51 <f_n> thanks
20:10:57 <f_n> no, not convinced, if its a Get instance then its a Get_r instance, there is no advantage to allowing the user not to implement this, and only results in excess code duplication
20:11:03 <f_n> ... ?
20:12:01 <f_n> Get_r Identity *
21:54:11 <f_n> ok, changed the defaults to match the style of FIFO_r https://gist.github.com/fen-hs/9772c2ce27a355984add2e5b7d352fbb
21:55:38 <f_n> https://pastebin.com/raw/deR4ZYrW , https://pastebin.com/raw/vZdTF8ui
21:56:06 <f_n> thats the updated list and nonempty instances respectively  
21:57:15 <f_n> they show the 2 different styles of using the defaults, either writing the get/set for stream and then adding last and empty, or the other way round
22:32:40 <maerwald> type families break type inference? https://git.io/fjJe4
22:33:52 <maerwald> 1. they are not used, 2. removing the extension makes the code compile, 3. WTF
22:34:11 <Heffalump> maerwald: it might be flipping MonoLocalBinds
22:35:18 <maerwald> yeah, I get compile error with just MonoLocalBinds as well
22:35:36 <Heffalump> and what about with TypeFamilies and NoMonoLocalBinds?
22:36:04 <maerwald> the builds 
22:36:07 <maerwald> *that
22:36:54 <maerwald> "with NoMonoLocalBinds but type inference becomes less predicatable if you do so"
22:38:31 <maerwald> Heffalump: would you consider this a bug?
22:47:15 <koz_> What's the rule for infix function names?
22:47:46 <MarcelineVQ> could you ask that using different words?
22:49:01 <koz_> I wanna name a function so that said function will be infix. I remember you have to name them specially somehow. How do I do said naming?
22:51:54 <MarcelineVQ> you use "symbol" instead of "small" https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-160002.2
22:53:08 <MarcelineVQ> more info in 2.4 https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-180002.4
22:56:07 <pavonia> koz_: You can also make every normal function infix by using `foo` syntax
22:58:00 <koz_> pavonia: I'm aware of that, thanks.
22:58:04 <koz_> MarcelineVQ: Thank you!
23:29:01 <koz_> Does Data.Finite.finites return the Finites in any particular order?
23:36:48 <koz_> :t Finite
23:36:49 <lambdabot> error:
23:36:49 <lambdabot>     ‚Ä¢ Data constructor not in scope: Finite
23:36:49 <lambdabot>     ‚Ä¢ Perhaps you meant one of these:
23:37:49 * ski thinks, probably not
23:39:20 <koz_> ski: As far as I can tell from GHCi tests, it's ascending.
23:39:22 <koz_> The docs don't say.
23:39:25 <koz_> (they should)
23:39:41 <koz_> The source says ascending.
23:39:48 <koz_> http://hackage.haskell.org/package/finite-typelits-0.1.4.2/docs/src/Data.Finite.html#finites
23:43:17 <koz_> mniip: Maybe a documentation fix?
23:45:01 <f_n> is there a version of ZipWith that uses eitherOr instead of (,) that preserves the length of the longest list?
23:45:33 <Cale> align
23:45:41 <Cale> or alignWith
23:46:10 <Cale> from Data.Align
23:46:18 <Cale> it uses the 'These' type
23:47:26 <nolrai> So I feel like I should know this aready, but I am using a library that needs a small number of changes to compile under 4.8, so how would I tell stack/cabal/ghc to use my local copy instead of the one in the resolver?
23:48:29 <MarcelineVQ> with stack you'd add the path to it to extra-deps in the stack.yaml
23:49:38 <MarcelineVQ> https://docs.haskellstack.org/en/stable/yaml_configuration/#local-file-path
23:50:41 <f_n> Cale: do you think it could work with this? https://pastebin.com/raw/TpcxxB9p
23:51:10 <Heffalump> maerwald: I think it's deliberate, some extensions imply MonoLocalBinds
23:52:17 <Heffalump> https://downloads.haskell.org/~ghc/8.4.2/docs/html/users_guide/glasgow_exts.html#extension-MonoLocalBinds (but I think you already quoted from that)
23:53:41 <f_n> Cale: consume is like build and unfold, and so it has fusion rules like for build, but it can also have them for zip, because it uses the state instead of church encoding
23:54:56 <f_n> there is zip fusion in Data.Stream, but it uses get on the list to produce a stream, instead of accessing the state which produced the list...
23:55:26 <Cale> f_n: Maybe? I don't know if there's any attempt at fusion in align.
23:56:18 <Cale> (though it's rather uncommon to use the list instance there... align is really more useful for Map-like structures
23:56:18 <Cale> )
23:57:33 <f_n> its some form of wizardry this zip fusion 
