00:59:59 <bartavelle> can someone explain to me what the third reduction rule mean in https://en.wikipedia.org/wiki/De_Bruijn_index ?
01:00:16 <bartavelle> I do not understand the 1.1[s'].2[s'] ... notation
01:01:50 <dminuoso> bartavelle: "The application of a substitution s to a term M is written M[s]"
01:02:24 <bartavelle> but what do the dot mean?
01:02:51 <dminuoso> bradparker: Read the paragraph above?
01:02:55 <dminuoso> Err bartavelle.
01:03:01 <dminuoso> bartavelle: It's all described in the text above. ;)
01:03:56 <bartavelle> I understand it is supposed to be all explained here, but I do not understand it :)
01:04:28 <bartavelle> ok I think I get the gist of it, but now I'll have to figure out what it means in my context
01:04:56 <dminuoso> bartavelle: "Formally, a substitution is an unbounded list of term replacements for the free variables, written M1.M2…, where Mi is the replacement for the ith free variable"
01:05:12 <dminuoso> bartavelle: Im intentionally not saying more in the hopes of you making sense of it.
01:05:46 <bartavelle> does taht mean that if there are no free variables the third rule is a noop ?
01:06:49 <bartavelle> I understand the second rule alright, it has this notation, M_1[s]
01:07:05 <bartavelle> it seems to me the third rule has another notation that makes no sense to me
01:07:35 <bartavelle> oh
01:07:38 <bartavelle> but I do understand this
01:08:00 <bartavelle> but that is just giving me the whnf, right ?
01:09:07 <bartavelle> it means I should increase the indices of free variables when injecting the replacement every time I cross a lambda?
02:13:21 <osa1> anyone here have experience with gi-gtk? can I update widgets in a thread or do I need to post an update function somehow? I can't find anything like idleAdd in the library so I'm not sure how to do that
02:15:42 <Enemies> helllo
02:22:05 <ski> hello there, Enemies
02:22:55 <Rembane> I did something with gi-gtk, then used gi-gtk-declarative for the stuff that changed and then lost the code... 
02:23:22 <asthma[m]> is haskell a good fit for async / event bases heavy code?
02:23:32 <Rembane> asthma[m]: Yes. Yes wholeheartedly. 
02:39:10 <osa1> hmm what's the difference between bytestring's hGet and hGetSome? the documentation says hGetSome can return a shorter bytestring than specified, but the same is also the case for hGet
02:39:15 <osa1> so not sure what the difference is
03:04:50 <gentauro> I would love some feedback on this implementation of an `immutable DAG` -> http://dpaste.com/03CZ1NP
03:05:02 <gentauro> is there something that I oversee?
03:05:07 <gentauro> (thx in advance) :-)
03:08:09 <koz_> gentauro: Is there a reason you don't wanna use an adjacency matrix?
03:10:41 <gentauro> koz_: the size of it?
03:11:04 <koz_> How big are we talking here?
03:11:41 <gentauro> koz_: could be as long as desired :-)
03:11:53 <koz_> Then I find your sizing concerns premature.
03:11:58 <koz_> But that's just my 10 cents.
03:11:59 <gentauro> (or how much could be contained in `Data.Map`)
03:12:14 <Rembane> gentauro: Are you doing something general? 
03:12:52 <gentauro> koz_: wouldn't it be the same when choosing between `Int` and `Integer`. By choosing the last, you know it will always survive 
03:13:20 <koz_> gentauro: Do you have a conception of _just how large_ Int is on a 64 bit platform?
03:13:59 <koz_> If you're seriously worried about hitting _that_ limit, I posit that you'll blow your storage requirements _long_ before that becomes an issue.
03:14:06 <[Leary]> `IntMap` is probably notably faster than `Map Integer` too.
03:14:14 <koz_> Unless you're running on a Dyson sphere or something.
03:14:17 <gentauro> koz_: sure, it is so small that it can't contain a `128-bit` from my hash function `fnv1a`. That's how small it is
03:15:21 <koz_> And I posit that this has no bearing on its use as a number, rather than a storage class for arbitrary hash data.
03:15:45 <koz_> I don't even know why you hash (what appears to be) a numeric identifier.
03:17:43 <gentauro> koz_: cos the `hash` algorithm works pretty big numbers. I don't see the point of going from those integers to a string afterwards (what does it bring to the table?)
03:32:37 * hackage console-program 0.4.2.3 - Interpret the command line and a config file as commands and options  https://hackage.haskell.org/package/console-program-0.4.2.3 (AriePeterson)
03:35:00 <asthma[m]> is there a project that aims to replace GHC with a combination of a custom frontend that uses LLVM as a backend?
03:38:02 <Ariakenom> asthma[m]: note that ghc has a llvm backend
03:38:48 <asthma[m]> I saw that and I'm wondering what's the advantage of keeping the GHC backend
03:41:15 <Ariakenom> alos ghc performs many optimizations before generating llvm, so it isn't just a frontend
03:42:55 <gentauro> GHC compiles to `System FC` iirc right?
03:43:05 <gentauro> how would LLVM be able to do that on its own?
03:43:46 <gentauro> https://imgur.com/a/xlzcnhW
03:55:26 <gentauro> asthma[m]: http://laser.inf.ethz.ch/2012/slides/PeytonJones/Inference%20and%20FC.pdf
03:56:13 <gentauro> btw, anybody know why SPJ use Comic Sans in his slides (is he just trolling?)
03:57:05 <__monty__> Maybe in honor of the lambdaman paper?
03:58:57 <gentauro> which paper from Philip Wadler?
04:03:06 <__monty__> Not from, in honor of.
04:06:04 <Rembane> It's the other way around. They use comic sans in the lambdaman paper to reference to SPJ slides.
04:06:11 <gentauro> "We acknowledge the pioneering work done by Simon Peyton-Jones rehabilitating this font in presentations"
04:06:23 <gentauro> http://homepages.inf.ed.ac.uk/hleather/publications/2016_lambdacalculus_wf.pdf
04:06:41 <gentauro> I mean, the paper is from 2016, I wonder how SPJ was inspired by that in 2012 :|
04:06:47 <__monty__> Ah, ok, misremembered. Was having a hard time finding the paper again.
04:07:08 <gentauro> that paper is actually f'd up :|
04:07:14 <gentauro> "paper"
04:07:58 <gentauro> "In addition, this paper goes on to its main results, showing how the Lambda Calculus can be used to easily prove the termination of Leibniz’ Hailstone numbers for all n>0, to show that matrix multiplication is possible in linear time, and to guarantee Scottish independence."
04:08:02 <__monty__> F'd up?
04:08:10 <gentauro> "and to guarantee Scottish independence." <- Ein?
04:08:35 <Rembane> It also has a solution to the backstop. 
04:08:47 <Rembane> And it proves P = NP 
04:15:44 <oo_miguel> I am using the hmatrix library to perform some vector and matrix operations. profiling my code with +RTS -p tells me that 66% of the overall time is spent inside Internal.Devel.check which seems to be related to error checking... 
04:24:03 <__monty__> gentauro: I think you're not reading the paper with the right frame of mind.
04:35:11 <gentauro> __monty__: Probably not, I'm not drunk this early in the morning ...
04:46:10 <__monty__> gentauro: Well if you canned the indignation you'd see it's a humorous birthday gift for Philip Wadler.
04:51:37 * hackage unbeliever 0.9.3.2 - Opinionated Haskell Interoperability  https://hackage.haskell.org/package/unbeliever-0.9.3.2 (AndrewCowie)
05:31:22 <statusfailed> Is there a conventional name in maths for the equivalent of haskell's "fst" and "snd"?
05:33:10 <oo_miguel> first and second element?
05:33:44 <hpc> you generally aren't dealing with tuples in pure math
05:34:32 <statusfailed> hpc: lots of definitions like graphs use them, but typically they name the components
05:34:51 <statusfailed> e.g., " a graph is a tuple (V, E), ..."
05:36:19 <traxex> for a graph G = (V, E), you sometimes see V_G and V_E for "fst G" and "snd G"
05:36:28 <[Leary]> Sometimes they might be called pi_1, pi_2, etc, (pi for projection).
05:36:39 <statusfailed> traxex: guessing you meant G_V and G_E ?
05:36:57 <statusfailed> [Leary]: Is that used much outside category theory?
05:37:05 <statusfailed> I've only seen it in the definition of product
05:37:19 <__monty__> Yes, pi or proj_1 I've seen.
05:37:30 <statusfailed> ok i'll go with pi then, cheers :-)
05:38:26 <[Leary]> Products and projections are used all over the place, as is using pi to denote them. I've only seen _1 and _2 in category theory. For a set of pairs A x B you might instead see pi_A and pi_B, which are better imo.
05:38:30 <traxex> statusfailed: I've seen V(G) and V_G, but maybe G_V is used too
05:38:53 <statusfailed> traxex: oh for some reason that didn't make sense but now it does haha
05:38:55 <traxex> plain V when G is clear from context, and the subscript serves to disambiguate
05:39:07 <statusfailed> I guess I didn't read it as subscript the first time :)
05:39:33 <statusfailed> i'll use pi for now and edit the definition later lol
05:39:40 <statusfailed> it's a bit nasty as is
05:41:43 <__monty__> When we say pi, note that we mean π. If you go with ascii I've only seen "proj."
05:42:46 <statusfailed> __monty__: yup, I assumed you meant \pi :)
05:42:47 <statusfailed> thanks
06:11:49 <ski> traxex : so you meant `V_G' and `E_G' ?
06:13:18 <ski> [Leary] : if `B' happens to be `A', that degenerates to `pi_A' and `pi_A' ...
07:09:55 <moll> I'm seeing a weird bug: A module I'm working on, installed via `cabal install ../Foo` and making use of c-sources, causes linker errors for the functions defined in those c-sources. Is it me or why don't the functions written in C get linked when installing libHSfoo.so? Thanks!
07:10:16 <moll> This is with Cabal v2.2.
07:40:43 <moll> (Moved my linker issue to #hackage)
07:48:30 <fr33domlover> Ughhhh I have the most annoying type error, which looks trivial but I just can't get it fixed lol
07:49:30 <fr33domlover> I grab an aeson Object, pass it to a function that takes an Object, and it keeps complaining about type mismatch between Object and Value
07:49:46 <fr33domlover> Sounds trivial right? I must have accidentally somewhere used Value instead of Object
07:50:04 <fr33domlover> But I keep trying and just can't spot the problem :-.
07:50:06 <fr33domlover> :-/
07:50:51 <tdammers> add more explicit type signatures
07:51:49 <tdammers> follow the expression tree, annotate everything on your path with what you think the type should be. this will lead you to the spot where your expectation doesn't hold.
07:54:46 <fr33domlover> tdammers, yeah I did that ^_^ the types seem so clear though, I wonder if accidentally I wrote code that type-checks but is incorrect
07:55:05 <fr33domlover> Like, in another module
07:55:16 <tdammers> my money is on an implicit toJSON / fromJSON somewhere
07:55:24 <fr33domlover> Hmmm weird, it seems to be the case indeed
07:55:35 <fr33domlover> My fromJSON was causing it yeah!
07:55:40 <fr33domlover> Bu why did it even build
07:55:41 <tdammers> you see, there is an instance JSON Object, so it's easy to accidentally convert an Object into a Value
07:56:07 <tdammers> I thought you were getting a type error from the compiler
07:56:10 <fr33domlover> Maybe one of my many GHC extensions enabled some ambiguous behavior that gets accepted? 
07:56:20 <fr33domlover> tdammers, yeah I was, but in a different module
07:56:20 <tdammers> hard to say without reading the code
07:56:30 <tdammers> oh, OK, makes sense. ish.
07:58:24 <fr33domlover> tdammers, I had data T a = T Object a, and fromJSON v = T <*> withObject "T" pure v <$> parseJSON v. This works. Ealier, I had fromJSON v = flip T <$> parseJSON v <*> withObject "T" pure v
07:58:55 <fr33domlover> tdammers, the latter did make the module build, but I was getting an error in another module about Value/Object mismatch
07:59:31 <fr33domlover> Although T's first parameter is Object, and the function it's passed to takes an Object too :p
07:59:52 <fr33domlover> :t flip
07:59:53 <lambdabot> (a -> b -> c) -> b -> a -> c
08:10:40 <im0nde> Hi, I'm trying to get my head around higher order functions with the following execise: Given a list of arbitrary length and type I would like to write a function that takes the list, one element and a count. It should return true if the list contains this element count times in a row somewhere in it or false otherwise.
08:10:52 <im0nde> Can you give me hints about how the general approach would be?
08:10:59 <im0nde> I don't want a solution, just a start
08:11:32 <im0nde> It should work for empty lists or ones with less elements than "count", in that case it would be obviously false.
08:12:13 <oo_miguel> im0nde: maybe have a look at "filter"
08:12:34 <oo_miguel> ah sorry
08:12:48 <oo_miguel> missed the "in a row"
08:13:17 <im0nde> oo_miguel: yeah, that is important. I don't just want to count the ocurrences.
08:13:26 <fr33domlover> im0nde, idk if this will use high order functions, but, check out isInfixOf
08:13:39 <fr33domlover> There are many ways to write such a function though
08:14:15 <oo_miguel> im0nde: I would use groupBy (==) before filtering
08:14:24 <im0nde> fr33domlover: I'm sure there are. I'm mainly interested in doing it in an "elegant" way. I'm sure I can get it done "somehow" with trying, but I want to learn something
08:15:16 <fr33domlover> im0nde, well one way is indeed groupBy and length; another is replicate and isInfixOf
08:15:21 <fr33domlover> And surely there are more ways
08:17:18 <fr33domlover> im0nde, btw don't hurry with the elegance; you'll gradually figure out elegant solutions as you learn the functions, write code, see othe people's code. I'd say, focus on a correct solution first of all, and look at functions in base and use hoogle and ghci :)
08:17:38 <im0nde> fr33domlover: Ok good advise, thank you!
08:18:38 <fr33domlover> im0nde, btw in Haskell people sometimes write stuff that is very concide but hard to understand, it may be elegant mathematically but less so as source code that people need to work with. Remember that too ^_^
08:18:45 <fr33domlover> *concise
08:19:01 <im0nde> isInfixOf is not imported as a default is it? It doesn't find that function 
08:19:14 <fr33domlover> im0nde, try hoogle.haskell.org
08:19:14 <ski> @index isInfixOf
08:19:14 <lambdabot> GHC.OldList, Data.List, Data.ByteString, Data.ByteString.Char8, Distribution.Simple.Utils
08:19:20 <fr33domlover> It will tell you where to find stuff
08:19:21 <ski> @hoogle isInfixOf
08:19:22 <lambdabot> Data.List isInfixOf :: (Eq a) => [a] -> [a] -> Bool
08:19:22 <lambdabot> GHC.OldList isInfixOf :: (Eq a) => [a] -> [a] -> Bool
08:19:22 <lambdabot> Data.ByteString isInfixOf :: ByteString -> ByteString -> Bool
08:19:24 <im0nde> I see.
08:19:34 <ski> @hoogle+
08:19:34 <lambdabot> Data.ByteString.Char8 isInfixOf :: ByteString -> ByteString -> Bool
08:19:34 <lambdabot> Data.Text isInfixOf :: Text -> Text -> Bool
08:19:34 <lambdabot> Data.Text.Lazy isInfixOf :: Text -> Text -> Bool
08:20:00 <oo_miguel> im0nde: you can use hoogle online as well, to find functions by name or signature
08:20:30 <im0nde> Nice. I got at least one solution working. isInfixOf (replicate 5 7) list2
08:20:32 <ski> @hoogle stripInfix
08:20:33 <lambdabot> Data.List.Extra stripInfix :: Eq a => [a] -> [a] -> Maybe ([a], [a])
08:20:33 <lambdabot> Extra stripInfix :: Eq a => [a] -> [a] -> Maybe ([a], [a])
08:20:33 <lambdabot> Data.List.Extra stripInfixEnd :: Eq a => [a] -> [a] -> Maybe ([a], [a])
08:20:40 <ski> @type isPrefixOf
08:20:41 <lambdabot> Eq a => [a] -> [a] -> Bool
08:20:45 <ski> @type stripPrefix
08:20:46 <lambdabot> Eq a => [a] -> [a] -> Maybe [a]
08:20:58 <im0nde> I'm always suprised/ashamed how easy solutions are after trying to find one for a while
08:21:20 <ski> > case "ab" `stripPrefix` "abcde" of Nothing -> "sorry"; Just s -> s
08:21:22 <lambdabot>  "cde"
08:22:08 <ski> > case "bc" `stripInfix` "abcde" of Nothing -> "sorry"; Just (front,back) -> front ++ "*" ++ back
08:22:10 <lambdabot>  error:
08:22:10 <lambdabot>      • Variable not in scope:
08:22:10 <lambdabot>          stripInfix :: [Char] -> [Char] -> Maybe ([Char], [Char])
08:22:35 <ski> @let import Data.List.Extra
08:22:36 <lambdabot>  Defined.
08:22:38 <ski> > case "bc" `stripInfix` "abcde" of Nothing -> "sorry"; Just (front,back) -> front ++ "*" ++ back
08:22:40 <lambdabot>  "a*de"
08:28:52 <fr33domlover> tdammers, I went back to the old code and it does build now :P I guess it was something else / compile not rebuilding the module
09:03:17 <razzy> surprisingly mny people here
09:16:29 <glguy> razzy: We're generally a pretty active group. Welcome.
09:18:04 <razzy> always when i tried haskell i find huge fat language, impossible to comrehend :]
09:18:34 <razzy> i would like to be proven wrong
09:18:35 <razzy> :]
09:19:02 <megaTherion> haskell is fat? :O
09:19:15 <razzy> it seemed to me
09:19:21 <megaTherion> compared to what?
09:19:36 <razzy> small lisps?
09:19:43 <razzy> scheme, picolisp?
09:21:18 <oo_miguel> it is fat comared to Ook!
09:23:02 <megaTherion> Ook is great
09:26:02 <razzy> i like brainfuck
09:26:21 <razzy> Ook! is bloat!
09:27:21 <razzy> brainfuck is nice and simple, not practical tho :]
09:35:50 <razzy> afk
09:51:36 * hackage newhope 0.1.0.0 - Library implementing the NewHope cryptographic key-exchange protocol  https://hackage.haskell.org/package/newhope-0.1.0.0 (jeremy)
10:05:16 <im0nde> fr33domlover: Replying to your comment about readable code:
10:05:29 <im0nde> this works, but is unreadable as hell :D
10:05:30 <im0nde>   putStrLn (show (filter  (\x ->  (length x == 5 && elem 'a' x == True)) (groupBy (==) ['a', 'b', 'c', 'd', 'e', 'f'])/= []))
10:08:27 <dmwit> im0nde: In case you want a readable alternative, consider ```print ("aaaaa" `isInfixOf` "abcde")```.
10:08:46 <dmwit> Oh, actually, I guess that's not the same.
10:09:54 <dmwit> print . elem "aaaaa" . group $ "abcde"
10:10:32 <Solonarv> 'something == True' is silly, just use 'something'
10:10:44 <fr33domlover> im0nde, there is a more readable way to use groupBy there (with map and filter etc., perhaps using a list comprehension), but either way it will likely be longer than the replicate/isInfixOf solution
10:10:46 <dmwit> Yes, there were many rewrites I went through in my head. =)
10:10:53 <dmwit> groupBy (==) is also silly, just use group.
10:10:59 <im0nde> Solonarv: Actually I tried exactly that. But it didn't work when i omit it
10:11:01 <Solonarv> also, groupBy (==) = group
10:11:01 <dmwit> And ['a','b'] is "ab".
10:11:24 <dmwit> And putStrLn (show x) is print x.
10:11:55 <dmwit> x/=[] is better as null x.
10:12:05 <dmwit> or not (null x) as appropriate
10:12:09 <im0nde> i see
10:12:40 <im0nde> dmwit: The isinfixof solution is shorter, I did that already. Was just wondering if I could do it without the "fancy" functions
10:12:53 <dmwit> im0nde: It's shorter, but as I noted above, it's wrong.
10:13:10 <dmwit> My second solution is better; matches yours exactly but is still way shorter.
10:13:35 <dmwit> im0nde: (The isInfixOf solution would accept strings with 6 'a's in a row.)
10:13:52 <im0nde> dmwit: you mean this one? print . elem "aaaaa" . group $ "abcde"
10:13:58 <dmwit> That's the best one, yes.
10:14:05 <dmwit> If you plan to take 5 as a parameter, you can
10:14:13 <dmwit> print . elem (replicate 5 'a') . group $ "abcde"
10:14:24 <im0nde> 6 'a's in a row is ok (should be true)
10:14:32 <im0nde> or did I misunderstand you?
10:14:42 <dmwit> Ah. Then in your initial code, you should change `length x == 5` to `length x >= 5`.
10:14:58 <im0nde> Right!
10:15:16 <fr33domlover> :t \ x n -> any (\ (mx, len) -> mx == Just x && len >= n). map (listToMaybe &&& length) . group
10:15:18 <lambdabot> Eq a => a -> Int -> [a] -> Bool
10:15:24 <fr33domlover> im0nde, ^
10:15:34 <fr33domlover> This is one way, maybe it can be made simpler?
10:15:38 <redpunch> I am so stuck! I get this error https://hastebin.com/wezoyazaja.sql (looks same as https://github.com/ghcjs/jsaddle/issues/85) and when I add the constrain `gi-javascriptcore == 4.0.15` I get https://hastebin.com/citisekuqo.sql (looks same as https://github.com/haskell-gi/haskell-gi/issues/187) and I cant figure out how to go beyond
10:15:39 <fr33domlover> Exercise for the reader ;)
10:16:12 <dmwit> fr33domlover: any (isPrefixOf (replicate n x)) . group
10:17:04 <fr33domlover> dmwit, yes that too! I was trying to avoid replicate because it was in the original solution :)
10:17:24 <fr33domlover> dmwit, good one though :)
10:18:46 <redpunch> http://hackage.haskell.org/package/gi-javascriptcore-4.0.15 does have the `gi-gobject` dependency, Idk how it is supposed to find the module it complains about not finding. Any idea to what I may be missing?
10:18:59 <redpunch> s/does/doesn't
10:19:08 <fr33domlover> im0nde, side note, dmwit's solution here is probably the best so far ^_^
10:20:33 <fr33domlover> It's elegant, and probably faster than replicate/isInfixOf :P (if you ever have a speed problem)
10:20:59 <dmwit> I doubt it's faster than isInfixOf.
10:24:03 <fr33domlover> dmwit, I mean faster because if you're looking for sequences of length 5, isInfixOf will watefully check sequences of length n<5 once per item while your code will skip them because of the grouping. But that's only if group runs lazily on the list. I guess the long solution would be faster than both? Because isPrefixOf unnecessarily tests equality N times, while mine only once, except my one-liner is way
10:24:05 <fr33domlover> uglier. The best would probably be to use a helper function that given a list, returns (Just x) if length>=5 and Nothing otherwise ^_^
10:24:14 <fr33domlover> *wastefully
10:25:04 <dmwit> I think you're confused about how isInfixOf proceeds.
10:25:34 <dmwit> If the first characters of the needle and the current tail of the haystack don't match, it doesn't look any further in the needle or haystack to decide about that position.
10:25:54 <dmwit> Oh, no, I understand your objection now.
10:26:03 <fr33domlover> dmwit, isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
10:26:34 <dmwit> Yeah, okay, so if we're looking for "aaaaa" and we see "aaa" we waste work looking at the "aa" tail. Got it.
10:26:37 <fr33domlover> dmwit, so it runs once per character because it's unaware the needle was made with replicate et.
10:26:42 <fr33domlover> *etc.
10:26:46 <dmwit> You are correct. =D
10:26:51 <fr33domlover> ^_^
10:26:57 * fr33domlover high fives dmwit
10:27:54 <im0nde> fr33domlover: dmwit But it only works for chars, right?
10:30:47 <fr33domlover> im0nde, nope it works for a list of anything that has an Eq instance
10:31:16 <fr33domlover> im0nde, i.e. basically types on which you can use (==) and (/=)
10:31:30 <fr33domlover> intuitively speaking
10:31:35 <fr33domlover> informally speaking
10:31:37 <fr33domlover> lol
10:33:06 <im0nde> myfunc3 a b c = do
10:33:07 <im0nde>   putStrLn "Funktion 3"
10:33:09 <im0nde>   print . elem (replicate a b) . group $ c
10:33:17 <im0nde>   myfunc3 5 7 [1,2,3,4,5,6,7,7,7,7,7,7,8,9,0]
10:33:22 <im0nde> returns false
10:36:44 <redpunch> Ok, different question, How do I rewrite it so one glance will not be sufficient to tell that this was written by a noob? https://hastebin.com/ujajoguxoh.coffeescript
10:36:49 <scav> I just cannot wrap my head around this, but is there an easy short hand way of updating fields in a record?
10:36:56 <redpunch> (not that i solved my previous one. sadlife)
10:37:20 <Solonarv> scav: oldValue { fieldName = newFieldValue }
10:38:43 <scav> by oldValue you mean the record I want to change, right?
10:41:40 <scav> yes, you did, thank you Solonarv !
10:42:00 <Solonarv> indeed
11:12:51 <fragamus> https://gist.github.com/fragamus/68405a42ca7f85d887573edf3dcfc5f0
11:15:06 <glguy> fragamus: Looks like the wrong channel
11:15:17 <fragamus> oh shit
11:16:37 <fragamus> sorry
11:22:09 <fragamus> yeah java does not seem to be able to infer the type on this one the way haskell can
11:35:22 <monochrom> pingPongCamelCaseUnreadableTrainWreckMonad
11:35:32 <yushyin> lol
11:55:11 <slack1256> i-would-like-hyphen-variable-names-though
12:15:38 <jeb> is there any good free haskell tutorials?
12:20:34 <dmwit> ?wiki tutorials
12:20:35 <lambdabot> https://wiki.haskell.org/tutorials
12:30:06 * hackage ip 1.5.0 - Library for IP and MAC addresses  https://hackage.haskell.org/package/ip-1.5.0 (andrewthad)
13:04:45 <scav> I have a recursive main that loops until a certain thing occurs, but I want to keep the record (my custom type)I initially passed it when it started executing. I want to keep using and updating this record while I print to the console (the data I print is stored in a field inside this record and it is updated for every iteration). I don't expect to be spoon fed, so any relevant reading material would be greatly appreciated.  
13:05:28 <johnw> the Writer monad can do this, if you can express "updates" as Monoid append
13:06:15 <johnw> to keep using it as well, maybe StateT s IO ()
13:07:53 <ski> perhaps you can keep your record in an argument
13:08:31 <ski> (accumulator-style)
13:09:39 <scav> I should probably head over to the beginners chan :)
13:09:53 <scav> Thanks for the input, I will check it out closer 
13:10:11 <glguy> scav: This  channel is for beginner questions
13:10:15 <ski> scav : well, that channel isn't the "beginner version" of this channel
13:11:14 <ski> (iow, asking beginner questions here is just fine)
13:12:06 <calloc> I have an X ( Maybe ( X () ) ) that I would like to turn into X (). Is there something like join for different types? Or am I thinking of this incorrectly?
13:12:23 <ski> how is `X' defined ?
13:12:45 <ski> is `X' an instance of `Monad' ?
13:12:48 <calloc> Yes
13:13:00 <calloc> X is from XMonad
13:13:06 <scav> glguy, ski okay, thanks - I just try not to be oblivious to things - cheers! :)
13:13:23 <ski> calloc : try using `sequence'
13:14:22 <ski> (that's only part of it)
13:15:25 <ski> (hm, i suppose in this case `sequence_' might also be relevant ..)
13:16:20 <calloc> I tried both, the type for sequence_ does look like what I want though.
13:16:46 <calloc> I'll keep poking at it, thanks for the direction!
13:16:56 <ski> well, as i said, that's only part of it
13:17:31 <ski> are you familiar with the superclasses of `Monad' ?
13:17:45 <calloc> lightly
13:18:02 <ski> it may be enough
13:18:15 <ski> (there's several ways one could do this, btw)
13:18:23 <glguy> ski: I'd think Monad would be necessary here
13:18:38 <ski> glguy : as i said. only part of it :)
13:21:23 <glguy> calloc: Do you know how to implement the thing you're asking for manually?
13:22:12 <calloc> Yea, I can do it another way, but I wanted to try something more modular.
13:22:26 <ski> scav : btw, of course you're free to ask questions in that channel as well. just pointing out that beginner questions aren't unwelcome here. someone else started that channel, partly for helping people going through a particular book. but you don't need to be following that book, to ask there, either
13:22:48 <glguy> calloc: What's your current version look like?
13:23:11 <jle`> calloc: just remember to also be sure that the semantics of the result are what you want it to be
13:23:23 <jle`> calloc: just because you can get something of the right type doesn't mean it "does" what you want it to do
13:23:56 <ski> calloc : of course, if you need/want more hints, or scrutiny of your current attempt(s), or if you have some question about something puzzling you, just ask
13:24:14 <im0nde> As a newcomer to haskell on linux, what tool would you recommend to manage haskell packages? I saw canbal-install and stach among other  in the arch linux wiki
13:24:47 <glguy> im0nde: ghcup is good for installing cabal-install and ghc. cabal's new-build functionality is great for building
13:24:48 <calloc> I have this currently. ((fmap $ fmap $ windows . W.shift) (screenWorkspace 0)) :: X (Maybe (X ()))
13:25:22 <ski> and what do you currently do, to get from that to something of type `X ()' ?
13:25:24 <jle`> im0nde: i personally use stack to manage haskell packages, but cabal (if you use the new-* functionality) should be fine too
13:25:40 <calloc> If I look up the workspace names earlier (screenWorkspace 0) :: X (Maybe String) I can remove the Maybe in the middle.
13:25:58 <im0nde> glguy: I installed ghc from the package manager of my distro, why should I manage it form stack or cabal at all?
13:27:04 <ski> calloc : what do you want to happen, in case of `Nothing' ?
13:27:04 <glguy> im0nde: The distribution managed compiler and libraries are not for development but for supporting other distribution provided packages
13:27:30 <calloc> I want nothing to happen.
13:27:36 <ski> ok, good
13:27:47 <ski> calloc : and the answer to my previous question ?
13:27:48 <im0nde> Oh I see. Well it worked fine till now.. I'll check out stack then
13:27:56 <glguy> im0nde: When you're doing development it's disruptive to leave version choices to your package manager where they can change out from under you so easily
13:28:20 <glguy> im0nde: if you're starting new the way I highlighted before is a good place to start
13:28:25 <calloc> ski: I haven't been able to yet
13:28:52 <ski> calloc : oh, i thought you meant to could, when you said "Yea, I can do it another way, but I wanted to try something more modular."
13:28:53 <im0nde> 'm
13:28:55 <im0nde> ok
13:29:01 <ski> s/meant to/meant you/
13:29:24 <calloc> ski: I can get it before it gets the additional X () in the Maybe ()
13:30:09 <ski> calloc : do you want an elegant solution or just any reasonable solution (to begin with, at least) ?
13:31:03 <ski> calloc : i trust you know how to get at the `Maybe String', yes ? (or the `Maybe (X ())', if you insist)
13:31:18 <calloc> ski: I'm mostly in this to learn, so if the inelegant solution makes sense to have first, then by all means.
13:31:36 <ski> (also, as i said, there's several ways to do this)
13:31:51 <jle`> i'd proably use do notation for this, in the simplest case
13:32:05 <ski> yes, that's what i meant by "reasonable solution"
13:32:06 <jle`> blahblah = do
13:32:11 <jle`>   ms <- screenWorkspace 0
13:32:13 <jle`>   case ms of
13:32:27 <jle`>     Just str -> putStrLn str   -- or whatever thing you want to do
13:32:41 <jle`>     Nothing -> pure ()
13:32:43 <ski> (perhaps there isn't that much difference here)
13:33:06 <jle`> and then from there you can do a simplification; the common pattern of "case blah of Just x -> f x; Nothing -> pure ()" is `traverse f blah`
13:33:24 <glguy> (traverse_)
13:33:28 <ski> (aka `mapM f blah')
13:33:35 <jle`> ah yes, traverse_ or mapM_ :)
13:33:36 <ski> (or `mapM_')
13:35:22 <glguy> I want a traverse__ :: (Foldable t, Applicative f) => (a -> f ()) -> t a -> f ()
13:35:52 <glguy> so that it doesn't have to add the extra operation to convert the result to () making it unsuitable for use in recursion
13:39:41 <ski> (a `Maybe' is a "container containing at most one element". `traverse'/`for',`mapM'/`forM' and `traverse_'/`for_',`mapM_'/`forM_' will do something for all elements of a collection, in this case that means do something, in case there's anything there, otherwise do nothing. the former four operations construct a new collection, the latter four doesn't
13:39:43 <im0nde> glguy: ghcup is not in my repos (Arch linux) is it part of something else? 
13:39:46 <ski>  the variants with `M' are monadic (present only because of hysterical raisins), the others are idiomatic (`Applicative'))
13:40:11 <glguy> im0nde: https://www.haskell.org/ghcup/
13:40:25 <ski> glguy : you mean for tail calls ?
13:40:30 <glguy> ski: yeah
13:40:39 <ski> that's an interesting point
13:41:36 <glguy> I'm always just careful to write out the case expression in those cases for now
13:42:05 <ski> so that's an argument against using a `m a'-typed parameter, rather than an `m ()'-typed parameter
13:42:53 <ski> glguy : for any other `Foldable' than `Maybe' ?
13:46:15 <glguy> That's certainly the most common one I've wanted. I think I could imagine other cases but I wouldn't say it's as important
13:49:52 <calloc> Ok so that led me back to how I was doing it before. But it never hits the X (Maybe (X ())).
13:50:23 <calloc> screenWorkspace 0 >>= flip whenJust (windows.W.view) :: X ()
13:50:47 <nai> does idiomatic mean applicative in some particular sense?
13:51:50 <ski> `whenJust' is (upto glguy fine distinction, it seems), just a specialized version of `for_', for `Maybe'
13:52:16 <ski> calloc : "never hits" meaning ?
13:52:59 <ski> nai : no. it's a synonym
13:53:25 <nai> but where does it come from? i mean, they're not synonyms in natural language
13:53:42 <ski> comes from the original paper on the idea, i think
13:53:44 <calloc> ski: I just haven't seen that type when breaking up segments of the above code in ghci.
13:53:49 <nai> ok
13:55:24 <bgavran> why does the following code only compile if I remove the annotation "k :: Type -> Type -> Type"? https://pastebin.com/JpCencxw  Isn't the kind of "k" precisely the one specified by the annotation?
13:56:18 <glguy> (please try to avoid pastebin.com , it doesn't highlight well and is covered in ads)
13:56:37 * hackage massiv-io 0.1.6.0 - Import/export of Image files into massiv Arrays  https://hackage.haskell.org/package/massiv-io-0.1.6.0 (lehins)
13:57:01 <bgavran> glguy: thanks for the heads up - is there a preferred alternative?
13:57:30 <ski> "Idioms: applicative programming with effects" by Conor McBride,Ross Paterson in 2008 at <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.106.4830>,<http://strictlypositive.org/Idiom.pdf>
13:57:42 <ski> (also cf. <http://www.staff.city.ac.uk/~ross/papers/Applicative.html>, which i believe is a later version)
13:57:48 <glguy> I like gist.github.com, but there are a bunch of others hastebin.com works well
13:57:56 <ski> nai ^
13:58:28 <ski> calloc : right. `X (Maybe (X ()))' doesn't occur in that snippet
13:58:35 <nai> thanks
13:59:24 <Solonarv> gist.github.com also supports multiple files and comments, which is quite convenient
14:01:39 <ski> nai : also see <https://wiki.haskell.org/Idiom_brackets> and the `Idiom' module in <https://hackage.haskell.org/package/applicative-quoters> (btw, Philippa's `ADo' module in the same package does something similar to the later extension <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#applicative-do-notation>, by Marlow,et al.)
14:02:51 <ski> (<https://paste.debian.net/> seems like a relatively nice and simple paste site)
14:02:59 <bgavran> Solonarv, glguy: I've created a gist, which is definitely more readable: https://gist.github.com/bgavran/bf2c223400b23003a58878bebf6e493f
14:04:11 * ski misses <hpaste.org>^W<lpaste.net> and <paste.lisp.org> ..
14:05:13 <ski> calloc : if you wanted to see that type, you'd have to break out the `whenJust' part of that thing, doing it later
14:06:11 * ski idly wonders whether one could make an anonymous gist
14:06:23 <glguy> ski: I think that was only in the past
14:06:38 <glguy> (which is why I feel compelled to offer an alternative to it when recommending it :(  )
14:07:30 <ski> bgavran : hm, shouldn't you use  ':  there ?
14:08:11 <ski> (hm, or i suppose it may be able to disambiguate anyway ?)
14:08:44 <Solonarv> ski: indeed, the tick is only needed when there is ambiguity
14:09:34 <ski> yea, i suppose i would include it, for consistency
14:09:46 <ski> (which is probably why it looked strange to me)
14:09:56 <bgavran> ski: could you please elaborate? I'm not sure how to interpret ':
14:10:03 <ski> bgavran : what is the kind of `Allowed' ?
14:10:37 <bgavran> Allowed :: (* -> * -> *) -> * -> Constraint
14:10:46 <glguy> bgavran: type family AllAllowed k xs :: Constraint where
14:11:23 <ski> i was wondering whether it maybe inferred a more general kind type of `a' in `type Allowed k a :: Constraint' ..
14:11:30 <bgavran> ski: ooh that fixes it!
14:11:55 <ski> hm, glguy suggestion sounds like it might be an issue
14:12:02 <ski> bgavran : oh, it does ?
14:12:15 <bgavran> whoops, it was glguy who recommended it
14:12:16 <ski> (which of my suggestions ?)
14:12:23 <bgavran> yeah, the "type family AllAllowed k xs :: Constraint where"
14:12:25 <ski> ok, fine :)
14:12:57 <ski> so, it was thinking that the tuple-like syntax meant tuple types, not constraint conjunctions
14:13:19 <bgavran> it seems to work - I guess I'm still in the dark what really was the issue. GHC couldn't infer it was of kind constraint?
14:13:43 <ski> (btw, this shows why that was not a good idea for the concrete syntax for tuple types in the first place, imho)
14:14:07 <bgavran> ski: yeah, tuples have kind constraint if their components have kind constraint
14:14:47 <ski> rather, in that case that syntax is not interpreted as tuple types, but as constraint conjunction
14:16:39 <ski> (hm, i suppose one could also view it as a kind of overloading (non-ad-hoc ?) .. not sure i like that though. i wonder whether there's a definite answer to how GHC actually thinks of this)
14:17:09 <Solonarv> of course there is, just trawl through its source (or perhaps the commetary
14:17:26 <ski> well, perhaps it's open to both interpretations ?
14:17:40 <bgavran> ski: hmm yeah I'm wondering the same!
14:17:50 <ski> (perhaps unlikely, but i wouldn't discount it as impossible)
14:24:36 <calloc> So Maybe is traversable but X is not. The sequence type only the outer one to be traversable. Is there some way to leverage this?
14:25:44 <calloc> Maybe I'm focusing too much on type-wrangling as jle` suggested.
14:26:07 <dmwit> Can you remind newcomers what the question is?
14:26:21 <jle`> calloc: the type-tetris way would be to `join . fmap sequence_`
14:26:36 <glguy> (=<<) sequence_
14:26:37 <jle`> but i'd definitely use do notation and pattern matching (or maybe traverse_) for something like this, in practice
14:29:16 <calloc> sequence_ would require X to be Foldable right?
14:29:32 <jle`> we're sequencing the Maybe here
14:29:43 <jle`> hence fmap sequence_
14:30:18 <jle`> sequence_ :: Maybe (X ()) -> X ()
14:30:28 <jle`> fmap sequence_ :: f (Maybe (X ())) -> f (X ())
14:32:39 <calloc> sequence_ =<< (fmap ((fmap f)) $ ws) :: X ()
14:33:01 <nai> why is unIO defined as a separate function  unIO (IO a) = a  instead of directly in the IO type like  newtype IO a = IO { unIO :: State# RealWorld -> (# State# RealWorld, a #) }  ?
14:33:11 <calloc> It has the right type. Tetris was a good name for it.
14:33:39 <ski> calloc : this is why i asked about superclasses of `Monad', remember ? :)
14:34:12 <calloc> Yea, maybe I should make X an instance of Traversable?
14:34:49 <ski> no
14:34:50 <jle`> what does that even mean? ;)
14:35:04 <calloc> Something like traverse f ws :: X ()
14:35:17 <jle`> are you going to redefine the structure of the X type to make it traversable?
14:35:31 <jle`> traversable isn't quite something you add or remove to something; it's a property of the structure itself
14:36:16 <ski> @src mapM_
14:36:16 <lambdabot> mapM_ f as = sequence_ (map f as)
14:36:17 <jle`> that's like saying you should make your dog into a hamster :)
14:37:20 <calloc> Would that not be like adding Monad to the List type?
14:37:36 <jle`> list is already a monad, whether or not it has a Monad instnace
14:37:57 <jle`> giving it a Monad instance only lets you refer to (:[]) and concatMap by 'universal' names
14:38:09 <ski> `[]' already is a monad (in the sense that it's possible to write `returnList',`bindList' of the right types, satisfing the laws), without any `Monad' instance written
14:38:16 <jle`> but if a type is not a monad, you can't just magically turn it into a monad by giving it a Monad instance
14:38:29 <jle`> the monad-ness of a list comes from the structure of list, not from its typeclass instance
14:38:38 <ski> similarly, `X' being a monad is a consequence of how `X' is defined
14:38:44 <jle`> the typeclass instance only witnesses a property that was already a part of list's structure
14:39:11 <jle`> even if we don't give list a Monad instance, it's still a monad'
14:39:31 <calloc> Hmmm. I was misunderstanding it deriving a class vs having an instance.
14:39:50 <jle`> the only thing the Monad class does is let you refer to its monad methods by a common name/identifier
14:40:04 <ski> (note the difference here between the informal term "monad", and the formal term (type class) `Monad' (specifically thinking of instances of it))
14:41:30 <calloc> So would you just write your own traverse method specifically tied to my types?
14:41:32 <jle`> so i guess to follow my analogy, it's like getting your pet a Dog License.  if you have a cat as a pet, you can't just go to the city and ask for a dog license for your cat to make it a dog
14:42:55 <jle`> calloc: what i mean is that if a traverse method isn't possible for your type, then you can't write a Traversable instance for it
14:43:06 <jle`> you're mixing the cause-and-effect
14:43:52 <calloc> jle`: I get that part now. I would either need to wierdly redefine X where Traversable might not even make sense, or make due without that type.
14:45:08 <jle`> well i mean, you could redefine X where having a traverse method would make sense
14:45:22 <jle`> but if X doesn't have one already, then it's probably likely that one isn't possible
14:45:27 <jle`> with the current definition
14:46:49 <calloc> On my second-to-last comment I should have said traverse-like, I wasn't meaning to imply an instance of Traversable all over again.
14:47:36 <jle`> ah, i see. at the heart of this though it does seem like focusing on the types more than the semantics of what you are trying to do
14:48:14 <jle`> the types are a good guide to what sort of approaches you want to attempt. but in most practical cases they give you a couple of options to try, instead of dictating the one true solution
14:50:21 <ski>     sequence_ =<< (fmap . fmap) f ws
14:50:38 <ski>   =  sequence_ =<< fmap (fmap f) ws  -- by definition of `(.)'
14:50:46 <ski>   =  sequence_ . fmap f =<< ws  -- by how `(=<<)' and `fmap' interacts
14:50:52 <ski>   =  traverse_ f =<< ws  -- by definition of `traverse_'/`mapM_' (see above)
14:51:12 <ski> calloc : that shows how these two formulations are related
14:58:36 <calloc> '(fmap . fmap) f ws' applies the function in place, skipping Nothings >>= sequence_ performs valid computations.
14:59:37 <calloc> Is that what you'd mean by 'focusing on the semantics rather than the types'?
15:00:00 <ski> now, as for the other formulation in terms of join that jle` mentioned :
15:00:44 <ski>      (join . fmap sequence_) ((fmap . fmap) f ws)  -- this is just an application of jle`s suggestion to your thing of type `X (Maybe (X ()))'
15:00:52 <ski>   =  (join . fmap sequence_ . (fmap . fmap) f) ws  -- by definition of `(.)'
15:01:08 <ski>   =  (join . fmap sequence_ . fmap (fmap f)) ws  -- by definition of `(.)', same as in the previous derivation chain above
15:01:17 <ski>   =  (join . fmap (sequence_ . fmap f)) ws  -- by law of `fmap'
15:01:33 <ski>   =  (join . fmap (traverse_ f)) ws  -- by definition of `traverse_'/`mapM_' (same as before)
15:01:40 <ski>   =  traverse_ f =<< ws  -- via law relating `(=<<)' to `join' and `fmap'
15:02:04 <ski> (and so both these equation chain derivations arrive at the same thing)
15:02:58 <ski> (and btw, yes, i mostly mentioned `(fmap . fmap) f ws' here, as an alternate way to think of `fmap (fmap f) ws', which can perhaps sometimes feel more natural/easy)
15:03:41 <ski> (sorry, to be clear, i meant that the former of those can perhaps sometimes feel more natural/easy, than the latter, equivalent, one, which is what you had)
15:06:42 <ski> calloc : i don't think i'd say "applies the function in place", though i get what you mean, in case you mean that you "leave the outer two shells, `X' and `Maybe', in place, and allow your provided function to operate inside of these two"
15:07:19 <ski> (the problem with "applies the function in place" would be that it tends to bring connotations of update-in-place (of state), which isn't what this is about)
15:08:00 <ski> also, i don't follow what you mean by ">>= sequence_ performs valid computations"
15:09:23 <ski> what `sequence_ =<<' above does is to take all the elements of the `Maybe', doing something to each one (there's at most one, so this amounts to doing something with the single contents, in case it's there). the "doing something" in this case is just executing the action (of type `X ()'), which is what's inside the `Maybe'
15:10:26 <ski> calloc : re "focusing on the semantics rather than the types", let's do the latter
15:11:28 <ski> `ws' has type `X (Maybe String)', and `f' has type `String -> X ()'
15:11:55 <ski> we want to "apply `f' inside the two layers"
15:12:04 <ski> in type signatures
15:12:21 <ski>   f :: String -> X ()
15:12:31 <ski>   fmap f :: Maybe String -> Maybe (X ())
15:12:43 <ski>   fmap (fmap f) :: X (Maybe String) -> X (Maybe (X ()))
15:12:49 <ski>   ws :: X (Maybe String)
15:13:05 <ski>   fmap (fmap f) ws :: X (Maybe (X ()))
15:13:21 <ski> next, we want to "get rid of the inner `X'"
15:14:00 <calloc> Maybe might hold an action. sequence_ performs those actions. (fmap . fmap) places the f action next to each valid datum (Just String). 
15:14:12 <ski> we can't actually (in general) "get rid" of a monad layer `X' here (at least not without knowing more about the particular monad. but in this case, general monadic reasoning/behaviour is sufficienct for what we want to do)
15:14:26 <ski> calloc : *nod*
15:14:52 <ski> what we *can* do is "smash"/merge together two *adjacent* monadic layers, here `X'
15:15:14 <ski> the problem here is that the two `X's aren't adjacent, there's a `Maybe' intevening inbetween them
15:15:16 <calloc> What's the intuition behind being able to do that?
15:15:28 <ski>   join :: Monad m => m (m a) -> m a
15:15:47 <ski> (do you know how that is defined, in terms of `(>>=)' ?)
15:17:25 <ski> the general (but a bit vague) description of what `join' does is that `join actact' will take an `m'-action `actact', that when executed, will yield a result value which is another `m'-action (which yields some result value of type `a')
15:18:58 <ski> so, the behaviour of `join actact' is : when executed, this action will start by executing the action `actact', yielding as result some `m'-action (with monadic result type `a'), call it `act'. then the overall execution continues by executing *this* (run-time computed, in general) action `act', yielding some result of type `a', which is to be the overall result yielded from the action `join actact' that we're describing
15:20:40 <ski> (one interesting part here, re the (possible) run-time generated aspect, is that this *allows* you to decide *which* next step to take, in an execution, depending on the *run-time* result of the previous execution step. this is the crucial difference between `Monad' and `Applicative'. the latter doesn't allow this kind of run-time dependence on later actions on earlier action results)
15:21:30 <ski> anyway, going back to the present problem of "following the types", with this `X' monad. we had arrived at
15:21:35 <ski>   fmap (fmap f) ws :: X (Maybe (X ()))
15:21:43 <ski> but we wanted to "get rid of the inner `X'"
15:21:52 <ski> now, we do have
15:22:18 <ski>   sequence :: Maybe (X a) -> X (Maybe a)
15:22:36 <Welkin> does anyone remember that blob racing game someone posted in here last year?
15:22:44 <Welkin> and many of us played it
15:22:49 <Welkin> is it still online?
15:22:55 <ski> (instead of `Maybe' you could have any `Traversable' collection, like e.g. lists. and instead of `X', you could have any monad, in fact even any idiom (iow `Applicative' instance))
15:22:56 <Welkin> supposedly it was written in haskell. It was fun (and funny)
15:23:19 <ski> in your particular case, `a' was `()', iow you want
15:23:33 <ski>   sequence :: Maybe (X ()) -> X (Maybe ())
15:23:42 <ski> however, since we had
15:23:45 <ski>   fmap (fmap f) ws :: X (Maybe (X ()))
15:23:59 <ski> there's an outer `X' layer which is in the way. no problem, `fmap' will fix that :
15:24:11 <ski>   fmap sequence :: X (Maybe (X ())) -> X (X (Maybe ()))
15:24:23 <ski>   fmap sequence (fmap (fmap f) ws) :: X (X (Maybe ()))
15:24:47 <ski> *now*, the two `X' layers are adjacent, so we can apply `join' to "smash"/merge them into a single `X' layer
15:24:57 <ski>   join (fmap sequence (fmap (fmap f) ws)) :: X (Maybe ())
15:25:22 <ski> .. however, `Maybe ()' here is pretty useless. you're not interested in looking an the result being either `Nothing' or `Just ()'
15:25:31 <ski> so, instead of `sequence' above, you use
15:25:46 <ski>   sequence_ :: Maybe (X a) -> X ()
15:25:48 <ski> or, in your case
15:25:51 <ski>   sequence_ :: Maybe (X ()) -> X ()
15:26:30 <ski> which simply doesn't reconstruct the collection, with the new result value(s) (since the result value(s) (only at most one in your case, because of `Maybe') aren't interesting to you)
15:27:38 <ski> calloc : so, this approach to "following / focusing on the types" yields the `join',`fmap' and `sequence_' formulation in the second derivation above, modulo a few inserted `(.)'s
15:27:50 <ski> calloc : does this make any kind of sense ?
15:28:06 <calloc> This has been extremely helpful.
15:28:58 <calloc> I'm still having a bit of a hard time with the intuition behind these abstractions, but using them is making more sense.
15:30:31 <ski> now, it's good to learn to recognize that this pattern of using `fmap' to replace an "inner value" (that's not really a good expression, better would be "(future) result value") with an action, and then use `join' to smash together the two action layers just amounts to `=<<'/`>>=' or `<-' in `do'-notation
15:32:10 <ski> calloc : but if you visualize the types, and think in terms of "operating inside layers, via `fmap'", "smashing layers with `join'", and "moving a collection layer inside an action layer with `sequence'", then it's probably easier to come up with the formulation that didn't use `=<<'/..., at first
15:33:31 <ski> (the idea with this visualization would be to try to "algebraically" modify the type, step by step, until it looks like you wanted to. if you want to, you could write this down on paper or in a file (say in a comment, perhaps) (rather than doing it all in head) to make it easier to follow/grasp)
15:35:20 <ski> calloc : *now*, re the "focusing on the semantics rather than the types" comments of jle`, the point is that, just because the types match, that doesn't mean the corresponding described transformation on the "layered action thing" does what you intended (/ what behaviour/semantics you had in mind)
15:37:06 <ski> in this case, if you arrive at the solution with `traverse_'/`mapM_' (or `whenJust', if you prefer), then your experience with these on `Maybe' as performing some action depending on whether there was a value there or not, could suggest that you're probably getting the semantics that you desired
15:37:16 <ski> with more practice, this will be easier to judge
15:40:38 <calloc> Hammering out the types algebraically seems to be able to get you pretty far, but I get what you mean. It would be easy to create a function of the appropriate type that does something undesirable. <br/> sequence_ in the documentation refers to throwing away the result or not needing it. What is 'getting thrown away'? I get that the type is changing, but would a better way to think about it be 'I have no
15:40:39 <calloc> more actions'.
15:41:16 <Welkin> the output of the function
15:42:21 <Welkin> imagine `print("bananas")` also returns a full bonobo who just ate all the bananas in addition to printing the string "bananas"
15:42:33 <ski> Welkin : hm, i think i may remember it. can't recall the name, though ..
15:42:39 <Welkin> well, when you throw away the result, you leave that poor bonobo out in the vaccuum of space
15:43:15 <calloc> (fmap . fmap) f ws >>= sequence :: X (Maybe ())
15:43:46 <Welkin> sequence turns a traversable of monads into a monad of traversables
15:43:52 <Welkin> :t sequence
15:43:53 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
15:44:28 <Welkin> :t sequence_
15:44:29 <lambdabot> (Monad m, Foldable t) => t (m a) -> m ()
15:45:14 <ski> @type sequenceA
15:45:15 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
15:45:16 <ski> @type sequenceA_
15:45:17 <lambdabot> (Applicative f, Foldable t) => t (f a) -> f ()
15:45:26 <ski> are the corresponding idiomatic versions
15:45:48 <ski> (the monadic versions exist only because of hysterical raisins)
15:46:34 <koz_> ski: I actually had to do a double-take there.
15:48:54 <Rembane> Crazy grapes.
15:49:29 <ski> calloc : consider `[getLine,getLine,getLine]' (or, if you prefer, `replicate 3 getLine'). this has type `[IO String]'. it's a list of three actions, which you could later pick and choose which to execute, in which order, and when. applying `sequence' to this gets you a single action of type `IO [String]' that is committed to executing all of them, in order, and also *giving* back as result the list of read lines (`String's), when executed
15:49:32 <Welkin> crazy apes
15:49:38 <Welkin> I played that game before
15:49:45 <Welkin> it's a simian version of crazy eights!
15:49:46 * ski . o O ( Jackan apes )
15:51:06 <calloc> Ok, (fmap . fmap) f ws produced a structure of values with associated actions. sequence performed those actions, leaving the empty boxes behind Maybe (). We no longer need those boxes, but in another context they might remain useful to keep around.
15:51:06 <ski> calloc : instead using `sequence_', you get an action of type `IO ()', that does read three lines, but doesn't given them back to you (doesn't reconstruct a list of results, from the list of actions), just drops the individual results on the floor / in outer space/void
15:51:44 <Welkin> the result of printing is already `()` anyway
15:51:46 <Welkin> not useful
15:51:58 <Welkin> IO [(),(),()]
15:52:00 <ski> calloc : btw, note that `sequence (replicate n act)' has a shorter expression, `replicateM n act', similarly `sequence_ (replicate n act)' is `replicateM_ n act'
15:53:00 <ski> (also `sequence_ (repeat act)' is `forever act'. `sequence (repeat act)' tend to not be useful as often (though it can be, in some situations). i'm not aware of a similar short form in that case)
15:53:18 <ski> koz_ : double-take where ?
15:54:21 <koz_> ski: At the hysterical raisins.
15:54:39 * ski doesn't follow
15:54:49 <Welkin> shriveled ovaries?
15:55:00 <calloc> "the monadic versions exist only because of hysterical raisins"
15:55:17 <koz_> Yeah, that one.
15:55:23 <koz_> What calloc said.
15:55:25 <monochrom> koz_: Do you mean that also sequence expected a list instead of more general Traversable?
15:55:28 <ski> "hysterical raisins" is a common joking misspelling of "historical reasons"
15:55:36 <koz_> monochrom: What ski said is what I was referring to.
15:55:46 <koz_> I had to read it a few times before I got the joke.
15:55:52 <monochrom> Oh! Nevermind.
15:55:57 <Welkin> what sally said to her sea shells by the sea shore
15:56:07 * ski thought it was common knowledge
15:57:13 <monochrom> Yeah actually the first time I saw "hysterical raisins" I needed to use the context and error correction to figure it out.
15:57:24 <MarcelineVQ> the big brain am winning again, I am the greetest, muahahah! now I am leaving earth for no raisin
15:59:04 <ski> calloc : "produced a structure of values with associated actions" -- if by "producing" you mean the value yielded (my terminology) when executing the action, and "structure of values with associated actions" is taken to mean the `Maybe'-"collection" *containing* actions (not containing values which are not actions, but are associated somehow to actions), then yes, that message line of yours sounds reasonable
15:59:48 <calloc> ski: The IO example helps. I got a bit stuck on it not being able to infer whether the result was needed by the provided function.
16:00:58 <ski> could you elaborate on the latter part ?
16:04:26 <calloc> After the actions are performed, the result is X (Maybe ()). Empty useless structure.
16:05:50 <calloc> Instead of X (), but it would have no way of knowing that structure was useless. It simply traversed it and performed the associated actions.
16:06:15 <Welkin> yes and the result of those actions was IO ()
16:06:32 <Welkin> :t putStrLn
16:06:33 <lambdabot> String -> IO ()
16:06:58 <Welkin> there is nothing magic going on here
16:07:30 <Welkin> it's just following the outputs of each function as they are applied as inputs to other functions
16:09:14 <calloc> I get that there's no magic, just trying to understand the abstraction. The maybe structure remained with no associated action, so we threw that away.
16:11:24 <Welkin> `Maybe ()` is just another type like any other
16:11:37 <calloc> ski: jle`: glguy: Welkin: Thank you for your time. I've been given plenty to chew on. 
16:11:45 <Welkin> the only time we talk about "actions" is when IO is involved because it is treated specially by the runtime system
16:11:59 <Welkin> IO ()
16:12:52 <Welkin> () is called unit and it a value that represents nothing (more like a placeholder)
16:13:13 <Welkin> it's just there to make the type signatures work out
16:13:41 <Welkin> because `Maybe` buy itself is not a type, it is a type constructor ( a type function)
16:13:44 <Welkin> by*
16:14:02 <Welkin> so when you give it a placeholder value () it becomes an actual type
16:14:37 * hackage bv-sized 0.6.0 - a BitVector datatype that is parameterized by the vector width  https://hackage.haskell.org/package/bv-sized-0.6.0 (benselfridge)
16:14:44 <Welkin> normally, ofr useful values, the type would be `Maybe Int` or something
16:15:15 <Welkin> :t getLine
16:15:16 <lambdabot> IO String
16:15:35 <Welkin> that is an example of IO that produces a useful result instead of ()
16:17:06 * hackage trasa 0.4 - Type Safe Web Routing  https://hackage.haskell.org/package/trasa-0.4 (chessai)
16:22:39 <__Myst__> What's the difference between StateT and MonadState?
16:23:01 <monochrom> MonadState is a class, StateT is an instance.
16:23:29 <monochrom> Or rather, to speak pedantically, StateT s m is an instance, provided m is an instance of Monad.
16:23:49 <__Myst__> what else satisfies MonadState?
16:23:55 <monochrom> To sum up, the difference between an example and a generalization.
16:24:15 <koz_> StateT s (ReaderT r m)?
16:24:22 <monochrom> You can always custom-write your own instance. Even though people use StateT in practice.
16:24:44 <koz_> ^ __Myst__ 
16:24:44 <monochrom> Oh and the other order too, ReaderT r (StateT s ...
16:25:04 <koz_> Also StateT s1 (StateT s2 m).
16:25:09 <rotaerk> hmm if I have a case expression that logically has exhausted all cases but not in a way the compiler can know ... what should I make the result of the _ case be?  assert False undefined?
16:25:12 <Welkin> MonadState is only useful is you create a newtype wrapper over some transformer stack and want to auto-derive the methods for it on your new type
16:25:35 <Welkin> rotaerk: meltdown
16:25:45 <Welkin> this is a common problem in haskell (and similar languages)
16:25:53 <Welkin> you know more than the compiler but cannot express it in the language
16:25:54 <ski> calloc : yw
16:25:56 <Welkin> it gets annoying
16:26:16 <rotaerk> I could just leave off the case, but the compiler whines when I do, with warnings enabled
16:26:30 <Welkin> it's best to cover all cases anyway
16:26:31 <monochrom> You can omit the _ case altogether.
16:26:46 <Welkin> just to be safe, especially if you change it later
16:26:53 <Welkin> you could break your program
16:26:58 * ski has no qualms talking about `Maybe'-actions, or `[]'-actions, or `Expr'-actions, or ...
16:27:42 <monochrom> "Nothing is an action" still beats "Nothing is a monad".
16:27:44 <Welkin> if you find yourself in a situation where thre is an impossible case, why not use `error`?
16:27:44 <Solonarv> I usually go with something like 'error "unreachable"' for unreachable cases
16:27:45 <rotaerk> in the event that that all the cases fail, I want failure of some kind to happen, whether it's running out of cases, or the final case throwing an exception, or whatever
16:27:54 <rotaerk> I'll just omit the case
16:28:07 <Welkin> no, not an exception
16:28:09 <Solonarv> but in practice I don't actually find myself in that situation very often
16:28:12 <Welkin> use error so it crashes
16:28:20 <ski> monochrom : yes, of course
16:28:33 <Welkin> so when you change your program later and it is no longer an impossible case, you will know immediately
16:28:51 <MarcelineVQ> You don't know immediately, you know if it's reached only
16:29:01 <rotaerk> ah, I forgot about 'error'
16:29:02 <MarcelineVQ> on that note follows monochrom's suggestion
16:29:02 <monochrom> On odd-numbered days, I omit the _ case because "I have already proved it correct".  On even-numbered days, I use "_ -> error ..." because "I want to write a really helpful error message". :)
16:29:15 <MarcelineVQ> i.e. It's best to cover all existing cases, not to be confused with covering all cases ever, which is what ending with _ = ... does.
16:29:17 <Solonarv> monochrom: hah
16:29:23 <rotaerk> I think I'll go with _ -> error, to get the warnings to stop
16:29:28 <Tuplanolla> Always promise cash prizes in unreachable branches.
16:29:33 <rotaerk> lol
16:29:59 <monochrom> However, the "what if you change the code in the future" argument is a double-edged sword. You can use it to argue both ways.
16:30:00 <ski> MarcelineVQ : *nod* .. the dangers of defaulty reasoning
16:30:23 <koz_> Tuplanolla: "If you made it here, you won $10."
16:30:41 <ttoe> Can Show for Text be derived automatically, with 'print' properly printing unicode, like 한글? There is a paste here: https://pastebin.com/EgMY2jjE
16:30:58 <ski> (though defaulty representations are worse. tends to mostly be an issue in dynamically typed situations, though)
16:31:19 <Tuplanolla> Just use `unpack`, ttoe.
16:31:43 <Welkin> just embed perl in your program
16:31:49 <Welkin> perl6
16:32:17 <hpc> perl4
16:32:19 <hpc> go back to basics
16:33:52 <monochrom> ttoe: Don't use print. Use putStrLn.
16:34:23 <monochrom> And yes if it means custom-writing a putItemLn without the help of Show, so be it.
16:34:27 <Welkin> you mean System::IO::System.out.write
16:37:59 <ttoe> Thanks for your advice. I'll see what i can do
16:39:03 <monochrom> unpacking will not help because Show for String does the same escaping as Show for Text.
16:39:16 <monochrom> http://www.vex.net/~trebla/haskell/string-print-show-read.xhtml is the reason why
16:48:01 <hpc> Welkin: feature request: a package named org.haskell.hackage.acme
17:00:40 * hackage haskell-dap 0.0.13.0 - Haskell implementation of the DAP interface data.  https://hackage.haskell.org/package/haskell-dap-0.0.13.0 (phoityne_hs)
17:08:37 * hackage hedgehog-classes 0.1.2 - Hedgehog will eat your typeclass bugs  https://hackage.haskell.org/package/hedgehog-classes-0.1.2 (chessai)
20:01:07 * hackage contiguous 0.3.3.0 - Unified interface for primitive arrays  https://hackage.haskell.org/package/contiguous-0.3.3.0 (andrewthad)
20:10:07 * hackage concurrency 1.7.0.0 - Typeclasses, functions, and data types for concurrency and STM.  https://hackage.haskell.org/package/concurrency-1.7.0.0 (barrucadu)
20:11:07 * hackage disjoint-containers 0.2.4 - Disjoint containers  https://hackage.haskell.org/package/disjoint-containers-0.2.4 (andrewthad)
20:11:08 * hackage tasty-dejafu 2.0.0.1, hunit-dejafu 2.0.0.1, dejafu 2.1.0.0 (barrucadu)
20:12:06 <tomboy64> i've written a small test program: https://bpaste.net/show/9aeedd87b3d2
20:12:24 <tomboy64> this takes stdin, counts the words and prints them
20:12:46 <tomboy64> however, i was a bit surprised at how slow it is. for a 400mbyte file it takes 30s on my machine
20:13:33 <tomboy64> any simple suggestions on how to speed it up?
20:14:37 * hackage primitive-containers 0.3.2 - containers backed by arrays  https://hackage.haskell.org/package/primitive-containers-0.3.2 (andrewthad)
20:19:44 <dmwit> tomboy64: Odd. On my machine, for a 5MB file, it takes only 0.3s.
20:20:11 <dmwit> Ah, that actually is about on par, just my multiplication by 80 in my head was wrong. Great!
20:20:36 <geekosaur> oen could also ask, compiled or ghci/runghc, and with or without optimization
20:20:51 <dmwit> I compiled with optimizations.
20:20:58 <dmwit> So the timings sound about right for them to have done so, too.
20:24:49 <dmwit> tomboy64: Switching to lazy text made it about 2x fast for me. Strict text was about 6x faster, though of course with significantly higher maximum residency.
20:25:38 <Solonarv> another suggestion: replace your sumUp implementation with foldl' (+) 0
20:25:43 <dmwit> Meanwhile ByteString (lazy or strict) was about 10x faster.
20:25:52 <dmwit> Oh, yeah, I forgot to mention I replaced sumUp with just sum.
20:26:06 <dmwit> Which I trust GHC to replace with what Solonarv suggested. =)
20:26:11 <tomboy64> heh
20:26:21 <tomboy64> Solonarv: did just that just 10 secs ago
20:26:23 <dmwit> (But ByteString is not really right.)
20:26:29 <Solonarv> the actual definition is sum = foldl (+) 0
20:26:45 <dmwit> sumUp -> sum, and map length $ map words -> map (length . words), together made almost no difference in my test.
20:27:07 <Solonarv> but some time ago the strictness analyzer got a boost and will often turn foldl into foldl'
20:27:37 <Solonarv> there's a rewrite rule for map f (map g xs) ==> map (f . g) xs, so that really shouldn't make any difference!
20:28:09 <dmwit> I know. But it is always good to verify these things just in case.
20:28:15 <tomboy64> okay, how would i switch to strict?
20:28:25 <tomboy64> and what optimizations did you use, dmwit?
20:29:38 <dmwit> Just import qualified Data.Text as T; import Data.Text.IO as T and replace getContents, lines, and words with T.getContents, T.lines, and T.words.
20:29:46 <dmwit> -O2 was the only compiler flag I used.
20:30:19 <tomboy64> dmwit: when i tried to use optimizations, the result was ~10s slower. e.g. 40s instead of 30s.
20:30:35 <tomboy64> i tried with -O2 and -optc-O3
20:30:50 <tomboy64> which i found pretty weird
20:31:36 <dmwit> What is -optc-O3?
20:36:03 <tomboy64>  -optc-O3: Enables a suite of optimizations in the GCC compiler. See the gcc(1) man-page for details. (a C-compiler option).
20:36:10 <tomboy64> from https://wiki.haskell.org/Performance/GHC
20:36:45 <dmwit> But there's no C...???
20:37:32 * tomboy64 shrugs
20:37:42 <tomboy64> i don't really know how ghc and gcc interact
20:38:18 <tomboy64> it's listed as optimization flag on the wiki so i presumed it was somehow useful :D
20:41:35 <Solonarv> it isn't, ghc does not work by producing C which is then passed to a C compiler
20:41:58 <Solonarv> (that was a supported mode of operation in the past but IIRC it's deprecated now)
20:42:48 <dmwit> It might be useful if there's C which you are asking GHC to pass to gcc, like if there's some FFI stuff going on.
20:42:54 <dmwit> But there's nothing like that here.
20:43:39 <tomboy64> hmmm. using data.text did not change anything regarding speed
20:43:54 <tomboy64> and good to know with the c independence.
20:44:09 <tomboy64> i deleted .o and .hi before recompilation
20:44:22 <dmwit> Show us the code you have now?
20:44:43 <tomboy64> https://bpaste.net/show/7f83d057b600
20:45:27 <tomboy64> oh
20:45:39 <tomboy64> caching reduced it to 12s O.O
20:45:50 <tomboy64> down from 30s
20:45:57 <dmwit> Strange. On my machine, that code is much faster than the original.
20:47:13 <Solonarv> "caching"? are you counting compile time in your time measurement?
20:47:24 <tomboy64> Solonarv: no
20:47:39 <tomboy64> but running it now has reduced the time by factor 2
20:47:50 <tomboy64> the code that i just pasted
20:47:57 <tomboy64> weird
20:48:49 <tomboy64> i'm generating a different text file
20:50:43 <tomboy64> so, that last version with data.text is supposed to be strict? as opposed to my initial version which is lazy?
20:51:29 <dmwit> Um.
20:51:33 <dmwit> Yes, but that's not what makes it faster.
20:52:13 <dmwit> What makes it faster is using a packed data structure instead of one where inspecting each Char involves following two pointers.
20:52:50 <tomboy64> and that is what Data.Text is for?
20:53:55 <dmwit> basically yes
20:57:15 <geekosaur> this is a little complicated. in cases where ghc can optimize it away, String (which is [Char]) can be much faster. But if it can't, having to do multiple indirections for each character is fairly slow; Text avoids this, but conversely doesn't optimize as well when the compiler can turn [Char] into a fast lazy pipeline.
20:57:53 <geekosaur> (and strictifying it would then make it slower again. laziness isn't necessarily equivalent to slowness)
20:59:00 <dmwit> Uh. This pipeline feels pretty easy to fuse away. But even knowing that my mental model was that Text was going to be faster than fused-away String.
20:59:04 <tomboy64> but in this case, because i am working with the words and lines functions, the strings cannot be optimized away?
20:59:49 <geekosaur> that depends
20:59:50 <dmwit> Hm. Maybe the nested-ness makes it harder to fuse. OKay.
21:11:21 <tomboy64> impressive
21:13:34 <tomboy64> https://bpaste.net/show/0d81fbc39442
21:13:52 <tomboy64> this runs in 8.3s on my machine
21:14:07 <tomboy64> which is ~1/4 of the original run time.
21:14:54 <tomboy64> is this sensible? any further improvement suggestions?
21:15:30 <tomboy64> not sure that foldl' is correct with importing Data.Foldable
21:16:45 <tomboy64> also, i'm not quite sure which Data.Text is imported qualified, but Data.Text.IO isn't.
21:17:41 <tomboy64> thanks for the help so far :)
21:19:57 <tomboy64> hmm. dmwit: if i may ask, if this current solution is strict, how would i write it with data.text as lazy?
21:20:16 <tomboy64> for me this looks just as lazy
21:20:39 <dmwit> You'd import Data.Text.Lazy and Data.Text.Lazy.IO.
21:21:10 <tomboy64> ahhh
21:21:16 <tomboy64> thanks again
21:52:53 <Shockk> ski: I fell asleep last night so didn't get to finish my thoughts on my type system; I've formulated them into a less confusing mess in my head now, so basically I think I'm going to have tuples that can be used as values or as types or as kinds or etc etc
21:53:50 <Shockk> i.e. `bool = <>` would not define a new type in itself, but it would define bool to be a tuple, so its kindedness (is that even a word?) would be determined upon actual usage
21:54:19 <Shockk> i.e. I could do `true = <> : bool` to make `true` be a tuple of higher-kind bool
21:54:39 * dmwit squints
21:54:52 <ski> "define bool to be a tuple" ?
21:54:54 <Shockk> but additionally I could also just treat bool as an actual value in itself, and it would be an empty value of new value 
21:55:34 <Shockk> well, if you perform substitution, it'd look like:   true = <> : <>
21:56:17 <Shockk> i.e. true is a value with no associated members, of a type with no associated members
21:56:42 <ski> from my POV, you seem to be overloading (e.g.) `<>' for two different things. in this case declaring `bool' as a data type (or data kind, if you prefer), and declaring `true' (a value, or, if you prefer, a type) to be a constructor for `bool'
21:57:05 <ski> (but perhaps you think of these two uses as in some sense being the same ?)
21:57:18 <Shockk> well what I'm more thinking about is treating values and types as the same kind of thing
21:57:50 <Shockk> i.e. rather than having distinct declarations for values and for types, instead something that's declared can theoretically be treated as either depending on what context I use it is
21:57:52 <Shockk> it in*
21:58:11 <ski> mhm. last time we spoke, you seemed to possibly consider a language with data kinds, but perhaps no data types (iiuc)
21:58:40 <Shockk> right, this is the progression of that line of thinking 
21:59:12 <ski> well. dependently typed languages tend to include types as among the values. namely as special values, which can themselves be inhabited by other values
21:59:44 <ski> (but i'm not sure whether you meant such an inclusion. or perhaps a more radical identification ?)
21:59:50 <Shockk> if I treat the concepts of values/types/kinds/etc as the same kinds of things, then I could decouple that so that declaring a 'thing' doesn't require knowledge about what level it's going to be used on]
22:01:02 <ski> hm, yes. but dependently typed languages tend to do that as well
22:01:05 <Shockk> i.e. at that point, in theory someone could program at the level beyond kinds
22:01:37 <ski> (or at least, it's not that uncommon(
22:01:40 <ski> ))
22:01:44 <Shockk> ah rihgt
22:02:00 <Shockk> I need to learn more about dependent typing as I'm not entirely clear on it in my head
22:02:03 <ski> (despite not identifying values with types)
22:02:51 <Shockk> either way I actually have to go and sleep again, already 5am 
22:03:05 <ski> i would suggest trying Agda, Idris, or maybe Epigram
22:03:10 <ski> there's also SHE
22:03:15 <ski> @where SHE
22:03:15 <lambdabot> http://personal.cis.strath.ac.uk/~conor/pub/she/
22:03:20 <Shockk> I definitely want to look into idris more at some point, it's on my todo list
22:03:38 <ski> Strathclyde Haskell Enhancement, iirc
22:04:16 <ski> Conor McBride has some interesting (colored, hand-written) slides, about dependent types, and programming with that
22:04:25 <ski> might be interesting to check out
22:05:12 <ski> Shockk : anyway, have fun pondering this
22:13:20 <MarcelineVQ> the relevant concept for this conversation is called a "universe (of types)", and while your user doesn't need to track the universe every value belongs to, you still do.
22:15:05 <MarcelineVQ> http://www2.math.uu.se/~palmgren/universe.pdf http://adam.chlipala.net/cpdt/html/Universes.html
