00:07:43 <jpcooper> Say I have a function `fun :: Applicative f => f t_1 -> f t_2 -> ... -> f t_n`. I also have functions `pure :: Applicative f => x -> f x` and `unpure :: Applicative f => f x -> x`. Can I define a general function that takes all `fun` to `t_1 -> t_2 -> ... -> t_n` for each chosen `Applicative f`, by mapping each `t_i` to `f` with pure, and mapping the result back with `unpure`?
00:08:13 <jpcooper> (without Template Haskell)
00:09:05 <phanimahesh> is the n fixed?
00:09:08 <jpcooper> I mean having a general function for all `fun` of that form, for any `n`
00:10:33 <phanimahesh> I don't see how that is possible without template haskell. Or maybe some type system magic.
00:11:01 <jpcooper> (->) and Arrow come to mind
00:13:30 <phanimahesh> I am still a beginner in haskell, I can easily whip up a function for fixed n, and I have a vague feeling it might be possible to define a general one with type families and black magic. But that's it. No clue how it might be done exactly.
00:13:53 <jpcooper> Yes
00:15:28 <calIn-> #u.s. - haida.
00:15:28 <calIn-> #u.s. - haida.
00:22:54 <jpcooper> phanimahesh: I think you could do it with a type family over type lists
00:24:39 <jpcooper> But then the question is how to view (a -> b -> c) as a : b : c : []
00:29:14 <ski> what if `c = d -> e' ?
00:44:24 <jpcooper> Yeah that's the problem
00:47:09 <ski> problem is that the notion of arity you want for `a -> b -> c' is not well-defined
00:49:29 <ski> btw, i don't see how your `unpure' could possibly work
00:49:30 <jpcooper> Should be possible to do this if we relax the function and require n
00:50:05 <jpcooper> ski: I was actually thinking about this only in the case of Identity. You're right
00:50:12 <ski> (unless you're talking about a specific `f'. but in that case, the type signature seems off)
00:50:33 <jpcooper> Let's just keep it in f
00:50:42 <ski> (i was wondering whether you could do `(f a -> f b) -> f (a -> b)' for a specific `f' you had in mind)
00:51:35 <jpcooper> f would have to be "Bi-Distributive"
00:52:30 <ski> i dunno what you mean by that
00:55:03 <jpcooper> Actually no it wouldn't. Anyway, isn't `(f a -> f b) -> f (a -> b)' the definition of Applicative?
00:55:13 <ski> nope
00:55:20 <ski> @type (<*>)
00:55:21 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
00:55:32 <jpcooper> Oh yes
00:55:59 <jpcooper> So the dual?
00:56:18 <ski> rather more like a converse kind of thing
00:56:48 <jpcooper> Okay
00:57:18 <ski> @type let unap :: (f a -> f b) -> f (a -> b); unap = undefined in unap . (unap .) . ((unap .) .)
00:57:19 <lambdabot> (f a1 -> f a2 -> f a3 -> f b) -> f (a1 -> a2 -> a3 -> b)
00:57:53 <ski> @type let extract :: f a -> a; extract = undefined; unap :: (f a -> f b) -> f (a -> b); unap = undefined in extract . unap . (unap .) . ((unap .) .)
00:57:54 <lambdabot> (f a1 -> f a2 -> f a3 -> f b) -> a1 -> a2 -> a3 -> b
00:58:27 <ski> but i dunno whether you can make that interesting, for a particular `f'
01:00:23 <jpcooper> I suppose what the real problem is, is to define functions over functions of general arity, but as you said, this is not well defined
01:00:48 <ski> why do you want to do that ?
01:01:09 <Lears> You can do something like `class Purifiable a where { type Purify a; purify :: a -> Purify a }; instance (Applicative f, Purifiable b) => Purifiable (f a -> b) where { ... }`.
01:01:33 <Lears> Then if your Applicative has `Purify (f a) = a`, it works out.
01:06:30 <jpcooper> ski: Just interest
01:06:56 <ski> i'm just not seeing where it would really help
01:07:39 <jpcooper> Is that a requirement? :)
01:13:36 <Lears> I could see it being convenient for transforming functions over newtypes to work on the underlying types, like `coerce` but without the inference problems.
01:18:38 <jpcooper> That is a good point
01:20:32 <jpcooper> Has anyone heard of someone getting stack to compile for the local machine on a remote machine?
01:21:03 <phanimahesh> arch mismatch?
01:21:11 <Rembane> GlibC grrrr?
01:21:48 <jpcooper> phanimahesh: Assume they match
01:22:33 <jpcooper> Or that someone has figured out how to mirror the environment appropriately
01:22:44 <phanimahesh> jpcooper: I do build on machine and run on another. But they're same OS.
01:23:27 <jpcooper> I was just hoping for a "seamless" solution with stack build
01:23:36 <phanimahesh> Or I follow the hack of copying up all the required shared libraries into a chroot dir and use that.
01:23:52 <jpcooper> Wouldn't adding to LD_LIBRARY_PATH be sufficient?
01:24:32 <phanimahesh> (technically equivalent to chrooting. I make a ultra minimal docker image with nothing but sh, the built binary and required shared libs)
01:24:32 <jpcooper> and maybe CPATH
01:24:37 <bwe> how to make      (+) <$> Foo 1 <*> Foo 2     work for     data Foo = Foo Int deriving (Show, Num) ? https://gist.github.com/benjaminweb/dead99658253077ce0d09ecb3f882f8a
01:25:01 <jpcooper> Nice
01:25:32 <jpcooper> bwe: Make Foo Applicative
01:26:24 <boxscape> bwe you need to make an Applicative instance for Foo, but that only works for type constructors that take one argument (i.e. something like Maybe a), so you're going to need to use `data Foo a = Foo a` instad
01:26:32 <boxscape> s/instad/instead
01:27:51 <phanimahesh> Or you can even do `data Foo a = Foo Int`
01:28:27 <Lears> bwe: If you've already derived Num, why don't you just write `Foo 1 + Foo 2`? Or even `1 + 2 :: Foo`?
01:29:51 <bwe> Lears: That's what I am wondering, too. It worked before. Now I get a   No instance nor default method for class operation +
01:30:13 <Lears> It's probably being derived by DeriveAnyClass or something.
01:30:24 <phanimahesh> use `DeriveFunctor` along with `DeriveAnyClass` and you can write `data Foo a = Foo a deriving (Show, Num, Functor, Applicative)`
01:30:40 <bwe> Lears: I get the warning   No explicit implementation for '+' ...
01:30:41 <phanimahesh> deriving Num needs DeriveAnyClass
01:31:19 <phanimahesh> bwe: Why not `newtype Foo = Foo Int`?
01:32:20 <phanimahesh> doesn't help
01:32:35 <phanimahesh> yeah, derive any class derives a useless implementation of Num
01:32:41 <Lears> You can make sure it comes from GND by using the DerivingStrategies extension. DeriveAnyClass just produces empty instance declarations to be filled in by defaults.
01:33:27 <Lears> (And yeah, it'll need to be a newtype)
01:33:41 <boxscape> I don't think we need to get into DerivingStrategies here
01:33:48 <boxscape> just make sure to not use DeriveAnyClass
01:34:04 <phanimahesh> DeriveAnyClass is useless here, even with newtype.
01:34:06 <boxscape> If you have a newtype of Int, you can use GeneralizedNewtypeDeriving to derive a Num instance
01:34:22 <phanimahesh> yeah, GND should work
01:35:13 <phanimahesh> Works.
01:35:24 <bwe> I confirrm, I need GeneralizedNewtypeDeriving to make it work.
01:35:39 <bwe> boxscape: However, it seems to collide with DeriveAnyClass, right?
01:35:57 <phanimahesh> do you need DeriveAnyClass?
01:36:20 <bwe> phanimahesh: for some Aeson stuff in different files.
01:36:31 <phanimahesh> set it on those files only
01:37:10 <phanimahesh> don't set problematic language extensions project wide.
01:37:14 <boxscape> bwe DerivingStrategies is the way around the colliding, but yeah if you can limit it in those files you don't need to worry about it
01:37:15 <bwe> I created the mess by moving all extensions to package.yaml file (specifically DeriveAnyClass).
01:37:36 <bwe> phanimahesh: I am happy to just have learned about that. 
01:37:54 <phanimahesh> There's a whitelist of "safe" extensions that can be enabled package wide in rio's docs.
01:38:51 <boxscape> some recommend against setting anything project wide, to make sure tools and readers aren't confused
01:39:53 <bwe> boxscape, phanimahesh thanks for your advice !
01:40:07 <bwe> btw: rio, relude, what else to consider as an alternative for prelude
01:40:12 <phanimahesh> that too. I would however think OverloadedStrings, ScopedTypeVariables and a few others are fine
01:40:44 <phanimahesh> bwe: rio is not a prelude replacement. It happens to have one, but it is not its primary use.
01:41:53 <boxscape> intro looked kind of interesting to me. But I haven't used a Prelude replacement in a while
01:43:27 <bwe> boxscape: it's attempt to keep things simple and be minimal seems appealing to me.
02:11:39 <bahamas> what does this error mean "Non type-variable argument in the constraint: Num (b1 -> b2)" that (b1 -> b2) is not a type variable?
02:12:41 <boxscape> yes, that's what it means
02:13:47 <boxscape> admittedly doesn't really tell you what's *actually* wrong. You might have forgotten to provide a parameter somewhere, and because of it are trying to use a function as a number
02:14:02 <mananamenos> hi, i don't understand what this line does https://github.com/Gabriel439/simple-twitter/blob/366b37e77d560a9f3f3cca67dc64426d962c959f/Main.hs#L86
02:15:40 <bahamas> boxscape: what is (b1 -> b2) then. a concrete type?
02:16:06 <bahamas> boxscape: this is the code that triggered the error: `fmap ((-1) . abs) [-2, -4]`
02:16:13 <boxscape> bahamas it's a polymorphic type, With the type constructor (->) and two type variables b1 and b2 as arguments
02:16:53 <boxscape> bahamas it interprets that as `negative 1`. To use - in that way, you need to use (\x -> x - 1), unfortunately.
02:17:16 <opqdonut> nah (flip (-) 1) is where it's at
02:17:19 <bahamas> boxscape: as in `Maybe a` is a polimorphic type, `a` is a type variable and `Maybe Int` a concrete type. right?
02:17:31 <opqdonut> or more constructively, pred
02:17:43 <__monty__> mananamenos: It unpacks a record so to speak, bringing its fields into scope. It's actually just pattern matching but using special record syntax for "all fields".
02:17:47 <boxscape> bahamas yeah
02:18:17 <__monty__> mananamenos: In this case it just brings `connectPort` into scope.
02:19:35 <bahamas> opqdonut: I was trying to show case the use of an infix operator, (.) in this case. but I found a simpler example
02:20:27 <bahamas> boxscape: is it correct to say that any type that takes at least one type variable as argument is a polymorphic type?
02:21:33 <ski> > map (subtract 1 . abs) [-2,-4]  -- bahamas
02:21:35 <lambdabot>  [1,3]
02:22:03 <mananamenos> __monty__ thanks, what the argument that getRecord takes, which is some seems some arbitrary string, what is it used for?
02:22:17 <ski> bahamas : `Maybe a' is not a polymorphic type
02:22:34 <boxscape> oh, it's not?
02:22:41 <ski> it's monomorphic
02:22:42 <jpcooper> Lears: On that coerce idea. Is (a -> b) Typeable if a and b are? I can't find where (->) is defined
02:23:08 <ski> assuming `a' is of kind `*', `Maybe a' is also of kind `*'
02:24:20 <__monty__> mananamenos: https://hackage.haskell.org/package/optparse-generic-1.3.0/docs/Options-Generic.html#t:ParseRecord
02:24:38 <__monty__> Oh, scroll up for the examples.
02:24:38 <ski> jpcooper : yes
02:24:41 <ski> @type typeOf `asTypeOf` \f -> let _ = f undefined in undefined
02:24:42 <lambdabot> (Typeable t, Typeable p) => (t -> p) -> TypeRep
02:24:57 <boxscape> ski: so, the correct thing to say would be that values of type "forall a . Maybe a" are parametrically polymorphic but the type "forall a . Maybe a" is monomorphic?
02:25:06 <jpcooper> Thanks, ski
02:25:33 <ski> @kind Const
02:25:34 <lambdabot> * -> k -> *
02:25:51 <ski> boxscape : `Const' is a polymorphic type, its kind is `forall k. * -> k -> *'
02:26:04 <ski> @type const
02:26:06 <lambdabot> a -> b -> a
02:26:15 <ski> boxscape : `const' is a polymorphic value, its type is `forall a b. a -> b -> a'
02:26:20 <boxscape> okay
02:26:36 <ski> boxscape : the presence of `forall' in the type of a value signifies the value is polymorphic
02:26:45 <ski> boxscape : the presence of `forall' in the kind of a type signifies the type is polymorphic
02:26:58 <ski> (or rather, the presence of `forall' at the front/top)
02:27:02 <boxscape> ski is there a word for types of polymorphic values?
02:27:15 <ski> i say `forall'-types, or universal types
02:27:18 <boxscape> okay
02:28:03 <ski> `x + 1' is an open expression, it has a free (value) variable `x'
02:28:21 <ski> `b1 -> b1' is an open type expression, it has free type variables `b1 -> b1'
02:28:39 <ski> you could say those are two parameters
02:29:00 <ski> er, sorry, has free type variables, `b1' and `b2'
02:30:23 <ski> one can say `Maybe', and `(->)' are parametric types, or are type functions
02:31:17 <boxscape> ski would a value of a rank 2 type like `Int -> forall a . a` be considered polymorphic?
02:31:18 <[exa]> Is there some library support for megaparsec parsing simple lists of tokens?
02:32:11 <[exa]> (e.g. some way to easily&correctly instantiate Stream for list-style stuff)
02:32:16 <nil> boxscape: is that really rank 2?
02:32:38 <boxscape> uhm well ghci doesn't accept it without RankNTypes at least
02:33:35 <boxscape> but it does infer a rank 1 type if a value of that type is given
02:33:53 <ski> boxscape : strictly speaking, no. it's a function whose result value is polymorphic. however GHC tends to convert `... -> (forall a. ..a..)' into `forall a. (... -> ..a..)'
02:34:01 <boxscape> ski okay, thanks
02:34:02 <ski> (and i'd say that's rank one)
02:34:20 <boxscape> clearly I need to read up on the definition of ranks
02:35:05 <ski> boxscape : also, a (rank two) value of type `(forall a. [a] -> [a]) -> [String] -> [String]' is definitely not polymorphic
02:35:11 <boxscape> okay
02:35:21 <ski> (rather "the opposite", so to speak)
02:36:13 <bahamas> does anyone have an example of a simple function that returns `Either`?
02:36:37 <ski> @type Left
02:36:38 <lambdabot> a -> Either a b
02:37:10 <ski> @type sequence :: [Either e a] -> Either e [a]
02:37:11 <lambdabot> [Either e a] -> Either e [a]
02:37:50 <bahamas> ok, maybe not that simple. I'm looking for a function that exemplifies how you use Either when your computation might fail, but you want to also return the reason for the failure
02:38:25 <bahamas> it doesn't have to be from Prelude or base. it just has to have a suggestive name
02:38:42 <boxscape> % :t \k -> maybe (Left $ "Could not find key " ++ show k) id . lookup k
02:38:42 <yahb> boxscape: forall {a} {b}. (Show a, Eq a) => a -> [(a, Either [Char] b)] -> Either [Char] b
02:39:44 <ski> @type Text.Parsec.parse
02:39:45 <lambdabot> Text.Parsec.Prim.Stream s Identity t => Text.Parsec.Prim.Parsec s () a -> Text.Parsec.Pos.SourceName -> s -> Either Text.Parsec.Error.ParseError a
02:39:56 * Pranz[m] sent a long message:  <  >
02:40:12 <ski> what kind of failure reason are you looking for ?
02:40:25 <ski> Pranz[m] : that looks like a very short long message
02:41:26 <boxscape> (the function I posted isn't quite what I wanted)
02:42:08 <ski> @type fromMaybe
02:42:09 <lambdabot> a -> Maybe a -> a
02:42:35 <boxscape> %  flip (\k -> maybe (Left $ "Could not find key " ++ show k) Right . lookup k) [(1, "hello"), (2, "world")] <$> [0..5]
02:42:35 <yahb> boxscape: [Left "Could not find key 0",Right "hello",Right "world",Left "Could not find key 3",Left "Could not find key 4",Left "Could not find key 5"]
02:42:45 <ski> boxscape : presumably you want some situation with more than one possible reason for failure
02:46:13 <bahamas> ski: I want something like parse :: String -> Either Error Token. something that shows a suggestive example of when you use `Either`
02:46:29 <bahamas> I don't want the implementation of the function, because this is just an example in a flash card
02:46:31 <ski> a concrete example, maybe
02:47:03 <bahamas> maybe I should just write what I wrote above, although I would prefer a real-world function that exists in a package
02:48:22 <nil> bahamas: readEither?
02:48:41 <nil> :t readEither
02:48:43 <lambdabot> error:
02:48:43 <lambdabot>     • Variable not in scope: readEither
02:48:43 <lambdabot>     • Perhaps you meant one of these:
02:49:21 <nil> :t Text.Read.readEither
02:49:23 <lambdabot> Read a => String -> Either String a
02:49:29 * ski is wondering what the multiple modes of failure would be, for parsing a token
02:49:45 <ski> (and who wants to know ?)
02:51:19 <kuribas> dminuoso: hi
02:51:33 <bahamas> this would be an example of what I mean, but the type signature isn't the easiest to understand https://hackage.haskell.org/package/aeson-1.4.6.0/docs/Data-Aeson-Parser.html#v:eitherDecodeWith
02:51:33 <kuribas> dminuoso: I am rewriting my library so it doesn't need a type family
02:51:54 <kuribas> dminuoso: then you can safely use GeneralisedNewtypeDeriving
02:52:32 <dnikolovv> guys, does anyone know if you can have something like a wildcard in exposed-modules?
02:52:36 <kuribas> dminuoso: I also want a bindAlways typeclass with a (>>!) operator which ignores pure errors.
02:52:41 <dnikolovv> e.g. export My.Modules.*
02:52:45 * ski still thinks `sequence' is a nice example
02:53:03 <dminuoso> dnikolovv: Nope, but there is an issue on github to allow for something like this.
02:53:10 <dminuoso> dnikolovv: But its not implemented yet.
02:53:10 <ski> (though, it's not concrete, it's generic. also, the name is not specific to `Either')
02:53:16 <dnikolovv> dminuoso: Thanks!
02:53:28 <dminuoso> dnikolovv: You could use hpack as a stop gap, or perhaps a shell script to generate your cabal file with.
02:53:36 <dnikolovv> dminuoso: I'm using hpack
02:53:39 <kuribas> dminuoso: which is like (>>), except that in case of Left or Nothing, it also does the second effect.
02:53:45 <dminuoso> dnikolovv: Then hpack can do this for you afaik.
02:53:58 <dnikolovv> dminuoso: it has wildcards?
02:54:03 <dnikolovv> dminuoso: I couldn't find it in the docs
02:54:17 <kuribas> dminuoso: that would solve all the issues from that article, and also give you StateT and ExceptT, etc..
02:55:18 <jpcooper> How can I have stack recompile a dependency?
02:55:50 <dnikolovv> jpcooper: --force-dirty should do the trick
02:56:45 <jpcooper> dnikolovv: Is it possible to force only a single package to be dirty?
02:57:18 <dnikolovv> jpcooper: is the dependency an external package
02:57:43 <jpcooper> force-dirty is only about local packages. I would like an external package to be rebuilt
02:57:51 <jpcooper> (dependency)
02:57:58 <typetetris> Hi there! Doesn't cabal have release notes?
02:58:01 <dminuoso> kuribas: Look into selective applicative functors.
02:58:10 <dnikolovv> jpcooper: yeah I assumed it was a local one
02:58:14 <dminuoso> kuribas: They are exactly that.
02:58:18 <dnikolovv> jpcooper: https://stackoverflow.com/questions/37236892/force-stack-to-rebuild-an-installed-package
02:58:35 <kuribas> dminuoso: right
02:59:01 <jpcooper> dnikolovv: I did that, and that stack said "using precompiled package"
02:59:06 <dminuoso> kuribas: You can share your solution if you want, but I'm still convinced that you cannot have a sane, monad-law respecting form of MonadBaseControl that doesn't suffer from issues regarding state and allow for bracket/finally/catch/etc to work right
02:59:20 <dnikolovv> jpcooper: hm let me try
02:59:54 <dminuoso> kuribas: Snoyman and many others have tried it for so long in vain.
03:00:08 <jpcooper> dnikolovv: I see I need to remove from precompiled directory as well. Thanks
03:00:43 <dnikolovv> jpcooper: makes sense, hope it resolves it
03:10:17 <kuribas> dminuoso: it's also not so clear to me what is right with respect to state.
03:10:33 <kuribas> dminuoso: should state be passed between handlers?
03:10:41 <dminuoso> "between handlers" ?
03:10:48 <dminuoso> kuribas: Yes it should.
03:10:54 <kuribas> hmm, okey
03:11:17 <dminuoso> kuribas: Otherwise exceptions cant be used for control flow at all anymore. They could only be used to crash a thread as fast as possible.
03:11:23 <kuribas> dminuoso: you'll need specialised version of bracket/..., I don't see any other way
03:19:08 * hackage zinza 0.1 - Typed templates with jinja like syntax  https://hackage.haskell.org/package/zinza-0.1 (phadej)
03:22:01 <dminuoso> kuribas: And specialized versions of catch, finally.. 
03:22:08 * hackage headed-megaparsec 0.1 - More informative parser  https://hackage.haskell.org/package/headed-megaparsec-0.1 (NikitaVolkov)
03:22:19 <dminuoso> kuribas: And things would probably get hairy fairly quickly wrt to masking
03:24:39 * hackage headed-megaparsec 0.1.0.1 - More informative parser  https://hackage.haskell.org/package/headed-megaparsec-0.1.0.1 (NikitaVolkov)
03:25:53 <dminuoso> kuribas: Plus, you quickly lose the ability to reason about what your stacks even do in these special situations.
03:26:14 <dminuoso> At the end, what I really care about is being able to unlift for things that have IO in negative position.
03:26:33 <dminuoso> e.g. `(T -> IO a) -> IO a` mainly
03:26:57 <dminuoso> And if avoiding StateT/ExceptT/ContT in your global transformer stack is the price, Im more than glad to pay that.
03:30:47 <jpcooper> Is stack meant to pass environment variables present when stack is called, when calling ghc?
04:50:09 <boxscape> Just found out that two things are possible both of which I would have guessed don't work, syntax wise
04:50:19 <boxscape> % data T = T Int Int
04:50:19 <yahb> boxscape: 
04:50:31 <boxscape> @ let a `T` b = T 4 5 in a + b
04:50:34 <boxscape> % let a `T` b = T 4 5 in a + b
04:50:34 <yahb> boxscape: 9
04:50:43 <boxscape> i.e. `` for pattern matching
04:50:52 <boxscape> % undefined :: Int `Either` Int
04:50:52 <yahb> boxscape: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:76:1 in interactive:Ghci24
04:50:55 <boxscape> and `` in types
04:51:08 <boxscape> But I'm happy that they do work
04:51:44 <dnikolovv> boxscape: very cool
05:06:25 <mananamenos> hi, i've installed hie + emacs and it seems to run pretty good. If there a way to to auto-import the package based on a function. For example when I hover fromMaybe i get an error * variable not in scope ..-- Defined in ‘Data.Maybe’*, but i can't find any emacs command to add this package to imports block
05:16:13 <fendor> mananamenos, did you build a local hoogle db?
05:17:14 <fendor> either `hoogle generate`, or, if built from source, `stack install.hs build-data` | `cabal v2-run install.hs --project-file install/shake.cabal -- build-data`
05:18:10 <fendor> or set the HOOGLE_DB env variable to the location of the local hoogle db
05:22:09 * hackage fixplate 0.1.8 - Uniplate-style generic traversals for optionally annotated fixed-point types.  https://hackage.haskell.org/package/fixplate-0.1.8 (BalazsKomuves)
05:29:13 <tabaqui1> the reason why I don't like MonadError is that "instance IOException IO" exists
05:29:17 <tabaqui1> it shouldn't
05:29:34 <tabaqui1> it's dangerous
05:33:16 <kuribas> dminuoso: what does mask have to do with pure exceptions or state?
05:33:45 <EvanR> if you're in IO, you can do much more than throw IOExceptions whether that instance exists or not
05:33:46 <lyxia> can you accidentally call throwError with an IOException
05:34:28 <lyxia> I don't see how that instance is dangerous
05:35:08 <tabaqui1> yes, you can call it accidentally, while thinking that you're inside of ExceptT IOError IO, f.e.
05:35:27 <tabaqui1> and if you're not, than you'll get runtime exception
05:35:37 <tabaqui1> (uncaught runtime exception)
05:36:10 <lyxia> sounds like a good reason not to use ExceptT IOException
05:36:16 <tabaqui1> or even worse, you have a pipelined calls with ExceptT, but first of them is ExceptT OtherException actually
05:36:26 <tabaqui1> right, you should use it at all
05:37:27 <lyxia> I mean, if you use your own exception type, there's no way to confuse it with an IOException
05:38:50 <EvanR> why would you use IOExceptions but not just throwIO them normally, in IO
05:42:08 * hackage ansi-terminal-game 0.7.0.0 - sdl-like functions for terminal applications, based onansi-terminal  https://hackage.haskell.org/package/ansi-terminal-game-0.7.0.0 (fffaaa)
05:43:12 <srid> I finally found a good "intermediate Haskell" book. It is called Chapter 9 of GHC User's Guide: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/index.html
05:44:19 <srid> I meant to use this URL: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/lang.html
05:46:05 <phanimahesh> I've read ExceptT whatever IO is a very bad idea, and am convinced by what I read.
05:46:58 <phanimahesh> IO can throw anything. The only way that ExceptT is useful is if whatever ~ SomeException, which is about as good as just IO.
05:47:29 <EvanR> well you can use ExceptT or WhateverT locally to get some task done and carry on normally
05:48:11 <EvanR> but ExceptT and StateT don't make sense to me as part of a global app stack over IO
05:48:52 <tabaqui1> I use ExceptT locally, but all api methods returns just m (Either MyException a)
05:49:06 <tabaqui1> but it's ok to use ExceptT inside
05:49:32 <phanimahesh> yeah. The argument is only about ExceptT over IO. I think StateT was mentioned too but I don't fully understand how they interact.
05:50:56 <EvanR> ExceptT over IO can still be used to do a local task that may fail 
05:51:09 <EvanR> with a specific user error type
05:52:53 <EvanR> phanimahesh: got a link to this anti ExceptT over IO propaganda?
05:53:19 <boxscape> any paramorphism can be implemented as catamorphism, right?
05:53:37 <EvanR> if you have tuples sure
05:53:45 <boxscape> ok
05:54:16 <phanimahesh> EvanR: https://tech.fpcomplete.com/blog/2016/11/exceptions-best-practices-haskell under the section The Bad
05:54:27 <EvanR> ah classic
05:54:31 <phanimahesh> ExceptT IO anti-pattern
05:54:38 * hackage ansi-terminal-game 0.7.1.0 - sdl-like functions for terminal applications, based onansi-terminal  https://hackage.haskell.org/package/ansi-terminal-game-0.7.1.0 (fffaaa)
05:54:41 <[exa]> Is there some rigorous documentation about the semantics of Megaparsec's error offset?
05:55:01 <[exa]> In particular, should it be fixed to number of characters, or is it the number of tokens (if I'm using custom datatype for parsing) ?
05:55:05 <phanimahesh> Yeah I've been devouring articles from fpcomplete. Great resources IMO.
05:55:21 <[exa]> I'm currently guessing the second but there's not a single line about that in docs.
05:59:33 <EvanR> phanimahesh: point 2 and 3 aren't convincing, either by being wrong or by missing a point respectively. Also it seems to assume were making a wide ranging app stack sort of thing rather than carrying out a local computation
06:00:16 <EvanR> and global app stacks are sort of their own can of worms beyond ExceptT
06:00:54 <phanimahesh> The argument seems to be that the type is reduced to a hint instead of being a contract when ExceptT wraps overIO
06:00:59 <magneticduck> what is the correct typeclass for a module over Integer?
06:01:11 <magneticduck> having a hard time searching for this since "module" has another meaning in Haskell
06:01:34 <EvanR> if it's used as a hint, yeah that'd be smelly
06:01:41 <magneticduck> (I mean a module over a ring)
06:01:51 <phanimahesh> as in modulus?
06:02:41 <phanimahesh> EvanR: Yeah. The argument is that ExceptT over IO is always a hint, since there is no _guarantee_ that the code doesn't throw other exceptions than the one listed in the type.
06:03:18 <EvanR> a module is similar to and a generalization of a vector space
06:03:31 <magneticduck> nice, Data.Ring.Module
06:04:13 <EvanR> well that argument is specious... and it seems clear that ExceptT Foo IO is adding 1 thing to the pandoras box that is IO
06:05:24 <EvanR> not limiting anything, i don't get why they went there. 
06:05:43 <EvanR> section seems like a reaction to some bad code encountered at work :)
06:07:23 <phanimahesh> Possible.
06:07:39 * hackage headed-megaparsec 0.1.0.2 - More informative parser  https://hackage.haskell.org/package/headed-megaparsec-0.1.0.2 (NikitaVolkov)
06:08:17 <phanimahesh> I haven't really used transformer stacks yet. Without getting a feel for the uses and gotchas I can add little besides parroting my initial opinion.
06:12:11 <sm[m]> srid: thanks for that link.
06:13:12 <phanimahesh> wow automatic differentiation is a very nice trick. and extremely interesting
06:20:24 <saml> what are nominees of monad blog post of the  year for 2019?  award is given in december, right?
06:20:55 <EvanR> best monad tutorial of 2019?
06:23:11 <saml> yeah i heard every new learners end up writing monad tutorial every year
06:23:30 <saml> and we should celebrate new comers by awarding best monad tutorial every year
06:23:52 <phanimahesh> hahaha, I can't decide if that's a good or a bad idea.
06:24:19 <phanimahesh> Are monads still burritos or did someone make them quesadillas yet?
06:24:23 <saml> that sounds like quantum computing
06:25:10 <EvanR> burritos was a pretty early theory, monads moved on since then
06:25:30 <fendor> I never wrote a monad tutorial :/ Now I feel like I skipped somethign in my haskell experience :/
06:25:39 <phanimahesh> What was the evolution chain?
06:25:48 <phanimahesh> should I write a monad tutorial?
06:25:52 <EvanR> https://wiki.haskell.org/Monad_tutorials_timeline
06:26:18 <phanimahesh> I wonder if any other language has a tutorial timeline for a single concept
06:26:23 <phanimahesh> or the whole language
06:26:30 <EvanR> dang this list doesn't mention burritos at all
06:27:48 <kuribas> I think monads are pipes, like the internet
06:28:10 <saml> wow thanks
06:28:13 <kuribas> or was it tubes?
06:28:32 <saml> so we stopped at 2015
06:28:40 <EvanR> comonad tutorials as underappreciated / underridiculed
06:28:46 <EvanR> are*
06:28:47 <phanimahesh> space suits and nuclear waste containers?
06:29:04 <EvanR> comonads are night clubs
06:29:16 <[exa]> nnected copancakes
06:29:35 <kuribas> or ants
06:30:07 <EvanR> comonads are ants?
06:30:25 <EvanR> at this point i wouldn't be surprised
06:30:45 <kuribas> they no their place and surroundings, but they are just a part of the whole...
06:31:07 <shapr> whoa, that's profound dude
06:31:32 <srid> How do I search for typeclasses beginning with `Is` in Hoogle?
06:31:48 <EvanR> saml: 2015 might be when the wiki was finally abandoned
06:31:59 <tdammers> EvanR: that list is a frighteningly accurate reflection of the Haskell buzzsphere
06:32:20 <kuribas> it seems cuda cores are comonadic as well...
06:32:23 <saml> wow what happened to wiki
06:33:03 <saml> did microsoft purchase haskell in 2015? they purchase everything
06:33:06 <tdammers> if you look at the early Monad tutorials, you can see that they're still struggling to understand Monads: "For our purposes, a monad is a triple of a type and then> & return operators defined over it so that the following laws apply: ..."
06:33:49 <EvanR> 2002 "yet another monad tutorial"
06:34:20 <kuribas> I encountered monads first in the "Gentle introduction to haskell", and was thoroughly confused.
06:34:43 <EvanR> around 13000 BC a burial site was discovered with anatomically modern human with a battle axe and a monad tutorial
06:35:01 <saml> don't forget to tell your grandkids your first monads this thanksgiving
06:35:03 <tdammers> fortunately, by 2012, people had figured them out: "Monads are conditional function calls"; "Monads are really about composing functions"; "Monads are a generalization of functions, function application, and function composition to allow them to deal with richer notions of computation than standard functions"; "it's best to think of a monad as representing some context. What do I mean by context? ..."
06:35:43 <EvanR> lol
06:35:45 <phanimahesh> how are they conditional function calls?
06:35:53 <EvanR> programmable semicolon
06:35:59 <kuribas> Maybe monad I suppose?
06:36:08 <phanimahesh> hmm....
06:36:20 <kuribas> wouldn't work with state though
06:36:27 <tdammers> and if that doesn't do the trick, Bartosz waltzes in and saves the day: "A monad is an endofunctor together with two special families of morphisms, both going vertically, one up and one down"
06:36:34 <phanimahesh> and what, pray tell, are comonads? I think one of you mentioned them earlier too, but I forgot. :/
06:36:50 <tdammers> "A monad is just an endofunctor together with two special families of morphisms, both going vertically, one up and one down, what's the problem?"
06:37:36 <tdammers> clearly a comonad is just an endofunctor (endocofunctor, but that's the same thing) together with two special cofamilies of comorphisms, both going vertically, one down and one up.
06:38:07 <phanimahesh> Are you sure it shouldn't read both cogoing covertically?
06:38:26 <EvanR> since cothings are just things with arrows reversed it's curious how they even can matter
06:39:35 <phanimahesh> That's even better. If it technically means the same the more the merrier
06:39:55 <tdammers> cogoing is coming
06:40:05 <tdammers> covertically however is just vertically, but with the directions reversed
06:40:07 <phanimahesh> I feel good that I understood "endofunctor (endocofunctor, but that's the same thing)"
06:40:12 <EvanR> :t Control.Comonad.extract
06:40:12 <tdammers> hehe
06:40:14 <lambdabot> Control.Comonad.Comonad w => w a -> a
06:40:20 <EvanR> :t Control.Comonad.duplicate
06:40:22 <lambdabot> Control.Comonad.Comonad w => w a -> w (w a)
06:40:38 <phanimahesh> :t duplicate . join
06:40:40 <lambdabot> error:
06:40:40 <lambdabot>     • Variable not in scope: duplicate :: m a -> c
06:40:40 <lambdabot>     • Perhaps you meant one of these:
06:40:42 <EvanR> :t Control.Comonad.extend
06:40:43 <lambdabot> Control.Comonad.Comonad w => (w a -> b) -> w a -> w b
06:40:58 <phanimahesh> :t Control.Comonad.duplicate . join
06:41:00 <lambdabot> (Control.Comonad.Comonad w, Monad w) => w (w a) -> w (w a)
06:41:15 <EvanR> Wonad 
06:41:25 <Phillemann> polysemy question: I have "f :: Member Foo r => r (); f = foo <- if something then g else h" and ghc tells me it doesn't have "Member Foo r1 for g", what do I do? Add a type annotation somewhere?
06:41:31 <phanimahesh> uwu monad?
06:41:50 <Phillemann> (g is of type Member Foo r => r Bool)
06:41:53 <tdammers> if a Monad eats a categorical mushroom, does it turn into Super Monad?
06:42:05 <kuribas> the tis-100 core looks like a comonad.
06:42:06 <EvanR> lol
06:43:08 <phanimahesh> so I see the functions in comonad, and kind of understand what they do. How are they useful? Examples of usage?
06:43:21 <EvanR> sounds like you need a comonad tutorial
06:43:25 <phanimahesh> yep.
06:43:40 <phanimahesh> one tutorial a day keeps sleep away
06:43:47 <EvanR> https://eli-jordan.github.io/2018/02/16/life-is-a-comonad/
06:43:59 <phanimahesh> The title.. The title scares me
06:44:17 <boxscape> hm I can't seem to figure out how to write tail with foldr
06:45:02 <EvanR> http://blog.emillon.org/posts/2012-10-18-comonadic-life.html
06:45:19 <EvanR> http://blog.emillon.org/posts/2012-10-18-comonadic-life.html
06:45:35 <sm[m]> @remember EvanR around 13000 BC a burial site was discovered with anatomically modern human with a battle axe and a monad tutorial
06:45:35 <lambdabot> Good to know.
06:46:23 <shapr> I heard the battle axe weighed 300 pounds
06:49:02 <EvanR> sm[m] you're reviving the wiki, the lambdabot quotes... what's next
06:49:34 <boxscape> reviving Miranda
06:49:49 <phanimahesh> boxscape: not straightforward. use an accumulator and reverse.
06:49:51 <EvanR> proprietary tech dies a quiet death
06:50:01 <boxscape> phanimahesh okay, I'll try, thanks
06:50:42 <EvanR> er, reverse will necessarily not work on infinite lists
06:50:49 <EvanR> tail does
06:51:03 <sm[m]> EvanR: haskell.org ?!  on a roll !
06:51:16 <EvanR> ok i can get behind that
06:52:37 <phanimahesh> yeah. also I just realized it's foldr, not foldl
06:53:15 <phanimahesh> is it even possible to use foldr to implement tail? Maybe just for finite lists
06:53:38 <phanimahesh> it is impossible for infinite lists
06:53:48 <EvanR> it should be fairly staight forward 
06:54:03 <EvanR> foldr is *the* way to process a list
06:54:03 <boxscape> any function that can be implemented with pattern matching can be implemented with foldr, as far as I'm aware
06:54:49 <sm[m]> https://github.com/haskell-infra/www.haskell.org/ has 11 stars, needs more love
06:54:56 <phanimahesh> EvanR: I thought foldl is the universal fold?
06:55:17 <EvanR> for list it's foldr
06:55:53 <boxscape> the Church encoding of lists is in terms of foldr
06:57:23 <phanimahesh> I mixed them up, sorry.
06:57:49 <phanimahesh> yeah. foldr seems to be the universal one.
06:59:15 <kuribas> > snd $ foldr (\e r -> (e:fst r, fst r)) ([], error "no tail") [a, b, c]
06:59:17 <lambdabot>  [b,c]
06:59:51 <boxscape> thanks!
06:59:53 <EvanR> > snd $ foldr (\e r -> (e:fst r, fst r)) ([], undefined) (repeat 'a')
06:59:55 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
07:00:09 <kuribas> duplicates the tail though
07:00:25 <boxscape> in what sense?
07:00:33 <kuribas> boxscape: it makes a copy of the tail
07:00:37 <boxscape> ah
07:01:34 <boxscape> so it's less efficient than the canonical version
07:01:42 <kuribas> yes
07:01:44 <phanimahesh> I wrote the foldl version and was scratching my head why it was giving reverse.tail.reverse
07:02:30 <kuribas> I don't think it's even possible with foldr at the head position
07:02:35 <phanimahesh> > snd $ foldr (\x (first, acc) -> (False, if first then acc else x:acc)) (True,[]) [1, 2,3]
07:02:37 <lambdabot>  [1,2]
07:02:54 <phanimahesh> > snd $ foldl (\x (first, acc) -> (False, if first then acc else x:acc)) (True,[]) [1, 2,3]
07:02:56 <lambdabot>  error:
07:02:56 <lambdabot>      • Occurs check: cannot construct the infinite type: a ~ (Bool, [a])
07:02:56 <lambdabot>        Expected type: [(Bool, [a])]
07:03:08 <phanimahesh> ..... lemme flip the args
07:03:41 <phanimahesh> > > reverse.snd $ foldl (\(first, acc) x -> (False, if first then acc else x:acc)) (True,[]) [1, 2,3]
07:03:43 <lambdabot>  <hint>:1:1: error: parse error on input ‘>’
07:03:50 <phanimahesh> > reverse.snd $ foldl (\(first, acc) x -> (False, if first then acc else x:acc)) (True,[]) [1, 2,3]
07:03:52 <lambdabot>  [2,3]
07:04:05 <boxscape> > reverse.snd $ foldl (\(first, acc) x -> (False, if first then acc else x:acc)) (True,[]) [1..]
07:04:12 <lambdabot>  mueval-core: Time limit exceeded
07:04:17 <EvanR> foldl really is a bad idea here
07:04:26 <phanimahesh> ofcourse it won't work for infinite lists
07:04:46 <EvanR> even for finite it requires going to the end of the list first
07:04:59 <phanimahesh> EvanR: yeah. I mixed up foldl and foldr, thought foldl was the universal one.
07:05:27 <EvanR> foldr being a catamorphism you would expect to tuple things and duplicate data
07:05:46 <EvanR> a paramorphism would be convenient for sharing existing structure
07:06:02 <phanimahesh> Examples of generic paramorphisms?
07:06:05 <boxscape> does that mean you can't do it with foldr without traversing the whole structure?
07:06:31 <EvanR> you did it with foldr without traversing the whole structure
07:06:40 <EvanR> phanimahesh: well, see natural number induction
07:06:51 <phanimahesh> boxscape: Technically both solutions traverse the entire structure. but foldr gives a thunk and you can choose to not evaluate the whole structure.
07:06:59 <boxscape> ok
07:07:23 <phanimahesh> foldl requires traversing the entire thing before even giving you anything.
07:07:47 <phanimahesh> EvanR: as in proofs by induction?
07:07:52 <EvanR> yeah
07:08:24 <phanimahesh> yeah. That can be seen as a paramorphism
07:08:25 <EvanR> you can think of induction as a fold
07:09:17 <phanimahesh> folding over numbers, with accumulator being proof until previous n?
07:09:22 <phanimahesh> I never thought of it as such
07:09:48 <EvanR> proof of P(previous n) is the accumulator
07:10:07 <phanimahesh> yeah.
07:10:43 <boxscape> hm, are there inductive proofs for which you need P(n-1) and P(n-2)?
07:10:46 <phanimahesh> Why do I see more foldl in the wild?
07:10:57 <phanimahesh> boxscape: yep.
07:10:57 <EvanR> in the end, you give it any number and it folds that many times to get the proof
07:11:37 <phanimahesh> To generalize it, the accumulator is the set of proofs until n-1.
07:11:42 <EvanR> you probably see foldl' in the wild
07:12:05 <phanimahesh> yes, the strict version.
07:13:09 * hackage tmp-postgres 1.15.0.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.15.0.0 (JonathanFischoff)
07:14:05 <phanimahesh> I think I see why foldl' is preferrable in many cases.
07:14:17 <phanimahesh> but feels counterintuitive.
07:14:33 <EvanR> it corresponds to what people think of as "reduce" outside haskell
07:14:54 <EvanR> go through the list one by one and update an accumulator, from the beginning
07:15:02 <phanimahesh> yeah
07:24:22 <boxscape> I suppose the main reason I wasn't able to solve tail via foldr was because I was only looking for solutions that don't deconstruct the whole list
07:24:25 <exarkun> Anybody know if there's an easy way to get a complete traffic dump from a Servant server?
07:26:09 <exarkun> maybe just for any network.wai server
07:27:25 <EvanR> boxscape: hmm. not sure i buy it.
07:28:05 <EvanR> "deconstruct the whole list" sounds like a large cost
07:28:21 <boxscape> maybe I'm not expressing it correctly
07:28:26 <EvanR> but for a lazy list, your foldr version of tail pays an incremental cost
07:28:50 <boxscape> pattern matching version has sharing where foldr version doesn't, is that right?
07:29:31 <EvanR> if the goal is to get a lazy list that reproduces the tail of some list, you did it and payed very little
07:29:36 <berndl> Are there higher-order versions of Foldable that anyone has heard about? It seems to me that e.g. Free is a higher-order Foldable.
07:30:29 <boxscape> EvanR to be clear when I say "was looking for" I don't mean that I'm not satisfied with the presented solution, I mean that I wasn't looking for solutions where I should have been looking
07:30:44 <EvanR> if you forget the original list, then it's still possible to process the tail in a fixed amoutn of memory
07:31:07 <EvanR> even if it's infinite
07:31:58 <boxscape> (also btw neither of the solutions posted here were mine, it was kuribas's and phanimahesh's)
07:33:47 <f-a> I often see "-f enable-tests" flags, what are they useful for?
07:34:03 <f-a> if I `cabal new-run someexe` it won't build test anyway
07:34:30 <boxscape> I guess another way to express my point is that with the foldr version, if you replace (:) with (+) and [] with 0, you get sum. With the canonical pattern matching version, you can't do that.
07:34:39 <EvanR> yeah, if the original list consisted of a "element generator" rather than literally a list, then the foldr version of tail gives at best a slightly slower generator that wraps the original
07:35:52 <EvanR> the pattern matching version simply returns the generator after taking an element, other than that not much difference
07:36:03 <EvanR> of course if you piled on many such tails the cost will add up
07:36:09 * hackage curry-base 1.1.1 - Functions for manipulating Curry programs  https://hackage.haskell.org/package/curry-base-1.1.1 (CurryLanguage)
07:36:30 <boxscape> performance wasn't my main concern - I was mostly trying to figure out why I got stuck
07:36:46 <EvanR> and if you don't forget the original list, i think it causes a space leak
07:37:08 * hackage curry-frontend 1.0.4 - Compile the functional logic language Curry to severalintermediate formats  https://hackage.haskell.org/package/curry-frontend-1.0.4 (CurryLanguage)
07:38:20 <EvanR> boxscape: i noticed you often need to keep state in a tuple to get things done with foldr (or any basic eliminator)
07:38:36 <boxscape> okay
07:38:49 <EvanR> i'm not sure what else you could have done really
07:39:11 <boxscape> I have heard para desribed as the Tuple trick so that sounds like the same thing
07:39:38 <EvanR> para is tuple state where the state is specifically "the original data structure here"
07:40:05 <boxscape> I see
07:41:20 <EvanR> which would make tail trivial!
07:41:55 <boxscape> yeah I actually started with seeing tail written with para, then tried to right it with cata, and after not succeeding tried it with foldr instead
07:42:03 <boxscape> s/right/write
07:42:36 <boxscape> hoping that it would help me solve the cata case
07:42:49 <boxscape> s/case/version
07:44:07 <EvanR> another way to see it is, if you wanted the original data structure here with a cata, you'd imagine rebuilding the entire thing from the ground up and providing the structure at each step to the f at that step
07:44:37 <kuribas> > snd $ foldr (\e (e2,r) -> (e, e2:r)) ([], error "no tail") [a, b, c]
07:44:39 <lambdabot>  error:
07:44:39 <lambdabot>      • Couldn't match expected type ‘[a]’ with actual type ‘Expr’
07:44:39 <lambdabot>      • In the expression: a
07:45:00 <EvanR> even identity function using foldr would have to do this
07:45:14 <boxscape> ah, yeah that's a good point
07:45:52 <EvanR> > foldr (\x xs -> x:xs) [] [1..]
07:45:54 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
07:47:52 <EvanR> so that's why "decontructing the entire list" sounded backwards, you're really reconstructing the list
07:48:25 <boxscape> yeah, that makes sense
07:53:38 * hackage ansi-terminal-game 0.7.2.0 - sdl-like functions for terminal applications, based onansi-terminal  https://hackage.haskell.org/package/ansi-terminal-game-0.7.2.0 (fffaaa)
07:53:41 <EvanR> "The most difficult concept to master while learning Haskell is that of understanding and using monads." oh... if only
07:54:34 <berndl> I thought the most difficult part is understanding the operational semantics of Haskell under GHC.
07:56:05 <maerwald> well, that is learning GHC ... /nitpick
07:56:23 <berndl> True.
07:56:34 <MarcelineVQ> if monads are so hard why do I have more trouble writing applicative instances than monad instances
07:56:52 <maerwald> MarcelineVQ: also try selective!
07:57:12 <phadej> (<*>) = ap; what's difficult in that!
07:57:55 <berndl> phadej: that assumes that you want the applicative instance from the monad.
07:59:29 <MarcelineVQ> maerwald: I've linked that here a few times :D
07:59:33 <maerwald> also, doesn't that break optimisation of applicatives?
07:59:53 <phanimahesh> what's this about optimising applicatives?
08:00:08 <berndl> optimisations under GHC?
08:00:19 <phanimahesh> which specific one, I mean
08:00:25 <EvanR> dang 3 british spellings of optimization in a row
08:00:43 <phanimahesh> from my reading (<*>) = ap is fairly common
08:00:53 <maerwald> MarcelineVQ: "It  is possible to implement branch in terms of select, which is a good  puzzle (give it a try!)." -- I found that to be quite enlightening (although, I only made it half-way)
08:02:01 <maerwald> can it be statically analyzed when it's the monad ap?
08:02:06 <phanimahesh> For historic reasons, apparently, people did that instead of what I would assume would be more natural ap = (<*> )
08:02:38 <phanimahesh> maerwald: why not? monads are not special at all.
08:02:43 <maerwald> they are
08:02:53 <maerwald> that's why we have selective, no?
08:03:04 <phanimahesh> How are they "special"?
08:03:12 <maerwald> you cannot statically analyze effect flow
08:03:13 <berndl> Monads are dynamic.
08:03:34 <phanimahesh> Any special stuff is in a particular instance, monad type class in general does nothing special.
08:03:35 <maerwald> applicatives are static, selective is... guess what :P
08:04:12 <maerwald> phanimahesh: nah, it's not about the instance
08:04:30 <maerwald> http://neilmitchell.blogspot.com/2019/10/monads-as-graphs.html
08:04:42 <phanimahesh> I don't see how monads are any more dynamic than say applicatives
08:04:45 <kuribas> EvanR: said who?
08:04:48 <maerwald> check the link
08:05:00 <maerwald> phanimahesh: the effect is determined dynamic
08:05:03 <kuribas> I find the most difficult part about haskell type class resolution.
08:05:08 <maerwald> it depends on the value
08:05:46 <kuribas> Type level computation is actually fairly simple.
08:06:02 <kuribas> It just gets hairy when mixing with type classes.
08:06:03 <maerwald> I still suck at type families...
08:06:13 <ski> @where applicative-vs-monadic
08:06:13 <lambdabot> "Applicative vs Monadic build systems" by ndm in 2014-07-23 at <https://neilmitchell.blogspot.se/2014/07/applicative-vs-monadic-build-systems.html>. (cf. "static sequencing" vs. "dynamic sequencing")
08:06:17 <ski> phanimahesh ^
08:06:21 <kuribas> maerwald: type families are type level functions.
08:06:25 <maerwald> yeah
08:06:46 <phanimahesh> I'm reading that, and selectives. brb
08:06:48 <kuribas> there is not much more about them.
08:06:50 <maerwald> I know what they do and can understand it when I read it. But I can't come up with solutions that involve them...
08:06:56 <maerwald> Maybe that means I don't need them
08:07:01 <kuribas> maerwald: yeah
08:07:11 <EvanR> kuribas: monad tutorial "All about monads"
08:07:24 <ski> @where AAM
08:07:24 <lambdabot> http://www.haskell.org/haskellwiki/All_About_Monads
08:07:38 <kuribas> don't look for solutions in need of problems.
08:07:55 <maerwald> The Vector with fixed size example was compelling
08:08:01 <maerwald> But the implementation sooo convoluted
08:08:34 <EvanR> type families aren't exactly type level functions so it's not so cleanly squared away yet
08:09:18 <EvanR> type level functional relations?
08:09:28 <lortabac> type families are not parametric
08:09:44 <tomjaguarpaw> How does Hedgehog know which line number a test failure came from?
08:09:50 <phanimahesh> I don't see how applicative as a graph is a node having two children. I see the merging with liftA2
08:09:53 <berndl> Also, there are two types of type families: open and closed.
08:10:13 <dminuoso> berndl: Is the fact that a type family is closed observable somehow?
08:10:23 <dminuoso> (Or does GHC use this for inference somehow?)
08:11:29 <berndl> dminuoso: All I can tell you is that if it is closed, I cannot add "instances" anymore.
08:11:34 <boxscape> don't closed type families have a somewhat well defined order in which the equations are attempted to be matched, or something like that?
08:11:57 <dminuoso> berndl: Oh Im aware. Just wondering whether closed type families have behavioral differences from open ones.
08:12:32 <boxscape> % type family Test t where Test Int = Int; Test t = String
08:12:32 <yahb> boxscape: 
08:12:46 <boxscape> this doesn't seem to make much sense as an open family
08:13:10 <kuribas> EvanR: starting with a complicate description of monads is not the way to go IMO.
08:13:25 <kuribas> EvanR: better build up a few examples, then show how monads simplify them.
08:13:26 <boxscape> in fact it would give you conflicting definitions errors if you tried it
08:13:45 <EvanR> kuribas: i was morbidly curious about these old monad tutorials
08:13:53 <dminuoso> kuribas: But that's the thing. Monad doesn't simplify anything in particulra.
08:13:59 <dminuoso> Monad *generalizes*
08:14:06 <dminuoso> Which is why its so hard for beginners to learn.
08:14:13 <ski> phanimahesh : if you use `(<*>) :: I (a -> b) -> I a -> I b' to build an `I b' from an `I (a -> b)' and an `I a', then you can possibly analyze those two latter parts, when looking inside the `I b', without/before handling `a's and `b's
08:14:32 <dminuoso> You can't present them with any single problem for which monad is a solution. 
08:14:37 <dminuoso> Monad is not a solution for any given problem
08:14:46 <EvanR> and generalizing can simplify reasoning, and in miraculous cases, actually simplify the original problem
08:15:10 <EvanR> but more likely change your problem and annoy your coworkers
08:15:12 <bolver> how does this work, even though the second function only takes 1 argument?  ((\x y -> x + y) . (\x -> x * x)) 2 4
08:15:30 <maerwald> phanimahesh: why not
08:15:49 <ski> phanimahesh : if you use `(=<<) :: (a -> M b) -> M a -> M b' to build an `M b' from an `a -> M b' and an `M a', then you can analyze the `M a', but not the `a -> M b', when looking inside the `M b', without/before handling `a's and `b's
08:16:03 <phanimahesh> ski: Okay. So you can build a static dependency graph without understanding what I does internally.
08:16:10 <kuribas> dminuoso: it simplifies nested pattern matching on maybe.
08:16:11 <maerwald> compare: fmap :: (a -> b) -> m a -> m b: "m a" is your start node, "m b" is the other and (a -> b) is the morphism
08:16:14 <boxscape>  > ((\x y -> x + y) . (\x -> x * x)) a b
08:16:20 <dminuoso> kuribas: No it does not. Monad is the generalization of what that means.
08:16:26 <ski> phanimahesh : to be able to extract any information from an `a -> M b', you must get hold of an `a', so you must execute the `M a'. so you can't statically analyze the structure, before executing it
08:16:33 <boxscape> lambdabot?
08:16:35 <dminuoso> kuribas: The solution to what you want is `thenMaybe :: Maybe a -> (a -> Maybe b) -> Maybe b` 
08:16:42 <boxscape> > ((\x y -> x + y) . (\x -> x * x)) a b
08:16:44 <lambdabot>  a * a + b
08:16:46 <maerwald> for dependency graphs in build systems this is pretty significant
08:16:48 <kuribas> dminuoso: you mean monad bind is a generalisation of flatMap?
08:16:53 <dminuoso> kuribas: But that's not what Monad is about. Monad is about giving a uniform interface, and then handing you combinators that work over any monad.
08:17:03 <kuribas> yes
08:17:35 <dminuoso> 17:16:25      kuribas | dminuoso: you mean monad bind is a generalisation of flatMap? <- yes.
08:17:48 <ski> what's `flatMap' ?
08:17:55 <dminuoso> ski: bind for list.
08:17:55 <berndl> From Scala?
08:18:02 <boxscape> bolver first, the first argument is given to the second function, resulting in (\x y -> x + y) (2 * 2) 4. Then, it just adds both and you get 12
08:18:02 <dminuoso> ski: "map then flatten"
08:18:03 <ski> you mean `concatMap' ?
08:18:15 <dminuoso> ski: Sure. That's the Haskell name for it. Other languages frequently call it flatMap
08:18:24 <boxscape> and by 12 I mean 8, of couese
08:18:29 <boxscape> s/couese/course
08:18:32 <berndl> dminuoso: which other languages?
08:18:54 <phanimahesh> dminuoso: Javascript. Python too iirc
08:18:55 <dminuoso> berndl: e.g. Ruby, Scala, JavaScript
08:19:05 <bolver> boxscape: i see that, but is that really how ghc does it?
08:19:06 <phanimahesh> err, I meant berndl 
08:19:47 <dminuoso> kuribas: Actually it's even more. It's not the generalization of flatMap. It's the generalization of thenList, thenIO, thenMaybe, thenEitherA, etc.. one to bind them all!
08:19:48 <bolver> i don't see that from the definition of (.)
08:19:56 <boxscape> @src (.)
08:19:56 <lambdabot> (f . g) x = f (g x)
08:20:05 <boxscape> why not?
08:20:13 <berndl> dminuoso: well, techinically flatMap is bind in Scala. And in JS, it's for arrays.
08:20:18 <EvanR> it's finally happened. #haskell is no longer dwelling either on theory of Applicative/Monads or on build systems. They've combined into applicative and monadic build systems
08:20:33 <dminuoso> berndl: Pardon me, I might have confused it. But that's my point, really.
08:20:43 <EvanR> a shambling abomination of a topic :)
08:20:45 <bolver> boxscape: in this case `x` is 2 4
08:20:58 <boxscape> bolver, no, x is just 2
08:21:03 <kuribas> dminuoso: so then after showing how these functions are similar, you let the student discover himself the pattern.  Rather than giving an inscrutable sentence.
08:21:17 <boxscape> bolver the 4 isn't part of the (.) equation taht @src shows
08:21:24 <dminuoso> kuribas: But what problem requires such a solution?
08:21:33 <bolver> boxscape: i see
08:21:37 <boxscape> bolver `(f . g) x` can return a function, and in this case, it does
08:21:41 <boxscape> s/return/be
08:21:52 <dminuoso> kuribas: Monad is a tool for convenience. We could throw away the Monad typeclas and have explicit thenXXX functions instead, we could achieve just as much.
08:22:16 <EvanR> can we have the type class and the do notation? thx
08:22:19 <dminuoso> If the problem is "how do I generalize over this", then sure Monad is the solution. But beginners very rarely have the problem of having `thenIO`, `thenMaybe`, etc.. all flying aroud.
08:22:20 <berndl> dminuoso: We could also through away all types and just work with raw bits.
08:22:30 <kuribas> dminuoso: many problems.  By grouping them together, you get a common framework, which avoids that a programmer has to learn the same thing over and over again.
08:22:37 <phanimahesh> bolver: all functions in haskell take a single argument
08:22:39 <dminuoso> kuribas: It's not a problem beginner problems face.
08:22:56 <bolver> boxscape: so (f . g) x y = f (g x) y?
08:22:59 <boxscape> so ((\x y -> x + y) . (\x -> x * x)) 2 4 = (((\x y -> x + y) . (\x -> x * x)) 2) 4, which fits the equation like ((f . g) x) 4 = (f (g x)) 4, bolver
08:23:00 <kuribas> they'll face it soon enough :)
08:23:06 <boxscape> exactly bolver
08:23:12 <dminuoso> kuribas: Beginners want to figure out "how do I sequence things in IO" - and then Monad is definitely not even remotely a solution. It's just an interface that generalizes nicely for advanced programmers, but is confusing to grasp for beginners.
08:23:27 <berndl> bolver: (f . g) x y = ((f . g) x) y)
08:23:35 <EvanR> yeah do not bring up monads when introducing IO
08:23:42 <kuribas> dminuoso: that's why you should first explain how IO works, before mentioning monads.
08:23:43 <phanimahesh> (f . g) x y = (f (g x)) y?
08:24:07 <EvanR> you don't even need to bring up monads when introducing do notation for IO
08:24:19 <phanimahesh> (ignore that ?)
08:24:43 <EvanR> phanimahesh: yes
08:24:53 <bolver> i see
08:25:00 <phanimahesh> EvanR: I was stating. :P
08:25:13 <phanimahesh> bolver: (\x y -> x + y) is the same as \x -> \y -> x + y
08:25:14 <EvanR> :P?
08:25:27 <bolver> new knowledge for me -- thanks
08:25:49 <maerwald> I agree with dminuoso. if you check rust https://doc.rust-lang.org/std/result/enum.Result.html it is less general, but perfectly usable (see "and", "and_then", etc)
08:26:12 <bolver> phanimahesh: correct, but i didn't the (.) worked lied that
08:26:18 <kuribas> phanimahesh: (f . g) x == f (g x) (by definition of (.)), so (f . g) x y == ((f . g) x) y == (f (g x)) y == f (g x) y
08:26:23 <maerwald> and with sufficient tooling you quickly get used to it and don't notice that there's some CT behind all that
08:26:27 <dminuoso> kuribas: The generalization is not a very common problem. Im willing to argue that not many people could have invented Monad.
08:26:39 <phanimahesh> bolver: So ((\x y -> x + y) . (\x -> x * x)) = (\x -> \y -> x + y) . (\x -> x * x)
08:26:48 <dminuoso> kuribas: It's a common theme to say "You could have invented Monads yourself", but what people usually mean whey they say that, is that you could have invented any given Monad *instance* yourself.
08:26:51 <boxscape> :t (.)
08:26:53 <lambdabot> (b -> c) -> (a -> b) -> a -> c
08:27:01 <kuribas> dminuoso: well, it took people thousand years to come up with "zero" :)
08:27:17 <boxscape> ^- bolver if you see a type like this, each of those type variables can also be a function type like `Int -> Int` or similar
08:27:17 <dminuoso> kuribas: Non sequitur.
08:27:17 <bolver> boxscape: correct
08:27:19 <EvanR> possibly even longer!
08:27:28 <berndl> maerwald: until you need higher-order generalizations...
08:27:36 <maerwald> berndl: if
08:27:45 <kuribas> dminuoso: what I mean to say, is that what seems obvious when you know it, may not be obvious when you learn it.
08:27:50 <dminuoso> kuribas: Im just suggesting that the reason why we generalize this pattern with Monad and all the combinators that come with it is fairly subtle.
08:27:55 <bolver> boxscape: correct
08:28:02 <maerwald> berndl: but that's not something beginners are concerned with
08:28:08 <maerwald> which was the point of the argument
08:28:11 <phanimahesh> bolver: and now doing an eta-reduction by "expanding" the definition of (.), we get (\x -> \y -> x*x + y)
08:28:31 <berndl> maerwald: true.
08:28:35 <bolver> phanimahesh: correct
08:28:52 <dminuoso> kuribas: You don't regularly see stackoverflow threads suggesting "Look! Here I have `f : A (A a) -> A a`, `g : B (B a) -> B a` and `h : C (C a) -> C a` - I really need to generalize over this because reason XYZ.
08:28:57 <boxscape> isn't expanding the definition beta-reduction?
08:29:09 <boxscape> or rather
08:29:09 <maerwald> dminuoso: and if you do you ask edward ;P
08:29:13 <berndl> boxscape: no
08:29:15 <boxscape> replacing bound varibales with arguments
08:29:22 <phanimahesh> * beta
08:29:52 <phanimahesh> it's not eta, eta is \x -> f x to f
08:29:54 <dminuoso> kuribas: So instead, if you look around for languages having functions like `replicateM` you might notice that they just have it because they learned `replicateM` from language XYZ, rather than this tool being developed out of a genuine need fo rit.
08:30:08 <dminuoso> kuribas: So it's convenience, and you dont realize you need this conveniene until you are used to it.
08:30:15 <phanimahesh> application is beta, yes. sorry
08:30:21 <kuribas> dminuoso: well, clojure has a lot of unprincipled generalising.
08:30:56 <kuribas> dminuoso: like transducers.
08:30:56 <berndl> Isn't Foldable and "unprincipled" generalization.
08:31:06 <berndl> And Enum.
08:31:09 <berndl> And Num
08:31:10 <bolver> boxscape: thanks, btw
08:31:16 <kuribas> berndl: IMO foldable is just anything that can be converted to a list.
08:31:30 <boxscape> bolver np
08:31:33 <kuribas> berndl: and no, it's not unprincipled.
08:31:47 <EvanR> yeah many standard and old classes are weird
08:32:08 <EvanR> also arrows turned out unprincipled in retrospect
08:32:11 <dminuoso> berndl: Foldable is easier because its not a higher order abstraction.
08:32:13 <nshepperd1> Eh, Foldable is semi-principled because of the connection to traversable
08:32:34 <dminuoso> berndl: Most languages cant even articulate higher order abstractions like we can with type classes for non-* kinded types.
08:33:16 <berndl> dminuoso: How is Foldable not higher-order?
08:33:25 <phanimahesh> haskellers have a habit of seeing patterns where none are obvious to the general public
08:33:34 <boxscape> there are apparently encodings though that let you do it even if the language doesn't support it, if rather clumsily
08:35:10 <berndl> boxscape: True, but that's just being a masochist.
08:35:20 <EvanR> one thing clojure did badly imo is the seqable interface
08:35:25 <EvanR> it 
08:35:28 <boxscape> basically the equivalent of using singletons in haskell :)
08:35:30 <EvanR> it's an interface
08:35:41 <EvanR> but what the inteface does changes wildly between containers
08:35:48 <EvanR> it follows no rhyme or reason
08:35:57 <maerwald> you just described all over clojure
08:36:29 <maerwald> change some type from vector to dictionary, everything runs, nothing works
08:36:42 <phanimahesh> seriously?
08:36:44 <maerwald> yes
08:37:00 <phanimahesh> wow. I thought clojure is a good language
08:37:01 <boxscape> kind of sounds like you're describing dynamically typed languages in general
08:37:03 <EvanR> it kind of defeats the purpose of having an interface
08:37:05 <maerwald> people thought it's a good idea for frontend maybe, so we got clojurescript 
08:37:22 <EvanR> if you can't use it generically
08:37:24 <maerwald> boxscape: python isn't that bad and may *crash* at runtime if you do weird stuff
08:37:47 <phanimahesh> boxscape: not necessarily. In python you can go around changing "types" willy nilly, and it either doesn't run, or runs properly.
08:38:00 <boxscape> hm, okay
08:38:03 <maerwald> boxscape: but the style of clojure is to define different implementations for different types of the same function
08:38:14 <phanimahesh> none of this runs without errors but makes a mess
08:38:24 <maerwald> and now have fun reasoning about behavior after a huge refactor
08:38:53 <phanimahesh> I don't think I should be taking a dig at lisps, but well, it's a lisp
08:39:33 <EvanR> maybe there is clojureZ
08:39:40 <EvanR> like scalaz
08:39:50 <phanimahesh> What do you guys think about ocaml? I built some non trivial stuff in ocaml but I'm very rusty now.
08:39:56 <berndl> python, clojure, etc. are nice for scripting. But for large projects, ...
08:40:14 <maerwald> After switching from ClojureScript to TypeScript... I felt like I was freed from hell. Structural typing, proper tooling...
08:40:37 <EvanR> that's the first good review of typescript i've ever heard
08:40:49 <phanimahesh> :')
08:40:52 <maerwald> You can be very productive very quickly in TS
08:40:57 <maerwald> and it scales ok-ish
08:41:07 <maerwald> clojure doesn't scale at all
08:41:07 <berndl> phanimahesh: I'm still waiting for modular implicits in OCaml.
08:41:28 * phanimahesh scratches head. wth are modular implicits?
08:41:40 <maerwald> something like purescript might scale better, but you cannot be very productive very quickly ;)
08:41:47 <berndl> And I'm not a fan of underscore languages in general.
08:41:53 <jpcooper> Has anyone come across a situation where when building a package with a flag enabled for a dependency, it works fine, but when testing that same package, the flag is somehow not set?
08:41:55 <jpcooper> (in stack)
08:42:09 * hackage pandoc-crossref 0.3.4.2 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.3.4.2 (lierdakil)
08:42:32 <jpcooper> I have forced rebuilding of the dependency by deleted .stack-work
08:47:43 <Zer000> Hey guys, I'm a mostly self taught developer who taught himself how to write haskell over the last 4 years (but mostly this year). I worked as a full stack webdev in python/java/c# but I want to jump to a functional language. Do you guys think there are opportunities for me to write haskell or is it still mostly academic at this point?
08:48:19 <kuribas> Zer000: there are, but not as many as python/java/c#/nodejs/...
08:48:37 <berndl> Zer000: you mean job opportunities?
08:48:44 <Zer000> yes, i mean paid work
08:48:55 <Zer000> of course I have lots I can work on as a side project :)
08:49:04 <berndl> Compared to HTML, no.
08:49:09 <Zer000> hahaha
08:49:14 <Zer000> html is quite popular
08:49:27 <berndl> No kidding.
08:50:00 <Zer000> It's just that I don't feel like my pure math skills are lacking, so I don't think i would be developing new language features that are rigorously proven to be true or anything
08:50:14 <Zer000> sorry. I feel like they *are* lacking
08:50:20 <amx> Zer000: when you develop something from scratch for clients you have a lot of opportunities. i find most clients do not care in the slightest what technology you use.
08:50:35 <berndl> Zer000: doesn't matter. If you like it and are interested, just do it.
08:51:05 <phanimahesh> yep. I sneaked haskell into client projects successfully for the first time this week
08:51:08 <Zer000> so you guys are saying find a contract to fulfill? I was looking at a full time position but maybe that's the way to go
08:51:31 <Zer000> how do you folks find clients then?
08:51:43 <berndl> Zer000: or make your own web startup that uses Haskell.
08:51:56 <phanimahesh> It worked. Took slightly longer to do maybe than python, but when inevitably inputs changed a lot, my code changes were minimal and compiler guided.
08:52:28 <phanimahesh> Granted none of them were complex, I could have done the same in python or shell script abominations, but still.
08:52:54 <berndl> Zer000: I don't find clients. They find me, but they want me to do PHP dev.
08:53:10 <Zer000> LOL
08:53:20 <phanimahesh> Zer000: Finding clients is both easy and difficult. Easy once you have a few clients with recurring work, or a reputation that pays dividends. Harder when you get started.
08:53:44 <kuribas> berndl: can you convince them then?
08:54:08 <phanimahesh> Mostly reach out to your network, let them know what you can do and are looking for opportunities, and then rely on a little luck and your ability to sieze opportunities.
08:54:23 <phanimahesh> Also maintain an online presence.
08:54:44 <phanimahesh> kuribas: people who want php can rarely be convinced to abandon it.
08:55:46 <kuribas> why would anyone ever want php?
08:55:48 <maerwald> phanimahesh: python is so much faster to get stuff done, but once you do... you really want it *done* and never touch again :P
08:56:24 <maerwald> wrote a django app with postgres stuff and regret not having tried haskells PostgREST
08:57:00 <maerwald> the test suite is now 3 times the actual code size, because... python
08:57:41 <berndl> kuribas: because WordPress
08:58:43 <kuribas> wordpress is nice, despites php
09:02:32 <[exa]> is there some systematic way to easily convert a (partial) pattern match result to boolean? Reason: I have several definitions that look like `f (C _) = True; f _ = False`, want to replace them
09:02:56 <phadej> a non-answer: generate Prism's and use
09:03:01 <phadej> :t isn't
09:03:02 <lambdabot> APrism s t a b -> s -> Bool
09:03:13 <phadej> or
09:03:14 <phadej> :t has
09:03:16 <lambdabot> Getting Any s a -> s -> Bool
09:03:26 <phadej> (or Control.Lens.Extra.is)
09:04:00 <[exa]> okkkkkay that is in fact a great answer, I somehow failed to remember prisms :]
09:04:02 <[exa]> thanks a lot
09:04:56 <phanimahesh> should I dance around for understanding prisms and thinking of them?
09:05:02 <phanimahesh> I think I should
09:05:47 <[exa]> certainly do.
09:06:47 * phanimahesh dances around
09:07:01 <maerwald> you can't view through a prism btw. ;P
09:07:26 <phanimahesh> yes. Indeed you can't. :D
09:08:18 <phanimahesh> (unless it is the same "face"? is that terminology correct? but then it probably wouldn't be called "view"ing)
09:08:30 <nshepperd> :t view _Right
09:08:32 <lambdabot> (MonadReader (Either c b) m, Monoid b) => m b
09:09:04 <maerwald> yep, in lens you can, because of Monoid
09:09:05 <maerwald> in optics not
09:09:06 <Boarders> Does anyone know the best way in repa to evaluate an array where you need to specify that for example the diagonals are computed in a given order but any diagonal itself can be computed in parallel?
09:09:43 <phanimahesh> Monoid b supplies mempty for when we have a different "face", right?
09:09:55 <maerwald> when it's a left, yeah
09:10:04 <maerwald> which is rarely what you want
09:10:15 <nshepperd> i suppose 'optics' has a separate 'fold' function?
09:10:36 <phanimahesh> depends. I definitely want mempty when doing view _Just
09:11:02 <maerwald> that should never be implicit though
09:11:39 <phanimahesh> yeah.
09:11:45 <phanimahesh> :t view _Just
09:11:46 <lambdabot> (MonadReader (Maybe b) m, Monoid b) => m b
09:11:51 <maerwald> > fromMaybe mempty $ preview _Right (Left "abc")
09:11:53 <lambdabot>  ()
09:11:56 <maerwald> just use preview
09:12:51 <phanimahesh> Why is that () ?
09:12:59 <maerwald> ghci defaulting probably
09:13:04 <phanimahesh> :t preview _Right
09:13:06 <lambdabot> MonadReader (Either c b) m => m (Maybe b)
09:13:55 <phanimahesh> yeah, I was expecting a can't resolve type yadda yadda yadda
09:15:10 <phanimahesh> > fromMaybe mempty $ preview _Right (Left "abc") :: Product Int
09:15:12 <lambdabot>  error:
09:15:12 <lambdabot>      Ambiguous occurrence ‘Product’
09:15:13 <lambdabot>      It could refer to either ‘Data.Monoid.Product’,
09:15:24 <phanimahesh> .....
09:16:38 <exarkun> chrome keeps telling me my Servant-based server is returning a 500.  meanwhile the Servant-based server, with Network.Wai.Middleware.RequestLogger, doesn't even log that a request was received
09:16:55 <exarkun> can I get a Warp server to just *definitely* log every request it receives somehow?
09:20:34 <nshepperd> wireshark time
09:21:14 <mheinzel> Not sure if there is something that does it out of the box, but a WAI Application is just: Request -> (Response -> IO ResponseReceived) -> IO ResponseReceived
09:21:32 <exarkun> nshepperd: so tedious to bust all the layers of TLS
09:21:45 <mheinzel> So you could wrap it with something that logs every Request by just using some printing.
09:22:42 <exarkun> mheinzel: Yea... but I'm not sure why that would do anything if RequestLogger middleware doesn't work
09:22:54 <exarkun> I guess I should look at RequestLogger and see what cases it doesn't log
09:23:09 * hackage pandoc 2.8 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-2.8 (JohnMacFarlane)
09:23:24 <mheinzel> Ah, RequestLogger is already a Middleware. Yes, that should already do what I suggested.
09:31:22 <exarkun> Meh ECDHE
09:32:03 <exarkun> so wireshark cannot decrypt it
09:34:23 <exarkun> oh, unless I export the session key from the browser...
09:35:02 <Geekingfrog> exarkun, if wai receives it, then it's decrypted at that point.
09:35:18 <exarkun> Geekingfrog: yea, which is why it seems like it'd be easier to get wai to log it
09:35:28 <exarkun> but I don't see how to do that
09:36:17 <Geekingfrog> If you're familiar with wireshark, you can indeed dump the NSS key from the browser and use it to decrypt the traffic yes. That seems fairly involved though.
09:37:40 <johnjay> is haskell the language for super geniuses?
09:37:44 <Geekingfrog> exarkun, in your servant server, at some point you should turn it into a wai application, and then you call serve with that. A middleware is juste Application -> Application. So you can apply the requestlogger
09:38:26 <Geekingfrog> reqLogger <- mkRequestLogger someSettings; Warp.serve (reqLogger myServantApp);   -- or something along those lines > exarkun 
09:39:15 <exarkun> Geekingfrog: Yea that possibility was discussed.  I'm already using RequestLogger middleware but it is not logging this request.
09:39:30 <exarkun> Geekingfrog: It logs other requests.
09:39:48 <exarkun> johnjay: I'm pretty dumb but I am using Haskell.
09:39:54 <lally> Design question.  I've got a value type like data Primitive = PDouble Double | PInt Int ...
09:40:08 <johnjay> exarkun: that was going to be my next question. what about people who aren't that smart but think they are
09:40:20 <johnjay> surely there's different languages for the different use cases
09:40:24 <lally> Is there a reasonable way to use those constructors as type tags?
09:41:46 <exarkun> johnjay: I don't think pedagogy is sufficiently formalized to make any meaningful statements about language design with respect to intelligence and self-assessed intelligence of the programmer.
09:42:03 <mheinzel> lally: What exactly do you mean by using them as type tags?
09:42:14 <mheinzel> What do you want to achieve?
09:43:02 <dmj`> johnjay: haskell is for lazy people
09:43:38 <mheinzel> Do you want to lift them to the type level in some way? Or tag something at runtime?
09:43:44 <lally> Right now I've got another type data PrimitiveType = PTDouble | PTInt, etc.
09:44:21 <lally> These represent values of typed variables.
09:44:35 <lally> So, I've got types of variables to represent, and typed values.
09:44:52 <lally> for those variables
09:47:46 <exarkun> Meh wireshark failing to decrypt even with exported browser session keys
09:49:22 <phanimahesh> derive Typeable?
09:49:48 <phanimahesh> I think at this point I know just enough to be dangerous.
09:50:42 <phanimahesh> What's the use case lally?
09:51:23 <lally> A mini language, inside my tool ppt (github.com/lally/ppt)
09:52:46 <johnjay> dmj`: and people who want closure?
09:52:55 <dmj`> johnjay: yes
09:53:33 <lally> phanimahesh: Typeable, interesting.  
10:03:38 <shapr> I want to start deploying stateless Haskell code "in the cloud". What's the recommend backend? heroku? cloud.run? something else?
10:05:20 <nshepperd> exarkun: maybe fork warp and add debug prints everywhere
10:12:34 <bahamas> shapr: what do you mean by stateless?
10:13:01 <shapr> bahamas: I don't need a db or other storage
10:14:21 <exarkun> shapr: nix!
10:14:48 <shapr> exarkun: What backend service would you suggest is best/easiest to run a nix-built Haskell program?
10:15:05 <shapr> I would very much prefer good nix support. I'm still a nix newbie, but golly it's cool.
10:16:00 <exarkun> shapr: I have run stuff on AWS and GCE with Nix.  Nix doesn't do a ton to make either of those platforms any more pleasant to use but it does a decent job with the rest.
10:16:25 <shapr> what's the rest?
10:16:32 <exarkun> shapr: Linux
10:16:34 <shapr> oh, anything except the cloud deploy parts?
10:16:43 <exarkun> yea.  OS-level management and below.
10:16:46 <exarkun> above?
10:17:16 <exarkun> shapr: I started with nixops which has some AWS and GCE support but it's pretty incomplete.  Then I switched to morph and only using it to manage NixOS and left the cloud wrangling to someone else (using terraform).
10:17:38 <phanimahesh> Depending on usage you may consider lambda
10:17:50 <exarkun> You can get Haskell onto Lambda?
10:18:46 <shapr> I've heard that, but haven't seen a github repo. Anyone know of one?
10:19:10 <gergap2> hi
10:19:40 <phanimahesh> No, but I can cook it up for you.
10:19:56 <gergap2> when I create the very basic factorial example in a .hs file and compile it, it works. When I use ghci and interactively define "fact 0=1\nfact n = n * fact(n-1)" and then use it
10:20:00 <phanimahesh> No different than running any other ones. Unfortunately goes via nodejs
10:20:14 <gergap2> I get an stack overflow. Can somebody explain why?
10:20:43 <phanimahesh> gergap2: sure. in ghci your second definition ends up overriding first
10:20:54 <phanimahesh> they are not considered the same definition together
10:21:09 <gergap2> ok, so pattern matching does not work in ghci?
10:21:10 <shapr> phanimahesh: I'd love to see that!
10:21:41 <bahamas> once you get familiar enough with nix, it feels really nice to build the entire system and deploy it. but it takes a while until you reach that point
10:21:56 <gergap2> phanimahesh: thx
10:21:57 <phanimahesh> gergap2: do `:set +m`, or write your definition between `:{` and `:}`
10:22:11 <bahamas> I want to put nix and terraform behind a haskell interface, but I haven't got around to that yet
10:22:52 <exarkun> There's Propeller for sufficiently small projects
10:22:54 <phanimahesh> shapr: I'll do a demo and report back to you on DM. Do you have a preference of aws vs gce vs azure?
10:23:52 <sm[m]> Propellor is interesting to me... I can’t decide if it’s worthwhile for me or not
10:24:02 <gergap2> phanimahesh: thx, that works
10:26:24 <phanimahesh> shapr: somebody made haskell runtimes for aws lambda already. I got my hopes up for creating one. :/
10:26:31 <dmj`> nixops works great for deploying haskell
10:26:33 <amalloy> gergap2: or use ; instead of \n
10:26:53 <amalloy> ghci handles a line at a time, and for simple definitions it's not that hard to fit it all on one line
10:27:10 <gergap2> amalloy: this was just for IRC. it's not in my program.
10:27:37 <amalloy> i know
10:27:43 <amalloy> instead of a newline, you can use ;
10:27:52 <gergap2> amalloy: ok, I undestand
10:28:28 <phanimahesh> shapr: https://theam.github.io/aws-lambda-haskell-runtime/
11:07:55 <exarkun> not sure I understand what's going on with these warp settings, https://github.com/PrivateStorageio/PaymentServer/blob/35.cors.2/src/PaymentServer/Main.hs#L212-L223
11:08:45 <exarkun> I get neither "onException" nor "exception: ..." anywhere when I break the server to throw an exception, https://github.com/PrivateStorageio/PaymentServer/blob/35.cors.2/src/PaymentServer/Processors/Stripe.hs#L176
11:09:01 <johnjay> does haskell use category theory to do things?
11:15:38 <yushyin> 'do things'?
11:25:09 <amalloy> i love the idea that haskell is so impractical that "doing things" is an unknown concept
11:26:40 <yushyin> very practical with the IO type :)
11:39:47 <dsal> @undo do things
11:39:48 <lambdabot> things
11:39:51 <dsal> nice
11:40:44 <yushyin> dsal: :D
11:46:13 <EvanR> > don't (do things) :: IO ()
11:46:16 <lambdabot>  error: Variable not in scope: things
11:46:54 <EvanR> correct
11:47:08 <[exa]> we should define the things now, to get some thing-oriented programming
11:47:16 <[exa]> previously oop
11:51:08 * hackage natural-arithmetic 0.1.1.0 - Arithmetic of natural numbers  https://hackage.haskell.org/package/natural-arithmetic-0.1.1.0 (andrewthad)
11:54:22 <Guest_93> hallo
11:57:04 <boxscape> hi
12:04:02 <koz_> Oh, they left, sadface.
12:05:45 <MarcelineVQ> they gave it a good 11 seconds at least
12:06:02 <MarcelineVQ> oh, numbers are hard, 2 mins 11 seconds :D
12:06:04 <amalloy> 131, by my watch?
12:06:14 <koz_> MarcelineVQ: Yes, I agree, numbers are hard, and so is time.
12:08:33 <EvanR> coder: time is hard. einstein: time is dynamic
12:09:07 <EvanR> well i guess even water is hard if you hit it fast enough
12:11:24 <koz_> EvanR: _Anything_ is hard if you hit it at sizeable fragments of c.
12:11:28 <koz_> s/fragments/fractions/
12:11:58 <Athas> Is there some single thing I can do in my Haskell program to make all IO functions behave as if the locale is UTF-8?
12:13:25 <EvanR> :t setLocaleEncoding -- ?
12:13:27 <lambdabot> error: Variable not in scope: setLocaleEncoding
12:13:47 <EvanR> in GHC.IO.Encoding
12:15:15 <Athas> EvanR: thanks, I am going to try this out.
12:15:40 <Athas> I am fully ready to say that if my UTF-8-enforcing code does not work on a user's system, that's *their* system that is buggy.
12:16:01 <f-a> Athas: I personally used https://hackage.haskell.org/package/utf8-light
12:17:14 <EvanR> if their system isn't using UTF-8 it's buggy?
12:17:25 <Athas> If their locale isn't, yes.
12:17:51 <Athas> Or specifically, if the input files they give my program are not valid UTF-8.
12:18:41 <Athas> setLocaleEncoding seems to work great, thanks!
12:19:03 <EvanR> seems like a hard sell on 'doze
12:20:24 <Athas> Doubt it.  GCC by default doesn't work with UTF-16 either, or whatever that weird thing they use on Windows is.
12:20:56 <EvanR> oh your project is a compiler
12:21:11 <EvanR> the 'user' is likely on board with utf8
12:40:05 <evelyn> UTF-18 was a joke until it wasn't
12:40:35 <monochrom> I use UTF-10.
12:40:44 <monochrom> Because I use base 10. >:)
12:46:07 <djanatyn> some of my friends were talking about monads fighting like Pokemon, and it made me very upset because I feel monads shouldn't fight. I started working on an AntiViolence monad transformer which fails when any Violence is detected: https://gist.github.com/djanatyn/2bcf66eced82d6829907400794a80d7a
12:46:45 <exarkun> I don't really understand how Wai, Warp, and Servant fit together but it seems that Servant handlers that throw anything except Servant's ServerError causes middleware processing to be skipped and instead only the Warp onException handlers are called.
12:47:05 <exarkun> Seems unfortunate
12:47:12 <monochrom> I am upset when monads are anthropomorphized.
12:47:15 <djanatyn> AntiViolenceT is equivalent to IdentityT right now. How can I fail during bind? When I use a case pattern in my bind definition, I get: Couldn't match expected type ‘b’ with actual type ‘Violence’
12:47:51 <EvanR> fail requires MonadFail
12:48:04 <EvanR> lately
12:48:46 <monochrom> In fact I am upset when monads are analogy-ized, especially with such broken analogies as "they fight" "they're anti-violence".
12:49:05 <monochrom> What's next, someone arguing over whether monads are feminists?
12:49:09 <f-a> is your sarcasm detector broken, monochrom 
12:49:11 <monochrom> I am upset when monads are anthropomorphized.
12:49:13 <djanatyn> yeah, that's the first place I went to (and I read through the proposal). my issue is, how can I fail during bind when MonadFail is a subclass (?) of Monad?
12:49:18 <EvanR> mono- "rain on your parade" -chrom :)
12:50:02 <EvanR> you can require MonadFail in your instance
12:50:25 <djanatyn> oh yeah, that'll do it
12:50:54 <monochrom> f-a: No.
12:51:10 <Clint> monochrom: would it help if he made it funny instead?
12:52:57 <EvanR> "if monads were pokemon" blog post probably exists
12:53:07 <f-a> it does for real
12:53:34 <f-a> *Type families, not monads though
12:53:44 <EvanR> wut
12:54:22 <f-a> let me fish it
12:54:31 <f-a> https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/type-families-and-pokemon
12:54:34 <f-a> there
12:55:04 <monochrom> Why is it so long.
12:55:31 <EvanR> hahahaha. "How do i put pokemon of different type in the same container"
12:55:51 <EvanR> clearly... at most 1 pokemon can be in a pokeball
12:56:49 <Athas> When e.g. readFile fails, I get an IOError with a 'show' method that produces a string like "doesnotexist: getDirectoryContents:openDirStream: does not exist (No such file or directory)".
12:56:49 <Athas> Is there a way to get just the last part (presumably the strerror() result), without also including information about Haskell function names?
12:58:24 <monochrom> This one is covered by System.IO.Error.isDoesNotExistError
12:58:40 <EvanR> Athas: maybe? https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.IO.Exception.html#IOException
12:58:49 <EvanR> by breaking into the IOException record
12:59:17 <monochrom> You don't have to break into that.  System.IO.Error also has ioeGetErrorString etc
12:59:27 <EvanR> nice
12:59:33 <monochrom> But maybe the record field names are shorter.
12:59:50 <Athas> Ah, thanks, that's very useful.
12:59:57 <monochrom> It pays to read dry library docs from cover to cover once in a while.
13:00:19 <EvanR> ioeGetError string seems to do some window dressing
13:00:26 <EvanR> ioeGetErrorString
13:00:47 <djanatyn> EvanR: this is in response to a "monads are pokemon" tweet that made me upsert
13:01:10 <EvanR> er nevermind
13:02:05 <monochrom> Anyone still want to tell me my sarcasm detector is broken?
13:02:13 <EvanR> i'm upset too
13:02:30 <EvanR> about the original monads should fight
13:02:39 <djanatyn> i think my question is really about the type system. my bind has the type: (>>=) :: (AntiViolenceT m a) -> (a -> AntiViolenceT m b) -> AntiVilenceT m b
13:02:45 <EvanR> but the AntiViolence transformer is mildly amusing
13:02:52 <djanatyn> i can't use a case pattern match on `b` with (Violence _)
13:03:02 <djanatyn> so how can I fail on Violence!
13:03:48 <EvanR> though i was expecting your implementation to magically detect source code vocabulary at runtime or somthing
13:04:29 <djanatyn> nah I have a Violence newtype. It has a `damage` field of type [Person] (the casualties)
13:05:01 <monochrom> I tell you a true story.
13:05:01 <EvanR> shouldn't it work on any monad though
13:05:34 <monochrom> In my university computer lab, I ran into a 1st-year CS student looking for TA help.
13:05:51 <djanatyn> that's the goal - I want to fail on any bind that results in (AntiViolenceT m Violence)
13:06:09 <monochrom> The student was learning Java and OOP as per our 1st-year course.
13:06:55 <monochrom> The student was looking for TA help for shoe-horning God, Jesus, and Human into some OOP class hierarchy and/or objects.
13:07:08 <koz_> monochrom: Wat.
13:07:23 <Rembane> Philosophy OOP?
13:07:26 <djanatyn> sounds creative
13:07:28 <EvanR> indeed the sounds like a tough one. Exactly what is the top of that hierarchy called
13:07:35 <monochrom> This experience is what pops up in my mind when I see this AntiViolenceT business.
13:07:38 <Rembane> Universe! 
13:07:40 <EvanR> OOP is hard
13:07:46 <monochrom> In other words, total crackpot.
13:09:03 <djanatyn> monochrom: do you see how my question is actually about constructing a monad transformer that fails when the bind operator results in a specific type?
13:09:21 <djanatyn> outside of any silliness?
13:09:37 <EvanR> you can't detect types at runtime since they don't even exist at that point
13:09:42 <monochrom> No.
13:11:09 <djanatyn> EvanR: hmm, that makes sense - I guess that my approach might not be possible
13:11:43 <nshepperd2> djanatyn: you can't, in an instance of Monad
13:21:48 <hololeap> djanatyn: i think the issue is that you want `Monad m => m a` to be able to detect what `a` is and treat it differently depending on its type. this isn't possible because that `a` has to be completely polymorphic (e.g. no restrictions of any kind)
13:22:08 <djanatyn> yeah
13:23:21 <djanatyn> i still want to create a context that respects the principles of anti-violence. i'm thinking about the typeclasses and language extensions I know to see if I could separate things into Violent and NonViolent actions - maybe I can read up on AlternativeT
13:23:43 <hololeap> but there are ways to do what you're looking for as long as you don't depend on what `a` is, for instance set up your type with a `Violence` constructor, sort of like how `Maybe` has a `Nothing` constructor
13:26:10 <djanatyn> would that be setting up my Violence type, or the type of my monad transformer, AntiViolenceT? I think I get the idea (Maybe was the first thing I thought of considering these two alternatives, and I read a MaybeT implementation) but I'm not sure what type I'd want to augment
13:26:32 <nshepperd2> what you need is maybe a GADT like "data AntiViolenceT m a where Nonviolent a => m a -> AntiViolenceT m a"
13:27:08 <nshepperd2> 'Nonviolent a' being a typeclass that asserts that a "isn't violent"
13:27:29 <nshepperd2> you won't be able to implement functor, applicative or monad for this
13:28:38 <nshepperd2> but you could define eg. a restricted version 'return :: Nonviolent a => a -> AntiViolenceT m a' that requires an instance of such type class
13:28:53 <djanatyn> interesting, thank you
13:34:41 <nshepperd2> sadly, actually checking that a program obeys the three laws of robotics is much harder
13:46:56 <dsal> I've got an API that has callbacks that are in the form of    a -> IO  ()    It seems... hard to make that use MonadIO instead.
13:48:21 <EvanR> it's a good question how these callbacks would be used
13:49:12 <dmwit> Does "I've got" mean "I'm creating" or "I'm using"?
13:49:23 <dsal> This is my MQTT library.  I'm using it in a lot of programs.  Sometimes I make a call back into the mqtt library to do something.  Sometimes I call out to an API to send alerts to  my phone.  Sometimes I just send to tchans and stuff.
13:49:36 <dsal> dmwit: It's my API.  I'm trying  to see if I can make it better.
13:49:56 <dsal> I ended up with a use case where I had to unwrap a reader to feed env through and runReaderT again to calls stuff from within a callback.
13:50:28 <dmwit> Okay. You can either parameterize your callback structure, and operate in the user's MonadIO instance; or you can stick with IO and let the user deal with serializing whatever info they need to to go in and out of the monad they actually care about.
13:50:28 <EvanR> if you're always using something like just ReaderT over IO, there's probably an abstraction for this. MonadUnliftIO ?
13:51:09 <dsal> Yeah, I might try to learn unliftio.  I don't think it's sensible to work for most monads.  One of my apps has a hundred or so of these callbacks running concurrently.
13:51:47 <dsal> The IO thing has been fine in most cases -- even here I can hack up a solution.  I do think ReaderT over IO is the only real case I care about.  But it seems invasive.
13:52:32 <glguy> If you're always using ReaderT over IO, then leave your callback API to use a -> IO b, and runReaderT before you register the callback
13:53:45 <EvanR> ah
13:54:10 <dsal> glguy: I don't follow the last bit.  What do you mean by "runReaderT before you register the callback" ?
13:54:55 <dsal> I'm registering the callback from within a function that's already in the ReaderT.  I'm just doing    env <- ask   and then passing that to my callback and doing another runReaderT inside the callback to reconstruct.
13:55:08 <glguy> that sounds right
13:55:25 <EvanR> that dance could even be a wrapper function
13:55:33 <dsal> It's not awful.  I just thought I might be able to do slightly better.  In reality, something like StateT would be impossible here.
13:56:22 <geekosaur> no, that's basically it, specifically because there are monads like StateT that wouldn't work
13:56:39 <dsal> Yeah, I just opened my code up thinking "that could be a wrapper function" but it wouldn't be any  cleaner in this  case.  It's env <- ask  and then catch (withThing (cb env))
13:57:24 <dsal> OK, thanks.  I was going through the implementation and it started to feel pretty gross.  Now I don't have to do it.  Thanks!  :)
13:57:27 <EvanR> i meant the registering, from the user side
13:57:39 <dsal> Yeah, this is the user side.
13:58:34 <dsal> I've not used transformers a whole lot.  I think I'll see the pattern a bit more when I get more experience doing this exact thing.  I've thought it wasn't very useful for most of my programs, but I did a thing yesterday that was kind of ugly.  (this is the program that tells me when I left a door open in my car and walked away)
13:58:42 <dmwit> StateT s couldn't really be sensibly done. But ReaderT (MVar s) could, and you could even make a newtype wrapper with a MonadState instance for taht.
13:59:30 <Uniaika> CSTs rulez
13:59:41 <dsal> ?
14:00:19 <EvanR> interesting idea
14:00:56 <dsal> What is CST?
14:01:03 * dsal reads it as a timezone
14:01:23 <monochrom> Yeah, what's CST?
14:01:24 <geekosaur> callback state transform?
14:01:32 <geekosaur> given context…
14:01:40 <geekosaur> of course that might have been context-free
14:02:00 * dsal requests Context supplementary text
14:02:41 <monochrom> The CST in the library at the other end of the galaxy.
14:03:39 * hackage ats-format 0.2.0.35 - A source-code formatter for ATS  https://hackage.haskell.org/package/ats-format-0.2.0.35 (vmchale)
14:04:54 <monochrom> SAT solver that takes ATS ASTs as input >:)
14:05:48 <glguy> run by the TSA in order to generate tool-assisted speedruns (TAS)
14:06:13 <dsal> Some Terrible Acronym
14:06:25 <monochrom> \∩/
14:08:00 <monochrom> (ATS is a dependently typed language. You would like to run a SAT solver when type-checking an ATS program, which of course is usually presented as an abstract syntax tree.)
14:09:00 <dsal> I still haven't done anything interesting with dependent types.  Occasionally I strongly desire dependent types, but  that feeling comes and goes.
14:09:02 <geekosaur> abstractly typed in one sense, dependently typed in another
14:09:17 * geekosaur hasn't found a lot of use for them either
14:09:41 <geekosaur> that should probably change, since I've read about singletons but not yet applied them to anything
14:10:11 <dsal> I have a weekly agda class, but I'm not super into it.
14:10:24 <EvanR> ghost of departed proofs (https://kataskeue.com/gdp.pdf) seems to offer a lot of dependent type-like things without the dependent types
14:10:55 <monochrom> departed types >:)
14:25:14 <hololeap> djanatyn: this might be the simplest thing to do, borrow everything from ExceptT: https://gist.github.com/hololeap/1be81c5bfeb847a12e9fc9dba6680765
14:30:53 <zeta_0> how do i setup aliases using xmonad(like when i press mod+p to open up dmenu), can i set aliases in xmonad to be recognized in dmenu  menu ?
14:33:18 <zeta_0> or if i set up linux terminal aliases, will they be recognized by dmenu ?
14:33:51 <hololeap> djanatyn: you could reinvent the wheel and make your AntiViolenceT from scratch, but it would end up looking very similar to the implementation of ExcepT
14:34:01 <Entroacceptor> zeta_0: no, dmenu searches executables
14:37:54 <zeta_0> Entroacceptor: then how do i do this then ?
14:39:34 <Entroacceptor> I've got something like dirExecPrompt myXPConfig spawnHere "/home/user/bin/actions" and put stuff into that
14:42:05 <jared-w> Dmenu more accurately creates a search bar from stdin given one line per text. You can make a dmenu setup that goes through your aliases and executes them but I'm not sure how useful that would actually be
14:50:35 <xp2000> Hello, I have a question about IO in Haskell: Can one understand a chain of IO actions - linked by means of '>>' and '>> =' - as a kind of collection type like lists? I mean, you can link any number of inputs and outputs together; and although you can not tell from the signature how many actions actually performed, they are all executed one after the other.
14:52:39 <EvanR> >> and >>= output IO A values which you can't inspect
14:52:54 <EvanR> but if you choose a suitable monad you can observe the structure sort of like a list
14:53:10 <Rembane> :t mapM 
14:53:12 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
14:53:23 <Rembane> Hm... nah
14:55:03 <Rembane> :t sequence 
14:55:05 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
14:55:22 <Rembane> sequence is a way to turn a series of instructions into a series of results 
14:55:38 <EvanR> it turns a series of actions into an action of series
14:56:18 <[exa]> xp2000: well not a list directly, but a list that can be dynamically generated based on results of the previous action
14:56:51 <Rembane> EvanR: Good point, I misspelled
14:57:17 <EvanR> xp2000: data T a = Pure a | forall z . Bind (T z) (z -> T a). This T type can be made a Monad and can be inspected. Have fun! :)
14:57:43 <jle`> xp2000: i think you can sort of talk about IO actions chained by >> as if they are list, but there is 'more structure' than just >>
14:58:31 <jle`> xp2000: you can compare it to rose trees, maybe, where under a limited set of constructions your tree is like a list -- if each branch has either zero or one children
14:58:52 <leo_> Man, I'm having a shitload of language extensions and dependencies in my Haskell programs.
14:59:04 <jle`> xp2000: but in general there is much more structure than just >>, just like a tree has more structure than just 'a long string maybe'
14:59:04 <leo_> Do you guys try and limit it somehow? Get the program "leaner"?
14:59:27 <f-a> leo_: some can make reading your program by someone else way more difficult
14:59:45 <jle`> leo_: for libraries i try to make my deps small out of respect for people using my library, but for applications i don't really mind
14:59:46 <[exa]> leo_: make a module that groups your most favorite imports
15:00:01 <jle`> leo_: also extensions i don't really limit, there isn't a point really
15:00:10 <jle`> i just don't use the 'bad' ones
15:00:29 <xp2000> Thanks for the answers. I'll think it through first. XD
15:00:29 <jle`> but there's no cost to enabling extensions really
15:00:33 <leo_> .-.
15:00:48 <jle`> there is a cost if you write complex code using those extensions of course
15:01:01 <EvanR> there's the wall of pragmas at the top of the source code
15:01:27 <EvanR> which i don't have a problem with in the end but it's a barrier to quick and dirty "hacking"
15:10:09 * hackage finitary-derive 2.0.0.0 - Flexible and easy deriving of type classes for finitarytypes.  https://hackage.haskell.org/package/finitary-derive-2.0.0.0 (koz_ross)
15:16:46 <koz_> EvanR: {-# LANGUAGE GimmeAllTheGHCFeaturesAlready #-}
15:18:57 <EvanR> yes please
15:19:14 <leo_> xd
15:19:35 <[itchyjunk]> hmm
15:19:52 <totycro> hi, i implemented a server in servant and i'm doing tests with servant-client, which is quite nice. however i have one handler which fetches data from the internet, which it shouldn't do during tests. is there an easy way to mock that?
15:21:26 <totycro> in the test, i'm running the server in a thread, so i could pass some initial argument, and then call some mock location rather then the resource i actually want
15:21:34 <totycro> but i don't really want to pollute my production code with test code
15:21:57 <totycro> or do i have to use e.g. reader to do something like this?
15:22:20 <totycro> in python, i would use some kind of request mocker which can intercept requests
15:23:27 <exarkun> totycro: What do you mean "pollute"
15:23:40 <exarkun> totycro: make the thing that fetches from the internet into a function
15:23:50 <exarkun> totycro: pass that function to your server initialization function
15:24:03 <exarkun> totycro: then implement another function of the same type that has the behavior desirable for the test suite
15:24:12 <exarkun> totycro: and pass that function in, instead, when setting the server up for your tests
15:24:21 <exarkun> totycro: or more succinctly, dependency injection
15:24:33 <totycro> exarkun: like i don't want to write realUrl if production else mockUrl
15:24:54 <totycro> ok, i see what you mean
15:25:17 <exarkun> this would be the correct way to do it in python, too, fwiw ;)
15:25:23 <totycro> exarkun: :-)
15:25:38 <[exa]> what's the patch way called correctly btw?
15:25:52 <[exa]> I always call it monkey patching but I guess there's a better name
15:26:17 <EvanR> spooky action at a distance
15:26:43 <totycro> exarkun: so for this approach, i would define the mock function only in the test code, right?
15:27:01 <exarkun> totycro: quite probably, yes
15:27:06 <[itchyjunk]> got a silly question, why can i [1..10] but not [10..1]? :x
15:27:37 <ChaiTRex> [itchyjunk]: Because the standard step is 1.
15:27:46 <totycro> [exa]: in python a common library for that is called requests-mock
15:27:48 <glguy> > [10,9..1]
15:27:50 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
15:27:54 <EvanR> what it does depends on your Enum instance
15:27:54 <[itchyjunk]> :O
15:27:55 <totycro> exarkun: k, i see
15:28:27 <EvanR> but everything implements that with step +1
15:28:28 * totycro sometimes still struggles to think more haskelly than in imperative style, but the haskell way feels much more right :-)
15:28:33 <[itchyjunk]> ah i am kinda happy that [10,9,..1] works ha
15:28:54 <[exa]> totycro: oh I worked with that once, don't want to think about that anymore. :]
15:28:56 <glguy> without that extra comma though
15:29:07 <[itchyjunk]> ah right
15:32:25 <jared-w> You can even do [100,95..6], but sadly you can't do [1,1,2,3,5..100] 
15:32:44 <jared-w> although if Haskell could magically guess a sequence of numbers correctly every time just from the first whatever, that'd be pretty wild :p
15:33:14 <amalloy> well, you can extrapolate to an N-degree polynomial
15:33:17 <[itchyjunk]> hmm foldr wants 2 arguments. but what i wanted to do was talke [1..10] and multiple each elements so 10! basically
15:33:24 <[itchyjunk]> i guess foldr is not the function i want then?
15:33:28 <jared-w> it is
15:33:32 <[itchyjunk]> i use 1 ?
15:33:39 <[itchyjunk]> foldr 1 list ?
15:33:41 <jared-w> foldr (+) 1 [1..10] -- yup
15:33:47 <koz_> jared-w: * I think.
15:33:48 <boxscape> [itchyjunk] by the way these are all syntactic sugar for regular library functions - [n..] = enumFrom n, [n..m] = enumFromTo n m, and [n, n+k .. m] = enumFromThenTo n (n + k) m
15:33:53 <koz_> Factorial is product.
15:33:53 <ChaiTRex> [itchyjunk]: foldr f startingValue list
15:33:59 <[itchyjunk]> ah okay, was wondering if some other function would be better
15:34:00 <jared-w> Or foldr1 which is a partial function that explodes on an empty list
15:34:25 <jared-w> If you want to be overly clever you can do `foldr (+) mempty [1..10]`
15:34:38 <koz_> jared-w: Funny story - I crashed GHC once because of foldr1.
15:34:42 <ChaiTRex> [itchyjunk]: Well, foldl' will probably be quicker, but foldr works.
15:34:51 <koz_> (a plugin used it assuming 'this list could never be empty')
15:35:04 <[itchyjunk]> :O i didn't know there was much difference between foldr and l lol
15:35:10 <jared-w> nvm, I lied, can't directly use mempty there. But that's essentially what you're doing with the 1 or the 0
15:35:14 <EvanR> foldl is conceptually right, but slow
15:35:15 <koz_> [itchyjunk]: There is considerable difference.
15:35:22 <EvanR> foldl' is fast
15:35:23 <[itchyjunk]> startingValue doesn't mean starting value from the list right?
15:35:33 <koz_> [itchyjunk]: startingValue can be whatever.
15:35:45 <[itchyjunk]> ah i need to be careful with similar sounding function then
15:35:54 <ChaiTRex> [itchyjunk]: Nope, it's the starting result and then the result is adjusted based on each list element.
15:36:12 <glguy> > foldl f z [a,b,c]
15:36:14 <lambdabot>  f (f (f z a) b) c
15:36:15 <glguy> > foldr f z [a,b,c]
15:36:17 <lambdabot>  f a (f b (f c z))
15:36:36 <koz_> > foldr (\x old -> old ++ show x) "" [1,2,3,4]
15:36:37 <boxscape> EvanR it's slow too? I haven't looked into it much but I thought the problem was with requiring more space if you're being lazy
15:36:37 <jared-w> You can see it pretty obviously if you use ^ instead of * or +
15:36:38 <lambdabot>  "4321"
15:36:43 <koz_> [itchyjunk]: ^
15:37:23 <EvanR> boxscape: foldl on list is still lazy. But maybe with -O2 a factorial function that used it would be strictified?
15:37:26 <[itchyjunk]> hmm
15:37:38 <ChaiTRex> EvanR: foldl' with a ' is stricter.
15:37:47 <EvanR> i'm aware
15:38:19 <EvanR> hence the comment earlier
15:38:20 <[itchyjunk]> hmm what is my syntax error with foldl * 1 [10..1] ?
15:38:31 <ChaiTRex> [itchyjunk]: * isn't a function, (*) is.
15:38:35 <koz_> [itchyjunk]: [10..1] is not a thing either.
15:38:41 <boxscape> EvanR uhm, I think you slightly misunderstood my question (or I'm misunderstanding your answer) - it was whether using foldl makes you slow rather than just requiring more space
15:38:47 <EvanR> [itchyjunk]: you just tried to multiply foldl by 1
15:38:49 <[itchyjunk]> oops i meant [1..10]
15:39:06 <EvanR> boxscape: yeah, i did
15:39:12 <[itchyjunk]> hmmm
15:39:25 <[itchyjunk]> EvanR, is that bad? :D
15:39:39 <EvanR> [itchyjunk]: it's a type error... not a syntax error
15:39:59 <[itchyjunk]> ahh 
15:40:24 <[itchyjunk]> make sense, the gchi says non  type-variable something something
15:40:26 <EvanR> (foldl * 1) [10..1], grammatically right, but nonsense nonetheless
15:40:35 <boxscape> it's a type error that caused by a misunderstanding of syntax ;)
15:40:39 <boxscape> s/that/that's
15:40:41 <jared-w> > foldl * 1 [10..1]
15:40:43 <lambdabot>  error:
15:40:43 <lambdabot>      • Could not deduce (Num a0)
15:40:43 <lambdabot>        from the context: (Foldable t, Num a,
15:41:03 <[itchyjunk]> [10..1] = []
15:41:06 <[itchyjunk]> w/e that means
15:41:11 <EvanR> boxscape: building the thunks takes time, chewing through the chunks takes time, and while thunks are taking up memory GC is slower
15:41:21 <ChaiTRex> > [10 .. 1]
15:41:23 <lambdabot>  []
15:41:23 <boxscape> EvanR I see, that makes sense
15:41:27 <[itchyjunk]> [10,9..1] = [10,9,8,7,6,5,4,3,2,1]
15:41:29 <jared-w> the could not deduce Num comes from the fact that * is a function that takes two numbers and returns another
15:41:35 <EvanR> s/chunks/thunks/
15:41:58 <jared-w> so it's trying to multiply a function by a number and can't get it because the function is of type Foldable (and other stuff)
15:42:59 <jared-w> > foldl (*) 1 [10,9..1] -- All of the syntax there is important
15:43:01 <lambdabot>  3628800
15:43:22 <[itchyjunk]> hey i think i managed to create the function i wanted: Prelude> factorial n = foldl (*) 1 [n,n-1..1]
15:43:40 <EvanR> i have prepared a link in my clip board just for you
15:43:46 <EvanR> [itchyjunk]: https://www.willamette.edu/~fruehr/haskell/evolution.html
15:44:17 <jared-w> Heh, that link is beautifully relevant
15:44:41 <[itchyjunk]> :O are those all different ways to generate factorial?
15:44:52 <[itchyjunk]> why does mine look like "senior haskell programmer" ? ha
15:44:52 <jared-w> yeah. It gets pretty wild
15:44:54 <EvanR> they are all ways and all different
15:45:04 <EvanR> but it's not all the ways, considering what you just wrote
15:45:19 <jared-w> It's a satire on how people tend to over complicate things for the sake of "maintainability" or "industry code"
15:45:24 <[itchyjunk]> oh right, i guess i didnt need it to be backward
15:45:31 <jared-w> https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition
15:45:34 <[itchyjunk]> 1..10 would have been jsut fine rofl
15:46:08 <EvanR> tenured professor is my favorite so far
15:46:17 <koz_> EvanR: Likewise.
15:46:36 <[itchyjunk]> whats wrong with the "interpretive haskell programmer"
15:46:37 <[itchyjunk]> ?
15:46:45 <[itchyjunk]> thats more like of code that i have written in my entire life
15:47:20 <EvanR> looks fine to me :)
15:47:51 <EvanR> haskell has a reputation for being "my programming language toolkit"
15:48:01 <EvanR> do all languages suck? write your own
15:48:02 <[itchyjunk]> is there a way to define infinite? [1..inf] ?
15:48:14 <jared-w> The joke is that the interpretive person has never met a language they don't like because every program they write is just defining the same language and then interpreting their program inside of that language they just wrote
15:48:29 <[itchyjunk]> oh nm i can just +1 everytime
15:48:34 <EvanR> using haskell as a metalanguage
15:48:38 <ChaiTRex> [itchyjunk]: [1 ..]
15:48:38 <dsal> [itchyjunk]: [1..]  ?
15:48:44 <[itchyjunk]> jared-w, ah!
15:48:51 <[itchyjunk]> holy shit [1..] works?
15:48:57 <jared-w> yeah
15:48:59 <EvanR> > [1..]
15:49:01 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
15:49:03 <[itchyjunk]> thats crazy
15:49:27 <ChaiTRex> [itchyjunk]: It's useful since Haskell supports infinite lists.
15:49:32 <jared-w> When I want to do weird number stuff with primes I tend to do [3,5..] and save myself the trouble of counting 1, 2, or the even numbers
15:49:33 <[itchyjunk]> so haskell does the programming. what do haskell programmers even get paid for?
15:49:44 <jared-w> Knowing which lever to pull :p
15:50:02 <boxscape> > zip [0..] ['a'..'f']
15:50:05 <lambdabot>  [(0,'a'),(1,'b'),(2,'c'),(3,'d'),(4,'e'),(5,'f')]
15:50:24 <EvanR> data Game deriving (MMO,FPS,RTS,Hypercasual)
15:50:25 <jared-w> > zip <*> tail $ ['a'..'d'] -- also fun
15:50:28 <lambdabot>  [('a','b'),('b','c'),('c','d')]
15:50:43 <boxscape> it's also quite nice that you can have a string representation of the alphabet by doing
15:50:47 <boxscape> > ['a'..'z']
15:50:49 <lambdabot>  "abcdefghijklmnopqrstuvwxyz"
15:51:08 <Clint> an alphabet
15:51:17 <boxscape> I suppose
15:51:45 <boxscape> > ['α'..'ω']
15:51:47 <lambdabot>  "\945\946\947\948\949\950\951\952\953\954\955\956\957\958\959\960\961\962\96...
15:51:49 <boxscape> meh
15:51:58 <boxscape>  % ['α'..'ω']
15:52:03 <EvanR> > text ['α'..'ω']
15:52:06 <lambdabot>  αβγδεζηθικλμνξοπρςστυφχψω
15:52:26 <EvanR> i'm glad you screwed that up first, i was about to lambdabot the same thing!
15:52:40 <boxscape> happy to help
15:52:49 <EvanR> aren't there 2 sigmas there
15:53:23 <boxscape> yes
15:53:34 <EvanR> anyway, never went to grade school in greece can't tell if that's right
15:55:31 <[itchyjunk]> uhh stupid question, i have a function f that takes some number. i want to generate a list [1..10] and pass each of those values to f
15:55:50 <exarkun> we can just say that you can have any alphabet which had the foresight to get itself into unicode with the proper codepoints
15:56:06 <exarkun> and the bar for unicode inclusion is pretty low so that's probably good enough
15:56:41 <Rembane> [itchyjunk]: Are you thinking of map? 
15:56:43 <Rembane> :t map 
15:56:45 <cole> [itchyjunk]: map f [1..10] ?
15:56:45 <lambdabot> (a -> b) -> [a] -> [b]
15:57:10 <koz_> :t flip map
15:57:12 <lambdabot> [a] -> (a -> b) -> [b]
15:57:19 <[itchyjunk]> hmmm
15:57:45 <koz_> :t flip map [1..10]
15:57:46 <lambdabot> (Num a, Enum a) => (a -> b) -> [b]
15:57:51 <koz_> There ya go.
15:58:05 <EvanR> map is bread of butter of basic functional programming
15:58:09 <EvanR> bread and butter
15:58:18 <koz_> In fact, it should really be
15:58:22 <koz_> :t flip fmap [1..10]
15:58:23 <[itchyjunk]> ah idk how to use map and flip map yet :<
15:58:24 <lambdabot> (Num a, Enum a) => (a -> b) -> [b]
15:58:36 <EvanR> quit flipping flipping
15:58:41 <Rembane> :t flip 
15:58:42 <lambdabot> (a -> b -> c) -> b -> a -> c
15:58:44 <Clint> :t flip for
15:58:46 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
15:58:46 <ChaiTRex> [itchyjunk]: map f xs applies f to each x and returns the result.
15:59:21 <ChaiTRex> > map (^2) [1 .. 10]
15:59:23 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
16:00:03 <[itchyjunk]> :O
16:01:45 <dsal> > head . filter (> 1000) . map (^2) $ [1..]
16:01:47 <lambdabot>  1024
16:02:15 <boxscape> > find (> 1000) . map (^2) $ [1..]
16:02:17 <lambdabot>  Just 1024
16:02:39 <cole> I have a needle and some haystack, both of which are Text, and I'd like to highlight all occurrences of the needle in the haystack when outputting to the terminal. My thought is to `split` on the needle and then intercalate with the highlighted needle. Is there any less-janky way?
16:03:00 <cole> I see that there's `indices :: Text -> Text -> [Int]` in Data.Text.Internal.Search, but it's still not quite what I want
16:03:01 <ChaiTRex> There's also takeWhile, which does less work if you're taking the first n values > 1000.
16:03:22 <ChaiTRex> dropWhile, rather.
16:03:34 <exarkun> cole: Which part do you find janky?
16:03:37 <boxscape> cole I would imagine there should be some "replace" function for Text which you can simply give your needle, highlighted needle, and haystack and it will give you what you want?
16:04:44 <boxscape> % :t Data.Text.replace
16:04:44 <yahb> boxscape: Data.Text.Internal.Text -> Data.Text.Internal.Text -> Data.Text.Internal.Text -> Data.Text.Internal.Text
16:04:45 <cole> boxscape: replace seems to only go from `Text` to `Text`, which makes sense; I was thinking of making a custom datatype, e.g. `data Highlighted = Highlighted Text | Plain Text` and then casing on that in the output
16:04:52 <boxscape> I see
16:05:13 <cole> I suppose I could look into encoding color codes into the Text, but I worry about that being platform-specific
16:05:54 <exarkun> eg colors in cmd.exe do not work by embedding special sequences of control bytes into the output
16:06:03 <exarkun> then again are you sure cmd.exe matters?
16:06:19 <cole> exarkun: it feels sort of like a hack I would do because it's more concise; seems smelly but I don't have a good sense for what's smelly in Haskell
16:06:39 <[itchyjunk]> harmph, i see my mistake i think. i need to add the values i am generating..
16:06:42 <jared-w> If you're trying to do anything mildly complicated with text and terminal output that's usually where I give up and get a pretty printing library to do it for me
16:06:52 <[itchyjunk]> i am writing all my code in gchi.. maybe i need to put it in text editor finally
16:07:47 <cole> jared-w: any recommendations? I was just going to use System.Console.ANSI
16:08:06 <jared-w> Depends on if you want it to work in cmd.exe or not
16:08:32 <cole> jared-w: I suppose more portability wouldn't hurt, unless the unix-only libraries are much nicer
16:09:04 <cole> I believe most of my friends on Windows who would benefit from this use the Ubunut subsystem
16:09:06 <exarkun> as a rule
16:09:09 <exarkun> cmd.exe hurts
16:09:11 <exarkun> yes
16:09:13 <jared-w> Brick is awesome for TUIs. It's unix-like only, though. The unix-only libraries tend to be way cooler for terminal based stuff. Especially the advanced things
16:11:10 <cole> jared-w: Thanks; I'll look into it.
16:13:21 <jared-w> But yeah, ansi-terminal, pretty-terminal, and maybe rainbow are the ones I found. The last two are unix only. Alternatively, you can scroll through this embarrassingly large list of pretty printing libraries: https://www.reddit.com/r/haskell/comments/8ilw75/there_are_too_many_prettyprinting_libraries/
16:13:53 <[itchyjunk]> idk why i am only writing one line functions..
16:14:02 * [itchyjunk] opens tutorial so see how to write multiline functions
16:16:15 <jared-w> Doing it in ghci is a bit uglier than in some of the nicer REPLs you might be used to
16:16:23 <jared-w> You have to like :{ }: and other nonsense
16:16:51 <ChaiTRex> It's easier to just put it in a file, load it in GHCi, and do :r to reload it when you make changes.
16:16:58 <[itchyjunk]> hmm i have a bit of an issue. its doing a bunch of stuff, but i wanted to to do the bunch of stuff and add them together
16:17:06 <[itchyjunk]> https://pastebin.com/gNKQcC40
16:17:07 <jared-w> yeh that's what I do
16:17:42 <[itchyjunk]> ah i don't know how to make ghci look into some specific folder i think. :s i was trying last time and was doing something wrong
16:17:59 <jared-w> You just use :l nameOfMyFile.hs in ghci and that'll load the file
16:17:59 <ChaiTRex> [itchyjunk]: You want to sum the result of euler?
16:18:18 <[itchyjunk]> ChaiTRex, its doing 1/1! , 1/2!, 1/3!
16:18:30 <[itchyjunk]> i wanted it to do 1/1! + 1/2! + 1/3! .. 
16:18:55 <jared-w> well you have what you want, all you need to do is sum up the resulting list
16:19:00 <ChaiTRex> [itchyjunk]: You can do sum . map fracSum $ [1 .. e]
16:19:12 <ChaiTRex> [itchyjunk]: Assuming I understand what you want, of course.
16:19:23 <jared-w> sum n = foldl (+) 0 [1..n] -- similar to factorial
16:19:47 <jared-w> and then: sum (map fracSum [1..e])
16:20:05 <jared-w> which is the same thing as what ChaiTRex said, but with less perl
16:20:18 <[itchyjunk]> <no location info>: error: can't find file: euler.hs
16:20:18 <[itchyjunk]> Failed, modules loaded: none.
16:20:31 <[itchyjunk]> i didn't know how to point it to my /Home/Haskell folder :x
16:20:37 <ChaiTRex> [itchyjunk]: Try exiting GHCi, then doing ghci path/to/whatever.hs
16:20:47 <jared-w> :l /Home/Haskell/euler.hs
16:20:49 <jared-w> will also work
16:20:51 <ChaiTRex> [itchyjunk]: You can reload after changes from within GHCi with :r
16:21:15 <ChaiTRex> [itchyjunk]: Saves typing.
16:21:53 <[itchyjunk]> hmm how do i check my absolute path ? :s
16:22:08 <ChaiTRex> [itchyjunk]: Outside of Windows, run pwd
16:22:24 <ChaiTRex> [itchyjunk]: In Windows, I'm not sure. Maybe run cd with no arguments
16:22:25 <[itchyjunk]> ah neat
16:22:28 <[itchyjunk]> thanks
16:23:19 <[itchyjunk]> <interactive>:2:1: error: parse error on input ‘/’
16:23:59 <[itchyjunk]> didn't give that error when i defined fracSum on ghci directly :s
16:24:23 <ChaiTRex> [itchyjunk]: It's probably complaining because it didn't understand the path because it wasn't expecting one.
16:24:41 <ChaiTRex> [itchyjunk]: Line has to start with colon-ell-space.
16:25:07 <[itchyjunk]> ah! gotcha
16:28:11 <[itchyjunk]> oh no /o\ the euler starts with 1/0! lol
16:28:24 <[itchyjunk]> mine starts with 1/1! so i am off by one
16:28:33 <[itchyjunk]> ChaiTRex, what does the . and $ do in your solution?
16:28:39 <[itchyjunk]> it works but not sure why :s
16:28:51 <dsal> :t (.)
16:28:52 <lambdabot> (b -> c) -> (a -> b) -> a -> c
16:28:55 <dsal> :t ($)
16:28:56 <lambdabot> (a -> b) -> a -> b
16:29:50 <dsal> > let plus1 x = x + 1 in    (plus1 . plus1 . plus1) 0
16:29:52 <lambdabot>  3
16:31:49 <ChaiTRex> [itchyjunk]: . is function composition from math.
16:32:06 <ChaiTRex> [itchyjunk]: $ separates the resulting composed function from its argument.
16:32:13 <[itchyjunk]> ah
16:32:28 <[itchyjunk]> ahh
16:34:57 <[itchyjunk]> omg.. i get 7 decimal accuracy with 1000 iteration /0\
16:36:09 * hackage copilot-core 3.1 - An intermediate representation for Copilot.  https://hackage.haskell.org/package/copilot-core-3.1 (IvanPerez)
16:38:39 * hackage copilot-c99 3.1 - A compiler for Copilot targeting C99.  https://hackage.haskell.org/package/copilot-c99-3.1 (IvanPerez)
16:40:09 * hackage copilot-theorem 3.1 - k-induction for Copilot.  https://hackage.haskell.org/package/copilot-theorem-3.1 (IvanPerez)
16:41:09 * hackage copilot-language 3.1 - A Haskell-embedded DSL for monitoring hard real-timedistributed systems.  https://hackage.haskell.org/package/copilot-language-3.1 (IvanPerez)
16:42:08 * hackage copilot-libraries 3.1 - Libraries for the Copilot language.  https://hackage.haskell.org/package/copilot-libraries-3.1 (IvanPerez)
16:44:08 * hackage copilot 3.1 - A stream DSL for writing embedded C programs.  https://hackage.haskell.org/package/copilot-3.1 (IvanPerez)
16:45:38 * hackage egison-tutorial 3.10.0 - A tutorial program for the Egison programming language  https://hackage.haskell.org/package/egison-tutorial-3.10.0 (SatoshiEgi)
18:08:15 <jared-w> copilot looks cool
18:12:03 <koz_> jared-w: Yeah, I looked into it briefly as well, and it does seem intriguing.
18:17:47 <libertyprime> hey guys. This  "data Person = Person String String Int Float String String deriving (Show)" has "...Person = Person..." but this http://ix.io/22Ay does not appear to have "data JsonValue = JsonValue". How come? Is there an implicit, default constructor?
18:21:58 <maerwald> libertyprime: do you know the difference between product and sum type?
18:22:48 <maerwald> https://wiki.haskell.org/Algebraic_data_type
18:25:54 <libertyprime> maerwald: no i dont, thanks for pointing me to that
18:27:12 <koz_> What's an example of a Functor which can't be Applicative?
18:27:58 <jared-w> https://stackoverflow.com/questions/7220436/good-examples-of-not-a-functor-functor-applicative-monad my favorite resource for that question
18:28:02 <jared-w> s/resource/rabbit hole
18:29:14 <koz_> jared-w: How could I forget about Writer, lol.
18:30:31 <libertyprime> haerwald: I'm now assuming that the reason there is no "data JsonValue = JsonValue" is because JsonValue is a sum type. Is it possible to have a type that makes use of both "sum" and "product" notation?
18:30:36 <jared-w> Because everyone tells you to never use it? :p
18:30:52 <koz_> jared-w: In my case it's more of a 'I've never needed it' than anything.
18:31:08 <koz_> Applicative-but-not-Monad I have a ready example for (ZipList).
18:31:41 <maerwald> libertyprime: yeah
18:31:50 <MarcelineVQ> koz_: Sum https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Sum.html
18:32:00 <MarcelineVQ> Nice and straightfoward
18:32:24 <jared-w> koz_: My go-to is the Validation applicative
18:32:24 <koz_> MarcelineVQ: Yeah, that's a good point - you can't even define pure, because which 'side' will you be in?
18:35:31 <maerwald> libertyprime: what would JsonValue be?
18:35:36 <maerwald> as a constructor?
18:36:43 <maerwald> when you do data Person = Person String -- then Person is both a constructor and a type. That's why some people write: data Person = MkPerson String
18:36:53 <nshepperd1> Const is a good non-monad Applicative
18:38:49 <libertyprime> maerwald: thanks. i think that is why i was confused. i think identifiers shouldnt be used for multiple things
18:39:39 <maerwald> Well, then you will be disappointed that it could also be a "kind" :P
18:39:49 <libertyprime> oh lordy
18:44:30 <libertyprime> A cool NLP project might be to separate conversations from chat rooms
18:45:06 <libertyprime> I find myself extracting my own one, but not wanting to discard the other one either cos it looked interesting
18:52:51 <libertyprime> hmm Discourse segmentation ---> https://www.aclweb.org/anthology/D18-1116/
18:53:20 <libertyprime> one day i want to be using haskell for my nlp stuff. it's my best hope at remaining sane
20:07:00 <mniip> nil, there's a cyclic buffer of 100 pastes
20:07:07 <mniip> it's dedicated to yahb/yalb
20:08:27 <mniip> there's also uhh, http://qp.mniip.com/y/.id
20:33:16 <dmwit> qp.mniip.com/y/20 is interesting because it says qp.mniip.com/p/4b doesn't exist, but it does
20:33:45 <mniip> eh, someone was probably playing around with http-as-files thingy
20:46:49 <dmesg> Hi there! I'm playing with Haxl which makes use of a (type-level?) map to from a data source type to its state object. The problem is have multiple data source instantiations of the same type to different state objects - and I can't figure out how to discriminate between them at a type level? The relevant haxl code is at
20:46:50 <dmesg> https://github.com/facebook/Haxl/blob/master/Haxl/Core/StateStore.hs#L51. What options are do I have?
21:06:19 <iqubic> I really wish I knew why the combinitory version of the factorial function works here: https://willamette.edu/~fruehr/haskell/evolution.html#combinatory
21:07:55 <DigitalKiwi> plz like my art https://twitter.com/ArchKiwi/status/1198095178294341632
21:08:21 <iqubic> That is execellent art.
21:08:31 <DigitalKiwi> ty
21:08:38 <iqubic> I see you are a NixOS user. I too am a NixOS user.
21:08:44 <iqubic> However, this is #haskell.
21:09:15 <maerwald> I only like it if you remove the NixOS logos xD
21:09:30 <DigitalKiwi> that's why there are many thompson wheelers
21:10:09 <DigitalKiwi> https://twitter.com/ArchKiwi/status/1198094609504722944 :)
21:10:41 <maerwald> The pink/violet one of the first link is nice
21:11:06 <DigitalKiwi> https://twitter.com/ArchKiwi/status/1198094530752454662 this one?
21:11:41 <DigitalKiwi> those are my expensive paints i <3 them
21:11:57 <maerwald> Yeah, where can I buy it
21:12:19 <maerwald> I want it on my socks
21:12:52 <DigitalKiwi> haven't tried painting socks
21:13:15 <DigitalKiwi> they're stickers though sooo
21:13:28 <DigitalKiwi> and dibblego wants me to make him a t-shirt
21:13:31 <maerwald> I think it's nice and subtle on socks
21:14:04 <DigitalKiwi> https://www.mostlyabsurd.com/contact/
21:15:04 <DigitalKiwi> i might have it on etsy later since the person it was originally for wanted a white background so i'm going to redo it (or you can pm me :P )
21:22:59 <iqubic> So, I'm trying to understand this combinatory logic version of factorial. It is difficult to undestand
21:23:55 <phanimahesh> Show the code please
21:24:14 <siraben> Ooh, combinatory logic!
21:24:35 <iqubic> https://willamette.edu/~fruehr/haskell/evolution.html#combinatory
21:24:50 <iqubic> The combinatory logic one is the one I'm looking at.
21:25:41 <iqubic> It defines 7 functions: s, k, b, c, y, cond, and fact
21:25:53 <phanimahesh> k = const, b = (.)
21:25:59 <iqubic> I know that.
21:32:32 <iqubic> (.) x y = x . y, right?
21:32:50 <dibblego> yes, by rules of syntax
21:32:58 <iqubic> Cool. Thanks.
21:34:00 <phanimahesh> Do you want an explanation of how it works or how to come up with that?
21:34:33 <phanimahesh> First eliminate c from that by applying the definition
21:34:42 <phanimahesh> It makes much more sense then
21:36:24 <iqubic> How does that help?
21:37:00 <phanimahesh> Lemme write a gist or something.
21:37:14 <phanimahesh> Do you see that y=fix, the y combinator?
21:37:30 <iqubic> I do.
21:37:35 <iqubic> I understand that.
21:37:47 <phanimahesh> Looking at the boyscout version you can now ignore y and compare the rest for equivalence
21:38:45 <phanimahesh> The cond (==0)  ( k 1) is nicely if n = 0 then 1
21:39:08 <phanimahesh> ( except written as function with an argument)
21:41:10 <iqubic> Yes. Right.
21:41:18 <phanimahesh> Expand outer b. It's now \x -> cond ((==) 0) ( k 1) (the last part) x
21:41:27 <phanimahesh> This already looks so much better
21:41:43 <iqubic> But what is "(b (s (*)) (c b pred)))"
21:41:47 <phanimahesh> Now to pick apart the last part, apply c and write it as lambda.
21:44:09 <phanimahesh> We know that should be \x -> x * f (x-1), f coming from the y we threw away
21:44:29 <phanimahesh> X-1 is just pred x
21:45:11 <phanimahesh>  f ( pred x) is f.pred x which is b f pred x
21:47:47 <phanimahesh> gimme a minute, I'm typing it all out at once and post a gist
21:48:44 <bolver> this doesn't work --  ((\x -> x * 2) . (\x y -> x * y)) 2 4 but this does -- ((\x -> x) . (\x y -> x * y)) 2 4.  any idea why?
21:50:10 <bolver> appreciate any help
21:50:48 <ChaiTRex> > ((\x -> x * 2) . (\x y -> x * y)) 2 4 
21:50:50 <lambdabot>  error:
21:50:50 <lambdabot>      • No instance for (Num (Integer -> Integer))
21:50:50 <lambdabot>          arising from a use of ‘e_1224’
21:51:17 <bolver> ChaiTRex: coorect, but why does it give this type error?
21:51:32 <ChaiTRex> OK, so it appears x in the leftmost function is receiving an Integer -> Integer function instead of a number.
21:51:42 <ChaiTRex> So let's evaluate it by hand.
21:52:13 <ChaiTRex> ((\x -> x * 2) . (\x y -> x * y)) 2 4 
21:52:44 <ChaiTRex> ((\x -> x * 2)) (\y -> 2 * y) 4 
21:52:50 <ChaiTRex> And we see why.
21:53:13 <ChaiTRex> The 2 goes into the rightmost function, turning it into \ y -> 2 * y.
21:53:26 <ChaiTRex> that becomes the first argument to the leftmost function.
21:53:40 <bolver> ChaiTRex: what about the other case?
21:53:55 <bolver> ((\x -> x) . (\x y -> x * y)) 2 4 -- this works
21:54:06 <ChaiTRex> bolver: In the other case, the leftmost function is id.
21:54:17 <ChaiTRex> bolver: It can handle its argument being not a number but a function.
21:54:31 <ChaiTRex> (\x -> x) can take a functional argument, (\x -> 2*x) can't.
21:54:34 <bolver> but it gives a result
21:54:38 <ChaiTRex> Right.
21:54:40 <ChaiTRex> (\x -> x) can take a functional argument, (\x -> 2*x) can't.
21:54:49 <bolver> ((\x -> x) . (\x y -> x * y)) 2 4 = 8
21:55:02 <ChaiTRex> Right, but this is the key:
21:55:04 <ChaiTRex> (\x -> x) can take a functional argument, (\x -> 2*x) can't.
21:55:26 <bolver> ChaiTRex: got it
21:55:31 <ChaiTRex> :t (\x -> x) (\y -> 2*y)
21:55:32 <lambdabot> Num a => a -> a
21:55:37 <ChaiTRex> :t (\x -> 2*x) (\y -> 2*y)
21:55:39 <lambdabot> (Num a, Num (a -> a)) => a -> a
21:56:35 <bolver> ChaiTRex: so when you use function composition, you are limited to just 1 argument?
21:56:50 <bolver> i mean -- f . g $ x
21:56:52 <ChaiTRex> bolver: Yes, but multiple arguments can be handled.
21:57:04 <bolver> ChaiTRex: how so?
21:57:38 <iqubic> phanimahesh: How is that gist coming along?
21:57:48 <ChaiTRex> @pl \ x y -> (2*x + 2*y)
21:57:48 <lambdabot> (. (2 *)) . (+) . (2 *)
21:57:54 <bolver> ChaiTRex: multiple arguments are possible if f takes multiple args, correct?
21:57:58 <phanimahesh> pastebin under load apparently. I'm dm-ing you
21:58:02 <iqubic> I see.
21:58:41 <phanimahesh> ooh, irccloud has a internal pastebin. here you go. https://www.irccloud.com/pastebin/1DSs3DwM/
21:58:42 <ChaiTRex> bolver: You'll see (. f) and (f .) a lot in pointfree code that takes multiple arguments.
21:59:32 <bolver> ChaiTRex: i see -- any simple example you've in mind?
21:59:40 <ChaiTRex> bolver: Let's try your example.
22:00:01 <ChaiTRex> @pl \ x y -> 2 * x * y
22:00:01 <lambdabot> (*) . (2 *)
22:00:15 <phanimahesh> bolver: just take a pen and paper, or a plain editor, and expand. With time you'll see patterns.
22:00:26 <phanimahesh> f.g is first apply g, then f, right?
22:00:33 <ChaiTRex> phanimahesh: It is.
22:00:55 <ChaiTRex> bolver: For that one, it multiplies the first argument by 2 and then multiplies the result by the second argument.
22:00:59 <phanimahesh> so (f .) is now a function of two arguments. Take the first argument, apply it to second, and then apply the whole thing to f
22:01:14 <ChaiTRex> bolver: For your multiply by two as well code:
22:01:34 <phanimahesh> @pl \g x -> f(g(x))
22:01:34 <lambdabot> (f .)
22:01:35 <ChaiTRex> bolver: Sorry, we already did that.
22:01:54 <ChaiTRex> @. unpl pl \ x y -> 2 * x * y
22:01:55 <lambdabot> (\ x -> (*) (2 * x))
22:02:12 <bolver> ChaiTRex: i am not sure i am understanding what you are saying exactly
22:02:33 <ChaiTRex> bolver: It looks like the tools aren't going to be in forms close to what you were going for.
22:02:52 <phanimahesh> bolver: do you understand how (f .) behaves from my above explanation?
22:03:21 <bolver> an example of multiple arguments -- ((\x y -> x * y) . (\x -> x *2)) 2 4 = 16
22:03:25 <ChaiTRex> > (((\ x -> 2 * x) .) . (\ x y -> x * y)) 2 4
22:03:27 <lambdabot>  16
22:03:44 <ChaiTRex> bolver: There's how to do your 2 * one that failed.
22:03:59 <ChaiTRex> bolver: It has ((f .) . g) a b
22:04:05 <bolver> ChaiTRex: i know, which is exactly what i had said before
22:04:16 <ChaiTRex> bolver: No, you had (f . g) a b
22:04:43 <ChaiTRex> bolver: You need to take your (\ x -> 2 * x) function and put it before a . and surround by parentheses.
22:04:59 <phanimahesh> ((\x y -> x * y) . (\x -> x *2)) 2 4 == ((2*) . (*2)) 2 4
22:05:03 <bolver> so if you've f . g $ x, and `f` takes multiple arguments, then it will work, but `g` has to take just 1 argument, correct?
22:05:12 <phanimahesh> oops I meant ((\x y -> x * y) . (\x -> x *2)) 2 4 == ((*) . (*2)) 2 4
22:05:15 <ChaiTRex> bolver: Yes.
22:05:37 <phanimahesh> bolver: First, all functions take one argument.
22:05:40 <ChaiTRex> bolver: But if g takes two arguments, you need to make the first function have a . after it to have the second function take its two arguments.
22:05:47 <bolver> ChaiTRex: thanks much.   that's what i thought
22:06:29 <bolver> ChaiTRex: sorry, i didn't get you
22:06:47 <phanimahesh> ChaiTRex: I think we should first explain currying
22:06:59 <ChaiTRex> bolver: ((f .) . g) a b passes the two arguments, a b, to g, then the result of g a b to f.
22:07:07 <phanimahesh> the whole mess is because of thinking functions take multiple arguments imo
22:07:14 <bolver> ChaiTRex: got it
22:07:14 <ChaiTRex> @unpl ((f .) . g) a b
22:07:15 <lambdabot> (f (g a b))
22:07:37 <ChaiTRex> Ahh, that's how to use @pl
22:07:49 <ChaiTRex> @pl \a b -> (f a (g b))
22:07:49 <lambdabot> (. g) . f
22:07:55 <ChaiTRex> @pl \a b -> (f (g a b))
22:07:55 <lambdabot> (f .) . g
22:07:59 <ChaiTRex> etc
22:08:12 <bolver> ChaiTRex: got it
22:09:06 <bolver> ChaiTRex: it doesn't seem very readable to me, though
22:09:31 <bolver> it works, but i don't think i want to write code with multiple .
22:09:56 <ChaiTRex> bolver: Yeah, it can be better to be explicit with \ a b -> f (g a b)
22:10:40 <bolver> phanimahesh: you said something about currying -- what did you want to say?
22:11:00 <ChaiTRex> bolver: (\ a b -> (\ x -> 2*x) ((\ x y -> x*y) a b)) 2 4 
22:11:05 <ChaiTRex> > (\ a b -> (\ x -> 2*x) ((\ x y -> x*y) a b)) 2 4 
22:11:07 <lambdabot>  16
22:11:41 <ChaiTRex> > (\ x -> 2*x) ((\ x y -> x*y) 2 4)
22:11:43 <lambdabot>  16
22:11:54 <bolver> ChaiTRex: yes
22:12:27 <phanimahesh> bolver: All functions in haskell take one argument. If it looks like a function f takes two arguments x and y, it is actually f takes x, returns another function, which takes y
22:12:52 <bolver> phanimahesh: yes, i know
22:13:29 <bolver> phanimahesh: so in this case i posed, perhaps i should evaluated with currying in mind?
22:14:10 <bolver> phanimahesh: i am not sure what you intended
22:17:20 <bolver> ChaiTRex: i've 1 more question --  ($) (\x y -> x + y) 2 4  works, but  (\x y -> x + y) $ 2 4 doesn't.  is it because in the latter case, because $ has lowest precedence, ghc considers `2 4' as a function application?
22:18:07 <phanimahesh> bolver: yes, always apply one argument at a time. When you have function sections such as (f .) or (. g), it makes working it out clearer imo
22:18:17 <ChaiTRex> bolver: Yes, I believe so.
22:18:25 <bolver> thanks
22:19:05 <bolver> ChaiTRex: thanks much
22:19:58 <ChaiTRex> bolver: You're welcome.
22:30:30 <phanimahesh> Damn I think I confused iqubic by attempting to expand and explain stuff without being fully awake.
22:31:30 <phanimahesh> Someone do a proper job of convincing that `(\g x -> x * (g x)) . (\h -> h.pred) == \f x -> x * (f.pred $ x)`
22:32:02 <iqubic> @src (.)
22:32:02 <lambdabot> (f . g) x = f (g x)
22:33:27 <phanimahesh> actually I messed up much earlier. :/
22:33:52 <phanimahesh> or did I?
22:34:07 <phanimahesh> someone please help review this one:
22:34:23 <phanimahesh> https://www.irccloud.com/pastebin/1DSs3DwM/
22:34:40 <iqubic> Yeah. This is hard to do.
22:34:45 <phanimahesh> I _think_ I got it right but I keep mixing things up.
22:35:39 <phanimahesh> @pl (\g x -> x * (g x)) . (\h -> h.pred)
22:35:39 <lambdabot> ap (*) . (. pred)
22:35:53 <phanimahesh> @pl \f x -> x * (f.pred $ x)
22:35:54 <lambdabot> ap (*) . (. pred)
22:36:21 <phanimahesh> yay! atleast I was right. Even if I can't properly expand them to show equality right now.
22:36:48 <iqubic> Yeah.
22:38:11 <phanimahesh> Take a piece of pen and paper and work it out. Or I'll attempt it again after taking a bath.
22:38:22 <iqubic> @let s f g x = f x (g x)
22:38:24 <lambdabot>  Defined.
22:38:37 <iqubic> @pl s (*)
22:38:37 <lambdabot> s (*)
22:38:51 <phanimahesh> you may want @unpl
22:39:01 <iqubic> @unpl s (*)
22:39:01 <lambdabot> s (*)
22:39:03 <iqubic> Nope.
22:39:45 <phanimahesh> this one is atleast simple. s (*) = \g x -> x * (g x)
22:40:18 <phanimahesh> I think lambdabot's pl and unpl don't look at definitions give.
22:40:26 <ChaiTRex> @unpl (\ f g x -> f x (g x)) (*)
22:40:26 <lambdabot> (\ g x -> x * g x)
22:40:43 <iqubic> Thanks.
22:41:16 <iqubic> @unpl (\h -> h . pred)
22:41:17 <lambdabot> (\ h x -> h (pred x))
22:41:44 <iqubic> @unpl (\f g -> f . g)
22:41:45 <lambdabot> (\ f g0 x -> f (g0 x))
22:42:30 <iqubic> @pl (\f g -> f . g)
22:42:30 <lambdabot> (.)
22:45:45 <iqubic> > (\x y -> x - y) 2 1
22:45:48 <lambdabot>  1
22:46:37 <iqubic> (\x y -> x - y) 2 = (\y -> 2 - y)?
22:46:39 <iqubic> right???
22:46:56 <ChaiTRex> iqubic: Yes.
22:47:37 <ChaiTRex> @unpl (\ x y -> x - y) 2
22:47:37 <lambdabot> (\ y -> 2 - y)
22:47:52 <iqubic> Nice.
23:00:16 <iqubic> Alright. I finally worked through it all and found all of my mistakes.
23:00:29 <iqubic> Why would you want to write factorial like that?
23:01:37 <ChaiTRex> iqubic: To learn lambda calculus, probably.
23:02:39 <iqubic> I see.
23:09:08 * phanimahesh is back
23:09:44 <iqubic> I figured it out on my own.
23:09:49 <iqubic> But thanks for helping.
23:09:54 <phanimahesh> Nice.
23:44:58 <laudecay> yo this pkg has no xaead for chacha20poly1305? https://hackage.haskell.org/package/cryptonite-0.26/docs/Crypto-Cipher-ChaChaPoly1305.html
23:45:17 <laudecay> do the devs lurk in here perchance or is there like a contributor guide
23:46:07 <Eduard_Munteanu> They might be in here.
23:49:07 <ChaiTRex> laudecay: Hackage lists the home page as https://github.com/haskell-crypto/cryptonite
23:49:14 <laudecay> ye im lookin at the code
23:49:21 <laudecay> this is gonna b more legwork than i wanted :( :(
23:51:38 <laudecay> fuuuckmylife
23:51:44 <laudecay> this is gonna be WRITING CODE
23:51:49 <laudecay> gah
23:52:46 <phanimahesh> we're the only profession where an aversion to actually do the thing wer're supposed to do is a good quality to have.
23:53:24 <laudecay> :(
23:53:31 <laudecay> im about to roll crypto
23:53:33 <laudecay> i wanna yell
23:56:08 * hackage cmf 0.1 - (C)oncurrent (M)onoidal (F)olds  https://hackage.haskell.org/package/cmf-0.1 (chessai)
23:56:23 <phanimahesh> do not roll your own crypto. :P
23:56:50 <phanimahesh> pay someone else to do it. You'll then avoid the cardinal sin.
23:57:46 * phanimahesh taps forehead
