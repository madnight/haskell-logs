00:07:52 <jle`> parser combinators are great ... i just used them to implement a parser for type level lists of tokens ... and it was only a fraction of the pain i thought it would be ...
00:08:02 <jle`> or maybe i'm still on a rush
00:10:56 <koz_> jle`: GHC as a mental force multiplier is totes a thing.
00:23:09 <phanimahesh> I just fought and gave up trying to parse time nicely.
00:23:55 <phanimahesh> How do I go from "2019-11-24T05:15:00.00Z" to Date.Time.LocalTime ?
00:24:09 * hackage math-grads 0.1.6.2 - Library containing graph data structures and graph algorithms  https://hackage.haskell.org/package/math-grads-0.1.6.2 (AlexKane)
00:25:00 <phanimahesh> (ended up doing take 19 then parseTimeM ...)
00:25:21 <dminuoso> phanimahesh: https://hackage.haskell.org/package/time-1.9.3/docs/Data-Time-Format-ISO8601.html#v:iso8601ParseM
00:29:05 <phanimahesh> Ah. Recent one, not in stackage.
00:29:39 <koz_> phanimahesh: You might wanna try a nightly.
00:29:40 <phanimahesh> but I should have found that while searching.. not sure how I missed it.
00:29:47 <phanimahesh> yeah, found it in nightly
00:30:19 <phanimahesh> but damn. let me look at the source.
00:33:58 <phanimahesh> yep. Implements from the scratch.
00:34:04 <phanimahesh> as suspected.
00:44:07 <phanimahesh> Actually, nevermind. Found that I couldn't read. Was using format specifiers from DiffTime and scratching my head why it wasn't working on LocalTime
00:44:25 <phanimahesh> Doesn't help that the lists are all almost identical, with differences
00:44:42 <jared-w> How would that not be in stackage?
00:45:44 <jared-w> tbf the time library is horribly confusing in general. I don't blame you for messing it up; I screw it up horribly every time I use it lol
00:47:28 <phanimahesh> jared-w: it is in stackage, but an older version. none of the lts versions have this
00:48:11 <jared-w> Really? It's been in there since 1.9 (I think) and that's been out for over a month
00:50:41 <jared-w> oh, 1.9 has been out since around January of last year.
00:51:21 <jared-w> but yup, sure enough, v1.8.0.2 is the latest in the lts. Weird
01:00:38 * hackage data-diverse 4.7.0.0 - Extensible records and polymorphic variants.  https://hackage.haskell.org/package/data-diverse-4.7.0.0 (louispan)
01:13:21 <bwe> I wonder why project-wide default-extensions set in project.yaml get not applied to MyModule/SubModule/SubSubModule.hs. Although extensions in question are clearly under the test section in the generated .cabal file, ghc complains when run via stack test. It seems the extensions get not propagated through. As expected, stack ghci and stack build both run without any such complaint.  ghc 8.6.5, stack 2.1.3. 
01:13:27 <bwe> Is this rather a stack or a ghc issue?
01:19:38 * hackage postgresql-binary 0.12.2 - Encoders and decoders for the PostgreSQL's binary format  https://hackage.haskell.org/package/postgresql-binary-0.12.2 (NikitaVolkov)
01:20:53 <boxscape> do you still need the bang if you use {-# UNPACK #-}?
01:22:29 <boxscape> dansho jugding by https://stackoverflow.com/questions/33931991/what-does-the-unpack-pragma-do-in-this-case it looks like there still is a difference, namely whether or not the Int# constructor is part of values of the type
01:23:01 <boxscape> I suppose the I# also means you do need to use the bang with unpack
01:23:09 <boxscape> (if you want it to be strict
01:23:10 <boxscape> )
01:24:11 <boxscape> oh ewait
01:24:13 <boxscape> wait*
01:24:18 <boxscape> I looked at the logs from yesterday
01:24:48 <boxscape> (so this question was asked hours ago instead of minutes ago as I thought)
01:27:26 <dansho> still here =)
01:28:11 <boxscape> luckily today's logs only started an hour and a half ago :D
01:29:33 <EvanR> wait... if you put # at the end of a ctor, it auto makes all the fields strict?
01:30:05 <dansho> i think Int# itself is strict in this case
01:30:26 <MarcelineVQ> EvanR: nooo
01:30:28 <EvanR> earlier, there was an example with Bar#
01:30:39 <dansho> it was Bar# Int#
01:31:19 <boxscape> dansho actually my answer wasn't right I think, since the stackoverflow answer uses T (P Int Int), rather than using Int directly as field type
01:31:23 <EvanR> an unboxed type as a field is a strict field
01:31:32 <EvanR> is that it
01:31:57 <dansho> good answer in that stackoverflow link
01:32:04 <boxscape> that sounds right to me EvanR, since values of unboxed types are always strict, afaik
01:32:27 <MarcelineVQ> > Identity undefined `seq` ()
01:32:30 <lambdabot>  *Exception: Prelude.undefined
01:33:04 <boxscape> Identity is presumably a newtype
01:33:12 <EvanR> i'm glad you did that MarcelineVQ was about to try something silly, now i will refine it
01:33:14 <MarcelineVQ> ahye maybe it is
01:33:24 <EvanR> (to use a data type not newtype)
01:35:44 <EvanR> :t Only 3
01:35:46 <lambdabot> Num a => Only a
01:35:48 <EvanR> :t Only 3#
01:35:50 <lambdabot> error:
01:35:50 <lambdabot>     • Couldn't match a lifted type with an unlifted type
01:35:50 <lambdabot>       When matching types
01:35:58 <EvanR> well never know~
01:36:52 <nshepperd> the rule is something like, a variable of unboxed type is always already evaluated
01:37:35 <EvanR> :t Only' 3#
01:37:36 <lambdabot> error:
01:37:36 <lambdabot>     • Couldn't match a lifted type with an unlifted type
01:37:36 <lambdabot>       When matching types
01:37:52 <EvanR> strict, unboxed, unlifted... oh my
01:38:03 <dansho> i'm still unsure if `Bar {-# UNPACK #-} !Int` is equivalent to `Bar Int#`
01:38:12 <EvanR> unpacked
01:38:22 <boxscape> dansho at this point I believe the answer is yes, but not sure either
01:40:10 <EvanR> not to mention ghc auto unpacks things sometimes, aiui
01:40:43 <boxscape> % data Bar = Bar {-# UNPACK #-} Int
01:40:43 <yahb> boxscape: ; <interactive>:8:12: warning:; * UNPACK pragma lacks '!' on the first argument of `Bar'; * In the definition of data constructor `Bar'; In the data type declaration for `Bar'
01:40:50 <boxscape> % Batr undefined `seq` 5
01:40:51 <yahb> boxscape: ; <interactive>:9:1: error:; * Data constructor not in scope: Batr :: t0 -> t1; * Perhaps you meant `Bar' (line 8)
01:40:54 <boxscape> % Bar undefined `seq` 5
01:40:55 <yahb> boxscape: 5
01:41:05 <boxscape> does it just ignore the pragma if you forget the !?
01:41:40 <boxscape> also interestingly doesn't provide a name for that warning
01:41:58 <EvanR> quite pagmatic of it to do so (and give a warning about it)
01:42:08 <boxscape> nice
01:42:32 <EvanR> just noticed that, so error messages have programming for 'first', 'second', ... i wonder to how high
01:42:59 <EvanR> 'nine hundred ninety ninth argument of Bar'
01:43:02 <boxscape> If I had to bet I'd bet on 62
01:43:23 <EvanR> sixty third?
01:43:54 <EvanR> two fifty fifth
01:44:38 <boxscape> oh it just switches to digits instead of words at some point
01:44:47 <boxscape> maybe it goes arbitrarily high then
01:44:55 <EvanR> well ok... what point
01:45:24 <boxscape> 7th is the first
01:45:35 <EvanR> and 1st is seventh?
01:45:45 <boxscape> No 1st is "first" :)
01:45:48 <EvanR> oh
01:45:59 <EvanR> so 7th is ... 8
01:46:25 <EvanR> or 6
01:47:09 <EvanR> "you screwed up the zeroth argument"
01:50:24 <nshepperd> i would have bet on 12, since sequence words get pretty regular and uninteresting after that
01:50:57 <boxscape> I also learned in school to use digits after 12
01:53:25 <EvanR> 13th is pretty luck
01:53:29 <EvanR> y
01:55:45 <EvanR> if you have over 12 arguments you're probably asking for trouble anyway
01:56:38 <boxscape> you might need it if you're interfacing with some database or JSON file
02:31:08 * hackage HTF 0.14.0.0 - The Haskell Test Framework  https://hackage.haskell.org/package/HTF-0.14.0.0 (StefanWehr)
02:40:55 <bwe> Why does   fmap (/2) $ (+) <$> Just (3) <*> Just (4)  work but   ((/2) . (+)) <$> Just (3) <*> Just (4) not?
02:44:29 <[exa]> bwe: what's the error btw?
02:45:30 <[exa]> :t (/2) . (+)
02:45:32 <lambdabot> (Fractional (a -> a), Num a) => a -> a -> a
02:46:51 <[exa]> bwe: (.) can not be applied that easily to 2-parameter functions
02:48:04 <bwe> [exa]: Did I just try to compose functions of different arity?
02:48:10 <[exa]> yes
02:48:17 <merijn> bwe: (/2) expects one argument (a number), but "f . g" is basically "\x -> f (g x)"
02:48:23 <[exa]> btw there's the boobs operator that does what you want
02:48:31 <merijn> bwe: So what you're passing to (/2) is "+" applied to one number
02:48:32 <[exa]> > (((.).(.)) (/2) (+)) <$> Just (3)  <*> Just (4)
02:48:34 <lambdabot>  Just 3.5
02:48:53 <EvanR> a funny short hand for (.).(.) is .:
02:49:03 <EvanR> and (.).(.).(.) is .::
02:49:14 <[exa]> EvanR: I'd love to have these in Prelude. :]
02:49:23 <[exa]> :t (.:)
02:49:25 <lambdabot> error:
02:49:25 <lambdabot>     • Variable not in scope: .:
02:49:25 <lambdabot>     • Perhaps you meant one of these:
02:49:34 <[exa]> :(
02:49:34 <EvanR> but... if haskell code starts using these for real... then we're all sons of bitches
02:49:40 <merijn> bwe: The first version works because you're applying (/2) (via fmap) to the result of "(+) <$> Just 3 <*> Just 4", so + will have already consumed two arguments, resulting in a single number (that gets passed to (/2)
02:49:59 <bwe> merijn: I understand it until then.
02:50:44 <bwe> merijn: But how do . and $ make a difference then?
02:51:17 <merijn> bwe: I mean, those two are different things? I'm not sure why everyone always expects them to be remotely the same
02:51:40 <[exa]> bwe: in the first case you have squashed the 2 parameters manually and applied the second function to the result (notice there are 2 different fmaps)
02:51:48 <merijn> bwe: Using (.) you're making a new function ((/2) . (+)) and fmapping that one single function over "Just 3"
02:52:01 <merijn> bwe: Bute "(/2) . (+)" doesn't type check
02:52:08 <merijn> :t (/2) . (+)
02:52:09 <lambdabot> (Fractional (a -> a), Num a) => a -> a -> a
02:52:12 <EvanR> yes... 'bru do you even compose functions' translations to both . and $ in other communities
02:52:25 <merijn> Or rather, it typechecks IFF there is a number instance for functions (which there isn't)
02:52:37 <EvanR> they are lacking in the jargon "function application"
02:52:53 <dminuoso> % f | True = 1; f | False = 2
02:52:54 <yahb> dminuoso: ; <interactive>:11:15: error:; Multiple declarations of `f'; Declared at: <interactive>:11:1; <interactive>:11:15
02:52:59 <merijn> bwe: $ just applies "function on the left" to "stuff on the right"
02:53:01 <dminuoso> I somehow expected this to be allowed. Is there a way to write it like this?
02:53:05 <merijn> :t fmap (/2)
02:53:07 <lambdabot> (Functor f, Fractional b) => f b -> f b
02:53:19 <merijn> :t (+) <$> Just 3 <*> Just 4
02:53:20 <lambdabot> Num b => Maybe b
02:53:42 <merijn> dminuoso: It is allowed
02:54:01 <dminuoso> merijn: Why is GHCi emitting multiple declaration errors?
02:54:06 <bwe> thanks for your explanations, helped!
02:54:08 <dminuoso> (Or GHC, rather)
02:54:10 <boxscape> EvanR Data.Composition uses .:. for (.).(.).(.)
02:54:14 <EvanR> :t (/2) .: (+)
02:54:16 <lambdabot> Fractional c => c -> c -> c
02:54:21 <EvanR> huehue
02:54:26 <dminuoso> boxscape: That's not consequent. It should be .::
02:54:28 <merijn> dminuoso: hmm, maybe only for functions due to duplicate bindings being allowed there
02:54:47 <dminuoso> merijn: Im so sure I've used this for non-function bindings before...
02:54:55 <Lears> % let f | True = 1 | False = 2 in f
02:54:56 <yahb> Lears: 1
02:54:56 <boxscape> dminuoso the rule they give is  "count the dots after the first one"
02:55:10 <EvanR> boxscape: well... historically i think .: and .:: are consistent with the "number of (.)"
02:55:19 <merijn> dminuoso: Without the duplicate f it works fine
02:55:20 <dminuoso> boxscape: So what is `(.).(.)` then?
02:55:29 <EvanR> er number of .
02:55:49 <dminuoso> merijn: Well that wouldn't be very useflu
02:56:05 <dminuoso> merijn: (It would either be trivial patterns, or incomplete ones)
02:56:09 <merijn> dminuoso: Why? What's the use case where that doesn't work, but the current does?
02:56:46 <dminuoso> merijn: So Im inside some where binding group and I want to do something like `f x = ... where g | x > 0 = True; g | otherwise = False
02:57:14 <merijn> whoops: What's wrong with just "g | x > 0 = True; |otherwise = False"?
02:57:32 <dminuoso> merijn: Ah nothing!
02:57:42 <dminuoso> merijn: Hah. Okay thanks that was my mistake :P
02:57:47 <merijn> dminuoso: That was my point, the problem is starting the next line with 'f'
02:58:00 <merijn> Which works for functions since those allow multiple bindings *anyway*
02:58:01 <dminuoso> merijn: Somehow I feel this should be valid nevertheless.
02:58:14 <merijn> Debatable
02:58:18 <dminuoso> Fair enough
02:58:36 <merijn> I think restricting values to a single binding is conceptually correct and simpler to understand
02:59:05 <merijn> anyway, lunch
03:23:19 <JanusBijle> Hi guys, I'm really struggling here. I'm trying to implement a simple lock system for n processes, but without using MVar (so with IORefs then). I'm noticing that I'm trying too much to implement C-like solutions and not paying any attention to the Haskell-way. Can someone point me in the right direction? Thanks. It can be a really simple lock
03:23:19 <JanusBijle> system.
03:25:07 <dminuoso> JanusBijle: Why do you feel you need a lock?
03:25:40 <JanusBijle> dminuoso Because I'd like to implement a critical section
03:27:07 <dminuoso> JanusBijle: What for? Are you doing ffi?
03:27:30 <dminuoso> JanusBijle: (Im trying to get an idea of what situation you are in)
03:27:38 * hackage pandoc-stylefrommeta 0.2.2.0 - Pandoc filter to customize links, images and paragraphs  https://hackage.haskell.org/package/pandoc-stylefrommeta-0.2.2.0 (lyokha)
03:28:42 <JanusBijle> Let me try to explain it to you. I'd like to implement a simple divide and conquer-system with multiple processes, and have them share a thread safe counter, by not using MVars. So that's why I need locks, to protect the counter in a critical section. dminuoso
03:30:35 <dminuoso> JanusBijle: A TVar would have what you want out of the box.
03:30:57 <dminuoso> JanusBijle: It lets you focus on the semantics without the subtle details of implementation
03:32:23 <dminuoso> JanusBijle: Or rather, check out STM in general.
03:32:50 <JanusBijle> Thanks for your reply dminuoso, however, I'm not able to use any outside libraries for this challenge. It has to be a self-written 'algorithm' to protect the critical section.
03:33:23 <laudecay> hi i'm trying to use cabal to build and test what will eventually be an executable, but currently has a submodule that's going to be mostly in c with a little ffi on top
03:33:24 <JanusBijle> And I'm finding lots of solutions to protect a critical section using arrays and stuff, but nothing that seems 'Haskell-ly'
03:33:25 <dminuoso> JanusBijle: STM comes with base.
03:33:37 <dminuoso> JanusBijle: The Haskell-ly way is to use STM
03:33:47 <laudecay> how do i build just this sub-library and test it properly?
03:34:26 <dminuoso> JanusBijle: The STM support is built into the runtime itself. You could consider it part of GHC Haskell.
03:35:39 <JanusBijle> Thanks for your reply dminuoso. However, while you are right, we can only use self-written solutions using IORefs. 
03:35:39 <dminuoso> JanusBijle: You are relying on library support either way in any language.
03:35:51 <dminuoso> JanusBijle: Is that a homework assignment?
03:36:36 <dminuoso> well there's this
03:36:38 <dminuoso> % :t atomicModifyIORef
03:36:38 <yahb> dminuoso: IORef a -> (a -> (a, b)) -> IO b
03:37:04 <dminuoso> Which lets you implement a thread safe counter trivially..
03:40:08 * hackage pandoc-vimhl 0.1.3.0 - Pandoc filter for native Vim code highlighting  https://hackage.haskell.org/package/pandoc-vimhl-0.1.3.0 (lyokha)
03:40:43 <JanusBijle> Thanks all! So, this is what I'd do in a C-like language: while (atomic_cas(lock, 0, 1) == 1). I'm having a hard time understanding how to 'translate' this to the atomicModifyIORef-funciont
03:40:54 <JanusBijle> *function
03:42:03 <JanusBijle> (and after the while you'd enter the critical section, of course)
03:46:18 <boxscape> dminuoso was afk, but the sequence is . .: .:. .:: .::. .:::, so it's consistent except that . should be ..
03:49:17 <merijn> JanusBijle: There's already an atomic counter package, btw
03:49:52 <JanusBijle> Thanks merijn, but for this challenge, we're not able to use that package :(
03:50:21 <JanusBijle> I'm really looking for a way to transfer while (atomic_cas(lock, 0, 1) == 1) in Haskell with atomicModifyIORef
03:51:17 <merijn> That seems fairly straightforward?
03:52:22 <JanusBijle> Could you help me understand why, merijn?
03:52:47 <JanusBijle> I'm very new to this
03:53:56 <evelyn> I think you could for instance do something with recursion and if then else
03:54:06 <merijn> JanusBijle: atomicModifyIORef returns two things: 1) the new value of the counter and 2) a result for the total action, so locking is just "always return 1 as new value, return old value as total result"
03:54:26 <merijn> And then you just loop until the old value was "lock is free"
03:54:47 <merijn> It's going to be pretty inefficient, though
04:42:09 * hackage generic-deriving 1.13.1 - Generic programming library for generalised deriving.  https://hackage.haskell.org/package/generic-deriving-1.13.1 (ryanglscott)
05:04:39 * hackage deriving-compat 0.5.8 - Backports of GHC deriving extensions  https://hackage.haskell.org/package/deriving-compat-0.5.8 (ryanglscott)
05:04:43 <boxscape> Do case expressions in core have guards? Or or guards translated into (guardless) case-expressions?
05:05:46 <phadej> core doesn't have guards
05:05:50 <berndl> I'm pretty sure guards are syntax suger.
05:05:57 <berndl> *sugar
05:06:00 <boxscape> ok, thanks
05:06:06 <phadej> Core's case is very different from Haskell source level case
05:07:05 <phadej> as the simple example `case p of ~(x,y) -> ...` will most likely not compile to Core's case 
05:07:30 <phadej> or case x of Identity x' -> ...
05:08:02 <boxscape> yeah, I think I can see why
05:13:09 * hackage pandoc-stylefrommeta 0.2.3.0 - Pandoc filter to customize links, images and paragraphs  https://hackage.haskell.org/package/pandoc-stylefrommeta-0.2.3.0 (lyokha)
05:14:39 * hackage comonad 5.0.6 - Comonads  https://hackage.haskell.org/package/comonad-5.0.6 (ryanglscott)
05:15:39 * hackage inflections 0.4.0.5 - Inflections library for Haskell  https://hackage.haskell.org/package/inflections-0.4.0.5 (stackbuilders)
05:17:32 <dminuoso> boxscape: https://gitlab.haskell.org/ghc/ghc/blob/master/compiler/coreSyn/CoreSyn.hs#L254-266
05:17:36 <dminuoso> boxscape: That's the entirety of Core.
05:17:56 <dminuoso> (It's that simple)
05:19:28 <boxscape> nice
05:19:46 <boxscape> though I suppose there's a bit of additional complexity from the types that that type uses
05:20:50 <dminuoso> boxscape: It's much simpler because there's no inference.
05:20:57 <boxscape> I see
05:21:01 <dminuoso> Which is why impredicativity works in core.
05:22:55 <Geekingfrog> What is `Tick  (Tickish Id) (Expr b)` ?
05:23:31 <boxscape> apparently that's used for profiling
05:23:57 <boxscape> https://gitlab.haskell.org/ghc/ghc/blob/master/compiler/coreSyn/CoreSyn.hs#L937
05:23:57 <merijn> What's the best/simplest way to GC my global store? Can I simply nuke ~/.cabal/store or do I need to do something more complicated
05:24:33 <merijn> (I'm okay with just nuking everything and rebuilding)
05:27:21 <dminuoso> merijn: Nuking ~/.cabal/store looks to be sufficient.
05:30:36 <merijn> dminuoso: Yeah, apparently that's enough :)
05:34:10 <Ariakenom> There is no more fine grained GC? More like just C.
05:34:28 <phadej> there are only designs
05:34:37 <merijn> phadej: Implementations too!
05:34:52 <merijn> Very brittle and "alpha" implementations, sure. But at least one exists
05:34:57 <phadej> maybe prototypes yes
05:50:13 <gauga> hello guys
05:52:05 <boxscape> hi
05:53:43 <boxscape> hm I'm getting "unhandled PEi386 relocation type 0" if I try to use singletons from any of the ghc 8.8.1 stackage snapshots. Anyone encountered this before?
05:54:08 * hackage bifunctors 5.5.6 - Bifunctors  https://hackage.haskell.org/package/bifunctors-5.5.6 (ryanglscott)
05:54:51 <gauga> I am trying to write a function wordCount :: Document -> WordTally that computes a tally of all the distinct words appearing in the document. For example, the text "A rose is a rose. But so is a rose." should return:
05:54:51 <gauga> a | 3
05:58:08 * hackage lift-generics 0.1.3 - GHC.Generics-based Language.Haskell.TH.Syntax.lift implementation  https://hackage.haskell.org/package/lift-generics-0.1.3 (ryanglscott)
06:03:43 <boxscape> gauga what problem are you having with it?
06:06:08 * hackage semigroupoids 5.3.4 - Semigroupoids: Category sans id  https://hackage.haskell.org/package/semigroupoids-5.3.4 (ryanglscott)
06:09:39 * hackage profunctors 5.5.1 - Profunctors  https://hackage.haskell.org/package/profunctors-5.5.1 (ryanglscott)
06:12:10 <gauga> This is what I have so far: elemCount x list = length ( filter ( x == ) list )
06:12:35 <gauga> The problem here is I am getting a list with repeated elements: [("rose",3),("a",3),("rose",3),("a",3),("rose",3),("is",2),("is",2),("a",3),("but",1),("so",1)]
06:12:43 <gauga> How do I filter out the unique elements? 
06:13:29 <boxscape> :t nub
06:13:30 <lambdabot> Eq a => [a] -> [a]
06:13:50 <boxscape> nub is a functions that takes a list and only keeps one copy of each element
06:14:10 <boxscape> gauga ^
06:14:22 <phadej> > :t Map.fromListWith (+) . map (\x -> (x, 1)) 
06:14:25 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
06:14:34 <phadej> :t Map.fromListWith (+) . map (\x -> (x, 1)) 
06:14:35 <lambdabot> error:
06:14:35 <lambdabot>     Not in scope: ‘Map.fromListWith’
06:14:35 <lambdabot>     Perhaps you meant one of these:
06:14:49 <phadej> ah, well, maybe lambdabot don't have Map
06:15:05 <boxscape> :t Data.Map.fromListWith (+) . map (\x -> (x, 1)) 
06:15:07 <lambdabot> (Ord k, Num a) => [k] -> M.Map k a
06:15:12 <boxscape> it does phadej
06:15:18 <phadej> boxscape: thanks, TIL
06:15:38 <boxscape> :t M.fromListWith (+) . map (\x -> (x, 1)) 
06:15:40 <lambdabot> (Ord k, Num a) => [k] -> M.Map k a
06:19:09 * hackage hreq-core 0.1.1.0 - Core functionality for Hreq Http client library  https://hackage.haskell.org/package/hreq-core-0.1.1.0 (epicallan)
06:23:38 * hackage hreq-client 0.1.1.0 - A Type dependent Highlevel HTTP client library.  https://hackage.haskell.org/package/hreq-client-0.1.1.0 (epicallan)
06:45:56 <boxscape> If I've built a local library with stack, how do I actually use it somewhere else in ghci?
06:53:03 <boxscape> oh huh
06:53:36 <fendor> boxscape, do you want to use it in another project?
06:54:07 <boxscape> If I build the singletons package locally and use it with stack in that directory, it works. If I copy the build folder somewhere else and try to use it, I get the same unhandled PEi386 error I get if I get it from stackage
06:54:14 <boxscape> fendor I just want to experiment with one file in ghci
06:55:24 <fendor> you can probably point ghci to the compiled files.
06:55:37 <phadej> I'd now how to do that with cabal v2-build
06:55:40 <fendor> but I dont know specific with only ghci
06:55:43 <boxscape> okay
06:55:51 <opqdonut> if you just want to experiment with one file, just do `stack ghci` in the singletons dir
06:55:56 <phadej> just build it, and use .ghc.environment.* generated
06:56:02 <opqdonut> and then `:load MyFile.hs` or something
06:56:27 <boxscape> opqdonut ok, I did that initially, main reason I wanted to try it differently was to make sure the issue I'm about to report doesn't happen otherwise, but maybe this will have to do
06:56:32 <fendor> phadej, so far, the .ghc.env* files did never what I hoped they would do
06:56:42 <hvr> fendor: what did you hope for? ;-)
06:57:25 <opqdonut> boxscape: you can probably do something like `stack --package=singleton-abc123 ghci` in another directory too, but I'm not sure what the syntax would be
06:57:29 <fendor> hvr, if i do ghci in a project dir with .ghc.env*, it does start with the packages in scope?
06:57:40 <hvr> fendor: yes
06:58:13 <hvr> they're basically just special "response files" for ghc & ghci
06:58:27 <boxscape> Should I expect it to work if I copy the build folder somewhere else and start stack ghci in there?
06:58:44 <fendor> then I am doing something wrong because for me, it fails to start ghci 
06:58:46 <boxscape> because I'm getting a segfault and am wondering whether and where I should report that
06:59:19 <phadej> fendor: you actually have to build stuff first
06:59:30 <fendor> phadej, i did
06:59:43 <fendor> at least I think I did? Because now I just wanted to test it and it worked as hoped
07:00:15 <phadej> good :)
07:00:26 <fendor> not good, what did I wrong all the time :/
07:01:27 <boxscape> oh actually I think what I'm experiencing is that stack is still using it's stackage version of the library even if I use ghci in the copy of the build dir
07:01:56 <phadej> ghci doesn't pick anything from local directory
07:02:07 <phadej> (except .ghci and .ghc.environment.*)
07:02:19 <phadej> but definitely it doesn't know anything about stack's build directory structure
07:02:36 <boxscape> I may have forgot to mention but I'm using "stack ghci"
07:02:43 <phadej> ....
07:08:05 <boxscape> hm I expected ghci to find local compiled files the same way it finds local source files but yeah I guess it doesn't
07:24:10 <orcus> Is there any reason we shouldn't be allowed to derive Generic on "non-gadt slices" of a GADT, i.e. data T a where B : T Bool; I : T Int; deriving instance Generic (T Bool)?
07:24:52 <orcus> Since T Bool is isomorphic to data TB = C, it seems like this makes sense, but I may be missing something
07:32:43 <merijn> orcus: You're assuming GHC has the boilerplate to prove that fact
07:35:35 <orcus> merijn: sure, GHC probably can't see that now, but perhaps we should improve it! I am wondering if there's a reason this is doomed to failure.
07:35:46 <Cale> This kind of question keeps arising in all different circumstances lately: how to get the compiler to determine for some GADT, at a specific index, exactly which constructors could be used to build a term of that type, or show that the remaining constructors are unneeded, etc.
07:36:03 <Cale> I think it's probably undecidable in general, once you work in type families
07:37:32 <orcus> I think there should be a difference between indices in GADTs (which should be patterns simple enough that everything is decidable), and equality constraints (which are wild, and you need to worry about providing evidence for)
07:39:52 <orcus> Implementation-wise for deriving Generic (T Bool), I would be happy with GHC looking at the definition of T and doing the simplest thing of "if the index is Bool, keep this constructor; if the index is apart from Bool, ignore this one; if we can't tell, throw an error"
07:39:55 <Cale> I'm pretty sure we're eventually going to need a way to explicitly provide evidence that cases are impossible, if we keep on down the road we have been going.
07:40:09 * hackage free 5.1.3 - Monads for free  https://hackage.haskell.org/package/free-5.1.3 (ryanglscott)
07:40:19 <orcus> Whereas currently we seem to ignore the first two cases and always error!
07:42:14 <lyxia> that seems awfully ad-hoc for something to bake into the language
07:42:48 <lyxia> might as well use Template Haskell to do it yourself
07:43:35 <Ariakenom> "don't write that equivalent code! you will confuse the compiler." you can get more of those weird effects if you dont always error
07:45:06 <orcus> lyxia: good point
07:48:12 <glguy> Anyone know a way to get cabal-install-3 for my Raspberry PI? (I don't have enough RAM on the device itself to compile it)
07:48:13 <hseg> Hi. Trying to compute the dimension of some vector spaces, as well as finding a basis among a set of linearly dependent vectors. WLibraries recommended?
07:51:07 <boxscape> glguy could take forever but have you considered setting up a large enough swap partition in some way?
07:51:50 <boxscape> (or swap file)
07:51:58 <merijn> glguy: Build it in a VM for the same architecture? >.>
07:55:02 <zincy_> Does anyone want to give feedback on a blog post. Its a brief introduction to Haskell's type system. https://pastebin.com/FPsx125g
07:55:44 <zincy_> I can just publish it if reading raw markdown is too unpleasant
07:56:06 <dminuoso> zincy_: Make it a gist.
07:56:10 <dminuoso> zincy_: That allows comments to be added inline.
07:56:17 <dminuoso> (Or does it on github?)
07:56:20 <zincy_> ok
07:56:34 <dminuoso> well. at least comments :
07:57:21 <zincy_> https://gist.github.com/therewillbecode/449ecf91d210a0e8e43b3bce5b2771ce
07:57:50 <dminuoso> Look at that! Markdown rendering too. :o)
07:58:10 <zincy_> I know right :)
07:58:58 <dminuoso> zincy_: `Everything to the right of the = lives in the values world.` <- Id say this is incorrect.
07:59:15 <dminuoso> `newtype Foo = Foo Int` I'd say the `Int` very much lives in the type world...
07:59:26 <zincy_> ah yes
07:59:29 <zincy_> Thanks
07:59:37 <dminuoso> zincy_: Also, you might want to make it clear that this only applies to data/newtype declarations.
08:00:53 <hseg> ... I *could* encode my set as a matrix and compute echelon form, but that feels a bit roundabout. Moreover, my vectors are pretty sparse and I'm concerned this will be inefficient
08:01:00 <zincy_> I forgot about type synonyms hehe
08:01:41 <orcus> hmm, is it possible to ask GHC to do unification in TH / is there a library for it? Otherwise i guess a plugin may be easier than writing that myself!
08:01:44 <dminuoso> zincy_: Sure. And about bindings in general.
08:01:58 <dminuoso> orcus: To what end/
08:04:39 * hackage tmp-postgres 1.19.0.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.19.0.0 (JonathanFischoff)
08:08:06 <Amras> I'm trying to use the record selector audioSpecFormat from sdl2, in the context `show (audioSpecFormat mySpec)`, just to print it out to the user. AudioSpec doesn't have any exported constructors, so I can't use pattern-matching to extract the value.
08:08:52 <orcus> dminuoso: a probably-stupid idea to derive Generic for (parts of) GADTs, where the index is fixed so the possible constructors can be thought of as forming non-gadt type.
08:08:56 <Amras> However, apparently there's an escaped type variable flying around there, probably inside the AudioFormat type, since that's * -> *
08:09:20 <Amras> so ghc insists that record selectors can't be used.
08:09:41 <Amras> Any way I can extract the value without a massive switch of all the possibilities?
08:11:01 <orcus> dminuoso: Alternatively put, from data T a where TI : T Int ; TB : T Bool, we should be able to automatically get T Bool is iso to data T_Bool = TB'
08:11:39 * hackage dependent-monoidal-map 0.1.1.1 - Dependent map that uses semigroup mappend  https://hackage.haskell.org/package/dependent-monoidal-map-0.1.1.1 (abrar)
08:11:39 <orcus> dminuoso: generally, I want to know whether a particular constructor can inhabit a GADT at a given index
08:11:43 <tom__> dminuoso: What do you mean "about bindings in general?"
08:12:36 <boxscape> tom__ the equal sign in something like "let x = 3"
08:12:42 <dminuoso> Amras: https://hackage.haskell.org/package/sdl2-2.5.0.0/docs/src/SDL.Audio.html#audioSpecFormat the underlying data AudioSpec is existentially quantified.
08:12:42 <glguy> Amras: I don't think you can get that field, actually. The author needs to provide a different way to access that field
08:13:11 <boxscape> or you can make your own similar type and unsafeCoerce to get the field out :^)
08:14:33 <Amras> The frustrating thing is that AudioFormat instances Show
08:14:47 <Amras> so it's just begging to be displayed
08:15:57 <Amras> I guess I'll drop an issue on the github
08:18:16 <dminuoso> 17:14:10     Amras | The frustrating thing is that AudioFormat instances Show
08:18:36 <dminuoso> Amras: I think you're confusing AudioFormat with AudioSpec
08:18:38 * hackage tmp-postgres 1.19.0.1 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.19.0.1 (JonathanFischoff)
08:18:56 <Amras> I want to extract the audioSpecFormat, which is of type AudioFormat
08:19:25 <Amras> AudioFormat instances show, so I'd like to `show (audioSpecFormat mySpec)`
08:19:38 <Amras> that's what I was trying to say
08:37:32 <tom__> Does a data constructor take a parameter where the parameter is a type, whose value is applied. Or is the type applied.
08:37:52 <glguy> constructors don't necessarily take parameters
08:38:26 <glguy> If this helps: functions "are applied to" arguments
08:38:32 <Cale> tom__: When you're declaring data constructors in a data declaration, you list the types of the arguments to the constructor
08:38:40 <dminuoso> I just realized we lied to Amras..
08:38:58 <dminuoso> In his case he could have scrutinized on the constructor. The existential would be thrown away anyway, so he could just grab it
08:39:03 <Cale> But everywhere else, data constructors are applied to values of the appropriate types
08:39:37 <dminuoso> tom__: It might be helpful to specify data types using the GADTSyntax extension. It's just a visually, a bit more verbose/explicit way of declaring data constructors
08:39:37 <tom__> Cale: Great thanks
08:39:41 <glguy> dminuoso: Oh, can he write:  case x of AudioSpec { audioFormatSpec = x } -> ?
08:39:54 <dminuoso> glguy: Yes. case x of AudioSpec { audioFormatSpec = x } -> show x
08:40:07 <dminuoso> glguy: Reason is that `x` is just a phantom type to AudioFormat
08:40:41 <dminuoso> Err. Not x, but you hopefully know what I meant
08:42:21 <bahamas> why does concatMap exist? isn't it the same as concat $ fmap func foldable?
08:43:08 <dminuoso> bahamas: Because its a commonly used function?
08:43:27 <dminuoso> bahamas: But really, concatMap has a special implementation for performance.
08:43:55 <bahamas> dminuoso: can you give me an example of usage? I'm genuinly curious about the context this occurs in
08:44:04 <bahamas> ok, implementation for performance makes sense
08:44:27 <t7> has anyone read 'Complete and Easy Bidirectional Typecheckingfor Higher-Rank Polymorphism' ?
08:44:32 <dminuoso> bahamas: It's the implementation for >>= for instance Monda []
08:45:09 <dminuoso> bahamas: So it sort of gives you non-determinism, in which a function can chose to collapse a choice, produce another choice, or multiple choices..
08:46:16 <bahamas> dminuoso: that function being (a -> [b])?
08:46:26 <dminuoso> bahamas: Right.
08:46:39 <bahamas> what does it return when it collapses a choice, []?
08:46:51 <dminuoso> bahamas: Try it out.
08:47:18 <bahamas> dminuoso: I'm asking, because your sentence is a bit over my head
08:47:32 <jared-w> concatMap has connections to category theory and other aspects of the ecosystem so there's deeper reasons beyond it being just an alias for concat $ fmap func foldable
08:47:58 <dminuoso> bahamas: It makes it disappear.
08:48:12 <jared-w> bahamas: the way you implement non-determinsm with lists is you represent every possible option as a list of results
08:48:14 <bahamas> jared-w: ok, I see. this is a higher level abstraction
08:48:30 <jared-w> so "choose a coin toss" is represented (nondeterminstically) as [Head, Tail]
08:48:39 <dminuoso> bahamas: Imagine we were writing a naive chess computer that, for each move, determines what moves it could do next.
08:48:49 <bahamas> dminuoso: ok, to me that means that that's the case when the function returns []
08:49:13 <jared-w> and then "flip a coin twice" is [ [Head, Head], [Head, Tail], [Tail, Head], [Tail, Tail] ]
08:49:33 <jared-w> and so on
08:50:26 <jared-w> that's really the only connection to non-determinism. You can use concatMap and lists for deterministic behavior as well and that's a more common use for most.
08:50:53 <ski> > replicateM 2 [0,1]
08:50:55 <lambdabot>  [[0,0],[0,1],[1,0],[1,1]]
08:51:36 <bahamas> jared-w: can you give me a short definition of non-determinism in this context? I know it's used in connection with probability, but I would find it hard to explain it or give any examples of it
08:51:38 * hackage tmp-postgres 1.20.0.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.20.0.0 (JonathanFischoff)
08:52:41 <dminuoso> Strictly speaking it's not really true though.
08:52:41 <dminuoso> Because lists have an order.
08:52:41 <dminuoso> So there's a tiny bit more than non-determinism going on
08:53:06 <jared-w> right. You'd want to use sets in theory but they're very inconvenient compared to lists in haskell
08:53:10 <dminuoso> bahamas: List comprehensions are syntax sugar around the Monad interface of [] by the way. :)
08:53:44 <dminuoso> (There's some extra bits, but we can gloss over that)
08:54:14 <TimZele> anyone know why this shows error: justVowels c = if c `elem` "aeiou" then Just c else Nothing
08:54:23 <TimZele> when I try an eval justVowels "f"
08:54:53 <boxscape> % justVowels c = if c `elem` "aeiou" then Just c else Nothing
08:54:53 <yahb> boxscape: 
08:54:53 <jared-w> bahamas: non determinism in this context means representing a non-determinstic function as all possible answers gathered in a list
08:54:53 <dminuoso> % :t "f"
08:54:54 <yahb> dminuoso: [Char]
08:54:57 <dminuoso> TimZele: ^-
08:54:59 <boxscape> % :t justVowels
08:54:59 <yahb> boxscape: Char -> Maybe Char
08:55:15 <jared-w> so a coin toss is represented non-deterministically by [Head, Tail] (all possible results of the function "tossCoin")
08:55:47 <dminuoso> Of course the meaning of the word *possible* depends on the context.
08:56:27 <bahamas> jared-w: ok, I'm with you so far
08:57:02 <bahamas> TimZele: what's the error?
08:57:11 <jared-w> So if I want to ask the question "is this coin biased or fair" I might want to flip it 100 times and see if the number of heads/tails is roughly 50% or so
08:58:59 <jared-w> In a imperative language I'd probably do something like ` for (1..=100) { let result = coin.toss(); results.push(result); } if ( -- amount of heads > 75% or amount of tails > 75% -- ) return "coin is biased"`
08:59:06 <tom__> Surely possible only has one meaning
08:59:20 <jared-w> (where 75% is arbitrarily chosen threshold)
08:59:27 <tom__> In any given simulation of the universe an event is possible if it can occur
08:59:27 <bahamas> jared-w: right
09:00:13 <jared-w> You can do this in haskell too, and it would require IO for coin.toss to work. Or you can say "well a coin toss is [Head,Tail]" and then say `let tosses = replicateM 100 tossCoin`
09:00:42 <tom__> It would only require IO for the coin toss to be fair :P
09:00:59 <tom__> coinToss = const Heads
09:01:10 <jared-w> heh, good point
09:01:36 <tom__> Sorry haha
09:01:39 <jared-w> and then you can go through all of the "universes" and see if the coin was fair or not
09:01:50 <jared-w> > replicateM 2 [0,0] -- biased coin
09:01:52 <lambdabot>  [[0,0],[0,0],[0,0],[0,0]]
09:01:57 <jared-w> > replicateM [0,1] -- fair coin
09:01:59 <lambdabot>  error:
09:01:59 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘[Integer]’
09:01:59 <lambdabot>      • In the first argument of ‘replicateM’, namely ‘[0, 1]’
09:02:06 <jared-w> > replicateM 2 [0,1] -- fair coin
09:02:08 <lambdabot>  [[0,0],[0,1],[1,0],[1,1]]
09:02:52 <dsal> > let hund = take 100 (randomRs (False, True) (mkStdGen 104)) in M.fromListWith (+) $ map (,1) hund
09:02:54 <lambdabot>  fromList [(False,55),(True,45)]
09:02:57 <bahamas> jared-w: in the case of `replicateM 100 tossCoin`, I assume it's `tossCoin`'s responsability to use a random number generator, right?
09:03:06 <jared-w> "oh look the number of heads/tails is roughly equal, it's fair". Rather than having to do some weird convoluted nesting of maps and loops or whatever, the list monad lets you write code like what dsal wrote
09:03:31 <jared-w> bahamas: that's the magic of representing a non-deterministic function as a list. You just need to have that list be "all possible results"
09:04:16 <jared-w> so a fair coin can return [Head, Tail], a biased coin can be [Head, Head], and you can represent another biased coin as [Head, Head, Head, Tail] (where this coin is 75% biased to return head vs tail)
09:04:21 <jared-w> no IO required :)
09:05:20 <jared-w> if you use do notation you can write code that looks very much like "do non-deterministic result several times"
09:17:00 <bahamas> jared-w: there's some subtlety here that I'm missing. I mean, I understand that you hold all possible outputs of a function in a list: [0, 1] for an unbiased coin, [0, 0] for a biased one. as far as I can see, `replicateM x list` returns a list of permutations (combinations?) of length x with all elements of list
09:18:42 <bahamas> in the end, I assume you concat all the lists and count how many times you got 0, how many times you got 1 and then decide if the original list represented a fair coin or a biased one
09:19:56 <jared-w> pretty much. I'm looking for a nice article that lays this out; I remember reading one a while ago but can't find it
09:21:44 <dsal> :t replicateM
09:21:46 <lambdabot> Applicative m => Int -> m a -> m [a]
09:22:18 <dsal> replicateM just gives you n replicas of an action.
09:22:32 <dsal> % replicateM 3 $ putStrLn "hi"
09:22:33 <yahb> dsal: hi; hi; hi; [(),(),()]
09:24:21 <dsal> I think the confusion is the list monad intuition takes a bit of time to grok.
09:24:54 <jared-w> https://gist.github.com/danidiaz/cfc576640b6680cd23db0d06b8cdd0a8
09:25:02 <dminuoso> I just forced that idea into my head that in some sense `[A, B, C]` is "A, B and C" simultaneously. You just dont know which.
09:25:20 <dminuoso> Sort of in a handwaving, quantum mechanical sense of superposition.
09:25:36 <jared-w> https://blog.jle.im/entry/unique-sample-drawing-searches-with-list-and-statet
09:25:36 <EvanR> it's all of A B and C simultaneously
09:25:46 <bahamas> dsal: ok. and that action can give you a permutation of a list or it can print a string
09:26:14 <bahamas> still, I don't understand how in the case of giving you a permutation it can somehow remember previous permutations
09:26:18 <jared-w> Yeah. The way I think about it is that you use lists to draw out a state tree where each action forks the possibilities and creates new branches in the state space
09:26:20 <bahamas> at least that's what it looks like
09:27:07 <jared-w> so if I did replicateM 2 flipCoin I have [0,1] as flipCoin which is the search space (not state, m'bad) of all possible coin flip results of a fair coin
09:27:27 <dminuoso> bahamas: >>= lets you analyze each "possible result" and then replace it with nothing, or 1+ other results. Just like a chess computer could anayze a move, and then decide not to follow that strategy, or what other moves it could do following that.
09:27:40 <dminuoso> *follow that move
09:27:47 <jared-w> and the replicateM is equivalent to do { x <- flipCoin; y <- flipCoin; return [x, y]}
09:28:05 <dsal> replicateM 2 specifically.
09:28:20 <dsal> > replicateM 1 [0,1]
09:28:22 <lambdabot>  [[0],[1]]
09:28:39 <jared-w> (right). Which results in [ [0,0] , [0,1], [1,0], [1,1] ] which, when drawn as a tree, each path is equivalent to every possible choice of flipping a coin
09:28:58 <dsal> > replicateM 3 [0, 1]
09:29:00 <lambdabot>  [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
09:29:26 <jared-w> coin < [ head < [head, tail], tail < [head, tail] ] -- shitty ascii tree
09:30:30 <jared-w> the "monad" bit of the list monad is only immediately practical for do notation syntax sugar to save you the trouble of constructing increasingly nested lists and building trees tediously
09:31:02 <EvanR> it saves you from writing concatMap everywhere
09:31:23 <EvanR> and enclosing some things in a [ ]
09:31:39 <EvanR> which is what return and >>= are
09:31:53 <EvanR> return and join
09:32:42 <jared-w> https://gist.github.com/danidiaz/cfc576640b6680cd23db0d06b8cdd0a8#file-nqueenslistsearch-hs-L33  like this line 33 to line 40 can be written as do { board1 <- putAnotherQueen [initialState]; board2 <- putAnotherQueen board1; ... }
09:33:13 <jared-w> so it feels like you're writing a non-deterministic "put the queen where it goes" in a declarative manner
09:33:18 <dsal> or  replicateM 8 putAnotherQueen
09:34:19 <bahamas> ok. at least I understand that it has something to do with representing all possible outcomes and their probabilities
09:34:21 <jared-w> right. The do notation isn't magical, it's just that the combination of it along with how the list monad works makes it very suitable for being able to write code "as if" it's "truly" non-deterministic
09:34:27 <bahamas> but something is still fuzzy and I can say what
09:34:38 <bahamas> thank you for trying to clarify it though
09:35:27 <jared-w> oneOf [] = []; oneOf (x:xs) = (x,xs) : map (\(y,ys) -> (y,x:ys)) (oneOf xs) -- this is a "non-deterministic" way to write "pick some element from a list"
09:35:29 <EvanR> non-deterministic meaning having possibly zero or more than 1 result
09:35:36 <EvanR> rather than random
09:36:54 <jared-w> all it does is return all possible ways to grab an item from a list. But with the list monad you can use it like do { x <- oneOf [1..5]; {- everywhere in here you can pretend x is "some number in 1..5" -} }
09:37:21 <EvanR> oneOf :: [a] -> [a]; oneOf xs = xs :)
09:37:27 <fosskers> Morning
09:37:52 <fosskers> Does anyone know where the GHC User Guide files are hosted?
09:38:01 <jared-w> er, the type of oneOf in the gist (where I took that from) is `oneOf :: [Int] -> [(Int,[Int])]`
09:38:05 <fosskers> I can't seem to find them in GHC's gitlab repo.
09:38:29 <EvanR> ah, you removed the item from a list
09:39:11 <jared-w> In a functional logical language like Curry with "real" non-determinism, I can write oneOf like this:  `oneOf [] = []; oneOf (_ ++ [x] ++ _) = x`
09:40:09 <jared-w> actually, skip the first pattern, you want oneOf to fail on an empty list in Curry
09:40:37 <EvanR> > let f xs = do{ i <- [0..length xs - 1]; [(xs!!i, deleteAt i xs)] } in f "abcd"
09:40:39 <lambdabot>  error:
09:40:39 <lambdabot>      • Variable not in scope: deleteAt :: Int -> [a] -> b1
09:40:39 <lambdabot>      • Perhaps you meant one of these:
09:40:54 <EvanR> really
09:40:58 <jared-w> lol
09:41:13 <bahamas> speaking of GHC, anyone know where I can report this documentation issue? `infinite'` is referenced here, but the formatting is wrong and the function is missing http://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#g:17
09:41:20 <bahamas> looking at the source, I can see it there
09:42:20 <jared-w> honestly the lowest effort method to report it is probably just on github. Ah, they don't have issues open on github, nvm.
09:49:34 <jared-w> > let f xs = do { i <- [0..length xs - 1]; [(xs!!i, take i xs ++ snd (splitAt (i+1) xs)] } in f "abcd"
09:49:36 <lambdabot>  <hint>:1:86: error: parse error on input ‘]’
09:49:54 * jared-w *flips table*
09:52:13 <EvanR> wth is there no deleteAt
09:52:25 <EvanR> yet we have its dual !!
09:54:09 <int-e> > drop 3 [0..10]
09:54:11 <lambdabot>  [3,4,5,6,7,8,9,10]
09:55:58 <jared-w> > let deleteAt n xs = take n xs ++ drop (n+1) xs in deleteAt 3 [1..5]
09:55:59 <lambdabot>  [1,2,3,5]
09:56:19 <jared-w> for some reason that doesn't actually exist in the prelude anywhere...
09:56:57 <jared-w> but we have splitAt
09:57:03 <EvanR> yeah that should exist, but should probably be implemented a little better
09:57:20 <EvanR> splitAt almost works
09:57:45 <int-e> :t Data.Sequence.deleteAt
09:57:46 <lambdabot> Int -> Seq.Seq a -> Seq.Seq a
09:57:56 <EvanR> fancy
09:58:29 <jared-w> yeah I would never implement it like that in a library. No reason to traverse twice
09:59:59 <jared-w> the thing that's funny is Data.List has delete, insert, and a bunch of indexing stuff, but no deleteAt. Wonder how that got missed for so long
10:00:43 <glguy> I think it's missing because if you're doing that you should use a different data structure generally
10:01:27 <int-e> Yes, Data.List is an odd mix. It has too many random access functions to really discourage that kind of list usage, but its coverage is not complete.
10:01:39 <EvanR> yes well
10:02:26 * EvanR pulls out !! in an evidence bag and drops it on the table
10:02:35 <jared-w> glguy: I mean, I agree in principle, but we already have a large amount of "treat list like a set, like an array, like a map" functions in Data.List. Seems almost like we should rip those out rather or keep adding to the pile
10:02:57 <int-e> EvanR: That's part of my evidence as well :)
10:03:21 <jared-w> tbh the dream, imo, is better support from the ecosystem and maybe the language itself for syntactically writing heterogeneous structures, or just non lists in general
10:03:52 <EvanR> is this dream clojure? :)
10:04:03 <EvanR> what a weird dream
10:04:06 <int-e> And honestly I'm using that functionality quite a bit too... either because I know that the lists are short, or because I'm lazy and know that performance doesn't matter.
10:04:08 <glguy> I don't think there's a requirement that everything is all-or-nothing
10:04:35 <EvanR> yeah don't fear the short lists
10:04:51 <int-e> (The latter assumption is dangerous for anything than one-off code, but I have a lot of one-off code.)
10:05:28 <EvanR> "i need an advanced datastructure that supports X and Y efficiently" "how big is this data structure really going to get?" "maybe 10 to 20 my dude"
10:05:31 <glguy> I might write deleteAt like this: https://hastebin.com/turamavohe.hs
10:05:34 <siraben> Speaking of lists, I particularly like Okasaki's random access lists.
10:05:35 <jared-w> lol no, but inspiration can certainly be taken. Maps are terribly inconvenient to write out, literally any heterogeneous structure is a nightmare to write out, and everything but lists are definitely second-class citizens. Even tuples feel second-class at times compared to lists (until you turn on a few language extensions)
10:06:22 <int-e> wait, why should tuples feel anything like lists?
10:06:25 <jared-w> EvanR: but if I don't blow my asymptotic advantage out of the water with gigantic constants, how am I ever going to get leet at hackerrank?
10:06:58 <jared-w> int-e: they shouldn't. But lists have a _lot_ of syntactical help to make them feel very natural. Tuples have a lot, but not as much, and literally everything else feels like squinting at the problem sideways and pretending to have what you want
10:07:13 <EvanR> 2-tuples is all you need :)
10:07:28 <int-e> EvanR: is that a cons-tructive comment?
10:07:39 <EvanR> hmm
10:07:41 <jared-w> (,x) = splitAt 2 [1..5] -- syntax error
10:07:59 <EvanR> not the list version
10:08:01 <EvanR> er lisp
10:08:04 <int-e> EvanR: You also need a sum type to be Generic.
10:08:47 <EvanR> as far as 3+-tuples, products, records, hlist, trees, you only need 2 tuple
10:08:54 <glguy> % [('a', True), ('b', False)] :: Data.Map.Map Char Bool -- yay, now it's easy
10:08:54 <yahb> glguy: fromList [('a',True),('b',False)]
10:09:11 <glguy> Didn't even have to write "fromList"
10:09:21 * jared-w squints suspiciously
10:09:22 <EvanR> but i should have restricted to just n-tuples
10:09:26 <jared-w> is that with overloaded lists enabled?
10:09:33 <glguy> one would hope
10:10:46 <jared-w> figured :) it's certainly an improvement. Though not a blanket win; I ran into a lot more type inference errors with that than with OverloadedStrings last time I used it. Not quite sure why
10:11:56 <jared-w> As far as I'm aware, you can't do ['a', "a", True] :: '[Char, String, Bool] (or whatever heterogeneous list syntax you're using)
10:13:05 <glguy> Fortunately you need heterogeneous lists less often than deleteAt
10:13:28 <jared-w> and I don't think there's an overloadedTuples allowing you to do the equivalent? It's not a huge problem, but I ran into it with libraries like type-of-html where you end up having to write ( p_ "txt" # p_ "txt" ) and writing nested trees with that thing is /horrible/. Especially if you're trying to use any sort of auto formatting
10:13:38 * hackage finitary-derive 2.2.0.0 - Flexible and easy deriving of type classes for finitarytypes.  https://hackage.haskell.org/package/finitary-derive-2.2.0.0 (koz_ross)
10:14:14 <jared-w> Right. But with -XKitchenSink getting closer and closer to -XDependentTypes I'd imagine it'll crop up more and more
10:15:02 <jared-w> At the least, it would be very nice to not have 12 different combinators for each different library that tries to solve HLists, extensible records, or type level whatever over and over :p
10:15:04 <EvanR> throw the baby in the bathwater, matrix syntax that works for any Naperian functor
10:15:28 <siraben> jared-w:  what does -XKitchenSink do?
10:15:32 <jared-w> Yes! While we're at it, why not force Haskell to be written in 3D syntax?
10:15:40 <EvanR> o_O
10:15:56 <shapr> I vote yes
10:15:58 <jared-w> siraben: it's a joke. -XKitchenSink doesn't do anything. It "stands for" the 15-25 different language extensions people tend to turn on when doing type level stuff in Haskell
10:16:10 <EvanR> oh is that a reference to "The Matrix" fine film
10:17:19 <siraben> jared-w: Heh, how much longer until we get dependent types? All these hacky extensions...
10:17:32 <glguy> dependent types aren't an ideal to aspire to
10:19:15 <jared-w> siraben: DataKinds FlexibleContexts GADTs LambdaCase PolyKinds RankNTypes ScopedTypeVariables TypeApplications TypeOperators TypeFamilies that's the usual list, +/- a few others.
10:20:03 <srid> So there is a new chat site on the block that purports to do better than Slack, while supporting forum like features (which is the most interesting feature IMO): https://funprog.zulipchat.com/#narrow/stream/201385-Haskell
10:20:20 <srid> (It is open source, and gets unlimited message history)
10:20:31 <jared-w> They're a powerful tool in the right place. Often overused, and not nearly enough research has gone into making them gradually available. One big gripe of mine is that you can't really "lower" a dependently typed API, so you either get _all_ of the safety or you rewrite the code with none of the safety
10:20:38 <siraben> glguy:  Agreed, but a quote from "A tutorial implementation of a dependently typed lambda calculus"
10:20:40 <siraben> "Most functional programmers are hesitant to program with dependent types. It is said that type checking becomes undecidable; the type checker will always loop; and that dependent types are just really, really, hard.  The same programmers, however, are perfectly happy to program with a ghastly hodgepodge of complex type system extensions. Current Haskell implementations, for instance, support generalized algebraic data
10:20:40 <siraben> types, multi-parameter type classes with functional dependencies, associated types and type families, impredicative higher-ranked types, and there are even more extensions on the way. Programmers seem to be willing to go to great lengths just to avoid dependent types."
10:21:04 <siraben> jared-w: Wow, much extensions
10:21:17 <jared-w> (which makes them often brittle, not extensible, and not reusable). In fact, dependent types have a nasty habit of leaking their implementation details into their API
10:21:38 <glguy> siraben: There's a mistake there that these other extensions are merely making up for the absense of dependent types and also that all of these extensions should be casually used as well
10:21:50 <jared-w> Like, depending on how you implement indexing and natural numbers changes how the "head" function on a 'indexed list' works
10:22:20 <svipal> "great lengths just to avoid dependent types" is not really true, though I suspect that' s tongue in cheek
10:22:47 <siraben> jared-w:  Wow, implementation leak indeed.
10:22:58 <svipal> agreed with glguy also.
10:23:12 <jared-w> svipal: from the perspective of implementing GHC, it makes a lot of sense. One of the biggest motivations behind implementing dependent types in GHC itself is so that you stop having a bunch of weird hacks in the type checker and the core language simplifies a lot.
10:23:28 <svipal> yeah but that 's upside down
10:23:39 <jared-w> On the other hand, it's _very_ nice to have things like GADTs that you can turn on in one or two places and get some safety without having to go all the way to dependent types
10:23:42 <siraben> glguy:  Right. It's sort of a joke, as I read it.
10:24:00 <glguy> I think there are two general camps: the camp of people making software and trying to keep things simple, and the camp of trying to push limits of what's possible to encode for its own sake
10:24:16 <siraben> (technically the paper's implementation of dependent types is unsound, as a :: A, A :: *, and * :: * (the bad step) when it should be * :: *1, *1 :: *2 ...
10:24:39 <glguy> both are fun camps to be in, but have different objectives
10:24:54 <jared-w> siraben: it does that on purpose. Because Haskell is turing complete its type system is already unsound
10:25:00 <siraben> GADTs are nice. But I'm not so sure of what it can let me express that normal data declarations can't?
10:25:23 <EvanR> a technically unsound dependent type system isn't necessarily bad
10:25:26 <jared-w> so there's no point in implementing an infinite tower of universes and then having to implement universe polymorphism and all those other fun stuffs that Agda deals with
10:25:28 <EvanR> if it simplifies things
10:25:41 <siraben> Right. Or Coq, even.
10:25:51 <EvanR> it's bad if you were trying to rewrite the foundation of math
10:25:55 <jared-w> GADTs let you gain type information by pattern matching
10:26:00 <siraben> I was trying to do some proofs about infinite lists in Coq, they're not terribly nice things to work with
10:26:16 <svipal> GADTs are mad fun
10:26:20 <siraben> All Coq programs must terminate, so you can't do something like filter an infinite list because you could get (filter even? (cycle [1]))
10:26:22 <glguy> siraben: I have a couple examples of benefits from GADTs if you're interested
10:26:44 <siraben> glguy:  Yes, I'm interested
10:26:46 <glguy> siraben: https://github.com/glguy/breadth-first-parser-combinators/blob/master/src/Parser/State.hs#L46-L52 uses GADTs to keep track of if my parser state needs to commit before it is done
10:27:08 <jared-w> GADTs makes it possible to write a function like this: `f = \case { A -> "hey"; B -> 3; }` in haskell
10:27:11 <svipal> they can really help  organize the way your recursive data is structured
10:27:42 <glguy> siraben: and I have a configured schema library where the GADT is used to link the types of data to the definition of the schema: https://github.com/glguy/config-schema/blob/master/src/Config/Schema/Types.hs#L58-L88
10:27:42 <siraben> glguy:  Is Nat the type level natural numbers?
10:27:52 <jared-w> *squints* ... probably. I might've fucked up the syntax slightly. But the general idea is there
10:27:53 <svipal> also, really cool to be able to pass class constraints depending on the constructor 
10:27:55 <EvanR> jared-w: dependent on the audience that either excites them or horrifies them :)
10:27:56 <glguy> siraben: yeah, defined below
10:28:29 <jared-w> EvanR: who doesn't want php-in-haskell? :p
10:28:43 <svipal> I want PHP at the type level.
10:28:59 <siraben> Ok so there is limited support for dependently-typed things, it seems, just not the whole schpeel
10:29:17 <jared-w> You can actually encode everything in Haskell at the type level with the singletons library
10:29:38 <jared-w> There's a proof floating around of this. It's ugly AF, but *technically* we have full support for dependent types now
10:29:41 <siraben> Type-level Haskell is something I haven't doved too deep in, any recommendations?
10:29:44 <lyxia> there's two meanings to "sound" here, I think? does (Type :: Type) allow you to implement unsafeCoerce?
10:29:52 <siraben> s/doved/dived
10:29:56 <EvanR> of all the stuff haskell can do, dependent types only technically covers some of it, and not necessarily in a convenient way. You also need extra bells and whistles to make use of dependent types conveniently. So it's not a panacea
10:30:26 <jared-w> https://thinkingwithtypes.com/ siraben  Sandy's book is _the_ comprehensive resource on it
10:30:39 <jared-w> alternatively just read about 200 variously scattered blog posts and half of the compiler source code /s
10:31:01 <siraben> glguy:  Where did the idea of breadth-first parser combinators come from?
10:31:20 <siraben> Oh, is Sandy isovector?
10:31:23 <jared-w> yeh
10:31:59 <glguy> From looking at ReadP which is mostly breath first except for how it implemented biased choice
10:32:06 <jared-w> That's why I changed all of my online names to my name. I keep seeing it confuse people lol.
10:32:08 <maganalope> I have a `Maybe (IO [String])`. Can I turn this into an `IO (Maybe [String])`?
10:32:31 <lyxia> maganalope: sequence?
10:32:53 <siraben> Wow, all these chapters in Thinking with Types. How long does it even take to learn all of Haskell?
10:33:24 <glguy> All of GHC? Probably a long time
10:33:26 <EvanR> jared-w: our leetness is so minimal
10:33:45 <jared-w> None of this is required for Haskell. Most people have long term professional careers without even thinking about `coerce` much less literally any of the stuff in that book
10:34:03 <maganalope> lyxia: I am new and stupid, gonna need a bit more
10:34:21 <jared-w> To be clear: Thinking with Types is two things: a) how to think with types, b) how to translate that to the bullshit you have to do in haskell to get anything done with "dependent-like" types
10:34:26 <jared-w> (which people appropriately call "hasochism")
10:35:02 <siraben> Is the type level strong enough to state theorems like forall a b : Nat, a + b = b + a?
10:35:12 <svipal> `let b :: Maybe (IO [String])  = Just $! return ["ab"]`
10:35:15 <jared-w> If you want a very approachable and pedagogical approach to "pure" dependent typed programming, edwin's book https://www.manning.com/books/type-driven-development-with-idris uses Idris which is excellent for this
10:35:24 <svipal> `sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)`
10:35:44 <jared-w> and I'd urge you to go that route over Sandy's book if all you want is to learn dependent types. If you want to apply that knowledge to Haskell, then ready Sandy's book
10:35:51 <svipal> try to do sequence b
10:36:01 <siraben> Thanks jared-w 
10:36:10 <jared-w> siraben: yes. Idris can do it nicely, Haskell... can
10:36:58 <siraben> Most of the dependent type stuff I've done is in Coq, some Agda, so not too much "practical" applications yet
10:38:03 <jared-w> Eh that's about as practical as it gets, quite honestly
10:38:19 <koz_> Seconding Sandy's book.
10:38:30 <koz_> It has useful stuff in it even if you're _not_ interested in dependent typing per se.
10:38:32 <jared-w> Because of how dependent types "leak" their API, you're never going to write a dependently typed library that's as reusable as a "normally" typed library
10:38:56 <siraben> jared-w:  Wow, I'd be interested in a proof of the commutative property in Haskell
10:39:08 * hackage morpheus-graphql 0.7.1 - Morpheus GraphQL  https://hackage.haskell.org/package/morpheus-graphql-0.7.1 (nalchevanidze)
10:39:16 <EvanR> jared-w: that's some serious fear uncertainty and doubt!
10:39:19 <maganalope> Wow thanks! think that's what I need. I was hoogling specifically for IO. 
10:39:39 <EvanR> "I can't imagine how to write a reusable library with dependent types"
10:40:01 <mycroftiv> dependent types are a superset of non-dependent types so you are never obligated to impose any additional obligations. often 'leaks' are precisely the point, because the goal is actually to bring information from different layers in contact to maintain an invariant
10:40:23 <maganalope> However that has made `stack run` start to hang on `registering library for...`, any ideas?
10:40:28 <jared-w> Right, but if you drop that information temporarily you don't get that information back for free
10:41:10 <mycroftiv> completely agreed, and some kind of 'implicit proof pipelining' that doesnt require so much manual ceremony would be greatly appreciated by most dep types people id imagine, for practical coding purposes
10:41:39 * hackage skylighting-core 0.8.3 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-core-0.8.3 (JohnMacFarlane)
10:41:54 <jared-w> So if you have a library for length indexed lists you're forced into <> being the ZipList implementation rather than the Concat implementation. You can drop the length information and go from `List Nat -> List` and then use <> but then you have to get the length all over again and prove everything you just proved
10:42:09 <mycroftiv> if you study things like 'how to keep your neighbors in order' by conor, you can see some really nice ideas though that help with things like this
10:42:38 * hackage skylighting 0.8.3 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-0.8.3 (JohnMacFarlane)
10:43:15 <mycroftiv> https://personal.cis.strath.ac.uk/conor.mcbride/Pivotal.pdf although that paper is hardly going to make the case that dep types are nice and easy and convenient without lots of study
10:43:41 <jared-w> It gets really hairy when you want to encode anything actually useful like multiple properties. "List that is not empty and contains only primes" doesn't work with a function that only takes "nonempty list" iirc. So even just adding two "nonempty prime list"s together loses the fact that they only contain primes
10:44:37 <jared-w> I do remember seeing some haskell libraries that try to solve this some, and I'm sure conor has some good stuff on it too. There might be a solution to that that I haven't seen yet, but in general it's a very tricky problem and imo one of the biggest barriers to "really using" dependent types more widely
10:44:56 <mycroftiv> i really wouldnt say that is accurate, you can make data structures that hold multiple proof varieties. of course then you have to wrap/unwrap those data structures, but this is why we have monads and such
10:45:13 <EvanR> there's a lot of preconceptions going on there
10:45:52 <jared-w> ah okay. I was hoping the wrapping/unwrapping and proof varieties was more solved than I thought
10:46:22 <mycroftiv> the McBride paper i linked has a lot of strong ideas in it, i dont think they have been comprehensively carried out by library writers and such though yet
10:47:29 <mycroftiv> he specifically addresses the question of how we gracefully maintain our invariants without constantly writing tons of proof-boilerplate to get the data in and out and track the information, there is a lot of background context in the mathematical presentation, but the idea is to make things 'just work nicely'
10:49:08 <mycroftiv> but i agree the question of whether or not the tools to let us 'all be like McBride' can really be deployed to all the programmers not on that level (such as myself) is an ongoing deep challenge
10:51:05 <glguy> siraben: no, the type checker doesn't know that addition is commutative. There are plugins to add that kind of automation
10:52:15 <davean> ot all addition is commutative
11:01:37 <jared-w> 2 + (-2) /= (-2) + 2  -- /s
11:02:07 <jared-w> ah whoops, accidentally wrote that correctly...
11:02:18 <jared-w> it was a dumb joke anyway
11:14:09 <saml> how long do you stay at a company as a programmer?
11:14:36 <saml> do programmers switch jobs every 2~3 years until retirement?
11:15:43 <dsal> Depends on the company. heh.  I did startups for a long time.  Though the last one I started (many years ago) is still doing OK.  I've been at my next job for almost six years, though.
11:15:46 <davean> saml: yes, no
11:15:59 <davean> saml: thats not a one-size-fits-all question
11:17:01 <evelyn> It's probably an achievment to leave a startup because you wanted to and not because it went under.
11:17:40 <jared-w> It seems to be that in the current industry you'll get about a 3-5% raise per year at a company, but about a 10-20% raise per company switch. So a lot of people will switch until they're sufficiently salaried and then find a place they like and stay there. But again, depends on the person
11:17:42 <dsal> Yeah, I've done it the other way.
11:17:56 <jared-w> evelyn: heh, isn't that the truth
11:26:34 <hseg> Don't understand why after the first element, I get an infinite loop when calling spanners @Natural 2 here http://ix.io/22VN
11:27:49 <jared-w> my first suspicion is ==
11:28:54 <hseg> What I'm trying to get is the list of all lists with elements in [0..n] such that the first occurrences are sorted
11:29:16 <hseg> of course, there's infinitely many such, so I'm trying to get them by length...
11:29:30 <hseg> I think I need to go back to the drawing board with this one
11:30:35 <tsahyt> hseg: so you want all 1 element lists before all 2 element lists etc?
11:30:44 <tsahyt> I mean that'd just be [0], [1], [2], etc
11:30:45 <tsahyt> because you'd never get to the 2 element lists
11:31:41 <hseg> No, it should be [[],[0],[1],..,[n],[0,0],[0,1],[0,2],...,[0,n],[1,n],..]
11:32:20 <tsahyt> oh so n is fixed, okay
11:32:24 <hseg> Right
11:32:57 <hseg> Actually, don't even need the shorter lists... Could parametrize over length
11:36:51 <tsahyt> hseg: `allFrom l = [] : [ (x:ys) | ys <- allFrom l, x < l ]`, then `allFrom [1..n]` should give you what you want
11:36:52 <tsahyt> I think
11:36:56 <tsahyt> @let allFrom l = [] : [ (x:ys) | ys <- allFrom l, x < l ]
11:36:57 <lambdabot>  Defined.
11:37:04 <tsahyt> or how did this work here
11:37:23 <tsahyt> > takeWhile (( < 2) . length) $ allFrom [1..3]
11:37:25 <lambdabot>  error:
11:37:25 <lambdabot>      • Couldn't match expected type ‘Expr’ with actual type ‘[Integer]’
11:37:25 <lambdabot>      • In the first argument of ‘allFrom’, namely ‘[1 .. 3]’
11:37:52 <EvanR> :t allFrom
11:37:53 <lambdabot> Expr -> [[Expr]]
11:38:02 <EvanR> Expr strikes again
11:38:38 <EvanR> x is free in your function definition
11:38:45 <tsahyt> yes, that was a typo
11:39:22 <tsahyt> let allFrom l = [] : [ (x:ys) | ys <- allFrom l, x <- l ] in takeWhile ((< 2) . length) (allFrom [1..3])
11:39:25 <tsahyt>  * > let allFrom l = [] : [ (x:ys) | ys <- allFrom l, x <- l ] in takeWhile ((< 2) . length) (allFrom [1..3])
11:39:42 <tsahyt> well now I wonder how edits work on the IRC side
11:39:50 <tsahyt> > let allFrom l = [] : [ (x:ys) | ys <- allFrom l, x <- l ] in takeWhile ((< 2) . length) (allFrom [1..3])
11:39:52 <lambdabot>  [[],[1],[2],[3]]
11:39:58 <EvanR> is that was that was supposed to be
11:40:14 <tsahyt> > let allFrom l = [] : [ (x:ys) | ys <- allFrom l, x <- l ] in takeWhile ((< 3) . length) (allFrom [1..3])
11:40:16 <lambdabot>  [[],[1],[2],[3],[1,1],[2,1],[3,1],[1,2],[2,2],[3,2],[1,3],[2,3],[3,3]]
11:40:27 <tsahyt> hseg: so like that?
11:40:30 <glguy> tsahyt: This is IRC, there are no edits; you just send multiple messages.
11:41:01 <tsahyt> glguy: Yeah but I don't know how edits, which are supported in Matrix, end up going through the Matrix <-> IRC bridge.
11:41:38 <EvanR> you send <space><star><space><your updated message>
11:41:38 <glguy> they go through as noise :)
11:41:42 <EvanR> sent*
11:42:03 <hseg> tsahyt: no -- I need that the first occurrences be sorted
11:42:08 <tsahyt> oh okay, thanks for clarifying. Well that's not that bad. it just doesn't work with lambdabot
11:42:57 <EvanR> so if you edit a large paragraph, IRC people will feel the hurt
11:43:17 <tsahyt> hm, well maybe that approach can still be salvaged though
11:43:44 <tsahyt> EvanR: I'll refrain from doing so. I usually use Fractal as a client which doesn't do any of this, but I thought it'd be fun to try out riot once in a while.
11:45:33 <tsahyt> > let allFrom l = [] : [ ys ++ [x] | ys <- allFrom l, x <- l ] in takeWhile ((< 3) . length) $ allFrom [1..3]
11:45:35 <lambdabot>  [[],[1],[2],[3],[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
11:46:16 <tsahyt> hm no that doesn't work either
11:52:00 <adamCS> I'm getting a "could not deduce" compiler error when it's trying to derive some generic class.  Is there a way I can see what constraints it would need to be happy?  It's a generic deriving situation so I'm not so sure how to look for what it's missing...
11:52:44 <glguy> Put the error on a pastebin?
11:54:55 <adamCS> glguy: yep...working on it.  Pastebin says it's busy...here: https://gist.github.com/adamConnerSax/21fc100ff5bada17dbbac3269ba61720
11:55:14 <adamCS> I'l paste code also...
11:56:13 <adamCS> https://gist.github.com/adamConnerSax/0eb7344a6e28b244f8a36d9004e7a868
11:57:37 <adamCS> Could be a lot of things.  The constraint stuff in vinyl often takes me some...fiddling.  But somehow it's usually clearer what is missing.  The combo of generics and vinyl has me flummoxed here.
11:58:29 <hseg> tsahyt: Rewriting, http://ix.io/22Wb seems to work
12:16:28 <adamCS> glguy: I gotta go.  But if you have any thoughts or even hints where to look, I'd appreciate it and I'll check the history when I get back.  Thanks!
12:23:53 <glguy> adamCS: You probably need: instance (GSerializePut (Rep (F.Rec SElField rs)), Generic (F.Rec SElField rs)) => ...
12:24:08 <glguy> adamCS: You'll have to actually know the type 'rs' to use that operation
12:29:06 <gauga> hi guys! Could anyone help me with a problem? I'm new to Haskell and writing a function that counts the number of occurences of a word in a text (a list of lists). I have a function that counts the number of occurences of a word in a list, but I don't know how to get one level deeper, namely to a list of lists. Anyone who can help? Here is the
12:29:06 <gauga> function: elemCount x list = length (filter ( x == ) list)
12:33:01 <merijn> gauga: Right, so you have a function that works on a list, yes? And you want a function that works on a list of those. Does "I have a function that I want to apply to a list" start ringing any bells? ;)
12:34:24 <gauga> Hi merijn! I see what you're pointing at but I'm not sure how to write it in Haskell syntax, which I find rather confusing at this point
12:35:20 <merijn> gauga: What books/tutorial/etc. are you using?
12:36:08 <gauga> Learn you a Haskell for Greater Good
12:36:38 <merijn> Ah, yeah, that one isn't particularly good at actually teaching Haskell
12:36:47 <gauga> Any recommendations? 
12:36:58 <merijn> gauga: https://github.com/bitemyapp/learnhaskell
12:37:57 <merijn> There's also the Graham Hutton book "Programming in Haskell" and a few others
12:38:24 <gauga> Thanks! I appreciate it!
12:38:32 <wildtrees> gauga, what if you fmap or map your word count function over a list of lists, what do you get back? 
12:39:05 <merijn> wildtrees: That's what I was getting at, but if the syntax is still unclear it's probably wiser to brush up on that first
12:39:29 <wildtrees> :)
12:39:35 <merijn> gauga: There's also http://haskell-for-readers.nomeata.de/ which seems nice and comprehensive (albeit not really aimed at teaching you how to *write* haskell)
12:40:08 <adamCS> glguy:  That worked!  When you say "know" you mean that when I actually use the instance, I'll have to be using it on a specific record?  That's my use case.  I just wanted to avoid having to declare an instance for each combination of columns I might want.  Thanks!
12:40:52 <adamCS> glguy: BTW, I guess I could have guessed that but I don't really know what that instance means.  Can you explain at all?
12:41:40 <gauga> Thanks, guys! 
12:43:19 <lavalike> I feel compelled to mention the haskell wikibook too!
12:43:30 <lavalike> it's rather straightforward and fast as far as syntax goes
12:44:11 <glguy> It says the type "F.Rec SElField rs" is an instance of S.Serialize, but when you use that instance you'll get the constraints added that "F.Rec SElField rs" is an instance of Generic and "Rep ("F.Rec SElField rs)" is an instance of GSerializePut
12:44:45 <glguy> Rep is a type family that gives back a uniform generic representation of given type
12:45:11 <glguy> and GSerializePut is a class used to implement a serialization function on types of that uniform representation
12:45:34 <glguy> The Generic class has method for converting to and from the uniform generic representation of things
12:46:01 <glguy> a -> Rep a x    and    Rep a x -> a
12:46:44 <glguy> the 'x' argument doesn't matter and is an unused hack that makes some of the Generic1 stuff to overlap with the Generic stuff
13:29:39 * hackage clay 0.13.3 - CSS preprocessor as embedded Haskell.  https://hackage.haskell.org/package/clay-0.13.3 (turion)
13:47:38 <koz_> base 4.12 is GHC 8.6 right?
13:47:55 <Clint> yes
13:47:59 <koz_> Clint: Thanks.
13:48:02 * koz_ sighs.
13:49:39 <koz_> Phyx-: If I use one of your Chocolatey packages to install two GHCs side-by-side, what path do I need to feed to -w so that it picks up the version that I want? I guess a better phrasing of the question is 'where do your Chocolatey GHC packages put the binaries?'.
13:51:03 <merijn> koz_: bindists generally also install version tagged executables
13:51:23 <merijn> koz_: So if you're lucky and both install dirs are in your path you can just specifiy ghc-8.6.5 without a path
13:51:30 <koz_> merijn: Ah, so I can just give the _name_ of the executable instead of a full path?
13:51:40 <merijn> koz_: afaik, yes
13:51:46 <koz_> merijn: I'll try that, thanks.
13:51:57 <geekosaur> if we're talking cabal -w, yes
13:52:10 <koz_> merijn: Seems like that's a thing. Thanks for the suggestion!
13:53:09 <merijn> :q
13:53:18 <merijn> Whoops :p
13:53:43 <koz_> Lol, what emoji is :q? Someone trying to lick their nose?
13:53:53 <merijn> koz_: That's me trying to quit vim :p
13:54:03 <koz_> (while licking your nose)
13:54:33 <MarcelineVQ> :)~
13:54:43 <srid> For this type, `data Foo a = { bar :: a }`, and this func: `someFunc :: FromJSON a => Foo a -> Text`, I want to "case" on the type of `a`. If `a = ()`, I want to return empty text, otherwise I'd do something else (parse json). Is this possible?
13:55:34 <koz_> srid: You can't pattern match on types usually.
13:55:37 <srid> actually, it is `someFunc :: FromJSON b => From b -> Foo a`. If `b == ()`, I want to return `Foo ()`, otherwise I want to parse json and put that in `a`
13:55:42 <merijn> srid: Yes, but it will make you very unhappy
13:56:03 <srid> all I want to do is make an exception for `()`. :-) Aeson is not lenient with decoding to ()
13:56:04 <merijn> srid: Because it involves lots of Typeable and sadness :p
13:56:28 <koz_> merijn: Typeable and sadness is one approach, though the other options aren't a whole tonne better.
13:57:28 <merijn> My recommendation: Stop wanting this :p
13:58:08 <srid> actually, aeson behaves differently for `Proxy ()`. Interesting.
14:00:17 <srid> yup, `Proxy ()` worked. aeson happily decodes empty json (`{}`) into it, but it expects an array for `()`, which is rather strange.
14:21:21 <merijn> Ah, that joyous moment where my Haskell code segfaults!
14:23:25 <cocreature> merijn: that’s simon telling you that you should go to bed :)
14:23:41 <koz_> cocreature: In Comic Sans.
14:24:23 <merijn> cocreature: To be fair, it was my C code tat actually segfaulted >.>
14:25:01 <cocreature> koz_: I’m now tempted to write a patch for GHC that makes it output compiler errors via a powerpoint presentation that exclusively uses comic sans
14:25:02 <dsal> merijn: try harder!
14:25:13 <koz_> cocreature: LOL
14:25:25 <koz_> Submit it for April 1st.
14:25:33 <merijn> dsal: At segfaulting Haskell, you mean?
14:25:37 <dsal> yeah
14:25:43 <cocreature> it’s not that hard :)
14:25:52 <merijn> dsal: Clearly you have not seen my code if you think I need to try harder :p
14:25:59 <dsal> heh
14:26:02 <merijn> dsal: Most people think I should try less hard ;)
14:26:04 <cocreature> I’m mostly surprised that my Haskell code doesn’t segfault more often :)
14:26:31 <merijn> dsal: Witness my actions and despair! https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/src/Utils/Vector.hs
14:27:12 <dsal> You lost me at line 1
14:27:37 <merijn> dsal: MagicHash makes everything go faster!
14:27:46 <dsal> Oh nice!
14:28:16 <dsal> {-# LANGUAGE HugeExhaustPipe #-}
14:28:22 <cocreature> performance of Haskell code is measured in the number of magic hashes and unsafeCoerce
14:28:40 <merijn> dsal: (If you don't know what it does, it allows # to be used in identifiers which isn't allowed by regular Haskell. Many GHC primitives/unboxed stuff uses # to signify it operates on unboxed stuff)
14:29:07 <dsal> Oh right.  That's a thing I vaguely understand, but haven't worried about enough to actually use.
14:29:18 <merijn> dsal: See, for example, the import of "Int(I#)" (which imports the data constructor for Int (i.e. I#) which you can't write otherwise
14:29:23 <cocreature> we need acme-magichash that is just base but all functions have magic hashes in them even though they are not unboxed
14:30:39 <dsal> Speaking of magic, is there a useful file magic library?
14:30:46 <merijn> also plusAddr#
14:31:04 <dsal> I've got a directory with a bunch of images and other junk and I just want to identify them.
14:35:07 <koz_> dsal: What do you mean by 'identify' here?
14:35:15 <koz_> I may be of some assistance given the hell I've been in for the past few days.
14:35:38 <merijn> koz_: He mentioned filemagic, so presumably he wants something like libmagic
14:35:38 * hackage regex-tdfa 1.3.1.0 - Pure Haskell Tagged DFA Backend for "Text.Regex" (regex-base)  https://hackage.haskell.org/package/regex-tdfa-1.3.1.0 (HerbertValerioRiedel)
14:35:54 <koz_> merijn: Oh, _that_ kind of magic.
14:36:07 <koz_> Then nope, I'm not really who you need. :P
14:36:09 <dsal> koz_: Yeah, lots of unidentified files that are a backing store for something.
14:36:19 <dsal> heh.  I could probably just use an image library or something, since I mostly want images.
14:36:36 <dsal> I could almost do this in sh, except the file command is dumb.
14:37:40 <adamCS> glguy: That worked! (Adding the GSerrializePut instance).  Had to go for a bit but finally got to try it.  That will be a huge help.  I'm always using it ina concrete context but it would be  a pain to have to declare instances each time, especially since with vinyl that sometimes means figuring out long type-level-lists.  THis way I can just serialize or deserialize without needing that. Thanks again!
14:40:26 <dsal> Look how dumb file is.  So close... https://www.irccloud.com/pastebin/sBBxae8H/file.txt
14:42:07 <Axman6> It would take you literally hours to answer "JPEG image data, JFIF standard 1.01, aspect ratio, density 1x1, segment length 16, baseline, precision 8, 4032x3024, frames 3"
14:44:15 <dsal> If file's --extension worked consistently, I would've been done with this a long time ago.  All I want to know is which of these blobs are images.  There's probably a video or two in there.
14:44:53 <merijn> dsal: Oh, if only things were so easy :p
14:45:41 <merijn> PNG, for example, is actually a weird is frame based encoding that allows all sorts of random proprietary/custom chunks to be interweaved 
14:45:50 <dsal> If there's one thing I've learned about easy things, they're all pretty hard.
14:45:59 <merijn> Word
14:46:55 <merijn> The Programmers’ Credo: we do these things not because they are easy, but because we thought they were going to be easy
14:47:17 * zmv claps
14:47:38 <MarcelineVQ> 'we do these things not because we need to, but because the other guy didn't do it quite right'
14:48:36 <Spock> you are about to embark on an annoying crusade
14:49:01 * dsal starts stack project to add extensions to files
14:49:03 <merijn> MarcelineVQ: Trigger warning :(
14:49:27 <merijn> MarcelineVQ: You're reminding me of my day job >.>
14:50:13 <dsal> merijn: My current day job is writing up a description of how things went wrong and affected users because of a thing the other guy didn't do quite right.  And also me and what I'm going to get someone to do about it.
14:50:27 <dsal> I'm so meta even this acronym...
14:51:09 <merijn> dsal: My current day job is working with Fortran 77 written by non-programmer scientists that's build on top of for the past several decades and FPGA tooling... >.>
14:51:16 <dsal> That's amazing.
14:51:30 <MarcelineVQ> merijn: now's your chance, move them to julia
14:51:56 <merijn> MarcelineVQ: hah, you're funny :p
14:53:44 <merijn> Thankfully I have a good therapist
14:54:45 <koz_> How do I ask cabal to download a package's source but not build it?
14:54:50 <MarcelineVQ> isn't that right dr. bobbles? *pats a sock full full of rice with a drawn face on it*
14:55:02 <merijn> MarcelineVQ: http://files.inconsistent.nl/panther-princess.jpg :p
14:55:14 <MarcelineVQ> koz_: upack iirc
14:55:39 <merijn> cabal fetch
14:55:50 <merijn> or cabal get
14:56:53 <MarcelineVQ> *unpack
15:02:32 <psygate> Is there a way to sum all previous elements of a list and "append" them on a function with argument?
15:03:14 <lavalike> what does "append them on a function with argument" mean?
15:03:39 <lavalike> > scanl (+) 0 [1..10] -- something like this?
15:03:41 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55]
15:04:06 <psygate> like scanl, but with a single argument function
15:04:30 <merijn> Are you thinking of iterate?
15:04:43 <psygate> I have a function A that generates an infinite list step by step, "yielding" each element in order.
15:04:50 <psygate> like  [1..]
15:04:54 <merijn> > take 10 $ iterate f x :: [Expr]
15:04:56 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
15:05:27 <psygate> now i have a function g x that should sum all previous elements of my list and yield each element in order.
15:05:35 <psygate> basically fibonacci but with an argument
15:08:32 <psygate> scanl seems to be the answer i was looking for, thanks
15:16:55 <Phyx-> koz_: just use the full version number in -w, e.g. -w ghc-8.0.1 
15:42:05 <dsal> merijn: Man, that thing about the png is true.  At least with hip, it's kind of annoying to have to make code that's typesafe by color space when I don't care about color space.
15:42:42 <Polarina> Why would you not care about the color space?
15:44:12 <crestfallen> hi I'm getting a missingMethod error, no explicit implementation for `fmap`. wondering what I'm missing..       https://termbin.com/bm4x
15:44:34 <dsal> Polarina: Because all I care about is whether this is a valid PNG.
15:44:44 <crestfallen> s/warning/error
15:44:56 <dsal> Polarina: I've got a bunch of files with names like 0dae0af728ae719f0a43bec7becd9fc7131fff46142e13cbd0b5ab8de57dca3f and I don't know what's in them.
15:46:04 <crestfallen> s/error/warning  :)
15:46:05 <AWizzArd> crestfallen: does this change when you try to use `fmap` instead of `(<$>)`?
15:46:08 <merijn> crestfallen: <$> is not a member of Functor
15:46:18 <merijn> crestfallen: So you did, in fact, not implement fmap
15:46:27 <Axman6> crestfallen: and if <$> were in )functor, you would have to indent it
15:47:21 <crestfallen> man. <$> is for monoids? I am rusty
15:47:29 <koz_> crestfallen: <$> is just infix fmap.
15:47:43 <koz_> <> is for Semigroups, and since every Monoid is a Semigroup, you can use it with Monoids too.
15:47:51 <merijn> crestfallen: <$> is fmap, but it is *not* part of the typeclass
15:47:53 <AWizzArd> Axman6: that is also a good tip, I once spent several minutes to discover that indentation is required when implementing methods. They can’t be top-level.
15:47:55 <MarcelineVQ> it's a synonym for it, it's not literally fmap which is what you have to implement to implement Functor
15:48:12 <crestfallen> ok , thanks. then it's strange that the prefix notation is illegal
15:48:27 <merijn> crestfallen: What? Why is that strange?
15:48:57 <merijn> crestfallen: <$> is not *literally* fmap, it is a separate, distinct function whose implementation happens to be "fmap"
15:49:31 <EvanR> it seems that SDL high level bindings don't export the newtype constructor for Texture and so you can't get at the pointer. But I need it for a low level raw call. I'm just SOL ?
15:49:34 <merijn> crestfallen: It's as if I write "let f = id in ..." in some sense 'f' *is* 'id', but it's still a completely independent function definition
15:49:48 <merijn> EvanR: unsafeCoerce :p
15:49:52 <EvanR> ah
15:50:01 <EvanR> (safe coerce?)
15:50:01 <merijn> EvanR: Actually, you can try using "coerce"
15:50:07 <merijn> EvanR: It might work!
15:50:25 <EvanR> i think we established yesterday if the ctor isn't exported the Coerce instance isn't made
15:50:33 <crestfallen> thanks ALL I'll sort it out before I'm 60
15:51:11 <AWizzArd> When I have an (Aeson) Value, is there a way to serialize it into a byte array that I can save and read back in later and have exactly the same Value? Compact?
15:51:51 <crestfallen> I'm following this tutorial so I'm now feeling sorry for myself:  https://vaibhavsagar.com/blog/2016/06/17/haskell-state/
15:52:15 <crestfallen> see beginning of this page ^
15:52:22 <AWizzArd> I would like to parse a JSON Text only once and store it in, say, a DB blob, and later not have to parse it again.
15:53:18 <MarcelineVQ> crestfallen: That's the defintion for Functor in the nicta course the page links.
15:54:01 <dsal> AWizzArd: Before  you parse it, you have it unparsed.  You could just keep that original value.
15:54:11 <MarcelineVQ> https://github.com/data61/fp-course/blob/master/src/Course/Functor.hs
15:55:32 <MarcelineVQ> the "State exercises" it refers to are https://github.com/data61/fp-course/blob/master/src/Course/State.hs
15:55:42 <crestfallen> but is it correct?
15:55:44 <koz_> Is there any 'higher-level' wrapper for Windows' GDL in Haskell? I can't find anything except Win32 (which is a lot painful to use), or stuff that requires external libraries (which are not ideal in my case).
15:56:20 <koz_> Phyx-: ^
15:56:21 <MarcelineVQ> is what correct?
15:56:21 <vaibhavsagar> crestfallen: that certainly wasn't my intention :(
15:56:21 <crestfallen> anyway fmap doesn't work either. I get the same missingMethods warning
15:56:27 <AWizzArd> dsal: The unparsed is just a Text representation of a JSON object. I need to work with a Value, so I have to parse the Text into something I can work with. I have many of those and want a very cheap way to read them.
15:56:58 <AWizzArd> dsal: I thought about writing a Value into a compact region. I guess that this compresses the whole thing into one single byte array.
15:57:04 <crestfallen> vaibhavsagar, I don't know what's going on, nor do I understand what the intention is.
15:57:39 <dsal> AWizzArd: Sure, I'm just saying that if you want to store the original value, you've got that initially.
15:57:45 <MarcelineVQ> it's correct for the nicta definition of the Functor class, which is not the Functor class you have when you just open ghci
15:57:48 <dibblego> crestfallen: please show what your are found and what error you get
15:57:53 <MarcelineVQ> "<crestfallen> anyway fmap doesn't work either. I get the same missingMethods warning" if you want people to help with that you need to show it
15:57:53 <crestfallen> I just try to go through tutorials and get things to work or at least compile.
15:58:04 <dibblego> *you are doing (sorry)
15:58:33 <AWizzArd> dsal: I could store a human-readable json string, yes. But when I want to use it in Haskell again I again have to parse it into a Value. This is the step that I would like to save.
15:58:33 <MarcelineVQ> but I'm going to go guess you didn't indent like Axman6 mentioned earlier
16:01:43 <Phyx-> koz_: you mean GDI+? No there's not afaik. GDI+ has mostly been superceded by DirectDraw and Direct2D ever since DWM came out but no haskell bindings for those at all afaik. 
16:01:45 <crestfallen> MarcelineVQ, yeah thanks it was the indent. I didn't take it to mean fmap also needs an indent here .. Axman6 
16:02:57 <koz_> Phyx-: OK, let me stop A-B-problem-ing. I need to make a Windows GUI: there is no concern for portability to other platforms, but any external libs must be avoided at all costs. I guess Win32 can help me, but it's very low-level and painful. Is there something higher-level I could use?
16:03:43 <Polarina> koz_, you could consider OpenGL.
16:04:00 <koz_> Polarina: What would you suggest I use for this?
16:06:47 <EvanR> koz_: you could make a windows GUI front end using windows dev technology, and it communicates with a haskell process using IPC
16:06:58 <Phyx-> koz_: my only experience with haskell gui has been with gtk. To be honest the few occasions I needed a gui for a controlling haskell code I wrote it in another language against a haskell dll with the logic as there's no support for any modern windows gui toolkit in haskell 
16:07:07 <EvanR> or that
16:07:15 <koz_> Phyx-: So basically I gotta write C++?
16:07:21 <EvanR> C# my dude
16:07:23 <koz_> (or C# I guess)
16:07:27 <crestfallen> vaibhavsagar hi mind if I pm you? 
16:07:36 <merijn> 30 minutes of "why the hell am I getting syntax error complaints?!" from SQLite, only to realise the sqlite version being shipped isn't up to date >.>
16:08:12 <koz_> That... definitely isn't ideal.
16:08:14 <merijn> koz_: ftlkhs seems reasonably easy to use and build
16:08:16 <Phyx-> koz_: i honestly wouldn't go down the road of using the win32 api for gui.. It's.. Painful and it'll be raster based. You have to do basic stuff like dpi scaling yourself 
16:08:19 <merijn> koz_: Not very pretty, though
16:08:30 <koz_> Phyx-: Yeah, that's not ideal.
16:08:57 <koz_> merijn: Can I build it so that users don't need to have anything besides a fat Haskell binary around?
16:09:50 <koz_> Because the instructions for installing fltkhs on Windows begin with 'Set up Stack', which I am not using.
16:10:06 <dsal> https://gist.github.com/dustin/e9295c5b61e89a15dfd750262ebde871 <--  this seemed a little repetitive
16:10:36 <EvanR> a fat exe with a statically link haskell DLL
16:11:05 <merijn> koz_: Just because the instructions are for stack doesn't mean you need stack
16:11:18 <merijn> Anyway, bed time
16:11:24 <koz_> merijn: Sleep well, and thanks!
16:11:56 <Phyx-> koz_: can't you just ship the dlls along with the program? 
16:12:19 <koz_> Phyx-: Can I just stuff them in the same folder and expect it to work without issue?
16:12:39 <koz_> I haven't dealt with DLL anything on Windows this end of ever, so I have no idea what to expect.
16:12:42 <vaibhavsagar> crestfallen: happy to take questions but I'm out right now so it'll be a few hours before I can get back to you
16:12:43 <Phyx-> I've only got experience with gtk2hs, wrote a decent game in it back at uni. Was easy enough to figure out
16:13:25 <Phyx-> koz_: yes that's actually the original distribution model for applications on Windows. Just put everything in the same folder 
16:13:55 <koz_> Phyx-: Well, in that case, I'm happy to use whatever is most convenient, maintained, and easy to get help for.
16:13:59 <crestfallen> vaibhavsagar, thanks! talk later
16:13:59 <Phyx-> Global installation of DLL and subsequent "dll hell" only because a thing because people tried to save disk space 
16:14:52 * koz_ is confused why exeExtension lives in System.Directory and not System.FilePath.
16:15:08 <koz_> Phyx-: So on that basis, would you suggest I use gtk2hs?
16:17:01 <Phyx-> koz_: I've last written a gui almost a decade ago.. So I really wouldn't know which is the best option these days or easiest to use in Haskell :) but I would imagine it's gtk or qt. 
16:17:26 <koz_> I haven't written a GUI this end of _ever_, so I have no idea either.
16:17:41 <koz_> Thanks for patiently answering my questions though - I appreciate it.
16:17:52 <dsal> I've had success writing GUIs in objective C for OS X or NeXTSTEP.   Otherwise, I'd just do a web thing.
16:18:04 <ysangkok> Phyx-: another argument for dynamic linking is "it allows me to fix an issue in a library without rebuilding everything". in the linux distribution model, this translates to pushing the burden of package maintainership from the program authors to the individual distributions, IMHO
16:18:30 <dsal> ysangkok: s/fix a/create an/
16:18:50 <koz_> dsal: By 'web thing' you mean Electron?
16:18:55 <koz_> Or actually run in the browser?
16:19:12 <dsal> koz_: I've never tried that.  I just do stuff in the browser when  I want a GUI.
16:19:18 <ysangkok> dsal: well, if you wanted to advertise dynamic linking, you wouldn't say it creates an issue :P
16:19:29 <dsal> ysangkok: Yeah.   pros and cons
16:19:30 <ysangkok> i am just saying disk space is not the only argument
16:19:41 <koz_> dsal: This is... possible but not ideal.
16:19:47 <evelyn> Sometimes a TUI can be as powerful as a full-blown GUI
16:19:48 <koz_> I'd rather have a standalone for what I'm trying to do.
16:20:08 <koz_> evelyn: Not an option in this case. I'm writing this for use by first-year programming students, many of whom can barely stand a computer up the right way.
16:23:20 <koz_> I shall investigate the options again. Thanks again for all your folks' help.
16:23:23 <Phyx-> koz_: np, unfortunately I have limited gui experience as well :) and what I do have isn't in haskell :) 
16:23:45 <koz_> Phyx-: I guess it's never too late to learn. It's like, two and a half weeks before I go on holiday leave, so good time to learn new stuff.
16:23:56 <koz_> I already learned a tonne about file system watching I never thought I needed. :P
16:24:53 <Phyx-> koz_: i probably spend more time in assembly than haskell so don't have much need for a UI there :p
16:25:11 <koz_> Phyx-: I wish I could say I was this lucky. I spend most of my time in the classroom.
16:25:18 <koz_> (I teach programming, in not-Haskell sadly)
16:25:25 <Phyx-> ysangkok: and it's faster to link :) 
16:27:58 <Phyx-> koz_: ah, btw https://chocolatey.org/packages/haskell-dev got approved today so that should make it a single package to set up an initial working environment. After that you can update or downgrade each individual component as you wish (e.g. Ghc, cabal) 
16:29:21 <lavalike> is chocolatey anywhere close to brew in terms of reliability of installing and uninstalling and maintaining of the packages?
16:34:33 <Phyx-> I don't have any experience with brew. So I can't make any comparisons. Chocolatey is extremely reliable and every package is machine verified before getting approved and hand verified if their not marked as trusted. 
16:35:02 <Phyx-> It's based on Microsoft's nuget which is what drives the dotnet package ecosystem 
16:35:29 <koz_> If I want a DiffTime representing 1 second, how many zeroes do I need after the 1?
16:36:12 <koz_> s/DiffTime/NominalDiffTime/
16:36:39 <lavalike> Phyx-: thanks, I will have to work on windows for a while so I thought I'd ask
16:37:20 <EvanR> koz_: you mean 1?
16:37:47 <EvanR> the Num instance converts integer literal to number of seconds
16:37:56 <koz_> EvanR: Oh, that easy huh. Thanks!
16:38:08 <EvanR> ikr
16:38:13 <EvanR> time is easy!
16:38:33 <jdt> working with a basic VHF antenna (https://www.amazon.com/gp/product/B016SIJX28/ ) and a LimeSDR with a small no-name pre-amp and a larger, 85 watt RM Italy amplifier for transmitting. Trying to manage SWR - when I crank it up, the SWR gets very high (like 10). If I keep the LimeSDR gain around 36db, I can get closer to 2 for SWR.
16:38:43 <jdt> is that just something I need to live with for this little antenna?
16:38:54 <EvanR> are you sure you don't want ##electronics?
16:39:21 <jdt> oh shoot.
16:39:22 <jdt> lol
16:39:24 <EvanR> you're in the haskell channel
16:39:28 <jdt> I thought this was the hamradio channel.
16:39:30 <jdt> sorry.
16:39:39 <jdt> all I could see was the ##h in my emacs client.
16:39:39 <EvanR> oh neat... joining
16:39:42 <jdt> ignore me. :)
16:39:44 <koz_> Dependently typed ham radio.
16:39:45 <Phyx-> lavalike: I spent a lot of time on those packages and afaik everyone who uses them likes them. It's also a lot simpler. Want a new ghc, just one command. Want multiple ghc, one command. Want to update or downgrade? One command. The packages contain significant scripting to ensure that they don't use global state. So if anything does go wrong you can just un install and reinstall without problems for instance 
16:39:54 <koz_> I have to echo Phyx- on this.
16:40:06 <koz_> I use Chocolatey on Windows to manage everything from my GHC to my Inkscape.
16:40:11 <koz_> I have yet to have even one complaint.
16:40:56 <Phyx-> lavalike: and they auto configure themselves. So you don't have to mess with PATH or anything like that to get things to work. Compiling configure based packages etc work out of the box. 
16:42:25 <Phyx-> Yeah, I use it for most things these days too. And chocolatey is supported out of the box by circleci, Azure pipelines, Travis and appveyor. So it makes CI scripting for windows also very easy
16:44:43 <koz_> Phyx- (or anyone else with Haskell-on-Windows-fu): I've looked into things, and supposedly, you're meant to use haskell-gi now. It gives a list of things to install in MSYS2, which I can do. How do I then provision the DLLs needed?
16:45:21 <koz_> https://github.com/haskell-gi/haskell-gi/wiki/Using-haskell-gi-in-Windows
16:47:10 <Phyx-> koz_: simplest would probably be to compile your program and use (inside an msys2 shell) ldd or strace on your program to find which dlls it uses and where they are and copy those. 
16:47:29 <koz_> I guess that works.
16:48:58 <Phyx-> koz_: alternative you can use depends.exe or just grab the binaries for the packages you installed via pacman from repo.msys2.org. But you'll likely end up with more than you need then :) 
16:49:18 <koz_> Phyx-: depends.exe?
16:49:54 <Phyx-> koz_: http://www.dependencywalker.com/
16:50:19 <koz_> Oh, neat.
16:50:22 <koz_> It's like ldd.
16:50:35 <Phyx-> Yeah
16:50:39 <koz_> Phyx-: I don't mind if I end up with more than I need. I need a setup that is as unbreakable as possible.
16:50:46 <Phyx-> choco install dependencywalker :) 
16:50:56 <koz_> An absolute idea is 'one fat binary and nothing else', but if I'm gonna use haskell-gi I guess I can't.
16:52:23 <EvanR> a windows universal binary :)
16:52:35 <EvanR> falls back to win95 or DOS if it has to
16:52:46 <koz_> s/idea/ideal/
16:52:56 <koz_> EvanR: Lol.
16:53:02 <Phyx-> I doubt the msys2 packages contain static versions of the libraries. But yeah you can just get the binaries from repo directly. Excluding any tools such as pkg-config
16:53:22 <koz_> pkg-config is only needed at build time, correct?
16:55:39 * hackage pointfree-fancy 1.1.1.15 - Tool for refactoring expressions into pointfree form  https://hackage.haskell.org/package/pointfree-fancy-1.1.1.15 (vmchale)
16:56:07 <Phyx-> koz_: yeah
16:56:21 <koz_> Phyx-: OK, that seems reasonable. Will attempt and see.
16:56:48 <koz_> Supposing I was insane^Wcommitted enough to build static versions of all those deps, could I statically link them into my Haskell exe then?
16:57:01 <koz_> Would that work with those libraries, or do they insist on dynalinking?
17:28:58 <monochrom> Perhaps one day we should port GHC to Commodore 64.
17:29:22 <monochrom> Because it's called "64" it ought to be 64-bit, right? right? >:)
17:30:35 <crestfallen> real quick , I was wondering why something like pure = a -> f a    is called a degenerate case. or what degenerate is generally in cs. in math they are talking about triangles as degenerate, so the only criterion I see with pure is that it is 'simpler' since the function is just a type as in 'a'. 
17:31:44 <divVerent> crestfallen: just like that, a degenerate triangle is also simpler
17:31:56 <crestfallen> say if a triangle has an angle that is zero, it lies on a line and is degenerate
17:31:58 <divVerent> as its three points are on a line, its area is zero
17:32:20 <MarcelineVQ> it depends what pure is said to be a degenerate case of
17:32:32 <divVerent> but degerate triangles also do NOT fulfill some things normal triangles do - degenerate functions don't have that in this case
17:32:43 <MarcelineVQ> as to "why something like pure = a -> f a    is called a degenerate case" I mean
17:32:51 <divVerent> like, a degenerate tringle does not have a unique circumcircle
17:33:02 <crestfallen> divVerent, thanks, yeah I never knew a triangle could be defined like that
17:33:03 <divVerent> unless you also see a line as a degenerate circle, of course :)
17:33:28 <monochrom> lines and points are two degenerate kinds of circles
17:33:32 <crestfallen> MarcelineVQ, I guess it is being related to <*>
17:33:35 <divVerent> which it technically is (e.g. inversion at a point independent from all other points you are using turns both lines and triangles into circles equally)
17:33:39 * hackage tmp-postgres 1.20.0.1 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.20.0.1 (JonathanFischoff)
17:33:53 <monochrom> lines being if you allow radius to be infinity, points if you allow radius to be 0.
17:34:11 <divVerent> but anyway, I wouldn't call pure :: a -> f a degenerate per se
17:34:36 <monochrom> But I did.
17:34:47 <crestfallen> I think it means that a is a type and not a function that takes an argument
17:34:48 <monochrom> Perhaps I should call it "imagine liftA0".
17:34:49 <divVerent> however, I'd say it generates degenerate elements of f a
17:35:06 <divVerent> namely, elements that use no properties of the Applicative, in a way
17:35:17 <crestfallen> a is merely a data type
17:35:32 <crestfallen> in the context of the hutton text
17:35:47 <divVerent> e.g. in the [] Applicative, pure :: a -> [a] returns one-element lists
17:36:02 <divVerent> I wouldn't call those lists degenerate per se, but in context of the [] Applicative, they are
17:36:17 <divVerent> simply because they do "nothing special"
17:36:39 * hackage tmp-postgres 1.21.0.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.21.0.0 (JonathanFischoff)
17:36:40 <crestfallen> yeah since a singleton is still a list in every way, right?
17:36:52 <divVerent> yes
17:37:16 <divVerent> now outside the context of Applicative, I'd rather call the empty list degenerate
17:37:25 <monochrom> My line of thought was that Applicative gives you liftA2, liftA3, etc., and you also have liftA1 as fmap from Functor, so how do I explain pure?  I explained by extrapolating in the other direction, that is towards 0.  At that point it's analogous to "point = circle of radisu 0" so I called it degenerate.
17:37:30 <divVerent> it e.g. is the only list that is member of multiple list types (namely, all of them)
17:37:45 <divVerent> pure f <*> pure x = pure (f x)
17:37:52 <divVerent> explains the degenerate-ness of pure very well, IMHO
17:39:47 <crestfallen> they do nothing special [singleton] say, but they can be passed around as structures, I guess.
17:40:02 <divVerent> yeah, pure basically is liftA0
17:41:05 <divVerent> hm... but to do this reductively, how to turn liftA2 into liftA the same way that turns liftA3 into liftA2?
17:42:32 <crestfallen> divVerent, ...
17:42:34 <divVerent> liftA2 f = liftA3 (const f) (pure undefined)
17:42:41 <divVerent> looks like this reduction always goes one level lower
17:42:52 <crestfallen> I haven't come to the lift stuff yet.. however...
17:43:14 <divVerent> so what is liftA (const f) (pure undefined)? It's actually pure f.
17:43:34 <crestfallen> could we go back to pure f <*> pure x = pure (f x) explains the degenerate-ness of pure very well, IMHO
17:43:49 <divVerent> yes :)
17:44:41 <divVerent> liftA_minus_1 = pure (const f) (pure undefined)... that now really makes no sense, unless you're in the (-> a) applicative.
17:45:14 <crestfallen> no capiche
17:45:25 <divVerent> it makes zero sense anyway :)
17:46:00 <crestfallen> pure f      that injects a function into a structure?
17:46:11 <divVerent> sort of, yeah
17:46:23 <divVerent> pure a injects a value into the structure, so Applicative can operate on it
17:46:50 <crestfallen> the last post, yes that I see
17:47:09 * hackage hOpenPGP 2.8.5 - native Haskell implementation of OpenPGP (RFC4880)  https://hackage.haskell.org/package/hOpenPGP-2.8.5 (ClintAdams)
17:48:07 <crestfallen> so what sort of function could pure inject into a structure.. not any function, correct?
17:50:00 <crestfallen> but in the case of pure f <*> pure x = pure (f x)   ultimately f has an argument 
17:50:05 <divVerent> it can inject anything
17:50:43 <divVerent> Prelude Control.Applicative> (pure (+1)) <*> [2, 3, 5, 7]
17:50:44 <divVerent> [3,4,6,8]
17:50:54 <divVerent> I know that example is rather useless, but here pure injects a function
17:51:16 <divVerent> Prelude Control.Applicative> [(+1), (+2)] <*> pure 42
17:51:17 <divVerent> [43,44]
17:51:19 <divVerent> and here it injects a value
17:51:41 <crestfallen> good example
17:51:48 <divVerent> basically Applicative in a way generalizes functions as values and lets you operate with them in similar ways
17:52:19 <divVerent> and the list Applicative is probably the easiest to understand I think
17:52:52 <crestfallen> so the above example (pure (+1)) <*> [2, 3, 5, 7]     ....     pure (+1) would be degenerate
17:55:18 <divVerent> sort of - it's the part that doesn't really use the Applicative
17:56:02 <crestfallen> I see that is reasonable. thanks kindly
17:56:44 <crestfallen> the applicative uses _it_
17:57:08 <divVerent> left op f = op (pure f) (pure undefined)
17:57:24 <divVerent> now this is fun... this "left" turns liftA3 into liftA2, into liftA, into pure...
17:57:33 <divVerent> but left pure is pure again
17:57:51 <dibblego> liftA1 :: (a -> b) -> f a -> f b
17:57:56 <dibblego> liftA2 :: (a -> b -> c) -> f a -> f b -> f c
17:58:01 <dibblego> liftA3 :: (a -> b -> c -> d) -> f a -> f b -> f c -> f d
17:58:02 <divVerent> Prelude Control.Applicative> :t left (pure :: a -> (b -> c) -> a)
17:58:04 <divVerent> left (pure :: a -> (b -> c) -> a) :: Applicative f => a -> f a
17:58:07 <dibblego> liftA4 :: (a -> b -> c -> d -> e) -> f a -> f b -> f c -> f d -> f e
17:58:10 <dibblego> liftA0 :: ?
17:58:25 <divVerent> well, that's what my "left" does... it removes one layer of lifting
17:58:37 <divVerent> Prelude Control.Applicative> :t left liftA
17:58:38 <divVerent> left liftA :: Applicative f => b -> f b
17:58:49 <divVerent> so liftA0 :: a -> f a, which must be pure
17:58:54 <crestfallen> yes actually those posts are close to the text I'm using divVerent dibblego 
17:59:09 <dibblego> it is the zero or identity case
17:59:28 <divVerent> what surprises me is that applying my "left" to liftA0 (i.e. pure) yields liftA0 again, once I make it work at all
17:59:51 <koz_> If I want to check if there's a file in a directory whose name fits a certain pattern, what should I use?
18:00:02 <crestfallen> but how can pure (+1) be identity, it is succ, right?
18:00:10 <divVerent> it's succ, yes
18:00:18 <dibblego> crestfallen: pure is the identity for (<*>)
18:01:13 <dibblego> just like 0 is the identity for (+)
18:01:34 <crestfallen> but in the case of a function being lifted dibblego  as in (+1) ? not sure I follow
18:02:09 <dibblego> @let identityPure \f x -> (pure f <*> pure x) == pure (f x)
18:02:09 <lambdabot>  Parse failed: TemplateHaskell language extension is not enabled. Please add ...
18:02:17 <dibblego> > let identityPure \f x -> (pure f <*> pure x) == pure (f x)
18:02:19 <lambdabot>  <hint>:1:18: error:
18:02:19 <lambdabot>      Unexpected lambda expression in function application:
18:02:19 <lambdabot>          \ f x -> (pure f <*> pure x) == pure (f x)
18:02:22 <dibblego> sorry
18:02:33 <dibblego> anyway, that will always return True
18:02:50 <dibblego> also this: (\x -> pure id <*> x)
18:03:07 <dibblego> also this: (\x -> pure id <*> x == x)
18:03:21 <divVerent> oh, I get it... liftA_minus_1 can only exist in the a-> applicative, but it reduces to pure in the same
18:03:39 <divVerent> but then... shouldn't liftA and pure ALSO be somewhat "equivalent" in the a-> applicative?
18:03:40 <dibblego> > pure (+1) <*> [1,2,3,4,5]
18:03:42 <lambdabot>  [2,3,4,5,6]
18:03:44 <crestfallen> pure id <*> x == x    that makes complete sense
18:04:19 <dibblego> > pure id <*> [1,2,3,4,5]
18:04:21 <lambdabot>  [1,2,3,4,5]
18:04:44 <dibblego> (pure f <*> x) == (f <$> x)
18:05:04 <dmwit> koz_: http://hackage.haskell.org/package/filepattern possibly
18:05:12 <koz_> dmwit: Thanks!
18:08:48 <divVerent> oh, now I get it... it actually IS
18:08:51 <divVerent> (a -> b) -> (a -> a) -> a -> b
18:08:55 <divVerent> is a type both pure and liftA can have
18:09:05 <divVerent> the -> Applicative is certainly amazing
18:09:14 <crestfallen> so yeah, pure just injects anything into a structure so that it can be used in the applicative, whether it changes anything or not. that's why its degenerate dibblego I suppose
18:09:46 <dibblego> I tend to call it the identity or neutral element, "the thing that does nothing"
18:10:02 <divVerent> except... the neutral element for <*> would be something else
18:10:04 <dibblego> I think of it as [] in relation to (++), or 0 in relation to (+), or id in relation to (.)
18:10:06 <crestfallen> but how can pure (+1) be seen to do nothing?
18:10:11 <divVerent> it'd be the value X so that X <*> y = y for all y
18:10:19 <divVerent> crestfallen: but it doesn't do nothing
18:10:28 <divVerent> in my example it incremented all the list elemnets on the other side by 1
18:10:34 <divVerent> that X, of course, is pure id
18:10:52 <dibblego> pure id
18:10:56 <divVerent> now is there also a neutral element on the right of <*>?
18:11:46 <divVerent> no, but there is at least
18:11:58 <divVerent> pure ($ x) <*> pure id = x
18:12:03 <divVerent> I suppose that's as neutral as it gets
18:12:33 <crestfallen> ...
18:12:44 <dmwit> % newtype Eat a = Eat (a -> Eat a)
18:12:44 <yahb> dmwit: 
18:13:00 <divVerent> it's a consequence of the Interchange law of Applicative
18:13:05 <dmwit> % unEat (Eat f) = f
18:13:05 <yahb> dmwit: 
18:13:28 <divVerent> dmwit: this looks like it's gonna get somewhere cool ;)
18:14:40 <dmwit> % :t \v -> (unEat <$> v) <*> pure undefined
18:14:40 <yahb> dmwit: Applicative f => f (Eat a) -> f (Eat a)
18:15:38 <crestfallen> Interchange law... looking in my book. there are functor laws discussed...are they shared with applicative?
18:16:00 <dmwit> Yes, Applicatives must be Functors.
18:17:34 <crestfallen> actually, that is implied only in the book... but the logic is not immediately apparent to me
18:18:29 <crestfallen> cant wait to understand dmwit 's example
18:18:55 <crestfallen> need to wait til morning tea
18:20:26 <crestfallen> divVerent, dibblego dmwit really appreciate it
18:20:31 <dibblego> np
18:24:56 <divVerent> crestfallen: I didn't understand the example either... damn, even got confused by the <$> which is just an odd way of saying fmap
18:26:32 <divVerent> with v :: f (Eat t), fmap unEat v :: f (t -> Eat t), which kinda makes sense
18:27:01 <divVerent> and then the <*> with pure undefined basically passes a value that does not matter to the first argument of the function, yielding an Eat t back
18:27:14 <divVerent> (so, a f (Eat t) in total)
18:28:09 <crestfallen> divVerent, wait could you load that into lambdabot or whatever yahb is? I don't know that % command
18:28:11 <divVerent> the fun part here is that Eat t allows getting a value out of a t -> Eat t
18:28:26 <divVerent> which normally you can't just do
18:28:37 <divVerent> sorry, no, would take me too many attempts
18:29:27 <crestfallen> dang
18:29:57 <divVerent> also, I can't currently even think of any value of the type Eat
18:30:28 <divVerent> is that even inhabited?
18:30:41 <EvanR> sure
18:31:22 <divVerent> but by anything other than Eat undefined and variants?
18:32:29 <EvanR> i think Eat undefined is different from let e = Eat (\x -> e) in e
18:33:13 <Clint> dcoutts: are you okay with bzlib having a lower bound on base 4.9?
18:33:53 <crestfallen> actually, after all this time I still don't quite get the structure of a let statement. They are coming up in state monad/applicative definitions. the result is often on the lhs which confuses me
18:34:16 <divVerent> is any of the differences actually observable though, except in the form of bottom vs non-bottom?
18:34:19 <EvanR> you mean the result uses something defined in the bindings
18:34:35 <crestfallen> the function application is on the rhs, and the result, with the new state, is on the left
18:34:36 <EvanR> which makes sense
18:35:29 <EvanR> the structure is let <bindings> in <evaluate this>. The only trick is bindinds are recursion and can appear in binding rhses
18:35:37 <EvanR> recursive*
18:35:47 <EvanR> aka letrec
18:37:18 <EvanR> divVerent: one freezes or crashes, the other doesn't
18:37:34 <EvanR> the other one let's you feed is any number of times without problems
18:37:48 <divVerent> EvanR: ah, I see
18:38:22 <divVerent> not sure what to call that in theory, but it seems like it's only really observable from "outside"
18:38:35 <EvanR> codata
18:38:53 <crestfallen> letrec  what's that?
18:38:59 <EvanR> recursive let
18:39:11 <divVerent> i.e. you can't define any expression that takes an Eat and for which values exist so it may return True for one and False for another
18:39:19 <divVerent> of course... you can't do that for the type () either
18:39:35 <EvanR> yeah it may be observably equivalent to ()
18:39:49 <dmwit> Yes, Eat is a fancy ().
18:40:07 <dmwit> This is closely related to my objection to the "encoding" of untyped lambda calculus as data L = L (L -> L)
18:40:29 <dmwit> or newtype if you prefer
18:40:34 <divVerent> sure
18:40:54 <shachaf> What's the objection?
18:41:04 <dmwit> If you allow IO in my distinguisher, I think I can make countably many distinguishable Eats.
18:41:28 <dmwit> (Even if you force me to identify otherwise-distinguishable bottoms.)
18:41:37 <dmwit> shachaf: Can't observe anything interesting about the terms.
18:42:14 <crestfallen> Eat is a fancy ()  << looks like an eating disorder
18:42:19 <shachaf> You can observe that they halt.
18:42:22 <divVerent> dmwit: well... in IO, I can make countably many distinguishable items of () too
18:42:25 <shachaf> Sorry, reduce to normal form.
18:42:31 <divVerent> error "1", error "2", error "3" ...
18:42:35 <dmwit> divVerent: Not if I force you to identify otherwise-distinguishable bottoms.
18:42:51 <divVerent> right, I see
18:43:06 <halogenandtoast> Is there a shorthand (or operator) that is essentially ((f <$>) . g)
18:43:40 <dmwit> shachaf: Can you?
18:43:41 <shachaf> (fmap f . g) is a shorthand.
18:43:55 <dmwit> I mean.
18:44:04 <dmwit> You can't return a Bool saying whether it reduces to normal form.
18:44:11 <EvanR> it's semidecidable
18:44:20 <shachaf> Sure, you can only semiobserve it, if you prefer.
18:44:32 <shachaf> You can return a () saying whether it reduces to normal form.
18:44:58 <dmwit> Whereas with a good encoding there's a lot more things you can observe about a lambda term.
18:45:02 <dmwit> Like whether it's an application or not.
18:45:08 <dmwit> Whether it's alpha-equivalent to another term.
18:45:16 <dmwit> All kinds of good stuff.
18:45:38 <crestfallen> EvanR I really wish I understood your posts re: recursive bindings on the rh sides. I understand recursion in many cases fairly well..
18:45:54 <shachaf> I mean, that depends on what you want out of your encoding.
18:45:54 <halogenandtoast> shachaf: thanks, that does look better for one case, but I have another that is (fmap (f a) . g) and can not decide if that is better than (f a <$>) . g
18:46:09 <EvanR> crestfallen: the bindings define names using equations. The names can be used on the right side of each equation
18:46:45 <crestfallen> one moment pls
18:46:55 <divVerent> hm... this repr of untped  lambda calculus... 
18:47:10 <shachaf> (\x -> f a <$> g x) is a longhand that might be clearer sometimes.
18:47:12 <divVerent> lets me get a L out of thin air: (\l -> (unL l) l) (L (\l -> (unL l) l))
18:47:36 <divVerent> of course, it's not like I can actually _do_ anything with it, so it may as well be undefined :: L
18:47:40 <EvanR> L id is even more thin!
18:47:46 <divVerent> right
18:47:51 <divVerent> but I wanted an endless loop
18:47:57 <divVerent> but then realized I can't actually trigger it ;)
18:47:59 <EvanR> u bad
18:48:04 <shachaf> dmwit: I think people want to talk about what lambda expressions represent, rather than how they're reduced.
18:48:39 <divVerent> and yes, L id is basically the same
18:48:49 <shachaf> You can always add additional ur objects or something if you want.
18:49:02 <crestfallen> https://termbin.com/ykqx   EvanR if you could peek at this and in the Applicative instance help me understand how recursion works in the let statement
18:49:29 <EvanR> it's not using recursion
18:49:32 <shachaf> But obviously statements like Rice's theorem will work for this this kind of representation, and won't work for things that tell you details about the reduction.
18:49:57 <dmwit> shachaf: We've already got () for representing things where all you can do is semi-decide if it terminates.
18:49:57 <EvanR> you could write that without recursive let
18:50:57 <shachaf> Well, the type L is certainly different in Haskell from the type ().
18:51:17 <dmwit> Not in very interesting ways.
18:51:23 <shachaf> You can write _|_ without recursion with it, unlike with ().
18:51:28 <shachaf> I think that's pretty interesting.
18:51:33 * dmwit doesn't
18:51:43 <EvanR> :\
18:51:53 <shachaf> Well, OK, that's because Haskell is kind of nonsense.
18:52:42 <shachaf> But it's kind of the point of this L ~~ (L -> L) model of untyped lambda calculus.
18:54:19 <shachaf> Hmm, I was about to say something about having a surjection : L -> (L -> L), but of course you have that in a total language with () too!
18:56:02 <divVerent> I like the Void type more anyway
18:56:19 <divVerent> never understood why C doesn't have it, and modern compilers call it void __attribute__((noreturn)) :)
18:57:34 <crestfallen> so this:    let <bindings> in <evaluate this>     allow you to give the state names s' and s'' to reflect ST a -> ST b. The bindings are s' and s''     EvanR  ?   
18:58:18 <crestfallen> allows*
18:59:26 <crestfallen> so no I think the bindings are the tuples (f,s') and (x,s'')
19:00:11 <EvanR> yes
19:00:11 <crestfallen> in the case of the let statement applicative 
19:00:57 <EvanR> > let (x,y) = (1,2); z = x + 1 in (z,y)
19:00:59 <lambdabot>  (2,2)
19:01:09 <EvanR> same thing
19:03:54 <crestfallen> yes, f actually reflects ST (a -> b)  
19:05:03 <crestfallen> I hope. thanks EvanR 
19:06:18 <dmj`> has anyone written a function that deduplicates a vector in-place ? (this means [a,b,a,c] would yield [a,b,c])
19:06:48 <Axman6> so nub for vectors?
19:07:12 <Axman6> I assume you wan mutable vectors?
19:07:38 <maerwald> the question is whether the output vector is allowed to be sorted
19:07:59 <dmj`> Axman6: yes
19:08:04 <dmj`> maerwald: yes
19:08:11 <dmj`> in-place nub for Vector
19:08:47 <maerwald> that should be reasonable in time and space after the input vector has been sorted, you only compare against the previous element
19:09:01 <dmj`> maerwald: that's exactly my approach
19:09:31 <maerwald> I wrote such a function in go, but not in haskell xD
19:09:36 <dmj`> I forgot to mention one thing, the operation must also allow for a combining step
19:09:36 <Axman6> you're using vector-algorithms then?
19:09:45 <dmj`> Axman6: I wrote my own in-place quicksort
19:09:58 <dmj`> and it's quick-checked so you know it's right ;) 
19:10:34 <dmj`> nubVectorInPlace :: Ord a => (a -> a -> a) -> Vector a -> Vector a
19:11:28 <dmj`> Axman6: I am going to use in-place quicksort on the Vector, than write another operation using modify that accumulates up the chunks in a linear scan, in-place overwriting, carefully moving the indices down the vector, finally yielding the slice at the end.
19:11:33 <dmj`> then*
19:13:56 <maerwald> dmj`: I did a bottom-up iterative mergesort (non-recursive), which turned out to be *really* fast
19:13:59 <maerwald> https://gist.github.com/hasufell/2f7146e39291a5eb3c5560c8f82b7c55
19:14:28 <maerwald> should probably give that a go in haskell
19:16:20 <EvanR> go in haskell *shudder*
19:16:31 <maerwald> lolol
19:32:18 <divVerent> main :: PublicT (StaticT (Void)) IO ()
19:32:25 <divVerent> Now that's shudder
19:34:40 <dmj`> maerwald: very nice
19:34:56 <halogenandtoast> Any suggestions for a good name for this: f (ma, mb) = (,) <$> ma <*> mb
19:35:01 <dmj`> I have a soft spot for while loops
19:35:39 <dmj`> maerwald: what would truly be incredible is if you could deduplicate while sorting and yield the slice of the vector correctly
19:36:42 <divVerent> halogenandtoast: <,>? <(,)>?
19:36:57 <divVerent> iirc latter is not valid
19:37:45 <halogenandtoast> divVerent: the type of f is f :: Applicative f => (f a, f b) -> f (a, b)
19:37:45 <divVerent> but <,> looks like one would expect it to also allow ma <,> mb <,> mc and expect it to be (,,) <$> ma <*> mb <*> mc
19:37:58 <heatsink> halogenandtoast, traverseTuple
19:38:05 <heatsink> :t traaverse
19:38:07 <lambdabot> error:
19:38:07 <lambdabot>     • Variable not in scope: traaverse
19:38:07 <lambdabot>     • Perhaps you meant one of these:
19:38:10 <heatsink> :t traverse
19:38:12 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
19:38:20 <heatsink> Hm, not traverse
19:38:49 <halogenandtoast> seems a little like sequence, but not quite
19:38:51 <halogenandtoast> :t sequence
19:38:52 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
19:38:53 <shachaf> The name in Data.Bitraversable is bisequence
19:41:41 <MarcelineVQ> :t uncurry (liftA2 (,)) -- give it a food related name
19:41:43 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
19:42:13 <monochrom> applicative = curried burritos
19:42:37 <monochrom> https://currito.com/
19:43:01 <halogenandtoast> oddly enough bisequence doesn't fit the type for some reason, still trying to figure out why
19:43:17 <maerwald> is $SHELL set under mac?
19:43:59 <glguy> maerwald: It is for me
19:44:00 <halogenandtoast> maerwald: Yes
19:44:20 <glguy> printenv SHELL
19:44:23 <glguy> /bin/zsh
19:44:27 <maerwald> nice
19:44:35 <MarcelineVQ> halogenandtoast: it's backwards
19:44:40 <MarcelineVQ> % :t bisequence @(,)
19:44:40 <yahb> MarcelineVQ: Applicative f => (f a, f b) -> f (a, b)
19:44:52 <MarcelineVQ> oh I'm an idiot, hehe
19:44:54 <maerwald> glguy: does /bin/sh link to /bin/zsh as well?
19:45:09 <glguy> -rwxr-xr-x  1 root  wheel  31440 Oct 23 18:34 /bin/sh
19:45:25 <halogenandtoast> MarcelineVQ: it works now, there must have been some formatting or something that was throwing it off
19:45:27 <halogenandtoast> :shrug]
19:45:32 <glguy> /bin/sh --version
19:45:32 <glguy> GNU bash, version 3.2.57(1)-release (x86_64-apple-darwin19)
19:45:38 <maerwald> interesting
19:46:11 <halogenandtoast> ah I had changed a $ to a . incorrectly
19:49:28 <dmj`> maerwald: selection sort might be able to both fold while sorting
19:49:36 <dmj`> in place
19:49:48 <dmj`> folding the duplicates that is
19:51:59 <monochrom> insertion sort too.
19:52:25 <monochrom> and insertion sort is much more friendly to immutable lists and functional programming
19:54:57 <nshepperd> does <|> in IO catch async exceptions?
19:55:32 <halogenandtoast> /quit
19:55:50 <glguy> % error "nope" <|> return ()
19:55:51 <yahb> glguy: *** Exception: nope; CallStack (from HasCallStack):; error, called at <interactive>:49:1 in interactive:Ghci22
19:57:10 <dmj`> monochrom: oh man, I actually have an in-place insertion sort
19:57:14 <nshepperd> 'mplusIO m n = m `catchException` \ (_ :: IOError) -> n' aha
19:57:15 <dmj`> w/ Vector
19:58:00 <EvanR> :t (<+>)
19:58:02 <lambdabot> error:
19:58:02 <lambdabot>     Ambiguous occurrence ‘<+>’
19:58:02 <lambdabot>     It could refer to either ‘Control.Arrow.<+>’,
19:58:26 <maerwald> dmj`: mh, but worst complexity of mergesort + dedup would still be O(n log n) right? while insertion and selection sort would be O(n^2)
19:58:51 <nshepperd> i think that means that it'll catch IOErrors sent from another thread? but not sure
19:59:42 <monochrom> I guess you can code your own mergesort to get rid of duplications too.
19:59:57 <monochrom> s/ion/e/
20:00:14 <monochrom> I should put that on my exam!
20:00:19 <dmj`> maerwald: true yea, for now I'll probably opt for quickSort O(n^2) + dedupe. I don't have an in-place merge sort.
20:00:41 <maerwald> monochrom: only in the recursive version that seems easy
20:00:47 <dmj`> monochrom: It's not obvious to me right now how I'd carry along the index of the deduped vector during the bottom-up merge
20:00:50 <maerwald> the iterative mergesort is already quite complicated
20:01:49 <monochrom> Eww. Yeah I wouldn't de-recursionize tower of hanoi either :)
20:02:11 <glguy> nshepperd: Yes, it catches IOErrors thrownTo it
20:02:38 <maerwald> loops with indices is harder than recursion :P
20:02:44 <glguy> Tried in GHCI running: tid <- forkIO (() <$ threadDelay 1000000000 <|>  putStrLn "else"); fail "fun" `catch` \e -> throwTo tid (e::IOError)
20:05:00 <koz_> dmj`: You wanna dedup while you merge bottom-up or something.
20:05:08 <koz_> (assuming I understand what you're trying to do)
20:06:17 <dmj`> koz_: that would be ideal, but I'd need to unsafeSlice the vector, and it isn't clear to me how I'd carry along the final index amidst the recursion
20:06:44 <koz_> The final index?
20:06:52 <koz_> I'm not sure I understand.
20:06:56 <dmj`> koz_: with my current qsort + standalone dedupe function, it performs 2-passes, but the dedupe can modify the vector in-place while it linearly traverses it
20:07:06 <koz_> Oh, OK.
20:07:09 <koz_> That's the bit I missed.
20:07:13 <koz_> Never mind, plz ignore me.
20:08:27 <nshepperd> glguy: i see, ok
20:08:43 <maerwald> dmj`: on the other side, even if you do both at the same time, complexity is the same :P
20:08:45 <nshepperd> not sure if i want that
20:09:02 <maerwald> but it should be a noticable performance improvement
21:01:36 <leo__> instance `NFData (ConduitT i o m r)`
21:01:40 <leo__> is that a blasphemy?
21:02:36 <leo__> I want to benchmark with a env `Gen (ConduitT i o m r)`
21:02:49 <leo__> an env*
21:03:11 <leo__> instance `NFData (ConduitT i o m r) where rnf = const ()`*
21:04:05 <koz_> leo__: What does it mean to deepseq an infinitely-large thing?
21:04:27 <dmj`> maerwald: good point :)
21:04:32 <dmj`> maerwald: want to see the function?
21:04:46 <leo__> koz_: In this case, nothing.
21:04:53 <leo__> I just want the constraint to be satisfied
21:04:58 <leo__> In Bench.hs
21:06:09 <Kristof_HT> I want to setup Haskell to work with Atom. As a newbie problems for me start as early as trying to figure out the right way to install Stack. Someone please tell me how to set alternative directory for global install (other than C:/sr) - or at least point me to a guide that explains the proper way to install Stack.
21:09:23 <leo__> koz_: ?
21:09:50 <koz_> leo__: What about me?
21:10:00 <leo__> Do you know that? D:
21:10:05 <Kristof_HT> Haskell website recommends using Platform - while all the 'opinions' I read on the net say that Platform is the worst choice.
21:10:07 <leo__> Is it to bad to force NFData on Conduit?
21:10:34 <leo__> Kristof_HT: What are you gonna use Haskell for?
21:10:48 <koz_> leo__: I don't know what it means for a Conduit to have an NFData instance. The semantics of what NFData is supposed to do don't make sense here.
21:10:55 <leo__> At least for learning, platform seems ok to me.
21:12:54 <Kristof_HT> End goal is to use it to write backend  (and Elm for frontend) - but that's a long ways away. Last time I has contact with FP was 6 years ago with OCaml
21:14:15 <leo__> Yeah, so platform should be ok.
21:16:36 <leo__> koz_: I'll investigate more instead of trying to subvert the type system.
21:17:49 <jle`> leo__: yeah, it sounds like you might be trying to do the wrong thing here
21:18:03 <jle`> there's a reason NFData is required for these things
21:18:22 <jle`> if you don't have a real NFData then the mechanisms that the benchmarking uses won't work
21:18:38 <leo__> Hm.
21:19:11 <jle`> for example your version doesn't even do a shallow seq
21:19:32 <jle`> so it might benchmark all things as taking 0s
21:19:36 <jle`> because it isn't evaluating any of the results
21:20:02 <leo__> jle`: But that's just for the param generation code.
21:20:46 <leo__> It'd be env `(QC.generate $ thing_that_gens_the_conduit) (bench "whatever" $ ...`
21:20:51 <leo__> ops
21:20:57 <leo__> `env ( ...`
21:21:40 <jle`> what are you using to benchmark?
21:22:10 <leo__> Criterion
21:22:28 <jle`> hm, just remember at least that the NFData constraint owuldn't be there unless it is actually used to do something important
21:23:46 <jle`> leo__: looking at criterion it seems that env doesn't require an NFData constraint?
21:23:58 <leo__> It does.
21:25:05 <jle`> ah wait, i see it now yeah
21:25:06 <leo__> Creation. An environment is created right before its related benchmarks are run. The IO action that creates the environment is run, then the newly created environment is evaluated to normal form (hence the NFData constraint) before being passed to the function that receives the environment.
21:25:15 <leo__> Sorry, my clipboard went astray.
21:26:20 <leo__> https://dpaste.de/0FTn
21:26:37 <leo__> I want to do that crazy stuff in the end.
21:27:29 <jle`> ah okay, the reason why nfdata is required here is so that it can force all the IO to be done *first* before starting any of the benchmarks
21:28:31 <jle`> hm, how are you generating a conduit?
21:28:55 <leo__> I actually generate a list and then sourceList it
21:29:22 <jle`> hm
21:29:26 <jle`> why don't you just 'gen' the list, then?
21:29:41 <jle`> er, i mean, use the list as the env
21:29:51 <leo__> Hm.
21:29:54 <leo__> Sure, It'd work. xd
21:30:16 <leo__> The only thing then is that I'd not be benchmarking it with conduit.
21:30:18 <jle`> it's possible that QC.generate doesn't force all IO before returning the final item
21:30:24 <leo__> Without disk IO overhead.
21:31:20 <leo__> Makes sense. :s
21:31:22 <jle`> leo__: hm, not sure what you mean. everything would be the same, effectively you can just use 'sourceList' before doing the functions you benchmark
21:31:39 <leo__> Yeah.
21:32:01 <leo__> Jesus, I should sleep more often. xd
21:32:11 <leo__> jle`: Thanks. .-.
21:32:20 <jle`> ^_^
21:32:42 <leo__> I'm embarassed now. :|
21:32:59 <leo__> Thanks again man!
21:33:52 <jle`> no need to be embarassed :)
21:55:05 <dmj`> maerwald: it works, it's just very slow
21:57:25 <koz_> Sleep is important yo.
21:58:09 <heatsink> sleep 28800;
21:58:16 <EvanR> koz_++
21:59:00 <koz_> Though to be honest, GHC limits the damage my sleep-deprived self can inflict.
21:59:47 <EvanR> hmm GHC for life
22:00:25 <koz_> Also EvanR - you shall be pleased to know I now have an all-watching, all-streaming, none-CPU-burning file watching solution.
22:01:33 <EvanR> nice
22:01:48 <EvanR> i hate polling!
22:01:57 <koz_> EvanR: I think this one is pollfree?
22:02:09 <EvanR> if it's 0 cpu, then yeah
22:02:18 <koz_> EvanR: https://github.com/composewell/streamly/issues/318#issuecomment-558846615
22:02:56 <koz_> (although I made it a bit better later, the essence is the same)
22:03:31 <koz_> I also had to set up 1-second debouncing because I was getting double-ups.
22:04:06 <EvanR> a cooldown
22:04:26 <EvanR> if it works it works
22:04:47 <koz_> It works for my purposes.
22:04:59 <koz_> I could have, in retrospect, sampled less frequently too.
22:05:03 <koz_> (this samples at 5Hz)
22:05:15 <koz_> (I could have probably gone down to like, 1Hz and not used debouncing lol)
22:05:32 <EvanR> sampling...
22:06:22 <koz_> It's what Streamly calls it.
22:08:31 <maerwald> dmj`: show me
22:20:08 <dmj`> maerwald: https://gist.github.com/dmjio/f6e55815fafcf98900c6924aa168b900#file-main-hs-L88
22:20:23 <dmj`> maerwald: I'm comparing it against a previous implementation defined in terms of Generic vector
22:20:45 <dmj`> maerwald: this new implementation boasts 0-1MB constant heap (per +RTS -s -RTS)
22:21:21 <dmj`> interestingly, it's very slow when the keys are similar, but faster when the keys are different.
22:21:49 <EvanR> koz_: i see they kind of ignored your point about inotify not enough enough
22:21:55 <EvanR> because windows
22:22:00 <Axman6> is it doeng O(n) copies every time it finds a match?
22:22:04 <EvanR> inotify not being enough
22:22:26 <Axman6> slash moves
22:23:13 <dmj`> maerwald: the old function chews up 1.3GB
22:28:28 <Axman6> dmj`: I'm curious to see the code
22:28:42 <dmj`> Axman6: https://gist.github.com/dmjio/f6e55815fafcf98900c6924aa168b900#file-main-hs-L88
22:28:56 <dmj`> Productivity  99.9% of total user, 99.7% of total elapsed, 1 MB total memory in use (0 MB lost due to fragmentation)
22:29:16 <Axman6> I've never see productivity that high :o
22:30:20 <phanimahesh> What's productivity?
22:30:49 <Axman6> percentage of time your program was running, as opposed to the GC
22:31:28 <EvanR> if you do it right, the gc won't run and or the program won't allocate 
22:31:43 <EvanR> it's like becoming superfluid
22:31:47 <dmj`> The deduplication occurrs in place, overwriting positions in the original vector, finally returning a slice
22:32:33 <dmj`> EvanR: all Storable Vector code is like that it seems (I'm not using that in the above snippet, but just saying)... when in doubt, FFI.
22:33:04 <dmj`> I'm surprised optimizations play a significant role w/ mutable vectors
22:33:25 <EvanR> i'm always surprised when do notation ends up not allocating anything
22:35:04 <EvanR> even with FFI, if you're juggling pointers around, Ptr is a boxed type
22:35:38 <dmj`> yea but its minuscule in comparison, drop of water into the grand canyon 
22:35:48 <maerwald> dmj`: I was thinking... write a selection sort that uses streamly as output and deduplicate as the values come in :P
22:35:50 <dmj`> just had it off to ST or C and be done with it
22:36:06 <maerwald> then you don't even need Vector API!
22:36:50 <dmj`> ooo yea streamly is very nice
22:37:02 <dmj`> but plot twist, streamly copied vectors internal streaming
22:37:38 <dmj`> but streamly might be something to look into
22:38:33 <dmj`> I just wish I could make this code faster ...
22:38:33 <EvanR> so the implementation was streaming... i mean leaking
22:38:40 <dmj`> :P 
22:39:06 <EvanR> a leak is bad, but full-on streaming is good
22:39:10 <EvanR> go figure
22:39:57 <dmj`> for this use case I just need to efficiently dedupe a vector, if anyone knows any other flags that could make my vector code faster, please share :) using -O2
22:40:01 <maerwald> dmj`: is the dedup slow or the sorting?
22:40:11 <dmj`> maerwald: good question, let me check
22:40:31 <MarcelineVQ> EvanR: the difference is that streaming comes with a faucet
22:40:34 <maerwald> the dedup has a tight loop, but I don't see any thunk build up
22:41:57 <EvanR> can we do any more liquid analogies while we're here?
22:42:10 <maerwald> go !vec !subSlice !runner !ele = ... -- probably won't help much
22:47:44 <dmj`> maerwald: yea its like 100% spent in sorting
22:48:59 <dmj`> I just can't get over the fact it's still slower in some cases, despite using 1MB heap
22:49:26 <dmj`> it's a GC vs. MUT tradeoff
22:51:50 <EvanR> mutable vector write barriers
22:52:20 <dmj`> yea, most likely
22:55:04 <dmj`> EvanR: changing from String to Text really speeds things up, the Eq must be so much faster
22:55:12 <dmj`> causing the sort to speed up
22:57:39 <maerwald> yeah, it checks the length first
22:57:51 <maerwald> and getting length is O(1)
22:58:29 <c_wraith> data locality also helps when repeatedly scanning it
23:07:59 <haskeldjiq> hey guys
23:08:21 <haskeldjiq> using type families, I'm trying to enforce each instance of a class to have an Id constructor of (UUID -> *)
23:08:23 <haskeldjiq> is this possible
23:08:44 <haskeldjiq> e.g. class MyClassWithId a where data Id :: UUID -> *
23:10:19 <haskeldjiq> wait no my thinking is all wrong
23:21:52 <bahamas> in what contexts are the scan functions useful?
23:22:56 <jle`> bahamas: do you mean like scanl, scanr ?
23:23:28 <bahamas> jle`: yes
23:24:43 <jle`> you can kind of think of them like traced versions of foldl/foldr
23:24:50 <jle`> normally when you use foldl/foldr you just get the end result
23:24:58 <jle`> scanl/scanr lets you look at the intermediate steps of evaluation
23:25:24 <jle`> the typical 'tech demo' example is probably to compute a running sum
23:25:25 <bahamas> I notice I have this question about a lot of List functions. in what situations would they help me
23:25:35 <jle`> > foldl' (+) [1..10]
23:25:38 <lambdabot>  error:
23:25:38 <lambdabot>      • No instance for (Num [Integer]) arising from a use of ‘e_1110’
23:25:38 <lambdabot>      • In the expression: e_1110
23:25:45 <jle`> > foldl' (+) 0 [1..10]
23:25:47 <lambdabot>  55
23:26:04 <jle`> > scanl' (+) 0 [1..10]
23:26:06 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55]
23:26:13 <jle`> the first is just a sum, the second is a 'running sum'
23:26:19 <jle`> it gives you all the sums along the way
23:26:36 <bahamas> jle`: yes, that I understand
23:27:15 <bahamas> but I don't know in what situation I would need that. like actually using that when developing software
23:27:46 <jle`> i mean, i don't think there is a general situation where it comes in handy, it just comes up naturally
23:27:51 <EvanR> a lot of data processing tasks can decomposed into simpler list processing subtasks
23:27:53 <jle`> in a lot of different unrelated situations
23:28:04 <jle`> maybe you're simulating a physical system
23:28:11 <pie_> am i missing something here? https://www.fpcomplete.com/blog/2017/06/readert-design-pattern;
23:28:26 <jle`> and your step function is f, so simulating the final state for a given input is like foldl updateFunction initialState [input1, input2, input3]
23:28:35 <pie_> how does 
23:28:35 <pie_> makeLensesWith camelCaseFields ''Env create HasBalance and HasLog?
23:28:47 <pie_> i dont see any mention of "Has" in the lens TH docs
23:28:49 <jle`> and now your client comes along and says "the final state is nice but i want to animate the progression of the state"
23:29:04 <jle`> and now you're like oh crap i only have the final state ...
23:29:06 <jle`> i'm screwed ...
23:29:17 <jle`> but then you remember scanl is like foldl but it gives you the intermediate states so your client can animate them
23:29:30 <bahamas> jle`: that makes sense. you want to trace the path you took to get somewhere
23:30:10 <jle`> pie_: i'm not sure what level of "how" are you are looking for
23:30:14 <bahamas> kind of hard to explain in a short sentence, but at least I understand the purpose
23:30:22 <jle`> pie_: are you asking how template haskell works, how AST works, etc.
23:30:29 * bahamas is creating flash cards with Haskell concepts
23:30:30 <jle`> and the staging rules and stuff
23:30:52 <jle`> bahamas: yeah, there isn't really like a flashy golden example that can encompass all use cases, it's just useful in a lot of different situations
23:31:08 <jle`> kind of like if i asked you why you would ever need to use (+) when developing software
23:31:28 <jle`> the best you could do is like ... give specific situations
23:31:35 <EvanR> a good list of haskell exercises should reveal situations where the list library functions are useful
23:31:43 <pie_> jle`: im just confused because nothing mentions "Has" anywhere, does templatehaskell add that implicitly or is the example bad? i havent tried to run it
23:31:51 <EvanR> but you can't write this list yourself without experience, catch 22
23:31:54 <jle`> pie_: TemplateHaskell adds everything implicitly :)
23:32:03 <jle`> pie_: it adds a lot of things
23:32:12 <jle`> some of them very surprising
23:32:41 <pie_> well, in this case i suppose its a question of what lens is doing with it but thats pedantic for this 
23:32:49 <jle`> but literally everything is implicit when you work with TH
23:32:53 <EvanR> there is a HasField class that is special
23:33:09 <EvanR> TH can make instances of it for you
23:33:09 <pie_> jle`: err right
23:33:11 <jle`> it adds all the lenses, classes, etc. implicitly
23:33:16 <pie_> yeah i get taht
23:33:18 <pie_> *that
23:33:23 <c_wraith> You know, I never was very happy with the compile-time cost of TH, but with generic-lens it seems like the value of the various lens TH bits is significantly lower.
23:33:34 <jle`> pie_: hm. maybe you're just asking if the article has a mistake?
23:33:47 <EvanR> the cost is lower?
23:34:41 <bahamas> jle`: agreed. I just need at least one situation to develop just a tiny bit of intuition by connecting the concept to an example of practical usage
23:35:12 <c_wraith> EvanR: no, the value is lower.  You can just derive Generic and use generic-lens instead of having a th blob for each type.
23:35:17 <jle`> bahamas: running sums themselves come up a lot too
23:35:25 <pie_> jle`: if the article is correct that would mean i can assume `makeLensesWith camelCaseFields ''Env` prepends Has to the field names, and drops the prefix to make this tagless final thingy
23:35:36 <bahamas> EvanR: I assume that list of exercises doesn't exist, does it?
23:35:38 <jle`> bahamas: a common example is the algorithm for picking a random weighted value
23:35:40 <pie_> and that seems like an arbitrary thing to do for a function names makeLensesWith
23:36:08 <jle`> pie_: i mean ... what else would you expect a function with that name to do?
23:36:19 <EvanR> bahamas: there are a few textbooks on haskell with exercises
23:36:27 <jle`> i'm sorry, i guess i'm still unclear on what the question is
23:36:37 <jle`> or what part you are trying to understand
23:36:51 <EvanR> also course notes
23:37:08 <jle`> bahamas: for example, if i had a list like [(Int, a)] where the Int is the relative weight to pick each item from the list
23:37:11 <c_wraith> jle`: I think the assertion is that it's unexpected that lens creates the class and instances instead of just lenses without all the name polymorphism
23:37:32 <jle`> bahamas: you can pick a random number between 0 and the sum of the weights, and find the place where the running sum exceeds your random number
23:37:48 <jle`> ah. so, not a question?
23:38:37 <c_wraith> well, I got a "where is this documented?" question out of it.
23:41:08 <pie_> c_wraith: uh. yeah. that. I think. 
23:42:13 <pie_> I mean I guess I didn't expect it to do anything with typeclasses to begin with but maybe thats just because I don't know lens
23:42:27 <c_wraith> I think that's reasonable to find unexpected.
23:42:42 <c_wraith> It's a convenience rather than a necessity
23:43:19 <EvanR> :t _Empty
23:43:20 <bahamas> jle`: "...the running sum exceeds your random number". the running sum of what would that be?
23:43:20 <lambdabot> (AsEmpty a, Choice p, Applicative f) => p () (f ()) -> p a (f a)
23:43:24 <pie_> c_wraith: https://hackage.haskell.org/package/lens-4.18.1/docs/Control-Lens-TH.html#v:makeLensesWith
23:43:42 <EvanR> prism for types that can be empty... which implement AsEmpty class
23:43:43 <MarcelineVQ> pie_: no it's microlens-th or something doing this
23:43:59 <jle`> bahamas: so let's say you wanted to pick a random item out of the list [(2, 'a'), (4, 'b'), (1, 'c')]
23:44:27 <jle`> bahamas: 'a', 'b', or 'c'.  with the first item being the weights: 'b' is picked twice more likely than 'a', and four times as likely as 'c'
23:44:37 <pie_> oh wait i had case sensitive search on
23:44:49 <pie_> searching in that page for Has at least has mentions of similar looking things
23:44:52 <jle`> bahamas: so you would compute a running sum of [2,4,1]:
23:44:58 <jle`> > scanl (+) 0 [2,4,1]
23:45:01 <lambdabot>  [0,2,6,7]
23:45:05 <MarcelineVQ> I couldn't even find HasBalance's source because appearantly it's being generated by th in the first place via makeFields
23:45:15 <MarcelineVQ> * https://hackage.haskell.org/package/microlens-th-0.4.3.2/docs/Lens-Micro-TH.html#v:makeFields
23:45:41 <jle`> bahamas: and you'd pick a number from 0 to 7, and then go through the cumsum until you find a number bigger than your picked number. and then that's your picked item
23:45:59 <jle`> bahamas: so i pick 5, say. and so then i'd stop after hitting 6, and pick 'b'
23:46:49 <jle`> hm, maybe i implemented that incorrectly
23:47:07 <MarcelineVQ> pie_: i.e. https://hackage.haskell.org/package/bitx-bitcoin-0.12.0.0/docs/Network-Bitcoin-BitX-Types.html#t:HasBalance only exists because  someone wrote makeFields ''Balance below the Balance datatype here https://hackage.haskell.org/package/bitx-bitcoin-0.12.0.0/docs/src/Network-Bitcoin-BitX-Types.html  :( super clear stuff
23:47:09 <pie_> i dont like the way this is done heh :I
23:47:26 <bahamas> jle`: ok, I understand the gist of it. that's an algorithm for weighted random choice
23:47:44 <jle`> i think it was 0 to 6
23:47:48 <jle`> % randomRIO (0,6)
23:47:49 <yahb> jle`: 0
23:47:55 <jle`> in that case we'd pick 'a'
23:47:59 <jle`> % randomRIO (0,6)
23:48:00 <yahb> jle`: 1
23:48:03 <gauga> hi guys! Could someone help a Haskell beginner? 
23:48:08 <jle`> bahamas: yeah, that's it :)
23:48:16 <jle`> gauga: just ask your question :)
23:48:24 <EvanR> pie_: you can write whatever TH generates by hand, and i would if i didn't understand it
23:48:25 <bahamas> jle`: ok. thank you for the explanation
23:48:46 <pie_> by which i think i mean the documentation suck
23:49:09 <jle`> bahamas: but yeah, my point is that even cumulative sum is a common thing used in a lot of different situations :)
23:49:09 <EvanR> blogs might assume you already know a lot too
23:49:19 <gauga> I am writing a function that counts the number of occurences of a list of elements in a list of lists. For example, if I have a list ["a", "rose"] and a listOfLists ["a", "rose", "a"] then I should get back this: [("a", 2), ("rose", 1)] 
23:49:49 <EvanR> blogs often exist to promote the author rather than (just) be educational
23:50:01 <pie_> or maybe im expecting too much , but im not sure how to get from looking at the function doc.....well i guess i could try trawling the source and find transitively all the functions that are getting called to figure out what it does
23:50:03 <EvanR> so they don't want to be too pedestrian
23:50:13 <gauga> sorry, a list of lists, for example [["a", "rose", ["a"]]
23:50:30 <bahamas> jle`: your other example with the all the intermediate steps is more meaningful in my mind
23:50:38 <pie_> EvanR: sure, i feel like im two levels too noob to really get anywhere with these blog posts somehow...
23:50:48 <bahamas> but maybe that's how you express intermediate state, with a cummulative sum
23:50:51 <EvanR> i couldn't ead any of those blogs for years
23:51:01 <pie_> i got to readert from https://markkarpov.com/post/free-monad-considered-harmful.html
23:51:02 <gauga> I have manage to write a function that counts the number of an element in a list of lists, for example countOccurences ["a"] [["a", "rose", ["a"] == 2 ]
23:51:09 <jle`> bahamas: yeah, i suppose the second example is just a situation where intermediate state is useful in specific
23:51:30 <gauga> But how do I run through a list of elements instead of just one element and return a list of tuples with the element and the number of occurences? 
23:51:39 <jle`> gauga: hm, are you sure that [["a","rose",["a"]] is a list of lists?
23:51:54 <jneira_> wow it doesnt should compile
23:52:05 <gauga> sorry, [["a", "rose"], ["a"]]
23:52:25 <jle`> and in the end you just want [("a", 2), ("rose", 1)] ?
23:52:39 <pie_> EvanR: :(
23:52:53 <gauga> yes :)  
23:53:17 <jle`> gauga: hm. in that case it might be easier to just flatten your lists of lists first, before doing anything
23:53:24 <MarcelineVQ> pie_: it's not actuially neccesary to understand the TH to use the concepts this blog conveys though, right?
23:53:32 <jle`> gauga: what is your first list input for, by the way? is it the list of keys you 'care' about?
23:54:00 <EvanR> pie_: there's a subset of haskell which is pretty simple, and almost no blog post limits themselves to it
23:54:00 <jle`> gauga: if you have a way to count the number of occurrences of an item in a list
23:54:01 <gauga> What do you mean by that? 
23:54:15 <jle`> gauga: i mean, what does ["a","rose"] do?
23:54:17 <jle`> how do you use it?
23:54:23 <EvanR> so you gotta work your way up, learning "a GHC extension a day" or some such
23:54:23 <jle`> or, what does the fucntion do with it?
23:54:28 <pie_> MarcelineVQ: yeah but the other stuff isnt exactly skim-through trivial either xD
23:54:50 <jle`> what if i passed ["a","rose"] and [["a"],["rose"],["tiger"]] ?
23:55:31 <haskelllisp[m]> http_request_duration_seconds_bucket{handler="prometheus",method="GET",status_code="200",le="0.005"} 31     what is `handler="prometheus"`?
23:55:39 <gauga> Then you should get this result: [("a", 2), ("rose", 2), ("tiger", 1)]
23:56:25 <gauga> The function should basically be able to count the number of each word appearing in a document. 
23:56:37 <bahamas> haskelllisp[m]: {...} denotes a record. handler is the key and "prometheus" the value
23:56:37 <gauga> the number of occurences of each word
23:56:51 <jle`> gauga: oh, so the two lists are treated equally together as one big document?
23:57:27 <gauga> yes, for example this text "A rose is a rose. But so is a rose."  is encoded as [["a", "rose", "is", "a", "rose"],["but", "so", "is", "a", "rose"]]
23:57:34 <jle`> gauga: this looks different from your first example where you had ["a","rose"] and [["a","rose"],["a"]]
23:57:42 <jle`> gauga: oh...so do you only have one list?
23:57:52 <jle`> one list of lists?
23:57:54 <gauga> yes, one long list of lists
23:58:10 <jle`> ah, okay. so just to be clear, your first example isn't what you are looking for, right?
23:58:16 <jle`> where you give two lists
23:58:18 <gauga> no, I made a mistake there
23:58:32 <haskelllisp[m]> I want to know which Haskell library this data is generated from?bahamas 
23:58:39 <jle`> okay. so you want to take a single list of lists, and output a frequency map
23:58:42 <gauga> the final function should just take a document (one long lists of lists) and return the number of occurences of each word in it
23:58:48 <gauga> yes
23:58:49 <jle`> myFunc :: [[a]] -> [(a, Int)]
23:58:53 <EvanR> pie_: nice article. It mentions final tagless which is pretty far out, but i think it could get complicated under certain circumstances. Which is one of the gripes they had about free monads and combining different ones
23:58:56 <gauga> yes
23:59:03 <bahamas> haskelllisp[m]: where did you find the code?
23:59:19 <jle`> gauga: hm, okay. one way to simplify it would be just to immediately flatten the list
23:59:28 <jle`> so you only have to worry about myFunc :: [a] -> [(a, Int)]
23:59:41 <jle`> you can flatten a list of lists with concat
23:59:58 <jle`> > concat [["a", "rose", "is", "a", "rose"],["but", "so", "is", "a", "rose"]]
23:59:59 <lambdabot>  ["a","rose","is","a","rose","but","so","is","a","rose"]
