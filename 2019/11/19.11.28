00:09:15 <refusenick> Anyone use IHaskell? Tips on installing it with Cabal?
00:11:24 <refusenick> It looks like exactly what I'm looking for. I'd like to embed some kind of interactive animation in it with FRP.
00:49:11 <absence> when you have a handful of records that share many fields, the oo solution is usually to put the common fields in a base class. what's the best way in haskell? copy paste them and use DuplicateRecordFields?
00:51:41 <haskeldjiq> guys I've been using IntelliJ IDEA for some time now but it keeps on crashing constantly
00:51:50 <haskeldjiq> I use it mainly for the ability to instantly go to a library's source
00:51:59 <haskeldjiq> "go to definition" works for any function
00:52:29 <haskeldjiq> can you somehow get that with other editors? as far as I could understand you only get that because of some custom mechanics implemented in the IntelliJ plugin
00:59:39 * hackage tasty-tmux 0.1.0.2 - Terminal user acceptance testing (UAT) via tmux  https://hackage.haskell.org/package/tasty-tmux-0.1.0.2 (romanofski)
01:07:14 <koz_> haskeldjiq: https://vim.fandom.com/wiki/Browsing_programs_with_tags
01:10:23 <haskeldjiq> koz_: I read about tags but they seem to be really hard to setup and inferior to what IntelliJ gives you
01:10:30 <Athas> I'll be giving a lecture about Parallel Haskell this Monday (*not* concurrent Haskell).  Any interesting parallel Haskell programs I should mention as examples?
01:10:43 <koz_> Athas: massiv?
01:10:48 <koz_> (it's a library not a program but still)
01:11:32 <koz_> haskeldjiq: I dunno about 'inferior' (I consider all IDEs to be inferior to what I get with vim anyway), but I'm pretty sure getting tags for your project isn't hard.
01:11:39 <koz_> (at least it's never been that way for me)
01:11:56 <haskeldjiq> so tags gives you that?
01:12:04 <haskeldjiq> you can go to the definition for anything
01:12:06 <haskeldjiq> even library code
01:12:15 <haskeldjiq> external library code*
01:12:19 <Athas> koz_: I suppose... and in that vein, also Accelerate and Repa.  I'd probably pick Accelerate out of the three, since it has much simpler types.
01:12:24 <koz_> haskeldjiq: Unsure about that one.
01:12:37 <koz_> Athas: I guess it depends on what you wanna demonstrate.
01:12:58 <haskeldjiq> koz_: yeah, as far as I could find out it's just intellij-haskell that gives you that but I'm really hoping to be wrong
01:13:36 <Athas> koz_: I'll mostly be talking about task parallelism.  My programming examples will be with the Par monad.  I'd just like to end the lecture with some examples of real parallel Haskell being used.
01:13:52 <koz_> Athas: Ah.
01:13:57 <koz_> Accelerate would be fine then.
01:14:28 <Athas> Unfortunately, Accelerate is a library (as is massiv and repa).  Are there cool applications that use these that I could point at?
01:14:49 <koz_> Athas: Not sure there - maybe someone else here might know.
01:15:52 <koz_> haskeldjiq: Also, you can just use a local hoogle to look up library stuff (it gives you type sigs, but that gets you surprisingly far in Haskell).
01:16:36 <haskeldjiq> koz_: yeah I guess that's what I'll settle with once intero dies
01:16:47 <haskeldjiq> koz_: but being able to browse library code inside the editor is a bliss
01:16:54 <koz_> haskeldjiq: HIE and its various integrational thingos not your jam?
01:17:18 <koz_> Also this? http://marco-lopes.com/articles/Vim-and-Haskell-in-2019/
01:17:54 <haskeldjiq> koz_: they're all great
01:18:11 <haskeldjiq> koz_: it's just this particular feature of intellij-haskell that keeps me there
01:18:19 <haskeldjiq> koz_: and I can't seem to find an alternative
01:19:02 <koz_> haskeldjiq: Check the link I sent you - it seems to be along the lines of what you seek.
01:19:23 <haskeldjiq> koz_: reading that
01:20:43 <haskeldjiq> koz_: yes, it's similar, you still can't get inside the files themselves, though
01:21:06 <haskeldjiq> koz_: but it may be enough to make me learn vim if intellij continues to crash
01:21:09 <jonathan_> No idea how I haven't picked up this yet, but.. how do I explicitly export instance declarations form a module?
01:22:04 <haskeldjiq> jonathan_: you don't
01:22:21 <haskeldjiq> jonathan_: they'll be implicitly exported
01:22:33 <koz_> haskeldjiq: The example shows the definition of a function, plus its docs. I have no idea what more you could possibly want or need in a file you did not write.
01:23:09 <merijn> haskeldjiq: You don't really have to learn vim (I say this as an avid vim user), I'd instead recommend just looking into our lord and saviour LangServerProtocol :)
01:23:25 <haskeldjiq> koz_: getting into the actual file is sometimes useful because you can search around it
01:23:35 <merijn> haskeldjiq: Both HIE and ghcide implement LSP, so you should be able to hook any editor with LSP support to them
01:23:56 <koz_> merijn: Can you run LSP stuff without needing Stack anywhere?
01:23:57 <merijn> koz_: Who says you're only jumping to definitions of files you didn't write?
01:24:03 <haskeldjiq> koz_: e.g. going to the definition of decodeEither (from aeson) and being able to search for other decode functions inside is very convenient
01:24:04 <jonathan_> haskeldjiq: ah, okay
01:24:19 <merijn> koz_: I've been using ghcide without stack, it's still a bit brittle manual setup-y, but it's crazy fast
01:24:25 <haskeldjiq> koz_: e.g. I just found eitherDecodeStrict that way like 2 minutes ago
01:24:36 <koz_> merijn: I have never managed to get that thing working correctly.
01:24:55 <koz_> I'll stick to my 'hack around ALE' solution for now, I guess. :P
01:25:03 <merijn> koz_: I'm using ALE
01:25:10 <merijn> koz_: With ghcide in LSP mode
01:25:14 <merijn> koz_: https://github.com/merijn/dotfiles/blob/master/dotfiles/vim/autoload/ale_linters/haskell/ghcide.vim
01:25:31 <koz_> merijn: I will have to look into that, thanks!
01:25:34 <merijn> koz_: There's the necessary ALE wrapping for ghcide in LSP mode
01:25:55 <merijn> koz_: At some point I'll try and get it merged into ALE
01:26:09 <koz_> merijn: I might have to give that a whirl. Thanks!
01:26:22 <koz_> (if you could get that merged into ALE, I'll buy you an ale)
01:26:27 <koz_> (assuming you want one)
01:26:29 <merijn> koz_: Together with this: https://github.com/merijn/dotfiles/blob/master/dotfiles/vim/ftplugin/haskell.vim#L1-L9
01:27:07 <koz_> Oh, nice.
01:27:51 <bahamas> does anyone have a list of recommended ghc flags to use?
01:28:19 <bahamas> -fwarn-incomplete-patterns for example
01:28:28 <koz_> bahamas: I go with Alexis King's suggestions: https://lexi-lambda.github.io/blog/2018/02/10/an-opinionated-guide-to-haskell-in-2018/
01:28:36 <bahamas> koz_: thanks!
01:33:17 <koz_> "It's important that ghcide is compiled with the same compiler you use to build your projects.
01:33:20 <koz_> " <-- argh
01:33:53 <MarcelineVQ> same architecture and version at least
01:35:20 <bahamas> koz_: ghcide has a nix setup and, if you use cachix, you don't have to compile everything
01:35:28 <bahamas> in case you didn't stumble upon that
01:35:50 <koz_> bahamas: I don't use nix, so I didn't even notice that.
01:36:14 <bahamas> koz_: it's easy to install it. you don't have to care about it, other than to install ghcide
01:36:43 <merijn> bahamas: Opinionated guide to recommended GHC flags: -Wall and disable anything you really don't want (probably only just -Wno-unused-do-binds)
01:36:45 <bahamas> if you use Linux and Mac OS before Catalina, that is
01:37:13 <bahamas> merijn: the link koz_ recommended says that -Wall doesn't enable everything
01:37:22 <merijn> bahamas: It enables everything *sensible*
01:37:54 <merijn> Almost everything *not* in -Wall is controversial and/or niche applicability
01:38:17 <merijn> Ok, -Wcompat might also be good
01:38:23 <bahamas> merijn: so you disagree with enabling -Wincomplete-record-updates and -Wincomplete-uni-patterns
01:40:45 <merijn> bahamas: I mean, you could, but honestly those are niche because -Wall already warns about partial record accessor in the record definition, so -Wincomplete-record-updates (which only warns for uses of them) seems rather redundant
01:41:38 * hackage niv 0.2.3 - Easy dependency management for Nix projects  https://hackage.haskell.org/package/niv-0.2.3 (nmattia)
01:42:34 <bahamas> merijn: is there any harm in using it? I mean, if you're a beginner isn't it better to use those flags?
01:42:52 <bahamas> I, at least, tend to lean towards strictness
01:44:06 <merijn> and incomplete-uni-patterns I don't use because the only real use I have of uni-patterns is when I *explicitly* wanna bypass incomplete warnings :p
01:46:06 <bahamas> I don't know what uni-patterns are :)
01:46:09 <merijn> bahamas: Well, it's not that I'd consider those two harmful, but they are very unlikely to be something you'd ever actually trigger :p
01:46:30 <merijn> > map (\(Just x) -> x) [Just 2, Just 3]
01:46:32 <lambdabot>  [2,3]
01:46:53 <merijn> bahamas: That lambda's pattern is a uni-pattern (since you can't have multiple patterns in a lambda
01:47:25 <boxscape> > let Just x = Nothing
01:47:27 <lambdabot>  <no location info>: error:
01:47:27 <lambdabot>      not an expression: ‘let Just x = Nothing’
01:47:28 <boxscape> this too?
01:47:30 <boxscape> wait
01:47:35 <boxscape> > let Just x = Nothing in x
01:47:37 <lambdabot>  *Exception: <interactive>:3:5-20: Non-exhaustive patterns in Just x
01:48:13 <bahamas> merijn: ah, so if the list contains Nothing, there's an error
01:48:30 <merijn> bahamas: Yeah
01:49:02 <merijn> boxscape: lambdabot doesn't report warnings
01:49:24 <merijn> (I'm not sure if it warns, actually)
01:52:04 <merijn> bahamas: Yeah, but personally those uni-patterns seem rather obviously wrong, so whenever I do write them it's intentional and I don't want a warning
01:55:09 <merijn> ugh...I'm gonna write a Haskell bot that downvotes anyone on reddit still trodding out that tired "monads are just a monoid in the..." "joke" >.>
01:55:37 <Athas> Yeah, I'm also a monad=burrito joke adherent.
01:56:41 <merijn> Athas: I'm an adherent of the "burritos for the working mathematician" joke from SIGBOVIK
01:56:59 <merijn> Tired: Monads are like burrito
01:57:11 <merijn> Wired: Comands are like burritos. It's hard to keep things inside
01:57:18 <merijn> s/Comands/Comonads
01:58:08 <MarcelineVQ> comonads are a world of burritos inside a universe of burritos
01:58:28 <merijn> Meeting time
01:59:57 <bahamas> what do you think about labeling in the documentation functions which should be avoided?
02:00:20 <bahamas> on this page, for example http://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html
02:00:42 <bahamas> I know there are alternative preludes that avoid these functions. but you have to know about them to find them
02:05:00 <boxscape> That might be a bit opinionated and subjective, but a good start would be to explicitly say which functions are partial and how
02:06:22 <maerwald> Prelude.Unsafe is fine
02:06:27 <maerwald> name the module properly
02:06:43 <bahamas> maerwald: that doesn't exist, does it?
02:06:52 <maerwald> nope, but in alternative preldues that's how they do it
02:07:12 <maerwald> no one reads documentation ;)
02:07:33 <bahamas> yes, I've seen that.
02:07:48 <bahamas> until that gets added to the standard Prelude, a change to documentation is easier to adopt
02:08:16 <bahamas> and I realize that some things are subjective, but almost every opinion I hear says you shouldn't use String for example
02:08:17 <maerwald> just start a deprecation phase for the old ones, give it two years, then remove
02:08:29 <bahamas> there's no mention in the Prelude about it though
02:08:34 <maerwald> compiler will tell people to use Prelude.Unsafe instead
02:08:50 <bahamas> maerwald: do you think the compiler maintainers are likely to accept that?
02:08:58 <maerwald> that's not about the compiler
02:09:05 <maerwald> you can annotate deprecations in your code
02:09:57 <bahamas> I meant whoever maintains base and the standard Prelude
02:10:29 <maerwald> no idea, but that's how people have done it in C for decades and it works fine
02:10:35 <maerwald> No idea why people don't do it in haskell :)
02:10:52 <bahamas> I guess someone has to come with the initiative and spearhead it
02:11:10 <maerwald> yeah, politics...
02:27:37 <f-a> hello. I am having some data in IntMap and I found myself doing simple query over those (only take values from intMapBeta whose IDs are from intMapAlpha where a certain condition is met). IntMap facilities (unions, intersections, etc.) seem adequate but I wonder if there already is a library for this or a better datatype to approach the problem.
02:29:58 <Athas> f-a: I think the best you can do is intersection combined with filtering.
02:31:51 <f-a> that will do!
04:29:28 <merijn> hmm, I get a weird ghci crash on an undefined symbol in a local package, despite the compile and link of said package working fine
04:30:51 <merijn> Any idea how I would even start debugging this nonsense?
04:36:19 <argent0> what's your build tooling like?
04:36:52 <merijn> Just v2-build
04:45:21 <leo__> Any way to make optparse-applicative skip unknown options?
04:45:41 <merijn> leo__: Yes, but I forgot which
04:45:53 <leo__> xd
04:46:20 <leo__> I'm trying hard.
04:46:30 <merijn> leo__: https://hackage.haskell.org/package/optparse-applicative-0.15.1.0/docs/Options-Applicative.html#v:forwardOptions
04:46:59 <leo__> Exactly that!
04:47:13 <leo__> I read that for a while, was even testing Common, Types, ...
04:47:14 <f-a> leo__: not my place to judge, but for some a program that doesn't explode on wrong options could be bad UX
04:47:19 <leo__> And didn't see.
04:47:32 <leo__> Thanks merijin!
04:47:39 <leo__> I was gonna give up and filter getArgs ...
04:48:00 <leo__> f-a: In this case it's not.
04:48:04 <leo__> "This is sometimes useful if one is wrapping a third party cli tool and needs to pass options through"
04:48:07 <leo__> This is my case.
04:48:27 <f-a> fair!
04:48:28 <leo__> merijn*
04:50:48 <merijn> cocreature: Do you have any clue whether it's possible (and if so where/how) to make use ghcide use -fobject-code?
04:52:11 <cocreature> merijn: at the moment it isn’t I believe
04:53:08 <merijn> cocreature: I noticed the PR that fixes the TH issue, which indeed solves it for me, but I run into the same ByteCodeLink.lookupCE, which iirc can be solved by using -fobject-code, but I'm not sure if I remember that correctly
04:53:41 <merijn> otoh, ghci seems to work fine without -fobject-code, so that's odd
04:54:42 <leo__> merijn: forwardOptions is not working. weird.
05:01:41 <leo__> Oh, never mind.
05:08:09 * hackage streaming-postgresql-simple 0.2.0.4 - Stream postgresql-query results using the streaming library  https://hackage.haskell.org/package/streaming-postgresql-simple-0.2.0.4 (OliverCharles)
05:12:39 * hackage mandrill 0.5.4.0 - Library for interfacing with the Mandrill JSON API  https://hackage.haskell.org/package/mandrill-0.5.4.0 (OliverCharles)
05:16:03 <alvert> hi
05:34:39 <argent0> hello
05:43:39 * hackage mmsyn6ukr 0.3.0.0 - Can be used as a musical instrument synthesizer or for Ukrainian language listening  https://hackage.haskell.org/package/mmsyn6ukr-0.3.0.0 (OleksandrZhabenko)
05:45:50 <svipal> is it possible to have multiple default definitions for typeclasse methods
05:46:04 <svipal> depending on what other methods were or not defined 
05:47:58 <opqdonut> scivola: no, not really
05:48:03 <opqdonut> scivola: sorry, not you
05:48:06 <opqdonut> svipal: no, not really
05:48:31 <opqdonut> usually it's enough to make the default definitions depend on each other
05:48:53 <svipal> that would be rad, though I guess you can make do 
05:48:57 <opqdonut> but if you want, you could export definitions like implementFooWithBarAndQuux
05:49:29 <opqdonut> so then the user would do something like: instance MyClass MyType where bar = ...; quux = ...; foo = implementFooWithBarAndQuux
05:49:29 <boxscape> I suppose if you have a class A containing methods a, b and c you could make one class A1 with methods a and b and class A2 with c and b and then instance A1 => A and A2 => A that derive the missing method
05:49:45 <opqdonut> yeeah that could work too
05:49:58 <opqdonut> need flexibleinstances though?
05:50:26 <boxscape> why is that?
05:52:38 * hackage mmsyn6ukr 0.3.0.1 - Can be used as a musical instrument synthesizer or for Ukrainian language listening  https://hackage.haskell.org/package/mmsyn6ukr-0.3.0.1 (OleksandrZhabenko)
05:53:57 <opqdonut> boxscape: won't the instances 'A1 t => A t' and 'A2 t => A t' overlap?
05:54:09 <boxscape> oh, you're right
05:54:31 <svipal> opqdonut : yep, I'm doing that
05:54:36 <opqdonut> and FlexibleInstances was the wrong extension, I guess Overlapping or Undecidable?
05:55:21 <opqdonut> oh, interesting
05:55:23 <opqdonut> > These extensions are now deprecated (since GHC 7.10) in favour of the fine-grained per-instance pragmas.
05:55:25 <lambdabot>  <hint>:1:54: error: parse error on input ‘in’
05:55:30 <boxscape> overlapping pragmas, yeah. I don't actually think that would really help here, though. Ime overlapping is usually to prefer a more specific over a general insatnce
05:55:35 <opqdonut> gah I always forget you can't use > as a quote here
05:55:37 <boxscape> these are equally general
05:55:41 <opqdonut> yep
05:55:46 <boxscape> so I think the compiler would always pick the same one
05:56:12 <merijn> There's a trick to provide a default implementation using another typeclass IFF you control the source of the class being instantiated
05:56:38 <boxscape> (I keep forgetting that superclass constraints aren't included when checking for overlapping instances...)
05:56:40 <merijn> Slightly more verbose than having a general instance, but less error prone and still fairly minimal boilerplate
05:56:47 <absence> anyone know what "ElF" is short for here? http://hackage.haskell.org/package/vinyl-0.12.0/docs/Data-Vinyl-Tutorial-Overview.html
05:58:23 <merijn> svipal: What sorta conditionality do you wanna accomplish?
06:00:18 <svipal> it was just : if the method mA that returns a lens is defined then use it for method mB , if not, let 's just defer (if you remember what I did with the defer thing) the method to the undernode
06:02:05 <nil> absence: acowley might know
06:02:40 <svipal> with the type of mB being a -> b and mA :: Lens
06:02:58 <merijn> svipal: I have no idea what you mean with the "defer thing" :) But I don't think there's really a way to do that, no
06:03:23 <svipal> that' s alright. also, cut message
06:04:54 <merijn> I also think it's kinda undesirable to have an implementations depend on things like that. You could split into multiple classes and maybe check that way, but I probably wouldn't
06:11:42 <boxscape> @pl \x (old, new) -> (new, x:new)
06:11:42 <lambdabot> (. snd) . ap (,) . (:)
06:25:25 <tdammers> fun observation: if you import two modules qualified into the same namespace alias (import Foo as Baz; import Bar as Baz), and one of them fails to compile, then accessing identifiers from the module that did compile successfully produces an error message saying that no such module was imported
06:41:04 <boxscape> -fimplicit-import-qualified, if you try to access a non-existing function in an existing module, it will also say that no such module was imported, even though all modules were imported
06:41:35 <boxscape> (mentally prepend a "with" to that message)
07:07:52 <boxscape> I managed to implement para for Lists in terms of cata. Is it possible to write a function implementing para in terms of cata in general, for any suitable type? From my definition it doesn't look like it to me
07:08:42 <haskeldjiq> guys anyone willing to think along?
07:08:45 <boxscape> (this is my implementation: https://pastebin.com/raw/Kgd8d1af )
07:09:21 <Ariakenom> I would like to keep join & part messages but matrix's server stability is changing my mind
07:09:39 <haskeldjiq> nevermind perhaps tomorrow
07:26:39 * hackage hspec-bracket 0.0.1.0 - The bracket definitions for Hspec  https://hackage.haskell.org/package/hspec-bracket-0.0.1.0 (KeiHibino)
07:27:03 <[exa]> Ariakenom: quite related, I don't really recall a user with the matrix [m] talking here
07:27:19 <merijn> Sometimes
07:43:33 <Ariakenom> yeah sometimes
07:54:38 * geekosaur notes that matrix has as many lurkers as direct IRC does
07:57:46 <sm> I've talked as [m] quite a bit. Unfortunately the matrix freenode bridge has been screwed up on and off for the last two weeks.. hopefully stable again soon
07:58:59 <sm> when its working, riot makes a great modern IRC client for persistence, notifications, and mobile access
07:59:43 <robotmay> They've certainly improved the GUI a lot in the past year. Been a while since I used it though
07:59:54 <alx741> would it ever be possible to write mobile -top to bottom- apps completely in Haskell/dialect? I'm sick of java,kotlin,swift
08:00:53 <maerwald> including frontend?
08:00:58 <robotmay> Elm might be more likely I guess, as it could build on top of some of the multiplatform JS stuff?
08:01:09 <geekosaur> one can use ghcjs but it's fairly heavy. I rhink haskell backend + purescript or elm is somewhat common?
08:01:10 <robotmay> I'd be pretty into that actually
08:01:20 <maerwald> haskell + typescript is a good choice
08:01:26 <maerwald> purescript community is too small
08:01:38 <alx741> perhaps Elm/purescript -> JS with nativescript...
08:02:47 <alx741> A Haskell transpiler to Dart, to leverage Flutter would be grand
08:02:52 <merijn> alx741: Possible, sure
08:03:03 <geekosaur> "purescript community" yet we're talking haskell backend :)
08:03:03 <merijn> alx741: It's not a polished and well-tested path, though
08:03:33 <merijn> alx741: All/most of the individual parts are there, getting them all to walk and setting up a toolchain will be painful, though'
08:03:37 <maerwald> geekosaur: what do you mean?
08:04:01 <alx741> merijn: yeah, I'm sadly aware of that :(
08:04:08 <geekosaur> we're not exactly a large community either (granting the size of the channel, but how many participate?)
08:04:25 <maerwald> geekosaur: haskell community is not small and there are at least 2 major consulting companies
08:04:30 <geekosaur> especially compared to the number of JS programmers out there
08:04:39 <merijn> alx741: I know Cale at some point was working on a game on mobile written in Haskell, and to the best of my knowledge it worked once the initial setup effort was done
08:05:08 <alx741> merijn: including the UI?
08:05:11 <maerwald> also, I think on the frontend... tooling is much more important
08:05:17 <merijn> alx741: So it's mostly a matter of "how much effort and time are you willing to invest"
08:05:26 <maerwald> because you're developing more "interactively" 
08:05:42 <merijn> alx741: I suppose they just used OpenGL, etc. so not sure about interacting with platform GUI toolkits
08:05:53 <maerwald> with a haskell backend you can get away with less fancy tools, although it might still be annoying
08:06:46 <merijn> alx741: That said, calling out to/being called from C is really easy, so binding existing C APIs for toolkits is fairly straightforward (but might not let you program at a nice level of abstraction without extra effort)
08:07:57 <alx741> yeah... the effort that would be required kind of levels up with the hassle/pain of writing native
08:09:09 <alx741> The Haskell/Dart(flutter) transpiler would give a good level of abstraction and kind of straight forward development framework
08:30:51 <an_user> hey folks, do you know any examples of grammars for parsing columnar table data?
08:38:32 <an_user> brb
09:20:51 <an_user> def show_diagram(graph, log=False):
09:20:51 <an_user>     with io.StringIO() as f:
09:20:51 <an_user>         d = Diagram(graph)
09:20:51 <an_user>         if log:
09:20:51 <an_user>             print(d)
09:20:52 <an_user>         d.writeSvg(f.write)
09:20:55 <an_user>         mysvg = f.getvalue()
09:20:57 <an_user>         return mysvg
09:21:01 <an_user> oops
09:21:03 <an_user> sorry
09:23:45 <Athas> Parseltongue!
09:23:49 <sm> what is this witchcraft!
09:29:36 <Cale> alx741: The UI was just more OpenGL stuff, so yeah
09:30:16 <Cale> alx741: Our company was actually responsible for some of the earliest ARM and iOS toolchain support in GHC
09:33:08 <Cale> (that was back in 2009 or so)
09:45:38 * hackage tmp-postgres 1.22.0.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.22.0.0 (JonathanFischoff)
09:50:13 <alx741> Cale: nice, no so different from what Flutter does... Any blog posts/articles on that?
09:54:54 <hxhfhjkl> anyone have spacemacs setup with a stack backend and working autocompletion?
10:05:16 <robotmay> Asking due to inability to Google properly today: how should I go about converting a `ActionCtxT ctx0 m0 Data.ByteString.Internal.ByteString` type into a String? It's the request body in a Spock action, if that helps :)
10:07:41 <robotmay> I feel like I need to unwrap it or something
10:08:00 <robotmay> (new to haskell so almost certainly using the wrong terminology/wrong everything)
10:10:37 <Putonlalla> Considering the `Internal` bit, you should not be touching it directly, robotmay.
10:10:53 <Putonlalla> There ought to be some function that does the conversion for you.
10:12:02 <robotmay> Ah ha, I'll have a poke about in the Spock source then and see if I can find it
10:12:12 <nshepperd2> That's just because they haven't imported Data.ByteString
10:16:11 <nshepperd1> robotmay: that value is not the request body, it's a spock action that fetches the request body for you
10:16:42 <robotmay> Ohhh. Any idea how to make it return the body as a string?
10:17:42 <gaze__> hey guys, what's the right way to parse a nested thing using megaparsec? or just vanilla parsec?
10:18:01 <gaze__> I see this between/charliteral is good for quotes
10:18:02 <nshepperd1> robotmay: what you want to do is combine that action with your own, by writing body >>= \b -> your_spock_action_here
10:18:16 <gaze__> but that needs escapes
10:18:40 <nshepperd1> robotmay: in the scope of your_spock_action_here, b is the request body as a ByteString
10:18:41 <Rembane> gaze__: Use between but be very careful to not match on the delimiters in the errr... body
10:20:19 <refusenick> Can Haskell code be represented as a Haskell data structure?
10:20:39 <nshepperd1> robotmay: that code reads "first fetch the request body, then do your_spock_action_here with it"
10:21:04 <refusenick> Template Haskell is a thing at compile time, but I'm interested in runtime aspects.
10:21:21 <robotmay> nshepperd1: Oh that makes a bit more sense, thanks! I'll try mashing it into my code and see if I actually understand :D
10:26:34 <robotmay> Right, got to the ByteString itself. What's the best way of converting that into a String? I seem to have turned up many different options
10:27:27 <refusenick> robotmay: The default String is a lazily-evaluated list of Chars. No bueno.
10:27:36 <refusenick> I've heard that Text is the standard option.
10:27:47 <robotmay> I'm trying to get the request body into a megaparsec parser if that helps
10:27:57 <robotmay> And it whinges that Text isn't a String :\
10:29:36 <robotmay> Couldn't match type ‘Text’ with ‘[Char]’
10:29:36 <robotmay>       Expected type: String
10:29:36 <robotmay>         Actual type: Text
10:29:36 <robotmay>     • In the second argument of ‘parse’, namely
10:29:36 <robotmay>         ‘(Text.Encoding.decodeUtf8 b)’
10:29:42 <robotmay> If that helps
10:29:46 <nshepperd2> You can convert ByteString into text with decodeUtf8
10:30:04 <nshepperd2> Then turn Text into String with unpack
10:30:30 <nshepperd2> Data.Text.unpack, that is
10:30:33 <robotmay> Aaah cool, thanks; I'll try that
10:30:49 <nshepperd2> That said, i would have thought megaparsec supports Text directly
10:31:04 <yushyin> it does support Text
10:31:05 <robotmay> Yeah I'm wondering if I've ballsed it up somehow
10:33:44 <nshepperd2> Oh, you've probably put String in your parsers type sig
10:34:50 <robotmay> Yeah I did have that, getting a couple of new errors now. Will chuck up a gist of the current state, maybe it's something obvious (first time I've tried writing a parser in Haskell)
10:35:22 <nshepperd2> Well, unpack will work for now, no need to try to switch it over to Text just yet
10:35:25 <gaze__> Rembrane : Eh what if it's a deeply nested thing
10:35:37 <gaze__> I'm parsing a bibtex file
10:35:51 <gaze__> it's like @article{foo={x},bar={{y}}}
10:37:05 <robotmay> https://gist.github.com/robotmay/96cd7c8f9bf71500fecea85eede26000 <- trying to take Heroku logdrain as an input, if you're wondering what the goal is :D
10:42:22 <nshepperd1> robotmay: so the two conversion functions for Text <-> String are Text.pack and Text.unpack
10:42:28 <robotmay> Managed to solve the second error by using Text.pack btw, but it still throws the String error
10:43:16 <nshepperd1> For the first error, you need to apply Text.unpack to the decoded body to turn it into a String
10:43:25 <nshepperd1> Then you should be good
10:44:08 <robotmay> nshepperd1: Ah ha, that sorted it! Thanks :D
10:46:00 <nshepperd1> Btw, 'body >>= \b -> stuff' is equivalent to 'do b <- body ; stuff'. The latter might fit your style here more
10:47:17 <robotmay> Aaah cool. Yeah I'm coming from Ruby (and Elm more recently) and I've probably been writing Haskell/Elm very oddly :D
10:52:24 <robotmay> I feel like I'm almost starting to understand vaguely what's maybe going on in Haskell
10:52:26 <robotmay> Maybe
11:15:21 <robotmay> I'm now up to the point where I have an `Either (ParseErrorBundle Text Void) Log)` value. How do I go about unwrapping that into just the Log value? (tried searching for the past 15 minutes and just finding a lot of guff without any examples)
11:16:45 <merijn> robotmay: You can just pattern match on the either?
11:17:19 <AndreyH> Just "Right log" I suppose
11:17:20 <robotmay> I tried (Right blah) and it goes all wonky, guess I'm doing something wrong?
11:17:23 <merijn> robotmay: "case yourResult of Right log -> log; Left _ -> {- handle error somehow -}"
11:17:44 <robotmay> Ooh ta, I'll try writing it out like that, might make it more obvious what I've ballsed up
11:26:42 <robotmay> I've figured out why megaparsec wanted a string. I was trying to give the input as the name of the file >.>
11:27:05 <robotmay> Ahem, I'm er, gonna leave that there for the night
11:37:41 <boxscape> Does having template haskell enabled in and of itself increase compilation times?
11:38:07 <merijn> boxscape: It shouldn't, at least not significantly
11:38:10 <boxscape> ok
12:17:25 <refusenick> Anyone use Asterius with Cabal?
12:18:30 <merijn> refusenick: Probably better off just asking your question :p
12:18:45 <refusenick> merijn: I haven't even tried to install it yet, tbh
12:18:51 <dsal> Is   `Either a ()`  weird or should I do something else?
12:19:04 <refusenick> I want to use it to generate a static animated page with WebGL
12:19:10 <dsal> Maybe I actually just want throwIO here.
12:19:13 <merijn> dsal: Seems fine if something can return an error
12:19:22 <merijn> dsal: For libraries, export both
12:19:38 <merijn> dsal: I'm a firm believer that exceptions should be "opt-in" for library APIs
12:19:38 <refusenick> conal 's work on compiling to categories to generate GLSL for WebGL seems like exactly what I'm looking for.
12:19:47 <refusenick> I've never done webdev, though
12:20:09 <dsal> merijn: yeah, that's a good way to think about it.  I'm running this over wreq so all kinds of things could fail at a lower level.
12:20:27 <refusenick> No Haskell, either. Elm is starting to look appealing, but there's all that webdev ecosystem bloat and baggage
12:21:09 <merijn> refusenick: Learning both haskell and webdev at the same might be...frustrating :p
12:21:36 <refusenick> merijn: I just want to make animations in something other than IPython
12:22:01 <refusenick> I installed IHaskell with Cabal and ran "ihaskell install" after, but Jupyter fails to connect to it.
12:22:08 <dsal> In the meantime, this works, though.  :)   heatSeat :: AuthInfo -> VehicleID -> Seat -> Int -> IO CommandResponse
12:22:36 <merijn> refusenick: webdev itself is frustrating and (some people at least) get frustrated in the beginning learning haskell, so doing both at the same time might extra frustrating
12:22:58 <refusenick> merijn: I'm fine with being frustrated for a time if I learn something.
12:23:03 <dsal> I'm controlling my car's heated seats from haskell.  I'll add this to my MQTT thingy that collects data and automate junk for no good  reason.
12:23:10 <refusenick> (where something != life lesson on "don't do this")
12:23:59 <refusenick> dsal: Have you seen https://joeyh.name/blog/entry/my_haskell_controlled_offgrid_fridge/
12:24:03 <merijn> refusenick: edwardk has a bunch of shader toys he ported to Haskell, so that might be interesting for you
12:24:59 <boxscape> can you not use guards in a lambda with something like "\n | n > 0 -> []"?
12:25:04 <boxscape> I guess MultiWayIf might have to do
12:25:09 <dsal> refusenick: neat.  I do silly automation stuff in haskell.
12:25:15 <merijn> refusenick: https://github.com/ekmett/quine
12:25:44 <dsal> I had a pipe break last weekend and now I get alerts when my pump is using too much power.  I just realized that's one of the few bits of this I didn't write in haskell.  That's sad.
12:25:46 <refusenick> merijn: Will look at his repo. Thanks for the rec. I see gelisam's frp-zoo repo uses FRP libraries as a control backend to control Gloss. Would it be hard for me to write a functional reactive wrapper for his stuff?
12:26:18 <refusenick> I'm working on a classical mechanics simulation for a class presentation and would like to give people something they can play with to illustrate my points.
12:26:38 <merijn> refusenick: I have no idea, tbh :)
12:26:50 <boxscape> is there a good reason I'm missing why "\n | n > 0" shouldn't work?
12:27:01 <refusenick> I'm almost done with a Python version, but I feel like with Haskell, I could show the code for partial derivatives and Lagrangians and explain it if need be.
12:28:30 <conal> refusenick: if you give it (Haskell-to-WebGL via compiling-to-categories) a try, I'd love to hear. There's room for improvement in optimizations, but it's a much simpler foundation than my previous Haskell-to-GPU compilers and with an ideal API, and I'd love to see it get more use.
12:28:41 <refusenick> Unfortunately, IHaskell isn't connecting for me. Do I need to add a directory to $PATH? I see ~/.ihaskell, but it's empty.
12:29:40 <refusenick> conal: It seems especially appealing because the technique helps with automatic differentation, which I hope might make the presentation of the math as simple as possible.
12:29:48 <conal> There's probably a very nice way to program GUIs via compiling-to-categories (CtoC) as well, akin to http://conal.net/papers/Eros/
12:29:59 <merijn> conal: Oh, this is a thing that exists already? Got any links?
12:31:15 <refusenick> I was wrong - there's a .kernel_profile file in ~/.ihaskell.
12:31:29 <conal> refusenick: yes, indeed, combining AD with WebGL generation. I did so with http://conal.net/Vertigo/, but the new implementation should be much smoother, and again an ideal API (regular Haskell).
12:32:19 <conal> merijn: https://github.com/conal/concat contains Haskell-to-WebGL as an example of CtoC.
12:32:31 <conal> merijn: see the README there.
12:34:24 <merijn> conal: Cool, I'll have a look
12:34:35 <conal> I'm trying 'stack build :graphics-examples' there right now to see if it works with GHC 8.8.1. 
12:34:51 <conal> If not, then 8.6.5 should do it.
12:35:46 <conal> merijn: enjoy. and please let me know how it goes. i've not done much with it lately.
12:37:09 <refusenick> conal: If I wanted to do functional reactive animation in IHaskell atop concat, what would be your recommendation of FRP library?
12:37:29 <merijn> conal: I will :)
12:37:41 <refusenick> varying has been pretty intuitive so far with desktop stuff
12:38:48 <conal> refusenick: i don't know about a decent FRP library, but getting CtoC-generated WebGL in IHaskell would be great. I looked for help doing exactly that a few years back (just the WebGL part) and didn't find any.
12:39:04 <dsal> I should get lunch... https://www.irccloud.com/pastebin/1bUxkShn/hvac%20and%20seats
12:39:14 <refusenick> conal: That's why the issue is still open?
12:39:28 <conal> refusenick: the choice of FRP-ish library might not matter much, ie easy to change.
12:39:39 <refusenick> conal: That's good to hear.
12:39:41 <conal> refusenick: what issue?
12:40:09 <merijn> conal: Man, if you don't know about a decent FRP library, what hope does the rest of us have? :p
12:40:14 <refusenick> https://github.com/gibiansky/IHaskell/issues/619
12:40:51 <boxscape> What would be the best recursion scheme for something like `take`? cata works, but I imagine one of the schemes abstracts out the pattern you need for that
12:42:41 <conal> refusenick: oh, yeah. that issue.
12:43:57 <Athas> conal: I'm fascinated by the idea of doing lighting via AD (cf. your GitHub issue).  Did you do a writeup of that somewhere?
12:44:10 <conal> I just tried Haskell-to-WebGL via CtoC on GHC 8.8.1. Worked fine.
12:44:30 <refusenick> conal: Would it be easier for me to create a bare HTML/CSS webpage (what I know), embed a WebGL object, and link it to the compiled Haskell output?
12:46:13 <conal> Athas: Yes: http://conal.net/papers/Vertigo/. I defined a simple and general denotational model of lighting, shading, etc, directly in (genuinely functional, i.e., no IO) Haskell, and compiled it to GPU code.
12:47:32 <conal> refusenick: for graphics, the compiler generates WebGL code as text. if you figure out how to embed WebGL code into IHaskell, then connecting with the compiler should be easy.
12:49:10 <refusenick> conal: I can't even get IHaskell to run right now.
12:49:15 <refusenick> What hope do I have? lol
12:50:02 <refusenick> It sounds like I might go with the static page option for now. Seems doable.
12:50:37 <boxscape> is there a more elegant way to write this?
12:50:38 <boxscape> (if n > 0 then first else second) (cons x) (more $ n - 1)
12:50:40 <refusenick> I'd definitely like to take a shot at IHaskell in the near future, though.
12:50:44 <zincy_> What is a subtype?
12:51:02 <refusenick> zincy_: Cat and Dog are subtypes of Animal
12:51:17 <Athas> conal: cool, thanks!
12:51:32 <refusenick> zincy_: C++/Java inheritance, basically
12:53:17 <conal> refusenick: On second thought, I guess we'd really want to get the CtoC GHC plugin into IHaskell somehow, so that one could edit Haskell code in the page and have it generate WebGL on the fly and run it in some kind of display widget in the page.
12:53:57 <conal> refusenick: I don't know whether IHaskell can work with GHC plugins, but if not yet, maybe it could be.
12:54:08 <zincy_> thanks
12:58:04 <boxscape> So -XRebindableSyntax desugars `if then else` into whatever function `ifThenElse` is in scope, however, there doesn't seem to be a function with that name in the base library. Is that right?
12:58:10 <conal> ... could be *improved*.
12:58:50 <merijn> boxscape: Might be, I dunno
13:38:33 <refusenick> Can Asterius compile itself to WebAssembly?
13:59:00 <AWizzArd> Is the approach described at https://lexi-lambda.github.io/blog/2016/10/03/using-types-to-unit-test-in-haskell/ called „tagless final”?
14:11:53 <MarcelineVQ> I wouldn't say so. There's a rather involved explanation of what tagless final entails here http://okmij.org/ftp/tagless-final/course/lecture.pdf
14:12:53 <AWizzArd> MarcelineVQ: reading it, just wanted a hint ahead of time :)
14:12:55 <MarcelineVQ> The mocking-via-typeclasses method lexi-lambda uses is, afaik, fairly well known but I don't know if it has a specific name
14:14:53 <an_user> how does one normally parse a line with parser combinators? though i happen to be trying to use pythons parsy library
14:15:06 <MarcelineVQ> AWizzArd: good link btw
14:15:33 <lexi-lambda> MarcelineVQ, AWizzArd: I mean, I think the general approach of writing typeclasses with that shape is essentially tagless final, isn’t it?
14:16:20 <AWizzArd> MarcelineVQ: yes, lots of posting in that blog are nicee
14:16:52 <AWizzArd> lexi-lambda: I had this impression. More or less taking a typeclass and have multiple implementations (i.e. „interpreters”).
14:16:57 <an_user> i dont suppose you guys can make sense of this hanging?: from parsy import *; import parsy as p; ((p.string("\n").should_fail("expected newline") >> any_char).many().concat()).many().parse_partial("asd\nasd\n")
14:17:12 <an_user> this is supposed to parse a line ((p.string("\n").should_fail("expected newline") >> any_char).many().concat())
14:17:30 <an_user> and parse_partial is supposed to accept a partial parse, or something like that
14:17:47 <boxscape> what language is that?
14:17:51 <an_user> its python
14:18:07 <an_user> but i figure most python people arent going to be familiar with parser combinators
14:19:07 <lexi-lambda> an_user: It depends on the flavor of parser combinators you’re using. If you’re using a Parsec-like system, you normally have to ensure none of your constituent parsers can parse a newline—you can’t add negation “after the fact”.
14:19:51 <an_user> yeah this is supposed to be parseclike ". If it means anything to you, it's a monadic parser combinator library for LL(infinity) grammars in the spirit of Parsec, Parsnip, and Parsimmon"
14:19:57 <MarcelineVQ> lexi-lambda: hmm I see. I guess I should read the paper again in that case, it has been a little while
14:20:04 <lexi-lambda> AWizzArd: The general idea of tagless final is to represent what might otherwise be represented as a data structure as dispatch.
14:20:30 <an_user> i cannibalized the should fail pattern from: "It is also useful for implementing things like parsing repeatedly until a marker:" from parsy.readthedocs.io/en/latest/ref/methods_and_combinators.html
14:20:57 <AWizzArd> lexi-lambda: that would be this „initial” encoding I guess.
14:21:11 <an_user> but in that case i imagine the any_char isnt satisfying your condition
14:21:25 <lexi-lambda> So instead of constructing a data structure and then folding over it, you create a type class with operations that correspond to the datatype’s constructors, then implement that typeclass. This basically skips the indirection—instead of creating an intermediate structure, you call the consumer directly. It’s kind of like list fusion, in a way.
14:22:27 <lexi-lambda> an_user: What exactly are you trying to parse?
14:22:33 <an_user> hm. still hangs.
14:22:38 <an_user> i want to parse a text file into lines
14:22:56 <lexi-lambda> You don’t care about the structure of the lines at all? You just want to split on newlines?
14:23:06 <an_user> for starters yeah
14:23:34 <an_user> i imagine ill end up decomposing this and i think that results in me throwing out the newline parser completely
14:24:06 <an_user> (im trying to write something convert a complex structured text file into an excel document for a friend)
14:24:11 <lexi-lambda> Then you likely want something like (in Haskell syntax) `many (many (satisfies (/= '\n')) <* newline) *> eof`.
14:24:24 <lexi-lambda> Err, `<* eof` at the end, but that’s the idea.
14:25:18 <lexi-lambda> You have to ensure your parser under `many` can’t consume newlines because, in a Parsec-like system, all combinators are effectively “greedy.”
14:25:29 <an_user> that makes sense
14:25:48 <an_user> whats <*
14:26:18 <lexi-lambda> `a <* b` runs parser `a` followed by parser `b`, returning the result of parser `a` (and ignoring the result of parser `b`).
14:26:26 <an_user> hm ok, makes sense
14:26:38 <lexi-lambda> In do notation, it’s equivalent to `do { r <- a; b; pure r }`.
14:26:42 <an_user> that sounds like should_fail
14:27:20 <an_user> hm but it consumes no input, so i have to consume a newline when it succeeds
14:27:27 <an_user> lookahead + consume
14:27:34 <an_user> sounds kind of screwy but it might work
14:27:51 <lexi-lambda> That’s why you have the `<* newline` bit at the end.
14:28:40 <an_user> ah, so parser b does still consume, its just ignored?
14:28:59 <lexi-lambda> Yes, that’s right. It’s executed for its side-effects (in this case, consuming tokens from the stream).
14:29:59 <lexi-lambda> It looks like you could translate that Haskell code more or less directly using `parsy.test_char` in place of `satisfies` and `parsy.string("\n")` in place of `newline`.
14:30:30 <lexi-lambda> It also looks like parsy overloads `<<` and `>>` to work like `<*` and `*>`, respectively.
14:31:30 <an_user> hmm...i think this still ends up being  ((p.string("\n").should_fail("expected newline") >> test_char(lambda c: c is not "\n", "not newline"))
14:31:37 <an_user> let me play with it a little
14:31:43 <an_user> though that snippet does seem to work by itself
14:32:25 <lexi-lambda> an_user: I think you want something like `many(many(test_char(fn c: c is not "\n")) << string("\n")).
14:32:46 <an_user> ill give it a shot
14:33:32 <MarcelineVQ> AWizzArd: 'inital' and 'final' algebras are derived from http://tunes.org/wiki/initiality_20and_20finality.html  Which is a neat little writeup that I don't fully follow but is really suggestive of some neat (relevant) concepts regardless
14:33:35 <lexi-lambda> You could also probably use `parsy.regex` instead of `test_char` to be significantly faster, since parsing one character at a time is normally not very efficient.
14:34:27 <an_user> reasonable
14:34:54 <an_user> y'all OP ;P
14:35:03 <lexi-lambda> And at that point you could just do `parsy.many(parsy.regex(r'[^\\n]*\\n'))` and call it a day.
14:35:06 <MarcelineVQ> Like the mention of initial algebras being minimal and final coalgebras being maximal could suggest why final can combine readily. Or that's a side-effect of typeclasses being great, dunno :>
14:35:56 <an_user> this appears to work (test_char(lambda c: c != "\n", "not newline").many().concat() << string("\n")).many().parse_partial("asd\nasd\n")
14:36:14 <MarcelineVQ> Oh actually I need to look up terminal object since that's what the 'maximum' line was about :X
14:37:47 <an_user> so now i guess to actually learn something i need to figure out why my approach is failing
14:39:37 <an_user> >> IS "Returns a parser which, if the initial parser succeeds, will continue parsing with other_parser. This will produce the value produced by other_parser."
14:39:47 <MarcelineVQ> edwardk: does machines take a coalgebra and turn it into an algebra or vica-versa? http://tunes.org/wiki/algebra_20and_20coalgebra.html I noticed Plan's are cps'd while Machine/Step's are not
14:40:17 <lexi-lambda> an_user: I think the reason your parser is failing is that you wrote a parser that can parse no input (i.e. succeed on the empty string) and used it under `.many()`.
14:41:32 <an_user> so these parsers usually try matching the empty string first?
14:42:04 <an_user> well if thats true the hang makes sense because it sounds like it would consume no input and keep restarting the parser on the non-progressing success case
14:42:17 <lexi-lambda> an_user: They don’t try matching the empty string first, but `many` will parse nothing iff its parser immediately fails.
14:42:36 <AWizzArd> MarcelineVQ: a deep topic.
14:42:38 <boxscape> @pl \y more x -> applyWhen (x < y) flip ((. more) . (:)) y x 
14:42:38 <lambdabot> flip flip id . (ap .) . (flip =<< (flip .) . (. ((. (:)) . flip (.))) . flip . flip flip flip . (applyWhen .) . flip (<))
14:42:42 <boxscape> yeah maybe I won't do that
14:42:59 <an_user> hm
14:43:01 <lexi-lambda> an_user: Since `should_fail` is a negative lookahead operation, it consumes no input whether it succeeds or fails. So if you write `foo.should_fail().many().many()`, it will spin forever.
14:43:35 <an_user> ((p.string("\n").should_fail("expected newline") >> any_char).many().concat()).parse("") does in fact not fai;
14:44:32 <lexi-lambda> Yes, that’s okay, because there’s only one `many`. Consider the simpler example `fail().many().many()`—the `fail()` parser always fails, but `fail().many()` always succeeds, consuming no input. So `fail().many().many()` infinitely parses no input, forever.
14:44:56 <an_user> ok i think that makes sense
14:45:08 <an_user> many is the regex equivalent of *?
14:45:14 <an_user> i suppose id want +
14:45:20 <lexi-lambda> Yes, that’s right. It’s like writing /()*/ in a regex.
14:45:37 <an_user> for some value of want
14:45:46 <an_user> ok thank you for expanding
14:46:11 <lexi-lambda> I think that, if you want to use `should_fail`, you just need to change your parser to consume a newline when `should_fail` fails.
14:46:20 <an_user> ive got a long way to go with this  file but hopefully ill get better and not need to ask about everything xD
14:46:34 <an_user> lexi-lambda: yeah i was thinking about that
14:46:57 <lexi-lambda> But at that point, `should_fail` doesn’t make that much sense, since you could just parse the newline and return rather than do the lookahead.
14:48:38 <lexi-lambda> I think usually when writing parsec-style parsers you want to avoid lookahead if possible, since normally it’s better/simpler to just write the parser assuming what will happen in the future will succeed, then make it fail/backtrack if your assumption turns out to be wrong.
14:49:14 <lexi-lambda> Put another way, branching with backtracking encodes a kind of implicit lookahead.
14:50:05 <an_user> lexi-lambda: yeah i was a bit bothered by the lookahead
14:50:11 <an_user> << is Similar to Parser.then(), except the resulting parser will use the value produced by the first parser.
14:50:14 <an_user> so that sounds reasonable
14:52:04 <lexi-lambda> MarcelineVQ: I think the initial encoding of a monadic operation is a Free formulation, and the final encoding is the corresponding mtl-style typeclass, so the linked blog post does indeed use tagless final. (I’m not an expert by any stretch, but that’s my understanding.)
14:56:03 <maralorn> When I read https://github.com/ghc-proposals/ghc-proposals/pull/295 I wonder, if anyone has ever considered making "import Data" a valid import statement so that you can then access Maybe.maybe or Aeson.encode.
14:56:51 <MarcelineVQ> that seems entirely reasonable, my hesitatation might be just that I've only seen tagless final used in the specific context of interpreting dsl's
14:57:08 <an_user> lexi-lambda: for the sake of completeness, this seems to work ((p.string("\n").should_fail("expected newline") >> any_char).many().concat() << string("\n")).many().parse("asd\nasd\n")
14:57:15 <an_user> i gotta drop off for a bit, thanks again
14:57:36 <an_user> which is to say, maybe i actually understood something :)
14:58:56 <lexi-lambda> MarcelineVQ: Monads are a kind of DSL. :)
14:59:40 <MarcelineVQ> Free ones especially :>
15:37:08 * hackage hackage-security 0.6.0.0 - Hackage security library  https://hackage.haskell.org/package/hackage-security-0.6.0.0 (HerbertValerioRiedel)
15:47:58 <d34df00d> Hi!
15:48:12 <d34df00d> Is it possible to control the order of fields in the output of Data.Yaml.encode?
15:48:50 <phadej> d34df00d: https://hackage.haskell.org/package/yaml-0.11.2.0/docs/Data-Yaml-Pretty.html
15:49:06 <d34df00d> phadej: oh, missed that module, thanks!
15:50:51 <d34df00d> phadej: yeah, thank you, works like a charm!
15:51:10 <phadej> you're welcome
16:23:27 <ph88> anyone here using pcre ?
16:24:13 <dsal> I did briefly.  It was a bad idea.
16:25:10 <hpc> regexes are pretty much obsolete in haskell with how good the proper parsing libs are
16:25:33 <ph88> dsal, why was it bad for you ?
16:26:18 <amalloy> Text.Regex.Applicative is a fun one imo. parsec-style combinators but much faster because it only handles regular languages
16:26:21 <dsal> It was significantly worse and less accurate in practice than attoparsec for my case, and there were edge cases where it'd throw exceptions on input, which I could somewhat deal with, and then edge cases where it'd just like, crash or something.  I don't remember the exact situation, but  I couldn't deal with it.
16:28:33 <ph88> oki
16:34:15 <svipal> I kind of like haskell
16:35:24 <jackdk> me too
16:43:40 <koz_> Me three!
16:59:40 <phadej> I have never got regex-applicative to throw any exceptions at me
17:33:38 <amalloy> phadej: i bet you'd get one if you gave it an undefined input
17:42:25 <crestfallen> hi I'm getting type errors on print here. If I have main = return $ ...    it compiles at least     https://termbin.com/f5dql
17:43:20 <ion> What's the type of print's return value? Is it the same as the type of main?
17:45:24 <ChaiTRex> :t print
17:45:26 <lambdabot> Show a => a -> IO ()
17:45:36 <ChaiTRex> main can be IO a.
17:47:08 <crestfallen> so do I use show there? never*** can figure out basic printing.
17:47:25 <ion> ChaiTRex: Technically yes, with some changes to the code, but it would be the easiest to make it exactly what the type of the code is.
17:47:43 <ion> print :: Show a => a -> IO ()
17:47:47 <ion> print something :: IO ()
17:47:51 <Axman6> crestfallen: main :: IO ()
17:47:56 <Axman6> :t print
17:47:57 <ion> if "main = print something" then main :: IO ()
17:47:58 <lambdabot> Show a => a -> IO ()
17:48:13 <crestfallen> but isn't Axman6 that doesn't work there is a type conflict
17:48:32 <crestfallen> deleter -but isn't-
17:48:34 <crestfallen> delete
17:48:44 <ion> Please pastebin the code and the error message
17:49:26 <Axman6> crestfallen: my car is broken, can you fix it please? It don't work
17:49:51 <ChaiTRex> Axman6: Turn on the windshield wipers. Always works for me.
17:49:58 <crestfallen> https://paste.ee/p/ScELG   << that is with [Integer]
17:50:12 <MarcelineVQ> crestfallen: print doesn't result in IO [Integer]
17:50:26 <crestfallen> Axman6, I don't understand
17:50:39 <crestfallen> main :: IO () also doesn't work with print
17:51:17 <MarcelineVQ> Are you certain of that.
17:51:18 <Axman6> crestfallen: it means that we can't help you if you don't tell us what's wrong. you haven't shared any type errors, and what we're telling you should work but I'm pretty sure you're not showing us the code which you say isn't working
17:51:25 <Axman6> you've done this several times
17:54:02 <crestfallen> I swear, main :: IO () just decided to work. I tried it a dozen times and there was no output (though it compiled) . my commands were:
17:54:20 <crestfallen> ghc -O applicativeTest.hs
17:54:33 <crestfallen> ./applicativeTest
17:55:04 <crestfallen> [5,9,10,28,6,10,11,29]
17:55:23 <crestfallen> thanks all I swear to the Turkey god I tried it like that a dozen times
17:55:25 <Axman6> looks like it works to me...
17:55:45 <crestfallen> and was getting no output
17:56:32 <ion> Putting the code from the time it didn't work on pastebin would most likely have revealed what was wrong.
17:56:45 <MarcelineVQ> ion: he did paste the code, just not the error
17:57:05 <ion> MarcelineVQ: I only saw code that doesn't compile, but apparently after that it compiled but didn't produce output when executed.
17:57:06 <MarcelineVQ> ah but there was no return in the pasted code if that's what you mean
17:58:27 <crestfallen> getting flustered ++ mental problem ++ not using ghc much. is printing out haskell not complicated generally?
17:59:08 <ion> FWIW, my hypothesis is that the code that did compile but didn't output anything was "main :: IO [Integer]; main = return $ fmap3 ..."
17:59:28 <crestfallen> that's correct I believe ion
17:59:51 <ion> That wouldn't print anything because it doesn't have print in it.
18:00:15 <crestfallen> so that is something I'm not sure of. main :: IO [Integer] threw me off since it compiled
18:01:07 <ion> It might be less confusing if GHC required the type of main to be, say, IO (). As of now, the result value can have any type and it's just discarded.
18:02:04 <crestfallen> but you're not being sarcastic ion .. meaning that main does have it as IO ()  ?
18:04:38 <crestfallen> the only thing I can think of was that I did add the -O flag at some point but it was still giving the error with main :: IO ()
18:05:21 <ion> From GHC's point of view, "main :: IO Bool", "main :: IO [[String]]", "main :: IO ()" and "main :: IO a" are all fine as the result value is simply ignored. I can see why that could be confusing and it might be more helpful if GHC required the type of main to be IO ().
18:06:08 <crestfallen> ok thanks ion 
18:07:23 <ion> That would disallow programs such as "main = getLine" which may or may not be a good thing.
18:07:50 <ChaiTRex> ion: It would introduce the confusion of return ()
18:08:18 <ChaiTRex> ion: Either way, I think, newcomers will be confused.
18:08:43 <ChaiTRex> ion: confusion of sometimes requiring return (), I mean.
18:08:52 <crestfallen> well I'm past my second year as beginner, but I'm just going to stick to ghci as long as I can
18:09:16 <crestfallen> the print stuff can wait I need to learn state monad
18:40:22 <dsal> crestfallen: I use STM quite a lot more than State.
18:44:14 <crestfallen> the other thing about learning is knowing how to look things up. I was looking for tutorials on using main for printing output from ghc to the command line and came up only with this https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using.html         and also similar examples in textbooks. any good resources appreciated, where there is a thorough explanation..?
18:45:12 <crestfallen> then there's the runhaskell command and knowing the difference from ghc -O file.hs etc
18:51:28 <MarcelineVQ> these are the basic options for printing to stdout https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#g:27
19:01:39 <crestfallen> MarcelineVQ, thanks, all those various ones can be used with main I guess
19:02:02 <MarcelineVQ> anywhere an IO () is acceptable
19:02:14 <crestfallen> with print and main :: IO () being the most common
19:02:37 <crestfallen> thanks happy thanksgiving if you're state bound..
19:03:26 <divVerent> what does "statement" mean in context of ghci?
19:03:39 <divVerent> I am aware I can do x = y, let x = y, and a mere expression
19:03:47 <divVerent> what else (not the stuff with colon, that;s shown by :?)
19:05:35 <divVerent> ah, also can do x <- y
19:10:24 <divVerent> % (return.return.return) 42 :: IO (IO (IO Int))
19:10:24 <yahb> divVerent: 
19:10:27 <divVerent> % it
19:10:27 <yahb> divVerent: 
19:10:30 <divVerent> % it
19:10:30 <yahb> divVerent: 42
19:25:09 * hackage tmp-postgres 1.23.0.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.23.0.0 (JonathanFischoff)
19:30:53 <gaze__> Hey, what's the right way to use megaparsec to patch something that requires matched parenthesis? I'm parsing bibtex entries... so I want something like "@article{foo = {bar {3} {baz {quux}}}}" to parse to [Foo, "bar {3} {baz {quux}}}"]
19:42:25 <suzu> perhaps you need a stack to keep track of the depth of braces as your state
19:42:39 * hackage tmp-postgres 1.23.0.1 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.23.0.1 (JonathanFischoff)
19:49:38 <amalloy> [Foo, ""] can't be what you want to parse to, since Foo is not likely to be a valid String
19:50:28 <amalloy> ideally you would parse the interior stuff rather than just looking for matching braces, and then it's as easy as writing Foo <$> (char '{' *> interior <* char '}')
20:00:09 * hackage chronos 1.1 - A performant time library  https://hackage.haskell.org/package/chronos-1.1 (chessai)
20:06:39 * hackage cloudi 1.8.0 - Haskell CloudI API  https://hackage.haskell.org/package/cloudi-1.8.0 (okeuday)
20:17:44 <gaze__> yeah but there needs to be some recursion
20:18:48 <gaze__> it needs to eat an open brace, eat string or not close brace, and if it gets a close brace it needs to bail out to a higher level
20:18:54 <gaze__> or something
20:19:52 <monochrom> Consider funny = char 'a' <|> (char '[' *> funny <* char ']').  What does it accept?
20:40:47 <sicklorkin> What's a good way to compare equality of two Maps that potentially contains 1mil+ items?
20:42:39 * hackage pandoc-citeproc-preamble 1.3 - Insert a preamble before pandoc-citeproc's bibliography  https://hackage.haskell.org/package/pandoc-citeproc-preamble-1.3 (spwhitton)
20:50:57 <sicklorkin> oh default Eq seems fast enough for my use case; 
20:51:31 <gaze__> monochrom something like a, [a], [[a]], ....
20:51:44 <gaze__> is what you intended I imagine
20:51:45 <gaze__> but
20:52:44 <gaze__> "Couldn't match type ‘Char’ with ‘Text’" is what I'm seeing
20:53:02 <gaze__> and I'm having troubles elsewhere in my parser with this class of issues...
21:04:20 <monochrom> I was answering "but there needs to be some recursion".  No one told me about moving the goalpost to Char->Text.
21:06:03 <gaze__> hah fair enough.
21:25:22 <dansho> anyone use nixos know how to allow broken haskell packages with nix-shell? https://hastebin.com/fapozogahe
21:25:45 <dmj`> config.allowBroken = true; 
21:25:55 <dansho> it mentions ~/.config/nixpkgs/config.nix but there is no such file
21:26:43 <dmj`> { pkgs ? import <nixpkgs> { config.allowBroken = true; } }: pkgs.haskellPackages.callPackage ./pkg.nix {}
21:29:00 <dansho> ah, thanks it looks like i can add config.allowBroken = true; to the shell.nix
21:30:20 <dansho> hm, turns out vinyl is truly broken
21:31:14 <dansho> https://hastebin.com/lapoxijayu
21:32:47 <dmj`> dansho: just disable tests on it
21:33:08 <dmj`> dansho: with pkgs.haskell.lib; dontCheck (pkgs.haskellPackages.vinyl);
21:46:20 <dansho> dmj`: where would i put that code?
22:24:23 <dansho> looks like this works: https://hastebin.com/bogojiwila.nix
22:29:04 <Pamelloe1> If my function has a constraint (KnownNat n) => ..., can I get the value n somehow? I'm trying to do a recursion, so I need a base case for when n = 1.
22:31:35 <koz_> Pamelloe1: natVal a Proxy.
22:32:05 <koz_> Something like 'natVal (Proxy :: Proxy n)'. You need ScopedTypeVariables for that one as well.
22:32:18 <koz_> If you don't mind TypeApplications, you can do 'natVal @n Proxy' also.
22:32:49 <koz_> You don't have to use Proxy if you have something of kind Nat -> Type lying around you can pass in.
22:33:33 <Pamelloe1> Ah, I see---the issue was I didn't have ScopedTypeVariables on
22:34:01 <koz_> Yeah - if you're gonna do typelevel shenanigans, ScopedTypeVariables is pretty much mandatory.
22:35:40 <Pamelloe1> I'm now having issues with the constraint that 1 <= n. Using natVal and pattern matching, I have two cases, where 1 == n, and where n > 1. How do I convince GHC that, in the second case, 1 <= n - 1?
22:36:28 <koz_> Yeah, that one is a bit trickier. I would recommend jle`'s typelits-witnesses for this purpose.
22:36:57 <koz_> Since it gives you the ability to branch on exactly this kind of thing, _while informing GHC_ of what's the case in which branch.
22:42:04 <Pamelloe1> Just checked typelits-witnesses out. Looks perfect :)
23:17:33 <Pamelloe1> Wow that was a beast get working
23:17:55 <Pamelloe1> Is getting things like this any easier in other languages?
23:18:34 <Pamelloe1> (Perhaps its time for bed, my sentences are rapidly losing coherence)
23:20:09 <MarcelineVQ> some languages, but they come with other hurdles
23:25:21 <koz_> Pamelloe1: Idris is notable.
23:40:22 <iqubic> So, I've been thinking I should create a small little library of functions to use during AoC. The only issue is that I'm not sure what sort of functions I'll want.
23:42:42 <iqubic> Just realized this would be better in the #adventofcode channel
23:43:00 <Ariakenom> iqubic: You can look at some from yesteryear. Like the esteemed glguy https://github.com/glguy/advent2018/tree/master/common
23:43:27 <iqubic> I will.
23:44:13 <Ariakenom> 64-ranked code, has to be good. 
23:44:25 <Ariakenom> :p
23:47:17 <iqubic> Nice
23:57:35 <HM_Having_a_go> hello all
23:59:22 <HM_Having_a_go> I'm playing around, implementing HM type inference in rust, but I'm likely to have a few questions that might be relevant to Haskell. I'm hoping this is a good place to ask?
