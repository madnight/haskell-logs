00:02:20 <ammar2> jle`: those examples make sense, but when is the last time you heard someone say: "I'm gonna compile this machine code back to C to try and understand it"
00:02:31 <ammar2> even though decompiler has the same relation to compiler as circle does to shape
00:03:12 <ammar2> and if not, why don't they say that?
00:04:04 <Arahael> ammar2: Last week.
00:04:22 <monochrom> Did they really say "compile"? Or did they say "decompile"?
00:04:54 <Arahael> monochrom: "I've lost the code, how do I convert the executable back to $lang?"
00:07:12 <ammar2> Arahael: fair enough but "convert" is more of a lay-term. I think the crux of my argument is that "compiler" in standard nomenclature isn't just the academic "turn one language into another". It usually means going from a higher-level language to a lower one and that's why words like transpiler/decompiler exist
00:07:33 <Arahael> ammar2: Fair enough.  I think the javascript backend crowd has corrupted it somewhat.
00:07:45 <tdammers> it's not a crazy thought to have - a compiler "translates" source code into machine code, so why wouldn't you be able to reverse the translation? the fact that compilation is a lossy transformation, more so than translations between natural languages, isn't immediately obvious.
00:08:13 <Arahael> tdammers: It also strikes me that languages should be convertible from one to another.
00:08:46 <Arahael> I mean, in the spirit of "you can write pascal in any language".
00:08:56 <thebnq> its also true that some transpiling really is going from a higher ecmascript to a lower ecmascript
00:09:02 <tdammers> Arahael: programming languages? most are, as per the Turing equivalence. with natural languages, the story is different.
00:09:26 <EvanR> in this random compiler book, it literally explains compilers in terms of the source language and target language
00:09:35 <Arahael> tdammers: Yet, you rarely see much work being done there.  We're still defaulting to the C ABI for interoperability.
00:09:51 <EvanR> it doesn't mention what the languages are or whether they are considered high or low level, or awful languages or good langauges
00:09:58 <tdammers> I have made a habit of avoiding the word "transpile" entirely
00:10:07 <tdammers> and not just because it is etymologically nonsensical
00:10:19 <Arahael> In some very old programming books, I see the term "rewrite" more often.
00:10:27 <Arahael> A compiler "rewrites" from one language to another.
00:10:29 <EvanR> a decompiler is a program that can reverse to some extent the action of a compiler, and has no indepedent existence
00:10:39 <tdammers> but also because there is no reasonable point at which you could draw a line between "compiling" and "transpiling"
00:10:43 <monochrom> I'm pretty sure every compiler book actually makes a high-to-low assumption whether they say it out loud or not.
00:11:17 <EvanR> i guess no compiler book compiles to javascript
00:11:22 <tdammers> monochrom: pretty much, yes. compilers generally resolve abstractions, they don't usually introduce any by themselves, even though technically they could
00:11:45 <monochrom> Because like apart from the lexing and parsing chapters, the remaining chapters make no sense for converting asm to Haskell or C to Haskell or even Haskell to c.
00:11:46 <Athas> In some (natural) languages, the word "compiler" is instead something like "translator".  I always liked that better.  Avoids this entire discussion.
00:11:47 <tdammers> EvanR: it's not "high-level to low-level language", but "high-level to low(er)-level code"
00:11:52 <EvanR> by that i mean, because what i said is true, you can compile to javascript
00:12:43 <EvanR> i don't see why abstractions need to be elminated by a compilation process
00:13:04 <tdammers> EvanR: because the target language generally doesn't support the same abstractive features as the source language
00:13:14 <EvanR> a goal might reasonably be to get faster code if possible
00:13:26 <Athas> Is there even a good definition for what "abstraction" means?  When Conal Elliott compiles Haskell to a cartesian closed category, I'd say the result is pretty abstract, but also low-level in a sense.
00:13:42 <tdammers> e.g., if you compile JavaScript to C, you need to find a way to deal with closures, because JavaScript has them, but C doesn't. So you unroll the "closure" abstraction into explicitly passing context objects around
00:14:07 <Arahael> tdammers: Or use the C extensions. ;)
00:14:09 <EvanR> and if you compile haskell to javascript, you don't have to worry about that
00:14:16 <tdammers> this isn't even about getting faster code, it's just about being able to express the construct in the first place
00:14:18 <EvanR> use the closures
00:14:21 <monochrom> I don't know how to define "abstraction" but Conal's compilation loses type classes I bet.
00:14:45 <Athas> monochrom: Definitely!  And almost by necessity, any compilation process loses information.
00:15:08 <Arahael> Athas: Not neccessarily.
00:15:18 <EvanR> man.
00:15:24 <EvanR> forget yall
00:15:42 <monochrom> Ironically I would say "lose structure, increase entropy".  The irony is "increase entropy => increase information?" heh heh
00:15:46 <tdammers> other example, assembly doesn't have proper procedures, they're implemented as a bunch of stack operations and jumps. so if you compile C to ASM, you need to unroll the procedure calls into series of push, call, pop, push, return, pop
00:16:00 <monochrom> OK now someone is going to ask me what is "structure"...
00:17:06 <ammar2> tdammers: and the cpu doesn't have a concept of a call and needs to turn it into a sequence of changing registers and memory :>
00:17:10 <EvanR> increase entropy is forget information
00:17:11 <ammar2> is the cpu a compiler?
00:17:22 <Arahael> The CPU is basically an interpreter.
00:17:35 <tdammers> modern CPUs are interpreters, but there may be small amounts of GIT compiling going on
00:17:48 <EvanR> ancient CPU are also interpreters
00:17:49 <Arahael> I hear they run Minix - the intel ones, anyway.
00:17:51 <ammar2> modern CPUs are compilers*, x86 turns into micro ops
00:17:54 <tdammers> s/GIT/JIT/
00:18:03 <Arahael> tdammers: I assumed that was an intentional typo. ;)
00:18:13 <tdammers> Arahael: that would have been awesome, wouldn't it
00:18:18 <tdammers> Arahael: and also terrible
00:18:48 <Arahael> tdammers: Yes.  It'd have been terrific.
00:18:55 <tdammers> just imagine a CPU pulling in firmware updates from github
00:18:59 <monochrom> Modern CPUs also have a covert minix-based machine inside. >:)
00:19:51 <Arahael> Pretty sure git can be ported to minix, if it hasn't already.
00:20:40 <EvanR> i am really surprised to see haskell people supporting ideas like "a compiler is a thing that is basically like GCC" and "an interpreter is a thing that does like what perl does". The idea is to get at the essence of what's going on so you can use techniques or at least apply philosophy effectively in more situations
00:21:05 <EvanR> and forget the non essential details
00:21:27 <monochrom> s/GCC/GHC/ and s/perl/GHCi/
00:21:33 <ammar2> lol
00:21:39 <monochrom> and GCC is a linker
00:21:40 <EvanR> sure
00:21:41 * hackage hreq-core 0.1.0.0 - Core functionality for Hreq Http client library  https://hackage.haskell.org/package/hreq-core-0.1.0.0 (epicallan)
00:21:52 <ammar2> monochrom: hol up
00:21:54 <ammar2> monochrom: what?
00:21:54 <EvanR> ...
00:22:03 <EvanR> gcc is a symlink
00:22:09 <monochrom> Because GHC calls up GCC for linking.
00:23:16 <monochrom> Presumably because calling up ld with the right flags (that gcc knows how to fill in) is too much chore and too error-prone
00:23:36 <EvanR> gcc in that context is a compiler driver
00:23:59 <monochrom> Anyway it was a joke based on a GHC-centric world view.  Please just laugh.  Please I beg you.
00:24:47 <EvanR> if compilers were planets which one is ghc
00:24:59 <monochrom> home
00:25:18 <monochrom> Flat-GHC theory. >:)
00:25:51 <Arahael> That's the "H"eliocentric worldview.
00:26:20 <ammar2> GHC actually stands for GNU Haskell Compiler
00:27:33 <tdammers> General Hublic Clicense
00:28:12 * hackage hreq-client 0.1.0.0 - A Type dependent Highlevel HTTP client library.  https://hackage.haskell.org/package/hreq-client-0.1.0.0 (epicallan)
00:30:42 * hackage hreq-conduit 0.1.0.0 - Conduit streaming support for Hreq.  https://hackage.haskell.org/package/hreq-conduit-0.1.0.0 (epicallan)
00:33:51 * Arahael sticks to wreq.
00:33:57 <Arahael> Intriguing, though.
00:34:21 <EvanR> type-dependent
00:37:09 <EvanR> ok hreq has some heavy types indeed
00:39:05 <Arahael> Yep.
02:12:42 * hackage mmsyn5 0.4.2.1 - Various additional operations on lists (some with intermediate Monads)  https://hackage.haskell.org/package/mmsyn5-0.4.2.1 (OleksandrZhabenko)
02:16:50 <maerwald> if the example is complete, then it has less boilerplate than servant
02:18:41 * hackage lightstep-haskell 0.4.3 - LightStep OpenTracing client library  https://hackage.haskell.org/package/lightstep-haskell-0.4.3 (DmitryIvanov)
02:21:12 * hackage probability 0.2.6 - Probabilistic Functional Programming  https://hackage.haskell.org/package/probability-0.2.6 (HenningThielemann)
02:31:33 <Phyx-> 07:36:40 < jle`> but i think windows has a limit on file extension length or something <-- Windows doesn't. the Win32 legacy APIs do. GHC no longer uses these APIs since GHC 8.4
04:36:11 * hackage ats-pkg 3.3.0.6 - A build tool for ATS  https://hackage.haskell.org/package/ats-pkg-3.3.0.6 (vmchale)
04:44:18 <dnikolovv> hi guys
04:44:33 <dnikolovv> can anyone help a bit
04:45:01 <dminuoso> dnikolovv: Hiya. Just present your code, your problem and what you have tried so far.
04:45:14 <dnikolovv> so I have the following code
04:45:25 <dminuoso> You can use https://gist.github.com/ or similar sites to share code if you like.
04:45:44 <dnikolovv> just a second
04:45:50 <dnikolovv> I'm trying to generalize this function but it's stubborn
04:46:14 <dnikolovv> https://gist.github.com/dnikolovv/fcbe99cb31da20c8e3b10f7d85da110f
04:46:26 <dnikolovv> so..
04:46:30 <dminuoso> dnikolovv: If you name your file with a .hs extension you will get syntax hilighting.
04:46:33 <dminuoso> That makes reading the code much easier.
04:46:39 <dnikolovv> 1 second
04:46:48 <dnikolovv> haven't really used Gist except for reading
04:47:05 <dnikolovv> can you see it because it says "secret"?
04:47:15 <dminuoso> dnikolovv: Yes. That just means its not visible on your public page.
04:47:19 <dnikolovv> great
04:47:38 <dnikolovv> https://gist.github.com/dnikolovv/1708a5532dbadccdb8fab0a0be9dfe10
04:47:42 <dnikolovv> alright this one should be better
04:47:58 <dnikolovv> so.. if you look at the askIncidentInfo function
04:48:15 <dminuoso> It's not a function, but go on.
04:48:21 <dnikolovv> yes sorry lol
04:48:44 <dnikolovv> I kind of want to generalize that on the form type parameter
04:49:04 <dminuoso> dnikolovv: ScopedTypeVariables
04:49:08 <dnikolovv> e.g. be able to say something like "Incident info." `withForm` @IncidentInfoForm
04:49:15 <dnikolovv> obviously this particular piece of syntax is made up
04:49:25 <dnikolovv> let me check
04:49:33 <dminuoso> dnikolovv: You can use Proxy to make that a bit easier to use.
04:49:49 <dminuoso> "Incident info." `withForm` (Proxy @IncidentInfoForm)
04:50:18 <dnikolovv> hm
04:50:32 <dnikolovv> let me try 
04:50:48 <dminuoso> dnikolovv: You'll have to rewrite withForm accordingly, of course.
04:50:57 <dnikolovv> yes I'm kind of confused on the Proxy bit
04:51:05 <dnikolovv> I haven't used it as a parameter
04:51:13 <dminuoso> dnikolovv: Proxy is an old trick how we did type applications before TypeApplications
04:51:21 <dminuoso> dnikolovv: `data Proxy a = Proxy` essentially
04:51:26 <dnikolovv> I use it currently for type applications
04:51:35 <dnikolovv> e.g.
04:51:54 <dminuoso> dnikolovv: Then you could write `withForm :: ToFormDecsription f => Text -> Proxy f -> ...; withForm t _ = ...`
04:52:01 <dnikolovv> withParsedInput @(Proxy 'AskIncidentInfo) $ \(IncidentInfoForm ---
04:52:13 <dminuoso> dnikolovv: You don't use type applications at all.
04:52:17 <dnikolovv> lol
04:52:22 <dminuoso> dnikolovv: You just pass `Proxy` as an actual argument.
04:52:37 <dnikolovv> just a second
04:52:38 <dminuoso> % @src Proxy
04:52:39 <yahb> dminuoso: ; <interactive>:257:1: error: parse error on input `@'
04:52:40 <dminuoso> @src Proxy
04:52:40 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
04:52:59 <dminuoso> % data Proxy t = Proxy
04:53:00 <yahb> dminuoso: 
04:53:12 <dminuoso> % class SizeOf t where sizeOf :: Proxy t -> Int
04:53:12 <yahb> dminuoso: 
04:53:23 <dminuoso> % instance SizeOf Word32 where sizeOf _ = 32
04:53:23 <yahb> dminuoso: 
04:53:32 <dminuoso> % sizeOf (Proxy :: Word32)
04:53:32 <yahb> dminuoso: ; <interactive>:261:9: error:; * Couldn't match expected type `Word32' with actual type `Proxy t0'; * In the first argument of `sizeOf', namely `(Proxy :: Word32)'; In the expression: sizeOf (Proxy :: Word32); In an equation for `it': it = sizeOf (Proxy :: Word32); <interactive>:261:9: error:; * Couldn't match expected type `Proxy t1' with actual type `Word32'; * In the first 
04:53:37 <dminuoso> % sizeOf (Proxy @Word32)
04:53:37 <yahb> dminuoso: 32
04:53:40 <dminuoso> % sizeOf (Proxy :: Proxy Word32)
04:53:40 <yahb> dminuoso: 32
04:53:56 <dnikolovv> one problem is that
04:54:07 <dnikolovv> I get the proxy as an argument but how do I tell the toFormDescription function
04:54:14 <dnikolovv> that it should use the type in the proxy
04:54:17 <dminuoso> dnikolovv: You do that via the type signature
04:54:26 <dminuoso> dnikolovv: withForm :: ToFormDecsription f => Text -> Proxy f -> ...; withForm t _ = ...
04:54:37 <dminuoso> dnikolovv: Then, when you pass some proxy of type `Proxy T` it will infer that `f ~ T`
04:54:52 <dnikolovv> it fails with
04:55:00 <dnikolovv> "Could not deduce ToFormDescription"
04:55:07 <dnikolovv> the problem is that the ToFormDescription typeclass is
04:55:08 <dnikolovv> kind of shitty
04:55:11 <dnikolovv> it's ambiguous
04:55:20 <dminuoso> dnikolovv: You can use the Proxy there too.
04:55:21 <dnikolovv> class ToFormDescription a where toFormDescription :: FormDescription
04:55:29 <dnikolovv> it doesn't take the a
04:55:32 <dminuoso> dnikolovv: class ToFormDescription a where toFormDescription :: Proxy a -> FormDescription
04:55:39 <dminuoso> dnikolovv: then you can keep passing the Proxy around.
04:55:43 <dnikolovv> lol
04:55:43 <dnikolovv> man
04:55:44 <dnikolovv> you just
04:55:50 <dnikolovv> I've been thinking about this for so long
04:55:54 <dnikolovv> just lol
04:56:15 <dnikolovv> yep..
04:56:18 <dnikolovv> works like a charm
04:56:21 <dminuoso> :)
04:56:27 <dnikolovv> lol
04:56:43 <dnikolovv> (bow)
04:57:34 <dnikolovv> thank you so much
04:57:42 <dminuoso> You are welcome.
04:58:32 <dnikolovv> I'll be stunned for the next 30 minutes 
04:58:36 <dnikolovv> it couldn't have been simpler
05:07:15 <kenran_> Is an emacs haskell-mode question on-topic in here?
05:09:38 <MarcelineVQ> yep
05:40:57 <irc27313> IO is about affect the outside world, what MonadIO is used to?
05:42:11 <Uniaika> irc27313: MonadIO is a typeclass that you can use to constraint an `m`
05:42:24 <Uniaika> IO () → MonadIO m => m ()
05:42:41 <Uniaika> note that not all types involving IO are isomorphic to a version that replaces IO with a constrained m, though.
05:42:45 <Uniaika> https://stackoverflow.com/questions/52387403/haskell-monadio-vs-io
05:42:47 <ashkan_kiani> Was anyone here an intern at tsurucapital before? I'm curious what the likelihood of becoming a full time employee is after the internship.
05:42:55 <ashkan_kiani> I got an offer from them
05:45:57 <dmwit> That seems like a fantastic question to ask Tsuru Capital.
05:46:14 <irc27313> liftIO will lift an IO action into an MonadIO instance, will this IO action will be executed?
05:47:11 <dmwit> I guess Proxy could technically be an instance of MonadIO, with `liftIO _ = Proxy`. Which... obviously won't execute the provided action.
05:48:07 <irc27313> what’s the special about lift an IO action into an ReaderT ?
05:48:24 <irc27313> ReaderT r IO a
05:48:27 <dmwit> E_TOOVAGUE
05:49:02 <ph88> is there a function for   return ()   or  pure ()   ?
05:50:51 <dmwit> 1. No, because aren't (necessarily) functions. 2. Yes, `pure ()`.
05:51:18 <dmwit> But see also `void`.
05:51:40 <irc27313> what value can have ReaderT r IO a?
05:52:33 <irc27313> ReaderT r IO is an instance of MonadIO? also Monad?
05:55:29 <phaazon> I think I could try CA
05:56:39 <dmwit> Yes, it has both of those instances.
05:57:05 <irc27313> how to execute an IO action?
05:57:22 <dmwit> Make it reachable from `main`.
05:58:32 <irc27313> how to get a from IO a?
05:59:10 <dmwit> Can't.
05:59:23 <Uniaika> irc27313: from a type perspective you cannot
05:59:26 <dmwit> But you can turn a function that would normally consume an `a` into a function that knows how to consume an `IO a`, which is almost as good.
05:59:54 <Uniaika> from a value perspective, you can use the do-notation to retrieve the content of said `a` and play with it
05:59:57 <dmwit> :t (=<<)
05:59:58 <lambdabot> Monad m => (a -> m b) -> m a -> m b
06:00:12 * hackage rainbox 0.22.0.0 - Two-dimensional box pretty printing, with colors  https://hackage.haskell.org/package/rainbox-0.22.0.0 (OmariNorman)
06:00:15 <dmwit> % :t (=<<) @IO
06:00:15 <yahb> dmwit: (a -> IO b) -> IO a -> IO b
06:01:24 <irc27313> what’s the effect of ReaderT r IO?
06:02:03 <dmwit> So, for example, you can't get the `String` out of `getLine :: IO String` and pass it to `putStrLn :: String -> IO ()`. But you can convert `putStrLn` by `(=<<) putStrLn :: IO String -> IO ()`, and then `getLine` is a fine argument for it; `(=<<) putStrLn getLine :: IO ()`.
06:03:39 <irc27313> if I want to use some value that inside an IO action, use do-notation or =<< means I have to put the function into that IO stack, it weird
06:03:48 <dmwit> ReaderT r IO offers all the effects available to both Reader r and IO; that is: you can create a value of type r out of thin air and you can do IO.
06:04:30 <dmwit> I agree that if you want to use some value that is inside an IO action, you must use do-notation or (=<<), and the result will still be in IO. I do not agree that this is weird.
06:04:43 <tdammers> I think that before you attempt to understand MonadIO, you first need to understand IO
06:05:02 <irc27313> yeah, I don’t understand IO
06:05:50 <tdammers> OK, so Haskell is a pure language, right? that means nothing in Haskell has any side effects - in other words, effects cannot occur as a result of evaluation
06:06:04 <tdammers> that means we cannot trigger IO actions by evaluating a Haskell function
06:06:24 <tdammers> and hence, IO doesn't do that either; it's not really special that way
06:06:42 <tdammers> what IO *can* do is symbolically represent interactions with the outside world (a.k.a. effects)
06:07:03 <tdammers> for example, `getLine` is a value (not a function!) that represents the effect of reading one line from stdin
06:07:51 <tdammers> `putStrLn` *is* a function, but applying it does not cause any effects to happen; rather, it is a function that takes a string and gives a value that represents the effect of printing that string to stdout
06:08:21 <tdammers> applying putStrLn to a string doesn't print anything, it just gives you a value of type IO ()
06:08:46 <tdammers> and you cannot execute the effect from inside Haskell; only the RTS (runtime system) can do this
06:09:08 <tdammers> and it will, if you bind a suitable IO action to the name "main" in the module "Main", and run the program
06:10:06 <irc27313> t = getLine >>= putStrLn
06:10:18 <tdammers> right, yes, >>=
06:10:25 <irc27313> main = t
06:10:42 <tdammers> obviously it's not very useful to have all these individual IO actions if we can't combine them into more useful programs, and that's what >>= does
06:11:10 <tdammers> it happens to be a method of the Monad typeclass, so implementations also exist for a lot of other types, but in this context, it's probably best to only consider the version for IO
06:11:14 <tdammers> :t (>>=)
06:11:16 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:11:19 <tdammers> :t (>>=)@IO
06:11:21 <lambdabot> error:
06:11:21 <lambdabot>     Pattern syntax in expression context: (>>=)@IO
06:11:21 <lambdabot>     Did you mean to enable TypeApplications?
06:11:23 <tdammers> aww
06:11:39 <tdammers> (>>=) :: IO a -> (a -> IO b) -> IO b
06:11:42 <tdammers> in this context
06:13:06 <irc27313> we have fromJust or maybe or either to get the values from the context, but we can’t get values from IO context?
06:13:14 <tdammers> correct
06:13:27 <tdammers> there is no way to "deconstruct" IO inside Haskell
06:13:33 <irc27313> we only can pass values in IO actions?
06:13:40 <tdammers> not quite
06:13:51 <tdammers> IO a is an effectful computation that produces an "a"
06:14:36 <tdammers> but the only thing we can do with it, other than passing it around and throwing it away, is to feed it to a combinator that accepts such values
06:14:52 <irc27313> IO product an "a"
06:15:13 <tdammers> yes, but the "produce" part happens outside of Haskell
06:15:56 <irc27313> how you describe getLine >>= putStrLn?
06:16:00 <tdammers> we can, for example, pass an IO a to the LHS of (>>=); this gives us the opportunity to consume that value in another function of our choice on the RHS, but due to the type of (>>=), that function must return another effectful computation
06:16:37 <tdammers> getLine >>= putStrLn is a value that represents the effectful computation of reading one line from stdin and printing it to stdout
06:17:37 <tdammers> colloquially, you will hear people say "getLine >>= putStrLn reads one line from stdin and prints it to stdout", but that's technically incorrect - it doesn't actually *do* that, it just *represents* it.
06:17:50 <tdammers> > let blah = getLine >>= putStrLn in "hello"
06:17:52 <lambdabot>  "hello"
06:18:37 <tdammers> see? we're not putting it in a context where the RTS reaches it when executing the "main" action, so it doesn't get executed. it's just a value sitting somewhere, just like any other value
06:19:11 <tdammers> > let blah = [getLine >>= putStrLn] in map (\x -> 1) blah -- we can even put IO actions in lists and all that
06:19:13 <lambdabot>  [1]
06:19:28 <tdammers> as far as Haskell itself is concerned, they're just values
06:20:43 <lortabac> tdammers: what you are saying is true, but your results in lambdabot and the fact that you can put IO in lists are unrelated to your point
06:20:57 <lortabac> both are due to laziness
06:21:19 <merijn> What? No
06:21:21 <tdammers> > let blah = getLine >>= putStrLn in seq blah "hello"
06:21:23 <lambdabot>  "hello"
06:21:34 <merijn> THe fact that you can put IO in lists would work just as well in a strict language
06:22:17 <tdammers> > let blah = getLine >>= putStrLn in seq getLine $ seq putStrLn $ seq blah "hello" -- how hard do you want me to seq this?
06:22:19 <lambdabot>  "hello"
06:22:29 <merijn> tdammers: spoon hard
06:22:36 <merijn> @hackage spoon
06:22:36 <lambdabot> http://hackage.haskell.org/package/spoon
06:22:53 <merijn> or deepseq or whatever :p
06:23:21 <tdammers> yeah, but this should be deep enough to show that lazy evaluation has nothing to do with it
06:23:28 <irc27313> ReaderT r IO a, if I put this action into main, it will ?
06:23:56 <tdammers> you can't, because ReaderT r IO isn't the same type as IO, and main must be IO ()
06:24:31 <tdammers> however, there is a useful function that can convert a ReaderT r m a value into an m a value (runReaderT)
06:24:34 <irc27313> then how I can make that possible?
06:24:36 <tdammers> :t runReaderT
06:24:38 <lambdabot> ReaderT r m a -> r -> m a
06:25:03 <tdammers> runReaderT takes your ReaderT r IO () action and gives you an IO () action; you do need to provide an r though
06:25:14 <tdammers> the resulting IO () action, however, *can* be bound to main
06:25:15 <irc27313> why main must be IO () not IO a?
06:25:28 <lortabac> tdammers: oops you are right, I didn't sleep enough last night :)
06:25:49 <tdammers> I'm not 100% sure it can't be IO a, but it would be pointless to use anything other than (), because the result can never be used
06:25:56 <irc27313> IIRC POSIX can have return value 0-255 from program
06:25:58 <tdammers> the RTS executes the action and throws the result away
06:26:28 <merijn> tdammers: main has to unify with "IO a" per the report
06:26:35 <tdammers> right... but that's not how we return exit codes from programs (though I don't know why not... might be to do with the fact that exit codes are a unix-specific thing)
06:26:43 <merijn> GHC doesn't do anything with the return value, but that's not required
06:26:45 <tdammers> merijn: ah, see, thought there was something
06:27:20 <tdammers> right, you *could* build a Haskell compiler that does something with the return value, though it's kind of difficult to imagine what that would be
06:27:23 <tdammers> you can
06:27:31 <tdammers> t print it, because just "a" doesn't give you a Show instance
06:27:50 <lortabac> maybe IO Int could be an exit code :)
06:27:58 <merijn> tdammers: If you build a Haskell OS you could return results to the calling process!
06:28:04 <tdammers> yeah, but that would require some un-haskelly dynamic dispatch logic
06:28:10 <merijn> tdammers: Not everything has to be about this shitty unix nonsense! :p
06:28:15 <tdammers> merijn: sure.
06:28:31 <irc27313> :runReaderT
06:28:40 <tdammers> merijn: just saying that returning an integer is not necessarily sensible for a program across execution environments / platforms
06:28:55 <absence> if i have a HashSet of keys, can i use them to split a HashMap in two, one that contains the keys and one that doesn't?
06:29:10 <tdammers> irc27313: you need to write it as :t runReaderT (":t" means "type of
06:29:11 * hackage rainbow 0.34.0.0 - Print text to terminal with colors and effects  https://hackage.haskell.org/package/rainbow-0.34.0.0 (OmariNorman)
06:29:12 <tdammers> ")
06:30:10 <irc27313> what’s the meaning to provide r in runReaderT ?
06:30:36 <irc27313> ReaderT r IO (), because a is ()
06:30:59 <irc27313> it’s like f _ = ()
06:37:03 <kuribas> irc27313: reader is used for passing configuration
06:37:24 <kuribas> irc27313: the r is a configuration type, for example which reads from a datafile, or from the command line.
06:38:57 <irc27313> main = runReaderT (x :: ReaderT r IO ()) y
06:39:05 <irc27313> y :: r
06:39:25 <irc27313> what this y is used to?
06:40:30 <irc27313> main = runReaderT (x >>= ...) y ?
06:40:31 <kuribas> irc27313: it could be configuration you read from a file
06:41:31 <irc27313> y is in the context of Reader T r?
06:41:56 <irc27313> so it can pass to others
06:42:01 <kuribas> irc27313: y :: r
06:42:48 <kuribas> like main = do y <- readConfiguration; runReaderT myProgram y 
06:43:50 <kuribas> irc27313: supposing readConfiguration has type "IO r"
06:44:32 <irc27313> how I can get y from ReaderT r IO context? pass x >>= \z -> ...      what z is?
06:44:49 <irc27313> x :: ReaderT r IO ()
06:45:22 <irc27313> x >>= \z -> ....     what z has?
06:45:41 <irc27313> ()?
06:46:07 <irc27313> becasue ReaderT r IO is the monad
06:46:11 <kuribas> irc27313: you don't need to get y from ReaderT, because reader cannot change the value, unlike State
06:46:35 <kuribas> irc27313: or do you ask you to get it in the monad?
06:46:40 <kuribas> irc27313: you use ask
06:46:42 <kuribas> :t ask
06:46:43 <lambdabot> MonadReader r m => m r
06:47:02 <irc27313> but this is a ReaderT
06:47:12 <irc27313> how I get a Reader from it?
06:47:17 <kuribas> irc27313: ReaderT is an instance of MonadReader
06:48:00 <kuribas> ask is polymorphic
06:48:25 <irc27313> ask (_::ReaderT r IO ()) will get?
06:48:51 <kuribas> :t ask :: Monad m => ReaderT r m r
06:48:52 <irc27313> y::r?
06:48:52 <lambdabot> Monad m => ReaderT r m r
06:49:15 <kuribas> irc27313: you need to be clearer in the question you ask
06:50:25 <irc27313> ask is not a function?
06:50:25 <kuribas> :t ask :: ReaderT r IO r
06:50:26 <lambdabot> ReaderT r IO r
06:50:41 <kuribas> irc27313: no, it's not
06:50:53 <kuribas> it does wrap a function though
06:53:18 <kuribas> :t ask :: Reader r r
06:53:19 <lambdabot> Reader r r
06:53:51 <kuribas> :t ask :: StateT s (ReaderT r IO) r
06:53:52 <lambdabot> StateT s (ReaderT r IO) r
06:54:22 <irc27313> then I don’t understand
06:55:04 <irc27313> ask is not a function, how it used to ReaserT
06:55:12 <kuribas> irc27313: ask is a monadic action.
06:56:00 <kuribas> in the reader monad
06:56:10 <tdammers> OK, so here's the deal
06:56:19 <kuribas> the same way putStrLn "hello" is a monadic action in the IO monad
06:56:23 <kuribas> :t putStrLn "hello"
06:56:24 <lambdabot> IO ()
06:56:29 <tdammers> Reader r a is basically a synonym for r -> a
06:56:42 <tdammers> ReaderT r m a is a synonym for r -> m a (more or less)
06:56:42 <irc27313> main = runReaderT $ do x <- ask ...  y
06:56:55 <irc27313> what this x has type?
06:56:59 <tdammers> runReader(T) gets you from the former representation to the latter
06:57:14 <kuribas> irc27313: r
06:57:28 <tdammers> the trick is of course that Reader monads allow you to combine r -> a and a -> r -> b into r -> b
06:57:48 <tdammers> and likewise, ReaderT allows you to combine r -> m a and a -> r -> m b into r -> m b
06:58:38 <tdammers> what that means is that rather than passing an extra argument explicitly at every part of the call chain, you wrap things in Reader(T), and only supply the extra argument once
06:59:32 <irc27313> it’s so trick
07:00:38 <tdammers> essentially the Reader monad captures a very common coding pattern, namely the one where you have some sort of context or environment that you pass to all parts of an expression
07:00:59 <tdammers> and now, if you look at ask:
07:01:00 <tdammers> :t ask
07:01:01 <lambdabot> MonadReader r m => m r
07:01:11 <tdammers> and desugar the Reader notation away:
07:01:21 <tdammers> ask :: r -> r
07:01:28 <tdammers> oh boy
07:01:45 <tdammers> so that means that if Reader r a is just r -> a, then ask is just r -> r
07:04:36 <tdammers> and it follows that \r -> runReader r ask is the identity
07:04:43 <tdammers> > runReader "hello" ask
07:04:45 <lambdabot>  error:
07:04:45 <lambdabot>      • Couldn't match type ‘[Char]’ with ‘ReaderT (m0 r0) Identity a’
07:04:45 <lambdabot>        Expected type: Reader (m0 r0) a
07:04:56 <tdammers> :t runReader
07:04:57 <lambdabot> Reader r a -> r -> a
07:05:07 <tdammers> > runReader ask "helo"
07:05:09 <lambdabot>  "helo"
07:05:15 <tdammers> (the other way around, actually)
07:05:34 <tdammers> but of course the real use for it is when you use monadic combinators inside
07:05:36 <tdammers> e.g.:
07:06:00 <tdammers> > runReader (ask >>= \str -> return (str ++ str)) "hello"
07:06:02 <lambdabot>  "hellohello"
07:06:22 <tdammers> > runReader (ask >>= \a -> ask >>= \b -> return (a ++ b)) "hello"
07:06:24 <lambdabot>  "hellohello"
07:06:31 <tdammers> or, with do sugar:
07:06:58 <tdammers> > runReader (do { a <- ask; b <- ask; return (a ++ b) }) "hello" -- literally the same thing
07:07:00 <lambdabot>  "hellohello"
07:09:50 <kuribas> > runReaderT (do y <- ask; liftIO (putStrLn y)) "hello"
07:09:52 <lambdabot>  error:
07:09:52 <lambdabot>      • Ambiguous type variable ‘m0’ arising from a use of ‘show_M559522842239...
07:09:52 <lambdabot>        prevents the constraint ‘(Show (m0 ()))’ from being solved.
07:10:22 <kuribas> > runReaderT (do y <- ask :: ReaderT String IO String; liftIO (putStrLn y)) "hello"
07:10:24 <lambdabot>  <IO ()>
07:12:36 <kuribas> that would print "hello"
07:20:41 * hackage rainbox 0.24.0.0 - Two-dimensional box pretty printing, with colors  https://hackage.haskell.org/package/rainbox-0.24.0.0 (OmariNorman)
07:23:01 <tdammers> > (runReaderT (do { y <- ask; liftIO (putStrLn y) }) "hello") :: IO ()
07:23:03 <lambdabot>  <IO ()>
07:23:06 <tdammers> oof
07:38:26 <ph88> When i have a ByteString is it possible to get a slice without allocating a new ByteString? Just by using some offset and length within the first ByteString
07:39:32 <merijn> ph88: It's definitely possible to do, but I dunno if the standard API has a method for it
07:39:47 <ph88> i'm looking around but i can't find one
07:39:56 <ph88> i don't know if i can access Internal module stuff
07:39:59 <merijn> ph88: Strict ByteString is just a thinly wrapped ForeignPtr which you can offset just fine
07:40:04 <mananamenos> hi, `nix-shell --pure -p ghc cabal-install cabal2nix --run "cabal init"` before i used to get interactive initing of project asking me stuff, now it just finishes producing files
07:40:11 * hackage non-empty-sequence 0.2.0.4 - Non-empty sequence  https://hackage.haskell.org/package/non-empty-sequence-0.2.0.4 (OmariNorman)
07:40:15 <merijn> ph88: https://hackage.haskell.org/package/bytestring-0.10.10.0/docs/Data-ByteString-Internal.html#t:ByteString
07:40:50 <ph88> am i allowed to use that data constructor myself ?
07:41:01 <EvanR> define "get a slice"... if you mean use bytes then ForeignPtr... if you mean have a slice value that you can pass around then it seems contradictory to not allocate a tuple for it
07:41:17 <c_wraith> ph88: no, the police will be notified
07:41:51 <EvanR> Internal Module Investigators
07:42:10 <merijn> ph88: split's documentation says it returns shared bytestrings, for example
07:42:24 <ph88> ye i saw that
07:42:30 <c_wraith> take and drop both say they're O(1), which means they can't copy the array
07:42:57 <dminuoso> c_wraith: Unless the documentation lies of course. :p
07:42:59 <merijn> Yeah, looking at the implementation of take and drop they literally just do what I referred to with the ForeignPtr :)
07:43:00 <EvanR> ByteString slices are already a pointer and a length
07:43:26 <EvanR> but ph88 sounds like they don't want to literally allocate a ByteString wrapper that holds them
07:43:28 <merijn> Odd that it doesn't expose a function to break sharing
07:43:35 <EvanR> they do
07:43:43 <merijn> EvanR: Where?
07:43:58 <merijn> oh, copy
07:43:59 <EvanR> copy :: ByteString -> ByteString
07:44:18 <merijn> I was looking for "force" like Vector uses
07:44:29 <geekosaur> "force" is kinda overloaded
07:54:42 * hackage tmp-postgres 1.11.0.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.11.0.0 (JonathanFischoff)
08:09:33 <jonathanmore> Is there a function that takes two lists, and returns a list that corresponds to list1, but with all common elements removed?
08:09:42 <jonathanmore> A "subtract", if you will
08:09:57 <dmj`> > [1,2,3] // [2]
08:09:58 <lambdabot>  error:
08:09:58 <lambdabot>      • Couldn't match expected type ‘Array i e’
08:09:58 <lambdabot>                    with actual type ‘[Integer]’
08:10:38 <dmj`> > [1,2,3] \\ [2]
08:10:40 <lambdabot>  [1,3]
08:10:44 <dmj`> voila
08:11:15 <jonathanmore> thank you
08:11:27 <MarcelineVQ> depends how common, e.g. [1,2,2,3] \\ [2]
08:13:37 <EvanR> > [1,2,2,3] \\ [2]
08:13:39 <lambdabot>  [1,2,3]
08:13:52 <EvanR> > [1,2,2,3] \\ (repeat 2)
08:13:58 <lambdabot>  mueval-core: Time limit exceeded
08:14:05 <ski> jonathanmore : hm, sounds like you want symmetric difference ?
08:14:15 * geekosaur was just wondering if that would fly, but suspecting not
08:14:19 <ski> hmm
08:14:29 <geekosaur> (the repeat thing)
08:14:34 <EvanR> i want my money back
08:14:37 <ski> oh, i see
08:14:43 <jonathanmore> I realiozed it is easier to solve it in a clearar, but less elegant way
08:14:54 <jonathanmore> keeps the code understandable by beginners
08:14:57 <jonathanmore> ty anyways
08:15:40 <EvanR> if the lists have no duplicates then \\ is set minus
08:16:00 <EvanR> pretty straightforward (unless i guess if the right list is infinite)
08:16:58 <ski> > foldr (filter . (/=)) "abacabad" "db"
08:17:00 <lambdabot>  "aacaa"
08:21:32 <mananamenos> `cabal init --exe --tests --test-dir=./tests` this does not create a tests dir :/
08:21:45 <mananamenos> what am i doing wrong?
08:27:09 <ph88> i wrote a custom build type, now the preconf hook is executed on each `stack run` .. is there any way to avoid that ?
08:27:23 <ph88> i think this only started happening since i added a confhook too
08:30:46 <phadej> in short: if you use build-type: Custom, you are more or less on your own
08:31:00 <ph88> hmm actually it depends .. sometimes it reruns other times not .. but i can't tell when or when
08:31:06 <ph88> hi phadej 
08:32:32 <ph88> i think after haskell sources recompile succesfully it's always ran atm
08:33:26 <ph88> phadej, do you know if i can pass a custom flag to `stack build` and then catch it in Setup.hs ?
08:34:11 <phadej> I doubt
08:34:41 <dmwit> mananamenos: I think nothing.
08:34:49 <phadej> build-type: Custom is wrong solution in 99.9% of use cases
08:34:57 <dmwit> Is running `mkdir tests` separately a problem for some reason?
08:35:32 <ph88> can i tag a data constructor without arguments with a number on the type level so that i can use this number later in my code ?
08:36:20 <dmwit> Yes, by adding a type parameter to the type constructor, or by using the pre-baked Tagged type.
08:37:04 <dmwit> But... this, too, sounds like it might be an XY problem.
08:38:09 <ph88> there is an API that accepts values 1 or 2  and i'm writing a library and i want to expose some data type. And not write in my own functions case statements for mapping data constructor to 1 or 2
08:38:16 <ph88> i rather have it in the type definition
08:39:05 <dmwit> What is wrong with `notFromEnumLol :: YourSemanticallyMeaningfulType -> Int`?
08:39:47 <ph88> not so much .. just that i like it in my type definition to keep code organized that way
08:39:50 <EvanR> the Enum class
08:41:10 <dmwit> But, like... even if you do that, you're still going to have to write `evenWorseNotFromEnumLol :: YSMT a -> Int` to be able to use this other API.
08:42:16 <ph88> what's that "a" int "YSMT a" ?
08:42:31 <dmwit> It's the type-level number you attached to the data constructor.
08:42:42 <EvanR> data YTMD a =
08:42:50 <EvanR> dang
08:42:54 <EvanR> YourSemanticallyMeaningfulType
08:43:03 <EvanR> NowDog
08:43:07 <ph88> i would like data constructor like   data MyType = One | Two
08:43:26 <dminuoso> ph88: You can still do `data MyType a = One | Two`
08:43:51 <dmwit> What you are asking for -- attaching a type-level number -- can be achieved like `data MT a where One :: MT 1; Two :: MT 2`.
08:44:00 <ph88> i want to attach a `1` to `One`   and a   `2` to `Two`
08:44:08 <dmwit> But it still is going to suck in all the same ways.
08:44:14 <ph88> :(
08:44:17 <dminuoso> ph88: To what end, exactly?
08:44:20 <dnikolovv> hey guys what's the issue
08:44:24 <dminuoso> ph88: I too think this is an XY problem.
08:44:33 <dmwit> Sure, you can write `getKnownNat :: MT a -> (KnownNat a => b) -> b; getKnownNat One = knownNat; getKnownNat Two = knownNat`.
08:44:55 <dmwit> And then `getInt = getKnownNat natVal` or whatever.
08:45:13 <dmwit> But that honestly looks significantly worse to me than `data MT = One | Two; getInt One = 1; getInt Two = 2`.
08:45:18 <dmwit> Just a ton of boilerplate with no benefit.
08:45:39 <EvanR> well the more info you put in the types themselves the more ghc can tell you when you screw up
08:45:49 <EvanR> however, it can't stop you from putting the wrong info in the types
08:46:13 <EvanR> the GADT definitions are like kernel of trust
08:46:16 <EvanR> also the instances
08:46:34 <dmwit> Aw, hell, I guarantee I can write a bug even with ph88's version.
08:46:42 <ph88> o_O
08:46:55 <dmwit> Well, with the version I'm saying satisfies ph88's (bad, I think) constraints.
08:47:11 <EvanR> but if you go the type-hairshirt way, at least there is *something* ghc can check, the functions
08:47:47 <dmwit> Or: why is the GADT definition being in the TCB better than `getInt` being in the TCB?
08:48:09 <EvanR> culture :)
08:48:25 <dmwit> heh
08:48:55 <EvanR> fork and knife on the left or right side of plate
08:49:43 <ph88> now that i have a GADT is there a way to check if a number correspons with any of the type-level attached numbers ?
08:49:48 <ph88> equality
08:50:25 <EvanR> :t testEquality
08:50:26 <lambdabot> error: Variable not in scope: testEquality
08:50:51 <c_wraith> you can only do that if you can enumerate constructors.
08:51:35 <EvanR> testEquality :: TestEquality f => f a -> f b -> Maybe (a :~: b)
08:52:15 <ph88> that looks somewhat like this  https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-TypeLits.html#v:sameNat
08:52:29 <c_wraith> that's not the hard part.
08:52:52 <c_wraith> the hard part is getting all the constructors to test against
08:54:24 * dmwit . o O ( just derive Enum and move on with your life )
08:54:46 <c_wraith> you can't derive Enum usefully for that type 
08:55:03 <c_wraith> :t succ
08:55:04 <lambdabot> Enum a => a -> a
08:55:10 <c_wraith> that's a type error.
08:55:14 <EvanR> data YSMT = NothingToSeeHere | One | Two deriving Enum :)
08:55:18 <dmwit> ^
08:55:46 <ashkan_kiani> dmwit: Thanks for your snarky help, but I obviously *did* ask tsuru. However, they often recruit from and work here, and it was midnight in Japan when I asked.
08:55:50 <dmwit> But I would skip NothingToSeeHere, I think. Just add 1 where appropriate.
08:56:05 <EvanR> :S
08:56:40 <dmwit> I don't understand why "it was midnight in Japan" makes my advice snarky. But okay.
08:57:02 <c_wraith> dmwit: it doesn't. your delivery does. :P
08:57:38 <MarcelineVQ> it's snowing on mt fuji
08:57:54 <ashkan_kiani> c_wraith: bingo
08:58:17 <EvanR> fuj mounti
08:58:59 * dmwit shrugs
08:59:25 <dmwit> Wasn't obvious to me that it had already been done. And it was honestly what I considered the best course of action. Can't think of anything nicer to do than suggest the best course of action I can think of.
08:59:55 <ashkan_kiani> to be fair, I'm being stupid for trying to determine tone from text
09:02:53 <ashkan_kiani> my bad
09:06:18 <EvanR> I'm kind of annoyed that unsafeInterleaveIO is in the System.IO.Unsafe module, along with the likes of unsafePerformIO, unsafeDupablePerformIO, and historically worse monstrosities
09:06:38 <EvanR> someone looks at what you're importing and thinks you've gone mad
09:06:53 <EvanR> guilty by association
09:07:22 <MarcelineVQ> guilty of lazy IO, you monster
09:07:48 <EvanR> at least i'm not using it for I/O
09:08:28 <EvanR> i want to read IORefs "out of order"
09:17:42 * hackage ats-pkg 3.3.0.7 - A build tool for ATS  https://hackage.haskell.org/package/ats-pkg-3.3.0.7 (vmchale)
09:18:42 * hackage generic-xmlpickler 0.1.0.6 - Generic generation of HXT XmlPickler instances using GHC Generics  https://hackage.haskell.org/package/generic-xmlpickler-0.1.0.6 (AdamBergmark)
09:36:10 <phanimahesh> Can anyone help me with sending a http request with wreq, with a client certificate?
09:38:53 <phanimahesh> I'm probably doing something stupid.
09:39:57 <phanimahesh> SO far I created a manager with an overridden onCertificateRequest in ClientHooks, and using Wreq.getWith
09:40:01 <phanimahesh> I get a handshake failure
10:11:02 <reallymemorable> is there any reason why i wouldn’t be able to run two haskell programs on the same AWS instance?
10:11:20 <Rembane> reallymemorable: No
10:11:57 <reallymemorable> great
10:19:41 <ph88> dmwit, if i make a simple function i need one to convert from type to int and another one to check if the nr is part of the type .. 2 extra functions as well
10:20:48 <djanatyn> slowly working my way through the concepts i need to understand to use the co-log library
10:21:19 <djanatyn> contravariant functors confuse me still but i'm watching George Wilson's talk at Lambda Jam 2018
10:21:31 <dave_uy> I'm using Network.Simple.TCP. How do I catch a network timeout exception?  I only know how to catch `SomeException`. https://gist.github.com/dmp1ce/61528228505bc8d9b997e62f4944f13f
10:23:42 <Rembane> dave_uy: What's the name of the exception you want to catch?
10:25:14 <dave_uy> Rembane: I don't know. How would I find out?
10:26:06 <dave_uy> Maybe this is an issue for the library I'm using.
10:27:25 <monochrom> My http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml#supertyping may help you discover the exception type you need.
10:28:42 * hackage haskoin-store 0.18.7 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.18.7 (xenog)
10:28:43 <Rembane> dave_uy: Run the program, create a timeout and see what it throws.
10:30:06 <dave_uy> Rembane: I am doing a `show e` like shows in the code snippet. This is all I see on the CLI: check_cgminer: sendCGMinerCommand error: user error (Network.Simple.TCP.connectSock: Timeout on connect)
10:31:11 <dave_uy> Is there a type to that besides just `SomeException`? 
10:33:17 <Rembane> dave_uy: Interesting. And a not very helpful error message. Let me see...
10:33:20 <dave_uy> I'm guessing "user error (Network.Simple.TCP.connectSock: Timeout on connect" is the error from a lower level library.
10:33:21 <dminuoso> dave_uy: It's an IOException 
10:33:37 <dminuoso> dave_uy: It's still not ideal though. 
10:34:16 <dave_uy> That does help! But I was hoping it would be more specific.
10:34:38 <Rembane> dave_uy: What dminuoso said, here's the source code if you want to see how they do it: https://hackage.haskell.org/package/network-simple-0.4.5/docs/src/Network.Simple.TCP.html#connectSock
10:34:56 <dminuoso> dave_uy: It's not.
10:35:41 <dave_uy> That's OK. Thanks!
10:50:51 <ph88> jle`, are you here ?
10:52:41 * hackage fused-effects-lens 1.0.0.0 - Monadic lens combinators for fused-effects.  https://hackage.haskell.org/package/fused-effects-lens-1.0.0.0 (patrick_thomson)
10:53:42 * hackage fused-effects-random 1.0.0.0 - Random number generation for fused-effects.  https://hackage.haskell.org/package/fused-effects-random-1.0.0.0 (patrick_thomson)
10:56:12 * hackage fused-effects-resumable 0.1.0.0 - Resumable exceptions for the fused-effects ecosystem.  https://hackage.haskell.org/package/fused-effects-resumable-0.1.0.0 (patrick_thomson)
11:14:11 * hackage sgd 0.8.0.3 - Stochastic gradient descent library  https://hackage.haskell.org/package/sgd-0.8.0.3 (JakubWaszczuk)
11:14:54 <djanatyn> does the List functor have a contravariant functor instance defined with contramap :: (b -> a) -> f a -> f b
11:15:06 <dminuoso> djanatyn: How would you implement that?
11:15:12 <djanatyn> you can't!
11:15:17 <djanatyn> ...right?
11:15:21 <dminuoso> djanatyn: Try it.
11:15:29 <djanatyn> i've been trying for a while :)
11:15:52 <dminuoso> djanatyn: There's a way to implement it in a way that it type checks.
11:16:08 <dminuoso> djanatyn: Checking the laws might be a good excercise then.
11:16:14 <djanatyn> dminuoso: thank you :)
11:16:23 <EvanR> show that a contravariant instance for list would prove Void if you had one
11:19:21 <djanatyn> i'm just stumped because you have a list of a, you need to get to a list of b, but the only transformation you have is the wrong direction: (b -> a)
11:19:47 <djanatyn> contramap f [x:xs] = ... -- no matter what i do here, i can't turn these elements into something else with the function i'm supplied with
11:19:57 <EvanR> pretty much
11:20:07 <dminuoso> djanatyn: For the purpose of this excercise, it might be interesting to figure out what implementation there is that will type check.
11:20:18 <dminuoso> There is one (without using bottom)
11:22:44 <djanatyn> i know that ignoring the function and returning the empty list (or really, any list of type :: f b) would typecheck
11:22:53 <djanatyn> contramap _ [x:xs] = []
11:23:07 <dminuoso> Good. Check the laws for that implementation.
11:23:07 <EvanR> this is why you'd need to use the laws to do my exercise
11:24:27 <dminuoso> djanatyn: Secret tip, you only need to prove `contramap id = id` - the other one follows from a free theorem.
11:24:41 <djanatyn> well, i don't remember all the laws, but i know that this is sensible and doesn't work with lists: contramap id
11:24:56 <dminuoso> djanatyn: You just need to demonstrate `contramap id = id` :)
11:24:58 <djanatyn> or i guess more precisely: contramap id == id
11:25:44 <djanatyn> so that implementation doesn't conform to the way i expect an fmap on a functor to work
11:26:09 <djanatyn> "Theorems for free!" is at #2 on my list of papers to read through
11:26:23 <EvanR> only by doing my exercise will the case be ultimately settled :)
11:26:32 <electricityZZZZ> is there a way i can select a haskell function and then hook into it to extract either (its inputs and outputs) or (some kind of histogram of its inputs and outputs)... i am going to guess that currying means that i can't meaningfully define "when the function is invoked"?
11:26:36 <EvanR> then you know it's impastable
11:27:07 <dminuoso> EvanR: What do you mean by "when the function is invoked"
11:27:13 <EvanR> bzz
11:28:14 <electricityZZZZ> right i am saying that i might not be able to define that... 
11:28:31 <dminuoso> Err electricityZZZZ ^- :)
11:28:34 <dminuoso> electricityZZZZ: What is your goal
11:29:05 <EvanR> electricityZZZZ: there is "when an expression is evaluated", which can be observed with unsafePerformIO on the best of days
11:29:26 <EvanR> optimizations and such can confuse the issue
11:29:57 <EvanR> but expressions are only evaluated once
11:30:08 <dminuoso> They might not.
11:30:20 <EvanR> ... unless duplicated!
11:30:25 <EvanR> yay
11:30:29 <dminuoso> Any expressione can be evaluated any of: 1) never. 2) once. 3) many times
11:30:33 <electricityZZZZ> well i can simplify what i am asking if we suppose that i am only interested in a function which is simply a map from type a to b, f :: a -> b
11:30:56 <sm[m]> can be observed with trace
11:30:57 <sm[m]> which I think should be required for every new haskeller
11:30:59 <EvanR> you just described every function
11:31:28 <electricityZZZZ> well i can see that if i have g :: a -> b -> c -> d  you can obtain abcd only at times where all of them are defined
11:31:47 <EvanR> what's abcd ?
11:31:57 <EvanR> g x y z ?
11:32:27 <EvanR> yes i meant to say Debug.Trace
11:32:30 <electricityZZZZ> g 1 2 3 4 is meaningful for printing the output, g 1 2 3 is not because the 4th arg isn't yet defined
11:32:43 <EvanR> there are only 3 args
11:32:49 * EvanR activates the torture device
11:33:09 <electricityZZZZ> oops yeah haskell notation is still foreign to me ;)
11:33:19 <dminuoso> electricityZZZZ: What is it you are trying to figure out or trying to solve?
11:33:51 <electricityZZZZ> i am playing with computer programs and was curious about the fact that there are good algorithms for generating so-called online histograms
11:34:00 <dmwit> ph88: That's correct. But you have made an imperative mistake: you have made an "if" and a "then", but no "else".
11:34:22 <dmwit> ph88: And when you write down the "else", you will find out that the "else" branch has all the same properties, plus more boilerplate.
11:34:33 <dmwit> (all the same bad properties, in particular)
11:34:50 <electricityZZZZ> so in some cousin of haskell at least you should be able to observe either "every invocation" of a function or some large random subset of invocations and construct a histogram
11:35:04 <electricityZZZZ> of all of its inputs and outputs,... i think that could be very interesting for understanding program behavior
11:35:25 <ph88> dmwit, i was betting that the alternative the boilerplate is write once, abstract over many data types and thus not boilerplate
11:35:37 <dmwit> bad bet
11:35:47 <electricityZZZZ> and when i say construct a histogram i mean that the amount of memory used for that function should be rather small and never need to grow large to build the histogram
11:36:02 <EvanR> yes well, it would be a trivial matter instead to measure everytime some action :: IO A was executed
11:36:16 <EvanR> that could be made into a nice wrapper
11:36:23 <ph88> dmwit, you think it's not possible or what ?
11:36:48 <EvanR> hmm.. a wrappee
11:36:53 <electricityZZZZ> one application for this would be automatically constructing tests for functions with IO 
11:37:05 <EvanR> that's the thing, functions don't do IO
11:37:11 <EvanR> they only build IO actions
11:37:12 <electricityZZZZ> so you could observe your program executing in the real world and write down some IO examples
11:37:22 <EvanR> maybe you want to track usage of certain IO actions instead
11:38:06 <electricityZZZZ> well IO at the end of the day is some data or program state and so you need either 1 - live testing or 2 - some undefined snapshotting process to construct your tests so you know things still work
11:38:20 <electricityZZZZ> so one thing i am thinking about is that snapshotting process
11:38:43 <dmwit> ph88: I don't know what the "it" in "it's not possible" is. But no, I don't think you'll manage to pull off write-once boilerplate for what you're proposing.
11:38:44 <electricityZZZZ> also i am thinking that if you run your program and can construct good histograms/distributions on arguments you can do interesting things with memory allocation
11:38:54 <EvanR> you skipped the easy part of testing non-IO stuff entirely
11:39:14 <EvanR> the less IO the better
11:39:14 <electricityZZZZ> yeah i am just trying to describe why i think this is interesting
11:39:17 <ph88> dmwit, that be to my own limitations rather than what is possible in haskell i expect
11:39:22 <electricityZZZZ> IO = real world
11:39:41 <EvanR> more like in haskell IO = not very precisely defined
11:39:52 <EvanR> = anything under the moon
11:40:04 <dmwit> ph88: Perhaps. But if so, I have similar limitations. =)
11:40:23 <electricityZZZZ> it will be a long time before i understand what people mean when they say IO so maybe i shouldn't have brought it up
11:40:44 <electricityZZZZ> sure so if we are just working with functions which take integers and produce integers it would be fun to generate histograms on that
11:40:46 <EvanR> the IO type constructor, DSL, is what i was talking about
11:41:30 <EvanR> intercepting when functions are used, this idea is used in memocombinators. Might be a place to look first
11:41:41 <ph88> dmwit, it's possible to use GHC.Generics to get a list of data constructors. And map natVal over them
11:42:05 <djanatyn> id :: (a -> a); contramap :: (b -> a) -> f a -> f b; contramap id [1,2,3] = []; id [1,2,3] = [1,2,3] -- ?
11:42:40 <dmwit> [] is not a Contravariant instance, so contramap id [1,2,3] is a type error.
11:43:05 <EvanR> djanatyn: you just proved that instance is illegal, though you still didn't prove contravariant for list is in general impossible
11:43:26 <dmwit> Oh. I guess I'm missing context. Apologies, then.
11:43:32 <djanatyn> hmm...
11:43:32 <EvanR> ya
11:43:55 <electricityZZZZ> EvanR: yeah you could do this for memoization too
11:44:38 <dmwit> ?free (b -> a) -> [a] -> [b]
11:44:38 <lambdabot> Try `free <ident>` or `free <ident> :: <type>`
11:44:43 <dmwit> ?free contramap :: (b -> a) -> [a] -> [b]
11:44:43 <lambdabot> g . h = k . f => $map f . contramap h = contramap k . $map g
11:47:24 <EvanR> djanatyn: so, to prove Void it suffices to have constructed a forall a b . a -> b. Then you can pick a=() and b=Void and apply it
11:47:37 <djanatyn> do i have to work entirely in type signatures to prove contravariant for list is impossible?
11:47:47 <djanatyn> thank you for all the advice
11:47:50 <EvanR> no i don't think so
11:49:13 <dmwit> EvanR: I have `x :: [Void]`. Do you believe me when I say that `x = genericReplicate n undefined` for some lazy nat `n`?
11:49:53 <EvanR> sure?
11:49:56 <dmwit> (i.e. or do you, the exercise setter, want me to prove it somehow?)
11:50:48 <EvanR> so n must be zero and then you can go back to what djanatyn just said
11:51:29 <EvanR> using undefined kind of defeats the purpose though
11:51:41 <dmwit> I don't know the purpose.
11:51:46 <EvanR> or bad recursion
11:51:56 <dmwit> (My question was sort of trying to flush out the purpose.)
11:52:09 <EvanR> dmwit: djanatyn has been dwelling at length on the idea of writing a Contravariant instance for list
11:52:19 <EvanR> they can't seem to do it, no matter how hard they try
11:52:31 <dminuoso> electricityZZZZ: Regarding IO. There's a really neat and simple way to think of `IO`. think of `IO Int` as a list of assembly instructions that, if they were executed, would give you a result of type Int. :)
11:52:37 <EvanR> they just concluded using empty list type checks but violates laws
11:52:42 <EvanR> and still might not be satisfied so
11:52:46 <djanatyn> yeah, i'm not satisfied yet
11:53:02 <MarcelineVQ> @quote /ls
11:53:02 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
11:53:19 <dmwit> djanatyn: Okay, then I ask my question to you instead. I have `x :: [Void]`. Do you believe me when I say that `x = genericReplicate n undefined` for some lazy nat `n`?
11:54:48 <nshepperd1> What would not believing you constitute
11:55:34 <dmwit> A demand that I descend into more acceptable axioms, and prove that fact from the more basic ones.
11:57:01 <djanatyn> i don't think i understand the question - it seems like that function type-checks iff (undefined :: Void)
11:57:29 <EvanR> i object to the introduction of undefined into my exercise
11:57:31 <djanatyn> but constructing that term is not useful in showing anything
11:57:45 <EvanR> Void has no values
11:57:59 <djanatyn> then...i don't believe that...?
11:58:13 <EvanR> "some nat n"
11:58:28 <Lears> I guess the point is that if you have a [Void], then you either have [] or some potentially infinite list containing only bottoms.
11:58:30 <jle`> hm. well maybe you can say that, disregarding bottoms and laziness, the only value of type [Void] is [], the empty list.  and so contramap absurd :: [a] -> [Void] must return an empty list
11:58:54 <dmwit> (Yes, that is where I was heading.)
11:59:22 <dmwit> djanatyn: If you banish undefined from the language, then I will say this insetad: I have `x :: [Void]`. Do you believe me when I say that `x = []`?
11:59:34 <EvanR> thank you jeebus
12:00:07 <dmwit> (i.e. there is *no* term that has that type is beta-eta-inequal to [])
12:00:24 <dmwit> s/is beta/and is beta/
12:01:29 <jle`> so if we establish that `contramap asburd xs` must return the empty list (contramp absurd xs = []), then it must also be the case that `contramap _ _ = []`
12:01:37 <jle`> but then this breaks ....
12:01:43 <jle`> (rest of the exercise left to the reader)
12:02:07 <EvanR> so uh... in simple terms... if list had a law abiding contravariant instance, you could do gratuitous magical things
12:02:08 <jle`> btw absurd is the total function, absord :: Void -> a, if it wasn't clear
12:02:30 <jle`> hm, my point was more that contramap _ _ = [] breaks contramp id = id
12:02:36 <jle`> and so you have two constraints that cannot be satisfied
12:02:43 <jle`> so there is no lawful implementation
12:03:01 <djanatyn> my understanding is that the List type is a lawful contravariant functor instance for empty lists. it does not respect identity morphisms (id) for non-empty lists (because there's no way to get back to the original list - no isomorphism?). the type [Void] is the only [a] to have a single term that satisfies the laws: []
12:03:03 <EvanR> i was trying to get djanatyn to produce unsafeCoerce using that law
12:03:20 <jle`> i don't think you can produce unsafeCoerce using that law
12:03:29 <jle`> but i might not be seeing something
12:03:40 <EvanR> well that law or the other one
12:03:50 <dmwit> jle`: For me, there is some justification needed between `contramap absurd xs = []` and `contramap _ _ = []`.
12:03:54 <jle`> djanatyn: so i'm mixing two things here, the fact that [Void] has only one inhabitant, [], is not a property of any laws. it's just a fact of the type [Void]
12:04:04 <djanatyn> jle`: sure
12:04:16 <jle`> djanatyn: so however you define contramap, contramap absurd :: [a] -> [Void], it *must* return the empty list
12:04:22 <jle`> since the empty list is the only possible result
12:04:26 <EvanR> if you had a Void, you could have unsafeCoerce (use absurd)
12:04:42 <jle`> djanatyn: so the only way to get that, is by `contramap _ _ = []`
12:04:50 <jle`> since you cannot "pattern match" on functions.
12:05:07 <jle`> you can only treat it uniformly for all functions, so the only way to ensure that contramap absurd _ = [] is by writing contramap _ _ = []
12:05:24 <jle`> EvanR: yes, but you cannot get void because contramap only returns [something], guarded in a list
12:05:37 <jle`> djanatyn: so the only allowed implementation for contramap is `contramap _ _ = []`.
12:05:54 <djanatyn> jle`: makes sense!
12:06:03 <jle`> however, even though this is the only allowed implementation, it's law-breaking: it doesn't satisfy the law contramap id == id
12:06:17 <jle`> so the only typechecking implementation breaks the laws. so no implementation is possible
12:06:29 <djanatyn> wow, that's beautiful
12:06:50 <djanatyn> i've never walked through a proof that an implementation of a lawful typeclass was not possible
12:06:57 <djanatyn> for a specific instance
12:07:14 <jle`> heh usually we just try at it for a while and can't get anything nice that typechecks and give up
12:07:26 <djanatyn> that's what I did before coming to this channel :)
12:07:35 <EvanR> if you have a thing that is following a law and breaking it too, there will be a way to get a Void
12:08:14 <EvanR> given the right formalism :)
12:09:05 <EvanR> the original problem was "assume i gave you a lawful instance, dot dot dot" you proved that if you had that, it would break laws. Contradiction
12:09:19 <EvanR> normally there's nothing wrong with breaking laws. But we started with the assumption you weren't
12:09:30 <jle`> yeah, but you cannot produce Void with an unlawful contravariant instance of list still
12:09:40 <jle`> unless the law was a part of the type/value system
12:09:52 <EvanR> djanatyn showed a while back some steps to show [] = [1,2,3]
12:11:29 <jle`> that would only allow you to produce Void if the law was a part of the type system, like class Contravariant f where idLaw :: forall a (xs :: [a]). contramap xs == xs
12:11:38 <jle`> *contramap id xs
12:12:02 <jle`> ==/:~: since we are in haskell
12:12:08 <EvanR> yes well we have plenty of handwaving left in the back
12:12:17 <EvanR> if we need it
12:12:56 <jle`> hm, my point was that saying that breaking laws allow you to produce Void might lead you to seeking Void as a goal in proving a laws cannot be satisfied
12:13:02 <EvanR> [] = [1,2,3] gives 0 = 1 or True = False
12:13:04 <jle`> but seeking Void here would get you nowhere
12:13:22 <jle`> or it would just mislead you
12:13:33 <jle`> Void the data type, at least
12:14:08 <jle`> so it is impossible here to literally 'produce unsafeCoerce'
12:14:14 <EvanR> of course, undefined :: Void and everything is true, and false
12:14:47 <EvanR> i guess i was talking about some function with that type not one that segfaults
12:15:07 <jle`> i'm saying that leading someone to try to produce unsafeCoerce in this case is not going to get them anywhere, since it's not possible without undefined, which breaks the premise of the exercise in the first place
12:15:23 <EvanR> if you can get a function with that type without cheating you know something is rotten in denmark
12:15:48 <EvanR> are you also complaining because the laws aren't even in the type system? come on
12:16:13 <jle`> EvanR: i'm saying that the guide to "try to produce unsafeCoerce" is not going to be helpful, because you cannot produce unsafeCoerce
12:16:26 <EvanR> i said that to you not them, anyway
12:16:45 <EvanR> you don't have to do it
12:18:07 <Lears> Can't you just do `head (contramap absurd [()])`? That should be defined, since `contramap id = id` implies `length . contramap f = length` ...
12:18:09 <jle`> i meant to say that in the context of using it as a principle for yourself to guide someone to a concluion.
12:18:26 <jle`> Lears: head is not a total function, so it doesn't really work here since we are excluding bottom
12:18:52 <EvanR> i'm impressed that you managed to satisfy them of the fact while simultaneously making me unsatisfied with the result
12:19:21 <EvanR> since it's even more wishy washy than where i was going
12:19:49 <EvanR> but this is haskell so whatevs
12:20:57 <kleisli> does anyone know of an existing language supporting "modular type classes" ala Dreyer, Harper, and Keller?
12:21:34 <jle`> being able to 'produce unsafeCoerce' in a total/safe way is not possible with a theoretical lawful instance of Contravariant for list; it's just not accessible to us within curry-howard as a logic system. that might be why it's unsatisfying: you have to go beyond the type system to prove it, which means unsafeCoerce is not a logical implication
12:22:00 <jle`> however it's definitely possible for NonEmpty :)
12:22:20 <jle`> well because you can disprove an instance for NonEmpty without ever referring to the contravariant functor laws
12:22:20 <EvanR> we're clearly not using the usual logic system
12:22:32 <jle`> yeah, we're not using the usual logic system, so you cannot use unsafeCoerce
12:22:32 <EvanR> we can use laws
12:22:41 <EvanR> o_O
12:22:56 <jle`> that's my point. if you resort to laws, then you cannot get your system to produce unsafeCoerce
12:22:57 <EvanR> stop
12:27:42 <dmwit> I don't understand the claim "being able to produce unsafeCoerce is not possible with a theoretical lawful instance of Contravariant". You believe that such an instance does not exist. Therefore you should believe that assuming it makes all conclusions -- even unsafeCoerce -- possible.
12:29:45 <jle`> that's fair :) it would be possible, taking into account that the laws forbid it. but it wouldn't be possible to utilize that fact to arrive at an implementation of unsafeCoerce within Haskell
12:30:17 <dmwit> No. But it would be possible to utilize that fact to arrive at an implementation of the type `Contravariant [] => a -> b`.
12:30:47 <dmwit> That is, an implementation of the type "take a legal instance and produce unsafeCoerce".
12:32:40 <jle`> hm, how would that implementation look like, without using bottom?
12:33:29 <dmwit> I don't know. But I understand that question to be the meat of EvanR's proposed exercise.
12:33:49 <dmwit> And I think he is unsatisfied precisely because it's not obvious how to turn your English argument into a piece of code with that type.
12:35:24 <jle`> i agree that that is unsatisfying
12:36:48 <jle`> not only is it not obvious...i believe it is not posisble
12:36:58 <jle`> which makes it even more unsatisfying
12:37:42 <dmwit> Okay, here's a proposed proof.
12:37:46 <jle`> such a statement is a 'conclusion' in Curry-Howard. but that conclusion is unreachable to us within Curry-Howard, because we need extra-CH steps to justify it. so it will be forever out of our reach :(
12:38:00 <dmwit> No matter what g and k you choose, we have g . absurd = absurd = k . absurd.
12:38:18 <dmwit> In particular I pick g = id :: a -> a and k = id :: b -> b.
12:38:37 <dmwit> From the free theorem, therefore map absurd . contramap absurd = contramap id . map id.
12:38:49 <dmwit> By the functor and contravariant functor laws, the RHS there is id.
12:38:57 <dmwit> So map absurd . contramap absurd = id.
12:39:05 <dmwit> But map absurd . contramap absurd :: [a] -> [b].
12:39:38 <EvanR> yeah i thought maybe it would not work because you'd end up with just [a] -> [b] which is not offensive at all
12:40:00 <dmwit> Whoops. There's a magic step missing in my reasoning. I'll state it here to be as clear as possible: since map absurd . contramap absurd = id, then map absurd (contramap absurd [a]) has length 1.
12:40:12 <dmwit> (I don't know how to justify this claim.)
12:40:21 <jle`> it's justifiable
12:40:28 <jle`> from the free theorem for fmap
12:40:30 <dmwit> If that claim is true, then unsafeCoerce a = head (map absurd (contramap absurd [a]))
12:40:46 <jle`> namely length . map f == length
12:40:48 <dmwit> (and this is total)
12:40:51 <EvanR> \o/
12:41:15 <monochrom> Wait, are you guys deriving unsafeCoerce in Haskell2010?!
12:41:46 <dmwit> No, in Haskell2010 with an extra axiom: lawful instance Contravariant []
12:41:52 <EvanR> only to show that list can't be contrafunctor
12:42:27 <jle`> this is essentially what Lears wrote earlier, with a justification that the length has to remain the same
12:42:38 <dmwit> Yeah. I don't know how to justify that claim.
12:42:46 <jle`> it comes from a free theorem for map
12:42:47 <EvanR> length . map f = length
12:42:50 <jle`> i wonder ..
12:42:51 <dmwit> Your justification isn't it, because your justification doesn't mention contramap.
12:43:03 <dmwit> (But my implementation does mention contramap.)
12:43:08 <EvanR> er
12:43:15 <jle`> hm, i'm assuming contramap has the same free theorem
12:44:11 <jle`> oh, the free theorem i'm using isn't a free theorem of functors, but rather a free theorem of naturla transformations
12:44:24 <dmwit> I'll be honest: I don't even see how to derive length . map f = length from the free theorem for map.
12:44:44 <jle`> say you had the natural transformation:
12:44:55 <jle`> @let nlength = Const . length
12:44:56 <lambdabot>  Defined.
12:44:59 <jle`> :t nlength
12:45:01 <lambdabot> forall k (t :: * -> *) a (b :: k). Foldable t => t a -> Const Int b
12:45:25 <jle`> then fmap f . nlength == length . fmap f
12:45:35 <jle`> * fmap f . nlength == nlength . fmap f
12:45:47 <dmwit> Surely to conclude that you must first prove that nlength is a natural transformation.
12:45:59 <jle`> or mapConst f . nlength = nlength . map f
12:46:07 <jle`> and mapConst f == id for all f, so nlength = nlength . map f
12:46:35 <jle`> dmwit: right, the fact that nlength is a natural transformation is guaranteed from parametricity...i think... i keep on hearing people talk about it
12:46:50 <jle`> how a forall x. f x -> g x is necessarily a natural transformation because of parmaetricity
12:46:53 <dmwit> I believe it to be true. But I don't know how to prove it.
12:47:47 <comerijn> dmwit: I have a simple strategy for that
12:47:52 <comerijn> dmwit: Proof by handwaving
12:48:20 <jle`> hm. in any case i'm not super satisfied in having to do extra-HC steps to prove that head must be total in that case
12:48:50 <jle`> but something like this, utilizing the fact that parametricity gives us this preservation of length, might be capturable within CH
12:49:31 <jle`> hm. no, it would require more than that, since it requires that fmap/contravariant are lawful in the first place, which is the conclusion we are trying to prove in the first place
12:49:55 <dansho> "cabal: unrecognized command: sandbox (try --help)"
12:50:14 <jle`> ah, but that part would at least be allowed because we're going for a proof by contradiction.
12:50:21 <dansho> cabal 3.0 removed sandboxes? it's still in the docs https://www.haskell.org/cabal/users-guide/installing-packages.html#sandboxes-basic-usage
12:59:47 <comerijn> dansho: v1-sandbox is the backwards compatible old command
12:59:56 <comerijn> dansho: But they are basically obsolete
13:01:11 <comerijn> dansho: v2-build (i.e. the new default in 3.0) is infitely better and simpler to use
13:02:13 <dansho> comerijn: where can i find explanation on how to migrate to the new system?
13:02:50 <merijn> dansho: You mean in terms of depending on unreleased libraries or just building stuff in general?
13:03:21 <dansho> i was using GHC_PACKAGE_PATH and now it doesn't seem to work
13:03:28 <merijn> dansho: v2-build takes a Nix-inspired approach of every version being tagged with a hash of it's transitive dependencies and allowing basically arbitrary numbers of parallel installs
13:03:53 <merijn> dansho: So it basically behaves as if every single package is automatically sandboxed for you (with possible sharing between sandboxes where possible)
13:04:23 <merijn> dansho: So the "migration" for simple package is "just run 'cabal build' and you're done" assuming you have working cabal files
13:04:32 <dansho> so i can just use cabal install and it won't end up in dependency hell?
13:05:05 <merijn> dansho: Correct, it will behave as if you have nothing installed, construct a build plan and then install all the missing parts (if any)
13:05:06 <dansho> cabal install --only-dependencies
13:05:35 <merijn> dansho: tbh for developing you don't really have to bother manually configuring/installing dependencies either it now happens automatically when you run "cabal build"
13:06:40 <merijn> dansho: So unless you want to depend on locally modified version of dependencies basically most of the old workflow is just redundant
13:08:41 <merijn> dansho: This should (I can't check, because for some reason the readthedocs domain is broken for me from home) have a basic overview https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
13:11:21 <dansho> ty
13:13:23 <Lears> @free eta :: F x -> G x
13:13:23 <lambdabot> $map_G f . eta = eta . $map_F f
13:13:46 <Lears> dmwit: The free theorem is the proof of natrality.
13:18:16 <jle`> oh neat
13:19:46 <jle`> @free length :: [x] -> ConstInt x
13:19:46 <lambdabot> $map_ConstInt f . length = length . $map f
13:21:22 <lavalike> what's ConstInt ?
13:22:40 <NemesisD> is there a smarter way to do this: given  (a -> b), with some possible restrictions on a, a way to go from (b -> Maybe a) without having to specify the mapping in both directions? https://gist.github.com/MichaelXavier/21e53e888cde7dee5d83dfdcd7e50c92
13:22:49 <jle`> lavalike: Const Int
13:22:56 <jle`> in a way that freebot can understand
13:23:29 <jle`> NemesisD: that way isn't necessarily true, either
13:23:34 <NemesisD> and then in either case, is my implementation here building that mapping every time on use if you give it the same `a -> b`?
13:24:25 <jle`> i believe your implementation should only build the map once
13:25:11 <jle`> types that can be fully enumerated interesting; there's a nice abstraction for them in the universe package
13:26:00 <jle`> and also finitary
13:26:40 <NemesisD> i didn't know about universe. 98% of the time i'm using derived Enum and Bounded for this purpose
13:27:10 <jle`> it's tricky because the Enum/Bounded laws don't ensure that all items are reached during the enumeration
13:27:40 <jle`> but i guess for all the types in base it does
13:27:50 <jle`> for types that are both bounded and enum
13:28:26 <NemesisD> yeah i mainly use it for simple sums. but i'd be willing to generally switch to universe since you can derive it so it grows as the datatypes change
13:29:23 <jle`> if there are some other properties of your function, there can be a better way to do it
13:29:39 <jle`> especially for a like Int where building a map of minBound .. maxBound is not practical
13:30:15 <jle`> for example if your function is monotonic you can do something like a binary search (if the space is bounded) or an exponential search (if bounded in one direction)
13:31:29 <jle`> if your function is differentiable you can use something like newton's method
13:35:42 * hackage scidb-hquery 2.8.0.436 - Haskell query for SciDB via shim  https://hackage.haskell.org/package/scidb-hquery-2.8.0.436 (mdgabriel)
13:43:16 <NemesisD> i'll just throw some guidance about suitable use cases in the docstring. this is going into a project prelude so i don't need to fret too much about using it to solve the wrong problem
14:31:19 <EvanR> slick AF stupid haskell trick of the month:
14:31:45 <EvanR> % [()|'c' <- Just 'c']
14:31:46 <yahb> EvanR: Just ()
14:31:49 <EvanR> % [()|'c' <- Just 'd']
14:31:50 <yahb> EvanR: Nothing
14:32:17 <EvanR> [a b c | C a b c <- Just e]
14:33:53 <wildtrees> EvanR, did you forget a %? 
14:34:16 <EvanR> it would have crashed
14:35:16 <EvanR> but this lets you check if something matches a single constructor as a Maybe real fast
14:36:03 <EvanR> and get the gooey goodness inside at the same time
14:38:50 <dsal> Can I dump out my .prof without exiting?
14:39:44 <EvanR> mkay [a b c | C a b c <- [e]] is the same thing and doesn't require MonadComprehensions
14:44:37 <wildtrees> if I use monadcomprehensions can I use "list comprehensions" for any monad? 
14:47:33 <jackdk> wildtrees: looks like it: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#monad-comprehensions -- "Enable list comprehension syntax for arbitrary monads."
14:47:57 <jackdk> I reference that page so much I should probably make it my homepage
14:50:40 <wildtrees> are they going to take fail out of Monad and put it in just MonadFail in the future? 
14:52:14 <EvanR> i thought that already happened
14:53:47 <jle`> it already happened
14:54:26 <jle`> % :i Monad
14:54:27 <yahb> jle`: class Applicative m => Monad (m :: * -> *) where; (>>=) :: m a -> (a -> m b) -> m b; (>>) :: m a -> m b -> m b; return :: a -> m a; fail :: String -> m a; {-# MINIMAL (>>=) #-}; -- Defined in `GHC.Base'; instance [safe] Monad m => Monad (MaybeT m) -- Defined in `Control.Monad.Trans.Maybe'; instance Monad f => Monad (Star f a) -- Defined in `Data.Profunctor.Types'; instance Monad (Costar f a) -
14:54:34 <jle`> hm, must be using 8.6 :|
14:55:12 <jle`> % System.Info.compilerVersion
14:55:12 <yahb> jle`: Version {versionBranch = [8,6], versionTags = []}
14:55:21 <Axman6> :o
14:57:24 <mercatoria> leave haskell
14:57:38 <EvanR> oh... i was about to say
14:58:11 * hackage purescript 0.13.5 - PureScript Programming Language Compiler  https://hackage.haskell.org/package/purescript-0.13.5 (hdgarrood)
15:01:12 <jle`> ...was that a threat?
15:01:42 <Axman6> do it, you won't
15:04:16 <wildtrees> % :info fail 
15:04:17 <yahb> wildtrees: class Applicative m => Monad (m :: * -> *) where; ...; fail :: GHC.Base.String -> m a; -- Defined in `GHC.Base'
15:04:51 <wildtrees> fail still seems to be there, or am I doing something wrong? 
15:09:19 <jackdk> it went away in 8.8
15:10:32 <wildtrees> does code have to be updated to handle that change? 
15:10:41 <jle`> it's gone in GHC 8.8
15:10:59 <jle`> wildtrees: the main breaking change is that if you defined fail = .. explicitly for your monads, it will now break
15:11:18 <jle`> and also if you used do notation or list notations with irrefutable patterns, it'll also fail unless you have a MonadFail instance
15:11:58 <jle`> and also if you use fail on a monad in specific it'll need a monadfail instance. this is related to the last one
15:12:04 <EvanR> refutable patterns?
15:12:27 <jle`> > do x <- Right 5; pure "hi"
15:12:28 <lambdabot>  Right "hi"
15:12:33 <jle`> that will fail in GHC 8.8
15:12:42 <jle`> er, that will not compile in GHC 8.8
15:13:15 <jle`> oh i just tried it and it seems it does. maybe they fixed it
15:13:18 <EvanR> what does that have to do with fail
15:13:33 <wildtrees> > do x <- Left 5 ; pure "hi" 
15:13:35 <lambdabot>  Left 5
15:13:36 <EvanR> it... can't fail
15:13:42 <jle`> > do Just x <- Right Nothing; pure "hi"
15:13:44 <lambdabot>  error:
15:13:44 <lambdabot>      • No instance for (Control.Monad.Fail.MonadFail (Either ()))
15:13:44 <lambdabot>          arising from a use of ‘e_1’
15:13:49 <EvanR> ^ makes more sense
15:13:55 <jle`> ah yeah that's what i meant
15:14:02 <wildtrees> I had heard pattern matching failing in do notation used to call fail from monad 
15:14:09 <EvanR> right
15:14:15 <jle`> yeah the (Just x) is the irrefutable pattern there
15:14:29 <EvanR> what...
15:14:31 <jle`> and it triggers a call to fail in the codegen
15:14:36 <wildtrees> can I still using those patterns in do notation? is there an option for that? 
15:14:56 <EvanR> you can implement MonadFail
15:15:20 <wildtrees> but is the do notation gonna desugar to include monadfail or only the new monad missing fail? 
15:15:34 <jle`> ah, do i really mean refutable and not irrefutable?
15:15:48 <jle`> > do ~(Just x) <- Right Nothing; pure "hi"
15:15:49 <EvanR> refuting is what i thought triggers fail
15:15:50 <lambdabot>  Right "hi"
15:15:57 <jle`> ah yeah, i mixed up the two
15:16:15 <jle`> refutable patterns trigger fail, irrefutable patterns do not
15:22:22 <wildtrees> jle`, whats that ~? 
15:22:39 <EvanR> lazy pattern
15:22:47 <wildtrees> !
15:22:54 <jle`> it means that it will "always match", no matter what
15:22:58 <Axman6> hey, that pattern is just as hard working as any other
15:23:05 <jle`> and it will only cause a runtime error when you use any of the bindings
15:23:14 <jle`> > do ~(Just x) <- Right Nothing; pure x
15:23:16 <lambdabot>  Right *Exception: <interactive>:3:4-29: Non-exhaustive patterns in Just x
15:23:49 <jle`> ghc just assumes that the pattern matches without actually looking at what it is matching on
15:23:55 <jle`> because it trusts you
15:24:16 <EvanR> it can enable some spiffy time traveling code
15:24:59 <EvanR> like when bill and ted assume they have prepared all the things necessary for the end of the movie, they just have to remember to go back and ensure it later
15:25:23 <EvanR> "or else"
15:26:18 <jle`> > isRight $ do ~(Just x) <- Right Nothing; pure x
15:26:19 <lambdabot>  True
15:28:08 <dmwit> % unsafeCoerce (do ~(Just x) <- Right Nothing; pure x) :: Bool
15:28:08 <yahb> dmwit: True
15:28:21 <Axman6> D:
15:28:24 <EvanR> what the
15:28:41 <jle`> Nothing unsafecoerces to the first constructor of any enumerable
15:28:59 <jle`> er, Left () does here, too i guess
15:29:02 <dmwit> Left/Right, False/True, tomato, tomahto
15:29:04 <EvanR> that's just asking for abuse
15:29:11 <jle`> * Right
15:29:28 <Axman6> % unsafeCoerce True :: Either () ()
15:29:28 <yahb> Axman6: Right [Segmentation fault]
15:29:38 <jle`> [constructor #, constructor contents]
15:29:39 <EvanR> hahahaha
15:29:50 <dmwit> Looking at more fields than the original value is dangerous. But looking at fewer fields is usually fine.
15:30:02 <EvanR> repeat (Segmentation fault)
15:30:32 <Axman6> % :t [Segmentation fault]
15:30:33 <yahb> Axman6: ; <interactive>:1:2: error: Data constructor not in scope: Segmentation :: t0 -> a; <interactive>:1:15: error: Variable not in scope: fault
15:30:44 <jle`> % data Pair a b = Pair a b
15:30:44 <yahb> jle`: 
15:31:03 <jle`> % unsafeCoerce (Pair "hi" "bye") :: Either String Double
15:31:03 <yahb> jle`: Left "hi"
15:31:13 <Axman6> :'(
15:31:19 <Axman6> this makes me unhappy
15:31:31 <EvanR> i'm so surprised that works
15:31:36 <jle`> i wonder if the bye gets garbage collected
15:31:50 <Axman6> would "bye" also be referenced by that Left?
15:32:03 <Axman6> yeah, that was exactly my though
15:32:04 <jle`> Axman6: well when you 'look at' a Left, you only look at the first pointer after the constructor #
15:32:05 <Axman6> t
15:32:12 <jle`> and you ignore the 2nd, 3rd ones
15:32:26 <Axman6> but the object that was allocated will contain the pointer to the others
15:32:39 <jle`> yeah i wonder how this works with GC
15:32:41 <EvanR> maybe this technique will attract more dynamic language fans
15:33:16 <Axman6> and the GC has no idea about types, just the objects it allocates, so I would be surprised if it did get GC's
15:33:41 <Axman6> would be easy to test if the second element were a ForeignPtr witha finaliser which printed something
15:33:55 <Axman6> GC'd*
15:33:56 <EvanR> if nothing is pointing to the "lost value"... it get's collected
15:34:35 <EvanR> if the wrong thing is pointing to the wrong thing, the universe gets corrupted
15:35:33 <EvanR> could be a cool premise for a video game
15:35:39 <EvanR> avoid the rogue GC
15:36:10 <EvanR> and the mutator
15:39:56 <phadej> rewire matrix, and keep it running
15:43:52 <jle`> Axman6: let me know if you find any interesting results :)
15:55:14 <Axman6> ain't no one got time for that
15:59:08 <olligobber> huh, runtime of (2^n)!4^(2^n), I think that's one of the slowest things I've written
15:59:57 <jackdk> GHC 8.8 added the ability to introduce new type variables in a rewrite rule, like `forall k. forall. f @(Map k) = fForMaps` or something like that, but how can I introduce an `Ord k` constraint?
16:13:37 <d34df00d> Hi!
16:14:10 <d34df00d> What's the right idiom for having an element of a list along with a function to update the corresponding position of the list with a new value?
16:15:02 <EvanR> a lens
16:15:05 <jackdk> can you back up to the problem you're solving?
16:15:21 <d34df00d> I'm writing some code for discrete optimization of a function, so I have a list of parameters of that function.
16:15:34 <d34df00d> For each element of the list, I can generate the list of possible variations of that element.
16:15:46 <d34df00d> So I'd like to choose the best variation and update the parameters list with that new value.
16:16:08 <d34df00d> EvanR: lenses... lenses everywhere!
16:16:41 <EvanR> by list do you mean tuple
16:16:47 <EvanR> or is it a uniform list of params
16:16:53 <d34df00d> It's an uniform list of params.
16:17:10 <d34df00d> Sort of... But that's irrelevant because existentials save my day.
16:27:49 <d34df00d> So what I basically have is [ (dv, idx) | | (Just dv, idx) <- zip (optToDV <$> filledOptions) [0..] ], and I can use the index to update the list as necessary, but this seems ugly.
16:28:09 <d34df00d> (I need this Maybe/Just match because not all options are discrete, so I'm only optimizing a subset of those)
17:00:11 * hackage monad-logger-syslog 0.1.5.0 - syslog output for monad-logger  https://hackage.haskell.org/package/monad-logger-syslog-0.1.5.0 (MichaelSnoyman)
17:04:19 <electricityZZZZ> okay so if i use a list comprehension like [x*2 | x <- [1..10]] ,... this boggles my mind because i could do something like [x | x <- prime at least one larger than the largest known] and my execution time becomes (essentially) infinite
17:04:49 <electricityZZZZ> why is using a list comprehension like this not a hazard?
17:05:40 <jackdk> > let loop = loop in [ x * 2 | x <- loop ]
17:05:43 <lambdabot>  *Exception: <<loop>>
17:06:07 <jackdk> it's no different to any other programming; why do you expect list comprehension to be special or safe?
17:06:45 <hpc> ignore that it detects a loop btw, that's a whole other lesson :P
17:08:07 <electricityZZZZ> i mean i could write, [x | x is the shortest traveling salesman path through some graph],... this seems to be like a really weird way of encouraging people to write programs
17:08:47 <hpc> it's not really that magic
17:09:03 <jackdk> you could also write `let x = proof_of_p_eq_np in x`. I do not understand the point you're making
17:09:17 <hpc> when you do something fancy besides [1..10] as the list you're pulling from, it still has to evaluate it
17:09:25 <hpc> and it tries as it would in any other circumstance
17:09:38 <hpc> for all lists xs, [x | x <- xs] = xs
17:09:58 <electricityZZZZ> well i would say that a substantial part of programming is coming up with intelligent ways of computing x given constraints, and i should have no expectation that a compiler would find constraint solutions on my behalf intelligently
17:10:16 <hpc> it's not intelligent at all
17:10:17 <EvanR> the evaluation strategy isn't really that smart
17:10:20 <hpc> it just loops through the list
17:11:31 <jackdk> are you new to haskell? Introductory haskell material often has an inexplicable fascination with list comprehensions, and I have seen it take many people in to the weeds for little benefit
17:11:54 <electricityZZZZ> i'm giving haskell a sniff test
17:12:26 <hpc> have you ever used linq in C#, or for..in in python?
17:12:29 <hpc> it's the same thing here
17:15:21 <electricityZZZZ> i had a hilarious experience where a boss of mine kepy linqifying my C# code and i'd rewrite it as for loops, thrashing the repo ;)
17:16:36 <electricityZZZZ> "find x, y, z, etc such that" has such a ridiculous amount of computational power that "most" such statements take "forever"
17:17:12 <electricityZZZZ> if i was in charge of a project i would ban these types of statements
17:17:22 <hpc> it doesn't really do that though
17:17:29 <hpc> it works like filter
17:17:51 <hpc> or well, when you put a predicate after the |
17:18:14 <hpc> i think you're misreading what "|" means here
17:18:23 <hpc> it's not [x | some condition that x matches]
17:18:36 <hpc> it's [expression | get variables from lists and whatnot]
17:19:48 <electricityZZZZ> ok you're saying that the enumeration process has to be explicit rather than implicit so it's no problem?
17:20:00 <hpc> yeah
17:20:04 <electricityZZZZ> ok
17:20:10 <hpc> it's really just foreach
17:20:35 <electricityZZZZ> philosophically it feels like haskell likes infinite constructs
17:20:40 <aarvar> it's really just map
17:21:05 <hpc> the real benefit you get from this in haskell is it lines up with the interface of Monad
17:21:25 <hpc> so instead of writing something like [x * y | x <- [1, 2, 3], y <- [10, 100, 1000]]
17:21:28 <hpc> you would write
17:21:46 <hpc> do {x <- [1, 2, 3]; y <- [10, 100, 1000]; pure (x * y)}
17:22:06 <hpc> and once your code is like that, it doesn't have to be just for lists
17:36:22 <johnw> hpc: well, couldn't the same be said for MonadComprehensions?
17:39:51 <n0v4> hi, i am trying to use a package that's on hackage but not stackage with stack. trying to follow the instructions here: https://stackoverflow.com/questions/41429680/workflow-for-using-stack-to-test-hackage-packages-not-in-stackage which suggest using `stack solver`. but i get `Invalid argument `solver'
17:39:51 <n0v4> Auxiliary command not found in path `stack-solver'
17:39:51 <n0v4> File does not exist or is not a regular file `solver'`
17:40:37 <n0v4> using Version 2.1.3, Git revision 0fa51b9925decd937e4a993ad90cb686f88fa282 (7739 commits) x86_64 hpack-0.31.2
17:40:41 <Axman6> just add it to your extra-deps in the stack.yaml
17:43:03 <n0v4> thanks, i added the package `algebra-4.3.1` to the stack.yaml and the package.yaml but the problem is it keeps complaining about missing and conflicting dependencies
17:43:12 <n0v4> i try to add the dependencies then there are more dependency problems
17:44:13 <ph88> how can i see the bytes in a Data.ByteArray  View ?  https://hackage.haskell.org/package/memory-0.15.0/docs/Data-ByteArray.html#t:View 
17:45:05 <n0v4> ok, i removed it from package.yaml and left only in stack.yaml extra-deps. if i add   - containers-0.6.0.1 it is building. thanks
17:51:53 <n0v4> but now i have problems importing modules from it: src\Lib.hs:6:1: error:                                                                    Could not find module `Numeric.Ring.Rng' 
17:55:15 <ChaiTRex> n0v4: Do you have the algebra package installed?
17:56:20 <n0v4> ChaiTRex, maybe not, i only added it to the .yaml 
17:56:33 <n0v4> how can i install it?
17:58:19 <ChaiTRex> n0v4: Looks like Stackage uses Numeric.Rng. See https://www.stackage.org/package/algebra
17:58:42 <ChaiTRex> n0v4: No, I'm wrong.
18:00:00 <Axman6> n0v4: did you add algebra to your cabal file or package.yaml file? you actually need to add the package as a dep - adding to stack.yaml just tells stack it's ok to install it
18:00:55 <Axman6> hmm, looks like you did, sorry wan't following along
18:01:28 <n0v4> Axman6, oh. i had it in package.yaml first, under depdencies as `  - algebra >= 4.3.1`. but it causes error messsages about dependency conflicts 
18:01:41 <n0v4> Error: While constructing the build plan, the following exceptions were encountered:                                                                                        In the dependencies for algebra-4.3.1:                                                    containers-0.6.0.1 from stack configuration does not match >=0.3 && <0.6  (latest                        matching version is 0.5.11.0)                                  needed due to 
18:01:41 <n0v4> hlin-0.1.0.0 -> algebra-4.3.1   
18:02:56 <n0v4> if i change the containers dependency to 0.5.11.0, it then complains about more dependency problems
18:03:11 <n0v4> for `binary` and `text`
18:03:45 <n0v4> i thought `stack solver` was meant to deal with this, hence the original question
18:05:01 <ChaiTRex> n0v4: algebra package needs containers before 0.6 or whatever. See dependency specification on https://github.com/ekmett/algebra/blob/master/algebra.cabal
18:05:03 <Axman6> stack solver tries to find compatible packages within a snapshot. if that doesn't exist it can't. look into "allow-newer"
18:06:06 <n0v4> thank you  both, i need to go now but i will try this later. goodbye
18:22:54 <refusenick> What's the best book to learn Haskell if I'm comfortable with lower-division math (aside from differential equations) and am somewhat familiar with abstract algebra and upper-division linear algebra?
18:23:42 <refusenick> (not too much handholding, but also preferably not a tome of every possible technique)
18:25:20 <Axman6> Graham Hutton's book is a classic
18:25:22 <refusenick> I know some Scheme, if that factors in
18:25:34 <refusenick> Axman6: Will take a look!
18:28:02 <Axman6> He's also done a couple of videos on Numberphile on youtube, if you want to see how much of a nice guy he is
18:30:20 <blankhart> if you want to learn haskell from someone evil, there are options
18:30:26 <blankhart> https://twitter.com/EvilHaskellTips
18:35:43 <sleblanc> blankhart, oof, that Show a => Ord a example is awful!
18:36:15 <refusenick> sleblanc: It has evil in the name.
18:36:47 <sleblanc> it meets expectations
18:36:53 <refusenick> It's much like how "cabal" carries a negative connotation.
18:37:11 <refusenick> (just kidding - I actually far prefer Cabal to Stack so far)
18:38:22 <refusenick> Am I the only one? I guess they put in a lot of work to fix the negative reputation, because the v2 set of commands work great.
18:42:07 <refusenick> No offense to Stack - I just think I'm not their target audience.
18:47:38 <refusenick> Maybe Cabal seems like a breath of fresh air because it's letting me do things the wrong way? Is there something like lexi-lambda's Opinionated Guide to Haskell, but for Cabal?
19:34:00 <dsal> refusenick: I like stack, but haven't put much effort into cabal related things.
19:35:55 <jackdk> stack was a well-needed kick in the butt for cabal, but now that cabal v2-* exists I'm happy using it again
19:36:06 <c_wraith> I like cabal because it does what I ask it to, not what it thinks I should want.
19:37:04 <jusss> data Result = Result { id :: Maybe Int64, name::Maybe String, age::Maybe Int64 } 
19:37:19 <jusss> fromRow = Result <$> filed <*> field <*> field
19:37:44 <jusss> what this means `Result <$> filed <*> field <*> field' ?
19:38:12 <jusss> if filed is a list, so Result <$> filed will be get a list [Result v1, Result v2...]
19:38:37 <jusss> then this list <*> a list will be?
19:41:00 <dsal> I I wouldn't call a field id...
19:41:03 <dsal> : (<*>)
19:41:13 <dsal> :t (<*>)
19:41:14 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
19:41:18 <jusss> http://hackage.haskell.org/package/postgresql-simple-0.6.2/docs/Database-PostgreSQL-Simple-FromRow.html
19:41:19 <dsal> That's basically <$> for applicatives.
19:42:02 <jusss> data User = User { name :: String, fileQuota :: Int } instance FromRow User where    fromRow = User <$> field <*> field
19:42:26 <jusss> I don't understand this fromRow function
19:43:00 <dsal> hmm...   So, do you understand field?
19:43:53 <jusss> Result 1 "John" 30, those are three fields?
19:44:09 <dsal> I mean the 'field' function there that's inside the RowParser monad.
19:44:13 <dsal> > let f = Just 3 in   (,) <$> f <*> f
19:44:15 <lambdabot>  Just (3,3)
19:44:23 <dsal> It's doing  basically that sort of thing, except instead of Maybe, it's RowParser.
19:44:31 <jusss> oh, `field' is a function... 
19:44:38 <jusss> I don't know that
19:44:44 <dsal> It's linked on that page you sent.  :)
19:45:11 * hackage tasty-tap 0.1.0 - TAP (Test Anything Protocol) Version 13 formatter for tasty  https://hackage.haskell.org/package/tasty-tap-0.1.0 (MichaelXavier)
19:45:48 <jusss> dsal: sorry, more details? I don't see how `field' defined
19:46:22 <dsal> That's almost all that page describes. Click on 'field' on that documentation.
19:46:52 <jusss> oh, in the bottom
19:47:14 <jusss> field = fieldWith fromField
19:48:10 <dsal> Did you see the small example I showed you above?
19:48:33 <jusss> yeah `<dsal> > let f = Just 3 in   (,) <$> f <*> f'
19:48:48 <dsal> You're doing a similar thing here, but with RowParser.
19:48:54 <jusss> > (,) <$> (Just 3)
19:48:55 <lambdabot>  error:
19:48:56 <lambdabot>      • No instance for (Typeable b0)
19:48:56 <lambdabot>          arising from a use of ‘show_M81157447429870919102281’
19:49:11 <dsal> :t (,) <$> (Just 3)
19:49:12 <lambdabot> Num a => Maybe (b -> (a, b))
19:49:17 <jusss> > fmap (,)  (Just 3)
19:49:19 <lambdabot>  error:
19:49:19 <lambdabot>      • No instance for (Typeable b0)
19:49:19 <lambdabot>          arising from a use of ‘show_M56330580551773345822311’
19:51:23 <jusss> > fmap (,) (Just 3) <*> (Just 3)
19:51:25 <lambdabot>  Just (3,3)
19:53:31 <dsal> > (fmap ap.fmap) (,) (Just 1) (Just 2)
19:53:33 <lambdabot>  Just (1,2)
19:53:59 <dsal> > liftA2 (,) (Just 1) (Just 2)
19:54:01 <lambdabot>  Just (1,2)
19:54:23 <dsal> There are a few ways to spell it, but the <$> <*> thing is pretty common when doing that sort of thing as adding another field is just another <*>
20:02:48 <jusss> :t (,)
20:02:49 <lambdabot> a -> b -> (a, b)
20:03:39 <jusss> > fmap (+) (Just 3) <*> (Just 3)
20:03:42 <lambdabot>  Just 6
20:04:12 * hackage statestack 0.3 - Simple State-like monad transformer with saveable and restorable state  https://hackage.haskell.org/package/statestack-0.3 (BrentYorgey)
20:52:31 <maerwald> > pure (+) <*> (Just 1) <*> (Just 3)
20:52:33 <lambdabot>  Just 4
20:52:35 <maerwald> is more intuitive imo
20:56:04 <dsal> Does anyone here have experience with Dhall?  I'm trying  to figure out whether it makes anything better for me.
20:59:55 <z3t0> hey all
21:00:22 <z3t0> I have a question. How can i define the type such as a = String | String[]
21:00:45 <z3t0> I'm not sure if that's valid haskell code, but I'm trying to do this in another language. Which requires me to understand what exactly this means
21:00:52 <z3t0> I was hoping someone on this channel might have some ideas
21:01:24 <maerwald> z3t0: type StringOrStringList = Either String [String]
21:01:27 <z3t0> My problem is how can I define a type which may be one or many of a certain type. It doesnt require generics because I know type of the single thing or collection
21:01:36 <z3t0> Ah okay, so Either is the word I was looking for I guess
21:04:18 <dsal> :t NonEmptyList
21:04:19 <lambdabot> error:
21:04:19 <lambdabot>     Data constructor not in scope: NonEmptyList
21:04:37 <dsal> :t NonEmpty
21:04:39 <lambdabot> [a] -> NonEmptyList a
21:04:53 <dsal> z3t0: ^ that's one or many of a
21:05:23 <z3t0> Hmm
21:05:31 <z3t0> Isn't that a function though?
21:05:41 <dsal> What do you mean by function?
21:05:41 <z3t0> P.S i don't know any haskell syntax
21:06:14 <Axman6> z3t0: I think the answer you're after is data SomeStrings = AString String | Strings [String]
21:06:46 <Axman6> that's the union of a String or a [String], which are contained in different constructors
21:07:37 <Axman6> so yuo can have AString "Hello" anbd that has the type SomeStrings, or Strings ["world","!"] which also has type SomeStrings
21:11:47 <phanimahesh> What's wrong with this?
21:11:50 <phanimahesh> > parseTimeOrError True defaultTimeLocale "%d.%m.%y %H:%M:%S" "07.11.2019 05:45:00" :: UTCTime
21:11:52 <lambdabot>  error:
21:11:52 <lambdabot>      Not in scope: type constructor or class ‘UTCTime’
21:13:09 <phanimahesh> > Data.Time.parseTimeOrError True Data.Time.defaultTimeLocale "%d.%m.%y %H:%M:%S" "07.11.2019 05:45:00" :: Data.Time.UTCTime
21:13:11 <lambdabot>  error:
21:13:11 <lambdabot>      Not in scope: ‘Data.Time.parseTimeOrError’
21:13:11 <lambdabot>      No module named ‘Data.Time’ is imported.error:
21:13:49 <phanimahesh> Welp. Anyway, what am I doing wrong here?
21:14:05 <phanimahesh> I get a parse error
21:14:40 <Axman6> haveyou imported Data.Time?
21:14:56 <Axman6> you should share the file you're using
21:15:35 <phanimahesh> Yeah, Data.Time is imported.  I get *** Exception: parseTimeOrError: no parse of "07.11.2019 05:45:00"
21:15:58 <Axman6> do you need %Y?
21:16:04 <monochrom> What does %y do again?  Does it really expect "2019" or does it expect "19"?  How do you know?
21:17:08 <phanimahesh> I got it from https://hackage.haskell.org/package/time-1.9.3/docs/Data-Time-Format.html#v:formatTime
21:17:49 <maerwald> %Y is correct
21:18:12 <maerwald> %y -- year of century, 0-padded to two chars, 00 - 99
21:18:19 <maerwald> docs are nice 
21:18:27 <phanimahesh> Derp. I'm sorry. Need my glasses. :/
21:18:56 <phanimahesh> Yeah, that was it. Thanks Axman6 and maerwald 
21:19:01 <Axman6> does it work?
21:19:05 <Axman6> nice
21:19:23 <Axman6> that's a strange time format
21:19:40 <phanimahesh> Yep. I don't control it unfortunately.
21:19:58 <phanimahesh> The file format is even weird. semicolon delimited quoted csv-ish
21:20:51 <Axman6> :(
21:21:01 <Axman6> where do these people come from
21:21:10 <Axman6> probably javascript developers
21:21:18 <phanimahesh> And there are a bunch of files with overlapping entries. Each entry for 15 minutes. Each file covers two hours. Don't even ask about it.
21:23:11 <jusss> how we can print a list in a do-notaion with IO context?
21:23:14 <Axman6> :''(
21:23:24 <Axman6> jusss: print list?
21:23:27 <jusss> main = do print alist
21:24:07 <jusss> Axman6: a list in a do-notaion, map print alist will get a [IO()]
21:24:24 <jusss> Axman6: but do-notation need IO () not [IO()]
21:24:32 <jusss> `map print alist'
21:24:46 <Axman6> mapM_ print list
21:24:48 <phanimahesh> You want to print the entries one per line?
21:25:17 <jusss> if I use `head $ map print alist' I find it only print the first one line
21:25:36 <phanimahesh> If you jyst want the entire list along with the [,] stuff `print list` works
21:25:42 <Axman6> :t mapM_
21:25:43 <lambdabot> (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
21:26:02 <phanimahesh> jusss: That's right. print takes an item and creates an IO action to print it.
21:26:16 <jusss> phanimahesh: per line
21:26:28 <phanimahesh> map print list is now a list of IO actions, each printing the corresponding item.
21:26:47 <jusss> Axman6: can we use `seq' here to make sure `map print alist' evaluated? and then head it
21:26:50 <phanimahesh> head picks first. Since it's in a do-notation in IO context, it gets evaluated. first item gets printed.
21:27:06 <phanimahesh> jusss: Did you try mapM_ print list?
21:28:09 <Axman6> no
21:29:34 <phanimahesh> Axman6: ?
21:30:04 <Axman6> replying to jusss
21:30:16 <phanimahesh> Ah. okay.
21:30:20 <jusss> phanimahesh: Axman6 yeah, I tried mapM_, it did what I want
21:38:42 <jusss> how to turn a list to string?
21:40:07 <Axman6> show?
21:40:25 <jusss> fmap show alist   will still get a list
21:40:36 <jusss> oh, show alist
21:46:01 <EvanR> @hoogle Show a => [a] -> String
21:46:01 <lambdabot> Sound.OSC vecPP :: Show a => [a] -> String
21:46:01 <lambdabot> Sound.OSC.Datum vecPP :: Show a => [a] -> String
21:46:02 <lambdabot> Numeric.Probability.Visualize vec :: Show a => [a] -> String
21:46:11 <EvanR> oh well
22:01:38 <phanimahesh> Yeah I've been getting strange results on hoogle all day too. Valid, but absolutely useless for my usecase.
22:02:53 <phanimahesh> Quick question: sane json library? I'm only going to go record -> json.
22:04:39 <phanimahesh> I'm going with Data.Aeson for now. Looks nicer than Text.JSON
22:05:40 <EvanR> aeson is standardish
22:05:47 <ChaiTRex> phanimahesh: Aeson is excellent
22:06:00 <phanimahesh> Thanks.
22:14:09 <maerwald> waargonaut is also nice
22:36:42 * hackage jose 0.8.2.0 - Javascript Object Signing and Encryption and JSON Web Token library  https://hackage.haskell.org/package/jose-0.8.2.0 (frasertweedale)
22:42:41 <jusss> why there're Text and String two types?
22:42:54 <jusss> show alist can turn a list to String
22:43:03 <jusss> how to turn  a list to Text?
22:43:13 <EvanR> :t Data.Text.pack
22:43:14 <lambdabot> String -> Data.Text.Internal.Text
22:43:48 <EvanR> (String is a list. type String = [Char])
22:44:02 <f-a> jusss: hoogle is always useful for questions like this (how to ____ from ____)
22:44:35 <laas> I'm new to Haskell, but I have a lot of experience with Rust. Can I make a function where the return type isn't known, but instead the caller only knows that the return type has some instance? Something like `fn f() -> impl MyTrait` in Rust.
22:44:35 <EvanR> yes learn to hoogle and/or :i and/or :t and/or read haddocks
22:44:37 <int-e> @hoogle String -> Text
22:44:38 <lambdabot> Data.Text pack :: String -> Text
22:44:38 <lambdabot> Data.Text.Lazy pack :: String -> Text
22:44:38 <lambdabot> System.Console.CmdArgs.Text Line :: String -> Text
22:44:56 <laas> I tried some forall stuff but couldn't get it to work
22:45:00 <int-e> nice, it puts the right functions first for once :)
22:45:06 <EvanR> lucky
22:45:12 <f-a> laas: you mean the return type is some instance of some typeclass?
22:45:12 <jle`> laas: if the caller can *choose* the return type, provided it has some instance, then you can just write SomeClass a => () -> a
22:45:25 <int-e> EvanR: very
22:45:27 <jle`> laas: if the caller cannot choose, and the function implementor chooses, then it's trickier
22:45:41 <Axman6> :t read
22:45:42 <lambdabot> Read a => String -> a
22:45:47 <EvanR> if the callee chooses, it's an existential type
22:45:49 <jle`> laas: the type you return would be existential. but i'm not sure you would really want that
22:45:52 <int-e> maybe @hoogle should just produce a URL, along the lines of @hackage
22:46:04 <jle`> laas: see those blog posts about the "existential type antipattern"
22:46:26 <Axman6> lambdabot: read is an example of a function where the caller chooses the return type
22:46:31 <jle`> laas: usually the desire for existential types comes from trying to fit some OOP/other paradigm thinking into Haskell and it causes more headaches than it is actually worth or useful
22:46:35 <Axman6> uh, laas
22:46:37 <laas> huh
22:46:46 <dsal> I switched a project from megaparsec to dhall and it helped.
22:46:57 <EvanR> basically we don't know how precise your "return type is unknown" really is supposed to be
22:47:11 <jle`> laas: for example, let's say i want to write a function that can return some instance of Show that the user cannot choose. it can be Int or Double or Bool...but the function chooses, not the user
22:47:11 <Axman6> > read "1" :: Int
22:47:12 <lambdabot>  1
22:47:19 <Axman6> > read "True" :: Bool
22:47:21 <lambdabot>  True
22:47:28 <jle`> laas: in that case...the user would have to handle it universally with only knowing that the value they got is an instance of Show
22:47:33 <laas> I meant that the callee chooses FYI
22:47:41 <dminuoso> laas: Both are possible.
22:47:41 <jle`> laas: so really, the only thing the user can do is use 'show' on it
22:47:52 <jle`> laas: so in that case, it would be equivalent to returning a String🏽
22:48:00 <laas> Yeah, but what is the signature for the function?
22:48:07 <jle`> so instead of writing a function Blah -> <callee chosen type>, you can just return Blah -> String, instead
22:48:13 <dminuoso> laas: You require Rank2Types for that.
22:48:14 <jle`> because it's effectively indistinguishable
22:48:23 <jle`> * Blah -> <calle choosen type that is an instance of Show>
22:48:28 <EvanR> or ExistentialQuantification
22:48:36 <jle`> such a function would be very non-haskelly, even though it is possible
22:48:41 <jle`> really you would just write Blah -> String
22:48:46 <jle`> since it is effectively the same thing
22:48:54 <EvanR> Show would be a bad example
22:49:03 <dminuoso> % f :: (forall s. Show s => s -> String) -> String; f s = s 10 <> s "foo" -- laas 
22:49:03 <yahb> dminuoso: 
22:49:23 <laas> thanks
22:49:34 <EvanR> we can move on to classes or other support that is not as convenient as "just return a string"
22:49:50 <jle`> https://medium.com/@jonathangfischoff/existential-quantification-patterns-and-antipatterns-3b7b683b7d71
22:50:02 <jle`> EvanR: there are cases where it can be useful...but it shouldn't really be the 'first' thing you reach for
22:50:03 <laas> In Rust you use it to prevent the caller from assuming internal design
22:50:08 <Axman6> % let f :: (forall s. Show s => s -> String) -> String; f s = s 10 <> s "foo" in f show
22:50:08 <yahb> Axman6: "10\"foo\""
22:50:13 <laas> But maybe it's not as required in Haskell
22:50:16 <dminuoso> laas: We do the same thing too!
22:50:20 <dminuoso> % :t runST
22:50:20 <yahb> dminuoso: (forall s. ST s a) -> a
22:50:27 <EvanR> you can do that in haskell several ways
22:50:28 <jle`> usually it's one of those "don't use it unless you know why you shouldn't use it" sort of things
22:50:45 <jle`> you can do it in haskell but *usually* you don't need to and there is a simpler way
22:50:58 <dminuoso> laas: ^- this is one of the more prominent examples. The type system is leveraged such that you cannot leak ST things.
22:51:12 <jle`> and in some cases it might be the best way. but it's hard to judge unless you have some perspective/familiarity
22:51:21 <dminuoso> laas: And equivalently polymorphism also allows you to hide. The reason is relatively simple
22:52:30 <jusss> there even are two Text...
22:52:31 <jle`> so, if you are new to haskell, i would recommend trying to write it without resorting to existential types if it is possible.  such an exercise would help get you acclimated to 'the haskell way of thinking', so to speak
22:52:31 <Axman6> wherte "ST things" means actual, honest to goodness mutation or variables
22:52:40 <jusss> Data.Text.Internal.Lazy.Text
22:52:41 <jle`> before jumping into the more advanced stuff wiht existentials that is only situationally useful
22:52:58 <jusss> why not just one simple String...........................................
22:53:04 <EvanR> jusss: now you're getting into performance tuning and such
22:53:44 <dminuoso> jusss: String is just a list of characters, remember its just a type alias for [Char]
22:53:59 <jusss> EvanR: I need turn a list into a Data.Text.Internal.Lazy.Text, but there's no pack method
22:54:03 <dminuoso> jusss: This mechanism is incredibly wasteful for storage and has poor locality of reference.
22:54:13 <dminuoso> jusss: Data.Text.Lazy.pack 
22:54:21 <jle`> jusss: strict Text is for text that you would normally use and consume all at once; lazy text is situationally useful for streaming, as it allows for lazy production and consumption and infinite text and stuff like that.
22:54:24 <EvanR> jusss: need to read more carefully the docs
22:54:51 <jusss> why not put a `pack' into Data.Text.Internal.Lazy?
22:54:57 <dminuoso> jusss: That's an internal module.
22:55:06 <jle`> jusss: pack already exists in Data.Text.Lazy
22:55:08 <dminuoso> jusss: Generally modules named Internal are not exposed/not part of public API.
22:55:08 <EvanR> get out of the Internal docs
22:55:22 <jle`> % Data.Text.Lazy.pack "hello"
22:55:22 <yahb> jle`: "hello"
22:55:25 <jle`> ta dah :)
22:55:37 <jle`> jusss: what brought you to the conclusion that there is no pack method?
22:55:43 <dminuoso> jusss: So your fault lies in looking through Data.Text.Internal.Lazy when you should have been looking at Data.Text.Lazy :)
22:56:20 <EvanR> jusss: historical reasons, would be nice if String were text/lazytext and [Char] was just [Char]. imho
22:56:21 <dminuoso> Sadly in diagnostics you frequently see names qualified with the internal module where it was defined in, rather than qualified with the module name where it was exported from.
22:57:07 <dminuoso> EvanR: And ByteString should be named ByteArray or ByteVector (not sure which it uses internaly)
22:57:12 <EvanR> String and [Char] are the same no of characters... [Char] would be fine!
22:57:23 <jle`> i would call ByteString BinaryBlob, maybe
22:57:25 <jusss> dminuoso: jle` EvanR then why no `show' in Data.Text.Lazy?
22:57:34 <jusss> so it can just turn a list into a Text?
22:57:35 <jle`> jusss: what would 'show' do?
22:57:49 <jle`> jusss: you can turn a list of chars into Text by using Pack
22:57:51 <dminuoso> jusss: It's called `pack`
22:57:52 <jusss> jle`: like it did to string
22:58:04 <EvanR> show works on Text just fine
22:58:04 <jusss> pack :: String -> Text
22:58:08 <jle`> jusss: you can 'show' a Text, it has a Show instance
22:58:16 <jle`> jusss: oh, you want Text -> String? that's unpack
22:58:17 <jackdk> If ByteString was called Binary, years of handwringing over Haskell having "too many string types" could have been headed off
22:58:34 <jusss> jle`: I want [Whatever] to Text
22:58:35 <jle`> yeah, the usage of String there had a lot more baggage than initially anticipated
22:58:49 <jle`> jusss: what text would come out of [True, False] ?
22:58:53 <EvanR> come on guys... ByteString isn't that bad
22:59:01 <jle`> jusss: ah, you want to 'show' it...as Text
22:59:05 <jle`> jusss: you can use T.pack . show then
22:59:09 <EvanR> tolerable at worst
22:59:11 <jusss> jle`: what about `show' do to list ?
22:59:22 <jle`> EvanR: ByteString isn't bad, but the weird thing is that people keep on using it for text
22:59:31 <EvanR> they do?
22:59:34 <jle`> if it wasn't named ByteString then people might not do that as much
22:59:39 <jle`> or at leas thave that expectation
22:59:40 <jusss> every typs deriving (Show), so show can turn them to String
22:59:48 <dminuoso> jle`: ByteString is bad because string is a terribly ambiguous word that is too often understood to mean "text"
22:59:50 <jle`> EvanR: yes, as evidenced by the questions that pop up here eveyr once in a while
22:59:55 <jusss> why not deriving (Text)?
22:59:56 <laas> doesn't that make sense, if it's not a specific encoding?
22:59:59 <laas> i.e. not UTF-8
23:00:10 <jle`> jusss: that would be redundant, you can just `T.pack . show`
23:00:15 <jle`> > show [True, False]
23:00:17 <dminuoso> laas: Dont confuse encoding with character set.
23:00:17 <lambdabot>  "[True,False]"
23:00:20 <jle`> > T.pack (show [True, False])
23:00:22 <lambdabot>  error:
23:00:22 <lambdabot>      Not in scope: ‘T.pack’
23:00:22 <lambdabot>      Perhaps you meant ‘BS.pack’ (imported from Data.ByteString)
23:00:25 <EvanR> luckily this channel corrects the issue and everyone ends up edumacated
23:00:29 <jle`> > Data.Text.pack (show [True, False])
23:00:31 <dminuoso> laas: Encoding is what happens when you turn unicode into say UTF8.
23:00:31 <lambdabot>  error:
23:00:31 <lambdabot>      Not in scope: ‘Data.Text.pack’
23:00:31 <lambdabot>      No module named ‘Data.Text’ is imported.
23:00:58 <jle`> > T.pack (show [True, False])
23:01:00 <lambdabot>  "[True,False]"
23:01:09 <EvanR> ByteString is fine. It's a string (math sense) of bytes
23:01:23 <jle`> EvanR: sometimes we miss people :'( and it shows up as a long complaint on other platforms
23:01:53 <jle`> it's technically true, but causes misleading conclusions/intuition from the baggage the individual word brings
23:01:53 <jackdk> I agree that the name is correct. It has had unintended side-effects though
23:01:59 <EvanR> i still don't get how people still don't know the diff between array of bytes and "a string" (text)
23:02:00 <jusss> jle`: I know we can turn list to string, then pack string to text, I wonder why we can't just turn list to text?
23:02:11 <jle`> jusss: i just did that ... with (T.pack . show)
23:02:28 <EvanR> decades of languages mucking up the distinction i guess
23:02:30 <dminuoso> EvanR: "a string" (text) <- what exactly is that?
23:02:48 <jusss> jle`: I mean we remove the string step
23:02:48 <EvanR> people usually mean text when they say string
23:02:51 <dminuoso> EvanR: There is not a more ambiguous term in programming than string I risk to claim.
23:02:51 <laas> dminuoso: if you didn't know if it was UTF-8, 16, or 32, wouldn't ByteString be appropriate?
23:02:55 <gonadmonad> bro, can someone explain to me the behavior of flip in functions with more than 2 parameter
23:02:57 <gonadmonad> ?
23:03:04 <jle`> jusss: what difference would it make?
23:03:10 <dminuoso> laas: ByteString is just a buffer of binary data.
23:03:16 <dminuoso> laas: It's no more than "a bunch of bytes" :)
23:03:22 <jle`> gonadmonad: the easiest way to do it is to just do the substitutions
23:03:31 <EvanR> laas: if you did know, then it's still be a byte string :)
23:03:36 <jle`> gonadmonad: flip f = \x y -> f y x
23:03:36 <gonadmonad> 3 parameter => flipping front, though with composition it's flipping the back
23:03:37 <dminuoso> laas: So sure, you can encode Text into ByteString by using UTF-8, UTF-16 or UTF-32
23:03:47 <EvanR> utf8 etc are properties of a byte string
23:03:57 <jle`> gonadmonad: so flip myFuncionWithThreeParameters = \x y -> myFUnctionWithThreeParameters y x
23:04:01 <gonadmonad> 4 parameter => both composition or not, are flipping the front
23:04:13 <gonadmonad> yeah i understand that
23:04:17 <jle`> gonadmonad: all of that stuff just falls out of application of the function
23:04:19 <dminuoso> gonadmonad: Functions have only one parameter. :)
23:04:28 <dminuoso> gonadmonad: So flip works on functions that return functions.
23:04:29 <jle`> gonadmonad: there isn't much more to understand, i think...can you derive what happens for a given function?
23:04:30 <dminuoso> % :t flip
23:04:30 <yahb> dminuoso: (a -> b -> c) -> b -> a -> c
23:04:37 <EvanR> the encoding or lack thereof is not supposed to matter semantically for an abstract type like Text
23:04:58 <jle`> gonadmonad: let's say that f = \q -> r.  then flip f x y = \x y -> f y x
23:04:59 <dminuoso> gonadmonad: You could set `c` to be a function too if you like.
23:05:03 <gonadmonad> how to think the curry way ? like 1 parameters only, i can't bend my mind on that dminuoso
23:05:29 <jle`> gonadmonad: one way is to just not think about it and just do the symbols do the thinking for you
23:05:33 <jle`> gonadmonad: so you don't have to think :)
23:05:42 <jackdk> gonadmonad:  https://www.irccloud.com/pastebin/d209Iwta/Flip.hs
23:05:46 <jle`> gonadmonad: let's say we had a three argument function, like f a b c = a+b+c
23:05:50 <gonadmonad> it's not simple substitution like you said though jle`
23:05:52 <gonadmonad> ...
23:05:57 <dminuoso> EvanR: I had an interesting discussion regarding notions of strings with my girlfriend who doesn't have any programming experience.
23:05:57 <jle`> gonadmonad: it is :)
23:05:58 <EvanR> jusss: i think you're confused. A String is a list
23:06:04 <jle`> gonadmonad: follow me here: if f a b c = a + b + c
23:06:16 <jle`> gonadmonad: then flip f = \x y -> f y x
23:06:20 <gonadmonad> okay
23:06:25 <jle`> = \x y -> (\a b c -> a+b+c) y x
23:06:36 <jle`> = \x y -> (\b c -> y+b+c) x
23:06:46 <jle`> = \x y -> (\c -> y+x+c)
23:06:48 <jusss> EvanR: type String = [Char]
23:06:48 <dminuoso> EvanR: And she argued that a PNG file is as much a valid representation of textual data, as [Char] 
23:06:51 <jle`> = \x y c -> y+b+c
23:06:53 <jle`> and that's it :)
23:07:06 <EvanR> jusss: so pack is precisely what you asked for
23:07:11 <jle`> if we flip a function like `f a b c = a + b + c`, we get a function \x y c -> y + x + c
23:07:22 <jackdk> dminuoso: The dark future, where everyone takes screenshots of their code
23:07:31 <EvanR> dminuoso: um you mean if the letters are rendered as an image?
23:07:36 <jle`> * that last line should have been \x y c -> y + x + c
23:07:44 <gonadmonad> okay what happens on composition jle`
23:07:45 <jle`> gonadmonad: do you see how there isn't really any magic to it? it's just simple substitution
23:07:47 <dminuoso> EvanR: Yes.
23:07:56 <EvanR> ok, wow
23:07:59 <jle`> gonadmonad: can you guess how i'm going to tell you to find the answer? ;)
23:08:09 <gonadmonad> okay let me try by hand 
23:08:16 <gonadmonad> thanks a lot btw
23:08:20 <jle`> if you guessed "it's just simple substitution", you're right:)
23:08:23 <dminuoso> EvanR: And if you think about it in depth, it's no less correct than say Char. The reason is that you cant even clearly define what "a character" is - if you try to generalize it.
23:08:56 <EvanR> dminuoso: did you ask her to take that png file and do anything text processing on it, like capitalize the first letter
23:09:18 <dminuoso> EvanR: Think of it differently
23:09:25 <EvanR> alternatively, she sounds 100% on track to be most of my old bosses
23:11:53 <EvanR> i'll give you that there is some metaphysical dark art to coming to an agreement with the world on what Char is
23:12:20 <EvanR> but it is NOT an image of a glyph or something
23:12:46 <EvanR> just by practicality
23:12:58 <dminuoso> EvanR: C++ would like to disagree with you.
23:13:24 <EvanR> what do you mean by this
23:13:25 <dminuoso> EvanR: ByteString's Char8 would also like to disagree with you.
23:13:26 <jusss> sleblanc: thanks :)
23:13:49 * EvanR disregards reference to Char8
23:13:50 <dminuoso> EvanR: Take ByteString with Char8 for instance. They expose an interface treating binary data as textual data.
23:14:06 <dminuoso> If you just disregard reality, a meaningful discussion is going to be hard.
23:14:22 <EvanR> Char8 took two issues we were having and puts them in the nutrabullet
23:14:31 <EvanR> will it blend
23:14:37 <dminuoso> EvanR: And the rendering of glyphs is important because textual data clearly has some link to natural languages
23:14:52 <EvanR> so the C++ was supposed to be talking about glyph images?
23:15:06 <EvanR> like fonts and italics, etc
23:15:25 <dminuoso> EvanR: No, but the fact that first encoding textual data into a binary blob and then pretending we can do textual operations on this binary blob is a sensible thing.
23:15:26 <[exa]> EvanR: did you see unicode spec? :D
23:15:31 <EvanR> yeah
23:15:37 <[exa]> EvanR: re-read then
23:16:37 <dminuoso> EvanR: Haskell has a simple solution, by setting Char to mean a character in unicode. So each value of type Char has a corresponding code point, by which we can assign meaning to it.
23:16:42 <EvanR> it says on page one that a character is not a image of a glyph
23:16:55 <EvanR> and i'm not even trying ask dminuoso for an explanation of unicode
23:17:01 <dminuoso> But we might as well have gone the route that Char is a binary blob representing a character in unicode, rendered with a font.
23:17:21 <dminuoso> EvanR: Right, but that's just a completely arbitrary definition in the scope of unicode.
23:18:07 <EvanR> wait, what was C++ disagreeing with again?
23:18:34 <pie_> there was a haskell datatype that lets you do locally imperative operations, what was it?
23:18:36 <dminuoso> EvanR: Consider taking the length of a string in C++.
23:18:43 <EvanR> ok
23:18:46 <dminuoso> pie_: ST
23:18:52 <pie_> thanks ^.^
23:18:54 <dminuoso> pie_: Probably? :)
23:19:02 <pie_> sounds right
23:19:10 <EvanR> was that supposed to answer my question
23:20:14 <dminuoso> EvanR: What should the length of a string even be? Should it be the number of characters in unicode? Should it be the number of octets in a given encoding? Should it be the number of octets in a given rendering? Perhaps its dimensions? The number of red pixels when rendered with a colorful font?
23:20:46 <dminuoso> EvanR: C++ gives you something between the first two depending on the architecture.
23:20:48 <EvanR> since a string is just an array of char, go ahead and count the bytes
23:21:02 <dminuoso> EvanR: But it's not in C++.
23:21:33 <dminuoso> EvanR: We might be talking about std::basic_string<char> or perhaps std::basics_string<wchar_t> or perhaps something else
23:22:11 <ammar2> I thought it's just the number of bytes?
23:22:18 <EvanR> yeah, ok, and at which point did we disprove "metaphysical dark art to agree what Char is"
23:22:21 <ammar2> on what architecture does it return the number of characters in unicode?
23:23:11 <dminuoso> ammar2: The problem is when you use varying length encoding.
23:23:18 <dminuoso> Or not.
23:23:20 <ammar2> > Note that this class handles bytes independently of the encoding used: If used to handle sequences of multi-byte or variable-length characters (such as UTF-8), all members of this class (such as length or size), as well as its iterators, will still operate in terms of bytes (not actual encoded characters).
23:23:22 <lambdabot>  <hint>:1:16: error: parse error on input ‘class’
23:23:26 <ammar2> sounds pretty reasonably to me
23:23:30 <dminuoso> ammar2: I'll have to look up the details, but Linux and Windows (MSCV) do it differently
23:23:44 <kenran> Does anyone of you use (any variant of) emacs together with HIE for "nixified" projects? I'm having a hard time finding resources that are still relevant for this. I'm on macOS at the moment and would love to find a working dev setup for this scenario.
23:24:17 <kenran> In particular, the project is quite old and so I have to enter the nix-shell to be able to build it with cabal.
23:30:17 <dminuoso> EvanR: Anyway, my point is really that once the API exposes some function `length` and it doesn't return some dark magic language specific number, but rather the length of a buffer after running it through some arbitrary encoding.. then that encoding might as well be "render, rasterized, encode into png, compress with gzip"
23:30:37 <dminuoso> Neither one is more correct. It's just that one tends to be more convenient.
23:30:44 <dminuoso> Neither is morally correct through.
23:31:28 <EvanR> why do you think length of a string necessarily involves questions about encoding
23:32:18 <dminuoso> EvanR: Because that's what C++ gives you.
23:34:43 <nshepperd1> Char8 is a crime against text processing
23:36:24 <c_wraith> it's really convenient in a lot of cases, though.
23:36:34 <dminuoso> nshepperd1: Is it? Say you are processing ASCII data, then its really useful..
23:36:35 <c_wraith> you only sacrifice correctness.
23:37:07 <dminuoso> Now it could be argued, that we should have some Text.ASCII perhaps..
23:37:33 <dminuoso> Or better yet, qualified Network.Control.ASCII
23:37:43 <dminuoso> (I refuse to accept ASCII as a "text encoding"
23:40:31 <opqdonut> Char7
23:40:33 <opqdonut> ;)
23:40:47 <ammar2> dminuoso: I searched around a bit but I can't find this difference in behavior, both MSCV and libstdc++ do the same thing: return the number of bytes
23:48:05 <ammar2> and from what I can see the C++ spec states that too (not that that's ever stopped anyone from creating non-conforming implementations before)
23:57:24 <phanimahesh> Wow, lot of discussion on strings.
23:57:53 <phanimahesh> dminuoso: Well, ascii as an encoding exists thanks to americans. We'll cry inside but live with it.
