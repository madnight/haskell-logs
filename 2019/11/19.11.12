00:59:10 <sicklork1n> Axman6: hey
01:05:42 * hackage box 0.1.0 - boxes  https://hackage.haskell.org/package/box-0.1.0 (tonyday567)
03:19:10 <Arahael> Does Haskell have a data type that defines a "type insensitive string"?
03:19:31 <Arahael> Erm... A *case* insensitive string...
03:19:39 <merijn> Arahael: There's a library for that
03:19:43 <Arahael> merijn: Oh?
03:19:54 <merijn> Arahael: https://hackage.haskell.org/package/case-insensitive
03:20:03 <merijn> newtype wrapper that changes Ord
03:20:04 <Arahael> Too bloody obvious. Thanks for that! :)
03:20:57 <merijn> Arahael: Beware of that wrapper when handling unicode though
03:21:14 <Arahael> I'm parsing Delphi code.  What's unicode?
03:21:41 <merijn> Arahael: It's basically compare after "map toLower", but I'm not sure it correctly handles caseless letters
03:21:58 <Arahael> Ah, fair enough, yeah, that'll fail for true unicode, but sounds good enough for my purposes.
03:22:02 <Rembane> Lowercase poo emoji. 
03:22:17 <merijn> Rembane: emojis aren't letters, so don't have a case
03:22:33 <merijn> But there are letter for which "isUpper" and "isLower" return false
03:22:48 <merijn> It's my favourite obscure bug in the Haskell Report/GHC :p
03:23:00 <Arahael> I seem to recall that the "upper" and "lower" case comes from which literal case the letters come from in the printing press.
03:23:10 <Arahael> ie, the top case or the bottom case.
03:23:10 <Rembane> merijn: that's interesting, can you run isUpper on an emoji?
03:23:11 <Uniaika> Arahael: yep'
03:23:13 <merijn> Arahael: in english, yes
03:23:26 <Arahael> merijn: I wonder what the system was for other languages.
03:23:30 <merijn> > isUpper '☃'
03:23:31 <lambdabot>  False
03:23:38 <merijn> > isLetter '☃'
03:23:40 <lambdabot>  False
03:23:55 <Rembane> > isLower '☃'
03:23:57 <lambdabot>  False
03:23:58 <merijn> > isLetter 'ಠ'
03:24:00 <lambdabot>  True
03:24:05 <merijn> > isLower 'ಠ'
03:24:07 <lambdabot>  False
03:24:11 <merijn> > isUpper 'ಠ'
03:24:13 <MarcelineVQ> ಠ_ಠ
03:24:13 <lambdabot>  False
03:24:21 <Rembane> Fascinating. TIL! 
03:24:23 <tdammers> there are also letters for which isUpper / isLower are language/culture dependent
03:24:24 <Rembane> Thank you merijn! 
03:24:45 <merijn> Rembane: GHC accepts ಠ in identifiers (see acme-LookOfDisapproval)
03:24:52 <Rembane> merijn: :D
03:24:59 <Arahael> I meant, did non-latin alphabets use a "case" to store their letters in? ;)
03:25:34 <merijn> This is technically a bug as the report specifies identifiers in terms of "uppercase unicode letter" and "lower case unicode letters", technically disallowing Kanada which has no case (which is the script ಠ is from)
03:25:42 <Lycurgus> sfaik, only latin and cyrillic use case
03:25:53 <tdammers> AFAIK, other languages didn't invent typesetting independently, they copied it from European countries where the Latin alphabet was used
03:25:59 <tdammers> Lycurgus: also Greek
03:26:17 <Lycurgus> well post classical greek
03:26:28 <Lycurgus> classical langs didn even use spaces
03:26:58 <Arahael> Lycurgus: I think in practice they did.
03:27:17 <Arahael> They just don't have spaces as an explicit concept.
03:27:35 <merijn> They tended to use dots/periods as space if you look at text engraved into walls
03:27:41 <MarcelineVQ> is that why old people put ... all over the place?
03:27:52 <Lycurgus> no they didn, diacritics in general come later in lang dev
03:27:56 <Arahael> Ellipses is something else.
03:27:56 <merijn> MarcelineVQ: Are you calling me old? >.<
03:27:57 <MarcelineVQ> like, between every fews words in emails and on facebook
03:28:04 <merijn> Also, what's wrong with ellipsis?
03:28:04 <MarcelineVQ> haha...funny!
03:28:04 <int-e> MarcelineVQ: what do you mean...
03:28:20 <tdammers> Lycurgus: classic Latin didn't have case either - they'd use "capitals" for masonry, and "majuscule" for hand-writing. the habit of mixing the two scripts didn't appear until the middle ages
03:28:24 * Arahael ponders... about ... whether he should get some sleep...
03:28:31 <int-e> merijn: it looks very narrow in fixed width fonts
03:29:06 <merijn> MarcelineVQ: https://en.wikipedia.org/wiki/Ellipsis
03:29:09 <int-e> …
03:29:23 * Lycurgus meant all the classicals, sanskrit, koine, etc
03:29:48 <merijn> MarcelineVQ: "Depending on their context and placement in a sentence, ellipses can indicate an unfinished thought, a leading statement, a slight pause, an echoing voice, or a nervous or awkward silence."
03:29:50 <MarcelineVQ> I know what elipses are for but I also know a lot of people who don't, but use them anyway, in place of spaces or commas, or without any particular rule at all
03:29:58 <int-e> what did people call the non-capital letters before the type setting notion of cases?
03:30:06 <Lycurgus> and ftm modern standard chinese
03:30:15 <merijn> MarcelineVQ: "haha...funny" seems like a perfectly reasonable use?
03:30:58 <merijn> Using a comma or period there seems awkward and just a space doesn't indicate the pause
03:31:19 <Arahael> And the use of the ellipsis accurately indicates something being unsead.
03:31:22 <Arahael> *unsaid.
03:31:48 <int-e> haha [...] funny
03:32:23 <Uniaika> int-e: in french we call them "Majuscule", from latin "majuscula" which means "slightly bigger"
03:32:39 * ski . o O ( "minuscule" vs. "majuscule" )
03:32:50 <int-e> ah that makes sense
03:32:55 <Uniaika> but wait, that's not all ;)
03:33:08 <Uniaika> majuscule refers to the position of a capital letter ;)
03:33:09 <Rembane> Is there a mediumuscule too?
03:33:27 <merijn> int-e: We call them (roughly translated) "head letters"
03:33:35 <Uniaika> Rembane: https://en.wikipedia.org/wiki/Small_caps ;)
03:34:02 <int-e> The casing convention is odd: é should be an upper case letter.
03:34:05 <MarcelineVQ> merijn: but there's no pause there at all
03:34:24 <merijn> MarcelineVQ: Maybe not when you say that
03:34:27 <Arahael> I'm going to find unicode painful.  Delphi does not define what encoding the files should be in.
03:34:39 <Uniaika> so, you can write a sentence in fullcaps, although only the first letter of the sentence and the first letter of names are majuscule
03:34:48 <Uniaika> int-e: you mean, in all cases?
03:34:55 <merijn> MarcelineVQ: But if I say "haha" with a guffaw there is definitely a pause between that and the following "funny", so *I* would write ellipsis there
03:34:56 <Lycurgus> delphi as in borlund?
03:35:16 <Rembane> Uniaika: Sweet! :D
03:35:22 <MarcelineVQ> But it wasn't your example it was mine :D An example of an improper use of ...
03:35:24 <merijn> MarcelineVQ: Without a pause it would sound like deadpan sarcasm
03:35:35 <MarcelineVQ> It's improper because there isn't a pause or missing text at all
03:35:39 <Arahael> Lycurgus: Yes.
03:35:42 <merijn> MarcelineVQ: You were talking about other people improperly using ellipsis
03:35:47 <int-e> Uniaika: https://en.wikipedia.org/wiki/Letter_case#Terminology ... look at the picture :)
03:35:54 <int-e> (pictures)
03:35:59 <merijn> MarcelineVQ: If they intended a pause there, how could it be improper?
03:36:04 <MarcelineVQ> They didn't
03:36:10 <merijn> Based on what?
03:36:25 <int-e> Uniaika: or maybe I didn't get a joke
03:36:41 <merijn> I would never write "haha" without any punctuation between it and any following text
03:36:45 <MarcelineVQ> Me knowing them and how they speak
03:36:55 <int-e> merijn: h.a.h.a.?
03:37:16 <Uniaika> int-e: oh I see! :)
03:37:30 <merijn> Anyway, we are know *thoroughl* offtopic :)
03:37:33 <lavalike> > (fmap.sequence) [isLetter,isUpper,isLower] "☃ಠo"
03:37:35 <lambdabot>  [[False,False,False],[True,False,False],[True,False,True]]
03:41:42 * hackage online 0.4.0.0 - online statistics  https://hackage.haskell.org/package/online-0.4.0.0 (tonyday567)
03:51:12 * hackage readme-lhs 0.3.0 - See readme.md  https://hackage.haskell.org/package/readme-lhs-0.3.0 (tonyday567)
04:15:11 * hackage web-rep 0.1.3 - representations of a web pag  https://hackage.haskell.org/package/web-rep-0.1.3 (tonyday567)
04:17:32 <copel> can I ask Gloss-related questions here?
04:17:47 <Uniaika> I guess yeah
04:20:09 <copel> can you take a look at this program: https://pastebin.com/Ae0xc0Rc I've spent so long trying to figure out what's wrong with it. It displays images correctly but doesn't update at all
04:23:56 <copel> wait i might have got it -_- 
04:49:12 <AWizzArd> How can I _not_ import (->)?  I tried     import Prelude hiding ((->))
04:49:57 <phadej> you cannot
04:49:59 <AWizzArd> More specifically: I want to hide the implementations of Functor, Applicative and Monad for ->
04:50:17 <phadej> and you cannot really hide instances either
04:50:30 <AWizzArd> phadej: oh okay, I see. I wanted to demonstrate to a colleague how to implement this, without wrapping it in a newtype.
04:51:15 <phadej> functionFmap :: (a -> b) -> ((->) e a) -> ((->) e b)
04:51:41 <dminuoso> AWizzArd: (->) is very special, since its implementation is primitive.
04:52:36 <AWizzArd> phadej: okay, maybe that will do. Or perhaps a new typeclass Funktor
04:53:43 <AWizzArd> dminuoso: makes sense
04:54:12 <phadej> -> is syntax, as well as [] and :
04:54:14 <AWizzArd> I think I'll go with Funktor, Aplikkative und Limonade
04:54:18 <phadej> they aren't defined anywhere, they just are
04:54:42 <dminuoso> phadej: For what its worth, list is sort of implemented in base basically
04:54:54 <tdammers> when life hands you Monoids, you make Lemonoide
04:56:00 <Rembane> AWizzArd: If you really want to spice it up, you can create your own function type. 
04:56:52 <dminuoso> You'd end up creating a language in the process.
04:57:20 <phadej>  NB: lists are built-in syntax, and hence not explicitly exported
04:57:47 <AWizzArd> Rembane: such as --> ?
04:58:06 <Rembane> AWizzArd: Sure.
04:59:12 <AWizzArd> Rembane: also an option, nice idea.
04:59:50 <phadej> well, that would be "wrapping it in a newtype", won't it
05:00:29 <Rembane> Yeah, or dance around that issue by creating a data type that isn't a newtype. :D
05:00:55 <AWizzArd> I think phadej is right here, at some point I would have to unpack the function.
05:01:01 <hpc> fwiw as well, you can go to a particular instance source from the Functor documentation
05:01:04 <hpc> https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#line-818
05:01:23 <hpc> if you just want to show the implementation
05:02:56 <Rembane> AWizzArd: If I can ignore the no-newtype-constraint, one argument for using a newtype is that you can show that your implementation is equal to the builtin one. 
05:06:42 <dminuoso> AWizzArd: Using newtypes to write different instances is a common trick.
05:07:36 <hpc> it's a common trick in real code, but i find the constructor trappings tend to get in the way when trying to learn something
05:15:42 * hackage aeson 1.4.6.0 - Fast JSON parsing and encoding  https://hackage.haskell.org/package/aeson-1.4.6.0 (AdamBergmark)
06:29:05 <boxscape> @where stg
06:29:05 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
06:33:27 <boxscape> If I type something like id=\a->a, is id initially represented as a lambda or as a thunk of a lambda?
06:34:23 <merijn> boxscape: E_INSUFFICIENT_CONTEXT :)
06:34:42 <merijn> boxscape: You mean concretely in GHC?
06:34:47 <boxscape> Yes
06:35:15 <merijn> boxscape: I'm not even sure it's possible to answer that question
06:35:48 <merijn> boxscape: Consider that GHC isn't even required to keep that binding in the first place
06:36:13 <merijn> boxscape: It's very well possible that it won't be in your program at all
06:36:58 <svipal> yo. let 's say I have data X = XA a | XB B | XC C , and that the types A B and C have valid instances of the class S, is there any way to automate making the instance for X ?
06:37:04 <boxscape> merijn, maybe to make it more concrete then, if i input it in ghci and type :print id, does the resulting _ represent a lambda or a thunk?
06:37:10 <svipal> XA A*
06:37:18 <merijn> boxscape: That I don't know
06:37:24 <boxscape> Ok
06:37:35 <boxscape> Thanks anyway :)
06:37:45 <merijn> svipal: I assume you're implying that X has too many alternative to do this manually?
06:38:11 <svipal> It 's possible to do it manually, but annoying enough that I'm thinking of writing TH to automate it
06:38:23 <svipal> but I was wondering if there wasn't a simpler way
06:38:42 <merijn> svipal: It's possible with both TH and with Generics
06:38:48 <svipal> because writing TH would probably take me more time than just writing it by hand for little benefit
06:38:51 <svipal> ohooo~
06:38:54 <merijn> svipal: Neither of those is going to be convenient enough to be worth it
06:39:03 <svipal> lol
06:39:43 <merijn> svipal: Unless you have like 10 datatypes like this with 5-10 alternatives each
06:41:11 <svipal> yeah nah
06:43:45 <hpyCdr> I try to use Megaparsec on my own Token type, but can't get it to type check. Any ideas? https://pastebin.com/P2P772wm
06:44:10 <hpyCdr> I thought that by defining the Parse type this way, I should be able to e.g. use 'single' this way
06:44:13 <svipal> the instance has 4 functions to define though ughh
06:44:54 <hpyCdr> (MegaParsec 7.0.5)
06:47:56 <merijn> hpyCdr: Did you define a Stream instance for [Token]?
06:51:12 <hpyCdr> merijn, no, let me take a look
06:52:31 <merijn> hpyCdr: single requires MonadParsec, which you will see has a superclass constraint of Stream on the token stream
06:54:58 <svipal> Okay what I did is that
06:55:38 <svipal> I made a "defer" function in the class
06:56:26 <svipal> `defer      ::  a -> ( forall x. NodeClass x  =>  x -> b) -> b`  with default `defer a f = f a`
06:57:11 <svipal> and for every function that fit the pattern I just made the default instance `fx n a = defer a fx`
06:57:37 <svipal> so I just had to define defer for the supertype au lieu de defining every function for every case
06:57:53 <svipal> and it didn't change anything for the subtypes
06:58:59 <svipal> with the pattern ```defer (XA n) f =  fn 
06:59:07 <svipal> woops
06:59:37 <svipal> ```defer (XA n) f =  fndefer (XB n) f =  fn```
07:00:01 <svipal> è_è
07:00:31 <svipal> `defer (XA n) f =  fn n``defer (XB n) f =  fn n`
07:00:41 <svipal> Ok I give up, but you get it anyways lol
07:02:15 <svipal> So now my question is : is there anyway this is not such a good idea and can horribly backfire ?
07:05:33 <merijn> svipal: Naah, looks fine to me
07:06:08 <merijn> svipal: Nice example use-case for Rank2Types, tbh :)
07:06:55 <merijn> svipal: Worst case scenario that can happen is "you add a new variant whose argument doesn't have a NodeClass instance" in which case it will simply stop compiling and then you're forced to implement it manually anyway
07:09:42 <svipal> Cool !
07:28:53 <hpyCdr> who to contact with ideas for hackage?
07:29:52 <merijn> hpyCdr: https://github.com/haskell/hackage-server/ but hackage is rather under-staffed so most features are on a "patches welcome" basis...
07:30:09 <dmwit> I don't think there's anybody who has a ton of spare cycles for feature requests. So unless you plan to implement it yourself, you'll almost certainly get the same response from /dev/null as from anybody official.
07:30:25 * dmwit high-fives merijn
07:32:58 <dminuoso> Or, if you toss enough money at it you might not have to implement it yourself.
07:34:54 <merijn> I'm curious what the idea is/was :p
07:35:11 * hackage byteslice 0.1.4.0 - Slicing managed and unmanaged memory  https://hackage.haskell.org/package/byteslice-0.1.4.0 (andrewthad)
07:38:42 * hackage bytesmith 0.3.1.0 - Nonresumable byte parser  https://hackage.haskell.org/package/bytesmith-0.3.1.0 (andrewthad)
07:50:19 <fendor> is there a  function to either replace or remove evervy non-ascii character text?
07:51:05 <f-a> fendor: filter + something from Data.Char ?
07:51:09 <f-a> or map
07:51:40 <f-a> :t filter isAscii
07:51:42 <lambdabot> [Char] -> [Char]
07:51:48 <fendor> oh, great, thanks
07:54:02 <Chobbes> Does anybody have experience with xml-conduit's streaming parsers? I'm trying to handle XML that looks like... "<stream a1=blah a2=blah><f>blah</f><f>blah2</f>" So, I need to handle the children of stream before the closing tag of stream, which I can do with manyYield, BUT the stream that I'm dealing with might also restart and send another opening stream tag without closing it. Any thoughts on how to deal
07:54:05 <Chobbes> with this?
07:54:12 <wroathe> Is there a straightforward way to get cabal to symlink a test executable into the project directory (the actual executable gets placed waaaaaay down deep inside dist-newstyle)
07:55:23 <fendor> wroathe, `cabal v2-install exe:test-exe --symlink-bindir=.` or if cabal version > 3.0 `cabal install exe:test-exe --installdir=.`
07:55:26 <f-a> wroathe: you know you could use cabal new-run, right?
07:56:16 <xaviergmail> Hey I'm considering getting LYAH paperback from amazon but before I do that I was just wondering if any revisions had been made that may not be in the printed book vs the online one?
07:57:02 <Chobbes> Also... If a Haskell package doesn't export a function / constructor that you need is the only recourse to fork the package?
07:57:08 <wroathe> fendor: gracias
07:57:14 <merijn> Chobbes: That sounds an awful like "not actually xml" though... >.>
07:57:43 <f-a> Chobbes: maybe contacting the maintainer
07:57:48 <merijn> Chobbes: Well, you can make a PR to fix the missing export...
07:58:01 <f-a> and live with a cabal.project meanwhile
07:58:32 <Chobbes> merijn: it's a little annoying in that it's "mostly XML". I believe the restarting is the only thing that isn't technically XML... https://tools.ietf.org/html/rfc6120#section-4.3.3
07:59:10 <merijn> Chobbes: tbh, a solid 90% of "XML" is properly XML, some is just more brokenly non-standard than others >.>
08:00:01 <merijn> wroathe: I just make dummy shell scripts that run my executable via v2-run :)
08:01:23 <wroathe> merijn: I'm trying to avoid using cabal for a test suite that I want to run repeatedly in a bash while loop
08:01:37 <merijn> wroathe: Why do you wanna avoid it?
08:01:43 <wroathe> There's easily like 1000-1500ms delay while cabal boots up and figures out whats what before running the actual test suite
08:02:00 <wroathe> the test suite takes like 200ms tops
08:02:15 <merijn> wroathe: Should be near instant, BUT you could be running into the same broken environment I had :)
08:02:30 <merijn> wroathe: So if you run "cabal v2-run" do you see any cabal output before the executable runs?
08:02:48 <wroathe> Oh, v2-run is fast
08:02:53 <wroathe> I was using v2-test
08:03:03 <wroathe> which tries to build
08:03:10 <wroathe> So that's probably where the speed hit comes from
08:03:12 <Stuck_> I'm looking at TH following this tutorial: https://wiki.haskell.org/A_practical_Template_Haskell_Tutorial. And the part of curryN works nice using $(curryN 3) to get the actual function at compile time, the problem is when I try to create declarations for example in genCurries, I try to write to other module (that imports the module where genCurries is) $(genCurries 10) in the hope that it would create 
08:03:18 <Stuck_> the declarations in compile time, ghci complains that genCurries is not in scope. Any help on what I'm doing wrong?
08:03:52 <merijn> Stuck_: Did you define genCurries in the same module you're using it?
08:04:30 <Stuck_> well I defined it in the module i'm importing
08:04:58 <merijn> Stuck_: Can you make a minimal example and put it in a github gist?
08:10:13 <Stuck_> I'm sorry merijn, when I was creating the gist I've realised that I was editing the wrong file, thanks anyway
08:11:09 <merijn> :)
08:15:11 * hackage tmp-postgres 1.10.0.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.10.0.0 (JonathanFischoff)
08:20:56 <drewr> bnim
08:21:11 <drewr> (wrong window)
08:36:42 * hackage pandoc-types 1.20 - Types for representing a structured document  https://hackage.haskell.org/package/pandoc-types-1.20 (JohnMacFarlane)
09:04:47 <siraben> How would one go about deriving bracket abstraction algorithms?
09:15:57 <whiskerzz> Now, I definitely might be an idiot here, so I'm very sorry if that's what's happening
09:16:22 <whiskerzz> but it doesn't seem like Cabal 3 is very easy to install on ubuntu
09:16:33 <merijn> whiskerzz: How so?
09:16:45 <whiskerzz> here's what I did: 1) Install ghc from apt, gets version 8.0.2
09:16:55 <whiskerzz> go here https://www.haskell.org/cabal/download.html
09:16:57 <merijn> whiskerzz: That version of GHC is fairly old
09:17:03 <merijn> You probably want hvr's ppa
09:17:19 <merijn> whiskerzz: https://launchpad.net/~hvr/+archive/ubuntu/ghc
09:17:25 <whiskerzz> download cabal-install-3.0.0.0.tar.gz, untar, cd
09:17:46 <whiskerzz> merijn, hm, okay
09:18:18 <whiskerzz> I'm curious though, is there a reason the most recent version isn't just in the regular repos?
09:18:30 <merijn> whiskerzz: Also, when you install ghc does it also install a version of cabal-install already? because it's fairly easy to build cabal-install with cabal-install
09:18:47 <merijn> whiskerzz: That is a question for the ubuntu maintainers/packagers
09:18:49 <whiskerzz> for noobs like me, installing some PPA often is a barrier
09:19:08 <whiskerzz> not physically, but in terms of confidence
09:19:27 <whiskerzz> Hm
09:19:34 <whiskerzz> merijn, it doesn't, with ghc
09:19:36 <evelyn> It seems unfair to blame anyone but Ubuntu in this respect
09:19:42 <merijn> whiskerzz: The Ubuntu maintainers are in charge of deciding what apt-get installs, the GHC project has fairly little influence on that
09:19:46 <whiskerzz> unless it's not on the PATH or something
09:19:49 <whiskerzz> Ahh
09:20:05 <merijn> whiskerzz: Could be, some package managers combine the two, others don't
09:20:37 <merijn> whiskerzz: Besides using hvr's PPA there's also ghcup (which many people like, but I don't since it wants to much control over my environment)
09:21:01 <merijn> whiskerzz: If you're a stubborn unix curmudgeon like me there's always the "just manually install a GHC bindist solution"
09:21:14 <whiskerzz> I see
09:21:55 <merijn> Which is just a matter of "./configure --prefix=path/to/install && make install" and building cabal-install from source
09:22:00 <whiskerzz> So I should probably install the ghc version, 8.8.1-12~18.04, since that seems to be the latest and I'm using ubuntu 18.04?
09:23:27 <merijn> whiskerzz: Right now I'd go with 8.6.5 personally, 8.8 was released 2 months ago and it usually takes a while for the ecosystem to catch up
09:23:44 <whiskerzz> Hm I see
09:23:45 <maerwald> 8.8 support is pretty ok
09:23:48 <merijn> So I generally lag behind GHC releases for 6 months to a year, unless I need a specific bugfix
09:24:14 <merijn> maerwald: Sure, but generally unless there is a specific reason to use the very latest version there is nothing wrong with using the one before it
09:24:46 <maerwald> merijn: what do you mean with "too much control" btw?
09:25:31 <merijn> maerwald: It wants to mess with my carefully setup and managed environment variables, etc. and wants to decide where everything gets installed
09:26:10 <maerwald> merijn: it doesn't do anything with your env variables and install location can be controlled
09:27:10 <maerwald> ignore the bootstrap script, that is just a wrapper for lazy people. ghcup itself does nothing with your bashrc or env
09:29:32 <merijn> maerwald: Without the bootstrapper would I bother using it?
09:29:37 <merijn> +why
09:30:23 <maerwald> merijn: https://gitlab.haskell.org/haskell/ghcup/#manual-install
09:30:29 <maerwald> the bootstrapper installs ghcup
09:30:53 <maerwald> and, for lazy people, suggests to mess with .bashrc (if you type in YES)
09:31:03 <maerwald> other than that, no files, no env, nothing is touched
09:31:51 <maerwald> https://gitlab.haskell.org/haskell/ghcup/blob/master/ghcup#L61 and here you can set the install location
09:32:17 <maerwald> undocumented, so people don't do weird stuff and then request support :P
09:32:29 <pie_> whats sbt and metals https://twitter.com/rossabaker/status/1192864987850653696 ?
09:35:43 <merijn> maerwald: Yeah, or I just keep using the bindists like I have for over half a decade :p
09:36:03 <maerwald> sure, I just want to make clear that if ghcup messes with your env or files: it is a BUG
09:36:11 <maerwald> and it never should do that
09:42:07 <monochrom> I use that undocumented variable too :)
09:42:32 <monochrom> found it when one day I had nothing to do so I read the code.
09:44:55 <evelyn> pie_: SBT is a Scala thing
09:45:08 <evelyn> https://www.scala-sbt.org
09:45:36 <evelyn> Likewise for metals: https://scalameta.org/metals/
09:46:24 <evelyn> SBT is (I presume) [a] Scala build tool
09:48:19 <yushyin> so scala has a working and functional language server, huh? *jelly* :)
09:49:03 <wroathe> peanut butter
09:50:03 <evelyn> I don't know what exactly a language server is, but... yes?
09:50:27 <yushyin> evelyn: https://langserver.org/
09:52:27 <evelyn> it looks like my luna68k box isn't powerful enough to run that >:)
10:01:58 <wroathe> Anyone know if any of the standard containers are implementations of a red-black tree off the top of their head?
10:03:29 <ChaiTRex> What a service, flood channels with quits by kicking off all the idle-too-long people at the same time.
10:08:05 <dsal> Map.splitRoot doesn't seem quite useful enough.
10:09:00 <wroathe> It's interesting that we've got unordered-containers, ordered-containers, and just containers
10:09:17 <wroathe> It seems like containers should neatly partition into the first two
10:09:46 <ChaiTRex> wroathe: there's red-black-tree
10:28:01 <margo49> how can I create a list of tuples from another list, so that if a number is greater then 9, it pairs it: (x,_) or if it's less then (y,_) ?
10:30:01 <koz_> > fmap (\x -> if x < 9 then (1, x) else (2, x)) [7, 8, 9, 10]
10:30:03 <lambdabot>  [(1,7),(1,8),(2,9),(2,10)]
10:30:12 <koz_> Something like that?
10:31:08 <margo49> think so
10:36:56 <dmwit> wroathe: Half the reason I chose the name "ordered-containers" was because of how delightful that little trichotomy felt. =)
10:39:06 <iqubic> What are ordered-containers? Aren't Maps already ordered in the regular containers library??
10:40:26 <wroathe> dmwit: That's the first time I've seen trichotomy used in sentence. Look at the big brains on you ;)
10:41:01 <iqubic> What's the trichotomy present in the phrase "Ordered-Containers" I'm just not seeing it.
10:41:22 <wroathe> iqubic: There's an unordered-containers, and a containers
10:41:31 <wroathe> So that makes ordered-containers the third category
10:41:42 <iqubic> Ah. I see.
10:42:08 <iqubic> Why do you want ordered-containers? Isn't Map from Containers already ordered?
10:42:34 <wroathe> iqubic: :P Just accept that you're missing context for this convo and move on
10:42:41 <dmwit> iqubic: Have you tried reading the fine documentation?
10:43:18 <iqubic> No. I haven't.
10:43:30 <iqubic> I guess I'll just accept that I don't know the right context.
10:43:31 <dmwit> I mean, I know you haven't, because I wrote it and I know it answers that question. So let me say that a different way: get in the habit of reading the fine documentation before you ask trivial questions.
10:43:33 <koz_> iqubic: It explains it pretty well.
10:45:26 <wroathe> https://www.youtube.com/watch?v=4Wu598ENenk
10:48:29 <wroathe> Anyone know if there's a way to make cabal valgrind my executable?
10:48:43 <wroathe> with something like exec or something like that
10:49:14 <dmwit> cabal v2-build exe:whatever && cabal v2-exec valgrind -- whatever
10:49:19 <dmwit> I *think* that should work.
10:49:28 <dmwit> I can't remember whether v2-exec modifies PATH or just does path lookups itself.
10:49:38 <wroathe> i'll give it a shot, thanks
10:49:42 * hackage cpsa 3.6.5 - Symbolic cryptographic protocol analyzer  https://hackage.haskell.org/package/cpsa-3.6.5 (mliskov)
10:49:47 <dmwit> If the latter, then ... && valgrind $(cabal v2-exec which whatever) will get you where you need to go.
10:50:35 <dmwit> Come to think of it, the fact that which whatever works must mean that cabal modifies PATH. So the first one should work fine.
10:51:53 <wroathe> hmm, it's actually the test executable I want to valgrind: https://gist.github.com/JustinChristensen/394d2eed59a10b548727b8bede384e37
10:52:02 <wroathe> and cabal v2-exec valgrind -- props-test doesn't seem to work
10:52:25 <wroathe> I should mention I'm on 2.4.1.0 of Cabal
10:53:14 <wroathe> cabal v2-exec which props-test outputs nothing
10:53:29 <wroathe> But the test executable is located here: dist-newstyle/build/x86_64-linux/ghc-8.6.5/base-props-0.0.1/t/props-test/build/props-test/props-test
10:54:42 <dmwit> Okay, tests don't get put on the PATH.
10:55:02 <dmwit> I don't know of a robust way to query cabal for the location of test executables.
10:55:07 <wroathe> My first thought is to do this independently from Cabal using find
10:55:33 <wroathe> But it seems like Cabal should have a subcommand to query it's environment and configuration
10:55:35 <dmwit> You can do that. Beware that find may return multiple results if e.g. you have v2-build'ed with different -w flags or --constraint flags or whatever.
10:55:59 <dmwit> I agree. I think there is a tracker bug with some speculation about how such a feature might work and what it might offer, but no implementation work done yet.
10:59:09 <wroathe> dmwit: Seems odd that there's so much bikeshedding that goes into features that other large command line interfaces have already established historical examples for. I'm thinking of git config as an example.
11:01:15 <phadej> @package cabal-plan
11:01:15 <lambdabot> http://hackage.haskell.org/package/cabal-plan
11:01:52 <dmwit> Relevant issues on the cabal issue tracker: 2771, 3643, 3850, 4220
11:05:09 <wroathe> Oh, I did not know about plan.json
11:05:11 <wroathe> That's neat
11:05:18 <wroathe> bin-file seems to have the path I want
11:05:29 <wroathe> phadej: I should've guessed you had solved this already
11:09:42 * hackage diagrams-contrib 1.4.4 - Collection of user contributions to diagrams EDSL  https://hackage.haskell.org/package/diagrams-contrib-1.4.4 (BrentYorgey)
11:13:12 * hackage texmath 0.12 - Conversion between formats used to represent mathematics.  https://hackage.haskell.org/package/texmath-0.12 (JohnMacFarlane)
11:16:59 <wroathe> phadej: Is there a plan to merge cabal-plan with cabal in the future? It seems to have a lot of features that people are requesting of cabal.
11:18:35 <wroathe> phadej: or would you consider it more of a stopgap until they sort out what their version of this is going to look like
11:24:17 <chreekat> wroathe: looks like hvr is the author of cabal-plan anyway, although your question is still valid
11:24:46 <chreekat> nm, commit history is very different from author information in cabal file
11:26:18 <pie_> evelyn: oh
11:27:11 * hackage fused-effects-exceptions 1.0.0.0 - Handle exceptions thrown in IO with fused-effects.  https://hackage.haskell.org/package/fused-effects-exceptions-1.0.0.0 (patrick_thomson)
11:33:49 <tamme> hello, can someone explain why the following type definition is allowed?: data T = Ctor T
11:34:52 <ChaiTRex> tamme: Because removing it would add a rule we don't strictly need, making things more complicated.
11:39:20 <tamme> mh ok, what would make such a rule complicated?
11:40:53 <tamme> because the problem is that such a constructor can never be fully applied.
11:47:26 <whiskerzz> merijn, I must be messing up something really basic
11:47:45 <whiskerzz> I removed the repo version of ghc, and added ghc 8.6.5 using that guy's PPA
11:47:47 <whiskerzz> seemed to install fine
11:48:13 <whiskerzz> I added it to my PATH, by adding /opt/ghc/8.6.5/bin to the front of my path, now it autofills, etc
11:48:32 <whiskerzz> now when I do ./bootstrap.sh, same errors at the end
11:48:53 <merijn> Which errors?
11:49:50 <whiskerzz> several of the general format:
11:49:52 <whiskerzz> Distribution/Compat/Binary.hs:31:1: error:
11:49:52 <whiskerzz>     Could not find module ‘Data.Binary’
11:49:52 <whiskerzz>     Perhaps you haven't installed the profiling libraries for package ‘binary-0.8.6.0’?
11:49:52 <whiskerzz>     Use -v to see a list of the files searched for.
11:49:52 <whiskerzz>    |
11:49:53 <whiskerzz> 31 | import Data.Binary
11:50:10 <whiskerzz> er, sorry, should've pastebinned that
11:50:48 <merijn> whiskerzz: hmm, suspicious
11:51:13 <whiskerzz> That was pretty much the same as with 8.0.2, slightly different but the same
11:51:19 <merijn> whiskerzz: Ok so if you run "command -v ghc" and "ghc --version" what do you get?
11:51:30 <whiskerzz> googling the final error from before led me to: https://github.com/haskell/cabal/issues/3434
11:51:37 <whiskerzz> I tried the --no-doc option, same result
11:51:48 <merijn> whiskerzz: And bootstrap.sh is inside a clone of the cabal repo on github or something?
11:52:13 <whiskerzz> merijn, those give 8.6.5 and /opt/ghc/8.6.5/bin/ghc
11:52:41 <merijn> ah, actually
11:53:04 <merijn> I just noticed the error complains about *profiling* libraries
11:53:12 <whiskerzz> merijn, er, maybe that's what I'm messing up? I downloaded, from https://www.haskell.org/cabal/download.html , the one called "source download"
11:53:25 <merijn> So, I don't know why it tries to do a profiling build, that's question 1
11:53:36 <whiskerzz> it has a folder called cabal-install-3.0.0.0 in it, with bootstrap.sh inside that
11:53:38 <whiskerzz> hm
11:53:47 <merijn> whiskerzz: Do you have an existing ~/.cabal/config file?
11:53:50 <whiskerzz> this is on a new machine, separate from all that profiling stuff I was trying to do before
11:54:10 <whiskerzz> merijn, nope
11:54:20 <merijn> hmmm
11:55:22 <whiskerzz> I'm not supposed to like, install some other libraries in addition to ghc, am I?
11:55:45 <merijn> whiskerzz: bootstrap.sh is what's supposed to take care of installing the additional libraries you need
11:55:49 <whiskerzz> I mean, on that website, there's also a download for "cabal library"
11:55:51 <whiskerzz> Yeah
11:56:00 <whiskerzz> I'm pretty sure I did this stuff before on my other machine and it worked
11:56:57 <merijn> whiskerzz: What if you run: EXTRA_CONFIGURE_OPTS="" ./bootstrap.sh
11:57:11 <merijn> (i.e. prefix that variable definition ahead of the command)
11:58:33 <whiskerzz> Right, should've tried that... lemme see
12:03:50 <whiskerzz> hm, sure doing a lot more stuff than before...
12:04:02 <whiskerzz> lotta warnings though...
12:05:24 <whiskerzz> aaaaaaaaand failed.
12:05:38 <whiskerzz> Configuring the zlib package failed.
12:10:12 <EvanR> tamme: that one can be fully applied, since haskell is lazy
12:10:17 <EvanR> fix Ctor
12:10:30 <EvanR> let x = Ctor x in x
12:11:43 <EvanR> forming an ouroboric heap object
12:13:42 <tamme> ok, and does that have any practical use?
12:14:12 * hackage pell 0.1.3.0 - Package to solve the Generalized Pell Equation.  https://hackage.haskell.org/package/pell-0.1.3.0 (lbrunjes)
12:18:25 <EvanR> i tried to come up with one, but couldn't. Now if you add another constructor, a type variable, a second field, etc it may have some practical use. Or it might not. I'm glad the language designers didn't try to figure that out ahead of time and try to impose bondage and discipline
12:19:19 <EvanR> categorical laws of types might also suffer if the seemingly pointless type data T = MkT T was illegal
12:20:04 <whiskerzz> merijn, got it working. For future reference, googling told me that for some reason I had to do: apt install libghc-zlib-dev
12:20:39 <EvanR> similarly, the number zero might seem pointless. But as moderns we know subtle reasons why it's good
12:21:05 <Lycurgus> to whom would it seem pointless?
12:21:40 <Lycurgus> (i.e. who who's opion on mathematics could matter)
12:21:54 <evelyn> whiskerzz: that's a package which is the zlib haskell  package; it now no longer fails because you've installed a prebuilt one.
12:22:02 <EvanR> whose ?
12:22:22 <EvanR> what a weird word
12:22:28 <whiskerzz> evelyn, it seems like the bootstrapper should've tried to get that though?
12:22:36 <Lycurgus> right sorry, at least I'm not chewing up the channel with petty i can't config shit issues
12:22:38 <evelyn> whiskerzz: but you could as well have install zlib1g-dev and built it. I don't think it's a good idea just to install a package because the internet tells you to
12:22:44 <EvanR> lol
12:22:49 <EvanR> tell us how you really think
12:22:58 <evelyn> "googling told me that for some reason I had to do"
12:23:17 <whiskerzz> Alright, sorry
12:23:18 <evelyn> well this does rather beg the question, why don't you ask the reason it told you to?
12:23:47 <evelyn> I think this is fine though.
12:24:28 <EvanR> Lycurgus: i'm not sure, but i always invent such a person when people ask "what is the point of the identity function, empty lists (array of size 0), ..." or similarly edge casey things
12:24:48 <whiskerzz> Because I have a lot of things to do, and in my experience why package dependencies do or don't work is kind of a rabbit hole and moving target
12:25:35 <evelyn> but a few hours ago you were complaining about Ubuntu not having the latest version of ghc, you can't have it both ways
12:25:37 <Lycurgus> EvanR: k, that would be the set of person I requested
12:25:46 <__monty__> whiskerzz: Installing a mix of packages using the distro's dependency manager and cabal can lead to headaches fwiw.
12:25:47 <whiskerzz> Anyway, sorry for chewing up the channel with this stuff, I'll stop
12:26:08 <Lycurgus> *persons
12:26:21 <whiskerzz> __monty__, yeah, that's definitely a worry :/
12:27:07 <__monty__> whiskerzz: The package evelyn suggested should get you the dependencies so cabal can build the package.
12:28:22 <EvanR> Lycurgus: i imagine a functor from those people to a past world where zero had not yet been invented
12:28:43 <tamme> ok, however, zero, the identical mapping, or a n empty list do not cause problematic behavior such as a never-ending recursion.
12:28:54 <tamme> like data T = C T
12:28:57 <EvanR> there is no problem with data T = C T
12:29:15 <EvanR> it doesn't cause a freeze by itself
12:29:21 <Lycurgus> or one where 'functor' still had only the original sense cantor gave it and not the current functor community
12:29:30 <nshepperd1> I thought the Romans didn't have 0
12:29:57 <EvanR> i bet they did in some way and we're just ignorant
12:30:09 <Lycurgus> 0 is hindu arabic
12:30:11 <EvanR> babylonians had a O shaped thing for zero but it wasn't used in arithmetic
12:30:26 <Lycurgus> it's not in classical mathematics of the west or china
12:30:50 <EvanR> (what was cantor's functor)
12:31:24 <Lycurgus> basically a predicate with named values
12:31:34 <tamme> ... XD thats not the topic / question – history of zero  
12:31:44 <Lycurgus> similar to the current prolog usage
12:31:45 <EvanR> tamme: so, another way to look at it
12:32:06 <EvanR> tamme: data T = C T has only 1 non-bottom value. The let x = C x in x value. 
12:32:11 <whiskerzz> __monty__, thank you
12:32:17 <EvanR> so it's bijective with the type data () = ()
12:32:24 <EvanR> which is not considered useless or illegal
12:32:44 <EvanR> it's a drop in replacement
12:34:41 * hackage mad-props 0.2.0.0 - Monadic DSL for building constraint solvers using basic propagators.  https://hackage.haskell.org/package/mad-props-0.2.0.0 (ChrisPenner)
12:36:44 <EvanR> i've got another one. In C you arbitrarily can't have an array of size 0. I imagine somebody said "let's make that illegal because it'd be useless". But here is why it would actually be useful, imagine a tool or language that was designed to convert C code or produce C code from source. Now it needs special case to avoid an array of size 0, even if it would make sense (though perhaps be useless).
12:37:10 <EvanR> by analogy if you had tools to work produce or convert haskell to haskell, it would have to avoid generating types that were arbitrarily deemed useless and so illegal
12:37:13 <EvanR> even if it wouldn't hurt
12:37:40 <merijn> It's not even useless, though
12:39:03 <geekosaur> it had a real use once
12:39:28 <geekosaur> put it at the end of a struct, you have something useful and that a lot of code used to use
12:40:10 <Lycurgus> you can't substitute useless for wrong in that idiom
12:40:48 <geekosaur> we're talking C. they left worse abuses in.
12:41:06 <Lycurgus> the complement of useless is binary: helpful/harmful
12:43:47 <geekosaur> actually, you want useless (and still in) C? you can swap around x[y]
12:44:24 <nshepperd1> useless things need to exist so that usefullness has an identity
12:44:36 <tamme> ok, XD but why can not I do that without getting an error: x = C C
12:44:47 <nshepperd1> Either Void a, ((), a)
12:45:06 <EvanR> tamme: data T = C !T might be what you were thinking of with bad recursion. And here you can't even construct it. Useless? Well now it's bijective with data Void {- no ctors -}, which turns out to be useful
12:45:11 * hackage mad-props 0.2.1.0 - Monadic DSL for building constraint solvers using basic propagators.  https://hackage.haskell.org/package/mad-props-0.2.1.0 (ChrisPenner)
12:45:54 <EvanR> tamme: C C is just a regular type error
12:46:09 <EvanR> C takes a T not a function
12:47:09 <EvanR> (Void being zero of type algebra so maybe I haven't gone totally insane on analogies)
12:47:58 <tamme> that's right. how embarrassing of me; but that did not change the funny things of the whole. XD
12:50:34 <tamme> OK. at least I understand that you could look at this construct like void or (). possibly in a certain context as something to use / interpret.
12:53:47 <EvanR> x[y] = y[x] seems kind of like the same situation. We have a feature and by god we'll allow its logical conclusion, no special cases
12:57:49 <tamme> or nullary type classes
13:03:15 <oo_miguel> how do I tell cabal (via the cabal file) to statically link an executable?
13:04:07 <monochrom> It already does. Unless you mean C libraries.
13:04:55 <oo_miguel> monochrom: oh. I meant just ALL libraries, did not notice that only C libraries are not linked statically
13:05:29 <oo_miguel> can I tell cabal to tell ghc to also statically link the C libraries?
13:08:12 * hackage numhask 0.3.1 - numeric classes  https://hackage.haskell.org/package/numhask-0.3.1 (tonyday567)
13:08:33 <_oz> I've got an HPC question (http://hackage.haskell.org/package/hpc)
13:08:51 <_oz> it looks like hpc shares its issue tracker with ghc
13:09:11 * hackage numhask-prelude 0.3.2, numhask-hedgehog 0.3.1 (tonyday567): https://qbin.io/lands-dublin-t2f0
13:09:40 <_oz> I can post something there, but if I am lucky and a maintainer is around I can ask here maybe :)
13:13:21 <oo_miguel> seems "ld-options: -static" is what I need
13:15:30 <refusenick> I'd like to animate some simple optimization programs (e.g. simplex method, gradient descent) using FRP. Which library would be best for this? AFRP looks especially interesting to me.
13:18:24 <EvanR> there's gloss for simple animations
13:18:43 <EvanR> but text formatting as such leaves to be desired
13:18:58 <jle`> what are you expecting FRP/AFRP to offer you in terms of optimization?
13:19:30 <jle`> ah, just noticed you said animate
13:20:40 <refusenick> EvanR: I'm more interested in Haskell for the math than practicality. I suppose I could write something in Python, but Haskell has caught my attention.
13:21:33 <refusenick> My first thought was to make the animation in Maxima (which is what I use for most computer algebra), but I don't see docs on how to make animations with it.
13:22:33 <refusenick> I haven't done much Haskell before, but I have over a week to do this and midterms are over.
13:25:03 <EvanR> there's a deadline, but not necessarily interested in the most practical way
13:25:24 <refusenick> Actually, it might even be 2 weeks from now.
13:25:24 <refusenick>  
13:25:52 <EvanR> i've done animations in matlab
13:26:02 <EvanR> but that's might be too practical
13:27:56 <refusenick> I hate Matlab. It would probably be easier to add support for Gnuplot's GIF output to Maxima than to get a working simplex animation in Matlab for me.
13:28:11 <refusenick> Besides, I've been wanting to learn Haskell for a while now.
13:30:14 <refusenick> Worst comes to worst, I'll write out an animation in Python. That won't take more than a day. I'd really like to give Haskell a chance, though.
13:45:03 <refusenick> Any Emacs setup recommendations? Right now, I have ghcide + lsp-haskell + haskell-mode. I use Counsel+Ivy for search & completion, and Org-Noter to sync notes to docs. My main goal is discoverability; pointers along the lines of haskell-mode's Hoogle integration would be nice.
13:45:55 <refusenick> (my use-case for Haskell would be when Maxima isn't flexible enough, so finding packages quickly is nice)
13:46:40 <refusenick> oh, and I'm using Stack
13:49:47 <EvanR> i've also mused about generating animations using diagrams (the library)
13:49:59 <EvanR> generate N frames and glue them together with a gif lib
13:51:56 <refusenick> Hmm. It looks like the frp-zoo repo uses FRP libraries as an interface of sorts to Gloss.
13:52:03 <refusenick> That might be what I'm looking for.
13:54:18 <EvanR> are you doing interactive animations?
13:56:51 <refusenick> EvanR: I'd like to be able to add new goals without recompiling or generating a new GIF from the terminal.
13:57:25 <refusenick> I'm giving a presentation to people without much math experience, so the easier and smoother the whole thing looks, the better.
13:58:01 <EvanR> cool
13:58:33 <refusenick> It's bad enough that there will be some Latinate math words (and I'm trying to avoid using them). Exposing them to Unix would distract and get rid of any chance of getting my point across.
13:59:06 <refusenick> Hell, I'm even setting up a second WM so that EXWM's weird appearance doesn't distract them.
13:59:38 <EvanR> fullscreen emersive surround sound ? :)
14:00:55 <refusenick> Eh. I don't care much for optimizing consumer tech choices for a "better experience". I'm pretty down-to-earth about productivity for the most part.
14:02:13 <refusenick> That's why I use an old Thinkpad with EXWM. I find it easier to fix than modern stuff when I mess something up.
14:03:55 <refusenick> The only downside is that I regularly have to field questions about why my laptop is so old or why I do so many things in the terminal.
14:14:41 <EvanR> why does refusenick use such an old laptop and refuse to use a modern desktop environment i wonder
14:15:45 <geekosaur> :p
14:25:10 <refusenick> Any recommendations for a calculus or analysis book using Haskell?
14:27:25 <[exa]> why would calculus books use haskell when they can just use math?
14:28:27 <refusenick> I've actually been using Maxima for problem solving and 3D graphing. I like doing math on its own, but making it interactive is even cooler.
14:29:16 <EvanR> this kind of book does sound interesting
14:29:18 <refusenick> There's a discrete math book in Haskell; I wish I had read it when I took that. Maybe I'll review it when I'm getting ready for abstract algebra.
14:29:58 <EvanR> "Haskell as a metalanguage despite itself"
14:30:30 <[exa]> well the problem with calculus is the finiteness
14:30:34 <[exa]> which is often absent
14:30:54 <refusenick> EvanR: It does seem somewhat restricted in terms of experimenting with category theory, for understandable reasons.
14:31:28 <refusenick> [exa]: Ever heard of discrete differential geometry?
14:32:00 <refusenick> https://www.ams.org/publications/journals/notices/201710/rnoti-p1153.pdf
14:39:21 <EvanR> holy crap that paper looks awesome
14:39:38 <[exa]> refusenick: yeah but you said calculus :]
14:40:54 <refusenick> [exa]: Eh. I'm in multivariable calculus right now. From what I understand, you can branch off into real analysis (for the foundations of it) or differential geometry (for linking it to linear algebra and applications thereof).
14:41:17 <refusenick> EvanR: One of the authors, Keenan Crane, has a free book about DDG on his website.
14:41:34 <refusenick> I think it's still a WiP, but I already love it so far.
14:42:02 <refusenick> I plan to read more of it over winter break and maybe try some sample projects from it in Maxima or Haskell.
14:42:36 <refusenick> EvanR: His website has the book and a bunch of other cool stuff - https://www.cs.cmu.edu/~kmcrane/
14:45:48 <refusenick> I think it's fair to say that stuff like DDG is why I've decided I'm going to declare as an Applied Math major instead of CS, even though I spend so much time programming.
14:45:55 <[exa]> refusenick: well it's certainly cool but I'm not sure whether it's going to help you work with actual things from real analysis (eg this one: https://en.wikipedia.org/wiki/Weierstrass_function )
14:47:50 <refusenick> [exa]: It seems real analysis will let me better understand why things work the way they do in Calc 3 (e.g. my book skipped over the proof of the 2nd Derivative Test, so I tried to prove it myself; I learn a lot about Hessians, but hit a brick wall with formal definitions of derivatives), but diff geo is closer to the kind of problem solving the class consists of.
14:48:38 <[exa]> 2nd derivative test needs a proof??!
14:50:39 <refusenick> It seems rather intuitive why it works, but intuition's lack of rigor is precisely why Weierstrass developed the foundations of modern analysis. His proof that there existed continuous functions which weren't differentiable at any point (pathological functions such as the Weierstrass function) demolished many 19th-century theorems about calculus (as they assumed that there would be at least 1 differentiable point)
14:51:27 <[exa]> okay nevermind sorry, the point is that we're taught calculus kindof at the borderline, like "how to recognize and trivialize stuff that you can differentiate" which is basically 99% proofs; which seems not like what you were seeking :]
14:51:57 <EvanR> for some value of "actual" in actual real analysis
14:52:13 <EvanR> classical logic, platonism
14:53:28 <refusenick> It's easy to explain away the 2nd derivative test by saying that that all-positive eigenvalues of the Hessian matrix show all nearby points curve away upwards (meaning a local minimum) and vice versa for negative eigenvalues indicating a local maximum, with a mix of positive and negative eigenvalues indicating a saddle point, but you can't give it a rigorous form without delving into analysis.
14:53:33 <EvanR> computing bolzano weierstrass subsequence produces limited principle of omniscience
14:54:38 <[exa]> refusenick: aren't eigenvalues a bit of overkill for this thingy? it can be proven by basically rewriting the definitions with the small epsilon on the beginning
14:56:39 <refusenick> [exa]: My only exposures to "real math" (not plug-and-chug physics and engineering formulas, not that there's anything wrong with that!) in a rigorous (non-self-study way) have been classes in linear algebra and discrete math.
14:57:50 <refusenick> I noticed that the formula for the test on a function in 2 variables looked a lot like a 2-by-2 determinant, so I spent some time searching. If I had known the word "Hessian", I could have found that on the Wikipedia page, but it's good to know I was on the right track.
14:58:30 <refusenick> My hope is that Haskell's strict type system will allow it to function as a poor man's proof checker without demanding the kind of rigor delivered by Coq (which I neither need nor want right now), something to check my reasoning for obvious errors.
14:58:52 <[exa]> oh that may explain that. linear algebra courses are usually "tool oriented", discrete math is "tricks". The calculus courses are for building up reals from limits and seeing the complexity explosion that happens
14:59:00 <refusenick> I guess what I'm really asking for is a book on type-level programming in Haskell.
14:59:05 <[exa]> :]
14:59:50 <[exa]> what I wanted to point out is that usual proof systems are probably not going to help you with calculus, the reals are too complicated
15:00:13 <[exa]> on the type-level programming I suggest looking at Agda and then backporting whatever you need from there
15:00:43 <EvanR> that's why a haskell version would be interesting, considering how it's not supposed to "do math"
15:00:58 <EvanR> would be interesting to see if there was a non-crap way to do it
15:01:21 <EvanR> type classism kind of doesn't translate to agda or idris
15:02:30 <refusenick> EvanR: I'm all-in on math being cool, so I suppose [exa] is right that I should look into Agda (although I was hoping for something with Haskell-level tooling for Emacs), but a Haskell book would be cool, both because it might force things to be kept simple for a wider audience and because it might be easier to do practical projects with it.
15:02:49 <refusenick> I know the Racket people do a lot of that kind of stuff, but a touch more rigor couldn't hurt, I don't think.
15:03:50 <[exa]> refusenick: btw the abstract algebra with groups and fields is very likely a much more happy place for type systems
15:04:23 <[exa]> in calculus, everything is "yeah real" which means "infinite complexity everywhere"
15:04:46 <refusenick> [exa]: It seems like that's why there's not one, but at least 2 books (that I know of) tackling discrete math or algebra in some form.
15:04:53 <EvanR> ironically smoothness makes that complexity less severe
15:05:00 <EvanR> differentiability
15:05:08 <EvanR> the complexity of real functions
15:05:30 <EvanR> hence the differential geometry
15:06:55 <EvanR> set theory reals basks in the absurdity of real numbers, differential geometry imposes a restriction which takes away the absurd and allows computability for example
15:06:55 <[exa]> EvanR: infinity still lurks there
15:07:07 <refusenick> I've been mulling over the idea of calculus as a special case of probabilistic approximation of a continuous function, where the smoothness means approximation can itself be taken to a logical conclusion (hence why fractals and other pathological maps can only be understood, poorly, in terms of probabilistic approximations)
15:07:14 <EvanR> s/set theory reals/set theory/
15:08:55 <EvanR> [exa]: "infinity" is kind of a red herring...
15:09:07 <EvanR> usually you aren't really interesting in counting things anyway
15:09:12 <EvanR> in calculus
15:10:06 <[exa]> hm
15:10:14 <[exa]> let's give it a try then
15:10:17 <EvanR> embedding shapes onto the computer screen for example
15:12:56 <refusenick> I suppose a finitist take on calculus (which I'm in no way qualified to talk about, like most other math things) might be to understand a limit as counting to an approximation as much as the situation demands, much like how bitmap images are fixed as an approximation at one scale, but SVGs can be scaled to various size approximations, with certain attendant restrictions.
15:13:39 <EvanR> see finitism-or-not is concerned with numbers and sizes of things, which is rarely the point of a given math theory
15:15:17 <refusenick> EvanR: Care to enlighten me? From what I've read so far (and, I'm aware, is acutely incomplete), much of applied math (insofar as goes deeper than engineering math) can be reduced to measure theory, which formalizes the size of things.
15:15:26 <EvanR> the closer your computer screen approximation gets to the "true answer", the less the difference matters. It's like the battle for finitism in this case becomes like a battle whose activity tends to zero as the approximation gets closer
15:15:58 <EvanR> measure theory is indeed about sizes as in lengths and volumes
15:16:17 <EvanR> not number of apples and oranges
15:16:33 <EvanR> or steps in your algorithm
15:17:12 <[exa]> ok well, let's try-- there's the weierstrass theorem (infinite bounded series has an infinitely populated interval of arbitrarily small size)
15:17:53 <[exa]> refusenick: this is the subresult you need for the larger bolzano-weierstrass theorem. Q: how do you encode it?
15:18:15 <refusenick> I haven't really started studying real analysis yet, tbqh
15:18:16 <EvanR> refusenick: there is the normal calculus vs constructive calculus, where instead of worrying about size of a set or infinite number of things, the concern is what kind of logic is used. 
15:18:46 <refusenick> That's why I'm asking for a book or guide using FP (or at least guiding me on how I might use it to assist proofs in my notes)
15:19:33 <EvanR> in constructive analysis for instance you can't do the bolzano weierstrass theorem, it's non constructive
15:20:00 <refusenick> It relies on proof by contradiction?
15:20:03 <EvanR> somehow i bet all this is relevant to wanting to "use math to do stuff on a computer"
15:20:30 <EvanR> law of excluded middle
15:20:55 <refusenick> Right, that's the thing finitists have a beef with.
15:21:23 <EvanR> really... well i still don't see how finitism is relevant
15:21:31 <EvanR> as i usually don't :)
15:24:26 <refusenick> Sometimes I wonder if my notion of math will stick out as I progress through a grad program and academia because my early exposure has been through a more computational, physicalist lense, as opposed to the philosophically-idealist "pure math" view espoused by the likes of Hardy and Erdos and most textbooks. Finitism seems like the only PoV I've seen so far which has any traction in math research and jives with doing math using
15:24:26 <refusenick> computers.
15:26:01 <refusenick> So, any textbook or resource which takes its views and runs with them, I believe, is liable to be easier to represent in Haskell or Agda. After all, FP is based on intuitionistic type theory, which has intutitionism in the name. :)
15:29:21 <EvanR> well, there is Software Foundations but it's in Coq
15:30:03 <EvanR> inexplicably, there is an Idris version 
15:30:19 <refusenick> I was considering it. Are Coq, Idris, Agda, etc eally that much more difficult than Haskell?
15:31:34 <EvanR> it funny, haskell is more difficult for the things Coq and Agda do
15:31:43 <EvanR> to the point of being impractical
15:32:02 <EvanR> so the question seems backwards
15:32:13 <refusenick> The complaints, then, are mostly about proof checkers for what Haskell is good at (practical programs)?
15:32:39 <EvanR> complaints?
15:33:20 <refusenick> I've seen a lot of people advise prospective users to not use proof checkers unless they're really set on it because they require too much writing, too much rigor.
15:33:43 <hpc> they're a specialized tool
15:34:04 <hpc> the way i would describe them, it's like when you're in an electrical engineering class and designing circuits that do things
15:34:14 <hpc> and so you have your breadboard and chips and wires
15:34:25 <hpc> or you can do it in a circuit design tool
15:34:28 <refusenick> I suppose that's because a lot of proof checking is oriented towards formal verification, where getting the assumptions right really matters (i.e. Space Shuttle code).
15:34:39 <hpc> but that tool might be overkill if all you're doing is running a digital display
15:35:08 <hpc> but using the design tool will probably still teach you things
15:35:49 <refusenick> hpc: an appreciation for how much more powerful the brain is than anything we can build?
15:36:36 <hpc> more like how to structure your thoughts
15:36:52 <hpc> a circuit design tool will probably have some notion of modules
15:37:40 <hpc> you make a small piece, it calculates the inputs/outputs in some way, and then the rest of the project is simpler to think about
15:37:57 <hpc> like how you have integrated circuits for all sorts of complicated things
15:38:14 <hpc> but having the tool makes you think about exactly what goes into that modularity
15:38:40 <refusenick> That seems like what I'm aiming for (using the computer to check parts of my work I'm not sure about). Maybe I will check out Coq.
15:38:47 <hpc> like every module has two wires for voltage, etc, etc
15:38:52 <Guest_21> how would I  add path for ghci
15:39:23 <hpc> a theorem proving tool teaches you how to think so you write good propositions, such that proving them is useful for the rest of your program
15:40:05 <crestfallen> https://paste.debian.net/1115978/  hi I was wondering under 'comments' why (return 'X') has that type on line 16, whereas in ghci the type is different (as shown on line 8).
15:40:23 <hpc> eventually you get in the habit of thinking that way outside the tool, which is sometimes as valuable as having the tool in the first place
15:40:55 <refusenick> Thanks for the tips. I just realized I need to get back to work.
15:42:18 <crestfallen> btw those comments are from haskellwiki
15:42:33 <ChaiTRex> crestfallen: It looks like you just filled in the m type variable from 8 with (State Int) down in 16.
15:43:21 <crestfallen> filled in? not sure I follow ChaiTRex 
15:43:46 <ChaiTRex> crestfallen: Yeah, Monad m => m Char can have m filled in with a monad.
15:43:59 <ChaiTRex> crestfallen: So, it could be used as Maybe Char, since Maybe is a monad.
15:44:08 <ChaiTRex> crestfallen: It could be IO Char, since IO is a monad.
15:44:18 <ChaiTRex> crestfallen: State Int appears to be a monad as well.
15:44:47 <ChaiTRex> crestfallen: So State Int Char is the same as Monad m => m Char with m filled in with (State Int).
15:46:18 <crestfallen> But isn't it that Int is the element type of the monad State? ChaiTRex 
15:47:17 <crestfallen> i.e. Int is separate from the type of Monad, State?
15:48:07 <ChaiTRex> crestfallen: No, State by itself isn't a monad.
15:49:34 <crestfallen> ok. so State needs to include something indicating change, in this case Int used as a counter. iiuc  ChaiTRex 
15:50:50 <ChaiTRex> crestfallen: The type right after State is kind of like further inside the monad than the type the monad stores in the normal sense.
15:51:12 <ChaiTRex> crestfallen: The type the monad stores in the normal sense is much more transitory.
15:51:45 <ChaiTRex> crestfallen: You have to use special commands to get the Int out.
15:52:01 <ChaiTRex> crestfallen: It's stuck deep in there.
15:52:26 <ChaiTRex> crestfallen: But there's also this temporary sort of value that it's storing in the normal sense, which is the second type after State
15:52:50 <ChaiTRex> crestfallen: Monads deal with the more temporary sort of value.
15:54:08 <crestfallen> thank you I will need to have that clarified I think
15:54:18 <ChaiTRex> crestfallen: It's like IO has special commands to get the time of day.
15:54:31 <ChaiTRex> crestfallen: But the type of IO isn't IO TimeOfDay or whatever.
15:54:42 <ChaiTRex> crestfallen: It's the immediate value you're working with.
15:55:09 <ChaiTRex> crestfallen: Similarly, State Int has a special command to get an Int stored inside of it back out, but that's not the immediate value you're working with, which is a Char.
15:57:49 <crestfallen> so can I say that a monad has metadata that makes it distinct from a functor? ChaiTRex 
16:00:23 <crestfallen> ie the time of day would be metadata that coincides with the counter changing from 1 to 2, perhaps
16:00:42 <ChaiTRex> crestfallen: Some do. IO can retrieve some extra data. Similarly, State Int can retrieve an Int.
16:01:07 <ChaiTRex> crestfallen: IO has a lot of things it can get, State Int tells you you can get an Int and that's it.
16:01:24 <koz_> It also tells you it won't query any databases, write any files, or rm -rf / you.
16:01:28 <ChaiTRex> crestfallen: But those are part of the monad type's m part, not its a.
16:01:35 <koz_> Once you have IO, you have _anything_.
16:05:56 <crestfallen> what won't query databases, you mean State Int right?
16:06:24 <crestfallen> koz_, ChaiTRex 
16:07:39 <ChaiTRex> crestfallen: Yes, that's right.
16:07:39 <koz_> crestfallen: Yes.
16:07:47 <koz_> If you have 'IO a', it can do basically whatever the hell.
16:08:00 <koz_> Query databases, rm -rf / your hard drive, launch nukes, etc etc etc.
16:08:26 <koz_> If you have 'State s a', you have access to some state of type s that you can modify or read and _nothing else_.
16:10:27 <crestfallen> thanks a lot. so if it's just an Int it's a counter, it couldn't be the result of function application
16:10:54 <koz_> crestfallen: I don't understand what you mean.
16:11:20 <koz_> If I have a State Int a, it describes a computation which produces an a, that, in its course, has access to a readable, modifiable Int value.
16:11:39 <koz_> State s a can be thought of as a way of saying s -> (a, s), or, in our case, Int -> (a, Int)
16:11:50 <koz_> Until you _provide_ an Int to 'get things going', it's just a function.
16:12:11 <crestfallen> state changes as the result of function application potentially, but isn't the result itself.
16:12:22 <koz_> crestfallen: It can be, depending on how you run it.
16:12:26 <koz_> :t runState
16:12:27 <lambdabot> State s a -> s -> (a, s)
16:12:30 <koz_> ^ produces both
16:12:32 <koz_> :t evalState
16:12:34 <lambdabot> State s a -> s -> a
16:12:39 <koz_> ^ produces only the 'result'
16:12:42 <koz_> :t execState
16:12:43 <lambdabot> State s a -> s -> s
16:12:48 <koz_> ^ produces only the 'final state'
16:13:29 <crestfallen> that's interesting, yeah I was thinking vaguely along the correct lines. thanks kindly koz_ ChaiTRex 
16:13:35 <koz_> crestfallen: No worries.
16:14:27 <koz_> :t even
16:14:28 <lambdabot> Integral a => a -> Bool
16:14:43 <Axman6> can you even?
16:15:29 <jle`> :t not . even
16:15:31 <lambdabot> Integral a => a -> Bool
16:18:18 <pie_> im jealous of people having actual teams to figure stuff out http://felixmulder.com/writing/2019/10/05/Haskell-in-Production.html
16:18:32 <pie_> bootstrapping by yourself is really hard :/
16:19:06 <ChaiTRex> crestfallen: You're welcome.
16:32:42 * hackage shake-ext 3.1.1.0 - Helper functions for linting with shake  https://hackage.haskell.org/package/shake-ext-3.1.1.0 (vmchale)
16:40:12 * hackage gdp 0.0.3.0 - Reason about invariants and preconditions with ghosts of departed proofs.  https://hackage.haskell.org/package/gdp-0.0.3.0 (mnoonan)
16:49:42 * hackage ats-pkg 3.3.0.5 - A build tool for ATS  https://hackage.haskell.org/package/ats-pkg-3.3.0.5 (vmchale)
16:50:54 <jackdk> lambdabot: that's odd
17:10:24 <jackdk> I have vague recollections about a project that let you write tests to ensure that rewrite rules fired. Was it a fever dream, or does someone else know what I'm talking about? My search-fu is failing.
17:10:55 <jusss> what is turing-complete?
17:14:30 <alexfmpe[m]> jackdk: maybe http://hackage.haskell.org/package/inspection-testing ?
17:16:06 <jackdk> potentially... I'll have a dig, thanks alexfmpe[m] 
17:26:51 <crestfallen> one more thing about this paste: what is Primitives referring to on line 12 ? I read about primitives in ghci docs but they are beyond me   https://paste.debian.net/1115978/ 
17:29:12 <Lycurgus> primitives, in this case, are irreducible actions defined in terms of other irreducible actions
17:29:51 <Lycurgus> in a more legitimate case the distinction would be clearer
17:30:24 <Lycurgus> eg, the ghci machine defined in terms of llvm code
17:31:45 <electricityZZZZ> so what does it mean for software to be "written in" a language
17:31:54 <Lycurgus> the root analogy is real machine instruction sets which are defined in terms of bit ops on a (typically) von neuman machine
17:32:17 <crestfallen> Lycurgus, beyond me.. sorry
17:32:28 <Lycurgus> i.e. circuits implementing those bit ops
17:33:32 <Lycurgus> it's also a sneering epithet used by the Emperor in the Empire Strikes Back
17:34:13 <Lycurgus> 'primitves on the forest moon of Endor'
17:36:24 <Lycurgus> *ghc
17:57:43 <refusenick> I don't understand from the Stack docs - how do I upgrade all of my extra-deps to their latest versions?
17:59:52 <MarcelineVQ> type in the versions you want, or delete them entirely and stack will reccomend the latest versions that work with your other dependencies in your snapshot
18:01:55 <refusenick> The docs say "stack remove" is deprecated. What do?
18:02:17 <MarcelineVQ> dunno never heard of it
18:02:28 <refusenick> err, "uninstall" is deprecated.
18:03:08 <refusenick> is https://stackoverflow.com/questions/38636436/how-to-uninstall-a-haskell-package-installed-with-stack still current?
18:05:57 <MarcelineVQ> seems suspect, you shouldn't need to mess with ghc-pkg. rather if you want a specific thing gone you'd go to ~/.stack/snapshots and find the thing you want to get rid of
18:06:47 <refusenick> just "rm" it?
18:07:21 <MarcelineVQ> If you need it gone yeah, is there a reason you want to do that aside from saving space?
18:07:40 <refusenick> I want to update some packages to the latest version in extra-deps
18:07:51 <refusenick> I'm new to Haskell.
18:08:03 <MarcelineVQ> rming installed things won't be related to that
18:08:27 <refusenick> Then how do I delete the package and reinstall its latest version?
18:08:43 <MarcelineVQ> If you want the latest versions in your extra-deps, you'd type the version number of the latest version in your extra-deps
18:08:59 <refusenick> It says not to edit the global stack.yaml though, doesn't it?
18:09:32 <refusenick> Maybe it's b/c I'm using DuckDuckGo, but I'm not finding the full extra-deps documentation online.
18:10:17 <siraben> Why is it a parse error to declare the fixity of (:)? How is it done in Base?
18:10:40 <siraben> "infixr 5 : , ++" is invalid, for instance, but "infixr ++" is valid
18:11:51 <MarcelineVQ> afaik : [] , are wired in so you can't use their syntax
18:12:38 <siraben> Aww
18:12:59 <siraben> By the way, anyone else reading Ben Lynn's blog posts on writing a functional compiler for Haskell? https://crypto.stanford.edu/~blynn/compiler/grind.html it's very informative
18:13:01 <MarcelineVQ> refusenic: if something you want to to needs extra-deps you're typically meant to make a project and add it to that project's stack.yaml
18:13:46 <siraben> The Haskell combinatory compiler won the IOCCC this year O.O https://www.ioccc.org/2019/lynn/hint.html
18:18:29 <MarcelineVQ> refusenick: this is important documentation https://docs.haskellstack.org/en/stable/stack_yaml_vs_cabal_package_file/
18:19:08 <MarcelineVQ> since it explains why even extra-deps is a thing
18:20:16 <refusenick> MarcelineVQ: I don't quite understand why copies of packages and even GHC itself need to be continuously reinstalled. I get that it's for reproducibility, but isn't being putatively purely functional (or at least aiming to reduce hidden state) supposed to be a way around having to copy things for every possible change? Shouldn't Haskell be reproducible without that?
18:20:31 <sm[m]> refusenick: it's normal to have more than one version of haskell packages installed, you don't usually need to delete them. Just specify the version you want and build again
18:20:34 <MarcelineVQ> They're not reinstalled if they're the same versions
18:22:50 <refusenick> I tried to "stack install futhark", and it failed with 2 missing deps. One was that "base" has to be 4.13.0 or higher (the highest version in Hackage atm is 4.12.0, so I'm tabling that for now). The interesting error is that "containers" has to be "0.6.2.1", but it says I have "0.6.0.1". I installed 0.6.2.1, but "stack install futhark" still lists both missing dependencies.
18:23:31 <refusenick> Is that supposed to happen? I feel like I'm missing something.
18:24:49 <sm[m]> refusenick: it's not unusual for the output to be confusing.. maybe you can paste the whole thing, and your stack.yaml and package.yaml or cabal file
18:25:39 <MarcelineVQ> there is a base-4.13 but it hasn't been put on hackage for some reason, but the latest ghc will have it regardless
18:25:55 <refusenick> futhark install error: https://0x0.st/zEG4.txt
18:26:28 <MarcelineVQ> still that that version of ghc won't be available on a stack snapshot so you'll want to specify an older futhark
18:26:57 <MarcelineVQ> before that though if you're going to play with futhark I'd make a project to do it in
18:27:11 <sm[m]> is this with latest futhark master ?
18:27:18 <monochrom> base is a special case. To use a different version of base, you have to switch GHC version altogether, not try to "install base"
18:27:22 <MarcelineVQ> sm[m]: futhark on hackage
18:28:05 <refusenick> My global project config is the default, except for that I've specified to use the system GHC install for everything.
18:28:09 <MarcelineVQ> stack install isn't really the way to go in the first place for playing around:  "Understanding stack’s model and avoiding its biggest gotcha" lexi-lambda.github.io/blog/2018/02/10/an-opinionated-guide-to-haskell-in-2018/
18:28:39 <sm[m]> refusenick is talking about a stack.yaml.. did that come from the tarball on hackage (stack unpack ?) or a git clone ?
18:29:56 <refusenick> I just ran "stack install foo" for several projects in ~
18:30:25 <sm[m]> maybe they are just doing "cd; stack install futhark-0.12.3 --dry-run". "stack install futhark-0.12.3 --resolver nightly-2019-11-08 --dry-run" may work better
18:31:15 <refusenick> Why is that different from setting up a project and doing x and y and z and praying to the rain god for a good harvest? Why is the obvious default broken? Where are the comprehensive guides like Lexi Lambda's?
18:31:46 <MarcelineVQ> Well the only part of that guide that matters here is that one section
18:32:06 <refusenick> Sorry if this seems whiny, but I just want to jot down a few ideas and experiment in the REPL, not build the next Facebook.
18:33:11 * hackage rainbow 0.32.0.0 - Print text to terminal with colors and effects  https://hackage.haskell.org/package/rainbow-0.32.0.0 (OmariNorman)
18:33:23 <sm[m]> refusenick: I feel your pain. Still, this is a very complex situation and stack can't do magic. It promises to install packages from a well-tested compatible set - a stackage snapshot. In your case, the one you have configured in ~/.stack/global-project/stack.yaml. You're asking it to install a bleeding edge package that isn't in that snapshot. 
18:34:05 <sm[m]> in such cases, it's a good idea to check the stack.yaml in the project's git repo, and try the newer snapshot they have configured there
18:34:49 <sm[m]> hence the --resolver nightly-2019-11-08. It still might screw up, but that's how I'd think about it
18:35:02 <refusenick> I barely even know how git works...
18:35:41 <sm[m]> ok, or you ask here, and I've given you the command, go for it :)
18:36:21 <sm[m]> what even is "futhark"
18:36:37 <MarcelineVQ> Athas's gpu dsl
18:36:42 <refusenick> It's a functional, parallel array programming language for GPUs
18:36:50 <quiet_laika[m]> futhark is a functional GPU programming language
18:36:51 <quiet_laika[m]> oh
18:37:12 <refusenick> think APL + ML type system
18:37:26 <refusenick> Is APL more obscure than Futhark by now?
18:37:31 <monochrom> Problem with stack is if a package is not on stackage then you have to do some manual setting and deviate from "default"s and suddenly "works out of the box" is false.
18:37:43 <monochrom> Or even s/package/version/
18:37:52 <MarcelineVQ> if you want to pop right into ghci you can write:  stack --resolver=nightly-2019-11-08 ghci --package futhark  but you should learn projects asap. it's really as simple as stack new myproject and edit the cabal file and stack.yaml
18:37:58 <monochrom> stackage :: iPhone app store
18:38:14 <refusenick> I don't have an iPhone
18:38:22 <sm[m]> stack doesn't claim to install any hackage release "out of the box", the whole point is not to attempt that
18:38:37 <refusenick> Is there a tool to do that?
18:38:50 <monochrom> Right, on your phone you're missing out all the walled-garden restrictions that stack offers!
18:39:22 <refusenick> Should I be using Cabal if I don't care about rockhard consistency and plan to use Haskell for small projects for the most part?
18:39:29 <monochrom> Yes!
18:39:33 <sm[m]> refusenick: cabal does that by default. stack does it if you ask it to. In both cases it may not "just work", because your package maintainers may not have ensured that
18:39:54 <monochrom> In fact in small cases use GHC directly, skip even cabal.
18:40:07 <sm[m]> No! :)
18:42:56 <refusenick> Is there a full guide to Stack? The docs sometimes tell you to just look at the output of a command-line flag (e.g. "stack build --help" covers more than the docs). I'm willing to sit down and read if it means I'll come out being capable (not having to look up every command every time).
18:43:04 <sm[m]> for example, here stack install futhark-0.12.3 --resolver nightly finds an install plan, but cabal new-install futhark-0.12.3 doesn't
18:43:31 <vimto> \exit
18:43:44 <refusenick> ah, "--resolver nightly" is the flag I want if I want to live dangerously, isn't it?
18:43:56 <sm[m]> yep
18:44:15 <refusenick> That's all I need!
18:44:19 <sm[m]> and also do "stack update" occasionally to know about even newer things on hackage
18:44:33 <sm[m]> ha
18:44:36 <monochrom> hackage? stackage?
18:44:47 <refusenick> Already thinking of making a cron job to run "stack update"!
18:45:08 <sm[m]> https://docs.haskellstack.org is the stack guide. The information is in there, even though not well organised
18:45:22 <refusenick> You can say that again...
18:50:52 <refusenick> For what it's worth, I had similar problems with Python's dependency management until I discovered Pipenv and its excellent Emacs frontend.
18:51:52 <refusenick> Is there anything like that for Haskell? I tried Intero in the past, but it was always very slow (even after the 1st install and run, which froze Emacs for a while) and its maintainer just declared last week that he's done with it.
18:54:22 <ysangkok> i don't think it is like pipenv, but i am going to try out haskell.nix after seeing that talk from NixCon
18:55:01 <ysangkok> i wonder if it works well with https://github.com/target/lorri
19:01:56 <dmj`> no geekosaur today?
19:01:59 <dmj`> :(
19:29:46 <iqubic> Is geekosaur gone?
19:30:30 <maerwald> maybe just offline xD
19:31:31 <monochrom> That's how rumour start.
19:34:48 * MarcelineVQ starts a rumor that geekosaur is offline.
19:35:20 <Axman6> Rawr in Peace geekosaur
19:37:46 <maerwald> internet citizens freaking out when someone is offline :>
19:40:36 <int-e> maerwald: it's a critical life support system after all
19:42:39 <int-e> I'm also tempted to do an s/wrong/gone/ in https://xkcd.com/386/
20:58:16 <dsal> Is there an extension that spells * differently?
20:58:31 <Axman6> TypeIsType?
20:58:35 <Axman6> somethin glike that
20:58:38 <MarcelineVQ> iirc StarIsType NoStarIsType
20:59:25 <MarcelineVQ> that might just be how its used :X you can import Data.Kind to get Type
21:04:19 <dsal> Hmm...  I tried a few things and it doesn't do what I expect.  My God, it's full of stars.
21:04:26 <monochrom> TypeIsType doesn't change spelling.
21:04:29 <dsal> % :kind Functor
21:04:30 <yahb> dsal: Functor :: (* -> *) -> Constraint
21:04:56 <monochrom> There are only two spellings, "*" and "Type".  And "*" can be turned off but default is on.
21:05:20 <monochrom> And "Type" doesn't need an extension, instead you can refuse to import it.
21:05:57 <dsal> Can I make the above say Type instead of *?
21:06:01 <monochrom> Err, s/TypeIsType/TypeInType/
21:06:12 <monochrom> I forgot.
21:06:12 <dsal> I'm trying to explain this to a friend and it's a little annoying to see * all the time.
21:07:07 <monochrom> But the GHC user's guide has all flags.
21:07:37 <monochrom> How ghci prints things is going to be a ghci flag not a language extension or pragma.
21:11:58 <EvanR> though ghc error message formatting comes up a lot in extension spec
21:12:11 <EvanR> which i presume ghci forwards
21:18:28 <jusss> how to do "SELECT * FROM person" in persistent? I saw there're `selectList' `selectSource' on http://hackage.haskell.org/package/persistent-2.10.4/docs/Database-Persist-Class.html
21:18:39 <jusss> but I'm not sure which can use for tables?
21:19:29 <jusss> there's also `get' but that need the Id which is returnd by `insert'
21:22:19 <EvanR> selectSource or selectList ?
21:23:37 <jusss> EvanR: I don't which can work on tables
21:24:08 <jusss> EvanR: there also are selectKeys and selectKeysList
21:24:25 <EvanR> no verb found
21:24:50 <jusss> I wonder so does the term 'table' exist in persistent?
21:25:33 <EvanR> selectList probably
21:26:28 <jusss> EvanR: I don't see any related to 'table' in `selectList'
21:27:24 <EvanR> how many arguments do you think selectLis has
21:28:25 <jusss> it's two list
21:28:27 <jusss> lists
21:29:03 <EvanR> i think there are 5
21:29:16 <EvanR> just to be instructive on future confusions
21:30:21 <jusss>    oneJohnPost <- selectList [BlogPostAuthorId ==. johnId] [LimitTo 1]
21:30:31 <jusss> BlogPost is the table name
21:30:40 <EvanR> actually, 8
21:30:54 <EvanR> right
21:31:11 <jusss> it combin the table's name with it's tag
21:31:23 <EvanR> you put in a filter 
21:31:30 <jusss> I see
21:31:34 <EvanR> to get all rows, you need to not use a filter
21:31:53 <jusss> EvanR: is this TH stuff?
21:32:13 <EvanR> did you use TH anywhere?
21:32:22 <EvanR> if not then no
21:32:36 <jusss> {-# LANGUAGE TemplateHaskell            #-}
21:32:45 <jusss> this is from yesod-persistent
21:32:56 <EvanR> ok... did you do $(...) or [qq|...] 
21:33:25 <jusss> share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase|...|]
21:33:41 <EvanR> looks like it
21:34:08 <jusss> EvanR: TH is just an extension or a new language?
21:34:19 <EvanR> anyway, selectList has basically 8 arguments. 3 types, 3 instances, and 2 values
21:34:42 <EvanR> the functionality you get depends on all of them
21:35:41 <jusss> Filter has 4, SelectOpt has 4
21:35:48 <EvanR> the table you are wondering about is probably tied up in one of the instance arguments
22:18:30 <jusss> there's [Entity {entityKey = Emp2Key {unEmp2Key = SqlBackendKey {unSqlBackendKey = 1}}, entityVal = Emp2 {emp2Name = "Joe MacMillan", emp2Age = Just 42}}]    how I can get emp2Age?
22:19:13 <jusss> let's assume that whole [...] as whatever
22:20:58 <EvanR> you... want the emp2Age from the first item or
22:21:18 <EvanR> list of all emp2Age from all results or
22:23:10 <jusss> EvanR: all
22:23:50 <jusss> this is record syntax, righ? 
22:23:55 <EvanR> oh... then can't you just map (emp2Age . entityVal)
22:24:25 <jusss> ok, I will try it
22:24:30 <EvanR> fields generate accessors of the same name
22:24:34 <EvanR> which are just functions
22:25:21 <jusss> EvanR: you're right!
22:31:20 <jusss> EvanR: https://hackage.haskell.org/package/persistent-2.10.4/docs/Database-Persist-Class.html#v:selectList      this result has ReaderT backend m [Entity record],  how I can get [Entity record] ?
22:31:31 <jusss> use runReader?
22:32:06 <EvanR> you mean runReaderT. But this type suggests that you are probably using it within a larger ReaderT backend m action
22:32:48 <jusss> EvanR: where or how I can get this action
22:33:30 <EvanR> how to get the larger action, many ways. How to get *some* action, selectList [...] [...] *is* that action
22:34:07 <jusss> name <- selectList [] [] 
22:34:23 <EvanR> ok, what monad is that 
22:34:28 <jusss> this `name' :: ReaderT backend m [Entity record]
22:34:36 <EvanR> i mean, what is m
22:34:48 <jusss> IO 
22:35:18 <jusss> it's in `main' and it use liftIO to every value, so this m is IO I assume
22:35:39 <EvanR> :t runReaderT
22:35:41 <lambdabot> ReaderT r m a -> r -> m a
22:35:58 <jusss> give it the r
22:36:12 <EvanR> when you write name <- selectList [] [] and more code, name has type [Entity record], it's not an action
22:36:14 <jusss> give this `name' (_::r)
22:36:27 <EvanR> that's basic do-notation facts
22:36:41 <jusss> oh I forget
22:36:54 <EvanR> r is the backend
22:37:12 <jusss> EvanR: what this value form like ReaderT r m a?
22:37:31 <jusss> value form I mean like Just Int,
22:37:32 <EvanR> it's a type
22:37:47 <jusss> what you call Just Int?
22:37:53 <EvanR> a value
22:37:57 <EvanR> what no
22:38:01 <EvanR> Just Int is an error
22:38:07 <EvanR> Maybe Int is a type
22:38:14 <Axman6> Maybe Int or Just 1
22:38:28 <jusss> EvanR: but you have `data Maybe Int = Just Int | Nothing'
22:38:29 <jusss> right?
22:38:37 <Axman6> Just 1 :: Maybe Int
22:38:45 <Axman6> not really
22:38:45 <EvanR> nope
22:38:55 <EvanR> data Maybe a where
22:38:57 <Axman6> daya Maybe a = Just a | Nothing
22:39:01 <EvanR>   Just :: a -> Maybe a
22:39:05 <EvanR>   Nothing :: Maybe a
22:39:10 <Axman6> you can have a value of Maybe Int, such as Just 1 or Nothing
22:39:25 <jusss> so this `data Maybe Int = Just Int | Nothing' is wrong?
22:39:31 <EvanR> data Maybe a = Just a | Nothing is shorthand and can be confusing
22:39:34 <Axman6> c..c..combo breaker - sorry :)
22:39:44 <EvanR> yeah that's wrong
22:40:18 <jusss> fine, what I want to say, it's just a form for value
22:40:38 <EvanR> what is?
22:40:59 <EvanR> Just Int is not valid
22:41:15 <EvanR> it can't decide if it's a type a value or something else
22:41:21 <jusss> I know, so I say `assume'
22:42:01 <EvanR> i can't imagine trying to use persistent without having these basics straight... yet you seem to be doing it
22:42:02 <jusss> maybe I should say Just (_::Int)
22:42:09 <jusss> ok?
22:42:14 <jusss> Just (_::String)
22:43:01 <EvanR> perhaps you'd enjoy Just @String
22:43:12 <EvanR> % :t Just @String
22:43:12 <yahb> EvanR: String -> Maybe String
22:43:55 <EvanR> (Just really has 2 arguments, 1 type and 1 value (of that type). @String is providing that first argument)
22:44:37 <jusss> EvanR : x :: ReaderT backend m [Entity record],  what x would be ? use that Just @String form
22:44:45 <jusss> m is IO
22:46:00 <jusss> @IO @Reader backend [Entity record] ?
22:46:00 <lambdabot> Maybe you meant: wn v rc pl id do bf @ ? .
22:46:16 <ammar2> o_O
22:46:16 <EvanR> we have a language problem
22:46:31 <EvanR> "what is x"  vs "what is x a"
22:46:46 <EvanR> x is a ReaderT backend IO [Entity record], as you say
22:46:56 <jusss> EvanR: x has
22:47:01 <jusss> not is
22:47:02 <EvanR> x is ... namely, we have no idea yet. We only know the type
22:47:09 <jusss> sorry, x is a value, not a type
22:47:22 <EvanR> correct
22:47:26 <EvanR> that is not ambiguous
22:47:55 <EvanR> but to ask "what would x be" leaves it open. What is x's type, or what is x's value
22:48:18 <EvanR> or perhaps it's asking something else about x
22:48:27 <dminuoso> jusss: I like to think of `ReaderT Env IO` as being essentially the same as just raw IO. So `x :: IO A` is some IO action. :)
22:48:56 <EvanR> ReaderT Env IO a is essentially Env -> IO a
22:50:16 <dminuoso> jusss: And equivalently `x :: ReaderT Env IO T` is just some IO action (which has access to some environment - and by environment we mean a sort of global variable of sorts)
22:52:10 <jusss> name <- selectList [] [],  not matter what m is, we can get `name ::  Reader backend  [Entity record]' right?
22:52:24 <dminuoso> jusss: No.
22:52:25 <EvanR> ReaderT backend m [Entity record] ?
22:52:41 <jusss> selectList [] [] :: ReaderT backend m [Entity record]
22:52:43 <EvanR> you also have to have support for m
22:52:50 <EvanR> it needs to be MonadIO
22:53:07 <EvanR> backend and record have to have correponding instances and other things
22:53:39 <jusss> this ReaderT is so difficult to me ...
22:54:00 <dminuoso> jusss: Imagine you have some data type representing your program config.
22:54:05 <dminuoso> jusss: data Config = Config { ... }
22:54:06 <EvanR> if you have all that, and the backend itself, then runReaderT (selectList [] []) myBackend would have type m [Entity record]
22:54:37 <dminuoso> jusss: Concretely, `data Config = Config { cfgDatabaseHost :: String, cfgDatabasePort :: Int, cfgVerbosity }`
22:54:44 <dminuoso> jusss: Concretely, `data Config = Config { cfgDatabaseHost :: String, cfgDatabasePort :: Int, cfgVerbosity :: Int }`
22:55:30 <dminuoso> jusss: Now, its a common idiom to not write your program in `IO`, but in `ReaderT Config IO` instead. The difference between `IO` and `ReaderT Config IO` is that the latter has *access* to some config file that is provided at the entry of your program.
22:56:00 <dminuoso> jusss: Does that make any sense?
22:56:51 <EvanR> protip, learn ReaderT (and just Reader for that matter) separately. Persistent can't be helping this
22:56:55 <jackdk> Anyone here good at rewrite rules? I'm trying to specialise with them and can't make it fire:  https://www.irccloud.com/pastebin/6f0on7KH/rewrites.md
22:57:11 <dminuoso> So now any part of your program has access to the database configuration and the logging verbosity. ReaderT is mainly useful when every (or most) parts of your program need a sort of "config/environment" parameter, and you are tired of explicitly passing it aroud.
22:57:58 <EvanR> > runReaderT (asks snd) ("foo", 9) :: Identity Int
22:57:59 <lambdabot>  Identity 9
22:58:09 <EvanR> > runReaderT (asks snd) ("foo", 9) :: Maybe Int
22:58:10 <lambdabot>  Just 9
22:58:21 <EvanR> > runReaderT (asks snd) ("foo", 9) :: [Int]
22:58:23 <lambdabot>  [9]
22:59:28 <EvanR> > runReaderT (asks snd) ("foo", 9) :: IO Int
22:59:30 <lambdabot>  <IO Int>
22:59:34 <jusss> dminuoso: did you miss `a' in ReaderT IO Config?
22:59:42 <dminuoso> jusss: Nope.
22:59:45 <jusss> ReaderT Config IO
22:59:53 <dminuoso> jusss: But if you prefer you can add some type to both `IO` and `ReaderT Config IO`
23:00:00 <dminuoso> Say `IO Int` and `ReaderT Config IO Int`
23:00:28 <jusss> ReaderT Config IO Int is fine to me
23:00:41 <dminuoso> jusss: Im intentionally leaving the final argument away because its irrelevant.
23:00:41 <jusss> the type and the value
23:00:53 <dminuoso> `ReaderT Config IO` is a monad just like `IO` is.
23:01:16 <monochrom> Right, "Maybe Int" is not the monad, "Maybe" is.
23:02:23 <jusss> I always think the type and the value like this, Just Int has Maybe Int, and Just Int is Just 3, Just 5,  and ReaderT Config IO a should have a value like IO Reader Config a, 
23:02:37 <jusss> I know this IO Reader Config a is not a type neither a value
23:02:53 <jusss> but the value has this form, just replace the type with value
23:02:59 <EvanR> Just 3 :: Maybe Int
23:03:03 <EvanR> no Just Int
23:03:21 <monochrom> "IO Reader Config a" is very messed up.
23:03:39 <jusss> same as `Just Int'
23:03:47 <dminuoso> jusss: `Just Int` is nonsense. :)
23:03:48 <jusss> but it's very intuitive
23:03:57 <jusss> what its value should like
23:04:02 <EvanR> IO Reader Config a doesn't even match Just Int
23:04:07 <monochrom> The flawed assumption that every type is a concrete type and its values all writable with data constructor.
23:04:10 <dminuoso> jusss: Then write `Just (x :: Int)` if you want.
23:04:10 <EvanR> it seems random
23:04:13 <dminuoso> jusss: That would be a valid thing to do.
23:04:19 <dminuoso> jusss: But `Just Int` is just gibberish.
23:04:35 <dminuoso> jusss: If all you want to denote that `Just` is applied to some value of type Int, write it as `Just (x :: Int)`
23:04:36 <monochrom> IO is an abstract type, no data constructor for you.  ReaderT is also best used as an abstract type even though it's concrete.
23:05:00 <int-e> jackdk: did you try using the rules without type signature for m?
23:05:35 <EvanR> IO :: Type -> Type
23:05:40 <EvanR> Maybe :: Type -> Type
23:05:44 <EvanR> Just :: a -> Maybe a
23:05:46 <monochrom> In other words I'm not even talking about what does "IO Reader Config a" mean, I'm talking about the wrong spirit behind it, that you always assume you can use data constructors.
23:05:51 <EvanR> Int :: Type
23:06:03 <EvanR> 1 :: Int
23:06:05 <monochrom> There is not going to be any analogy for "Just 3 :: Maybe Int" for IO.
23:06:12 <EvanR> amen
23:06:20 <jackdk> int-e: if I remove the typesig on `m` I get errors about not having `Ord k`
23:06:33 <monochrom> You write like "getLine >>= putStrLn" or you get no IO.
23:07:46 <dminuoso> 08:02:33       jusss | but the value has this form, just replace the type with value
23:07:55 <dminuoso> ^- what monochrom juts said. :)
23:08:27 <jusss> (_ :: IO a) (x :: Reader Config a)
23:08:42 <monochrom> That's nonsense.
23:08:43 <EvanR> if people can just use persistent, but the nuts and bolts of haskell are this hard, i'm impressed
23:09:04 <Arahael> Why do I have to explicitly list every file in other-modules in the cabal file? Why isn't hs-source-dirs sufficient?
23:09:10 <Arahael> Particularly for an executable.
23:09:42 <sclv> because its a package manifest
23:09:58 <sclv> its not just a "build config"
23:10:18 <sclv> its all the info necessary to prepare a package for distribution
23:10:20 <dminuoso> sclv: One could argue that cabal could derive the package manifest from what it sees.
23:10:35 <dminuoso> I think the question itself is valid.
23:10:50 <monochrom> But I argue that I want to put junk files in hs-source-dirs that should not be picked up. >:)
23:10:55 <Arahael> Indeed.  1) I am not developing a "package", I only care that I end up with an *executable*., and 2) What dminuoso said - hpack does it, why not cabal?
23:12:24 <sclv> one could argue many things, but i'm answering the question as given
23:12:39 <sclv> there's a ticket for cabal to figure out how to do this stuff somewhere
23:12:42 <sclv> people aren't opposed to it
23:12:51 <sclv> but they do want a way to ensure cabal files are sufficient to be manifests
23:13:29 <sclv> if you're not developing a package, you arguably don't need to use cabal files. you can just use ghc directly, or use ghc + cabal to gin up a package environment
23:13:40 <monochrom> Makes you wonder how many "why" questions are literal, how many are disguised rhetorical questions.
23:13:41 <sclv> cabal is a tool for developing haskell packages
23:13:44 <sclv> that's the unit we think in
23:14:30 <Arahael> sclv: How would I do this without cabal!? I thought cabal was basically required?
23:14:46 <monochrom> "why the hell am I not going to bed?" really means I'm taking a stance against not going to sleep, totally not an expression of curiosity.
23:14:50 <Arahael> I've a dozen dependencies. How do I manage and install those dependencies in a sane manner?
23:14:50 <jle`> jusss: not all data types have 'constructors' that characterize that type
23:15:06 <jle`> jusss: a simple counter-example is something like `Int -> Bool`
23:15:10 <jle`> there is no `IntToBool 3`
23:15:41 <dminuoso> Arahael: Well you could use cabal to generate a ghc environment file for you.
23:15:41 <EvanR> (arguably.. is Int -> Bool even a 'data type')
23:16:13 <EvanR> (if so is it an algebraic data type)
23:16:16 <sclv> here is the ticket: https://github.com/haskell/cabal/issues/5343
23:16:21 <dminuoso> It begs the question of what we define "data type" to even mean.
23:16:22 <jle`> EvanR: maybe i should say 'type', then :p
23:16:30 <jle`> to remove the ambiguity
23:16:36 <sclv> new cabal contributors always welcome!
23:16:40 <Arahael> dminuoso: Have we gone in circles in the discussion, or are we confusing cabal-the-tool, vs cabal-the-library, vs cabal-the-configuration file or something?
23:17:00 <sclv> cabal-the-tool can generate environments so that you don't need to build them with cabal manafests
23:17:14 <sclv> its not perfect for it yet
23:17:18 <jle`> jusss: another common abstract type is Map, from Data.Map
23:17:20 <sclv> https://github.com/phadej/cabal-env is a stab at how that will develop
23:17:42 <sclv> the ticket i linked is the other way forward, to allow some sort of expansion while preserving the manifest property for people that want it
23:17:42 <jle`> jusss: you can make a map using functions like M.singleton, M.fromList, M.insert, etc.; there's even M.empty, the empty map
23:17:51 <jle`> jusss: but there is no `Map 3 5` constructor or data type form
23:18:03 <dminuoso> Arahael: ever seen the `.ghc.environment...` files cabal v2-* generates in your project directories by default?
23:18:15 <Arahael> dminuoso: Nope.
23:18:22 <maerwald> Arahael: "Why do I have to explicitly list every file in other-modules in the cabal file?" -- simple, because otherwise the .cabal file would not be complete static information anymore and you'd have to unpack the entire tarball and inspect files to do any kind of analysis
23:18:32 <Arahael> maerwald: What tarball?
23:18:41 <jle`> oh monochrom already said this exact thing
23:18:43 <Arahael> maerwald: (Remember: I'm very firmly in the "I am building an executable" mindset.
23:18:53 <maerwald> Arahael: the hackage tarball (or the repository)
23:19:08 <Arahael> maerwald: But I'm not building hackage as an executable!
23:19:08 <maerwald> it is good that the source files are not determined dynamically
23:19:28 <maerwald> I'm only replying to your question, not to you building an executable
23:19:57 <monochrom> See? "why" seldom really means "why".
23:20:08 <Arahael> maerwald: Ah, yeah - I can understand this for libraries and packages, etc. I just don't understand why I have to list every file explicitly when writing a hello-world app that just happens to be spread across two or more files.
23:20:27 <monochrom> More often it expresses disinterest and indifference.
23:20:34 <maerwald> monochrom: this request pops up a lot though where people want hpack-like functionanlity (or really remove static information)
23:20:44 <maerwald> static information is good 
23:20:48 <Arahael> sclv: (That #5343 is exactly what I'm after - looks good there. :) )
23:21:26 <jusss> jle`: ok, I build on the worng intuition
23:21:45 <maerwald> imagine: you want to analyse ALL packages of hackage... what do you have to do now? download all .cabal files (which is reasonable)
23:21:48 <dminuoso> Amongst some things, build-depends causes cabal to fetch dependencies, build them, install them, register them in a package db - and then a .ghc.environment file is created that is essentially configuration for ghc to select package databases and packages.
23:21:52 <maerwald> otherwise you'd have to unpack everything...
23:21:54 <jle`> jusss: in general for abstract data types you should think of them as black boxes that export an API, a bunch of functions you can use to manipulate them
23:21:57 <dminuoso> Arahael: ^- and that's what gives you a sort of package environment.
23:22:12 <jle`> jusss: not that they are 'constructed', but rather that they are things that 'mean' something
23:22:27 <Arahael> maerwald: That's not the scenario I'm dealing with, though. The scenario is this: All the files in src/ should be built into the executable, along with whatever dependencies which are explicitly defined in the cabal file.
23:22:27 <jle`> and you have functions that manipulate meanings of inputs
23:22:33 <jusss> :t putStrLn
23:22:34 <lambdabot> String -> IO ()
23:22:45 <jusss> :t main
23:22:47 <lambdabot> error:
23:22:47 <lambdabot>     • Variable not in scope: main
23:22:47 <lambdabot>     • Perhaps you meant ‘min’ (imported from Data.Ord)
23:22:54 <monochrom> <Q> Why does the law require wearing seat belts?  <A> Because it is safer.  <Q> But I don't want safety! Tell me what's in it for what I want!  <A> I was just answering the "why" question!
23:23:09 <dminuoso> monochrom: I think we can stop riding on this. :p
23:23:22 <Arahael> Hmm, perhaps I should subtly change my question.
23:23:33 <jle`> jusss: for example if we're looking at natural numbers, maybe a natural number could represent something like, how many cats i have
23:23:42 <jle`> jusss: and now we have an operation (+), which takes two numbers and returns a new one
23:23:50 <jle`> and its 'meaning' is that it sums the two sides together
23:23:52 <EvanR> (my program is spread over several files and I am not listing them individually in package.yaml. But I'm using stack build)
23:23:58 <Arahael> Why do we need to specify each file for an executable? In what scenarios would we have a difference in behaviour where each file was not explicitly specified?
23:24:02 <jle`> jusss: so n + m's result is the sum of n and m.
23:24:23 <jle`> jusss: if n is some amount of cats owned, and m is some amount of cats owned, then n + m would represent owning the cats in both sets
23:24:35 <maerwald> monochrom: I think it's a good exercise for the questioner to start formulating proper questions :P
23:24:45 <jle`> jusss: we give meaning to the values we have, and then we manipulate those meanings using functions that the type provides us
23:24:46 <Arahael> EvanR: I only noticed this in very recent stack, actually, because recent cabal's have enabled this warning.  Even then, it only happens if you aren't using hpack, and many stack templates use hpack.
23:24:51 <maerwald> in addition to getting free information
23:25:02 <dminuoso> maerwald: I dont think being overly pedantic is helpful. At the end we are humans and natural languages are very ambiguous.
23:25:28 <Arahael> In any case, I hope my reworded question is more precise. :)
23:25:50 <dminuoso> maerwald: I think it was obvious what Arahael was wondering about. :)
23:25:54 <EvanR> .oO( if n is cats owned here and m is cats owned there then n + m = cats owned here + cats owned there :)
23:25:58 <jusss> `data Maybe a = Just a | Nothing' , you should use `data Maybe a = Just 'a | Nothing'  
23:26:05 <jusss> 'a :: a
23:26:32 <EvanR> jusss: use GADT syntax to avoid the issues with that notation
23:26:52 <jle`> yeah admittedly the normal ADT notation is kind of confusing
23:27:12 <jle`> who thought of it anyway
23:27:31 <dminuoso> Arahael: I think https://github.com/haskell/cabal/issues/5343#issuecomment-521590517 might give a pointer as to why.
23:28:02 <monochrom> Dates back to ML.
23:28:06 <sclv> ok so the scenario is that often people have a bunch of junk files along with the files they mean to use and those will get compiled too
23:28:12 <sclv> even if they don't get linked in
23:28:29 <jle`> Arahael: if the point of a cabal file was to be a build system, like make or something, then yeah, listing directories and stuff should be ok
23:28:29 <EvanR> data Maybe :: Type -> Type where
23:28:34 <EvanR>   Just :: a -> Maybe a
23:28:38 <Arahael> dminuoso: It's not obvious enough to me, even there.  For executables I'm directly working on, it's *always* the filesystem, never a tarball. (Why would my routine app dev involve making a tarball *before* compilation?)
23:28:39 <EvanR>   Nothing :: Maybe a
23:28:46 <jusss> data Maybe a where   Nothing  :: Maybe a;   Just :: a -> Maybe a
23:28:48 <sclv> in the "standard" "correct" structure for an executable there's typically a big library and a small attendant executable
23:29:10 <Arahael> jle`: Isn't cabal *the* build system, though?
23:29:14 <sclv> and you think carefully about what you want to expose or not in the lib portion, and then only use a small portion of it directly in your Main.hs
23:29:16 <Arahael> I mean, it's not like we use other systems.
23:29:19 <EvanR> (the Maybe a in the non KindSignatures gadt syntax head is still wonky! )
23:29:24 <dminuoso> Arahael: That brings us back to "cabal is about building packages" :)
23:29:24 <jle`> Arahael: the point of Cabal isn't the same as the point of "a cabal file"
23:29:36 <dminuoso> Arahael: a cabal file describes a package.
23:29:43 <dminuoso> (or multiple ones)
23:29:46 <jle`> Arahael: for example cabal-install these days use many different files, each of those files have a different purpose
23:29:47 <Arahael> sclv: You mean, the "correct" structure is basically having just the one file?
23:29:56 <Arahael> sclv: (Ie, just the one main.hs file?)
23:29:57 <sclv> cabal is "common architecture for building applications and libraries"
23:30:02 <jle`> Arahael: are you saying that every file that cabal uses has to be a full build system?
23:30:10 <dminuoso> sclv: Is that the actual abbreviation? :o
23:30:24 <Arahael> jle`: What do you mean?
23:30:26 <sclv> no the "standard" structure is a cabal file which has a lib and an exe component bth
23:30:28 <jle`> Arahael: just because "Cabal" can be used as a build system, doesn't mean that that's what a ".cabal" file is meant for
23:30:33 <sclv> and the exe component depends on the lib component
23:30:47 <jle`> Arahael: for example, git is a version control system, right?
23:30:49 <Arahael> jle`: Ah...  So clearly I'm misunderstanding what that .cabal file is?
23:30:53 <jle`> Arahael: so, why isn't ".gitignore" a version control system?
23:30:56 <int-e> jackdk: I think this doesn't work with rewrite rules. https://stackoverflow.com/questions/19745038/ghc-rewrite-rule-specialising-a-function-for-a-type-class  has an explanation
23:31:00 <sclv> the idea is really that we build packages, including for exes
23:31:05 <sclv> because if you want to build it on your machine
23:31:11 <jle`> Arahael: shouldn't ".gitignore" also contain the list of branches, the remote urls, the verison history, the full commit log ...
23:31:15 <sclv> likely you want to build it on a few other machines
23:31:19 <sclv> even if you don't put it on hackage
23:31:33 <EvanR> confirmed, no one knows what cabal is
23:31:34 <Arahael> jle`: You could put the .gitignore into the version control system if you only want it to apply to particular branches, sure?
23:31:40 <EvanR> i guess it's a fitting name
23:31:42 <jle`> Arahael: in reality .gitignore is a specific piece of git, a specific metadata file that git uses to do its overall job. a .gitignore file has one usage: to specify what files to ignore
23:31:43 <sclv> so you need to package up all the information about how to build it
23:31:47 <sclv> and that includes what files to build
23:31:53 <Arahael> jle`: Or you could put it outside the version control system if you want it to be more global?
23:32:03 <jle`> Arahael: the role of a .gitignore file isn't to "specify what files to ignore.  and also specify the name of branches and commit history"
23:32:13 <sclv> dminuoso: yes, that was the reason the name was given when it was first introduced many years ago
23:32:28 <jle`> Arahael: a ".gitignore" file has one specific purpose, and it isn't meant to be the a full description of a repository. it's only meant to specify what files to ginore
23:32:30 <Arahael> jle`: Well, indeed, but nobody uses it that way, or tries to. I've never heard of people in #git asking how to do that.
23:32:43 <monochrom> I wouldn't say this conversation is getting nowhere.  Because it is getting all over the place now.  Next we will also talk about makefiles.
23:32:51 <sclv> i think the problem isn't the exe vs. lib distinction. its the package vs "just messing around locally" distinction
23:32:56 <Arahael> jle`: I'm beginning to feel like I'm complaining about wanting to use Lotus Notes as an email server, and all the Domino guys telling me to shut up, it's so much more!
23:33:06 <sclv> and cabal is about packaging stuff so people can build it elsewhere too
23:33:11 <jle`> Arahael: yeah, so a .cabal file is the same thing.  a .cabal file isn't meant to specify the building process.
23:33:32 <jle`> Arahael: a .cabal file is just one type of metadata file that Cabal uses.  just like how .gitignore is one type of metadata file that git uses
23:33:39 <Arahael> jle`: Ok, so basically, what I'm getting out of this is that I should use a tool designed for the building process, and that's hpack?
23:34:17 <jle`> Arahael: well, you can use Cabal to build packages.  but i'm saying that's that not what a ".cabal" file, *in specific*, is meant to specify
23:34:41 <Arahael> jle`: Have you ever used Lotus Notes?
23:34:44 <jle`> caban can use many different types of metadata files in order to specify how to build things. not just ".cabal". it's only one piece of the picture
23:35:02 <jle`> i have not :o
23:35:10 <sclv> Arahael: no that's not what people are saying at all!
23:35:14 <Arahael> jle`: Hmm, then you're not going to understand that metaphor.
23:35:18 <sclv> hpack isn't designed for building any more than cabal files
23:35:35 <Arahael> sclv: Oh?
23:35:36 <EvanR> monochrom: bad call. We have to first take a detour through Lotus Notes
23:35:42 <sclv> the only question being answered was "why do cabal files list this" and the answer is "its a package manifest"
23:35:58 <sclv> the question i think you mean to ask is "how do i mess around locally without all this cabal file nonsense"
23:36:04 <monochrom> Yeah I wasn't imaginative enough.  But now I've learned.  WordStar anyone?
23:36:06 <jle`> Arahael: so, my point is that even though Cabal can be used to build things, that doesn't mean that it is what a ".cabal" file is meant to take on the full responsibility of
23:36:27 <sclv> and the answer is "well if you don't want to build a package, but just get some libraries in scope, then you can do that too, take a look at cabal-env"
23:36:29 <jle`> maybe the confusion is the naming of the file extension
23:36:39 <monochrom> Does anyone still remember what's "mail merging"? >:)
23:36:41 <jle`> instead of calling it ".cabal", we can call it ".packagemanifestandnotabuildsystem"
23:37:03 <jle`> but i think windows has a limit on file extension length or something
23:37:03 <sclv> but i would recommend that you stick with the package approach for now since its straightforward and listing the modules is a minor thing
23:37:36 <Arahael> sclv: It means every time I think: "Hmm, I want to define this new set of functions in this other file", I have to take a detour to the .packagemanifestandnotabuildsystem to explicitly add it to the build.
23:37:41 <jle`> presumaly we'd get the same type of confusion if ".gitignore" file was not named gitignore but rather named ".everythingaboutgit"
23:37:57 <sclv> yeah, i guess so. i barely even notice these days since its such minor part of my workflow
23:38:18 <EvanR> so why do i not have to list all the files with stack build
23:38:36 <sclv> because stack uses hpack which assumes everything is something you want to build
23:38:54 <EvanR> that explains why it was trying to build everything in sight
23:38:56 <sclv> hpack files get "compiled" to cabal files behind the scenes
23:38:57 <Arahael> Depending on teh template - most of them use hpack.
23:39:01 <EvanR> and i had to delete stuff
23:39:10 <sclv> so yeah, there's the tradeoff :-)
23:39:34 <EvanR> "hpack"... wth is that
23:39:45 <EvanR> and why has no one complained about it until today
23:39:53 <sclv> its a tool someone built that compiles yaml to cabal files
23:40:12 <sclv> it used to have a bunch of features in advance of cabal files, like better condiditonal handling
23:40:16 <monochrom> I wonder if it's transcode rather than compile.
23:40:28 <jle`> i like to think of it as transcodpile
23:40:29 <sclv> at the cost of a grammar not suited for the task, to be honest
23:40:32 <Arahael> monochrom: I'm not sure what the difference between transcode, and compile. ;)
23:40:45 <sclv> but cabal files have since gotten all the conditional power, etc
23:40:57 <sclv> oh and the shared stanza power
23:40:58 <EvanR> that's annoying
23:41:17 <sclv> so all that's not provided directly is the "grab everything in sight" feature, but there's a ticket for how to do that in a sort of reasonable opt-in way
23:41:21 <monochrom> Because "compile" connotes higher-level-to-lower-level and even increase in entropy.
23:41:23 <jle`> hpack has module discovery and directory wildcards too, so that's ... something
23:41:41 <sclv> while preserving the property that _published_ packages list everything in the manifests
23:41:50 <EvanR> i refuse to derail, but you could compile asm into C
23:41:51 <monochrom> "transcode" connotes fairly on-par changing encoding.
23:42:18 <EvanR> compilers are just language translation
23:42:19 <sclv> jle`: yeah, that's what i meant by the "grab everything" feature -- i think that's all covered in the linked ticket
23:42:27 <EvanR> back to build systems yeeeeah
23:42:37 <Arahael> EvanR: You could compile that C to Javascript, too. :)
23:42:44 <Arahael> But yeah.
23:42:46 <monochrom> I could compile asm into Haskell too.
23:42:57 <sclv> monochrom: maybe _you_ could :-P
23:43:09 <monochrom> Yes I'm speaking for myself :)
23:43:23 <jle`> nice strategic usage of pronouns to convey meaning
23:44:24 <EvanR> so... we learned that not only no one knows what cabal is, everything it stands for is ignored by stack and hpack got it
23:44:35 <EvanR> "you must list everything in the manifest" "no you dont"
23:44:56 <jle`> hpack could be considered a manifest generator
23:45:15 <Arahael> CUriously, it works fine even if you don't list everything, but you get an annoying warning, iirc.
23:45:32 <jle`> we like manifests but we don't like writing them by hand
23:45:34 <EvanR> "static information is better than dynamically generated information" "agreed, standby while i dynamically generate it"
23:45:36 <jle`> so enter hpack
23:46:06 <monochrom> Eclipse can make manifest files for you. Just switch to Java. >:)
23:46:40 <ammar2> if compilers are just language translators then why do words like transpiler and decompiler exist :>
23:46:48 <EvanR> ignorants
23:47:04 <monochrom> Eclipse is the culprit of this "set up a project" craze every time you just want to write a 1-liner toy programming assignment.
23:47:04 <EvanR> should be a word
23:47:33 <monochrom> decomptranspiler
23:47:48 <EvanR> decompiler ought to be a sort of reverse compiler
23:47:58 <EvanR> so it's a negative concept
23:48:08 <monochrom> BTW why don't we say "encompile and decompile", like "encode and decode"? >:)
23:48:37 <EvanR> inverse of a function is also a function
23:48:47 <ammar2> the en- prefix isn't there for every verb
23:48:53 <ammar2> example gaussing vs degaussing
23:49:04 <int-e> monochrom: or compile and depile
23:49:21 <monochrom> Hey how about "enjoy" and "dejoy"? >:)
23:49:27 <EvanR> pile and unpile
23:49:36 <ammar2> now that I can get behind
23:50:02 <EvanR> dogpile
23:50:06 <sclv> well clearly compiling is the opposite of mpiling
23:50:31 <Arahael> Isn't this argument basically in favour of George Orwell's "doublespeek" language? ;)
23:50:42 <EvanR> newspeak
23:50:48 <Arahael> Ah, that was it.
23:50:51 <monochrom> What argument? Who's arguing?
23:50:52 <EvanR> doublethink
23:51:20 <jle`> ammar2: if words like polygon exist, why do words like square and triangle exist
23:51:53 <EvanR> instance Polygon Square where
23:52:17 <EvanR> instance Ellipse Circle where
23:52:30 <ammar2> never heard anyone use the word "polygon"
23:52:34 <EvanR> too far maybe
23:52:44 <ammar2> compiler on the other hand
23:53:03 <jle`> ammar2: if words like 'shape' exist why do words like 'circle' and 'rectangle' exist
23:53:44 <monochrom> "you plan to go to the Bermuda triangle? you're such a square" -> "you plan to go to the Bermuda polygon? you're such a polygon"
23:53:51 <jle`> if words like 'number' exist, why do words like 'one' and 'two' exist
23:54:11 <Arahael> jle`: What's "one" or "two"?
23:54:24 <EvanR> today's quota of "why" questions is nearly depleted
23:54:46 <monochrom> EvanR: Why?!  >:)
23:54:52 <ammar2> I think the distinguishing factor there is that no one points to a square and says look at this 'shape' 
23:55:14 <monochrom> I think I did that once.
23:55:14 <ammar2> but with compiler/compiling people do
23:55:28 <jle`> i'm pretty sure that's a common thing
23:55:44 <jle`> "which of these shapes is better for a table? this one, or that one?"
23:56:23 <jle`> i sometimes point at a dog and say "i like your pet".  does that mean 'dog' doesn't have a reason for existing as a word?
23:57:29 <monochrom> double movie bundle: Reservoir Pet and Organic Fiction
23:57:45 <jle`> the reason why these words exist is that sometimes there is benefit in talking about distinctions between subcategories, for different layers of meaning and nuance
23:58:10 <jle`> the word you use depends on what sort of nuance and specifity you want to convey in that usage site
23:58:29 <EvanR> can i make a devil's deal where transpiler is acceptable jargon in exchange for this thread to be over
23:58:47 <ammar2> no
23:58:50 <jle`> so if i ask a child 'draw me a shape', i don't care what sort of shape they draw, and so there is no reason to make a distinction and say 'draw me a square or triangle or octagon or circle or ....'
23:58:52 <int-e> Welcome to the Haskell School of Expression, where the finest linguists of the world congregate.
23:59:03 <ammar2> is template haskell a transpiler
23:59:14 <jle`> but if i want them to draw a square i say 'please draw square', in the case that i specifically want a square
23:59:16 <monochrom> I thought they were musicians...
23:59:27 <jle`> so the different layers of meaning are useful in different circumstances
23:59:41 * hackage pcre-light 0.4.1.0 - Portable regex library for Perl 5 compatible regular expressions  https://hackage.haskell.org/package/pcre-light-0.4.1.0 (DanielDiaz)
23:59:45 <monochrom> Template Haskell is a preprocessor.  Change my mind.
