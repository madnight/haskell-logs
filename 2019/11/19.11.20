00:24:55 <bahamas> anyone using ghcide with vs code? it's maxing out my CPU on mac
00:27:16 <bahamas> it spawns a lot of ghc processes, which don't go away even after I close vs code.
00:45:12 <maerwald> vscode needs to run in the cloud
01:12:35 <bahamas> maerwald: what do you mean?
01:13:43 <mpickering> bahamas: It is probably compiling the dependencies of your project
01:14:08 <Arahael> maerwald: No, it doesn't.
01:14:15 <Arahael> maerwald: Unless I've missed something?
01:14:39 <mpickering> it can but doesn't have to
01:17:29 <bahamas> mpickering: is there a way to limit the number of ghc processes it spawns? at one point it created so many that I had to restart my computer
01:18:09 <mpickering> do you have an explicit conifg?
01:18:16 <mpickering> if you don't it might be trying to use stack
01:18:21 <mpickering> which might not be what you want
01:18:22 <merijn> Does stack auto-parallelise builds? Because cabal-install for sure doesn't
01:18:25 <Arahael> You should be able to set a ulimit, as well.
01:18:55 <mpickering> I think stack does merijn 
01:20:35 <bahamas> mpickering: if you're referring to an explicit config for ghcide, then no, I don't have one
01:21:14 <bahamas> I'll look through their docs more carefully
01:21:21 <DigitalKiwi> have some art https://www.dropbox.com/s/4z6ee2e6ckh3wyw/2019-11-20%2003.09.58.jpg?dl=0
01:22:31 <DigitalKiwi> https://www.dropbox.com/s/0s9mzbgjawfkf8l/2019-11-20%2003.09.58-1.jpg?dl=0 rather
01:22:39 <yushyin> sm[m]: thanks to your hints it worked out. it is a bit more verbose than I expected but all testcases are now successful.
01:23:43 <Arahael> You should be able to set a ulimit, as well.
01:23:48 <Arahael> (Oops)
01:26:13 <bahamas> mpickering: by config are you referring to the hie.yaml file?
01:26:29 <bahamas> that's the only thing relevant I could find here https://github.com/digital-asset/ghcide
01:37:28 <Guest82> Heya guys; I'm a beginner with some questions on using dejafu (https://github.com/barrucadu/dejafu)
01:37:47 <Guest82> I am trying to port some existing code to using MonadConc; but I am stuck on "Parameterise your state types by the monad:"
01:38:16 <Guest82> I've got some structures like so: `data Channel a = IORefChan (IORef (Maybe a)) | MVarChan  (MVar a)`
01:38:26 <Guest82> How would I go about porting these?
01:39:41 * hackage cobot-tools 0.1.1.0 - Biological data file formats and IO  https://hackage.haskell.org/package/cobot-tools-0.1.1.0 (ozzzzz)
01:40:31 <dminuoso> Guest82: I don't quite understand the question. 
01:41:26 <Guest82> woops; accidently left the channel instead of checking the message. Did someone send me something?
01:42:56 <Lycurgus> dminuoso said they didn understand the question
01:43:31 <Lycurgus> you may wanna use a pastebin
01:43:59 <Guest82> Ah. I am quite a beginner at Haskell; and I have trouble understanding step 4 in this guide: https://dejafu.readthedocs.io/en/latest/typeclass.html#porting-guide
01:44:03 <Guest82> making a pastebin
01:44:28 <mpickering> bahamas: Yes
01:45:08 <mpickering> Guest82: You need to change you definition of `Channel` to `data Channel m a = IORefChan (IORef m (Maybe a)) | MVarChar (MVar m a)`
01:45:20 <dminuoso> Guest82: Good quesition, at first glance that reads like nonsense.
01:45:34 <dminuoso> mpickering: Ohh.
01:45:54 <dminuoso> mpickering: But that wouldn't kindcheck would it?
01:46:02 <mpickering> yes it would
01:46:04 <dminuoso> Huh
01:46:05 <dminuoso> Oh.
01:46:06 <Guest82> that results in an error I think
01:46:07 <mpickering> because you change your import of IORef
01:46:22 <dminuoso> mpickering: Ahh I didn't notice that STM was also an associated type family.
01:46:34 <mpickering> to `Control.Concurrent.Classy.*` from `Control.Concurrent`
01:46:50 <dminuoso> Right. I didn't notice the implication of that change.
01:46:52 <mpickering> http://hackage.haskell.org/package/concurrency-1.8.1.0/docs/Control-Concurrent-Classy-IORef.html
01:47:40 <Guest82> Ah it does work
01:47:48 <Guest82> or at least; it moves me on to new type errors
01:47:50 <Guest82> :)
01:47:57 <mpickering> I didn't find the documentation to be very precise either
01:48:08 <mpickering> but you basically just overload the whole program and then write tests as normal
01:48:23 <dminuoso> mpickering: I suppose if you think of that list of things to do as mechanical actions, then its sort of fine..
01:48:36 <Guest82> what exactly is that `m` that I am adding everywhere?
01:48:52 <dminuoso> Guest82: The idea is to write it polymorphic over the monad.
01:49:01 <dminuoso> Guest82: are you familiar with mtl?
01:49:34 <Guest82> no, I just started writing haskell last month
01:49:47 <dminuoso> Guest82: Have you worked with monad transformers?
01:50:28 <Guest82> ah yes I read about those
01:50:55 <dminuoso> Guest82: mtl is an effect library, which nowadays is somewhat orthogonal to transformers but they play nice together.
01:51:40 <dminuoso> Guest82: So with transformers, you might encapsulate a stateful monad by `StateT Int SomeMonad t` - but that limits your computation to only work in that exact stack.
01:52:27 <dminuoso> mtl allows you to write something polymorphic over *any* stateful monad by saying `f :: MonadState Int m => m ()` - where the caller can pick anything for `m` they want (as long as it satisfies MonadState Int)
01:55:08 <Guest82> okay, I kind of get it 
01:58:14 <mpickering> Guest82: Are you using STM at all?
01:58:49 <Guest82> No, it is part of a study assignment; which is limited to just IORef and MVar
01:59:07 <Guest82> I wanted to explore unit testing myself a bit more; I got it working without dejavu
01:59:19 <Guest82> so now I am porting it. 
01:59:55 <mpickering> yeah it's a nice library. I just misunderstood how to port some STM fragments of my code but don't worry about that
02:01:33 <Guest82> So I used to have some constructors like this: 
02:01:52 <Guest82> https://pastebin.com/2icpQj0p
02:02:09 <Guest82> (but using IO instead of MonadConc)
02:02:20 <mpickering> You surely want `newIORefChan :: MonadConc m => m (Channel m a)`
02:03:25 <Guest82> It works like magic
02:03:39 <Guest82> but it is looks like sorcery to me by now :P
02:16:19 <bahamas> mpickering: I see hie.yaml is documented in hie-bios. thanks!
02:18:32 <bahamas> what is the name of the `::` operator? I'm assuming it's a type operator
02:19:44 <dminuoso> bahamas: It's not an operator
02:19:55 <dminuoso> bahamas: It's meaning is "has type"
02:20:12 <dminuoso> bahamas: So it connects the value world with the type world, or the type world with the kind word.
02:20:38 <bahamas> dminuoso: ah, ok. that's why it's not an operator. because it connects things from different worlds
02:21:15 <dminuoso> bahamas: I suppose at the end it depends on what you mean by the word "operator"
02:22:28 <Guest82> dminuoso am I correct in extending the constraint to `(MonadConc m, MonadIO m)` and using `liftIO . putStrLn "something"` when trying to print?
02:23:04 <dminuoso> Guest82: For just `print` you only need MonadIO
02:23:10 <dminuoso> Guest82: But if you want to do any concurrency things, then yes.
02:23:20 <dminuoso> Guest82: Though.. strictly speaking..
02:23:27 <bahamas> dminuoso: well, as it's used in Haskell, when you talk about infix operators you mean functions, which apply to values. when you mean type operators, they apply to types. so they work with things from the same world
02:23:39 <dminuoso> Guest82: Using MonadIO is the ultimate hammer because MonadIO lets you sneak in concurrency without MonadConc.
02:25:14 <Guest82> So it might make my tests more unreliable
02:25:25 <Guest82> since I could be doing sneaky stuff inside MonadIO
02:25:50 <mpickering> If you are using IO to print then it's fine
02:27:01 <dminuoso> It just occured to me that Cont is not the mother of all monads. 
02:27:05 <dminuoso> You can't do IO with Cont..
02:27:12 <dminuoso> You also can't do STM with Cont..
02:27:44 <dminuoso> It's the mother of all monads that are representable by pure functional terms. :o
02:28:51 <tom__> Every monad can be be built out of Cont so I hear
02:29:05 <dminuoso> tom__: It's a mischaracterization.
02:29:11 <tom__> oh
02:29:47 <dminuoso> tom__: Every monad you can build using standard haskell could also be built in terms of Cont. But there's other monads like IO or STM that cannot be implemented in terms of Cont.
02:30:06 <sm[m]> yushyin: good
02:30:41 <dminuoso> tom__: http://hjemmesider.diku.dk/~andrzej/papers/RM-abstract.html
02:30:54 <tom__> Ah yes thanks
02:31:00 <dminuoso> tom__: Take note of "any monad whose unit and extension operations are expressible as purely functional terms can be [...]"
02:31:32 <tom__> Can refinement types be useful for runtime stuff?
02:32:13 <tom__> As in things like Agda and Coq arent generally used for their runtime
02:32:40 <tom__> So in the same vein are refinement types only useful for formal verification?
02:32:44 <dminuoso> What do you mean by "agda [isnt] used for [its] runtime"?
02:33:13 <tom__> My impression is that Agda is used purely for formal verification during compile time.
02:33:42 <tom__> Like you wouldnt ship a binary to someone else as they wouldnt have any useful purpose for it
02:34:22 <jonathanmore>  Seeing as types are stripped during compile, I see no reason for well implemented refinement types to have a runtime hit. My guess is that it's because industry lags behind academia when it comes to powerful types
02:34:42 <dminuoso> tom__: I dont think that's a correct assessment.
02:35:06 <tom__> What is the correct assessment as I have no experience in such matters
02:35:08 <dminuoso> tom__: Agda in particular is a general purpose programming language, the theorem proving can be used to derive program satisfying certain properties.
02:35:14 <dminuoso> tom__: Even more so in Coq when you extract programs.
02:35:24 <merijn> tom__: Agda is "more theorem prover" and "less general purpose programming language"
02:35:46 <yushyin> sm[m]: I guess there might be a not so verbose solution. https://paste.xinu.at/exvk/
02:35:48 <merijn> tom__: It *is* a general purpose programming language, feature wise, but almost no one really uses/supports it as such
02:35:55 <tom__> Right
02:36:41 <merijn> Anyway, refinement types don't (necessarily) require any runtime impact, just look at Liquid Haskell
02:38:11 <tom__> I am interested in program synthesis but not sure where to begin, thinking maybe liquid haskell
02:38:25 <tom__> So I can try Synquid
02:39:39 <kuribas> AFAIK refinement types are their to prove properties about your code, so you have less bugs at runtime.
02:39:49 <kuribas> but they don't operate at runtime.
02:40:03 <phadej> that's an idea of types, to be not present at runtime? :)
02:40:04 <dminuoso> kuribas: That could be said of *types* in general.
02:40:14 <kuribas> dminuoso: indeed
02:40:24 <kuribas> only when you add type-classes, they influence run-time
02:40:36 <tom__> Now I am confused about the difference between strong typing and weak typing
02:40:37 <kuribas> since typeclasses link runtime and compile time.
02:40:50 <dminuoso> tom__: Do you know Pierce's Types and Programming Languages?
02:40:52 <dminuoso> @where TaPL
02:40:52 <lambdabot> "Types and Programming Languages" by Benjamin C. Pierce in 2002-02-01 at <https://www.cis.upenn.edu/~bcpierce/tapl/>
02:41:05 <tom__> I thought the distinction related on the ability to coerce values into different types at runtime
02:41:07 <merijn> tom__: That's because most programmers use incredibly poor terminology and confuse lots of things
02:41:36 <tom__> dminuoso: Saw it on Amazon once
02:41:37 <merijn> tom__: The computer science definition of types is *always* static (i.e. at compile time, without running code)
02:42:08 <tom__> merijn: Ah interesting, it was Michael Snoyman that said that in a podcast
02:42:33 <kuribas> weak/strong, dynamic/static, they are mostly poorly defined terms.
02:42:35 <merijn> tom__: And strong vs weak is also weird, because they're rather vauge and squishy
02:42:36 <dminuoso> tom__: TaPL has the following definition: A type system is a tractable syntactic method for proving the absence of certain program behaviors by classifying phrases according to the kinds of values they compute.
02:42:43 <merijn> kuribas: Static is perfectly well defined
02:42:56 <dminuoso> tom__: That book is a foundational book in type theory, probably one of the most authoritative ones. The definition is quite good. :)
02:43:25 <kuribas> dminuoso: what's "classifying phrases"?
02:43:32 <dminuoso> kuribas: The act of classification.
02:43:36 <tom__> Awesome thanks
02:43:41 <kuribas> what's a phrase in computing?
02:43:49 <kuribas> I find it a rather vague definition
02:44:02 <dminuoso> kuribas: It is intentionally vague because it makes no particular assumptions about the programming language
02:44:27 <kuribas> is lisp type-tagging a type system then?
02:44:50 <merijn> kuribas: Is it static? (i.e. offline, without running code). No? Then not types
02:45:10 <kuribas> so it's a static typing centric point of view
02:45:20 <dminuoso> tom__: Out of that definition, there's several notable properties. For one, it's a *syntactic* method. So by that definition alone something like "dynamic typing" is non-sensical, obviously. :)
02:45:50 <merijn> kuribas: Type systems are about enforcing properties at the syntactical level
02:45:58 <phadej> I guess merijn is after something that you would call "value system", e.g. Python has different kinds of values, integers, strings, lists etc.
02:46:02 <kuribas> merijn: _static_ type systems
02:46:11 <merijn> kuribas: It's not "static typing centric", type systems are *by definition* static
02:46:17 <dminuoso> kuribas: In a type theory sense there is no differentiation between "static" and "dynami"
02:46:25 <merijn> You may have some sort of "tag system" to enforce things at runtime, but that's not a type system
02:46:26 <dminuoso> kuribas: It's the same sort of confusion with "functions". 
02:46:43 <dminuoso> kuribas: A majority of people say "functions" and "pure functions", but really they are just misusing terms that were well defined.
02:46:45 <merijn> Because it can't say things about expressions, it can only do things at runtime
02:47:05 <dminuoso> kuribas: A type system is a theorem prover, essentially. 
02:47:07 <merijn> kuribas: If you like "dynamic runtime tag" that's fine, but it's not types, it's runtime tagging
02:47:21 <phadej> merijn: do you mean more like "python has a (static) type system, but it doesn't have type-checker" ?
02:47:26 <merijn> A sort of sanity checking/assert
02:47:31 <dminuoso> phadej: It does have a type checker actually. :P
02:47:44 <dminuoso> Python has been receiving a proper type system over the past few years.
02:47:48 <tom__> So python is statically typed
02:47:50 <tom__> ?
02:48:03 <kuribas> wikipedia: "In programming languages, a type system is a set of rules that assigns a property called type to the various constructs of a computer program, such as variables, expressions, functions or modules."
02:48:11 <kuribas> that would include lisp/python...
02:48:14 <merijn> phadej: Everything has a (static) type system, loads of them are just useless
02:48:30 <merijn> kuribas: Wikipedia is a nonsense source that contradicts most established computer science
02:48:33 <dminuoso> kuribas: The definition is poor
02:48:54 <dminuoso> kuribas: It matches with many casual programmers with no academic background would say.
02:48:56 <merijn> kuribas: The fact that people colloquoially misuse the term "type system" doesn't mean there isn't a well established technical definition that's existed for decades
02:49:47 <dminuoso> kuribas: A type system is an automated theorem prover. It proves things about your program.
02:49:56 <merijn> Also, lisp and python do have type systems, they're just "every expression has type unit" so every expression/value is allowed in any context, which makes it 1) rather useless and 2) pointless to check at parse time, since everything is always valid
02:50:12 <dminuoso> merijn: Thats not strictly true.
02:50:18 <dminuoso> Python has an actua type system..
02:50:28 <merijn> Lisp and python *also* have runtime tagging to guard against "wrong" behaviour, but that's more akin to "assert"
02:50:28 <kuribas> dminuoso: I find the TAPL definition also nonsensical "classifying phrases according to the kinds of values they compute." doesn't mean anything.
02:50:33 <dminuoso> merijn: https://docs.python.org/3/library/typing.html
02:50:46 <merijn> dminuoso: I'm ignoring pythons recent type system stuff, because 1) I don't care and 2) don't know anything about it
02:50:48 <dminuoso> It's not very comprehensive, and it doesn't work well - but they have it never the less.
02:51:00 <merijn> kuribas: I think that phrase is a poor example and not a good definition
02:51:01 <dminuoso> merijn: That's rather ignorant. If your point is "Python has no real type system" then that's just a blatant lie.
02:51:20 <merijn> dminuoso: All python versions I know about don't have a type system
02:51:33 <dminuoso> merijn: It's in Python since 3.5
02:51:36 <merijn> And considering all the python I see in daily life is 2.7
02:51:38 <dminuoso> Fair enough
02:51:46 <dminuoso> kuribas: We can try and make sense of it, if you like.
02:51:48 <merijn> dminuoso: Yeah, in fairy land where all python is >3.5
02:51:59 <kuribas> merijn, dminuoso: or do you mean from the view of mathematical type theory?
02:52:15 <tom__> So does pythons 3.5+ type system count as an automated theoreom prover?
02:52:24 <dminuoso> tom__: Yes, but it's a poor one. 
02:52:31 <merijn> kuribas: TaPL has a proper technical definition of typing, but it's like a paragraph or so long so hard to condense into a single line
02:52:34 <dminuoso> tom__: But is one nevertheless. :)
02:52:40 <kuribas> merijn: right
02:52:46 <merijn> (My copy is at home, so I can't really quote or summarise atm)
02:52:51 <dminuoso> tom__: Or rather it can be used to implement one.
02:52:54 <dminuoso> tom__: That's probably a better phrasing.
02:53:02 <dminuoso> tom__: So it has the underlying support to actually create a type system from it.
02:53:35 <tom__> So will learning Agda improve my programming ability or just make it harder to talk to normal people or both?
02:53:52 <dminuoso> A type system is a tractable syntactic method for proving the absence of certain program behaviors by classifying phrases according to the kinds of values they compute.
02:53:53 <heebo> the fact that python doesnt force you to use it mean everywhere means, that you cannot be sure that the theorem is complete
02:54:12 <dminuoso> kuribas: ^- now consider. If you write some term `1 + 2`, we can classify that *term* according to the kind of values they compute.
02:54:20 <heebo> so python typing doesnt prove theorems
02:54:54 <dminuoso> kuribas: This phrase computes to an integer value. So we could classify that phrase/term as "integer"
02:54:59 <merijn> heebo: It does, they're just rather useless ones
02:55:11 <kuribas> dminuoso: so "phrase" is an expression?
02:55:20 <dminuoso> kuribas: It could be, in Haskell.
02:55:43 <heebo> merijn: agreed but i was talking about the new-fangled python type hints thingy
02:55:45 <dminuoso> kuribas: It's not limited to expressions, we can also classify binders
02:55:58 <dminuoso> kuribas: But we can ignore that for now. Let's say expressions.
02:57:52 <heebo> Am I write in saying that all python types have kind () and as such can be interchanged
02:57:59 <heebo> *right
02:58:11 <yushyin> python calls it 'Any' in Type Hints
02:58:12 <merijn> kuribas: That's the other thing people get wrong about typing, the term "type safety". The correct, technical definition of "type safety" is: Given a model of "acceptable behaviour" and a well-typed expression, that well-typed expression will only exhibit "acceptable behaviour". But everyone always skips the "we have to define a model" step and just says "language X is type-safe" which is rather 
02:58:18 <merijn> meaningless, without a discussion of what "type-safe" even means. I mean, C is perfectly type safe under the model of "memory is a linear sequence of bytes that we can arbitrarily modify" (not that that model is correct on actual machines, but it is a model and well-typed C satisfies it)
02:58:37 <heebo> meaning that the only thing you can prove in python is that () = ()
03:02:02 <dminuoso> kuribas: For instance, Haskell's type system guarantees the absence of page faults (i.e. segfaults in Linux).
03:02:11 * hackage digit 0.9 - A data-type representing digits 0-9 and other combinations  https://hackage.haskell.org/package/digit-0.9 (TonyMorris)
03:02:21 <dminuoso> kuribas: Of course the presence of backdoors like unsafePerformIO, ffi weakens that. 
03:04:55 <tom__> Maybe it makes more sense to think of "programs" as type safe
03:05:26 <tom__> Take python it does a poor job of checking that a program follows python's type system.
03:05:49 <dminuoso> tom__: in type theory the term "safety" has a drastically different meaning from what people think it menas.
03:06:00 <dminuoso> TaPL defines safety to mean progress and preservation.
03:06:08 <tom__> Ah right
03:06:24 <tom__> so undefined is not a function isn't necessarily an example of type unsafety
03:06:27 <tom__> it is "safe"
03:06:34 <tom__> if Javascript says so
03:06:36 <dminuoso> tom__: It depends
03:06:37 <kuribas> dminuoso: for me safety means totality, you always get an answer
03:06:56 <dminuoso> kuribas: Well terminology in specialized fields is not really a matter of personal opinion.
03:06:59 <dminuoso> Or beliefs.
03:07:12 <kuribas> dminuoso: ideally :)
03:07:23 <tom__> Depends on the field
03:07:36 <kuribas> because often different researchers disagree on definitions
03:09:06 <dnikolovv> guys could anyone advise on whether what we're thinking is possible
03:09:14 <dnikolovv> so we have a bunch of web services using Servant
03:09:22 <dnikolovv> and a ui using Yesod
03:09:35 <dnikolovv> the ui is using servant-client to generate clients for the services
03:09:44 <dminuoso> tom__: Right. So progress is defined as "a well typed term is not stuck" (there's a definition for what that means) and presevation means that if a well-typed term takes a step of evaluation, then the resulting term is well-typed.
03:09:55 <dminuoso> tom__: JavaScript in fact has no type system.
03:09:59 <dnikolovv> but each time you update a service's API, you need to also update the client definition
03:10:30 <dminuoso> tom__: so "type safety" in this formal setting really is about "things dont get stuck" and "well-typedness is maintained"
03:10:30 <dnikolovv> can we somehow move the client inside each service (so the compiler will notify us when they break)
03:10:50 <dnikolovv> and then the ui could reference this "client"
03:10:53 <dnikolovv> the catch is
03:10:59 <dminuoso> tom__: so type safety is a property of the type system itself.
03:11:04 <dnikolovv> we don't want to drag all dependencies required to build everything on the service
03:11:08 <dminuoso> tom__: It says whether the type system is *sound*
03:11:10 <dnikolovv> we just need the client definition
03:11:18 <dnikolovv> not sure if I said anything that makes sense lol
03:11:30 <tom__> diminuoso: Ah right
03:11:41 * hackage llvm-tf 3.1.2 - Bindings to the LLVM compiler toolkit using type families.  https://hackage.haskell.org/package/llvm-tf-3.1.2 (HenningThielemann)
03:11:51 <tom__> dnikolovv: What language is the client in?
03:11:57 <dnikolovv> Haskell
03:12:01 <dnikolovv> it's using servant-client
03:12:14 <alp> dnikolovv, each service could supply separate libraries: api, server, client. this is made rather easy with the "multiple public libraries for a package" feature of Cabal >= 3
03:12:24 <tom__> So you want the compiler to tell when both back and front ends break?
03:12:32 <alp> (that is, you can this with a single .cabal file)
03:12:34 <dnikolovv> multiple public libraries that sounds exactly what we need
03:12:37 <tom__> What about sub packages?
03:12:42 * hackage llvm-extra 0.8.1 - Utility functions for the llvm interface  https://hackage.haskell.org/package/llvm-extra-0.8.1 (HenningThielemann)
03:12:53 <dnikolovv> we hope that the compiler could notify us when the API is changed
03:13:05 <alp> it would, just like it does now
03:13:09 <dnikolovv> without referencing the whole service with all it's dependencies
03:13:10 <tom__> Does it not do that anyway?
03:13:21 <dnikolovv> no because they are in different projects
03:13:27 <dnikolovv> in service 1 you have ApiDefinition1
03:13:35 <dnikolovv> in the ui you have ApiClient1.hs
03:13:39 <alp> dnikolovv, the catch being that Cabal 3 is rather recent, so this might not be doable if you're using a build system that doesn't support Cabal 3 yet.
03:13:48 <dnikolovv> I'll check
03:13:51 <dnikolovv> thank you!
03:13:55 <tom__> I cant see how you could do that without creating a new Common package that the client and server both depend on
03:14:10 <dnikolovv> me too that's why I'm asking lol
03:15:09 <dminuoso> tom__: Ah I suppose what I just said is incorrect. It is a property of the underlying programming language.
03:15:28 <tom__> dminuoso: Type safety?
03:15:35 <dminuoso> tom__: Yes.
03:15:44 <tom__> dnikolovv: Ok hope it works
03:16:40 <tom__> dminuoso: So type safety is whether the implementation of a PL honours a sound type system?
03:18:05 <dminuoso> tom__: Essentially, yes. If you think about preservation for example.
03:18:59 <tom__> And an implementation of a programming language is a program? ....
03:19:06 <dminuoso> tom__: If we define some language to have some particular set of evaluation rules. Then preservation means if you have some term that is not a value (you can take an evaluation step) and it is well typed, then taking that evaluation step produces a new term that is also well typed.
03:19:22 <tom__> ok makes sense
03:19:34 <dminuoso> So well-typedness is preserved according to evaluation rules.
03:20:08 <dminuoso> tom__: And equivalently progress means, if you have a well-typed term then it's always a value or you can take an evaluation step.
03:20:29 <dminuoso> tom__: So this guarantees, if some term is well-typed, you can't go stuck in the sense of "dont know what to do with this"
03:21:32 <dminuoso> tom__: Let me present you with a violation of this property:
03:22:02 <dminuoso> tom__: You can write well-typed C programs that cause memory violations. 
03:22:25 <dminuoso> A memory violation would leave you in a state in which no further evaluatoin rule according to the semantics of the language exist.
03:22:44 <dminuoso> So Cs type system does not have formal progress
03:22:46 <dnikolovv> stack currently supports cabal only up to version 2.4
03:22:49 <dminuoso> its therefore not type safe.
03:22:52 <dnikolovv> can you somehow make it use a newer one?
03:23:24 <tom__> dminuoso: interesting
03:23:59 <tom__> A much more nuanced understanding than "type safe" means no runtime coercions
03:24:37 <tom__> Although are values passing through isomorphic types technically type coercions?
03:46:42 * hackage geoip2 0.4.0.1 - Pure haskell interface to MaxMind GeoIP database  https://hackage.haskell.org/package/geoip2-0.4.0.1 (ondrap)
03:52:12 <tdammers> it's funny if you remove the nicks from those messages and read them as one monologue: "Stack currently supports cabal only up to version 2.4. It's therefor not type safe."
04:02:53 <dnikolovv> tdammers: lol
04:08:08 <kuribas> dminuoso: I looked at unliftIO, but it seems to be missing ExceptT, etc...
04:09:54 <tdammers> dnikolovv: it's funny because it's true!
04:10:55 <dnikolovv> tdammers: I'm literally laughing out loud
04:23:35 <concaveirc> Is it possoble to use stack install to install a package with flags? The motivation is that I want to install xmobar with all features enabled.
04:23:52 <jpcooper> concaveirc: Yes. There is syntax for assigning flags in stack.yaml
04:24:20 <jpcooper> concaveirc: See section "flags" at https://docs.haskellstack.org/en/v1.0.2/yaml_configuration/
04:25:45 <concaveirc> jpcooper: Thanks. Do I add the flags to my global stack.yaml? Adding a flags entry causes a complaint about the missing xmobar package.
04:26:12 <concaveirc> The same occurs when I add xmobar to extra-deps
04:30:44 <jpcooper> concaveirc: Is xmobar a package on Stackage?
04:31:06 <jpcooper> I see mentions of it in the package xmonad-contrib
04:34:03 <concaveirc> jcooper: It is not, surprisingly. I am still able to install it with stack install with no flags specified though.
04:34:42 * hackage hw-prim 0.6.2.39 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.6.2.39 (haskellworks)
04:36:23 <jpcooper> concaveirc: Are you trying to install xmobar as part of another package?
04:36:33 <concaveirc> No, I just want the binary.
04:36:36 <jpcooper> Or have you cloned xmobar from github, while trying to install that package
04:37:27 <concaveirc> I have successfully tried cloning from github and building with flags, but I wanted to check if there is a more convenient method.
04:37:46 <jpcooper> Okay. Clone xmobar from github. The stack.yaml on github already has the all-extensions flag set to true
04:37:51 <dminuoso> kuribas: Yes.
04:38:01 <jpcooper> run stack install in that directory
04:38:02 <concaveirc> jpcooper: Thanks
04:38:06 <jpcooper> No problem
04:38:10 <dminuoso> kuribas: MonadUnliftIO essentially only works for things isomorphic to ReaderT/IdentityT.
04:38:35 <dminuoso> z12:23:37          tom__ | A much more nuanced understanding than "type safe" means no runtime coercions
04:38:42 <dminuoso> tom__: You can have runtime coercions just fine.
04:39:02 <merijn> They just have to typecheck ;)
04:39:26 <merijn> tom__: FYI, GHC has type safe coercion support
04:39:36 <merijn> :t coerce
04:39:37 <lambdabot> error:
04:39:37 <lambdabot>     • Variable not in scope: coerce
04:39:37 <lambdabot>     • Perhaps you meant ‘coerced’ (imported from Control.Lens)
04:39:39 <merijn> aww
04:39:53 <merijn> % :t Data.Coerce.coerce
04:39:53 <yahb> merijn: Coercible a b => a -> b
04:43:16 <dminuoso> tom__: By the way, C also does not have preservation. A specific example is type punning.
04:43:28 <merijn> dminuoso: Type punning isn't C
04:43:46 <dminuoso> merijn: What do you mean?
04:44:00 <dminuoso> merijn: The C standard formally allows for some forms of type punning.
04:44:02 <merijn> dminuoso: All forms of type punning that I'm aware of are UB
04:44:12 <dminuoso> merijn: There's several forms that are not UB.
04:44:19 <merijn> dminuoso: Those are all useless, though :)
04:44:21 <dminuoso> merijn: The simplest one, you may pun everything through *char
04:44:26 <dminuoso> merijn: And that's *far* from useless
04:44:49 <merijn> dminuoso: You can access bytes via char*, yes. But you have to go through memcpy to a different pointer
04:44:54 <dminuoso> merijn: You do not.
04:45:01 <merijn> You can't simply "cast to char* and than cast to something else"
04:45:11 <dminuoso> merijn: No, but you can cast to char* and then access through the resulting pointer.
04:45:14 <merijn> dminuoso: You do, because the UB is not defined on types but on the actual objects
04:45:16 <boxscape> It would be overlapping the existing base instance for (->), but is there anything other than that speaking against an instance Monoid (a -> a) where mempty = id; mappend = (.)? (same for Semigroup)
04:45:30 <merijn> dminuoso: Not as anything other than 1) char or 2) the original type
04:45:39 <merijn> dminuoso: Accessing as any other type is UB
04:46:20 <merijn> dminuoso: So you can can cast a double* and a int64_t to a char* and use memcpy between them, but directly accessing a uint64_t object via a double* is UB
04:46:33 <dminuoso> merijn: Im well aware.
04:47:08 <dminuoso> merijn: Im saying you can cast a double* to a char* and then access it via the char* pointer. It's legit. It's not even about memcpy
04:47:19 <merijn> dminuoso: Type punning refers to accessing as the "wrong" type without intermediate copy, which is always UB (well, unless you're like casting int to volatile int, that's fine)
04:47:36 <merijn> dminuoso: Yes, but you cannot cast that char* to an int64_t* and access that
04:47:43 <merijn> dminuoso: Which is what type punning means
04:48:57 <dminuoso> merijn: I consider type punning to access an object through a different type. Accessing a double buffer and treating it as a char buffer is exactly that.
04:49:18 <dminuoso> To exclude punning through *char doesn't really make much sense in this discussion, and it doesn't change much
04:49:34 <dminuoso> But if you absolutely insist on your definition, then fine.
04:49:42 <dminuoso> But that sort of discussion is meaningless, I dont mean to fight on terms.
04:49:45 <dminuoso> My point is
04:49:53 <dminuoso> The type system allows you to do type punning.
04:50:08 <dminuoso> Some forms of it are even allowed according to the semantics of the language.
04:52:34 <dminuoso> merijn: So to get back.. I was merely stating that the type system itself allows for a well-typed term to take one step in the evaluation rules according to the abstract machine specified in the C standard, after which the resulting term is no longer well-typed.
05:00:42 * hackage hw-xml 0.4.0.4 - XML parser based on succinct data structures.  https://hackage.haskell.org/package/hw-xml-0.4.0.4 (haskellworks)
05:02:48 <kuribas> dminuoso: I think I could create a typeclass that has "withResource :: (forall b c.(a -> IO b) -> IO c) -> (m a -> m d) -> m d", and works with StateT as well
05:03:34 <merijn> kuribas: That's just MonadBaseControl and it sucks :p
05:04:29 <kuribas> merijn: why?
05:05:26 <merijn> kuribas: It's API is superconfusing, it's very hard to reason about what exactly happens, etc.
05:05:28 <dminuoso> kuribas: https://www.fpcomplete.com/blog/2017/06/tale-of-two-brackets
05:05:45 <dminuoso> kuribas: There's numerous other similar blog entries. MBC is really nasty for so many reasons.. :)
05:06:24 <merijn> kuribas: There's a reason snoyberg & co invented MonadUnliftIO and moved all his stuff from MonadBaseControl to MonadUnliftIO and they basically all boil down to "now we finally know what stuff does"
05:28:09 <Lears> boxscape: It's not Haskell2010; it requires FlexibleInstances, TypeFamilies or GADTs.
05:28:43 <boxscape> That's fair, though I think the existing base instance for (a -> b) does as well
05:28:43 <job123> Hi, i don't understand kinds very well, especiall kind signatures. I want to define a function that takes a ParamSchema argument and returns a String, i.e. paramSchemaToString :: ParamSchema SwaggerKindParamOtherSchema -> String. A constructor for that type is _paramOtherSchemaParamSchema and can be found here[tm]:
05:28:44 <job123> http://hackage.haskell.org/package/swagger2-2.4/docs/Data-Swagger.html#t:ParamOtherSchema. How should the signature look like?
05:29:00 <job123> If i use the signature as written above, i get the following error message:     Not in scope:      type constructor or class ‘SwaggerKindParamOtherSchema’    A data constructor of that name is in scope; did you mean DataKinds?
05:30:53 <dminuoso> job123: Apparently that data type is not exported.
05:31:43 <job123> dminuoso: so what to do then?
05:34:14 <Lears> boxscape: No, `instance Monoid b => Monoid (a -> b)` is perfect Haskell2010, even 98.
05:34:22 <dminuoso> job123: You'd ignore it.
05:34:25 <dminuoso> job123: Perhaps?
05:34:27 <dminuoso> job123: No idea.
05:34:33 <boxscape> Lears ah, huh, fair enough
05:34:59 <boxscape> job123 note that _paramOtherSchemaParamSchema  isn't a constructor, it's a record field of the constructor ParamOtherSchema. Perhaps what you want is a function from ParamOtherSchema (also the name of the type the constructor belongs to) to String?
05:35:00 <dminuoso> boxscape: Remember that `(a -> b)` is `((->) a b)`
05:35:19 <dminuoso> boxscape: At that point the inflexible instance rules are satisfied.
05:38:01 <job123> boxscape: thank you and, yes, if this is the only way to do it, i'll take the level above ParamSchema. However, it is a little bit inconvenient. I wanted to reduce the nesting level as much as possible.
05:38:44 <boxscape> job123: The code they use presumably used -XDataKinds, and you could write the type you started out with if you enable that extension
05:39:37 <job123> boxscape: ok - is this common or rather esoteric?
05:40:18 <boxscape> job123: I'd say as long as you're using a library that exposes types that rely on it it's pretty common
05:40:54 <job123> boxscape: thank you very much. i will give it a try.
05:51:11 * hackage universum 1.6.1 - Custom prelude used in Serokell  https://hackage.haskell.org/package/universum-1.6.1 (gromak)
05:55:20 <shapr> GOOD MORNING #haskell !
05:55:27 <shapr> it's a beautiful day to upload something to hackage!
05:56:25 <Rembane> shapr: Have you placed traps or something in the uploading form?
05:56:46 <shapr> Rembane: no, I was just reading up on how to upload my own cabbage
05:56:57 <shapr> but I like you creative interpretation better than reality
06:02:56 <sgraf> Does anyone have a clue how ready-for-primetime backpack is in terms of tooling (cabal, stack)? Can I just write a backpack-ified package now? Are there any examples?
06:03:45 <shapr> sgraf: I know ed has used backpack for a real something, you could search inside the many repos of https://github.com/ekmett/
06:04:13 <shapr> sgraf: ah check this out http://hackage.haskell.org/package/unpacked-containers
06:05:50 <sgraf> shapr: Thanks, I was faintly aware of unpacked-containers but didn't bother to try. `stack install unordered-containers` ultimately fails with `Invalid package ID: "unpacked-containers-0-LfzPMTpGfdOB6DZgwnNLSt+9O4xGsIBaOn7knYCYMH2U"`, so not sure if it works for everyone in the eco system or not
06:06:34 <shapr> I dunno anything about stack, but I can try it with cabal 3 on ghc 8.6
06:11:13 <sgraf> Well, maybe I just don't care for stack until they fix it
06:18:19 <shapr> sgraf: you could use unordered-containers as an example for backpack use
06:19:40 <shapr> looks like backpack does have cabal support, https://www.haskell.org/cabal/users-guide/developing-packages.html#pkg-field-mixins
06:25:35 <edwardk> sgraf: for cabal it works great. for stack? not yet
06:26:17 <edwardk> sgraf: i did just talk to snoyman at functionalconf about trying to figure out what we'd need to fix that
06:27:29 <edwardk> (we use backpack pretty heavily at MIRI)
06:28:51 <merijn> sgraf: Stack uses Cabal (but I don't think they support Cabal 3.0) so anything supported by Cabal 2.4 should work with stack (which includes backpack, afaik)
06:31:45 <edwardk> https://github.com/commercialhaskell/stack/issues/2540 <- is still open
06:38:12 * hackage ghc-trace-events 0.1.0 - Faster traceEvent and traceMarker, and binary object logging foreventlog  https://hackage.haskell.org/package/ghc-trace-events-0.1.0 (MitsutoshiAoe)
06:54:22 <Kaiepi> i'm trying to run some tests that depend on unicode but it seems like ghc isn't detecting my locale and is using latin1 instead
06:54:43 <Kaiepi> LC_ALL, LC_CTYPE, LANG, and LANGUAGE are all set to en_CA.UTF-8
06:54:57 <Kaiepi> is there anything else i can do to try to make it use the right one?
06:56:28 <phadej> why you think it's using latin1 ?
06:57:17 <Kaiepi> when i call localeEncoding in ghci it returns latin1 instead of utf8
06:58:16 <phadej> localeEncoding :: TextEncoding is pure value, it's not affected by environment
06:58:47 <merijn> Not to mention that latin1 is a subset of UTF-8 :p
06:59:25 <phadej> try
06:59:26 <phadej> Prelude GHC.IO.Encoding> getLocaleEncoding 
06:59:26 <phadej> UTF-8
06:59:28 <merijn> So you literally can't tell whether something is UTF-8 or latin1, unless it includes things that are not in latin1 (in which case it must, thus, be unicode)
07:01:56 <boxscape> phadej localeEncoding uses unsafePerformIO
07:02:01 <phadej> sad
07:02:17 <phadej> I see, but still, i'd call getLocaleEncoding
07:02:46 <phadej> and see what it returns
07:02:58 <merijn> boxscape: It only defines the initial encoding
07:03:12 <merijn> boxscape: It's not updated if it changes later
07:03:30 <boxscape> true, but I wouldn't call it a pure value
07:04:35 <Kaiepi> *GHCI.Tools GHC.IO.Encoding> getLocaleEncoding
07:04:36 <Kaiepi> ISO-8859-1
07:07:57 <phadej> what happens if you import GHC.IO.Encoding.Iconv and try localeEncodingName
07:10:32 <phadej> there's really a lot which could happen: https://github.com/ghc/ghc/blob/master/libraries/base/cbits/PrelIOUtils.c
07:10:38 <phadej> either iconv works or it doesn't
07:10:41 <Kaiepi> *GHCI.Tools GHC.IO.Encoding.Iconv> localeEncodingName
07:10:41 <Kaiepi> "latin1"
07:11:31 <jared-w> what does en_CA stand for? Haven't seen the CA before
07:12:03 <phadej> canada?
07:12:04 <Kaiepi> canada
07:13:14 <jared-w> Oh, duh. It's too easy for me apparently
07:13:41 <jared-w> Comedy option: what happens if you set them all to en_US?
07:14:52 <Kaiepi> same thing
07:15:17 <jared-w> does running "locale" in your terminal show what you've set LC and everything else to?
07:15:43 <phadej> and you have them, i.e. `locale -a` does list these locales?
07:16:47 <Kaiepi> yeah, it shows en_CA.UTF-8 for all of them
07:17:42 * hackage compact-word-vectors 0.1 - Small vectors of small integers stored very compactly.  https://hackage.haskell.org/package/compact-word-vectors-0.1 (BalazsKomuves)
07:18:26 <jared-w> Hmm. Weird. I assume utf8 works fine everywhere else on your OS?
07:18:59 <jared-w> perl -Mcharnames=:full -CS -wle 'print "\N{EURO SIGN}"'
07:19:13 <jared-w> That tests utf8 in Perl in the terminal
07:19:42 <jared-w> Well, really it tests if your font has the € symbol...
07:20:02 <merijn> are the locale variables exported?
07:23:23 <Kaiepi> bastille% perl -Mcharnames=:full -CS -wle 'print "\N{EURO SIGN}"'
07:23:23 <Kaiepi> €
07:23:57 <phadej> interesting... :)
07:23:57 <jared-w> Cool. So Perl believes you can do utf8 then
07:24:50 <jared-w> This is the point where I give up and suggest looking at the implementation details of localeEncodingName or getLocaleEncoding
07:25:38 <phadej> yeah, compiling small C program which calls locale_charset() and see what it does report would be good start, but it's some work
07:25:53 <jared-w> Although, does putStrLn "€" in ghci not work?
07:26:14 <boxscape> % putStrLn "€"
07:26:14 <yahb> boxscape: €
07:26:46 <jared-w> I meant in Kaiepi 's computer. But good to know :p
07:27:11 <boxscape> I wanted to see if yahb's encoding is set up to handle it :)
07:27:25 <dmwit> hold up
07:27:37 <dmwit> I think y'all are concluding weird things from Kaiepi's perl test.
07:28:07 <Kaiepi> € displays as � when i try pasting it in ghci
07:28:33 <dmwit> Remember that the euro sign, if it renders at all for y'all, is rendering on *your* computer, not Kaiepi's.
07:29:02 <Kaiepi> bastille% ghci -e 'putStrLn "€"'
07:29:02 <Kaiepi> <interactive>:0:12: error:
07:29:02 <Kaiepi>     lexical error in string/character literal at character '\130'
07:29:06 <dmwit> And there is some unknown set of software involved in the copy-and-paste that transferred those bytes from perl's output to IRC's input.
07:29:22 <Kaiepi> i can paste unicode into my terminal and run it through perl6 fine
07:29:54 <jared-w> Fair point, but the fact that pasting it in breaks ghci and not Perl is interesting. Makes sense since ghci is reporting latin1. It should choke in utf8 if it doesn't think you support it.
07:29:56 <dmwit> I honestly don't conclude very much from "I can paste unicode into my terminal and run it through perl6 fine".
07:31:16 <dmwit> Kaiepi: Anyway, it is weird that the encoding isn't being set appropriately. In the short term, there is a way to set the encoding that later Haskell functions will use for terminal and file IO.
07:31:26 <dmwit> Kaiepi: (But I don't know of a way to affect what encoding ghci itself uses.)
07:31:43 <dmwit> ?hoogle hSetEncoding
07:31:43 <lambdabot> System.IO hSetEncoding :: Handle -> TextEncoding -> IO ()
07:31:43 <lambdabot> GHC.IO.Handle hSetEncoding :: Handle -> TextEncoding -> IO ()
07:33:55 <dmwit> Kaiepi: (And of course there's the question of what encoding your terminal is using to convert your keypresses to bytes for the process it's running, and what encoding your terminal is using to convert bytes of output from the process it's running into renderable text, and I can't speak to either of those at all.)
07:35:03 <dmwit> There's a surprisingly large number of pieces of software that all have to agree for this stuff to work right!
07:39:57 <Entroacceptor> AFAIK latin-1 contains byte sequences that are illegal in UTF-8, so it's not a proper subset.
07:43:52 <Kaiepi> i think ghc is trying to use locale_charset from libcharset on my machine, but that returns US-ASCII when i test it
07:44:27 <phadej> well, that's helpful to know, that GHC doesn't do anything weird
07:44:41 <phadej> but why iconv/libcharset is misbehaving is a next question
07:45:04 <Entroacceptor> Kaiepi: locale -a shows en_CA.utf8 as available?
07:45:33 <Kaiepi> yep
07:46:02 <Entroacceptor> and you're not running ghci from some weird container stuff, nix envs or whatever, right?
07:46:12 <Kaiepi> i'm running it on openbsd
07:46:21 <petrus> Do the "build-depends" lists of various sections (like library and executable) interfere with each other? In particular, when the lib components and Main.hs in the same src/ directory. And if they do, why?
07:46:39 <Kaiepi> otherwise no
07:46:42 <merijn> petrus: Only if those components depend on each other
07:47:18 <phadej> petrus: sharing the same src/ directory is bad practice, it's even documented!
07:47:24 <merijn> petrus: Oh, if you have the source of the exe in the library than GHC will pick up the source files directly, rather than going via you library
07:47:39 <phadej> https://cabal.readthedocs.io/en/latest/developing-packages.html#pkg-field-hs-source-dirs
07:49:45 <Entroacceptor> Kaiepi: it's old, but maybe try http://openbsd-archive.7691.n7.nabble.com/lang-ghc-locale-support-td221713.html
07:50:42 * hackage overloaded 0.1.3 - Overloaded pragmas as a plugin  https://hackage.haskell.org/package/overloaded-0.1.3 (phadej)
07:51:47 <phadej> fwiw, there isn't occurences of "HS_ENCODING" in ghc source code (of today)
07:51:51 <Kaiepi> ahh there we go, setting HS_ENCODING=UTF-8 works
07:52:04 <phadej> I wonder how that works, or is it some openbsd specific patch
07:52:51 <petrus> Okay, I read the cabal doc, I understand, I guess, what is says. There is nothing about interference there, just efficiency. 
07:53:23 <phadej> what you mean by interference?
07:53:40 <phadej> components are not independent, even if they don't depend on each other
07:54:16 <phadej> cabal can pick only single version of a dependency; and in local project it solves for all components
07:54:48 <phadej> (I think even for external dependencies, it only omits building them when that's possible)
07:58:12 * hackage knead 0.4.1 - Repa-like array processing using LLVM JIT  https://hackage.haskell.org/package/knead-0.4.1 (HenningThielemann)
07:58:17 <petrus> Say I have Main.hs and Lib.hs in src/ and I use Map in Lib but not in Main. If I don't include containers into both build-depends then build fails. If Main and lib are separate dirs then I need to include containers only for lib. Nothing changed regarding the package internal deps, main depend on Lib in the same way both cases.
07:59:03 <merijn> petrus: It's because your Lib's modules are getting recompiled again when the executable is compiled
07:59:38 <merijn> petrus: Because GHC is bypassing cabal and finding the modules your importing directly as source files, rather than actually using your library (that you just compiled)
07:59:59 <phadej> ok, so the documentation isn't clear enough :(
08:00:05 <Kaiepi> thanks for the help
08:00:19 <phadej> now I wonder where from HS_ENCODING comes
08:00:25 <phadej> as I cannot find any hint in GHC sources about it
08:00:36 <petrus> merijn: I see, still this is strange ...
08:00:42 <merijn> petrus: Why?
08:00:56 <petrus> phadej: no the doc doesn't help
08:01:34 <phadej> https://cvsweb.openbsd.org/cgi-bin/cvsweb/ports/lang/ghc/patches/patch-libraries_base_cbits_PrelIOUtils_c?rev=1.3&content-type=text/x-cvsweb-markup&hideattic=1
08:01:37 <phadej> oh it is
08:01:59 <phadej> well, next time we'll be aware that at least openbsd does non-trivial and non-upstreamed patches
08:02:11 <Entroacceptor> Kaiepi: you're welcome
08:02:24 <merijn> petrus: cabal controls which installed packages GHC is allowed to use during compilation. Because containers isn't in build-depends for Main, GHC can't use containers. While building Main you import your Lib module (which uses containers), due to GHC bypassing cabal and finding Lib.hs directly (because it's in the same source dir), it tries to recompile Lib, notices you need containers and complains about 
08:02:30 <merijn> containers not being visible
08:03:04 <petrus> why a user should now how cabal internally works for just a simple config? (i.e just what merijn told me)
08:03:07 <merijn> petrus: If you keep them in separate directories, GHC will *not* accidentally find Lib.hs and use the already compiled version (which is linked against containers during its build) and everything continues as normal
08:03:35 <merijn> petrus: This is not a "how cabal works" this is "ghc overeagerly opening modules it finds"
08:03:39 <petrus> merijn: that is not the point
08:04:04 <merijn> petrus: Well, how would you expect to fix this?
08:04:33 <merijn> Cabal can't stop GHC from finding the module (well, unless it'd temporarily delete and then restore the .hs file, but that's dangerous)
08:04:37 <petrus> merijn: good question I admit
08:04:51 <merijn> petrus: It's not fixed, because there is no real fix
08:05:15 <merijn> Other than "fundamentally change how each tool works, breaking everyone's existing stuff"
08:05:35 <merijn> You could stop GHC from looking for modules itself, but then anyone not using cabal is screwed
08:05:51 <petrus> cabal + ghc works in rather mysterious ways :-)
08:05:54 <phadej> "actually", we'd like to let Cabal be able to tell GHC to turn out the auto-discovery, but it's not a oneline change
08:05:55 <merijn> And from within cabal-install your only option is "make the file invisible in the filesystem"
08:06:21 <merijn> Yeah, I guess making the auto lookup configurable works too
08:06:40 <phadej> it's not that pressing though, that anyone would like to spend time on that
08:07:21 <merijn> phadej: Perhaps the cabal docs should be modified to say "just don't" instead >.>
08:08:09 <phadej> merijn: well, I was thinking on making `cabal check` complain if components which depend on each other share hs-source-dirs
08:08:12 <petrus> phadej, merijn : thanks now I understand the situation, still you must admit that behaviour is confusing if one doesn't know all these details.
08:08:35 <phadej> though, beginners don't know to run `cabal check` either
08:10:45 <petrus> also does ghc auto-discovery is recursive?
08:11:03 <phadej> if A depends on B which depends on C? yes
08:11:15 <exarkun> trying to define an OPTIONS endpoint for cors preflight with Servant.  How do I match an OPTIONS request?  I defined `Options` as `Verb 'OPTIONS 204` and used the combinator `Options '[] NoContent` but this fails to compile: Could not deduce (Servant.API.ContentTypes.AllCTRender '[] Servant.API.ContentTypes.NoContent)
08:11:41 <petrus> sure, I meant, does it descend into subdirs?
08:11:43 <exarkun> `Options '[JSON] NoContent` builds but I don't want to match JSON requests...
08:12:15 <phadej> petrus: no, it won't find "src/Bar/Foo.hs"  as Foo, but will find it as Bar.Foo
08:13:49 <petrus> phadej: I know that. What I meant was src/Main.hs/Foo.hs is still the same problem I bumped into?
08:14:32 <phadej> I don't understand what you mean by src/Main.hs/Foo.hs
08:15:49 <petrus> src/Main.hs,Foo.hs -> problem  src/Main.hs/Bar/Foo.hs -> ? , sorry I left Bar out
08:16:06 <tdammers> you mean you have a directory named Main.hs?
08:16:21 <petrus> no
08:16:27 <petrus> just the file
08:17:11 * hackage ansi-pretty 0.1.2.2 - AnsiPretty for ansi-wl-pprint  https://hackage.haskell.org/package/ansi-pretty-0.1.2.2 (phadej)
08:20:33 <petrus> src/{Main.hs,Bar/Foo.hs}
08:21:05 <tdammers> ah, much clearer
08:21:47 <phadej> if Main depends on Bar.Foo then yes, GHC will find it in src/ and not in the lib-library
08:25:11 <petrus> usually main depends on libs and not the other way around so is it not possible that in the main case ghc restrict itself
08:26:33 <petrus> to the executable build-depends list
08:27:04 <petrus> regardless where main is
08:28:15 <phadej> I don't see what's here "other way around"? dependencies are not transitive, and that causes you to realise that your executable isn't actually using your library component but trying to recompile it
08:29:31 <phadej> dependencies are not transitive = if foo depends on bar, and bar depends on quu, then quu modules are not visible when compiling foo (if foo doesn't depend on quu directly)
08:30:22 <phadej> it all does make sense, maybe not immediately. Give it a chance :)
08:32:13 <petrus> I was not talking about a transitive closure, but about the direction of segment. while compiling main what is the point recompiling libs already compiled.
08:33:15 <phadej> the point is that you can (and sometimes there is good reason to) shadow modules in dependencies
08:33:28 <phadej> GHC cannot know what happens, and picks local one
08:33:46 <geekosaur> it has to guess whether that's from the library or intended to be a source… and bu combining source directories, you hinted that it's local source instead of a library
08:34:12 <geekosaur> ghc can't read your mind, or Cabal's for that matter
08:34:47 <geekosaur> (or indeed stack's or make's or any other build system's)
08:37:32 <petrus> cabal needs not to, I have already told it what I want, but the process (ghc + cabal) ignores it, in a rather surprising way.
08:37:53 <petrus> I am not so sure about make for this simple case
08:38:57 <geekosaur> you appear to want ghc and cabal to be incestuous. I'm not so sure this is a good thing especially given stack, which has its own rules
08:39:16 <warbo> hi, I have a fixed set of a few hundred strings, which I need to do *lots* of comparisons with (checking if some sets of these strings are subsets of others)
08:39:21 <geekosaur> and ghc's own build mechanism uses make or shake/hadrian depending on your configuration
08:39:35 <warbo> it seems like a good idea to map them to Ints, but I'm wondering what the fastest way would be?
08:40:10 <phadej> warbo: make it right first, and then see if its acceptably slow or not
08:40:12 <warbo> I could easily write them in a list and look up their index; that's low overhead but O(n) time
08:40:30 <warbo> phadej: it's already slow, and I have the profiles to show it ;)
08:41:19 <phadej> to be clear: you are checking only that sets of strings are subsets of each other
08:41:21 <warbo> is there a well-known package which would use a tree, for example?
08:41:22 <petrus> geekosaur: No, no blaming here. still think the situation is not ideal, maybe clearer warning in cabal doc could improve on that.
08:41:37 <phadej> not that strings are substrings of each other?
08:41:47 <warbo> phadej: yes, subsets; not substrings
08:41:57 <phadej> warbo: there is `containers` which gives you Set with efficient enough `isSubsetOf` operation
08:41:57 <warbo> I started out with lists of Data.Text.Text
08:42:08 <phadej> well, then try containers first
08:42:11 <warbo> I'm currently looking at bitset
08:42:16 <phadej> that's too far
08:42:19 <phadej> try `Set` first
08:42:19 <warbo> but that needs Enum
08:42:23 <geekosaur> ghc would somehow have to know that cabal has placed this file as part of a library, it's not something cabal can sanely tell it and all it has to go by is "you imported this and oh hey, there's source in the local source tree". which is why cabal warns not to set things up that way
08:42:34 <phadej> you talk about sets, then you should use Set first
08:42:42 <geekosaur> telling you not to use the same source dir for different components
08:42:58 <phadej> i.e. you didn't get it "right"
08:43:25 <geekosaur> ghc can never get this one right without reading the mind of the build system (or the user if they're relying on --make instead of a build system)
08:43:44 <petrus> without telling the side effects
08:44:22 <petrus> and no ghc needs no mind reading just options to convey this info
08:44:39 <phadej> I still don't understand, why you won't simply put them in different directories
08:44:57 <petrus> as it was mentioned before
08:44:59 <phadej> to me it's just good engineering practice, to keep source code of different components separate
08:45:34 <petrus> phadej: I don't. I just discovered that by accident.
08:45:47 <geekosaur> petrus, you'd need optiosn which amount to the build systtem dumping its entire build plan just in case. which is mindreading, for this purpose, except in thi case the build system would be dumping its mind into ghc
08:46:11 * hackage yesod-test 1.6.8 - integration testing for WAI/Yesod Applications  https://hackage.haskell.org/package/yesod-test-1.6.8 (MaxGabriel)
08:46:18 <phadej> it would be nice if cabal could be able to control ghc more, but it's not the case now. case closed.
08:46:35 <phadej> as said, there's simple workaround: use it.
08:47:37 <petrus> phadej: "case closed. as said, there's simple workaround: use it." nice thanks
08:50:55 <nshepperd1> Couldn't cabal stop ghc from recompiling a module by providing its compiled .hi and .o files to ghc explicitly
08:50:56 <phadej> it's just way harder to change than it might seem
08:51:39 <phadej> currently Cabal doesn't know anything about .hi or .o files
08:51:45 <phadej> it just tells GHC where to put them, and that is
08:51:55 <phadej> it's not as simple.
08:52:05 <phadej> *that simple.
08:52:09 <nshepperd1> Poor ignorant cabal
08:52:22 <shapr> we have the technology, but who has the time?
08:52:31 <phadej> well, it's unfortunate that ghc has --make to begin with
08:52:52 <phadej> which results that build tools aren't really orchestrating the build
08:53:08 <shapr> it was great when that's all we had!
08:53:13 <phadej> they just setup stuff and let ghc do the build
08:53:18 <phadej> shapr: yes, exactly
08:53:38 <phadej> but IMHO it should be removed, but there's no alternative
08:53:41 <phadej> "it's good enough"
08:54:08 <nshepperd1> Turns out cabal is neither a package manager nor a build system
08:54:27 <phadej> nope, it's "middle management"
08:54:55 <phadej> more concretely discussing https://github.com/ghc-proposals/ghc-proposals/pull/245 doesn't seem to be as fun as bikeshedding on recordset syntax
08:56:25 * shapr reads
08:56:42 <phadej> it would be very nice if that's get eventually implemented, but I'm not holding my breath
08:56:54 <phadej> (or even accepted first, so it can be implemented)
09:02:03 <nshepperd1> I implemented a python script that regex-matches import lines to solve that problem
09:05:42 * hackage stratosphere 0.46.0 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.46.0 (jdreaver)
09:05:49 <phanimahesh> Haskell tooling leaves a lot to be desired. I don't even understand most of it, I just know enough to get going. Which is basically just stack
09:07:00 <phanimahesh> I noticed that over here people prefer cabal. I don't understand the nuances, why one over the other.
09:07:12 <AWizzArd> phanimahesh: could you maybe mention a few things that you desire and which are absent?
09:07:53 <phanimahesh> Dead code elimination is _technically_ possible but happens in a very.. I don't know, primitive manner?
09:09:00 <phanimahesh> AWizzArd: stack kind of just works for me. Automatic sandboxes, caches stuff. Brings and manages its own ghc.
09:09:26 <phanimahesh> Never tried cabal much. I don't know what is missing from cabal honestly
09:09:34 <AWizzArd> phanimahesh: did you use some kind of debugger or code analyzer to discover that dead code is not eliminated?
09:10:20 <AWizzArd> phanimahesh: I think Cabal was worse in the past and thanks to the existence of Stack it improved. Now they might be on par, don’t know. Some people combine Nix with Cabal. I will be looking into that as well.
09:10:58 <phanimahesh> AWizzArd: I mean tree shaking. simply adding an import increases binary size. Unused code is not automatically excluded.
09:11:17 <phanimahesh> It doesn't get executed, but is kind of still part of the binary
09:11:40 <phadej> it's not with --split-sections
09:12:07 <phanimahesh> I thought it was split-objs that does tree shaking?
09:12:32 <phadej> split-obj is old thing which didn't scale, --split-sections scales better
09:12:48 <phanimahesh> By creating one object file per top level function. I mean it works, but "feels" clunky.
09:13:06 <phanimahesh> Oh. I haven't looked at split-sections
09:13:11 <AWizzArd> phanimahesh: are there possibly some compiler switches that need to be turned on? I once read that Haskell is doing whole-program-optimization, and that should include dead code elimination, in my understanding.
09:13:46 <phadej> split-sections is one section per "top level function"
09:13:52 <phadej> but one object file
09:14:02 <phadej> something that contemporary linkers can deal better with
09:14:15 <phanimahesh> AWizzArd: it most definitely doesn't by default. I tested. Whole program optimisation does not happen beyond file/module boundaries for most optimizations as far as I understand
09:14:41 <warbo> AWizzArd: GHC compiles/optimises per-module
09:14:55 <AWizzArd> phanimahesh: Interesting. I would have thought that I can include as many libs as I want – the unneeded code won’t end up in my exe.
09:15:08 <phanimahesh> Nope. Unused imports bloat up eses
09:15:12 <phanimahesh> * exes
09:15:20 <warbo> it does include some things in the result which can be used in subsequent optimisation (e.g. definitions for inlining)
09:15:27 <phanimahesh> phadej: Thanks. This looks interesting.
09:16:01 <warbo> AWizzArd: one way to help dead code elimination is to use explicit export lists
09:16:18 <phadej> https://downloads.haskell.org/~ghc/8.4.2/docs/html/users_guide/phases.html#ghc-flag--split-sections
09:16:26 <warbo> if a module defines A, B and C but only exports A, then B and C can be safely eliminated if possible
09:16:47 <warbo> without an explicit export list, A, B and C could all be imported by other modules, so none cn be eliminated
09:18:03 <AWizzArd> warbo: I would want to build a lib that exports a, b and c. And then I want to develop an app, which only uses something from c. Then i would want the minimal functionality of a and b, but not more, in my binary.
09:19:36 <dsal> Is there a thing to combine (a -> Bool) functions together?   Something like this:   a &*& b = liftA2 (&&) a b
09:19:53 <warbo> AWizzArd: ah, my Haskell-level knowledge isn't enough for that (I would guess maybe link-time trickery, or LLVM plugins, or something like that)
09:20:11 <berndl> dsal: Yeah. Bool is a monoid (in two ways), so you have two choices.
09:20:26 <phadej> dsal: in lattices you can use /\
09:20:29 <dsal> That's what I was looking for...
09:20:31 <phadej> for both bools and (a -> Bool)s
09:20:33 <phadej> and other stuff
09:21:06 <dsal> Hmm...  I wonder what I was looking for that didn't show me the monoid instances.
09:21:44 <berndl> dsal: Well, the monoid instances of Bool are newtype-wrapped.
09:21:55 <berndl> They're called Any and Some I think.
09:22:05 <berndl> Or All and Any.
09:22:09 <berndl> I forget.
09:22:19 <dsal> Yeah, Any and All
09:22:26 <goolord> https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Monoid.html#g:2
09:26:12 <dsal> I see it now.  I'm trying to figure out how to make it not be terribly inconvenient. 
09:26:42 <nshepperd1> Just define your own alias for liftA2 (&&)?
09:27:47 <dsal> Yeah, I did that above.  Just seemed like it'd be easier.
09:30:36 <jle`> dsal: yeah if you postcompose All then it can work if you use <>, but it might be inconvenient in a one-off thing
09:30:47 <jle`> but if you're doing like a list it can be nice
09:31:19 <jle`> :t foldMap (All.)
09:31:21 <lambdabot> Foldable t => t (a -> Bool) -> a -> All
09:31:33 <jle`> :t getAll . foldMap (All.)
09:31:35 <lambdabot> error:
09:31:35 <lambdabot>     • Couldn't match type ‘a -> All’ with ‘All’
09:31:35 <lambdabot>       Expected type: t (a -> Bool) -> All
09:32:12 <jle`> :t (getAll.) . foldMap (All.)
09:32:14 <lambdabot> Foldable t => t (a -> Bool) -> a -> Bool
09:32:46 <phadej> :t all
09:32:47 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
09:32:50 <phadej> :t any
09:32:52 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
09:33:15 <phadej> :t \x -> any ($ x)
09:33:16 <lambdabot> Foldable t => a -> t (a -> Bool) -> Bool
09:35:08 <jpcooper> Is there anything like http://hackage.haskell.org/package/vector-sized-1.4.0.0/docs/Data-Vector-Sized.html, but with instances of Traversable, Foldable and so on defined instead of defining those functions separately? Or is there a reason why they are defined separately?
09:35:38 <koz_> jpcooper: Data.Vector.Sized has instances of all those type classes.
09:36:08 <koz_> We need specialized versions for Data.Vector.{Unboxed, Storable}.Sized because they can't be legal members of those type classes.
09:36:28 <koz_> s/members/instances/
09:36:37 <jpcooper> Oh, I see instances in http://hackage.haskell.org/package/vector-sized-1.4.0.0/docs/Data-Vector-Generic-Sized.html
09:37:05 <jpcooper> Thanks again
09:37:33 <koz_> jpcooper: No worries. It can be a bit confusing at first, but it's got to do with how each of those are differently represented.
09:37:52 <koz_> And some of those representations are 'too specialized' to be instances of a lot of type classes, including the ones you mentioned.
09:38:11 <jpcooper> Makes sense
09:38:55 <tabaqui1> what I really cannot understand is the classes with duplicate methods with different signatures
09:39:06 <tabaqui1> one is more specialized and another is less specialized
09:39:27 <tabaqui1> https://hackage.haskell.org/package/monad-logger-0.3.30/docs/Control-Monad-Logger.html#t:MonadLogger
09:39:29 <jle`> tabaqui1: that's a haddock 'glitch'
09:39:30 <tabaqui1> for example
09:39:38 <jle`> tabaqui1: it's the -XDefaultSignatures signature
09:39:47 <jle`> the less specialized one is the actual signature
09:39:58 <jle`> the more specialized one is the one that the default implementation requires
09:40:12 <jle`> but it's a "bug" in haddock that they display the smae way
09:40:24 <tabaqui1> oh, ok
09:40:41 <koz_> Yeah, this is a tad obnoxious.
09:41:00 <jle`> so basically if you write `instance MonadLogger MyMonad` and leave it blank, it'll fill in with the default instance
09:41:10 <jle`> default implementation
09:41:17 <jle`> but the default implementation requires those extra instances
09:41:20 <jle`> *constriants
09:47:50 <tabaqui1> btw, can I mix DefaultSignatures with TypeFamilies?
09:48:17 <tabaqui1> like "class Foo a where type Bar a; default Bar ::..."
09:51:36 <koz_> tabaqui1: Yes. Check it out here: https://hackage.haskell.org/package/finitary-1.2.0.0/docs/src/Data.Finitary.html
09:51:51 <koz_> (search 'type Cardinality' to find the bit I'm referring to)
09:52:03 <koz_> (I unfortunately cannot link to a line number in this view :()
09:53:39 <tabaqui1> I see the type, but it is not what I wanted to
09:54:22 <koz_> As I understand it, you want a default associated type.
09:54:27 <tabaqui1> I would like to use smth, like "default Bar x :: (MonadTrans t, x ~ t m) => Bar m
09:56:14 <tabaqui1> Cardinality has a default declaration, but it doesn't depend on instance constraints
09:57:30 <koz_> I don't think you can constrain an associated type like that, default or not.
09:58:00 <koz_> (you can see that I had to jam the KnownNat constraint into the _class_ definition, not the associated type)
09:58:09 <tabaqui1> it seems so
09:58:17 <tabaqui1> thanks anyway
09:58:21 <koz_> No worries.
10:05:56 <exarkun> Can Options.Applicative define an option such that `--foo a --foo b` results in [a, b]?
10:06:02 <exarkun> I can't see it
10:11:53 <amalloy> exarkun:   http://hackage.haskell.org/package/optparse-applicative-0.15.1.0/docs/Options-Applicative.html#v:flag-39- seems to suggest just using many
10:12:15 <amalloy> there's nothing for it in optparse-applicative because the thing you need is already in Control.Applicative
10:13:29 <exarkun> ah, thanks
10:17:03 <amalloy> i remember having the same question when i first used regex-applicative: what kind of regex package doesn't have concat or alternation operators?
10:17:26 <leo_> amalloy: Yeah!
10:17:36 <leo_> I was gonna post a question that I think is related to that
10:17:45 <leo_> In attoparsec, for instance, how to accumulate parsers into a list?
10:18:40 <leo_> e.g string "bla" ... char 'j' ... string "bli" resulting in "blajbli"
10:18:43 <amalloy> what do you mean, accumulate parsers into a list? do you mean you have a list of parsers, and you'd like a list of their results?
10:18:48 <leo_> yep.
10:19:17 <amalloy> well, in this case you don't have a list of aprsers
10:19:26 <amalloy> because string "bla" and char 'j' have different types
10:19:44 <jpcooper> koz_: I've been thinking about the "BiDistributive" idea a bit more. Actually my example involves a type `class sh`, where all instances are of the form `Z :. Int :. Int :. Int` for some number of `Int`s. What I want is the ability to "unwrap" values of type `IR (sh :. Int)`, having a function that takes `IR (sh :. Int)` to `IR sh :. IR Int`. Is there really no existing term for this?
10:20:22 <leo_> amalloy: sure enough, but it's easy to massage char 'j'
10:20:31 <amalloy> so if you want a list, first you'd want to write: pure <$> char 'j'
10:20:46 <leo_> sure.
10:21:13 <amalloy> but supposing you have ps :: [Parser String], you then have (concat <$> ps) :: Parser String, no?
10:21:15 <koz_> Z :. Int ... :. Int is basically [Int] under a slightly different name.
10:21:28 <amalloy> no, that's nonsense
10:21:44 <amalloy> it's probably traverse concat or something
10:21:55 <koz_> :t traverse concat
10:21:57 <lambdabot> (Traversable t1, Foldable t2) => t1 (t2 [b]) -> [t1 b]
10:22:46 <amalloy> concat <$> sequenceA ps feels inelegant
10:22:59 <jpcooper> koz_: Not quite. `Z :. Int :. Int` also encodes the length. It's similar to a sized vector of Ints
10:23:07 <nshepperd> it oughta be fold :: [Parser String] -> Parser String
10:23:10 <koz_> jpcooper: How does it do that?
10:23:16 <nshepperd> if Parser has the correct monoid instance
10:24:05 <jpcooper> koz_: class Shape sh, instance Shape Z, instance Shape sh => Shape (sh :. Int)
10:24:39 <amalloy> :t fold
10:24:41 <lambdabot> (Foldable t, Monoid m) => t m -> m
10:24:45 <jpcooper> So I first thought, why not just define a function to and from Shape sh to sized vectors of Ints, but that doesn't quite work, as it misses the recursive idea
10:25:19 <leo_> fold it is. .-.
10:25:24 <leo_> Thanks!
10:25:28 <leo_> Thanks amalloy.
10:25:34 <amalloy> neat, i didn't know about fold
10:25:55 <leo_> I forgot. xd
10:26:07 <EvanR> wow ok, two different convos. I was like... parsing a sized vector of ints
10:26:16 <koz_> jpcooper: Are you perhaps seeking https://hackage.haskell.org/package/vec?
10:26:40 <nshepperd> https://hackage.haskell.org/package/attoparsec-0.13.2.3/docs/src/Data.Attoparsec.Internal.Types.html#line-198 noooo
10:27:07 <nshepperd> instance Monoid (Parser i a) where mempty  = fail "mempty" :/
10:27:08 <EvanR> :'(
10:27:34 <nshepperd> they just copied the Alternative instance to the Monoid instance >:(
10:27:36 <EvanR> for only 7 cents a day you can help these abandoned and deformed Monoid instances...
10:27:50 <EvanR> they need your help
10:27:56 <dmwit> Why does this qualify as a "nooooo"? This is the Alt instance, and perfectly cromulent.
10:27:56 <jpcooper> koz_: That looks closer than vector-sized. I have a good feeling that the Distributive instance of vec is exactly what is needed
10:28:05 <jpcooper> koz_: Thanks again
10:28:09 <koz_> jpcooper: I had the same sentiment. You're welcome!
10:28:11 <nshepperd> dmwit: the correct instance is (<>) = liftA2 (<>)
10:28:20 <dmwit> There are at least two correct instances.
10:28:24 <dmwit> Which is why Ap and Alt both exist.
10:28:30 <nshepperd> if you need the Alt instance you can use asum!
10:28:32 <dmwit> Alt is a perfectly fine choice, especially for parsers.
10:28:47 <dmwit> foldMap : fold :: ? : asum
10:29:11 <nshepperd> it's redundant to have monoid and alternative do the same thing
10:29:25 <dmwit> It's redundant to have monoid and applicative do the same thing.
10:29:59 <EvanR> Monoid allows things Applicative doesn't because of the uniform types
10:30:10 <EvanR> it can be different
10:30:41 <EvanR> i.e. fold
10:30:49 <dmwit> EvanR: Are those two statements intended to support one of "use Ap as the default" or "use Alt as the default"?
10:31:17 <nshepperd> monoid and applicative don't do the same thing
10:32:18 <nshepperd> leo_: so anyway, don't use fold
10:33:04 <nshepperd> leo_: you'll need 'foldMap Ap' instead
10:33:07 <EvanR> so how do you do Parser [m] -> m using Applicative
10:33:58 <leo_> .-.
10:33:59 <dmwit> You don't. You do [Parser m] -> Parser m
10:34:46 <nshepperd> dmwit: the redundancy of (<>) = (<|>) is very different to the 'redundancy' of (<>) = liftA2 (<>)
10:35:05 <dmwit> I agree they are different. So what?
10:35:07 <nshepperd> (and yes, asumMap should exist)
10:35:18 <EvanR> where is / what is Ap ?
10:35:34 <dmwit> ?hoogle Ap
10:35:35 <lambdabot> Data.Monoid newtype Ap f a
10:35:35 <lambdabot> Data.Monoid Ap :: f a -> Ap f a
10:35:35 <lambdabot> Test.Tasty.Runners newtype Ap f a
10:37:34 <nshepperd> dmwit: so obviously the latter instance is better, because it's less redundant
10:37:44 <dmwit> I didn't agree it was less redundant.
10:37:58 <EvanR> wow that's handy
10:37:59 <nshepperd> well, you should
10:38:18 <dmwit> hm =)
10:38:25 <nshepperd> just having two names for the same function is very redundant indeed
10:39:30 <EvanR> yeah Alternative instances make me think of choices, <> makes me think of smushing. But only because the method names are mappend and mconcat
10:39:46 <EvanR> and the preponderance of existing instances
10:39:56 <Lears> Alternative already exists to capture a monoid on the Functor structure which is independent of the embedded values. It seems pretty weird to me to mirror that exactly in the Monoid instance when Applicative guarantees you a sane way to map an underlying Monoid up instead.
10:40:00 <dmwit> nshepperd: Do you ever use map and (.), even though fmap exists?
10:40:44 <dmwit> Hm, okay, scratch that. I agree it's irrelevant, and I apologize for bringing it up.
10:40:55 * dmwit ponders more carefully
10:41:54 <EvanR> agreed we should rename fmap to (.)
10:42:51 <t7> haha i didn't realize (.) is the same :)
10:42:56 <dmwit> Well, I'm still on the fence. The core of the question seems to be roughly which of the two instances is more useful (or perhaps less surprising?) to end users. It's not clear to me that redundancy has much bearing there.
10:42:58 <t7> mind blown
10:43:02 <Lears> Imo, `Ap` only exists because of when we have a /third/ choice that's better, not because you ever want `Alt` to be the default.
10:43:49 <chessai> Lears: what are you talking about? i'm missing some context
10:43:53 <dmwit> It's not clear to me that one behavior or the other seems more canonical.
10:44:13 <dmwit> (If I just sit down to the question of "I want to combine some parsers, which is the thing I expect?".)
10:44:17 <chessai> that `Ap` is a redundant version of `Alt`?
10:44:55 <nshepperd> <> = <|> has the unfortunate effect that if you're not expecting it, your code will compile but just do the wrong thing
10:45:16 <EvanR> when this convo started, i totally thought <> on parsers would <> the results
10:45:18 <Lears> chessai: No, we're using `Ap` and `Alt` as stand-ins for potential Monoid instances for Applicatives. The argument is whether a Monoid instance that copiers the Alternative instance is sane/expected.
10:45:22 <dmwit> I don't think you can fix that by choosing a different implementation. If your mental model doesn't match the code, you will be surprised.
10:45:44 <chessai> Lears: oh ok
10:45:58 <nshepperd> no, but if <> = liftA2 (<>), there's a good chance your code will error out due to missing monoid instance if you expect it to be <|>
10:46:14 <dmwit> I see.
10:46:35 <dmwit> Perhaps we should not have a Monoid instance, so that it errors out even more. =P
10:46:45 <dmwit> (Facetious.)
10:47:08 <EvanR> yeah more errors is better, javascript + case in point
10:47:49 <dmwit> I mean, I guess there are definitely types where we chose that solution.
10:47:54 <dmwit> Bool, Int e.g.
10:47:58 <nshepperd> pragmatically, I have often wanted to combine the output of parsers with <>, and end up writing my own operator to do it. but i never find myself reaching for <> to combine parsing alternatives
10:48:06 <nshepperd> why would I, when I've got <|> and asum
10:50:11 <dmwit> I think I could lean a bit towards Ap being better in this case. But I don't yet see myself in the camp where Alt being the existing choice makes me sad.
10:51:22 <EvanR> currently "there's more than one way to do it (<|>)", which is usually how haskell works :)
10:51:45 <EvanR> but in this case, how many ways do you need
10:53:40 <EvanR> .oO( if you only had Alternative then you aren't compatible with Writer or something parameterized on Monoid )
10:59:51 <koz_> . o O (everything in Haskell is State or a monoid)
11:01:51 <lavalike> koz_: so you're saying everything in Haskell is a Monoid! (State is!)
11:02:27 <koz_> lavalike: Lol, this is true.
11:02:38 <koz_> Monoids are like turtles - all the way down.
11:02:57 <EvanR> i feel cheated because almost nothing in haskell is a Group
11:03:00 * koz_ mumbles something about monoids on the category of endofunctors.
11:03:04 <tabaqui1> anyway, you always get a Monoid for free
11:03:15 <tabaqui1> literally from everything
11:03:19 <tabaqui1> *can get
11:10:38 <nshepperd1> Get your monads for nothing, and your monoids for free
11:12:54 <Curly_dev> Hello
11:28:25 <EvanR> exactly how do you get a monoid from literally anything again
11:29:33 <nil> Monoid [a], where a is literally anything
11:30:02 <EvanR> k
11:30:11 <lavalike> EvanR: the free structure construction
11:30:22 <EvanR> anti-climactic :)
11:30:30 <lavalike> hehe
11:30:36 <Curly_dev> data Line = L [Int] 
11:30:53 <Curly_dev> How do i ... traverse [int] ?
11:31:20 <EvanR> monotraversable... or upgrade the line to Line a
11:33:24 <Cale> You can use the Traversable instance for [] directly
11:33:37 <Curly_dev> how?
11:33:38 <Cale> Or you can just write mapM like a normal person
11:33:43 <Cale> lol
11:34:16 <nil> i don't understand the question
11:34:22 <Curly_dev> you can lol however you want. 
11:34:27 <Cale> I'd pattern match away the L data constructor by matching against L xs or something and then write something like forM xs $ \x -> do ...
11:34:41 <Curly_dev> oh now you are talking
11:34:41 <Cale> or mapM (...) xs
11:35:59 <EvanR> online :: ([Int] -> [Int]) -> Line -> Line
11:36:20 <Curly_dev> but i want the other way around like 
11:36:38 <Curly_dev> traverse:: Line -> [Int]
11:37:00 <Cale> oh, you don't mean
11:37:03 <Cale> :t traverse
11:37:04 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
11:37:11 * hackage small-bytearray-builder 0.3.1.0 - Serialize to a small byte arrays  https://hackage.haskell.org/package/small-bytearray-builder-0.3.1.0 (andrewthad)
11:37:12 <EvanR> bait and switch!
11:37:19 <Cale> You just mean traverse in the plain sense of the English word :)
11:37:49 <Cale> Yeah, you can just write something like lineElems (L xs) = xs
11:38:01 <EvanR> data Line = L { unline :: [Int] }
11:38:24 <Cale> yeah, or just use record syntax like that, and you'll get a function Line -> [Int] for extracting the field
11:40:05 <Curly_dev> yeah (L xs) = xs works... but how and why ....... it takes ... what?
11:40:15 <Curly_dev> takes the list and drops the L ?
11:40:17 <Cale> It takes a Line
11:40:42 <Curly_dev> Yeah but if i show L it shows L [1,2,3] but taking xs it takes [1,2,3]
11:40:44 <Cale> and that data declaration says that every value of type Line is formed by applying L to some list of Int values
11:41:13 <Curly_dev> Well fair enough
11:41:16 <Curly_dev> Thank you
11:41:21 <Cale> and so yeah, we're allowed to pattern match against the "data constructor" L, and capture the thing that L was applied to when building the Line
11:41:38 <Cale> (really it's just grabbing a pointer)
11:41:45 <Curly_dev> There is any documentation about this?
11:41:52 <Curly_dev> Because i didn't find anyyything online
11:44:18 <merijn> Curly_dev: How are you learning Haskell? (What book/tutorial/whatever) because pattern matching is a pretty fundamental and crucial part of the language
11:44:40 <EvanR> pattern match all the things
11:45:26 <Cale> Yeah, this is something that probably should have been mentioned even before data declarations were introduced, if not at the same time.
11:46:18 <Curly_dev> Well it's a college course but this isn't anywhere in the courses
11:46:24 <Curly_dev> I didn't even know (L xs) is valid
11:46:30 <Curly_dev> What i learned is (x:xs) is valid 
11:46:44 <Cale> ah, so that's an example of the same thing, but with the list data type instead
11:46:59 <Curly_dev> but its not ... because if i do M:xs it gives an error
11:47:00 <Cale> The infix : operator is one of the data constructors for lists
11:47:13 <Cale> So you're allowed to match against it
11:47:28 <Cale> and bind its arguments to variables (or other patterns)
11:47:48 <EvanR> > let xs = [1,2,3] in 0:xs
11:47:50 <lambdabot>  [0,1,2,3]
11:48:06 <Cale> > let (x:xs) = [1,2,3] in (x, xs)
11:48:07 <EvanR> > let (0:xs) = [0,1,2,3] in xs
11:48:08 <lambdabot>  (1,[2,3])
11:48:08 <lambdabot>  [1,2,3]
11:48:17 <EvanR> example fight!
11:48:48 <Curly_dev> well yeah  i know that [] it's flavour for 1:2:[]
11:49:05 <Curly_dev> or whatever but that L xs there is nowhere to be found
11:49:30 <EvanR> : is a 2-arg constructor
11:49:33 <EvanR> L is a 1-arg constructor
11:49:38 <EvanR> same thing
11:50:10 <txdv> i have a list [[1,2]], i want to use lenses to modify the first element inside of the first list, how do I do that?
11:52:07 <Curly_dev> Still doesn't make any sense why it drops the L
11:52:41 <aveltras> is there an obvious way to implement Value -> (Int, Value) with Aeson ? it's some kind of incomplete decoding of the value
11:52:42 * hackage aws-lambda-haskell-runtime 2.0.2 - Haskell runtime for AWS Lambda  https://hackage.haskell.org/package/aws-lambda-haskell-runtime-2.0.2 (NickSeagull)
11:52:50 <EvanR> why f in  f (L xs) = xs  drops the L ?
11:52:55 <Curly_dev> yes
11:53:04 <EvanR> if you read it literally it's literally true
11:53:23 <EvanR> if some expression has a f (L xs) in it, that can be substituted with xs
11:53:41 <EvanR> due to the defining equation
11:53:42 * hackage tz 0.1.3.3 - Efficient time zone handling  https://hackage.haskell.org/package/tz-0.1.3.3 (MihalyBarasz)
11:53:54 <Curly_dev> I am gonna be even more dense: L is what in this context?
11:54:03 <EvanR> your original data type was like
11:54:08 <EvanR> data Line = L [Int]
11:54:16 <EvanR> L is the constructor
11:54:41 * hackage Taxonomy 2.0.0 - Libary for parsing, processing and vizualization of taxonomy data  https://hackage.haskell.org/package/Taxonomy-2.0.0 (FlorianEggenhofer)
11:54:47 <EvanR> it's a wrapper around a list
11:56:03 <Curly_dev> so i could have made it a bit more nicer if i put a property on that data and said :"give me the list"?
11:56:40 <EvanR> well, record syntax is a feature on top of data types. It produces accessor functions for you
11:56:58 <EvanR> you could have used it. But also pattern matching comes up a lot anyway
11:57:13 <EvanR> it can be more convenient than accessor functions
11:58:59 <EvanR> joinLine (L xs) (L ys) = L (xs ++ ys)
11:59:19 <EvanR> as opposed to joinLine l1 l2 = L (unline l1 ++ unline l2)
11:59:26 <EvanR> joinLine l1 l2 = L (unline l1 ++ unline l2)
12:00:50 <Curly_dev> this thing doesn't make too much sense
12:00:53 <Curly_dev> but yeah it works now :)
12:00:53 <EvanR> to me the first one is more natural and informative
12:01:47 <EvanR> have you been playing around in ghci
12:02:15 <Curly_dev> Well yes i done stuff... but this one was out of the blue with no help
12:02:23 <Curly_dev> We barely touched data
12:03:10 <EvanR> if you understand lists, then you understand almost the most complicated data
12:03:43 <Curly_dev> Yes but again... (L xs) this is magic
12:04:48 <EvanR> but do more data examples like  data Triple a = Tri a a a;  data Either a b = Left a | Right b;  data Stream a = a :| Stream a
12:05:19 <Curly_dev> Well this is the next course
12:34:42 * hackage tree-sitter 0.6.0.0 - Unstable bindings for the tree-sitter parsing library.  https://hackage.haskell.org/package/tree-sitter-0.6.0.0 (tclem)
12:38:42 * hackage tree-sitter-python 0.7.0.0 - Tree-sitter grammar/parser for Python  https://hackage.haskell.org/package/tree-sitter-python-0.7.0.0 (tclem)
12:39:26 <dsal> > let l = [[1,2]] in    l & ix 0 . ix 0 .~ 5  -- txdv 
12:39:28 <lambdabot>  [[5,2]]
12:40:50 <EvanR> :t ix 0 . ix 0
12:40:51 <lambdabot> (Applicative f, Ixed m, Ixed (IxValue m), Num (Index m), Num (Index (IxValue m))) => (IxValue (IxValue m) -> f (IxValue (IxValue m))) -> m -> f m
12:45:46 <refusenick> Are there friendlier guides to Cabal's v2-* commands than the docs? I like them better than Stack's docs, but a "do's and don'ts" tutorial would be much appreciated.
12:46:25 <phadej> I'm not aware of anything up to date (not even out of date even)
12:49:05 <txdv> dsal: nice, thank you!
12:51:10 <refusenick> phadej: The v2-* commands are still pretty new (Emacs' haskell-mode thinks they're still prefixed new-* and doesn't handle them right), so I imagine finding an out-of-date one would be difficult. 
12:51:46 <refusenick> As annoying as I find stack, I might be forced to switch back to it if I can't get Emacs to play nice with the new Cabal.
12:52:48 <shapr> refusenick: ooh, whatcha doin?
12:53:06 <shapr> I'm using cabal + emacs
12:53:11 <shapr> what functionality is broken?
12:53:51 <merijn> shapr: Yeah, but are you using v2-build?
12:54:00 <shapr> uh, v3 ?
12:54:25 <merijn> shapr: There is no v3-build, presumably you mean 3.0 (which is using v2-build, yes)
12:54:34 <shapr> yup
12:54:39 <shapr> in v3 it's just 'build'
12:55:25 <shapr> I'm using haskell-interactive to load modules into an in-emacs ghci
12:55:38 <shapr> I also have stylish and hlint enabled
12:56:29 <shapr> this is my config: https://gist.github.com/shapr/586fb27ec7b0c1e05c6413693af99626
12:56:59 <shapr> I also have flycheck-haskell enabled, I can add that.
12:57:35 <refusenick> shapr: Thanks! That's basically where I am, except for that I also have lsp-haskell with ghcide.
12:58:02 <shapr> oh, I haven't tried that. What's it do?
12:58:52 <shapr> now I'm interested
13:05:11 <refusenick> shapr: It does all the usual LSP stuff (refactoring & error messages across a project)
13:16:16 <Curly_dev> Hello, there is any resources oriented for OOP people? With some exercises at the end like interactive? There is anything like that? (this is where i am right now http://learnyouahaskell.com/making-our-own-types-and-typeclasses ) so i would like a better resource
13:17:47 <dsal> Curly_dev: haskellbook.com is pretty great.  Having OOP experience will make your life harder in general, but I found that book to be good if you can start from the premise that you don't know things.  :)
13:18:37 <EvanR> a book that "undoes the damage" of an OOP education would be interesting
13:18:53 <EvanR> and would never sell
13:19:17 <Curly_dev> Not really undo, but explaining more into recursive and some parallels with the OOP
13:19:47 <dsal> “It is practically impossible to teach good programming to students that have had a prior exposure to BASIC: as potential programmers they are mentally mutilated beyond hope of regeneration.”
13:19:54 <Curly_dev> like foldr being explained in recursive in C would make it way more obvious than how was explained to me
13:20:09 <merijn> Naah, that's nonsense I learned Haskell fine after OOP
13:20:12 <EvanR> explaining foldr in terms of recursive C is going to be an uphill battle
13:20:20 <dsal> merijn: I'm not saying it's impossible.  It's just harder.
13:20:26 <merijn> Naah
13:20:27 <EvanR> foldl' in terms of recursive C is doable
13:20:42 <dsal> Curly_dev: IME, the "slow" path will save you a lot of time.
13:21:01 <merijn> Curly_dev: Anyway, I can very quickly explain all the parallels to OOP
13:21:08 <merijn> Curly_dev: "There are, essentially, none"
13:21:11 * hackage BiobaseHTTP 1.2.0 - Libary to interface with the Bioinformatics HTTP services - Entrez Ensembl  https://hackage.haskell.org/package/BiobaseHTTP-1.2.0 (FlorianEggenhofer)
13:22:04 <merijn> Curly_dev: For imperative languages in general there are more parallels in the form of do notation, but I don't think those are particularly helpful beyond the obvious ones that no one has to point out
13:22:43 <EvanR> also this thread has a volatile dependence of "what OOP means"
13:22:52 <EvanR> dependence on
13:23:17 <merijn> dsal: Most people who learn Haskell learn it after learning something else first and I'm willing to wager that a solid 90% or more of those people know at least one OOP language, so saying "knowing OOP will make it harder", etc. is nonsense
13:23:21 <EvanR> also the original question was for a resource... i'm also interested in the answer to that
13:23:28 <dsal> I initially learned OOP from the school of Bertrand Meyer / Eiffel.  It's almost entirely different in java and then almost entirely different again in smalltalk.
13:24:03 <leo_> https://github.com/bos/attoparsec/issues/48
13:24:07 <merijn> It's just that unlike many other languages where knowing another language will make things easier to learn, that's just not the case for Haskell, unless you know (S)ML or Ocaml or F#
13:24:11 <leo_> merijn: Why mempty instead of fail?
13:24:14 <EvanR> yeah i think some schools of OOP do have an analog in Haskell City
13:24:33 <leo_> I can think of reasons, but would like to hear you, considering you already here. .-.
13:24:36 <merijn> leo_: It's *empty*, not mempty
13:24:47 <merijn> leo_: And empty *is* fail
13:24:50 <merijn> :t empty
13:24:51 <lambdabot> Alternative f => f a
13:25:10 <leo_> fail without a message.
13:25:37 <leo_> https://github.com/bos/attoparsec/issues/95
13:26:00 <merijn> leo_: I suppose, but that message is going to be generic to the point of uselessness and you can add your own message on parse error anyway
13:26:00 <dsal> merijn: It's harder to teach people who have to unlearn.  Trying to understand constructs in relation to things you already know that are inaccurate models makes things confusing.  That's why I find pretending I know nothing to get to a useful state a lot faster.  I don't have a *broad* experience teaching, but anecdotally, I've found people who don't assume they know things easier to teach than those who do.
13:26:16 <leo_> Hmpf.
13:26:49 <leo_> bos said `fail is definitely not the right function to be using here, sorry.`
13:26:55 <leo_> What he meant?
13:27:37 <dsal> I'm not on the Dijkstra level there.  It's not impossible.  I've unlearned almost everything I ever knew about java.  It feels like losing weight and gaining muscle tone.
13:30:15 <merijn> dsal: I've TAed functional programming for people who only knew C and Java for 5 years in a row, and feel fairly confident in saying that's your exaggerating to the point where it's just harmful and demotivating for people no good reason
13:30:31 <refusenick> Any advice on Haskell + Org Mode?
13:30:49 <dsal> merijn: Alright, then.
13:30:54 <merijn> Yes, lots of people struggle, but then all the people I've helped/taught Haskell that *didn't* know an OO language *also* struggled
13:31:41 <merijn> I haven't taught enough of the second category to say that it's exactly the same, but it doesn't appear to be drastically less struggle, they just struggle with different things
13:31:54 <dsal> I definitely don't mean to be demotivating.  I'm just trying to encourage taking things a bit slower rather than looking for translations.
13:31:59 <merijn> Like "why would I even wanna do all these things with a list, it seems so pointless"
13:32:34 <merijn> I mean, I think any attempt at directly translating is not going to work, but that's more because you end up structuring code very differently to do things
13:33:17 <Curly_dev> Yes but it's less frustrating when you want to do something ... and you can't 
13:33:27 <EvanR> there is plenty of say about haskell from the angle of knowing bog standard OOP stuff first
13:33:44 <Curly_dev> Something like doing the sum of all lists in a lists and get the maximum is hard
13:34:13 <EvanR> :t concatMap
13:34:15 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
13:34:24 <EvanR> % :t concatMap @[]
13:34:24 <yahb> EvanR: (a -> [b]) -> [a] -> [b]
13:34:38 <EvanR> knowing about higher order library functions is good
13:35:12 <Curly_dev> Still its "knowing" versus be able to do it by just by doing 2 for loops and 2 arrays
13:35:34 <EvanR> yeah, processing arrays of things is the #1 thing that will be different in functional programming
13:35:45 <EvanR> different and easier
13:35:55 <dsal> > let maxsum = maximum . map sum  in  maxsum [[1, 2, 3], [4, 5, 6]]
13:35:57 <lambdabot>  15
13:36:15 <EvanR> you need to break the problem up into steps though
13:36:35 <EvanR> > maximum [1,6,4,3,1]
13:36:37 <lambdabot>  6
13:37:13 <EvanR> > maximum (map maximum [[12],[2,3,4],[1,6,4,3,1]])
13:37:14 <lambdabot>  12
13:37:37 <EvanR> now you avoided looping and manual arrays
13:38:29 <Curly_dev> i am not gonna lie: let maxsum = maximum . map sum  in  maxsum [[1, 2, 3], [4, 5, 6]] 
13:38:31 <dsal> We don't have 'for' loops as such, but that's a flaw in a lot of languages.  There are a few really common ways to consume a list that are worth learning.  It's hard to write much of anything without map.
13:38:47 <Curly_dev> thats still gives me trouble
13:39:00 <EvanR> maximum (map sum [[1,2],[3,4],[5,6]])
13:39:03 <EvanR> more clearly
13:39:15 <dsal> Curly_dev: It's two different things, as EvanR said.  The first is adding up all the sublists.  Then asking for the maximum.
13:39:24 <dsal> :t map
13:39:26 <lambdabot> (a -> b) -> [a] -> [b]
13:39:31 <dsal> :t sum
13:39:33 <lambdabot> (Foldable t, Num a) => t a -> a
13:39:43 <EvanR> % :t sum @[]
13:39:43 <yahb> EvanR: Num a => [a] -> a
13:39:48 <dsal> Yes, that. heh
13:39:53 <dsal> > sum [1, 2, 3]
13:39:56 <lambdabot>  6
13:40:02 <dsal> > map sum [[1, 2, 3], [4, 5, 6]]
13:40:04 <lambdabot>  [6,15]
13:40:10 <dsal> > maximum (map sum [[1, 2, 3], [4, 5, 6]])
13:40:12 <lambdabot>  15
13:40:24 <Curly_dev> Well not really that one but this one : sum in maxsum [[1, 2, 3], [4, 5, 6]] 
13:40:32 <Curly_dev> like whats up with in ? and maxsum?
13:40:40 <dsal> I defined maxsum in my example.
13:40:42 <EvanR> that was ancillary to the example
13:40:49 <EvanR> dsal was naming a new function
13:41:01 <geekosaur> let <bindings> in <expression>
13:41:18 <geekosaur> which is the proper form of "let"; the truncated one in "do" expands to it
13:41:28 <EvanR> > let x = 9 in (x,x,x)
13:41:29 <lambdabot>  (9,9,9)
13:41:44 <Curly_dev> Eh ...
13:41:59 <EvanR> let bindings
13:42:08 <EvanR> this exists in other languages too
13:42:15 <EvanR> and should exist in all of them!
13:42:18 <dsal> Curly_dev: what language  are you coming from?
13:42:27 <Curly_dev> Java
13:42:44 <dsal> Oh man.  I managed to forget everything  I ever knew about java.  Pretty helpful, but not in this exact case.
13:42:46 <Curly_dev> Well i am more of a full stack so i have some knoweldge in others as well
13:42:58 <Curly_dev> But this one this is ... hard i think?
13:43:18 <EvanR> in the body of a let expression, you can use the variables that you defined in the bindings
13:43:21 <Curly_dev> I see where it's coming from but there are important bits stashed away
13:43:28 <EvanR> very convenient
13:43:39 <Curly_dev> Yes i looked into ghci and understood the syntax
13:43:40 <EvanR> local variables essentially
13:43:49 <dsal> Curly_dev: haskell is actually quite easy.  It's just not like ones you're used to.
13:44:04 <Curly_dev> AIt'
13:44:08 <Curly_dev> It's anything but easy
13:44:33 <Curly_dev> It feels i need to do extra stuff every time i want something simple
13:44:35 <dsal> Nah, it's the easiest language I work in regularly.  You just don't know it yet.
13:45:09 <EvanR> after enough haskellisms you kind of appreciate the peculiar wackiness that algol family came up with way back when, that everyone (but haskell) uses now
13:45:10 <dsal> The thing you were describing above is just   "maximium . map sum"   -- that's a lot more simple than "building two arrays and writing for loops over them"
13:45:43 <jle`> Curly_dev: after a while you'll start feeling the opposite ;)  in other languages you have to do extra stuff every time you want something simple
13:46:01 <EvanR> Curly_dev: well, when everything simple requires loops, ifs, and array munging... that seems like extra stuff to me
13:46:04 <jle`> Curly_dev: the difference is the things you find as simple will be different (and possibly unrelated from before)
13:46:11 <refusenick> shapr: How do you add a new library to a project? I have something installed globally (via "cabal v2-install --lib") which I'd like to pull into a project. How do I tell it to use the installed version?
13:46:15 <dsal> Your problem statement was "the sum of all lists in a lists and get the maximum"  -- My implementation is   "maximum . map sum"  :)  It's very close to your question.  :)
13:46:16 <jle`> yeah, imagine having to allocate a new array and a new variable just to find a maximum value ...
13:46:48 <jle`> Curly_dev: imagine trying to explain to someone who has never programmed before the two different ways you might approach finding the maximum of sumds of list
13:46:54 <geekosaur> refusenick, if it
13:46:56 <EvanR> you get int the groove of anything after a while
13:47:01 <jle`> Curly_dev: what do you think is simpler: myFunc xs = maximum (map sum) ?
13:47:02 <geekosaur> s a cabal v2 project, just add the dep
13:47:19 <jle`> Curly_dev: or: do two for lists by allocating variables. .. loop over them, i < n ...
13:47:24 <EvanR> myFunc xs = maximum (map sum) xs
13:47:26 <jle`> * myFunc xs = maximum (map sum xs)
13:47:29 <EvanR> dangit
13:47:44 <EvanR> mistake cascade
13:47:50 <jle`> heh
13:47:57 <refusenick> geekosaur: Adding it to the cabal config file for the project and saving it does weird things.
13:48:04 <shapr> refusenick: what kind of weird things?
13:48:16 <shapr> v2-install is all about not having anything globally installed
13:48:22 <jle`> Curly_dev: it's just really hard for me to reasonably say that the nested for loop example is 'simpler' than just finding the maximum of the sums, maximum (map sum xs)
13:48:25 <geekosaur> it won't use the v2-install-ed one in that case, though, because that basically exposes a library for non cabal-v2 stuff to use
13:48:27 <shapr> it's nix-style builds where everything is independent
13:48:45 <jle`> maximum (map sum xs) is something that any third grader who knows what sums and maximums are can understand
13:48:48 <Curly_dev> It's still 2 loops no matter how oyu put it
13:48:57 <dsal> Curly_dev: is it?
13:48:59 <EvanR> i don't agree
13:49:01 <Curly_dev> Just the fact that haskell hides it and you need to think about it
13:49:16 <geekosaur> although I suppose ghc could find it and become confused as to which to use; ghc-envronment files sometimes have surprising results
13:49:19 <jle`> Curly_dev: so in this case, the "extra stuff you have to do" is...allocate variables, do a loop, etc.
13:49:27 <EvanR> sometimes haskell's abstractions are really really abstract
13:49:28 <Curly_dev> Yes but it's visible
13:49:29 <jle`> Curly_dev: don't you agree that the imperative method is the one with the extra stuff you have to do?
13:49:34 <refusenick> I added it to the deps. Do I need to run cabal v2-configure now?
13:49:38 <EvanR> and it doesn't map to what you think it does
13:49:40 <jle`> Curly_dev: and the functional version is the one with less extra stuff you have to do?
13:49:49 <shapr> refusenick: for most things I just do "cabal build"
13:49:55 <geekosaur> it should do that itself after recomputing the buildl plan
13:49:58 <EvanR> it's better to think about the abstraction instead sometimes
13:50:03 <shapr> or cabal run
13:50:12 <geekosaur> i.e.. it should recognize that things changed and rerun configure
13:50:13 <EvanR> especially when the implementation is quite efficient
13:50:16 <Curly_dev> jle` i agree, functional has less extra stuff
13:50:33 <geekosaur> these days you don't generally need to manually configure, install deps, etc.; that was cabal v1's workflow
13:50:35 <geekosaur> v2 is smarter
13:50:58 <dsal> Curly_dev: In haskell, we generally write things closer to the things we want.  *how* it gets done isn't the thing we have to write down most of the time.
13:51:01 <jle`> Curly_dev: this is a normal thing when people start learning haskell with a background from other languages ... they carry all this 'extra stuff' baggage from their history and it freaks them out when the extra stuff isn't there in haskell
13:51:07 <EvanR> Curly_dev: so with the proper data structure, a maximum operation can be done in parallel. Then thinking of it as a loop is not only too concrete, it's not corresponding to any real process
13:51:24 <dsal> The hugely liberating thing here is that when you decide you want to do something different, it's a much smaller refactoring when you don't have to undo all of the hows and write new hows.
13:52:11 <jle`> to learn how to do this in an imperative language ... you literally have to go over the theory of mutable variables, references, the syntactic structure of for loops, off-by-one errors, control flow
13:52:23 <jle`> what it even means to have control flow in the first place
13:52:31 <Curly_dev> Wow wow wow. Not that far
13:52:41 <Curly_dev> For something elementary it's just easy stuff. 
13:52:51 <jle`> i mean, for an example like this, how do you get around that?
13:52:53 <Curly_dev> More about the imperative one, you can hack your way into things
13:53:10 <jle`> for someone already experienced with programming and an imperative mindset, sure
13:53:32 <EvanR> Curly_dev: for example if you had a binary tree, the maximum of (Branch l r) is max (maximum l) (maximum r). This could be implemented as a loop, but given the right implementation could be parallelized
13:54:04 <EvanR> given the right implementation would actually be faster
13:54:17 <EvanR> *hypothetically
13:54:34 <dsal> :t Map.splitRoot
13:54:35 <lambdabot> error:
13:54:35 <lambdabot>     Not in scope: ‘Map.splitRoot’
13:54:35 <lambdabot>     Perhaps you meant one of these:
13:54:39 <EvanR> This operation actually is made faster in a distributed maximum
13:54:48 <dsal> I massively parallelized an app using splitRoot
13:54:51 <dsal> :t M.splitROot
13:54:52 <lambdabot> error:
13:54:52 <lambdabot>     Not in scope: ‘M.splitROot’
13:54:52 <lambdabot>     Perhaps you meant one of these:
13:54:54 <dsal> :t M.splitRot
13:54:55 <lambdabot> error:
13:54:56 <lambdabot>     Not in scope: ‘M.splitRot’
13:54:56 <lambdabot>     Perhaps you meant one of these:
13:54:56 <dsal> damnit, nevermind
13:55:40 <jle`> splitRot is what happens to hair that isn't properly taken car of
13:55:42 <dsal> Anyway, I needed parallel traversal of a large map.  Program got many times faster and I didn't have to think about normal concurrency bugs.
13:55:52 <EvanR> really, impressive
13:56:17 <dsal> Also, splitRoot is like, O(1) (though I had to call it multiple times because it only approximately cuts the map in half)
13:58:12 <dsal> Then there's par...  which I'd completely forgotten about.
13:58:20 <EvanR> Curly_dev: even without parallelism, many situations you would write a big loop in are actually faster when lazy evaluation happens. I guess my point is, it's as important to keep the abstractions in mind as well as the concrete machinery. Since many things "don't care how you do it"
13:59:40 <EvanR> sorry for jumping down your throat about asserting something as simple as "it's still a loop"
14:01:32 <dsal> > maximum . fmap sum $ Just (Just 3)
14:01:35 <lambdabot>  3
14:01:49 * dsal still wishes map == fmap
14:02:04 <EvanR> spare the poor person x . y $ z constructions :(
14:02:14 <dsal> Yes, sorry...
14:02:55 <dsal> The point is that it works with many different data structures in many different shapes.  In this case, there's no conceptual loop at all even for the thing that might have one or two loops.
14:03:52 <dsal> Curly_dev: We have a few common operators that look foreign and perly at first, but you get used to them quickly.  I did the thing off the top of my head and not the thing  that a newcomer would read the most easily.
14:04:10 <refusenick> What's the proper way to add deps into a Cabal file and restart the Emacs Haskell process so it stops giving me "this package is hidden" errors?
14:04:29 <EvanR> x (y z) -- ahh....
14:04:30 <yushyin> Curly_dev: if you wanted to, you *could* do it with 2 folds and a map, which is just more verbose and maybe resembles 2 loops a bit more :)
14:05:34 <dsal> The only slight confusion is that maximum is partial.
14:06:21 <EvanR> hmm yes we should delve into total functional programming at this point :)
14:06:41 <refusenick> Reading Haskell configuration failed with exit code 1 and output:
14:06:49 <refusenick> It just says that.
14:07:42 <koz_> How many microseconds to a second again?
14:07:48 <EvanR> million
14:08:02 <EvanR> 10^6
14:08:32 <EvanR> think of me as highly compact and energy efficient google
14:08:37 <dsal> I'm a little frustrated with how things that want time just take Int.  That gets pretty annoying.
14:09:05 <koz_> EvanR: So are you going to serve me targeted ads now?
14:09:16 <EvanR> yes. Stand By
14:17:18 <mpickering> Is `th-expand-syns` a reliable package?
14:19:12 * hackage tree-sitter-java 0.5.0.0 - Tree-sitter grammar/parser for Java  https://hackage.haskell.org/package/tree-sitter-java-0.5.0.0 (tclem)
14:19:58 <dsal> Curly_dev: Sorry to gang up on you.  We're an enthusiastic community.  :)  I've had production code in java, go, c, c++, objective c, javascript, ruby, scheme, smalltalk, perl, python,  r, eiffel, and surely more I can't remember.  The issues I have with haskell aren't as much with the language as they are about getting things built on obscure targets I run. heh
14:20:01 <koz_> I have a library stanza and an executable stanza in my .cabal, with the name of the library as a build-depends for the executable stanza. However, when I 'cabal new-build', I get complaints about missing home modules.
14:20:04 <koz_> Am I doing something wrong?
14:20:07 <refusenick> https://0x0.st/z6G9.txt
14:20:21 <koz_> s/library as a/library stanza as a/
14:22:27 <refusenick> shapr: That's one of the errors I'm getting.
14:23:11 <doublex_> Curly_dev, there's really only one thing you need to learn for this example. Maximum, map, and sum are all folds: https://rextester.com/HQR48516
14:24:43 <dsal> doublex_: Reading that comes with a few dependencies.  :)
14:26:12 * hackage tree-sitter-json 0.4.0.0 - Tree-sitter grammar/parser for JSON  https://hackage.haskell.org/package/tree-sitter-json-0.4.0.0 (tclem)
14:26:44 <koz_> Can I have a Vector of IORefs or is there some special structure for that?
14:26:57 <EvanR> a mutable Vector ?
14:27:16 <koz_> EvanR: So just a regular MVector IO would work fine?
14:27:30 <merijn> koz_: Well, it depends
14:27:49 <EvanR> the good thing about vectors is there's so many to choose from
14:27:49 <koz_> merijn: Each async job gets a dedicated position which only it can write to.
14:27:50 <merijn> koz_: I mean, you can certainly have a vector of IORef's, but if that makes sense depends on *why*
14:28:16 <merijn> koz_: And when they're done, they're done?
14:28:40 <koz_> The async jobs spin for the entire lifetime of the program. So yes, I guess?
14:28:51 <EvanR> sounds like an immutable vector of unsafeInterleaveIOs would work
14:28:58 <merijn> koz_: So they're continuously updating that position, or what?
14:29:02 <koz_> merijn: Yeah.
14:29:06 <koz_> Someone else reads.
14:29:07 <EvanR> oh nevermind
14:29:07 <merijn> ENOTENOUGHINFO ;)
14:30:17 <koz_> So basically, for the entire lifetime of the program, I have one 'writer async job' for each position of this array, which can't touch anything else, and some other async jobs read.
14:30:20 <koz_> (but they can't write)
14:31:05 <merijn> I'm not sure why they'd be in a vector?
14:31:21 <koz_> I figure it's easier to keep track of than a lot of separate IORefs.
14:31:30 <EvanR> skeptical
14:35:29 <koz_> I guess I should re-read The Book (the one on concurrency and parallelism) again. I kinda skated on the concurrency parts last time, so maybe I might answer my own questions.
14:36:04 <EvanR> there shouldn't be a problem with 1 thread continually writing to the IORef and the other threads reading from it
14:36:07 <merijn> koz_: What are you doing? i.e. what are these threads doing, who/what is consuming things?
14:36:20 <koz_> merijn: It's a bunch of file watches.
14:36:22 <EvanR> the vector ended up being a red herring!
14:36:59 <koz_> So the idea is they each keep an eye on a particular file, and scribble the state of said file into an IORef.
14:37:03 <EvanR> but so might the rest of it be
14:38:13 <koz_> It's fine - I think I need to think about my problem some more.
14:38:22 <koz_> I'll get back to you once I have a more coherent question.
14:51:42 * hackage massiv-io 0.1.9.0 - Import/export of Image files into massiv Arrays  https://hackage.haskell.org/package/massiv-io-0.1.9.0 (lehins)
14:57:00 <mpickering> Anyone understand "[__1] rejecting: base-4.13.0.0/installed-4.1... (conflict: hie-lsif => base^>=4.12.0.0 && <5)" ?
14:57:43 <merijn> mpickering: That's...odd
14:57:54 <dmwit> 4.13 doesn't meet the constraint ^>=4.12
14:58:04 <dmwit> Because ^>=4.12 means >=4.12 && <4.13
14:58:05 <merijn> Oh, wait, yeah, duh
14:58:23 <mpickering> why is it legal to write ^>= && <?
14:58:38 <merijn> mpickering: Well, why not?
14:58:39 <dmwit> Because --allow-newer will relax the first part but not the second.
14:59:13 <merijn> mpickering: How could we possibly enforce something sane on arbitrary combinations of && and || with ranges? That sounds rather hard
14:59:15 <dmwit> So --allow-newer will let you make an attempt to build with newer bases; but <5 says "I really don't promise to even attempt to work if we have entered a whole new regime of Haskell".
14:59:38 <mpickering> Because clearly I did not mean ^>>= && < ...
14:59:55 <dmwit> Well... that's not clear to me.
15:00:02 <dmwit> Dunno how you're imagining that would be clear to a machine.
15:00:38 <mpickering> You said it means >= 4.12 && < 4.13 which makes the < 5 constraint redundant
15:00:46 <dmwit> I lied.
15:00:52 <mpickering> but then apparently it does something different to --allow-newer
15:00:54 <dmwit> What I said was only true to a first approximation.
15:01:16 <dmwit> Because the second approximation is that it `^>=4.12` and `>=4.12 && <4.13` behave differently with respect to --allow-newer.
15:01:22 <merijn> mpickering: X ^>= says "I am known to work with anything that's PVP compatible with X, starting from X
15:01:36 <monochrom> Once again I call into question that when someone asks "why?" what does that really mean.
15:01:52 <dmwit> I gave you the first approximation because it was a v. quick explanation of why your build failed.
15:01:59 <monochrom> Like is it curiosity or is it a complaint.
15:02:07 <dmwit> I thought it didn't make sense to try to descend all the way to quantum mechanics, so I had to cut my explanation off somewhere.
15:02:19 <monochrom> or maybe s/complaint/objection/
15:02:54 <mpickering> I actually want to understand why this operator exists and why it's in my cabal file
15:02:55 <monochrom> Like I am sure as hell when I say "why don't you try it" it is rhetorical not curious.
15:03:25 <mpickering> but I am also a bit annoyed that it's in my cabal file at all when they have worked without this operator for a seemingly long time
15:03:57 <merijn> mpickering: ^>= exists to distinguish between "known to work with X (and might work with later)" from "we *definitely* know it won't work with something newer than X"
15:04:18 <mpickering> So I read the manual now and apparently ^ >>= only has a different meaning if you use `^ foo` in `allow-newer` and otherwise it just expands to dmwit's suggestion
15:04:20 <phadej> very subtle difference
15:04:22 <merijn> mpickering: If you only have "< X" you don't know if that's "someone being defensive with upperbounds" OR "we know it won't work with X"
15:04:39 <merijn> mpickering: ^>= unambiguously says "the former" of those two
15:04:49 <phadej> I think only merijn, hvr and myself "know" that difference :)
15:04:50 <merijn> mpickering: Mich means we can start treating "<X" as the latter
15:05:00 <mpickering> so you are supposed to always use ^>>=
15:05:05 <merijn> mpickering: Ideally
15:05:08 <mpickering> unless you have reason to use >>= && <
15:05:23 <phadej> mpickering: you have amonad day? :)
15:05:59 <merijn> mpickering: Assuming you are okay with the cabal-version restriction that implies, ^>= should be preferable/default to use, yes
15:06:03 <mpickering> but how can you use ^>>= if it works with multiple versions?
15:06:08 <koz_> TIL. Thanks folks!
15:06:21 <dmwit> I think (>=2.0 && <5.0) || ^>=4.9 would be sensible, and doesn't *only* use ^>=.
15:06:22 <merijn> (It enforce cabal-version: 2.0 or later)
15:06:25 <mpickering> Say my package works on 0.2 and 0.3 but I don't know about 0.4
15:06:37 <monochrom> I agree "^>=4.12 && <5" is redundant. But now this splits into two questions because two parties are involved. Why the Cabal devs allow this redundancy, and why whoever wrote your *.cabal file have this redundancy.  I believe the answer to both is "too lazy to eliminate, stamp out, get rid of redundancies".
15:06:44 <merijn> mpickering: In the newest version of the cabal spec there's a set notation
15:07:09 <dmwit> Sorry, I mean (>=2.0 && <4.9) || ^>=4.9
15:07:13 <phadej> btw, cabal-version: 2.0 has
15:07:14 <phadej> build-depends: network ^>= { 2.6.3.6, 2.7.0.2, 2.8.0.0, 3.0.1.0 }
15:07:31 <merijn> phadej: Set notation is cabal-version 3.0, I thought?
15:07:34 <mpickering> ok that's too annoying so I will just use > 
15:07:38 <phadej> merijn: typo
15:07:40 <phadej> 3.0 yes
15:08:14 <mpickering> there is so much annoying stuff managing and releasing packages
15:08:26 <mpickering> Ryan and you Oleg are just a sight to behold
15:08:37 <phadej> mpickering: I have tools
15:08:51 <phadej> i'm just very lazy to make them usable for others :(
15:09:01 <phadej> (well, maybe haskell-ci is usable by others)
15:09:19 <mpickering> yeah I just used it
15:09:29 <phadej> cabal-fmt also improved my life editing .cabal files
15:09:46 <phadej> I can sleep well, knowing that all fields are properly aligned
15:10:06 <mpickering> also something I have no time for 🙃
15:10:16 <mpickering> something I do have time for though, is sleeping
15:10:29 <merijn> mpickering: Story of my life... ;)
15:10:48 <mpickering> thanks for your help merijn dmwit phadej  and monochrom 
15:11:04 <phadej> I wonder how much manyears is spent aligning code manually
15:11:14 <phadej> in all small and niche languages
15:11:16 <phadej> e.g. Isabelle
15:11:44 <monochrom> I think I just press "tab" in emacs.
15:11:45 <phadej> (i.e. where people don't use emacs which could potentially have some macro for aligning stuff)
15:12:14 <phadej> monochrom: not only indenting, aligning
15:12:22 <phadej> you know = under = and so on
15:13:13 <monochrom> Oh, I seldom do that.
15:13:27 <monochrom> But I guess I am not enough data points.
15:13:42 <merijn> Just lower your expectations!
15:13:44 <phadej> mpickering: and remember ^A, the ultimate key for bumping bounds
15:13:46 <merijn> Great way to solve any problem!
15:14:06 <phadej> though I haven't found a way to make it increase the last number on the row
15:15:10 <monochrom> You know, because there is such a thing as burn-out, time spent aligning code does not completely take away from time spent thinking or writing code.
15:16:32 <monochrom> i.e., if I spent one fewer hour aligning, this does not translate into one more hour thinking.  That one hour is either aligning or idling.
15:16:32 <phadej> monochrom: I lose thread of thought (and get demovitated by) if I have to do some busy work in between
15:16:49 <monochrom> Yes.
15:17:04 <phadej> as in, aligning is something which still needs concentration, to get it right
15:17:23 <monochrom> But there are times your thread of thought is done and you're resting anyway.
15:17:29 <phadej> but aligning code is not the same as doing ASCII art
15:17:46 <monochrom> I think no one disputed that?
15:17:52 <phadej> ... then I'd rather format some ASCII art in the comment in the header of the file!
15:17:55 <phadej> not aligning the code :P
15:18:25 <EvanR> have I lost my mind. Next question, `VU.!` doesn't work??
15:18:41 <phadej> anyway, I have macros for that, so I don't really manually align anything nowadays
15:18:46 <ziman> that's already infix
15:18:46 <monochrom> Sure. So now I ask how many people-hours are "wasted" on ensuring that "/**********************/" has the right length etc etc.
15:18:50 <EvanR> oh
15:18:57 <ziman> without the backticks
15:19:13 <monochrom> (In this case my answer is still "I seldom do it" :) )
15:19:16 <phadej> monochrom: I have snippet which puts the right ------------------------------------ to the code :0
15:19:40 <phadej> so I don't count those either, but they are consistent along code I have written in past 2-3 years
15:20:01 <koz_> If I cabal new-build an executable, where can I find the actual executable it makes for me?
15:20:25 <phadej> koz_: if you install cabal-plan executable, than cabal-plan list-bins or list-bin exename will tell you
15:20:36 <phadej> otherwise there are various hacks, which may or may not work
15:20:40 <evelyn> phadej: editor macros, you say...?
15:20:43 <phadej> evelyn: yes
15:20:45 <merijn> koz_: You can install them, or you can use lifehacks to test while developing
15:20:58 <koz_> I guess I can install cabal-plan.
15:21:09 <merijn> koz_: Why are you trying to find them?
15:21:22 <merijn> koz_: Wouldn't either install or run suffice?
15:21:26 <monochrom> The cabal user's guide also has a section describing how to find the exe.
15:21:39 <monochrom> It's a bit of a long story though.
15:21:51 <koz_> merijn: Because I'm gonna be distributing this executable as part of a bunch of other stuff to students.
15:22:23 <phadej> monochrom: does it? that's surprising, as that place is really hard to predict
15:22:45 <phadej> koz_: then installing and `which exename` would work as well
15:22:48 <merijn> koz_: Then install would suffice to copy them somwhere, no?
15:22:55 <koz_> I guess that works too.
15:23:00 <monochrom> Oh "new-install" is hard to predict but this is "new-build"
15:23:01 <merijn> phadej: Well, you could even just override the install dir to be .
15:23:02 <koz_> I'm gonna try phadej's suggestion too.
15:23:25 <merijn> monochrom: new-install hard to predict in 3.0 in earlier versions it was just half finished
15:23:39 <phadej> merijn: well, you have to follow symlinks or specify install method to be copy, not easy either in the long run
15:23:55 <merijn> I just configure cabal to always copy >.>
15:24:11 <merijn> More reastically, when not distributing things I tend to just use something like: https://paste.debian.net/1117184/
15:24:21 <phadej> well, you /have/ to do that; cabal v2-build; cabal-plan exe-name is as good
15:25:23 <monochrom> Heh "extra lines to satisfy spam protection"
15:25:43 <merijn> monochrom: It wanted at least 3 linebreaks or it'd reject the paste
15:25:43 <phadej> maybe list-bin and list-bins is something which is stable and useful enough to be added to cabal proper
15:26:14 <phadej> it's just some much fun to not hack cabal's cli parser
15:26:36 <merijn> phadej: Trigger warning :(
15:26:53 <phadej> O.o
15:27:12 * hackage ansi-terminal 0.10.2 - Simple ANSI terminal support, with Windows compatibility  https://hackage.haskell.org/package/ansi-terminal-0.10.2 (mpilgrem)
15:27:30 <merijn> phadej: For mentions of modifying the cabal CLI parser stuff >.>
15:27:38 <monochrom> I was on a web forum that insisted on minimum message length too, something like "at least 12 bytes".  But I was answering simple student questions like "do we have to deal with empty strings?" and the answer would be simply "yes".  Fortunately the web forum supported html.  So I replied "<span>yes</span>"
15:27:52 <phadej> merijn: I think I'll end up doing it in 2021, i'm morally preparing
15:28:23 <phadej> oh
15:28:24 <phadej> `hGetTerminalSize` now assumes a terminal is no bigger than 9,999 by 9,999 (previously, no bigger than 999 by 999).
15:28:38 <phadej> that's definitely solving year 2019 problem
15:28:56 <phadej> 999 wide terminal, is... quite wide
15:29:19 <phadej> mine is 282
15:29:34 <merijn> phadej: Godspeed in your battles with that code ;)
15:30:08 <monochrom> Now you can play Battleship on a 9999x9999 grid.
15:30:19 <monochrom> Or 9999x9999 Go.
15:30:37 <Axman6> Omega Go
15:30:41 <Curly_dev> Ok ... flash question... how do you print a new line in ghci? Because "\n" doesn't work
15:31:07 <phadej> putChar '\n'
15:31:12 <phadej> or putStrLn ""
15:31:16 <Axman6> putStrLn ""
15:31:47 <Curly_dev> Ok and lets say i need to do a string... do i just do that ? 
15:31:57 <phadej> putStrLn string
15:31:57 <koz_> monochrom: That's a _long_ game of Battleship.
15:32:01 <dsal> Curly_dev: Most of the time, I don't print anything in ghci.  It'll show you the last thing you evaluated.
15:32:07 <Axman6> I don't know what "do a string" means :\
15:32:18 <Curly_dev> Yeah my teacher is a piece of sh...
15:32:27 <Axman6> I doubt that
15:32:28 <monochrom> Every student says that in IRC.
15:32:31 <phadej> :D
15:32:36 <dsal> % putStrLn "this is (probably) a string printed with a newline"
15:32:37 <yahb> dsal: this is (probably) a string printed with a newline
15:32:39 <monochrom> Every student on IRC are liars.
15:32:41 <koz_> Curly_dev: There's a non-zero chance this person is in this channel. :P
15:33:04 <Axman6> Curly_dev: fun fact: if they're teaching Haskell, they're probably in here, or we know them. *The More You Know*
15:33:33 <Axman6> I've caught my students in here before when I was tutoring
15:33:39 <TheCommieDuck> https://pastebin.com/y8VSKXpd If I have some nested sum types, then I can do compose prisms. x = A1 5, fx = UnifiedA (A1a x), fx ^? _UnifiedA . _A1a. But is there a nice way to automagically make that composition without having to manually write it out? just a nice automatic fx ^? _A1a. 
15:33:59 <monochrom> Are your students a piece of csh? >:)
15:34:00 <Curly_dev> Can i call putStrLn "" in a derived show?
15:34:13 <monochrom> No.
15:34:18 <Axman6> TheCommieDuck: classy prisms get you some of the way there
15:34:40 <phadej> TheCommieDuck: https://hackage.haskell.org/package/lens-4.18.1/docs/Control-Lens-TH.html#v:makeClassyPrisms
15:34:41 <Curly_dev> So there is no way for me to make data structure that derives a show which can show matrix on new lines
15:34:52 <Curly_dev> Like 1 2 3 
15:35:00 <Axman6> yes there is, but that's not what you asked
15:35:01 <dsal> Curly_dev: that's not what show is for.  It's tempting to do that.  You'll eventually be sad if you did.
15:35:25 <TheCommieDuck> time to grit my teeth and get my head around classy vs regular lens/prisms :P thanks
15:35:38 <dsal> Curly_dev: Note there's a difference between "calling putStrLn (an IO action with side effects) from within show" and "putting newlines in show output"
15:35:39 <Curly_dev> Ok lets say i have [1,2,3,4,5,6] i want to start a new line if n / 3 == 0
15:35:51 <monochrom> "deriving" doesn't allow you to write your own code anyway. Your question shows wrong assumptions.
15:36:10 <Curly_dev> Ok me stupid. I want to make my own instance of Show that does that
15:36:45 <dsal> You could write one if that's what you want show to do.  Or you could just  write a pretty printing function that  does that.
15:38:10 <Curly_dev> So that means i need side effects
15:38:11 <monochrom> OK here is my hint.  There is a different between 'putStrLn "\n"' and 'putStrLn (show "\n")'
15:38:39 <monochrom> \n works but you have to use the right function.
15:40:03 <Axman6> you definitely do not need side effects
15:40:10 <Axman6> in your Show instancew
15:41:17 <dsal> The easy way to do it is a mix of chunksOf and intercalate
15:41:37 <Axman6> or unlines
15:41:52 <dsal> Oh, I never think of those functions.
15:41:54 <Axman6> and unwords actually
15:42:16 <Axman6> :t unlines . map (unwords . map show)
15:42:17 <lambdabot> Show a => [[a]] -> String
15:42:46 <dsal> Nice.  That's most of the work.
15:42:53 <Curly_dev> unlines will bring back \n
15:43:23 <Axman6> that's what a new line is
15:43:33 <dsal> Yes.  This seems to match your specification.
15:43:41 <Curly_dev> There is a difference between putStrLn will print out a \n
15:43:55 <dsal> Half of putStrLn's job is to print out a \n
15:43:56 <Curly_dev> the unlines will actually put the characters
15:44:06 <Axman6> % putStrLn "1 2 3\n4 5 6"
15:44:07 <yahb> Axman6: 1 2 3; 4 5 6
15:44:10 <dsal> unlines doesn't "put" any characters at all.  It  has no effects.
15:44:14 <Curly_dev> "aa\nbb\ncc\ndd\n"
15:44:22 <Axman6> (; means new line in yahb's output)
15:44:39 <dsal> % putStrLn "aa\nbb\ncc\ndd\n"
15:44:39 <yahb> dsal: aa; bb; cc; dd
15:50:31 <Curly_dev> And yes you are right :)
15:52:42 <TheCommieDuck> Okay cool; if I use makeClassyLenses then writing instance AsUnifiedA Foo where _A1a = _X . _A1a; _A2a = _X . _A2a etc (for Foo = X UnifiedA | ...)..but I guess I can't automagically generate this?
15:53:14 <Axman6> no
15:53:27 <dsal> Oh neat.  I didn't know about makeClassyLenses.  I've just written my own prisms in those cases.
15:53:50 <TheCommieDuck> rip. (well,makeClassyPrisms). at least it's not that bad to write myself. thank you :)
15:55:03 <Axman6> yeah you end up with instance ... where _A1 = _X and that's all you need
15:56:11 <TheCommieDuck> do I not need to do it for every A2, A3, An... etc and also for the id case?
15:56:43 <Axman6> nope, only the one which points to the type, there are detaults for the others
15:56:56 <TheCommieDuck> oh - then excellent. :D
15:58:54 <Curly_dev> Axman6 i don't see it but if the string is with \n if you make your own instance of show it uses putStrLn
16:00:35 <Axman6> show has nothing to do with putStrLn. putStrLn will write a string to the terminal. if that string containt \n then it will write to a new line
16:00:58 <Curly_dev> Yeah but i don't need the function at all it's simple as
16:01:14 <Curly_dev> instance Show X where  show m = f $ linii $ m
16:01:17 <Curly_dev> Where f returns a string
16:01:31 <EvanR> if you don't need any I/O you don't need putStr or putStrLn
16:01:44 <EvanR> in fact they would be useless
16:01:58 <Curly_dev> if i call my function it will just show \n but when i put it in the instance of Show it will be shown properly
16:02:21 <Axman6> no... but if that gets you to write the correct code then sure
16:02:22 <EvanR> if you call your function and there's no I/O... you don't see anything. GHCI is a special case
16:02:39 <Axman6> show is just a function from a to String, thet's all it is
16:02:39 <Curly_dev> Axman6 what do you mean no?
16:02:43 <Axman6> that's*
16:03:37 <Curly_dev> Yes but what gets called when you make your own instance of show?
16:03:38 <dsal> % (putStrLn . show . show . show . show) "a\nb"
16:03:38 <yahb> dsal: "\"\\\"\\\\\\\"a\\\\\\\\nb\\\\\\\"\\\"\""
16:03:40 <EvanR> > snd (show 3, False)
16:03:42 <lambdabot>  False
16:03:47 <EvanR> show didn't do anything
16:03:50 <Axman6> ththe only thing special about show is that it is used in GHCi to print values when you evaluate them 
16:03:52 <dsal> Curly_dev: You're not calling show on the output of show are you?
16:04:18 <Curly_dev> Ok lets reiterate. What i am saying is if you do data X = L [V]
16:04:23 <EvanR> (show is badly named)
16:04:32 <Axman6> if you just type 1 at the prompt, ghci will use its Show instance to print it to the terminal
16:04:45 <Curly_dev> and you do a instance Show X where show x = code here
16:04:46 <Axman6> it is literally applying print to your value to display it
16:04:49 <Axman6> :t print
16:04:51 <lambdabot> Show a => a -> IO ()
16:04:52 <Axman6> @src print
16:04:52 <lambdabot> print x = putStrLn (show x)
16:05:11 <Curly_dev> i am not talking about the function show i am talking about the instance of a data 
16:05:24 <dsal> Curly_dev: show is the same as toString in java, except it's far easier in  java to make toString() do more than just return a  string.
16:06:21 <Curly_dev> Ok big question. When you say deriving Show
16:06:34 <Curly_dev> What function gets called on the string that Haskell does behind the scene?
16:06:47 <dsal> That question is a bit confusing.
16:06:58 <EvanR> show doesn't print anything
16:07:03 <EvanR> it's a conversion function only
16:07:06 <Curly_dev> you can print any string ...
16:07:10 <dsal> "deriving Show" just means a Show instance is written for you.
16:07:11 <EvanR> not with show
16:07:17 <Curly_dev> Correct is written for you
16:07:25 <Curly_dev> That means it's a function that returns a string
16:07:37 <EvanR> yeah a pure function, no side effects
16:07:39 <Curly_dev> What function is called upon that string so that it shows in your console?
16:07:53 <EvanR> functions don't have effects, or I/O
16:07:56 <EvanR> so none
16:08:01 <dsal> Well, you were using putStrLn above.  That's an example of a thing that prints a string to console.
16:08:09 <Axman6> really it's the compiler doing that for you, it's part of the definition of the language that the compiler must eb able to derive Show for "normal" data types
16:08:21 <Curly_dev> Well ... the problem here is 
16:08:36 <Curly_dev> that when you do a Instance of a Show, Haskell does behind the scene putStrLn
16:08:39 <Curly_dev> for functions is putStr
16:08:46 <dsal> it absolutely does n ot
16:08:46 <EvanR> uhm no
16:08:52 <Axman6> no
16:08:52 <Curly_dev> You can try it
16:08:54 <EvanR> show doesn't do I/O
16:09:00 <EvanR> deriving doesn't do I/O
16:09:01 <Axman6> it absolutely, 100% does not do that
16:09:03 <dsal> :t putStrLn
16:09:04 <lambdabot> String -> IO ()
16:09:05 <Curly_dev> Try it
16:09:14 <EvanR> nah
16:09:20 <Curly_dev> I just bashed my head around this
16:09:25 <Curly_dev> My functions returns just a string
16:09:38 <dsal> putStrLn is in the IO monad.  It can't be called from something not in the IO monad.
16:09:48 <EvanR> yeah it can
16:09:49 <Axman6> Curly_dev: do you honestly think that we don't know what we're talking about? I mean, I'm paid to write Haskell every day, I've been doing it for 12 years
16:10:00 * dsal tries to avoid unsafe* conversations
16:10:01 <Curly_dev> In a second
16:10:22 <EvanR> > (putStrLn "foo", putStrLn "bar")
16:10:23 <lambdabot>  (<IO ()>,<IO ()>)
16:10:37 <Axman6> ghci does call print on values, like I told you earlier, but thatis separate from what Show does
16:10:42 <yushyin> ghci repl calls print for the evaluated expression
16:10:44 <dsal> EvanR: Ooh.  Yes.  Right.
16:11:38 <dsal> Without unsafe, it can't be called and do the thing you think it's going to do from inside of a pure function?  :)
16:11:53 <EvanR> calling functions isn't what does I/O
16:12:19 <Curly_dev> Well it does in a terminal isn't it?
16:12:24 <EvanR> no
16:12:27 <Curly_dev> Otherwise you would never see anything
16:12:32 <EvanR> see
16:12:54 <EvanR> > Nothing
16:12:56 <lambdabot>  Nothing
16:13:17 <EvanR> > (print 1, print True)
16:13:19 <lambdabot>  (<IO ()>,<IO ()>)
16:13:30 <Curly_dev> Again what i am saying is simple
16:13:36 <EvanR> Nothing isn't a function. calling print didn't do any I/O
16:13:46 <dsal> Curly_dev: does toString in java print to console when you call it?
16:13:56 <EvanR> show == toString
16:14:02 <Curly_dev> Ok
16:14:15 <Curly_dev> so when i am deriving Show on Data
16:14:16 <Curly_dev> What it does?
16:14:24 <dsal> What does what?
16:14:30 <EvanR> implementing show
16:14:35 <Curly_dev> Deriving Show
16:14:40 <Curly_dev> data V= L [Int]    deriving Show
16:14:45 <EvanR> it implements show
16:14:50 <Curly_dev> and show does what?
16:14:50 <dsal> It writes a show function  for you.  Similar to writing a toString() in java.
16:14:54 <dsal> :t show
16:14:55 <lambdabot> Show a => a -> String
16:14:55 <EvanR> toString
16:15:17 <Curly_dev> Good, and the ghci will show that string back to you right?
16:15:22 <Curly_dev> Because it wants to help
16:15:35 <Curly_dev> Otherwise there is no reason to Derive Show in the first place
16:15:45 <dsal> Most haskell code isn't running interactively in ghci
16:15:47 <EvanR> i don't buy that ...
16:16:19 <EvanR> ghci just prints the result of whatever you wrote
16:16:22 <monochrom> ghci calls "putStrLn (show ...)".
16:16:34 <Curly_dev> but it doesn't do that for functions output
16:16:38 <Curly_dev> And thats my problem
16:16:39 <Axman6>  data V= L [Int]    deriving Show will produce something soughly like instance Show V where show (L xs) = "L " ++ show xs
16:16:46 <dsal> > succ 3
16:16:48 <lambdabot>  4
16:16:49 <EvanR> ghci executes the result of print <whatever you wrote>
16:16:59 <Axman6> Curly_dev: are you getting errors?
16:17:01 <EvanR> difference between evaluation and execution
16:17:48 <Curly_dev> I had errors for like half an hour and trying to get to the bottom of why outputs are different between what instance of the Show of data is showing and the function output
16:18:01 <dsal> What  do you mean by "function output"  ?
16:18:14 <Curly_dev> 2 + 2
16:18:20 <dsal> > 2 + 2
16:18:22 <lambdabot>  4
16:18:22 <EvanR> yep i can imagine getting stuck for half an hour if you are this confused
16:18:32 <EvanR> the first step is admitting you have a problem
16:18:33 <Axman6> rude :P.
16:18:46 <Curly_dev> ah...
16:18:46 <Axman6> (though not necessarilly untrue)
16:18:53 <Curly_dev> i am bashing a rock here
16:19:09 <Axman6> in this channel, to evaluate haskell expressions, you need to write > some Expr
16:19:17 <EvanR> 2 + 2 is a number. When you type it in ghci, it evaluates to get a value
16:19:19 <EvanR> namely 4
16:19:22 <EvanR> THEN
16:19:25 <Axman6> but that's only so lambdabot knows you want ot execute something
16:19:25 <EvanR> it prints 4 out
16:19:29 <Curly_dev> > "\n"
16:19:30 <lambdabot>  "\n"
16:19:44 <Axman6> > show "\n"
16:19:46 <lambdabot>  "\"\\n\""
16:19:50 <EvanR> "\n" is a value, it's value is itself. Then ghci prints it out
16:19:58 <Axman6> % show "\n"
16:19:58 <yahb> Axman6: "\"\\n\""
16:20:05 <Axman6> % putStrLn $ show "\n"
16:20:05 <yahb> Axman6: "\n"
16:20:12 <Axman6> % print $ show "\n"
16:20:12 <yahb> Axman6: "\"\\n\""
16:21:10 <Axman6> I will admit that the differences between these expressions is somewhat confusing
16:21:17 <EvanR> now it's all clear :)
16:22:09 <Axman6> in GHCi, if you evaluate an expression ghci will use print to display it - unless that expression is an IO expression, then it will _execute_ that expression
16:22:49 <Axman6> si if you run writeFile "someFile" "lololol", it will write lololol to the file someFile and print nothing
16:22:54 <Axman6> so*
16:23:06 <Curly_dev> https://pastebin.com/9wNwyDJW
16:23:16 <Curly_dev> try this with M [1,2,3] and then just call a
16:23:20 <Curly_dev> and you will see the differencfe
16:23:55 <monochrom> Curly_dev, this is explained by what I said way back.
16:24:03 <Axman6> "try this" doesn't tell us what you wan t us to do
16:24:13 <EvanR> behold this
16:24:16 <EvanR> done
16:24:19 <Curly_dev> aaa see that one prints "\n" and one puts a newline
16:24:27 <Curly_dev> it's pretty easy to see the same output isn't the same output
16:24:34 <EvanR> nothing is getting prined when i load that
16:24:43 <EvanR> there's no I/O actions here
16:24:49 <Curly_dev> :|
16:24:54 <monochrom> But no one sees me so I may as well shut up.
16:25:04 <yushyin> hi monochrom
16:25:11 <yushyin> I see you
16:25:13 <yushyin> :)
16:25:14 <EvanR> we're all in the invisible room together
16:25:16 <Curly_dev> monochrom i see you. What i asked is why it happens for functions and not for the instance of Show
16:27:16 <leo_> Any reason why Conduit sometimes uses Void, sometimes ()?
16:27:44 <jle`> leo_: they mean different things :)
16:27:58 <jle`> leo_: Void is the type with zero values, () is the type with one value
16:27:58 <leo_> jle: How so? .-.
16:28:20 <jle`> admittedly it's kind of confusing coming from languages like c/java where void corresponds to () roughly
16:28:30 <leo_> Yeah.
16:28:40 <jle`> to be fair, we thought of it first >_>
16:28:50 <leo_> But I mean, Source m o = ConduitT () o m ()
16:29:02 <leo_> And then Sink = ConduitT i Void
16:29:11 <leo_> Why not Sink = ConduitT i ()?
16:29:21 <Axman6> so you know Sink ncan never return any values downstream
16:29:22 <jle`> because that implies that Sink will output ()'s
16:29:26 <leo_> Or Source = ConduitT Void o m Void ...
16:29:42 <jle`> leo_: Sink i = ConduitT i Void means that Sink will *never* output *anything*
16:29:49 <jle`> because there's nothing it oculd possibly ever output
16:29:53 <jle`> s/yield/output
16:30:25 <jle`> think of `ConduitT i o` as conduits that expect 'i' to "churn", and will yield o's
16:30:43 <jle`> Sink o = ConduitT Void o would be useless, because you could never churn it
16:30:53 <jle`> it expects a Void, but there is no VOid that can be given to it to start the cranking
16:31:06 <leo_> Got it! :DD
16:31:09 <jle`> `Sink o = ConduitT () o` means that it is the trivially churnable conduit
16:31:12 <leo_> Just needed a little hand. xd
16:31:13 <jle`> you can churn it forever by just feeding in ()'s
16:31:39 <jle`> er sorry, that should have been Source
16:31:59 <jle`> Source o = ConduitT Void o is useless, since you can never churn it to get the o's it sources
16:32:21 <jle`> Source o = COnduitT () o is exactly a source because it will keep on outputting values because you can trivially churn it with ()'s
16:32:41 <jle`> leo_: the opposite is the case for Source i = ConduitT i Void
16:32:51 <leo_> Void and () were confusing me a bit. But yeah, now the distinction makes sense.
16:32:52 <dsal> Curly_dev: your question is a little confusing because ghci doesn't do different things (except in the IO action case which doesn't apply here).  It's unclear what you could mean.
16:33:00 <jle`> leo_: how can I say "this conduit will never yield anything nope never"?
16:33:03 <Curly_dev> Just try the example
16:33:14 <leo_> A Conduit with Void o, right?
16:33:17 <Curly_dev> I would write it here but i don't know if i can
16:33:19 <jle`> leo_: ConduitT i () doesn't mean that, because it could potentially output ()'s
16:33:25 <jle`> it could yield ()'s
16:33:41 <jle`> but ConduitT i Void would mean that.  because it's impossible to yield a Void
16:33:56 <leo_> ^^
16:34:01 <dsal> Curly_dev: the example just defines a data type, an instance, and a named value. There's nothing to try.
16:34:05 <leo_> Thanks again jle`.
16:34:19 <jle`> leo_: np :)
16:34:21 <leo_> Second or third time you answer me around here.
16:34:22 <Curly_dev> ok .. and if you do M 1 and a in the ghci ... it gives what?
16:34:25 <jle`> dsal: admittedly, ghci is very confusing
16:34:31 <jle`> ghci does do a lto of different things
16:34:33 <jle`> and in very inconsistent ways
16:34:39 <jle`> *lot
16:34:48 <jle`> taming ghci is a really awkward part of the haskell learning curve
16:35:14 <jle`> ghci switches how it interprets what you put in in seemingly magic ways, at first
16:35:19 <EvanR> if you type something x that is not an IO action, then it will execute `print x'
16:35:22 <jle`> and none of them are really consistent with haskell source files
16:35:27 <EvanR> that's it
16:35:32 <jle`> EvanR: not necessarily -- what if you type in data Foo = Bar | Baz ?
16:35:34 <Curly_dev> just try the example ...
16:35:41 <EvanR> Curly_dev isn't doing that
16:35:44 <jle`> what if you type in import Control.Monad ?
16:35:52 <EvanR> let's reel it in until it sticks
16:36:41 <yushyin> Curly_dev: I did, and now?
16:37:14 <Curly_dev> Call M 1 and a if you load the file or however you put it
16:37:21 <yushyin> yes
16:37:22 <Curly_dev> and you will get different results for the same freaking code
16:37:26 <yushyin> no
16:37:49 <Curly_dev> so it gives a new line on both of them?
16:39:09 <jle`> in the case of the source file, M [1,2] and 'a' should give different output in ghci
16:39:10 <EvanR> you should try writing a source file that uses putStr and putStrLn, compile the file, run it
16:39:11 <yushyin> typing in M [1] calls putStrLn (show (M [1])), typing in a does putStrLn (show a)
16:39:19 <EvanR> and see the difference
16:39:41 <jle`> it's consistent in how it treats `M [1,2]` and `a` in this situation
16:40:04 <jle`> when you 'show' a string, you get the literal you would type in to get that string in a source file
16:40:09 <jle`> > show "\n"
16:40:11 <lambdabot>  "\"\\n\""
16:40:23 <Curly_dev> but it doesn't show "\n"
16:40:26 <Curly_dev> it shows
16:40:30 <Curly_dev> > "\n"
16:40:32 <lambdabot>  "\n"
16:40:49 <jle`> i don't know how i am supposed to interpret that
16:40:50 <EvanR> did you try what i said
16:40:57 <jle`> are you trying to say that "\n" is not "\n" ?
16:41:14 <dsal> Can you paste what you actually see and how it confuses you?
16:41:15 <Curly_dev> There is a difference between the characters "\n" shown like this and a newline
16:41:26 <Curly_dev> *Main> M 1*Main> a"\n"
16:41:34 <jle`> Curly_dev: are you familiar with the difference between a string literal and a string?
16:42:00 <jle`> the instance of 'Show' for strings is to output the string literal that would create that string
16:42:01 <Curly_dev> Again, it does something behind the hood
16:42:10 <jle`> yeah, it uses 'show' behind the hood
16:42:23 <jle`> 'show' for String (or [Char]) will output the string literal that would create that string
16:42:34 <jle`> show for M here always outputs newline
16:42:58 <Curly_dev> i agree
16:43:07 <jle`> so in both cases it applies 'show' to the result
16:43:11 <jle`> so it treats both situations equally
16:43:14 <jle`> and consistently
16:43:24 <divVerent> I think what makes this confusing is that a REPL also applies show
16:43:32 <jle`> when you write M [1,2,3], it calls show (M [1,2,3]), which yields "\n"
16:43:45 <jle`> when you write "\n", it calls show "\n", which yields \"\\n\"
16:43:50 <Curly_dev> no
16:43:56 <EvanR> we just went back to square 1
16:43:56 <Curly_dev> for that function it will return "\n"
16:44:01 <divVerent> so "\"\\n\"" is actually show $ show "\n"
16:44:11 <Curly_dev> but it doesn't show escaped n
16:44:13 <Curly_dev> It shows the n
16:44:14 <jle`> hm. yes, when you show "\n", it returns literally `"\n"`
16:44:16 <divVerent> where show "\n" is merely the string (literally) "\n"
16:44:18 <EvanR> you lost your minds
16:44:24 <jle`> when you show M [1,2,3] it gives literally the newline string
16:44:32 <jle`> hm, i used literally in a weird way there
16:44:42 <divVerent> basically, the confusing part is just that the interactive ghci prompt etc. also run their own "show" on any output
16:44:56 <EvanR> divVerent: we went through this at least 4 times already. The repl is doing `print x'
16:45:02 <jle`> Curly_dev: when you write M [1,2,3], it calls show (M [1,2,3]), which is just a newline
16:45:03 <EvanR> now show (show x) or show (show (show x))
16:45:13 <Curly_dev> and when i call the function
16:45:14 <EvanR> not*
16:45:19 <EvanR> show doesn't print anything
16:45:19 <Curly_dev> It magically doesn't put a newline because?
16:45:37 <jle`> Curly_dev: when you write "\n", it calls show "\n", which is *the string literal* (quotes and all, escape characters and all) that would produce it
16:45:47 <jle`> Curly_dev: it shows you the *string literal* that would produce "\n"
16:45:51 <divVerent> EvanR: correct, but isn't print (sort of, not quite) defined as putStrLn . show?
16:45:58 <EvanR> yeah, so 1 show
16:46:01 <EvanR> total
16:46:02 <jle`> Curly_dev: er, let me ask again beucas ei'm not sure if you got the question before, but do you understand the difference between a string and a string literal?
16:46:03 <divVerent> wait, it actually is defined that way
16:46:06 <divVerent> so if you in the REPL type
16:46:06 <EvanR> yes
16:46:08 <divVerent> show "\n"
16:46:11 <divVerent> then you get two of them
16:46:14 <EvanR> no one did that though
16:46:18 <Curly_dev> i understand
16:46:21 <divVerent> I see
16:46:32 <jle`> Curly_dev: so, do you understand the difference between the string "\n" and the string literal producing "\n" ?
16:46:35 <Curly_dev> But why it makes the difference between the Instance show and the function that gets show
16:46:40 <dsal> Curly_dev: I mentioned this earlier, but you probably don't want to write your own show.  It's causing a lot of confusion and it leads to misery anyway, as most of the time, show prints out valid Haskell source you can use to recreate values.
16:46:56 <divVerent> Curly_dev: hm... the instance Show is simply what implements the function show
16:46:57 <EvanR> show doesn't print out anything
16:47:05 <jle`> Curly_dev: the string "\n" is a newline.  the string literal producing "\n" is `a double quote, then a slash, then the letter n, then a double quote`
16:47:29 <divVerent> there's only few reasons why you ever want to implement your own show... mainly for types where just deriving (Show) isn't good enough or not possible
16:47:46 <jle`> Curly_dev: so when you show (M [1,2,3]), you get a newline, the string.  When you show "\n", you get the *string literal*, which is "a double quote, a slash, the letter n, a double quote"
16:47:59 <jle`> Curly_dev: that's because the instance of Show for strings is to output the string literal, not the string itself
16:48:08 <Curly_dev> Perfect
16:48:29 <Curly_dev> So there is a difference between the instance Show of a data and the instance Show of a string
16:48:36 <EvanR> no
16:48:37 <jle`> so it treats both consistently in that it calls show on both, but show for M [1,2,3] produces the newline string, but show for "\n" produces a string literal
16:48:38 <divVerent> BTW, speaking of weird things... the HAskell report seems not quite clear about what \n is
16:48:53 <divVerent> like, can "\n" have a length of two on Windows, as one uses \13\10 for that purpose?
16:48:54 <jle`> Curly_dev: every single type actually has its own unique implementation for 'show'
16:49:02 <jle`> Curly_dev: that's a part of the "typeclass" mechanism that haskell has
16:49:16 <divVerent> C is rather clear in requiring this translation to happen in stdio at file IO time
16:49:21 <jle`> Curly_dev: it's like how every type has its own unique implementation of (==)
16:49:25 <divVerent> but how does Haskell define newline conversions?
16:49:43 <jle`> Curly_dev: when you write 'instance Eq MyType where blah blah', you are defining how (==) works for MyType
16:49:56 <jle`> Curly_dev: and when you write instance Show MyType where blah blah', you are defining how 'show' works for MyType
16:50:00 <monochrom> divVerent: "\n" stays as length 1.  It is the I/O routines such as putStr that will do the translation to \r\n on Windows.
16:50:07 <Curly_dev> jle` well my only feud was that it's not the same for data and string
16:50:13 <Curly_dev> The rest makes perfect sense
16:50:19 <jle`> Curly_dev: well, it's actually not the same for any two things
16:50:24 <jle`> Curly_dev: every type has its own unique instance
16:50:26 <EvanR> string is data
16:50:28 <Curly_dev> Since you can make your own type of data where "\n" is "5"
16:50:29 <jle`> Curly_dev: in general you should not expect them to be the same
16:51:00 <divVerent> monochrom: ah, I get it
16:51:02 <jle`> String is a data type.  M is a data type. Bool is a data type. *all* of them have different instances of Show, so they have different 'show' implementation
16:51:08 <monochrom> IIRC the Haskell Report also requires the reverse translation when readFile for example.  You won't get \r\n.
16:51:11 <divVerent> openFile vs openBinaryFile is what ultimately enables/disables newline conversions
16:51:15 <jle`> Curly_dev: it's not just the difference between M and String, it's the difference between every single type
16:51:16 <EvanR> Curly_dev: you are mixing up the value itself with a string representation of the value
16:51:22 <EvanR> 5 vs "5"
16:51:27 <monochrom> Yeah!
16:51:33 <EvanR> "abc" vs "\"abc\""
16:51:55 <monochrom> Modern System.IO also has tools for you to fine-tune hand-pick these translation details.
16:52:14 <divVerent> but a bit annoying there's no readBinaryFile
16:52:18 <divVerent> not that it's hard to make one's own
16:52:30 <Curly_dev> Again i understand, no value in Haskell has a representation, it needs a instance of Show to be displayed
16:52:51 <monochrom> Oh readBinaryFile has a moral problem because by that time it is immoral to stay with String.
16:53:06 <divVerent> yeah
16:53:09 <jle`> Curly_dev: yeah, no showable representation unless there is a Show instance :)  but, for the most part, you can auto-derive a Show instance
16:53:19 <EvanR> divVerent: theres Data.ByteString I/O
16:53:24 <divVerent> can always spell it [Char] though ;)
16:53:27 <divVerent> but yes, ByteString is better
16:53:43 <jle`> btw the restriction that there is no showable representation without a Show instance is what enables some of haskell's neat features, like parametricity
16:54:06 <jle`> so being able to say 'no showable rep' makes reasoning about haskell functions much more powerful
16:54:07 <divVerent> also it's a lot less annoying
16:54:57 <divVerent> also... readFile does not call hClose. How sad.
16:55:10 <divVerent> sounds like a FD leak waiting to happen (or running out of maxfd before the GC kicks in)
16:55:25 <Curly_dev> Well thanks for patience and answers!
16:55:31 <EvanR> i mean, do you want it to hClose before you're done?
16:55:34 <divVerent> for it to call hClose it'd have to be strict, not lazy, though
16:55:36 <EvanR> doesn't sound smart
16:55:39 <divVerent> readFile does not give me the handle
16:55:46 <divVerent> so I can't close it myself
16:55:53 <EvanR> you'd have to consume the whole file
16:56:08 <EvanR> but by using readFile you sign this long weird contract
16:56:09 <divVerent> basically, readFile on 50000 files would be a stupid idea
16:56:14 <divVerent> unless you force a GC run in between
16:56:28 <EvanR> nobody but yourself to blame!
16:56:35 <divVerent> referring to System.IO.readFile
16:56:39 <EvanR> me too
16:56:47 <divVerent> well, readFile documentation does not say it is dangerous
16:56:52 <divVerent> only its source does
16:57:33 <divVerent> OR... does opening a file and getting ENFILE force a GC to close all possible still open FDs?
16:57:37 <divVerent> that'd be a smart implementation
16:57:45 <EvanR> we should change the docs, though i'm not sure Dangerous is the right word
16:58:16 <divVerent> yeah, more like "don't call it more often in a single program run as you have permitted open file descriptors, as there is no guarantee about when it will be closed"
16:58:30 <divVerent> for typical tasks like reading few files it is just fine
16:58:31 <EvanR> the real issue is errors are ignored
16:58:42 <EvanR> it manifests as a short list
16:58:45 <divVerent> wait, it doesn't throw?
16:58:47 <EvanR> no
16:59:11 <monochrom> IIRC it keeps jumping between truncation and bottom.
16:59:21 <monochrom> So, depends on GHC version.
16:59:43 <divVerent> that... hurts
16:59:51 <EvanR> we can chalk up readFile as "it was the 80s. They did a lot of drugs back then"
17:00:00 <monochrom> And even with bottom, it's so hard to catch anyway.
17:00:13 <jle`> i guess 1990 is still technically the 80's
17:00:15 <divVerent> wait, but it can fail with isEOFError?
17:00:27 <divVerent> isn't that the one thing that should NOT be an error for hGetContents?
17:00:43 <monochrom> Oh, that one is fine.
17:00:53 <divVerent> I suppose it means you get this error when already at EOF when calling hGetContents
17:01:11 <divVerent> but... wouldn't that still throw if you readFile an empty file, or does this error only come when already past EOF?
17:01:52 <monochrom> EOF becomes end of list. This one is fine. They were high but not insane. :)
17:01:55 <divVerent> like, when calling hGetContents on the same handle a second time
17:02:17 <monochrom> That one is an exception.
17:02:26 <divVerent> Well, hGetContents does say:
17:02:28 <divVerent> This operation may fail with:
17:02:30 <divVerent> isEOFError if the end of file has been reached.
17:02:34 <divVerent> which is an odd thing for this specific op
17:02:36 <EvanR> EOFError sounds weird
17:02:40 <monochrom> Hrm!
17:03:03 <divVerent> but maybe they really mean when calling it after already having gotten a short read once due to EOF
17:03:11 <EvanR> sir there has been an error in file processing. What? We reached the end of the file? You got me out of bed for this?
17:03:20 <monochrom> But if you hGetContents the second time it throws an exception.
17:05:33 <EvanR> because of the "half closed" handle
17:05:38 <monochrom> Yeah
17:33:55 <EvanR> can I write my own Unbox instances
17:34:47 <EvanR> or somehow get a data type with all unboxed unpacked fields to go into an unboxed vector
17:37:12 <monochrom> I think you can't, but you can write your own Storable instance and use storable vector.
17:43:35 <koz_> EvanR: You certainly can.
17:43:41 <koz_> It's a uniquely tedious chore, but you can.
17:44:03 <koz_> http://hackage.haskell.org/package/vector-0.12.0.3/docs/Data-Vector-Unboxed.html <-- the top of this specifies how
17:44:40 <koz_> Basically, you declare newtype instances around _existing_ unboxed Vector for whatever type, implement MVector and Vector type classes for those newtype instances, then declare that whatever type you want is an Unbox.
17:44:51 <koz_> Alternatively, if your type is finitary, finitary-derive has you covered. :P
17:44:59 <koz_> (and will get an even better new version soon)
17:46:50 <EvanR> so... magic
17:47:40 <koz_> EvanR: I don't think the manual method is _particularly_ magical - it's just tedious.
17:47:49 <koz_> finitary-derive is only semi-magical.
17:48:14 <EvanR> this makes a new vector type while the usual one works with several existing Unbox types
17:48:29 <koz_> EvanR: Uhh, no, that's not what it does.
17:48:43 <koz_> The whole point of Unbox is 'this is how you map it onto Prim'.
17:48:52 <koz_> Using the manual method, you're specifying another mapping.
17:48:55 <koz_> Not another type of vector.
17:49:16 <koz_> If you follow the manual method, it'll work with Unboxed vectors just fine.
17:50:11 <koz_> (specifying another type of vector is _another_ uniquely tedious chore, for very different reasons)
17:52:44 <EvanR> well you said newtype around Vector itself
17:52:51 <koz_> I said _newtype instance_.
17:52:54 <EvanR> oh
17:52:57 <koz_> Vector is a data family.
17:53:31 <koz_> What exact type are you trying to Unbox?
17:53:40 <koz_> I can probably sketch you most of an implementation right now.
17:53:52 <koz_> (Nyarlathotep only knows I've done it enough times)
18:01:10 <EvanR> four Word8s
18:01:19 <EvanR> but now i'm thinking i want to find a library to do it all for me
18:01:24 <koz_> Hmm.
18:01:48 <koz_> This is well within the range of finitary-derive. If you're allergic to it, there's vector-th-unbox.
18:07:31 <koz_> EvanR: https://gist.github.com/kozross/f9e280735c9daa2ccc033e67dd0c0178 <-- here's the basic idea
18:07:38 <EvanR> so a data family is like, the unholy union of data type and type class?
18:07:50 <koz_> I haven't filled in all the class methods, but you can implement a large number of them by 'forwarding', an example of which I have given.
18:08:15 <koz_> A data family allows you to vary the representation of a type by what fills its type parameter holes.
18:08:34 <koz_> This is kinda how vector does its magic.
18:08:56 <EvanR> is there a 'default' for non-matching types
18:09:09 <koz_> The type classes (Data.Vector.Generic.Vector and Data.Vector.Generic.Mutable.MVector) basically define a bunch of 'primitive' operations, out of which everything else is built.
18:09:15 <koz_> (irrespective of representation)
18:09:51 <koz_> It goes something like
18:10:15 <koz_> 'Raw' ops in type classes -> 'generic' ops in Data.Vector.Generic and Data.Vector.Generic.Mutable -> 'specialized' ops in other modules
18:10:49 <EvanR> what is -> here
18:10:55 <koz_> 'Is used to define'.
18:11:35 <koz_> (or 'are used to define' if I can grammar this afternoon)
18:16:17 <koz_> This might be a better way: https://gist.github.com/kozross/f9e280735c9daa2ccc033e67dd0c0178
18:16:23 <koz_> (basically, pack the Word8s adjacent)
20:53:38 <phanimahesh> Good morning folks! Another day, another adventure. I discovered --split-sections yesterday and I like it a lot. binary sizes down from 40 Mb to 7.3 Mb
20:55:24 <Axman6> is split sections or split objects the new hotness? I thought it was the latter
20:56:42 <glguy> "Note that GHC recommends using section splitting in favor of object splitting wherever possible."
20:56:56 <Axman6> thanks
20:57:35 <benoitj>  /window
21:34:55 <haskelllisp[m]> https://leanpub.com/thinking-with-types/
21:34:55 <haskelllisp[m]> Who knows where to get the electronic version of this book?
21:34:55 <haskelllisp[m]> Or, the price is a bit cheaper....
21:35:39 <amalloy> what is a good way to get emacs support now that intero is shutting down? intero links to haskell-ide-engine, dante, and ghcide, but it's not super easy to tell which of those does what
21:37:18 <amalloy> haskelllisp[m]: the page you have linked to provides the electronic version
21:39:13 <dsal> haskelllisp[m]: I got the electronic version from that page.
21:39:41 <dsal> amalloy: I'm using dante.  It's fine.  I failed to get HIE working.
21:41:17 <haskelllisp[m]> amalloy: The electronic version is not complete, right?
21:41:37 <amalloy> why do you think that?
21:43:16 * haskelllisp[m] uploaded an image: image.png (1332KB) < https://matrix.org/_matrix/media/r0/download/matrix.org/fDamHCRCwNSHKvagUmpqNKDT >
21:43:39 <amalloy> indeed, the free sample is incomplete
21:43:54 <amalloy> but the electronic version, for sale on the right half of that page, is surely complete
21:44:51 <haskelllisp[m]> The price is too expensive. . . . Dollar. . , the dollar. . .
21:45:02 <amalloy> if you don't like the price, vote with your wallet by not reading the book
21:46:57 <haskelllisp[m]> 50 USD	=  351.9501 CNY
21:47:54 <amalloy> that's how markets work. goods are offered for a price, and if you find the goods worth the price you pay it
21:48:50 <haskelllisp[m]> You can buy 6 genuine books for $50 in our country. . . However, if I can, I am willing to pay $25 for this book.
21:49:39 <amalloy> i can't help you with that
21:49:41 <dmwit> You cannot by 6 genuine Thinking With Types-es in your country.
21:49:47 <dmwit> s/by/buy/
21:50:11 <dmwit> Oh heck. And I dropped a "for $50". I really failed on this one.
21:50:34 <haskelllisp[m]> Yes, China does not currently have this book. . .
21:51:51 <Axman6> good thing isovector isn't in this channel at the moment :\
21:52:00 <dsal> haskelllisp[m]: the books is quite genuine.  I enjoyed it.
21:54:25 <haskelllisp[m]> I want to see it. . But I can't afford it. ....
21:55:30 <amalloy> you have no obligation to pay more than you find the book worth, just as the author has no obligation to provide it to you for less than he thinks it worth. if seller and buyer don't agree on a price, no sale occurs
21:55:41 <amalloy> there is really no way around it
21:57:11 <haskelllisp[m]> -_-!!
21:57:26 <Axman6> at least, not in a capitalist country with a free market economy
21:58:45 <haskelllisp[m]> https://github.com/isovector/thinking-with-types
21:58:45 <haskelllisp[m]> Is this warehouse a complete electronic version of this book?
21:59:13 <EvanR> there is really no way around it. Unless haskelllisp[m] finds the file lying around somewhere
21:59:21 <phanimahesh> wait intero is shutting down? I only recently got my intero setup. :/
22:00:21 <EvanR> "Don't make me regret open-sourcing this."
22:00:22 <EvanR> heh
22:00:33 <amalloy> phanimahesh: announced a couple weeks ago: https://github.com/chrisdone/intero/blob/master/README.md
22:04:52 <phanimahesh> Oh.
22:06:17 <phanimahesh> EvanR: That's sometimes necessary to spell out
22:07:00 <EvanR> this seems to be one of those times
22:19:03 <amalloy> dsal: dante was indeed very easy to set up and get going, except i can't figure out how to install/configure the hlint feature
22:19:50 <dsal> amalloy: I used to have it working as a haskell-check sort of thing, but I don't have it working in fly mode.  I don't pay enough attention to tools.  heh
22:20:36 <dsal> Oh neat.  I found a bug in the book.  Now I feel obligated to fix it.
22:22:32 <amalloy> actually now that i poke around i see i do not have it set up very well at all. it can tell me what type map has, but not anything i've defined in this buffer
22:27:56 <amalloy> i get the idea it is supposed to do this with flycheck somehow but flycheck seems to be a no-op
22:29:48 <EvanR> "The ⊙ operator fulfills the requirement of a non-commutative monoid where the identity element e is chosen so that a ⊙ e = e ⊙ a = a (i.e. the identity element can be any tuple <C,α> where α=0)
22:30:15 <EvanR> " Now how do you reconcile this with the theorem that all identity elements of a monoid must be equal?
22:32:13 <EvanR> ⊙ in this case is the 'over' operation of two pixels with alpha channel
22:34:53 <amalloy> EvanR: the same set can admit multiple monoids, each with a single identity element
22:35:07 <amalloy> but i don't know what text you're quoting so i can't say if that's what they mea
22:36:14 <EvanR> well, they are right. Any color with alpha zero acts as an identity
22:36:39 <EvanR> the text is paraphrased from this page https://en.wikipedia.org/wiki/Alpha_compositing 
22:37:27 <nshepperd1> "a ⊙ e = e ⊙ a = a" only holds in that case under a weaker notion of equality where all colours with alpha 0 are equal
22:37:29 <EvanR> However <red,0> and <green,0> aren't equal in some vague platonic sense of equals
22:37:31 <sm[m]> amalloy: ghcide is not too hard to set up and seems most likely to succeed
22:39:54 <sm[m]> amalloy, see recent /r/haskell thread about HIE for tips
22:39:56 <nshepperd1> In which case you have only one identity element, namely the set of all colours with alpha 0
22:40:13 <EvanR> well that just made me not understand this monoid anymore
22:40:30 <Lears> EvanR: They're inequal if you derive equality structurally, but that's not appropriate in the context. It's fine to have an equivalence relation that makes <red,0> == <green,0>.
22:41:06 <EvanR> that is fine as it is, but now i'm like in what sense does it even act as identity
22:42:03 <EvanR> let me try to figure this out again
22:42:49 <EvanR> if both alpha are zero, it's division by zero. That's cool
22:45:54 <nshepperd1> If both alphas are zero, you're painting nothing on nothing so presumably the answer is nothing
22:46:30 <nshepperd1> A reasonable convention would be just returning the second value unmodified if the first alpha is zero
22:47:59 <EvanR> yeah this it requires squinting to call it a monoid
22:48:01 <EvanR> then it*
22:48:07 <EvanR> also i can't define it in lambdabot
22:48:38 <EvanR> @define (c0,a0) ⊙ (c1,a1) = let d = a0+a1*(1-a0) in ((c0*a0 + c1*a1*(1-a0))/d, d)
22:48:39 <lambdabot>  .L.hs:213:1: error: [-Woverlapping-patterns, -Werror=overlapping-patterns]
22:48:39 <lambdabot>      Pattern match is redundant
22:48:40 <lambdabot>      In an equation for ‘⊙’: ⊙ (c0, a0) (c1, a1) = ...
22:50:07 <nshepperd1> Considering all colours with alpha zero to be equal doesn't seem like a particularly unreasonable form of squinting
22:51:04 <EvanR> it would be nicer if you didn't have to, since we don't have dependent type technology yet to understand that kind of reasoning
22:51:27 <nshepperd1> What do dependent types have to do with it
22:51:51 <EvanR> the law e <> a = a <> e = a could be type checked and proven 
22:52:00 <EvanR> unless the equality is fancy
22:52:23 <EvanR> i think there is a way out of this
22:52:46 <nshepperd1> You can write a quickcheck test that checks that law easily
22:52:57 <nshepperd1> Just define == the right way
22:53:06 <EvanR> pre-multiplied alpha would make <green,0> and <red,0> different
22:53:25 <EvanR> representing a green glow and a red glow that is entirely unoccluded
22:54:54 <EvanR> and <0,0> (no emission, no occlusion) would be an actual identity
22:56:12 <EvanR> the wikipedia article also makes this case that pre-multiplied is better for image compression, since otherwise <red,0> and <green,0> are taking up compressed bits despite being invisible
22:56:46 <EvanR> in non-premultiplied alpha. What a terrible name for something
22:57:39 <EvanR> nshepperd1: any idea why lambdabot doesn't accept that definition??
22:57:56 <EvanR> @define (c0,a0) ⊙ (c1,a1) = (0,0)
22:57:58 <lambdabot>  .L.hs:213:1: error: [-Woverlapping-patterns, -Werror=overlapping-patterns]
22:57:58 <lambdabot>      Pattern match is redundant
22:57:58 <lambdabot>      In an equation for ‘⊙’: ⊙ (c0, a0) (c1, a1) = ...
22:58:02 <EvanR> wth
22:58:29 <EvanR> @define (c0,a0) ⊙ (c1,c1) = (0,0)
22:58:30 <lambdabot>  .L.hs:213:13: error:
22:58:31 <lambdabot>      • Conflicting definitions for ‘c1’
22:58:31 <lambdabot>        Bound at: .L.hs:213:13-14
22:58:40 <EvanR> @define (c0,a0) ⊙ (c1,a1) = (0,0)
22:58:42 <lambdabot>  .L.hs:213:1: error: [-Woverlapping-patterns, -Werror=overlapping-patterns]
22:58:42 <lambdabot>      Pattern match is redundant
22:58:42 <lambdabot>      In an equation for ‘⊙’: ⊙ (c0, a0) (c1, a1) = ...
22:58:53 <nshepperd1> No idea
22:59:00 <EvanR> sorry, thought it might just be stuck
22:59:18 <EvanR> @define (c0,a0) !!! (c1,a1) = (0,0)
22:59:20 <lambdabot>  Defined.
22:59:20 <nshepperd1> Maybe it doesn't recognise that circle thing as an operator
22:59:35 <EvanR> > isSymbol '⊙'
22:59:36 <lambdabot>  True
23:00:13 <EvanR> @define ⊙ (c0,a0) (c1,a1) = let d = a0+a1*(1-a0) in ((c0*a0 + c1*a1*(1-a0))/d, d)
23:00:13 <lambdabot> Plugin `eval' failed with: Enum.toEnum{Word8}: tag (8857) is outside of bounds (0,255)
23:01:11 <nshepperd1> That looks like it doesn't understand Unicode at all
23:01:33 <EvanR> since when... 
23:01:47 <EvanR> we've unicode snowmen operator before
23:02:06 <nshepperd1> It's a mystery to me
23:02:31 <EvanR> @define (c0,a0) ☃︎ (c1,a1) = let d = a0+a1*(1-a0) in ((c0*a0 + c1*a1*(1-a0))/d, d)
23:02:32 <lambdabot>  Parse failed: Illegal character ''\65038''
23:03:13 * EvanR gives lambdabot an illegal character
23:03:44 <Lears> @undefine
23:03:45 <lambdabot> Undefined.
23:03:49 <Lears> @define (c0,a0) ⊙ (c1,a1) = let d = a0+a1*(1-a0) in ((c0*a0 + c1*a1*(1-a0))/d, d)
23:03:51 <lambdabot>  Defined.
23:03:55 <EvanR> omg
23:04:26 <Lears> When in doubt, @undefine or %kill. <.<
23:04:43 <EvanR> > (0.2,1) ⊙ (0.3,1)
23:04:45 <lambdabot>  (0.2,1.0)
23:04:53 <EvanR> > (0.2,0.5) ⊙ (0.3,1)
23:04:55 <lambdabot>  (0.25,1.0)
23:05:05 <EvanR> > (0.2,0) ⊙ (0.3,0)
23:05:07 <lambdabot>  (NaN,0.0)
23:07:28 <EvanR> well could be worse
23:22:11 <EvanR> @define (c0,a0) @ (c1,a1) = (c0 + c1*(1-a0), a0 + a1*(1-a0)) --ahh now that's a monoid
23:22:11 <lambdabot>  Parse failed: TemplateHaskell language extension is not enabled. Please add ...
23:22:38 <EvanR> @define (c0,a0) ⊙⊙ (c1,a1) = (c0 + c1*(1-a0), a0 + a1*(1-a0))
23:22:39 <lambdabot>  Defined.
23:24:05 <EvanR> > (0.2,1) ⊙⊙ (0,1)
23:24:07 <lambdabot>  (0.2,1.0)
23:24:23 <EvanR> > (0.2,0.1) ⊙⊙ (0.3,1)
23:24:25 <lambdabot>  (0.47000000000000003,1.0)
23:25:13 <EvanR> blend all the things
23:25:50 <EvanR> > (0.2,0.1) ⊙⊙ (0,0)
23:25:53 <lambdabot>  (0.2,0.1)
23:25:59 <EvanR> > (0,0) ⊙⊙ (0,0)
23:26:01 <lambdabot>  (0,0)
23:27:10 <EvanR> with pre multiplied alpha there's a distinction between a totally black object and the blackness of space behind an invisible object... brain explode
23:54:12 * hackage llvm-extra 0.8.2 - Utility functions for the llvm interface  https://hackage.haskell.org/package/llvm-extra-0.8.2 (HenningThielemann)
