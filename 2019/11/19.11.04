00:02:05 <jusss`> how we handle functions about time? like set a timer to count down?
00:02:11 <jusss`> turn to epoch time?
00:02:40 <dminuoso> jusss`: What exactly do you want to do with time?
00:04:39 <jusss`> dminuoso: I need a counter down, for example now is 2019-11-04, 16:02, now I want set a time 2020-01-25 00:00, now counter down with days:hours:minutes
00:04:48 <jusss`> and display
00:05:11 <nshepperd> want circular imports? build a preprocessor macro that dumps everything into one file! :D
00:05:56 <jusss`> dminuoso: if haskell didn't has a easy GUI to display that, a website will be ok too
00:06:04 <dminuoso> nshepperd: Honestly, Im starting to think that the lack of circular imports is one of the biggest "doesnt feel right" about Haskell, especially when you are so used to throwing stuff into declaration groups without any regard of ordering...
00:06:35 <dminuoso> I mean hey, we can have mutually recursive types...
00:10:14 <nshepperd> it's pretty annoying
00:11:50 <tdammers> also "only one module per source file, and filename must match module name, except for Main, where for some reason it doesn't matter at all, but you still can only have one module in that file"
00:11:51 <nshepperd> but it seems like it should be fixable, if we just had a preprocessor step to generate the hs-boot files
00:12:24 <tdammers> problem is, whenever I muse about what the perfect solution to this problem would be, the answer I arrive at is "literate programming on crack cocaine"
00:12:49 <nshepperd> like, just have cabal generate a hs-boot for every source file by default, and make 'import X' use the hs-boot by default
00:12:59 <dminuoso> nshepperd: Im convinced hs-boot is not the answer.
00:13:14 <tdammers> hs-boot feels like a really dirty hack
00:13:20 <nshepperd> that's basically how other languages do it
00:14:14 <nshepperd> although i guess i have no idea what the inline story is there
00:14:30 <Guest3238> So intero is sun-setting. Dont want to use haskell-ide-engine. I have bad experience with that.
00:14:35 <tdammers> I think if I were to design a language, I'd start with a naive approach where in import literally just parses the imported source file into an AST and injects that into the importing module
00:15:09 <dminuoso> Good bye fast compilers!
00:15:15 <tdammers> and then optimize that approach with caching, modularize the compiler pipeline with serialization opportunities in strategic spots, etc
00:15:33 <tdammers> but you have to design the language and its specs for this from the ground up, really
00:15:45 <tdammers> that is, the serialization formats need to be managed in a reliable way
00:16:18 <tdammers> the language would also have to refrain from stuff like CPP and such
00:17:42 * hackage monad-par 0.3.4.9 - A library for parallel programming based on a monad  https://hackage.haskell.org/package/monad-par-0.3.4.9 (SimonMarlow)
00:19:41 <Guest3238> How do you work with emacs ? 
00:20:05 <jusss`> haskell-mode?
00:20:25 <Guest3238> mine is haskell-mode and intero. 
00:20:59 <Guest3238> intero is being archived as we speak. so was wandering what to do. 
00:21:57 <jusss`> I haven't used intero, I just use haskell-mode and a hook connect to runghc
00:22:21 <Guest3238> ah that explains it. 
00:22:39 <jusss`> so press f5, runghc will eval current buffer's code
00:23:06 <jusss`> but this can't do interactive
00:25:35 <dminuoso> jusss`: https://hackage.haskell.org/package/posix-timer
00:26:47 <dminuoso> jusss`: But without knowing more about your requirements its hard to say. In general a "countdown" is difficult to implement right if you have any reasonable expectations about its behavior.
00:27:03 <jusss`> dminuoso: what Timer.hsc means?  does all haskell file end with hs?
00:27:32 <dminuoso> jusss`: That is code using hsc2hs
00:27:45 <dminuoso> jusss`: One of the common tools people use when writing Haskell bindings to C code.
00:28:36 <jusss`> dminuoso: so there're some C codes in that file?
00:28:42 * hackage alex 3.2.5 - Alex is a tool for generating lexical analysers in Haskell  https://hackage.haskell.org/package/alex-3.2.5 (SimonMarlow)
00:28:53 <jusss`> foreign import ccall ...
00:28:58 <jusss`> FFI...
00:29:40 <jusss`> dminuoso: I wonder why haskell has so many bindings, not implement them by haskell?
00:29:42 <dminuoso> jusss`: What does it matter how its implemented though? Im merely suggesting to use posix-timer :)
00:30:06 <dminuoso> jusss`: This is a POSIX feature, its already implemented by most systems - why re-implement the wheel?
00:30:19 <jusss`> I heard that guy implement openGL bindings with just a few days
00:30:43 <jusss`> and GUI are bindings
00:30:46 <dminuoso> jusss`: So re-using existing libraries for performance or because they dont want to reimplement something is a good reason to use FFI
00:31:13 <jusss`> dminuoso: but that ask the people to use C...
00:31:36 <jusss`> it's like the Kotlin docs or implement always point to Java
00:32:00 <jusss`> so learn Java first, then you can learn Kotlin
00:32:52 <dminuoso> jusss`: Well you would not be using C. You would be using a library which was written in C.
00:33:17 <dminuoso> In case of FFI into C, it's just machine code at the end.
00:33:57 <jusss`> dminuoso: but haskell can let us don't think with that C way, I think this the point
00:34:12 <jusss`> otherwise why we shouldn't use C to do anything
00:34:33 <dminuoso> jusss`: There's various reasons to want this. 
00:35:09 <dminuoso> jusss`: Perhaps the library you are developing against exists only as a native library. Or its too much effort to reimplement it in Haskell. Or its only available via C (say kernel functionalities in Linux)
00:36:12 <jusss`> dminuoso: I heard that masters always do generators to generate C code...
00:36:42 * hackage monad-par 0.3.5 - A library for parallel programming based on a monad  https://hackage.haskell.org/package/monad-par-0.3.5 (SimonMarlow)
00:36:45 <jusss`> write a tool, use that tool to generator C code
00:36:52 <jusss`> generate
00:37:39 <dminuoso> jusss`: The usefulness of posix-timer is that any (mostly) POSIX compliant system already has timer functionality out of the box.
00:37:42 <jusss`> that's related to meta-programming or DSL topic?
00:38:03 <dminuoso> jusss`: So instead of reinventing the wheel, and trying to recreate high resolution timers, why not use your systems capabilities?
00:38:04 <jusss`> ok
00:42:11 <jusss`> dminuoso: did time function come with ghc? or I need to install the time package?
00:42:31 <jusss`> System.Posix.Clock is not existed
00:42:57 <jusss`> but System.Posix.Time exist
00:53:14 <tinga> Hi. Is there a way I can define the Y combinator in Haskell without relying on Haskell's recursion, i.e. via a helper _y _y f = f (_y _y f) ? I get (predictably) "cannot construct the infinite type".
00:53:32 <tinga> Is there a way to define a recursive function type manually to solve this?
00:53:41 <dminuoso> tinga: There's a couple ways, yes
00:54:01 <dminuoso> tinga: (In fact the whole point of the Y combinator is to define recursion to begin with, so relying on recursion to define it, would almost defeat the point of it)
00:54:19 <tinga> yep
00:54:29 <merijn> tinga: You can't define the Y combinator directly in a typed lambda calculus, you need to go through a newtype
00:55:00 <merijn> Well, maybe you can in some typed lambda calculus, but definitely not in most
00:55:09 <dminuoso> % newtype Mu a = Mu (Mu a -> a)
00:55:10 <yahb> dminuoso: 
00:55:12 <tinga> merijn, I actually started going down that route, but a newtype seems to not be applicable? Or so?
00:55:15 <dminuoso> tinga: ^- this is going to be your friend. :)
00:55:33 <dminuoso> (Or any other version of it, there's plenty of them)
00:55:36 <tinga> k let me play with that
00:57:14 <merijn> tinga: Anyway, the simpler solution to this is fix
00:57:16 <merijn> :t fix
00:57:17 <lambdabot> (a -> a) -> a
00:57:19 <dminuoso> tinga: Note that you have to disable optimizations in many implementations of the Y combinator. Otherwise the optimizer is likely to bail out if you use it.
00:57:53 <merijn> > let myMap = fix (\map' f list -> case list of [] -> []; (x:xs) -> f x : map' f xs) in myMap (+1) [1..10]
00:57:55 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
00:58:08 <jusss`> newtype Fix f = MkFix (f (Fix f))
00:58:35 <merijn> tinga: fix is what you'd usually use instead of the y combinator
00:59:16 <tinga> merijn, what is fix here? Where is it defined?
00:59:49 <merijn> tinga: fix is the (least? I always forget) fixpoint combinator, i.e. the primitive for recursive functions
01:00:00 <merijn> Should be in Prelude, I think?
01:00:18 <tinga> Not in my prelude?
01:00:20 <merijn> Oh, Control.Monad.Fix/Data.Function
01:00:32 <dminuoso> tinga: fix is defined in terms of recursoin though
01:00:42 <dminuoso> fix f = let x = f x in x
01:00:50 <tinga> But then that's just cheating. I want to define y myself; also what's the difference between fix and y here?
01:01:16 <dminuoso> % :t fix
01:01:17 <yahb> dminuoso: (a -> a) -> a
01:01:20 <merijn> tinga: I mean, you can just define fix yourself :p
01:01:36 <dminuoso> merijn: I think you are missing the point. They appear to want to implement the actual y-combinator for some reason.
01:01:47 <merijn> I guess the real answer is: Let's rollback to "why do you want to implement the Y combinator?"
01:01:50 <dminuoso> Maybe its an assignment, or just curiosity.
01:02:23 <dminuoso> tinga: Either way, the Mu newtype above (and disabled optimizations) is all you need.
01:03:05 <tinga> I implemented an interpreter without recursion and tested it via Y combinator and wanted to benchmark it against a translation to Rust, which I didn't manage to type right so I tried to type it out in Haskell. 
01:03:14 <tinga> At which point I realized that, yeah, that's not so easy :)
01:03:56 <tinga> So now I basically just want to understand the details.
01:05:51 <merijn> The details of?
01:06:12 * hackage LDAPv3 0.1.0.0 - Lightweight Directory Access Protocol (LDAP) version 3  https://hackage.haskell.org/package/LDAPv3-0.1.0.0 (HerbertValerioRiedel)
01:06:17 <tinga> Of how one would handle it in type systems.
01:06:31 <tinga> (Playing with newtype now)
01:07:25 <dminuoso> @tell hvr Regarding your LDAPv3 protocol implementation, is there going to be a client library at some point in the future?
01:07:25 <lambdabot> Consider it noted.
01:08:14 <tinga> I mean I've got no idea whether Rust will allow me to do it--with no higher-kinded types, which I guess is what's needed here?
01:08:31 <tinga> Actually no, just recursion.
01:12:46 <dminuoso> tinga: Strictly speaking the full newtype is: newtype Mu f = Mu {unMu :: f (Mu f)}
01:13:16 <dminuoso> (Which gets you into recursion schemes)
01:13:35 <dminuoso> tinga: Its not even about higher kinded types really.
01:17:10 <dminuoso> % :t \f -> (\x -> f(x x)) (\x -> f(x x))
01:17:10 <yahb> dminuoso: ; <interactive>:1:18: error:; * Occurs check: cannot construct the infinite type: t0 ~ t0 -> t; Expected type: t0 -> t; Actual type: (t0 -> t) -> t; * In the first argument of `x', namely `x'; In the first argument of `f', namely `(x x)'; In the expression: f (x x); * Relevant bindings include; x :: (t0 -> t) -> t (bound at <interactive>:1:9); f :: t -> 
01:17:51 <dminuoso> tinga: So the trick here lies in recognizing that `Mu a ~= Mu a -> a`, which is all you need. :)
01:18:36 <tinga> I need a coffee first :), thanks for all the hints!
01:26:17 <olligobber> I found out this data type I made is a monad, but defining the Applicative instance is mind bending
01:26:40 <dminuoso> olligobber: It's completely mechanical.
01:27:12 <dminuoso> olligobber: Implement `<*>` in terms of `join` or `>>=`, and then mechaically substitute?
01:27:17 <merijn> olligobber: If you have a lawful monad you can just use the Monad instacne to define your applicative...
01:28:00 <olligobber> but the code requires you to define Applicative before Monad instances right?
01:28:13 <dminuoso> olligobber: No.
01:28:15 <olligobber> oh
01:28:40 <dminuoso> olligobber: The order is irrelevant. You can just write `instance Functor F where fmap = liftM; instance Applicative F where pure = return; (<*>) = ap; instance Monad F where ...`
01:28:51 <merijn> olligobber: Instances aren't ordered like subclassing is
01:28:59 <olligobber> cool
01:29:22 <merijn> olligobber: Monad requires an Applicative instance, but there's no notion of "before" or "after", there's just "Applicative exists" or "Applicative doesn't exist"
01:29:34 <dminuoso> olligobber: Though, it might still be interesting to do what I suggested. If its truly that mind bending, it could be useful to understand how the applicative instance would be implemented.
01:29:36 <merijn> So it's perfectly legal to define Functor/Applicative using Monad for your specific type
01:29:56 <dminuoso> olligobber: (Using that technique I mentioned its very simple too... any Haskell beginner could do it)
01:30:18 <merijn> olligobber: The only catch is that you gotta be careful with default implementations, i.e. "return = pure" by default (I think?) in which case defining "pure = return" would infinite loop
01:30:20 <olligobber> dminuoso, well, my data type has 6 constructors to expand
01:30:40 <dminuoso> olligobber: Its still mechanical, regardless of how many constructors.
01:31:49 <merijn> olligobber: It makes sense when you think about it, defining "fmap = liftM" just triggers GHC to go "well, liftM requires Monad to lookup it's implementation. Is this type an instance of Monad? Yes? Then just call that implementation..." so as long as it works out at compile time everything "Just Works (TM)"
01:32:14 <olligobber> huh
01:41:06 <olligobber> It is so weird having ~(+1) <*> ~1 return ~~2
01:45:14 <dibblego> it's not always mechanical e.g. ReaderT
01:46:21 <olligobber> ok, I get what it's doing now
01:46:29 <dminuoso> dibblego: Huh?
01:47:15 <dminuoso> dibblego: Of course it is. `(<*>) = ap` by coherence laws (if of course you have a non-lawful instance its a different story, but at that point the discussion would be senseless)
01:48:17 <dibblego> oh yeah, disregard, I am used to Applicative not being in the middle
01:54:12 * hackage mmsyn5 0.1.0.0 - Various additional operations on lists  https://hackage.haskell.org/package/mmsyn5-0.1.0.0 (OleksandrZhabenko)
02:05:12 * hackage mmsyn5 0.1.1.0 - Various additional operations on lists  https://hackage.haskell.org/package/mmsyn5-0.1.1.0 (OleksandrZhabenko)
02:12:12 * hackage mmsyn5 0.1.2.0 - Various additional operations on lists  https://hackage.haskell.org/package/mmsyn5-0.1.2.0 (OleksandrZhabenko)
02:26:54 <Athas> Release early, release often!
02:30:28 <merijn> Athas: Pfft, testing before release is for suckers
02:30:50 <dminuoso> Besides, its much easier to do testing if people run your software in production.
02:30:53 <maralorn> So what is the recommended way to find version bounds for my package (a library)? Should I try to be as liberal as possible? Or do I start with pinned versions to what I build it with and then extend the range upwards whenever I can?
02:31:36 <merijn> maralorn: The recommended way is to follow the PVP
02:31:42 <merijn> maralorn: https://pvp.haskell.org/
02:32:41 <maralorn> merijn: So I take from every package the version I work with and do a >=x.y.0.0 && < x.(y+1).0.0?
02:33:07 <merijn> maralorn: Personally if I developed with foo-0.5 I will use "foo ^>= 0.5" as the starting bound ( ^>= defaults to "any version that's PVP compatbile with a minimum of this"
02:33:28 <maralorn> Okay, nice.
02:33:51 <maralorn> And then when I bump I gradually extend the range?
02:33:53 <merijn> maralorn: See the explanation here: https://cabal.readthedocs.io/en/latest/developing-packages.html#pkg-field-build-depends
02:33:57 <Athas> maralorn: I just guesstimate the lower bound and leave the upper bound unset.  If it becomes a problem, there's Hackage revisions or pinning.
02:34:35 <Athas> In practice, I have had more trouble with restrictive upper bounds than with missing upper bounds.
02:34:37 <merijn> maralorn: I extend the lower bound as need/asked and bump the upperbound via revision whenever a new release comes out that still works
02:34:59 <merijn> Athas: I have the exact opposite result, since loosening bounds transitively is trivial, but tightening them is hard
02:35:41 <merijn> maralorn: Also relevant: http://packdeps.haskellers.com/ that has an RSS feed that lets you track out-of-date upperbounds via RSS
02:36:19 <maralorn> merijn: I was thinking about integrating packdeps in my ci?
02:36:34 <merijn> maralorn: For example: http://packdeps.haskellers.com/feed?needle=broadcast-chan (note the "view as RSS feed" link up top), so I just add RSS feeds for all my packages so that I'm notified when a dependency release a new version I should test
02:36:58 <maralorn> merijn: Well, that looks like the best way.
02:37:23 <maralorn> One last question: When does a bound loosening require a version bump on my side?
02:37:39 <merijn> Athas: Ah, wait, I just realised something "you never had issues with open upperbounds" <- was this while using stack? :p
02:38:28 <merijn> maralorn: Consult the earlier PVP link ;) i.e. only when it affects your API/types, which would usually only be if you re-export things
02:38:38 <merijn> And even then might not be relevant
02:39:52 <maralorn> Okay
02:40:46 <Athas> merijn: yes, of course, or freezing.
02:41:13 <merijn> Athas: Right, so you only say "no issue with missing upperbounds" because you're developing with an implicit upperbound imposed by stack
02:42:06 <Athas> Yes, but when I need to move to the next GHC, 90% of the problems I encounter are artificial problems imposed by upper bounds.
02:42:34 <merijn> Athas: I frequently get my build broken by packages ommitting upperbounds
02:42:39 <Athas> Stack isn't magical.  When a new GHC comes out, it's a manual process to go through all the packages and ensure they do not transitively conflict with any of the wired-in packages.
02:43:33 <merijn> Athas: Right, but you run into breakage less often when someone releases something new in your transitive dependencies, because stack's snapshot won't pick it up
02:43:53 <Athas> Right!  It works wonderfully.
02:44:43 <denbrahe[m]> Does anyone know what the state of WriterT is?
02:44:47 <__monty__> Athas: Do the problems with upper bounds happen inside stackage or only once you step outside into the wilderness that is hackage?
02:44:55 <Athas> The same experience can more flexibly be obtained with 'cabal freeze', can it not?  I'm experimenting with moving back to pure cabal and it seems to work fine.
02:44:57 <merijn> Athas: Right, but then you don't get to claim "missing upperbounds are never an issue", "missing upperbounds are never an issue if I buy into this ecosystem and build tool and use only that" is a lot less convincing than "missing upperbounds are never an issue"
02:45:14 <denbrahe[m]> Is the space leak fixed with `Control.Monad.Trans.Writer.CPS`?
02:45:16 <merijn> Athas: Sure, you can freeze, but that doesn't mean missing upperbounds don't break tons of shit ALL the time
02:45:16 <Athas> __monty__: only outside the wilderness, but the wilderness creeps back in every time a new GHC is released.
02:45:51 <Athas> merijn: I am merely conveying my preference and experience as a Haskell library consumer - nothing more.  I don't think anyone has any global empirical data on the Best Way to do things.
02:46:36 <merijn> Athas: Sure, but then you should probably also mention that your preference is rather related to choice of build tool :)
02:46:43 <Athas> merijn: so is yours.
02:46:55 <__monty__> Athas: Wait, the upperbounds are only an issue within the confines of stackage? That doesn't make sense, isn't stackage supposed to guarantee intercompatibility?
02:47:08 <Athas> __monty__: in fact, one of the main reasons I'm experimenting with going back to cabal+freeze is that I'm a bit tired of the overhead of pushing boulders back up the stackage hill every time a new GHC is released.
02:47:30 <Athas> Someone has to *make* that guarantee work.
02:47:57 <merijn> Athas: Not entirely/just related to my choice of build tool, upperbounds are crucial if you want old releases of software to remain working
02:48:02 <__monty__> Isn't it checked by the stackage build matrix?
02:48:17 <merijn> __monty__: Sure, but if the matrix breaks someone has to fix it
02:48:22 <Athas> When Stackage moves to a new GHC, it throws out all the packages that don't work with it.  It's a manual process to track them down, fix them, and push them back into Stackage.
02:49:05 <__monty__> Ah, good to know.
02:49:07 <merijn> I was gonna add a package to stackage since someone requested it, but the workflow was too much bother so I just abandonned that
02:49:37 <Athas> There's usually three steps: (0) badger the maintainer to bump the bounds, (1) get a Hackage revision in place (because maintainers can be very slow), (2) update the build-contraints.yaml file in Stackage that I never quite got a good grasp of.
03:17:22 <learningHaskell> hey guys, who konws how to pattern matching the function type
03:17:37 <learningHaskell> I tried it in this way 
03:17:39 <learningHaskell> whichFun f = case f of                            (String -> String) -> "string"                           (String -> [a]) -> "list"
03:17:51 <learningHaskell> but it failed
03:17:56 <dminuoso> learningHaskell: You cannot
03:18:16 <tdammers> this doesn't work for so many reasons
03:18:29 <dminuoso> learningHaskell: What are you trying to do? What is the problem you have?
03:18:47 <learningHaskell> seems that I still need a lot to learn
03:19:03 <dminuoso> learningHaskell: Maybe it might be helpful to understand why you cant do this
03:19:21 <learningHaskell> I've just started in Haskell
03:19:23 <__monty__> tdammers: It's not a stupid question though. This is basically the motivation for dependent types.
03:19:27 <dminuoso> learningHaskell: `case of` lets you pattern match on data constructors. :)
03:19:30 <tdammers> __monty__: yes, I know.
03:19:42 * hackage mmsyn5 0.1.3.0 - Various additional operations on lists  https://hackage.haskell.org/package/mmsyn5-0.1.3.0 (OleksandrZhabenko)
03:19:58 <tdammers> the reasons all amount to "types and values are separate universes in Haskell"
03:20:10 <dminuoso> __monty__: Huh? In what sense is that related to dependent types?
03:20:41 <tdammers> dminuoso: in a dependently typed language, you can have whichFun :: Type -> String
03:20:52 <dminuoso> tdammers: No, that's just polymorphism.
03:20:54 <dminuoso> We have that.
03:21:15 <dminuoso> % :set -XAllowAmbiguousTypes
03:21:16 <yahb> dminuoso: 
03:21:18 <tdammers> putStrLn $ whichFun (typeOf f) -- this?
03:21:30 <dminuoso> % class Named a where named :: String;
03:21:30 <yahb> dminuoso: 
03:21:32 <__monty__> dminuoso: In a dependently typed language a type is just another pattern matchable value.
03:21:37 <dminuoso> % instance Named Int where named = "This is an int"
03:21:37 <yahb> dminuoso: 
03:21:41 <dminuoso> % named @Int
03:21:42 <yahb> dminuoso: "This is an int"
03:22:05 <dminuoso> __monty__: That's not a feature of dependently typed languages. We can pattern match on types just fine using typeclasses.
03:22:31 <tdammers> that's not what whichFun does though
03:22:34 <__monty__> Treating types as values is *not* a motivation of dependent types?
03:22:51 <dminuoso> __monty__: It's rather the opposite.
03:23:07 <kuribas> is there a way to extract a ByteString from a Text?
03:23:14 <tdammers> kuribas: define "extract"
03:23:23 <kuribas> I mean give the underlying bytestring, not encode it in any way...
03:23:30 <__monty__> dminuoso: That's just a word game.
03:23:35 <dminuoso> __monty__: No its not.
03:23:36 <tdammers> there isn't really an "underlying bytestring"
03:23:54 <tdammers> Text transparently uses UTF-16 internally, but that's an implementation detail
03:23:55 <dminuoso> __monty__: polymorphism gives you terms binding types, dependent types gives you types binding terms.
03:23:58 <kuribas> the reason is that mysql recommends using varchar for binary, but the mysql-haskell driver gives back a Text
03:24:02 <MarcelineVQ> __monty__: which language can you pattern match a type? typecasing isn't a thing in the langs I've used so far
03:24:10 <dminuoso> __monty__: In GHC Haskell we expose this clearly, since you can do `f @Int` for instance.
03:24:19 <kuribas> tdammers: I need the original bytes
03:24:24 <__monty__> MarcelineVQ: You don't need a special construct because the types are just values.
03:24:25 <tdammers> that's impossible, I think
03:24:31 <tdammers> use a better driver
03:24:33 <dminuoso> __monty__: It's rather that ability to say `Vec 10 Int` that makes dependent types special. 
03:24:41 <dminuoso> __monty__: So its rather the ability to say `f :: String -> Type`
03:24:46 <dminuoso> That's the speciality of dependent types.
03:24:59 <dminuoso> Not `f :: Type -> String`, that's just polymorphism and we can do that with typeclasses.
03:25:18 <tdammers> if the driver returns Text, and does the right thing, then what it's going to do is take the bytestring that the raw MySQL driver returns, and decode it into a Text using the encoding currently set on the connection
03:25:22 <kuribas> tdammers: Well, perhaps mysql-haskell uses MySQLBytes for binary varchar...
03:25:25 <MarcelineVQ> __monty__: what do you mean by pattern matching a type?
03:25:28 <kuribas> tdammers: rather than Text
03:26:09 <dminuoso> __monty__: So for instance, a pi type would be: x : Pi (a :: K). B(a)
03:26:19 <tdammers> kuribas: long story short, if all you have a Text, then the original bytes have been discarded, all you can get is the decoded Unicode data; the Text itself stores them in UTF-16, but that's fairly irrelevant, point is the original raw bytes are lost
03:26:20 <dminuoso> __monty__: Where K is any type you want. It could be String.
03:26:25 <__monty__> MarcelineVQ: Concat for vec's a good example.
03:26:44 <dminuoso> __monty__: The speciality is not pattern matching on types of that.
03:26:52 <__monty__> MarcelineVQ: Or splitting a vector if that's not good enough for you.
03:26:55 <MarcelineVQ> __monty__: That invovles pattern matching values of Vect n a doesn't it?
03:27:04 <kuribas> tdammers: yes, it seems there is a flag in the driver that determines if it is binary of text: http://hackage.haskell.org/package/mysql-haskell-0.8.4.2/docs/src/Database.MySQL.Protocol.MySQLValue.html#MySQLValue
03:27:05 <dminuoso> __monty__: Really, the differentation between "types that bind terms" and "terms that bind types" is really important. :-)
03:27:08 <__monty__> MarcelineVQ: Not in the type.
03:27:20 <kuribas> tdammers: so then a binary varchar should return bytestring, not text
03:27:27 <tdammers> yeah
03:27:48 <tdammers> you want the query to give you MySQLBytes back, that constructor contains a raw bytestring
03:28:03 <tdammers> not MySQLText, which contains pre-decoded text
03:29:13 <dminuoso> __monty__: So conversely one could say, polymorphism lets you apply values to types and dependent types lets you apply types to values. :)
03:29:35 <dminuoso> __monty__: But the ability to discriminate on type, say `f :: Type -> String` is perfectly implementable in Haskell. Its not dt.
03:30:31 <tdammers> kuribas: ah, here is is. the column charset from the result set must equal 63, then you get a MySQLBytes instead of a MySQLText
03:30:47 <tdammers> I think the code there is wrong btw., it always uses decodeUtf8, even when a different charset is selected
03:31:21 <tdammers> or maybe mysql-haskell always forces utf-8
03:31:33 <__monty__> dminuoso: Sure, if you like hasochism.
03:31:49 <dminuoso> __monty__: Im not sure what you are on about.
03:32:35 <__monty__> dminuoso: Maybe show me how you'd write the WhichFun f typeclass.
03:33:29 <dminuoso> __monty__: Look at my example with Named above.
03:34:06 <dminuoso> (If you dont like the TA you can of course use Proxy instead, that's just for visual pleasantry)
03:34:55 <__monty__> dminuoso: But whichfun is matching a type to a *value*.
03:35:03 <dminuoso> __monty__: And that's exactly what named does.
03:35:10 <dminuoso> __monty__: named takes a parameter, a type, and it produces a string.
03:35:30 <__monty__> Whichfun doesn't produce a string. It matches a type to a string.
03:35:49 <dminuoso> __monty__: It produces a string.
03:35:52 <dminuoso> 12:17:16 learningHaskell | whichFun f = case f of                            (String -> String) -> "string"                           (String -> [a]) -> "list"
03:36:27 <dminuoso> Now we could say
03:36:37 <learningHaskell> so the main problem is that though I could match the value by its constructor, I cant match a value by its type?
03:36:38 <dminuoso> % class WhichFun f where whichFun :: String
03:36:39 <yahb> dminuoso: 
03:36:53 <dminuoso> % instance WhichFun (String -> String) where whichFun = "string"
03:36:53 <yahb> dminuoso: 
03:37:00 <dminuoso> % instance WhichFun (String -> [a]) where whichFun = "list"
03:37:00 <yahb> dminuoso: 
03:37:09 <dminuoso> % whichFun @(String -> String)
03:37:10 <yahb> dminuoso: ; <interactive>:56:1: error:; * Overlapping instances for WhichFun (String -> String) arising from a use of `whichFun'; Matching instances:; instance [safe] WhichFun (String -> String) -- Defined at <interactive>:54:10; instance [safe] WhichFun (String -> [a]) -- Defined at <interactive>:55:10; * In the expression: whichFun @(String -> String); In an equation for `it':
03:37:18 <dminuoso> Oh well yeah. There's that, but you get the idea.
03:37:26 <__monty__> learningHaskell: Matching a value by it's type sounds like a typeclass, which is what dminuoso is showing.
03:38:28 <dminuoso> __monty__: The specialty of dependent types is the other way around, where you could have something like `Vec 10 Int`, where `Vec :: Nat -> Type -> Type`
03:38:48 <__monty__> dminuoso: It's not WhichFun (String -> String) = "string", it's WhichFun (String -> String) -> ("string" -> ...) = ???
03:39:27 <dminuoso> __monty__: Judging from what they wrote Id say yo uare wrong.
03:39:53 <__monty__> But I copied what they wrote?
03:40:12 <__monty__> Translating to your typeclass syntax but not altering further.
03:41:08 <dminuoso> " it's WhichFun (String -> String) -> ("string" -> ...) = ???"
03:41:11 <dminuoso> What is that supposed to mean?
03:41:12 * hackage mmsyn5 0.1.4.0 - Various additional operations on lists  https://hackage.haskell.org/package/mmsyn5-0.1.4.0 (OleksandrZhabenko)
03:43:00 <__monty__> dminuoso: WhichFun (your typeclass) (String -> ...) (what they wrote) =  ??? (what would you put here?)
03:43:24 <dminuoso> I have no idea what that means.
03:43:43 <dminuoso> They wrote some pseudo code, suggesting to pattern match on the type of an argument and then produce a string based on the tye.
03:43:54 <dminuoso> I implemented that exact behavior using type classes.
03:44:06 <__monty__> Not really because their type had another string in it.
03:44:16 <dminuoso> So?
03:44:22 <__monty__> *That*'s the pattern match on a type I'm talking about.
03:44:26 <dminuoso> What "another string" are you talking about?
03:44:41 <dminuoso> __monty__: https://gist.github.com/dminuoso/eeba4e5beadfeed032cc8393a5d547f8
03:44:45 <dminuoso> __monty__: Thats what they posted.
03:45:29 <dminuoso> (I just modified slightly to avoid the [a]/String issue)
03:46:36 <__monty__> The "string"
03:47:03 <__monty__> Oh, I get it.
03:47:17 <__monty__> I read that as *one* type. Not as case -> arrows.
03:47:52 <dminuoso> Even then I could encode that with typeclasses.
03:47:56 <dminuoso> ;
03:47:58 <dminuoso> ;)
03:48:18 <dminuoso> __monty__: The relevant portion would be, that at the end it'd return a string.
03:48:28 <dminuoso> __monty__: And that's just polymorphism.
03:49:38 <__monty__> How'd you do the "string" part though? We're not talking a Symbol here. But a value, in a type as a concrete instance of the entire type in question.
03:50:15 <dminuoso> __monty__: Well sure, if that's an actual string it wouldn't work either way.
03:50:25 <dminuoso> __monty__: But lets assume that it was value of another type.
03:50:44 <dminuoso> __monty__: Ah. Okay!
03:50:48 <dminuoso> I can see where the confusion comes from
03:51:36 <__monty__> So my confusion could be sensible? I was starting to doubt myself. I clearly read the intent wrong though.
03:53:25 <dminuoso> __monty__: Well at best it'd be a parametrized type still.. say a tyfam
03:53:35 <dminuoso> Still not seeing how you get to dependent types from that
03:55:08 <__monty__> dminuoso: Note that I didn't say it *needed* dependent types. Just that this kind of thing is what becomes easy with dependent types.
03:55:17 <dminuoso> Mmm
03:55:18 <sshine> apparently I cannot printf "%f" (n :: Ratio Int)
03:57:50 <__monty__> sshine: I guess normally you'd use fromRational but that'd require s/Int/Integer.
03:59:55 <sshine> right. I suppose I could use Rational.
04:00:01 <lavalike> > printf "%s" (show (1 % 2)) :: String -- >:)
04:00:01 <sshine> it's not really necessary here, though.
04:00:03 <lambdabot>  "1 % 2"
04:00:19 <sshine> lavalike ;)
04:02:52 <__monty__> > printf "%f" (fromRational . approxRational $ (1 % 2 :: Ratio Int))
04:02:54 <lambdabot>  error:
04:02:54 <lambdabot>      • Couldn't match type ‘Ratio Int -> Rational’ with ‘Ratio Integer’
04:02:55 <lambdabot>        Expected type: Ratio Int -> Rational
04:03:22 <phadej> :t approxRational
04:03:24 <lambdabot> RealFrac a => a -> a -> Rational
04:03:24 <__monty__> Oh, need to split the Ratio first.
04:03:52 <__monty__> You get the idea.
04:04:56 <phadej> printf "%f" (realToFrac (1 % 2 :: Ratio Int) :: Double)
04:04:59 <phadej> > printf "%f" (realToFrac (1 % 2 :: Ratio Int) :: Double)
04:05:02 <lambdabot>  error:
04:05:02 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M462510882323...
04:05:02 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
04:05:07 <phadej> > printf "%f" (realToFrac (1 % 2 :: Ratio Int) :: Double) :: String
04:05:09 <lambdabot>  "0.5"
04:05:29 <phadej> :t realToFrac
04:05:30 <lambdabot> (Real a, Fractional b) => a -> b
04:06:04 <phadej> @src realToFrac
04:06:04 <lambdabot> realToFrac = fromRational . toRational
04:06:27 <__monty__> Ah, much better.
04:07:10 <__monty__> Don't understand why the :: String's necessary though.
04:07:27 <phadej> :t printf
04:07:29 <lambdabot> PrintfType r => String -> r
04:07:31 <merijn> __monty__: Because printf's return type is polymorphic
04:07:34 <phadej> > printf "%f" (realToFrac (1 % 2 :: Ratio Int) :: Double) :: IO ()
04:07:36 <lambdabot>  <IO ()>
04:07:50 <merijn> printf is a gross ugly hack, tbh
04:08:00 <phadej> convinient
04:08:06 <lavalike> it's a thing of beauty! >:)
04:10:22 <__monty__> Ah, my fault for thinking ... -> String.
04:14:42 <sshine> phadej, thanks! I'll just use show.
04:15:18 <merijn> sshine: FWIW my solution to basic formatting is just "mconca [ ... ]" and then I will just mix string literals, "show x", etc. in that list
04:15:41 <merijn> It's simple, trivial to understand, linewrapping long lists is easy, etc.
04:16:06 <merijn> For really complex pretty printing I'd use prettyprinter, but for 90% of formatting that approach works great
04:17:26 <__monty__> merijn: To represent a Ratio Int as a fractional decimal you'd still have to jump through hoops though.
04:17:42 <merijn> sshine: Relatedly (when it comes to prettyprinting numbers) have you looked at the Numeric module in base
04:18:00 <merijn> __monty__: Sure, but you have to jump those hoops anyway?
04:18:27 <merijn> __monty__: You just write "showFraction :: Ratio Int -> String" and use that in the list your mconcat'ing
04:18:49 <sshine> merijn, no, thanks looks very applicable. thanks!
04:19:38 <merijn> sshine: It's one of those modules almost no one seems to have looked at, despite being superuseful
04:20:16 <merijn> Honestly, I'd say my number 1 "power user" tip for Haskell is "take a few hours every year to browse through the GHC User Guide and the base modules, because there's tons more stuff than you think!"
04:20:31 <__monty__> merijn: Any reason to prefer mconcat [...] to explicit <> or ++?
04:20:48 <merijn> __monty__: Easier to linewrap
04:21:50 <Arahael> And since it's already all in a list anyway, easier to transform if need be, eg, suppose you want to intercalate different line endings or something.
04:21:51 <merijn> __monty__: Also when you pass the result to a function you need to wrap it in parentheses, etc. making it a list solves all that
04:22:28 <sshine> merijn, yes, I was pretty happy to find Data.Fixed recently. now I keep a mental note for when it might be useful. :)
04:23:40 <__monty__> Arahael: That only works if every element is a line though. Which means you'd end up nesting mconcats or mixing in <> anyway.
04:23:41 <merijn> sshine: Yeah, that's also one that's weirdly unknown, given how great it is :)
04:23:53 <merijn> __monty__: Ah, but see, nesting is also easy in lists
04:24:11 <Arahael> __monty__: As they say, the choice is yours!
04:24:12 <merijn> __monty__: Just do ", mconcat $\n extraListWithIncreasedIndent"
04:25:04 <merijn> __monty__: Not list formatting, but still Monoid: https://github.com/haskell/cabal/blob/master/Cabal/Distribution/Simple/Program/GHC.hs#L163-L193
04:25:09 <__monty__> Not easier than with parens though, neither is alignment? If it's just horses for courses that's fine.
04:25:51 <merijn> __monty__: I dunno, I find both trailing and leading operators rather ugly and confusing, I'm very used to the prefix list style, though
05:09:12 * hackage mmsyn5 0.2.0.0 - Various additional operations on lists  https://hackage.haskell.org/package/mmsyn5-0.2.0.0 (OleksandrZhabenko)
05:18:33 <dminuoso> __monty__: I'd at least avoid ++ (especially if you are working with strings).
05:18:48 <dminuoso> It's less pain down the road if at some point you switch to text.. :p
05:19:15 <merijn> dminuoso: Or prettyprinter
05:19:24 <dminuoso> Indeed.
05:19:53 <Rembane> sed <3
05:29:01 <olligobber> dminuoso, does that extend to avoiding using the monoid instance of ShowS, since ShowS = String -> String so (<>) = lift (++)
05:29:09 <olligobber> s/lift/fmap
05:29:25 <olligobber> no, liftA2
05:30:34 <dminuoso> olligobber: Sadly you need the Endo newtype wrapper for that.
05:31:02 <merijn> dminuoso: That's not sad, Endo is clearly inferior to the great function Monoid!
05:31:15 <dminuoso> actually.. you could use (<>) heh
05:31:26 <dminuoso> % (shows "foo" <> shows "bar") ""
05:31:27 <yahb> dminuoso: "\"foo\"\"bar\""
05:31:48 <dminuoso> Im not sure it will perform well though.
05:31:55 <olligobber> but wouldn't the Endo wrapper be much faster?
05:32:20 <dminuoso> olligobber: Yes.
05:32:33 <olligobber> annoying
05:32:42 <dminuoso> olligobber: Well that's my thought anyway.
05:33:24 <olligobber> wait, Control.Monad.Writer exports Endo?
05:33:27 <dminuoso> olligobber: However, there's a cool primitive you could use
05:33:37 <olligobber> dminuoso, hmm?
05:33:38 <merijn> Writer is a terrible Monad anyway
05:33:49 <olligobber> merijn, I like it
05:33:59 <merijn> olligobber: Performance is shite, though :p
05:34:06 <dminuoso> % appEndo (foldMap (Endo . shows) ["foo", "bar", "quux"]) ""
05:34:06 <yahb> dminuoso: "\"foo\"\"bar\"\"quux\""
05:34:08 <merijn> Better off using State
05:34:10 <dminuoso> olligobber: ^-
05:34:24 <dminuoso> foldMap is by far one of my favourite functions. :)
05:34:36 <merijn> dminuoso: I just wish there was a version with sane strictness
05:34:45 <merijn> dminuoso: I almost never want a lazy mappend
05:34:58 <olligobber> dminuoso, oh, I wasn't the one using mconcat earlier, I just wanted a vaguely fast monoid string
05:35:10 <dminuoso> olligobber: Use text.
05:35:29 <dminuoso> olligobber: The problem is not how to get a convenient way to use shows, but that you are using string to begin with.
05:35:30 <olligobber> I guess I should start using it at some point
05:38:01 <merijn> Text also has Builder monoid for fast construction
05:40:15 <olligobber> merijn, so Text's monoid instance isn't fast, but this Builder is?
05:40:27 <merijn> Define "isn't fast"
05:40:32 <merijn> "It Depends (TM)"
05:40:46 <dminuoso> olligobber: text monoid is still blazing fast compared to string
05:40:54 <olligobber> that will do for me then
05:41:10 <dminuoso> (At least if you have strings of non-trivial sizes)
05:41:22 <merijn> Strict Text needs to copy both Text into a new location that fits both of them, which has a cost
05:41:30 <merijn> If you only do that once, it hardly matters
05:41:48 <merijn> But if you know you're going to append 10k times, then you run into a Schlemiel the Painter algorithm
05:43:28 <merijn> So "is it slow?" depends on "what do you intend to do with the result?"
05:43:45 <olligobber> I see
05:44:09 <olligobber> I'll just use Text and hope
05:44:13 <merijn> As always, performance is a mostly hollistic problem
05:44:30 <merijn> olligobber: At the very least Text is gonna dramatically reduce memory usage
05:44:57 <merijn> Since going from 24 bytes per character to (on average) 2 tends to have that affect
05:45:16 <merijn> Plus, better cache locality for Text
05:45:23 <dminuoso> 14:34:13          merijn | dminuoso: I just wish there was a version with sane strictness
05:45:28 <dminuoso> % :t foldMap'
05:45:29 <olligobber> good, I imagine what I'm doing will use a fair bit of memory in the worst cases
05:45:29 <yahb> dminuoso: ; <interactive>:1:1: error:; * Variable not in scope: foldMap'; * Perhaps you meant one of these: `foldMap' (imported from Prelude), `foldMapBy' (imported from Control.Lens), `foldMapOf' (imported from Control.Lens)
05:45:47 <dminuoso> huh
05:45:55 <merijn> olligobber: If your gonna process more than, say, 100 lines of text you basically never want String
05:46:11 <dminuoso> merijn: Well, it was here https://phabricator.haskell.org/D4924
05:46:15 <dminuoso> No idea what happened to that.
05:46:50 <dminuoso> Id rather count the string in terms of characters... 100 lines can be anything between 100 characters and 100 billion characters...
05:46:58 <dminuoso> And more..
05:48:00 <merijn> dminuoso: oh, base-4.13
05:48:05 <merijn> dminuoso: That's GHC 8.8
05:48:08 <olligobber> my text editor will wrap lines above a certain length even with wrapping turned off
05:48:51 <dminuoso> merijn: There you go! Good reason to upgrade. :)
05:49:18 <merijn> dminuoso: Better reason would be the fact that I've heard that 8.8 compiles are considerably faster
05:49:27 <olligobber> though trying to work with 10,000 character regex expressions is going to run into lots of weird issues
05:50:23 <merijn> olligobber: eeww
05:50:59 <olligobber> merijn, yeah, luckily I found a smaller regex with the same issue and managed to fix it
05:58:39 <olligobber> huh, <$ seems very useful surprisingly
05:59:11 <heatsink> the less money operator
05:59:30 <Rembane> The more money operator is also very good
05:59:39 <Rembane> Depending on if you want to program from left to right or right to left
05:59:44 <olligobber> % "Premise" <$ [1,6,2,4,8]
05:59:45 <yahb> olligobber: ["Premise","Premise","Premise","Premise","Premise"]
06:05:19 <dminuoso> olligobber: A really neat use is: () <$ ...
06:05:30 <dminuoso> () <$ do ... 
06:05:46 <dminuoso> It's sometimes easier to read than trailing with `pure ()` or using `void` which I find terribly named.
06:06:47 <sshine> dminuoso, it came before Void :)
06:09:43 <olligobber> dminuoso, I have considered using it like that
06:13:18 <sim590> Also creating a matrix with default values inside is handy with <$. For example, in my labyrinth problem, I did `replicate (fromIntegral w') (True <$ [1..h'])` where w and h were resp. width and height.
06:17:09 <Rembane> sim590: I've fallen down the tree of stupid, what does that expression evaluate to? 
06:18:38 <sim590> Rembane: a matrix of width and height (w,h) with values `True` inside.
06:18:57 <sim590> It creates columns of height h and replicates columns.
06:19:02 <sim590> w times.
06:20:54 <dminuoso> % replicate 10 (replicate 20 True)
06:20:55 <yahb> dminuoso: [[True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True],[True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True],[True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True],[True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,Tr
06:23:12 <sim590> Indeed, replicate could have been used instead of <$ and [1..h]. ;)
06:23:43 <olligobber> it could also be useful if you have some complex data structure where the structure itself can be shown but the data it contains can't be
06:25:08 <olligobber> % "Function" <$ [[(+1), (^2)], [], [id, const 1, (0-)]]
06:25:09 <yahb> olligobber: ["Function","Function","Function"]
06:25:15 <olligobber> oops
06:25:35 <olligobber> % fmap ("Function" <$) [[(+1), (^2)], [], [id, const 1, (0-)]]
06:25:36 <yahb> olligobber: [["Function","Function"],[],["Function","Function","Function"]]
06:26:12 * hackage language-protobuf 1.0 - Language definition and parser for Protocol Buffers.  https://hackage.haskell.org/package/language-protobuf-1.0 (AlejandroSerrano)
06:26:55 <dminuoso> I think a great use for <$ might actually be in parsers.
06:27:07 <dminuoso> Something like `True <$ string "foo"`
06:27:25 <dminuoso> e.g.
06:28:12 <phadej> just used it like that
06:28:22 <phadej> replace ("foo <$ string "bar") sometext
06:29:19 <Rembane> sim590: Sweet! 
06:29:30 <phadej> actually replace ("foo" <$ string "bar" <|> "quu" <$ "uup" <|> ...) sometext -- https://hackage.haskell.org/package/regex-applicative-text-0.1.0.1/docs/Text-Regex-Applicative-Text.html#v:replace
06:30:51 <sshine> dminuoso, yes, <$ is neat in parsers.
06:33:40 <sshine> dminuoso, like <* :)
07:06:51 <olligobber> how do I print out Text?
07:09:09 <jgt> print ("foo" :: Text)
07:10:29 <cocreature> Data.Text.putStrLn ("foo" :: Text) might be more appropriate
07:10:33 <olligobber> I mean what is the Text equivalent of putStrLn
07:10:37 <cocreature> print calls `show` which will add quotes and escape
07:10:45 <cocreature> *Data.Text.IO.putStrLn
07:11:19 <jgt> true; I rarely use either of those unless I'm doing printline debugging
07:11:34 <jgt> in which case, it doesn't matter so much
07:23:45 <AWizzArd> Does it require much Emacs magic to use both, stack and dante?
07:44:12 * hackage di-monad 1.3.1 - mtl flavoured typeful hierarchical structured logging for di-core.  https://hackage.haskell.org/package/di-monad-1.3.1 (RenzoCarbonara)
07:44:52 <merijn> cocreature: Does ghcide's hover only support single variable/value inputs, or is this just a limitation of my LSP plugin?
07:47:30 <dminuoso> Im running monad-logger with runStdoutLoggingT, and when my process is running as a systemd unit, I dont see any logs written to the journal (Ive even explicitly set stdout and stderr to be written to journal). When I run the server by hand, I get log output as usual. The thing I dont get, looking at the implementation of runStdoutLoggingT, there's no probing whether Im on an interactive terminal..
07:47:57 <merijn> dminuoso: Why would it probe whether there's a terminal?
07:48:19 <cocreature> merijn: lsp doesn’t support passing ranges iirc
07:48:21 <dminuoso> merijn: My thinking was "whats different when this is ran as a systemd service"
07:48:27 <cocreature> and ghcide inherits this limitation
07:48:28 <merijn> cocreature: That's a bummer :\
07:48:39 <dminuoso> merijn: So I figured "hey maybe this does some ansi-terminal shenanigans for whatever reason"
07:48:40 <cocreature> I _think_ there might be something in LSP 3.15 but that’s still in a draft state
07:49:57 <geekosaur> dminuoso, does it write enough? logging not to terminal will be buffered
07:50:06 <geekosaur> 4K or 8K are common buffer sizes
07:50:28 <merijn> geekosaur: Should be flushed upon exit, though
07:51:01 <geekosaur> true
07:51:39 <dminuoso> geekosaur: Ah interesting. Spot on, its the buffering. But the logs are not flushed upon exit.
07:52:07 <geekosaur> oh, hm. systemd will send it SIGTERM to shut it down, not normal exit
07:52:27 <geekosaur> and it's not safe to flush in the signal handler
07:52:52 <geekosaur> I'd hSetBuffering stdout LineBuffered
07:53:17 <geekosaur> or whatever the appropriate constructor is
07:53:41 <merijn> cocreature: in hdevtools I could repeatedly do "get type" and it'd expand the expression one step further and that was super nice, guess I'll keep an eye out on how LSP develops
07:53:59 <dminuoso> geekosaur: Interesting, so if a process is terminated its handles are not flushed?
07:54:16 <dminuoso> Or is that haskell-side buffering here?
07:54:31 <merijn> cocreature: Then again I'm not sure whether moving this to the LSP client is really feasible anyway, since then your client has to understand how to correctly parse haskell (sub) expressions, which seems undesirable
07:55:25 <geekosaur> it's haskell-side (and also applies to C stdio)
07:55:43 <dminuoso> By C stdio because the glibc sits in between?
07:55:51 <geekosaur> you can't flush from the signal handler, best you could do is somehow notify the program to exit and then return from the signall handler
07:55:51 <dminuoso> (Or whatever c library you'd be using)
07:55:57 <dminuoso> Mmm
07:56:10 <geekosaur> "stdio" means what glibc or other libc provides, yes
07:56:25 <geekosaur> raw C I/O is unbuffered read() and write() calls
07:57:25 <merijn> cocreature: I guess what you'd really need for that is some sort of stateful query, so maybe that's out of scope for now
07:57:36 <merijn> geekosaur: What does raw C even mean? >.>
07:58:02 <geekosaur> "C" is an adjective there, bboth applying to "I/O"
07:59:35 <dminuoso> I see. Why wouldn't it be safe to flush buffers in a SIGTERM handler? Wouldn't that be the clean-up semantics that SIGTERM is for, compared to SIGKILL?
07:59:53 <merijn> dminuoso: There is no SIGTERM handler by default
08:00:03 <dminuoso> No but I could install one.
08:00:08 <merijn> Sure
08:00:35 <merijn> I'd just intercept SIGTERM and have it trigger graceful shutdown
08:00:37 <dminuoso> merijn: I was just referring to
08:00:41 <dminuoso> 16:55:28       geekosaur | you can't flush from the signal handler, best you could do is somehow notify the program to exit and then return from the signall handler
08:00:58 <merijn> dminuoso: You can't do anything useful from the handler
08:01:22 <merijn> dminuoso: Any form of IO and really 90% of libc are unsafe to call from within a signal handler
08:01:29 <geekosaur> dminuoso, signals are not delivered at known-safe times, stdio internal structures, malloc internal structures, etc. are in an indeterinate state
08:01:37 <merijn> dminuoso: You can't even malloc from a signal handler
08:02:13 <merijn> dminuoso: If you wanna know how to do this stuff properly I can *highly* recommend that book "Advanced Programming in the UNIX Environment"
08:02:22 <geekosaur> haskell signal handlers do make some attempt to deal with this since arbitrary haskell code needs to be able to allocate from the nursery, but it's not safe enough to make I/O calls iirc
08:02:31 <merijn> dminuoso: That will teach you all the creative ways 90% of the software you use fucks up and how to do things properly
08:03:04 <merijn> The sane way to handle this is to have the handler set an MVar/TVar/throw an async exception
08:03:25 <merijn> Anything else is a shortcut to madness
08:03:32 <geekosaur> ^
08:04:03 <merijn> And also, buy a copy of that book I mentioned, because more people should read it
08:04:13 <merijn> It's the bible of writing portable, correct *nix software
08:07:39 <merijn> Unrelatedly...
08:09:14 <merijn> I have a bin-packing problem. I have N slots and M chunks of different sizes to fit into it. Is there some nice/simple approach to maximise the number of filled slots?
08:10:12 <heatsink> Does the problem have constraints, such as a small constant bound on the slots or chunk sizes?
08:10:21 <geekosaur> only in certain special cases?
08:10:54 <hyperisco> Last time I looked into bin packing, years ago, the first question to ask is how much time you want to trade for optimality
08:11:02 <merijn> heatsink: I'm just looking for max utilisation, I guess I can just do some silly greedy approach?
08:11:10 <heatsink> If the maximum chunk size is much less than the maximum slot size, you can get pretty close to optimal with the greedy approach
08:11:36 <hyperisco> After you figure that you've already pared down the viable solutions considerably
08:11:38 <merijn> In my case both numbers are fairly small, maybe I should just exhaustively search with a greedy algorithm
08:21:44 <duairc> I'm trying to copy the runST trick for a monad that I'm working on, but I think I must be missing something
08:22:31 <duairc> I get this error: https://upaste.de/raw/UHT
08:23:07 <merijn> duairc: Can't store RankN values inside datatypes
08:23:34 <cocreature> you totally can but not on polymorphic fields
08:23:43 <merijn> duairc: Not without ImpredicativeTypes anyway, which you shouldn't use because they're super broken
08:23:44 <cocreature> if you have a field that has a rankntype that works just fine
08:24:08 <kuribas> merijn: put the smallest chunk in the smallest slot, etc... ?
08:24:20 <kuribas> merijn: that should maximise the number of filled slots.
08:24:28 <merijn> I think there's an actual working prototype for impredicative types, but that is only in heads
08:24:46 <merijn> kuribas: Slots are fixed size, different chunks just take up different amount of slots
08:24:47 <duairc> merijn: Okay, but am I doing that? I don't understand how the type signature of what I have is different from that of runST
08:24:51 <duairc> That error message is from this: https://upaste.de/raw/nER
08:25:16 <duairc> s is just a phantom type variable
08:25:31 <merijn> duairc: Oh, add an explicit  argument to run and it'll probably work
08:26:02 <kuribas> merijn: if the slot size is small, dynamic programming should work
08:26:37 <merijn> kuribas: ok, let me rephrase, slots don't have a size, they're just "a thing" and the chunks just take up a fixed amount of slots
08:26:53 <kuribas> merijn: erm, I mean number of slots
08:27:07 <duairc> merijn: What do you mean by "an explicit argument"?
08:28:09 <merijn> duairc: "run = undefined" -> "run x = undefined"
08:28:34 <duairc> merijn: Oh, of course
08:28:39 <duairc> That makes sense. Thanks!
08:29:23 <merijn> duairc: RankNTypes are fully inferrible, so I'm guessing this function type is complaining about trying to make undefined fit. Adding the explicit argument should just infer "undefined :: m Template" and that (I'm guessing) it'll be happy again
08:29:47 <kuribas> merijn: complexity is O(number of chunks * number of slots)
08:29:57 <kuribas> merijn: worst case
08:32:51 <kuribas> merijn: create an intmap, where a number is in the map if you can fill that amount of slots with the given chunks.
08:33:14 <merijn> kuribas: I think I'm just going to use a simple greedy fill, yes
08:33:41 <kuribas> merijn: you don't need an optimal solution then?
08:33:52 <merijn> kuribas: I just need "not terrible"
08:36:38 <dmwit> merijn: Bin-packing is NP-complete.
08:36:51 <wroathe> Anyone know where the documentation on representing a C union in Haskell for FFI is?
08:36:56 <dmwit> So... no, there is no nice/simple approach to maximize the number of filled slots.
08:37:05 <dmwit> Alternately: yes, there is a nice/simple approach, namely brute force.
08:37:29 <merijn> dmwit: I know, but I just need approximate and reasonable, not "optimal and exact"
08:37:32 <dmwit> But Wikipedia says the obvious greedy algorithm gets you an approximation factor of 2, so.
08:37:59 <merijn> wroathe: "the biggest of the two types"? :p
08:38:02 <kuribas> dmwit: it's O(n*m)
08:38:26 <kuribas> dmwit: if the slots are the same size
08:38:32 <wroathe> merijn: Well, for the "peek" implementation of storable there's no way to know which of the member types it is
08:38:52 <merijn> wroathe: Well, sure
08:39:02 <merijn> wroathe: So you need to use whichever type it actually when calling peek
08:39:04 <wroathe> merijn: The union I want to represent is: union entry { void *v; int i; };
08:39:10 <merijn> wroathe: i.e. just cast the Ptr
08:39:17 <dmwit> merijn: https://en.wikipedia.org/wiki/Bin_packing_problem discusses several variants and their tradeoffs. Worth a look, I think.
08:39:38 <merijn> wroathe: Are you getting those by value or just have a pointer to that union?
08:39:53 <wroathe> By value, specifically this is a hash table in C
08:39:57 <wroathe> and it's for the insert function
08:40:12 <wroathe> so something like: String -> Entry -> Ptr HashTable
08:40:12 <merijn> wroathe: Does that even have a well-defined implementation in the ABI?
08:40:28 <wroathe> define well-defined
08:40:47 <wroathe> struct hash_table *htinsert(char const *key, union entry const val, struct hash_table *table);
08:40:59 <wroathe> This is the signature, if that's what you mean
08:41:01 <merijn> wroathe: There is a C ABI, that's what GHC uses, anything that's not part of your platform's C ABI (like passing structs by value) is not something you can sensibly do
08:42:00 <merijn> wroathe: Ok, a quick google seems to imply that's not part of the C ABI, so the answer is "you're hosed, don't do that"
08:42:17 <wroathe> merijn: Can you link where you read that?
08:42:33 <wroathe> I've heard the term ABI before, but I'm honestly not familiar with it
08:42:54 <merijn> wroathe: ABI = Application Binary Interface, i.e. "what does this look like at the assembly level"
08:43:25 <wroathe> merijn: Yeah, I got that far :P. The determination that something is not part of something elses ABI is what I'm unclear on
08:43:26 <merijn> wroathe: To be able to call functions compiled by another C compiler (or via the FFI) you need to know things like "what do arguments look like on the call stack?" and "what are sizes of things"
08:44:07 <wroathe> merijn: So in my case I should just be able to use the c calling convention and say that this thing is 8 bytes in size
08:44:13 <merijn> wroathe: The ABI is platform specific, although (afaik) all relevant unices use the same things (only sizes vary across them), although windows has a different one
08:44:15 <geekosaur> you hope
08:44:16 <dmwit> Don't cast pointers between Ptr (Ptr CVoid) and Ptr Int if what you really have is a Ptr to a union entry. Your array arithmetic isn't guaranteed to work right.
08:44:33 <merijn> wroathe: My point is the "the c calling convention" *is* the ABI
08:44:35 <wroathe> geekosaur: I'm not programming for more than just my Macbook Pro as a platform, so I know
08:44:43 <merijn> wroathe: And passing unions by value may not be defined
08:45:00 <merijn> wroathe: Which means it only works if the code calling that functions is compiled by the same compiler as the function itself
08:45:03 <wroathe> dmwit: In this case it's not a pointer
08:45:15 <merijn> wroathe: For example, passing structs by value is *not* part of any ABI
08:45:23 <wroathe> dmwit: I'm trying to represent struct hash_table *htinsert(char const *key, union entry const val, struct hash_table *table);
08:45:42 <merijn> wroathe: Therefore you *can't* "use the c calling convention" to call something that takes a struct by value, because you don't know what that means
08:46:49 <merijn> wroathe: To be sure, lookup the ABI for your platform and check if its defined
08:47:08 <merijn> Something like "x64 macos ABI" should turn up something relevant
08:47:49 <merijn> wroathe: Is that function in source that you wrote?
08:47:54 <wroathe> merijn: I'm obviously not understanding, but it sounds to me like you're saying that passing a union by value on x86 is not defined?
08:47:58 <wroathe> merijn: Yes
08:48:18 <merijn> wroathe: The sanest/simplest solution is "change the source to take a pointer to a union"
08:49:00 <wroathe> merijn: This is all just so I can QuickCheck my the C code. I'm not going to change the implementation just to suit Haskell's idea of FFI
08:49:03 <merijn> wroathe: I'm not certain, this is a 80% certainty guesstimate, but I think it's the same as struct where "not defined" isn't quite adequate
08:49:25 <merijn> wroathe: It's more like "not defined in some portable method that is consistent across compilers/implementations"
08:49:45 <wroathe> I really don't care about portability in this case
08:49:51 <merijn> wroathe: But you do
08:50:02 <merijn> wroathe: Because GHC is another compiler
08:50:11 <merijn> wroathe: GHC and the compiler you're using for C *need to agree*
08:50:16 <wroathe> It sounds like I just need to say that this is a pointer and then cast it in Haskell
08:50:22 <merijn> wroathe: And you have no way of knowing whether they do
08:50:23 <wroathe> If I want to work with the int member
08:50:39 <merijn> wroathe: "maybe"
08:50:44 <geekosaur> merijn, it's one of the pwb / system III / system V additions to libc, I don't think glibc supports it because it's a lousy API much less ABI
08:50:49 <merijn> Depends on how your C compiler compiles that
08:51:07 <merijn> Anyway, gotta run
08:51:14 <geekosaur> and gnu has had its own hash tables for longer than glibc has existed
09:02:56 <sshine> it seems that the 'memoize' package uses BSTs rather than wider tries, e.g. ones provided by Hashable/HashMap.
09:20:12 * hackage mmsyn5 0.2.1.0 - Various additional operations on lists  https://hackage.haskell.org/package/mmsyn5-0.2.1.0 (OleksandrZhabenko)
09:33:12 * hackage pandoc-citeproc 0.16.3.1 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.16.3.1 (JohnMacFarlane)
09:36:02 <dsal> I'm using amazonka for a thing I run once a month.  Looks like Amazon broke a public API.  I probably fixed it in my code, but I won't know until next month.  heh
10:06:10 <maralorn> After I got so friendly help about haskell-ci here. I have two questions. 1. Can I make travis use -Werror when I only have -Wall in my cabal file. 2. Can I make the tests fail on incomplete haddock coverage?
10:09:23 <TheCommieDuck> However much I try, I just cannot think in a haskell way rather than an object way.
10:11:36 <jle`> TheCommieDuck: it just takes practice :)
10:11:47 <jle`> TheCommieDuck: it usually takes a few years for people to start getting the hang of the object-oriented way
10:12:12 * hackage token-limiter 0.2.0.2 - Fast rate limiting using the token bucket algorithm (BSD)  https://hackage.haskell.org/package/token-limiter-0.2.0.2 (GregoryCollins)
10:12:22 <jle`> so it wouldn't be too surprising for it to take a few years to start training yourself in another way too
10:12:54 <dsal> TheCommieDuck: You  can be cured.  I used to program in OO and now I generally find it an absurd way to think about things.
10:13:15 <TheCommieDuck> Like, the shape example. OO you have a Shape then Circle, Triangle, Square each of which has area. The haskell way is that any kind of Shape collection can only be used for its areas, so why not just store the list of floats of the areas.
10:14:18 <TheCommieDuck> which makes sense up until the point I get...but what if I want to now do something else with the shapes? but I then can't think /what/ else I'd even do. But it seems bizarre, still. Like I'm missing the basic idea of how to store a thing.
10:14:54 <jle`> it sounds like you are able to think in the haskell way
10:15:26 <TheCommieDuck> I'm able to regurgitate the "haskell way" to a problem I have googled for a dozen or more hours over the last few days but cannot get my head around how or why :P
10:15:28 <dmwit> TheCommieDuck: Are you actually writing a program which has to muck about with shapes?
10:15:40 <dmwit> If no, then no problem. Bring us the problem with the actual program you want to write.
10:16:15 <dmwit> (I aim this same comment at people who use sized vectors as an example of what dependent types are good for. ;-)
10:16:17 <jle`> this sort of "i can't think of what else i'd even do" is a common result of fp 'vertigo' i think. people try to relate small parts of what they used to know to this new domain
10:16:28 <jle`> but in the big picture it doesn't really matter
10:16:31 <jle`> but it makes them really stressed out
10:16:56 <jle`> 'i can't mutate variables? how can i change every item in a list without mutating a counter variable then?'
10:17:07 <jle`> but in the end in the big picture these fears don't really matter
10:17:33 <TheCommieDuck> I'm trying to construct a problem which doesn't immediately start with "I have these objects..."
10:17:42 <jle`> like in this case TheCommieDuck can't even figure out what they are afraid of might happen
10:17:46 <jle`> they just have a base level of fear and stress
10:17:48 <dmwit> What if I told you there was no counter. morpheus.jpg
10:17:56 <dsal> I saw someone describe the difference between OO and FP as where you have to do the extra work.  Something about functions growing for types in FP where types grow for functions in OO.
10:18:07 <TheCommieDuck> I mean, congrats #haskell for working out my life faster than I have. 
10:18:12 <dmwit> dsal: aka the expression problem
10:18:22 <jle`> TheCommieDuck: try writing a program :)
10:18:33 <jle`> then the 'real problems' will start to come up, without you having to construct them
10:18:38 <dmwit> ^
10:19:00 <sm[m]> jle, “FP vertigo” is a great term :)
10:19:08 <dsal> Starting with a canonical OO problem and a canonical OO solution makes orientation a bit difficult.
10:19:09 <TheCommieDuck> I did try writing the program, my first error was "yknow, this feels an awful lot like I'm just bodging OO into FP". :p
10:19:24 <dmwit> Cool! What program did you try to write?
10:20:24 <TheCommieDuck> https://pastebin.com/C04wxfbY I tried to get a system of general things and physical things for a text adventure esque world.
10:20:42 * hackage token-limiter 0.2.0.3 - Fast rate limiting using the token bucket algorithm (BSD)  https://hackage.haskell.org/package/token-limiter-0.2.0.3 (GregoryCollins)
10:20:56 <TheCommieDuck> somewhat generic-made MWE, 'str' was 'nameOf' in my code.
10:21:22 <dmwit> Well, I think the first problem we can help you solve is picking better names. ^_^
10:22:11 <dmwit> What is the meaning of the `String` and `Int` in an `Object`?
10:22:36 <dsal> What is your program trying to do?
10:23:10 <TheCommieDuck> give me 2 minutes to get the messier version onto pastebin. :P
10:23:17 <dsal> If you're interested in shapes, try something like this:   Write a text file with a list of shape parameters that matter to you.  Things like "circle 5" and "rectangle 3 6" and then  spit out the area of each line.
10:23:19 <dmwit> Very good!
10:23:47 <dsal> It would be strange to implement something like the above with the word "class" ever showing up.
10:24:52 <TheCommieDuck> I mean I can look at that problem statement, I can tell you how it'd be solved in the functional way, and I can stand here and call myself an idiot for wondering why I had an issue with the solution for it. :P
10:26:33 <dmwit> Well, the first two of those three steps sounds productive, at least. ^_^
10:29:00 <dmwit> (Are we still going to get the messier version?)
10:29:30 <TheCommieDuck> Yeah, I was just having issues with vscode.
10:30:05 <TheCommieDuck> https://pastebin.com/sp86v8Sz
10:33:59 <dmwit> What goes wrong if you don't have any of these classes?
10:34:06 <wildtrees> TheCommieDuck, have you heard of Sum types and algebraic datatypes? 
10:34:16 <dsal> TheCommieDuck: It's not clear what you're doing there.  It mostly just looks like you're trying to make lots of classes  and stuff.
10:34:32 <dmwit> Why are outside rooms a different type than rooms?
10:34:34 <TheCommieDuck> excellent, I just deleted everything I typed and weechat doesn't seem to have an undo. whoops.
10:34:48 <dmwit> (...why do directions have objects?)
10:35:15 <TheCommieDuck> directions are objects because they have the same data access that other objects do, like names and ids.
10:36:03 <dmwit> I see. Have you considered inverting the container relation?
10:36:37 <TheCommieDuck> name :: Direction -> String is a function that makes sense, except it acts in the same way that name :: Room -> String does, or anything else. And I do know ADTs, sum types, etc - but I guess I shied away from them for a) aiming for code reuse and b) wanting to keep things extensible rather than a sum type with 50+ variants.
10:36:46 <dmwit> data Identified a = Identified { uniqueID :: ID, name :: Name, isProper :: Bool, isPlura :: Bool, value :: a }
10:37:12 <dmwit> Then you can have e.g. `type Direction = Identified Text` (or use a newtype).
10:37:12 * hackage req 3.0.0 - Easy-to-use, type-safe, expandable, high-level HTTP client library  https://hackage.haskell.org/package/req-3.0.0 (mrkkrp)
10:37:32 <dmwit> Similarly `data Room = Room Darkness Description` and then you can distinguish between `Room` and `Identified Room`.
10:37:54 <dmwit> And you would have `name :: Identified a -> Text` for free from the record declaration.
10:38:55 <dmwit> for clarity: s/(or use a newtype)/(or use a newtype wrapper around Text)/
10:39:06 <TheCommieDuck> oh, yes.I think I see. So let's take a Room by that structure; type Room = Identified (Bool, Text)? 
10:39:31 <TheCommieDuck> (i.e. a flag if the room is dark or not, and a textual description for this case)
10:39:32 <dmwit> Roughly, yes. Though I wouldn't shy away from making a real data structure rather than reusing tuples.
10:39:49 <TheCommieDuck> Yeah or some kind of type Room = Identified RoomData
10:39:55 * dmwit nods
10:41:18 <dmwit> I think I'd probably also do something like `data RoomData = Inside Darkness Description | Outside Darkness Description HasTrees` or similar, unless there's a really good reason for inside and outside rooms to be different types.
10:41:34 <TheCommieDuck> I had just typed "but how is this any different to what I've done" and it's started to click; now the additional gubbins is stored inside the type (parameteric polymorphised) rather than me bolting it on 
10:41:39 <TheCommieDuck> I think?
10:42:05 <dmwit> Yep. What's different is that the data representation is more uniform, and so the queries for specific parts of the data representation are easier to write.
10:43:23 <TheCommieDuck> and at some point, if it gets sufficiently complex with the levels of nesting, that explains why lenses are so useful. Yes. I think.
10:43:46 <dmwit> I would not expect to see very many layers of nesting.
10:44:41 <TheCommieDuck> I strongly doubt more than what, 4 or 5? but enough that I can see "hm, time to learn lenses to make this access easier"
10:44:56 <dmwit> ...but yes, one of the raisons detre of lenses is updating deeply-nested records. See also https://stackoverflow.com/q/7365425/791604
10:45:08 <dmwit> TheCommieDuck: Uh. I would be surprised to see more than 2, hah!
10:45:14 <wildtrees> thecoffemaker, I wrote a bit of a mud using Data.Maps of Data.Maps and sum types for the values, and lenses, though I kind of lost strong typing and its almost like dynamic typing 
10:45:16 <TheCommieDuck> thank you very much, I think I can feel the gears starting to turn :) I knew of parametric polymorphism, but this really made me go "ohhhhh" as to how it applied in this case.
10:45:25 <dmwit> And if I did see more than two, *probably* my first tool to reach for would be refactoring, not lenses.
10:45:54 <dsal> TheCommieDuck: This is where the interesting thing happens... instead of having a bunch of types and a class that specifies a property and then having an instance of that class for each type, you just have the one function that does different things based on the input value.
10:46:03 <dmwit> Then again, some of my opinions about code are relatively unpopular.
10:46:37 <TheCommieDuck> from the model I'm loosely basing off, Object (or Identified, I suppose) -> Thing -> Being -> Person -> Player seems to be the longest chain I can reasonably expect.
10:46:51 <TheCommieDuck> but who knows, probably don't actually need all that.
10:48:10 <dmwit> I don't mean to say that data structures never get nested. What I mean is that you almost never care to operate on more than one or two layers of nesting at a time.
10:48:14 <TheCommieDuck> dsal: yeah, and it makes far more sense to reason about; I'm not reasoning about different types for the most part, they're the same types but with a slight change based on parametricity? Maybe? Okay or this is now going too far and losing what I just had :P
10:48:18 <TheCommieDuck> ahhh, yes yes
10:48:58 <dmwit> Because you have written an API for Things, right? And most of the stuff you're doing to an Object that has a Thing in it involves using the Thing's API, not descending into the Thing's Being's Person's Player and using the Player's API.
10:49:19 <dsal> TheCommieDuck: That's why I suggested the shape exercise above based on what you  were saying about shape stuff.  How you'd model that in Haskell would  look something like   area :: Shape -> Size
10:49:44 <TheCommieDuck> and I don't at any point need to care about this notion of "but what if I want to hold onto these arbitrary shapes"
10:49:59 <dmwit> But then, I'd be sort of surprised if you actually ended up with a Object -> Thing -> Being -> Person -> Player stack, too, and so if you do have something where you think that's the sanest design you should show us so we can offer advice and (maybe!) propose alternatives.
10:53:53 <jpcooper> Hello. In the context of a stack project, given a .h file for a .o static library, how can I have the library linked with my programme so that it can be used from the FFI?
10:55:29 <TheCommieDuck> (but yes, thank you very much again. hope to hang around and eventually be able to pass the help along too someday!)
11:09:22 <unfixpoint> While trying to figure out what license I need to use for my project I noticed that HDBC-mysql is under LGPLv2.1 which is the least permissive (other deps are BSD-3, MIT and BSD-2 licenses). So from my little knowledge about licenses I'd say I will need to pick LGPLv2.1 as well.
11:10:48 <unfixpoint> However when looking at reverse deps, I found that haskelldb-hdbc-mysql and sprinkles too depend on HDBC-mysql, but they use BSD-3 licenses. Is this a mistake by their maintainers, or do I mistake things?
11:10:56 <wroathe> So given that union type from earlier: union entry { void *v; int i; }; it seems that I'd need to be able to cast between a Ptr a and an Int32 in order to represent this with Haskell's FFI. coerce complains when I try that. Is there a straightforward way to do Ptr a -> Int32?
11:11:48 <wroathe> For context, I'm trying to represent struct hash_table *htinsert(char const *key, union entry const val, struct hash_table *table); with Haskell's FFI
11:13:53 <f-a> unfixpoint: they might be going for paragraph 5 somehow https://www.gnu.org/licenses/lgpl-3.0.html
11:13:57 <f-a> I agree with you , dodgy 
11:16:14 <wroathe> Actually, I wonder if I can use a typeclass for this
11:17:11 <f-a> unfixpoint: I'd file a issue on their repo
11:17:12 <jpcooper> I feel like extra-libraries is close, but it seems to take shared library names only
11:17:18 <unfixpoint> Freaking licenses -.- why do such things need to get into the way of things
11:17:52 <f-a> because otherwise you end up like BSD guys, surviving on 20k a years while BIG_CORP rakes millions
11:19:52 <f-a> https://www.gnu.org/licenses/gpl-faq.html#LGPLStaticVsDynamic check if they comply with this unfixpoint 
11:20:54 <unfixpoint> I really don't want to be/become the lawyer guy :S
11:21:02 <kosmikus> I'm not a license expert, but we're talking about reverse dependencies in source form here, right? I fail to see how their license could be constrained by a dependency being LGPL.
11:22:10 <kosmikus> If you build any binaries, you obviously have to consider the licenses of the transitive closure of all your dependencies.
11:22:55 <nshepperd2> Not constraining reverse dependencies is sort of the point of LGPL (as opposed to GPL)
11:23:06 <tdammers> indeed
11:23:26 <tdammers> IIRC the idea with LGPL is that as long as you link against an unmodified version of the library, it doesn't become infectuous
11:23:32 <kosmikus> even the GPL should not constrain source code reverse dependencies, as long as you don't either include source code or distribute binaries?
11:23:44 <tdammers> but if you modify the library itself, you have to redistribute those changes under LGPL as well
11:24:30 <tdammers> kosmikus: indeed; but that's not due to how the GPL is written, but simply because just saying "this code depends on library X" (which is all there is to a dependency) doesn't make it a derived work
11:24:42 <kosmikus> right
11:25:06 <tdammers> only when you actually pull in the code and link yours against it does the resulting program become a derived work
11:25:14 <kosmikus> yes, that's my understanding
11:25:18 <tdammers> (or when you actually copy their code into your project, of course)
11:25:26 <kosmikus> also agreed
11:25:28 <unfixpoint> I really don't understand much of that jargon there, but it does seem like kosmikus says. That if I don't distribute binaries, I'll be fine with a BSD-3 license. The project will be software as a service w/o any moneys involved
11:25:36 <tdammers> I believe some FSF people would love for the law to be different, but it's not, and I think it would be silly
11:26:42 <kosmikus> right, I'm not ruling out that laws are very strange, but it would feel completely absurd to me that changing a line in a cabal file could force me to change a license as long as I'm not providing any binaries
11:27:03 <wroathe> Hmm, well that didn't work either: https://gist.github.com/JustinChristensen/084249315394df90fe37d3487de2d66d
11:27:06 <kosmikus> anyway, as I said, I'm not an expert. I could be wrong.
11:27:17 <wroathe> Apparently FFI doesn't like class constraints
11:28:48 <f-a> of course you would have to change the licence
11:29:05 <f-a> otherwise you are sharing an undistributable repo (in binary form)
11:29:18 <nshepperd2> wroathe: how is foreign code supposed to use a type class dictionary?
11:29:44 <f-a> that's as polite as pushing something that does not compile on hackage  
11:30:22 <wroathe> nshepperd2: It's not. I was hoping that I'd be able to tell Haskell that this parameter is a subset of storable things, and have it figure out the marshalling strategy based on which
11:30:31 <kosmikus> f-a: but certainly, anyone building binary distributions would have to take all licenses into account?
11:30:58 <wroathe> nshepperd2: i.e. if the haskell program is working with Int32, having it marshall an Int32 when it makes the call
11:31:00 <kosmikus> f-a: I must be able to say that while I depend on a library A, my code isn't the reason it becomes more restrictive, but it's all A's fault
11:31:04 <wroathe> nshepperd2: Or a Ptr a
11:31:33 <wroathe> nshepperd2: There's seemingly no "nice" way to represent an untagged union with Haskell's FFI
11:31:44 <f-a> kosmikus: when we have "this library is GPL, better not include it in GHC" we don't want to have a "this library is BSD, but really is GPL"
11:32:05 <kosmikus> f-a: but it's only the dependency that is GPL :)
11:32:05 <f-a> if you use gpl code, you work is gpl'd, any other statement is madness
11:32:20 <kosmikus> well, the GPL is madness
11:32:43 <f-a> I will pass on the flame
11:33:02 <kosmikus> sorry that you see it that way
11:33:13 <f-a> if you (impersonal you) use gpl libraries, please don't pull pettifogger stunts
11:33:21 <unfixpoint> I'm sorry for having started this discussion ^^
11:33:32 <kosmikus> if I'm writing source code, I'm not using anything
11:33:39 <tdammers> f-a: that is blatantly untrue. you can use GPL code in all sorts of ways that doesn't make it viral
11:33:48 <kosmikus> and certainly shoudln't be told what license to use
11:34:04 <kosmikus> for my own code, that is
11:34:13 <nshepperd2> Iirc, FFI only supports "primitives" like Int, Word, Ptr
11:34:16 <f-a> tdammers: if you are *distributing code*, it's madness to say "not compiled - not my job"
11:34:37 <f-a> hackage `licence` would mean f*&ck all then 
11:34:50 <f-a> in any case, back to unfixpoint problem
11:34:54 <nshepperd2> If you want to pass Storable things you need to put it on the heap
11:35:30 <f-a> unfixpoint: https://sourceforge.net/p/haskelldb/bugs/ the library seems abandoned
11:36:18 <nshepperd2> f-a: if you're building a binary distribution of GHC, it's your responsibility to check that your transitive dependencies' licenses are usable. Since you're the one distributing a binary of them
11:36:33 <wroathe> nshepperd2: If that's true, then I'm back to my earlier question, which is how to say that this is just a Ptr a and then convert between Int32 and Ptr a?
11:37:20 <f-a> nshepperd2: I am specifically pointing at a baseline common courtesy among open-source software users
11:37:23 <wroathe> The C signature for htInsert is struct hash_table *htinsert(char const *key, union entry const val, struct hash_table *table);
11:37:43 <f-a> willfully breaching it (and not by mistake) is monumental 
11:38:07 <f-a> unfixpoint: good news for you
11:39:27 <nshepperd2> Requiring people to relicense their work for the sake of "courtesy" doesn't seem very reasonable
11:40:29 <f-a> if they use gpl code in their codebase and they do not change their licence because ponies, rest assured I'd instaping hackage maintainers 
11:40:41 <f-a> let's see if "woopsie it wasn't me" is fine with them
11:40:57 <f-a> unfixpoint: haskelldb-hdbc-mysql is unbuildable on my machine
11:41:05 <nshepperd2> Particularly when this "courtesy" could be accomplished with a function in the cabal library
11:41:06 <f-a> even with --allow-newer
11:41:07 <unfixpoint> Huh, how is that good news?
11:41:47 <unfixpoint> f-a: I'm not using that library, I just saw it while trying to figure out if I can still use BSD-3
11:41:49 <nshepperd2> How hard is it to compute the most restrictive licence of a set of transitive dependencies?
11:41:58 <f-a> unfixpoint: well, if you manage to fork it and get it to shape, you can then comply with whatever the lgpl says. I see you plan to use it as SaaS, so you should be in the clear
11:42:32 <f-a> nshepperd2: in the lgpl case, especially in some languages, very 
11:42:42 <unfixpoint> Oh, now I see what you mean
11:42:54 <nshepperd2> What?
11:44:08 <unfixpoint> That the point about that library is moot as it doesn't even build
11:45:22 <wroathe> unsafeCoerce all the things and hope for the best 
11:51:55 <essentiality[m]> haskell? more like has-cool 8)
11:52:14 <essentiality[m]> this language is fresh, fam!
11:53:25 <f-a> \o/
11:54:00 <zincy_> What do people recommend for ensuring a process on a server is auto restarted when crashes
11:54:12 <zincy_> I am running a haskell executable on an ec2 server
11:54:41 <f-a> unfixpoint: just to wrap this up, let me know if I got this straight: you will end up using HDBC-mysql (lgpl v2.1) in your project, and that project is a SaaS, right?
11:55:46 <alter2000_> zincy_: for extra logging and other goodies, systemd service; for simple stuff (web scraper) just a `while :; do ./exec; done`
11:56:08 <sm[m]> zincy_: I use systemd or supervisord
11:56:14 <zincy_> thanks
11:57:19 <zincy_> Ill try systemd
12:05:12 * hackage ghc-syntax-highlighter 0.0.5.0 - Syntax highlighter for Haskell using lexer of GHC itself  https://hackage.haskell.org/package/ghc-syntax-highlighter-0.0.5.0 (mrkkrp)
12:06:34 <dsal> systemd makes me sad, but it's better than most of the really dumb things people did before systemd.
12:07:34 <dsal> zincy_: Also, write better code.  My haskell code doesn't crash itself, but it crashes the whole system and then it reboots. 
12:10:15 <koz_> Is there some 'standard' way of referring to a natural transformation argument? Kinda how 'f, g' are used for a function argument, or 'x, y' for a non-functon value.
12:15:29 <dmwit> koz_: η ;-)
12:15:38 <koz_> dmwit: Is that eta? Or nu?
12:15:43 <dmwit> eta
12:15:50 <koz_> OK, thanks - I get those two mixed up all the time.
12:15:56 <dmwit> It was a joke.
12:16:06 <dmwit> I don't think very many people use non-ASCII stuff in their Haskell source.
12:19:28 <TheCommieDuck> I know "don't prematurely optimise", /but/: is it a bad idea to use simple ADTs in place of booleans for clarity? e.g. rather than "isOutside :: Bool", have Outsideness = Inside | Outside.
12:19:47 <phadej> it's a good idea to use them
12:19:51 <phadej> Bool has nothing special in it
12:20:03 <phadej> use them [ = simple ADTs]
12:20:08 <phadej> data types are cheap
12:20:15 <TheCommieDuck> ...I just realised this was a silly question because bool is data Bool = True | False.
12:20:22 <TheCommieDuck> ahem. thanks. :p
12:20:28 <lavalike> @src Bool
12:20:28 <lambdabot> data Bool = False | True deriving (Eq, Ord)
12:28:23 <EvanR> TheCommieDuck: probably better is to bake some intended functionality into that inside/outside type. Let make it have any arbitrary different between Inside and Output so they don't get mixed up
12:28:37 <EvanR> a natural place to get that difference is from intended ussage
12:29:19 <EvanR> if it's going in a database though, probably unavoidable to make it an enum-like type
12:31:19 <sclv> skillsmatter is gone, no more haskellxchange :-/ https://twitter.com/wendydevolder/status/1191371952742633472
12:32:04 <merijn> sclv: Which sucks, because no Apfelmus' lazy eval tutorial is gone :\
12:32:23 <merijn> s/no/now
12:33:03 <sclv> i don't think the videos are going
12:33:10 <sclv> they're going to try to preserve that stuff
12:33:48 <EvanR> failed to parse "gone in administration"
12:34:57 <merijn> Oh, wait, I'm confusing skillsmatter and another platform
12:35:40 <merijn> EvanR: I'm assuming that means "a curator has been appointment for bankruptcy procedures"
12:36:07 <merijn> EvanR: Whoo! Guessed right: https://www.realbusinessrescue.co.uk/company-administration/going-into-administration
12:36:35 <merijn> Not even sure if curator is the right word in English, that's just a blind guess translation of the Dutch word :p
12:36:53 <EvanR> TIL
12:41:07 <jgt> merijn: a "curator" is someone who gathers things together, like for example pieces to be shown at a museum, or artworks at a gallery/exhibition
12:41:31 <merijn> jgt: I know, that's *also* what it means in Dutch
12:41:54 <jgt> I'm guessing it's from Latin or something
12:42:12 <merijn> jgt: A curator is just "someone who curates", usually art, but in case of bankruptcy finances
12:42:50 <merijn> "to curate" -> "select, organize, and present (online content, merchandise, information, etc.), typically using professional or expert knowledge."
12:43:03 <merijn> Makes perfect sense to me
12:43:13 <merijn> Don't even need latin roots or something
12:43:21 <jgt> I've never heard it used in that context, but I won't challenge!
12:43:40 <jgt> (the insolvency context)
12:43:56 <dmj`> Is Taylor Fausk in this channel ?
12:44:10 <dmj`> Or any moderators on reddit ?
12:44:24 <merijn> jgt: It's probably not used like that in English, because English never does the sensible consistent thing :p
12:44:46 <dmj`> edwardk: ping
12:44:53 <EvanR> is it possible to have a deterministic RNG with multiple clients in a way that the order the clients take from, split from, the RNG doesn't matter
12:45:08 <merijn> EvanR: Define "matter"
12:45:14 <EvanR> affect the result
12:45:23 <merijn> EvanR: Also, "haha, no" ;)
12:45:31 <EvanR> result is function of the original seed only
12:45:33 <merijn> EvanR: Is the number of clients static?
12:45:34 <EvanR> not ordering
12:45:42 <nshepperd2> does (const 4) count as a deterministic RNG
12:45:50 <EvanR> say the number of clients are static and they always "take once per day"
12:46:06 <EvanR> nshepperd2 good call
12:46:11 <merijn> EvanR: Trivial solution: Seed each client in deterministic order with seeds from a deterministic RNG
12:46:22 <EvanR> merijn: in some order? heh
12:46:41 <merijn> EvanR: As long as clients stay consistent everything is ok
12:46:51 <merijn> (consistent in order internally, that is)
12:47:03 <EvanR> i might as well just, do things in some order heh
12:47:14 <[itchyjunk]> hi
12:47:14 <merijn> EvanR: But I suspect the real answer is ENOTENOUGHINFO
12:47:25 <EvanR> imagine
12:47:30 <EvanR> i have a set of N clients
12:47:32 <EvanR> not a list
12:47:33 <EvanR> see
12:47:33 <merijn> Like, what are they doing? Why do you need determinism? etc.
12:47:40 <EvanR> i just do
12:48:03 <merijn> EvanR: Clients internally always use the same order of operations?
12:48:47 <nshepperd2> EvanR have each client deterministically assign itself a uuid, and seed its individual rng from md5(uuid || common starting seed)
12:49:04 <merijn> nshepperd2: ooh, nice!
12:49:28 <merijn> nshepperd2: But then the deterministic uuid is basically what I suggested via "seed every client deterministically from a global RNG"
12:49:41 <EvanR> i like that idea
13:25:42 * hackage backstop 1.3.0.354 - Backstop a target directory by source directories  https://hackage.haskell.org/package/backstop-1.3.0.354 (mdgabriel)
13:35:48 <Noobster> Gotta logoff, this nick was taken. Sorry..
13:38:04 <gnkka> Will get some scrub...
14:04:54 <jollygood2> is there a name for this function?
14:05:02 <jollygood2> > foldr1 (<|>) [Nothing, Just 10]
14:05:04 <lambdabot>  Just 10
14:05:13 <lyxia> asum?
14:05:22 <jollygood2> > asum [Nothing, Just 10]
14:05:25 <lambdabot>  Just 10
14:05:26 <jollygood2> @src asum
14:05:26 <lambdabot> Source not found. I feel much better now.
14:05:38 <jollygood2> thanks
14:05:44 <jle`> asum is different
14:05:54 <jle`> it won't blow up if you give it an empty list
14:05:55 <jollygood2> can you give an example?
14:05:59 <jle`> > foldr1 (<|>) []
14:06:01 <lambdabot>  error:
14:06:01 <lambdabot>      • Ambiguous type variables ‘f0’,
14:06:01 <lambdabot>                                 ‘a0’ arising from a use of ‘show_M63968944570...
14:06:03 <jollygood2> ah
14:06:05 <jle`> > foldr1 (<|>) [] :: Maybe Int
14:06:11 <lambdabot>  *Exception: Prelude.foldr1: empty list
14:06:18 <jle`> > asum (<|>) [] :: Maybe Int
14:06:20 <lambdabot>  error:
14:06:20 <lambdabot>      • Couldn't match type ‘Maybe Int’ with ‘[a0]’
14:06:20 <lambdabot>        Expected type: [a0] -> Maybe Int
14:06:29 <jle`> > asum [] :: Maybe Int
14:06:30 <lambdabot>  Nothing
14:06:40 <jle`> asum = foldr (<|>) empty
14:06:46 <lavalike> :t foldr (<|>) mempty
14:06:47 <lambdabot> (Foldable t, Alternative f, Monoid (f a)) => t (f a) -> f a
14:06:51 <jollygood2> ok, that's an improvement over my code
14:06:57 <jle`> so it will behave properly for empty lists
14:08:01 <jollygood2> :t foldr1 (<|>)
14:08:03 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
14:08:12 <nshepperd2> sclv: oh no :(
14:08:14 <jle`> :t foldr (<|>) empty
14:08:15 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
14:08:18 <lavalike> :t empty
14:08:19 <lambdabot> Alternative f => f a
14:08:22 <jollygood2> :t foldr (<|>) Nothing
14:08:23 <lavalike> oh!
14:08:24 <lambdabot> Foldable t => t (Maybe a) -> Maybe a
14:09:06 <jollygood2> > foldr (<|>) Nothing [Nothing, Just 10]
14:09:09 <lambdabot>  Just 10
14:09:18 <jollygood2> why is asum using empty over Nothing?
14:09:39 <jollygood2> > foldr (<|>) empty [Nothing, Just 10]
14:09:41 <merijn> jollygood2: empty *is* Nothing for Maybe
14:09:42 <lambdabot>  Just 10
14:09:44 <lavalike> so that it matches the input foldable
14:09:46 <jollygood2> oh :P
14:09:55 <merijn> > empty :: Maybe Int
14:09:57 <lambdabot>  Nothing
14:10:04 <merijn> :t empty
14:10:05 <lambdabot> Alternative f => f a
14:10:08 <jollygood2> :t asum
14:10:10 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
14:11:38 <jollygood2> > asum [[], [1,2]]
14:11:41 <lambdabot>  [1,2]
14:12:36 <jollygood2> > asum [Left "err", Right 20]
14:12:38 <lambdabot>  Right 20
14:12:43 <jollygood2> cool
14:15:02 <jle`> note the Alternative instance for Either isn't exactly ... stable
14:15:20 <merijn> jle`: How so?
14:15:22 <jle`> it's an orphan instance
14:15:35 <merijn> It is? :o
14:15:37 <jle`> from a non-base package
14:15:48 <jle`> so i try to avoid it when possible
14:16:30 <jle`> it's just working right now because lambdabot imported a module that imports a module that imports a module that imports a module that defines the orphan instance
14:17:30 <jle`> but if you just whip out Prelude and Data.Either and Control.Applicative or any other module in base, you won't get that instance
14:18:27 <jle`> in an ideal world we would move the instance to base ... into either Control.Applicative or Data.Either (whichever one depends on the other). but right now we have a bit of a mess
14:19:04 <gnkka> I'm a total noob who has tried to study Haskell. it would help me a lot, if I could describe in some forum a a short string- and character handling "problem", and get someone to suggest how to code it. i feel it'd be easier for me to have some code to tinker with and learn. Could you suggest a forum where to post this kind of request?  -Ta!
14:19:15 <essentiality[m]> http://www.pythonchallenge.com
14:19:15 <essentiality[m]> remember this
14:20:21 <merijn> gnkka: /r/haskellquestions and here are pretty good for getting help on how to implement things
14:20:54 <gnkka> thanks, merijn!
14:21:39 <jollygood2> gnkka you can also ask in here
14:21:57 <dibblego> what empty for Either?
14:22:41 <jle`> in the somewhat de-facto orphan instance, we have empty = Left mempty
14:22:50 <dibblego> hmmm
14:23:38 <dibblego> @type (Data.Functor.Alt.<!>)
14:23:39 <lambdabot> Data.Functor.Alt.Alt f => f a -> f a -> f a
14:24:34 <jle`> actually the de-facto orphan instance is literally wrong
14:24:47 <jle`> > Left "hi" <|> empty
14:24:49 <lambdabot>  Left ""
14:24:59 <MarcelineVQ> le gaspe
14:25:01 <gnkka> jollygood2, somehow i feel it would be too long a "question" in irc, explaining my sample case is not done in a couple of words. And answering would kinda need to be a shred of code that is more than a command or two, it'd need to be a short, working program rather than a smorgasboard of text-related commands...
14:25:01 <jle`> >:(
14:25:17 <jle`> i say we kill the beast
14:25:26 <merijn> jle`: Why is that wrong?
14:25:26 <dibblego> orphan instances are dead to me anyway
14:25:44 <jle`> merijn: <|>/empty is supposed to be monoidal
14:25:49 <jle`> that's the "only" law of Alternative
14:25:59 <merijn> ah
14:26:10 <jle`> well, there are a few proposed 'maybe iffy' laws, but the one unanimously agreed-upon one is that <|>/empty forms a monoid
14:27:01 <jle`> the sad thing is that it doesn't even have to be that way
14:27:15 <jle`> there's already a Monoid constraint, so <|> could have mappended the Left's if there are two lefts
14:27:27 <jle`> and it would have been a perfectly fine lawful Alternative instance
14:33:54 <koala_man> :5b
14:34:03 <koala_man> wait this isn't vim
14:36:08 <jle`> yeah emacs is the one with the built-in irc client
14:37:52 <lukelau> What’s the closest way to get dependent Pi types in GHC? Something like this https://gist.github.com/08e107aae150db295981c158939e9531
14:39:48 <merijn> ...
14:39:59 <merijn> I need some new profanity
14:40:03 <merijn> Like...
14:40:07 <merijn> A lot of it
14:40:33 <merijn> Pro-tip: Just, like, never use persistent and never read the source
14:41:03 <alter2000_> can we get a link so that we can avoid it next time we see it?
14:42:00 <merijn> "huh, I wonder why running this query multi-threaded somehow breaks things"
14:42:58 <merijn> "oh, yeah, creating a query looks things up in a map of existing queries (what?) using the query text as key (what?) and we do this in a racy way, so two threads running the same query will just, like, arbitrarily corrupt each other
14:43:45 <jle`> lukelau: that should already compile i believe
14:43:53 <jle`> well, you might get a Char cannot be promoted error
14:44:01 <jle`> but Foo (x :: Symbol) a should compile, at least
14:44:13 <jle`> oh, i didn't notice the second part, taking x as an argument
14:44:40 <jle`> in that case you could just have x be a normal type variable, f :: Foo x (), since x is already a type variable
14:44:49 <jle`> implicitly it's f :: forall x. Foo x ()
14:53:48 <lukelau> jle`: i see. then is there a way to move that type down to the term level?
14:55:09 <jle`> that's 'reflection' -- there are a few tools for doing so, but the main important thing is to overcome type erasure
14:55:13 <lukelau> Or is there a way I can call it like `f “foo”`, and then access the string inside the definition inside?
14:55:24 <jle`> but the main mechanisms for overcoming type erasure are typeclasses and GADTs
14:55:27 <lukelau> (Presumably via type application?)
14:55:47 <lukelau> ok, I’ll take a look at those. thanks
14:55:52 <jle`> for an example of the typeclass based mechanism, see GHC.TypeLits
14:56:06 <jle`> it offers a typeclass KnownSymbol, where you have symbolVal :: KnownSymbol s => p s -> String
14:56:32 <jle`> so if you have KnownSymbol x => Foo x (), you can reflect using symbolVal (Proxy :: Proxy x)
14:56:46 <lukelau> Ah
15:01:04 <lukelau> jle`: https://gist.github.com/ee8e877be128b350571732d14c34ca68
15:01:20 <lukelau> I’m getting some interesting type errors
15:01:39 <jle`> try turning on POlyKinds
15:01:45 <lukelau> In that the Proxy constructor takes in a type, not a symbol apparently
15:01:46 <jle`> or TypeInType, which implies both PolyKinds and DataKinds
15:01:56 <jle`> ah, one issue here is 'x' is not scoped
15:02:12 <jle`> you'd need f :: forall x. KnownSymbol x => Foo x String
15:02:28 <jle`> right now your line22 is interpreted as let p = Proxy :: forall q. Proxy q
15:03:04 <lukelau> Ah that fixes it, I had turned on scopedtypevariables but not added the explicit forall x.
15:03:27 <lukelau> Thanks!
15:04:14 <lukelau> One thing, is it possible to move the `forall x. KnownSymbol x` constraint up into the data type Foo?
15:19:12 * hackage Map 0.1.3.0 - Class of key-value maps  https://hackage.haskell.org/package/Map-0.1.3.0 (MatthewFarkasDyck)
15:35:06 <Axman6> merijn: yeah I used persistent in a project, I definitely regretted it
15:35:28 <merijn> Axman6: I've been regretting it for awhile :p
15:35:49 <merijn> I've patched most of the major issues I had upstream, because that was less work then migrating, but...yeah
15:36:02 <merijn> So super questionable decision making for parts
15:36:08 <merijn> s/So/Some
15:37:05 <jackdk> I personally have been happiest with the opaleye, hasql and the *-simples if I'm not on postgres. Next time I do something targeting sqlite I may look at groundhog again. Didn't seem too bad when I last tried (years ago)
15:37:37 <merijn> Well...that's worrying
15:37:53 <jackdk> ?
15:37:57 <merijn> I wrote a "quick fix" to work around this and now the code segfaults
15:38:04 <Axman6> I enjoyed hasql
15:38:09 <merijn> Despite no pointers/etc.
15:38:13 <Axman6> nice
15:38:16 <dibblego> merijn ♥ persistent
15:38:23 <merijn> jackdk: opaleye is postgres only, though
15:38:35 <merijn> Selda looks somehwat promising and opaleye inspired
15:38:40 <Axman6> as much as dibblego   scala
15:38:45 <Axman6> hmm, that didn't work...
15:38:52 <dibblego> <censored>
15:38:54 <jackdk> merijn: (opaleye, hasql) and (the *-simples if I'm not on postgres)
15:39:03 <merijn> Oh, goodie
15:39:06 <Axman6> yeah that's probably more appropriate
15:39:13 <merijn> Irreproducible segfault, of course
15:39:19 <jackdk> haven't looked closely at selda nor heard much from it recently
15:40:06 <sm> merijn: interesting.. subscribed to your https://github.com/yesodweb/persistent/issues/981
15:41:05 <merijn> Well, this fix has just broken every damn thing >.>
15:41:30 <TheCommieDuck> should I assume that the haskell compiler will make sane choices about memory behind the scenes? I get pass by value/reference is moot in an immutable world, but e.g. should I avoid doing something like [reallyBigX | x <- 1..10000] if I can do [idlookupsToReallyBigX | x <- 1..10000] and just store it once?
15:42:17 <merijn> TheCommieDuck: You should do "let foo = reallyBigX in [foo | x <- 1..10000]"
15:42:47 <merijn> TheCommieDuck: In GHC that basically guarantees you will have 10k reference to a single "reallBigX"
15:43:11 <merijn> TheCommieDuck: If you care about sharing you almost always want to explicitly name the shared thing
15:43:28 <TheCommieDuck> okay, but in a more worked example where reallyBigX is part of a product type in a bunch of different places...?
15:44:21 <TheCommieDuck> (I probably butchered the syntax for the list example, so thanks for that)
15:47:47 <Axman6> did you mean for x to be an argument to reallyBigX?
15:49:48 <Guest_96> Trying to install Haskell on Mac OS X Catalina and I keep getting this error:  Failed to install, consider updating this script via: ghcup upgrade"ghcup --cache install" failed!
15:57:06 <Guest_38> It would be great if someone could help me with an issue I've got: I installed ghc via ghcup. but I can't run ghci as command in the terminal...
16:01:15 <merijn> Axman6: Ugh, this means rearchitecting a bunch of stuff for no real gain aside from working around brokenness :\
16:07:44 <Axman6> :'(
16:13:09 <merijn> oh well, guess I won't finish this today
16:15:46 <dmwit> TheCommieDuck: I'm gonna be honest: I have no idea what you're asking.
16:16:19 <dmwit> What does it mean for reallyBigX to be "part of a product type in a bunch of different places"?
16:16:39 <dibblego> maybe show the real code
16:45:00 <jollygood2> is there a function that does this?
16:45:05 <jollygood2> :t [minBound ..]
16:45:06 <lambdabot> (Bounded a, Enum a) => [a]
16:45:33 <Axman6> yes, enumFrom minBound =)
16:45:38 <jollygood2> :P
16:45:56 <Axman6> @hoogle universe
16:45:57 <lambdabot> Control.Lens.Combinators universe :: Plated a => a -> [a]
16:45:57 <lambdabot> Control.Lens.Plated universe :: Plated a => a -> [a]
16:45:57 <lambdabot> Data.Generics.Uniplate universe :: Uniplate on => on -> [on]
16:46:01 <Axman6> hmm
16:48:06 <evocatus> @pl \x -> x
16:48:07 <lambdabot> id
16:49:07 <evocatus> @pl \f g h x -> h (f x) (g x)
16:49:08 <lambdabot> flip . (ap .) . flip (.)
16:51:07 <jollygood2> will this shortcircuit?
16:51:47 <jollygood2> asum $ map expensiveCalculation (enumFrom minBound)
16:51:47 <Axman6> evocatus: a.k.a h <$> f <*> g or liftA2 h f g
16:52:03 <Axman6> yes
16:52:04 <jollygood2> expensiveCalculation  returns Maybe Data
16:52:11 <jollygood2> Axman that was for me?
16:52:15 <evocatus> Axman6: ah yes, liftA2.. I thought I had seen something like this before
16:52:18 <evocatus> thanks muchly
16:52:38 <Axman6> jollygood2: yes
16:52:52 <olligobber> I left my program running for like 7 hours and it didn't finish :(
16:53:09 <Axman6> you should write better programs :P
16:53:26 <olligobber> it was brute forcing a very large search space
16:53:27 <dibblego> maybe it was factoring primes
16:54:01 <olligobber> I should make it report progress in future though
16:54:05 <Axman6> How hard could that be? Primes have no factors!
16:54:15 <olligobber> Axman6, lol
16:54:23 <Axman6> (well, no non-trivial factors)
16:54:45 <dibblego> and there is a bug
17:00:26 <koz_> jollygood2: You may also want to check out finitary. </shameless_plug>
17:02:13 <jollygood2> koz_ ok, I'll take a look!
17:03:42 <dmwit> jollygood2: You might like
17:03:44 <dmwit> ?hackage universe
17:03:45 <lambdabot> http://hackage.haskell.org/package/universe
17:08:08 <dmwit> Compared to finitary, I guess the main difference is that universe has a class for enumerable infinite types.
17:08:36 <Axman6> is there an instance for Rational?
17:08:46 <dmwit> But less fanciness for defining instances with Generics magic.
17:08:50 <dmwit> Axman6: There is, yes.
17:16:47 <koz_> dmwit: Yeah, I think it uses the trick from 'Seemingly impossible functional programs' somewhere in there.
17:17:07 <koz_> http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/ <-- this one
17:23:56 <dmwit> ...for what?
17:24:25 <koz_> Or am I thinking of a different library?
17:25:12 <koz_> Yep, I was, lol.
17:25:21 <koz_> I know there is a library _somewhere_ for that trick.
17:34:20 <dmwit> When everything is finite, nothing seems impossible.
17:35:26 <dolio> You just need a stronger idea of what's impossible.
17:40:21 <gobby> Is there a way to convert the schema I defined in `beam` to executable SQL? 
17:40:45 <quiet_laika[m]> is it possible to parse source text into a tagless final encoding? im confused how one would parse an encoding like https://serokell.io/blog/tagless-final#final-encoding
17:41:25 <quiet_laika[m]> i tried writing a `LambdaSYM repr => Parser (repr a)`, but because a is existential i can't use any of my concrete parsers
17:42:01 <quiet_laika[m]> i suppose im mostly confused at how to write a "top level" parser
17:42:03 <quiet_laika[m]> or an entry point
17:45:53 <quiet_laika[m]> (using any given parser combinator library)
17:55:24 <lyxia> if you don't know what `a` is upfront you would probably start with an untyped AST
17:56:35 <lyxia> you can try to do typechecking and parsing at the same time, but it just makes things complicated
18:04:10 <quiet_laika[m]> not really trying to do any typechecking yet, just parsing. i dont have a concrete type for AST to parse to because im trying to use the "tagless" approach with syntax typeclasses and interpreters as datatypes. is it possible to deserialize syntax from text without an actual syntax tree type, or am i getting things confused?
18:05:09 <quiet_laika[m]> my understanding was that tagless final is supposed to allow you to avoid defining that top level AST in the first place, so i thought that going that route for parsing would defeat the purpose
18:12:19 <lyxia> I mean to parse an `repr a` when you don't know what `a` is, you have to do typechecking.
18:13:15 <lyxia> but otherwise `LambdaSYM repr => Parser (repr a)` would actually be a good start.
18:16:07 <dmwit> Perhaps you could `LambdaSYM repr => Parser (Some repr)`, using this Some:
18:16:14 <dmwit> http://hackage.haskell.org/package/parameterized-utils-2.0/docs/Data-Parameterized-Some.html
18:17:24 <dmwit> (Presumably then the `LambdaSYM` class ought to expose enough machinery that you can recover the `a` from there with suitable pattern matching or the like.)
18:18:30 <lyxia> or put `a` in a singleton
18:21:44 <quiet_laika[m]> oo, ill look into thsoe
18:21:47 <quiet_laika[m]> *those
18:22:21 <jollygood2> how can I show date using currently set OS locale?
18:29:48 <dsal> % getCurrentTimeZone >>= \tz -> utcToLocalTime tz <$> getCurrentTime
18:29:48 <yahb> dsal: 2019-11-05 02:29:25.204012741
18:36:17 <dmwit> Is "time zone" what you meant by "locale"?
18:37:28 <dmwit> (The time package also has a concept of a formatting locale. I don't know a way to retrieve a suitable such locale from the system.)
18:43:11 <dsal> Oh, yeah.  That's a different thing... I normally assume local time first, then locale
18:45:17 <jollygood2> I'm talking about localized formating. day/month order, etc
18:46:24 <dmwit> I don't know how to retrieve that information from the OS.
18:46:38 <dmwit> (Do you know how it would be done in another language?)
18:46:48 <siraben> Hi all, what am I missing in line 109 to be able to lift a Freer Teletype computation into IO? https://paste.debian.net/1113845/
18:46:51 <siraben> I was able to write "runTeletypeInIO :: Free Teletype a -> IO a", but writing "runTeletypeInIO' :: Member Teletype r => Union r a -> IO a" is tricky.
18:47:40 <jollygood2> dmwit, I think you can do it in C with POSIX functions, and have it work in windows and *nix? it has been a long time since I've done that, and I was hoping for a nice haskell localizedTimestamp :: Day -> String function
18:47:50 <jollygood2> I guess it doesn't exist
18:49:17 <dmwit> What functions?
18:51:18 <jollygood2> looking into it now.. strftime with %c flag may do it. I think haskell has that function? http://man7.org/linux/man-pages/man3/strftime.3.html
18:51:49 <jollygood2> with a different name, probably
18:54:02 <dmwit> I believe there is no corresponding thing in the time package.
18:54:48 <dmwit> The time package's formatTime does support %c, but I'd wager it uses the TimeLocale you pass to decide what %c means, and I know of no way to fill out a TimeLocale just by looking at environment variables (as strftime appears to do).
18:55:20 <jusss`> dmwit: did time pacakge came with ghc?
18:55:31 <dmwit> I don't know. Why does it matter?
18:56:15 <jollygood2> hmm, looking at environment variables doesn't sound too portable either
18:56:21 <jusss`> https://hackage.haskell.org/package/old-time-1.1.0.3/docs/System-Time.html
18:57:05 <jusss`> what's the proper module if I want to do something with time?
18:57:16 <dmwit> I strongly recommend the time package for dealing with time.
18:57:58 <jusss`> ok
19:00:28 <olligobber> I changed how my program works slightly and suddenly it's using way more ram :(
19:00:55 <dmwit> jollygood2: You might consider filing a feature request on the time package's bug tracker (or looking if one already exists and voting for it). =P
19:01:18 <jollygood2> dmwit, yes
19:17:27 <Guest_61> hi good evening
19:17:35 <Guest_61> im Luis from Mexico 
19:18:10 <jgt1> Hello Luis from Mexico
19:18:15 * dmwit waves
19:18:26 <Guest_61> and I'd like to know if someone can help me 
19:18:34 <Axman6> ¡Hola!
19:18:39 <evocatus> Guest_61: what do you need?
19:19:34 <Guest_61> thank you, I have a mac and i don't have idea how to set haskell in the right way
19:19:39 <Guest_61> In order to run ghc and cabal, you need to adjust your PATH variable.
19:19:45 <Guest_61> I have that error
19:20:13 <dmwit> What does `echo $SHELL` (without the backticks) say?
19:21:23 <Guest_61>  In order to run ghc and cabal, you need to adjust your PATH variable.> >         You may want to source '/Users/h/.ghcup/env' in your shell> >         configuration to do so (e.g. ~/.bashrc).
19:21:49 <Guest_61> this is what it said but i closed the terminal and open again but i don't have idea 
19:21:51 <monochrom> So just do that?
19:22:04 <evocatus> Guest_61: how did you install ghc and cabal?
19:22:05 <maerwald> Guest_61: you can just rerun the curl | sh thing at any time
19:22:07 <Guest_61> yeah just that after de installation 
19:22:23 <Guest_61> the *
19:22:27 <dmwit> Guest_61: I'd like to help you. But to do a good job, I need to know what shell you are using. You can learn that by running the command I suggested above and telling us what it says.
19:22:59 <Guest_61> I'am using Terminal on MACOSX mojave
19:23:04 <Axman6> try running this and then opening a new terminal: echo '\nsource ~/.ghcup/env' >> ~/.bashrc
19:23:10 <maerwald> if he doesn't have .bashrc or .bash_profile the bootstrap script won't do anything
19:23:16 <maerwald> otherwise it will suggest to add it automatically
19:23:26 <maerwald> which requires an explicit YES and enter :P
19:23:39 <maerwald> if you close the terminal it won't do anything
19:24:09 <f-a> I feel this question has been asked multiple times, wonder of ghcup devs know of this
19:24:16 <maerwald> f-a: yes
19:24:25 <f-a> very good
19:24:38 <maerwald> that is why it asks in funny color whether you want it to add that line...
19:25:04 <monochrom> I'm cynical, I say that if the user turns a blind eye on "text walls", nothing can fixed.
19:25:36 <Guest_61> really I didn't know but how can I make that appear again
19:25:37 <Guest_61> ?
19:25:46 <Guest_61> I have to install it again ?
19:25:48 <maerwald> monochrom: previously the script would consider the user pressing enter without typing YES a no... but that confused users, so now you have to type YES or NO
19:25:56 <maerwald> Guest_61: just run the curl | sh thing again, it's safe
19:26:38 <f-a> Guest_61: may I ask you where you were suggested to use this install method? haskell.org?
19:26:50 <maerwald> probably using tidal
19:27:07 <Guest_61> https://www.haskell.org/platform/
19:27:11 <Guest_61> from there 
19:27:19 <f-a> thanks Guest_61 
19:28:14 <maerwald> monochrom: I'm thinking about face recognition, so the script would figure out the answer from your facial expression
19:28:29 <Guest_61> jajajajaja
19:28:50 <monochrom> I'm drunk so I'm going to satire about "maybe you need to turn ghcup into a smartphone app..."
19:29:11 <maerwald> it's tuesday morning... wth
19:29:37 <Guest_61> I already run the command but It seems that anything happen
19:29:43 <Guest_61> this command curl -sSL https://get.haskellstack.org/ | sh
19:29:49 <olligobber> ok, the problem is I'm dumb
19:30:03 <olligobber> I had <= instead of >=
19:30:06 <Axman6> hmm, that's not ghcup
19:30:07 <maerwald> Guest_61: ok that means you don't have a .bashrc and not a .bash_profile
19:30:08 <Axman6> is it?
19:30:15 <maerwald> it is
19:30:25 <Guest_61> yeah i don't hace it
19:30:27 <maerwald> Guest_61: what shell environment are you using and how do you configure your shell?
19:30:27 <Guest_61> have 
19:30:34 <Axman6> the world is a strange and scary place
19:30:43 <maerwald> oh wait
19:30:50 <maerwald> it isn't =)
19:30:57 <maerwald> ask a stack user for help haha
19:31:03 <monochrom> \∩/
19:31:12 <maerwald> guess we are all drunk
19:31:19 <Guest_61> now im gonna show you this thing
19:31:20 <Guest_61> Stack has been installed to: /usr/local/bin/stackNOTE: You may need to run 'xcode-select --install' and/or      'open /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg'      to set up the Xcode command-line tools, which Stack uses.WARNING: '/var/root/.local/bin' is not on your PATH.    For best results, please add
19:31:21 <Guest_61> it to the beginning of PATH in your profile.
19:31:24 <f-a> Guest_61: you could join #haskell-stack ( with /join #haskell-stack )
19:31:25 <Axman6> Guest_61: are you sure that's what you ran before? that isn't ghcup, that's stack
19:31:33 <maerwald> In order to run ghc and cabal, you need to adjust your PATH variable.> >         You may want to source '/Users/h/.ghcup/env' in your shell> >         configuration to do so (e.g. ~/.bashrc).
19:31:40 <maerwald> so you tried to install ghc via ghcup first
19:31:44 <maerwald> then you switched to the stack installer
19:31:46 <maerwald> ....
19:31:47 <maerwald> what
19:31:54 <Axman6> did you run that as root??? D:
19:32:01 <Guest_61> exactly as you said
19:32:15 <maerwald> wait, why are you using stack installer now?
19:32:19 <maerwald> you just switched the installation method
19:32:29 <maerwald> O.o
19:32:35 <Guest_61> yeah i did it
19:32:41 <maerwald> ok
19:32:42 <Guest_61> that's so bad=
19:32:43 <Guest_61> ?
19:32:43 <monochrom> maerwald: It's what https://www.haskell.org/platform/#osx says for Mac. "using ghcup to install ghc and cabal-install, and following the instructions at haskellstack.org to install stack"
19:32:52 <Axman6> if you want to use ghcup, you want to run "curl https://get-ghcup.haskell.org -sSf | sh"
19:32:55 <maerwald> monochrom: yes, it's particularly confusing
19:33:15 <Axman6> but now you've run both the ghcup and stack installers, who knows how things will work D:
19:33:21 <monochrom> I think the reason is that Haskell Platfom includes the stack exe so they want to tell you how to include it yourself.
19:33:43 <maerwald> maybe ghcup should just install stack as well, wouldn't be hard :P
19:34:06 <Guest_61> Ok, but I so confused as my explanations 
19:34:12 * hackage hjugement-protocol 0.0.10.20191104 - A cryptographic protocol for the Majority Judgment.  https://hackage.haskell.org/package/hjugement-protocol-0.0.10.20191104 (julm)
19:34:14 <monochrom> I would hate that because it would mean stack would download GHC for a second time.
19:34:30 <maerwald> monochrom: yeah, but some projects really don't work well without stack
19:34:56 <monochrom> But if you use stack you may as well skip ghcup.
19:35:12 * hackage hjugement-cli 0.0.0.20191104 - Majority Judgment and Helios-C command line tool  https://hackage.haskell.org/package/hjugement-cli-0.0.0.20191104 (julm)
19:36:05 <Guest_61> So... am I did it right then?
19:36:17 <Guest_61> :S
19:36:27 <maerwald> Guest_61: create a ~/.bash_profile file
19:36:33 <Axman6> it looks like you've tried to install haskell twice, using two different methods
19:36:54 <maerwald> Guest_61: the file can be empty
19:37:06 <maerwald> then rerun "curl https://get-ghcup.haskell.org -sSf | sh" again
19:37:45 <jusss`> how I can turn UTCTime to other type time? like DiffTime or AbsoluteTime
19:37:58 <jusss`> I didn't find the transform function
19:38:05 <Axman6> you can use "touch ~/.bash_profile" to create it
19:38:06 <f-a> Data.Time.Clock utctDayTime :: UTCTime -> DiffTime
19:38:26 <f-a> from `time`, jusss` (and others)
19:38:30 <glguy> Just be sure you know what that function does
19:38:34 <Axman6> f-a: auh no, that will return the number of seconds into the day
19:38:41 <glguy> Just because it has the right type doesn't meant it's what you expected
19:38:51 <jusss`> f-a: what's the epoch time in time package? AbsoluteTime DiffTime UniversalTime UTCTime?
19:39:20 <Axman6> POSIXTime IIRC
19:39:21 <monochrom> I don't think time does epoch time...
19:39:25 <f-a> jusss`: hoogle will help you imm- yeah immensely, if you don't blindly follow it
19:39:56 <jusss`> it's different between haskell and the others about time?
19:40:00 <Axman6> https://hackage.haskell.org/package/time-1.9.3/docs/Data-Time-Clock-POSIX.html
19:40:03 <Guest_61> sh-3.2# curl -sSL https://get.haskellstack.org/ | shStack version 2.1.3 already appears to be installed at:  /usr/local/bin/stackUse 'stack upgrade' or your OS's package manager to upgrade,or pass '-f' to this script to over-write the existing binary, e.g.:  curl -sSL https://get.haskellstack.org/ | sh -s - -fTo install to a different location,
19:40:04 <Guest_61> pass '-d DESTDIR', e.g.:  curl -sSL https://get.haskellstack.org/ | sh -s - -d /opt/stack-2.1.3/binsh-3.2# 
19:40:14 <Guest_61> now it says this
19:40:18 <maerwald> Guest_61: you are not following our instructions
19:40:37 <Axman6> Guest_61: you're using the wrong url
19:40:39 <Guest_61> yeah i have tried to create bash profile 
19:40:48 <Guest_61> i just copied form the chat
19:40:52 <maerwald> no you didn't
19:40:55 <maerwald> read it again please
19:41:00 <monochrom> Yes Guest_61 please follow maerwald's instruction, he is an author of ghcup.
19:41:06 <Axman6> "if you want to use ghcup, you want to run "curl https://get-ghcup.haskell.org -sSf | sh""
19:41:34 <Axman6> "curl https://get-ghcup.haskell.org -sSf | sh" is not the same as " curl -sSL https://get.haskellstack.org/ | sh"
19:41:36 <Guest_61> OK sorry i just download the pdf
19:42:05 <maerwald> pdf?
19:42:13 <Guest_61> well the txt document
19:42:52 <jusss`> Axman6: what time type I should use in haskell?
19:43:05 <monochrom> UTCTime
19:43:06 <jusss`> is POSIXTime depreciate?
19:43:10 <Axman6> jusss`: that's not an easy question to answer, time is a very complex topic
19:43:30 <Axman6> generally UTCTime is the right choice, but not always
19:43:33 <jusss`> monochrom: about UTCTime, should I think about time zone?
19:44:03 <monochrom> Iff you have human users.
19:44:04 <glguy> jusss`: First say what kind time thing you're doing with "time" and then someone can help you figure out what that is in the time library
19:44:24 <glguy> There's no one type that you should use
19:44:38 <jusss`> glguy: I'd like to make countdown timer, and the time is GMT +8
19:45:28 <jusss`> > getCurrentTime
19:45:30 <lambdabot>  error: Variable not in scope: getCurrentTime
19:45:44 <Axman6> the time package has types for dealing with all the common representations of time: LocalTime for representing a date and time without a time zone, ZonedTime for representing the same but with a TimeZone, UTCTime which represents utc time, and POSIXTime for dealing with time in seconds from the unix epoch
19:46:11 <Axman6> (It also has UniversalTime to dealing with UT1 if you need to, and probably some others)
19:46:40 <jusss`> Axman6: and AbsoluteTime DiffTime?
19:47:15 <Axman6> Data.Time.Clock.TAI: "TAI and leap-second maps for converting to UTC: most people won't need this module."
19:49:31 <Axman6> Like I said, this is a complex topic, we're lucky enough to have a (couple of)  package(s) which let us talk about several of the most common representations of time, and convert between them if it makes sense to do so, sometimes by using an intermediate type
19:50:56 <Axman6> jusss`: if you don't know which type to choose, go with UTCTime
19:53:22 <jusss`> Axman6: why POSIXTime and UTCTime use decimal representation?
19:53:49 <jusss`> should it be Integer?
19:54:18 <Axman6> I'm not sure what you mean
19:54:31 <jusss`> 2019-11-05 03:51:15.294294 UTC
19:54:49 <jusss`> 1572926058.2463907s
19:54:57 <dsal> How do you think it should be represented?
19:55:13 <jusss`> shouldn't they be 1572926058? 
19:55:28 <Axman6> that the Show instance - a UTCTime is the combination of a Day and a DiffTime, which represents the number of seconds into the day (with a maximum value of 86401 for leap seconds)
19:55:32 <dsal> You mean discard the subsecond resolution?  I use the subsecond resolution.
19:55:40 <Axman6> no, that's not what a UTC time is, that's a POSIX time
19:56:01 <Axman6> UTC time and P:OSIX time are not the same thing
19:56:07 <Axman6> POSIX*
19:56:37 <Axman6> but there are these functions: posixSecondsToUTCTime :: POSIXTime -> UTCTime, utcTimeToPOSIXSeconds :: UTCTime -> POSIXTime
19:56:42 <jusss`> 2019-11-05 03:51:15.294294 UTC   this is UTCTime, why not end with 03:51:15 ?
19:57:08 <Axman6> because lots of applications need higher precision than seconds?
19:57:36 <jusss`> ok
20:05:22 <jusss`> how we can lift a Maybe Int into IO (Maybe Int) ?
20:05:31 <heatsink> return
20:05:33 <jusss`> with liftIO ?
20:05:39 <jusss`> aha
20:06:05 <jusss`> :t return Nothing :: IO (Maybe a)
20:06:07 <lambdabot> IO (Maybe a)
20:06:38 <jusss`> :t liftIO (Just 3)
20:06:40 <lambdabot> error:
20:06:40 <lambdabot>     • Couldn't match expected type ‘IO a’
20:06:40 <lambdabot>                   with actual type ‘Maybe Integer’
20:07:27 <jollygood2> > return (Just 10) :: Maybe (Maybe Int)
20:07:29 <lambdabot>  Just (Just 10)
20:07:38 <jollygood2> return (Just 10) :: Either String (Maybe Int)
20:07:50 <jollygood2> > return (Just 10) :: Either String (Maybe Int)
20:07:53 <lambdabot>  Right (Just 10)
20:10:53 <jle`> lukelau: i wouldn't do it
20:11:09 <jusss`> :t liftIO @IO(Maybe Int) (return $ Just 3)
20:11:11 <lambdabot> error:
20:11:11 <lambdabot>     Pattern syntax in expression context: liftIO@IO
20:11:11 <lambdabot>     Did you mean to enable TypeApplications?
20:11:35 <jollygood2> why do you want to do it with liftIO?
20:11:38 <Axman6> :t liftIO
20:11:39 <lambdabot> MonadIO m => IO a -> m a
20:11:49 <jle`> lukelau: having it be explicit helps you know where type erasure is being circumvented, and where the potential performance impacts lie
20:11:54 <Axman6> Maybe Int isn't an IO a
20:11:56 <jle`> lukelau: hiding it in a constructor is just asking for trouble
20:12:20 <jusss`> jollygood2: what liftIO is used for?
20:12:20 <jle`> lukelau: think of it as explicit binding in a dep typed language, {x}. ...
20:12:54 <jollygood2> jusss` for something completely different. monad transformers
20:12:55 <jusss`> Axman6: return $ Just 3 is an IO a
20:13:15 <jusss`> jollygood2: a simple example?
20:13:39 <Axman6> jusss`: uh yes, sorry I misread :)
20:13:59 <Axman6> % :t liftIO @(IO (Maybe Int)) (return $ Just 3) 
20:14:00 <yahb> Axman6: ; <interactive>:1:10: error:; * Expected kind `* -> *', but `IO (Maybe Int)' has kind `*'; * In the type `(IO (Maybe Int))'; In the expression: liftIO @(IO (Maybe Int)) (return $ Just 3)
20:14:14 <Axman6> % :t liftIO (return $ Just 3) 
20:14:14 <yahb> Axman6: (MonadIO m, Num a) => m (Maybe a)
20:14:19 <rustacean> hi
20:14:24 <jusss`> Axman6: you're right, we should use `return' to create an IO type, but I wonder what liftIO can do
20:14:39 <Axman6> it's for Monads which wrap IO
20:14:41 <jollygood2> jusss`, given your questions I guess you have not worked with monad transformers yet.. so I don't think I can explain them, and show an understandable example, in a couple of irc lines
20:15:30 <jusss`> :t runMaybeT (liftIO (print True) :: MaybeT IO ())
20:15:31 <lambdabot> error:
20:15:31 <lambdabot>     Not in scope: type constructor or class ‘MaybeT’
20:15:31 <lambdabot>     Perhaps you meant ‘Maybe’ (imported from Data.Maybe)
20:16:00 <Axman6> % :t runMaybeT (liftIO (print True) :: MaybeT IO ())
20:16:01 <yahb> Axman6: ; <interactive>:1:35: error:; Not in scope: type constructor or class `MaybeT'; Perhaps you meant `Maybe' (imported from Prelude)
20:16:19 <Axman6> % :t runExceptT (liftIO (print True) :: ExceptT String IO ())
20:16:19 <yahb> Axman6: IO (Either String ())
20:17:15 <evocatus> % :t liftIO
20:17:16 <yahb> evocatus: MonadIO m => IO a -> m a
20:18:03 <evocatus> jusss`: liftIO can take IO actions and turn them into actions in any monad `m`, so long as that monad `m` instances `MonadIO`... it's useful for when you're deep in a stack of monad transformers and want to perform IO actions within the stack
20:21:28 <jusss`> evocatus: ok
20:21:36 <jusss`> :i MonadIO
20:22:09 <Axman6> class Monad m => MonadIO m where liftIO :: IO a -> m a
20:22:36 <Axman6> in GHCI you'll get a (long) list of instances if you have Control.Monad.IO.Class imported
20:23:16 <jusss`> Axman6: but the MonadIO  must be like IO (...) ?
20:23:50 <jusss`> IO is the outsider
20:24:27 <jle`> MonadIO makes no claim about how the type is structured
20:24:34 <jle`> just that it has to support IO a -> MyMonadIO a
20:24:47 <Axman6> in ExceptT String IO a it is really the outside monad - ExceptT String IO a is IO (Either String a) under the hood
20:24:58 <jusss`> jle`: liftIO :: IO a -> m a, this m can be Maybe?
20:25:07 <jle`> no, because Maybe has no instance of MonadIO
20:25:21 <jle`> so that's a 'proof' that Maybe cannot have an instance of MonadIO
20:25:42 <jusss`> jle`: but this m a can be IO (Maybe a)?
20:25:53 <jle`> no, that doesn't unify
20:26:11 <jle`> what would m be?
20:26:20 <jusss`> ok, my fault, I should go check what MonadIO is...
20:26:32 <jle`> it's really as simple as just the typeclass here
20:26:42 <jle`> it has a single method, liftIO :: MonadIO m => IO a -> m a
20:26:50 <jusss`> jle`: MaybeT IO Maybe a
20:27:00 <Axman6> but without understanding monad transformers it probably won't make a lot of sense
20:27:04 <jle`> do you mean `MaybeT IO a` ?
20:27:10 <jusss`> jle`: yeah
20:27:41 <jle`> i don't think MonadIO has anything to do with monad transformers in particular ... because no monad transformers are MonadIO instances
20:27:52 <jusss`> ok...
20:28:00 <jle`> MonadIO instances are monads
20:28:04 <jle`> not monad tnnasformers
20:28:25 <jle`> the simplest MonadIO instance is IO
20:28:28 <jle`> instance MonadIO IO where
20:28:28 <f-a> the trick is mostly useful (or taught) as a way to fish IO from a stack
20:28:33 <jle`>   liftIO = id
20:29:01 <jle`> i think that's a narrow way of looking at it...a MonadIO instance doesn't even have to be a part of a 'stack'
20:29:05 <jle`> it's just something that "supports IO"
20:30:03 <siraben> Is there a good tutorial on implementing freer monads from scratch to combine IO effects such as filesystem access, Teletype, etc?
20:30:46 <jle`> siraben: maybe look into 'data types a la carte'
20:32:05 <maerwald> siraben: it isn't any different from other effects really
20:32:11 <Axman6> does isovector's blog posts on polysemy start with an introduction to free(r) monads? I can't remember
20:32:28 <maerwald> polysemy tutorial should be sufficient to get started with that yes
20:32:31 <siraben> jle`:  Yeah, I've read that paper and implemented the code; https://gist.github.com/siraben/eff8971545e34310e569648534deb5d5 , but IIRC it suffers from adding additional effects
20:32:43 <siraben> Oleg's blog post: http://okmij.org/ftp/Haskell/extensible/extensible-a-la-carte.html
20:32:53 <siraben> So I was wondering how it compared with extensible effects and later polysemy.
20:33:20 <siraben> suffers from not being able to add additional effects*
20:33:29 <jle`> if you've gone through that then you are experienced with free monads as any other
20:33:44 <jle`> you are now the top echelon of people who understand free monads
20:33:52 <jle`> haskell is lonely like that :'(
20:34:09 <siraben> Is it not that different from EE and polysemy?
20:34:21 <maerwald> siraben: what do you mean with "it suffers from adding additional effects"?
20:34:24 <jle`> it's ... different, i think
20:34:37 <jle`> free monads is a specific mechanism, not a design pattern
20:34:41 <siraben> maerwald:  suffers from not being able to add additional effects*
20:34:44 <maerwald> in polysemy you can have higher-order effects and re-interpret effects
20:34:47 <siraben> At least, according to Oleg.
20:35:01 <jle`> so EE and polysemy etc. are not limited to just tools like free monads
20:35:04 <maerwald> but the author says it sometimes has weird semantics that are not clear
20:35:24 <jle`> free monads are a level much lower than an actual extensible effects system
20:35:35 <siraben> Also, how do EE and polysemy compare to MTL in terms of performance?
20:36:03 <jle`> afaik mtl is still the gold standard
20:36:13 <maerwald> polysemy is supposed to be very fast
20:36:26 <maerwald> and mixing mtl with polysemy is possible
20:36:27 <Axman6> (or should be once GHC 8.10 is out)
20:36:52 <Axman6> polysemy should match MTL soonish
20:37:05 <maerwald> but the future is uncertain
20:38:54 <maerwald> https://www.reddit.com/r/haskell/comments/dm3wyd/wip_eff_screaming_fast_effects_for_less_the/f4y4gjb/
20:40:20 <siraben> Interesting. I thought MTL had low performance due to stacking of monads vs. extensible effects which uses open unions and type-level lists?
20:41:00 <jle`> mtl doesn't have anything to do with monad stacking
20:41:24 <jollygood2> is there a `wrapText :: Int -> String -> String' function?
20:41:32 <jle`> what would it do?
20:42:14 <jollygood2> split text into multiple lines, if they exceed maximum line length
20:42:43 <jle`> hm, maybe chunksOf from Data.List.Split
20:42:46 <siraben> jle`: I mean, the layering of monads.
20:42:47 <jle`> unlines . chunksOf i
20:43:00 <jle`> siraben: right, mtl doesn't have anything to do with monad transformers
20:43:21 <siraben> Wait, it doesn't?
20:43:28 <maerwald> jle`: weird, it depends on monad transformers :)
20:43:31 <evocatus> wat
20:43:34 <jle`> yea, it just lets you selectively specify effects
20:43:41 <jle`> it depends on transformers because it provides instances
20:43:51 <jollygood2> ideally it would be intelligent, it wouldn't split the string in the middle of the word, for example
20:43:52 <maerwald> so it definitely does have something to do with it ;)
20:44:08 <jollygood2> I guess I'll have to hack my own? or maybe Data.Text has something similar?
20:44:16 <jle`> i suppose not in a fundamental level
20:44:22 <jle`> that's like saying that Monoid has to do with String
20:44:29 <dibblego> jollygood2: https://hackage.haskell.org/package/ansi-wl-pprint
20:44:30 <jle`> String is a Monoid, but it's not like using monoid == using strings
20:44:50 <maerwald> jle`: well, how do you use mtl without transformers (and who does that?)
20:45:04 <jollygood2> dibblego looks promising.. thanks
20:45:19 <jle`> it's pretty common, you can have a type like newtype WithConfig a = WC (Config -> IO a)
20:45:26 <jle`> and that has an intsance of MonadReader Config
20:45:29 <jle`> and an instance of MonadIO
20:45:33 <maerwald> well sure
20:45:50 <jle`> so now what you can do is have a type like myAction :: MonadReader Config m => m String
20:45:57 <jle`> or myOtherActoin :: MonadIO m => m a
20:46:13 <maerwald> most people have their master monad and then all sorts of specialised ones that run through existing transformers
20:46:16 <jle`> mtl is the system that lets you 'selectively specify' effects, and write polymorphically over different monads
20:46:36 <jle`> that's just one way to create a monad that has a readability, io, etc.
20:46:38 <jle`> but it's not the only way
20:46:46 <jusss> except IO, what’s other instance of  MonadIO
20:46:54 <jle`> mtl isn't *about* stacking monads, it's about being able to selectively specify effects
20:47:06 <jle`> and write while abstracting over different monads that offer different effects
20:47:08 <maerwald> I would say transformers are the canonical way to use mtl
20:47:17 <jle`> MonadReader COnfig m => ..., means that m has the ability to ask :: m Config
20:47:18 <jollygood2> dibblego that package has great api
20:47:43 <jle`> and there are plenty of monads that aren't monad transformers that have an ask :: m Config
20:48:13 <jle`> i don't mean to appeal to authority, but this is also edward kmett's vision of mtl
20:48:28 <f-a> jle`: https://hackage.haskell.org/package/transformers-0.4.1.0/docs/Control-Monad-IO-Class.html see the pattern?
20:48:34 <jle`> not as a library for managing monad transformers, but rather as a way of writing polymorphically over monads that just have to have certain effects
20:48:39 <f-a> imagine having a deep stack
20:48:52 <jle`> f-a: you're just giving me one specific application of MonadIO
20:48:58 <jle`> but there are other useful ways to use MonadIO
20:49:40 <jle`> monad transformers are useful because they give you 'free' instances of MonadIO, MonadReader, MonadExcept, etc.
20:49:53 <jle`> so the link between monad transformers and mtl is sort of like the link between lists and monoids
20:49:55 <f-a> wuups I was replying to jusss , not to you sorry jle` 
20:50:20 <jle`> yeah, lists give you a "free monoid" instance. but using monoids is about a lot more than just using lists
20:50:28 <jle`> so approaching monoids just from the perspective of lists is pretty limting
20:50:53 <maerwald> jle`: I agree, but it's a bit far fetched saying they have nothing to do with each other still
20:51:00 <jle`> [Int] is a monoid yeah, but so is Sum Int, etc., many other instances
20:51:19 <maerwald> monoid has something to do with lists, because they share a structure
20:51:23 <jle`> 'nothing to do' might have been overreaching, maybe i should say 'using mtl doesn't imply using transformers'
20:51:29 <jollygood2> a bit unfortunate that ansi-wl-pprint uses <$> identifier
20:51:38 <jle`> yeah, so there's a 'theoretical' link in the mathematics of the abstraction
20:51:46 <jle`> but in the actual usage of the abstraction, there isn't really necessarily a link
20:51:47 <f-a> yup jle` , you oughta hide it 
20:52:25 <chreekat> jollygood2: try https://hackage.haskell.org/package/prettyprinter 
20:52:43 <jle`> so maybe 'mtl doesn't have anything to do with transformers' is somewhat ambiguous. i should say 'mtl doesn't necessarily imply using transformers'
20:52:52 <jle`> just like how using Monoid doesn't mean you have to use lists to make all your monoids
20:53:07 <f-a> argh sorry again jle` 
20:53:14 <jle`> in fact the interesting usages of Monoid happen when you use monoids that *aren't* lists
20:53:15 <f-a> yup jollygood2 , you oughta hide it 
20:53:21 * f-a should stop j<tab>-ing
20:54:00 <jollygood2> hide applicative's <$> or pretty printers? 
20:54:15 <jle`> i'd qualify pp's <$>
20:54:33 <jle`> presumably if they wrote the library today, they wouldn't have chosen <$>
20:55:09 <jollygood2> so it is pre-<$>.. if there's a breaking change worth making..
20:56:54 <f-a> jollygood2: something like
20:56:55 <f-a> import PPMod hiding ( (<$>) )
20:56:55 <f-a> import qualified PPMod as PP
20:57:31 <f-a> depending on your module, you could get away with hiding Prelude's one or what jle` said
20:57:32 <jle`> siraben: in any case, monad transformers are essentially just newtype wrappers ... they don't incur any runtime cost
20:58:05 <jle`> siraben: so even if you had something like ReaderT r (StateT s IO) a, that's just r -> s -> IO (a, s)
20:58:27 <siraben> jle`:  So what's the performance penalty of https://github.com/siraben/vpl/blob/master/src/VPLTypes.hs#L60-L71
20:58:40 <siraben>     { runTurtle :: ExceptT String (RWS Env Picture TurtleST) a } isn't a "stack of monads"?
20:59:29 <jle`> under the hood it's Env -> Picture -> Either String (TurtleST, a)
20:59:36 <jle`> it's just newtype wrappers
20:59:50 <jle`> that's all it is at runtime
21:00:08 <jle`> so usages of >>= and <$> etc. are just operating on that type
21:00:14 <siraben> Wow, I didn't know that MTL did that.
21:00:17 <jle`> to generate a "new" Env -> Picture -> Either String (TurtleST, a)
21:00:33 <jle`> mtl doesn't do that
21:00:38 <jle`> transformers does that :)
21:00:39 <siraben> I thought it was implemented the same way monad transformers are described in a book by bird, with "promote" and so on
21:00:51 <jle`> the power of mtl is that it is abstract: *anything* can have an instance of MonadReader Env
21:01:04 <jle`> so you can write something of type myAct :: MonadReader Env m => m String
21:01:08 <jle`> and it can now work over any type you want
21:01:18 <jle`> and the performance characteristics you have depend on whatever type you instance 'm' as
21:01:56 <jle`> so if you use it with m ~ (->) Env, it's basically just working with a normal function. if you use it with m ~ ReaderT Env n, it's just a normal function, Env -> n String
21:02:10 <jle`> and presumably you could also use it with polysemy monads, ee monads, etc.
21:02:28 <jle`> just any monad that allows you to write `ask :: M Env`
21:02:33 <siraben> I see. Thanks for clearing it up.
21:02:48 <jle`> mtl hands off its 'performance' to whatever type instances m
21:03:53 <siraben> Is the wiki outdated when it says "However stacked monad transformers do not inline well ... it can often impose a performance hit of up to 300%... " https://wiki.haskell.org/Performance/Monads ?
21:04:48 <jle`> hm, maybe there are some issues that have to do with newtype wrappers/unwrappers not disappearing properly
21:04:57 <maerwald> mtl is simple. Not really easy to build a proper effects system with it though
21:05:12 * hackage haskell-src-exts-simple 1.22.0.0 - A simplified view on the haskell-src-exts AST  https://hackage.haskell.org/package/haskell-src-exts-simple-1.22.0.0 (BertramFelgenhauer)
21:05:15 <jle`> the 'hand-unrolled' style, like in the article, is a good way to use mtl without monad transformers
21:05:24 <jle`> and was what i was hinting at earlier
21:05:37 <jle`> newtype wrappers have a pesky way of ... not disappearing when they are supposed to
21:07:12 <jle`> so that's a downside of using monad transformers, i suppose
21:07:23 <jle`> but in the article it shows a way of using mtl without monad transformers where the problems go away
21:07:46 <maerwald> jle`: you mean the wiki.haskell.org article?
21:07:47 <int-e> RWST exists mainly for that reason, I suppose.
21:07:59 <jle`> yeah
21:08:09 <maerwald> and then there is RIO :P
21:08:43 <maerwald> https://hackage.haskell.org/package/rio-0.1.12.0/docs/RIO.html#g:2
21:09:35 <jollygood2> how do I wrap lines with Text.PrettyPrint.ANSI.Leijen?
21:09:39 <maerwald> so basially, haskell started with lots of IO code, then people tried to express effects, came up with monad transformers, effects systems that are complicated... and now move back to IO and a config parameter (which is basically reader)
21:09:43 <maerwald> and history will repeat itself
21:10:29 <siraben> Wowza
21:10:37 <jle`> pentafunctor IO is where it's at, of course
21:12:59 * Axman6 prefers to use amateurfunctor optics
21:13:15 * jackdk holds fast to lens
21:26:57 <jusss`> jle`: MaybeT m is the instance of MonadIO ?
21:27:31 <f-a> jusss`: if m is, yes
21:27:39 <Axman6> I think you'll find that MonadIO m => MonadIO (MaybeT m) is the instance
21:27:57 <jusss`> f-a: I still don't get it...
21:28:05 <Axman6> as long as MaybeT wraps something which can run IO actions, it can also run IO actions
21:28:12 <f-a> jusss`: do you know what a constraint is?
21:28:26 <Axman6> jollygood2:  what do you mean by wrap?
21:28:33 <jle`> jusss`: well, is there a way to write an IO a -> MaybeT m a ?
21:28:35 <f-a> if I say: Monad m => m a, ca you parse this signature?
21:28:39 <jle`> jusss`: if yes, then it's a MonadIO instance
21:28:47 <jusss`> f-a: barely
21:29:04 <jle`> in this case, we can write one:
21:29:12 <f-a> jusss`: then maybe MonadIO is not that important at the moment
21:29:13 <jle`> liftIOMaybe :: MonadIO m => IO a -> MaybeT m a
21:29:23 <jle`> liftIOMaybe x = MaybeT (liftIO x)
21:29:25 <jle`> er
21:29:31 <f-a> keep reading whichever book are you reading and you'll see that in no time you will get it all
21:29:50 <jle`> liftIOMaybe x = MaybeT (Just <$> liftIO x)
21:30:01 <jusss`> newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }
21:30:04 <jle`> it's possible, so it's an instance ... just as simple as that
21:30:30 <jle`> there are a couple of laws, but that's not super important right now
21:30:46 <jusss`> f-a: Monad m => m a means this m is an instance of typeclass Monad
21:30:46 <jle`> maybe looking more concretely, can you write IO a -> MaybeT IO a ?
21:30:55 <f-a> jusss`: excellent
21:30:56 <f-a> now
21:30:58 <f-a> if I say
21:31:36 <f-a> MonadIO m => MonadIO (MaybeT m)
21:31:57 <f-a> (typeclass instance)
21:33:06 <evocatus> I will just leave this here... https://page.mi.fu-berlin.de/scravy/realworldhaskell/materialien/monad-transformers-step-by-step.pdf
21:33:08 <jollygood2> Axman6, wrap sentences at 79 characters, so that it is formatted nicely in the terminal. I kind of did it by splitting everything into words 
21:34:00 <jollygood2> putStrLn $ flip displayS "" $ renderSmart 1 80 $ hang 11 $ fillSep (map text (words $ "Text:   " ++ longSingleLineText))
21:34:38 <Axman6> jollygood2: yeah you could write a function which splits a string into alternating wqhite space and non white space, and put a soft new line after each whitespace section
21:34:45 <f-a> jollygood2: with a bit of work you could also have it hyphened https://hackage.haskell.org/package/linebreak
21:34:47 <jollygood2> it isn't ideal though, because it will modify original white spacing
21:35:19 <jollygood2> (modify it beyond just inserting newlines, that is)
21:35:58 <Axman6> there's also https://hackage.haskell.org/package/hyphenation
21:36:17 <f-a> Axman6: that won't break lines for you at $NUM
21:38:47 <jusss`> jle`: f :: IO a -> MaybeT IO a;  f x = runMaybeT (liftIO x) ?
21:38:57 <Axman6> no, but it will let you rejoin all the returned sections with one of the combinators which adds a soft line
21:39:12 <Axman6> jusss`: does that type check?
21:39:30 <Axman6> that doesn't look like it matches the type you've given
21:39:53 <Axman6> jusss`: if you have an IO a, and you need an IO (Maybe a) how can you do that?
21:40:24 <jusss`> Axman6: get a from IO a, then  return Maybe , then return IO
21:40:36 <wejetheman> does anyone know any way to abstract some of the redundancy inside of my move function in this exercise? http://codepad.org/PIIVSs9s
21:40:37 <jusss`> Axman6: but this will switch contexts
21:40:52 <Axman6> that matches the type, but it's not as useful as returning the a that the IO action produced
21:41:20 <Axman6> jusss`: can you write f :: IO a -> IO (Maybe a) without using Nothing
21:43:07 <jusss`> Axman6: f = \x -> x >>= return $ return a
21:43:37 <Axman6> :t let f = \x -> x >>= return $ return a in f
21:43:39 <lambdabot> Monad m => (m Expr -> t) -> t
21:43:52 <Axman6> not wuite
21:43:53 <jusss`> Axman6: I don't know the syntax, if I want declare the type in the value
21:43:54 <Axman6> quite*
21:44:07 <Axman6> jusss`: hint: use fmap
21:44:22 <Axman6> :t Just
21:44:23 <lambdabot> a -> Maybe a
21:44:29 <Axman6> :t fmap Just
21:44:30 <lambdabot> Functor f => f a -> f (Maybe a)
21:44:40 <Axman6> % :t fmap @IO Just
21:44:40 <yahb> Axman6: IO a -> IO (Maybe a)
21:45:24 <Axman6> so f :: IO a -> IO (Maybe a); f ioa = fmap Just ioa
21:45:45 <Axman6> %t MaybeT
21:45:53 <Axman6> % :t MaybeT
21:45:53 <yahb> Axman6: m (Maybe a) -> MaybeT m a
21:46:03 <Axman6> % :t MaybeT @IO
21:46:04 <yahb> Axman6: IO (Maybe a) -> MaybeT IO a
21:46:42 <jusss`> Axman6: f x = fmap (\y-> Just y) x ?
21:47:00 <jusss`> oh, f x = fmap Just x
21:47:04 <jusss`> eta-reduce
21:47:05 <Axman6> so going back to jle`'s original exercise, how can we write the function g :: IO a -> MaybeT IO a?
21:47:11 <Axman6> yep, good!
21:47:13 <jusss`> Just = \x -> Just x
21:49:32 <Axman6> jusss`: can you now write  g :: IO a -> MaybeT IO a? we've seen how to go from IO a to IO (Maybe a), and MaybeT is just a wrapper around things of the shape m (Maybe a)
21:50:37 <jusss`> f x = MaybeT $ fmap Just x
21:50:43 <f-a> wejetheman: to start, maybe http://www.ariis.it/link/t/paste360-0
21:51:05 <jusss`> Axman6: right?
21:51:32 <Axman6> % :t let f x = MaybeT $ fmap Just x in f -- let's find out
21:51:32 <yahb> Axman6: Functor m => m a -> MaybeT m a
21:51:48 <Axman6> Looks good to me, though that's evenmore powerful :o
21:51:59 <Axman6> Nice work!
21:52:28 <Axman6> whatr you've actually defined is the function lift, from the MonadTrans class
21:52:28 <jusss`> Axman6: but this type and value has same constructor is still weird to me...
21:52:31 <Axman6> :t lift
21:52:33 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
21:52:47 <Axman6> where t = MaybeT
21:52:48 <jusss`> Axman6: and I always ignore the value consturctor
21:53:07 <Axman6> jusss`: it takes some getting used to, you'll get used to it :)
21:53:36 <Axman6> all it takes is practice
21:54:13 <jusss`> Axman6: but how we can make sure about the t?
21:54:35 <jusss`> lift x = MaybeT $ fmap Just x
21:54:47 <Axman6> well, let's try and do the ExceptT version
21:54:52 <wejetheman> f-a interesting, i never knew pred was a thing
21:54:55 <Axman6> % :t ExceptT
21:54:55 <yahb> Axman6: m (Either e a) -> ExceptT e m a
21:55:23 <Axman6> can you write h :: IO a -> ExceptT String IO a?
21:57:04 <f-a> wejetheman: I suppose there is probably a typeclass for it to (circular enum thingie). For advance you could shave a few words by calculating axis and sign (+/-), but it feels not so useful
21:57:05 <jusss`> lift x = ExceptT "" $ fmap Right x?
21:57:16 <Axman6> not quite
21:57:22 <Axman6> :t ExceptT
21:57:23 <lambdabot> m (Either e a) -> ExceptT e m a
21:57:48 <Axman6> it only takes one argument, of type m (Either e a), so that " shouldn't be there
21:57:52 <Axman6> ""*
21:58:26 <wejetheman> f-a no big magic bullet thing im missing though huh?
21:59:04 <jusss`> lift x = Except $ fmap Right x?
21:59:12 <mjrosenb> writing a state monad where put x >> get produces something other than X would be breaking a monad law, and thus bad, right?
21:59:20 <jusss`> ExceptT
21:59:46 <Axman6> % :t lift x = ExceptT $ fmap Right x in lift
21:59:46 <yahb> Axman6: ; <interactive>:1:8: error:; parse error on input `='; Perhaps you need a 'let' in a 'do' block?; e.g. 'let x = 5' instead of 'x = 5'
21:59:55 <Axman6> % :t let lift x = ExceptT $ fmap Right x in lift
21:59:56 <yahb> Axman6: Functor m => m a -> ExceptT e m a
22:00:03 <Axman6> Looks good to me!
22:00:20 <f-a> wejetheman: not that I see! let's wait for other, more experienced folks to check the code
22:00:27 <jusss`> Axman6: so we will have lots of lift functions to define?
22:00:28 <Axman6> % :t let lift x = ExceptT $ fmap Right x in lift (putStrLn "")
22:00:28 <yahb> Axman6: ExceptT e IO ()
22:00:42 <wejetheman> (y) 
22:00:52 <jusss`> Axman6: with patter matching?
22:00:56 <jusss`> pattern
22:01:29 <Axman6> jusss`: well, for someing to be a monad transformer, it needs to provide the function lift which can turn some monad m into t m
22:01:37 <Axman6> no pattern matching here that I can see
22:02:13 <jusss`> Axman6: how I can tell lift will turn monads into which transformer?
22:02:36 <Axman6> it depends on the context
22:02:55 <Axman6> % :t lift (print ()) :: ExceptT Int IO ()
22:02:55 <yahb> Axman6: ExceptT Int IO ()
22:03:01 <jusss`> Axman6: so we should use lift in a do-notation or like >>= ?
22:03:04 <Axman6> % :t lift (print ()) :: MaybeT IO ()
22:03:04 <yahb> Axman6: MaybeT IO ()
22:03:13 <Axman6> % :t lift (print ()) :: StateT s IO ()
22:03:14 <yahb> Axman6: StateT s IO ()
22:03:14 <jle`> jusss`: you use it whenever you want to turn an 'm a' into a 't m a'
22:03:24 <jle`> which can happen in many different situations
22:03:29 <jle`> the types will guide you, when you need it
22:04:46 <mjrosenb> I guess what I want is something like StateT (Maybe a) b, so that once the state becomes Nothing, you can't update it anymore
22:05:39 <jusss`> Axman6: jle` what's the relation, lift and liftIO?
22:06:35 <jusss`> lift is a function which lift its monadic value parameter into a monad transformer?
22:06:38 <mjrosenb> but I also want code to see a StateT (Identity a) b, rather than a Maybe a
22:06:38 <Axman6> good queation - with what we've written so far, lift and liftIO have been the same. but what happens when we want ExceptT String (MaybeT IO) a?
22:07:03 <mjrosenb> but that b also can't be b, it would need to be (Maybe b)
22:07:29 <jle`> jusss`: the types tell you everything you need to know
22:07:40 <jle`> lift :: MonadTrans t => m a -> t m a
22:07:47 <jle`> liftIO :: MonadIO m => IO a -> m a
22:07:58 <jle`> they are similar in that they are both 'monad homomorphisms'
22:08:11 <jle`> or natural transformations
22:08:14 <jle`> they move you from one monad to another
22:08:20 <jle`> lift moves you from 'm' to 't m'
22:08:25 <jle`> liftIO moves you from 'IO' to 'm'
22:08:50 <jle`> in a way they can be seen just as boilerplate, just moving an action from one monad to another
22:09:02 <jle`> liftIO :: IO a -> MaybeT IO a, you move from (IO) monad to (MaybeT IO) monad
22:09:10 <jle`> the use case?  when you have an IO a, but you want a MaybeT IO a
22:09:25 <jle`> or more generally, liftIO :: IO a -> MyMonad a
22:09:32 <jle`> the use case? when you have an 'IO a', but you want 'MyMonad a'
22:09:39 <jle`> there isn't really anything deeper or more profound than that
22:10:16 <jle`> the reasion liftIO exists is so that you don't have to define a liftIOIntoMyMonad :: IO a -> MyMonad a, for every single monad
22:10:49 <jle`> then you'd have something like liftIOMaybeT :: IO a -> MaybeT IO a, liftIOStateT :: IO a -> StateT s IO a, liftIOExceptT :: IO a -> ExceptT e IO a
22:11:02 <jle`> you could just have one function referring to all of the with the same name
22:11:19 <jle`> like how by having Eq and (==), you wouldn't have to write eqInt, eqString, eqFloat, eqDouble, etc.
22:11:21 <jusss``> lift IO into MaybeT IO a, then lift the result into EexceptT?
22:11:31 <jle`> i'm not sure what you are asking
22:11:38 <jusss``> jle`: sorry, net split, I''m reading your words
22:11:49 * Axman6 hands the reins back to jle`
22:13:03 <jle`> MonadIO is a completely ad-hoc typeclass -- just like Eq, Ord, Show, Read, etc.; basically used for overloading names of useful functions, with some laws to make it a little more predictable
22:13:08 <jusss``> jle`: Axman6 sorry, this ExceptT String (MaybeT IO) a really got me
22:13:20 <jle`> without monad IO, we'd do just fine.  we'd have liftIOMaybeT :: IO a -> MaybeT IO a, liftIOStateT :: IO a -> StateT s IO a, etc.
22:13:47 <jle`> having MonadIO just lets us call all of those functions by the same name, liftIO. just like how having Eq lets us call our Int comparer, Double comparer, string comparer, etc. all with (==)
22:14:12 <jusss``> jle`: is MonadIO a monad?
22:14:20 <jle`> no, it is a typeclass, like Eq, Ord, Show, etc.
22:14:22 <jle`> but its instances are monads
22:14:58 <jusss``> MaybeT m is a monad?
22:14:58 <jusss``> when m is a monad,
22:15:02 <jle`> yes
22:16:02 <jle`> that's why it is called a "monad transformer"
22:16:06 <jle`> give it a monad, and it returns a monad
22:16:17 <jle`> IO is a monad, so `MaybeT IO` is a monad
22:16:19 <jusss``> jle`: sorry, it's lots of messages I need to think a few moments
22:16:39 <jle`> give MaybeT a monad, and it returns a new monad.  if you have a monad M, then MaybeT M is a fresh new monad for you
22:17:15 <jusss``> jle`: can you give me a simple instance of MonadIO 
22:17:32 <dibblego> jusss``: you can ask ghci for the instances, use :info
22:17:35 <jusss``> like newtype MaybeT m a = MaybeT m (Maybe a)
22:17:47 <jle`> one simple instance is IO
22:17:53 <jle`> instance MonadIO IO where liftIO = id
22:17:59 <jusss``> jle`: except IO
22:18:17 <jle`> another simple instance is MaybeT IO, liftIO x = MaybeT (Just <$> x)
22:18:30 <jle`> in that type, liftIO :: IO a -> MaybeT IO a
22:19:16 <Administrator_> ....
22:19:47 <jusss``> jle`: MonadIO is a typeclass, and MaybeT IO is an instance of MonadIO, also MaybeT IO is an instance of Monad?
22:19:50 <monochrom> "An adminstrator walked into a bar"
22:20:03 <jle`> yes all of those are true
22:20:11 <Administrator_> waoo
22:20:12 <jle`> MonadIO is actually a subclass of Monad
22:20:17 <jle`> class Monad m => MonadIO m
22:20:26 <jle`> just like how Ord is a subclass of Eq
22:20:31 <jle`> Fractional is a subclass of Num, etc.
22:20:40 <Administrator_> where are you  from??
22:20:56 <jle`> in haskell we have many Monads, and some of those Monads are MonadIO
22:21:10 <jle`> some Functors are Applicatives.  some Applicatives are Monads.  some Monads are MonadIO
22:21:32 <jle`> some shapes are quadrilaterals, some quadrilaterals are rectangles, some rectangles are squares, etc.
22:22:51 --- mode: ChanServ set +o dibblego
22:23:00 --- mode: dibblego set +b *!*@103.136.111.227
22:23:53 <jle`> if seeing monad transformers is confusing, maybe look at a simpler MonadIO instance, like `newtype WithArgs a = WithArgs { runWithArgs :: String -> IO a }`
22:24:22 <jle`> er, `newtype WithArgs a = WithArgs { runWithArgs :: [String] -> IO a }`
22:24:39 <jle`> WithArgs a is [String] -> IO a, it's an IO a that has access to a [String], the command line arguments
22:24:49 <jle`> we can write an instance of Functor
22:25:03 <jle`> instance Functor WithArgs where fmap f (WithArgs x) = WithArgs (fmap f . x)
22:25:16 <jle`> we can write an instance of Applicative, which i'll only give 'pure' here:
22:25:28 <jle`> instance Applicative WithArgs where pure x = WithArgs $ \_ -> pure x
22:25:38 <jle`> and we can write an instance of Monad (exercise left to reader)
22:25:42 <jle`> and we can write an instance of MonadIO:
22:25:50 <jle`> instance MonadIO WithArgs where liftIO x = WithArgs $ \_ -> x
22:26:04 <jle`> so that's an example of a Functor that is also an Applicative that is also a Monad that is also a MonadIO
22:26:10 <jusss``> jle`: MonadIO a is MT IO a, the value is like MT IO (M a) ?   MT mean monad transformer type constructor
22:26:28 <jle`> no, not necessarily
22:26:38 <jle`> look above where i gave an instance of MonadIO that doesn't involve any monad transformer applied to IO
22:26:54 <dibblego> then do the reader exercise
22:27:28 <jle`> here the `WithArgs` type i defined above is an instance of (1) Functor, (2) Applicative, (3) Monad, (4) MonadIO
22:27:43 <jle`> but there are no monad transformers involved
22:27:56 <jle`> the purest form of a MonadIO
22:28:35 --- mode: dibblego set -b Administrator_!*@*
22:28:36 <jle`> dibblego: i didn't even realize that i was making a pun there
22:28:47 --- mode: dibblego set -b *!*@103.136.111.227
22:28:52 --- mode: ChanServ set -o dibblego
22:31:00 <purelazy> How to does one write the import statement to hide "null" from "Data.Foldable", which I presume is part of Prelude?
22:31:21 <dibblego> import Data.Foldable hiding (null)
22:31:29 <jle`> import Data.Foldable hiding (null), but if you want to hide it from Prelude completely ou can do import Prelude hiding (null) as well
22:31:36 <jle`> um, i'm not sure if Prelude exports null
22:31:48 <purelazy> I did that in ghci
22:32:12 <monochrom> Prelude exports null
22:32:12 * hackage tmp-postgres 1.0.1.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.0.1.0 (JonathanFischoff)
22:32:50 <purelazy> The I typed :t null and get null :: t a -> Bool
22:32:57 <jle`> hm, you'd have to "un-import" Prelude, in that case
22:33:18 <jle`> i'm not sure if that is possible
22:33:25 <purelazy> But I want the Predule :)
22:33:35 <monochrom> import Prelude hiding (null)  -- pull the same trick
22:33:41 <MarcelineVQ> ^
22:33:42 <jle`> yeah, you'd be unimporting it and then re-importing it hiding null
22:33:52 <jle`> monochrom: the problem is doing that in ghci
22:34:14 <monochrom> Don't do everything manually in ghci then.
22:34:32 <monochrom> Write a file to contain your import lines, then use :load
22:34:47 <monochrom> ghci is not an IDE editor.
22:35:20 <monochrom> Why do people type in everything manually into ghci and then demand "how do I save everything I have typed into ghci?"?
22:35:21 <jle`> it would be a neat feature i think
22:35:47 <jle`> to not import Prelude. i wonder if -XNoImplicitPrelude would do the trick in ~/.ghci
22:36:06 <purelazy> Yey!    Thanks.  :t null = <interactive>:1:1: error: Variable not in scope: null
22:36:09 <jle`> i commonly import combinators that shadow prelude bindings
22:36:34 <jle`> oh neat it works :o
22:36:54 <jle`> purelazy: yeah, then you can import Prelude hiding (null) to get all of prelude back
22:37:05 <jle`> (except for null)
22:37:06 <jusss``> jle`: now, I see, there're four typeclass, Functor, Applicative, Monad and MonadIO, some monads are MonadIO, some aren't, MonadIO isn't related to Monad Transformer,  Monad Transformer is also a typeclass? what's the relation Monad and Monad Transformer?
22:37:31 <jle`> jusss``: MonadTransformer is also a typeclass, but it exists separately from the Functor > Applicative > Monad > MonadIO hierarchy
22:37:39 <jle`> it's a different "kind", too
22:37:52 <jle`> Functor, Applicative, Monad, MonadIO instances are all (Type -> Type)
22:38:02 <jle`> but MonadTrans instances are all (Type -> Type) -> (Type -> Type)
22:38:23 <jle`> they "take" a (Type -> Type) (your monad), and "return" a (Type -> Type) (your transformed monad)
22:38:47 <jle`> so MonadTrans is a higher-higher-kinded abstraction. it abstracts over all things that can transform monads
22:39:01 <jusss``> jle`: we use kind to describe type, we use typeclass to describe type, typeclass is related to kind?
22:39:17 <dibblego> 🥄
22:41:29 <jle`> hm, i don't think there is really any formal link for it. kinds can be used to reason with types and how they fit together, but typeclasses express the 'capabilities' that certain types have in terms of value-level functions associated with them
22:43:23 <jusss``> jle`: what you mean (Type -> Type)?
22:43:35 <jle`> (* -> *)
22:44:34 <jusss``> Monad has the kind * -> *, and MonadTrans has the kind (*->*) -> (*->*) ?
22:44:57 <jle`> instances of Monad have kind * -> *, and instances of MonadTrans have kind (* -> *) -> (* -> *)
22:45:25 <jusss``> jle`: and instances of MonadIO have kind ?
22:45:40 <jle`> Functor, Applicative, Monad, MonadIO instances are all * -> *
22:45:49 <jusss``> yeah
22:47:22 <jusss``> jle`: about the law, Monad has that three laws, and MonadIO ? 
22:47:40 <jusss``> MonadIO is a sub class Monad, and some monads aren't MonadIO
22:47:49 <jusss``> MonadIO at least has three laws?
22:48:00 <jusss``> and the implement functions?
22:48:13 <jusss``> and laws and functions about MonadTrans?
22:48:27 <jle`> https://hackage.haskell.org/package/transformers-0.4.1.0/docs/Control-Monad-IO-Class.html
22:48:57 <jusss``> jle`: Monads are about effects, and MonadIO and MonadTrans are about ?
22:49:11 <jle`> um...don't listen to the line that says "instances should satisfy ..", it's kind of iffy
22:49:33 <jle`> jusss``: MonadIO is being able to 'embed' IO actions into your monadic actions, IO a -> M a.
22:49:41 <jle`> there isn't any deeper meaning than that
22:50:13 <jusss``> jle`: monad actions are not function, what about Functor and Applicative?
22:50:22 <jle`> what about them?
22:50:43 <jusss``> jle`: is there Functor action or Applicative action?
22:51:39 <jle`> sometimes people call values of 'f a', where f is a functor, a functorial action. same for applicative
22:52:03 <jle`> but it's not really anything formal, it's just to aid discussion
22:52:39 <jle`> so an `IO Int` is an IO action. it's monadic, functorial, applicative, monadio-ic, etc.
22:52:48 <jusss``> jle`: Functor and Applicative have laws?
22:52:55 <jle`> i know one way to find out :)
22:54:00 <jle`> hint: it utilizes a web browser
23:01:39 <jusss``> jle`: those concepts really make me confused ... 
23:02:05 <jle`> that's ok :) familiarity and practice is what helps lower the confusion over time
23:02:13 <jusss``> it takes lots of time to build the intutive...
23:02:28 <jle`> all the time won't do anything unless you are writing programs using these abstractions
23:02:36 <jle`> so time can help, but practice is necessary
23:02:54 <jusss``> jle`: it's weird that it takes lots of time to understand concepts not to code
23:03:09 <jle`> you might be looking at it backwards
23:03:15 <jle`> writing the code is how you understand the concepts
23:03:18 <jle`> not the other way around
23:03:23 <jusss``> yeah
23:03:30 <jle`> so write the code, and the concepts will come to you after
23:03:41 <jle`> you won't even have to try  :)
23:03:53 <jusss``> jle`: but if I don't understand monad, how I can code about ti
23:04:12 <jle`> sounds like it would be hard, right?
23:04:14 <jle`> turns out, it isn't
23:04:30 <jle`> writing code using monads, day to day, requires understanding nothing about monads as an abstraction
23:04:46 <jle`> that's the beauty of it
23:04:57 <monochrom> It's true of everything.
23:04:57 <jle`> you can write code using the monad instance of Maybe, without ever understanding monads as an abstraction
23:05:09 <jusss``> jle`: but then I never would know about `return' is the unit,
23:05:21 <jle`> yes, so many things you will never know
23:05:22 <monochrom> No one says "I don't understand rings, so how can I do plus and times?"
23:05:36 <jle`> but so many things you will end up accomplishing
23:05:44 <monochrom> In fact it's the other way round. You do plus and times for a long time, then you're ready to learn ring theory.
23:06:21 <monochrom> Similarly for Chess. Similarly for natural languages. I can go on and on.
23:06:24 <jle`> jusss``: imagine something building a useful haskell application, without ever knowing 'return is the unit'
23:06:26 <jle`> the nerve of them!
23:06:28 <jle`> how dare they
23:06:31 <purelazy> You learn before you understand how muscles work
23:06:42 <jle`> how dare they ... not know this, and still make useful things, that don't require knowing it
23:06:50 <purelazy> You do walk before you understand how muscles work
23:06:57 <monochrom> When you were a child you didn't ask your parent to "explain English to me first" or whatever your mother tongue it was.
23:07:03 <purelazy> I think that is the point here
23:07:25 <jusss``> yes, you all are right
23:07:46 <jle`> it's like wondering how you can write a song without memorizing all the cadences, modes, extensions, etc. of music theory
23:07:48 <purelazy> If you can read and print using do, that is enough for the first year
23:08:07 <jle`> "you wrote a song? psh. did you even know about the locrian mode."
23:08:36 <purelazy> And you can concentrate on more important things
23:09:16 <jle`> knowing the 'essense of a monad' is maybe something fun to learn for no purpose at all, but using monads day to day requires none of that
23:10:42 <jusss``> jle`: now I meet a typeclass, I ask three questions, laws, functions and used for
23:10:56 <jusss``> or about
23:11:20 <jusss``> maybe I should append the kind
23:11:25 <jle`> the thing is that, what a typeclass is 'used for' is often not that useful
23:11:36 <jle`> that a *type* is used for -- that's definitely very useful
23:11:43 <jle`> learn what Maybe is used for. what IO is used for
23:11:45 <jusss``> jle`: but that `used for' is we really use it to do
23:12:16 <jle`> right, but when do you actually 'use' a typeclass?
23:12:18 <jle`> usually you're using the types
23:12:25 <jle`> not the 'typeclass' as an abstraction
23:12:49 <jle`> 90% of the time you use >>=, <$>, etc., you're using specific types. you're not using Monad the abstraction, Functor the abstraction, etc.
23:13:03 <jle`> so it doesn't matter what Monad is used for. it matters what the specific type you are using is used for
23:13:13 <jusss``> jle`: yeah, the typeclass's laws and implented functions, and the type instances of it, the type is used for, or about ?
23:13:38 <jle`> learning about laws and methods of a typeclass and what they 'mean' in the abstract sense is usually not very useful
23:13:48 <jusss``> jle`: wait a sec, typeclass is not type, typeclass don't have kind?
23:13:59 <jle`> well, it can be in some situations. but it's never going to be the first thing you learn.
23:14:19 <jle`> typeclasses have a kind with -XConstraintKinds, they are k -> Constraint. but that's not too important here
23:15:09 <nshepperd> the term 'monad action' is kind of 
23:15:49 <jusss``> jle`: so now we have type and typeclass two stuff, and they both have kind, and types are instances of typeclass
23:17:39 <jusss``> Semigroup, Monoid, Functor, Applicative, Monad, MonadIO, MonadTrans, those seven all are typeclass, and MonadTrans has kind (*->*) -> (*->*), the others have kind (*->*), some instances of Monad are also instances of MonadIO too, but some aren't
23:18:09 <jle`> instances of MonadTrans ahve kind (*->*) -> (*->*), ec., yeah
23:18:19 <jle`> Semigroup, Monoid instances are *
23:19:01 <jusss``> jle`: what?
23:19:22 <jusss``> jle`: <jle`> Semigroup, Monoid instances are *
23:19:32 <jusss``> * is a type now?
23:19:40 <jusss``> or it means any type
23:20:23 <jle`> it means things of kind *
23:20:29 <jle`> like Int, Bool, String, Double
23:20:38 <jle`> but not Maybe, IO, Either, MaybeT
23:20:53 <jle`> :k Int
23:20:54 <lambdabot> *
23:21:01 <jusss``> :k (Int -> Int)
23:21:02 <lambdabot> *
23:21:36 <jusss``> jle`: so (Int -> Int) is an instance of Semigroup and Monoid?
23:21:47 <jle`> it could be if someone wrote an instance for it
23:21:50 <dansho> i asked this on #machinelearning but didn't get a response: if i have a character-level RNN that is converging only to the relative frequency of each character, what might be wrong with the model?
23:22:00 <jle`> but in base, nobody has written an instance
23:22:06 <jle`> just like how there is no Show instance for it either
23:22:09 <dansho> code using backprop here: https://hastebin.com/vebuzabebe.haskell
23:22:27 <jusss``> jle`: except those seven typeclass, is there any other special typeclass?
23:22:34 <jle`> jusss``: none of those typeclasses are special
23:22:59 <jusss``> jle`: those seven may have connections
23:23:00 <jle`> dansho: the connection between each time step might be too weak
23:23:17 <jle`> dansho: or maybe you aren't unrolling
23:23:46 <jle`> or well, unrolling enough steps
23:24:10 <jle`> if you unroll 0 steps you get relative frequency, if you unroll 1 step you get something like a bigram markov model
23:24:34 <jle`> dansho: try testing your unrolling function on something like a sine wave
23:26:16 <dansho> jle`: should i be backpropagating at each length of unroll? 'h', 'he', 'hel', 'hell', 'hello'. right now i think i only compute gradient on the full sequence 'hello'
23:27:18 <jle`> usually you unroll a fixed amount and train on that unrolled model
23:28:08 <jle`> i talk about the semantics of unrolling and how you would train on an unrolled model here https://blog.jle.im/entry/purely-functional-typed-models-2.html
23:28:48 <jle`> there's also a full optimizer/trainer implemented there if you want to see what it is exactly to optimize/train on
23:29:15 <dansho> thanks, i have read those articles but i had a hard time implementing the functional models so i went back to the data style model
23:30:57 <samtor> people say that monad is a monoid in the category of endofunctors
23:31:11 <jle`> the main high-level thing is that you can't really use SGD to optimize an time-series model directly, so you have to turn your time series model into a normal input-output model. so you transform your (S x A) -> (S x B) model into a A^n -> B^n model, or A^n -> B model
23:31:17 <samtor> why isn't monoid a superclass of monad in haskell?
23:31:19 <jle`> that transform is known as unrolling
23:31:30 <jle`> samtor: two issues -- first, they're the wrong kind
23:31:40 <jle`> samtor: second, monads aren't the *only* monoid in the category of endofunctors
23:31:44 <jle`> there are many others
23:32:15 <jle`> so you could say that even if we wanted to unite the Monoid typeclass with Monad somehow, we'd run into the same problem as Sum/Product for Monoid Int
23:33:49 <dansho> the actual unrolled/destated function that i train on has signature: BVar s Rnn -> BVar s [R Dimension] -> BVar s [R Dimension]
23:34:16 <jle`> dansho: that that looks reasonable
23:36:17 <jle`> if your network is converging on just a frequency map, i would probably isolate/debug the unrolling part first, then maybe next how you are generating the samples you are feeding to the unrolling part
23:36:24 <jle`> feeding to the training part
23:36:36 <jle`> and then also the architecture of your model: how the previous state feeds into the next prediction, etc.
23:37:09 <jle`> for a one-hot vector model, maybe train it on something that is going 0-1-2-3-4-5-4-3-2-1-0-1-2-3-4- .. etc.
23:37:21 <dansho> computing the error part i am less confident on, i was kind of guessing on this: https://hastebin.com/qituyufexu
23:37:43 <jle`> if it's converging on a frequency map then i am guessing the error function isn't the problem
23:38:40 <dminuoso> samtor: Are you familiar with what a monoid is?
23:38:43 <jle`> if your error function was bad then you wouldn't even be converging on a frequency map, i think
23:39:41 <jle`> dansho: but, something fishy, it looks like you are taking the log recip?
23:39:51 <jle`> here is how i do it myself
23:39:53 <jle`> https://mstksg.github.io/backprop-learn/src/Backprop.Learn.Loss.html#crossEntropy
23:44:42 * hackage advent-of-code-api 0.2.0.0 - Advent of Code REST API bindings and servant API  https://hackage.haskell.org/package/advent-of-code-api-0.2.0.0 (jle)
23:44:59 <dansho> oh thanks for pointing that out, it converges to [0,0,1,0,0] for each input if i change that, i'll have to play around some more
23:45:41 <dansho> jle`: one problem i had when debugging was i couldn't figure out how to use traceShow in a function over BVars, is it possible to trace intermediate results like this?
23:46:52 <jle`> ah that would be useful
23:47:03 <jle`> right now you can simulate it by writing a tracing BVar function maybe
23:47:42 <jle`> isoVar traceShowId id
23:47:51 <jle`>  :: Show a => BVar s a -> BVar s a
23:48:39 <dansho> thanks i'll try that out
23:49:45 <jle`> but yeah it probably wouldn't hurt to give an unsafe Show instance for BVar
23:51:35 <jle`> i guess it depends on what you want to do with it, and when you want tracing to happen
23:51:56 <jle`> for isoVar traceShowId traceShowId, the firs trace would happen on the forward pass, and the second one on the backwards pass.  the second one would output the gradients
23:58:25 <glguy> Getting ready for aoc already?
