00:00:02 <dsal> Every time I sit down to try polysemy, I end up... not doing that.
00:00:10 <jle`> for all its shortcomings, mtl is still the industry-tried and tested so far
00:00:40 <maerwald> dsal: but higher order effects are awesome. It just seems the underlying semantics are not as well defined as they should be
00:01:34 <maerwald> And that should make you think twice before using it in production 
00:02:02 <dsal> All of my code is a lot of threads doing different things.  Just getting the transformers in place is already kind of annoying.
00:02:21 <dsal> I'm running two loggers in this code right now because I don't know how to run one yet.
00:03:31 <dsal> But I can honk my car's horn from the commandline, and that's all that really matters.
00:03:42 <libertyprime> Another noobie question: I have a hole in my code which is IO String -> IO String. I would like to use a String -> String function there. What can I do about this?
00:04:25 <jle`> libertyprime: you can use fmap :: (a -> b) -> IO a -> IO b
00:04:34 <koz_> (among other things)
00:04:43 <jle`> or (a -> b) -> (IO a -> IO b)
00:04:46 <koz_> dsal: Something something Car Monad.
00:04:52 <libertyprime> ok thanks !
00:05:03 <jle`> fmap is like a fundamental tool for turning 'pure' functions into IO functions
00:05:17 <jle`> libertyprime: for IO it basically maps the function over the result, while leaving the effects unchanged
00:05:35 <koz_> jle`: Is this where I make a 'bro do u even lift' joke? :P
00:06:07 <libertyprime> haha
00:06:32 <jle`> so much of writing haskell is just lifting D:
00:06:51 <koz_> All we ever do in Haskell is lift.
00:07:02 <koz_> fmap is a lift, pure is a lift, lift ... is a lift.
00:08:12 <lisprez[m]> type wrapper
00:08:31 <lisprez[m]> all the job done in haskell is type wrapping
00:09:15 <koz_> dsal: replicateM 1000 honkHorn -- annoy the neighbours
00:11:14 <ChaiTRex> We need a Goose monad with a honk action.
00:11:15 <koz_> forever honkHorn -- even better
00:15:30 <Pamelloe1> I have a type data Gradients :: [*] -> *. Can I create an type class instance for Gradients provided that every type in the list has the instance?
00:15:54 <jle`> Pamelloe1: the basic way to do it is to write your instances inductively
00:16:15 <jle`> Pamelloe1: like an instance for Gradients '[], and MyClass (Gradients as) => MyClass (Gradients (a ': as))
00:16:42 <jle`> it's not my favorite way but it is the one that works in every situation, without knowing more about the class or the data type
00:17:00 <koz_> I echo jle`'s suggestion here - it's also what Sandy's book recommends.
00:17:27 <Pamelloe1> Great! That'll definitely get the job done :)
00:17:42 <jle`> but if you have more information i think there are better ways
00:17:48 <jle`> this is a last-resort sort of thing for me
00:18:01 <jle`> because it makes typeclass constraints a little uglier imo
00:18:42 <Pamelloe1> What kind of other information would you like?
00:19:20 <jle`> what the type is, what the class is, etc.
00:19:24 <jle`> just specifics, i mean
00:19:44 <jle`> i like to be able to define an instance for ConstraintsOn as => MyClass (Gradients as) all at once, if possible
00:20:00 <jle`> because then if you want to use a methd of MyClass for (Gradients as), you can only require ConstraintsOn as
00:20:24 <jle`> and ConstraintsOn as might satisfy a lot more typeclasses than just MyClass
00:20:36 <libertyprime> GUYS! http://ix.io/23am I lifted for the first time
00:20:44 <Pamelloe1> The typeclass is AdditiveGroup/VectorSpace from the vector-space package
00:20:57 <jle`> so for example instead of (Class1 (Gradient as), Class2 (Gradient as), Class3 (Gradient as)) => ...
00:21:05 <jle`> you could instead write FooClass as => ...
00:21:08 <jle`> and get the same info
00:21:39 <koz_> libertyprime: Congratulations, you now lift.
00:21:52 <jle`> if you can have some constraint on 'as' be usable to define wholesale instances for Class1 (Gradient as) etc,. then things get much cleaner
00:21:58 <jle`> than if you just defined those classes inductively
00:22:03 <jle`> Pamelloe1: what is Gradient, then?
00:22:30 <Pamelloe1> jle`: http://hackage.haskell.org/package/grenade-0.1.0/docs/Grenade-Core-Network.html#t:Gradients
00:23:41 <Pamelloe1> jle`: Also, I was reading through your singletons blog posts earlier today, and they were excellent! Thanks for publishing such informative and well-written articles :)
00:24:06 <jle`> ah, no problem! glad it was helpful
00:24:20 <jle`> you can probably write an instance of Additive by just asking for SingI as
00:24:34 <jle`> instance SingI as => AdditiveGroup (Gradient as), maybe
00:24:53 <jle`> but probably if this is a new thing for you, it might be simpler to just start with the explicit induction case
00:25:57 <Pamelloe1> What does the SingI as constraint accomplish there?
00:26:22 <jle`> hm, i'm not sure if you actually need it, depending on what AdditiveGroup is
00:26:29 <jle`> but SingI allows you to "generate" a shape 'as'
00:26:35 <jle`> without SingI you can only consume 'as'
00:27:28 <jle`> but i'm sure exactly what is in AdditiveGroup so it may not be necessary, or it may not be sufficient either
00:27:45 <jle`> also it's kind of weird because it requires Typeable on all of the items in the list so it might not be feasible/usable
00:28:02 <jle`> finding a general constraint on 'as' can be tricky :) so writing the inductive class is always simpler/always possible
00:28:19 <jle`> s/always simpler/always more straightforward
00:29:30 <Pamelloe1> I think I'll probably just do the inductive case for today, and leave the direct implementation as an exercise for future generations :)
00:30:02 <koz_> Pamelloe1: That's a sensible choice.
00:57:24 <libertyprime> hey guys. how do i print the environment variables from ghci?
00:58:04 <libertyprime> createProcess is not finding my scripts
00:58:05 <libertyprime> http://ix.io/23az
00:59:25 <libertyprime> all good. worked it out, sorry
00:59:32 <libertyprime> https://stackoverflow.com/questions/50501241/how-to-pass-environment-variables-into-haskell-programs-run-via-stack
00:59:47 <iqubic> So I have this:
01:00:00 <iqubic> manhatten x y = sum $ zipWith (\x0 x1 -> abs $ x0 - x1) x y
01:00:10 <iqubic> I can't figure out how to make it pointfree.
01:00:32 <iqubic> @pl \ x y -> sum $ zipWith (\x0 x1 -> abs $ x0 - x1) x y
01:00:32 <lambdabot> (sum .) . zipWith ((abs .) . (-))
01:00:45 <iqubic> Oh hell. Not what I wanted.
01:05:22 <jle`> any point-free version is definitely going to be unreadable
01:05:48 <jle`> without some fancy nonstandard combinators
01:06:25 <iqubic> I'm just working on beefing up my AoC toolkit right now.
01:06:58 <internauta> cc
01:07:34 <internauta> cc
01:58:22 <libertyprime> Hey guys. Would anyone be able to please show me how to chain the stdout of a createProcess to the stdin of another createProcess? https://lotz84.github.io/haskellbyexample/ex/spawning-processes
01:58:46 <libertyprime> I think I need to do the opposite of lift...
01:59:03 <libertyprime> but I've been told this is not possible. The way is to lift the environment
01:59:09 <libertyprime> This is the way
02:00:38 <merijn> libertyprime: You need to feed the returned stdout handle if your first process as stdin handle for your second process
02:01:17 <libertyprime> merjin: that makes a lot of sense. thanks
02:01:19 <merijn> libertyprime: Which you can do by using https://hackage.haskell.org/package/process-1.6.7.0/docs/System-Process.html#t:StdStream
02:01:49 <merijn> libertyprime: So instead of CreatePipe for the stdin of the second one, just use UseHandle with the stdout of the first one
02:28:11 <nil> iqubic: it might be more readable using  (.:) = (.) . (.)  :
02:28:20 <nil> manhattan = sum .: zipWith (abs .: (-))
02:30:49 <iqubic> I'm not sure it is.
02:30:58 <iqubic> But either way, I'm keeping it the way it is.
02:31:26 <iqubic> Or rather, I changed the way I'd doing this so that I no longer have that function in that form.
02:32:47 <kuribas> what's a good parser for html?
02:35:35 <kuribas> tagsoup seems to allow parsing invalid html
02:35:49 <kuribas> or at least valid html with unbalanced tags
02:37:58 <kuribas> maybe better to use xml...
02:40:26 <kuribas> ah, Text.HTML.TagSoup.Tree may do...
02:50:39 <merijn> kuribas: html-conduit worked fairly well for scraping when I tried
02:51:15 <kuribas> merijn: I am not scraping, I am parsing a document, then generating another one based on it.
02:51:44 <kuribas> taggy looks interesting... It also works with blaze...
02:51:46 <iqubic> Maybe try pandoc then?
02:52:20 <kuribas> iqubic: I need to be able to take the html literally
02:56:06 <libertyprime> merijn: ChaiTRex: greymalkin: jle`: koz_: Thanks! I feel like I have made huge strides in my learning today.
03:30:33 <kuribas> I really wonder if using composition is so much better than just pass a parameter...
03:30:44 <kuribas> for example: markSeen attr = modify (HashSet.insert attr)
03:30:58 <kuribas> versus: markSeen = modify . HashSet.insert
03:31:02 <kuribas> is the second really more readable?
03:31:06 <merijn> kuribas: "It Depends (TM)"
03:31:15 <merijn> kuribas: I find them about equal, tbh
03:31:32 <kuribas> composition is nice in HOFs
03:31:32 <merijn> But with the 2nd I'm not forced to come up with a good name if I don't have one
03:32:06 <kuribas> merijn: so not using composition forces you to give good names, which is a good thing.
03:32:22 <merijn> kuribas: No, it just forces me to give names
03:32:32 <aveltras> any idea what could cause the following error with ghcide in a nix project "Step 4/6, Cradle 1/1: Loading GHC Session
03:32:32 <aveltras> ghcide: <command line>: can't load .so/.DLL for: /nix/store/q6p9ph6wigww9q0386rdsn3i17q0j8xx-ghc-8.6.5/lib/ghc-8.6.5/binary-0.8.6.0/libHSbinary-0.8.6.0-ghc8.6.5.so (/nix/store/q6p9ph6wigww9q0386rdsn3i17q0j8xx-ghc-8.6.5/lib/ghc-8.6.5/binary-0.8.6.0/libHSbinary-0.8.6.0-ghc8.6.5.so: undefined symbol: base_DataziTypeableziInternal_typeRepKind1_closure)" ?
03:32:32 <merijn> Nothing can force people to give good names :)
03:33:09 <merijn> aveltras: It's trying to link a library that is, well, missing bits
03:33:28 <merijn> aveltras: So the question is "Why is the library missing bits?" and that's hard to answer
03:34:59 <kuribas> is there a shortcut for mconcat <$> traverse ...
03:35:05 <aveltras> i see, guess i'm back to bare ghcid for now
03:35:24 <merijn> kuribas: foldMap?
03:35:37 <merijn> Ah, not quite
03:35:43 <merijn> I guess you'd want like foldMapM
03:35:49 <kuribas> merijn: yeah :)
03:36:01 <merijn> kuribas: You could use Ap?
03:36:08 <kuribas> :t Ap
03:36:10 <lambdabot> forall k (f :: k -> *) (a :: k). f a -> Ap f a
03:36:19 <merijn> That lifts Monoid through an Applicative
03:37:14 <kuribas> maybe...
03:37:19 <kuribas> not sure if it's shorter though
03:38:08 <merijn> kuribas: Which Monad/Applicative?
03:38:36 <kuribas> merijn: My own stack
03:38:51 <merijn> kuribas: Can't you just define a Monoid instance for it?
03:38:52 <kuribas> on top of Blaze Markup
03:39:34 <merijn> kuribas: There's no general instance for all Monads, because it overlaps too many things, but any Applicative can be trivially made a monoid instance with the semantics you want
03:39:48 <kuribas> merijn: In that case I'd use Ap
03:40:35 <merijn> kuribas: If you use "mconcat <$> traverse" enough that you need a shortcut, then defining the instance once will save you considerable effort :p
03:41:26 <kuribas> nah, only once
03:42:53 <kuribas> it's not that bad
03:43:03 <kuribas> I just thought I might have missed something
04:10:12 <tom_> Is there any way of classifying the similarity of types according to how "similar" the valies each set holds?
04:10:19 <tom_> *values
04:10:56 <Athas> tom_: not in any useful way I think.  This sounds like an exotic task.  What are you trying to do?
04:11:15 <tom_> Could you do it with the name of constructors?
04:11:42 <Athas> Given two (finite) types, you could do something like take all possible values of each type, prettyprint each of them, then match them up to minimise the Levenshtein editing distance between values.
04:11:45 <tom_> I am trying to create a fitness function for evaluating how closely a typed AST matches a spec
04:12:29 <tom_> Yeah that is a good idea
04:12:43 <tom_> I gues it depends on what I mean by *mean*
04:13:09 <tom_> The goal for this toy project is some simple program synthesis
04:13:31 <tom_> I just thought typed ASTs, genetic algorithms and Singletons could be an avenue
04:14:32 <tom_> Am I barking up the wrong tree
04:38:08 * hackage tmp-postgres 1.27.0.1 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.27.0.1 (JonathanFischoff)
04:41:09 * hackage tmp-postgres 1.27.0.2 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.27.0.2 (JonathanFischoff)
05:03:39 * hackage hedgehog-golden 0.6.0 - Golden testing capabilities for hedgehog using Aeson  https://hackage.haskell.org/package/hedgehog-golden-0.6.0 (felixmulder)
05:39:09 * hackage language-c99 0.1.2 - An implementation of the C99 AST that strictly follows thestandard.  https://hackage.haskell.org/package/language-c99-0.1.2 (frankdedden)
05:44:15 <Zork> #haskell
05:44:44 <ChaiTRex> Hello, Zork. May your day be grue-free.
05:45:24 <Zork> Tks
06:21:09 <f8e3> to get a functional programming style pov, should i use C or haskell, is C OO?
06:21:19 <f8e3> https://www.youtube.com/watch?v=re96UgMk6GQ
06:22:36 <ChaiTRex> f8e3: Haskell. C doesn't do functional programming that well.
06:22:45 <ChaiTRex> f8e3: C doesn't do OOP that well either.
06:22:56 <ChaiTRex> f8e3: C's more a procedural programming language.
06:24:38 <f8e3> ChaiTRex how to get a clear definition of imp, func, oo, proced?
06:25:23 <f8e3> also overview great here: https://www.levenez.com/lang/lang.pdf
06:26:05 <ChaiTRex> f8e3: That's somewhat difficult. For example, there are two major kinds of OOP: Smalltalk style and Java/C++ style.
06:27:34 <ChaiTRex> f8e3: Smalltalk style has you thinking of objects as these things that can pass messages to each other. Java/C++ style is like procedural where you group the procedures into classes and then make instances of classes.
06:28:26 <maerwald> the former is great
06:36:33 <f8e3> why is hakell 150k loc yacc?
06:44:17 <f8e3> ok, great link talk, yay
06:49:31 <int-e> f8e3: where does that number come from?
06:50:11 <int-e> ghc's Parser.y is 4k loc, for example.
06:50:49 <int-e> (but it's happy, not yacc)
06:54:42 <ggole> A 150k loc parser would be quite something. Ruby's parse.y is gargantuan, and it's only about a tenth of that.
06:56:19 <int-e> but a yacc file may contain anything between a bare parser and a full compiler
06:56:38 <int-e> so 150k isn't outrageous if it's the latter.
06:57:07 <merijn> hmmm, so what's the simplest way of taking a string like "2019-11-30 14:50:00" to UTCTime?
06:58:02 <int-e> . o O ( unsafeCoerce )
06:58:26 <hpc> haha
06:58:43 <hpc> merijn: https://hackage.haskell.org/package/time-1.9.3/docs/Data-Time-Format-Internal.html#t:ParseTime
06:59:02 <merijn> hpc: Yeah, but I didn't wanna figure that out :<
06:59:08 <int-e> read "2019-11-30 14:50:00" :: UTCTime  works?
06:59:36 <hpc> hmm yeah, that interface is pretty crap
06:59:44 <merijn> int-e: No
07:00:26 <hpc> ah, https://hackage.haskell.org/package/time-1.9.3/docs/Data-Time-Format-ISO8601.html might be easier
07:01:09 <hpc> hmm no, that's kind of a pain to construct the Format value
07:01:35 <int-e> Prelude Data.Time> read "2019-11-30 14:50:00" :: UTCTime
07:01:35 <int-e> 2019-11-30 14:50:00 UTC
07:01:45 <hpc> aha, https://hackage.haskell.org/package/time-1.9.3/docs/Data-Time-Format.html#v:parseTimeM
07:01:52 <merijn> int-e: I get no parse
07:01:52 * int-e shrugs.
07:02:22 <merijn> int-e: Which version of time?
07:02:38 <int-e> Oh maybe it's relying on some C library support? It's tyime-1.8.0.2
07:02:39 <hpc> merijn: parseTimeM should be super easy to use
07:03:03 <merijn> hpc: That doesn't parse either, though
07:03:18 <merijn> iso8601ParseM "2019-11-30 14:50:00" :: Maybe UTCTime
07:03:22 <merijn> That produces Nothing
07:04:55 <hpc> merijn: use parseTimeM
07:04:55 <hpc> Prelude Data.Time.Format Data.Time.Clock> parseTimeM True defaultTimeLocale "%Y-%-m-%-d %T" "2019-11-30 14:50:00" :: Maybe UTCTime
07:04:58 <hpc> Just 2019-11-30 14:50:00 UTC
07:05:40 <int-e> 'parsing: reject invalid (and empty) time-zones with %z and %Z' .. maybe that's why `read` fails now.
07:05:59 <hpc> there's probably a cleaner format string, i just adapted the docs' example
07:06:22 <merijn> hpc: I was thinking of that but defaultTimeLocale has a super confusing documentation
07:06:29 <int-e> merijn: so this still works: read "2019-11-30 14:50:00 UTC" :: UTCTime
07:08:12 <hpc> does the locale matter?
07:08:18 <hpc> for your use case?
07:08:26 <merijn> There is no locale, it's UTC
07:08:50 <merijn> I just don't understand what the defaultTimeLocale docs are saying and I hate using things I don't understand >.>
07:09:31 <hpc> ah
07:09:40 <hpc> the locale isn't for picking a time zone or anything like that
07:09:53 <hpc> it's for how to represent the time
07:10:05 <hpc> or how to translate it
07:10:42 <hpc> it's not concerned about things like "i am on the east coast so infer -400" or whatever
07:11:01 <hpc> it's more like "i am in germany so it should be spelled dienstag"
07:11:35 <hpc> you can tell by the parameters to the TimeLocale data constructor
07:12:46 <hpc> it's definitely poorly explained in words though
07:21:41 <Athas> Sooo... what's the nice way of writing a floating-point infinity in a program?  1/0 works, but feels dumb.
07:22:03 <merijn> Athas: It's that, or make a pattern synonym for it
07:22:31 <Athas> Seems like a strange oversight.  I sometimes get the feeling the Haskell 98 authors wanted to forget about IEEE floating point.
07:28:34 <hpc> everyone wants to forget about IEEE floating point
07:28:59 <hpc> even the chip designers - floating point math used to be done on a coprocessor
08:13:58 <Zemyla> There should be a newtype wrapper around Float and Double with sensible Eq and Ord instances.
08:14:53 <Zemyla> NaN < -Inf < -finite numbers < -0 < +0 < finite numbers < +Inf.
08:16:01 <geekosaur> but then you get to figure out how to make Enum match
08:23:39 <geekosaur> next thing you know you're hip deep in a reimplementation of numeric-prelude :)
08:23:48 <Zemyla> The Float and Double instances for Enum really aren't sensible, don't obey laws, and are just put there for syntactic sugar, so people can go [0.0, 0.1.. 1.0].
08:24:19 <Zemyla> The wrappers don't need to go into base, but they do need to go into containers, so that you can make sensible Float and Double Sets and Maps.
08:53:11 <OmegaDoug> Does HSpec have anything like HUnit Approx: http://hackage.haskell.org/package/HUnit-approx-1.1.1.1/docs/Test-HUnit-Approx.html
08:53:57 <[itchyjunk]> foldr (+) 0 [1..12] gives me the sum of first 12 natural numbers right? :s
08:54:00 <OmegaDoug> I want to test the return type of Doubles and I'm getting rounding differences, 1.6666666666666667 vs 1.6666666666666665
08:54:00 <[itchyjunk]> right right, nm
08:59:39 <monochrom> The first 13 natural numbers.
09:02:08 * hackage ats-format 0.2.0.36 - A source-code formatter for ATS  https://hackage.haskell.org/package/ats-format-0.2.0.36 (vmchale)
09:06:35 <higherorder> Hello; what's the best practice to read *and write* files when running tests (with stack). E.g. I would like some of my tests to be able to write "snapshot" files in the test's source directory
09:07:32 <merijn> higherorder: So golden tests?
09:07:47 <merijn> Tasty has tasty-golden for those, and presumably so do other testing frameworks
09:11:34 <higherorder> merijn: yes! though from what I can tell with the way tasty-golden is implemented paths to snapshots are relative to the directory in which you run `stack test`?
09:12:06 <merijn> No idea, I don't use stack
09:13:48 <higherorder> merijn: I see. Well either way, I assume that since Haskell is compiled there is no direct way to have a test write a file in the same directory as the test's source file? be it stack, cabal, whatever
09:15:49 <phadej> stack test / cabal test run test programs from the package's local directory
09:18:34 <higherorder> phadej: ah, thanks, so I should be able to read file relative to that; I'll try, ty
09:33:17 <nig> umm... hey?
09:35:05 <djanatyn> I'm using a simple Data.Text newtype as a phantom type parameter with DataKinds: `newtype Module = Module Text deriving (Eq, Show); shell :: Text -> AnsibleCmd ('Module "shell")`
09:35:32 <djanatyn> that doesn't work: Expected kind ‘Text’, but ‘"shell"’ has kind ‘ghc-prim-0.5.3:GHC.Types.Symbol’
09:36:18 <djanatyn> is there a way to either do something like OverloadedStrings with data kind promotion, or do I need to change my type to String? don't think i can use "Text.pack" in a type signature yet :)
09:40:08 <c_wraith> the big problem is that Symbol is the only promoted string-like type
10:10:08 * hackage sgd 0.2.3 - Stochastic gradient descent  https://hackage.haskell.org/package/sgd-0.2.3 (JakubWaszczuk)
10:23:19 <fresheyeball> so mapConcurrently dies if you map over something too large
10:23:29 <fresheyeball> is there an alterative that lets me set a threadpool size?
10:23:39 <merijn> fresheyeball: Yes
10:23:49 <merijn> fresheyeball: My library :p
10:23:57 <fresheyeball> merijn: hook me up yo
10:24:02 <fresheyeball> I need my threads managed
10:24:11 <merijn> fresheyeball: https://hackage.haskell.org/package/broadcast-chan-0.2.1/docs/BroadcastChan.html#v:parMapM_
10:24:18 <merijn> fresheyeball: And friends
10:24:35 <merijn> I've also got one that you can slot into a conduit pipeline
10:24:48 <merijn> So you can parallelise a stage of your conduit
10:25:39 * hackage polysoup 0.2.1 - Online XML parsing with polyparse and tagsoup  https://hackage.haskell.org/package/polysoup-0.2.1 (JakubWaszczuk)
10:33:54 <fresheyeball> merijn: your lib looks great
10:34:01 <fresheyeball> but I went with a lazier approach for this
10:36:35 <merijn> fresheyeball: I basically kept needing a somewhat better controlled/limited thread-pooly thing over and over and I got sick of having half-tested broken implementations everywhere, so I figured I'd just solve it once and for all :p
10:36:50 <fresheyeball> merijn: love it
10:37:12 <merijn> fresheyeball: The conduit one is actually super nice, since it means you can just stick a slow IO action in your pipeline and magically speed it up by running it in parallel :p
10:37:50 <fresheyeball> merijn: have you seen streamly?
10:38:19 <merijn> I've heard of it, but haven't looked into it, because all my dependencies use conduit
10:38:28 <fresheyeball> merijn: I like it much better
10:41:55 <merijn> Giving a quick look at streamly it looks considerably more complicated than conduit, despite its claim of being simpler >.>
10:42:09 <fresheyeball> merijn: I think that claim is justified
10:42:24 <fresheyeball> and for concurrency it's pretty amazing
10:48:09 * hackage polysoup 0.2.2 - Online XML parsing with polyparse and tagsoup  https://hackage.haskell.org/package/polysoup-0.2.2 (JakubWaszczuk)
11:15:47 <[itchyjunk]> :< i want to do the following sum 1^2 + .. + 12^2. foldr (+) 0 [1..12] would give me 1+..+12. I would want toerr
11:18:06 <merijn> [itchyjunk]: Just map (^2) before summing?
11:18:38 <[itchyjunk]> oh map! right
11:18:39 * hackage hackage-repo-tool 0.1.1.2 - Manage secure file-based package repositories  https://hackage.haskell.org/package/hackage-repo-tool-0.1.1.2 (HerbertValerioRiedel)
11:20:31 <[itchyjunk]> map (^2) [1,2] would return [1,4] and i would want to foldr that with a +
11:20:51 <[itchyjunk]> so foldr (+) 0 (map (^2) [1,2]) ?
11:21:25 <[itchyjunk]> oh nm it does work
11:21:51 <[itchyjunk]> ah sweet!
11:21:55 <[itchyjunk]> thanks o/
11:26:21 <phadej> 13^2-1
11:26:24 <phadej> > 13^2-1
11:26:28 <lambdabot>  168
11:26:36 <Nolrai> Hey, so anyone willing to help me figure out what data structure I need? I am trying to make an DSPL for representing reversible boolean circuits (not for any good reason, just because I can), and my brain just starts hurting when it tries to figure out how represent 'rectangle diagrams' which I think is the right level of abstraction.
11:26:41 <phadej> > foldr (+) 0 (map (^2) [1..12])
11:26:43 <lambdabot>  650
11:26:56 <phadej> hmm
11:27:47 <int-e> > 12*(12*2+1)*13 `div` 6
11:27:50 <lambdabot>  650
11:28:12 <int-e> :t sum
11:28:14 <lambdabot> (Foldable t, Num a) => t a -> a
11:28:55 <Nolrai> I could also just stick with an expresion tree, but that would be really hard to work with when 'compileing'.
11:29:53 <Nolrai> Maybe what I actually want is a version of the little circles operad? Which I also have no idea how to represent?
11:30:55 <Nolrai> > foldr (+) 0 (map (^2) [1..2])
11:30:58 <lambdabot>  5
11:31:08 <Nolrai> > foldr (+) 0 (map (^2) [0..2])
11:31:10 <lambdabot>  5
11:31:33 <Nolrai> > foldr (+) 0 (map (2^) [0..2])
11:31:36 <lambdabot>  7
11:31:46 <Nolrai> Okay, thats what was going on.
11:32:14 <[itchyjunk]> what?
11:32:24 <[itchyjunk]> why is it saying 7?
11:32:42 <[itchyjunk]> oh
11:32:45 <[itchyjunk]> damn
11:32:47 <Nolrai> Because 7 is 2^3 - 1?
11:33:32 <m1cl> > 3 +3
11:33:36 <lambdabot>  6
11:34:56 <Nolrai> No I do want to divide conections into the left side and the right side, because I have _two_ ways of bending a wire.
11:35:09 <phadej> is there any common name for "fixed-width integers", other than "fixed-width integer"?
11:36:32 <Nolrai> "word" sort of.
11:37:20 <Nolrai> I mean its the default for most languages.
11:37:22 <jle`> [itchyjunk]: note if you want a fun trip, foldr f z . map g = foldr (f . g) z
11:37:39 * hackage monad-codec 0.2.1 - Monadic conversion between complex data structures and unique integers  https://hackage.haskell.org/package/monad-codec-0.2.1 (JakubWaszczuk)
11:38:34 <[itchyjunk]> ;_;
11:46:33 <jle`> understanding it helps with seeing how foldr is like a constructor-transformer
11:47:21 <Nolrai> So each diagram has a full type, that is a type on the left, and a type on the right, where a type is a nesting of products of sums (of products... of variables or empty sum/product at leaves) and internally its a rose DAG of smaller diagrams, with a capilary like structure of splitting and merging, like two trees sowed together at the leaves. 
11:48:30 <dmj`> jle`: 9 hours, 12 minutes
11:48:43 <refusenick> What's the right way to install a globally-reused Haskell package like Hasktags or ghcide with Stack if "stack install" in ~ is verboten?
11:49:03 <Nolrai> And I have no idea how represent that?
11:50:41 <[itchyjunk]> i dont think i underrstand it though :s
11:50:58 <jle`> dmj`: heh, come to ##adventofcode where i built santabot to report the countdown and time left on command ;)
11:51:07 <[itchyjunk]> . is a seperator but you somehow have a function defined inside that thing 
11:51:09 <jle`> [itchyjunk]: do you understand that a list like [1,2,3] is (1:2:3:[]) ?
11:51:12 <dmj`> refusenick: just build it locally then cp it into a folder that your PATH references
11:51:22 <[itchyjunk]> wait no
11:51:24 <jle`> [itchyjunk]: ah no, . is a function
11:51:31 <jle`> just like + or *
11:51:37 <[itchyjunk]> jle`, ah i didn't know that
11:51:43 <[itchyjunk]> but i understand the syntax
11:52:05 <[itchyjunk]> oh i think i might have read it! yes i thikn i know that list is just 1:2:[] stuff
11:52:09 * hackage crf-chain1 0.2.3 - First-order, linear-chain conditional random fields  https://hackage.haskell.org/package/crf-chain1-0.2.3 (JakubWaszczuk)
11:52:15 <jle`> ah, okay. hm, maybe ask again when you are familiar with (.) :)
11:52:16 <jle`> it'll come soon
11:54:24 <[itchyjunk]> whats the name for it? 
11:54:30 <[itchyjunk]> google doesn't like me searching for it
11:54:40 <yushyin> function composition
11:55:36 <[itchyjunk]> oh
11:55:50 <jle`> @src (.)
11:55:51 <lambdabot> (f . g) x = f (g x)
11:56:06 <jle`> but, it's one thing to know the definition, and another thing to be familiar with it
11:57:17 <refusenick> I deleted ~/.cabal for the last time and uninstalled GHC from my system's package manager. I'll do things Stack's way.
11:57:31 <refusenick> Now I'm getting this error: https://0x0.st/zl-D.txt
11:57:42 <fresheyeball> anyone know of a good optics library for python?
11:57:51 <fresheyeball> I am trying to teach a friend about the magic of lens
11:58:11 <dmj`> refusenick: just nuke it all rm -r ~/.ghc ~/.stack
11:58:23 <refusenick> dmj`: really? ok
11:58:28 <dmj`> refusenick: or use nix, which doesn't use an impure model like cabal or stack
11:58:35 <yushyin> fresheyeball: do they even exist in languages like py?
11:58:41 <fresheyeball> yushyin: ishhh
11:58:47 <fresheyeball> McSorta
11:59:06 <fresheyeball> #FPinYourFavoriteImperativeLang
11:59:13 <dmj`> fresheyeball: why use python at all :)
11:59:20 <fresheyeball> I don't
11:59:28 <fresheyeball> but I want to help a friend 
11:59:33 <refusenick> Aren't lens supposed to emulate subtyping?
12:00:49 <dmj`> fresheyeball: dot notation is just mutable lensing :) 
12:00:57 <dmj`> in OOP langs
12:01:33 <fresheyeball> dmj`: cheeky
12:01:56 <refusenick> dmj`: It worked! Thanks.
12:02:04 <dmj`> fresheyeball: I've been called far worse
12:02:07 <dmj`> refusenick: that's great :)
12:02:40 <dmj`> refusenick: destroying everything is the pure way to go, unfortunate FPComplete / stack authors haven't migrated to nix yet.
12:03:21 <vaibhavsagar> refusenick: does this mean I can close the IHaskell issue you raised :)?
12:04:09 <refusenick> vaibhavsagar: I suppose so! 
12:04:28 <refusenick> So much for using Cabal to test cutting-edge Hackage releases.
12:04:38 <vaibhavsagar> I even got it working successfully on my machine with just Cabal :(
12:05:09 * hackage dawg 0.8.2 - Directed acyclic word graphs  https://hackage.haskell.org/package/dawg-0.8.2 (JakubWaszczuk)
12:05:38 <refusenick> vaibhavsagar: What OS?
12:05:51 <vaibhavsagar> NixOS
12:06:03 <fresheyeball> \m/ nixos
12:06:04 <vaibhavsagar> https://github.com/gibiansky/IHaskell/issues/1128#issuecomment-560000760
12:07:50 <dmj`> NixOS, the savior of real world haskell
12:07:53 <vaibhavsagar> anyway, in the course of doing that I also found out that cabal v2-exec doesn't apply my `-hide-package` flags to the environment file it uses
12:08:29 <vaibhavsagar> another entry to my list of reasons why .ghc.environment files are bad
12:08:58 <sclv> its.. a bug
12:09:22 <vaibhavsagar> https://github.com/haskell/cabal/issues/6390
12:09:27 <sclv> yes
12:19:38 * hackage polimorf 0.7.4 - Handling the PoliMorf dictionary  https://hackage.haskell.org/package/polimorf-0.7.4 (JakubWaszczuk)
12:29:14 <vaibhavsagar> btw why does `ghc-lib-parser` export `Language.Haskell.TH`?
12:36:27 <nshepperd> looks like it includes all of template-haskell
12:37:34 <vaibhavsagar> okay, but is there a reason for that other than to make things difficult for people who have both `template-haskell` and `ghc-lib-parser` in their dependency tree
12:38:19 <vaibhavsagar> at one point they were going to make those packages (`ghc-lib`, `ghc-lib-parser`) hidden by default but that hasn't happened yet
12:39:03 <nshepperd> i don't know
12:39:38 <nshepperd> it includes all of ghc too, so you have problems if you depend on ghc as well
12:40:30 <cocreature> vaibhavsagar: because we pull in everything from the GHC sources that is transitively used by the parser modules and apparently Language.Haskell.TH is part of that
12:40:38 <vaibhavsagar> ahh
12:40:53 <vaibhavsagar> but why export it?
12:41:40 <cocreature> no particular reason but we don’t make any attempts to hide individual modules atm. I think hiding the package as you suggested is the better approach here. the GHC API doesn’t really have a concept of a public API that should be exported and non-public things
12:41:48 <vaibhavsagar> it doesn't actually matter, I'm just salty because I have to implement a workaround in IHaskell to make it work in the presence of `ghc-lib-parser`
12:42:22 <vaibhavsagar> and in addition to being a janky workaround it is now breaking in the presence of the cabal v2 commands
12:43:55 <vaibhavsagar> in my case the workaround is to explicitly pass `-hide-package ghc-lib-parser` in DynFlags
12:44:24 <cocreature> in general, you have to find some way to deal with two packages exporting colliding module names, whether that’s ghc-lib-parser and ghc, ghc-lib-parser and template-haskell or something completely unrelated to ghc-lib-parser doesn’t really matter. I don’t see how not exporting modules or hiding the package by default fundamentally changes this.
12:46:09 <vaibhavsagar> sure, except when one of them is a dependency of IHaskell
12:46:20 <vaibhavsagar> which `ghc-lib-parser` is, because `hlint` uses it
12:47:11 <vaibhavsagar> so basically this decision guarantees a collision every time IHaskell is launched
12:47:40 <vaibhavsagar> which I don't think is ideal or necessary
12:48:04 <cocreature> fair, as I said I’m open to hiding ghc-lib-parser by default. I’ll try to look into it next week but I expect that we can do it
12:49:00 <vaibhavsagar> thanks :), I opened https://github.com/digital-asset/ghc-lib/issues/158
12:49:14 <cocreature> yeah saw that
12:56:09 * hackage data-named 0.6.2 - Data types for named entities  https://hackage.haskell.org/package/data-named-0.6.2 (JakubWaszczuk)
12:57:09 * hackage aeson-yaml 1.0.5.0 - Output any Aeson value as YAML (pure Haskell library)  https://hackage.haskell.org/package/aeson-yaml-1.0.5.0 (patrick)
13:03:57 <jgt> I'm using fieldLabelModifier from Data.Aeson with `drop 3` to remove the field prefix, but this leaves me with PascalCase names. Is there an elegant way to make them snakeCase instead?
13:06:42 <jgt> oh, looks like I'll need to pull in casing or aeson-casing
13:11:00 <jgt> this is what I was after: `toJSON = genericToJSON (aesonDrop 3 camelCase)`
13:16:38 <dsal> I wonder how much time I would've saved if I looked at UnliftIO.Async before doing lots of things.
13:23:03 <d34df00d> Hi!
13:24:33 <d34df00d> I want to construct a Data.Vector.Unboxed.Vector of a known length with each value defined by a function of its index and previous value. What's the best way (performance- and readability-wise) to do this?
13:25:10 <d34df00d> `iterateN` gives me the previous value but not the index, `replicate` gives the index but not the previous value.
13:25:45 <d34df00d> `unfoldrN` might work, but I imagine it might be suboptimal because it doesn't know I'll never return `Nothing` "prematurely".
13:26:14 <d34df00d> (of course, s/replicate/generate/ in the pre-previous message)
13:26:37 <d34df00d> `iterateNM`/`replicateM`/`generateM` living, say, in the State monad will also do, but I'm not sure if ghc will be able to reasonably desugar that.
13:28:49 <d34df00d> constructN also looks interesting, but I'm not sure it's gonna be the most optimal solution.
14:13:42 <vaibhavsagar> d34df00d: I vote `iterateNM` with `State`, but I don't know for sure what the most performant solution is
14:14:22 <vaibhavsagar> I suggest trying a few different approaches and seeing which one you like best
14:57:14 <vaibhavsagar> is Haskell AoC happening again this year?
14:57:39 <jle`> vaibhavsagar: we're all hanging out in ##adventofcode again :)
14:57:51 <jle`> but it seems like you are there too
14:58:12 <vaibhavsagar> I thought that was just the regular AoC IRC channel
14:58:32 <jle`> yeah, i don't remember if there was a specific haskell aoc one :o
14:58:41 <jle`> or some slack maybe
14:59:13 <vaibhavsagar> there was glguy's leaderboard in the past
14:59:29 <jle`> yeah, the leaderboard is carried on to this year as well
15:00:22 <vaibhavsagar> I don't think I have the energy to try to compete for the leaderboard this year
15:00:31 <vaibhavsagar> :'((
15:01:01 <vaibhavsagar> especially since I never finished last year's problems
15:01:10 <jle`> we're going to miss you :'(
15:01:18 <jle`> it's not about finishing, it's about having fun :3
15:01:21 <vaibhavsagar> oh, i'll still participate
15:01:31 <vaibhavsagar> just not at 12:00am
15:02:09 <vaibhavsagar> it won't be a huge loss because I've never made it on to the leaderboard before anyway
15:03:26 <d34df00d> Ok, I can't write fast code.
15:03:41 <d34df00d> http://dpaste.com/32CNFFE can I do better?
15:04:04 <Rembane> d34df00d: Do you know where it is slow?
15:04:09 <d34df00d> (I know about edit-distance already on hackage, but that has quadratic memory requirements, which doesn't work for my case since my strings a big)
15:04:32 <d34df00d> Rembane: I compiled with profiling and it shows 'loop' (which is not a loop really, but whatever) responsible for 60% of time.
15:04:51 <Athas> Some of my Debug.Trace.trace calls seem to be removed when building with 'cabal install' instead of plain 'ghc'.  I've never seen anything like this when building with 'stack install'.  What could be going wrong?
15:05:00 <d34df00d> Which is sort of what I expect.
15:05:19 <d34df00d> levenshteinDistance.loop             Text.EditDistance.Linear src/Text/EditDistance/Linear.hs:(24,5)-(32,100)    56.0   41.8
15:05:20 <d34df00d> levenshteinDistance.loop.\           Text.EditDistance.Linear src/Text/EditDistance/Linear.hs:(26,32)-(32,100)   42.1    0.0
15:05:23 <d34df00d> ^ top two cost centers.
15:05:25 <d34df00d> Not sure how to parse that.
15:07:36 <Rembane> d34df00d: I wonder if the vector library is faster or if it's just me that's familiar with that one. 
15:07:55 <d34df00d> I tried with Vector too (Unboxed.Mutable), but it seems to be slower than this.
15:08:12 <Rembane> Oh, then I'm wrong there.
15:22:29 <vaibhavsagar> d34df00d: did you try it with -O2?
15:23:12 <d34df00d> vaibhavsagar: yep! No big difference with the default -O.
15:23:17 <d34df00d> -fllvm also doesn't help.
15:25:09 <vaibhavsagar> hmm
15:25:17 <vaibhavsagar> I dumped the core but it's impenetrable to me
15:26:49 <d34df00d> You're brave. I didn't even think I'm up to it.
15:29:06 <vaibhavsagar> I don't blame you, it's over 1500 lines of stuff
15:32:45 <phadej> fwiw, there is https://github.com/phadej/edit-distance/blob/master/Text/EditDistance/STUArray.hs burried inside edit-distance
15:32:54 <phadej> but I'm not sure if it's correct, or works, and why it's not exported
15:32:58 <d34df00d> phadej: yeah, I noticed that your package :)
15:33:04 <dmj`> jle`: I'm concerned about AOC 2019 
15:33:24 <dmj`> jle`: some people might think it's a bunch of occasio cortez fans
15:33:25 <phadej> it's max bolinbrokes, I really haven't done anything else than bumping bounds 
15:33:52 <d34df00d> phadej: BTW this looks to build a square array of MN elements, but for strings of the order of 50 kbytes it only consumes a couple of megs (if the edit costs are the default ones). Do you know why?
15:33:56 <jle`> reading the news this year was admittedly a bit confusing
15:34:04 <d34df00d> If the edit costs are custom, then it explodes to a few gigs, as expected.
15:34:44 <phadej> ok, there's -- SquareSTUArray usually beat making more use of the heap with STUArray comment
15:34:50 <phadej> trading memory for speed
15:35:23 <dmj`> jle`: that christmas code cannot come soon enough
15:36:42 <phadej> there's also https://hackage.haskell.org/package/text-metrics-0.3.0/docs/Data-Text-Metrics.html
15:38:28 <d34df00d> Oh, nice! Thanks!
15:38:37 <d34df00d> I think that one is closer algorithmically to what I'm trying to do.
15:40:46 <d34df00d> Ok cool, his implementation does it in 1 sec on my test data, while mine does this in 1.6 secs.
15:40:55 <d34df00d> So I'm not that terribly ashamed.
15:41:02 <d34df00d> But I wonder what's the crucial difference.
15:41:15 <d34df00d> (looking at https://hackage.haskell.org/package/text-metrics-0.3.0/docs/src/Data-Text-Metrics.html#levenshtein_ )
15:42:45 <phadej> I guess mark spent some time on that
15:44:05 <vaibhavsagar> d34df00d: did you see https://markkarpov.com/post/migrating-text-metrics.html?
15:44:06 <phadej> unsafe reads, using TU.Iter (vs. checked indexing), there's a lot of small things which would build-up
15:52:48 <d34df00d> phadej: well anyway your variant is the fastest so far.
15:53:07 <d34df00d> And I'm still curious how does it achieve linearity memory-wise with default edit costs.
15:56:02 <d34df00d> vaibhavsagar: yeah, quite some time ago, but I think I'll need to re-read this.
15:56:54 <d34df00d> > We beat it in the case of long inputs, with short strings performance is roughly the same, but for input lengths from 20 to 64 edit-metrics performs better!
15:56:57 <lambdabot>  <hint>:1:12: error: parse error on input ‘in’
15:56:57 <d34df00d> No you don't lol.
15:57:13 <d34df00d> 12 secs for edit-distance vs 60 secs for text-metrics on some sample strings.
15:57:56 <d34df00d> But I bet nobody designs this stuff with strings of 10-50 thousands of bytes long.
16:12:15 <psygate> Hey, is there a neat way to generate all subsets of a list while preserving order?
16:12:37 <psygate> [0,1,2] ->> [0], [1].., [0,1], [1,2], .. [0,1,2]
16:15:05 <yushyin> > init [0,1,2]
16:15:07 <lambdabot>  [0,1]
16:15:13 <yushyin> > inits [0,1,2]
16:15:15 <lambdabot>  [[],[0],[0,1],[0,1,2]]
16:15:42 <yushyin> mmh not quite
16:16:10 <psygate> not quite what i wanted. i can probably do it recursively by blacklisting entries on each step, but id like a "standard" solution somehow
16:17:24 <koz_> psygate: https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Set.html#v:powerSet
16:18:09 <psygate> koz_, well, im not allowed to use anything outside of prelude, and yes its part of homework, but im stuck.
16:18:49 <yushyin> > filterM (const [True, False]) [0,1,2]
16:18:52 <lambdabot>  [[0,1,2],[0,1],[0,2],[0],[1,2],[1],[2],[]]
16:18:59 <yushyin> mmh but not the order you wanted
16:19:34 <psygate> I've got a "close but not quite" code that I tried to adapt: 
16:19:34 <psygate> gen_words :: [String]
16:19:34 <psygate>        gen_words = [ c : s | s <- "" : gen_words, c <- ['a'..'c'] ]
16:20:23 <psygate> this generates all possible strings of "abc", and id like to use it for my other list too
16:20:26 <psygate> gen_word_list_permutations wl = [c : s | s <- [] : (gen_word_list_permutations wl), c <- wl]
16:30:39 <ChaiTRex> > filterM (const [False, True]) [0..2]
16:30:42 <lambdabot>  [[],[2],[1],[1,2],[0],[0,2],[0,1],[0,1,2]]
16:31:18 <ChaiTRex> Still not perfect.
16:32:28 <iqubic> Why isn't that perfect?
16:33:15 <MarcelineVQ> it's doens't fit the form of the initial request
16:33:33 <ChaiTRex> iqubic: It would be nicer to have the sets in size order and then, with sets of equal size, sorted.
16:34:09 <psygate> uff, i think anything works, in order or out of order, as long as it only uses prelude functions
16:34:27 <psygate> but i think ill just steal the implementations of permutation from the stdlib
16:34:33 <ChaiTRex> > sortBy (comparing (\ xs -> (length xs, xs))) . filterM (const [True, False]) $ [0 .. 2]
16:34:35 <lambdabot>  [[],[0],[1],[2],[0,1],[0,2],[1,2],[0,1,2]]
16:34:39 <int-e> > subsequences [0..2] -- not the requested order either, but closer
16:34:41 <lambdabot>  [[],[0],[1],[0,1],[2],[0,2],[1,2],[0,1,2]]
16:34:49 <MarcelineVQ> Hopefully your teacher doesn't ask you to explain you work I guess
16:35:11 <psygate> i can explain it, i just cant work it out by myself ._.
16:35:28 <int-e> > subsequences [0..] -- (that particular order has the advantage of allowing a lazy implementation)
16:35:32 <lambdabot>  [[],[0],[1],[0,1],[2],[0,2],[1,2],[0,1,2],[3],[0,3],[1,3],[0,1,3],[2,3],[0,2...
16:35:32 <psygate> This isnt the optimal state, but I only have a week per assignment, and other courses and work and all, and I cant spend a whole week only haskell alone
16:35:36 <monochrom> Explain by an induction proof.
16:37:05 <psygate> oh wait, subsequences looks very promising, int-e 
16:37:51 <psygate> is there an open haskell code repository where i could look at the implementation?
16:38:26 <ChaiTRex> psygate: Look it up on Hoogle, go to the docs, click the source link.
16:39:07 <psygate> thank you ChaiTRex 
16:39:45 <MarcelineVQ> The source links can be hard to see, there's one at the top of the page and one next to each definition in a module's documentation
16:40:06 <iqubic> Here's another version of the powerset: http://dpaste.com/2MTRYJW
16:40:36 <iqubic> http://dpaste.com/3CPM5J8
16:40:57 <iqubic> Second one is correct. I forgot a pair of parens.
16:41:07 <int-e> > concat $ foldr (\x xss -> zipWith (++) ([] : map (map (x:)) xss) (xss ++ [[]])) [[[]]] [0..2] -- too bad about the (++)
16:41:09 <lambdabot>  [[],[0],[1],[2],[0,1],[0,2],[1,2],[0,1,2]]
16:42:14 <iqubic> I have no idea how that works.
16:42:30 <int-e> > foldr (\x xss -> zipWith (++) ([] : map (map (x:)) xss) (xss ++ [[]])) [[[]]] [0..2] -- too bad about the (++)
16:42:32 <lambdabot>  [[[]],[[0],[1],[2]],[[0,1],[0,2],[1,2]],[[0,1,2]]]
16:44:09 <ChaiTRex> > foldr (\x xss -> zipWith (++) ([] : map (map (x:)) xss) (xss ++ [[]])) [[[]]] [0..] 
16:44:16 <lambdabot>  mueval-core: Time limit exceeded
16:44:23 <int-e> it's really morally the same as that `powerset` function (if you correct it: you need map (x:) powset). It just splits the result into several lists based on their lengths.
16:44:28 <psygate> @iqubic, the second one doesnt work because "cannot construct infinite type a ~ [a]"
16:44:28 <lambdabot> Unknown command, try @list
16:44:39 <iqubic> Oh. I see.
16:44:49 <iqubic> Yeah. I didn't test my function.
16:45:09 <int-e> ChaiTRex: No, it's not lazy. It won't be very lazy in any case, because at the point where you switch to lists of length 2, the whole input will be consumed..
16:45:38 <iqubic> But I see my issue.
16:45:45 <ChaiTRex> int-e: Ahh, good point.
16:46:27 <psygate> i will simple use the subsequence implementation.
16:46:31 <psygate> that one i can understand atleast.
16:47:29 <psygate> ChaiTRex, int-e, yours i couldnt explain if my life depended on it. looks like some arcane dark magic invokation to elder gods.
16:47:43 <ph88> how to write ffi to cpp ?
16:50:00 <iqubic> I just changed my powerset function so that it works properly now. http://dpaste.com/37KETMW
16:50:07 <iqubic> This has been tested.
16:56:55 <wikiemol> Question for everyone: In your opinion, what is the best front end haskell framework?
16:57:24 <MarcelineVQ> front end for what?
16:58:04 <psygate> iqubic, thats a pretty neat function. i think ill steal that.
16:58:13 <wikiemol> MarcelineVQ You're right that was vague. I meant web Front end, but really
16:58:28 <wikiemol> *but really any UI framework
16:58:29 <MarcelineVQ> wikiemol: I've not ther expertise to say what's best but I'd check out miso as stop #1
16:59:15 <wikiemol> Why do you say that?
17:01:12 <MarcelineVQ> Because it's already put the hard parts together for you but you still have the freedom to do what you prefer instead of being chained to one particualr way. their readme has a better sales pitch than I could come up with since it has examples: https://github.com/dmjio/miso
17:02:39 <wikiemol> MarcelineVQ Thank you!
17:09:06 <bushuo> Hi all, I have a list of strings and a function p :: [String] -> Bool. How can i create all permutations from the list that fulfill p. p can be found here http://dpaste.com/00QNPQT
17:11:38 <hpc> bushuo: generate all permutations of the input and then you can just do filter p (that list)
17:12:22 <ChaiTRex> bushuo: So, p checks whether it's monotonically strictly decreasing?
17:12:34 <ChaiTRex> bushuo: If so, sort and reverse.
17:12:45 <ChaiTRex> bushuo: Then check it. Either that'll pass or nothing will.
17:14:36 <hpc> ah, that's a better idea
17:14:42 <hpc> i wasn't even looking at what the predicate was :P
17:15:18 <bushuo> ChaiTRex: p checks if the input is an increasing series of laddersteps. A ladderstep of two words is given if w1 can be transformed to w2 with one of three transformation rules
17:17:01 <ChaiTRex> bushuo: Oh, I missed the very last line.
17:17:06 <bushuo> rule1: add a Char to the end of w1. rule2: remove the head of w1. rule3: change any Char in w1
17:18:52 <ChaiTRex> bushuo: The simplest solution is just to generate all permutations and filter based on the criterion for the list.
17:19:05 <ChaiTRex> bushuo: Not sure of a more efficient solution.
17:19:34 <ChaiTRex> bushuo: You could probably generate a DAG or something.
17:20:15 <ChaiTRex> bushuo: If a laddersteps to b, a has a vertex directed to b.
17:20:40 <ChaiTRex> bushuo: Would be more like O(n^2) instead of O(n!).
17:21:38 <bushuo> ChaiTRex: Thanks :) I will try that. 
17:23:07 <ChaiTRex> bushuo: Now that I think of it, you might not get a DAG, since the third rule allows for cycles (seems the prior two in combination can as well: aaa -> aa -> aaa)
17:23:16 <ChaiTRex> bushuo: So, a directed graph.
17:23:24 <ChaiTRex> bushuo: You're welcome.
17:26:05 <bushuo> ChaiTRex: Repetitions are not allowed DAG is good i think
17:27:21 <ChaiTRex> bushuo: I mean that if you have apple, adple, and acple, you need to generate all permutations of those.
17:27:42 <ChaiTRex> bushuo: They form a cycle, so you need to break the cycle in all possible ways.
17:29:39 <bushuo> the increasing rule takes care of that. cuz acple < adple < apple
17:30:12 <ChaiTRex> bushuo: Oh!
17:30:17 <ChaiTRex> bushuo: Good point :)
17:34:02 <crestfallen> "the bind operator for lists provides a means of sequencing expressions that may produce multiple results." this is from my textbook.   however a pairs function by example lists "all possible ways of pairing elements from two lists." but in what way is this returning multiple results? The results will always be the same with those two lists as input ..  ?
17:34:55 <crestfallen> the pairs function is then compared to the similar list comprehension structure for creating pairs..
17:36:56 <psygate> is there a way to turn chars into ints?
17:37:29 <int-e> crestfallen: The idea is that [1,2,3] represents multiple results: 1, 2, or 3.
17:37:51 <int-e> > do x <- [1,2]; y <- ['a','b']; return (x,y)
17:37:53 <lambdabot>  [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
17:38:30 <int-e> > [1,2] >>= \x -> ['a','b'] >>= \y -> return (x,y) -- maybe better without sugar
17:38:32 <lambdabot>  [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
17:39:20 <crestfallen> so can we say that that matrix multiplication returns multiple results?
17:39:39 <Dufaer> Hey!
17:39:46 <Dufaer> I have a function:
17:39:48 <Dufaer> foldrGMap :: GMapKey k => ((k, v) -> a -> a) -> a -> GMap k v -> a
17:39:59 <int-e> anyway, selecting x from one of the results represented by [1,2], and y from one of the results represented by ['a','b'], those are the possible resulting pairs (x,y): [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
17:40:00 <dmwit> psygate: chr/ord or fromEnum/toEnum
17:40:04 <Dufaer> Is there any way to declare a Foldable istance on that?
17:40:17 <psygate> dmwit, thank you!
17:40:17 <int-e> crestfallen: Not reasonably. That's a completely different view on a list.
17:40:37 <dmwit> Dufaer: Foldable instances happen to data types, not functions.
17:40:50 <Dufaer> I mean on GMap
17:40:56 <dmwit> You can certainly create a Foldable instance for GMap using foldrGMap.
17:41:21 <crestfallen> the wording of the text leads me to think that those two input lists could result in different pairs, which is not the case int-e I suppose
17:41:50 <dmwit> % data GMap k v; class GMapKey k; foldrGMap :: GMapKey k => ((k, v) -> a -> a) -> a -> GMap k v -> a; foldrGMap = undefined
17:41:50 <yahb> dmwit: 
17:42:26 <Dufaer> How so? "instance GMapKey k => Foldable GMap _what_here where ..."
17:42:27 <dmwit> % :t \f m -> foldrGMap (\(k,v) m -> f v <> m) mempty
17:42:27 <yahb> dmwit: (GMapKey k, Monoid a) => (t -> a) -> p -> GMap k t -> a
17:42:39 <dmwit> % :t \f m -> foldrGMap (\(k,v) m -> f v <> m) mempty m
17:42:40 <yahb> dmwit: (GMapKey k, Monoid a) => (t -> a) -> GMap k t -> a
17:42:44 <crestfallen> do you see my point int-e ?
17:42:56 <int-e> crestfallen: I see your point, but that's not what the author meant.
17:43:21 <dmwit> % instance GMapKey k => Foldable (GMap k) where foldMap f = foldrGMap (\(_, v) m -> f v <> m) mempty
17:43:21 <yahb> dmwit: ; <interactive>:64:59: error:; * Couldn't match type `k' with `*'; `k' is a rigid type variable bound by; the instance declaration; at <interactive>:64:10-39; Expected type: GMap k1 a -> m; Actual type: GMap k0 a -> m; * In the expression: foldrGMap (\ (_, v) m -> f v <> m) mempty; In an equation for `foldMap': foldMap f = foldrGMap (\ (_, v) m -> f v <> m)
17:43:58 <crestfallen> int-e, thanks kindly the language is often what sends me down rabbit holes.
17:44:20 <dmwit> % :k GMapKey
17:44:20 <yahb> dmwit: GMapKey :: k -> Constraint
17:45:03 <dmwit> Dufaer: Okay. Some odd extensions have gotten in my way. But that's how you would do it.
17:45:21 <int-e> crestfallen: Rather than a pure value of type a, in the list monad you'd have a list of possible values [a]. But the list itself, is, of course, a pure value. The "multiple values" arise from looking at the individual list elements as candidate values.
17:45:51 <dmwit> Dufaer: I guess you'll also need a Functor instance; that one probably can't be done in terms of foldrGMap, but perhaps you have a mapGMap that will do.
17:45:51 <int-e> crestfallen: So you have pure functions [a] -> [b] but you think of them as functions of type a -> b where a and b can have multiple values.
17:46:44 <Dufaer> @dmwit I think you are discarding the keys, is that right? That's not desirable.
17:46:44 <lambdabot> Unknown command, try @list
17:52:54 <Lears> Dufaer: it sounds like you don't want a Foldable instance, but a FoldableWithIndex instance instead.
17:56:49 <Lears> Though it's questionable what utility you'll get out of making that instance rather than just using what you've already written.
18:01:28 <dmwit> Dufaer: I am discarding the keys. If that's not desirable, then a Foldable instance is not desirable.
18:07:41 <Dufaer> @dmwit Huh? It is. I think I know how to do it: I just need a constraint that tells me that the parameter has the form (k, v).
18:07:42 <lambdabot> Unknown command, try @list
18:09:15 <dmwit> Can't be done. The Functor instance isn't writable.
18:09:37 <dmwit> Sorry. You don't have to believe me, of course, but I'm telling the state of the world as I understand it.
18:09:56 <dmwit> Use a different class, or just expose foldrGMap under that name.
18:12:18 <Dufaer> @dmwit I think you are right.
18:12:18 <lambdabot> Unknown command, try @list
18:18:43 <habbah> what are all the ways to specific versions of a packag dependency in a cabal file?
18:19:02 <habbah> what are all the ways to specify versions of a package dependency in a cabal file?
18:27:54 <dmj`> >, >=, ==, <, <=, ^>= 
18:39:28 <pavonia> What is ^>=?
18:42:50 <Clint> a mistake
18:43:46 <habbah> are these mentioned in the ghc or cabal docs?
18:45:31 <Clint> cabal
19:16:08 <slack1256> How do I use glade with gi-gtk?
19:16:58 <glguy> https://github.com/glguy/CookieCalculator/blob/master/gui/Main.hs#L62
19:17:17 <slack1256> glguy: You're awesome
19:31:13 <iqubic> I'm so looking forward to AoC.
19:31:40 <iqubic> glguy: I joined your leaderboard. jle` gave me the add code.
19:40:21 <iqubic> I have a parsec question. I want to write a parser that reads a single char, if it is '(' the parser returns 1. If it is ')' the parser returns -1. Otherwise, fail.
19:40:52 <iqubic> How do I do that?
19:42:57 <dsal> 1 <$ "(" <|> 2 <$ ")"
19:43:07 <iqubic> Does that work?
19:43:12 <dsal> something like that
19:43:18 <iqubic> What does `<$` do?
19:43:21 <dsal> I'm eating popcorn
19:43:23 <iqubic> :t <$
19:43:25 <lambdabot> error: parse error on input ‘<$’
19:43:30 <dsal> It's half a fmap
19:43:30 <iqubic> :t (<$)
19:43:32 <dsal> fap
19:43:33 <lambdabot> Functor f => a -> f b -> f a
19:43:41 <iqubic> Oh. I see.
19:44:00 <iqubic> It needs to be (<*) though, I think.
19:45:05 <MarcelineVQ> What is the type of <* ?
19:45:26 <dsal> Here's code from a parser I use:    PingPkt <$ A.string "\192\NUL" <|> PongPkt <$ A.string "\208\NUL"
19:45:35 <dsal> Tha's attoparsec,  though.
19:46:21 <iqubic> I'm going to be using megaparsec, so results may vary.
19:46:57 <dsal> You  probably don't need A.string
19:48:14 <dsal>  (True <$ symbol "watch") <|> (False <$ symbol "match")   -- I'm using "symbol" for space consumption
19:53:26 <dmj`> glguy: you gonna show everyone up again this year?
19:53:32 <dmj`> :)
19:54:15 <iqubic> Did he show everyone up last year?
19:54:33 <dmj`> every year
19:55:29 <ChaiTRex> Is the private leaderboard we're using the one given out by santabot?
19:55:58 <iqubic> I think so.
19:56:05 <[itchyjunk]> oh glguy is aprticularly good at haskell?
19:56:23 <dsal> Wasn't he the one doing haskell and rust last year?
19:56:40 <dsal> I'd still be loading the page exactly as it showed up and he'd have already pushed his answer.
19:57:16 <Dufaer> Is there a way (an extension?) to declare a class & a superclass instance at once?That is, to write```instance Num a => Monoid a where  (<>) = (+)  mempty = 0```instead of```instance Num a => Semigroup a where  (<>) = (+)instance Num a => Monoid a where  mempty = 0```?
19:58:09 <glguy> No, and making an instance like that separately isn't a good idea eitehr
19:58:13 <amalloy> i hope that is just an example, and you don't plan to actually give Num a Monoid instance
19:58:46 <iqubic> Sum and Product newtype wrappers exist for a reason.
19:59:03 <dsal> (And can compile away with coerce)
19:59:27 <Dufaer> The specific instances are just to make the example shorter.
20:02:16 <glguy> dmj`: I'm participating this year, but I probably won't be able to consistently race the problems
20:02:53 <dmj`> glguy: ah, ok so that means you'll be eighth place globally instead of seventh
20:02:57 <glguy> I'll keep publishing solutions and I plan to do them all though
20:03:06 <dmj`> in rust or haskell ?
20:03:20 <glguy> Haskell and then I think O'Caml this year
20:03:21 <cheater> hi
20:03:30 <cheater> can there be a Num class instance without 0?
20:03:36 <dmj`> glguy: OCaml ??  
20:03:38 <dmj`> well I'll be
20:03:53 <dsal> I used to write a lot of ocaml.  I'm pretty sure I couldn't hell world today.
20:03:57 <glguy> I pick my off languages based on what I'm doing at work
20:03:58 <cheater> glguy: participating in what?
20:04:49 <dsal> I probably shouldn't try to stay on the scoreboard.  It was kind of painful last year.
20:05:04 <iqubic> I'll see what I can do.
20:05:53 <glguy> cheater: advent of code
20:05:56 <cheater> ok
20:06:29 <dmj`> the best part of advent of code is the first week, since the problems are easy and you feel so smart when you finish them
20:07:17 <dmwit> cheater: One of the sort-of-expected behaviors of Num instances is that fromInteger be a ring homomorphism. That's not possible unless the instance has a sensible 0 (or rather, that is one way to say what "0" means).
20:11:23 <iqubic> How well does the AoC server handle the influx of people trying to read the day 1 puzzle?
20:11:31 <glguy> without any trouble
20:11:41 <iqubic> Good.
20:11:57 <iqubic> I was worried I'd have trouble getting my data.
20:17:54 <dsal> The worst problem from last year was when they were computing the wrong answer for something.
20:21:17 <jle`> cheater: there's an unofficial haskell leaderboard, 43100-84040706
20:21:26 <jle`> er sorry, ChaiTRex ^
20:21:52 <leftylink> great, joined
20:21:55 <glguy> I might have to start bumping people off it who were in active last year
20:26:16 <dmj`> if you were smart you'd DDoS the servers right after you got your puzzle
20:27:04 <dmj`> to ensure your global dominance
20:30:08 <ChaiTRex> jle`: thanks
20:36:04 <cheater> dmwit: thank you
20:36:53 <cheater> jle`: there's some sort of leaderboard? what's that based on?
20:37:48 <jle`> cheater: it's for Advent of Code :) (sorry, the message was meant for ChaiTRex but i tabbed too early)
20:39:49 <cheater> interesting!
20:42:57 <dmj`> jle`: start your engines, warm up your buffers
20:46:04 <dmj`> get that ghci interpreter sputtering
20:47:33 <iqubic> My buffers are warmed up.
20:47:51 <dmj`> that's good
20:47:52 <iqubic> I have my GHCi interperter running.
20:49:04 <dmj`> now cheat a little and write some partial function like main = do { input  :: [Int] <- fmap read . lines <$> readFile "input.txt"; mapM_ print input }
20:49:16 <dmj`> maybe import some things import Data.List, etc.
20:50:43 <iqubic> I have that already.
20:51:02 <dmj`> well you're more than halfway there then for day 1
20:51:06 <iqubic> I have Parsec imported for parsing.
20:51:14 <dmj`> woa woa, let's not get carried away now
20:51:28 <iqubic> I have a function which takes a parser and parses the file line by line.
20:51:29 <dmj`> open a browser tab to AoC, wait for the countdown 
20:51:33 <iqubic> I will.
20:51:56 <dmj`> when the clock strikes 12 santa visits 
20:52:38 <cheater> can you somehow pattern match on sets?
20:53:06 <iqubic> 442 seconds and counting
20:53:26 <jle`> cheater: not based on the official API
20:53:33 <cheater> that's sad
20:53:42 <jle`> cheater: but lookupMin is a pretty close alternative
20:53:57 <cheater> i want to match on the contents of a set
20:54:40 <jle`> like, go down a branch if a set is equal to some items you have?
20:54:47 <jle`> the best way probably is to just use guards
20:54:53 <cheater> if a set contains exactly the items i have
20:54:56 <cheater> aha
20:55:00 <cheater> how would you do that?
20:55:01 <jle`> mySet == S.fromList [1,2,3]
20:55:03 <cheater> right
20:55:11 <iqubic> Oh. Yeah. Still just use a guard.
20:55:16 <iqubic> Not sure what condition to use.
20:55:27 <jle`> and you can use `isSubset` too if you only want it to at least contain some items
20:55:36 <cheater> nah, just exact equality
20:55:44 <cheater> thanks!
20:55:46 <iqubic> In 5 minutes I will preoccupied.
20:55:54 <jle`> cheater: np!
20:56:00 <iqubic> cheater: `isSubset` isn't quite what you want.
20:56:32 <iqubic> You want a guard with the condition "mySet == S.fromList [1,2,3]" or some such.
20:57:02 <cheater> yes
20:57:03 <cheater> thanks
20:57:07 <cheater> :)
20:58:25 <dmj`> don't forget to login
20:58:55 <iqubic> I've already done that.
20:59:20 <iqubic> I've got my session key ready so that I can use jle's library.
21:11:33 <dmj`> done :)
21:12:24 <jle`> nice
21:12:40 <dmj`> easy as pie
21:12:46 <jle`> i hit the timeout/cooldown for part 2, i accidentally added the original number as well :'( every time i think "i'll just submit without tests", it bites me
21:13:58 <dmj`> yea I'm always scared to hit submit
21:14:28 <dmj`> I ran their example through my function to ensure the output was the same as their example output
21:14:49 <dmj`> at first I was thinking of using foldl', or scanl'
21:15:10 <dmj`> then maybe foldMap too, but didn't want to map Sum because I'm lazy
21:15:29 <kiwiQs> http://trichan.usr.bz
21:16:46 <dmj`> jle`: resorted to good ol' recursive functions over lists
21:16:56 <jle`> dmj`: do you have a repo this year?
21:16:59 <dmj`> the base case was tricky
21:17:15 <dmj`> jle`: https://github.com/dmjio/advent-of-code-2019
21:18:14 <iqubic> Well I learned that I should test things before submitting them.
21:18:17 <dmj`> forgetting to fromIntegral the Int into a Double took some time away
21:18:49 <iqubic> I had the right answer, except that the first element of (iterate) is the input you give it.
21:19:14 <dmj`> jle`: you know what, it was actually an unfoldr
21:19:27 <iqubic> Are you talking about the AoC puzzle?
21:20:45 <dmj`> jle`: that is so fresh
21:20:48 <dmj`> iqubic: yea
21:21:03 <iqubic> I didn't use an unfoldr.
21:21:04 <jle`> dmj`: i used iterate too. but um ##adventofcode-spoilers
21:23:29 <dmj`> jle`: iterate and takeWhile (>=0), you lazy piece of .... 
21:24:37 <iqubic> He he.
21:27:23 <dmj`> jle`: first place?
21:28:18 <monochrom> It is always safe to say "I used recursion" :)
21:29:51 <dmj`> monochrom: ok ok, explicit recursion
21:30:31 <monochrom> I use recursion and base 10. :)
21:31:24 <MarcelineVQ> you monster
21:32:19 <nshepperd> am I a bad person for always defining input = unsafePerformIO (parse <$> readFile "input.txt") in these problems
21:32:26 <dmj`> jle`: your aoc repo is a complete situation
21:32:41 <monochrom> Yes that's bad.
21:32:43 <jle`> i spend way too much time on it lol.
21:32:46 <dmj`> nshepperd: that's a great idea
21:32:55 <jle`> nshepperd: it's beautiful
21:32:55 <dmj`> just {-# NOINLINE input #-} it
21:33:05 <glguy> nshepperd: Yes, you're a bad person.
21:33:12 <dmj`> nshepperd: santa will bring you coal though
21:33:14 <glguy> or at least a bad Haskell programmer and maybe a great person :)
21:33:16 <jle`> i would {-# INLINE input #-} it
21:33:20 <nshepperd> excellent
21:33:35 <dmj`> jle`: no inline :P
21:33:44 <jle`> if you inline it then it's a disk operation every time you use it
21:33:58 <jle`> then at least you pay for your sins
21:34:56 <dmj`> if you inline it, the IO can be run more than once, but I guess if you only use it in one place who cares
21:35:31 <monochrom> I think jle` is aiming at maximum badness. Err I mean beauty.
21:35:44 <glguy> Leave it to Haskell to make the solution to day 1 complicated :-D "should I use unsafeperformio to add up this list of numbers?"
21:35:47 <jle`> dmj`: yes, that's my point :)
21:35:53 <monochrom> In fact why not make it a C macro, too!
21:35:55 <nshepperd> up, down, top, bottom, truth, badness
21:36:08 <dmj`> jle`: fair enough :) 
21:36:13 <monochrom> #define input ( unsafePerformIO (parse <$> readFile "input.txt") )
21:36:39 <jle`> dmj`: if you do it then you at least deserve to suffer for it by re-doing the IO
21:38:26 <dmj`> jle`: I shall allow it
21:38:46 <iqubic> I'm so confused here.
21:38:50 <nshepperd> in puzzles where the input fits on one line I just paste it into my solve.hs, obviously
21:39:22 <dmj`> nshepperd: that would be cool to have some elisp that fetched the puzzle and formatted it in your buffer
21:40:02 <iqubic> I have this one function of code that compiles in my Common.hs file, but if move it to Day1.hs, it fails to compile.
21:40:42 <dmj`> jle`: oh man, iterate is nice here, nice look
21:40:48 <glguy> Doctor, it hurts when I bend my arm like this
21:41:11 <dmj`> loool
21:43:24 <iqubic> Alright, I have the same exact function in two different files, and it has two different type signatures. What the hell is going on here?
21:46:10 <jle`> extensions, maybe? or different things imported
21:46:54 <iqubic> Here it is in Util.hs. http://dpaste.com/0304FWZ
21:47:22 <iqubic> Here is it in Day1.hs. http://dpaste.com/3ARYVWM
21:47:29 <iqubic> I have no clue what's up there.
21:47:56 <iqubic> I'm trying to use megaparsec here, but it isn't working.
21:48:03 <glguy> Why is 'Module' capitalized?
21:48:11 <glguy> Are you sure you're looking at a file that's loading?
21:49:13 <iqubic> module is capitalized because I typed that line by hand when putting it into dpaste.
21:49:58 <iqubic> http://dpaste.com/39PHK7H
21:50:02 <iqubic> Fixed that for you.
21:51:01 <iqubic> I have no idea why this isn't the same typesignature.
21:51:10 <iqubic> *type signature.
21:51:57 <nshepperd> probably one of your assumptions about what you are loading or importing are wrong
21:52:19 <iqubic> How so?
21:53:16 <nshepperd> like your shell is in the wrong directory and you're looking at the Util.hs from last year or something
21:53:24 <iqubic> No. That's not it.
21:53:37 <dmj`> just put all the code into a single module ... problem solved
21:54:17 <iqubic> Oh, that was the issue.
22:05:05 <iqubic> parsing is hard.
22:05:48 <dsal> megparsec is pretty nice once you get the hang of it.
22:05:58 <iqubic> I know. But I can't seem to make this work.
22:09:15 <iqubic> @unpl h . g . f
22:09:15 <lambdabot> (\ x -> h (g (f x)))
22:09:30 <nshepperd> iqubic: i'd suggest using not parseMaybe, but something that prints out an informative parse error in failure
22:09:56 <iqubic> Like what?
22:10:20 <jle`> parseMaybe is also really restrictive ... it fails when parser/runParser/etc would normally succeed
22:10:26 <iqubic> Ah I see.
22:10:45 <jle`> if you're in ghci you can use testParse or parseTest, w/e it is called
22:11:15 <iqubic> https://hackage.haskell.org/package/megaparsec-8.0.0/docs/Text-Megaparsec.html#v:parseTest
22:11:17 <iqubic> I see.
22:12:55 <iqubic> So I have this: (T.unpack . T.append "\n" . T.strip), which is most likely unneeded. I just want to make sure that every line of the input is followed by exactly one newline.
22:13:14 <iqubic> I'm running that on the input as soon as I get it.
22:15:00 <nshepperd> (T.append "\n") puts the newline at the start of the result
22:15:17 <iqubic> It does? why?
22:15:24 <iqubic> Oh right.
22:15:27 <iqubic> I'm dumb.
22:15:28 <jle`> > (++) "\n" "hello"
22:15:30 <lambdabot>  "\nhello"
22:16:11 <iqubic> Right.
22:20:17 <iqubic> I fixed my parser.
22:21:22 <iqubic> I can now use parseInputLines :: Parser a -> String -> [a]
22:21:26 <iqubic> And it just works.
22:21:31 <iqubic> I also have number.
22:21:38 <iqubic> modules :: String -> [Int]
22:21:43 <iqubic> modules = getParsedLines number
22:22:00 <iqubic> Does basically exactly what you'd expect it too.
22:31:24 <iqubic> Is it possible to make it so that if you import module a, you get all the functions from module b and c too?
22:32:32 <amalloy> a can export modules b and c
22:32:44 <iqubic> Like I want module a to export all the functions it defines, as well as module b and c.
22:33:24 <dsal> Can I disable an orphan warning for a single instance?
22:33:26 <iqubic> What is the syntax for that?
22:36:02 <amalloy> iqubic: a google search for "haskell export module" yeids https://stackoverflow.com/q/18035458/625403
22:40:10 <Pamelloe1> Is there a type for a Functor with restricted domain? In this case, I would like to restrict the domain to just Double.
22:40:15 <iqubic> Good that works.
22:43:23 <amalloy> Pamelloe1: you may be looking for mono-traversable, but it's sorta a weird thing to want. are you sure you want it?
22:44:18 <Pamelloe1> Ah, that's exactly what I want!
22:48:44 <Pamelloe1> Out of curiosity, is there a middle ground between Functor and MonoFunctor? I'm imagining I might have a container which only accepts Num types, and it would be cool to have a correct quasi Functor instance for it.
22:50:10 <Pamelloe1> Nevermind, it looks like MonoFunctor actually encodes this behavior already.
22:51:51 <Pamelloe1> Actually, nevermind the nevermind---MonoFunctor does not encode this behavior. I just got confused for a moment about how type families work.
22:51:55 <iqubic> ChaiTRex: drop 1 == tail.
22:52:09 <iqubic> I'm just looking at what you did for AoC day 1.
22:52:19 <nshepperd> ordinarily you'd just write a custom function for that
22:52:31 <nshepperd> it's not really any less convenient than using MonoFunctor
22:53:25 <sim590> I'm doing some dynamic programming so I have to mutate some 2d array containing intermediary values. What's the best approach to stay efficient and readable? Data.Vector (so Vector (Vector a)) or Data.Array.Repa ? Or something else?
22:56:00 <Pamelloe1> From a practical standpoint, I agree. What I like about MonoFunctor, though, is that it formally encodes the intution that a type is a categorical functor, even if it isn't a haskell Functor.
22:57:16 <Pamelloe1> That's why I think a not-quite-mono functor that was parameterized by a type class instead of a single type would have value
22:58:11 <jle`> Pamelloe1: hm, how does MonoFunctor encode the intuition that a type is a categorical functor?
22:58:33 <jle`> i feel like it goes in the opposite direction ... it sheds that intuition, and allows you to do map in a way that is non-categorical
22:59:15 <jle`> an instance of MonoFunctor is as "not" a categorical functor, so it doesn't have to pretend to be
23:00:15 <Pamelloe1> An instance of MonoFunctor is as much a categorical Functor as a standard Functor. The difference is the domain of Functor is the entire category Hask, while the domain of MonoFunctor is the subcategory of Hask only involving the associated Element type.
23:00:36 <Pamelloe1> (Hask is the name for the category of Haskell functions, right?)
23:01:55 <solrize_> haskell types
23:02:37 <Pamelloe1> Well, haskell types are the objects and haskell functions are the arrows :)
23:02:48 <ChaiTRex> iqubic: I wanted to be safe against a module weighing zero :)
23:08:32 <jle`> Pamelloe1: so it is a functor from (), basically?
23:08:45 <jle`> Pamelloe1: the category with a single object?
23:10:11 <jle`> Pamelloe1: it sounds like you're saying that it's specifically a functor from a single-object category to another single-object category
23:10:37 <Pamelloe1> Yes, that's correct
23:10:55 <jle`> ah, i misinterpreted your message, i think
23:11:20 <Pamelloe1> So for instance MonoFunctor Text is a Functor from Hask restricted to Char to Hask restricted to Bytestring
23:11:21 <jle`> i thought you were saying that you liked MonoFunctor becasue it's more faithfully a categorical functor abstraction than haskell Functor
23:12:24 <jle`> well, "Hask restricted to Char" is a little weird to say...it's like saying "integers restricted to 5"
23:12:57 <Pamelloe1> I think it's more like saying Vector Spaces restricted to R
23:13:12 <jle`> but, it only has a single object
23:13:32 <jle`> so maybe closer to saying vector spaces restricted to a single vector space, R^3 or something
23:14:09 * hackage ttc 0.1.0.0 - Textual Type Classes  https://hackage.haskell.org/package/ttc-0.1.0.0 (TravisCardwell)
23:14:36 <Pamelloe1> Yep, that's what I was trying to say---I was referring to R as a 1-dimensional R vector space.
23:14:49 <jle`> ah, instead of R being the field it's over
23:15:06 <Pamelloe1> Yep!
23:15:51 <Pamelloe1> The point is, even though vector spaces restricted to R^3 has only a single object, it has a lot of arrows: one for each endomorphism of R^3
23:16:37 <Pamelloe1> Likewise Hask restricted to Char would be a category with a single object (Char) and lots of arrows (one for each function Char -> Char)
23:17:18 <Pamelloe1> MonoFunctor Bytestring is a categorical functor from Char and functions Char -> Char into Bytestring and functions Bytestring -> Bytestring
23:17:34 <jle`> yeah, i see what you are trying to say :)
23:17:46 <jle`> i guess at first i thought you were comparing MonoFunctor to Functor, instead of just saying MonoFunctor is great on its own right
23:20:51 <Pamelloe1> I guess my original point is it would be cool to have a Functor with a domain determined by a type class, rather than just everything (Functor) or a single type (MonoFunctor)
23:27:40 <jle`> i've seen some posts about possible abstractions like that, so you could use it with Data.Set
23:30:23 <jle`> i know you can fake it with things like Coyoneda
23:53:05 <nshepperd2> map on Data.Set could be viewed as a functor from Hask to data C a b = C (Ord b => Set a -> Set b)
23:53:57 <nshepperd2> C having the obvious Category instance
23:54:58 <nshepperd2> Ah, no, that doesn't work
23:55:40 <nshepperd2> Since you can't compose 'em
23:57:22 <Pamelloe1> You'll want to add Ord a as well, and restrct the domain of map accordingly. 
23:58:18 <Pamelloe1> Data.Set.map can be seen as witnessing a functor from Hask restricted to Ord into Hask restricted into Ord a => Set a
23:59:00 <Pamelloe1> Which is exactly the knd of restricted Functor I was musing about earlier :)
23:59:16 <jle`> just use the Functor instance of Coyoneda Set :)
23:59:35 <jle`> the main downside is you have to remember to concretize every once in a while
23:59:44 <jle`> but also Coyoneda Set has some different semantics
23:59:57 <jle`> it actually preserves fmap f . fmap g = fmap (f . g), which is not preserved by Set.map
