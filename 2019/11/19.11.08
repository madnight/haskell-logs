00:29:41 * hackage slist 0.1.0.0 - Sized list  https://hackage.haskell.org/package/slist-0.1.0.0 (vrom911)
00:38:11 * hackage yaml-combinators 1.1.1.2 - YAML parsing combinators for improved validation and error reporting  https://hackage.haskell.org/package/yaml-combinators-1.1.1.2 (RomanCheplyaka)
00:50:49 <kenran_> I use haskell with nix to manage dependencies. Now one of the packages has a transitive dependency on an old HSpec version (<2.6). What should I do now? I cannot really set hspec to a version old enough because then other packages break.
00:51:50 <kenran_> Can I add a "second" hspec with different name and different version, and then override whichever package depends on it to us the "other" hspec?
01:04:36 <lortabac> how can I represent optional where predicates with postgresql-simple?
01:05:45 <phadej> string concatenation :)
01:06:26 <lortabac> phadej: the problem is that the number of parameters varies according to the number of predicates
01:06:53 <phadej> Action has `ToField`
01:06:55 <phadej> instance
01:07:17 <phadej> so you can build something very silly
01:07:49 <phadej> like https://github.com/futurice/haskell-mega-repo/blob/master/futurice-postgres/src/Futurice/Postgres/SqlBuilder.hs
01:07:56 <asdfghjklo> Does anyone have opinions on lisp vs haskell?
01:08:35 <jollygood2> hi. is there a combinator like this in parsec? keepTrying parser = try parser <|> do anyChar; keepTrying (parser)
01:09:36 <merijn> jollygood2: Not directly related to your question, but: http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/
01:10:07 <merijn> jollygood2: And I don't think such a parser exists, tbh, it seems rather brittle and slow
01:11:05 <jollygood2> I'm not sure what other options I have than try + <|>. I need to extract some information (price, area, etc) from human written descriptions
01:11:06 <phadej> it looks like manyTill
01:11:16 <phadej> which returns the end
01:11:57 <Arahael> Megaparsec's use of 'many' should work there, too? Except yeah, the errors are a bit hard to understand.
01:11:59 <phadej> which essentially is what jollygood2 wrote: https://hackage.haskell.org/package/parsec-3.1.14.0/docs/src/Text.Parsec.Combinator.html#manyTill
01:12:29 <merijn> phadej: Oh! Good point
01:12:43 <merijn> Arahael: Many would eat up everything
01:14:16 <Arahael> merijn: Not even as 'many parser'?
01:15:16 <merijn> Arahael: That...does not do remotely the same thing?
01:15:39 <Arahael> merijn: I'm very much mis-understanding the question here?  He wants to repeatedly keep trying a parser?
01:15:41 <merijn> Arahael: Basically he want to "ignore all the garbage until I find another case of parser"
01:15:48 <jollygood2> yes
01:15:49 <Arahael> Oh!
01:16:12 <merijn> Which, indeed, is just manyTill as phadej pointed out
01:16:47 <phadej> ... except manyTill doesn't return the `end`
01:18:04 <merijn> Ok, actually it'd be "manyTill anyChar parser >> parser"
01:18:21 <merijn> Since manyTill doesn't consume the final parser
01:23:03 <w1d3m0d3> how's haskell on android so far?
01:23:11 * hackage traverse-with-class 1.0.1.0 - Generic applicative traversals  https://hackage.haskell.org/package/traverse-with-class-1.0.1.0 (RomanCheplyaka)
01:25:10 <merijn> w1d3m0d3: Rather DIY, afaik :p
01:25:31 <w1d3m0d3> sounds terrifying
01:25:46 <w1d3m0d3> does ghc predate llvm?
01:25:57 <jusss> merijn: how haskell work with sql? mysql pgsql blabla, 
01:26:26 <merijn> w1d3m0d3: By a few decades
01:26:42 <jusss> merijn: why people alwasy suggest persistent...
01:26:45 <w1d3m0d3> suspected so :P
01:27:10 <merijn> w1d3m0d3: There is an LLVM backend, but that is a bit tricky to get working, since it is (was, at least) rather picky about exact LLVM versions
01:27:39 <merijn> jusss: I would recommend the various *-simple sql libraries and definitely *not* persistent, tbh
01:28:06 <merijn> jusss: I don't think people "always" suggest persistent, tbh
01:28:29 <jusss> merijn: why?
01:29:17 <w1d3m0d3> I may give that a shot
01:29:22 <w1d3m0d3> the llvm backend, that is
01:29:54 <merijn> jusss: Why I wouldn't recommend it? Because using persistent has been the 1 major painpoint in my current Haskell codebase. It worked well enough to get an initial version working, but now it's too much work to migrate to something else, so I have to patch/fix persistent anytime I run into problems
01:30:32 <merijn> w1d3m0d3: Basically, people have gotten Haskell programs to run on Android and iOS in the past, all the individual necessary parts appear to be (mostly?) there, but none of it is documented or easy/convenient
01:30:51 <merijn> w1d3m0d3: Mostly due lack of manpower working on this stuff in GHC
01:31:18 <merijn> w1d3m0d3: Might want to ask on the haskell-cafe mailing list on who's done this and how
01:31:37 <w1d3m0d3> merijn: does ghc-created code use libc for io or does ghc also need a layer for each platform?
01:31:41 <jusss> merijn: what `various *-simple' sql you would recommend? I found a few on hackage, I don't know to choose which one
01:31:53 <merijn> jusss: That depends on the database you have
01:32:18 <jusss> the most download is esqueleto which is for persistent
01:32:28 <merijn> w1d3m0d3: The RTS system is implemented in C (and thus uses libc stuff)
01:32:56 <merijn> jusss: If you have sqlite, then sqlite-simple, if you have postgres, then postgresql-simple, etc.
01:35:29 <w1d3m0d3> merijn: yeah this seems a wee bit over my head
01:35:41 * hackage network-ip 0.3.0.3 - Internet Protocol data structures  https://hackage.haskell.org/package/network-ip-0.3.0.3 (MikhailVorozhtsov)
01:59:04 <jollygood2> it worked better than I expected. after some tweaking I managed to extract data from 67 out of 100 human written descriptions with 100% accuracy
02:01:01 <jollygood2> and most of the remaining descriptions didn't have that data
02:10:27 <jollygood2> 76 percent after adding support for spelled out numbers
02:47:36 <tdammers> juss: IME, the best starting point is to use one of the *-simple libraries and write SQL as SQL. Layers on top introduce abstraction-induced constraints that may or may not be beneficial for your use case, and they always introduce some organizational overhead (i.e., they're liabilities)
02:47:58 <tdammers> (oh well, too late)
02:48:15 <MarcelineVQ> soon to return
02:58:14 <jollygood2> is there something like this in parsec? anyParser :: [Parser a] -> Parser a
02:59:06 <f-a> jollygood2: choice
03:00:47 <jollygood2> thanks!
03:14:14 <jollygood2> style question, do you use same alias for different modules? for example, having both `import qualified Data.Text as T ' and `import qualified Data.Text.IO as T' in the same file
03:15:34 <f-a> no, I prefer to have it differentiated
03:15:46 <f-a> so it is easier to understand where that pesky function came from
03:19:31 <ollehar> How would a Haskell programmer decide where to put code with side-effects?
03:19:47 <ollehar> There's nothing in principal stopping a Haskell program from having side-effects everywhere, right?
03:19:52 <ollehar> principle*
03:20:11 <Uniaika> ollehar: nah, you'll just have to put everything in IO
03:21:34 <ollehar> Uniaika: yeah
03:22:12 <ollehar> Uniaika: so does that restraint people? or is it rather a culture of carefulness that make haskell programs more structured with regard to pure code?
03:23:07 <f-a> ollehar: it is not difficult to get it working and then factor pure stuff out
03:23:16 <f-a> also for testing, etc. it is much more convenient
03:23:22 <f-a> so you kind of get along with it
03:23:40 <jollygood2> you can't have side-effects everywhere. for example, you can't do IO in Show instance, it won't compile. likewise, you can't do IO in STM transaction.
03:28:16 <ollehar> f-a: what's more convinient for testing?
03:28:31 <ollehar> jollygood2: what's STM?
03:28:49 <jollygood2> software transactional memory
03:29:03 <ollehar> jollygood2: Show is the toString() function in Haskell, right?
03:29:44 <f-a> pure functions are easier to work with in quickcheck and of course seeing a pure signature is easier when you read code, less to think about 
03:32:51 <jollygood2> ollehar STM is concurrency control mechanism. since every transaction can fail, and can be repeated one or more times, you can't do any IO in it. in other languages it is up to discipline of the programmer to not accidentally do any IO in STM transaction. in haskell doing IO in STM transaction is compile error
03:32:55 <ollehar> f-a: right
03:33:05 <ollehar> jollygood2: +1
03:33:10 <jollygood2> ollehar, yes, show is like toString
03:33:19 <ollehar> ok ^^
03:34:19 <jollygood2> same for Eq, Ord, etc functions (==, >, <, etc). you can't do any IO when you define those methods for your own data types
03:36:43 <ollehar> OK, so some limitations :)
03:38:28 <jollygood2> beyond those limitations, yes, you could basically be in IO in every single function that you write. which would make haskell the same as other languages. but you couldn't call those functions in non-IO code
03:41:11 * hackage parser-combinators 1.2.1 - Lightweight package providing commonly useful parser combinators  https://hackage.haskell.org/package/parser-combinators-1.2.1 (mrkkrp)
03:42:41 * hackage parser-combinators-tests 1.2.1 - Test suite of parser-combinators  https://hackage.haskell.org/package/parser-combinators-tests-1.2.1 (mrkkrp)
03:52:38 <ollehar> jollygood2: got it
03:52:55 <ollehar> I was actually thinking about a language which only allows side-effect on the first level of the stack-trace :d
03:53:20 <ollehar> But it seems like there's no free lunch with this "organize you side-effects" issue.
03:55:24 <[itchyjunk]> say a and b are nested list with integerentries
03:55:49 <merijn> ollehar: You mean to have the side effects be local to a single "function call stack entry"?
03:55:52 <[itchyjunk]> [[1,2],[3,4]] [[5,6],[7,8]] say for example
03:56:15 <[itchyjunk]> i want to define a function that take a and b and does a component wise addition
03:56:28 <[itchyjunk]> i guess my question is, how do i refer to the positions of those lists?
03:56:51 <[itchyjunk]> how do i say add 5+1, 2+6 etc :x
03:57:12 <merijn> ollehar: That doesn't work for arbitrary side-effects, but you are right that if we only consider memory mutation and restrict it to only be observable within a specific function invocation
03:57:34 <Ariakenom_> [itchyjunk]: look at zipWith
03:57:36 <merijn> > zipWith (zipWith (+)) [[1,2],[3,4]] [[5,6].[7,8]]
03:57:39 <lambdabot>  error:
03:57:39 <lambdabot>      • Couldn't match expected type ‘b0 -> c0’
03:57:39 <lambdabot>                    with actual type ‘[Integer]’
03:57:51 <merijn> > zipWith (zipWith (+)) [[1,2],[3,4]] [[5,6],[7,8]]
03:57:53 <lambdabot>  [[6,8],[10,12]]
03:57:56 <merijn> Boom
03:58:09 <Ariakenom_> https://hoogle.haskell.org/?hoogle=zipWith
03:58:11 <[itchyjunk]> hmm
03:58:36 <merijn> ollehar: That has, in fact, already be invented and implemented too ;)
03:58:46 <[itchyjunk]> is this the best way to do it? zipWith is an inbuilt function i guess :s
03:59:01 <ollehar> merijn: ???
03:59:08 <ollehar> merijn: how and where?
04:00:09 <merijn> ollehar: There's a paper called "Lazy Function State Threads" and the implementation is the ST monad in base
04:00:28 <ollehar> ok
04:00:40 <merijn> ollehar: The ST monad lets you write code that (internally) use memory mutation, but with an API that lets you convert it in a pure setting
04:00:50 <ollehar> will have a look
04:01:04 <merijn> ollehar: So, unlike IO, there is a perfectly safe, pure function "ST r -> r"
04:01:43 <merijn> ollehar: The vector package, for example, supports an ST based interface so you can write code that just mutates vectors in place, which can be used from pure code
04:01:48 <ollehar> merijn: but, you can still put this anywhere in your code?
04:02:16 <[itchyjunk]> if i am in ghci, can i quickly access help on function somehow? :x
04:03:04 <merijn> ollehar: Yes, because ST limits the visibility of mutation. With IO *everyone* can see you mutating variables, but STRef (the mutable ST variable) are limited (by the type system to a single computation which can't be observed externally
04:04:06 <merijn> ollehar: The simplest example would be: If I have a Vector and I implement a sort function that "copies the vector, then sorts by mutating the vector in place and then returns the sorted copy" then that function itself is obviously pure (same input gets same output and no one can see the mutation)
04:04:19 <ollehar> merijn: that doesn't help my case, where I'm looking to organize a code-base in a way to enhance testability.
04:04:34 <ollehar> Hm, or maybe it does :d
04:06:26 <Ariakenom_> Sounds like some effect library might be relevant
04:07:18 <merijn> Depends on the details of what you wanna do
04:08:23 <Ariakenom_> I'm not too familiar with them so I hope someone else can explain :p
04:08:41 * hackage PyF 0.8.1.2 - Quasiquotations for a python like interpolated string formater  https://hackage.haskell.org/package/PyF-0.8.1.2 (guibou)
04:09:04 <Ariakenom_> but mocking effects for testing is something they can do
04:11:33 <[itchyjunk]> http://zvon.org/other/haskell/Outputprelude/zipWith_f.html
04:11:53 <[itchyjunk]> how to read (a->b->c)->[a]->[b]->[c] ?
04:12:25 <merijn> Ariakenom_: You can do the same with tagless final style classes
04:12:58 <Ariakenom_> is that not an effect system? is there a terminology braekdown somewhere?
04:13:10 <f-a> [itchyjunk]: as a first approximation, a function that takes (a -> b -> c) (it iself a function), [a] and [b] to return [c]
04:13:20 <merijn> [itchyjunk]: zipWith takes a function with type "a -> b -> c", a list with type [a], and a list of type [b] and returns a list of type [c]
04:13:27 <merijn> Ariakenom_: Not necessarily?
04:13:59 <merijn> Ariakenom_: You can do similar things, but it's a distinction of what you care about
04:14:41 <merijn> Ariakenom_: tagless final classes are for encoding DSLs, whereas effects are concerned with what kinds of effects you use
04:14:56 <[itchyjunk]> hmmmm
04:15:09 <[itchyjunk]> what is an example of a function with type "a->b->c" ?
04:15:27 <merijn> Ariakenom_: So one is a matter of thinking operationally "what sort of effects do I do?" and the other denotationally "what do I want to mean"
04:15:31 <kenran> Using haskell+nix: if the cabal file has bounds, but they are not contained in the nix expression. So when building via nix, there is still a check performed meaning "do my haskell packages in nixpkgs satisfy the bounds? if not: stop". is that understanding correct?
04:15:34 <f-a> [itchyjunk]: 
04:15:36 <merijn> [itchyjunk]: a -> b -> c can be any type
04:15:51 <f-a> > zipWith (+) [1..3] [0..2]
04:15:53 <lambdabot>  [1,3,5]
04:15:59 <merijn> [itchyjunk]: So "(+) :: Int -> Int -> Int" would work, with a = Int, b = Int, c = Int
04:16:28 <merijn> [itchyjunk]: But "Char -> Bool -> String" would work too
04:17:03 <[itchyjunk]> hmm well in my head, + take a pair of int and spits out an it right? so i think i am not understanding why ints int->int->int and not just int->int
04:17:16 <[itchyjunk]> spits out an int*
04:17:23 <f-a> ichor: the first two are the parameters
04:17:27 <f-a> and the last one the result
04:17:38 <f-a> so length is 
04:17:43 <f-a> > :t +d length
04:17:45 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
04:17:50 <f-a> @t +d length
04:17:50 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
04:17:54 <f-a> @type +d length
04:17:55 <lambdabot> [a] -> Int
04:18:10 <f-a> take a list, return an Int
04:19:59 <[itchyjunk]> ah
04:20:59 <[itchyjunk]> so the notation [a]->a->b would mean it take `type [a]`, `type a` and returns `type b` ?
04:21:18 <f-a> yup, it takes a value of type xyz
04:21:39 <f-a> there is a bit more to it
04:21:43 <[itchyjunk]> so this notation extends always in the same way? a->a->b->c->[d] ?
04:21:50 <[itchyjunk]> thanks, this makes sense
04:21:55 <f-a> yeah
04:22:00 <f-a> if we want to be precise
04:22:06 <f-a> a -> b -> c
04:22:07 <f-a> is
04:22:09 <f-a> a -> (b -> c)
04:22:34 <f-a> so "takes an `a`, returns a function which takes a `b` and returns a `c`"
04:22:52 <f-a> it might seems useless now but it will come handy later
04:23:08 <[itchyjunk]> ah so its a composition of functions
04:23:25 <dminuoso> Not a composition.
04:23:30 <dminuoso> Its a function returning a function.
04:23:42 <dminuoso> Which we use to model function taking multiple arguments with.
04:23:50 <[itchyjunk]> hmm
04:23:53 <f-a> it should be called partial function application
04:24:07 <dminuoso> `f 1 2` is actually `(f 1) 2` which you can think of `first apply f to 1` and then `apply the resulting function to 2`
04:24:09 <f-a> you just provide one (the first) of the parameter
04:24:25 <dminuoso> f-a: No it should not, since in principle we dont have partial function application.
04:24:42 <dminuoso> It's still fully applied. All functions take exactly one argument in haskell
04:25:12 <[itchyjunk]> :O
04:27:29 <lortabac> I think both definitions are valid, it's fully applied because all functions take one argument, but it's partially applied because you can still apply the result to another value
04:28:52 <f-a> the Report seems more liberal in his lexicon than some haskellers
04:39:42 * hackage lightstep-haskell 0.4.0 - LightStep OpenTracing client library  https://hackage.haskell.org/package/lightstep-haskell-0.4.0 (DmitryIvanov)
04:49:00 <ollehar> Ariakenom_: Again, an effect system will not help the programmer in general to discipline the code-base.
04:49:36 <ollehar> Or to create as many pure functions as possible.
04:49:48 <ollehar> I'm trying to argue that the more pure functions you have in a code-base, the easier it is to test.
04:50:01 <ollehar> The ratio stateful/pure.
04:50:10 <Ariakenom_> ollehar: you can literally control which effects a section of code can perform
04:50:25 <ollehar> Ariakenom_: Yes :) And who is "you"?
04:51:04 <ollehar> E.g., all functions can have DB IO effect signature.
04:52:57 <Ariakenom_> ex if you are programmer A you can create an interface for programmer B that only allows certain things
04:53:38 <Ariakenom_> if you are you designing the program you can specify restrictions that you must follow later when you are implementing the program
04:55:42 <Ariakenom_> if your application is in a monad that you interpret and perform effects you can replace the interpreter with one that doesnt perform the effects. and run tests that way
04:57:22 <jollygood2> for example you can write your own IO-like type called STDIO that only allows printing to stdout and reading from stdin, while disallowing any other effects
04:59:18 <ollehar> Ariakenom_: true, good point
04:59:42 <ollehar> gotta learn haskell now :D to try
05:00:01 <Ariakenom_> ollehar: :D glad you were inspired. go forth and code!
05:00:22 <ollehar> jollygood2: yeah, that was the "tagless final style classes" that someone explained to me yesterday
05:00:58 * ollehar now back to work with 15 year old PHP web app
05:05:11 * hackage orgstat 0.1.7 - Statistics visualizer for org-mode  https://hackage.haskell.org/package/orgstat-0.1.7 (volhovm)
05:09:41 * hackage ansi-terminal-game 0.5.0.0 - sdl-like functions for terminal applications, based onansi-terminal  https://hackage.haskell.org/package/ansi-terminal-game-0.5.0.0 (fffaaa)
05:22:52 <f-a> should I put constraits in my "setup-depends" section too?
05:29:57 <boothead> Anyone using the katip -> datadog scribe?
05:31:11 * hackage text-show-instances 3.8.3 - Additional instances for text-show  https://hackage.haskell.org/package/text-show-instances-3.8.3 (ryanglscott)
05:31:20 <maralorn> kenran: No. The haskell infrastructure in nixpkgs ignores cabal bounds. It just builds everything with the version of every library which was in the used stack snapshot, or when the packages is not on stackage the newest hackage version when the hackage scrape happened.
05:31:47 <maralorn> kenran: In general in nixpkgs if something doesn‘t build under this conditions it will just be marked broken.
05:34:57 <maralorn> kenran: If you want the bounds respected you will have to let cabal do the creation of a buildplan. There is a project (sadly not integrated into nixpkgs) called haskell.nix which can build the dependencies with nix according to a given cabal build plan.
05:35:25 <maralorn> But I have never tried it, it never seemed worth it.
05:36:32 <maralorn> Overall I have great respect for the existing solutions, because the problem is really hard. Still the haskell+nixpkgs combination is very much not stellar.
05:37:29 <maralorn> With "it never seemed worth it" I mean: I found easier workarounds. I actually think the approach is the sanest way.
05:38:11 * hackage wuss 1.1.15 - Secure WebSocket (WSS) clients  https://hackage.haskell.org/package/wuss-1.1.15 (fozworth)
05:42:11 * hackage autoexporter 1.1.15 - Automatically re-export modules.  https://hackage.haskell.org/package/autoexporter-1.1.15 (fozworth)
05:46:11 * hackage mmsyn5 0.2.2.0 - Various additional operations on lists  https://hackage.haskell.org/package/mmsyn5-0.2.2.0 (OleksandrZhabenko)
05:50:41 * hackage mmsyn5 0.2.2.1 - Various additional operations on lists  https://hackage.haskell.org/package/mmsyn5-0.2.2.1 (OleksandrZhabenko)
05:51:20 <kenran> maralorn: Thanks! I wonder where the "missing dependency" message I get comes from then, though.
05:52:05 <maralorn> kenran: Can you linke to a paste of the error?
05:52:28 <kenran> The library `clay-0.13.1` has a test-suite (maybe that's the point here) dependency of `hspec` in quite tight version bounds. Of course one version of hspec exists in the nixpkgs-unstable branch, but it's newer. But it won't even start building.
05:52:40 <kenran> maralorn: I can, but I'll have to reproduce it first. Give me a minute.
05:53:31 <kenran> (I fixed it by using `haskell.lib.doJailbreak`, which removes version boundaries from packages. I don't really get why this would be a thing if nix just ignored all bounds)
05:55:00 <kenran> maralorn: https://pastebin.com/xc3bYTYd
05:56:04 <boxscape> if I type something like `let a = Id (f x) in ()`, am I right in thinking that the structure of a is `<thunk>` rather than `Id <thunk>`?
06:02:56 <LCRERGO> Hi, does anyone know a pandoc irc channel?
06:10:23 <lortabac> boxscape: you can try it in GHCI
06:10:55 <lortabac> 'let a = ...' and then ':sprint a'
06:11:09 <boxscape> ah, thanks
06:21:37 <jellostahps> was the haskell language created by haskel curry or by church and his students?
06:22:01 <mniip> neither
06:22:24 <mniip> haskell is much newer than both of those
06:22:41 * hackage derulo 1.0.7 - Parse and render JSON simply.  https://hackage.haskell.org/package/derulo-1.0.7 (fozworth)
06:22:57 <sshine> jellostahps, it was just named after him.
06:23:15 <jellostahps> who named it after him>
06:24:29 <mniip> he was very influential in development of lambda calulus, mathematical formalism, etc
06:25:05 <boxscape> The parts of the story I remember are that the Haskell committee members wrote a bunch of name ideas on a blackboard, and I think one of them was Curry but for some reason they then went with Haskell
06:25:34 <mniip> by then currying has already been a colloquially used word
06:26:02 <mniip> though, haskell is a kind of curried lisp if you think about it
06:29:41 * hackage mmsyn5 0.2.3.0 - Various additional operations on lists  https://hackage.haskell.org/package/mmsyn5-0.2.3.0 (OleksandrZhabenko)
06:31:24 <yushyin> https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/history.pdf 2.4 The first meetings § 'Choosing a Name'
06:36:26 <Taneb> Idle curiosity: on Hackage, what's the typeclass with the most instances?
06:37:21 <mniip> probably Eq
06:37:24 <maralorn> kenran: Well the bounds check there is done by the install script. It seems that I stand corrected.
06:37:55 <mniip> or perhaps Apply from singletons
06:41:12 * hackage lackey 1.0.10 - Generate Ruby clients from Servant APIs.  https://hackage.haskell.org/package/lackey-1.0.10 (fozworth)
06:41:35 <lortabac> haha, one package against the rest of Hackage
07:04:25 <tabaqui1> % :i toString
07:04:25 <yahb> tabaqui1: ; <interactive>:1:1: error: Not in scope: `toString'
07:04:34 <tabaqui1> % import Data.ByteString.UTF8
07:04:34 <yahb> tabaqui1: ; <no location info>: error:; Could not find module `Data.ByteString.UTF8'; Perhaps you meant; Data.ByteString.Char8 (from bytestring-0.10.8.2); Data.ByteString.Lazy (from bytestring-0.10.8.2); Data.ByteString.Lens (from lens-4.16.1)
07:04:42 <tabaqui1> err
07:04:44 <tabaqui1> anyway
07:05:10 <tabaqui1> can anyone check this out "toString "\239\191\190" == toString "\239\191\189"
07:05:30 <tabaqui1> I just found out that HDBC incorrectly converts my strings while using this library
07:06:31 <tabaqui1> fffe-ffff are not a valid UTF8 sequences, but utf8-strings decodes all of them into fffd
07:07:19 <tabaqui1> btw, quickcheck tested 400000 probes before hitting this one
07:08:34 <tabaqui1> glguy: ^
07:09:03 <tabaqui1> probably, I shouldn't use fffe as a possible test scenario, but maybe you would like to know this anyway
07:14:28 <tabaqui1> ah, I see that you explicitly excluded these chars from tests
07:14:41 * hackage json-feed 1.0.7 - JSON Feed  https://hackage.haskell.org/package/json-feed-1.0.7 (fozworth)
07:21:41 * hackage github-release 1.2.5 - Upload files to GitHub releases.  https://hackage.haskell.org/package/github-release-1.2.5 (fozworth)
07:24:55 <dmwit> tabaqui1: What were you expecting it to do with invalid sequences, if not put the codepoint created to represent invalid sequences?
07:33:35 <tabaqui1> dmwit: well, then it's in HDBC library
07:34:07 <tabaqui1> somehow Eve sends "ffff" as input string and HDBC writes this string into sqlite3 database
07:34:15 <tabaqui1> *encodes and writes
07:34:52 <dmwit> I don't know what Eve is, but if it's sending ffff, then it's probably not sending UTF-8 and you probably shouldn't be pretending it is.
07:35:08 <tabaqui1> right, I should raise an error
07:35:31 <tabaqui1> but not encode it via UTF8 and write into a database
07:35:41 <dmwit> Maybe. Or maybe you should treat it as a ByteString instead of text.
07:35:46 <dmwit> I don't know.
07:36:10 <tabaqui1> but I'm not using Python here
07:36:24 <dmwit> I have no idea what that is supposed to mean.
07:36:41 * hackage mmsyn5 0.3.0.0 - Various additional operations on lists (some with intermediate Monads)  https://hackage.haskell.org/package/mmsyn5-0.3.0.0 (OleksandrZhabenko)
07:36:45 <Taneb> tabaqui1: dmwit is suggesting you use the "bytestring" Haskell library
07:36:51 <tabaqui1> I cannot interpret Text as Bytestring in Haskell
07:37:05 <Taneb> Rather than the String type or the "text" Haskell library
07:37:38 <dmwit> Hold up.
07:37:50 <dmwit> When you say "Eve sends 'ffff'", what *precisely* do you mean by that?
07:38:30 <dmwit> Do you mean, "I receive the bytes 0xff, 0xff on the wire." or "I receive the UTF-8 encoding of the 0xffff codepoint on the wire." or what?
07:39:15 <tabaqui1> Somehow I receive ("\65535" :: Text) data
07:39:45 <tabaqui1> in my specific case, I get it by Quickcheck "pack <$> getUnicodeString"
07:41:00 <tabaqui1> I doubt, that I cannot get ffff in other and more dangerous way
07:41:54 <dmwit> I am beyond lost.
07:42:11 * hackage ratel 1.0.9 - Notify Honeybadger about exceptions.  https://hackage.haskell.org/package/ratel-1.0.9 (fozworth)
07:42:37 <dmwit> Those three functions come from text, base, and QuickCheck respectively. Eve doesn't appear to be in the picture at all unless it's a codename I've never heard before for one of those three.
07:42:53 <tabaqui1> I have such test case "property $ \(UnicodeString t) -> do dumpIntoSqlite3 (T.pack t); readFromSqlite3 === T.pack t"
07:43:29 <tabaqui1> Eve - is a evil guy in cryptography
07:43:32 <tabaqui1> Alice, Bob, Eve
07:44:09 <dmwit> What is dumpIntoSqlite3, readFromSqlite3?
07:44:17 <dmwit> This question is so vague and incomplete it's impossible to actually help you.
07:44:41 * hackage ratel-wai 1.1.1 - Notify Honeybadger about exceptions via a WAI middleware.  https://hackage.haskell.org/package/ratel-wai-1.1.1 (fozworth)
07:44:52 <tabaqui1> allright, I'll make a paste
07:47:49 <geekosaur> I'm still unclear as to whether this is an invalid sequence for the encoding, or an invalid codepoint after decoding
07:48:18 <tabaqui1> the first one
07:48:22 <geekosaur> > '\65535'
07:48:24 <lambdabot>  '\65535'
07:48:38 <tabaqui1> Unicode has no fffe-ffff legal characters
07:48:50 <geekosaur> right, that's the secon d option
07:49:02 <geekosaur> the first option is e.g. you get the bytes 0xff, 0xff in utf8
07:49:12 * hackage rattletrap 9.0.7 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-9.0.7 (fozworth)
07:49:12 <tabaqui1> ok
07:49:20 <geekosaur> which is illegal utf8, so cant be said to encode a codepoint at all
07:49:29 <tabaqui1> UTF-8 can encode *any* characters
07:49:44 <geekosaur> you seem confused
07:50:06 <tabaqui1> utf8 is a function Int -> ByteString
07:50:13 <geekosaur> what you said is not relevant, of course utf8 can encode any valid codepoint, but there are byte sequences that are not valid utf8
07:50:16 <tabaqui1> and it accepts any positive int
07:50:46 <geekosaur> (they may be valid in extensions to utf8, but iirc 0xff, 0xff is incomplete in those encodings)
07:50:53 <tabaqui1> sure, so encodeUtf8 accepts any positive int, while decodeUtf8 accepts only utf-8 legal bytestrings
07:53:15 <jellostahps> foldl (*) 2 [1,2,3] .. how is the (*) operating i this fold?
07:53:53 <lavalike> > foldl f x [y,z,w]
07:53:55 <lambdabot>  f (f (f x y) z) w
07:54:18 <lavalike> jellostahps: like that ^
07:54:19 <geekosaur> wrapping an operator in parentheses makes iti prefix
07:54:27 <geekosaur> > (*) 2 3
07:54:29 <lambdabot>  6
07:54:34 <jellostahps> How could (*) be expanded in this context
07:54:42 <lavalike> simple substitution
07:54:52 <lavalike> f=(*) x=2 y=1 z=2 w=3
07:56:05 <jellostahps> foldl (\x i -> x*i) 2 [1,2,3] . Is that what its doing?
07:56:32 <berndl> jellostahps: that fold does ((2 * 1) * 2) * 3)
07:56:35 <dmwit> jellostahps: yes
07:56:48 <dmwit> > foldl (*) 2 [1,2,3] :: Expr
07:56:51 <lambdabot>  2 * 1 * 2 * 3
07:57:04 <jellostahps> great thx
07:57:08 <dmwit> > foldl (*) w [x,y,z]
07:57:10 <lambdabot>  w * x * y * z
08:06:41 * hackage salve 1.0.8 - Semantic version numbers and constraints.  https://hackage.haskell.org/package/salve-1.0.8 (fozworth)
08:09:18 <tabaqui1> dmwit: slightly different behavior, but it is still actual
08:09:20 <tabaqui1> https://pastebin.com/XH7hNQ5m
08:10:16 <tabaqui1> about the comment on line 15: Arbitrary instance of UnicodeString *can* give you "\65535"
08:11:11 * hackage strive 5.0.9 - A client for the Strava V3 API.  https://hackage.haskell.org/package/strive-5.0.9 (fozworth)
08:20:43 <siraben> With all the variety of effect systems, is MTL still the fastest?
08:21:37 <maerwald> I can't recall any extensive performance analysis. Only stuff that people write in their own papers
08:28:58 <lukelau> I want to link in an object file into my haskell executable, which has symbols which aren’t referenced by the haskell executable. However ghc or ld seems to be stripping it out each time. I’m linking it via `ghc Main.hs -o Main -L. -lmylibrary`
08:29:19 <lukelau> I’ve also tried just doing it statically with `ghc Main.hs mylibrary.o -o Main`
08:34:47 <geekosaur> lukelau, the .o should work. -l would work for a .so but not for a .a
08:35:42 <lukelau> I’m on a mac so I compiled it with `clang -shared mylibrary.c -o libmylibrary.dylib`
08:36:07 <geekosaur> unless ghc is passing certain stripping options to the linker, but I don't think it does that. (might need -v to see what it's sending to the link step)
08:36:53 <geekosaur> .dylib should be the same, it can't strip symbols from it, they're wired in
08:37:45 <geekosaur> what are you doing to test whether the symbols are present?
08:38:26 <geekosaur> also are they present if you link it into a small C program?
08:38:39 <lukelau> I can see dead_strip being passed in some -Wl options
08:38:41 * hackage mmsyn5 0.4.0.0 - Various additional operations on lists (some with intermediate Monads)  https://hackage.haskell.org/package/mmsyn5-0.4.0.0 (OleksandrZhabenko)
08:38:58 <lukelau> I’m running `symbols`, sometimes `objdump -syms`
08:39:06 <lukelau> And yeah it links into a c program
08:39:12 <lukelau> Trying to create a test case
08:39:37 <geekosaur> oh, macs might allow dead_strip on dylibs (tbh that's kinda bad as it defeats sharing to some extent)
08:39:58 <geekosaur> btu macs have those stupid table size limitations so ghc minimizes everything it can
08:40:39 <geekosaur> "must pretend a desktop machine is as limited as an iphone"
08:41:28 <Guest10183> hey anyone here i could need some help im kinda stuck 
08:41:48 <lukelau> geekosaur: I’ll give it a shot on linux, see what happens
08:42:13 <lukelau> but -Wl,-force_load,mylibrary.o didn’t work either
08:42:41 * hackage mmsyn5 0.4.0.1 - Various additional operations on lists (some with intermediate Monads)  https://hackage.haskell.org/package/mmsyn5-0.4.0.1 (OleksandrZhabenko)
08:44:30 <Guest10183> when i use atome as  an editor  for haskell and illl try to compile it on ghci there is alltime an error which says i missed brackets ? could someone pls help i need it for my university im in my first year so im kinda new to this  
08:44:38 <mpickering> lukelau: What about `-fwhole-archive-hs-libs`?
08:45:16 <Guest10183> but when i try to code in prelude its working just fine 
08:47:00 <dsal> Guest10183: hard to guess what you're doing
08:48:01 <lukelau> mpickering: that seems to only prevent dead_strip in the hs libraries
08:48:12 <Guest10183> there is no certain thing i try to do its for every code i just try compile let me post the error rq 
08:48:19 <mpickering> lukelau: Are you using cabal or GHC directly?
08:48:32 <lukelau> also for some reason on linux the verbose option is different, it doesn’t show the exact linker command used
08:48:37 <lukelau> ghc direct
08:48:46 <mpickering> hmm it should do?
08:48:51 <mpickering> increase verbosity higher?
08:49:03 <mpickering> then grep GHC's source code for the bad option
08:49:22 <lukelau> ah got it
08:49:33 <lukelau> not sure what I changed but the symbol is here now
08:50:44 <lukelau> yeah it is the -fwhole-archive-hs-libs flag. That seems to affect not just the hs-libs but all libs in general
08:51:06 <lukelau> time to tattoo that flag somewhere on my hand
08:51:10 <mpickering> what are you implementing?
08:51:21 <mpickering> I looked at your blog post to remember what the flag was called..
08:52:09 <lukelau> I’m trying to statically or dynamically link a library to an executable, which uses llvm-hs’s OrcJIT
08:52:21 <lukelau> so that then code compiled via the jit can call this library
08:52:58 <geekosaur> Guest10183, one thing to watch out for is that code in a file must always be in functions; ghci (what you miscalled "prelude") allows arbitrary expressions
08:53:24 <lukelau> It would be nice if you could only strip the hs-libs and still link in the other stuff, without having to link in everything
08:53:26 <cocreature> lukelau: have you seen my blogpost on that? admittedly I’ve forgotten the details myself but at some point that worked :)
08:53:32 <Guest10183> geekosaurcan you give me an example ?
08:53:34 <geekosaur> there is a special "function" named "main" which will be run when you run the program
08:54:04 * geekosaur is going to have to leave shortly
08:54:09 <lukelau> cocreature: I have it open at the moment haha
08:54:25 <geekosaur> but I'm guessing as to what you might be running into, since you haven't given anything like enough information
08:54:44 <Guest10183> geekosaur sorry im really new to this 
08:55:22 <geekosaur> you can't, for example, have a putStrLn at top level, it needs to be inside main or some other function (ignoring for the moment definitions of "function")
08:55:54 <cocreature> lukelau: hopefully it’s at least of some use :)
08:56:15 <geekosaur> python or javascript would let you do thaat; c, c++, and java force you to put it in a function (and in java's case, a class) like haskell does
08:57:14 <dsal> Guest10183: It'd be easier to discuss your issue if you posted the code and error.
08:58:04 <Guest10183>  Parse error: module header, import declaration
08:58:12 <Guest10183> this is just to give an example 
08:58:49 <Guest10183> shouldnt give it the list in ghci instead of an error 
08:58:52 <Guest10183> ? 
08:58:54 <lukelau> cocreature: It was! Explained the symbolresolver stuff pretty well. although i think the api for that has changed since
08:59:55 <lukelau> also either way I’m now getting duplicate symbol errors when linking with -fwhole-archive-hs-libs because for some reason two different versions of the network package is getting linked in twice
09:00:13 <dsal> Guest10183: We can't help you if we have to guess what you're doing.  Paste your code and error here:  https://pastebin.com/
09:10:11 * hackage tmp-postgres 1.5.0.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.5.0.0 (JonathanFischoff)
09:18:00 <glguy> tabaqui: utf8-string emits the replacement character u+fffd when you give it bad input
09:19:10 <kingkong63> hey guys is anyone german ? and might help me real quick ? also is there a way to private chat im a complete beginner and im scared of embarass myself 
09:20:12 <tsahyt> german no, but I speak german if that helps. also if it's a haskell related question, just ask here.
09:21:06 <dsal> kingkong63: We've all asked embarrassing questions.  Don't worry about that part.  But lots of people here are helpful.
09:24:51 <dsal> I'm trying to ffi, and it's like.     x <- domystuff.  *ghci exits without message*  That's  pretty insulting.
09:25:34 <EvanR> when you walk out of haskell you may not return
09:26:08 <EvanR> in C code always check error conditions and make sure you don't do anything invalid
09:27:01 <dsal> Yeah.  I was hitting some assertions before (in the way we do it in our code, which is a pleasant crash).  Now it's just like I FFI'd exit(0)
09:27:52 <kingkong63> my question without coding anything what editor do i need and how do i compile with ghci pls dont joke on me xD
09:27:54 <lukelau> cocreature: do you know why https://llvm.org/doxygen/Support_8h.html#a6fc1331c1a6d2cc6f0fda94f4a4636f9 needs to be called to find static symbols?
09:28:58 <dsal> kingkong63: Use whatever editor you're most comfortable with.  GHCI isn't a compiler, but you might try stack for getting projects bootstrapped quickly.  Or you can do lower-level ghc on simple files.
09:29:26 * dsal sigh
09:29:28 <cocreature> lukelau: I don’t sorry
09:29:54 <dsal> My problem was that there's a C++ function I have to call before I can call my thing.  If I don't call that function first, something just exits without message.  Obviously.
09:30:05 <kingkong63> well im using windows and i dont have any idea how to install stack and all that kind of tings to get haskell running tbh
09:30:21 <EvanR> nice API
09:30:28 <kingkong63> i mean i read the tutorial but i might be to stupid to understand it
09:30:33 <dsal> Which tutorial?
09:30:43 <kingkong63> on haskell.org
09:31:25 <dsal> I don't know anything about Windows.  There's a howto here:  https://docs.haskellstack.org/en/stable/README/
09:31:32 <tsahyt> There should be an installer
09:31:34 <dsal> Not everyone likes stack, but it at least gets you a skeleton setup you can build from.
09:31:34 <tsahyt> haskellstack.org links this: https://get.haskellstack.org/stable/windows-x86_64-installer.exe
09:31:48 <kingkong63> yeah in installed it 
09:32:20 <kingkong63> but how do i load it in
09:32:50 <kingkong63> sorry dont want to waste anyones time 
09:33:18 <tsahyt> does windows not have some sort of shell or command line?
09:33:27 <tsahyt> I haven't used it in well over a decade, but afaik such a thing should exist.
09:34:36 <kingkong63> like cmd? 
09:34:58 <tsahyt> for example
09:35:04 <kingkong63> yeah
09:35:07 <kingkong63> cmd 
09:35:15 <tsahyt> you'll need the stack executable in your path of course. but then you should be able to run stuff like stack setup and stack build etc
09:36:11 * hackage yaya 0.2.1.2 - Total recursion schemes.  https://hackage.haskell.org/package/yaya-0.2.1.2 (sellout)
09:37:11 * hackage yaya-unsafe 0.1.1.2, yaya-hedgehog 0.1.2.1 (sellout): https://qbin.io/some-online-e0aj
09:45:24 <kingkong63> i guess im just to stupid ...  cant get it running 
09:45:39 <EvanR> windows is a tough nut to crack
09:46:08 <kingkong63> yeah looks like 
09:48:11 * hackage proto3-wire 1.1.0 - A low-level implementation of the Protocol Buffers (version 3) wire format  https://hackage.haskell.org/package/proto3-wire-1.1.0 (GabrielGonzalez)
09:50:37 <jgt> makes me sad how many people must think themselves stupid, instead of thinking Windows is stupid
09:51:15 <EvanR> yep
09:51:17 <[exa]> :]
09:51:24 <kingkong63> i mean i have no other choise for than using windows my laptop cant run linux for some reason 
09:52:04 <kingkong63> my english is so bad i just recognize 
09:52:28 <EvanR> google translate ftw
09:52:57 <EvanR> also there's probably a semidead #haskell-de
09:53:09 <jgt> kingkong63: your English is fine; don't stress yourself out
09:55:39 <kingkong63> well that channel is dead i gues 
09:55:41 * hackage proto3-suite 0.4.0.0 - A low level library for writing out data in the Protocol Buffers wire format  https://hackage.haskell.org/package/proto3-suite-0.4.0.0 (GabrielGonzalez)
09:55:42 <kingkong63> guess  *
09:56:23 <jgt> kingkong63: did you read this? https://docs.haskellstack.org/en/stable/README/
09:56:38 <jgt> kingkong63: I don't work on Windows, but there appears to be an installer
09:56:45 <jgt> this _might_ be the easiest way for you to get going
09:57:09 <jgt> I don't use Stack though, so I'm not 100% sure
09:57:38 <dsal> Windows makes me feel stupid. I've managed to avoid it my whole life.
09:58:07 <tsahyt> WSL might be another approach
09:58:26 <kingkong63> @jgt well yeah i read it but i didnt really understand all of it i installed it but what  next thats the question 
09:58:26 <lambdabot>  Parse failed: TemplateHaskell language extension is not enabled. Please add ...
09:58:48 <dsal> That's an interesting one
10:00:42 <cheater> hi
10:00:55 <cheater> can someone tell me why the tax function would return 0 for negative inputs? http://paste.ubuntu.com/p/f8Nq5X3989/
10:00:57 <jgt> kingkong63: just below the installation instructions, there's a quick start guide
10:01:01 <cheater> i'm kind of lost here.
10:04:13 <kingkong63> @jgt is ghci and ghc the same thing ? just curious 
10:04:13 <lambdabot>  Parse failed: TemplateHaskell language extension is not enabled. Please add ...
10:04:36 <jgt> kingkong63: you don't need to stick an @ in front of my name here on IRC
10:04:41 <dsal> kingkong63: (your @ is triggering  lambdabot)
10:04:51 <kingkong63> oh okay 
10:04:57 <dsal> kingkong63: ghci is an interactive shell you can play around in.  Like lambdabot or yahb.  ghc is a compiler.
10:05:00 <kingkong63> sorry 
10:05:01 <jgt> kingkong63: GHC is the Glasgow Haskell Compiler. This the compiler.
10:05:08 <kingkong63> wow
10:05:09 <kingkong63> wait
10:05:10 <kingkong63> wait
10:05:11 <kingkong63> wait
10:05:13 <jgt> kingkong63: GHCi is an interactive prompt for it
10:05:14 <dsal> please don't do that
10:05:17 <EvanR> cheater: sure *computes the results like dr manhattan*
10:05:17 <kingkong63> okay it made click i guess
10:06:57 <cheater> EvanR: sorry? :)
10:07:04 <EvanR> cheater: because you wrote the algorithm assuming amount is not negative and should accept whatever happens otherwise :)
10:07:12 <cheater> ?
10:07:31 <cheater> that made no sense evan :)
10:07:57 <EvanR> neither does passing in negative amount
10:08:41 * hackage grpc-haskell-core 0.0.0.0 - Haskell implementation of gRPC layered on shared C library.  https://hackage.haskell.org/package/grpc-haskell-core-0.0.0.0 (GabrielGonzalez)
10:10:29 <EvanR> cheater: if remaining is negative, taxable is that negative amount, newRemaining is zero
10:10:54 <EvanR> you can also use Debug.Trace to look at values as they are evaluated
10:16:43 <jellostahps> If I have a list [2,3,4] then whats the result of this: foldl (\x i -> (i:head xs):xs) [ [ ] ] xs ?
10:17:04 <EvanR> type it into ghci and see?
10:17:05 <jellostahps> is it [ [4,3,2], [2,3] , [2], [] ]?
10:17:09 <dsal> > let xs = [2,3,4] in  foldl (\x i -> (i:head xs):xs) [ [ ] ] xs
10:17:11 <lambdabot>  error:
10:17:12 <lambdabot>      • No instance for (Num [Integer]) arising from a use of ‘e_1234’
10:17:12 <lambdabot>      • In the expression: e_1234
10:17:37 <jellostahps> Why is there an error?
10:17:52 <jellostahps> and is that what I type in ghci exactly to test it?
10:17:58 <dsal> Because Num [Integer] is not a num.
10:17:58 <EvanR> sure
10:18:31 <EvanR> there is an error because you treated the types inconsistently
10:18:42 <jellostahps> wheere specifically?
10:18:57 <EvanR> in the lambda, possible in the [[]]
10:19:03 <EvanR> depending on what you wanted to do
10:19:14 <jle`> jellostahps: xs is supposed to be a list of lists
10:19:26 <jle`> :t foldl (\x i -> (i:head xs):xs) [[]]
10:19:28 <lambdabot> error:
10:19:28 <lambdabot>     • Variable not in scope: xs :: [[a]]
10:19:28 <lambdabot>     • Perhaps you meant one of these:
10:19:40 <jle`> :t \xs -> foldl (\x i -> (i:head xs):xs) [[]]
10:19:41 <lambdabot> Foldable t => [[a]] -> t a -> [[a]]
10:19:43 <jellostahps> >let xs =[2,3,4] in foldl(\x i -> (i:head x):x) [ [] ] xs
10:19:55 <jle`> do you see from the type that it is supposed to be a list of lists?
10:20:03 <jellostahps> yes
10:20:11 <jle`> so you cannot apply that to a list of non-list
10:20:31 <jellostahps> I changed it to 'x' instead of xs, 'x' is a list of lists
10:20:54 <kingkong63> okay i guess i got it 
10:21:00 <jle`> jellostahps: what are you trying to say?
10:21:30 <jle`> :t foldl (\x i -> (i:head x):x) [[]]
10:21:31 <lambdabot> Foldable t => t a -> [[a]]
10:21:38 <jle`> so in that case yeah, it can take a normal list
10:21:41 <jellostahps> That I just made a typo
10:21:49 <jle`> > foldl (\x i -> (i:head x):x) [[]] [2,3,4]
10:21:51 <lambdabot>  [[4,3,2],[3,2],[2],[]]
10:21:52 <kingkong63> one more question how do i compile with ghc ? do i need to implement the command $ghc -o into the code or how does it work
10:21:52 <jellostahps> But yeah it works now
10:21:54 <jle`> jellostahps: what was the typo?
10:22:19 <jellostahps> I had 'xs' instead of just 'x' inside the brackets
10:22:34 <jle`> ah, i see
10:22:44 <jle`> but yeah, next time, you have the power of ghci at your disposal :)
10:22:49 <jle`> you can see what these do in ghci
10:22:55 <jle`> you would type it without the ">" though
10:23:06 <jellostahps> now i know how to use let-in thx
10:23:19 <jle`> kingkong63: it deoends on what you want to do exactly; you can compile one-off files with 'ghc' executable, but it won't have access to any othe rlibraries or stuff
10:23:28 <jellostahps> > foldr (\x i -> (i:head x):x) [[]] [2,3,4]
10:23:30 <lambdabot>  error:
10:23:30 <lambdabot>      • Occurs check: cannot construct the infinite type: a ~ [[a]]
10:23:30 <lambdabot>        Expected type: [[a]]
10:23:41 * hackage grpc-haskell 0.0.1.0 - Haskell implementation of gRPC layered on shared C library.  https://hackage.haskell.org/package/grpc-haskell-0.0.1.0 (GabrielGonzalez)
10:24:01 <jellostahps> > foldr (\i x -> (i:head x):x) [[]] [2,3,4]
10:24:04 <lambdabot>  [[2,3,4],[3,4],[4],[]]
10:24:07 <kingkong63> jlei want to compile from atom for example 
10:24:09 <jellostahps> There we go :p
10:24:36 <jle`> ah, i'm not sure how atom works, sorry
10:24:42 <jle`> but you might be able to search for atom integration with haskell
10:24:54 <jellostahps> haskell exam soon, I learned folds so well from the group here and they are so darn powerful, so thank you.
10:26:18 <jle`> jellostahps: best of luck :)
10:26:29 <jellostahps> thanks!
10:44:23 <dsal> I feel like I'm lensing poorly.  I keep doing this      f $ x ^. thing
10:44:31 <dsal> Is there a lensier way to do that?
10:49:38 <tsahyt> x ^. thing . to f perhaps?
10:49:50 <tsahyt> though that's probably either wrong or it's abusing to
10:50:32 <dsal> Hmm...  That's interesting.  I'm still a bit of an optical noob.
10:52:22 <jle`> `x ^. thing . to f` is the same, but nothing is wrong with f (x ^. thing), or f (view thing x)
10:52:37 <jle`> f . view thing $ x,   view (thing . to f) x, etc.
10:53:07 <jle`> dsal: ah, there's also views
10:53:13 <jle`> views thing f x
10:53:25 <jle`> but i think doing the normal function application seems a bit clearer
10:54:43 <dsal> Yeah.  I was mainly  wondering if there were a clear place to put the "f ." while using ^.
10:55:24 <dsal> I also keep typing =  for .~
10:59:05 <dsal> Heh, or ~.
11:03:14 <jgt> kingkong63: does Atom give you a terminal? You will need to get comfortable using a terminal.
11:11:51 <tabaqui1> yeah, right Data.ByteString.UTF8.fromStrings accepts incorrect unicode
11:12:00 <tabaqui1> *fromString
11:12:40 <tabaqui1> and from other side, Test.QuickCheck.getUnicodeString can generate incorrect unicode
11:25:28 <xujaan> hi
11:26:53 <jle`> hello
11:58:53 <electricityZZZZ> so is anyone following rust async developments? it looks like the async execution is 'cold' which means (i think?) that rust async is essentially nonstrict? so rust is now like haskell, and i need to know how to debug the equivalent of thunk leaks? this development is oddly pushing me towards haskell...
11:59:56 <cheater> EvanR: hmm, why is newRemaining zero?
12:01:02 <cheater> code again http://paste.ubuntu.com/p/f8Nq5X3989/
12:03:14 <cheater> in the first iteration of the fold, we have taxForBand = taxable * 0 / 100, so newRemaining = remaining - 0. in the second iteration, we have taxForBand = taxable * 2 / 100 = remaining * 2 / 100, so newRemaining = remaining - remaining * 2 / 100 = remaining * 98 / 100. etc.
12:13:44 <tabaqui1> glguy: yeah, sorry, I missed your message
12:14:56 <tabaqui1> utf8-string decodes bad input appropriate, but it does nothing on *encoding* bad unicode
12:15:09 <tabaqui1> *in appropriate way
12:15:43 <gaze__> It seems like iteratees are somewhat out of fashion. What has replaced them?
12:15:59 <cheater> conduit?
12:16:05 <cheater> (i don't know)
12:16:08 <merijn> tabaqui1: "encode bade unicode" <- what does that mean?
12:16:11 <tabaqui1> anyway, I just sent a pull request into QuickCheck to prevent generating chars of NotAssigned category
12:16:20 <merijn> gaze__: iteratees has been out of fashion for years :p
12:16:37 <tabaqui1> merijn: encode "\xffff", for examle
12:16:39 <gaze__> Well you know, I pop in and out of this community.
12:16:49 <gaze__> What’s the thing to do now merijn
12:17:00 <merijn> gaze__: conduit and pipes are the main successors, there's also machines and streamly which I've heard good things about, but not used
12:17:15 <gaze__> Fab. Thanks!
12:17:21 <merijn> gaze__: Conduit probably has the largest mindshare in the ecosystem
12:17:42 <tabaqui1> merijn: * fromString "\xffff"
12:17:43 <merijn> gaze__: Considerably easier API than iteratees too :p
12:18:26 <tabaqui1> this call accepts invalid input and results in valid output
12:18:41 <merijn> tabaqui1: I'm not sure what that means. utf8 by definition can encode all unicode, so I'm confused how you could have "bad unicode"
12:18:54 <cocreature> conduit is kind of the “I just wanna get shit done” option. it’s not super fancy but it does its job quite well, has a fairly simple API and there are a lot of libraries that integrate with it
12:19:12 <tabaqui1> in this case "utf8 can encode all unicode but not only unicode"
12:19:35 <tabaqui1> by standard, there are 66 invalid charactars in unicode
12:20:10 <tabaqui1> I dunno, imagine that you have logarithm function that can deal with negative integers
12:20:24 <MarcelineVQ> merijn: streamly is pretty nice for my tiny brain
12:21:22 <tabaqui1> like "strangeLog|n>0 === ln" and "strangeLog|n<=0 == 0"; would you place this function in Data.Math under the name "logarithm"?
12:21:24 <tabaqui1> I doubt
12:42:00 <olle> what you guys think about this: a project's folder structure should separate between pure modules and stateful modules?
12:42:17 <olle> or modules that use IO and those that don't
12:42:53 <merijn> olle: I don't think that's a very useful separation, tbh
12:43:01 <olle> because?
12:43:42 <merijn> olle: Well, why would that separation make sense to begin with?
12:44:01 <olle> merijn: testing purpose, for example
12:44:21 <merijn> Not to say there aren't cases where it makes sense, but I think it's no very useful generally
12:44:35 <apostaaat> Is there any difference between infix and normal notation? Speed or something?
12:44:47 <olle> hm
12:44:49 <merijn> Why does "how modules are organised" affect testing?
12:45:01 <merijn> apostaaat: Eh, no, why would it affect speed?
12:45:04 <olle> merijn: functions with side-effects need mocking
12:45:25 <merijn> Why?
12:46:32 <apostaaat> merjin: idk either, but one guy told that infix notation is more correct
12:46:58 <merijn> apostaaat: infix vs prefix is syntactical only
12:49:15 <monochrom> That guy needs to be confronted and challenged on what the even hell do they mean "more correct".
12:49:36 <olle> merijn: merijn because you want to test the glue code without testing the side-effect code
12:51:53 <merijn> Why does that require mocking the IO functions? You can call the glue code without the IO code, and if you can't then why are you even testing them separately?
12:54:38 <Athas> Even if such a distinction was useful for testing, I think it is less important than making the folder structure resemble the conceptual design of the program.
12:55:07 <Athas> Also, there is no such thing as a "pure" or "stateful" module.
12:55:26 <merijn> Athas: Which is why the difficulty of hs-boot files is such a travesty >.<
12:57:00 <Athas> When I have raised an army and conquered Haskell, I will ban circular dependencies across modules.
12:57:30 <cocreature> meanwhile merijn will make GHC support circular deps without hs-boot files
12:58:20 <merijn> Years from now people will look to this point in time to see the reason why Denmark and the Netherlands are in a constant state of war...
12:59:07 * cocreature takes a photo of his screen displaying this channel to remember this point in time
13:01:48 <monochrom> My sworn allegiance is with QE2 of Canada who is also of England which has a long historic allegiance with the Netherlands so I'm afraid I have to join merijn!  Plus I love fixpoints.
13:03:22 <merijn> England a long historic allegiance with the Netherlands? Methinks your world history has...glossed over some things :p
13:04:13 <monochrom> I glossed over all that part before William the Orange became co-monarch of England :)
13:04:53 <evelyn> this is getting into still-raw bits of history in Britain and its neighbours
13:05:24 <merijn> evelyn: We already went there in -offtopic :p
13:05:54 * Rembane_ hands out swords
13:06:07 <Haskbie> foldl (+) 0 a is equal to foldl1 (+) a right?
13:06:39 <merijn> Haskbie: The latter crashes in some cases :p
13:06:47 <merijn> So the former is always better
13:07:05 <monochrom> Yeah, exercise: Find out how to crash it.
13:07:12 <monochrom> Crash and trash.
13:07:20 <Haskbie> empty list? 
13:07:27 <merijn> Haskbie: Correct
13:31:17 <mjrosenb> ugh, I have run afoul something... which is causing the memory usage of this code to get far higher than it should be.
13:33:02 <sm[m]> Time to profile mjrosenb
13:34:26 <sm[m]> Or identify the relevant commit if that’s quicker  I suppose
13:34:32 <mjrosenb> so, I have do  {logs <- getLogs; let logLines = lines logs; let blocks = getBlocks logLines; classes <- mapM classifyM blocks; print (length blocks) }
13:34:45 <ovitus> ghc: Network.Socket.sendBuf: does not exist (Connection refused)
13:34:53 <ovitus> anyone know why I'm getting that error message?
13:35:45 <dsal> @where void
13:35:45 <lambdabot> I know nothing about void.
13:35:46 <mjrosenb> where getBlocks :: [String] -> [[String]], and it discards about 90% of the lines, and bundles the rest of the lines together.  classifyM just extracts two lines from the block, or prints an error message if it can't.
13:35:53 <dsal> lambdabot knows nothing about nothing
13:36:19 <sm[m]> you’re reading all the logs into memory at once, it looks like
13:36:20 <mjrosenb> for some reason, the mapM classifyM blocks is causing the memory usage of the program to increase by about 16x
13:36:24 <geekosaur> @index void
13:36:24 <lambdabot> Foreign.Marshal.Error, Foreign.Marshal, Foreign, Foreign.Safe, Foreign.Marshal.Safe, Data.Functor, Control.Monad
13:37:50 <sm[m]> mjrosenb: I’ll hazard a further guess it has been working up to this point thanks to lazy IO, which is fragile, and a robust solution will use a streaming lib like conduit
13:38:00 <mjrosenb> right.  what I can't figure out is why filtering out some of the lines is causing stuff that's normally gc'd to be retained.
13:38:38 <mjrosenb> yeah, I chose haskell for this specifically because of the lazy IO, which has always done what I wanted in the past.
13:39:02 <monochrom> mapM is going to take up much memory for most monads.
13:40:17 <mjrosenb> mmm, I should not hold onto a reference to blocks while mapM runs.  it is *not* helping.
13:40:54 <merijn> Lazy IO is terrible, tbh should be avoided at almost any cost, imo
13:41:23 <mjrosenb> in general, I agree.
13:41:51 <merijn> mjrosenb: Anyway, in the category "more constructive feedback" I do agree with sm[m] that 1) conduit is great for this and 2) it's super easy to use
13:42:09 <tabaqui1> just debugging my code that uses HDBC - "Commands out of sync;". Damn on you, lazy IO!
13:42:13 <mjrosenb> for "I want to know what is in this many gigabyte log file, but it doesn't need to be used in production", it is great until it isn't.
13:42:51 <merijn> mjrosenb: tbh, with conduit half the time it's not much more complicated than replacing mapM with "Conduit.mapM" :)
13:43:16 <mjrosenb> that's good to hear.
13:43:36 <merijn> mjrosenb: What does your input look like?
13:43:41 <sm[m]> how could mjrosenb rewrite this particular snippet to be lazy IO friendly I wonder - ooh
13:44:00 <mjrosenb> I will definitely look into that if I decide to keep this code around now that I have the results that I need.
13:44:01 <merijn> ok, just filtering a bunch of lines
13:44:23 <mjrosenb> it is 500 mb of logs from a java webserver, and I'm pulling out very specific stack traces.
13:44:33 <merijn> mjrosenb: And your filtering is just some boolean predicate function?
13:45:06 <mjrosenb> there's a boolean predicate for the start, then a second boolean predicate for how many lines to take for the stack trace
13:45:16 <dsal> I've got a with function that takes a callback.  Is there a better way to write something than    with thing1 $ \x -> with thing2 $ \y -> f (x,y)   ?
13:45:28 <mjrosenb> and it doesn't backtrack, since I know the start predicate won't appear in the stack trace.
13:45:51 <dsal> I guess I only need the case with two, so I could do that.
13:46:11 <monochrom> dsal: Turn on BlockArguments, then you can delete the "$"s.
13:47:03 <monochrom> It is also possible to get ContT involved and use do-notation.
13:47:53 <merijn> mjrosenb: That second predicate works on the line following the start, or on the start?
13:48:10 <mjrosenb> what do people use for pastebins these days? I apparently forgot how to use gist.github
13:48:17 <mjrosenb> merijn: actually 3 lines after it
13:48:46 <EvanR> every jedi builds their own pastebin site in a unique way
13:49:02 <sm[m]> hastebin.com sometimes
13:49:13 <merijn> I don't know of any good ones know that lpaste is dead
13:49:31 <dsal> monochrom: Hmm...   That's probably not bad.  I just need two here, so I can just write up a with2
13:50:07 <merijn> dsal: For just two I'd do that, yes, but for more ContT becomes quite nice
13:50:11 <sm[m]> or pipe to nc termbin.com 9999
13:50:29 <merijn> Or Managed, which is just ContT without the confusion ;)
13:50:46 <sm[m]> mjrosenb: repl.it is kind of cool for more elaborate things
13:51:05 <merijn> I just want something low effort and clean :\
13:51:27 <sm[m]> termbin then
13:51:50 <dsal> Man, I keep having to forall today.  I must be doing things terribly wrong.  Or right.
13:52:22 <merijn> dsal: RankNTypes or ScopedTypeVariables? :p
13:53:02 <mjrosenb> https://termbin.com/uie7
13:53:20 <mjrosenb> merijn: sm[m] in case yinz is interested.
13:53:22 <sm[m]> when will I know I’m ready for forall ?
13:53:24 <dsal> Yeah, I've got a bunch of rank 2 stuff here.
13:53:59 <dsal> sm[m]: I started reading Sandy's book and now it's all obvious to me.  Just in time for me needing it.
13:54:08 <merijn> dsal: Nothing wrong with RankN
13:54:36 <merijn> sm[m]: RankN types is usually very obvious once you run into a place where you need them
13:54:59 <dsal> Yeah, I'm doing a ton of that here.  FFI with callbacks to do the thigns.
13:55:02 <merijn> sm[m]: Minimal example illustrating why you'd need them: https://gist.github.com/merijn/77e3fa9757658e59b01d
13:56:10 <sm[m]> Thanks!
13:57:13 <merijn> sm[m]: Basically, they let you "demand" to be given a value with a polymorphic type, which you can't enforce in "regular" haskell
13:57:48 * sm[m] might have done this once or twice, through semi sentient pattern matching  on ghc errors
13:59:17 <sm[m]> nice English explanation, thanks
14:00:09 <dsal> Yeah, I don't know why I didn't just turn on RankNTypes here.  I still needed one forall even with it on, though.
14:00:45 <dsal> sm[m]: https://leanpub.com/thinking-with-types -- this has made a bunch of things I interact with regularly a lot clearer.
14:01:00 <dsal> I got it to learn new stuff, but mostly so far have just learned stuff I already knew better.
14:02:26 <dsal> Is there a convenient way to split a NominalDiffTime into seconds and nanos?  I'm getting into tedious stuff.  heh
14:02:29 <sm[m]> good to know, thanks dsal
14:10:56 <geekosaur> dsal, I think fromEnum gives you 10^(-12), then you can use divMod or w/e
14:11:20 <dsal> I feel like I abuse toEnum/fromEnum, but I'll keep  doing that. heh
14:11:29 <merijn> You can just do nominalDiffTimeToSeconds
14:11:39 <merijn> And the round the resulting Pico
14:11:56 <EvanR> o_O
14:11:57 <geekosaur> oh, I missed that produced Pico-s
14:12:26 <dsal> :t nominalDiffTimeToSeconds
14:12:28 <lambdabot> error:
14:12:28 <lambdabot>     Variable not in scope: nominalDiffTimeToSeconds
14:12:33 <merijn> Also, why use fromEnum instead of realToFrac?
14:12:38 <dsal> There's a diffTimeToPicoseconds...
14:12:47 <merijn> "nominalDiffTimeToSeconds :: NominalDiffTime -> Pico"
14:13:10 <merijn> Oh, wait it's new in time 1.9.1
14:13:19 <shafox> May I get someone's emacs haskell-mode configuration for completion in the project (with projectile that would be great or not.) . 
14:13:30 <EvanR> multiply NominalDiffTime by 1 billion, then floor, then divMod
14:14:33 <EvanR> solutions like this never work in C... haskell rocks
14:15:00 <merijn> Or realToFrac and truncat :p
14:15:33 <EvanR> not sure that works...
14:16:01 <merijn> Why wouldn't it
14:16:09 <merijn> :t realToFrac
14:16:11 <lambdabot> (Real a, Fractional b) => a -> b
14:16:14 <EvanR> you won't get the nanos
14:16:33 <merijn> EvanR: Truncate for the seconds, do some math for that nanoseconds
14:16:54 <EvanR> riiiight
14:17:03 <dsal> I just did    (picos `div` 1000000) `divMod` 1000000
14:17:25 <EvanR> divMod . floor . (*1000000)
14:17:26 <EvanR> heh
14:17:34 <EvanR> er
14:18:14 <EvanR> 1000000000, and flip divMod 1000000000
14:18:17 <geekosaur> as for earllier question, going through Num used to get you seconds instead of nanos, fromEnum was the hackaround that got you full precision. things may be saner now
14:18:42 <geekosaur> (this was inherited from Data.Fixed's behavior with respect to both Num and Enum)
14:18:43 <EvanR> wow that sounds nuts
14:19:02 <EvanR> esp since Enum returns an Int
14:19:09 <geekosaur> yep
14:20:49 <monochrom> > properFraction 45.0002
14:20:52 <lambdabot>  (45,1.9999999999953388e-4)
14:21:13 <EvanR> going through Double can't be right, sorry
14:21:18 <monochrom> That should help you split a number into those two parts.
14:21:24 <EvanR> also why the hell doesn't lambdabot have Data.Time
14:21:27 <monochrom> @type properFraction
14:21:29 <lambdabot> (RealFrac a, Integral b) => a -> (b, a)
14:21:45 <monochrom> Works for every RealFrac.
14:22:04 <EvanR> let me know how many steps it takes with properFraction and get back to me
14:22:21 <monochrom> I was only using Double as an example.  NominalDiffTime is a RealFrac too.
14:22:32 <monochrom> And Pico.
14:22:46 <EvanR> yeah i was thinking it was the target for some reason, that or Rational but no
14:22:48 <monochrom> > properFraction (1.01 :: Pico)
14:22:51 <lambdabot>  (1,0.010000000000)
14:22:54 <monochrom> There.
14:23:01 <EvanR> half the problem solved
14:23:10 <dsal> What is Pico?
14:23:14 <dsal> :i Pico
14:23:26 <EvanR> fixed point with 12 decimal places
14:24:54 <dsal> @locate Pico
14:24:54 <lambdabot> Unknown command, try @list
14:25:00 <EvanR> Data.Fixed
14:25:06 <EvanR> iirc it's implemented as an Integer
14:25:39 <dsal> Oh, I see.
14:25:43 <monochrom> What's the other half of the problem?
14:25:48 <EvanR> get the nanos
14:26:22 <monochrom> > properFraction (45.0000000002 :: Pico)
14:26:24 <lambdabot>  (45,0.000000000200)
14:26:31 <EvanR> as an integer
14:27:02 <monochrom> > fmap (10^12 *) (properFraction (45.0000000002 :: Pico))
14:27:04 <lambdabot>  (45,200.000000000000)
14:27:08 <monochrom> Like that?
14:27:16 <monochrom> #spoonfeeding
14:27:29 <monochrom> #silverplatter
14:27:39 <EvanR> this is where floor shines, despite not being able to return a float from a float
14:28:14 <EvanR> monochrom: like, times by 1 billion, floor, then divmod by 1 billion
14:29:04 <monochrom> To be sure I should floor the 200 too.
14:29:15 <monochrom> But why all the hate against properFraction.
14:31:05 <EvanR> you could use it twice and still not have the right types
14:31:11 * hackage servant-auth-token-api 0.5.4.0 - Servant based API for token based authorisation  https://hackage.haskell.org/package/servant-auth-token-api-0.5.4.0 (NCrashed)
14:31:22 <monochrom> What are the right types?
14:31:23 <EvanR> well, i guess you could
14:31:47 <EvanR> you could do it twice, or divMod once
14:32:14 <monochrom> What was I doing twice that you're talking about?
14:32:29 <EvanR> properFraction
14:32:51 <monochrom> Then you misread.
14:33:51 <EvanR> > fmap (* 10^9) (properFraction 45.0000000244)
14:33:53 <lambdabot>  (45,24.400002018865052)
14:34:04 <EvanR> > fmap (* 10^9) (properFraction (45.0000000244 :: Pico))
14:34:06 <lambdabot>  (45,24.400000000000)
14:34:33 <monochrom> The 24.400... is still Pico, but I would floor it to get Integer if desired.
14:34:35 <EvanR> so not two integers
14:34:50 <monochrom> The 45 is already Integer or any Integral instance you want.
14:34:57 <EvanR> sure
14:35:10 <EvanR> i'm guessing properFraction is doing a divMod
14:35:20 <EvanR> then converting to get a fraction in the original type
14:35:41 <monochrom> Why guess? Data.Fixed is open source.  Read it.
14:36:05 <EvanR> because i solved the problem a hour ago and i gotta get to this basketball game
14:36:39 <monochrom> OK why aren't you already there?
14:36:53 <jollygood2> how "unsafe" is top-level myData = unsafePerformIO $ readData path ?
14:37:12 <EvanR> good question
14:37:29 <monochrom> #notinventedhere #someoneontheinternetiswrong
14:37:36 <jollygood2> I have no inline pragma
14:37:45 <monochrom> #nottonightIvegotamodem
14:38:27 <sm[m]> Probably not that unsafe. As long as it works for you. Not for safety critical applications.
14:38:56 <sm[m]> When you’re debugging in ghci it won’t reload.
14:39:00 <monochrom> You probably also need a noinline pragma.
14:41:03 <jollygood2> I'm using it for debuggin in ghci, but I got curious if there's a guarantee that IO won't run twice (with noinline pragma)
14:41:17 <jollygood2> both in ghci and in compiled executable
14:41:31 <merijn> jollygood2: No guarantees, all bets are off
14:41:45 <merijn> @quote not.a.bug
14:41:45 <lambdabot> Lemmih says: "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
14:42:43 <monochrom> But it is not as scary as that.
14:43:23 <monochrom> How about this.  A lot of important libraries do it.  Too big to fail.
14:43:43 <jollygood2> for top-level IORef, I guess? something else?
14:44:03 <monochrom> Or maybe not "a lot" but a few that are important enough.
14:44:31 <monochrom> Yeah.  System.Random.
14:45:15 <monochrom> (an IORef serving "getStdGen :: IO Gen" etc)
14:46:32 <monochrom> System.IO's "stdin, stdout, stderr :: Handle" --- how could anyone pre-create those Handles without IO?
14:47:20 <monochrom> (Not to mention that inside each Handle there are a couple of further IORefs and mutable arrays...)
14:47:54 <jollygood2> I don't see NOINLINE pragma in here for theStdGen. http://hackage.haskell.org/package/random-1.1/docs/src/System.Random.html#RandomGen
14:48:28 <monochrom> Probably a case of "won't bother until proven broken" :)
14:49:00 <monochrom> But it costs you nothing to add your own NOINLINE.
14:49:12 <monochrom> for your myData
14:49:30 <jollygood2> yeah, I did it as per recommendation in unsafePerformIO documentation
14:49:53 <jollygood2> a bit surprised that a library in base doesn't follow the same recommendation 
14:50:14 <merijn> jollygood2: random isn't in base?
14:50:18 <sarahzrf> jollygood2: there's a package for the readdata thing i think
14:50:23 <sarahzrf> a template haskell thing
14:50:26 <jollygood2> well ok, a popular package then
14:50:37 <monochrom> random used to come with GHC.
14:51:52 <dsal> GHC probably shipped with a bunch of predefined random numbers and removed them because the distribution got too b ig.
14:52:00 <monochrom> Yeah.
14:52:21 <sarahzrf> lol
14:52:37 <monochrom> But I brought up "used to come with GHC" to explain that it used to have somewhat official status.
15:07:21 <DigitalKiwi> isn't 4 enough?
15:08:00 <DigitalKiwi> good enough for debian
15:12:41 * hackage mmsyn5 0.4.1.0 - Various additional operations on lists (some with intermediate Monads)  https://hackage.haskell.org/package/mmsyn5-0.4.1.0 (OleksandrZhabenko)
15:19:42 * hackage mmsyn5 0.4.1.1 - Various additional operations on lists (some with intermediate Monads)  https://hackage.haskell.org/package/mmsyn5-0.4.1.1 (OleksandrZhabenko)
15:21:56 <merijn> Is he using Hackage as version control or something? >.>
15:25:51 <DigitalKiwi> what you never notice a typo immediately after you submit to hackage?
15:27:51 <merijn> DigitalKiwi: Well, more that I noticed the first version a few days ago, which looked pretty much like someone's list function homework and the changelog pretty much reads like a commit log
15:38:24 <DigitalKiwi> rofl
15:41:04 <DigitalKiwi> btw i was being facetious, conflating submitting to hackage with sending a text, which afaik is a lot more involved, not sure though, as i've never gone through the process to submit to hackage...
15:42:04 <merijn> Well, since you can do it with one command now, not that much more :p
15:42:30 <DigitalKiwi> you know what maybe the hackage policy should be adopted by other social media/irc it would probably weed out a lot of bad actors
15:42:31 <merijn> And submitting to hackage is like submitting a paper, fastest way to find all your typo's... >.>
15:42:50 <merijn> Which policy?
15:43:02 <DigitalKiwi> don't you have to email a real person
15:43:24 <merijn> You do now, because spam packages were starting to be uploaded
15:43:48 <merijn> tbh, I feel more for the suggestion I saw floated on twitter "what if we replaced all modern social media with text-only MUDs"
15:44:02 <Rembane_> That would be lovely
15:44:22 <MarcelineVQ> much nostalgic
15:44:35 <DigitalKiwi> i'm too young for muds
15:44:36 <merijn> Rembane_: Every tech nerd I know thinks that :p
15:45:22 <merijn> I somehow ended up rereading a webcomic I read in 2004 and seeing this site is reminding me that the early 2000s web was much better than this current nonsense >.>
15:46:17 <MarcelineVQ> was it Jerkcity
15:46:40 <Rembane_> merijn: Maybe it's a Shibboleth or we're just way too nostalgic about MUDs.
15:46:42 <merijn> Anyway, I think this drifted offtopic :p
15:48:32 <hpc> the best part of MUDs is having a much better internet connection, walking into an inn with 500 pets following you, and crashing everyone else
15:50:24 <sm[m]> isn't there a live haskell mud somewhere ?
15:51:06 <shapr> I think I've seen two?
15:51:19 <shapr> I've seen a pile of rogue-likes in Haskell.
15:51:28 * slack1256 thinks if #haskell can be interpreted as a MUD
15:51:29 <merijn> I've seen rogue likes yes, but not muds
15:51:34 <slack1256> @slap sm[m]
15:51:34 * lambdabot jabs sm[m] with a C pointer
15:51:44 <slack1256> Mmm for me it does.
15:52:06 <MarcelineVQ> haskell would be a muck anyway
15:52:46 <sm[m]> I guess not.. only https://github.com/jasonstolaruk/CurryMUD updated two years ago. There ought to be one.
15:53:12 <shapr> sm[m]: Hey, did you see the research paper annotation tool I've mostly finished?
15:53:24 <shapr> I'm super excited about building a thing from start to finish!
15:54:04 <shapr> I'm not a front end dev, so the javascripty parts are not so great: https://github.com/shapr/fermatslastmargin
15:54:20 <shapr> I'll try to get it up on hackage this weekend.
15:54:39 <MarcelineVQ> yo go girl
15:54:46 <shapr> yeah!
15:54:48 <ion> Any screenshots?
15:54:56 <shapr> I can make some
15:55:06 <shapr> right now it has all of three screens
15:55:43 <shapr> Here's one from a week or two ago: https://imgur.com/9zF3bbj
15:55:47 <MarcelineVQ> shapr: next stop, hydrus for papers! https://github.com/hydrusnetwork/hydrus
15:56:10 <shapr> MarcelineVQ: I'll have to look at that
15:56:17 <sm[m]> go shapr!
15:56:17 <ion> shapr: Cool
15:56:43 <shapr> I just got the paper search and add working yesterday.
15:57:07 <MarcelineVQ> basically it'd be searchable/sharable tags in addition to notes
15:57:35 <MarcelineVQ> probably most easily populated by ganking the keywords section of a paper, but then users could add more
15:58:09 * shapr quickly creates screenshots
15:59:07 <shapr> Here's the list view: https://imgur.com/cWop9cE
15:59:59 <MarcelineVQ> whne your sci papers are over 1000 yers old
16:00:55 <shapr> MarcelineVQ: crossref.org doesn't always have date info, it's often frustrating
16:01:12 <shapr> here's what crossref search results look like: https://imgur.com/Y4u2U1g
16:01:38 <shapr> You can click the checkbox on the left of any of those and the button will add the metadata to the list.
16:01:53 <shapr> Right now you have to get the PDF by yourself, but I'm working on a plugin system to do it for you.
16:02:00 <shapr> So far I use scholar.google.com to get the matching PDF
16:03:06 <DigitalKiwi> MarcelineVQ: it's ridiculous how long copyright lasts these days, only way to be safe
16:03:09 <MarcelineVQ> it doesn't help that the manufature of papers is arcane in the first place, I had a litle utility for reading pdfs one time and the title info would sometimes be things like c:\\foober\dorp.dvi when the title in the pdf viewer was more serious like "The Enumenaripidation Transiclosure Proxy: Firthgasting Eventual Torpors"
16:03:15 <MarcelineVQ> DigitalKiwi: thanks disney
16:03:19 <DigitalKiwi> :)
16:03:48 * DigitalKiwi enjoys when jokes land
16:04:05 <DigitalKiwi> MarcelineVQ: https://gist.github.com/Kiwi/b86979c0bb2fb2cb03d63537a40f7533
16:04:09 <jollygood2> how to parse roman numbers?  this fails:  parse (string "II" *> pure 2 <|> string "I" *> pure 1) "" ("I" :: String).  and this returns 1 instead of 2. parse (string "I" *> pure 1 <|> string "II" *> pure 2) "" ("II" :: String)
16:04:21 <jollygood2> I should use try and <|> again? which I was already advised against using :P
16:04:59 <jollygood2> (I am using parsec)
16:05:21 <shapr> here's note view: https://imgur.com/SInhKS7 and note edit: https://imgur.com/MtuT2um
16:05:30 <shapr> ion: that's all the screens
16:05:45 <merijn> jollygood2: Too tired to comment on your actualy question, but you may want to use <$ and $> instead of *>
16:05:53 <merijn> :t (<$)
16:05:54 <lambdabot> Functor f => a -> f b -> f a
16:06:01 <merijn> > True <$ Nothing
16:06:04 <lambdabot>  Nothing
16:06:08 <merijn> > True <$ Just 'c'
16:06:10 <lambdabot>  Just True
16:06:31 <jollygood2> perhaps this will make it easier to follow. I swapped the order of parsers before/after <|>. https://pastebin.com/qGipJkDx
16:07:07 <ion> shapr: neat
16:07:24 <jollygood2> :t (<*)
16:07:25 <lambdabot> Applicative f => f a -> f b -> f a
16:07:53 <MarcelineVQ> DigitalKiwi: fwiw I've heard of ivanhoe
16:08:09 * DigitalKiwi adds you to the high brow list
16:08:33 <MarcelineVQ> well, they made a cartoon.
16:09:35 <jollygood2> the issue is this: if string "II" parser comes first it fails on "I" and string "I" parser doesn't get to run. and if string "I" is ran first, then it will always parse as 1, even if the input is "II"
16:16:35 <jollygood2> the only way I can think of is to order roman numerals with common prefix by length, first the ones with longest string length, and add try to each parser
16:28:42 <slack1256> On emacs I normally use haskell-processs-type set to 'cabal-new-repl. This locally build and work OK. But I am on nixos and I am not using the caching, should just (add-to-list 'haskell-process-args-cabal-new-repl "--enable-nix") be enough?
16:29:22 <slack1256> Currently that is not working nor showing any logs on why, so I don't know if it's a problem with the project setup or the shell.nix file.
16:37:27 <wikiemol> What is the best way to do GUI programming in Haskell on mac? I think the best thing I have found so far is WebviewHS, but since its not really pure Haskell I feel like I am not learning as much about functional programming as I should be as a beginner.
16:37:41 * hackage cli-setup 0.2.1.0 - Helper setup scripts for packaging command-line tools.  https://hackage.haskell.org/package/cli-setup-0.2.1.0 (vmchale)
16:39:11 <dmwit> jollygood2: `try (2 <$ string "II") <|> (1 <$ string "I")`.
16:40:06 <dmwit> jollygood2: See also https://stackoverflow.com/q/34356668/791604
16:44:58 <jollygood2> dmwit, thanks. I was given "try a <|> b" considered harmful in parsec today. but this is the second time in a day that I couldn't write a parser without it, from what I can tell
16:46:11 * hackage ats-format 0.2.0.33 - A source-code formatter for ATS  https://hackage.haskell.org/package/ats-format-0.2.0.33 (vmchale)
16:47:11 * hackage madlang 4.0.2.16 - Randomized templating language DSL  https://hackage.haskell.org/package/madlang-4.0.2.16 (vmchale)
16:47:44 <dmwit> jollygood2: You can write it without. Did you follow my link?
16:48:33 <dmwit> tl;dr `char 'I' *> ((2 <$ char 'I') <|> pure 1)`
16:52:07 <jollygood2> It fails for "II"
16:52:24 <jollygood2> parse (char 'I' *> ((2 <$ string "II") <|> pure 1)) "" ("II" :: String)   => unexpected end of input. expecting "II"
16:54:39 <jollygood2> oh! second char 'I' was intentional
16:55:58 <jollygood2> it works.. but it seems like it would become pretty unwieldy to do that all 10 roman numerals
16:56:05 <jollygood2> +for
16:56:39 <jollygood2> unless chooseFrom wraps that behavior into a neat little function
17:28:04 <CrazyPython> I want a higher order function that takes another function F and returns the inverse of F. Where do I download or copy paste from?
17:28:46 <jollygood2> f returns Bool?
17:29:14 <jollygood2> :t not
17:29:16 <lambdabot> Bool -> Bool
17:29:36 <CrazyPython> like, I have a function that maps a domain A to a range B
17:32:08 <koala_man> invert (*) $ rsaModulus
17:37:03 <pavonia> Hackage clearly lacks a package acme-inverse
17:51:06 <dmwit> Well, I was going to link https://stackoverflow.com/q/13404208/791604 but CrazyPython is gone. Whatevs.
17:51:30 <dmwit> Oh, they know about it.
17:51:37 <dmwit> Since they're the one that opened a bounty on it.
18:14:41 * hackage heckin 0.0.1.0 - Oh heck, it's a heckin' case conversion library.  https://hackage.haskell.org/package/heckin-0.0.1.0 (maxdeviant)
18:37:11 <aviD> Does anyone have a working or WIP fork of HaRe for ghc 8.8?
19:11:44 <slack1256> Is "cabal --enable-nix v2-build" working for anybody?
19:14:11 * hackage standalone-haddock 1.4.0.0 - Generate standalone haddock documentation for a set of packages  https://hackage.haskell.org/package/standalone-haddock-1.4.0.0 (KarlVoelker)
19:57:03 <sshine> if I do 'Text.any p s && Text.any q s', is this as efficient as 'Text.any (\x -> p x && q x) s'? I suppose that "Subject to fusion." can't mean much other than yes, but how might I find out if not through microbenchmarking? I can't seem to find heads or tails of the fusion framework in the source code.
19:58:34 <slack1256> sshine: If you know how to read core, you could read to what they compile to and compare.
19:59:19 <sshine> slack1256, "read core"? what will I type to "get core", so I can read it?
20:01:09 <Lears> sshine: those two expressions mean different things. You can only do that transformation with `(||)` and `any`, or `(&&)` and `all`.
20:02:07 <Lears> > let s = [1..10] in (any odd s && any even s, any (\x -> odd x && even x) s)
20:02:10 <lambdabot>  (True,False)
20:02:16 <sshine> Lears, sorry, yes, my logic is wrong.
20:05:27 <sshine> Lears, so 'any p s || any q s' vs. 'any (\c -> p c || q c) s'.
20:10:35 <slack1256> sshine: Probably it's an overkill for what you want, GHC core is an intermediate representation of haskell programs. Basically gives types to all top level expressions and converts the program to a sequence of "let"s (which allocate) and "case of" (which evaluate expressions). So learning to read some core can say you about the performance characteristics of a program after rewrite rules do their magic. The problem is that Core output is 
20:10:35 <slack1256> fill with redundant info/noise, so takes a while to learn what to ignore and in what to focus, but it's a sure way to know when certain transformations apply.
20:10:43 <MarcelineVQ> I don't even see fusion rules for any :X
20:11:06 <slack1256> sshine: https://downloads.haskell.org/~ghc/7.6.3/docs/html/users_guide/options-debugging.html for how to output Core for a program and http://www.stephendiehl.com/posts/ghc_03.html for how to clean and read some Core.
20:11:19 <crestfallen> HI MarcelineVQ    I broke my big toe. what a drag !
20:11:25 <sshine> thanks, slack1256!
20:11:51 <sshine> MarcelineVQ, hurm. so it is subject to fusion, but not actually fused? :-P
20:11:53 <MarcelineVQ> ah there's the generic ones for stream https://hackage.haskell.org/package/text-1.2.4.0/docs/src/Data.Text.Internal.Fusion.html#stream
20:12:13 <sshine> MarcelineVQ, ah. I understand.
20:12:19 <MarcelineVQ> so it just doesn't have its own specific rules
20:12:26 <Lears> sshine: Right. In that case there could be a rewrite rule for it, but I don't think it would otherwise be covered by fusion; what's being avoided is a /traverse/ of the Text, not a construction.
20:12:45 <sshine> MarcelineVQ, ok, so it's only wrt. allocations that it fuses, but not necessarily wrt. traversals.
20:12:48 <MarcelineVQ> I don't really expect 'Text.any p s && Text.any q s' to fuse because && is driving it
20:13:05 <sshine> OK, good to know.
20:13:30 <sshine> I don't really know what to expect, I'm pretty amazed that fusion of allocations is even possible in a library.
20:13:51 <MarcelineVQ> crestfallen: hello
20:15:23 <crestfallen> hi, I dropped a heavy object on my toe. 
20:15:27 <crestfallen> << see moniker
20:15:29 <MarcelineVQ> Yes I saw
20:48:11 <justsomeguy> Heh, I just typed out like five questions to ask here, and ended up solving them all on my own. Feels good. :^)
20:48:39 <heatsink> Glad we could help. 8)
20:48:42 * hackage hmp3-ng 2.7.3 - A 2019 fork of an ncurses mp3 player written in Haskell  https://hackage.haskell.org/package/hmp3-ng-2.7.3 (galen)
20:49:14 <justsomeguy> It's like the #haskell chat window has been my rubber ducky.
20:53:11 * hackage hmp3-ng 2.7.3.1 - A 2019 fork of an ncurses mp3 player written in Haskell  https://hackage.haskell.org/package/hmp3-ng-2.7.3.1 (galen)
20:54:45 <jzyamateur> `pure` and `return` are exactly same in any case right?
20:55:14 <heatsink> When they are both defined, they're the same
20:55:18 <heatsink> Some data types only have pure
20:57:03 <jzyamateur> got it
21:03:10 <hololeap> i've got a data type: data Carving = Carving { startBoard :: BoardNum, height :: Height }
21:03:23 <hololeap> then i've got a line, using RecordWildCards:
21:03:32 <hololeap> let startBoard = minimum $ board : map startBoard (M.elems gm)
21:04:02 <hololeap> the right-hand `startBoard` refers to the `startBoard` function
21:04:16 <jellostahps> Does anyone here use Haskell in industry?
21:04:41 <hololeap> but GHC gets confused. is there a clean way to change that line so GHC understands?
21:05:53 <hololeap> the best i can come up with is: map (\Carving{..} -> startBoard) (M.elems gm)
21:06:02 <hololeap> but i'm not very familiar with RecordWildCards
21:06:10 <monochrom> I don't think you even need RecordWildCars or Carving to confuse GHC.  This is "let x+y = y+x"
21:06:53 <monochrom> In other words this is "let f x y = f y x" Haskell thinks you're defining a recursive function "f", or "(+)", or "startBoard".
21:08:12 <monochrom> OK maybe not function in the case of startBoard.  It's like "let x = 0 : x".
21:09:25 <monochrom> Except "x = 0 : x" is cool but if you try "x = 0 : map x [1,2,3]" that becomes strange.
21:11:10 <hololeap> monochrom: that all makes sense to me. is there a trick to disambiguate what i mean by the right-hand `startBoard` in that line, other than using (\Carving{..} -> startBoard)?
21:12:50 <monochrom> I think no.
21:47:37 <dmwit> hololeap: Yes, you may `\Carving{startBoard=startBoard} -> startBoard` with no extensions.
21:48:24 <dmwit> hololeap: Or `\(Carving startBoard _) -> startBoard`.
22:59:37 <sicklorkin> dmwit: I wonder if this works `\Craving{startboard=_,..}`
23:06:11 * hackage yhseq 0.2.1.1 - Calculation of Y-sequence Hexirp edition  https://hackage.haskell.org/package/yhseq-0.2.1.1 (Hexirp)
23:11:11 * hackage nyx-game 1.0.1.0 - A bullet-hell game made with SDL2.  https://hackage.haskell.org/package/nyx-game-1.0.1.0 (gilmi)
23:26:42 <dansho> is there anything in base to create directories?
23:27:49 <sicklorkin> are you restricted to only using packages in base?
23:34:43 <jle`> i would guess no, not in a cross-platform way
23:40:18 <dmj`> jle`: ping
23:41:03 <monochrom> But "directory" comes with GHC.
23:42:41 * hackage yhseq 0.2.1.2 - Calculation of Y-sequence Hexirp edition  https://hackage.haskell.org/package/yhseq-0.2.1.2 (Hexirp)
23:48:21 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/directory-1.3.3.2/System-Directory.html#v:createDirectory -- you can generally assume that some version of this is available, as it goes all the way back to the Haskell Report.
