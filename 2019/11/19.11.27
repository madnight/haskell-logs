00:00:06 <gauga> aha I see! so then I try concat listOfLists
00:00:13 <jle`> an [a] -> [(a, Int)] is a little easier to write
00:00:19 <MarcelineVQ> bahamas, haskelllisp[m]: seems pretty likely it's from prometheus.io
00:00:19 <jle`> well, this doesn't solve our problems
00:00:28 <gauga> nope
00:00:30 <jle`> but it at least helps get rid of the details that might otherwise have been misleading/dead ends
00:00:40 <jle`> so we can focus on the actual algorithm
00:00:41 <Axman6> haskelllisp[m]: is that from my mostly broken servant-prometheus package?
00:01:09 <gauga> ok I have flattened the listOfLists. what is the next step then? 
00:01:32 <jle`> there are a couple ways of going about this
00:02:08 * hackage graphql 0.6.0.0 - Haskell GraphQL implementation  https://hackage.haskell.org/package/graphql-0.6.0.0 (belka)
00:02:32 <jle`> gauga: if you have a function like a -> [a] -> Int, that can count the number of occurrences of a given item in a list, then you can map that function over a list of all unique words. that's kind of slow though
00:02:49 <jle`> gauga: a common trick people use here is to sort the list, and then count the number of runs
00:02:57 <jle`> er, count the lengths of the equal runs
00:03:09 <jle`> > sort (concat [["a", "rose", "is", "a", "rose"],["but", "so", "is", "a", "rose"]])
00:03:11 <lambdabot>  ["a","a","a","but","is","is","rose","rose","rose","so"]
00:03:31 <gauga> hm that's cool! 
00:03:32 <jle`> then you can clearly see: ("a",3), ("but", 1), ("is", 2), ("rose", 3), ("so", 1)
00:03:37 <jle`> just by reading it off "in order"
00:03:52 <gauga> that's pretty cool 
00:03:59 <gauga> how do I write the final step though? 
00:04:08 <jle`> so now depending on what you want to get out of this, you can go in and manually use foldr or something to generate the list of run lengths
00:04:28 <jle`> or you can use a function like group which groups consecutively equal items, taking a way a lot of the work and potential learning experience
00:04:33 <jle`> > group (sort (concat [["a", "rose", "is", "a", "rose"],["but", "so", "is", "a", "rose"]]))
00:04:36 <lambdabot>  [["a","a","a"],["but"],["is","is"],["rose","rose","rose"],["so"]]
00:05:13 <jle`> from there you can map over that list with a function that takes ["a","a","a"] and returns ("a", 3)
00:05:25 <jle`> etc.
00:05:29 <haskelllisp[m]> thank you,I am watching the promethues tutorial
00:05:33 <gauga> wow that's pretty awesome! 
00:05:39 <gauga> thank you so much! 
00:05:43 <jle`> this is the typical way to do it using only prelude functions
00:05:49 <pie_> apparently this is a thing https://github.com/polysemy-research/polysemy#readme
00:05:51 <jle`> as a learning exercise
00:06:07 <jle`> but, if you're doing this in a "real" program, usually we'd just use Data.Map from the containers library
00:06:28 <gauga> I'll have a look at that too
00:06:33 <gauga> much appreciated!
00:06:38 <jle`> np :)
00:08:07 <EvanR> pie_: yeah that's the new hottness
00:09:43 <bahamas> eff is hotter :)
00:10:25 <jle`> polysemy is me realizing i'm too old for all this anymore
00:11:24 <pie_> jle`: not sure what that means :P
00:12:24 <Axman6> polysemy is super cool - and should be even more cool with GHC 8.10
00:12:51 <yushyin> I hope so
00:13:23 <EvanR> when your 11 year old niece is raving about polysemy and never heard of monad transformers
00:13:58 <Axman6> though... lexilambda (?) new effects thing also looks very promising
00:13:59 <jle`> all these whippersnappers just want to talk about their polysemy and eff and aych and gee
00:14:09 <jle`> kids these days
00:16:32 <yushyin> so here I am with so many choices for monad transformer alternatives, that I don't know which I should use and just stick to mtl?
00:19:39 <jle`> mtl is the tried and true blue :)
00:23:24 <koz_> If you're writing a library, mtl _is_ the standard, for better or worse.
00:23:29 <koz_> For _applications_, use whatever.
00:23:59 <pie_> wow even I might be able to use this https://haskell-explained.gitlab.io/blog/posts/2019/07/28/polysemy-is-cool-part-1/index.html#fnref1
00:24:32 <bahamas> do all functions have a strict version? or at least prelude ones. I'm asking, because http://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#v:iterate references its strict version which is not documented there
00:25:51 <pie_> what happened that we're getting all this new hotness in this space?
00:30:49 <koz_> pie_: Alexis King has always been about the effects, and now she's writing Haskell again. Sandy is a recent convert, but he's a big fan, and he puts money where his mouth is.
00:33:21 <lexi-lambda> Competition is good. :) I was a casual fan of effect systems back when I was writing Haskell two years ago, but then fused-effects happened, and I happened to get a job writing Haskell again where performance really matters!
00:35:01 <koz_> lexi-lambda: Hi!
00:35:06 <pie_> ohai o/
00:35:08 <koz_> Good to see you in here - I'm a big fan of your writings.
00:35:22 <lexi-lambda> Hi! And thanks!
00:36:36 <lexi-lambda> Don’t let anyone tell you effects are a solved problem, by the way: I’ve been working more or less nonstop in my spare moments on eff for the past month, and a lot of that has meant learning what doesn’t work rather than coming up with any great solutions. (Effects are hard!)
00:37:08 <koz_> lexi-lambda: I look forward to the inevitable release then.
00:37:44 <lexi-lambda> Somehow I feel like I’ve gotten further away from that than I was a month ago.
00:37:59 <pie_> now there are more known unknowns
00:38:52 <koz_> lexi-lambda: I'm having this feeling right now with what I'm working on too, since I'm actually Haskelling for work for a change.
00:39:54 <lexi-lambda> The problem is I tried to support NonDet properly (all the existing implementations are somehow broken). And that led to realizing I think the semantics everyone’s been implementing is wrong, or at least weird. And then I figured out how to implement the semantics I want, but the types are a little too complicated… and I don’t know how to support bracket properly!
00:41:02 <koz_> lexi-lambda: Does this include polysemy's NonDet?
00:41:40 <lexi-lambda> Yes. They’re all broken in some way or another. It’s semi-fundamental given the approach they’re using.
00:43:01 <lexi-lambda> See this thread for the details: https://github.com/polysemy-research/polysemy/issues/246
00:43:38 <pie_> the final steps section here suggests to me its sensitive to the order that the interpretets are run?: https://haskell-explained.gitlab.io/blog/posts/2019/07/31/polysemy-is-cool-part-2/index.html
00:43:51 <lexi-lambda> Unfortunately my last few comments in that thread aren’t even the whole story; that approach I thought fixed the issues actually still had another problem. So now I have a new model based on delimited control.
00:45:00 <pie_> oh n o xD https://github.com/polysemy-research/polysemy/issues/246#issuecomment-539454189
00:45:31 <koz_> Yup, everything is broken, confirmed.
00:45:48 <lexi-lambda> My new model is insensitive to the order handlers are executed in, modulo fundamental differences arising from nesting of the types in the result.
00:47:15 <lexi-lambda> IME, people mostly tout the sensitivity to handler order as a feature rather than a bug by highlighting the interaction between state and error, which seems kind of compelling—you get “transactional” state. But I’m convinced that’s mostly a happy accident, and most of the other interactions are just nonsensical, not useful.
00:49:20 <lexi-lambda> You can recover transactional state in my model explicitly, by adding a `transact :: m a -> m a` effect operation, but it isn’t immediately clear to me how to make that kind of thing work reasonably for different kinds of stateful effects (e.g. state, writer) without duplicating the operation.
00:50:29 <lexi-lambda> Still, I am confident this semantics is the right one, since it provides good laws and equational reasoning power, and it makes things like `catch` interact correctly with NonDet. But implementing it in Haskell is tricky. :(
00:50:44 <lexi-lambda> (At least, implementing it efficiently is tricky.)
00:53:24 <lexi-lambda> The biggest secret that “effect systems people” don’t want you to know is that mtl style is still way, way slower in real code than concrete transformers, so this mythical performance target everyone’s trying to hit isn’t even that good. I’ve been thinking about how we might do better, but it’s hard.
00:54:59 <pie_> lexi-lambda: im asking because this means i have to replicate some amount of structure of my program by how i run interpreters right?
00:55:52 <pie_> whats a concrete transformer
00:56:24 <lexi-lambda> That’s already true with mtl/transformers, so it isn’t something specific to effect systems per se. (In fact, my current eff branch is unique in that it is *not* sensitive to handler order).
00:56:53 <pie_> ive never gotten around to using any of this stuff and it all looked hard, so im pretty clueless about it
00:57:00 <lexi-lambda> By “concrete transformers” I just mean writing against concrete stacks of monad transformers rather than writing polymorphic code with mtl style constraints.
00:58:15 <pie_> sooo...if i have a big program that does a lot of things i basically have to copy the whole effect structure?
00:58:17 <pie_> or how do i phrase this
00:58:57 <pie_> lexi-lambda: oh. ok, so you just lost me because IDK how mtl works and how normal monad transformers work.
00:59:03 <pie_> thats fine
00:59:25 <pie_> (i thought mtl _is_ normal monad transformers >_>)
01:00:23 <Rembane> mtl is the fancy tagless final representation of monad transformers. 
01:00:33 <pie_> or is the normal stuff things like MonadThingy m => m a
01:00:43 <pie_> oh so thats mtl
01:00:54 <Rembane> That example is mtl style
01:01:19 <lexi-lambda> It’s… all very complicated. A big part of why I’m willing to spend a ton of time on this is I’d love to be able to point people to “the solution” for effects in Haskell rather than having to explain this mess to people learning the language.
01:01:58 <lexi-lambda> I’d normally be happy to explain in as much detail as you’d like, but I can’t stick around—I need to sleep.
01:03:35 <pie_> lexi-lambda: same :P
01:04:25 <pie_> but maybe someone else can answer
01:04:32 <pie_> whats a monad "transformer" then
01:04:53 <pie_> or actually, i can just google this, or if someone has a specific recommended article
01:05:07 <pie_> lexi-lambda: your work is appreciated
01:06:44 <lexi-lambda> Someday it will bear fruit, I hope! Until then… good luck with the monad transformers. ;)
01:06:53 <koz_> pie_: Have you read the Typeclassopedia?
01:06:57 <koz_> If not, do that first.
01:08:50 <pie_> koz_: i remember going through some of it at some point
01:09:09 <koz_> pie_: Then complete the rest. :P
01:09:22 <koz_> I cannot emphasize its importance enough.
01:12:43 <pie_> not unreasonable
01:12:45 <pie_> math is good
01:12:52 <pie_> i am weak :P
01:13:07 <pie_> do you want me to work through the derivations and problems too
01:13:10 <pie_> iirc those exist
01:13:29 <koz_> pie_: Just read the whole thing carefully. Do the exercises if you can, but that might take too long.
01:13:39 <koz_> And the Typeclassopedia isn't really 'math'.
01:13:53 <koz_> It's 'explaining Haskell basics that you will need for the rest of your career in this language whatever you might do'.
01:14:52 <pie_> not that i have anything against it
01:15:05 <pie_> in fact id actively like to read it now that you reminded me of it :(
01:15:38 <pie_> is this still the up to date version https://wiki.haskell.org/Typeclassopedia
01:16:18 <Suspended> it's difficult to memorize just by reading. At least for me. I learn by doing examples
01:16:24 <koz_> Yes.
01:16:35 <pie_> the typeclassopedia expands to fill the availible time
01:16:41 <pie_> study methods apply as usual
01:16:42 <Suspended> then gradually I get ideas and test
01:16:43 <koz_> Suspended: To each their own. I advocate for exercises, but pie_ clearly wants an answer sooner. :P
01:16:46 <Suspended> and so on
01:17:04 <pie_> 'x)
01:18:19 <pie_> im not one to be impatient but events keep causing me to have midlife crises and im not even 25 yet -_-
01:18:22 <Suspended> currently I pull my hair over reader adn writer monads
01:18:52 <koz_> Suspended: What exactly is causing you to pull your hair out about those two?
01:20:31 <Suspended> koz_: Well... It all stems from years of programming in java where you do what you want. Haskell bends my mind, IO() and Maybe() are not so bad
01:21:14 <Suspended> but those two introduce additional type variable, which in turn adds complexity to monadic operations
01:21:39 <koz_> Suspended: I would worry more about State than those two.
01:21:54 <koz_> Since I am fond of saying that basically _everything_ in Haskell boils down to State or monoids.
01:21:59 <Suspended> yeah... I meant state hhaha
01:22:06 <koz_> Suspended: OK, State is a bit trickier.
01:22:09 <Suspended> state too
01:22:20 <koz_> The best way to think about it is this: State s a is just a fancy way of saying s -> (a, s)
01:22:33 <koz_> And literally everything about its Functor, Applicative and Monad instances is just convenience wrappers.
01:22:42 <absence> @let import Control.Monad.Trans.Maybe; import Control.Monad.Trans.Except
01:22:45 <lambdabot>  Defined.
01:22:47 <absence> > (MaybeT . except $ Left ()) <|> (MaybeT . except . Right $ Just ()) :: MaybeT (ExceptT () Identity) ()
01:22:49 <lambdabot>  MaybeT (ExceptT (Identity (Left ())))
01:23:02 <koz_> absence: much error, such handle
01:23:06 <absence> i was hoping to get the right one as a result :(
01:24:39 <absence> i guess the Alternative instance isn't compatible with my hopes, is there an elegant way to do this without manual pattern matching?
01:25:01 <koz_> absence: Are you familiar with Alt?
01:25:05 <koz_> It might do what you wish.
01:27:22 <absence> koz_: the Alt instance for MaybeT looks identical to the Alternative instance (modulo empty of course)
01:28:09 <koz_> absence: Huh, OK then, maybe not.
01:28:09 <koz_> Write a newtype wrapper with the semantics you desire?
01:30:38 <archonest> Hello
01:31:44 <koz_> archonest: Wazzup?
01:32:22 <absence> koz_: i was hoping to avoid that, as it seems to be a thing that should work out of the/a box, but on the other hand, Alternative seems weird in general
01:33:28 <archonest> koz_: How are you doing?
01:33:41 <koz_> archonest: I am doing pretty great, thanks.
01:35:24 <archonest> koz_: Good to hear. I am first time at this channel. Seems to be alive enough.
01:35:25 <jle`> absence: one of the 'points' of MaybeT is to imbue a monad with an Alternative instance that is maybe-like
01:35:37 <jle`> absence: for example so you can use `MaybeT IO`
01:36:43 <absence> jle`: yes, i was just expecting it to include more than the top layer in its "alternativeness", but maybe that's impossible in general
01:36:55 <pie_> koz_: oh...its in the typeclassopedia...
01:37:01 <pie_> also so THATS what the T means"
01:37:02 <pie_> !
01:37:03 <koz_> pie_: It's a source of many serets.
01:37:08 <koz_> s/serets/secrets/
01:37:16 <jle`> absence: using only the top layer is the main utility of it, i think
01:37:37 <jle`> absence: so for example MaybeT IO, would only use Maybe and not rely on something like IO's semantics
01:37:46 <jle`> basically "overriding" an Alternative instajce
01:37:56 <jle`> absence: in your case it looks like maybe you want something like catch instead?
01:38:13 <absence> jle`: that's different from e.g. the Functor instance which goes through all the layers
01:38:29 <jle`> yeah, this is why i wouldn't really think about it as 'layers'
01:38:40 <jle`> the idea breaks apart pretty quickly
01:38:51 <jle`> even the Applicative instance doesn't go through the 'layers'
01:39:09 <jle`> the Applicative instance will ignore the IO part's Applicative instance whenever possible
01:39:21 <jle`> for MaybeT IO, the Applicative instance will ignore IO's Applicative instance whenever possible, i mean
01:39:55 <jle`> since it gives IO new 'short-circuiting' applicative semantics
01:40:11 <jle`> MaybeT doesn't "add a layer", it transforms and overrides semantics
01:40:44 <absence> jle`: it doesn't use IO's aplicative instance directly, but it does use its monad instance with is kinda the same thing
01:41:04 <jle`> > catch (MaybeT . except $ Left ()) (const (MaybeT . except . Right $ Just ()))
01:41:07 <lambdabot>  error:
01:41:07 <lambdabot>      • Couldn't match expected type ‘IO a’
01:41:07 <lambdabot>                    with actual type ‘MaybeT (ExceptT () m0) a0’
01:41:13 <jle`> > catchError (MaybeT . except $ Left ()) (const (MaybeT . except . Right $ Just ()))
01:41:15 <lambdabot>  error:
01:41:15 <lambdabot>      • Ambiguous type variable ‘m0’ arising from a use of ‘show_M278602668458...
01:41:15 <lambdabot>        prevents the constraint ‘(Data.Functor.Classes.Show1
01:41:34 <jle`> absence: it actually bypasses Applicative and Monad semantics for IO whenever possible
01:41:48 <jle`> > catchError (MaybeT . except $ Left ()) (const (MaybeT . except . Right $ Just ())) :: MaybeT (ExceptT () Identity) ()
01:41:51 <lambdabot>  MaybeT (ExceptT (Identity (Right (Just ()))))
01:42:02 <jle`> i think that's what you want maybe
01:42:16 <jle`> the instance of MonadError for `MaybeT m` will use the instance of MonadError for m
01:42:40 <jle`> so if you use catchError, it will catch errors on the transformed monad m
01:42:46 <jle`> in this case ExceptT () Identity
01:43:38 * hackage galois-fft 0.1.0 - FFTs over finite fields  https://hackage.haskell.org/package/galois-fft-0.1.0 (sdiehl)
01:55:11 <kuribas> dminuoso: I changed the representation of my UnwrapIO class: https://github.com/kuribas/unwrapio/blob/master/src/Control/Monad/IO/Unwrap.hs
01:55:34 <kuribas> dminuoso: but it turns out it is now equal to monad-peel, which was the predecessor of MonadBaseControl.
01:56:37 <kuribas> it's beyond me why they ever changed it, because MonadPeel seems to be much easier to use.
01:57:22 <kuribas> MonadBaseControl seems like the typical thing people accuse haskell of: an overly generic solution for a simple problem, that has more theoretical than practical use.
01:59:30 <kuribas> MonadPeel seems under documented, and a bit bare bones, but otherwise it seems to be handling the problem of lifting callbacks pretty well.
01:59:43 <maerwald> I feel that applies to most of the transformer stuff. It's an awkward place between "give in, use IO" and "should use an effects system"
02:00:08 <maerwald> RIO is almost there, lol... just needs to drop the R
02:01:35 <kuribas> I am ok with the complexity of transformer stacks, since it also makes it easy to add functionality (like logging), without adding mystery state, like in Java.
02:02:18 <tdammers> ReaderT IO ftw
02:02:28 <maerwald> Java is such a bliss, you can code without too much thinking (and I'm not mocking)
02:02:37 <maerwald> But maintenance isn't really nice :P
02:02:50 <tdammers> IME, ReaderT IO is all you need in terms of stacking, at least for the big brush structure
02:03:01 <kuribas> maerwald: you also give up on compositionality, and usually need to write big blobs of intertwined code.
02:03:05 <maerwald> tdammers: I find reader barely useful for some reason
02:03:21 <kuribas> tdammers: what if you want to throw stuff?
02:03:21 <tdammers> maerwald: same here, but for the top-level type of your application, it's useful
02:03:22 <maerwald> it basically abstracts over... having an argument to a function
02:03:35 <kuribas> tdammers: like non 200 status codes?
02:03:41 <tdammers> kuribas: we're already in IO, anything can throw anything at any time
02:03:54 <tdammers> but exceptions for status codes other than 500 are kind of bad
02:04:44 <tdammers> e.g., for 400, I much prefer the wrapper approach, e.g., :: (Request -> a) -> (a -> Application) -> Application
02:05:25 <tdammers> that is, take a function that parses data out of the request, validates it, and if it's OK, delegates to a function that does the real work (the second arg), otherwise return a 400 error
02:05:41 <tdammers> this is much cleaner IMO than throwing from somewhere deep in the bowels of the payload handler
02:06:13 <pie_> <maerwald> Java is such a bliss, you can code without too much thinking (and I'm not mocking)
02:06:20 <kuribas> tdammers: there is also authentication
02:06:37 <pie_> i was talking to someone earlier about how you can just bullshit your way through imperative code
02:06:38 <kuribas> for example, I want see if a user has access to some resource
02:06:54 <pie_> i havent found a better way to express yet why i find haskell difficult besides "you need to know more"
02:07:29 <absence> jle`: yes, that looks more like what i want. MonadError seems deprecated though?
02:07:37 <kuribas> pie_: yeah, writing good haskell usually means using appropriate libraries.
02:07:49 <pie_> and by more i mean a lot more xD
02:08:22 <tdammers> kuribas: yes, so? you don't want that whole mechanism to poison your entire call chain. either just load your resources up front, in a local ExceptT (or even just a MaybeT - avoids information disclosure), but keep it local
02:08:48 <tdammers> also depends a lot on what kind of application you're building
02:09:09 <tdammers> if it's an SPA kind of thing with just a raw REST API behind it, then a simple wrapper will do for the authorization
02:09:44 <kuribas> tdammers: accessing resources is the main logic in our REST API.
02:09:45 <tdammers> kuribas: oh, and, heads up: authentication = prove who you are; authorization = prove that you are allowed to do this
02:09:59 <kuribas> tdammers: yeah, I means authorization :-)
02:10:04 <kuribas> meant
02:10:10 <tdammers> authentication, IMO, is best left to middleware
02:10:43 <tdammers> or if you can't easily propagate the user ID into the inner application, use a wrapper, just like with the 400 example above
02:11:17 <tdammers> then again, if you have the ReaderT in place anyway, might as well have currentUser :: Maybe UserID in your application state
02:11:31 <tdammers> then the middleware can just local your reader to add the authenticated user
02:12:34 <bahamas> in your experience what do beginners find most difficult when learning Haskell? I'm looking for specific concepts rather than more general ones. for example, when I started, I found it very confusing that type and data constructors have the same name and casing
02:13:13 <bahamas> I'm asking this, because I'm making some flash cards with Haskell concepts and I want to decide what I can focus on the most
02:13:30 <kuribas> tdammers: it's not just users, I may access any resource.  Loading all resources simply isn't possible.
02:13:50 <kuribas> tdammers: accessing resources is the main purpose of our REST API.
02:13:52 <tdammers> kuribas: that's the authentication example. authorization is a different concern.
02:13:59 <kuribas> tdammers: ah right :)
02:14:54 <tdammers> for authorization, I'd start out with plain old Maybe: if you're allowed, you get Just the thing, if not, you get Nothing
02:15:11 <tdammers> if you have calls that need to access multiple resources, then I'd use MaybeT, but only locally
02:15:19 <tdammers> just to tie things together
02:15:26 <kuribas> tdammers: that will not do, we should provide the user with the correct response.  Nothing could mean anything, not just "unauthorized".
02:15:31 <tdammers> I wouldn't want to poison the entire application with a generic exception mechanism for this
02:15:57 <tdammers> well, there is this thing called "information disclosure vulnerability"
02:16:08 <kuribas> tdammers: why poison?  You wouldn't care about it otherwise?
02:16:12 <tdammers> so if you do strict security, Maybe is *exactly* the right thing
02:16:41 <tdammers> and you *would* care about it when it comes to things like brackets and such
02:16:46 <kuribas> tdammers: when they use our API, they should be authenticated already.
02:17:09 <kuribas> tdammers: that's why my version of bracket uses pure IO for the acquire and release :)
02:17:10 <tdammers> authentication is irrelevant here
02:17:59 <kuribas> tdammers: what's the risk of "Unauthorized to use resource X"?
02:18:27 <tdammers> you're giving away the information that resource X exists
02:18:52 <kuribas> tdammers: X may be an intervention ID, which is totally useless information.
02:19:09 <kuribas> but I understand the general concern.
02:19:12 <tdammers> relying on such assumptions is brittle
02:20:04 <tdammers> but anyway, if you decide you want to expose this information, because being able to debug and solve authorization problems is more important than keeping the existence of certain resources secret, you can use Either instead of Maybe, the mechanism is the same
02:20:45 <tdammers> I still wouldn't want this to bleed up the call stack too much
02:21:08 <tdammers> (s/stack/graph/)
02:21:45 <maerwald> pie_: naive solutions in imperative languages more often are doing ok-ish. I believe that in functional languages you have more pressure for non-naive solution (esp. wrt performance)
02:22:28 <kuribas> tdammers: ok, a better example is when a user doesn't have rights to access any interventions in a plant, than it's safe to return "unauthorized".
02:22:54 <tdammers> yes, maybe
02:23:14 <tdammers> but there's also not a lot of added benefit to distinguishing between "this doesn't exist" and "this doesn't exist FOR YOU"
02:23:47 <kuribas> tdammers: in this case, it's more like "you are not allowed to do this".
02:24:31 <tdammers> also, this whole authorization thing is usually a two-layer thing: the outer layer checks authorizations to decide which UI elements to render (i.e., which options to present to the user), the inner layer does the actual safeguarding, hard-denying access to anything you're not authorized to see
02:25:29 <tdammers> for the outer layer, you don't need anything exception-like, instead it's more like when (userHasPermission currentUser View Interventions) (renderInterventionsUI)
02:25:57 <kuribas> tdammers: we don't render anything
02:26:00 <tdammers> for the inner layer, if a user runs into an authorization failure, then they shouldn't have come here in the first place, and you can just send them away without further information
02:26:17 <tdammers> kuribas: there's no UI at all?
02:26:26 <kuribas> tdammers: we outsourced the UI...
02:26:41 <kuribas> the UI corrently is a java application which will become obsolete.
02:26:48 <kuribas> tdammers: it will be a one page javascript app.
02:27:23 <kuribas> tdammers: well, typescript
02:27:38 <kuribas> tdammers: I am not so much fan of a one-page app, but it wasn't my decision.
02:33:04 <kuribas> tdammers: I see your points, but it's a bit annoying to have an ExceptT in all my servant endpoints.
02:33:47 <Rembane> kuribas: Why is it annoying?
02:34:08 <dansho> how can i install the profiling versions of base libraries?
02:35:42 <kuribas> Rembane: it's boilerplaty...
02:37:24 <Rembane> kuribas: That's a very good point.
02:38:50 <kuribas> Anyway, I'll have to try it out, find for myself the best solutions.
02:42:34 <kuribas> I'll keep tdammers and others comments in mind :)
02:46:54 <boxscape> What was the way to make it possible to use fully qualified names without importing them in files like you can in ghci?
02:49:01 <bahamas> is there a way in ghci to declare a value while also declaring its type?
02:49:26 <boxscape> % f :: Bool; f = True
02:49:26 <yahb> boxscape: 
02:49:29 <boxscape> yes
02:49:55 <boxscape> alternatively multiline input with `:set +m` or {: and :}
02:50:05 <bahamas> ah, I separate them with `;`
02:50:14 <bahamas> boxscape: thanks
02:50:18 <boxscape> np
02:50:32 <cipherchess> hello, I was looking at this [1] and was thinking if there is a more up-to-date page with some indication on how to create a TCP server as I'd like to create a high performance one, but with up-to-date things; [1] https://wiki.haskell.org/Simple_Servers
02:52:10 <boxscape> (the answer to my question is -fimplicit-import-qualified)
03:15:10 <cipherchess> no one?
03:24:06 <bahamas> cipherchess: you will find this useful, if I understand what you're asking http://hackage.haskell.org/package/streamly
03:25:33 <phanimahesh> streamly so hot right now
03:34:52 <pie_> oh duh
03:35:25 <pie_> i just realized, i was thinking polysemy is worse than a free monad because i have to sequence the individual run functions myself to match the code
03:35:46 <pie_> but i just realized thats wrong because one free monad is one `run` thingy
03:36:19 <pie_> so yeah i have to sequence orthogonal effects (?) but thats not worse than with free monads
03:36:38 <pie_> IIUC
03:38:01 <pie_> what i didnt get is, if im using polysemy, do i have to loop through all my effects till the list is empty or what?
03:38:28 <pie_> because iiuc effects can cause more effects to appear, or of a different kind, which i may have already executed previously?
03:39:44 <gauga> hey guys, how do I map a function that takes an element and a list to a function that takes two lists? So, a function that counts the number of occurences of one element in a list I would like to use on a list of elements (so that the function would run through the list and count how many times the elements from that list occur in another list? 
03:40:20 <cipherchess> bahamas: interesting, but in the end I'd like to make a packet inspector in haskell
03:41:39 <pie_> im looking at the end of https://haskell-explained.gitlab.io/blog/posts/2019/07/31/polysemy-is-cool-part-2/index.html
03:43:59 <haskeldjiq> guys
03:44:17 <haskeldjiq> can you somehow "derive" an instance out of an inner monad
03:44:19 <haskeldjiq> e.g. you have
03:44:24 <haskeldjiq> newtype SomeMonad a = SomeMonad { runSomeMonad :: SomeT AnotherMonad a }
03:44:42 <haskeldjiq> then instance MyClass AnotherMonad where ...
03:44:54 <haskeldjiq> can you somehow get the instance up to SomemOnad
03:44:57 <haskeldjiq> can you somehow get the instance up to SomeMonad
03:45:37 <pie_> im not sure its the right answer but that vagely sounds like lift
03:45:51 <haskeldjiq> oh my god
03:45:52 <haskeldjiq> yeah sorry
03:45:55 <haskeldjiq> I'm stupid today
03:46:00 <pie_> :D
03:46:14 <haskeldjiq> pie_: thanks!
03:46:28 <pie_> well thats a first, look at me im helping
03:46:48 <haskeldjiq> has never happened to me yet so I understand lol
04:19:32 <absence> haskeldjiq: you can derive instances for a newtype wrapper using the GeneralisedNewtypeDeriving language extension
04:21:45 <haskeldjiq> absence: yes this would work for deriving instances from SomeT
04:21:55 <haskeldjiq> but getting instances from AnotherMonad requires you to lift
04:22:45 <absence> haskeldjiq: hm, i don't think you can lift instances?
04:22:58 <haskeldjiq> absence: not literally lift an instance but you can do
04:23:00 <ski> unless you have `instance C m => C (SomeT m)' ?
04:23:14 <haskeldjiq> you can do
04:23:22 <haskeldjiq> instance MyClass SomeMonad where
04:23:31 <haskeldjiq> someFunc = SomeMonad . lift . someFunc
04:23:39 <haskeldjiq> of something similar depending on the stack
04:23:42 <haskeldjiq> or*
04:23:49 <ski> depends on the signature of `someFunc'
04:23:52 <haskeldjiq> yes
04:24:02 <haskeldjiq> but the approach is more or less the same
04:24:07 <ski> works in some cases, doesn't work in some cases
04:24:21 <haskeldjiq> well there shouldn't be cases where it won't work but I may be wrong
04:24:27 <haskeldjiq> if there are multiple arguments composition won't do the jobs
04:24:29 <haskeldjiq> if there are multiple arguments composition won't do the job
04:24:32 <haskeldjiq> but you can always do
04:24:39 <haskeldjiq> someFunc x y = SomeMonad $ someFunc x y
04:24:42 <haskeldjiq> or whatever
04:25:08 <ski> if you have `class ..m.. => MyClass m where someFunc :: m () -> m ()', then that's going to be hard
04:25:26 <haskeldjiq> I guess
04:25:33 <ski> (but quite possibly that doesn't happen for your `MyClass')
04:25:34 <haskeldjiq> then again it's a really weird function to have
04:25:42 <ski> @type forkIO
04:25:43 <lambdabot> error: Variable not in scope: forkIO
04:25:47 <ski> @hoogle forkIO
04:25:48 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
04:25:48 <lambdabot> GHC.Conc forkIO :: IO () -> IO ThreadId
04:25:48 <lambdabot> GHC.Conc.Sync forkIO :: IO () -> IO ThreadId
04:25:54 <ski> @hoogle catch
04:25:54 <lambdabot> Control.Exception catch :: Exception e => IO a -> (e -> IO a) -> IO a
04:25:54 <lambdabot> Control.Exception.Base catch :: Exception e => IO a -> (e -> IO a) -> IO a
04:25:56 <lambdabot> System.Directory.Internal.Prelude catch :: Exception e => IO a -> (e -> IO a) -> IO a
04:26:00 <haskeldjiq> lol
04:26:13 <ski> @type local
04:26:14 <haskeldjiq> let's say it's an esoteric case
04:26:15 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
04:26:48 <ski> if you don't need it, then fine. if you do need it .. well, that's tough
04:27:18 <haskeldjiq> then we'll have a discussion here lol
04:27:38 <ski> just pointing out that this can, sometimes, be a real problem
04:27:38 * hackage github 0.24 - Access to the GitHub API, v3.  https://hackage.haskell.org/package/github-0.24 (phadej)
04:28:13 <ski> anyway, i'd look into `instance MyClass m => MyClass (SomeT m)' and GND
04:28:58 <ski> only if that doesn't work, or you don't want that, i'd suggest manually making an instance of `MyClass' for `SomeMonad', directly in terms of `lift'
04:29:10 <haskeldjiq> I got it work with lift
04:29:19 <haskeldjiq> yeah GND would've been nice but it won't quite work in this case
04:29:34 <ski> (of course, that `instance MyClass m => MyClass (SomeT m)' could quite possibly use `lift' ..)
04:29:54 <haskeldjiq> hm you're right
04:29:56 <haskeldjiq> I could try that
04:30:07 <ski> is there a reason why you don't want `MyClass (SomeT m)' ?
04:30:11 <haskeldjiq> will make the files look a bit nicer
04:30:17 <haskeldjiq> given
04:30:17 <haskeldjiq> newtype SomeMonad a = SomeMonad { runSomeMonad :: SomeT AnotherMonad a }
04:30:24 <haskeldjiq> we have a bunch of instances that we derive from SomeT
04:30:37 <haskeldjiq> and one class that needs to be implemented in terms of AnotherMonad
04:30:51 <haskeldjiq> e.g. you derive the instances that you have "default" behavior for
04:30:54 <ski> (there could well be, i'm just asking. if such an instance does make sense, i'd probably lean towards making it (since it helps with what you're doing anyway, so might as well declare it)
04:31:00 <haskeldjiq> and you need to supply this additional instance that is special for each use case
04:31:32 <ski> mhm
04:31:44 <haskeldjiq> it's kind of tricky
04:31:55 <haskeldjiq> it hasn't yet worked there are some implementation details but the design looks
04:31:58 <haskeldjiq> "okayish"
04:31:59 <haskeldjiq> I guess
04:35:42 <Putonlalla> Who named the generators for paramorphisms "R-algebras"?
04:35:53 <Putonlalla> I can't find any mention of this in the literature.
04:37:48 * ski . o O ( "F-algebra" is such a bad name )
04:52:46 <Cale> Putonlalla: Where have you seen R-algebra? Usually absent of context, those things are referred to as F-algebras (really "functor algebras" would be more appropriate), though if you have some functor R sitting around, then its algebras would be called R-algebras. That sounds weird though, because (again without context) you might expect R to be a ring
04:55:17 <Putonlalla> It's used in the Semantic library, Cale.
04:55:36 <Putonlalla> Look here: https://github.com/github/semantic/blob/master/src/Data/Algebra.hs
04:57:33 <[itchyjunk]> ah r-algebra meaining recursive type here? :s doesn't it mean algebra on some commutative ring in math? hmm
04:57:58 <Cale> Putonlalla: Ah, in that case, I'd just git-blame ;)
05:00:04 <gauga> Hej guys, Haskell newbie here, anyone who could help with a basic function? 
05:00:24 <boxscape> that'd be easier to say if we knew what the function was about :)
05:00:45 <gauga> Sure :)  
05:01:18 <gauga> Making a function that takes a text as input and counts the number of occurences
05:01:38 <boxscape> What are you having trouble with?
05:02:10 <kuribas> Can you compile a project with only typechecks?
05:02:15 <kuribas> no output?
05:02:25 <kuribas> For example for a CI/CD pipeline
05:02:32 <Cale> -fno-code
05:03:01 <gauga> My reasoning is this: 1. make a list of unique words from the text 2. count the occurence of each of those unique words in the text; what I have so far: 1. I have made a list of the unique words in the text; 2. I have made a function that counts the occurence of one given element in the text (so, it takes an element and a listOfLists as arguments
05:03:02 <gauga> and returns the number of times the element occurs) 
05:03:03 <kuribas> is there a cabal command for that?
05:03:46 <boxscape> kuribas surely there's a way to provide ghc arguments to cabal?
05:04:07 <gauga> What I am having trouble with is making a function that would take a list of unique words and a text and count the number of occurences of each of those words in the text. How do I do that recursively? 
05:04:39 <gauga> I don't know how to map that or how to do that recursively 
05:04:52 <Putonlalla> I now know to blame Patrick Thomson, but that makes me none the wiser, Cale.
05:05:11 <boxscape> gauga how would you do it if you wanted to count the occurences of a single unique word?
05:05:22 <boxscape> rather than a list of them
05:05:22 <Cale> Putonlalla: I'm just half-joking that it was probably whoever wrote that definition in the first place that came up with the name
05:05:38 * hackage HGL 3.2.3.2 - A simple graphics library based on X11 or Win32  https://hackage.haskell.org/package/HGL-3.2.3.2 (AlanHawkins)
05:05:50 <Cale> gauga: Are there any restrictions on what libraries you use?
05:06:04 <Putonlalla> It probably has nothing to do with rings or polynomials and just happens to be some mnemonic for "an algebra that remembers".
05:06:05 <kuribas> gauga: check each unique word against each word of the input?
05:06:09 <gauga> hi boxscape, I've actually written a function elemCount x list and used that on a flattened list 
05:06:37 <gauga> so, first I flatten a list of lists and then I count the number of times a given element appears in that list
05:06:39 <boxscape> what is the type of elemCount?
05:06:45 <Cale> gauga: There's a good way to use Data.Map to do this, but without that, I would use Data.List group and sort
05:07:00 <gauga> Eq a => a -> [a] -> Int
05:07:03 <Cale> > group "mississippi"
05:07:05 <lambdabot>  ["m","i","ss","i","ss","i","pp","i"]
05:07:11 <Cale> > group . sort $ "mississippi"
05:07:13 <lambdabot>  ["iiii","m","pp","ssss"]
05:07:22 <Cale> this makes it easy to count occurrences
05:07:38 <gauga> but how do I do the final step? 
05:07:39 <Cale> > map (\xs -> (head xs, length xs)) . group . sort $ "mississippi"
05:07:42 <lambdabot>  [('i',4),('m',1),('p',2),('s',4)]
05:07:50 <kuribas> gauga: use a HashMap Text Int ?
05:08:15 <gauga> thanks, everyone! 
05:08:17 <Cale> Normally, head is a function to avoid
05:08:25 <gauga> thanks, cale 
05:08:31 <gauga> much appreciated
05:08:32 <Cale> But in this case, it's safe, because the elements of the list that group gives you are guaranteed nonempty
05:09:19 <boxscape> (I wish group had a different return type grumble grumble)
05:09:19 <gauga> can I take a document as input instead of a string
05:09:26 <gauga> or a list of lists?
05:09:41 <boxscape> a list of lists should work
05:10:12 <kuribas> gauga: Text.words <$> Text.getContents
05:10:33 <kuribas> or Text.readFile if it comes from a file.
05:11:12 <gauga> awesome
05:11:21 <gauga> what a great channel! 
05:32:39 * hackage HTF 0.14.0.1 - The Haskell Test Framework  https://hackage.haskell.org/package/HTF-0.14.0.1 (StefanWehr)
05:42:11 <JustAStudent> Hi, quick question. I'd like to do the following, but for some reason it does not work. It complains about the (readIORef) in the equation. How do I solve this while still using guards? https://pastebin.com/v75fwb3q
05:43:36 <opqdonut> JustAStudent: guards are for pure code, readIORef needs to run in the IO monad
05:43:57 <JustAStudent> Check. So a construction like that is not possible?
05:44:24 <opqdonut> JustAStudent: if you really want to use guards, you need an outer function that does the readIORef calls, and an inner function with Int arguments that uses guards
05:44:52 <JustAStudent> Thanks! opqdonut
05:45:18 <opqdonut> you _could_ also use the "empty case with guards" trick with do-notation
05:45:33 <JustAStudent> Could you explain that to me?
05:47:02 <opqdonut> if you want guards in an expression (as opposed to on the top level of a definition): you can use something like: case () of _ | guard1 -> val1 | guard2 -> val2
05:47:13 <opqdonut> but that's a bit hacky
05:47:41 <JustAStudent> Ah, I see, thanks.
05:51:12 <JustAStudent> So I tried to make a checkIORef-function, but it fails, and I do not see why: https://pastebin.com/HXhpCV1V
05:53:34 <opqdonut> because readIORef returns an IO Int, and you can't escape the IO monad
05:53:49 <opqdonut> if you use an IO action in your function, the return type of the function must also be an IO action
05:55:10 <Ariakenom> with brackets and semicolons instead of whitespace: "do {x; y;}" the type of y must be the same as the entire do-block
05:55:40 <JustAStudent> So I cannot compare Ints with IORef Ints outside of a do-block?
05:56:22 <boxscape> You cannot do it outside of an IO action. A do-block is one way to write an IO action.
05:56:50 <Ariakenom> you cant use a function with this type signature to compare IORef ints "IORef Int -> IORef Int -> Bool"
05:57:10 <Ariakenom> I mean you cant write a function that does that with that type
05:57:18 <tdammers> you cannot compare IORefs and Ints at all
05:57:40 <tdammers> you can extract an Int value from an IORef Int, and compare that against an Int
05:58:04 <tdammers> or rather, you can construct an IO action that reads a value from an IORef Int and compares it against an Int
05:59:24 <tdammers> but the only things you can do with such an IO action are 1) throw it away, 2) combine it with other IO actions, 3) bind it to Main.main, causing the RTS to execute it
05:59:44 <tdammers> do notation has little if anything to do with it though
05:59:57 <tdammers> and monads only tangentially
06:00:21 <JustAStudent> So this would'nt work as well? https://pastebin.com/61BYRjfC
06:00:36 <tdammers> no
06:01:11 <opqdonut> the only problem with that function is that the return type needs to be fixed to `IO Bool` :)
06:01:17 <JustAStudent> Thanks. But I'm confused then. How can I compare an IORef Int to an Int in a 'normal' function?
06:01:26 <JustAStudent> Or any IO type to a 'normal' type
06:01:35 <tdammers> you can't
06:01:40 <boxscape> JustAStudent What do you want the "return"s to do in that snippet?
06:01:42 <tdammers> that's the point
06:01:50 <opqdonut> (ok there are some other problems as well, you should compare ioref_readable to int instead of ioref etc.)
06:02:15 <tdammers> I think you are confused about do notation though, so I suggest you forget that it exists for a while, and write everything in terms of the raw monadic combinators
06:02:19 <tdammers> >>= and >>, that is
06:02:22 <opqdonut> JustAStudent: IO means you are doing side-effects. A "normal" function is a pure function, that is, it can't have side effects
06:03:19 <tdammers> opqdonut: that's slightly misleading. they're not really side effects, and you aren't "doing" them; an IO value is just a value that happens to describe an effectful computation, but those effects aren't triggered by evaluation
06:03:31 <ski> (there are no side-effects in Haskell)
06:03:48 <JustAStudent> Thanks for all your replies. I'm really confused and I'm feeling like I'm not seeing something very obvious. Is there a way to compare an int to an IORef int?
06:03:58 <ski> nope, JustAStudent
06:04:29 <JustAStudent> But why would you store ints in an ioref when you cannot compare them?
06:04:34 <opqdonut> tdammers: sure, but I thought it might be helpful anyway
06:05:18 <tdammers> You can compare values stored in IORefs, but you can't do it in (pure) Haskell. You have to construct an IO action that pulls the value out, compares it, and returns it into IO
06:05:32 <AndreyH> JustAStudent: In order to use pattern matching, there should be a data constructor available for the IORef type, but there is no such.
06:05:44 <tdammers> e.g.: compareIOInt ref i = readIORef ref >>= \j -> return (i == j)
06:05:47 <ski> JustAStudent : let's change the `Int' for a `Widget'. asking to compare a `Widget' with an `IORef Widget' is comparable to asking to compare the `Widget' with an array index (or finite map key). if you don't get your hands on the array the index is meant to be used in (or the finite map the key is meant to be looked up in), you simply have no second `Widget' to compare with
06:06:42 <opqdonut> JustAStudent: in case this helps, here's a version of your original function that should work: waitForFoundOrCompleted found num_threads_completed num_threads = do f <- readIORef found; n <- readIORef num_threads_completed; if (f == 1 || n == num_threads) then return () else waitForFoundOrCompleted found num_threads_completed num_threads
06:06:50 <ski> JustAStudent : an `IORef Widget' is akin to an array index, or a finite map key. an `IORef Widget' does not contain a `Widget'. the `Widget' is kept in some state that is "passed around under the covers" in the `IO' part of the type
06:07:40 <opqdonut> JustAStudent: (of course, you probably want a sleep in there too, otherwise it's a busy loop :)
06:08:03 <ski> JustAStudent : "But why would you store ints in an ioref when you cannot compare them?" -- you don't store `Widget's in `IORef Widget's. you store them in the state that's being kept by `IO'. the `IORef Widget' is just an indicator of the place in which state to look for a `Widget'
06:08:23 <tdammers> IMO the best mental model for IO is that values of type IO a are just plain old pure values that don't "do" anything, they just sit there and represent effectful programs, much like a C source file represents a C program
06:08:38 <tdammers> for example, getLine is the effectful program that reads one line from stdin
06:08:54 <tdammers> putStrLn "Hello" is the effectful program that prints the string "Hello" to stdout
06:09:05 <tdammers> s/is/represents/
06:09:13 <tdammers> but they're both just values
06:09:14 <ski> JustAStudent : this also explains why you can compare two `IORef Widget's for equality, without ever touching equality on `Widget's. it's basically (in a conceptual sense) just comparing two indices, never touching the state that they could be used to reference into
06:09:23 <tdammers> we can bind them to variables, pass them around, etc.
06:09:31 <tdammers> we can even put them in lists and such
06:09:42 <JustAStudent> Thanks! You all have been very helpful. So an IORef is more like a pointer?
06:09:44 <tdammers> :t [putStrLn "Hello", return ()]
06:09:45 <lambdabot> [IO ()]
06:10:10 <ski> JustAStudent : or a memory address. an index into a mutable portion of the addressable memory
06:10:39 <tdammers> JustAStudent: kind of, yes. It's a reference. But we can't do anything with it other than feed it to functions that give us IO values that represent programs to manipulate the value it refers to
06:10:49 <ski> (however, you can't do arithmetic on `IORef X's, you can't add offsets to them, can't subtract one from another, &c.)
06:11:09 <tdammers> and those IO values we can pass around, but we cannot actually *run* those programs from within haskell, only the RTS (runtime system) can
06:11:41 <JustAStudent> Thanks all, and thanks opqdonut for the corrected version of my function. It seems to work now.
06:11:44 <tdammers> so essentially you can think of haskell as a (pure) "metalanguage" that we use to construct (impure) programs
06:13:48 * ski notes `waitForFoundOrCompleted' is busy-waiting, which may be less than ideal
06:16:35 <boxscape> What's the language of those impure programs? A structure of IO actions strung together with bindIOs?
06:17:06 <boxscape> (well, I guess that structure would be a program in that case and not the language the program is in)
06:17:31 <ski> JustAStudent : to clarify what i mean, if your return type is `IO Something', then you can extract the `Int' from the state inside that `IO', referenced by the `IORef Int', and compare that to the other `Int'. but without access to that state which's hidden inside the `IO', there's no way to "extract an `Int' from an `IORef Int'", since the `Int' was never there in the first place
06:19:09 <ski> basically, yes, boxscape
06:19:13 <boxscape> okay
06:20:31 <ski> (and also other primitives. like some versions of functionality given by `catch',`fork',`newIORef',`writeIORef',`hGetChar',&c.)
06:20:41 <ski> (er, `forkIO', i meant)
06:41:27 <infandum> How can I add "#" to the third column of a "a,b,c,d" using lens?
06:42:44 <infandum> If it was a list I could do "over (ix 2) (`T.append` "#") ["a", "b", "c", "d"]", but there must be a way to go directly from a lens
06:43:05 <infandum> like a way to tell it to use T.splitOn "," first
06:47:22 <infandum> It looks like "to" is close, but that just applies the function rather than use it as a getter only
06:47:34 <kuribas> infandum: sounds like a isomorphism
06:48:03 <kuribas> T.splitOn "," and T.concatMap
06:48:59 <infandum> kuribas: Yeah
06:49:05 <infandum> But in the lens
06:49:16 <kuribas> infandum: maybe iso?
06:49:17 <saml> happy thanks
06:49:19 <kuribas> :t iso
06:49:20 <lambdabot> (Profunctor p, Functor f) => (s -> a) -> (b -> t) -> p a (f b) -> p s (f t)
06:49:55 <saml> take two functions and a monad and returns a monad
06:49:58 <kuribas> :t iso (T.splitOn ",") T.concatMap
06:50:00 <lambdabot> error:
06:50:00 <lambdabot>     Not in scope: ‘T.splitOn’
06:50:00 <lambdabot>     No module named ‘T’ is imported.
06:50:11 <kuribas> :t iso (Data.Text.splitOn ",") Data.Text.concatMap
06:50:12 <lambdabot> error:
06:50:12 <lambdabot>     • Couldn't match expected type ‘Data.Text.Internal.Text’
06:50:13 <lambdabot>                   with actual type ‘[Char]’
06:50:48 <Ariakenom> % :t iso (Data.Text.splitOn ",") Data.Text.concatMap
06:50:49 <yahb> Ariakenom: ; <interactive>:1:24: error:; * Couldn't match expected type `Data.Text.Internal.Text' with actual type `[Char]'; * In the first argument of `Data.Text.splitOn', namely `","'; In the first argument of `iso', namely `(Data.Text.splitOn ",")'; In the expression: iso (Data.Text.splitOn ",") Data.Text.concatMap
06:50:56 <infandum> :t iso (Data.List.splitOn ",") Data.List.concatMap
06:50:58 <lambdabot> error:
06:50:58 <lambdabot>     Not in scope: ‘Data.List.splitOn’
06:50:58 <lambdabot>     Perhaps you meant one of these:
06:51:33 <Ariakenom> % :set -XOverloadedStrings
06:51:33 <yahb> Ariakenom: 
06:51:35 <Ariakenom> % :t iso (Data.Text.splitOn ",") Data.Text.concatMap
06:51:35 <yahb> Ariakenom: (Profunctor p, Functor f) => p [Data.Text.Internal.Text] (f (Char -> Data.Text.Internal.Text)) -> p Data.Text.Internal.Text (f (Data.Text.Internal.Text -> Data.Text.Internal.Text))
06:52:52 <infandum> I guess if I need to define that then I might as well just do it the old fashion way
06:53:00 <infandum> It would be similar
06:53:42 <kuribas> infandum: the simple way is usually the good way :)
06:54:33 <infandum> kuribas: But less fun haha
06:54:38 <infandum> and more verbose
06:55:38 <Ariakenom> I assumed yahb had overloaded strings on. Appearantly not.
06:58:13 <boxscape> % :set -XOverloadedStrings
06:58:13 <yahb> boxscape: 
06:58:16 <boxscape> now it does Ariakenom
06:58:30 <boxscape> oh wait
06:58:33 <boxscape> you did the same thing
06:58:44 <Ariakenom> :)
06:58:52 <lordgrenvilll> Hi everyone! Rank beginner here, could someone give me a hint as to why the following 4 lines don't work?
06:58:56 <lordgrenvilll> toDigits :: Integer -> [Integer]
06:58:57 <lordgrenvilll> toDigits x
06:58:59 <lordgrenvilll>   | x < 10 = [x]
06:59:02 <lordgrenvilll>   | otherwise toDigits (x `div` 10) ++ [x `mod` 10]
06:59:20 <lordgrenvilll> the error I get is Parse error (line 4, column 52): parse error (possibly incorrect indentation or mismatched brackets)
06:59:20 <ski> missing an `=' after the `otherwise'
06:59:32 <lordgrenvilll> ah *facepalm* thank you!
07:00:10 <ski> i might use an accumulator here
07:01:07 <lordgrenvilll> could you elaborate?
07:01:26 <ski> repeatedly adding stuff to the end of a list is needlessly inefficient
07:02:36 <ski> that will generate `((([d0] ++ [d1]) ++ [d2]) ++ [d3]) ++ [d4]' (for a five (decimal) digit number)
07:03:00 <lordgrenvilll> OK, I see. I'm a real beginner but I'll read up about that. Thanks again for the help!
07:03:29 <ski> that will first traverse `[d0]', making a copy of that list, that then continues with the list `[d1]'. namely `d0 : [d1]' (which is `d0 : d1 : []', or `[d0,d1]' for short)
07:04:03 <ski> then it will traverse that `[d0,d1]', making a copy of *that* list, that then continues with the list `[d2]'. namely `d0 : d1 : [d2]' (which is `d0 : d1 : d2 : []', or `[d0,d1,d2]' for short)
07:04:26 <ski> then it will traverse that `[d0,d1,d2]', making a copy of *that* list, that then continues with the list `[d3]'. namely `d0 : d1 : d2 : [d3]' (which is `d0 : d1 : d2 : d3 : []', or `[d0,d1,d2,d3]' for short)
07:04:49 <ski> finally it will traverse that `[d0,d1,d2,d3]', making a copy of *that* list, that then continues with the list `[d4]'. namely `d0 : d1 : d2 : d3 : [d4]' (which is `d0 : d1 : d2 : d3 : d4 : []', or `[d0,d1,d2,d3,d4]' for short)
07:05:19 <lordgrenvilll> but isn't that how all recursion works?
07:05:19 <ski> so, you're "passing by" first `d0', then `d0' and `d1', then `d0' and `d1' and `d2', then `d0' and `d1' and `d2' and `d3'
07:05:30 <ski> this is `1 + 2 + 3 + 4' steps
07:06:12 <ski> otoh, if you instead do `[d0] ++ ([d1] ++ ([d2] ++ ([d3] ++ [d4])))', then it will only "pass by" `d0' once, then `d1' once, then `d2' once, then `d3' once
07:06:20 <ski> so, that's only `1 + 1 + 1 + 1' step
07:06:40 <ski> because we're here repeatedly adding to the *front* of a list (starting with `[d4]')
07:07:07 <ski> repeatedly adding to the front is not a problem, it's as cheap as you'd expect it to be
07:07:08 * hackage unexceptionalio 0.5.0 - IO without any non-error, synchronous exceptions  https://hackage.haskell.org/package/unexceptionalio-0.5.0 (StephenWeber)
07:07:23 <Cale> lordgrenvilll: One way to think about it is that xs ++ ys takes O(length xs) steps to fully reduce, so using it on lists where the left list is long costs more
07:07:36 <ski> but repeatedly adding to the *end* of a list is a problem, since the only way to get to the end is to traverse all the way to it, from the start
07:08:08 * hackage unexceptionalio-trans 0.5.0 - A wrapper around UnexceptionalIO using monad transformers  https://hackage.haskell.org/package/unexceptionalio-trans-0.5.0 (StephenWeber)
07:08:36 <ski> you can't jump to the end of `[d0,d1,d2]' (that is, `d0 : d1 : d2 : []') directly. you have to pass all the `:'s on the way to the `[]' (the empty list), which occurs at the end
07:08:56 <Cale> There's a clever trick we can use to sidestep this problem, which is that instead of building a list of type [a], we can build a function [a] -> [a] which will add elements to the beginning of whatever list it's given
07:09:06 <ski> lordgrenvilll : do you understand how lists a built out of `[]' and `:', in a single-linked fashion ?
07:09:16 <Cale> So the empty list [] will become the identity function id x = x
07:09:29 <Cale> A singleton list [x] will become the function (x:) which adds x to the start of a list
07:09:35 <lordgrenvilll> @ski yes, I think I do
07:09:36 <lambdabot> Maybe you meant: wiki src ask
07:09:49 <Cale> and most importantly, list concatenation (++) will become (.) function composition
07:09:51 * ski thinks perhaps Cale maye be jumping one step too far, at this point (depending on how familiar lordgrenvilll is with accumulating-style)
07:10:15 <Cale> So we'll get:
07:10:34 <Cale> toDigits :: Integer -> ([Integer] -> [Integer])
07:10:47 <ski> lordgrenvilll : if you keep a "current digits, so far" argument, you could add to the front of that, and, at the end, you'll have all your digits (in the right order, nonetheless)
07:10:52 <Cale> toDigits x
07:10:55 <Cale>   | x < 10 = (x:)
07:11:12 <boxscape> I suspect the answer is no, but, is there a REPL for core?
07:11:18 <Cale>   | otherwise = toDigits (x `div` 10) . ((x `mod` 10) :)
07:11:22 <ski> (Cale is getting at the same thing as me, but from a slightly different (a little bit more abstract) angle)
07:11:29 <geekosaur> there's not even a file-based way to inject core, iirc
07:11:39 <boxscape> sorry for breaking your multiline code cale
07:11:40 <Cale> Yeah, it might be a little weird to think about constructing functions at first
07:11:47 <boxscape> geekosaur oh, interesting
07:12:26 <geekosaur> once upon a time there was -fext-core but it wasn't even the same language as internal core
07:13:05 <Cale> But yeah, having constructed a function like this, we can implement the original toDigits by applying the result of this one to an empty list
07:13:31 <Cale> (maybe I should have named this one toDigits' so we could write toDigits x = toDigits' x []
07:13:44 <Cale> )
07:14:10 <ski> lordgrenvilll : you might want to check out the "Shlemiel the painter’s algorithm" at <https://www.joelonsoftware.com/2001/12/11/back-to-basics/>. it's talking about basically the same issue of "repeatedly adding to the end (by first traversing to the end each time, from the start)"
07:14:37 <boxscape> The reason I'm actually asking is because I just saw on stackoverflow someone saying that things like "case x of y -> ()" force x to WHNF, which isn't true in ghc Haskell, but they might have been talking about case, so I was wondering if it's true in case
07:14:40 <boxscape> uh
07:14:46 <boxscape> s/case/core
07:14:46 <lordgrenvilll> oh yeah, I've actually seen that post!
07:14:49 <boxscape> -.-
07:15:03 <lordgrenvilll> I do understand the inefficiency of going over the whole list each time and appending to the end
07:15:14 <geekosaur> Haskell only forces to WHNF if it needs to. core always does
07:15:19 <boxscape> ok, thanks
07:15:25 <geekosaur> so in that one, since y is irrefutable, no forcing
07:15:29 <lordgrenvilll> I just wasn't thinking much about optimizing performance at this stage
07:15:49 <ski> lordgrenvilll : if you see a recursion `fun x = fun (...) ++ (...)', then this should be a warning sign
07:16:39 <ski> lordgrenvilll : did you understand what to try for my "accumulator" suggestion ?
07:16:50 <boxscape> seems like any recursion of the form `fun x = fun (...) <+> fun (...)` should be cause for concern, regardless of what <+> is
07:16:53 <ski> lordgrenvilll : did you understand what Cale was talking about ?
07:17:10 <Cale> One of the first things I was tasked with when I was hired at iPwn Studios back in 2009 or so was improving the performance of some code that was responsible for exporting data from our game's map editor. It was taking over half an hour and a ridiculous amount of memory. I noticed that most of what the code was doing was chopping up bytestrings and concatenating them together, and so before even bothering to understand anything more 
07:17:10 <Cale> than that, I changed the code to instead construct functions ByteString -> ByteString using effectively the same trick as above.
07:17:12 <ski> boxscape : not if `(<+>)' is a thin wrapper for a data constructor
07:17:35 <Cale> The export then took a couple of seconds and ran in a few megabytes of space, so we were done :)
07:17:38 <boxscape> ski ah, because it's just two thunks then?
07:18:01 <ski> boxscape : but yes, the same kind of issue can (sometimes) occur with `(>>=)' as well, e.g.
07:18:12 <lordgrenvilll> ski I don't think I would be able to implement it, no
07:18:31 <Cale> (nowadays, you'd probably use bytestring's Builder type, which is a more refined version of the trick, but it didn't exist yet)
07:18:47 <ski> lordgrenvilll : well, by "accumulator" i mean to keep track of the "result, so far". specifically, in an extra/auxilary parameter of your recursive function
07:19:39 <ski> lordgrenvilll : when you reach the base case, you trust that all things that you want to return as result have been accumulated, so you basically just return the accumulator (perhaps after some minor, or final, adjustment)
07:20:30 <ski> lordgrenvilll : and, in the recursive case, instead of nesting the recursive call inside (in this case) an invocation of `++', you instead just call yourself recursively, directly, adding the extra thing to this accumulator parameter
07:20:41 <ski> lordgrenvilll : making any sense at all ?
07:21:37 <ski> lordgrenvilll : i could show an example of what i mean, for another function, if that helps ..
07:22:01 <Cale> reverse is another good example, as is flattening a tree
07:22:17 * ski was thinking of summing
07:22:20 <lordgrenvilll> sorry. At the moment I'm trying to figure out how to see chat history (just started using weechat) - was trying to see your earlier posts
07:22:29 <ski> ah, okay
07:24:08 * hackage futhark 0.13.1 - An optimising compiler for a functional, array-oriented language.  https://hackage.haskell.org/package/futhark-0.13.1 (TroelsHenriksen)
07:25:20 * ski isn't familiar with WeeChat, but it seems a quick start guide claims the `<PgUp>' and `<PgDn>' buttons would do the trick ?
07:25:28 <lordgrenvilll> got it (fn + up arrow on mac). so @ski if I were to build the list in reverse would it solve this problem?
07:25:43 <lordgrenvilll> (no pg-up on mac)
07:25:58 <ski> ah, i guess some more crammed laptop keyboard
07:27:11 <ski> (also, it's not IRC custom to adorn nicknames with sigils like `@'. if you'd like to refer to or address someone, just mention their nickname. in the addressing case, it may help to mention the nickname at the start of the message, followed say by a colon or comma, and the message)
07:27:34 <ski> lordgrenvilll : "if I were to build the list in reverse would it solve this problem?" -- maybe ?
07:27:37 <ski> think about it ?
07:27:51 <ski> try it out, and see whether things go according to plan ?
07:27:54 <lordgrenvilll> OK, thanks for etiquette tip
07:28:06 <ski> lordgrenvilll : would you like to see another accumulating-style example ?
07:28:06 <lordgrenvilll> I will fool around with it and see
07:28:24 <ski> (to make my abstract description more concrete, hopefully)
07:28:26 <lordgrenvilll> ski: if you have the time, that would be great
07:28:54 <ski> okay, let's first consider summing. we could also cover reversing, to see how it differs
07:28:59 <ski> so, consider
07:29:05 <ski>   sumList :: [Integer] -> Integer
07:29:08 * hackage tmp-postgres 1.21.1.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.21.1.0 (JonathanFischoff)
07:29:10 <ski>   sumList [    ] = 
07:29:19 <ski> er
07:29:22 <ski>   sumList [    ] = 0
07:29:26 <ski>   sumList (n:ns) = n + sumList ns
07:30:08 * hackage intro 0.6.0.0 - Safe and minimal prelude  https://hackage.haskell.org/package/intro-0.6.0.0 (minad)
07:30:22 <ski> (note that i define the sum of zero numbers (empty list) to be zero. i hope you agree that this is natural to do, if we want to define sum of empty list at all. i also claim that we want to define this, even if it may seem "useless", at first glance)
07:31:19 <ski> (also, if we were defining product, then the product of zero numbers would be defined to be the number `1', one. not zero. you may or may not accept that yet, may or may not feel comfortable with it. that's just something that you could consider, if you feel like it)
07:32:10 <ski> anyway, if we have at least one number, `n', in our list `n:ns', `ns' being the list of the remaining numbers (possibly zero of them). then the sum of the list `n:ns' will be `n' added to the sum of the list of the remaining numbers (`ns')
07:32:10 <lordgrenvilll> ah, I get why. because it's the identity
07:32:14 <ski> yes
07:32:25 <ski> now, if we compute e.g.
07:33:41 <ski> `sumList [2,3,5,7]' which is shorthand for `sumList (2:3:5:7:[])' (or `sumList (2:(3:(5:(7:[]))))', if you want extra disambiguation), then we could show the step-wise reduction of this as :
07:33:51 <ski>      sumList (2:3:5:7:[])
07:34:02 <ski>   =  2 + sumList (3:5:7:[])
07:34:10 <ski>   =  2 + (3 + sumList (5:7:[]))
07:34:19 <ski>   =  2 + (3 + (5 + sumList (7:[])))
07:34:31 <ski>   =  2 + (3 + (5 + (7 + sumList [])))
07:34:34 <ski>   =  2 + (3 + (5 + (7 + 0)))
07:34:37 <ski>   =  2 + (3 + (5 + 7))
07:34:40 <ski>   =  2 + (3 + 12)
07:34:44 <ski>   =  2 + 15
07:34:46 <ski>   =  17
07:35:15 <ski> do you see how this is a consequence of the definition of `sumList' ?
07:35:54 <ski> we call `sumList' recursively "to the right of `+'", and that's why we get this "right-leaning" "tree" of additions, with bracketting "to the right"
07:35:55 <lordgrenvilll> yes
07:35:59 <lordgrenvilll> we kind of fold it up from the right
07:36:18 <lordgrenvilll> after interpreting it from the left
07:36:29 <ski> so, no additions will happen here, until we reach the end of the list (so that we can start adding things to `0', coming from the empty list, which is the end of the list)
07:36:57 <ski> in each step, the "current call" is the call to `sumList'
07:37:51 <ski> around it, we have a "context" of "delayed additions", or more generally "what to do after the call". this would be stored in the computer in some kind of stack
07:38:06 <ski> and, as you can see, the stack grows, until we reach the end of the list
07:39:52 <lordgrenvilll> I see! So the key thing is the order - atom ++ function is OK, but not function ++ atom ? 
07:40:02 <lordgrenvilll> I just made up those terms but hopefully you get what I mean
07:40:06 <ski> (in a strict language, this would just be how function calls work. in Haskell, which is non-strict (typically implemented with laziness), arguments of calls aren't typically evaluated before the calls. however, in this case, the call to the function `(+)' requires both arguments to be evaluated. that's why we get this growing stack behaviour, from the recursion here. this doesn't always happen in Haskell. it only happens here because `(+)' is "strict")
07:40:32 <ski> anyway, let's say we wanted to "do the additions as we walk along the list"
07:41:04 <ski> so, we need to know, at each step, not just the list (typically some tail of the original list) that we have left to sum, but also the sum so far
07:41:56 <ski> now, as i mentioned before, we can do this by introducing an auxilary parameter (the accumulator), for keeping track of this "sum so far"
07:42:49 <ski> i'll also rename the function slightly (one reason for that is that it now has a different type. if we didn't rename, then any previous calls to the function, from other places, would have to be adapted)
07:42:54 <ski> so
07:43:02 <ski>   sumListTo :: [Integer] -> Integer -> Integer
07:43:14 <ski>   sumListTo [    ] acc = acc
07:43:29 <ski>   sumListTo (n:ns) acc = sumListTo ns (acc + n)
07:44:41 <ski> so, in the base case (reaching the end of the list, which is an empty list), we assume all the number that we've seen before have already been added into the parameter `acc' (for "accumulator". you could call it `sumSoFar', if you prefer), and so we just return the current sum so far, in the base case, being the final sum
07:45:05 <ski> in the recursive case, we add the current number, `n', to the accumulator parameter, and carry on with the remainder of the list
07:45:14 <ski> so, let's see how this could play out
07:46:00 <ski> however, we also need to call this new function with some initial value of the accumulator. if we're summing up, it makes sense to start adding to an initial sum of zero, so we'll use `0' (note that the base case no longer mentions zero)
07:46:04 <ski> so
07:46:20 <ski>      sumListTo (2:3:5:7:[]) 0
07:46:31 <ski>   =  sumListTo (3:5:7:[]) (0 + 2)
07:46:35 <ski>   =  sumListTo (3:5:7:[]) 2
07:46:41 <ski>   =  sumListTo (5:7:[]) (2 + 3)
07:46:49 <ski>   =  sumListTo (5:7:[]) 5
07:46:55 <ski>   =  sumListTo (7:[]) (5 + 7)
07:47:12 <ski> er, that should be
07:47:14 <ski>   =  sumListTo (7:[]) (5 + 5)
07:47:18 <ski>   =  sumListTo (7:[]) 10
07:47:25 <ski>   =  sumListTo [] (10 + 7)
07:47:29 <ski>   =  sumListTo [] 17
07:47:33 <ski>   =  17
07:47:45 <ski> lordgrenvilll : does this make any sense, so far ?
07:52:14 <lordgrenvilll> yeah, it does
07:52:48 <lordgrenvilll> you're kind of manually overriding the lazy evaluation, would that be accurate?
07:53:52 <ski> not really. so far, the same kind of issue, with the same kind of cure, would apply to a strict language, employing eager reduction (eagerly reducing arguments before calling functions)
07:55:25 <ski> (i should probably add that it's not always a good idea to convert a "direct recursion" to an "accumulating recursion". in this integer summing case, it most probably is a good idea (unless the implementation manages to do it for you under the covers, anyway, i suppose))
07:56:59 <lordgrenvilll> OK
07:57:13 <ski> anyway, the point here is that, by introducing an accumulator, we're performing the additions as we "walk down" the list (not when we "walk back out" of the resulting recursion). and so, there's "nothing to do after the recursive calls". the recursive call to `sumListTo' is a tail call (nothing to do after, the result from that call will be the result of the current call to `sumListTo'. tail calls can be implemented more efficiently, not growing a stack)
07:57:22 <ski> (also, note that we've effectively computed `(((0 + 2) + 3) + 5) + 7' .. rather than `2 + (3 + (5 + (7 + 0)))', which `sumList (2:3:5:7:[])' computed. however, these two compute the same result, because "grouping doesn't matter, when adding" (and also "adding zero does nothing"). that fact is known as the "associative law (of addition)")
07:59:01 <ski> however, for completeness, i mention one slight problem with this version of `sumListTo' .. it doesn't actually work, like i described, if we use lazy evaluation !
07:59:17 <lordgrenvilll> why not?
07:59:49 <ski> the issue is that with lazy evaluation, we don't evaluate arguments to calls, unless it's clear that their values will be needed. more specifically, if we're trying to match on them
08:00:31 <ski> we know that the accumulator will be needed, in the end (the base case), but a naïve implementation will put off actually computing the additions in the accumulator, until the very end
08:01:33 <ski> what will actually happen (unless a SSC realizes it will always be needed, in the end (so might just as well do the work already) .. but in more complicated cases, it may not realize it) is :
08:01:38 <ski>      sumListTo (2:3:5:7:[]) 0
08:01:41 <ski>   =  sumListTo (2:3:5:7:[]) 0
08:01:49 <ski>   =  sumListTo (3:5:7:[]) (0 + 2)
08:01:57 <ski>   =  sumListTo (5:7:[]) ((0 + 2) + 3)
08:02:03 <ski>   =  sumListTo (7:[]) (((0 + 2) + 3) + 5)
08:02:10 <ski>   =  sumListTo [] ((((0 + 2) + 3) + 5) + 7)
08:02:15 <ski>   =  (((0 + 2) + 3) + 5) + 7
08:02:19 <ski>   =  ((2 + 3) + 5) + 7
08:02:23 <ski>   =  (5 + 5) + 7
08:02:28 <ski>   =  10 + 7
08:02:30 <ski>   =  17
08:02:31 <deni> Can anyone tell me what "ambiguous infix expression" when dealing with TH means? I'm stumped
08:02:47 <lordgrenvilll> so then you haven't gained anything
08:02:51 <[exa]> deni: parsing is hard. :] can you post a minimal example?
08:03:31 <ski> right, instead of building up stack, we (probably) build up heap space, storing the delayed additions (which are later converted into stack, when we traverse inside the `+'s to get to the `0', so we can start adding)
08:03:41 <ski> lordgrenvilll : however, the fix is simple :
08:03:50 <deni> [exa]: I'm trying to compile the `marvin` package with ghc 8.6
08:03:53 <ski>   sumListTo [    ] !acc = acc
08:03:56 <ski>   sumListTo (n:ns) !acc = sumListTo ns (acc + n)
08:04:01 <deni> let me get the full error
08:04:29 <deni> [exa]: http://dpaste.com/143E99A
08:04:59 <ski> the `!' will tell the implementation "yes, this value will be needed in the end". and so it most probably will arrange to evaluate it at that point (unless it sees a better way to do things, i guess)
08:05:09 <deni> it's likely related to the issue I opened here (for the accompanying package): https://github.com/JustusAdam/marvin-interpolate/issues/2 but I'm not sure
08:05:20 <ski> lordgrenvilll : so, that modified version, will give us the behaviour we want
08:05:52 <ski> lordgrenvilll : now, remember i renamed the function. now, let me define the original `sumList', in terms of this function :
08:06:01 <ski>   sumList :: [Integer] -> Integer
08:06:08 <ski>   sumList ns = sumListTo ns 0
08:06:49 <ski> this way, we don't have to remember to initialize the accumulator to zero, when we want to sum a list, we just call `sumList' (as before). but now it acts as a thin "wrapper", around the "worker" `sumListTo'
08:07:21 <lordgrenvilll> OK, so that's just neater/clearer code
08:07:29 <ski> often, one would add (indented) `where' after the `sumList' definition above, and then the whole definition of `sumListTo' (also indented)
08:07:46 <ski> that way, we've hidden the implementation details (`sumListTo') from the users
08:08:33 <ski> (and, often, people wouldn't bother to come up with a very sensible name for such internal "loop functions". calling them `loop' or `sumAux' or `doIt' or whatever strikes their fancy)
08:09:09 <ski> (occasionally, such a "worker" function can be a separate interest, and then one'd not hide it inside the "wrapper", and would make sure to invent some more sensible name)
08:09:46 <lordgrenvilll> I see
08:09:47 <ski> (btw, in this case, note that the law `sumListTo ns acc = acc + sumList ns' holds)
08:10:10 <ski> now, let's take the second example
08:10:15 <deni> [exa]: I think it's got something to do with some recent GHC changes since I already had to fix the MonadFail thing. But I'm not sure...it's hard tracking down a changelog for these things
08:10:18 <ski> (unless you have any questions or comments ?)
08:10:18 <lordgrenvilll> so in my case acc could be a list?
08:10:29 <ski> well, take this example
08:10:44 <ski>   reverse :: [Char] -> [Char]
08:10:52 <ski>   reverse [    ] = []
08:11:05 <ski>   reverse (c:cs) = reverse cs ++ [c]
08:11:29 <ski> (note that this is a "bad recursion", since it'll "left-nest" calls to `++')
08:12:01 <ski> can you figure out how to fix this, by introducing an accumulator ?
08:12:38 <lordgrenvilll> so it'll be something like 
08:12:50 <lordgrenvilll> reverse :: [Char] -> [Char] -> [Char] 
08:13:09 <lordgrenvilll> reverse [    ] [] = []
08:13:44 <ski> (also note that in this case, using `!' to force evaluation of a parameter isn't really much use. the reason it helped with `sumListTo' is that we were adding numbers, which are "small", while (unevaluated) additions can be "large". however, here, the results will be lists, which are already "large". it's not so clear that attempting to evaluate intermediate lists early will help much ..)
08:13:56 <haskeldjiq> has anyone implemented ForkableMonad?
08:13:56 <ski> well, i would suggest renaming the function (as before)
08:14:07 <haskeldjiq> on a custom stack
08:14:10 <lordgrenvilll> right
08:14:17 <lordgrenvilll> reverse_ :: [Char] -> [Char] -> [Char] 
08:14:23 <lordgrenvilll> reverse_ [    ] [] = []
08:14:24 <ski> also, which parameter is the accumulator, the "result, so far" ?
08:14:25 <dmwit> I think no, and it is generally not super possible. But see also MonadUnliftIO or whatever it's called.
08:14:33 <lordgrenvilll> it's the empty list
08:14:47 <lordgrenvilll> wich we'll add to at each step...
08:14:57 <lordgrenvilll> or wait is that not going to help? since we're appending to end of a list?
08:15:20 <ski> so, you're saying that, when we reach the end of the list-to-reverse, the accumulator parameter should always be empty ?
08:16:06 <ski> (recall i didn't say `sumListTo [    ] 0 = 0', before ..)
08:16:32 <dmwit> haskeldjiq: (My last message was for you.)
08:17:02 <haskeldjiq> dmwit: thank you
08:17:13 <haskeldjiq> dmwit: I actually got it to compile
08:17:17 <ski> lordgrenvilll : do you want a hint ? (a visual image, which might or might not help)
08:17:18 <haskeldjiq> dmwit: let me see if it works
08:17:35 <lordgrenvilll> sure
08:18:01 <ski> let's say you have a deck of cards, on the table, you want to reverse the order of the cards. how would you do it ?
08:18:32 <haskeldjiq> flip the deck
08:18:33 <haskeldjiq> easy
08:18:41 <ski> (not just turning the deck upside-down. each card should still face the same direction as before)
08:18:58 * ski smiles at haskeldjiq
08:19:33 <haskeldjiq> dmwit: I did it
08:19:34 <dmwit> haskeldjiq: (Why not possible? Except for ReaderT, which doesn't have such amazing effects to share across monadic actions, it's usually not super sensible to share the effects of most monad transformers between two threads.)
08:19:37 <lordgrenvilll> take off each card from the top and put it on top of the new stack
08:19:39 <lordgrenvilll> O(n)
08:20:13 <dmy> Hi, I am building for the first time on Raspberry PI (4 with Raspbian 10 and the default ghc 8.4.4) and I noticed that "-N` and "-qg" RTS options are not available (among others). Does anyone known why and what behavior should I expect by default?
08:20:16 <ski> yep. the new stack is your accumulator, your "result-so-far"
08:20:38 <haskeldjiq> dmwit: in this case we have a callback running in m and we need to have a "forever $ do callback"
08:20:46 <ski> lordgrenvilll : so, when the initial deck has been exhausted, what do you do ?
08:20:46 <dmwit> dmy: Did you build whatever executable you're trying to pass those options to with -rtsoptions?
08:21:28 <dmwit> dmy: ...and -threaded, I guess, for -N
08:21:56 <dmwit> I guess I should mention I've never played with a PI, so perhaps even with those options something important is not available.
08:21:59 <dmwit> dunno
08:22:05 <dmwit> But on not-PI, those would be my first two questions.
08:22:09 <lordgrenvilll> ski return the new deck
08:22:45 <ski> lordgrenvilll : would you say that's what `reverse_ [    ] [] = []' is doing ?
08:23:16 <lordgrenvilll> sorry, maybe I didn't understand the notation. is [   ] not an empty list?
08:23:27 <dmwit> haskeldjiq: If you'd like, you might consider sharing a few snippets of what you came up with. You are not the first person to ask for this, so we do have some experience pointing out problems with the standard obvious "solutions".
08:23:38 <ski> it's the empty list, sure
08:23:53 <haskeldjiq> dmwit: sure
08:24:07 <haskeldjiq> dmwit: I'm using 
08:24:08 <haskeldjiq> http://hackage.haskell.org/package/forkable-monad-0.2.0.3/docs/Control-Concurrent-Forkable.html
08:24:11 <dmy> @dmwit yes with "-threaded"
08:24:11 <lambdabot> Unknown command, try @list
08:24:18 <ski> lordgrenvilll : anyway, you could also suggest a recursive case, if you'd rather go on to that (perhaps that'd help)
08:24:28 <dmy> dmwit: yes with "-threaded"
08:25:01 <dmy> Ok, found this: https://gitlab.haskell.org/ghc/ghc/issues/13007
08:25:26 <dmwit> haskeldjiq: Okay. The IO and ReaderT instances there are sensible, but beware the StateT instance: the state changes in the original thread and in the forked thread will not be mutually visible.
08:25:36 <dmwit> They'll be completely distinct.
08:25:37 <haskeldjiq> dmwit: my instance looks like this - https://pastebin.com/kYtc9cng
08:25:56 <haskeldjiq> dmwit: yeah StateT wouldn't really make sense but I think we're okay
08:26:07 <dmwit> Similarly for the short-circuiting that ExceptT offers: exceptions thrown in one thread will not abort the other.
08:26:30 <dmwit> I don't know what runKatipContextT does, but I wouldn't be surprised if a similar caveat applied to it.
08:26:41 <haskeldjiq> dmwit: Yeah we're kind of messed up with that, ExceptT is everywhere but we'll refactor sometime in the future
08:26:51 <haskeldjiq> dmwit: it's a logging library 
08:27:00 <haskeldjiq> dmwit: http://hackage.haskell.org/package/katip
08:27:28 <dmwit> Well, things are certainly a lot simpler if you don't actually care about the effects in your monad stack.
08:27:34 <dmwit> -_-
08:27:47 <haskeldjiq> dmwit: I guess you could call it a luxury lol
08:28:28 <haskeldjiq> dmwit: handling exceptions within the callbacks will be fun though
08:28:48 <haskeldjiq> dmwit: but it's past the end of the workday so I'm closing my eyes
08:29:44 <dmwit> Okay, runKatipContextT is just a fancy runReaderT. That one is probably fine.
08:29:55 <lordgrenvilll> reverse_ [x] [] = [x] : []
08:29:58 <lordgrenvilll> maybe?
08:30:16 <lordgrenvilll> I'm sorry, I'm really new to haskell and it's hard for me even to think of how to express basic things
08:30:34 <ski> it's okay, it will take some time to get used to it
08:30:44 <haskeldjiq> dmwit: thank you for thinking along!
08:30:52 <lordgrenvilll> what I want to do is sort of, for each item in the list, append to accumulator
08:31:10 <lordgrenvilll> to the front of accumulator
08:31:13 <ski> (just like it took some time to get used to basid ideas of imperative programming, like assignment, sequencing, iteration. even though you may have forgotten most of that)
08:31:20 <ski> yes
08:31:41 <lordgrenvilll> yeah I'm pretty confident in Python but in Haskell I really do feel like I've forgotten how to code
08:32:11 <lordgrenvilll> and then if you have [] acc then just return acc
08:32:22 <ski> i would like to see your attempt/suggestion, for this recursive case, when you're looking at a current item in the list, and also have the list of all remaining items (and, of course, also the accumulator, the items already reversed, so far)
08:32:35 <ski> that sounds like a plan, lordgrenvilll
08:32:49 <ski> could you write that last statement of yours, into code ?
08:33:48 <dmwit> I don't want to hijack the conversation too much, but I think it may actually be somewhat helpful to see what the two cases an experienced Haskeller would immediately be thinking about would be:
08:33:52 <dmwit> reverse_ [] acc = ...
08:33:56 <dmwit> reverse_ (x:xs) acc = ...
08:34:33 <dmwit> (Then, later, while filling in `...`, they might ponder whether they should also be pattern-matching on `acc` to check whether it's [] or a:as.)
08:35:39 <lordgrenvilll> so like reverse_ (x:xs) acc = reverse_ xs (x:acc)
08:35:43 <lordgrenvilll> is that it?
08:36:03 <lordgrenvilll> do I need to put acc in parentheses to show it's a list?
08:36:12 <ski> it definitely adds the current item to the accumulator
08:36:18 <ski> nope, you don't
08:36:41 <ski> the only remaining question is whether the items added to the accumulator will come out in the right order, in the end
08:37:05 <ski> (well, you also have to nail the base case .. but that might be related to what i just said)
08:37:16 <lordgrenvilll> oh, right...
08:37:36 <nil> lordgrenvilll: the parentheses around (x:xs) are only there because `reverse_ x:xs acc` would be parenthesised as `(reverse_ x):(xs acc)`, which doesn't make sense
08:37:56 <lordgrenvilll> oh I see
08:38:03 <Putonlalla> As an experienced Haskeller, my thought process was "write the simplest definition that preserves information and makes the recursion decreasing wrt the matched argument and think later", dmwit.
08:38:11 <nil> this is because function application (juxtaposition, separating things with spaces) has the highest precedence; in particular, higher than (:)'s precedence
08:38:16 <lordgrenvilll> am I allowed to append to the end of a list?
08:38:27 <ski> (aside, the only reason there's any brackets in `reverse_ (x:xs) acc' is because `reverse_ x:xs acc' will be interpreted as `(reverse_ x):(xs acc)' (application binds tighther than any normal infix operator, like `:'). also `reverse_ xs x:acc' will mean `(reverse_ xs x):acc')
08:38:49 <Putonlalla> It happened to work immediately, so I never got to the "think later" part.
08:38:53 * nil hugs ski
08:39:46 <ski> lordgrenvilll : append is okay, if you think you need it (do you need it ?). it's "repeatedly appending to the end" that's less efficient than would be expected (Schlemiel the painter)
08:39:50 <dmwit> Putonlalla: Just to double-check: do you believe your experience is in agreement with my description of how an experienced Haskeller would proceed, or in contradiction? (Personally it feels like agreement to me.)
08:40:00 * ski hugs nil back
08:40:39 <Putonlalla> Yes, it's quite close, dmwit.
08:41:16 * dmwit nods
08:41:24 <Putonlalla> Exposure to Coq has taught me to always think of the recursive measure first.
08:42:39 <Putonlalla> So, along the lines of "if the list is decreasing and information must be preserved, something else must be increasing".
08:42:53 <lordgrenvilll> well the base case is reverse_ [] acc = acc
08:43:16 <lordgrenvilll> and then the other is reverse_ (x:xs) acc = reverse_ xs (acc:x)
08:43:39 * hackage pandoc 2.8.0.1 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-2.8.0.1 (JohnMacFarlane)
08:43:49 <ski> lordgrenvilll : could you try to hand-trace through an example, similar to the examples i did, before ?
08:44:21 <ski> lordgrenvilll : e.g. `reverse_ (2:3:5:7:[]) []'
08:46:44 <nil> Putonlalla: i find it (even) easier to think about this visually: if i had a stack of plates and i wanted to reverse it, i'd repeatedly pop from the first stack and push onto my new stack until the first stack is empty
08:47:10 <gauga> hey haskell experts! 
08:47:34 <gauga> could someone help a newbie write a rather basic function? 
08:48:06 <lordgrenvilll> ok... so  reverse_ [1,2,3] []  
08:48:30 <gauga> this function is supposed to take a listOfLists and return the list of all pairs appearing at the start of lists, for example: initialPairs [["time", "for", "a", "break"], ["not", "yet"]]
08:48:50 <lordgrenvilll> =  reverse_ (1:2:3) ()  
08:49:06 <lordgrenvilll> =  reverse_ (2:3) (:1)  
08:49:12 <lordgrenvilll> =  reverse_ (3) (:1:2)  
08:49:18 <lordgrenvilll> =  reverse_ () (:1:2:3)  
08:49:19 <ski> (missing some `[]'s)
08:49:21 <nil> gauga: what should that evaluate to?
08:49:21 <gauga> I have written a function that works for the example above but doesn't work if one of the lists is only a one-item list, such as initialPairs [["time", "for", "a", "break"], ["not", "yet"]]
08:49:29 <lordgrenvilll> =  (:1:2:3:)  
08:49:31 <evelyn>  So if "time" were also matched by "time" in the second list, you would form a pair?
08:49:49 <lordgrenvilll> ski what do you mean?
08:49:50 <gauga> sorry, initialPairs [["time", "for", "a", "break"], ["a"]]
08:49:53 <ski> lordgrenvilll : but i believe you may already be seeing a problem ? (and how to fix it ?)
08:50:09 <gauga> yes, duplicates should appear
08:50:14 <gauga> yes, evelyn
08:50:16 <nil> gauga: what should that evaluate to?
08:50:18 <ski> lordgrenvilll : `[1,2,3]' is not shorthand for `1:2:3'. it's shorthand for `1:2:3:[]'
08:51:06 <lordgrenvilll> ok so like this?     reverse_ (1:2:3:[]) ()  
08:51:21 <lordgrenvilll> or     reverse_ (1:2:3:[]) ([])  
08:51:48 <evelyn> gauga: What have you written already, and where did you get stuck?
08:52:00 <ski> lordgrenvilll : however, that's a relatively minor detail that's, in this case, not that crucial (but, imho, it's good to get into the habit to be pedantic about these things, when learning. you can be sloppy later, when you know what you really meant, anyway, as opposed to confusing yourself with sloppy notation, which i've seen newbies do many times, just saying ..)
08:52:02 <gauga> hi nil, so here are some examples: initialPairs [["time", "for", "a", "break"], ["not", "yet"]]
08:52:33 <gauga> hi evelyn, here is my function: initialPairs document = map (\xs -> (head xs, xs !! 1) else $ document
08:52:36 <ski> lordgrenvilll : yes (or just `[]' in place of `([])'. the latter isn't wrong, though, just needlessly complicated, having redundant brackets)
08:52:36 <nil> gauga: you're showing a function call without telling what it should result in, so it's hard to understand what the function should do
08:53:09 * ski might, sometimes, have an allergy of redundant brackets (unless they're intensionally included)
08:53:32 <lordgrenvilll> OK, no it's good to know
08:53:45 <lordgrenvilll> so is the problem that I'm repeatedly appending to a list?
08:54:23 <gauga> nil, I thought I was showing the result after == ? so if I call initialPairs with [["time", "for", "a", "break"], ["not", "yet"]] then I should get [("time","for"),("not", "yet")]
08:54:24 <ski> lordgrenvilll : well .. it appears that you have a reversing function, that .. doesn't reverse a list ?
08:54:39 <nil> gauga: your previous messages didn't contain a == at all
08:54:54 <ski> lordgrenvilll : `1' is still in front of `2', which is in front of `3', in the final accumulator, it seems
08:55:07 <gauga> if I call initialPairs with [["time", "for", "a", "break"], ["a"]] then I should get [("time", "for")]
08:55:17 <nil> gauga: so, you want to map each list to a pair consisting of its first two elements? what about lists that contain fewer than 2 elements?
08:55:18 <ski> (lordgrenvilll : also, adding in the missing `[]' could maybe help giving a clue. or maybe not)
08:55:25 <nil> ah, you just want to ignore them
08:55:52 <gauga> I am stuck with this latter example where the indexing doesn't work because lists that contain fewer than 2 elements should be skipped; I want to just ignore them but don't know how to write that in Haskell
08:55:53 <ski> lordgrenvilll : what is the root cause of the items not appearing reversed, would you say ? in terms of your two defining equations for `reverse_' ?
08:55:55 <evelyn> gauga: When you map, you're applying a function over each element. In this case the elements are the sub-lists. So (head xs, xs !! 1) would actually look at the first two elements of the sub-lists.
08:55:59 <evelyn> !! is unsafe
08:56:36 <evelyn> and hence causes exception for lists of length 1 or 0.
08:56:40 <gauga> yes, !! is indeed unsafe and the tests fail; I want to ignore lists that have fewer than 2 elements but I don't know how to write that in Haskell
08:56:48 <ski> pattern-matching, gauga
08:57:06 <nil> gauga: list comprehension and pattern matching allow you to express this very concisely:  initialPairs l = [(a, b) | a:b:_ <- l]
08:57:16 <lordgrenvilll> well it's the items going on to the front and not the back of the list
08:57:19 <nil> however i'm not too sure about the pedagogical value of this :3
08:57:35 <dminuoso> Is there a library that has generic instances, such that I can generate any possible value for a finite data type?
08:58:02 <dminuoso> Amras: By the way, are you there
08:58:06 <gauga> hehe thanks, nil :)  
08:58:12 <Amras> hi dminuoso 
08:58:32 <dminuoso> Amras: Hey. What I told you yesterday was false.
08:58:39 <dminuoso> Amras: You can use show without a problem. :)
08:58:45 <Amras> how?
08:59:06 <ski> gauga : do you know `filter' function ?
08:59:25 <dminuoso> Amras: case x of AudioSpec { audioFormatSpec = form } -> show form
08:59:40 <dminuoso> Amras: You have to explicitly use pattern matching. :)
08:59:52 <deni> ok so I figured out what the issue with TH was. I'm working around it by not using infix operators like `^.` and just using the normal function names. Another option is to define fixities for various lenes it seems.
08:59:54 <ski> (GADT ? existential ?)
08:59:56 <Amras> yeah, what I was asking is how I could avoid that dminuoso 
09:00:01 <Amras> or wait
09:00:03 <dminuoso> ski: Existential, yeah. :)
09:00:07 <Amras> oh, I see
09:00:35 <Amras> AudioSpec doesn't have an exposed constructor, so I'm pretty sure that won't parse
09:00:39 <dminuoso> Amras: It does.
09:01:11 <dminuoso> Oh gosh! You are right!
09:01:18 <dminuoso> I think I mixed it up with AudioFormat
09:01:28 <ski> deni : i was suspecting something along those lines
09:01:54 <deni> ski: yeah it just wasn't clear to me from the get go because I don't really use TH that often
09:02:01 <ski> (but i dunno how one'd define fixities appropriately, i such a TH context)
09:02:03 <deni> so TIL :D
09:02:12 <dminuoso> Amras: That's a shame then. The field accessor is fairly useless then.
09:02:21 <deni> ski: I found this example as pretty good: https://github.com/ennocramer/floskell/commits/master?after=545907f711c15e299ea63ec4fb1be2c05c8298c8+34
09:02:31 <gauga> the example nil gave works very well! Thanks! 
09:02:37 <deni> I'm not going to do this right now.... but it's a nice learning experience
09:02:40 <ski> gauga : do you understand it ?
09:02:41 <dminuoso> Amras: Is this for debugging only?
09:02:59 <dminuoso> Amras: Because I have just the right trick for you in that case..
09:03:10 <djanatyn> is there a good resource for understanding the difference between Data.Map.Strict from containers, and Data.HashMap.Strict from unordered-containers? i see that Map uses size balance binary trees, and HashMap uses hash array mappted tries ("A HashMap is often faster than other tree-based set types, especially when key comparison is expensive, as in the case of strings.")
09:03:16 <Amras> it's for an academic project, so prettiness in the UI I guess
09:03:24 <gauga> I understand nil's example well; I find list comprehensions to be very clear and concise, but I am very new to Haskell syntax; I have more trouble understanding recursive calls
09:04:01 <dminuoso> Amras: Then nevermind. I was going to suggest a copy of the ADT, unsafeCoerce, some disabled optimizations perhaps, and prayer.
09:04:05 <djanatyn> Aeson uses Data.HashMap.Strict and I was considering converting to a Data.Map.Strict.Map, but I guess that might not be necessary
09:04:17 <lortabac> dminuoso: try generic-random or universe (I have never used them though)
09:04:17 <gauga> if I want to turn around my initialPairs function to find the final pairs in a listOfLists, why doesn't this code work? : finalPairs document = [(a, b) | _:a:b <- document]
09:04:31 <ski> gauga : perhaps you should then try to understand them better, this could be an opportunity to do so
09:04:34 <Amras> dminuoso, yeah, I'm not desperate enough to do that atm :P
09:04:46 <Amras> and I think you suggested something similar yesterday
09:04:54 <ski> gauga : `:' combines a single item (to the left), with a list of items (to the right)
09:05:17 <gauga> aha I see
09:05:18 <dminuoso> Amras: I was hoping to use unsafeCoerce to make the field accessor work.
09:05:27 <dminuoso> Amras: But the attempt wouldn't work as I understand now.
09:05:30 <ski> gauga : `2:3:5:7:[]' means `2:(3:(5:(7:[])))'
09:05:49 <gauga> hi ski, you think I should re-write the function recursively then? 
09:05:58 <Amras> right
09:06:05 <ski> gauga : you have direct access to the first element of a (non-empty) list, but you don't have direct access to the last element
09:06:24 <ski> gauga : you could also try using `filter', perhaps
09:08:10 <gauga> I see! 
09:09:03 <ClaudiusMaximus> is it possible to make ghci respect my (very wide) terminal size and not cram the output of :browse all to the left hand side?
09:12:21 <dminuoso> lortabac: Cheers
09:13:05 <dminuoso> lortabac: universe seems to be what I was looking for
09:15:58 <dmj`> maerwald: when I replaced my quicksort with mergesort from vector-algorithms, it was so fast I thought it was wrong, but it wasn't.
09:18:20 <dmj`> vector-algorithms is pretty wild
09:21:33 <Rembane> dmj`: What did yout quicksort look like?
09:21:56 <Putonlalla> I hope it's not the not-quicksort quicksort again.
09:22:25 <dmj`> Rembane:  https://gist.github.com/dmjio/f2aa3c51b9c52b2543103e22f5547021#file-main-hs-L61
09:22:29 <dmj`> Putonlalla: it's in-place
09:22:30 <argent0> hi, what's nix latest ghc version? Is it 8.6.5?
09:22:37 <Rembane> dmj`: Thank you. 
09:22:55 <Rembane> Putonlalla: Is there an infamous version of quicksort floating around on the internet?
09:22:58 <Putonlalla> Neat. I'd also be surprised, then.
09:23:09 <dmj`> he's just doing some crazy optimizations
09:23:57 <Putonlalla> The one that goes `quickSort (x : xs) = quickSort ys ++ [x] ++ quickSort zs`, Rembane.
09:24:12 <Rembane> Putonlalla: That's a fun one. Looks more like a merge sort to me. 
09:24:18 <Rembane> Putonlalla: With a cooler name.
09:25:10 <Putonlalla> I'd also describe "quadratic or worse" algorithms as "fun".
09:25:38 <Rembane> I see that you are a fellow Dwarf Fotress player.
09:26:17 <nil> !!fun!!
09:28:17 <dmj`> Putonlalla: yea that is the trash version of quicksort, faux-sort
09:32:05 <dsal> sicksort, bro
09:35:38 * hackage hasql-transaction 1.0.0.1 - Composable abstraction over retryable transactions for Hasql  https://hackage.haskell.org/package/hasql-transaction-1.0.0.1 (NikitaVolkov)
09:38:39 * hackage niv 0.2.2 - Easy dependency management for Nix projects  https://hackage.haskell.org/package/niv-0.2.2 (nmattia)
09:40:09 * hackage hasql-transaction 0.10.0.2 - Composable abstraction over retryable transactions for Hasql  https://hackage.haskell.org/package/hasql-transaction-0.10.0.2 (NikitaVolkov)
09:48:30 <koz_> argent0: 8.8.1.
09:48:50 <koz_> Oh wait, missed the 'nix' bit, argh.
09:53:26 <argent0> It is according to: https://hydra.nixos.org/search?query=ghc
10:25:30 <sm> would anyone know how to temporarily stop haskell-mode from starting lsp-mode/flycheck/ghcide, without restarting emacs ?
11:15:30 <EvanR> so cairo has cairo-ft.h for interfacing with freetype but it's not exposed by haskell bindings
11:21:27 <dasli> I'm looking at a heap profile, and "FUN_2_0" is the largest cost center. Anybody know what that means? Other centers have reasonable names like data constructors.
11:21:33 <dmj`> dsal: thanks
11:54:03 <tabaqui1> can I introspect over a class methods in the same way as Generic does?
11:54:08 <tabaqui1> without TemplateHaskell?
11:55:05 <tabaqui1> s/over a//
11:55:46 <jle`> tabaqui1: that'd be neat, but i haven't ever heard of such a feature
11:56:14 <EvanR> i can't think of any way to abuse that :)
12:00:57 <int-e> dasli: As far as I can make it that is a partially applied function with two boxed arguments supplied. Not sure whether one can easily find out which functions it's used for.
12:09:45 <dasli> @int-e thank you
12:09:45 <lambdabot> Unknown command, try @list
12:30:09 * hackage ribbit 0.4.1.0 - Type-level Relational DB combinators.  https://hackage.haskell.org/package/ribbit-0.4.1.0 (taphu)
12:33:57 <EvanR> funny lexical error https://i.imgur.com/jxOhFE8.png
12:34:22 <EvanR> > '\9211'
12:34:25 <lambdabot>  '\9211'
12:34:45 <EvanR> > '⏻'
12:34:46 <lambdabot>  <hint>:1:2: error:
12:34:47 <lambdabot>      lexical error in string/character literal at character '\9211'
12:35:38 <EvanR> > '⏺'
12:35:40 <lambdabot>  '\9210'
12:36:02 <electricityZZZZ> is google using haskell much internally? the last time i looked this up i found a description saying that they had a couple of internal tools and that was about it,... i see that tensorflow has official haskell bindings,...
12:36:39 * hackage pointfree-fancy 1.1.1.15 - Tool for refactoring expressions into pointfree form  https://hackage.haskell.org/package/pointfree-fancy-1.1.1.15 (vmchale)
12:36:41 * hackage bond 0.12.0.1 - Bond schema compiler and code generator  https://hackage.haskell.org/package/bond-0.12.0.1 (chwarr)
12:36:43 * hackage calenderweek 1.0.0 - Commandline tool to get week of the year  https://hackage.haskell.org/package/calenderweek-1.0.0 (rmeis)
12:36:44 * hackage github 0.24, haskell-ci 0.8 (phadej): https://qbin.io/rise-visual-luq6
12:36:47 * hackage free 5.1.3, profunctors 5.5.1, semigroupoids 5.3.4, lift-generics 0.1.3, bifunctors 5.5.6, comonad 5.0.6, deriving-compat 0.5.8, generic-deriving 1.13.1 (ryanglscott)
12:36:49 * hackage graphql 0.6.0.0 - Haskell GraphQL implementation  https://hackage.haskell.org/package/graphql-0.6.0.0 (belka)
12:36:51 * hackage hOpenPGP 2.8.5 - native Haskell implementation of OpenPGP (RFC4880)  https://hackage.haskell.org/package/hOpenPGP-2.8.5 (ClintAdams)
12:36:54 * hackage hw-xml 0.5.0.0 - XML parser based on succinct data structures.  https://hackage.haskell.org/package/hw-xml-0.5.0.0 (haskellworks)
12:36:55 * hackage inline-c-cpp 0.4.0.0, inline-c-cpp 0.3.1.0, inline-c 0.9.0.0 (FrancescoMazzoli)
12:36:58 * hackage egison 3.10.1 - Programming language with non-linear pattern-matching against non-free data  https://hackage.haskell.org/package/egison-3.10.1 (SatoshiEgi)
12:36:59 * hackage clay 0.13.3 - CSS preprocessor as embedded Haskell.  https://hackage.haskell.org/package/clay-0.13.3 (turion)
12:37:02 * hackage regex-tdfa 1.3.1.0 - Pure Haskell Tagged DFA Backend for "Text.Regex" (regex-base)  https://hackage.haskell.org/package/regex-tdfa-1.3.1.0 (HerbertValerioRiedel)
12:37:04 * hackage dependent-monoidal-map 0.1.1.1, monoidal-containers 0.6.0.1 (abrar): https://qbin.io/again-louise-bznh
12:37:06 * hackage unexceptionalio-trans 0.5.0, unexceptionalio 0.5.0 (StephenWeber): https://qbin.io/spain-neil-i28d
12:37:08 * hackage data-diverse 4.7.0.0 - Extensible records and polymorphic variants.  https://hackage.haskell.org/package/data-diverse-4.7.0.0 (louispan)
12:37:11 * hackage tmp-postgres 1.21.1.0, tmp-postgres 1.21.0.0, tmp-postgres 1.20.0.1, tmp-postgres 1.20.0.0, tmp-postgres 1.19.0.1, tmp-postgres 1.19.0.0, tmp-postgres 1.18.0.0, tmp-postgres 1.17.0.0 (JonathanFischoff)
12:37:14 * hackage pandoc-pyplot 2.3.0.0 - A Pandoc filter to include figures generated from Python code blocks  https://hackage.haskell.org/package/pandoc-pyplot-2.3.0.0 (LaurentRDC)
12:37:15 * hackage hasbolt 0.1.3.6, cobot-io 0.1.2.1 (zmactep): https://qbin.io/nodes-marble-shob
12:37:17 * hackage pandoc-stylefrommeta 0.2.3.0, pandoc-vimhl 0.1.3.0, pandoc-stylefrommeta 0.2.2.0 (lyokha)
12:37:19 * hackage ribbit 0.4.1.0 - Type-level Relational DB language.  https://hackage.haskell.org/package/ribbit-0.4.1.0 (taphu)
12:37:21 * hackage hasql-transaction 0.10.0.2, hasql-transaction 1.0.0.1, postgresql-binary 0.12.2 (NikitaVolkov): https://qbin.io/deluxe-stores-ukmj
12:37:24 * hackage math-grads 0.1.6.2 - Library containing graph data structures and graph algorithms  https://hackage.haskell.org/package/math-grads-0.1.6.2 (AlexKane)
12:37:26 * hackage inflections 0.4.0.5 - Inflections library for Haskell  https://hackage.haskell.org/package/inflections-0.4.0.5 (stackbuilders)
12:37:28 * hackage niv 0.2.2 - Easy dependency management for Nix projects  https://hackage.haskell.org/package/niv-0.2.2 (nmattia)
12:37:30 * hackage predicate-typed 0.6.0.0 - Predicates, Refinement types and Dsl  https://hackage.haskell.org/package/predicate-typed-0.6.0.0 (gbwey)
12:37:32 * hackage intro 0.6.0.0 - Safe and minimal prelude  https://hackage.haskell.org/package/intro-0.6.0.0 (minad)
12:37:34 * hackage network-messagepack-rpc-websocket 0.1.1.1, wss-client 0.3.0.0 (igrep): https://qbin.io/those-xx-uw3b
12:37:35 * hackage galois-fft 0.1.0 - FFTs over finite fields  https://hackage.haskell.org/package/galois-fft-0.1.0 (sdiehl)
12:37:38 * hackage dhall-fly 0.2.0 - Translate concourse config from Dhall to YAML  https://hackage.haskell.org/package/dhall-fly-0.2.0 (axeman)
12:37:40 * hackage futhark 0.13.1 - An optimising compiler for a functional, array-oriented language.  https://hackage.haskell.org/package/futhark-0.13.1 (TroelsHenriksen)
12:37:42 * hackage morpheus-graphql 0.7.1 - Morpheus GraphQL  https://hackage.haskell.org/package/morpheus-graphql-0.7.1 (nalchevanidze)
12:37:45 * hackage finitary-derive 2.2.0.0 - Flexible and easy deriving of type classes for finitarytypes.  https://hackage.haskell.org/package/finitary-derive-2.2.0.0 (koz_ross)
12:37:46 * hackage network-byte-order 0.1.2.0, iproute 1.7.8 (KazuYamamoto): https://qbin.io/more-post-b66u
12:37:48 * hackage pandoc 2.8.0.1, skylighting 0.8.3, skylighting-core 0.8.3, yst 0.7.1 (JohnMacFarlane)
12:37:50 * hackage hreq-client 0.1.1.0, hreq-core 0.1.1.0 (epicallan): https://qbin.io/uses-shorts-3hk2
12:37:51 * hackage HTF 0.14.0.1, HTF 0.14.0.0 (StefanWehr): https://qbin.io/meyer-gaps-llac
12:37:53 * hackage HGL 3.2.3.2 - A simple graphics library based on X11 or Win32  https://hackage.haskell.org/package/HGL-3.2.3.2 (AlanHawkins)
12:39:43 <electricityZZZZ> https://github.com/adjoint-io/galois-fft a financial company needs FFTs over galois fields? what?
12:44:22 <dmj`> vector algorithms is blazin' no scope 420 
12:47:33 <EvanR> nice
12:48:54 <electricityZZZZ> dmj`: talking to me?
12:49:31 <dmj`> just talking in general
12:52:00 <electricityZZZZ> ok well my haskell arrayfire project is sitting here, gathering dust
12:53:10 <dmj`> electricityZZZZ: time to dust off those modules
12:53:15 <dmj`> light the fire again boy
12:54:03 <electricityZZZZ> haha,... i don't see a commit which touches AF.replace ?
12:54:48 <dmj`> electricityZZZZ: I talked with the devs on that, it needs to be in IO because it actually mutates the array in place
12:54:53 <maralorn> Does some now for shake a version "Action a -> Rule (Action a)", there is "newCache :: (k -> Action a) -> Rule (k -> Action a)"
12:54:53 <dmj`> electricityZZZZ: I can add that probably tonight
12:55:38 <electricityZZZZ> talked with the arrayfire devs?
12:56:00 <electricityZZZZ> i mean no rush just saying i haven't given up yet. it will be my first nontrivial haskell program ;)
12:56:21 <dmj`> electricityZZZZ: that's good, it's a good library, its the fastest array library for haskell, and maybe most featureful
12:56:31 <electricityZZZZ> mutation is part of real programs,...
12:56:41 <dmj`> haskell FFI is good
12:56:51 <electricityZZZZ> yeah i like arrayfire
12:57:02 <electricityZZZZ> they have an official rust package
12:57:25 <dmj`> basic haskell is always best, don't listen to the typestronauts, they're out to lunch
12:57:47 <electricityZZZZ> typestronauts? haha. i am still getting a feeling for this stuff
12:58:33 <electricityZZZZ> i've tried starting to learn category theory a couple of times and i keep hearing these trivial graph-theorems about how dots and arrows interact and my eyes glaze over and i fall asleep
12:58:39 <dmj`> these are people who think haskell proficiency is all about esoteric parts of the lens library, and using experiment ghc extensions and will judge people according to their knowledge of these things. these kinds of people can't even understand the runtime properties of their own code
12:58:45 <dmj`> experimental*
12:58:57 <electricityZZZZ> that's not a graph edge, that's a functor!
12:59:38 <electricityZZZZ> i could see that it would be useful to dive into a complicated type and pull out another type,... nothing wrong with that
12:59:39 <dmj`> yes, like that
13:00:01 <dmj`> types for types sake isn't good, and lots of types make things heavy
13:00:03 <electricityZZZZ> i am still just starting to learn to write code
13:00:12 <electricityZZZZ> so you're saying that you are type-woke
13:00:16 <dmj`> electricityZZZZ: that's good, you've come to the right place
13:00:28 <electricityZZZZ> i was thinking about learning to write cogent lang
13:01:10 <dmj`> electricityZZZZ: yes, I've ascended a few mountains, talked with the shamans. It's all about knowing when not to use something. Ask yourself "why am I using this". 
13:01:13 <Cale> Yeah, there are places where all the fancy type system features can buy you leverage, but you should never go there first before investigating what you can do with plainer forms of Haskell.
13:01:38 <dmj`> electricityZZZZ: heed the wise words of Cale my son.
13:02:25 <Spock> sometimes the plainest haskell is the most satisfying anyway
13:02:48 <Spock> even if you do all your work in IO, you can still pass IO actions around instead of functions of "zero arguments"
13:14:17 <dmj`> its true
13:14:18 <dmj`> IO is pure
13:17:08 <electricityZZZZ> can i get examples of a few things which are relatively easy to implement in haskell which would be difficult or impossible in rust?
13:17:41 <EvanR> hilarious dichomtomy between "plainer haskell" and "planar haskell"
13:17:57 <hpc> that's a tough one to answer without getting into more advanced features
13:18:24 <tabaqui1> I have two instances which are strictly marked as OVERLAPPING and OVERLAPPABLE but compilation still fails
13:18:24 <EvanR> as in astral planes
13:18:38 <hpc> rust is pretty much a big IO do-block with squiggly braces, in many ways
13:18:49 <tabaqui1> I dunno, probably I didn't quite get the english text
13:19:00 <tabaqui1> anyway, what should I do?
13:19:02 <MarcelineVQ> if you replace 'still fails' with 'gives me this <link to code and error>' people will rush to examine it :>
13:19:17 <electricityZZZZ> well you don't have to explain *why* something is hard in rust (or if you like, modern C++)
13:19:29 <tabaqui1> (instance OVERLAPPABLE Foo a a; instance OVERLAPPING Foo (a -> f) b)
13:19:51 <tabaqui1> it seems obvious to me that the second one is always more specific
13:20:00 <EvanR> electricityZZZZ: well, implement a bare bones programming language
13:20:12 <hpc> doing things with laziness, perhaps
13:20:38 <electricityZZZZ> so, stream computations?
13:21:35 <hpc> yeah, but without having to directly resort to streaming primitives
13:21:44 <hpc> so like if you're writing a solver for chess or something
13:22:07 <hpc> you can express the entire decision tree and just not look at most of it
13:25:56 <kamatsu> @free map
13:25:57 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
13:34:52 <dmj`> electricityZZZZ: also, don't be afraid of using FFI in Haskell, this too is a great tragedy
13:38:04 <dmj`> electricityZZZZ: many people like to stay cozy in their type bubble, afraid of the outside world
13:40:56 <electricityZZZZ> dmj`: haha says you ;)
13:41:21 <dmj`> :)
13:41:40 <koz_> dmj`: Did you manage to figure out an n log(n), 1-pass, in-place dedup?
13:42:15 <tabaqui1> allright, my previous centence is false
13:42:36 <koz_> tabaqui1: Nice paradox evasion there. :P
13:43:12 <dmj`> koz_: unfortunately, no. Ended up using mergesort from vector and then a dedupe on top of that, the dedupe is negligible in both space and time
13:43:24 <tabaqui1> my next sentence is false
13:43:32 <tabaqui1> my previous sentence is right :)
13:43:35 <dmj`> koz_: if you have any ideas, I'm all ears :)
13:43:58 <koz_> dmj`: I've been thinking about it (my Master's was in dynamic partial sorting, so I'm not ignorant of the problem space), but so far no dice.
13:43:58 <tabaqui1> I still can't understand why overlapping doesn't work in my case
13:44:36 <EvanR> dmj`: type Blanket = Hide Self
13:44:41 <EvanR> dangit
13:46:45 <koz_> Also, can I have library stanzas in a cabal file with an executable? I've tried that, but GHC constantly complains when I build the executable that I'm not declaring files that belong to the library as deps.
13:47:58 <dmj`> koz_: that's pretty wild
13:48:07 <koz_> dmj`: What is?
13:48:12 <koz_> My question or my degree?
13:49:00 <koz_> dmwit: Sorry to bother, but what was the library you suggested to me for checking if file names match a pattern?
13:49:09 <koz_> (I forgot to note it down)
13:49:39 <dmj`> dynamic partial sorting, very cool
13:51:02 <koz_> dmj`: It was interesting, even if the solution I came up with as 'optimal' only becomes viable for inputs that won't fit into this universe.
13:51:07 <koz_> (no seriously)
13:51:36 <koz_> (as my practical testing showed, constants murder you anyway)
14:19:47 <refusenick> If GHC 8.8.1 has been out since August, why do all the tools default to 8.6.5?
14:20:19 <monochrom> Many libraries have not caught up.
14:21:44 <refusenick> monochrom: It's not backwards-compatible?
14:22:16 <monochrom> Who is "it"?
14:22:23 <refusenick> GHC 8.8.1
14:22:24 <EvanR> MonadFail is a breaking change
14:22:35 <EvanR> GHC, move slow, break things
14:22:37 <koz_> Plus there's a lot of very conservative upper bounds.
14:22:45 <koz_> (I'm dealing with one of those right now)
14:23:11 <monochrom> Version number of base is usually not backward-compatible.  Note emphasis on version number, not content.
14:23:46 <Clint> pretty much none of my stuff works on GHC 8.8 yet due to broken dependencies
14:24:00 <monochrom> Reason being what koz_ just said, many libraries say "base <= <the version number of base at the time of writing>"
14:24:28 <koz_> And updates can be slow in coming.
14:24:47 <monochrom> Most likely there will be no problem using a newer base, but someone has to update their *.cabal file.
14:24:51 <koz_> Especially if those people have full-time jobs or are responsible for a metric tonne of libraries.
14:24:58 <koz_> (those two are not mutually exclusive)
14:25:20 <EvanR> so which base are we on?
14:25:43 <EvanR> other than "all your"
14:28:01 <koz_> 4.12 in my current case.
14:35:14 <glguy> Current is 4.13
14:46:26 <refusenick> https://0x0.st/zIE7.txt
14:47:18 <refusenick> Cabal keeps telling me that ghc and process are in conflict, but it won't let me update either one.
14:47:28 <refusenick> Time to nuke .cabal again?
14:48:15 <dcoutts> you cannot upgrade base
14:48:22 <dcoutts> what are you actually trying to do?
14:49:16 <refusenick> dcoutts: All the packages I try to install fail with the ghc-process conflict error
14:49:21 <refusenick> IDK what went wrong
14:49:25 <Pamelloe1> Should I be concerend about enabling UndecideableInstances?
14:49:55 <Clint> dcoutts: are you okay with bzlib having a lower bound on base 4.9?
14:51:01 <refusenick> Is a standalone package manager for Haskell a la Pip in the works or on the roadmap?
14:51:15 <koz_> Pamelloe1: It depends. What exactly are you doing?
14:51:24 <koz_> UndecidableInstances is a scary-sounding name, but in many cases it's fine.
14:51:31 <refusenick> Nix seems rather bulky if I'm going to use it for Haskell packages alone.
14:55:21 <Pamelloes> koz_: I'm trying to automatically derive an instance of MonadTransControl for a newtype around StateT
14:55:51 <koz_> Pamelloes: That should be fine.
14:56:03 <Pamelloes> Great :)
14:59:43 <pertl> as a haskell n00b, is it considered bad style to use "DuplicateRecordFields" or not?
14:59:57 <pertl> with ghc 8
15:00:01 <pertl> +
15:00:21 <pertl> or is there something better?
15:09:02 <jle`> pertl: better for what?
15:09:34 <pertl> is there a better option than using "DisambiguateRecordFields" to solve the problem of having multiple records with the same accessor name
15:09:36 <pertl> ?
15:09:46 <sm[m]> refusenick: cabal or stack are essentially pip
15:13:21 <EvanR> pertl: field name and accessor name, it's unfortunate that they are confused in haskell. NoFieldSelector solves a lot of issues :)
15:14:30 <pertl> seems like this is currently in the state of "proposal accepted, not yet implemented in ghc" - right?
15:14:38 <EvanR> yeah...
15:14:54 <pertl> ok so for now I will need to prefix the field names with the type as a hack
15:14:59 <EvanR> for example many records may naturally have an `id' field but a function with name id is colliding with id :: a -> a
15:15:12 <pertl> "id" => "customer_id" to fix it?
15:15:44 <pertl> in the case of "data Customer { id :: Int, name :: String, ... } "
15:15:47 <EvanR> pertl: well, i didn't get to a real point. What issue with records are you dealing with? The accessor function names colliding?
15:15:53 <pertl> yep
15:16:04 <pertl> customer has a name. user has one, too
15:16:10 <pertl> for exampl
15:16:11 <pertl> e
15:16:20 <EvanR> if you don't want them, you can put the definition in its own module and don't export the fields
15:16:44 <pertl> ok - so I think I know my options now ... thanks EvanR  :-)
15:16:55 <EvanR> ok, great!
15:16:59 <pertl> =1
15:17:00 <pertl> +1
15:17:34 <EvanR> prefixes solve the issue of accessors colliding, but then the field names are "wrong"
15:26:29 <Pamelloes> I'm trying to lift this function (http://hackage.haskell.org/package/gloss-1.13.1.1/docs/Graphics-Gloss-Interface-IO-Simulate.html#v:simulateIO) with MonadBaseControl, but it's not going very well.
15:27:27 <Pamelloes> I suspect the (model -> IO Picture) parameter means that it can't be done.
15:27:42 <Pamelloes> Am I missing something obvious, or is this really the case?
15:27:55 <vaibhavsagar> refusenick: never try to `cabal install base`
15:28:34 <vaibhavsagar> that's very wrong, there's no reason to do it, and it'll never have the outcome you want
15:28:55 <vaibhavsagar> `base` is tied to a particular GHC version
15:29:44 <ph88> how can i make a ByteString with utf inside of it ?
15:30:07 <koz_> ph88: ByteString is not encoding-sensitive.
15:30:10 <koz_> It's just a blob of bytes.
15:30:29 <ph88> yes, but i would like to put bytes in there that represent encoding
15:30:52 <davve_> sorry for posing a non-haskell specific question, but I am trying to figure out how I can think of programs in terms of side effects state and pure functions... can anyone recommend some good reads for it? (be it haskell or something else)
15:31:13 <koz_> ph88: ... then just put those bytes there? 
15:31:13 <koz_> I'm not entirely sure what you're after there.
15:31:15 <davve_> asking here cause i couldn't find a functional programming channel and haskell seems neat
15:31:54 <rotaerk> davve_, your question is really vague.  but how about just learn haskell
15:32:03 <rotaerk> that might be a good way to get what you want to know
15:32:13 <ph88> koz_, when i do  bs :: ByteString;  bs = "ab"   it's 2 times 8 bytes right ? But if i have utf-16 encoding it would be 4 bytes right ? I don't know how to write that down in sourcecode
15:32:31 <davve_> rotaerk: I am thinking that might be the way to go
15:32:43 <davve_> monads seem complicated though
15:32:56 <davve_> but i understand that is to deal with side effects?
15:33:01 <rotaerk> not really
15:33:19 <laudecay> hey so is there a good example of complicated c compilations in cabal
15:33:20 <rotaerk> if you approach learning them the wrong way, they can be frustrating to learn
15:33:21 <koz_> ph88: If you need to work with UTF-16, then you want Text, not ByteString.
15:33:44 <koz_> ByteString is 'arbitrary blob of bytes', which is clearly not what you have there.
15:33:54 <davve_> i used xmonad for the longest time. it was my second favorite window manager
15:34:01 <ph88> davve_, i think you shouldn't dive too much into it actually and just try to make a program .. your head starts spinning before you get something done already
15:34:01 <davve_> tiling wm*
15:34:20 <rotaerk> davve_, monads aren't for side-effects, they're for ... sequencing, roughly
15:34:28 <ph88> laudecay, i'm making a haskell library that FFI into C code .. what do you need ?
15:34:57 <davve_> ph88: that's a bit how i fee
15:35:00 <davve_> l*
15:35:06 <laudecay> ph88: what should my end goal be from getting the c stuff to compile
15:35:16 <laudecay> like, a makefile that produces an SO? or
15:35:18 <ph88> koz_, ByteString has the advantage that it's pinned. But anyway .. i know about Text. But i still want utf-16 stuff into ByteString, it should be possible no ?
15:35:34 <laudecay> ph88: like what'll be easiest to make work with cabal for calling with the ffi
15:35:44 <davve_> but I like to do some research, not touching monads, just the concept of how i can make them explicit
15:35:47 <davve_> to write programs
15:35:53 <davve_> side effects that is
15:35:53 <laudecay> also linking the tests from the library in, i need to figure that one out
15:36:03 <koz_> ph88: Sure, you can, but at that point, you have to deal with all the vagarities of encoding yourself.
15:36:24 <rotaerk> davve_, IMO, the best way to learn abstractions like Monad, Functor, etc, is to study concrete instances of them.  don't bother learning the definition of Monad until you understand what return and (>>=) do for IO, State, Maybe, [], etc
15:36:25 <ph88> laudecay, if you have just a bunch of source files you can specify them to be compiled along with your haskell program. If you have your C source code with it's own build system it gets more complicated
15:36:31 <koz_> Basically, a ByteString is like char* - it's a blob of bytes with whatever-the-hell semantics you want or don't.
15:37:01 <ph88> koz_, yes i understand. My question was how can i write the character literals with utf-16 encoding in my haskell source code and then put them in ByteString type
15:37:21 <koz_> ph88: The answer is 'even if you could do that, this is a terrible idea and don't do it'.
15:37:40 <ph88> koz_, please i need this to test my code
15:37:41 <koz_> A ByteString is full of _bytes_. How these map to symbols in the human sense is dependent on the encoding.
15:37:51 <rotaerk> a StarString is ... full of stars!
15:38:12 <ph88> koz_, i know the encoding i want, it's not a variable
15:38:46 <davve_> rotaerk: thanks for the suggestion
15:39:24 <ph88> laudecay, you can also compile your C code into a library first and keep the compilation process separate from compiling your haskell code. And then specify in your cabal file that you want to use this library
15:39:57 <ph88> laudecay, https://www.haskell.org/cabal/users-guide/developing-packages.html?highlight=source#pkg-field-c-sources this is one option
15:40:16 <ph88> laudecay, other options https://www.haskell.org/cabal/users-guide/developing-packages.html?highlight=source#pkg-field-extra-libraries 
15:40:21 <davve_> thing is, i'm learning a different language and there my three primitives are basically pure functions that can use state and side-effects that are made explicit with hooks, im only recently familliar with the concept of side effects, and using them to your advantage seems nice, but I understand it should be limited
15:40:39 <davve_> in my mind I don't see why state isn't enough
15:41:03 <ph88> laudecay, third option https://www.haskell.org/cabal/users-guide/developing-packages.html?highlight=source#more-complex-packages 
15:42:03 <ph88> davve_, state is one monad. But there are a bunch of different monads. IO is the main one and it's more than just state
15:42:12 <davve_> oh right, side effects are important because you need io and stuff..
15:42:37 <davve_> ok
15:43:20 <davve_> and monads are a mathematical construct, if i remember correctly? how true is that for haskell?
15:43:27 <davve_> in haskell*
15:43:51 <ph88> davve_, should you care to ask that question ?
15:44:16 <davve_> haha.. i don't know, i'm sorry
15:45:16 <davve_> it's not relevant im just curious
15:46:06 <davve_> but yeah... maybe this was the wrong place to ask :)
15:46:24 <davve_> if anyone knows of a general functional programming channel, let me know!
15:46:25 <ph88> i'm not going to pretent to know the answer to that. But i just decided to skip over such questions mostly :P
15:46:32 <monochrom> Actually name one non-mathematical construct from any programming language of your choice.
15:46:44 <davve_> classes
15:47:04 <monochrom> What you'll realize is that standard things like numbers, booleans, strings are not going to be one of them.
15:47:50 <ph88> davve_, as i understood it (again there are probably people more qualified to answer this) .. there was a theory of computation lambda expressions and so on defined in math by which you can define all other concepts of computer programming stuff
15:47:52 <monochrom> Also there are a bunch of things that didn't start out as mathematical constructs but someone managed to mathematicalize them after the fact. OOP is one of them.
15:48:34 <monochrom> I know that someone even category-theorized most of UML.
15:49:14 <davve_> cool
15:49:31 <monochrom> At any rate even if you disregard after-the-fact mathizing ("aftermath"? :) ) the very basic things you take for granted like numbers are math constructs whether you like it or not.
15:49:46 <davve_> i like math
15:49:47 <mycroftiv> you can view everything computers do as mathematical via both the curry-howard correspondence of proofs and programs, and also for the reason that as physical devices, computers are boolean switching algebras made of logic gates
15:50:04 <monochrom> I mean OOP is optional but numbers and/or strings and/or bits are not.
15:50:29 <monochrom> So you'll find that the mandatory things are math constructs. Any programming language.
15:51:41 <monochrom> Perhaps I'm over-reacting to "is ____ which shows up in haskell a math construct?" kind of questions.
15:52:13 <davve_> your input is appreciated
15:52:26 <davve_> maybe it was a stupid question :)
15:53:17 <davve_> I don't even know
15:53:39 <davve_> maybe i just need to gripe with it long enough and it'll come to me
15:53:50 <davve_> gripe is not the word but.. grapple
15:54:51 <davve_> i know if i actually learned haskell, this other language would probably not be as difficult
15:55:23 <davve_> i've only written a program that parsed my emails... and configured xmonad a bit
15:55:39 <monochrom> Monad can be easy or hard.  Easier if you lean more towards "how to".  Harder if you lean more towards "what is".
15:56:52 <monochrom> Recall that the way you learned numbers when you were a kid was all about how-to, not what-is.  No kid ever asked "what are numbers?".  You got used to working with numbers, not philosophizing or analogizing over it.
15:57:40 <davve_> makes sense
15:59:53 <hpc> that applies to type classes in general
16:00:11 <hpc> the "what" of any type class is its kind and whatever functions it defines
16:00:24 <hpc> so you're already being pushed in a "how" direction
16:01:32 <dsal> monochrom: I don't know what math books you guys had in school, but we learned it the right way... https://usercontent.irccloud-cdn.com/file/DTSs9D6I/principia
16:02:07 <monochrom> haha
16:02:14 <davve_> it proves 1+1=2?
16:02:23 <davve_> i only understand that last sentence :)
16:02:26 <dsal> Once you get to page 362
16:02:57 <monochrom> https://wiki.haskell.org/Monad_laws may help you see a purpose/motivation of the monad laws.
16:03:39 <davve_> thank you
16:03:41 <monochrom> TLDR "what you expect of sequential execution"
16:04:52 <koz_> Is there a Haskell implementation of Knuth-Morris-Pratt, or do I need to roll my own?
16:05:02 <koz_> (I'm eating Text with it, in case that matters)
16:05:04 <monochrom> I think there is one on hackage
16:05:28 <monochrom> Just ask hackage to search "kmp" :)
16:05:28 <koz_> KMP?
16:05:53 <monochrom> acronym for K____-M_____-P____
16:06:03 <koz_> monochrom: That one sadly works over lists.
16:06:16 <Axman6> I'm sure I've seenKMP in Haskell before
16:06:31 <monochrom> hrm
16:06:59 <koz_> The main reason I need something like Knuth-Morris-Pratt is that I need _all_ matches.
16:09:21 <monochrom> OK yeah I think I can't find KMP for text on hackage.
16:09:32 <koz_> monochrom: It's fine, I'll write one as a contribution. :P
16:10:03 <monochrom> Would it be too inefficent to unpack then feed to list-based KMP?
16:10:44 <koz_> I guess it's not an _awful_ first stop.
16:10:53 <koz_> If it turns out too awful, I guess I could change it.
16:13:18 <koz_> It might be pretty awful though, since it reports match _indexes_ not slices.
16:13:34 <koz_> Although it might be OK actually.
16:13:38 <koz_> Hmm.
16:14:18 <monochrom> Oh!
16:14:34 <Clint> ph88: https://hackage.haskell.org/package/text-1.2.4.0/docs/Data-Text-Encoding.html#g:5
16:15:17 <ph88> thx Clint  :)
16:29:38 * hackage vector-algorithms 0.8.0.2 - Efficient algorithms for vector arrays  https://hackage.haskell.org/package/vector-algorithms-0.8.0.2 (ErikDeCastroLopo)
16:47:13 <koz_> Phyx-: How does the Chocolatey package for GHC deal with MSYS2 stuff? I wanna give haskell-gi a go, but I'm not sure how MSYS2 is set up for me.
16:47:19 <iqubic> I think that Haskell is a much much more elegant language than Java.
16:48:19 <iqubic> I just wrote a small parser in Java and it ended up being 209 lines long.
16:48:59 <iqubic> The equivalent in haskell, with mega-parsec would most likely be like 30 lines or less.
16:49:48 <evelyn> On the other hand code quality isn't abbout code length
16:55:45 <iqubic> No.
16:56:19 <iqubic> In fact, my code has wound up looking a whole lot like it should be written in a functional language.
16:59:34 <crestfallen> hi well a slight misunderstanding: on line 4 lhs (Just f) is used in the pattern match, but on the rhs f has potential for failure. so with pattern matching generally, there's no other way to express that, even though f may fail in the expression. https://paste.ee/p/YsppF   sorry not sure how to frame my question..
17:00:37 <crestfallen> because (Just f), that part of the applicative anyway, itself wouldn't fail
17:00:59 <crestfallen> ..wouldn't cause failure
17:01:52 <Axman6> why do you say that f has the potential to fail?
17:02:07 <Axman6> it has type (a -> b)
17:02:14 <Axman6> :t (<*>)
17:02:16 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
17:02:23 <Axman6> :t (<*>) @Maybe
17:02:25 <lambdabot> error:
17:02:25 <lambdabot>     Pattern syntax in expression context: (<*>)@Maybe
17:02:25 <lambdabot>     Did you mean to enable TypeApplications?
17:02:29 <Axman6> % :t (<*>) @Maybe
17:02:30 <yahb> Axman6: Maybe (a -> b) -> Maybe a -> Maybe b
17:02:43 <crestfallen> it's the book saying thus:
17:04:03 <crestfallen> "That is, the function pure tranforms a value into a successful result, while the operator <*> applies a function that may fail to an argument that may fail to produce a result that may fail
17:04:43 <crestfallen> "    that's what is says following the Maybe instance of Applicative
17:04:47 <monochrom> That's poor wording in the book.
17:04:55 <iqubic> Correct. The failure is getting Nothing.
17:04:55 <Axman6> the production of the operation may fail, hence Maybe (a -> b), but in the case where you actually did get Just f, then f :: a -> b
17:05:07 <iqubic> Success is Just f.
17:05:25 <iqubic> The Maybe Applicative doesn't care what the function does.
17:05:45 <monochrom> But this is one of those cases where intuitive simple wording is poor or wrong wording.
17:06:11 <iqubic> It is?
17:06:15 <iqubic> How so?
17:06:52 <crestfallen> iqubic, wait, what is correct?
17:07:24 <iqubic> % :t (<*>) @Maybe
17:07:24 <yahb> iqubic: Maybe (a -> b) -> Maybe a -> Maybe b
17:07:24 <crestfallen> so this is something I don't get about pattern matching...
17:07:34 <iqubic> What don't you get?
17:07:36 <monochrom> For "Maybe b", It is so much easier to say "argument that may fail" than "either failure or has argument".
17:08:01 <iqubic> Yeah. I agree.
17:08:15 <iqubic> But only the second one is the truth here.
17:08:35 <monochrom> Or maybe s/easier/less clumsy/ is more accurate. Hey, I also need to hone my wording too! :)
17:09:05 <monochrom> Yeah unfortunately English is crap (all natural languages are crap) so correct wordings are mostly clumsy.
17:09:13 <crestfallen> if f fails, on the lhs we have (Just f), which would set success in stone. or is that still just a Maybe with the possibility of failure
17:09:15 <crestfallen> ?
17:09:18 <MarcelineVQ> iqubic: "<*> applies a function that may fail" is wrong, it's producing the function in the first place that can fail, the function has no notion of failure. ">>= applies a function that may fail" would have a better argument
17:09:19 <monochrom> More reason to just say "Maybe b" formally.
17:09:40 <MarcelineVQ> But still not one I'd make
17:10:33 <iqubic> crestfallen: if you pattern match and get the "(Just f)" case, then you have success set in stone for the first argument to <*>.
17:10:53 <crestfallen> sorry I'm trying hard to follow your arguments
17:11:04 <iqubic> It doesn't matter what 'f' does there. You have succeeded in that pattern match if you get the (Just f)
17:11:42 <Axman6> crestfallen: do you understand that if f :: a -> b, then Just f :: Maybe (a -> b), and if you mattern match on something of type Maybe (a -> b) with the pattern Just f then you get back f :: a -> b?
17:12:22 <crestfallen> Ok yes I do, so...
17:12:59 <monochrom> THE END
17:13:13 <crestfallen> the (Just f) on the lhs is the only way to express possible failure. I mean,, you can't say (Maybe f) <*> mx = ...
17:13:15 <Axman6> so in (Just f) <*> ma = fmap f ma, f has type a -> b, ma has type Maybe a and the result has type Maybe b
17:13:32 <MarcelineVQ> Just f is not failure. Nothing is failure.
17:13:47 <Axman6> crestfallen: Maybe is a type constructor, not a data constructor, writing that doesn't make any sense
17:14:28 <Axman6> Nothing <*> ma = Nothing is the failure case - no function of type a -> b was passed so you cannot continue any further
17:15:22 <Axman6> Just f is the pattern for "I was successfully given a function of tyoe a -> b". Nothing says "I didn't get a function"
17:15:36 <crestfallen> no Axman6 I get precisely what you wrote.. the logical explanation above. oh yes! the failure case is listed first and would catch any failure scenario
17:15:43 <Phyx-> koz_: if you've installed msys2 as well via chocolatey you should find everything you need in c:\msys2. If you just want to install a package the cabal package would have created a new command for you to make this easier 
17:16:03 <Phyx-> koz_: see https://chocolatey.org/packages/haskell-dev for that command. It's in the description 
17:16:34 <Axman6> yes
17:17:29 <MarcelineVQ> would catch any failure scenario for the first argument of <*>
17:18:52 <crestfallen> yes thanks Axman6 monochrom MarcelineVQ .. so simple but I do overlook the first cases and get lost in the  last / recursive case sometimes.
17:19:11 <crestfallen> last or recursive case
17:19:51 <crestfallen> and thanks iqubic 
17:20:45 <crestfallen> I mean, you do call those cases, without pipes or case statements right?
17:21:13 <crestfallen> guards*
17:23:29 <MarcelineVQ> I do, correct or not :> They're declarations that each handle a specific case of your inputs.
17:24:41 <crestfallen> copy that thanks
17:30:38 <maralorn> In what hell do I belong if I write code that assumes years can be sorted lexically? That will break in about 8000 years …
17:32:37 <monochrom> Or perhaps it will be star-trek-like paradise by then :)
17:33:21 <EvanR> correct, time ends in 9999
17:34:59 <MarcelineVQ> make your own notion of time, Blears, which are lexically sortable years
17:36:34 <maralorn> I have today written some shake-rules for the first time. It‘s really awesome!
17:36:36 <MarcelineVQ> And provide a conversion that outside methods to be used for the conversion, if people disagree with your notion of how years becomes blears they can provide their own
17:38:17 <EvanR> yeah, you can compatify time so it asymptotically approaches year 10000
17:52:07 <Axman6> > sort ["10000","8000-"]
17:52:10 <lambdabot>  ["10000","8000-"]
17:52:14 <Axman6> D:
17:52:25 <Axman6> ISO8601 has failed me!
18:00:47 <divVerent> 20:30:15        maralorn | In what hell do I belong if I write code that assumes years can be sorted lexically? That will break in about 8000 years …
18:00:54 <divVerent> You're already in the right place.
18:01:17 <divVerent> Like, who doesn't name their files on version control "foo2019-11-27.hs"
18:01:17 <monochrom> haskell hell? :)
18:01:24 <divVerent> which makes it easy to diff to previous versions or even roll back
18:01:26 <divVerent> ;)
18:01:42 <divVerent> oh wait, that convention is unusal for hs, people do use that for .docx a lot
18:01:51 <monochrom> Oh, right, I name my course directories like 2019-5/CSCC24
18:01:56 <divVerent> solution: make ghc parse Haskell source from docx files
18:02:02 <divVerent> when is next April Fools?
18:09:43 <dmwit> koz_: filepattern?
18:10:50 <epta> could someone please remind me of the solution of the einstein-zebra puzzle on type level?
18:31:50 <koz_> dmwit: That one.
18:40:23 <koz_> monochrom: HaskHell. :P
18:40:33 <dsal> Does anyone here know how to use hsexpr?  I'm trying to do the most simple possible code generation thing, and I only seem to be successful with complicated things.  :)
18:45:24 <fresheyeball> Happy Thanksgiving!
18:51:55 <Axman6> dsal: then do complicated things :P
19:03:19 <dsal> Heh.  The complicated things are mostly done.  I'm just trying to define one value at the top.
19:08:33 <siraben> Anyone know of a good use for the reverse state monad?
19:09:00 <siraben> Also, I want to use the writer monad with a list of elements as a log, but (++) is linear in the first argument, which package is a good replacement?
19:09:35 <EvanR> you can use Writer but instead of ++ on lists, use . on Endo builder
19:10:16 <EvanR> ++ is actually worse than linear if you repeatly append short strings
19:10:21 <Axman6> a.k.a DList
19:10:35 <ChaiTRex> siraben: used a combo state and reverse state monad for a game AI written procedurally once
19:11:14 <EvanR> type DList a = Endo [a] ?
19:12:56 <ChaiTRex> siraben: you pass the moves forward in time and the endless game state backwards in time, so I needed both.
19:13:24 <Axman6> EvanR: yeah
19:22:06 <EvanR> > last (foldl (++) "" (replicate 1000000 "a"))
19:22:12 <lambdabot>  mueval-core: Time limit exceeded
19:22:32 <EvanR> > last (foldl (.) id (replicate 1000000 ("a" ++)) "")
19:22:35 <lambdabot>  'a'
19:22:39 <EvanR> \o/
19:41:19 <leo__> Some more "involved" benchmarks with criterion are DOSing my box.
19:41:24 <leo__> Any tips on how to deal with that?
19:41:48 <leo__> ulimit the shell or something?
20:01:08 <Phyx-> . 
20:12:53 <uniquerockrz> bshah
20:28:38 * hackage tmp-postgres 1.21.1.1 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.21.1.1 (JonathanFischoff)
21:43:13 <shafox> I am on archlinux, I just installed xmonad, it installed ghc and ghc is in my path. however my emacs is setup with stack/cabal. How do I work withsystem packages ? 
21:44:52 <Axman6> I thought arch completely broke their support of haskell packages - did that get fixed?
21:45:11 <dibblego> apparently so, according to my son who uses archlinux and haskell
21:45:36 <koz_> Axman6: Depends on what you mean by 'fixed'.
21:45:39 <shafox> Axman6, I have read about it however not so much knowledge about how it got broke. 
21:45:46 <koz_> shafox: Dynalinking everything is how.
21:45:58 <koz_> Basically, use Stack, or cabal new-*, for all things Haskell.
21:46:03 <koz_> (would be my advice)
21:46:22 <dibblego> somethings used to not even work with cabal new-* iirc
21:46:47 <shafox> koz_, I am trying out xmonad, I am pretty sure it needs to have ghc install as part of the package dependency. 
21:47:11 <koz_> shafox: Can't speak for xmonad, honestly.
21:47:15 <koz_> (never used it)
21:47:28 <dibblego> install ghc for xmonad, then use ghcup for haskell dev
21:47:37 <shafox> koz_, trying out to learn xmonad system. 
21:48:16 <shafox> dibblego, thats what I did however to work with xmonad i need to communicate with system ghc and its packages. 
21:48:30 <dibblego> which packages do you need for xmonad?
21:49:02 <shafox> dibblego, https://www.archlinux.org/packages/community/x86_64/xmonad/ 
21:49:11 <dibblego> yeah, so pacman -S xmonad
21:50:55 <shafox> Did that. Now I am creating xmonad.hs and to write my own config: for this I am using emacs., I have set up emacs to use stack. Now this particular dir, ~/.xmonad/xmonad.hs would be using system ghc. I was wandering how can I use the system ghc while working for this particular lib ? Or any ghc I can use and run xmonad via that ? 
21:51:14 <shafox> in emacs*
21:51:26 <dibblego> can't help you with emacs, but somehow point it to /usr/bin/ghc
21:52:07 <shafox> got it.
21:52:07 <koz_> Stack has an option (--with-system-ghc I think) to use a system GHC instead of its own.
21:52:08 * hackage feed 1.3.0.0 - Interfacing with RSS (v 0.9x, 2.x, 1.0) + Atom feeds.  https://hackage.haskell.org/package/feed-1.3.0.0 (jkeuhlen)
