01:28:42 * hackage postgres-options 0.2.0.0 - An Options type representing options for postgres connections  https://hackage.haskell.org/package/postgres-options-0.2.0.0 (JonathanFischoff)
01:36:25 <chreekat> jusss: yes, it's possible
01:01:42 * hackage tmp-postgres 1.0.0.2 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.0.0.2 (JonathanFischoff)
01:48:05 <chreekat> MasseR: ^
01:55:28 <Orbstheorem> Hello, I have a simple haskell project that I'd like to build in gitlab. I manage to build it, but so far installing and compiling dependencies takes about 28 minutes (and building my app takes 2), is there any way I could speed this up? (binary caches, ...). I'm using stack ^^
02:31:34 <chreekat> Orbstheorem: yeah, I think so, depending on how the shared runners support caching: https://docs.gitlab.com/ee/ci/yaml/#cache
02:32:15 <chreekat> Tell stack to install the deps to a local dir instead of the default user-specific dir, then tell gitlab to cache that dir
03:04:39 <jusss> :t (>=>)
03:04:40 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
03:05:51 <jusss> what this kleisli composition can used for?
03:06:10 <Rembane> Pointfree style programming with monads
03:07:00 <jusss> i don’t get it
03:08:08 <jusss> can it use to exchange the context?
03:09:12 <maralorn> jusss: What do you mean by that?
03:09:28 <maralorn> You can‘t use it to switch monads, if that‘s what you mean.
03:09:37 <jusss> ok
03:09:52 <jusss> then how I can switch monads?
03:10:17 <jusss> and what it’s used to be
03:11:01 <maralorn> jusss: >=> is really not that special. It doesn‘t do anything that you cannot do with >>=. It‘s just a bit of convenience in certain situations.
03:12:43 <dmwit> ?src (>=>)
03:12:43 <lambdabot> Source not found. I feel much better now.
03:12:55 <dmwit> (f >=> g) x = f x >>= g
03:13:08 <dmwit> That's the entire source code for it.
03:13:08 <maralorn> e.g. loadUser :: Name -> IO User, loadProfile :: User -> IO Profile, you can do "loadUser >=> loadProfile :: Name -> IO Profile"
03:13:21 <sicklorkin> compose
03:14:35 <maralorn> But you could also do "\name -> do {user <- loadUser name; loadProfile user}"
03:18:54 <Orbstheorem> I have a CI that first creates a container that builds and installs my haskell project inside. This container is used by the subsequent stages in the CI. I just discovered the docker muti stage build feature, which allows me to separate the build env from the final image. I'd like to know if there's a way to export an artifact containing all the haskell-packages my project needs to run, so that I can leave
03:18:56 <Orbstheorem> behind all the compile-time dependencies behind
03:24:46 <maralorn> jusss: In general there is no concept for switching monads included in the typeclass. Every monad needs it‘s own functions for "switching". Often you have something like "runPure :: m a -> a" or "runInIO :: m a -> IO a"
03:24:59 <__monty__> Orbstheorem: Sounds like a static executable'd be the easiest way. (you'd still have to provide glibc and something I always forget though, I believe).
03:25:45 <jusss> ok
03:27:09 <Orbstheorem> glibc works for me, how would I go to produce static executables? Also how would that work with package data (e.g. Paths_foo)? 
03:27:20 <Orbstheorem> __monty__: ^^
03:29:33 <jusss> about ‘join’ can we use join to m a -> a?
03:29:41 <jusss> :t join
03:29:42 <lambdabot> Monad m => m (m a) -> m a
03:29:48 <Cale> Not unless a is m t for some type t
03:29:50 <__monty__> Orbstheorem: It should be mostly static already but https://www.reddit.com/r/haskell/comments/9on8gi/is_there_an_easy_way_to_compile_static_binaries/
03:31:04 <jusss> so we have to implemt m a->a ?
03:31:19 <Cale> For a particular m, you might be able to
03:31:20 <jusss> it’s been in the typeclass
03:31:22 <jusss> not
03:31:38 <Cale> But in general, a function of type m a -> a isn't going to be possible
03:31:57 <jusss> yeah, like Maybe a->a
03:32:06 <jusss> if Maybe a is Nothing
03:32:51 <jusss> but if we concret a then it’s possible, Maybe String -> String
03:33:07 <jusss> then we can return a string if it’s Nothing
03:33:45 <jusss> but that’s not a good idea, not generics
03:34:58 <jusss> I saw that maybe and fromJust in Data.Maybe
03:35:22 <__monty__> It's not possible with IO a for example.
03:37:32 <jusss> :t either
03:37:33 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
03:39:00 <jusss> what about f :: (Maybe a-> b) -> (Maybe a -> b) -> b?
03:40:31 <Cale> Doesn't seem too plausible
03:40:41 <sonar235> jusss: Is that a valid type? How is that `b` getting  returned at the end
03:40:51 <Cale> :t maybe
03:40:53 <lambdabot> b -> (a -> b) -> Maybe a -> b
03:40:56 <Orbstheorem> __monty__: Thanks
03:41:08 <Cale> If you're looking to something analogous to either
03:42:12 * hackage hedis 0.12.9 - Client library for the Redis datastore: supports full command set,pipelining.  https://hackage.haskell.org/package/hedis-0.12.9 (k_bx)
03:42:37 <jusss> sonar245: depends on the function
03:43:53 <sonar235> jusss: Well if it's generic then it doesn't. If f :: (Maybe a -> b) -> (Maybe a -> b) -> b, you are supp
03:44:11 <sonar235> supplying it with two Maybe a -> b functions, but  no value of Maybe a
03:44:27 <sonar235> so it can't return a value of type `b`
03:46:44 <Cale> Well, you could give Nothing to either one of those functions and get something of type b
03:46:59 <Cale> But that doesn't seem especially useful
03:47:25 <sonar235> Oh right yeah that's true
03:47:53 <jusss> yeah, that’s what I mean
03:48:01 <sonar235> so there would be two valid functions for f, one where you pass Nothing to the first function and another to the second
03:48:49 <jusss> yeah
03:49:14 <jusss> but it seems maybe already has that
03:49:22 <jusss> :t maybe
03:49:23 <lambdabot> b -> (a -> b) -> Maybe a -> b
03:51:01 <Phyx-> @tell haskellNewbie You have another choco install earlier on your PATH, choco appends to PATH, not prepend
03:51:02 <lambdabot> Consider it noted.
04:13:26 <f-a> I am trying to solve https://projecteuler.net/problem=14 using memoisation
04:13:47 <f-a> http://paste.debian.net/1113371/ I came up with this but I am not able to compute a solution. What am I missing?
04:22:12 * hackage lucid 2.9.12 - Clear to write, read and edit DSL for HTML  https://hackage.haskell.org/package/lucid-2.9.12 (ChrisDone)
05:00:35 <scriptdevil> Is there a (possibly-opinonated) guide to setting up Haskell projects with cabal-3+ ? I heard good things about cabal new-* but don't know where to start (I understand how to use stack)
05:02:35 <f-a> scriptdevil: mhhh I don't think there is much more than cabal init - cabal new-build xyz and cabal new-repl. I usually read the docs once I encounter an edge case
05:03:38 <dcoutts_> https://www.haskell.org/cabal/users-guide/developing-packages.html
05:04:03 <dcoutts_> https://www.haskell.org/cabal/users-guide/nix-local-build-overview.html
05:36:42 * hackage yarn-lock 0.6.1 - Represent and parse yarn.lock files  https://hackage.haskell.org/package/yarn-lock-0.6.1 (Profpatsch)
05:38:49 <thefloweringash> I'm wanting to call a haskell library from a C++ program. I can link it all together by hand, and it works, but I'm looking for a way to tell the C++ build system what libraries and include paths are required. Is there a standard or simple way to do this?
06:26:53 <[exa]> is it just me or hoogle CSS is somehow borked today?
06:27:20 <ziman> i was wondering about the same
06:27:26 <ziman> so it's probably not just us
06:28:16 <[exa]> 2 of us = basically everyone now
06:29:12 <[exa]> thefloweringash: so basically you would like the FFI to tell your makefiles that some extra includes and libraries should get watched/included/linked ?
06:29:48 <[exa]> (side question, you said "c++ build system" -- which one? :] )
06:32:01 <thefloweringash> [exa]: yeah. I'm currently using qmake, considering switching to cmake, but I'd be happy to know how to do it in any build system.
06:32:48 <scriptdevil> Thanks dcoutts_ and f-a 
06:32:54 <[exa]> afaik FFI just generates the include .h and .o/.so with the precisely same name as the haskell module in question, right?
06:33:34 <[exa]> so the only thing you need to do is to specify all these build dependencies to the system
06:33:51 <[exa]> and well, "good luck with that" in case of cmake
06:35:01 <[exa]> s/precisely same name/_stub.h suffix/
06:35:44 <Lears> f-a: Indexing deep into a list is probably slower than computing the length of the collatz sequence from scratch. I'm also not sure if your memoisation or recursion are right; that stuff can be pretty delicate. Imo it's most manageable if you just handle the cache explicitly with a state monad, e.g. (spoilers) https://gist.github.com/LSLeary/32a851dc65b74de23b7aad55592f68a1
06:36:06 <[exa]> thefloweringash: also, except for the actual FFI docs, this https://wiki.haskell.org/FFI_complete_examples#When_main_is_in_C.2B.2B is the most complete and practical example I am aware of
06:39:53 <sm[m]> morning all
06:40:10 <Rembane> Morning
06:41:23 <sm[m]> f-a: +1 to Lears' comment about memoisation being delicate, it's easy to get wrong and if you haven't already I recommend using trace to check it
06:44:34 <sicklorkin> f-a: you should be able to get something like this to complete w/o much modification. http://paste.debian.net/1113388/
06:44:54 <sicklorkin> (it won't compile as is)
06:49:20 <fendor> If I am waiting for a ffi call, such as read from a process handle, can I use timeout to wait at most 5 seconds for it?
06:49:57 <geekosaur> interrupting an FFI call is ... fraught
06:50:46 <geekosaur> because C doesn't have any good way to do so; if you happen to know that interrupting it with a signal is safe then there's a hack you can use documented in ghc's FFI support docs
06:50:55 <geekosaur> note that it's not safe for arbitrary C functions
06:52:19 <fendor> so, I cant wait for reading from a process handle at most 5 seconds? I could spawn another thread that interrupts the process by raising sigterm?
06:53:08 <geekosaur> reading from a file/process handle ususally isn't FFI but ghc rts's event loop. you can do it in a thread and have another thread throwTo it after 5 seconds
06:53:51 <fendor> oh, I thought that is ffi. Ok, great, then it is easier than expected
06:54:21 <fendor> lets add async as an dependency
06:54:27 <fendor> *a
06:54:54 <thefloweringash> [exa]: thanks for the pointers, it's useful to know I wasn't missing something obvious. I'll keep poking to see if I can make something reasonable
06:58:10 <geekosaur> at some level an FFI call is involved, but it's mnaged so this will be safe (in particular, select()/poll() and friends would be kinda useless if they couldn't be safely interrupted)
09:17:35 <heath> any ideas on how to get around this build error? https://github.com/awakesecurity/gRPC-haskell/issues/94
09:22:34 <geekosaur> it's complaiing about a library -lgpr not existing
09:24:16 <geekosaur> looks like this is bindings for the C grpc package which provides that library
09:25:45 <heath> https://github.com/grpc/grpc/tree/master/src/core/lib/gpr
09:26:01 <geekosaur> that's what I said
09:26:10 <geekosaur> so did you install grpc first?
09:26:47 <heath> I did
09:26:49 <heath> https://gist.github.com/heath/5d4f9cba79ea3eb0a686d6cb036e0c31
09:27:21 <heath> I've been running this in a Dockerfile recently and then running "stack setup && stack build" from within /opt/grpc-haskell
09:28:19 <geekosaur> does it know to look there for -lgpr? it's probably checking only the system default directories, not the current directory or its parents
09:28:22 <heath> er, I meant to say I've been running the build commands in a docker container instead of osx
09:28:45 <heath> guess I'll try passing that directory in
09:28:46 <geekosaur> this isn't windows, the current directory is not searched for random DLLs
09:28:58 <heath> tbh, when I first saw the error, I was thinking it was asking for an ada runtime
09:45:26 <heath> huh, I noticed that Docker has been emitting a slightly different error message (https://gist.github.com/heath/35cc5ce838de84c53da01c8ef5d55db0) stating that it's missing gprc and gpr. the build command being used now is stack build --extra-lib-dirs=/var/local/git/grpc/src/core/lib/gpr
10:07:11 * hackage aeson-yaml 1.0.3.0 - Output any Aeson value as YAML (pure Haskell library)  https://hackage.haskell.org/package/aeson-yaml-1.0.3.0 (patrick)
10:32:19 <bwe> How can I combine the where clauses? https://bpaste.net/show/K3N24
10:34:19 <rotaerk> bwe, one way is:  f = \case { [] -> undefined; xs -> undefined } where val = 10
10:34:23 <[exa]> bwe: pretty common: https://bpaste.net/show/465D2
10:34:24 <rotaerk> using LambdaCase
10:35:23 <yushyin> I can second [exa], I often do that.
10:35:29 <[exa]> bwe: (usually the temporary function is called 'go' or 'run')
10:35:53 <[exa]> except ofc LambdaCase is much "cleaner"
10:36:12 * hackage stylish-haskell 0.9.4.4 - Haskell code prettifier  https://hackage.haskell.org/package/stylish-haskell-0.9.4.4 (JasperVanDerJeugt)
10:36:32 <rotaerk> I'm not really a fan of the way the standard syntax requires you to repeat function names, once for the type, and once for each parameter match
10:37:06 <[exa]> rotaerk: looks more declarative!!111
10:38:25 <[exa]> also kindof prevents long names... anyway I wondered whether type declarations without name couldn't automatically bind to the next definition
10:38:40 <[exa]> :: a -> a
10:38:43 <[exa]> id x = x
10:39:43 <Phyx-> geekosaur: that's a static linker error, ld doesn't search the current directory even on Windows.
10:39:56 <Phyx-> only the loader searches cwd
10:40:34 <rotaerk> I wouldn't want to prevent long names :P sometimes it's better to make them more descriptive
10:52:42 * hackage dhall-fly 0.1.0 - Translate concourse config from Dhall to YAML  https://hackage.haskell.org/package/dhall-fly-0.1.0 (axeman)
10:54:45 <bwe> [exa], yushyin, rotaerk: thanks
11:02:06 <koz_> Neuromancer: Do you come to us from a Gibson novel?
11:02:24 <Neuromancer> indeed i am
11:03:03 <koz_> :D
11:10:20 <monochrom> Q: What does neuromancer mean?
11:10:38 <monochrom> A: It's what happens when Haskell messes with your brain. >:)
11:19:35 <nshepperd1> I'd describe my relationship with haskell as a neuromance
11:19:47 * Clint claps.
11:23:09 <geekosaur> romancing the monad?
11:32:19 <tom_> Is there a function which has this sig ::  [[(a,b,c)]] -> [(a,b,[c])]
11:32:37 <tom_> where applying [[(1, 2), (1, 3)], [(2, 1)]] equals [(1, [2, 3]), (2, [1])]
11:34:58 <infinisil> tom_: You probably have to write that on your own, and define what should happen with inputs like [[(1, 2), (2, 3)]]
11:35:57 <cocreature> also your type signature doesn’t match your example, your type signature uses 3-tuples while your example has 2-tuples
11:36:04 <infinisil> Yeah that too
11:36:08 <cocreature> but it sounds like you want to group all values with the same key?
11:37:06 <tom_> oh yeah oops
11:37:08 <cocreature> if so, there is https://hackage.haskell.org/package/extra-1.6.18/docs/Data-List-Extra.html#v:groupSort
11:37:27 <tom_> Ah ok so maybe groupSort and then 
11:39:14 <lavalike> > liftA2 (,) (fst . head) (map snd) <$> [[(1, 2), (1, 3)], [(2, 1)]]
11:39:15 <lambdabot>  [(1,[2,3]),(2,[1])]
11:42:04 <tom_> nice
11:42:18 <infinisil> I feel like if you end up with a datastructure where some values don't make sense this should be fixed
11:42:24 <lavalike> that is, as long as sublists are both nonempty and their tuples' first elements are the same
11:42:57 <tom_> Yeah perhaps I am approaching this with the wrong data structure
11:43:06 <tom_> sigh
11:43:22 <tom_> Maybe I should even be doing this in the db anyway, it is just tricky
11:43:44 <tom_> As the results of sql queries are flat by nature
11:44:04 <tom_> So if you want to have nesting you have to return json in a column which feels weird
11:45:07 <tom_> This is basically the fallout of this .. https://stackoverflow.com/questions/58674880/how-do-i-write-a-query-which-returns-a-nested-list-using-the-beam-library-in-has
11:48:14 <merijn> Which database?
11:48:21 <tom_> postgresql 
11:48:41 <merijn> ok, then all of my ideas don't work :p
11:49:05 <tom_> Am I alone in thinking this is tricky
11:49:13 <tom_> am beginning to doubt my sanity slightly
11:49:39 <merijn> tom_: The answer is "if you want anything from SQL that's not rows, you're hosed"
11:49:53 <tom_> :D
11:50:06 <merijn> Alternatively, if your problem doesn't rule out SQLite there are *some* options
11:51:12 <lavalike> > map (fmap ($[])) . M.toAscList . M.fromListWith (.) . map (fmap (:)) . concat $ [[(1, 2), (1, 3)], [(2, 1)]]
11:51:14 <lambdabot>  [(1,[3,2]),(2,[1])]
11:52:32 <lavalike> > map (fmap ($[])) . M.toAscList . M.fromListWith (flip (.)) . map (fmap (:)) . concat $ [[(1, 2), (1, 3)], [(2, 1)]]
11:52:34 <lambdabot>  [(1,[2,3]),(2,[1])]
11:53:11 * hackage country 0.2 - Country data type and functions  https://hackage.haskell.org/package/country-0.2 (chessai)
12:01:03 <Guest_54> Failed to install, consider updating this script via: ghcup upgrade"ghcup --cache install" failed!
12:01:32 <Guest_54> Would anyone know how to get around this error, im trying to install ghcup on my mac
12:01:48 <Guest_54> curl https://get-ghcup.haskell.org -sSf | sh
12:02:07 <Guest_54> this command didnt work and im on sh
12:18:12 * hackage shake-ats 1.10.4.1 - Utilities for building ATS projects with shake  https://hackage.haskell.org/package/shake-ats-1.10.4.1 (vmchale)
12:21:12 * hackage mod 0.1.0.0 - Fast type-safe modular arithmetic  https://hackage.haskell.org/package/mod-0.1.0.0 (Bodigrim)
12:51:15 <Guest_92>   I have the same problem as Guest_54 
12:52:38 <infinisil> Guest_92: No logs?
12:53:37 <Guest_92> 'consider updating this Script via;ghcup upgrade'......??
12:54:10 <f-a> thanks Lears sicklorkin sm[m] . I'll definitely use trace
12:55:44 * geekosaur is tempted to ask if this is OS X catalina
12:57:05 <sclv> Guest_92: no information at all?
12:57:12 <sclv> like does it say anything prior to that message?
12:57:15 <sclv> if so pastebin it
12:58:30 <Guest_92> configure: error: in `/var/folders/9p/2h5_mc4j2gv5wl29vpm5wjwc0000gn/T/tmp.kEUcSmrm/ghc-8.6.5':configure: error: C compiler cannot create executablesSee `config.log' for more detailsFailed to install, consider updating this script via: ghcup upgrade"ghcup --cache install" failed!
13:03:23 <sclv> Guest_92: do you have apple's dev tools installed?
13:03:57 <sclv> like do you have a gcc executable that works?
13:06:08 <Guest_92> Hi sclv - I appreciate you trying to help but don't know 'dev tools' or 'gcc executable' sorry
13:06:40 <sclv> Guest_92: you need to install apple developer tools from the app store (https://en.wikipedia.org/wiki/Apple_Developer_Tools) 
13:06:48 <sclv> and install the command line tools from xcode
13:07:01 <sclv> if you run "gcc" what happens?
13:07:03 <sclv> on the terminal
13:08:08 <merijn> After installing XCode "xcode-select --install" in the terminal should install the commandline tools
13:09:34 <Guest_92> Ah - I shall try that - thank you.
13:15:55 <Guest_92> Thanks for all your help - I think I've worked out what the problem is - my mac is too old!!!  I tried downloading the ADT from the App Store but told I cannot install x code because I 
13:16:44 <Guest_92> sorry - to continue need mac OS 10.14.4 or later....need new gear
13:17:59 <yushyin> at least easy fixable
13:24:23 <tom_> Ok so I did the groupBySort type of thing like this https://pastebin.com/P0d7rzqj
13:24:34 <tom_> Can anyone give some recommendations to make my code more palatable
13:27:16 <sclv> Guest_92: you can possibly get an older version of the dev tools from somewhere
13:27:20 <sclv> but i don't remember where
13:29:43 <Guest_92> ah - that's interesting - I'll look into it - thanks sclv
13:30:08 <sclv> Guest_92: note you don't need all of xcode/devtools just the "commandline tools" portion
13:30:23 <f-a> tom_: where are you sorting?
13:30:53 <f-a> tom_: `on` and `comparing` can help a bit
13:30:55 <f-a> :t on
13:30:57 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
13:30:58 <f-a> :t comparing
13:30:59 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
13:31:08 <jellostahps> How do I pattern check for an empty tuple?
13:31:27 <f-a> when you group/compare on a element of a product type
13:31:30 <geekosaur> sclv, did they go back to that being possible?
13:31:36 <f-a> jellostahps: hello again :P
13:31:48 <jellostahps> hey
13:31:51 <f-a> jellostahps: do you mean ()?
13:32:11 <f-a> in this case, it is called `unit`, it is not a tuple, an makes very little sense to pattern match on it
13:32:24 <f-a> can you tell us what you are trying to do?
13:32:25 <jellostahps> idek at this point. I have a function that takes in 2 tuples, and if 1 is empty I want to return something based on that
13:32:26 <geekosaur> tuples are not funny looking lists
13:32:46 <f-a> jellostahps: a tuple is fixed in its length
13:32:50 <geekosaur> you cannot compare (1,2) to (1,2,3), it is a type error
13:33:13 <jellostahps> Yes, the function takes in 2 tuples of the ame length
13:33:18 <jellostahps> *same
13:33:24 <geekosaur> then how can it be empty?
13:33:26 <f-a> jellostahps: what do you mean with empty then?
13:33:35 <f-a> all its values to, say, 0?
13:33:39 <jellostahps> oh jeez
13:33:49 <jellostahps> I guess I dont have to check for that then anyways
13:34:01 <f-a> "for that" what :P
13:34:13 <f-a> jellostahps: I suspect you will be happier with lists
13:34:18 <jellostahps> for an empty tuple
13:34:53 <sclv> geekosaur: what do you mean? i haven't been keeping track
13:35:01 <sclv> i thought there was some secret place to get old cmd-line tools
13:35:02 <jellostahps> ill work my way around it
13:35:07 <sclv> but idk where since i haven't had to in forever
13:35:09 <f-a> jellostahps: think about it, an "empty tuple" ( () ) is the only element of type (), there is no reason to typecheck on that
13:35:13 <sclv> if they deleted it, that would be lame
13:35:17 <sclv> but hey, apple, go figure
13:35:33 <geekosaur> there used to be, but apple's own went away and other sources are technically illegal and apple keeps getting them shut down
13:35:42 <geekosaur> or at least contrary to their licensing
13:35:43 <sclv> wtffff
13:36:05 <sclv> the command line tools include gpl core right!?
13:36:15 <sclv> or is it all bsd that they have relicensed proprietary
13:36:16 <f-a> sclv: I believe they worked around that
13:36:17 <sclv> mfers
13:36:26 <f-a> i.e. dumping all gpl'd stuff
13:36:30 <f-a> almost all
13:36:44 <f-a> iirc they have bash no more but zsh
13:36:49 <sclv> ok i take it all back about clang
13:36:50 <sclv> clang bad
13:36:51 <geekosaur> and they didn't relicense most bsd stuff, they just don't want gpl3 at all
13:37:09 <geekosaur> and gpl2 stuff is now far too old to be practical
13:37:13 <f-a> yeah to pull stunts like that
13:38:47 <geekosaur> also there's no gpl violation here, if you don't have the tools installed then you have nothing to get source for. gpl can't say "your OS vendor is forced to provide a way for you to install gpl programs"
13:39:14 <sclv> right, fair enough -- they have to give source, but not executables
13:39:14 <f-a> geekosaur: you can't shut down sources
13:39:15 <geekosaur> and absent the command line tools "gcc" or "clang" is a dummy
13:39:24 <merijn> You can install old XCode versions just fine
13:39:26 <f-a> with gpl
13:39:26 <sclv> but if they had to give the source fully, then anyone could build the executables and distribute them
13:39:32 <geekosaur> f-a, exactly
13:40:01 <geekosaur> you can get gcc sources, apple didn't change them
13:40:09 <merijn> sclv: That's not the reason they're avoiding GPL, there's the Apple open source website that does provide the source for all the GPL stuff they ship and a bunch of BSD stuff too
13:40:10 <geekosaur> you can't get xcode sources but xcode isn't gcc
13:40:20 <merijn> geekosaur: They did change gcc, though :p
13:40:36 <merijn> https://opensource.apple.com/
13:40:40 <sclv> the thing i'm complaining about is them making old command-line tools inaccessible reportedly
13:40:48 <sclv> and shutting down other people for "license violations" for distributing them
13:41:15 <merijn> sclv: I dunno, this sounds like a bunch of hearsay nonsense to me
13:41:20 <geekosaur> command line toolls is more than gcc. and in particular system header files are not covered by gpl
13:41:30 <geekosaur> but you won't get far compiling things without them
13:41:51 <sclv> merijn: yeah take it up with geekosaur, who just tld me :-P
13:42:05 <merijn> sclv: The open source link I I just pasted has the Dev Tools all the way back to 2.x
13:42:17 <geekosaur> oh, they finally did that then?
13:42:29 <merijn> geekosaur: What? That's always been there?
13:42:36 <geekosaur> used to be there was a downloads area on developer.apple.com which went away
13:42:44 <geekosaur> the installable dev tools used to be there
13:43:16 <geekosaur> opensource.apple.com was the open part, which didn't include system include files and such
13:43:37 <geekosaur> opendarwin used to include a subset of them, but stopped being updated years ago
13:47:50 <merijn> geekosaur: Last I checked you could just download old xcode versions from the app store and developer site
13:48:04 <lukelau> Is there a way to propagate TypeErrors in data types with phantom types?
13:48:07 <geekosaur> maybe they put the old ones back then
13:48:22 <geekosaur> but this thread started with someone saying the app store had told them their os x was too old
13:48:29 <merijn> I can't really check atm, due to them refusing to send me my 2FA code
13:48:36 <f-a> lukelau: can you write an example
13:48:48 <lukelau> e.g. I have a datatype with `newtype Foo (a :: k) b = Foo b`
13:49:03 <merijn> geekosaur: I try not to put too much stock into 1.5 line abbreviations of unclear errors
13:49:15 <lukelau> But putting (Foo 42 :: Foo (TypeError (‘Text “boo”)) Int) seems to be fine
13:49:26 <geekosaur> which I also recall from when I still had a Mac, and they made all the old versions disappear from the app store at the same time developer.apple.com/downloads started redirecting to the main developer.apple.com page
13:49:29 <merijn> geekosaur: Lots of possible reasons for potential failures, such as "trying to install an xcode that's too new"
13:50:04 <lukelau> But I should mention that this only happens when the typeerror is coming from a type family
13:52:07 <unfixpoint> Looking at http-client-tls: There are the functions `{get,set}GlobalManager` (which are implemented w/ `{read,write}IORef`.. Surely these are not thread-safe, are they?
13:52:44 <merijn> unfixpoint: readIORef and writeIORef are atomic
13:52:57 <merijn> unfixpoint: So "it depends what they do when reading/writing"
13:53:25 <lukelau> f-a: https://gist.github.com/30e2e9888bc2c75148b3268d57ba86c7
13:54:08 <lukelau> This is my example here, new typechecks, and in ghci `:type new` gives `new :: SubIO' (TypeError ...) () `
13:54:12 <unfixpoint> They set `globalManager = unsafePerformIO $ newTlsManager >>= newIORef` and then do the {read,write} on that. Tbh, I don't understand the IO implications
13:54:47 <unfixpoint> To me it seems like I should lock that manager across the threads, am I wrong?
13:54:50 <f-a> sorry lukelau , never really used type families
13:55:42 * hackage token-limiter 0.2.0.1 - Fast rate limiting using the token bucket algorithm (BSD)  https://hackage.haskell.org/package/token-limiter-0.2.0.1 (GregoryCollins)
13:56:01 <unfixpoint> I mean, `unsafePerformIO` sounds bad, but it's not always wrong to use I think.. 
14:00:55 <unfixpoint> So, basically I'm using `httpLbs _ (man :: Manager)` across multiple threads. The non-TLS version for `Manager` says I should reuse the it across threads. Now I have three options:
14:01:36 <unfixpoint> 1) Use that global manager I mentioned 2) Create a manager and pass it as argument/reader monad 3) Pass an MVar for the manager
14:02:28 <unfixpoint> Option 3 is more work, but will work I'd assume. Now, I'm not sure about the other two options. Would option 1 or at least 2 be safe too, or will I run into troubles there?
14:04:12 <jellostahps> If I have a foldl inside a foldl, then will the iterator of the outer foldl have scope inside the inner foldl?
14:04:30 <jellostahps> list iterator*
14:05:29 <gobby> Is there a way to generate SQL to create my schema using beam? I.e if i've defined a table in `beam` is there a way to convert it into SQL so I can create my db?
14:19:09 <nshepperd> Is there a more specific term for a function F that is injective in the sense that F x y = z | z x -> y, z y -> x, but *not* in the sense that z -> x y?
14:19:31 <nshepperd> like 'bilinear' but for injectivity, or something
14:30:08 <jellostahps> ignore my prev. question I think I figured it out
14:34:39 <ysangkok> i am really confused regarding getting stacktraces without HasCallStack
14:34:52 <ysangkok> bss03 states that all you need is "-g", is that true?
14:35:11 * hackage avro 0.4.5.4 - Avro serialization support for Haskell  https://hackage.haskell.org/package/avro-0.4.5.4 (haskellworks)
14:35:44 <ysangkok> i see all these comments about various profiling flags... and somebody mentions "configuring" with --enable-profiling. but i use "cabal new-run", and i don't have a configure step
14:36:07 <ysangkok> i just added -g to ghc-options in the cabal file, and i append the +RTS -cx flag to new-run, but nothing happens
14:36:13 <sclv> new-run autoconfigures
14:36:18 <sclv> but you can also new-configure iirc
14:36:40 <merijn> new-configure just makes a cabal.project.local, you can also just do that yourself
14:37:02 <merijn> ysangkok: You wanna run cabal with "--enable-profiling" when doing new-run
14:37:18 <merijn> ysangkok: Alternatively, make a cabal.project.local file with the line "profiling: True"
14:37:44 <merijn> You also need to add -rtsopts to ghc-options to be able to use +RTS
14:38:49 <ysangkok> so 'ghc-options: "+RTS -xc"  ' ?
14:38:59 <ysangkok> no wait
14:39:09 <ysangkok> ghc-options: -rtsopts +RTS -rtsopts -xc ?
14:39:26 <merijn> No, "ghc-options: -rtsopts"
14:39:39 <merijn> ysangkok: That tells ghc to compile an executable that understands +RTS
14:39:42 <AWizzArd> I saw this very interesting benchmark: https://github.com/pepeiborra/gc-benchmarks/blob/master/README.md
14:39:45 <AWizzArd> Now does anyone know how the existing and new GC compare, on this specific (pusher-) benchmark, on the same machine?
14:39:50 <ysangkok> ooh i thought it was like -Wl for gcc
14:41:37 <ysangkok> lol "Could not find module ‘Prelude’"
14:42:00 <ysangkok> well, at least it tried to rebuild everything with profiling. so some progress :P
14:42:42 * hackage aeson-diff 1.1.0.8 - Extract and apply patches to JSON documents.  https://hackage.haskell.org/package/aeson-diff-1.1.0.8 (ThomasSutton)
14:42:48 <merijn> ysangkok: Incidentally, adding "+RTS -xc" to ghc-options runs *ghc* with those RTS options, not your executable ;)
14:42:56 <ysangkok> aaah
14:43:04 <d34df00d> Hi!
14:43:28 <ysangkok> thanks for helping me... i have had this bugging me for months now, never really motivated to figure it all out
14:43:55 <ysangkok> there are not many languages where you routinely pass runtime-library configuration flags to your built executable
14:44:53 <d34df00d> I have a sort of algebraic question. Consider a class `C p r` with two operations, `extract :: r -> p` and `update :: (p -> p) -> (r -> r)` such that the following laws hold: `update id = id`, `update (f . g) = update f . update g` and `extract . update f = f . extract`. What would be its (categorical) dual?
14:45:39 <d34df00d> The intuition is that C is a sort-of-lens that allows projecting a component out of a record type and update that record type based on an updating function for a field.
14:45:41 <merijn> ysangkok: You can use -withrtsopt too to pass RTS options at compile time
14:46:23 <merijn> ysangkok: You can even specify that *some* options are settable and others are not
14:47:08 <ysangkok> i am really just looking for the simplest way of always enabling debugging, since i don't care about performance at all. so i guess the best way is "ghc-options: -withrtsopt -xc" and the local file you talked about. and then i just use new-run like always
14:47:24 <d34df00d> I sort of understand it would be `inject :: p -> r` and `coupdate :: (r -> r) -> (p -> p)`, where `r` is dual to a product type (hence a sum) and `p` is dual to an element of a product type (hence on option). But what would be the semantics of `coupdate`?
14:48:09 <merijn> ysangkok: Just adding -rtsopts and having "profiling: True" is enough, -xc tends to be a bit spammy, so I wouldn'y enable it always
14:48:19 <d34df00d> My intuition is that it takes a function working on a sum type and produces a function that works on a given option of that sum, but that doesn't make sense for any function working on the sum (but only for those that don't change the tag).
14:48:23 <merijn> ysangkok: (i.e. it reports all exceptions, including those that are caught)
14:48:31 <d34df00d> Is there a nice and more formal way to describe this?
14:48:35 <merijn> ysangkok: Which, as you'll see, are more than you though :)
14:59:44 <ysangkok> hmmm, i wonder if there the profiling variants of the base libraries is a separate package if i am using hvr's ubuntu builds. since i get this error https://hushfile.it/api/file?fileid=5dbf5b7b1b6fa
15:00:29 <merijn> "Could not find module ‘Prelude’" <- yeah...I'm gonna go ahead an say something's fucked...
15:13:42 * hackage morte 1.7.2 - A bare-bones calculus of constructions  https://hackage.haskell.org/package/morte-1.7.2 (GabrielGonzalez)
15:18:46 <ysangkok> switched to using ghc from ghcup instead, and now it seems to work. but what a weird combination, cabal from hvr, but not hvr's ghc build...
15:19:54 <phadej> ysangkok: there are
15:19:58 <phadej> ghc-8.6.5-prof
15:19:59 <phadej> in ppa
15:20:38 <phadej> % apt-cache search ghc-8.6.5
15:20:38 <phadej> ghc-8.6.5 - The Glasgow Haskell Compilation system
15:20:38 <phadej> ghc-8.6.5-dyn - The Glasgow Haskell Compilation system
15:20:38 <phadej> ghc-8.6.5-htmldocs - The Glasgow Haskell Compilation system
15:20:38 <phadej> ghc-8.6.5-prof - The Glasgow Haskell Compilation system
15:20:38 <yahb> phadej: ; <interactive>:43:1: error:; * Variable not in scope: apt :: a -> c; * Perhaps you meant one of these: `app' (imported from Control.Arrow), `ap' (imported from Control.Monad), `at' (imported from Control.Lens); <interactive>:43:5: error: Variable not in scope: cache :: t0 -> t1 -> a -> c; <interactive>:43:11: error:; * Variable not in scope: search; * Perhaps you meant `each' (imported
15:23:49 <ysangkok> aaaah! thanks! errornously used dpkg -l to search for the prof variant. of course that only works if the package was ever installed...
15:26:42 * hackage api-rpc-pegnet 0.1.0.0 - simple json-rpc client for PegNet  https://hackage.haskell.org/package/api-rpc-pegnet-0.1.0.0 (sigrlami)
15:37:55 <hololeap> so is Float something like (data Float n = Float n | Infinity | NaN) ?
15:38:28 <hololeap> (not that i think it's polymorphic...)
15:39:03 <merijn> Float is just the same thing as float in C and every other languagw
15:39:11 <merijn> i.e. IEEE-754 single precision
15:39:18 <hololeap> just curious if Infinity and NaN are parts of a sum type or if they're actually represented by a float value behind the scenes
15:39:46 <merijn> hololeap: There isn't one NaN, there's a bunch of different ones and you're missing negative infinity
15:40:29 <monochrom> If you mean "does Haskell add its own Infinity and NaN" then no.
15:41:11 <hololeap> monochrom: that's a better way to phrase my question
15:41:29 <hololeap> alrighty. just wondering.
15:41:52 <monochrom> I would not call it "not a sum type" because whenever someone uses different bit patterns for different cases that's morally a sum type.
15:42:47 <wikiemol> Is there a detailed explanation of Functional Reactive Programming? All of the examples I have seen have been too high level for me to really wrap my head around.
15:43:10 <merijn> wikiemol: Conal's papers are pretty good
15:43:22 <hololeap> i'm not familiar with IEEE 754
15:43:23 <merijn> wikiemol: http://conal.net/fran/
15:43:38 <merijn> wikiemol: http://conal.net/papers/push-pull-frp/
15:44:02 <monochrom> Everyone should read this: https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
15:44:11 <hololeap> i'm looking at the wikipedia page for it, but it's a little too dense for my taste right now. i was just idly curious.
15:44:15 <merijn> hololeap: It's the standard for floating point implementations that's used by most languages, i.e. most C implementations, Java, everything
15:44:36 <monochrom> Well, everyone who uses floating point at all.
15:44:42 <wikiemol> merijn Thanks!
15:44:55 <merijn> (C/C++ don't technically require that an implementation uses IEEE-754, but most common ones do, because that's what your CPU supports)
15:45:18 <merijn> monochrom: I'm sure there's some weird languages that roll their own FP support somewhere :p
15:45:40 <monochrom> Such as Java.
15:45:50 <hololeap> i see. i think i had a more simplified viewpoint of how floating point works in the real world
15:46:18 <monochrom> Java differs from IEEE754 by just one point: Java has one 0, 754 has +0 and -0.
15:46:38 <merijn> hololeap: But yeah, almost any time you see float or double pop up in a language they're referring to the single and double precission formats defined in IEEE-754
15:46:42 <monochrom> One of those times when "more intuitive" is wrong.
15:47:44 <monochrom> (Hint: Having one 0 makes sense iff you also have at most one infinity.)
15:50:23 <monochrom> But Goldberg's contains a lot of stuff that applies to all floating point mechanisms.
16:10:15 <jellostahps> @hoogle elem (Eq a)
16:10:15 <lambdabot> Net.Concurrent newEmptyMVar :: MVarIO v io => io (v a)
16:10:16 <lambdabot> Net.Concurrent newChan :: ChannelIO c io => io (c a)
16:10:16 <lambdabot> Control.Monad.Par.Class new :: ParIVar ivar m => m (ivar a)
16:10:52 <jellostahps> @hoogle Eq a => [a] -> a -> Bool
16:10:53 <lambdabot> Data.List.Unicode (?) :: Eq ? => [?] -> ? -> Bool
16:10:53 <lambdabot> Data.List.Unicode (?) :: Eq ? => [?] -> ? -> Bool
16:10:53 <lambdabot> Data.Foldable.Unicode (?) :: (Foldable t, Eq ?) => t ? -> ? -> Bool
16:11:35 <f-a> jellostahps: my suggestion: integrate hoogle in your ghci 
16:11:37 <jellostahps> @hoogle Eq a => a -> [a] -> Bool
16:11:37 <lambdabot> GHC.List elem :: Eq a => a -> [a] -> Bool
16:11:37 <lambdabot> GHC.List notElem :: Eq a => a -> [a] -> Bool
16:11:38 <lambdabot> GHC.OldList elem :: Eq a => a -> [a] -> Bool
16:11:51 <jellostahps> found it ;)
16:12:08 <jellostahps> how hard is that to do
16:12:14 <f-a> very easy
16:12:45 <f-a> add this to your ~/.ghci http://www.ariis.it/link/t/paste31893-0
16:13:09 <f-a> and install hoogle with `cabal new-install hoogle`
16:13:17 <jellostahps> ok
16:13:24 <blondiee354> what does this error mean ? https://bitlylink.com/wj3kY
16:13:31 <f-a> (and for the first run generate the db with `hoogle generate`)
16:13:56 <jellostahps> oh damn i thought this was ez lol, idek what ~/.ghci is ...? Path?
16:14:06 <f-a> blondiee354: wrong link
16:14:21 <f-a> jellostahps: are you on linux/unix?
16:14:26 <jellostahps> yes
16:14:31 <jellostahps> new to it, however
16:14:31 <f-a> are you using stack?
16:14:50 <f-a> jellostahps: ~/ is your home folder
16:15:04 <jellostahps> ooh
16:15:11 <f-a> say your editor is gedit, `gedit ~/.ghci` will do
16:15:31 <jellostahps> whats the ls command for hidden files again? ls -a?
16:15:41 <f-a> ls -a yeah
16:16:18 <jellostahps> i have .ghc , not .ghci
16:16:42 <f-a> well, create it jellostahps 
16:19:14 <jellostahps> its asking me to install cabal-install   , is that the correct thing to install or is it malicious?
16:19:20 <TheCommieDuck> can I somehow make a typeclass instance but instead of on a type, I do it on a typeclass? e.g. instance Foo (Num a => a) where..
16:19:50 <jellostahps> 'cabal-install' all lower case
16:20:12 <f-a> jellostahps: you are not using cabal? are you using stack?
16:20:29 <jellostahps> I mean I guess I am using stack, not sure
16:20:34 <f-a> (how do you invoke ghci)
16:21:18 <f-a> how do you enter a repl session, jellostahps 
16:21:28 <jellostahps> wait lemme check my notes
16:21:52 <f-a> (or: how do you compile your programs)
16:22:17 <jellostahps> 'stack ghci'
16:22:26 <jellostahps> I was running the cabal install from outside ghci
16:24:10 <f-a> sorry I am not a stack user, but `stack hoogle -- -i map` should work (from https://github.com/commercialhaskell/stack/issues/55 ) 
16:34:41 * hackage hasql-transaction 0.9.1 - Composable abstraction over retryable transactions for Hasql  https://hackage.haskell.org/package/hasql-transaction-0.9.1 (NikitaVolkov)
16:42:27 <GyroW> Hi, I was watching https://youtu.be/9T8A89jgeTI?t=600 about lambda calculus and was wondering how I should solve the second question he poses.
16:43:07 <ChaiTRex> GyroW: What is the second question?
16:43:23 <GyroW> Writing the factorial function as general recursion
16:43:36 <ChaiTRex> GyroW: Oh. What's the base case?
16:43:42 <GyroW> general recursion being rec f = f (rec f)
16:43:47 <ChaiTRex> Ahh, that.
16:44:14 <GyroW> so I need to find 'f'
16:44:50 <GyroW> and he hints on using (\f . \n . ?) where ? is still to be filled in
16:45:10 <monochrom> Huh? I thought the goal was how to use f.
16:45:44 <GyroW> well in any case, what should 'f' be to calculate factorial of n
16:46:02 <monochrom> No.
16:46:11 <GyroW> No?
16:46:15 <monochrom> You are given f.  It's a parameter given to you.
16:46:26 <monochrom> You are to find "?".
16:46:44 <monochrom> Inside "?" you may use f (in fact you need to).  use.
16:46:59 <GyroW> well but he says in the video it's the non recursive part
16:47:04 <monochrom> Likewise you use n, not ask "what should n be? I need to find n."
16:47:31 <monochrom> That doesn't contradict what I said. Hell in fact I think it supports what I said.
16:47:54 <GyroW> Well it's confusing to me
16:49:45 <GyroW> I understand that rec f n = f ( rec f) n = f ( f (rec f) ) n
16:49:55 <GyroW> Right?
16:50:31 <monochrom> Is it OK if you used a different name in your "rec f n = f ( rec f) n = f ( f (rec f) ) n"?
16:50:46 <monochrom> I mean don't use "f" there again. Use "g"?
16:51:05 <monochrom> "rec g n = g (rec g) n"?
16:51:13 <GyroW> Yeah sure?
16:51:54 <monochrom> Because next you're going to do "g = \f n . ?"
16:53:18 <GyroW> I guess so, I've been stumbling on this for a good 40 minutes now and haven't come up with anything viable...
16:53:21 <monochrom> rec (\f n. ?) = (\f n. ?) (rec (\f n. ?)) n
16:54:55 <GyroW> so if n == 0 return 1 else return (*) n ?
16:57:23 <monochrom> OK, you're defining "fac = rec (\f n. ?)" and you're wondering what to fill in for "?".
16:58:17 <monochrom> You know "rec (\f n. ?) n = (\f n. ?) (rec (\f n. ?)) n"
16:59:05 <monochrom> Let's just reuse the name "fac" to stand for "rec (\f n. ?)".  So you're looking at: fac n = (\f n. ?) fac n
17:00:20 <monochrom> Let me make a wild guess "? = f (n-1)" it's going to be wrong but let's see why I'm wrong.
17:01:00 <monochrom> fac n = (\f n. f (n-1)) fac n = (\n. fac (n-1)) n = fac (n - 1)
17:01:42 <monochrom> This is wrong because you don't want "fac n = fac (n-1)" but now suddenly you also see: if you make a guess for ?, you now know how to check your guess.
17:02:15 <GyroW> well we want n * fac (n-1)
17:02:19 <jellostahps> :t [] && []
17:02:20 <lambdabot> error:
17:02:20 <lambdabot>     • Couldn't match expected type ‘Bool’ with actual type ‘[a0]’
17:02:20 <lambdabot>     • In the first argument of ‘(&&)’, namely ‘[]’
17:02:47 <monochrom> Maybe even you see how to reverse engineer (in fact refactor) "if n=0 then 1 else n * fac (n-1)" into the "(\f n. ?) fac n" form.
17:03:38 <TheCommieDuck> so if I'm reading this right, I can do class A a where foo :: a -> Int, class A a => B a where foo :: a -> Bool, but is there a nice way to do instance (A a) => B a and get a 'free' instance of A for any B?
17:05:21 <monochrom> No free instance.
17:05:26 <GyroW> No I don't understand
17:05:40 <TheCommieDuck> welp, thanks.
17:06:31 <monochrom> Oh with my new information you're supposed to take another 40 minutes.
17:08:34 <GyroW> I tried doing it that way, but (\f -> \n -> if n == 0 then 1 else (*) n f(n-1)) doesn't work
17:08:59 <monochrom> Why are you not writing "n * f(n-1)"?
17:09:31 <GyroW> how is that not equivalent
17:09:32 <GyroW> ._>
17:09:52 <monochrom> It is.
17:10:03 <monochrom> Except parenthesizing
17:11:58 <GyroW> Ok well guess I'm not as dumb as I thought
17:12:17 <dmwit> TheCommieDuck: You can `class A a where foo :: a -> Int; default foo :: B a => a -> Int; foo a = fromEnum (bar a); class B a where bar :: a -> Bool`.
17:12:33 <GyroW> Thanks
17:12:49 <dmwit> TheCommieDuck: Then you may write e.g. `instance B X where bar x = ...; instance A X` and get a "free" instance of `A` for `X`.
17:15:06 <GyroW> But when does it start "filling" in `n`? monochrom 
17:15:23 <monochrom> When the user provides a number?
17:16:03 <GyroW> right at the start?
17:16:24 <monochrom> I don't know. I don't know how the user uses it.
17:16:53 <GyroW> recfac n = rec (\f -> \n -> if n == 0 then 1 else (*)n  (f(n-1))) n = (\f -> \n -> if n == 0 then 1 else (*) n  (f(n-1))) (rec (\f -> \n -> if n == 0 then 1 else (*)n  (f(n-1)))) n
17:16:59 <monochrom> Maybe the user writes "map fac [1,2,3,4]" so it gets filled multiple times?
17:17:08 <GyroW> wel just fac 5
17:17:20 <GyroW> so it first fills in n and then start recursing?
17:18:27 <monochrom> You have all the necessary skills to answer that question.
17:21:00 <Flummox> Hello, I'm doing Learn You A Haskell and have a question. We are defining a length function with pattern matching and recursion and this is the type signature: length' :: (Num b) => [a] -> b
17:21:14 <GyroW> well values get filled in from right to left, correct?
17:21:40 <Flummox> Why is a class constraint being used? Why not just define it as: length' :: [a] -> Int
17:22:06 <f-a> Flummox: well you might want to use that function in other settings
17:22:09 <jchia> Flummox Num is a typeclass. Int is a class. This function can also return other Num types like Integer
17:22:09 <Axman6> what if you want the length as a Double?
17:22:13 <f-a> where, i.e. a float is required
17:22:25 <Flummox> ah
17:22:27 <jchia> Sorry, Int is a type
17:22:40 <Axman6> average :: [Double] -> Double; average = sum xs / length xs
17:22:44 <f-a> a typeclass let you do it without need to use pesky conversion fuctions
17:23:00 <Axman6> (This is a terrible way to write average though, don't do this)
17:23:31 <Axman6> average :: [Double] -> Double; average = sum xs / fromIntegral (length xs) -- you need this if length returns Int
17:24:04 <Flummox> Since the function is defined using only Integer operations should it still be left open to use other Num types?
17:24:21 <f-a> Flummox: which operations
17:24:22 <monochrom> No, the function is defined using only Num operations.
17:24:25 <f-a> :t (+)
17:24:26 <lambdabot> Num a => a -> a -> a
17:24:29 <f-a> ^--
17:24:50 <Flummox> oh...
17:24:52 <f-a> Flummox: if those were *Integer* operations the compiler would reject the program
17:25:17 <f-a> you can try it yourself, devine an Integer-only myPlus function
17:27:42 <GyroW> Is there something like python tutor but for haskell?
17:27:50 <monochrom> No.
17:28:13 <GyroW> I just can't get my head around this, what I think is a core concept with haskell and recursion
17:28:38 <monochrom> Haskell allows you to write "fac n = fac (n-1)" directly.
17:29:09 <monochrom> Also the Y combinator is not for beginners.
17:29:18 <GyroW> Yeah I know that but recfac n = rec (\f -> \n -> if n == 0 then 1 else (*)n  (f(n-1))) n is equivalent
17:29:35 <GyroW> Beginners in functional programming or in general?
17:29:59 <GyroW> I'm in my third year of CS but this was never touched
17:30:55 <GyroW> We saw turing machines but lambda calculus was taken out a few years prior
17:31:14 <Axman6> what a terrible choice
17:31:29 <GyroW> It got shifted to the master's
17:31:42 <Axman6> "Let's use mutation to compute everything, in a world of concurrency"
17:40:34 <Flummox> Thanks for the help. I'm sure I'll be back soon enough :)
17:42:25 <jellostahps> Quick quesiton: Is (y:[] ) = [y] or to [ [y] ]?
17:42:54 <monochrom> > (True : [])
17:42:56 <lambdabot>  [True]
17:43:18 <jellostahps> ty
17:43:39 <GyroW> I still don't get how it fills in n
17:44:29 <monochrom> Basically like "(\f n . f (n*2)) sin 4 = sin (4*2)"?
17:44:52 <GyroW> well but I only have n behind the lambda
17:45:02 <GyroW> recfac n = rec (\f -> \n -> if n == 0 then 1 else (*)n  (f(n-1))) n
17:45:23 <GyroW> since I call rec g n but g is a lambda taking 2 arguments
17:46:11 <monochrom> I wouldn't care how many parameters g takes.  I would just expand "rec g" to "g (rec g)" and take it from there.
17:46:47 <GyroW> well so then rec g to g (rec g) n
17:47:02 <GyroW> does it then fill in n at that step?
17:47:04 <Axman6> reg g n = g (rec g) n
17:47:17 <GyroW> let's say n = 3
17:47:54 <monochrom> Again, you have the skills to finish it.  "(\f n . blahblahblah) (rec g) 3" you know how to take it from there.
17:48:19 <Axman6> execute it by hand: rec (\f n -> f (n-1)) 3 =>  (\f n -> f (n-1)) (rec (\f n -> f (n-1))) n. what comes next?
17:48:20 <GyroW> rec (\f -> \n -> if n == 0 then 1 else (*)n  (f(n-1))) n becomes (\f -> \n -> if n == 0 then 1 else n * f(n-1)) (rec g) 3
17:48:36 <monochrom> If you know how to do "(\f n . f (n*2)) sin 4" you know how to do this.
17:48:49 <GyroW> If I understood I wouldn't still be on this an hour later
17:48:58 <heatsink> Right.  Now you have this lambda applied to 2 arguments, so you can substitute the arguments
17:50:55 <monochrom> May I say this is one of those times you do steps not think theory.
17:51:39 <monochrom> One of those times 5 minutes of doing can be saved by 1 hour of armchair philosophizing.
17:51:55 <GyroW> rec (if 3 == 0 then 1 else 3 * (\f -> \n if n == 0 then 1 else n * f(n-1)) 2
17:51:57 <GyroW> ?
17:51:58 <Axman6> GyroW: you understand how (\f n . f (n*2)) sin 4 becomes (\n . sin (n*2)) 4 and then sin (4*2) yeah?
17:52:52 <heatsink> The body of the lambda starts with "if".  Where did the first "rec" come from?
17:52:57 <GyroW> No that's wrong waht I said
17:54:06 <GyroW> if 3 == 0 then 1 else 3 * (\f -> \n if n == 0 then 1 else n * (rec if n == 0 then 1 else n*f(n-1) 2)
17:54:08 <GyroW> is that it?
17:54:25 <monochrom> substantial typos and omissions
17:55:06 <GyroW> \f -> \n -> and a closing )
17:55:34 <GyroW> but that's the essence of it?
17:55:50 <heatsink> Not quite
17:56:14 <GyroW> What did I miss
17:56:20 <heatsink> If you do it right, you should notice that the new call of (rec ...) looks similar to the original call, but with some parameters changed
17:56:34 <heatsink> Here, rec has ended up in the wrong place
17:57:53 <heatsink> Before substitution, that part of the function body was "n * f (n - 1)"
17:58:29 <GyroW> well there should be () around if ... -1)
17:59:16 <TheCommieDuck> https://pastebin.com/C04wxfbY so I've ended up writing this, and it's fine, but it feels like something that has a much better way to write? 
18:00:02 <monochrom> Yes. I would delete it all. :)
18:00:32 <monochrom> My rule is if you don't have at least 3 instances, don't make a class.
18:00:47 <monochrom> Actually that's merely the first condition.
18:01:01 <GyroW> I really don't see it
18:01:26 <TheCommieDuck> okay, let's imagine I have this but it extends to SpecificallyVerySpecificThing, and AnotherThing Thing Bool, and SpecificAnotherThing AnotherThing Int String, and etc etc.
18:02:22 <monochrom> Second condition is if you don't have laws for your methods, don't make a class.
18:02:55 <heatsink> GyroW: Here's the expression with some parts taken out.  (\f -> \n -> (...) n * f(n-1)) (rec g) 3
18:02:56 <TheCommieDuck> trivial instances to be able to do IsWhatever is one red flag, double defining each type with getX and X is the other.
18:03:09 <heatsink> GyroW: When you substitute for f and n, you get...?
18:04:26 <GyroW> ((...) 3 * reg g n-1
18:04:29 <GyroW> )
18:05:11 <heatsink> There is still an n there.  Remember to substitute all occurrences of n
18:05:32 <Axman6> it might help if you write things up in an editor with syntax highlighting, helps a lot with the boring details of matching brackets etc.
18:05:57 <GyroW> I'm trying but I'm just not making the click in my monkey brain
18:06:20 <monochrom> It takes 10-100 exercises like this to click.
18:07:03 <monochrom> Likewise you don't click chess just by IRCing.
18:07:25 <maerwald> most likely, exercises don't make it click as well, actual gameplay does
18:07:34 <monochrom> OK, unless the IRCing does like "knight G7 - F5".
18:10:22 <GyroW> rec (\f -> \n -> if n == 0 then 1 else (*)n  (f(n-1))) 3
18:10:24 <GyroW> (\f -> \n -> if n == 0 then 1 else (*)n  (f(n-1))) (rec (\f -> \n -> if n == 0 then 1 else (*)n  (f(n-1)))) 3
18:10:26 <GyroW> (\n -> if n == 0 then 1 else (*)n  (rec (\f -> \n -> if n == 0 then 1 else (*)n  (f(n-1))))(n-1)) 3
18:10:28 <GyroW> (if n == 0 then 1 else (*)3  (rec (\f -> \n -> if n == 0 then 1 else (*)n  (f(n-1))))(3-1))
18:10:30 <GyroW> (if n == 0 then 1 else (*)3  (rec (\f -> \n -> if n == 0 then 1 else (*)n  (f(n-1)))) 2)
18:10:32 <GyroW> y
18:10:34 <GyroW> is that correct?
18:11:02 <monochrom> Why am I seeing "n==0" not "3==0"?
18:11:12 <Axman6> It's very close :)
18:11:30 <GyroW> Oh right
18:11:45 <GyroW> and there's something wrong with the brackets but I starting at it blindly
18:12:08 <TheCommieDuck> ...okay, looking back - I have more than 3 instances in a non-MWE. I have laws for my classes (they always produce a subset of the type). I can roll getX into a where clause. Even so, feels like a lot of boilerplate or bad code design.
18:12:31 <GyroW> (if 3 == 0 then 1 else (*)3  (rec (\f -> \n -> if n == 0 then 1 else (*)n  (f(n-1))) 2))
18:13:48 <GyroW2> Great when you think you finally got it you get banned for spam...
18:14:01 <maerwald> Then don't spam :)
18:14:04 <GyroW2> (if 3 == 0 then 1 else (*)3  (rec (\f -> \n -> if n == 0 then 1 else (*)n  (f(n-1))) 2))
18:14:04 <Axman6> haha
18:14:10 <maerwald> some people don't learn...
18:14:24 <monochrom> Hrm how is that classified as spam?
18:14:32 <maerwald> probably 50 lines of code?
18:14:35 <Axman6> oh dear, poor GryoW
18:14:35 <monochrom> But they should use a paste bin.
18:14:46 <f-a_> it started when there was that spam attack on freenod
18:14:47 <heatsink> Maybe because it's almost the same text repeatedly
18:14:48 <f-a_> +e
18:14:51 <TheCommieDuck> (since every function is going to be of form x :: IsSomeInstance a => a -> b, x = getX . toSomeInstance where getX (<pattern match on someinstance>).
18:14:55 <monochrom> Oh! Yeah.
18:15:00 <f-a_> and yup, repeated text
18:15:20 <monochrom> OK how do I tell Sigyn to forgive them?
18:15:30 <f-a_> now let's see if we can unban poor GyroW
18:16:41 <heatsink> You started with an application of "rec".   and you expanded it to a new expression.  The new expression has a very similar application of "rec".
18:17:02 <GyroW> Am I alive?
18:17:17 <heatsink> It's useful to convert the two applications of "rec" back to "recfac"
18:17:22 <heatsink> yes
18:17:33 <heatsink> You started with recfac 3
18:17:54 <heatsink> and you got if 3 == 0 then 1 else 3 * recfac 2
18:18:03 <GyroW> I'm scared of pasting anything now but yes
18:18:07 <GyroW> Now I understand
18:18:08 <f-a_> GyroW: try to use a pastebin :P I am checking with #freenode staff
18:18:24 <f-a_> about pasting and misdetected spam
18:18:35 <glguy> I'm looking at it
18:18:44 <GyroW> Ah yeah thanks
18:18:50 --- mode: ChanServ set +o glguy
18:20:02 <Axman6> We have an API at work which uses cloudflare, and we had some requests being blocked because they contained "javascript: x" (for some x). They were job ads looking for javascript developers
18:20:13 <Axman6> I'm not convinced it's a problem if those fail :)
18:20:43 <GyroW> Thanks guys for helping, I think I understand now
18:21:02 <GyroW> the backconversion makes it click heatsink 
18:21:06 <heatsink> great
18:21:13 <PyDon> hi
18:21:36 <GyroW> :-) and uh, are there any repercussions of being tempbanned like that?
18:21:39 <PyDon> can anyone help me? I am not familiar with haskell but this error message is my problem
18:21:42 <Axman6> GyroW: there's a rule which may help you going forward, it's one of the first things we teach in the Data61 course: All functions take exactly one argument. This is _always_ true in Haskell
18:21:43 <PyDon> >> No instance nor default method for class operation mappend
18:22:05 <Axman6> PyDon: can we see the code? paste it somewhere online
18:22:09 <GyroW> Yeah I get that rule, but not always sure how I need to apply it practically
18:22:14 <Axman6> @where paste
18:22:14 <lambdabot> https://gist.github.com
18:22:44 <PyDon> https://github.com/Eelis/cxxdraft-htmlgen/blob/master/LaTeXParser.hs#L31
18:23:14 <PyDon> I already imported the package and changed it to “instance S.Semigroup Macros where”
18:23:36 <Axman6> I think you need to specify mappend = (<>) in the Monoid instance
18:23:50 <GyroW> I probably shouldn't be doing this at 3 am either...
18:24:01 <PyDon> like in that instance in that file?
18:24:15 <PyDon> instance S.Semigroup Macros where 
18:24:16 <PyDon> 	mappend = (<>) 
18:24:26 <PyDon> ‘mappend’ is not a (visible) method of class ‘S.Semigroup’
18:24:27 <Axman6> yeah after instance Monoid Macros where
18:24:33 <Axman6> no
18:24:38 <Axman6> Monoid, not Semigroup
18:25:01 <PyDon> oops, mom
18:25:15 <PyDon> instance Monoid Macros where
18:25:15 <PyDon> 	mappend = (<>) 
18:25:23 <PyDon>     • Variable not in scope: (<>) :: Macros -> Macros -> Macros
18:25:34 <PyDon> it worked! S.<>
18:25:57 <Axman6> uh, whatever you did to make you need to use S.Semigroup instead of Semigroup, undo that :)
18:26:10 <PyDon> wooo!! thanks so much!
18:26:36 <PyDon> So no S.Semigroup?
18:26:50 <Axman6> you shouldn't need it
18:27:00 <Axman6> but without being able to see _your_ code I have no idea
18:27:31 <PyDon> it’s pretty much that file, but my change worked now
18:52:59 <jusss`> anyone is using yesod? about static file, I have a little confused, https://github.com/yesodweb/yesod/wiki/Static-file-subsite-Hello-World      
18:53:13 <jusss`> what this code mean "static@(Static settings) <- static "static""
18:53:42 <jusss`> I don't know about the syntax `static@( )'
18:53:51 <Axman6> it's a pattern match which gives the name static to the result, but also gives the name settings to the value contained inside the Static constructor
18:54:22 <Axman6> > let x@(y,z) = ("Hello",True) in (x,y,z)
18:54:23 <lambdabot>  (("Hello",True),"Hello",True)
18:55:04 <Axman6> https://en.wikibooks.org/wiki/Haskell/Pattern_matching#As-patterns
18:55:05 <jusss`> Axman6: @ is a standard symbol in haskell?
18:55:33 <Axman6> it's the symbol for as-patterns
18:55:44 <Axman6> (and a few other things)
18:55:55 <jusss`> there're so many symbols in haskell I've seen, but @ is new
18:56:38 <jusss`> Axman6: oh, I remember , type application\
18:56:49 <jusss`> Axman6: id @Int 3
18:58:32 <wikiemol> Can't remember who gave me the suggestion of looking at Conal's papers/talks for understanding FRP, but if you are still in the chat, gotta thank you again. Looking into this not only gave me a true understanding of FRP, but also gave me my first real "aha" moment in terms of the beauty and power of functional programming.  
19:12:22 <jusss`> Axman6: "static@(Static settings) <- static "static"" I don't understand the syntax (a) <- y
19:12:38 <jusss`> let's assume static "static" is y
19:13:11 <jusss`> static@(Static settings) should be ?
19:13:27 <jusss`> x@(y,z) is ((y,z), y, z)
19:16:55 <Axman6> jusss`: have you use do blocks before?
19:17:05 <jusss`> Axman6: yeah
19:17:33 <jusss`> m a -> a
19:17:40 <Axman6> well that's just pattern matching on the result of static ("static")
19:17:49 <Axman6> uh, no
19:19:12 * hackage chs-cabal 0.1.1.0 - Cabal with c2hs dependencies  https://hackage.haskell.org/package/chs-cabal-0.1.1.0 (vmchale)
19:19:30 <jusss`> assume `static "static"' has type IO String, so `b <- static "static"', b will has that String
19:19:58 <jusss`> wrong?
19:20:02 <Axman6> I would assume static "static" has type IO Static
19:20:17 <jusss`> ok, then b has Static
19:20:24 <Axman6> assuming the type wqhich defines the constructor Static is called Static
19:21:04 <Axman6> yes
19:21:27 <jusss`> yes
19:22:03 <jusss`> assuming the type Static x
19:22:05 <jusss`> and?
19:22:58 <jusss`> wait a sec, you're assuming that value with a value constructor in the left of <-
19:23:36 <Axman6> in the expression "static@(Static settings) <- static "static", static (on the left of @) has type Static, settings (probably, I'm guessing) has type Settings, and static "static" has tyoe IO Static (probably)
19:23:46 <jellostahps> :i notelem
19:24:02 <dibblego> @type notElem
19:24:03 <jusss`> if static "static" has IO (Static Int), then Static b <- static "static", so b will has Int?
19:24:03 <lambdabot> (Foldable t, Eq a) => a -> t a -> Bool
19:24:13 <jellostahps> :)
19:24:24 <dibblego> b :: Static Int
19:24:50 <Axman6> jellostahps: that depends on how Static defined
19:24:58 <Axman6> uh, jusss`
19:30:12 * hackage arrayfire 0.1.0.0 - Haskell bindings to the ArrayFire general-purpose GPU library  https://hackage.haskell.org/package/arrayfire-0.1.0.0 (DavidJohnson)
19:53:52 <jusss`> Axman6: x(Maybe a) will be?
19:54:44 <jusss`> x@(Maybe a)
19:55:21 <jusss`> Maybe a (Maybe a) ?
19:57:56 <jusss`> :t import Yesod
19:57:57 <lambdabot> error: parse error on input ‘import’
19:58:07 <jusss`> > import Yesod
19:58:08 <Axman6> jusss`: that doesn't make any sense as a pattern mathc, Maybe is a type
19:58:09 <lambdabot>  <hint>:1:1: error: parse error on input ‘import’
19:58:46 <jusss`> if we forget that right part of <-, so `static@(Static settings)' would be ?
19:59:08 <jusss`> % import Yesod
19:59:08 <yahb> jusss`: ; <no location info>: error:; Could not find module `Yesod'; It is not a module in the current program, or in any known package.
19:59:43 <jusss`> static :: FilePath -> IO Static
20:00:00 <jusss`> static "static" :: IO Static
20:00:22 <jusss`> Static :: WaiAppStatic.Types.StaticSettings -> Static
20:00:33 <jusss`> Static settings :: Static
20:01:24 <jusss`> Axman6: the right part <- has IO Static, and the left part should has Static
20:01:32 <Axman6> yes
20:01:37 <jusss`> Static settings has Static
20:01:56 <jusss`> so static@ on a Static means ?
20:02:20 <Axman6> > runIdentity $ do {imTheMaybe@(Just x) <- pure (Just True); pure (imTheMaybe, x) } 
20:02:23 <lambdabot>  error:
20:02:23 <lambdabot>      • No instance for (Control.Monad.Fail.MonadFail Identity)
20:02:23 <lambdabot>          arising from a do statement
20:02:57 <Axman6> >  do {imTheMaybe@(Just x) <- pure (Just True); pure (imTheMaybe, x) }  :: Either String (Maybe Bool, Bool)
20:02:58 <lambdabot>  error:
20:02:58 <lambdabot>      • No instance for (Control.Monad.Fail.MonadFail (Either String))
20:02:58 <lambdabot>          arising from a do statement
20:03:01 <jusss`> wait a sec, Static :: WaiAppStatic.Types.StaticSettings -> Static
20:03:03 <Axman6> oh ffs
20:03:32 <Axman6> yes, Static is a constructor which contains a StaticSettings
20:04:32 <jusss`> Axman6: the value constructor has the same name with the type
20:05:34 <jusss`> data P = P a, but that's not possible, a must show up in the left part
20:06:19 <jusss`> data P a = P a?
20:06:39 <jusss`> no
20:07:15 <Axman6> yes, but data P = P Int is fine, and that's what Static is
20:07:29 <jollygood2> is it possible to see what is new between any two ghc versions, and not just what's new relative to the prior version?
20:07:46 <jusss`> Axman6: wait, but data P = P a is not fine?
20:07:52 <dibblego> TRY IT AND SEE
20:07:59 <jusss`> til a is concret?
20:08:37 <dibblego> no, because a is not a thing in that declaration
20:08:40 <jusss`> yeah, data P = P a is not fine
20:08:42 * dibblego tags Axman6 
20:08:51 <jusss`> only a is defined
20:08:56 <dibblego> did you try it and see?
20:09:00 <jusss`> yeah
20:09:05 <dibblego> what did it report?
20:09:10 <jusss`> not in scope
20:09:15 <dibblego> what wasn't in scope?
20:09:19 <jusss`> a
20:09:26 <dibblego> then that is why
20:12:32 <jusss`> so data Static = Static settings, the right part of <- will return a value like Static settings, and in the left part `static@(Static settings)' this Static settings is already that pattern, what this static@ would do?
20:13:03 <dibblego> did you look up what do-notation does?
20:13:55 <jusss`> dibblego: I don't why you guys always said it's about do-notation , I know what is do-notation
20:14:11 <dibblego> ok, then you know what <- is doing
20:14:17 <jusss`> dibblego: yes
20:14:21 <dibblego> ok great
20:14:24 <dibblego> did you look up as patterns?
20:15:00 <jusss`> dibblego: as-patterns with tuple, list, yes, not this form
20:15:08 <dibblego> which form?
20:15:19 <dibblego> as patterns have only one form
20:15:20 <jusss`> dibblego:  x@(y,z) is ((y,z), y, ) ,right?
20:15:30 <dibblego> No.
20:15:32 <dibblego> did you look up as patterns?
20:15:32 <jusss`> ((y,z),y , z)
20:16:16 <jusss`> dibblego: yeah, I look up,  but I don't totally understand what it said on the page, "bind a name to the whole value"
20:16:29 <dibblego> which part of that did you not understand?
20:16:52 <Axman6> > let everything@(h:t) = "Hello" in (everything, h, t)
20:16:54 <lambdabot>  ("Hello",'H',"ello")
20:17:18 <jusss`> Axman6: this is about list, 
20:17:28 <jusss`> Axman6: what about constructor?
20:17:42 <dibblego> I did not see the word list there
20:17:44 <jusss`> dibblego: use @ on value constructor
20:17:49 <dibblego> I saw a constructor
20:17:49 <Axman6> (:) is a constructor
20:18:06 <Axman6> > let everything@(Just x) = Just True in (everything, x)
20:18:08 <lambdabot>  (Just True,True)
20:18:29 <dibblego> jusss`: "bind a name to the whole value" does not contain the phrase "use @ on value constructor"
20:18:30 <Axman6> everything is just a name for the whole expression bein pattern matched
20:21:05 <jusss`> static@(Static settings) = Static s
20:21:18 <Axman6> > case Right True of theRight@(Right b) -> (b, theRight); theLeftWhenFalse@(Left c@False) -> (c, theLeftWhenFalse); theLeftOtherwise@(Left d) -> (d, theLeftOtherwise)
20:21:20 <lambdabot>  (True,Right True)
20:21:27 <dibblego> which part of as-patterns did you not understand?
20:23:12 <jusss`> dibblego: `static@(Static settings) <- static "static"'  , static "static" :: IO Static, and data Static = Static Settings, so static@(Static settings) :: Static, which means `static@(Static settings)' has the value form `Static s', right?
20:23:56 <dibblego> No.
20:24:06 <dibblego> did you look up as patterns?
20:26:58 <Axman6> jusss`: in theStatic@(Static settings) <- static "static", theStatic is just a name for the value returned by static "static". and settings is the name of the value inside that Static of type StaticSettings
20:27:22 <dibblego> specifically, it binds a name to the whole value
20:27:25 <jle`> @let example xs@(y:ys) = (xs, y, ys)
20:27:26 <lambdabot>  Defined.
20:27:29 <jle`> > example [1,2,3]
20:27:31 <lambdabot>  ([1,2,3],1,[2,3])
20:29:18 <nshepperd2> ghc doesn't believe in my injectivity annotation :( https://zlkj.in:9000/uploads/7e33a0202fba05f3/paste.hs
20:29:55 <jle`> trust takes time to build
20:30:21 <Axman6> particularly if it's written in haskell, amirite?
20:30:56 <jle`> heh heh
20:31:09 <nshepperd2> "trust" is just a fancy word for a ghc type checker plugin
20:31:30 <jle`> nshepperd2: maybe it's not taking advantage of the kind of xs
20:31:49 <jle`> nshepperd2: try taking k as an explicit parameter
20:32:18 <jle`> (just for debugging)
20:34:47 <nshepperd2> that didn't seem to help
20:35:31 <nshepperd2> i think the issue is that it can't prove that xs |> y is apart from '[]
20:35:40 <nshepperd2> even though it's obvious
20:48:57 <jle`> i think that part it can do at least...i feel like it's done it before
21:31:20 <b_and_w> HI. 1. are there any specific resources someone can point me to, to learn the difference between roff, troff, groff, and nroff?   2. also, are there any utilities that ship with debian (or linux in general) which can convert either .txt and/or .html files into man/roff/troff/groff/nroff/whatever-it's-called format (iow, the format used by man pages)?
21:31:31 <b_and_w> and if not, then what would be the best utility for me to install?
21:31:38 <Axman6> b_and_w: what does this have to do with Haskell?
21:32:19 <Axman6> If you want to convert documents, pandoc is the best place place to start, even if this is the wrong channel to be asking in :)
21:33:11 <Axman6> (pandoc happens to be written in Haskell, but that's not something you need to worry about if you're just trying to convert documents between formats)
21:33:42 * hackage profunctor-optics 0.0.0.1 - Profunctor optics  https://hackage.haskell.org/package/profunctor-optics-0.0.0.1 (cmk)
21:33:44 <b_and_w> Axman6: im looking for the smallest tool for the job. i was hoping there would be a GNU coreutil or some bash built in command or something.
21:34:03 <jusss`> Axman6: now I understand "bind the whole value to a name", but TheStatic@(Static settings) <- static "static" missing an expression?
21:34:22 <jusss`> everyting@(Just x) = Just True in (everything, x)
21:34:36 <jusss`> it missing (everything, x)
21:34:59 <Axman6> that's just showing you what those names become
21:35:01 <jle`> it depends on if you are in do notation, or a normal let .. in ..
21:35:05 <jle`> the specifics, at least
21:35:18 <jle`> but @ is a part of pattern syntax in general. you can use it wherever you would normally use a pattern
21:35:27 <Axman6> case Just True of everything@(Just b) -> (b, everything)
21:35:33 <jle`> so, in do notation binds, do notation lets,, let ... in ..., case expressions, etc.
21:35:35 <Axman6> > case Just True of everything@(Just b) -> (b, everything)
21:35:37 <lambdabot>  (True,Just True)
21:36:05 <Axman6> b_and_w: well in that case this is the wrong channel
21:36:08 <jusss`> Axman6: yeah, but this has (b,everything)
21:36:10 <jle`> also function declaration syntax, lambda syntax, etc.
21:36:35 <Axman6> > case Just True of everything@(Just b) -> b -- I'm ignoring everything, but is it the name given to the value matched
21:36:38 <lambdabot>  True
21:36:59 <jle`> > do xs@(y:ys) <- Just [1,2,3]; pure (xs,y,ys)
21:37:01 <lambdabot>  Just ([1,2,3],1,[2,3])
21:37:02 <b_and_w> Axman6: ok
21:37:19 <jusss`> oh I see
21:37:25 <jle`> that's the same as
21:37:29 <jusss`> they did xs bind
21:37:34 <jle`> > do y:ys <- Just [1,2,3]; pure (y:ys,y,ys)
21:37:36 <lambdabot>  Just ([1,2,3],1,[2,3])
21:37:42 <jusss`> they bind the whole value to xs
21:37:51 <jle`> yup
21:38:04 <jle`> in general the syntax is [pattern] <- [expression]
21:38:08 <jle`> if you are in do notation
21:38:17 <jle`> the pattern dictates what bindings/names are created
21:38:33 <jusss`> but what's the meaning `static@(Static settings) <- static "static"'?   it is same as `static <- static "static"'  
21:38:36 <jle`> the neat thing is that the same pattern syntax is used in all those different contexts, consistently
21:38:47 <sarahzrf> jle`: are you sure that's the same
21:38:51 * sarahzrf tests something
21:39:02 <jusss`> it just did a match if it is the result match (Static settings)
21:39:09 <jle`> jusss`: yes (if we fix the names so there isn't shadowing), but also we bind "settings"
21:39:27 <jle`> x@(Static y) <- static "static"
21:39:28 <sarahzrf> oh wait nvm
21:39:43 <sarahzrf> i was gonna complain that you were doing some sort of eta expansion
21:39:46 <jle`> jusss`: it has the same semantics as x <- static "static", matching-wise
21:39:52 <sarahzrf> but my thought about why that might be invalid didnt make sense
21:39:54 <jle`> jusss`: only in the case of x@(Static y), you can now use 'y' later on
21:39:54 <sarahzrf> idk
21:40:04 <jle`> in x <- static "static"...you have no 'y' to play with
21:40:34 <jle`> hm, i suppose they have different matching semantics
21:40:43 <jle`> so they are different semantically, but the same syntactically
21:40:58 <sarahzrf> how are they the same syntactically o.O
21:41:09 <jle`> [pattern] <- [expression]
21:41:16 <jle`> heh, i guess this is a loose usage of 'same'
21:42:53 <jusss`> it takes two bindings
21:44:16 <jle`> not sure what you mean by 'takes' here
21:44:20 <jle`> but it's just different ways of making bindings
21:44:27 <jle`> if you want to bind y, then bind it.  otherwise, don't
21:46:11 <jusss> TheStatic@(Static settings) <- static “static”.    one binding TheStatic has the result static “static”, and another binding is that settings bind the value inside the result
21:46:36 <jusss> that’s two bindings
21:47:16 <jle`> yeah. except TheStatic isn't a valid identifier
21:47:19 <jle`> since it is upper cased
21:47:56 <jusss> yeah, it’s static@(Static settings)
21:48:03 <jle`> but theStatic@(Static settings) <- static "static", yeah.
21:48:07 <nshepperd> https://mpickering.github.io/ghc-docs/build-html/users_guide/glasgow_exts.html#verifying-injectivity-annotation-against-type-family-equations 'Note that for the purpose of injectivity check in bullets (4) and (5) GHC uses a special variant of unification algorithm that treats type family applications as possibly unifying with anything.' :(
21:48:16 <jle`> :'(
21:48:52 <nshepperd> so yeah, it can't know that the recursive call is apart from '[]
21:49:32 <nshepperd> I guess I'll just simulate injectivity with the type checker plugin
21:50:14 <jusss> jle` did you use yesod?
21:50:45 <jusss> I'm learning yesod, it’s a little weird to others
21:50:55 <nshepperd> maybe this is a good argument for adding some kind of {-# unsafe_injective #-} pragma though
21:51:42 * hackage doctest-driver-gen 0.3.0.2 - Generate driver file for doctest's cabal integration  https://hackage.haskell.org/package/doctest-driver-gen-0.3.0.2 (Hexirp)
21:51:50 <jle`> jusss: i do not use yesod no
21:55:20 <jle`> i actually don't know if people are still making new projects in yesod these days
21:56:07 <jusss> what is people working on?
21:56:54 <jusss> I know there’re yesod, servant, wai, blablablah
21:57:03 <jusss> and scotty
21:58:05 <Axman6> I use Servant for all web services, but it's no the batteries included solution that yesod is
21:58:44 <jusss> sorry, what “batteries” means here?
21:58:45 <Axman6> not*
21:58:57 <jusss> my bad English
22:02:26 <Axman6> "batteries included" means it comes with everything you need, it provides logging, database connections, templating etc. servant doesn't provide anything like that, you have to do it all for your self
22:04:49 <jusss> ok
22:09:15 <jusss> “/static StaticR Static getStatic” this means if visit the /static with Static will run StaticR, but Static is not a HTTP method like Get Post Delete, also what getStatic means here?
22:09:55 <jusss> there should be getStaticR
22:10:04 <Axman6> you should probably read the yesod book
22:10:14 <jusss> ok
22:10:58 <jusss> thanks for your help
22:17:40 * edwardk just spent the day using redis. i need brain bleach.
22:34:54 * jackdk is trying to CPP himself out of a hole to give monoidal-containers more instances
23:04:02 <koz_> edwardk: I am so sorry.
23:06:05 <MarcelineVQ> koz_: so you're to blame!
23:06:17 <koz_> MarcelineVQ: It was a commiserative sorry, not an apologetic one.
23:06:20 <koz_> I certainly didn
23:06:23 <koz_> t make Redis.
23:06:30 <koz_> (and thank Nyarlathotep)
23:06:54 <MarcelineVQ> or did you
23:35:12 <Zer000> I have a weird case where this function http://dpaste.com/0KMNFYW.txt is infinitely looping. The recv network call returns a zero length byte string which I thought was not supposed to happen. When can recv return an empty bytestring?
23:36:38 <opqdonut> the docs say
23:36:41 <opqdonut> "For TCP sockets, a zero length return value means the peer has closed its half side of the connection.
23:36:45 <opqdonut> "
23:37:42 <Zer000> do they really, I must have missed that
23:38:09 <Zer000> thanks!
23:38:17 <Zer000> so I don't have to retry
23:39:59 <Zer000> I spent an embarassing amount of time debugging that :(
23:52:43 <dminuoso> If only GHC allowed for circular imports... :(
23:53:01 <f-a> dminuoso: if you feel brave http://ariis.it/static/articles/haskell-circular-imports/page.html
23:53:57 <dminuoso> f-a: gross. :<
23:54:24 <f-a> very.
