00:06:00 <jle`> glguy: decided to use the api to help me practice my servant :)
00:09:27 <jle`> servant-api that is
00:14:12 * hackage prettyprinter 1.5.0 - A modern, easy to use, well-documented, extensible pretty-printer.  https://hackage.haskell.org/package/prettyprinter-1.5.0 (quchen)
00:17:59 <trcc> I've been doing haskell/elm/scala for the last couple of months. Now I am back to java and dealing with all the functionality I need being in private functions :(
00:18:06 <jle`> :(
00:18:38 <dminuoso> trcc: And you came here, asking how to implement the Y-combinator in Java to recover pure functional programming with recursion?
00:19:43 <dminuoso> See, you could just implement lambda calculus in Java, lets call it Jambda,, and then write an STG-to-Jambda compiler. Then you can keep writing in Haskell and deliver Java code.
00:19:45 <trcc> haha no, although it sounds interesting. So to let off some stream. I am in charge of rebuilding our solution from scratch, so I will do much more pure functinoal programming :)
00:19:59 <trcc> But we have to complete this last task first
00:20:03 <trcc> with the old solution
00:22:44 <Ariakenom> may The Lambda bless you in this trial
00:23:02 <trcc> hehe thanks
00:39:00 <dibblego> trcc: http://functionaljava.org
00:39:26 <trcc> dibblego how is the performance of this?
00:39:45 <dminuoso> trcc: The problem is not performance but your sanity.
00:39:53 <dibblego> trcc: some of it is good, some is not. Other people maintain it these days and work on performance
00:40:17 <dibblego> It was initially a hypothesis, "to what extent can we FP in Java?"
00:40:37 <dminuoso> I've spent a year trying to use functional idioms in JavaScript. Without a specially tailored type system (higher kinded types) and a good toolbag its more annoying than worth it, to try functional idioms in Java.
00:41:11 <dibblego> I have also done JavaScript, which is much harder
00:41:24 <trcc> dibblego: what was your conclusion? Although to what extent is difficult to conclude on in brief :)
00:41:31 <trcc> and java has changed quite a lot since i take it
00:41:55 <dibblego> trcc: much more so than we initially thought. It is also helped wean a lot of people off Java. This was was early 2000s.
00:42:09 <trcc> pretty cool
00:42:22 <trcc> well we are going scala in the future
00:42:23 <dibblego> Not really, we did Java closures before they were cool :) see http://javac.info
00:42:49 <dibblego> Yes, but using "Scala" was once a prison sentence, so now weaning required
00:43:00 <dibblego> s/now/more
00:43:29 <dibblego> If you can improve without the external burdens often associated with it, then just do it
00:44:33 <dibblego> There are some sub-experiments like, someone once said, "you can't do typed message actors" so we said, can too, even in Java
00:45:16 <dibblego> Or, "ya can't do HList in Java", so...
00:45:40 <tdammers> I think the first question to answer before embarking on this is "*which* FP"
00:45:44 <trcc> So was this on your spare time or part of something?
00:45:54 <dibblego> There is only one FP, so that one
00:46:03 <trcc> I agree. There are a couple of reasons why we are going with scala/java and not something like functional java/haskell/eta/whatever. The main one is that we hope to get a lot of interest from the community, and the community consists of people who has done software development, but not necessarily can be considered software developers. So we do not want to invest to much into "difficult" frameworks
00:46:17 <trcc> too*
00:46:29 <tdammers> I agree, just like I agree on the fact that there are exactly three Star Wars movies, but a large crowd out there seems not to
00:46:38 <dibblego> trcc: bit of both at the time, my full time job for about six months was, "yeah the CTO how to use Haskell", early 2000s. We started at Java
00:47:08 <trcc> sorry, yeah? 
00:47:15 <trcc> learn?
00:47:17 <dibblego> I am not concerned with large crowds of wrong people
00:47:30 <dibblego> Sorry, s/yeah/teach
00:47:32 <trcc> ahh
00:47:42 <trcc> hehe tdammers ye
00:47:51 * tdammers coughs in clojure
00:48:12 <trcc> dibblego: unfortunately that is not always the case
00:48:23 <dibblego> What is not always the case?
00:48:34 <trcc> that you can be unconcerned with large crowds of wrong people
00:48:58 <dibblego> There are techniques to deal with them, sure.
00:49:01 <int-e> tdammers: Are you still waiting for the sequels to the Matrix movie as well?
00:49:33 <int-e> (see also https://www.xkcd.com/566/ )
00:49:40 <dibblego> I should say, "minimise concern" against other factors
00:50:09 <trcc> definitely. And we will try to do that but making a plugin section and keeping the core to ourselves
00:50:14 <trcc> by
00:50:21 <tdammers> int-e: no, the number of matrix movies worth watching is approximately 0.7
00:50:31 <tdammers> I have no hopes for any sequels
00:50:49 <dibblego> I beat that particular hurdle by knowing Java at least as well as the opponents in any disagreement
00:51:36 <int-e> tdammers: harsh
00:51:55 <tdammers> int-e: harsh, but true. the battery thing completely ruins it for me.
00:52:51 <kosmikus> tdammers: isn't it then more like 0.3?
00:53:13 <tdammers> there's some cool visuals after the battery explanation
00:53:34 <kosmikus> true. there are some cool visuals even in reloaded (less so in revolutions, imho).
00:53:35 <tdammers> the story is dead at that point, but it's still fun to watch those silly slo-mo gunfights and stuff
00:55:05 <kosmikus> I always feel like the matrix trilogy was in desperate need of a second twist, but it never happened.
00:56:23 <tdammers> oh, also, protip: star wars is much more interesting to watch if you approach it as the story of a young man who, after his parents become the victims of excessive police violence, radicalizes, joins a terrorist organization, and becomes a mass murderer and helps assassinate the democratically elected head of state
00:59:55 <MarcelineVQ> the animatrix is wizard tho
01:00:01 <dminuoso> tdammers: The sad thing is, it could have been fixed easily. Say humans need to be harvested for some proteins - or maybe the brains run the neural networks for machines. It would have been tons more believable.
01:00:22 <dminuoso> But the battery thing is like the dumbest idea of them all
01:01:18 <MarcelineVQ> tbf it's morpheus that says all that, he might just be wrong. I mean the line about batteries also has the line "combined with a form of fusion" stuffed into it, so there's more going on we're not aware of
01:03:53 <tdammers> dminuoso: yes, the original idea was that the matrix was a distributed supercomputer, using humans as computation nodes, but the producers felt that this would be too complicated for the audience, and asked the script writers to change it
01:04:05 <tdammers> worst micromanagement ever
01:04:57 <MarcelineVQ> For my money the matrix is about keeping a zoo more than powering anything. As far as where the story went I kind of wanted zion (and by extention 'the real world') to be another matrix, so that it's a failsafe device to trick people into not looking to escape once they've escaped. And would explain neo's ability to see that glowing machine shit in the real world at the end despite being blind.
01:05:37 <tdammers> it's kind of weird that there's an escape at all
01:06:19 <tdammers> the machines essentially have full control of their victims' bodies, it would be trivial to add a kill switch
01:06:24 <MarcelineVQ> Well maybe you can shake it off, so the escape is to make people stop trying to do so. And 'the one' could be the singular person who's _really_ escaped
01:07:05 <tdammers> haha, can you imagine being "the one", escaping, just to find that you are completely alone and absolutely powerless, and that the only thing to do is survive as best you can and then die as the last human standing
01:07:33 <MarcelineVQ> I would have prefferred that ending :.
01:07:50 <merijn> tdammers: You do realise that's literally one of the Animatrix stories? :)
01:07:53 <MarcelineVQ> At least the nonsense would make sense, in that it really was nonsense
01:08:06 <tdammers> merijn: nope, never watched any of that
01:08:16 <merijn> tdammers: You should, the Animatrix is *really* good
01:08:17 <MarcelineVQ> tdammers: you're missing out
01:08:17 <tdammers> MarcelineVQ: I love imagining better endings to popular movies
01:08:24 <MarcelineVQ> the animatrix is incredible
01:08:24 <tdammers> oh, OK, will watch then
01:08:37 <merijn> tdammers: It's not really a sequel/ending to the matrix, tbh
01:08:57 <merijn> tdammers: It's basically "we asked 9 famous anime directors in Japan to come up with a short story set in/around the matrix"
01:09:01 <MarcelineVQ> It's just some very imaginative stories in that world. With a bit of world-building as a side-effect
01:13:32 <dminuoso> MarcelineVQ: Regarding your "neos ability to see [..] despite being blind" - I guess Matrix also suffers from the heavy religious notions bolted into the movie.
01:14:37 <tdammers> does it suffer from it, or are those more like stabs at established religions?
01:14:42 * hackage prettyprinter 1.5.1 - A modern, easy to use, well-documented, extensible pretty-printer.  https://hackage.haskell.org/package/prettyprinter-1.5.1 (quchen)
01:18:26 <MarcelineVQ> tdammers: suffers I'd agree, it's not that clever, matrix1 is a fluke but a really fun one.  What follows (the other films) is a child telling a story of "and then... and then.. and then..."
01:20:06 <tdammers> idk, you have this scene where there's this kid who can bend spoons with his mind
01:20:29 <tdammers> I think it's funny how they're all so stoked about it, but of course that's only possible because they're in a fake reality
01:21:08 <MarcelineVQ> Which they?
01:21:15 <tdammers> the humans in the matrxi
01:22:33 <MarcelineVQ> Which ones though? Regular people didn't know about that stuff and the kids didn't seem to care too much, even neo just thought it was weird at first seeing of it, is the they you mean the crew?
01:22:51 <tdammers> no, I mean the religious nuts around that kid
01:23:38 <merijn> I think we can conclude the Matrix is like an onion, it has layers... >.>
01:23:46 <MarcelineVQ> hmm, I'm gonna have to find the scene you mean, I don't know what religious nuts you are talking about
01:25:05 <MarcelineVQ> man this spoon did not age well
01:27:55 <MarcelineVQ> Do you know where this scene is in the film you're thinking of? there's no one else around when neo and the kid are being spoony.   oh my god... the tv has night of the lepus playing on it
01:29:59 <tdammers> it's been 20 years or so, but IIRC, there's a scene where they meet this fortune teller like lady who runs a center for weird kids in her kitchen or sth
01:32:07 <MarcelineVQ> Yes the Oracle. appearantly I don't have a copy of the matrix kicking around so I can't see what happens after the spoon scene but nothing happens before it other than a couple close-ups of different kids. iirc neo has a cookie and we're done with the kids after that
01:32:43 <fweht> i just wonder, is there something like turing completeness but for types, like specification completeness, that your type system is so strong that you can specify any specifyable algorithm or something like this?
01:33:14 <merijn> fweht: Simple solution: Just make your type system Turing complete, done.
01:33:24 <fweht> merijn: ok!
01:33:28 <merijn> Of course now you have undecidably many other problems :)
01:33:54 <tdammers> "you had a problem. you decided to use a turing-complete language to solve it. now you have undecidably many problems." :D
01:34:06 <fweht> merijn: where can i read into this?  incompleteness theorems for type theories or something like that?
01:35:48 <tdammers> fweht: it's not anything special really. a type system is a formal system, a type written in it is an expression of some hypothesis, and type checking is the act of formally proving the hypothesis from the type system's axioms and rules
01:36:19 <dminuoso> Prositions as types, programs as proofs.
01:37:10 <tdammers> alternatively, you could consider your type system a programming language in its own right; "programs" written in it are "executed" by performing type checking
01:37:14 <fweht> tdammers: sure, its just that i learned about the incompleteness theorems in FOL and i dont have a good intuition on how to apply them to other formal systems.  but i guess that lawvere paper might help, ive been to it once but not with type theory in mind
01:37:37 <ggVGc> tdammers: I often wonder why we even have different syntaxes for types and runtime code in languages
01:37:46 <tdammers> ggVGc: hysterical raisins
01:37:47 <ggVGc> rather than just two passes in the same language, where types are values in the first pass
01:38:02 <tdammers> some languages actually use the same language for both
01:38:18 <ggVGc> I think I saw one a long time ago, but it was someone's experiment
01:38:22 <ggVGc> got any example?
01:38:29 <tdammers> dependently typed languages would be one
01:38:49 <tdammers> the other example would be type checkers written in a lisp-style homoiconic language
01:39:00 <tdammers> people have actually done that
01:39:34 <tdammers> basically you have (defn type-check [expr]), which returns some value indicating whether the expr you gave it type-checks
01:39:53 <tdammers> and then you provide a bunch of macros to improve ergonomics
01:40:46 <tdammers> fweht: as far as intuitions go, I think it's best to stop thinking in terms of termination and operational semantics for a moment, and instead use the notion of "decidability"
01:41:11 <tdammers> fweht: "turing-complete" means that the language can express propositions for which it is impossible to formally decide whether they hold or not
01:41:59 <fweht> tdammers: ill try to let sink that in
01:42:57 <tdammers> fweht: in a typical programming language, this manifests as nontermination: the offending "proposition" there is a program that should return some value (a boolean, in the textbook examples), but it isn't guaranteed to give us an answer; and "not giving an answer" can manifest as just running forever, or as crashing somehow
01:44:13 <tdammers> fweht: in a type system, we also have propositions, in the form of types; and the act of deciding is called type checking. a type check can be thought of as a program that says "this is well-typed" or "this is ill-typed", i.e., accept or reject the program. But in a turing-complete type checker, the type checking may not yield an answer for all types, i.e., some types (propositions) are undecidable
01:44:18 <fweht> tdammers: ok, but turing completeness is more than just expressing propositions which are not formally decidable, it could express some of those but not enough to be turing complete, or am i wrong?
01:44:48 <tdammers> TC is a particular kind of undecidability, just viewed from a different angle
01:45:28 <tdammers> this is an important takeaway from the church-turing thesis
01:47:03 <fweht> ok...  so a turing complete type system is one where arbitrary programs (resulting in a boolean) can be encoded in types and the type-checking gives the result of executing the program
01:47:06 <fweht> that makes sense to me
01:47:31 <fweht> and i guess the translation of those programs should be primitive recursive or something like that
01:47:44 <tdammers> informally, "turing complete" means that you can create unbounded loops or unbounded recursion
01:48:07 <tdammers> in the case of a type system, this means there needs to be a way to make unboundedly recursive types
01:49:07 <Maxdamantus> It at least means that the type system might go into an infinite loop when you ask whether a program typchecks.
01:49:24 <fweht> ok!
01:51:57 <Maxdamantus> it doesn't need a way to make recursive types, just as turing-complete programming languages don't need ways to make recursive datastructures.
01:52:25 <Maxdamantus> (you can model recursion in TC systems in other ways)
01:52:52 <fweht> i see
01:54:42 <fweht> but i still dont see the connection to specifiability...  if i have a first-order defineable relation R, what does the type system need to satisfy so that i can write in the type that a function f always satisfies R(x,f(x)) with static type checking?
01:55:55 <fweht> oops, this is an ill-termed question, of course the type system could contain only empty types so that the requirenment is trivially satisfied
01:57:53 <Maxdamantus> fweht: it depends on the relation. The point with TC is that it allows you to do any computation, thus perform any proof, but being able to express "any computation" means that you're allowed to express computations with infinite loops.
01:58:58 <Maxdamantus> fweht: languages like Coq, Agda and Idris have fairly advanced type systems that are able to be used to prove many useful things, but since their type systems are all not TC, there are always going to be things they can't prove.
02:01:12 <Maxdamantus> I think Gödel's incompleteness theorems might also be relevant, but I'm not particularly familiar with that.
02:01:59 <fweht> Maxdamantus: i see, but things like that a sorting algorithm is indeed a sorting algorithm, i can specify without running into undecidabilities, right?
02:03:08 <fweht> but no, i can only specify that there exists an intuitionistic proof for it to be a sorting algorith, that seems relevant
02:03:20 <Maxdamantus> fweht: generally, yes, you should be able to prove sorting implementations as being correct in something like Idris, though of course it will always depend on the actual sorting implementation.
02:03:53 <fweht> hm ok, thanks for all your input, food for thought
02:04:11 <Maxdamantus> consider what happens if the sorting implementation does something silly like relying on termination of a Collatz sequence.
02:05:01 <Maxdamantus> since we don't have a proof for termination of every Collatz sequence, we don't really know how to prove that such a sorting algorithm terminates either.
02:05:44 <fweht> Maxdamantus: yes exactly, so the type doesnt express 'this is a sorting algorithm' but 'this is a function f of type a -> Ord a -> [a] -> [a] *together* with an intuitionistic proof that f is a sorting algorithm'
02:07:46 <Maxdamantus> fweht: the proof would have a type that looks something like `(l: List) -> (IsOrdered (sort l), HasSameElements (sort l))`
02:08:33 <Maxdamantus> where `IsOrdered l` is the type of a proof that `l` is ordered, etc
02:09:44 <Maxdamantus> so it should be impossible to come up with a value (proof) of type `IsOrdered [5, 8, 1]`, but it might be possible to come up with a value of type `IsOrdered [1, 5, 8]`
02:10:03 <fweht> Maxdamantus: yes...  this was the mistake i made, one cannot specify some logical relation in the type system, but only some proof type which captures a subset of the actual logical relation
02:10:30 <fweht> like you said, there are sorting algorithms for which no intuitionistic proofs of correctness exists
02:10:58 <Maxdamantus> Indeed.
02:18:28 <tdammers> Gödel is relevant, yes. The First Incompleteness Theorem states that no effective formal system can prove all truths about the arithemtic of natural numbers; the Second Incompleteness Theorem then proceeds to show that this also means that no such formal system can "prove itself"
02:19:41 <ggVGc> got any example?
02:19:56 <ggVGc> oh, sorry :( irc usage failure
02:21:33 <Rembane> tdammers: Does that mean that I need two systems to prove one system? 
02:24:57 <merijn> Rembane: It means you need a more powerful system to fully prove a weaker one
02:26:03 <Rembane> merijn: Got it. 
02:26:58 <merijn> Rembane: Note that Turing machines/Turing completeness is undecidable *with a Turing machine*
02:27:49 <Rembane> merijn: That's fun, is there anything more powerful than a Turing machine out there? 
02:28:45 <Taneb> Rembane: nothing particularly sensible
02:29:08 <infinisil> I guess a quantum computer?
02:29:44 <Taneb> infinisil: are not any more computationally powerful than a turing machine, just possibly more efficient
02:30:08 <infinisil> Hm I guess
02:30:12 <Rembane> Taneb: I think I understand why the Incompleteness Theorem makes everything so interesting now. Thank you all! 
02:31:21 <tdammers> you can't prove one turing-complete with another turing-complete system due to the fact that all turing-complete systems are equivalent (as in, each of them can be expressed in terms of any of them)
02:31:47 <tdammers> AFAIK, no model of computation or calculus has been found so far that is more powerful than turing-complete systems
02:31:49 <merijn> Rembane: You have things like Oracle Machines
02:32:30 <Rembane> merijn: Do they only work in Deplhi?
02:32:49 <tdammers> merijn: nobody has built any of those yet though have they ;)
02:32:59 <Taneb> tdammers: to be fair, nobody's built a turing machine either
02:34:26 <tdammers> Taneb: ah yes, that pesky requirement of an infinitely large storage tape
02:34:51 <tdammers> Taneb: although some people argue that the internet is effectively a practical turing machine, because its storage capacity grows faster than any computation might fill it
02:35:06 <tdammers> (personally I'm not buying that)
02:35:12 <MarcelineVQ> not any, surely
02:35:21 <Taneb> Turing machines need a little magic to make
02:35:24 <tdammers> any practically implementable one
02:35:26 <Taneb> Oracle machines need a LOT of magic to make
02:36:14 <tdammers> with turing machines, we can, in many cases, be content with "practical infinity" (i.e., large enough to run into limitations like the age or the size of the universe before terminating)
02:36:34 <Taneb> (and I think oracle machines still have some things not being decidable)
02:37:41 <fweht> i think some research suggests you could build oracle machines around the edge of a black hole or something
02:37:52 <fweht> its called hyper turing computation
02:39:06 <fweht> for a turing machine you need to be just able to count far enough, for a hyper turing machine you definitely need to count until omega
02:39:11 <Taneb> fweht: I think some people at my uni were researching that kind of thing
02:53:31 <Maxdamantus> er, noticed a mistake
02:53:31 <Maxdamantus> 23:07:23 < Maxdamantus> fweht: the proof would have a type that looks something like `(l: List) -> (IsOrdered (sort l), HasSameElements (sort l))`
02:53:43 <Maxdamantus> Should have said `(l: List) -> (IsOrdered (sort l), HasSameElements l (sort l))`
02:54:00 <fweht> Maxdamantus: ah, i see!
02:54:47 <Maxdamantus> So `HasSameElements [5, 8, 1] [1, 5, 8]` might have an instance, but `HasSameElements [5, 8, 1] [5]` doesn't.
02:55:06 <jpcooper> Hello. I am trying to link a static library I have created to my Haskell programme in a way similar to http://www.the-efficient-programmer.com/programming/link-c-lib-in-haskell.html. For some reason, cabal is not seeing my static libname.o file, where I have set 'extra-libraries: name'. On the mentioned page, the writer creates .a archive files from his static objects. I am not convinced that this should be needed, and I'm guessing that
02:55:06 <jpcooper> the problem lies somewhere else. Does anyone have any suggestions?
02:58:13 <jpcooper> Maybe I'm wrong. The documentation for extra-bundled-libraries mentions .a files
03:13:36 <Drufts> Hi guys i have a question to recursive function.
03:13:41 <Drufts> argMax :: (Integer -> Integer) -> Integer -> Integer
03:14:23 <Drufts> does argMax _ 0 means it should be 0 if (Integer -> Integer) is empty or the n == 0?
03:15:40 <f-a> no Drufts 
03:15:42 <f-a> n == 0
03:15:44 <Taneb> Drufts: "argMax _ 0 = ..." is a case of argMax which is called then the second argument is 0
03:15:50 <Taneb> *when
03:15:53 <f-a> _ in a pattern match: "does not matter"
03:16:21 <Drufts> ahh so if the value should be ignored i type _?
03:16:28 <Taneb> Yeah
03:16:29 <Drufts> Thanks guys
03:17:30 <Drufts> so the | otherwise = 0 will never be called? because i have already _ 0 ?
03:18:11 <Taneb> Where is the | otherwise
03:18:12 <Taneb> ?
03:18:24 <Drufts> argMax g n
03:18:43 <Taneb> argMax takes two inputs, a function and a number
03:18:53 <Drufts> but i have argMax _ 0 = 0 before the otherwise
03:19:24 <Taneb> What do you have between that line and the otherwise?
03:19:42 <Drufts> this is the whole function
03:19:44 <Drufts> argMax :: (Integer -> Integer) -> Integer -> Integer
03:26:21 <dibblego> that's a type
03:30:26 <dminuoso> Drufts: Pattern matching happens: From top to bottom, from left to right. 
03:31:41 <Taneb> dminuoso: is the left-to-right observable?
03:33:46 <[exa]> Taneb: it allows you to guess what thunks will be forced first
03:33:59 <dminuoso> Taneb: Yes.
03:36:36 <dminuoso> Taneb: I cant recall specific examples, but I recall several rather convincing examples from SPJs talk in London.
03:36:48 <dminuoso> *but I remember that he named several convining ones..
03:38:21 <dminuoso> Taneb: Think of `t False () = False; t True _ = True` with `t False undefined`
03:38:44 <dminuoso> Err `t True undefined` of course.
03:38:47 <dminuoso> If left-to-right was not specified, this might diverge or not depending on the mood of the compiler
04:13:42 * hackage hpqtypes-extras 1.10.0.0 - Extra utilities for hpqtypes library  https://hackage.haskell.org/package/hpqtypes-extras-1.10.0.0 (arybczak)
04:51:34 <cocreature> is there a way to map a module to the packages containing it? :i only shows the module name
04:52:12 <[exa]> ghc-pkg has some kind of lookup for that
04:52:31 <dminuoso> Is there a flag to suppress the output of cabal when doing `cabal v2-run` ?
04:52:42 <merijn> dminuoso: Eh, the verbosity flag? :p
04:52:50 <[exa]> cocreature: ghc-pkg find-module Data.Array etc
04:52:55 <cocreature> [exa]: hm, nothing in ghci? I don’t have an easy way of invoking ghc-pkg such that pkg-dbs are setup properly in our environment
04:53:28 <dminuoso> merijn: Is `-v0` guaranteed to properly suppress all output?
04:53:38 <merijn> dminuoso: Works For Me (TM)
04:57:47 <[exa]> cocreature: afaik not
05:00:13 <[exa]> cocreature: well you can execute ghc-pkg using :! but that's obviuosly not what you want :D
05:00:43 <cocreature> [exa]: I actually tried that hoping that ghci maybe sets up env vars such that it works out but sadly it doesn’t :)
05:06:42 <phadej> cocreature: yea, I think someone should write a patch to ghc, so you could say :show package-db
05:06:49 <phadej> and it would dump how it was conigured
05:07:40 <phadej> (and also :show package-ids, as "packages" is take, to show which explicit -package-id's are passed)
05:09:03 <cocreature> phadej: sounds sensible, I’ll put it  on my ever-growing list of things to do :)
05:09:29 <merijn> cocreature: Oh! I know that list!
05:09:55 <phadej> I wanted those interspection features for something, but I completely forgot for what and when
05:10:13 <cocreature> merijn: I hope you don’t know mine! or at least you don’t know how to put things on mine :)
05:10:31 <merijn> cocreature: Wait, isn't that what the ghcide issue tracker is for? >.>
05:11:21 <phadej> and one more issue in the same spirit, is to have better non-interactive story for ghci, i.e. to write doctest like things
05:11:58 <phadej> (doctest cheats by evaluating "random1231231312313" tokens, and searching in ghci's stdout for these markers; a huge hack)
05:13:00 <phadej> I have no idea if there's way to capture GHCi output in proper chunked way (even if you not call ghci-the-executable, but use API)
05:13:09 <cocreature> merijn: crap, you found it :P
05:13:44 <phadej> or does ghcide has some nice trick  to evaluate stuff in ghci?
05:13:56 <phadej> (... self-set-up session)
05:13:59 <cocreature> no, we don’t evaluate things in ghcide
05:14:15 <cocreature> you can set the logaction to get ghc output reasonably nice but I’m not sure that works for ghci
05:14:42 <phadej> i'm sure you'll get to that :)
05:14:52 <phadej> i'm not in hurry :)
05:15:23 <phadej> my goal would be to have ghc independent doctest
05:15:39 <phadej> i.e. the one which just knows how to start ghci session (sounds like ghcide) and then operates with it
05:16:00 <phadej> currently you need doctest per ghc version you'll like to doctest with
05:16:07 <phadej> which is impractical locally
05:17:59 <dmwit> cocreature: I guess you know about cabal v2-exec and stack exec; but you're not using cabal or stack?
05:19:03 <cocreature> dmwit: yeah, for better or for worse, we’re using bazel
05:19:11 <dmwit> ok
05:19:24 <cocreature> I could write a script or patch things to get ghc-pkg setup correctly but I was hoping to avoid that :)
05:20:00 <phadej> cocreature: perfectly, :i ModuleName would work too
05:20:07 <phadej> which oculd print the package info
05:20:10 <phadej> but it doesn't :(
05:20:51 <cocreature> phadej: heh, yeah I tried that and was disappointed that it did nothing :)
05:21:24 <phadej> I don't think that trying to resolve modulename after trying to resolve name would break too many things
05:21:32 * dmwit data Prelude = Prelude; :i Prelude
05:21:38 <phadej> :)
05:25:59 * tabaqui1 data Foo = Prelude; class Prelude a; :i Prelude
05:27:03 <tabaqui1> using Type as class, point, module and kind would be even funnier
05:34:57 <dminuoso> Why is `Real` called `Real` when its actually the typeclass of things that can be turned into rational numbers?
05:36:24 <dminuoso> I mean it does not seem to be compatible with irrational numbers.. that is if I had some `pi :: Irrational` I couldn't sensibly write `instance Irrational Real`, could I?
05:36:34 <dminuoso> *instance Real Irrational
05:36:56 <tabaqui1> because Real numbers is a lineary ordered field with continuity principle
05:37:02 <tabaqui1> it is not a constructive definition
05:37:40 <tabaqui1> so class of Reals is a class of all field isomorphic to "naive" real numbers (1,2,3,pi,etc)
05:37:42 <Athas> dminuoso: there's a long tradition in programming languages of using 'real' for things that are not real numbers.
05:37:42 * hackage pandoc-pyplot 2.2.0.0 - A Pandoc filter to include figures generated from Python code blocks  https://hackage.haskell.org/package/pandoc-pyplot-2.2.0.0 (LaurentRDC)
05:37:49 <Athas> FORTRAN probably did it first.
05:38:07 <Athas> What's the state of the art in Haskell technology for straightforward parallel maps?
05:38:28 <tabaqui1> hah, no, I am wrong
05:38:44 <tabaqui1> Haskell Real is far from R
05:38:47 <dminuoso> tabaqui1: :-)
05:39:15 <dminuoso> Athas: So `Real` should have been named `Rational`, but FORTRAN is to blame?
05:39:21 <dminuoso> I like the logic!
05:39:26 <Athas> dminuoso: it's not really a rational number either, is it?
05:39:35 <Athas> I like "float" because it's not as much of a lie.
05:39:46 <dminuoso> But "float" is even more of a lie 
05:39:52 <tabaqui1> it is not rational either
05:39:54 <dminuoso> Athas: Perhaps `Rationally` then.
05:40:28 <dminuoso> That is, `Real` seems to be compromised of all subsets of the Rational numbers.
05:40:40 <Athas> I mean, it *is* possible to represent both rationals and real numbers on a computer (well, except for the uncomputable ones), but most programs really don't want or need to.
05:40:51 <tabaqui1> instance Real Complex where toRational = toRational . abs
05:41:03 <dminuoso> tabaqui1: Gah.
05:41:27 <dminuoso> The numeric typeclasses appear to be a mess.
05:41:35 <tabaqui1> Num is fine :)
05:42:21 <merijn> Athas: How parallel?
05:42:28 <merijn> Athas: And also, what are you mapping? :p
05:43:40 <dminuoso> tabaqui1: Why not just have some `class Semiring s => Ring s where negate :: s -> s` ... we could have a full algebraic lattice of typeclasses.
05:43:47 <dminuoso> Imagine the fun.
05:43:51 <dolio> Complex is not an instance of Real.
05:44:01 <Athas> merijn: in my compiler, I want to run a pure function on a bunch of the functions I am compiling.  This is embarassingly parallel.
05:44:21 <dolio> All the instances of Real in the standard library are subsets of the reals.
05:44:22 <merijn> Athas: Ok, then I got nothig
05:44:30 <tabaqui1> there was a package with algebra from scratch
05:44:31 <Athas> I just want to expose the parallelism and let the GHC RTS take care of the rest.  I can't really imagine a much simpler problem than this.  The only challenge is that not all functions will take the same time to run.
05:44:57 <merijn> Athas: I'd say the state of the art in "parallel map" for IO bound stuff is "my code", but that's not really suited for fast pure maps
05:46:28 <Athas> merijn: wait, how come you developed fast parallel IO yourself?  Weren't you just doing scaffolding for CUDA code?
05:47:42 <merijn> Athas: To be fair, you didn't specify fast, you said "straightforward parallel map" And the answer is "I kept reimplementing the same kinda stuff across several libraries so I decided to implement it properly once and forall"
05:47:50 <raven> hey bois
05:47:57 <Athas> Why would one want a parallel map that isn't fast?
05:48:07 <Guest18828> hey
05:49:23 <dminuoso> hey.
05:50:21 <merijn> Athas: Fast is relative, I wrote it for IO bound tasks, so while it isn't particularly slow it's not really fast compared for non IO bound tasks
05:53:39 <Athas> Well, using Control.Parallel.Strategies.parMap is certainly heating up my cores, but seems very slow in wall-clock terms.
06:07:42 * hackage castagnoli 0.1.0.0 - Portable CRC-32C  https://hackage.haskell.org/package/castagnoli-0.1.0.0 (andrewthad)
06:13:41 <chreekat_> parallelization is hard :)
06:17:31 <kuribas> do you use foldMap or concatMap?
06:19:38 <dminuoso> kuribas: depends, concatMap has fusion builtin.
06:20:29 <kuribas> and foldMap not?
06:20:30 <dminuoso> kuribas: foldMap on [] is not specialized, so you could pay deerly for it.
06:20:49 <kuribas> dminuoso: but likely inlined, no?
06:20:58 <dminuoso> kuribas: Still, you wouldn't get the same definition.
06:21:38 <dminuoso> kuribas: concatMap uses build which fuses with foldr, foldMap on [] gives you `foldMap f = foldr (mappend . f) mempty` 
06:22:30 <dminuoso> So if you are generating a large list, concatMap is far more effective.
06:23:26 <tabaqui1> which sql client library would you advise? I need to switch between remote MariaDB and local sqlite as easy as possible
06:23:55 <dminuoso> tabaqui1: Is Postgres instead of MariaDB an option?
06:24:16 <dminuoso> (If so, you could use postgresql-simple and sqlite-simple, it should be really simple to write a thin abstraction over those)
06:24:18 <tabaqui1> nope, the database is provided by other team
06:24:56 <tabaqui1> maybe, I will create mock class to abstract over both of them and pure test code
06:25:14 <dminuoso> tabaqui1: What's the local sqlite for?
06:25:35 <hyperisco> I need help with semantics for m >>= f. I am trying to give a semantics for all types  M a  wherein I don't care about  a  nor do I care about values of  a . So I need to refer to the M-action  f(x::a) :: M b  But I don't really want "return values" or function application in my semantics
06:25:53 <tabaqui1> I have some service that manages tasks; this service store data in remote database, but in case of bad network it should use local storage instead
06:26:06 <tabaqui1> and switch between them if needed
06:27:10 <hyperisco> So, I don't see how I can refer directly to  f  . I can break  f  down to  λx.n  then refer to n? But n has x free, so that seems weird.
06:27:10 <tabaqui1> so I need simple "select" "insert update on duplicate" and "delete"
06:27:30 <tabaqui1> dminuoso: ^
06:27:55 <tabaqui1> HDBC?
06:28:38 <hyperisco> Maybe what I need to go is just give semantics to ap and join
06:30:17 <dminuoso> tabaqui1: My honest opinion? Dont have a bad network.
06:31:39 <tabaqui1> % :i RealWorld
06:31:39 <yahb> tabaqui1: data RealWorld -- Defined in `GHC.Prim'
06:32:27 <dminuoso> tabaqui1: It's going to be extremely painful to have consistent world views like this.
06:33:39 <tabaqui1> not much. Actually, it is a pretty fun feature request, and I'm getting paid for it
06:33:49 <tabaqui1> *funny
06:34:04 <tabaqui1> dminuoso: ^
06:55:37 <tabaqui1> in English "alpha-quality" means very good or very bad?
06:56:33 <hpc> it refers to the stability of the code
06:56:41 <hpc> something that's released is considered stable
06:57:05 <hpc> "beta" is when something is being prepared for release, not quite stable but has upcoming features
06:57:21 <hpc> "alpha" is usually for something that's not feature-complete and still being worked on
06:57:26 <hpc> and can change at any time or may have bugs
06:57:45 <hpc> so not so much "bad" as "unfinished"
06:57:46 <tabaqui1> yeah, I've seen alpha, beta relating to versions
06:57:52 <tabaqui1> but here is quality
06:58:17 <hpc> should mean the same thing
06:58:31 <hpc> the code it's talking about is as good as something that's not finished yet
06:58:43 <tabaqui1> ok, thanks
07:00:15 <LCRERGO> \quit
07:24:56 <militia> I want to read the FilePath for readFile in the cmd line args
07:25:05 <militia> anyway to turn string to FilePath for this?
07:25:19 <militia> inputFile <- getArgs returns a string
07:25:25 <militia> readFile needs a FilePath
07:25:30 <dminuoso> militia: FilePath is just a type alias for String :)
07:25:35 <ski> @src FilePath
07:25:35 <lambdabot> type FilePath = String
07:25:36 <dminuoso> type FilePath = Strin
07:25:42 <militia> ah
07:25:45 <militia> makes sense
07:25:57 <dminuoso> If only, I wish type aliases would be abolished. :-p
07:26:51 <ski> being able to export them abstractly, could be nice
07:27:25 <dminuoso> ski: To what end? Overall I feel type aliases add more confusion and hamper diagnostics.
07:27:48 <dminuoso> (Though GHC is littered with type aliases, so Im guessing they are sticking, someone there is liking them)
07:27:49 <ski> as an alternative to `newtype'
07:28:47 <ski> although `LiberalTypeSynonyms' is going in the direction of macros
07:29:40 <ski> i suppose one potential issue with exporting them abstractly is type class instances
07:30:28 <phadej> there is package path and paths
07:30:41 <phadej> which provide similar (though different) newtypes over FilePath
07:31:07 <phadej> I later in personal packages
07:31:47 <ski> i suppose this is where restricted type synonyms, in Hugs, <https://www.haskell.org/hugs/pages/users_guide/restricted-synonyms.html>,<https://www.haskell.org/hugs/pages/hugsman/exts.html#sect7.3.5> have some appeal
07:32:19 <ski> (which is not that dissimilar to `abstype' in SML)
07:36:07 <dmwit> Cute, I like it.
08:03:25 <TheCommieDuck> Is there a nicer pattern than having instance Foo (Bar a) where x = "a", instance Foo (Bar b) where x = "b", instance Foo (Bar c) where x = "c" etc?
08:06:00 <phadej> class FooBar where barX = ... ; instance FooBar a => Foo (Bar a) where x = barX
08:06:22 <phadej> maybe, not sure
08:06:33 <phadej> "instance Foo (Bar a)" and "instance Foo (Bar b)" are the same
08:07:00 <TheCommieDuck> oh
08:07:05 <jusss> 🗜️
08:07:17 <TheCommieDuck> I guess I shouldn't be using typeclasses for this and instead should just be adding it into the record type
08:08:14 <TheCommieDuck> oh hang on. My bad, I've given a wrong example. Not (Bar a), (Bar b); (Bar Int) and (Bar String) and (Bar SomethingElse)
08:08:39 <TheCommieDuck> but writing x _ = "some way of tagging the parameter type" feels like it's doing it wrong
08:10:04 <lortabac> TheCommieDuck: look at Data.Proxy, that's what is normally used in these cases
08:10:32 <lortabac> class Foo a where foo :: Proxy a -> String
08:10:44 <lortabac> instance Foo Int where foo _ = "Int"
08:11:05 <TheCommieDuck> oh - it's a thing that the parameter actually does hold information, just I don't care about any of the contents of the type, just that it's of Int or String.
08:12:01 <lortabac> TheCommieDuck: that's exactly what Proxy is for
08:12:34 <TheCommieDuck> oh, I see. Huh.
08:12:36 <lortabac> you don't need Bar in your instances
08:12:49 <lortabac> just its parameter
08:12:59 <psftw> Hoping to catch the right person in here :-)
08:13:20 <TheCommieDuck> thanks :)
08:13:33 <psftw> The code for the "haskell" docker image disappeared from github recently as the person whose account it was under deleted their online presence
08:13:56 <psftw> I think it makes sense to move this under the "haskell" organization on GitHub if possible
08:14:05 <psftw> rather than my personal account
08:14:11 <psftw> (also, looking for maintainers :-D)
08:14:55 <fendor> what was the solution again to capture an exception and find the most concrete type of the exception?
08:14:55 <geekosaur> this might be better on haskell-cafe mailing list, otherwise #haskell-infrastructure
08:15:01 <fendor> tpyeOf?
08:15:36 <psftw> thx geekosaur, will blast over there as well
09:15:31 <wejetheman> does anyone have any thoughts on how I could abstract out some of the redundancy in this move function? http://codepad.org/PIIVSs9s
09:18:38 <lyxia> map the four directions to 0..3 and do modular arithmetic
09:21:37 <glguy> wejetheman: I would break up the two operations of changing direction and advancing
09:22:25 <wejetheman> still ends up being the same number of lines, but yea it might be more explicit that way
09:22:42 <wejetheman> a similar number of lines and characters
09:23:40 <lyxia> https://gist.github.com/Lysxia/d64cb2f57d20732557fb7d8e1f2dce5e
09:24:56 <wejetheman> huh.. cool
09:26:25 <EvanR> there's removing redundancy by compression and there's making the code more clearly, which might reduce the size, or increase it
09:26:50 <wejetheman> that code is really clear, ill grant that
09:27:35 <EvanR> looks good
09:27:58 <glguy> wejetheman: You can also store the veleocity vector a robot is heading and then just update it: https://github.com/glguy/advent2018/blob/master/execs/Day13.hs#L196-L204
09:28:22 <glguy> wejetheman: Then 'advance' is just to add the current direction of travel to the current position
09:35:05 <wejetheman> thanks for the suggestions guys
09:35:12 * hackage ip 1.7.0 - Library for IP and MAC addresses  https://hackage.haskell.org/package/ip-1.7.0 (chessai)
09:40:12 * hackage orgmode-parse 0.2.3 - A collection of Attoparsec combinators for parsing org-modeflavored documents.  https://hackage.haskell.org/package/orgmode-parse-0.2.3 (ParnellSpringmeyer)
10:06:12 * hackage advent-of-code-api 0.2.1.0 - Advent of Code REST API bindings and servant API  https://hackage.haskell.org/package/advent-of-code-api-0.2.1.0 (jle)
10:11:53 <dsal> Can I convince show to give me unicode?  I've got a string "ping↓" that keeps showing up as "ping\8595"
10:12:04 <dmwit> Nope.
10:12:22 <dsal> Alright.  I guess I'll change the string so I can read it.
10:12:26 <dmwit> But why are you using show? "ping↓" is already a suitably-unicody string.
10:12:48 <dsal> It's a failing quickcheck test.
10:12:54 <dmwit> (...perhaps you're just using `print` instead of `putStrLn`?)
10:13:50 <dmwit> Can you... say a bit more, maybe? I'm not sure I understand the problem yet.
10:16:54 <dsal> Quickcheck fails and shows all the inputs and stuff.  My input contains a string description of itself.
10:17:06 <dsal> It can be a ping up, ping down, etc...
10:17:35 <dsal> I was using ping↓ as it's easy to read, but not when it gets turned into a number.
10:18:18 <dmwit> Why not use a real data type for the description and write a suitable Show instance for it?
10:18:38 <dmwit> data Whatever = PingDown; instance Show PingDown where show PingDown = "ping\8595"
10:20:07 <dsal> I could, but it doesn't actually matter too much.  The data type is defined elsewhere as a String description and a couple bits of  data.  The ping things only exist in tests.  Something like them may occur in the real world, but they haven't yet.
10:20:23 <dsal> I started out predefining all these things, but then realized it's just a string and two Maybes
11:34:25 <siraben> LiquidHaskell gives me an error: "1:1-1:1: Error  crash: SMTLIB2 respSat = Error "line 13 column 13: invalid sort definition, sort already declared/defined", anyone manage to get it to work with an older version of Z3 in Nix?
11:54:03 <EvanR> so is this right
11:54:16 <EvanR> Ord = O | S Ord | Lim (Nat -> Ord)
11:55:48 <EvanR> is it the ordinals
12:00:46 <koz_> % :k ReaderT
12:00:46 <yahb> koz_: ReaderT :: * -> (k -> *) -> k -> *
12:25:43 <EvanR> (if so it seems basic-AF ADTs transcend set theory)
12:32:22 <wildtrees> EvanR, AF?
12:32:37 <EvanR> basic as fruit
12:32:49 <wildtrees> oic
12:34:56 <EvanR> basically Ord is just some Type whereas ordinals can't be a set
12:48:42 * hackage http2-grpc-types 0.5.0.0 - Types for gRPC over HTTP2 common for client and servers.  https://hackage.haskell.org/package/http2-grpc-types-0.5.0.0 (LucasDiCioccio)
12:49:42 * hackage http2-client-grpc 0.8.0.0, warp-grpc 0.2.0.0, http2-grpc-proto3-wire 0.1.0.0, http2-grpc-proto-lens 0.1.0.0 (LucasDiCioccio)
12:52:32 <EvanR> i wonder if there is an embedding of any ADT into Ord
12:56:10 <merijn> I want a time machine to go back in time to stop myself from making terrible technical decisions >.>
12:59:49 <quiet_laika[m]> hrm
12:59:50 <EvanR> what could go wrong?
13:00:03 <merijn> EvanR: I'd have taken over the world by now >.>
13:01:04 <merijn> Instead I'm patching upstream libraries and unnecessarily churning my code base >.<
13:02:00 * quiet_laika[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/dtLvEiyvPkzPxQzOCPfnLDBI >
13:02:48 <quiet_laika[m]> would `HList` be appropriate here? or should i use nested tuples (maybe this follows the `car/cdr` model better as well?)
13:02:54 <merijn> quiet_laika[m]: No one can read that. Or rather, it requires people to open a random link from their IRC client and a substantial number would be too lazy
13:02:57 <EvanR> perfectionist programming, do everything right the first time and don't go back. Agile programming, relentlessly refactor. Logical limit programming, do nothing until the end of time, then write down the final state
13:03:28 <quiet_laika[m]> merijn: can't read the code block?
13:03:36 <dminuoso> quiet_laika[m]: Why do you think that [LispVal] would be a heterougenous list?
13:03:46 <merijn> quiet_laika[m]: Message too long and matrix turns that into a paste link
13:03:56 <merijn> EvanR: I don't even need to get it right the first time
13:04:00 <quiet_laika[m]> ahhh
13:04:01 <quiet_laika[m]> sorry
13:04:08 <merijn> EvanR: I just need to make choices that won't make getting it right later so hard
13:04:28 <EvanR> i drive myself crazy thinking like that
13:04:35 <EvanR> like a what i game
13:04:37 <EvanR> what if
13:04:42 <merijn> EvanR: I'm working around all sorts of brokenness because patching upstream is less work than porting everything to something else
13:05:06 <merijn> EvanR: It would've been fine to get it wrong, if I got it wrong in a way that I could fix >.>
13:05:11 <tdammers> the most important part is writing down your choices and assumptions in unambiguous language, so that when you come back later to change them, you know exactly what you need to do
13:05:15 <tdammers> type systems are great for that
13:05:29 <dmwit> quiet_laika[m]: I don't know "finally tagless" for sure. But if it's the one I'm thinking of, then it would be like
13:05:33 <merijn> tdammers: That doesn't stop it from requiring several weeks/months to fix
13:06:02 <tdammers> merijn: no, but at least it'll be several weeks/months of straightforward, predictable work
13:06:08 <dmwit> quiet_laika[m]: class LispVal v where atom :: String -> v; list :: [v] -> v; dottedList :: [v] -> v -> v; number :: Integer -> v; string :: String -> v; bool :: Bool -> v
13:06:09 <merijn> tdammers: I mean, the actual assumptions and pretty unambiguous and there's nothing fundamentally hard from fixing it
13:06:37 <merijn> tdammers: Yes, but at this point that time investment is not going to happen, so it's irrelevant
13:06:49 <tdammers> merijn: ah, classic write-only codebase
13:06:58 <quiet_laika[m]> dminuoso: it's "heterogenous" in terms of the lisp values that are represented, which are all covered under the single `LispVal` datatype. but the representation in final tagless has the underlying type of the `LispVal` explicitly mentioned, so i can't make a regular list of `LispVal repr => [repr a]`
13:07:58 <merijn> tdammers: Classic "I promised a finished first draft of my thesis on monday", "several weeks/months of engineering" is *not* the right trade-off to the problem of "past technical choices made it hard to speedup my experiments so I can actually hit my monday deadline"
13:08:01 <dminuoso> quiet_laika[m]: Im not familiar with that encoding. Can you elaborate?
13:08:22 <EvanR> quiet_laika[m]: you'd have to use existentials, or otherwise decide what the uniform treatment of those things in the list will be. HList instead would probably be relatively hellish
13:09:25 <EvanR> the existential way pairs the ListVal dictionary with the rep
13:09:29 <quiet_laika[m]> dmwit: one of the oleg papers shows most of its higher order final tagless interpreters as taking a type variable argument, `v a`, but, maybe that isn't required here because i don't (yet) have any higher order terms...?
13:09:35 <tdammers> https://peddie.github.io/encodings/encodings-text.html might help
13:09:48 <EvanR> then you can put them all in the list since the rep type is hidden
13:10:51 <quiet_laika[m]> dminuoso: you define your syntax/semantics in terms of typeclasses and datatype interpreters, which is supposed to give you more extensibility in a couple directions: https://serokell.io/blog/tagless-final here is what i used to try and understand a bit better
13:11:09 <EvanR> oleg's site on final tagless is pretty good
13:11:42 <quiet_laika[m]> olegs site is very good but i found it a bit over my head when i was first trying to understand the subject
13:12:15 <quiet_laika[m]> lots of good code examples though
13:12:19 <EvanR> i was impressed with the extensibility but worried about doing basic stuff like what quiet_laika[m] is trying to do
13:12:55 <quiet_laika[m]> EvanR: would that be something like, `list :: forall a. [repr a] -> repr [a]`?
13:13:29 <tdammers> if you're currently learning haskell by following the Scheme book, then finally tagless might be a bit too much
13:14:00 <EvanR> newtype HideLispVal = forall a . MkHideLispVal (LispVal a => a)
13:14:08 <quiet_laika[m]> i mean, i've been using haskell for couple years in my spare time, im not /just/ learning
13:14:40 <quiet_laika[m]> im doing this as an experiment specifically with final tagless
13:14:48 <EvanR> quiet_laika[m]: or you could make an in-universe list, since lisp has those
13:15:23 <EvanR> nil :: v, cons :: v -> v -> v
13:16:24 <quiet_laika[m]> hadn't thought of it that way, i'll play with both!
13:19:37 <EvanR> may the skolems be zonked
13:31:25 <uglyoldbob> if I have a list of 8 things, how might I generate all 256 "combinations" of those things: [a] -> [[a]]
13:32:26 * EvanR attempts to infer how to get 256 from 8 things, other than having 8 bits
13:33:47 <EvanR> this is why i failed the GRE
13:36:54 <EvanR> define "combinations"
13:37:02 <quiet_laika[m]> frankly it seems a lot more "lispy" to define the list by cons+nil (car+cdr maybe?) than by `list` and `dottedlist`
13:37:28 <EvanR> car and cdr destruct a list
13:37:38 <EvanR> cons and nil build a list
13:37:48 <EvanR> well, a binary tree
13:38:21 <uglyoldbob> for example [1,2,3] should create [ [3], [2], [2,3], [1], [1,3], [1,2], [1,2,3], []] (order not important)
13:38:29 <EvanR> i mean, car and adr destruct a list using the usual interpretation
13:39:15 <quiet_laika[m]> no you're right, im just very dim sometimes
13:39:18 <EvanR> uglyoldbob: i suspect this is a foldM using list monad
13:41:25 <dmwit> uglyoldbob: filterM (const [False, True])
13:41:32 <EvanR> ah filterM
13:41:33 <dmwit> > filterM (const [False, True]) "abc"
13:41:35 <lambdabot>  ["","c","b","bc","a","ac","ab","abc"]
13:43:42 <catern> is there a word for changing "x" into "(λy.y) x"? ___ abstraction or something?
13:44:04 <uglyoldbob> ah that is exactly what i was looking for
13:44:12 <dmwit> catern: That is one way of beta expanding.
13:44:56 <catern> dmwit: is that a term that people use? beta expansion? that did occur to me, but...
13:45:09 <catern> I didn't see much usage of it as a term
13:45:11 <dmwit> (another beta expansion of `x` might be `(\y. x) z`)
13:45:26 <dmwit> It is a term. People don't use it much, because it's rarely useful.
13:46:16 <catern> I guess "abstraction" is a more specific term to use
13:47:54 <dmwit> I don't believe I've ever seen "abstraction" used to describe that transformation or anything similar.
13:50:26 <catern> well, it's abstraction over x
13:50:55 <EvanR> i dunno
13:51:18 <catern> I think my example is too simple, this one is better: "x+1" into (λy.y+1) x
13:51:19 <EvanR> not that i understand lambda "abstraction" 
13:59:46 <catern> or also, "f x" into "(λg.g x) f"
14:01:23 <EvanR> unbeta reduction.. beta expansion
14:01:36 <EvanR> not unique like eta expansion
14:03:15 <catern> the main thing is that I feel dumb repeatedly saying "passing arguments to functions" in phrases like, say, "you should pass this value as an argument to a function instead of closing over it"
14:03:24 <dmwit> I maintain my stance: I've never seen "abstraction" used to describe that transformation or anything similar.
14:04:45 <dmwit> In unification, there is a similar transformation that is sometimes called generalization.
14:05:19 <zeta_0> hello guys, how do i associate yesod with web-mode in emacs ? http://web-mode.org/
14:06:11 <zeta_0> do i need to use the `associate an engine` section ?
14:16:06 <romildo> Is 'cabal build' supposed to recompile the project if a source file has changed, right?
14:16:41 <romildo> If so, it stopped working for me on NixOS unstable.
14:16:44 <romildo> Any clues?
14:17:26 <merijn> romildo: cabal-install 3.0?
14:18:05 <romildo> cabal-install version 3.0.0.0
14:18:19 <merijn> romildo: And what does "has changed" mean?
14:18:46 <merijn> romildo: 3.0 defaults to v2-build which has a considerably more aggressive "don't do useless work" implementation
14:19:04 <romildo> merijn, it means that I have edited a source file, saved it.
14:19:11 <merijn> Most notably, just touch'ing the file or hitting safe so the modification time changes will *not* trigger rebuilds
14:19:24 <merijn> It will only rebuild if the hash has changed
14:20:23 <merijn> romildo: You're: 1) sure the file is actually different right now and 2) sure the file is listed under exposed/other modules of your cabal file?
14:22:47 <romildo> merijn, 1) yes, sha256sum calculates different sums before and after editing and saving the file
14:24:54 <romildo> merijn, 2) the file is not listed under exposed/other modules; it is a module that is used only in the project, and ghc is able to find it up to now.
14:25:40 <geekosaur> that should be in other-modules, otherwise cabal doesn't know about it
14:25:52 <merijn> romildo: That's because GHC if you incorrectly specify modules in your cabal file GHC sometimes still finds the module and in the past cabal relied on "just run GHC and GHC will handle whether to recompile"
14:26:31 <merijn> romildo: Modules local to your project *should* be in other modules, so your cabal file has been broken all along, but it managed to work through sheer coincidence
14:27:05 <merijn> romildo: Now that cabal-install handles the recompilation logic via hashing it's basically deciding "nothing has changed, so don't need to run GHC"
14:29:42 <romildo> merijn, in fact 'cabal v1-build' still works, while 'cabal v2-build' does not see the file has been updated.
14:29:59 <merijn> romildo: The fact that v1-build is coincidence
14:30:09 <merijn> Your cabal file is broken
14:30:17 <romildo> merijn, then I am going to fix the cabal file to list all those modules in other modules.
14:31:54 <romildo> merijn, although I do not have that much projects of my own, they all have worked. I did not know the cabal file was broken because of that. I thought cabal per see was able to find these modules.
14:32:08 <romildo> merijn, I am going to fix them.
14:33:10 <romildo> merijn, let me just read any relevant part in the cabal documentation.
14:33:56 <merijn> I can't link it right now, because for some reason readthedocs has a broken DNS setup from my home connection >.>
14:35:28 <romildo> merijn, google should give it to me. Thanks for helping me.
14:37:12 * hackage hw-json-lens 0.2.0.0 - Lens for hw-json  https://hackage.haskell.org/package/hw-json-lens-0.2.0.0 (haskellworks)
15:00:30 <EvanR> to test if a small axis aligned rectangle overlaps a axis aligned line segment, or to test if a floating point point coincides with a line segment. Something tells me they are the same thing, since the position of the line segment is also a floating point
15:01:13 <EvanR> a floating point point is already a small rectangle (crosses fingers)
15:02:46 <EvanR> using floating point equals for fun and profit
15:03:12 * hackage hasql-transaction 0.10 - Composable abstraction over retryable transactions for Hasql  https://hackage.haskell.org/package/hasql-transaction-0.10 (NikitaVolkov)
15:11:46 <EvanR> i'm wrong if these floats are really defined through addition of subtraction hah!
15:11:59 <EvanR> addition, and or subtraction, even if they are supposed to cancel
15:18:53 <royal_screwup21> EvanR are you interview prepping?
15:19:55 <EvanR> i don't think so
15:22:42 <EvanR> small rectangles it is... curious that this would turn wrong into right
15:26:11 <[itchyjunk]> hi
15:26:26 <[itchyjunk]> what is the difference between mod m n vs m `mod` n
15:26:59 <EvanR> nothing
15:27:00 <merijn> [itchyjunk]: Nothing, wrapping a function with backticks makes it "infix" instead of prefix
15:27:03 <ChaiTRex> [itchyjunk]: It's just notation. Same effect.
15:27:21 <[itchyjunk]> ah
15:27:33 <jle`> it could be said that m `mod` n is "sugar" for (mod m n)
15:27:34 <[itchyjunk]> is either one considered better than the other?
15:27:39 <jle`> just like how 1 + 3 is (+) 1 3
15:27:49 <ChaiTRex> [itchyjunk]: Whichever is more readable in the context you're using it.
15:27:51 <jle`> for 'mod' in specific, or functions in general?
15:27:52 <merijn> [itchyjunk]: Whichever is more readable is better
15:28:01 <[itchyjunk]> ah 
15:28:36 <[itchyjunk]> on paper, i would write m (mod n) so i guess m `mod` n looks similar.
15:29:12 * hackage proto-lens-jsonpb 0.1.0.0 - JSON protobuf encoding for proto-lens  https://hackage.haskell.org/package/proto-lens-jsonpb-0.1.0.0 (tclem)
15:30:12 <[itchyjunk]> althought mod m n seems easier :P
15:30:24 <[itchyjunk]> no need to stretch my pinky to ` twice
15:30:40 <EvanR> m (mod n) doesn't look right
15:30:43 <jle`> optimize for readability, not writeability
15:30:50 <Axman6> EvanR: on paper
15:30:56 <EvanR> m mod n or m % n looks right
15:31:00 <EvanR> (on paper) (to me)
15:31:12 * hackage hasql 1.4.0.1 - An efficient PostgreSQL driver with a flexible mapping API  https://hackage.haskell.org/package/hasql-1.4.0.1 (NikitaVolkov)
15:31:23 <EvanR> as an operator. I wouldn't expect 3 (+ 5) to make any sense
15:31:58 <EvanR> x = y (mod n) is another story
15:32:01 <[itchyjunk]> a \equvi b (mod n)
15:32:07 <[itchyjunk]> right thats what i meant
15:32:31 <EvanR> you need the whole thing for that notation to make sense, like integral _ d _
15:32:43 <jle`> laughs in dx
15:35:47 <[itchyjunk]> so how come i can do 2 + 2 but not + 2 2
15:35:55 <[itchyjunk]> and why isn't it 2 `+` 2 ? :x
15:36:05 <Axman6> > (+) 2 2
15:36:07 <lambdabot>  4
15:36:35 <[itchyjunk]> ah mod 5 10 and (mod) 5 10 works
15:36:47 <[itchyjunk]> why is mod special in that way?
15:36:49 <Axman6> 'operators' are infix by default and prefix with brackets, all other functions are prefix byt default but infix when using backticks
15:36:51 <merijn> [itchyjunk]: There is a distinction between "prefix function names" and "operator function names" the former default to prefix (and can be made infix via backticks) and operators default to infix and can be made prefix by wrapping with ()
15:37:06 <Axman6> mod isn't special at all
15:37:16 <jle`> > 3 `logBase` 10
15:37:17 <lambdabot>  2.095903274289385
15:37:26 <jle`> > (+3) `map` [1..10]
15:37:28 <lambdabot>  [4,5,6,7,8,9,10,11,12,13]
15:37:41 <Axman6> > logBase 2 16
15:37:43 <lambdabot>  4.0
15:37:51 <merijn> [itchyjunk]: So it's not that mod is special (this works for every "prefix function"), is just that functions with operator names are treated differently than functions with non-operator names (and + is an operator)
15:37:58 <[itchyjunk]> hmm what is map? i can see that it's taking the list [1..10] and adding 3 to it
15:38:02 <jle`> [itchyjunk]: so you can think of `` as making a prefix function infix, and () as making an infix operator prefix
15:38:03 <Axman6> logBase isn't a good candidate for using infix IMO :)
15:38:05 <glguy> A small way that mod is special is that it has a fixity declaration: infixl 7 `mod`
15:38:14 <jle`> > map negate [3,4,5]
15:38:16 <lambdabot>  [-3,-4,-5]
15:38:23 <Axman6> :t map
15:38:25 <lambdabot> (a -> b) -> [a] -> [b]
15:38:26 <ChaiTRex> [itchyjunk]: map applies a function to every element of a list and gives you the results.
15:38:28 --- mode: glguy set -o glguy
15:38:33 <jle`> > map f [x,y,z]
15:38:35 <lambdabot>  error:
15:38:35 <lambdabot>      • Ambiguous type variable ‘b0’ arising from a use of ‘show_M477872040683...
15:38:35 <lambdabot>        prevents the constraint ‘(Show b0)’ from being solved.
15:38:39 <jle`> > map f [x,y,z] :: [Expr]
15:38:41 <lambdabot>  [f x,f y,f z]
15:39:07 <jle`> i probably could have just written map f [x,y,z] = [f x, f y, f z] to get the same point across
15:39:23 <[itchyjunk]> ah so here, map is applying the function + ?
15:39:37 <[itchyjunk]> hmm i don't seem to understand this notation : lambdabot> (a -> b) -> [a] -> [b]
15:39:48 <Axman6> (+3) is syntax sudar for (\x -> x+3)
15:39:55 <Axman6> sugar*
15:40:06 <[itchyjunk]> ah
15:40:31 <Axman6> which can also be used with any other infix function:
15:40:43 <Axman6> > map (`mod` 3) [1..10]
15:40:44 <lambdabot>  [1,2,0,1,2,0,1,2,0,1]
15:40:50 <[itchyjunk]> but how did the list get generated? is [] a function of some sort?
15:41:01 <jle`> [itchyjunk]: ah sorry, (+3) is the function that adds three to its input
15:41:06 <jle`> [itchyjunk]: here we use a list literal
15:41:13 <jle`> [1,2,3] is a literal that represents the list with three items: 1, 2, and 3
15:41:50 <jle`> `(a -> b) -> [a] -> [b]` is the 'type' of map: it takes an (a -> b) and an [a] (a function from 'a' to b', and a list of a's) and returns a [b] (a list of b's)
15:42:09 <Axman6> there's also some syntax sugar for lists of Enums (types which implement the Enum type class). [a..] = enumFrom a, [a..b] = enumFromTo, [a,b..c] = enumFromThenTo a b c
15:42:27 <Axman6> > [2..7]
15:42:29 <lambdabot>  [2,3,4,5,6,7]
15:42:34 <Axman6> > enumFromTo 2 7
15:42:36 <lambdabot>  [2,3,4,5,6,7]
15:42:48 <Axman6> > [2,8..70]
15:42:50 <lambdabot>  [2,8,14,20,26,32,38,44,50,56,62,68]
15:42:53 <[itchyjunk]> (x |-> x+3) -> [1,2,3,..,10]->[4,..,13] ?
15:43:10 <Axman6> I don't know what that means
15:43:20 <jle`> map (+3) [1..10] = [4..13], yeah
15:43:26 <[itchyjunk]> ah neat
15:43:33 <jle`> > map (+3) [1..10]
15:43:34 <lambdabot>  [4,5,6,7,8,9,10,11,12,13]
15:43:37 <ChaiTRex> [itchyjunk]: Yes, that's what map (+3) [1..10] essentially means.
15:43:37 <jle`> > [4..13]
15:43:39 <lambdabot>  [4,5,6,7,8,9,10,11,12,13]
15:43:39 <Axman6> > map (+3) [a,b,c] :: [Expr]
15:43:41 <lambdabot>  [a + 3,b + 3,c + 3]
15:44:19 <jle`> [itchyjunk]: but you can think of [1..10] as just 'sugar' for writing [1,2,3,4,5,6,7,8,9,10], in a way.
15:44:44 <glguy> or more directly it's a way to write: enumFromTo 1 10
15:44:46 <jle`> so map (+3) [1..10] = map (+3) [1,2,3,4,5,6,7,8,9,10] = [1 + 3, 2 + 3, 4 + 3, 5 + 3, 6 + 3, 7 + 3, 8 + 3, 9 + 3, 10 + 3]
15:44:58 <jle`>  = [4,5,6,7,8,9,10,11,12,13]
15:45:34 <[itchyjunk]> ah neat
15:48:01 <jle`> a lot of haskell is just replacing like with like :)
15:48:20 <Axman6> > [(a,b,c) | a <- [1..10], b <- [a+1..10], c <- [b+1..10], a^2 + b^2 = c^2]
15:48:22 <lambdabot>  <hint>:1:68: error:
15:48:22 <lambdabot>      parse error on input ‘=’
15:48:22 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
15:48:31 <Axman6> > [(a,b,c) | a <- [1..10], b <- [a+1..10], c <- [b+1..10], a^2 + b^2 == c^2]
15:48:33 <lambdabot>  [(3,4,5),(6,8,10)]
15:49:21 <[itchyjunk]> ah so the set builder notation just works?
15:49:31 <[itchyjunk]> you generated pythogorian triplets right?
15:49:45 <jle`> s/just//
15:50:28 <Axman6> we call them list comprehensions
15:50:47 <[itchyjunk]> ah okay
15:51:25 <[itchyjunk]> i am/was trying to learn py as well. i was checking out haskell and i really like it
15:51:41 <[itchyjunk]> for some reason, i feel like i can think in math for haskell which not for py
15:51:55 <[itchyjunk]> while*
15:51:57 <Axman6> Pyhton's list comprehensions were inspired byt Haskell's
15:52:04 <jle`> a lot of the concepts transfer more directly, syntax-wise
15:52:09 <[itchyjunk]> ah didn't know!
15:52:14 <[itchyjunk]> i don't know too much py
15:52:23 <jle`> for example writing a function that increments something by three is as simple as (+3), or (\x -> x + 3)
15:52:24 <Axman6> That's a good thing :)
15:52:33 <[itchyjunk]> i tried to jump into numpy directly a long time ago and got wrecked
15:52:36 <jle`> for python you'd do something like ... function ... blah .. x ... return (x + 3) ... osmething
15:53:14 <jle`> and for higher-order functions (like operators in math) it's a little easier to work with
15:53:16 <jle`> and reason with
15:53:26 <Axman6> what's python's "lambda" syntax?
15:54:18 <jle`> even non-lambda syntax is a little more direct
15:54:22 <jle`> addThree x = x + 3
15:54:27 <jle`> def addThree(x):
15:54:32 <jle`>  return x + 3
15:54:35 <jle`> or something like that
15:54:43 <jackdk> Axman6: `lambda args: expr`, iirc
15:54:55 <jle`> haskell the added benefit of type safety so your program won't compile if you give it a non-number
15:55:05 <jle`> wherehas python your programs will crash ten minutes after they already start running
15:55:12 <jackdk> Axman6: https://hackage.haskell.org/package/hpython-0.3/docs/Language-Python-Syntax-Expr.html#t:Expr
15:55:24 <jle`> and also good luck modifying any non-trivial python code after taking a break from writing it
15:56:05 <jackdk> no but jle` we have tests, see? (and if my ruby experience is anything to go by, you have greenspunned type checks into your test suite...)
15:56:58 <jle`> but is suppose it isn't fair to pick on python in a channel like #haskell
15:58:42 <justsomeguy> Do you think the phrases "trait" and "impl" (from rust) are more descriptive than "type class" and "instance"?
15:59:53 <jle`> i'm not sure if i'd say more descriptive, but they are certainly less overloaded in general programming terminology
15:59:55 <MarcelineVQ> when knowing nothing about either they are equivalently descriptive
16:00:07 <justsomeguy> Haha, true.
16:00:21 <Axman6> we got here first
16:00:45 <EvanR> i love it when things get renamed for no reason
16:00:57 <EvanR> a practice only a coder could love
16:00:58 <Axman6> FLATMAPABLE
16:01:24 <jle`> the words type, class, and instance all have pretty established meanings outside of haskell, and they are just related enough to make it confusing when using haskell
16:01:36 <MarcelineVQ> Costar
16:01:46 <EvanR> hey renaming for a good reason is possible
16:01:57 <EvanR> hypothetically
16:02:07 <MarcelineVQ> EvanR: Istanbul
16:03:15 <Axman6> could type classes have been called type families? ignoring the concept we already have with that name
16:03:55 <jle`> Axman6: the type theory concept, or the haskell concept?
16:04:08 <MarcelineVQ> call 'em type logics
16:05:09 <Axman6> the haskell concept
16:05:35 <[itchyjunk]> this "type theory" stuff is from catagory theory?
16:05:52 <EvanR> they didn't come up with an esoteric enough name for type classes. What were they thinking
16:06:12 <justsomeguy> I tend to think of them as "overloaded operations" and "instances of those operations". Maybe the keywords "op" and "instance" would have been a decent choice.
16:06:35 <EvanR> how about "overloads"
16:06:48 <justsomeguy> That sounds better.
16:07:05 <EvanR> great. *renaming it now*
16:07:15 <jle`> [itchyjunk]: no, separate thing
16:07:25 <justsomeguy> But I also like the existing terminology, from both Haskell and Rust. Naming things is a fussy affair.
16:07:26 <[itchyjunk]> ah
16:07:42 * hackage proto-lens-jsonpb 0.2.0.0 - JSON protobuf encoding for proto-lens  https://hackage.haskell.org/package/proto-lens-jsonpb-0.2.0.0 (tclem)
16:07:54 <EvanR> rust really has something called "impl"? How do you even pronounce that
16:07:56 <jle`> [itchyjunk]: type theory is about building type systems that are consistent and different abilities to reason about your code/values/types, etc.
16:08:02 <justsomeguy> EvanR: "implements"
16:08:05 <jle`> [itchyjunk]: category theory is closer to something like abstract algebra
16:08:51 <[itchyjunk]> ah
16:08:53 <MarcelineVQ> overloads doesn't express there's constraints involved, where class suggests that there's separations
16:08:59 <EvanR> category theory is algebraic, type theory is logical
16:10:55 <nshepperd1> Type classes should have been called Predicates
16:11:21 <EvanR> class Mortal t where
16:11:27 <EvanR> instance Mortal Socrates where
16:11:33 <justsomeguy> nshepperd1: Why predicates?
16:12:05 <jle`> Show a => a -> String   -- if 'a' is Show, then you can turn it into a String
16:12:08 <EvanR> instance Man t => Mortal t where -- crap overlapping
16:12:24 <EvanR> instance Man Socrates where
16:13:24 <justsomeguy> nshepperd1: Ah had to look up predicated again. "to assert to be a quality, attribute, or property of", that makes sense.
16:13:33 <justsomeguy> s/predicated/predicate/
16:13:56 <justsomeguy> But that also sounds just like a trait. A trait of.
16:14:06 <ammar2> I like trait
16:14:16 <jle`> trait is grait
16:14:25 <ammar2> predicate might get confused with actual predicate functions(?)
16:14:37 <EvanR> traits sounds like properties, which is oo for instance variables
16:16:42 * hackage twirp 0.2.0.0 - Haskell twirp foundations  https://hackage.haskell.org/package/twirp-0.2.0.0 (tclem)
16:17:16 <EvanR> or object fields
16:19:03 <nshepperd1> predicate Num a ... fact Num Int where...
16:22:36 <Axman6> is Num a ? ....  actually Num Int hence
16:24:57 <EvanR> that settles it, We need coffeeHaskell which is another language that is just haskell with different syntax
16:25:36 <nshepperd1> Haskell, but you need more coffee to read it
16:27:03 <maralorn> EvanR: I would be open to that idea.^^
16:27:45 <maralorn> I thought about it before and decided, that passing through all ghc features to a language with different syntax would be a terrible overhead not worth the effort.
16:28:51 <jle`> i would just like to write haskell in a language where all the upper and lowercase letters are flipped
16:29:56 <justsomeguy> Well, Haskell is already elegant enough. More than any other language I've used. :^)
16:30:33 <Axman6> INSTANCE mONAD M WHERE RETURN :: A -> M A
16:31:08 <MarcelineVQ> Axman6: you're full of beans
16:31:39 <justsomeguy> Axman6:  Needs more verbosity, and more keywords, and every keyword should be in English. Look to Ada for inspiration.
16:31:48 <Axman6> https://www.youtube.com/watch?v=4C9i9LMG_5c
16:32:03 <EvanR> i mean, there was a time when Axman6's code was normal
16:32:18 <Axman6> justsomeguy: I like Ada a lot, it's genuinely a fantastic language
16:32:20 <EvanR> before civilization developed lowercase
16:32:22 <maralorn> Is there a way to tell cabal to build my lib with -Werror without changing my cabal file and without building the dependencies with -Werror?
16:33:13 <justsomeguy> Axman6: It actually is. The type system is pretty fascinating. Especially how easy it is to do refinement types. But I have to admit that the verbosity of the syntax weirds me out.
16:34:47 <jle`> maralorn: try adding --ghc-opts="-Werror" ?
16:34:51 <jle`> or ghc-options
16:35:11 <maralorn> jle`: I did that, but that seems to affect the dependencies, too.
16:35:16 <jle`> :(
16:36:04 <justsomeguy> Axman6: All that, and it executes as fast as C. Years before rust and other alternatives existed.
16:37:07 * justsomeguy decides that he better stop wasting the internets time by idly chatting about programming languages he doesn't understand and actually do something productive instead
16:37:30 <EvanR> reaches speed = c, impressive
16:38:42 * hackage warp 3.3.4 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.3.4 (KazuYamamoto)
16:39:39 <jle`> also wouldn't it be nice if kebab-case was allowed for haskell identifiers
16:40:35 <ammar2> no
16:40:46 <ammar2> haskell has plenty of punctuation/symbols already
16:40:50 <EvanR> i always have space on both sides of operators anyway
16:40:58 <jle`> and yet we allow this'abomination'of'an'identifier
16:41:16 <ammar2> m'identifier
16:41:33 <glguy> jle`: I also prefer the - as a separator in identifiers
16:41:36 <jle`> kebab-case not being allowed is weird since it's the de facto standard for hackage package names
16:42:11 <glguy> > 10` mod `3
16:42:13 <lambdabot>  1
16:47:06 <jackdk> we should fix hackage to use words'with'apostrophes for consistency
16:58:14 <jle`> yea let's modify the standard for hackage/cabal files 
16:58:17 <jle`> ... oh wait
17:01:01 <jackdk> we'll make some friendly M4 macros to generate package.toml, which can be used to generate package.yaml, which will generate a cabal file.
17:01:31 <shapr> you making me sad already.
17:04:41 <jackdk> I'm sorry.
17:06:09 <hpc> you mean you don't just copy stuff into ./ghc_modules?
17:17:12 <koz_> jackdk: You're missing about 10 levels of indirection. :P
17:18:06 <jackdk> koz_: Maybe I'll create autocabal, which uses perl to assemble a cabal file template from snippets :P
17:18:13 <koz_> jackdk: Much better.
17:18:24 <koz_> You also have to have autocabal-build.
17:23:37 * Axman6 prefers using ccabal
17:23:50 <Axman6> more colours on the command line is always a good thing
17:29:49 <jackdk> no
17:35:21 <koz_> Gotta make it look like a unicorn vommed on your screen.
17:38:42 <Axman6> while we're at it, we need to make use of this valid haskell: https://ift.tt/2qiyq80
17:39:05 <Axman6> youShouldn'tDoThisIO :: IO a -> a
17:39:39 <koz_> whatIsThisIDon'tEven :: (Num a) => IO a -> Bool
17:39:41 <justsomeguy> koz_: $ bash | lolcat
17:39:47 <Axman6> thatShould't'veHappened :: Exception e => IO a -> (e -> IO a) -> IO a
17:40:27 <koz_> don'tChangeTheShapeOfTheList :: (a -> b) -> [a] -> [b]
17:40:31 <Axman6> n* :(
17:42:12 <koz_> Also, why stop at functions? We should rename That Type Class to 'PleaseDon'tMakeMoreTutorialsAboutMe'.
17:58:12 * hackage hw-all 0.0.0.1 - Demo library  https://hackage.haskell.org/package/hw-all-0.0.0.1 (haskellworks)
18:07:06 <siraben> @pl (\y x-> x + 2 *y)
18:07:06 <lambdabot> (+) . (2 *)
18:11:19 <koz_> :t (+) . (+)
18:11:20 <lambdabot> (Num a, Num (a -> a)) => a -> (a -> a) -> a -> a
18:12:08 <siraben> @pl (\y x-> (if x then 1 else 0) + 2 * y)
18:12:08 <lambdabot> (. flip (flip if' 1) 0) . (+) . (2 *)
18:22:25 <MarcelineVQ> koz_: (+) . join (+)
18:22:36 <koz_> :t (+) . join (+)
18:22:38 <lambdabot> Num a => a -> a -> a
18:22:43 <koz_> Lol, cool.
18:23:43 <MarcelineVQ> > join (+) 7
18:23:45 <lambdabot>  14
18:51:23 <dmwit> > ((+) . join (+)) x y
18:51:25 <lambdabot>  x + x + y
18:52:22 <dmwit> siraben: You might like fromEnum if the 1 and 0 in your last query are Ints.
18:56:12 * hackage arrayfire 0.2.0.0 - Haskell bindings to the ArrayFire general-purpose GPU library  https://hackage.haskell.org/package/arrayfire-0.2.0.0 (DavidJohnson)
18:58:02 <monochrom> thisNeedsMoreTutorials :: Functor f => (a -> f b) -> s -> f t
19:02:05 <MarcelineVQ> monochrom: hey I know what that is, it's something about knife violence
19:31:26 <Orbstheorem> Hi, I'm having problems understanding how Data.HashMap.Lazy works. I would like to have stricly lazy maps, but I can't figure out why my map is being collapsed, does anybody know how could I debug this?
19:31:42 * hackage codeworld-api 0.4.0 - Graphics library for CodeWorld  https://hackage.haskell.org/package/codeworld-api-0.4.0 (ChrisSmith)
19:34:34 <Orbstheorem> More precisely, I'm having problems [here](https://gitlab.com/agepoly/it/infra/kubernetes/merge_requests/67/diffs#0ecbbc742bef6d9effafd6a027a808d9f0f94f5a_94_154) This line is getting evaluated, even if none of its consumers runs (requiredFiles is empty). I've prepared a step by step guide on how to run the code if somebody is kind-hearted enough to guide me through ^^ https://paste.gnugen.ch/raw/TIEk
19:36:06 <koz_> MarcelineVQ, monochrom: such stab, very optic
19:37:43 <glguy> What is a strictly lazy map? And what does collapsed mean?
19:39:09 <Orbstheorem> Stricly lazy map: The map should be looked up <=> somebody will consume it's output. Collapsed: evaluated
19:39:23 <Orbstheorem> s/<=>/if and only if/
19:42:50 <jusss> how to point to use cabal v2 in cabal config?
19:55:26 <Axman6> Orbstheorem: I don't think Data.Hashmap will evey be strictly lazy - Data.Map may be (I haven't looked at your code)
20:10:29 <Orbstheorem> After some fuzzing, I have the impression that the strictness of my code comes from the applicative style :/
20:11:07 <dmwit> I think you should probably try to minimize before you theorize.
20:12:27 <dmwit> It'll probably be easier to explain what you mean by "should be looked up <=> somebody will consume its output" if you do that, too.
20:13:39 <Orbstheorem> That's a good idea
20:52:28 <dsal> Kind of obscure question...  I'm trying to use checkers to verify my monoid implementation, but I believe it's failing because my arbitrary can't produce three sufficiently  realistic instances with respect to their associative property.  I could generate three from a single invocation, but that's different.  Is there a way I can  convince quicktime or checkers or something to let me generate three arbitrary instances?
20:52:46 <dsal> monoid :: forall a. (Monoid a, Show a, Arbitrary a, EqProp a) => a -> TestBatchSource -- doesn't give me much to work with.
20:56:29 <jle`> dsal: what do you mean by instances, exactly?
20:56:36 <jle`> Arbitrary can only generate values
20:56:41 <jle`> not typeclass instances
20:56:51 <dsal> Yes, sorry, not typing very precisely.
20:56:56 <jle`> unless used with some mechanism like Template Haskell
20:57:00 <jle`> or maybe reflection
20:57:24 <dsal> My type is InstanceState, so that's not helping...
20:57:49 <dsal> The value contains what is effectively a timestamp.  For most of my tests, I have one of these InstanceStates and then I do stuff to it.  In a couple cases, I might have two, but I can sort of adjust the timestamps to make them valid for a test.
20:58:28 <dsal> arbitrary sets to a "zero" time in a way that <> cares about, so, appending  left to right, the numbers should increase.
20:58:38 <jle`> if you are testing a monoid implementation, you would probably be testing that <> is associative, and mempty is an identity
20:58:46 <N3RGY> jle`: What about "data Witness c where Witness :: c => Witness c" and "instance ... => Arbitrary (Witness c)"? :p
20:59:31 <N3RGY> (I don't actually know the context, just kidding around)
20:59:56 <jle`> that could work too technically :)
21:00:47 <dsal> jle`: Yes, checkers does this, but it does it by creating three arbitrary instances.  <> isn't properly associative unless the timestamps are increasing.
21:01:01 <jle`> ah, so it's not a lawful monoid?
21:01:54 <jle`> one thing you can do if you want to check only on a predicate is use something like (==>)
21:01:58 <dsal> Hmm...   Maybe?
21:02:16 <dsal> I guess the problem is that it's checkers that's generating.  I don't get to ==>
21:02:30 <jle`> @check \x y z -> ((x == y) && (y == z)) ==> (x == z)
21:02:32 <lambdabot>  +++ OK, passed 100 tests.
21:03:04 <jle`> yeah if it isn't the case that forall a b c. (a <> b) <> c = a <> (b <> c), then it's definitely not a lawful monoid
21:04:09 <jle`> so you don't want to check a monoid instance, you just want to check 'a' property
21:04:20 <dsal> I guess the forall is the issue.  It works if you replace the forall with an iff
21:04:46 <jle`> that if valid(a,b,c) ==> a `f` (b `f` c) == (a `f` b) `f` c
21:04:52 <jle`> what do you mean replace the forall with an iff?
21:05:04 <jle`> i just wouldn't call it <>, maybe give it a different name
21:05:12 <jle`> but it's still a good property of something that isn't monoidal
21:05:30 <dsal> in practice, c > b > a and it should work fine then.
21:06:16 <jle`> why does it have to be called <> ?
21:06:25 <jle`> what would mempty even be?
21:06:50 <jle`> a lot of your problems might go away if you lose the attachment to the name of it
21:08:44 <dsal> Well, it almost works like a monoid.  It's quite monoidish.
21:09:29 <jle`> what would you gain from calling it a monoid?
21:09:35 <dsal> I do see the problem, though.  I'm not 100% sure I can make it always work.
21:10:23 <dsal> Well, it's got something like mempty and it's got a <>.  The case where all the timestamps are the same is a weird edge case that shouldn't happen in the real world.
21:12:13 <jle`> but what do you gain from calling it a monoid?
21:12:35 <nshepperd> is it monoidish enough that you can turn it into an actual monoid
21:12:40 <_d0t> ohai! How do I parse something like this using attoparsec: AABBCCDD? That's four numbers without any delimiters between them.
21:12:51 <dsal> _d0t: replicateM
21:12:56 <jle`> _d0t: how do you know when one number ends and another begins?
21:13:10 <_d0t> jle`: each one has a set number of digits in it.
21:13:11 <jle`> can you give some actual examples of strings you want to parse, and what you want it to parse into?
21:13:21 <dsal> jle`: I'm not too big on the name.  It just feels a lot like it.
21:13:29 <_d0t> Say, it's a time format: 235959
21:13:30 <_d0t> Like that.
21:13:45 <_d0t> I want to get three numbers, for hours, minutes, and seconds respectively.
21:14:09 <jle`> _d0t: you can use 'take' to get a given number of items
21:14:10 <_d0t> I could pick each digit, but I'm wondering if there is a better way.
21:14:11 <jle`> and then parse those items
21:14:37 <jle`> so (myParseNum =<< A.take 2) to take two digits and parse them
21:14:55 <jle`> dsal: in this case calling it a monoid doesn't really give you any benefit
21:15:17 <_d0t> Yep, that's the first thing I thought about.
21:15:18 <jle`> dsal: so looking into 'monoidal' things might take you down some weird roads that make things more complicated
21:15:33 <jle`> dsal: my point is to just call it some function that isn't <>, and then think about properties of that function
21:15:49 <jle`> it's ok for functions to have well-defined properties, even if they aren't a part of a typeclass
21:16:17 <_d0t> Sadly, there is no ByteString -> Parser Int in Attoparsec.
21:16:50 <Axman6> replicateM 2 digit >>= maybe (fail "Could not parse number") pure . readMaybe 
21:17:06 <dsal> jle`: Yeah.  It's probably not hard for me to stop calling it a monoid.
21:17:33 <_d0t> Axman6: ugh... thank you
21:17:58 <dsal> you  can replicateM 3 that.  :)
21:17:59 <jle`> dsal: so does `valid a b c ==> (a # b) # c == a # (b # c)` not work?
21:19:04 <dsal> Yeah.  I think the only code that actually uses this is my test.
21:20:34 <Axman6> _d0t: it's a bit gross though - you could also foldM or something to do (\acc n -> 10*acc + n) or something
21:21:31 <_d0t> Axman6: I was kinda hoping for an existing solution.
21:21:51 <_d0t> I know a few ways out of my head to do this, but this is such an obvious thing to be implemented out of the box.
21:22:15 <jle`> hm, i don't really think it is super obvious
21:22:39 <_d0t> scanf in C does it out of the box :)
21:23:09 <_d0t> scanf("%2d%2d%2d", &x, &y, &z);
21:24:17 <jle`> ah, fair enough :)
21:24:38 <jle`> it may be a fairnbairn threhshold kind of thing
21:24:49 <_d0t> I sorta expect anything I can do with scanf to be readily available in a parser library.
21:25:07 <jle`> you weigh how easy it is to implement from scratch vs. the cost of remembering what the name of it is
21:25:17 <jle`> if it's faster to implement it than it is to look up what the function is called
21:25:40 <jle`> it's 'readily available' in that it's easy to implement using parser combinator pieces
21:25:46 <_d0t> true. Maybe attoparsec isn't the right library for this.
21:25:54 <jle`> it can be easy to do with do notation
21:26:04 <jle`> parseTheThing = do
21:26:06 <_d0t> or with this https://hackage.haskell.org/package/scanf-0.1.0.0/docs/Text-Scanf.html
21:26:14 <jle`>   Just n <- readMaybe <$> replicateM 2
21:26:17 <sm[m]> parseTime would do it out of the box
21:26:22 <jle`>   Just m <- readMaybe <$> replicateM 3
21:26:24 <jle`>   pure (n, m)
21:26:50 <_d0t> is matching on Just a good idea here?
21:27:01 <jle`> yeah, that's how you control failure
21:27:05 <jle`> if it doesn't match, then the parser fails
21:27:09 <jle`> ie, the read doesn't work
21:27:16 <_d0t> Yeah, I know, I'm concerned about the error message.
21:27:22 <_d0t> and the whole MonadFail thing.
21:28:00 <jle`> the error message wouild be that the pattern match doesn't work, but you can 'catch' and re-name it later, maybe
21:28:03 <jle`> otherwise you could repliace it with
21:28:16 <jle`>   n <- maybe (fail "bad bad") pure . readMaybe =<< replicateM 2
21:28:34 <jle`> but at this point we already are doing more than the scanf version is doing -- error messages
21:29:04 <jle`> matching on Just already has better errors than the scanf version :)
21:29:17 <dsal> Well, my almost-monoid is no longer called monoid.
21:29:41 <jackdk> "monoi", perhaps?
21:29:59 <dsal> Is that French?
21:31:20 <jackdk> no idea. but it's almost monoid
21:31:30 <jackdk> I'm being silly, mostly
21:36:41 <Axman6> dsal: no that's Monet
21:45:38 <jusss> why sublimetext or intellij idea use ghc-mod or hsdev as backends not ghc?
21:46:05 <Axman6> ghc doesn't have any support for providing information to IDEs
21:46:15 <MarcelineVQ> Axman6: it goes actually ^^;
21:46:20 <Axman6> (actually that's no longer true, but is basically true)
21:46:21 <MarcelineVQ> more modern plugins probably use haskell ide engine rather than ghc-mod though
21:46:29 <jusss> is that all the haskell packages only source? I haven't saw a binary package yet
21:46:44 <jusss> it means every time I install a package, I have to compile it...
21:46:49 <jusss> and it takes time
21:47:18 <Axman6> I think you have misunderstood what ghc-mod etc. do
21:47:40 <jusss> I don't know what ghc-mod or hsdev do
21:49:23 <jusss> I should stay on emacs... but auto-complete is not good at haskell, i haven't tried company-mode, it seems difficult to config
21:49:50 <jusss> what you're using?
21:50:24 <Axman6> I use VS code and haskell-ide-engine
21:50:42 <jusss> Axman6: is that need `backends' ?
21:50:49 <Axman6> ?
21:51:04 <MarcelineVQ> I'm really boring, and just use atom with ghcid. there's no autocomplete other than regular dumb autocomplete that editors have that look for similar things in open buffers, but typechecking is fast
21:51:37 <jusss> Axman6: I mean does it need ghc-mod stuff thing?
21:51:47 <Axman6> I've been using TabNine for auto-complete - it's scare how good it is
21:52:09 <Axman6> jusss: haskell-ide-backend is basically an alternative to ghc-mod (I think, I haven't used ghc-mod)
21:52:13 <MarcelineVQ> haskell-ide-engine is the backend, afaik it's the language server. As in LSP
21:52:21 <Axman6> yes
21:53:02 <jusss> I saw there're some people doing a haskell IDE on twitter
21:54:41 <MarcelineVQ> There's been a couple tries at a haskell ide, such as leksah or ihaskell. haskell ide engine isn't the same thing as an ide, it's what you use to drive an ide.
21:54:44 <jusss> Axman6: did haskell-ide-engine need compile? 
21:54:50 <Axman6> yes
21:55:00 <Axman6> but it has the compile sripts in the repo
21:55:08 <Axman6> scripts*
21:55:31 <jusss> I'm stuck in cabal's compiling
21:55:35 <MarcelineVQ> oh not ihaskell, "Haskell for Mac"
21:56:26 <jusss> I use cabal to install hsdev or stylish-haskell, it takes almost 1 hours, and it still not completed, I think there're some issue about cabal on windows 10
21:56:42 <dsal> haskell doesn't compile as fast as some languages.
21:56:58 <dsal> Of course, the haskell compiler can do things most other languages can't.
21:57:13 <jusss> I have an archlinux server, but like you know haskell sucks on archlinux, so I create a debian sid chroot envronment
21:57:54 <jusss> but that archlinux server is PC without a screen, so I have to ssh login it, ssh -X seems a not good idea
21:58:13 <MarcelineVQ> it only sucks when you use arch's packages, you can install ghc yourself or use stack to manage them on arch
21:58:26 <jusss> even it's in the local network, ssh forward Xorg still not smooth
21:59:18 <MarcelineVQ> *or use stack to manage ghc on arch
21:59:19 <jusss> MarcelineVQ: but stack has some stuff on AWS, and AWS is forbidden on my country
21:59:31 <jusss> so I have to use cabal
22:01:29 <MarcelineVQ> Oh I see newer stack doesn't support the Tsinghua mirrors :(
22:01:37 <jusss> if cabal has some binary repos like python, will be good
22:02:25 <MarcelineVQ> nix is probably the only option for getting packages as binaries
22:02:27 <jusss> the cabal tool is like that gentoo or freebsd pacage manager, compile everything
22:03:12 <jusss> I wonder how much it takes when that gentoo user want to install firefox or chromium, it must be a long time
22:03:31 <jusss> MarcelineVQ: what is nix?
22:03:35 <jusss> a linux distro?
22:03:55 <MarcelineVQ> no. there is a nixos distro but nix is just a tool by itself
22:04:29 <MarcelineVQ> https://nixos.org/nix/
22:05:28 <MarcelineVQ> https://maybevoid.com/posts/2019-01-27-getting-started-haskell-nix.html
22:06:41 <jusss> MarcelineVQ: what about guix?
22:06:47 <jusss> IIRC
22:07:27 <MarcelineVQ> I don't know anything about it. looks interesting though
22:08:08 <jusss> https://guix.gnu.org/
22:09:08 <MarcelineVQ> seems there's a #guix channel if you have questions for them
22:09:35 <MarcelineVQ> there's also a #nixos channel for questions about both nix and nixos
22:09:50 <jusss> what about cabal?
22:10:07 <MarcelineVQ> what about it?
22:10:35 <jusss> there's a #cabal
22:10:43 <jusss> but only a few people...
22:11:05 <MarcelineVQ> yeah there's a #hackage too for more general questions about packages. questions about cabal and hackages are also welcome here
22:12:14 <jusss> why it takes so much time, cabal v2-install hsdev, I run it again, it takes 20 minutes and still not complete
22:12:54 <jusss> fine, I will do it with ssh -X on linux
22:13:43 <jusss> I heard that Microsoft provide some money to haskell community, but why windows still not support ghc well...
22:14:13 <jusss> I wonder what haskell to do with Microsoft
22:14:53 <opqdonut> microsoft research is doing quite a bit of language research these days (typescript, haskell, ...)
22:15:06 <Axman6> several of the main GHC developers work at Microsoft Research, which is an academic institution - most of them don't use windows
22:15:08 <opqdonut> doesn't really have anything to do with microsoft the company
22:16:02 <jusss> so what they do there?
22:16:21 <Axman6> research
22:16:27 <jusss> haha
22:16:31 <Axman6> write papers
22:16:41 <Axman6> develop new features in GHC
22:17:03 <ammar2> MSR isn't an academic institute
22:17:07 <EvanR> if you don't export certain field selectors of a record type.. client code can't observe these fields, even with pattern matching? skeptical
22:17:08 <ammar2> it's an industrial research arm
22:17:18 <dsal> They should rename Microsoft Research to BingBing
22:17:31 <Axman6> They certainly do a their fair share of academic research
22:17:41 <ammar2> while they do have more leeway on what they work on, there is still an underlying motivation to create stuff that can eventually be product-ized or benefit the main company
22:18:30 <jusss> I went that Microsoft Research on Asia once
22:21:55 <EvanR> oh man, it's true
22:25:34 <MarcelineVQ> ammar2: thus simon's recent papers on excel :D
22:26:20 <ammar2> MarcelineVQ: heh, link? let me take a wild guess first, program synthesis for excel formulas?
22:27:38 <EvanR> if you don't export, or import field selectors, you can't access that field using R{field=x} syntax. But it's not private because you can still access it with R a b x d syntax
22:27:53 <MarcelineVQ> https://www.microsoft.com/en-us/research/publication/elastic-sheet-defined-functions-generalising-spreadsheet-functions-to-variable-size-input-arrays/ https://www.microsoft.com/en-us/research/publication/build-systems-la-carte/
22:28:02 <EvanR> this seems silly
22:28:02 <MarcelineVQ> the latter is more incidental
22:29:51 <dsal> one of the conduit libs did a weird thing where they exported 'R' and then 'field' separately.
22:30:05 <dsal> I don't fully understand the magic that makes that work.
22:32:40 <EvanR> i'm messing with duplicate record fields, so i don't even know how you export fields separately
22:32:46 <LysergicDreams> dsal: Click 'source' in the upper right of the docs
22:33:05 <dsal> I know how to do it... I just don't understand the magic.
22:34:05 <dsal> I watched a couple haskell talks today that assured me that my perceived proficiency is an illusion (just in case I had doubts).
22:34:51 <dsal> I can write pretty much whatever I need written in Haskell, but I apparently haven't managed to need things like datakinds and what-not.
22:35:58 <wejetheman> I was messing around with this robot program a bit more, and I'm wondering if there is a better way to do this sort of thing than line 15 http://codepad.org/iIL7lfxt line 15 feels wonky. i had this idea that maybe i could compose advance and turn togather inside the foldl but no luck there
22:36:11 <Axman6> I believe module Foo (R, field) where data R = R { field :: Int } is legal - and it plays havoc with Haddock
22:38:25 <EvanR> nice
22:39:13 <EvanR> i think in the pattern R{field=whatever} `field' should always work, why wouldn't it
22:39:29 <EvanR> i mean, it doesn't. And it's annoying
22:41:37 <EvanR> since we don't have "NoSelectors" yet, it would be a convenient way to avoid the namespace pollution, don't export selectors. But then you can't pattern match
22:41:43 <EvanR> (that way)
22:42:23 <dsal> wejetheman: turn (Robot North c) 'L' = Robot West  c
22:44:23 <dsal> I did variants of succ and pred that wrapped around for bounded enums and used them for that kind of thing.     turn (Robot d c) = Robot (succ' d) c
22:45:06 <wejetheman> ya i had written code like that, and then precceded to learn that enum doesnt wrap around like that
22:45:15 <wejetheman> proceeded* 
22:45:53 <Axman6> Don't breat the law yo
22:45:57 <Axman6> break*
22:46:00 <wejetheman> I figured there was a way to make it wrap but that would be more complicated than just explicitly defining all that stuff like i did
22:46:06 <dsal> That's why I made ones that did.  heh
22:46:58 <wejetheman> i have this theory that explicit and simple code is better than clever code 
22:47:13 <MarcelineVQ> you iconoclast :D
22:47:43 <monochrom> cleverly explicit and cleverly simple.
22:48:00 <jle`> optimize for readability, not writeability
22:48:39 <monochrom> btw people also disagree (even antipodally conflict) on what counts as "explicit", "simple", and "clever".
22:48:54 <dsal> I don't know.  Having an eight line table of operations isn't strictly better than having the ability to rotate across directions.
22:49:01 <tolt> Does anyone know of a good way to sort through a long heap profile?
22:49:29 <monochrom> Fundamental theorem of egomanics: Everyone thinks what they write is simple, explicit, clear, readable, and what-can-possibly-go-wrong.
22:50:00 <wejetheman> but yea, this link http://codepad.org/iIL7lfxt isnt meant to be good, its really just there to help me ask the question if there is a way to get foldl use both functions rather than that ugly like 15
22:50:47 <c_wraith> at the very least, you should be pattern matching
22:51:05 <c_wraith> and probably have something like data TurnDirection = L | R
22:51:09 <dsal> wejetheman: advance == turn
22:52:09 <dsal> You could just do regular pattern matching in the definition instead of all those guards.  It'd be easier, at least.
22:52:28 <LysergicDreams> wejetheman: foldl (\robot instruction -> turn (advance robot instruction) instruction)
22:53:31 <LysergicDreams> But make fallthrough matches for advance & turn because those are partial functions at the moment.
22:53:33 <dsal> But if turn == advance, you don't need both.
22:56:54 <wejetheman>  Couldn't match expected type ‘Robot’                  with actual type ‘Robot -> t0 Char -> Robot’
22:58:09 <LysergicDreams> I know; I'd right it as a single function w/ pattern matching or a `nextOrFirst :: (Bounded a, Enum a) => ...` function but I just wanted them to have an answer to their initial question
22:59:06 <LysergicDreams> wejetheman: you still need the robot & instructions as arguments to foldl, sorry: `foldl (\r i -> turn (advance r i) i) robot instructions`
23:01:35 <wejetheman> thanks lsd, i spent hours trying to do that
23:01:52 <wejetheman> lol so easy for everyone else 
23:05:41 <LysergicDreams> It helps to pop open ghci and enter `:t foldl`. You'll see `foldl : (b -> a -> b) -> b -> t a -> b`. In your case `b` is `Robot`, `a` is a single `Char` instruction, and `t` is the list type.
23:07:11 <LysergicDreams> So that first argument becomes `Robot -> Char -> Robot`, `\r i -> ...` starts an anonymous function with robot & instruction arguments. `advance : Robot -> Char -> Robot`, so you can pass those arguments to advance to get a new Robot.
23:07:36 <LysergicDreams> `turn : Robot -> Char -> Robot`, so you pass in the Robot that `advance` returns along with the instruction to get your final `Robot`.
23:08:44 <wejetheman> im going to save all of that witchcraft and see if I can decode its meaning in the morning after coffee
23:10:09 <LysergicDreams> Err those single colons : should be doubles ::. Been writing too much Elm recently :P
23:10:51 <wejetheman> okay i updated it in the comment where i saved it all
23:11:05 <wejetheman> and I really do appreciate it all
23:31:12 * hackage tomland 1.2.1.0 - Bidirectional TOML serialization  https://hackage.haskell.org/package/tomland-1.2.1.0 (shersh)
23:31:20 <EvanR> :t getField
23:31:21 <lambdabot> error:
23:31:21 <lambdabot>     • Variable not in scope: getField
23:31:21 <lambdabot>     • Perhaps you meant ‘getFixed’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
