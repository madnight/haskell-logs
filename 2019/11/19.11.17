00:01:01 <tomjaguarpaw> jonathan_: The comment says   -- See also Note [The equality types story] in TysPrim
00:01:05 <tomjaguarpaw> so perhaps you can check there
00:08:06 <jonathan_> tomjaguarpaw: ty! :)
00:12:28 <tomjaguarpaw> :D
00:37:08 <mpickering> Is there a version of `lines` which works with windows line endings?
00:45:30 <Lycurgus> rly? the ending isn't a parameter/element of code?
00:45:37 <Athas> Oooh, 'traverse id' is a nice pattern.
00:46:17 <Athas> mpickering: you're not supposed to have "\r\n" in Strings.  Those should always be translated to/from "\n" when reading and writing from text files.
00:46:59 <Lycurgus> also dos2unix and many others including just command line skills with perl, awk, etc
00:47:10 <hololeap> Athas: traverse id = sequence
00:47:17 <mpickering> Athas: So which function which converts a `ByteString` to `Text` is supposed to do that conversion?
00:47:19 <hololeap> (well, sequenceA)
00:47:25 <Athas> hololeap: ah yes, of course, after the generalisation.
00:47:41 <Lycurgus> maybe he means there's a design pattern of that name
00:47:51 <Athas> mpickering: alright, in that case, you're on your own.  Sounds like you are getting text from a binary file.
00:48:04 <mpickering> I'm getting text from stdout
00:48:15 <Athas> Normally when you open a file you specify whether it's binary or text, and in the latter case, Windows will do the translation.
00:48:42 <mpickering> In the form of the conduit function `sourceProcessWIthStreams` which gives me two streams to deal with stdout and stderr
00:48:44 <Lycurgus> (that's what I thought, since referring to pattern matching didn register as a possibility)
00:49:15 <Athas> mpickering: I would suggest writing your own function to turn \r\n into \n when on Windows.
00:49:44 <hololeap> https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.Traversable.html#sequenceA
00:52:43 <hololeap> couldn't you just filter out every occurrance of \r ? it seems pretty safe to me.
00:56:24 <mpickering> yeah ok
00:56:28 <mpickering> I am just upset this doesn't exist
00:59:08 <hololeap> mpickering: oh, hey: https://stackoverflow.com/questions/41702549/splitting-by-lines-with-conduit-on-windows/41704243#41704243
00:59:29 <hololeap> the documentation sucks, but it does look like it will work with \r\n
00:59:33 <hololeap> https://hackage.haskell.org/package/conduit-extra-1.3.4/docs/src/Data.Conduit.Text.html#foldLines
01:03:03 <mpickering> I need a `Conduit Text Text m ()`
01:03:09 <mpickering> But yes otherwise it would work
01:03:44 <mpickering> I am using this function - http://hackage.haskell.org/package/conduit-extra-1.3.4/docs/Data-Conduit-Process.html#v:sourceProcessWithStreams
01:04:50 <mpickering> I added a filter for now, gtg
01:25:31 <jle`> do 50% of haskell users really want OverloadedStrings enabled by default?
01:25:42 <jle`> it appears so ._.
01:27:10 <amalloy> 50% of respondents to a haskell survey, which is not quite the same population
01:28:41 <Maxdamantus> 50% of Haskell users use this one really weird trick that your professor doesn't want you to know about
01:29:56 <jle`> amalloy: indeed, but now how to assess how such a bias would skew the result
01:33:49 <hololeap> Maxdamantus: TELL ME
01:33:59 <hololeap> i give u all my clicks
01:35:35 <hololeap> also, if 50% of haskellers use it, is it really that weird?
01:37:02 <Maxdamantus> If Haskellers use it, it's weird.
01:38:30 <hololeap> are you saying i sound weird when i start talking about applicative functors at parties?
01:38:37 <Athas> I use OverloadedStrings very rarely because Real Programs Don't Use Strings, but I would like it enabled by default.
01:38:51 <Athas> Seems like it has the same tradeoffs as overloaded integers, and we're fine with those.
01:42:23 <hololeap> Athas: are you saying helloWorld.hs isn't a real program?
01:42:43 <Athas> hololeap: impure filth!
01:43:25 * hololeap blushes
01:45:23 <hololeap> maybe it would be better to have a config file where you could state which extensions you want on by default
01:45:43 <hololeap> (then again, it would make for some pretty unportable code)
01:46:02 <hololeap> nvm... bad idea :D
01:47:26 <jle`> hololeap: so basically in the .cabal file? :p
01:51:26 <koz_> Something something default-extensions.
01:56:04 <jzyamateur> When I see a type signature like `T f (g a)` does it mean that the thing inside parentheses i.e. `g a` results in kind `*` ? e.g. `Maybe Int`?
01:56:39 <koz_> jzyamateur: Not necessarily. For all we know, T has kind Type -> Constraint -> Type.
01:57:03 <jle`> jzyamateur: no, consider something like StateT
01:57:10 <jle`> StateT Int (Either String)
01:57:20 <jle`> Either String is * -> *
01:57:40 <jzyamateur> Either String is `*`
01:57:46 <jle`> :k Either String
01:57:47 <lambdabot> * -> *
01:58:00 <jzyamateur> ah my bad
01:58:05 <jle`> in general you need look no further than the kind of T
01:58:13 <jle`> :k StateT
01:58:14 <lambdabot> * -> (* -> *) -> * -> *
01:58:21 <jle`> it tells you what exactly the kind of each of its inputs are
01:58:35 <jzyamateur> What exactly is significance of parantheses in type signatures?
01:58:43 <jle`> the same as for normal values
01:59:03 <jle`> > sin (2 * 3)
01:59:05 <lambdabot>  -0.27941549819892586
01:59:12 <jzyamateur> for normal values, it says that this application happens before others
01:59:13 <jle`> > 2 * (3 + 4)
01:59:15 <lambdabot>  14
01:59:26 <jle`> if that's how you put it, then sure :)
01:59:30 <jle`> it's the same thing here
01:59:34 <jzyamateur> ok
01:59:42 <jle`> consider `Maybe (Either Int Bool)`
01:59:51 <jle`> it's just saying that you are applying Maybe to `Either Int Bool`
02:00:12 <jle`> or `IO (Maybe Int)`, it means you are applying IO to `Maybe Int`
02:00:19 <jzyamateur> got it
02:00:21 <jle`> > Just (3 + 4)
02:00:23 <lambdabot>  Just 7
02:00:25 <jle`> that is saying you are applying Just to (3 + 4)
02:00:51 <jle`> generally speaking if think of `Just _` as having a "single hole", then the parentheses tells you what "goes in the hole"
02:01:01 <jle`> it's the single semantic unit that "goes in the whole"
02:01:17 <jle`> so when we write Just (3 + 4), it means that (3 + 4) "goes in the hole", so to speak
02:01:45 <jle`> and when we have something like IO _, it's waiting for a single input. so saying IO (Maybe Int), the `Maybe Int` is what "goes in" the hole in `IO _`
02:02:32 <jle`> if you feel like you have an intuition for parentheses at the value level, most of it applies also to the type level.  they play the same role in value expression syntax and in type expression syntax
02:02:59 <jzyamateur38> got iy
02:03:24 <jle`> not sure if you got my messages about IO _, Just _, etc. before the dc :)
02:03:31 <jle`> but just letting you know in case you didn't
02:04:36 <jle`> jzyamateur38: another way you can think of it is that expressions are like a tree
02:05:17 <jle`> jzyamateur38: and parentheses help you group what goes down each branch of the tree
02:05:36 <jle`> Just
02:05:40 <jle`>   +- (+)
02:05:49 <jle`>      +- 3
02:05:56 <jle`>      +- 4
02:06:01 <jle`> that is how you would parse Just (3 + 4)
02:06:20 <jle`> so the parentheses are there to tell you that that is what is directly below the first leaf under Just
02:06:45 <jle`> same for Maybe (Either Int Bool):
02:06:48 <jle`> Maybe
02:06:50 <jle`>   +- Either
02:06:54 <jle`>        +- Int
02:06:59 <jle`>        +- Bool
02:07:40 <jle`> so here the parentheses denote that the whole `Either Int Bool` part is all one single leaf under Maybe
02:07:49 <jle`> s/leaf/branch
02:09:07 <jzyamateur38> yeah, till now, I was thinking the parentheses in type signatures like `sequenceA` etc were not important. Now I realize
02:09:57 <jzyamateur38> That you cannot apply Maybe to a [], So hence the grouping. to get proper kinded values.
02:10:53 <jle`> yeah. well, on one level you can say `Maybe [] Int` doesn't make sense because of the kinds.  but also it doesn't really make sense semantically either.  what do you have a maybe *of* ?
02:11:10 <jle`> and for something like sequeceA you can have sequenceA :: Maybe (IO Int) -> IO (Maybe Int)
02:11:18 <jle`> which is a Maybe that *contains* an IO Int
02:11:41 <jle`> so like how Maybe String is a Maybe that contains a String, a Maybe (IO Int) is a Maybe that contains an IO Int
02:12:11 <jle`> so putting the parentheses there is the only way that this would make sense, semantically
02:12:54 <jle`> if you had (Maybe IO) Int....that makes no sense. not only do the kinds not match, but...the 'meaning' of sequenceA is that it takes a Maybe *containing* an IO Int
02:13:01 <jzyamateur38> Also since type signatures with arrows `->` automatically associate to the right , hence there was confusion, but I realized this is type application like normal value application.
02:13:12 * hackage gasp 1.2.0.0 - A framework of algebraic classes  https://hackage.haskell.org/package/gasp-1.2.0.0 (JeanPhilippeBernardy)
02:13:17 <jle`> so the only way to *denote* a "Maybe containing an IO Int" is Maybe (IO Int)
02:13:56 <jle`> jzyamateur38: ah yeah, we don't always put parentheses for ->, the same way we don't usually for something like 1:2:3:4:[]
02:13:59 <jzyamateur38> `a -> b -> c` is `(a -> (b -> c))` was a contributor to the confusion.
02:18:11 * hackage glpk-hs 0.7 - Comprehensive GLPK linear programming bindings  https://hackage.haskell.org/package/glpk-hs-0.7 (JeanPhilippeBernardy)
03:26:07 <b_and_w> hi
03:26:37 <b_and_w> i have a question for all you w3m users out there: do you know whether or not the default keymap file is SUPPOSED to be there by default? (in my ~/.w3m/ folder, the file is missing. I did not delete it or anything. it's simply not there.)
03:42:37 <__monty__> b_and_w: Really not the appropriate channel and it's perfectly normal for configuration files to have to be instantiated by the user.
03:46:11 * hackage egison 3.9.4 - Programming language with non-linear pattern-matching against non-free data  https://hackage.haskell.org/package/egison-3.9.4 (SatoshiEgi)
04:02:44 <b_and_w> __monty__: ok. i will instantiate it. thank u.
04:33:50 <mhpr92> Hey! I have got a Haskell program based on dynamic programming with a large array to solve a problem defined by a matrix recurrence. However, I do not need to calculate all results, I could throw away everything requiring more than a certain recurrence level x. Can you think of any way to achieve that?
04:39:32 <merijn> mhpr92: Do you know the problem size before hand?
04:40:29 <merijn> Actually, is your question how to do the dynamic programming efficiently, or do you already have that and you're optimising it?
04:40:35 <mhpr92> I know the array's bounds, yes.
04:40:47 <mhpr92> It's the latter.
04:41:32 <merijn> hmm, then I think the answer is: Insufficient information :p
04:44:35 <mhpr92> Okay, I'll try to express it more clearly... :D
04:46:33 <mhpr92> Basically, I have to calculate the result of a matrix recurrence for a lot of values.
04:47:52 <mhpr92> And in the end return only the lowest result.
04:49:19 <mhpr92> This means that while calculating one of the results, I could stop and throw it away as soon as I know that it's not going to be better than the lowest result found so far.
04:56:31 <nshepperd1> Sounds like you want branch and bound
05:00:06 <jzyamateur> The definition of `IdentityT` does not have any constraint on `f`?
05:00:10 <jzyamateur> `newtype IdentityT f a = IdentityT { runIdentityT :: f a }
05:01:14 <jzyamateur> We usually call them monad transformers? I guess the only constraint is to be of kind `* -> *`
05:01:54 <merijn> jzyamateur: Why would there be a constraint?
05:02:05 <merijn> jzyamateur: Constraints and "the kind of a type" are distinct
05:02:05 <hpc> it's the operations on it that have the constraint
05:02:28 <merijn> jzyamateur: Constraints are more like "predicates on types" where as kinds are "the "type" of a type"
05:02:31 <jzyamateur> Reading first time about monad transformers thought that it was necessary for `f` to be a monad.
05:02:59 <merijn> jzyamateur: Usually it's required for 'f' to be a Monad to ensure that the resulting transformer is a Monad
05:03:00 <jzyamateur> So the only "restriction" on `f` is to be of kind `* -> *` ?
05:03:08 <EvanR> constraint in the data type definition would be too early
05:03:40 <EvanR> but it is possible to do
05:04:33 <EvanR> :k IdentityT
05:04:34 <lambdabot> (k -> *) -> k -> *
05:04:49 <EvanR> surprise, f doesn't strictly have to be * -> *
05:06:07 <EvanR> f has kind 'kind of a' -> *
05:11:03 <nshepperd1> mhpr92: if your "result" is an integer,  an interesting idea would be to return it as a lazy integer such as http://hackage.haskell.org/package/nat
05:12:34 <nshepperd1> mhpr92: and then whenever you know a lower bound for 'x' in your calculation, write 'max lowerBound x'
05:16:29 <nshepperd1> This should have the result that unproductive branches are 'automatically' unexplored
05:17:53 <mhpr92> nshepperd1: Thank you, I will try that one.
05:18:13 <nshepperd1> Although possibly you need to write a special lazy version of max for it to work properly
05:19:24 <constantine_91> In a simple TCP client server program, If I want to keep the list of incoming connection (maintain pool of peers) then how do I achieve this, because it will require to keep a list and update operation, but update operation is like changing state. 
05:19:33 <haskesel1337> bro I can't understand typeclasses. How do i make value constructor with typeclass?
05:19:44 <mhpr92> It would be much easier with "real" recurrence, of course, where you call a real function in each recurrence step instead of just accessing a lazy array at a certain position.
05:19:59 <hpc> type classes don't have constructors
05:20:17 <hpc> they define a set of functions without implementations
05:20:25 <hpc> you can define instances which give them implementations for specific types
05:20:30 <mhpr92> Because you could add a parameter to that function "remembering" the current depth and one with the maximum depth.
05:20:33 <hpc> and then use those functions generically with a class constraint
05:20:39 <haskesel1337> how do you make a data x = a Float | b Double be accepted for a function ?
05:20:51 <haskesel1337> i cant make a f::(Floating a)=>a->...
05:21:20 <hpc> let's say you wanted to do some kind of a + b
05:21:39 <mhpr92> But with recursive array access, there is no way to achieve counting how deep you have gone so far, right?
05:21:40 <hpc> a = A (1.0 :: Float), b = B (1.0 :: Double)
05:21:42 * hackage di-df1 1.2 - Write logs in the df1 format using the di logging framework  https://hackage.haskell.org/package/di-df1-1.2 (RenzoCarbonara)
05:21:48 <haskesel1337> okay
05:21:49 <hpc> what do you expect a + b to be?
05:21:49 <merijn> constantine_91: There's a bunch of mutable variable types for that sorta thing
05:22:04 <merijn> constantine_91: You probably want either MVar or TVar from the Control.Concurrent parts of base
05:22:08 <haskesel1337> error ?
05:22:42 * hackage di 1.3 - Typeful hierarchical structured logging using di, mtl and df1.  https://hackage.haskell.org/package/di-1.3 (RenzoCarbonara)
05:22:44 <hpc> if it's an error, you probably don't necessarily want your X type to be an instance of Floating in the first place
05:23:09 <haskesel1337> okay some Floating then ?
05:23:10 <hpc> since these sorts of operations are going to error in a lot of circumstances you wouldn't expect when writing normal numeric code
05:23:26 <hpc> also for your f :: Floating a => ...
05:23:34 <hpc> you're defining that for all instances of Floating
05:23:58 <hpc> meaning everything on this instance list - https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Floating
05:24:01 <hpc> not just your X type
05:24:16 <hpc> what you probably want is f :: X -> X -> ...
05:24:37 <haskesel1337> umm I don't quite understand ...
05:24:45 <haskesel1337> can i personal chat you ?
05:25:11 <hpc> basically, ignore type classes and just write your function for your type specifically
05:25:37 <haskesel1337> ignore type class?
05:25:56 <hpc> since it sounds like you're not trying to write something generic, just do some specific operation on a specific type
05:26:12 <haskesel1337> I'm trying to understand how things work :(
05:26:22 <hpc> ah
05:26:46 <haskesel1337> absurd::(Floating x)=>x->x
05:27:12 <haskesel1337> but when using that with pattern matched type, it's an error
05:27:46 <hpc> so, a couple of things
05:27:54 <hpc> when x is lower-case, it's a type variable
05:27:54 <haskesel1337> absurd2::(Floating x)=>X->x; absurd2 (A x) = x
05:28:09 <hpc> if you want your data type X, you have to say capital X
05:28:10 <nshepperd1> mhpr92: you'd need to add extra dimensions to your array for those parameters
05:28:27 <haskesel1337> yeah I forgot to capitalize
05:28:42 <hpc> so absurd2 is what you're trying to write?
05:28:49 <haskesel1337> yeah
05:29:06 <hpc> cool, so
05:29:28 <hpc> your issue here is in "absurd2 (A x) = x", x :: Float
05:29:47 <hpc> but by the type of absurd2, it has to be able to satisfy any (Floating x => x)
05:30:04 <haskesel1337> but why in "absurd" it works bro?
05:30:14 <haskesel1337> when passing 3::Float / 3::Double
05:30:42 <hpc> because the definition of absurd is generic
05:30:46 <hpc> it's not being too specific
05:31:30 <hpc> x can only have type Float there, that's the error
05:31:39 <hpc> if absurd2 :: X -> Float, it would work
05:31:48 <hpc> (but then you'd have trouble with the B case of the X type)
05:31:52 <haskesel1337> what if i made absurd2 for B too?
05:32:07 <haskesel1337> yeah that's my confusion bro
05:32:14 <hpc> so let's look at what you can do to make a generic (Floating x) => x value
05:32:17 <hpc> https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Floating
05:32:32 <hpc> nothing there looks terribly promising, but it has a Fractional constraint so you get those operations too
05:32:40 <hpc> https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Fractional
05:32:47 <hpc> and it has fromRational
05:33:24 <hpc> there happens to be a function further down, https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#v:realToFrac
05:33:39 <hpc> which uses fromRational in a more convenient way
05:33:48 <nshepperd1> mhpr92: that sort of explicit path dependent decision making kind of breaks the dynamic programming. Like say you previously found a solution at depth 100, then later you end up at state A at depth 100. Then you want to skip evaluating the children of A and just say "the cost is at least 100 here"
05:34:17 <hpc> it requires (Real a) => a for its argument, but Float and Double both have that instance
05:34:32 <hpc> if you look at the instances at https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Float / https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Double
05:34:57 <hpc> so given either a Float or a Double, you can now produce the desired result type for absurd2
05:35:17 <nshepperd1> mhpr92: but then later if you find your way back to state A at depth 50, you certainly want to resume evaluating A's children
05:35:29 <hpc> it will be able to satisfy any type that the thing calling absurd2 could ask for
05:37:14 <nshepperd1> Lazy nats seem convenient for this, actually, since they inherently do such 'resuming'
05:37:41 * hackage haskell-lsp-types 0.18.0.0 - Haskell library for the Microsoft Language Server Protocol, data types  https://hackage.haskell.org/package/haskell-lsp-types-0.18.0.0 (AlanZimmerman)
05:39:04 <mhpr92> nshepperd1: It wouldn't "break" the dynamic programming, if the arrays were different ones for every calculation anyways, right? Because that's the case here.
05:39:11 * hackage haskell-lsp 0.18.0.0 - Haskell library for the Microsoft Language Server Protocol  https://hackage.haskell.org/package/haskell-lsp-0.18.0.0 (AlanZimmerman)
05:40:14 <nshepperd1> Not sure what you mean
05:41:15 <nshepperd1> The point of dynamic programming is to reuse the 'answer' calculated for each state in the search, which relies on the answer only depending on the state, not how you got there
05:46:00 <haskesel1337> @hpc sorry, I'm still confused, what are we doing here exactly ? so let's look at what you can do to make a generic (Floating x) => x value
05:46:00 <lambdabot> Maybe you meant: src rc pl ghc
05:46:01 <haskesel1337> https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Fractional
05:47:32 <dunce> can some one tell me whats up with this period?  `accepts d = accept d . foldl (transit d) (initial d)` before foldl
05:47:50 <haskesel1337> it's called function composition
05:48:47 <haskesel1337> (.) f g= \x -> f (g x)
05:49:43 <Joxx> Hi, I have been given a task. I did something but it seems like I'm stuck for now. Anyone willing to help me with the task? It's quite complex tho
05:50:02 <hpc> haskesel1337: so absurd2 :: Floating x => X -> x
05:50:26 <haskesel1337> yeah 
05:50:32 <hpc> haskesel1337: you have to produce a generic (Floating x => x) value here
05:50:52 <hpc> you can't just go "there's instance Floating Double so let's just return a Double"
05:51:13 <hpc> but when you have a Double, you have to somehow get to (Floating x => x)
05:51:22 <haskesel1337> but why, in absurd it can bro ?
05:51:25 <hpc> and so i went through the steps of finding that way in the docs
05:51:32 <hpc> in absurd you don't have a Double
05:51:39 <hpc> you already have that generic value from the parameter
05:51:56 <hpc> you're only specializing it when you use it
05:51:58 <hpc> not when you define it
05:52:23 <hpc> it's like you're writing (5 + 5) :: Int, you can specialize that
05:52:28 <hpc> but you can't have (+) only work on Ints
05:53:26 <haskesel1337> okay thanks bro
05:54:20 <haskesel1337> also is there any guidelines, when to be generic?
05:58:20 <hpc> i don't think there's anything in particular, you just look at the problem you're trying to solve
05:58:46 <hpc> usually being more specific is better, or making use of something that already exists by writing instances
05:58:55 <dunce> thanks (y) 
05:59:43 <haskesel1337> okay thanks
06:00:12 * hackage hOpenPGP 2.8.1 - native Haskell implementation of OpenPGP (RFC4880)  https://hackage.haskell.org/package/hOpenPGP-2.8.1 (ClintAdams)
06:02:17 <Joxx> I have created a list and now I have to go through the list again and rewrite an element to another when the position is equal to a tuple from a list of tuples. How do I proceed?
06:04:00 <haskesel1337> give me an example input / output 
06:04:58 <Joxx> pp(ticktack (8,8) [(1,1),(8,8),(2,2),(3,3),(4,2),(3,2)])
06:05:08 <Joxx> ----------|       o||        ||        ||        ||        ||  o     || xox    ||x       |----------
06:05:56 <Joxx> pp :: [String] -> IO ()pp x = putStr (concat (map (++"\n") x))
06:06:53 <Joxx> pp function is basically a function which each element of a list displays on a new line
06:11:41 * hackage lsp-test 0.8.1.0 - Functional test framework for LSP servers.  https://hackage.haskell.org/package/lsp-test-0.8.1.0 (luke_)
06:12:40 <Joxx> It should go like this
06:12:42 <Joxx> https://prntscr.com/py4jy0
06:14:03 <jzyamateur> So I am trying to define my own monad instance for `IdentityT`, I am not able to understand why `(>>=) (IdentityT ka) fn = ka >>= fn
06:15:28 <jzyamateur> https://gist.github.com/chetnashah/ce4a46c2ac3df17906e3b8fa0e05486b line no. 22 seems correct logically.
06:15:54 <jzyamateur> https://gist.github.com/chetnashah/ce4a46c2ac3df17906e3b8fa0e05486b#file-test25-hs-L22
06:16:57 <jzyamateur> Have been at it for 1+ hr, seems something trivial that I don't know.
06:28:45 <lyxia> jzyamateur: what error do you get
06:30:11 * hackage lsp-test 0.8.2.0 - Functional test framework for LSP servers.  https://hackage.haskell.org/package/lsp-test-0.8.2.0 (luke_)
06:30:17 <infinity0> has anyone used ghc 8.8.1 yet
06:30:28 <infinity0> i notice it contains base 4.13 but the latest version on hackage is 4.12
06:31:58 <lyxia> yes there are server issues to be solved before base can be published on hackage
06:35:33 <Joxx> Anyone willing to help me?
06:36:18 <Joxx> This is the input & output
06:36:21 <Joxx> https://prnt.sc/py4sbq
06:37:22 <Joxx> I have created an empty playing screen and now I have to go though that screen ( [String] ) and fill it with 'x's and 'o's where needed
06:44:31 <Pranz[m]> What problem have you run into? Joxx 
06:45:10 <Joxx> I have created an empty playing screen and now I have to go though that screen ( [String] ) and fill it with 'x's and 'o's where needed. I don't know how to proceed
06:46:51 <Pranz[m]> wouldn't it be easier to use the existing `ticktack` function for filling in the 'x's and 'o's?
06:47:50 <Joxx> I have to create that function
06:47:59 <Joxx> Implement the function ticktack which has 2 arguments. First argument is a tuple of natural numbers and defines the number of rows and columns of a play field. Second list contains a record of a match of ticktacktoe game given by coordinates on which played in turns player 'x' and player 'o'. Print actual state of the game in the way where
06:48:00 <Joxx> play-field will be bordered by characters '-' and '|', empty squares ' ' and characters 'x' and 'o' will be on squares where the players have played. 
06:49:23 <Pranz[m]> oh I see.
06:51:28 <Pranz[m]> Well, if I were you I would start off by defining a helper function `getTileChar`, which takes in a tuple `(x,y)`, denoting the tile position, and the list of coordinates that have been played on
06:52:09 <Pranz[m]> once you have that function the task becomes much easier
06:56:15 <Joxx> To get a tile where there should be 'x' or 'o', but still is a space and replacing it with the actual 'x' or 'o'?
07:02:04 <talles> Hi,
07:02:24 <talles> Does anyone know, how to use a data like, data CellType = Mine | Empty
07:02:24 <talles>                   deriving (Show, Read, Eq)
07:03:05 <talles> to place a string, example, when there is Mine I want to place "*" and Empty "#"
07:03:23 <pta2002> is there any function that splits a list every time a function is met
07:03:24 <pta2002> like
07:03:58 <pta2002> splitOn even [1,1,2,3,4] = [[1,1],[2,3],[4]]
07:04:11 <pta2002> or even = [[1,1,2],[3,4]]
07:04:21 <pta2002> more keen on the latter
07:05:39 <pta2002> i mean not particularly difficult to implement
07:07:33 <infinity0> pta2002: https://hoogle.haskell.org/?hoogle=%5Ba%5D+-%3E+%28a+-%3E+Bool%29+-%3E+%5B%5Ba%5D%5D&scope=set%3Astackage
07:08:08 <pta2002> oh splitWhen that's what i want
07:08:26 <pta2002> no it isn't it removes the element
07:09:00 <infinity0> "Equivalent to split . dropDelims . whenElt" maybe you can drop "dropDelims" and see if it works
07:15:46 <lavalike> > groupBy (const odd) [1,1,2,3,4]
07:15:48 <lambdabot>  [[1,1],[2,3],[4]]
07:19:28 <infinity0> that would be brittle if the internal implementation of groupBy changes (e.g. to be more efficient) no?
07:19:40 <infinity0> const odd is not an equivalence relation, it is not symmetric
07:21:44 <lavalike> I think groupBy can't do the second version
07:48:18 <talles> Hi, If I have a matrix defined like this:
07:48:27 <talles> newtype Tabuleiro = Tabuleiro { unwrap :: Matrix CellType                    deriving (Show)
07:48:44 <talles> and I wanna use the getElem x y m1, 
07:49:04 <talles> I need to write a custom function like this? returnPosition :: Tabuleiro -> CellType
07:49:17 <talles> returnPosition pos = getElem pos tg?
07:54:24 <geekosaur> not like that, no; you need at minimum to use unwrap to get at the Matrix. and want the type signature to include both the newtype and the position of the element
07:55:31 <talles> Can you help me?
07:55:44 <talles> I don't know how to do this
07:56:15 <geekosaur> I know what you ned to do, but if this is an assignment you won't gain anything from my doing it for you
07:56:32 <talles> I need to delivery at the end of the day 
07:57:26 <talles> I've try many ways but get no result 
07:57:47 <talles> returnPosition :: (Int,Int) -> Tabuleiro -> CellType
07:59:07 <talles> I understand what need to be done, but I really new with Haskell, in C style, I iterate in the vector and return the given value in the given position
08:12:39 <Pranz[m]> So you still need to iterate over it obviously, but in haskell it is done with recursion
08:14:19 <talles> Yeap, that's the hard part 
08:18:30 <Pranz[m]> You should be familliar with how `(!!)` is implemented, yeah?
08:18:56 <talles> given a position, it returns the value in that position
08:19:00 <talles> Let me try this way
08:19:38 <Pranz[m]> I don't mean what it does, I mean how it does it
08:19:55 <talles> No, the implementation I don't know 
08:20:24 <Pranz[m]> Then I think you should first try implementing a function like that on lists first
08:20:54 <Pranz[m]> try to figure out a way to do it, by using recursion
08:21:02 <bwe> What are your experiences with different approaches for the records problem? https://nikita-volkov.github.io/record/ https://hackage.haskell.org/package/optics-core-0.2/docs/Optics-Label.html, https://github.com/turingjump/bookkeeper or...
08:21:07 <Pranz[m]> I'm willing to bet the function you need to implement is gonna be very similiar to `(!!)`
08:22:43 <talles> I really like to inside what is inside and how it works, but due to the timeline I have, I'll leave the code without this, because I think my health is more important than learn Haskell in one week, just for academic purposes 
08:23:40 <talles> *I really like to see what is inside 
08:32:07 <zincy_> Anyone have any ideas why a websocket server would work fine locally but not in production behind a load balancer
08:33:00 <zincy_> On the deployed server messages have to be sent multiple times to get through very frequently 
08:42:24 <Geekingfrog> zincy_, websocket connections comming from webbrosers?
08:56:10 <zincy_> Geekingfrog: Yes
08:57:40 <Geekingfrog> without anything it's a bit hard to say. But usually there is a first http request to upgrade the connection, then websocket takes over. The load balancer may not like this protocol switching, depending at what level it operates.
08:58:17 <zincy_> The funny thing is
08:58:28 <zincy_> The first few messages go through perfectly
08:58:58 <zincy_> and then there is this kind sporadic effect where messages need to be sent many times to actually update the server
09:00:02 <gentauro> anybody knows if `ghcjs` makes dead-code-elimination like `PureScript`?
09:27:10 <asheshambasta> https://github.com/jyp/dante/issues/133 any obvious pointers on this issue will be appreciated. 
09:34:32 <asheshambasta> on a bit more experimenting, it seems like the flycheck errors can only be found after closing the file and reopening it. 
09:41:42 <sm[m]> @freenode_asheshambasta:matrix.org: not sure what you are doing but I haven’t seen that with ghcide + flycheck
09:41:42 <lambdabot> Unknown command, try @list
09:43:55 <zincy_> Anyone know how to print the contents of a mailbox from pipes-concurrency without removing any items?
09:44:20 <asheshambasta> sm[m]: in my case, I think I've found the issue via some guesswork: I had a custom keybinding to format the buffer using brittany and then save it. At the end of the function, I was re-reading the file from the disk (after brittany had formatted and written it) via a `revert-buffer t t t`; and that seems to have been the cause. 
09:45:38 <asheshambasta> afaics, the issue was with the PRESERVE-MODES argument: `
09:45:38 <asheshambasta> (revert-buffer &optional IGNORE-AUTO NOCONFIRM PRESERVE-MODES)
09:45:38 <asheshambasta> ` 
09:47:09 <asheshambasta> I'm not sure why removing `t` in that case seems to have done the trick, but it has. 
10:41:01 <dmj`> gentauro: -dedupe flag should do this
11:30:41 * hackage store 0.7.1 - Fast binary serialization  https://hackage.haskell.org/package/store-0.7.1 (MichaelSloan)
11:30:55 <tom__> Even though Haskell has excellent concurrency
11:31:03 <tom__> There is massive scope for improving it further
11:34:17 <dsal> tom__: Is something affecting you currently?
11:46:32 <electricityZZZZ> where can i read about real world situations (rather than hypothetical learning examples) where lazy evaluation makes a night and day difference in performance, memory use, reliability, is a logical requirement for implementation, or is otherwise very important for implementation?
11:47:13 <electricityZZZZ> please don't tell me about some one-off list thing which lets me skip evaluation of non-even numbers or somesuch
11:48:10 <dmj`> electricityZZZZ: nix is a good example of how laziness brings a lot of power
11:48:48 <dmj`> electricityZZZZ: you can import every single package of nixpkgs into any build script, but only the ones that get referenced are evaluated. 
11:49:03 <dmj`> evaluation is outside in, as opposed to inside out when it comes to laziness
11:49:59 <dmj`> electricityZZZZ: for example in python if you have a function like this def foo (x, y): return y, and used it like foo(calcTillionDigitsOfPi(), 1)
11:50:44 <dmj`> electricityZZZZ: you'd be waiting forever for it to finish calculating all the digits of pi, only then not to use the result at all. In Haskell / nix, since x is never referenced it never gets evaluated, simply remains an unevaluated thunk
11:50:50 <electricityZZZZ> i know what lazy eval is
11:50:57 <electricityZZZZ> my question is what are real world situations where it is essential
11:51:02 <dmj`> I just gave you one
11:51:39 <tom__> electricityZZZZ: Definitely essential in that case described
11:52:22 <infinity0> electricityZZZZ: an "iterator" in most programming languages is effectively a list in haskell
11:53:03 <infinity0> also, i don't think you really know what lazy eval is. lots of things are lazy eval but not called lazy eval, like everywhere
11:53:48 <tom__> Is it fair to say lazy eval is just not computing something until you need its result?
11:54:08 <tom__> and that haskell just has this built in the language
11:54:18 <tom__> but other strict languages can have laziness through libraries
11:54:39 <tom__> dsal: Yes
11:55:32 <infinity0> lazy eval in haskell is simply not evaluating an inner expression until the outer expression needs to do a "case" match on it i.e. check what the first layer of wrapping it
11:55:46 <infinity0> in other languages you would define a function that takes 0 arguments instead, and people often do this
11:58:06 <tom__> ah thanks
12:00:01 <nshepperd1> The ? : operator in C evaluates its arguments lazily
12:03:02 <EvanR> also in haskell the lazy result is shared so you don't have to recompute it
12:04:39 <geekosaur> we often use repeat to pair a value against elements of another list, and repeat "produces an infinite list" but in this use case only produces enough to satisfy the other list
12:05:10 <geekosaur> lazy eval doesn't mean you can do more things, but it does mean that different ways of doing things will work
12:08:34 <electricityZZZZ> nshepperd1: heh interssting
12:14:05 <f-a> I am trying to write a small script (using shelly)
12:14:33 <f-a> It needs to pick up an executable (cabal built) some data and zip it
12:14:49 <f-a> now, I see that cabal builds here dist-newstyle/build/i386-linux/ghc-8.6.4/venzone-0.3.0.0/build/venzone
12:15:32 <f-a> but it seems silly to hardcode the path. Where do I get the relevant/appropriate "i386-linux" and "ghc-8.6.4" ?
12:19:28 <TheCommieDuck> How on earth can I represent a huge state (in this case, something resembling a game world) with a variety of different pieces of data (in this case, different game objects of form Object a with specific 'a's) functionally? I know I can 'wrap' them in corresponding functions and then store e.g. a list of [render x, renderDifferent y, renderSomething z] but then what if I want to change x?
12:21:54 <TheCommieDuck> having a really big record type with fields for each different possible type works, but feels incredibly messy.
12:22:39 <EvanR> i am doing somthing like that right now
12:23:06 <EvanR> the world state is nested records
12:23:37 <TheCommieDuck> I mean I don't know why bigListOfThings :: HList Things is somehow better than rocks :: Rocks, people :: People, cars :: Cars, etc
12:23:53 <EvanR> i don't either, i don't believe it is
12:25:03 <f-a> TheCommieDuck: I went for the gigantic sumtype approach
12:25:05 <f-a> https://hub.darcs.net/ffaf/venzone/browse/src/Meeple/Primitives.hs#302
12:25:26 <f-a> and basically rewriting it to abuse microlens
12:25:36 <f-a> and effectively deferring some type errors at runtime
12:25:43 <EvanR> we're basically talking about how to implement a database
12:25:51 <TheCommieDuck> els = some kind of error message?
12:26:08 <f-a> if you two come up with a sensible and/or battle tested approach, please shar- TheCommieDuck , yes
12:26:27 <EvanR> records, hlist, tuples, maps are all serving the same essential purpose
12:26:30 <TheCommieDuck> I mean the 'sensible' approach I can think of is just plain old entity-component systems
12:26:46 <CrazyPython> (Have you considered using D for this project? If you use mostly pure @safe functions, you can write a D function that auto-parallelizes your program. D has a GC too.)
12:27:13 <f-a> TheCommieDuck: my idea would be to come up with some TH trickery to generate "hasCapability" functions, and then a safeMapSomething function
12:27:17 <EvanR> CrazyPython who are you asking this?
12:27:27 <CrazyPython> the person with the game
12:27:30 <TheCommieDuck> but I just...cannot grok my head around the haskell-y implementations and I don't like blackbox waving hands
12:27:35 <f-a> basically a dynamic way of handling it
12:27:36 <EvanR> i think all three of us have a game right now
12:27:40 <f-a> hehe yeah CrazyPython 
12:27:57 <TheCommieDuck> and if me, then...well, I'm mostly doing it because haskell seemed fun to learn :P this is the...5th language I've made an attempt at this identical thing in
12:28:10 <TheCommieDuck> first C#, then prolog, then python, then julia, now haskell
12:28:42 <CrazyPython> well, I have a game in production I helped work on... It runs @ http://arras.io
12:29:16 <CrazyPython> It's written in Node.JS, but if I were you I would not write it in node.js no matter what kind of game it is
12:29:52 <CrazyPython> I am considering rewriting it in D (write a websocket and an event loop in D, then apply regexes)
12:30:17 <TheCommieDuck> but yeah, I can't think of another option outside of the 3. Big sum type and then just loads of pattern matching at the end, big record type and then having to keep adding new bits to it as you go (I guess e.g. vinyl? makes this easier?), or doing something black magic-y
12:30:37 <CrazyPython> I am just curious, why Haskell?
12:30:49 <zincy_> TheCommieDuck: I started a poker app in NodeJS and it only really was feasible now in Haskell
12:31:53 <TheCommieDuck> it's been on my 'tolearn' list for a while, I value enjoyment through programming over the enjoyment of an end product, I find the mathematical side of programming far more exciting than the actual writing, and haskell seemed like it would be a good use for this use case. and it is, mostly.
12:32:10 <EvanR> ++
12:32:40 <EvanR> i support the seemingly nonsensical pursuit of "haskell games"
12:32:54 <TheCommieDuck> if I ignore this massive headache I've had with keeping a state updated, I just find it really nice to think in input in -> input out rather than changing variables.
12:33:26 <f-a> TheCommieDuck: you are using microlens or similar, right?
12:33:36 <TheCommieDuck> I'm using regular lens
12:33:54 <TheCommieDuck> I *just* about grok what lenses do, I have no clue why there are 500 variants of lens
12:34:09 <TheCommieDuck> lens, generic-lens, lens-sop, silica, microlens...
12:34:31 <f-a> micro because I have an old pc
12:34:36 <EvanR> you can easily make your own version of lens... so people apparently do :)
12:34:41 <f-a> and don't want to rebuild all hackage
12:35:28 <TheCommieDuck> that's another point on haskell: all these crazy libraries that are simply things you could write yourself if you wanted (even things like state monads), to me, just shows the flexibility of doing cool stuff
12:35:42 <geekosaur> the problem with lens is everyone has their own list of things they want wired into it
12:36:29 <TheCommieDuck> I've still not used anything in lens except view, set, and over and I can't work out anything else I'd want other than "given an X, keep iterating through nestings until you find a Y and apply this lens"
12:37:50 <f-a> TheCommieDuck: have you used any ECS haskell library?
12:37:58 <f-a> I am wholling ignorant and wanted to give it a go
12:38:11 <TheCommieDuck> I've not
12:38:23 <f-a> seems better than my "half reinvent a badly designed dynamic typing"
12:38:28 <TheCommieDuck> I swear I combed every piece of ECS literature back in 2012 when I was big into gamedev
12:38:46 <TheCommieDuck> but the haskell ecs libraries (or at least ecstasy and apecs) I just can't understand
12:41:58 <TheCommieDuck> I think I'm just going to go with the big record type over the big sum type
12:42:08 <TheCommieDuck> https://github.com/TheCommieDuck/Catnip (here's what I've been working on so far fwiw)
12:43:30 <f-a> TheCommieDuck: for us cabal folks, consider adding .cabal to git repo :)
12:43:34 <EvanR> a record to hold a set of rocks, a set of cars, etc seems like a no brainer
12:44:28 * f-a has no idea what records are
12:44:38 <EvanR> a tuple with field names
12:44:39 <f-a> those vinyl type trickeries?
12:44:40 <TheCommieDuck> oh. yes. honestly I'm so clueless about stack and cabal and everything I actually decided to quit haskell a couple days into the project because I couldn't work out how to use stack to get an interactive prompt with my code loaded in
12:44:59 <TheCommieDuck> (I later found out it's just `stack ghci`.)
12:45:32 <EvanR> MyWorld {rocks=x, cars=y, ...}
12:45:41 * hackage pipes-network-tls 0.4 - TLS-secured network connections support for pipes.  https://hackage.haskell.org/package/pipes-network-tls-0.4 (RenzoCarbonara)
12:46:40 <merijn> TheCommieDuck: https://gist.github.com/merijn/8152d561fb8b011f9313c48d876ceb07
12:46:44 <f-a> EvanR: oh, those! thanks
12:47:00 <TheCommieDuck> yes, but then it's just awkward if I want to have very simple object inheritance without pain: e.g. I want BaseWorld { rocks, cars, trees, people... } and then SpecificWorld {BasicWorld, dinosaurs, volcanoes} and SpecificWorld2 { BasicWorld, spaceships, stars, aliens...}
12:47:41 <TheCommieDuck> is the .cabal not just Catnip.cabal? that's the one I've been editing when adding libraries
12:47:56 <f-a> f@x60s:/tmp/Catnip$ ls
12:47:56 <f-a> LICENSE  package.yaml  README.md  Setup.hs  src  stack.yaml
12:47:57 <TheCommieDuck> oh, it hasn't commited it, my bad
12:48:00 <f-a> this is from cl- yeah
12:48:27 <merijn> TheCommieDuck: If you edit the Catnip.cabal file manually I'd recommend just getting rid of package.yaml (in fact, I would recommend that anyway!) ;)
12:48:57 <f-a> TheCommieDuck: fyi there is a #haskell-game where we share and discuss
12:49:22 <TheCommieDuck> yus, thanks both of you (and evan further up and everyone else) :)
12:49:32 <EvanR> TheCommieDuck: inheritance.....
12:49:37 <EvanR> sounds suspicious
12:50:14 <TheCommieDuck> I just mean inheritance as a shortform SpecificX { X :: BaseX, other things ... } without having to then preface everything with SpecificX ^. X
12:50:29 <TheCommieDuck> solely extended records, no OO-nonsense
12:50:33 <EvanR> this kind of modeling sounds very OO
12:50:52 <f-a> that's what makeClassy does, no?
12:51:01 <TheCommieDuck> likely!
12:51:05 <merijn> f-a: Make typeclass based lenses
12:51:28 <merijn> f-a: i.e. create a HasFoo typeclass with a lens that uses it so you can reuse the same lens for multiple types
12:51:36 <TheCommieDuck> yes literally makeClassy
12:52:18 <EvanR> TheCommieDuck: if many kinds of objects act like BaseX, then it might be prudent to take it out of all the objects and make a single BaseX part of your database.
12:52:30 <EvanR> to rule them all
12:52:54 <EvanR> distributing them to all the varying types doesn't sound like it helps
12:53:11 <TheCommieDuck> oh for sure, should've clarified what I meant more
12:53:12 * hackage xlsx 0.8.0 - Simple and incomplete Excel file parser/writer  https://hackage.haskell.org/package/xlsx-0.8.0 (KirillZaborsky)
12:54:01 <TheCommieDuck> in this case, my baseX would be this world state with cars and rocks and everything; then if I wanted to use this stuff in two projects, each with different various things in them, I'd have to be copypasting the world state and adding a bunch of extra junk to it
12:54:15 <TheCommieDuck> rather than just a record of "start with these fields and add a bunch more"
12:54:44 <EvanR> basically prototype based OOP
12:55:01 <EvanR> haskell really doesn't like that
12:55:14 <merijn> Debatable
12:55:31 <EvanR> please do
12:55:34 <TheCommieDuck> I understand why, but...I also don't? like it's not breaking the function-first nature of FP
12:55:50 <merijn> Interface represented by record of functions is a perfectly fine and useful design approach for some problems, IMO
12:56:00 <CrazyPython> you sacrifice type safety when you use prototypes
12:56:03 <EvanR> a record of function is fine
12:56:22 <EvanR> prototype means you have a record of functions with fallbacks to other records if the field is missing
12:56:25 <merijn> EvanR: Can you distinguish what exactly makes prototype OO different from that?
12:56:41 <merijn> EvanR: That's easy enough to implement via wrapping upon creation
12:56:48 <EvanR> yeah i was just thinking that
12:56:54 <TheCommieDuck> oh, yes. I see now.
12:56:58 <merijn> Which seems perfectly reasonable, tbh
12:57:11 <EvanR> haven't fully worked out the ergonomics though
12:57:31 <merijn> Generally you capture the state in an MVar/TVar/IORef/etc.
12:57:44 <EvanR> or do you mean, have an entirely other record type which is a subrecord type and do manually mapping?
12:57:52 <merijn> So you get an opaque "IO MyObject" or "Foo -> Bar -> IO MyObject"
12:58:01 <EvanR> that is what TheCommieDuck doesn't want to do
12:58:04 <merijn> EvanR: Whichever seems easiest to implement
12:58:52 <EvanR> if you implement the records as functions, i see lookups being easy to implement
12:59:09 <EvanR> but i don't see how to get the types right
12:59:12 <f-a> TheCommieDuck: I ran it, is that a game or prolog :P
12:59:39 <EvanR> TheCommieDuck: coming full circle to the vinyl or HList... that also gives you a poor mans sort of prototype
13:00:58 <merijn> *sigh*
13:01:08 <merijn> Debugging races without an easy reproducing case sucks
13:01:15 <EvanR> TheCommieDuck: in my current attempt, i am combining simpler systems into more complex systems with a combiner operation. I could imagine if it worked out, adding onto a world would not be that hard. 
13:01:17 <Athas> So, in the wonderful world of cabal 2, what's the easiest way to compile a standalone .hs program against some cabal library that I have cloned from GitHub?
13:01:22 <TheCommieDuck> f-a: it's a very very bare bones start of things :P
13:01:32 <Athas> I can 'cabal build' the library just fine.  I vaguely remember something about environment files.
13:01:32 <EvanR> so instead of prototype, it's just concatenations
13:01:37 <merijn> Athas: cabal 2 as in "without v2-build" or what?
13:01:48 <f-a> TheCommieDuck: what's the genre?
13:01:53 <f-a> CYOA? IF?
13:02:14 <Athas> merijn: uh, I guess I actually mean cabal 3.  I mean with Nix-style builds.
13:02:23 <Athas> In the old days I'd just 'cabal install' into the global database.
13:02:25 <TheCommieDuck> the *long term plan* is somewhere between IF and a roguelike (specifically, along the lines of DF/URR. of course nowhere near the same scale.)
13:02:28 <merijn> Athas: The environment stuff isn't really relevant
13:02:44 <merijn> Athas: If you want to depend on local checkouts you can use cabal.project
13:02:46 <f-a> very good TheCommieDuck , keep me posted on updates please!
13:03:05 <Athas> merijn: is there any way to do it without writing files?
13:03:22 <Athas> I don't want to write a .cabal file at all, either.
13:03:22 <TheCommieDuck> using the 300+ inform7 examples as a test suite, which also means I can basically just roughly port the inform7 language to haskell. which is nice, because 98% of it is pure inform7 and written in the documentation appendices
13:03:48 <geekosaur> Athas: just use the cabal file from the manual checkout and add a dep to the library you (v2-)built
13:03:51 <merijn> Athas: eh, maybe, but I wouldn't how, since it's just one line anyway
13:03:51 <Athas> I just have an .hs program that is a PoC of a bug in a library, and I want to compile and run that program.
13:03:58 <f-a> excellent TheCommieDuck 
13:04:13 <merijn> Athas: Ah, that way
13:04:17 <geekosaur> you do need a cabal file (whatever.cabal)
13:04:38 <Athas> The library has a .cabal file.  Surely I don't need a .cabal file for a quick throwaway program?
13:04:49 <merijn> geekosaur: Well, you don't he could use the environment file stuff and manually install a version then "cabal exec ghc", but that's a hassle
13:05:06 <geekosaur> that was what he was asking about at first
13:05:20 <geekosaur> they were
13:05:24 <merijn> Athas: The environment stuff would work, but the workflow for that is...being fleshed out
13:05:35 <TheCommieDuck> final thing before diving back into messing about with this pile: is there any overhead likely about having a huge record type?
13:05:39 <merijn> Athas: You could just v1-install and compile that :p
13:05:59 <geekosaur> but for anything else a cabal file is needed. this has been annoying me a bit as well woth some local stuff which i sytarted to migrate from cabal1, but enh
13:06:22 <Athas> Actually, 'cabal exec bash' works fine as long as I then don't try to compile inside the folder containing the library (because then the imports will pick up the un-compiled files rather than the installed library).
13:06:31 <EvanR> TheCommieDuck: a huge record will take more work to update than many smaller nested records
13:06:45 <geekosaur> I'm finding more annoying that I can't use more than one cabal file in a directory of one-file programs
13:07:01 <EvanR> but a huge record will have less work to do lookups in
13:07:11 <geekosaur> so I end up with a bunch of tiny directories
13:08:03 <TheCommieDuck> are we talking actually significant levels of time, or sort of extra nanoseconds
13:08:16 <EvanR> only profiling could tell
13:08:57 <TheCommieDuck> well I suppose one of the advantages of haskell is it tells you pre-compile if you do choose to nest everything after;p thanks
13:12:43 <merijn> geekosaur: Or just put all executables in the same cabal file :p
13:12:48 <merijn> geekosaur: <- galaxy brain
13:14:01 <merijn> So...anyone up for a challenge coming up with an easily reproducible testcase for a race condition that my brain is too fried to invent? :p
13:17:07 <f-a> since we are talking about game, I will ask a related question
13:17:32 <f-a> I went with the sum type approach https://hub.darcs.net/ffaf/venzone/browse/src/Meeple/Primitives.hs#302
13:18:07 <f-a> and instead of constant pattern matching I would really love a series of hasWalk functions on the sumtype (notice lowercase 'h')
13:18:14 <d34df00d> How would you go about turning a list of key-value pairs like [("Foo", Bool True), ("Bar.Baz", String "meh"), ...] into a nested Data.Aeson.Object (which encodes to { "Foo": true, "Bar": { "Baz": "meh" } })?
13:18:18 <f-a> is this doable via TH (or already done)?
13:19:00 <d34df00d> I think of folding over the list, breaking each key by the dot and recursing on the resulting list and doing Data.HashMap.update (or adjust, or whatever it is) on every component.
13:19:09 <d34df00d> But it feels too imperative. Can I do better?
13:19:28 <Darwin226> So after all these years. Is there a way to enable profiling in my project without recompiling every dependency? I don't want to profile any of the code that isn't in my own project
13:19:55 <merijn> Darwin226: How would that work?
13:20:21 <Darwin226> I never needed to recompile anything when I profiled my code in any other language I used
13:20:24 <merijn> Darwin226: If your code passes a function to an external library (say, map's argument or whatever) how would you profile that
13:20:40 <EvanR> d34df00d: man... that's rough :)
13:20:59 <d34df00d> EvanR: so I wanna be less rough!
13:21:05 <Darwin226> merijn How do other languages do it
13:21:09 <merijn> Darwin226: That's because C/C++ generally profile by inspecting the instruction counter and mapping that back to code, which is tricky with haskell because many closures end up, say, on the heap
13:21:27 <merijn> Darwin226: So you could do that in Haskell, but it'd be unintelligible without *a lot* of effort
13:21:59 <Darwin226> merijn What do managed languages do?
13:22:56 <merijn> Darwin226: Basically the same, but with an extra "attribute VM codelines back to their calling code" step, which you can reconstruct from the call stack
13:23:11 <merijn> Darwin226: But GHC Haskell doesn't have a callstack to do similar attribution
13:23:35 <f-a> (and a slightly less difficult question: how do I know which OS/arch I am running on? Looked at System.Environment but came up empty handed)
13:23:36 <merijn> Darwin226: Which is exactly what the profiling builds do, insert instrumentation to build a "fake" callstack to attribute profiling samples to source code
13:24:06 <Darwin226> merijn Damn... Ok then, is there a way to at least only rebuild my dependencies ONCE?
13:24:16 <merijn> f-a: https://hackage.haskell.org/package/base-4.12.0.0/docs/System-Info.html ?
13:24:27 <Darwin226> every time I switch between non-profile and profile builds everything recompiles
13:24:29 <f-a> thanks merijn 
13:24:38 <merijn> Darwin226: Which build system?
13:24:44 <Darwin226> Stack in this case
13:24:59 <d34df00d> Darwin226: how do you build for profiling? Just stack build --profile?
13:25:03 <merijn> I have no clue about stack, v2-build only rebuilds profiling dependencies once
13:25:09 <Darwin226> d34df00d yeah
13:25:14 <d34df00d> Dunno, #worksforme.
13:25:31 <d34df00d> It builds the deps once, sure, but after that I can do arbitrary number of `stack build` vs `stack build --profile` with arbitrary interleaving.
13:25:34 <d34df00d> And it does the right job.
13:25:35 <Darwin226> merijn I might just switch to cabal for this project if that's true
13:25:55 <geekosaur> are you running recent stack? iirc that used to be a bug
13:26:05 <Darwin226> the latest and greatest
13:26:19 <merijn> Darwin226: Any local (i.e. git checkout/clones) dependencies and your package itself are rebuild each time, of course, but the dependencies only the first (unless you update and it computes a new build plan)
13:32:43 <Darwin226> Perhaps I switched resolvers at some point
13:33:08 <Darwin226> But I'm not switching to test because the gl library is in it's 25th minute of compiling
13:33:46 <gentauro> 19:40 < dmj`> gentauro: -dedupe flag should do this
13:33:48 <gentauro> thx :)
13:34:05 <dmj`> gentauro: np
13:34:31 <dmj`> gentauro: closure-compiler will also do this as well, which I recommend you use, with advanced optimizations
13:38:03 <EvanR> am i missing a more obvious operator for liftA2 (.)
13:38:34 <EvanR> or repeated uses of this in a row
13:40:11 * hackage clay 0.13.2 - CSS preprocessor as embedded Haskell.  https://hackage.haskell.org/package/clay-0.13.2 (turion)
13:47:23 <gentauro> dmj`: Until now, nothing really beats PureScript :)
13:47:47 <gentauro> but I would like that GHCJS did this so I could switch to it ;)
13:50:08 <dmj`> gentauro: GHCJS + closure-compiler beats purescript
13:50:34 <dmj`> you get true type sharing, small payload, large ecosystem, good FFI
13:50:35 <gentauro> dmj`: https://pastebin.com/JtZ1VWmZ
13:51:00 <dmj`> gentauro: are you just minifying or closure compiling
13:51:10 <gentauro> that's a simple hellow world printing to the console :)
13:51:46 <gentauro> dmj`: I'm compiling with PS and then bundling
13:51:58 <gentauro> bundle is what makes the dead-code-elimination
13:52:03 <gentauro> iirc
13:52:20 <gentauro> (the usage of `js-min` seems a bit irrelevant)
13:56:51 <dmj`> gentauro: GHCJS bundles by default into all.js, this includes anything in js-sources
13:57:03 <dmj`> gentauro: closure-compilation will do a lot more than just minify
13:58:45 <gentauro> dmj`: this is what I have read
13:58:59 <nisstyre> dmj`: does ghcjs compile to something similar to stg?
13:59:16 <dmj`> nisstyre: ghcjs compiles STG to JS, and links with its own rts.js
13:59:22 <nisstyre> nice
13:59:26 <gentauro> that with GHCJS all code goes to `all.js`. I'm hopping that the -dedupe flag removes unused stuff :)
13:59:38 <gentauro> (which would make the closure-compiler irrelevant)
13:59:49 <dmj`> gentauro: not necessarily
14:00:12 <nisstyre> by closure-compiler you mean how it converts lexically scoped functions to closures?
14:00:14 <dmj`> it's like extreme compression
14:00:21 <dmj`> https://developers.google.com/closure/compiler/docs/api-tutorial3
14:00:52 <dmj`> it will do variable renaming of the js, I don't think -dedupe does this
14:00:56 <nisstyre> ohhh closure as in google's thing
14:01:04 <dmj`> and function inlining
14:01:05 <nisstyre> I was confused
14:03:25 <gentauro> dmj`: PureScript bundle, checks if code is used. If not, it removes that branch
14:03:34 <gentauro> leaving very minimalistic .js files
14:03:41 <gentauro> aka `dead-code-elimination`
14:03:46 <gentauro> it's not just renaming stuff
14:04:49 <dmj`> -dedupe will do that, and so will google's closure compiler
14:05:01 <dmj`> along with variable renaming and inling, and more
14:05:28 <dmj`> ghcjs was made to be compatible with closure compiler's advanced optimizations
14:06:19 <gentauro> 23:04 < dmj`> -dedupe will do that
14:06:27 <gentauro> Nice, that's the feature I'm looking for :)
14:06:39 <gentauro> (and what made me go from Elm to PS in the first place)
14:07:20 <dmj`> you can use closure-compiler on Elm's output to get that though
14:11:11 * hackage sitepipe 0.4.0.1 - A simple to understand static site generator  https://hackage.haskell.org/package/sitepipe-0.4.0.1 (ChrisPenner)
14:39:00 <arampaa> Hi, noob question here. I'm currently working on the following task:The everyday life of an imaginary country is impaired due to frequent strikes from the country's political parties.To regulate things, it is only possible for each party to call on a daily strike between fixed intervals.It is possible for multiple parties to call on a strike on the
14:39:01 <arampaa> same day.However, it is not allowed to call on a strike on Fridays or Sundays:Example scenario starting from a Monday and given a time period of 15 days.Political parties P0, P1, P2, P3 are allowed to call on strikes every 2, 3, 4 and 5 days respectively.The picture below shows on which days strikes are allowed in this
14:39:01 <arampaa> example:https://imgur.com/a/6hcPKOoAnyway, the task at hand is to write a function that takes a scenario of the form (weekday,time period,parties)and calculates the amount of days on which at least one strike is allowed.So far I came up with this but it does not calculate the days
14:39:02 <arampaa> properly.https://gist.github.com/arampaa/249d20cee557271b7af925f71ded3677Apologies for the long message, any feedback would be greatly appreciated.
14:40:02 <arampaa> sorry, here's the proper link: https://gist.github.com/arampaa/249d20cee557271b7af925f71ded3677
14:42:59 <steevveen> Hi! I'm curious. Imagine I have a `ma`. And lots of `a -> mb` . Like `(Obj o) >>= op1 >>= op2 >>= op3 >>= op4` and so on. Without using do notation, is there a traditional way for applying the list `mbs = [op1,op2,op3,op4]`  to my `ma` ?
14:43:55 <steevveen> indeed my operations are of type `a -> m a`, so they can fit in a list
14:45:09 <shachaf> foldr (>=>) return
14:45:15 <shachaf> Or maybe just foldr (=<<)
14:45:33 <EvanR> foldr (=<<) myFirstMa list
14:45:47 <steevveen> hmm ;-)
14:46:11 <EvanR> :t foldr (=<<)
14:46:12 <lambdabot> (Foldable t, Monad m) => m a -> t (a -> m a) -> m a
14:46:45 <EvanR> :t foldl (>>=)
14:46:46 <lambdabot> (Foldable t, Monad m) => m a -> t (a -> m a) -> m a
14:47:38 <steevveen> I'm gonna play with this. That's powerful.
14:48:21 <EvanR> fold all the things
14:49:14 <phadej> :t foldM
14:49:15 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
14:49:49 <steevveen> rather than recursion, you tell me the advice to go into fold by default ?
14:52:21 <ion> folds are recursion
14:52:38 <phadej> yes, after some level of familiarity with "what's in base library", seing foldl (>>=) would tell you more quickly what happens than 3-4 lines of explicit recursion
14:53:22 <phadej> you know, professor version of factorial n = product [2 .. n]
14:53:55 <Axman6> doesn't work for factorial 1
14:54:03 <phadej> > product [2 .. 1]
14:54:04 <lambdabot>  1
14:54:12 <Axman6> hmmm, I hiess it does
14:54:23 <phadej> > product []
14:54:24 <Axman6> guess even
14:54:24 <lambdabot>  1
14:54:34 <phadej> it's, professor version for a reason ;)
14:55:07 <ion> factorial n = product [0 .. n]
14:56:33 <ion> The ACME package could benefit from that.
14:56:42 <EvanR> that's brutal :)
14:58:11 <suzu> what's a good web framework that isn't yesod?
14:58:24 <suzu> and not servant -- i need browser interaction
14:58:44 <phadej> browser integratio?
14:58:58 <suzu> i wish to return html
14:59:07 <phadej> servant can return Html
14:59:08 <shachaf> ion: That's n+1 numbers. product [0..n-1] would be more consistent.
14:59:09 <steevveen> suzu I have read this article a few minutes ago : https://www.reddit.com/r/haskell/comments/dxrau2/an_example_deadsimple_web_stack_in_haskell/
14:59:12 <suzu> so it is a web application, not a backend service like servant
14:59:15 <shachaf> (By making factorial 0 be 1.)
15:00:14 <suzu> hmm, spock
15:01:02 <suzu> okay, i'll give spock a try
15:01:13 <phadej> spock is much "web application framework" as is servant, you can use blaze-html with both, and Html things will look more or less the same
15:01:23 <phadej> I wonder where this myth "servant is for backend services" comes
15:01:26 <phadej> from
15:01:42 <suzu> i'd need to return a value of which type can be presented as Html
15:02:11 <phadej> which can be Markup -- https://hackage.haskell.org/package/blaze-markup-0.8.2.2/docs/Text-Blaze.html#t:Markup
15:02:13 <suzu> so i'd take whatever data i'd like to present, wrap it up in some larger type, which builds out an html page from that data
15:02:26 <suzu> or it reads it out of the handler state or whatever
15:02:33 <suzu> i.. suppose i could do that yeah
15:03:02 <steevveen> @ion what is the purpose of the ACME package? I have gone rapidly on hackage, and it was not obvious from the few acme prefixed package I saw
15:03:02 <lambdabot> Maybe you meant: yow wn run nixon join id do
15:03:02 <suzu> servant feels "backend-y" to me probably because of the significance of examples all working with json types
15:04:17 <phadej> I define some newtype Page tag = Page Markup -- so I can render the common look of webpage in one place, and differentiate different pages (so I don't misconnect the handlers)
15:04:32 <phadej> but that's very light addition (and quite application specific)
15:05:42 <suzu> and just compose pages together, yeah
15:05:57 <suzu> i suppose i could do that
15:06:03 <suzu> /home returns a HomePage which can be Html-ified etc
15:06:41 <ion> steevveen: Wile E. Coyote acquired various products from the ACME corporation to catch the road runner only to have them backfire horribly. The ACME packages have the same guarantee.
15:08:18 <jle`> man that RecordDotSyntax proposal has some pretty active/intense debating
15:08:39 <suzu> alright, servant it is
15:09:33 <phadej> nice, good choice
15:09:37 <phadej> :)
15:09:39 <koz_> I'm getting weirdness from Twitch (the file watching library). After I start my program with cabal new-exec, even if I pass --root, it doesn't seem to pick up what I'm watching.
15:09:44 <koz_> (like, it doesn't respond at all)
15:09:48 <jle`> suzu: not sure how you are distinguishing 'backend' from 'web application'
15:09:56 <jle`> suzu: are you looking for 'frontent' (compile-to-JS)?
15:09:58 <jle`> *frontend
15:13:45 <suzu> no, i'm looking for no javascript at all
15:13:52 <suzu> the server returns complete html pages and forms
15:15:34 <jle`> suzu: ah yeah, you don't call that backend?
15:15:52 <jle`> typically i have heard of the application that takes requests and returns html pages as the backend
15:15:57 <jle`> but maybe my vocabulary is a little loose
15:17:57 <jle`> but yeah, servant is pretty good as a web backend, it can do all your html web application needs like any other backend can :)
15:21:57 <dignissimus> When running ghcup, how much space is it going to use up?
15:22:23 <dignissimus> I have ~2.8GB free and I'm getting no space left on disk errors
15:22:49 <dignissimus> I've made a gparted USB so if needed I can create more space
15:23:35 <Axman6> how do you have so little space left D:
15:25:56 <dignissimus> It's a school chomebook, it's quite useless for anything that's not school work so I'm dual booting, I didn't want to remove _too_ much space from the original partitions just in case I muck something up
15:30:28 <koz_> How do I set package-specific compile options in cabal.project?
15:32:46 <dignissimus> Ok, installing ghc, stack and cabal-install with my package manager just worked
15:33:04 <dignissimus> Hopefully it'll continue to work
15:37:08 <dignissimus> Hmm, now I have 1.8GB left. But that's a problem for tomorrow
15:39:50 <glguy> I'm working on a version of ReadP that parses biased alternatives in parallel as well as the unbiased ones https://github.com/glguy/breadth-first-parser-combinators
15:40:23 <glguy> I don't expect it to compete as the package people reach for, but it has been fun to figure out all the details
15:41:48 <phadej> koz_: package foo\n  ghc-optiions: ...
15:42:01 <suzu> jle`: yeah my terminology is a bit wrong probably
15:42:08 <suzu> :P
15:42:31 <suzu> so i used to think that you'll pry my emacs from my cold dead hands
15:42:34 <suzu> i just tried vscode
15:42:37 <suzu> uh oh, this is really damn good
15:43:15 <suzu> microsoft put a lot of work into this and it's really good
15:43:40 <koz_> OMG FINALLY
15:43:45 <koz_> I got a file watcher to watch files.
15:44:04 <dsal> What's it been watching?
15:44:19 <koz_> I'm trying to get it to work - it's something for my Real Job.
15:44:23 <koz_> And it's been surprisingly difficult.
15:44:31 <koz_> (mostly because fsnotify is a lot under-docced)
15:44:48 <dsal> I find most things I work on are either surprisingly difficult or surprisingly easy.  Not enough stuff is just about what I expected.
15:45:15 <koz_> Well, now I gotta wire it up properly, but _at least I get how it's meant to work now_.
15:45:33 <suzu> koz_: i know that feel
15:45:38 <suzu> sometimes i just hate computers
15:45:53 <suzu> you can burn hours on the dumbest stuff sometimes
15:45:58 <suzu> feels bad y'all
15:46:28 <Uniaika> suzu: need a hug?
15:46:49 <koz_> Also, is there any library for working with FilePaths? Working with them as raw Strings feels off.
15:46:56 <suzu> Uniaika: y-yes please
15:47:17 <koz_> Uniaika: I thought your handle was 'Unlaika' for a moment there.
15:47:20 <suzu> koz_: there's `filepath`
15:47:36 <dsal> :t FilePath
15:47:37 <lambdabot> error: Data constructor not in scope: FilePath
15:47:44 <dsal> Well, in any case, it's just  a string.
15:47:51 <koz_> suzu: That's exactly what I needed, thanks!
15:48:26 <suzu> not a fan of it's insistence on string/char
15:48:28 <suzu> but it should work ye
15:50:41 <koz_> Could someone help me make sense of withManager from System.FSNotify?
15:51:06 <koz_> I kinda don't get how it works - does it create an 'eternal' WatchManager? One that fires once then goes away? Something else?
15:52:44 <koz_> The minimal example isn't terribly clear about this.
15:57:47 <zeta_0> can you guys explain what is: >>(monad sequencing operator) and >>=(>> with value passing), i am confused, what are they, how do they work, and could you guys show me some examples ?
15:57:53 <zeta_0> thanks in advance
15:58:11 <koz_> zeta_0: Let's work in Maybe, as a simple example. Are you familiar with it?
15:59:34 <zeta_0> koz_: a little bit, boolean(either Just a or Nothing), right ?
16:00:32 <koz_> Not quite.
16:00:39 <koz_> Booleans are different.
16:00:47 <koz_> But essentially, Maybe a is either Nothing, or Just a, yes.
16:00:59 <koz_> Now, this can be thought of as a way of describing 'error' at the value level.
16:01:13 <koz_> If we 'get back' Nothing, we failed; if we get back a Just x for some x, then we succeed, and the result was x.
16:01:24 <koz_> For instance, we could conceive of the following function: 
16:01:34 <koz_> saferSqrt :: Float -> Maybe Float
16:01:41 <koz_> We'd get back Nothing if we fed it a negative number.
16:01:44 <koz_> Make sense?
16:05:55 <koz_> zeta_0: Plink?
16:05:56 <zeta_0> koz_: yes, that makes sense, but for: Just x , does Just mean `only` x ?
16:06:09 <koz_> Just x means 'we didn't fail, and got the result x'.
16:06:30 <koz_> Right, so let's consider >>= in the context of Maybe.
16:06:34 <zeta_0> koz_: ok thanks for clarifying that
16:06:37 <koz_> Doing some copy-paste, we get
16:06:47 <koz_> (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
16:06:58 <zeta_0> koz_: shouldn't i learn >> before >>= ?
16:06:59 <koz_> Wait, no, it's the other way around isn't it?
16:07:03 <koz_> zeta_0: Quite the reverse.
16:07:07 <koz_> :t (>>=)
16:07:09 <lambdabot> Monad m => m a -> (a -> m b) -> m b
16:07:17 <koz_> OK, so let's look at the >>= specialized to Maybe.
16:07:20 <koz_> What does it tell us?
16:07:30 <koz_> The 'Maybe a' is something which might have failed.
16:07:33 <koz_> (we dunno, but it's possible)
16:07:50 <koz_> Whereas (a -> Maybe b) is a function which takes an a, and _may_ successfully give us a b, or might fail.
16:07:59 <nshepperd> The Just constructor is rather oddly named, isn't it. Maybe it should be 'Behold x'. Or 'Some x', as other languages have done.
16:08:03 <koz_> Now, we need to produce a Maybe b, which is 'a b, but possibly a failure'.
16:08:10 <koz_> So what are the possibilities here?
16:08:23 <koz_> It could be that our Maybe a is Nothing, in which case, we've already failed and there's nothing to do.
16:08:28 <nshepperd> 'data Maybe a = Nothing | Behold a' has a nice ring to it, I think
16:08:29 <zeta_0> give me a couple minutes to read this stuff, on second
16:08:32 <koz_> So then >>= just 'propagates' this failure.
16:08:36 <koz_> OK, no worries.
16:08:55 <Axman6> data IsThereAn a = Nope | IHaveAn a
16:09:31 <koz_> Axman6: data CanYouGiveMeAn a = Nope | HereYouGo a
16:10:54 <heatsink> data Here's a = It's a | Nevermind
16:11:03 <jackdk> Axman6: `type YeahNah = Maybe; pattern Yeah a = Just a; pattern Nah = Nothing`
16:11:04 <koz_> heatsink: You win.
16:11:10 <koz_> jackdk: You win also.
16:11:30 <EvanR> Just was named to be consistent with pure
16:11:43 <jackdk> that which is Just is also pure
16:11:48 <Axman6> data YeahNah = YeahNah | NahYeah -- Bool isomorphism with equal clarity
16:11:57 <koz_> Axman6: If you're Australian. :P
16:12:01 <jackdk> Axman6: yeah, nah
16:12:03 <nshepperd> EvanR: pure is Just and Right
16:12:10 <EvanR> exactly
16:12:19 <Axman6> koz_: luckily jackdk and I are
16:12:26 <koz_> Axman6: I'm a Kiwi.
16:12:34 <koz_> So I find this both comprehensible and amusing also.
16:13:07 <koz_> Axman6: New blog post: 'Solve Boolean blindness with one newtype'? :P
16:13:16 <Axman6> sweet as bro
16:13:18 <koz_> s/newtype/type/ argh
16:13:19 <EvanR> data Bool = YeahNah | NahYeah, you somehow compressed 2 possible isomorphisms of Bool into 1
16:13:28 <EvanR> maybe we can apply this to data storage
16:13:41 <Axman6> welcome to Australia, we're a simple, and complex people
16:13:49 <monochrom> simplex people
16:14:10 <Axman6> data QBit = YeahNah | NahYeah | Perhaps | Unlikely
16:14:48 <EvanR> KnownKnown | KnownUnknown | UnknownUnknown
16:15:01 <koz_> EvanR: data Rumsfelf
16:15:02 <EvanR> the rumsfeld topology
16:15:05 <sarahzrf> is a qbit like a qubit 🤔
16:15:05 <koz_> Rumsfeld*
16:15:24 <koz_> monochrom: Gotta linear program the population of Melbourne.
16:15:25 <Axman6> you missed a change to forget UnknownUnknown
16:15:36 <monochrom> data Modal a = Known (Modal a) | Unknown (Modal a)
16:15:49 <nshepperd> data YeahRight = YeahRight | RightYeah. the two isomorphisms australian :: Bool -> YeahRight; american :: Bool -> YeahRight
16:15:51 <EvanR> i think he forgot UnknownKnown
16:15:53 <EvanR> on purpose
16:16:33 <EvanR> that just wouldn't make any sense!
16:16:43 <sarahzrf> monochrom: concerning
16:16:46 <monochrom> nshepperd: Is that because America and Australian are on opposite sides of the equator? >:)
16:16:55 <sarahzrf> monochrom: isn't that just infinite lists of bools
16:17:01 <nshepperd> monochrom: yeah, right
16:18:44 <EvanR> data Sierpinski = Bottom | Top | DontWorryAbout4thOption
16:19:30 <nshepperd> Don'tWorryAboutTheVase
16:20:44 * Uniaika offers a comforting hug to suzu :)
16:21:24 <Uniaika> koz_: sorry I don't ride unsputniks :P
16:21:43 <koz_> Uniaika: Are you also not an undoggo?
16:21:59 <Uniaika> I'm afraid I'm not 
16:22:11 <koz_> Uniaika: On the internet, nobody knows you're not an undog.
16:22:34 <Uniaika> koz_: so… are you an updog?
16:22:42 <koz_> Uniaika: Mu.
16:22:51 <zeta_0> koz_: ok, i'm still confused
16:23:01 <koz_> zeta_0: What specifically confuses you?
16:23:50 <Uniaika> koz_: my keyboard has a "Mu" key :)
16:24:11 <koz_> Uniaika: Are you an (ancient) Greek?
16:24:14 * Uniaika gives koz_ a Mu before going to bed: o/~µ
16:24:15 <MarcelineVQ> it's right next to the Nu key
16:24:56 <Uniaika> koz_: not at all, I'm a french person with a finnish nickname, although my first name is greek ;)
16:26:11 <Uniaika> have a good day / night y'all! :)
16:26:34 <Axman6> Mr Worldwide
16:27:12 <koz_> Axman6: Pitbull is a Haskell programmer?
16:27:24 <Axman6> u kno it
16:27:24 <koz_> main = dale
16:27:26 <koz_> :D
16:27:56 <zeta_0> koz_: i understand function composition(.) pretty well, the output type must match the input type then you: pre-compose or post-compose, anyways how does relate to composing monads and how does it relate to sequencing statements like semi-colon(;) in imperative languages ?
16:28:09 <koz_> zeta_0: That's like, fifty things. :P
16:28:12 <koz_> Let's go one at a time.
16:28:21 <koz_> Let's look at our >>= for Maybe again
16:28:27 <koz_> Maybe a -> (a -> Maybe b) -> Maybe b
16:28:40 <zeta_0> ok
16:28:43 <koz_> In this case, we don't have an 'a' (which is 'an always-succeeding thing that gives us an a').
16:28:50 <koz_> We have a 'Maybe a' (so it might have failed already).
16:29:07 <koz_> And our function argument _may_ fail as well (which is why it returns _Maybe_ b, instead of just b).
16:29:18 <koz_> And the thing we're meant to get 'in the end' is 'Maybe b'.
16:29:50 <koz_> There's three possible outcomes here: either we've _already_ failed (that is, our Maybe a is a Nothing); or we fail as a result of running our function; or we succeed.
16:30:12 <koz_> So, in the first two cases, we expect to get a Nothing as a result, while in the last case, we expect Just x, where x is of type b.
16:30:15 <koz_> With me so far?
16:31:42 * hackage arbor-monad-metric-datadog 1.1.2 - Metric library backend for datadog.  https://hackage.haskell.org/package/arbor-monad-metric-datadog-1.1.2 (arbornetworks)
16:35:12 <zeta_0> koz_: ya, i understand more or less
16:35:31 <koz_> zeta_0: So, the key thing with >>= is that it isn't (really) like (.), but more like (backwards) ($).
16:35:35 <koz_> :t ($)
16:35:37 <lambdabot> (a -> b) -> a -> b
16:35:42 <koz_> :t (=<<)
16:35:44 <lambdabot> Monad m => (a -> m b) -> m a -> m b
16:36:10 <koz_> So essentially, in the case of 'Maybe' it 'propagates failure', without you having to do it manually.
16:36:45 <Axman6> it's the opposite of error checking in Go, where every second line is required to be a check for failure
16:37:24 <EvanR> as long as people are typing, they're earning their keep
16:37:28 <EvanR> productivity++
16:37:45 <EvanR> even better if what they type takes no thought
16:38:14 <zeta_0> koz_: were you supposed to use >>= instead of =<< ?
16:38:28 <koz_> zeta_0: I deliberately used =<< to indicate the similarity.
16:38:34 <koz_> (it's just flip >>=)
16:38:47 <koz_> If you look at the types carefully, you'll see why.
16:39:35 <siraben> Does anyone know of algorithms and data structures for computational geometry in Haskell?
16:39:36 <siraben> e.g. range trees/segment trees
16:39:41 * hackage streamdeck 0.1.0 - Control library for the Elgato Stream Deck  https://hackage.haskell.org/package/streamdeck-0.1.0 (wuest)
16:43:26 <zeta_0> koz_: ok, i think i see the symmetry for the type signatures of (>>=) and (=<<)
16:43:56 <koz_> zeta_0: More importantly, do you see the similarity between ($) and (=<<)?
16:44:02 <koz_> That's kinda the key thing here.
16:50:14 <zeta_0> koz_: they both take a value of type `a`, but after that the difference is (=<<) applies a monad `m` to the returned values, is this the similarity you mean ?
16:50:26 <koz_> zeta_0: Sort of.
16:51:00 <koz_> The idea is that ($) simply applies a function to a value, but bind also (in the case of Maybe) combines together the failure of both the input and the result of the function.
16:51:41 <koz_> To see how this works, we can try and write a specialized version of (>>=) for only Maybe. Let me get you started.
16:52:52 <koz_> zeta_0: https://gist.github.com/kozross/c4a2742ec7da14819511321d3d52b78d
16:52:59 <koz_> See if you can write these.
16:53:04 <koz_> Follow the types.
16:53:36 <EvanR> :t ap
16:53:38 <lambdabot> Monad m => m (a -> b) -> m a -> m b
16:53:52 <EvanR> even more compelling similarity
16:54:50 <EvanR> (i wonder how by removing the first m and getting the signature for (>>=) gives you the "greater monad power")
16:54:59 <EvanR> er =<<
16:57:43 <koz_> Has anyone here used varying (the FRP library)? I wanna have it do something for me, but I have no idea how to start.
16:58:09 <zeta_0> do i need to take into account currying to understand the type signatures or do i ignore currying in this case ?
16:59:44 <koz_> zeta_0: Just implement those two cases.
16:59:49 <koz_> Nothing else matters until you manage this.
16:59:56 <koz_> if you can't, say what's blocking you and we can work through it.
17:01:39 <zeta_0> koz_: ok, it's going to take me a couple minutes to figure this out
17:01:52 <koz_> zeta_0: No hurry. Take as long as you need.
17:02:00 <koz_> Remember - follow the types!
17:02:17 <EvanR> koz_: the documentation exists but seems to be missing some major points
17:02:31 <koz_> EvanR: For varying? Yeah, it's a bit on the vague side, hence my asking.
17:02:43 <koz_> Especially given what I'm trying to do, this is not making any sense to me at present.
17:03:16 <siraben> :t (>>=) . (((.) >>=) . (>>=))
17:03:17 <lambdabot> ((b1 -> a) -> (b1 -> a) -> b1) -> (a -> (b1 -> a) -> b2) -> (b1 -> a) -> b2
17:03:28 <koz_> siraben: Is this @pl output?
17:03:45 <siraben> koz_:  No
17:03:49 <siraben> :t (>>=) . ((>>=) . (>>=))
17:03:50 <lambdabot> Monad m => m a -> (((a -> m b1) -> b2) -> (m b1 -> (a -> m b1) -> b2) -> b3) -> (m b1 -> (a -> m b1) -> b2) -> b3
17:04:03 <siraben> Oops, compose is associative, could've dropped some parens
17:04:24 <siraben> I was just wondering what happens when you compose bind, and what it could be useful for.
17:04:32 <siraben> :t (>>=) . (>>=)
17:04:33 <lambdabot> Monad m => m a -> (m b1 -> (a -> m b1) -> b2) -> (a -> m b1) -> b2
17:05:08 <psygate> In a declaration like newtype Q = P S deriving Show, what does the P stand for?
17:05:32 <siraben> psygate:  It's the "constructor" for Q
17:05:32 <psygate> its not bound to anything anywhere
17:05:45 <siraben> It takes a value of type S and returns a value of type Q
17:05:49 <psygate> aaahhhh
17:05:57 <psygate> So i have to call P(3) instead of Q(3)?
17:06:06 <siraben> newtype Money = MakeMoney Int
17:06:13 <siraben> But usually, we write newtype Money = Money Int
17:06:33 <siraben> So (perhaps confusingly), the constructor for a newtype is written the same as the newtype
17:06:45 <siraben> psygate:  Yes, you would.
17:06:49 <psygate> thank you!
17:06:56 <siraben> (BTW brackets can be dropped in function calls, P 3 and Q 3)
17:07:23 <psygate> yeah i just wrote a huge chunk of C code so im still... confused .
17:07:56 <siraben> C has higher order functions... in the form of function pointers!
17:08:14 <psygate> yes... and lambdas if youre willing to abuse everything
17:08:56 <psygate> now id like to decompose my type Q = P S in a function signature. but its telling me i cant, becuase I cant extract the int
17:09:05 <psygate> so I cant get the S by using p@(s)
17:09:21 <psygate> s is supposed to be an int
17:09:27 <psygate> uh... whats the prefered pastebin here?
17:09:45 <koz_> psygate: gist.github
17:10:27 <siraben> psygate:  extractMoney :: Money -> Int
17:10:33 <siraben> extractMoney (MakeMoney x) = x
17:11:36 <psygate> oh lord... i dont know how i forgot how to use data classes.
17:11:48 <psygate> i feel bad for even asking that one
17:11:51 <siraben> psygate:  I used something called "pattern matching"
17:12:10 <psygate> yes i know, I forgot to add the P in my p@(P s)
17:12:13 <psygate> ._.
17:12:31 <siraben> psygate:  doing p@ is only needed if you need to refer to the whole expression (P s) later on
17:12:40 <siraben> If you don't use p, might as well drop it
17:12:43 <psygate> yeah.  know that one atleast
17:13:23 <siraben> A note about newtype: it doesn't incur runtime overhead
17:13:45 <siraben> Money is different from Int to the typechecker, but at runtime, if x :: Money, then its representation is basically Int
17:14:12 <psygate> thank you, I hope I can remember this this time
17:15:10 <koz_> psygate: This this time, you may forget; but that this time, you will remember. :P
17:15:41 <psygate> koz_, its 2:15am here. forgive me for repeating myself.
17:15:51 <koz_> psygate: It's fine, I'm just being facetious. :P
17:17:09 <talles> koz_: I've made some progress with the minesweeper thanks to you and the guys here.
17:17:25 <koz_> talles: Good to hear.
17:36:00 <zeta_0> koz_: i'm getting an error so i don't think that this is correct ? https://gist.github.com/zeta-00/a4d40e789e5fe68d9bcde6b974e95b55
17:36:33 <koz_> zeta_0: Well, you're halfway there.
17:36:46 <koz_> Line 4 specifically you got. You _must_ give back Nothing in that case - why?
17:36:56 <koz_> (hint - the type of f is core to the answer)
17:40:28 <dmwit> zeta_0: You write `... = Maybe x`. Perhaps you intended to write `... = Just x` and just had a thinko? If not, you should let us know so we can help you understand the difference.
17:40:29 <newhoggy> Does hackage not support `cabal-version: 3.0`?
17:40:36 <newhoggy> https://www.irccloud.com/pastebin/pmZ2sFua/
17:42:40 <zeta_0> https://gist.github.com/zeta-00/a4d40e789e5fe68d9bcde6b974e95b55
17:43:32 <zeta_0> Nothing or Just x ?
17:44:21 <koz_> zeta_0: I was talking about line 4 (the case where the Maybe a input is Nothing).
17:44:28 <koz_> Why must the _result_ of that line be 'Nothing'?
17:44:33 <koz_> (not 'can', _MUST_)
17:48:12 <turab> dmwit: I found definitions of asymmetric and symmetric lenses in a paper you coauthored, however, I don't intuitively understand what part of a lens is used to check whether it is symmetric or not
17:49:43 <turab> i.e. I am used to the definition that aRb <-> bRa. I don't understand what part of a Lens goes in place of R
17:51:18 <zeta_0> koz_: if the 2nd function takes Nothing, then it will return Nothing, correct ?
17:51:50 <koz_> zeta_0: Even more fundamentally. The function argument is of type _a_ -> Maybe b, right?
17:51:57 <koz_> If we have Nothing, we have no 'a' to give, right?
17:52:07 <koz_> So if we have no 'a' to give, we can't call it, right?
17:52:18 <koz_> So therefore, the _only_ thing of type 'Maybe b' we can possibly provide is?
17:58:54 <zeta_0> koz_: Nothing ?
17:59:00 <koz_> zeta_0: Correct.
17:59:12 <koz_> Now, let's look at line 5. Here, we have a different situation.
17:59:20 <koz_> Do we, on line 5, have something of type 'a'?
18:00:35 <psygate> can i decompose a tuple in a list comprehension?
18:00:52 <psygate> as in [t | t <- some_tuple_returning_function, (x,y) -> x = true]
18:01:56 <koz_> psygate: Try [t | (x, y) <- some_tuple_returning_function, etc ...
18:02:08 <psygate> thanks!
18:02:49 <Axman6>  [t | t@(x, y) <- ...
18:03:05 <MarcelineVQ> > (\xs -> [t | t@(x,y) <- xs, x]) [(True,2),(False,4)] -- you can even keep your t if you like, 
18:03:08 <lambdabot>  [(True,2)]
18:03:09 <MarcelineVQ> Axman6: you!
18:03:21 <zeta_0> koz_: yes: yes so the function f will take that value and return a Maybe b, correct ?
18:03:35 <koz_> Yep, that's the idea. Can you write that so it compiles?
18:04:15 <Axman6> <3
18:04:49 <koz_> It's all patterns, all the way down.
18:11:27 <zeta_0> koz_: it's throwing an error: data constructor not in scope ? https://gist.github.com/zeta-00/a4d40e789e5fe68d9bcde6b974e95b55
18:11:48 <koz_> zeta_0: I see no function application in your line 5.
18:12:04 <koz_> You have f to use, and we have a value of type a. So use them!
18:21:18 <zeta_0> koz_: i am getting an error line under `a` in (`a` -> Maybe b) ? https://gist.github.com/zeta-00/a4d40e789e5fe68d9bcde6b974e95b55
18:22:25 <koz_> zeta_0: That doesn't make sense. f is a function. To call it, you need to give it a value of type a. What is the name of the value of type 'a' that we have on line 5?
18:22:31 <koz_> (hint: the pattern match is key)
18:26:45 <zeta_0> koz_: (Just a) ?
18:27:03 <koz_> zeta_0: That's _nowhere_ on line 5.
18:27:09 <koz_> Please look a bit more carefully.
18:32:52 <zeta_0> koz_: i erased the right side of line 5 so i can start my thinking from scratch:
18:32:59 <zeta_0> koz_: maybeBind (Just a) f = 
18:33:11 <koz_> It wasn't (Just a) in my version, _deliberately_.
18:33:13 <koz_> It was (Just x).
18:33:22 <koz_> I did that quite on purpose.
18:33:30 <koz_> So, what's the type of x?
18:34:33 <zeta_0> koz_: x is of type Maybe ?
18:34:37 <koz_> Nope.
18:35:17 <koz_> (Just x) as a whole is of type Maybe a.
18:35:23 <koz_> So thus, what is the type of x?
18:35:54 <zeta_0> koz_: x is of type a ?
18:35:57 <koz_> Yep!
18:36:17 <koz_> So now you have a function, and a value. All you gotta do is put them together.
18:37:44 <zeta_0> koz_: maybeBind (Just x) f = f x
18:37:51 <koz_> Yes!
18:38:14 <koz_> Hopefully this gets across what I was saying earlier.
18:38:25 <koz_> If our Maybe a is _already failed_, then we just pass the failure forward.
18:38:38 <koz_> Otherwise, we 'unwrap' the value that we got by succeeding, and pass it along to the function.
18:39:01 <koz_> With me so far?
18:41:30 <zeta_0> koz_: a chain of returned failure results through the composed functions ? if Just x is passed, then extract x and call function f ?
18:41:52 <koz_> zeta_0: I guess, though I don't quite understand what you're saying.
18:42:08 <koz_> But anyway, before we can move to >> and the differences, there's one more thing I'd like you to try.
18:42:13 <koz_> Are you familiar with State?
18:42:22 <crestfallen> hi anyone know how to have ghci operate in (neo)vim?
18:44:52 <zeta_0> koz_: i've worked through a couple of examples of State, but it still confuses me
18:45:14 <koz_> zeta_0: Well, it'll be good practice for you to do this exercise, then!
18:45:19 <zeta_0> call function f on the extracted x(fixing that part)
18:45:36 <koz_> OK, so as you might recall, State s a is really just s -> (a, s)
18:45:59 <koz_> Now, unsurprisingly, we can do a version of (>>=) for State s as well. Let's try and write it.
18:46:39 <zeta_0> koz_: hold on
18:47:41 <koz_> zeta_0: When you're ready.
18:48:16 <zeta_0> koz_: so in State the function takes the current state(s) and returns a value `a` with the new state `s` , s -> (a,s)
18:48:24 <zeta_0> koz_: correct ?
18:48:47 <koz_> zeta_0: Yes, that's right.
18:48:49 <koz_> Anyways.
18:48:51 <koz_> https://gist.github.com/kozross/facc32b302b2477e188fb2170ef2ddff
18:49:00 <koz_> Again, follow the types, work carefully, think.
18:49:03 <zeta_0> koz_: good my interpretation was correct then
18:50:01 <koz_> Once you've managed that, I can demonstrate to you the difference between (>>) and (>>=).
18:51:38 <zeta_0> koz_: wow, i did not know i'd have to understand all these other things before i could start to learn about these operators
18:51:54 <koz_> zeta_0: The thing is, you need some kind of context to put these things into.
18:52:04 <koz_> This is what this context looks like.
18:52:15 <koz_> I could have given you a very high-level and abstract overview, but it wouldn't make sense to you anywya.
18:52:18 <koz_> anyway*
18:52:32 <koz_> However, by working through this, you'll _feel_ the difference in your bones.
18:52:37 <EvanR> it's really very simple. Let me just go over some basic category theory first
18:52:43 <zeta_0> koz_: oh, i see you mean
18:52:44 <koz_> EvanR: Lawl.
18:53:31 <crestfallen> koz_, when you use newtype is one of those in your example a 'dummy' constructor?
18:53:45 <koz_> crestfallen: I don't quite understand the question.
18:54:20 <koz_> One of what in my example?
18:54:56 <crestfallen> in the hutton book they have a dummy constructor 'S' but that is in Functor and Applicative cases for state
18:55:10 <koz_> crestfallen: Oh, you mean in my newtype definition?
18:55:17 <zeta_0> EvanR: i learned some category theory with bartosz milewskis videos, so i at least understand the basics of category theory, before that haskell didn't make that much sense
18:55:25 <koz_> newtype State s a = State (s -> (a, s))
18:55:36 <crestfallen> yeah
18:55:40 <koz_> The first State is the name of the type, the second is a type constructor.
18:55:52 <koz_> They share the same name, which is a bit confusing, but for newtypes, you can only have one constructor anyway.
18:55:57 <koz_> If you prefer, you can name it something else.
18:56:06 <koz_> I go with this because I'm lazy and naming things is hard.
18:56:26 <zeta_0> koz_: ok, i'll work on that problem, thank you for having patience
18:56:42 <crestfallen> this section of my book is pretty confusing. this is what I have so far from hutton: https://termbin.com/4sa3
18:56:44 <koz_> zeta_0: Patience is a critical part of learning anything, don't worry. You're doing fine - just keep at it.
18:57:35 <crestfallen> also the comments are help from some members here..
18:58:15 <koz_> crestfallen: Ah, that's... terminologically a bit confusing.
18:58:36 <koz_> ST is an example of (what we usually call) State with a _fixed_ state type.
18:59:04 <koz_> That fixed state type is what Hutton calls 'State'.
18:59:18 <crestfallen> does it make sense if the author is calling that 'state transformer'
18:59:19 <crestfallen> ?
18:59:19 <koz_> Whereas ST is what most folks in this here channel would refer to as 'State Int'.
18:59:31 <koz_> crestfallen: That term can mean a few different things.
18:59:39 <crestfallen> hmm
18:59:42 <koz_> In some respects, yes, it does 'transform' 'state'.
18:59:56 <koz_> But that's a pretty general statement - what's 'transforming'? What's 'state'?
19:00:17 <EvanR> S -> S
19:00:20 <koz_> I think the pedagogical goal is to simplify the idea of making the jump to things which aren't of kind Type -> Type, which is where the Functor saga tends to begin.
19:00:26 <koz_> (such as Maybe or list)
19:00:36 <koz_> However, the terminology is definitely apt to confuse.
19:01:27 <koz_> However, you would have to ask Hutton. I hear he's active on Twitter lately. :P
19:03:15 <crestfallen> yeah I took a break from haskell when I hit that. some members said its best to learn the state monad first in this case (at bottom of paste)
19:04:04 <koz_> I agree - the 'leap' to State can be a bit hard. It is, however, very important - once you've grasped that, you rapidly discover that many things are just a complicated way to talk about State. :P
19:04:12 <koz_> (or StateT as the case may be, same diff)
19:04:35 <crestfallen> you mean many things in haskell generally?
19:04:40 <koz_> Yes.
19:04:51 <crestfallen> that's interesting and somewhat encouraging
19:04:51 <koz_> Or at least this has been my observation.
19:05:10 <koz_> Other members of this channel may disagree.
19:05:22 * slack1256 agrees
19:05:53 <crestfallen> the section of the book made me think I overlooked an entire chapter :)
19:07:01 * Axman6 also agrees, but also has a different meaning for the word "agrees"
19:07:10 <koz_> Axman6: I'm curious now.
19:07:32 <Axman6> it's an aggregation of rees
19:07:51 <koz_> Aren't those just trees, but without a T?
19:08:00 <koz_> The non-transformer versions of trees, lol.
19:08:03 <Axman6> koz_: do you know many other NZ Haskellers? I used to know quite a few
19:08:09 <koz_> Axman6: None.
19:08:13 <Axman6> D:
19:08:22 <koz_> Neither personally nor professionally.
19:08:30 <koz_> I'm sure they exist somewhere, but I've never met any.
19:09:10 <Axman6> hamishmack is a kiwi, he's mostly responsible for Leksah, and I think the company he works(ed?) for did a lot of work for haskell on iOS
19:09:21 * koz_ investigates.
19:09:38 <vaibhavsagar> Axman6: I hear he works at IOHK now
19:09:52 <Axman6> also blackh but he hasn't been around on IRC for years sadly
19:10:17 <crestfallen> so you all know any resources where there's a good treatment of state ?
19:10:42 <koz_> Hi vaibhavsagar! Thanks for the follow. :D
19:11:00 <Axman6> vaibhavsagar: they keep hiring all the best peeps
19:11:09 <crestfallen> I'm just staring at my unsatisfactory vim colors
19:11:48 <vaibhavsagar> koz_: my pleasure!
19:11:59 <vaibhavsagar> Axman6: it's true, those blocks won't chain themselves!
19:12:20 <Axman6> we need more blocktree
19:13:21 <MarcelineVQ> aka blockt ree
19:13:27 <Axman6> reeeee
19:13:33 <Axman6> yes
19:14:47 <koz_> Does anyone know of a good writeup of arrowized FRP?
19:14:57 <koz_> All the stuff I've read seems to assume I know things that I don't.
19:15:00 <Axman6> jackdk: ping
19:15:48 <jackdk> Axman6: sup
19:15:58 <EvanR> koz_: Yampa Arcade paper?
19:16:04 <koz_> EvanR: Link?
19:16:16 <EvanR> https://www.antonycourtney.com/pubs/hw03.pdf
19:16:41 <koz_> EvanR: Seems legit, thanks!
19:18:10 <crestfallen> if I may ask again: know any resources where there's a good treatment of state ?
19:18:41 <crestfallen> I don't like any resources right now :)
19:19:21 <slack1256> You could play with Control.Monad.State's runState, put, get and see the type signatures.
19:19:34 <slack1256> I used to execute >>= on State by hand to see how it worked.
19:20:03 <crestfallen> put, get slack1256 ?
19:20:31 <slack1256> Those are functions over the State context
19:20:35 <slack1256> @type get
19:20:37 <lambdabot> MonadState s m => m s
19:20:47 <slack1256> @type runState
19:20:49 <lambdabot> State s a -> s -> (a, s)
19:21:34 <crestfallen> ok yeah I have notes somewhere I did some of that not too long ago. but slack1256 ..
19:21:40 <slack1256> > runState (return "a value" >> put (8 :: Int) >> get >>= return) 11
19:21:42 <lambdabot>  (8,8)
19:21:58 <slack1256> > runState (return "a value" >> put (8 :: Int) >> get >>= return . (+ 20)) 11
19:22:00 <lambdabot>  (28,8)
19:22:27 <crestfallen> hmm
19:23:06 <crestfallen> could you give an example of 'executing >>= on State by hand'   ?  slack1256 
19:23:41 <slack1256> > runState (get >>= \s ->  put (s + 10) >> get >>= return) 11
19:23:43 <lambdabot>  (21,21)
19:24:02 <slack1256> @info State
19:24:02 <lambdabot> State
19:24:12 * hackage thrift 0.13.0 - Haskell bindings for the Apache Thrift RPC system  https://hackage.haskell.org/package/thrift-0.13.0 (jking)
19:24:16 <Axman6> info is actually echo
19:24:21 <Axman6> in lambdabot
19:25:02 <slack1256> crestfallen: It just reading the definition on (>>=) for State and applying for toy examples to develop an intuition. That last part is why is not useful if I give it to you.
19:27:42 <crestfallen> thanks slack1256 I'll work on that
19:29:23 <Axman6> jackdk: oops, sorry, meant to point you at koz_ since I thought you'd looked into arrowised FRP in the past
19:29:27 <EvanR> koz_: apparently someone managed to use yampa, to some extent, to make a 3d shooter
19:29:39 <jackdk> Axman6: I haven't. Only a bit of event/behavior stuff
19:32:16 <EvanR> frag
19:35:44 <zeta_0> koz_: comp is short for compose ?
19:36:23 <zeta_0> koz_: in that code
19:52:35 <evocatus> Is it possible to instruct stack to just download dependencies as declared in `package.yaml` without necessarily building the app?
19:52:41 <evocatus> trying to optimize docker image build times
19:53:04 <evocatus> and would like to avoid having to redownload the entire dependency tree any time the contents of the stack project change
19:57:37 <Axman6> Usually I would make two images, one with all the deps installed and then one for building
19:57:42 <Axman6> which depends on the former
19:57:49 <Axman6> saves _a lot_ of time
19:58:05 <zeta_0> this piece of code is confusing me, could you guys clarify this ? https://gist.github.com/kozross/facc32b302b2477e188fb2170ef2ddff
19:58:15 <zeta_0> thanks in advance
19:58:46 <evocatus> Axman6: how do you install the deps into the former image?
19:59:09 <Axman6> stack install --only-dependencies
19:59:16 <c_wraith> zeta_0: We need more information on what part is confusing you.  Do you know what it's asking?
19:59:31 <evocatus> Axman6: aaah. I will give that a shot, many thanks
20:01:56 <zeta_0> c_wraith: the type signatures and the implemented parameters are confusing me, i'm not sure whats going on ?
20:04:09 <c_wraith> zeta_0: so, stateBind is a higher-order function, kind of like something like concatMap.  does its type make sense to you?
20:04:12 <c_wraith> :t concatMap
20:04:14 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
20:04:18 <c_wraith> hmm
20:04:39 <c_wraith> % :t concatMap @[]
20:04:39 <yahb> c_wraith: (a -> [b]) -> [a] -> [b]
20:04:52 <c_wraith> there.  Use that type.  Get rid of the classes. :)
20:04:55 <evocatus> zeta_0: given a stateful computation, and a function from the result of that stateful computation to another stateful computation, how can you produce another stateful computation?
20:05:18 <c_wraith> zeta_0: does (concatMap :: (a -> [b]) -> [a] -> [b]) make sense to you?
20:05:44 <evocatus> (where the stateful computation you produce has the same result type as the one returned by the function specified as a second argument to stateBind)
20:06:09 <zeta_0> alright, give me a second to break this stuff down and digest it
20:08:22 <evocatus> effectively `stateBind` is saying, I have a computation of type `State s a`. I want to execute that computation, and then use its result (of type `a`) to determine what computation to run next
20:08:32 <evocatus> the next computation I run will have type `State s b`
20:09:09 <evocatus> The function `f` of type `a -> State s b` is responsible for determining what computation to run next, and it can determine this using the result of the last computation (of type `a`)
20:18:11 <zeta_0> i am going to get some sleep and wake up in a couple of hours, what time zone are you guys in ? do you guys stay up during the night ?
20:19:07 <c_wraith> don't worry too much about it.  there are usually helpful folk around, and it can be nice to get multiple viewpoints.
20:19:28 <c_wraith> (unless you're getting like 5 at once, then it's just overwhelming)
20:19:43 <dsal> % :t foldMap @[]
20:19:44 <yahb> dsal: Monoid m => (a -> m) -> [a] -> m
20:20:16 <zeta_0> cool, well later guys
20:21:29 <EvanR> funny how that function seems pointless if you fill in the Monoid, but may be mildly inscrutible for a novice if you leave the Foldable
20:22:24 <dsal> I did that to myself today.  I was using foldMap and wondering why.  
20:22:40 <haskelllisp[m]> What are the functions of `FromJSON` and `FromByteString`? When I receive a request, I first convert from `byteString` to an object? If so, what is the use of `FromJSON`?
20:23:36 * haskelllisp[m] sent a long message:  <  >
20:23:44 <EvanR> oh nice
20:24:06 <EvanR> matrix.org took the liberty of sending your long message to /dev/null
20:24:25 <Axman6> haskelllisp[m]: what's FromByteString?
20:24:32 <Axman6> ha
20:25:51 <haskelllisp[m]> https://hackage.haskell.org/package/bytestring-conversion-0.3.1/docs/Data-ByteString-Conversion-From.html#t:FromByteString
20:27:44 <haskelllisp[m]> I want to know what is the use of FromByteString and FromJSON in an http request response process？
20:30:24 <evocatus> haskelllisp[m]: it's possible that you may be referencing `FromJSON` from the aeson library, whose typeclass definition is given here: https://hackage.haskell.org/package/aeson-0.5.0.0/docs/Data-Aeson-Types.html#t:FromJSON
20:31:10 <Axman6> haskelllisp[m]: you're not giving us very much context here
20:32:38 <haskelllisp[m]> Yes, I am using aeson, but I don't know how it works.
20:33:14 <evocatus> haskelllisp[m]: https://artyom.me/aeson#generics-customising-field-names
20:33:43 <evocatus> for many use cases it should suffice to just `derive(Generic)` on the type you would like to deserialize into, and possibly specify a `fieldLabelModifier` to translate your field labels into JSON key names
20:33:53 <haskelllisp[m]> What is the difference between FromByteString and FromJSON? Must both be used at the same time?
20:34:59 <Axman6> I've never seen FromByteString used, so don't know what you're talking about. is there some code yoy're referring to?
20:35:32 <nshepperd> this FromByteString typeclass seems like a trap
20:35:35 <haskelllisp[m]> At what time is it converted?
20:36:06 <EvanR> your type T needs to implement FromJSON is some way for you to try to convert json to T with aeson
20:36:17 <EvanR> in some way
20:36:37 <EvanR> no idea what FromByteString is
20:37:26 <evocatus> haskelllisp[m]: the link I provided will give you a basic implementation of the `FromJSON` typeclass using generics
20:37:36 <evocatus> it should work for most cases
20:38:30 * haskelllisp[m] sent a long message:  <  >
20:38:43 <evocatus> Axman6: also thank you; almost 1 hour later I now have a docker layer that bundles all of my app's stack dependencies lol
20:38:53 <Axman6> noice
20:39:04 <Axman6> haskelllisp[m]: use a paste website, this isn't matrix
20:39:04 <EvanR> haskelllisp[m]: negative big daddy... no message recieved
20:39:22 <nshepperd> matrix.org sure is buggy today
20:39:22 <haskelllisp[m]> ok
20:40:34 <haskelllisp[m]> https://paste.ubuntu.com/p/3Kyb89qrCd/
20:44:45 <haskelllisp[m]> https://paste.ubuntu.com/p/xRKHsCpV3C/
20:44:45 <haskelllisp[m]> Looking at this code, which one of FromJSON and FromByteString works? ?
20:46:38 <EvanR> don't you know if it works?
20:48:37 <Axman6> which http library are you using? I don't recognise it
20:50:37 <nshepperd> first, i suggest forgetting that FromByteString exists
20:50:56 <nshepperd> it doesn't work and can't possibly work
21:00:39 <dmwit> ?tell turab In this case, "symmetric" is a technical term to mean that the category is its own dual.
21:00:39 <lambdabot> Consider it noted.
21:01:43 <dmwit> ?tell turab (By comparison, the standard category of lenses that predates my work is not symmetric; for example, in Haskell terms, if `data Foo = Foo Bar Baz`, then there is a straightforward lens of type Foo -> Bar, but none of type Bar -> Foo.)
21:01:43 <lambdabot> Consider it noted.
21:12:57 <constantine_91> as is getLine :: IO String, does haskell have something like mayBeGetLine :: IO MayBe String?
21:13:21 <Axman6> how would it know not to return something?
21:13:47 <constantine_91> I mean if user enter "" then it will be Nothing otherwise Just "Entered Text"
21:15:00 <constantine_91> I might be being silly here, but just curious 
21:15:25 <olligobber> constantine_91, (\x -> if x == "" then Nothing else Just x) <$> getLine
21:17:16 <Axman6> I would say that "" is a perfectly valid String :P
21:19:10 <EvanR> some kinda non-blocking I/O or something
21:20:09 <constantine_91> olligobber thanks man! It is working 
21:20:40 <EvanR> but yeah i expect <enter> to be them literally entering ""
21:21:07 <EvanR> it can't really mean anything else given the circumstances
21:21:18 <olligobber> constantine_91, do you understand why it works though?
21:21:39 <constantine_91> yeah! of course it is valid, I just want to use "fromMaybe" function cause if the input string is "" then I want to pass my default value
21:22:05 <constantine_91> olligobber No, can you please explain..??
21:22:52 <olligobber> constantine_91, so the first part is a function that turns "" into Nothing and anything else it becomes Just x, using an if statement
21:23:08 <olligobber> then <$> is used to apply that function to the result of getLine
21:24:18 <constantine_91> olligobber Oh! then what is type of <$>?
21:25:02 <olligobber> in this case you can think of it is (a -> b) -> IO a -> IO b
21:25:31 <olligobber> in general it works for any functor F as (a -> b) -> F a -> F b
21:26:15 <olligobber> :t (<$>)
21:26:17 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:26:33 <olligobber> it's also known by the name fmap
21:26:34 <olligobber> :t fmap
21:26:36 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:27:25 <constantine_91> olligobber thanks! I need to study and understand this concepts :)
21:27:54 <olligobber> yeah, everyone has to start somewhere, good luck
21:57:12 * hackage mini-egison 0.1.6 - Template Haskell Implementation of Egison Pattern Matching  https://hackage.haskell.org/package/mini-egison-0.1.6 (SatoshiEgi)
22:10:31 <haskelllisp[m]> https://paste.ubuntu.com/p/wMF2h57Jtc/
22:10:31 <haskelllisp[m]> Why can I convert `r :: ByteString` to a `User` object list?
22:13:32 <jle`> haskelllisp[m]: what is the type of parseResponse ?
22:15:00 * haskelllisp[m] sent a long message:  <  >
22:16:30 <haskelllisp[m]> FromJSON a  and  eitherDecode' ?
22:18:11 <EvanR> (i don't know if you can tell but your long message from matrix.org is not arriving)
22:23:24 <haskelllisp[m]> sorry ，I will sort out the code and send you a paste connection later.
22:25:41 <nshepperd> it seems to me there are some foundational issues here
22:26:01 <nshepperd> 'converting' a bytestring to a haskell object is kind of meaningless without a specific encoding
22:27:36 <M0b10s> hey! anyone could help me with some questions about BTree's ?
22:27:50 <Axman6> Not if you don't ask them :)
22:29:28 <M0b10s> x) true fact! i have to remove the lowest value from a tree and know that value but one running the tree once in a recursive way...this is:  minSmin :: Ord a => BTree a -> (a,BTree a)
22:31:28 <M0b10s> it's messing with my head because i think i have to run the tree once to know the min....and just then i know how to remove it... i have no ideia how to do know the min and remove it, in one run...
22:31:44 <c_wraith> the min is always in the same place
22:31:50 <c_wraith> it's a sorted data structure
22:32:20 <M0b10s> i got that, but how about if it wasn't?
22:32:45 <c_wraith> then it wouldn't be a b-tree, so no algorithms that work on b-trees are guaranteed to work
22:33:24 <M0b10s> ok, so BTree's are allways ordered...
22:34:03 <M0b10s> but, how do i order a Tree? the min's are the leafs?
22:34:06 <Axman6> each recursive call returns their changes to the tree, and those are incorporated with that calling iteration's changes. so something like minBTree (Leaf a) = (a, Empty); minBTree (Branch l a r) = let (a,l') = minBTree l in (a, Branch l' a r)
22:34:49 <Axman6> the minimum value in an order binary tree is always the valu furthest to the left, so keep going left until you can't go any further
22:35:39 <Axman6> M0b10s: is the BTree a b-tree or a binary tree? they are quire different things (though it doesn't actually change much here)
22:35:54 <M0b10s> so if i need to add a value to the tree, i'd need to re-arrange the whole tree?
22:36:21 <Axman6> "rearrange" no, reconstruct with the changes yes
22:36:30 <M0b10s> as far as i know, it may be a Int tree, a char tree...
22:36:51 <Axman6> what is the definition of the tree? data BTree a = ....
22:37:22 <M0b10s> = Empty | Btree a Btree a
22:37:22 <shachaf> B-Tree deletion is tricky business.
22:37:28 <shachaf> Oh.
22:38:00 <Axman6> M0b10s: that doesn';t quite look right, but yes, that is a binary tree, not a b-tree
22:38:16 <M0b10s> (the happiness of starting to understand) :thumbs up! =)
22:38:39 <M0b10s> data BTree a = Empty | Node a (BTree a) (BTree a) deriving (Show)
22:38:42 <M0b10s> my bad sry
22:38:50 <M0b10s> just starting on them
22:41:23 <M0b10s> well, in that case...it get's much easier than i was thinking! (just turn left x) )
22:42:06 <M0b10s> but can we have tree's that are not ordered? 
22:42:52 <Axman6> they types say so, but if it is an ordered binary tree then no (by definition)
22:43:41 <int-e> Is that really a problem though? You can /view/ ordered trees as unordered ones if you like.
22:44:27 <Axman6> there's nothing stopping me saying Node 2 (Node 3 Emoty Empty) (Node 4 Empty Empty) which corresponds to [3,2,4], but only if I have access to create that tree in an unordered way
22:44:39 <int-e> (Though I suppose then you'll have some fun implementing the corresponding equality etc.)
22:45:09 <M0b10s> it becomes wen i have to find and remove a node that may have more branches, in just one passage x)
22:45:15 <haskelllisp[m]> https://paste.ubuntu.com/p/mKWgFk5CXJ/
22:45:15 <haskelllisp[m]> I have an incredible mistake, who has time to help take a look.
22:47:20 <nshepperd> haskelllisp[m]: start by deleting the FromByteString and ToByteString instances. they should be unnecessary if you are using json and are probably harmful
22:47:22 <int-e> haskelllisp[m]: "account"       .= userAccount u  attempts to parse an Account field?
22:47:47 <int-e> haskelllisp[m]: or rather the corresponding parser part, <*> o .:? "account"
22:48:21 <int-e> haskelllisp[m]: btw, you've messed up the field order in the parser, which may explain your confusion?
22:49:33 <int-e> haskelllisp[m]: so what I wrote before is false; it's <*> o .:? "userAddress" that attempts to parse an account
22:51:59 <int-e> haskelllisp[m]: And with that realization the error message makes sense as well. (In retrospect.)
22:52:50 <haskelllisp[m]> Is the field order consistent?
22:52:50 <haskelllisp[m]> The internal implementation of `o .:? walletAddress` is not looking for the value of a field with a key of `walletAddress` from a map? If this is the case, I think the order should have no effect.
22:53:52 <jle`> haskelllisp[m]: the issue isn't the map it's looking up, it's the way you are assembling it
22:53:57 <int-e> haskelllisp[m]: the 5th argument of User has type Maybe Account
22:54:15 <jle`> haskelllisp[m]: for example, if you want something of type (Int, Bool), you have to write (4, True) --- not (True, 4)
22:54:25 <haskelllisp[m]> nshepperd: This is the source code of the open source application. He uses FromByteString and ToByteString. I also feel very confused.
22:54:40 <int-e> haskelllisp[m]: and the <*> o .:? "userAddress"  parses the 5th argument of User.
22:54:45 <jle`> so the order in the map you are looking up doesn't matter, but if you're turning it into a haskell type, then it matters what the order of the arguments are that you give to your haskell constructor
22:54:45 <Axman6> they are probably being used for something else
22:55:02 <nshepperd> haskelllisp[m]: ah, well i guess you're stuck with them then
22:55:36 <Axman6> int-e has nailed the problem I think, the order of field parsing is wrong
22:56:08 <int-e> it would be nice if we could /conveniently/ mention the Hakell record field names here... but I don't see how.
22:56:28 <int-e> err, Haskell
22:56:58 <Axman6> we need idion bracketsd
22:57:30 <Axman6> idium brackets even
22:57:37 <int-e> Axman6: wow :)
22:57:50 <nshepperd> iridium brackets
22:57:58 <nshepperd> int-e: RecordWildCards and write 'do { userId <- o .: "id"; userName <- o .: "name"; ... ; return User{..} }'?
22:58:02 <haskelllisp[m]> Ok, I understand, thank you for your answer.
22:58:06 <int-e> (or maybe I should reserve that exclamation for the third misspelling in a row :) )
22:58:07 <Axman6> but also idiom brackets
22:59:53 <EvanR> idium is the stupid nonsense material movies with totally wrong science are always trying to acquire
23:01:12 <int-e> nshepperd: Hmm, that looks reasonable actually.
23:01:41 <dminuoso> int-e: It's the one single great side of RecordWildCards :)
23:01:59 <int-e> could be prettier (putting the constructor last is a bit awkward) but at least nothing is duplicated.
23:01:59 <Axman6> and use ApplicativeDo so it's not actually monadic (Useful in parsers which can report multiple errors)
23:03:26 <int-e> I mean, User { userId <- o .: "id", ... } would be ideal.
23:04:33 <jle`> i use RecordWildCards with do notation all the time now
23:04:35 <jle`> it's my new fav
23:04:47 <int-e> But I'm sure all this has been suggested before.
23:04:52 <dminuoso> int-e: Mmm, sort of a mix between do-notation and field syntax?
23:05:01 <int-e> dminuoso: yes
23:10:14 <jle`> int-e: something like that would be nice, but it seems a little ad-hoc and for a single usage
23:10:22 <jle`> int-e: the nice thing about RecordWildCards is that it desugars into normal haskell
23:10:40 <jle`> so it's understandable within 'normal haskell' rules without any specialized magic
23:11:01 <jle`> the last thing just desugars return User{..} into return User{userId = userId, userName = userName}
23:11:17 <jle`> and that simple desugaring allows you to use it in multiple situations, not just for this one thing, which is kind of nice
23:13:20 <int-e> Oh with monad comprehensions we could also put the constructor first, [User{..} | userId <- o .: "id", ...]
23:16:03 <int-e> jle`: I agree that this kind of syntax sugar for solving a cosmetic problem is probably not worthwhile. But if I had to make up a syntax for the purpose of applicatively building a record, that would be my choice (probably as part of a `do` block to have *some* warning that non-pure stuff is about to happen).
23:22:23 <dminuoso> int-e: I think it might be trying too hard to give haskell the feeling of <insert some traditional language here>.
23:23:53 <dminuoso> RecordWildCards really gives you a nice balance of the expressivity while not hiding the Haskell that's going on. 
23:24:07 <int-e> dminuoso: if I ever design my own language (everybody and their dog seems to be doing that these days...) ;-)
23:25:47 <dminuoso> int-e: This sort of talk reminds of elixir somehow, which focuses a lot on "We want this syntax feature, damn anyone who wants to talk about the semantics of the language or understand whats going on"
23:26:18 <dminuoso> Not saying you're victim here, just that it reminds me.
23:29:05 <int-e> This is heading off topic, but I'm really fairly cynical about this proliferation of programming languages. They usually solve one particular syntactical (or sometimes semantical) problem well, are average in all other aspects, but they give their designers and implementors an opportunity to be productive by writing all the basic libraries from scratch.
23:30:18 <EvanR> can we call the first of the next 700 languages idium
23:37:54 <int-e> EvanR: I approve of that name. It's definitely much better than using common words like clean, rust, swift, or go...
23:39:20 <dminuoso> Or just pick a single letter... there's still plenty unused ones left!
23:39:52 <dminuoso> Imagine how great it looks on your CV if you were to list "A, B, C, C--, C++ F*, R, T, Q, Z, W-" in your language competencies..
23:40:25 <int-e> dminuoso: The ⛄ language.
23:40:39 <dminuoso> Oh amazing! I hadn't thought of that.
23:40:49 <dminuoso> int-e: Any Agda developer would approve.
23:40:52 <dminuoso> ;)
23:41:30 <EvanR> i'm a pile of poo developer
23:41:52 <int-e> dminuoso: I'm too ignorant of Agda to get that joke.
23:42:42 <dminuoso> int-e: Agda developers are *very* liberal with unicode.
23:42:42 <EvanR> rather than allowing unicode but shying away like haskell, agda jumps the shark and is mostly non-ascii
23:43:28 <dminuoso> Reading agda code might give you the impression you need latex to write agda with.
23:44:17 <dminuoso> int-e: So you have websites like this.. https://people.inf.elte.hu/divip/AgdaTutorial/Symbols.html
23:44:33 <dminuoso> Im guessing memorizing that page is part of the tutorial
23:44:39 <dminuoso>  /s
23:45:03 <int-e> dminuoso: wonderful
23:46:15 <int-e> dminuoso: It makes Isabelle developments look sane.
23:48:36 <ammar2> dminuoso: and APL devs
23:49:03 <int-e> dminuoso: But honestly I suspect one gets used to that... I'd be more worried about having to type those things. Part of the learning curve I suppose.
23:49:45 <ammar2> int-e: what about learning something like `life←{↑1 ⍵∨.∧3 4=+/,¯1 0 1∘.⊖¯1 0 1∘.⌽⊂⍵}`
23:49:55 <ammar2> oh good, my font doesn't even have some of those symbols
23:50:51 <int-e> ammar2: That's be about as bad... though APL's character set is a small subset of Unicode, isn't it?
23:51:03 <int-e> 's -> 'd
23:51:59 <EvanR> cool the life in APL rendered!
23:52:21 <EvanR> macron / overbar... what were they smoking
23:53:24 <EvanR> also obligatory shoutout to naperian functors and APLlicative programming paper
