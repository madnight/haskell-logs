00:36:49 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org'
00:36:49 --- topic: set by glguy on [Sat Jan 05 07:21:52 2019]
00:36:49 --- names: list (clog encod3_ smatting shutdown_-h_now encod3 lambda-11235 uniquerockrz brettgilio ce9a multiproc therisen sQVe cfricke doublex chele aqd trcc zaquest lprd_ cynick vlatkoB_ milanj qzo danvet machinedgod aveltras alfredo APic Synthetica stilgart kosmikus crooked rotty sud0 amx anderson_ jdevlieghere glamas acowley electrostat kraem Tene nitrix totte dashkal zv codedmart inimino Zemyla dmwit chivay jix puffnfresh ChaiTRex TMA sim590 yumh- immae globber)
00:36:49 --- names: list (alicemaz lukelau incertia Moyst ycheng juri_ valdyn toure|gone exarkun esph forell dolio raek amiri Poscat dopplergange AkhILman acertain styledash lowryder grumble DTZUZO fliife seliopou Anthaas subttle hiptobecubic theDon lagothrix imtravis rruizt Sk01 noCheese stepnem dave_uy9 kenran chreekat coddinkn MacYET2 kevinyins monochrom myme divVerent Lite kqr zeta_0 joeytwiddle markhuge jinblack djanatyn avp sssilver luigy geal exio4 Aleksejs [df] connrs-)
00:36:49 --- names: list (gambpang gsingh93 michalrus bob_twinkles Firedancer_ jvanbure Mo0O rodlogic bind wraithm xarian greymalkin a7250ag kaol gothos _ht oeblink Logio Nikotiini Deadhand jorj lyxia bbear sshine ashnur mmaruseacph2 Ornedan Chobbes dredozub- bydo_ stefan-__ rotaerk_ poga mearon_ Ivan__1_ _phaul ion kav_ arianvp_ habbah_ tureba_ jonatan_ jellie quintasan_ phanimahesh obfusk_ tylerjl atriq vodkaInferno PragCypher_ zargoertzel poljar [Leary] revprez_1nzio jneira_)
00:36:49 --- names: list (maxter_ dnikolovv albion mulk evanjs Sgeo__ Lycurgus ggole klntsky s00pcan unyu tabemann blankhart cybai tomsen_ MoarSpaceFi vicfred abhixec xff0x jluttine sword865 macroprep carldd jusss cgfbee Batholith rizary_ ^[ higherorder TallerGhostWalt_ hsiktas parseval PotatoGim ryzokuken nh2 jonrh enemeth79 lightandlight elvishjerricco dukedave affinespaces scav moobar feepo Kamuela ibloom newhoggy m-renaud jsatk mankyKitty nbouscal edmundnoble verlet64)
00:36:49 --- names: list (monad_cat Lermex simony alunduil zabracks banjiewen AfC alexknvl liquorice AndreasK benwr_ PatrickRobotham nkaretnikov Nascha jetpack_joe sariyar isacl___ obskur3 xujaan gluegadget rslima___ FMJz___ fingerzam peschkaj ryjm natim87 koankeeper sebastianrkg TheCommieDuck_ olle pavonia olligobber1 khisanth_ zyeri jud notzmv dcoutts inkbottle nullifidian alx741 sagax efm Tesseraction pfurla OnkelTem ziyourenxiang kjak kwantam StoneToad jakalx clynamen rootnode)
00:36:49 --- names: list (conal shrewdy irc27313 justan0theruser farn yahb Thra11_ Kaiepi refusenick lassulus sm m0rphism1 erikd k_sze maralorn jlamothe wonko7 aarvar ystael carlomagno kirand megeve LnL Novitsh stux|RC bollu _janne benl23 mitchellsalad_ heyj terrorjack__ mpickering lexi-lambda Jacoby6000 amuck RecursiveG Athas DrDuck J_Arcane jackdk wildsebastian jesyspa phaazon thi_ amosbird eagleflo Guillaum fiQ2 jbetz adamse lucas8 freusque irclogger_com teehemkay lockshaw_)
00:36:49 --- names: list (statusbot Hijiri Ranhir Madars noexcept Vtec234 stiell bgavran liff jdt nemesit|znc gargawel mxf_ pasukon pharaun PHO Cathy eldritch krystianbajno rubik literallyCrevice crtschin vin-ivar_ raatiniemi iphy RoguePointer tumdedum azahi fiddlerwoaroof PtxDK dogui earldouglas seventh__ theophil97 ixian sw4n ziman dexterfoo Blkt dan64 anishathalye mceier w1gz tjbp fryguybob Natch Uniaika texasmynsted Kiruwa srhb devurandom maerwald bwe absence tokik hvr sdrodge)
00:36:49 --- names: list (MindlessDrone hjozwiak Ring0` tromp_ cchalmers johnw bsima evelyn tabaqui1 phadej jayjayjay infinity0 gabiruh verement niko AWizzArd tanuki entel chreekat_ yaroot DrAwesomeClaws m4lvin mozzarella tinwood MarcelineVQ kuttifunk thunderrd GyroW fredcy| mccoyc andyo Foritus hololeap jneira z3t0 RusAlex tstat ponyrider sleblanc theorbtwo markus1199 nisstyre darjeeling_ SCHAPiE cheater NightA jb55 mounty Jesin duairc xplat gentauro a3f sphalerite chirpsalot)
00:36:49 --- names: list (MonkeyNOS ashkan_kiani sarahzrf cheshircat smelc Majiir Slothel_ cyphase xtsee kish phreedom M2tias jtcs _xor robogoat keep_learning Shoubit stzsch zmt01 vimto coldpress _abel srnty_ bgamari_ remexre xelxebar mniip mursu jwynn6 dixie_ Deewiant hpc hive-mind Paks mountaingoat ichor perrier-jouet infinisil pta2002 topos dimonov2 ap5 devalot cods Neo-- Chousuke DustyDingo TemporalShift andi- mnrmnaugh atk albel727 ps-auxw andreabedini jrslepak artem)
00:36:49 --- names: list (Neuromancer drewr Maxdamantus Vq dunningk jrm nshepperd jchia waskell nh raoulb _ashbreeze_ matheus Cale ysangkok ephemera_ leah2 john-doh Unode rosalux droplet dmiles betawaffle m1dnight_ Jon seanparsons uberj heredoc eythor Profpatsch sterni cocreature aesi Orbstheorem tomboy64 Unhammer [exa] ahf nckx gienah andreas31 sqrt2 gehmehgeh rembo10 carbolymer cp runawayfive suppi Rembane freeside dminuoso d3lxa teardown silver_needles averell Bergle_1 rawles)
00:36:49 --- names: list (swater andromeda-galaxy coeus eyenx urdh daissgr ammar2 treehaqr spoonm zzz dibblego tessier samtor bbear_ nikola pong mikeplus64 arsdragonfly julienXX Hotbees idupree ab9rf ambrosia ericsagnes cartwright hc wrengr_away SegFaultAX sujeet troydm q3k restrictedchoice cross joeyh_ remy^ sigmundv_ ctag_ thecoffemaker lockshaw Sose saurik meck raid PyroLagus ivegotasthma bolverkr mrd nivpgir niklasb_ scal daGrevis asm89 rzmt adarshaj obiwahn orzo Entroacceptor)
00:36:49 --- names: list (klugez_ marble_visions moocow totbwf Zoddo koala_man Sparadox TimWolla michaelpj otwieracz Bigcheese edwtjo gaze__ nurupo tv haskell_enthusia Niamkik tdammers lemald jle` haveo Ekho thaumavorio iomonad Randy DTZUZU johnstein sw1nn Igloo Arahael mimi_vx Dykam vjoki Cthalupa chin-tastic eruditass tomku joehillen SquidDev nekomune a3Dman Philonous Nik05 int-e qz wagle epta glowpelt dustinm- afreakk hackage Phyx- ego ptrcmd jfredett jackhill nopf jonge hegge)
00:36:49 --- names: list (barrucadu bartavelle zymurgy jokester cheers glguy cjh` atraii sudden Clint fuzen magicman sukbeom datajerk kiix suzu e dilinger brnzz arkeet jassob xacktm SolarAquarion Klumben dysfigured pingiun koz_ dpn` shachaf lurkless aldum nil lambdabot simplegauss cbilt statusfailed vk3wtf_ ByronJohnson Reisen nyaomi Rudd0^ Rudd0 Tspoon_ drewbarbs sandman13 hongminhee mikolaj cyberlard kaychaks xstill tensorpudding flebron dfordivam Forkk mjuad locallycompact)
00:36:49 --- names: list (drbrule Jello_Raptor militia Remavas nyuszika7h electrocat riatre Cerise Adeon Seich Willis MatrixBot7 pikajude pierrot kAworu thebnq aristid pdxleif @Sigyn abra0 fr33domlover alanz mupf PlasmaStar jameekim taylskid rann travv0 monokrome Mon_Ouie Annihite1 loc_ bendo_ bcoppens mutantmell nibbling Ckat Nevoic rkrishnan c_wraith qbnk4 srid micro p3n jmsx ft hiredman Intensity ahri cpape pacak abuss fiatjaf rodgzilla blackdog relrod ullbeking Xandaros mrus)
00:36:49 --- names: list (JSharp hodapp gregberns_ sethetter_ drdo lstdgtfp_ atle_ PierreM_ Ke heath implementation_ telser- w1d3m0d3 zekt83 umachan NinjaTrappeur feuerbach Velpoman defanor_ zfnmxt Twey tabaqui ekleog ent tlax tsani acro badzergling mr_yogurt dequbed Axman6 neildaemond Jonno_FTW anathema mikolaj_ dqd atomi copypasteque Tourist TC` tomjaguarpaw lavalike gilbertw1 tms_ ski kini noan DigitalKiwi strangeglyph chindy _Tristan_ abbe echoreply dxld haasn s4msung miklcct)
00:36:49 --- names: list (Arguggi nshepperd2 adamCS ereu nuxdie Shun131 landonf sdx23 MasseR caasih coot dmj` wz1000 bjobjo c-rog jzl michalisko madnight EvanR dumptruckman nonzen deu wadadli apoc samebchase mjrosenb energizer guios dyl_ tristanC comboy_ hyperfekt violeta ocharles sis7 null_ptr alp mycroftiv peel nlofaro stylewarning TommyC andjjj23 johs komasa polux7 lnx amatecha_ dongcarl darthThorik bjs metalrain kip ajmcmiddlin ghuntley xyggos EduardoBautista dani- tazjin)
00:36:49 --- names: list (d0liver runeks pent dsal milessabin typetetris ebutleriv bspar bandali raoul @ChanServ bitonic bradparker winny interruptinuse unsymbol morgib Jabbslad sebhoss ephemeron xnyhps jlpeters Konehaltia NemesisD Ferdirand paf31_ aib bananagram `slikts mstruebing dgpratt sclv lieven tolt ProofTechnique spamlessj integral uwap akermu vqrs Geekingfrog twk- t36s _flow_ solarus kloeri lortabac exferenceBot shadowdaemon reyu lpsmith Squarism connrs_ deni oleks)
00:36:49 --- names: list (Someguy123 arw wtw charukiewicz Drezil catern SlashLife CindyLinz digia shapr Flonk stvc rootmos ecx86 flogfr Eliel hexagoxel kubrat ManiacTwister S007 beaky aidecoe graingert Adluc srk quaestor petermw rom1504 cbarrett diginet n3t luite nshepperd1 carter edwardk lally SrPx noctux yushyin i7c sveit megaTherion angerman scivola bengt_ malthe cjay- kipras`away saidinwot1 chessai beka Ankhers thoradam glowcoil billstclair kyagrd__ joshmeredith dolanbatar dh)
00:36:49 --- names: list (canta mudri davean runde ynyounuo dagit agrif aweinstock pcoutin teej debugloop systemfault so evilmonads sivs Tritlo sgraf PoliticsII_ hamishmack spinda adius Firedancer Peter_Storm joel135 kapil_ opqdonut)
00:36:51 <dminuoso> dnikolovv: It's customary to just start with your question. :)
00:37:01 <dnikolovv> thank you
00:37:06 <dnikolovv> so I have this "design" issue
00:37:14 <dnikolovv> this is my code
00:37:15 <dnikolovv> https://pastecode.xyz/view/06775449
00:37:40 <dnikolovv> how do you think I can make ToInputsDescription and FromLookup 
00:37:48 <dnikolovv> "depend" on each other?
00:38:04 <dnikolovv> what bugs me is that you have to set the keys once as strings when implementing ToInputsDescription
00:38:16 <dnikolovv> and then be careful not to make a typo on those keys when implementing FromLookup
00:38:28 <dnikolovv> the whole thing feels kind of fragile
00:38:32 <absence> can Show1 be derived via Generic?
00:38:57 <dnikolovv> what do you mean by Show1?
00:39:33 <dminuoso> absence: Yes.
00:39:55 <dminuoso> absence: At least with Generic1
00:40:08 <dminuoso> absence: See https://github.com/ekmett/transformers-compat/pull/21/commits/71ee2c70cfed44e7d5ddf03965baff4c14832fe5
00:41:40 <absence> oh, there's a Generic1. thanks!
00:43:32 <dminuoso> dnikolovv: Show1 is a typeclass that lets you lift Show to unary type constructors.
00:45:26 <dnikolovv> thank you
00:47:32 <dminuoso> dnikolovv: https://blog.poisson.chat/posts/2017-10-21-making-a-show.html goes a bit down that rabbit hole
00:48:18 <dnikolovv> reading that
00:48:25 <absence> dminuoso: just so i understand, is the idea to define instances with liftShowsPrec = liftShowsPrecDefault from transformers-compat? it's not built into ghc as "deriving Show1" or something?
00:48:27 <dminuoso> In essence its a trick that might become less useful after QuantifiedConstraints is around.
00:48:58 <dminuoso> The blog article mentions `forall a. Show a => Show (f a)` 
00:49:06 <dminuoso> We cant express that in standard haskell
00:49:22 <dminuoso> You can think of `Show1 a` as being an encoding of the above
00:49:38 <dminuoso> Err, `Show1 f` rather
00:50:04 <dminuoso> absence: Read the blog post too! :0
00:53:10 <absence> dminuoso: i did give it a glance, but it seems to suggest using template haskell because no generics library exists? it doesn't mention transformers-compat
00:53:38 <dminuoso> absence: I just mentioned that library because I found a Generic1 instance for Show1 there.
00:54:08 <dminuoso> https://hackage.haskell.org/package/transformers-compat-0.6.5/docs/src/Data.Functor.Classes.Generic.Internal.html#GShow1
00:56:33 <absence> dminuoso: i'm confused :D i haven't heard about GShow1, and the blog post briefly mentions GShow without going into details
01:17:17 <tolt> When writing an instance of a type class, what is the reason that `instance A (B C)` doesn't work but `instance (c ~ C) => A (B c) ` does?
01:19:54 <merijn> tolt: The report is fairly conservative (most people would say *too* conservative) in what it allows typeclass instances too look like
01:20:57 <merijn> tolt: Specifically, the report demands they only include one non-type variable (i.e. B) and then complainsa bout the C. In the second 'c' is a type variable (a constrained one, but that's irrelevant to the compiler logic) so that's fine
01:21:21 <tolt> merijn: hmm, I guess I'm just curious about why I can never get an instance like `instance A (B C)` to resolve
01:21:46 <tolt> The instance compiles fine
01:21:47 <merijn> tolt: I'd simply enable -XFlexibleInstances instead, that's one of the least controversial extensions in existence and if we ever do get a new Haskell report I'd expect it to be in there
01:22:21 <merijn> tolt: What do you mean by "can't get it to resolve"?
01:24:22 <boxscape> interestingly -XFlexibleInstances isn't on the list of https://github.com/haskell/rfcs/projects/1, but then, there's probably lots of things that would be included in a report that aren't on that list
01:24:53 <tolt> merijn: The instance compiles on its own (say `instance A (B C) where ...` . When I want to use a function defined in the typeclass GHC can't find the instance. Switching the definition to `instance (c ~ C) => A (B c)` somehow allows GHC to resolve the instance
01:27:18 <merijn> tolt: I know that the latter (supposedly, I have never run into this issue) infers better
01:27:28 <merijn> But it's hard to say what's going on without specific examples
01:27:57 <tolt> Yeah, it was weird. A coworker sent the issue to me and I immediately knew what the problem was but I didn't know the wording to use...
01:57:25 <kuribas> is eta dead?
01:57:51 <phanimahesh> Why do you ask? It was never big to begin with.
01:58:29 <kuribas> because when I told my team lead about haskell, he want to use eta because it works on the jvm.
01:58:29 <phanimahesh> Atleast that's what I thought. I don't live in java land so my only experience was with playing around
01:58:46 <kuribas> I told him it's a bad idea
01:59:05 <tdammers> it probably is
01:59:24 <kuribas> because you give up on most of the ecosystem, restrict yourself to a few libraries, have not much support.
02:00:00 <tdammers> from what I gather, eta is pretty impressive, but it will most definitely not deliver a "Just Works, and there's great documentation and community support for everything, and wrapper libraries exist for everything you could possibly wish for" experience
02:00:19 <tdammers> so yes, this is not a use case for eta
02:00:41 <Arahael> If I was forced to code in the Java ecosystem (I'm biased against anything Oracle), then I'd end up choosing Kotlin, most likely.
02:00:53 <tdammers> eta is probably great when you have a team of experienced haskellers who know how to play the language's strengths, and running on jvm is so vitally important that you're willing to suffer quite some pain for it
02:00:56 <kuribas> also, it's slower, I doubt the benefits for the jvm (good tooling, live debugging), apply here.
02:01:29 <tdammers> the main benefit of JVM, in most business situations, are about deployment
02:01:38 <tdammers> s/benefit/&s/
02:01:52 <kuribas> And from my experience with clojure, the only thing you get from it is interaction with java libraries.
02:01:52 <hpyCdr> I merge multiple Map via [Maybe Map] -> Maybe Map with mconcat . sequence . It seems to first evaluate all the input lists before starting to merge into the final map, causing a lot of memory overhead (I might be wrong). If so, is there another built in call, that avoids this?
02:01:56 <tdammers> the whole "just give me a jar" deployment experience
02:01:58 <phanimahesh> tdammers: that's a good point. I never looked at eta that way
02:02:06 <hpyCdr> *input Maps
02:02:44 <tdammers> phanimahesh: yeah, if you can freely pick any platform to run your Haskell code on, then there is little reason to pick JVM
02:02:44 <kuribas> tdammers: indeed.  And I've been looking at how to get make building and deployment easy in our environment.
02:02:48 <Arahael> tdammers: That's why I like Go, actually.
02:02:54 <Arahael> "Just give me a .exe".
02:03:32 <tdammers> Arahael: you can get pretty close to that with GHC Haskell. "Here's a binary, as long as you have libc and libgmp installed, you're good"
02:03:47 <phanimahesh> hpyCdr: no idea, but how did you figure it out? Looks like it shouldn't happen
02:03:56 <tdammers> it's not the default, but it's only one or two build options away
02:04:04 <phanimahesh> tdammers: matching libc and libgmp
02:04:09 <tdammers> phanimahesh: well yes.
02:04:10 <merijn> kuribas: So something I haven't done yet, but I would seriously look into when having to deploy Haskell is to get a setup where I can build full static executables (so using a musl based toolchain so even the C parts can be linked statically)
02:04:21 <Arahael> tdammers: Not really...  "Here's an arbitrary haskell project. You're on NixOS or MacOS.  Get me a windows .exe".
02:04:29 <phanimahesh> I just fought with libc version mismatches
02:04:40 <tdammers> Arahael: oh, so you want to cross compile. Yeah, that's a bit of a sore spot.
02:04:45 <merijn> phanimahesh: That's because glibc is terrible
02:04:55 <Arahael> tdammers: Trivial with Go. Trivial with Java.  Not with Haskell, yeah.
02:04:56 <phanimahesh> Won't argue that
02:05:23 <phanimahesh> Musl should be more popular
02:05:26 <merijn> Arahael: It's trivial if you built it into your language/compiler from the start, which Haskell didn't, which is a bit unfortunate, yes
02:05:36 <tdammers> Arahael: Go can do it more easily because it doesn't have anything comparable to TH. Java can do it because it cheats by not compiling to native code at all.
02:05:48 <merijn> Arahael: Compounded by the fact that it's unclear how TH should even work when crosscompiling
02:06:00 <Arahael> merijn: And yet, you can compile haskell to javascript.
02:06:10 <merijn> Arahael: So?
02:06:23 <merijn> I don't see how that is at all related?
02:06:30 <phanimahesh> Cross compiling is a different beast. How does js come into picture?
02:06:40 <Arahael> Because node already works everywhere, more or less.
02:06:55 <merijn> Arahael: I fail to see the relevance?
02:07:05 <phanimahesh> Terrible performance, long build times, etc etc
02:07:13 <tdammers> merijn: I don't think it's conceptually unclear, it's more that it requires untangling the mess that is the current implementation. In principle, what you need to do is 1) compile your TH code and everything it depends on for the host platform; 2) compile everything except the TH code for the target platform, running TH as compiled in step 1 as needed
02:07:26 <Arahael> merijn: The relevance is that the TH, etcetera, are not the ultimate problem. You can get a portable executable.
02:07:26 <merijn> tdammers: I am *sure* it's conceptually unclear
02:07:32 <phanimahesh> Haskell to js is only for when you absolutely need js and have haskell stuff.
02:07:36 <phanimahesh> Its not pretty
02:07:44 <Arahael> phanimahesh: It proves that it can be done.
02:07:47 <merijn> Arahael: If you throw out all of the C FFI and libraries depending on it, sure
02:07:53 <Arahael> merijn: But of cours.e
02:07:56 <Arahael> *of course
02:08:09 <phanimahesh> merijn: i am sure it is conceptually clear though.
02:08:13 <Arahael> merijn: You have to do the same with Go, if you want easy cross compilation.
02:08:17 <merijn> tdammers: The problem is that there are 2 separate things that TH are used for and there's currently no way to distinguish them
02:08:56 <tdammers> merijn: well, sure, as I said, it's a mess
02:09:03 <phanimahesh> Namely? I thought th did code gen. What else?
02:09:19 <merijn> tdammers: There is "I want to run this (IO?) code at compile time to generate stuff" which should probably use the host machine, but it is ALSO used to determine properties of the runtime target at compile time
02:09:38 <merijn> phanimahesh: Consider the "simple" case of computing "maxBound :: Int" in TH
02:09:53 <merijn> phanimahesh: Should it refer to the maxBound on the target machine or the host machine?
02:09:56 <phanimahesh> Oh.
02:10:16 <tdammers> merijn: yes, lots and lots of unfortunate details; I think most of them stem from the design decision to not make the boundary between TH and the stuff it operates on more obvious
02:11:28 <phanimahesh> But all codegen systems supporting cross compilation should? Have same issues when you assume build time and runtime env are identical
02:11:36 <merijn> phanimahesh: Either choice is justifiable, in fact wanting to be able to do BOTH is perfectly reasonable, but we currently have no way to distinguish the two
02:11:53 <tdammers> so now you can define a function or IO action or whatever, and use it both from direct code and from TH metacode; and deciding whether we need to compile that function for the host, or for the target, or both, isn't trivial, and we might not even know at the point where we are asked to compile it
02:12:18 <phanimahesh> Yes it's a mess.
02:12:21 <tdammers> I don't think this is a fundamentally unsurmountable problem, just that a proper solution amounts to redesigning large parts of how GHC works
02:12:21 <merijn> phanimahesh: Int is part of code generation for a specific platform, so it's fine to assume what it is for a specific architecture (and code isn't portable across architectures anyway)
02:12:49 <tdammers> and ofc it becomes even messier when FFI and CPP are involved
02:13:15 <merijn> And sure, you can "use TH" in JavaScript right now when compiling Haskell, but those implementations making some pretty arbitrary choices of what TH means
02:13:34 <merijn> So while you can "use it" you can't actually know/control whether it means what you intend it to
02:19:18 <hpyCdr> phanimahesh, I wrote the 'optimal' solution by hand, the result is the same. So it seems to behave as expected. I'll keep looking
02:20:40 <Arahael> merijn: Clearly, it'd be a major version update.
02:21:13 <merijn> Arahael: hmm?
02:22:49 <Arahael> merijn: A new TH, with an interim "compatibility" phase with similar gotcha's to what ghcjs suffers - since it's going to be somewhat incompatible, you'd need a major version number bump.
02:23:05 <Arahael> (Then again, I probably don't know what I'm talking about)
02:23:58 <merijn> Arahael: Someone first has to sit down and figure out what things SHOULD mean before we can start worrying about how we can implement it and migrate to that
02:26:56 <kuribas> merijn: I can build static executables, but I still need a matching libc
02:27:40 <kuribas> merijn: right now my idea is to setup a lxd image with a build environment, then create another lxd image for deployment, with the same system.
02:27:47 <Arahael> merijn: That's a fairly good point, I'll accept that.
02:28:07 <merijn> kuribas: No, that with musl you can statically link libc too
02:28:16 <kuribas> merijn: and to have gitlab runners to have continuous integration and deployment.
02:28:27 <merijn> kuribas: Then the only thing you depend on is "compatible syscall/kernel API" and that is fairly stable
02:28:33 <kuribas> merijn: musl has problems with dns resolution.
02:28:59 <merijn> Define problems
02:29:15 <kuribas> merijn: https://github.com/gliderlabs/docker-alpine/issues/255
02:29:26 <kuribas> merijn: it still doesn't seem to be solved.
02:31:10 <merijn> kuribas: It's not obvious to me that that issue is a musl issue
02:33:01 <kuribas> merijn: https://superuser.com/questions/1219609/why-is-the-alpine-docker-image-over-50-slower-than-the-ubuntu-image
02:33:08 <Arahael> Agree, that doesn't look like a musl issue either, though it could well be a difference of interpretation/implemetnation in the libc.
02:34:24 <kuribas> merijn: doesn't using musl complicates the toolchain a lot?
02:34:47 <kuribas> merijn: I am trying to avoid all this complexity, I don't want my team members to say, see, the jvm is so much easier.
02:35:19 <kuribas> merijn: I think having a build environment which is the same as the deployment is the easiest.
02:35:27 <Arahael> kuribas: The glibc/musl thing is kind of like the Oracle JVM / Android Dalvik thing.
02:36:36 <merijn> kuribas: Right, but if you build environment is the same as deploy then you're entire earlier complaint of "glibc needs to be the same version" becomes irrelevant, no?
02:37:22 <merijn> So your problem statement seems to shift around
02:38:19 <Arahael> It may well be that kuribas knows that "there is a" problem, but hasn't yet identified exactly that "the" problem is yet.
02:39:36 <Arahael> Incidentially, this may be another reason Go is so good here as well: It avoids glibc. ;)
02:39:44 <merijn> kuribas: Let's rewind, what exactly is the problem with "just using v2-build and a freeze file"?
02:40:20 <merijn> Arahael: Or...crazy idea...stop using linux and just use something decently engineered like BSD for your servers. Then you get to avoid glibc *and* all the other insanity in linux :p
02:40:58 <Arahael> merijn: That's crazy indeed. ;)  (I'm toying with nixos these days)
02:41:11 <mpickering> Is there a library somewhere which makes incrementally reading from a `Handle` easy? 
02:41:15 <Arahael> At work I use macos.  It's not that much better.
02:41:24 <mpickering> I want to spawn a process and redirect stdout to a logger
02:41:28 <merijn> mpickering: Depends what you mean by that?
02:41:54 <merijn> mpickering: I mean it sounds like "conduit" is the obvious answer to you question?
02:41:58 <mursu> embrace the crazy :)
02:42:05 <mpickering> eh I guess but also no
02:42:45 <mpickering> hmm I can actually as `yaml` already depends on `conduit`
02:48:46 <kuribas> merijn: frezze file?
02:49:20 <merijn> kuribas: You can freeze the current build plan on your machine, forcing to use the exact same build plan
02:49:36 <kuribas> merijn: right, that I also wanted.
02:49:46 <merijn> kuribas: So sorta like stack's snapshots, except you can dynamically freeze them from your current Hackage buildplan
02:50:09 <kuribas> merijn: but I still need to build it for production
02:50:27 <merijn> https://cabal.readthedocs.io/en/latest/nix-local-build.html#cabal-v2-freeze
02:50:49 <merijn> kuribas: If production matches dev, then how is "building" different from "building for production"
02:51:06 <kuribas> merijn: you mean building on production?
02:51:24 <merijn> I don't understand your problem, tbh
02:51:25 <kuribas> I am not sure we want to run all our binaries on the build image
02:51:45 <kuribas> we want some isolation between staging and production
02:51:54 <merijn> isolation of *what*
02:52:22 <merijn> I mean, they're just executables I don't understand what's so hard unless you want to run executables in a different environment which you earlier said you didn't
02:52:45 <kuribas> merijn: ah I see
02:53:08 <kuribas> merijn: freeze plan looks more useful for ensuring the development environment is the same then
02:53:22 <merijn> "isolation between staging and production" they're different machines, just copy the executable to production once you deem it "ready"
02:53:30 <kuribas> merijn: indeed
02:54:48 <kuribas> merijn: that looks like a good plan
02:55:19 <kuribas> merijn: if I can set this up, it will save the team lead from having to think about it himself.
02:55:28 <kuribas> merijn: he only needs to provide a build image which I can setup
02:55:45 <kuribas> merijn: deploying will go via gitlab
02:56:23 <merijn> I mean, that's the entire point/advantage of all Haskell dependencies being linked statically. If you assume all external C dependencies are just installed via apt-get the same way in production and build, then there's really nothing more to do
02:56:34 <kuribas> yeah
02:56:42 <kuribas> and no docker either :)
02:58:04 <kuribas> merijn: the production image can also be fairly small, like 150 MB or so for a minimal image.
02:59:45 <mursu> what base is that 150mb using?
03:00:29 <Arahael> Ubuntu, I suspect.
03:00:57 <mursu> I'd imagine with alpine you could maybe get a smaller image
03:01:36 <Arahael> mursu: You've missed a lot of the conversation.
03:01:40 <mursu> probably
03:02:11 <mursu> I'm also bad at reading which doesn't help lol
03:02:42 <Arahael> Heh, possibly. :)
03:03:29 <kuribas> mursu: short story, alpine linux has problems with slow dns resolution: https://github.com/gliderlabs/docker-alpine/issues/313
03:17:46 <mpickering> merijn: How do I apply an IO action to everything in a conduit? Do I map over it to create a stream of IO actions?
03:18:23 <mananamenos> hi, i can make `cabal test` output stuff to the console instead of a log file?
03:18:26 <mpickering> or is there some consumer which I can use with an (a -> IO ()` function
03:20:42 <dminuoso> mpickering: awaitForever?
03:20:43 <LysergicDreams> mpickering: `mapMC`?
03:21:00 <dminuoso> Oh no. That ^-
03:21:12 <mpickering> Not defined in `Data.Conduit.Combinators`
03:21:20 <mpickering> it seems `mapM_` or `iterM_` might be what I need
03:22:43 <kuribas> merijn: can I fix the ghc version with cabal?
03:23:38 <mpickering> that seems to have worked, thanks
03:23:51 <LysergicDreams> mpickering: Ah, from the source it looks like Conduit.mapMC is just a re-named version of Data.Conduit.Combinators.mapM
03:26:24 <LysergicDreams> And you can use the mapM_ version if you don't care about the result but it'll be the same return type if your action already returns ()
03:31:19 <statusfailed> I want to learn category theory by doing some rigorous proofs; what's a good theorem prover for this? I was looking at Coq and LEAN
03:50:04 <mananamenos> how can i make compiler not to complain writing this in hspec `safetail [] `shouldBe` []`?
03:51:54 <mananamenos> `safetail ([] :: [Int]) `shouldBe` ([] :: [Int])` i can something like this, but it is very specific. I cannot use the type variable `a` instead Int. Is there some better way here?
03:54:24 <dminuoso> mananamenos: Sure you can use the type variable `a`
03:54:54 <dminuoso> mananamenos: You just need to introduce the type variable somewhere above via `forall a. ...` with ScopedTypeVariables enabled
03:55:14 <dminuoso> But
03:55:17 <dminuoso> That doesnt help you
03:56:43 <mananamenos> safetail ([] :: forall a. [a]) `shouldBe` ([] :: forall a. [a]) not working either
03:56:57 <dminuoso> No, what you want doesnt work with hspec
03:56:59 <mananamenos> Ambiguous type variable ‘a0’ arising from a use of ‘shouldBe’ prevents the constraint ‘(Show a0)’ from being solved. Probable fix: use a type annotation to specify what ‘a0’ should be. 
03:57:10 <dminuoso> mananamenos: You could change the problem by taking the length of the list and asserting it to be 0.
03:57:11 <mananamenos> aa ok
03:57:21 <mananamenos> thanks a lot dminuoso
03:57:23 <dminuoso> otr
03:57:26 <dminuoso> % :t null
03:57:26 <yahb> dminuoso: forall {t :: * -> *} {a}. Foldable t => t a -> Bool
03:57:28 <dminuoso> mniip: ^- this
03:57:33 <dminuoso> Wow what happened to weechat there.
03:57:35 <dminuoso> mananamenos: ^-
03:58:14 <dminuoso> (safetail []) `shouldSatisfy` null
03:59:16 <dminuoso> mananamenos: But, you can use parametricity to argue that pinning the type to `Int` or `()` can work.
03:59:41 <dminuoso> mananamenos: If, for example, your `safetail :: [a] -> [a]` you can argue that regardless of what you pick for `a` it will behave the same.
03:59:52 <dminuoso> (Which is what parametricity is all about)
04:06:06 <eden> hello everyone
04:08:24 <ibrox> hi
04:26:34 <merijn> kuribas: cabal just uses whatever there's in your path, or you can explicitly specify which GHC/path
04:34:09 <trcc> Any actual proposals on implemented dependant types for haskell? Or is it still too early?
04:34:13 <trcc> implementing*
04:34:46 <dminuoso> trcc: Yes.
04:34:55 <dminuoso> trcc: TypeInType is one of the major corner stones.
04:35:59 <trcc> dminuoso: this one? https://gitlab.haskell.org/ghc/ghc/wikis/dependent-haskell/phase1
04:37:06 <dminuoso> trcc: yeah. Also relatedly https://gitlab.haskell.org/ghc/ghc/wikis/dependent-haskell
04:37:49 <boxscape> trcc this is a proposal about reserving syntax (rather than implementing) for dependent quantifiers, but it's dormant right now until it's more immediately necessary https://github.com/ghc-proposals/ghc-proposals/pull/102
04:37:53 <trcc> Any way to follow the progression? (if it is on https://gitlab.haskell.org/ghc/ghc/wikis/dependent-haskell, then it is currently timing out for me)
04:37:58 <trcc> ah too fast boxscape
04:38:10 <trcc> what does more immediately necessary mean?
04:39:27 <trcc> any time expectation?
04:40:15 <boxscape> trcc not entirely sure, but rae says at the end that "we shouldn't implement it until other parts fall into place." this might mean things like the grand class unification proposal (https://github.com/ghc-proposals/ghc-proposals/pull/236), lambdas in types, etc. I'm not sure anyone has a timeline at the moment
04:40:47 <boxscape> (better formatted link: https://github.com/ghc-proposals/ghc-proposals/pull/236 )
04:41:23 <boxscape> just looking through the various proposals is the best way to follow the progression I think
04:41:28 <trcc> Thank you dminuoso and boxscape. Will go read ;)
04:41:52 <lortabac> Eisenberg gave an ideal release date for DependentHaskell during last Zurihac (I think it was around summer 2021)
04:42:10 <lortabac> you can probably find the video on Youtube
04:42:11 <trcc> That is not too far away
04:42:29 <boxscape> trcc two more recent proposals that are necessary for dependent types: https://github.com/ghc-proposals/ghc-proposals/pull/236 and https://github.com/ghc-proposals/ghc-proposals/pull/270
04:42:53 <boxscape> oh, first one is the wrong link
04:43:02 <boxscape> https://github.com/ghc-proposals/ghc-proposals/pull/281
04:46:18 <trcc> all the comments are soo interesting and I have actual work do to :(
04:47:32 <berndl> Has someone compared depedent Haskell with e.g. Idris or Agda?
04:47:45 <trcc> berndl: great question!
04:47:53 <boxscape> you might find some comments about it in richard eisenbergs thesis
04:48:35 <boxscape> One of the most important aspect is that there isn't a totality checker in haskell and it would be hard to get one
04:48:56 <boxscape> so you can never be sure your proofs are correct without running them
04:49:06 <lortabac> Haskell is logically inconsistent and allows non-termination, so it cannot be used to prove theorems
04:51:24 <merijn> Of course you can use it to prove theorems, it's just not sound
04:52:17 <lortabac> I mean, you can prove False with Haskell
04:52:54 <boxscape> The proof erasure is different as well, not sure how it works in agda, I think in Idris it's whole-program analysis to determine what can be erased? In haskell, if I'm understanding it correctly (which I might not be), the quantifier you use determines erasure, i.e. anything with forall will be erased but not the things introduced with foreach
04:53:17 <dminuoso> lortabac: You can prove theorems still fine with that.
04:54:28 <Arahael> ~
04:54:31 <lortabac> of course, but if I were a mathematician I'd rather use Agda for that
04:54:51 <berndl> I'm a mathematician and I use Agda.
04:54:57 <berndl> But I don't use it for proving.
04:55:05 <berndl> I use it as a better Haskell.
04:55:33 <berndl> But the totality/positivity checker does get in the way a lot.
04:55:42 <trcc> berndl: how do you see haskell with dependant types compare to agda then?
04:56:24 <berndl> Well, I won't have to worry about totality/positivity and can do all the crazy things that laziness gives you.
04:56:57 <dminuoso> berndl: What is positivity?
04:57:00 <berndl> Coinduction in Agda is not very ergonomic.
04:58:15 <dminuoso> berndl: Ohh, positivity in the sense of monotonicity of datatypes?
04:58:16 <berndl> dminuoso: It basically means that you can't write things like Fix or Free in Agda.
04:58:21 <dminuoso> Right gotcha
04:58:45 <trcc> Thanks for the discussion
04:58:50 <berndl> Actually, I can write Fix and Free, but not in the usual Haskell way.
04:58:54 <dminuoso> berndl: That doesn't seem something to want at first glance. Fix and Free are so useful.. :)
04:59:29 <berndl> This is my definition of Free in Agda: Free F X = forall {M} {{_ : Monad Sets M}} -> (F ~> M) -> M X
04:59:51 <berndl> It's basically the universal property.
05:00:23 <labbekak> Yeah like the Church encoding of Free, no recursion needed right?
05:00:31 <labbekak> You can do it in pure System F.
05:01:07 <lortabac> you can run Agda with --no-positivity-check, --no-termination-check and --type-in-type, but then you probably cannot use the standard library
05:02:53 <berndl> lortabac: That's right.
05:03:05 <berndl> That's why I have my one standard library.
05:03:13 <berndl> *own
05:04:01 <MarcelineVQ> You can write them but you have to show that your f isn't naughty, https://gist.github.com/gallais/9aa22e17b7d64bf943c1dee3f10b675c
05:05:10 <EvanR> > let f :: Int -> Ord t => t -> t; f x y = y in "ok"
05:05:11 <lambdabot>  "ok"
05:05:22 <EvanR> goofy but cool
05:05:26 <berndl> MarcelineVQ: Yep. The agda-stdlib does it that way too, i.e. you define Mu only on containers.
05:24:47 <asheshambasta> Is there a similar way to use `ghcide` dynamically using the correct binary depending on the project GHC version? For example, `hie` has `all-hies` on nix. 
05:25:18 <asheshambasta> (I'm using nixos) 
05:50:00 <__monty__> asheshambasta: If you can encode that in a project's shell.nix I'd look into lorri.
05:51:19 <asheshambasta> __monty__: and then run emacs from within `nix-shell` you mean so that it sees the ghcide binary? 
05:57:25 <__monty__> asheshambasta: No, lorri is basically just a daemon that sets up a direnv environment based on a shell.nix. Direnv automatically changes your environment when you change to a directory.
05:57:55 <__monty__> There's integration with most editors so they do the right thing when you open a file from a dir with a .env file.
06:19:23 <M0b10s> good afternoon everyone!
06:28:54 <svipal> yo
06:36:37 <asheshambasta> __monty__: that looks promising, maybe not just for ghcide. 
06:36:37 <asheshambasta>  
06:36:50 <asheshambasta> (but also for other things)
06:45:46 <__monty__> asheshambasta: Yes, can't imagine my development setup without it anymore : )
07:21:41 * hackage tmp-postgres 1.12.0.1 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.12.0.1 (JonathanFischoff)
07:28:03 <Unhammer> is GHC.Stats.currentBytesUsed the same as GHC.Stats.gcdetails_live_bytes in newer versions? 
07:28:45 <Unhammer> cf. https://hackage.haskell.org/package/base-4.8.1.0/docs/GHC-Stats.html#t:RTSStats vs https://hackage.haskell.org/package/base-4.11.1.0/docs/GHC-Stats.html#g:1
07:30:34 <int-e> the matrix has you
07:31:32 <Rembane> The thundering matrix herd. 
07:31:41 <Rembane> Like the Lion King but in cyberspace.
07:31:47 <Rembane> Mufasa is surely dead.
08:00:41 * hackage tmp-postgres 1.13.0.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.13.0.0 (JonathanFischoff)
08:29:38 <mananamenos> This is from Programming in haskell book, https://pastebin.com/UQPUFJGS. I can't understand how lazy evaluation works with this equation. For `prime 15`, when it hit [1,3], it stop evaluating and returns False. But why wouldn't it return False when at the step [1] == [1,15]?
08:31:38 <merijn> mananamenos: What do you mean "step"?
08:32:37 <mananamenos> so the right side of the equation of `prime 15` is `factors 15 == [1,15]`
08:32:43 <merijn> mananamenos: The point is that equality on lists is defined as "(x:xs) == (y:ys) = if x == y then xs == ys else False
08:33:02 <mananamenos> aa
08:33:06 <merijn> mananamenos: Each element of that list is computed "on demand"
08:33:07 <geekosaur> it generates the factors sequentially, trying 1, 2, 3, ..., so it won't try [1,15] before [1,3]
08:33:08 <mananamenos> then it makes sense
08:33:09 <mananamenos> cool
08:33:30 <dmwit> It never tries [1,15] *or* [1,3].
08:33:30 <merijn> mananamenos: So as soon as it demands something which leads to two elements being different, there's no point in comparing (and thus computing) the rest
08:33:32 <geekosaur> and "demand drivern evaluation" is more correct in some sense than "lazy evaluation"
08:33:45 <dmwit> However, at some point, it *is* (1:3:some delayed computation that hasn't been done yet).
08:33:53 <dmwit> This is not the same as [1,3] at all.
08:34:04 <merijn> dmwit: That's not actually guaranteed to ever be the case :p
08:34:17 * dmwit nods agreeably
08:34:43 <dmwit> But my point is that [1] == [1,15] is definitely not a good mental model of what's happening.
08:34:54 <dmwit> Nor is [1,3] == [1,15]. Neither of those calls is ever made.
08:34:55 <merijn> Man, one of these dies I'm going to implement "weird Haskell" which is Haskell2010, but bit the weirdest possible evaluation strategy that is "not lazy" but still matches the report :p
08:35:13 <merijn> s/dies/days
08:35:50 <merijn> Like, randomly try to evaluate things strictly with a timeout/check for bottom and only fallback to lazy eval when needed :p
08:36:05 <dmwit> strict evaluation with backtracking ^_^
08:36:09 <dmwit> in the Omega monad
08:36:47 <merijn> dmwit: THat's too boring, though. I feel there should be some randomness/active maliciousness in the eval strategy to spice it up
08:37:02 <merijn> (while still conforming, of course!)
08:37:09 <geekosaur> "evil strategy" :p
08:37:35 <merijn> ;)
08:38:29 <svipal> alignment : lazy evil 
08:40:27 <geekosaur> notto be confused with chaotic lazy
08:47:58 <vaibhavsagar> is there a statically linked build of GHC?
08:52:42 <tolt> Does anyone know the reason why the instance `instance SomeClass (A B)` won't resolve but `instance (b ~ B) => SomeClass (A b)` will?
08:53:28 <glguy> A B won't resolve until the type is definitely A B, but A b will be picked as soon as the outer type is A and then b is forced to be B
08:57:18 <goolord[m]> `instance SomeClass (A B)` makes constraint checking undecidable
08:57:32 <goolord[m]> `instance (b~B) ...` is basically what `-XFlexibleInstances` does
08:58:00 <dl3br[m]> i m trying to use the data i receive through websockets to create events that i can use for functional reactive programming (reflex, probably). i did FRP in scala and typescript but never in haskell, and i am new to haskell. 
08:58:30 <glguy> goolord[m]: Neither of those sounds right
08:58:50 * dl3br[m] sent a long message:  <  >
08:59:19 <glguy> dl3br[m]: your message was too long, you'll have to break it up or using a pastebin site
08:59:41 <__monty__> The matrix bridge broke? Normally pastes automatically.
09:00:11 <glguy> It's more of a gradient of brokenness rather than a binary property
09:00:40 <dl3br[m]>  every time i receive data in the forever, i want it to fire an event
09:01:41 * hackage duet 0.0.1 - A tiny language, a subset of Haskell (with type classes) aimed at aiding teachers teach Haskell  https://hackage.haskell.org/package/duet-0.0.1 (ChrisDone)
09:02:04 <goolord[m]> dl3br: http://hexagoxel.de/haddock/reflex-0.5/html/Reflex-TriggerEvent-Class.html#v:newTriggerEvent
09:04:10 <electricityZZZZ> so i just ran across cogent, which as i understand is a total linear (and more restricted) haskell
09:04:41 <electricityZZZZ> why is it desirable to *not* have totality?
09:06:00 <__monty__> Because it's a lot easier to write many things.
09:06:31 <electricityZZZZ> can i get a couple examples, or is there an article about this?
09:06:31 <goolord[m]> dl3br: https://gist.github.com/goolord/d0ed3b6805897cc0a3b9d1c0e166b085
09:12:54 <__monty__> electricityZZZZ: This is a good article on it: https://en.wikipedia.org/wiki/Total_functional_programming
09:15:17 <electricityZZZZ> "Another outcome of total functional programming is that both strict evaluation and lazy evaluation result in the same behaviour" -- interesting
09:17:52 <dl3br[m]> goolord: thank u for the example, next error is that i do not have an instance for (TriggerEvent t IO). do i have to instanciate that myself?
09:18:31 <__monty__> electricityZZZZ: Yes, because there's no exceptional conditions in a total language. So a strict evaluation can't run into errors that a lazy evaluation would pass by.
09:19:09 <goolord> that was psuedocode, `IO` will usually be some weird stack there
09:19:11 <goolord> http://docs.reflex-frp.org/en/latest/
09:22:05 <electricityZZZZ> also i see that the creators of seL4 historically translated haskell to C, and now they are hand-translating cogent to C,... cogent has no runtime and doesn't have a garbage collector,... does anyone have a clue what this transcription process would be accomplishing or why it would be needed at all?
09:24:02 <Rembane> electricityZZZZ: The cogent -> C process?
09:24:35 <electricityZZZZ> Rembane: yeah, i understand why it would be needed for haskell
09:24:41 <svipal>  never even heard of cogent
09:24:42 <electricityZZZZ> is it a memory layout thing for interacting with drivers...?
09:24:45 <Rembane> electricityZZZZ: Why wouldn't it be needed for cogent? 
09:25:09 <electricityZZZZ> well as i mentioned above, cogent has no runtime and is linear (no GC)
09:25:53 <Rembane> electricityZZZZ: How are you gonna execeute it? 
09:26:30 <electricityZZZZ> well my question is why it is *hand* translated to C
09:27:09 <electricityZZZZ> put another way, if the runtime is taken care of, and GC is taken care of, what other reasons would there be to hand-translate haskell to C?
09:28:06 <Rembane> electricityZZZZ: It seems to generate C.
09:28:41 * hackage propellor 5.10.1 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-5.10.1 (JoeyHess)
09:29:01 <electricityZZZZ> Rembane: yes but in spite of that there was a manual translation process, according to the paper
09:30:03 <Rembane> electricityZZZZ: Nice! Maybe they did that as a first step to verify to themselves that the cogent language actually was executable?
09:31:08 <electricityZZZZ> i think you aren't really understanding the purpose of my question, which is to understand what benefit there would be for hand-translating haskell to C, aside from runtime freedom and GC
09:33:25 <Rembane> electricityZZZZ: I see, I can't see any benefit at all, but hopefully someone else here can. 
09:43:44 <ChrisPenner[m]> Who knows much about how stackage works? I have a tricky question;
09:43:45 <ChrisPenner[m]> I just recently (minor) patched `pcre-light` (which is on stackage) and I need to depend on the new minor version in `lens-regex-pcre` (also on stackage). How do I do this without getting kicked off stackage for depending on something out of scope? Or can I just add the dependency constraint in my package.yaml and they'll both be picked up in the next nightly?
09:57:16 <LCRERGO> Hi, is there a way to read a .haddock file?
09:57:33 <LCRERGO> I mean like a text file
09:57:48 <svipal> wdym
10:02:35 <LCRERGO> I have xmonad.haddock file and I want to see what is in it
10:03:08 <dmwit> Do the HTML files that haddock produces not suit your needs for some reason?
10:05:48 <lavalike> LCRERGO: haddock --show-interface=parsec.haddock "works" for me (:
10:07:08 <lavalike> ( ``… |& jq | less'' for legibility )
10:16:39 <EvanR> what do you call an operation like... (a -> a -> a) -> [a] -> [a]
10:16:59 <dmwit> What does it do?
10:17:05 <dmwit> At a guess: I call it foldb.
10:17:09 <EvanR> [] is mapped to []. [x] is mapped to [x]. and length > 2 is reduced to length 1
10:17:29 <dmwit> I call it foldb, but give it type a -> (a -> a -> a) -> [a] -> a
10:17:38 <glguy> or -> Maybe a
10:17:48 <EvanR> that type won't let you do [] to []
10:17:57 <EvanR> Maybe would make more sense
10:18:06 <glguy> EvanR: dmwit added an extra  a -> 
10:18:34 <EvanR> ah well then it's just a specialization of fold1
10:18:43 <dmwit> https://gist.github.com/dmwit/6dce178eab1988fc7219153534ad8788
10:19:19 <EvanR> what is 'b' for
10:19:22 <dmwit> binary
10:19:37 <dmwit> Take careful note of the order this coalesces things in. Neither foldr nor foldl order.
10:19:41 * hackage R-pandoc 0.2.3 -   https://hackage.haskell.org/package/R-pandoc-0.2.3 (CorentinDupont)
10:19:48 <dmwit> It coalesces neighbors to half the length of the list, then iterates that.
10:20:13 <dmwit> Which is a sort of tree fold for binary trees.
10:20:17 <dmwit> Which motivates the b.
10:20:47 <dmwit> (half? halve? which is the verb form? whatever)
10:20:56 <EvanR> i was thinking foldl order would make the most sense
10:22:53 <EvanR> @hoogle Maybe a -> [a]
10:22:54 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
10:22:54 <lambdabot> System.Directory.Internal.Prelude maybeToList :: () => Maybe a -> [a]
10:22:54 <lambdabot> Distribution.Compat.Prelude.Internal maybeToList :: () => Maybe a -> [a]
10:22:59 <EvanR> shoulda known
10:22:59 <lavalike> does anyone happen to know how to avoid ctrl+y stopping ghci? I use it often in the shell to paste some input that was previously cut (e.g. ctrl+k)
10:23:10 <dmwit> plain old toList has the appropriate type, too
10:23:14 <dmwit> > toList (Just 3)
10:23:16 <lambdabot>  error:
10:23:16 <lambdabot>      Ambiguous occurrence ‘toList’
10:23:16 <lambdabot>      It could refer to either ‘F.toList’,
10:23:25 <dmwit> > F.toList (Just 3)
10:23:27 <lambdabot>  [3]
10:24:01 <EvanR> rockin
10:24:03 <dmwit> ctrl+y doesn't stop ghci here. But then I use vim keybindings, so perhaps whatever I did to enable that also modified what ctrl+y does.
10:24:29 <dmwit> I believe that's `editMode: Vi` in ~/.haskeline
10:24:51 <lavalike> dmwit: does it paste what you cut with ctrl+k ? (it deletes from the cursor forward)
10:25:00 <dmwit> If you *only* want to change what ctrl+y does, perhaps poking around in the haskeline docs would be a good next step.
10:25:27 <dmwit> p pastes what I cut with D
10:26:05 <dmwit> (In normal mode, rather than insert mode, obviously.)
10:26:24 <lavalike> > let foldb op def xs = foldb1 op (def:xs) where foldb1 op = foldb' where pairwise (x:y:rest) = op x y : pairwise rest; pairwise xs = xs; foldb' xs@(_:_:_) = foldb' (pairwise xs); foldb' [x] = x in foldb (+) 0 [1..10] :: Expr
10:26:25 <lambdabot>  0 + 1 + (2 + 3) + (4 + 5 + (6 + 7)) + (8 + 9 + 10)
10:27:07 <dmwit> (try 1..16, it will be more regular)
10:27:37 <lavalike> > let foldb op def xs = foldb1 op (def:xs) where foldb1 op = foldb' where pairwise (x:y:rest) = op x y : pairwise rest; pairwise xs = xs; foldb' xs@(_:_:_) = foldb' (pairwise xs); foldb' [x] = x in foldb (+) 0 [1..16] :: Expr
10:27:38 <lambdabot>  0 + 1 + (2 + 3) + (4 + 5 + (6 + 7)) + (8 + 9 + (10 + 11) + (12 + 13 + (14 + ...
10:27:53 <lavalike> 0 + 1 + (2 + 3) + (4 + 5 + (6 + 7)) + (8 + 9 + (10 + 11) + (12 + 13 + (14 + 15))) + 16
10:28:43 <lavalike> wow I had no idea you could use non-vi things with vi-like command/insert/etc modes
10:28:45 <dmwit> heh, I was off by one, forgot 0 was included
10:29:15 <dmwit> Your shell almost certainly also has a vi-like line-editing capability.
10:29:29 <lavalike> I think I prefer the standard one, I guess they are emacs like?
10:29:45 <dmwit> In zshrc, it's bindkey -v
10:29:58 <lavalike> ctrl+y just always makes me sad, maybe haskeline can be prod to behave
10:30:00 <dmwit> emacs-like is a common default, yes
10:30:55 <lavalike> 'stty dsusp undef' magically makes it not behave like ctrl+z
10:31:12 <Zemyla> Why are sconcat and mconcat for a -> b not defined as [sm]concat ls = \e -> [sm]concat (fmap ($ e) ls)?
10:33:01 <lavalike> (found here: https://stackoverflow.com/a/46310328 )
10:37:34 <dmwit> I suspect no good reason. If you have a use case where that's better, I encourage you to send a patch to libraries@
10:38:34 <dmwit> Bonus points for describing the use-case that makes it better enough that people think you know what you're talking about. ;-)
10:51:56 <EvanR> dmwit: what's with this wacky grouping
10:57:12 <djanatyn> any advice on debugging dante? i have a stack project that builds fine with `snack build` and `stack build`, but dante can't find modules in subdirectories in my `hs-source-dirs`: https://gist.github.com/djanatyn/d9519a198c21a79ee5fbe36d3b4cd505
10:59:27 <djanatyn> added my cabal, stack, and hpack config if anyone is familiar
11:09:37 <sim590> Why is hashtable returning IO () https://hackage.haskell.org/package/base-4.2.0.2/docs/Data-HashTable.html ? Couldn't it be implemented as a pure function? What's the rational?
11:10:16 <higherorder> Hello! Quick question: what's haskell's default behaviour when calling "error"? It doesn't appear to write anything to `stderr`
11:10:32 <f-a> higherorder: it should
11:10:41 <f-a> ah my bad
11:11:48 <jle`> higherorder: calling error doesn't actually quite do anything, but trying to evaluate something that is defined using 'error' will trigger an stderr output
11:12:20 <jle`> sim590: it's a mutable hash table
11:12:26 <ryan__> hi all
11:13:18 <higherorder> jle`: ah
11:13:27 <jle`> sim590: you could have a persistent/immutable hashtable use pure functions, but an ephemeral/mutable hashtable (a different data structure) would require IO or something similar
11:13:33 <higherorder> jle`: thanks! 
11:13:42 <jle`> higherorder: np :)
11:14:04 <jle`> higherorder: think of it like a trap for the evaluator
11:14:15 <jle`> > head [1,2,error "gotcha"]
11:14:17 <lambdabot>  1
11:14:20 <jle`> > head [error "gotcha",2,3]
11:14:21 <lambdabot>  *Exception: gotcha
11:14:49 <jle`> just having error in the list doesn't trigger anything, but any attempts to evaluate it will explode
11:15:02 <higherorder> jle`: yep; basically I am having a problem with it in context; I am writing an app running on AWS Lambda using hal (https://github.com/Nike-Inc/hal) and errors aren't showing up in the logs, but what you told me just made me think that perhaps `hal` is catching the errors and so they don't end up on stderr
11:15:10 <EvanR> > head [1, 2, let bomb = bomb in bomb]
11:15:12 <lambdabot>  1
11:15:13 <higherorder> I'm looking into it now!
11:15:34 <koz_> EvanR: It's an Infinity Bomb!
11:15:34 <jle`> higherorder: fwiw, 'error' is kind of badly named -- it's to really meant for 'errors'
11:15:51 <jle`> in that it's not meant for exceptions and control flow and stuff like that
11:16:02 <EvanR> koz_: great time for an emoji identifier
11:16:04 <jle`> it's not meant to be reliably usable for exceptions or error handling
11:16:04 <ryan87> I have a basic question and I hope this is the right place
11:16:11 <f-a> shoot, ryan87 
11:16:14 <koz_> ryan87: It probably is.
11:16:15 <higherorder> follow up question: Protolude's "panic" function is documented as "Uncatchable exceptions thrown and never caught.", but... it appears catchable? (with `try`)
11:16:32 <ryan87> thanks, f-a :)
11:16:43 <EvanR> protolude is trying a jedi mind trick
11:16:50 <jle`> higherorder: it is not reliably catchable
11:16:51 <sim590> jle`: Yeah, I finally figured, but why make mutable? What's the point?
11:16:53 <ryan87> I'm trying to install cabal from source via homebrew with brew install -s cabal-install
11:16:59 <higherorder> jle`: why so?
11:17:05 <EvanR> because you're not supposed to catch a panic
11:17:14 <ryan87> and I get the following error in compilation: Configuring HTTP-4000.3.12...
11:17:14 <ryan87> Setup: Encountered missing or private dependencies:
11:17:14 <ryan87> base >=4.3.0.0 && <4.13
11:17:14 <ryan87> Error during cabal-install bootstrap:
11:17:14 <ryan87> Configuring the HTTP package failed.
11:17:15 <higherorder> "not supposed to", but... you can, right?
11:17:17 <jle`> higherorder: it basically depends on 'hacks' in the evaluation semantics
11:17:27 <jle`> higherorder: you're basically relying on undefined behavior to catch it with try
11:17:51 <ryan87> I've checked out some of the config source in the relevant build scripts and I've inferred that base is a Haskell package
11:17:52 <jle`> it's really not meant to be used as a tool for control flow/exceptions because it breaks semantics
11:18:18 <ryan87> but it isn't totally clear to me how to install base without having cabal already installed
11:18:19 <higherorder> jle`: why is panic any more uncatchable than error?
11:18:23 <jle`> sim590: well, there are advantages and disadvantages without both the two (different) data structures
11:18:30 <jle`> higherorder: it's the same level of uncatchable
11:18:41 <sclv> you can’t install base
11:18:47 <koz_> sim590: Performance mostly.
11:18:50 <jle`> sim590: without/both
11:18:52 <koz_> It's the same reason we have mutable arrays.
11:18:53 <f-a> ryan87: I am sorry I do not use osx but base  comes bundled with ghc
11:19:03 <higherorder> jle`: so what's the point of `try` if it's UB
11:19:03 <jle`> i would say...situational performance/memory
11:19:05 <sim590> jle`: I know that the point to have a hash table, theoretically (whatever the syntax of that word), is to have O(1) complexity in accessing an element.
11:19:09 <sclv> you have to use the base bundled with your ghc
11:19:17 <jle`> higherorder: 'try' is defined. but it's defined for *exceptions*
11:19:24 <koz_> sim590: That's a mutable hash table.
11:19:28 <sclv> You can’t get a new one without a different version of ghc that bundles a different one
11:19:35 <ryan87> sclv, f-a, okay interesting. ghc compiled fine and I have the latest stable version
11:19:37 <jle`> higherorder: in particular, it has well-defined semantics for IO Exceptions, thrown in IO
11:19:42 <koz_> An immutable equivalent of that is Theta(log_(large number)(n)).
11:19:46 <sim590> koz_: How making it mutable enables O(1) access ? Are they using arrays behind the scene?
11:19:49 <higherorder> jle`: ah, I see
11:19:52 <koz_> sim590: Yes.
11:19:56 <koz_> That's exactly it.
11:20:06 <jle`> higherorder: so things like throwIO :: Exception e => e -> IO a
11:20:08 <ryan87> 8.8.1
11:20:15 <koz_> To have something equivalent and be immutable and not have Theta(n) copying, you need something like a HAMT.
11:20:24 <sclv> ryan87: right so you’re probably just trying to install a package not yet conpat with the newest base
11:20:30 <koz_> And a HAMT only gives Theta(log_(large number)(n)).
11:20:39 <ryan87> sorry, I know this is more of a platform question than a haskell question
11:20:45 <koz_> (large number is usually 32 I think, but it doesn't really have to be)
11:20:57 <EvanR> 32 is pretty huge i dunno
11:21:07 <sclv> its fine, we answer those questions here
11:21:07 <koz_> EvanR: It's two to a whole _five_!
11:21:30 <EvanR> it's 3 followed by one 2
11:21:40 <jle`> higherorder: IO's semantics give a clear view of what exceptions, as IO, should mean/do.  throwIO e :: IO a is an IO action that triggers an IO acception, which bubbles up to the nearest try
11:21:43 <koz_> EvanR: Two whole digits!
11:21:53 <koz_> That's 100% more than just 2 on its own.
11:22:06 <sim590> koz_: OK. Yeah. I have not yet understood how you develop that black magic. Is that solely something a Haskell language dev can make or can I use arrays easily me too in my project?
11:22:10 <jle`> higherorder: but error/panic have no defined semantics for recovery.  semantically they are all _|_ which is basically 'nothing makes sense anymore, do not try to make sense o fit'
11:22:14 <higherorder> jle`: hmm I see, the problem is that for my use-case I think I do need to catch *everything*. I am running some code on AWS Lambda; the details don't matter, but what's important is that my program is ran by a bigger piece of haskell code called a "runtime" (for aws lambda). This runtime needs to be able to catch any error to then report it in the logs
11:22:14 <koz_> sim590: You can use arrays.
11:22:18 <koz_> You need the vector package.
11:22:24 <f-a> ryan87: hold tight, I am sure there is some mac users who can tell us which is the sensible way to install cabal on a mac
11:22:31 <sim590> And the vector package will live in the IO monad?
11:22:41 <koz_> But the way immutable arrays work is more or less 'you can trigger a Theta(n) copy on _any_ change, we just avoid it where possible'.
11:22:45 <EvanR> haskell has an embarrassment of array types to choose from
11:22:48 <koz_> sim590: _Mutable_ arrays can be in any PrimMonad.
11:22:53 <jle`> sim590: we have immutable arrays in haskell
11:22:55 <koz_> Usually, this is IO or ST.
11:23:01 <ryan87> f-a, in all fairness, I'm not really trying to install the sensible way, I'm trying to explicitly build from source
11:23:11 <koz_> Although any transformer stack atop either would also work.
11:23:15 <f-a> well, you have ghc 8.8, right?
11:23:25 <ryan87> f-a, yup, 8.8.1
11:23:30 <jle`> higherorder: the ideal 'solution' is to never use error or undefined or _|_ for anything you want to behave predictably
11:23:31 <sclv> Latest cabal doesn’t build with latest ghc its a known issue
11:23:46 <sclv> use a binary, or try head
11:23:46 <shapr> is the matching base for 8.8 on hackage?
11:23:49 <ryan87> sclv, whoa...
11:23:57 <koz_> sclv: *giggle*
11:24:08 <koz_> Ahem.
11:24:26 <sclv> shapr: no. Latest hackage can’t yet host latest base because it needs to upgrade some deps
11:24:31 <sclv> Another known issue
11:24:41 <ryan87> >.>
11:24:44 <jle`> higherorder: unfortunately this solution is not practical if you are importing any library that uses error/undefined internally. the best way to get around it is to send a PR berating them or use a fork
11:24:46 <ryan87> what do?
11:24:50 <sclv> 8.8.1 release threw everything out of wack
11:24:57 <f-a> ryan87: maybe 8.6?
11:24:58 <higherorder> jle`: haha
11:25:08 <sclv> ryan87: just download a binary
11:25:16 <koz_> jle`: Use a fork on the maintainers in lieu of berating them?
11:25:20 <jle`> higherorder: alternatively you have tools that can try their best to catch it whenever possible and usually true for GHC's behavior
11:25:30 <higherorder> jle`: isn't using "error" legit in scenarios where some code-path should never be reached under normal circumstances, though?
11:25:32 <jle`> koz_: yes for those who don't feel like confrontation
11:25:53 <ryan87> sclv: simple enough, I'll do that
11:25:58 <jle`> higherorder: only if you want to completely render your program unusable if abnormal conditions arise
11:26:13 <jle`> higherorder: and forbid any sort of meaningful error recovery
11:26:14 <ryan87> sclv: I have to admit though, I'm giggling like a schoolgirl right now
11:26:24 <koz_> ryan87: You aren't the only one.
11:26:26 <EvanR> if you have a proof undefined can't be reached, you're good. Unfortunately you often don't have the proof in the code itself
11:26:28 <sim590> OK. Thanks for explanations guys.
11:26:45 <ryan87> koz_: lol
11:26:49 <EvanR> and we know how long proofs outside the code survive
11:26:49 <koz_> sim590: No worries. Ask if you have issues - but vector is pretty well documented.
11:26:52 <sclv> They just didn’t cut a new release yet
11:26:59 <sclv> It happens
11:27:06 <jle`> higherorder: it's sort of an extreme i suppose, because in practice we have some predictability in how GHC in specific behaves, outside of the UB of the haskell spec
11:27:37 <jle`> but haskell semantics prevents it from being perfectly predictable, we just have to do dark magic to try our best
11:27:52 <EvanR> it's possible that "normal circumstances" your proof refers to is "all circumstances as long as no one touches the code"
11:28:07 <EvanR> which is better than nothing
11:28:15 <sclv> In partic they needed to release one in conjunction with the ghc release, but the release broke some dep chains so then they’d have needed to release another right after
11:28:25 <sclv> And the pace was too demanding
11:28:25 <EvanR> but then you have people with the belief "there are always bugs"
11:28:33 <jle`> higherorder: one way you can sort of attempt to tame it is to deepseq everything you 'try'
11:28:38 <sclv> So they took a month or two between releases
11:29:37 <jle`> higherorder: the main thing that can go wrong is if an IO action executes all its effects without evaluating its result value (which is possible and normal). so if you use 'try', 'try' only catches exceptions thrown as a part of IO execution
11:30:15 <jle`> higherorder: so if you have something like `const undefined <$> pure ()`, try would not catch that because it's only looking for exceptions thrown as a part of IO actions/IO effects
11:30:29 <ryan87> sclv: would it be fair to say that cabal is to pip as the ghc is (very roughly) to cpython?
11:30:41 <jle`> higherorder: so in *practice* one way to avoid that large case of errors is to deepseq+evaluate everything before you try it
11:30:48 <jle`> `try` it
11:31:23 <sclv> Idk. I don’t use python enough to say
11:31:41 <sclv> there’s a bunch of package tools iirc
11:32:06 <ryan87> sclv: fair enough
11:32:33 <jle`> % let noExceptions = do putStrLn "I'm a-ok"; return undefined
11:32:33 <yahb> jle`: 
11:32:36 <ryan87> sclv: thanks for the help btw. I would've never figured out the build thing alone
11:32:38 <higherorder> jle`: errrr I see
11:32:58 <jle`> % do try noExceptions :: IO (Either SomeException ()); print "goodbye"
11:32:58 <yahb> jle`: I'm a-ok; "goodbye"
11:33:27 <jle`> try only catches "IO Exceptions", exceptions thrown as IO effects using throwIO or some other mechanism
11:33:39 <jle`> so it won't catch that the result value is undefined
11:34:09 <jle`> but we can get around it with evaluate + deepseq
11:34:33 <jle`> % do try (evaluate . force =<< noExceptions :: IO (Either SomeException ())); putStrLn "goodbye"
11:34:33 <yahb> jle`: ; <interactive>:37:4: error:; * Ambiguous type variable `e0' arising from a use of `try'; prevents the constraint `(Exception e0)' from being solved.; Probable fix: use a type annotation to specify what `e0' should be.; These potential instances exist:; instance Exception NestedAtomically -- Defined in `Control.Exception.Base'; instance Exception NoMethodError -- Def
11:34:56 <higherorder> jle`: thanks a lot
11:34:57 <jle`> % do try (evaluate . force =<< noExceptions) :: IO (Either SomeException ()); putStrLn "goodbye"
11:34:57 <yahb> jle`: I'm a-ok; goodbye
11:35:02 <jle`> whoops, even that didn't do it
11:35:04 <jle`> how embarassing
11:35:14 <higherorder> :D
11:35:22 <EvanR> for more shenanigans see the spoon package
11:35:33 <jle`> 'evaluate' is supposed to turn the evaluation of your result into an IO action itself, so that IO action would throw errors during evaluation that 'try' could catch
11:36:02 <jle`> i guess in this case there's no way to catch that undefined
11:36:12 <EvanR> spoon :: NFData a => a -> Maybe a
11:36:45 <EvanR> I'm being mischevious you probably shouldn't use spoon
11:36:49 <jle`> spoon is another way to 'try your best' to catch bad usage of error/undefined. and it seems just secure enough to misplace your trust in heh
11:36:59 <jle`> i used it a lot my first year of haskell before realizing it was all a lie :'(
11:37:20 <sm[m]> hi ChrisPenner.. didn’t understand completely but I would expect just set your right bounds and stackage will do the right thing
11:38:14 <ChrisPenner[m]> sm: that's what I figure 😄, thanks!
11:38:29 <jle`> higherorder: really it is unfortunate that there is no middle-ground between "i trust this code 99% so i'll return Maybe" and "i trust this code 100% so i'll use error", because there's code that you might be sure of 99.99999% of the time, but you aren't confident enough to want to completely give up all ability of error recovery
11:38:59 <EvanR> need a continuum of error techniques near the 100%
11:39:07 <higherorder> jle`: yeah :(
11:39:17 <jle`> higherorder: a 'practical' way this is handled in library design is to offer both the Maybe version and the not-Maybe version, so that the end-user can use the non-Maybe version normally and if it gives them toruble, they can file an issue while switching to the Maybe version
11:39:41 <EvanR> use a term that has a probability of erroring or being Nothing
11:39:48 <hyperisco> Any Maybe-based API becomes a non-Maybe-based API via fromJust, no?
11:40:05 <jle`> or even for the library developer it can be helpful, as they can use the Maybe version to help debug their own code and isolate where it is coming from
11:40:09 <EvanR> yeesh. yes. And spoon is the reverse of that
11:40:12 <jle`> s/library developer/application developer writing functions
11:40:25 <EvanR> something is lost in translation both ways
11:40:28 <jle`> hyperisco: yes; i'm just saying that it's better that the library author/internal module is the one doing the fromJUst
11:40:38 <jle`> because they're the one with the 'proof' that it won't be Nothing
11:41:04 <EvanR> supposedly
11:41:13 <jle`> returning a Maybe to the user when you "know" it's 99.99999% for sure going to be a Just is a little disingenuous
11:41:27 <jle`> i mean, it's 'honest' in the most extreme sense, heh
11:41:43 <jle`> but you'd want to do the dirty deed (fromJust) yourself and save the user from the moral burden
11:41:44 <EvanR> yes
11:42:02 <EvanR> when you have a Maybe that is always a Just, then there is really no reasonable way to handle Nothing
11:42:21 <hyperisco> jle`, what I am thinking of is when there is 100% reliability when the preconditions are met, and only the user knows if they're met, so the opposite of your case
11:42:25 <higherorder> jle`: yeah but how do you deal with the case of "I want to run this black-box code, and if it fails (even in an unrecoverable way), I want to log the error somewhere (and not crash the whole program)"
11:42:34 <higherorder> from what you said, I guess the answer is "you cannot"
11:42:47 <EvanR> higherorder: i like running it in an async thread
11:43:02 <EvanR> and waiting for the result
11:43:08 <EvanR> i pretend this is erlang
11:43:08 <higherorder> ah, interesting
11:43:09 <monochrom> You can catch exceptions.
11:43:19 <higherorder> I am using https://github.com/Nike-Inc/hal, which doesn't do that.. But perhaps I should write something that does
11:43:31 <monochrom> And yeah using its own thread is also good sandboxing.
11:43:33 <higherorder> They do this: https://github.com/Nike-Inc/hal/blob/master/src/AWS/Lambda/Runtime.hs#L137
11:43:37 <jle`> there are hacks to somewhat guarantee it.  i believe people who do 'important' systems with haskell have some sort of precautions against it, outside of auditing all code they import to ensure it never uses error/undefined
11:43:48 <djanatyn> (figured out my dante problem! switching `dante-methods` to run `stack` first helped)
11:44:15 <evelyn> Nike .oO
11:44:35 <monochrom> The async library has simple functions that do it all: run in a new thread and tell you which exception it throws.
11:44:43 <EvanR> cool Nike uses haskell
11:55:04 <dmwit> EvanR: Some things are more efficient when done on "similarly-sized" data structures than when done on "one-big one-small" structure.
11:55:45 <EvanR> interesting
11:56:00 <dmwit> EvanR: So e.g. `foldb (*) 1 [1..1000]` is a bit faster than `foldl' (*) 1 [1..1000]` because bigint multiplication is faster when the bitwidths of the two operands is very close.
11:56:32 <dmwit> Or, well... that's not quite the right way to say it.
11:56:58 <dmwit> Bigint multiplication's speed is mostly determined by the wider operand.
11:57:09 <dmwit> So if you can do more multiplications where the wider operand is small, you're better off.
11:57:53 <EvanR> this calls for a bot-timed experiment
11:58:29 <dmwit> There are other operations that are similar; e.g. if you're building a big Map one key at a time, it might be more efficient to use foldb M.union than foldl' M.union
11:59:00 <boxscape> % data GADT a where GADTList :: [a] -> GADT [a]
11:59:00 <yahb> boxscape: 
11:59:11 <boxscape> does the a in GADTList shadow the previous a here?
11:59:17 <dmwit> (Of course asymptotically it's exactly the same.)
11:59:19 <boxscape> seems like you would get an infinite type with a ~ [a] otherwise
11:59:40 <dmwit> boxscape: Sort of. It technically doesn't shadow anything because the first `a` isn't in scope at all inside the `where`.
11:59:47 <boxscape> oh, ok
12:00:17 <svipal> massiv looks really damn scary but it's actually quite pleasing to use
12:01:03 <svipal> that index type is really nice, and there are a lot of convenient instances
12:01:36 <svipal> and it doesn't lock you into crazy requirements, which is what I was afraid of because of the sheer number of typeclasses involved
12:03:43 <svipal> (by crazy reqs I meant you'd have to type (Class2 a, Class3  b) => before every function 's type dec in your prog)
12:12:11 * hackage lens-regex-pcre 1.1.0.0 - A lensy interface to regular expressions  https://hackage.haskell.org/package/lens-regex-pcre-1.1.0.0 (ChrisPenner)
12:23:29 <jle`> boxscape: basically none of the 'names' of the type variables in the constructor for GADT syntax matter. it's kind of awkward
12:23:44 <boxscape> I see
12:23:57 <jle`> boxscape: you might as well write data GADT _ where GADTList :: ... and get the same effect: the only information it is providing is 'how many'
12:24:03 <jle`> but i don't think that syntax is allowed
12:24:25 <boxscape> % data GADT _ where GADTList :: [a] -> GADT [a]
12:24:25 <yahb> boxscape: ; <interactive>:50:11: error:; Unexpected type `_'; In the data declaration for `GADT'; A data declaration should have form; data GADT a = ...
12:24:29 <boxscape> :(
12:24:39 <jle`> but at least, the names of the type variables to the type constructor are completely ignored in all situations
12:24:56 <jle`> except for template haskell
12:25:04 <jle`> and generics i suppose, if you don't have a real GADT
12:25:15 <boxscape> % data GADT __ where GADTList :: [a] -> GADT [a]
12:25:15 <yahb> boxscape: 
12:25:19 <jle`> cute :)
12:25:34 <jle`> that's why you'll see a lot of people preferring kind signatures instead of type variables for the type constructor
12:25:40 <jle`> data GADT :: Type -> Type where
12:25:49 <jle`>     GADTLIst :: [a] -> GADT [a]
12:25:50 <boxscape> oh I somehow forgot that that let's you omit the variable
12:25:53 <jle`> provides some sort of symmetry i suppose
12:32:18 <boxscape> hm, I feel like this should work with TypeOperators
12:32:19 <boxscape> % id' x = x; id' :: (+) -> (+)
12:32:19 <yahb> boxscape: ; <interactive>:61:19: error: Not in scope: type constructor or class `+'; <interactive>:61:26: error: Not in scope: type constructor or class `+'
12:32:30 <boxscape> maybe I'm missing something though
12:32:44 <boxscape> as in, missing a good reason to make it not work
12:33:18 <boxscape> ah
12:33:27 <boxscape> let me rephrase
12:33:38 <boxscape> % id' x = x; id' :: forall (+). (+) -> (+)
12:33:38 <yahb> boxscape: ; <interactive>:62:27: error: parse error on input `+'
12:33:44 <boxscape> this should work, but not the other one, maybe
12:40:57 <boxscape> (I suppose this is closely related to the effort to unify type and term namespaces and how shadowing of type variable names would work with that)
12:45:11 * hackage th-format 0.1.3.0 - Template Haskell based support for format strings  https://hackage.haskell.org/package/th-format-0.1.3.0 (mtesseract)
12:46:36 <glguy> boxscape: with TypeOperators, Operator symbols become type constructors rather than type variables.
12:46:40 <glguy> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=typeoperators#extension-TypeOperators
12:47:09 <boxscape> Ah, I see
12:47:10 <glguy> so you can't write: forall (+).  any more than you can write: forall A.
12:47:16 <boxscape> that makes sense
12:50:36 <jle`> forall (+) doesn't feel like it should inherently be impossible
12:50:43 <jle`> since (+) is a valid name for a variable
12:50:50 <jle`> just not a type variable
12:50:59 <jle`> in all other cases, valid names for variables are valid names for type variables
12:51:17 <jle`> oh that's what you just said
12:54:07 <phadej> but on term level : is "uppercase" and all other operator symbols are lowercase
12:55:00 <phadej> and still, "by convention" plenty type-level data types begin with :, :+: :*: :.: :-> .. 
12:55:11 * hackage df1 0.3.2 - Type, render and parse the df1 hierarchical structured log format  https://hackage.haskell.org/package/df1-0.3.2 (RenzoCarbonara)
12:56:12 * hackage di-core 1.0.4, di-df1 1.1, di 1.2.1 (RenzoCarbonara): https://qbin.io/ad-dam-moox
13:09:34 <jle`> phadej: isn't that the case for both term and type level?
13:09:56 <jle`> excepting this situation where where type variables are not valid variable names
13:11:32 <glguy> jle`: (+) and (:+) are constructors at the type level, but at the value level (+) is a variable and (:+) is a constructor (I'm not sure I understand your question though)
13:12:34 <tomjaguarpaw> Can I actually install an executable specified in the .cabal file of a package with cabal v2-install, or is that not supported?
13:13:03 <glguy> Yes, v2-install (which is now the default install) can install executables
13:13:42 <tomjaguarpaw> What's the right incantation?  It claims there is no executable specified when there certainly is (I'm trying to install ghcide from source)
13:14:12 <tomjaguarpaw> and tangentially, is there a reason that cabal doesn't tell you how many dependent packages it is through compiling?
13:14:53 <sclv> tomjaguarpaw: by specifying an executable it means you have to explicitly give a target
13:15:10 <sclv> as in: cabal-install exe:foo
13:15:25 <tomjaguarpaw> What is cabal-install?
13:15:32 <sclv> erm i mean, cabal install
13:15:35 <sclv> typo
13:15:38 <dsal> Is : the only capital operator?
13:15:39 <sclv> thinko
13:15:43 <sm> if there's an executable "foo", is "cabal install foo" not enough ?
13:16:08 <glguy> tomjaguarpaw: Is your cabal executable up to date? cabal --version; cabal-install version 3.0.0.0
13:17:36 <sclv> no reason it doesn't tell you how far it is through the install plan btw
13:17:36 <tomjaguarpaw> I alternate between 2.4 and 3.0.  Does anyone know why they use a different index cache format?  Should I just get rid of 2.4?
13:17:38 <sclv> just UI
13:17:51 <sclv> I'd just start using 3.0 for everything
13:18:11 <tomjaguarpaw> OK, I will add it to my list of things I will work on in cabal if I ever get round to it
13:18:34 <sclv> the index cache format is just internal structures auto-serialized afaik
13:18:41 <sclv> so between versions it can change
13:18:49 <sclv> its easier engineering than keeping it the same
13:18:57 <tomjaguarpaw> Right, this recipe does work despite seeming to not work earlier.  Perhaps it was beacuse I hadn't updated.
13:19:03 <tomjaguarpaw> Thanks sclv glguy 
13:20:39 <tomjaguarpaw> Oh wow, ghcide requires lens.  No wonder it just installed the whole world.
13:21:07 <glguy> The bulk of ghcide's dependencies aren't due to lens
13:21:33 <jle`> glguy, phadej: ah, i just realized that type constructors can start with non-:
13:21:41 <jle`> i didn't realize that was possible, outside of type families
13:21:45 <tomjaguarpaw> Interesting.  What are they due to?  The list of first-level dependencies is really small.
13:22:50 <tomjaguarpaw> Oh, it's the /library/ that depends on aeson and shake.  That'll pull in a lot.
13:22:56 <glguy> https://paste.fedoraproject.org/paste/CQ3Fuknr~A-DVdBNVqNF4Q
13:23:11 <glguy> I already had lens install and still had all that to pull in; lens dependencies are mostly tiny stuff
13:24:12 <tomjaguarpaw> Well, with nix-style cabal builds I don't mind building the whole world anymore :D
13:24:13 <glguy> I went through a couple years ago and pulled out all the big dependencies of lens (like aeson) into separate packages
13:24:29 <sm> are all the default commands the v2 ones in cabal 3.0.0.0 ?
13:24:31 <tomjaguarpaw> Oh right, nice!  I didn't realise that had happened.
13:25:15 <tomjaguarpaw> (Do you mean there's now lens-aeson etc.?)
13:25:32 <glguy> http://hackage.haskell.org/package/lens-aeson
13:26:22 <dignissimus> For now, my school uses ghc 7, how can I define a function in ghci?
13:26:32 <glguy> with "let"
13:27:16 <ChaiTRex> dignissimus: In GHCi, enter the line: let f :: Int -> Int; f x = x + 1
13:27:31 <dignissimus> With `let minimum' [] = error ""` I get `<no location info>: not an expression: ‘let minimum' [] = error ""’`
13:27:38 <jle`> but do be careful that every time you 'end' a line, you are starting a new declaration
13:27:43 <dignissimus> ChaiTRex: Is the type annotation necessary?
13:29:02 <dignissimus> Ah hmm, this online ghci isn't exactly ghci 7
13:29:14 <ChaiTRex> dignissimus: Nope, it's optional
13:29:18 <dignissimus> The code you gave me might very well work on ghci 7
13:29:54 <sclv> which online ghci?
13:29:58 <sclv> the haskell.org / tryhaskell one?
13:30:09 <dignissimus> https://www.tryhaskell.org/
13:30:17 <sclv> yeah that's not a real ghci -- its a webdemo
13:31:04 <sm> dignissimus: the one at http://repl.it is real (though a bit flaky)
13:38:05 <srid> So Jimmy Wales launched a new social network; I invite you all to the Haskell group :-D https://wt.social/wt/haskell
13:39:12 <vaibhavsagar> that should be pretty recent (GHC 8.6.5)
13:39:56 <ChaiTRex> dignissimus:  Tryhaskell seems to be only an expression evaluator rather than full GHCi. You'll need let f = ... in f 5 or whatever
13:40:10 <ChaiTRex> dignissimus: The definition of the function and the use of it on one line.
13:54:56 <EvanR> srid: my list of social networks is monotonically decreasing sorry
13:55:04 <mpickering> Why does `canonicalizePath` strip a trailing `/` from the path?
13:55:16 <mpickering> It means that `takeDirectory` does a different thing 
13:55:53 <koala_man> would you expect the canonical path to /tmp and /tmp/  to be different?
13:56:49 <ryan87> EvanR: +1
13:57:13 <ryan87> koala_man: no
13:57:34 <ryan87> koala_man: well, maybe
13:58:02 <ryan87> \/tmp might indicate a file and \/tmp\/ might indicate a dir
13:58:14 <ryan87> never at the same time though
13:59:17 <Lycurgus> a path is a path
13:59:33 <gwern> so I've been storing data for gwern.net stuff (like defining redirects or adding summaries to hyperlinks) as serialized Haskell lists using Read/Show. this was very easy to code and relatively easy to hand-edit. the main drawback is that when I make a syntax error and forget a comma or something, parsing crashes with a useless exception. is there any way to get the equivalent of read/show but...
13:59:39 <gwern> ...it'll at least tell me the line number it crashed at? I've googled and everything I find is either about catching the exception (which doesn't include line numbers or the failing entry) or about handrolling arbitrarily complex Parsec et al parsers
13:59:54 <Lycurgus> what the object it designates is force to be a single thing at a time in this case
14:00:12 <Lycurgus> *forced, i.e. that's its natural semantics
14:00:27 <Lycurgus> (in most FSes)
14:02:49 <dignissimus> 2 questions, is it important that my school updates from ghc 7? And if I have a project with some dependencies, my school firstly runs windows and secondly doesn't have stack or cabal installed, what would be the best way of working on these projects at school?
14:03:43 <tom_> I am using servant and the wai-cors package but am still getting "No 'Access-Control-Allow-Origin' header is present on the requested resource." in the browser on a request
14:03:46 <tom_> any ideas?
14:03:47 <lavalike> gwern: at a very basic level there's ReadS https://www.vex.net/~trebla/haskell/reads.xhtml
14:04:52 <gwern> hm. I did see reads but it wasn't clear to me that it'd help from the haddock
14:07:51 <amalloy> gwern: it'll return a value describing how it failed, so that you can do whatever you want with that (at the very least, produce your own error with call-site context)
14:08:06 <amalloy> well, i guess mostly the description will be "it failed"
14:10:42 <gwern> I'm not sure it'd be useful. consider this: 'reads "[(1,2), (3,4)]" :: [([(Int, Int)], String)]'. yields '[([(1,2),(3,4)],"")]'. fine. now commit the error I often make, of dropping a trailing comma, like 'reads "[(1,2) (3,4)]" :: [([(Int, Int)], String)]'. that just yields '[]'. it doesn't tell me 'error starting with the string "(3,.."' or anything. it doesn't throw an exception, but it...
14:10:48 <gwern> ...doesn't help me either
14:11:48 <gwern> (one thought I had was to just convert the data files into a single list per line and then map over it and print out offending lines after catching the exception, but I figured someone had written a more useful 'read' somewhere)
14:16:32 <NemesisD> is there a technique for traversing a product type generically without having to create typeclasses for every little operation? i.ve got something where all the values have a similar shape `data A = A { b :: Foo B, c :: Foo C}` and i want to fold `forall a. Foo a -> X` over it
14:17:10 <sclv> dignissimus: i think it might be nice if they updated from 7 at some point
14:17:13 <sclv> its only getting more out of date
14:17:41 <sclv> dignissimus: i would think you can also install your own cabal binary on your school computer if you like
14:17:49 <sclv> its very small
14:19:52 <EvanR> NemesisD: yes vinyl has this feature
14:20:07 <EvanR> it calls Foo a 'universe'
14:23:45 <EvanR> rfoldMap :: forall f m rs. Monoid m => (forall x. f x -> m) -> Rec f rs -> m
14:25:23 <NemesisD> EvanR: hmm i see a reference to universe in the tutorial where you make a separate sum type for all the fields of your product
14:26:19 <EvanR> ok that's something else then
14:26:36 <EvanR> the Foo functor represents the common things among all fields
14:26:45 <NemesisD> yeah
14:27:36 <Uniaika> EvanR: (this almost reads like chinese philosophy)
14:28:19 <EvanR> vinyl definitely contains some enlightenment to be had
14:28:20 <NemesisD> maybe i could just have one generic-oriented typeclass that takes `forall a. f a -> b` and then i can write instances for :*:, K1, etc
14:28:43 <EvanR> generics is another way to accomplish ... well... generic programming
14:29:03 <EvanR> vinyl requires you use their data structures
14:29:05 <NemesisD> its just getting to the point of generality where i have some sense there's something already in my dependency set that does this
14:31:58 <jle`> NemesisD: you can also use plated stuff and get specific Foo B -> ..., Foo C -> ... functions
14:32:09 <jle`> like uniplate and plated
14:32:22 <jle`> basically plated gives you a traversal over every value of type X inside your type
14:32:44 <jle`> but it wouldn't give you a unified Foo a -> ...
14:33:24 <NemesisD> jle`: so it sort of gives you a function with an arity equal to the number of fields in your record?
14:33:58 <jle`> NemesisD: basically if you have type MyType that contains Int fields (or sub-fields that contain Int fields), then you get overInts :: (Int -> f Int) -> MyType -> f MyType
14:34:06 <jle`> which you can use to fold/map/traverse/etc.
14:34:21 <jle`> so you could do the same thing but replace Int with Foo A, Foo B
14:34:35 <jle`> it "finds" all of the sub-Ints, essentially
14:35:13 <jle`> but it can only do this if the type it is trying to select for is monomorphic i believe.
14:35:16 <NemesisD> hmm, but it doesn't get you out of the structure of the record? i'm wanting to fold over all the Foos in my record
14:35:24 <NemesisD> ah
14:35:26 <jle`> you can get out of the structure with f ~ Const
14:35:33 <jle`> so getAllInts :: MyType -> [Int]
14:35:39 <jle`> getAllFooA :: MyType -> [Foo A]
14:36:11 <NemesisD> Foo in this case has a type variable but i don't need it for the function i'm folding over
14:36:43 <jle`> in this case basically you can't fold over "all sub-Foos", but you can fold over "all sub-Foo A's" and "all sub-Foo B's"
14:37:05 <jle`> you wouldn't be able to respect the relative order of when they occur since you take a whole pass for one, then another pass for another
14:41:19 <koz_> Does anyone have a link to an explanation of System F (preferably with extensions a-la the lambda cube) which isn't named 'Barendregt's thesis'?
14:44:12 * sm installs ghcide+hie-bios+haskell-lsp+lsp-haskell+lsp-mode+lsp-ui oh my
14:46:58 <sm> every time I move point, the Hover request takes a second. So as I move it falls behind and takes a long time to catch up. Normal ?
14:47:25 <sm> needs to discard obsolete events I think
14:55:17 <EvanR> yeesh
14:57:51 <EvanR> nothing worse than an unresponsive GUI
15:01:39 <mpickering> sm: How big is your project?
15:01:53 <sm> at least, I think that's what's happening. I see dante is still interfering, let me try exorcising that
15:02:28 <sm> mpickering: not too big.. 150 modules in 4 packages
15:02:42 * hackage core-text 0.2.2.4 - A rope type based on a finger tree over UTF-8 fragments  https://hackage.haskell.org/package/core-text-0.2.2.4 (AndrewCowie)
15:02:46 <mpickering> there is an issue I made about how slow hover was
15:02:59 <sm> thanks, looking. Incidentally hie-bios worked perfectly, great work!
15:03:29 <mpickering> it turned out the issue was that on every request ghcide would consult the status of thousands of files because ghc has a lot of include dirs
15:03:39 <mpickering> probably not your issue though
15:03:41 * hackage core-program 0.2.2.4, core-data 0.2.1.4 (AndrewCowie): https://qbin.io/duty-order-mhgw
15:04:13 <mpickering> glad to hear it
15:04:32 <mpickering> the current state of master is really different to the 0.2 release, hopefully an improvement again
15:05:08 <sm> noted (I got the latest from hackage)
15:05:24 <mpickering> It should tell you how long the hover request takes anyway in the logged output, my experience is that it's slower than h-i-e because of this file polling it does
15:05:47 <mpickering> but it's "more correct" 
15:09:29 <sm> mpickering: I restarted emacs for a clean config. It gives feedback very quickly for first edits, but if I hold down C-n for a bit and then try another edit, I see it working through the backlog of "hover" events, each one taking >2s
15:10:18 <mpickering> What does C-n do?
15:10:28 <sm> cursor down
15:10:33 <mpickering> It sounds like your client isn't sending cancellation notifications
15:11:01 <sm> well I see a lot of "Starting shakeRun (aborting the previous one took 0.00s)"
15:11:07 <mpickering> ah right
15:11:10 <mpickering> so it is cancelling?
15:11:12 <sm> I'm using emacs lsp-mode
15:12:06 <lavalike> gwern: I tried to play around but no, there seem to be no way to get that info out of ReadS/ReadP/ReadPrec, hope is crushed
15:12:13 <sm> I guess so, but it's still working through all the hover events and taking 2s for each. But, I do now see it will notice a new edit and I get the visual feedback. But it has missed the first edit, that one never shows visual feedback until I re-do it
15:13:09 <sm> or, maybe some of the edits I'm making aren't recognised as errors. Guess I need to learn more
15:13:35 <mpickering> my experience is that feedback is very fast when typing even on GHC
15:13:38 <mpickering> which is over 500 modules
15:16:37 <sm> I guess I'll leave the log hidden and test. Some of my edits seem to give feedback immediately and others not. I suspect there are multiple different kinds of checkers responsible too
15:16:53 <sm> ghc, hlint, ... ?
15:18:09 <sm> mpickering: do you remember where that hover request issue is ?
15:19:13 <mpickering> https://github.com/digital-asset/ghcide/issues/101
15:19:25 <sm> I'm getting occasional errors which may not be in your area: "Suspicious state from syntax checker haskell-stack-ghc: Flycheck checker haskell-stack-ghc returned non-zero exit code 1, but its output contained no errors" https://termbin.com/mpww
15:19:43 <sm> thx
15:20:59 <mpickering> yeah that's nothing to do with ghcide
15:21:03 <mpickering> that's flycheck?
15:21:52 <sm> ok. It's a bit of a stretch juggling 6 new packages at once :)
15:29:13 <sm> interesting.. emacs is writing MODULE_flymake.hs files in my source tree, some of which were failing to build
15:31:32 <sm> it's cool that syntax checking works even in a clean unbuilt project
15:37:03 * srid wonders who the target audience of the Haskell wikibook is. https://en.wikibooks.org/wiki/Talk:Haskell#Target_audience
16:02:21 <absence> @let import Data.Functor.Compose
16:02:22 <lambdabot>  Defined.
16:02:28 <absence> :t Compose (Left undefined) <|> Compose (Right $ Just undefined)
16:02:29 <lambdabot> Control.Monad.Trans.Error.Error a1 => Compose (Either a1) Maybe a2
16:02:39 <absence> where does the Error instance come from?
16:02:54 <absence> constraint, i mean
16:06:39 <nshepperd2> <|> is from the Alternative typeclass
16:06:53 <nshepperd2> so probably the Alternative instance for Either
16:08:47 <absence> nshepperd2: Either doesn't have an Alternative instance
16:13:55 <nshepperd2> my ghci says instance Control.Monad.Trans.Error.Error e => Alternative (Either e)
16:14:25 <absence> nshepperd2: isn't that a bit funny though? that type isn't in base
16:15:21 <nshepperd2> oh, this is the evil orphan instance which lives in 'transformers' package
16:16:18 <nshepperd2> https://gitlab.haskell.org/ghc/ghc/issues/9588
16:20:31 <absence> nshepperd2: hm, i guess it's in lambdabot's scope by default
16:24:49 <sim590> I'm trying to make a String instance of something and I think that I have discovered that String can't be instance of anything. Neither can list of any stuf... We're then forced to use newtype. Is that right?
16:25:40 <sim590> Is there some standard newtype binding String to a name that I could use?
16:26:10 <sim590> I don't like recreating some newtype in every module where I need to make String an instance of some class.
16:27:32 <absence> which class?
16:28:21 <sim590> Some class that I created.
16:28:32 <sim590> Its name is Hashable.
16:29:09 <sim590> So you understand that this class has the signature `hash :: a -> ByteString` in it.
16:33:01 <absence> sim590: i guess you need an instance for lists in general, not specific lists (like String)
16:34:44 <absence> and an instance for Char so the list instance can defer to it
16:34:59 <amalloy> right, instance Hashable a => Hashable [a]
16:40:42 <[Leary]> You can also just turn on FlexibleInstances.
16:44:11 <amalloy> yeah but...should you? i feel like the [a] instance is more useful anyway
16:45:16 <sim590> [Leary]: OK. I did that. Simpler ;)
16:45:26 <[Leary]> amalloy: You're right, but I thought sim590 ought to know.
16:48:28 <koala_man> I have a project that generates a man page from a markdown file in a `preSDist` hook. That way, the man page will be part of `cabal sdist` but won't normally be built. Cabal 3.0.0.0 does not have this hook. What else can I use?
16:57:45 <haskell_n00b> can you guys give some advice on how to translate do-notation to bind?
16:59:50 <sm> do\n  a <- readFile "A"\n  putStrLn a  -> readFile "A" >>= putStrLn
17:01:33 <haskell_n00b> acutally, got it
17:01:36 <haskell_n00b> thanks
17:02:11 * hackage Map 0.1.3.1 - Class of key-value maps  https://hackage.haskell.org/package/Map-0.1.3.1 (MatthewFarkasDyck)
17:10:29 <gwern> lavalike: darn.
17:20:14 <dsal> @undo do { x <- f; print x} 
17:20:15 <lambdabot> f >>= \ x -> print x
17:20:29 <dsal> haskell_n00b: ^
17:20:59 <dsal> Though I wouldn't write it that way...
17:26:11 <ChaiTRex> @. pl undo { x <- f; print x }
17:26:11 <lambdabot> (line 1, column 1):
17:26:11 <lambdabot> unexpected "<"
17:26:11 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
17:26:29 <ChaiTRex> @. pl undo do { x <- f; print x }
17:26:29 <lambdabot> print =<< f
17:29:22 <dsal> heh.  I wish to not know how to do that.
18:03:11 * hackage exist 0.1.0.0 - Dependent sum type  https://hackage.haskell.org/package/exist-0.1.0.0 (MatthewFarkasDyck)
18:13:12 * hackage exist 0.1.1.0 - Dependent sum type  https://hackage.haskell.org/package/exist-0.1.1.0 (MatthewFarkasDyck)
18:28:30 <gwern> lavalike: yeah, I'm still seeing nothing at all in any googling indicating anyone has created a 'read' which will report any kind of error information. I guess I'll look into a non-haskell data format like yaml or dhall
18:33:00 <dsal> I know I'm getting deep into bytestring when I find functions that are misspelled, presumably on purpose so they can break people's code who dare to get this low.
18:34:05 <dsal> gwern: read isn't great for non-trivial things.  I just used dhall in a haskell project and it was pretty great.  It maps to my haskell code pretty well, including a custom data type I had to write a custom parser for.
18:34:59 <gwern> dsal: this is trivial! I'm parsing a [("String", ("String", "String", "String", "String"))]. it's just that there's a *lot* of it and it's hard to figure out where the error is, but all I need is a line number
18:35:39 <dsal> Well, sure, but I mean trivial applications.  If you want to know what's wrong, use megaparsec or dhall or something.  :)
18:36:27 <gwern> I never thought 'line number' would be considered an advanced application ;_;
18:36:39 <dsal> read doesn't have a concept of a line, much less a line number.
18:37:19 <amalloy> read really is for like "hey, i promise you the value i need to parse was produced by `show`"
18:37:33 <amalloy> if that isn't true, you don't get much
18:37:37 <dsal> "unless it was from something poorly defined like Data.Time.*"
18:38:08 <dsal> read is fine for hacking and debugging.
18:38:36 <amalloy> i don't know anything about haskell's time libraries, but it seems appropriate that they are poorly defined, just like civil time
18:39:23 <dsal> % print =<< getCurrentTime
18:39:23 <yahb> dsal: ; <interactive>:66:11: error:; * Variable not in scope: getCurrentTime :: IO (); * Perhaps you meant `getCurrentCCS#' (imported from GHC.Exts)
18:39:41 <dsal> ...anyway, it's got a "friendly" show:  2019-11-16 02:38:54.848068 UTC
18:39:55 <goolord> gwern: megaparsec is pretty nice and easy to use, if you are at a point where you want good error messages while parsing something you will find something like `megaparsec` much more amenable than `read`
18:40:53 <dsal> It doesn't take long to get to the point where megaparsec takes similar time to like, building a regex to hack up a parser, but it's composable and can do lots of fancy things.
18:41:23 <gwern> goolord: I'll probably just go with yaml, though. I really don't need the power of a full parsing library, and I've gotten away this long without learning parsing
18:42:27 <goolord> if that's suitable for what you're parsing, than by all means!
18:43:24 <dsal> gwern: I'd take dhall before yaml if you're trying  something new.  It's typesafe and easy to use.
18:43:43 <goolord> dhall is pretty sweet
18:43:56 <gwern> dsal: dhall looks cool but I can't see what I would use it for with this data
18:43:58 <dsal> And you can write functions in your config files.  (Which I started to write as a joke, but I actually really needed)
18:44:47 <gwern> the data in question is https://www.gwern.net/static/metadata/custom.hs to be more specific - these entries define the annotations/summary for a link when you mouse-over it on gwern.net
18:44:57 <dsal> I don't know what your data looks like.  dhall wasn't a good fit for most of my config things that I'd written custom parsers for, but the one place I  used it w as huge.
18:45:12 <gwern> it really is just a string (the URL in question) and then some basic metadata - the title, authors, date, doi if any, and an excerpt/summary
18:45:35 <dsal> Yeah, I'd go megaparsec right away.
18:45:35 <gwern> I can't see what I could possibly use most of the dhall features for, as useful as they would be in configuring something like a irc client or editor etc
18:46:16 <gwern> so my thinking is I can just write it as yaml; 'url: foo \n [indent] title: X \ author: X \ etc'
18:46:19 <dsal> I used dhall to configure a data importer sort of thing.  I give it influxdbs and queries and MQTT destinations so I can get my influxdb data as snapshots.
18:46:29 <gwern> in dhall I would need... a giant record, I guess?
18:47:19 <dsal> List RecordType   I'd guess.
18:48:09 <dsal> But you're going to want to do something  with this data after you import it.  yaml will only get you so far.  With megaparsec, you can coerce things to the  right type as they're coming in.  You can do that with dhall to a degree as well, but it's a bit less obvious how that works.  (I needed to do that, so I figured it out)
18:48:43 <goolord> aside from dhall's type system, the benefits of dhall aren't really compelling until you need to configure a lot of stuff, i guess
18:49:06 <dsal> This is me changing a thing from doing custom config file format for outfluxer -> dhall:  https://github.com/dustin/outfluxer/commit/abd4a6892b12e5c62c62fae1759aa7d2f2fb63b2?diff=split
18:49:40 <dsal> *shrug* anyplace  I'd think yaml might be considered, I'd expect dhall  to be better.  I've never liked yaml, though, so I'm possibly a little biased.
18:50:03 <gwern> dsal: well yes, I read in in as a list and then convert it to a Map, but that's largely irrelevant to the on-disk serialization format
18:50:17 <gwern> * assoc list
18:51:00 <goolord> trying to convince non-haskeller co-workers to adopt dhall has been difficult
18:51:28 <dsal> list of [(String, (String, String, String, String))] is a bit hard to work with.
18:51:35 <goolord> the examples are not compelling, because your average network engineer will see the dhall example next to the yaml example and think the dhall seems more complicated
18:52:10 <dsal> Yeah, a friend made a similar argument.  Let me find the thing he said...
18:52:11 * hackage twitter-types 0.10.0 - Twitter JSON parser and types  https://hackage.haskell.org/package/twitter-types-0.10.0 (TakahiroHimura)
18:52:25 <dsal> "I bet the people who need it most are the ones who make mistakes.   and they're the ones who won't like it because it seems "hard""
18:53:11 * hackage twitter-types-lens 0.10.0 - Twitter JSON types (lens powered)  https://hackage.haskell.org/package/twitter-types-lens-0.10.0 (TakahiroHimura)
18:53:16 <dsal> This is my before:  https://gist.github.com/dustin/3c30d5f2fc2dbf7d4c54acff4ec070c1
18:53:28 <dsal> Some of  those queries had bugs and lacked a bit of uniformity.
18:53:41 <dsal> This is my after:  https://gist.github.com/dustin/983e1f92b6ded976f4a84d31af3f826a
18:54:02 <goolord> nie
18:54:05 <goolord> nice*
18:54:19 <dsal> I could tuck away some of the types and junk, but the file is still a good deal shorter and I've had two fix two different query bugs in there on one line each, where each bug affected like, 11 queries.
18:55:15 <dsal> Still has more repetition than I'd like, but, eh, one night.
19:06:22 <haskell99> can someone explain how does list work as a monad
19:06:57 <koz_> haskell99: Basically, a function that returns a list can be thought of as having 'many answers'.
19:07:12 <koz_> So a list represents 'any of these could be the real answer, but I dunno which'.
19:07:28 <koz_> So thus, return for [] is 'this thing here is the right answer'.
19:07:58 <koz_> Bind says 'if I have a thing that could have many answers, and a list of possible inputs, I'll try them all, collect all the answers, and have one super-answer with all those in it'.
19:08:09 <koz_> s/right/only/
19:08:12 <haskell99> huh
19:08:50 <koz_> haskell99: What's confusing you?
19:08:59 <haskell99> do a <- [1,1,1]  <- [2,2,2]
19:09:03 <haskell99> oops
19:09:11 <haskell99> do a <- [1,1,1]  <- [2,2,2]
19:09:32 <haskell99> if assign two values lists with `<-`
19:09:41 <koz_> haskell99: One, that's not valid do notation.
19:09:54 <koz_> Two, do-notation is not helpful if you don't understand the underlying stuff in terms of return, >>= and >>.
19:10:10 <koz_> Have you read the Typeclassopedia by chance?
19:10:37 <ChaiTRex> > do { a <- [1, 1, 1]; b <- [2, 2, 2]; return (a, b) }
19:10:39 <lambdabot>  [(1,2),(1,2),(1,2),(1,2),(1,2),(1,2),(1,2),(1,2),(1,2)]
19:10:50 <haskell99> Nope, I read this https://wiki.haskell.org/All_About_Monads#List_is_also_a_monad
19:11:04 <haskell99> okay, so how would you express it without do-notation?
19:11:36 <koz_> haskell99: The answer is 'Read the Typeclassopedia. Then read it again. Then one more time for luck. Then, if you're still unsure, ask, with that in mind.'.
19:12:15 <haskell99> pure [1,1,1] >>= a ; pure [2,2,2] >>= b ; return a*b
19:12:22 <dsal> koz_: That's a really nice explanation.
19:12:22 <koz_> That has a very good explanation of all monad-related things, as well as the necessary scaffolding.
19:12:25 <haskell99> would that work?
19:12:31 <koz_> dsal: Am unsure if sarcasm.
19:13:06 <dsal> koz_: nah, it's  good.  Someone asked me the same question recently and I'm sure she was not very pleased with whatever I said in response.
19:13:20 <koz_> dsal: In that case, thanks, and sorry for doubting your sincerity.
19:13:29 <koz_> (I'm on the spectrum, and in text-only media, intent carries poorly)
19:13:46 <koz_> (therefore, I tend to be very unsure in general if someone's being sincere or not, unless it's _incredibly_ telegraphed)
19:13:49 <dsal> Ah.  Yeah.  I'm generally sarcastic and probably confusing.
19:14:07 <dsal> But I didn't know how to think about or explain list monad.
19:14:21 <koz_> dsal: The 'many possible answers' is how I always understood it.
19:14:23 <dsal> There are a few things in haskell I have an easy time using, but don't really fundamentally understand.
19:14:39 <koz_> It's kinda like, you're fundamentally not sure which is 'the right one', so you gotta cart them all around just in case.
19:14:44 <dsal> I've pretty much only used it for logic puzzles and stuff.
19:14:57 <koz_> Nondeterminism is very useful for such cases, yes. :D
19:18:39 <haskell99> Thanks, Typeclassopedia seems useful
19:18:53 <koz_> haskell99: Typeclassopedia is very valuable.
19:19:01 <koz_> Definitely recommended reading for all aspiring Haskellers.
19:19:33 <haskell99> Do u guys use Haskell professionally as well, or is it just as a hobby?
19:20:24 <koz_> haskell99: I use it at work and as a hobby.
19:20:33 <koz_> But the work part is new.
19:20:52 <dsal> I've been doing a lot of work at work with Haskell.  I'll probably pay for that later.  heh
19:21:05 <dsal> My go-to language for hobby stuff is haskell.  I've got a lot of hobbies.
19:21:28 <goolord> I'm also a professional/hobbyist haskeller!
19:21:56 <koz_> dsal: I suspect I won't pay for that - in fact, I'll probably be able to work miracles.
19:22:15 <koz_> (relative what I'm replacing, 'isn't a horrific mess that makes people wanna kill themselves' would be considered miraculous)
19:22:47 <haskell99> what are the advantages to using this to anything else? 
19:23:14 <koz_> haskell99: Haskell is very good at describing things in its type system.
19:23:15 <dsal> I told my manager I have to do this thing  I'm working on in haskell because I can't think of how to solve this problem with  our normal tools)
19:23:20 <goolord> the type system
19:23:26 <koz_> Which basically means 'you can easily make invalid states unrepresentable'.
19:23:29 <koz_> Aww, they left.
19:23:45 <koz_> dsal: I didn't tell the folks in charge anything. I was given carte blanche, 'as long as it works'.
19:23:49 <koz_> Well, if you want working... :P
19:24:17 <dsal> Yeah, this isn't production critical, and can theoretically easily be replaced as soon as I figure out the actual solution to all the things.
19:24:36 <goolord> idk, for small teams it's a real peace of mind knowing how much heavy lifting the compiler is doing
19:24:40 <koz_> I'm in the same boat, and the problem is actually challenging enough that attacking it in anything else seems painful and unnecessary.
19:24:50 <koz_> goolord: For large teams, I am sure the same goes too.
19:25:07 <goolord> i suppose so
19:25:10 <dsal> The refactoring has been insane.  I've been fundamentally wrong so many times on this project and dreaded fixing all the things.  But then it was just  fine.
19:25:10 <koz_> The less human error you can accidentally introduce, the better, and if you magnify the number of humans, you magnify the number of chances for human error.
19:26:20 <goolord> i mean to say that i don't think my team would have shipped anything if we weren't writing haskell
20:02:02 <dsal> I sit down to write a little haskell so I can think about my problem at a high level and now I'm having to learn about peek and poke.  This day is weird.
20:03:22 <koz_> dsal: You working with Storables somehow?
20:03:32 <dsal> Yeah, somehow.  heh
20:03:42 <dsal> I'm trying to make proto encoding a bit faster.
20:03:49 <slack1256> A real BASIC-programmer can write peek/poke on any language </curse>
20:03:50 <koz_> Well, if it's of any consolation, I'm having to figure out how to do filesystem watches
20:03:57 <koz_> (for work)
20:04:34 <dsal> Data.ByteString has a lot of tricks to speed things up that I need, but are not very fun to play with.
20:04:48 <koz_> Lol, I imagine not.
20:05:01 <koz_> But at least for now, I don't have to worry about it. Instead, I get to worry about other fun things.
20:05:08 <dsal> Speaking of LOL:  boudedPrim :: Int -> (a -> Ptr Word8 -> IO (Ptr Word8)) -> BoundedPrim a
20:05:21 <koz_> dsal: Wat.
20:05:45 <dsal> This one integer encoding was about 25% of the runtime of my program.  My program is fast enough, but this is a  super common thing, so if I can figure out to make it faster, it'll benefit a lot of people.
20:06:08 <dsal> Man, my program won't even compile anymore.  Maybe, I can't tell.  I guess I'll watch a movie and see if it ever finishes.
20:06:16 <koz_> dsal: Woah.
20:07:01 <monochrom> A real haskell programmer can make BASIC a haskell EDSL: http://hackage.haskell.org/package/BASIC
20:07:04 <dsal> I didn't change that much, but it's just kinda hanigng.
20:07:09 <koz_> monochrom: Lol.
20:07:18 <dsal> heh, neat
20:12:06 <slack1256> monochrom: Hey, the whole point to BASIC is to do unsafe things. Making it a EDSL removes that >.> .
20:12:36 <dmj`> luigy: ping
20:12:43 <dmj`> luigy: wya now 
20:26:12 * hackage miso 1.4.0.0 - A tasty Haskell front-end framework  https://hackage.haskell.org/package/miso-1.4.0.0 (DavidJohnson)
20:31:44 <dmj`> that looks like a really cool package
20:59:53 <jle`> looks very tasty
21:06:18 * dmj` slurps loudly
21:22:15 <siwica> Is there some elegant way to write a function "f :: (Int -> Int -> Int) -> [Maybe Int] -> Maybe Int" with f (+) [Just 1, Just 2, Nothing] = 3 and f [Nothing, Nothing] = Nothing?
21:22:46 <siwica> f (+) [Nothing, Nothing] = Nothing that is
21:23:01 <jle`> siwica: hm, do you mean Just 3 before?
21:23:09 <siwica> Ah, yes
21:23:15 <siwica> Sorry, I seem to be tired
21:23:48 <jle`> hm, you can catMaybes, then convert to nonEmpty and foldl1 the nonEmpty maybe
21:24:08 <jle`> that would probably be the most readable way, although there might be some clever ways to skip things
21:24:56 <siwica> Ok, didn't know about catMaybe, that's a first step
21:25:00 <jle`> :t \f -> fmap (foldl1 f) . NE.nonEmpty . catMaybes
21:25:01 <lambdabot> (b -> b -> b) -> [Maybe b] -> Maybe b
21:25:31 <jle`> or foldr1
21:25:44 <jle`> foldl1 and foldr1 for NonEmpty are both total, unlike the situation for lists
21:26:02 <siwica> Ok, thanks! :)
21:28:09 <wejetheman> how do i see the definition of a built in function? particularly I want to see about making a modified version of span
21:28:21 <jle`> wejetheman: check out the docs
21:28:30 <jle`> namely the docs for base
21:28:33 <jle`> @hackage base
21:28:33 <lambdabot> http://hackage.haskell.org/package/base
21:29:29 <jle`> wejetheman: you can't see the definitions of any "true" built-in functions, but functions like span are defined within the language and are just normal functions you import
21:30:00 <wejetheman> ah right im sure the lowest level stuff is just assembly
21:30:15 <wejetheman> but im trying to find the definition of span with no success
21:31:13 <jle`> wejetheman: check out the links [index] and [Quick Jump]
21:31:13 <electricityZZZZ> there's a paper on the arxiv which says pretty much never use lists in haskell
21:31:30 <electricityZZZZ> unless you are making a lifo/fifo or a few other very constrained cases
21:31:31 <jle`> wejetheman: [Quick Jump] and typing in span tkaes me to it :)
21:31:48 <jle`> wejetheman: once you find it, you can clikc the little link that says 'source'
21:32:12 <jle`> electricityZZZZ: it is true that lists are really only good for queues and streaming, but in haskell that happens a lot
21:32:27 <wejetheman> source!
21:32:31 <jle`> electricityZZZZ: so that's like saying "never use lists in haskell, except for these situations that happen all the time on an everyday basis"
21:32:33 <wejetheman> that was there the whole time lol
21:32:52 <jle`> electricityZZZZ: the real gotcha is that a lot of people from other languages use lists like arrays, to store data
21:32:59 <jle`> electricityZZZZ: that's definitely a no-no
21:34:03 <jle`> electricityZZZZ: but, in haskell, lists show up all the time because we use streaming generators all the time, it is the basis of almost all haskell control flow
21:37:46 <electricityZZZZ> i also found this (imo) well-done language comparison paper https://arxiv.org/pdf/1909.06344.pdf
21:38:06 <electricityZZZZ> or at least, well-done in comparison to the other language comparison papers i have found, which have never been very good at all
21:44:10 <electricityZZZZ> and this was the no-list paper https://arxiv.org/pdf/1808.08329.pdf
21:46:34 <siwica> Why does Scala gain popularity whereas Haskell seems to be declining a bit (according to Google Trends that is)
21:46:38 <siwica> ?
21:47:07 <jle`> my best guess is probably it integrates with the whole java and jvm ecosystem 
21:47:41 <electricityZZZZ> why does language popularity matter
21:48:06 <siwica> It matters because of the job market, the ecosystem, ...
21:48:28 <jle`> yeah, a critical mass is useful for getting the libraries in the ecosystem that can improve day to day QoL
21:48:39 <siwica> less people writing haskell => less libraries 
21:50:00 <siwica> I haven't written very much Haskell in the last 2 years and just checked Google trends
21:50:21 <electricityZZZZ> then make a company and do something haskell us good at with it :)
21:52:34 <siwica> I was a bit sad that it not just didn't seem to grow in popularity but even declined a bit
21:53:07 <siwica> But maybe people have just gotten Haskell experts in the meantim and don't need to google as much any more ;)
21:53:10 <electricityZZZZ> i think you are seeing the impact of rust
21:53:27 <electricityZZZZ> early adopters are spending there time there
21:53:27 <siwica> yeah probably...
21:53:46 <electricityZZZZ> their time i swear im not this bad at spelling
21:54:09 <siwica> Yeah, Rust is on an all time high in the TIOBE index
21:54:40 <electricityZZZZ> but i just discovered cogent lang, which is a linear typed total haskell with no GC or runtime
21:54:51 <siwica> "I swear" I suppose ;)
21:56:12 <electricityZZZZ> what are these mythical libraries which are so important anyway
21:59:13 <jle`> well the other day i needed to do some wavelet analysis
21:59:33 <jle`> and there are some mature libraries on python, R, matlab, etc.
21:59:43 <jle`> but nothing really on haskell so i had to take time to write one myself
22:03:34 <electricityZZZZ> scientific computing libraries tend to appear in languages which have strong control over memory and have relatively good systems performance
22:03:59 <dmj`> R?
22:04:04 <dmj`> get outta here
22:04:11 <dmj`> PLT only here
22:04:29 <jle`> electricityZZZZ: that is not false, but they also appear in languages with mature ecosystems in general
22:04:34 <dmj`> electricityZZZZ: we have an FFI, we can do things too
22:04:49 <dmj`> electricityZZZZ: arrayfire boy, that's the ticket
22:05:02 <jle`> at a critical mass even niche libraries and applications become expected to exist
22:07:27 <dmj`> C is a great systems langauge
22:07:36 <dmj`> Haskell can FFI in to C
22:07:43 <dmj`> Therefore, Haskell is a great systems language
22:07:46 <dmj`> q.e.d
22:19:14 <ryan87_> dmj`: ffi? ffschmi! just let the compiler handle it.
22:19:43 <dmj`> I never met a heap I trusted
22:21:34 <ryan87_> heapless haskell
22:29:11 <electricityZZZZ> matlabs libraries for the most part are no good
22:29:47 <electricityZZZZ> ive written more matlab than i care to admit,... and not many people who write in it know how to do things like pass by reference etc
22:32:29 <electricityZZZZ> haskell i think is still the starting point for learning to write correct software
22:33:15 <electricityZZZZ> dmj`: still waiting on replace ;-)
22:33:37 <dmj`> electricityZZZZ: I can get it for you, but it will be in IO ()
22:33:45 <dmj`> electricityZZZZ: if you can live w/ that
22:34:10 * electricityZZZZ is writing python in haskell and then complaining on irc when it isn't python and then doing what people say ;)
22:34:26 <electricityZZZZ> i have no idea what "in IO" means
22:34:56 <electricityZZZZ> i would say don't rush take your time i have some other stuff i need to get to anyway
22:36:19 <dmj`> electricityZZZZ: alright sounds good
22:37:08 <electricityZZZZ> i think also the entry level Haskell education materials have weird types like Int
22:38:09 <electricityZZZZ> unbounded integers should be explicitly defined like Int[infinity] or sometihng
22:38:19 <electricityZZZZ> and very selectively or never used
22:43:41 <cocreature> electricityZZZZ: Int isn’t unbounded, Integer is the one that is unbounded
22:47:11 <electricityZZZZ> ok my bad
22:47:51 <electricityZZZZ> but it is still very common to encounter in entry level materials
22:57:49 <cocreature> yeah
23:06:34 <electricityZZZZ> what is a combinator all of the definitions i have found arent good
23:18:28 <electricityZZZZ> jle`: you could write your wavelet analysis code in futhark :-P
23:28:57 <electricityZZZZ> siwica: https://trends.google.com/trends/explore?date=today%205-y&geo=US&q=%2Fm%2F03j_q,%2Fm%2F091hdj,%2Fm%2F0dsbpg6
23:29:26 <electricityZZZZ> siwica: scala if anything is down a little bit and haskell is pretty much steady, maybe slightly down
23:31:47 <goolord> something about that histogram seems funky to me
23:32:18 <goolord> am I to belive that there are more people interested in *scala* than haskell and rust *combined*?
23:33:22 <electricityZZZZ> i think it is relative popularity of searches,... that probably doesnt represent individual people
23:33:46 <electricityZZZZ> it could be that there are more people working using scala so there are more hours in the day where people search for scala than for haskell or rust
23:38:11 <goolord> electricityZZZZ: I don't think 'combinator' has ever been formally defined
23:39:52 <goolord> https://wiki.haskell.org/Combinator_pattern is good enough for me /shrug
23:43:29 <jhaugh> Hey all I had a quick question about using polysemy if anyone has time to take a look at this code I would really appreciate it! https://gist.github.com/JHaugh4/140f07cf4e7ff5c408dc716d787611d6 Let me know if you need me to clarify anything!
