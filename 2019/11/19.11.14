00:38:56 <koz_> such string
00:38:57 <koz_> much encode
00:46:40 <jusss> why ByteString is not an instance of FromJSON?
00:46:42 <dminuoso> phanimahesh: Its not as much a text encoding as it is a terminal control protocol.
00:47:08 <jusss> there's ByteString , call r, it's a json data from network, 
00:47:22 <dminuoso> jusss: Because ByteString is just a binary blob of data
00:47:23 <jusss> how I can turn it to a haskell data type?
00:47:57 <jusss> dminuoso: and is Binary a data type?
00:48:53 <dminuoso> jusss: Turning binary data into some data type is a matter of deserialization. It could be different for every data type.
00:50:12 <jusss> dminuoso: err. but in other languages, json is a string, and we pass json as binary, right?
00:50:39 <jusss> after encoding string to binary
00:51:14 <jusss> handle json with requests in python is so simple
00:52:14 <jusss> did we turn binary data to String in haskell ?
00:59:28 <dminuoso> jusss: That depends on what the binary data contains, doesnt it?
00:59:47 <dminuoso> Perhaps the binary data is a PNG encoded image. Perhaps it's an ELF executable.
00:59:58 <dminuoso> Or maybe it's just random data drawn from /dev/urandom ...
01:00:04 <jusss> ByteString to [Word8] ?  Word8 is an instance of FromJSON
01:00:35 <jusss> dminuoso: it's a json data
01:07:45 <lortabac> jusss: if you expect the ByteString to contain text, you can decode it by using one of these functions https://downloads.haskell.org/~ghc/latest/docs/html/libraries/text-1.2.4.0/Data-Text-Encoding.html
01:07:49 <jusss> found it https://hackage.haskell.org/package/aeson-0.7.0.5/docs/Data-Aeson.html
01:08:07 <jusss> decode :: FromJSON a => ByteString -> Maybe a
01:08:11 <lortabac> if it's JSON you can use 'decode'
01:12:43 <Unhammer> can ghci tell me the type of an exception?
01:12:50 <Unhammer> or more specifically, the module it came from
01:12:53 <Unhammer> "Exception: ParseError" could be from several :)
01:15:21 <dminuoso> lortabac: You mean "If you expect the ByteString to contain UTF8 encoded text"
01:17:51 <lortabac> dminuoso: Latin1, UTF-8, UTF-16 or UTF-32
01:18:05 <thebnq> how can I get :i from lambdabot? Or specifically get the fixity
01:19:16 <boxscape> % :i (+) -- use yahb instead thebnq
01:19:16 <yahb> boxscape: ; <interactive>:1:3: error: parse error (possibly incorrect indentation or mismatched brackets)
01:19:22 <boxscape> well, bad example
01:19:32 <boxscape> % :i (+)
01:19:32 <yahb> boxscape: class Num a where; (+) :: a -> a -> a; ...; -- Defined in `GHC.Num'; infixl 6 +
01:19:44 <thebnq> oh cool
01:19:50 <thebnq> % :i (!!)
01:19:50 <yahb> thebnq: (!!) :: [a] -> Int -> a -- Defined in `GHC.List'
01:19:58 <thebnq> My second question is whats the fixity here
01:20:00 <lortabac> Unhammer: if you compile with profiling enabled and run with +RTS -xc -RTS, you can get a stack trace
01:21:54 <boxscape> thebnq https://www.haskell.org/onlinereport/decls.html says "Any operator lacking a fixity declaration is assumed to be infixl 9"
01:24:41 * hackage lukko 0.1.1 - File locking  https://hackage.haskell.org/package/lukko-0.1.1 (phadej)
01:24:43 <thebnq> boxscape: oh thanks!
01:29:42 <Unhammer> hm, that works I guess
01:29:44 <Unhammer> thanks lortabac 
01:46:19 <AmbroseRen> hello every,Please take care of me
01:46:51 <AmbroseRen> this my first to login in here
01:47:25 <Unhammer> is there a version of (.|) that ignores the value of the left-hand conduit?
01:47:29 <Unhammer> return value
01:48:07 <Unhammer> :t .|
01:48:08 <lambdabot> error: parse error on input ‘.|’
01:48:15 <Unhammer> :t (.|)
01:48:16 <lambdabot> error:
01:48:16 <lambdabot>     • Variable not in scope: .|
01:48:16 <lambdabot>     • Perhaps you meant one of these:
01:48:33 <Unhammer> eh, anyway, 
01:48:36 <Unhammer> (.|) :: Monad m => ConduitM a b m () -> ConduitM b c m r -> ConduitM a c m r
01:48:46 <Unhammer> and I want
01:48:48 <Unhammer> Monad m => ConduitM a b m ignored -> ConduitM b c m r -> ConduitM a c m r
01:49:17 <Unhammer> since I'm using mapAccumM and just looking at the accumulator when in that function
01:50:59 <dminuoso> Unhammer: What would that do?
01:51:15 <Unhammer> I'd like to streamily warn if there are more than N elements
01:51:28 <dminuoso> Unhammer: To get what you asked for, you can simply apply the first argument to `void
01:51:44 <dminuoso> or: (() <$ p1) .| p2
01:51:53 <dminuoso> % :t (<$)
01:51:53 <yahb> dminuoso: Functor f => a -> f b -> f a
01:51:54 <Unhammer> ooh thanks
01:52:07 <dminuoso> % :t void
01:52:07 <yahb> dminuoso: Functor f => f a -> f ()
01:52:58 <dminuoso> (I wonder why (.|) doesn't have the type you asked for in the first place)
01:53:40 <Unhammer> hm, maybe they like being explicit about "losing" info along the pipe
01:53:51 <dminuoso> Mmm, perhaps yeah.
02:05:58 <Stone> hi
02:06:20 <Stone> is anybody here?
02:06:43 <dnikolovv> yes
02:08:24 <Cale> Stone: Hello! How's code?
02:08:48 <Stone> I want to learn haskell what do think what would be the most adequate way to do it?
02:09:16 <Stone> I mean what would you recommend to start with?
02:09:20 <f-a> Stone: I personally like cis194
02:09:33 <f-a> https://www.seas.upenn.edu/~cis194/fall16/
02:09:40 <dnikolovv> +1 for that
02:09:41 <Cale> Yeah, Brent Yorgey's version of the course in particular is one that many people recommend
02:10:00 <dnikolovv> follow the course and after you've got the basics
02:10:01 <f-a> written by an experienced haskeller, thorough, clear, with exercises, etc.
02:10:02 <Cale> I'd expect Joachim Breitner's to also be fun :)
02:10:05 <dnikolovv> strive towards building something you care about
02:10:20 <f-a> and free
02:10:22 <dnikolovv> you'll continuously run into various issues and that's how you learn
02:10:31 <Cale> https://www.cis.upenn.edu/~cis194/spring13/
02:11:11 <Cale> If you're looking for a dead-tree book, I might recommend Graham Hutton's "Programming in Haskell"
03:08:32 <Arahael> dnikolovv: Highly recommend that, yeah.  I mean, learning all the theory is nice and all, but what's the point, if you're not *using* it for something?
03:18:11 <dnikolovv> it's so obvious and so easy to skip
03:18:29 <dnikolovv> I was stalling with Haskell for so much time trying to do "excerises" in books
03:19:04 <dnikolovv> then for a few months of tinkering with actual projects I was able to get a job
03:28:11 <mursu> Thanks for the cis194 recommendation!
03:28:31 <mursu> and link
03:37:57 <AWizzArd> Int does not have the right kind to be a Functor. But if we ignored that: wouldn't it fulfill the Functor laws?
03:43:38 <boxscape> AWizzArd what would a functor instance look like, if you ignore the kind issue?
03:44:49 <AWizzArd> boxscape: maybe something like   instance Functor Int where fmap f i = f i
03:45:11 <MarcelineVQ> aka $
03:45:57 <AWizzArd> MarcelineVQ: yes.
03:49:46 <boxscape> Does that make it just the identity functor restricted to Int? (And without the usual newtype)
03:55:14 <kuribas> hmm, I am wondering if they could create a digital piano using flywheels to get more accurate touch.
03:55:23 <kuribas> to simulate the hammer hitting the string
03:55:38 <kuribas> and then a sensor to measure the speed.
04:10:24 <yushyin> kuribas: wrong channel?
04:12:56 <MarcelineVQ> maybe a digital peano with flycheck
04:16:16 <AWizzArd> yushyin: maybe he wanted to make a turn and talk about piano arithmetics
04:16:40 <yushyin> :)
04:19:51 <hpc> curch encoding uses a much more complicated keyboard though
04:35:21 <AWizzArd> Why does   `data Void` has the kind *?
04:35:29 <AWizzArd> It is not inhabited, or is it?
04:35:51 <AWizzArd> has => have
04:35:56 <opqdonut> it has kind * because Void is a type
04:36:00 <opqdonut> (instead of a type constructor)
04:36:03 <hpc> * is the kind of types that "have values", and Void "has" zero values
04:36:28 <opqdonut> that's a nice way of putting it
04:36:31 <AWizzArd> hpc: "have values" could be interpreted as actually having at least one.
04:36:36 <hpc> as opposed to a kind like Constraint, it doesn't make sense to talk about the value of a class constraint
04:37:06 <AWizzArd> hpc: I have Cola. How much I have? Nothing!
04:37:11 <hpc> AWizzArd: maybe "where it makes sense to talk about having values" is a better term
04:37:20 <AWizzArd> k
04:37:39 <opqdonut> the 2010 report uses better language
04:37:42 <opqdonut> "The symbol ∗ represents the kind of all nullary type constructors.
04:38:02 <hpc> so like, "nuka cola" is a noun even if the thing itself doesn't exist
04:38:22 <hpc> but "supercalifrajalisticexpialidocious" is... i think an adjective
04:38:27 <hpc> even though it doesn't exist either
04:39:55 <boxscape> AWizzArd Void does have an inhabitant, namely bottom
04:40:38 <boxscape> compare with Void#, which does not
04:41:02 <hpc> Void# is still of kind * though
04:41:09 <ph88> when i have a function that mutates some variable (given), is it good practice to return that same variable ?
04:41:10 <boxscape> I don't think that's correct
04:41:12 <boxscape> hpc
04:41:15 <hpc> i think, i forget how the kind system works now wrt boxing
04:41:17 <boxscape> % :k Void#
04:41:17 <yahb> boxscape: Void# :: TYPE ('TupleRep '[])
04:41:28 <hpc> ah, nvm
04:41:32 <boxscape> * = TYPE LiftedRep
04:41:58 <boxscape> I think Void# used to be TYPE VoidRep for a short while
04:42:52 <boxscape> ph88 can you elaborate a bit on what you mean? At least to me it's not quite clear
04:42:56 <ph88> btw is there any mechanism to let a function consume a variable so that it can't be used afterwards ?
04:43:14 <hpc> that sounds like affine types
04:43:24 <hpc> https://en.wikipedia.org/wiki/Substructural_type_system
04:43:29 <hpc> or well, that family of type systems
04:43:38 <hpc> i think there's packages that implement it
04:43:53 <boxscape> ph88 there is a proposal to add linear types to ghc as well, but it's not yet finished https://github.com/ghc-proposals/ghc-proposals/pull/111
04:44:15 <ph88> boxscape, sure    myFunction :: MyType -> Bool      now on call site   do; step1 <- myFunction myVal; -- now use myVal or step1  when memory of myVal was changed ?
04:45:19 <boxscape> hm, ghc will give you a warning if you have -Wall enabled and use the same type, which I think suggests that using different names is best practice
04:45:22 <dnikolovv> ph88: not sure if I get you, but the "memory" of myVal will not be changed
04:46:00 <boxscape> dnikolovv it would shadow the name, much like writing `\x -> \x -> x`
04:46:01 <ph88> dnikolovv, why do you think so ? it's a ByteString with a pointer ..
04:46:23 <dnikolovv> yeah now I get you
04:46:46 <boxscape> ph88 btw when I wrote "the same type" I mean "the same name"
04:47:03 <ph88> i don't know if i should make the API immutable and how to do it if it's a good idea
04:47:35 <ph88> boxscape, what names are the same ?
04:48:06 <boxscape> ph88 if I'm understanding you correctly you're suggesting writing something like "myVal <- myFun myVal"?
04:48:30 <boxscape> The two myVals here don't refer to the same thing, it's just the same name twice for different values
04:48:52 <ph88> eh, well what the function is returning right now is not so important. I'm just asking what it should be returning ..
04:49:06 <ph88> it can return just ()  because value has been changed anyway
04:49:24 <dnikolovv> if you're asking whether to return step1 or myVal
04:49:27 <ph88> it's IO function, sorry forgot to mention
04:49:33 <dnikolovv> they are different types so
04:50:20 <dnikolovv> not saying that it's best practice but I'd return myVal over ()
04:50:52 <ph88> type can stay the same
04:50:57 <boxscape> (okay looks like I misunderstood the question)
04:52:11 <ph88> this is my function https://bpaste.net/show/KBSG6 
04:54:01 <dnikolovv> so the issue is how do you notify the caller that his input has been mutated?
04:54:23 <ph88> like when you update a record you have to assign it again to a new variable right ? you can not use the old variable name for the record, because it's immutable ???
04:54:25 <kuribas> yushyin: ah, sorry, I thought this was haskell-offtopic :)
04:55:17 <ph88> dnikolovv, yes i think it's not really clear what the code does when it's mutating memory behind the scenes. I thought haskell being immutable on some points had some things for it that could help here
04:55:40 <dnikolovv> yeah I'm thinking about it
04:55:51 <ph88> ah ok, thank you :)
04:56:01 <dnikolovv> but even if you return the CompileContext
04:56:18 <dnikolovv> yeah I guess it would be much more obvious that it has been mutated
04:56:36 <dnikolovv> more like
04:56:40 <ph88> i can also return Either with left error code and Right the result
04:56:55 <dnikolovv> it would be obvious that it's a different version of the inputted context
04:56:55 <ph88> i can also return Either with left error code and Right the CompileContext
04:57:14 <dnikolovv> then it's obvious that it's a new context but
04:57:15 <ph88> what do you think is best practice here ?
04:57:20 <dnikolovv> it's not obvious that the actual memory has been mutated
04:57:24 <ph88> true
04:57:27 <dnikolovv> I'd definitely go with the Either approach
04:57:43 <dnikolovv> well it seems to me that you can get away with some documentation
04:57:57 <dnikolovv> + the Either
04:58:04 <ph88> so i guess it's better to return a CompileContext and then just wait for lineair types so that the input variable can't be reused ..
04:58:17 <dnikolovv> sounds like a good idea to me
04:58:24 <ph88> thanks for thinking along dnikolovv :D
04:58:33 <dnikolovv> lol you're welcome
04:58:40 <dnikolovv> there's also this
04:58:51 <dnikolovv> how likely do you think it is for someone
04:59:00 <dnikolovv> to try and use the same input again
04:59:09 <dnikolovv> and expect it to be unchanged
05:00:51 <ph88> in just the source file on that spot i think he's not going to care because he's gonna change the value anyway
05:01:59 <ph88> but then on the other hand i remember my job where we had hundres of (non-haskell) scripts that all overwrite some mutable state until the final state arrived. Some parts of the states being written to multiple times because one could not remember that previous script already had set it to the "wrong" value
05:03:25 <dnikolovv> that sounds more like a design problem
05:03:25 <smelc> gosh, reminds me of those Ant script files we had at my job too, which were including other Ant script files; using shadowing of names
05:03:25 <ph88> it's like an opaque bag of memory, but you can use functions on it to change some bits within that
05:03:45 <smelc> the whole thing was scrapped when the original author went away, there was no way to maintain it
05:04:07 <dnikolovv> classic Java
05:05:42 <ph88> i have another question, now that i am returning Either in the function. What if similar functions come and they can be cained, how can i tell which one triggered the error condition in the Either monad ?
05:06:35 <ph88> new function looks like this atm https://bpaste.net/show/LDPZO 
05:08:13 <ph88> Maybe wrap the Int in some other type ? I have no experience writing error types
05:09:27 <dnikolovv> instead of Either Int
05:09:32 <dnikolovv> you can have Either MyCustomError
05:09:39 <dnikolovv> and MyCustomError can hold some context
05:09:55 <dnikolovv> e.g. MyCustomError Text (source) Int (code)
05:09:58 <dnikolovv> or whatever
05:09:59 <ph88> maybe i can attach a stacktrace to the error or something ?
05:10:15 <ph88> I need something to indicate which function this error is coming from
05:10:34 <dnikolovv> if you have a custom error type with some context
05:10:41 <dnikolovv> you can do something along the lines of
05:10:42 * hackage lightstep-haskell 0.4.4 - LightStep OpenTracing client library  https://hackage.haskell.org/package/lightstep-haskell-0.4.4 (DmitryIvanov)
05:11:07 <dnikolovv> throwError $ MyCustomError "this would be the error message or source" 1 (for the error code)
05:12:03 <ph88> i like to keep exceptions out of the library, the user of the library can turn errors into exceptions if he wants
05:12:59 <merijn> ph88: I just provide both interfaces
05:13:21 <merijn> throwError isn't a proper exception, though
05:13:38 <ph88> https://bpaste.net/show/EIUKU so like this would be better ?
05:14:08 <merijn> Depends on how you define better?
05:14:24 <ph88> better than not knowing where an error comes from
05:14:44 <ph88> when using the either monad  one can use a bunch of functions to change that variable
05:14:53 <merijn> Having one function makes it hard to say anything useful how the error handling integrates in the surrounding code
05:15:28 <ph88> alright i'll leave it like this then for the moment
05:15:47 <dnikolovv> throwError is not like "error"
05:16:36 <dnikolovv> it's like returning Left
05:17:18 <dnikolovv> anyway you got what I meant
05:30:21 <boxscape> ph88 you can also look at GHC.Stack if you still want to return a stack trace
05:43:21 <ocharles> Apparently I'm wrong to assume `realToFrac (0.3 :: Float) :: Rational == 3 % 10 :: Rational`. Is that a standard gotcha of floating point numbers?
05:43:30 <ocharles> This one I kind of find surprising
05:45:06 <kuribas> 0.3 is not exactly 3/10
05:45:41 <kuribas> because floating point is base 2, not base 10
05:46:16 <merijn> > realToFrac (0.3 :: Float) :: Rational
05:46:18 <lambdabot>  5033165 % 16777216
05:46:31 <merijn> ocharles: Why would it be surprising?
05:46:50 <infinite_recursi> yo
05:47:08 <ocharles> Because I forgot what kuribas said :)
05:47:49 <kuribas> whoa, why does installing hie has to install a hole new ghc...
05:47:50 <merijn> ocharles: In what context are you doing this anyway? Can't you just use Rational right away?
05:47:57 <merijn> > 0.3 == 3 % 10
05:47:58 <lambdabot>  True
05:48:12 <ocharles> merijn: Sort of. I'm reading data from a database, but it's getting decoded into a `Float` which I was then turning into a `Rational`
05:48:27 <merijn> ocharles: Are you using hexfloats?
05:48:37 <merijn> ocharles: Because if not, you're results are already wrong and hosed
05:48:46 <ocharles> But I see now the database schema uses a PostgreSQL `real`, so loading directly into a `Float` is wrong
05:49:14 <merijn> ah, not sure what format postgres uses internally
05:49:25 <infinite_recursi> I wanted to know your opinions on modularity of Haskell. Can you pinpoint the problem of the most complex codes to a certain area easily?
05:49:26 <ocharles> "4 bytes 	variable-precision, inexact 	6 decimal digits precision"
05:49:44 <ocharles> "The data types real and double precision are inexact, variable-precision numeric types. On all currently supported platforms, these types are implementations of IEEE Standard 754 for Binary Floating-Point Arithmetic (single and double precision, respectively), to the extent that the underlying processor, operating system, and compiler support it."
05:50:10 <ocharles> So `Float` seems right?  I suppose what is confusing me is:
05:50:14 <ocharles> > show (0.3 :: Float)
05:50:16 <lambdabot>  "0.3"
05:50:31 <ocharles> Which suggests that `Float` can exactly represent `0.3`, but I guess there's more to it than that
05:50:58 <merijn> ocharles: This is what I was getting at
05:50:58 <kuribas> ocharles: that's has to do with IEEE rounding
05:51:07 <ocharles> kuribas: ah
05:51:24 <infinite_recursi> I ask my above question in context of security.
05:51:31 <merijn> ocharles: show representation (and printf and others) do extra rounding and *cannot* be relied upon for accurately serialising/deserialising floating point numbers
05:51:42 <ocharles> sure, I'm not using them for that purpose
05:51:46 <merijn> ocharles: That applies, to basically every main language
05:51:57 <kuribas> merijn: but IEEE rounding should be 1 on 1
05:52:00 <merijn> ocharles: Sure, but it also means it can't be relied upon for debug :)
05:52:08 <ocharles> Right, hence misleading me
05:52:26 <merijn> kuribas: There is not defined decimal output for floating point numbers and many implementation rounds the decimal representation differently
05:52:31 <merijn> s/not/no
05:52:33 <svipal> heyo
05:52:34 <ocharles> I think my best option here is to do some rounding myself. The 0.3 in question is in `mm`, so I can take those floats and round to some domain specific precision that we care about
05:52:37 <kuribas> merijn: there is IEEE
05:52:39 <ocharles> Which is probably a micrometer or something
05:52:55 <merijn> kuribas: IEEE-754 does not specify a deterministic rounding to decimal representation
05:53:15 <merijn> kuribas: IEEE-754 specifies the hexfloat format for *accurate* serialisation of floats to text
05:53:30 <merijn> And that is the *only* standardised, accurate representation
05:53:52 <merijn> But it's not decimal so almost no language uses it by default
05:54:26 <merijn> ocharles: I would use Double anyway
05:54:40 <svipal> I have a question. Let 's say I have a function `f :: a -> IO a`. If I have a `v :: Vector a`, is there any way I can use a  kind of lens operator to do something like `g :: Vector a -> (a -> IO a) -> IO (Vector a); g f =   v & a %~?  f`
05:54:42 <ocharles> merijn: It's a 4 byte float in the database, I don't think Double would buy me anything
05:54:45 <ocharles> The precision is already gone
05:54:53 <merijn> ocharles: There's no loss if the database is returning floats and it avoids precision los if it's double
05:55:08 <merijn> ocharles: ah, I thought it was unknown which one the schema was using
05:55:18 <merijn> svipal: That's just mapM?
05:55:29 <ocharles> I think I'll keep using `Rational` for this stuff, but when I convert from Float I'm going to do my own rounding
05:55:37 <svipal> hu
05:55:49 <merijn> svipal: Not the typeclass one, but Vector has its own version
05:56:00 <merijn> svipal: https://hackage.haskell.org/package/vector-0.12.0.3/docs/Data-Vector.html#v:mapM
05:56:31 <boxscape> can you not use the Prelude one with Vector?
05:56:55 <merijn> boxscape: You can on boxed vectors, but the others aren't functor and thus can't be traversable
05:57:01 <boxscape> Ah, I drr
05:57:02 <boxscape> see*
05:57:15 <kuribas> merijn: hmm, I though it was specified... But there are ways to represent floats in decimal without requiring huge amout of digits.
05:57:23 <tabaqui1> I have a multithreaded application, and during its work, somewhere happens an error "Prelude.chr bad argument 1234567"
05:57:30 <tabaqui1> How can I locate the call?
05:57:36 <kuribas> merijn: Which I would expect a database to use, to avoid loss.
05:57:41 <tabaqui1> I tried to add HasCallStack constraint in random places
05:57:42 <merijn> kuribas: Sure, but that representation isn't *accurate*
05:57:45 <tabaqui1> but it didn't help
05:57:58 <kuribas> merijn: yes it is accurate
05:57:59 <tabaqui1> I hope, there is more sensible way
05:58:12 <merijn> kuribas: How do you define accuracy?
05:58:20 <kuribas> merijn: that there is no loss
05:58:47 <boxscape> tabaqui1 you need to compile with certain flags to get a callstack, I believe -prof and -fprof-auto
05:58:49 <kuribas> that readFloat . writeFloat == id
05:58:58 <kuribas> for every float
05:59:11 <boxscape> or wait
05:59:13 <merijn> kuribas: NaN and Infinity already ruin that :p
05:59:25 <boxscape> the GHC.Stack documentation is somewhat confusing
05:59:33 <merijn> boxscape: You don't, profiling and HasCallStack are alternate ways of getting stacks
05:59:33 <kuribas> merijn: you can represent that in a string too
05:59:50 <tabaqui1> boxscape: uh, it requires to recompile all deps
05:59:55 <tabaqui1> I'll wait and try
06:00:12 <boxscape> merijn right I was thinking of currentCallStack
06:00:15 <kuribas> merijn: maybe denormalised numbers don't apply...
06:01:00 <svipal> How would you use mapM with ix ?
06:01:39 <kuribas> :t ix
06:01:40 <lambdabot> (Ixed m, Applicative f) => Index m -> (IxValue m -> f (IxValue m)) -> m -> f m
06:01:54 <kuribas> svipal: what do you mean?
06:02:12 <kuribas> svipal: mapM is traverse, and lenses are already traversals
06:02:18 <kuribas> :t traverseOf
06:02:19 <lambdabot> LensLike f s t a b -> (a -> f b) -> s -> f t
06:02:30 <kuribas> traverseOf is just id
06:03:41 <svipal> I guess I made lenses too much of a block box
06:04:11 <svipal> I mean that I don 't see how I can just modify the element at an index with a monadic function
06:04:26 <boxscape> tabaqui1 so to be clear I was wrong, those flags don't help with the HasCallStack callstacks
06:04:44 <tabaqui1> boxscape: so I should locate it manually?
06:04:59 <kuribas> svipal: you can do "traverseOf (ix i) f"
06:04:59 <boxscape> I'm not sure what the best way is tbh
06:05:26 <kuribas> svipal: or just "ix i f"
06:05:53 <kuribas> svipal: the last is actually a leaking implementation details, you can use traverseOf for clarity.
06:06:03 <svipal> Oo.
06:06:04 <tabaqui1> boxscape: I think, that I can set a global catch and use "whoCreated" function
06:06:14 <kuribas> svipal: it takes a lens, and turns it into a traversal.
06:06:31 <boxscape> sounds like an idea, though for whoCreated you *do* need those flags I believe tabaqui1
06:06:50 <tabaqui1> but it still requires profiling flags
06:06:55 <boxscape> yeah
06:07:04 <tabaqui1> ok, thanks anyway
06:07:30 <svipal> thanks, looks like I have work to do
06:10:41 <boxscape> tabaqui1 it looks like that, if you compile with -prof, you can run your program with +RTS -xc to get a detailed stack trace from an exception https://wiki.haskell.org/Debugging
06:12:18 <tabaqui1> boxscape: no need to catch globally, cool
06:12:46 <boxscape> (though keep -fprof-auto as well and I suppose maybe -fprof-cafs, not sure what it does)
06:13:05 <tabaqui1> I'll find out
06:15:52 <kuribas> is there a way to make hie work with an existing installion?
06:27:10 <merijn> kuribas: Have you tried using ghcide instead?
06:27:23 <kuribas> merijn: why?
06:27:34 <merijn> kuribas: I found it much easier to setup than hie
06:27:44 <merijn> Or rather, I never got hie to work :p
06:28:26 <kuribas> merijn: It seems their solution to make it work is to download it's own versions of ghc
06:28:44 <kuribas> merijn: but it looked they added a lot of features.
06:28:51 <kuribas> more than ghcide
06:29:22 <merijn> tbh the only thing I really want is "warning/error highlighting" and "query type" everything else is bonus
06:29:38 <kuribas> I already have that just with flycheck
06:29:52 <kuribas> and haskell-mode
06:29:58 <merijn> kuribas: How did you setup "query type"?
06:30:09 <kuribas> merijn: it works out of the box
06:30:17 <kuribas> merijn: but I do have to load the buffer into ghci first
06:34:10 <fendor> kuribas, what do you mean with "existing installation"?
06:34:22 <kuribas> fendor: existing ghc
06:34:26 <kuribas> and packages
06:34:29 <fendor> sure, which version?
06:34:46 <kuribas> fendor: 8.4.4 for example
06:34:57 <fendor> kuribas, any preferences? cabal/stack/nix ?
06:35:05 <kuribas> fendor: cabal :)
06:35:31 <fendor> is there any problem with installation script?
06:35:35 <fendor> *the
06:35:51 <fendor> or did you try the installation script?
06:36:59 <fendor> or did I misunderstand?
06:37:03 <kuribas> fendor: I did: "stack ./install.hs hie-8.4.4"
06:37:10 <kuribas> fendor: it seems to be installing a lot of packages
06:37:37 <fendor> yeah, you can also du `cabal run ./install.hs --project-file install/shake.project  hie-8.4.4`
06:37:41 <fendor> it will install a lot of packages
06:37:57 <kuribas> fendor: ah I see.  And it will reuse exiting packages?
06:38:07 <fendor> kuribas, yeah, just like normal cabal
06:38:14 <kuribas> fendor: ah great, thanks
06:38:17 <fendor> maybe `v2-run`
06:38:32 <kuribas> now how do I get rid of the stack build?
06:38:51 <kuribas> rm .stack -rf ?
06:38:54 <fendor> rm -rf ~/.stack ? also rm -rf .stack-work/
06:39:06 <fendor> that deletes everything from stack
06:40:44 <fendor> nix can use a binary cache, thus, is faster.
06:41:38 <kuribas> fendor: cabal: unrecognized 'run' option `--project-file'
06:42:05 <fendor> kuribas, what is the cabal version?
06:42:20 <kuribas> cabal-install version 2.4.1.0
06:42:27 <fendor> then use `v2-run`
06:45:33 <kuribas> fendor: that works, thanks!
06:45:49 <fendor> kuribas, you're welcome!
06:46:01 <kuribas> fendor: are you a maintainer of hie?
06:46:34 <fendor> kuribas, at least a contributor :) 
06:46:44 <kuribas> I see :)
06:59:28 <purelazy> > 1
06:59:31 <lambdabot>  1
06:59:46 <purelazy> ( * 2) (2)
06:59:51 <purelazy> > ( * 2) (2)
06:59:53 <lambdabot>  4
07:00:01 <purelazy> > ( * 2) (2.2)
07:00:02 <lambdabot>  4.4
07:00:12 <purelazy> > ( * 2) (Just 2)
07:00:13 <lambdabot>  error:
07:00:14 <lambdabot>      • No instance for (Num (Maybe Integer))
07:00:14 <lambdabot>          arising from a use of ‘e_122’
07:00:30 <boxscape> why does hoogle show a () constraint for a lot of functions? (e.g. seq)
07:01:05 <kuribas> > (* 2) <$> Just 2
07:01:07 <lambdabot>  Just 4
07:01:12 <kuribas> purelazy: ^^
07:01:14 <purelazy> How is it Haskell can do the right thing for (* 2) 2, (* 2) 2.2, but not (Just 2)
07:01:33 <purelazy> I know about <$>
07:01:41 <kuribas> purelazy: because it doesn't try to guess what you think is right, like other languages do.
07:02:08 <kuribas> purelazy: instead it expects you to be precise.
07:02:10 <boxscape> purelazy you could make that work, if you defined a Num instance for Maybe. * and + and such are only defined for types that have Num instances
07:02:47 <purelazy> But I would think it knows the difference between 2, 2.2 and Just 2
07:02:49 <kuribas> purelazy: implicit behaviour in other language (like javascripts) tends to backfire
07:03:06 <kuribas> purelazy: sure you could define a Num instance for Num a => Just a
07:03:29 <merijn> purelazy: The first two have Num instances, Maybe does not
07:03:36 <merijn> :t (*)
07:03:37 <lambdabot> Num a => a -> a -> a
07:03:37 <purelazy> So its a "OK, enough implicits here!!!" policy.
07:03:41 <merijn> :t 2.2
07:03:42 <lambdabot> Fractional p => p
07:03:44 <kuribas> purelazy: erm Num a => Maybe a
07:03:47 <purelazy> Which I can understand
07:03:56 <merijn> purelazy: There is nothing implicit there, tbh
07:04:29 <kuribas> merijn: it could put such an instance in Base.
07:04:31 <boxscape> (or actually to get something like `2.2 * Just 2` to work you'd need a different type class than Num)
07:04:41 <kuribas> merijn: but I suppose that would be causing even more confusing error messages.
07:05:00 <merijn> purelazy: (*) works on any type that's a num instance "2" works for any type that is a Num instance, 2.2 works for any type that's an instance of Fractional (which is a subclass of Num) So the conclusion is "2 * 2.2 :: Fractiona p => p"
07:06:10 <merijn> purelazy: So there is no implicit conversions, it's just that numeric literals (unlike most other languages) are *explicitly* polymorphic and thus can be used for multiple different types
07:08:25 <purelazy> What is not a polymorphic type?
07:08:38 <merijn> :t 2.2
07:08:39 <lambdabot> Fractional p => p
07:08:55 <merijn> purelazy: This says "2.2 has any type as long as that type has a Fractional instance"
07:09:13 <merijn> purelazy: Maybe does *not* have a Fractional instance, so that's not allowed
07:09:17 <purelazy> Is Char polymporphic?
07:09:21 <merijn> No
07:09:22 <kuribas> boxscape: not, that would work
07:09:45 <kuribas> boxscape: it would work with Maybe Float
07:09:47 <merijn> > 2.2 :: Maybe Double
07:09:49 <lambdabot>  error:
07:09:49 <lambdabot>      • No instance for (Fractional (Maybe Double))
07:09:49 <lambdabot>          arising from the literal ‘2.2’
07:09:57 <merijn> > 2 :: Int
07:09:59 <lambdabot>  2
07:10:02 <merijn> > 2 :: Double
07:10:03 <lambdabot>  2.0
07:10:22 <boxscape> I guess if you add a Fractional instance as well. Really I was thinking of something like `2.2 + Just (2 :: Int)`
07:10:41 <purelazy> Let's forget about polymorphism
07:10:54 <purelazy> It must be confusing me
07:11:24 <purelazy> > id 'c'
07:11:26 <lambdabot>  'c'
07:11:46 <purelazy> > 'id' (Just 'c')
07:11:47 <lambdabot>  error:
07:11:47 <lambdabot>      • Syntax error on 'id'
07:11:47 <lambdabot>        Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
07:12:04 <boxscape> > id (Just 'c')
07:12:06 <purelazy> No polymorphism 
07:12:06 <lambdabot>  Just 'c'
07:12:14 <boxscape> id is polymorphic
07:12:33 <merijn> :t id
07:12:34 <lambdabot> a -> a
07:12:53 <boxscape> % :set -fprint-explicit-foralls
07:12:53 <yahb> boxscape: 
07:12:55 <boxscape> :t id
07:12:56 <lambdabot> a -> a
07:13:00 <boxscape> :t +v id
07:13:02 <lambdabot> a -> a
07:13:06 <purelazy> boxscape: Thanks
07:13:07 <merijn> purelazy: id has a type that says "I work on ANY type 'a'", which happens to include "Maybe Char"
07:13:09 <boxscape> hmm
07:13:19 <merijn> :t id `asAppliedTo` Just 'c'
07:13:20 <lambdabot> Maybe Char -> Maybe Char
07:13:28 <merijn> lambdabot: % is for yahb
07:13:45 <boxscape> uh yeah of course
07:13:46 <merijn> :t (*)
07:13:47 <lambdabot> Num a => a -> a -> a
07:13:51 <boxscape> % :t +v id
07:13:51 <yahb> boxscape: forall a. a -> a
07:13:58 <merijn> :t (*) `asAppliedTo` (2 :: Int)
07:14:00 <lambdabot> Int -> Int -> Int
07:14:02 <kuribas> :t (*)
07:14:03 <lambdabot> Num a => a -> a -> a
07:14:31 <merijn> purelazy: Note that (*) says "I work on any type AS LONG AS that type has a Num instance"
07:14:48 <kuribas> purelazy: having to many instances can make errors confusing.  In fact numeric errors are already confusing :)
07:14:54 <merijn> purelazy: So the deciding factor on whether (*) works is "does this type have a Num instance"
07:15:51 <purelazy> My main issue is the " " (being apply) is so beautiful and "<$>" makes me vomit
07:17:47 <merijn> You can't "magically" apply functions to anything
07:18:11 <merijn> So I'm not really sure how you'd propose things to work differently
07:18:58 <boxscape> purelazy some people have suggested idiom brackets for this, which aren't in vanilla haskell but would allow you to write [| (2*) (Just 3) |], or even [| Just 2 * Just 4 |], I believe, unless I'm misremembering the details
07:19:34 <merijn> I forgot the details of idiom brackets, so who knows
07:19:48 <merijn> I don't think those will ever appear in Haskell, though, so the point is mostly moot
07:19:52 <purelazy> There must be lots of "apply" functions
07:20:07 <merijn> how so?
07:20:16 <purelazy> " " and "<$>" and .... I have no idea how many
07:20:27 <merijn> Also, if you just don't like the symbol you can use fmap?
07:20:59 <purelazy> merjin - I should say "apply-like" functions
07:21:11 <boxscape> arguably (=<<) is an "apply-like" function
07:21:30 <merijn> purelazy: Well, what else do you propose?
07:22:02 <purelazy> Thing is which me - I guess I'm "symbol-dyslexic"
07:22:03 <boxscape> just do it all implicitly :P
07:22:16 <purelazy> <$> = it's jibberish
07:22:51 <purelazy> Thing is with me - I guess I'm "symbol-dyslexic"
07:23:10 <kuribas> purelazy: then use fmap
07:23:18 <kuribas> > fmap (* 2) (Just 2)
07:23:20 <lambdabot>  Just 4
07:23:27 <purelazy> kuribas: Please show me how
07:23:32 <kuribas> > (* 2) `fmap` (Just 2) -- like this
07:23:34 <lambdabot>  Just 4
07:23:41 <merijn> purelazy: "f <$> x" is just "fmap f x"
07:23:48 <purelazy> Wow
07:23:52 <purelazy> thanks mate
07:24:30 <purelazy> let superapply = fmap
07:25:24 <dsal> You can also get rid of $ and . if you just write your code like lisp.
07:25:28 <purelazy>  > let apply = fmap
07:25:51 <dsal> fmap is not apply.  $ is apply
07:25:52 <purelazy> > apply (* 2) (Just 2)
07:25:54 <lambdabot>  error:
07:25:55 <lambdabot>      Variable not in scope:
07:25:55 <lambdabot>        apply :: (Integer -> Integer) -> Maybe Integer -> t
07:26:11 <kuribas> purelazy: fmap isn't apply
07:27:01 <purelazy> > (* 2) `fmap` (Just 2)
07:27:03 <lambdabot>  Just 4
07:27:17 <boxscape> (* 2) `fmap` Just 2)
07:27:20 <boxscape> > (* 2) `fmap` Just 2)
07:27:23 <lambdabot>  <hint>:1:20: error: parse error on input ‘)’
07:27:23 <boxscape> > (* 2) `fmap` Just 2
07:27:25 <lambdabot>  Just 4
07:27:34 <boxscape> don't need the parentheses at the end
07:27:50 <dsal> > let apply = ($) in (* 2) `apply` 2
07:27:51 <lambdabot>  4
07:28:23 <purelazy> > let myapply = ($)
07:28:25 <lambdabot>  <no location info>: error: not an expression: ‘let myapply = ($)’
07:28:38 <boxscape> % let myapply = ($)
07:28:38 <yahb> boxscape: 
07:28:48 <boxscape> % myapply (*2) 2
07:28:48 <yahb> boxscape: 4
07:28:59 <purelazy> hmm: Does lambda bot have stae?
07:29:04 <purelazy> hmm: Does lambda bot have state?
07:29:10 <boxscape> yes with @let
07:29:45 <purelazy> > @let xx = ($)
07:29:46 <lambdabot>  <hint>:1:1: error: parse error on input ‘@’
07:29:53 <purelazy> @let xx = ($)
07:29:54 <lambdabot>  Defined.
07:30:11 <purelazy> ( * 2) xx (Just 2)
07:30:32 <dsal> xx is not an operator
07:30:44 <purelazy> > xx  ( * 2)  (Just 2)
07:30:46 <lambdabot>  error:
07:30:46 <lambdabot>      • No instance for (Num (Maybe Integer))
07:30:46 <lambdabot>          arising from a use of ‘e_122’
07:31:05 <purelazy> :(
07:31:08 <svipal> fmap
07:31:45 <dsal> This gets easier if you learn how and why the things you're complaining about exist.
07:32:54 <purelazy> > let apply = ($) in (* 2) `apply` 2
07:32:56 <lambdabot>  4
07:33:19 <kuribas> purelazy: being more explicit is what I like about haskell.
07:34:08 <kuribas> none of the magic is hidden, it all reflects in the types.
07:35:17 <purelazy> @let apply = <$>
07:35:17 <lambdabot>  Parse failed: Parse error: <$>
07:35:41 <geekosaur> needs parens
07:35:49 <purelazy> @let apply = (<$>)
07:35:51 <lambdabot>  Defined.
07:36:18 <purelazy> (* 2) `apply` (Just 2)
07:36:32 <purelazy> > (* 2) `apply` (Just 2)
07:36:34 <lambdabot>  Just 4
07:36:54 <purelazy> Thanks. That's gonna help me a lot
07:37:01 <purelazy> You all great
07:37:37 <purelazy> No more jibberish :)
07:39:49 <purelazy> Thanks geekosaur, kuribas, dsal, svipal, boxscape, lambdabot
07:40:01 <dsal> Why would your rename fmap?  That won't help you and will just confuse anyone who tries reading your code since that isn't apply
07:40:30 <dsal> > succ $ 3
07:40:32 <merijn> Not to mention that apply is a horribly misleading name
07:40:33 <lambdabot>  4
07:40:57 <dsal> > succ <$> [3, 4]
07:40:58 <purelazy> dsal: Why would I? or anyone?
07:40:58 <lambdabot>  [4,5]
07:41:48 <purelazy> What makes you think I would write code to be read by anyone else?
07:41:48 <dsal> > [succ, pred] <*> [3, 4]
07:41:50 <lambdabot>  [4,5,2,3]
07:43:23 <dsal> > let addadd = (*) in 2 `addadd` 3
07:43:25 <lambdabot>  6
07:44:16 <purelazy> dsal: Did I say I would write code to be read by anyone else?
07:44:59 <geekosaur> "someone else" has  an annoying teendency to be you 6 months later, once you've become used to fmap and then confuse yourself with apply
07:45:30 <dmwit> This argument is probably not the most productive thing we could be doing right now.
07:45:44 <purelazy> dmwit: I agree
07:45:57 <purelazy> dmwit: They just don't get it
07:46:11 <dmwit> Don't mistake that statement for agreement, friend.
07:47:27 <purelazy> I apologise for sounding like a dimwit, but I find it hard to assimilate symbols like <$> etc
07:48:14 <dsal> ... And works like fmap
07:48:19 <purelazy> I have found a workaround for myself
07:48:45 <purelazy> Other need never see my work
07:48:55 <purelazy> Others need never see my work
07:48:57 * dsal had a Drive-o... Meant words
07:49:19 <purelazy> But I got my answers, and I am greatful
07:49:57 <kuribas> purelazy: you use <$> so often that you get used to it.
07:50:05 <kuribas> purelazy: but I would keep away from most operators in lens
07:50:13 <purelazy> And I can always write tiny "convert to neuro-typical" routines
07:51:12 <purelazy> So you can understand them
08:15:41 * hackage happstack-server 7.6.0 - Web related tools and services.  https://hackage.haskell.org/package/happstack-server-7.6.0 (JeremyShaw)
08:21:46 <svipal> is anyone else getting disconnected a lot
08:21:57 <svipal> question : does anyone here use Massiv ?
08:28:21 <asheshambasta> has anyone had any luck in being able to debug a stuck hie? Hie seems to run when invoked manually from the project directory, however it seems to fail in starting up a server when passed with some flags. 
08:28:54 <asheshambasta> https://github.com/haskell/haskell-ide-engine/issues/1133#issuecomment-553959005 I've written what I could find to the best of my knowledge. 
08:29:16 <asheshambasta> Also, what's currently the most reliable setup for Haskell workflows using emacs now that Intero has been EOL-ed. 
08:31:49 <devalot> asheshambasta: I've been using dante for years and really like it.  To give it access to a repl I use nix + direnv.
08:36:09 <asheshambasta> devalot: last I checked, dante didn't have basics like goto definition etc. did it? 
08:36:37 <asheshambasta> also, how does it perform compared to intero and hie (both of which are really slow on large projects)
08:37:41 * hackage happstack-server-tls 7.2.1 - extend happstack-server with https:// support (TLS/SSL)  https://hackage.haskell.org/package/happstack-server-tls-7.2.1 (JeremyShaw)
08:41:16 <devalot> asheshambasta: I never used intero so I can't compare.  I don't have any complaints about dante's performance.  And for goto definition I use a tags table.
08:42:20 <asheshambasta> okay; but anyway, in case it helps someone, in my case, the issue on emacs-27 seems to be because lsp-haskell fails with native json support, which I'm told has performance benefits. 
08:42:27 <devalot> To be honest, I don't use a lot of IDE-like features.  I mostly just want to see compiler errors in my code before I run the compiler.
08:44:28 <asheshambasta> devalot: seems like to me that is the wisest at this point; something like ghcid alongside emacs with simple haskell mode sounds attractive. 
08:44:31 <sm> morning all
08:44:51 <asheshambasta> needless to say, you cannot get better performance out of emacs when comparing to that. 
08:45:44 <sm> yep, the most reliable emacs haskell setup is ghcid in a shell buffer
08:46:10 <dminuoso> sm: Have you tried using compilation-mode with it?
08:46:23 <dminuoso> It's really superb because it requires so little modification to emacs :)
08:46:42 <sm> I think I did once, but I thought that didn't work with interactive things ?
08:46:53 <dminuoso> What do you mean by interactive things?
08:46:53 <sm> time to try again!
08:46:55 <dminuoso> https://github.com/ndmitchell/ghcid/blob/master/plugins/emacs/ghcid.el 
08:47:08 <dminuoso> This works like a charm. Needs a minor modification to work with cabal v2-
08:47:23 <sm> sorry I'm confusing with ghci. I have one of those open too
08:47:56 <dminuoso> ?
08:48:25 <sm> I was confusing ghcid with ghci. I didn't knw about ghcid.el, thanks!
08:50:55 <dminuoso> Ah! 
08:51:13 <dminuoso> sm: I made the same mistake, read ghcid and thought ghcid :)
08:51:27 <dminuoso> Oops I did it again.
08:52:49 <sm> happens constantly :)
08:53:24 <dminuoso> I think dante is very similar to ghcid, I dont know how they differ though.
08:53:46 <dminuoso> But ghcid is much simpler, and essentially cant fail.
08:53:49 <sm> dminuoso: so ghcid.el fixes two problems with plain compilation-mode for ghcid - it scrolls to keep the first error in view, like terminal; and it fontifies the results. Great!
08:53:49 <f-a> neil needs a statue for ghcid
08:54:04 <dminuoso> sm: Yup :)
08:55:55 <f-a> there is --reverse-errors for everyone who uses terminal
08:56:15 <f-a> *anyone
08:58:24 <sm> f-a: agreed!
08:59:21 <devalot> Dante integrates with flycheck for inline compiler errors and hlint for warnings.
08:59:31 <dsal> succ dante
08:59:59 <devalot> And it also provides a backend for company-mode for some types of completions.
09:03:41 * hackage tmp-postgres 1.12.0.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.12.0.0 (JonathanFischoff)
09:13:39 <chreekat> The one thing about ghcid I didn't necessarily appreciate was that I couldn't use it to jump to errors. Then I discovered the -o flag. Now my whole world is complete. With "-o errors.err", :cfile (in vim) Just Works™ - hands down the *best* way to jump to errors I've used so far
09:14:54 <kuribas> compiling haskell-ide-engine fails on compiler/basicTypes/Avail.hs: error: parse error on input ‘[’
09:15:04 <kuribas> that file isn't even in the package!
09:15:19 <kuribas> erm, forget that...
09:15:59 <fendor> kuribas, are you compiling ghc? 0.o
09:16:16 <kuribas> fendor: no, hie
09:16:43 <fendor> but compiler/basicTypes/Avail.hs is ghc
09:16:50 <kuribas> fendor: well, it fails on that
09:17:00 <sm> dminuoso: ghcid.el seems fine with resizing the ghcid window as long as you don't make it shorter than the original height
09:17:16 <fendor> kuribas, can you paste the whole log?
09:17:46 <sm> dminuoso: also, does C-x ` not work ?
09:18:04 <sm> devalot: will give dante a try too, thanks
09:18:21 <kuribas> fendor: hmm, it's maybe haddock which is failing
09:18:29 <kuribas> fendor: perhaps I need a newer haddock?
09:18:40 <fendor> kuribas, dont know why haddock should be needed
09:19:14 <sm> chreekat: interesting!
09:19:43 <djanatyn> devalot: just switched to dante today after intero stopped working with a recent ghc version
09:20:08 <fendor> kuribas, with the build output, it would be easier to tell! :)
09:21:07 <sm> dante: "no suck file or directory, snack"  :)
09:21:39 <sm> no such file or directory, snack. What is this "snack"
09:23:16 <f-a> sm: chestnuts will do
09:24:03 <dsal> snack is just its pet name for the user
09:24:05 <kuribas> fendor: I'll come back to it later
09:26:16 <sm> devalot: alas, dante falling back into the "doesn't work yet" pile
09:27:05 <sm> I tried customising dante-repl-command-line too
09:29:48 <sm> no matter what, "buffer *dante.. has no process"
10:04:59 <dsal> Brain not working.  What's the number type where you get to specify the valid range of numbers?
10:09:10 <MarcelineVQ> depends how much granete you want
10:09:11 <MarcelineVQ> Ix or Finite
10:09:18 <MarcelineVQ> *guarantee
10:09:55 <MarcelineVQ> There's surely others that could fit better too
10:10:30 <dsal> Finite was the thing I was thinking of.  I never think of Ix...  It's not what I'm looking for, though.
10:11:39 <refusenick> Is there any way to do hotswapping in Haskell like with Lisp or Erlang?
10:11:42 <dsal> Hmm....  So Finite isn't a Num?
10:12:51 <MarcelineVQ> dsal: https://hackage.haskell.org/package/finite-typelits-0.1.4.2/docs/Data-Finite.html
10:13:04 <refusenick> I see packages for hotswapping online, but it doesn't seem typical.
10:13:33 <dsal> MarcelineVQ: Oh weird.  I ended up on a really old version.
10:14:12 <sm> refusenick: it's not, it would be great if more people explored it
10:14:57 <sm> what's the scenario you have in mind ?
10:15:19 <refusenick> sm: just easy experimentation with applied math stuff
10:15:34 <jle`> dsal: Finite is for integers, but in the general case you can use the 'Refined' library
10:15:37 <dsal> erlang, at least, has a very tiny type system with clear representation of serialized form and almost all code moves state via tail recursive calls.  It's super easy to swap code out with their design.
10:15:42 <sm> how would it help you there, compared to ghci say ?
10:15:44 <refusenick> I really like Lisp's way of doing it, is all. 
10:15:44 <jle`> dsal: for floating points and stuff like that too
10:16:03 <dsal> jle`: Thanks.  I'm just counting up milliseconds in a minute and ended up with... a lot more than I expected in some cases.
10:16:12 <jle`> dsal: and also more complex range like ones that don't start at zero, or negative
10:16:25 <jle`> dsal: ah, then that sound work
10:16:40 <jle`> i don't really consider Finite to be 'restricted range of numbers', but rather like a finite set of ordered anonymous elements
10:16:41 <refusenick> being able to save persistent state in some way like an IPython notebook would be nice, but I see an opportunity with Haskell - it might be better for reproducibility to have a system which is Haskell all the way down (or most)
10:17:00 <jle`> ie like `Finite 3` i think of as basically the same as Ordering, `Finite 2` the same as Bool, etc.
10:17:07 <sm> there are IHaskell notebooks, aren't there
10:17:36 <dsal> jle`: Would you not recommend `Finite 61000` for counting millis?
10:17:37 <jle`> but in the cases where it does work as a restricted Integer, it's definitely usable :)
10:17:53 <refusenick> Jupyter notebooks are cool and all (definitely a strict improvement over, say, Stata), but they weren't designed thoughtfully IMO
10:18:08 <refusenick> I'm pining for ASDF right now :)
10:18:17 <jle`> dsal: yeah, that would be fine i think :)
10:18:36 <refusenick> It just seems strange that so many Haskellers came here from Lisp and left that workflow behind.
10:18:40 <refusenick> Is there a reason?
10:18:49 <sm> it's ha-aaard
10:19:28 <refusenick> I suppose it is. Lisp was built with Lisp Machines in mind, so it doesn't play well with Unix.
10:19:39 <sm> I'd say part of it is that 99% of available brain cycles have been soaked up by just ordinary building, so far
10:20:01 <sm> if that was simple, there'd be more people exploring cooler things
10:20:07 <EvanR> there is a fundamental issue with idiomatic haskell that stops persistent environments, that many "values" in haskell are not expressions
10:20:27 <jle`> dsal: just be aware that the Num instance is partial too, in case you use it
10:20:29 <refusenick> Is there anything like a database for Haskell in Haskell? I really like how Prolog stores data in its own relations. I've heard of MiniKanren-style logic programming with the List Monad.
10:20:38 <EvanR> IORefs, functions, Data.Map
10:20:48 <dsal> jle`: I'd assume so.
10:20:51 <EvanR> kind of mitigated with fromList [] but still
10:21:35 <EvanR> [m]et split
10:21:56 <f-a> talk of lisp an get a netsplit
10:21:56 <f-a> coincidence?
10:21:56 <EvanR> probably only people with glirc can hear me
10:22:02 <ashkan_kiani> oh my lord. the matrix users are all being reset right now haha
10:22:12 <refusenick> wat
10:22:24 <EvanR> this is like the end of the matrix 3
10:22:32 <sm> what's missing from the existing reload libs on hackage ? maybe they work and just need users ?
10:22:41 <EvanR> like rapid?
10:22:47 <sm> yeah
10:22:51 <f-a> sm: which one do you use?
10:22:53 <MarcelineVQ> At first I thought "It'd be nice if matrix lied a little and let their users die out a little slower on a split." but imagine that spam being threaded over top of a whole conversation instead.
10:22:55 <f-a> use/suggest
10:23:19 <EvanR> yeah get it over with like pulling a tooth with a door knob
10:23:29 <refusenick> sm: IDK. I'm just exploring solutions. It seems like something people are familiar with. Is there a most-popular option?
10:24:15 <sm> f-a: I don't use any of them.. reloading data is as far as I've got
10:25:26 <sm> refusenick: no.. basically nobody is doing it, or we'd have heard about it
10:25:26 <f-a> let's see what tidal uses
10:26:06 <dsal> jle`: It looks like addition rolls over.  Bad state is not representable, but it's not because only good things happen. heh.
10:26:57 <refusenick> f-a: Oh, it's like that live music coding project in Lisp! https://overtone.github.io/
10:27:10 <f-a> yeah refusenick very similar
10:27:56 <refusenick> Is it related to Hudak's book on music and FRP?
10:28:27 <sm> one obvious place where hot code reloading would seem very useful is visual apps, like games
10:28:39 <f-a> refusenick: I don't know for sure
10:29:22 <sm> eg f-a has just recently made a very cool TUI platformer game, venzone
10:29:35 <sm> it already hot-reloads levels, but hot-reloading code would be even better
10:29:41 <f-a> slowly slowly working on it
10:29:46 <f-a> yeah it would be super
10:30:08 <f-a> I believe that every hot-swap project nowadays leverages ghc(i)?
10:30:27 <f-a> hot swapping while testing would be Godsent
10:30:44 <f-a> refusenick: I suppose you are a lisper, right?
10:30:44 <refusenick> sm: I'm very partial towards visual programming, and Haskell seems like a good fit. Something like live-compiling tensor network diagrams to a running system would be cool.
10:31:27 <refusenick> f-a: Lisper in rehab. As my interests have shifted from CS to math, it's started to look less shiny.
10:32:06 <refusenick> I still write a fair amount of Elisp for myself, but I can't find a good excuse to use CL over the other options.
10:32:12 <sm> refusenick: it's not exactly code reloading, but I usually try to rig up hot-feedback loops using entr or ghcid's ability to run any GHCI command
10:32:26 <f-a> +1
10:34:02 <refusenick> It's actually kind of a shame. Lisp's fast, but not fast enough to beat C++ at numerics, and it doesn't have support for security, so it's only safe for single user interactive systems.
10:34:35 <f-a> refusenick: every lisp/scheme? or just cl?
10:35:14 <refusenick> f-a: Scheme is cool, but very minimal. When it has stuff built atop, it's usually CL-style stuff (e.g. Guile's GOOPS is a port of CLOS).
10:35:40 <refusenick> I suppose Racket is its own thing and has a cool ecosystem of its own.
10:35:55 <refusenick> but Haskell looks like it overlaps with my other interests.
10:38:02 <refusenick> My only complaint about Emacs, now that multithreading is here, is that it's a huge security hole. I'm an addict, though.
10:38:52 <refusenick> Speaking of Emacs, anyone know how to set up Flycheck to use Cabal instead of Stack?
11:16:41 <refusenick> Stack and Cabal both insist that they're build systems, not package managers. Is there a package manager for Haskell?
11:16:48 <refusenick> (actually happy with Cabal so far, just curious)
11:18:24 <f-a> refusenick: cabal-install (lowercase 'c'), especially the new-build etc. commands, deal with most things a package manager would do
11:18:52 <Athas> refusenick: they are essentially package managers, just not in the sense that rpm and dpkg are package managers.
11:18:58 <MarcelineVQ> *except for actually installing/uninstalling packages
11:19:10 <Athas> MarcelineVQ: they can't uninstall, but surely they can install?
11:19:46 <MarcelineVQ> depends on what connotation of install we're assuming :X
11:20:11 <Athas> Putting something in position for future use.
11:21:37 <fragamus> hi im working on a comonad and while im at it, i want to understand extend.  I have always used duplicate
11:22:09 <nshepperd1> I have a package manager which is a script wrapping cabal new-build and updates your default ghc environment
11:22:12 <fragamus> can anyone shed light? looking at laws and type signatures is not working
11:23:07 <EvanR> :t extend
11:23:08 <lambdabot> error: Variable not in scope: extend
11:23:18 <EvanR> testament to how popular Comonad is
11:23:43 <EvanR> :t Control.Comonad.extend
11:23:45 <lambdabot> Control.Comonad.Comonad w => (w a -> b) -> w a -> w b
11:24:38 <EvanR> fragamus: this takes a "summarize function" and a world, and gives back a world of summaries
11:25:06 <EvanR> which is the summary evaluated everywhere
11:25:41 <dmwit> nshepperd1: Isn't that what cabal v2-install --lib does?
11:26:04 <dmwit> ...or does your script also support deinstallation?
11:26:33 <EvanR> the overused example is a convolutional image filter
11:26:35 <nshepperd1> It supports deinstallation, also upgrades
11:28:39 <irc27313> how to avoid tail or head on empty list?
11:28:59 <EvanR> use pattern matching to decide what to do in case of empty
11:29:37 <irc27313> can we use Maybe for that?
11:29:47 <EvanR> that just pushes the problem down the line
11:30:07 <EvanR> but sure, you can do headMay :: [a] -> Maybe a
11:30:41 <irc27313> > headMay []
11:30:42 <lambdabot>  error:
11:30:42 <lambdabot>      Variable not in scope: headMay :: [a0] -> t
11:30:50 <EvanR> imagine try to "solve" the same issue for Maybe.  fromJustMay :: Maybe a -> Maybe a
11:31:02 <fragamus> EvanR: that is enlightening
11:31:34 <irc27313> so headMay is not defined yet?
11:31:37 <EvanR> fragamus: and by analogy, duplicate is using the most trivial summary, the world is returned as is. So duplicate gives you a world of worlds
11:31:45 <refusenick> Athas: That's what I meant. Deleting packages and other features like pip or quicklisp would be nice for a Cabal frontend, perhaps. The v2-* commands do get most of the way there.
11:32:19 <fragamus> Does the community prefer extend over duplicate
11:32:21 <refusenick> (Cabal is already pretty nice)
11:32:53 <EvanR> i'm not sure there even is a Comonad community
11:34:20 <MarcelineVQ> It just depends what's more efficient to write for your datatype I would guess since extend can be written using duplicate
11:34:55 <MarcelineVQ> kind of like how Applicative has <*> and liftA2 in it
11:35:09 <EvanR> whoa really
11:35:19 <MarcelineVQ> yebra
11:38:43 <EvanR> i still haven't figured out a dual analogy for Monad
11:39:21 <MarcelineVQ> refusenick: If you're asking about use though you can use the same sort of reasoning we use for >>=/join, use whatever fits better in the code you're writing
11:39:33 <MarcelineVQ> EvanR: what do you mean there
11:40:11 <EvanR> extend is like generalized convolution filter
11:40:47 <EvanR> world of summaries
11:41:15 <EvanR> maybe "bind is like dual of this" goes nowhere
11:41:50 <EvanR> category theory is a red herring
11:43:05 <refusenick> I see a lot of recommendations for push-pull FRP like Reflex. Are there arguments in favor of arrowized nowadays?
11:43:23 <EvanR> reactive is push-pull FRP
11:43:45 <EvanR> paper on it is almost called that
11:43:45 <fragamus> When I refer to the comonad community I am referring to Ed Kmett
11:43:52 <EvanR> lol
11:44:45 <refusenick> EvanR: I skimmed conal's original paper on push-pull a while back.
11:45:01 <refusenick> (this is my 2nd time taking a look at Haskell)
11:47:35 <sm> refusenick: to uninstall a package, it's stack exec -- ghc-pkg unregister PKG, and maybe the same with cabal (my cabal fu is out of date)
11:48:05 <sm> that doesn't reclaim disk space though. That's something stack/cabal/ghc-pkg aren't yet good at
11:48:24 <f-a> do you need to uninstall with new- - oh yeah disk space, good reason
11:48:48 <evelyn> just nuke your ~/.stack every few months :>
11:48:54 <f-a> hehe
11:49:04 <sm> that's been the answer since I started haskelling.. 11 years ago ? :)
11:49:23 <evelyn> with the nix integration it seems to like rebuilding a lot anyway
11:50:08 <sm> "just nuke your .ghc, .cabal, or .stack". We can't really safely say that alas because there's always a bit of config there you might want
11:50:32 <irc27313> why to do auto complete for haskell is so difficult to editor?
11:50:51 <evelyn> I bet someone has solved this problem already in 8 different ways.
11:50:54 <irc27313> I just want a auto complete without language server
11:51:52 * sm tries to answer irc27313's question: because it requires first-class support from the compiler, which hasn't been a priority
11:52:35 <evelyn> I had good results with emacs+dante but it was quite nasty to set up.
11:52:42 <refusenick> irc27313: What editor do you use?
11:52:44 <MarcelineVQ> ghci has :complete editors just need to use it
11:53:03 <irc27313> vim and emacs
11:53:17 <refusenick> I'm using Emacs + haskell-mode + lsp-haskell + ghcide. It's remarkably snappy.
11:53:30 <refusenick> I'm just trying to tell flycheck that I don't use Stack.
11:53:41 <refusenick> Any particular reason not to use LSP?
11:53:56 <irc27313> I don’t like to compile lsp or company-mode or HIE
11:53:57 <sm> not if it works!
11:54:03 <MarcelineVQ> refusenick: people sometimes have trouble getting hie set up
11:54:04 <irc27313> hsdev ghc-mod blabla
11:54:04 * sm makes a note to try that combo
11:54:30 <refusenick> I just globally ran "cabal v2-install ghcide"
11:54:43 <refusenick> (a stripped-down version of HIE, AFAICT)
11:54:55 <irc27313> ghcide need to compile?
11:55:00 <sm> irc27313: those are past attempts which were hard to maintain, you should probably focus on ghcide now
11:55:11 <refusenick> It took some time to compile (potato X200), but it wasn't horrible.
11:55:18 <yushyin> all code needs to compile if you want to use the executable?
11:55:39 <refusenick> I think Cabal's new Nix-style management means you only need to install it once.
11:55:44 <sm> yushyin: what if you compile with -fdefer-type-errors ?
11:55:49 <irc27313> yeah, executable
11:56:00 <sm> (or is that just for GHCI ?)
11:56:07 <yushyin> sm: psst! :)
11:56:21 <irc27313> compiling takes too much time
11:56:34 <irc27313> such like on windows
11:56:51 <irc27313> or archlinux what a distro
11:56:57 <sm> irc27313: the practical easy solution for now is use ghcid
11:57:09 <refusenick> Ah, Windows might be a different story. I run on Void Linux, which is pretty good about not pulling in too many packages at once.
11:57:24 <yushyin> yeah, ghc is particularly slow ^^
11:57:49 <refusenick> Cabal should work the same, though (at least across Linux distros)
12:00:19 <irc27313> ghcide provides binary package to install?
12:00:41 <sm> no
12:01:02 <f-a> irc27313: it is simple and quick enough to install via cabal new-install or stack
12:01:15 <f-a> even on my 32bit CPU
12:01:22 <dsal> :t listToMaybe -- irc27313 
12:01:23 <lambdabot> [a] -> Maybe a
12:01:28 <refusenick> It really doesn't take that long to compile. It 10 minutes or so, maybe less.
12:01:42 <refusenick> I set it to run, go up to do something, and it was finished when I came back.
12:01:59 <refusenick> it took 10 minutes or so*
12:02:34 <evelyn> I don't really like installing standalone programs through stack as it's better for projects and upgrades are a pain... and it feels like things get sort of stale without me doing anything
12:02:35 <sm> on non-windows, you could use nix, https://github.com/hercules-ci/ghcide-nix#1-use-cachix-to-avoid-compilation-optional-if-you-like-compiling-for-2h
12:02:37 <irc27313> > listToMaybe []
12:02:39 <lambdabot>  Nothing
12:03:05 <sm> evelyn: I don't find that, I use stack for global installs (of apps) all the time
12:03:07 <irc27313> > listToMaybe [3]
12:03:10 <lambdabot>  Just 3
12:03:28 <dsal> > tail []
12:03:31 <lambdabot>  *Exception: Prelude.tail: empty list
12:04:01 <dsal> > drop 1 []
12:04:03 <lambdabot>  []
12:04:51 <irc27313> > listToMaybe [2,3]
12:04:53 <lambdabot>  Just 2
12:05:20 <irc27313> I will try ghcide
12:05:28 <dsal> > liftA2 (,) listToMaybe (drop 1) [1..5]
12:05:30 <lambdabot>  (Just 1,[2,3,4,5])
12:06:13 <irc27313> what about windows?
12:06:19 <sm> NO
12:06:25 <dsal> drop windows
12:06:32 <EvanR> as in "I don't do them"
12:06:37 <EvanR> but seriously ...
12:06:38 <sm> just kidding. :-) No, nix doesn't work for windows
12:13:21 <evelyn> that will apparently need changes with nix to work with wsl
12:23:42 * hackage reflex-dom-core 0.5.2.0 - Functional Reactive Web Apps with Reflex  https://hackage.haskell.org/package/reflex-dom-core-0.5.2.0 (abrar)
12:31:14 <srid> What's a good way to represent a number type that can takes values only in the range of [0...n]? It should be enforced at the type-level. 
12:31:25 <srid> n is typically < 100
12:31:31 <hpyCdr> is using mconcat the most memory efficient, or should I e.g. check out foldl' ?
12:31:38 <EvanR> Fin 99 ...
12:31:56 <EvanR> er Fin 100
12:32:53 <EvanR> is it really a number type, what happens when you add them
12:33:26 <srid> In my case, I'd be defining two types with n=59 and n=23, to represent minute and hour mark in a day, respectively
12:33:36 <monochrom> Perhaps it's just an enum type, no adding.
12:33:37 <srid> 00h00 to 23h59
12:34:05 <srid> I'm writing a time tracker, and I do not care about timezones, days, etc... - just specific clock hand positions in a day
12:34:23 <lortabac> srid: maybe you can use the refined package (I have never used it but I've heard of it)
12:34:30 <EvanR> hmm.. wouldn't 1 number that must be >= 0 and < 86400 be simpler
12:34:41 <EvanR> then minute hour seconds etc are derived from it
12:35:02 <EvanR> oh
12:35:32 <monochrom> Or 1440 if only down to minutes.
12:35:44 <monochrom> Wait, is it 1440 or is it 2880? :)
12:35:55 <EvanR> modem speeds
12:36:02 <srid> Yes, [0..1440] too will work (I do not care about second-level precision) though it kind of looks 'low-level'
12:36:50 <srid> lortabac: interesting, reading...
12:36:52 <EvanR> 0..1439, would be a shame to go through all this trouble and be off by 1
12:37:05 <monochrom> "supports leap minutes" >:)
12:37:17 * EvanR rage quits
12:38:47 <EvanR> smart constructor pattern to verify value at construction time is the simplest way and technically satisfies "enforced at type level" (outside the module)
12:39:10 <EvanR> inside the module no one can stop you from being off by 1 anyway
12:39:16 <srid> well, there will be calculation on the hh:ss values (like diff'ing, then summing durations). 
12:39:38 <srid> to nip any bugs in the bud, it'd be better to have the compiler compile at any potential violations
12:39:51 <EvanR> even better reason to implement it using during-past-midnight in the first place
12:40:01 <EvanR> duration-
12:40:13 <monochrom> No type-level overflow checks when you add or subtract.
12:40:14 <EvanR> hh:ss being a pretty printing task
12:41:09 <lortabac> a smart constructor is the simplest way IMHO. Haskell's type system is not powerful enough to express this kind of invariants easily
12:41:35 <monochrom> Or rather, no add or subtract that are type-level checked.
12:41:45 <hpyCdr> how to I pass parameters to the program started via stack run?
12:41:47 <srid> lortabac: why smart constructor vs refined types?
12:41:59 <srid> > refine @(LessThan 60) @Int 40)
12:42:01 <lambdabot>  <hint>:1:23: error: parse error on input ‘@’
12:42:01 <hpyCdr> is stack run --foo passing foo to stack or the compiled program?
12:42:22 <monochrom> likely to stack
12:42:40 <hpyCdr> I only find examples for stack exec online
12:43:10 <MarcelineVQ> stack run --help   "Usage: stack run [-- ARGS (e.g. stack run -- file.txt)]"
12:43:16 <lortabac> hpyCdr: the program options have to be put after --
12:43:51 <monochrom> Discovery skills are more important than knowledge.
12:45:22 <lortabac> srid: with Fin or refined types you make your life more complicated for a small gain
12:47:08 <dsal> srid: Hey, you seem to have the same problem I do right now.  :)
12:48:04 <hpyCdr> monochrom, yeah :/
12:48:20 <EvanR> type level problem of the form "can only be between 0 and n-1" immediately implies there is much more about the problem we need to know to get that precise
12:48:34 <svipal> sup
12:48:49 <EvanR> and if the as yet unknown problem changes slightly, all the work might be lost
12:49:04 <EvanR> dependent types fear uncertainty and doubt!
12:49:10 <monochrom> Generally true of any request for data structures.
12:49:16 <srid> lortabac: dsal - so using `refined` my code looks like this: https://gist.github.com/srid/5a2db21d1db09621b1896418ea3e08c2
12:49:46 <srid> as you can see it is impossible pass to `duration` illegal values. i like that
12:49:55 <srid> *to pass to
12:50:14 <monochrom> People speak and think naïvely like "I need sets" "I need numbers" "I think I need strings" and, always, upon closer scrutiny they never need the full power of sets, numbers, strings.
12:50:17 <srid> i think `mkHour` is called a 'smart constructor'?
12:50:17 <EvanR> smart constructor has the same feature
12:50:22 <srid> ^
12:50:34 <srid> a smart constructor returns dumb types, no?
12:50:40 <DigitalKiwi> i have a (potentially huge) favor to ask. i would like to at some point be able to use https://github.com/jgarff/rpi_ws281x from haskell (if you check the link there are several bindings to it in other languages). i'm not even sure of all of the ways to use c libs from haskell... would someone be able to look at it and estimate how much of a pita this would pose for me to attempt?
12:50:47 <srid> what would be the return type of a smart constructor?
12:50:50 <Athas> monochrom: they even say things like "I need booleans!", but no.  They often do not!
12:50:55 <EvanR> Minute, Hour
12:51:10 <EvanR> newtype Minute = MkMinute Int
12:51:10 <dsal> Athas: True
12:51:19 <EvanR> (MkMinute hidden)
12:51:38 <DigitalKiwi> i'm not even sure where to start if i were to try :<
12:51:39 <srid> but, smart constructor is not the only constructor out there. somewhere in the code a buggy function can directly create it using `MkMinute 999`
12:51:48 <EvanR> no it can't
12:52:00 <monochrom> That "somewhere" is only in your own secret module.
12:52:02 <EvanR> because you didn't export MkMinute. Read about the smart constructor pattern
12:52:07 <srid> so you have to hide MkMinute, and not export it, while keeping the module where it is defined small enough in scope.
12:52:17 <monochrom> So hide.
12:52:27 <EvanR> yes and the module constructing a Minute is a couple lines long
12:53:13 <srid> But, is there any advantage to using smart constructor in my case. There is not much difference between `unMkMinute x` and `unrefine y`, but the latter is arguably better inasmuch as it is a general function.
12:53:47 <EvanR> if all you do is unwrap it and go back to unrestricted-ville, might as well use the simpler solution
12:54:03 <EvanR> if you need to do real operations on the restricted type, smart ctor still might work
12:54:36 <EvanR> the real difference seems to be if there is advanced info at the actual type level that you need to depend on
12:54:39 <EvanR> Hour and Minute has none
12:55:37 <EvanR> here's an example where crazy types might be needed: you have a 0..n and 0..m and you want to add them to get a 0..m+n
12:55:49 * srid feels like he should just drop the hour/min distinction and use [1..1440]
12:56:42 <srid> Actually, if m+n >= 60, I'd do one calculation, and if m+n < 60, I'd do another. Type-level calculations?
12:56:45 <EvanR> in which case you will probably immediately need to think carefully about all the ways it makes sense to use a 0..m+n
12:57:18 <EvanR> splitting on whether m+n is more or less than 60 is now getting non trivial
12:57:43 <EvanR> you'll need a type talking about ordering
12:57:44 <srid> type MinOfDay = Refined (LessThan 1440) Natural
12:58:20 <monochrom> What happens when I request 1439 + 1439?
12:58:39 <srid> there is also http://hackage.haskell.org/package/facts-0.0.1.0/docs/Data-Refined.html from the fellow who maintains megaparsec
12:59:00 <EvanR> also, arithmetic on hours and minutes is exactly the thing using "number of seconds" avoids
12:59:02 <srid> monochrom: for timetracking, only substraction operation is allowed (to compute 'duration' between two time slots)
12:59:16 <srid> addition happens on unbounded 'duration' values
12:59:21 <dmwit> What happens when I request 9 - 10?
12:59:25 <srid> type Duration = Natural
12:59:27 <monochrom> Yeah, that.
12:59:37 <srid> It should error out. 
12:59:47 <EvanR> > 9 - 10 :: Natural
12:59:49 <lambdabot>  *Exception: Natural: (-)
12:59:50 <EvanR> done
12:59:52 <monochrom> Also inb4 <monochrom> People speak and think naïvely like "I need sets" "I need numbers" "I think I need strings" and, always, upon closer scrutiny they never need the full power of sets, numbers, strings.
13:00:09 <srid> So, type WorkItem = Refined ??? (MinOfDay, MinOfDay) -- where ??? refines it so that fst < snd
13:00:36 <EvanR> i will be impressed if refined can do that much
13:00:39 <monochrom> OK so run time errors are still possible?  So why bother with static checking?  Java-like?
13:01:00 <srid> not if we define WorkItem with that refinement, no
13:01:30 <monochrom> Good luck with that.
13:01:46 <srid> I should note that the 'input data' for all this comes from plain text files, which I parse using megaparsec, wherein all these smart constructors will be utilized (and error reporting happen). Beyond that 'boundary', I should not expect runtime errors.
13:02:23 <monochrom> Because now basically every number has its own type.  4 has type Refined 4.  10 has type Refined 10.  Because without that much static precision you can't statically check subtractions.
13:02:33 <srid> so I have `Parser WorkItem`, and aside from parser error there should not be runtime errors (ideally)
13:03:27 <monochrom> And if 4 has type Refined 4, 10 has type Refined 10, n has type Refined n for all n, then you don't have user input.
13:03:53 <monochrom> And if you don't have user input, you have no program.  "Vanishes in a puff of logic."
13:03:57 <srid> if it turns out that defining that `WorkItem` is impossible, I can always redefine it like this: `type WorkItem = (MinOfDay, Duration)` and have the parser error out if the order is bad
13:03:57 <EvanR> subtraction of naturals with dependent types, and potentially inapplicable side tangent... (-) :: (m:Nat) -> (n:Nat) -> (m `GT` n) -> Nat
13:04:11 <monochrom> Well, no interactive program.  You can have a static program.
13:05:56 <DigitalKiwi> how did people know the results of programs before IO
13:06:43 <monochrom> They had lazy input strings and lazy output strings.
13:07:09 <EvanR> [Response] -> [Request] or some nutty thing
13:07:16 <monochrom> "main :: String -> String" back then.  (Today's "interactive")
13:07:29 <monochrom> Err, what EvanR says. I erred.
13:07:41 <DigitalKiwi> oh
13:08:01 <EvanR> make sure you don't look at a response before you make a request, i guess
13:08:11 <monochrom> Yeah
13:08:32 <monochrom> Now trying enforcing that statically! >:)
13:08:35 <dmj`> no IO, no problems
13:08:41 * hackage acid-state 0.16.0 - Add ACID guarantees to any serializable Haskell data structure.  https://hackage.haskell.org/package/acid-state-0.16.0 (JeremyShaw)
13:08:45 <DigitalKiwi> every program is a nop!
13:08:48 <dmj`> mo' IO, mo' problems
13:09:31 <monochrom> Eh, I can't argue against that, but I still believe that those problems are worth solving.
13:09:55 <dmj`> runtime is overrated
13:10:05 <dmj`> compile time is the new runtime
13:10:16 <hpyCdr> when I derive instances such as Monoid on a newtype, is the implementation "overhead" strict, or do I maybe introduce lazyness by deriving?
13:10:26 <DigitalKiwi> throw an error with your result
13:10:57 <monochrom> @quote monochrom runghc
13:10:58 <lambdabot> monochrom says: just add #! /usr/bin/runghc to your haskell file. then type errors occur at runtime only.
13:11:42 <EvanR> doom at the type level, each type error is getting blown up by a fireball. Winning is compiling fully
13:11:47 <monochrom> The "overhead" is strict and you do not want to make it lazy.
13:12:01 <DigitalKiwi> no excuse to use python with that trick
13:12:17 <monochrom> newtype is strict precisely because that's how to get zero overhead.  lazy adds overhead.
13:12:42 <monochrom> or rather, newtype adds no extra laziness.
13:12:50 <monochrom> or rather, newtype adds no extra non-strictness.
13:13:17 <DigitalKiwi> rephrase; can't make excuses to use python anymore since can you use that trick with haskell
13:13:31 <DigitalKiwi> you can*
13:13:38 <DigitalKiwi> someday i will learn to type again
13:22:42 * hackage reflex-dom 0.5.2.0 - Functional Reactive Web Apps with Reflex  https://hackage.haskell.org/package/reflex-dom-0.5.2.0 (abrar)
13:36:22 <srid> EvanR: looks like you have a reason to be impress (cf. `Via` composition): https://markkarpov.com/post/smart-constructors-that-cannot-fail.html
13:36:28 <srid> *impressed
13:48:18 <EvanR> srid: so how does all that relate to subtracting two numbers that you know can be subtracted (somehow)
13:49:51 <nshepperd1> monochrom: you do user input by getInput :: IO (Some Refined), where Some is a newtype that wraps an existential
13:50:25 <nshepperd1> Then you have new and exciting problems with proof propagation
13:52:20 <monochrom> or property propagation.
13:52:45 <nshepperd1> (also, why not let durations be negative?)
13:52:57 <chreekat> refusenick: you asked a question about storage a bit earlier --  i actually think there's interesting questions there. Like, could we abstract over the persistence layer for the rts the way we can abstract over execution strategies (with Parallel Haskell)? The heap is just that - a persistence layer. One designed for a particular set of use cases. I wonder if there are others. Distributed Haskell?
13:53:50 <EvanR> since compact regions can be stored and restored i wonder if that helps a persistence ?
13:54:15 <oo_miguel> How can I tell cabal to use -O2 via my cabal file?
13:55:30 <chreekat> oo_miguel: https://www.haskell.org/cabal/users-guide/developing-packages.html#pkg-field-ghc-options
13:56:42 * hackage ClustalParser 1.3.0 - Libary for parsing Clustal tools output  https://hackage.haskell.org/package/ClustalParser-1.3.0 (FlorianEggenhofer)
13:57:11 <oo_miguel> chreekat: aah thank you. I was trying to use "optimization:"
13:57:57 <geekosaur> oo_miguel, note that this will iirc be rejected by hackage/stackage, since that's an installer's choice normally.
13:58:18 <oo_miguel> geekosaur: oh ok. thank you for pointing this out
13:59:17 <geekosaur> cabal.project.local I think is preferred for specifying such options
14:04:01 <monochrom> in which case, it goes like "optimization: 2"
14:04:12 <monochrom> that's right it doesn't have to be a boolean!
14:06:03 <srid> EvanR: now I can define the constraint that h1:m1 should be <= h2:m2 at the type-level: https://gist.github.com/srid/5a2db21d1db09621b1896418ea3e08c2#file-time-duration-refined-hs-L34-L41
14:06:58 <quartzshard> o/, got a noob question for anyone listening:
14:15:14 <EvanR> srid: it looks like a very elaborate smart constructor
14:15:25 <EvanR> and there's no Via
14:16:24 * srid updated the Gist with simplified types, and leaves to cook food
14:16:39 <EvanR> and your use of subtraction doesn't seem to be checked
14:17:10 <EvanR> (type checked)
14:20:11 <EvanR> TimeRange is basically a pair of numbers wrapped in something that enforces a construction check. Then you can unpack the pair later and use unrestricted
14:21:29 <EvanR> it would be even smarter to put the "difference between my numbers using just (-)" inside the trusted code base
14:22:07 <EvanR> your use site could easily mix up the c1 and c2 getting an error
14:22:20 <gobby> has anyone here ever used servant+serverless+aws apigateway?
14:22:47 <gobby> having issues with a POST request with a JSON payload
14:28:11 <Lycurgus> prolly authentication/permissions
14:28:49 <Lycurgus> the auth that comes with servant is like a starter
14:29:10 <Einzige> Hello?
14:29:27 <Lycurgus> min
14:29:31 <Lycurgus> *moin
14:30:18 <Einzige> I've never used an IRC channel before, are any of my messages coming through?
14:30:37 <ChaiTRex> Einzige: Yes.
14:30:59 <Einzige> Hello
14:31:09 <Einzige> Kind of a quiet chat 
14:31:36 <gobby> Lycurgus is like a starter?
14:32:25 <Lycurgus> meaning you need to do stuff to make it work across AWS security, which you always do
14:33:11 <gobby> strange because I've gotten simple GEt and POST requests to work.
14:37:33 <refusenick> chreekat: I've seen Cloud Haskell, but don't know much about it. Haskell and BEAM languages have very different memory models, but arrowized FRP looks a lot like something which could be compiled to the BEAM and grant Haskell the hotswapping abilities of Erlang and Elixir.
14:38:15 <refusenick> It also appears that Tidal did, in fact, switch to FRP as part of its hotswapping model: https://dl.acm.org/citation.cfm?doid=2633638.2633647
14:39:04 <EvanR> .oO( compiling to categories )
14:39:08 <refusenick> (the circuits of AFRP vaguely resemble message passing between actors to me)
14:39:21 <EvanR> oh man, they do not look like that to me
14:40:00 <EvanR> any actor may send any message to any other actor simply by having a reference to their mailbox
14:40:07 <refusenick> EvanR: Does compiling to categories really mean that it can be ported everywhere? Doesn't it still require a full graph rewrite architecture like GHC's runtime to execute?
14:40:23 <EvanR> arrow circuits have no names are generally quite complicated to get something like that to happen
14:40:53 <EvanR> refusenick: no, it has not much to do with graph reduction implementation of lazy languages
14:41:30 <EvanR> also arrow circuits are fixed, actors are dynamic
14:41:48 <refusenick> I suppose a better way to put it would be that they can be implemented using actors.
14:42:05 <EvanR> well, actor model is vague enough that it can implement anything
14:42:22 <refusenick> Technically, all Turing complete languages can do that, no?
14:42:35 <refusenick> I'm thinking about what it would take for Haskell to run on BEAM.
14:42:57 <EvanR> e.g. (2 + 2) / (3 - 4) can be implement with actors, the / sends a message to (2+2) and (3-4), which in turn send messages to 2 2 3 and 4
14:43:33 <refusenick> Right, it's basically asynchronous fexprs.
14:43:36 <EvanR> OOP can be implemented with actors, every statement sends a message to the named object, waits for a response, goes to the next statement
14:44:26 <EvanR> (synchronous)
14:44:40 <conal> refusenick: A category (as in compiling-to-categories) could be an otherwise noncomputable semantic ability like differentiation or interval analysis, or it could be an alternative execution model like FPGA. Also combinations, like massively parallel exact differentiation in hardware.
14:45:38 <refusenick> EvanR: Actors are asynchronous, that's why they're nondeterministic (results depend on order of message arrival)
14:46:12 <EvanR> you can implement classic sequential programming by having every function by an actor, waiting for everything it calls to respond before continuing
14:46:17 <EvanR> i.e. don't use the asynchronous part
14:46:38 <refusenick> Sure. That's basically the core of Hewitt's critique of concurrent logic programming.
14:46:38 <EvanR> basically, actors always work but don't necessarily gain anything
14:47:07 <refusenick> https://en.wikipedia.org/wiki/BEAM_(Erlang_virtual_machine)
14:47:40 <EvanR> there are languages and interpretations that fit problems better
14:47:46 <refusenick> conal: It sounds as though that could be used to map Haskell to the BEAM's operational semantics.
14:48:19 <conal> refusenick: yeah. it might well be.
14:48:33 <refusenick> EvanR: Oh no no no, I'm not saying actors are an unambiguous good! It's just my understand that the BEAM is based on them as a basis for how it executes bytecode.
14:48:47 <EvanR> just responding to AFRP
14:49:21 <EvanR> while actors may do things non deterministically, FRP is suppose to be deterministic
14:49:36 <EvanR> and things can happen simultaneously
14:50:45 <refusenick> I've read as much. Just the same, you can build deterministic message-passing systems (like CSP) atop actors as a restricted case and compile them down to it. That's why I thought AFRP might be a good model for compiling Haskell to the BEAM for live coding like Erlang.
14:50:55 <EvanR> :'(
14:50:58 <conal> FRP has a simple and precise denotation (mathematical meaning). I think the actor model is operational. And yes, FRP's denotation is deterministic and as temporally continuous. Sounds like very different beasts.
14:52:08 <conal> refusenick: what are you looking to get out of BEAM? hot-swapping? inter-process communication?
14:52:16 <refusenick> hotswapping, mostly
14:52:27 <conal> got it.
14:54:45 <Platoshusband> What exactly is stack used for?
14:55:05 <Axman6> it's a build tool
14:55:56 <Platoshusband> Ah okay
14:57:13 <jackdk> starting flamewars ;-)
14:57:25 <jackdk> but seriously, some people (typically those building applications as opposed to libraries) get a lot of value out of having "consistent snapshots of the hackage universe". But IMHO it was more compelling when it first came out - cabal-install was worse back then and stack's competition was a kick up the rear that it needed
14:58:28 <jackdk> I was personally turned off it after having to clean/rebuild a lot when working on multi-repo projects, and it makes me a bit sad that it doesn't (afaik) yet support backpack, even though I don't use that myself
14:58:56 <jackdk> I also dislike its use of hpack (yes I know it's optional), because I dislike yaml
14:59:06 <jackdk> so on balance, it doesn't bring a lot of value to me
14:59:16 <Platoshusband> the book i'm using is recommending me to install stack
14:59:20 <EvanR> tell us how you really feel!
15:00:09 <Platoshusband> The worst part about doing anything computer science related has to be installing things :d
15:00:26 <Axman6> basically all of stack's value comes from the snapshots, which gives a lot of value if you're developing applications and want to be able to choose when you're ready to upgrade libraries
15:00:27 <EvanR> that's why i switched to doing it all on paper
15:00:54 <Platoshusband> You must be the person that devises all the programming tests at my local university 
15:02:05 <Platoshusband> snapshots?
15:02:37 <jackdk> the "lts-x.yy" you see in a stack.yaml, which implies a ghc version and universe of packages
15:02:46 <jackdk> (and specific versions of each)
15:03:24 <Platoshusband> ah
15:08:49 <svipal> stack is very quick to install
15:08:56 <svipal> and will save you a lot of headaches
15:10:41 <jackdk> so is cabal, but I think "go with your book" is probably the most productive recommendation for a new perso
15:10:43 <jackdk> n
15:13:03 <EvanR> in general i've noticed new persons using the most advanced tools first, then having more advanced problems
15:13:05 <srid> EvanR: I ended up going with the smart constructors approach :-P  https://www.irccloud.com/pastebin/B6JIPvQd/time-duration.hs
15:13:16 <EvanR> nice
15:20:37 <hpyCdr> srid, what's void good for there?
15:20:42 <hpyCdr> void $ validate...
15:20:56 <srid> yea i don't like it. it validates and ignores the result (while still propagating the error)
15:21:09 <srid> because the result will be same as the argument anyway
15:21:22 <srid> cf. https://www.reddit.com/r/haskell/comments/dsmq38/parse_dont_validate/
15:22:31 * EvanR puts on asbestos underwear and clicks
15:23:33 <srid> This looks slightly better https://www.irccloud.com/pastebin/ZnZhtp7u/a.hs
15:23:36 <hpyCdr> I'd return pure () in the validate methods in this case
15:24:45 <hpyCdr> *in validateLessThan
15:24:58 <srid> I wonder if haskellers serious use doctest, because I'm feeling lazy to add sources for tests.
15:25:02 <srid> *seriously
15:27:29 <EvanR> alright the title of the blog post is misleading!
15:27:46 <EvanR> the thesis is really "parsing *is* validating"
15:28:16 <EvanR> and validating a second time is redundant
15:40:50 <sm> srid: I use it.. but rarely, because it's so slow
15:41:13 <sm> which is a great pity
15:44:40 <sm> <Axman6> basically all of stack's value comes from the snapshots - there's a bit more to it than that
15:48:18 <srid> fruits of labour on time: https://github.com/srid/modus/pull/3/files
16:05:32 <EvanR> would this be cool. The type of something is too disturbing to type out manually, but happens to equal the type of `f x', where f's type was inferred.
16:05:54 <EvanR> but no way to annotate it as such
16:06:03 <EvanR> would it be cool to annotate it as such
16:06:33 <ChaiTRex> EvanR: You can probably write const whatever ((value, f x) :: (a, a))
16:10:56 <ChaiTRex> EvanR: Or, if you just want to evaluate the value: fst ((value, f x) :: (a, a))
16:13:13 <EvanR> more like, want to use the type in other annotations without having to write it out
16:13:31 <EvanR> so a synonym that is "type of that thing over there, ask the inferencer)
16:14:09 <EvanR> type A = type of foo
16:14:40 <zyeri> Is it possible to limit the amount of memory stack uses to build a project? I'm running into OOM issues when I try to build haskell-ide-engine.
16:19:50 <lyxia> that's a rather frequently asked question. I don't know the answer, but maybe there's something on the issue tracker of stack or hie?
16:22:40 <AWizzArd> zyeri: there is a docker image by the user/organization `fpco` that includes Stack. You could mount your sources into that image and build your project inside a container, which you give only limited ram access.
16:24:11 * hackage semialign-extras 0.1.0.0 - Extra functions for working with Semialigns  https://hackage.haskell.org/package/semialign-extras-0.1.0.0 (qfpl)
16:29:17 <Axman6> jackdk: you mad lad, I can't believe you've done this
16:43:27 <jackdk> Axman6: ?
16:43:53 <jackdk> couldn't make the rewrites go, so I'll probably ask for help on -cafe in the release announce
16:44:02 <Axman6> I assume that was you releasing semialign-extras?
16:44:07 <jackdk> yes
17:00:42 * hackage primitive-foreign 0.1.1 - using the `Prim` interface for the FFI  https://hackage.haskell.org/package/primitive-foreign-0.1.1 (chessai)
17:05:41 * hackage massiv-io 0.1.8.0 - Import/export of Image files into massiv Arrays  https://hackage.haskell.org/package/massiv-io-0.1.8.0 (lehins)
17:27:59 <djanatyn> hmm, does typed-process have a way to append to the current environment? i only see setEnv and setEnvInherit, which don't work together: https://hackage.haskell.org/package/typed-process-0.2.6.0/docs/System-Process-Typed.html
17:29:48 <djanatyn> also thanks for all the help with Contravariant, I was able to get up and running with co-log-core today: https://gist.github.com/djanatyn/5fbed3dad7e50edc8ee12006bfc5441d
18:01:12 * hackage git-annex 7.20191114 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-7.20191114 (JoeyHess)
18:09:59 <jusss> dict in Python, structure in C, map in Java, data constructor in Haskell, they're similar?
18:10:54 <shachaf> No.
18:11:16 <jusss> reason?
18:12:13 <wikiemol> Is there a version of show that doesn't escape everything?
18:16:02 <sm> wikiemol: maybe you want putStrLn ?
18:17:50 <sm> zyeri: try -j1
18:19:17 <wikiemol> sm I tried that, but I am using show recursively in my instance.. so I am getting weird stuff (at least I think thats the reason)
18:20:01 <sm> ah.. don't show your show
18:20:30 <wikiemol> sm Why doesn't that work?
18:20:59 <wikiemol> I am trying to pretty print a recursive data structure
18:21:18 <wikiemol> basically I am trying to pretty print an Abstract Syntax Tree
18:32:25 <wikiemol> nvm I was just being dumb
18:39:50 <sm> wikiemol: for that I recommend eg pretty-show
18:40:06 <sm> (on hackage)
18:48:39 <jusss> there's a do-notation, the context is ActionM, and there's an IO [Result] in the do-notation, how I can get the [Result] from IO ?
18:49:07 <jusss> 'cause the context is ActionM, so I can't use <- to get [Result] from IO [Result]
18:49:14 <jusss> unless the context is IO
18:49:15 <ChaiTRex> jusss: You usually shouldn't take the value from IO. Instead, bring the functions you want to use on the value into IO.
18:49:50 <jusss> ChaiTRex: how ?
18:50:54 <jusss> how I can put that function into IO?
18:53:21 <ChaiTRex> jusss: That's more general advice than particular to ActionM. Looks like ActionM has liftAndCatchIO :: IO a -> ActionM a
18:56:22 <jusss> ChaiTRex: liftIO = return when the type is an instance of MonadIO and Monad?
18:56:50 <jusss> no
18:59:36 <ChaiTRex> jusss: No, specifically liftAndCatchIO from Web.Scotty.
19:01:55 <Guest_14> I have some issues downloading ghcup on MacOS, it says `configure: error: C compiler cannot create executables`. Any ideas how to solve?
19:02:19 <koala_man> can your C compiler create executables?
19:02:30 <ChaiTRex> Guest_14: Do you have gcc installed?
19:03:59 <Guest_14> yeah, I have gcc
19:04:23 <ChaiTRex> Guest_14: Is it on your PATH and everything? Does `gcc --version` do anything in a Terminal window?
19:04:57 <Guest_14> `Configured with: --prefix=/Library/Developer/CommandLineTools/usr --with-gxx-include-dir=/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/4.2.1Apple clang version 11.0.0 (clang-1100.0.33.12)Target: x86_64-apple-darwin18.6.0Thread model: posixInstalledDir: /Library/Developer/CommandLineTools/usr/bin`
19:05:32 <Guest_14> ^ it shows this for `
19:05:40 <Guest_14> `gcc -v`
19:06:10 <ChaiTRex> Guest_14: Not sure then, sorry.
19:06:24 <ChaiTRex> Guest_14: Usually the solution is to install the Xcode command line tools, but it seems you've done that.
19:07:09 <Guest_14> yeah, I was wondering the same thing. Should I uninstall commandline tools
19:07:18 <Guest_14> and retry
19:07:51 <ChaiTRex> Guest_14: Perhaps. I'm not sure why it thinks the C compiler can't create executables.
19:08:05 <ChaiTRex> Guest_14: It's not exactly the most informative error message.
19:08:41 <ChaiTRex> Guest_14: Is your macOS version old?
19:09:46 <Guest_14> hmm, that might be the case
19:10:18 <ChaiTRex> Guest_14: Somebody in here was having trouble with their GCC version being too old because Xcode's best version for that macOS version was too old.
19:16:44 <maerwald> if anyone has more information on requirements on macOS please feel free to add to https://gitlab.haskell.org/haskell/ghcup/blob/master/.requirements/ghc/darwin
19:17:54 <glguy> maerwald: Did something change?
19:18:43 <maerwald> Don't think so, but it doesn't seem to work for all users?
19:22:11 <nineonin_> I want to concurrently fold a structure and my accumulator is a map
19:22:39 <nineonin_> what is right way to go here?
19:22:43 <nineonin_> IORef or MVar?
19:23:03 <nineonin_> all the actions will do a concurrent write
19:35:19 <glguy> phadej: What's the current state of using doctest? Should I be using cabal-doctest?
19:36:49 <nshepperd> the only way of concurrently folding i'm aware of is parallel evaluation of a monoidal summary
19:37:40 <nshepperd> that is mconcat [a,b,c,d] = (a <> b) <> (c <> d), where you can evaluate (a <> b) and (c <> d) in parallel
19:38:15 <Guest_14> thank you for helping about the MacOS stuff earlier
19:53:39 <maerwald> Guest_14: what solved it?
19:53:45 <jusss> ChaiTRex: "<ChaiTRex> jusss: You usually shouldn't take the value from IO. Instead, bring the functions you want to use on the value into IO."  IO is a Functor, we can use fmap to do that
19:55:58 <Guest_14> maerwald: Haven't solved it yet :D
20:04:15 <jusss> where's `void' defined?
20:04:21 <jusss> @hoogle void
20:04:22 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
20:04:22 <lambdabot> Data.Functor void :: Functor f => f a -> f ()
20:04:22 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
20:07:06 <Guest_14> Downloading ghcup I also have this error:
20:07:10 <Guest_14> `checking XCode version... xcode-select: error: tool 'xcodebuild' requires Xcode, but active developer directory '/Library/Developer/CommandLineTools' is a command line tools instance`
20:07:32 <Guest_14> Do you know what it means?
20:09:12 <dminuoso> Guest_14: Try `sudo xcode-select -s /Applications/Xcode.app/Contents/Developer`
20:10:21 <Guest_14> I checked `/Applications` there's no Xcode.app file there. Should I uninstall it and then reinstall
20:10:47 <dminuoso> Ah.
20:10:52 <dminuoso> Hold on
20:11:27 <dminuoso> Guest_14: Do you have just command line tools installed or the full xcode?
20:12:18 <Guest_14> full xcode
20:12:34 <dminuoso> Guest_14: Where is it installed to?
20:13:21 <Guest_14> dminuoso: I'm trying to find it right now
20:13:35 <dminuoso> Guest_14: How did you install it?
20:16:50 <Guest_14> I installed it from app store way back. I can see the app icon under Applications folder, but cannot see the `Xcode.app` file from terminal
20:17:51 <jusss> :t void (_::IO (IO ()))
20:17:55 <lambdabot> error:
20:17:55 <lambdabot>     • Found hole: _ :: IO (IO ())
20:17:55 <lambdabot>     • In the first argument of ‘void’, namely ‘(_ :: IO (IO ()))’
20:18:48 <Guest_14> checking whether the C compiler works... noconfigure: error: in `/var/folders/8w/lp0t6vv924g0gncghqw469lc0000gn/T/tmp.EhZtv68W/ghc-8.6.5':configure: error: C compiler cannot create executablesSee `config.log' for more detailsFailed to install, consider updating this script via: ghcup upgrade"ghcup --cache install" failed!
20:18:58 <Guest_14> `checking whether the C compiler works... noconfigure: error: in `/var/folders/8w/lp0t6vv924g0gncghqw469lc0000gn/T/tmp.EhZtv68W/ghc-8.6.5':configure: error: C compiler cannot create executablesSee `config.log' for more detailsFailed to install, consider updating this script via: ghcup upgrade"ghcup --cache install" failed!`
20:19:21 <Guest_14> Go that error, saying C compiler not working, the xcode part is working now
20:26:01 <dminuoso> Guest_14: Does `ls /Applications` list Xcode at all?
20:28:53 <jusss> > t :: IO Int
20:28:55 <lambdabot>  error:
20:28:55 <lambdabot>      • Couldn't match expected type ‘IO Int’ with actual type ‘Expr’
20:28:55 <lambdabot>      • In the expression: t :: IO Int
20:29:18 <jusss> t :: IO Int;  t = return 3;  fmap print t;   why it won't print anything?
20:30:09 <dminuoso> jusss: I have a question. What resource are you using to learn Haskell?
20:30:25 <jusss> dminuoso: learn you a haskll
20:31:01 <jusss> dminuoso: what's wrong?
20:31:08 <Guest_14> Okay, I just used homebrew to install it and got it to work. Thank you dminuoso
20:32:06 <ChaiTRex> jusss: fmap print t is type IO (IO ())
20:32:09 <dminuoso> jusss: It's just that you have been around for quite a while, repeatedly asking similar questions and demonstrating so much confusion..
20:32:27 <dminuoso> Guest_14: Huh? You dont need homebrew to install xcode..
20:33:01 <dminuoso> Fairly sure you don't need homebrew at all, it's more likely to cause problems down the road.
20:33:30 <dminuoso> jusss: Perhaps you might have more success picking a different learning resource?
20:34:14 <dminuoso> jusss: The technique you have been using so far, which seems to be asking questions on IRC, seems to not be very effective.
20:34:18 <jusss> ChaiTRex: yes, fmap print t :: IO (IO()), and?     it must need to be IO () ?  void $ fmap print t?
20:34:35 <Guest_14> dminuoso I did `sudo brew install ghci` and it worked
20:34:36 <dminuoso> Between all the conversations you've had, I dont see how you can really ask this question.
20:34:39 <Guest_14> just needed the compiler
20:35:12 <Guest_14> No I used that `brew install ghc cabal-install`
20:35:27 <dminuoso> Guest_14: I strongly recommend against using brew to install ghc.
20:36:02 <dminuoso> Guest_14: brew generally has poor quality builds, things can easily break if you do upgrades or macOS upgrades, you dont get the newest installation, you cant run multiple GHC versions in parallel..
20:36:31 <Guest_14> would apt-get be a better choice
20:36:32 <Guest_14> ?
20:36:59 <dminuoso> Guest_14: ghcup is a fine choice, I can only offer guidance to help you figure out why it wasn't working in the first plcae.
20:37:07 <dminuoso> Because it really should be.
20:38:16 <ChaiTRex> jusss: do { x <- t; print t }
20:38:18 <Guest_14> it kept giving me the C compiler error
20:38:26 <Guest_14> dminuoos
20:38:29 <ChaiTRex> jusss: or: t >>= print
20:38:38 <ChaiTRex> jusss: do { x <- t; print x }, rather
20:38:52 <Guest_14> dminuoso
20:39:34 <ChaiTRex> jusss: <- turns IO Int into Int, which can then be printed.
20:39:36 <dminuoso> Guest_14: What command did you use and what errors did you get exactly? Please use a gist or similar tool to display the information.
20:40:02 <jusss> > fmap (+1) $ Just 3
20:40:04 <lambdabot>  Just 4
20:41:16 <jusss> IO is not a data constructor, I forget 
20:41:41 <ChaiTRex> > do { x <- Just 3; return (x + 1) }
20:41:44 <lambdabot>  Just 4
20:42:06 <jusss> but IO is an instance of Functor, 
20:42:10 <ChaiTRex> > do { x <- return 3 :: IO Int; return (print x) }
20:42:12 <lambdabot>  <IO (IO ())>
20:42:20 <ChaiTRex> That's what fmap print does.
20:42:34 <ChaiTRex> return (print x)
20:42:40 <ChaiTRex> That's not what you want, though.
20:42:45 <ChaiTRex> You want print x
20:42:52 <haym> I thought the definition was `newtype IO a = { unsafePerformIO :: a }` :P
20:43:17 <dminuoso> haym: If we want to be really precise, that'd be accursedUnutterablePerformIO
20:43:25 <ChaiTRex> haym: No, it's something with RealWorld# or something.
20:43:29 <dminuoso> haym: unsafePerformIO has additional magic for safety
20:43:32 <Guest_14> `checking XCode version... xcode-select: error: tool 'xcodebuild' requires Xcode, but active developer directory '/Library/Developer/CommandLineTools' is a command line tools instancenot found (too old?)checking whether the C compiler works... noconfigure: error: in
20:43:32 <Guest_14> '/var/folders/8w/lp0t6vv924g0gncghqw469lc0000gn/T/tmp.FlApxMlZ/ghc-8.6.5':configure: error: C compiler cannot create executables`
20:43:45 <haym> ChaiTRex: it was a joke :)
20:43:54 <jusss> instance  Functor IO where   fmap f x = x >>= (pure . f)
20:44:14 <dminuoso> Guest_14: Can you just put it up in a gist perhaps? Just copy the command and the output you are getting.
20:44:27 <ChaiTRex> jusss: Right, and you just want x >>= f
20:44:55 <jusss> this assume IO is already a monad, so it can be a functor, that's not right
20:45:31 <monochrom> IO is already a monad.
20:45:56 <monochrom> It is also already a functor.
20:47:45 <jusss> but it should be a Functor, then Applicative, then Monad
20:48:17 <nshepperd> time is an illusion
20:48:28 <jusss> if we don't implement >>=, it may just be an Applicative
20:48:33 <monochrom> Either you made that up or someone wrote that but you read too much into the word "then".
20:49:50 <monochrom> Re-consider the fact that Haskell supports mutual recursion.
20:50:01 <monochrom> This means forward references are allowed.
20:50:11 <monochrom> This is not stupid C.
20:50:35 <haym> ^
20:51:27 <monochrom> If you write "f :: MyType -> ()" on line 1, "data MyType = MyCtor" on line 100,  "f MyCtor = ()" on line 1000, this is fine, despite all your wrong presumptions about order and dependency.
20:51:47 <monochrom> Go ahead and try it.
20:54:19 <Guest_14> jusss: NY?
21:01:18 <monochrom> Hell I should contrive a type so that its >>= calls its fmap and its fmap calls its >>= for the kick of it.
21:01:36 <monochrom> (And still productive, no hanging loop.)
21:14:18 <dminuoso> Guest_14: It's possible you might need the entire xcode for this to work.
21:14:50 <Guest_14> I have the entire xcode
21:14:56 <Guest_14> I might need to update it 
21:40:42 * hackage streamly 0.7.0 - Beautiful Streaming, Concurrent and Reactive Composition  https://hackage.haskell.org/package/streamly-0.7.0 (harendra)
21:55:48 <Axman6> % :t only
21:55:48 <yahb> Axman6: forall {a} {p :: * -> * -> *} {f :: * -> *}. (Eq a, Choice p, Applicative f) => a -> p () (f ()) -> p a (f a)
21:56:21 <jle`> my favorite prism
21:56:34 <jle`> even though slightly unlawful
21:56:39 <Axman6> I always forget its name, it's quite useful with has
21:57:22 <jle`> hm, i wonder if you can make it lawful with some combination of refined/reflection
21:57:39 <jle`> it would be awful but ... l-awful
21:58:54 <jle`> oh, actually in that form it is already lawful, i am thinking about its complement
21:59:06 <jle`> i can be comfortable calling it my favorite prism again
21:59:21 <Axman6> I want a t-shirt that says > length (1,True,"Oh no") > 1 > awful but l-awful
22:00:32 <koz_> jle`: Would that make it _co_-lawful? :P
22:01:10 <jle`> heh. it's lawful because it hides its unlawful cousin
22:04:42 * hackage cmark-gfm 0.2.1 - Fast, accurate GitHub Flavored Markdown parser and renderer  https://hackage.haskell.org/package/cmark-gfm-0.2.1 (kivikakk)
22:08:48 <EvanR>  > this means forward references are allowed
22:08:56 <EvanR> this is not stupid idris
22:19:09 <evocatus> when using Data.Aeson.Generic, how should one handle key names that have special characters (e.g. "/") in them
22:19:17 <evocatus> do I need to just manually instance FromJSON in this case
22:21:32 <jle`> you can pass in a function to genericParseJSON with an explicit record field name -> key name function
22:25:12 <evocatus> jle`: perfect, thank you
