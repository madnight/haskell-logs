00:02:36 <sicklorkin> Anyone here have experience using openapi spec (v3) to generate serverside api code?
00:25:11 <mrkuntsucker> mmmmmmm, cunt
00:27:53 <jzyamateur> I fail to understand why `runStateT (put 1 >> get) 8` returns `(1,1)` instead of `(8,8)`
00:29:04 <Cale> jzyamateur: The first thing you do is replace the current state with 1, and then you read the current state, so the result of the get is obviously going to be 1
00:29:17 <Cale> So your final state is 1, and your result is also 1
00:29:21 <jzyamateur> When state `8` is actually given, does it start executing effects from left to right?
00:29:29 <Cale> yeah
00:29:51 <jzyamateur> Ok
00:31:40 <mrkuntsucker> I support the Gay Nigger Association of America!
00:31:46 <mrkuntsucker> now EAT SPAM, MOTHERFUCKERS
00:32:19 <mrkuntsucker> X5O!P%@AP[4\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*
00:32:24 <koz_> @ops
00:32:24 <lambdabot> Maybe you meant: pl oeis docs
00:32:24 <jle`> jzyamateur: yeah, that's at least the behavior for (>>) for StateT
00:32:26 <mrkuntsucker> * * g o a t s e x * * * * g o a t s e x * * * * g o a t s e x * * * * g o a t s e x * * * * g o a t s e x * * * * g o a t s e x * * * * g o a t s e x * * * * g o a t s e x * * * * g o a t s e x * * * * g o a t s e x * * * * g o a t s e x * * * * g o a t s e x * * * * g o a t s e x * * 
00:32:30 <mrkuntsucker> !ops
00:32:33 <mrkuntsucker> @ops
00:32:33 <lambdabot> Maybe you meant: pl oeis docs
00:32:34 <mrkuntsucker> .ops
00:32:36 <mrkuntsucker> ,ops
00:32:41 <jle`> jzyamateur: and (*>), (<*), etc. as well
00:33:49 --- mode: ChanServ set +o Cale
00:33:51 <jzyamateur> Yes but it seems hard to wrap my head around "effects" so to speak. Kind of feels like "environment/context" ?
00:33:54 --- mode: Cale set +b *!*cuntsuckr@181.215.238.97
00:33:54 --- kick: mrkuntsucker was kicked by Cale (mrkuntsucker)
00:34:08 <Cale> maybe I should generalise that ban...
00:34:20 <jle`> jzyamateur: i look at it as sequencing semantic actions
00:34:24 --- mode: Cale set +b *!*@181.215.238.97
00:34:26 <jle`> "put 1" is the action of setting state to 1
00:34:32 --- mode: Cale set -b *!*cuntsuckr@181.215.238.97
00:34:33 <jle`> "get" is the action of retrieving the state
00:34:50 <jle`> so (put 1 >> get) would, semantically, be the action that first puts 1, then gets the state
00:35:14 <jzyamateur> Yeah, that makes sense
00:35:18 <jle`> thinking about "effects" in a general sense might be tricky, but thinking about "effects" for a specific monad, and its semantics, is usually simpler
00:35:33 <jle`> the semantics of StateT at least are pretty clear
00:35:41 <jle`> in specific
00:36:39 <jzyamateur> How I was thinking : (>>) is ma -> mb -> mb, so ma must be useless unless it does something like IO etc. so only mb i.e. get matters. 
00:37:07 <jle`> ah. yeah, i can see where you are coming from
00:37:17 <Cale> jzyamateur: In this case, the effect of the first action matters -- it's a put, so it changed the current state.
00:37:20 <jle`> the 'a' and 'b' are the "results" in this case, of the action
00:37:36 <jle`> so your intuition hit something meaningful -- it's the fact that the *result* of the first action is ignored
00:37:55 <jle`> for example `get >> put 4`, the result of get is thrown away into the abyss
00:38:04 <jle`> never to be seen or heard from again
00:38:31 <jle`> the whole "point" of (>>) is to be able to combine (and not ignore) effects, but ignore results
00:39:04 <jle`> you can think of it as (>>=) = use both effects, use both results, and (>>) = use both effects, ignore the first result
00:39:39 <jzyamateur> effect is different from result? what exactly is an effect?
00:39:49 <koz_> jzyamateur: Something _other_ than the value you get back.
00:39:57 <jle`> specifically in the case of State, it is things that 'change' or access state
00:40:00 <koz_> For example, in IO, it's 'interaction with the outside world somehow'.
00:40:18 <jle`> in the general sense it's a bit hard to pin down intuitively, without just working with a lot of different examples
00:40:23 <jzyamateur> All monads have their effects documented?
00:40:37 <jle`> jzyamateur: yes, ideally
00:40:55 <jle`> if they are written by responsible library owners :)
00:41:08 <jzyamateur> Ok, I will play around until I get the hang of it. :)
00:41:27 <koz_> jzyamateur: Yeah, practice is key - generalized intuition will come in time.
00:41:46 <Cale> Just using lots of examples of monads is the best way to understand the abstraction
00:42:30 <jle`> it's like collecting korok seeds in Breath of the Wild. each monad you learn about is the reward, in and of itself
00:42:46 <jle`> and at the end when you 'collect' them all, the reward (understanding the abstraction) is basically a piece of poop
00:42:50 <koz_> jle`: I guess monads are now like Nintendo game things, not burritoes. :P
00:43:21 <jle`> understanding the abstraction is much less useful than just understanding each example
00:43:56 * koz_ o O O (monads do what applica-don't?)
00:47:06 <hololeap> A Monad is like a Paraglider for your code...
00:47:20 <hololeap> you fumble around until an old dude gives it to you, and then you fly away
00:49:43 <hololeap> where do i get my "best monad analogy" trophy?
01:09:41 * hackage tagsoup-navigate 0.1.0.3 - Tagsoup Navigate  https://hackage.haskell.org/package/tagsoup-navigate-0.1.0.3 (TonyMorris)
01:12:02 <koz_> hololeap: I think Yoneda is giving them out in (lift RealWorld).
01:19:44 <hololeap> good ol' Nobuo
01:22:50 <jzyamateur> Is `(*>)` same as `(>>)` ?
01:23:05 <dibblego> yes
01:24:05 <jle`> in the case where they both are defined for a given type, yes
01:24:09 <romanix> Hello everyone! I'm trying to use the OverloadedLabels extension together with DuplicateRecordFields to get around the name clashes in record types. However, I'm getting compilation errors when trying to use #fieldName rec. The error is: No instance for (IsLabel "fieldName" (MyRecord -> T.Text))
01:24:50 <jle`> romanix: i think the point is to use a function from that takes #fieldName and gives you a MyRecord -> Text
01:24:51 <romanix> Does it mean I have to define my own IsLabel instances manually? It would defeat the purpose I think.
01:25:01 <jle`> #fieldName itself is not the accessor
01:25:07 <jle`> but it is a tool that libraries can use to create accessors
01:25:32 <jzyamateur> Also can I convert `m >> k` to `m >>= \_ -> k` for any monad ?
01:25:40 <Cale> jzyamateur: yes
01:26:00 <Cale> Though it might be the case for some instances that m >> k is implemented more efficiently.
01:26:38 <Cale> (the difference will usually be tiny if it exists at all though)
01:27:21 <romanix> jle`, I see. So in practice this extension is more for library writers than for end-users?
01:27:53 <jle`> which extension are you talking about?
01:28:01 <romanix> jle`, OverloadedLabels
01:28:05 <jle`> it is for end-users
01:28:11 <jle`> but they will use it with the help of a library
01:28:38 <jle`> for example a library would be able to provide a function like getField :: Label "fieldName" -> MyRecord -> T.Text
01:28:47 <jle`> then you could write getField #fieldName :: MyRecrd -> T.Text
01:30:12 <romanix> jle`, OK. Got it!
01:30:22 <kuribas> would it be useful to have asInt, asDouble, etc...for example: "asInt :: f Int -> f Int; asInt = id"
01:30:24 <kuribas> ?
01:30:27 <jle`> romanix: for example that's exactly what generic-lens-labels exports
01:30:51 <jle`> or i suppose that package is now absorbed into generic-lens
01:31:11 <jle`> then you can write view (fieldLens #fieldName) :: MyRecord -> T.Text
01:31:17 <jle`> provided MyRecord has a Generic instance
01:31:19 <kuribas> Then I could use it on overloaded strings in my library, for example (asInt "age") instead of ("age" :: Selector Int)
01:32:05 <jle`> 'useful' as in for your own usage
01:32:08 <jle`> or as in to add to base?
01:32:18 <kuribas> jle`: add to my own library
01:33:33 <kuribas> it'll just save some bytes, but I it's more readable.
01:34:00 <jle`> i mean, it's as useful as you have uses for :)
01:34:34 <kuribas> For example (Person <$> asInt "age" <*> asText "name") instead of (Person <$> ("age" :: Selector Int) <*> ("name" :: Selector Text))
01:34:54 <kuribas> I just hope I am not overengineering
01:35:07 <kuribas> there are also typed holes, but they are a bit invasive
01:35:49 <kuribas> alright, I'll keep it :)
01:36:23 <kuribas> it's a SQL library, and the overloaded string selects the field.
01:36:28 <jle`> i'm not sure what sort of answer you are looking for -- if it's a yes or no question, i can't imagine how it would be *not* useful
01:36:38 <jle`> there might be other, better ways to do it
01:36:43 <jle`> but that doesn't make it not useful
01:37:01 <kuribas> right
01:37:35 <jle`> if you want, you can unite them all as `as :: forall a f. f a -> f a; as = id`
01:37:47 <jle`> then you can write `as @Int`, `as @Text`, etc.
01:38:31 <kuribas> oh right, that's nice!
01:38:33 <kuribas> though I already have as...
01:39:56 <kuribas> maybe asA
01:40:33 <jle`> if you only ever use it for Selector, you can write sel :: String -> Selector a
01:40:38 <jle`> sel @Int "age"
01:40:44 <jle`> sel @Text "name"
01:41:14 <jle`> and not use OverloadedStrings
01:41:34 <kuribas> I have field already
01:41:38 <kuribas> field @Int "age"
01:42:02 <kuribas> field @Text "name"
01:42:16 <jle`> but also Person <$> "age" <*> "name" should already be ok, if Person's fields are monomorphic
01:42:26 <jle`> since it's unambigously Int and Text
01:42:47 <kuribas> indeed.  However for refactoring it could be helpful to have the right type in the field.
01:42:57 <jle`> that's fair, yeah
01:43:13 <jle`> asInt, asText, could also be intField, textField
01:43:31 <jle`> and you get the same code in the end
01:43:35 <jle`> (end-user code)
01:43:50 <kuribas> yeah
01:53:35 <kuribas> jle`: isn't as just id though?
01:53:54 <kuribas> > :t (id @Int [])
01:53:57 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
01:54:02 <kuribas> :t (id @Int [])
01:54:03 <lambdabot> error:
01:54:04 <lambdabot>     Pattern syntax in expression context: id@Int
01:54:04 <lambdabot>     Did you mean to enable TypeApplications?
01:54:24 <jle`> kuribas: yes, but with a specialized type
01:54:28 <jle`> kuribas: just like your asInt, asDouble
01:55:13 <kuribas> jle`: ah I see, you swapped a and f in the forall
01:56:38 <jle`> not quite 'swap'
01:56:42 <jle`> but 'split out'
01:57:08 <kuribas> yeah
01:57:57 <jle`> id would take (f a), but 'as' splits it out to take f and a, separately
01:58:11 <jle`> otherwise you could use `id @(_ Int)`
01:58:22 <jle`> which is a little uglier because it requires parentheses
01:58:27 <kuribas> indeed
04:24:06 <jzyamateur> Even though mempty value is used in many places, the value of mempty entirely depends according to context it is being used in, and compiler will automatically figure it out according to the type instance?
04:25:32 <f-a> jzyamateur: if the compiler cannot figure out a concrete type in your application, it will display an error
04:26:16 <dansho> is there a way to do zipWith over backprop BVars?
04:26:30 <jzyamateur> ok
04:30:34 <Cale> f-a, jzyamateur: Or you'll end up defining something polymorphic...
04:31:18 <Cale> (but yeah, eventually you need to pick an actual type)
04:52:14 <dansho> looks like i can use a combination of collectVar and sequenceVar to implement it
05:06:35 <maerwald> branch :: Selective f => f (Either a b) -> f (a -> c) -> f (b -> c) -> f c
05:06:41 <maerwald> branch fEither fA fB = select ((second <$> fB) <*> fEither) fA -- is this branch correct wrt selective? Because it always runs fB, even if it's a Left, but I guess that's within the laws
05:10:15 <maerwald> the one from the code seems quite different and: branch x l r = fmap (fmap Left) x <*? fmap (fmap Right) l <*? r
05:10:16 <maerwald> ouch
05:15:12 * hackage mmsyn5 0.4.2.0 - Various additional operations on lists (some with intermediate Monads)  https://hackage.haskell.org/package/mmsyn5-0.4.2.0 (OleksandrZhabenko)
05:30:35 <maerwald> I'll just claim I was half way there :P
05:57:00 <jzyamateur> What exactly is `<|>` from Alternative is supposed to do?
05:58:32 <f-a> jzyamateur: do you happen to know/use parsec or similar?
05:58:47 <jzyamateur> Trifecta
05:59:08 <jzyamateur> But this is something more general right?
05:59:36 <[exa]> jzyamateur: basically it "returns" one of the alternatives that didn't fail
05:59:38 <f-a> yeah I mean
05:59:40 <f-a> > Nothing <|> Just 7
05:59:41 <lambdabot>  Just 7
06:00:01 <jzyamateur> "didn't fail" is something baked into the definition ?
06:00:15 <[exa]> specified by the instance usually
06:00:29 <[exa]> e.g. f-a showed that Nothing means failure for Maybes
06:00:42 <[exa]> Left is considered a failure in Eithers
06:00:49 <jzyamateur> It takes two applicatives and returns any one of them then?
06:01:12 <[exa]> the one that failed less.
06:01:37 <[exa]> > Left "error" <|> Right 5
06:01:39 <lambdabot>  Right 5
06:01:47 <[exa]> > Right 3 <|> Right 5
06:01:49 <lambdabot>  error:
06:01:49 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M251882985919...
06:01:49 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
06:01:56 <[exa]> oh noes
06:02:09 <[exa]> > Right "some choice of what to return" <|> Right "other choice"
06:02:12 <lambdabot>  error:
06:02:12 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M715471858249...
06:02:12 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
06:02:52 <Clint> > Right 3 <|> Right 5 :: Either String Int
06:02:56 <lambdabot>  Right 3
06:03:19 <[exa]> oh thanks
06:03:24 <jzyamateur> Why did it pick 3?
06:03:31 <jzyamateur> came first?
06:03:48 <f-a> yep
06:03:52 <MarcelineVQ> 'succeeded' first
06:03:57 <f-a> I realise I don't know what the IO instance does
06:04:01 <[exa]> jzyamateur: basically, yes. The meaning is as I said, "pick any alternative that does not fail, or fail if there's none"
06:04:29 <jzyamateur> got it
06:05:52 <[exa]> f-a: afaik in IO it "catches" the ioErrors and fails
06:06:19 <f-a> > undefined <|> print 7
06:06:21 <lambdabot>  <IO ()>
06:06:23 <oo_miguel> I'm reading about "category theory for programmers" and I do not see why in `Cat` the morphism between a pair of products say C x D -> C x D is neceserily just a pair of independent morphisms (c->c',d->d') ?
06:08:11 <oo_miguel> I accept that an object in C x D is just a pair of objects (c,d)
06:08:40 <[exa]> C,D are objects or categories?
06:08:49 <oo_miguel> C and D are categories
06:08:56 <oo_miguel> and CxD is the `product category`
06:11:25 <jzyamateur> Also saw that in case of lists, `<|>` returns the one with more elements.
06:11:56 <[exa]> jzyamateur: in case of lists afaik (<|>) is defined as (++)
06:12:12 <lortabac> > [1,2,3] <|> [4,5]
06:12:14 <lambdabot>  [1,2,3,4,5]
06:12:40 <lortabac> there is some overlap between Alternative and Monoid
06:12:52 <jzyamateur> And that is how `some`, `many` have a recursive definition, and the termination occurs via `<|>`. I was doing `pure [1,2,3] <|> pure []`
06:13:21 <jzyamateur> sorry list wrapped inside an applicative I meant
06:13:45 <lortabac> some and many are meant to be used with parsers
06:13:53 <[exa]> oo_miguel: oh so. Isn't that morphism independence kindof implied by the definition?
06:14:31 <jzyamateur> Why does it concatenate in case of lists, instead of choosing one of them?
06:15:34 <[exa]> jzyamateur: lists are imagined as "sets of possibilities" in this case, ++ does the correct thing -- return all valid alternatives
06:16:50 <oo_miguel> [exa]: Hmm.. yeah something seems to prohibit defining a morphism like: morph :: (Int,Int) -> (Int,Int); morph (a,b) = (a+b,a+b), right?
06:17:01 <jzyamateur> what about choosing a less failing one?
06:17:07 <[exa]> which is certainly more ambitious that the "return something that does not fail"
06:17:31 <oo_miguel> [exa]: aa ok. you mean it is not there by defintion.. ook
06:17:36 <jzyamateur> It's more like you might get some alternatives, maybe all of them, maybe a less failing one.
06:17:54 <jzyamateur> depending on context
06:18:02 <oo_miguel> [exa]: defintion of product category just contains this individual morphisms.. allright. seems plausble
06:18:06 <oo_miguel> plausible
06:18:12 <[exa]> jzyamateur: afaik returning just one element from either one of the lists would "implement alternative" as well, but in light of lists it would just uselessly discard random alternatives
06:19:24 <[exa]> oo_miguel: in the first diagram here https://en.wikipedia.org/wiki/Product_(category_theory) --- viewed differently, the product must carry some information that can be used to "reconstruct" the original morphisms
06:19:25 <jzyamateur> List is the most fascinating structure it seems, no matter what the typeclass, it sure has some interesting behavior, and most likely the most used structure as well.
06:19:40 <lortabac> to be honest Alternative looks like a hack to me
06:20:47 <lortabac> the only time I needed polymorphic behavior over failure I ended up using 'Alt' from semigroupoids
06:20:59 <lortabac> at least it has more useful instances
06:21:42 <oo_miguel> [exa]: I see. Did not know that. thank you!
06:22:28 <[exa]> oo_miguel: I'm not sure how that definition would prohibit e.g. just permuting the objects in the product
06:23:21 <oo_miguel> It probably does not even prohibit just swapping the objects everytime for instance.. but this would be isomorphic to NOT swapping them at all.
06:23:40 <[exa]> well
06:23:56 <oo_miguel> So it would be exactly the same operation (up to isomorphism)
06:24:45 <[exa]> if we look at objects in a way they are completely defined by morphisms, permutation/swapping doesn't really do anything
06:25:17 <[exa]> yeah.
06:25:25 <oo_miguel> yeah this is how I undertand it as well (based on my limited knowledge)
06:32:33 <merijn> lortabac: You say "Alternative looks like a hack", but secretly Alternative is just "Monoid1" :p
06:33:13 <lortabac> :)
06:33:47 <merijn> And Monoid is obviously the best typeclass!
06:34:19 <lortabac> if it was "exactly" Monoid1 I would have nothing against it
06:35:59 <merijn> lortabac: How is it not Monoid1?
06:37:07 <merijn> It's an associative binary operation + identity element
06:37:32 <lortabac> it has some and many, it does not have Semigroup1 in base, it has an instance for IO
06:37:47 <merijn> The only difference is Monoid requires type of kind *, but Alternative requires kind "* -> *", hence Monoid1
06:38:11 <merijn> What's wrong with the instance for IO?
06:38:36 <lortabac> you have to look at the source code to know what it does
06:38:49 <lortabac> which kind of defeats the purpose of type classes
06:38:54 <merijn> That applies for many Monads and Monoids too
06:39:18 <merijn> As well as Applicative, etc. yet no one would argue those are hacks
06:39:39 <literallyCrevice> I'm trying to set up vim with haskell-ide-engine. I ran stack ./install.hs stack-hie-8.4.2 and it installed but I'm getting an error about not having cabal-install installed. Do I need to stack install cabal-install or something?
06:40:21 <merijn> literallyCrevice: Possibly? Don't the instructions say which dependencies you need?
06:40:51 <merijn> literallyCrevice: Alternatively, you could try ghcide which seems to be considerably easier to install
06:42:46 <lortabac> merijn: I guess you are right, but I still don't like this class :)
06:42:50 <merijn> literallyCrevice: I recently switched to using ALE to do error/warning highlighting in vim and it's been working very well (except, for stuff including internal TH) and *crazy* fast. It doesn't have all the HIE features, though
06:43:19 <lortabac> I write Monad-polymorphic every day, yet I have never written nor seen Alternative-polymorphic code
06:44:08 <merijn> lortabac: I don't object to "not liking" a given abstraction, but I do object to poor reasons for disliking :p (subjective reasons are fine, if you can admit they're subjective :p)
06:44:23 <merijn> lortabac: asum is a pretty damn useful Alternative polymorphic function :)
06:44:25 <merijn> :t asum
06:44:26 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
06:44:44 <literallyCrevice> merijn: I'll check ale out
06:44:45 <merijn> I use it with parsers, I use it with MaybeT/ExceptT
06:45:21 <merijn> literallyCrevice: You can even steal the hard parts from me (I'll try to get these into ALE directly when ghcide is a bit more stable)
06:45:24 <merijn> literallyCrevice: https://github.com/merijn/dotfiles/blob/master/dotfiles/vim/autoload/ale_linters/haskell/ghcide.vim
06:45:36 <merijn> literallyCrevice: and https://github.com/merijn/dotfiles/blob/master/dotfiles/vim/ftplugin/haskell.vim#L1-L9
06:45:56 <lortabac> ok, maybe me it's just me who didn't happen to need it often enough :)
06:49:07 <merijn> literallyCrevice: ALE is just the first linter I found that's 1) supports LSP (needed by ghcide and also HIE), and 2) didn't require me to either install Rust or Node.js to use it :p
06:54:11 * hackage ats-format 0.2.0.34 - A source-code formatter for ATS  https://hackage.haskell.org/package/ats-format-0.2.0.34 (vmchale)
06:54:24 <literallyCrevice> merijn: I got ale working, yay!
06:59:16 <merijn> literallyCrevice: ALE + ghcide is so fast for me that it often has finished typechecking my code before vim finished leaving insert mode :)
07:04:45 <cocreature> merijn: don’t worry, I’m good at making things slower
07:04:55 <merijn> cocreature: :p
07:05:07 <maerwald> merijn: how many LOC?
07:05:49 <merijn> maerwald: Mostly tiny things, because it can't currently handle my biggest project
07:05:58 <maerwald> yeah :/
07:06:08 <merijn> Due to TH
07:06:38 <cocreature> we do have an internal codebase (DAML not Haskell) at around 200k loc that people work on using ghcide
07:10:05 <Rembane_> What's a DAML?
07:11:55 <cocreature> a language that we have developed at digital asset. our compiler is based on a fork of GHC which why our DAML lsp server can also function as a Haskell lsp server as demonstrated in ghcide
07:49:07 <jzyamateur> I am trying to get info about Compose using `:i Compose` on ghci repl but it is not in scope. I also imported `Data.Functor` but it still fails. Where is it?
07:50:14 <merijn> jzyamateur: Data.Functor.Compose
07:50:15 <f-a> Data.Functor.Compose
07:50:19 <merijn> @hoogle Compose
07:50:20 <lambdabot> module Data.Functor.Compose
07:50:20 <lambdabot> Data.Functor.Compose newtype Compose f g a
07:50:20 <lambdabot> Data.Functor.Compose Compose :: f (g a) -> Compose f g a
07:50:25 <f-a> us- yeah
07:50:46 <jzyamateur> oh Ok, the module name is also the same.
07:51:00 <merijn> jzyamateur: Yeah
07:56:05 <jzyamateur> I see the type definition : `newtype Compose (f :: k -> *) (g :: k1 -> k) (a :: k1)= Compose {getCompose :: f (g a)}` what are the k's supposed to mean? I want to understand the types necessary for f, g, a.
07:56:34 <jzyamateur> I see the type definition : `newtype Compose (f :: k -> * ) (g :: k1 -> k) (a :: k1)= Compose {getCompose :: f (g a)}`
07:57:40 <lyxia> it means you can replace k with any kind
07:57:59 <merijn> jzyamateur: You can pretty much ignore most of that, tbh
07:58:37 <merijn> jzyamateur: At some point people made it kind polymorphic, but you are free to just pretend 'f' and 'g' to be "* -> *"
07:59:15 <jzyamateur> ok
08:05:09 <merijn> jzyamateur: Basically, it says 'a' is some type (which is not necessarily kind *) and 'g' is something that takes that type and return a new type with kind 'k', and f takes some type of kind 'k' and returns a type *, allowing you to compose things other than functors
08:06:09 <merijn> jzyamateur: But if you just assume 'a :: *', 'k1 = *' and 'k = *' then you get the "f, g :: * -> *" simple interpretation back
08:36:33 <ysangkok> can i use Type Applications in rewrite rules?
08:36:59 <ysangkok> i am trying, but ghc claims a forall'ed variable that i use in a Type Application is not in the left hand side
08:39:24 <merijn> That sounds like a bad idea
08:39:58 <merijn> Although I would argue that using TypeApplications *at all* qualifies as a bad idea, so...
08:41:03 <ysangkok> roconnor suggested i do Russell O'Connor:blockstream: 10:49 AM
08:41:05 <ysangkok> e.g. fullAdder @(Kleisli m) w into Kleisli (\((a,b),c) -> return $ let sum = fromWord w a + fromWord w b + fromWord1 c in (toBit (sum >= 2 ^ wordSize w), toWord w sum))
08:41:57 <ysangkok> so i tried
08:41:59 <ysangkok> "fullAdderOpt" forall w m. fullAdder @(Kleisli m) w = Kleisli (\((a,b),c) -> return $ let sum = fromWord w a + fromWord w b + fromWord1 c in (toBit (sum >= 2 ^ wordSize w), toWord w sum))
08:42:24 <ysangkok> but that gives "Forall'd variable ‘m’ does not appear on left hand side" and "Not in scope: type variable ‘m’"
08:42:29 <ysangkok> which seems contradictionary?
08:43:24 <ysangkok> anyway, i thought (after reading your advice about type applications a couple of times on here) that i'd just remove the type application :)
08:43:57 <ysangkok> "fullAdderOpt" forall w. fullAdder w = Kleisli (\((a,b),c) -> return $ let sum = fromWord w a + fromWord w b + fromWord1 c in (toBit (sum >= 2 ^ wordSize w), toWord w sum))
08:44:41 <ysangkok> but then i get "Could not deduce (Monad m) arising from a use of ‘return’". "Possible fix: add (Monad m) to the context of the RULE "fullAdderOpt""
08:44:56 <ysangkok> but can rules even have contexts?
08:45:04 <merijn> Good question...
08:45:32 <merijn> ysangkok: You might wanna ask this sorta detailed stuff on the haskell-cafe mailing list, better reach and chance that someone with the right knowledge sees it
08:46:14 <ysangkok> i am actually just starting out with haskell, that's why i ask on irc first, i assume that all my questions are stupid :P
08:46:23 <ysangkok> but if you say it is a meaningful question, i will ask on haskell-cafe
08:47:51 <geekosaur> anything involving RULEs is meaningful in this sense, tbh
08:47:59 <geekosaur> they're not really a beginner feature
08:48:26 <merijn> ysangkok: haskell-cafe isn't really "advanced stuff only" it's pretty much "any level of haskell related communication" (although asking extremely basic stuff would probably make it be spammy)
08:48:40 <merijn> OTOH, I would say anything involving RULES is definitely not beginner stuff :p
08:58:11 * hackage tmp-postgres 1.6.0.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.6.0.0 (JonathanFischoff)
09:01:17 <sm[m]> #haskell-cafe usually handles pretty much any Haskell related question
09:24:14 <merijn> So...naming convention... if I have 2 version of an operation 'foo' one which can be used within larger transactions and the other only "standalone" what'd be a good suffix to distinguish them?
09:25:56 <cocreature> merijn: obvious, call one "foo" and the other "foo'" 
09:26:14 <TheCommieDuck> how can I get around circular type dependencies? e.g. data A = A { f :: X -> Y}, data X = X A? 
09:27:20 <cocreature> merijn: on a more serious note, I sometimes end up suffixing all operatins that can be composed into a larger thing with a common suffix (e.g. T for transaction, I’ve used `cmd` in another context recently where that made sense) and then use the unsuffixed version for the “standalone” version
09:28:08 <TheCommieDuck> I can understand why it'd be an issue to have A { f :: X}, X { g :: A } but is my only option with functions to have some weird parameterised thing?
09:31:16 <merijn> TheCommieDuck: That seems fine, tbh :p
09:31:56 <merijn> TheCommieDuck: Like, where is it going wrong for you, because it seems like that should just work?
09:32:32 <merijn> cocreature: oh, T might be good, I tries using Trans or something, but then the names started getting very long
09:33:34 <TheCommieDuck> it has issues with not being able to find the type decl for X
09:33:42 <aberisha> hello!
09:33:47 <merijn> TheCommieDuck: X and A are in different modules?
09:33:57 <cocreature> merijn: people already make fun of Haskellers for using one-letter variables names so it only seems fitting that we use one letter abbreviations for our suffixes :)
09:34:09 <merijn> @quote first.26
09:34:09 <lambdabot> alexbagel says: i find that my first 26 variables are always easy to name. after that it becomes a bit harder.
09:34:17 <TheCommieDuck> No
09:35:00 <TheCommieDuck> https://pastebin.com/5Hi9y1A8 actual code
09:35:20 <cocreature> TheCommieDuck: the issue is the TH here
09:35:27 <cocreature> TheCommieDuck: try moving all of that to the bottom of the file
09:35:29 <TheCommieDuck> Ohhhh
09:35:33 <TheCommieDuck> thank you!
09:35:35 <cocreature> TH has weird restrictions on ordering
09:38:52 <cocreature> TheCommieDuck: scroll down to “declaration groups” at https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#th-syntax if you want to know the details
09:40:36 <nil> why are tuple sections disabled by default?
09:41:27 <nil> (guess: they're not standard Haskell?)
09:42:13 <merijn> nil: Correct, which, imo is an oversight/error in the standard
09:42:29 <nil> indeed
09:43:45 <merijn> I was hoping Haskell2020 would fix that, but at this rate not :p
09:45:18 <merijn> cocreature: hmm, maybe I should just move to separate modules, since I'm importing them qualified in most places anyway
09:49:22 <Haskeller> Hey guys, I'm working on server-client application using Cloud Haskell. Do you have any info about that topic, I'm having a small issue about the application
09:50:31 <cocreature> merijn: sure if that doesn’t lead to an awkward API that’s a nicer solution
09:55:47 <aberisha> I'm just starting to learn about haskell. I love thinking about types and how it changes the way I program
09:56:19 <aberisha> mostly I've been watching conference talks on youtube; I read that Learn You Some Good Haskell is a good book to start with
09:56:44 <aberisha> I work within emacs as well so if anyone has any suggestions as far as configurations/packages please let me know
09:56:47 <aberisha> :]
09:57:00 <f-a> use ghcid or similar
09:57:06 <f-a> I suppose there is something for emacs
10:00:02 <aberisha> when it comes to stack and cabal should I just choose either and go with it?
10:00:25 <f-a> follow what's used in your book, I would say
10:01:27 <aberisha> thank you for recommending ghcid, it looks handy
10:01:50 <f-a> excellent piece of software , does one thing, does it well
10:18:59 <dmwit> nil: One could imagine a hypothetical TrailingCommas extension that allowed [foo,bar,] to mean the same as [foo,bar] and (foo,bar,) to mean the same as (foo,bar), and TupleSections would conflict with that.
10:19:27 <monochrom> Aw
10:19:49 <dmwit> Haskeller: You'll get better advice if you 1. ask your actual question, and 2. include a link to a pastebin that has a minimal version of the code that shows the problem.
10:19:50 <monochrom> I like trailing commas.  I like rust for having it.
10:20:22 <nil> dmwit: fair point
10:20:57 <monochrom> But I agree we may be unwilling to part with tuple sections.
10:22:27 <nil> trailing commas probably make more sense for lists anyway
10:23:22 <monochrom> Don't forget comprehension!  [ z+1 | x<-xs, y<-ys, x>y, z<-[x..y], ]
10:25:11 * hackage haskell-src 1.0.3.1 - Support for manipulating Haskell source code  https://hackage.haskell.org/package/haskell-src-1.0.3.1 (HerbertValerioRiedel)
10:29:43 <nil> random thought: `f <$> g <$> x` has the same meaning regardless of whether (<$>) is left- or right-associative
10:39:07 <Haskeller> Hello there! (Sorry for sending first message so badly :)) I'm trying to build a server-client project using Cloud Haskell. I checked some resources and found the cloudhaskell-chat and work on it for some time. Everything works fine in this tutorial and this repo. But what I want to add is that a acknowledgement message with a checksum. When a
10:39:07 <Haskeller> client sends a message server broadcasts this message to all clients.messageHandler :: CastHandler ClientPortMap ChatMessage messageHandler = handler     where         handler :: ActionHandler ClientPortMap ChatMessage         handler clients msg = do     broadcastMessage clients msg     continue clients But there is no correlation about whether
10:39:08 <Haskeller> checking if the message is delivered without any loss. To do that I thought about a simple checksum. Where when a client sends a message, it also sends the summation of the decimal equivalent of the string.chatInput <- liftIO getLine cast serverPid $ sum $ map ord chatInput cast serverPid (ChatMessage (Client nickName) $ chatInput) In the same time
10:39:08 <Haskeller> I have to send the received packet's sum of decimal equivalent of the string to server to compare these two values and print an ack message.msg <- receiveChan rp cast serverPid $ sum . C.ord . chatMessageToStr msg Everything is logical until this point but I don't know how to handle these message in the server code so that I can send the ack
10:39:09 <Haskeller> message. If I can find a way to do this whole problem will be solved. I hope you can show me the right direction. Thank you so much!
10:41:28 <merijn> Is there a way I can reexport parts of a module and still use some of the not reexported parts wich doesn't require me to manually spell out the reexports?
10:44:46 <geekosaur> no, this is why Internals modules
10:49:31 <merijn> geekosaur: That doesn't help if most of the "Internals" module is also public
10:49:56 <geekosaur> Internals doesn't enforce anything, it's just convention
10:49:57 <merijn> Normally I'd import hiding the relevant things, but that doesn't help in this case, cause I do need those parts
10:50:54 <geekosaur> do you actually want to hide them, or qualify them? although that doesn't really affect the answer, there's no fancy way to do multiple namespaces from a single module
10:51:03 <geekosaur> aside from maybe some backpack hackery
10:51:57 <merijn> geekosaur: Yeah, but that's too much work right now
10:53:22 <geekosaur> the best you can do is a modue which exposes everything, that you'd import qualified (the Internals module), and another that imported the Internals module and re-exported only the standard API that you could import unqualified or with a different qualifier
12:01:32 <dsal> Hey, another dumb lens question.  I don't have full lens here, just Lens.Family2.  I have an "Either String a"  I don't know how to get to that a, but if I pull it out manually, I can "map (\x -> x ^. #name) $ r ^. #field" and get  a list of field names, but I'm not sure how to do that in one pass.
12:10:19 <dsal> I found the second half, anyway.
12:15:18 <dsal> I think it's probably better not to do the first part, though I'm curious how that's supposed to work.  I don't understand over/under.
12:21:09 <dsal> Hmm...  Part of my confusion might be from an older version of Lens.Family2.
12:55:39 <koz_> If m is a Monad, and I have m (m b, s), can I get (m b, s) from that?
12:56:20 <cocreature> koz_: no, consider m = IO, in the first case you need to execute some kind of IO to get s, in the second you don’t
12:56:37 <cocreature> koz_: or even simpler m = Maybe, how do you get s if it is Nothing?
12:56:45 <koz_> Yeah, point taken.
12:58:42 * hackage tmp-postgres 1.7.0.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.7.0.0 (JonathanFischoff)
13:04:16 <dmj`> Has anyone ever got doctests to work when using a third-party C dependency ?
13:05:07 <dmj`> I'm in a bit of a pickle, it seems subprocesses that are spawned lose information about where dynamic libraries live 
13:05:25 <dmj`> yes I'm using cabal-doctest
13:09:47 <romanix> Hi All! I'm playing with DuplicateRecordFields and TypeApplications. I don't understand why this disambiguates the userEmail accessor: userEmail (user :: User) but this doesn't: userEmail @User user. Any ideas?
13:12:21 <Habib> Can someone help me understand what's going on with this example in the TwiML package documentation?
13:12:21 <Habib> https://hackage.haskell.org/package/twiml-0.2.1.0/docs/Text-XML-Twiml-Verbs-Message.html
13:12:35 <Habib> This bit really confuses me:
13:12:36 <Habib> where Twiml.Syntax{..} = def
13:13:18 <Habib> I can't find any documentation on any syntax rules that would allow that `Module{..} = binding`
13:13:31 <Rembane> Habib: Is Syntax a module ?
13:14:09 <Habib> Actually, you're right. It's a data constructor.
13:14:15 <Rembane> Habib: If it is a constructor it says that if def is the constructor Syntax then the expression evaluates to True. 
13:14:19 <cocreature> romanix: the type application doesn’t make sense since there is no polymorphic userEmail function that takes a type parameter.
13:14:47 * Rembane waves hands 
13:15:09 <Habib> Rembane: it only has one equal sign, not two.
13:15:23 <Habib> And that's consistently the case.
13:15:26 <Rembane> Habib: That is indeed true, it's because pattern matching is used. 
13:15:41 <cocreature> 1551 users wave back at Rembane 
13:16:04 <Habib> Okay, but where's the function or case statement that it's pattern matching for?
13:16:10 <Rembane> Habib: You can also write it as: case def of Twiml.Syntax{} -> _ 
13:16:13 <Rembane> cocreature: ^^
13:16:33 <Habib> Where can I find some documentation on this?
13:17:26 <Rembane> Habib: here for instance: https://en.wikibooks.org/wiki/Haskell/Pattern_matching#Introduction_to_records
13:17:40 <romanix> cocreature, Oh. Right. I thought TypeApplications worked the same way as type annotations in the context of DRF and it could be used to select the right accessor. 
13:18:10 <romanix> cocreature, Thanks for clarifying this.
13:18:46 <cocreature> romanix: you could ofc imagine that GHC accepts TypeApplications here anyway and I don’t see a fundamental reason why it couldn’t but it doesn’t fall out “naturally”.
13:18:59 <cocreature> the disambiguation for DRF is pretty weird
13:19:23 <cocreature> HasField like disambiguation is much more natural imho
13:20:09 <nolrai> Hey I remember seeing a reddit post about how haskell profiling results can now be sent to a standard profiling visualizer?
13:20:31 <Athas> nolrai: this? https://github.com/fpco/ghc-prof-flamegraph
13:20:42 <cocreature> nolrai: sounds like https://www.reddit.com/r/haskell/comments/dt9acz/introducing_hsspeedscope/
13:20:52 <AMDphreak> I had an idea for Haskell: what if lists operators were automatically assumed to use the "map" function? Wouldn't this make is so that the user can just do "lst * 3" or "3 * lst"? More importantly, wouldn't this make it so that you never have to explicitly think about the "map" function?
13:21:27 <nolrai> I mean it loses a lot of type safety. 
13:21:32 <Athas> AMDphreak: why only lists?  Why not do that for any Functor?
13:21:58 <nolrai> cocreature: Thanks, that was it!
13:22:05 <AMDphreak> Good question. I'm not thinking that clearly today. The idea sort of popped in my head while I was look at a basic tutorial for Haskell.
13:25:10 <geekosaur> more than that, one can come up with a Num instance for lists
13:25:26 <geekosaur> (not recommended because there goes your type safety)
13:25:41 * hackage predicate-typed 0.3.0.0 - Predicates, Refinement types and Dsl  https://hackage.haskell.org/package/predicate-typed-0.3.0.0 (gbwey)
13:26:16 <Rembane> And when you've implemented your Num instance for lists you might as well take a look at APL or J. 
13:26:34 <nolrai> And having 3 = repeat 3 is a bit ... :/
13:27:27 <nolrai> Wait no thats the instance for zip lists.
13:28:02 <Habib> Rembane: okay, so if I'm understanding this right, where Twiml.Syntax{..} = def makes all the fields of Twiml.Syntax available to the local scope, and in this case, it's constructing the default (from class Default) Twiml.Syntax definitions and making the fields available in that scope?
13:29:47 <nolrai> Anyway, is updating my GHC to the merge of the above profiling feature a bad idea?
13:29:56 <nolrai> It feels like a bad idea.
13:29:59 <AMDphreak> Interesting, I'll have to think about this implicit "map" some more. Type safety is important but I think it is compatible with this.
13:30:31 * geekosaur is not sure this gains much over list comprehensions, tbh
13:31:10 <jassob> Habib: yes, I think you've understood it correctly
13:31:16 <Rembane> Habib: Maybe... I just saw that they use RebindableSyntax, so that make things much more interesting.
13:31:48 <Habib> Yes, they use rebindable syntax to redefine the monadic operators as thye want to use an indexed monad instead.
13:31:51 <nolrai> My experience is that distinguishing 'T 'from 'm T' from 'm (m T)' catches a lot of conceptual errors on my part when writing monadic code.
13:34:20 <monochrom> This kind of wishes has been wished and forgotten before.  Every generation will wish for a version of type-directed instance resolution and then it will lose traction and forgotten.
13:34:56 <nolrai> I mean idris has it sort of.
13:35:51 <Rembane> Habib: I'm at a loss, maybe someone else here has a better clue. 
13:37:41 <nolrai> I can see an argument for changing the "white space operator" to fmap, but I think having some sort of fairly simple way to distinguish a function applied directly and applied to a functor is pretty necessary.
13:37:59 <Habib> Thanks for the docs link anyway, that does tie it all together. I'd only ever seen the {..} stuff in pattern matching, so I was guessing that's what was happening here, but I'd never seen it used like that in a where binding before.
13:38:26 <monochrom> Likewise in every generation of teenagers there are some who wish "when I grow up I will go into politics to change the law and lower the legal drinking age".  After they have grown up they abandon the idea. >:)
13:39:05 <Habib> I think we've got it figured out. They link to a Haskell Cafe message which shows the idea as a little trick to rebind syntax but scoping the syntax change to only a single do block instead of a whole file.
13:39:29 <monochrom> Actually there was an idea of change (.) to be an alias of fmap.
13:39:38 <monochrom> s/change/changing/
13:41:28 <monochrom> <troll>The benefit of changing juxtaposition to be automatically either application or fmap is that we won't need to answer the beginner question "what's the difference between ($) and (.)?" anymore >:) </troll.
13:41:36 <monochrom> Aw I can't type.
13:41:58 <geekosaur> trollolol?
13:42:12 <Habib> Should have generated the string through a type-safe DSL.
13:42:46 <monochrom> Anyway this was my perspective last time people wished for it: https://mail.haskell.org/pipermail/haskell-cafe/2010-November/086220.html
13:46:26 <monochrom> Last time it was due to widespread dissatisfaction with how record syntax is not a real record system, especially for example two types cannot use the same field name (even if same field type), so people thought maybe add automatic resolution by context to allow it.
13:47:12 <monochrom> Eventually lens happened and fulfilled that motivation.
13:52:08 <nil> we could go even further and make juxtaposition mean ($), (<$>) or (<*>) !
13:56:47 <ollehar> Why would Maybe ever need to be a monad and not just a datatype?
13:57:21 <Clint> what
13:57:42 <monochrom> Someone is bound to make it a monad.  I know I would.
13:57:47 <ChaiTRex> ollehar: dorsn't need to be one, just has nice uses
13:58:16 <ollehar> Ok
13:59:20 <monochrom> Mathematically it is a monad whether you like it or not.  From this angle, if you don't like it, the burden is on you to give reasons why not code it up.
14:00:03 <ollehar> I judt
14:00:52 <ollehar> I just see it as a data type. That's how it's used in ocaml.
14:01:36 <monochrom> Welcome to eye-opening Haskell!
14:02:02 <ollehar> Haha
14:02:11 <monochrom> Even when I was dabbling in ocaml I wrote my own monad definition and Option-is-a-monad code fairly quickly.
14:02:41 * hackage arrayfire 0.5.0.0 - Haskell bindings to the ArrayFire general-purpose GPU library  https://hackage.haskell.org/package/arrayfire-0.5.0.0 (DavidJohnson)
14:02:43 <monochrom> More seriously if your reason is "it is not done in other languages" that's a dumb reason.
14:03:04 <ollehar> Just a question :)
14:04:46 <dmj`> that sweet sweet smell of fresh haddocks
14:05:36 <amx> can I install a tarball with cabal 3?
14:06:03 <monochrom> I don't know but you can always unpack it first.
14:08:49 <nil> i wish people would stop using OCaml to teach functional programming
14:09:43 <nil> the more i use haskell, the more ocaml looks like javascript to me
14:09:51 <monochrom> haha
14:10:42 <ollehar> Ocaml is great, but lack effect types
14:11:54 <monochrom> Yeah I disagree about ocaml looking like javascript (and I have been using haskell exclusively for a decade) but if you put it that way heh.
14:11:59 <amx> monochrom: the workflow so far was cabal new-sdist and then cabal new-install on the tarball, but I suspect this is redundant if the project can be built and installed
14:12:04 <nil> it mostly doesn't need them because it isn't pure. you can have all the effects you want without anything special at the type level
14:12:23 <ollehar> That's the problem
14:12:26 <nil> monochrom: i was exaggerating a lot
14:12:29 <dolio> Maybe the fact that it isn't abstracted over in OCaml tells you something about OCaml.
14:12:36 <monochrom> Yeah
14:14:17 <ollehar> I was hoping they'd do row-polymorhpic effect types, but that hasn't happened
14:14:24 <monochrom> amx: I don't understand why you need the "cabal new-sdist" step.  Also XY-problem alarm.
14:15:11 <monochrom> w00t row-polymorphic effect types is so much better than type-level effect lists (e.g. Idris)
14:15:11 <amx> monochrom: it's a build script, I inherited it. I guess I will replace everything with cabal build, test, install
14:15:44 <ollehar> Didn't try Idris
14:15:58 <monochrom> Don't forget that Setup.hs also exists.
14:18:48 <jle`> ollehar: mostly you can use Maybe as just a normal data type, because it is
14:18:57 <monochrom> In haskell land, the servant library also use type-level lists for a similar purpose. IIUC s/effect/feature/
14:18:59 <jle`> ollehar: when it becomes useful to think of it 'as a monad' is when you are using monad-polymorphic abstractions
14:19:10 <jle`> ollehar: for example in Haskell there are a lot of functions that work "for all monads"
14:19:24 <jle`> so in those specific cases it can be useful to think of Maybe "as a Monad"
14:19:41 <jle`> for example we have the sequence function, which is defined to work for all monads, sequence :: Monad m => [m a] -> m [a]
14:19:46 <jle`> > sequence [Just 3, Just 10, Just 2]
14:19:49 <lambdabot>  Just [3,10,2]
14:20:09 <monochrom> I simply enjoy using >>= (and fmap, <*>, etc) to do the "if Nothing then Nothing else carry on" case analysis boilerplate for me.
14:20:27 <ollehar> Hm
14:20:29 <jle`> ollehar: in this case in the end you are really just using Maybe as a normal data type, but making the connection that "oh, i can use sequence here" is only possible if you understand Maybe as a Monad
14:20:36 <jle`> ollehar: of course you could write sequence to work *only* for Maybe
14:20:47 <jle`> and so you wouldn't ever need to think of it as a monad
14:20:54 <jle`> it's easy enough to write sequenceMaybe :: [Maybe a] -> Maybe [a]
14:21:17 <jle`> but the power of the monad abstraction is that it allows us to generalize it and write functions like Monad m => [m a] -> m [a] that work for all monads, to reduce code duplication
14:21:28 <jle`> just like how we have `sort :: Ord a => [a] -> [a]`, that works for all Ord instances
14:21:46 <jle`> so we don't have to write sortInt :: [Int] -> [Int], sortString :: [String] -> [String], sortDouble :: [Double] -> [Double], etc.
14:22:10 <jle`> so the parallel question would be "why would Int ever need to be Ord, and not just a data type/integer?"
14:22:22 <monochrom> It is true that I don't insist on the name ">>=" and I don't insist on a Monad class.  But observe that SML and OCaml standard libraries don't even bother with an Option-specific version of ">>=".  Like they don't take Option seriously.
14:22:24 <jle`> and the answer would be, when you want to make the connection that you can use sort :: Ord a => [a] -> [a] for Int
14:22:25 <nil> i don't know if i would have picked sequence as an example, given that you really only need Applicative to implement it
14:22:37 <monochrom> I mean even Rust does better in this regard.
14:23:05 <nil> but i guess the question "why is Monad an Applicative?" could also be asked
14:23:07 <jle`> nil: i don't think that impacts the relevance of the example, since we aren't comparing Monad and Applicative, but rather Monad and (no constraints at all)
14:23:13 <nil> er, "why is Maybe an Applicative?"
14:23:44 <jle`> if we were trying to illustrate the difference between Monad and Applicative then it wouldn't be a good example ... but that difference is not really relevant here
14:24:01 <nil> fair
14:24:07 <jle`> the heart of the issue is "why would we think of Maybe in terms of abstractions it implements, instead of just as a normal data type without any abstractions implemented at all?"
14:24:17 <monochrom> Anyone who uses Maybe or Either in anger will run into the need for at least one of: fmap, <*>, <|>, >>=.  Just look at Rust.
14:25:02 <monochrom> (And again I just mean fmap, <*>, <|>, >>= tailor-made to Maybe or Either.)
14:25:37 <monochrom> For example Rust has "use ? instead of ; to end your command" as an Either-specific >>= or >>
14:25:39 <dolio> Actually, it's possible that the neglect tells you even more than I was thinking before.
14:26:27 <nil> dolio: what do you mean?
14:26:35 <dolio> Many of those functions are actually less useful in OCaml than they are in Haskell.
14:26:46 <jle`> hm, i just realize that ocaml doesn't even have an Ord-based sort
14:26:53 <dolio> Because eager evaluataion encourages you to not abstract things, due to performance considerations.
14:27:46 <jle`> ocaml only has sort :: (a -> a -> Int (???)) -> [a] -> [a], so maybe sort was not a very convincing example for an ocamler who is happy with always providing comparison functions
14:28:42 <dolio> <|> and <*> will evaluate things they don't have to.
14:28:44 <monochrom> OCaml also has + for bounded int, .+ for floating point, ...
14:28:56 <dolio> So you don't use them.
14:29:08 <nil> +.
14:29:12 <dolio> You just inline them everywhere, or else your code is penalized. :)
14:29:29 <monochrom> But >>= doesn't suffer that.
14:29:38 <dolio> Yeah, that's true.
14:29:45 <heatsink> I've written and used a decision tree monad in C++11.  It was very unpleasant.
14:29:54 <nil> ocaml doesn't have a composition operator
14:30:12 * hackage yx 0.0.3.0 - Row-major coordinates  https://hackage.haskell.org/package/yx-0.0.3.0 (mtth)
14:30:47 <jle`> hm. i suppose *if* you can convince an ocamler that sort :: Ord a => [a] -> [a] is useful, then you should also be able to convince them that sequence :: Monad m => [m a] -> m [a] is useful
14:30:49 <slack1256> Is there a way to know from ghc-pkg if a library is installed with profiling information?
14:31:11 <heatsink> I didn't manage to convey the point that avoiding language support for monads doesn't mean you can avoid monads.
14:31:45 <jle`> but i haven't programmed ocaml long enough to know what it would take to convince an ocamler that sort :: Ord a => [a] -> [a] is useful
14:31:51 <nil> jle`: but how would you write these functions? ocaml doesn't have typeclasses, or any equivalent that i know of
14:32:10 <jle`> right, my point is that you'd have to convince them that typeclass-based abstractions are useful
14:32:11 <dolio> You'd have to use modules.
14:32:14 <monochrom> IMO this is what happened. SML and OCaml people just use the exception system, so they don't need Either and its >>=, and by extension they aren't seriously about Option.  Rust is cautious about exceptions, they learned from Haskell and use Result (our Either) instead, and give you "?" for >>=.
14:32:31 <dolio> Which are very heavy weight, which is the other thing these examples are telling you.
14:32:39 <dolio> There's a barrier to how useful small abstractions are.
14:33:54 <heatsink> What do you mean by heavy weight?
14:34:06 <jle`> it's Sapir-Whorf, but actually real
14:34:32 <monochrom> heatsink: What do you say about learning integer addition at school, avoiding the mention of "monoid", and avoiding monoids? >:)
14:34:39 <dolio> heatsink: It takes a significant amount of physical typing to use it.
14:34:52 <monochrom> (Hell I could also escalate it to "ring" and "field".)
14:34:56 <nil> jle`: :D
14:35:50 <heatsink> monochrom: It's useful to learn integer addition as a specific case first
14:35:53 <monochrom> (Guess what?  I could also escalate it to "learn set theory, avoid mention of 'category', avoid category".  Fun fact: The set-theory-textbook notation "f:A->B" came from category theory.)
14:36:12 <heatsink> Maybe a better analogy is C code bases that have 20 monomorphic implementations of linked lists
14:36:47 <heatsink> At some point, you should realize that it's worth the time to learn generics instead of writing yet more specialized implementations
14:36:48 <monochrom> And Go, too.
14:37:10 <monochrom> https://twitter.com/mosheroperandi/status/856946180810354688
14:37:35 <nh> Ada is an example of a language that does generics nicely
14:37:47 <monochrom> C can be excused because 1960s, and Ritchie had other priorities.
14:37:59 <monochrom> IIUC Go's excuse is "faster compiler" that's it.
14:38:09 <heatsink> Wow.  They use a preprocessor for generics
14:38:36 <monochrom> "our edit-compile-test cycle is oh-so-holier-than-thou fast"
14:38:51 <monochrom> My refutation is "why not an interpreter?"
14:39:26 <lavalike> they have gone researched and implemented a couple generics implementations and dropped them, planning and working on a new one for Go 2
14:39:44 <monochrom> All of {lisp, scheme, *ml, haskell, python, javascript, ...} has shown that our edit-load-test cycle is oh-so-fast too.
14:40:12 <monochrom> and some of them (*ml, haskell, ...} also show that this doesn't give up on polymorphism.
14:40:37 <nh> l
14:41:13 <lavalike> the latest public talk about the topic is here https://www.youtube.com/watch?v=WzgLqE-3IhY
14:41:29 <nolrai> do de do..letting my possibly in a infinite loop possibly just slow program run...
14:42:42 <monochrom> But is Go 2 like Haskell 2020? >:)
14:43:03 <monochrom> Actually let me up the game.  Is Go 2 like Dependent Haskell?  >:)  #shotsfired
14:43:08 <dolio> monochrom: Are you sure it's not because the people who made it have been in stasis since the 80s?
14:43:20 <monochrom> ("like" in terms of release date)
14:43:41 <monochrom> Hey I want to respect Pike!
14:44:06 <monochrom> I want to believe that Pike is not stupid!
14:44:51 <slack1256> Even the Caesar went to shit sometimes :-P .
14:45:06 <ollehar> Ocaml people usually know haskell too and understand the trade-offs
14:45:28 <ollehar> No reason to be religious about it
14:46:42 <lavalike> well they do put resources in it, but nobody knows the future
14:47:27 <monochrom> But we can make bets. (I'm a Bayesian!)
14:48:05 <TheCommieDuck> how do I thread functions of the form f :: State -> (Result, State) through a do block? rn I'm doing do { s <- get ; let (x, y) <- f s ; put y ; x }, but it feels like I should be able to do it more easily
14:48:06 <monochrom> Which one of the following three will be released first?  Place your bet!  Algol 68, Go 2, Dependent Haskell.
14:48:38 <dolio> :t state
14:48:39 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
14:48:50 <lavalike> I wouldn't bet a consequential sum on any of those (:
14:49:14 <monochrom> Yeah I'm just teasing
14:49:36 <TheCommieDuck> ...oh, that makes sense. >___<
14:50:10 <monochrom> In all likelihood Go 2 will be released in reaonable time because enough people work on it and it is not as difficult as Dependent Haskell.  I threw in Algol 68 there just for jokes.
14:57:12 <ollehar> jle`
14:57:17 <ollehar> Hm
14:58:37 <ollehar> nil, ocaml can emulate type classes with functors, but it's not used much, I think
14:58:48 <nil> :)
14:59:01 <ollehar> But who knows what's idiomatic out there!
14:59:10 <nil> it's funny that what ocaml calls functors have nothing to do with functors in haskell, or in category theory for that matter
14:59:30 <nil> same with C++
15:00:03 <monochrom> Actually I think it does to category theory.  Let modules be objects.
15:00:12 <nil> then functors are morphisms.
15:00:13 <ollehar> I know! Sorry for the confusion. A functor in ocaml is a module function which produces another module.
15:00:17 <nil> er.
15:00:24 <nil> then "ocaml functors" are morphisms.
15:00:30 <monochrom> C++'s is of course "function operator -> func...tor"
15:01:28 <nil> actually, no; ocaml functors are morphisms in the category of ocaml signatures (modules are "inhabitants" of these signatures)
15:02:39 <monochrom> How about this, objects are structs and sigs, morphisms are those :> relations.
15:02:59 <nil> :> ?
15:03:16 <monochrom> "this struct implements this sig"
15:03:40 <nil> what's the identity morphism for a struct? for a sig?
15:03:53 <dolio> I'm not sure it actually makes sense to say you can emulate type classes with modules unless you also say you can emulate it by passing more arguments to your functions manually.
15:04:30 <hololeap> is there a way to force a function like foldlWithIndex to be strict like foldl'?
15:04:32 <dolio> Or functors, rather.
15:04:58 * nil . o O ( can a module contain other modules? )
15:05:20 <nil> (anyway, i think we've gone a bit offtopic)
15:06:17 <dolio> Unless features have been added to do it.
15:07:08 <ChaiTRex> hololeap: what is the type of foldlWithIndex?
15:07:47 <nil> hololeap: you can't force a function to become strict, but you can copy its definition into your source code and make it use foldl' instead
15:08:09 <hololeap> nil: sorry, i saw it in GHCi. it's from Data.Sequence
15:08:18 <hololeap> foldlWithIndex :: (b -> Int -> a -> b) -> b -> Seq a -> b 
15:08:24 <hololeap> but the question remains
15:09:02 <hololeap> or can you force foldMap to be strict?
15:09:09 <nil> the answer remains too!
15:09:34 <ChaiTRex> @src Data.Sequence.foldlWithIndex
15:09:34 <lambdabot> Source not found. Where did you learn to type?
15:09:53 <hololeap> oops, i meant to respond to ChaiTRex. i didn't see your answer, nil
15:09:55 <nil> @src Data.Sequence.Internal.foldlWithIndex 
15:09:55 <lambdabot> Source not found. Are you on drugs?
15:10:13 <nil> grr. https://hackage.haskell.org/package/containers-0.6.2.1/docs/src/Data.Sequence.Internal.html#foldlWithIndex
15:11:04 <hololeap> well, i was hoping there might be some way to do it within the function you pass in using BangPatterns or something
15:11:55 <monochrom> Hrm I be damend, In Foldable default implementation of foldl' is in term of foldr, foldr' is in terms of foldl
15:12:13 <ChaiTRex> hololeap: you can use let answer = whatever in seq answer answer, in your function
15:15:11 <monochrom> seq answer answer = answer
15:15:55 <monochrom> In plain English, "please evaluate me when evaluating me"
15:19:39 <monochrom> hololeap: "foldl' f z0 xs = foldr f' id xs z0  where f' x k z = k $! f z x" in Foldable default.  Maybe you can use this idea to gain foldlWithIndexButStrict from vanilla foldrWithIndex.
15:21:27 <monochrom> I've got to put this on my exam! >:)
15:21:49 <hololeap> the variables they chose for that make it extra confusing
15:22:10 <hololeap> well, maybe not
15:24:26 <hololeap> either way, it makes my head hurt trying to unpack it
15:26:10 <dolio> that might be the way foldl is defined now, even. There were some optimizations added to GHC to make it viable a while back.
15:27:51 <dolio> I was going to say 'recently' but it probably isn't recent anymore.
15:28:28 <nolrai> What does the ".\.\" in "Par.Cont.>>=.\.\" mean in a *.prof file?
15:36:18 <AWizzArd> shapr: sounds good
15:51:14 <sarahzrf> when would seq answer answer be useful o.O
15:51:52 <EvanR> it doesn't do anything
15:51:59 <sarahzrf> okay i didnt think so
15:51:59 <monochrom> pyschological comfort >:)
15:52:02 <ChaiTRex> sarahzrf: If you want foldl' like eagerness in a foldl-like function
15:52:16 <sarahzrf> ChaiTRex: wat
15:52:20 <sarahzrf> what difference would it make
15:52:30 <EvanR> nah
15:52:34 <EvanR> do it like this
15:52:37 <EvanR> @src foldl'
15:52:37 <lambdabot> foldl' f a []     = a
15:52:37 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:53:09 <ChaiTRex> EvanR: That's not a functional argument to foldlWithIndex
15:53:09 <dolio> ChaiTRex: seq in the function you pass to foldl doesn't do what you want.
15:53:10 <EvanR> the two args to seq need to at least be different to make a difference
15:53:30 <monochrom> Let's spread the next level myth!  seq x (seq x (seq x x)) evaluates deeper (3 levels)!
15:53:56 <EvanR> fix (seq x) ?
15:54:01 <sarahzrf> owo
15:54:15 <monochrom> Yeah! fix (seq x) = rnf x
15:54:23 <dolio> ChaiTRex: The problem is that foldl isn't strict in the accumulator, so your seq in the function only ensures that the accumulator is strict in all previous accumulators.
15:54:25 <sarahzrf> genius
15:54:35 <sarahzrf> > fix (seq 3)
15:54:37 <lambdabot>  *Exception: <<loop>>
15:55:23 <EvanR> ChaiTRex: yeah so that foldl' would need to be modified
15:55:46 <EvanR> but zipping over the list with [0..] would be simpler
15:56:00 <EvanR> folding over the zipped with that list
15:56:31 <dolio> (I'm a bit loose with the terminology, there.)
16:05:07 <hololeap> just like a haskeller to play fast and loose ;)
16:22:11 * hackage tmp-postgres 1.7.0.1 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.7.0.1 (JonathanFischoff)
16:36:41 * hackage store 0.6.1 - Fast binary serialization  https://hackage.haskell.org/package/store-0.6.1 (MichaelSloan)
16:39:41 * hackage advent-of-code-api 0.2.2.0 - Advent of Code REST API bindings and servant API  https://hackage.haskell.org/package/advent-of-code-api-0.2.2.0 (jle)
16:43:42 * hackage store 0.7.0 - Fast binary serialization  https://hackage.haskell.org/package/store-0.7.0 (MichaelSloan)
16:58:54 <jackdk> my favourite thing to do with `fix`
16:58:57 <jackdk> > fix error
16:58:59 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
17:01:18 <jle`> > unfix error
17:01:19 <lambdabot>  all better
17:01:37 <nil> :D
17:26:27 <jackdk> rofl
17:35:38 <sm[m]> those wild and crazy, slap-dash, happy-go-lucky haskellers
17:43:56 * jgt feels seen
18:06:56 <koz_> LOL, unfixing errors.
18:34:42 <dmwit> blaze-builder, lucid. What others should I be looking at before I decide?
19:20:50 <MarcelineVQ> dmwit: before you decide to make your own? :>
19:28:49 <int-e> sm[m]: you should see us frivolously tying knots...
19:31:08 <MarcelineVQ> why can I hold all these loops
19:45:42 <nicknotfound> how we implement product and sum type in other languages? use enum to implement sum type, and structure to implement product type?
19:50:37 <heatsink> Sometimes a product type is implemented as a sum type where only some fields hold valid data
19:51:58 <heatsink> If you want a type that's an X or a Y, you can implement it with a type that's an X and a Y.  You would only use part of the data in the type.
19:52:31 <dsal> Anyone know why this might fail to do what I want?  I stopped feeding it, AFAICT, but my process did not die. https://www.irccloud.com/pastebin/j5hkuiFA/watchdog.hs
19:53:38 <dsal> nicknotfound: which other languages?
19:54:26 <nicknotfound> C?
19:54:59 <dsal> a struct is a product type in C.
19:55:09 <nicknotfound> I never understand what enum is used for
19:55:19 <dsal> A union can kind of implement a sum type,  but you need tagging.
19:55:54 <nicknotfound> until some people said they use enum to do sum type
19:56:04 <dsal> enum is useful when you just want to name a few numbers that don't collide.  Haskell has an Enum class which is a more useful generalized thing.
19:56:04 <heatsink> Enum in C is used for tag values
19:56:05 <nicknotfound> Kotlin has enum
19:56:56 <nicknotfound> what about Java?
19:56:59 <dsal> You could use the enum for tags, but an enum by itself only gives you a pretty small concept  of sum types.
19:57:16 <heatsink> In Java, it's more common to use subclasses for sums
19:57:31 <nicknotfound> and product type?
19:57:32 <dsal> I've been making it a point to forget as much as I can about java.
19:58:01 <dsal> A class is a product type.
19:58:06 <dsal> I'm a little confused by your question.  Do you  understand what sum and product types are?
19:58:08 <nicknotfound> in OOP, they can use subclasses to implement product and sum type?
19:58:24 <nicknotfound> Bool is a sum type
19:58:31 <heatsink> They can use subclasses to implement sum types
19:58:40 <nicknotfound> and Maybe is a product type
19:58:56 <dsal> Maybe is a sum type.  It adds one.
19:59:04 <heatsink> Maybe is a sum type.  It has two constructors, called Just and Nothing.
19:59:06 <nicknotfound> no ,Maybe us a sum
19:59:13 <nicknotfound> sorry
19:59:30 <Lears> You can write sum and product data structures within the lambda calculus, so in principle any language with lambdas should have ADTs ... but actually having them be properly type checked may be difficult, depending on the type system.
20:00:07 <nicknotfound> Reader is a product type
20:00:17 <heatsink> If Java programmers were really faithful to OOP, they would have a class Bool with subclasses True and False
20:00:29 <dsal> product types multiply cardinality of values by the things they  stick together.  A pair is a product type that multiplies the cardinality of the values of fst with the cardinality of the values of snd.  Either is a sum type that adds the cardinality of Left to the cardinality of Right.
20:00:40 <Lears> No, Reader is the function arrow, which isn't even algebraic.
20:00:40 <heatsink> and to dispatch based on a Bool, they would write a visitor class with methods visit(True t) and visit(False f)
20:01:11 <dsal> nicknotfound: if Reader were a product type, what would it be the product of?
20:01:31 <dsal> heatsink: Some of us have programmed in smalltalk.  heh
20:01:41 <nicknotfound> fine...
20:01:53 <Lears> Though I suppose any newtype is technically a trivial product in the sense that `product [x] = x`.
20:02:29 <MarcelineVQ> Lears: iiuc algebraicly -> is exponentiation, e.g. a -> b  is  b^a
20:02:43 <nicknotfound> data Person = Person String Int , this is a product type ok?
20:02:51 <dsal> Yeah, I've heard -> referred to as "exponent types"
20:02:59 <dsal> nicknotfound: why?
20:03:53 <nicknotfound> I don’t know
20:04:42 <dsal> nicknotfound: In your example, your Person type's cardinality is every possible String * every possible Int
20:05:23 <nicknotfound> ok
20:06:40 <dsal> % :i Maybe
20:06:41 <yahb> dsal: data Maybe a = Nothing | Just a -- Defined in `GHC.Maybe'; instance Alternative Maybe -- Defined in `GHC.Base'; instance Applicative Maybe -- Defined in `GHC.Base'; instance Eq a => Eq (Maybe a) -- Defined in `GHC.Maybe'; instance Functor Maybe -- Defined in `GHC.Base'; instance Monad Maybe -- Defined in `GHC.Base'; instance MonadPlus Maybe -- Defined in `GHC.Base'; instance Semigroup a => Monoid (Maybe
20:07:06 <dsal> Maybe is a sum type.  Its cardinality is the cardinality of a, plus the cardinality of Nothing (which is 1)
20:07:20 <dsal> % :i Either
20:07:21 <yahb> dsal: data Either a b = Left a | Right b -- Defined in `Data.Either'; instance [safe] Control.Monad.Trans.Error.Error e => Alternative (Either e) -- Defined in `Control.Monad.Trans.Error'; instance Applicative (Either e) -- Defined in `Data.Either'; instance (Eq a, Eq b) => Eq (Either a b) -- Defined in `Data.Either'; instance Functor (Either a) -- Defined in `Data.Either'; instance Monad (Either e) -- Defi
20:08:26 <dsal> I built a thing for a work project that was very similar to Maybe, but instead of being  +1, mine was +2.  It's isomorphic to Maybe Maybe, but I didn't want Maybe Maybe.
20:09:10 <nicknotfound> what is ‘isomorphic’? what laws it has?
20:09:16 <dsal> I called it Possibly because that's not confusing.  I have a conversion function called possiblyMaybe because I listened to Björk in high school.
20:10:02 <jle`> nicknotfound: here it means that you can match every value of one type to every value of the other type, one-ot-one
20:10:35 <heatsink> Just a | Nothing | FileNotFound
20:11:02 <dsal> haha. yes
20:11:09 <nicknotfound> jle` that would be the same type?
20:11:10 <dsal> Mine was    Unknown  | No | Yes a
20:11:29 <jle`> nicknotfound: type X is isomorphic to type Y if every value in X matches with exactly one other value in Y, and vice-versa
20:12:01 <jle`> nicknotfound: for example `Either () a` is isomorphic to `Maybe a`, because you can match up Left () with Nothing, and Right x with Just x
20:12:29 <dsal> Maybe Maybe a would map to Possibly a in a kind of gross way.    Nothing = Unknown.   Just Nothing = No.  Just  Just x =  Yes x
20:12:35 <jle`> and `Either Bool a` is isomorphic to `Maybe (Maybe a)`, because you can match Left False with Nothing, Left True with Just Nothing, and Right x with Just (Just x)
20:12:37 <nicknotfound> ok
20:13:03 <dsal> Oh yeah, Either Bool would be a lot less dumb than Maybe Maybe
20:13:20 <jle`> well, dumbness only depends on what you want to use it for
20:13:54 <nicknotfound> they have the same number of types
20:14:00 <jle`> nicknotfound: same number of values
20:14:01 <nicknotfound> same values
20:14:07 <jle`> different values
20:14:10 <dsal> nicknotfound: values
20:14:20 <jle`> the values are different, but their number is the same
20:14:34 * dsal has super high latency
20:14:44 <dsal> isomorphism just requires there are functions  to convert back and forth.
20:14:49 <nicknotfound> yeah, same number of values, but different value
20:15:41 <nicknotfound> then Bool and Maybe a are isomorphic?
20:16:10 <jle`> Bool and Maybe () are isomorphic
20:16:11 <heatsink> Either Bool a and Maybe (Maybe a) are isomorphic
20:16:13 <dsal> Bool and Maybe  ()
20:16:39 <nicknotfound> oh, it need to be concreted
20:16:57 <jle`> not necessarily
20:17:04 <nicknotfound> Bool and Maybe Int?
20:17:14 <jle`> `Bool and Maybe a` are isomomorphic if 'a' has exactly one inhabitant
20:17:23 <dsal> How many possible bools are there?
20:17:24 <dsal> How many Ints?
20:17:37 <jle`> Bool and Maybe Int doesn't work, because you could map False to Nothing, True to Just 0 ....
20:17:46 <nicknotfound> oh , I see
20:17:47 <jle`> but then there is nothing that maps to Just 1, Just 2, Just 3, Just 4, etc.
20:17:52 <jle`> so you're missing some out
20:18:11 <jle`> so no go for isomorphism :'(
20:18:43 <nicknotfound> data P = P, Maybe P is isomorphic to Bool
20:19:03 <dsal> Yeah.
20:19:20 <jle`> indeed, you could map False to Nothing and True to Just P, and now everyone is accounted for
20:19:52 <jle`> writing isomorphisms can be fun
20:20:13 <nicknotfound> useful?
20:20:15 <jle`> you would write to :: X -> Y, and from :: Y -> X, and prove that to . from = id, and from . to = id
20:20:34 <jle`> useful? situational, maybe
20:20:36 <jle`> fun? always ~
20:20:39 <dsal> I do a lot of networking stuff.  I need to verify my data structures and their wire encoding are isomorphic.
20:21:22 <dsal> I don't necessarily do that exhaustively, but if I can represent something that I can't put on the wire and get back in tact, then things go bad.
20:27:44 <dsal> Woo.  I contributed to a lens related project.  Now I just need to start understanding lens.
20:31:21 <nicknotfound> then what is polymorphic?
20:31:53 <nicknotfound> and ad-hoc?
20:34:01 <dsal> Are you just asking for definitions?
20:34:28 <nicknotfound> yeah
20:56:53 <sarahzrf> jle`: Bool has 3 inhabitants, Maybe () has 4
20:57:41 * hackage pine 0.1.0.0 - Functional Reactive 2D Game Framework  https://hackage.haskell.org/package/pine-0.1.0.0 (Grinshpon)
20:58:34 <sarahzrf> lazy languages are not the right setting for this kind of reasoning 😛
20:58:42 <ammar2> sarahzrf: what's the 3 inhabitants of Bool?
20:58:50 <sarahzrf> ⊥, True, and False
20:59:30 <sarahzrf> inb4 someone links the fast and loose reasoning paper ~_~
20:59:45 <jle`> ~___~
21:00:22 <ChaiTRex> There's also a fourth: FileNotFound.
21:00:32 <sarahzrf> 😱
21:01:28 <MarcelineVQ> or my favorite inhabitant "Segmentation fault (core dumped)"
21:01:42 * sarahzrf files that under ⊥
21:02:32 <ammar2> Segmentation fault is pretty ⊤
21:02:44 <sarahzrf> how so?
21:02:52 <sarahzrf> perhaps it's more 0 than ⊥
21:15:41 * hackage pine 0.1.0.1 - Functional Reactive 2D Game Framework  https://hackage.haskell.org/package/pine-0.1.0.1 (Grinshpon)
21:29:41 * hackage stylist 1.1.0.0 - Apply CSS styles to a document tree.  https://hackage.haskell.org/package/stylist-1.1.0.0 (alcinnz)
22:30:29 <jluttine> Why doesn't this have a monoid instance? MaybeT [Just 1, Just 2, Just 3]
22:30:43 <jluttine> Without monad transformer MaybeT it has
22:31:20 <jle`> jluttine: presumably it's because there is more than one useful instance
22:32:07 <jle`> if that's the case then it's a judgment call ultimately
22:32:32 <jluttine> jle: Hmm.. What would those be? I can't come up with anything else as similar to without MaybeT appending..
22:33:28 <jluttine> In general, I'd expect monad transformers to provide monoid instance based on the monoid instance of the outer monad. Or is this somehow bad..
22:33:29 <ovitus> is there a way for a do notation to also create variables globally?
22:34:19 <jle`> jluttine: there's the instance with Ap, which is (<>) = liftA2 (<>) and mempty = pure mempty
22:34:23 <jle`> jluttine: what is 'the outer monad' here?
22:34:43 <jle`> ovitus: do notation is just sugar for applications of (>>) and (>>=)
22:34:44 <jluttine> jle`: the list monad
22:35:25 <jle`> jluttine: what is the outer monad 'in general'?
22:35:36 <jle`> monad transformers don't really have a general concept of 'inner' or 'outer' monad
22:37:32 <jluttine> jle`: SomeMonadTransformer :: m1 m2 a -> SomeMonadTransformer m1 a     <- outer monad is m1. But yeah, I'm not thinking of all monad transformers in general, just this kind of MaybeT, StateT, ReaderT etc
22:38:09 <jle`> `m1 m2 a` is a kind error
22:38:15 <jle`> if m1 is a monad
22:38:30 <jluttine> jle`: yes, sorry, meant m1 (m2 a)
22:38:35 <jle`> what is m2 here?
22:38:42 <jluttine> the inner monad :)
22:38:44 <jle`> and how does it relate to SomeMonadTransformer ?
22:39:10 <jle`> okay, so for ReaderT r m, what is m2 ?
22:40:49 <jle`> for StateT r m, what is m2?
22:40:58 <jle`> s/r/s
22:41:20 <jle`> ovitus: do notation is just sugar for normal function application, so if you can't do it with normal function application, you can't do it with do notation
22:41:37 <jle`> jluttine: my point is that...'inner and outer monad' doesn't really have any sort of meaning for monad transformers even in a limited general sense
22:42:20 <ovitus> how can I set variables and apply a function at the same time?
22:42:29 <jle`> jluttine: you say that you have SomeMonadTransformer :: m (m2 a) -> SomeMonadTransformer m a
22:42:34 <ovitus> global variables that is
22:42:38 <jle`> jluttine: ...are there any actual situations where this is true?
22:42:52 <EvanR> haskell doesn't do globals
22:42:55 <jluttine> jle`: ok. then i've understood them incorrectly.. i've thought these monad transformers extend Compose so that they add the Monad instance to it. and Compose has "inner" and "outer" concept as far as I understad
22:43:13 <jluttine> jle`: MaybeT?
22:43:37 <jle`> jluttine: funny i just tweeted about this exact misconception a few hours ago, haha
22:43:45 <jle`> jluttine: MaybeT, ok. any other examples?
22:44:01 <jluttine> jle`: don't know, that was my only example :)
22:44:16 <jluttine> IdentityT?
22:44:18 <jle`> so by 'monad transformers in general', you mean 'only MaybeT' 
22:44:29 <jle`> ah, you found the other one ;)
22:44:34 <ovitus> re-assign constants and apply a function simultaneously 
22:44:52 <EvanR> reassign constants... ?
22:45:07 <ovitus> like I want to do something like
22:45:20 <ovitus> x = 10; y = 20; x + y
22:45:28 <EvanR> haskell also doesn't do assignment
22:45:40 <jle`> ovitus: hm, what do you mean by "do" something?
22:45:44 <EvanR> no assignment, no globals
22:45:49 <ovitus> using the do notation
22:45:51 <jle`> ovitus: you can have main = do let x = 10; y = 20; print (x + y)
22:46:03 <jluttine> jle`: now i'm just really confused.. so these typical monad transformers don't extend Compose? that's how one book taught them as far as i understood..
22:46:13 <ovitus> right but if I try and do x + y outside of that those variables are not set
22:46:30 <ovitus> they are local to main?
22:46:37 <jle`> ovitus: indeed, because let bindings in do notation is just 'aliasing'
22:46:48 <jle`> ovitus: that's guar for let x = 10; y = 20 in print (x + y)
22:46:56 <jle`> it aliases x to 10, and y to 20
22:47:02 <jle`> jluttine: your book taught you wrong :)
22:47:09 <jle`> jluttine: monad trnasformers do not extend any sort of composition
22:47:33 <ovitus> there has to be a way to set variables and apply a function at the same time?
22:47:43 <jle`> what do you really want to do?
22:47:48 <EvanR> let x = f y in ...
22:47:54 <jle`> you can define x = 10 for your whole file
22:47:59 <jle`> at the top level
22:48:59 <ovitus> but if I was in ghci and wanted to do it in one command
22:49:07 <jle`> do... what?
22:49:15 <jluttine> jle`: probably i have then just misunderstood but indeed the book did present the stuff in such a way that i got that impression. it was this "haskell programming from first principles" book. it first showed how Compose can compose any two applicatives in general. but to get a monad instance for such a composition, one needs to write inner-monad specific monad transformer.
22:49:18 <ovitus> define x and y, apply a function
22:49:23 <jle`> % do let x = 10; y = 20; print (x + y)
22:49:23 <yahb> jle`: ; <interactive>:186:37: error: parse error (possibly incorrect indentation or mismatched brackets)
22:49:32 <jle`> % do let {x = 10; y = 20}; print (x + y)
22:49:32 <yahb> jle`: 30
22:49:35 <jle`> ta dah :)
22:49:40 <jle`> or also just:
22:49:50 <EvanR> > let x = 10; y = 20 in x+y
22:49:52 <lambdabot>  30
22:50:03 <jle`> ^ yeah, that :)
22:50:03 <ovitus> cool let me try these
22:50:24 <jle`> jluttine: hm. i respect that book a lot, but i think that statement is wrong
22:50:43 <nshepperd1> Rather than extending Compose, Monad transformers are more like a totally different approach which gives powers Compose does not
22:52:09 <ovitus> wait these are using do notation.. I need the variables as constants
22:52:11 <jle`> jluttine: it's easy to see that it isn't true because it falls apart for every monad transformer besides MaybeT and IdentityT, and it even falls apart for MaybeT
22:52:30 <jle`> jluttine: because `Compose m Maybe` gives an (*>) that is different than (*>) for MaybeT m
22:52:43 <jle`> ovitus: can you explain what you actually want or need?
22:52:50 <jle`> in the big picture sort of thing?
22:52:56 <jle`> ovitus: also, EvanR's example doesn't use do notation
22:53:25 <jle`> you can assign multiple constants in one do notation command:
22:53:31 <EvanR> my example doesn't use do notation, sets variables, applies functions, uses constants, all at aonce
22:53:38 <jle`> % let myconst1 = 3; myconst2 = 100
22:53:39 <yahb> jle`: 
22:53:42 <EvanR> it can't be wrong
22:53:45 <jle`> % myconst3
22:53:45 <yahb> jle`: ; <interactive>:189:1: error:; * Variable not in scope: myconst3; * Perhaps you meant one of these: `myconst1' (line 188), `myconst2' (line 188)
22:53:49 <jle`> % myconst2
22:53:49 <yahb> jle`: 100
22:53:59 <ovitus> well this is to be applied to Tidalcycles
22:54:01 <nshepperd1> It's only an extension in the sense that Compose and transformers can both be used for the general purpose of combining effects
22:54:28 <ovitus> trying to do exactly that, set variables (constant) but also apply a function, that will do some sequencing with those variables
22:54:30 <jle`> i wouldn't even say that monad transformers are for 'combining' effects -- they're for 'adding' effects
22:54:37 <jle`> ovitus: and you want to do it all in one line in ghci?
22:54:39 <ovitus> but they key is the variables are not local to just that function, they are constant
22:54:46 <nshepperd1> Sure, adding
22:55:16 <jluttine> Where can I finc Compose? That is, what do I need to import to get it in ghci?
22:55:16 <jle`> ovitus: this all seems pretty vague still, since you can just declare constants in ghci
22:55:24 <jle`> jluttine: Data.Functor.Compose
22:55:31 <jle`> ovitus: can you give us a specific example?
22:55:44 <ovitus> you can, but set I set x to 10 and y to 20
22:56:02 <jle`> x = 10, and y = 20
22:56:04 <ovitus> I then have to enter another line to add them, or do whaterver
22:56:06 <jluttine> jle`: Thanks! Where can I find such information other than asking from IRC? :)
22:56:20 <jle`> jluttine: for me i use the [index] link in the documentation for 'base'
22:56:25 <jle`> @hackage base
22:56:25 <lambdabot> http://hackage.haskell.org/package/base
22:56:25 <jluttine> For instance, this didn't tell: https://wiki.haskell.org/Compose
22:56:38 <jle`> ovitus: so your issue is that you don't want to press <enter>?
22:56:41 <jle`> in ghci?
22:56:50 <EvanR> you want to set variables in ghci, then "apply a function", to what? with what effect
22:57:14 <jluttine> jle`: Thanks, that's really useful!
22:57:30 <ovitus> well say I'm writing variables that contain functions with allot of parameters and I'm changing the arguments to them
22:57:45 <ovitus> but then I want to use those functions within another function to sequence them
22:58:11 <EvanR> sounds like you should be writing a source code file and reloading after changes
22:58:18 <EvanR> with :r
22:59:08 <jluttine> jle`: How is (*>) different for Compose m Maybe and MaybeT m? I just tried a few examples and I get the same result (except the prefix Compose vs MaybeT in the result)
23:00:19 <jle`> % runMaybeT $ MaybeT (pure Nothing) *> lift (putStrLn "hi")
23:00:20 <yahb> jle`: Nothing
23:01:01 <jle`> % getCompose $ Compose (pure Nothing) *> Compose (Just <$> putStrLn "hi")
23:01:02 <yahb> jle`: ; <interactive>:195:1: error: Variable not in scope: getCompose :: f0 b0 -> t; <interactive>:195:14: error:; * Data constructor not in scope: Compose :: f1 (Maybe a0) -> f0 a1; * Perhaps you meant variable `icompose' (imported from Control.Lens); <interactive>:195:40: error:; * Data constructor not in scope: Compose :: IO (Maybe ()) -> f0 b0; * Perhaps you meant variable `icompose' (imp
23:01:13 <jle`> % import Data.Functor.Compose
23:01:13 <yahb> jle`: 
23:01:27 <jle`> % getCompose $ Compose (pure Nothing) *> Compose (Just <$> putStrLn "hi")
23:01:27 <yahb> jle`: hi; Nothing
23:01:38 <jle`> % runMaybeT $ MaybeT (pure Nothing) *> MaybeT (Just <$> putStrLn "hi")
23:01:38 <yahb> jle`: Nothing
23:01:46 <jle`> jluttine: one prints 'hi', the other doesn't
23:02:08 <jle`> that's because Compose m Maybe is not short-circuiting
23:03:23 <jle`> % runMaybeT $ MaybeT ("hello", Nothing) *> MaybeT ("hello", Just 10)
23:03:23 <yahb> jle`: ("hello",Nothing)
23:03:45 <jle`> % getCompose $ Compose ("hello", Nothing) *> Compose ("hello", Just 10)
23:03:45 <yahb> jle`: ("hellohello",Nothing)
23:04:45 <jle`> jluttine: but actually, thanks for helping me track down some possible sources of this misconception. i was wondering earlier today where it might have come from
23:06:04 <jluttine> jle`: do you know what i should read to understand this correctly?
23:08:10 <jle`> understand what?
23:09:14 <jluttine> jle`: to fix this misconception i have regarding compose and monad transformers like MaybeT etc
23:10:07 <jluttine> jle`: i am really confused about that example you gave.. i thought MaybeT implements only the monad instance but keeps the applicative instance that Compose provides... then they should give the same result, but they don't..
23:10:27 <jle`> basically just detach the idea of monad composition and monad transformers in your head
23:10:37 <jle`> just understand monad transformers in terms of how they transform monads is good enough
23:11:13 <jle`> jluttine: the "point" of MaybeT is to add short-circuiting semantics to a monad
23:11:28 <jle`> so in order to do that, it has to be unrelated to ComposeT m Maybe, which does not have any short-circuiting semantics
23:14:28 <jluttine> jle`: ok, thanks. this was a bit mind blowing.. i thought i had a very clear understanding about this and then it turns out i didn't at all.
23:15:10 <jle`> jluttine: i don't think your understanding is toooo far off, but i just think you added extra things that didn't necessarily need to be there
23:15:23 <jle`> it's ok to understand monad transformers in how they enhance effects, without needing to link it to monad composition
23:17:21 <jluttine> jle`: yep. i had understood that in general monad transformers just transform monads, but i thought that these special cases like MaybeT, IdentityT, ReaderT, etc can be seen as monadic extensions of Compose. but it's good to know that it's not exactly true and it's better to think all of them as just transformations of monads..
23:21:45 <MarcelineVQ> monad transformers are equipment cards
23:22:16 <EvanR> so Identity is "naked and afraid" ?
23:33:26 <nshepperd1> Identity is bold and self confident
