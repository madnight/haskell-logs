00:05:08 <siwica> As for the previous discussion: https://syzygy-tables.info/ provides a web interface to "solve" all chess endgames with up to 7 pieces. That's the maximum number of pieces that all possible endgames were solved for, as far as I know.
00:05:42 <siwica> "The 7-piece tablebase contains 423,836,835,667,331 unique legal positions in about 18 Terabytes."
00:10:44 <siwica> There are some interesting findings: E.g. the endgame https://syzygy-tables.info/?fen=QN4n1/6r1/3k4/8/b2K4/8/8/8_b_-_-_0_1 leads to a forced mate for white in 1034 moves with optimal play from both sides. That's a records in this regard :D
00:10:49 <siwica> *record
00:12:47 <EvanR> so much for the 50 move rule !
00:14:11 <ammar2> how many moves is an average game?
00:15:25 <EvanR> https://chess.stackexchange.com/questions/2506/what-is-the-average-length-of-a-game-of-chess
00:15:58 <siwica> EvanR: Yeah, this one shows that due to the 50 move rule not all theoretically winnable endgames can be won in practice. 
00:33:12 <isovector1> hi all. haddock says there's an instance `Arbitrary Text.Pandoc.Definitions.Block`: https://hackage.haskell.org/package/pandoc-types-1.17.5.4/docs/Text-Pandoc-Definition.html#t:Arbitrary
00:33:29 <isovector1> but it doesn't appear in the file, nor can GHC find the instance
00:33:33 <isovector1> wondering wtf
00:35:30 <isovector1> ahh, they're orphans!
00:39:29 <EvanR> "Come to think of it, the Freer monad frees us from monads."
00:39:39 <EvanR> (oleg)
00:41:08 * hackage ip2proxy 2.2.0 - IP2Proxy Haskell package for proxy detection.  https://hackage.haskell.org/package/ip2proxy-2.2.0 (ip2location)
00:58:28 <AndreyH> Hi there! Could anyone please give a hint of why:
00:58:28 <AndreyH> This type checks: fmap_ :: (a->b) -> Either t a -> Either t b; fmap_ f (Left t) = Left t
00:58:28 <AndreyH> But this doesn't:  fmap_ :: (a->b) -> Either t a -> Either t b; fmap_ f l@(Left t) = l
00:58:28 <AndreyH> For me it looks basically the same thing, but the as-pattern "l" somehow interfering with types here.
00:59:43 <EvanR> second one returns l as-is, which has the wrong type
01:00:03 <boxscape> AndreyH "Left t" has the type "forall e . Either t e", but l isn't as polymorphic. It has the type "Either t a", with both type variables fixed
01:00:49 <EvanR> can you use "let polymorphism" here?
01:01:01 <boxscape> I would think so?
01:02:00 <EvanR> it didn't work, and i think it's because of what i said
01:02:15 <boxscape> oh you mean "let x = l"?
01:02:25 <EvanR> let l' = l in l'
01:02:37 <EvanR> l has the wrong second type variable
01:02:39 <boxscape> ok, I thought you meant "let x = Left l in x"
01:02:46 <boxscape> uh
01:02:50 <boxscape> Left t rather
01:04:06 <merijn> EvanR: That won't work, l is not polymorphic
01:04:15 <EvanR> right
01:04:41 <EvanR> i was thinking of the rule where if you let bind a specialized function you get the generalized version
01:04:58 <merijn> AndreyH: Basically, in your 2nd version you're relying on the observation that "l" happens to match "Left t", but those two facts are, to GHC, unrelated
01:05:19 <EvanR> unsafeCoerce l ? *ducks*
01:05:49 <merijn> AndreyH: So, as far as GHC is concerned you're trying to cast/coerce an expression to a different type, which isn't allowed
01:06:32 <boxscape> % Unsafe.Coerce.unsafeCoerce (Left 4 :: Either Int String) :: Either Int Double
01:06:33 <yahb> boxscape: Left 4
01:06:36 <EvanR> f (Left x) = Left x  seems like could be optimized?
01:06:57 <EvanR> don't make new data if form on the right matches the pattern
01:07:48 <AndreyH> merijn: Right, so if I change f to (a->a) it works with alias:  fmap_ :: (a->a) -> Either t a -> Either t a; fmap_ f l@(Left t) = l
01:08:04 <boxscape> EvanR do you have an example for where binding a specialized function gives you a more general version?
01:08:32 <merijn> AndreyH: Yeah
01:09:04 <merijn> EvanR: That seems likely, yes
01:09:44 <boxscape> I imagine unsafeCoerce would let you optimize quite a few things that you couldn't optimize otherwise?
01:10:22 <boxscape> or do you mean the compiler can optimize it?
01:10:24 <merijn> boxscape: EvanR's question was more whether GHC can/does that optimisation
01:10:29 <boxscape> ok
01:10:38 <merijn> Which seems likely, since it seems like a trivial enough optimisation
01:10:45 <boxscape> yeah that makes sesne
01:13:58 <EvanR> boxscape: nope... i just tried it and it doesn't work. So i'm thinking of yet something else!
01:14:21 <EvanR> maybe the part of HM where polymorphism is introduced using let
01:14:55 <boxscape> EvanR judging from wikipedia let generalization simply means that let bindings aren't monomorphized, whereas function arguments are
01:15:06 <merijn> That, yes
01:15:36 <EvanR> > let f (x:xs) = x in (f [1,2,3], f "abc")
01:15:38 <lambdabot>  (1,'a')
01:15:53 <AndreyH> merijn: My intention with alias "l" was to make the code more compact, because on the right side of the function I'm kind of using the "same thing" as on left. I'm a new to Haskell, currently learning it from the "First principles" book by Allen@Moronuki. Can you suggest some docs explaining this nitty gritty details of as-patterns?
01:15:54 <boxscape> (wikipedia calls it let polymorphism, actually)
01:16:10 <EvanR> > (\f -> (f [1,2,3], f "abc")) (\(x:xs) -> x)
01:16:12 <lambdabot>  error:
01:16:12 <lambdabot>      • No instance for (Num Char) arising from the literal ‘1’
01:16:12 <lambdabot>      • In the expression: 1
01:16:16 <boxscape> (not to say that generalization is wrong, but just saw that)
01:16:56 <EvanR> AndreyH: you had the right intuition, l is literally what was given as input
01:17:07 <EvanR> it just has the wrong type to stands as the output
01:17:18 <EvanR> Either a b not Either a c
01:17:45 <EvanR> so this will not come up in a discussion on as patterns
01:18:56 <boxscape> AndreyH what you tried is very similar to something like "intToInteger :: Int -> Integer; intToInteger n@(1) = n"; this doesn't work because n is an Integer, whereas "intToInteger n@(1) = 1" would work
01:19:03 <boxscape> uh
01:19:09 <boxscape> because n is an Int, I mean
01:19:34 <boxscape> % intToInteger :: Int -> Integer; intToInteger n@(1) = n -- making sure
01:19:34 <yahb> boxscape: ; <interactive>:71:54: error:; * Couldn't match expected type `Integer' with actual type `Int'; * In the expression: n; In an equation for `intToInteger': intToInteger n@(1) = n
01:21:44 <EvanR> this could never happen with mySlickFun c@'a' = 'a' because Chars don't involve polymorphism
01:22:07 <EvanR> 1 and 1 have different types, and turns out Left x and Left x have different types... due to polymorphism happening
01:22:21 <[exa]> -XOverloadedChars
01:22:37 <EvanR> really
01:22:46 <[exa]> no :]
01:22:59 <EvanR> -XOverloadedWhitespace
01:24:16 <EvanR> AndreyH: if anything find a section on polymorphism, like the kind in the type for Left :: forall a b . a -> Either a b
01:24:27 <boxscape> % (Left "hi" :: Either String Int) :: Either String Bool -- AndreyH, this is also the same problem
01:24:27 <yahb> boxscape: ; <interactive>:72:2: error:; * Couldn't match type `Int' with `Bool'; Expected type: Either String Bool; Actual type: Either String Int; * In the expression: (Left "hi" :: Either String Int) :: Either String Bool; In an equation for `it': it = (Left "hi" :: Either String Int) :: Either String Bool
01:36:24 <AndreyH> EvanR: So, in my own words I would say that as-pattern "fixes" all types inside the aliased expression which, in turn, doesn't allow alias to be used in an expression which requires some of the types to be different, like (a->b) in my example. Does it sound sane? 
01:36:56 <EvanR> the arguments to your function have their types fixed
01:37:03 <EvanR> good way to put it
01:38:02 <AndreyH> EvanR++
01:38:13 <EvanR> assuming you aren't using RankN, but that's another story
01:38:44 <AndreyH> merijn++
01:40:03 <boxscape> AndreyH I want to emphasize a distinction here - the as-pattern doesn't fix the type, l being a function argument fixes it
01:40:27 <EvanR> yeah nothing to do with as-patterns
01:40:39 <boxscape> % let l@(Left _) = Left String in (l :: Either String Int; l Either String Bool)
01:40:39 <yahb> boxscape: ; <interactive>:73:56: error: parse error on input `;'
01:40:55 <boxscape> oops
01:41:25 <boxscape> % let l@(Left _) = Left "test" in (l :: Either String Int, l :: Either String Bool)
01:41:25 <yahb> boxscape: (Left "test",Left "test")
01:41:48 <boxscape> AndreyH In this case, l is polymorphic, because it's bound in a let expression
01:43:14 <EvanR> boxscape: and you proved it has something to do with as-patterns :P
01:43:38 <boxscape> uh how? the same would work if I typed l instead of l@(Left _)?
01:43:40 <merijn> It's not really about "being in a let expression", "Left x" is polymorphic *in general*
01:43:47 <boxscape> fair
01:43:54 <merijn> :t Left 'c'
01:43:55 <lambdabot> Either Char b
01:44:12 <EvanR> boxscape: we were trying to do it without @ to prove it... so yeah
01:44:16 <merijn> AndreyH: So *normally* you get to pick "any 'b' you want"
01:44:22 <EvanR> just l would be a better example
01:44:42 <merijn> AndreyH: But in the context of your function, 'b' has already been picked *and fixed* by the functions' type signature
01:44:43 <boxscape> EvanR I wanted to make it as close as possible to the original function to show the contrast
01:45:15 <boxscape> :set -fprint-explicit-forall
01:45:17 <boxscape> % :set -fprint-explicit-forall
01:45:18 <yahb> boxscape: Some flags have not been recognized: -fprint-explicit-forall
01:45:22 <boxscape> % :set -fprint-explicit-foralls
01:45:23 <yahb> boxscape: 
01:45:25 <EvanR> > let l = Left 'c' in (l :: Either Char Int, l :: Either Char Double)
01:45:27 <lambdabot>  (Left 'c',Left 'c')
01:45:30 <boxscape> % :t Left 'c'
01:45:30 <yahb> boxscape: forall {b}. Either Char b
01:45:44 <EvanR> but i'm sure we are just confusing now
01:46:59 <EvanR> > (\l -> (l :: Either Char Int, l :: Either Char Double)) (Left 'c')
01:47:01 <lambdabot>  error:
01:47:01 <lambdabot>      • Couldn't match type ‘Int’ with ‘Double’
01:47:01 <lambdabot>        Expected type: Either Char Double
01:47:11 <EvanR> same issue and no @
01:51:49 <boxscape> Oh I just found out where the name for the old sort BOX came from https://en.wikipedia.org/wiki/System_U
01:53:22 <AndreyH> I think, it's finally starting to make sense for me how the type of 'l' alias is fixed by function's type signature:
01:53:22 <AndreyH> fmap_ :: (a->b) -> Either t a -> Either t b
01:53:22 <AndreyH> Here 'l@(Left t)' data c-tor match pattern as a 2nd argument to the fmap_ corresponds to the type 'Either t a' which obviously can't be used in place of 'Either t b' because a != b.
01:53:22 <AndreyH> Am I closer now? :)
01:53:54 <merijn> AndreyH: That's exactly it
01:54:44 <EvanR> \o/
01:54:49 <boxscape> (I feel like this would be less confusing if we didn't have implicit foralls)
01:55:27 <EvanR> conversely if we have explicit 'skolems'
01:56:13 <AndreyH> Folks, thanks a lot! Your help is invaluable!
01:56:18 <EvanR> a could be universal and a1 specific but unknown
01:57:17 <boxscape> personally I'd prefer explicit foralls but yeah I suppose that could work too
01:58:06 <EvanR> me too especially since forall is used for like 9 other things
01:58:28 <Rembane> What is a skolem in this case?
01:58:43 <Rembane> I know that it is a norwegian logician, but what has he given his name to in Haskell?
01:58:49 <boxscape> https://stackoverflow.com/questions/12719435/what-are-skolems
01:59:10 <EvanR> i may have made this up, but it's a variable used in type checking or inference to stand for a type
02:00:36 <Rembane> To say it in a different way, for my understanding: Is it a fancy name for a type variable? 
02:01:00 <EvanR> different from the universally quantified type vars we are used to
02:01:24 <EvanR> which can be substituted for any type
02:01:57 <EvanR> skolem stands for an unknown
02:02:29 <Rembane> Is it a free variable? 
02:03:42 <EvanR> since it only appears internally and they get 'zonked' reguarly, and don't appear in expressions... i dunno
02:05:35 <Rembane> Interesting, well this seems like a fun rabbit hole to dive down into. Thanks for the link boxscape. See ya! 
02:11:14 <arampaa> hey, I'm currently trying to evaluate some expressions for the following types:data Ar_Var = A1 | A2 | A3 | A4 | A5 | A6 deriving (Eq,Show)data Ar_Exp = AK Int | AV Ar_Var | Plus Ar_Exp Ar_Exp | Minus Ar_Exp Ar_Exp | Mult Ar_Exp Ar_Exp deriving (Eq, Show)type Ar_Assignment = Ar_Var -> Inttype Var_assignment = (Ar_Assignment,Log_Assignment)This
02:11:15 <arampaa> should be done by making Ar_Exp an instance of the following typeclass:class Evaluated a where  evaluate :: a -> Var_assignment -> Either Int BoolFor AK Int and AV Ar_Var it is pretty clear. For, say, Plus, I tried this:  evaluate(Plus a b) v = (+) (evaluate a v) (evaluate b v)It does not seem to be working though.
02:11:42 <Rembane> arampaa: How does it not work? 
02:11:44 <EvanR> it's looking like i was talking about rigid type variables
02:12:41 <arampaa> Rembane I'm getting this in ghci: No instance for (Num (Either Int Bool)) arising from a use of `+'
02:20:33 <EvanR> ok...
02:21:03 <EvanR> you can't just add two Either Int Bools because that type has no Num instance
02:21:43 <EvanR> Either Bool Int has potential 'trick'...
02:21:54 <arampaa> so how would this work?
02:22:05 <EvanR> > liftA2 (+) (Right 2) (Right 3)
02:22:08 <lambdabot>  Right 5
02:22:16 <EvanR> > liftA2 (+) (Right 2) (Left False)
02:22:18 <lambdabot>  Left False
02:23:30 <arampaa> ooh, never thought of that, thanks!
02:26:54 <int-e> Hmm, do we have a monad transformer ala  newtype MonadErrorFail m a = MEF (m a) deriving (Monad); instance Monad m => MonadFail (MonadErrorFail m) where fail = errorWithoutStackTrace  somewhere?
02:26:57 <boxscape> hm, could you make a somewhat reasonable Num instance for any pointed functor just by using (+) = fmap (+) and so on?
02:27:28 <merijn> int-e: I should hope not
02:27:51 <merijn> That'd completely ruin the entire use of MonadFail
02:28:20 <Lears> boxscape: You need at least Applicative. `Ap` has this instances, but it's not lawful in general.
02:28:21 <merijn> I wish I could revoke the Haskell license of anyone writing MonadFail instances using error
02:28:25 <int-e> merijn: Well it would solve a real maintenance pain.
02:28:40 <boxscape> Lears okay, thanks
02:29:00 <boxscape> Lears and yeah Applicative makes sense, confused liftA with liftA2 there
02:31:07 <int-e> merijn: The scenario I have is that a library defines utility functions ala  Monad m => m a, implementing failing cases with `fail`. With MFP, the signature changes to MonadFail =>, and suddenly the thing becomes unusable for various monads.
02:31:44 <int-e> merijn: And then you have to convince the library maintainer to make two versions of the function. Which, btw, would also be easier with such a transformer.
02:32:09 <merijn> Sounds like those instances don't really have sensible semantics anyway?
02:33:08 <int-e> Well all I can say is that exploiting the old dual role of the old `fail` is a real phenomenon.
02:33:18 <merijn> Like, I emphatise with the hassle that a bunch of stuff has to be fixed and it's a maintenance pain, but IMO any code that relies on error to signal errors is already broken
02:34:39 <EvanR> doubly ironic "error to signal error is wrong" and "error is an error" is right
02:35:09 <EvanR> you can't win!
02:35:18 <int-e> > let (\(Just x) -> x -> x) = Just 1 in x
02:35:20 <lambdabot>  1
02:36:14 <boxscape> double -> looks weird, maybe I've been using too much Java recently but it looks like a curried two-argument lambda
02:37:09 <EvanR> I, I don't know what's going on there
02:38:21 <EvanR> > let f = \a -> b -> (a,b) in f 'a' 2
02:38:23 <lambdabot>  <hint>:1:17: error: parse error on input ‘->’
02:38:34 <Lears> > let (fromJust -> x) = Just 1 in x
02:38:36 <lambdabot>  1
02:38:44 <boxscape> sneaky view pattern
02:38:48 <Lears> It's a really confusing way to write a ViewPattern.
02:40:05 <boxscape> > let (\x -> x -> x) = 1 in x
02:40:07 <lambdabot>  1
02:41:01 <EvanR> shenanigans
02:53:20 <int-e> I'd still like a more lightweight way of turning a failing pattern into an equivalent strict, but non-failing pattern. :P
02:55:54 <merijn> int-e: Naah, being inconvenient makes you feel the burden of guilt... :p
02:56:14 <int-e> Purists...
02:57:17 <merijn> int-e: I've been using MonadFail to prevent crashes and I've already twice been bitten by people completely subverting it with nonsense instances, so I'm not very motivated to encourage this kinda behaviour
02:57:21 <nshepperd1> int-e: !(~pat) <- action :)
02:58:01 <[exa]> int-e: btw a few days ago I solved a similar thing with prisms
02:58:08 <int-e> > do !(~(Just 1)) <- return Nothing; return ()
02:58:10 <lambdabot>  error:
02:58:10 <lambdabot>      • Ambiguous type variable ‘m0’ arising from a use of ‘show_M822382355306...
02:58:10 <lambdabot>        prevents the constraint ‘(Show (m0 ()))’ from being solved.
02:58:17 <merijn> If everyone starts arbitrarily subverting MonadFail, why even bother with this breaking change then we're just back were we started
02:58:18 <int-e> > (do !(~(Just 1)) <- return Nothing; return ()) :: Maybe ()
02:58:20 <lambdabot>  Just ()
02:58:32 <int-e> nshepperd1: So that doesn't work.
02:58:58 <nshepperd1> Hm
02:59:04 <nshepperd1> Could sworn
02:59:25 <nshepperd1> > (do ~(!(Just 1)) <- return Nothing; return ()) :: Maybe ()
02:59:27 <lambdabot>  Just ()
03:00:03 <int-e> > (do (\(Just 1) -> () -> ()) <- return Nothing; return ()) :: Maybe ()
03:00:05 <lambdabot>  *Exception: <interactive>:3:6-20: Non-exhaustive patterns in lambda
03:00:36 <boxscape> what would it mean for this to be non-failing and strict? What output do you want here?
03:01:07 <int-e> I *want* the error.
03:01:10 <AWizzArd> How can I configure the server timeout in Servant? Or is this done via WAI?
03:01:33 <nshepperd1> % (do !(~(Just 1)) <- return Nothing; return ()) :: Maybe ()
03:01:33 <yahb> nshepperd1: Just ()
03:02:44 <int-e> nshepperd1: it's perfectly logical
03:03:14 <int-e> % (do !(~(Just 1)) <- return (error "oops"); return ()) :: Maybe ()
03:03:15 <yahb> int-e: *** Exception: oops; CallStack (from HasCallStack):; error, called at <interactive>:92:29 in interactive:Ghci21
03:03:35 <int-e> nshepperd1: the value is forced, but the pattern match is still done lazily.
03:04:33 <int-e> % (do ~(Just 1) <- return (error "oops"); return ()) :: Maybe ()
03:04:33 <yahb> int-e: Just ()
03:11:35 <nshepperd1> Alas
03:19:19 <alp> AWizzArd, yes servant doesn't touch any of that, this is handled at the wai/warp level indeed
03:39:22 <ph88> phadej, are you around ?
03:40:35 <haskeldjiq> guys
03:40:44 <haskeldjiq> can I somehow "derive" an instance out of an inner monad
03:40:45 <haskeldjiq> e.g.
03:41:03 <comerijn> Does anyone know how cabal-install finds/decides what compiler to use for C and C++ files mentioned in the cabal file?
03:41:10 <comerijn> haskeldjiq: If it's a newtype, then yes
03:41:15 <haskeldjiq> instance (Class m1) => m m1
03:41:26 <haskeldjiq> nah not derive literally
03:41:40 <haskeldjiq> I have a custom monad transformer
03:42:00 <haskeldjiq> can I somehow make an instance of a class for it that is valid when the underlying monad has an instance of the class
03:42:35 <ph88> where did comerijn go ?
03:42:51 <haskeldjiq> he's hidden
03:43:40 <merijn> haskeldjiq: You mean "for all classes"?
03:44:17 <haskeldjiq> say you have a (MonadT m)
03:44:25 <haskeldjiq> when m has an instance of Class
03:44:35 <haskeldjiq> I would like (MonadT m) to also have an instance of Class
03:45:01 <merijn> haskeldjiq: Yeah, but do you mean "can I do this for a specific class" or "can I do this for all classes at the same time"?
03:45:10 <haskeldjiq> for a specific class in this case
03:45:25 <haskeldjiq> but if it could work for all classes that'd be fine too although it sounds kind of impossible to me
03:45:35 <merijn> haskeldjiq: I mean, you can just write "instance MyClass m => MyClass (MonadT m) where"
03:46:02 <haskeldjiq> I did that but I thought it'll end up with recursion
03:46:08 <haskeldjiq> because the definitions become
03:46:11 <haskeldjiq> someFunc = someFunc
03:46:34 <merijn> haskeldjiq: Presumably you want "someFunc = MonadTConstructor . someFunc"
03:46:35 <haskeldjiq> maybe I should've tested first lol 
03:46:47 <haskeldjiq> hm let me try
03:47:21 <merijn> haskeldjiq: See, for example, the implementations of MonadReader here: https://hackage.haskell.org/package/mtl-2.2.2/docs/src/Control.Monad.Reader.Class.html#line-156
03:48:38 <haskeldjiq> I looked at those but couldn't get it to work
03:49:18 <merijn> haskeldjiq: Assuming "data MonadT m a = MonadTCons (m a)" and, say, "someFunc :: SomeClass m => Int -> m Bool"
03:49:24 <haskeldjiq> it worked after adding MonadTrans
03:49:29 <haskeldjiq> I mean compiled
03:50:05 <haskeldjiq> ah no just moved the compilation errors lol
03:50:17 <haskeldjiq> this is fun
03:50:24 <haskeldjiq> maybe the whole design is shit
03:50:31 <merijn> haskeldjiq: Can you make a gist containing the class/datatype/current attempt?
03:50:49 <haskeldjiq> I just figured out that this won't even resolve the issue
03:51:04 <haskeldjiq> I'll make a gist trying to explain the whole thing maybe someone can give ideas
03:57:01 <haskeldjiq> merijn: https://pastebin.com/rWXUpTvP
03:58:28 <haskeldjiq> this is inside a domain shared library
03:58:40 <haskeldjiq> the instances defined at the DomainT level are used through GeneralizedNewtypeDeriving
03:58:58 <haskeldjiq> e.g. ServiceOperation = ... deriving (SomeEntityQueries, SomeEntityCommands)
03:59:07 <merijn> haskeldjiq: You'd want to make it something like: "searchSomeEntities = DomainT . lift . lift $ SomeEntityLogic.search"
03:59:46 <merijn> haskeldjiq: The first "lift" goes from 'm' to 'ExceptT DomainError m', the second lift, wraps that with ReaderT, and then the DomainT constructor wraps the whole thing into DomainT
04:00:17 <haskeldjiq> thank you!
04:00:26 <haskeldjiq> it led to other errors though 
04:00:29 <haskeldjiq> I'll try to fight with those
04:01:01 <merijn> haskeldjiq: You need to remember that while 'm' has those methods, you're actually wrapping 'm' with three things, ExceptT, ReaderT, and DomainT
04:01:57 <haskeldjiq> yeah it's the whole design that I think is broken
04:02:06 <haskeldjiq> it worked fine until now 
04:02:15 <merijn> I don't this is necessarily broken
04:02:28 <haskeldjiq> it's glowing with errors
04:03:39 <haskeldjiq> point is this is meant to be used by deriving
04:04:00 <haskeldjiq> at the service level we have 
04:04:53 <haskeldjiq> newtype ServiceOperation a = ServiceOperation { runServiceOp :: DomainT Config (KatipContextT IO) a } deriving (SomeEntityQueries, SomeEntityCommands, SomeOtherEntityQueries...)
04:05:04 <haskeldjiq> now that we've put the constraints on m
04:05:16 <haskeldjiq> and m in this case is (KatipContextT IO)
04:05:19 <haskeldjiq> things really get fucked up
04:12:32 <kuribas> Some people say you need to get a PHD to write simple code in haskell.  Monadbasecontrol makes me wonder if theyt aren't right.
04:13:21 <kuribas> Monad stacks are supposed to make life easier, but if you see all the complexity to just use a resource handler.
04:13:26 <Spock> MonadBaseControl makes me wonder if someone wanted that to be true
04:13:43 <Spock> i have never found occasion to use it, myself
04:14:07 <merijn> MonadBaseControl is super confusing, which is why FP Complete which used to advocate it's use has basically stopped using it entirely
04:14:29 <merijn> That's literally why MonadUnliftIO was invented >.>
04:16:03 <kuribas> how do you use it with ExceptT?
04:17:51 <merijn> I don't understand having "ExceptT" buried inside your stack anyway, that seems to defeat it's entire usefulness I always want ExceptT/MaybeT as outer-most thing in local places where I need it
04:18:17 <merijn> kuribas: If your resource management can't be handled by MonadUnliftIO, use ResourceT
04:19:52 <kuribas> merijn: well any transformer build on top of a servant Handler
04:20:42 <kuribas> it's useful because it allows you to treat special (non 200) responses as pure values.
04:20:51 <merijn> I don't know servant and I don't see a Handler type in it's API index
04:21:00 <merijn> So can't say
04:21:23 <kuribas> merijn: http://hackage.haskell.org/package/servant-server-0.16.2/docs/Servant-Server-Internal-Handler.html
04:23:25 <merijn> That sounds more like "Servant wasn't designed to make resource handling simple", rather than "you can't easily do resource management with transformer stacks"
04:25:24 <kuribas> merijn: I don't see why ExceptT is problematic
04:25:39 <kuribas> I think StateT is problematic if think of it as global state.
04:25:59 <kuribas> why IMO acquire and cleanup should be pure IO, not a transformer stack.
04:27:17 <merijn> kuribas: https://stackoverflow.com/questions/40372087/what-is-the-best-way-to-manage-resources-in-a-monad-stack-like-exceptt-a-io
04:27:38 <merijn> kuribas: I know you don't see/don't think it's problematic, but community consensus does not agree with you
04:29:56 <merijn> You are, of course, welcome to write your own solution and convince everyone else to switch to it over the mix of unliftio-core/exceptions/resourcet that are now common, but that seems an uphill battle to say the least
04:30:08 <kuribas> merijn: no, because IMO the proper generalisation of bracket is: bracket :: IO a -> (a -> IO b) -> (a -> m c) -> m c
04:30:37 <kuribas> merijn: I want something that is easy for non-expert haskellers to use, and neither monadbasecontrol or unliftIO is it.
04:30:57 <kuribas> merijn: could be because the servant stack is "wrong", but I don't want to throw away servant for that.
04:31:06 <merijn> kuribas: Why is unliftIO not easy to use?
04:31:14 <alp> kuribas, Hander isn't really meant to be used all that much. for any serious app, I'd define a custom monad, that doesn't involve Handler at any level, and then map that monad to Handler at the very end, as indicated in the tutorial
04:31:45 <kuribas> alp: but you still need to handle non-standard responses, no?
04:31:45 <merijn> kuribas: ResourceT gives you exactly that bracket definition
04:32:10 <alp> kuribas, you can use your own ExceptT/Either, with a dedicated, custom error type
04:32:25 <alp> and when you map it all back to Handler, you turn those error _values_ into responses
04:32:41 <kuribas> alp: but then you're back to a stack with ExceptT
04:32:58 <alp> well, that's just the common option
04:33:06 <merijn> kuribas: The problem isn't "ExceptT" itself, it's "having ExceptT at the bottom"
04:33:08 <alp> you're free to pick whatever it is that you typically use
04:33:51 <alp> https://haskell-servant.readthedocs.io/en/stable/tutorial/Server.html#using-another-monad-for-your-handlers explains the whole "using a custom monad" thing.
04:34:08 <merijn> kuribas: ExceptT over some monad that implement MonadUnliftIO/MonadResource is all you need to use resource handling
04:38:35 <merijn> Which brings us full circle to my earlier remarks stating that you almost always want ExceptT/MaybeT as *outermost* transformer
04:39:15 <merijn> So that you can then do "runMaybeT" to unwrap the short-circuiting behaviour and get something that integrates with your application monad stack
04:43:39 * hackage mmsyn6ukr 0.1.0.0 - Can be used as a musical instrument synthesizer or for Ukrainian language listening  https://hackage.haskell.org/package/mmsyn6ukr-0.1.0.0 (OleksandrZhabenko)
04:46:02 <kuribas> I think the problem is not with monadbasecontrol itself, it's the idea that an IO a can be replaced by any transformer stack.
04:46:44 <kuribas> Looking at ResourceT, I just see more complexity that I wouldn't want to inflict on new haskell programmers.
04:46:56 <merijn> The problem of monadbasecontrol is that it's API is super confusing and complicated and that despite 10 years of Haskell I'm still confused anytime I have to use it
04:47:04 <kuribas> merijn: that also :)
04:47:13 <merijn> kuribas: How so? What's complex about ResourceT?
04:47:50 <kuribas> I'll need to give a better look maybe...
04:48:15 <merijn> The implementation is complex, sure, but the API is fairly simple
04:48:47 <merijn> kuribas: I mean, "allocate" is pretty much the bracket API you described earlier :p
04:49:13 <merijn> allocate/register/release and the stuff in Data.Acquire is all you really need as user
04:49:33 <kuribas> mm, okay...
04:50:03 <merijn> kuribas: The rest of the module is for integrating ResourceT nicely into threading libraries, etc.
04:51:27 <merijn> The docs could probably be streamlined a bit for beginners, if I ever have time (ahahahahaa I'm so funny!) I might consider doing that
04:54:25 <merijn> kuribas: ResourceT is actually more general, since it also supports doing cleanup in monads that don't really have a sensible bracket (like ConduitT), for things that do have a sensible bracket you can probably get by with just the Data.Acquire portion of the library (which also simpler/more beginner friendly docs)
04:54:52 <alp> kuribas, re: new haskell programmers, servant is certainly not the option that's going to feel most familiar to them (as opposed to e.g Spock)
04:55:39 <kuribas> alp: true, but it's also the better option for rest API's...
04:56:40 <kuribas> it shows clearly the API and types it can handle.
04:57:47 <Putonlalla> What's the correct way to implement `showsPrec` if I want to temporarily disable printing the constructor of a `newtype` wrapper?
04:58:11 <Putonlalla> With the wrapper, the derived instance is `showsPrec n (Wrap x) = showParen (n >= 11) (showString "Wrap " . showsPrec1 11 x)`.
05:00:47 <merijn> Putonlalla: The correct way I always use is "think long and hard, decide 'fuck it', and just derive Show instead" ;)
05:01:48 <Putonlalla> Why not "use Racket instead"?
05:02:02 <merijn> Which, admittedly, is not the most useful answer >.>
05:02:35 <mananamenos> hi, what do you use with nixos and bios-hie to jump to definition? xref of lsp-mode does not seem to work. I can use haskell-mode's generate tags or just start cabal-new-repl process on every project's file and then i can navigate the definitions of my own code only. Prelude functions still do not work
05:02:36 <merijn> Putonlalla: Doesn't just implementing Show work?
05:03:56 <Putonlalla> No. I need to do this as a stepping stone to `Show1` trickery.
05:07:25 <Putonlalla> It almost works to say `showsPrec n (Wrap x) = showParen (n >= 11) (showsPrec1 0 x)`, but this puts unnecessary parentheses around atomic things.
05:09:40 <phadej> than the problem is in caller of showsPrec @Wrap which calls it with too high `n`
05:09:45 <Putonlalla> It also almost works to say `showsPrec _ (Wrap x) = showsPrec1 11 x`, but this puts unnecessary parentheses around the whole thing.
05:09:54 <phadej> (or in downstream showsPrec1 which always put parentheses)
05:10:11 <phadej> showsPrec n (Wrap x) = showsPrec1 n x
05:10:12 <phadej> ?
05:10:15 <phadej> is probably what you want
05:10:35 <Putonlalla> Oh, yes. Yes it is.
05:10:46 <Putonlalla> Thanks, phadej.
05:11:08 <Putonlalla> I can't believe it's so simple.
05:11:15 <phadej> also `deriving newtype (Show)
05:11:16 <phadej> `
05:11:31 <phadej> with DerivingStrategies and GeneralizedNewtypeDeriving
05:11:51 <Putonlalla> When was this sorcery developed?
05:12:25 <phadej> DerivingStrategies is in GHC-8.4
05:12:37 <Putonlalla> Neat.
05:12:43 <phadej> GND is ~always
05:13:03 <phadej> (but it doesn't work for Show, unless you say it with DerivingStrategies)
05:14:28 <Putonlalla> I guess you still can't say `deriving newtype Show1 m => Show (Wrap m)`.
05:14:49 <Putonlalla> Using `StandaloneDeriving`, that is.
05:19:27 <phadej> you can deriving newtype instance
05:19:36 <phadej> instance keyword still have to be there
05:22:16 <Putonlalla> That's nice, but looks like the derived instance doesn't type check, because GHC can't make use of `Show1`.
05:22:32 <Putonlalla> Still, that is good to know.
05:26:27 <phadej> ah, sorry, showsPrec vs showsPrec1, i'm blind.
05:28:15 <phadej> yet, you can argue that wrapped type `Show` instance should be there doing whatever showsPrec1 would do for it.
05:29:17 <phadej> cannot say for sure without more context. Show1 m => Show (Wrap m) feels weird. Is newtype Wrap m = Wrap (m Int) or something like that?
05:29:37 <phadej> then yes, there is no way around writing manual instances
05:29:59 <Putonlalla> Yes, it's like that.
05:30:41 <phadej> btw, newtype Wrapped m = Wrap { unwrap :: m Int } -- reads better
05:31:12 <phadej> Wrapped Maybe, Wrap Nothing, unwrap somethingWrapped
05:32:39 <Putonlalla> That's the `base` library convention.
05:34:54 <phadej> yes, with a concrete benefit having type and data constructor have different names
05:36:09 * hackage monad-logger 0.3.31 - A class of monads which can log messages.  https://hackage.haskell.org/package/monad-logger-0.3.31 (MichaelSnoyman)
05:37:44 <boxscape> Putonlalla phadej read the whole conversation but there is a library to generate Show1 instances with TH
05:37:49 <boxscape> haven't read *
05:38:01 <phadej> boxscape: it's not about generating them, but using them
05:38:12 <boxscape> ah
05:39:44 <Putonlalla> I have `deriving-compat` in use.
05:40:06 <boxscape> okay
05:47:37 <boothead> Hey folks. Anyone using the swagger package? I'd like to add an "x-amazon-apigateway-integration" to the generated swagger and was wondering if there's a way to do that?
06:17:39 * hackage mmsyn6ukr 0.2.0.0 - Can be used as a musical instrument synthesizer or for Ukrainian language listening  https://hackage.haskell.org/package/mmsyn6ukr-0.2.0.0 (OleksandrZhabenko)
06:21:27 <hmm695> Hi, quick question: is it possible to do something like this?
06:21:33 <hmm695> test :: a -> b
06:21:38 <hmm695> test x = maxBound :: b
06:22:50 <hmm695> I simply get: could not deduce 'maxBound'...
06:23:35 <maerwald> test :: Bounded b => a -> b
06:23:41 <hmm695> sorry, that's with the type: test :: Bounded b => a -> b
06:24:16 <boxscape> hmm695 if you want to use b inside the function body like that you're going to need to enable the -XScopedTypeVariables extension
06:24:22 <c_wraith> hmm695: yes, but it either needs the ScopedTypeVariables extension or rewriting the code rather awkwardly
06:25:00 <boxscape> and then you'll need to write "test :: forall a b . Bounded b => a -> b", because without the explicit forall, ScopedTypeVariables doesn't come into effect
06:25:27 <boxscape> hmm695 though in this particular case you should also just be able to drop ":: b" from maxBound
06:27:51 <VictorPP> Hi, can I ask a type-related Haskell questions here?
06:28:00 <hmm695> cool that works, thanks a lot!
06:28:00 <boxscape> yes
06:28:05 <c_wraith> all Haskell questions are on-topic here
06:28:06 <boxscape> VictorPP
06:28:08 <hmm695> now I'll have to read up what that forall means.
06:28:19 <maerwald> I don't see why you need that
06:28:36 <VictorPP> Thanks. I have the following code: https://gist.github.com/Tears/81f452c8daa3bea079d0b1982d7b667c
06:28:40 <boxscape> maerwald I don't think ScopedTypeVariables works without it
06:28:53 <VictorPP> And it generates the following error: No instance for (RealFrac Integer) arising from a use of ‘ceiling’
06:28:58 <VictorPP> And I can really not see why
06:29:31 <VictorPP> I tried fromIntegral and toInteger and all variants but it really is not doing anything it seems
06:29:41 <hmm695> maerwald: I tried it. It only works with the extension and with the "for all . Bounded b"
06:30:03 <boxscape> hmm695 as a really quick introduction (but feel free to read up on it more), ghc will always implicitly generate these foralls for you if you have a type signature that contains type variables. Writing it out just makes it explicit, and "forall a. <something>" means that this function is valid for any type a you can come up with
06:30:24 <c_wraith> VictorPP: the problem isn't the ceiling call, it's the division before it
06:31:17 <VictorPP> Ah ok, but when I tried the division in ghci it worked just fine, no errors. What is different in this situation? c_wraith
06:32:11 <c_wraith> VictorPP: the arguments to it are getting inferred as Integer, based on their other uses
06:32:23 <berndl> VictorPP: you need it to be Int, not Integer
06:32:31 <c_wraith> > (10 :: Integer) / 5
06:32:32 <lambdabot>  error:
06:32:32 <lambdabot>      • No instance for (Fractional Integer) arising from a use of ‘/’
06:32:32 <lambdabot>      • In the expression: (10 :: Integer) / 5
06:33:09 <berndl> VictorPP: oops, nevermind.
06:33:14 <c_wraith> VictorPP: you should fromInteger both arguments to (/)
06:33:33 <hmm695> boxscape: Ah, good to know, thanks for the introduction.
06:34:30 <VictorPP> Thanks for your comment. However, the following error is now reported: Couldn't match expected type ‘Integer’ with actual type ‘Int’ c_wraith
06:35:11 <c_wraith> then use fromIntegral instead of fromInteger
06:35:31 <c_wraith> though I don't see how that should happen with the code you posted
06:36:21 <VictorPP> That seems to have worked, thanks. The whole Integer/Int/Num/Integral-stuff is still a big mess for me, c_wraith
06:37:22 <boxscape> I think most people would agree that numeric classes could have been designed better
06:37:44 <c_wraith> this isn't a result of the classes, though.  Just of (/) being non-integral division
06:37:53 <boxscape> ah, that's true
06:38:15 <c_wraith> as long as you want different operations for integral and non-integral division, you're going to run into this
06:39:01 <boxscape> hm, I'm actually not sure if that's desirable or not
06:42:28 <AWizzArd> alp: Ah okay, so WAI was the right direction.
06:43:16 <AWizzArd> Does Servant use Warp under the hood for doing http?
06:44:05 <berndl> VictorPP: I can sympathize. The numeric hierarchy in Haskell is bonkers.
06:44:55 <svipal> it really is super weird
06:45:13 <VictorPP> Thanks, berndl. Coming from a imperative background, it really takes a while getting used to
06:45:36 <c_wraith> really, though, this one just came down to the type of (/)
06:45:47 <c_wraith> be wary of division.  It's usually wrong. :)
06:46:30 <merijn> The numeric hierarchy is slightly annoying, but not that much
06:47:23 <merijn> Calling it "completely bonkers" is a bit of an overstatement. I sometimes get annoyed at having to use fromIntegral explicitly everywhere when I mix lots of integers and Double's, but then I remember that time I spend 3 weeks debugging an implicit type conversion in C and the annoyance passes
06:48:14 <Cale> It mostly makes good sense now I think. What was bonkers was when Num required Show for some reason.
06:48:48 <Cale> Having abs and signum in Num doesn't quite make perfect sense, but it's always possible to provide trivial implementations.
06:49:08 <Cale> and Real isn't a good name for what it is
06:49:09 <alp> AWizzArd, no, but in turns an API type declaration + a bunch of handlers into a value of type 'Application', from WAI
06:49:13 <c_wraith> and now I'm reminded of helping someone with java homework, where they were finding pi with the monte carlo method.  They kept getting 0 every time, and I went "oh, you're doing hits/successes, but those are both ints, so you're getting 0"
06:49:16 <boxscape> it's also a bit annoying to have to define negate in the same class that gives you (+)
06:49:34 <alp> which is the meeting point of a bunch of web app libraries.
06:49:34 <infandum> Is there a function that reads a file from a URL, that is, from local or remote?
06:49:39 <Cale> Well, Num is approximately Ring
06:49:49 <Cale> and so negate makes sense there
06:50:03 <alp> AWizzArd, warp is then a library that takes those application specifications and turns them into HTTP servers
06:50:12 <boxscape> but surely there's some algebraic structure that form a superset of rings that doesn't have negation?
06:50:23 <boxscape> (but does have addition)
06:50:53 <Cale> Sure, there's semirings, but you're providing fromInteger here regardless
06:51:02 <boxscape> hm, true
06:51:02 <Cale> So you already have fromInteger (-1) * x
06:51:18 <boxscape> you could split fromInteger and fromPositiveInteger, only allowing non-negated literals
06:51:27 <Cale> I guess we could have something semiring-esque which did fromNat
06:51:42 <boxscape> ...that does sound more elegant
06:52:11 <Cale> I don't know how much we really need to care about putting arbitrary semirings under that same umbrella
06:53:02 <boxscape> could be that I just define a Natural type too often for no real practical pupose :)
06:53:04 <Cale> Also, if you start using technical terms like that, well, you probably want to have law-abiding instances, and we probably want Float and Double to remain
06:53:57 <boxscape> true :/
06:54:32 <Cale> So I actually like the name "Num" for not implying so much about what laws are available.
06:54:46 <Cale> (at least, given that we're making the compromise)
06:56:13 <merijn> People have invented entirely different complicated Num hierarchies, but they, invariably, end up worse than what we have now when it comes to practical ergonomics
06:56:20 <berndl> Couldn't we make Float and Double law-abiding if you to write them down exactly?
06:56:44 <Cale> IEEE arithmetic doesn't have very many nice properties
06:56:48 <merijn> berndl: Not until carter's work on eliminating value NaN is finished
06:56:58 <Cale> There's nothing you can do to make them associative, for example
06:57:00 <merijn> And even then it depends on your definition of "law abiding"
06:57:27 <Cale> Wait, someone's eliminating NaN as a value?
06:57:44 <Cale> That sounds horrifyingly disruptive at this point
06:57:45 <merijn> Cale: carter is working on a proposal to (at least optionally) elimiante value NaN
06:57:47 <boxscape> Cale is the associativity related to NaN or to floating point inaccuracies?
06:57:49 <Cale> hm
06:57:51 <merijn> Cale: How so?
06:57:52 <carter> Cale cpus lets you make NaN an exception
06:57:58 <carter> It’s in the ieee spec
06:58:04 <merijn> Cale: value NaN breaks everything
06:58:06 <carter> And cpus support it
06:58:07 <Cale> merijn: I mean, it would be disruptive to existing code
06:58:11 <merijn> Trapping NaN is much more nicely behaved
06:58:14 <carter> Not really
06:58:29 <carter> Most code actually wants to abort on NaN
06:58:30 <merijn> Cale: I'm going to go ahead and say that any code that works with NaN currently is *already* fundamentally broken
06:58:58 <Cale> boxscape: It has to do with rounding
06:59:00 <carter> Ignoring languages that abuse NaN for ptr Tati g
06:59:09 <Cale> boxscape: The lack of associativity does
06:59:21 <merijn> Cale: I'm willing to bet $10 that *no one* can find any Haskell code that breaks by removing value NaN, except for code explicitly written to try and get $10 from me
06:59:28 <Cale> haha
06:59:29 <boxscape> Cale okay, I see
06:59:49 <Rembane> merijn: How sneaky do I have to be to get $10? :)
06:59:52 <boxscape> I imagine you could have some code that parses Doubles, including NaN, and then filters them out afterwards
07:00:19 <carter> Cale if you add a multiplicative 1+\- eps tolerance to each of the usual Algebra laws then floats are fine
07:00:22 <merijn> boxscape: There's no way to write NaN without hexfloats which is 1) an extension and 2) has only been in one or two GHC releases
07:00:49 <carter> Cause they’re geometry rather than exact numbers
07:00:50 <berndl> I think major problem with floating point is that most language allow me to write 0.25 as a floating point value, which is completely bonkers.
07:00:54 <boxscape> merijn I don't mean as haskell literals but form some external resource in some other config language
07:01:07 <boxscape> or something like that
07:01:16 <Cale> carter: uhhh, I'm not sure about that. It seems like the rounding errors can get pretty large.
07:01:23 <merijn> boxscape: Yeah, but those would have had to invent their own NaN syntax as there's no way to write NaN textually
07:01:42 <carter> Cale : that’s because relative error of different size numbers
07:01:43 <boxscape> merijn right.. I was about to correct myself before you wrote that :)
07:01:44 <merijn> (barring hexfloats)
07:01:52 <Cale> carter: Right.
07:02:03 <merijn> And no one is currently parsing hexfloats, because there's no library for it
07:02:09 <carter> Cale: multiplicative error term covers that :)
07:02:12 <merijn> I know, cause I needed one, like, 2 weeks ago :p
07:02:24 <carter> berndl: human writing let’s me pretend physical measure’ents are exact. Which is nuts
07:02:27 <merijn> berndl: In Haskell that's perfectly cromulent, though :)
07:02:32 <merijn> berndl: Just use Rational as a type :)
07:02:33 <boxscape> the ghc parser parses hexfloats
07:02:41 <merijn> boxscape: As of 1 or 2 releases
07:02:45 <merijn> boxscape: With an extension
07:02:55 <merijn> boxscape: And it doesn't expose the parser in base
07:03:03 <carter> merijn: I thought hexfloats only does the rational representative terms. Not the hex of memory reps
07:03:14 <boxscape> doesn't ghc api expose it?
07:03:20 <carter> I could be wrong
07:03:30 <merijn> boxscape: No, because I opened a ticket for that and it's still being worked on
07:03:36 <boxscape> ah, fair enough :0
07:03:42 <boxscape> s/0/)
07:03:46 <carter> merijn: who was I helping with the parsing who was confused about some corner case ?
07:03:52 <merijn> carter: AFAIK according to IEEE-754 hexfloats can reprsent all floats *exactly*
07:03:58 <merijn> carter: __monty__ was working on it
07:04:04 <carter> Oh yeah
07:04:23 <carter> merijn: I thought it was all finite floats.
07:04:39 <carter> Cause it’s exact / no rounding for fractions
07:04:51 <carter> Scientific notation, but in hex base
07:06:07 <merijn> carter: I'd have to look into that
07:06:51 <merijn> boxscape: Numeric in base can *show* hexfloat, but not parse them >.>
07:07:35 <boxscape> I see
07:08:47 <carter> merijn: maybe since you keep on reminding me I’ll do some ghc hacking today
07:08:51 <smelc> hey guys, given a list of Validation err a (http://hackage.haskell.org/package/validation-1.1/docs/Data-Validation.html), how can I return the first 'Success a' case or return a default err value ? I suppose there's a combinator in there to do it, but I'm new to haskell and I can't find hints
07:11:09 * hackage mmsyn6ukr 0.2.0.1 - Can be used as a musical instrument synthesizer or for Ukrainian language listening  https://hackage.haskell.org/package/mmsyn6ukr-0.2.0.1 (OleksandrZhabenko)
07:11:29 <carter> merijn: I’m wondering if adding a version of my monad ste monad thst has support for monad fail would be useful for anyone. 
07:11:32 <carter> Thoughts ?
07:11:40 <lyxia> smelc: Data.Foldable.asum
07:11:54 <carter> https://hackage.haskell.org/package/monad-ste
07:11:55 <berndl> smelc: Maybe use the semigroup instance with a fold?
07:12:19 <lyxia> oh wait it's not an instance of Alternative ?!
07:12:47 <carter> lyxia: ?
07:12:59 <carter> My thing or what
07:13:14 <lyxia> not you :)
07:13:44 <haskeldjiq> guys I know ExceptT over IO is bad and all what alternative do you suggest and where do I get more informed about it
07:13:46 <carter> Ok. I was confused. Cause alternative is under some monads basically a catch and handle construct :)
07:14:01 <carter> haskeldjiq: https://hackage.haskell.org/package/monad-ste use this instead
07:14:32 <carter> As least when you can make it more about mutable memory than io
07:14:54 <haskeldjiq> thanks
07:15:07 <Cale> haskeldjiq: Well, what kinds of exceptions are you dealing with? Usually just throwing the exception in IO, or returning an Either result is an option.
07:15:50 <haskeldjiq> we currently have ExceptT DomainError (... IO)
07:15:53 <haskeldjiq> at the bottom of our stack
07:16:05 <smelc> berndl> and the function passed to fold would "carry on" the starting value, so that the starting value is returned in case I have only "Failure" instances ?
07:16:05 <haskeldjiq> so domain errors
07:16:45 <berndl> smelc: sure
07:18:05 <smelc> I see, I'll try that; thanks!
07:18:20 <haskeldjiq> Cale: it's not like we've had any problems I've just heard that ExceptT over IO is so bad so many times
07:18:24 <haskeldjiq> Cale: it makes me wonder
07:20:23 <carter> So one good argument is that in inner loops, exceptT means every bind is a case
07:21:16 <carter> But in the large / not inner loop focused land of most applications, that doesn’t matter
07:24:31 <AWizzArd> hPut appends a ByteString to a given handle. Is there a way that allows me to specify to overwrite data in a (large) existing file at a certain position?
07:29:05 <nil> hSeek?
07:29:21 <geekosaur> that, basically
07:29:22 <maerwald> haskeldjiq: IO inside ExceptT is hard
07:30:09 * hackage network 3.1.1.1 - Low-level networking interface  https://hackage.haskell.org/package/network-3.1.1.1 (dukerutledge)
07:30:11 <geekosaur> also note the file must not be open for append, which will force all writes to be at the end. you may want to open for read+write
07:30:21 <haskeldjiq> maerwald: there's something easier?
07:31:36 <maerwald> haskeldjiq: I'm not sure yet. Error handling is a complicated topic, but IME, people usually forget that they have to handle IO exceptions at all when they are dealing with ExceptT
07:31:36 <maerwald> ignoring the inner monad
07:31:41 <AWizzArd> geekosaur: good, hSeek it is.
07:34:20 <haskeldjiq> maerwald: this is definitely tricky
07:34:20 <maerwald> We have MonadThrow, MonadFail, MonadError, ExceptT and straight IO
07:34:20 <maerwald> and everyone uses it a little different
07:34:28 <haskeldjiq> dem side-effects
07:34:51 <haskeldjiq> always bringing trouble
07:50:39 * hackage esqueleto 3.2.3 - Type-safe EDSL for SQL queries on persistent backends.  https://hackage.haskell.org/package/esqueleto-3.2.3 (parsonsmatt)
07:54:38 <AWizzArd> Instead of hFlush, can I somehow run a (blocking) flush action until the data has *really* been written out to disk?
07:56:14 <tabaqui1> what do you think about monad-control and lifted-base packages?
07:57:18 <tabaqui1> probably the most usefull function from the last one is "timeout"
07:58:15 <tabaqui1> fork/forkFinally works well with state-like monads (IO, Reader, read-only State)
07:58:20 <geekosaur> AWizzArd, the OS does not tell you when it's written to disk
07:58:42 <geekosaur> moreover, modern disks don't tell you when they actually write to persistent media
07:58:47 <tabaqui1> but is has it's own lifted exceptions, that are not composable with MonadThrow/MonadCatch
07:58:58 <tabaqui1> *it has
07:59:13 <geekosaur> what problem are you trying to solve?
08:01:33 <boxscape> I kinda feel like you should get some sort of error if you try to write "const :: forall a . a -> _ -> a" with PartialTypeSignatures. Seems like the correct way ought to be something like "forall a _ . a -> _ -> a", where _ in the forall is a hole that can be filled with anything by the compiler
08:02:21 <geekosaur> (you can set NoBuffering mode, in which case every write will block until committed to a kernel buffer; that's the best you can ever do)
08:08:24 <boxscape> % (\case) (\case)
08:08:24 <yahb> boxscape: *** Exception: <interactive>:101:2: Non-exhaustive patterns in case
08:08:41 <boxscape> kind of neat that \case by itself is a perfectly valid function
08:08:59 <boxscape> (also the implementation of absurd)
08:09:11 <boxscape> s/the/an
08:13:10 <fendor> :t (\case)
08:13:11 <lambdabot> p1 -> p2
08:13:16 <fendor> lol
08:14:17 <boxscape> % absurd' :: Void -> a; absurd' = \case
08:14:17 <yahb> boxscape: 
08:19:26 <maralorn> Can I disable a certain warning for a part of a file only?
08:20:13 <boxscape> maralorn https://gitlab.haskell.org/ghc/ghc/issues/602
08:20:17 <boxscape> opened 15 years ago
08:28:06 <fendor> maralorn, {-# GHC_OPTIONS -fno-warn-orphan-instances #-}
08:28:09 * hackage monad-logger-syslog 0.1.6.0 - syslog output for monad-logger  https://hackage.haskell.org/package/monad-logger-syslog-0.1.6.0 (iamemhn)
08:28:53 <djanatyn> i'm reading the Ghosts of Departed Proofs paper and having trouble understanding why rank-2 functions on newtypes for "phantom labels" are necessary (the paper says it is for emulating existentially qualified types?)
08:30:36 <djanatyn> newtype Named name a = Named a; type a ~~ name = Named name a; name :: a -> (forall name. (a ~~ name) -> t) -> t; name x k = k (coerce x)
08:30:52 <geekosaur> fendor, that's still whole file and has to be before the module declaration
08:31:01 <geekosaur> or it will be ignored
08:31:06 <fendor> geekosaur, true, misread the question, sorry
08:33:01 <dmwit> AWizzArd: I don't know enough to endorse or disclaim this package, but a google search for "fsync Haskell" suggests http://hackage.haskell.org/package/cautious-file-1.0.2/docs/System-Posix-Fsync.html
08:40:16 <geekosaur> fsync still doesn't guarantee data are committed to persistent media; as I said (unless it got eaten when I got dsconnected) modern disks don't even promise they have committed writes to permanent storage
08:40:55 <maralorn> I ask because I‘d like to use -Wmissing-export-lists but I have one exception (a custom Prelude).
08:41:12 <maralorn> Any tips how to work around that?
08:41:24 <geekosaur> and fsync may or may not block even to the extent of data committed to the drive
08:42:26 <fendor> maralorn, so, you want to have that warnings except in one special file?
08:43:00 <maralorn> fendor: I want to have the warning except for one special import statement?
08:43:13 <geekosaur> there's a decent amount of hitorical griping on OS development mailing lists about disks that refuse to tell the truth, so fsync is more or less impossible to do correctly except with some more expensive SSDs and maybe the most expensive SCSI spinning rust
08:45:20 <jzyamateur> How does one represent this type `newtype IdentityT f a = IdentityT { runIdentityT :: f a }
08:45:22 <nshepperd> fsync is enough to protect against your app being oom-killed though
08:46:02 <berndl> geekosaur: do you know if Intel Optane SSDs are the exception?
08:47:01 <geekosaur> I couldn't tell you current specific models, no. I would expect SSDs in general to be better behaved because they don't have to hide waiting on spinning discs from benchmarks
08:47:03 <maralorn> jzyamateur: What do you mean with "represent"?
08:47:12 <jzyamateur> I mean define.
08:47:25 <nil> well you just did that
08:47:30 <jzyamateur> define similar type without the record syntax, is it possible?
08:47:31 <maralorn> jzyamateur: Isn‘t what you posted the definition?
08:47:43 <geekosaur> newtype can't have multuple parameters
08:48:00 <AWizzArd> dmwit: that looks good, in principle, but I wonder how I can make an Fd out of a Handle.
08:48:02 <nil> newtype IdentityT f a = IdentityT (f a)
08:48:31 <jzyamateur> `newtype IdentityT f a = IdentityT (f a)
08:48:36 <geekosaur> AWizzArd, handleToFd exists but closes the Handle. otherwise you need to poke around in the GHC.Handle module
08:49:27 <geekosaur> in this case you probably need the latter. it's been a few years but the definitions are fairly straightforward aside from some abstraction intended to deal with Windows sockets, which aren't file descriptor based
09:12:36 <dminuoso> Is there a base binding for a function that takes a list [1,2,3,4] and generates lists of consecutive combinations `[[1], [1,2], [1,2,3], [1,2,3,4]]` ?
09:15:50 <yushyin> > inits [1,2,3,4]
09:15:53 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4]]
09:16:51 <dminuoso> yushyin: Ah cheers!
09:28:07 <fmhkll> Hey guys, I'm using an algorithm with an STUArray, but I have to rewrite it without Data.Array.ST.
09:28:08 <fmhkll> I should try to use accumArray, right?
09:28:28 <dmj`> fmhkll: why not use vector
09:29:09 <fmhkll> I can't even use vector...
09:29:22 <dmj`> fmhkll: why not :(
09:33:29 <Taneb> fmhkll: is this a homework exercise?
09:35:40 <ph88> how can i pass cabal flags to stack ?
09:38:08 <fmhkll> No, just learning with a list of exercises :D
09:39:14 <evelyn> ph88: https://docs.haskellstack.org/en/stable/nonstandard_project_init/#passing-flags-to-cabal
09:40:55 <fmhkll> Can't figure that one out, though, because inside my STUArray do block I iterate over an Int list xs, but modify elements by indices different from the ints in xs (but depending on them)
09:43:39 <fmhkll> That's why I'm not able to transform my xs and ys into a list for accumArray... Personally, I don't think there is a way to achieve what I want without \\ (which is not very performant)
09:44:29 <Phyx-> AWizzArd: though please avoid using any method that relies on FD, if at all possible always use Handle, and the worse case Handle__, using FD will make it not cross platform if that was a goal
09:57:38 * hackage hsinspect 0.0.8 - Inspect Haskell source files.  https://hackage.haskell.org/package/hsinspect-0.0.8 (tseenshe)
09:58:38 * hackage ghcflags 1.0.2 - Dump the ghc flags during compilation  https://hackage.haskell.org/package/ghcflags-1.0.2 (tseenshe)
09:58:51 <ph88> evelyn, those flags seem to be for packages, i would like to pass cabal's own flag
09:59:30 <sclv> example?
10:00:49 <ph88> cabal build --enable-debug-info
10:04:21 <sclv> ph88 that’s a cabal-install flag. stack can’t handle it
10:04:36 <ph88> is there any way to pass it from stack ?
10:04:47 <sclv> it translates to two ghc flags you can pass
10:05:08 <sclv> -g and —enable-dwarf-unwind
10:06:24 <ph88> those ghc options are transparent to cabal code .. i like to use --enable-debug-info
10:06:47 <sclv> well file a feature request with stack
10:10:06 <ph88> ok
10:10:06 <leo_> Is there a way to make Criterion.main IO benchmarks not output to stdout?
10:14:20 <dsal> leo_: does Quiet do that?
10:17:35 <leo_> dsal: Where's that? xd
10:17:44 <sshine> http://hackage.haskell.org/package/criterion-1.5.6.1/docs/Criterion-Types.html#t:Verbosity
10:17:47 <sshine> but I don'
10:17:49 <sshine> t think so.
10:19:02 <dsal> leo_: I was just reading through the manual. I've never tried making it quiet.
10:22:38 <leo_> :s
10:24:43 <sshine> leo_, sorry, I assumed you'd want to print to stderr or something.
10:27:20 <rhine> @free f :: a -> a
10:27:21 <lambdabot> g . f = f . g
10:27:29 <rhine> @free f :: a -> b
10:27:29 <lambdabot> h . f = f . g
10:30:57 <leo_> sshine: No problem. I'll just leave it be. :s
10:31:22 <sshine> leo_, so Quiet doesn't work for suppressing output?
10:58:31 <refusenick> Is it possible to write Haskell as if it were APL (pointfree composition of operations across generic sequences, no explicit loops or recursion)?
10:59:33 <refusenick> It seems as if non-strict evaluation works against this (Futhark chose strict semantics because it makes parallelism easier)
11:11:28 <jcowan> Is there a typeclass for key-value mapping collections, and if so, what is its name?
11:13:11 <TwentySeven27> exit
11:16:05 <romanix> jcowan, I'm not aware of such a typeclass
11:16:17 <jcowan> huh, I had hoped there would be
11:16:54 <romanix> you can always create one
11:18:08 <TwentySeven27> exit
11:18:16 <jcowan> I've come up with a conceptual description with seven methods: contains, get, set, delete, size, foreach, copy (the last to hide the difference between transient and persistent maps)
11:22:23 <odanoburu> hi, I'm trying to have aeson 1.4.2.0 omit fields with a Nothing value, and I wonder why this doesn't work: `genericToEncoding defaultOptions{omitNothingFields=True, sumEncoding=UntaggedValue} $ object ["foo" .= (Nothing :: Maybe Int)]` -> `"{\"foo\":null}"` (I'd have expected `"{}"`)
11:24:33 <romanix> jcowan, I haven't used this package but perhaps this could work for you? http://hackage.haskell.org/package/collections-api
11:33:22 <lyxia> odanoburu: because this only works on data types that are records, and Value is not a record.
11:35:49 <jle`> jcowan: maybe also mono-traversable, which is at the heart of the conduit ecosystem
11:35:56 <jle`> @hackage mono-traversable
11:35:56 <lambdabot> http://hackage.haskell.org/package/mono-traversable
11:37:32 <odanoburu> lyxia: thanks for the information! I guess I'll have to omit them myself then
11:45:25 <EvanR> @tell refusenick https://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/aplicative.pdf
11:45:25 <lambdabot> Consider it noted.
11:53:09 * hackage forma 1.1.3 - Parse and validate forms in JSON format  https://hackage.haskell.org/package/forma-1.1.3 (mrkkrp)
12:13:09 * hackage mmark 0.0.7.2 - Strict markdown processor for writers  https://hackage.haskell.org/package/mmark-0.0.7.2 (mrkkrp)
12:49:09 * hackage cobot-io 0.1.2.1 - Biological data file formats and IO  https://hackage.haskell.org/package/cobot-io-0.1.2.1 (zmactep)
12:57:39 * hackage bond 0.12.0.1 - Bond schema compiler and code generator  https://hackage.haskell.org/package/bond-0.12.0.1 (chwarr)
13:04:09 * hackage calenderweek 1.0.0 - Commandline tool to get week of the year  https://hackage.haskell.org/package/calenderweek-1.0.0 (rmeis)
13:31:15 <mpickering> Is `eventful` the library I should use for event sourcing?
13:40:08 * hackage inline-c 0.9.0.0 - Write Haskell source files including C code inline. No FFI required.  https://hackage.haskell.org/package/inline-c-0.9.0.0 (FrancescoMazzoli)
13:41:09 * hackage inline-c-cpp 0.3.1.0 - Lets you embed C++ code into Haskell.  https://hackage.haskell.org/package/inline-c-cpp-0.3.1.0 (FrancescoMazzoli)
13:49:08 * hackage inline-c-cpp 0.4.0.0 - Lets you embed C++ code into Haskell.  https://hackage.haskell.org/package/inline-c-cpp-0.4.0.0 (FrancescoMazzoli)
14:00:55 <heebo> hello , im i cant seem to stack build a package i think the stack.yaml is out of date https://github.com/joe9/streaming-betfair-api/blob/master/stack.yaml
14:01:07 <heebo> can anyone tell me what i have to do to compile it?
14:03:18 <evelyn> That's an old snapshot version. You can try to use it as it is but it may not work. Otherwise, update the snapshot to a recent version *(like lts-14.16) and update extra-deps accordingly. This may not work, though.
14:04:57 <fendor> heebo, while the snapshot is old, you should rather say what the exact error is. stack *should* be able to build any snapshot at any time
14:05:39 <solrize> $ stack ghc -- a.hs
14:05:39 <solrize> Downloaded lts-13.26 build plan.    
14:05:39 <solrize> AesonException "Error in $.packages.cassava.constraints.flags['bytestring--lt-0_10_4']: Invalid flag name: \"bytestring--lt-0_10_4\""
14:05:39 <solrize>      is this a usual thing?
14:05:50 <solrize> compiler downloading stuff :(
14:06:18 <glguy> solrize: What version of stack?
14:06:24 <fendor> solrize, what is the stack version?
14:06:27 <solrize> sec
14:06:28 <fendor> damn it, too slow
14:06:43 <solrize> $ stack --version
14:06:43 <solrize> Version 1.5.1, Git revision 600c1f01435a10d127938709556c1682ecfd694e (4861 commits) x86_64 hpack-0.17.1
14:07:00 <fendor> solrize, very, very old version
14:07:11 <solrize> ok i'll see if i can figure out how to upgrade thanks
14:07:16 <fendor> stack upgrade
14:07:37 <solrize> ah my PATH needs update
14:07:55 <solrize> now 2.1.3
14:08:00 <solrize> not sure why it was wrong
14:08:03 <heebo`> what do i need to do?
14:10:04 <evelyn> heebo`: it depends, di you try what fendor suggested?
14:10:28 <heebo`> stack upgrade ok ill try that thanks
14:10:43 <evelyn> no, no, what's the error?
14:10:58 <heebo`> ould not parse '/Users/greg/dev/haskell/streaming-betfair-api/stack.yaml':
14:10:59 <heebo`> Aeson exception:
14:10:59 <heebo`> Error in $.packages[1]: failed to parse field 'packages': expected Text, encountered Object
14:10:59 <heebo`> See http://docs.haskellstack.org/en/stable/yaml_configuration/
14:14:52 <heebo`> my stack version is Version 2.1.3, Git revision 0fa51b9925decd937e4a993ad90cb686f88fa282 (7739 commits) x86_64 hpack-0.31.2
14:16:37 <fendor> heebo`, I think you moved accidentally some lines. lines 5-8 in stack.yaml should be in extra-deps
14:17:02 <heebo`> thanks ill try that
14:18:55 <fendor> heebo`, however, do these locations actually exist?
14:19:44 <heebo`> ummm , this is questionable
14:21:37 <heebo`> but they seem to be in hackage , i can just add to cabal i guess or set the location to the git commit
14:21:52 <heebo`> ill give that a shot, its a bit of a sloppy repo
14:23:44 <koz_> Is it just me, or is linking a Cabal project under Windows _really_ slow?
14:24:38 <heebo`> i see they changed the syntax (https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md) thanks ppl
14:47:09 <hseg> Hi. I'm trying to set up haskell on arch linux, am getting seriously confused. What's the recommended workflow? cabal-install/stack in a local cache, nix?
14:47:36 <heebo`> i think stack is simplest
14:47:57 <heebo`> closely followed by cabal
14:48:00 <hseg> static/dynamic compilation?
14:48:05 <hseg> (note arch linux)
14:48:30 <hseg> also, i see it's hard to uninstall packages, iiuc?
14:49:09 <heebo`> im not sure to be honest, im no expert with build tools (see above)
14:50:22 <hseg> from what i see arch's packaging breaks stuff
14:55:44 <koz_> hseg: Do you specifically _want_ Stack for something?
14:55:51 <koz_> (HIE, IDE, some other such thing?)
14:55:57 <hseg> nope
14:56:16 <koz_> Well, I can walk you through setting up cabal new-* stuff on Arch if you want.
14:56:17 <hseg> just want ghc and some packages
14:56:40 <hseg> OK
14:56:50 <koz_> I'll PM you, because it'll be a lot of chatter.
15:07:50 <xenon-> @hoogle Maybe [a] -> [a]
15:07:51 <lambdabot> Prelude concat :: Foldable t => t [a] -> [a]
15:07:51 <lambdabot> Data.List concat :: Foldable t => t [a] -> [a]
15:07:51 <lambdabot> Data.Foldable concat :: Foldable t => t [a] -> [a]
15:08:15 <xenon-> > concat $ Just [1,2,3]
15:08:17 <lambdabot>  [1,2,3]
15:08:25 <xenon-> neat
15:08:52 <xenon-> it used to be just [[a]] -> [a] or am I imagining things?
15:09:47 <Polarina> xenon-, lists implement Foldable, so one specialization of that type is indeed [[a]] -> [a].
15:13:55 <amalloy> xenon-: https://wiki.haskell.org/Foldable_Traversable_In_Prelude i think is the relevant thing
15:13:55 <xenon-> I meant that I don't remember concat being generic. was it generic from the start?
15:14:44 <amalloy> Polarina: the thing being specialized there is Maybe, not []
15:17:08 <dmwit> xenon-: You are not imagining things.
15:19:45 <jacks> hi
15:19:54 <jacks> should I store timestamp as UTCTime or ZonedTime? it represents the time user added a note, and it will be shown to the user when displaying the notes
15:21:06 <Polarina> jacks, store timestamps in UTC and convert to ZonedTime only for presentation.
15:21:50 <Axman6> if necessary also store the timezone the timestamp was created in, but generally UTC is enough
15:22:30 <jacks> if I am storing both UTC and timezone, isnt that basically ZonedTime?
15:22:52 <EvanR> note ZonedTime contains an offset, not a full time zone
15:23:08 <EvanR> see TimeZoneSeries from timezone-series
15:23:10 <Axman6> jacks: however, this somewhat depends on where you're storing the times - most databases do an awful job of dealing with times, I usually resort to storing times as either an ISO8601 timestamp text, or in a time column which is explicitly only used at UTC time
15:24:00 <EvanR> for presentation i find the timezone-series is nicer to show than an offset
15:24:08 <EvanR> many people don't know their offset
15:24:16 <EvanR> also offset changes through history
15:24:56 <EvanR> "US Central Time" vs "+6"
15:25:05 <Polarina> It gets even trickier when working with timestamps into the future.
15:25:24 <jacks> Basically, my question is, is it true that zonedtime has more information than UTC? You can always get UTC out of ZonedTimed, but not the opposite (obviously UTC + TimeZone is even better)
15:25:28 <Polarina> You don't know your timezone in advance. New laws may pass that change them.
15:25:32 <EvanR> (and +6 is a lie to do DST)
15:25:51 <EvanR> jacks: yeah but that info is kind of useless, the offset
15:26:37 <EvanR> basically, ZonedTime is equivalent to storing a UTCTime and a LocalTime as a pair
15:26:44 <jacks> Are you sure it is just the offset? Show instance prints timezone name
15:26:49 <EvanR> not really a time zone
15:27:03 <EvanR> yeah a Data.Time TimeZone is an offset and a string for the name
15:27:59 <EvanR> s/to do DST/due to DST/ gawd ... these typos
15:28:27 <jacks> EvanT I mean show instance of ZonedTime prints timezone name
15:28:46 <EvanR> it prints the string that is sitting there in the TimeZone
15:29:06 <EvanR> the rest of the data is a number of minutes offset from UTC
15:29:14 <EvanR> and ... that is not really a time zone at all
15:29:18 <jacks> So it stores full Timezone
15:29:23 <EvanR> not really
15:29:33 <EvanR> offset /= time zone
15:29:51 <jacks> It has offset, and timezone name, which is TimeZone
15:29:53 <EvanR> unless you're talking about cron, which breaks during DST
15:30:19 <EvanR> i'm telling you, what most people call a time zone, is not a name + and offset :)
15:30:36 <EvanR> it's a complicated thing which you can access with the timezone-series package
15:31:22 <EvanR> what the user really has is a UTCTime and a timezone-series that they are in
15:32:27 <EvanR> i don't live in UTC-6, i live in US Central Time which varies between -6 and -5
15:32:31 <jacks> Ok, I think I dont care enough to bring in another package
15:32:36 <EvanR> ok
15:32:45 <jacks> But interesting nonetheless
15:33:20 <jacks> I need to get this done. Can I always convert ZonedTime to UTCTime?
15:33:28 <jacks> I guess not?
15:33:33 <EvanR> doing enough ruby on rails you get used to standard timezone-series like "Central Time (US & Canada)"
15:33:53 <EvanR> yeah you can lose the TimeZone and go from ZonedTime to UTCTime whenever
15:34:06 <EvanR> @where time
15:34:06 <lambdabot> https://wiki.haskell.org/Time
15:34:21 <juri_> @where love
15:34:21 <lambdabot> http://en.wikipedia.org/wiki/Where_Is_Love%3F
15:34:45 <juri_> @where truth
15:34:45 <lambdabot> I know nothing about truth.
15:35:08 <jacks> What if timezone changes in the future
15:35:18 <EvanR> what exactly do you mean
15:35:30 <EvanR> the user moves?
15:35:44 <EvanR> or govt changes the schedule again
15:36:26 <jacks> s/timezone/daylight savings for the timezone in question. It is happening now in EU
15:36:59 <EvanR> well, the UTCTime of an event won't change
15:37:32 <EvanR> if a user is looking at a report and their local timezone is set to a timezone-series, then past times will still show correctly
15:37:41 <EvanR> if it's set to an offset, it'll just be wrong anyway
15:37:45 <jacks> ZonedTime would be incorrect if that happens, but would still be convertible to UTCTime?
15:38:06 <EvanR> old ZonedTimes won't be incorrect
15:38:28 <jacks> Old ZonedTimes for future dates would be
15:38:46 <EvanR> or would they
15:39:08 <EvanR> for example, someone specified they want to arrive at 3 oclock on some day in the future
15:39:11 <EvanR> local time
15:39:11 <jacks> Are you saying they wouldnt be?
15:39:23 <EvanR> that UTCTime would have to change if the govt changed the time zones
15:39:26 <EvanR> get it? :)
15:39:39 <jacks> No
15:39:54 <EvanR> people can specify a future local time
15:40:12 <EvanR> what time that is UTC depends on time zones 
15:40:37 <EvanR> that havent happened yet!
15:41:17 <EvanR> this is why booking services for future events should really use LocalTime
15:41:25 <jacks> If you substracted that future ZonedTime, stored with old (incorrect in the future) daylight savings, you would get erong duration
15:41:33 <EvanR> where the LocalTime is in the local time of that event
15:41:37 <jacks> Wrong*
15:41:56 <EvanR> subtracted what with what?
15:42:42 <jacks> Future ZonedTime with current ZonedTime
15:42:53 <EvanR> that operation sounds quite dubious
15:43:09 * hackage egison 3.10.1 - Programming language with non-linear pattern-matching against non-free data  https://hackage.haskell.org/package/egison-3.10.1 (SatoshiEgi)
15:43:18 <jacks> Huh?
15:43:50 <dibblego> this is the reason for the QFPL time policy in the code of conduct
15:43:52 <EvanR> you can subtract two UTCTimes to get a duration
15:44:04 <jacks> Does Data.Time support that?
15:44:11 <EvanR> sure
15:44:15 <dibblego> https://gist.github.com/tonymorris/90522094bb964fd0d7bb42acd43ff4fb#times
15:44:31 <jacks> Sybtracting two ZonedTimes, not UTCTimes
15:44:44 <EvanR> but the issue is that a future LocalTime is not necessarily known in UTC
15:45:07 <EvanR> (ZonedTime being a proxy for LocalTime)
15:45:36 <EvanR> so subtracting them seems dubious, just like you just said
15:45:39 <laudecay> i guess im here at a more normal time now- anyone know how to get in touch w cryptosink devs
15:45:48 <dibblego> jacks: imagine I rang you right now and said, "talk to you at 8am 03 3 March next year" — which 8am? What if the government changes your local timezone? Or mine? Do you even know mine?
15:45:52 <laudecay> i wanna submit a PR to get xchacha20poly1305 working
15:46:09 <dibblego> s/03/at
15:46:46 <jacks> dibblego, I understand the issue.
15:46:51 <dibblego> ok
15:47:37 <dibblego> fwiw, professions where telling the time unambiguously is safety critical, use a fixed time reference datum
15:48:20 <jacks> So Data.Time does not support that. So what does a programmer do? He converts ZonedTimes to UTCTimes, then subtracts those.. same issue :)
15:48:24 <EvanR> booking services regularly handle future times of events, and precisely because of this problem, they should just use the local time itself and let the UTC wander until it happens
15:48:50 <EvanR> jacks: we were trying to explain that it doesn't make logical sense, nothing to do with Data.Time
15:49:43 <EvanR> i think ZonedTime is mildly meaningless for many things, this being one of them
15:50:22 <EvanR> LocalTime is meaningful, UTCTime is meaningful, but their relationship is complicated
15:50:35 <jacks> So what would you store in database again? UTCTime, or UTCTime + timezone series?
15:51:05 <EvanR> well, we determined at least two examples for why it depends
15:51:08 <jacks> But you can get both UTCTime and LocalTime out of ZonedTime
15:51:08 <amalloy> i think it's useful to make a distinction between physical time (number of milliseconds since some fixed reference) and civil time (based on some way humans have decided to describe time)
15:51:13 <EvanR> what are you trying to accomplish
15:51:41 <EvanR> amalloy: oh man... now you're talking about AbsoluteTime which is a different can of worms no one invited! :)
15:51:48 <jacks> ZonedTime -> LocalTime is a lossy operation. So is ZonedTime -> UTCTime
15:52:12 <EvanR> the value of ZonedTime in the first place is already suspect imo
15:52:26 <amalloy> am i? i'm not very familiar with haskell's time libraries, but it seemed to me that physical time is basically utctime
15:52:28 <EvanR> especially for the future
15:52:46 <jacks> EvanR shouldnt that be ONLY for the future?
15:52:47 <EvanR> amalloy: no they differ by seconds over the course of history... 
15:52:58 <EvanR> which is why we have NominalDiffTime
15:53:16 <amalloy> ah, utc gets leap seconds applied to it
15:54:15 <EvanR> jacks: for past ZonedTime, you can argue it definitely means a UTCTime, a LocalTime, and a string
15:54:23 <EvanR> and the data is right. I think
15:56:04 <EvanR> but i'm still skeptical
15:56:36 <EvanR> UTCTime shifted by a number of minutes may land at a time that has no valid local time in someone's timezone
15:57:02 <EvanR> so the value would be deeply meaningless
15:59:40 <EvanR> er, i'm wrong. It may land at an ambiguous time. It's going the other way that may bottom out
16:01:11 <jacks> Yes
16:04:25 <jacks> Bbl, my phone irc keeps disconnecting on autolock
16:04:38 <jacks> Thanks for input everyone
16:09:35 <dibblego> "Eucla time" is a personal favourite
16:09:57 <dibblego> Eucla, Western Australia, population 53, has its own time zone
16:12:02 <amalloy> EvanR: fwiw i think a totally reasonable approach to leap seconds is to pretend they don't exist. you obviously can't pretend time zones don't exist, but leap seconds are both rare and small
16:12:21 <jle`> i wonder if there is a region that still primarily uses a different calendar than gregorian
16:12:30 <jle`> so l10n has to convert to that calendar to display dates
16:12:52 <jle`> in the time i had to count out the letters to localization to be able to write l10n i could have just written localization
16:13:01 <amalloy> just write lNn
16:13:04 <amalloy> very clear
16:13:10 <jle`> l(length "localization" - 2)n
16:13:36 <dibblego> http://metar.online/metar/ybaf "260000Z" this bit is a time
16:13:57 <dibblego> http://metar.online/taf/ybaf/ and this bit "252257Z" and this is a time interval "2600/2612"
16:14:26 <jle`> reminds me i wanted to write a physics simulator on GR so you can simulate time dilation and stuff near planetary or solar surfaces, observing how time flows differently
16:14:44 <jle`> i worked out the math but i couldn't figure out any interesting application of the program so i never got to it
16:15:28 <jle`> maybe a video game where you have to get to work on time so you jump up and down to different rates of time flow to get there by 8:00am
16:16:29 <Spock> give it a really slow speed of light and make a hide and seek game
16:17:07 <jle`> that just sounds like that SR game that MIT put out
16:17:12 <Spock> or make it like a thief game
16:17:23 <Spock> if you move fast your mass increases, make gravity really sensitive to that
16:17:31 <Spock> so you can pull things through windows by running by them really fast
16:18:07 <Spock> and to sneak through places you control your speed to color-match the surroundings
16:18:59 <jle`> hm the math i worked out only works for very simple spacetime geometries so it can show how your own motion is affected by GR but not how other objects would be affected by your own contributions to spacetime. so the first thing doesn't work but the color thing would
16:19:59 <Spock> oh, and if you get seen the guards follow your light trail
16:38:54 <koz_> jle`: That game should be called 'Archailect Simulator' lol.
16:40:50 <jle`> i just want to be able to help everyone experience the stress of being late to work
16:46:31 <nshepperd2> you could make an excessively future-proof time library
16:47:21 <nshepperd2> suitable for timekeeping in the future galactic empire
16:48:57 <glguy> too many time libraries make assumptions about things like the number of days in a week or the months in a year. I need more flexibility!
16:49:31 <dibblego> type Time = [()]; bigbang = []
16:49:59 <glguy> dibblego: What time is it now in that model?
16:50:16 <dsal> How many time units since big bang?
16:50:24 <Axman6> glguy: when did you ask?
16:50:33 <dibblego> many plancks
16:50:34 <shachaf> Does a timestamp independent of a space position even make sense?
16:50:47 <dsal> shachaf: not at ()
16:50:49 <dibblego> shachaf: was going to ask which space position :)
16:50:56 <glguy> shachaf: I'm the center of my universe
16:51:01 <jle`> it sort of does if you consider proper time relative to the CMB
16:51:29 <dibblego> quite regularly, I get people email, "talk to you at 8am" and I have to apply a heuristic to determine where they are, and what they think 8am means
16:52:00 <dsal> dibblego: at least when they say AM you have some clue.  I reject 12 hour time, which is awkward, but people still make fun of me when they're 12 hours late.
16:52:23 <jle`> why would they make fun of you when they are the one who is late >:(
16:52:27 <dibblego> so do I, reject 12 hour time, and timezones
16:52:49 <dsal> jle`: People are weird.  They screwed up, but at least they're not nerds.
16:52:58 <dibblego> http://metar.online/metar/ybaf 260030Z was a little over 22 minutes ago
16:53:08 * hackage predicate-typed 0.6.0.0 - Predicates, Refinement types and Dsl  https://hackage.haskell.org/package/predicate-typed-0.6.0.0 (gbwey)
16:53:26 <glguy> dibblego: Right, because each day is really four separate days
16:53:31 <dibblego> if they are in .au the heuristic skews toward "Sydney", in that particular case
16:53:47 <dibblego> glguy: ?
16:53:51 <nshepperd2> haha
16:53:54 <shachaf> glguy knows what's up.
16:54:01 <Axman6> It clearly skews towards Canberra, being the capital 'n all
16:54:08 <glguy> dibblego: https://en.wikipedia.org/wiki/Time_Cube
16:54:16 <dibblego> Axman6: Canberra people are a little more responsible with telling the time
16:54:17 <shachaf> Four simultaneous type systems in a single rotation of the lambda cube.
16:54:23 <Axman6> dibblego: <3
16:54:23 <dibblego> glguy: dammit
16:54:36 <dsal> I work in an international company that generally expresses time in my personal local time, so that's convenient.
16:54:36 <dibblego> glguy: I have a 4 earth year long joke around that
16:55:01 <dibblego> the joke starts with, "I have a very common and mistaken email address"
16:55:21 <glguy> dsal: Do you work at Swatch? Do you use beats?
16:55:35 <dsal> glguy: I was just thinking I was the only person who remembered that.
16:55:43 <dsal> almost made that joke, but it felt too obscure.
16:57:47 <jle`> the real solution is to move time to the blockchain
16:58:04 <jle`> so it can be decentralized from any central authority
16:58:06 <dsal> Without being able to prove causality, there's no point in time, anyway.
16:58:08 <glguy> Ah, is this what the blockchain is for?
16:58:34 <jle`> each hour is a link on a distributed ledger
16:59:01 <dsal> Without at least three others agreeing, there's no consensus that the hour actually happened.  This could be useful.
16:59:13 <jle`> so setting appointments in the future is a matter of projecting when the next block will be added
16:59:33 <jle`> "meet me at block 2984123 ... approximately 5 blocks from now"
17:04:32 <dsal> My house is about three blocks from here, depending on when I leave.
17:07:11 <koz_> Has anyone here used streamly to do file watching? I'm currently having severe CPU load and what feels like a space leak trying to watch 25 files.
17:07:33 <nshepperd2> https://en.wikipedia.org/wiki/Barycentric_Coordinate_Time
17:10:03 <EvanR> koz_: doesn't sound right... watching should be event based...
17:10:26 <koz_> EvanR: If you can suggest me a library which makes sense that does this in a portable way and is documented, I am all ears.
17:10:38 <EvanR> portable you say
17:10:52 <koz_> EvanR: Well, in the sense of 'will work on Windows without me having to bend myself out of shape'.
17:11:08 * hackage yst 0.7.1 - Builds a static website from templates and data in YAML orCSV files.  https://hackage.haskell.org/package/yst-0.7.1 (JohnMacFarlane)
17:12:03 <MarcelineVQ> streamly can implement frp so it can surely handle watching some files
17:13:11 <koz_> MarcelineVQ: Once again, all ears to all suggestions.
17:13:22 <koz_> That was kinda why I went with streamly to begin with.
17:14:38 * hackage pandoc-pyplot 2.3.0.0 - A Pandoc filter to include figures generated from Python code blocks  https://hackage.haskell.org/package/pandoc-pyplot-2.3.0.0 (LaurentRDC)
17:15:34 * MarcelineVQ watches the ghost of haskellers past waft through, whispering the dread words, 'whaaatt haveee you triiiedd....'
17:16:54 <Axman6> newhoggy: I'm having a play with HaskellWorks.Data.Dsv.Strict.Cursor and struggling to figure out what snippet, nextField, nextPosition and nextRow are supposed to do? if I iterate each of these functions only nextPosition seems to produce any useful output (running  mapM_ print $ take 100 $ unfoldr (\(a,b,c) -> Just ((snippet a,snippet b,snippet c), (nextRow a, nextField b, nextPosition c))) (cur,cur,cur))
17:17:39 <koz_> MarcelineVQ: I tried writing it with varying (same problem with like twice the confusion), Win32-notify (non-compositional, leaks like a sieve, burns CPU like it's going out of style), and fsnotify (not documented worth a damn). Unclear how to integrate those two into anything resembling an FRP anything which I will need at some point.
17:18:20 <koz_> This attempt with streamly is my latest take, using System.Directory functions to do the checking (specifically for last modification), and composing WAsyncT streams with <>.
17:18:51 <EvanR> so the issue is really "windows support"
17:18:57 <Axman6> newhoggy: when I run that, the very first iteration prints the first column's header is printed by all three calls to snippet, but aftere that the first two only print "" and the last iterates through each header dropping one character at a time
17:19:09 <koz_> EvanR: I don't think 'Windows support' is really the problem here somehow, unless Windows is inherently awful at file watching.
17:19:17 <koz_> (which I could 100% believe)
17:19:24 <koz_> (but I dunno because I'm not usually on it)
17:19:44 <EvanR> crazy
17:20:22 <koz_> I decided I'd ask on streamly's repo to hear any suggestions. Perhaps I am merely using it wrong.
17:20:40 <koz_> It's not helped by the fact that I'm on an unfamiliar OS, working on an unfamiliar task, with unfamiliar libraries.
17:20:49 <koz_> Like, I'm a long way from the Haskell I'm used to.
17:22:07 <EvanR> don't go chasing windowsfails stick to the *nix and macos you're used to
17:22:47 <koz_> EvanR: Unfortunately this is not an option I have.
17:22:50 <koz_> (this is for work)
17:34:40 <koz_> Alrighty, seems the streamly maintainer is like, super-responsive.
17:34:44 <koz_> (if you're in here, thank you!)
17:38:38 * hackage haskell-ci 0.8 - Cabal package script generator for Travis-CI  https://hackage.haskell.org/package/haskell-ci-0.8 (phadej)
17:52:40 <Phyx-> koz_: actually Windows has a pretty good file watching API with FindFirstChangeNotificationW  and friends that work great, see https://docs.microsoft.com/en-us/windows/win32/fileio/obtaining-directory-change-notifications
17:52:58 <koz_> Phyx-: Can I use this from Haskell?
17:53:07 <koz_> And if so, with what?
17:53:46 <Phyx-> koz_: now whether any haskell package has taken the proper approach I don't know. it may be that people has done what EvanR did and just not did it right because they don't know Windows
17:54:20 <koz_> Phyx-: Well, either way, if there isn't a Haskell package for this, I'd have to write the FFI by hand.
17:54:29 <koz_> Which I am _willing_ to try at this point, but I'd rather not.
17:54:37 <jackdk> https://github.com/haskell-fswatch/hfsnotify/blob/master/win-src/System/Win32/FileNotify.hsc seems like fsnotify supports windows' filenotify stuff
17:55:06 <Phyx-> koz_: the api is in Win32 so you can use it following the second link I sent which builds an example
17:55:53 <koz_> Phyx-: Second link? I only saw the docs.microsoft one.
17:55:56 <EvanR> wait how is this my fault
17:56:32 <Axman6> It's always your fault Evan
17:56:46 <Axman6> typical Evan
17:57:21 <Phyx-> koz_: ah yes, sorry meant that one
17:57:56 <Phyx-> 01:21:44 < EvanR> don't go chasing windowsfails stick to the *nix and macos you're used to <-- becuase this is the kind of BS that makes Windows support stay bad
17:58:26 <Phyx-> koz_: first one was supposed to be https://github.com/haskell/win32/blob/c5f1d13f2edc19aceb87503cd20861d9b94b1cca/System/Win32/File.hsc#L577
17:58:43 <EvanR> k that was a joke based on koz_'s remark. I didn't internalize the possibility that windows can't do this
17:58:43 <koz_> Phyx-: Thanks, I will look at that.
17:58:51 <EvanR> good to know there's a proper API available
17:59:09 <Phyx-> koz_: that said, the package jackdk sent looks to have done it right, so you'll be much better of using it if possible
18:00:38 <koz_> hfsnotify isn't documented much.
18:00:41 <Axman6> surely Windows support is going to get better with WSL =)
18:00:53 <koz_> (especially if I want to use it with ... well, any FRP anything, for example)
18:01:04 <koz_> (since that's far from the only thing I'm gonna have to mess with)
18:01:43 <EvanR> i'm number 1 person who laments who little love windows gets in haskell
18:01:54 <Phyx-> they've used a different interface, ReadDirectoryChangesW, but that's one that should fit a lot better with GHC's new windows I/O manager
18:01:55 <EvanR> i bought a windows box but still haven't set up haskell yet
18:02:11 <Phyx-> Axman6: that's not Windows so no
18:03:34 * Axman6 removes tounge from cheek
18:03:44 <Phyx-> koz_: it looks like pretty straight forward. it seems to mostly wrap the Win32 API functions. see https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-readdirectorychangesw
18:04:03 <koz_> jackdk: Wait, did you link this library? http://hackage.haskell.org/package/fsnotify
18:05:08 * hackage dhall-fly 0.2.0 - Translate concourse config from Dhall to YAML  https://hackage.haskell.org/package/dhall-fly-0.2.0 (axeman)
18:05:46 * Axman6 glares at this axeman imposter
18:07:29 <koz_> Phyx-: Win32 (the Haskell library) doesn't seem to have bindings to this function. I guess it's FFI time for me?
18:08:33 <Phyx-> koz_: so whatever you do I'd recommend going the same approach as that hfsnotify package, e.g. using the ReadDirectoryChangesW interface. in GHC 8.12 you'll be able to hook that into the I/O manager directly. This will allow you to use it asynchronously and service it with much lower overhead
18:09:11 <koz_> Phyx-: I'm on 8.8.
18:09:18 <koz_> But I guess it's still the right idea?
18:09:50 <Phyx-> koz_: yeah, though the interface is fairly simple. If you get it to work do submit it to Win32. I'd be happy to add it
18:10:31 <koz_> Phyx-: I'll give it a go. I'll wait to hear back from the streamly maintainer - I might be able to write streamly-fswatch. :P
18:10:35 <Phyx-> koz_: yes, the only difference is it'll be a blocking call. so you will need -threaded for it to work correctly
18:10:43 <koz_> Phyx-: I'd be using -threaded anyway.
18:10:47 <koz_> So this isn't a big issue.
18:11:30 <Phyx-> and you can't cancel the operation, which is what the async api provide :)
18:12:13 <Phyx-> koz_: I assume eventually you'll be on 8.12 too :) We'll switch winio on by default at some point
18:13:46 <koz_> Phyx-: Sure, I would be.
18:14:00 <koz_> Cancellation is also not much of a concern for me - the watching has to be for the entire running time of the program.
18:14:40 <Phyx-> fair enough
18:15:31 <koz_> Phyx-: Are you generally a good person to ask about Haskell on Windows? I'm gonna be doing a lot of this, and as you can tell, have no idea wtf I am doing.
18:18:32 <Phyx-> koz_: Well, I've written a not insignificant amount of code for Windows support in GHC including the new I/O manager so :)
18:18:33 <iqubic> koz_: Windows is terrible, don't use it.
18:18:53 <koz_> iqubic: I don't have a choice, since this is for work.
18:19:39 * hackage monoidal-containers 0.6.0.1 - Containers with monoidal accumulation  https://hackage.haskell.org/package/monoidal-containers-0.6.0.1 (abrar)
18:21:19 <Axman6> Phyx-: thank you for your service (I hate the phrase, but the sentiment applies here)
18:23:09 <koz_> Phyx-: Thank you, shall keep in mind. You also deserve all the rum cookies.
18:23:12 <Phyx-> Axman6: lol, np :) Still has a long way to go but we're getting there
18:23:15 <koz_> (assuming you enjoy rum and/or cookies)
18:24:59 <Phyx-> hmm never heard of rum cookies :O
18:25:24 <koz_> Phyx-: Take your favourite cookie recipe. Add rum. Then proceed as usual.
18:25:30 <koz_> Chocolate optional but suggested.
18:25:47 <Phyx-> aha
18:26:14 <Phyx-> speaking of which.. need to add the 8.10 alpha to chocolatey..
18:26:14 <koz_> Again, assuming you like either of those things.
18:26:19 <koz_> Lol.
18:26:32 <Phyx-> but it's 2.30am so I'll do that tomorrow. going to bed. night
18:26:40 <koz_> See ya! Thanks for the help!
18:28:25 <newhoggy> Axman6:  `nextPosition` moves to the next character.
18:29:23 <Axman6> newhoggy: the other two don't seem to do anything useful (though I'm also not sure if snippet is the right thing to debug with - could use some docs =)
18:29:57 <newhoggy> Yeah, I need to write more docs :D
18:30:16 <newhoggy> You need to use `nextPosition` to get anything useful out of the others.
18:30:38 <Axman6> so nextField . nextPosition should move to the next field?
18:30:55 <newhoggy> Yeah, something like that.
18:31:03 <newhoggy> Calling `nextField` on its own it will get stuck.
18:31:31 <newhoggy> See this from the source code:
18:31:36 <newhoggy> https://www.irccloud.com/pastebin/gdoNE7kB/
18:32:16 <newhoggy> `nextField` takes you the the delimiter before the next field.  So repeated calls on it won't get you anywhere.
18:32:25 <newhoggy> You need to skip the delimiter with `nextPosition`.
18:33:30 <Axman6> This seems to do sensible things: mapM_ print $ take 100 $ unfoldr (\(a,b,c) -> Just ((snippet a,snippet b,snippet c), (nextPosition . nextRow $ a, nextPosition . nextField  $ b, nextPosition c))) (cur,cur,cur)
18:33:57 <Axman6> (Where sensible means mostly nonsense but it's extracting the data as I'm expecting)
18:34:21 <siraben> How do I pronounce (<*>) ?
18:34:34 <siraben> Ap?
18:34:46 <Axman6> I usually say 'apply'. dibblegowill tell you it's anglebum
18:34:55 <Axman6> dibblego will*
18:35:46 <newhoggy> 👌
18:37:35 <Axman6> newhoggy: how difficult would it be to write a function move a cursor to row i? is that constant time?
18:41:07 <jackdk> koz_: I linked the source repo of that library, showing the actual windows code
18:41:59 <newhoggy> Should be pretty easy.
18:43:29 <newhoggy> If you look inside `nextRow`, you'll see `newPos = select1 (dsvCursorNewlines cursor) (currentRank + 1) - 1`
18:44:06 <newhoggy> Replace `(currentRank + 1)` with the row number you want.
18:44:42 <newhoggy> This will take you the delimiter before that row I think.
18:45:16 <newhoggy> s/delimeter/newline
18:45:18 <newhoggy> Which means you may need to special case the 0-th row because the 0-th row doesn't have a preceding newline.
18:46:01 <newhoggy> And use `popCount1` to figure out how many rows there are so you don't go out of bounds.
18:52:09 <Nolrai> So whats a good name for the additive/multiplicative distinction, like if I had "data XXXX = Add | Multiply" what should go instead of XXXX?
18:53:11 <dibblego> XXXX is a great name
18:53:11 <jle`> Op ? if you're planning on expanding it to other things
18:53:54 <Nolrai> No its never going to be anything other then additive/multiplicative.
18:53:57 <dsal> I don't think I completely understand unliftio.  I think I'm doing the most basic thing it can do, but it seems a little inconvenient.
18:54:34 <Nolrai> I know I don't understand unliftio..
18:56:19 <newhoggy> As for whether moving to row i is efficient, it depends what index you have on the rank select bit string.  If you build a `CsPoppy` index over it and query that instead, then it should be very fast.  Close to constant time.
18:59:04 <newhoggy> The strict loader should already build the `CsPoppy` index.
18:59:25 <newhoggy> If your cursor type is `DsvCursor ByteString CsPoppy` then you're good.
18:59:49 <newhoggy> Axman6: ⬆️
19:05:15 <Axman6> sweet, thanks newhoggy!
19:18:37 <cheater> is there a function that will do the following? let a = Nothing; let b = Just 2; x = a ?? b -- Nothing; x = b ?? a -- Nothing
19:18:50 <cheater> generally for any Monad that can be "empty"
19:20:16 <Axman6> liftA2 fst or snd?
19:20:57 <[Leary]> *> or <*?
19:21:02 <Axman6> the i9nteresting case is what do you want when both are Just
19:21:29 <Guest_32> hey I have a very simple question
19:21:41 <cheater> i guess *> and <* are what i'm looking for
19:21:45 <cheater> [Leary]: yeah! thanks
19:21:55 <Guest_32> how to add the right PATH variable in Mac OS Catalina ?
19:21:56 <cheater> siraben: "ap"
19:22:39 * hackage hw-xml 0.5.0.0 - XML parser based on succinct data structures.  https://hackage.haskell.org/package/hw-xml-0.5.0.0 (haskellworks)
19:22:53 <Guest_32> tried to add export PATH="$HOME/.cabal/bin:${GHCUP_INSTALL_BASE_PREFIX:=$HOME}/.ghcup/bin:$PATH" in ~/.bashrc
19:23:24 <Guest_32> andexport PATH=$HOME/Library/Haskell/bin:$PATH in ~/.profile
19:23:29 <Axman6> have you opened a new terminal since adding that?
19:23:39 <Guest_32> yeah
19:23:51 <Guest_32> zsh: command not found: ghci
19:24:03 <Axman6> echo $PATH?
19:24:06 <Guest_32> I went nano ~/.bashrc
19:24:16 <[Leary]> Why would zsh read your bashrc?
19:24:23 <Axman6> uh, you're using zsh, not bash - you need to edit ~/.zshrc
19:24:28 <Guest_32> gives me /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
19:24:38 <Guest_32> ok get it
19:24:43 <Axman6> Catalina changed the default shell to zsh (hooray!)
19:24:49 <Guest_32> slightly confusing but makes a lot of sense
19:25:13 <Guest_32> no, I think I installed it, hooray, lol
19:27:07 <maerwald> oh, it's happening
19:27:39 <Axman6> IT"S HAPPENING! </ronpaul>
19:27:40 <Guest_32> yeah finally
19:27:43 <Guest_32> gawd
19:27:58 <maerwald> ok, does ~/.zshrc work the same way as ~/.bashrc? I'm not a zsh user
19:28:32 <Axman6> I believe so, but I'm no expert - mine's full of cargo from my cult
19:28:36 <maerwald> https://gitlab.haskell.org/haskell/ghcup/issues/121#note_239049
19:29:16 <Guest_32> haha so how do I get help and how do I quit the intepreter
19:29:27 <maerwald> so most mac users now will have both ~/.bashrc AND ~/.zshrc?
19:29:35 <maerwald> or is there no ~/.zshrc by default
19:30:31 <Axman6> I haven't upgraded so couldn't tell you
19:30:51 <Guest_32> yey, TidalCycles up and running again on a fresh install :)
19:30:55 <Guest_32> thanks guys!
19:37:39 <dmwit> maerwald: zsh is more complicated.
19:37:47 <dmwit> Ideally changes to PATH would go in .zshenv, not .zshrc
19:38:01 <maerwald> is that "sourced" by default?
19:38:03 <dmwit> But many people don't know that, and so don't even have a .zshenv in the first place.
19:38:26 <dmwit> Yes, .zshenv is applied by default.
19:41:06 <dmwit> (The difference is that .zshenv is read by every shell; .zprofile only by login shells; .zshrc only by interactive shells.)
19:42:20 <dmwit> Reading the man pages, it also seems it actually first checks if ZDOTDIR is set and uses that as the directory to look in, only looking in HOME if ZDOTDIR isn't set. I'm willing to bet good money that nobody actually sets that to something other than HOME, though.
19:43:47 <edwardk> even if they do sert ZDOTDIR in a distribution its usually to set up some kind of global info about paths for the system, etc. before delegating to your HOME
19:47:40 <dmwit> Wait, do distributions actually do that instead of using the zsh-supported method of having /etc/zshenv, /etc/zshprofile, /etc/zshrc??
19:47:49 <dmwit> That's evil!
20:05:11 <maerwald> ~/.zshenv does nothing for me
20:09:43 <maerwald> https://unix.stackexchange.com/a/272179 says not to set PATH there
20:09:49 <hololeap> o
20:10:16 <hololeap> i've been trying to solve this hackerrank practice problem. i stumbled upon linear programming and i think it fits: https://www.hackerrank.com/challenges/mango/problem
20:11:29 <hololeap> i think i have the problem laid out in canonical form, but i don't have a math background. i was hoping someone could check my work and help point me in the right direction from there
20:11:44 <hololeap> does anyone know of a pastebin type service where i can put latex equations?
20:15:01 <koz_> hololeap: mathb.in
20:16:27 <hololeap> http://mathb.in/38305?key=c8f4ac0d0e07038ac8dce54bac8e8f8129346e3a
20:22:39 * hackage iproute 1.7.8 - IP Routing Table  https://hackage.haskell.org/package/iproute-1.7.8 (KazuYamamoto)
20:23:41 <dsal> I'm not sure how I feel about this unliftio thing.  It was more invasive than I expected.
20:25:09 * hackage network-byte-order 0.1.2.0 - Network byte order utilities  https://hackage.haskell.org/package/network-byte-order-0.1.2.0 (KazuYamamoto)
20:33:49 <hololeap> actually, it looks really close to the knapsack problem
20:44:45 <EvanR> the distinction between CInt and Int is annoying!
20:45:26 <EvanR> is it really possible for them to be different
20:47:10 <heatsink> The Haskell spec seems to be designed with tagged words in mind
20:47:21 <heatsink> like lisp
20:50:34 <EvanR> interesting
20:52:51 <EvanR> so for SDL i can either convert to and from CInt all over the boundary, or use CInts instead of Ints heh
20:53:12 <EvanR> which would probably cause issues when prelude happens
21:09:02 <dsal> Does anyone use unliftio?  The one thing I seem to want everywhere and appears to be missing is   MonadUnliftIO m => IO a -> m a
21:09:20 <dsal> I wrote that and it's fine, but it kind of seems like an omission.
21:11:38 <MarcelineVQ> that's liftIO :>
21:13:42 <EvanR> :t liftIO
21:13:43 <lambdabot> MonadIO m => IO a -> m a
21:13:46 <jle`> dsal: MonadUnliftIO is a superclass of MOnadIO
21:13:50 <jle`> *subclass
21:14:19 <dsal> OK.  I'm really confused then.
21:14:43 <jle`> dsal: so all instances of MonadUnliftIO have 'liftIO' :)
21:15:05 <EvanR> you're really confused, luckily you are probably in a good shape if you're already doing MonadUnliftIO
21:15:29 <dsal> man...  OK, thanks.  I think I accidentally solved this problem part of the way along and thought I needed unlift for some reason.
21:15:39 <MarcelineVQ> entirely confused is when it stops being fun
21:15:47 <jle`> luckily liftIO is in base these days
21:16:05 <EvanR> you need to be at balmer peak of confused, but no further confused
21:16:21 <EvanR> er, ballmer
21:16:49 <dsal> Yeah, I think I actually wanted MonadIO, but I messed up my parens and went a really long way around. heh
21:17:35 <MarcelineVQ> ballmer peak not to be confused with peak ballmer, which is when you start pronouncing baltimore as ballmer
21:17:52 <dsal> haha
21:59:51 <koz_> dsal: Is a 'bro do u even lift' joke appropriate here? :P
22:00:11 <dsal> Apparently I didn't unlift, so I guess...
22:00:17 <dsal> All I do is lift.
22:00:48 <koz_> dsal: All we ever do is lift.
22:00:53 <koz_> fmap is a lift.
22:00:56 <koz_> pure is a lift
22:01:00 <koz_> lift ... is a lift.
22:01:02 <koz_> etc.
22:01:26 <dsal> Haskell programmers are very strong.
22:02:06 <koz_> dsal: Yes, you can first' and second' through them.
22:03:39 * hackage wss-client 0.3.0.0 - A-little-higher-level WebSocket client.  https://hackage.haskell.org/package/wss-client-0.3.0.0 (igrep)
22:03:58 <koz_> (there's also liftEq and so on)
22:05:09 <dsal> I'm not too sad about this code yet.  I do think I need to find a good logger.
22:13:38 * hackage network-messagepack-rpc-websocket 0.1.1.1 - WebSocket backend for MessagePack RPC  https://hackage.haskell.org/package/network-messagepack-rpc-websocket-0.1.1.1 (igrep)
22:13:43 <phanimahesh> how do I go from lazy bytestring to strict bytestring?
22:14:32 <glguy> toStrict
22:16:03 <phanimahesh> .... I kept looking through hoogle without trying the obvious. :/
22:18:32 <dsal> It doesn't help that everything is named ByteString and there are a few places you might find these functions.
22:23:58 <jle`> for me i would look at the Quick Jump for the bytestring library
22:27:57 <phanimahesh> yeah. Now how do I go the other way around?
22:28:11 <phanimahesh> there doesn't seem to be toLazy
22:28:17 <phanimahesh> atleast none I could find
22:28:38 <phanimahesh> found fromStrict
22:29:31 <EvanR> it's interesting some things are name to, some from. In other languages i don't recall 'from' anything
22:29:49 <EvanR> explain the psychology to me!
22:30:06 <EvanR> in other languages, we don't want to look back
22:30:59 <koz_> EvanR: In other languages, they just cast.
22:31:02 <yushyin> in haskell I see the from prefix so often that I would have thought it would be fromLazy
22:31:14 <koz_> So you don't have 'fromIntegral', you just go '(int)yolo'.
22:44:04 <monochrom> The 4 choices are: X.toY, X.fromY, Y.toX, Y.fromX
22:44:44 <monochrom> and then the decision was made solely based on which module you're writing.
22:45:15 <monochrom> If you're writing module X and you have no say over module Y, then you only have one way.
22:51:09 * hackage tmp-postgres 1.17.0.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.17.0.0 (JonathanFischoff)
22:56:21 <EvanR> that's cool, if i FFI call to the (for some reason unbinded) SDL call SDL_GetWindowBordersSize on a window that was created but without a renderer, the call hangs with 400% cpu usage
22:57:55 <EvanR> what a way to be defeated for the night
22:59:39 * hackage hasbolt 0.1.3.6 - Haskell driver for Neo4j 3+ (BOLT protocol)  https://hackage.haskell.org/package/hasbolt-0.1.3.6 (zmactep)
22:59:43 <EvanR> undefined behavior works in mysterious ways
23:01:38 * hackage tmp-postgres 1.18.0.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.18.0.0 (JonathanFischoff)
23:04:44 <EvanR> nice it was a typo which was basically let x = x in x
23:05:32 * dminuoso waits for an Idris fanboy to rise and yell "Wouldn't have happened with Idris"
23:11:57 <EvanR> if it weren't for quotation it would have already happened!
23:17:43 <jle`> wouldn't have happened in ocaml
23:17:45 <jle`> D:
23:28:31 <MarcelineVQ> dminuoso: but that's okay to write in idris :> some syntax differences aside. let is less expressive but you can put the x = x in a where
23:29:52 <dminuoso> MarcelineVQ: Termination checker?
23:32:30 <MarcelineVQ> safety is opt-in ;>
23:33:05 <MarcelineVQ> there's limitations to be sure though, functions used in types won't reduce if they're not total
23:33:55 <MarcelineVQ> *won't attempt to reduce
23:43:49 <dansho> is there a difference between these two definitions? https://hastebin.com/cukedawafa.hs
23:44:12 <dansho> i can derive Storable on the first, but not the second
23:44:52 <dminuoso> dansho: Yes.
23:45:04 <dminuoso> dansho: The second lacks strictness.
23:45:23 <dminuoso> dansho: You may mistakingly think that adding a hash to a constructor name changes its semantics, but in truth it's just part of the identifier.
23:45:57 <dansho> so Int# fields aren't strict by default?
23:45:59 <dminuoso> Oh wait.
23:46:01 <dminuoso> Mmm
23:46:15 <dminuoso> % data Bar = Bar# Int#
23:46:15 <yahb> dminuoso: 
23:46:28 <dminuoso> % Bar# undefined `seq` ()
23:46:28 <yahb> dminuoso: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:4:6 in interactive:Ghci6
23:46:34 <dminuoso> I did not know this. :o
23:51:16 <dminuoso> I suppose it makes sense.
