00:05:11 <koz_> Identity is the option in Dark Souls where you start with nothing.
00:25:35 <MarcelineVQ> koz_: which ones correspond to thief, pyromancer, and hunter?
00:25:49 <koz_> MarcelineVQ: Thief is StateT
00:25:58 <koz_> Pyromancer is probably ContT
00:26:03 <koz_> Hunter... ReaderT?
00:27:16 <jackdk> Hunter2... ******T
00:30:25 <koz_> Could someone help me get an intuition of what it means for a Profunctor to be Strong?
00:31:54 <nicknotfound> FPC2019 Japan air on
00:52:53 <MarcelineVQ> koz_: https://arxiv.org/pdf/1406.4823.pdf
00:53:04 <koz_> MarcelineVQ: Thanks!
01:28:23 <koz_> MarcelineVQ: That paper is pure gold.
02:44:41 * hackage rosa 0.5.0.0 - Query the namecoin blockchain  https://hackage.haskell.org/package/rosa-0.5.0.0 (rnhmjoj)
02:46:42 * hackage rosa 0.5.0.1 - Query the namecoin blockchain  https://hackage.haskell.org/package/rosa-0.5.0.1 (rnhmjoj)
02:46:57 <berndl> Would it make sense to interpret Foldables as type contructors t such that t a is free monoid (or almost a free monoid)?
03:01:03 <berndl> Foldable + Alternative seems to be what you need for a t to be a free monoid functor.
03:02:42 * hackage futhark 0.12.3 - An optimising compiler for a functional, array-oriented language.  https://hackage.haskell.org/package/futhark-0.12.3 (TroelsHenriksen)
03:09:03 <n0v4> hello, i am looking to do linear algebra over finite fields. is it possible with the `linear` library (https://hackage.haskell.org/package/linear) ? i am new to haskell
03:29:14 <xenon-> hi. what's the best haskell UI framework that works in a web browser? I want to write a local program (not an online web page) that works on every modern os, desktop or mobile
03:32:26 <xenon-> i was thinking of using Threepenny-gui. is it suitable for this? and how to deploy it on, say, a phone? does a phone need to have local webserver running?
03:36:40 <jluttine> Is (>>) equivalent to (*>) ? (For Monads..)
03:37:09 <lavalike> yup
03:40:55 <jluttine> thanks
03:43:36 <MarcelineVQ> xenon-: to be crossplatform in that sense you make the browser your platform. to that end I'd be inclined to try miso and compile to js
03:44:07 <xenon-> what is miso?
03:44:11 * hackage kafka-client-sync 0.1.0.0 - Synchronous Kafka Client  https://hackage.haskell.org/package/kafka-client-sync-0.1.0.0 (felixmulder)
03:45:11 <MarcelineVQ> https://hackage.haskell.org/package/miso
03:46:09 <MarcelineVQ> probably better off at the git https://github.com/dmjio/miso
03:59:04 <dansho> is there something in random-fu to sample from a softmax vector of probabilities like [0.6, 0.2, 0.1, 0.1]?
03:59:32 <dansho> oh, categorical i think
04:04:45 <kevinyins> what is the diff bet  : liftIO print x and print x  ,Both in a do block 
04:04:57 <xenon-> MarcelineVQ, thanks, taking a look
04:08:42 <kevinyins> what confuse me is both work with no problem .
04:11:13 <MarcelineVQ> do is for working with a Monad, IO is a Monad and liftIO lets print work in with Monads that aren't just IO.
04:12:24 <MarcelineVQ> liftIO :: MonadIO m => IO a -> m a    this says that given an IO a, if there's an instance of MonadIO for 'm', you get an 'm a'.  so if they both work exactly the same if means that the m was IO
04:15:32 <kevinyins> MarcelineVQ: I see
04:20:41 * hackage kafka-client-sync 0.1.0.1 - Synchronous Kafka Client  https://hackage.haskell.org/package/kafka-client-sync-0.1.0.1 (felixmulder)
04:23:49 <kevinyins> why  liftIO $ print 2 >> print 3 >> print 4  work , but  print 2 >> liftIO $ print 3 >> print 4 not work   in ghci
04:24:01 <kevinyins> ?
04:24:30 <MarcelineVQ> that $ parses the line as:  (print 2 >> liftIO) (print 3 >> print 4)
04:25:04 <kevinyins> thanks
04:47:11 * hackage ansi-terminal-game 0.6.0.0 - sdl-like functions for terminal applications, based onansi-terminal  https://hackage.haskell.org/package/ansi-terminal-game-0.6.0.0 (fffaaa)
05:44:47 <xenon-> dd
05:47:49 <xmonadnoob> hey I'm new to Xmonad and Haskell and was looking for the tour of the haskell syntax
05:48:06 <xmonadnoob> the link on Xmonad/Config_archive is broken
05:49:19 <merijn> xmonadnoob: I have no clue what that refers to, but I do have a link to "Haskell for Readers" which tries to give a comprehensive intro on how to read existing code: http://haskell-for-readers.nomeata.de/
05:49:35 <xmonadnoob> http://wiki.haskell.org/Xmonad/Config_archive
05:50:27 <xmonadnoob> thanks I'll take a look at that link
06:15:41 * hackage line-drawing 0.2.0.0 - raster line drawing  https://hackage.haskell.org/package/line-drawing-0.2.0.0 (fffaaa)
06:27:41 * hackage cql 4.0.2 - Cassandra CQL binary protocol.  https://hackage.haskell.org/package/cql-4.0.2 (romanb)
06:33:41 * hackage line-drawing 0.3.0.0 - raster line drawing  https://hackage.haskell.org/package/line-drawing-0.3.0.0 (fffaaa)
07:03:42 * hackage cookie 0.4.5 - HTTP cookie parsing and rendering  https://hackage.haskell.org/package/cookie-0.4.5 (MichaelSnoyman)
07:14:15 <xenon-> what library can I use to render text to an image?
07:14:52 <f-a> xenon-: diagrams would do it? or the bindings to imagemagick?
07:17:19 <yushyin> pango?
07:18:16 <xenon-> I'll check them out.. context (as there may be a better way): I couldn't find a way to have remote text in an email, so has a last resort hack, I will render that text as an image
07:19:20 <xenon-> it should have been easy with an iframe, but most email clients do not support it
07:20:49 * yushyin only sees the text part of a multipart email and ignores html
07:21:54 <f-a> yeah xenon- , if it is for you it's ok, but other folks might send html to /dev/null
07:22:43 <dmwit> What does "remote text" mean?
07:22:46 <xenon-> I am sending those emails only to myself and my coworker
07:22:56 <f-a> goo
07:22:57 <f-a> d
07:23:22 <xenon-> dmwit text pulled from a database that may be updated after the email was already sent
07:24:56 <xenon-> my website can render the current data as an image, and I can put that in am email.. but it seems silly that I have to do this. would like to know if there's a better way
07:25:21 <dmwit> You want to change the content of an email after you've sent it?
07:25:26 <dmwit> That's... evil.
07:26:27 <xenon-> the content is html source, so technically it won't change. is it too much to expect that html email supports html?
07:26:58 <xenon-> and I'm not sure what is evil about it
07:27:22 <f-a> xenon-: html and mail clients always has been a sorry partnership
07:27:46 <geekosaur> you are confusing html with javaxxcript, I think. and js has security implications in email
07:27:55 <geekosaur> javascript
07:27:58 <xenon-> iframe is html
07:28:27 <xenon-> remote images have exactly the same security implications, and yet they are supported (and turned on by default in some email clients)
07:29:06 <geekosaur> remote images only allow execution of remote-sourced code if there's a bug in the image renderer, granting that there have been such
07:29:18 <geekosaur> but I don't much like remote images either, for that reason
07:29:37 <xenon-> they can be used to reveal the IP of the receiver
07:29:48 <yushyin> remote image are also used for tracking 
07:33:00 <dmwit> Aaaanyway moral aesthetics aside I second the pango recommendation.
07:49:34 <merijn> It's not gonna work right anyway :p
07:49:45 <merijn> gmail, for example, caches images in emails
07:49:57 <merijn> So readers might see old/stale versions
07:51:23 <__monty__> How "user friendly..."
07:51:28 <merijn> __monty__: It is, actually
07:51:43 <merijn> __monty__: It's to disable tracking who opens/reads emails
07:52:07 <merijn> __monty__: gmail prefetches the image then displays it from their servers, so you can't be tracked that way
07:52:11 <__monty__> I expect the motivation is more, "If we scrape this anyway we should cache it too. That way *we* get the tracking info."
07:52:27 <merijn> Mail.app on macOS similarly doesn't load images by default and can fetch over a proxy
07:52:42 <merijn> __monty__: Google already trivially knows which emails you read
07:52:58 <__monty__> Thunderbird blocks them by default. Mail.app doesn't for me, but I'm stuck on High Sierra.
07:53:24 <__monty__> merijn: Yeah but their data's more valuable if others *don't* have it.
07:53:34 <merijn> __monty__: THis machine is still on Sierra and Mail.app definitely blocks images and has for as long as I remember
07:54:03 <merijn> __monty__: Note that it only blocks remote hosted images, not ones embedded in the email
07:54:18 <__monty__> It has never for me. And I *definitely* did not disable such a feature on purpose because I'd love to have it.
07:54:23 <merijn> Ah, actually, there's a checkbox, not sure about the default value
07:54:34 <__monty__> TIL
07:54:44 <merijn> __monty__: Mail.app under "Viewing" has a "Load remote content" checkbox
07:55:12 <merijn> __monty__: When disabled every message with remote content gets a "load remote content" button if you deem it safe
07:55:21 <__monty__> Yep, checking that right away.
07:56:10 <__monty__> Does it do this by default with junk mail? I vaguely remember this but I might be recalling thunderbird.
07:56:29 <merijn> I think junkmail doesn't load by default, yeah
07:56:52 <sm[m]> xenon-: you want the option to change the remote image before your coworker first views the mail ? Or keep changing it and have them see the latest each time they view ? The latter is not going to work except with a weird and stupid mail client
07:57:29 <reallymemorable> I built an API from a tutorial (https://www.spock.li/tutorials/rest-api), but now I want to put it on my website.  I have never done anything like this before.  Does anyone have an idea of the next step?
07:58:56 <yushyin> just put a link in the mail :D
07:59:48 <merijn> reallymemorable: Presumably your rest API is just an executable that functions as a webserver, so you'd configure the webserver hosting your current site to proxy request for the API to your Haskell code
07:59:51 <__monty__> Yeah a "Check on the current status" in the footer seems like a simpler solution.
08:00:25 <reallymemorable> so i need to compile my code into an executable as a first step
08:00:26 <xenon-> sm[m], I want to keep changing it
08:01:20 <merijn> reallymemorable: The "main" from that code is pretty much all you need to "make an executable" :p
08:01:27 <sm[m]> A mail client is the wrong tool for that
08:01:30 <merijn> reallymemorable: How are/were you compling? cabal-install or stack?
08:01:47 <reallymemorable> stack
08:01:47 <xenon-> yushyin, that may be my only option. I'll still try testing if email clients we use cashe images
08:03:39 <reallymemorable> do i literally just put my .hs files in a folder on my site?
08:04:20 <merijn> reallymemorable: No, "stack build" should build an executable
08:08:15 <reallymemorable> ok so now I have this folder with 4 folders inside it
08:08:20 <reallymemorable> bin, doc, lib, pkgdb
08:08:35 <reallymemorable> i just take the .exe from the bin folder?
08:12:59 <sm[m]> reallymemorable: it depends on the kind of web server you have. Is it a machine you can build haskell programs on ?
08:13:37 <sm[m]> Eg a machine you control, or a virtual private server you can ssh to ?
08:13:41 <reallymemorable> I just have a domain + hosting with GoDaddy now, but I can set something else up 
08:13:50 <slack1256> Does anyone experience crashes when profling programs that use the FFI? I am profiling taffybar which uses gtk-gi. Only when running with +RTS -p -N2 --RTS I get crashes.
08:15:30 <sm[m]> To put a haskell app on the web, you need a web hosting setup that can run haskell programs and ideally build them too. Usually that means a Linux “VPS”
08:16:17 <reallymemorable> so like an ubuntu AWS instance
08:16:23 <sm[m]> Unless your setup lets you upload and run .exe files. You could ask their support
08:16:38 <merijn> reallymemorable: For example, yes
08:16:59 <reallymemorable> ok i think im going too set up that
08:17:25 <sm[m]> Yes but a Linode or digital ocean instance eg would be simpler for starting out
08:17:25 <merijn> reallymemorable: Incidentally, this isn't related to what you wanna do, but I would *strongly* advice you to migrate your domain to something other than GoDaddy as they're a notoriously terrible company (both ethically and technically)
08:17:47 <merijn> Digital Ocean is cheap and good, yeah
08:17:50 <reallymemorable> oh wow had not heard anything ethically bad about them
08:18:13 <EvanR> merijn: not that i disagee but can you elaborate on that
08:18:33 <EvanR> why are they notoriously terrible ethically and technically
08:19:39 <sm[m]> They’re a registrar, aren’t they ?? :)
08:20:01 <merijn> EvanR: If you search for domains they will preemptively buy them and upcharge you to get them, supports anti-open internet legislation, etc.
08:20:20 <merijn> EvanR: Also, incredibly poor customer service
08:20:37 <reallymemorable> yeah i am paranoid aboout that so i always first search on NetSol
08:20:44 <f-a> that search one is disgusting
08:20:51 <reallymemorable> I have actually been pleased with the customer service
08:20:57 <merijn> Just google for "godaddy bad" or "godaddy terrible" and you will find tons of articles, reviews, etc.
08:20:57 <reallymemorable> within a couple minutes i am talking to a human
08:21:05 <reallymemorable> thats weird
08:21:12 <merijn> They're not even that cheap >.>
08:21:15 <reallymemorable> their service is the sole reason i have not looked elsewhere
08:21:35 <reallymemorable> being anti-open internet is compelling though
08:23:41 <merijn> reallymemorable: If you look for reviews you will find that they get *lots* of incredibly bad reviews. Anyway, that's a choice for everyone to make for themselves, I just know many people use them because they're 1) one of the cheapest and 2) SEO'd to hell
08:25:36 <merijn> I don't really have any recommendations what to use though, as the company I use is local and I don't think they really support the worldwide market
08:26:01 <reallymemorable> i will look at digital ocean
08:26:17 <reallymemorable> anyway im setting up an ubuntu EC2
08:27:06 <merijn> I've only used Digital OCean's VPS service, but I'm happy with it. Fairly cheap, quick to setup, reliable (I used to have cheaper VPS' but those companies kept disappearing overnight and taking my servers with them >.>)
08:29:51 <reallymemorable> so i just put my exe onto this ubuntu instance and thats it?
08:30:27 <merijn> reallymemorable: You'll have to set it up to run as a daemon via systemd or whatever just like any other webserver, but yeah, pretty much
08:30:43 <reallymemorable> set up the ubuntu ec2 like that?
08:30:45 <reallymemorable> or the exe
08:31:43 <merijn> reallymemorable: The executable is just a program that happens to be a webserver, just like things as nginx/apache/etc. except instead of hosting static files it implements your REST API
08:33:25 <reallymemorable> ok
08:33:34 <reallymemorable> i dont know what setting something up as a daemon means
08:33:53 <jluttine> i've thought that pure and return should be equivalent but is it possible that they'd give different results and that'd be ok according to laws?
08:33:56 <merijn> reallymemorable: Normally you want your webserver to start running when your system boots
08:33:59 <sm[m]> Methinks there must be a how to reallymemorable could follow
08:34:14 <reallymemorable> what should i google?
08:34:19 <merijn> jluttine: Is it possible? Yes. But that means one of the two is not following the laws
08:34:21 <reallymemorable> set up my ec2 as a daemon?
08:34:33 <sm[m]> You could search for “easy deploy haskell web app”
08:34:52 <merijn> reallymemorable: Probably something like: https://medium.com/@benmorel/creating-a-linux-service-with-systemd-611b5c8b91d6
08:35:06 <sm[m]> and check digital oceans and Linodes how-tos in particular
08:35:15 <reallymemorable> awesome thanks
08:35:26 <merijn> jluttine: DO you have an example where this happens?
08:39:03 <jluttine> merijn: i was just confused by this sentence "the recommended order is to define `return` as `pure`, if the two are the same" in here: https://wiki.haskell.org/Monad
08:39:29 <jluttine> because i thought they must be the same
08:39:45 <merijn> jluttine: They mean "the recommended thing is to literally write "return = pure" when you write the Monad instance"
08:40:52 <jluttine> merijn: ok.. a bit weird way of saying that as it sounds that the two don't necessarily need to be equivalent.
08:40:58 <EvanR> right, they must be the same right?
08:41:09 <merijn> "It's Complicated (TM)"
08:41:17 <sm[m]> reallymemorable: in the results for that search, Clever Cloud might be of interest. Or Heroku.
08:41:46 <reallymemorable> Heroku instead of AWS?
08:41:51 <reallymemorable> or Heroku on AWS?
08:41:57 <reallymemorable> (this world is all new to me)
08:42:12 <merijn> You can have lawful Applicative instance that don't match lawful Monad instance, because types can have multiple Applicatives and those don't always have corresponding Monad instances. It's recommended of course to no do this and instead have Applicative and Monad matching, using a newtype for the other Applicatives
08:42:20 <merijn> If you don't other programmers will throw rocks at you
08:42:24 <merijn> Rightfully so :p
08:42:50 <EvanR> when applicative was made a superclass of monad, they didn't add some interaction law?
08:43:01 <sm[m]> https://www.clever-cloud.com/doc/haskell/haskell/
08:43:03 <MarcelineVQ> merijn: haxl's doesn't, or didn't, for the purposes of choosing parallel action or not
08:43:06 <Eduard_Munteanu> jluttine, since Monad now implies Applicative, it would be illegal or at least very confusing to have mismatched monadic/applicative structures.
08:43:24 <merijn> Incidentally, this is why ZipList isn't the default applicative for lists, as it doesn't have a Monad instance so the default was chosen to match the Monad instance
08:43:29 <sm[m]> I’m pretty sure you don’t want to tangle with AWS right now
08:43:31 <merijn> MarcelineVQ: I disagree that hose differ, tbh :p
08:43:46 <MarcelineVQ> sure they do, didn't is past tense
08:44:10 <Eduard_Munteanu> You can only have one Monad/Applicative instance, unless you have some other way to refer to them.
08:45:19 <Eduard_Munteanu> So if you pick the wrong Applicative to implement, surely you can't also implement the right one which corresponds to the Monad.
08:51:41 * hackage tmp-postgres 1.7.1.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.7.1.0 (JonathanFischoff)
09:10:00 <glguy> Do we have a data type in base like 'data T a {- empty -}' that I'm forgetting?
09:11:44 <bwe> I am reading https://wiki.haskell.org/Foldr_Foldl_Foldl%27. It recommends principal use of foldr. To date I used foldl as my default. Now I am reflecting on changing foldl into foldr, where appropriate. Should I change foldl into foldr if the order of computation is relevant (data should be evaluated from left to right)?
09:12:23 <f-a> bwe: could you use a strick foldl?
09:12:45 <f-a> i.e. foldl' 
09:13:21 <glguy> bwe: There's no "default" choice. The three functions are each unique and appropriate for different situation
09:14:07 <cocreature> bwe: as a rough guidelines, if your accumulator is constant-size (e.g. an Int) and you cannot produce parts of it lazily you probably want a foldl'. if you can produce results lazily (e.g. a list), then a foldr is probably a better choice.
09:18:32 <EvanR> bwe: foldl is usually a mistake
09:18:38 <EvanR> (no prime)
09:19:06 <dmwit> glguy: There's Const Void.
09:20:52 <dmwit> glguy: And GHC.Generics has V1, I guess?
09:20:56 <EvanR> though i have stumbled upon reverse-like tasks where foldl made sense
09:21:23 <glguy> dmwit: V1 has a slightly different kind, right?
09:21:31 <glguy> % :i GHC.Generics.V1
09:21:32 <yahb> glguy: type role GHC.Generics.V1 phantom; data GHC.Generics.V1 (p :: k); -- Defined in `GHC.Generics'; instance forall k (p :: k). Eq (GHC.Generics.V1 p) -- Defined in `GHC.Generics'; instance Functor GHC.Generics.V1 -- Defined in `GHC.Generics'; instance forall k (p :: k). Ord (GHC.Generics.V1 p) -- Defined in `GHC.Generics'; instance forall k (p :: k). Semigroup (GHC.Generics.V1 p) -- Defined in `GHC.Gene
09:21:44 <glguy> Oh, I guess it's just more generic
09:21:57 <dmwit> Looks suitably polymorphic to me.
09:21:58 <glguy> I was just thinking of types like K1 and M1 that have metadata
09:22:58 <glguy> It feels wrong to use types from GHC.Generics for things other than Rep[1] results, but that would work
09:23:00 <glguy> thanks
09:23:33 <dmwit> I agree it feels a bit weird from a "human reading the code" standpoint.
09:23:46 <dmwit> V1 says something I'm not sure I necessarily agree with about how it's intended to be used.
09:26:27 * glguy is playing with a parser combinator module like ReadP that supports breadth first parsing even when processing <|| (left-biased choice)
09:27:23 <__monty__> Oooh, will the more parallel nature benefit performance?
09:28:21 <glguy> I don't know; I'm mostly playing with it for fun
09:28:43 <glguy> I doubt that there are many uses of ReadP that have really large parsers on the left of <||
09:29:12 <glguy> but I was surprised to learn that ReadP uses backtracking to implement <|| and wanted to see if I could implement the same set of features without that
09:35:11 * hackage chronos 1.0.9 - A performant time library  https://hackage.haskell.org/package/chronos-1.0.9 (chessai)
09:41:03 <bwe> cocreature: that notion of accumulator has constant size (e.g. Int) helps. I learned: in such case, I should use foldl'. Producing results lazily (e.g. accumulator is a list), qualifies foldr. Did I get the understanding right?
09:41:38 <cocreature> bwe: yeah, it’s a rule of thumb rather than a hard guideline but it works reasonably well ime.
09:42:02 <cocreature> I guess “hard guideline” is the wrong word here but hopefully you get what I’m trying to say :)
09:42:22 <bwe> I wonder why hlint is not raising the flag for my "abuse" of foldl, since it could reason about laziness (IMHO).
09:43:10 <cocreature> hlint isn’t very clever. it’s mostly a bunch of fairly simple syntactic matching.
09:43:43 <EvanR> foldr for laziness, foldl' for eagerness, and foldl never. True to a first approximation
09:44:12 <bwe> cocreature: so, I substitute any foldl by a foldr when the accumulator may be lazily evaluated, right? but what if the order of evaluation of the Foldable matters (i.e. I want left to right evaluation)?
09:44:37 <bwe> cocreature: is    foldr ... . reverse   the right starting point here?
09:45:04 <EvanR> if you're doing a reverse for some reason, then foldl might work
09:45:23 <cocreature> I think that’s a case where trying to come up with a general strategy is more harmful than helpful. if you fall outside of the standard cases you have to analyze your specific usecase.
09:46:02 <bwe> EvanR: I am basically reducing a list of items with mappend.
09:46:35 <bwe> There, due to some business logic, order of evaluation matters: it should do so from left to right (of the list).
09:46:42 <EvanR> then use fold?
09:46:47 <EvanR> :t fold
09:46:49 <lambdabot> (Foldable t, Monoid m) => t m -> m
09:48:08 <EvanR> > fold ["a","b","c","d"]
09:48:09 <lambdabot>  "abcd"
09:48:15 <EvanR> not backwards
09:50:29 <EvanR> foldr is decidedly "left to right of the list" because lazy evaluation. But with mappend you are free to mappend to the right or left of the accum
09:51:27 <bwe> EvanR: err, you mean foldr is "right to left"?
09:51:34 <EvanR> there is no way
09:51:41 <EvanR> foldr works for infinite lists
09:51:43 <cocreature> given that monoids have to be associative you can use both a foldr and a foldl
09:51:54 <cocreature> EvanR: huh? foldr totally works on infinite lists
09:52:04 <EvanR> lol
09:52:12 <dsal> parse error
09:53:07 <bwe> from <https://wiki.haskell.org/Foldr_Foldl_Foldl%27>: foldr will be effective for transforming even infinite lists into other infinite lists.
09:53:19 <EvanR> there is no way "foldr is right to left" because foldr works on infinite lists
09:53:35 <cocreature> oh sorry missparsed your sentence :)
09:54:14 <cocreature> foldr replaces each (:) constructor by your folding function and [] by the initial value
09:54:19 <EvanR> ambiguous references and message dividors
09:54:44 <cocreature> the simplest case is foldr (:) [] which is just the identity
09:55:08 <bwe> EvanR: (\acc x -> ...) foldl; (\x acc -> ...) foldr -- is this the notion?
09:55:20 <EvanR> bwe: you may be undersanding foldr's definition without using lazy evaluation
09:55:30 <EvanR> which would be bad in haskell
09:57:00 <EvanR> yeah that argument order looks right, though i can never remember it when i need to
09:57:17 <EvanR> (why the hell is it different)
09:59:16 <cocreature> because in a foldl, acc corresponds to the (combined) elements left of x whereas in a foldr it corresponds to the elements right of x (if you write the elements in the list left to right)
09:59:45 <EvanR> ah
10:00:31 <EvanR> and here i was thinking the language designers has the omniscient wisdom to know what kind of binary functions would be more convenient in the two cases
10:00:36 <__monty__> Yes, it's super logical but also annoying when you realize you need to switch between the two : )
10:02:20 <EvanR> i think i would have chosen (\x acc -> ...) for both 
10:02:52 <cocreature> if they had the same order I could never remember it. currently I can think through it to figure out where acc needs to be :)
10:03:37 <EvanR> i can see that
10:04:41 * hackage logging-effect 1.3.8 - A mtl-style monad transformer for general purpose & compositional logging  https://hackage.haskell.org/package/logging-effect-1.3.8 (OliverCharles)
10:06:20 <heatsink> @quickcheck \s -> foldl (++) "" (words s) == foldr (++) "" (words s)
10:06:21 <lambdabot> Unknown command, try @list
10:06:23 <__monty__> cocreature: Yes but think of us poor noobs who need to try out foldr/l/l' all the time to figure out the right one.
10:06:38 <EvanR> @check
10:06:38 <lambdabot>  <unknown>.hs:1:1:Parse error: EOF
10:06:56 <heatsink> @check \s -> foldl (++) "" (words s) == foldr (++) "" (words s)
10:06:58 <lambdabot>  +++ OK, passed 100 tests.
10:07:08 <heatsink> @check \s -> foldl (++) "" (words s) == foldr (flip (++)) "" (words s)
10:07:10 <lambdabot>  *** Failed! Falsifiable (after 8 tests and 3 shrinks):
10:07:10 <lambdabot>  "\960914=\DC4 \728971"
10:07:36 <bwe> @check \s -> foldl (++) "a" (words s) == foldr (++) "a" (words s)
10:07:37 <lambdabot>  *** Failed! Falsifiable (after 2 tests and 1 shrink):
10:07:37 <lambdabot>  "!"
10:08:26 <bwe> heatsink: so, the starting accumulator ends up with a foldr at the end while with a foldl in the beginning?
10:08:36 <heatsink> foldr and foldl do the same thing for a monoid.  If they were both \x acc -> ..., they wouldn't do the same thing
10:08:43 <heatsink> right, bwe
10:09:12 <EvanR> interesting
10:11:47 <EvanR> that explains why `fold' has no l or r on it
10:11:58 <EvanR> but not i'm curious about the prime
10:12:00 <EvanR> now
10:12:57 <merijn> EvanR: foldl' you mean?
10:13:19 <monochrom> There is foldr' too
10:13:34 <EvanR> no
10:13:38 <EvanR> fold
10:13:53 <merijn> Presumably that just means strictness.
10:13:58 <EvanR> where are the "prime" (eagerness) characteristics
10:14:03 <merijn> Does that mean there's a fold' now?
10:14:15 <EvanR> :t fold'
10:14:16 <lambdabot> error:
10:14:16 <lambdabot>     • Variable not in scope: fold'
10:14:16 <lambdabot>     • Perhaps you meant one of these:
10:14:18 <EvanR> nope
10:14:32 <cocreature> GHC 8.8 added foldMap' iirc and probably also fold'?
10:14:43 <monochrom> Actually what does "i'm curious about the prime" mean?
10:14:54 <EvanR> what can you expect from fold
10:15:21 <EvanR> foldl-like nonsense, foldr-like goodness, or foldl'-like dependsness
10:15:29 <monochrom> OK, which package which module has "fold"? Or is it hypothetical?
10:15:36 <cocreature> monochrom: base
10:15:37 <EvanR> :t fold
10:15:38 <bwe> monochrom: import Data.Foldable
10:15:39 <lambdabot> (Foldable t, Monoid m) => t m -> m
10:15:41 * hackage line-drawing 0.4.0.0 - raster line drawing  https://hackage.haskell.org/package/line-drawing-0.4.0.0 (fffaaa)
10:15:42 <mniip> foldr-like
10:15:56 <mniip> but using a second-order deduction
10:15:57 <EvanR> ok
10:15:59 <mniip> rather than a first order
10:16:14 <cocreature> just checked, 8.8 only added foldMap', there is no fold' for whatever reason
10:16:23 <cocreature> but foldMap' id should give you that
10:16:42 <mniip> > fold (:[]) [0..]
10:16:44 <lambdabot>  error:
10:16:44 <lambdabot>      • Couldn't match type ‘[a0]’ with ‘[Integer] -> t’
10:16:44 <lambdabot>        Expected type: a0 -> [Integer] -> t
10:16:54 <mniip> > fold $ (:[]) <$> [0..]
10:16:56 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
10:17:24 <EvanR> this holds for most instances?
10:17:33 <Agent-008> i need some help installing hdbc-sqlite3 on windows
10:17:44 <mniip> think about how most instances implement fold
10:18:00 <EvanR> with a foldr?
10:18:02 <mniip> no
10:18:16 <mniip> by pattern matching, <>'in the relevant fields and recursing into relevant fields
10:18:22 <mniip> this gets you foldr-like behavior
10:18:45 <cocreature> tbf, [] just uses a foldr
10:19:23 <mniip> fold' would be implemented completely differently
10:23:25 <mniip> fold (Tree l x r) = fold l <> x <> fold r; fold Tip = mempty
10:23:25 <mniip> fold' = go mempty where go p (Tree l x r) = let !p' = go p l; !p'' = p' <> x in go p'' r; go p Tip = p
10:24:47 <Agent-008> Hello, can someone help me install hdbc-sqlite3 on Windows? I installed the dll and pointed to it, but I still get the error that a dependency is missing
10:25:43 <monochrom> I think it may be clearer to say "catamorphism-like behaviour".
10:26:32 <monochrom> Because "cata" and "foldr" coincide for cons lists only.
10:27:00 <EvanR> mniip's fold for Tree is a catamorphism, but that's not gonna be foldr like unless the tree is shapes carefully
10:27:10 <monochrom> Right
10:27:24 <merijn> Agent-008: Tbh, I would question the decision to want HDBC-sqlite3
10:27:41 <EvanR> with recursion on both sides of <> <> can't possibly steer toward finite-first
10:27:50 <mniip> when I say foldr-like I mean if the folding function is lazy the result can be completely lazy
10:28:12 <merijn> Agent-008: Consider that the last maintenance release of that library appears to be from *2015*
10:28:13 <EvanR> x <> fold l <> fold r has a chance
10:28:13 <Agent-008> merijn: I just want to use a database and sqlite seems to be the least painful to get started with
10:28:21 <Agent-008> is there a better option?
10:28:57 <mniip> Foldable is not suitable to talk about infinite structures tbh
10:29:03 <merijn> Agent-008: Oh, I would totally recommend sqlite, just not that package ;)
10:29:16 <merijn> Agent-008: You could try sqlite-simple
10:29:18 <mniip> it relies on the assumption that [] is the free monoid, which it is not
10:29:23 <bwe> Okay, I now swapped foldl in favour of foldr for the given case of a list. The result is now reversed.
10:29:33 <merijn> Agent-008: That one is far more actively mainained
10:29:51 <EvanR> bwe: show code
10:29:51 <Agent-008> merijn: I'll try that
10:30:59 <geekosaur> remember to flip the parameters to the folded function if you swap foldl with foldr or vice versa
10:31:10 <bwe> I still don't understand folds clearly. Need to read haskellbook on that topic again. 
10:31:24 <geekosaur> :t foldl
10:31:25 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
10:31:31 <geekosaur> :t foldr
10:31:32 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
10:31:38 <itsyaboi> I have a question, where can i find certain material to learn from. As i dont know how to approach the task ?
10:32:04 <EvanR> > foldl (++) "" ["a","b","c"]
10:32:05 <lambdabot>  "abc"
10:32:10 <EvanR> > foldr (++) "" ["a","b","c"]
10:32:12 <lambdabot>  "abc"
10:32:25 <EvanR> heh... DONT swap parameters
10:32:42 <geekosaur> depends on how they substituted, I guess
10:32:59 <bwe> EvanR: foldl (\acc x -> snd acc ++ [x]) ... ; needs to become:   foldr (\x acc -> [x] ++ (snd acc)) ...
10:33:18 <bwe> EvanR: resolved this on my own. (had pasted the code if it were not business stuff)
10:33:31 <EvanR> good
10:34:04 <EvanR> yeah your foldr is now more lazy
10:34:16 <EvanR> [x] ++ ... is streamable
10:34:54 <EvanR> but the snd doesn't make sense to me
10:35:09 <monochrom> As usual, all of you are wrong.  (b -> a -> b) and (a -> b -> b) don't always match up, so sometimes you are forced to flip your operator.  When you do that, the correct equation is: foldl op a xs = foldr (flip op) a (reverse xs)
10:35:50 <bwe> monochrom: I love your "As usual, all of you are wrong." 
10:35:56 <EvanR> this was a follow up to earlier, you don't have to flip for mappend and mempty
10:36:10 <EvanR> specifically
10:36:10 <monochrom> In EvanR's example, you are saved by associativity of (++).
10:36:35 * geekosaur is dealing with other stuff concurrently (sigh)
10:37:59 <EvanR> monoid law for mempty also contributes to your saving
10:38:13 <monochrom> Actually more. Saved by both associativity of (++) and its identity "".
10:38:19 <bwe> monochrom: I wonder whether there is some shorthand for    foldr (flip op) a (reverse xs) 
10:38:19 <monochrom> Yes, that.
10:38:48 <__monty__> bwe: Yes, `foldl`.
10:38:50 <monochrom> > (foldl (++) "x" ["a","b","c"], foldr (++) "x" ["a","b","c"])
10:38:51 <lambdabot>  ("xabc","abcx")
10:39:05 <monochrom> Yeah foldl hehe
10:39:09 <EvanR> doh... the shorthand for foldr (flip op) a (reverse xs) was just posted :)
10:39:21 <monochrom> Like, why would you even bother with reverse.
10:41:11 <merijn> Welp...I did a massive complicated refactor of over 50% of my source files, any bets on how much I broke (if anything) after fixing all the compiler errors? >.>
10:41:36 <EvanR> only a few things
10:41:56 <monochrom> Any bet on whether you will fix all the compiler errors? >:)
10:42:04 <merijn> monochrom: I already did, so
10:42:08 <monochrom> Oh oops
10:42:13 <merijn> monochrom: Only took me most of the weekend >.>
10:42:25 <monochrom> 4%
10:42:45 <bwe> monochrom: is it because foldr does not need a reverse (compared to foldl), it is lazy?
10:42:47 <EvanR> if the business logic was 100% encoded in what GHC can see, 0%
10:43:13 <monochrom> I don't understand that question but most likely the answer is still no.
10:43:29 <monochrom> And I was saying that reverse has a cost.
10:45:07 <monochrom> Usually the benefits of foldr are shadowed by the cost of reverse.
10:46:02 <EvanR> bwe: if you're building big strings, you might want to look into the builder pattern
10:50:53 <bwe> merijn: Recently I was positively impressed by the ease of integrating two distinct Haskell packages into another one (which used some core types of the target module). 
10:54:38 <sm[m]> merijn: NOTHING
10:54:52 <merijn> sm[m]: I hope so, but I doubt it >.>
11:29:52 <lavalike> monochrom: you're on a betting spree
11:33:07 <merijn> Well, at least one thing I broke so far >.>
11:33:25 <merijn> Sure great I wrote all these tests! >.>
11:39:52 <merijn> Although it does appear to be a trivial mistake, so there's that
11:49:11 <sm[m]> drat
12:03:29 <merijn> sm[m]: Not even as trivial as I thought :p
12:03:38 <merijn> Or rather, the bug was a trivial, the fix not so much... :p
12:03:44 <[itchyjunk]> hello :s i am trying to continue on my example i was working on last time. I understand that if i have 2 lists like a=[1,2] and b=[3,4] i can use zipWith(+) a b to get point wise addition
12:04:31 <[itchyjunk]> what i can't figure out is that other example you guys did with nested list, a = [[1,2],[3,4]]. how do i use zipWith here? i remember it was nested zipWith
12:05:35 <oo_miguel> I am very unconfident on what exact "build-depends" (beside just fixing all versions) to put into my cabal file. When I put ranges I should actually test ALL possible combinations of these or how is this handled in general?
12:05:41 <merijn> [itchyjunk]: zipWith wants a function with 2 arguments as argument
12:05:53 <merijn> [itchyjunk]: "zipWith (+)" happens to be a function that takes two arguments
12:06:09 <merijn> oo_miguel: https://pvp.haskell.org/
12:06:42 <merijn> oo_miguel: I generally default to using the exact version I developed against as lower bound and the upper-bound based on the PVP
12:07:02 <merijn> oo_miguel: Or, with recent cabal versions, you can use ^>= to get that behaviour by default
12:07:11 <dmwit> oo_miguel: This is where you learn to love those packages that put "Since: version x.y.z" next to every exported name.
12:07:18 <merijn> Also that
12:07:35 <merijn> You should always use @since with adding stuff :)
12:08:05 <dmwit> > zipWith (zipWith (+)) [[1,2],[3,4]] [[5,6],[7,8]] -- [itchyjunk]
12:08:07 <lambdabot>  [[6,8],[10,12]]
12:08:30 <[itchyjunk]> zipWith (zipWith (+)) make the outer happy
12:08:33 <[itchyjunk]> ahh okay
12:08:48 <[itchyjunk]> it kinda was/is making sense, let me think some mroe about this lol
12:09:03 <[itchyjunk]> not sure if it's just be but functional programming seems HARD!
12:09:21 <dmwit> oo_miguel: Anyway, "all possible combinations" is completely infeasible. But if you want to support wide version ranges, I recommend having at the very least a CI script or similar that builds with all the oldest versions your ranges allow and all the newest versions your ranges allow.
12:09:28 <dmj`> > uncurry (zipWith (+)) $ (head &&& last) [[1,2],[3,4]]
12:09:31 <lambdabot>  [4,6]
12:09:33 <dmwit> *Probably* anything that satisfies the constraints will work if those two do.
12:09:42 <oo_miguel> merijn: dmwit: ok thanks a lot! (I used stack until now, since I am quite fresh to haskell and it seemed easier for starting)
12:09:59 <merijn> oo_miguel: Hackage allows revisions which loosen the bounds
12:10:33 <oo_miguel> dmwit: yeah I agree. The "all combinations" was meant as rethoric. But I did not know about this pvp-guide
12:10:47 <merijn> oo_miguel: So I basically stick to my starting version as lower bound and anything newer I check manually as it gets released. If someone complains that an older version works but is not supported, then I can always relax the bounds later
12:11:12 <merijn> oo_miguel: Not everyone strictly follows the PVP, sadly. But it's a reasonable starting default
12:11:25 <oo_miguel> I also do not really expect ANYONE using my first packages... but still I wanted to get it clean
12:12:27 <dmwit> Confession bear: I make my version ranges hit just one version and wait until somebody complains (maybe even "somebody" is me) before I bother even thinking about relaxing the constraints.
12:12:49 <dmwit> Didn't always do it that way. But it's just so, so much less work.
12:13:17 <dmwit> (Well, just one major-minor version. Bugfix version variation is fine.)
12:13:39 <merijn> dmwit: Depends on how many dependencies you have, I suppose. Most of my packages have very few, and major bumps are rare, so I just check and relax as they happen
12:14:50 <oo_miguel> I even do not know (yet) how multiple packages interact.. If I can have different versions of a single package within one project etc (but this are coming-up questions, once I get up and running with cabal without stackage)
12:15:22 <dmwit> These days the answer is simple: all packages get a project-wide version.
12:15:29 <EvanR> .oO( i could imagine someone wanting to use ALL versions of a package in one project for some reason )
12:15:37 <dmwit> Used to be more complicated, but it turned out to be useful only very rarely and a painful problem less rarely.
12:16:04 <oo_miguel> I just imagine using package foo-1 that depends on bar-1 and package bam-1 that depends on bar-2
12:16:17 <dmwit> (Both stack and cabal agreed on this. And then stack went even further.)
12:16:24 <oo_miguel> so my final product will require bar-1 and bar-2 right?
12:16:26 <dmwit> oo_miguel: Yes, that's not possible any more.
12:16:53 <oo_miguel> Sounds bad :(
12:16:54 <merijn> dmwit: What makes you say that?
12:17:01 <yushyin> sounds good!
12:17:08 <dmwit> Well. It's possible. But you have to use cabal v1-* commands or even skip cabal entirely, and ain't nobody got time fo dat!
12:17:21 <[itchyjunk]> zipWith takes a binary function and 2 lists.. zipWith itself is a binary function?
12:17:28 <merijn> To the best of my knowledge both GHC and cabal still support using multiple different versions of a package in the same dependency true
12:17:34 <oo_miguel> sounds like dependency hell and getting into unresolvable situations likely (the more packages I require, the more probable)
12:17:35 <merijn> dmwit: Are you sure?
12:17:38 <[itchyjunk]> i am still trying to parse zipWith (zipWith (+)) list list
12:17:49 <dmwit> merijn: Yep, v2-* doesn't allow that any more.
12:17:54 <dmwit> merijn: Sandboxes, neither.
12:18:00 <dmwit> merijn: Gotta straight v1-* if you want it.
12:18:20 <oo_miguel> so I might have two perfectly fine packages will I can never use within a single library right?
12:18:22 <reallymemorable> whats the best way to install haskell on an ec2
12:18:23 <merijn> I'm skeptical, but don't care enough to check
12:18:23 <EvanR> [itchyjunk]: maybe it helps to write even more parens? ((zipWith (zipWith (+))) list) list ?
12:18:28 <oo_miguel> s/will/which
12:18:28 <reallymemorable> ubuntu ec2 that is
12:18:28 <dmwit> [itchyjunk]: `zipWith` is a 3-argument function. But `zipWith (+)` has one argument already supplied, so it's a 2-argument function.
12:18:35 <[itchyjunk]> EvanR, :<
12:18:42 <EvanR> guess not, was a long shot
12:19:23 <dmwit> oo_miguel: Yes, that's correct. It also turns out to be so rare that it doesn't matter.
12:19:45 <oo_miguel> oh ok. I will just believe you and start worrying when I run into it
12:19:47 <oo_miguel> thanks
12:20:08 <dmwit> oo_miguel: i.e. in almost all cases it is completely fixed by just relaxing the dependency constraints on one or the other of the packages in the dependency tree, because they simply haven't been updated.
12:20:57 <dmwit> (Like, it isn't that foo-1 breaks when used with bar-2, it's just that foo-1 was released before bar-2.)
12:21:00 <EvanR> [itchyjunk]: looks like that's a type error to me anyway. So understanding it will be quite hard :)
12:21:32 <dmwit> EvanR: eh?
12:21:57 <EvanR> :t zipWith (zipWith (+)) list list
12:21:58 <lambdabot> error:
12:21:58 <lambdabot>     • Variable not in scope: list :: [[c]]
12:21:58 <lambdabot>     • Perhaps you meant one of these:
12:22:04 <EvanR> hmm
12:22:10 <dmwit> :t \list -> zipWith (zipWith (+)) list list
12:22:11 <lambdabot> Num c => [[c]] -> [[c]]
12:22:15 <dmwit> No problem here.
12:22:17 <EvanR> guess i'm wrong
12:22:30 <[itchyjunk]> :O yeah it worked for me
12:22:43 <EvanR> it does seem a bit opaque though
12:22:52 <dmwit> Ignore EvanR, read dmwit's replies only. ;-)
12:23:02 <dmwit> Nah, I'm only teasing.
12:23:20 <[itchyjunk]> so, in my ghci, if i type `a=1`, it sets a to 1. but if i type `let a = 1`, it also sets a to 1. so what am i missing here? :s
12:23:23 <EvanR> zipWith f list list, this is easy
12:23:28 <EvanR> or should be
12:23:45 <[itchyjunk]> nothing is easy!
12:23:52 <EvanR> > zipWith f [x,y,z] [x,y,z] :: [Expr]
12:23:53 <lambdabot>  [f x x,f y y,f z z]
12:23:54 <dmwit> [itchyjunk]: https://stackoverflow.com/q/58035349/791604
12:23:56 <geekosaur> [itchyjunk], the "let" used to be required, but ghci hhas been changed to be a little more like ghc
12:23:57 <sm[m]> oo_miguel: your optimal bounds policy is also affected by which kind of package you're publishing (library or application ?), how technical your intended users are, which kind of problems you want them to see, whether you want to be packaged in stackage, etc. 
12:24:19 <[itchyjunk]> ah
12:24:42 <geekosaur> it used to pretend to be the inside of a "do" expression, now it pretends to be like a file's top level but still supports things like "let" for backward compatibility
12:24:53 <EvanR> (a=1 in ghci ended up causing more confusion! ha)
12:25:14 <EvanR> something could be said for tools being "really dumb"
12:25:21 <sm[m]> oo_miguel: a good way to do some basic bounds testing is have one stack.yaml file for each major ghc version you want to support, and make sure they all build cleanly before release
12:25:50 <geekosaur> except people expect repls to be "really smart" (as if)
12:26:45 <EvanR> programming tools being smarter than most programmers, reasonable goal? (loaded question)
12:28:40 <EvanR> when the tools get smarter, user must get even smarter to control it. Example, alexa being vulnerable to invisible inaudible laser-audio commands
12:29:03 <EvanR> easily dealt with by a smart person
12:29:14 <dmwit> Dunno. I've seen some pretty dumb people controlling computers.
12:29:30 <EvanR> maybe they were using windows
12:29:56 * geekosaur has been trying to help folks whose phones were smarter than they were, of late >.>
12:31:24 <ammar2> some programming tools are already smarter than a lot of programmers
12:31:31 <heatsink> The tools aren't smart enough to convince you that you really meant to do what they did for you
12:31:49 <heatsink> Eventually alexa will be able to tell you, no, you meant to do that
12:32:16 <geekosaur> alexa will have the intelligence of a cat?
12:32:27 <dolio> I don't see how the alexa example demonstrates the previous statement.
12:32:45 <EvanR> yes i see i veered into security issues not tooling
12:34:09 <heatsink> Smart tools do some amount of guessing what you meant
12:35:35 <heatsink> Between reliably doing what you wanted and justifying why it didn't do what you wanted, I think the second choice is more practical.
12:35:56 <oo_miguel> sm[m]: ok thanks. Will keep this in mind!
12:45:25 <koz_> Is there some library that allows testing whether custom type errors come up like they're supposed to?
12:50:41 <lyxia> sounds fragile but it could be a fun thing to have, koz_
12:51:42 <koz_> lyxia: I'm one of the co-maintainers of coercible-utils, and it's something we'd like to have, so I was wondering if someone had already applied the hammer to this problem.
12:51:54 <koz_> (and I finally decided to get off my ass and do my maintenance duties lol)
12:59:10 <[itchyjunk]> damn
12:59:21 <[itchyjunk]> i google one haskell program, and google thinks i am a coding instructure
12:59:58 <[itchyjunk]> its telling me to "teach coding for an hour" on csfirst.withgoogle.com
13:00:27 <EvanR> so this is what i have to look forward to when i turn google back on
13:00:29 <evelyn> You don't have to use Google if it makes you uncomfortable
13:01:06 <[itchyjunk]> who do you prefer turning on instead?
13:02:05 <EvanR> i've used google using opt-out plugins, also duck duck go
13:03:00 <EvanR> i'm not sure incognito mode does much
13:03:46 <[itchyjunk]> if you don't log in to google accounts and dont keep histories, its not the worst
13:05:35 <evelyn> People always complain about the highly targeted adverts, but seem shocked at the obvious step of using it less.
13:07:49 <hpc> duckduckgo is great
13:08:06 <hpc> if you set it as your default search engine it has !hackage and !hoogle shortcuts
13:09:51 <evelyn> or just !h for hoogle :)
13:29:13 <Phyx-> EvanR: so are you saying Windows users are dumb?
13:30:08 <monochrom> I'm a Windows user. Change my mind.
13:30:25 <evelyn> You don't get a penguin on startup
13:30:45 <EvanR> no that windows is dumb
13:31:09 <hpc> monochrom: steam has wine built in :P
13:32:59 <Cale> Does anyone know if there exists a sequence of decision problems P_k for which there is an unbounded increasing sequence a_k, such that any algorithmic solution to P_k must take at least O(n^(a_k)) time? The closest thing I've seen is that there are some optimisation problems for which obtaining a solution within 1+epsilon of the optimal one can be done in O(n^(1/epsilon)) time -- but that's just saying that a solution exists of that 
13:32:59 <Cale> complexity, not that it must have it.
13:35:13 <monochrom> hpc: I actually tried that for Recursed. It didn't launch. Either nothing happened or the Recursed process just sat there idle, I forgot which.  I didn't have the steam (pun!) to troubleshoot it, or in my favourite wording, babysit it.
13:36:55 <monochrom> I wanted to show Recursed to my students in my principles of programming languages course because it is like procedure calls and even continuations sometimes.
13:38:03 <Cale> Recursed has a native linux executable...
13:41:08 <ddellacosta> so, I want to call forkIO on a complicated function that repeatedly hits a web page then stores the results in a TVar. I ended up with something with MonadIO and MonadHttp constraints, but now I don't know how to call forkIO on it. Do I really need https://hackage.haskell.org/package/unliftio or am I thinking about this the wrong way?
13:41:44 <ddellacosta> sorry if I'm being vague, can give an example if that's not clear
13:41:58 <Cale> You probably need to pick a monad satisfying those constraints, and then use whatever run functions are required to turn the resulting action into an IO action
13:43:35 <Cale> Specifically, you probably want to use runHttpT with a Manager that you've initialised beforehand
13:44:05 <Cale> (assuming that my assumption about what library you're using is correct)
13:44:34 <ddellacosta> Cale: okay. I am using Req fwiw, and I structured everything using MonadHttp (vs. Req explicitly) which is maybe part of the problem
13:45:26 <jackdk> no, I don't think so.
13:46:37 <jackdk> all of the req functions use MonadHttp in their type sig, and then you have `runReq :: MonadIO m => HttpConfig -> Req a -> m a`
13:47:40 <mpiechotka> @free traverse
13:47:42 <lambdabot> Extra stuff at end of line in retrieved type "(Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)"
13:48:15 <ddellacosta> jackdk: my point is that I have a bunch of functions already calling http endpoints and the are all in m with the constraint MonadHttp m
13:48:18 <Cale> ddellacosta: That's probably fine, it's just that it's similar to if you'd written a sorting algorithm and its type was (Ord a) => [a] -> [a] -- if you actually want to use it, you need to pick some type of list to sort. It's the same kind of situation here -- you have an algorithm abstracted over a choice of MonadHttp, and you need to pick a specific monad, with the goal being that it's one which you can turn into an IO action 
13:48:18 <Cale> (shouldn't be hard), because you want to use forkIO
13:48:23 <mpiechotka> @free traverse :: (a -> f b) -> t a -> f (t b)
13:48:23 <lambdabot> Plugin `free' failed with: src/Lambdabot/Plugin/Haskell/Free/Type.hs:(153,17)-(161,45): Non-exhaustive patterns in case
13:48:41 <ddellacosta> jackdk: but maybe I'm missing your point
13:48:47 <jackdk> Req is also MonadIO, so if you have some `thingo :: (MonadIO m, MonadHttp m) => m Thing`, then `runReq someConfig thingo :: MonadIO m => m Thing` and `m` could be `IO`
13:49:11 <mpiechotka> @free traverse :: (a -> F b) -> T a -> F (T b)
13:49:11 <lambdabot> $map_F g . h = k . f => $map_F ($map_T g) . traverse h = traverse k . $map_T f
13:49:16 <jackdk> so you could potentially do `forkIO (runReq someConfig thingo)` and it would go off in some other thread
13:50:16 <mpiechotka> @free sequence :: T (F a) -> F (T a)
13:50:16 <lambdabot> $map_F ($map_T f) . sequence = sequence . $map_T ($map_F f)
13:50:48 <ddellacosta> jackdk: yeah, it just requires me to rewrite a bunch of my functions that already hit endpoints so I can use someConfig vs. the getHttpConfig instance I already wrote...etc. Just annoying, but probably suggests I did it wrong anyways
13:51:01 <Cale> ddellacosta: What?
13:51:01 <mpiechotka> @free (sequence . return . return) :: a -> F (T a)
13:51:01 <lambdabot> Try `free <ident>` or `free <ident> :: <type>`
13:51:03 <jackdk> tell me more about your gethttpconfig instance?
13:51:16 <mpiechotka> @free r :: a -> F (T a)
13:51:16 <lambdabot> $map_F ($map_T f) . r = r . f
13:51:21 <Cale> ddellacosta: I'm not sure I understand why you'd have to rewrite anything.
13:51:53 <ddellacosta> I think I'm not being clear. Let me upload a sample and try it again, haha. 
13:51:56 <Cale> ddellacosta: If you already have a polymorphic thing, it's fine to just use it at a specific type
13:53:35 <mpiechotka> @free r :: a -> (a -> F b) -> F (T b)
13:53:35 <lambdabot> $map_F g . h = k . f => $map_F ($map_T g) (r x h) = r (f x) k
13:59:10 <ddellacosta> Cale, jackdk this is completely fake Haskell, but hopefully it makes it more obvious the bind I've got myself in, and how I can apply the advice you've both given me, if I can: https://gist.github.com/ddellacosta/3731e743f4aaa75bd9c62f7e1133276c
14:04:33 <jackdk> ddellacosta: `forkIO $ runReq someHttpConfig (complicatedThing someUrl)`, where you'll have to make up the config and url from somewhere?
14:07:32 <ddellacosta> jackdk: that requires me to change complicatedThing quite significantly compared to what I have in the gist though, right? Or am I missing something still?
14:09:14 <jackdk> sorry, skimmed. I'm assuming you can get the url and options before trying to fork. you can create the TBQueue beforehand using `newTBQueueIO`
14:09:38 <jackdk> then `forkIO $ runReq someHttpConfig (complicatedThing someUrl someOptions someQueue`
14:09:45 <jackdk> `)`
14:13:47 <ddellacosta> jackdk: okay. That works but I don't entirely understand why, I think I'm getting confused as to how I'm getting a Req a for that second argument to runReq. Will bang my head on this until I get it--thanks for the help
14:15:37 <jackdk> ddellacosta: runReq wants a Req as you correctly noticed. When you supply all arguments to complicatedThing, you are left with `(MonadIO m, MonadHttp m) => m ()`.
14:16:03 <jackdk> GHC then goes "is Req an instance of both MonadIO and MonadHttp?" The answer is "yes", so it can proceed
14:16:07 <ddellacosta> jackdk: yeah exactly; I'm feeling dense but I don't see how those unify
14:16:22 <ddellacosta> jackdk: okay, so I think I was thinking about that backwards. Thank you!
14:17:01 <jackdk> NP.
14:19:10 <koz_> jackdk: Hard, or complete? :P
14:20:13 <ChaiTRex> has a period at the end, so it's complete
14:20:19 <Lycurgus> yeah it's case sensitive
14:20:47 <ddellacosta> I love #haskell 
14:21:01 <jackdk> NP = "no problem", therefore NP < P
14:21:14 <ddellacosta> haha solves
14:21:17 <ddellacosta> *solved
14:22:01 <EvanR> i presume NP-easy has been solved for a while? Never hear about that one
14:23:05 <Lycurgus> https://en.wikipedia.org/wiki/NP-easy disambigs with NP-ea
14:23:23 <Lycurgus> (in chrome)
14:23:41 <koz_> ddellacosta: Yep, agreed.
14:24:10 <EvanR> lol it's real
14:24:28 <koz_> EvanR: Not imaginary?
14:25:04 <ddellacosta> I saw some crazy cool visualization once that had all the complexity classes layered on top of each other based on where they fit, there were so many more than I thought
14:25:21 <Lycurgus> and it's not really easy, maybe need an npeasey
14:25:35 <koz_> ddellacosta: Are you referring to the diagram from Complexity Zoo?
14:26:27 <Lycurgus> just guaranteed to have a specific big O form
14:26:39 <ddellacosta> koz_: maybe? Got a link?
14:26:52 <Lycurgus> easy is like triggering the woke
14:27:07 <ddellacosta> it was kind of like a 3d layer cake with weird piles on top of other ones
14:28:00 <ddellacosta> oh, this is _not_ it, but this is amazing: https://www.math.ucdavis.edu/~greg/zoology/diagram.pdf
14:29:48 <koz_> ddellacosta: That was the one I meant.
14:38:33 <d34df00d> Suppose I need to replace every unique alphanumeric sequence in a string (or Data.Text, or ByteString) with an unique identifier (that might be generated as I encounter more unique sequences). Do I have better options than just manually fold over the string?
14:39:10 <koz_> :t fromIntegral
14:39:11 <lambdabot> (Integral a, Num b) => a -> b
14:41:36 <c_wraith> d34df00d: how do you determine the boundaries of "sequences"?
14:42:20 <d34df00d> c_wraith: [a-zA-Z0-9]+ basically.
14:43:41 <d34df00d> To avoid X-Y problem: I'm trying to calculate Levenshtein distance of two program sources under the assumption that identifiers are not edited. So looks like "interning" these identifiers allows me to express this as well as reduce the running time of the Levenshtein distance calculation algorithm.
14:46:12 <evelyn> What do you mean by replace? Do you just substitute a given group of alphanumeric characters with a single identifier (presumably a character)?
14:46:17 <d34df00d> evelyn: yep!
14:46:40 <wildtrees[m]> Maybe generate a hash of identifier keys and the values would be unique ids then substitute them in
14:47:44 <d34df00d> I have the rough idea about generating the identifiers (just store the already encountered ones in a map mapping strings onto ints or chars, and replace an identifier with the result of the lookup, or with a newly generated char one `succ`er than the biggest one in the map).
14:47:51 <d34df00d> But I don't know about the best way to traverse the text.
14:48:16 <d34df00d> I'm sort of really lazy to write an explicit fold over a Text (or a Seq Char, which might be the best structure here).
14:48:24 <EvanR> a parser that outputs bytestring builder
14:48:24 <evelyn> I think you could use something like [atto|mega]parsec instead of a horrifying mess of regexen
14:50:16 <EvanR> a lexer really, which *parsec can do
14:50:43 <d34df00d> Cool, a chance to try out megaparsec then.
14:52:20 <dmwit> d34df00d: I wonder if walking over a suffix trie would get you where you need to go.
14:53:03 <dmwit> This idea is only half-baked. Let's pretend I didn't say it. If I manage to fully bake it I'll mention you again.
14:53:48 <evelyn> There is also regex-applicative and earley. I quite like the former.
14:54:32 <EvanR> it's really a tokenization problem, if you had a stream of tokens you could trivially map them to builders using the substitution table
14:57:16 <d34df00d> Uh, so how do I tokenize?
14:58:41 * hackage keycloak-hs 1.0.1 -   https://hackage.haskell.org/package/keycloak-hs-1.0.1 (CorentinDupont)
14:59:28 <EvanR> regex-applicative seems to be based on list rather than ByteString... but could work. (ByteString breaks into a [Word8])
14:59:48 <totbwf> Most of the parsecs are polymorphic over the stream type
14:59:51 <ddellacosta> d34df00d: if you haven
15:00:02 <ddellacosta> haven't yet, take a look at e.g. https://markkarpov.com/megaparsec/megaparsec.html for tips on how to get going
15:00:15 <EvanR> but attoparsec could give you output bytestring fragments so you don't need to reform ByteStrings from Word8
15:00:41 <EvanR> also there's alex
15:06:43 <boogiewoogie> hey, is anyone else having trouble building the 'hmatrix-morpheus' package?
15:07:15 <whiskerzz> hi guys, I'm having a lot of trouble doing heap profiling with my program to try and find a memory leak. I'm following the procedure in the user guide, and visualizing the heap use with hp2ps, but it's only showing two "bands" in it, one of them being "PINNED". Does anyone know why it could be only showing two of them despite there being lots of other CAFs?
15:08:28 <TheCommieDuck> I hope this isn't too offtopic, but: is it normal to get sucked into far more whirlpools of "well I can refactor *this* and that allows me to do *that*" than other languages because you've always got type signatures to lead the refactor?
15:14:07 <EvanR> you mean, are you less afraid to touch anything in haskell when it's working
15:14:38 <EvanR> for the sake of say gold plating :)
15:15:37 <TheCommieDuck> Yes, probably :P
15:16:00 <TheCommieDuck> (though it did take me 3 hours to add a single parameter 'a' to a type after crying my way through monads)
15:16:24 <TheCommieDuck> I've got almost identical functionality to my julia code in 40% of the LoC
15:17:19 <hpc> TheCommieDuck: a lot of things about haskell make "cemented" code much less scary to change
15:17:33 <EvanR> when it's haskelly code, not much raw IO, it feels really easy to mess with
15:17:54 <EvanR> if you wrote C in haskell, then ... no
15:18:41 <hpc> i would say even if you use lots of IO
15:18:42 <EvanR> this is why people want FRP so bad
15:19:07 <EvanR> gtk code written in C form probably won't be such a dream to refactor
15:19:13 <TheCommieDuck> yeah, it took me an age to coax the IO ( ... ) out of my code
15:19:55 <EvanR> async-based IO code seems a lot easier to mess with too
15:20:04 <EvanR> but i may be delusional
15:21:37 <hpc> no, parconc stuff in haskell really is a lot easier
15:22:11 <hpc> because of the IO thing, there's a very narrow set of things you have to worry about when changing that sort of code
15:22:46 <EvanR> parconc?
15:22:49 <hpc> weird hidden effects can't happen wherever they like
15:22:52 <hpc> parallel/concurrent code
15:23:28 <hpc> even when i am using straight forkIO, it seems easier than async in say, javascript
15:23:46 <EvanR> then i don't get the 'no' part :)
15:24:31 <hpc> oh, no as in you're not delusional
15:26:11 * hackage egison 3.9.2 - Programming language with non-linear pattern-matching against non-free data  https://hackage.haskell.org/package/egison-3.9.2 (SatoshiEgi)
15:36:12 * hackage egison 3.9.3 - Programming language with non-linear pattern-matching against non-free data  https://hackage.haskell.org/package/egison-3.9.3 (SatoshiEgi)
15:51:14 <fresheyeball> you know I have gotten so used to the idea, that when I run into real trouble, I can turn to the IRC. That being without it is really jarring.
15:51:28 <fresheyeball> doing some work in opencv today, and it's all popular and mainstream and stuff
15:51:37 <fresheyeball> and as a result, there is tons of tutorials and docs
15:51:45 <fresheyeball> but... no one being helpful on IRC
15:52:07 <fresheyeball> FP land got me accustomed to talking to real humans, because often docs just don't exist, or don't answer the question at hand
15:52:13 <fresheyeball> you guys spoiled me
15:55:32 <heatsink> Haskell is the programming language with the best customer service
15:55:42 <fresheyeball> I agree
15:55:52 <fresheyeball> we might not have our tooling figured out
15:55:54 <fresheyeball> but we got the people
15:58:06 <jackdk> We do need to sort out our documentation, but I hope the community remains strong when that happens
15:59:00 <EvanR> am i going insane, or is it normal to wonder about the behavior of a function Double -> Whatever as the float argument increments to the "next float"
15:59:29 <EvanR> and then create a harness to check that
15:59:51 <EvanR> i've honestly never heard of anyone caring about "next float"
16:02:23 <fresheyeball> EvanR: what is a "next float"?
16:02:28 <EvanR> exactly
16:02:28 <jackdk> I've heard stories about people checking something for all floats using sbv: https://leventerkok.github.io/sbv/
16:02:41 <[itchyjunk]> hi, why is b !! 2 not [5,3,3,3] ? is it because when you append [6,6,6]:b, you never really change b ? https://imgur.com/a/cA66fAG
16:03:03 <EvanR> literally checking all doubles is impossible, but you could begin somewhere and go left and right a ways as an experiment
16:03:06 <[itchyjunk]> so if a = [6,6,6]:b then a !! 2 would be [5,3,3,3] ?
16:03:30 <jackdk> [itchyjunk]: there is no mutation. `b` is bound once in the `let`, and never changes.
16:03:57 <EvanR> fresheyeball: increment the mantissa, if you go too far increment the exponent fix the mantissa
16:04:10 <[itchyjunk]> what would happen if i did b = [,6,6]:b then ? :s
16:05:00 <hpc> you'd have an infinite list of [6,6,6]
16:05:27 <jackdk> Ignoring the syntax error in the list syntax, it would create a new definition for `b` that would shadow the old one, and the `b` in the body would refer to the new `b` being defined. Still not mutating, and depending on your warning settings, you'll probably get a variable shadow warning
16:08:58 <monochrom> No, it would create a cyclic list.
16:09:17 <hpc> when you define something like "let b = [6,6,6]:b", you're saying that b consists of a cons cell with head of [6,6,6] and a tail of itself
16:09:40 <EvanR> itself being the cons cell not the [6,6,6]
16:09:54 <hpc> yeah
16:10:01 <monochrom> Self-reference takes priority over shadowing.
16:10:44 <jackdk> Is that not what I said? https://www.irccloud.com/pastebin/ahe19u7A/SelfReference.hs
16:10:47 <hpc> on some level you're asking the computer for the smallest solution to that equation, but that's a problem for future [itchyjunk] ;)
16:11:28 <monochrom> OK, I misread, you said that.
16:11:38 <jackdk> no worries
16:12:13 <[itchyjunk]> lol :D
16:15:05 <sm[m]> whiskerzz: we ignore your insensitive "real-world", "practical" question
16:15:34 <[itchyjunk]> i agree that it creates endless thingy
16:15:45 <[itchyjunk]> it gave me no error
16:15:48 <[itchyjunk]> heh heh
16:16:08 <sm[m]> if you're stuck, maybe share a link to the manual and what you're seeing
16:22:05 <ysangkok> whiskerzz: or you could post it on stackoverflow with a bounty
16:30:48 <[itchyjunk]> :O you can post stuff on stackoverflow with a boundy?
16:31:28 <jle`> not a cash bounty, but a reputation bounty i believe
16:31:46 <jle`> and that's only if there is a week or something that passes with no good answers
16:31:55 <shachaf> It's a bounty on the head of people who don't answer your question.
16:32:30 <whiskerzz> sm[m], haha thanks! I wasn't sure whether my posts could be seen in this channel hahah
16:33:31 <whiskerzz> in my .cabal file for my project, I have: ghc-options:         -rtsopts -prof -auto-all -caf-all
16:33:52 <whiskerzz> and I build/run with: cabal run --enable-profiling my-exec -- +RTS -p -hc
16:34:22 <whiskerzz> and then I use hp2ps on the produced .hp file, which creates this plot: https://imgur.com/prtjJpI
16:35:32 <whiskerzz> I've googled the "pinned" thing, but quickly got lost in the weeds... I noticed that it may have to do with the fact that I'm using hmatrix, which use c libraries...I think?
16:36:11 <whiskerzz> My main question is, why is the heap profiler only showing those two...
16:40:52 <sm[m]> whiskerzz: and where's that doc you're following. I'm no expert but maybe there are some alternate RTS or hp2ps modes you can try ?
16:42:18 <whiskerzz> sm[m], mostly this: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html
16:42:51 <sm[m]> and, I'd check your GHC version, because these profiling flags are a nightmare and I think have changed a bit
16:43:00 <whiskerzz> but they don't have as much specific directions on using cabal 3, so I found some more recent stuff on blogs
16:43:05 <sm[m]> I see -fprof-auto instead of -auto-all at https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flags.html#profiling-options
16:43:11 <[itchyjunk]> What does lexigographical order mean?
16:43:21 <whiskerzz> you're totally right, I found that one already haha
16:43:28 <jle`> [itchyjunk]: some people describe it as dictionary order
16:43:35 <ChaiTRex> [itchyjunk]: Something like alphabetical order.
16:43:46 <jle`> > sort ["hello", "help", "happy"]
16:43:48 <lambdabot>  ["happy","hello","help"]
16:43:57 <[itchyjunk]> hmmm
16:44:17 <[itchyjunk]> i am trying to figure out why [3,2,1] > [2,10,100] is true
16:44:19 <jle`> 'sort' sorts strings in lexicographical order
16:44:26 <monochrom> Simply becasue 3>2.
16:44:34 <jle`> > "cba" > "bzz"
16:44:36 <lambdabot>  True
16:44:40 <ChaiTRex> [itchyjunk]: The first item is checked. Only if equal are the remaining items checked.
16:44:44 <monochrom> Also "z" > "monochrom"
16:44:51 <[itchyjunk]> ahh..
16:44:55 <whiskerzz> sm[m], I have ghc 8.0.2
16:45:04 <[itchyjunk]> okay, makes sense
16:45:34 <sm[m]> whiskerzz: ok, let's get the 8.0.2 manual out
16:45:44 <whiskerzz> sm[m], the confusing part is that in the actual .prof file, as well as the .hp file if I open it in a text editor,  show lots of the CAFs I'm interested in
16:45:55 <whiskerzz> it seems like they're somehow getting grouped together under one or something
16:46:02 <whiskerzz> or maybe only showing the largest ones?
16:47:06 <sm[m]> https://downloads.haskell.org/~ghc/8.0-latest/docs/html/users_guide/profiling.html#profiling-memory-usage
16:48:29 <sm[m]> whiskerzz: what does +RTS -p do ?
16:48:58 <whiskerzz> That only produces the .prof file, it works fine as far as I can tell
16:49:12 <whiskerzz> tells which CAFs use memory/time, but not a time dependent version
16:50:27 <jackdk> Axman6: what's your horrific lens party trick with plated?
16:50:44 <Axman6> I should save it somewhere...
16:51:29 <Axman6> something like partsOf template %~ (reverse :: [Char] -> [Char])
16:52:35 <sm[m]> whiskerzz: FWIW the recipe I used last was stack build --profile EXE; stack exec -- EXE +RTS -hc -RTS; hp2ps EXE.hp (no -p when running EXE)
16:53:09 <jackdk> > ["hello", "help", "happy"] & partsOf template %~ (sort :: String -> String)
16:53:11 <lambdabot>  ["aeehh","hlll","opppy"]
16:53:17 <Axman6> <3
16:53:46 <sm[m]> well, until someone knowledgeable shows up, I'd try the different -hX modes and see if that gives any clues.. and maybe try #ghc
16:54:33 <sm[m]> whiskerzz: oh that's a good sign. Maybe a hp2ps option then
16:55:02 <sm[m]> wait... are you sure the .prof file is used here ? I think only the .hp file is
16:56:07 <sm[m]> I would also try -hc explicitly, not just -h
16:56:10 <dmwit> Axman6: useful
16:57:46 <dmwit> > liftA2 splitPlaces (length<$>) (sort.concat) ["hello", "help", "happy"]
16:57:48 <lambdabot>  ["aeehh","hlll","opppy"]
16:58:05 <whiskerzz> Yeah, hp2ps only uses the .hp file
16:58:11 <Axman6> % (Left "Hello" :: Either String Int, "world") & partsOf template %~ (sort @Char)
16:58:11 <yahb> Axman6: (Left "Hdell","loorw")
16:58:16 <whiskerzz> Most people just also do the -p option to produce the .prof at the same time
16:58:49 <sm[m]> I see -l and -m flags at https://downloads.haskell.org/~ghc/8.0-latest/docs/html/users_guide/profiling.html#hp2ps-rendering-heap-profiles-to-postscript 
16:58:53 <Axman6> :t partsOf template
16:58:55 <lambdabot> (Functor f, Data t, Typeable a) => LensLike f t t [a] [a]
16:59:01 <whiskerzz> sm[m], I've tried -h and -hc, I think they're equivalent... I've also tried -hd, but based on what I can see, they're basically just different labeling schemes
16:59:18 <whiskerzz> For example, -hd makes the "PINNED" in my heap profile instead say "ARR_WORDS"
16:59:28 <Axman6> a.k.a: give me a traversals over all a's in a structure, as a list
16:59:34 <Axman6> % (Left "Hello" :: Either String Int, "world") & partsOf template %~ (sort @String)
16:59:34 <yahb> Axman6: (Left "Hello","world")
16:59:56 <Axman6> % (Left "Hello" :: Either String Int, "world") & partsOf template %~ (sort :: [String] -> [String])
16:59:56 <yahb> Axman6: (Left "Hello","world")
16:59:58 <shachaf> > over (partsOf (each.traverse)) reverse ("hello", "help", "hi")
17:00:00 <lambdabot>  ("ihple","holl","eh")
17:01:34 <Axman6> eah on tuples feels so strange
17:01:36 <Axman6> each*
17:01:57 <shachaf> You certainly shouldn't be doing any of this nonsense.
17:02:06 <shachaf> It's all ridiculous.
17:03:04 <Axman6> thouh potentially useful - toListOf (partsOf template) lets you do things like extract all URLs from an arbitrary structure
17:03:28 <shachaf> toListOf of partsOf is silly.
17:03:35 <Axman6> uh yes
17:03:40 <Axman6> good point
17:04:17 <Axman6> :t view (partsOf (template @_ @Bool))
17:04:19 <lambdabot> error: parse error on input ‘@’
17:04:19 <jackdk> some of the stuff I was able to write with this silliness and lenses over markdown... man, I would have dreaded writing it in any other language
17:04:23 <Axman6> %:t view (partsOf (template @_ @Bool))
17:04:30 <Axman6> % :t view (partsOf (template @_ @Bool))
17:04:30 <yahb> Axman6: (MonadReader s m, Data s) => m [Bool]
17:04:37 <jackdk> Axman6: @_@
17:04:37 <shachaf> That's not the silly part!
17:04:42 <shachaf> Just use toListOf directly.
17:05:08 <shachaf> > toListOf template (1,2,3) :: [Integer]
17:05:10 <lambdabot>  [1,2,3]
17:05:18 <whiskerzz> sm[m], I tried those just now, they don't change anything. I don't think the problem was too many bands, since only 2 were displayed
17:05:28 <Axman6> I guess that also works, I hadn't thought about doing that
17:05:37 <shachaf> But that's how partsOf is implemented.
17:05:56 <shachaf> It gets a list of values with toListOf -- that's the reasonable part -- and then (as a lens) lets you modify that list.
17:05:58 <Axman6> TIL
17:06:19 <shachaf> If you don't need to modify you should just use listOf.
17:07:52 <jle`> > ["hi","hello"] & partsOf template .~ "abcdefg"
17:07:54 <lambdabot>  ["ab","cdefg"]
17:09:24 <Axman6> > ["hi","hello"] & partsOf template .~ "ABCD"
17:09:27 <lambdabot>  ["AB","CDllo"]
17:15:20 <sm[m]> whiskerzz: I'd try the same procedure on some other project not using hmatrix, just for reference 
17:15:45 * sm[m] found https://www.reddit.com/r/haskellquestions/comments/dui0y4/having_a_nightmare_trying_to_profile_my_haskell
17:16:58 <sm[m]> you seem to be making the right incantations
17:17:55 <whiskerzz> sm[m], a confession...that's me!
17:18:20 <whiskerzz> I made that post, and am trying his idea, but I don't quite understand what I should be looking for in the GC stats
17:19:23 <sm[m]> I know it's you. I was searching for what PINNED was and this helped. :)
17:19:30 * sm[m] asks #ghc
17:20:07 <whiskerzz> ahhh haha, sorry :)
17:20:45 <Axman6> PINNED is usually ByteString IIRC, but HMatrix is probably also using pinned memory
17:22:57 <whiskerzz> From what I've read from googling, it does
17:23:40 <monochrom> GC can move your live data, except pinned blocks. A reason to pin a block is to let C access it and always find it at the same place.
17:23:45 <Axman6> it'd make sense, means it can be shared with C safely
17:24:11 <monochrom> The down side is that unmovable blocks increases fragmentation.
17:24:18 <whiskerzz> Hmmmm
17:25:01 <sm[m]> whiskerzz: what about http://hackage.haskell.org/package/hp2pretty
17:25:15 <whiskerzz> Hm, I saw that, I guess I could try it
17:25:44 <whiskerzz> but it seems to me like the thing to figure out is whether the problem is on the heap profiling part, or the display part
17:25:51 <monochrom> Still, if you have a severe memory growth, it may not be merely fragmentation.
17:25:54 <whiskerzz> hp2ps or hp2pretty is really the latter
17:26:31 <sm[m]> yes, but it may help you find out
17:26:38 <whiskerzz> I'm very new to haskell so I might be doing something very dumb btw
17:26:51 <whiskerzz> I'm aware of lazy evaluation, just not always spotting it when I'm doing it
17:26:56 <whiskerzz> sm[m], okay I'll try it!
17:26:57 <sm[m]> eg if it just works, your .hp  is good and the issue is with hp2ps
17:27:16 <whiskerzz> Yeah
17:27:29 <sm[m]> whiskerzz: in that case you are doing rather well. The UX for this stuff is improving slowly but still rather painful
17:30:59 <sm[m]> to the extent that I think a very small percentage of haskellers have made a heap profile
17:31:16 <whiskerzz> thanks. Yeah, it seems like there are some good resources for basics/concepts, but as soon as you get into the weeds with cabal/profiling/etc, it's...not easy, at least for me
17:31:35 <whiskerzz> so I tried hp2pretty, at least with the first attempt, no diff
17:31:40 <whiskerzz> nicer look though haha
17:32:10 <whiskerzz> there's actually a third band in the legend, "trace elements"
17:33:40 <sm[m]> maybe the other CAFs are just vanishingly small. Trying a different project might confirm this
17:34:19 <sm[m]> or messing with your code, in THEORY
17:34:37 <whiskerzz> Yeah... hmmmm.
17:34:54 <whiskerzz> So what does it mean that the hmatrix memory stuff is pinned, exactly?
17:35:08 <whiskerzz> like, I'm definitely doing operations on the matrices
17:35:18 <whiskerzz> that's mostly what the program is tbh
17:35:19 <sm[m]> it's data that (for efficiency reasons) GHC is not allowed to move 
17:35:27 <whiskerzz> Hmmmm
17:35:46 <whiskerzz> so what does it do if I do `mat_b = 3*mat_a` ?
17:36:15 <whiskerzz> like, does it not GC mat_a ?
17:36:44 <sm[m]> if you compare your time&space profile (.prof, which can be simplified with profiterole), maybe it can help tell whether the heap profile is accurate
17:36:55 <whiskerzz> oh, MY
17:37:05 <whiskerzz> I was looking at the args for hp2pretty
17:37:07 <whiskerzz> AND
17:37:25 <whiskerzz> one of them is --trace, the percent of trace elements to combine, which is by default 100%
17:37:38 <whiskerzz> changing it to 0.0, I see a bunch of my CAF's
17:38:27 <sm[m]> victory!? \o/
17:38:27 <whiskerzz> so I believe it was what you were suggesting, that the others might just be negligibly small
17:38:33 <whiskerzz> well... heh
17:40:06 <whiskerzz> I still haven't found the source of it
17:40:38 <sm[m]> the source of... ?
17:41:04 <whiskerzz> Oh, the increasing memory usage
17:41:14 <whiskerzz> it's why I'm using all this in the first place, I suspect there's a memory leak
17:42:34 <sm[m]> whiskerzz: that profile doesn't seem to show a leak, it is nicely flat 
17:43:17 <sm[m]> but maybe it's using more than you expected ? (120M doesn't sound like all that much)
17:44:46 <whiskerzz> sm[m], the leak isn't that large in the short term, but I want to run it for a while, and eventually it eats up all my 8GB of RAM
17:44:59 <whiskerzz> so I might see it if I let it run longer, which I'll try now
17:45:02 <whiskerzz> but for future reference
17:45:07 <whiskerzz> hp2ps has a similar option
17:45:09 <whiskerzz> -t
17:45:18 <whiskerzz> so doing -t0.0 also shows a bunch of bands
17:45:40 <whiskerzz> just not visible with respect to the larger ones
17:47:11 * hackage egison-tutorial 3.9.3 - A tutorial program for the Egison programming language  https://hackage.haskell.org/package/egison-tutorial-3.9.3 (SatoshiEgi)
17:47:21 <sm[m]> whiskerzz: is it actually eating up all your ram, or is htop just saying that it is. I believe the RTS can appear to consume it all but it can still be allocated by others
17:49:15 <whiskerzz> sm[m], well..htop says it is, but it sure seems to coincide with everything getting all slow and the program crashing itself :P
17:49:31 <sm[m]> that could be a sign, indeed :)
17:51:47 <sm[m]> if you get more interesting profiles/insights, I'd be interested to see. It's helpful for learning this stuff
17:54:09 <whiskerzz> Yeah
17:54:22 <whiskerzz> I think my next step is figuring out a way to remove those bigger ones from the plot
17:54:26 <whiskerzz> or maybe just run for longer
18:08:33 <whiskerzz> sm[m], welppp, ran it for 10x longer, pretty clearly, PINNED is growing linearly
18:09:01 <Axman6> :'(
18:21:27 <whiskerzz> hm, so when I use -hd instead of -hc, it calls that "pinned" part ARR_WORDS instead
18:22:05 <whiskerzz> https://stackoverflow.com/questions/7241470/what-is-arr-words-in-a-ghc-heap-profile
18:22:22 <whiskerzz> would hmatrix be using bytestrings or any of those things?
18:23:15 <Axman6> the memory that stores the data in HMatrix is almost certainly that same type
18:23:25 <Axman6> whiskerzz: have you shared the code anywhere?
18:32:57 <whiskerzz> Axman6, no, it's honestly just very large and embarrassing to show :'(
18:32:59 <whiskerzz> BUT
18:33:03 <whiskerzz> mother of god I FIGURED IT OUT
18:33:12 <shapr> yay!
18:40:37 <sm[m]> OMG
18:41:01 <sm[m]> this is unheard of
18:44:04 <Axman6> whiskerzz: what was it?
18:49:34 <sm[m]> I'm going with a loop maintaining a non-strict hmatrix array as state
18:50:02 <whiskerzz> Sorry, back
18:50:28 <whiskerzz> sm[m], yeeaahhhh, it's basically that. Embarrassingly, I actually already solved the problem a while ago...
18:50:35 <whiskerzz> it's exactly that
18:50:55 <whiskerzz> I foldM over an hmatrix, over many iterations
18:51:22 <whiskerzz> and there's an inner loop to it and outer loop. On the outer loop, I actually use `force` every iteration, so it prevents this from happening, it actually evaluates it
18:51:39 <whiskerzz> but for testing purposes, I was only doing one iteration of the outer loop and a bunch with the inner...
18:51:45 * sm[m] uplevels in haskell performance fu! woot!
18:52:03 <whiskerzz> so I just need to either force on the inner loop too, or make those inner loops smaller
18:52:45 <EvanR> bang patterns or strict containers might also do it
18:53:10 <EvanR> force is a bit heavy handed-sounding
18:53:49 <whiskerzz> EvanR, I was previously using bang patterns, I forget why I switched, someone's advice...
18:53:54 <whiskerzz> what exactly is a strict container?
18:54:40 <Axman6> ata Foo = Foo !Int !Text - if the Foo is forces, so are the Int and Text 
18:54:44 <Axman6> data*
18:54:49 <Axman6> d*
18:55:27 <whiskerzz> Hmmm
18:55:46 <whiskerzz> So I'm using `newtype` for a bunch of my structures. Would that work with them?
18:55:53 <shapr> How do I find the DOI for a PhD thesis? I want to re-read the GRIN thesis: https://github.com/grin-compiler/grin
18:56:13 <Axman6> it's unnecessary for newtypes
18:57:59 <Axman6> newetype Foo = Foo Bar says that Foo and Bar have exactly the same representation in memory at runtime, but they are considered different types at compile time
18:58:01 <heatsink> I don't think phd theses have dois.  They're published by the university where the thesis was written.
18:58:53 <shapr> heatsink: that's gonna be exciting, I don't know how to put in a unique ID for that
18:59:09 <whiskerzz> Axman6, I was actually trying to understand that... I'm using them because I want to be able to easily pass around a structure that has a few sub structures
18:59:21 <EvanR> whiskerzz: what Axman6 said. Like strict pair is like pair but with two strict fields. Data.Map.Strict is like Data.Map.Lazy but payload is evaluated when inserted
18:59:35 <EvanR> evaluated to WHNF
19:00:14 <whiskerzz> and I frequently find myself doing something like `Batch mat_x = x` to get at `mat_x`
19:00:26 <whiskerzz> EvanR, hmm... this is kind of at the very edge of my knowledge of this
19:00:32 <whiskerzz> I'll read more though
19:04:47 <EvanR> whiskerzz: basically, get used to the idea that by default nothing in haskell is ever evaluated :)
19:04:59 <EvanR> until absolutely necessary
19:05:29 <Axman6> so you may have to make it necessary sooner than the program thinks it is
19:05:43 <maerwald> and mind that the semantics of "necessary" might greatly diverge from your own perception
19:06:22 <EvanR> casually necessary vs absolutely necessary heh
19:06:31 <Axman6> 1 and seq = "I want it noooowww"
19:06:34 <Axman6> !*
19:06:37 <jusss> what is `!Int' ?
19:06:41 * hackage regex-wrapper 0.1.0.0 - Types that can only be constructed if they match a regular expression  https://hackage.haskell.org/package/regex-wrapper-0.1.0.0 (lukec)
19:06:53 <EvanR> a strict field
19:08:17 <jusss> data Persion = Person { personeName :: !String } 
19:08:28 <EvanR> !String is probably wrong
19:08:40 <jusss> https://www.yesodweb.com/book/persistent
19:08:49 <EvanR> !Text makes more sense. Remember String is a list
19:09:01 <jusss> data Person = Person    { personName :: !String    , personAge :: !Int    }  deriving Show
19:09:11 <EvanR> that seems goofy to me
19:09:51 <jusss> EvanR: what is `a strict field'? it means it only can be or not can be?
19:10:07 <EvanR> it accomplishes the reduction of personName to either [] or (:) but doesn't even establish the first letter
19:11:14 <jusss> is there an example?
19:11:47 <Axman6> it means that  if the constructor is evaluated, that field will also be evaluated to WHNF - a.k.a it will evaluated enough to know which constructor the field is, so in the case of String it will evaluate <stringThunk> into <charThunk> : <stringThunk> or []
19:14:18 <Axman6> if you have data Foo = Foo !Int !String, a function which pattern matches on Foo like this data (Foo i s) = ... is basically the dame as writing f foo = case foo of Foo i s -> i `seq` s `seq` ...
19:16:46 <jusss> Axman6: s is the first character of that !String?
19:17:10 <EvanR> no and !String isn't a type
19:17:26 <jusss> EvanR: !String is a value?
19:17:30 <EvanR> no
19:17:52 <jusss> EvanR: what it's called?
19:18:10 <EvanR> !a and ~a in a data type are strictness annotations for fields... it's all in the manual!
19:24:26 <LCRERGO> \quit
19:25:04 <iqubic> So I have a map, coming Data.Map. I want to get a list of all the Keys Value pairs where the keys were constructed with a certain data constructor Foo. Is this possible?
19:25:37 <shachaf> It is computable.
19:26:01 <Axman6> lens would be a good way to do that
19:26:26 <Axman6> using an indexed traversal and a prism
19:26:43 <Axman6> :t itoListOf
19:26:45 <lambdabot> IndexedGetting i (Endo [(i, a)]) s a -> s -> [(i, a)]
19:27:35 <iqubic> So if I have a Map of type "M.Map Maybe a" I want to have a function that will give an output of type [(Maybe, a)] where all the Maybes match Nothing. I'd also like that same function to give me a view of the list where all the Maybes returned were made from the Just constructor.
19:27:57 <Axman6> you're missing something in those types
19:28:05 <iqubic> But actually, the more I think about it, the more I realize that this is overkill.
19:29:14 <iqubic> Axman6: What am I missing in the types?
19:29:24 <EvanR> do you really want lists (yet?)
19:29:36 <Axman6> Map Maybe a doesn't make sense
19:29:54 <iqubic> I know.
19:30:02 <iqubic> That was just an example.
19:30:26 <iqubic> But it should really be "M.Map (Maybe b) a"
19:30:26 <Axman6> like it's not valid, I don't understand what you want
19:30:43 <iqubic> Well, I'm not being very clear.
19:30:49 <Axman6> there will only be at most one entry in the map with key Nothing
19:30:50 <iqubic> Just forget I ever asked this.
19:30:58 <iqubic> Right. I know.
19:31:07 <iqubic> I see what I need to do here.
19:31:22 <iqubic> Sorry I bothered you guys with my ill formed question.
19:32:24 <EvanR> i for one enjoyed this bizarre use of Data.Map
19:32:29 <iqubic> Is there a good way to modify the on particular Key in a map, while leaving it's value alone?
19:32:43 <iqubic> s/the on/one/
19:34:12 <EvanR> maybe you need two Maps, Map k a and the reverse index Map a [k], and keep them in sync
19:34:22 <EvanR> then some of these questions might make sense
19:35:09 <iqubic> Yeah. I suppose that would be good.
19:41:48 <dmwit> :t M.partitionWithKey
19:41:50 <lambdabot> (k -> a -> Bool) -> M.Map k a -> (M.Map k a, M.Map k a)
19:42:04 <dmwit> But even better would be if you can reuse the ordering information for whatever type you're actually thinking about.
19:42:24 <dmwit> :t M.split
19:42:26 <lambdabot> Ord k => k -> M.Map k a -> (M.Map k a, M.Map k a)
19:42:50 <dmwit> But split is terrible. I tend to always want a different semantics.
19:43:54 <dmwit> :t \k m -> case M.splitLookup k m of (l, v, r) -> (foldr (M.insert k) l v, r)
19:43:56 <lambdabot> Ord k => k -> M.Map k a -> (M.Map k a, M.Map k a)
19:44:15 <dmwit> ^ same type, better behavior
19:44:38 <dmwit> (But the library could do it more efficiently, so I do wish it was in the library somewhere.)
19:49:06 <iqubic> dmwit: Yes. The key that I want to modify is constructed from a constructor that is LT all the others.
19:49:59 <iqubic> Basically I wrote out a list of all my constructors, then did: "deriving (... Ord)"
19:50:28 <iqubic> So the constructor I'm interested in finding is the first one in that list.
20:22:52 <iqubic> How do modules work in haskell?
20:23:06 <Axman6> that's an incredibly broad question
20:23:14 <EvanR> it's a miracle
20:23:22 <iqubic> This project I'm working on has gotten to the point where I want to seperate out the code into multiple directories.
20:23:37 <iqubic> I having a hard time getting the import statements correct.
20:24:09 <EvanR> most packages use multiple directories you can look at their source code for examples
20:24:21 <Axman6> well if you give us some details about what you've tried and what result you weant we might be able to help
20:24:52 <Axman6> want*
20:30:41 * hackage net-mqtt 0.6.2.0 - An MQTT Protocol Implementation.  https://hackage.haskell.org/package/net-mqtt-0.6.2.0 (dustin)
20:31:24 <iqubic> So, I have this directory structure. http://dpaste.com/2GV005Q I want to import OccurrenceMap.hs from the Rules.hs file Adding "import Rewrite.OccurrenceMap" to the top of Rules.hs gives this error message: http://dpaste.com/3RHH0ZC. The first line of Rules.hs enables all warnings, and that's the one GHC takes issue with.
20:32:35 <dsal> iqubic: did you declare your module as Rewrite.OccurrenceMap ?
20:42:27 <iqubic> No.
20:42:57 <iqubic> I declared my module as OccurrenceMap.
20:43:02 <iqubic> Is that the issue?
20:44:22 <iqubic> My import statement now reads: "import OccurrenceMap" And the import keyword is underlined with this error message: http://dpaste.com/3THDTY3
20:46:20 <iqubic> So I have very little clue what I need to do?
20:49:28 <EvanR> have you looked at the source of some package to see how they do it
20:51:03 <dmwit> iqubic: module Foo.Bar.Baz must reside in Foo/Bar/Baz.hs. Going the other way, Foo/Bar/Baz.hs must be module Foo.Bar.Baz.
20:51:09 <iqubic> I see.
20:51:16 <iqubic> This is not something I knew.
20:52:07 <iqubic> That fixes my issue.
21:24:11 * hackage net-mqtt-rpc 0.1.0.0 - Make RPC calls via an MQTT broker.  https://hackage.haskell.org/package/net-mqtt-rpc-0.1.0.0 (dustin)
21:25:12 <nshepperd> what should I call a package that implements a type checker plugin for x
21:25:27 <dsal> xmonad
21:25:32 <nshepperd> lol
21:25:47 <nshepperd> considering ghc-tcplugin-x, ghc-x-solver
21:26:56 <dsal> solve-for-x
21:27:14 <dsal> Wait.  x isn't a real name is it?
21:27:28 <dsal> ghc-x-solver seems nice.
21:28:21 <nshepperd> i should have said "foo" :p
21:29:16 <nshepperd> there's an embarrassment of different naming schemes on mpickering's list https://mpickering.github.io/plugins.html
21:29:32 <dsal> Yeah, I was reading it that way at first.  But ghc-x-solver sounded pretty retro-future.
21:29:47 <dsal> I'm incredibly bad at naming.
21:30:40 <nshepperd> the x-solver sounds like a robot assassin from the future
21:31:26 <dsal> Terminator: Predicate
21:36:16 <dmj`> haddocks really needs a way to resize images
21:38:19 <iqubic> I didn't know you could have images in a haddock.
21:43:04 <ptrcmd> what's the recommended way to install profiling libraries w/ cabal?
21:46:39 <jusss> sorry, I still have confused about bang pattern, is !Int a type? 
21:47:08 <Axman6> no
21:47:11 * hackage tmp-postgres 1.8.0.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.8.0.0 (JonathanFischoff)
21:47:22 <Axman6> it's an annotation on a field in a data constructor
21:48:35 <Axman6> data Foo = Foo {fooInt :: !Int, fooChar :: Char } -- contains a strict Int and a lazy Char, so Foo undefined 'a' `seq` () will throw an exception, but Foo 1 undefined `seq` () won't
21:48:47 <jusss> Axman6: data P = P Int, here this Int is not a type?
21:48:53 <Axman6> yes it is
21:49:06 <Axman6> but !Int isn't a type, it's an annotation on the type Int
21:49:13 <EvanR> jusss: so !Int -> !Char is not valid anything
21:49:44 <EvanR> but data Foo = Foo !(Int -> Char) is a valid data type, though the ! here is a bit silly
21:51:51 <iqubic> Why would you want a strict function?
21:52:16 <EvanR> it's not making a strict function
21:52:38 <EvanR> fine, i admit it, this notation is totally fake making you think it's modifying the type
21:52:44 <jusss> if we don't put ! before the type, it's lazy about evaluation, we put it before the type, it will eval like the call-by-value eval stratege ?
21:52:53 <EvanR> but it has nothing to do with the type, it's about the field
21:53:27 <EvanR> it should have been data Foo = Foo { !field1 :: Int, !field2 :: Char } or something
21:54:29 <dmj`> can I embed a movie in haddocks ? Like an .mp4 or .mov
21:54:37 <dmj`> or is a gif the closest thing ?
21:55:10 <jusss> EvanR: ok
21:59:29 <dsal> I don't really need a movie, but I can proscribe a really great soundtrack to read my docs to.
21:59:40 <dsal> Er, perscribe
21:59:50 <dsal> Maybe both.  Can I have noise cancelation directives in documentation?
21:59:51 <EvanR> hmm... VR haddocks
22:00:02 <dsal> I can't spell anymore.   I'm going to stop typing tonight.
22:05:48 <jle`> dmj`: hm, i don't think so, but you can generate your own haddocks and change the html before you upload it maybe
22:05:50 <jle`> he he he
22:08:38 <EvanR> oh man
22:09:07 <EvanR> scrolling marques and embedded shockwaves for everyone
22:11:41 * hackage mad-props 0.1.0.0 - Monadic DSL for building constraint solvers using basic propagators.  https://hackage.haskell.org/package/mad-props-0.1.0.0 (ChrisPenner)
22:14:14 <iqubic`> Hello.
22:15:36 <Axman6> ChrisPenner[m]: <3
22:16:15 <ChrisPenner[m]> Axman6: haha 😄
22:16:37 <Axman6> great name
22:17:16 <ChrisPenner[m]> A library is only as good as its  pun
22:17:48 <Axman6> I've been meaning to write a library which combines Grenade and Accelerate for ages, and call it RPG
22:17:55 <ion> heh
22:20:13 <dmj`> jle`: oh man, that's way too much work  for me
22:20:22 <dmj`> jle`: I'll try a gif
22:21:43 <ChrisPenner[m]> Axman6: love it
22:22:06 <dmj`> jle`: I got visualizations working with arrayfire, it's pretty dope
22:22:51 <dmj`> jle`: https://github.com/arrayfire/arrayfire-haskell/issues/13#issuecomment-552293982
22:26:31 <dmj`> enter the monad
22:28:10 <EvanR> exit the comonad
22:30:01 <haskellearner> Hi, there. I defined a new type that takes type parameters as following -- data Car2 a b c = Car2 {company2 :: a, model2 :: b, year2 :: c} deriving (Show) -- Now i am trying to use this type as following but it is not working -- data Car2 a b c = Car2 {company2 :: a, model2 :: b, year2 :: c} deriving (Show) -- Any ideas what I am doing wrong?
22:30:48 <haskellearner> Hi, there. I defined a new type that takes type parameters as following -- data Car2 a b c = Car2 {company2 :: a, model2 :: b, year2 :: c} deriving (Show) -- Now i am trying to use this type as following but it is not working -- Car2 String String Integ  {company2 = "Toyota", model2 = "280i", year2 = 1900} -- Any ideas what I am doing wrong?
22:31:00 <haskellearner> sorry for the bad copy paste, i fixed it in the 2nd paste. 
22:31:31 <Axman6> you only need Car2 {company2 = "Toyota", model2 = "280i", year2 = 1900}
22:31:34 <EvanR> Car2 {company2="Toyota",model2="280i",year2=1900}
22:31:46 <Axman6> or Car2  {company2 = "Toyota", model2 = "280i", year2 = 1900} :: Car2 String String Integer
22:33:06 <Axman6> you don't provide type parameters to constructors
22:40:11 * hackage regex-wrapper 0.1.0.1 - Types that can only be constructed if they match a regular expression  https://hackage.haskell.org/package/regex-wrapper-0.1.0.1 (lukec)
23:01:49 <dminuoso> Axman6: It's quite amusing that in principle their intuition was good.
23:06:41 <jle`> maybe they came from dhall
23:07:26 <haskellearner> Thanks a lot to everyone that answered my question. I was getting some food!
23:07:27 <dminuoso> Does Dhall feature polymorphism with explicit type applications?
23:09:28 <jle`> dminuoso: dhall requires explicit type applications
23:09:40 <jle`> so you would literally call it Car2 String String Integer
23:09:46 <jle`> (the value constructor)
23:10:28 <jle`> Car2 String String Integer { company2 = "Toyoda", model2 = "280i", year2 = 1900 }
23:11:19 <jle`> that's almost legal dhall except you'd have to write +1900 since dhall doesn't have polymorphic numeric literals
23:24:21 <mpiechotka> @free f :: (a -> F b) -> a -> F (T b)
23:24:21 <lambdabot> $map_F h . k = p . g => $map_F ($map_T h) . f k = f p . g
23:38:53 <EvanR> what the heck is @free ?
23:39:27 <lyxia> free theorems
23:40:02 <EvanR> cool
23:40:02 <Axman6> @free fmap
23:40:04 <lambdabot> Extra stuff at end of line in retrieved type "Functor f => (a -> b) -> f a -> f b"
23:43:22 <jle`> @free f :: a -> b -> a
23:43:23 <lambdabot> g . f x = f (g x) . h
23:43:44 <jle`> i mean....i guess that's true
23:43:59 <jle`> @free f :: a -> a
23:44:00 <lambdabot> g . f = f . g
23:46:55 <f-a> I am having troubles with TH and "not in scope". I feel I wrote myself into a corner, can somebody please confirm? https://pastebin.com/hVMeVW1T
23:50:12 * hackage yesod-bin 1.6.0.4 - The yesod helper executable.  https://hackage.haskell.org/package/yesod-bin-1.6.0.4 (MichaelSnoyman)
