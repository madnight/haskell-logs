00:00:36 <edwardk> if you're using the unboxed lenses then zipping is free, then you can foldMap in one pass without actually making any intermediaries
00:00:37 <koz_> edwardk: I guess I start with Dual EQ?
00:00:59 <koz_> (like, the starting element of the fold)
00:01:26 <edwardk> and in general you should be able to avoid intermediaries because zipWith i think streams at high eenough -O levels? i'd have to check
00:01:39 <koz_> edwardk: It will.
00:01:58 <koz_> Unboxed Vectors represent Vector (a, b) as a pair of Vectors anyway.
00:02:10 <koz_> So I think it's just 'magic up two pointers'.
00:02:14 <edwardk> yeah, that was my point
00:02:25 <edwardk> the other was in case they were boxed vectors
00:02:31 <koz_> Mine are unboxed.
00:02:37 <edwardk> so easy peasy
00:02:56 <koz_> As a random aside - how much coffee do you consume daily, edwardk?
00:03:03 <edwardk> usually 0
00:03:08 <edwardk> lots and lots of diet coke
00:03:09 <koz_> edwardk: Woah.
00:03:15 <koz_> Lol.
00:03:22 <koz_> I guess we have different caffeine fixes.
00:04:08 <edwardk> i'm a bit of a wreck this week though, came back from india, and the particulate matter in the air, incense, dust, smoking folks, etc. led to me getting the usual sinus infection i get from that sort of thing, which is now settled into my chest, leaving me a hacking coughing mess for days
00:04:26 <edwardk> so i'm hoping to relax for a few days and get back to 100%
00:04:43 <koz_> edwardk: As someone who came off a chest infection recently, I hear you.
00:04:56 <koz_> Waking in the morning with chest pains is absolutely no joke.
00:06:10 <edwardk> meanwhile i'm writing some goof-off code for probabilistic programming, and trying to work up the energy to get back to cadenza
00:07:16 <iqubic> What is cadenze?
00:07:30 <iqubic> *cadenza
00:07:53 <edwardk> it is my playing around with whether or not i can get graal + truffle to evaluate functional code in a scary fast manner on the jvm
00:08:11 <edwardk> basically write an interpreter in a funny way and get a fast jit
00:08:38 <maerwald> https://www.reddit.com/r/haskell/comments/e0r3lv/applying_typelevel_and_generic_programming_in/ -- lol, first I thought someone leaked Andres' 350 pages book... but then I realised it's hosted on his own domain
00:08:39 <koz_> edwardk: Interesting.
00:09:19 <iqubic> maerwald: So the book is free now?
00:09:29 <maerwald> I'm not sure, but the link is public now
00:09:52 <iqubic> I see.
00:09:53 <EvanR> every time you click the link you owe him 79.95
00:10:17 <EvanR> better service your mouse first
00:10:35 <edwardk> EvanR: ah the sort of reasoning that led to https://www.youtube.com/watch?v=Gq70QKa7588
00:11:13 <maerwald> iqubic: he definitely links to the book on his homepage
00:11:28 <EvanR> hah
00:11:43 <maerwald> gotta download it quickly before he changes his mind ;D
00:12:07 <iqubic> I actually will.
00:12:48 <iqubic> I'm not sure if this is strictly legal, but it's online and public. So I guess I now "own" the book.
00:16:52 <iqubic> I cannot think of a single good use for a prepromorphism.
00:17:03 <iqubic> And believe me, I've been trying.
00:21:11 <maerwald> kosmikus: ^
00:21:52 <iqubic> maerwald: is that in response to my message, or your own?
00:22:10 <maerwald> Just asking if he's ok with people downloading the book
00:22:36 <iqubic> Ah. I see.
00:22:54 <iqubic> I'll delete my local copy if he isn't fine with it.
00:26:02 <joebobjoe> hello?
00:34:11 <edwardk> iqubic: there is a reason why i don't advocate for much past ana/cata/hylo
00:34:24 <edwardk> histo has some uses, futu can be forced to be useful, but then, meh
00:34:52 <edwardk> iqubic: maarten fokkinga wrote a paper that had some prepromorphism uses
00:35:58 <edwardk> not sure how to find it on the internets in this day and age
00:36:54 <kosmikus> maerwald: the "book" is just my PhD thesis. I'm certainly ok with people downloading it. It's not necessarily very relevant in this day and age though. (unless you're interested in history or doing research in generic programming yourself, perhaps.) I've commented on the reddit thread.
00:37:56 <maerwald> thanks!
00:38:40 <koz_> kosmikus: Thanks!
00:43:52 <jle`> when phd theses get published it's common for new phds to hide a $20 bill in their book or something when they put it in the library
00:44:10 <koz_> jle`: I should go searching.
00:44:15 <jle`> the joke is that nobody will read it anyway
00:44:25 <koz_> LOL
00:44:28 <jle`> i wonder if i should do the same with my digital copy, like hide a bitcoin in it or something
00:44:42 <jle`> a QR code for a bitcoin wallet
00:44:43 <koz_> jle`: I'll read it just to prove you wrong.
00:48:54 <jle`> but ... my bitcoin ;_;
00:50:58 <koz_> jle`: LOL
00:51:15 <EvanR> if it's supposed to be $20... maybe 1/2000 bitcoin
01:24:39 * hackage finitary-derive 2.1.0.0 - Flexible and easy deriving of type classes for finitarytypes.  https://hackage.haskell.org/package/finitary-derive-2.1.0.0 (koz_ross)
01:46:08 <pavelz> oh NSLockignore -channels #haskell * JOINS PARTS QUITS NICKS
01:46:24 <pavelz> whoops
02:31:17 <xenon-> I want to write a function that should, when called, read the file only if it was modified, otherwise it should return cashed content. does this seem like a proper signature? FilePath -> IO (IO Text)
02:32:12 <Rembane> xenon-: Assume that the function name of this function is f, then you can do this: join . f and get the signature FilePath -> IO Text 
02:33:21 <EvanR> though IO (IO Text) can be more useful as is, depending on the original effects
02:33:34 <EvanR> but i think xenon- is asking if that's even the right direction
02:33:40 <xenon-> what I'm asking is, do I need nested IO?
02:34:13 <Rembane> I was trying to say that you don't need it, but I got derailed I think. 
02:34:58 <EvanR> i don't think you need it for that either
02:36:45 <xenon-> how would I keep track of the old timestamp and data content without nested IO? with nested IO, I'd create two references, and then capture them in inner IO
02:38:06 <Rembane> xenon-: Do you have an example of your function? 
02:38:22 <xenon-> give me a moment to clean it up
02:38:48 <EvanR> ah so you're going to hide an IO ref inside the closure of the other IO action
02:38:57 <EvanR> sneaky
02:39:38 <EvanR> or you could pass the timestamp in as an argument
02:39:54 <EvanR> Time -> FilePath -> IO Text, partial apply
02:40:27 <EvanR> hmm guess that wouldn't work since it couldnt' be incremented
02:41:06 <Rembane> IMO: Avoid IORefs
02:41:17 <Rembane> They will bite you in interesting ways
02:46:08 <EvanR> i heard you like IORefs so
02:46:16 <xenon-> =)
02:46:19 <EvanR> IORef (IORef (IORef ...))
02:47:59 <Rembane> ^^
02:48:02 <Rembane> > fix error
02:48:04 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
02:55:16 <xenon-> here: https://pastebin.com/gQ54B9Mh
02:55:37 <xenon-> I'm not sure how I'd avoid IORef completely?
02:57:05 <xenon-> I am curious if I could do the same thing, but without nested IO. makeFileReader :: FilePath -> IO String
02:57:31 <EvanR> you can also pass in the IORef
02:58:25 <xenon-> FilePath -> IORef -> IO (String, IORef)?
02:58:37 <EvanR> wut
02:58:43 <xenon-> heh
02:58:52 <EvanR> IORef Time -> FilePath -> IO Text
03:00:03 <xenon-> right
03:00:15 <xenon-> what interface would you prefer?
03:00:57 <EvanR> i use nested IO for a goofy time checker
03:01:07 <EvanR> 'time since last executed'
03:01:11 <xenon-> I'd also need to pass timestamp IORef
03:01:21 <EvanR> but it only works if you make sure only 1 thread uses it at a time
03:01:55 <xenon-> yeah
03:02:48 <xenon-> Rembane, can you think of a way to do this without IORefs?
03:05:22 <xenon-> I'm going full blown imperative here. well I guess there's a bit of functional programming there too, closing over IORefs
03:05:39 <EvanR> you're trying to make a cache
03:05:55 <xenon-> yes
03:05:58 <EvanR> it'd review what you're doing and check that whatever plan you have will even work
03:06:10 <EvanR> checking modified times? really
03:06:27 <xenon-> I am loading a large file, and I want to avoid loading it if it has not changed
03:06:55 <EvanR> and you definitely want to load it if it DID change
03:06:56 <xenon-> and I wanted to abstract all the book keeping away from my main code
03:07:28 <EvanR> so save a hash of the file nearby in the file system instead of checking times
03:07:33 <aveltras> does anyone have an example somewhere of the way to get the value of an html element attribute with ghcjs-dom ?
03:07:34 <EvanR> or use a file watcher
03:07:49 <EvanR> get notified when the file is write-closed
03:08:37 <xenon-> and then what? write to IORef? will the notification code be called in a different thread?
03:09:09 <EvanR> a thread waiting on a watch makes sense
03:09:56 <EvanR> it can push whatever in response, or save it to a var if you are pulling
03:11:21 <EvanR> i've use fsnotify package
03:11:56 <xenon-> I'd need to depend a file watching library, which may just use polling anyway. and then I need to worry about thread safe. I think I'll do it like this for now
03:12:03 <EvanR> though the Events therein look a bit odd to me
03:12:04 <xenon-> safety*
03:12:14 <EvanR> file watching doesn't use polling
03:13:24 <EvanR> to do it your way it would still make more sense to compare hashes instead of time
03:13:40 <xenon-> I'd need to load a big file to do that, which is what I want to avoid
03:14:56 <xenon-> I'm doing this on web page request, and the delay is noticeable and annoying
03:15:05 <EvanR> the writer would also write the hash out
03:15:16 <EvanR> web pages :(
03:15:26 <EvanR> have 9 different mechanisms to do caching
03:20:26 <xenon-> actual file is 30 MB json. it takes nearly a second to load it and parse it. I could read the file and store hash, which would be significantly faster, but still slower than checking timestamp, and not sure what I'd gain 
03:21:02 <EvanR> i have cooked up caching schemes that didnt work reliably
03:21:28 <EvanR> serving old versions 
03:22:29 <EvanR> the hash file idea also wouldn't work unless you went out of your way to update the two files atomically, with a directory mv
03:22:53 <EvanR> so yeah loading that file doesn't sound like the problem
03:22:54 <xenon-> when file changes so does the modification time. am I missing something? in what case could I be serving old file
03:23:08 <EvanR> it's the json decoding, which youre probably immediately reversing to send?
03:23:45 <EvanR> yeah, if your modification time were a real number, and all accesses to the file took time greater than zero, it would work
03:24:50 <EvanR> if you were just serving a file, then disk is already caching
03:25:04 <EvanR> and the memory/filesystem/io system
03:25:07 <xenon-> so if the two changes were happening in shorter time than timestamp's resolution, I could get the old version?
03:25:22 <EvanR> i wouldn't be surprised if that were possible
03:25:38 <xenon-> json parsing takes far more time than reading the file. In my actual code I'm cashing parsed data, not just plain text
03:25:43 <EvanR> your cache is version 1 and version 2 is sitting there on disk with the same time
03:26:03 <EvanR> yeah i see where your slowdown is
03:27:07 <EvanR> 30MB of data in some file that is being updated kind of smells like needing a database
03:27:24 <xenon-> yeah, it should have been a proper database. but I'm not controlling that file, just reading it
03:27:59 <EvanR> checking timestamps should work, most of the time :)
03:28:04 <xenon-> =)
03:29:12 <xenon-> in practice, I doubt two subsequent writes to 30 MB json "database" could be done faster than timestamp's resolution. maybe if it was an actual database :)
03:30:12 <maerwald> hinotify works really well
03:30:34 <EvanR> i think in another case i made a separate POST handler and posted the updated file to it
03:30:55 <EvanR> with a separate job or program that was watching the file
03:31:08 <EvanR> all kinds of lamebrained schemes
03:31:42 <xenon-> Evan already suggested notification package, I think I'll keep things like this for now
03:43:44 <xenon-> I still have a feeling there should be a way to do this without nested IO, without changing the signature (other than flattening IO (IO a) to IO a)
03:43:56 <EvanR> flattening doesn't make sense
03:44:37 <EvanR> IO (IO Aeson.Value) makes sense, it's an IO action that returns a puller for the value
03:45:06 <EvanR> it has to do some setup to build the puller, that's what the type kind of indicates
03:45:14 <EvanR> flattening it wouldn't work and would not indicate anything
03:45:57 <xenon-> I think you're right
03:54:38 * hackage publish 2.1.0 - Publishing tools for papers, books, and presentations  https://hackage.haskell.org/package/publish-2.1.0 (AndrewCowie)
04:16:26 <constantine_91> how to pass command line args with "cabal run" ?
04:17:26 <beka> anyone know  why i might be getting the cabal error `LICENSE: openBinaryFile: does not exist (No such file or directory)` on the `indents` package?
04:22:15 <fendor> constantine_91, separate the list with `--`, e.g. `cabal run exes -- --help`
04:58:38 * hackage bulmex 4.0.0 - Reflex infused with bulma (css)  https://hackage.haskell.org/package/bulmex-4.0.0 (Jappie)
05:31:39 * hackage altsvc 0.1.0.0 - HTTP Alternative Services  https://hackage.haskell.org/package/altsvc-0.1.0.0 (OlivierCheron)
05:52:38 * hackage cabal-install-parsers 0.1 - Utilities to work with cabal-install files  https://hackage.haskell.org/package/cabal-install-parsers-0.1 (phadej)
06:09:23 <xenon-> wtf.. my website is two times faster in ghci than when compiled. 1.2 vs 2.5 seconds. I am using -O2
06:13:49 <[exa]> xenon-: sounds fishy right?
06:14:05 <[exa]> xenon-: any specific framework?
06:14:47 <xenon-> scotty, but I can't tell yet if it is scotty related, or if it is my own code that is running slower compiled
06:16:50 <xenon-> I'll try to make a test case, it might take me a while though
06:41:38 * hackage constraint-tuples 0.1.2 - Partially applicable constraint tuples  https://hackage.haskell.org/package/constraint-tuples-0.1.2 (ryanglscott)
06:45:13 <nil> so i've written a very simple virtual machine emulator for a programming challenge, both in C and in Haskell, and the Haskell version runs about 300 times slower than the C version. any ideas how i might optimise it? https://gist.github.com/niiiil/95064d85627986d1557235e5f569ed48
06:45:47 <nil> i've included a profiling report in the gist. i couldn't really get anything helpful from it, though
06:53:13 <maerwald> nil: turn everything strict :o
06:56:58 <nil> i am already using unboxed arrays
06:58:03 <maerwald> where is the file you test it with?
06:58:13 <smelc> hey guys, I'm a new haskeller; I'm using vscode and I'm wondering how to have documentation in hovers in vscode, using haskell-ide-engine
06:58:43 <fendor> smelc, how did you install hie?
06:58:44 <smelc> I've done `stack haddock --keep-going` in my stack-managed project, as advertised by https://github.com/haskell/haskell-ide-engine, but the documentation doesn't show up nevertheless
06:59:15 <fendor> did you try `hoogle generate`?
07:00:36 <nil> maerwald: i've uploaded it https://up.monade.li/7pZgMy.bin
07:00:47 <nil> this is the Synacor challenge, by the way
07:00:50 <smelc> humm I don't remember, I believe I followed https://github.com/haskell/haskell-ide-engine#installation-from-source
07:01:16 <fendor> smelc, you can try to generate a local hoogle db
07:01:18 <smelc> no I didn't do hoogle generate
07:01:30 <fendor> do you have hoogle installed?
07:02:03 <maerwald> nil: that looks like a game, how do I run the performance test?
07:02:13 <smelc> globally no, but stack hoogle generate is running
07:02:49 <nil> maerwald: i was measuring the time it takes to get to the first "read input" instruction using  time ./vm challenge.bin < /dev/null
07:02:57 <maerwald> ah
07:03:01 <fendor> smelc, should be fine, iirc. You can look if there are any files in ~/.hoogle. 
07:03:08 <nil> more than 6 seconds, whereas the C program takes 20ms
07:03:47 <maerwald> mine takes 0.264s
07:03:56 <nil> o_o
07:04:30 <nil> i've added the C version to the gist so you can compare
07:05:14 <maerwald> with StrictData it is 0.213
07:05:48 <nil> oh, so that's what you meant by "turn everything strict" :')
07:05:54 <nil> let me try that
07:05:54 <maerwald> how do you compile?
07:06:41 <maerwald> you must be running without optmisation then it takes 5s here
07:07:20 <nil> yeah, just  ghc -dynamic -o vm vm.hs  (i'm on arch linux)
07:07:27 <maerwald> add -O2
07:07:51 <nil> oh.
07:07:55 <nil> 0.25s
07:08:06 <nil> damn
07:08:26 <maerwald> still slower than the C version
07:08:58 <maerwald> could be the lazy stack list maybe
07:09:51 <nil> lazy as in unboxed?
07:09:59 <nil> er, boxed
07:10:03 <nil> are there unboxed lists?
07:10:19 <nil> i'll try to profile this
07:12:15 <maerwald> your code could benefit from type signature :>
07:13:15 <nil> :D
07:13:31 <nil> it wasn't meant to be read by other people
07:14:09 * hackage compensated 0.8 - Compensated floating-point arithmetic  https://hackage.haskell.org/package/compensated-0.8 (ryanglscott)
07:18:18 <nil> heh. i also had another version using mutable IOUArrays instead of StateT, which previously was performing slightly worse; it now runs 5 times faster
07:19:56 <nil> (5 times faster than the other version, that is)
07:20:05 <nil> (both compiled with -O2)
07:26:37 <Cale> nil: You could make unboxed list types, but they'd have to be for specific data types.
07:26:39 * hackage gitlab-haskell 0.1.3 - A Haskell library for the GitLab web API  https://hackage.haskell.org/package/gitlab-haskell-0.1.3 (RobStewart)
07:27:02 <Cale> (and the tail of the list somewhat obviously couldn't be unboxed)
07:27:04 <nil> Cale: that's alright, i only need [Word16]
07:28:21 <Cale> data Word16List = Nil | Cons {-# UNPACK #-} !Word16 Word16List
07:28:36 <Cale> (and then make sure -O is turned on, or this has no effect)
07:28:43 <nil> i'm not sure this would be a significant performance improvement though, mostly because my test program doesn't use the stack that much
07:28:46 <nil> thanks, i'll try
07:28:48 <maerwald> I also wonder if you could STUArray
07:29:03 <nil> maerwald: isn't IOUArray just STUArray specialised to IO?
07:29:17 <nil> (i am using IOUArrays)
07:29:50 <maerwald> maybe it's the same performance characteristics
07:32:36 <bifunc2> Is it possible for tests in a project to test functions from an executable  in the same project?
07:32:45 <bifunc2> (I have a project  without a library.)
07:33:12 <merijn> bifunc2: Not easily
07:33:15 <bifunc2> I  have a hard time including the exe portion as a dependency into the tests.
07:33:17 <bifunc2> hmm ok
07:33:43 <merijn> bifunc2: OTOH I'm convinced that basically every executable should just be "a library with a thin wrapper" anyway :p
07:33:50 <merijn> So it's usually not a problem
07:34:44 <bifunc2> ok, i'll do that too :)
07:35:37 <merijn> bifunc2: And there's very little downside to structuring things like that (I'm not really aware of any, at least)
07:36:01 <bifunc2> yeah i see no downside either
07:38:45 <kscarlet> does haskell has a good RPC mechanism? if not that would make it hard to distribute components of the system over network
07:39:02 <merijn> kscarlet: Define "good RPC mechanism"?
07:39:16 <merijn> There's a bunch of stuff in Cloud Haskell for that sorta thing
07:39:43 <kscarlet> i see, looks neat
07:40:48 <maerwald> nil: I would also try dumping state monad and make everything IORef :P
07:41:01 <dminuoso> kscarlet: If you are familiar with Erlang OTP, Cloud Haskell is based on that in spirit. :)
07:41:08 <nil> maerwald: yes, my IOUArray version uses IORefs too
07:41:22 <maerwald> no state monad?
07:41:50 <nil> (i've added it to the gist if you're curious)
07:41:58 <nil> nope
07:42:52 <nil> making everything strict didn't change the performance, the only place i could find an improvement is on line 40, in `jump` (i'm not quite sure why)
07:44:25 <nil> hmm... http://hackage.haskell.org/package/unboxed-ref-0.4.0.0
07:44:33 <nil> i'm tempted to try that out
07:44:50 <nil> maybe i should just leave it there though, 3 times slower than C is already something to be proud of
07:45:46 <maerwald> I thought it's 200ms vs 20ms
07:46:11 <nil> 200ms was the StateT version
07:46:22 <nil> the IOUArray version takes about 70ms
07:46:26 <merijn> nil: I missed the context, what are you doing?
07:46:27 <srid> As a beginner Haskeller I had quickly reached out for `MonadThrow` for reporting errors from otherwise pure functions. Since then I learned that `MonadError` is better, as the function can then report a specific error type (instead of arbitrary types constrained by Exception class). Or am I missing something? Some libraries use MonadThrow in pure functions: 
07:46:27 <srid> https://github.com/commercialhaskell/path/blob/master/src/Path/Include.hs#L409-L418
07:46:28 <maerwald> ah
07:46:37 <nil> merijn: trying to optimise this https://gist.github.com/niiiil/95064d85627986d1557235e5f569ed48
07:46:44 <merijn> srid: Whether MonadError is "better" is debatable
07:47:04 <nil> this gist contains three versions of the same program, two in haskell and one in C, and a profiling report i should remove
07:47:33 <merijn> srid: MonadThrow is a typeclass for throwing IO exceptions, MonadError is one for ExceptT (aka EitherT) they're not really comparable
07:47:44 <Cale> srid: I'd usually just go with something very neutral if the function is otherwise-pure, like Either
07:47:58 <srid> merijn: the problem is with MonadThrow the caller has to expect any arbitrary exception. with `MonadError MyErrType` they only expect MyErrType. remember, I'm talking about pure functions (not IO actions)
07:48:07 <merijn> nil: Have you tried ST yet?
07:48:08 <Cale> It's easy to turn an Either into whatever other kind of exception you might want
07:48:13 <nil> merijn: the main solution to my issue was to compile with -O2, which made the time i was testing go from 6+ seconds to 200ms on one version and 60ms on the other
07:48:22 <nil> merijn: i don't think i need it here
07:48:33 <nil> everything is happening in IO
07:49:00 <srid> merijn: Cale - for context, I should link you to this discussion which had me thinking about this: https://github.com/commercialhaskell/path/issues/149 (btw, Cale, I was referring to my use of MonadThrow -- which later got changed to MonadError -- in obelisk)
07:49:09 <maerwald> Cale: have you seen https://docs.haskus.org/variant/excepts.html
07:49:16 <merijn> nil: IORef does some locking to make accesses atomic, so ST might be faster in that regard
07:49:49 <merijn> srid: tbh, I personally really dislike MonadError
07:49:57 <merijn> I prefer explicit use of Either/ExceptT
07:50:44 <srid> I think a plain Either would still be a better alternative to using MonadThrow in pure functions
07:50:48 <Cale> maerwald: I haven't really gotten into the whole type-level list meme, but that makes some sense
07:51:29 <srid> when a pure function uses MonadThrow, i would expect it to throw an arbitrary exception. but looking at its library source code, it throws a single custom data type. So MonadThrow doesn't seem like a fitting candidate here 
07:51:49 <merijn> srid: I'm not really sure what "pure function" even means in the context of MonadThrow, tbh
07:51:57 <srid> both `Either CustomError` and `MonadError CustomError` will work, because they specify the type of the error
07:52:21 <Cale> I tend to expect that if I begin using type-level lists, I'm going to end up in a position where I need to do nontrivial type-level computations/proofs on lists in order to make things typecheck, which seems like a big enough downside in Haskell to avoid it. In something dependently-typed, I might be a bit less reserved.
07:52:59 <srid> merijn: This function is pure, except for its error reporting (via throwM) behaviour: https://github.com/commercialhaskell/path/blob/master/src/Path/Include.hs#L409-L418
07:53:08 * hackage rainbow 0.34.2.0 - Print text to terminal with colors and effects  https://hackage.haskell.org/package/rainbow-0.34.2.0 (OmariNorman)
07:53:24 <Cale> (but actually using certain aspects of dependent types in Haskell is pushing the envelope in a way that can make things difficult to maintain)
07:53:30 <maerwald> I also like These over Either
07:53:33 <maerwald> @hackage these
07:53:33 <lambdabot> http://hackage.haskell.org/package/these
07:53:50 <Cale> I don't know about These *over* Either, but yeah, These is important.
07:53:51 <merijn> srid: I mean, anything not using unsafe is pure...anyway, functions that aren't in some IO based monad should just return Either
07:54:33 <Cale> I... wish that package had not been split
07:54:44 <maerwald> Cale: but the chronicle transformer really has terrible function names
07:54:45 <srid> In what scenarios would anyone use MonadThrow?
07:54:53 <maerwald> confess, disclose... er right
07:54:57 <Cale> maerwald: I agree, though it's entirely a meme
07:54:58 <geekosaur> as should some that are in IO.I still think the file-open functions should mostly return Either instead of throwing a synchronous exception for file open errors
07:55:18 <Cale> I don't think I've ever run into a situation where it would really have been the thing to use.
07:55:19 <geekosaur> there are things that can go wrong asynchronously but "file not found" isn't one of them
07:55:25 <merijn> srid: Throwing IO exceptions in stacks/monads over IO
07:55:39 <Cale> (though it is universal in a particular way, so probably such a situation will occur eventually)
07:57:04 <Cale> But yeah, for align to be separated out is enough to make me just want to start releasing a series of versions of these whose version numbers converge to 1
07:57:31 <Cale> I guess what's done is done though
07:58:45 <dmwit> Cale: I've used MonadChronicle for a compiler-style thing. This for errors, That for successes, These for warnings.
07:59:29 <Cale> dmwit: Yeah, that seems reasonable
08:03:58 <Gurkenglas> Missing "updateAtF :: Functor f => (k -> a -> f (Maybe a)) -> Int -> Map k a -> f (Map k a)"
08:11:41 <Gurkenglas> Is there an l-free way with up to one use of xs to write let l = length xs in [l,l-1..1]?
08:11:54 <merijn> hmm...anyone have a good style for linewrapping long transformer stacks? >.>
08:12:18 <Rembane> Gurkenglas: Using the range function is a good start imo
08:12:21 <Rembane> :t range 
08:12:23 <lambdabot> Ix a => (a, a) -> [a]
08:12:52 <dmwit> Gurkenglas: let down n = [n,n-1..1] in down (length xs) -- l-free. next you're gonna ask about down-free
08:13:08 <Gurkenglas> I like that more actually
08:13:20 <dmwit> :t takeWhile (>=1) . iterate (subtract 1) . length
08:13:22 <lambdabot> Foldable t => t a -> [Int]
08:14:15 <Gurkenglas> dmwit, though it's not l-free, n is l
08:15:59 <dmwit> oh, tru
08:16:21 <dmwit> Well my latest \bot query is pretty l-free.
08:16:30 <dminuoso> What is l-freeness?
08:16:46 <dmwit> Since it's completely variable-free (well, barring variables defined in the Prelude, anyway), it's certainly l-free.
08:16:50 <dmwit> dminuoso: No variables named l. ;-)
08:27:39 * hackage expresso 0.1.2.2 - A simple expressions language based on row types  https://hackage.haskell.org/package/expresso-0.1.2.2 (willtim)
08:37:39 * aric-Iu- server - irc.europeirc.eu - Join. -
08:37:39 * aric-Iu- server - irc.europeirc.eu - Join. -
08:37:57 * aric-Iu- server - irc.europeirc.eu - Join. -
08:37:57 * aric-Iu- server - irc.europeirc.eu - Join. -
08:38:12 * aric-Iu- server - irc.europeirc.eu - Join. -
08:38:12 * aric-Iu- server - irc.europeirc.eu - Join. -
08:38:16 * aric-Iu- server - irc.europeirc.eu - Join. -
08:38:17 * aric-Iu- server - irc.europeirc.eu - Join. -
09:10:05 <imgulya> Hello. I just started using lenses, and run into something. I have a record definition R in module A. I make the lenses with makeLenses ''R.  How can I expose the generated lenses from A so that I can use them from other modules? Thanks
09:11:05 <Rembane> imgulya: You need to export them manually IIRC
09:11:25 <dminuoso> Or you export the entire module blanket.
09:11:36 <maerwald> are the records even prefixed with underscore?
09:11:47 <imgulya> maerwald: yes, they are.
09:11:56 <imgulya> I mean the its fields are.
09:11:59 <dminuoso> imgulya:  What I do, is have a separate lens module `module Foo.Lens where`, in which I use the TH helpers
09:12:06 <dminuoso> imgulya: That automatically re-exports all lenses.
09:12:35 <maerwald> then the functions will be without underscore and you can export them explicitly
09:13:12 <imgulya> I see, thanks.
09:13:38 <merijn> The fact that you can do "module Foo" in the export list of module Foo is a life-hack I knew I'd had learned much sooner :p
09:13:59 <dminuoso> merijn: What do you mean?
09:14:06 <dminuoso> merijn: `module Foo (module Foo, ...) ... ` ?
09:14:09 <merijn> dminuoso: Yes
09:14:14 <dminuoso> That works?! :o
09:14:16 <xenon-> I knew that one for a while.. very useful
09:14:23 <merijn> The exports everything from the local module
09:14:39 <merijn> s/The/That
09:14:55 <merijn> Very useful if you want to export everything while also reexporting some stuff
09:15:00 <geekosaur> note that you don't need it if that's all you're exporting; `module Foo where` is sufficient there. it's ... that
09:15:25 <dminuoso> merijn: s/Very/Only/ :-p
09:15:42 <dminuoso> It's certainly a good trick to now.
09:15:43 <geekosaur> you can also reexport everything you've imported from some other module by naming it there instead
09:18:49 <merijn> Is there a way to check if both stdout and stderr are mapped to the same terminal?
09:20:19 <dminuoso> merijn: The only way would be via ioctl I guess
09:20:22 <dminuoso> if at all
09:20:52 <merijn> I guess there can technically be only one terminal per application, so if they're both connected to the terminal I guess that suffices...
09:21:48 <geekosaur> fstat and compare st_dev
09:22:47 <geekosaur> and there can in fact be multiple terminals although at most one is the controlling terminal. (think terminal emulators, or cu/tip/minicom/whatever)
09:22:58 <merijn> hmm
09:24:38 * hackage tmp-postgres 1.15.1.1 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.15.1.1 (JonathanFischoff)
09:25:03 <geekosaur> in Haskell that's getFdStatus (note need to get an fd from a Handle) and specialDeviceId
09:27:24 <merijn> ugh, can't easily get an fd from a Handle since that closes the handle
09:27:35 <merijn> I guess I can use the stderr/stdout Fd's from the unix package
09:28:10 <geekosaur> yeh, you have to convert twice because they're overly worried about mangled buffering
09:28:21 <geekosaur> unsafeHandleToFd would be helpful
09:31:10 <geekosaur> actually last time I cared I imported GHC.Handle and rolled my own
09:31:35 <geekosaur> unix only, but you're already in that realm with these calls
09:35:09 <merijn> My code is already super unix only :p
09:38:50 <Pamelloes> Is there a good way to split a monadic computation? I want to write a function a -> [ m b ], where each entry in the list is a function of the previous one.
09:39:26 <merijn> :t foldM -- ?
09:39:28 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
09:40:20 <Pamelloes> In my head I'd like to write something like { do compute; yield; computeMore; yield; ... } where at each yield, the current state is added to the output list.
09:41:00 <Gurkenglas> Pamelloes, if the computemore is really different each time and sometimes you'd like to yield in a subroutine, use the Writer monad
09:42:36 <Gurkenglas> > do x <- ("initializing",2); y <- ("fetching second value",2); return $ x+y
09:42:39 <lambdabot>  ("initializingfetching second value",4)
09:43:27 <Pamelloes> Can you have nest WriterT?
09:44:16 <Gurkenglas> Yes, but then tell goes to the outer WriterT by default
09:45:37 <Pamelloes> Interesting. I'll have to think about if this is what I really want to do
09:46:21 <Gurkenglas> Pamelloes, if there is repeating structure to what you want to do, can you write down the type signature more precisely than a -> [ m b ]?
09:46:41 <Gurkenglas> aka finding a library function with what type signature would make you happy?#
09:51:39 * hackage doctemplates 0.7.2 - Pandoc-style document templates  https://hackage.haskell.org/package/doctemplates-0.7.2 (JohnMacFarlane)
10:03:08 <Kristjan1291983> Hello people, I have just started a company, main specialization is simple web pages. I'm looking for clients. http://supersoft.likesyou.org/en
10:03:25 <dminuoso> Sounds legit.
10:03:39 <xenon-> I'll take two
10:03:51 <Kristjan1291983> Please write to me
10:03:58 <Kristjan1291983> Via the e-mail on webpage
10:04:00 <Kristjan1291983> or call
10:04:22 <dminuoso> Kristjan1291983: Im curious, do you expect anyone to actually click on that ink?
10:04:38 <Kristjan1291983> Yes
10:06:48 <dminuoso> Kristjan1291983: And the relationship to Haskell?
10:07:06 <dminuoso> Kristjan1291983: Are you hoping to rewrite that webpage using Haskell?
10:07:15 <Kristjan1291983> No
10:07:20 <Kristjan1291983> I know the language
10:07:33 <Kristjan1291983> I am programming in it if it is neccessary and wanted
10:07:36 <Kristjan1291983> By clients
10:08:15 --- mode: ChanServ set +o geekosaur
10:08:51 <rotaerk> perhaps take that to #haskell-advertisements
10:09:06 <glguy> Kristjan1291983: spam isn't welcome on freenode
10:09:14 <geekosaur> if it's not haskell related, not even there
10:10:02 <Kristjan1291983> It is
10:10:37 <dminuoso> I guess it wasn't just #haskell ... :o)
10:10:45 <geekosaur> not surprised
10:10:57 --- mode: geekosaur set -o geekosaur
10:11:18 <xenon-> haskell was among most popular channels last time I checked. probably the only reason he joined
10:11:39 * hackage souffle-haskell 0.0.1 - Souffle Datalog bindings for Haskell  https://hackage.haskell.org/package/souffle-haskell-0.0.1 (luc_tielen)
10:12:57 <xenon-> top #6
10:13:00 <xenon-> python is #2
10:13:39 <rotaerk> this thing is haskell related because I made it and I've heard of programming languages, and haskell is a programming language, therefore it's related
10:14:01 <dminuoso> xenon-: Interesting, we used to be #2 a year ag.
10:14:21 <xenon-> #2 programming related, or overall?
10:14:27 <dminuoso> overall on freenode
10:14:42 <glguy> We lost a lot of lurkers after an incident with a #haskell op's account getting compromised resulting in the channel getting cleared :)
10:15:13 <rotaerk> 1485 is still a pretty huge number
10:16:18 <salva> stack is not working for me, unable to connect to raw.githubusercontent.com
10:16:37 <nil> Sounds like a network issue
10:17:04 <salva> yeah, but I don't have any other problem connecting to other servers
10:17:30 <nil> xenon-: where do you find that list?
10:17:49 <xenon-> just type /list and wait for a bit
10:18:01 <nil> Ok
10:18:46 <nil> Ugh, doing that on a phone client was a bad idea.
10:18:49 <xenon-> glguy interesting. did they attempt a takeover?
10:19:04 <geekosaur> they redirected the channel to a different one
10:19:26 <glguy> I think they were just having fun; we got it fixed right away afterward
10:19:26 <xenon-> #python? =)
10:19:30 <geekosaur> and kicked everyone so on rejoin they landed in the other channel. other haskell ops had to undo it
10:19:42 <geekosaur> no, I think I landed in #mysql or something
10:20:08 <geekosaur> my logs are on a different machine
10:42:08 * hackage massiv 0.4.4.0 - Massiv (Массив) is an Array Library.  https://hackage.haskell.org/package/massiv-0.4.4.0 (lehins)
10:44:11 <Pamelloes> Can I sequence in reverse?
10:44:20 <geekosaur> not generally
10:44:30 <merijn> What does that even mean?
10:44:40 <Pamelloes> I want a function Monadm => m [a] -> [m a]
10:44:53 <dmwit> :t forwards . traverse Backwards
10:44:55 <lambdabot> error:
10:44:55 <lambdabot>     Variable not in scope: forwards :: f0 (t b0) -> c
10:44:55 <lambdabot> error:
10:45:16 <merijn> Pamelloes: That's not possible in general
10:45:20 <dmwit> Oh, yeah, no, you can't do that for most `m`.
10:45:50 <dmwit> Which m are you interested in, specifically?
10:46:14 <dmwit> Maybe a better question: why do you want that?
10:46:44 <glguy> :t backwards traverse
10:46:46 <lambdabot> (Traversable t, Applicative f) => Optical (->) (->) f (t a) (t b) a b
10:47:00 <Pamelloes> I'm trying to make a function iterateM :: Monad m => Int -> (a -> m a) -> a -> [m a] which iterates (a -> m a) n times and returns a list of each stage of the iteration
10:47:29 <glguy> :t sequenceOf (backwards traverse)
10:47:31 <lambdabot> (Traversable t, Monad m) => t (m b) -> m (t b)
10:47:34 <MarcelineVQ> [m a] not m [a] ?
10:47:46 <glguy> (yes, I know that's not the thing Pamelloes is asking about)
10:48:05 <Pamelloes> MarcelineVQ: yes
10:48:08 <dmwit> Pamelloes: ...but why?
10:48:29 <geekosaur> [m a] looks wrong there tbh, you'd not be iterating, you'd be making multiple independent actions
10:48:40 <geekosaur> and not getting any results
10:49:49 <Pamelloes> I'm trying to use this to make a branching Writer computation
10:50:01 <dmwit> :t Back.forwards . traverse Back.Backwards
10:50:03 <lambdabot> (Traversable t, Applicative f) => t (f b) -> f (t b)
10:50:52 <Pamelloes> Specifically, I want to write a value one to three times first, and then in each of these cases, write a second value one to ten times.
10:51:06 <Pamelloes> But I have some complicated logic that may short circuit each of these iterations
10:51:55 <Pamelloes> So I do actually want a list of independent computations here.
10:52:08 <dmwit> Can you use ExceptT to get the short circuiting instead?
10:52:34 <EvanR> list monad?
10:53:52 <EvanR> join :: [[a]] -> [a], has branching and short circuiting
10:55:17 <Pamelloes> Maybe
10:55:49 <dminuoso> That sounds exactly like list monad. :)
10:57:07 <Phyx-> Lol, haven't seen a kline in a while 
11:01:46 <Pamelloes> I see how (=<< :: (a -> [b]) -> [a] -> [b]) creates a branching computation, but how does the list monad provide short circuiting?
11:02:07 <EvanR> produce [] with that function
11:02:12 <gobby> When I print the result `unpack` from `Data.ByteString.Char8.Lazy` my program loops and prints the bytestring infinitely. What the hell is going on?
11:02:21 <EvanR> cuts off the rest of the action
11:02:31 <EvanR> or use fail hehe
11:02:50 <EvanR> > fail "oh noes" :: [Int]
11:02:52 <lambdabot>  []
11:03:06 <geekosaur> gobby, printing is strict even if the data source is strict, unless you limit printing somehow (e.g. lambdabot does `take 50` or some such)
11:03:35 <geekosaur> just because the data is lazy doesn't mean a strict operation becomes lazy when given it
11:04:37 <gobby> geekosaur I don't understand. Did you mean to say even if the data source it lazy?
11:04:39 <EvanR> > do{ x <- [1,2]; y <- if even x then [x,x,x] else []; [y,y] }
11:04:41 <lambdabot>  [2,2,2,2,2,2]
11:04:52 <geekosaur> gobby, yes, I meant to say that
11:05:13 <geekosaur> putStrLn would be kinda useless if you called it on a String and it printed only the first character
11:05:16 <gobby> geekosaur why does it loop indefinitely though?
11:05:32 <geekosaur> presumably the ByteString is infinite. how did you produce it?
11:06:02 <gobby> via `OctetStream` in `servant`
11:06:08 <geekosaur> (I think there are also some unsafe operations that can build looped lazy ByteStrings since they're lists of chunks underneath)
11:06:26 <gobby> but I'm using `servant` with `aws` which has been.....an experience.
11:06:48 <EvanR> gobby sounds like they want a streaming lib!
11:06:55 <geekosaur> that still doesn't tell me a whole lot since I have no idea what the OctetString represents/contains
11:07:41 <gobby> EvanR I didn't think of that. When I try to `eitherDecode` my `ByteString` I get an `endOfInput` error.
11:09:07 <dmwit> gobby: Time to show a MCVE.
11:09:49 <EvanR> yeesh it sounds like your lazy bytestring is using 'lazy i/o'
11:11:01 <gobby> dmwit: you would need an aws account
11:12:09 * hackage ListLike 4.6.3 - Generalized support for list-like structures  https://hackage.haskell.org/package/ListLike-4.6.3 (DavidFox)
11:12:16 <gobby> EvanR: How do you know this?
11:12:32 <EvanR> well i just tried to use eitherDecode, which is a non-IO function
11:12:44 <EvanR> on a lazy byte string that is too short or empty, it doesn't give that error
11:13:30 <EvanR> so it seems decoding your lazy bytestring is trying to read from a handle implicitly, which is spooky and clearly an issue
11:14:16 <gobby> If I make a MCVE would  you look at it?
11:14:31 <EvanR> somebody would
11:14:35 <gobby> lol
11:14:41 <EvanR> probably, eventually :P
11:14:54 <gobby> I may just push the repo
11:15:13 <gobby> cause I'm using servant and have to convert the AWS request to a wai request
11:17:48 <gobby> EvanR dmwit this is my shim code: https://pastebin.com/tFSQMK0R
11:18:01 <srid> I think I just got bit by Haskell's laziness
11:18:17 <srid> writeFileText s -- truncates file even if `s` is a strict Text
11:18:48 <EvanR> eh?
11:18:56 <merijn> srid: IO is never lazy unless you explicitly use unsafeInterleavIO/lazy IO
11:19:02 <srid> The solution was to replace that with `writeFileText $! s`
11:19:25 <srid> cf. https://wiki.haskell.org/Performance/Strictness#Evaluating_expressions_strictly
11:19:37 <merijn> Where does writeFileText come from?
11:19:46 <srid> writeFile truncates the file (which did happen, unless I use `$!) before beginning to write.
11:20:04 <gobby> dmwit EvanR and this is my servant API: https://pastebin.com/ZzPaRbZq
11:20:06 <merijn> srid: That makes no sense
11:20:07 <srid> merijn: that just uses writeFile https://hackage.haskell.org/package/relude-0.6.0.0/docs/src/Relude.File.html#writeFileText
11:20:47 <shapr> Is there a recent blog post on profiling + optimization in Haskell?
11:21:03 <merijn> srid: I don't see how making the input text strict could possibly affect the behaviour of that
11:21:09 * hackage tmp-postgres 1.16.0.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.16.0.0 (JonathanFischoff)
11:21:32 <srid> let s = TL.toStrict $ Lucid.renderText blah -- This is using Lucid library to render HTML
11:21:32 <srid> writeFile somePath s 
11:21:32 <srid> ^ when the Lucid monad throws error, this truncates the file. The original bug.
11:21:51 <srid> The fix was to add a `$!` before `s`. I don't understand how this worked.
11:22:07 <srid> I thought an explicit `TL.toStrict` would have removed any laziness.
11:22:32 <merijn> srid: toStrict removes the laziness, but toStrict doesn't actually run until 's' is forced
11:23:49 <svipal> question here
11:23:53 <srid> So, always do this? `let !s = TL.toStrict ...` (i.e. use BangPatterns in front of toStrict). Otherwise why would anyone want lazy evaluation when converting lazy text to strict?
11:24:04 <srid> It makes no sense
11:24:04 <svipal> Can you profile a program running under GHCI
11:24:26 <svipal> just curious really, not planning to *unless it's really easy
11:25:38 <geekosaur> svipal, you'd need a profiling build of ghc
11:25:52 <geekosaur> since ghci = ghc --interactive
11:27:19 <geekosaur> also I wouldn't trust the numbers since ghci is already fairly slow and non-optimized
11:27:47 <EvanR> gobby: Response is undocumented so it seems to me you shouldn't be breaking it open and using the innars directly, that's just an observation. I don't actually know what problem you're seeing where
11:29:00 <EvanR> srid: well, Ints "are strict" but you have to be careful when doing a complex arithmetic, because haskell is lazy
11:29:11 <EvanR> one way is bang patterns
11:29:18 <gobby> EvanR undocumented as undocumented in my code or undocumented in  `wai`
11:29:25 <EvanR> undocumented in wai
11:29:56 <EvanR> the docs make it look like an abstract type
11:31:02 <EvanR> srid: strict/lazy evaluation vs strict/lazy data structure (all of the above are being loose with "strict")
11:31:39 <srid> EvanR: merijn - FWIW, here's the fix: https://github.com/srid/rib/commit/6da1ba0eb0d3fc4286745b08439459550c10a76b
11:32:04 <srid> EvanR: got it
11:32:17 <EvanR> i don't want to know the fix, i want to know what the problem was
11:32:50 <srid> writeFile was truncating the file whenever `error` was used in the Lucid monad (rendering html).
11:33:00 <merijn> EvanR: The problem was lazy bytestring throwing an error which didn't trigger until the write started (which truncated)
11:33:23 <EvanR> oh there was a lazy bytestring involved
11:33:25 <merijn> Which isn't even a bug, IMO
11:33:30 <srid> it was lazy Text, though
11:33:41 <merijn> eh, text, bytestring, same diff
11:34:05 <EvanR> so bottoms are to blame
11:34:09 <srid> but it uses lazy bytestring internally, cf. https://hackage.haskell.org/package/lucid-2.9.12/docs/src/Lucid.Base.html#renderText
11:34:30 <srid> uses Blaze: https://hackage.haskell.org/package/blaze-builder-0.4.1.0/docs/Blaze-ByteString-Builder.html#v:toLazyByteString
11:34:46 <EvanR> you got bit by someone using 'error' in the Lucid monad
11:34:49 <gobby> EvanR: thanks ill look into how wai deals with `Response`. Perhaps I'm doing it incorrectly.
11:35:02 <srid> EvanR: yup. i have error peppered throughout the code :P
11:35:16 * EvanR gets nauseous
11:35:21 <srid> guess i should fix it and have the function return `Either e ...`
11:35:48 <srid> EvanR: what if this was an exception thrown? would the problem still not occur?
11:36:09 <EvanR> you mean with throw?
11:36:15 <EvanR> it would be the same issue
11:36:17 <srid> yup
11:36:21 <EvanR> @src error
11:36:21 <lambdabot> error s = throw (ErrorCall s)
11:36:32 <srid> ah right. they are both bottoms
11:36:53 <EvanR> nevermind why error is peppered, why is it being reached at all?
11:36:55 <srid> hence, adding errors to the function types. 
11:36:58 <EvanR> bad data validation?
11:37:09 * srid vaguely recalls Bartosz's discussion of bottoms in ctx of CT
11:37:57 <srid> This program is a static site generator, reading Markdown and converting to HTML. error will be thrown if a) markdown syntax is wrong, b) metadata cannot be parsed as JSON into an user's data type. 
11:38:20 <EvanR> that should really be checked before you begin templating
11:38:32 <EvanR> and streaming begins
11:39:56 <srid> Good idea. I should just change the Document type to replace parsed doc with actual html: https://github.com/srid/rib/blob/master/src/Rib/Markup.hs#L27 (and maybe as well replace aeson Value with a `FromJSON a` - but that might be too much)
11:40:25 <srid> re: aeson Value, it used to do that. The type was `Document t meta`
11:40:57 <EvanR> i guess
11:41:15 <EvanR> but if you had a valid markdown doc, then you can stream out the HTML
11:41:39 <EvanR> rather than build up the HTML in memory while you wait for it to fail
11:43:39 <EvanR> (also can pandoc be your static site generator?)
11:44:29 <srid> My library uses two parsers: pandoc & mmark. And uses a type class to switch between the two.
11:45:17 <srid> It used to be just pandoc, but I grew tired of the behemoth that is pandoc, and wanted to use something lighter, hence `mmark`. So: https://github.com/srid/rib/pull/46
11:46:11 <EvanR> hmm to support multiple input formats i imagine a juicypixels-like situation rather than a typeclass
11:46:42 <srid> how would that look?
11:47:04 <EvanR> you give it an input and it gives you data Markup = Markdown MMark | 
11:47:25 <EvanR> you give it an input and it gives you data Markup = MMark MMarkDoc | Pandoc PandocDoc
11:48:02 <EvanR> by trying both parsers
11:48:15 <EvanR> well gives you a Maybe Markup
11:48:41 <srid>  Currently the user of the library uses `TypeApplications` to choose the parser: https://github.com/srid/rib-sample/blob/master/Main.hs#L60
11:48:58 <srid> And their functions remain polymorphic (see line 67)
11:49:02 <EvanR> well
11:49:47 <srid> I'm trying to imagine how your types would make this Main.hs look (as library user)
11:50:47 <Pamelloes> Is there a list monad transformer?
11:50:55 <EvanR> the way user code looks would be... case parse input of Just (MMark doc) -> ...; Just (Pandoc doc) -> ...; Nothing -> ...
11:51:19 <srid> So it will use *both* the parsers? 
11:51:43 <EvanR> try mmark first since you say it's lighter weight
11:52:03 <geekosaur> Pamelloes, there is ListT but it's not law-abiding and may have been offloaded from mtl. there are alternatives that are, such as LogicT
11:52:35 <srid> Well I think it has to choose one or the other. For example, for my site I choose mmark, and I rely on certain mmark extensions (table of contents, footnotes, etc.) - which won't work with Pandoc. So I wouldn't want the uncertainty of multiple parsers here.
11:52:41 <geekosaur> no, it's still there, Control.Monad.List in mtl: http://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-List.html
11:53:21 <srid> I considered support just mmark, and removing pandoc altogether. But pandoc is still useful in some cases, as it supports formats other than Markdown.
11:53:27 <EvanR> if they are that different and no one would want this "accept any" behavior... not sure i see the value in a class. Especially if you have to do TypeApplications necessarily
11:54:03 <koz_> Pamelloes: There are _several_, but you probably don't want them.
11:54:22 <srid> TypeApplications is only necessary if the rest of the code remains polymorphic. If `renderPage` had the type `Page MMark -> Html ()` no TypeApplications is needed. 
11:54:32 * EvanR headscratch
11:54:50 <EvanR> exactly what do the two instances have in common
11:55:01 <Pamelloes> Interesting. I'll check those out.
11:55:05 <EvanR> how could they be used polymorphically
11:55:06 <srid> ... and `data Page = ...` instead of `data Page doc = ...`
11:55:28 <koz_> Pamelloes: What are you trying to do with a list monad transformer? Or is this just for understanding/research/funsies?
11:55:30 <svipal> I have this weird going on thing with TypeApplications where I feel like really badass everytime I use it, 
11:55:37 <svipal> and it's a bit concerning
11:55:50 <EvanR> it's a control thing
11:56:01 <srid> EvanR: three things common between them: parsing, rendering and the error type: https://github.com/srid/rib/blob/master/src/Rib/Markup.hs
11:56:03 <EvanR> power balance between haskell and programmer
11:56:05 <svipal> hahaha
11:57:52 <EvanR> srid: yeah, the t here is being used in a way that can't be use polymorphically
11:58:20 <EvanR> i mean, in the sense that myValue :: a can't be used
11:58:33 <Pamelloes> koz_: I'm trying to enumerate all possible future moves in a game, and the path to get there.
11:58:48 <EvanR> t must be concrete in user code if it's going to be of use
11:58:52 <koz_> Pamelloes: You _probably_ wanna look at LogicT.
11:59:05 <srid> `t` is concrete in `_document_val` (the parsed structure)?
11:59:12 <koz_> However, I also suspect you _probably_ want something a bit more efficient than (what is essentially a fancy version of) brute force.
11:59:29 <srid> But what would be the alternative if not type class? 
12:00:02 <Pamelloes> koz_: My current approach is in fact exactly a fancy version of brute force :)
12:00:14 <siwica> Having a type defined as `data Foo = A Int | B Int | C Int`, I am looking for a datastructure similar to a Set that can contain each dataconstuctor at most one time. E.g. {A 1, B 2} is valid, {A 1, A 2} is not. Does such a datastructure exist and is that even possible with Haskells typesystem?
12:00:15 <srid> I suppose I could replicate these functions (parsing, rendering, error type, error conversion) between two modules -- MMark.hs & Pandoc.hs -- and have the user do "import qualified Rib.Mod.MMark as M"
12:00:31 <EvanR> srid: a sober way to do this API would be to have the Markup class be a record of those functions
12:00:38 <koz_> Pamelloes: Yeah, LogicT is probably what you want then.
12:00:56 <EvanR> no t isn't concrete yet
12:01:45 <EvanR> b looks like a typo
12:02:09 <Pamelloes> I'm off to read the LogicT paper, then. Thanks for the help!
12:03:31 <koz_> Pamelloes: You're welcome
12:06:19 <EvanR> srid: ok i'm wrong. This only thing you could do is pass the document to the renderer, makes sense
12:06:46 <EvanR> and display errors
12:08:25 <siwica> Any opinions?
12:08:50 <EvanR> so that does put some guiding constraints on your driver polymorphic in Markup t
12:09:37 <EvanR> siwica: there's dependent maps and extensible records for this
12:09:50 <EvanR> A B and C look like "fields"
12:10:16 <EvanR> it's possible in haskell but advanced
12:11:16 <siwica> Hm, yeah. They might aswell be fields in a record I guess.
12:11:34 <siwica> Thanks for the terms. I'll do some googling then...
12:11:55 <EvanR> yeah if you know the fields ahead of time... going to be easier to use a record
12:13:32 <siwica> Hm, a record of multiple fields of type `Maybe Int` might be the easiest if I think about it.
12:13:51 <siwica> That somehow did not occur to me before.
12:14:15 <EvanR> data ABC a = ABC {abcA :: a, abcB :: a, abcC :: a}
12:14:25 <EvanR> er
12:14:38 <EvanR> data ABC f a = ABC {abcA :: f a, abcB :: f a, abcC :: f a}
12:14:41 <EvanR> ABC Maybe Int :)
12:15:23 <siwica> Yeah. No need to abstract it that much though. :)
12:15:30 <EvanR> said no one ever!
12:15:56 <EvanR> in all seriousness this is sometimes what you have to do to satisfy many type classes which assume "abstracted that much"
12:15:59 <siwica> Well maybe you are right...
12:16:58 <siwica> Yeah, it probably makes sense if I think about it. Thanks! :)
12:19:15 <EvanR> e.g. instance Foldable f => Foldable (ABC f) 
12:20:19 <MarcelineVQ> Should also be doable with Set with a degenerate​ Ord instance. You could use a newtype to not pollute other things. newtype SetFoo = SFoo {unFoo :: Foo}   you'd have your Ord instance for SetFoo consider all A equivalent. caveat being that adding SFoo (A 1) to a Set containing SFoo (A 2) will have the Set now contain SFoo (A 1) instead.
12:22:38 * hackage tmp-postgres 1.16.1.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.16.1.0 (JonathanFischoff)
12:24:28 <EvanR> data Letter = A | B | C deriving Ord... Map Letter Int ?
12:25:07 <EvanR> i jumped to dependent map without noticing the high non-dependentness
12:25:25 <koz_> EvanR: data Letter = A | B | C deriving (Eq, Generic, Finitary) ... Vector 3 Int and use toFinite for indexing. :P
12:26:06 <EvanR> which package exactly are you bragging about again :)
12:26:19 <koz_> EvanR: I wonder. :P
12:26:39 <EvanR> i looked at finitary-derive, but isn't it part of a family of packages or
12:26:40 <koz_> (considering the options given above, it could be up to two different ones!)
12:26:51 <koz_> EvanR: Well, you need finitary to use finitary-derive.
12:27:00 <koz_> The finitary 'family' is growing, when I can work on it.
12:27:06 <EvanR> so finitary comes with that whizbang Vector?
12:27:13 <koz_> Vector is from vector-sized.
12:27:13 <siwica> Oh, what have I done... :D
12:27:16 <koz_> (which I co-maintain)
12:27:16 <EvanR> ah
12:27:25 <koz_> Well, realistically, since you asked...
12:27:54 <koz_> data Letter = A | B | C deriving (Eq, Generic, Finitary) .. Vector 3 (PackBits Int) -- now you can be unboxed too!
12:27:59 <EvanR> siwica: opened a pandoras can of worms!
12:28:06 <koz_> Here, this is the ultimate self-promo from me.
12:28:36 <koz_> (although to be fair, the PackBits is unnecessary since Int can be Unboxed just fine without it)
12:28:37 <EvanR> koz_: needs to be Maybe Int... now what
12:28:49 <koz_> EvanR: That's totally fine.
12:28:50 <EvanR> -1 means it's not there? :)
12:28:58 <koz_> Vector 3 (PackBits (Maybe Int)) works.
12:29:06 <EvanR> oh wow
12:29:19 <EvanR> it uses 65 bits right
12:29:20 <koz_> Maybe only increases the cardinality of a type by 1.
12:29:27 <koz_> EvanR: PackBits would, yes.
12:29:33 <EvanR> wait...
12:29:35 <koz_> You could use PackBytes instead, which would be a bit more.
12:29:48 <EvanR> that was supposed to be a joke
12:30:14 <EvanR> a vector of 3 maybe ints takes 195 bits?
12:30:20 <koz_> EvanR: Lol, a fixed-length Vector of 3 (PackBits (Maybe Int)) would be 65 * 3 bits, rounding to the nearest Word boundary.
12:30:27 <koz_> (it packs everything as a bitvector)
12:30:45 <koz_> (and vectors of PackBits types are packed into one giant bitvector, with indexing by slicing)
12:30:56 <siwica> Thank's though for the ideas. I'll do some reading about all the stuff you mentioned if I find some time.
12:31:06 <EvanR> that should save space...
12:31:17 <EvanR> the teenage dream of storing Bools as bits :)
12:31:17 <koz_> EvanR: In practice, it's only worth it in very specific circumstances.
12:31:31 <koz_> I provide it more-or-less because I can.
12:31:43 <koz_> PackWords is nearly always a better option unless you're _really_ short of space.
12:31:59 <koz_> Since the chief advantage of the bitvector representation (bulk logical ops at high speeds) doesn't get used here at all.
12:32:08 <EvanR> so basically haskell has bitfields. Where is PackBits from?
12:32:13 <koz_> And bit accesses are usually slower, unless you've ported GHC to a museum piece.
12:32:19 <koz_> PackBits is from finitary-derive.
12:32:24 <koz_> The thing I use is from bitvec.
12:32:38 <koz_> s/PackWords/PackBytes/
12:32:57 <edwardk> siwica: you're pretty close to the memo-combinators approach
12:33:25 <lidenbrock> Hi. What is the best way to learn Haskell?
12:33:35 <edwardk> siwica: er http://hackage.haskell.org/package/data-memocombinators-0.5.1/docs/Data-MemoCombinators.html
12:33:43 <koz_> lidenbrock: Try writing something you care about.
12:35:17 <edwardk> wrap fromEithers toEithers $ either (either int int) int  -- in the parlance of that library, where fromEithers and toEithers are combinators for converting to/from your rep
12:36:43 <edwardk> that is then usable as a function of type (Foo -> r) -> Foo -> r  -- and if r = Bool you can use it like a set.
12:37:06 <edwardk> but unlike id it internally uses a structure like what you'd want
12:37:20 <shapr> koz_: I like that advice
12:37:39 <koz_> shapr: It's pretty good advice for learning a large range of things. Nothing like wanting something to get things done.
12:37:49 <shapr> koz_: did you see the thing I built recently?
12:37:54 <shapr> Fermat's Last Margin?
12:37:58 <koz_> Disclaimer: I learned Haskell because I needed to parse some hideous Weka output.
12:38:01 <edwardk> shapr built a thing?
12:38:03 <shapr> what's weka?
12:38:11 <koz_> shapr: Machine learning framework thingo.
12:38:14 <shapr> edwardk: yeah, but it's not up on Hackage yet
12:38:27 <shapr> edwardk: does have screenshots and kinda works: https://imgur.com/gallery/YNez0sA
12:38:49 <koz_> shapr: I... thought that was some kind of elaborate joke.
12:38:52 <shapr> I'm hoping last night's release of morpheus-graphql will fix one of the broken features
12:38:58 <koz_> About Hackage being too small to contain your solution or something.
12:39:01 <shapr> koz_: ha, that's cool :-)
12:39:20 <edwardk> weka = janky old style machine learning framework
12:39:27 <koz_> edwardk: Janky is right.
12:39:51 <edwardk> in new zealand, they are big brown birds that can't fly with bitchy personalities. the same can be said about the framework
12:39:54 <shapr> koz_: FLM is about having an infinite sized margin, but I like your interpretation
12:40:05 <koz_> edwardk: Truer words have never been spoken.
12:40:13 <koz_> (about both things)
12:40:16 * koz_ is from New Zealand.
12:40:31 <edwardk> koz_: =)
12:40:40 <koz_> Weka is also the reason why Waikato Uni still has a compsci department.
12:40:46 <koz_> (it's like, their sole achievement)
12:41:03 <koz_> (despite being situated in a region that is known for... farming and basically nothing else)
12:41:35 <edwardk> but yeah weka sort of embodies the "previous generation" of ml research
12:42:56 <edwardk> i remember having to staple output from half a dozen different weka based models together by hand with my own constructed notions of r^2 because it didn't have any good way to compare the quality of results across different regression models, etc.
12:43:08 <edwardk> it left a terribly bad taste in my mouth
12:43:10 <koz_> edwardk: Yeah, this is basically what I had to do.
12:43:17 <koz_> The thing left in my mouth was rather similar.
12:43:41 <koz_> Each model is its own special snowflake, and basically the results are 'blobs of fuck-you structured text'.
12:43:58 <edwardk> in my case this was 2004ish?
12:44:08 <shapr> I haven't heard this kind of resentment since I talked to the people who still work at my last job.
12:44:10 <EvanR> by memoizing a function from Letter -> Bool, could you also support updating the set without getting slower and slower
12:44:12 <koz_> edwardk: It hasn't gotten any better - last I used it was 2015ish!
12:44:16 <edwardk> glad to see they haven't learned anything since
12:44:52 <koz_> shapr: I have very few good things to say about most pieces of software I have ever used.
12:45:01 <koz_> Sturgeon's Law is alive and well.
12:45:02 <edwardk> shapr: i figure its worth letting my full opinions beknown lest my acknowledgement of its existence be accidentally taken by someone to be endorsement and lead someone astray
12:45:04 <EvanR> or leaking space
12:45:09 * hackage debian 3.96 - Modules for working with the Debian package system  https://hackage.haskell.org/package/debian-3.96 (DavidFox)
12:45:31 <edwardk> EvanR: yeah
12:46:01 <edwardk> using representable-tries lets you be a bit more explicit about the trie-like structure of it
12:46:08 * hackage compact-word-vectors 0.2 - Small vectors of small integers stored very compactly.  https://hackage.haskell.org/package/compact-word-vectors-0.2 (BalazsKomuves)
12:46:25 <edwardk> but you can do it all implicitly using the functional style
12:46:32 <koz_> That library was missing an opportunity in not naming itself 'small-word-vectors'.
12:46:48 <koz_> And describing itself as 'Small vectors of small integers stored very small-ly.'
12:47:00 <EvanR> small world vectors
12:47:08 <koz_> (maybe 'small-small-integer-vectors'?)
12:47:27 <koz_> (gotta qualify that smallness)
12:47:41 <edwardk> that reminds me i need to get around to building a tiny library for std::vector-like succinct vectors i've needed it like dozens of times now
12:48:10 <shapr> edwardk: if you get a chance to look at the screenshots for fermat's last margin, I'd appreciate any suggestions for features that would improve reading and annotating research papers.
12:48:17 <koz_> edwardk: Please make the name some kind of awful pun.
12:48:30 <shapr> something about skinks?
12:49:10 <edwardk> koz_: not much to pun on in there that is tasteful
12:50:16 <koz_> edwardk: I have faith in the person who came up with the type for from.
12:50:47 <koz_> Alternatively, the person who named 'confusing'.
12:50:51 <edwardk> hah
12:51:03 <edwardk> confusing is still one of my favorite combinators
12:51:16 <edwardk> even if glguy was theone who finally figured out how to write it
12:51:20 <edwardk> :t confusing
12:51:22 <lambdabot> Applicative f => LensLike (Data.Functor.Day.Curried.Curried (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
12:51:45 <lavalike> agreed
12:51:52 <koz_> :t from
12:51:54 <lambdabot> (Profunctor p, Functor f) => AnIso s t a b -> p t (f s) -> p b (f a)
12:51:58 <koz_> Aww.
12:52:09 <koz_> It should really be 'Iso s t a b -> Iso b a t s'.
12:52:29 <koz_> I can't help but this the entire lens library is just an elaborate setup for that bit of wordplay.
12:52:36 <koz_> s/this/think/
12:53:11 <edwardk> lens is setup for all sorts of wordplay. pun driven development was key
12:53:31 <koz_> edwardk: When will we get the book 'Pun-Driven Development'?
12:54:34 <edwardk> i'll add it to my copious list of backlogged projects
13:09:39 * hackage compact-word-vectors 0.2.0.1 - Small vectors of small integers stored very compactly.  https://hackage.haskell.org/package/compact-word-vectors-0.2.0.1 (BalazsKomuves)
13:23:09 <siwica> edwardk: Thanks for the explanation on the memo-combinators approach (I've only been reading it just now)! Regarding its level of abstraction I think it's a bit beyond what I feel comfortable writing in Haskell at the moment. But I will make a note and come back to it later.
13:28:46 <Athas> Will GHC 8.10 really not break source compatibility?  The alpha release notes look pretty harmless.
13:29:44 <dminuoso> Athas: What is source compatibility to you?
13:31:08 <Athas> dminuoso: mainly changes that would bump one of the two leading version numbers under the PVP scheme.
13:31:27 <Gurkenglas> Why doesn't confusing use auf?
13:31:32 <Athas> The MonadFail change definitely broke source compatibility.
13:32:05 <dminuoso> Athas: Well, there's certainly a list of things that can cause compilation errors in 8.10 that would have compiled in 8.8.
13:32:28 <dminuoso> Athas: Refer to https://gitlab.haskell.org/ghc/ghc/wikis/Migration/8.10
13:34:11 <Athas> Alright, mostly some fiddly type system stuff.  I suppose some of my dependencies could run into the stricter inferred type signatures.
13:34:24 <Athas> (Didn't some semi-recent release also tighten those up?)
13:34:35 <Gurkenglas> Why doesn't Yoneda have a Wrapped instance?
13:36:49 <crab1> I'm trying to get the Euterpea library working on OpenBSD, cabal install Euterpea works but when I try and run "play $ c 4 qn" in ghci I get "undefined symbol 'Pm_GetDefaultOutputDeviceID', any idea how I can fix this?
13:38:05 <Gurkenglas> @let import Data.Functor.Yoneda -- :(
13:38:06 <lambdabot>  .L.hs:97:1: error:
13:38:07 <lambdabot>      Data.Functor.Yoneda: Can't be safely imported!
13:38:09 <lambdabot>      The package (kan-extensions-5.2) the module resides in isn't trusted.
13:38:24 <EvanR> agreed
13:38:57 <Gurkenglas> The :(, or that it can't be trusted?
13:39:39 <EvanR> % import Data.Functor.Yoneda
13:39:40 <yahb> EvanR: 
13:39:47 <EvanR> well, that's not an error!
13:39:51 <Gurkenglas> nice
13:42:53 <Gurkenglas> % :t auf (iso _ _) :: Applicative f => LensLike (Curried (Yoneda f) (Yoneda f)) s t a b -> LensLike f s t a b -- y no response?
13:42:55 <yahb> Gurkenglas: 
13:45:08 * hackage buffet 0.2.0 - Assembles many Dockerfiles in one.  https://hackage.haskell.org/package/buffet-0.2.0 (evolutics)
13:46:58 <EvanR> % putStrLn "pong"
13:46:58 <yahb> EvanR: pong
13:52:19 <TheCommieDuck> if I have newtype Foo = Maybe Bar, how can I get around the compiler whining about expecting [Maybe a] and getting [Foo]?]
13:54:38 <Spock> TheCommieDuck: you've defined Foo as "a value containing a Bar, and the data constructor is Maybe"
13:54:50 <Spock> maybe you want newtype Foo = Foo (Maybe Bar)
13:54:53 <dminuoso> TheCommieDuck: You could use `coerce`, things like `ala` or wrap/unwrap.
13:54:58 <dminuoso> % :t coerce
13:54:58 <yahb> dminuoso: Coercible a b => a -> b
13:54:59 <dminuoso> % :t ala
13:54:59 <yahb> dminuoso: (Functor f, Rewrapped s t, Rewrapped t s) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
13:55:11 <TheCommieDuck> got it
13:55:19 <TheCommieDuck> yes I see now, my bad. Thanks!
14:12:42 <cheater> hi
14:13:21 <cheater> using hmatrix, is there a way to replace part of a matrix? e.g. i have a matrix that is 10x20, and i want to replace a part of it that starts at 7,4 with a matrix that is 2x3.
14:34:57 <d34df00d> Hi!
14:35:21 <d34df00d> How does mapConcurrently/forConcurrently behaves if the action that it executes doesn't consume a HEC? That is, say, it's just calling some system process.
14:35:50 <d34df00d> Will it run at most as many actions as there are CPU capabilities, or will it just happily go through the whole list?
14:39:33 <jle`> d34df00d: i believe it uses haskell's lightweight threads/sparks functionality underneath
14:42:04 <d34df00d> jle`: and what does that one do if it's blocked in FFI or something similar?
14:44:30 <EvanR> with -threaded FFI calls are done from a dedicated OS thread for that purpose
14:44:44 <EvanR> so as not to block the rest of the runtime
14:45:01 <d34df00d> Is it a dedicated thread per a Haskell application? Or, in other words, how many of those there are?
14:45:10 <EvanR> it's fluid
14:45:20 <d34df00d> Uh.
14:45:26 <EvanR> none of this is visible to the programmer
14:45:39 <d34df00d> So it can spawn more OS threads than I have cores?
14:46:30 <EvanR> you're supposed to think in terms of "capabilities", which are what can run a haskell thread
14:46:47 <EvanR> you probably shouldn't have more capabilities than cores
14:47:06 <EvanR> number of capabilities is configurable with -N
14:47:11 <d34df00d> In this case I care how much stress do I put on the system via the non-Haskell programs that I call as part of my Haskell stuff.
14:47:28 <EvanR> those programs might not even be using CPU
14:47:32 <d34df00d> Or, in other words, how long would it take to run `forConcurrently [0..99] $ \_ -> system "sleep 1"`? 100 seconds? 100 / <number of CPUs> seconds? 1 second? Something arbitrary in between?
14:47:36 <EvanR> i.e. waiting on I/O
14:47:41 <d34df00d> EvanR: suppose I know they do.
14:47:46 <boxscape> kind of weird that DataKinds doesn't allow you to use record syntax on the type level
14:47:57 <EvanR> if they are in another process it doesn't really have much to do with your program
14:48:09 <EvanR> the OS deals with all that
14:48:18 <d34df00d> Sure, but I'd like to control how many other processes do I spawn.
14:48:25 <d34df00d> (for a bunch of reasons)
14:49:02 <EvanR> ah
14:49:04 <d34df00d> So I wonder if it's tied to the capabilities count at least in some sense, or if I should resort to async-pool instead of async, say (which is painful for a couple of reasons, so I'd like to avoid that).
14:49:30 <EvanR> you can choose how to chunk your mapConcurrenties
14:49:38 <EvanR> -lies*
14:49:48 <d34df00d> So I sorta have to do this explicitly?
14:49:58 <d34df00d> No magic here for me :(
14:51:00 <EvanR> mapConcurrently uses race, which spawns 2 threads
14:51:10 <EvanR> it's not doing magic rate limiting or anything
14:51:34 <Axman6> you can add concurrentcy limintig using a QSem
14:51:34 <EvanR> all the actions are all running concurrently, like it says on the tin
14:52:42 <Axman6> I would guess that forConcurrently [0..99] $ \_ -> system "sleep 1" would take much closer to 1 second than 100
14:53:17 <EvanR> if you use -threaded 
14:56:41 <Axman6> even if you don't, threrads still work in apps with a single capability
14:58:16 <EvanR> though FFI calls will block the rest of the runtime
14:58:26 <EvanR> what it means for system i don't know
15:01:21 <boxscape> Does -XRebindableSyntax does anything to multiway if-expressions?
15:01:51 <jle`> multi-way if is desugared into case i believe, so it would probably work the same way it works on case
15:04:11 <boxscape> I see
15:04:18 <boxscape> thanks
15:04:22 <boxscape> it doesn't do anything with case
15:04:51 <d34df00d> Alright, I just switched to async-pool instead of async and it's good enough for my purposes.
15:05:16 <d34df00d> Passing TaskGroup through the monadic stack and doing some of the IO stuff in the stack turned out to be less problematic. Thanks!
15:11:19 <ggVGc> so, this is valid typescript: function getPrice(item, asString: boolean): number | string
15:11:32 <ggVGc> how could we immitate this in haskell?
15:11:38 * hackage ghcid 0.7.7 - GHCi based bare bones IDE  https://hackage.haskell.org/package/ghcid-0.7.7 (NeilMitchell)
15:11:51 <EvanR> which part
15:12:11 <EvanR> also what does asString: boolean mean
15:12:19 <ion> getPriceNumber :: Item -> Rational, getPriceString :: Item -> String
15:12:51 <EvanR> yes we obstensibly don't want to answer "do you want to immitate this in haskell":)
15:13:25 <ggVGc> that's not really the question
15:13:34 <EvanR> asString is the argument label?
15:13:44 <ggVGc> I think the typescript type system seems pretty interesting, in that it can even type that correctly?
15:14:04 <EvanR> "correct"...
15:14:34 <Axman6> getPrice :: ITem -> Bool -> Either Double Text no?
15:14:34 <ion> I mean, you can do the same thing in Haskell with Bool and Either but it just reduces the static guarantees you have.
15:15:33 <EvanR> if the result is a dynamic number or string, but you don't know which... but you should have because of the contract of getPrice... it seems less correct
15:15:42 <EvanR> rather, less typed after all
15:16:17 <ion> I assume the initial TypeScript code suffers from the exact same thing.
15:16:38 <WilliamHamilton> is there a way to modify the _keys_ of a Data.Map.Map using lens?
15:16:43 <ggVGc> well, that's not the same thing as it wouldn't let you write: let s :: String; s = getPrice(item, true)
15:17:18 <EvanR> let s :: Either String Int; getPrice(item, true)
15:17:21 <EvanR> s =
15:17:24 <ggVGc> EvanR: what interests me is that it gives you a row type (I guess?) based on a conditional
15:17:31 <ion> How do you convert a number | string into a string in TypeScript?
15:17:35 <EvanR> it's a 'union type'
15:17:45 <ggVGc> well, the whole interesting part is that TS allows you to do it without the introduction of a wrapping type
15:17:56 <ggVGc> and then statically type checks it
15:18:13 <EvanR> so it has an auto coercion?
15:18:13 <yushyin> it just doesn't show you on the surface, it still is a union type
15:18:15 <ggVGc> I dunno, maybe I'm stupid. But it seems kind of intersting to me
15:18:38 <EvanR> haskell does have ways of auto coercing
15:18:54 <EvanR> and auto converting, though we don't like auto converting
15:19:36 <d34df00d> Just do `(|) = Either` and now you can do `Int | String`
15:19:45 <EvanR> but auto coercing number|string to string does not seem sound
15:20:00 <ggVGc> for me the big difference is that if I call getPrice :: Item -> Boolean -> Either String Int with True, I will have to either handle the Either case which will never happen, or use a non-total function
15:20:04 <ggVGc> and TS sidesteps it
15:20:16 <EvanR> um you don't have to ?
15:20:17 <yushyin> https://www.typescriptlang.org/docs/handbook/advanced-types.html#union-types it _is_ just a union type.
15:20:17 <d34df00d> You need dependent types.
15:20:18 <EvanR> how
15:20:55 <EvanR> don't you still have to handle the failure of number|string -> string in TS?
15:21:26 <EvanR> (even if it's impossible because of a reason not in the type system)
15:21:34 <ggVGc> EvanR: afaik no
15:21:35 <ion> I entered this to the TypeScript playground: 'const a: number | string = "hello"; const b: number = a; console.log(b);' and ran it. It did not give type errors and output hello.
15:21:38 <ggVGc> that's why it's interesting
15:21:43 <EvanR> ggVGc: ... could you explain how that is possible
15:22:24 <ion> Is this how TS sidesteps the issue of converting number | string to a number or am I misunderstanding something about how typechecking works on the playground?
15:22:27 <yushyin> nothing prevents the function to emit a string even with asString := false, it is just programmed to do not so.
15:22:49 <EvanR> more importantly, how can you get away with treating a number|string as a string?
15:23:35 <matheus> does anyone know how I can parse "-Wl,--foo" style options with optparse-applicative?
15:24:48 <ggVGc> EvanR: huh... I guess I was wrong. I was sure my friend had showed me an example of this being the case.
15:24:53 <ggVGc> then it's no longer interesting...
15:25:02 <ggVGc> MY BAD
15:25:04 <ggVGc> :*
15:25:06 <ggVGc> :(
15:25:23 <EvanR> i'm sure there's something interesting buried somewhere around here related :)
15:25:34 <dmwit> matheus: `option foo (short 'W')` where `foo` is a custom-built ReadM parser?
15:26:06 <matheus> ahh, good thinking!
15:26:08 <EvanR> ion: i think maybe you didn't enabled the type system
15:26:26 <matheus> dmwit: i managed to completely gloss over ReadM in the docs
15:26:29 <yushyin> ggVGc: the typescript website gives an example where it says that it will fail at runtime if you treat it as the wrong type
15:26:37 <EvanR> gradual typing = type system off by default
15:27:42 <ggVGc> well, something made me believe TS had some form of dependent typing...
15:27:51 <ggVGc> but I think I have been mislead
15:28:01 <ggVGc> one day I will write some Idris for real
15:28:08 <yushyin> ^^
15:28:30 <matheus> typescript has like, a third of a dependent type system clumsily tacked on
15:28:49 <EvanR> key at least typescript will actually fail when the types are mismatched at runtime
15:29:00 <EvanR> unlike javascript
15:29:44 <yushyin> wow!
15:29:47 <EvanR> is there a technical word for a system that responds to nonsense by continuing on without error?
15:30:12 <ggVGc> software
15:30:37 <koz_> EvanR: Garbage?
15:30:54 <koz_> Web applications.
15:31:10 <ion> @let data SBool b where { SFalse :: SBool False; STrue :: SBool True }; type family PriceResult (b :: Bool) :: * where { PriceResult False = Rational; PriceResult True = String }; getPrice :: SBool b -> PriceResult b; getPrice SFalse = 42; getPrice STrue = "hello"
15:31:11 <lambdabot>  Defined.
15:31:14 <ion> > getPrice STrue
15:31:15 <lambdabot>  "hello"
15:31:34 <EvanR> we say "untyped" a lot, but pretty much all untyped languages at least crash sometimes
15:32:00 <EvanR> PHP kind of is the only example
15:32:14 <EvanR> white screen effect
15:34:19 <ggVGc> ion: cool, thanks. I was thinking we could do something like it with type families. But now I have realised TS can't even do what I thought... so, I guess +1 for haskell
15:35:04 <EvanR> > getPrice SFalse
15:35:06 <lambdabot>  42 % 1
15:35:17 <matheus> <EvanR> is there a technical word for a system that responds to nonsense by continuing on without error? ← Garbage-in-garbage-out?
15:35:22 <EvanR> ah
15:35:29 <matheus> and/or "HTML parsers"
15:35:37 <EvanR> yeah garbage in garbage out is a thing
15:51:50 <koz_> Is there a function like replicateM_ :: (Applicative m) => Int -> m a -> m ()?
15:51:59 <koz_> Or do I have to do something like void . replicateM
15:52:00 <koz_> ?
15:53:02 <nil> :t replicateM_
15:53:03 <MarcelineVQ> :t replicateM_
15:53:03 <lambdabot> Applicative m => Int -> m a -> m ()
15:53:04 <lambdabot> Applicative m => Int -> m a -> m ()
15:53:04 <MarcelineVQ> :>
15:53:07 <nil> :)
15:53:56 <nil> it's weird that deleteBy has type (a -> a -> Bool) -> a -> [a] -> [a] instead of (a -> Bool) -> [a] -> [a]
15:54:21 <nil> i'm trying to delete the first value in an association list associated with some key k
15:54:59 <nil> i guess i can do something like  deleteBy (\_ (k', _) -> k' == k) undefined l  but it's ugly
15:55:55 <xenon-> > deleteBy (==) 1 [1,2,3,4]
15:55:58 <lambdabot>  [2,3,4]
15:56:45 <nil> yes, it's useful in that case -- note that you could just as well do  deleteBy (== 1) [1..4]  if the function had my proposed type
15:57:02 <MarcelineVQ> you can just write delete if you're using Eq
15:57:07 <xenon-> I know. I'm not fan of the type either
15:57:28 <nil> oh well, i'll just use filter
15:57:29 <ammar2> :t filter
15:57:31 <lambdabot> (a -> Bool) -> [a] -> [a]
15:57:35 <nil> ammar2: :D
15:57:48 <xenon-> indeed =)
15:57:49 <nil> doesn't delete only the first one, but that doesn't really matter in my case
15:58:54 <xenon-> what's the rationale behind deleteBy's signature?
15:59:13 <EvanR> :t on
15:59:15 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
15:59:59 <ammar2> probably for consistency with all the *By functions?
16:00:00 <EvanR> ah well deleteBy is a totally different operation from filter
16:00:10 <EvanR> :t sortBy
16:00:11 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
16:00:19 <EvanR> :t maximumBy
16:00:21 <lambdabot> Foldable t => (a -> a -> Ordering) -> t a -> a
16:00:33 <ammar2> :t unionBy
16:00:34 <lambdabot> (a -> a -> Bool) -> [a] -> [a] -> [a]
16:00:37 <AWizzArd> Let’s say you wanted to implement some database, some B+ tree, doing lots of read/writes on SSDs. Is Haskell nearly as fast as C for such low-level operations?
16:00:54 <AWizzArd> Or would it make sense to write the core operations of such a system in C, and then do the higher-level work in Haskell?
16:01:00 <EvanR> deleteBy is comparing each element by some x you started with, unlike the other Bys and unlike filter
16:01:12 <EvanR> it's weird
16:01:31 <Axman6> AWizzArd: probably depends how low level you want to go - if you're working on the level of tiles then it's all the same syscalls
16:02:07 <AWizzArd> Axman6: what are „tiles” in this context?
16:02:14 <EvanR> pages?
16:02:52 <xenon-> > deleteBy ((==) `on` fst) (1,undefined) [(1,2),(3,4)]
16:02:54 <lambdabot>  [(3,4)]
16:03:18 <EvanR> deleteBy seems oddly specific
16:03:54 <Spock> :t deleteBy
16:03:56 <lambdabot> (a -> a -> Bool) -> a -> [a] -> [a]
16:04:12 <xenon-> > filter (==1) [(1,2),(1,3)]
16:04:14 <lambdabot>  error:
16:04:14 <lambdabot>      • No instance for (Num (Integer, Integer))
16:04:14 <lambdabot>          arising from a use of ‘e_111213’
16:04:37 <EvanR> filter ((==1) . fst)
16:04:37 <xenon-> > filter ((==1).fst) [(1,2),(1,3)]
16:04:39 <lambdabot>  [(1,2),(1,3)]
16:04:48 <xenon-> uh
16:04:55 <EvanR> haha
16:04:58 <Spock> :t delete
16:04:59 <xenon-> > filter ((/=1).fst) [(1,2),(1,3)]
16:05:00 <lambdabot> Eq a => a -> [a] -> [a]
16:05:01 <lambdabot>  []
16:05:19 <EvanR> who knows what filter means
16:05:30 <Spock> i think the logic is for it to line up with delete, regardless of if it makes sense overall after factoring out (==)
16:05:33 <xenon-> I usually do, deleteBy messed up my brain
16:05:57 <Axman6> I wish the names were keep and reject = keep . not
16:05:58 <xenon-> coffee filter lets through coffee
16:06:35 <EvanR> > mapMaybe ((\x -> if x == 1 then Just x else Nothing) . fst) [(1,2),(2,3),(1,3)]
16:06:37 <lambdabot>  [1,1]
16:06:45 <EvanR> heh
16:07:21 <EvanR> i will not be distracted *poof*
16:07:29 <Spock> i like perl's shameless name for filter
16:07:32 <Spock> it just calls it grep
16:10:28 <koz_> Spock: Might as well be honest...
16:12:20 <Spock> it makes it really easy to remember what the output will be :D
16:19:02 <EvanR> riddle me this
16:19:46 <EvanR> (Applicative f, Applicative g) => f (g (a -> b)) -> f (g a) -> f (g b)
16:20:40 <EvanR> what would djinn say
16:22:07 <EvanR> :t liftA2 liftA2
16:22:08 <lambdabot> (Applicative f1, Applicative f2) => f1 (a -> b -> c) -> f1 (f2 a) -> f1 (f2 b -> f2 c)
16:22:35 <EvanR> :t fmap (<*>)
16:22:37 <lambdabot> (Applicative f1, Functor f2) => f2 (f1 (a -> b)) -> f2 (f1 a -> f1 b)
16:23:28 <nshepperd> :t liftA2 . liftA2
16:23:30 <lambdabot> (Applicative f1, Applicative f2) => (a -> b -> c) -> f1 (f2 a) -> f1 (f2 b) -> f1 (f2 c)
16:23:47 <EvanR> :t fmap (<*>) . fmap (<*>)
16:23:48 <lambdabot> Functor f => f (a1 -> a2 -> b) -> f (((a1 -> a2) -> a1) -> (a1 -> a2) -> b)
16:24:01 <nshepperd> :t (liftA2 . liftA2) id
16:24:02 <lambdabot> (Applicative f1, Applicative f2) => f1 (f2 (b -> c)) -> f1 (f2 b) -> f1 (f2 c)
16:24:15 <EvanR> whooaaaaa
16:25:16 <EvanR> :t fmap ($) . fmap (<*>)
16:25:17 <lambdabot> (Applicative f1, Functor f2) => f2 (f1 (a -> b)) -> f2 (f1 a -> f1 b)
16:25:46 <EvanR> :t fmap fmap . fmap (<*>)
16:25:48 <lambdabot> (Applicative f1, Functor f2, Functor f3) => f2 (f1 (a -> b)) -> f2 (f3 (f1 a) -> f3 (f1 b))
16:25:54 <EvanR> ok i'm done
16:27:01 <nshepperd> :t fmap liftA2 liftA2 id
16:27:02 <ph88> how can i get debug symbols in my executable with stack ?
16:27:03 <lambdabot> (Applicative f1, Applicative f2) => f1 (f2 (b -> c)) -> f1 (f2 b) -> f1 (f2 c)
16:30:07 <svipal> yo
16:30:21 <koz_> svipal: Sup?
16:30:42 <svipal> just noticed my program, when run with --profile, is way slower, and wondering why
16:33:44 <svipal> Well, I was not even tracking a bug as the performance is really more than acceptable without --profile, just noticed it
16:33:59 <svipal> it does a lot of ffi calls, maybe that's why, I never noticed this behaviour before
16:35:39 * hackage hw-bits 0.7.0.9 - Bit manipulation  https://hackage.haskell.org/package/hw-bits-0.7.0.9 (haskellworks)
16:37:07 <svipal> what are the advantages of ^ over plain data.bits  ?
16:38:08 <koz_> svipal: Bunch of SIMDy stuff I think.
16:38:32 <TheCommieDuck> brainfart time: I'm parsing some stuff in applicative style with aeson. I want to basically parse in a value, but put it into a singleton list. I figure it's some variant of <*> ([] <$> (parseJSON (Object v))) <*>, but I can't quite work out what it needs. <*> [parseJSON (Object v)] <*>... gives a "expected [Foo], got [Parser a0]" which is the closest I've gotten
16:38:58 <svipal> mmhmmm
16:42:07 <nil> TheCommieDuck: how do you go from x to [x]?
16:42:35 <TheCommieDuck> I'd just put [ ] around it, though I suspect there's something to be done with cons as well.
16:42:44 <nil> what does [x] desugar to?
16:44:19 <nil> (in other words, how would you express [x] using only the list constructors?)
16:44:25 <TheCommieDuck> oh, right - (:) x [].
16:44:38 <nil> yes, x:[]
16:45:47 <TheCommieDuck> therefore, I need to put (:) into the applicative context in some form..? I think. 
16:45:59 <ph88> got it to work
16:46:11 <nil> do you know how to turn \x -> (x:[]) into a point-free expression?
16:46:41 <nil> or, do you know how to turn \x -> (x + 2) into a point-free expression?
16:46:52 <TheCommieDuck> thinking.
16:47:14 <nil> have you heard of sections?
16:47:45 <TheCommieDuck> Yes, in the algebra/function/category theory way. But I can't remember which is a section and which is a fiber.
16:49:11 <TheCommieDuck> I mean, my first go would be your latter example goes to (+) 2; but that's assuming associativity of addition.
16:49:17 <TheCommieDuck> or commutativity. one of them.
16:50:14 <alexfmpe[m]> `(+ 2)`
16:51:03 <alexfmpe[m]> :t (+ 2)
16:51:04 <lambdabot> Num a => a -> a
16:59:30 <nil> TheCommieDuck: sections in haskell are a syntax thing, nothing to do with algebra
16:59:47 <koz_> nil: Do you happen to have a friend named 'cons'?
16:59:54 <TheCommieDuck> oh, gotcha.
17:00:06 <nil> they allow you to conveniently apply a binary operator to only one of its arguments, so that (+ 2) is short for \x -> x + 2
17:00:24 <nil> and since (:) is just another binary operator, the function you're looking for is (:[])
17:02:43 <TheCommieDuck> aha; so (:[] <$> (parseJSON ...
17:04:27 <nil> (:[]) <$> ...
17:05:08 <TheCommieDuck> thank you kindly :)
17:05:34 <nil> you could also use pure, if the types are not ambiguous, since the Applicative instance for lists defines pure x as [x]
17:06:11 <TheCommieDuck> I fiddled with pure, but it was trying to use the list applicative instance rather than the json one. I think.
17:06:43 <d34df00d> What about introducing `singleton` into Prelude?
17:06:50 * d34df00d ducks and covers.
17:10:13 <jackdk> nah
17:10:39 * hackage hw-xml 0.4.0.5 - XML parser based on succinct data structures.  https://hackage.haskell.org/package/hw-xml-0.4.0.5 (haskellworks)
17:16:09 <rinx> python2 websploit.py
17:19:07 <Pamelloes> How does one go about optimizing a haskell program? I've profiled my program with +RTS -p, but I'm not quite sure where to go now.
17:21:57 <koz_> Pamelloes: That is such a general question, I'm not even sure where to begin.
17:22:07 <koz_> What are you finding inadequately optimal?
17:27:00 <Pamelloes> I'm note exactly sure. My program consists of running a function on loop, and right now it only completes around 3 times a second. I'd like to get that closer to 10.
17:27:15 <koz_> Pamelloes: What exactly are you running on loop?
17:27:19 <Pamelloes> I'm looking for some kind of a reference work for general principals
17:27:41 <Pamelloes> The program is a tetris AI, and so the function in the loop is the entire AI logic.
17:28:02 <koz_> Pamelloes: This is where I go back to this morning and tell you that brute force isn't a good idea, right?
17:28:19 <koz_> The problem here has nothing to do with code optimization and everything to do with not picking the right algorithm.
17:28:50 <noumenon> https://pastebin.com/raw/MQtM0Cn0
17:30:37 <maybefbi> noumenon: start with a 1 character string, then see what happens for a 2 character string. see if you can find a pattern
17:30:44 <Pamelloes> You're not wrong. However, I'm only looking 2 moves into the future---which works out to only around 1600 board positions.
17:31:09 <koz_> How do you represent board positions?
17:32:20 <Pamelloes> I represent a square as (data Square = Empty | Garbage | Remant Color | HurryUp), and the board via Vector Square
17:32:44 <koz_> And you're brute-force generating 1600 of these?
17:32:51 <koz_> How large is each Vector?
17:33:00 <koz_> Also, Colour is what?
17:34:30 <Pamelloes> Color is an ADT with 7 values for the 7 tetronimos. Each vector consists of 200 squares.
17:34:45 <Pamelloes> You can see my source code at https://github.com/jbrot/jstris-ai
17:34:53 <koz_> Well, one easy (conceptually if not work-wise) possible thing to try is unboxing those Vectors.
17:35:15 <koz_> Since you basically have a type whose cardinality is 10, you can pack each Square into a Word8.
17:35:27 * koz_ glances sideways at finitary-derive which does this for you.
17:35:50 <koz_> Then replace the Data.Vectors you're currently generating with Data.Vector.Unboxed Vectors, which might get you someplace.
17:36:04 <koz_> Another thing to consider is using alpha-beta pruning rather than a brute-force search.
17:36:12 <koz_> (that is conceptually _much_ harder)
17:36:36 <refusenick> How do I pull in an external dependency in Emacs' haskell-mode interactively ( without closing the project and GHCi process, editing project.cabal, and reopening the project)? Bonus points if I don't have to edit project.cabal directly. Using Cabal 3.0.0.0
17:37:35 <refusenick> for context, I'm running into this issue: https://github.com/haskell/haskell-mode/issues/1231
17:38:25 <Pamelloes> Very interesting. Currentlty, the number 2 cost center is Data.Vector.basicUnsafeIndexM, so that seems to suggest that switching to an unboxed vector would have large benefits, right?
17:39:43 <Pamelloes> Certainly changing the core algorithm could yield better results, but that's a task for another day :)
17:40:33 <koz_> Pamelloes: Yes, because you won't have to pointer chase constantly.
17:40:44 <koz_> Since boxed vectors are arrays of pointers to whatever-it-is-they're-storing.
17:41:10 <koz_> While unboxed vectors just hold the values directly.
17:41:31 <koz_> However, I _definitely_ recommend using finitary-derive to make this process less tedious.
17:41:36 <koz_> Writing Unbox instances by hand isn't fun.
17:42:10 <koz_> You can try, but it's a uniquely tedious chore.
17:42:37 <koz_> (if you wanna use finitary-derive, use PackInto)
17:42:58 <Pamelloes> I'll definitely look into finitary-derive :)
17:46:05 <refusenick> Do most people here use Emacs? It seems like Emacs is common among Haskell users (perhaps the 1st non-Lisp community I've seen where it's common).
17:46:30 <Axman6> VS Code here
17:47:07 <Axman6> I wouldn't have said there's any clear favourite editor - people choose editors, not editors for languages, unless they're forced to
17:47:17 <Cale> I've been using Sublime Text for the past year or so, before that I used vim mostly.
17:47:38 <refusenick> Axman6: Which makes it all the more surprising to me that so many Haskellers use Emacs.
17:47:55 <refusenick> It makes sense with Lisp, because all the tooling is built around Emacs (that's why I learned it).
17:47:56 <Cale> Yeah, for something like Agda, you're pretty much going to use Emacs because Agda-mode is almost necessary
17:47:57 <koz_> I'm on vim also.
17:48:09 <Axman6> maybe you're biased by only looking for things to do with Emacs and Haskell, and not paying attention to the tools for other editors ;)
17:48:17 <MarcelineVQ> atom has an agda-mode now  :>
17:48:28 <Cale> Oh? Nice!
17:49:01 <maybefbi> refusenick: I used to use Vim for 10+ years for Haskell. I think haskell users are more vim than emacs. but recently i switched to spacemacs. im a noob spacemacser
17:49:04 <refusenick> Axman6: It seems as if Emacs was the 1st editor with real Haskell tooling. I see a lot more tooling for other editors cropping up as Haskell becomes more mainstream.
17:50:07 <refusenick> maybefbi: If you want an Emacs workflow a bit closer to Vim, maybe check out Doom Emacs: https://github.com/hlissner/doom-emacs
17:50:37 <refusenick> I haven't tried it, but it coincidentially uses most of the same packages that I like
17:51:27 <Axman6> refusenick: FYI: https://taylor.fausak.me/2019/11/16/haskell-survey-results/#s3q1
17:51:34 <evelyn> maybefbi: there's not a lot of evidence other than "Vim has more users" in general
17:52:43 <Cale> A lot of the early tooling for Haskell in editors was clunky and often more of a hindrance than something you actually wanted running. The new HIE-based stuff looks cool though, but I've yet to really try it for real.
17:53:36 <evelyn> What does HIE stand for?
17:53:41 <Cale> Haskell IDE Engine
17:54:04 <refusenick> Cale: ghcide is actually the 1 part of Haskell tooling which I haven't had to finagle with (mostly because I did the finagling with generic LSP setup already) and works out of the box.
17:54:42 <refusenick> (ghcide being a stripped-down HIE)
17:55:41 <maybefbi> refusenick: thanks for the doom-emacs
17:57:51 <refusenick> evelyn: Vim having more users Emacs and IDEs having more users than either always skews these kinds of discussions. Perhaps a better phrasing of my original point is that Emacs is visible in the Haskell community. It's already seen as offbeat in C/C++ if you're not around the right people, and actively weird in webdev (not that I've done much, but I've seen how they react to seeing a Vim user).
17:58:15 <Cale> If you're working on large projects, it's worth figuring out some sort of jump-to-definition, for which I presently just use tags (hasktags), and probably syntax highlighting, though that's pretty standard. Apart from that, I tend to just run ghcid in a separate terminal window, and that gives me continuously updated errors/warnings.
17:58:39 <Cale> But yeah, I don't expect or ask much from my editor, so it doesn't really matter which editor I use all that much.
17:58:59 <Cale> The main thing is "can it convert tabs to spaces automatically?"
17:59:14 <Cale> Which pretty much every respectable editor can.
18:00:09 <parisienne> damn this channel is active :o
18:00:51 <Cale> It's been more active. We're a few hundred users short of where I remember us being a while back.
18:01:05 <refusenick> I should have asked my haskell-mode question then
18:02:49 <parisienne> I am usually in #clojure and similar channels. Absolutely nothing going on there :)
18:09:53 <parisienne> Cale: bouncer & Emacs updated to autojoin in here. :D
18:11:45 <Pamelloes> koz_: finitary-derive does not play nice with stack. Just managed to convince it a build plan exists, now to see if it actually works :)
18:11:54 <koz_> Pamelloes: Because it's not on stackage.
18:12:00 <koz_> s/stackage/Stackage/
18:25:33 <evelyn> it's looking for someone to adopt it and take care of it on Stackage
18:54:24 <maerwald> Cale: you don't use codex?
18:56:38 * hackage haskell-src-meta 0.8.5 - Parse source to template-haskell abstract syntax.  https://hackage.haskell.org/package/haskell-src-meta-0.8.5 (DanBurton)
19:14:21 * srid tried and failed spectacularly to get hie working with emacs on nixos, and went back to good ol' ghcid.
19:15:59 <maerwald> due to nixos or hie?
19:17:01 <srid> hie, i'd say. got all sorts of errors, including it trying to install Cabal 3 (when it is already installed in PATH)
19:17:09 <srid> (also, using nix-shell)
19:21:11 <maerwald> sounds like hie is still using cabal-helper
19:21:35 <maerwald> which tries to compile a cabal on the fly in some tmpdir and fails for 100 different reasons :)
19:22:14 <refusenick> srid: How do you pull a new module into a project from within Emacs' haskell-mode?
19:22:36 <srid> I use doom-emacs haskell layer, which has lsp support.
19:22:48 <refusenick> Does LSP handle that for you?
19:23:03 <refusenick> I have lsp-mode and ghcide installed, but I don't know the features too well
19:23:18 <srid> Can you clarify what you mean by 'pull a new module into a project'?
19:24:04 <refusenick> When I enter "import Reactive.Banana.GI.Gtk", I initially get a bunch of errors because it's not already in the cabal file
19:24:45 <refusenick> then I tried the same thing as this guy and got the same result:  https://github.com/haskell/haskell-mode/issues/1231
19:26:04 <refusenick> (entering it without having it in the cabal files means Flycheck errors, to be clear)
19:26:10 <srid> Well, I don't use any of those fancy IDE features. I have been using just `ghcid` (by side of my editor) so far. Today I thought I'd give HIE a try. But it is still not in good form.
19:26:13 <maralorn> So with ghcide in that moment one needs to a) add it in the cabal file b) (if necessary) download it via cabal c) restart ghcide.
19:26:44 <refusenick> maralorn: Is that how it's supposed to work?
19:26:50 <srid> I used to poke around with spacemacs and dante. It worked that day, and then soon started breaking down. My coworkers at that time were happy with just ghcid, so I followed suit.
19:27:53 <refusenick> I just have haskell-mode + lsp-haskell + flycheck (enabled globally), and the problem persists if I disable all the LSP stuff
19:28:16 <maralorn> refusenick: I don‘t know. It feels like c) is the only point which could be optimized away with proper tooling.
19:28:42 <refusenick> It took me some time to find it, but the Github issue means it's an issue with haskell-mode itself. Do others have a different way of importing things?
19:29:44 <jle`> rest in peace github
19:30:04 <jle`> or maybe not, depending on your opinions of them as an institution
19:30:19 <refusenick> jle`: Why do you say that? B/c they were brought by MS?
19:30:26 <refusenick> Do people refuse to use it because of that?
19:30:32 <jle`> oh no because they are offline
19:30:37 <refusenick> wat
19:30:39 <jle`> they are experiencing some downtime
19:30:47 <jle`> as of right now there is some partial service restored
19:31:22 <ammar2> getting some unicorns
19:31:26 <Axman6> yeah GH is nearly unusable ATM
19:31:35 <refusenick> My link still works. Anyone had similiar issues?
19:31:57 <jle`> there's an incident https://www.githubstatus.com/
19:32:00 <Axman6> https://www.githubstatus.com/incidents/4sh7f76nh5gq
19:32:21 <refusenick> I meant the Emacs issue
19:32:41 <maerwald> MS fired all the site reliability engineers?
19:33:03 <jle`> gotta cut that overhead
19:33:34 <jle`> refusenick: i was able to get to the link you posted
19:33:34 <refusenick> Should've taken the opportunity to rewrite it in Haskell.
19:33:52 <ammar2> their uhhh, language analyzer is in haskell
19:34:08 * hackage hw-xml 0.4.0.6 - XML parser based on succinct data structures.  https://hackage.haskell.org/package/hw-xml-0.4.0.6 (haskellworks)
19:34:14 <ammar2> https://github.com/github/semantic
19:34:21 <ammar2> (if only github was up so you could see it)
19:34:42 <refusenick> ammar2: Oh yeah, I'm not seeing it. Huh.
19:34:59 <refusenick> Too bad the part that needs to be reliable isn't in a reliable language.
19:35:47 <ammar2> I don't think writing your webapp in haskell is going to save you from your database dying
19:36:01 <refusenick> ammar2: Write the database in Haskell
19:36:07 <Axman6> unless your database is also written in haskell
19:36:23 <jle`> i like to imagine dramatic situations, but maybe it's some sort of ddos in protest
19:36:36 <ammar2> in protest of what?
19:36:50 <Axman6> 'MERICA
19:37:30 <jle`> the thing that some of the people near the top have recently stepped down in protest
19:37:32 <jle`> of
19:37:50 <jle`> but maybe we are moving into non-#haskell territory
19:38:09 <ammar2> https://github.com/github/semantic/blob/master/docs/why-haskell.md
19:38:19 <ammar2> seems to be loading for me again
19:39:19 <refusenick> Given that it's intermittently up and down like this without extraneous circumstances that we know of, the DDoS hypothesis seems reasonably sound.
19:39:52 <jle`> alternatively it could just be a single server (out of a distributed system) that someone spilled coffee on
19:40:40 <jle`> did i just reveal to all of #haskell that i have no idea how distributed systems work
19:40:51 <refusenick> :o
19:41:12 <ammar2> heh, if one server is all it takes then it's not a very good distributed system ^^
19:41:18 <refusenick> A supercomputer's a distributed system if you squint hard enough.
19:41:51 <refusenick> right?
19:42:06 <refusenick> I think I also just revealed that I know nothing about distributed systems.
19:42:50 <jle`> maybe coffee spilling happens often, but rarely do enough coffee spillings happen across different server centers at the same time to trigger a significant outage
19:42:58 <jle`> it's like a poisson process
19:44:13 <Pamelloes> koz_: How do you extract from PackWords?
19:45:10 <ammar2> jle`: I think instead of coffee, the usual scenario used is a bunch of monkeys getting into a data center randomly ripping apart cables and servers
19:45:21 <ammar2> https://en.wikipedia.org/wiki/Chaos_engineering
19:47:37 <Axman6> supercomputers are certainly distributed systems, though they tend to be connected by much higher bandwidth networks like infiniband, and in topologies like 4 dimensional hypercubes to maximum concurrent bandwidth
19:50:10 <Lycurgus> only by tedious and abnormal parsing of "distributed" which normally means across distinct sites as opposed to parallelism at one
19:51:27 <Lycurgus> but natural lang usages is seldom crisp and consistent
19:51:35 <Lycurgus> *usage
19:52:38 <refusenick> Lycurgus: To be fair, what genuine algorithmic innovations there are in modern "cloud" services versus mainframes and such are that one can treat a heterogenuous distributed network as if it were a single supercomputer.
19:52:49 <Lycurgus> and equivocation and contradiction in the use of terms is common
19:53:17 <Axman6> most supercomputers don't act any differently than a bunch of servers in the cloud really, the network is usually the major difference. they don't operate as a single machine (though usually have special capabilities to coordinate all the nodes, for things like reductions and large data transfers between nodes)
19:53:40 <refusenick> It almost seems as if supercomputation is more a strict subset of distributed systems, much as parallelism is to concurrency.
19:53:56 * Lycurgus is working on a concept to make it so, distinct from established cluster and grid stuff
19:53:56 <refusenick> supercomputing*
19:54:56 <refusenick> supercomputation sounds like super-recursion and hypercomputation
19:55:40 <refusenick> Lycurgus: Sounds interesting. Any links?
19:56:53 <Lycurgus> rufusenick, yes but not right now
20:10:23 <crab1> Hi
20:22:48 <koz_> Pamelloes: You just pattern match on Packed.
20:23:04 <koz_> Also, in your case, PackWords isn't what you want - PackInto Word8 is a much better plan.
20:41:39 * hackage net-mqtt 0.6.2.1 - An MQTT Protocol Implementation.  https://hackage.haskell.org/package/net-mqtt-0.6.2.1 (dustin)
20:43:13 <jle`> it's 2019 and we still don't have a typesafe printf on hackage
20:43:17 <jle`> just on a github gist :'(
20:43:33 <jle`> we just have nice typesafe formatter libraries which is ok i guess
20:46:38 <jle`> i guess th-printf it is
20:47:28 <maerwald> https://hackage.haskell.org/package/category-printf-0.1.1.0/docs/Control-Category-Printf.html ?
20:47:37 <maerwald> but it isn't same syntax
20:51:57 <jle`> yeah, i guess i classified that as a formatter library, but it's still kind of annoying to have to write open-close double quotes so many times
20:52:03 <jle`> that's the whole 'benefit' to printf imo
20:52:22 <jle`> "hello %s world" instead of "hello".str."world"
20:54:21 <Axman6> jle`: formatting works well
20:54:36 <jle`> formatting is a nice formatting library
20:54:43 <jle`> but it still has the same double-quotes-duplication problem
20:54:48 <Axman6> which also has the same problem
20:55:16 <Axman6> printf @"Hello %s, how are you?" would be nice
20:56:09 <jle`> yeah that is my ideal interface
20:56:14 <jle`> there's nothing stopping this from being possible
20:56:34 <jle`> at least that i know of
20:56:43 <Axman6> you can's easily break up Symbols
20:56:52 <jle`> indeed you cans
20:56:52 <Axman6> they aren't type level [Char]
20:57:02 <Axman6> well, you can, but it's gross
20:57:08 <jle`> they aren't, but we have the equivalent of T.uncons these days
20:57:42 <Axman6> Csongor Kiss' thing? or something less hacky?
20:58:33 <jle`> that and also the option of a typechecker plugin
20:59:46 <heatsink> This sounds like a job for TH. [printf|Hello %s, how are you?|]
21:00:28 <Axman6> https://kcsongor.github.io/symbol-parsing-haskell/
21:01:06 <jle`> heatsink: yeah, th-printf works, and it doesn't even require full TH, just QQ
21:01:13 <jle`> but for some reason it lags my ID a lot
21:01:17 <jle`> * IDE
21:02:22 <jle`> probably because it has to evaluate the TH in order to typecheck the code. but i wonder if a printf @"..." would be the same
21:10:20 <jackdk> I tend to use formatting for this sort of thing
21:21:08 <iqubic> I'm going to try and learn about folds and unfolds by writting a function of the form: "Int -> (a -> a) -> [a] -> [a]" twice once with a fold, and once with an unfold. The function will apply the function to the first N elements of the given list.
21:27:32 <nshepperd> jle`: hmm. class Printf (fmt :: Symbol) a where { printf :: a }? plus a type checker plugin to magic up instances of Printf?
21:28:10 <nshepperd> where's the gist? I'm curious now :)
21:31:55 <jle`> nshepperd: https://github.com/konn/ghc-typelits-symbols/blob/master/examples/printf.hs is the gist from three years ago, but apparently it doesn't compile if you enable optimizations
21:32:27 <jle`> but it might work in a more modern ghc
21:32:47 <jle`> the type checker plugin didn't magic up instances of printf, but rather provided the uncons type family i think
21:33:13 <nshepperd> ah yep, the SymbolView thing
21:44:37 <iqubic> Doesn't Prelude already have a Printf?
21:49:26 <dsal> iqubic: that sounds like of strange. I wouldn't think to write one function with a fold and again with an unfold.  They are opposites.
21:50:30 <EvanR> when the input is a list, you can implement your function with a fold. When the output is a list you can write it with an unfold (?)
21:51:18 <MarcelineVQ> your output from a fold can be a list, your input to unfold can be a list
21:51:24 <jle`> iqubic: i'm talking about a type-safe printf that won't fail at runtime
22:05:07 <iqubic> Oh. I see.
22:18:21 <EvanR> "an element of type f a where f is some functor"
22:18:49 <EvanR> that's too long, what's a better word
22:18:57 <iqubic> That's just: "Functor f => f a"
22:19:15 <EvanR> english though, imagine if this was a crosswords clue
22:19:49 <iqubic> Is it a crossword clue?
22:20:00 <iqubic> It seems like you are making a crossword.
22:20:14 <EvanR> no, so i can't tell you how many letters
22:20:28 <iqubic> Darn.
22:20:38 <iqubic> What is this description for?
22:20:50 <EvanR> "term in an F algebra" ? still pretty long
22:20:55 <MarcelineVQ> functorial value if you want to be just awful, just the worst
22:20:57 <EvanR> "F-term" ?
22:21:04 <jle`> i call it a fote
22:22:02 <iqubic> jle`: I just found your AoC library on Haskell. I will certainly be using that come December.
22:22:14 <iqubic> Thank you for creating that.
22:22:18 <EvanR> fote, are u srs
22:22:27 <iqubic> *hackage
22:22:36 <iqubic> not Haskell
22:23:03 <EvanR> MarcelineVQ: wouldn't "functor action" be worse?
22:23:58 <iqubic> Stop making my skin crawl with your terrible names.
22:24:28 <jle`> iqubic: hope you have fun ^^
22:24:35 <jle`> iqubic: also join us in ##adventofcode :) we have a freenode leaderboard
22:25:31 <iqubic> Is that specifically for Haskell users or is that for people using all coding languages?
22:25:41 <jle`> it's for everyone :)
22:25:45 <iqubic> Ah. Cool.
22:25:59 <iqubic> I'll be in ##adventofcode.
22:27:25 <iqubic> I think I just found a way to solve one of last year's part 1 with an apomorphism.
22:27:42 <iqubic> I haven't actually written the code, so I have no idea if it will work or not.
22:28:09 <EvanR> there should be a scoreboard for record number of *morphisms used
22:28:27 <iqubic> I would win that so hard.
22:28:40 <MarcelineVQ> I​ humbly suggest that the -> morphism score best.
22:29:04 <iqubic> That's just a function arrow.
22:29:37 <EvanR> underappreciated and underexploited worldwide
22:29:40 <MarcelineVQ> And earth is just a planet, but it's the most special one for various reasons.
22:29:40 <iqubic> Which is a morphism in the catagory of Hask. So it is a morphism
22:30:02 <EvanR> proof by definition
22:30:19 <iqubic> But it's not one of the special recursive morphism from the recursion-schemes library.
22:33:00 <EvanR> i buy catamorphisms and anamorphisms as special
22:33:35 <EvanR> but the others seems like pragmatisms
22:34:40 <EvanR> like animorphs and mightymorphs
22:34:41 <iqubic> I have used Paramorphism in a nice way to create a pretty-printer for a EDSL I created.
22:36:39 <iqubic> I mean, I also used Meijer's PP library. But the paramorphism was how I recursively printed everything.
22:37:25 <EvanR> man tagless final really sells the pretty printing
22:38:51 <iqubic> What is tagless final?
22:39:19 <EvanR> http://okmij.org/ftp/tagless-final/index.html
22:43:26 <jle`> iqubic: interestingly enough a lot of the puzzles end up being nice little self-contained examples of recursion schemes shining
22:43:40 <jle`> iqubic: see https://bartoszmilewski.com/2017/12/29/stalking-a-hylomorphism-in-the-wild/
22:44:32 <jle`> and i used hylomorphisms for a few puzzles last year too, namely day 13 and 15
22:49:28 <iqubic> I have read both of those.
22:49:48 <iqubic> I didn't complete any puzzles last year. I hope to do better this year.
22:50:45 <iqubic> There was also a domino puzzle that was solved with a hylomorphism.
22:51:04 <iqubic> Wait... I thought that link was something else.
22:51:34 <iqubic> https://bartoszmilewski.com/2018/12/20/open-season-on-hylomorphisms/
22:51:44 <iqubic> That's the other post I was thinking of.
22:52:13 <jle`> ah, that one is nice too
22:52:28 <jle`> i also had fun with day 5 by using a Free Group (the algebraic data structure)
22:52:56 <iqubic> What does that look like? Never heard of it.
22:53:19 <yushyin> jle`: I read that article, was very fun to read, thanks for that.
22:54:09 <jle`> yushyin: ah, thanks! :) glad it was fun to read, it was fun to write
22:54:13 <jle`> iqubic: have you heard of the free monoid
22:54:56 <iqubic> yeah. I have. That just another name for a list.
22:54:57 <jle`> er, pre-question: have you heard of monoids
22:55:04 <jle`> and follow-up question: have you heard of groups
22:55:04 <iqubic> I know what monoids are.
22:55:12 <iqubic> I don't know what a group is.
22:55:38 <iqubic> I assume the free group is like the free monad and the free monoid.
22:55:38 <jle`> Group is a subclass of Monoid, with the extra method invert :: m -> m
22:55:51 <jle`> and the law is invert x <> x = mempty
22:56:00 <iqubic> What is the free group?
22:56:04 <jle`> so for every item x, you can create another item 'invert x' that will create mempty
22:56:18 <jle`> for example we have instance Num a => Group (Sum a) where invert (Sum x) = Sum (negate x)
22:56:23 <iqubic> Sure.
22:56:27 <jle`> because negate x + x = 0
22:56:47 <iqubic> I see how that works.
22:56:48 <jle`> so the free monoid basically gives any type A a "free" instance of Monoid, implementing <>
22:56:50 <jle`> without any extra work
22:56:57 <jle`> or any more extra structure than necessary
22:56:59 <EvanR> > negate 1 :: Word8 --crossing fingers
22:57:02 <lambdabot>  255
22:57:04 <EvanR> nice
22:57:13 <jle`> so if i have a type `Foo` that isn't a Monoid, i can use `[Foo]`, which is a Monoid and so has <> that satisfies the laws
22:57:14 <EvanR> > 1 + 255 :: Word8
22:57:16 <lambdabot>  0
22:57:19 <jle`> sweet
22:57:24 <iqubic> Right. I claim that the free monad is list.
22:57:28 <iqubic> And that was true.
22:57:31 <jle`> *free monoid is a list, yeah
22:57:45 <jle`> so free group is similar, FreeGroup Foo is a Group that has <> and negate, that satisfies the laws
22:58:00 <jle`> just like FreeMonoid Foo is a Monoid that has <> and mempty, satisfying the laws
22:58:12 <jle`> so FreeGroup Foo has <>, mempty, and negate, without any extra work, and these methods satisfy the laws
22:58:17 <jle`> and that's "it"
22:58:27 <iqubic> What does the data structure look like?
22:58:39 <jle`> unfortunately unlike for free monoid, there isn't really an ADT representation of FreeGroup
22:58:50 <jle`> whereas there is a nice ADT rep of FreeMonoid and a nice ADT rep of FreeSemigroup
22:58:50 <EvanR> or perhaps like free monoid
22:59:01 <jle`> EvanR: ah yes, tricky tricky
22:59:15 <jle`> iqubic: so the best we can do in Haskell is with an abstract data type
22:59:19 <iqubic> So how did you use a free group then?
23:00:03 <jle`> https://blog.jle.im/entry/alchemical-groups.html :)
23:00:15 <jle`> ah looking at my logs i am kind of sad now that i only wrote four blog posts this entire year
23:00:30 <jle`> i guess it's not too late
23:00:37 <iqubic> You have time to write a fifth.
23:01:56 <jle`> in theory :)
23:01:57 <EvanR> quality over quantity jle` !
23:02:48 <iqubic> part 1 was really simple.
23:02:50 <koz_> jle`: I've written like, zero.
23:02:56 <iqubic> That seems almost too simple.
23:03:11 <jle`> iqubic: most of the 'imperative' solutions are pretty complicated
23:04:14 <iqubic> Yeah. My first thought was, iterate over the string, removing upper + lower pairs, again and again until the string remains the same after an iteration.
23:04:24 <EvanR> the moral of the story is, real world problems need to be refactored to be nicely solvable using algebra tricks
23:04:29 <iqubic> I'm not sure how your inject function works though.
23:04:50 <jle`> iqubic: it injects a character into a singleton in the free group
23:05:06 <EvanR> i don't want to hear about 'the only way is a wacky imperative spaghetti'
23:05:20 <jle`> all, a lot of the 'work' is admittedly hidden behind the free group library i used.  so a part of the benefits reaped is that we recognize it's a free group and know who already implemented it fo rus
23:05:28 <koz_> EvanR: Spaghetti is functional food - it is both extensible and compositional. :P
23:06:03 <jle`> iqubic: so it's basically like \c -> [c] , for free monoid.  except it's \c -> if isUpper c then [negate c] else [c]
23:06:10 <EvanR> now that's food for thought
23:06:23 <koz_> *ba-dum-psh*
23:06:25 <iqubic> Oh I see. That makes a ton of sense.
23:06:44 <iqubic> Most implementations might scan the list for things to replace, and iterate over things until there is no more change.
23:06:55 <iqubic> That's what I thought at first.
23:07:01 <EvanR> you know someone wrote a DFA or regex engine
23:07:01 <jle`> i should clarify that, yeah
23:07:33 <jle`> iqubic: yeah. that's what i would do at first too.  but recognizing it as a group action is the step to realizing that you can do this in one pass under-the-hood
23:07:47 <jle`> if you don't recognize that, you're going to have to justify to yourself why you only have to make one loop
23:07:53 <jle`> and it's not obvious
23:08:10 <iqubic> I have no idea what a group homorphism is.
23:08:30 <iqubic> Time to read the blog post.
23:08:37 <EvanR> an arrow in the category of groups
23:09:31 <jle`> reading this again i notice i use $ way too much
23:09:55 <iqubic> I love $.
23:10:00 <iqubic> I use it all the time.
23:10:15 <jle`> can be useful for writing code but bad for reading code
23:11:33 <iqubic> where did foldMapFree come from?
23:11:37 <jle`> and the other big advantage of this method is that we can recognize that "clean then react" is the same as "react and clean", because of group homomorphism properties
23:11:45 <jle`> iqubic: from the library i got the free group from
23:11:51 <jle`> it's basically foldMap but for general free structures
23:12:03 <jle`> so it works for lists too but it gives a monoid homomorphism
23:12:11 <jle`> and nonempty lists but gives a semigroup homomorphism blah blah
23:12:41 <jle`> idk i don't really see too much benefit in uniting them all under the same typeclass
23:12:45 <mycroftiv> something about this reminds me of codensity monad, is there a similarity
23:12:56 <jle`> i'd rather each free structure have its own folding function
23:13:04 <jle`> like how lists have foldMap and nonempty lists have foldMap1
23:13:50 <jle`> mycroftiv: on one level there is a similarity maybe -- you can think of it like using a continuation to defer the final evaluation
23:14:03 <jle`> but in the case of the code i don't actually defer the final evaluation, i just collapse things right away
23:14:21 <jle`> but the freedom to defer if we want to is a property of groups we can use, that codensity also exploits i think, in how it is used
23:14:41 <jle`> or maybe there is another thing you are seeing
23:14:46 <mycroftiv> jle' : i see, that makes sense, codensity optimizes operations on free monads in a way that sounds similar and also relates to continuations
23:15:43 <mycroftiv> the - "clean then react" is the same as "react and clean" - sounds similar to the symmetry principle that lets codensity work
23:16:23 <mycroftiv> i dont have too precise a handle on this, ive been chasing the type theoretic interpretation of large infinities in set theory and its dropped me into a bunch of category theory im pretty lost in
23:16:55 <jle`> mycroftiv: it's a property of 'linearity' sort of, not necessarily too deep into cat theo
23:17:04 <jle`> it's something studied in abstract algebra
23:17:22 <jle`> the idea that f(x+y) = f(x) + f(y)
23:17:26 <jle`> and f(0) = 0
23:17:32 <jle`> and f(-x) = -f(x)
23:17:49 <jle`> some people call it a 'distributive property'
23:18:20 <jle`> so the idea is that if we want to solve f(x+y+z), we have the option of computing x+y+z and applying f to it, or also computing f(x), f(y), and f(z), and then adding the results
23:18:21 <mycroftiv> yeah, ultimately almost everything has a translation into the topological properties of the stone spaces generated by boolean algebras and these are some of the conditions they have to encode
23:19:12 <iqubic> That group theory solution to the advent of code puzzle was awesome.
23:20:08 <iqubic> I came to Haskell from a Java background, so I often try to do things the 'imperative' way first, when I know that might not be the best way to handle something.
23:20:32 <iqubic> I find it hard to immediately see the clever FP way to do something.
23:20:33 <jle`> thanks :)  yeah, i do think it "sometimes" is the best way, but it's good to be able to branch out and explore different ways as well
23:23:16 <EvanR> well, jury is out of the clever OOP way to do things is immediately obvious
23:23:23 <EvanR> s/of/if/
23:23:52 <iqubic> It usually isn't
23:24:10 <iqubic> the clever way to do something is usually the harder method to find.
23:33:59 <jle`> ☻
23:34:40 <jle`> ah, in any case, i hope that the method here isn't really seen as 'clever'
23:34:51 <jle`> but with enough familiarity with known problems in mathematics, these associations become natural
23:35:25 <jle`> writing a clever solution isn't really the best, but writing a solution where guarantees of safety and properties are self-evident is the most important thing i think
23:37:08 <EvanR> yeah "clever" has developed a stigma 
23:37:17 <jle`> yeah, it has a weird sort of association for me
23:37:39 <dminuoso> It wasn't until hacking a bit on GHC that I appreciated simple code.. and bindings bindings bindings.
23:37:41 <jle`> i guess what i'm saying is that clever is not an ends in and of itself, so looking for a clever solution isn't necessarily something that should be enshrined
23:38:02 <jle`> cleverness can sometimes lead to "good" solutions, but the end goal is a "good" one, not a clever one
23:38:28 <EvanR> "clever" is considered bad in industry, but the logical reaction "dumb solution good" also doesn't work
23:39:05 <tsahyt> how about "maintainable solution good"
23:39:16 <jle`> yeah. maybe cleverness isn't good when it describes the code or the solution, but it can play a part in the journey to the solution
23:40:01 <jle`> cleverness isn't a good thing in and of itself, only in the case where it can arrive at a good solution, where good is context-dependent
23:40:10 <EvanR> "if it's dumb and it works, then it's not dumb" ... someone said. Still haven't unpacked that one
23:41:26 <mycroftiv> sometimes brute force can be elegance. when Ken Thompson realized that you could effectively bruteforce chess endgames 'from the other end' by looking at ending game states and working backwards, rather than strategizing forward from the current board state, it was a huge leap in computer skill
23:42:35 <Axman6> :o
23:43:08 <Axman6> aren't there an astronomical number of end game states though?
23:43:24 <EvanR> with the limited pieces on the board...
23:43:45 <jle`> we're in the endgame now
23:43:55 <mycroftiv> the number of possible board states with a small number pieces is much smaller computationally than the space of all possible moves of those pieces, so the insight is that the piece-oriented rather than move-oriented search ius computationally tractable
23:43:57 <maerwald> mycroftiv: elegance is is about intellectual satisfaction and not engineering precision or scientific proper
23:43:57 <jle`> so most of the pieces have been snapped away
23:43:57 <EvanR> 2 kings 1 rook 1 knight, etc
23:44:13 <maerwald> so it's quite a dangerous thing to subscribe to, imo
23:44:39 <siwica> I want to transform a function `[f :: a -> [b] -> c` to a function `g :: a -> b -> b -> ... -> b -> c` (variable number of arguments of type b). Is there an elegant way to do so? 
23:44:54 <jle`> interesting timing
23:45:06 <jle`> you just walked into a discussion where we were debating the value of elegance, heh
23:45:42 <siwica> Ok, maybe the question was phrased wrongly: I have a function g with the above type signature and want to pass the arguments as in f.
23:45:43 <jle`> siwica: there are some hacky ways to do it but none of them simple, and usually cannot justify their own weight
23:45:56 <jle`> the problem is that the type signature isn't very well-defined in haskell
23:46:08 <Axman6> do you have any particular reason for not wanting to pass arguments in a list?
23:46:23 <Axman6> :t printf
23:46:25 <lambdabot> PrintfType r => String -> r
23:46:36 <jle`> of the ways that do work for this, the type inference is going to be really weird, since ... not well-deifned types
23:46:42 <Axman6> :t printf "Hello"
23:46:44 <lambdabot> PrintfType r => r
23:46:47 <Axman6> :t printf "Hello" 1
23:46:49 <lambdabot> PrintfType t => t
23:46:50 <siwica> jle`: My concrete problem is with using printf (http://hackage.haskell.org/package/base-4.12.0.0/docs/Text-Printf.html). I want to pass the arguments as a list, since I have to do some transformation on them first.
23:46:52 <Axman6> :t printf "Hello" 1 True
23:46:54 <lambdabot> error:
23:46:54 <lambdabot>     • Could not deduce (PrintfArg Bool) arising from a use of ‘printf’
23:46:54 <lambdabot>       from the context: PrintfType t
23:47:18 <jle`> siwica: yeah, you're already in the territory of things that stretch the usefulness-to-complexity ratio to dangerous extremes
23:47:34 <jle`> the "haskelly" way would be to aggregate your b's into some aggregate value that f can use
23:47:35 * Axman6 agrees
23:48:04 <jle`> so instead of (((g x) b1) b2) b3, you'd do g x (b1 <> b2 <> b3), or some other sort of aggregation to give to g
23:48:14 <jle`> and that gives you exactly what 'f' originally is, essentially
23:48:15 <EvanR> printf is already stretching the sanity of idiomatic haskell
23:48:35 <EvanR> also wanting a dynamic arg list is crossing the line!
23:48:53 <EvanR> though it might be possible
23:48:56 <jle`> siwica: yeah, using a list with printf ... that's not going to be pretty, heh. printf's multi-arity trick is already a fragile house of cards
23:49:08 <jle`> it's possible but you're twisting an already bad fragile system to do even worse things
23:49:23 <dminuoso> And we all know how bad House of Cards gets, if you let it run its course.
23:49:30 <EvanR> lol
23:49:46 <siwica> Haha, ok :D
23:50:20 <jle`> this isn't something that you *need* per se, right?
23:50:26 <jle`> it's just something you hoped would make things more convenient
23:50:33 <jle`> syntactically
23:50:45 <siwica> jle`: Yeah, actually using printf with a list would be enough
23:51:02 <siwica> It's a concrete rather than an abstract problem
23:51:06 <dminuoso> It's curious how I haven't needed printf until now..
23:51:07 <jle`> so it sounds like your original question was looking for a general solution
23:51:12 <jle`> but this is more of a concrete one yeah
23:51:23 <EvanR> siwica: which type are you using printf to format
23:51:44 <siwica> Well, it's always interesting to solve the abstract problem first. But in this case it's not strictly necessary.
23:51:49 <jle`> you can probably get something nice to pass in a list of things to format, if you just use a well-made formatting system unlike printf
23:52:00 <siwica> EvanR: Strings
23:52:01 <jle`> there was just a discussion here a few hours ago about some of those
23:52:13 <EvanR> Strings...
23:52:31 <jle`> dminuoso: i just use it for things like "There are %d apples left in a the %s box, with weight %0.2f"
23:52:33 <EvanR> so columns and tables?
23:52:58 <Axman6> can you use printf to format the individual elements of the list and then combine the results?
23:53:02 <jle`> dminuoso: and the other day it actually bit me when a long-running process crashed suddenly because it ran into a statement that was not run until a ways in
23:53:04 <dminuoso> jle`: This sounds like a perfect job for a quasiquoter.
23:53:04 <siwica> EvanR: Yes, pretty much.
23:53:17 <EvanR> there's a few libs for laying out columns in tables
23:53:29 <jle`> dminuoso: yeah, i just spent a bit replacing it with QQs earlier today actually
23:53:36 <jle`> dminuoso: but i normally wouldn't reach for TH as a first thing
23:54:08 <jle`> my mind is somewhat at peace because QQs don't have the full power and so have much less issues than full on TH
23:54:11 <siwica> Axman6: The spacing between the individual elements is not always the same, so this approach would not work so well I think.
23:54:14 <EvanR> siwica: there's boxes...
23:54:25 <EvanR> https://hackage.haskell.org/package/boxes
23:54:25 <siwica> Ok, I'll check out boxes
23:56:53 <siwica> It would basically need to be able to: a.) define a width b.) left/right align strings c.) trim strings if they exceed width
23:59:20 <siwica> Thanks for now! :)
23:59:48 <EvanR> i think there was a newer one, though can't think of it at the moment
