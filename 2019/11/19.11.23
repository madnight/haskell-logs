00:06:06 <laudecay> it is unfortunate that i do crypto
00:06:19 <laudecay> i think i am almost at the point where i am the one who rolls the crypto and that is a lot of fear and pressure
00:14:41 <nil> i'm writing a simple emulator that needs to maintain a mutable "memory" array; should i rather use an immutable (unboxed) array in the State monad (and make sure it's modified in a strict way), or a mutable (unboxed) array in the IO monad?
00:15:19 <monochrom> Maybe ST is a middleground.
00:18:15 <nil> i don't really see the point of using ST instead of IO, given that i don't need to run "pure" computations
00:19:00 <iqubic> ST is weird. I've never really learned to properly harness it.
00:21:08 <iqubic> I know that ST is kinda like a continuation, but not much more than that.
00:21:30 <c_wraith> it's...  not much like a continuation at all
00:21:52 <c_wraith> ST just lets you use local mutability that's externally pure
00:22:45 <iqubic> Why would you want that?
00:24:02 <c_wraith> sometimes there's no known pure/lazy algorithm that matches the efficiency of algorithms that use mutability.  Fisher-Yates shuffling is one example.
00:24:58 <iqubic> I see.
00:25:47 <nil> what's an example of a pure function in the usual libraries implemented using ST?
00:25:56 <iqubic> Is that just doing a series of swaps between the elements of a list/array/vector/whatever?
00:26:11 <iqubic> Is that what Fisher-Yates Shuffling is?
00:26:27 <c_wraith> yes, so long as you obey the other requirement
00:26:47 <iqubic> Which is?
00:27:13 <c_wraith> you randomly select an element to put into each position from the unselected elements.
00:27:45 <c_wraith> That gives you a random distribution that's as good as the underlying RNG
00:28:22 <iqubic> Does ST give you access to functions in IO like mkStdGen?
00:28:29 <iqubic> :t mkStdGen
00:28:31 <lambdabot> Int -> StdGen
00:28:49 <c_wraith> :t newStdGen
00:28:51 <lambdabot> IO StdGen
00:28:55 <dsal> You can think of ST as being a place where mutable values are used to implement pure functions.
00:28:57 <c_wraith> that the one you're looking for?
00:29:14 <c_wraith> and no, creating the RNG in ST ruins purity
00:29:24 <c_wraith> it has to be passed in
00:29:38 * hackage neko-obfs 0.1.0.4 - a TCP tunnel with packet length obfuscation  https://hackage.haskell.org/package/neko-obfs-0.1.0.4 (JinjingWang)
00:30:12 <c_wraith> remember, the results of an ST calculation must be pure as far as the outside world can tell
00:30:50 <iqubic> c_wraith: I was actually looking for this function:
00:30:54 <iqubic> :t newStdGen
00:30:55 <lambdabot> IO StdGen
00:30:57 <c_wraith> (there are unsafe functions that let you violate that constraint, but...  well...  they're basically as bad as unsafePerformIO)
00:31:08 <iqubic> But running that in ST is bad. I see.
00:31:45 <nil> by the way, why don't we have  runState :: (forall s. State s a) -> a  ?
00:32:09 <c_wraith> because that wouldn't make any sense at all with the types of get and set
00:32:28 <nil> ah
00:32:31 <iqubic> :t get
00:32:33 <lambdabot> MonadState s m => m s
00:32:38 <iqubic> :t set
00:32:39 <lambdabot> ASetter s t a b -> b -> s -> t
00:32:41 <c_wraith> the s in ST s a is never actually instantiated to a concrete type
00:33:27 <nil> what if we don't use set or get? couldn't we just use State just like ST?
00:33:48 <nil> :t newSTRef
00:33:50 <lambdabot> a -> ST s (STRef s a)
00:34:03 <nil> newStateRef :: a -> State s (StateRef s a)
00:34:05 <c_wraith> State and ST really have nothing in common
00:34:13 <iqubic> The s is never instantiated to prevent the mutable state inside the ST monad from leaking out into the immutable outside world.
00:34:17 <c_wraith> like, every single thing is different
00:34:21 <nil> their definitions look very similar to me
00:34:21 <iqubic> Yeah.
00:34:31 <iqubic> State is pure, and ST isn't.
00:35:02 <nil> newtype ST s a = ST (State# s -> (# State# s, a #))
00:35:03 <c_wraith> State operates on a single value.  ST lets you create a whole arbitrary heap.
00:35:04 <dsal> iqubic: is State more pure than ST?
00:35:11 <nil> newtype State s a = State (s -> (s, a))
00:36:02 <nil> c_wraith: i understand that's how they are used, i'm only questioning whether State *could* be used like ST, if the ST functions were somehow translated to use State instead
00:36:21 <c_wraith> nil: you'd have to implement your own garbage collection.  Somehow.
00:36:50 <iqubic> dsal: Well, ST provides you a nice little sandbox for doing immutable things. State requires you to be pure 100% of the time.
00:37:26 <dsal> It kind of sounds like an implementation detail, though.
00:38:10 <c_wraith> ST is kind of a primitive in the RTS.  It does things you can't do without RTS support, like garbage collecting references that are no longer reachable.
00:38:55 <nil> ok.
00:39:37 <nshepperd> the definition of ST is as much a lie as the definition of IO
00:39:52 <c_wraith> in fact, the definition is identical to IO
00:39:54 <EvanR> weak refs can kind of let you do ST manually
00:39:59 <iqubic> IO has a definition?
00:40:01 <c_wraith> weak refs are still RTS support
00:40:11 <EvanR> yeah but different RTS support
00:40:42 <nshepperd> State# s isn't a state, it's just a hack to make the rts enter effectful functions in order
00:41:02 <EvanR> i get by with a little help from my RTS
00:41:08 <EvanR> actually, a lot
00:41:13 <c_wraith> iqubic: IO has a definition, but it's meaningless.  It just exists to make ghc compile it correctly, not to have a meaning.
00:41:46 <nil> nshepperd: i see
00:42:32 <nil> the way i understand it, ST s relies mostly a type system hack and doesn't ever actually use the type s
00:42:49 <c_wraith> It's not a hack.
00:43:13 <iqubic> And it does use the type s.
00:43:17 <iqubic> I think.
00:43:18 <EvanR> it's a higher polymorphic phantom type
00:43:32 <EvanR> we don't exploit these as much as we can
00:43:37 <c_wraith> I do. :P
00:43:43 <iqubic> Right.
00:43:58 <c_wraith> But then everyone else looks at my code and says "wtf, is that necessary?"
00:45:18 <iqubic> I don't understand the concept of a higher polymorphic phantom type.
00:45:26 <iqubic> What even is that?
00:46:05 <c_wraith> I mean, it's a phantom type that happens to be used in a higher-rank way
00:46:57 <EvanR> yeah, that
00:46:58 <nshepperd> the type s is a pretty clever trick
00:47:04 <iqubic> But is that needed?
00:47:33 <EvanR> it guarantees you can't smuggle references from one state thread to another where it would be invalid
00:47:40 <c_wraith> it is a clever way to make sure ST is safe
00:47:42 <nshepperd> it represents a 'state thread' which is like a sequenced collection of stateful actions
00:47:43 <c_wraith> https://www.microsoft.com/en-us/research/wp-content/uploads/1994/06/lazy-functional-state-threads.pdf
00:47:47 <dansho> is there a stringify for haskell?
00:47:55 <c_wraith> like all SPJ papers, it's quite readable
00:48:06 <ChaiTRex> dansho: What does stringify do?
00:48:30 <purelazy> dansho: Is "show" what you are looking for?
00:48:44 <dansho> https://gcc.gnu.org/onlinedocs/gcc-3.4.3/cpp/Stringification.html
00:49:01 <purelazy> > 2
00:49:03 <lambdabot>  2
00:49:11 <purelazy> > :t show
00:49:13 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
00:49:17 <c_wraith> dansho: um.  so do you mean in template haskell?
00:49:34 <purelazy> :t show
00:49:35 <lambdabot> Show a => a -> String
00:49:39 <dansho> c_wraith: i don't know
00:50:06 <nshepperd> each invocation of runST creates its own fresh s, which your ST action has to be 'in' (and all the ST actions in the stdlib only let you touch references from the same s thread you're in)
00:50:06 <dansho> show (2+2)
00:50:07 <purelazy> Converts things to a string
00:50:11 <dansho> > show (2+2)
00:50:13 <lambdabot>  "4"
00:50:14 <c_wraith> dansho: because that's a compile-time macro thing you linked to.
00:50:27 <dansho> should be "(2+2)" not "4"
00:50:43 <ChaiTRex> dansho: There's not really anything that will in general turn the unevaluated version of something into a String.
00:51:04 <EvanR> the ghci debugger will show unevaluated thunks
00:51:05 <c_wraith> I mean, if you're willing to use template haskell
00:51:17 <nshepperd> but! if your s is RealWorld, that means your action is in the global IO state thread (it's an IO action), and can only be run by wiring it with into main
00:51:35 <nshepperd> i find that pretty cool
00:51:54 <EvanR> really... and i thought RealWorld was deeply magical
00:52:05 <EvanR> it's just another state thread?
00:52:13 <iqubic> RealWorld *is* deeply magical.
00:52:53 <nshepperd> RealWorld is the name for the global state thread in which IO happens, i suppose
00:53:10 <dansho> just looking for a more convenient way of writing `printf "blah: %s" (show blah)`
00:53:48 <EvanR> % print ('b','l','a','h')
00:53:49 <yahb> EvanR: ('b','l','a','h')
00:54:06 <EvanR> @src print
00:54:07 <lambdabot> print x = putStrLn (show x)
00:54:42 <purelazy> > show "2+2 = " ++ show (2+2)
00:54:44 <lambdabot>  "\"2+2 = \"4"
00:55:02 <purelazy> > "2+2 = " ++ show (2+2)
00:55:04 <lambdabot>  "2+2 = 4"
00:55:46 <EvanR> template haskell could be used indeed to Debug.Trace.trace something and print out the variable or expression you wrapped
00:56:00 <EvanR> along with the value
00:58:02 <iqubic> Should I make a library for this?
00:58:12 <ChaiTRex> dansho: c_wraith mentioned the possibility of Template Haskell. There might be some way to use quasiquoting or something. https://wiki.haskell.org/Quasiquotation
00:58:13 <iqubic> or would it be a stupidly pointless thing to do?
00:58:15 <EvanR> probably exists
00:59:07 <purelazy> iqubic: I missed your question
00:59:45 <purelazy> (I just arrived)
01:01:41 <dansho> i tried learning template haskell once
01:02:19 <edwardk> dansho: if it helps i've learned it a dozen times, as it changes from ghc release to ghc release enough that i always have to go back to the docs
01:02:38 <iqubic> purelazy: You actually didn't miss any context.
01:02:56 <iqubic> TH seems like a big time suck.
01:03:08 <iqubic> Well, to learn it I mean.
01:04:00 <iqubic> I can only imagine the hell edwardk goes through to update the TH for Recursion-Schemes and Lenses after each GHC update rolls out.
01:04:57 <purelazy> iqubic: OK. It's outside my experience anyway.
01:06:12 <edwardk> iqubic: that mostly falls on glguy and ryanglscott these days, for which i'm incredibly grateful
01:06:42 <edwardk> glguy has a little th abstraction library we use that soaks up a fair bit of the burden
01:06:58 <iqubic> Oh. I thought you were the lead maintainter for those libraries.
01:07:04 <edwardk> i am
01:07:07 <edwardk> but they help out a TON
01:10:24 <c_wraith> dansho: https://paste.ubuntu.com/p/VqZp2w2Rsz/
01:11:13 <c_wraith> ChaiTRex: also, I guess that answers your comment
01:11:16 <iqubic> I have no idea how the recursion schemes library works on the inside, but I am eternally grateful that it exists. I've fixed so many bugs when rewritting code from explicit recursion to using a recursion scheme.
01:11:31 <dansho> c_wraith: thanks i will study this
01:12:07 <iqubic> I also recently found a problem where using a histomorphism was in fact the simplest way to solve it.
01:13:32 <c_wraith> there are probably ways to tweak the pretty printer so that its output is less ridiculous.  But that's an optimization. :)
01:17:20 <iqubic> edwardk: I just wanted to thank you so much for all the work you have put into creating the Recursion-Schemes library. I just recent found a use for a histomorphism.
01:17:38 <iqubic> And it was really cool to see it in action.
01:19:18 <edwardk> 'all the work i put in' consisted of doing a bender when it was all in category-extras, then a few years later spending an afternoon recoding it with some typeclasses to help, so it wasn't all that much work
01:19:40 <iqubic> Oh. I see.
01:20:07 <iqubic> But histomorphism are still pretty darn cool.
01:20:30 <edwardk> there was a little window where i sat there spackling over all the missing ones (.e.g. what is co-dyna?) and finding the distributive law encoding which held up pretty well til wu and hinze gave the adjoint story
01:20:39 <edwardk> yeah
01:20:55 <edwardk> i just find it somewhat sad how limited the fancier recursion schemes really are in practice
01:21:54 <iqubic> I still don't really understand why there is a Cofree constructor in the type.
01:22:03 <iqubic> histo :: Recursive t => (Base t (Cofree (Base t) a) -> a) -> t -> a
01:23:38 <iqubic> Because Cofree doesn't seem to have a base case. It seems to be an infinite loop.
01:24:27 <edwardk> nah, Base t might have a branch that doesn't mention 'a' for instance. consider [a]
01:24:32 <edwardk> [] exists as a branch
01:24:47 <edwardk> so Cofree [] a can have a :< []  -- as a perfectly cromulent base case
01:25:19 <iqubic> Oh. That's totally right. Thanks for dispelling the confusion.
01:25:29 <edwardk> Maybe is even clearer
01:25:34 <edwardk> a :< Nothing
01:25:45 <edwardk> Cofree Proxy = Identity
01:25:54 <iqubic> Correct.
01:26:13 <iqubic> I wasn't thinking about that properly. I feel silly.
01:26:44 <edwardk> also the function you give doesn't have to keep reaching off to infinity thrrough the input, its given one, but it might only introspect on the next level or two of the nested functorrs
01:27:24 <edwardk> so there are multiple aways around this sort of seeming paradox
01:28:24 <iqubic> Yes. I just wasn't thinking about it properly.
01:31:10 <iqubic> I've only just recently learned that the recursion-schemes library exists, but it has made my life so much easier.
01:33:03 <iqubic> I honestly wish that Prelude had more of these recursion schemes built into it.
01:34:09 <iqubic> I still don't understand corecursive unfolds, but now is not the time to learn about them. It's 1:30AM here in Seattle, Washington and I need to sleep.
01:37:38 <edwardk> later
02:46:59 <xenon-> can someone recommend a package for creating dynamic websites? I tried yesod, it was too complex for what I want to do, and relying so much on template haskell isn't my cup of tea. I need a very simple website, that will just display data from my database in mostly plain text
02:47:16 <xenon-> s/so much/too much/
02:49:49 <bahamas> xenon-: I've heard people talk about scotty and spock in that space
02:50:39 * hackage swagger2 2.5 - Swagger 2.0 data model  https://hackage.haskell.org/package/swagger2-2.5 (NickolayKudasov)
02:55:19 <kuribas> dminuoso: hi
02:55:36 <kuribas> dminuoso: I have been thinking about the problem of handle, catch, etc...
02:56:05 <kuribas> I came to a simple (but opiniated) conclusion: cleanup and acquire resource handlers should only run in IO.
02:56:41 <kuribas> And if you need an pure effect there, you are doing something wrong.
02:57:23 <xenon-> bahamas, thanks, I will check them out. is snap also worth taking a look?
02:58:14 <kuribas> dminuoso: that article you linked just jumps to the idea that they have to run in the monad stack, but it doesn't give a good reason to.
03:01:28 <bahamas> xenon-: I found this thread comparing them: https://www.reddit.com/r/haskell/comments/78k3af/servant_scotty_or_snap/
03:04:38 * hackage singular-factory 0.1 - Multivariate polynomial factorization via bindings to Singular-factory  https://hackage.haskell.org/package/singular-factory-0.1 (BalazsKomuves)
03:08:11 <kuribas> I'd advice against servant
03:08:17 <kuribas> servant is good for rest APIs
03:08:37 <kuribas> but it's overkill for a simple dynamic website
03:10:37 <kuribas> dminuoso: I also eliminated the type family, so you can (and should) use GenericNewtypeDeriving.
03:19:38 * hackage pandoc-crossref 0.3.5.0 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.3.5.0 (lierdakil)
03:26:36 <[exa]> xenon-: certainly go for scotty, it's extremely simple to get started and pretty extensible if the project grows
03:29:42 <mikail_> Hi, I am currently working on a open source project where given a description of a micro-service via it's type signatures the tool will produce JSON/YAML AsynApi documentation which describes that service. I'm bit of noob to this type of programming and I am researching what is the best approach to this. First hurdle for me is how to programmatically read a type signature and translate that to data structures which adhere to the 
03:29:42 <mikail_> AsyncApi specification. 
03:33:55 <[exa]> mikail_: you will very probably just want to look at how servant works, or perhaps read some papers about that
03:34:50 <[exa]> mikail_: e.g. this one https://alpmestan.com/servant/servant-wgp.pdf
03:35:33 <mikail_> thanks exa
03:37:57 <mikail_> exactly what I needed
03:38:15 <mikail_> it will be a very good starting point
03:38:42 <[exa]> mikail_: it starts a bit from the middle, but sections 3,4 contain the necessary details (e.g. how to get the strings from the type description etc.)
03:45:30 <kuribas> mikail_: seems you want generics or template haskell
03:46:00 <mikail_> section 2.2 is key for me
03:46:14 <mikail_> this paper is definitely a very good starting point
03:46:32 <mikail_> kuribas, the implementation has to be in Scala
03:46:50 <mikail_> some of the Haskell machinery may not translate well
03:47:08 <kuribas> mikail_: but the type is in haskell?
03:47:43 <mikail_> the project is in its infancy at the moment - however, the implementation of the client and server will be in Scala
03:48:07 <kuribas> mikail_: wrong channel then?
03:48:15 <mikail_> no not really
03:48:29 <mikail_> i'm researching how others have approached it
03:48:37 <muesli4> Hi, what's the best type to use as an intermediate string? bytestring-builder? I need to concatenate single characters and strings and they will most likely be written to stdout.
03:48:38 <mikail_> and take ideas
03:48:39 <kuribas> scala is a whole different language than haskell
03:49:05 <kuribas> muesli4: reverse them?
03:49:06 <mikail_> kuribas, yes, fully appreciate that but it's more the ideas on the high level approach
03:49:36 <kuribas> muesli4: if they are unicode characters, then Text-builder would be my choice
03:52:15 <muesli4> kuribas: They are unicode. But why does it matter? After all, I'm just concatenating.
03:53:07 <kuribas> muesli4: Text is for unicode.  
03:53:44 <muesli4> kuribas: I know but all I need to do is output it. I don't really care whether the result can be converted to Text
03:54:55 <kuribas> muesli4: if you output to stdout, then you do care if it is text or byestring
03:55:02 <kuribas> you should write a bytestring to stdout.
03:55:25 <kuribas> well, depends if it goes to a file, or it has to be read by people.
03:55:37 <muesli4> kuribas: Why?
03:56:07 <kuribas> muesli4: perhaps you should give some context about where you are outputting?
03:57:20 <muesli4> kuribas: It could actually go to a file as well.
03:57:39 <kuribas> muesli4: If you want to output text to a terminal, then use Text.
03:57:44 <kuribas> or String
03:58:00 <muesli4> kuribas: What's the issue with bytestring?
03:58:17 <kuribas> muesli4: because bytestring is for binary data, it has no notion of character encoding or Text.
03:58:32 <muesli4> kuribas: Still, how does it matter? ;)
03:59:19 <kuribas> because sending random bytes to standard output doesn't give well defined results.
04:00:44 <muesli4> kuribas: But as long as it is encoded as UTF-8 it shouldn't be a problem, right?
04:01:27 <kuribas> muesli4: I don't think so
04:03:49 <kuribas> it may be a bit faster, if you don't need to do anything with the characters in between.
04:04:26 <kuribas> but if you need to do any processing in between, then I'd use Text.
04:06:01 <kuribas> muesli4: may I ask what you are doing, if you are processing individual characters?
04:07:09 <muesli4> kuribas: It's literally just concatenating characters and strings for formatting grids / tables.
04:07:29 <kuribas> html?
04:07:43 <muesli4> kuribas: Plain text
04:07:49 <kuribas> okay
04:09:31 <xenon-> bahamas, [exa], like scotty so far. thanks
04:10:52 <muesli4> kuribas: I'm not even sure whether that's a reason to not use String. Because previously I used String for everything and it just worked fine. But now I was modifying the input types that you could use different text types. I created a typeclass for that that requires Semigroup. But I could also completely drop the Semigroup and use a builder or create a class for the builder to be used.
04:12:33 <kuribas> muesli4: you need to use a builder if you are repeatedly appending.
04:12:50 <kuribas> because that has bad complexity
04:13:30 <kuribas> muesli4: if you append everything in one go (from right to left), you don't need a builder
04:14:07 <kuribas> String is often good enough, but it very space inefficient.
04:14:30 <kuribas> Text and bytestring use chunks, so they are more compact and have better cache locality
04:14:49 <muesli4> kuribas: Yeah, which is exactly what I did. So I am looking for a sensible solution that doesn't restrict the user of the library.
04:15:16 <kuribas> did what?
04:15:26 <kuribas> append repeatedly?
04:15:40 <muesli4> kuribas: The worst case: Append left to right.
04:17:15 <kuribas> also, if you are formatting, you'd care about the length of characters, in which case bytestring will not work...
04:18:42 <muesli4> kuribas: Oh, so that's why Data.Text.length is O(n).
04:18:49 <kuribas> yeah :)
04:19:12 <xenon-> huh, it is O(n)?
04:20:29 <kuribas> I wonder if Text stores UTF8 internally
04:20:44 <kuribas> http://hackage.haskell.org/package/text-1.2.4.0/docs/Data-Text.html#v:length
04:21:36 <muesli4> kuribas: Could also be another encoding but none that guarantees that one character is one "element".
04:21:46 <kuribas> indeed
04:22:06 <ChaiTRex> Text's docs say it uses UTF-16 and they're thinking about maybe switching to UTF-8.
04:22:47 <ChaiTRex> From http://hackage.haskell.org/package/text
04:28:45 <[itchyjunk]> There is no difference between  (^) (^^) and (**) right?
04:28:53 <[itchyjunk]> :s
04:29:06 <[itchyjunk]> ah nm, googled
04:29:09 <ChaiTRex> :t ((^), (^^), (**))
04:29:10 <lambdabot> (Integral b1, Integral b2, Floating a1, Fractional a2, Num a3) => (a3 -> b1 -> a3, a2 -> b2 -> a2, a1 -> a1 -> a1)
04:29:11 <[itchyjunk]> says they are different :<
04:29:27 <lavalike> > 2^(-1)
04:29:29 <lambdabot>  *Exception: Negative exponent
04:29:48 <lavalike> > 2^^(-1)
04:29:50 <lambdabot>  0.5
04:30:02 <lavalike> > 2**(0.5)
04:30:04 <lambdabot>  1.4142135623730951
04:30:05 <[itchyjunk]> hmm
04:30:31 <[itchyjunk]> so if i want an integer back, i want ^. i think i understand. thanks
04:31:14 <lavalike> I'd say it's mostly about the domain not the codomain
04:31:24 <[itchyjunk]> hmm
04:31:26 <ChaiTRex> [itchyjunk]:  No, ^ just means you have a natural number exponent.
04:31:41 <ChaiTRex> [itchyjunk]: You can use it with a nonintegral base to get a nonintegral result.
04:31:50 <[itchyjunk]> oh so (.1)^(2) is valid?
04:31:55 <xenon-> :t (^)
04:31:56 <[itchyjunk]> ah gotcha
04:31:57 <lambdabot> (Integral b, Num a) => a -> b -> a
04:31:57 <lavalike> > 1.5^3
04:31:58 <lambdabot>  3.375
04:32:09 <xenon-> :t (^^)
04:32:10 <lambdabot> (Fractional a, Integral b) => a -> b -> a
04:32:21 <muesli4> kuribas: So now I cam up with the following https://gist.github.com/muesli4/694e87b241dac6553b487aebfac4561e . Could this hinder some of the rule optimization?
04:32:24 <xenon-> :t (**)
04:32:25 <lambdabot> Floating a => a -> a -> a
04:33:40 <ChaiTRex> [itchyjunk]: I think ^^ expands it from a natural exponent to an integral exponent. And ** expands it further to a Floating exponent.
04:33:50 <xenon-> not sure why we need both ^ and ^^?
04:33:53 <kuribas> muesli4: Text has dropEnd, which is likely more efficient.
04:33:58 <ChaiTRex> xenon-: Negative exponents.
04:34:07 <ChaiTRex> > 2^(-1)
04:34:10 <lambdabot>  *Exception: Negative exponent
04:34:12 <ChaiTRex> > 2^^(-1)
04:34:14 <lambdabot>  0.5
04:34:24 <muesli4> kuribas: Yes, I actually have an instance already. :)
04:34:48 <[itchyjunk]> ahh i see
04:34:55 <kuribas> looks fine to me
04:34:58 <xenon-> ChaiTRex, and why do we need a version where negative exponent throws an exception?
04:35:27 <Kristjan1291983> Hello guys !!!!!! My programming company(located in Viljandi, Estonia) is looking for clients. Webpage: supersoft . likesyou . org/en/index.php 
04:35:40 <[itchyjunk]> now for a silly question, i wanted to pass 2 values "a" and "p" to my function. :s
04:35:48 <ChaiTRex> xenon-: Because we may want to have an integral base and result.
04:35:57 <ChaiTRex> xenon-: With a negative exponent, we can't really have that.
04:36:07 <xenon-> oh I see
04:36:08 <lavalike> > exp 1 ** (((-pi) :+ 0) * (0 :+ 1)) :: Complex Double
04:36:10 <lambdabot>  (-1.0) :+ (-1.2246467991473532e-16)
04:47:05 <kuribas> what does monadplus for IO do?
04:47:28 <[itchyjunk]> I am getting a ambiguous type variable 'a0' error :'( essendre a p = (a ^ ((p-1)/2)) `mod` p 
04:48:01 <kuribas> [itchyjunk]: ghc doesn't know which type you want there
04:48:19 <[itchyjunk]> for the output? so i tell it to output an int?
04:48:42 <kuribas> yes
04:49:14 <nil> this isn't really important, but is there any sort of logic to how GHC chooses type variable names?
04:49:21 <[itchyjunk]> can i tell it the (a^((p-1)/2)) should be int somehow?
04:49:24 <nil> i was looking at `(Integral b1, Integral b2, Floating a1, Fractional a2, Num a3) => (a3 -> b1 -> a3, a2 -> b2 -> a2, a1 -> a1 -> a1)` above and it seems pretty random
04:49:40 <lavalike> kuribas: https://github.com/ghc/ghc/blob/dab12c/libraries/base/GHC/IO.hs#L198-L202
04:49:46 <[itchyjunk]> it should be int `mod` int
04:51:57 <ChaiTRex> nil: It's easier to read if you do each separately.
04:52:01 <ChaiTRex> :t (^)
04:52:02 <lambdabot> (Integral b, Num a) => a -> b -> a
04:52:08 <ChaiTRex> :t (^^)
04:52:09 <lambdabot> (Fractional a, Integral b) => a -> b -> a
04:52:11 <ChaiTRex> :t (**)
04:52:13 <lambdabot> Floating a => a -> a -> a
04:52:24 <kuribas> lavalike: only IOError, strange...
04:53:17 <[itchyjunk]> hmm i am unsure how to fix my error
04:54:23 <muesli4> kuribas: It seems that it will get the result of the first non-throwing IO action: mzero `mplus` print 2
04:54:38 <kuribas> throwing IOError
04:54:46 <kuribas> it doesn't seem to catch other exceptions
04:54:57 <kuribas> > undefined <> putStrLn "hello"
04:54:58 <muesli4> kuribas: Oh, now I understand your comment. Haha.
04:54:59 <lambdabot>  <IO ()>
04:56:40 <[itchyjunk]> ugh, i added :: Int in my function def and now it's freaking out about more things
04:58:49 <[itchyjunk]> https://bpaste.net/show/6KEAA
04:59:04 <[itchyjunk]> I added a type annotation and its now giving me this error
04:59:25 <xenon-> :t (/)
04:59:27 <lambdabot> Fractional a => a -> a -> a
04:59:52 <xenon-> > 1 / 2 :: Int
04:59:54 <lambdabot>  error:
04:59:54 <lambdabot>      • No instance for (Fractional Int) arising from a use of ‘/’
04:59:55 <lambdabot>      • In the expression: 1 / 2 :: Int
04:59:56 <Rembane> :t fromIntegral 
04:59:57 <lambdabot> (Integral a, Num b) => a -> b
05:00:11 <Rembane> > on (/) fromIntegral 
05:00:12 <xenon-> either that, or div instead of /, depending on desired behavior
05:00:13 <lambdabot>  <Integer -> Integer -> Double>
05:00:14 <[itchyjunk]> but 4/2 can be an int :x
05:00:25 <Rembane> [itchyjunk]: In ghci? 
05:00:31 <[itchyjunk]> no in math
05:00:41 <Rembane> That's true 
05:00:46 <Rembane> > div 4 2 
05:00:48 <lambdabot>  2
05:01:05 <[itchyjunk]> so i should use div instead of / ?
05:01:20 <xenon-> what result do you expect when diving 4 and 3?
05:01:53 <ChaiTRex> [itchyjunk]: If you want floored division, let's see, it's either quot or div.
05:01:53 <[itchyjunk]> in my case, that will never happen
05:02:04 <[itchyjunk]> hmm let me try div
05:02:05 <ChaiTRex> > -5 `div` 4
05:02:07 <lambdabot>  -1
05:02:13 <ChaiTRex> > -5 `quot` 4
05:02:15 <lambdabot>  -1
05:02:44 <[itchyjunk]> i thought / and div were the same thing :s
05:02:58 <[itchyjunk]> ah div is that other function like mod
05:02:59 <Rembane> [itchyjunk]: They aren't / works on floating numbers and div works on divs
05:03:01 <xenon-> :t div
05:03:03 <lambdabot> Integral a => a -> a -> a
05:03:05 <xenon-> :t (/)
05:03:06 <lambdabot> Fractional a => a -> a -> a
05:03:19 <[itchyjunk]> Rembane, div works on divs?
05:03:44 <Rembane> [itchyjunk]: What? 
05:03:51 <Rembane> [itchyjunk]: integers! 
05:04:27 <[itchyjunk]> i feel like it will take me some time to get comfertable with all the types and such
05:05:09 <Rembane> It does 
05:06:25 <aveltras> how can i workaround error like "solveWanteds: too many iterations" ?
05:09:27 <[itchyjunk]> ah i wish my code did one more thing.. not sure if its worth poking it or doing the last step manually
05:13:20 <[itchyjunk]> hmmmmm
05:13:45 <[itchyjunk]> if the output is not 1 , i wanna substract p from it..
05:14:52 <[itchyjunk]> the examples i am looking at are testing the input values hmm :s
05:15:41 <Rembane> Add more functions! 
05:18:46 <[itchyjunk]> :O
05:18:53 <[itchyjunk]> adding another function was easier
05:19:15 <[itchyjunk]> but my code because way ugle because i am computing entire thing for each of the "if else" thing
05:19:26 <[itchyjunk]> instead of comupting once, storing and checking that vlaue
05:19:52 <[itchyjunk]> https://bpaste.net/show/PGEA4 but i am happy enough
05:22:41 <Rembane> [itchyjunk]: Do you know about the where and let constructs? 
05:23:08 <[itchyjunk]> no i don't :s if and else is the only one i've dabbled with 
05:23:12 <Rembane> There's another fun way... let me see...
05:23:15 <[itchyjunk]> oh i know let
05:24:22 <Rembane> [itchyjunk]: https://bpaste.net/show/FBIOO
05:24:30 <Rembane> [itchyjunk]: Is the fun way 
05:25:37 <[itchyjunk]> hmm what is v?
05:25:46 <[itchyjunk]> i mean it looks like the value but how did it know ?
05:26:53 <xenon-> are you familiar with pattern matching? 1 ->   will match if result in case /* of this */ of   is 1. v will match any value (and since it is below 1, any value that is not 1)
05:27:07 <Rembane> [itchyjunk]: It is the value. 
05:27:22 <[itchyjunk]> ah
05:27:34 <[itchyjunk]> i think i understand
05:27:37 <ChaiTRex> [itchyjunk]: It's like pattern matching in a function definition. f 1 = 1; f v = v + 5
05:27:37 <[itchyjunk]> thats neat
05:28:08 <xenon-> v is just a variable name
05:47:59 <kuribas> merijn, dminuoso: here is my own library to unwrap transformers into IO: https://github.com/kuribas/unwrapio/blob/master/src/Control/Monad/IO/Unwrap.hs
05:48:56 <kuribas> there is no type family, so it works with generalisednewtypederiving.
05:49:16 <kuribas> and unlike unliftIO also with StateT and ExceptT
05:49:50 <kuribas> merijn: for example, here are the unwrapped versions of Control.Exception: https://github.com/kuribas/unwrapio/blob/master/src/UnwrapIO/Exception.hs
05:51:14 <kuribas> merijn, dminuoso: it should be easier to use than monadbasecontrol, you usually only need to call unwrapCallback :: UnwrapIO m => ((a -> IO (m b)) -> IO (m b)) -> (a -> m b) -> m b
05:55:36 <Inari-> Hi there. Relatively new to Haskell still, and trying to use this HIP library to do image creating/processing stuff. I installed it and such, and now am trying some example code they give (though it looks like they migth run that in the REPL). But it errors for me and I have no idea what to do about it... https://gist.github.com/Inari-Whitebear/55a8fe46663217836da72e461727153a
06:00:48 <ChaiTRex> Inari-: Not sure. My best guess is maybe the division should be inside that lambda?
06:01:23 <ChaiTRex> Inari-: Do you want to calculate fromIntegral (i*j)/(200*200)?
06:01:58 <ChaiTRex> Inari-: Or does makeImageR return something that can be divided by a number?
06:02:28 <Inari-> Uhh, I believe the former, but it seemed to error even if I put extra parentheses around it, so I figured that isn't the issue
06:02:52 <ChaiTRex> Inari-: Oh, OK. You need to move the / (200*200) inside the parentheses.
06:03:03 <kuribas> Inari-: ambiguous type variable means you need to give more information about the types.
06:03:24 <ChaiTRex> Inari-: ... $ fromIntegral (i*j) / (200*200))
06:03:36 <ChaiTRex> Inari-: End should look something like that, I think.
06:04:19 <kuribas> Inari-: just adding a type signature to grad_gray may be enough
06:04:28 <Inari-> :/
06:04:36 <Inari-> Thing is, I have no clue on the types :D
06:05:04 <Inari-> litereally just copied it from http://hackage.haskell.org/package/hip-1.5.3.0/docs/Graphics-Image.html#v:makeImageR
06:05:49 <kuribas> Inari-: also, it seems like you are dividing the result of makeImageR
06:06:12 <ChaiTRex> Inari-: Ahh, yes. See the line above that, which is equivalent.
06:06:25 <ChaiTRex> Inari-: The / is inside the lambda parentheses there.
06:06:35 <kuribas> Inari-: applicationg binds more strongly than operators
06:06:35 <ChaiTRex> Inari-: The second line you copied has an error.
06:06:53 <Inari-> I see
06:07:14 <ChaiTRex> Inari-: It's basic algebra a/b * c/d = (a*c)/(b*d)
06:07:27 <Inari-> Still seems to have the same error with the other line though :D
06:07:28 <ChaiTRex> Inari-: The first line has the left form. The second line should have the right form.
06:07:41 <Inari-> Hmm
06:09:25 <ChaiTRex> Inari-: OK, for that, you can put something like ... $ fromIntegral (i*j) / (200*200 :: Double))
06:09:43 <ChaiTRex> :t (200*200 :: Double)
06:09:44 <lambdabot> Double
06:09:52 <ChaiTRex> :t (200*200)
06:09:54 <lambdabot> Num a => a
06:11:00 <Inari-> Seems to work, now I just get the error on my "main = "  thing. But I can google that
06:11:31 <Inari-> Oh, I was lakcing a )
06:12:07 <Inari-> Works, thanks :D
06:16:39 * hackage semiring-num 1.6.0.3 - Basic semiring class and instances  https://hackage.haskell.org/package/semiring-num-1.6.0.3 (oisdk)
06:17:08 <ChaiTRex> Inari-: You're welcome.
06:18:31 <xenon-> @hoogle liftIO
06:18:32 <lambdabot> Control.Monad.IO.Class liftIO :: MonadIO m => IO a -> m a
06:18:32 <lambdabot> Test.Framework.Providers.API liftIO :: IO a -> ImprovingIO i f a
06:18:32 <lambdabot> Conduit liftIO :: MonadIO m => IO a -> m a
06:18:49 <xenon-> (wanted to do that in lambdabot)
06:26:25 <xenon-> using scotty for the first time. why is line 7 executed twice per single page open/refresh?  https://paste.ubuntu.com/p/dmXkxXWjRw/
06:29:31 <merijn> kuribas: Your code "handles" in StateT in the exact way MonadUnliftIO does, i.e. it doesn't really
06:30:08 <kuribas> merijn: it passes on the state
06:30:25 <kuribas> merijn: but each "unwrapped block" starts with the state where it is created.
06:30:36 <kuribas> merijn: it's impossible to do otherwise with IO.
06:31:30 <merijn> kuribas: The state from the block on the left is discarded, though
06:31:46 <merijn> kuribas: But that's just what MonadBaseControl does
06:32:28 <kuribas> merijn: unlike monadbasecontrol, I don't have a type family
06:32:32 <merijn> kuribas: And it's very confusing to use, especially in more complicated stacks, which is the reason why most people stopped using MonadBaseControl
06:32:51 <merijn> kuribas: The type family isn't what makes MonadBaseControl difficult/confusing
06:33:14 <kuribas> merijn: do you have an example?
06:36:05 <merijn> kuribas: The fact that state modifications don't apply to the "finally" handler is highly non-obvious for example
06:37:12 <kuribas> merijn: that's why the final handler is just IO in my version.
06:37:30 <merijn> kuribas: The conduit/resource/etc. migration to monadunliftio links to a Snoyberg talk on this too: https://www.youtube.com/watch?v=KZIN9f9rI34
06:38:44 <merijn> kuribas: The real question is: How does your version improve over monadunliftIO? because "reusing the same state" for handler and action can just be done by unwrapping the main action and handler directly IFF you want that, but I find it hard to see why you *would* want that
06:39:27 <merijn> kuribas: Can you clearly define 1) what you want to do, 2) how it's not doable with MonadUnliftIO, and 3) is possible with sensible semantics in your library?
06:41:23 <kuribas> merijn: well, I'd like to automatically derive instances that use ExceptT or StateT.
06:43:55 <merijn> kuribas: See, but that's confusing because if you have a newtype that has StateT hidden inside somewhere then it isn't obvious for users of your newtype that brackets, etc. are going to discard/reset (parts of) the state
06:44:19 <kuribas> that can be documented
06:44:51 <merijn> kuribas: In https://www.fpcomplete.com/blog/2017/07/the-rio-monad Snoyberg actually mentions how they ran into issues with that when combining the unwrap with running code asynchronously
06:53:15 <kuribas> merijn: If I have a monad stack with only ReaderT and IO, I may as well just pass the environment directly
06:54:08 * hackage bulmex 3.0.0 - Reflex infused with bulma (css)  https://hackage.haskell.org/package/bulmex-3.0.0 (Jappie)
06:54:13 <merijn> kuribas: That assume you have only a single ReaderT, there's tons of "specific" monads that boil down to "Reader" that you may want to combine
06:54:31 <kuribas> merijn: true, but there's also ExceptT, like Handler
06:54:34 <kuribas> in servant
06:54:36 <merijn> kuribas: Examples: LoggingT from MonadLogger, ResourceT
06:58:23 <merijn> hmm, I have a set of prefixes that I repeatedly need to check individual strings against, is there some convenient data structure for that sorta thing? Or should I just always try all prefixes...
06:59:19 <kuribas> merijn: a trie?
07:00:10 <kuribas> merijn: or sort the prefixes and do a binary search
07:00:34 <merijn> kuribas: I can think of a ton o ways to do it, I was just wondering if someone already had :p
07:01:01 <kuribas> merijn: you could use a set, then find the first element greater than that prefix.
07:01:12 <kuribas> merijn: then check the prefix again
07:01:20 <kuribas> O(log n) on the number of prefixes
07:04:37 <kuribas> merijn: fromMaybe (`isPrefixOf` "myWord) False <$> lookupGT "myWord" prefixes
07:05:06 <kuribas> "$", not "<$>"
07:05:21 <kuribas> merijn: you get the idea :)
07:06:09 * hackage llvm-ffi 3.9.0 - FFI bindings to the LLVM compiler toolkit.  https://hackage.haskell.org/package/llvm-ffi-3.9.0 (HenningThielemann)
07:06:19 <kuribas> merijn: lookupGE, incase the prefix matches the word
07:07:58 <merijn> Hmm, I'm not entirely sure whether that has exactly the right semantics
07:08:00 <merijn> Because
07:08:05 <merijn> > "" < "a"
07:08:07 <lambdabot>  True
07:08:13 <merijn> But "" is a complete prefix of "a"
07:09:13 <kuribas> merijn: ah, right, you need lookupLE
07:13:05 <kuribas> merijn: "" seems to be a special case
07:14:08 <kuribas> hmm, no...
07:14:56 <kuribas> I guess you'll need a trie after all...
07:17:43 <kuribas> I used a set, but I had the opposite problem, to find a prefix in a set of strings
07:48:09 * hackage llvm-ffi 3.9.1 - FFI bindings to the LLVM compiler toolkit.  https://hackage.haskell.org/package/llvm-ffi-3.9.1 (HenningThielemann)
07:48:42 <xenon-> what's up with scotty error messages? page loads fine, but I get output like this every now and then.   recv: failed (No error)  or  Network.Socket.sendBuf: failed (No error)
07:51:34 <merijn> Sounds like it's not handling sockets getting closed properly
08:20:52 <dmesg> Hi there! Can someone explain to me how the getStateType in https://www.stackage.org/haddock/lts-13.26/haxl-2.0.1.1/Haxl-Core.html#t:StateKey works? Specifically I want to implement it in a way where I can distinguish between keys in the map based on value (it sounds impossible from the docs I've been reading?)
08:54:09 * hackage tmp-postgres 1.15.1.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.15.1.0 (JonathanFischoff)
09:10:31 <sickouts> i heard that the venn diagram for haskell programmers and autists is a single circle.  
09:10:34 <sickouts> comments?
09:10:46 <MarcelineVQ>  can confirm
09:10:46 <sickouts> :s/autists/autistics/
09:10:49 <sickouts> k
09:10:52 <sickouts> just checking
09:11:28 * geekosaur considers
09:12:38 <sickouts> worst part about autistic people is a result of that temple grandin ted talk.  autistic people believe they're super special.  thy believe being autistic makes them better than normal people.
09:14:43 <MarcelineVQ> This is a channel for disucussing the haskell programming language :> but you can go to #haskell-offtopic if you've got other things to discuss
09:14:56 <sickouts> okay fascist
09:15:02 <sickouts> censor me
09:15:07 <geekosaur> you can badmouth elsewhere
09:15:08 <f-a> that's an Euler diagram tho
09:37:24 <mikail_> Hi, I need some help understanding section 2.2. in this paper on Servant https://www.andres-loeh.de/Servant/servant-wgp.pdf
09:37:53 <mikail_> I don't understand why the Proxy data type is required
09:38:06 <mikail_> Please could somebody unpack and expand on that 
09:38:50 <EvanR> docs :: HasDocs api => Proxy api -> API
09:39:54 <EvanR> it kind of explains it in that section
09:40:23 <EvanR> typeclass methods that don't actually use 'a' need proxy to assist in instance resolution
09:45:25 <EvanR> well they don't need Proxy, but when `api' has no actual values in the first place then it's the only way
09:45:27 <mikail_> EvanR, I'm not really a Haskell programmer (I have a Scala background) - just trying to grok the ideas in the paper
09:45:57 <EvanR> servant is using some advanced haskell stuff
09:45:59 <mikail_> if I may, let's break this section down in layman terms a bit
09:46:03 <[exa]> mikail_: you will probably need to see the problem first to appreciate proxies. :]
09:46:31 <mikail_> docs is a function which take an API
09:46:40 <[exa]> mikail_: the proxy basically just carries some type around, so that it can be used at random places that need extra type information that is not available from the rest of the type
09:46:45 <mikail_> and this API must have an instance of the typeclass HasDocs
09:47:02 <EvanR> it doesn't take an API
09:47:40 <EvanR> we should look at the HasDocs class
09:47:56 <EvanR> https://hackage.haskell.org/package/servant-docs-0.11.1/docs/Servant-Docs.html
09:48:33 <EvanR> the class has one method
09:48:38 <EvanR> docsFor :: Proxy api -> (Endpoint, Action) -> DocOptions -> API
09:49:05 <EvanR> ignoring Proxy api, this method doesn't actually depend on the api type
09:49:14 <EvanR> it takes 3 other things that are just some concrete type
09:49:28 <mikail_> oh, I get it now
09:49:33 <mikail_> I see what you mean
09:49:53 <EvanR> so if you use docsFor, it has no way to know which HasDocs instance you wanted
09:50:01 <mikail_> right
09:50:34 <mikail_> isn't this kind of a strange design tho?
09:50:47 <EvanR> personal opinion, yes :)
09:50:59 <EvanR> i've avoided making classes like this
09:51:15 <EvanR> it seems kind of like abuse
09:51:19 <mikail_> yes
09:51:33 <mikail_> I'm basically fishing for ideas on how to do the equivalent in Scala
09:53:56 <mikail_> My aim is to have a doc function which given an explicit API will generate some structured representation of the API documentation (e.g. markdown, AsyncAPI)
09:54:11 <EvanR> so whenever you want to do somthing like this, you either need to take an api as argument and no use it, which might be weird for someone who doesn't have one available or do something like
09:54:24 <EvanR> data Proxy a = Proxy
09:54:48 <EvanR> then user can pick the a at the use site without having an a
09:54:49 <mikail_> but if you don't have an API at hand, why would you use doc?
09:55:38 <EvanR> even if they are expected to, the proxy argument does indicate the method won't be using api for anything
09:56:05 <EvanR> but more importantly you should be able to use the instance regardles
09:56:32 <EvanR> instances are just global record of functions (and non-functions) sitting around somewhere
09:56:53 <mikail_> yes, I like the Haskell Typeclass mechanism
09:57:02 <mikail_> some people hate it but I like it
09:57:32 <mikail_> have to do a lot of nonsense in Scala to get the same
09:58:04 <mikail_> ok, that's cleared it up for me - thanks for the info EvanR exarkun 
09:58:14 <EvanR> yeah scala has more power, as i understand it, but then you need more brain power to keep it straight
10:57:05 <|Lupin|> Hello :)
10:57:18 <|Lupin|> I'm stuck with what's probably a really dumb question
10:57:40 <f-a> shoot, |Lupin| 
10:58:13 <|Lupin|> When reading a string (bytestring) from an input (a terminal, say), how do you remove just the final end-of-line
10:58:16 <|Lupin|> ?
10:58:54 <merijn> |Lupin|: If you want to operate on text you probably don't want to read as ByteString
10:59:49 <merijn> |Lupin|: For historical reasons it has "string" in the name, but it's really just Bytes. The text alternative (Text, that's at least straightforward ;)) has several functions for stripping whitespace of the start/end
11:00:16 <|Lupin|> merijn: with a friend we try to implement a little server, we use the recv function from NEtwork.Socket.ByteSTring
11:00:46 <EvanR> you can dropWhile from the end of a bytestring
11:01:01 <EvanR> if it's as simple as "remove \n"
11:01:04 <|Lupin|> merijn: well I saw the ones in Text but they seem to strip all blank characters at the end whereas I'd like to strip just the last one, and in an OS-dependent way
11:01:21 <|Lupin|> so if you are on Windows I'd like to strip \r\n, for example
11:01:37 <merijn> |Lupin|: Data.Text.Encoding has "ByteString -> Text" functions. You can do it in ByteString too if you really want, but I wouldn't recommend using ByteString if things are really Text :)
11:02:39 <merijn> |Lupin|: Is stripping all newlines (as opposed to all whitespace) acceptable, because then there's dropWhileEnd
11:02:55 <|Lupin|> not really...
11:03:21 <|Lupin|> So is there a way to recv text from a socket, rather than recv-ing a ByteString?
11:03:55 <|Lupin|> (also I used if msg=="bye\jn") in my code and that didn't work. Any idea why?
11:04:06 <|Lupin|> \n sorry
11:04:14 <merijn> |Lupin|: Sockets return bytes, because they can't know if you're sending text over them)
11:04:59 <merijn> |Lupin|: The only reliable way of getting Text from a ByteString is via Data.Text.Encoding and one of the decode functions
11:05:00 <|Lupin|> merijn: so would you stay with bytes or would you ocnvert to text? e.g. if the server uses Json, say?
11:05:50 <EvanR> > unlines "abc\ndef\n"
11:05:51 <lambdabot>  error:
11:05:51 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Char]’
11:05:52 <lambdabot>        Expected type: [String]
11:05:55 <merijn> |Lupin|: Oh, if it's JSON then I'd first see what JSON librries expect :)
11:05:58 <EvanR> > lines "abc\ndef\n"
11:06:01 <lambdabot>  ["abc","def"]
11:06:07 <EvanR> > lines "abc\r\ndef\r\n"
11:06:10 <lambdabot>  ["abc\r","def\r"]
11:06:14 <EvanR> well dam
11:06:33 <merijn> |Lupin|: For example, aeson wants ByteString
11:06:46 <|Lupin|> Ultimately it will be JSON but at the moment we wanted to play with a simple protocol, just to experiment
11:07:06 <EvanR> if you want a simple protocol, require people separate lines with \n
11:07:27 <|Lupin|> ok
11:07:32 <|Lupin|> When the server is run
11:07:41 <merijn> |Lupin|: For simple experimenting you may want to use Data.ByteString.Char8 with the important note that I will curse you and your children if you ever use it for "real" code :)
11:07:45 <|Lupin|> and a telnet is run in another ocnsole
11:07:55 <|Lupin|> if in the telnet I say
11:07:57 <|Lupin|> bye
11:08:12 <|Lupin|> The server will actually receive "bye`n" (I think)
11:08:13 <merijn> See also https://github.com/quchen/articles/blob/master/fbut.md#bytestringchar8-is-bad
11:08:17 <EvanR> there are better programs for interacting with a simple protocol than telnet
11:08:21 <|Lupin|> And I don't understand why
11:08:29 <EvanR> telnet is pretty complex
11:08:30 <merijn> |Lupin|: Are you using putStrLn?
11:08:33 <|Lupin|> if request=="bye\n"
11:08:42 <|Lupin|> will evaluate to False?
11:08:56 <merijn> Also, what EvanR says, despite common believe telnet is a surprisingly complex protocol with lots of escape codes, etc.
11:09:08 <merijn> It's not "just bytes and characters"
11:09:14 <EvanR> netcat is cool
11:09:23 <merijn> Yeah, for testing use netcat
11:10:35 <|Lupin|> oh good idea, thanks
11:16:19 <nshepperd> or netcat's cool uncle, socat
11:16:37 <merijn> nshepperd: Less portable
11:17:14 <merijn> nshepperd: All *nix OSes I know ship with netcat, only linux ships with socat (and even then maybe only some distros?)
11:17:59 <EvanR> starnix
11:18:09 * EvanR trademarks that
11:18:24 <nshepperd> you don't really need portability when you're just testing things
11:25:00 <Chobbes> Does anybody know if conduits are thread-safe? Like if I have something like: do forkIO (runConduit $ yield "helllloooo" .| sink); forkIO (runConduit $ yield "world" .| sink) ... Is there a chance that the output gets interleaved?
11:26:40 <geekosaur> I would expect it to be interleaved, yes
11:26:48 <geekosaur> if you want something else, plumb it that way
11:26:56 <merijn> Chobbes: The sink is a computation which gets duplicated
11:27:12 <Chobbes> merijn: what do you mean by that?
11:28:03 <merijn> Chobbes: sinks are not stateful things, they're computations so if your sink is "write stuff to a handle" then you're getting two independent computations that happen to write to the same handle (and may thus interleave)
11:28:03 <geekosaur> you do not hve one sink. you hav e two sinks with the same description
11:28:18 <jle`> Chobbes: that's definitely going to get interleaved, because once you use runConduit you're back in just a normal IO action
11:28:43 <jle`> well, i guess it depends on what 'sink' does
11:28:45 <nshepperd> if the sink is "concatenate all the values received and write the result to an IORef", the second thread to complete is just going to overwrite the first one
11:28:45 <Chobbes> For what it's worth I never seem to end up with like "hewllollrldoooo" or something with stdoutC, but maybe it has a lock behind the scene or something.
11:28:51 <Chobbes> (it being stdoutC)
11:28:54 <merijn> Chobbes: Handles have some rudimentary locking for access
11:29:00 <jle`> hm, yeah, there isn't any actual outputting in what you sent
11:29:06 <jle`> so it's hard to know what you mean unless you paste what 'sink' is
11:29:10 <merijn> Chobbes: So you're less likely to get interleaving, but it's not guaranteed
11:29:17 <jle`> if 'sink' has built-in thread safety with some known MVar, for example, then yeah it won't get interleaved
11:29:28 <jle`> 'conduits are thread-safe' isn't the question here; 'sink is thread-safe' is the question
11:29:37 <jle`> conduits just link normal IO actions together
11:29:41 <Chobbes> Awesome. This is clearing things up a lot :).
11:29:51 <jle`> with some cleanup stuff and resource management
11:30:00 <merijn> Chobbes: Why are you running the conduit in parallel?
11:30:10 <merijn> Or are they different conduits with a shared sink?
11:30:11 <jle`> so how thread-safe it is will depend on how thread-safe the specific sink is
11:30:11 <nshepperd> 'thread-safety' isn't any one particular thing in the first place, outside of not crashing your application
11:30:43 <merijn> (Because if your answer is "I want to parallelise a computation within a conduit" then I have a simpler solution for you ;)
11:33:50 <Chobbes> merijn: so, a client connects to a server, and I have a source and a sink where the sink sends messages to the client. Some messages I want to send to the client are responses to things that come from the source... BUT I also have other messages from the server that need to get sent on the same sink that I don't want to send through the same conduit pipeline. If that makes sense. So I want to send messages
11:33:51 <Chobbes> over this connection from different pipelines.
11:34:10 <Chobbes> (source is messages from the client)
11:34:30 <merijn> Chobbes: I'd use one thread per client and then serialise all communications to it via a Chan (or one of the bounded versions)
11:34:51 <Chobbes> merijn: like a TMChan?
11:35:14 <merijn> No clue what that is, but probably, yeah
11:35:26 <Chobbes> I guess the STM variant of Chan.
11:35:47 <Chobbes> Oh TChan, whatever :).
11:36:46 <Chobbes> merijn: okay, thanks. That's in line with my backup plan if the sink wouldn't behave how I'd like.
11:41:44 <druid99> Hello
11:41:48 <druid99> What’s going on?
11:51:38 * hackage hip 1.5.4.0 - Haskell Image Processing (HIP) Library.  https://hackage.haskell.org/package/hip-1.5.4.0 (lehins)
12:14:35 <constantine_91> when I am trying to "cabal install" inside a sandbox then why cabal is showing conflict of libraries with globally installed ones? like "base"
12:15:16 <hololeap> druid99: you're lookin at it
12:15:18 <merijn> constantine_91: Which version of cabal-install do you have?
12:15:42 <constantine_91> cabal-install version 3.0.0.0compiled using version 3.0.0.0 of the Cabal library
12:16:15 <merijn> constantine_91: cabal-install defaults to using v2-build, which doesn't support sandboxes (because they're basically obsolete in the v2-build era)
12:16:37 <merijn> constantine_91: (cabal-install 3.0 I mean)
12:16:55 <constantine_91> then what I am supposed to do?
12:17:20 <merijn> constantine_91: What are you trying to use a sandbox for? Isolating projects or for depending on local packages?
12:18:09 <constantine_91> because there is base library installed with version "4.13.0.0" and most of packages has dependency of base as "<4.12.0"
12:18:24 <merijn> constantine_91: Oh, that's a fundamentally different problem :)
12:18:37 <constantine_91> isolating a project
12:18:53 <merijn> constantine_91: base is hard wired into GHC, this means your GHC is new enough to not be supported by your dependencies yet
12:19:21 <constantine_91> so I need to downgrade my ghc version?
12:19:38 <constantine_91> current version is "The Glorious Glasgow Haskell Compilation System, version 8.8.1"
12:19:47 <geekosaur> hackage itself needs an upgrade for ghc 8.8, as I understand it
12:19:51 <merijn> constantine_91: Basically, cabal-install 3.0 now *always* and *automatically* isolates projects/builds from eachother, so "how do I isolate builds?" is now "you just use 'cabal build' or 'cabal install' and forget about managing it)
12:20:01 <merijn> geekosaur: Only for the base docs, not the packages
12:20:46 <constantine_91> so downgrading my ghc will solve my problem?
12:20:56 <merijn> constantine_91: You have to either downgrade GHC or "fix" those packages (which may just be "relax the upper bounds"), the quickest thing you can do (assuming you really wanna use 8.8) is to run "cabal build --allower-newer=base"
12:21:08 <merijn> eh
12:21:13 <merijn> --allow-newer=bae
12:21:37 <geekosaur> you'll get it at some point :p
12:21:42 <merijn> constantine_91: That basically informs cabal-install "ignore upperbounds on the base package", if you're lucky that "Just Works (TM)"
12:21:58 <merijn> constantine_91: If your unlucky your dependencies need some patching/fixing first
12:22:19 <merijn> Personally I'd advice to just use 8.6.5 instead, as 8.8 is still rather bleeding edge
12:22:45 <merijn> I tend to lag GHC releaes by 6 months to a year unless I *really* want/need a specific fix/feature in the newest version
12:23:29 <druid99> So let me explain myself, I’m a spiritualist with a lot of interest in science and spirituality and how they supplement one another
12:23:39 <druid99> And I love physics
12:23:56 <constantine_91> merijin: Okay! I will try to downgrade my ghc
12:25:05 <merijn> constantine_91: You can also keep multiple versions of GHC installed and switch as needed. cabal-install will happily use whichever version is in your path (or the version you explicitly tell it too) and all the global config/package registry is separated per GHC version, so they don't interfere
12:25:42 <merijn> (See, for example, ghcup which lets you switch versions)
12:26:07 <merijn> Or, if you're a minimalist unix curmudgeon like me you can just install multiple bindists and manage them yourself
12:27:14 <constantine_91> merijn: I tried ghcup last night... it broke my shell.. I mean whenever I tried opening my terminal that installation script for ghcup was running recursively
12:27:29 <merijn> constantine_91: Which OS?
12:27:34 <constantine_91> macOs
12:29:05 <merijn> constantine_91: If you're comfortable on the commandline you can just grab the bindist and do "./configure --prefix=path/to/install/ghc && make install" to install things (which is what I do on macOS and every other *nix :p)
12:29:09 <merijn> constantine_91: https://www.haskell.org/ghc/download_ghc_8_6_5.html#macosx_x86_64
12:31:55 <constantine_91> merijn: Yes! I more comfortable with command line than GUI stuff... going to try configure and install manually as you said
12:33:18 <merijn> constantine_91: I just install into $HOME/ghcXY (matching the version) and then just add $HOME/ghcXY/bin/ to my path
12:34:05 <constantine_91> meiijn: Just to clear my understanding.. this libraries comes wired with ghc right? means ghc-8.8* will have base-13.0.0 and ghc-8.6 will have something lesser version right?
12:35:17 <merijn> constantine_91: Correct
12:35:35 <merijn> https://wiki.haskell.org/Base_package
12:36:14 <ChaiTRex> constantine_91: For 8.6 versions, see http://hackage.haskell.org/package/base-4.12.0.0/changelog
12:36:46 <solrize> @hoogle [a] -> ([a]->[b]) -> [b]
12:36:47 <lambdabot> Boltzmann.Species emap :: Embed f m => (m a -> m b) -> f a -> f b
12:37:07 <solrize> @hoogle a -> (a->b) -> b
12:37:08 <lambdabot> Data.Function (&) :: a -> (a -> b) -> b
12:37:08 <lambdabot> Control.Lens.Lens (&) :: () => a -> (a -> b) -> b
12:37:08 <lambdabot> Control.Lens.Operators (&) :: () => a -> (a -> b) -> b
12:37:20 <constantine_91> Thanks ChaiTRex and merijn
12:37:25 <merijn> bleh, there's no identity conduit?
12:37:32 <solrize> weird that msg'ing lambdabot no longer works
12:37:57 <merijn> solrize: Works for me
12:38:00 <ChaiTRex> solrize: Try messaging this: > 5
12:38:08 <koz_> > 5
12:38:10 <lambdabot>  5
12:38:14 <koz_> such eval
12:38:17 <ChaiTRex> solrize: A simple evaluation is a good test of whether it can hear you.
12:38:43 <hololeap> this worked for me just now: /msg lambdabot @hoogle a -> (a -> b) -> b
12:40:25 <EvanR> @botsnack
12:40:25 <lambdabot> :)
12:48:57 <solrize> merijn, ChaiTRex, ah, thanks, i didn't realize i had to include the prefix '@' or '>' in the message.  so it ignored me i guess.
12:49:26 <solrize> dunno if it was different before.  vague memory.
12:59:02 <bifunc2> Attoparsec: https://hackage.haskell.org/package/attoparsec-0.13.2.3/docs/Data-Attoparsec-ByteString-Char8.html
12:59:02 <bifunc2> Can you help me find/build an alternative to "manyTill" where I can also get the output of the second parser?
12:59:14 <bifunc2> "manyTill" only retains the output of the first and discards the output of the second.
12:59:38 * hackage semiring-num 1.6.0.4 - Basic semiring class and instances  https://hackage.haskell.org/package/semiring-num-1.6.0.4 (oisdk)
13:09:13 <merijn> bifunc2: Eh...no it doesn't?
13:09:55 <merijn> Or does it? That'd be weird, that'd deviate from the other parsecs
13:10:54 <merijn> bifunc2: You can probably use lookAhead if it really does consume the final output
13:20:34 <bifunc2> merijn it worked, thank you!!
13:20:38 <bifunc2> you saved me
13:23:25 <koz_> "Do you have time to talk about our lord and saviour merijn?" :P
13:25:12 <merijn> The work on my cult of personality is finally starting to pay off
13:25:32 <koz_> merijn: You need a Little Red Book now.
13:25:40 <koz_> Or whatever colour you prefer.
13:26:57 <merijn> Anyway, I finally got my code to where I wanted it to be 2 weeks ago, so it's time slack off
13:29:14 <koz_> merijn: Seems like a good plan.
13:30:39 * hackage hOpenPGP 2.8.3 - native Haskell implementation of OpenPGP (RFC4880)  https://hackage.haskell.org/package/hOpenPGP-2.8.3 (ClintAdams)
13:43:57 <srid> I've finalized my Nix recipes for Haskellers article (target audience: Haskellers not yet familiar with nix, but wants to try it). If you have any feedback, please let me know! https://www.srid.ca/haskell-nix.html
13:54:24 <dsal> Does anyone have a favorite logger?
13:57:16 <[exa]> logger as in "connection to syslog" ?
13:59:51 <dsal> Not necessarily syslog, but just "print stuff"
14:00:46 <EvanR> there's a passed around/in your readerT  String -> IO ()
14:00:58 <EvanR> what it does, depends 
14:01:22 <dsal> I've been using hslogger.  It's modeled after log4j which basically means it's too complicated for me to do anything useful with.
14:01:56 <dsal> About the most useful thing I do is add a -v which sets the default filter from INFO to DEBUG
14:02:14 <EvanR> Level -> String -> IO ()
14:02:30 <[itchyjunk]> i can't believe that thing i wrote to compute lessender symbol came so handy to do the homework.
14:03:09 * hackage total-map 0.1.3 - Finitely represented total maps  https://hackage.haskell.org/package/total-map-0.1.3 (ConalElliott)
14:13:26 <infinisil> Hey, is there a simple 2D interactive animation library?
14:13:51 <infinisil> I've looked at gloss and diagrams, which both can draw 2D graphics with animations, but no interaction with them
14:14:10 <EvanR> gloss does have interaction
14:14:24 <EvanR> keyboard, mouse clicks, etc
14:14:41 <infinisil> Ah nice! Seems I have missed that
14:15:14 <infinisil> Ah yup, I've missed this one: https://hackage.haskell.org/package/gloss-1.13.1.1/docs/Graphics-Gloss.html#v:play
14:16:46 <EvanR> and i thought diagrams at least had a method to get a value associated with every point in space on a diagram
14:16:57 <EvanR> for the purposes of clicking on the diagram
14:17:25 <EvanR> https://archives.haskell.org/projects.haskell.org/diagrams/haddock/diagrams-lib/Diagrams-Query.html
14:18:10 <royal_screwup21> can I ask an algorithmic question?
14:19:39 <EvanR> ........... yes
14:23:03 <infinisil> EvanR: Ah nice, then diagrams might work too!
14:25:23 <solrize> royal_screwup21, go for it ;)
14:25:42 <royal_screwup21> solrize I am trying to solve this question: https://open.kattis.com/problems/classrooms
14:26:30 <royal_screwup21> my approach is to keep track of the ending time for each class...then greedily assign a class to new activity 
14:26:49 <royal_screwup21> problem is, finding a the most suitable class takes O(n) time 
14:28:02 <solrize> finding optimal solution sounds np-hard at first glance, thinking about it.  greedy assignment is a reasonable first approach
14:28:53 <solrize> it's a graph coloring problem
14:29:15 <royal_screwup21> solrize the idea is to allocate the class whose ending time is smaller than and the closest to the starting time of a new activity
14:29:48 <royal_screwup21> I think it's possible to do it optimally in c++ with multiset 
14:29:55 <royal_screwup21> but I'm using python
14:30:32 <royal_screwup21> and to find this optimal class, I have to maintain a list of classed sorted by ending time, and be able to efficiently find and delete an iterm 
14:30:37 <royal_screwup21> classes*
14:31:01 <royal_screwup21> find, delete and insert 
14:31:24 <royal_screwup21> any ideas folks?
14:32:02 <solrize> well you could implement a balanced tree algorithm or maybe there is a way to use the heapq module... but, the problem as stated is to find the optimal number
14:32:26 <royal_screwup21> solrize yup
14:34:13 <royal_screwup21> I don't want to implement a red-black tree :(
14:37:03 <solrize> well you're on #haskell, why not program it in haskell instead of python?
14:37:53 <solrize> anyway i think greedy coloring is not likely to give the right answer
14:38:08 <royal_screwup21> aside from computing fibonacci I can barely do anything in haskell :p
14:38:17 <solrize> well why ask here then?  :)
14:38:19 <royal_screwup21> solrize why not
14:38:34 <royal_screwup21> I thought you guys were smart ;)
14:38:58 <solrize> aha this is called an interval graph
14:39:02 <solrize> https://en.wikipedia.org/wiki/Interval_graph
14:39:21 <solrize> In interval graphs and chordal graphs, if the vertices are ordered in the reverse of a perfect elimination ordering, then the earlier neighbors of every vertex will form a clique. This property causes the greedy coloring to produce an optimal coloring, because it never uses more colors than are required for each of these cliques. An elimination ordering can be found in linear time, when it exists.[9] 
14:39:29 <solrize> from https://en.wikipedia.org/wiki/Greedy_coloring  
14:39:32 <solrize> brb
14:42:36 <solrize> yeah how does this sound
14:42:42 <solrize> read all the intervals into a list
14:42:57 <solrize> sort the list on the starting time of each interval
14:44:26 <solrize> i guess in worst case this can be quadratic hmm 
14:45:55 <solrize> ok sort the list on the starting time of each interval.  then scan from left to right and for each interval, put its ending time onto a priority queue 
14:46:32 <solrize> or rather, put all the ending times onto a priority queue
14:47:11 <solrize> scan the intervals by earliest starting time, til you get one that starts after the earliest time on the queue
14:48:10 <solrize> now you've got a group of overlapping classes of known size
14:49:33 <solrize> pop that earliest end time and any starts before the starting time of that end time, and repeat
14:49:43 <solrize> maybe this is still worst case quadratic, hmm
14:50:29 <solrize> anyway you get the idea, i dont think red-black trees really help with this, just use sorted arrays and queues
14:52:43 <EvanR> ok. years later i go back to machines and it makes perfect sense
14:52:58 <EvanR> why is no one using it :)
14:54:29 <EvanR> the slides are accessible using way-back machine... hopefully it doesn't get forgotten
14:54:38 <solrize> using what?
14:54:48 <EvanR> machines
14:55:06 <solrize> machines = a haskell module or ?
14:56:03 <EvanR> a hackage package with some sparse background material and no real docs... ok i guess i answered my own question
14:56:09 <solrize> ah ok
14:56:24 <solrize> state machines or something?  there is a ruby package for that and it is actually kind of useful
14:57:09 <EvanR> state machines that can compose
14:57:16 <solrize> ic
14:57:19 <EvanR> and be programmed with do notation
14:57:24 <solrize> k
14:57:32 <EvanR> and has some kind of optimizer
14:58:21 <EvanR> and has a monad transfomer
15:01:03 <koz_> EvanR: streaming uses many of the same ideas as machines, but it's much better docced in my experience.
15:01:15 <EvanR> streaming eh
15:01:31 <koz_> It's a pretty cool library.
15:02:32 <koz_> (it also has a pretty strong description of the justifications behind its design)
15:02:44 <koz_> (I kinda tried to echo that with finitary-deriving, to limited success)
15:04:38 <koz_> Now I have to decide whether I wanna finish finitary-random or finitary-sorting first.
15:05:45 <jle`> EvanR: i had a use case for machines a month or so ago but i ended up using free instead for some reason
15:06:48 <koz_> Hi jle`!
15:06:52 <jle`> hi!
15:07:05 <EvanR> i love the front page shoutout to "mapM in IO uses a lot of memory, and everyone is used to it, but shouldn't!"
15:07:14 <koz_> EvanR: It's a valid point.
15:07:26 <EvanR> ya
15:07:30 <koz_> Does traverse_ suffer from the same problem?
15:07:41 <koz_> (or mapM_ for that matter)
15:07:44 <EvanR> we complain about people using list as a data structure... but then mapM in IO
15:07:58 <koz_> EvanR: Friends don't let friends mapM in IO.
15:12:17 <maralorn> What should I let my friends use instead?
15:13:11 <koz_> maralorn: streaming, conduit, pipes, something like that.
15:13:48 <EvanR> not everything incremental can be streamed right... when if an error in the middle is supposed to equal "no effect overall"
15:13:59 <EvanR> what if*
15:14:11 <nshepperd1> What's wrong with mapM in IO?
15:14:15 <maralorn> I am always wandering about all those libraries. Are they "contagious" to my code base? As in: Do I have to go all in with them?
15:14:24 <maralorn> *wondering
15:14:40 <EvanR> mapM in IO builds the entire outputlist upfront before returning anything
15:15:24 <maralorn> It‘s strict in the returntype?
15:15:30 <MarcelineVQ> koz_, EvanR: streamly is your bet if you want blazing speed however, with async as a nice bonus
15:15:35 <nshepperd1> Isn't that what it should do?
15:15:41 <EvanR> yeah...
15:15:50 <Eduard_Munteanu> You do kinda get locked in to your particular choice of streaming lib.
15:15:56 <MarcelineVQ> e.g. https://github.com/composewell/streaming-benchmarks though I admit these charts are a little hard to read
15:16:41 <koz_> MarcelineVQ: Yes, that's a pretty valid statement.
15:16:59 <koz_> Eduard_Munteanu: Yes, but there's a decent amount of interop.
15:17:11 <koz_> streaming, for example, specifically has provisions to play nice with conduit and pipes.
15:17:13 <MarcelineVQ> streamly is also nicely documented. though I really like streaming's writeup
15:17:41 <koz_> MarcelineVQ: They're both very nicely documented.
15:17:55 <MarcelineVQ> As someone who's trying to write a streaming lib currently that was a good lib to have linked
15:19:05 <koz_> EvanR: My memory might be fuzzy, but I think streaming _does_ have provisions for that case _somewhere_.
15:22:00 * Eduard_Munteanu wonders if the Rx API got implemented somewhere
15:22:18 <koz_> Eduard_Munteanu: What's Rx?
15:22:54 <Eduard_Munteanu> koz_, http://reactivex.io/
15:23:09 <koz_> Eduard_Munteanu: Ah, that.
15:23:09 <EvanR> not to be confused with ActiveX
15:23:11 <Eduard_Munteanu> I guess we have better than rx.
15:23:53 <koz_> Eduard_Munteanu: This paper comes to mind: https://dl.acm.org/citation.cfm?id=2976010
15:24:21 <koz_> If I recall correctly they even have Reactive _something_ as an example in there.
15:24:26 <koz_> (or an implementation of said)
15:24:45 <Eduard_Munteanu> Ah.
15:25:59 <koz_> Eduard_Munteanu: Reactive Programming is what they use as an example. I dunno if that's related or not.
15:26:06 <koz_> (Section 6 of the paper, page 7)
15:26:07 <nshepperd1> ReactiveX looks like another reinvention of "frp, but without behaviours"?
15:27:10 <EvanR> "and a weird event model"
15:27:12 <Eduard_Munteanu> TBF, they did a good job at dumbing it down.
15:28:32 <EvanR> so i'm not surprised we go on the topic of ReactiveX/Rx, but let me rock the boat a little and wonder how that kind of thing is related to "stream processing"
15:29:10 <EvanR> which is what List, conduit, pipes, machines, streaming, and streamly do?
15:29:19 <EvanR> and iteratees?
15:29:32 <koz_> EvanR: I believe it's to do with the whole 'produce elements on demand' thing.
15:29:44 <EvanR> so that sounds like streaming
15:30:11 <koz_> There's probably some _conceptual_ overlap there, but at the same time, I dunno how exactly this translates or whether I can say anything sensible about it.
15:30:14 <EvanR> not really reactive anything
15:31:00 <EvanR> streaming seems to focus on "give it to me", pull 
15:31:44 <maralorn> I feel like the whole thing is not even very far away from futures …
15:32:04 <koz_> maralorn: Futures being what again?
15:32:39 <maralorn> koz_: e.g. the thing rust uses for async.
15:32:45 <koz_> maralorn: Ah.
15:33:13 <maralorn> The conceptual similarity is, that they work pull based.
15:33:23 <EvanR> http://conal.net/blog/posts/future-values
15:33:39 <maralorn> But they don‘t really fit with the rest because I think the only yield once.
15:34:19 <koz_> On a much different note - can I generate x86 binaries with an x64 GHC?
15:34:27 <koz_> And if so, what specific flags do I have to feed it?
15:36:00 <EvanR> see also IVar
15:43:08 * hackage morpheus-graphql 0.7.0 - Morpheus GraphQL  https://hackage.haskell.org/package/morpheus-graphql-0.7.0 (nalchevanidze)
15:56:41 <noni> Hello. .
15:56:48 <dmj`> hey
15:57:26 <noni> Whoa someone else still using irc. Great
15:57:29 <dmj`> koz_: yea, if your arch is x86_64 should just be standard
17:08:32 <whitePixel>  /quit
17:41:39 * hackage snap-core 1.0.4.1 - Snap: A Haskell Web Framework (core interfaces and types)  https://hackage.haskell.org/package/snap-core-1.0.4.1 (DougBeardsley)
17:55:54 <siraben> I'm trying to mix the state and continuation monad, what am I doing wrong? http://ix.io/22Hc
17:58:35 <Cale> siraben: That's really hard to read, maybe try ContT?
17:58:55 <Cale> The thing you want is almost certainly either ContT of State or StateT of Cont
17:59:42 <siraben> Hm, but which one? I'm trying to translate Matt Might's A-normalization code written impurely in Racket: http://matt.might.net/articles/a-normalization/
17:59:54 <siraben> He uses CPS style and gensym to create fresh variables.
18:00:15 <siraben> So, I somehow need to update the state before I call a continuation
18:00:24 <siraben> Does that mean I use StateT of Cont?
18:02:09 <Cale> Probably the easiest way to tell is just to do a small experiment with both to see how they interact, but we could also think hard about it...
18:02:18 <Cale> @unmtl ContT r (State s a)
18:02:18 <lambdabot> Plugin `unmtl' failed with: `ContT r (s -> (a, s))' is not applied to enough arguments.
18:02:21 <Cale> @unmtl ContT r (State s) a
18:02:21 <lambdabot> (a -> s -> (r, s)) -> s -> (r, s)
18:02:30 <Cale> @unmtl StateT s (Cont r) a
18:02:30 <lambdabot> s -> (a -> s -> r) -> r
18:06:19 <Cale> > flip runState 0 . flip runContT return $ do callCC (\ret -> forever $ do n <- get; if n > 10 then ret n else put (n+1))
18:06:22 <lambdabot>  (11,11)
18:07:00 <Cale> ah, no, this doesn't distinguish them...
18:07:08 <Cale> > flip runCont id . flip runStateT 0 $ do callCC (\ret -> forever $ do n <- get; if n > 10 then ret n else put (n+1))
18:07:10 <lambdabot>  (11,11)
18:07:11 <siraben> Cale:  http://ix.io/22Hg
18:07:14 <siraben> Does this work?
18:07:14 <Cale> ^^ same outcome
18:07:41 <Cale> Yeah, give that a shot
18:08:16 <siraben> Cale:  Ok, suppose I wanted to call the continuation with arg "5" in gensym, what do I do?
18:08:20 <siraben> callCC?
18:08:47 <siraben> Like, I want the effect of do { n <- k "5"; return n } where k is the continuation
18:08:50 <Cale> Well, callCC is what creates your local sense of what "the continuation" is
18:09:02 <siraben> The continuation that was passed to gensym, in this case.
18:09:23 <Cale> Right, so you can wrap the body of gensym in callCC
18:09:58 <siraben> This good? http://ix.io/22Hi
18:10:34 <Cale> That'll just be equivalent to let k = Val (S t)
18:10:43 <Cale> er, sorry
18:10:46 <Cale> That'll just be equivalent to let b = Val (S t)
18:11:15 <siraben> But we don't know what k is, right?
18:11:19 <siraben> Isn't k the continuation?
18:11:39 <Cale> k is the function from b to the rest of the computation
18:13:02 <Cale> One way I like to think about it is that in an imperative programming language, every function/procedure definition is implicitly wrapped in callCC, and when you use the return keyword, it calls the continuation that callCC gave you
18:13:29 <Cale> So it's like you wrote a thing that just immediately terminates with the result Val (S t) there
18:13:37 <Cale> and that's what b is going to get bound to
18:13:56 <siraben> Huh.
18:14:25 <siraben> Well, how do I translate the Scheme code http://ix.io/22Hl then?
18:14:34 <Cale> If you move the callCC, it'll do something else though.
18:14:46 <siraben> He performs a gensym, binds the result to t, then calls the continuation on t.
18:15:01 <siraben> and returns a Let whose body is the result of calling k on t
18:16:18 <Cale> So, probably because the continuation is bound there as an argument to normalize-name, in the translation, you want to get the continuation of normalizeName
18:16:37 <Cale> So like, normalizeName m = callCC $ \k -> ...
18:19:12 <siraben> Wow, I don't know what happened now. I suddenly get (t0 t1 3) as my output when I translate  ((f g) (h x) 3), whereas the blog says it should be translated to (let ([t0 (f g))  (let ([t1 (h x))   (t0 t1 3)))
18:19:13 <Cale> and you can think of executing  k x  as being like "abort this call to normalizeName and return the result x"
18:19:24 <siraben> Looks like it is doing what I want, but it returns only the innermost body of the let
18:19:58 <siraben> For reference, here is normalizeName now: http://ix.io/22Ho
18:20:41 <siraben> It's somehow not going back up the call stack and returning early
18:20:52 <Cale> So... right... now when you execute k (Val (S t)), that's the end. It's like having written return (Val (S t)) in an imperative language
18:21:19 <Cale> So we'll have to think a little harder about what the original code means
18:21:30 <siraben> Do I have to rewrite all my other normalize functions with callCC $ \k -> ... in front?
18:21:47 <Cale> Well, hm
18:21:54 <Cale> It shouldn't affect their behaviour
18:22:07 <Cale> But what we have for normalizeName now doesn't quite make sense
18:22:28 <Cale> Ah, I see
18:23:43 <Cale> Er, maybe :)
18:25:00 <Cale> This scheme is tricky
18:27:23 <Cale> So, in the case that the result of normalizing M is not a value, we're producing a let, and then inside that let, we have an antiquote that calls the continuation we were passed.
18:27:40 <siraben> Yes
18:29:18 <Cale> But if that continuation is just the entire rest of everything that we're ever going to do, that... can't quite be right
18:29:54 <Cale> (because then we'll never get around to returning the let, we'll just proceed with the continuation applied to t and never get back to here)
18:30:23 <siraben> Right
18:31:21 <Cale> So maybe it really is easier to do this in explicit CPS
18:32:00 <siraben> Hm, it feels like we're nearly there, no?
18:32:00 <Cale> Just because they're passing carefully-crafted continuations, and it's hard to sort of invert everything at once
18:32:05 <siraben> Ah
18:32:57 <Cale> But we're closer anyway, we can take k as an argument there
18:33:09 <Cale> and not have the callCC, and I think that's a pretty decent translation
18:33:47 <Cale> Er, except instead of return n
18:33:50 <Cale> You want k n
18:34:20 <Cale> (they'd have been the same thing with the callCC, but not now)
18:35:28 <siraben> Ok, does normalize have to accept an explicit continuation parameter k now as well?
18:36:52 <Cale> Well, what does normalize look like? It might be easiest to write normalize by starting with a ContT thing and then just writing a version which takes an explicit continuation and does runContT with that
18:38:29 <Cale> Though, I wonder where the rubber meets the road with all these continuations
18:40:27 <siraben> Why didn't callCC work? It seemed like it almost worked
18:40:35 <siraben> It just didn't go back up the call stack, hm.
18:40:48 <Cale> callCC basically gives you a way to abort the code inside the callCC
18:40:55 <Cale> and return a different value prematurely
18:41:13 <Cale> So when we do  callCC (\k -> ... k whatever ...)
18:41:33 <Cale> When we execute k whatever, the entire callCC finishes immediately with whatever as its result
18:42:41 <Cale> So, we were aborting early, with (Val (S t)) as the result of the whole callCC
18:42:53 <Cale> and the code with the Let in it was pretty much dead code
18:43:26 <Cale> because there was no condition under which we'd get there before hitting the k (Val (S t))
18:44:12 <Cale> The scheme code is by contrast, taking a much smaller "continuation", and applying it more than once.
18:45:05 <siraben> Ah I see.
18:47:15 <Cale> Though, I really don't yet understand what all this continuation loopiness is *for*
18:49:46 <siraben> Yeah, my best guess is that it was a direct translation of code from a paper on A-normalization
18:50:23 <Cale> It might have something to do with the way that lambdas are being translated
18:52:31 <Cale> No, that one calls the continuation immediately..
18:53:25 <Cale> It's all these ones which want to generate some let that's on the outside of the result
18:54:15 <Cale> But I'm not sure why you'd do that rather than just... generate the thing you want directly...
18:54:25 <Cale> Oh, maybe because they're obsessed with tail-calls
18:54:34 <siraben> @pl norm e = runCont (evalStateT (runANormal (normalizeTerm ex1)) 0) id
18:54:35 <lambdabot> norm = const (runCont (evalStateT (runANormal (normalizeTerm ex1)) 0) id)
18:54:46 <Cale> Yeah, that must be it
18:54:48 <siraben> norm e = runCont (evalStateT (runANormal (normalizeTerm e)) 0) id
18:54:53 <siraben> @pl norm e = runCont (evalStateT (runANormal (normalizeTerm ex1)) 0) id
18:54:53 <lambdabot> norm = const (runCont (evalStateT (runANormal (normalizeTerm ex1)) 0) id)
18:54:58 <Cale> Let me take a shot at this...
18:55:02 <siraben> Oops
18:55:06 <siraben> @pl norm e = runCont (evalStateT (runANormal (normalizeTerm e)) 0) id
18:55:06 <lambdabot> norm = flip runCont id . flip evalStateT 0 . runANormal . normalizeTerm
18:55:08 <siraben> There we go
18:55:20 <siraben> And we get the translation as desired: Let ("t0",App [Val (S "f"),Val (S "g")]) (Let ("t1",App [Val (S "h"),Val (S "x")]) (App [Val (S "t0"),Val (S "t1"),Val (N 3)]))
18:55:36 <Cale> Yeah, the mtl screwed up when determining the order of arguments to run functions
18:55:41 <siraben> i.e. (let (t0 (f g)) (let (t1 (h x)) (t0 t1 3)))
18:56:13 <Cale> I think we can write a version of this which is far more sensible
18:56:33 <Cale> without the continuation passing mess
18:56:56 <Cale> and which just recurses directly
18:57:09 <Cale> Can you paste a full version that I can edit?
18:57:10 <siraben> Cale: http://ix.io/22Hx
18:57:15 <Cale> thanks
18:57:27 <siraben> There's something unsatisfying about writing code that looks exactly like a monad
18:58:28 <siraben> Cale:  All the features of Cont are unused :(
18:59:46 <Cale> yes
19:00:09 <Cale> I think we can do this kind of thing:
19:00:10 <Cale> normalize (L ps b) = L ps (normalizeTerm b)
19:00:11 <Cale> normalize (Let (x, m1) m2) = Let (x, normalize m1) (normalize m2)
19:00:11 <Cale> normalize (If m1 m2 m3) k = If (normalizeName m1) (normalize m2) (normalize m3)
19:00:22 <Cale> There's no disadvantage to this in Haskell
19:00:46 <vaibhavsagar> silly question: why can't I lowercase a char8 bytestring?
19:01:11 <Cale> In scheme, you might cause a stack overflow, but this is actually easier on the stack when lazy evaluation is involved -- you're evaluating the thing in order to figure out which data constructor it's constructed with anyway
19:01:18 <Cale> So producing that sooner is a good thing
19:01:33 <Cale> vaibhavsagar: I don't know, why can't you? :)
19:02:00 <Cale> BSC.map toLower ?
19:02:38 * hackage hOpenPGP 2.8.4 - native Haskell implementation of OpenPGP (RFC4880)  https://hackage.haskell.org/package/hOpenPGP-2.8.4 (ClintAdams)
19:03:17 <Cale> siraben: Oh, except of course we need gensym, so it'll have to be StateT at least, but it can be in applicative-style
19:03:18 <siraben> Cale:  yeah, but I need to update the state as well
19:03:21 <Cale> yeah
19:03:26 <siraben> Ah, wow it is possible
19:03:27 <siraben> Let me try
19:03:34 <vaibhavsagar> Cale: toLower works on Char, not ByteStrings :)
19:03:55 <vaibhavsagar> unless you're suggesting BSC.pack . map toLower . BSC.unpack
19:03:57 <Cale> vaibhavsagar: Well, Data.ByteString.Char8.map
19:04:05 <Cale> works on Char, doesn't it?
19:04:11 <dmwit> vaibhavsagar: BSC.map works on ByteStrings
19:04:20 <Cale> :t Data.ByteString.Char8.map
19:04:22 <lambdabot> (Char -> Char) -> BSC.ByteString -> BSC.ByteString
19:04:32 <Cale> :t Data.ByteString.Char8.map toLower
19:04:34 <lambdabot> BSC.ByteString -> BSC.ByteString
19:04:36 <vaibhavsagar> wow, you're totally right
19:05:14 <Cale> That's the whole point of that module -- it operates on the same ByteString type as what's exported by Data.ByteString, but all the functions work on fake Chars
19:05:39 <siraben> Cale:  Wait, what about normalizeName?
19:05:40 <Cale> with the slightly foolish encoding where you map bytes to the first 256 unicode codepoints
19:08:01 <Cale> siraben: I'm not sure yet, but maybe if we figure out what goes wrong, we'll be enlightened about why all this CPS is being used :)
19:11:33 <Cale> Well, even before we figure that out, let's actually use ContT effectively...
19:12:21 <siraben> @pl g t = normalizeNames xs (return . App . (t:))
19:12:21 <lambdabot> g = normalizeNames xs . ((return . App) .) . (:)
19:13:17 <siraben> Cale:  new version: http://ix.io/22HA
19:13:30 <siraben> So I did a little trick with "where"
19:15:56 <siraben> Passing that continuation is still annoying, however.
19:20:49 <Cale> I think I might know what we need...
19:24:11 <Cale> oh, hmm!
19:24:16 <siraben> runContT
19:24:47 <Cale> Well, yeah, we can clean up a bunch of this with ContT at the very least
19:25:05 <Cale> But yeah, the tricky part is figuring out what sort of thing normalizeName ought to be
19:25:23 <Cale> You want to at very least clean up normalizeNames with ContT as well
19:25:53 <Cale> but normalizeName wants to receive an explicit continuation -- it actually wants the continuation which is obtained by a callCC at the top level of normalize
19:26:35 <Cale> (at least, in the case where we're calling it when handling an If)
19:27:50 <Cale> ah, yeah, but we could just explicitly apply the ContT constructor to it in order to use mapM to define normalizeNames :)
19:29:23 <siraben> Cale:  https://dpaste.de/SfTs
19:29:45 <siraben> Oops wrong syntax, fixed; https://dpaste.de/vUyT
19:29:57 <siraben> Ok now we have runContT
19:29:58 <Cale> Let me just fix up my version so that I can show you what I've got...
19:30:40 <siraben> Ok
19:46:27 <Cale> ohhh, I think we need polymorphic continuations...
19:46:29 <Cale> hmm
19:46:40 <Cale> or maybe I can sidestep that, but it'll be annoying
19:46:57 <siraben> whichever is shortest
19:53:47 <Cale> so annoying, haha
19:55:28 <siraben> I can't get it smaller than that paste, hm
20:05:25 <Cale> Yeah, I'm just back to calling the wrong continuation somewhere, hm
20:06:02 <Cale> However, you might like this widget at least:
20:06:14 <Cale> :t mapM cont
20:06:15 <lambdabot> Traversable t => t ((b -> r) -> r) -> ContT r Identity (t b)
20:06:33 <Cale> :t flip runCont id . mapM cont
20:06:34 <lambdabot> Traversable t => t ((b -> t b) -> t b) -> t b
20:06:41 <siraben> Cale:  this is as small as it gets: https://dpaste.de/kY9u
20:06:46 <Cale> :t \f -> flip runCont id . mapM (cont . f)
20:06:48 <lambdabot> Traversable t => (a -> (b -> t b) -> t b) -> t a -> t b
20:06:56 <siraben> Much better, I think, than the original versions
20:07:19 <Cale> The Traversable thing makes it a little harder to read, but that's the relationship between normalizeName and normalizeNames
20:07:47 <Cale> ah, yeah, that's not too bad
20:08:01 <Cale> and you already have the mapM trick :)
20:08:32 <siraben> Untangling that Scheme code was quite a journey!
20:09:00 <Cale> ahhh, cool, I don't know why I didn't think to only apply Cont at the level of normalizeName
20:09:00 <siraben> Do you think I can get rid of runCont in normalize?
20:09:27 <Cale> Maybe...
20:10:33 <Cale> Oh, yeah, let's just inline the argument a couple times and see what we end up with...
20:10:37 <Cale> and then maybe simplify that
20:11:30 <Cale> Like, we're down to the point where we're calling runCont on something that is directly a cont (...)
20:11:43 <Cale> and so we could just inline the k
20:12:33 <Cale> Maybe it's easier to define an Exp as either n or (Val (S t))
20:12:54 <Cale> and just return Let (t, n) e
20:14:22 <Cale> I think that's the same?
20:14:38 <siraben> Hm, this corresponds to this transformation in Scheme:
20:14:59 <siraben> (if x a b) => (if x a b)
20:15:01 <siraben> In the other case,
20:16:10 <siraben> (if (f 3) a b) => (let ((t0 (f 3)) (if t0 a b))
20:16:57 <siraben> If we reduce it down to one branch, (if x a b) becomes (if x a b) => (let ((t0 x)) (if t0 a b))
20:17:05 <siraben> Which is still right, but necessarily blows up coe
20:17:06 <siraben> code*
20:19:51 <siraben> @pl do { t <- gensym ; Let (t, n) <$> k (Val (S t)) }
20:19:52 <lambdabot> (line 1, column 4):
20:19:52 <lambdabot> unexpected '{'
20:19:52 <lambdabot> expecting variable, "(", operator or end of input
20:20:03 <siraben> Oops, PL doesn't know do-notation
20:20:23 <Cale> I mean...
20:23:15 <Cale> Let me just quickcheck...
20:31:08 <Cale> ah, yeah, I see what you mean :)
20:37:35 <Cale> siraben: It's worth noting that you can remove the ContT from the definition of ANormal now though
20:37:49 <Cale> Or the Cont rather
20:37:57 <Cale> Since you're actually never using that one
20:37:57 <siraben> Cale:  How so?
20:38:11 <Cale> You're always running a fresh Cont on top
20:38:24 <siraben> So just a state monad?
20:38:27 <Cale> yeah
20:39:36 <siraben> Ah, yes, even better.
20:42:35 <slack1256> 1/w
20:42:40 <slack1256> (sorry)
20:43:16 <amalloy> i managed to get lsp-mode installed for emacs, but i don't know how to use it. it's providing type popups and suggested actions, but i don't see how to invoke those actions. is there a manual somewhere? the readme just has pictures
20:44:44 <amalloy> (i installed lsp-ui as well)
21:03:54 <siraben> Cale:  Managed to get through the rest of the blog post, here's the final version! https://gist.github.com/siraben/447c419508b460afc99a232d5df8063f
21:04:49 <siraben> Looks like it successfully transforms the factorial example too
21:06:58 <edwardk> siraben: that's pretty clean
21:07:21 <siraben> Makes me wonder why he didn't just  do it in Haskell in the first place, lol
21:23:37 <Cale> siraben: Yeah, looks good!
21:35:10 <siraben> Thanks edwardk, Cale
21:44:09 * hackage fakedata 0.4.0 - Library for producing fake data  https://hackage.haskell.org/package/fakedata-0.4.0 (psibi)
21:47:39 * hackage advent-of-code-api 0.2.4.2 - Advent of Code REST API bindings and servant API  https://hackage.haskell.org/package/advent-of-code-api-0.2.4.2 (jle)
22:13:03 <dmj`> @def rot13 x = let rot c | c == 'z' = 'a' | isAlpha c = succ c | otherwise = c in iterate rot x !! 13
22:13:05 <lambdabot>  Defined.
22:13:19 <dmj`> > fmap rot13 "wrsserl rcfgrva qvqa'g xvyy uvzfrys"
22:13:21 <lambdabot>  "jeffrey epstein didn't kill himself"
22:14:19 <siraben> Clever use of iterate!
22:14:26 <siraben> I wonder if we can golf that further
22:17:32 <slack1256> dmj`: They got him dammit
22:37:34 <hololeap> > fmap rot13 "qzw` qvq vg"
22:37:37 <lambdabot>  "dmj` did it"
23:07:00 <siraben> @def y = y
23:07:01 <lambdabot>  .L.hs:188:5: error:
23:07:01 <lambdabot>      Ambiguous occurrence ‘y’
23:07:01 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.y’,
23:07:09 <siraben> @def foobar = foobar
23:07:11 <lambdabot>  Defined.
23:07:13 <siraben> > foobar
23:07:19 <lambdabot>  mueval-core: Time limit exceeded
23:07:25 <siraben> Bwahaha
23:07:44 <siraben> > mapM_ print [1..10]
23:07:46 <lambdabot>  <IO ()>
23:09:43 <koz_> siraben: such io
23:10:07 <siraben> Such sad
23:10:11 <siraben> > take 1000 [1..]
23:10:14 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
23:10:34 <siraben> Who wrote lambdabot, by the way?
23:11:03 <EvanR> % mapM_ print [1..10]
23:11:04 <yahb> EvanR: 1; 2; 3; 4; 5; 6; 7; 8; 9; 10
23:11:05 <koz_> Current maintainer is James Cook.
23:11:35 <siraben> The explorer?
23:12:20 <siraben> Where can I view lambdabot;s source code?
23:12:45 <koz_> siraben: I doubt that Haskell existed in the 19th century.
23:13:00 <koz_> https://github.com/lambdabot/lambdabot
23:15:44 <nineonine> if I have term :: Foo 'Bar
23:15:55 <nineonine> Is there a way to cast it to :: Foo 'Baz ?
23:16:15 <koz_> nineonine: coerce, assuming 'Bar and 'Baz are phantom.
23:16:40 <koz_> Although this assumes that Foo is (essentially) a newtype.
23:16:49 <koz_> And not like, some fancy GADT or something.
23:17:20 <nineonine> makes sense. thanks
23:17:28 <EvanR> phantom types can be coerced willy nilly?
23:17:39 <koz_> EvanR: Consider the example of Proxy.
23:17:48 <EvanR> doesn't that break things
23:17:51 <koz_> Proxy a and Proxy b don't differ in their representation one whit.
23:17:58 <EvanR> sure
23:18:16 <koz_> EvanR: The role derivation algorithm is rather careful in this regard, and if you don't want that to be possible, either assign the role manually or don't export the constructors.
23:18:34 <koz_> (at least I believe the second will block coercion)
23:18:41 <iqubic> A proxy is just a carrier for a phantom type.
23:18:45 <EvanR> don't export the datakind constuctors?
23:19:08 <iqubic> Can you do that?
23:19:11 <EvanR> :t coerce
23:19:12 <lambdabot> error:
23:19:12 <lambdabot>     • Variable not in scope: coerce
23:19:12 <lambdabot>     • Perhaps you meant ‘coerced’ (imported from Control.Lens)
23:19:22 <koz_> EvanR: The data constructors.
23:19:26 <EvanR> of what
23:19:27 <koz_> % :t coerce
23:19:27 <yahb> koz_: Coercible a b => a -> b
23:19:43 <koz_> EvanR: The type you don't want to be coerced with?
23:19:46 <EvanR> coerce doesn't seem to need constuctors
23:19:50 <iqubic> How the hell does that work?
23:19:54 <koz_> iqubic: I don't understand the question.
23:20:02 <koz_> EvanR: If they're not visible, I believe coerce will fail.
23:20:06 <koz_> (I could be wrong on that though)
23:20:20 <Lears> Coercible instances aren't generated when the constructors aren't in scope, or else opaque newtypes would all break.
23:20:22 <koz_> Again, if you're that concerned about abuse of your data types, just assign the roles manually.
23:20:30 <koz_> Lears: Thanks - that's what I was looking for.
23:20:35 <EvanR> you're talking about your newtype wrapper constructor right
23:20:40 <koz_> EvanR: I was, yes.
23:20:43 <EvanR> ok
23:21:19 <koz_> Sorry if I was unclear.
23:22:31 <EvanR> % :t coerce (proxy :: Proxy Char) :: Proxy Int
23:22:32 <yahb> EvanR: ; <interactive>:1:9: error:; * Variable not in scope: proxy :: Proxy Char; * Perhaps you meant one of these: data constructor `Proxy' (imported from Data.Data), `proxy#' (imported from GHC.Exts)
23:22:45 <EvanR> % :t coerce (Proxy :: Proxy Char) :: Proxy Int
23:22:45 <yahb> EvanR: Proxy Int
23:23:05 <koz_> Why stop there?
23:23:14 <koz_> % :t coerce (Proxy :: Proxy Void) :: Proxy Int
23:23:15 <yahb> koz_: Proxy Int
23:23:16 <koz_> :D
23:24:15 <koz_> % :t Sum
23:24:15 <yahb> koz_: a -> Sum a
23:24:34 <koz_> % :t coerce [Sum 4, Sum 5, Sum 6] :: [Int]
23:24:34 <yahb> koz_: ; <interactive>:1:1: error:; * Couldn't match representation of type `Integer' with that of `Int' arising from a use of `coerce'; * In the expression: coerce [Sum 4, Sum 5, Sum 6] :: [Int]
23:24:41 <koz_> Argh, dammit.
23:24:55 <koz_> % :t coerce ([Sum 4, Sum 5, Sum 6] :: [Sum Int]) :: [Int]
23:24:56 <yahb> koz_: [Int]
23:24:58 <koz_> :D
23:25:06 <EvanR> handy, i guess?
23:25:14 <koz_> EvanR: Not only that, but a guaranteed no-op.
23:25:24 <koz_> Unlike, for example, fmap getSum or something.
23:25:38 <EvanR> really... 
23:25:39 <koz_> (this is the primary motivation given in the wiki page on Coercible I believe)
23:25:57 <koz_> It also works through any number of levels.
23:26:05 <koz_> % :t Down
23:26:05 <yahb> koz_: a -> Down a
23:26:22 <EvanR> the lengths we go through so that nothing happens at runtime :)
23:26:26 <koz_> % :t coerce ([Down (Sum 4), Down (Sum 5), Down (Sum 6)] :: [Down (Sum Int)]) :: [Int]
23:26:26 <yahb> koz_: [Int]
23:26:36 <koz_> Tear apart dem newtypes.
23:26:52 <EvanR> soon ghc will achieve support for "at runtime absolutely nothing happens"
23:27:04 <EvanR> it will be quite complex i'm sure
23:27:12 <koz_> EvanR: I believe the quote you were fishing for is "'But it doesn't do anything!' 'No, it _does nothing_.'"
23:27:43 <EvanR> what's that from
23:27:49 <koz_> EvanR: An MtG card. :P
23:27:57 <EvanR> shoulda known
23:28:21 <EvanR> % :t getDown
23:28:21 <yahb> EvanR: ; <interactive>:1:1: error: Variable not in scope: getDown
23:28:22 <koz_> Null Rod.
23:28:33 <koz_> EvanR: If only.
23:28:37 <koz_> :t unDown
23:28:38 <lambdabot> error:
23:28:38 <lambdabot>     • Variable not in scope: unDown
23:28:38 <lambdabot>     • Perhaps you meant one of these:
23:28:41 <koz_> Argh.
23:28:56 <EvanR> fallDown? 
23:29:02 <koz_> jle` joked in a tweet that the lack of getDown is a missed opportunity.
23:29:03 <EvanR> callDown
23:29:16 <EvanR> rollDown
23:29:22 <iqubic> What is down?
23:29:32 <EvanR> % :t unDown
23:29:33 <yahb> EvanR: ; <interactive>:1:1: error:; * Variable not in scope: unDown; * Perhaps you meant one of these: data constructor `Down' (imported from Data.Ord), `S.union' (imported from Data.Set), `IS.union' (imported from Data.IntSet)
23:29:55 <koz_> There's no unwrapped function.
23:30:00 <koz_> Well, you can cook one as so
23:30:00 <EvanR> if it has no accessor... there is still time to add getDown
23:30:02 <koz_> :t op
23:30:03 <lambdabot> Wrapped s => (Unwrapped s -> s) -> s -> Unwrapped s
23:30:08 <koz_> NOT THAT OP ARGH
23:30:16 <koz_> % import qualified CoercibleUtils as CU
23:30:16 <yahb> koz_: ; <no location info>: error:; Could not find module `CoercibleUtils'; It is not a module in the current program, or in any known package.
23:30:20 <koz_> DOUBLE ARGH
23:30:23 <koz_> Although...
23:30:25 <koz_> :t op Down
23:30:26 <EvanR> power overwhelming
23:30:27 <lambdabot> Down a -> a
23:30:31 <koz_> Works!
23:30:38 <koz_> % :t op Down
23:30:38 <yahb> koz_: Down a -> a
23:30:45 <koz_> % op Down (Down 10)
23:30:45 <yahb> koz_: 10
23:30:49 <iqubic> What does that op do?
23:30:58 <koz_> iqubic: 'reverses' a newtype constructor.
23:30:58 <iqubic> :t op Last
23:31:00 <lambdabot> Last a -> Maybe a
23:31:02 <koz_> % :t Down
23:31:02 <yahb> koz_: a -> Down a
23:31:08 <koz_> % :t op Down
23:31:08 <yahb> koz_: Down a -> a
23:31:28 <iqubic> I'm confused but why my Last thing there returns a Maybe.
23:31:31 <EvanR> :k Op
23:31:31 <koz_> There's an equivalent in CoercibleUtils which uses Coercible to burn out the wrapper.
23:31:33 <lambdabot> * -> * -> *
23:31:53 <koz_> iqubic: because the op here is the lens one, and it's more elaborate.
23:31:58 <edwardk> > log (1 + 2 + 3) == log 1 + log 2 + log 3
23:31:58 <koz_> It _happens_ to coincide for Down.
23:32:00 <lambdabot>  True
23:32:13 <koz_> edwardk: The floating-point deities have been kind today.
23:32:21 <koz_> (or not)
23:32:24 <EvanR> wth
23:32:36 <koz_> > log (1 * 2 * 3) == log 1 + log 2 + log 3
23:32:39 <lambdabot>  True
23:32:40 <EvanR> that is not the law of logs i remember in school
23:32:40 <koz_> :D
23:32:56 <koz_> EvanR: This only works because 1 + 2 + 3 == 1 * 2 * 3
23:32:59 <iqubic> > 1 + 2 + 3 == 1 * 2 * 3
23:32:59 <edwardk> EvanR: koz got it =)
23:33:00 <lambdabot>  True
23:33:22 <koz_> Does this mean I kept up with edwardk?
23:33:25 <EvanR> i'm glad no one showed me that in class... i would have been confucious
23:33:28 <edwardk> in this one
23:33:33 <edwardk> koz++
23:33:34 <koz_> When do I finally understand coalgebra costate comonads? :P
23:33:47 <edwardk> when you learn that costate comonad coalgebras are a dead end
23:34:00 <EvanR> > sqrt (1 + 2) == sqrt 1 + sqrt 2
23:34:02 <lambdabot>  False
23:34:11 <koz_> edwardk: Isn't a costate comonad coalgebra getter and setter technology for Haskell, according to PLTBorat?
23:34:43 <iqubic> EvanR: How does a misleading fact about logs turn you into a Chinese philosopher?
23:35:00 <koz_> iqubic: Have you heard of this concept termed the 'pun'?
23:35:02 <edwardk> koz_: the encoding of lenses as costate comonad coalgebras was how roconnor originally pitched them iirc. the problem with that view is it sort of relies on a set of cosmic coincidences and doesn't generalize to other notions of lenses/prisms/optics
23:35:20 <koz_> edwardk: So I guess profunctor optics are the evolved form of this idea?
23:35:21 <edwardk> s -> a   and    s -> a -> s   have a common prefix leading to s -> (a, a -> s)     or s -> Store a s
23:35:25 <edwardk> yeah
23:35:29 <koz_> edwardk: Ah.
23:35:42 <edwardk> but when you go to turn that thing into laws for a prism you don't get a common prefix
23:36:03 <edwardk> it just happens because we have products and an internal hom that that encoding worked out for the one case of "lenses" into (,)
23:36:15 <iqubic> I love looking at Lenses as Pretexts, and Traversals as Bazaars. But that's most likely too obscure for right now.
23:36:17 <edwardk> but we don't have coexponentials, so we can't do it for sums
23:36:22 <koz_> Is it bizarre that I actually understand how each part of that fits into the 'costate comonad coalgebra' thing?
23:36:33 <edwardk> there you have it
23:36:40 <iqubic> No. I also understand each part of that.
23:36:56 <koz_> iqubic: I meant 'vis a vis the types Edward just gave us'.
23:37:13 <edwardk> the profunctor optics thing is also a bit of a dead end, but its the one we can encode in haskell/purescript
23:37:30 <koz_> edwardk: Why do you consider profunctor optics a bit of a dead end?
23:37:39 <edwardk> koz_: because its a local optima of a sort
23:37:43 <iqubic> koz_: I know what you referring to. I also understand it too.
23:37:49 <koz_> iqubic: :D
23:37:52 <edwardk> it doesn't capture the lens laws directly, you still need to impose them
23:38:18 <edwardk> now if you require that the morphisms you use to map over both halves of the profunctors are isomorphisms and that you just use one side of them the laws come along for free
23:38:35 <koz_> But isn't that really restrictive?
23:38:40 <edwardk> that gets you pretty close to the phi_i :: S_i <-> (C * A_i) story
23:38:41 <edwardk> no
23:38:46 <edwardk> that is _exactly_ the lens laws
23:39:57 <koz_> On a completely different note - who (used to, seemingly) run the plt_borat Twitter?
23:40:06 <edwardk> start with a family of isomophisms of that form, and you get lenses they compose by a sort of pullback, a lens from S to A  composes with one from U to V wherever A_i = U_j, so pullback on that central square and you get a subset of indices i*j where that works
23:40:09 <edwardk> no idea
23:40:21 <koz_> I am highly suspicious that it's someone here.
23:40:22 <edwardk> i also noted that haskell ceo started back up
23:40:59 <EvanR> https://danieljharvey.github.io/images/profunctor-optics.png
23:41:09 <edwardk> anyways the reason why i liked the iso story is that if you relax and allow a section retract pair in one direction or the other it corresponds directly to dropping the first or second lens laws
23:41:35 <koz_> EvanR: Lawl.
23:42:17 <iqubic> I just found out that this exist, and I have no idea why: https://github.com/ekmett/lens/blob/master/examples/Pong.hs
23:42:58 <koz_> iqubic: Why you just found out, or why it exists?
23:43:03 <edwardk> then from there the next step is to play games with what i consider 'indexed groupoid optics' where we note that by taking just isomorphisms we're looking at Core(Hask), then profunctors Core(Hask^op) * Core(Hask) -> Hask are isomorphic to Core(Hask) * Core(Hask) -> Hask   or Core(Hask)^2 -> Hask  -- and there is nothing special about '2' there, so why not allow whatever indexing category you want, using the same pullback-like 
23:43:03 <edwardk> composition, and profunctors never even appear in the narrative
23:43:14 <edwardk> they are an accident in that they are the simplest thing that allows types to change
23:43:44 <edwardk> just like store comonad coalgebras were an accident implied by (,) e having a right adjoint
23:43:47 <iqubic> koz_: I have no idea why that exists.
23:44:06 <koz_> iqubic: As an example of lens library use, I'd imagine.
23:44:09 <iqubic> I see.
23:44:21 <edwardk> iqubic: it was a nice little self contained lens example that was written by a #haskell'er
23:44:40 <edwardk> i moved it into the library along with a bunch of brainfuck interpreter examples and other things of the sort
23:45:11 <edwardk> it was more or less the first code anybody had seen that used lens's ability to work with state
23:45:13 <EvanR> can indexed groupoid optics be encoded in haskell
23:45:19 <iqubic> I'm totally lost by this complex Catagory Theory conversation.
23:45:22 <edwardk> EvanR: nope
23:45:34 <iqubic> I'm not even going to try to understand it right now.
23:45:35 <EvanR> cool
23:46:02 <koz_> iqubic: You are experiencing what I term 'Edward Lag'.
23:46:03 <EvanR> not sure i believe you :)
23:46:03 <edwardk> which is one reason why this is more of a theoretical curiosity, but i hoold it up more for the pure mathematician / category theorists who are trying to use lenses for things like neural network training, or other such activities
23:46:21 <koz_> I'm _only just_ getting past Edward Lag myself.
23:46:35 <edwardk> koz_: sweet. time for me to up the baud rate
23:46:48 <koz_> edwardk: Yamete, Edward-senpai! :P
23:47:13 <koz_> (I apologize sincerely for that, it was awful and I'm in a silly mood)
23:47:17 <edwardk> =P
23:47:33 <iqubic> Edward Lag is a real thing, and I am indeed experiencing it.
23:47:43 <koz_> iqubic: Get used to it.
23:48:09 <iqubic> I have.
23:48:22 <iqubic> Edwardk is way smarter than any of us here.
23:48:38 <koz_> In terms of applying category theory to Haskell, I suspect that to be true.
23:48:48 <MarcelineVQ> idk, I'm pretty smart, I made a back scratcher out of a cardboard tube.
23:49:21 <MarcelineVQ> I bet edwardk has to pay for back scratchers
23:49:35 <koz_> At the end of the day, I enjoy Haskell because I can be completely idiotic and GHC will gently correct my ways.
23:50:55 <iqubic> GHC's type checker is excellent.
23:50:55 <edwardk> MarcelineVQ: i married mine
23:51:15 <iqubic> I tried learning Scala the other day. Scala's type checker is terrible.
23:51:26 <iqubic> I stopped learning Scala.
23:52:04 <EvanR> i learned to stop learning scala and worry
23:52:17 <EvanR> ^how
23:52:48 <iqubic> I honestly worry that Scala is turning people off of Functional Programing.
23:52:55 <iqubic> But that's neither here nor there.
23:53:03 <edwardk> i had to write some code on the jvm over the last month or so, thankfully scala wasn't up to the task, so i was able to learn something a little new, even if kotlin is a mess, its not scala
23:53:46 <EvanR> how many lens libraries are there now?
23:54:04 <EvanR> i think my dog has one now
23:54:22 <koz_> Scala is something I took one brief look at and ran back to other languages.
23:54:26 <edwardk> there are something like 2^9 subsets of lens that folks might consider "reasonable" so in the limit i expect we'll evolve roughly that many
23:54:41 <iqubic> I know there's Edwardk's ibrary, plus one that calls itself optics.
23:54:56 <EvanR> i just ran into "mezzolens"
23:55:53 <edwardk> reasonable-lens, data-lens, lens, fields, optics, microlens, totally-not-judgementally-named-lens...
23:55:58 <iqubic> Reminds me of that XKCD comic about competing standards: https://xkcd.com/927/
23:56:01 <EvanR> i'm glad they seem to be sharing vocabulary words good job edwardk 
23:56:08 <edwardk> happy to help
23:56:36 <iqubic> lens-aeson
23:56:48 <iqubic> For all your JSON needs.
23:57:08 <edwardk> lens-aeson isn't really a lens library per se as a component of lens that got factored out into its own library when aeson didn't go into the haskell platform, iirc
23:57:19 <koz_> What's a simple way to write a compare for Vectors which compares in colex rather than lex order?
23:57:40 <iqubic> What are lex and colex?
23:57:41 <koz_> I'm having a massive brain fail.
23:57:55 <maerwald> iqubic: optics is quite nice
23:58:06 <koz_> iqubic: Lex is lexicographical order (which is left to right), colex is co-lexicographical order (right-to-left).
23:58:20 <edwardk> colex = Dual Ordering using the monoids from base
23:58:26 <maerwald> I'd say the only real replacement for lens. Because it can be reasonably used as a drop-in replacement
23:58:42 <maerwald> with functions converting to and from van laarhoven representation
23:58:43 <koz_> edwardk: Thanks, that's exactly what I needed.
23:58:45 <edwardk> but the mess is the indexing
23:58:57 <koz_> edwardk: I guess I can foldMap that?
23:59:09 <edwardk> so if you need to support different lengths  you'll need to be careful
23:59:14 <maerwald> so you can actually mix lens and optics (but probably with performance penalty)
23:59:17 <edwardk> nah, because it takes two of them
23:59:17 <koz_> edwardk: My lengths are the same.
23:59:30 <edwardk> ok, then in that case you can basically zipWith that and fold over the result
23:59:39 <koz_> edwardk: Thank you - that's perfect.
23:59:40 <edwardk> kind of a mess
23:59:50 <koz_> edwardk: It's fine, it's my chance to be pointless af. :P
23:59:55 <edwardk> k
