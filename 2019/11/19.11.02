00:24:53 <learninghaskell> Hi, guys, i have a question
00:25:03 <learninghaskell> This works: length . map (*2) $  [1,2,3]
00:25:20 <learninghaskell> This does not: length . map (*2) [1,2,3]
00:25:32 <learninghaskell> why?
00:25:48 <f-a> learninghaskell: "space" (function application) has higher priority than anything
00:26:08 <learninghaskell> applying . to lenght and map and (*2) should return a function pointer, which then should apply to last parameter
00:26:26 <learninghaskell> Ohh i see
00:26:32 <f-a> so let's see what you a- yeah
00:26:48 <learninghaskell> so it is like this in this case : length . (map (*2) [1,2,3])
00:26:56 <f-a> yep
00:27:13 <learninghaskell> this is why it is not working because of space, it first calls map, which doe snot return function pointer. 
00:27:14 <learninghaskell> I see
00:27:16 <learninghaskell>  thanks a lot
00:27:26 <f-a> no worries, enjoy your learning!
00:43:48 <learninghaskell> f-a can i ask a similar question in the same spirit?
00:44:02 <f-a> learninghaskell: of course!
00:44:28 <f-a> and since we are 1500 here, someone is bound to answer =D
00:44:49 <learninghaskell> I typed this : take 10 . iterate (*2) 1 -- Now, i understand why this is not working. because things at the right of . are not returning function pointer
00:44:59 <learninghaskell> that being said, I can not decipher the following error:
00:45:11 <learninghaskell>     • Couldn't match expected type ‘a -> [a1]’                  with actual type ‘[Integer]’
00:45:55 <learninghaskell> shouldn't it be: could not match (a -> b) -> b with actual type [Integer]
00:46:39 <f-a> well
00:46:42 <f-a> :t (.)
00:46:44 <lambdabot> (b -> c) -> (a -> b) -> a -> c
00:46:59 <f-a> (.) has 2 arguments, right?
00:47:05 <f-a> sorry, 3
00:47:10 <learninghaskell> yup 3 :D
00:47:32 <f-a> and if we apply take 10, like this
00:47:36 <f-a> :t (.) take 10
00:47:37 <lambdabot> Num (a1 -> Int) => a1 -> [a2] -> [a2]
00:47:50 <f-a> then you need a             ^
00:47:52 <f-a> but
00:47:59 <f-a> you are passing a [Integer]
00:48:02 <f-a> and ghci complains
00:48:24 <f-a> makes sense?
00:48:27 <learninghaskell> hmmm, let me hit my head on the wall a little bit more :D
00:48:32 <learninghaskell> thanks for the answer though. 
00:50:21 <f-a> yeah, as usual I invoked the wrong line
00:50:37 <f-a> :t (take 10 .)
00:50:38 <lambdabot> (a1 -> [a2]) -> a1 -> [a2]
00:50:40 <f-a> this makes more sense
00:50:59 <learninghaskell> Yup
00:51:01 <f-a> so ghci is expecting
00:51:09 <f-a> 1. (a1 -> [a2])
00:51:40 <learninghaskell> Yup
00:51:43 <f-a> in fact, this works
00:51:45 <f-a> > (take 10 . iterate (*2)) 1
00:51:47 <lambdabot>  [1,2,4,8,16,32,64,128,256,512]
00:52:10 <learninghaskell> yeah, i figured how to make it work. I just cant understand the error
00:52:18 <learninghaskell>     • Couldn't match expected type ‘a -> [a1]’                  with actual type ‘[Integer]’
00:52:28 <learninghaskell> this also works btw
00:52:33 <f-a> learninghaskell: every ghci error is pretty simple
00:52:38 <learninghaskell> > take 10 . iterate (*2) $ 1
00:52:39 <lambdabot>  [1,2,4,8,16,32,64,128,256,512]
00:52:41 <f-a> indeed
00:53:24 <f-a> 1. go to the specified line/column (easier if you have saved the function in a file, but column 11 is `iterate`)
00:53:39 <f-a> 2. see what is written there
00:53:47 <f-a> in this case : iterate (*2) 1
00:53:51 <f-a> which has type
00:53:52 <f-a> :t iterate (*2) 1
00:53:53 <lambdabot> Num a => [a]
00:54:02 <f-a> (defaulting to [Integer])
00:54:16 <f-a> so you are putting an [Integer] there and that makes no sense to ghci
00:54:35 <f-a> would you ever write `take 10 . [1, 2, 3]`?
00:54:38 <learninghaskell> Yup, i get that part as well :)
00:54:51 <learninghaskell> I just cant see why ghci is expecting : a -> [a1]
00:54:56 <f-a> ok
00:55:10 <learninghaskell> instead of (a1 -> [a2])
00:56:36 <learninghaskell> I think the error message should be "(a -> [a1])" instead of just "a -> [a1]"
00:56:57 <f-a> it is the same learninghaskell 
00:57:06 <learninghaskell> hmmmm
00:57:14 <f-a> similar to writing "3 + 5"
00:57:28 <f-a> while you would write "2 * (3 + 5)" in a bigger expression
00:57:34 <f-a> if I understood your question correctly
00:58:32 <learninghaskell> hmmm, ok i kind of get the idea i think... I have been thinking that (a -> b) meant that it was a function pointer where as a -> b were normal types... I think this kind of thinking is wrong in haskel..
00:58:48 <f-a> look
00:58:53 <f-a> say you have a signature like
00:58:56 <f-a> a -> b -> c
00:59:00 <f-a> in reality it is
00:59:00 <learninghaskell> yup
00:59:05 <f-a> a -> (b -> c)
00:59:10 <f-a> singe -> is right associative
00:59:13 <f-a> *since
00:59:22 <f-a> so we can omit parentheses
00:59:34 <f-a> and that's why this is different:
00:59:34 <learninghaskell> i see
00:59:38 <f-a> (a -> b) -> c
00:59:45 <f-a> not sure what a function pointer is
00:59:48 <learninghaskell> ohh i get it now :D
00:59:51 <f-a> but remember
01:00:18 <f-a> yeah
01:00:31 <f-a> get used with it because with partial application you can do stuff like
01:00:35 <f-a> :t (5 +)
01:00:36 <lambdabot> Num a => a -> a
01:00:42 <f-a> :t (+)
01:00:43 <lambdabot> Num a => a -> a -> a
01:00:50 <learninghaskell> Thanks a lot buddy, i will name my first born f-a :P  
01:00:52 <f-a> see? we are partially applying it
01:00:53 <f-a> haha
01:00:59 <learninghaskell> I see
01:11:48 <learninghaskell> I just realized something... Since space has higher precedence than '.', we can never do " f g x". We always have to do "(f . g) x"  or "f . g $ x". Right?
01:11:59 <learninghaskell> I just realized something... Since space has higher precedence than '.', we can never do " f . g x". We always have to do "(f . g) x"  or "f . g $ x". Right?
01:13:24 <f-a> yeah
01:13:42 <f-a> learninghaskell: or simply
01:13:44 <f-a> f (g x)
01:14:45 <learninghaskell> nice :D
01:14:47 <learninghaskell> thanks again
01:16:34 <learninghaskell> have a good  night guys!
01:20:31 <Nachtgespenst> Well, "never" isn't true for either "f g x" or "f . g x"
01:29:12 <ggVGc> how could this be written in a nicer way? https://gist.github.com/85c046793dea87e1a1fbf4496581945d
01:34:12 <f-a> ggVGc: not easy to see what the code does!
01:35:49 <sm[m]> https://termbin.com/d5ri ?
01:36:08 <sm[m]> are /. and \. operators ?
01:36:35 <kuribas> does ghc offer a way to "unpeal" a newtype?  To show what type is inside it?
01:36:46 <kuribas> sm[m]: yes, but not from the standard library
01:37:16 <kuribas> sm[m]: any string of (some) non-numeric characters can be an operator
01:38:38 <sm[m]> these ones are from.. data-diverse ?
01:39:03 <f-a> kuribas: you mean an accessor? like runSomething :: Xyz -> Foo?
01:39:32 <kuribas> f-a: more like a ghci command
01:39:42 <kuribas> like :i or :k
01:41:27 <f-a> kuribas: :i should do the trick
01:42:02 <f-a> or do you mean "something I can use at runtime"?
01:42:04 <f-a> if so, no
01:42:10 <f-a> types get discarded
01:42:24 <kuribas> no, to get the real type of something like: StateT s Cont a
01:42:37 <kuribas> or the unwrapped type or so...
01:42:42 <f-a> λ> :i State
01:42:43 <f-a> type State s = StateT s Data.Functor.Identity.Identity :: * -> * -- Defined in ‘Control.Monad.Trans.State.Lazy’
01:43:12 <f-a> and then if you :i again on StateT -> StateT {runStateT :: s -> m (a, s)}
01:43:37 <kuribas> that's manual
01:43:44 <kuribas> I mean something automatic
01:44:02 <kuribas> but I suppose ghc eliminates that information accross module boundaries
01:44:31 <f-a> yep, once it is compiled, type infos end up in the bin
01:45:06 <kuribas> still it would be useful inside a module
01:45:16 <sm[m]> data-diverse needs a better doc somehow. ggVGc when you get back I'm curious to know what \., /., and |> do here
01:45:57 <f-a> sm[m]: and what's their name in plain english ;P
01:46:15 <otwieracz> Hey!
01:47:25 <kuribas> I like user definable operators, but I think they are overused, like in lens
01:49:28 <kuribas> Oh Interesting, "StateT s Cont a" is isomorphic to "ContT (Reader s) a"
01:49:42 <otwieracz> Is there any channel dedicated to newbie questions, or should I try asking here? I am having really hard time wrapping my head around IO in Haskell (and I just started scraching it's surface).
01:49:56 <kuribas> otwieracz: there is #haskell-beginners, but you can ask here to
01:50:05 <f-a> otwieracz: no worries, ask here
01:50:08 <kuribas> we are happy to help you
01:50:44 <otwieracz> I am curious about cases like: I've got two functions: F :: String -> String and G :: String -> IO String.
01:51:08 <otwieracz> I'd like to call, for example, F G "Foo"
01:51:35 <otwieracz> But I am not sure if this requires F to be also "impure" (or however it's called)
01:51:46 <otwieracz> But F resuluts does not depend on external world.'
01:52:13 <otwieracz> But obviously it won't work, as F is expecting String and not IO String returned by G.
01:52:31 <f-a> otwieracz: remember that io is a Funtor
01:52:32 <f-a> so
01:52:34 <f-a> :t length
01:52:36 <lambdabot> Foldable t => t a -> Int
01:52:38 <f-a> and
01:52:41 <f-a> :t fmap length getLine
01:52:43 <lambdabot> IO Int
01:52:51 <kuribas> otwieracz: you mean f (g "foo")?
01:52:59 <kuribas> otwieracz: functions start with lowercase
01:53:00 <f-a> where length is pure and getline is not
01:53:06 <otwieracz> kuribas: yes yes, sorry
01:53:14 <kuribas> otwieracz: unless it's a constructor :)
01:53:21 <kuribas> then they start with uppercase
01:55:20 <kuribas> otwieracz: so you want to turn "f :: String -> String" into "f' :: IO String -> IO String", right?
01:55:54 <kuribas> otwieracz: like f-a says, that's what Functor is for
01:55:57 <kuribas> :t fmap
01:55:59 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:56:22 <kuribas> otwieracz: replace f with IO, and you get (a -> b) -> (IO a -> IO b)
01:56:57 <kuribas> otwieracz: then set a = b = String, and you get (String -> String) -> (IO String -> IO String)
01:57:25 <otwieracz>  OK, I need to think about that :)
01:57:53 <f-a> otwieracz: do you know / are you comfy with Functors?
01:57:57 <kuribas> otwieracz: fmap is polymorphic, and a more specialised version of it is "(String -> String) -> (IO String -> IO String)"
01:58:21 <kuribas> otwieracz: do you know polymorphism?
01:58:56 <otwieracz> In Haskell? Not yet.
01:59:11 <kuribas> otwieracz: ok, so then it's probably a bit over your head ;)
02:00:18 <kuribas> otwieracz: you could use do notation as well: do x <- f "foo"; return (g x)
02:00:48 <otwieracz> Hmmm, I thought I tried it after reading Gentle introduction to IO.
02:00:56 <otwieracz> But something wasn't working. Let me try again..
02:01:14 <kuribas> otwieracz: did you forget return perhaps?  Or parens?
02:01:25 <kuribas> "return g x" will not work
02:01:48 <otwieracz> Let me try again..
02:02:37 <otwieracz> OK, I see what I was doing wrong. That was my misunderstanding.
02:02:47 <otwieracz> `do`-way definitely works too.
02:02:47 <kuribas> So "StateT s Cont a = s -> (((s, a) -> r) -> r)", and "ContT (Reader s) a = ((a -> (s -> r)) -> s -> r)"
02:03:24 <kuribas> after rewriting they become ((a -> s -> r) -> s -> r)
02:04:07 <kuribas> so applies state over the continuation monad gets you the contination monad over reader
02:04:15 <kuribas> which is pretty interesting
02:06:11 <otwieracz> Thank you very much for help!
02:08:12 * hackage QuickCheck-GenT 0.2.2 - A GenT monad transformer for QuickCheck library.  https://hackage.haskell.org/package/QuickCheck-GenT-0.2.2 (NikitaVolkov)
02:27:40 <jzyamateur> what are some use cases for using `Constant` and `Identity` functors?
02:33:12 <lavalike> jzyamateur: very many monads you end up using from base are defined as transformers over Identity
02:33:26 <lavalike> @src State
02:33:26 <lambdabot> type State s = StateT s Identity
02:33:26 <lambdabot> --OR
02:33:26 <lambdabot> data State s a = State { runState :: s -> (a, s) }
02:34:41 <kuribas> jzyamateur: lens uses them
02:36:04 <kuribas> jzyamateur: the const functor takes the focus, and ignores the context, so when using it as a traversal it is a"get" over the focus.
02:36:07 <jzyamateur> I was trying to know if there are cases like  "when you need to ... you can use `Identity` or `Constant`". I am yet to learn/read about lens or State/StateTransformer.
02:36:35 <kuribas> I don't think Const is used that often outside lens
02:36:48 <aviD> Does a `MonadIO m` constraint prevent `MonadError MyError m`?
02:36:49 <kuribas> but Identity is fairly common, like lavalike says
02:37:21 <kuribas> jzyamateur: it allows you to "remove", so to speak, any monadic of functorial context.
02:37:34 <jzyamateur> got it
02:37:41 <kuribas> jzyamateur: since "Identity a" is isomorphic to "a"
02:38:01 <kuribas> for example fmap becomes id: (a -> b) -> (Identity a -> Identity b)
02:40:30 <lavalike> if you hang around long enough in here you'll see someone golf a solution to some problem using Constant
02:48:57 <kuribas> lavalike: haha, right
03:12:27 <equivrel> Hello, is there a GHC extension that would let me do (irrefutable) pattern matching in a monadic bind? i.e. so I can do Foo a <- get
03:12:36 <equivrel> I vaguely remember such a thing but can't find it atm...
03:13:27 <equivrel> i.e. something that desugars to {_a <- get; let Foo a = _a;}
03:15:56 <Rembane> I suppose you aren't looking for MonadFail? 
03:17:52 <equivrel> Rembane: no I think I am just looking for this syntactic sugar for all dos.
03:20:21 <equivrel> OK actually I think I was being silly and that you can already pattern match on the LHS of <-
03:20:43 <equivrel> not sure what I was thinking about, thanks for pointing out I might be confused :)
03:23:58 <merijn> equivrel: Aren't you simply thinking of irrefutable patterns?
03:24:43 <equivrel> merijn: Yes, I am. It's just that I had a recollection that ghc didn't allow me to do irrefutable patterns on the LHS of a <- like I could on the LHS of a =
03:24:45 <merijn> equivrel: You've always been able to pattern match on the LHS of <- :) (although as of the latest GHC incomplete patterns will infer MonadFail, rather than Monad)
03:25:56 <equivrel> potentially what I had misremembered is that it's inconvenient to do a case on a <-, and maybe there is a language extension for that? 
03:26:16 <merijn> equivrel: Maybe you're thinking of LambdaCase?
03:26:43 <merijn> That lets you turn "do { x <- foo; case x of ... }" into "foo >>= \case ..."
03:28:35 <equivrel> I know and use LambdaCase, though I think it's a little inconvenient if I want `do { x <- foo; let y = case x of ...; }`
03:28:55 <equivrel> do you know of a way to do it without introducing a spurious variable name?
03:29:01 <merijn> equivrel: "y <- foo >>= \case .."?
03:29:10 <equivrel> ah, right
03:29:16 <equivrel> yeah I guess that is nice enough
03:29:18 <equivrel> thanks :)
03:29:53 <Rembane> equivrel: If you ever want more inspiration regarding LambdaCase: http://storm-country.com/blog/LambdaCase
03:30:44 <equivrel> Rembance: yes, that was the blog post I was (very vaguely) remembering when I initially asked this question. Thanks!
03:31:19 <equivrel> the "case-inside-monadic-value" idiom
03:31:48 <Rembane> Sweet! ^^
03:38:30 <merijn> glguy: That hexfloat parser you linked yesterday, how efficient is it?
03:43:24 <Uniaika> mpickering: thanks for organising the Bristol hackathon! 
03:50:05 <haskellNewbie> Hi there... 
03:52:14 <haskellNewbie> There's something I don't understand. I've just installed ghc v8.8.1, with chocolatey, and I have the message " The install of ghc was successful."
03:53:27 <haskellNewbie> So it seems good, but when I ask "ghc --version" my version is still "The Glorious Glasgow Haskell Compilation System, version 8.6.5"
03:53:56 <haskellNewbie> How is that possible, is there a step I missed?
03:54:32 <f-a> haskellNewbie: no idea what chocolatey is, but I suspect you need to put some bin folder in your $PATH
03:55:42 <haskellNewbie> f-a: I'm on windows 10n so chocolatey help for the installation of software.
03:56:39 <haskellNewbie> f(a: Chocolatey - the package manager for Windows.
03:56:48 <f-a> haskellNewbie: then I have really no idea, I am sorry dumped windows when vista came out. Stay put for a bit, there are 1.5k people here, someone will for sure have something useful to say
03:57:14 <haskellNewbie> f-a: sorry for the misspelling of you pseudo.
03:58:32 <haskellNewbie> f-a: thanks, I was thinking I probably missed a step after to config or something else like this.
03:59:20 <haskellNewbie> 1.5k people here: it's huge. :-)
03:59:43 <merijn> Does anyone know a package that properly implements a hexfloat parser?
03:59:56 <merijn> attoparsec/megaparsec/whatever, don't really care
04:03:31 <phadej> with chocolatey you definitely SHOULD NOT touch the PATH yourself
04:03:39 <phadej> except if you know what you are doing (which is the case)
04:04:18 <phadej> you might need to refreshenv to make PATH refresh
04:04:32 <haskellNewbie> Phadej: good to hear this. 
04:04:42 <phadej> https://hub.zhox.com/posts/introducing-haskell-dev/
04:05:16 <phadej> unfortunately I don't know how to choose default GHC (i.e. which ghc-8.6.5, ghc-8.8.1 or such is bound to `ghc`)
04:06:19 <phadej> haskellNewbie: maybe you have 32bit system, if you haven't ghc before that (it's mentioned in the blog post: ... As such the GHC 8.8.1 package will install GHC 8.6.5 on 32-bit machines so that you get a working compiler.)
04:06:54 <phadej> but I'm 100% sure the choco prints the very same note during installation
04:06:56 <haskellNewbie> Phadej: I have a 64 bit system
04:07:16 <phadej> how you installed 8.6.5 before?
04:07:36 <phadej> various installation methods don't really work well together
04:08:05 <phadej> I'd remove everything and use only choco from now on (as it works nicely)
04:08:06 <merijn> ugh...is parsec3-numbers really the only parser lib that knows how to handle hexfloats? :(
04:08:20 <haskellNewbie> Phadej: Well it was my first installation with the haskell platform.
04:08:32 <phadej> haskellNewbie: yes, don't mix installation methods
04:08:56 <phadej> remove both 8.8.1 installed with choco, and uninstall platform, and start from scratch
04:08:59 <phadej> "Windows <3"
04:10:26 <haskellNewbie> Phadej: I can do that, I'm not using haskell for production.
04:13:30 <haskellNewbie> Phadej: Thanks, it's a good advice which suits me. I'll do that.
04:14:27 <merijn> Man...this is the biggest disappointment I've had in the Haskell ecosystem in years >.<
04:15:14 <phadej> looks like not many need hexafloats :)
04:16:23 <phadej> hexdecimal floats are relatively new addition to GHC itself, 8.4.1 https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0037-hexFloats.rst
04:16:36 <merijn> phadej: Yes, which is itself rather a criminal oversight
04:16:54 <merijn> Considering hexfloats are literally the only possible way to safely serialise floats to text
04:18:07 <phadej> looks like they have been in C since C99
04:18:20 <merijn> The only thing I've found besides an inscrutable Parsec3 parser is HexFloat but that's "String -> Maybe Double" which doesn't bode well for performance
04:18:30 <merijn> phadej: They've been in IEEE-754 for ages too
04:18:46 <phadej> so, if nobody needs them, nobody adds support for them
04:19:14 <merijn> phadej: But I don't need more yaks like "implementing hexfloat parsing" >.>
04:19:51 <merijn> There's a MR to (finally) add a reader for them to Numeric, in GHC but that got bumped to GHC 8.12 milestone
04:20:42 <mpickering> Uniaika: no problem, hope you can make it
04:24:00 <Ariakenom> merijn: there is a library with the to be GHC implementation (I think) https://hackage.haskell.org/package/FloatingHex-0.4/docs/Data-Numbers-FloatingHex.html
04:24:42 <merijn> Ariakenom: Yes, I just mentioned that, but that's "String -> Maybe a" which doesn't spell good things for performance when I need to parse several billion of them
04:28:42 * hackage jsonpath 0.1.0.2 - Library to parse and execute JSONPath  https://hackage.haskell.org/package/jsonpath-0.1.0.2 (axeman)
04:44:44 <Rembane> I need a data structure that map between the constructors in a sum type and some other type, have you seen one of those?
04:51:22 <Rembane> Nevermind, I'll use a Data.Map instead and be very careful. 
04:56:00 <lavalike> Rembane: there are a bunch of generic machineries in ghc you could use, just like lens uses one to give you functions for each constructor
04:56:07 <Uniaika> mpickering: still hesitating between eurostar or flight from Charles-de-Gaulle :P 
04:56:23 <f-a> train pride
04:58:32 <Rembane> lavalike: That does sound interesting, I'll get back to it when I have more than two constructors, I think my primary concern right now is correctness and that I don't want to have a lookup that evaluates to a (Maybe ...) when I know that the content exists. 
05:33:42 * hackage lukko 0.1 - File locking  https://hackage.haskell.org/package/lukko-0.1 (phadej)
05:35:23 <lavalike> Rembane: you can use fromJust >:)
05:47:23 <Rembane> lavalike: I can, I just don't like it. :)
05:53:16 <erisco> Good morning!
05:53:28 <f-a> morgen
05:58:35 <fendor_> what was the easy to use parsing pacakge? parsec or megaparsec or something like that? performance doesnt matter
05:59:22 <f-a> fendor_: I find parsec most relaxing
05:59:56 <f-a> I switched to megaparsec which is a tad less friendly and somewhat more efficient
06:00:10 <fendor_> f-a, thanks! 
06:00:44 <fendor_> but have you heard about parsec3? ;D Must be three times better than the original
06:01:08 <f-a> hehe
06:04:36 <Rembane> fendor_: I prefer megaparsec, it doesn't drive me nuts anymore. 
06:06:32 <fendor_> let's which package has the better documentation to parse a simple file
06:12:35 <nil> If performance doesn't matter, I'd say ReadP is the easiest to use
06:14:33 <fendor_> nil, yeah, that looks nice as well
06:23:07 <Uniaika> megaparsec is a wonderful library
06:23:37 <Uniaika> I regret not being more proficient at it because I would rewrite so many Parsec tutorials in haskell books
06:36:36 <glguy> merijn: happy generates efficient parsers. It's linear in the input
06:41:10 <__monty__> merijn: I'm sorry for the delays on that MR : )
06:43:01 <merijn> __monty__: tbh I'd probably still want a direct parser one that operates on Text, so I'll add it to my list of "small feature patches to libraries to make some day" >.>
06:47:22 <glguy> It would be easy to have happy operate directly on Text
06:48:36 <merijn> glguy: I was meaning an *parsec implementation, but I don't have the time to write one now (or rather, I could write one, but testing it properly sounds like too much work atm >.>)
07:05:10 <Zemyla> Where is the GHCi config file?
07:05:28 <merijn> Zemyla: ~/.ghci ?
07:06:39 <Zemyla> Oh, right.
07:14:37 <maralorn> I have to say. I am not really satisfied with haskell-ci. Extending the jobs is not easy. The ghc-head option gives me GHC 8.7. The whole "language=C" and ubuntu lts stuff feels a bit awkward. And the job just fails because it can‘t find ghc? https://travis-ci.com/maralorn/haskell-taskwarrior/jobs/252034206
07:15:16 <maralorn> On the other hand: I have never used CI before. So probably haskell-ci is quite useful. And maybe I am just on a to old version.
07:15:25 <merijn> maralorn: If ghc-head gives 8.7 you need to update haskell-ci
07:16:01 <maralorn> Anyways I feel like doing all of this with nix would be awesome. Are there any examples of that?
07:17:06 <merijn> maralorn: Well, 1) why does "language=C" feel awkward, and 2) even if it is, why would that matter if you don't manually edit .travis.yml?
07:17:43 <maralorn> merijn: 1) Because I don‘t use C. But I admit, it doesn‘t matter.
07:18:14 <maralorn> Actually I should probably just be content with how it works.
07:18:31 <maralorn> I‘ll try to unstall a new version.
07:18:37 <merijn> maralorn: The "language=C" is just the way to get travis to not load language specific tooling because their Haskell tooling is super old and it loads it's own tooling from hvr's PPA instead
07:19:08 <merijn> So "language=haskell" would result in loading unnecessary tools and potentially hard to debug breakages if something ends up using travis' GHC/cabal instead of the PPA ones
07:31:43 <maralorn> merijn: Okay.
07:34:15 <maralorn> Is there a way to create a shell.nix in which I install packages via cabal? The haskell-ci from nixpkgs unstable is too old.
07:37:25 <srid> What's the recommended way to represent 'hour' (0-23) and 'minute' (0-59) types? There is http://hackage.haskell.org/package/o-clock - but it is not clear how you would represent the range constraint.
07:38:05 <sm[m]> Uniaika: please do provide updates for all the parsing tutorials :)
07:38:19 <erisco> srid, "smart constructors" and a newtype over Int is a good choice
07:38:27 <sm[m]> srid: start with the time library
07:39:15 <erisco> maybe there is an extension for overloaded integer literals, not sure, but would also be an option
07:39:46 <srid> I'd prefer a version that makes illegal values unrepresentable. Smart constructure will just throw a runtime error (afaiu)
07:40:19 <erisco> Not necessarily, no, they can just arbitrate how to map Int to Int/24
07:40:23 <merijn> maralorn: I don't use nix, so no clue
07:40:36 <erisco> Common options being clamping and modulus
07:40:38 <merijn> srid: Just use the time package?
07:40:55 <merijn> srid: Smart constructors should return "Maybe X"
07:41:00 <merijn> srid: Not throw
07:41:15 <erisco> Using Maybe is possible but I highly discourage it, based on my experience with that
07:41:17 <merijn> Having a throwing operation is, like, the opposite of a smart constructor >.>
07:41:26 <merijn> erisco: Why?
07:41:50 <merijn> Silently truncating/corrupting defeats the point of having smart constructors
07:41:55 <srid> merijn: sm[m] - which particular type from the `time` package represents 'hour' and 'minute' values (with the aforementioned constraint)?
07:41:57 <geekosaur> also you're not getting "unrepresentable" easily if at all with values coming from outside your program
07:42:02 <erisco> It is a massive inconvenience and really does nothing to help the problem of not throwing errors
07:42:12 <sm[m]> http://hackage.haskell.org/package/time-1.9.3/docs/Data-Time-LocalTime.html#t:TimeOfDay has the smart constructor makeTimeOfDayValid (returning a maybe)
07:42:17 <merijn> erisco: How is it an inconvenience?
07:42:32 <erisco> 9 times out of 10 you're writing  fromJust (hourFromInt 23)
07:42:39 <merijn> erisco: And the goal isn't "not throwing errors" the goal is "ensuring valid state"
07:42:47 <srid> sm[m]: thanks!
07:42:57 <srid> It is not ideal, but will do the job I guess
07:42:59 <merijn> erisco: You mean when writing literals in your code?
07:43:04 <erisco> absolutely
07:43:10 <merijn> erisco: Good news for you, I already solved that :)
07:43:14 <merijn> @hackage validated-literals
07:43:14 <lambdabot> http://hackage.haskell.org/package/validated-literals
07:43:15 <erisco> so did I
07:43:31 <merijn> erisco: That turns failed conversion of literals in code to compile time errors :p
07:43:47 <srid> geekosaur: i'm parsing these values from a text file. the parser will throw a parser error, but the rest of the program shouldn't have to deal with unrepresentable values (ideally speaking)
07:43:53 <merijn> erisco: Anyway, smart constructors are generally for converting runtime values, not literals in source code
07:44:18 <erisco> I disagree, but if that is how you see them, that's fine. I have little stake in what "smart constructor" means.
07:44:50 <erisco> To me, if something is a constructor, I should be able to write it literally
07:45:26 * geekosaur wans to say "liquid haskell" here. normal haskell will be painful no matter how you slice it (type level isn't easy to use and still has a fair amount of boilerplate, singletons notwithstanding)
07:46:03 <erisco> merijn, that is a nice use of TH. Well done.
07:46:25 <merijn> :)
07:46:35 <erisco> In PS I essentially wrote type level parsers on Symbol
07:46:48 <erisco> Imagine similar can be done in Haskell, but I haven't played with HS Symbols before.
07:46:57 <merijn> erisco: I invented exactly because I hated having to use fromJust when using smart constructors :p
07:47:28 <erisco> i.e. you write the literal as a string, and it is checked by instance resolution and converted to the appropriate value
07:48:24 <sm[m]> srid: in case you wonder, yes time is a big powerful confusing package but you can't avoid it so you might as well master it
07:49:02 <merijn> The confusing part isn't really the fault of the package, but the fault of time being complex
07:49:03 <sm[m]> there may be easier packages for specific tasks also, I don't know them
07:49:46 <sm[m]> agreed, but there's still room for improvement in time's UX
07:50:10 <erisco> merijn, and the other low tech approach I use, like I said, is just arbitrating a mapping from Int to Int/n, by clamping or modulus
07:50:20 <erisco> (or both)
07:52:03 <maralorn> merijn: That packages looks very cool. But I am a bit fuzzy on for what values one can use it. Can you just put anything in there, which returns a Maybe?
07:52:33 <merijn> maralorn: Pretty much
07:52:57 <maralorn> But you need to provide the instance yourself first?
07:53:10 <merijn> maralorn: There's examples on github
07:53:26 <merijn> maralorn: https://github.com/merijn/validated-literals/tree/master/examples
07:54:18 <merijn> The Lift instance is optional, but recommended (because if there's a Lift instance you can compile in the result, without it it resorts to redoing the conversion at runtime, so then it better be pure!)
07:54:19 <maralorn> merijn: Ah, nice
07:54:59 <merijn> maralorn: So if you write "foo :: Even; foo = $(validInteger 3)" it fails at compiletime
07:55:31 <merijn> But the validation function can be basically anything that's legal Haskell, including parsec parsers or whatever
07:57:37 <maralorn> I am always a bit fuzzy about runtime vs. compiletime. I mean I know what they mean, but I always wonder about how much ghc does at compile time and how much at runtime.
07:57:56 <merijn> maralorn: At runtime GHC does nothing
07:58:15 <merijn> maralorn: Because there is no GHC at runtime (well, unless you're using the GHC library)
07:58:28 <maralorn> Okay, yeah.
07:58:57 <maralorn> The questions how much of the execution does GHC do at compiletime.
07:59:10 <merijn> maralorn: Almost none
07:59:30 <maralorn> Like when I write "3 :: Even" it could just write a throw in the binary right?
07:59:58 <merijn> maralorn: No, because that wouldn't match the language spec
08:00:22 <maralorn> I see.
08:00:53 <maralorn> So if I want something like that, I have to do it manually with template Haskell?
08:01:21 <merijn> maralorn: What the meaning of Haskell code is is defined by the Haskell Report. This definition is rather lax so it leaves the compiler a lot of freedom to do thing, as long as it doesn't violate the definitions of the report
08:01:55 <merijn> maralorn: Yes. Template Haskell is effectively just "regular haskell that is run at compile time to generate the Haskell that you actually want to compile"
08:03:34 <merijn> maralorn: If I write "map (const True) [1..5]" then a compiler would be perfectly allowed to turn that into just a static list of [True,True,True,True,True] but it turns out that deciding when and how to evaluate code at compile time is...pretty damn tricky, so it's mostly not done that much
08:04:01 <maralorn> Because you can never be sure, that it terminates?
08:04:20 <merijn> maralorn: Well, also because people get annoyed if compiling a 200 line file takes 5 hours :)
08:04:52 <merijn> maralorn: So you gotta make the trade-off between "does this extra compile time actually produce significant performance benefit at runtime?"
08:05:26 <merijn> And obviously it only works if there's no input from files/sockets/etc. that you only know at runtime, etc.
08:08:00 <maralorn> Yeah, obviously.
08:09:24 <merijn> maralorn: The Haskell Report is suprisingly readable and that's the "One True Source" wrt "what does this Haskell code mean?" writing a compiler is just a game of "what's the most creative way we can implement a given meaning that's fast?"
08:09:25 <maralorn> I mean there is always the option to write your program as a lookup table on the input.^^
08:12:30 <maralorn> Could I do something like $([|fromJust ...|]) as an adhoc way to get that functionality?
08:13:31 <geekosaur> I think just the [| |] ?
08:13:58 <merijn> maralorn: At that point you might as well just use that library instead
08:14:19 <merijn> maralorn: Especially since the dependency footprint is trivial
08:14:33 <gobby> I'm having an issue when trying to insert a value into a postgres db with Persistent. I get ` Error was: Failed to parse Haskell type `Int64`; expected integer from database, but received: PersistNull`
08:14:37 <merijn> (basically zero, since it's just base and TH both of which ship with GHC :p)
08:15:12 <merijn> gobby: You managed to get a NULL in a column that's marked as not NULL in persistent
08:15:46 <gobby> merijn: its the id column. It's defined in my schema but not explicitly defined in persistent
08:16:33 <Uniaika> sm[m]: :( I don't have the bandwidth I had when I was 17 
08:16:41 <Uniaika> but if I come around doing that I'll ping you
08:16:49 <Uniaika> (or you'll see it on reddit)
08:17:40 <gobby> merijn: https://pastebin.com/EfKSgvCL
08:18:41 <merijn> gobby: You're only printing the migration, not running it there?
08:19:08 <merijn> Anyway, I haven't really used persistent-postgres, so not sure what might be going on
08:20:29 <gobby> merijn: ah ok. Thanks.
08:20:54 <geekosaur> at a guess, the id column needs to have some kind of autoincrement? (in postgres, use SERIAL instead of BIGINT)
08:21:09 <maralorn> merijn: Well it depends. On how often I need it. Writing an instance is still 5 to 10 lines.
08:21:15 <geekosaur> since the code is apparently trying to retrieve the assigned key
08:21:48 <merijn> maralorn: Minimal is really only 2 if you already have "String -> Maybe a" or something
08:22:32 <merijn> maralorn: You only need to prive a single function for the class (either fromLiteral or fromLiteralWithError) and you can just use an existing function there
08:23:07 <merijn> maralorn: "class Validate String Int where fromLiteral = readMaybe" would be a complete and working instance
08:26:37 <merijn> maralorn: And you need to define the "a -> Maybe b" function anyway to use your fromJust idea :p
08:28:20 <merijn> I'm lazy, therefore all my code is designed for lazy people ;)
08:29:06 <gobby> geekosaur thank you this fixed my issue!
08:32:33 <maralorn> merijn: Convincing
08:33:59 <merijn> maralorn: Well, that also requires a Lift instance for the type you're converting too, but 1) all types in base already have that and 2) in modern GHC you can use DeriveLift to derive it for your datatype (you probably want to use the default Lift based implementation in the class because it's more efficient anyway)
08:41:28 <sm[m]> Uniaika: i hear that
08:56:36 <aveltras> is there a preferred password hashing library nowadays ? (i only need to hash passwords for a web application)
08:59:03 <d34df00d> Hi!
08:59:08 <d34df00d> Haddock question here.
08:59:22 <d34df00d> Is there a way to avoid generating the documentation for a module that I partially export?
08:59:42 <d34df00d> So I do `import Foo as X hiding(a, b, c)` and I also have `module X` in my export list, so haddock generates documentation for ti.
09:00:19 <d34df00d> Is there a way to avoid this behaviour? The only thing that I could come up with is to have an internal module with the `hide` haddock option that reexports the parts that I need, but creating an extra proxy module just for the sake of it seems clumsy.
09:00:21 <merijn> d34df00d: You mean that it inline the docs for Foo in the module that re-exports it?
09:00:29 <d34df00d> merijn: yep.
09:00:39 <d34df00d> And I'd like to avoid that.
09:01:07 <GyroW> Hi, I was wondering the difference between a function like: "test1 = map (\x -> x == 3)" and "test2 y = map (\x -> x == 3) y"
09:01:28 <merijn> d34df00d: Not yet. By default it includes a link for completely re-exported modules, but inlines partial re-exports. There was an open issue to give more control over this, but afaik it's not finished yet
09:01:35 <GyroW> I'm new to haskell and want to know if there's any major difference in the 2 forms that, for all that I know, do the same
09:01:51 <d34df00d> merijn: would you suggest going this proxy hidden module route?
09:02:23 <merijn> GyroW: No differences that are relevant to beginners (there are some subtle differences if you dive into "how does GHC optimise this", etc. but those are hardly relevant to beginners :))
09:02:33 <d34df00d> merijn: also, if I'll have a few spare days to try out working on haddock, where should I look for issues etc?
09:02:42 <merijn> d34df00d: I would suggest "suck it up and deal with it" :)
09:02:45 <d34df00d> :(
09:03:08 <merijn> d34df00d: https://github.com/haskell/haddock
09:03:18 <d34df00d> Ah, so github and all the usual PR stuff.
09:03:18 <d34df00d> Cool.
09:03:22 <GyroW> I see, so one's not definitevely better than the other merijn ?
09:04:10 <merijn> d34df00d: see also https://github.com/haskell/haddock/issues/958
09:04:27 <merijn> GyroW: I'd say the first is better, because you don't have to think of a name for the list :p
09:04:36 <merijn> And naming things is hard
09:04:47 <GyroW> Hah, allright thanks! That's true :P
09:04:55 <merijn> d34df00d: You might need GHC HEAD to work with haddokc HEAD, though
09:04:55 <geekosaur> GyroW, stylistically we often prefer the one that avoids the unnecessary name, but practically they should be identical
09:05:22 <d34df00d> ...and this is how you become ghc contributor.
09:05:23 <d34df00d> Sneaky!
09:05:33 <merijn> d34df00d: ;)
09:05:41 <GyroW> Thanks guys!
09:05:48 <d34df00d> BTW speaking of GyroW's question.
09:05:58 <d34df00d> If there also was a let/where binding there.
09:06:21 <d34df00d> Do I understand correctly that it'll be memoized in the reduced version but not memoized in the version having a parameter?
09:07:39 <merijn> d34df00d: Yes, hence why I said there are *some* differences
09:08:10 <GyroW> But for a function like "add5 = 5 +" gives me a syntax error wheres "add5 x = 5 + x" does not
09:08:17 <merijn> Those differences all relate to "when are where blocks shared" and other performance related details
09:08:37 <d34df00d> GyroW: parentesize that.
09:08:39 <d34df00d> parenthesize...
09:08:43 <d34df00d> add5 = (5 +)
09:08:45 <GyroW> but where
09:08:47 <merijn> GyroW: To partially apply operators either use prefix syntax (wrap them in parentheses) or use section syntax
09:09:05 <merijn> > let add5 = (+) 5 in add5 3
09:09:07 <lambdabot>  8
09:09:20 <GyroW> ah
09:09:23 <merijn> Or indeed (5+) or (+5)
09:09:35 <d34df00d> Personally I prefer sections.
09:09:41 <GyroW> right, I tried 5 (+) and it didn't work
09:10:07 <merijn> Note that with section syntax (the last two examples) the position matters
09:10:25 <merijn> Not with + because it's commutative, but (20/) and (/20) are different :)
09:10:29 <d34df00d> Especially for non-commutative ops.
09:10:29 <d34df00d> (yeah.
09:10:51 <merijn> GyroW: Basically wrapping an operator in () makes it work like regular functions, so
09:10:52 <GyroW> I see
09:10:55 <merijn> > (+) 5 3
09:10:57 <lambdabot>  8
09:11:02 <GyroW> yeah that makes sense 
09:11:10 <merijn> You can also make functions behave as operators, using `
09:11:17 <merijn> > elem 2 [1..10]
09:11:19 <lambdabot>  True
09:11:23 <merijn> > 2 `elem` [1..10]
09:11:25 <lambdabot>  True
09:11:31 * d34df00d still feels a bit bitter about not being able to turn prefixed operators back into infix form with backticks.
09:11:39 <d34df00d> (`(+)`) 5 8
09:12:56 <d34df00d> merijn: thanks for that link btw. I think I'll open a separate issue since my request is orthogonal (or, rather, direct inverse) for the discussion of the general approach.
09:13:17 <merijn> d34df00d: There might be some other related issues, so maybe search the open issue list first
09:13:19 * geekosaur doesn't: we don't need arbitrary length lookahead (we alredy have one such with ViewPatterns iirc, one is more than enough)
09:13:46 <merijn> ViewPatterns feels kinda pointless with PatternGuards in Haskell2010 anyway
09:14:08 <d34df00d> Dunno, I personally find ViewPatterns quite useful.
09:14:13 <d34df00d> Allowing for way more concise code.
09:14:19 <dmwit> geekosaur: I'd be down for `( being an opener and )` being a closer.
09:14:28 <dmwit> Then you don't need long lookahead, just standard parser techniques.
09:14:31 <merijn> d34df00d: Sure, but are the more useful than doing the same via pattern guards?
09:14:44 <dmwit> And it would let you do fun things like ```foo `(bar baz)` quux```.
09:15:03 <d34df00d> Can't argue about usefulness — you can express all the same with pattern guards, yeah.
09:15:24 <geekosaur> section syntax already has similar limits
09:15:35 <merijn> d34df00d: "foo (myFun -> x) = ..." vs "foo v | x <- myFun v = ..." except the latter doesn't require an extension :p
09:15:39 <geekosaur> for the same reason, arbitrary lookahead slows the common case down fairly badly
09:16:07 <d34df00d> merijn: things get more interesting once you have more than one view pattern/guard.
09:16:09 <geekosaur> even when not triggered
09:16:15 <d34df00d> I don't have a good example at hand tho.
09:16:31 <geekosaur> eh? would expect , to work the same way with pattern guards
09:16:59 <geekosaur> | x <- myFun v, y <- someOther w =
09:17:08 <mniip> merijn, lambdas do not allow guards
09:17:49 <merijn> mniip: tbh if you're adding ViewPatterns in lambdas you should probably just name that thing instead before I start throwing stones >.<
09:17:59 <mniip> also requires introducing more names than necessary
09:18:06 <d34df00d> geekosaur: don't have a good example at hands, sadly. I'm not saying that view patterns are required often, but they are quite useful sometimes.
09:18:15 <monochrom> Would LambdaCase help?
09:18:22 <d34df00d> The thing I dislike about view patterns is that they break totality checker heuristics.
09:18:31 <mniip> :t \f (f -> x) -> x
09:18:32 <lambdabot> (t1 -> t2) -> t1 -> t2
09:24:42 * hackage can-i-haz 0.3.0.0 - Generic implementation of the Has and CoHas patterns  https://hackage.haskell.org/package/can-i-haz-0.3.0.0 (0xd34df00d)
09:34:02 <sm[m]> hey all, what's the best command line way to check the latest release of one or more packages on hackage ?
09:34:28 <sm[m]> and for bonus points, on stackage ?
09:37:20 <merijn> sm[m]: hmm, not sure there is one. What's the goal?
09:38:30 <d34df00d> Alrighty, https://github.com/haskell/haddock/issues/1106
09:41:08 <sm[m]> merijn: when fixing constraint problems/updating bounds in a package, I usually have to check a bunch of packages' versions on hackage and stackage in the web browser. It would be much easier to just do (stack|cabal) list --available PKG1 PKG2 PKG3 or so
09:41:55 <merijn> sm[m]: Right, I thought something along those lines. Did you know there's an RSS feed that you can subscribe that reports when your direct dependencies release versions outside your version bounds?
09:43:36 <merijn> sm[m]: You can search for your package here: http://packdeps.haskellers.com/ and get a report like http://packdeps.haskellers.com/feed?needle=broadcast-chan (which will list any direct dependencies with versions newer than your bounds), note also the "view this information as a news feed" link)
09:43:48 <merijn> I just have all my package's feeds in my RSS reader :)
09:45:18 <sm[m]> I do too, thanks for reminding me :) But often I'm fixing up some random package so I can build it
09:45:43 <dmwit> sm[m]: https://hackage.haskell.org/package/highlight-versions
09:45:44 <merijn> I think there were some tools, but I honestly can't remember them
09:47:15 <dmwit> Should be pretty easy to make it work with stackage too, provided stackage provides an index like Hackage does.
09:53:20 <sm[m]> sorry, tied up with emacsconf & it issues. I'll check that out
10:09:34 <sm[m]> my god.. still building highlight-versions :)
10:10:20 <merijn> I wish +RTS -xc had a way to only show uncaught exceptions :\l
10:10:21 <sm[m]> just 20 packages, it didn't look too bad
10:34:15 <jkell111> Hello everyone, I need to find the nth coefficient of an exponential generating function (like SeriesCoefficient in Mathematica)... any ideas? :)
10:34:42 <suzu> how would you do that with pen and paper?
10:37:09 <jkell111> i don't know tbh ^^
10:42:45 <sm[m]> highlight-versions isn't really helpful in my situation, but maybe later
10:43:34 <sm[m]> (can't easily get a clean list of package versions until the build plan works)
10:43:42 * hackage hlint 2.2.4 - Source code suggestions  https://hackage.haskell.org/package/hlint-2.2.4 (NeilMitchell)
10:49:52 <cocreature> sm[m]: `cabal info` also includes versions
10:52:32 <sm[m]> cocreature: "cabal info ." just shows the deps in my cabal file, I think
10:53:01 <merijn> sm[m]: Oh, this won't solve your problem but might still be of interest. Do you know cabal-plan?
10:54:00 <sm[m]> now I do!
10:54:02 <cocreature> sm[m]: you can pass it the name of a package
10:54:19 <merijn> sm[m]: That lets you query transitive dependencies and build plans, etc.
10:56:43 <sm[m]> cocreature: good to know. Really though I'm wanting the latest hackage/stackage release versions
10:57:19 <cocreature> sm[m]: it shows you the list of available versions
10:57:50 <sm[m]> cocreature: aha! you're right, great
10:57:53 <sm[m]> merijn: installing it, thanks
10:58:52 <Orbstheorem> Is there any way to conditionally fail inside IO ?
10:59:11 <c_wraith> well, if you define "fail", the rest can be constructed
10:59:11 <Orbstheorem> I have `if not $ null services then return () else fail "Failed"`, but not pretty :P
10:59:27 <c_wraith> well, you could use when
10:59:33 <c_wraith> :t when
10:59:34 <lambdabot> Applicative f => Bool -> f () -> f ()
10:59:51 <geekosaur> tbh fail is usually a mistake anyway in IO, since it throws an exception and exceptions should be, well, exceptional
11:00:00 <c_wraith> That's a small simplification.  But I think calling fail is not a good solution overall.
11:02:37 <Orbstheorem> c_wraith: Perfect
11:03:20 <Orbstheorem> geekosaur: I've been dragging ExceptT for a while, eventually I have to come to the real world xD
11:04:01 <Orbstheorem> And fail does `\x -> print (show x) >> exitFailure 1` :P
11:07:09 <sm[m]> to print just the available versions from cabal info output: cabal info microlens-platform | awk '/available/{f=1} /installed/{f=0} f'
11:09:10 <sm[m]> doh.. never mind, needs more time in the oven
11:09:59 <Orbstheorem> sm[m]: missing `f ~ {print}`?
11:10:45 <geekosaur> that doesn't seem quite right
11:11:21 <sm[m]> no.. the above works, until there are multiple occurrences of "installed" or "available"
11:12:01 <Orbstheorem> This works `pactl list sinks | awk '/Proper/{a=1} /Ports/{a=0} a && //{print}'`
11:13:31 <Orbstheorem> Oh ^^
11:13:45 <Orbstheorem> I didn't know you could implicit print after a condition ^^
11:13:56 <geekosaur> it's the default action, yes
11:14:47 <sm[m]> ah: cabal info microlens | awk '/available/{f=1} /installed/{f=0;exit} f'
11:15:42 <geekosaur> now I wonder about order :)
11:21:34 <dignissimus> I'm eulating a turing machine and I didn't want to force a particular type for symbols and state identifiers, is this code ok? https://paste.debian.net/1113200/
11:23:20 <dignissimus> emulating*
11:25:12 * hackage regression-simple 0.1 - Simple linear and quadratic regression  https://hackage.haskell.org/package/regression-simple-0.1 (phadej)
11:29:42 * hackage hoogle 5.0.17.12 - Haskell API Search  https://hackage.haskell.org/package/hoogle-5.0.17.12 (NeilMitchell)
11:34:02 <sm[m]> function hackage-versions() {\n    printf "$1: "; cabal info "$1" | awk '/available/{f=1} /installed/{f=0;exit} f' | ghc -e "getContents >>= putStrLn . unwords . map (drop 24) . lines" \n}
11:34:08 <sm[m]> for p in microlens-platform microlens microlens-ghc microlens-mtl microlens-th; do hackage-versions $p; done
11:35:10 * sm[m] declares victory
11:36:13 <Rembane> Now that's some sweet scripting.
11:37:12 <hpc> nice use of ghc -e
11:39:53 <sm[m]> thanks! but I spoke too soon. cabal info sometimes elides the newest versions. Doh
11:45:12 * hackage haskell-names 0.9.7 - Name resolution library for Haskell  https://hackage.haskell.org/package/haskell-names-0.9.7 (AlexandrRuchkin)
11:48:00 <ysangkok> how do i find a type a that is an instance of typeclasses A, B and C? 
11:49:00 <f-a> ysangkok: maybe hoogle can do it?
11:49:10 <ysangkok> f-a: afaik hoogle only searches for values?
11:49:27 <f-a> mhh you might be well right
11:49:41 <ysangkok> you can search "by type", but you are still finding values
11:49:46 <hpc> hoogle also searches for types
11:49:58 <hpc> or well, for data definitions and such
11:50:15 <ysangkok> aah maybe the :: syntax: https://github.com/ndmitchell/hoogle/blob/master/README.md#searching
11:52:52 <Orbstheorem> Is there any way of adding hoogle to my dependencies when using stack repl in a project?
11:53:00 <ysangkok> can't get it to work, don't know the syntax. any combination of (...) and => doesn't seem to work
11:53:20 <ysangkok> hpc: example for data definition search?
11:53:26 <Guest13> Is there a function that returns the first item in a list that matches a predicate? Like takeWhile
11:54:20 <hpc> https://hoogle.haskell.org/?hoogle=Maybe&scope=set%3Astackage
11:55:03 <ysangkok> Guest13: lists are lazy, so just can just match on the head of takeWhile...
11:55:36 <hpc> i don't think you can do what you're looking for, but hoogle isn't categorically value-only
11:55:38 <Guest13> ysangkok But that wouldn't work if the first element doesn't satisfy the predicate
11:56:00 <ysangkok> hpc: all right, thanks anyway
11:56:23 <ysangkok> Guest13: ah, i mean head of the filter, then
11:57:18 <hpc> you might be able to use holes to get suggestions?
11:57:52 <Guest13> ah, right. that makes sense. I didn't think of that (I'm still training my imperative brain to think functionally). Thanks!
11:58:03 <hpc> no, that's focused on values too :(
11:59:31 <ysangkok> Guest13: just don't use partial functions like head please. otherwise you will never realize the full potential of types
12:01:04 <dsal> I'm trying to learn how to mtl a bit.  How do I actually execute my function ? I've got a   ReaderT Env (StateT Int IO)  type aliased as 'Processor' and my action is  :: Processor ()   Brain can't fit it all together.
12:01:20 <ysangkok> runReaderT?
12:01:33 <merijn> dsal: That sounds more like learning transformers than mtl, tbh :p
12:01:45 <dsal> I don't even know what I'm learning.  heh
12:01:54 <dsal> Ooh, I didn't see runReaderT
12:02:00 <merijn> dsal: Anyway you execute it by running the individual transformer layers
12:07:00 <Guest77> Could someone help me figure out why this takes so long? https://pastebin.com/raw/UDMThfHr
12:07:18 <Guest77> I am trying to solve this puzzle: https://pastebin.com/raw/9SR0VTDL
12:07:22 <merijn> Guest77: Because length is a terrible function
12:07:27 <merijn> Guest77: It walks the entire list
12:08:17 <Orbstheorem> dsal: I just read this tutorial and I find it very good: https://en.wikibooks.org/wiki/Haskell/Monad_transformers
12:08:18 <Guest77> Are you sure the code isn't stuck in an infinite loop? because it has been running for a good 10-15 mins now
12:08:59 <dsal> Orbstheorem: Thanks.  I just poked around a bit and figured out how to get a model thing working.  I'll be trying this for real in a bit.
12:09:10 <geekosaur> tbh it looks like very inefficient code
12:09:35 <Guest77> What part specifically? I would appreciate any pointers, bc im still quite new to Haskell
12:09:47 <f-a> factorisation
12:10:53 <Guest77> What would be a better way?
12:12:02 <vaibhavsagar> silly question: how do I catch `undefined`?
12:12:06 <vaibhavsagar> I'm told there are ways
12:12:18 <merijn> vaibhavsagar: The number one solution would be "don't"
12:12:19 <f-a> Guest77: https://wiki.haskell.org/Euler_problems/1_to_10#Problem_3 is a good start 
12:12:29 <merijn> vaibhavsagar: How'd you end up with undefined in your codebase?
12:12:34 <Guest77> f-a: ah, thanks
12:12:45 <Guest77> but this is question 12
12:13:16 <f-a> Guest77: it is didacti- yeah question 3 deals on "how to generate primes reasonably fast"
12:13:40 <vaibhavsagar> merijn: I'm trying to implement this paper
12:13:45 <geekosaur> vaibhavsagar, yes there are ways. none of them are convenient, most of them are bad.
12:13:51 <vaibhavsagar> http://publications.lib.chalmers.se/records/fulltext/195847/local_195847.pdf
12:14:05 <vaibhavsagar> understood, I still want to do it though
12:14:21 <merijn> vaibhavsagar: Before we dive into black magics, you still haven't answered why :)
12:14:32 <vaibhavsagar> http://publications.lib.chalmers.se/records/fulltext/195847/local_195847.pdf
12:14:39 <vaibhavsagar> look for `valid`
12:15:03 <vaibhavsagar> the authors wisely do not include a definition
12:15:34 <merijn> vaibhavsagar: The talks about bottom, though, there's plenty of non-undefined bottoms too
12:15:38 <Guest77> f-a, how would you solve this? https://pastebin.com/raw/xXkt3Yxt
12:15:39 <f-a> Guest77: still slow with fast primes, algo must be not ok
12:15:47 <merijn> @where spoon
12:15:47 <lambdabot> I know nothing about spoon.
12:15:49 <merijn> eh
12:15:53 <f-a> Guest77: let me see
12:15:57 <merijn> @hackage spoon -- this one I think?
12:15:57 <lambdabot> http://hackage.haskell.org/package/spoon -- this one I think?
12:17:51 <vaibhavsagar> merijn: this looks like exactly what I want
12:18:21 <merijn> vaibhavsagar: I'm not responsible for any depression or therapy needed due use of this package
12:20:40 <dsal> I'm starting to think I didn't actually need ReaderT here, now that I've done the hard bits.
12:23:33 <vaibhavsagar> merijn: it's cool, I just want to implement this paper
12:24:27 <f-a> ok Guest77 , I think I got it, one sec
12:24:34 <Guest77> ok, cool
12:26:21 <Guest77> I also tried it in rust (https://pastebin.com/raw/Ydx4vUub) but thats also taking forever
12:27:09 <ncinick> @help
12:27:09 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:37:45 <f-a> Guest77: http://www.ariis.it/link/t/paste10288-0 the busillis is that the assignment talks about "prime factors" when then it shows it means "divisors"
12:38:26 <f-a> http://www.ariis.it/link/t/paste10911-0 welp this is not blank Guest77 
12:38:43 <Guest77> ah, okay i see. awesome
12:39:32 <f-a> Guest77: usually in thos Euler-type problems there is always a mathematical "trick" (in this case I suppose: using a somewhat decent prime generatio *and* calculating the /number/ of divisors, not each one of them)
12:39:48 <Guest77> okay.
12:39:51 <Guest77> thanks so much
12:41:27 <f-a> also (unlike me) remember always to write signatures of top level functions
12:41:37 <f-a> makes the program easier to read and to debug
13:48:42 * hackage record-dot-preprocessor 0.2.1 - Preprocessor to allow record.field syntax  https://hackage.haskell.org/package/record-dot-preprocessor-0.2.1 (NeilMitchell)
13:59:23 <Uniaika> Neil is doing God's work here
14:01:52 <sicklorkin> Any one know if ti's possible to reclaim unshaged changes to a repo after running git checkout .? these chanes were never stashed, i dont have a swap file, my editor was exited and zero trace of thse changes in reflog.. 
14:03:13 <Athas> sicklorkin: Git will have never heard of those changes.
14:05:05 <sicklorkin> the chages were indexed at one point then I reset just before commit die on my code.
14:07:06 <didymus> sicklorkin: I can't think of the name of it off the top of my head but there is a way to see every command executed. One sec I'll see if I can find/remember the name..
14:07:41 <didymus> reflog
14:08:10 <didymus> sicklorkin: try git reflog and see https://git-scm.com/docs/git-reflog for more info, might help
14:08:51 <sicklorkin> i've already `git reflog -p | grep mynewcode` and nothing was found
14:09:06 <didymus> bah, that sucks
14:09:55 <sicklorkin> but git must have writen thse changes to disk at some point so manybe I can restore lost inodes.. dunno if that's a thing or not
14:11:03 <sicklorkin> co = !sh -c 'git stash; git stash apply; git checkout "$@"' <- would have been nice
14:20:56 <sicklorkin> git fsck  | grep 'dangling block' ftw
14:21:41 <dsal> I've got a stack of monads with IO at the bottom.  Is there a sensible way to catch an exception thrown inside?
14:22:06 <jackdk> this is the problem that MonadBaseControl solves, IIRC
14:22:42 <didymus> sicklorkin: nice
14:26:42 <testi23435useriu> hello
14:27:37 <didymus> hi
14:27:42 <ChaiTRex> testi23435useriu: Hello.
14:28:45 <merijn> Ignore MonadBaseControl, it's way overcomplicated
14:29:04 <merijn> Instead I recommend either: 1) exceptions or 2) unliftio
14:29:08 <merijn> @hackage exceptions
14:29:08 <lambdabot> http://hackage.haskell.org/package/exceptions
14:29:19 <jackdk> ooh neat, I'll take a look
14:33:22 <bsima> is there a way to tell ghc to look for lowercase filenames when loading modules?
14:33:45 <dignissimus> In a parser combinator is it possible to say that I want A,B,C in any order and that they don't have to appear but they can't appear more than once. I said that A,B,C were "attributes" and created a new parser for them, but how could I specify that each attribute only appears once, is there some sort of unconsume function or should I not use a parser combinator?
14:34:24 <EvanR> make an A OR B OR C parser, then use many
14:34:41 <monochrom> Some parser libraries provide "permutation parsers". That may help.;
14:34:53 <EvanR> only read the first question
14:35:06 <EvanR> wrongly
14:37:35 <nshepperd2> It's probably best to parse the items with (a or b or c)  then check for duplicates after the the fact
14:39:40 <nshepperd2> You can give a proper "conflicting values of attribute a" error message that way
14:40:18 <nshepperd2> Instead of an inscrutable "expected b or c or end" kind of message
14:44:39 <dsal> merijn: Cool, thanks.  This whole thing  seems easier than  I thought it would be.
14:45:07 <merijn> dsal: :)
14:45:37 <merijn> The advantage of common problems is that a lot of them have been solved already ;)
14:47:04 <fendor_> @pl wrap (o, i, e, p) = (Just o, Just i, Just e, p)
14:47:04 <lambdabot> (line 1, column 20):
14:47:05 <lambdabot> unexpected " "
14:47:05 <lambdabot> expecting operator
14:48:42 * hackage poly 0.3.3.0 - Polynomials  https://hackage.haskell.org/package/poly-0.3.3.0 (Bodigrim)
14:49:00 <dignissimus> nshepperd2: That's reasonable but I'm parsing an esoteric language where having the same type of character will mean that I'm parsing something new, I'd have to unconsume the data somehow
14:50:39 <dignissimus> monochrom: I've written all my code with Text.ParserCombinators.ReadP, I found a permutation parser for Parsec but not for this, will I have to rewrite the code with another parser library?
14:54:55 <dsal> merijn: Yeah.  I'm digging into an old program and wanted to add a couple features to it.
14:59:19 <dsal> Now that I've added exception handling so it continues after it finds an error, it seems to use all RAM.
15:28:47 <zincy_> if anyone has any clues as to how to write this query I would be grateful :)
15:28:48 <zincy_> https://stackoverflow.com/questions/58674880/how-do-i-write-a-query-which-returns-a-nested-list-using-the-beam-library-in-has
15:38:08 <dsal> mfix feels a little oddly magical.
15:47:12 * hackage predicate-typed 0.2.0.0 - Predicates, Refinement types and Dsl  https://hackage.haskell.org/package/predicate-typed-0.2.0.0 (gbwey)
15:53:46 <TheCommieDuck> Hey. So I'm trying to think in a not-OO way, but I can't think of anything...sane? I guess? Let's say in an OO-world I have some Object class with some properties (idk, it has a 'name' and an 'id') and then I have a Foo1 and a Foo2. These are subclasses of object except foo1 has Field1 and foo2 has Field2. Seems like the haskell way would be to have a id typeclass, a name typeclass, etc
15:54:07 <TheCommieDuck> but then it seems like if I had a lot of different FooXs, I'd be writing out the same typeclass instances a million times.
15:54:41 <dsal> Weird.  stylish-haskell made me enable ExplicitForAll before it'd work.  I'm not using explicit forall.
15:55:36 <EvanR> TheCommieDuck: you described extensible records with a subtyping relationship or row polymorphism
15:55:37 <TheCommieDuck> and if I did the composition way; Foo1 = Foo1 Field1 Object, that'd get messy even with lenses if it was a deep-ish hierarchy. 
15:55:43 <EvanR> rather than OO as such
15:55:53 <dolio> If you're trying to think in a non-OO way, maybe you shouldn't just try to translate exactly what you'd do in OO to Haskell.
15:55:58 <TheCommieDuck> Yes, I think that's where I ended up on the google-foo.
15:56:10 <EvanR> however haskell doesn't really have that either
15:56:22 <EvanR> but you might not need it
15:56:41 <EvanR> haskell does have extensible record packages
15:56:56 <EvanR> vinyl...
15:57:14 <TheCommieDuck> Yeah, I found vinyl/rawr/bookkeeper/etc, but I wasn't sure if there was a more functional way rather than seeming to take a sledgehammer to it all
15:57:47 <EvanR> well, a new language for new abstractions fixes many things
16:03:13 <jkell111> Hey guys, I need to find the nth coefficient of an exponential generating function using haskell... any ideas? :)
16:04:30 <ChaiTRex> TheCommieDuck: It depends on the specific problem you have, but one simple way is: data Foo a = Foo String Int a
16:06:09 <TheCommieDuck> the specific problem I have is one of those fairly classical "baby's first OOP hierarchy" ones; you have an Animal class, then Cat and Dog and Panda except each have additional stuff with them. I don't need the runtime method polymorphism, just...I guess record label reuse
16:06:44 <EvanR> yeah, record label reuse. Not really an OOP thing and coincidentally something haskell botched
16:07:23 <EvanR> typeclasses might work
16:07:44 <TheCommieDuck> typeclasses would work, but...the sheer quantity of boilerplate
16:07:57 <EvanR> hence the sheer quantity of TH
16:08:06 <TheCommieDuck> heh
16:08:32 <dsal> jkell111: What do you have so far?
16:09:12 <EvanR> another problem is `id' as a field name stomps on the id function because field names generator accessors, but there is an upcoming extension which will allow disabling those
16:09:22 <EvanR> generate
16:10:41 <TheCommieDuck> my other thought was to have each record be just a Map of String -> SomePropertyType and then have a lookup function be String -> Record -> Maybe SomePropertyType
16:10:53 <TheCommieDuck> but then...I feel like I proceed to throw away everything the type system gives me?
16:11:07 <EvanR> unless all fields have the same type, you will be stepped directly in dynamic types
16:11:14 <EvanR> stepping* !
16:11:34 <EvanR> but you can use a dependent map to fix that issue
16:11:49 <TheCommieDuck> yup, because I'd have data SomePropertyType = Int a | String b | Bool c | etc...
16:11:56 <EvanR> please don't :)
16:12:00 <TheCommieDuck> yes :P
16:15:43 <EvanR> TheCommieDuck: i heard dependent map can get traction there
16:18:44 <TheCommieDuck> I think the best way would be to go look up TH in more detail and go the typeclass way
16:19:54 <EvanR> TH is kind of "i give up and this needs to work by wednesday"
16:20:08 <TheCommieDuck> ahah
16:20:19 <EvanR> (and then no one asks if it will finish compiling by wednesday)
16:22:23 <dolio> What is the real problem that is solved by having 'Animal' with subtypes 'Dog', 'Cat' and 'Panda'?
16:23:17 <EvanR> so you can put dogs, cats, and pandas in the same cage at the zoo
16:23:44 <EvanR> jk
16:23:45 <TheCommieDuck> animals have names. I can do HasName as a typeclass, then instances for each of them, but then I'm writing out the same typeclass for each one when they are just labels on certain groupings of data. idk, maybe the 'Dog' thing has something specifically for dogs. this says animal typeclass to me (and then instances for e.g. 'Name')
16:24:08 <EvanR> if you're using a database, then it's not animals that have names really
16:24:17 <dmwit> Way to completely ignore the question dolio asked. -_-
16:24:42 <dolio> That paragraph isn't a problem description. It's just a description of how to mimic OOP ways of structuring your animals.
16:24:52 <TheCommieDuck> Okay. Yes.
16:25:52 <dolio> My point is, instead of looking up fancy ways of doing OOP-like things in Haskell, you should think about concrete problems that you can solve in a functional way, instead of this example, which is specifically designed to show how OOP works.
16:26:04 <dolio> I mean, assuming you're just starting to learn.
16:26:55 <TheCommieDuck> (I'm still thinking how to rephrase my problem description). And yeah, I should stress I'm not looking for "how do I force haskell to do this OO thing" and more what the functional approach to such a problem would be.
16:28:00 <dolio> Like, one general critique is that although examples like 'animal and dog' are intuitive, they aren't necessarily the best way to represent all programs.
16:28:40 <EvanR> animal and dog isn't even the problem, it's supposed to be a thing you can and no actual problem is posed
16:28:46 <dolio> Without a less abstract example, it's impossible to say what a solution would be, though.
16:28:49 <EvanR> a thing you can do
16:28:53 <dignissimus> Is it ok to roll my own parser? I'm parsing an esolang and I think  it would just be easier to use recursion and pass the programme state and a character buffer
16:29:48 <dolio> Like, perhaps for an actual use case, `data Animal = Dog | Cat | Panda` with functions is appropriate.
16:30:04 <dolio> But it's impossible to say.
16:30:42 <EvanR> i can throw you a problem TheCommieDuck, you want an interface for device drivers. You want to be able to write 3 devices drivers with room for more, in a way that they will all ... drive devices
16:30:49 <TheCommieDuck> The actual thing I'm doing is some kind of text game/world simulation/thing. I want to have concrete /things/ in said world simulation that are naturally going to share properties without having to write out the same typeclass a hundred times. 
16:31:22 <EvanR> to solve that with C++ maybe you use an abstract class, but in haskell you would use a record of functions
16:31:37 <EvanR> one type, not a hierarchy
16:32:03 <EvanR> whatever Dog Cat and Panda have in common, make that a type
16:32:15 <EvanR> dog cat and panda (lowercase) are then values of that type
16:33:06 <EvanR> yeah so your real problem is just  not being able to reuse field names
16:33:22 <TheCommieDuck> I want to be able to take any of these objects, ask its name, get something that is a name. says typeclass to me. problem with using ADTs is that then I'm stuck with the closed/open thingy 
16:33:33 * EvanR cringes
16:34:00 <EvanR> you may have a database with many entities, some of which have a name, some don't
16:34:03 <jkell111> dsal: I have it working in J, but no idea how to translate it to Haskell
16:34:05 <heatsink> If they all have the same common fields and those fields have the same behavior, why not use the same data type for all of them?
16:35:15 <TheCommieDuck> But then each one has, potentially, additional overhead. and I don't want a single monolithic type with 200 fields where an arbitrary 195 aren't used and there's 2 common always fields or something.
16:35:46 <heatsink> If those 195 fields aren't used, then they are not common to all the objects
16:35:52 <TheCommieDuck> I think I just want a record of functions, but...still can't quite get my head around the idea. Back to google I think. :P 
16:36:25 <jkell111> dsal: In J it's simply "f =: (%4+^@-)t:" which calculates the nth coefficient of x/(4+exp(-x))
16:36:30 <TheCommieDuck> let's say there's 5 fields common to everything, then each thing has its own 2 fieldsthat are not. it's 5 fields+stuff on top. 
16:36:45 <heatsink> Shared data type on the outside: data Entity a = Entity { name :: String; extra :: a }; data DogExtra = DogExtra; type Dog = Entity DogExtra
16:37:21 <heatsink> Shared data type on the inside: data Common = Common { name :: String }; data Dog = Dog { common :: Common }
16:37:24 <EvanR> each entity has an ID, and that's about it
16:37:31 <EvanR> everything else is optional
16:38:01 <TheCommieDuck> and then...typeclassing them both with some kind of HasName instance?
16:38:07 <dsal> jkell111: I don't know J, but I've got a cat.  I'm not sure if that helps.
16:38:10 <EvanR> you can use a database to ask "all the things with attribute name"
16:38:23 <EvanR> the record coming back from a database query depends on the query
16:38:29 <heatsink> If the shared data type is on the outside, you don't need a typeclass.  Just access the field.
16:39:12 <Zemyla> The type of lists sorted by a given function is a Functor:
16:39:18 <heatsink> If the shared data type is on the inside, you need a typeclass with one or two methods to access the shared data of each type.
16:39:37 <Zemyla> @let newtype SortedList a = SortedList { getSortedList :: (a -> a -> Ordering) -> [a] } deriving (Functor)
16:39:38 <lambdabot>  Defined.
16:39:46 <heatsink> It's one or two methods regardless of how complex the shared data is.
16:39:51 <Zemyla> But I think it's also a monad.
16:39:53 <EvanR> these record types and their nesting is really a view of a database rather than the core data model
16:39:59 <TheCommieDuck> I guess I'm just wondering when that becomes unwieldy; type VerySpecificDog = Entity DogExtra SpecificDogExtra AnotherSpecificDogExtra ... blah
16:40:15 <EvanR> there are many ways to view a database
16:41:33 <heatsink> Zemyla, it's not a monad because fmap will not preserve sortedness
16:41:59 <heatsink> You would need sortedFmap :: Ord b => (a -> b) -> SortedList a -> SortedList b
16:42:39 <TheCommieDuck> thank you very much, everyone. I think I'm starting to grok. :)
16:42:40 <Zemyla> No, because fmap f (SortedList m) = SortedList $ \cmp -> fmap f $ m $ \a b -> cmp (f a) (f b)
16:43:44 <Zemyla> :t \(SortedList m) -> SortedList $ \cmp -> mergeAllWith cmp $ fmap (\(SortedList mc) -> mc cmp) $ m $ \(SortedList ma) (SortedList mb) -> compareWith cmp (ma cmp) (mb cmp)
16:43:45 <lambdabot> error:
16:43:45 <lambdabot>     Variable not in scope:
16:43:45 <lambdabot>       compareWith :: (a -> a -> Ordering) -> [a] -> [a] -> Ordering
16:44:17 <Zemyla> :t \(SortedList m) -> SortedList $ \cmp -> mergeAllWith cmp $ fmap (\(SortedList mc) -> mc cmp) $ m $ \(SortedList ma) (SortedList mb) -> liftCompare cmp (ma cmp) (mb cmp)
16:44:19 <lambdabot> L.SortedList (L.SortedList a) -> L.SortedList a
16:45:54 <Zemyla> :t \(SortedList m) f -> SortedList $ \cmp -> mergeAllWith cmp $ fmap (\a -> getSortedList (f a) cmp) $ m $ \a b -> liftCompare cmp (getSortedList (f a) cmp) (getSortedList (f b) cmp)
16:45:55 <lambdabot> L.SortedList t -> (t -> L.SortedList a) -> L.SortedList a
16:46:15 <Zemyla> :t \a -> SortedList $ const [a]
16:46:16 <lambdabot> a -> L.SortedList a
16:47:05 <Zemyla> It has pure and (>>=), so it's a monad, I think, assuming it's associative.
16:47:37 <heatsink> I see what you mean with the Functor implementation
16:49:17 <Zemyla> @let slBind (SortedList m) f = SortedList $ \cmp -> mergeAllWith cmp $ fmap (\a -> getSortedList (f a) cmp) $ m $ \a b -> liftCompare cmp (getSortedList (f a) cmp) (getSortedList (f b) cmp)
16:49:19 <lambdabot>  Defined.
16:50:01 <Zemyla> @let instance Applicative L.SortedList where { pure a = SortedList $ const [a]; liftA2 f ma mb = slBind ma $ \a -> fmap (f a) mb }
16:50:03 <lambdabot>  Defined.
16:50:58 <Zemyla> @let instance Alternative L.SortedList where { empty = SortedList $ const []; SortedList ma <|> SortedList mb = SortedList $ \cmp -> mergeWith cmp (ma cmp) (mb cmp) }
16:51:00 <lambdabot>  Defined.
16:51:12 <Zemyla> @let instance Monad L.SortedList where (>>=) = slBind
16:51:14 <lambdabot>  Defined.
16:51:20 <Zemyla> @let instance MonadPlus L.SortedList
16:51:22 <lambdabot>  Defined.
16:51:44 <Zemyla> Now I just need to figure out if it's associative.
16:52:48 <jellostahps>   Black -> setMessage $ set status Red s    is the 'lens' notation.   What is the equivalent 'record notation'   ? I thought it would be setMessage $ s{_status Black s}     but that is wrong
16:56:17 <dmwit> s{_status = Red}
16:56:44 <dmwit> I don't know what the role of "Black ->" is in that snippet.
16:56:52 <dmwit> But I would guess it probably doesn't need to change.
17:01:16 <dsal> mfix failed me.  I wrote   "while :: Monad m => m Bool -> m ()"  which seems like it'd be pretty common.
17:04:19 <dsal> Still using an unreasonable amount of memory.  I'm processing some junk and memory keeps accumulating.
17:07:31 <kentt_> i am sorely confused about an error I'm getting trying to import a module
17:08:45 <sagax> hi all!
17:09:19 <sm[m]> hi sagax
17:09:22 <kentt_> paste: https://gist.github.com/cruxicheiros/81d5571557c9c1b16f520f135dc71ef0
17:09:43 <kentt_> the error is in a comment on the paste
17:09:50 <haym> I implore you to not actually send me anything https://i.imgur.com/SypPEfp.jpg
17:10:04 <sagax> what the best vim theme for haskell?
17:10:33 <kentt_> i am confused about why there's a type error because... if i constrain the type to a list of ords then when I produce a list from that list it should still be a list of ords, right?
17:10:41 <kentt_> or am I looking at the wrong thing
17:10:52 <MarcelineVQ> kentt_: it's not related to importing something, the error says you've given bubbleSort an a then it's expects an [a], this is because  bubbleSortRound y:xs  is  (bubbleSortRound y):xs
17:11:20 <kentt_> oh
17:11:25 <haym> I implore you to not actually send me anything: https://i.imgur.com/SypPEfp.jpg
17:11:28 <kentt_> i thought because I bracketed it, it was fine
17:11:32 <haym> wrong channel twice lol
17:12:05 <kentt_> i guess i'll try with ++
17:12:08 <MarcelineVQ> well with your brackets still   x:(bubbleSortRound y:xs)   is  x:((bubbleSortRound y):xs)
17:12:20 <kentt_> oh
17:12:21 <MarcelineVQ> you probably wanted  x:(bubbleSortRound (y:xs))
17:12:22 <kentt_> gdi
17:12:29 <kentt_> yes! thanks
17:13:11 <kentt_> i didn't realise it did that, i'll try to remember now haha
17:46:23 <dignissimus> Ok, I finally get how to use the parser, I don't need to write my own
18:54:47 <jellostahps> :t &
18:54:48 <lambdabot> error: parse error on input ‘&’
18:54:52 <jellostahps> :y (&)
18:56:16 <dsal> > 4 & succ
18:56:18 <lambdabot>  5
19:05:54 <jackdk> :t (&)
19:05:56 <lambdabot> a -> (a -> b) -> b
19:09:59 <jellostahps> I am normally using 'stack ghci' to bypass Prelude> and end up in *Main>   ... but if I am in Prelude> then how do I get back into *Main  ? Because Prelude >stack ghci doesn't work
19:12:39 <sm[m]> jellostahps: probably the easy way is :quit and stack ghci
19:12:57 <jellostahps> yeah thats what ive been doing, is there no alternative from inside Prelude> ?
19:13:11 <jackdk> `:m + *Main` ?
19:13:59 <sm[m]> It depends how you got there, yes try that ^
19:14:20 <sm[m]> Or :load Main
19:19:14 <dsal> I fixed that in my .ghci by setting my prompt to:  λ> 
19:22:43 <jellostahps> :load Main seemed to work
19:22:45 <jellostahps> ty
19:47:11 * hackage nonempty-vector 0.2.0.1 - Non-empty vectors  https://hackage.haskell.org/package/nonempty-vector-0.2.0.1 (topos)
19:48:19 <renzhi> Has anyone use the Foundation (https://github.com/haskell-foundation/foundation) in real project? if yes, what was your experience with it?
20:07:55 <jackdk> I do not use custom preludes because I mostly end up working on libraries, and it's rude to pull in everything on which the custom prelude depends if you don't need it
20:15:25 <jellostahps> For pattern matching, [] is the empty list, so how do I parse the empty tuple?     () doesn't seem to work
20:16:05 <f-a> jellostahps: no such thing as an empty tuple
20:16:21 <f-a> if you signature is say
20:16:24 <f-a> :t fst
20:16:25 <lambdabot> (a, b) -> a
20:16:40 <f-a> the pattern match will always be like: (x,y) or (1, 3) etc.
20:16:42 <f-a> never ()
20:16:49 <jellostahps> ok
20:17:07 <f-a> now, () exists
20:17:08 <f-a> :t ()
20:17:09 <lambdabot> ()
20:17:26 <f-a> but I strongly suspect it is not what you are looking for, since it is useless to pattern match on it
20:21:35 <dsal> jellostahps: () is unit -- it's a type that only has one value.
20:27:07 <jellostahps> :i member
20:27:26 <jellostahps> Whats the function that does this called: (Eq a) => a -> [a] -> Bool
20:27:43 <f-a> jellostahps: hoogle might help
20:27:51 <koz_> :t elem
20:27:51 <f-a> @hoogle Eq a => a -> [a] -> Bool
20:27:52 <lambdabot> GHC.List elem :: Eq a => a -> [a] -> Bool
20:27:52 <lambdabot> GHC.List notElem :: Eq a => a -> [a] -> Bool
20:27:52 <lambdabot> GHC.OldList elem :: Eq a => a -> [a] -> Bool
20:27:52 <lambdabot> (Foldable t, Eq a) => a -> t a -> Bool
20:28:20 <jellostahps> oh cool theres a bot
20:28:54 <f-a> better, there is a site https://hoogle.haskell.org/
20:29:06 <f-a> and if you want, you can add it to your ghci too
20:45:27 <olligobber> is there a nice way of writing \f ma mb -> do {a <- ma; b <- mb; f ma mb} ?
20:45:56 <olligobber> or mainly just the do block
20:46:48 <koz_> Are you sure you want the last line to be 'f ma mb' not something like 'return (f a b)'?
20:47:05 <olligobber> yeah, f returns the thing in a monad
20:47:10 <f-a> olligobber: most likely applicative style
20:47:20 <totbwf> Just use `liftA2`
20:47:22 <koz_> Then why do you need a <- ma; b <- mb;?
20:47:27 <koz_> You're not using a or b anyplace.
20:47:33 <olligobber> oh woops
20:47:33 <f-a> f <$> a <*> b -- etc
20:47:37 <olligobber> I mean f a b
20:47:59 <koz_> Yeah, then you should use either liftA2 f ma mb or f <$> ma <*> mb.
20:48:02 <olligobber> I have f :: x -> y -> m z, ma :: m x, mb :: m y
20:48:10 <olligobber> so liftA2 doesn't work
20:48:10 <koz_> Oh yeah, that's different then.
20:48:14 <MarcelineVQ> join $ liftA2 f ma mb
20:48:20 <olligobber> oh
20:48:32 <olligobber> join from Control.Monad, that will work, ty
20:48:55 <koz_> Did anything ever come of the whole 'let's put join back into Monad now that we have quantified constraints' thing?
20:49:08 <f-a> olligobber: pattern is ubiquitous in haskell, make sure to really get it
20:50:03 <olligobber> I get the <$> and <*> thing, I just forgot about join for a moment
20:50:08 <totbwf> I don't think so, AMP was pretty hard as it was
20:50:33 <jusss> :t lift
20:50:34 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
20:50:51 <f-a> olligobber: "I am not branching out based on \a -> " --> let's check Applicative
20:51:17 <olligobber> I'm not sure applicative would be enough for this?
20:52:01 <f-a> if I correctly interpreted your example, yes it would
20:52:12 <koz_> f-a: f gives back an m c, not a c.
20:52:17 <olligobber> ^
20:52:21 <f-a> doh
20:52:32 <koz_> I first thought Applicative as well until I saw that.
20:52:48 <olligobber> I used applicative at first but got unhelpful type errors
20:53:19 <olligobber> Though the nested monads should have been a hint to use join
20:56:05 <MarcelineVQ> ((join .) .) . liftA2   if you want to upset children and the elderly and end up on a wanted poster
20:56:42 <koz_> MarcelineVQ: Pointfree is best. :P
20:57:15 <olligobber> `join $ mergeErr <$> match w w' <*> match v v''
20:57:40 <olligobber> oh no, I'm gonna get yelled at for using ' in variable names now
20:59:04 <MarcelineVQ> that's pretty common, especially when the ' is for a derivative value, e.g.   let (s',r) = runstate foo s
20:59:19 <MarcelineVQ> though I prefer s1 s2 s3
20:59:22 <olligobber> doesn't hlint flag it or something?
20:59:43 <MarcelineVQ> idk hlint isn't the boss of me :D
21:00:50 <olligobber> huh, it doesn't, must have been elm's linter or something
22:34:07 <Zemyla> The Monad instance for SortedList I showed earlier came to me in my dreams last night, I have to mention.
23:04:31 <jusss> yesod has a templating language Hamlet to generate HTML, can we use it out of yesod?
23:34:24 <mr2robot> pprl
23:39:46 <refusenick> Anyone know how to fix stack/GHC without resorting to deleting libcurses.so and replacing it with a symlink to libcursesw.so? 
23:40:05 <refusenick> That's the solution I've come across online for this issue: https://0x0.st/zgq2.txt
23:41:25 <refusenick> (using Void Linux, for which there's an open issue on this: https://github.com/commercialhaskell/stack/issues/4981 )
23:41:33 <refusenick> How would I go about adding support to that script?
