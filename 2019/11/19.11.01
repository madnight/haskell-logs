00:15:12 <jusss> is there a web frame easier than yesod for beginner?
00:15:42 <jusss> I can't find a good example for how to share a file via yesod
00:16:14 <dminuoso> jusss: I dont think that "full stack web development" is easily approachable for beginners.
00:16:17 <MarcelineVQ> scotty is probably the simplest start for that
00:16:58 <MarcelineVQ> probably need to add wai-middleware-static to it for basic file serving
00:18:24 <jusss> dminuoso: MarcelineVQ file serving is not easy for those web frames?
00:18:36 <dminuoso> jusss: Put it this way.. why are you using yesod?
00:18:57 <MarcelineVQ> it's easy enough since I managed to do it
00:19:31 <jusss> dminuoso: I need a web service to sync other robots's file, 
00:19:58 <dminuoso> jusss: Can you describe this in a bit more detail?
00:20:29 <jusss> so I create a web server that provide restful api, so on the robot side they can use python to connect with this web server to know if they need to update some files or not
00:21:20 <jusss> so there's two simple things I need, one provide restful api, another is sharing files
00:21:52 <jusss> I don't think keep touch in a websocket is a good idea, so I choose restful
00:21:55 <dminuoso> jusss: Yeah yesod is probably not what you want to be using for that. Yesod is basically a framework for making complex web pages.. :)
00:22:18 <jusss> dminuoso: what's your suggestion
00:22:25 <dminuoso> jusss: MarcelineVQ suggested scotty, which is a fine choice.
00:22:41 <jusss> dminuoso: but one day, this need may be complex, work with front-end, sql, stuff
00:26:21 <EvanR> toast92: ah you can see SNatRep in action in the code for findFirst
00:28:01 <EvanR> which basically does vect !! getSNat. Walk n steps down the vect
00:31:06 <toast92> EvanR: Yeah I saw that. Earlier I thought that it wasn't actually necessary, that findFirst could somehow be implemented by some natural recursive solution
00:32:06 <toast92> but now upon second glance I think it is true that n would otherwise be unavailable to findFirst
00:32:41 <EvanR> the type would be effectively HVect ts -> x
00:33:02 <EvanR> nothing to go on at runtime for what to do
00:33:41 <EvanR> also I don't quite understand why this (can?) only find the "first" item of some type
00:34:21 <EvanR> if you specify and satisfy any n, seems like it would work. Even if ts contains multiple of some type
00:34:59 <dminuoso> EvanR: Im still curious, the type variable is quantified `findFirst :: forall x ts n. ...`
00:35:16 <dminuoso> EvanR: `n` is effectively ambiguous.
00:35:24 <toast92> Ah I think thats because InList x ts stops recursing at the first instance found
00:36:18 <EvanR> don't see why n is ambiguous. But I do see why they put a forall, so they can use `n' in a sub-typesig
00:36:40 <dminuoso> EvanR: Because its not mentioned in the actual type anywhere.
00:36:58 <dminuoso> findFirst :: forall x ts n. (ListContains n x ts) => HVect ts -> x
00:37:09 <EvanR> i see n used once
00:37:29 <toast92> Its in the ScopedTypeVariable right?
00:37:46 <EvanR> ScopedTypeVariable is why they put forall
00:38:09 <EvanR> but dminuoso is looking at the top level sig
00:38:32 <dminuoso> "We say that an expression e has anambiguous typeif, in its type ∀u.cx⇒t, there is a type variable u' in u that occurs in cx but not in t."
00:38:45 <dminuoso> If that's not ambiguous, I dont know what is.
00:39:13 <EvanR> n is related to ts and x within the ListContains constraint
00:39:24 <dminuoso> Sure, it's still ambiguous.
00:39:47 <EvanR> so you're saying you don't understand how type inference can work?
00:40:17 <EvanR> it might not, you might need beaucoup annotations
00:41:43 <EvanR> er inference + resolution
00:43:19 <dminuoso> EvanR: Does GHC have special machinery to accept an ambiguous type in which there is a type variable `t` not mentioned in the type signature, if there is some equality constraint mentioning `t` on one side?
00:45:52 <EvanR> where is the quoted text from i'm curious
00:47:21 <dminuoso> EvanR: The Haskell report.
00:47:37 <dminuoso> EvanR: https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-750004.3
00:47:43 <dminuoso> EvanR: 4.3.4 "Ambiguous Types..."
00:50:15 <dminuoso> Im not saying this is wrong, Im just genuinely curious why this is legit when this is, at first glance, an ambiguous type.
00:51:47 <EvanR> you're right it's ambiguous and n would need to be explicitly specified by the user at the use site unless one of the 20 extensions in play does something
00:52:38 <EvanR> which would be annoying
00:53:51 <EvanR> https://stackoverflow.com/questions/26146983/ambiguous-type-variable-fixed-with-type-equality-constraint
00:54:18 <dminuoso> EvanR: Yeah I found that too, but it was not quite.. obvious.
00:54:20 <dminuoso> But Ive got an idea.
00:54:40 <dminuoso> % f :: forall a. (a ~ Int) => Bool; f = True
00:54:41 <yahb> dminuoso: 
00:54:42 <dminuoso> % f
00:54:42 <yahb> dminuoso: True
00:54:57 <dminuoso> EvanR: ^- I suppose an equality constraint can make an ambiguous type non-ambiguous.
00:55:18 <dminuoso> Assuming there's not a bunch of crazy extensions activated in yahb at the moment..
00:56:33 <EvanR> impressive if true
00:57:09 <dminuoso> Well we can test this..
00:57:57 <EvanR> to the bat ghcmanual
01:01:20 <dminuoso> % type family Length (x :: [*]) = (y :: Nat) where Length (x ': xs) = (Length xs) + 1
01:01:20 <yahb> dminuoso: 
01:01:29 <dminuoso> % lengthOf :: forall (a :: Nat) (n :: [*]). (a ~ Length n) => Integer; lengthOf = natVal (Proxy :: Proxy a);
01:01:30 <yahb> dminuoso: ; <interactive>:21:81: error:; * Could not deduce (KnownNat a) arising from a use of `natVal'; from the context: a ~ Length n; bound by the type signature for:; lengthOf :: forall (a :: Nat) (n :: [*]). (a ~ Length n) => Integer; at <interactive>:21:1-67; Possible fix:; add (KnownNat a) to the context of; the type signature for:; 
01:01:48 <dminuoso> oh
01:01:48 <EvanR> i found no mention of this disambiguating power
01:01:51 <dminuoso> % type family Length (x :: [*]) = (y :: Nat) where Length (x ': xs) = (Length xs) + 1; Length '[] = 0
01:01:51 <yahb> dminuoso: 
01:01:53 <dminuoso> Of course.
01:02:23 <dminuoso> EvanR: Me neither, but equality constraints dont have much about them in the manual.
01:02:46 <Ariakenom> % :unset -XCrazy
01:02:46 <yahb> Ariakenom: Some flags have not been recognized: -XNoCrazy
01:03:10 <EvanR> Crazy is a one way street
01:03:13 <EvanR> no coming back
01:03:29 <koz_> One does not simply unset Crazy.
01:03:39 <dminuoso> % lengthOf :: forall (a :: Nat) (n :: [*]). (KnownNat (Length n), a ~ Length n) => Integer; lengthOf = natVal (Proxy :: Proxy a);  -- EvanR 
01:03:40 <yahb> dminuoso: ; <interactive>:26:13: error:; * Could not deduce (KnownNat (Length n0)); from the context: (KnownNat (Length n), a ~ Length n); bound by the type signature for:; lengthOf :: forall (a :: Nat) (n :: [*]). (KnownNat (Length n), a ~ Length n) => Integer; at <interactive>:26:13-88; The type variable `n0' is ambiguous; * In the ambiguity check for `length
01:04:18 <dminuoso> Mmm I guess my length tyfam needs to have constraints..
01:04:51 <koz_> dminuoso: I think this is the first time I've heard someone call it a 'tyfam'.
01:05:11 * koz_ o O O ("It's lit, tyfam!")
01:05:43 <dminuoso> I picked it up in here. fundeps, tyfams, tyclas...
01:05:54 <EvanR> ok, ambiguousness might even prevent the function itself from compiling much less it's usages
01:06:14 <dminuoso> EvanR: Well no this is a separate problem
01:06:24 <dminuoso> Its one of lazyness from my side. :)
01:06:55 <EvanR> is ScopedTypeVars on
01:07:08 <dminuoso> oh.
01:07:10 <EvanR> n0
01:07:12 <dminuoso> % :set -XScopedTypeVariables
01:07:12 <yahb> dminuoso: 
01:07:14 <dminuoso> Good catch
01:07:18 <dminuoso> % lengthOf :: forall (a :: Nat) (n :: [*]). (KnownNat (Length n), a ~ Length n) => Integer; lengthOf = natVal (Proxy :: Proxy a); 
01:07:18 <yahb> dminuoso: ; <interactive>:28:13: error:; * Could not deduce (KnownNat (Length n0)); from the context: (KnownNat (Length n), a ~ Length n); bound by the type signature for:; lengthOf :: forall (a :: Nat) (n :: [*]). (KnownNat (Length n), a ~ Length n) => Integer; at <interactive>:28:13-88; The type variable `n0' is ambiguous; * In the ambiguity check for `length
01:07:44 <EvanR> bruh where is n0 coming from
01:08:24 <EvanR> %more
01:08:33 <koz_> % more
01:08:33 <yahb> koz_: ; <interactive>:30:1: error:; * Variable not in scope: more; * Perhaps you meant `mode' (imported from Text.PrettyPrint.HughesPJ)
01:08:37 <koz_> LOL
01:10:06 <Ariakenom> % :set -XNoConstrainedClassMethods -XNoJavaScriptFFI -XNoScopedTypeVariables -XNoConstraintKinds -XNoKindSignatures -XNoStandaloneDeriving -XNoDataKinds -XNoLambdaCase -XNoStarIsType -XNoDefaultSignatures -XNoLiberalTypeSynonyms -XNoStaticPointers -XNoDeriveAnyClass -XNoMagicHash -XNoStrict -XNoDeriveDataTypeable -XNoMonadComprehensions -XNoStrictData -XNoDeriveFoldable -XNoMonadFailDesugaring
01:10:06 <yahb> Ariakenom: 
01:10:08 <Ariakenom> -XNoTemplateHaskell -XNoDeriveFunctor -XNoMonoLocalBinds -XNoTemplateHaskellQuotes -XNoDeriveGeneric -XNoMonomorphismRestriction -XNoTraditionalRecordSyntax -XNoDeriveLift -XNoMultiParamTypeClasses -XNoTransformListComp -XNoDeriveTraversable -XNoMultiWayIf -XNoTupleSections -XNoDerivingStrategies -XNoNPlusKPatterns -XNoTypeApplications -XNoDerivingVia -XNoNamedFieldPuns -XNoTypeFamilies
01:10:10 <Ariakenom> -XNoDisambiguateRecordFields -XNoNamedWildCards -XNoTypeFamilyDependencies -XNoDoAndIfThenElse -XNoNegativeLiterals -XNoTypeInType -XNoDuplicateRecordFields -XNoNondecreasingIndentation -XNoTypeOperators -XNoEmptyCase -XNoNumDecimals -XNoTypeSynonymInstances -XNoEmptyDataDecls -XNoNumericUnderscores -XNoUnboxedSums -XNoEmptyDataDeriving -XNoOverloadedLabels -XNoUnboxedTuples
01:10:12 <Ariakenom> -XNoExistentialQuantification -XNoOverloadedLists -XNoUndecidableInstances -XNoExplicitForAll -XNoOverloadedStrings -XNoUndecidableSuperClasses -XNoExplicitNamespaces -XNoPackageImports -XNoUnicodeSyntax -XNoExtendedDefaultRules -XNoParallelArrays -XNoUnliftedFFITypes -XNoFlexibleContexts -XNoParallelListComp -XNoViewPatterns -XNoFlexibleInstances -XNoPartialTypeSignatures
01:10:14 <Ariakenom> -XNondecreasingIndentation -XNoForeignFunctionInterface -XNoPatternGuards -XNoFunctionalDependencies -XNoPatternSynonyms -XNoGADTSyntax -XNoPolyKinds -XNoAllowAmbiguousTypes -XNoGADTs -XNoPolymorphicComponents -XNoAlternativeLayoutRule -XNoGHCForeignImportPrim -XNoPostfixOperators -XNoAlternativeLayoutRuleTransitional -XNoGeneralisedNewtypeDeriving -XNoQuantifiedConstraints -XNoApplicativeDo
01:10:16 <Ariakenom> -XNoGeneralizedNewtypeDeriving -XNoQuasiQuotes -XNoArrows -XNoHexFloatLiterals -XNoRank2Types -XNoAutoDeriveTypeable -XNoImplicitParams -XNoRankNTypes -XNoBangPatterns -XNoImplicitPrelude -XNoRebindableSyntax -XNoBinaryLiterals -XNoImpredicativeTypes -XNoRecordWildCards -XNoBlockArguments -XNoIncoherentInstances -XNoRecursiveDo -XNoCApiFFI -XNoInstanceSigs -XNoRelaxedLayout -XNoCPP
01:10:19 <dminuoso> Haha
01:10:27 <dminuoso> This just made my day./
01:10:35 <EvanR> toast92: ok yeah. InList can only see to the first of a given type
01:11:09 <EvanR> wth
01:12:01 <koz_> Is this yahb throwing up on Ariakenom?
01:12:59 <EvanR> haskell with NoArrows
01:13:08 <EvanR> can you imagine
01:13:59 <dminuoso> EvanR: So I was wondering whether it was because of the recursive tyfam..
01:14:23 <dminuoso> % type family SizeOf x = (y :: Nat) where SizeOf Int = 32
01:14:23 <yahb> dminuoso: ; <interactive>:37:30: error:; Illegal kind signature: `Nat' Perhaps you intended to use KindSignatures; In the declaration for type family `SizeOf'; <interactive>:37:54: error: Illegal type: `32' Perhaps you intended to use DataKinds
01:14:36 <dminuoso> Oh heh
01:14:50 <dminuoso> % :set -XTypeFamilies -XKindSignatures -XScopedTypeVariables
01:14:50 <yahb> dminuoso: 
01:14:52 <dminuoso> % type family SizeOf x = (y :: Nat) where SizeOf Int = 32
01:14:52 <yahb> dminuoso: ; <interactive>:39:54: error: Illegal type: `32' Perhaps you intended to use DataKinds
01:14:56 <dminuoso> % :set -XDataKinds
01:14:56 <yahb> dminuoso: 
01:14:58 <dminuoso> % type family SizeOf x = (y :: Nat) where SizeOf Int = 32
01:14:58 <yahb> dminuoso: 
01:15:07 <dminuoso> % lengthOf :: forall a n. (KnownNat (SizeOf n), a ~ SizeOf n) => Integer; lengthOf = natVal (Proxy :: Proxy a) -- EvanR  this is truly strange
01:15:08 <yahb> dminuoso: ; <interactive>:42:13: error:; * Could not deduce (KnownNat (SizeOf n0)); from the context: (KnownNat (SizeOf n), a ~ SizeOf n); bound by the type signature for:; lengthOf :: forall (a :: Nat) n. (KnownNat (SizeOf n), a ~ SizeOf n) => Integer; at <interactive>:42:13-70; The type variable `n0' is ambiguous; * In the ambiguity check for `lengthOf'; 
01:15:33 <dminuoso> EvanR: My guess here is that the `n0` comes from the equality constraint.
01:15:35 <dminuoso> That is..
01:17:43 <MarcelineVQ> koz_: no
01:25:38 <EvanR> dminuoso: in your last example you use natVal at Proxy a... but in the findFirst code they don't go through a ~, they pick equivalent of SizeOf n as the type
01:26:23 <EvanR> ambiguous n in context SNatRep n, then use getRep :: SNat n
01:27:50 <EvanR> or something, i'm half asleep. But i think these tests aren't doing the same thing
01:28:40 <EvanR> failure to compile function itself, vs failure to use it anywhere because of ambiguity
01:31:33 <dminuoso> Oh yeah I understand that.
01:31:48 <dminuoso> I just dont have the time to beat GHC into submission at the moment. Type programming costs so much effort.. :)
01:32:58 <jellostahps> How do you declare a function empty again, to fill it out later? Like, function1::A->B .... what goes on line 2?
01:33:27 <ChaiTRex> jellostahps: function1 = undefined
01:33:34 <jellostahps> thx
01:33:46 <ChaiTRex> jellostahps: You're welcome.
01:34:09 <dminuoso> jellostahps: It's best to use `_` :)
01:34:29 <dminuoso> jellostahps: That will automatically generate appropriate compiler errors containing the inferred type.
01:51:07 <jusss> dminuoso: MarcelineVQ I just got what I want from scotty, :) thanks
01:51:29 <jusss> what's the different between scotty , yesod, servent?
01:53:26 <dminuoso> jusss: yesod is an opinionated feature-rich web framework with all batteries included. HTML templating, JavaScript, build pipeline, database models, everything. :)
01:54:31 <dminuoso> jusss: servant is a family of libraries designed around type-driven HTTP APIs which is really great if you want to write both a server and some clients sharing the same API. Scotty is just a miniature web framework for simple web tasks.
01:55:48 <maerwald> scotty is simple, servant is elegant, yesod is complex
01:56:09 <dminuoso> The differences are not in complexity, they are rather in the problem domain.
01:57:54 <maerwald> Of course there are differences in complexity. Some of those *might* be related to the problem domain, some might not
01:58:29 <jusss> dminuoso: and wai, warp?
01:58:38 <maerwald> Also note that most of complexity in software is not essential, but accidential complexity
01:59:45 <dminuoso> jusss: wai is a standard/specification how a web application should be exposed, such that you can separate the http server from the application running on it.
01:59:55 <dminuoso> jusss: warp is a http server capable of running wai applications.
02:00:17 <maerwald> dminuoso: https://blog.ploeh.dk/2019/07/01/yes-silver-bullet/
02:00:28 <maerwald> problem domain has little contribution to complexity :)
02:00:53 <learningHaskell> data Tree a = Node a (Tree a) (Tree a)            | Empty              deriving (Show)
02:01:01 <learningHaskell> how to understand the "Node" above-- I've just started in Haskell
02:01:27 <dminuoso> learningHaskell: `Node :: a -> Tree a -> Tree a -> Tree a`
02:01:50 <dminuoso> learningHaskell: So Node is a data constructor taking some value of type `a` and two trees of type `Tree a` and, returning a tree of type `Tree a` :)
02:04:45 <jusss> learningHaskell: also Node is a function
02:05:09 <learningHaskell> oh, i got it
02:05:20 <jusss> this is a recursive type
02:06:03 <learningHaskell> it's a constructor
02:06:05 <jusss> dminuoso: what's the diffrent between the term "type" and "data type" ?
02:06:18 <learningHaskell> is it right?
02:06:25 <jusss> learningHaskell: data constructor, or value constructor
02:06:53 <dminuoso> jusss: It probably depends on the context.
02:07:04 <dminuoso> jusss: "data type" is an expression I would try and avoid.
02:10:30 <jusss> dminuoso: I still have no idea about ADT and what it's used for
02:14:23 <learningHaskell> thank u guys 
02:14:25 <learningHaskell> I thought I got a little bit more clear
02:14:35 <learningHaskell> :] 
02:15:16 <dminuoso> jusss: An ADT is just the simple idea that you can create data types with a) multiple constructors and/or b) multiple fields in a given constructor. Nothing more.
02:15:18 <dminuoso> THat's it. :)
02:16:56 <dminuoso> jusss: Having "multiple constructors" is sometimes called "a sum type" and having "multiple fields in a constructor" is sometimes called a "product type". There's really nothing more to it. :)
02:17:58 <merijn> Well, there's a lot more to it, but all that is mostly unnecessary for programming :p
02:18:59 <jusss> ok
02:19:47 <dminuoso> jusss: In school you most likely learned elementary algebra in which you can add numbers... multiply numbers... so in the same sense the name "algebraic data types" is just derived from the fact that you can "add and multiply types together"
02:21:15 <dminuoso> jusss: (In truth there's more to it like merijn' hinted at, but this is sufficient for Haskell)
02:21:40 <jusss> dminuoso: "add and multiply types together" is related to type family?
02:21:46 <dminuoso> jusss: No.
02:22:14 <dminuoso> jusss: `data F = F Bool Int` can be thought of as "F is Bool * Int" (multiple fields is called multiplication"
02:22:36 <dminuoso> jusss: Or `data G = R Int | L Bool` can be thought of as "G is Int + Bool"
02:23:04 <jusss> dminuoso: and we can ignore those type consturctors?
02:23:20 <dminuoso> jusss: It's just a choice of words, really.
02:23:48 <jusss> dminuoso: ok
02:23:51 <dminuoso> `data F = F Bool Int` is considered to be a product type. A product is what you get when you multiply things - and the things multiplied here are `Bool` and `Int`.
02:23:54 <dminuoso> Like I said
02:23:57 <dminuoso> 10:14:53        dminuoso | jusss: An ADT is just the simple idea that you can create data types with a) multiple constructors and/or b) multiple fields in a given constructor. Nothing more.
02:24:17 <dminuoso> If you have multiple constructors, you are "summing these things" and if you have multiple fields you are "multiplying these things"
02:24:36 <jusss> ok
02:24:38 <ChaiTRex> jusss: If you look at it with Bool, product types multiply the number of possible values of each to get the number of values your type can hold. A Bool Bool Bool Bool can hold 2*2*2*2 different values. Similarly, sum types sum the number of values: A Bool | B Bool has 2+2 different values.
02:24:40 <dminuoso> `data F = G Int Char | H Bool` can be considered `(Int * Char) + Bool`
02:24:55 <phadej> anding and orring is more understandable then multiplying and adding
02:25:28 <jusss> dminuoso: what is this used for ? 
02:25:40 <jusss> type sum or multipy
02:25:50 <merijn> jusss: When you're just starting, nothing really
02:25:51 <jusss> on the value level?
02:25:56 <dminuoso> jusss: It's just a different name for what you know.
02:26:20 <merijn> jusss: It's like preschooler being able to do arithmetic without understanding groups and monoids
02:26:26 <dminuoso> jusss: You call it "this data type has two data constructors". I call it "its a sum type". You say "this data constructor has two fields". I say "its a product type"
02:26:34 <dminuoso> Just different names for the same idea.
02:26:55 <merijn> jusss: The fact that basic arithmetic forms groups and monoids is interesting and you can invent some pretty cool things using that knowledge, but when all you wanna do is arithmetic the underlying theory is rather redundant
02:28:06 <dminuoso> jusss: So when someone says "oh this is a sum type" it just means "the type has two or more data constructors". Or when someone says "this is a product type" it just means "it has multiple fields"
02:28:43 <jusss> the type world is still misterioso to me, type inference, dependent type, polymorphic type, type in type, infinite type, recursive type, type application, type function, type family, type class, kind, sort, what else? :)
02:28:55 <jusss> and that type system
02:29:32 <merijn> jusss: Dependent types are not really relevant when learning Haskell, they might become interesting once you're already comfortable with Haskell
02:29:43 <jusss> I heard that scala has a different type system to haskell
02:29:51 <merijn> type families and type functions are the same thing and again, only really interesting when you're already comfortable with Haskell
02:29:57 <jusss> merijn: I heard rust will have that 
02:30:07 <dminuoso> jusss: Agreed, there's a lot of topics you encounter in Haskell - but thats not because Haskell is complicated, but rather because there's lots of advanced people doing interesting things with Haskell - and that's what you primarily read on blogs or this channel.
02:30:18 <dminuoso> jusss: Most of them are irrelevant to becoming a proficient Haskell programmer.
02:30:24 <dminuoso> Where's that "haskell pyramid" blog entry?
02:30:32 <merijn> dminuoso: Just google haskell pyramid :p
02:30:42 <dminuoso> Oh
02:30:44 <dminuoso> jusss: https://patrickmn.com/software/the-haskell-pyramid/
02:30:50 <merijn> @where+ haskell-pyramid https://patrickmn.com/software/the-haskell-pyramid/
02:30:50 <lambdabot> Done.
02:30:57 <merijn> @where haskell-pyramid
02:30:57 <lambdabot> https://patrickmn.com/software/the-haskell-pyramid/
02:31:08 <merijn> There we go :)
02:31:48 <dminuoso> jusss: So ADT just means "You can have multiple fields and/or constructors for a data type". :)
02:32:19 <jusss> dminuoso: ok, 
02:32:39 <mycroftiv> i think the slippery slope is real, but its a good thing. you start out just wanting to sort some strings into an array, and in about 5 easy connections you are lost in some arxiv paper looking at list sorting as a topological restructuring of some vector space
02:33:00 <jusss> can I describe "data type" is a relation between type and value?
02:33:03 <mycroftiv> but hopefully its a fun and exciting discovery and chance to learn something new
02:33:51 <dminuoso> jusss: I'd say a data type is a type introduced using the keyword data.
02:34:53 <jusss> dminuoso: why people use data to instead of value like value constructor, people will say data constructor
02:35:04 <jusss> but value is a more easier to understand word
02:35:15 <merijn> Is it?
02:35:20 <merijn> Why?
02:35:22 <jusss> type and value, you never say data and type
02:36:11 <jusss> 3 is a value
02:36:24 <jusss> 3 is a value which has Int type
02:40:45 <tdammers> 3 is polymorphic, so it may not be the best example
02:41:18 <tdammers> but anyway, I think a better way of phrasing it is that 3 is a value that inhabits the Int type
02:42:13 <tdammers> you can think of types as sets of values; so it's not so much that the type is an inherent property of the value, but rather, that there is a "member-of" relationship between values and types
02:43:52 <f-a> I smile
02:44:20 <f-a> I wonder if I inhabit the "old people" set or I am just old
02:53:27 <dminuoso> Mmm, in inference rules, how does one talk about literals?
02:56:39 <isnc> Hey, any of you guys can recommend me a good and up-to-date book to learn everything about Haskell? I’ve watched some tutorials and know a bit about Haskell, but I’m interested in going more in-depth. I’d like to use Haskell professionally someday. Thanks 😊
02:57:04 <dminuoso> isnc: What background do you have?
02:57:26 <dminuoso> isnc: What kind of resource are you looking for? Beginner oriented? Something short? More uni lecture oriented?
02:57:28 <isnc> I’m a medior Java developer if that helps
02:57:50 <isnc> Well, I’m actually looking for one book which has it all actually
02:58:58 <isnc> Haskell Programming from first principles is what i’ve found so far. Do you have experience with that?
02:59:07 <merijn> I'm not sure Haskell from First Principles has it all, but it certainly has a lot :p
02:59:25 <dminuoso> isnc: Haskell from First Principles is, as far as I have gathered, really tailored to complete beginners.
02:59:29 <dansho> does anyone know how to debug trace a backprop variable (BVar)?
02:59:36 <merijn> dminuoso: I don't think it is, tbh
02:59:56 <merijn> dminuoso: Experienced programmers say that, but the structure is...suboptimal for complete novices
03:00:38 <merijn> dminuoso: Lots of stuff about working on lists at the start with no real context for beginners on why you'd care. For experienced programmers a lot of those exercises are obviously useful, but not for complete beginners
03:02:18 <isnc> Can the chapters be read in chronological order? Or what do you mean with the suboptimal structure?
03:03:47 <merijn> isnc: dminuoso was arguing that it was more suited to non-programmers, I disagree because the early chapters make a lot of implicit assumptions on what sorta thing you'd want to do in code without adequately explaining for non-programmers
03:04:04 <merijn> isnc: For programmers it seems mostly fine, albeit a bit verbose and slow
03:04:08 <merijn> OTOH it does have exercises
03:06:11 <isnc> merijn: ah ok, I think I’m gonna try out that book. It’s 1228 pages long, so just wanted to make sure if its the right one before I dive in too much lol. Thank you guys :)
03:13:22 <merijn> isnc: Also somewhat relevant
03:13:26 <merijn> @where haskell-pyramid
03:13:27 <lambdabot> https://patrickmn.com/software/the-haskell-pyramid/
03:14:37 <merijn> isnc: I think one of the advantages of that book (and the reason it's so damn long) is that just teach Haskell the language, but also a bunch of common libraries that are pretty crucial to know for writing "real" Haskell
03:15:08 <tdammers> the latter is why I like to recommend Diehl's "what I wish" as a companion to any learning materials
03:15:58 <isnc> merijn: wow, that's a very cool visualisation! 
03:16:02 <maxsu> hey all, in category theory any product category C gets a bifunctor (_,_) : CxC -> C  where given f:a->b, g:c->d we get  (f, g) : (a, c) -> (b, d), and which can be implemented (f,g) (a,b) = (f a, g b)
03:16:14 <merijn> isnc: ^^ prime example right there ;)
03:16:24 <maxsu> I seem to recall that haskell has this, but I don't remember what it's called (either in category theory or in haskell!)
03:16:36 <isnc> merijn: yeah, I guess it has everything I need to learn.
03:16:38 <isnc> lol yh :p
03:17:07 <dminuoso> maxsu: https://hackage.haskell.org/package/profunctors-5.5/docs/Data-Profunctor.html#t:Strong
03:22:34 <maxsu> dminuoso, I'm not sure how to use that.. I seem to remember there was some simple syntax lifting (f,g) : (a -> b, c -> d) to  type (a,c)->(b,d)
03:23:39 <maxsu> which I seem to recall was actually just writing (f,g). But I'm probably confusing category theory syntax for haskell syntax there
03:33:13 <maxsu> dminuoso, I do not thing the functor (_,_) is a profunctor - it's covariant in both arguments, whereas a profunctor requires contravariance in the first arg
03:33:37 <merijn> maxsu: Bifunctor?
03:34:00 <maxsu> but it does seem to be an instance of a bifunctor's dimap function https://typeclasses.com/profunctors
03:34:08 <maxsu> err, bimap*
04:11:19 <__monty__> merijn: Is the pedagogy of the Hutton book better?
04:12:20 <Rembane> What does the First semigroup do? 
04:12:30 <Rembane> It doesn't seem to give me the first element of a list for instance. 
04:22:55 <merijn> __monty__: No clue
04:23:36 <merijn> __monty__: I haven't read it (I haven't really read HffP either, but I've at least looked through parts while helping my girlfriend)
04:24:10 <merijn> > sconcat $ map First [1..10]
04:24:13 <lambdabot>  error:
04:24:13 <lambdabot>      • Couldn't match expected type ‘NonEmpty a’
04:24:13 <lambdabot>                    with actual type ‘[First a0]’
04:24:18 <merijn> oh, right
04:24:34 <merijn> > sconcat $ fmap First (1 :| [2..10])
04:24:37 <lambdabot>  error:
04:24:37 <lambdabot>      • No instance for (Num (Maybe ())) arising from a use of ‘e_11210’
04:24:37 <lambdabot>      • In the expression: e_11210
04:24:46 <merijn> Oh, that's the wrong First >.>
04:25:10 <merijn> > sconcat $ fmap Data.Semigroup.First (1 :| [2..10])
04:25:13 <lambdabot>  error:
04:25:14 <lambdabot>      Not in scope: data constructor ‘Data.Semigroup.First’
04:25:16 <lambdabot>      Perhaps you meant variable ‘Data.Semigroup.stimes’ (imported from Data.S...
04:26:08 <merijn> Rembane: Anyway, works just fine in ghci
04:26:49 <lavalike> ``No module named ‘Data.Semigroup’ is imported.'' ):
04:27:13 <merijn> lavalike: Yes, but then I end up shadowing stuff and doing more stuff to fix that, etc.
04:30:17 <lavalike> > sconcat . fmap Data.Semigroup.First $ 1 Data.List.NonEmpty.:| [2..10::Int]
04:30:19 <lambdabot>  First {getFirst = 1}
04:30:45 <lavalike> (had to add those two imports to lambdabot tho)
04:55:12 * hackage semirings 0.5.2 - two monoids as one, in holy haskimony  https://hackage.haskell.org/package/semirings-0.5.2 (chessai)
05:00:12 <minijinski> Hello, i want to round a decimal of a double (-5.345 -> -5.35) is it possible ?
05:00:58 <fweht> minijinski: multiply by 10^k -> round -> multiply by 10^-k
05:01:22 <fweht> in your case k=1
05:01:42 <fweht> with other k you can round also in other decimal positions
05:01:59 <tabaqui1> if you don't need an actual double, but it's string representation, you can use functions from Numeric module of base
05:02:11 <tabaqui1> *its
05:02:22 <Guest_11> Hello, after the new Mac Update (Catalina) ghci doesn't work anymore. Can someone tell me how to set the right Path again?
05:02:42 <maerwald> Guest_11: how did you install?
05:03:41 <Guest_11> With this command: curl https://get-ghcup.haskell.org -sSf | sh
05:04:05 <maerwald> do you have a ~/.bashrc?
05:04:43 <Guest_11> Yes.
05:05:02 <maerwald> does it have a line: source "${HOME}"/.ghcup/env
05:06:02 <fweht> minijinski: hey sorrry i thought i was on the ##math channel 😳
05:06:20 <Guest_11> Should this line be there?
05:07:04 <maerwald> Guest_11: yeah
05:07:21 <minijinski> fweht: I was trying with your technique but it doesn't work ?
05:07:34 <fweht> minijinski: yeah, i didnt use haskell syntax
05:07:45 <fweht> i just thought you want to know the mathematics
05:07:47 <minijinski> tabaqui1: it's a string before beeing a double, how could I do it then ? 
05:08:14 <minijinski> fweht: Oh ok no problem anw 
05:09:18 <maralorn> minijinski: I actually don think that you can achiev that specific rounting in Haskell.
05:09:28 <maralorn> *achieve, *rounding
05:09:46 <maralorn> I mean, not using standard functions.
05:10:08 <tabaqui1> ok, btw you can use Text.Printf to read in C-style but it's dangerous
05:10:33 <tabaqui1> % printf "%f" 0
05:10:33 <yahb> tabaqui1: *** Exception: printf: bad formatting char 'f'
05:10:41 <tabaqui1> % printf "%f" (0 :: Float)
05:10:41 <yahb> tabaqui1: 0.0
05:10:52 <maralorn> There is the "round" function, but it rounds to the nearest even number when it meets a 5.
05:11:27 <maralorn> minijinski: Is the length of the double fix?
05:12:31 <maralorn> Anyways: (/ 100) . round . (* 100) $ -5.345 = -5.34
05:12:37 <minijinski> maralorn: the result must have 2 digits after the decimal point, yea
05:13:11 <maralorn> Modulo type conversions.
05:13:35 <tabaqui1> oh, sorry, you don't need to print it
05:13:43 <Guest_11> fweht: thank you so much
05:15:06 <maralorn> > ((/ 100.0) . fromInteger . round . (* 100.0) $ -5.345) :: Double
05:15:08 <lambdabot>  -5.34
05:15:24 <maralorn> minijinski: There you go.
05:15:50 <maralorn> > ((/ 100.0) . fromInteger . round . (* 100.0) $ -5.355) :: Double
05:15:51 <lambdabot>  -5.36
05:16:04 <maralorn> > ((/ 100.0) . fromInteger . round . (* 100.0) $ -5.35234) :: Double
05:16:06 <lambdabot>  -5.35
05:16:27 <minijinski> damn, thanks a lot it work now ! :)
05:19:02 <maralorn> Just a remark: If you always need two digits after the decimal point, you might consider not using Double for that at all. (especially when you are working with money). That could be a way to make your program a bit more typesafe.
05:19:28 <dminuoso> maxsu: Ah sorry indeed. I didn't look closely enough. :)
05:19:58 <dminuoso> Rembane: First gives you the first Just.
05:20:07 <merijn> dminuoso: Depends on which First
05:20:19 <merijn> dminuoso: That's just the shitty one from Data.Monoid
05:20:27 <dminuoso> "shitty" - that's quite hateful.
05:20:32 <dminuoso> I think First is quite useful.
05:20:42 <merijn> dminuoso: It's strictly worse than First from Data.Semigroup
05:21:03 <dminuoso> merijn: Ah. Yes.
05:23:36 <minijinski> maralorn: Float instead Double then ? I'm doing a parser for a calculator
05:23:52 <maralorn> I am not sure, if I have a problem with hate speech against abstract objects. „5 x 5 matrices are the worst!“
05:24:15 <maralorn> minijinski: Hm, ah, no. I think for a calculator double is a fine choice.
05:26:06 <maralorn> minijinski: If you wanna make a real good calculator you could consider using the Scientific data type from the scientific package. Then you have arbitrary precision.
05:28:25 <minijinski> maralorn: I'm doing that as a training in haskell, just wanted to use the base package to learn
05:31:49 <minijinski> > ((/ 100.0) . fromInteger . ceiling . (* 100.0) $ -5.345) :: Double
05:31:50 <lambdabot>  -5.34
05:36:20 <merijn> Well, here's a neat part of base to learn, then: Data.Fixed :)
05:36:29 <merijn> > 5.4978742 :: Centiy
05:36:31 <lambdabot>  error:
05:36:31 <lambdabot>      Not in scope: type constructor or class ‘Centiy’
05:36:31 <lambdabot>      Perhaps you meant ‘Centi’ (imported from Data.Fixed)
05:36:32 <merijn> > 5.4978742 :: Centi
05:36:35 <lambdabot>  5.49
05:36:38 <merijn> > 5.4978742 :: Milli
05:36:40 <lambdabot>  5.497
05:37:47 <lavalike> what package is that?
05:37:54 <merijn> lavalike: Eh, base? :p
05:38:01 <lavalike> I never seen those types before!
05:38:04 <merijn> Data.Fixed as I just mentioned
05:38:12 <lavalike> my bad, thanks
05:38:25 <merijn> lavalike: Centi/Milli are type synonyms for Fixed with a specific phantom type
05:38:41 <merijn> lavalike: Data.Fixed is pretty cool because it even supports easily defining custom precisions
05:38:52 <lavalike> it looks excellent
05:39:03 <maralorn> Awesome!
05:39:59 <maralorn> Looks very usefull for money.
05:41:27 <lavalike> for money you're supposed to ship all the calculations through a unix socket to your COBOL codebase
05:42:18 <maralorn> Just be careful: The :: Centi typ cast truncates and doesn‘t round.
05:43:54 * sm[m] uses Decimal for money
05:44:36 <Rembane> merijn, dminuoso: Got it! Thank you! 
05:48:09 <dminuoso> merijn: What a shame sqlite has only one available pragma for users. :(
05:49:31 <merijn> dminuoso: Why do you need more?
05:50:45 <dminuoso> merijn: I am running period actions and I would like to store the timestamp of the last run in order to assert monotonicity of the time.
05:51:34 <dminuoso> I mean yeah.. I can keep that in a single row in some table, it's just a shame there's not much support for "I just need to store a single value"
05:53:11 <untseac> hello, quick question. should I have everything static or dynamic link? What's the recommended way nowadays? I don't really care about the pros and cons (for now), I just want to have code working.
05:53:32 <untseac> I know arch has static versions, that's why I'm asking
05:54:15 <opqdonut> anyone here tried safe haskell? I have a module A marked with {-# LANGUAGE Unsafe #-} and I do a "import safe B". even though module B uses unsafePerformIO module A compiles fine
05:54:35 <opqdonut> if I try to explicitly compile module B with -XSafe or LANGUAGE Unsafe it fails
06:06:40 <jedai> untseac: static is the default, AFAIK, dynamic is still only a choice you would make if you have specific needs
06:06:42 <merijn> dminuoso: I just have a GlobalVar table for that :p
06:07:10 <merijn> untseac: The default (and recommended way) is to have GHC link all haskell libraries statically and all C libraries dynamically
06:08:15 <untseac> thanks jedai and merijn. Meaning I'll just use the static versions and install everything else with stack or nix or whatever
06:08:42 <merijn> untseac: That's the best way, yes
06:13:43 <merijn> untseac: FWIW, my solution is generally to install the official GHC bindists and build cabal myself to bootstrap a working environment
06:14:48 <merijn> untseac: That way I know I have everything working the same across environments
06:15:48 <tabaqui1> probably, you would prefer dynamic binding in case of the big home enviroment for all needs
06:16:12 * hackage ghc-events-analyze 0.2.6 - Analyze and visualize event logs  https://hackage.haskell.org/package/ghc-events-analyze-0.2.6 (EdskoDeVries)
06:16:15 <tabaqui1> like XMonad, file and network browsers (lol) and so on
06:16:46 <tabaqui1> in this case static binaries would consume a lot of memory on disk
06:19:34 <merijn> define "a lot" :p
06:20:42 * hackage ghc-lib-parser 0.20191101 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-parser-0.20191101 (shayne_fletcher)
06:21:42 * hackage ghc-lib 0.20191101 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-0.20191101 (shayne_fletcher)
06:27:11 <merijn> tabaqui1: I mean, I have an executable of something like 10k LOC with 45 direct dependencies (>150transitive dependencies or so) and that one is 9 MB after stripping, which doesn't seem like such a huge size
06:27:31 <merijn> Sure, it's not skinny by "micro C applications", but not bloated to the point it's worth thinking about
06:27:53 <tabaqui1> I agree with you, it's a very rare case
06:28:50 <tabaqui1> I mean, that one should the difference between static and dynamic linking and theirs advantages
06:30:13 <tabaqui1> and the advantage of dynamic linking is tiny in case of Haskell, because the most part of the word has C dependencies
06:30:36 <tabaqui1> *one should know the difference
06:34:31 <tabaqui1> oh, there is another one: if your app depends on vulnerable version of library
06:34:41 <tabaqui1> than you can patch and rebuild only the dependency
06:34:56 <merijn> tabaqui1: Nope
06:35:16 <merijn> Only for C dependencies, but C dependencies are dynamically linked by default anyway
06:35:35 <tabaqui1> GHC doesn't allow this? Why so?
06:36:15 <merijn> tabaqui1: It's not that it doesn't allow this, but GHC inlines across package boundaries to get good performance, so implementation details of transitive dependencies leak through packages
06:36:48 <merijn> tabaqui1: So if you rebuild a dependency you have to rebuild everything using it *anyway*, so there's no advantage
06:36:48 <tabaqui1> ah, okay then
06:36:53 <tabaqui1> I didn't know it
06:37:12 <merijn> tabaqui1: You COULD make it so that you can do it, but then you'd ruin the performance quite drastically
06:39:14 <Orbstheorem> Is there any standard function `sh f ls as = if null f ls then ls else as` ?
06:39:25 <tabaqui1> % :t bool
06:39:25 <yahb> tabaqui1: a -> a -> Bool -> a
06:39:34 <tabaqui1> bool (print 1) (print 2) True
06:39:37 <tabaqui1> % bool (print 1) (print 2) True
06:39:37 <yahb> tabaqui1: 2
06:40:53 <Orbstheorem> Oh
06:42:17 <Orbstheorem> Thanks ^^
06:42:42 <tabaqui1> you're welcome
06:43:42 * hackage data-serializer 0.3.4.1 - Common API for serialization libraries  https://hackage.haskell.org/package/data-serializer-0.3.4.1 (MikhailVorozhtsov)
06:48:12 * hackage replace-attoparsec 1.2.0.0 - Find, replace, and edit text patterns with Attoparsec parsers  https://hackage.haskell.org/package/replace-attoparsec-1.2.0.0 (JamesBrock)
06:51:12 * hackage replace-megaparsec 1.2.0.0 - Find, replace, and edit text patterns with Megaparsec parsers  https://hackage.haskell.org/package/replace-megaparsec-1.2.0.0 (JamesBrock)
07:09:12 * hackage data-textual 0.3.0.3 - Human-friendly textual representations.  https://hackage.haskell.org/package/data-textual-0.3.0.3 (MikhailVorozhtsov)
07:32:42 * hackage postgresql-simple-opts 0.5.0.1 - An optparse-applicative and envy parser for postgresql-simple's connection options  https://hackage.haskell.org/package/postgresql-simple-opts-0.5.0.1 (JonathanFischoff)
07:47:24 <dminuoso> In `time`, is there a standard way to turn an UTCTime into a Day?
07:47:42 * hackage tmp-postgres 1.0.0.1 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.0.0.1 (JonathanFischoff)
07:48:25 <merijn> dminuoso: You need to convert it to a zoned time first
07:49:10 <merijn> Oh, apparently you don't
07:49:30 <merijn> dminuoso: How about the utctDay record field? :p
07:49:46 <dminuoso> merijn: Heh yeah I just spotted that too. I kept looking in the Calendar modules.
08:03:57 <dminuoso> Finally! A use case for fix!
08:04:48 <tabaqui1> great
08:04:50 <tabaqui1> what for?
08:05:07 <dminuoso> tabaqui1: https://gist.github.com/dminuoso/8e7a0d107812efae00ac46b6b98b2b0b
08:05:22 <dminuoso> tabaqui1: This is less annoying than to make a separate binding for that verbosity parameter...
08:05:23 <tabaqui1> I've used it once to make Arbitrary instance for unique elements list
08:06:24 <dminuoso> Oh, I copied one line too few, there's a recursion step there of course.
08:06:54 <tabaqui1> just "    loop"?
08:08:10 <tabaqui1> hmm, I could reuse this approach too
08:08:15 <chreekat_> % :t forever
08:08:15 <yahb> chreekat_: Applicative f => f a -> f b
08:08:32 <tabaqui1> just remove all these "go where go = "
08:08:40 <merijn> chreekat_: forever can be less efficient in some cases
08:08:51 <merijn> chreekat_: Because there's no sharing
08:11:00 <chreekat_> so dminuoso, is that why you're using fix in this case? :) Inefficiency due to lack of sharing?
08:12:06 <merijn> chreekat_: For some transformers >>= and up rewalking the stack every iteration, by using fix this only happens once
08:14:55 <tabaqui1> ah, it is such useful. Thanks, dminuoso!
08:15:19 <merijn> I recall a nice blogpost/article on this, but can't find it right now :\
08:15:23 <Orbstheorem> How can I access a record like a nested hashmap? (e.g. `mylookup "volumes.size" FOO{volumes = BAR{size = 2}}` = `2`)
08:15:47 <tabaqui1> lenses
08:16:06 <tabaqui1> Orbstheorem: https://hackage.haskell.org/package/lens
08:17:17 <tabaqui1> though, in your case microlens package would be prettier
08:20:32 <dminuoso> tabaqui1: Of course it just occured to me, that `forever` does it even better..
08:21:56 <tabaqui1> you cannot pass modified context with forever (without Reader)
08:22:27 <tabaqui1> like "foldSomehow = go mempty where go cdr = takeNew >>= go . (:cdr)"
08:22:29 <tabaqui1> or whatever
08:22:35 <dminuoso> Oh yeah I suppose so
08:23:13 <Orbstheorem> tabaqui1: here we go! 
08:23:21 <tabaqui1> but this approach "go where go =..." cannot use variables from the do-context before
08:23:51 <tabaqui1> so you have to pass all opened sockets/files/etc as arguments, which is ugly if there many of them
08:23:55 <opqdonut> Orbstheorem: if you just want to read, you can just literally say: (size.volumes) foo
08:24:05 <opqdonut> Orbstheorem: so compose the field access functions
08:24:28 <opqdonut> > (fst.fst) ((1,2),3) -- example with tuples
08:24:30 <lambdabot>  1
08:24:37 <dminuoso> tabaqui1: Yeah, that's basically how the idea of using fix started.
08:24:53 <Orbstheorem> Unfortunately I need bare strings (since I want to use it with ginger) 
08:24:55 <dminuoso> tabaqui1: In order to use do bound variables without a let binding creating the loop.
08:25:10 <tabaqui1> I dunno, there are many fixed-point combinators
08:25:12 <Orbstheorem> But it looks amazing *.*
08:25:32 <tabaqui1> I guess, one should choose appropriate for efficiency
08:25:36 <tabaqui1> but I don't know how
08:25:50 <dminuoso> Im in the lucky spot to not care about efficiency at all.
08:25:55 <dminuoso> I care about correctness.
08:26:11 <dminuoso> This job could take hours to update this single sqlite row for all I care
08:56:10 <EvanR> Which number type is best for a straight forward calculator program... Data.Fixed won't let you do a square root out of the box. Double gives unintuitive results wrt base 10. CReal and Scientific possibly freeze...
08:57:07 <EvanR> CReal and Double are the only ones off the top of my head that have square root
08:59:09 <EvanR> CReal might be best after all
09:00:47 <EvanR> > let x = 123e-123 :: CReal in (x, log10 x)
09:00:48 <lambdabot>  error:
09:00:49 <lambdabot>      • Variable not in scope: log10 :: CReal -> b
09:00:49 <lambdabot>      • Perhaps you meant ‘log1p’ (imported from Numeric)
09:01:19 <phadej> I'm quite sure there was a library for exact algebraic numbers, but cannot find it
09:01:28 <EvanR> cyclotomic?
09:02:18 <EvanR> > let x = 123e-123 :: CReal in (x, logBase 10 x)
09:02:20 <lambdabot>  (0.0,-120.9100948885606020681955602467767038912694)
09:02:37 <EvanR> > let x = 123e-123 :: Double in (x, logBase 10 x)
09:02:39 <lambdabot>  (1.23e-121,-120.9100948885606)
09:05:50 <sm[m]> How about Decimal, EvanR ?
09:07:05 <lavalike> …or implement square root (:
09:07:35 <EvanR> dang didn't know about this package
09:07:46 <EvanR> capital D Decimal 
09:08:20 <EvanR> lavalike: a tall order for Fixed types and a beginner programming task :S
09:08:43 <EvanR> but i'm now seeing calculators are ironically not very beginner friendly
09:14:17 <EvanR> Decimal also has no sqrt or sin etc
09:14:35 <EvanR> CReal reigns
09:27:30 <s0kil> Hello everyone!
09:27:30 <s0kil> I was wondering what is the recommened way for beginners to learn Haskell, books, videos, blogs,etc?
09:27:54 <lavalike> > let fix' f x = let fx = f x in if abs (x - fx) <= 1/10^(resolution x) then fx else fix' f fx; sqrt' n = fix' (\x -> (x + n/x)/2) 1 in sqrt' <$> [0.09, 0.25, 0.36, 1 :: Centi, 2, 3, 9, 25, 36]
09:27:57 <lambdabot>  [0.30,0.50,0.60,1.00,1.41,1.73,3.00,5.00,6.00]
09:28:16 <sm[m]> s0kil: yes
09:29:15 <lavalike> > let fix' f x = let fx = f x in if abs (x - fx) <= 1/10^(resolution x) then fx else fix' f fx; sqrt' n = fix' (\x -> (x + n/x)/2) 1 in sqrt' (2 :: Data.Fixed.Fixed E6)
09:29:16 <lambdabot>  1.414213
09:29:17 <sm[m]> and hello :)
09:30:17 <lavalike> EvanR: ^
09:30:26 <s0kil> I have encountered https://stackoverflow.com/a/1016986/7889817, Is this the best way to go in 2019?
09:32:15 <sm[m]> there are really many learning paths, it depends on what you like and need
09:32:52 <sm[m]> http://haskell.org (-> Documentation) is an obvious starting point. I always add HTAC to the recommendations
09:32:52 <sm[m]> @where HTAC
09:32:53 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
09:34:34 <sm[m]> there are actually so many learning resources nobody knows them all
09:35:15 <Orbstheorem> I'd like to make a function that takes an argument of kind (* -> *) and returns a String. I thought DataKinds was the way to go but I'm a bit lost. In practice, I'd like to associate a string to record constructors so I can typecheck that if that record type is used I will be able to find its associated string on runtime
09:35:48 <s0kil> I want to become proficient using Haskell, and start building REST API's.
09:36:20 <s0kil> It seems like Yesod is a reasonable
09:36:49 <heatsink> Orbstheorem, typeOf does that
09:37:16 <heatsink> > typeOf (Proxy :: Proxy [])
09:37:18 <lambdabot>  Proxy (* -> *) []
09:37:49 <heatsink> > "The type is: " ++ show (typeOf (Proxy :: Proxy []))
09:37:50 <lambdabot>  "The type is: Proxy (* -> *) []"
09:38:23 <EvanR> you can write javascript in any language!
09:38:24 <sm[m]> s0kil: yep. It has a useful book
09:39:18 <EvanR> Orbstheorem: there's likely a better way to solve the actual issue, whatever it is. Casing on arbitrary pretty printed dynamic types doesn't sound very haskelly
09:40:49 <Orbstheorem> heatsink: typeOf takes an instance, I don't have an instance; but rather I want to construct that instance from the string
09:41:03 <Orbstheorem> I may not have expressed myself correctly
09:41:20 <Orbstheorem> (My my whiteboard it makes sense xD)
09:41:26 <Orbstheorem> s/My/In)
09:41:52 <Orbstheorem> Let me rethink the problem and come back
09:42:28 <heatsink> Why do you want to construct an instance of a type from a run-time type descriptor?
09:43:09 <heatsink> Usually, when you want to construct a value, you already know the type you want to construct
09:43:51 <Orbstheorem> Yes, I think I may expressed the contrary of what I'm looking for
09:44:18 <moet> hello! if i have a `class Bar f` and I declare an instance `instance Ord n => Bar n` I'm immediately in UndecidableInstances territory. What is this kind of instance called (where the methods of an existing class are used to implement the new class), and is UndecidableInstances an inevitable result of this pattern?
09:46:45 <glguy> moet: You don't need a new class in that case; you can just write some definitions in terms of Ord
09:49:52 <moet> glguy: yes, if i only had the one instance, then the class is redundant
09:50:04 <glguy> and that isntance would overlap with any other instance
09:50:05 <Orbstheorem> let records Foo {a :: A, b :: B}, Bar {c :: C}, Baz {..}, let kind FBB = Foo | Bar | Baz, let family of functions f :: a -> FBB, for every element of FBB. I would like ghc to complain if one of the functions is not defined
09:51:12 <heatsink> I think a closed type family would do that
09:51:30 <Orbstheorem> heatsink: Rings a bell
09:51:34 <heatsink> I haven't used them before.  Perhaps someone else can explain it
09:55:37 <moet> glguy: wouldn't the instance only overlap with instances whose type also had `Ord`?
09:55:41 <glguy> no
09:56:40 <moet> i'll test it out and try to understand; thanks
09:57:17 <chreekat_> moet: some details are missing, perhaps. Is it "class Ord f => Bar f" that you want? Or do you want constraints on some of Bar's methods?
09:59:20 <glguy> moet: the constraints aren't considered when picking an instance
10:00:26 <emanuel_> finally got coc working (silly name)
10:00:41 <Orbstheorem> heatsink: The problem I see with type families is that they give me type computations, I think that in my case what I'd like is rather to descend the type as a value in my equation
10:01:59 <heatsink> Orbstheorem, if it's a closed family, you can use a GADT to reflect the type as a value
10:02:36 <heatsink> data FBBTag (a :: FBB) = FooTag Foo | BarTag Bar | BazTag Baz
10:02:45 <heatsink> I mean
10:02:56 <heatsink> data FBBTag (a :: FBB) where FooTag :: FBBTag Foo | ...
12:05:22 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org'
12:05:22 --- topic: set by glguy on [Sat Jan 05 07:21:52 2019]
12:05:24 <zincy_> koz_: Was that for me?
12:05:47 <koz_> zincy_: I was meaning to display a message to the effect of 'ask your question, because anyone who knows will chime in'.
12:10:28 <zincy_> ok
12:12:17 <zincy_> https://pastebin.com/9bmkHd97
12:13:01 <zincy_> Trying to write a query which includes a list of associated items from a join through table
12:13:10 <zincy_> But every method I have tried so far the typechecker infers that there is no list
12:22:26 <ggVGc> Hrm, I think I've asked this before... But why does this give me overlapping instances? https://gist.github.com/07a38f447523345d55b07dff51415b36
12:23:34 <koz_> Is Int an instance of QuatSpec?
12:23:47 <ggVGc> no
12:24:25 <lyxia> (ValRange -> a) and (ValRange -> Int) overlap because if you set a = Int then you get the same type
12:25:23 <ggVGc> right, I remember now, type class instance resolution happens before constraints, right? (badly expressed)
12:25:39 <ggVGc> is there a way to do what I want?
12:26:30 <ggVGc> e.g one instance of Lang for QuatSpec instances, and one for other concrete types
12:30:27 <ggVGc> I think the issue is I've again falling into the type class trap... This should all just be records
12:32:59 <drdo> Has it ever been seriously considered having named instances and parameterizing everything with the instance (perhaps with implicit arguments as well)?
12:34:59 <iptq> Quick q, is there a way to turn on compile errors for cases that aren't covered while pattern matching
12:39:18 <dsal> What is 'pattern' ?
12:39:49 <dsal> iptq: -Wall
12:39:55 <dsal> + -Werror
12:40:09 <dsal> You can be more specific, but I like -Wall -Werror most of the time.
12:40:37 <iptq> O ok thanks
12:42:54 <dsal> Hmm...  TIL pattern synonyms.  I wonder if this is the thing I wanted recently...
12:45:45 <lyxia> ggVGc: The rule is that you look only to the right of (=>) to determine overlap/choose the next instance.
12:55:35 <ralftshirt> k
13:01:23 <tabaqui1> I have such implementation of factorial function: "fact n = fix (\go x k -> if k == 0 then x else go (x * k) (k - 1)) 1 n"
13:01:42 <tabaqui1> as I see, combinator from Control.Monad.Fix causes memory leak
13:02:02 <tabaqui1> is there any fixed-point combinator that doesn't in case of tail recursive function?
13:02:10 <tabaqui1> % fact n = fix (\go x k -> if k == 0 then x else go (x * k) (k - 1)) 1 n
13:02:10 <yahb> tabaqui1: 
13:02:14 <tabaqui1> % fact 5
13:02:14 <yahb> tabaqui1: 120
13:05:04 <tabaqui1> btw, I cannot even understand why memory leaks here; all together seems tail recursive for me
13:06:38 <bollu> What's that quote about haskell being designed to be unsuccessful?
13:07:02 <tabaqui1> avoid success at all costs?
13:07:03 <EvanR> haha
13:07:05 <tabaqui1> @where avoid
13:07:05 <lambdabot> I know nothing about avoid.
13:07:11 <tabaqui1> @quote avoid
13:07:11 <lambdabot> mzan says: temo un attentato dell'HISIS il gruppo di fanatici dell'avoid success at al costs!
13:07:15 <tabaqui1> @quote avoid success
13:07:15 <lambdabot> No quotes for this person. Just what do you think you're doing Dave?
13:07:20 <tabaqui1> @quote success
13:07:20 <lambdabot> deech`` says: <deech``> Has anyone here successfully installed Haskore? And if you have how much of a pain was it. <ksf> deech``, imagine impaling yourself on a ship mast wrapped with red-glowing,
13:07:20 <lambdabot> barbed wire.
13:07:45 <EvanR> k that's ancient
13:07:47 <dsal> avoid success at all costs is my current quickcheck strategy
13:07:54 <tabaqui1> if you mean "avoid success..." quote, then I can tell you that people understand it wrong
13:08:13 <dsal> If it's the one I'm thinking of, it's more about not becoming popular.
13:08:13 <tabaqui1> they usuall forget about quotes here: avoid "success at all costs"
13:08:37 <EvanR> tabaqui1: tail recursive in haskell doesn't imply "no leak memory"
13:08:40 <sm[m]> anyone using http://repl.it extensively with haskell ? I see it can import a github repo, and I was just trying to see how far you can get with :set to enable CPP, load cabal macros, install deps etc.
13:08:42 <EvanR> @src foldl
13:08:43 <lambdabot> foldl f z []     = z
13:08:43 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
13:09:13 <tabaqui1> EvanR: oh, did I forget about laziness?
13:09:20 <EvanR> i dunno
13:09:30 <sm[m]> and here's the shortcut url for a haskell paste, FYI: https://repl.it/languages/haskell
13:10:42 * hackage github-rest 1.0.0 - Query the GitHub REST API programmatically  https://hackage.haskell.org/package/github-rest-1.0.0 (leapyear)
13:11:33 <tabaqui1> % fact n = fix (\go x k -> if k == 0 then x else let a = go (x * k) (k - 1) in seq a a) 1 n
13:11:33 <yahb> tabaqui1: 
13:11:35 <tabaqui1> % fact 5
13:11:36 <yahb> tabaqui1: 120
13:11:42 <tabaqui1> (it still leaks)
13:12:24 <bollu> tabaqui1 ah yes, that's the one
13:13:40 <tabaqui1> EvanR: yeah, cool, thanks
13:13:52 <tabaqui1> I need to seq (x * k) and (k - 1) there
13:14:20 <tabaqui1> so fix is safe in terms of memory
13:14:32 <EvanR> yeah seq a a does nothing
13:14:53 <EvanR> all fix does is
13:14:57 <EvanR> @src fix
13:14:57 <lambdabot> fix f = let x = f x in x
13:15:15 <bollu> tabaqui1 thanks for the quote :) 
13:15:28 <tabaqui1> yeah, I know, but I cannot image assembly code in my head so easy
13:15:42 <EvanR> no idea what the assembly code looks like for that
13:15:55 <tabaqui1> bollu: do not forget about the quotes around "at all costs" :)
13:16:03 <dsal> My brain won't let me understand fix.
13:16:05 <bollu> tabaqui1 ofc :D 
13:16:30 <EvanR> to understand fix f, you must first understand f (fix f)
13:16:41 <bollu> dsal expand it out: f (f ( f( f( f( ...))))) but it's lazy, so you get to compute as much of the f ( f ( f (...))) as you want
13:16:43 <tabaqui1> EvanR: but how do realize that tail recursion can be optimized?
13:16:44 <EvanR> or the other way around
13:16:54 <sm[m]> dsal, ha, me too
13:17:19 <EvanR> we need an FAQ write up about "tail recursion optimization (misnomer?)" 
13:17:22 <EvanR> in haskell
13:17:54 <EvanR> haskell doesn't compile in a way resembling C or eager lisp
13:19:00 <tabaqui1> but Haskell is running on real hardware
13:19:10 <EvanR> no small miracle :)
13:19:11 <dsal> EvanR: Oh.  I think your explanation was pretty clear.
13:20:16 <sm[m]> well it looks like you can cabal install things on repl.it
13:20:42 <dsal> Interesting.  I think I tried using that a while back and sent them feedback because it was missing a few things I considered essential.
13:20:58 <trollfactory> help
13:21:11 <trollfactory> can someone help me to create new objects
13:21:22 <dsal> I have 3D printers.
13:21:39 <tabaqui1> I know a guy that has a 3D printer
13:21:54 <sm[m]> and you can add load paths and CPP with :set -iDIR -cpp
13:22:07 <sm[m]> but as usual, enabling cabal macros is hard
13:22:12 * hackage token-limiter 0.2.0.0 - Fast rate limiting using the token bucket algorithm (BSD)  https://hackage.haskell.org/package/token-limiter-0.2.0.0 (GregoryCollins)
13:22:29 <EvanR> newIORef :: a -> IO (IORef a)  -- creates an object
13:22:54 <trollfactory> i am so angry because functional programming is not good for a generic newbie
13:23:23 <tabaqui1> Lisp is the easiest language in the world
13:23:28 <Deide> Is any programming good for a generic newbie?
13:23:31 <dsal> I'd imagine FP would be very good for newbies.  Probably not as good for people with a lot of experience teaching them to think badly.
13:23:40 <yushyin> trollfactory: so your question is?
13:24:18 <ysangkok> tabaqui1: easy for what purpose? that statement is like bait lol
13:24:18 <dsal> I was teaching my gf haskell recently.  She was doing things that were hard for me to learn naturally.  I asked her how she was able to do that and she said, "It's just math *shrug*"
13:24:37 <dsal> ysangkok: Each to describe the syntax of.
13:25:00 <tabaqui1> and to understand how everything works
13:25:16 <tabaqui1> and after all it is the best language to create other languages
13:25:19 <EvanR> i had a hard time understanding lisp until i learned haskell, go figure
13:25:20 <ysangkok> in that case, an abstraction that doesn't define syntax should be considered even simpler. like lambda calculus :P
13:25:33 <Deide> I think most programming resources are not in a functional style, so newbies just get more exposure to imperative/procedural.
13:25:42 <tabaqui1> Lisp *is* lambda calculus :)
13:25:54 <EvanR> skeptical
13:25:54 <tabaqui1> and it has no syntax :)
13:26:31 <trollfactory> i am so angry
13:26:38 <tabaqui1> take it easy, dude
13:26:52 <trollfactory> only giftred teenagers or otherwise mathematically oriented people can learn functional paradigm
13:27:09 <mycroftiv> isnt it like 97.2% chance that trollfactory is a bot? i mean, i think the name kinda gives it away...
13:27:14 <dsal> I learned haskell in my 40s, I think.  I have no math background.
13:27:17 <MarcelineVQ> I am angry too let us form a club where we do constructive crafts as a form of catharsis.
13:28:23 <dsal> ha.  I was angry at this property that was failing and then realized I've not written the code to make it pass.
13:28:49 <ysangkok> MarcelineVQ: do you consider the Calculus of Constructions a constructive craft? :P
13:29:45 <ysangkok> MarcelineVQ: i propose a definition of 'constructive' that means you can't talk about syntax :P
13:30:22 * dsal (talks 'about 'syntax)
13:31:27 <trollfactory> but according to some people people can learn programming and software developtment in 3 months and get well paid jobs because of that
13:31:51 <MarcelineVQ> sure but I'm not so good at constructive proofing
13:31:59 <dsal> trollfactory: If that's true, I don't want to work in one of those places.
13:32:30 <MarcelineVQ> Anyone that can learn that much in 3 months is likely to end up in a well paid job
13:32:37 <ysangkok> MarcelineVQ: does that mean you are better at classical proving?
13:32:47 <MarcelineVQ> ysangkok: not even a litte :D
13:33:48 <EvanR> classical proofing, where you line the walls with anti-mozart filter
13:34:42 * hackage recursion 2.2.4.1 - A recursion schemes library for Haskell.  https://hackage.haskell.org/package/recursion-2.2.4.1 (vmchale)
13:39:36 <fweht> is there any way i can in the repl define two functions depending on each other?
13:39:53 <dsal> :{ is the easy way  :}
13:40:42 * hackage call-alloy 0.1.0.2 - A simple library to call Alloy given a specification  https://hackage.haskell.org/package/call-alloy-0.1.0.2 (marcellus)
13:43:28 <dsal> trollfactory: Is there anything in particular you need help with?
13:48:16 <merijn> fweht: I'd personally recommend just working in an editor and loading the file via ":l"
13:48:46 <fweht> merijn: yeah, thats what i also did, was just wondering... ty
13:52:44 <dsal> Yeah, that's a good point.   Editor is the actual easy way.   Whenever I start using :{ :}  I end up breaking something.
13:53:17 <trollfactory> i want to declare that haskell is not good for a newbie
13:54:27 <dsal> Do you have evidence to support this claim?
13:55:03 <trollfactory> yes because most of the newbies are not super mathematically oriented and or gifted
13:55:19 <trollfactory> and also functional code is much harder to read and understand for a newbie
13:55:56 <boj> well, i couldn't read Japanese until i studied it for awhile, so i suppose you are right
13:56:03 <MarcelineVQ> I remember being a newbie at non-functional code and it was awfully hard to read too
13:56:28 <dsal> Your first claim presupposes you need to be gifted or mathematically  oriented to be good at Haskell, which is not the case for at least me.
13:56:39 <fweht> it was a good thing that i learned from haskell (but couldve also learned from a different language) to always ask for the types of given objects
13:56:47 <dsal> The second  is just kind of odd.  I find many languages I'm unfamiliar with hard to read.  Haskell is pretty easy to read.
13:56:56 <trollfactory> yes but you are the exception and because you are here uh i mean because you are here it proves the exception
13:56:57 <fweht> not only in programming, also in the math context, it just help so much to first clarify things
13:57:02 <koz_> I have (n :: Nat) and (m :: Nat) in scope, and I want to use testEquality from Data.Type.Equality to compare them and see if they're :~:. How would I write this?
13:57:05 <trollfactory> a generic newbie would just run away
13:57:24 <merijn> Haskell is so far removed from math it's not even funny people keep thinking it's remotely related >.>
13:57:56 <dsal> trollfactory: You also seem to be here.
13:58:02 <lortabac> koz_: testEquality is meant to be used with singletons
13:58:18 <dsal> How have you been trying to learn?  If it's only by complaining about objects, there are much better ways.
13:58:18 <yushyin> merijn: we ... we have functions! so much math!
13:58:29 <trollfactory> yes but newbies are usually banned quickly because of toxic community
13:58:41 <boj> not this community
13:58:42 <MarcelineVQ> Banned from where?
13:58:46 <koz_> lortabac: As in, singletons-the-library singletons?
13:58:50 <dsal> [citation needed]
13:59:09 <lortabac> koz_: yes, but not necessarily that library
13:59:41 <merijn> I don't think I've *ever* seen anyone be banned from here, other than maybe porn spammers and racists
14:00:05 <koz_> lortabac: OK, thanks.
14:00:51 <dsal> trollfactory: But honestly, if you want to learn stuff, there are more constructive ways than, you know, trolling.
14:01:03 <trollfactory> ?
14:01:06 <lodi_g> Hello there, why this code outputs -5.34 and not -5.35? printf "%.2f\n" (-5.345::Float). How can I have a accurate round to two decimal places?
14:01:17 <trollfactory> i just learned about factory pattern
14:01:32 <EvanR> lodi_g: seems correctly rounded? according to "round to even" rule
14:01:50 <EvanR> round half to even
14:01:55 <EvanR> banker's rounding
14:01:55 <lodi_g> Well not according to my math classes though aha
14:02:08 <EvanR> perhaps it would be according to statistics class
14:02:12 <dsal> lodi_g: There are a bunch of ways to round numbers.
14:02:31 <lodi_g> Oh?
14:02:35 <dsal> lodi_g: If you want to be sad at your math classes: https://en.wikipedia.org/wiki/Rounding
14:02:35 <EvanR> you may be able to set the global floating point rounding mode
14:02:58 <EvanR> banker's rounding gets good reviews
14:04:02 <koz_> jle`: I'm a bit confused about https://hackage.haskell.org/package/typelits-witnesses-0.4.0.0/docs/GHC-TypeLits-Compare.html#v:cmpNat. I tried following the example at the top, but GHC complains about a lack of arguments to CEQ (expects 2, but got 1).
14:04:41 <koz_> Does it have to be CEQ Refl Refl or something?
14:05:01 <lodi_g> well didnt know about that 
14:05:06 <lodi_g> will have to learn a bit thank you
14:06:58 <trollfactory> burn all jews in oven
14:07:12 <trollfactory> sieg heil
14:07:18 <trollfactory> only muslims have a right to live
14:07:27 <merijn> @where ops
14:07:27 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw mniip monochrom quicksilver shachaf shapr ski
14:07:52 <MarcelineVQ> It's a lot more fun, for yourself and others, to troll subtley.
14:07:54 <boj> well then
14:08:01 <jle`> koz_: ah yeah, it looks like CEQ has more fields than the example shows
14:08:04 <EvanR> i hope that was freenode AI
14:08:11 <EvanR> that executed the k line
14:08:28 <koz_> jle`: I think a documentation update might be in order. :P
14:08:28 <sm[m]> bye bye troll
14:08:31 <dsal> Neat.  Took it a while to notice the design pattern reference, though.
14:08:37 <sm[m]> lodi_g: I asked a very similar question recently. I still can't quite answer yours.. :)
14:09:03 * koz_ is sorely tempted to make a doge meme about this.
14:09:17 <MarcelineVQ> Which this?
14:09:18 <sm[m]> maybe printf documents how it rounds somewhere
14:09:43 <merijn> The real answer is that you can't even be sure what printf sees in the first place
14:09:44 <sm[m]> or y'all will point out my dopiness again :)
14:09:48 <jle`> koz_: indeed :) or maybe i should just figure out a way to move to doctests and make sure my examples compile lol
14:10:09 <merijn> Because if the number you write isn't exactly representible then printf might get an already rounded value
14:10:29 <koz_> jle`: https://i.imgur.com/URHxFty.jpg
14:11:02 <jle`> too much equal to handle D:
14:13:23 <koz_> inb4 something needs _three_ Refls.
14:13:39 <koz_> 'All hail the Thrice-Refl!'
14:13:56 * EvanR waits to see if koz_ gets klined
14:14:00 <MarcelineVQ> and we shall name it cong3
14:14:07 <koz_> EvanR: klined?
14:14:22 <EvanR> if you squint sounds like a warped nazi salute
14:14:47 <sm[m]> https://stackoverflow.com/questions/58239327/round-a-float-to-a-specific-decimal also helps: "there is no number 5.545 in the type" (or 5.345 either, presumably). What's the mechanism by which ghci> 5.345 outputs exactly "5.345" then ?
14:15:38 <EvanR> so floating point numbers have an exact finite decimal expansion
14:15:46 <EvanR> but it's usually really big and unwieldy
14:15:54 <EvanR> theres a lambdabot incantation to show it
14:16:32 <EvanR> our conventional floating point libs display a different decimal number instead, one that is shorter but unambiguous wrt the real value
14:16:48 <c_wraith> show picks the shortest output that round trips back to the same bit pattern with read, iirc
14:17:25 <EvanR> it seems show and read correspond with every other languages usual behavior
14:17:57 <merijn> The real answer is that if you want deterministic output from float/double you should use hexfloats
14:18:12 <EvanR> that definitely saves space relative to decimal
14:18:28 <merijn> > showHFloat 5.297826856 ""
14:18:30 <EvanR> but fortran people assure me you should just use a 32 or 64 bit number :)
14:18:31 <lambdabot>  "0x1.530f985f98fep2"
14:18:47 <lavalike> fancy
14:19:08 <merijn> That's guaranteed to parse back into the exact same bit representation
14:19:23 <merijn> Well...once the read function for hexfloats gets merged into base anyway
14:19:41 <EvanR> is it guaranteed not to hard freeze PHP when parsed?
14:19:45 <merijn> Turns out that while we have -XHexFloats and a way to print them, no one thought to implement a parser :p
14:20:46 <glguy> merijn: You can use mine ^_^ https://github.com/glguy/config-value/blob/master/src/Config/NumberParser.y#L46-L47
14:22:08 <sm[m]> lodi_g: so I think a simple answer is when you type printf "%.2f\n" (-5.345::Float), the computer sees something more like printf "%.2f\n" (5.5449999999999999289457264239899814128875732421875::Float)
14:22:34 <EvanR> oh hell yeah. 5.5449999999999999289457264239899814128875732421875  loving it
14:22:38 <sm[m]> I mean, when you type printf "%.2f\n" (5.545::Float)
14:22:54 <EvanR> "you want base ten... i'll GIVE you base ten"
14:22:59 <sm[m]> why can't we just write what we mean, eh
14:23:38 <EvanR> and this is why financials should not use floats
14:24:05 <c_wraith> put the blame in the right place - programming languages treating floating point as the only way you can have fractional values.
14:24:33 <dsal> > (-5.345::Scientific)
14:24:35 <lambdabot>  error:
14:24:35 <lambdabot>      Not in scope: type constructor or class ‘Scientific’
14:24:58 <EvanR> most programming language designers think they know performance better than eventual users
14:24:58 <glguy> c_wraith: Are you imagining rational literals? 22/7 as literal syntax?
14:25:27 <EvanR> decimals would also be cool
14:25:31 <Peter64> hi
14:25:58 <jedai> EvanR: There's a IEEE spec for decimals too !! :)
14:25:58 <sm[m]> more on this topic: interesting recent HN discussion of what calculators do,   https://news.ycombinator.com/item?id=21330341
14:26:00 <dsal> @let π = 22%7
14:26:01 <lambdabot>  Defined.
14:26:21 <EvanR> jedai: good point. And how do we access those
14:26:34 <c_wraith> glguy: no, I mean having types other than float and double get the same nice syntax as anything else. Haskell does that. very few, if any, other languages do. (even Haskell still is biased towards Double via defaulting)
14:26:49 <jedai> EvanR: We don't ?
14:26:54 <EvanR> :(
14:29:04 <jedai> EvanR: there seems do be some packages for that
14:29:15 <jedai> @where decimal-arithmetic
14:29:16 <lambdabot> I know nothing about decimal-arithmetic.
14:29:28 <jedai> http://hackage.haskell.org/package/decimal-arithmetic-0.5.1.0/docs/Numeric-Decimal.html
14:30:56 <EvanR> this is funny, someone mentioned Decimal today but it didn't really support real operations
14:31:09 <EvanR> this one has Floating instance
14:31:32 <EvanR> we have so many options it's ridiculous
14:33:35 <jedai> This package seems pretty good with support for IEEE 754-2008 floating point decimals and arbitrary precision, most numeric classes and specific packages for some operations support. I don't know how it performs though
14:34:16 <EvanR> do CPUs have hardware for ieee decimals?
14:34:31 <EvanR> (that no one ever uses)
14:34:35 <dsal> Nobody knows.
14:35:09 <koz_> Maybe someone at Intel, AMD or ARM might?
14:35:27 <mycroftiv> anyone ever looked at unum representation? has an interesting pedigree
14:39:09 <merijn> EvanR: None of the common CPUs do, afaik
14:39:23 <Athas> I'd look at mainframe CPUs for that.
14:39:33 <Athas> But they might instead support some weird non-IEEE decimal format.
14:39:39 <jedai> Yep, same from my rapid investigation (IBP Power do, I think ?)
14:39:45 <jedai> IBM
14:40:37 <jedai> Though Intel at least have an official library that should support all IEEE 754-2008 on x86 and x86-64
14:41:30 <jedai> But only for binary.... :/
14:45:52 <sizur> Is there a comparison of type systems like Haskell's to Lattice-based like Cuelang?
14:47:06 <jedai> Intel also has https://software.intel.com/en-us/articles/intel-decimal-floating-point-math-library though the status seems a bit less obvious
15:04:02 <sizur> Could you recommend a better channel to ask this question?
15:05:12 * hackage github-rest 1.0.1 - Query the GitHub REST API programmatically  https://hackage.haskell.org/package/github-rest-1.0.1 (leapyear)
15:17:07 <dmwit> sizur: You might post to /r/types, perhaps. FWIW from the moderation side of things: I consider your question perfectly on-topic here (though I think that's not what you're asking with your last message).
15:18:26 <dmwit> The documentation for (<**>) seems very misleading to me. "A variant of (<*>) with the arguments reversed." But it's not `flip (<*>)`; it also swaps the effect order.
15:19:17 <jle`> it is super misleading
15:24:18 <pikajude> :t (<**>)
15:24:19 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
15:24:29 <pikajude> :t (<*>)
15:24:30 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
15:24:39 <pikajude> uhh, it certainly is flip (<*>)
15:24:57 <[exa]> there may be extra Backwards hidden
15:25:17 <pikajude> `flip`ping a function that operates over two Applicative swaps the effect order anyway
15:25:20 <pikajude> isn't that the point?
15:25:58 <[exa]> sizur: are you sure the two systems are comparable?
15:27:53 <lavalike> @src (<**>)
15:27:53 <lambdabot> (<**>) = liftA2 (flip ($))
15:28:18 <sizur> I am not sure.  But both constrain values, so not sure why they might not be.
15:28:21 <[exa]> sizur: anyway the lattice thing (and finding meets/cuts is quite a bit of subtyping, which haskell avoids
15:28:39 <[exa]> types are not constraints!
15:29:10 <sizur> Right, that's the graph unification/anti-unification part of cuelang.
15:29:34 <[exa]> oh well in cuelang the types in fact _are_ constraints as I see
15:29:43 <sizur> and values
15:30:05 <[exa]> hm.
15:30:59 <dmwit> pikajude: No. `flip (<*>) x f` does `f`'s effects first, then `x`'s. `(<**>) x f` does `x`'s effects first, then `f`'s.
15:31:05 <sizur> and i think Haskell's types aren't constraints view depends on perspective.  From immediate perspective, that's valid, but couldn't one consider universe of all values and then types can be viewd as constraints>
15:32:01 <[exa]> haskell types are basically a formal system of materializable statements (like logic) that can be used to prove stuff about the program (among other, they can be used to constrain the program to work on a computer)
15:32:18 <sizur> just like predicates can be viewed as constraints defining a relation?
15:32:33 <[exa]> there are better uses, mostly for guiding the polymorphism and various forms of generics
15:34:29 <[exa]> the thing is kindof directed from the other side, haskell programs are "generating" the true statements about themselves by inference; basically serving as proofs for statements in a theory
15:35:12 <[exa]> that's the methodological difference; do not constrain, rather see if you can generate something that matches the expectation
15:36:10 <dmwit> pikajude: "`flip`ping a function that operates over two Applicative swaps the effect order anyway" is not correct. But you may be thinking of `pure f <*> x <*> y` vs `pure (flip f) <*> y <*> x`; it is true that the effects happen in a different order in the latter, but that's not because of `f` vs `flip f`, it's because of `<*> x <*> y` vs `<*> y <*> x`.
15:36:28 <[exa]> sizur: technical difference is that haskell typesystem avoids using constraint solver as much as it can, going with simple unification and a few other tricks for as much code as possible
15:37:22 <sizur> Seems similar to unification in general, so don't yet see why the two can't be compared.  Cue doesn't use constraint solvers, it uses graph unification.
15:40:23 <nshepperd2> haskell types classify values, but constraints constrain types
15:40:48 <[exa]> "greatest lower bound" used in cuelang doesn't seem to be equality-preserving btw
15:41:34 <[exa]> (and certainly not invertible)
15:41:34 <sizur> in values lattice, types, constraints, and values are all just nodes in a graph with no distinctions (except top and buttom values)
15:43:36 <sizur> bottom* (sorry)
15:43:59 <[exa]> also, "types are values" is nice but has serious consequences if taken seriously
15:44:38 <sizur> Awesome, thank you!  Could you point me to these serious consequences?
15:45:07 <[exa]> mostly, type inference becomes undecidable very quickly
15:45:33 <[exa]> unless there is some well-positioned constraint on actual values present in types
15:45:49 <[exa]> btw cue uses static types?
15:46:23 <[exa]> btw did you see Dhall ?
15:46:52 <[exa]> I just realized it's a config language
15:47:30 <sizur> If unification produces bottom, you get error with offending expression, so that's the same as a static typing check (seems to me)
15:47:42 <dmwit> "types are values" is probably a lot safer in languages where function types do not exist.
15:48:05 <[exa]> yeah, I thought it has functions
15:48:18 <dmwit> It may have functions. But they are not values.
15:48:28 <dmwit> At least from the quick reading I've done in the last ten seconds. =P
15:49:09 <sizur> Yeah, I thought about it, but wouldn't be as simple as defining partial order between function types?
15:49:33 <sizur> i.e. exactly what variance gives
15:49:40 <[exa]> sizur: its complexity explodes very quickly
15:50:50 <sizur> implying unification of a complex system would become infeasible?
15:51:35 <dmwit> I don't know what *you* means by "complex system". But the short answer is that there's an awful lot of very innocuous-seeming features that you could add to Haskell's type system, each of which makes unification undecidable.
15:51:35 <[exa]> there is this kind of "partial ordering" in haskell, specializations of functions are less generic than their principial types, but I did not see it expressed as a lattice
15:51:56 <dmwit> So yes: feasible unification is a very fragile beast.
15:52:16 <[exa]> like, the hindley-milner-style inference works just right, why break it
15:52:47 <[exa]> also the subtyping is kinda complicated when used in polymorphic environments if you want _static_ types
15:52:57 <merijn> I'll take RankNTypes over the ability to infer everything anyday
15:56:16 <sizur> I think inference is less of a requirement with lattice, since constraints are so easy to express.  But since Cue doesn't have built-in exponentiation type (function type) I very well might be wrong here.
15:56:53 <[exa]> sizur: the closest thing I recall from haskell world is Dhall, they might have something interesting
15:57:07 <[exa]> other than that, haskell types are mostly about handling functions
16:04:27 <sizur> Thanks for Dhall pointer.  I'm interested in how Cue's theory can be related with "our stuff".  Does it make sense to explore what they have for our non-function types (and keep what we have for function types), since it would give us data-dependece (in addition to function-dependence we have with `-*`)?
16:05:15 <sizur> Or i'm just spewing ingorant nonsense?
16:06:03 <guhh> yes
16:10:10 <merijn> How do I search GHC's gitlab for issues I commented on?
16:12:27 <merijn> glguy: Oh, if you wrote an implementation, maybe you can help review: https://gitlab.haskell.org/ghc/ghc/merge_requests/268/pipelines
16:13:20 <hololeap> i'm getting an error deriving an instance of Eq, when i use the same constraints and everything to derive Show successfully for a GADT
16:13:28 <hololeap> https://gist.github.com/hololeap/d984425bec806e805a51694552b8f753
16:13:56 <hololeap> i feel like i'm confusing the compiler, but i could use some more insight into what it needs
16:21:39 <lyxia> hololeap: in the (:!) case there is no guarantee that the fs on both sides are the same
16:29:09 <hololeap> lyxia: how do you mean? it seems like it would be guaranteed by how i made the type
16:31:19 <hololeap> is it the fact that i apply ToList?
16:32:22 <hololeap> would it be possible to prove to the compiler that ToList preserves the information of fs?
16:50:10 <merijn> hololeap: Possible? Almost certainly. Will it makes you happy? Almost certainly not :o
17:08:27 <jle`> hololeap: i wouldn't use ToList there
17:08:53 <jle`> instead of PThese fs a, use PThese (g ':| gs) a
17:09:15 <jle`> hololeap: then you can write PThese (f ':| (g ': gs)) a
17:09:29 <jle`> hololeap: the difference is that now ghc can "work backwards" from (g ': gs)
17:10:13 <jle`> for example if you have a `PThese (A ':| (B ': '[C]))`, ghc can know that g ~ B, gs ~ '[C]
17:10:37 <jle`> hololeap: but i your original example, GHC wouldn't be able to do anything just knowing ToList fs ~ B ': '[C]
17:11:27 <jle`> i think it could be done if ToList was declared to be injective ... which it is.  but singletons's ToList is not declared as injective
17:12:07 <jle`> hololeap: so, using this explicit pattern instead of ToList might do the trick
17:12:20 <jle`> https://hackage.haskell.org/package/singletons-2.6/docs/Data-Singletons-Prelude-List-NonEmpty.html#t:ToList (not declared as injective)
17:12:58 <jle`> in general using type families in GADT constructor types is often going to result in headaches, so it's best to not do it unless absolutely necessary
17:21:39 <maralorn> I am trying to use https://github.com/haskell-CI/haskell-ci. The readme has a section Ideas for additional checks. Is that more a todo for the developers or a suggestion for me to enable?
17:24:44 <maralorn> I‘d really love to have a haddock coverage test in my ci.
17:48:10 <sm[m]> maralorn: just add --haddock --no-haddock-deps to your stack build command, or whatever
17:48:36 <sm[m]> like https://github.com/simonmichael/hledger/blob/master/.travis.yml#L143 . I found it a waste of time and carbon so don't bother
17:48:56 <sm[m]> remember it's going to do it on every. little. commit.
17:49:10 <sm[m]> and every. ghc. version. and. platform. you test
17:49:35 <maralorn> Hugh, sm is short for simonmichael.^^
17:49:54 <sm[m]> yes indeed
17:50:27 <maralorn> I like hledger.^^
17:50:40 <maralorn> Just made the connection.
17:50:45 <maralorn> Anyways, thx for the hint.
17:51:00 <sm[m]> thanks! me too
17:53:07 <maralorn> Actually: sm[m] Do you have a workflow/tooling for (semi-automatically) downloading transactions from online banking and then interactively ask the user how to save them to ledger?
17:53:29 <maralorn> I have a python tool for that and am thinking about a Haskell rewrite.
17:53:50 <sm[m]> and coincidentally, I think it might have been me who added coverage reporting to haddock. I thought it would do great things. I think it's too slow to be something people look at though.
17:54:29 <sm[m]> maralorn: I do, but it's in python also
17:54:59 <sm[m]> plaid2qif
17:56:22 <sm[m]> https://gist.github.com/simonmichael/3b32b660cc497a493da6b6ba04141b21 is a bank scraper that worked sometimes
17:59:06 <sm[m]> once you have the CSV downloaded, there are a bunch of options, I use hledger import. We could discuss that more in #hledger or #plaintextaccounting
18:00:40 <olligobber> Huh, I expected a -> a to be an instance of Monoid
18:01:07 <olligobber> oh, Endo a is
18:03:44 <sm[m]> maralorn: oh, and I have a haskell google sheet fetcher, from when I was using Tiller for bank data
18:11:09 <maralorn> sm[m]: I am mainly talking about the csv -> ledger step. I‘ll come over to #hledger when I have time to get more into this.
18:12:21 <sm[m]> sounds good
18:13:12 <olligobber> huh, I don't have System.Random...
18:15:33 <olligobber> I thought that would be installed by default
18:16:38 <guhh> i am so angry because i cant solve a mathematical problem
18:17:33 <olligobber> installing haskell-random from pacman didn't seem to fix it either
18:17:56 <olligobber> it was already installed
18:18:53 <olligobber> `There are files missing in the ‘random-1.1’ package'
18:19:52 <olligobber> ghci has no problems, just ghc
18:23:09 <MarcelineVQ> it's generally not a good idea to use pacman haskell packages and better to just have ghc (and ghc-static) and get packages by making a project with cabal or stack. the missing files thing is when there's dynamic packages being used as static or vica versa afaik. arch haskell packages are dynamic but most ghc workflows are static by default
18:23:37 <olligobber> oh, this issue again
18:23:59 <olligobber> I remember running into this when trying to submit my code to someone else's server
18:26:18 <olligobber> `-dynamic' should fix it
18:26:36 <olligobber> cool, thanks MarcelineVQ 
18:44:51 <maralorn> Am I supposed to run into problems if I name a file IO.hs?
18:50:59 <Cale> maralorn: shouldn't be an issue
18:58:23 <jle`> maralorn: some build processes will auto-detect capital names as modules
18:58:32 <jle`> (like hpack)
18:58:40 <maralorn> Hm
18:58:46 <jle`> so it might cause issues if your file is actually an executable
18:59:00 <maralorn> Something about ghcide is a bit brittle in my setup.
18:59:01 <jle`> or an application or file with main
18:59:16 <jle`> so for me i always name my executables with main :: IO () with lowercase letters
18:59:20 <jle`> as a module though it should be okay.
19:18:21 <maralorn> The travis-ci bot is not joining my channel. :-(
19:19:02 <maralorn> I just set the channel name via haskell-ci. Wondering what else I need to do.
19:39:10 <koz_> Under what constraints (if any) is f a -> g b Strong?
19:45:00 <koz_> f ~ Identity, Applicative g is my current best guess.
19:45:22 <koz_> Unless there's a way to do f (a, b) -> (f a, b)?
19:46:11 <koz_> I can go in the other direction if I have Applicative f, but I'm not sure I can go this way.
20:21:54 <MarcelineVQ> koz_: pretend f is IO and its a little clearer, IO (a,b) -> (IO a, b)  means b just escaped from IO
20:22:13 <koz_> MarcelineVQ: Yeah, I realize that full generality is probably impossible here. 
20:22:37 <koz_> Most general is probably something like (forall a . Coercible a (f a)).
20:22:37 <shachaf> ESCAPE FROM PLANET JUPITER
20:23:04 <koz_> Which basically translates 'f is a newtype wrapper'.
20:23:35 <koz_> (well, f has to be a Functor also, but who's counting?)
20:49:23 <olligobber> apparently grep has a character limit on expressions
20:51:31 <ammar2> sounds about right
20:51:36 <ammar2> why are you running into this limit?
20:54:22 <olligobber> I made a regex that matches all multiples of 7
20:54:27 <olligobber> it is >10,000 characters
20:55:42 * koz_ mumbles something about hammers and nails.
20:56:29 <olligobber> hey, I didn't write the expression by hand, I wrote a haskell program to generate it
21:02:20 <olligobber> code is now online: https://github.com/olligobber/DivisibilityRegex
21:13:12 * hackage morpheus-graphql 0.6.0 - Morpheus GraphQL  https://hackage.haskell.org/package/morpheus-graphql-0.6.0 (nalchevanidze)
21:58:35 <sarahzrf> well that's easy, /(SSSSSS)*Z/
21:58:37 <sarahzrf> :}
21:58:52 <sarahzrf> sorry i mean /(SSSSSSS)*Z/
22:00:27 <monochrom> err what's that?
22:00:46 <sarahzrf> matches any multiple of 7, i dont know what olligobber is wasting so many characters on ;)
22:01:54 <olligobber> sarahzrf, I'm working in base 10
22:02:02 <sarahzrf> yeah, just teasing
22:02:37 <sarahzrf> https://i.stack.imgur.com/ldNco.png
22:02:52 <olligobber> sarahzrf, /(0|(10((0|11)(1|00))*((0|11)01|10)|11)(01*(01(1|00)((0|11)(1|00))*((0|11)01|10)|0101|00))*1)*/ for base 2
22:03:12 <olligobber> I mean base A, sorry
22:03:15 <jle`> does it grow exponentially for bases
22:03:36 <olligobber> no idea
22:03:51 <monochrom> [0-9]*0 matches n in base n, for all n between two and ten.
22:04:14 <sarahzrf> base A?
22:04:17 <monochrom> "I use base 10."
22:04:23 <olligobber> A, the number after 9
22:04:29 <sarahzrf> haha
22:05:08 <olligobber> monochrom, for some reason my code's best solution for multiples of 2 in base 2 is (0|11*0)*
22:05:10 <monochrom> http://cowbirdsinlove.com/43
22:06:09 <sarahzrf> monochrom: thanks for sourcing my image
22:06:10 <monochrom> Why do you hate 1010?
22:06:12 <jle`> wouldn't it be 0$
22:06:29 <sarahzrf> jle`: that's not a regex
22:06:35 <jle`> :O
22:06:45 <olligobber> monochrom, 1010 matches, it is two copies of 10, which matches 11*0
22:06:57 <monochrom> Oh, I misread.
22:07:43 <olligobber> it seems in general my code's answer for multiples of n base n is (0|..*0)*, where . is replaced with [0-(n-1)]
22:08:20 <jle`> so (0|99*0)* for decimal, neat
22:08:44 <olligobber> no, (0|[0-9][0-9]*0)*
22:08:49 <jle`> ah
22:09:12 <jle`> that's different than the binary case is it not?
22:09:19 <olligobber> oh
22:09:22 <olligobber> [1-9] I mean
22:37:12 * hackage haskell-src-meta 0.8.4 - Parse source to template-haskell abstract syntax.  https://hackage.haskell.org/package/haskell-src-meta-0.8.4 (DanBurton)
23:27:12 * hackage morpheus-graphql 0.6.1 - Morpheus GraphQL  https://hackage.haskell.org/package/morpheus-graphql-0.6.1 (nalchevanidze)
23:39:12 * hackage morpheus-graphql 0.6.2 - Morpheus GraphQL  https://hackage.haskell.org/package/morpheus-graphql-0.6.2 (nalchevanidze)
