00:00:42 <dminuoso_> evocatus: Without seeing the code, I cant say. Im just giving you the necessary preconditions for sharing to occur: It has to be named and it has to have a monomorphic type (note that `g` in something like `f :: forall a. ...; f = ... where g :: a` is to be considered monomorphic)
00:00:58 <dminuoso_> (Assuming ScopedTypeVariables enabled of course)
00:03:02 <[exa]> kenran: (btw can you try that you are able to link any .o with -lz ? )
00:03:58 <kenran> [exa]: I just checked, I only find logs with the same verbosity as the build output. I think I'll try making a new cabal project with only one of the failing dependencies and find out how to increase the verbosity level.
00:04:33 <kenran> [exa]: Phew, I can surely try. I'm not good at that :) Can I just try to link with -lz (or -liconv) even when I'm not using it in code?
00:05:54 <dminuoso_> evocatus: Actually that was phrased wrongly. These are necessary for guaranteed sharing, not any sharing. GHC might on its own do sharing if has a good opportunity. :)
00:06:05 <[exa]> yeah, make a simple .c file with main and use cc -lz main.c
00:11:32 <kenran> [exa]: yeah, I make a hello_world-style c-thingy and just added the -lz part. It does not work.
00:11:46 <kenran> That's something I can figure out (at least figure out elsewhere :)). Thanks!
00:12:33 <jle`> int-e: (runIdentity .) . runReaderT = runReader☻
00:14:08 <int-e> jle`: ah of course
00:15:19 <int-e> jle`: I first had to realize that an actual pattern will not work though... so I got distracted from the basics.
00:15:34 <int-e> So... stupidity ensued ;)
00:15:57 <[exa]> kenran: what's the error message?
00:40:42 * hackage tmp-postgres 1.2.1.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.2.1.0 (JonathanFischoff)
00:49:54 <kenran> [exa]: Sorry, I was AFK a bit. The error message was verbatim the same (ld: library not found for -liconv). I checked what `gcc` was and saw that it came from my nix environment. Using the system gcc/clang fixed the problem.
01:05:30 <kenran> If I want to convert an old cabal project to have nix-integration, but simply using `cabal2nix` to generate a nix expression leads to missing dependencies (because of version constraints): what do I do now? Should I go back in time manually by either using older stable nix channels or pinning nixpkgs to older versions, or is there a way to find out "where in time" it could work?
01:05:48 <kenran> (Let me know if this is better asked in #nixos or somewhere else as I'm not quite sure)
01:23:08 <__monty__> kenran: Sounds like a hard problem. I assume you're stuck with the bounds you have? I'd check which stackage-lts is likely compatible then try a nixpkgs from back then.
01:24:29 <dminuoso> kenran: Is fixing the things causing tight bounds an option?
01:25:00 <olligobber> someone just told me they avoid category theory because they feel functional programming and category theory are like a cult
01:26:44 <dminuoso> olligobber: Well, realistically category theory is not necessary.
01:26:55 <dminuoso> That is, you can become an expert Haskeller without a grain of category theory.
01:26:56 * olligobber hisses
01:27:30 <olligobber> blaspheme!
01:27:37 <dminuoso> In fact, the vast majority of Haskell is not even built ontop of category theory. The connections were made mostly after the fact.
01:29:24 <olligobber> in all seriousness, I actually used Haskell as a source of examples for learning category theory
01:29:42 <olligobber> and as some motivation
01:29:54 <dminuoso> olligobber: As a concrete example, Hask is not even a proper cartesian closed category. And there's not even a formal specification of "Hask".
01:30:16 <dminuoso> There's no actual published paper describing what this "Hask" is, that people sometimes talk about. 
01:30:37 <kuribas> merijn: I am not convinced that "first" is more friendly than "_1".  It is very polymorphic.
01:30:38 <olligobber> yeah, I usually adapted the examples from Hask and applied them to Set instead
01:30:59 <kuribas> merijn: and "_1" has a clearly defined meaning.
01:31:41 <dminuoso> olligobber: I you want to learn category theory, it's a really interesting subject - but the overall value/impact on programming is relatively small. 
01:31:53 <olligobber> yeah
01:32:06 <kuribas> category theory for programmers is nice
01:32:18 <kuribas> it allows you see patterns that you may never have seen before
01:32:32 <kuribas> and appreciate the power of algebraic datatypes
01:32:34 <dminuoso> olligobber: An hour of algebra will have much more impact on your programming than a week of category theory though.
01:32:54 <kuribas> dminuoso: true, but most people already know algebra, no?
01:32:57 <dminuoso> I just made these numbers.
01:33:06 <dminuoso> kuribas: Judging from the many discussions in here, I dont think so.
01:33:13 <dminuoso> They might have some rudimentary algebra knowledge from school.
01:33:40 <kuribas> dminuoso: ah, you mean abstract algebra
01:33:46 <kuribas> like groups, rings, etc...
01:33:49 <dminuoso> Yeah.
01:35:12 <kenran> __monty__: Thanks, I can try that as I can see that the transitive HSpec dependency seems to be the main problem.
01:36:15 <kenran> dminuoso: It might just be. The version are quite tightly bound as-is in the cabal file already. I could try loosening them up and seeing what happens. I just have no idea what the best way to go about it would be.
01:37:30 <merijn> kenran: I just pick the looses bound as applicable by the PVP and then check the changelog each A.B version bump to see if I can loosen it further
01:39:50 <dminuoso> kuribas: Or perhaps even formal logic or type theory. There's quite a few fields that have valuable low hanging fruits.
01:40:10 <dminuoso> kuribas: I personally found that category theory is not one of them. 
01:44:48 <merijn> I would say category theory is probably the *least* useful thing to study when it comes to getting better at writing Haskell, at least I find it very hard to think of things that are less directly beneficial (except, you know, entirely different things like "learning fly fishing", and even then I'm not sure :p)
01:46:02 <dminuoso> That being said, points have been repeatedly made that its definitely not useless. It's just that it requires some good amounts of CT experience to draw benefits from it.
01:46:04 <tsahyt> yea, fly fishing is a rather lazy activity. that's gotta teach you something.
01:49:49 <jgt> kenran: you can use overrides/overlays to specify the version of the package you want
01:50:54 <jgt> kenran: I use something like this in my projects: http://ix.io/213X#
01:51:07 <jgt> there's apparently a better way with haskell.nix, but I haven't tried it yet
02:09:13 <chreekat_> jgt: kenran: yeah, you can use a cabal-built plan with haskell.nix, rather than rely on the static package set provided in nixpkgs. Otherwise, you can do what you would do with stack, which is provide a bunch of additions or overrides of the package set
02:10:22 <__dingbat__> I have a function that is returning type -- ConduitT () Something m ()  , how do I extract Something from it to print etc.?
02:11:18 <kenran> Thanks everyone! I was thinking of trying out haskell.nix, but last time I checked it was building for ages and I couldn't do anything while that lasted. I'll have to do that again over night.
02:12:11 <jgt> chreekat_: thanks for your work on Snowdift :) Having some Yesod stuff public on GitHub was an excellent resource for me while learning.
02:12:13 <chreekat_> As I just discovered, there *is* a #haskell.nix, fwiw
02:12:28 <chreekat_> jgt: haha great :)
02:12:43 <chreekat_> (there's also a #snowdrift, naturally)
02:12:51 <jgt> chreekat_: we may have bumped into each other briefly in Brno too :)
02:13:00 <kenran> Using git bisect with manual grepping I found a version that fits. Now I just have another problem, namely a runtime dependency is not found. I have to read up on how to add that to my cabal2nix-generated default.nix file.
02:14:03 <chreekat_> cool :)
02:14:10 <jgt> kenran: here's how the Riskbook default.nix currently looks http://ix.io/2144
02:14:24 <jgt> it uses a pkgconfig.nix like the one I posted earlier
02:16:59 <__dingbat__> Anyone can help me with my ealier question please?
02:17:40 <kenran> Thank you jgt ! I just asked in #nixos as well because any missing runtime dependency of a package is probably a bug in that package's derivation.
02:18:31 <jgt> kenran: you can override those derivations on-the-fly yourself; it's just a case of writing all that override code
02:19:04 <jgt> all the power is there, but there's no big "fix all the things" button
02:19:39 <kenran> Overriding in this case means "adding in the runtime dependency" tehn?
02:21:36 <jgt> I guess. I don't know the specific of the package that isn't working for you
02:22:11 <kenran> Ah of course, sorry. It's about `odbc`, which needs `freetds`.
02:22:23 <kenran> nix + Haskell is a lot to take in... thanks for sticking with me.
02:25:57 <jgt> kenran: btw, I don't bake runtime dependencies into the default.nix
02:26:13 <jgt> I include them in my shell.nix, so I have them available locally
02:26:27 <jgt> and for deploying with NixOps, I include them in my services.nix
02:27:11 <jgt> kenran: here's how my shell.nix looks http://ix.io/214d
02:27:49 <jgt> the distinction between the global and pinned nixpkgs versions is not important; I should probably actually remove the global version
02:33:07 <kuribas> merijn: ah, bifunctor first is easier than arrow first
02:46:20 <kenran> jgt: very interesting, I'll have a deeper look into how those files work together this afternoon! I just found out I mistakenly thought a runtime dependency was the problem earlier. It's actually happening earlier, as the odbc package is missing a header file during build. But that's a problem for later on.
03:03:12 * hackage breve 0.5.0.0 - a url shortener  https://hackage.haskell.org/package/breve-0.5.0.0 (rnhmjoj)
03:33:26 <merijn> kuribas: You seem to be having several days of conversation lag ;)
03:37:48 <LCRERGO> Hi, I'm seeing a pattern newtype Product a = Product { getProduct :: a }
03:37:53 <LCRERGO> all the time
03:38:00 <fendor> is it sensible to use ghci interactively for remote code execution as a service? E.g. start ghci process, obtain stdout, stdin handles, pipe single line into it and read the output line - by - line (which is definitely wrong)? 
03:38:02 <LCRERGO> what getProduct means?
03:38:23 <boxscape> any idea why the initial value argument for foldr in the ghc sources is called "z"? Only thing I can think of is that it's the rightmost (so "last) element if you look at foldr as doing (a + (b + ... + z)...), but maybe there's a better reason
03:38:28 <dminuoso> LCRERGO: This is standard record field syntax.
03:38:54 <LCRERGO> @diminuoso, but is it kind of a function?
03:38:54 <lambdabot> Unknown command, try @list
03:38:57 <dminuoso> LCRERGO: This style will generate a function `getProduct :: Product a -> a` as well as a function that doubles as a data constructor `Product :: a -> Product a`
03:39:24 <dminuoso> lambdabot: It's equivalent to writing `newtype Product a = Product a; getProduct :: Product a -> a; getProduct (Product a) = a`
03:39:27 <dminuoso> LCRERGO: ^-
03:40:04 <LCRERGO> hm... kind of a syntax sugar so
03:40:09 <LCRERGO> thanks
03:40:20 <dminuoso> LCRERGO: Strictly speaking its more, if we are being super precise.
03:40:38 <dminuoso> LCRERGO: There's some extra bits that are not available if you type that out by hand. But I think its more important to gloss over that and consider it syntax sugar for now.
03:40:39 <LCRERGO> like...
03:40:41 <Axman6> it can also be used to 'update' a product
03:40:55 <dminuoso> % let x = Product 5 in x{getProduct = 10}
03:40:55 <yahb> dminuoso: Product {getProduct = 10}
03:41:09 <Axman6> let x = Product 7 in x{ getProduct = 8 }
03:41:31 <dminuoso> LCRERGO: ^- this would not work if you manually specified getProduct. But it's really a small detail that we can safely ignore for the purpose of understanding `newtype Product a = Product { getProduct :: a }`
03:42:17 <LCRERGO> ok, I understood
03:43:00 <dminuoso> LCRERGO: The reason for Product existing by the way, is the fact that a given type can have only a single instance for a typeclass.
03:44:09 <dminuoso> LCRERGO: Now there's multiple implementation choices for `instance Semigroup Integer`. In order to have all available, we use newtypes (which, in our heads, we associate with some behavior in its typeclass instances)
03:55:23 <kuribas> if there is no productivity advantage to functional programming, then why am I running into problems in java that I don't run into in haskell?
03:55:29 <kuribas> (negative array size)
03:56:24 <dminuoso> kuribas: negative array size has nothing to do with functional programming
03:56:56 <kuribas> dminuoso: well, it shows that looping over arrays with indices is harder than using lists
03:57:56 <merijn> fendor: Define "sensible" :p
04:06:54 <kuribas> dminuoso: and looping over lists is quite inconventient in java
04:07:16 <dminuoso> 12:55:07         kuribas | (negative array size)
04:07:18 <dminuoso> % :t length
04:07:18 <yahb> dminuoso: Foldable t => t a -> Int
04:07:33 <dminuoso> % minBound @Int
04:07:33 <yahb> dminuoso: -9223372036854775808
04:07:37 <dminuoso> kuribas: ^- check that out.
04:08:16 <kuribas> dminuoso: you showed the minimum value of Int?
04:08:18 <merijn> dminuoso: So? length can't sensibly return that
04:08:25 <dminuoso> Okay
04:08:27 <dminuoso> % :t (!!)
04:08:28 <yahb> dminuoso: [a] -> Int -> a
04:08:40 <dminuoso> There's a lot of Int in base that, in an ideal world, should be Nat rather.
04:08:52 <dminuoso> 13:07:56          merijn | dminuoso: So? length can't sensibly return that
04:08:56 <dminuoso> merijn: Thats sort of my point.
04:09:24 <kuribas> dminuoso: or Word?
04:09:33 <kuribas> % minBound @Word
04:09:34 <yahb> kuribas: 0
04:09:45 <dminuoso> kuribas: Sure
04:18:52 * Axman6 starts writing the IWP: The Int to Word proposal
04:20:13 <Taneb> Axman6: I think we should rename Natural to "Wordeger" for consistency
04:21:09 <dminuoso> Taneb: Not bad. The IWP has lasted only 90 seconds, and the name bikeshedding has started.
04:21:50 <Taneb> dminuoso: Haskell is a very efficient language
04:21:54 <tabaqui1> :i Data.IntMap.Strict.Key
04:21:57 <tabaqui1> % :i Data.IntMap.Strict.Key
04:21:58 <yahb> tabaqui1: type IM.Key = Int -- Defined in `Data.IntSet.Internal'
04:23:23 <tabaqui1> % genericLength
04:23:23 <yahb> tabaqui1: ; <interactive>:163:1: error:; * No instance for (Show ([a0] -> Integer)) arising from a use of `print'; (maybe you haven't applied a function to enough arguments?); * In a stmt of an interactive GHCi command: print it
04:23:31 <tabaqui1> % :i genericLength
04:23:31 <yahb> tabaqui1: genericLength :: Num i => [a] -> i -- Defined in `base-4.12.0.0:Data.OldList'
04:24:09 <tabaqui1> I think that Int's is a nice choice as "universal numeric type", but many functions from Prelude use the wrong type for indexing
04:24:25 <tabaqui1> btw, Words are not a ring
04:25:57 <[itchyjunk]> I hears there are no loops or some such?
04:26:00 <[itchyjunk]> or i misread?
04:26:24 <tabaqui1> [itchyjunk]: do you mean smth like "for i in [1..10]; do smth"?
04:26:39 <ion> Silly mathematicians inventing their own words for well-known concepts such as a Word.
04:26:58 <tabaqui1> there are no "while", "for", "until" loops, that's right
04:27:04 <[itchyjunk]> tabaqui1, i thought i read there are not "while" loops or some such
04:27:06 <[itchyjunk]> ah okay
04:27:19 <dminuoso> [itchyjunk]: We dont have loops built into the language as primitives. 
04:27:22 <tabaqui1> "while True" does exist though
04:27:36 <[itchyjunk]> hmmm
04:27:38 <dminuoso> [itchyjunk]: We can model loops with recursion however.
04:27:54 <Taneb> ion: so inconsiderate
04:27:55 <[itchyjunk]> could you give me an example? ":x
04:28:35 <dminuoso> [itchyjunk]: `sum ls = go 0 ls where go n (x:xs) = go (n + 1) xs; go n [] = n`
04:28:35 <tabaqui1> fact n = fix (\go x k -> if k == 1 then x else go (x * k) (k - 1))
04:28:44 <dminuoso> [itchyjunk]: Here `go` implements a loop with a counter.
04:29:02 <Axman6> ion: it's very unnatural
04:29:04 <tabaqui1> we use "go" function with counters to achieve tail recursion here
04:29:22 <tabaqui1> because compiler can optimize it and prevent memory leaks
04:29:30 <Axman6> @src forever 
04:29:30 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
04:30:42 <[itchyjunk]> hmm
04:31:13 <dminuoso> [itchyjunk]: There's a major reason for this: values in Haskell are immutable.
04:31:20 <dminuoso> [itchyjunk]: And furthermore, evaluation order is not specified.
04:32:01 <dminuoso> Haskell fundamental has no notion of "first this, then that" that would allow for a "loop/while/for" keyword to make even sense. So instead we have imagine how to implement the core behavior using functions.
04:32:15 <dminuoso> % :t for
04:32:15 <yahb> dminuoso: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
04:32:17 <[itchyjunk]> well i know about the immutable part. not sure what the significance of order... ah
04:32:19 <[itchyjunk]> i see
04:32:40 <tabaqui1> dminuoso: err, Haskell for has no relation to imperative for-loop
04:32:42 <dminuoso> This is just a haskell function that, roughly, implements the behavior of effectful loops. :)
04:33:21 <Axman6> > last $ map (2^) [1..1000] -- this only evaluates 2^1000
04:33:23 <merijn> tabaqui1: Sure it does "for [1..10] $ \n -> do imperativeCodeHere"
04:33:23 <lambdabot>  1071508607186267320948425049060001810561404811705533607443750388370351051124...
04:33:45 <dminuoso> [itchyjunk]: So instead we can use recursion to implement "loops" and arguments to model stateful variables.
04:33:56 <[itchyjunk]> i see :s
04:34:03 <dminuoso> In fact
04:34:37 <Axman6> [itchyjunk]: what we have is much more powerful than loops
04:34:39 <dminuoso> [itchyjunk]: If you have looked at State/StateT, you will observe that the idea of a "stateful variable" is modelled by a function. :)
04:34:51 <dminuoso> [itchyjunk]: So we get to talk about these things as first-class values we can pass around.
04:34:53 <tabaqui1> merijn: well, at first we are bound to Applicative instance here, and anyway it is very rough relation
04:35:49 <tabaqui1> and we have no accumulation in for
04:35:58 <tabaqui1> (we can use foldM, I know)
04:37:08 <dminuoso> [itchyjunk]: This idea of expressing things using functions is very pervasive in Haskell. Rather than limiting, it gives us incredible expressive power. :)
04:37:24 <dminuoso> % foldr (+) 0 [1,2,3,4,5]
04:37:24 <yahb> dminuoso: 15
04:37:27 <dminuoso> % foldr (*) 0 [1,2,3,4,5]
04:37:27 <yahb> dminuoso: 0
04:37:30 <[itchyjunk]> i need to get used to it i suppose
04:37:44 <GeDaMo> "A tutorial on the universality and expressiveness of fold" http://www.cs.nott.ac.uk/~pszgmh/fold.pdf
04:37:46 <dminuoso> This is much more expressive than an effectful loop with a counter where you access each element, and then manipulate some counter
04:38:02 <[itchyjunk]> so am i supopsed to be compiling from gchi? as opposed to compiling with it and just running it like ./somefile? :s
04:38:24 <[itchyjunk]> i don't grasp why its more expressive yet :s
04:38:25 <dminuoso> [itchyjunk]: Whatever you prefer. For simple fast "try it out" I like running `! ghci %` from vim.
04:41:07 <dminuoso> [itchyjunk]: The major thing is compositionality. https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf this paper might be worth a read.
04:41:35 <fendor> merijn, sensible in the sense of, no one is tearing their hair out because of it
04:42:25 <merijn> fendor: I mean that involves giving arbitrary remote code execution access to whomever can reach said webservice, so...
04:42:38 <merijn> fendor: There are some teensie-weensie security details to think through
04:42:39 <fendor> merijn, yeah, security is not a concern :D 
04:43:26 <fendor> not my non-functional requirements, but it is ok to just throw away any security concerns.
04:43:33 <fendor> the machine is a lost cause anyways
04:43:46 <lortabac> [itchyjunk]: you can also try Haskell in IRC by sending private messages to lambdabot
04:43:47 <merijn> fendor: There's also mueval which lambdabot is based on
04:44:49 <Axman6> [itchyjunk]: definitely read the paper dminuoso linked
04:45:24 <[itchyjunk]> think the bot is ignoring me
04:45:27 <fendor> merijn, mueval is nice, but there is not interactive mode, right? Startup time is huge
04:45:28 <[itchyjunk]> Axman6, working on it :x
04:45:47 <Axman6> [itchyjunk]: /msg lambdabot > 1+1
04:45:51 <Axman6> the > is needed
04:47:06 <lortabac> fendor: there is also hint
04:47:31 <Axman6> [itchyjunk]: also /msg lambdabot @help will get you started on soe fo the things lambdabot can do
04:47:42 <fendor> lortabac, isnt that the code interpreter that mueval depends on?
04:48:09 <boxscape> is it more common to have multiple LANGUAGE pragmas or one with a comma separated list of extensions?
04:48:26 <merijn> boxscape: I prefer 1 per line
04:48:36 <boxscape> Seems like 1 lends itself better to small diffs
04:48:45 <fendor> boxscape, code style preference. I also prefer 1 per line
04:48:51 <boxscape> ok
04:48:53 <merijn> boxscape: And to staying within maximum line length ;)
04:48:57 <dminuoso> boxscape: 1-per-line is what haskell-mode gives me :p
04:49:07 <boxscape> (I meant 1 per line by 1 btw) 
04:49:15 <lortabac> fendor: you are right, mueval uses hint
04:49:42 <boxscape> merijn well, it's not like you can't split a list over multiple lines
04:49:54 <merijn> boxscape: You can, but it looks awkward
04:50:03 <boxscape> that's fair
04:52:12 <fendor> does hackage somehow look different?
04:52:16 <fendor> like, a tiny bit?
04:52:21 <merijn> fendor: Which package?
04:52:28 <fendor> hint
04:52:55 <merijn> "tiny bit" lol
04:53:12 <merijn> It looks completely different. Looks like new haddock CSS style
04:53:16 <dminuoso> yes.
04:53:21 <dminuoso> It's been live for quite some time.
04:53:39 <dminuoso> It only applies if the doc is compiled anew.
04:53:40 <fendor> so, probably my cache? 
04:53:43 <fendor> a
04:53:45 <fendor> ah
04:53:50 <merijn> dminuoso: I've only seen it on like 2 packages
04:54:04 <phadej> package docs applies only when docs are uploaded by users atm
04:54:14 <phadej> e.g. hint says "Docs uploaded by user"
04:54:37 <merijn> phadej: I always upload manually, doc builder is to slow for my inpatient ass :p
04:54:52 <dminuoso> Ahh wait
04:54:58 <dminuoso> Right. That's a new haddock builder
04:55:32 <merijn> I'm still waiting for a new Hackage deploy that fixes the super annoying outfocus on the search bar nonsense
04:55:34 <dminuoso> Err *haddock style. But apparently the hackage builders dont use it yet.
04:56:14 <phadej> merijn: is the patch merged?
04:56:32 <merijn> phadej: afaik it's been merged for ages, but there hasn't been a new deploy
04:57:15 <merijn> phadej: https://github.com/haskell/hackage-server/issues/807
04:57:27 <merijn> Merged in March
04:58:17 <phadej> surely it has been redeployed since march, i'll ask about
04:58:45 <phadej> at least I fixed bugs in depenendencies, I hope are deployed
04:59:30 <merijn> phadej: Well it's still doing the autofocus stealing thing for me no
04:59:57 <phadej> merijn: yes, I just thought that issue were in a "no one did anything" limbo
05:00:19 <phadej> it's especially annoying on mobile, I agree
05:00:41 <merijn> I hate it because I try to use hackage's new quickjump and end up typing the search bar
05:00:57 <phadej> that too
05:01:31 <merijn> Because quickjump is freaking amazing and I never wanna search packages from a package page (I just have an address bar search set up for Hackage :p)
05:03:38 <phadej> quickjump is amazing, I agree
05:03:44 <phadej> hidden gen
05:05:13 <fendor> quickjump's performance is sometimes abyssal
05:07:42 * hackage chronos 1.0.8 - A performant time library  https://hackage.haskell.org/package/chronos-1.0.8 (chessai)
05:07:49 <dmwit> ?tell maerwald (re: Selective doesn't say whether its method must short-circuit) I made the same complaint. You can read one of the author's replies about it here: https://www.reddit.com/r/haskell/comments/8u81bg/selective_applicative_functors/e1dlvn6/?context=3 (...but I didn't find the response super satisfying).
05:07:50 <lambdabot> Consider it noted.
05:09:04 <n0v4> i have learnt that the catamorphism of list is foldr. can foldl also be expressed as a catamorphism?
05:09:43 <Axman6> you can express foldl using foldr... but i'm not sure the question make sense beyond that
05:10:04 <Axman6> IIRC, there is only one catamorphism for a type
05:10:08 <Axman6> :t maybe
05:10:09 <lambdabot> b -> (a -> b) -> Maybe a -> b
05:10:10 <Axman6> :t either
05:10:11 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
05:10:14 <Axman6> :t bool
05:10:16 <lambdabot> a -> a -> Bool -> a
05:10:18 <Axman6> :t foldr
05:10:19 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
05:11:03 <Axman6> those are all examples of catamprphisms for Maybe, Either, Bool and list
05:11:57 <boxscape> > foldl (+) [a,b,c,d] -- wasn't there something like this that works?
05:11:58 <lambdabot>  error:
05:11:58 <lambdabot>      • Could not deduce (Num [Expr]) arising from a use of ‘+’
05:11:59 <lambdabot>        from the context: Foldable t
05:12:24 <boxscape> ah wait
05:12:25 <Axman6> > foldl (+) 0 [a,b,c,d] :: Expr
05:12:27 <lambdabot>  0 + a + b + c + d
05:12:31 <boxscape> right I'm just misusing foldl
05:12:33 <boxscape> thanks
05:13:21 <tabaqui1> @src Expr
05:13:21 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
05:13:38 <tabaqui1> lambdabot: why don't you go and love yourself?
05:13:41 <tabaqui1> % :i Expr
05:13:41 <yahb> tabaqui1: ; <interactive>:1:1: error: Not in scope: `Expr'
05:13:46 <tabaqui1> > :i Expr
05:13:48 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
05:13:49 <n0v4> i see. what i was really interested in was the catamorphism for trees. it `consumes` the tree from the bottom up (i.e. starting from the leaves). i was wondering if there is a corresponding process that consumes from the top down, starting from the root. i guessed that this would be related to foldl. sorry if im being pretty vague, the details are still a bit hazy for me
05:14:49 <boxscape> @hoogle Expr
05:14:49 <lambdabot> Test.Tasty.Patterns.Types data Expr
05:14:49 <lambdabot> module Text.Parsec.Expr
05:14:49 <lambdabot> module Text.ParserCombinators.Parsec.Expr
05:15:19 <tabaqui1> hmm
05:16:42 <tabaqui1> I guess, it is from simple-reflect
05:17:03 <tabaqui1> we can see "instance Num Expr" here at least
05:17:09 <boxscape> yeah looks like it
05:29:29 <maerwald> dmwit: very interesting
05:38:26 <machined1od> no, disabled swap, ran 3 IDEs, they ate memory
05:39:36 <Axman6> o.O
05:40:12 <ziman> > foldr (+) 0 [a,b,c,d] :: Expr
05:40:14 <lambdabot>  a + (b + (c + (d + 0)))
05:43:04 <boxscape> > sum [a,b,c,d]
05:43:06 <lambdabot>  0 + a + b + c + d
05:43:44 <fendor> @type a
05:43:45 <lambdabot> Expr
05:43:53 <fendor> @type aa
05:43:54 <lambdabot> error:
05:43:54 <lambdabot>     • Variable not in scope: aa
05:43:54 <lambdabot>     • Perhaps you meant one of these:
05:49:04 <evancz> Hello! I am getting some confusing results when compiling with `-split-objs` vs `-split-sections`. We are seeing our binary stay about the same size with `-split-objs` and get about 50% smaller with `-split-sections`
05:49:35 <evancz> Shouldn't I expect -split-objs to do better than -split-sections though?
05:49:59 <evancz> (I'm not worried about compile time or size of library artifacts, only the final executable.)
05:50:05 <merijn> evancz: GHC user guide suggest split-sections is superior to split-objects
05:50:16 <merijn> @where user-guide
05:50:16 <lambdabot> I know nothing about user-guide.
05:50:18 <merijn> hmmm
05:50:26 <merijn> @where userguide
05:50:26 <lambdabot> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/
05:51:03 <evancz> https://www.haskell.org/cabal/users-guide/nix-local-build.html?highlight=split#cfg-field-split-sections
05:51:22 <evancz> It just describes how it works. No comparison between them that I am seeing.
05:51:55 <evancz> Oh, the `-split-objs` has a note! "It is generally recommend that you use split-sections instead of split-objs where possible." Why though?
05:52:22 <evancz> Is that about the final binary size? Or about the other details of build times and build artifact size?
05:54:41 <merijn> evancz: Because split-objs is basically "faking split-sections at the object level" without the linker understanding what/why, whereas split-sections is a linker feature
05:56:08 <merijn> evancz: GHC docs literally say: "When linking, the linker can automatically remove all unreferenced sections and thus produce smaller executables. The effect is similar to -split-objs, but somewhat more efficient - the generated library files are about 30% smaller than with -split-objs."
05:56:17 <merijn> for split-sections
05:56:24 <evancz> That makes sense. That would suggest that the resulting binaries would be the same size with either approach, right? (I'm confused because when trying them out individually, that's not what I'm seeing.)
05:56:49 <evancz> I don't care about the size of library files, only the final executable.
05:57:09 <merijn> evancz: Potatoe, potatoe (that doesn't really work in text..)
05:57:13 <dmwit> Seems like a naive linker would just copy the contents of the library files into the executable.
05:57:21 <dmwit> So smaller library => smaller executable.
05:57:57 <dmwit> (And I would be VERY suspicious of any linker which claimed to do something smarter than that.)
05:58:33 <merijn> If you care about executable size, you care about library size, because how else would you possible reduce executable size...
05:58:42 <evancz> If I understand correctly, the library files are much bigger in BOTH cases. Just 30% less bigger in one of the cases.
05:59:01 <evancz> The point is that you don't use as many in the final executable.
05:59:11 <evancz> (In the split-objs case)
05:59:58 <merijn> I'm really confused what even the question or problem is. There's one recommended flag and one legacy one and the recommended one is better and producing smaller executables
06:00:09 <merijn> So, use that one and be done
06:00:48 <zer0xp[m]> Hey, are any of you working in academia ? The company that I'm working for is looking for a Haskell expert who can help with building an online Haskell course for a University elective. Please PM me if interested. 
06:03:17 <evancz> I just wanted to understand _why_ I was seeing some strange results.
06:03:34 <merijn> I challenge your assumption that the results are strange
06:04:07 <merijn> evancz: You apparently have a hypothesis that the two approaches should be identical. I disagree with that assumption and don't understand why you think that would be the case
06:04:55 <evancz> Here's the results:
06:05:23 <evancz> no flags: 53M (28M when stripped)
06:05:39 <evancz> split-objs: 62M (27M when stripped)
06:05:49 <merijn> evancz: So?
06:06:00 <evancz> split-sections: 25M (14M when stripped)
06:06:42 <evancz> On another project I am seeing binaries go from 13M to 2M with split-objs.
06:07:04 <evancz> It seems weird that it'd have such a swing in results
06:08:00 <merijn> "It seems weird" <- why?
06:08:14 <aldum> evancz: are you the elm guy?
06:08:33 <merijn> You seem to have a certain intuition how things "should behave", but it is unclear what you base this intuition on
06:09:56 <jollygood2> is there a better way of doing this?
06:10:00 <jollygood2> > map (\[x,y] -> (x,y)) $ chunksOf 2 [1..6]
06:10:02 <lambdabot>  [(1,2),(3,4),(5,6)]
06:10:52 <evancz> The question is about _why_ it's different. It's cool if you don't know either.
06:11:08 <evancz> One of my colleages found https://ghc.readthedocs.io/en/latest/8.2.1-notes.html that mentions that it'll be deprecated.
06:11:13 <jollygood2> > map (\[x,y] -> (x,y)) $ chunksOf 2 [1..6]
06:11:15 <lambdabot>  [(1,2),(3,4),(5,6)]
06:11:16 <jollygood2> > map (\[x,y] -> (x,y)) $ chunksOf 2 [1..5]
06:11:18 <lambdabot>  [(1,2),(3,4),*Exception: <interactive>:3:6-20: Non-exhaustive patterns in la...
06:11:30 <evancz> So it looks like "just don't do it" is the best why available for now.
06:11:30 <merijn> evancz: The answer is "it depends on the exact libraries you're linking and how they interact" there is no general answer
06:11:51 <Orbstheorem> Hello o/ If I make an instance of Default with undefined values, is there a way to statically check these values were overriden?
06:11:58 <jollygood2> > [(x,y) | [x,y] <- chunksOf 2 [1..5]]
06:12:00 <lambdabot>  [(1,2),(3,4)]
06:12:07 <evancz> Thanks for trying to help me out!
06:12:19 <fendor> > filter (odd . fst) $ zip [1..6] (tail [2..6])
06:12:21 <lambdabot>  [(1,3),(3,5)]
06:12:35 <fendor> > filter (odd . fst) $ zip [1..6] (tail [1..6])
06:12:37 <lambdabot>  [(1,2),(3,4),(5,6)]
06:12:52 <jollygood2> cool
06:13:04 <fendor> nah, I like [(x,y) | [x,y] <- chunksOf 2 [1..5]] better
06:14:13 <merijn> evancz: My point was that the exact savings are a function of "what can the linker make of the things it has been given" so the only thing you can/could do is dive into the specific object files and investigate what is being linked and why it's larger. There is no generalised/simple answer for these types of questions. That combined with the fact that split-objs is kind of an ugly hack to "trick" the 
06:14:19 <merijn> linker into doing something you want makes it rather unpredictable
06:14:36 <merijn> Orbstheorem: Not really, but more importantly: Default is a terrible typeclass and you should avoid using it
06:24:17 <jollygood2> nicer way of doing this?
06:24:20 <jollygood2> > let xs = [("foo", "barbaz")] in (T.isInfixOf "baz" <$> lookup "foo" xs) == Just True
06:24:22 <lambdabot>  error:
06:24:23 <lambdabot>      Not in scope: ‘T.isInfixOf’
06:24:23 <lambdabot>      Perhaps you meant one of these:
06:24:37 <jollygood2> > let xs = [("foo", "barbaz")] in (isInfixOf "baz" <$> lookup "foo" xs) == Just True
06:24:39 <lambdabot>  True
06:26:30 <fendor> looks fine to me. At most you may use `>>=` so you read from left to right, imo
06:26:46 <fendor> > > let xs = [("foo", "barbaz")] in (lookup "foo" xs >>= pure . isInfixOf "baz") == Just True
06:26:49 <lambdabot>  <hint>:1:1: error: parse error on input ‘>’
06:26:54 <fendor> > let xs = [("foo", "barbaz")] in (lookup "foo" xs >>= pure . isInfixOf "baz") == Just True
06:26:56 <lambdabot>  True
06:27:10 <fendor> or, maybe: 
06:27:36 <texasmynsted> So maybe not the ideal place to ask this but... I see "large nested unions are not handled performantly by the Haskell reference implementation." on https://github.com/coralogix/dhall-concourse
06:27:44 <fendor> > let xs = [("foo", "barbaz")] in (maybe False (isInfixOf "baz") (lookup "foo" xs) == True
06:27:45 <lambdabot>  <hint>:1:89: error:
06:27:45 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
06:27:51 <fendor> > let xs = [("foo", "barbaz")] in maybe False (isInfixOf "baz") (lookup "foo" xs) == True
06:27:53 <lambdabot>  True
06:28:02 <jollygood2> I like that one
06:28:32 <texasmynsted> It sounds like dhall-concourse is blaming the haskell implementation. That seems unfair?
06:32:30 <texasmynsted> Anybody know anything about this project?
06:34:18 <merijn> texasmynsted: Which project? dhall or dhall-concourse?
06:35:20 <texasmynsted> dhall-concourse. I find it unlikely that dhall its self has such performance issues.
06:35:34 <texasmynsted> but maybe
06:36:49 <chreekat_> "The slow and expensive performance is due to the increasing numbers of deeply-nested unions being added to the model, and currently, large nested unions are not handled performantly by the Haskell reference implementation."
06:37:11 <tabaqui1> do you know how to combine "prop" and "around" in hspec?
06:37:18 <texasmynsted> So do you think that means dhall its self?
06:37:43 <texasmynsted> Like it is generating huge thunks on deeply-nested unions?
06:37:54 <tabaqui1> I need to write similar code "test = around (openFile >>= run h) $ prop "test" (\handle randomData -> do smth)"
06:38:20 <tabaqui1> but I cannot realize how prop handles arguments here
06:40:59 <sm[m]> texasmynsted: don’t know, but curious, maybe dhall issue tracker can help too
06:41:00 <texasmynsted> Oh I see that dhall-concourse is all dhall. 
06:41:04 * texasmynsted facepalm
06:41:28 <texasmynsted> heh yeah. I checked the issue trackers first.
06:41:40 <jollygood2> I'm using aeson, and if I add a new field in the data structure with Maybe Bool type, that does not exist in json file, it is automatically set to Nothing. but if I make it Bool, then I get key not present exception. how can I automatically default to False when keys are missing? I am autogenerating FromJSON rather than defining it manually
06:41:44 <sm[m]> and/or #ghc
06:41:54 <texasmynsted> But I see now. Sadly it appears to be the dhall project its self
06:43:42 <Orbstheorem> merijn: What should be used instead of default if I want to provide default values for my record?
06:44:22 <Orbstheorem> Or is there a rationale for not using default values at all?
06:44:31 <merijn> Orbstheorem: Functions that take the mandatory argument and fills in all the "default" ones
06:44:39 <merijn> Orbstheorem: For example, see: https://hackage.haskell.org/package/process-1.6.6.0/docs/System-Process.html#v:shell
06:45:16 <merijn> Orbstheorem: Default configurations themselves are fine, but the problem with Default is that you never know what the "default" value of many types is
06:45:31 <merijn> Consider "Int", is the default 0? 1? something else?
06:46:04 <Orbstheorem> Hmm
06:46:10 <merijn> Orbstheorem: And if you're handwriting the "default" configuration, then you might as well just define a proper name for it
06:46:17 <Orbstheorem> Alright
06:46:38 <merijn> Orbstheorem: For example: https://hackage.haskell.org/package/prettyprinter-1.5.1/docs/Data-Text-Prettyprint-Doc-Internal.html#v:defaultLayoutOptions
06:48:16 <merijn> Orbstheorem: Basically, adding the Default class into the mix doesn't really solve any issues (you still have to handwrite the default value) and the only real difference is the user has to use a slightly more specific name than "def". The added advantage is that in cases where only some fields have defaults you can basically mimic process' approach of having a function that returns the configuration with 
06:48:23 <merijn> defaults for all non-mandatory fields and then the user can always overwrite them
06:49:02 <tabaqui1> oh, ok, I just "around (\run -> openFile >>= run) $ it "test" $ \handle -> property $ \randomData -> do Smth"
06:50:05 <dmwit> merijn: That effect can be achieved with Default, too; see https://github.com/dmwit/maryodel/blob/master/haskell/Dr/Mario/Protocol/Client.hs#L391-L414 e.g.
06:50:29 <merijn> dmwit: Can you explain what problem Default solves?
06:50:55 <dmwit> Hungarian notation is silly.
06:51:13 <merijn> dmwit: Lawless typeclasses with confusing semantics are worse
06:51:33 <dmwit> Everybody harps on "oh it's lawless". But nobody actually says what the problem with lawless is.
06:51:49 <Rembane_>  
06:52:02 <merijn> dmwit: It means you can't use "recursive" default uses like some people try to
06:52:22 <dmwit> Okay. I'm not familiar with that problem; would you unpack it a little for me?
06:52:56 <merijn> dmwit: People try and define records like "Foo { foo = def, bar = def, ... }" if that worked sensibly then it might have some sue
06:53:36 <merijn> But in practice Default just: 1) adds a dependency, 2) makes type errors worse/more confusing, 3) doesn't save the library author any work
06:53:48 <merijn> The pros seem to be "def is a nice short name for users to type"
06:54:27 <dmwit> Why doesn't `Foo { foo = def, bar = def }` work sensibly?
06:54:37 <merijn> dmwit: Well, what is def for Int?
06:54:52 <merijn> dmwit: In some cases 0 might be useful, others 1
06:54:53 <dminuoso> dmwit: What does that even do? The main problem for "default" is that it presumes every type in the world has one single canonical sensible default.
06:55:08 <dminuoso> If you really insist on providing a default value for some type, just make some `defaultPort` binding and be done with it.
06:55:15 <Orbstheorem> merijn: Thanks
06:55:18 <dmwit> merijn: So is the real problem the Int instance?
06:55:29 <dmwit> There are plenty of types where there really is a sensible default.
06:55:33 <dminuoso> Typeclasses mainly gain their power when you write polymorphic code. But writing `f :: Default a => ...` is not really sensible.
06:55:35 <merijn> dmwit: Well, can you answer me what the pros are?
06:55:41 <dmwit> I thought I did.
06:56:00 <merijn> dmwit: Which is? "you get to save a few characters"
06:56:01 <merijn> ?
06:56:19 <dminuoso> dmwit: What benefit do you get from saying `def` over `defaultPort`? What does that typeclass itself buy you?
06:56:52 <merijn> dmwit: Because if that's the only advantage than that's pretty piss poor value compared to the downsides
06:56:58 <dmwit> Library predictability, for one. Just like when I see "Num" in the list of instances, I instantly know a big chunk of a type's API, when I see "Default" in the instance list, I know a part of its API.
06:57:23 <merijn> dmwit: If you see defaultLayoutOptions, you do too
06:57:24 <jollygood2> I kind of like def for brevity
06:57:26 <dmwit> I don't have to guess whether it's `defPort` or `defaultPort` or `defP` or `defaultP` or `defaultPortNumber` or `standardPort` or what.
06:57:37 <jollygood2> and predictability
06:57:38 <dmwit> ...and then go hunting through the documentation for it.
06:57:51 <merijn> dmwit: Except you have to look up the documentation anyway to see if it's a Default instance :)
06:58:01 <merijn> @quote Wadler XML
06:58:01 <lambdabot> Wadler says: So, the essence of XML is this: the problem it solves is not hard, and it does not solve the problem well.
06:58:03 <dmwit> I have to look up the documentation for the type, which I was going to do anyway.
06:58:06 <merijn> ^^ applicable to Default too
06:58:19 <dmwit> I don't have to look up the documentation for the type, and then hope that the same module that defined the type defined all the API bits I care about, too.
06:58:23 <dmwit> Which happens *all* the time.
06:58:35 <dmwit> I click on a type, and it goes to a *.Types module that doesn't include any of the API.
06:58:36 <dminuoso> dmwit: and at that point, you might as well write `--| Blablabla. Suitable default is exported as 'defaultPort'` 
06:58:48 <merijn> dmwit: Blame GHC's shitty support for cyclical imports
06:58:54 <dmwit> And then I've no idea how to build one, because it's actually *.Types.Internal and I'm not even supposed to consider the constructors to be part of the API... =P
06:59:04 <nshepperd> 'instance Default CIntPtr' what the heck
06:59:16 <dmwit> dminuoso: I'd be fine with that, if it were consistently done. But it ain't.
06:59:25 <merijn> nshepperd: Like I said, that entire library is just offensive to my sensibilities >.>
06:59:44 <dminuoso> merijn: http://hackage.haskell.org/package/acme-default this captures the problems with Default nicely.
06:59:57 <dminuoso> merijn: Because this is a *perfectly* valid version of default that is in no way worse than data-default.
06:59:58 <nshepperd> basically none of these instances should exist
07:00:12 <dminuoso> I mean if data-default is fine, then so should acme-default.
07:00:22 * dmwit is fine with acme-default, believe it or not
07:00:53 <dminuoso> dmwit: Just curious.. are you one of those 540 downloads? :p
07:00:54 <fendor> can I supply a .ghci to a ghci process or does it always have to be in ~/.ghci or ./.ghci 
07:01:12 <dmwit> Nah. Of course I'm going to depend on the more standard one, that's just pragmatics.
07:01:53 <dmwit> But if all the Default instances for the basic types like numbers and Char and such were not the ones I wanted, I'd still find it a useful class to instantiate for more complex types.
07:02:04 <dmwit> The default-arguments pattern is just too useful for complicated APIs.
07:02:20 <dmwit> Too nice for the API user, I mean.
07:02:22 <dminuoso> My usual bar for a typeclass T is: Does it make sense to write polymorphic code `f :: T a => ...` and Default just does not make it that far.
07:03:51 <dminuoso> In addition some libraries using data-default don't even re-export def, forcing you to add data-default to your depends just in order use the library.
07:03:57 <dminuoso> Which I find somewhat offensive.
07:04:04 <dmwit> Agreed.
07:04:10 <dmwit> That's not data-default's fault, though.
07:04:16 <dminuoso> Absolutely.
07:04:38 <dminuoso> dmwit: But as you have pointed out consistency across hackage is a relevant factor.
07:05:00 <dmwit> Oh, it's consistent. You always have to depend on it yourself. -_-
07:08:45 <nshepperd> def @T { override = value } isn't valid syntax :(
07:10:58 <infinity0> suppose i have a state transition ST i,s -> m(o,s) that i want to build up using several smaller state transitions ST[x] which are partial functions on i, each can be modelled as i[x],s -> m(o,s), so the function ST would look something like \i,s -> StateT $ do case i of (does it match i[0]) -> ST[0] i; case i of (does it match i[1]) -> ST[1] i; case i of (does it match i[2]) -> ST[2] i; etc etc
07:11:25 <merijn> infinity0: Wait, is ST short for StateT?
07:11:29 <infinity0> now i want to ensure two properties, (1) all values of i are covered by some ST[x], and (2) all possible input types of ST[x] are "hit" by some value of i
07:11:32 <merijn> Or what?
07:11:42 <dmwit> nshepperd: (def @T) { override = value }
07:11:43 <infinity0> by ST i'm just referring to a specific instance of StateT
07:11:52 <infinity0> er, specific value rather
07:12:05 <merijn> infinity0: Ah, better don't, because ST is an existing (different) Monad :)
07:12:13 <nshepperd> dmwit: that's two whole extra characters! >:)
07:12:19 <dmwit> nshepperd: I guess it would be nice for @ to bind tighter than {}, though, since I think currently {} isn't valid at the type level anyway (?).
07:13:26 <dmwit> ?unmtl MaybeT (State s) a
07:13:26 <lambdabot> s -> (Maybe a, s)
07:13:38 <dmwit> ?unmtl StateT s Maybe a
07:13:38 <lambdabot> s -> Maybe (a, s)
07:13:49 <dmwit> infinity0: You might like (<|>) and StateT s Maybe
07:14:11 <infinity0> i don't think i've described the hard part of the problem well
07:14:44 <dmwit> Yes, this doesn't do either of your properties.
07:15:00 <infinity0> the issue with doing it the "simple" way like i said is that suppose ST[0] just does "return True" for all inputs, then it has "handled" the input. but ST[1] still wants to do some more stuff with some values of i but not others
07:15:20 <infinity0> i want to somehow ensure that when I implement the overall ST, i don't accidentally forget to call ST[1] on those particular values of i
07:15:25 <dmwit> There is currently no way in Haskell to do what you ask for the general case.
07:15:43 <infinity0> what if "those particular values" can be restricted to a branch of a ADT
07:15:52 <dmwit> If you use explicit case matching, GHC can warn you about incomplete and overlapping patterns. That's as close as you can get.
07:16:18 <infinity0> hm, ok thanks, guess i'll just do it the manual explicit way then
07:29:19 <djanatyn> i wanted to add some typeclass constraints to the constructors of a type, so I could assume when pattern matching on the constructor that the typeclass instance would be there (and there's no chance of a constructor holding a value that didn't implement the typeclass). i wanted to put that in the datatype definition, since a term of that datatype that doesn't implement the class would be an illegal state in
07:29:21 <djanatyn> my program. i found the DatatypeContexts extension, but it was deprecated for being "useless"
07:29:57 <djanatyn> i saw i could do something very similar with GADTs and ExistentialQuantification: data Create a where Create :: HasCreate a => a -> Create a
07:30:11 <merijn> djanatyn: "there's no chance of a constructor holding a the constructors of a type" <- no you don't
07:30:17 <djanatyn> am I doing the same "useless" thing as  with DataTypeContexts?
07:30:39 <merijn> djanatyn: ExistentialQuantification does something way different thatn DataTypeContexts
07:31:06 <dmwit> This isn't existential quantification anyway. That extension isn't needed here.
07:31:15 <dmwit> No you are not doing the same useless thing as DataTypeContexts.
07:31:26 <djanatyn> yeah, i was a little confused - the compiler recommended it when i just used GADTSyntax like described here: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-GADTSyntax
07:31:28 <dmwit> Nevertheless, it's considered best practice not to do this. See also https://stackoverflow.com/q/40825878/791604
07:31:40 <dmwit> Yes, you need GADTs, not just GADTSyntax.
07:31:50 <merijn> djanatyn: GADTSyntax is *just* syntax, GADTs changes how ADTs work
07:32:04 <merijn> @where existential-antipattern
07:32:04 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
07:32:24 <djanatyn> ah yeah, i see - the example is showing that what i'm doing isn't possible with GADTSyntax
07:34:32 <djanatyn> is it ever legitimate to want want your typeclass invariant in a constructor to *always* be there? i see how it's more flexible to put the typeclass in the function definitions, but in my case there's absolutely nothing I can do with a "Create PoolMember", for example, and i want that to be clear in my code
07:34:56 <boxscape> Are there things you can't write with ADT + type equality that you can write with GADTs?
07:34:58 <merijn> djanatyn: Well, why do you want that typeclass on the constructor?
07:35:15 <dmwit> boxscape: Sure, djanatyn's type. =)
07:35:32 <boxscape> I see
07:35:32 <merijn> djanatyn: Adding the typeclass constraint on constructor does *not* allow you to skip adding the constraint on your functions
07:35:45 <dmwit> djanatyn: Is Create the only constructor of the Create a type?
07:35:59 <merijn> djanatyn: Everyone who wants to use DatatypeContexts wants to use it so they can skip writing the constraint on every function, but it doesn't let you do that
07:36:07 <merijn> djanatyn: Hence, it's useless
07:36:16 <dmwit> merijn: ...but GADTs *do* let you skip adding the constraint.
07:36:20 <merijn> dmwit: Sure
07:36:25 <dmwit> And he's explicitly using GADTs for this reason.
07:36:30 <dmwit> So... why bring it up?
07:36:42 <merijn> dmwit: But GADTs and Existentials bring their own problems with them
07:36:50 <dmwit> But this isn't an existential.
07:37:14 <djanatyn> dmwit: yeah
07:37:31 <dmwit> djanatyn: What if you just... don't define this type? ^_^
07:37:38 <djanatyn> and yes, i don't think i wanted to use ExistentialQuantification here
07:37:41 <djanatyn> dmwit: ...ah :)
07:38:27 <djanatyn> dmwit: this makes a lot of sense - i was trying to represent different types of actions at the type level (Create a, Destroy a) and I was already thinking about using GADTs with an Action a type (and multiple constructors)
07:38:38 <nicknotfound> is there a good auto completion on emacs for haskell except autocompletion-mode?
07:38:56 <boxscape> dmwit re: ADT vs GADT, I realize this isn't strictly speaking included in my previous question, but can't you add type constraints to ADTs with -XGADTs and -XExistentialQuantification enabled?
07:39:08 <djanatyn> thanks for the help! i'm really enjoying diving into these compiler extensions, they're totally new ideas i've never encountered before
07:39:10 <merijn> djanatyn: That sounds more like you want DataKinds?
07:39:50 <boxscape> dmwit i.e. add them to ADT constructors
07:40:46 <dmwit> boxscape: Seems so; I therefore claim that ExistentialQuantification is a poorly-named extension, since it adds more than that.
07:40:54 <djanatyn> hmm, why would I use DataKinds instead of doing something like: data Action a where Create :: a -> Action a; Destroy a -> Action a? (i haven't been using DataKinds, but I have been reading abotu datatype promotion)
07:41:02 <lortabac> djanatyn: if I understand correctly, you want this data type to describe an API
07:41:06 <djanatyn> yeah
07:41:08 <boxscape> I suppose that does make the type a GADT, it just doesn't use GADT syntax, dmwit?
07:41:41 <lortabac> djanatyn: at work we often define a Command GADT, with all the possible actions
07:41:43 <dmwit> boxscape: er, wait
07:41:56 <dmwit> boxscape: Can you show the code you intend to be asking about? I suspect we haven't got the same snippet in mind at this point.
07:41:57 <lortabac> djanatyn: very similar to what you are doing
07:42:07 <saml> do you read GADT  gad? or gat?
07:42:20 <boxscape> dmwit I just typed this into ghci `data A a = Show a => A a | B a`
07:42:20 <dmwit> I read it "gad-it".
07:42:41 * hackage hs-speedscope 0.1.1.0 - Convert an eventlog into the speedscope json format  https://hackage.haskell.org/package/hs-speedscope-0.1.1.0 (mpickering)
07:42:56 <boxscape> I used to always say "G-A-D-T" and now sometimes gadit since I head rae say that it's pronounced that way
07:42:58 <lortabac> djanatyn: I think it's a good pattern
07:43:50 <dmwit> boxscape: cool cool cool
07:43:56 <dmwit> Still object that this isn't an existential.
07:44:01 <dmwit> But dunno where to direct my rage.
07:44:45 <djanatyn> i'm going a little wild with extensions, but this is some of the context around my code if anyone is curious: https://gist.github.com/djanatyn/d65d76661f43f861d043fad4fe183f87
07:44:51 <merijn> dmwit: Because it's not allowed to also clarify related things when discussing a question?
07:45:15 <merijn> dmwit: I didn't see a single line of anyone saying that was an existential
07:46:24 <djanatyn> i have type representing objects, but the API i'm interfacing with has it's own object references. i can lookup a reference to return types, but the references don't carry as much information as I need for a full object type. so, i used TypeFamilies to create an "APIReference a" type for anything that can be looked up. my creation operations take an object type, a, and return an APIReference a
07:47:03 <djanatyn> class HasLookupAPI a where data APIReference a :: *; lookupAPI :: APIReference a -> Client (Maybe a)
07:47:29 <djanatyn> (i'm wrapping some load balancer API I use at work a lot)
07:47:41 * nshepperd pronounces it 'gadt'
07:47:48 <dminuoso> djanatyn: APIReference is a dafam not a tyfam. :)
07:48:09 <dminuoso> Or rather an associated data type.
07:48:48 <djanatyn> ah yeah, i was really excited by that feature
07:49:00 <monochrom> associated data family >:)
07:49:02 <djanatyn> some of my other haskell friends said that TypeFamily code can be bit challenging to follow
07:49:15 <boxscape> dmwit the error message you get without GADTs is confusing as well, unless I'm misunderstanding something. It talks about "A :: forall a. Show a => a -> A a", but adding that forall would actually result in a very different constructor, I think
07:49:19 <djanatyn> but i've been reading up a lot about Idris and I wanted to try out all the -XDependentHaskell features
07:49:24 <boxscape> without -XGADTs, that is
07:50:21 <monochrom> "forall a. P a -> Q a" is very different from "forall a. P a -> Q", in both logic and types.
07:50:56 <monochrom> "forall a. P a -> Q" = "(exists a. P a) -> Q" but you can't do that to "forall a. P a -> Q a".
07:50:59 <djanatyn> merijn: How could DataKinds help me model these actions? i have trouble understanding a lot of code that uses DataKinds
07:51:36 <monochrom> This is also why programmers need to learn symbolic logic.
07:52:53 <boxscape> Ah actually I did misunderstand the error message
07:53:09 <boxscape> adding the forall in the type is different from adding it in the ADT definition
07:53:12 <dminuoso> djanatyn: DataKinds promotes type constructors to kinds and data constructors to types. :)
07:53:22 <c_wraith> I'm very amused that goldfire quit seconds before you said you wanted to start using DependentHaskell features.
07:53:33 <dminuoso> djanatyn: So with -XDataKinds there exists a *type* `True` whose kind is `Bool` 
07:53:50 <dminuoso> djanatyn: And the kind Bool is inhabited by two types True and False.
07:59:27 <djanatyn> hmm, I think I would like my terms to be exactly the things I can create: it might look like {Create Pool, Create PoolMember}, for example. then I could create functions that only accept values of that kind, to avoid representing (Create NonCreatableObject)
07:59:37 <djanatyn> i should probably look at some more code that uses DataKinds for ideas
08:01:11 <djanatyn> i see another reason why I was using this (Create a) type/constructor - it gave me an interface for writing custom ToJSON instances. hmmmm
08:03:25 <dminuoso> monochrom: Im strictly following the terminology GHC uses in its manuals. They call them either "data families" or "associated data types" :P
08:04:10 <djanatyn> it's very surprising to me that I can turn on DataKinds in default-extensions and my code still works
08:04:32 <dminuoso> djanatyn: DataKinds doesn't change existing code. It just adds extra types and kinds, so to speak. :)
08:04:52 <geekosaur> it shouldn't affect existing code, although erroneous code might mysteriously become valid (but not do what you intended, probably)
08:05:30 <geekosaur> well, erroneous type signatures
08:07:36 <lortabac> my only problem with DataKinds is that it leads you very quickly to singletons and other complicated stuff
08:08:00 <lortabac> it works well as long as all the type information is known statically
08:08:54 <lortabac> but once you need to deserialize from an external source, you need advanced tricks to reconstruct the types
08:10:13 <Zemyla> Will Linear Haskell add a Comonoid type, or would that prevent some of the benefits of linearity?
08:12:08 <Zemyla> Like, a function Int -o Int should use the argument exactly once, but if Int is a Comonoid, you can't guarantee that.
08:21:50 <TheCommieDuck> possibly silly question: I'm getting issues with ambiguous 'length'; (length "-----"). It's trying to match it as Foldable or Either or a bunch of other things.
08:22:36 <jonnobrow> quit
08:23:08 <TheCommieDuck> well, I know my haskell-foo is pretty basic, but that's a little extreme. :p
08:23:29 <pikajude> TheCommieDuck: what do you want it to be?
08:24:10 <TheCommieDuck> Int. length :: String -> Int.
08:24:46 <TheCommieDuck> I know I can explicitly annotate it, but it just seems like I'm doing something wrong if I need to annotate finding the length of a string literal
08:24:55 <pikajude> > length "-----"
08:24:57 <lambdabot>  5
08:25:04 <pikajude> what's the error exactly?
08:25:26 <geekosaur> hrm. could this be polymorphic string literals leading to Foldable n ot being able to pick an instance?
08:25:35 <pikajude> yeah, that's why
08:25:43 <TheCommieDuck> oh - it seems like it was auto-inferring Text.length, not just Prelude.length.
08:25:55 <TheCommieDuck> despite the fact it needed me to explicitly qualify Text.length somewhere else.
08:26:06 <pikajude> well, Prelude.length is [a] 
08:26:10 <pikajude> oops, early enter
08:26:16 <pikajude> Prelude.length operates on list anyway, so it couldn't be that
08:26:40 <TheCommieDuck> I mean, with overloadedstrings, doesn't it consider "blah" to be either [Char] or Text?
08:26:51 <pikajude> well, it considers it to be IsString a => a
08:26:58 <TheCommieDuck> ahh
08:27:04 <pikajude> and people could define all kinds of wacky instances for IsString
08:27:16 <pikajude> IsString a => IsString (Either e a) where fromString = Right . fromString
08:27:43 <pikajude> and the `Foldable.length` of `Right a` is 1, but the `Foldable.length` of the value inside the Right would be the string length, instead
08:27:47 <pikajude> so you can see where the confusion comes from
08:28:00 <TheCommieDuck> yeah, makes sense.
08:28:01 <TheCommieDuck> thanks :)
08:32:11 * hackage sexpresso 1.0.0.2 - A flexible library for parsing and printing S-expression  https://hackage.haskell.org/package/sexpresso-1.0.0.2 (VincentArchambault)
08:50:22 <ollehar> How much can you differentiate between different side-effects in Haskell? E.g. between database IO and stdout writing?
08:50:32 <dminuoso> ollehar: You cannot.
08:50:36 <ollehar> D:
08:50:44 <dminuoso> ollehar: There's a few tricks to make the differences visible in code though
08:50:49 <ollehar> ok
08:51:12 <dminuoso> ollehar: For example, you could have some `class MonadDatabase` and then write `addUser :: MonadDatabase m => User -> m ()`
08:51:23 <dminuoso> ollehar: And then reason that addUser cannot do anything that the class doesn't support.
08:51:45 <ollehar> What's MonadDatabase's relation to IO monad?
08:52:00 <maerwald> An effects system would allow you to make this visible at any granularity you want
08:52:21 <dminuoso> ollehar: So in general I'd have some `newtype App a = App { runApp :: ReaderT Env IO a }` - and then write `instance MonadDatabase App`
08:52:24 <ollehar> maerwald: I am well aware. :) Sadly, there's no industry-ready langauge with an effect system.
08:52:29 <maerwald>  But those libraries are all in flux and no one seems to use it much in production 
08:52:41 * hackage slick 1.0.1.0 - A quick & easy static site builder built with shake and pandoc.  https://hackage.haskell.org/package/slick-1.0.1.0 (ChrisPenner)
08:52:41 <maerwald> Doesn't have to be a language 
08:52:50 <dminuoso> ollehar: (And here Env might have access to some `Pool Connection` from resource-pool, such that you can implement MonadDatabase sensibly)
08:53:24 <ollehar> dminuoso: thanks
08:53:31 <ollehar> dminuoso: I don't know Haskell really, was just curious.
08:53:38 <dminuoso> ollehar: I see!
08:53:41 <ollehar> :)
08:53:48 <ollehar> maerwald: has to be something
08:53:49 <maerwald> ollehar: there are effects libraries 
08:53:56 <maerwald> Check polysemy 
08:54:07 <ollehar> Nope, must be stable for me to consider.
08:54:14 <ollehar> I'm happy with OCaml otherwise :D
08:54:29 <dminuoso> ollehar: So MonadDatabase is essentially a specialization of IO which, in its interface, can only do database interaction.
08:54:48 <maerwald> ollehar: nothing here is stable, except types, lol
08:54:55 <dminuoso> ollehar: So by writing `addUser :: MonadDatabase m => User -> m ()` you can know that addUser can only use the interface of `MonadDatabase` and not arbitrary IO.
08:55:07 <ollehar> dminuoso: that's good!
08:55:08 <dminuoso> ollehar: This style is employed by the mtl across the board and models an effect system. :)
08:55:11 * hackage hedgehog-servant 0.0.0.1 - Hedgehog property testing for Servant APIs  https://hackage.haskell.org/package/hedgehog-servant-0.0.0.1 (felixmulder)
08:55:18 <ollehar> looks cool
08:55:20 <ollehar> dminuoso: what's mtl?
08:55:28 <dminuoso> ollehar: Basically a collection of MonadX things.
08:55:32 <ollehar> ok
08:55:35 <dminuoso> ollehar: MonadState, MonadReader, MonadWriter, etc..
08:55:38 <maerwald> dminuoso: the example would be more interesting without IO
08:55:39 <ollehar> right
08:57:07 <dminuoso> ollehar: So for instance `f :: (MonadState GameState m, MonadIO m) => m Int` is some action that has access to stateful GameState and it can do IO.
08:57:44 <dminuoso> ollehar: Equivalently `f :: (MonadLogger m) => Int -> m ()` has access to the logger enviornment, but it cant do any other effects.
08:57:53 <ollehar> dminuoso: Is this subclassing?
08:57:57 <dminuoso> ollehar: Not really
08:58:01 <ollehar> Type alias?
08:58:12 <dminuoso> ollehar: I think scala folks call tihs final tagless encoding?
08:58:21 <dminuoso> *tagless final
08:58:30 <ollehar> pfff, scala. ain't noone understands that XD
08:58:32 <dminuoso> Heh
08:58:45 <EvanR> ain't nobody got time for that
08:58:59 <dminuoso> ollehar: `f :: MonadIO m => m ()` is an action returning no information, that works for any monad that can do arbitrary IO
08:59:22 <ollehar> dminuoso: But yeah, this is great info, really. I will include it in my blog post ^^ http://olleharstedt.github.io/opinion/2019/11/05/increase-pure-functions.html
08:59:25 <dminuoso> ollehar: `g :: MonadState GameState m => GameState -> m Bool` is an action returning a Bool, that works for any monad that can manipulate a stateful GameState
08:59:33 <maerwald> mtl isn't all that exciting in the end
08:59:51 <ollehar> why?
09:00:01 <maerwald> But it's rather well defined
09:01:06 <boj> dminuoso: thank you for the ldap-client patch, great addition
09:01:14 <maerwald> Because it isn't really an effects system and often times you are still dealing with transformers or your own huge god-object that encapsulates all the effects. 
09:01:38 <maerwald> He called it App
09:02:16 <maerwald> Isn't particularly composable imo. But it's the best we got
09:02:26 <ollehar> dminuoso: any link that explains this?
09:02:47 <EvanR> maybe it's semimythological to be able to decomplect your App into independent effects
09:02:50 <ollehar> maerwald: still, better than other languages
09:02:57 <maerwald> Oll
09:02:57 <EvanR> we just don't write apps like that
09:03:53 <dminuoso> boj: You're welcome. I see you took hold of that package. Any rough estimate when you will release 0.4.0?
09:04:11 * hackage keycloak-hs 1.0.0 -   https://hackage.haskell.org/package/keycloak-hs-1.0.0 (CorentinDupont)
09:04:35 <dminuoso> (Just asking because we've been using my ldap-client patch for about 9 months now, and it'd be great to let go of cabal depending on git)
09:04:37 <maerwald> EvanR: I want to write libraries with zero low level code and the user can write the interpreters, hah. 
09:04:37 <boj> dminuoso: if not this week, definitely next. showing a teammate around and getting upload approval for him
09:04:50 <dminuoso> boj: Alright great. If there's any questions let me know :)
09:04:56 <boj> yep!
09:06:13 <maerwald> And then the ecosystem would develop into two categories: domain logic and interpreters 
09:06:35 <maerwald> Imagine the chaos and the ways you can compose
09:07:01 <dsal> maerwald: I felt like I was approaching that in my mqtt library building on conduit.  I'm using STM all over the place internally and have a bunch of threads, but the actual IO is managed via conduit so there are just little adaptors for plain tcp, tls, and websockets over each.
09:07:07 <maerwald> Might be next level of programming. And then we go back to OOP
09:07:57 <EvanR> and then everyone wrotes code like Art Of Computer Programming
09:08:12 <EvanR> and nature reclaims us
09:09:07 <dsal> Is there a reasonable way to build my own default stack template?
09:09:20 <maerwald> And GHC would reject programs that don't use dependent types or FRP! 
09:11:11 * hackage seqid 0.6.1 - Sequence ID production and consumption  https://hackage.haskell.org/package/seqid-0.6.1 (wraithm)
09:15:48 <ollehar> Nothing wrong with OOP
09:15:52 * ollehar :O
09:19:41 * hackage ats-pkg 3.3.0.4 - A build tool for ATS  https://hackage.haskell.org/package/ats-pkg-3.3.0.4 (vmchale)
09:21:47 <maerwald> ollehar: I think by now everyone has realised that composition > inheritance. And stateless > stateful. And proper APIs > getter-setters... and
09:23:51 <dsal> Made my own stack project.  My life has just improved.
09:25:12 <maerwald> Stack? 
09:25:36 <Uniaika> dsal: like, stack template?
09:25:44 <dsal> Er, yes, sorry.
09:26:02 <dsal> project template.  So now I don't have to remember all the things I like when I'm starting stuff.
09:26:34 <jgt> dsal: did you take a look at summoner?
09:26:46 <dsal> I've not heard of this.
09:27:09 <yushyin> mmh yes, need to write a stack template too
09:29:33 <dsal> It's not hard, just docs all over the place.
09:29:57 <dsal> Grab this file:  https://github.com/commercialhaskell/stack-templates/blob/master/new-template.hsfiles   edit it.  Stick it in a gist or something.    stack new https://...
09:30:05 <dsal> Then you can  set new-template  in ~/.stack/config.yaml
09:35:39 <yushyin> summoner looks cool with the TUI but also a bit overkill for me. a template file will be sufficient in my case.
09:39:18 <fendor>  any idea why terminateProcess might not kill a running process?
09:40:03 <dsal> Is it unkillable?
09:40:16 <jgt> there's a movie joke in there somewhere
09:40:29 <fendor> seemingly, I need sigkill in htop to finally kill it
09:40:42 <dsal> terminateProcess should reboot the machine.
09:40:42 <fendor> it also spins at 100%, it is a interactive ghci process, btw
09:47:33 <sm> https://github.com/replit/upm , repl.it's Universal Package Manager, sounds pretty nice. Wouldn't it be great to add cabal/stack support ?
09:48:41 * hackage parameterized-utils 2.0.1.0 - Classes and data structures for working with data-kind indexed types  https://hackage.haskell.org/package/parameterized-utils-2.0.1.0 (KevinQuick)
09:49:24 <TheCommieDuck> so at a very basic level, if I have a StateT Foo IO a, and then a do block (or equivalent binds), I can think of the computations being done in the state context (so I am passing an implicit state to every function along the way), and then doing lift foo is jumping out of the state context (which is still within the IO context)?
09:50:20 <EvanR> terminateProcess should reboot the franchise?
09:50:57 <merijn> fendor: Process might be stuck in a syscall
09:52:12 <fendor> merijn, oh, right, so, e.g. they might be reading from stdin?
09:52:25 <EvanR> TheCommieDuck: lift myIO isn't jumping out of anywhere, it's embedding myIO into your StateT "context".
09:52:44 <EvanR> which you can see in the type
09:52:47 <pikajude> uh-oh, evan said the c-word
09:52:55 <dsal> TheCommieDuck: That's kind of a weird way to think of it.  The "do block (or equivalent binds)" implies some monad which isn't stated in your question.  It might be part of your StateT thing, or it could be even higher.
09:53:10 <EvanR> IO a -> StateT Foo IO a
09:53:20 <EvanR> into, not out of
09:54:19 <EvanR> with monads only, you can only get into. With comonads only you can only get out of
09:54:24 <jle`> i like to think of it in terms of the 'functor design pattern'
09:54:26 <jle`> http://www.haskellforall.com/2012/09/the-functor-design-pattern.html
09:54:42 <jle`> ( TheCommieDuck )
09:55:06 <jle`> you pick a master 'lowest common denominator' type that expresses all the power you need
09:55:21 <jle`> and then now you can program in your 'less powerful types' (like IO), to get an IO a
09:55:22 <TheCommieDuck> I want to feed this function a Foo, then it does some things to the Foo, and outputs some things and does IO in general, then gives me an updated Foo and a result of a. So right now, that's \f = do lift $ putStr "do some output stuff" ; modify (\x -> x { ... }) return a
09:55:35 <TheCommieDuck> ohhh, okay
09:55:40 <jle`> and you can unite it back with StateT s IO a with 'lift :: IO a -> StateT s IO a'
09:56:05 <jle`> so basically "i want to sequence an IO action into StateT s IO a.  but i can't. i can only sequence StateT s IO a actions together."
09:56:07 <TheCommieDuck> I've got that article up, will read it shortly
09:56:21 <jle`> " so ==> i'll just convert that IO into StateT s IO a, so now sequencing is ez pz"
09:56:46 <jle`> note that this view falls apart when you start considering functions that 'take' IO, instead of 'give' IO. but that story is a lot more complicated
09:57:05 <TheCommieDuck> "do: some state action, some IO action, some state action" => "do: some state action, convert my IO action into a state action with lift, some state action"?
09:57:14 <TheCommieDuck> okay poor use of => but
09:57:19 <jle`> TheCommieDuck: yeah. in the end it's state action, state action, state action
09:57:25 <jle`> and you can 'pretend' an IO is a State action with lift
09:57:30 <jle`> to make the types match up
09:57:42 <jle`> in this sense lift becomes sort of like an explicit conversion function
09:57:45 <TheCommieDuck> that makes sense. thank you. the functor post looks good too
09:57:51 <jle`> like 3.5 + fromIntegral x + 5.9
09:58:04 <TheCommieDuck> (I should probably stop thinking of functors and whatnot as boxes)
09:58:05 <jle`> > let x = 3 :: Int in 3.5 + x + 5.9 :: Double
09:58:07 <lambdabot>  error:
09:58:07 <lambdabot>      • Couldn't match expected type ‘Double’ with actual type ‘Int’
09:58:07 <lambdabot>      • In the expression: 3.5 + x + 5.9 :: Double
09:58:12 <jle`> > let x = 3 :: Int in 3.5 + fromIntegral x + 5.9 :: Double
09:58:14 <lambdabot>  12.4
09:58:21 <jle`> ^ massaging the types to get them to + together properly
09:59:00 <EvanR> hmm. We know boxes can express any concept with enough effort. But seriously, what are some actual abstract things you can do with a box
09:59:10 <EvanR> put it over something, remove it again?
09:59:12 <jle`> TheCommieDuck: there are some other ways to do it though -- a 'typeclass based' way, championed by libraries like mtl
09:59:41 <jle`> TheCommieDuck: in the typeclass based way, you never have an IO action --- you always have `MonadIO m => m a`
09:59:50 <jle`> which will work for 'any monad that supports IO'
09:59:58 <TheCommieDuck> I wish more IO tutorials mentioned that IO is RealWorld -> (a, RealWorld). it makes it so much more sense when you consider it takes the real world and gives you an updated real world.)
10:00:07 <jle`> TheCommieDuck: ah, that's actually not true
10:00:13 <TheCommieDuck> oh, okay. well.
10:00:15 <jle`> IO is *not* RealWorld -> (a, RealWorld)
10:00:23 <jle`> and it actually falls apart for most analysis of IO
10:00:33 <EvanR> TheCommieDuck: where is this tutorial.
10:00:41 * EvanR locks and loads
10:00:46 <TheCommieDuck> "IO inside" on the haskell wiki.
10:01:00 <jle`> TheCommieDuck: as in, in most ways to reason about IO, that interpretation gives you more wrong intuition than right intuition
10:01:09 <TheCommieDuck> it does open with 'Warning: The following story about IO is incorrect' but it says that's for concurrency.
10:01:13 <jle`> the proper description of IO is as a description of some I/O action
10:01:29 <jle`> so `putStrLn "hi"` describes the act of printing "hi"
10:01:32 <pikajude> honestly they should remove the monad instance for OI
10:01:33 <pikajude> IO
10:01:36 <pikajude> and just call it something else
10:01:42 <jle`> mionad
10:01:44 <pikajude> so people stop thinking monad has something to do with IO
10:01:52 <EvanR> Mayonad
10:02:00 <pikajude> rust calls inlined type signatures "turbofish", maybe we could do something like that
10:02:04 <dolio> It's not wrong just for concurrency. It completely fails to achieve the semantic goals that leads to introducing IO.
10:02:08 <TheCommieDuck> heh
10:02:13 <TheCommieDuck> excellent.
10:02:17 <pikajude> class Fishy m where (>>=) :: m a -> (a -> m b) -> m b
10:02:22 <jle`> yeah, the intuition you think it gives you is actually...completely false
10:02:32 <jle`> it doesn't take any real world and doesn't give you any updated real world
10:02:37 <jle`> and it's not a function from real world to real world
10:02:55 <jle`> there is nothing intuitively useful to be gained from that perspective
10:03:02 <jle`> that gives you any more usable understanding of IO
10:03:12 <jle`> and it gets in the way of understanding the actual semantics of IO
10:03:16 <nshepperd2> @hackage acme-realworld
10:03:16 <lambdabot> http://hackage.haskell.org/package/acme-realworld
10:05:01 <jle`> you shouldn't think of IO as a function, you should think of it as a description :)
10:05:11 <jle`> or as a 'plan', like some people call it
10:05:47 <benjwadams> :t absurd
10:05:48 <lambdabot> Void -> a
10:06:14 <benjwadams> What's the point of `absurd`?
10:06:33 <jle`> mainly it's used to help with complete pattern matches
10:06:40 <jle`> in practice
10:06:58 <jle`> for example some libraries let you pick your error type
10:07:11 <jle`> like Parser e a, where 'e' is the type of parse errors
10:07:11 * hackage seqid-streams 0.7.1 - Sequence ID IO-Streams  https://hackage.haskell.org/package/seqid-streams-0.7.1 (wraithm)
10:07:22 <benjwadams> how is absurd different than a function that returns some constant in `a`?
10:07:23 <jle`> so you might have a running function like parser :: Parser e a -> String -> Either e a
10:07:38 <jle`> now let's say you know your parser will never have any errors
10:07:42 <jle`> then you can set e ~ Void
10:07:54 <jle`> then you would have runParser :: Parser Void a -> String -> Either Void a
10:08:12 <jle`> now, because Void has no constructor, you would never have anything returned with 'Left'
10:08:16 <jle`> it will always be 'Right'
10:08:21 <pikajude> case (some_expr :: Either Void a) of ...
10:08:43 <jle`> so how do you handle this in a safe way?  you would pattern match on Left and use absurd to satisfy pattern matching completion
10:09:01 <jle`> @let myEither :: Either Void Int; myEither = Right 4
10:09:03 <lambdabot>  Defined.
10:09:16 <jle`> > case myEither of Left v -> absurd v; Right i -> i
10:09:18 <lambdabot>  4
10:09:27 <benjwadams> I have to profess I haven't touched Haskell for about a year now, but have never known about Void
10:09:33 <nshepperd2> absurd turns a program that runs forever into a program that runs forever, then returns anything you want
10:09:39 <benjwadams> so Void is an empty set, but can't actually be constructed?
10:09:46 <pikajude> @src Void
10:09:46 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
10:09:47 <jle`> benjwadams: s/but/and
10:09:50 <pikajude> come on lambdabot
10:09:53 <pikajude> @src Data.Void.Void
10:09:53 <lambdabot> Source not found. Just try something else.
10:09:55 <pikajude> ok...
10:09:59 <pikajude> well I tried
10:10:03 <jle`> pikajude: src doesn't actually give any sources
10:10:06 <jle`> it's basically like @quote
10:10:07 <pikajude> the declaration is just `data Void`
10:10:20 <pikajude> you can only do `undefined :: Void`
10:10:22 <pikajude> it has no constructors
10:10:36 <nil> jle`: couldn't the compiler detect that there are no possible values of the form `Left _`, and therefore consider `case e of Right i -> i` as complete?
10:10:39 <jle`> benjwadams: yeah, you *could* write `case myEither of Left _ -> 0; Right i -> i`, but 'absurd' is useful because you don't have to think of or construct a random thing
10:10:40 <benjwadams> Can you construct a function that only returns bottom?
10:10:57 <pikajude> undefined
10:11:01 <jle`> nil: technically values exist of Left _, since you can have Left undefined
10:11:09 <jle`> i wouldn't call undefined a function that only returns bottom
10:11:10 <pikajude> also, i think forever returns bottom?
10:11:10 <benjwadams> in the sense of not having to declare a type?
10:11:15 <jle`> but \_ -> undefined, would
10:11:20 <nil> jle`: true
10:11:26 <benjwadams> :t \_ -> undefined
10:11:27 <lambdabot> p -> a
10:11:49 <jle`> nil: however in ghc 8.8 if you have a strict field, GHC will not bother you about the empty pattern
10:11:55 <nil> cool
10:12:02 <jle`> nil: so if Left was strict on its field then GHC would not require an explicit match on it
10:12:08 <jle`> s/empty/missing
10:12:21 <jle`> benjwadams: bottom is a value, not a type
10:12:45 <jle`> benjwadams: but yeah, Void is a useful type because it can be put in sum types to signal 'this sum won't ever happen'
10:12:49 <jle`> er, this branch won't ever happen
10:13:00 <benjwadams> jle`: bottom can be returned by any function, in addition to the types declared, right?
10:13:19 <benjwadams> :t Maybe Void
10:13:20 <lambdabot> error:
10:13:20 <lambdabot>     • Data constructor not in scope: Maybe :: t0 -> t
10:13:20 <lambdabot>     • Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
10:13:22 <jle`> benjwadams: i'm not sure what you mean, functions don't return types
10:13:26 <jle`> they return values
10:13:28 <pikajude> :k Maybe Void
10:13:29 <lambdabot> *
10:13:34 <nil> Void is to Either what () is to (,)
10:13:43 <jle`> benjwadams: maybe you mean that a function could always return bottom in addition to the values of its target type?
10:13:57 <jle`> so `not :: Bool -> Bool`, could return False, True, or _|_
10:14:04 <benjwadams> jle`: no, i mean is it possible to only return bottom?
10:14:06 <jle`> bottom is the 'extra inhabitant' of every type in haskell
10:14:12 <benjwadams> from a function
10:14:14 <jle`> benjwadams: yeah, not _ = undefined
10:14:23 <pikajude> strict values cant be bottom though
10:14:33 <pikajude> at least, i don't think so
10:14:34 <jle`> or do you mean, is it possible for a function to have a type that signifies that it will only return bottom?
10:14:44 <benjwadams> jle`: the latter
10:14:49 <jle`> because a function like `mkInt :: String -> Int`; mkInt _ = undefined` will always return bottom
10:15:01 <jle`> but if a function's return type is Void  ... Void has no non-bottom inhabitant
10:15:13 <jle`> so a function like `myFunc :: Int -> Void` will necessarily always return bottom, enforced by the type system
10:15:23 <nil> a function with type `X -> a` will always return bottom too, right?
10:15:35 <jle`> if it's forall a, yeah
10:15:39 <nil> yes
10:15:48 <jle`> so for example `error :: String -> a`
10:15:52 <jle`> error has to necessarily return bottom
10:15:53 <nil> (since it can be specialised to `X -> Void`)
10:16:01 <jle`> so also absurd :: Void -> a
10:16:41 <jle`> the difference between error and absurd is that absurd is a total function :)
10:16:41 * hackage unagi-streams 0.2.6 - Unagi Chan IO-Streams  https://hackage.haskell.org/package/unagi-streams-0.2.6 (wraithm)
10:16:43 <nil> (i guess `Void -> Void` is the edge case)
10:16:57 <dmwit> maerwald: The compiler is the one claiming it's an existential: it is illegal syntax without the ExistentialQuantification extension, and works (and means the right thing) with it.
10:17:12 <jle`> error is undefined for all inputs. absurd is defined for all inputs
10:17:35 <dmwit> But I'm no longer as certain that existential is a bad name for it as I was before.
10:17:42 <jle`> all non-bottom inputs, at least
10:17:57 <benjwadams> So because there are no values in the domain of Void, it can't be instantiated, correct?
10:18:13 <jle`> 'called' or 'applied', maybe, yeah
10:18:23 <benjwadams> sorry if my nomenclature is a little off
10:18:32 <dmwit> After all, the eliminator does look existential like. e.g. for `data Foo a = Num a => Foo a` the eliminator is `foo :: (Num a => a -> r) -> Foo a -> r`, which does look similar to the standard translation of existentials.
10:18:43 <jle`> benjwadams: but yeah, in practice you often would be able to use \_ -> 4 or something like that, instead of absurd, if the result type is known
10:18:55 <jle`> benjwadams: the benefit of using absurd is (1) the reader will know that that branch is intended to not be taken
10:19:05 <jle`> so it helps with self-documenting code in a way that \_ -> 4 wouldn't
10:19:17 <jle`> and (2) it's useful if getting a value of 'a' is difficult
10:19:42 <jle`> for example to make an `MVar Int` you need to use newMVar :: Int -> IO (MVar Int), and then bind from IO
10:20:02 <benjwadams> as \_ -> 4 could return a result if it were ever reached.  absurd can't because you can't make Voids ?
10:20:04 <jle`> so it's kind of annoying to just generate a random mvar, bind from IO, etc. just to do \_ -> myThrowayMVar
10:20:18 <benjwadams> Am I understanding correctly?
10:20:21 <jle`> benjwadams: i'm saying absurdFour :: Void -> Int; absurdFour _ = 4
10:20:25 <jle`> that function would also never retunr 4
10:20:45 <jle`> trying to answer the question you wrote earlier about why you couldn't just return a constant value
10:20:58 <jle`> in both cases the 4 is never reached
10:21:05 <jle`> but using 'absurd' has benefits over just always returning 4
10:21:13 <jle`> like in the example of:
10:21:26 <jle`> > case myEither of Left _ -> 1000; Right i -> i
10:21:27 <lambdabot>  4
10:21:37 <jle`> > case myEither of Left v -> absurd v; Right i -> i
10:21:38 <lambdabot>  4
10:21:47 <jle`> both cases are technically the same, so you don't *need* absurd
10:21:58 <jle`> but using absurd signals to the reader that the left branch is never intended to be reached
10:22:06 <jle`> and also the reader might wonder things like 'I wonder why 1000 is important...'
10:22:40 <jle`> and also in some cases getting a value of the right type is difficult.  not like 'Int' in that example, where it is easy.
10:23:33 <jle`> in the first case reader would read it and say "i wonder why they are returning 1000. what would happen if Left gets hit?" in the second case the reader would read it and say "ah, Left never will happen, so i'll just look at the Right case"
10:23:44 <sm> is there any random number generation available in base ?
10:24:00 <jle`> s/what would happen if Left gets hit/what would cause Left to be returned
10:24:28 <jle`> sm: i've had some success with hGet from /dev/null :)
10:25:29 <jle`> er
10:25:31 <jle`> /dev/urandom
10:25:51 <jle`> but it's not exactly cross-platform
10:27:15 <sm> jle`: nice. I'm exploring making quick games on http://repl.it. The time library is there too
10:27:21 <sm> but not random
10:28:47 <jle`> > forever Nothing     -- pikajude 
10:28:49 <lambdabot>  Nothing
10:28:58 <sm> if anybody wants to join our multiplayer repl, come to #haskell-game
10:29:41 * hackage ldap-client 0.4.0 - Pure Haskell LDAP Client Library  https://hackage.haskell.org/package/ldap-client-0.4.0 (sambolias)
10:29:55 <jle`> > forever $ Const (Any True)
10:29:57 <lambdabot>  Const (Any {getAny = True})
10:30:27 <jle`> sm: ah i could have sworn that was already on my auto-join list ... maybe i took it off some time ago and forgot
10:30:57 <jle`> pikajude: forever is as lazy as *>
10:31:23 <jle`> pikajude: instance Applicative Maybe where Nothing *> _ = Nothing
10:32:59 <jbweston[m]> Not sure if this is the correct place to post such questions, but here goes:
10:33:32 <jle`> benjwadams: btw, if you are familiar with logic, absurd is known as the "principle of explosion"
10:33:52 <jle`> benjwadams: if you take Void as False, absurd :: Void -> a means "from falsehood, you can imply anything"
10:34:06 <koz_> Something something Curry-Howard.
10:34:26 <jle`> hm, i suppose it's slightly different than principle of explosion
10:35:30 * jbweston[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/mMHmAGUBKUlVMGCpvrpryoVb >
10:36:41 * hackage opaleye-trans 0.5.1 - A monad transformer for Opaleye  https://hackage.haskell.org/package/opaleye-trans-0.5.1 (wraithm)
10:36:42 * jbweston[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/ThlwwRVYHwMmUbCzbsoJnTpD >
10:38:41 * hackage heartbeat-streams 0.1.0.2 - Heartbeats for io-streams  https://hackage.haskell.org/package/heartbeat-streams-0.1.0.2 (wraithm)
10:40:25 <nil> jbweston[m]: monomorphism restriction, presumably
10:41:35 <jbweston[m]> <nil "jbweston: monomorphism restricti"> thanks; I know what to google now!
10:42:19 <nil> you can either disable it with `{-# LANGUAGE NoMonomorphismRestriction #-}`, or explicitly annotate `read' :: Read a => String -> a`
10:42:55 <jle`> (probably don't disable it)
10:48:16 <TheCommieDuck> is <=< just a typo of >>= or is it a different operator?
10:48:31 <nil> :t (<=>)
10:48:32 <Rembane_> :t (<=<)
10:48:33 <lambdabot> error:
10:48:33 <lambdabot>     • Variable not in scope: <=>
10:48:33 <lambdabot>     • Perhaps you meant one of these:
10:48:33 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
10:48:35 <nil> oops
10:48:39 <Rembane_> :D
10:48:46 <Rembane_> :t (<=<)
10:48:47 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
10:49:01 <TheCommieDuck> :t (>>=)
10:49:02 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:49:04 <Rembane_> TheCommieDuck: The left fish is good for composing functions that evaluate to monadic actions.
10:49:08 <TheCommieDuck> oh, I see
10:49:12 <Rembane_> Also! 
10:49:15 <Rembane_> :t (>=>)
10:49:16 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
10:49:47 <TheCommieDuck> yknow, I think I preferred my strategy of putting various lifts and >>= and >> everywhere until the code compiled.
10:50:08 <Rembane_> That is a very good strategy.
10:50:11 <Rembane_> Do you use hlint?
10:50:42 <TheCommieDuck> ...I just realised I have it enabled in vscode, but I never actually downloaded hlint.
10:51:04 <evelyn> hlint is opiniated but you might not agree with its opinions
10:51:35 <jle`> but it's tricky to get a good perspective on the value of those opinions until you have used haskell a lot
10:52:04 <jle`> so it's good as a guide when you're starting, to the point where you have the perspective to evaluate its opinions
10:52:15 <TheCommieDuck> whilst I'm here: how can I go StateT Foo IO (Maybe Bool) -> Maybe Bool? evalStateT then...something else?
10:52:29 <jle`> it is not possible
10:52:31 <jle`> im sorry
10:52:31 <TheCommieDuck> oh.
10:52:38 <jle`> other than returning a constant Maybe Bool
10:52:57 <jle`> using evalStateT you'll get an `IO (Maybe Bool)`
10:53:08 <jle`> which is an IO action that produces a Maybe Bool
10:53:24 <jle`> from there you can bind other IO actions to it, or fmap it, etc., to do whatever you want with it :)
10:53:36 <jle`> you could techically 'get' it
10:53:44 <jle`> myIoMaybeBool >>= \myMaybeBool -> ....
10:53:49 <TheCommieDuck> okay, I guess I just want some way of displaying a IO (Maybe Bool) :P
10:53:53 <jle`> and in the ..., you will have (myMaybeBool :: Maybe Bool)
10:54:00 <jle`> yeah, you can do something like
10:54:02 <Rembane_> TheCommieDuck: >>= print 
10:54:08 <TheCommieDuck> ...derp, yes, thank you
10:54:17 <jle`> mb <- evalStateT theStateTThing foo0
10:54:20 <jle`> print mb
10:54:41 <Rembane_> That's a better answer.
10:55:21 <jle`> it's not possible to StateT Foo IO (Maybe Bool) -> Maybe Bool, but it is possible to get the Maybe Bool and use it in a meaningful/useful way
10:55:34 <TheCommieDuck> yep, that's what I was actually after. Thanks.
10:55:49 <jle`> np :)
11:01:31 <benjwadams> :t unit
11:01:33 <lambdabot> error:
11:01:33 <lambdabot>     • Variable not in scope: unit
11:01:33 <lambdabot>     • Perhaps you meant one of these:
11:07:27 <sm[m]> jbweston: interesting use of markdown for pasting there. As a fellow matrix user, I saw it in riot, beautifully syntax-highlighted. Most IRC users only see * jbweston[m] sent a long message:  < URL >, as you may know
11:22:04 <jbweston[m]> <sm[m] "jbweston: interesting use of mar"> I did not know that.  Had I known that I would have pasted a shorter example and not used markdown-specific formatting
11:22:28 <jbweston[m]> > <@simonmic:matrix.org> jbweston: interesting use of markdown for pasting there. As a fellow matrix user, I saw it in riot, beautifully syntax-highlighted. Most IRC users only see * jbweston[m] sent a long message:  < URL >, as you may know
11:22:29 <jbweston[m]>  * I did not know that.  Had I known that I would have pasted a shorter example and not used markdown-specific formatting. Thank you for letting me know.
11:22:29 <lambdabot>  <hint>:1:1: error: parse error on input ‘<@’
11:23:42 <sm[m]> another tip: quoting a previous message creates noise on IRC, you probably want to avoid that (and sometimes riot does it when you didn't want it to)
11:24:38 <jbweston[m]> How do other people know to which message a reply pertains?
11:26:04 <sm[m]> usually they can tell by recent context. If you're replying to something that has scrolled far off screen, it's good to briefly mention who/what you're replying to
11:26:59 <jbweston[m]> Thanks for the pointers
11:27:18 <sm[m]> in a busy channel like this one especially. FYI here's the kind of long-message paste IRC users see: https://matrix.org/_matrix/media/r0/download/matrix.org/ThlwwRVYHwMmUbCzbsoJnTpD. It's as good as any other paste site I guess.
11:27:44 <monochrom> Yeah, use context and case-by-case judgment.
11:28:24 <sm[m]> finally if you really want to know you can check what IRCers see et at https://webchat.freenode.net/#haskell 
11:35:11 * hackage assoc 1.0.1 - swap and assoc: Symmetric and Semigroupy Bifunctors  https://hackage.haskell.org/package/assoc-1.0.1 (phadej)
11:53:41 * hackage hasbolt-extras 0.0.0.23 - Extras for hasbolt library  https://hackage.haskell.org/package/hasbolt-extras-0.0.0.23 (ozzzzz)
11:54:35 <benjwadams> :k Unit
11:54:36 <lambdabot> error:
11:54:36 <lambdabot>     Not in scope: type constructor or class ‘Unit’
11:54:36 <lambdabot>     Perhaps you meant ‘Uni’ (imported from Data.Fixed)
11:57:28 <koz_> :k ()
11:57:30 <lambdabot> *
12:10:41 * hackage megaparsec 8.0.0 - Monadic parser combinators  https://hackage.haskell.org/package/megaparsec-8.0.0 (mrkkrp)
12:24:11 * hackage hgrev 0.2.4 - Compile Mercurial (hg) version info into Haskell code  https://hackage.haskell.org/package/hgrev-0.2.4 (wraithm)
12:47:11 * hackage hspec-megaparsec 2.1.0 - Utility functions for testing Megaparsec parsers with Hspec  https://hackage.haskell.org/package/hspec-megaparsec-2.1.0 (mrkkrp)
12:50:45 <sm[m]> yay, megaparsec 8
12:51:24 <sm[m]> dropped support for ghc 8.2 ? bah
12:54:47 <sm[m]> and that's about it. I am underwhelmed. 
12:56:13 <Uniaika> yeah there's no killer feature
12:56:57 <Uniaika> but at the same time, it was due for a major upgrade since it dropped support for 8.2 and turned some class methods to simple functions
12:57:41 * hackage megaparsec-tests 8.0.0 - Test utilities and the test suite of Megaparsec  https://hackage.haskell.org/package/megaparsec-tests-8.0.0 (mrkkrp)
13:29:57 <EvanR> functor design pattern seems cool
13:44:02 <EvanR> i functor basically embeds one category in another
13:44:27 <EvanR> (though there is probably a more specific kind of functor property called embedding that in general is not satisfied)
14:06:48 <dsal> Is there a sensible way to fail an IO call from FFI?
14:07:12 <EvanR> return -1, set errno? :P
14:09:08 <dsal> I guess returning NULL would be similar.  I just want to call fail() and have magic happen.
14:09:33 <EvanR> exceptions in C
14:10:07 <EvanR> there's the longjmp thing
14:10:09 <dsal> I'll just call longjmp
14:10:22 <dsal> longjmp(rand()) or something.
14:10:27 <EvanR> should work
14:11:09 <EvanR> you could divide by zero, but then haskell crashes
14:11:12 <jle`> sm[m]: i hope one day it can support arbitrary tokens
14:11:18 <jle`> token streams
14:17:37 <MarcelineVQ> jle`: iirc there's a posted issue on their tracker that suggests that's not too likely
14:21:37 <MarcelineVQ> kind looks like there's been changes since then so I'm probably being misleading. there were at least no plans to have [a] as a token source
14:22:24 <dmwit> dsal: You can foreign export a failing IO action.
14:31:43 <dsal> dmwit: oh that's a neat idea
14:44:45 <maralorn> Is anyone here in favor of the ormolu way of not vertically aligning various syntax constructs to improve diff readability?
14:48:35 <MarcelineVQ> no idea :> Do you have an example of it?
14:49:15 <dmwit> maralorn: Yes, I use it and like it.
14:50:29 <nshepperd1> Is that something specific or just not bothering to align stuff
14:50:53 <sm[m]> Not vertically aligning things makes diffs more readable ?
14:52:51 <sm[m]> Reduces diff noise, yes I see that
14:52:56 <sm[m]> but makes a given version of the code less readable
14:58:35 <Axman6> Good diff tools let you turn off whitespace only changes in difs
14:58:39 <Axman6> diffs*
15:01:09 <MarcelineVQ> still want to know what this formatting method is. if this is just another convo about putting , in front of things and aligning them I'm going to pee
15:01:49 <Lycurgus> will you sit down to do that?
15:03:10 * Lycurgus savors the Frontline piece on AI
15:03:32 <sm[m]> MarcelineVQ: read the introductory blog post I guess
15:04:29 <MarcelineVQ> What blog is this?
15:06:05 <LysergicDreams> I haven't tried ormolu but elm-format does "more informative diffs" formatting and I enjoy it. I don't care about having my case arrows vertically aligned because I want the pattern and result on different lines anyways.
15:06:46 <shapr> I sure started a Haskell twitterstorm today, whew!
15:07:11 * hackage key-vault 0.1.0.0 - Store of values of arbitrary types  https://hackage.haskell.org/package/key-vault-0.1.0.0 (MatthewFarkasDyck)
15:09:09 <Cale> shapr: haha, I like the bit from Graham Hutton about his book
15:09:24 <shapr> yeah, that was really funny
15:10:42 <shapr> specifically this tweet: https://twitter.com/haskellhutt/status/1192535793421737987
15:11:21 <LysergicDreams> Welp after trying out ormolu's web-based formatter, I'm not a fan :/
15:19:51 <Zemyla> New monad law: join return == id
15:21:47 <Axman6> :t join return
15:21:48 <lambdabot> a -> a
15:22:17 <ChaiTRex> :t join return 3
15:22:19 <lambdabot> Num t => t
15:22:50 <Axman6> :t join `ap` return
15:22:52 <lambdabot> error:
15:22:52 <lambdabot>     • Occurs check: cannot construct the infinite type:
15:22:52 <lambdabot>         a ~ m a -> m a -> b
15:27:42 <pikajude> :t let ffix f = f (fmap (ffix f)) in ffix
15:27:44 <lambdabot> Functor f => ((f a -> f b) -> a -> b) -> a -> b
15:27:59 <pikajude> owo
15:30:34 <pikajude> :t let ffix f = f (fmap (flip $ ffix f)) in ffix
15:30:36 <lambdabot> Functor f => ((f b -> f (a -> c)) -> a -> b -> c) -> a -> b -> c
15:30:42 <pikajude> oh, that wasn't right
15:45:40 <[itchyjunk]> hmm
15:45:49 <[itchyjunk]> i was expecting to get error but i didnt get one
15:46:01 <[itchyjunk]> f f=f
15:46:12 <lyxia> haha
15:46:17 <[itchyjunk]> defining a function and setting the function to be itself
15:46:25 <[itchyjunk]> why did it not error out?
15:46:31 <[itchyjunk]> and what can i use this for?
15:46:50 <lyxia> that's equivalent to f x=x
15:47:02 <jackdk> the pattern variable is not the same as the function you are defining
15:47:08 <[itchyjunk]> ah the first f is a function but the second is a variable?
15:47:08 <jackdk> ... yeah, what lyxia  said
15:47:09 <[itchyjunk]> ah
15:47:25 <[itchyjunk]> so what happens when i call f ?
15:47:31 <[itchyjunk]> i guess i have to pass a value
15:47:50 <[itchyjunk]> ah it just spits it back out
15:47:51 <lyxia> it's giving an argument the same name as f, which means you can no longer refer to the function
15:48:02 <[itchyjunk]> i've invented print function \o/
15:48:04 <lyxia> but the argument and the function are still two very separate things
15:48:22 <[itchyjunk]> oh
15:48:30 <[itchyjunk]> when i do f 2, i spits back f though
15:48:36 <[itchyjunk]> am i not calling the function f?
15:48:46 <lyxia> > let f f = f in f 2
15:48:49 <lambdabot>  2
15:49:14 <[itchyjunk]> :o
15:49:21 <lyxia> you can no longer refer to the function in its body, but outside what is being defined is the function
15:49:46 <[itchyjunk]> so when i call f, i am calling the function
15:49:56 <lyxia> in f 2, yes
15:49:57 <[itchyjunk]> ah right
15:50:03 <[itchyjunk]> makes sense
15:50:18 <[itchyjunk]> i wanted to check if i can can a function inside a function
15:50:24 <[itchyjunk]> didn't know how to test that
15:50:57 <ChaiTRex> [itchyjunk]: If you can what?
15:51:11 <lyxia> > let f x = (x : f x) in f 42
15:51:12 <[itchyjunk]> recursively call functions
15:51:13 <lambdabot>  [42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,...
15:51:21 <[itchyjunk]> hmm how did you do that :s
15:51:27 <ChaiTRex> [itchyjunk]: Oh, sure, just use the function name on the right of the equal sign.
15:51:49 <[itchyjunk]> what does "let" do here?
15:52:16 <[itchyjunk]> hmmmmm i dont think i understand that code lol
15:52:22 <ChaiTRex> [itchyjunk]: It defines the variable 'f' for use only in the 'in' portion.
15:53:17 <[itchyjunk]> hmmmm
15:53:44 <ChaiTRex> [itchyjunk]: For example, let variable = 2 in 3 + variable. This defines 'variable' as '2' for use in the 'in' section.
15:54:02 <[itchyjunk]> ah okay i understand you example
15:54:17 <Zemyla> And where is basically let, but turned over and with different scoping rules?
15:54:49 <ChaiTRex> Zemyla: From what I understand, yep.
15:54:57 <Zemyla> Also, I don't think functions can be canned.
15:55:58 <[itchyjunk]> Hmm, what does canned mean?
15:56:10 <ChaiTRex> [itchyjunk]: I think that was a joke.
15:56:23 <[itchyjunk]> oh :<
15:56:29 <Zemyla> Yeah, you asked, "i wanted to check if i can can a function inside a function".
15:56:56 <maralorn> I have now repeatedly fallen about trying to use name shadowing to override a variable, like I often do in rust, whereas in Haskell this led me to unintentionally given the variable a recursive definition …
15:57:24 <maralorn> Like let a = 2 in do let a = a + 1.
15:57:43 <lyxia> yeah name shadowing in Haskell is dangerous.
15:57:55 <Zemyla> If you interpret "canning" as serializing, then there are languages that let you can functions, but Haskell isn't one of them.
15:59:02 <[itchyjunk]> okay another think i was contemplating was.. 
15:59:32 <[itchyjunk]> hmmm, what do i use to use as a matrix? should i be using nested lists?
15:59:37 <maralorn> What‘s the best workflow to find higher upper bounds for my dependencies?
16:00:17 <ChaiTRex> [itchyjunk]: If you're new to Haskell, sure.
16:00:43 <ChaiTRex> [itchyjunk]: There are faster things, but they're better to use when you get the basics of the language.
16:00:46 <[itchyjunk]> I'm new to programming in general :s
16:01:20 <ChaiTRex> [itchyjunk]: Ahh, OK. Yeah, nested lists are fine. They'll just be a bit slow, but probably not noticeably for messing around with and learning things.
16:02:06 <[itchyjunk]> i just wanted to figure out how to write a function that can take 2 2x2 matrices and add them :x
16:02:37 <[itchyjunk]> i shouldn't think of loops i suppose.. i need to think functionally
16:02:37 <ChaiTRex> [itchyjunk]: Ahh, OK. Yeah, that's a decent exercise.
16:05:18 <kamatsu> @free fmap
16:05:20 <lambdabot> Extra stuff at end of line in retrieved type "Functor f => (a -> b) -> f a -> f b"
16:05:26 <kamatsu> @free map
16:05:28 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
16:06:27 <kamatsu> @free a->a
16:06:27 <lambdabot> Extra stuff at end of line
16:06:32 <kamatsu> @free a -> a
16:06:32 <lambdabot> Extra stuff at end of line
16:06:47 <kamatsu> @free head
16:06:48 <lambdabot> f . head = head . $map f
16:06:57 <[itchyjunk]> maybe it wants you to use paid functions!
16:08:39 <Zemyla> @free uncons
16:08:41 <lambdabot> $map_Maybe ($map_Pair f ($map f)) . uncons = uncons . $map f
16:08:42 <lyxia> The price of free theorems.
16:09:05 <Zemyla> @free zipWith
16:09:07 <lambdabot> (forall x. h . k x = p (f x) . g) => $map h . zipWith k xs = zipWith p ($map f xs) . $map g
16:11:05 <Zemyla> Wouldn't zipWith p . map f = zipWith (p . f)?
16:11:26 <Zemyla> @free Left
16:11:27 <lambdabot> Try `free <ident>` or `free <ident> :: <type>`
16:11:43 <Zemyla> @free left :: a -> Either a b
16:11:43 <lambdabot> $map_Either f g . left = left . f
16:11:46 <dsal> I don't quite understand Data.Proxy.  When do I need a Proxy?
16:12:28 <ChaiTRex> dsal: I think it's just for having phantom types or something like that.
16:12:42 <dsal> Oh, says here in the docs:    Historically, Proxy :: Proxy a is a safer alternative to the 'undefined :: a' idiom.
16:12:50 <dsal> But the "Historically" qualifier is suspicious.
16:13:49 <lyxia> that's indeed suspicious. It's also not only safer, it's more general because `a` doesn't have to be a type. It could be a number or a symbol.
16:14:56 <lyxia> Zemyla: yours is less general since it's missing the map on the second argument
16:17:07 <dsal> lyxia: number or symbol?  You mean in the DataKinds sense?
16:23:03 <lyxia> yes
16:25:52 <[itchyjunk]> list are homogenous i.e only one type can be stored. but what about list of lists? can i have [[1..10],[a],1,b]?
16:26:34 <dsal> List is  [a]   What is the a in your example?
16:27:44 <[itchyjunk]> :s character
16:28:02 <[itchyjunk]> i should have written it as 
16:28:17 <[itchyjunk]> ['a'] and 'b' 
16:28:30 <dsal> :t ['a']
16:28:31 <dsal> :t 'b'
16:28:31 <lambdabot> [Char]
16:28:32 <lambdabot> Char
16:28:58 <dsal> I meant 'a' as in the type variable.
16:29:19 <lyxia> in a list of lists the lists must still be of the same type
16:29:20 <dsal> A list is   [a]    It contains one type, as you said.  What is the type in your example list?
16:29:53 <[itchyjunk]> [[1..10],['a'],2]
16:30:00 <[itchyjunk]> is this a valid list of lists?
16:30:07 <dsal> It's not even an invalid list of lists.
16:30:11 <[itchyjunk]> the outer list contains 2 lists and a number
16:30:47 <dsal> So, given that a list has a type, what is the type of your list  there?
16:30:51 <[itchyjunk]> what about [[1..10],['a']] ?
16:31:00 <dsal> Again, what would the type of that be?
16:31:09 <dsal> :t [1..10]
16:31:10 <lambdabot> (Num a, Enum a) => [a]
16:31:24 <dsal> :t [[1..10]]
16:31:26 <lambdabot> (Num a, Enum a) => [[a]]
16:31:35 <Cale> It would have to be [[Char]], but then you'll need an instance of Num for Char for that to make sense.
16:31:53 <Cale> (There isn't one, usually)
16:32:15 <dsal> Making Num instances of arbitrary things is a fun parlor trick.
16:32:46 <dmj`> deriving newtype Num
16:32:50 * dmj` pulls rabbit out of hat
16:32:54 <ChaiTRex> [itchyjunk]: As you said, lists contain the same type throughout. That means that nested lists can anly contain the same type throughout, since they're also lists.
16:32:56 <dsal> [itchyjunk]: Part of your confusion, I think  is thinking of "list" as a type.
16:33:26 <dsal> It's more like half a type, since it's Type -> Type
16:33:50 <dsal> % :k []
16:33:50 <yahb> dsal: [] :: * -> *
16:33:56 <dsal> % :k [1]
16:33:56 <yahb> dsal: ; <interactive>:1:2: error:; * Expected a type, but `1' has kind `Nat'; * In the type `[1]'
16:34:06 <ChaiTRex> [itchyjunk]: The type of element in a nested list is a list of a particular type, and it has to be the same throughout, like [Int] or [Char]. No mixing types or the nested list wouldn't contain the same type throughout.
16:34:11 <[itchyjunk]> but then [[1..10],2,3] contain the type int?
16:34:26 <[itchyjunk]> oh
16:34:30 <dsal> The head of that list is not an int.
16:34:42 <Cale> [itchyjunk]: In order for that expression to make sense, you need a way to interpret 2 as a list of integers
16:34:43 <ChaiTRex> [itchyjunk]: Yes, but one element is [Int], and the others are Int. As you said, the outer list needs the same type, but you have two different types.
16:34:57 <Cale> :t [[1..10],2,3]
16:34:59 <lambdabot> (Enum a, Num a, Num [a]) => [[a]]
16:35:17 <Cale> The Num [a] is unlikely to be satisfied there
16:35:29 <Cale> Usually there isn't a Num instance for lists.
16:35:40 <Cale> If it's not clear, all the elements of a list must have the same type
16:35:43 <dsal> Integers are really just lists of bits.
16:36:44 <Cale> (This restriction makes good sense, because otherwise, why would you put the things in a list? They must have something in common, you might as well explain what that is by inventing some type for them to all share/)
16:37:09 <dsal> That constraint looks really weird.  Num a and Num [a]
16:39:32 <dmj`> phadej: ping
16:40:11 <Cale> There are some sensible instances of Num for [a] you could conceivably imagine. For example, the interpretation as polynomials/power series
16:41:23 <Cale> (i.e. lists of coefficients)
16:42:07 <dsal> I don't know a lot of number theory.  Just seems weird to have both a and [a].  I'm sure I could implement it without understanding why, though. heh.
16:43:53 <Cale> I mean, for instance, [3,2,1] would represent the polynomial 3 + 2*x + 1*x^2
16:44:06 <Cale> and you'd just define addition and multiplication to make that work out
16:44:47 <dsal> And then 1 would just mean 1?
16:45:10 <Cale> 1 would be [1]
16:45:17 <dsal> Yes, right.
16:45:22 <dsal> That's pretty neat.
16:47:27 <[itchyjunk]> aren't all number sequences technically in dedekinds cuts?
16:47:31 <[itchyjunk]> so maybe 2 is a list!
16:53:46 <wikiemol> Hello, new to haskell here. I was wondering, is there a notion of "Isomorphism" in haskell? 
16:54:03 <boj> there is indeed
16:54:42 <wikiemol> Oh! Is it a type class? 
16:55:43 <dsal> I've not seen such a thing.  What are you hoping to achieve?
16:56:08 <wikiemol> Not really hoping to achieve anything, I was just curious 
16:56:26 <boj> there is an Iso type in the lens library, although if you are new that may be a bit much
16:56:49 <wikiemol> Well, I am familiar with category theory already
16:56:57 <wikiemol> I am new to Haskell as a language though
16:57:16 <boj> still, the concept of isomorphisms exist.  data F = MkF A B is isomorphic to (A, B) for example
16:59:29 <lyxia> outside of any context it's a pretty broad word though
16:59:36 <wikiemol> Well, I was more hoping for an isomorphism between categories. Like two Functors which are inverses of eachother
17:00:12 <dsal> Is that a contravariant functor?
17:00:27 <dsal> https://hackage.haskell.org/package/contravariant-1.4/docs/Data-Functor-Contravariant.html
17:00:32 <Cale> dsal: no...
17:00:41 <monochrom> Most of the time people just mean "bijection".  Change my mind.
17:01:06 <wikiemol> monochrom: I can't change your mind haha its honestly true
17:01:41 <Cale> wikiemol: There aren't many great examples of isomorphisms of categories that are witnessed in practical Haskell code
17:02:05 <monochrom> OK let me up the game.  This shows that haskellers throw around buzzwords as much as java people.  Change my mind.
17:02:31 <shachaf> This shows that Haskell is isomorphic to Java.
17:02:38 <monochrom> haha
17:02:44 <boj> to be fair, someone new to haskell was asking how to apply a buzzword to haskell
17:03:00 <boj> or in their mind, a concrete concept
17:03:07 <Cale> The usual Functor class is only for endofunctors on the category of Haskell types, but there are libraries out there which let you work with a bit more than that.
17:03:26 <TheCommieDuck> quick question: so am I right in thinking that State is not actually a container of state, but actually a way to do a computation on a state?
17:03:48 <Cale> http://hackage.haskell.org/package/categories-1.0.7/docs/Control-Categorical-Functor.html
17:03:53 <TheCommieDuck> i.e. if I want the behaviour of "give it state 0, get out result and state 1" I want a State s a, not a s -> State s a.
17:03:59 <wikiemol> Cale Is that this lens library I keep hearing about?
17:04:00 <monochrom> Yes. But there are ways to rethink computation as container, and vice versa.
17:04:09 <Cale> No, it's another library
17:04:14 <Cale> (called categories)
17:04:16 <TheCommieDuck> suddenly, everything makes so much more sense.
17:04:27 <Cale> same maintainer though :)
17:04:31 <nshepperd> an endofunctor on a category of buzzwords...
17:04:38 <TheCommieDuck> I was wrapping my do block in a lambda and struggling to feed things in or get things out.
17:04:41 <maralorn> I have never realeased a package on hackage. Does anyone care to look at my release candidate to see if I did anything obviously wrong? https://hackage.haskell.org/package/taskwarrior-0.1.0.0/candidate
17:04:58 <monochrom> Simplest example being "Bool -> X" sounds like "function, so computation" until you see how it's the same as an array of two X's.
17:05:19 <TheCommieDuck> the computation is just very simple, "is it true" :P
17:05:38 <monochrom> No, Bool is on the left not on the right.
17:05:39 <wikiemol> Cale: Thats interesting, I might check that out. I find the Prelude Functor confusing because it is far more strict than a real Functor
17:05:44 <TheCommieDuck> "is the
17:06:08 <shachaf> The only thing restricted is the domain and codomain.
17:06:23 <TheCommieDuck> Bool -> X is given by f(T) -> x, f(F) -> y. seems like a computation of "is the value given to me true"
17:06:31 <TheCommieDuck> even if yes, it is just [x, y]
17:06:42 <monochrom> So let's up the game.  State Bool X = Bool -> (X, Bool) so it's an array of two (X, Bool)s.
17:07:14 <lyxia> maralorn: maybe add a minimal executable example, but otherwise it LGTM
17:07:20 <monochrom> Also "Int -> X" is now just a very large array.
17:07:35 <TheCommieDuck> Yes, I think I somehow got lost in the typery that I overlooked state is x -> (x, y)
17:07:40 <TheCommieDuck> not just the (x, y)
17:08:09 <monochrom> Probably too large to fit in memory but you happen to know a short formula so you code it up as a function but math doesn't care it's conceptually an array.
17:08:19 <wikiemol> Cale: I also find it interesting that there aren't many examples of it in practical Haskell. But now that I think about it, I think monochrom is spot on, really, the examples that come to mind are I am more thinking about bijections.  I would think there would be a lot of examples of
17:08:35 <wikiemol> Wow that last message got garbled to all hell
17:08:58 <monochrom> Oh it just got truncated after "I would think there would be a lot of examples of".
17:09:32 <TheCommieDuck> there's so many examples it couldn't fit in your message
17:09:49 <lyxia> if two things are isomorphic often that means you don't need to keep both around
17:10:43 <wikiemol> lyxia That actually makes perfect sense.
17:10:56 <monochrom> The other buzzword haskellers throw around without reflecting why is "thunk".
17:11:11 <wikiemol> Have no idea what that one means
17:11:27 <boj> monochrom the critic
17:12:34 <kamatsu> @free filter
17:12:36 <lambdabot> $map f . filter (g . f) = filter g . $map f
17:12:45 <gnustomp> hi kamatsu 
17:12:48 <monochrom> Most people have wrong ideas about what "thunk" means. You are already better than them.
17:13:00 <kamatsu> hi gnustomp
17:13:07 <kamatsu> @free head
17:13:08 <lambdabot> f . head = head . $map f
17:13:13 <kamatsu> @free (++)
17:13:13 <lambdabot> Try `free <ident>` or `free <ident> :: <type>`
17:13:16 <kamatsu> @free ++
17:13:16 <lambdabot> Try `free <ident>` or `free <ident> :: <type>`
17:13:31 <kamatsu> @free append :: [a] -> [a] -> [a]
17:13:31 <lambdabot> $map f . append xs = append ($map f xs) . $map f
17:15:03 <wikiemol> monochrom What is it? 
17:15:29 <monochrom> Low-level representation of an unevaluated expression.
17:15:32 <maralorn> lyxia: Thanks! I added an example.
17:15:47 <dsal> monochrom: what do people think it is?
17:16:00 <monochrom> thunk : unevaluated expression :: capacitors : memory
17:16:17 <lyxia> maralorn: :)    main :: IO ()
17:16:30 <dmwit> monochrom: Do you think "most people mean 'bijection' when they say 'isomorphism'" is a bad thing?
17:16:35 <maralorn> ^^
17:16:50 <maralorn> I was wondering about how to test the code in my README …
17:17:31 <dsal> I'm using literate Haskell in markdown at work. I compile my docs.
17:18:03 <monochrom> dsal: Most people heard GHC devs say "thunk" and just parrot it without having actually studied how, for example, GHC does it. (I have.)
17:18:26 <monochrom> So let's just say they fantasize that they know.
17:18:31 <monochrom> dmwit: Yes.
17:18:38 <dmwit> Why?
17:19:03 <monochrom> isomorphism : bijection :: strategic synergy partnership : signed a contract
17:19:38 * dmwit wrinkles his brow
17:19:42 <monochrom>  :: glorified pencil : pencil
17:20:16 <boj> curious, what is an example of someone misunderstanding "thunk"?
17:20:34 <monochrom> I am talking about how the ignorant people use "isomorphism", not how the mathematicians in the know use "isomorphism".
17:20:35 <wikiemol> monochrome: What is the best resource to learn about that stuff? I am really interested in how haskell works under the hood
17:21:22 <dsal> wikiemol: I'd recommend years of practice and study.
17:21:23 <monochrom> https://github.com/takenobu-hs/haskell-ghc-illustrated
17:21:38 <wikiemol> boj: "Damn girl, you dummy thunk"
17:23:21 <boj> i suppose that is the best answer i will get today
17:24:02 <monochrom> boj: An example may be when someone's code use more memory than they thought and they knee-jerkly attribute it to "laziness accumulating thunks" but it turns out their real mistake is keeping too much evaluated data live
17:25:00 <boj> monochrom: hmm, i thought you meant what the term defines, not a use case
17:26:11 <monochrom> I have always meant buzzwords, so I have always meant a, you know what, legitimate well-defined word that people misues to parrot and glorify their language.
17:26:41 * hackage taskwarrior 0.1.0.0 - Types and aeson instances for taskwarrior tasks  https://hackage.haskell.org/package/taskwarrior-0.1.0.0 (maralorn)
17:27:33 <boj> i am just an industry programmer, so when someone says "isomorphic" i don't have any fancy mathematical notion of what it means, just that "these two things are the same". the idea that people actually mean "bijection" would never occur to me
17:27:59 <monochrom> Well that's even worse.  Why not use "the same"?
17:28:02 <boj> seems natural to use the term in this community
17:29:15 <boj> "we use math terms becasue they are precise!"
17:29:31 <Cale> Equality is a subtle concept. What does it mean for two things which we've already distinguished to be "the same"? Various types of isomorphism are one way of trying to capture this.
17:29:31 <boj> "oh wait, but not that one. you mean the more plebian version"
17:29:41 <nshepperd> using "the same" would be wrong
17:30:17 <Cale> I'm not sure about going that far. "The same" isn't really a technical term.
17:30:51 <monochrom> I'm OK with using "isomorphism" if you can answer me when I ask "in which category?"
17:31:14 <monochrom> Hell, I have to accept that.  Mathematicians use it correctly all the time.
17:31:55 <monochrom> They can tell me "I mean group isomorphism" or even "this is a group theory textbook, what do you think, are you stupid?"
17:32:06 <monochrom> But industry programmers?  Hahahaha don't kid me.
17:32:19 <aniston> isn't it more accurate to say "up to isomorphism"?
17:32:44 <maralorn> Talking about equality I am a bit unsatisfied with the Monoid law "x <> mempty = x" not requiring "Eq a => Monoid a".
17:33:20 <monochrom> Probably don't even realize that in our context it's some version of "Hask" and in which it's either "computable bijection" or "continuous bijection" take your pick.
17:33:33 <ion> The law doesn't say ==, it says =
17:33:55 <maralorn> ion: I know. But is that welldefined in Haskell?
17:34:01 <monochrom> Yeah maralorn that one is mathematical equality not Haskell you-coded-it-up ==
17:34:11 <nshepperd> isn't computable the same as continous
17:34:13 <boj> monochrom: so basically it is incorrect for me to answer someone who asks what an example of an isomorphism is in haskell, a language they don't know, by replying with an example using that term. got it
17:34:41 <monochrom> No! Continuous is broader. But Dana Scott or someone found that continuous is nicer to work with.
17:34:56 <ion> The law is more about human reasoning than language-level definitions, I suppose.
17:35:03 <nshepperd> broader how
17:35:21 <nshepperd> is it to do with 'unamb'
17:37:22 <dmwit> maralorn: I guess = there is probably alpha-beta-eta-delta equality.
17:37:26 <dmwit> Pretty well-defined, yes.
17:38:09 * dmwit wonders whether monochrom would consider him an "industry programmer" or not
17:38:18 * dmwit ponders whether he considers himself an "industry programmer"
17:38:31 <monochrom> I don't know whether unamb does it.  But I think if pressed I may be able to define a continuous function based on the halting problem.
17:38:59 <dmwit> unamb plays tricky tricks with the halting problem, yes.
17:39:38 <shachaf> I wonder what specifically people mean by saying continuous is broader, in what context.
17:40:08 <dmwit> unamb _|_ _|_ = _|_; unamb _|_ x = x; unamb x _|_ = x; unamb x y = x (caller is responsible for guaranteeing x = y)
17:40:09 <shachaf> There's certainly no topology (in the usual sense) on N where the open sets are the recursively enumerable ones.
17:41:13 <monochrom> CPO's version of continuous.  Preserves suprema of ascending chains.
17:41:42 <monochrom> Or preserves directed joins if you like.
17:42:04 <shachaf> I guess it means continuous in the Scott topology.
17:44:21 <dolio> Recursively enumerable subsets of the naturals is probably the topology of Σ^ℕ or something.
17:45:20 <dolio> In ASD.
17:45:41 <shachaf> What is Σ^ℕ?
17:46:16 <dolio> Σ is the Sierpinski space.
17:46:29 <dolio> ^ is exponential.
17:46:55 <nshepperd> i don't think i can see anyone writing a noncomputable function in haskell
17:47:01 <shachaf> Exponential in what category?
17:47:14 <shachaf> Or what's the topology on ℕ?
17:47:31 <dolio> Whatever category of topological spaces is used for the semantics of Abstract Stone Duality.
17:47:34 <nshepperd> since whatever program you write, it computes some function, even if that function is const ⊥
17:48:27 <monochrom> I did not contradict that.
17:48:51 <nshepperd> on the other hand, I would believe that you can write a noncontinuous function. such as by using exception-catching escape hatches
17:49:07 <monochrom> I did not imply that.
17:49:08 <dolio> The points of Σ^ℕ would be like the semi-decidable predicates on ℕ, I think.
17:49:37 <dolio> I'm not an expert, though.
17:49:43 <shachaf> dolio: One time I asked Andrej Bauer a question like this and he said something something about the effective topos, I think.
17:49:58 <dolio> Yeah, there's also that.
17:50:17 <dolio> There you'd write it Ω^ℕ.
17:50:19 <monochrom> "Here Be Madness"
17:50:24 <shachaf> But I don't know what this thing is.
17:50:50 <shachaf> I should figure out all the ASD business.
17:51:34 <shachaf> What topology would ℕ get here?
17:51:35 <dolio> ASD is pretty cool, although it's more of a computational topology thing than a topological computing thing.
17:51:43 <dolio> ℕ is just discrete, I think.
17:52:12 <shachaf> Then everything I want to know is hidden in ^, or something?
17:52:48 <dolio> I don't know. Maybe it's hidden in Σ.
17:53:09 <dolio> Σ is like the space of semi-decisions.
17:53:44 <shachaf> I vaguely feel like the effective topos thing makes ℕ "computably discrete", i.e. singleton sets are open, and you have computable unions rather than arbitrary unions.
17:54:46 <dolio> I don't know. The explanation I've seen of the effective topos isn't directly topological.
17:56:33 <dolio> I think there is't kind of related to Ω, too.
17:59:41 <dolio> ℕ is discrete, 2 is discrete, Ω is not discrete, it lets you say 'yes' or diverge (maybe you can say no, too; not sure). Computable maps into 2 are decisions, and maps into Ω are semi-decisions.
18:00:30 <sim590> I have this code https://paste.debian.net/1115196/ where I'm trying to return the the `j+1` bits of an integer from the `i`-th one with leading zeroes on a 64 bit integer. The code worked partially before I go from returning Int to Maybe Int. Now, when calling the function, it stalls. Why ? 
18:00:51 <dolio> And in the effective topos I think there is basically no difference between Hom(A,B) and B^A.
18:00:58 <sim590> I clearly just see `Just` in the output with the cursor flashing and nothing happening more. I guess it was looping somewhere.
18:01:16 <monochrom> Oh, is Ω two elements, bottom and unit?
18:01:26 <shachaf> In standard topology, talking about maps into the Sierpinski space is no different from talking about open sets, of course.
18:02:12 <shachaf> I guess something like that isn't true here?
18:02:41 <topos> lordie it's that time of day again
18:02:53 <monochrom> haha
18:02:54 <dolio> Well, 'open sets' is already wrong, I think, because it's probably using locales.
18:03:10 <sim590> Nvm. I must have changed something else. I've just removed the Maybe code and it stalls too.
18:03:23 <wikiemol> Okay, so this is entirely unrelated to the question I had before, but considering this expression `(<*>) . fmap (+) $ Just 1`  types to `Num b => Maybe b -> Maybe b` and considering that `(*>)` types to `Applicative f => f a -> f b -> f b` I would think `(*>) $ (<*>) . fmap (+) $ Just 1` would type to something like  `Maybe b` but it doesn't, it
18:03:23 <wikiemol> types to `Num b1 => (Maybe b1 -> b2) -> Maybe b1 -> b2`, what is going on here?
18:03:39 <dolio> ASD would be, that is.
18:04:14 <dolio> I guess so would the effective topos if you wanted to talk about its topology.
18:05:48 <dolio> I don't really have a thorough understanding of all this, though.
18:06:21 <monochrom> topos: Hey "isomorphism" is not taken, maybe you should try that >:)
18:06:42 <topos> I'd rather take the word "the". That sounds nice :)
18:07:51 <dolio> ASD is all about point-set topology being all wrong, though, and trying to make topology computable, I think.
18:08:11 <jusss> which sql  yesod would work with?
18:08:22 <wikiemol> Nvm I figured out the answer to my own question
18:09:23 <wikiemol> I was previously confused as to why it didn't work, but now I am confused as to why it worked xD
18:09:23 <monochrom> What is ASD?  (I Googled, I tried all of "ASD", "ASD math", "ASD topology". They all brought up autism.)
18:09:46 <Axman6> Not the Australian Signals Directorate?
18:10:37 <dolio> shachaf: I guess it's probably this: locale theory doesn't say anything about the joins you're allowed. You can do arbitrary joins. But how are you going to write down an uncomputable formula for one?
18:10:44 <monochrom> Also I secretly hope that ASD functions are called ASDF.
18:10:46 <dolio> monochrom: Abstract Stone Duality.
18:10:51 <monochrom> Oh! That.
18:12:06 <shachaf> dolio: With locales you still have opens, though, even if they're not sets.
18:12:46 <dolio> I guess that argument is more specifically for the effective topos, though, because there the exponentials are still computable, and not all similar stuff behaves that way.
18:13:11 <dolio> I.E. the arrows may all be computable, but the 'values' of the exponentials may not be.
18:13:33 <topos> who wants to read johnstone's stone spaces
18:13:35 <topos> lass do eet
18:15:33 <dolio> Ω^ℕ might be wrong, too. Maybe it's just ℕ implicitly has computable joins, because there's no such thing as uncomputable stuff.
18:28:37 <jusss> Persistent from Yesod, what it is? it's not a database, but connect to database?
18:28:58 <jusss> a deliver?
18:29:32 <Axman6> Persistent is for accessing databases and defining the Haskell types which map to the tables in the database
18:30:00 <jusss> Persistent is a stand-alone package?
18:30:14 <Axman6> yes
18:30:14 <jusss> or combind to Yesod?
18:30:18 <TheCommieDuck> final question before I go to bed (thanks all!): I've got 3 lists of StateT Foo IO (Maybe Bool); basically 'first', 'middle', 'last'. I want to go down a list as long as I keep getting Nothing, and stop on a Just, keeping passing state through. if I finish on one list, I start on the next, etc. I've got a nice solution for doing each list, but it's a triangle of doom for doing all 3 lists.  
18:30:30 <TheCommieDuck> would I need to write my own sort of reverse-Maybe monad?
18:31:00 <LysergicDreams> jusss: You can use persistent by itself
18:31:11 <jusss> LysergicDreams: ok
18:31:14 <dolio> shachaf: "However, it is much stronger than saying that "every point" of K is in U, as there are not enough computably representable points for this to be a valid mode of reasoning." From the ASD page.
18:31:27 <dolio> About ∀ : Σ^K → Σ.
18:31:32 <LysergicDreams> I've used it in scripts, CLI apps, w/ other web frameworks, etc.
18:32:41 <dolio> So, despite unions being 'arbitrary,' he seems to consider that you are still limited by your ability to computably specify the arbitrary things.
18:33:45 <LysergicDreams> jusss: Pretty sure the same applies to the HTML/CSS/JS DSLs as well.
18:35:11 <dolio> shachaf: Oh! "Its strongest relationship is to recursive enumerability in recursion theory, and it legitimises the idea that the topology of N consists of the RE subsets."
18:35:24 <dolio> So that's the answer. :)
18:37:48 <shachaf> But that's not the standard topology, certainly.
18:38:02 <shachaf> What is "it"?
18:38:15 <shachaf> I guess I can read the page.
18:38:39 <shachaf> Oh, "it" is overtness?
18:38:44 <shachaf> If only I understood overtness.
18:40:19 <dolio> Well, as I said, ASD doesn't care what the 'standard' is. He's doing better than the standard. :)
18:42:34 <shachaf> So what's overtness?
18:42:43 <shachaf> While you're at it, what's compactness?
18:43:01 <shachaf> In particular what's the computational content of compactness?
18:47:03 <dolio> Compactness lets you universally quantify over a space in predicates. So if φ : Σ^K is a semi-decidable on K, then ∀k. φ(k) is semi-decidable.
18:47:06 <dolio> I think.
18:47:26 <dolio> And overtness is the same for ∃.
18:49:53 <shachaf> I guess I should ask a different question.
18:50:45 <shachaf> You can do the "seemingly impossible" thing for any compact space, right?
18:51:32 <shachaf> What's the type class that lets you do it?
18:52:47 <dolio> I wonder if the 'seemingly impossible' thing is related to the 'definition by description' in ASD.
18:53:05 <dolio> Those two things might be slightly different, though.
18:53:42 <dolio> The impossible stuff is about total functions, and ASD uses a lot more partial functions.
18:54:03 <dolio> And I'm not sure you can even take the exponential with base 2 there.
18:54:12 <dolio> Not all exponentials exist.
18:55:12 <dolio> The only ones I know for a fact exist are the ones that can be written with base Σ.
18:57:40 <shachaf> https://www.cs.bham.ac.uk/~mhe/.talks/popl2012/escardo-popl2012.pdf says that you can do the thing for function spaces where the domain is compact and the codomain is discrete.
18:58:19 <shachaf> I guess "doing the thing" means that the function space is also discrete.
18:58:31 <shachaf> And discreteness means decidable equality?
19:01:35 <dolio> Yeah, I think the relation of the above description of 'compact' back to the more usual one is that even though K is infinite, you can somehow reduce your work down to a finite amount.
19:01:52 <dolio> Which is somehow related to the finite subcover property.
19:02:41 * hackage perf 0.5.0.0 - Low-level run time measurement.  https://hackage.haskell.org/package/perf-0.5.0.0 (tonyday567)
19:02:52 <dolio> So, in ASD, ∀ is fine for predicates on compact spaces because you only need to do a finite amount of semi-deciding, and for the 'seemingly impossible' stuff you only need to do a finite amount of deciding, or something.
19:02:52 <shachaf> Something like that makes sense to me but I don't have the details.
19:03:25 <shachaf> Can you concretely write exists :: Compact a => (a -> Bool) -> Bool which a total predicate and tells you whether anything satisfies it?
19:04:11 * hackage perf-analysis 0.2.0.0 - analysis example using perf  https://hackage.haskell.org/package/perf-analysis-0.2.0.0 (tonyday567)
19:06:19 <dolio> That's not what the seemingly impossible things do.
19:06:30 <dolio> They do (a -> Bool) -> a
19:07:15 <shachaf> Well, they do both.
19:07:25 <dolio> Oh, I guess you can get the Bool one from that.
19:07:35 <shachaf> I guess your thing is more useful if you don't have a way to search the space.
19:08:18 <dolio> I think `exists` is the method of `Compact`. :)
19:08:39 <dolio> Or `search`.
19:11:48 <shachaf> Hmm.
19:12:36 <shachaf> How does it relate to the usual definition?
19:17:28 <dolio> In those slides he's talking about deciding equality. f = g <=> ∀ k. f k = g k.
19:18:05 <dolio> The codomain being discrete lets you decide point-wise, and compactness lets you do the universal quantifier.
19:20:23 <shachaf> What does the universal quantifier end up being?
19:22:45 <dolio> What do you mean?
19:23:39 <dolio> It exhaustively searches the space.
19:26:36 <dolio> I think it's a little confusing to look at the decidable case, because ∀ and ∃ look the same there.
19:27:24 <dolio> Because you can flip the decision by negating the predicate.
19:35:00 <jusss> “ Cannot decode byte '\xed': Data.Text.Internal.Encoding.decodeUtf8: Invalid UTF-8 stream”
19:37:10 <jusss> where I can find this decodeUtf8 definition?
19:38:01 <jusss> https://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text-Encoding.html
19:38:09 <jusss> decodeUtf8 :: ByteString -> Text
19:38:29 <jusss> decodeUtf8' :: ByteString -> Either UnicodeException Text
19:40:15 <jusss> why it's not Either Text Text?
19:44:16 <Axman6> because it's nearly impossible to do anything with text error messages programatically
19:49:14 <koz_> Imagine if you get 'Left "this failed lol"'.
19:49:28 <koz_> (and yes, I have received error message of equal unhelpfulness)
19:50:36 <dmwit> I have written error messages of equal unhelpfulness.
19:50:45 * dmwit crosses fingers that none of them made it to Hackage
19:51:39 <MarcelineVQ> some of them are in base (IO execptions :()
19:53:10 <monochrom> I have used String for error messages in lectures, and switched to a dead simple ADT (there are only two cases VarNotFound and TypeError) in assignments.  This turned out to be a good test against clueless students (they continued to use String, so type error when compiled against my support files).
19:53:14 <flebron> Hi :) Is there a shorter (golfing) version of f.(g>=>h)?
19:54:34 <MarcelineVQ> What is the real f's type?
19:54:48 <flebron> read :: String -> Int
19:57:57 <flebron> g is init.chunksOf 5, and h is show.l, for some horrible function l :) (chunksOf 5 lives in Data.List.Split)
20:11:11 <glguy> That's probably as opaque as it will get
20:12:46 <quiet_laika[m]> anyone tried out the `eff` library yet? i'm having trouble writing a trivial `local` implementation in an effect that just delegates to `Reader`
20:17:21 <quiet_laika[m]> https://gist.github.com/matthewess/21f73b6bacc2dd9b776ddba5bf0825ad
20:17:31 <quiet_laika[m]> gist has a minimal example and the typeerror
20:19:53 <quiet_laika[m]> i imagine it's something straightforward having to do with the fact that `local` takes an `m a` and i'm not responding to that properly, but it's not immediately obvious to me what the "right way" is...
20:20:34 <shachaf> dolio: What's the general case?
20:21:53 <dolio> For semi-decisions you can't just negate the predicate.
20:22:20 <dolio> And ASD uses semi-decisions.
20:22:58 <quiet_laika[m]> oo, looks like `runHandlerT` is what i was looking for
20:23:04 <quiet_laika[m]> typed holes ++
20:23:19 <shachaf> Also, what do you get when you do topology with linear logic instead, as in http://home.sandiego.edu/~shulman/papers/lcm-bloomington-talk.pdf ?
20:23:36 <shachaf> Will that make everything seem much more natural?
20:25:42 <dolio> More natural than what?
20:26:22 <shachaf> The usual constructive thing.
20:26:54 <dolio> Why are we talking about that when I brought up ASD?
20:27:46 <shachaf> I don't know, I was just curious about it unrelated to anything said before.
20:28:06 <shachaf> Also I don't really understand ASD.
20:28:43 <dolio> Well, the usual constructive thing isn't very topological.
20:29:07 <dolio> It's more like sets.
20:30:40 <dolio> But maybe it depends what exactly is being talked about.
20:32:09 <dolio> Like, if you want to do the same thing Paul Taylor was saying, you wouldn't end up with RE subsets of ℕ being the opens.
20:32:20 <dolio> I think.
20:48:27 <dolio> I guess really the difference is he's careful about what sort of quantifiers are allowed.
20:48:50 <dolio> The usual constructive thing just gives you quantifiers over everything by fiat.
20:49:34 <evocatus> @pl (\x -> f x /= y)
20:49:34 <lambdabot> (y /=) . f
20:49:46 <dolio> Which lets you define uncomputable subsets of the naturals, for instance.
20:53:28 <dolio> In HoTT, quantifiers are continuous in some sense, too, but it doesn't match semi-decidability.
21:19:25 <evocatus> for circular data structures, is it true that the derived instance of Eq will not terminate?
21:19:38 <Lysergic1reams> When making an application, do people usually limit the library's exposed modules? I've been limiting them to only modules that are used in tests & executables, but I'd really like to be able to generate docs for everything.
21:20:38 <c_wraith> evocatus: sort of.  Identical infinite structures are hard to tell are the same, but sometimes easy to tell are different
21:23:09 <dsal> evocatus: They don't have to be circular.
21:23:17 <dsal> > [0..] == [0..]
21:23:22 <evocatus> c_wraith: ok, I see.. I think I have another approach to my problem.
21:23:23 <lambdabot>  mueval-core: Time limit exceeded
21:23:41 <evocatus> dsal:I am writing a red/black tree implementation with references from child/parent and parent/child
21:23:49 <evocatus> in this particular case it is circular
21:24:11 <evocatus> ah, but I see your point - it's not just circular data structures that are non termintaing
21:24:31 <opqdonut> usually with persistent tree structures you don't need parent pointers
21:24:58 <opqdonut> (or even want, they make you copy more than necessary)
21:26:32 <evocatus> opqdonut: eh, interesting... I am not familiar with persistent tree structures unfortunately
21:26:50 <evocatus> currently just working out of CLRS & trying to re-implement their basic pseudocode algorithms which do involve parent pointers
21:27:05 <opqdonut> yeah, you'll probably have a bad time doing that in a pure language
21:27:17 <dsal> I assume your tree is Foldable.  The naïve implementation would be to just verify toList a == toList b
21:27:56 <opqdonut> since the traditional tree algorithms use pointer mutation
21:28:00 <evocatus> dsal: yes, I was considering something similar to that - just some cursory research reveals that an in-order traversal and one of a pre/post-order traversal is enough to uniquely characterize a tree structure
21:28:15 <evocatus> so if I use two traversals I should be able to ascertain equality without actually using (==)
21:28:45 <opqdonut> can't you just write your own == that doesn't look at parent pointers?
21:28:54 <opqdonut> no need for anything complicated
21:29:36 <opqdonut> anyway, if you want to reimplement CLRS algorithms you might want to use STRefs or IORefs for pointers
21:29:54 <evocatus> opqdonut: mm, I considered this as well... I do want to ensure that the parent pointers are actually being correctly updated by my functions, though on second thought not sure if that's strictly necessary
21:30:11 <dsal> How are you updating things?  Updating sounds hard.
21:30:31 <evocatus> tbh looking at some of these algorithms I'm not even sure the parents are really crucial to their functioning
21:30:34 <evocatus> dsal: tying the knot
21:30:36 <opqdonut> if you want to learn datastructures in haskell going through okasaki's book is probably a better idea than clrs
21:31:08 <opqdonut> evocatus: I hope you realise you won't get the promised asymptotics, you'll have an extra factor of O(n) from copying the whole tree all the time
21:31:46 <opqdonut> (by okasaki I mean Okasaki: Purely Functional Data Structures)
21:32:37 <opqdonut> but if you implement red-black (or AA, or AVL) trees without parent pointers, stuff works out and you get a nice O(log n) persistent tree
21:32:53 <opqdonut> okasaki has a chapter on this :)
21:33:29 <evocatus> opqdonut: eh, okay - perhaps I'll have to give it a read then, especially if I don't actually get the same asymptotics.. it's not the first time I've heard that book mentioned =)
21:34:08 <opqdonut> btw one way to think about parent pointers is this: if you're doing a recursive traversal of the tree, you don't need parent pointers since they are on your stack
21:34:22 <opqdonut> the call stack that is
21:34:31 <evocatus> opqdonut: yeah, I am becoming increasingly wary of whether or not the parent pointers are even necessary
21:34:52 <evocatus> I was laboring under the assumption that they would be required for red/black tree insertion but giving it a closer read I don't think it actually serves any purpose for that function
21:34:59 <opqdonut> yep
21:35:01 <evocatus> (or any of the others I care about..)
21:35:52 <evocatus> ok, well I will give it a shot. thanks for the advice & the book recommendation! =)
21:35:58 <dsal> The more interesting part, IMO, is when you implement functor, applicative, monad, foldable, and traversable.  :)
21:36:37 <evocatus> dsal: hehe.. perhaps once I get the basic operations implemented!
21:37:26 <dsal> Sure, yeah.  The nice thing is that you get a bunch of defaults that possibly perform terribly, but are good reference implementations of things you can compare against.
21:39:05 <dsal> e.g., if you implement foldr, you get Foldable which gives you null, toList, length, elem, minimum, maximum, sum, and even stuff like foldl (and some other junk).
21:39:40 <dsal> And if you don't implement foldr, what are you even doing?  :)
21:39:57 <evocatus> dsal: ah, never thought of that... would help verifying correctness certainly
21:40:42 <jzyamateur> When I see the docs, I see `mapM_` present in both `Data.Foldable` and `Control.Monad`, Are they one and the same? Can I import any one of these two?
21:41:24 <dsal> I believe so, but you can check
21:41:36 <dsal> :hoogle mapM_
21:41:46 <Lysergic1reams> The types are the same
21:41:52 <dsal> @hoogle mapM_
21:41:53 <lambdabot> Prelude mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
21:41:53 <lambdabot> Control.Monad mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
21:41:53 <lambdabot> Data.Foldable mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
21:41:56 * dsal can't hoogle
21:42:20 <dsal> :t void.traverse
21:42:21 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> ()
21:44:21 <LysergicDreams> :t traverse_
21:44:23 <lambdabot> (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
21:45:25 <dsal> @src traverse_
21:45:25 <lambdabot> traverse_ h xs = foldr (\fx fxs -> h fx *> fxs) (pure ())
21:45:25 <lambdabot> --OR
21:45:25 <lambdabot> traverse_ h xs = traverse h xs *> pure ()
21:45:37 <dsal> weird.
21:45:58 * Axman6 prefers the first definition by a large margin
21:46:01 <lavalike> :t (void .) . traverse
21:46:02 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f ()
21:46:25 <Axman6> :t foldMap . void
21:46:26 <lambdabot> Foldable t => (a1 -> a2) -> t a1 -> ()
21:47:00 <MarcelineVQ> :t foldMap void
21:47:02 <lambdabot> (Foldable t, Monoid (f ()), Functor f) => t (f a) -> f ()
21:47:08 <Axman6> :t \f -> foldMap (void . f)
21:47:10 <lambdabot> (Foldable t, Monoid (f ()), Functor f) => (a1 -> f a2) -> t a1 -> f ()
21:47:24 <Axman6> uh right
21:48:05 <MarcelineVQ> :t getAp . foldMap (void . Ap)
21:48:07 <lambdabot> (Foldable t, Applicative f) => t (f a) -> f ()
21:49:24 <dsal> What's Ap?
21:50:54 <MarcelineVQ> A Monoid that exists for any Applicative, iiuc
21:51:25 <MarcelineVQ> e.g <> = liftA2 (<>)
21:51:27 <dsal> Oh, that makes sense.
21:51:31 <MarcelineVQ> :t alaf Ap foldMap void -- :|
21:51:33 <lambdabot> (Foldable t, Applicative g) => t (g a) -> g ()
22:09:29 <dmwit> dsal: void.traverse isn't a good definition, because it first builds a complicated data structure then throws it away. traverse_'s actual implementation throws stuff away as it goes, never building the big data structure in the first place.
22:10:19 <dmwit> (Well, (void.).traverse isn't a good definition, I mean.)
22:10:32 <jle`> i think idealllllly, with an appropriately lazy Applicative, it should be the same. but sometimes it's hard to really reason about it
22:10:50 <jle`> a lot of applicatives in haskell aren't as lawfully lazy (or strict?) as we'd like
22:11:13 <jle`> so yeah i would avoid `\f -> void . traverse f` too
22:11:28 <dmwit> Even with a lazy Applicative, you're still putting unnecessary GC pressure by preserving references to the original input.
22:11:48 <dmwit> Think of `traverse_ print [1..]` vs. `void <$ traverse print [1..]`.
22:12:03 <jle`> the poor gc
22:12:25 <dmwit> s/<//
22:12:32 <jle`> :t \f -> foldr ((>>) . f) (pure ())
22:12:34 <lambdabot> (Foldable t, Monad m) => (a1 -> m a2) -> t a1 -> m ()
22:12:41 <jle`> :t \f -> foldr ((*>) . f) (pure ())
22:12:43 <lambdabot> (Foldable t, Applicative f) => (a1 -> f a2) -> t a1 -> f ()
22:13:24 * dsal mumbles something about a sufficiently smart compiler.
22:14:14 <jle`> % foldr ((*>) . print) (pure ()) [1,2,3]
22:14:15 <yahb> jle`: 1; 2; 3
22:27:41 * hackage ban-instance 0.1.0.0 - For when a type should never be an instance of a class  https://hackage.haskell.org/package/ban-instance-0.1.0.0 (qfpl)
22:27:47 <jackdk> Axman6: ^
22:28:33 <Axman6> :tada:
22:28:59 <jbrouwer> Hey there! I am new to haskell. I try to use `cabal install` but it gives me "LICENSE: openBinaryFile: does not exist (No such file or directory)"
22:29:33 <jbrouwer> OS: Mac OS X. I have installed ghcup and `cabal new-install cabal-install`
22:30:37 <_vaibhavingale_> ._ashbreeze_ 
22:30:39 <jackdk> back up a second, what are you trying to achieve with `cabal install` command?
22:31:08 <_vaibhavingale_> ._ashbreeze_ ignore..
22:31:33 <jbrouwer> I am assuming that `cabal install` tries to install all the packages in `*.cabal` ?
22:32:01 <jbrouwer> I want to install all the dependencies of the .cabal file in the current directory
22:32:05 <dminuoso> jbrouwer: Hiya. What are you trying to do? Compile a project?
22:32:23 <jbrouwer> Yes I am trying to compile a project
22:32:29 <dminuoso> jbrouwer: Use `cabal v2-build` :)
22:32:34 <sclv> does your project have a LICENSE file?
22:32:54 <sclv> its trying to install the package, and that means using the license file, and i think the cabal file is pointing to a license file that does not exist
22:32:56 <jbrouwer> `touch LICENSE` okay now it works =)
22:33:35 <jbrouwer> Thank you guys - the error message doesn't give me any hints where to look besides having to do with a LICENSE
22:37:11 * hackage numhask-histogram 0.2.0 - See readme.md  https://hackage.haskell.org/package/numhask-histogram-0.2.0 (tonyday567)
22:44:11 * hackage ban-instance 0.1.0.1 - For when a type should never be an instance of a class  https://hackage.haskell.org/package/ban-instance-0.1.0.1 (qfpl)
22:45:11 <Axman6> jackdk: ^ D:
22:45:24 <jackdk> there's always something...
22:46:28 <Axman6> every time
22:55:47 <dsal> Ha
22:56:11 <dsal> It's not possible to find obvious things before things go live.
23:07:41 * hackage tmp-postgres 1.3.0.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.3.0.0 (JonathanFischoff)
23:14:29 <jackdk> somehow they only become obvious when live
23:58:41 * hackage tmp-postgres 1.4.0.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.4.0.0 (JonathanFischoff)
