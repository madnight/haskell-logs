00:03:05 <goolord> jhaugh: i have not tested this yet but does `runParserE :: Sem (Parser : r) a -> Sem (State String : NonDet : Reader Dictionary : Parser : r) a` compile?
00:05:06 <goolord> all of the other return types seem more polymorphic
00:05:33 <jhaugh> It does if I leave comment out the wordE case match
00:07:23 <jhaugh> goolord: I can edit the gist to include all of the imports and language pragmas if that would help.
00:08:32 <goolord> no, it's ok, im going to get a compiler in front of me and look at it
00:09:14 <jhaugh> goolord: Awesome I appreciate the help! I went ahead and put in the imports anyway.
00:09:24 <goolord> thanks
00:12:49 <goolord> oh
00:13:08 <goolord> adding `Member Parser r =>` worked
00:14:37 <jhaugh> goolord: Huh it does! Is that the general pattern that should be followed when writing the interpretation of something like Parser? Is this an idiomatic way of setting up an effect?
00:17:39 <jhaugh> goolord: It seems weird because I thought it was gaining this information from the "Sem (Parser : r) a" part, does this actually take Parser off the stack? I will try to test it out now.
00:18:28 <goolord> hmmm tbh i haven't seen or written enough polysemy code to know what's idiomatic
00:20:45 <goolord> this is a learning experience for me as well
00:22:31 <jhaugh> goolord: Awesome! I really appreciate the help! I am trying to write a function to fully evaluate a function that uses the Parser effect. I will add what I tried to the gist. It is not yet compiling.
00:25:58 <justsomeguy> What is the best library for working with filesystem paths?
00:26:01 <justsomeguy> I tried System.FilePath, but noticed that it doesn't make a distinction between abstract paths and real paths. Where abstract paths are treated purely textually vs real paths which may require IO to canonnocalize or check that a path component is a file or directoyr, for example.
00:26:27 <jhaugh> goolord: I added a function at the bottom of the gist that attempts to run the Parser effect but it complains that I didn't handle Parser. Thus I don't think that runParserE is actually taking Parser off the stack.
00:26:54 <goolord> justsomeguy: https://hackage.haskell.org/package/path
00:27:19 <justsomeguy> Thanks, goolord
00:30:18 <jhaugh> goolord: The following two resources really helped me get started with polysemy if you want to take a look: https://github.com/KerfuffleV2/haskell-polysemy-test https://www.reddit.com/r/haskell/comments/c23wxd/example_for_polysemy_a_simple_guessanumber_game/erhvr0a/
00:30:42 <jhaugh> goolord: I am looking at them again to try to figure out what I am doing wrong
00:32:04 <goolord> so i think runParser does not handle the `Parser` effect
00:33:05 <goolord> hmmm
00:35:20 <jhaugh> goolord: The original runParser or runParserE?
00:37:23 <goolord> what i mean is that runParserE should push `Parser` off the effects stack
00:40:00 <jhaugh> goolord: Ya I think that is the problem as well it handles it but also puts another one right back on.
00:40:56 <goolord> i came up with something that compiles
00:42:18 <jhaugh> Awesome!
00:43:48 <goolord> https://gist.github.com/goolord/346a122748b697d65c7d78a280bcbb57
00:44:13 <goolord> i am skeptical that this is desirable, but 
00:44:57 <goolord> to push Parser off the effects stack WordE calls runParserE recursively 
00:46:08 <goolord> hmmm actually yeah, the type signature of `test` seems like what you want?
00:46:45 <goolord> `sm` is like your vaguely your weird parser type i suppose
00:48:38 <goolord> ok that was totally incoherent, which is probably a sign I should go to bed
00:48:53 <jhaugh> It really does work!
00:49:30 <jhaugh> I really aprreciate all of you help! You can run "testing ["test1", "test2"] "test2" wordE" if you want the satisfaction of it running haha
00:49:41 <jhaugh> goolord++
00:50:07 <goolord> oh, nice
00:50:10 <jhaugh> I will try to tweak it some more and see if I can figure out a more ergonomic solution
00:50:49 <jhaugh> But for now it at least works! Thanks again for all of your help
00:50:59 <goolord> it would be cool if you could somehow figure out a way to prove w/ the types that `runParserE` won't just loop forever
00:51:30 <goolord> i mean, i can read the code and see that it won't, so maybe that's not a big deal
00:51:46 <jhaugh> Ah ya that would be cool! 
01:48:54 <zincy_> How do you upgrade a single stack dependency in a project?
01:50:01 <MarcelineVQ> specify the version you want to use in extra-deps
01:50:21 <MarcelineVQ> - foo-1.2.3
01:51:06 <MarcelineVQ> if your stack.yaml was generated it should have an example comment in it about how to do this if it's unclear
01:51:20 <MarcelineVQ> *how to write this
03:15:04 <jonathan_> Is generalizednewtypederiving safe as of the latest GHC version? I want to use it for simple double wrappers such as: newtype Joule = Joule {unWrap :: double} deriving(Num)
03:15:31 <jonathan_> Is there any rule of thumb as to when it's ok and when it's not?
03:21:19 <cocreature> jonathan_: yeah it‚Äôs fine
03:21:27 <cocreature> and has been for quite some time afaik
03:23:27 <jonathan_> okay, so it's considered safe in general? Even with GADT:s/TypeFamiles?
03:24:16 <jonathan_> I'm curious about getting a high level intuition as to what made it unsafe, what has changed, and what's ok
03:25:58 <cocreature> I don‚Äôt recall the details but afaik the issues were solved by the introduction of the role system 
03:27:05 * ski thinks multiplying joules, getting joules back, doesn't make much sense
03:29:37 <jonathan_> ha, that's true
03:30:03 <int-e> Well it's type-safe.
03:30:03 <jonathan_> I'll keep that in mind :)
03:30:36 <jonathan_> and ty, then I know where to start lookig
03:30:40 <int-e> You can still potentially break invariants (type roles help in cases like Map k a) or end up with weird semantics.
03:31:26 <int-e> :t coerce
03:31:27 <lambdabot> error:
03:31:27 <lambdabot>     ‚Ä¢ Variable not in scope: coerce
03:31:27 <lambdabot>     ‚Ä¢ Perhaps you meant ‚Äòcoerced‚Äô (imported from Control.Lens)
03:31:41 <jonathan_> what kind of invariants, and what do you mean by weird semantics?
03:32:03 <int-e> :t Data.Coerce.coerce
03:32:05 <lambdabot> Coercible a b => a -> b
03:33:30 <int-e> My limited understanding is that old, unsafe GND used `unsafeCoerce` on class dictionaries. New, type-safe GND uses `coerce` instead, and the compiler checks that the new dictionary has the same representation as the original one. This fails for type families, for example, because their arguments have a nominal role.
03:36:27 <jonathan_> I dont' really understand what you mean by arguments having a "nominal role". I'll need to do some reading. One question though, when you say that "this fails for type families", do you mean a nice compilation failure, or a scary hidden one?
03:37:14 <jonathan_> e.g. can I trust the compiler to hold my hand as to when generalizednewtypederiving works or not?
03:40:08 <int-e> jonathan_: it's not terribly pretty: http://paste.debian.net/1116523/
03:40:35 <int-e> jonathan_: But that error makes sense with the `coerce` story that I just told.
03:40:40 <int-e> ...in mind.
03:41:55 <jonathan_> as long as I don't risk pushing unsafe code into production I'm fine with it
03:41:55 <int-e> (type roles don't really enter the picture in that example)
03:42:22 <jonathan_> GHC isn't really known for it's beautiful error msgs anyway :D
03:43:13 <int-e> jonathan_: It could be far worse. SPJ at least actually cares about error messages.
03:43:49 <int-e> jonathan_: Which is a huge reason why GHC type-checks code before desugaring.
03:45:04 <jonathan_> hm, it could always be worse I guess, didn't mean to critizise the things that are there
03:45:31 <int-e> That said it's still true that you often need to think like a compiler to make sense of error messages.
03:45:58 <jonathan_> It's just that I've been doing some ELM as well, and that's in a whole different ballpark
03:46:24 <jonathan_> I'd settle for some formatting/layout/coloring to make them more readable :D
03:47:03 <jonathan_> right now it often feels like a big chunk of text which my mind needs to be.. coerced into parsing
03:48:18 <int-e> it's black, and red, and blue... plenty of colors.
03:49:40 <jonathan_> huh, I'll need to rethink my life I guess
03:50:30 <jonathan_> I'll try to formulate concrete suggestions instead of complaining (and look into whare my color's at)
03:50:38 <jonathan_> ty for the pointers
03:51:27 <int-e> jonathan_: My real complaint about that error would be that it doesn't explain *why* there's a `coerce` to begin with... so you really have to know what GND does to make sense of that.
03:51:59 <int-e> (There are a few hints, last but not least the offending line itself.)
04:07:16 <tom_> MarcelineVW: Thanks for your answer
04:25:37 <jacks2> I need very simple web page.. just text, buttons, textbox input, and fetching data from and writing to a database. is it even worth using some library for making websites, vs using html combinator like blaze?
04:41:41 * hackage lukko 0.1.1.1 - File locking  https://hackage.haskell.org/package/lukko-0.1.1.1 (phadej)
04:56:42 * hackage minilight 0.4.1 - A SDL2-based graphics library, batteries-included.  https://hackage.haskell.org/package/minilight-0.4.1 (myuon)
05:36:25 <sm[m]> jacks2: blaze would be fine. If it gets larger, blaze is still fine if your priority is clean consistent refactorable html; a templating system would be better if your priority is complex hand-tweakable web-designer-compatible markup
06:01:08 <reallymemorable> I have a CSV that I currently have locally that I need to read out of (using Cassava).  How do I set the file path relative to its directory?
06:01:21 <reallymemorable> Currently, I can only hard link it to its location when I have the repo locally
06:04:05 <lyxia> I'm not sure what that means. The file path of a file relative to its own directory is... the file name. You don't mean that do you?
06:04:42 <__monty__> Are you looking for a symlink rather than a hardlink maybe? Relative hardlinks don't make sense.
06:05:33 <reallymemorable> so when i put it in the specific sub dir that the .hs file using it is in
06:05:40 <reallymemorable> it says the file does not exist
06:05:46 <reallymemorable> (when i just put the file name)
06:06:37 <__monty__> Is the path relative to the current directory? Or the directory main is in maybe?
06:07:19 <reallymemorable> i have tried both the path relative to the specific directory of the .hs file that uses it is in
06:07:31 <reallymemorable> but i have also tried putting the CSV in the root of the repo
06:09:53 <__monty__> And do you run the program from the root of the repo?
06:10:56 <reallymemorable> I did `:l Path.To.Haskell.File.hs`
06:11:04 <reallymemorable> so that I could test the function in question
06:13:12 <lyxia> is it a single haskell file or are you trying to make a cabal package and distribute a csv with it?
06:13:36 <reallymemorable> distribute the csv
06:13:51 <merijn> Sounds like you want data-files
06:14:04 <merijn> Assuming the CSV is read-only
06:14:10 <reallymemorable> yes
06:14:21 <reallymemorable> data files meaning a directory for putting files in?
06:14:28 <lyxia> https://cabal.readthedocs.io/en/latest/developing-packages.html#accessing-data-files-from-package-code
06:14:43 <merijn> reallymemorable: cabal supports data files and methods for finding them at runtime
06:15:01 <reallymemorable> thanks!
06:16:25 <merijn> reallymemorable: The idea is that (OS) packagers can easily change/control where data files are installed on a system without your application needing to know
06:16:49 <merijn> (since the getDataFile etc. functions can be easily configured to look elsewhere)
06:17:14 <merijn> Added bonus: With v2-run it can correctly locate datafiles in your repository without needing to install your program :>
06:20:11 <__monty__> What directory are relative paths resolved to usually? I.e., does `.` mean `$PWD`?
06:20:36 <merijn> __monty__: What do you mean by PWD?
06:21:05 <__monty__> The shell environment variable.
06:21:11 <merijn> ALso what does "usually" mean? . and .. aren't OS dependent, they do the same on all posix platforms (and possibly windows?)
06:21:33 <merijn> __monty__: Sure, but I don't understand why environment variables would be relevant for relative paths
06:21:49 <__monty__> I imagine it gets fuzzier when you run GUI programs. I'm not sure those *have* a concept of present working directory?
06:22:16 <merijn> __monty__: On posix *every* process has a "current working directory", but that's not at all related to environment variables like PWD
06:22:32 <merijn> I'm also pretty sure windows has a similar "current working dir" notion
06:23:01 <__monty__> If that's in the POSIX spec it has to.
06:23:01 <merijn> Relative paths are always relative to current working dir, there is no "usually"
06:23:42 <merijn> __monty__: "the POSIX spec" <- that's where people already go wrong, there's like 10 different ones, not to mention no one actually implements them correctly
06:24:01 <__monty__> Aren't they relative to the file they're in in dhall?
06:25:19 <sm[m]> monty: I usually like them to be relative to the place you used them (eg the file you wrote them), that's more stable/deterministic
06:25:32 <merijn> __monty__: There are "paths" as in the stuff you pass to libc/syscalls, this is unambiguous. Then there's "strings that happen to represent filepaths" like you might find in a Dhall file, what an application does with said strings before having a final path that's passed to the OS is, well, application dependent
06:26:07 <merijn> __monty__: So the answer to "aren't they relative to the file in Dhall?" is "maybe, that'd be entirely dhall dependent"
06:26:18 <__monty__> Then I guess my question is are the common file reading operations in base implemented using those libc/syscalls?
06:26:35 <__monty__> *without path-related magic
06:26:39 <merijn> __monty__: Presumably dhall then prepends the path to the final containing the relative path before opening
06:27:12 <merijn> __monty__: Well, you have to figure out whether you're referring to "relative paths" or "non-normalised paths" first
06:27:56 <merijn> __monty__: Paths can be non-normalised (i.e. containing . and ..) and they can be relative, but these are two orthogonal properties
06:28:54 <merijn> so you can have normalised relative paths, non-normalised relative paths, normalised absolute paths and non-normalised absolute paths (and then you can actually also go into the fact that there are multiple levels of normalisation, i.e. do you strip out symlinks)
06:29:02 <__monty__> I'm definitely talking about relative paths, be they normalized or not.
06:29:22 <merijn> __monty__: So in short: Whatever your questions is is probably more easier answered by being more specific about what your question is :p
06:30:11 <__monty__> I think the version of my question that still stands, i.e., in terms of syscalls is more specific?
06:30:35 <merijn> base use the same logic as libc/etc. yes
06:30:43 <merijn> So relative to current working dir
06:31:35 <merijn> __monty__: Dhall accomplishes (presumably) "relative to file containing the path" by prefixing every relative path in a Dhall file with the path to the DHall file it was found in
06:33:09 <__monty__> I wonder why it requires the `./` prefix. Presumably to differentiate from identifiers?
07:32:11 * hackage authenticate 1.3.5 - Authentication methods for Haskell web applications.  https://hackage.haskell.org/package/authenticate-1.3.5 (MichaelSnoyman)
07:38:53 <merijn> Am I the only one who uses stuff like mmorph without a clue what the resulting code means? >.>
07:39:42 * hackage tmp-postgres 1.13.1.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.13.1.0 (JonathanFischoff)
07:48:31 <jonge[m]> hey there. i just read this (pretty cool and understandable) tutorial about ghc.generics: https://jeltsch.wordpress.com/2016/02/22/generic-programming-in-haskell/ unfortunately in base-4.12.0.0 there does not appear to be the type `NoSelector`... how would that look today? somehow i don't find a tutorial that works without
07:51:42 * hackage tmp-postgres 1.13.1.1 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.13.1.1 (JonathanFischoff)
07:52:42 * hackage concurrency 1.8.1.0 - Typeclasses, functions, and data types for concurrency and STM.  https://hackage.haskell.org/package/concurrency-1.8.1.0 (barrucadu)
07:58:49 <lyxia> jonge[m]: it's a field of the 'MetaSel constructor now
08:00:04 <lyxia> jonge[m]: have you seen the example at the top of the GHC.Generics module https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Generics.html#g:2
08:06:02 <jonge[m]> lyxia: thank you! I will have a look. I am a bit overwhelmed because the whole thing appears to me to have a steep learning curve
08:23:12 * hackage di 1.2.2 - Typeful hierarchical structured logging using di, mtl and df1.  https://hackage.haskell.org/package/di-1.2.2 (RenzoCarbonara)
09:03:35 <reallymemorable> how would i read a value out of a Cassava-ingested csv given a certain key value?
09:03:41 <reallymemorable> with `lookup` from Data.Csv?
09:07:31 <f-a> reallymemorable: I suspect that runParser function does the trick
09:14:04 <constantine_91> Hello, I am trying to write simple TCP chat server following https://wiki.haskell.org/Implement_a_chat_server steps. I am trying to import "import Network.Socket" and added dependency to as "build-depends:       base, network" but while building I am getting this error "    Could not load module ‚ÄòNetwork.Socket‚Äô    It is a member of the hidden
09:14:04 <constantine_91> package ‚Äònetwork-2.8.0.1‚Äô.    Perhaps you need to add ‚Äònetwork‚Äô to the build-depends in your .cabal file.    Use -v to see a list of the files searched for."
09:16:01 <lavalike> constantine_91: any luck following the suggestion?
09:16:44 <constantine_91> @lava
09:16:44 <lambdabot> Not enough privileges
09:17:08 <constantine_91> @lavalike which suggestion?
09:17:08 <lambdabot> Unknown command, try @list
09:17:35 <lavalike> constantine_91: it's there at the end of the message you pasted
09:18:57 <constantine_91> @lavalike No, I have already added the dependency to .cabal file as I mentioned earlier. But still in error message it tells me to add same dependency to same .cabal file
09:18:57 <lambdabot> Unknown command, try @list
09:19:28 <sm[m]> constantine_91: seems like it should work, can you share your whole cabal file on a paste site ? And what are you doing that produces the error ?
09:19:33 <Lycurgus> @aint-twitter
09:19:33 <lambdabot> Unknown command, try @list
09:19:44 <lavalike> (constantine_91: starting a line with @ makes the bot think it's a command here, you can drop it: irc clients will highlight without it anyway)
09:19:49 <lavalike> @botsnack
09:19:49 <lambdabot> :)
09:20:55 <jzyamateur> Let's say I have a structure `g` that is foldable, but not a functor. How do I use `fold` such a structure?  The elemnts within g are not monoid. I can't `fmap` to make them monoid
09:22:20 <sm[m]> (Ah, ‚Äúwhile building‚Äù you said)
09:22:50 <sm[m]> Still it always helps to tell the command you ran
09:24:34 <constantine_91> lavalike, sm[m] : posted my .cabal and error here https://gist.github.com/saurabhkukade/c9d4288bdc0b764cc8d63798d5d82d1e
09:24:42 * hackage network-simple-tls 0.4 - Simple interface to TLS secured network sockets.  https://hackage.haskell.org/package/network-simple-tls-0.4 (RenzoCarbonara)
09:25:04 <jacks2> what are popular haskell libraries for creating websites?
09:25:15 <f-a> jacks2: static ones, hakyll
09:25:17 <jacks2> preferably with web server included
09:25:31 <jacks2> and dynamic ones?
09:26:14 <sm[m]> constantine_91: I wonder if a cabal file without a ‚Äúlibrary‚Äù section is legal
09:27:05 <merijn> sm[m]: Yes
09:27:12 <merijn> sm[m]: Why wouldn't it be?
09:27:32 <sm[m]> ok, then that‚Äôs not the cause..
09:28:00 <constantine_91> sm[m] . Sorry...  I forgot to add library section. Added it now on same gitst
09:28:08 <merijn> That cabal file looks woefully incomplete, though?
09:28:11 * hackage lambda-options 1.0.1.0 - Declarative command-line parser using type-driven pattern matching.  https://hackage.haskell.org/package/lambda-options-1.0.1.0 (ThomasEding)
09:28:41 <jzyamateur> Let's say I have a structure `g` that is foldable, but not a functor. How do I use `fold` on such a structure?  Or do I have to use foldMap?
09:29:24 <constantine_91> sm[m] : solved. I added that dependency to library 
09:29:28 <merijn> It's also clearly broken in that the error says it tries to import Network.Socket in the PeerToPeer module, but the library doesn't depend on network
09:29:54 <merijn> jzyamateur: What makes you think foldMap would work?
09:30:01 <merijn> :t foldMap
09:30:03 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
09:30:09 <constantine_91> merijin : yes. fixed it and now its working
09:30:41 <merijn> :t fold
09:30:42 <lambdabot> (Foldable t, Monoid m) => t m -> m
09:30:43 <jzyamateur> it will convert a's to m's, what `fold` gives is also `m` but needs the a's inside to be m's , which I cant fmap and convert because no functor
09:31:08 <jacks2> snap vs happstack? what do you think?
09:31:14 <merijn> jzyamateur: foldMap would work, I guess, but why can't you make the type a Functor instead?
09:31:37 <jzyamateur> It's a incoming constraint, can't enforce it.
09:31:59 <merijn> ugh...it's "I'm unhappy" o clock, again >.<
09:32:37 <merijn> By which I mean "I opened the source code of an important library and realised that we're all doomed by it's unsafety"
09:33:55 <LKoen> I opened the source code of a library and found a lot of "//TODO rewrite this algorithm, it is not correct"
09:34:08 <f-a> hehe
09:34:42 <merijn> LKoen: Sure, but was that a library that was used by huge parts of the ecosystem? :)
09:34:51 <LKoen> no
09:35:10 <merijn> LKoen: This is an issue with unliftio-core and resourcet >.>
09:36:52 <LKoen> well, I guess we'll just pretend there is no safety issue and live our lives in blessed ignorance
09:37:23 <LKoen> the city center 200m from my home is literally on fire right now btw
09:37:55 <merijn> LKoen: Except it's breaking my own code, so i was just "oh, I'll just quickly fix my code" *half an hour later* "oh...well, guess there's literally no way my library can prevent a user from doing something that will introduce resource races an ugliness everywhere"
09:38:35 <LKoen> ah
09:39:37 <LKoen> so it's not so much "the bridge I walk on could potentially collapse at some point under the right circumstances" as "the bridge is currently sinking into the ground"
09:39:49 <merijn> basically, ResourceT has a MonadUnliftIO instance, but that instance uses an implementation that is only safe when used in the same thread
09:40:31 <merijn> Which means that, if you use "MonadUnliftIO" to make it convenient to run functions in monads other than IO in a separate thread, you'll get races/multiple frees/etc.
09:40:58 <LKoen> almost as scary as non-functional programming languages!
09:41:09 <LKoen> I mean non-pure
09:41:10 <merijn> But there's no way to prevent users from passing you MonadUnliftIO instances that don't involve ResourceT anywhere
09:41:21 <merijn> s/that don't/that/
09:41:33 <merijn> So I have no way to prevent users from blowing everything up
09:45:10 <LKoen> after the genoa highway collapsed, the city people said they had already read reports stating the bridge was very old and very unsafe and could collapse very easily if they didn't do roadworks to reinforce it, but everyone had a "come on, in real life highways don't collapse" attitude about it
09:46:40 <merijn> ugh, and I don't think I can really fix this, because the only bracketing operation available in Conduit use MonadResource, so if I want to bracket so I'm not even sure I can fix it with well behaved user code
09:48:38 <tomjaguarpaw> Is there a known issue with loading HSghc-prim on 32-bit systems?
09:48:53 <tomjaguarpaw> I seem to be having problems with that when trying to run ghcide
09:49:04 <tomjaguarpaw> I get unknown symbol `_GLOBAL_OFFSET_TABLE_'
09:55:11 * hackage filestore 0.6.3.5 - Interface for versioning file stores.  https://hackage.haskell.org/package/filestore-0.6.3.5 (JohnMacFarlane)
09:56:46 <merijn> Man, clearly we should just remove forkIO from Haskell, because no one knows how to do this shit safely
09:58:37 <dmj`> merijn: we should remove all I/O from Haskell
09:58:40 <dmj`> it's very unsafe
09:58:55 <merijn> dmj`: Yeah, but at least libraries that use IO safely exist >.>
09:59:24 <merijn> Although, actually also debatable
09:59:36 <merijn> Considering the Control.Exception is still utterly bollocksed
09:59:55 <merijn> But, like, every single library out there is utterly broken when it comes to threading
10:01:05 <heatsink> How so? I haven't used threads much
10:01:22 <merijn> heatsink: Because concurrency is hard and people aren't paranoid enough
10:04:48 <dmj`> modifyMVar_ is where it's at 
10:05:01 <dmj`> one giant lock FTW
10:05:45 <dmj`> merijn: there should be a library that wraps all these various patterns into opaque data types and exposes them as records
10:05:49 <heatsink> My bad experience was writing code to interrupt a subprocess after a timeout, which would work properly on one OS but not another
10:06:04 <merijn> anyway, dinner
10:09:46 <dsal> I put a bunch of effort into trying to speed up variable int protocol encoding (-> ByteString) and, AFAICT, I didn't make it clearly faster.  Lame.  I guess I could try doing it in C.
10:41:47 <dunce> considering `enumerate (r : * s) = [ x ++ y | x <- enumerate r, y <- enumerate s]`  the `<-` operation is acting as `int x = Math.max(x, y)` in say Java correct?  As in `<-` is used to set equivalence to the output of a function where = would set x to  the function `enumerate r` ?
10:42:07 <dsal> Eh, it's not clearly faster in C, either.  Not enough to justify adding FFI.
10:42:29 <merijn> dsal: How did you encode it originally?
10:42:58 <geekosaur> dunce, '<-' in there is best read as 'in' or 'taken from'
10:43:10 <dsal> merijn: This is the code I was hoping I could make a lot faster:  https://github.com/google/proto-lens/blob/master/proto-lens/src/Data/ProtoLens/Encoding/Bytes.hs#L126-L130
10:43:29 <geekosaur> it will be set to each value produced on the right in turn
10:43:50 <merijn> dsal: Builder is already intended to be pretty fast, so...
10:44:13 <dsal> Yeah.  It just showed up  as like, 25% of my profile, so I wanted to see if I could make improvements.  It's surprisingly hard to beat.
10:44:55 <merijn> dsal: Well, if you know ahead of time how many bytes to write you could do a direct mutable implementation that would probably beat it
10:45:22 <dsal> I tried a few internals, the unfoldr thing, building a pre-allocated encoding and using boudedPrim (LOL) and then doing the same with  FFI.  I made it slightly more consistent and maybe slightly  faster, but it's just not better enough.
10:46:11 <merijn> dsal: Honestly, I'd just go directly for ForeignPtr Word8 and writing a loop over that, that's about as fast as you can reasonably get
10:46:38 <merijn> FFI will add non-trivial overhead and your C code will be basically the same as doing the Ptr twiddling in Haskell
10:49:15 <dsal> Yeah, I  was looking at how  it was doing some stuff internally, but nothing I did justified the complexity I added.  I was hoping I could see something a *lot* faster.
10:49:25 <javi> hi
10:49:39 <javi> can someone explain me how this recursive method works?
10:49:51 <javi> prueba (y:xs) = [y]:[1:x | x<- prueba (xs)]
10:50:00 <javi> prueba [] = []
10:50:35 <dsal> javi: which part is confusing?
10:50:39 <javi> prueba [2,3,5]
10:50:42 <javi> [[2],[1,3],[1,1,5]]
10:50:55 <javi> why is that the output?
10:50:59 <lavalike> javi: you can understand it by substituting the right hand sides for the left hand side in your expression
10:51:53 <lavalike> javi: prueba [2,3,5] = prueba (2:[3,5]) {so the first case applies: y=2, xs=[3,5]} = [2] : [1:x | x <- prueba [3,5]]
10:53:04 <lavalike> javi: focusing on the list comprehension on the right, prueba [3,5] = prueba (3:[5]) {first case again: y=3, xs=[5]} = [3] : [1:x | x <- prueba [5]]
10:53:51 <lavalike> javi: and lastly prueba [5] = prueba (5:[]) {first case again: y=5, xs=[]} = [5] : [1:x | <- prueba []]
10:54:47 <lavalike> now we can resolve them backwards since prueba [] {second case} = []
10:55:17 <lavalike> prueba [5] = [5] : [1:x | x <- [] ] = [5] : [] = [[5]]
10:56:10 <lavalike> prueba [3,5] = [3] : [1:x | x <- [[5]]] = [3] : [ 1:[5] ] = [3] : [[1,5]] = [[3],[1,5]
10:56:21 <lavalike> ]
10:57:29 <lavalike> and lastly: prueba [2,3,5] = [2] : [1:x | x <- prueba [3,5]] = [2] : [1:x | x <- [[3],[1,5]]] = [2] : [1:[3], 1:[1,5]] = [2] : [[1,3],[1,1,5]] = [[2],[1,3],[1,1,5]]
10:58:32 <javi> wait
10:58:36 <javi> why is prueba [5] = [5] : [1:x | x <- [] ] = [5] : [] = [[5]]
10:58:57 <javi> [1:x | x <- [] ]  means [1]
10:59:00 <lavalike> good question, ignore the "[5] :" part as it doesn't change the answer
10:59:29 <lavalike> [_ | x <- []] means produce _ for each element of the list [], while binding such element to the name x
10:59:43 <lavalike> but there are no such elements! so it produces the empty list
11:00:58 <javi> you mean [1:x] means [] because x=nothing
11:01:00 <javi> ?
11:01:01 <lavalike> nope
11:01:20 <lavalike> > [ "pony" | x <- [1,2,3] ]
11:01:22 <lambdabot>  ["pony","pony","pony"]
11:01:34 <lavalike> this produces a pony for each of the elements of the [1,2,3] list
11:01:39 <lavalike> > [ "pony" | x <- [] ]
11:01:41 <lambdabot>  []
11:01:53 <lavalike> this does too, since the list is empty, it produces no ponies
11:01:54 <javi> i see
11:02:18 <javi> now everything is starting to make sense
11:02:22 <javi> ty!
11:02:25 <lavalike> yw!
11:07:30 <koz_> Love the pony example.
11:09:42 <sm> update on yesterday's ghcide comments mpickering: disabling flymake may have helped quite a bit, discovered thanks to tomjaguarpaw's https://www.reddit.com/r/haskell/comments/dwkehu/thoughts_on_hie/f7nj2e1/
11:18:53 <dsal> I learned a lot of interesting things trying to make this na√Øve code faster.  One of them is that libraries can do magic to make na√Øve code faster.
11:22:07 <geekosaur> RULES are a bit scary
11:22:25 <geekosaur> (and even scarier when they go wrong)
11:22:52 <dsal> Yeah, looks like you can do a lot of damage.
11:23:12 <dsal> I used to think list fusion was some super fancy compiler magic.
11:24:15 <Athas> I can't decide whether RULES are brilliant or crazy.
11:24:31 <Athas> Considering their power-to-weight ratio, probably both.
11:24:54 <tsahyt> a bit of both, yes
11:25:28 <dsal> Most languages seem to reserve a lot of power to the small language body.  Haskell seems to give quite a lot of power to users.
11:25:47 <geekosaur> RULES are ghc, not standard
11:25:48 <Athas> That's a GHC thing.  No Haskell report ever mentioned RULES pragmas!
11:26:27 <f-a> mhhh my program seems to require Cabal-3.0.0.0 and Cabal.2.4.1.0 at the same time
11:26:33 <f-a> I suspect it is b/c custom setup
11:26:50 <dsal> Well, yeah.  I understand that haskell isn't GHC, but at the same time, I'm not sure I believe that.
11:26:54 <Athas> RULES are unfortunately limited.  I wonder if the reliance on RULES-based fusion was a contributor to the failure of Data Parallel Haskell.
11:27:08 <Athas> But this was before my time.
11:27:09 <f-a> https://hub.darcs.net/ffaf/venzone/browse/venzone.cabal is there a way to fix it (i.e. having only one version of Cabal compiled)?
11:28:58 <geekosaur> Athas, my understanding is DPH just ran out of maintainers with time. which has also happened to ghc alternatives and such, and DPH itslf hung on for so long only because it got into ghc's codebase
11:29:33 <geekosaur> being inside ghc meant it wasn't limited to RULES
11:29:33 <Athas> Right, but they ran out of time because it was very hard to get the crucial fusion transformations working right.
11:29:58 <geekosaur> ghc internals had more to do with it iirc
11:30:20 <geekosaur> (also why RULES are so limited, as it turns out)
11:31:09 <Athas> Which internals?
11:31:17 <Rembane> Are DPH still part of GHC? 
11:31:23 <Athas> Rembane: no.
11:31:51 <Athas> I'm quite interested in this history, but I've refrained from imposing *too* much when I met with the involved parties.
11:32:17 <Athas> It's definitely possible that DPH could have gone further had more funding been available.
11:33:29 <Athas> Looks like DPH was removed for good on June 2nd 2018.
11:33:43 <Athas> bgamari_ swung the axe in faee23bb69ca813296da484bc177f4480bcaee9f.
11:33:46 <geekosaur> Athas: RULES are shaped as they are, along with things like inlining passes with positions, because of how ghc internal passes work. I couldn't quite chapter and verse, but some things are hard to do with the internal architecture
11:34:45 <Athas> geekosaur: you could easily have another core-to-core pass that did array fusion using its own bespoke mechanisms, completely independently of RULES.
11:34:52 <Athas> Presumably DPH already had something like that, to run the vectoriser.
11:35:00 <geekosaur> (this bites in a few more places, for example iiuc it prevents exposing to llc what ghc has done in terms of cps transforms, which limits its ability to produce optimized code)
11:37:33 <geekosaur> there were some limits to core-to-core that were only lifted when they redesigned plugins, I think?
11:37:56 <geekosaur> which was after DPH was axed and long after it was left esentially maintainerless
11:38:48 <Athas> Incidentally, nobody else has managed to perform good fusion on vectorised/flattened code either.  In fact, I don't know of anyone who's made flattened nested data parallelism run fast at all...
11:39:04 <Athas> Doesn't mean it's not possible with enough time and funding, of course.
11:42:06 <heatsink> I am skeptical of the whole premise of flattening nested parallelism
11:42:14 <Athas> As am I.
11:42:42 <merijn> Athas: btw, a bunch of my GPU programming (absolutely not FP related) colleagues would be interested in your Futhark talk, if you do come to NL-FP 
11:42:57 <Athas> My favourite parallel programming model for Haskell is the Par monad.  It's just so simple and effective.
11:43:10 <Athas> merijn: definitely considering it!
11:44:12 * hackage predicate-typed 0.5.0.0 - Predicates, Refinement types and Dsl  https://hackage.haskell.org/package/predicate-typed-0.5.0.0 (gbwey)
11:45:15 <merijn> Athas: Because apparently the new national supercomputer is going to be all AMD (due to politics wrt open source and price of NVidia) and everyone is already dreading having to manually write OpenCL :p
11:45:33 <Athas> That is pretty hilarious.
11:45:52 <Athas> They'll need a therapist to go along with that supercomputer.
11:46:12 <merijn> Pretty much
11:51:08 <sm> f-a: can you constrain cabal-install to a Cabal 2 based version in cabal-version: ?
11:51:48 <sm> I guess you are using cabal-install 3.0.0.0 to build ?
11:52:02 <Athas> heatsink: do you have experience with flattening NDP?
11:52:08 <f-a> sm: which is the sensible¬Æ optio- actually I am using cabal-install version 2.4.1.0
11:52:45 <sm> maybe cabal-version: >=1.24 && <3 works ?
11:53:17 <merijn> sm: That's illegal syntax
11:53:21 <sm> ah
11:53:30 <merijn> sm: cabal-version is *not* the version of cabal-install
11:53:39 <sm> f-a: custom Setups are pain, I think
11:53:51 <f-a> sm: I am pondering about axing it
11:53:55 <merijn> cabal-version refers to the version of the CABAL spec that the cabal file pertains too
11:54:04 <merijn> f-a: What was the question, I missed the start?
11:54:07 <f-a> it just moves the compiled to release/venzone, not sure it it meant to do that too
11:54:17 <f-a> merijn: a https://hub.darcs.net/ffaf/venzone/browse/venzone.cabal is there a way to fix it (i.e. having only one version of Cabal compiled)?
11:54:36 <sm> merijn: Last login: Sun Oct 20 13:11:59 on ttys004
11:54:46 <sm> oops
11:54:53 <sm> merijn: <f-a> mhhh my program seems to require Cabal-3.0.0.0 and Cabal.2.4.1.0 at the same time
11:55:07 <f-a> missed that line, thanks
11:55:08 <merijn> Ok, so first of all "cabal-version:       >=1.24" <- this is wrong and you don't want that
11:56:02 <merijn> What does your custom setup do, do you even need one?
11:56:31 <f-a> merijn: it moves exe + some text (data/level) files to "release" folder.
11:56:44 <f-a> I am not sure this is the correct place where to do such operations to be honest
11:56:46 <merijn> f-a: the data/level are read-only?
11:56:53 <f-a> yes
11:57:01 * sm hands f-a a shiny axe
11:57:05 <f-a> hehe
11:57:10 <merijn> f-a: Cabal already has a method for setting/finding read-only data for distribution
11:57:42 <merijn> So you can get rid of the custom setup and use that, then you still have to deal with copying to the release folder, but custom setup is certainly inappropriate for that
11:58:01 <f-a> so what's the appropriate way?
11:58:03 <merijn> f-a: https://cabal.readthedocs.io/en/latest/developing-packages.html#accessing-data-files-from-package-code
11:58:31 <f-a> also what's the appropriate replacement for >=1.24
11:58:39 <merijn> f-a: I'd say "just make a shell script" for copying/moving
11:58:43 <sm> the trouble with *that* way, is it requires installation with cabal or stack, which is not so good for a game you might want to ship binaries of
11:59:07 <merijn> f-a: Cabal-install is backwards compatible by default, the "cabal-version" is intended to indicate a specific version of the cabal spec that the file follows
11:59:16 <merijn> sm: It does not
11:59:41 <merijn> sm: getDataFiles and co are designed to be easily configurable/overridable by OS package maintainers
12:00:00 <sm> merijn: ok, or it requires proper packaging
12:00:00 <f-a> I am not an OS package maintainer though
12:00:10 <sm> (which is as rare as hens teeth)
12:00:13 <f-a> I expect my user to dowload a zip, unzip it and click on the exe
12:00:15 <merijn> sm: They will look relative to a rootdir which, by default, looks at the cabal install directory
12:00:32 <merijn> You can override the rootdir via environment variables
12:01:08 <sm> unfortunately all this is too much pain if you have casual users
12:01:12 <merijn> So you'd normally make a small shell script that points to the relevant (relative to the script!) paths and then set the environment variables correctly before running
12:01:20 <sm> for this use case, I think file-embed is a pretty good approach
12:01:34 <f-a> https://hub.darcs.net/ffaf/venzone/browse/src/Paths.hs#18 I went for this, again, not sure it is the best
12:01:38 <merijn> sm: The casual user doesn't have to know, many programs work by having a shell script do that stuff
12:02:12 <sm> yes, you could bundle a script and the files in a zip. Not as good as a single exe, but another option
12:02:12 <f-a> sm: unfortunately data are read only in game, but then you can modify them (and add to the folder) via the level editor
12:02:13 <merijn> sm: Hell, just run "type ghc" and then open the reported path in vim (or whatever editor)
12:02:28 <merijn> sm: You'll see that "ghc" in your path isn't actually ghc :p
12:03:01 <sm> f-a: yes, I am imagining once the casual gamer wants to edit levels, they'd clone the repo, or run venzone --write-levels
12:03:10 <merijn> f-a: Anyway, this page reports which features were added in which cabal version: https://cabal.readthedocs.io/en/latest/file-format-changelog.html
12:04:05 <merijn> f-a: I'd use "cabal-version: 2.2" or 2.4 by default and only increase it if you need newer features (and only decrease it if you really, really need to support older cabal's (which you probably don't))
12:04:34 <merijn> Since cabal-install and cabal are backwards compatible with the old format and with really old GHCs
12:04:57 <f-a> so cabal-version:       2.2 will be
12:05:15 <merijn> f-a: That will work with any cabal-install >=2.2, yes
12:05:30 <merijn> (although it might complain that you need to move it to the first line of the file)
12:06:42 <sm> by the way, this game is playable and fun already, I recommend it!  darcs get https://hub.darcs.net/ffaf/venzone && cd venzone && stack/cabal run
12:06:56 <f-a> if you do: feeback welcome
12:07:16 <f-a> sm: you deal with this stuff probably every week since you develop hledger
12:07:44 <f-a> I can write an .sh to deal with moving files, but is there something like a cross platform sh? 
12:07:59 <merijn> sm: If you use v2-run then getDataFiles also works with uninstalled packages by defaulting to the repo :)
12:08:27 <merijn> sm: I have been using that with great success to have my "in development" code executable from anywhere :)
12:08:32 <sm> f-a: yes, I wanted "single exe" easy of installation, eg for windows users and non-haskellers, so I use file-embed instead of cabal's data files supprot
12:08:46 <f-a> I see
12:09:04 <sm> I also couldn't assume anybody has a new enough version of cabal
12:10:04 <sm> I also wanted to avoid this feature because files saved somewhere on disk is state which creates more failure modes, I wanted fewer moving parts
12:10:36 <sm> merijn: good to know those things nevertheless
12:11:13 <f-a> yeah, very informative, thank you both
12:11:48 <f-a> nkdarcs push
12:11:57 <f-a> meh, wrong pane :P
12:12:42 <f-a> I can assume a .sh works on Mac too, right?
12:12:46 <f-a> a simple sh
12:12:50 <sm> oh yeah, that was the other reason not to use a script, you'd have to maintain a .bat file as well
12:13:05 <merijn> f-a: You need a regular shebang like on linux, but yes
12:13:05 <sm> ye-e-e-ss...
12:13:16 <sm> depending very much what you do in it...
12:13:41 <sm> I think on mac the shebang line must be an absolute path, also 
12:13:49 <f-a> create release folder; move exec and level-folder to there, zip it
12:15:08 <f-a> of the many fun things of program developing, this is not one of them
12:16:55 <sm> the joys of packaging! a test of how much you love your users :)
12:17:58 <merijn> sm: Just use env on every platform
12:18:18 <merijn> "#!/usr/bin/env bash" (replace bash with sh/whatever as appropriate)
12:19:56 <sm> it just doesn't work on every platform
12:20:06 <sm> (windows)
12:20:16 <merijn> sm: There shebangs don't automatically work anyway
12:23:19 <merijn> w
12:26:20 <sm> actually, I think there is a more portable script format than bash: stack scripts (cabal may have them too)
12:26:56 <f-a> good idea
12:27:06 <f-a> using turtle there or similar could do
12:27:45 <sm> those can work on vanilla windows too, if you require them to install stack, which is easy
12:28:10 <sm> but nothing beats a single exe (download, double click)
12:28:28 <sm> well, I mean, ignoring security....
12:28:38 <Athas> Windows is a very difficult operating system, so I assume Windows users are very skilled and can solve their own problems.
12:28:53 <merijn> Athas: That's what I assume about all OSes ;)
12:28:55 <Athas> Otherwise I assume they would use something easy like Unix.
12:30:28 <monochrom> Windows users are actually the most willing to run exes from strangers, so don't worry! >:)
12:31:15 <sm> if you're well funded, I guess you package your haskell app like the Daedalus devs do (build it on electron, do whatever they do ?)
12:31:56 <monochrom> And linux users? Oh they're very willing to run incomprehensible shell scripts "but it is open-source it's fine" so no worries there either! >:)
12:32:26 <sm> we must discourage this curl | sh madness
12:32:51 <monochrom> Millions of linux users have ran "curl | sh" from stack and ghcup. Join them!
12:34:00 <monochrom> But yes back in the 1990s I very much cringed that my Windows-using classmates kept sending me and each other "christmas cards" in the form of exes by email.
12:34:02 <hpc> don't forget to do it as root! sudo curl | sh
12:34:03 <hpc> :P
12:34:11 <sm> I try to look at the script, at least
12:34:18 <monochrom> Um I think you want to put the "sudo" with the "sh".
12:34:31 <geekosaur> ^
12:34:41 <sm> best to be logged in as root. Everything works then
12:34:45 <geekosaur> unless that was part of the joke
12:34:52 <hpc> ^
12:35:09 <monochrom> But for best of both world put "sudo" everywhere. "sudo curl | sudo sh"
12:35:27 <monochrom> Hell, "sudo (sudo curl | sudo sh)"
12:35:31 <geekosaur> sudo sudo‚Ä¶
12:35:42 <geekosaur> extra powah!
12:36:05 <Chousuke> just sudo chmod u+s /usr/bin/bash
12:36:09 <monochrom> Prove that sudo is the join of a monad.
12:36:10 <Chousuke> then you don't need sudo anymore
12:36:22 <monochrom> Hey that's smart!
12:36:59 <Athas> Haskell is very close to being sane and safe installation-wise, buuuuut we permit our dependencies to do unsafePerformIO and even perform arbitrary IO at compile-time.
12:37:29 <sm> I wouldn't say *very* close.. what about deterministic builds
12:37:35 <merijn> Aww...fuck
12:37:44 <monochrom> Deployment and installation is the easiest (for users) when everyone simply trusts everyone.
12:38:18 <Athas> sm: that's desirable, but not as crucial.  And isn't GHC pretty close?
12:38:26 * geekosaur is remembering Back In The Day
12:38:37 <monochrom> The limit of which is that every computer has open remote access so users just need to tell you their IP address and your install bot can just remote login and install.
12:38:42 <Athas> I think gentauro managed to get binary-reproducible builds using Nix and stack.
12:38:44 <Chousuke> I generally trust my distro maintainers. Everything else I'm going to look at first before installing :P
12:38:49 <merijn> Lemme just carefully refactor this code and realise how it completely breaks upon exceptions >.>
12:39:01 <merijn> Now I need to refactor this nonsense
12:39:21 <sm> Athas: I dunno.. GHC is pretty close to being able to get its CI green, I'd say
12:40:00 <sm> ie, GHC devs have a lot on their plate with more mundane goals. But I suppose there's a lot of GHC devs
12:40:29 <sm> Athas: interesting
12:41:04 <sm> still no good on windows of course :)
12:41:49 <sm> really, webassembly seems to be the solution (ie, no install)
12:42:33 <sm> deterministic signed webassembly lovingly shipped intact to my entirely trusted browser by 100% authentic Debian developers
12:42:37 <monochrom> On a parallel note (it's a pretty nerdy parallel, if you don't get it don't worry), how some of the theorems are like "if all sequences have colimits and your functor F preserves all such colimits, then you have an initial F-algebra".  And then the proof goes on to need only a very specially constructed sequence, not an arbitrary sequence at all. (For example, it always starts with the initial object, and the rest is always just F applied to previous 
12:42:37 <monochrom> ones.)
12:43:37 <merijn> Man...why are exceptions so hard >.<
12:44:04 <monochrom> They prove the rule, that's why they're so hard, it's a tall order to prove the rule!
12:44:42 <merijn> Someone should really start funding me to work on my "Haskell, but with sane exceptions and proper 1st class concurrency" >.>
12:45:06 <monochrom> More seriously, if you have 10 exceptions because they represent 10 independent failure modes, there is no way to simplify that.  Unless you refuse to solve that problem in the first place.
12:45:33 <merijn> monochrom: No, I mean exceptions as in Control.Exception
12:45:43 <merijn> Haskell's exception support is needlessly shit, tbh
12:45:47 <monochrom> That's easy to work with for me.
12:46:11 <merijn> monochrom: Only if you don't care about such silly things as "correctness" and "safety" >.>
12:46:55 <merijn> Correctly implementing brackets for non-trivial allocation actions is *hard*
12:48:05 <cocreature> fun fact: if you throw at async exception while it is reading a yaml file, it will catch that and report it as an error in the yaml file.
12:49:11 <merijn> cocreature: Pfft, I'm not even considering async exceptions at the moment
12:49:27 <merijn> Also, all async brackets in the entire ecosystem are broken, so...good luck with that
12:49:48 <cocreature> how so?
12:50:01 <monochrom> I was too afraid to ask.
12:51:03 <tom__> If you think this language's ecosystem is broke checkout nodejs
12:51:15 <merijn> Cleanup is not run with uninterruptibleMask, there was a push by me and Peaker to fix it, but in the end there was so much bikeshedding I never end up getting that patch into base/ghc
12:51:37 <merijn> Because I had better things to do than argue endlessly on mailing lists
12:52:21 <cocreature> ah I remember, iirc safe-exceptions fixes that
12:52:30 <merijn> I recently stumbled upon my own thread again, so I've been sorta floating the idea to try again, but I also need to, you know, finish a thesis
12:52:43 <geekosaur> like fixing that buggy remove thing in Cabal that deletes through symlinks?
12:53:12 <geekosaur> "oh someone might rely on that so we can't change it, people will just have to recognize it might blow away more than expected"
12:53:27 <merijn> geekosaur: "It might break some obscure portion of Hackage!"
12:53:47 <geekosaur> yeh
12:53:49 <monochrom> Yikes
12:54:13 <merijn> Because it really only breaks the portion whose cleanup relies on "blocking actions in cleanup being interruptible"
12:54:57 <merijn> Which is 1) an insane thing to rely on, 2) my experience sanity checking concurrent code concludes that no one in the community except maybe like 2 people is smart enough to think to rely on that and the 2 that are are smart enough not to
12:55:06 <merijn> cocreature: That won't fix withFile being broken!
12:55:33 <merijn> Or any bracket involving files/sockets made using Control.Exception
12:55:43 <cocreature> of course it‚Äôs fine to break the whole ecosystem due to moving `fail` around but fixing exceptions is of course unexceptable breakage :)
12:55:57 <monochrom> heh
12:56:18 <cocreature> merijn: sure, I wasn‚Äôt suggesting that safe-exceptions solves this for the ecosystem but at least it gives you a bracket function that behaves like you are proposing it should.
12:56:25 <monochrom> It is trivial to cater for those who want interruptible cleanups too.
12:56:34 <merijn> Pay me and I will add checked exception (with inference so you don't have to annotate them) handling to GHC :p
12:57:01 <monochrom> Like, new "bracket" has uninterruptible cleanup, but add "unsafeBracket" to stand for the old version.
12:57:03 <merijn> I can't promise backwards compat with the existing exception system, though >.>
12:57:13 <merijn> monochrom: Yeah
12:57:22 <EvanR> i refuse to pay you for that without first having a paper on it
12:57:46 <merijn> Fun fact: Even GHC HQ can't use bracket safely >.>
12:58:04 <hpc> checked exceptions <3
12:58:43 <merijn> EvanR: In all seriousness, I do have a mental sketch on how it should work and started a prototype a few times, but I don't have the energy outside my day job to get it finished and turn it into a paper
13:00:16 <monochrom> Oh EvanR just wants some piece of paper.  So just send a piece of paper that says "I EvanR agrees to pay $100" and also have a space for him to sign. >:)
13:00:59 <monochrom> And afterwards send a receipt so it's two papers for the price of one!
13:01:26 * geekosaur sighs and considers pinging [redacted] about that almost-convenient opening
13:01:34 <EvanR> no the "instead of a manual entry for this feature we have a paper" paper
13:01:51 <hpc> don't forget to park somewhere you aren't supposed to
13:01:55 <hpc> a paper is nothing without citations
13:02:00 <jacks2> why not? (re using bracket safely)
13:03:34 <merijn> My "lemme quickly fix my own library" has now detoured into a mess of "using ContT to bracket stuff" >.>
13:06:59 <geekosaur> jacks2, the whole point of bracket is you can clean up some resource (file or socket handle/descriptor, database connection, etc.) if something goes wrong. but as implemented, an exception during cleanup can still leak the resource
13:07:52 <merijn> It requires particularly bad luck, but that's a poor excuse!
13:07:54 <geekosaur> and then there's no way to reclaim it short of aborting the program entirely, or potentially even worse if you are requesting access to an external resource (e.g. via a lock file/daemon)
13:08:17 <dsal> Programming i s a lot more fun when you only work with things that can't go  wrong.
13:08:27 * dsal seems to have a lot of extraneous spaces the last couple of daysd.
13:09:01 <merijn> But thinking about exceptions (especially combined with concurrency!) is hard, so most people don't bother
13:11:24 <jacks2> geekosaur, I know what bracket is used for. just wasn't aware that it can leak resources. when can that happen?
13:11:36 <lavalike> this problem can't be solved by composing your call to bracket with the do-not-interrupt-me function?
13:11:44 <geekosaur> as I said, if an exception happens during cleanup
13:11:46 <merijn> jacks2: When an async exception gets thrown during a blocking action in the cleanup
13:12:16 <merijn> lavalike: Bracket already use mask to not be interrupted, mask suspends the masking upon blocking operations
13:12:26 <geekosaur> lavalike, no, bracket needs to arrange for the cleanup to be run with exceptions masked, otherwise there's still a short window in which the exception can be delivered before they're masked and the entire cleanup handler gets aborted
13:12:33 <merijn> lavalike: You need *uninterruptible*Mask to also block during blocking actions
13:12:45 <jacks2> oh. well that isn't the fault of bracket, or its ipmlementation
13:12:45 <geekosaur> ^
13:12:59 <merijn> lavalike: You could do that yourself, but it's easy to fuck up uninterruptibleMask so you don't want everyone using that
13:13:11 <merijn> jacks2: Yes it is, because the implementation should use uninterruptibleMask
13:13:45 <merijn> "Oh, but I don't use blocking actions" <- oh, but are you *sure* about that?
13:14:08 <merijn> Lots of things use MVars internally and thus, potentially block
13:14:12 <jacks2> how will that help if your clean up code throws exception before all the clean up is done? seems like I'm not understanding the issue
13:14:28 <joeyadams> I've been out of the Haskell loop for about 7 years.  Does cabal's "nix-style local builds" essentially replace Stack, or are there uses for either?
13:14:37 <merijn> jacks2: Exceptions can be thrown/raised asynchronously by other threads
13:14:46 <jacks2> yes
13:15:10 <sclv> it basically replaces it
13:15:24 <merijn> jacks2: If your cleanup code can throw, that's something you need to change in your cleanup. But you can get interrupted by async exceptions *anytime* even if your cleanup doesn't throw
13:15:32 <jacks2> yeah I get it
13:15:42 <geekosaur> joeyadams, yes and no. it solves similar problems in a different way, and in particular doesn't rely on curated package sets which partially solve a different problem
13:15:47 <merijn> joeyadams: I never used stack, so I can't say "it replaces it"
13:16:08 <merijn> joeyadams: You can achieve something close to what stack does via v2-build, yes. But it still fundamentally works very different
13:16:11 <geekosaur> but solves it in a way that's dependent on someone else
13:16:11 <jacks2> merijn, Control.Exception.Safe fixes that issue, no?
13:16:39 <merijn> jacks2: Sure, if you patch literally all uses of Control.Exception in the entire Hackage ecosystem to use that instead...
13:17:32 <jacks2> those are other people's bugs. it is their responsibility to fix it
13:17:53 <merijn> Disagree, bracket is wrong, therefore it's bracket that should be fixed
13:17:54 <lavalike> I remember a friend getting an issue opened on his rust project by a bot suggesting some update to a dependency for breakage reason, that was surprising
13:19:16 <joeyadams> Thanks.  I assume v2-build is closer to what I'm "used to", then.
13:23:42 * hackage acme-year 2019 - Get the current year  https://hackage.haskell.org/package/acme-year-2019 (JoeyAdams)
13:24:54 <f-a> sorely missing 2017-2018
13:25:37 <joeyadams> Sorry for the delay, been needing to get around to it.
13:25:55 <lavalike> it's november!!!
13:26:10 <joeyadams> Better late than never!
13:27:56 <merijn> joeyadams: If you are used to cabal-install, then yes
13:29:03 <merijn> joeyadams: It's basically "cabal-install, except everything is automatically and transparently sandboxed (so conflicting dependencies in different projects don't matter anymore), and you don't have to manually do individual steps like install dependencies/configure/build anymore"
13:29:23 <merijn> Because it will now auto-install any missing dependencies and run configure if you run "cabal build"
13:31:02 <nil> consider these two equivalent functions http://ix.io/2202 whose goal is to find the first duplicated element in a list, using a custom key function (so that `firstDuplicateBy fst [(1, "foo"), (2, "bar"), (1, "baz")]` is `(1, "baz")`). 1. is there any performance difference between the two functions? 2. is there a shorter way to express them using standard library functions?
13:31:16 <joeyadams> So if you have multiple packages you want to build/install, together, how does v2-install handle that?  Does each package have its own sandbox?
13:31:37 <joeyadams> E.g. a "core" library, a "data access" library, and the "executable"
13:31:45 <joeyadams> Where the "executable" depends on everything.
13:34:57 <merijn> joeyadams: There is a single global store where all packages get installed, but every package is tagged with a hash of its transitive dependencies/flags, so they can be reused if two things have the same config, but don't conflict if not
13:35:49 <merijn> joeyadams: Relatedly, there is now a cabal.project file you can use to depend on "unreleased" packages/versions (for example, when you are developing multiple packages in a single repo"
13:36:13 <merijn> joeyadams: See also: https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
13:37:45 <joeyadams> Thanks
13:38:40 <joeyadams> So multiple packages aside, if I build one package with a bunch of dependencies, then build a second package with a bunch of similar dependencies, the old cabal install would lock me into the versions I used for the first run.
13:38:58 <merijn> joeyadams: Right, that no longer happens
13:39:11 <joeyadams> So v2-install will pick the "best" packages for each one I build.
13:39:28 <merijn> joeyadams: It behaves as if the other package doesn't exist and if (by coincidence) it needs some of the same dependencies then it will use the already built ones
13:40:14 <joeyadams> Will the first build/install affect package selection for the second?
13:40:39 <merijn> no
13:40:45 <joeyadams> That is, if I have two unreleased packages locally, and I v2-install the first one, is it available to the second one?
13:41:09 <joeyadams> I'd expect the answer to be "no"
13:41:24 <merijn> Correct
13:41:36 <sclv> v2-install is a bit weird
13:41:47 <sclv> you normally just work with packages without "installing" them and "install" is for exes
13:41:54 <merijn> joeyadams: However, cabal.project files let you depend on tarballs, git commits, and local directories
13:42:03 <sclv> when you v2-install it puts things into a shared ghc environment file
13:42:13 <sclv> so that they're available to the raw ghci repl, etc
13:42:22 <sclv> and compiling with ghc outside of using cabal
13:42:37 <sclv> but you have the manage that env file, which isn't yet super easy (although its easy to delete stuff by hand from it)
13:42:58 <sclv> otherwise you can v2-install sometihng and then something else can fail to v2 install because the calculated deps will mismatch
13:43:50 <sm[m]> Urgh
13:45:11 <sm[m]> v2-install still isn‚Äôt isolated ?
13:45:11 <sclv> i mean yeah, on the one hand it needs improvements to the UI (cabal-env tool helps here) but otoh, you can just not use that workflow while its not polished
13:45:20 <sclv> v2-install of exe is isolated
13:45:31 <sclv> v2-install of a package is definitionally not isolated
13:45:33 <sclv> taht's the point
13:45:53 <merijn> v2-install of an exe is (by default) just a symlink into the global store
13:46:00 <sm[m]> Good, I probably misunderstood
13:46:01 <sclv> the only reason to do it (and effect it has) is to mutate the global package env
13:46:04 <joeyadams> nil>: That's O(n^2), so not efficient for a large list.  You might want to use a Set instead.  I gotta hop off, hopefully someone else can help.
13:46:24 <joeyadams> But I imagine passing f through instead of making it a closed-over variable *might* help a little.
13:46:36 <sclv> to be precise s/of a package/of a lib/
13:46:42 <sm[m]> But I thought I heard you say ‚Äúan install can cause a later install to fail‚Äù
13:46:49 <sclv> _of a lib_
13:47:04 <sclv> they all have to live in the same global package env
13:47:21 <geekosaur> if you v2-install a lib, you are specifically asking for it to be globally visible
13:47:26 <geekosaur> usually you don't want to do this
13:48:08 <geekosaur> precisely because you're specifically asking for it to be a confounding influence on cabal's attempt to keep things in their own safe containers
13:51:00 <geekosaur> (this can make sense in some cases, e.g. xmonad is kinda ungodly slow to start up with a cabal v2 build script because everything has to be loaded and checked; I'm strongly tempted to v2-install xmonad and xmonad-contrib and go back to no build script because they won't generally conflict with anything else)
13:51:51 <merijn> geekosaur: hmm, probably a bit early to start relying on multiple public libraries in a package, I guess?
13:52:00 <merijn> eh, wait that wasn't for you specifically :)
13:52:08 <merijn> tab completion fail :p
13:52:15 <sclv> check the tickets in cabal and hackage first (and maybe haddock)?
13:52:19 <sclv> there's some rough edges
13:52:27 <sclv> some of it might just be presentation layer with showing the addocks
13:52:33 <sclv> but not sure if that's the only issue
13:52:41 <merijn> sclv: Basically I have a couple of strongly related packages and bumping them in lockstep is kinda annoying
13:53:03 <sclv> i mean after you check the tickets, you may want to be an early adopter still and see how rough the edges are
13:53:10 <sclv> we sorta need that to ever sort things out :-P
14:11:32 <d34df00d> Hi!
14:11:49 <d34df00d> I got a question about monads and constraints.
14:12:17 <d34df00d> So there is `forConcurrently` from the async package that lives in IO.
14:12:40 <d34df00d> And there is a computation that I wrote that lives in a huge monadic stack with IO at the bottom.
14:13:24 <d34df00d> So I wrote my own wrapper forConcurrently' that executes and rewraps that stack:
14:13:47 <d34df00d> https://bpaste.net/show/GLTTM
14:14:50 <d34df00d> Now let's say I have a slightly different monadic stack elsewhere (maybe with one more constraint in the loop). What's the best way to make my `forConcurrently'` wrapper polymorphic on the stack? I guess I can be polymorphic on the constraint, but I still have to pass the unwrapping/rewrapping logic somehow.
14:15:01 <d34df00d> What's the common approach to this?
14:25:28 <joeyadams> d34df00d: I think you want something like MonadTransControl: http://hackage.haskell.org/package/monad-control-1.0.2.3/docs/Control-Monad-Trans-Control.html
14:27:26 <joeyadams> forConcurrently is similar in nature to bracket in that it's an IO combinator.
14:27:56 <joeyadams> This is a way people lift bracket, mask, etc.  It should work for forConcurrently too.
14:28:24 <joeyadams> The library provides MonadTransControl instances for the standard monad transformers, so your monad is probably covered.
14:29:07 <d34df00d> I have MonadLogger in my stack with is not that standard I think.
14:29:33 <joeyadams> You can add a MonadTransControl instance if it's missing.
14:29:33 <d34df00d> I'm also gonna have MonadReader r m, Has Foo r in my constraints. Dunno how it handles the Has part.
14:29:55 <d34df00d> Thanks for the link, I haven't had a change to look carefully at that class. Time to finally study it!
14:30:12 <joeyadams> MonadTrans is the only constraint you should need for this.
14:32:24 <joeyadams> Your signature could be something like this:
14:32:25 <joeyadams> forConcurrently' :: (MonadTransControl t, MonadIO m) => [a] -> (a -> t m b) -> t m [b]
14:32:30 <d34df00d> Damn, why doesn't MonadState s m imply MonadReader s m? I'd like to seamlessly call reading-only functions in my stateful computations.
14:32:32 <joeyadams> I haven't done Haskell in so long, that could be way off.
14:33:02 <d34df00d> joeyadams: that looks really interesting! And it makes sense ‚Äî why does forConcurrently care at all about the specifics of my computation as long as its IO?
14:34:00 <joeyadams> It needs a way to distribute environment to each callback.  MonadTrans takes care of that.
14:35:09 <joeyadams> Watch out for gotchas that stem from Error and State monads.  You are running the actions concurrently, so state won't thread through, and errors...not sure how those are to be handled.
14:35:30 <d34df00d> I'm runExceptT'ing and sequence'ing the results anyway.
14:36:06 <d34df00d> So... that's the sad part: looks like I actually have to pass the specifics of my stack to forConcurrently' for correct combining of the results.
14:36:07 <d34df00d> Damn :(
14:38:32 <joeyadams> MonadForConcurrently :P
14:39:20 <joeyadams> You could make a constraint defining whatever method you need, and only worry about it when you implement the monad in question.
14:39:24 <dansho> does anybody know how to build digest with stack on nixos? can't find zlib
14:40:01 <d34df00d> Eh, this gets overly verbose.
14:40:06 <d34df00d> Probably not worth it for a non-library.
14:41:22 <joeyadams> But seriously, you could define a class to represent the needed "combine results" operation.
14:42:56 <joeyadams> That's not used to combine results into the final array; MonadTrans and forConcurrently handle that.
14:43:30 <joeyadams> But it's used to handle what should happen to all those concurrent actions at the end, e.g. concatenate logging output.
14:43:45 <joeyadams> Or fail on the first error encountered.
14:47:40 <Clint> is there a data type like These but without the That?
14:51:35 <nitrix> Clint, data Foo a b = This a | These a b
14:53:56 <Clint> nitrix: thanks :P
14:59:21 <nil> (a, Maybe b)
14:59:34 <Clint> nil: that's exactly what i want to replace
15:05:36 <koz_> Clint: Either a (a, b). :P
15:05:57 <Clint> koz_: thought about it but it seems equally awkward
15:06:13 <koz_> Yeah, it's a bit awkward. You can make the type less awkward by doing like
15:06:26 <koz_> type OneOrBoth a b = Either a (a, b)
15:06:28 <koz_> ANd some patterns.
15:06:38 <koz_> But at that point, you might as well roll your own and automagic some instances.
15:06:51 <Clint> alas, i was hoping somebody had a package for this
15:07:11 <Clint> thanks for the suggestion
15:07:56 <koz_> There isn't one I'm aware of, sadly.
15:08:18 <koz_> You could make the roll-your-own-ing easier by automagically deriving Generic, then using lyxia's all-singing, all-dancing, all-deriving library to derive everything.
15:10:06 <Clint> koz_: generic-data?
15:10:11 <koz_> Clint: Yeah that one.
15:10:14 <koz_> I can never remember its name.
15:10:31 <koz_> There are three things in Haskell-land I will never remember:
15:10:38 <koz_> 1) Order of arguments to foldr's function
15:10:44 <koz_> 2) The name of lyxia's library
15:11:08 <koz_> 3) That liftA2 needs an import
15:12:57 <koz_> (well, liftA2 and Alternative)
15:15:33 <d34df00d> Alright, now I need pure constraint polymorphism.
15:16:00 <d34df00d> Is it possible to write a type along the lines of this: (c m, MonadState s m) => (forall m'. (MonadReader r m', Has s r, c m') => m' a) -> m a ?
15:16:27 <d34df00d> Here `c` is the fun part and something that doesn't work. It's intended to be instantiated with the rest of the constraints that the first argument of this function has.
15:16:29 <koz_> d34df00d: Try that signature and see what extensions GHC requests.
15:16:42 <koz_> (you may need ConstraintKinds, and probably a few things)
15:16:48 <d34df00d> I have all that, but I'm getting
15:16:59 <jle`> d34df00d: well, what do you want that function to do?
15:17:00 <d34df00d> Could not deduce: c0 m from the context: (c m, MonadState s m) bla bla bla
15:17:12 <koz_> d34df00d: That's a type variable scoping problem.
15:17:14 <jle`> that sounds like you need AllowAmbiguousTypes
15:17:19 <d34df00d> jle`: `get` `s` from the `m` and run the passed action with that extra info attached.
15:17:24 <koz_> jle`: I think ScopedTypeVariables as well.
15:17:40 <d34df00d> koz_: i have that enabled. Do I need to forall-list everything?
15:17:41 <jle`> that specific error would happen before you even try to write the function, i think
15:17:49 <koz_> d34df00d: If you wanna bind them.
15:17:55 <jle`> that type signature itself is illegal without AllowAmbiguousTypes
15:17:57 <koz_> (I do it in general anyway)
15:18:01 <koz_> jle`: Good point.
15:18:06 <d34df00d> jle`: why is it ambiguous?
15:18:11 <d34df00d> And why doesn't ghc complain about it?
15:18:20 <jle`> d34df00d: because neither the input or the output allows you to infer what 'c' is
15:18:28 <d34df00d> Why? Input allows this!
15:18:30 <jle`> d34df00d: i believe it should complain about it in most cases
15:18:34 <jle`> d34df00d: does it?
15:18:48 <d34df00d> Alright, let's simplify it, it has too much domain-specific crap.
15:18:58 <jle`> d34df00d: what if i passed it `pure ()` ?
15:19:01 <jle`> how would you infer 'c' from that input?
15:19:05 <d34df00d> (c m, MonadState s m) => (forall m'. (MonadReader s m', c m') => m' a) -> m a ?
15:19:18 <d34df00d> 'c' is the rest of the constraints that the action has besides `MonadReader s m'`.
15:19:23 <jle`> so i can pass that function `pure ()`
15:19:26 <d34df00d> I'm not sure if it's unifiable, though.
15:19:26 <jle`> as valid input
15:19:32 <d34df00d> Sure. Then 'c' is an empty set.
15:19:37 <jle`> since `pure ()` is a valid value of type forall m' (MonadReader s m', c m') => m' a)
15:19:58 <jle`> *but* it's also a valid value of type forall m' (MonadReader s m', MonadIO m') => m' a)
15:20:10 <jle`> and it's also a valid value of type forall m'. (MonadReader s m', Alternative m') => m' a)
15:20:29 <jle`> and it's also a valid value of type forall m' (MonadREader s m', MonadRail m') => m' a
15:20:30 <d34df00d> As usual, you get the smallest possible constraint sent, don't you?
15:20:32 <jle`> if you get my point
15:21:05 <d34df00d> The compiler is perfectly happy to derive that `foo = get >>= const (pure ())` is MonadState something (modulo the ambiguity of the state param itself).
15:21:16 <d34df00d> I don't see why it wouldn't be able to to something similar in this case.
15:21:20 <jle`> i think the implication is backwards from what you are suggesting
15:21:56 <jle`> d34df00d: 'c' here is given by the caller, so it means that you are using it to constrain what possible value the input can be
15:22:06 <jle`> so the function needs to know *wnat* to constrain it by
15:22:11 <jle`> *what
15:22:25 <jle`> but also here c is a type variable, not a constraint
15:22:34 <d34df00d> So just take the set of the constraints of the caller, subtract MonadReader (or not, duplicates are OK in the list aren't they?) and be happy with it!
15:23:09 <jle`> d34df00d: the constraints of the caller are what is not knowin the first place
15:23:21 <koz_> Unless the caller spells them out.
15:23:27 <koz_> GHC can't magically mind-read.
15:23:49 <d34df00d> Spells out in what sense?
15:23:56 <koz_> Type applications usually.
15:23:59 <d34df00d> GHC can't mind-read but it can type-infer.
15:24:01 <jle`> yeah, it can't know that the caller "wants" an empty constraint, or they "want" MonadIO, or it wants "Alterantive"
15:24:05 <koz_> The simplest example of this is something like
15:24:13 <koz_> magicNumber :: (Num a) => a
15:24:19 <jle`> d34df00d: basically the caller here is supposed to give your function what 'c' to use
15:24:24 <d34df00d> I still don't understand why it can't just take the smallest possible set of constraints that the passed action requires.
15:24:29 <koz_> How is GHC to know whether you want Int, Integer, Float, Vector 3 Int, etc?
15:24:38 <koz_> d34df00d: Such a set doesn't always exist.
15:24:42 * hackage postgresql-copy-escape 0.1.0.1 - Format data to feed to a PostgreSQL COPY FROM statement  https://hackage.haskell.org/package/postgresql-copy-escape-0.1.0.1 (JoeyAdams)
15:24:42 <koz_> For any notion of 'smallest'.
15:24:49 <jle`> hm, i think the issue here is a little different than what you have
15:24:54 <d34df00d> koz_: why?
15:24:55 <jle`> the problem here is that c is not a constraint
15:25:00 <jle`> the problemis that c is a *type variable*
15:25:08 <jle`> 'c m'' is a constraint, 'c m' is a constraint
15:25:41 <jle`> d34df00d: okay, so what 'c' would you infer if you had `myFunction (pure ())`?
15:25:53 <d34df00d> c m = ()
15:25:55 <koz_> c has kind k -> Constraint. k _could be_ a lot of different things.
15:26:13 <jle`> if you had myFunction :: forall c m. (c m, MOnadState s m) => (forall m'. (MOnadReader s m', c m') => m' a) -> m a
15:26:17 <d34df00d> koz_: but does it affect anything at all?
15:26:22 <jle`> d34df00d: no, what woudl *c* be?
15:26:29 <jle`> i'm asking what would *c* be, not what would *c m* be
15:26:32 <jle`> do you see the difference?
15:26:33 <d34df00d> Ah.
15:26:37 <d34df00d> I see what you're getting to.
15:26:45 <jle`> what would `c` be if i called it `myFunction (pure ())`?
15:26:51 <jle`> how could GHC possibly infer what 'c' would be?
15:27:06 <jle`> well, i can ask...how can *you* know what c would be?
15:27:13 <jle`> do *you* even have a good answer? :P
15:27:16 <jle`> if you can't think of one, how can GHC?
15:27:22 <d34df00d> You're saying allowing inferring `c = \m -> ()` (in some pseudocode) is undecidable or something?
15:27:59 <jle`> you want to infer c to be `const ()` ?
15:28:04 <jle`> is that...even a typeclass?
15:28:14 <jle`> what typeclass gives you const ()?
15:28:40 <d34df00d> Why should it be a typeclass? It's a constraint set.
15:28:42 <jle`> it's not just undecidable, it's meaningless
15:28:52 <d34df00d> I don't have a good intuition for the metatheory of constraints though.
15:29:01 <jle`> d34df00d: it's something of kind ((Type -> Type) -> Constraint)
15:29:12 <jle`> aka, Monad, Alternative, Functor, MonadState s
15:29:14 <d34df00d> So it's a function mapping a variable of type (* -> *) to something of type Constraint.
15:30:08 <jle`> yeah, and there's no way to infer what that would be
15:30:24 <jle`> in fact in this case it can be literally *anyything*
15:30:30 <d34df00d> I guess if I really want to know why I need to read some papers on how constraints work.
15:30:40 <jle`> if you do `myFUnction (pure ())` ... what could c be?
15:30:49 <d34df00d> c = const () :)
15:30:53 <jle`> it could be Monad. it could be Alternative. it could be MonadPlus. 
15:31:00 <jle`> it could be MonadWriter String
15:31:01 <koz_> It could be a combination of these even.
15:31:20 <jle`> in fact it could literally be *anything* of kind (* -> *) -> Constraint
15:31:20 <d34df00d> You have a partial order on constraints (I hope), why not just choose the minimal element?
15:31:27 <d34df00d> Which I hope would also be the least.
15:31:31 <jle`> we have a partial order on constraints, but c is not a constraint
15:31:37 <jle`> c is a (* -> *) -> Constraint
15:31:44 <koz_> A _partial_ order doesn't necessarily imply a unique minimum of any two elements.
15:31:52 <d34df00d> Yeah, c = \m -> ?hole
15:31:53 <koz_> Or _any_ minimum for that matter.
15:31:58 <d34df00d> And ?hole is a constraint with environment m.
15:32:12 <jle`> d34df00d: yeah, you can't really infer "Type functions"
15:32:23 <d34df00d> koz_: it's well-founded though, so there _is_ a minimum.
15:32:29 <d34df00d> Probably not unique though.
15:32:43 <d34df00d> But my intuition is that lack of the least element would break lots of things.
15:32:48 <jle`> we can infer types but we can't infer "type functions"
15:32:50 <jle`> which is what c is
15:33:05 <koz_> Something something undecidability something something dependent type inference something
15:33:09 <jle`> or well, we can in some simple cases: where it shows up in the input or the output
15:33:36 <d34df00d> At this point I really hope constraints aren't as expressive as deptypes.
15:33:44 <jle`> d34df00d: but even you, as a human being, cannot solve that constraint
15:34:03 <koz_> The problem isn't constraints - it's c, which a function that _returns_ a constraint (at the type level).
15:34:06 <jle`> you cannot even give me an answer for what it should be, other than psuedocode
15:34:27 <d34df00d> Sure, cause I lack syntax for that.
15:34:33 <d34df00d> Like, I mean, proper haskell syntax.
15:34:41 <jle`> we all lack proper haskell syntax :)
15:34:45 <koz_> LOL
15:34:53 <jle`> or are you suggesting that the proper haskell syntax might exist, but you don't know it?
15:34:58 <d34df00d> –ù—É–∑—é
15:35:00 <d34df00d> Yep, pardon.
15:35:18 <jle`> ah. so you think that that thing you wrote should be expressible in haskell, even though you don't know how ot write it
15:35:27 <d34df00d> I don't think it should.
15:35:31 <d34df00d> I was hoping it might :)
15:35:51 <[itchyjunk]> hmmm
15:36:12 <jle`> d34df00d: in general for type variables in specific, the rules for instantiating them are basic enough to be understood from simple principles
15:36:19 <[itchyjunk]> i am trying to define a recursive sequence where the nth term depends on the n-1 and n-2th term
15:36:19 <d34df00d> koz_: also, unless you throw DataKinds at it, the type system is pretty limited isn't it?
15:36:21 <d34df00d> STLC lifted to types.
15:36:29 <d34df00d> And there type inference (and term inference!!111) works.
15:36:42 <jle`> d34df00d: basically you cannot call any function without a specific instantiation of every type variable, so unless you can think of one, it doesn't work
15:36:56 <jle`> d34df00d: in ghc, we have some 'hacks' around this, from ExtendedDEfaulting
15:36:59 <koz_> d34df00d: DataKinds isn't really needed for this - GHC's type-and-kind-unification is always in effect. What DataKinds does is promotion.
15:37:16 <jle`> d34df00d: which is why you can call `print 1` in ghc without issues.  `print 1` only works because of dirty ad-hoc hacks we have in haskell
15:37:41 <jle`> d34df00d: that's because print :: Show a => a -> IO (), needs to know what 'a' has to be.  and so *normally*, `print 1` should not compile
15:37:46 <koz_> It means if I define the type 'Foo' consisting of two constructors 'Bar' and 'Baz', I then get the _kind_ Foo, consisting of two _types_ ''Bar' and ''Baz'.
15:38:00 <d34df00d> koz_: so even if I wanted to do term inference in the universe where my types are STLC with the single base type of *, I cannot do that because type-and-kind-unification?
15:38:03 <koz_> (sorry for the double-ticking there, but hopefully it's clear)
15:38:05 <jle`> d34df00d: it's just that in haskell we have some ad-hoc rules specifically for numbers and numeric literals and stuff to make life easier
15:38:15 <koz_> d34df00d: What's STLC sorry.
15:38:21 <koz_> s/\./?/
15:38:21 <d34df00d> simply-typed lambda calculus.
15:38:35 <d34df00d> There you can do function inference based on types.
15:38:41 <koz_> I think I'll let jle` answer this one.
15:38:52 <koz_> My knowledge of this isn't comprehensive enough to say anything intelligent.
15:38:57 <jle`> yeah, the issue here really isn't on that level i think -- the fundamental problem can be illustrated in an example as simple as `print 1`
15:39:19 <jle`> you're essentially running into the same problem that `print 1` faces, except you don't have the help of the ugly ad-hoc extended defaulting system we have
15:39:40 <jle`> `print 1` shouldn't compile, which is somewhat of a glaring fault in haskell's typeclass based system
15:40:05 <jle`> but we have a rule that says "ok so if you have a forall a. Num a, and we don't know the variable, let's just say *specifically* for Num, it's Int"
15:40:06 <d34df00d> But you don't have this problem on type level do you?
15:40:22 <jle`> and that rule is hard-coded into haskell, with Num and with Integer
15:40:35 <koz_> jle`: Oh, so _that_'s what all that defaulting to Integer warning means.
15:40:43 <koz_> Thanks, that makes more sense now.
15:41:13 <d34df00d> You don't have "kindclasses", the kind-level part of Haskell 2010 is pretty boring, etc. So function inference there _might_ be decidable and efficient (in algorithmic sense).
15:41:20 <jle`> d34df00d: what do you man by type level?
15:41:36 <d34df00d> I mean you can derive a type function of kind (* -> *) -> (* -> *)
15:41:45 <d34df00d> Infer that is.
15:41:59 <jle`> only in some specific situations
15:42:24 <d34df00d> Why? In every Haskell 2010 situation (if I know the set of what Haskell 2010 includes correctly)
15:42:29 <jle`> namely for injective/constructive functions coming from type constructors
15:42:41 <jle`> ah, if we're just in haskell 2010, then yeah
15:43:03 <jle`> but haskell 2010 doesn't relaly have a concept of type functions, just of type constructors you can match and pair up
15:43:34 <jle`> unifying `p a ~ Bar a` doesn't mean finding a type function that has the same effect that Bar has
15:43:55 <jle`> it's just literally using the rules [a b] ~ [c d] => [a ~ c], [b ~ d]
15:44:16 <jle`> so it's not reasoning with "type functions", but rather just with type constructors and their applications
15:45:53 <jle`> d34df00d: in any case it's okay to have a polymorphic value, but if you ever actually "call" something, you need to make sure all of the type variables are 'filled in'
15:46:14 <jle`> with specific, concrete, non-polymorphic, chosen things
15:46:21 <d34df00d> ...and I see that even if the typechecker can infer what c m' is, it can't reasonably infer c.
15:46:40 <jle`> non-arbitrarily and unique chosen things
15:46:57 <jle`> constraints have a different sort of magic, but now we are no longer dealing with constraints, but rather with type variables
15:47:17 <jle`> so you've somewhat neutered the power of ghc's constraint magic by making it try to guess a type variable, which it can only do through normal unification methods
15:47:36 <jle`> type variables can't be chosen by a 'minimal solution', they have to be uniquely determined
15:47:43 <jle`> (as opposed to typeclasses)
15:48:08 <jle`> uniquely determined or else left as polymorphic to the outside caller
15:48:36 <d34df00d> ...and this is why I'm extremely unproductive with recreational haskell.
15:48:37 <d34df00d> But it's fun.
15:48:41 <jle`> [itchyjunk]: did you have a specific question?
15:48:47 <d34df00d> jle`: thanks for the discussion, that's enlightening.
15:49:06 <jle`> np :) for what it's worth i run into these 'why is this ambiguous' situations all the time and i have to reason myself through them
15:50:05 <jle`> i have some basic tricks that i usually follow but usually it boils down to just 'what would the type variable be' for given inputs i try to think of :)
15:50:08 <d34df00d> I guess I'll just inline my `stateToReader` function.
15:50:26 <d34df00d> `ask >>= \env -> runReaderT act env` is not that hard.
15:51:04 <jle`> you could get what you had earlier to work by just turning on -XAllowAmbiguousTypes and having the user give a type application, or maybe taking `Proxy c` as an input
15:51:20 <d34df00d> I really don't want to spell out 'c'.
15:51:23 <d34df00d> It's huuuge.
15:52:05 <jle`> hm
15:52:20 <jle`> if all you do is use runReaderT on the input, you can also just take it monomorphically
15:52:31 <d34df00d> What do you mean?
15:52:41 <jle`> myFunction :: forall m. MonadState s m => (ReaderT s a) -> m a
15:52:45 <d34df00d> Damn, it should be get >>= ... but whatever.
15:53:04 <jle`> ah wait that one doesn't work
15:53:59 <jle`> :t \act -> get >>= \env -> runReaderT act env
15:54:01 <lambdabot> MonadState r m => ReaderT r m b -> m b
15:54:07 <jle`> that's what i meant :)
15:54:26 <d34df00d> Ah.
15:54:28 <d34df00d> Interesting.
15:54:51 <jle`> d34df00d: that function will *still* take a value of type (forall m'. (MonadReader r m', c m') => m a)
15:55:24 <jle`> the difference is that it 'leaks' the implementation, i suppose
15:55:33 <d34df00d> Uh, that's harder than that.
15:55:37 <d34df00d> Let me try smth out...
15:56:07 <jle`> ReaderT r m b is a 'supertype' of forall m'. (MonadReader r m', c m') => m a.  or is it subtype. i always mix up the direction here
15:58:48 <d34df00d> jle`: yeah, that's more complicated than that.
15:59:14 <d34df00d> jle`: one of my act's constraints is (MonadReader r m, Has Foo r)
15:59:17 <d34df00d> I wanna add Bar to that Foo.
16:00:08 <d34df00d> So in reality my inlined version is `get >>= \current -> ask >>= \env -> runReaderT act (current, env)`
16:00:35 <jle`> :t \act -> get >>= \current -> ask >>= \env -> runReaderT act (current, env)
16:00:36 <lambdabot> (MonadState a m, MonadReader b1 m) => ReaderT (a, b1) m b2 -> m b2
16:01:30 <d34df00d> > Could not deduce (Has (s, r) r) arising from a use of ‚Äòask‚Äô
16:01:33 <lambdabot>  <hint>:1:52: error: parse error on input ‚Äòof‚Äô
16:01:37 <d34df00d> Yeah, my Has implementation checks that the types are unique.
16:01:45 <d34df00d> So I'll need to express that in types too...
16:01:52 <d34df00d> Scratch that I guess.
16:09:24 <LCRERGO> I've been programming in XMonad and I've been seeing type anotations like this: "workspaces :: ![String]". What does the '!' stand for?
16:09:44 <EvanR> koz_: the other day c_wraith clued me into a mnemonic to remember the order of arguments to foldr and foldl's visitor. When you are foldr-ing the next list element is on the left, and you're "going left", so it's the first arg. In foldl the next list element is on the right, you're "going right", so it's the second argument. Of course... this requires a kind of odd understanding of fold action being eager
16:10:12 <EvanR> And it's backwards from their names
16:10:15 <c_wraith> I said that? huh. don't remember that conversation at all
16:10:15 <koz_> EvanR: That's very interesting.
16:10:17 <EvanR> so YMMV
16:10:25 <koz_> That may actually help me learn this, for once.
16:10:33 <EvanR> c_wraith: well i think you said it more clearly
16:10:39 <EvanR> check logs :)
16:11:29 <koz_> c_wraith - bringing us ghostly wisdom.
16:12:33 <stilgart> LCRERGO: ! is for stricness... but you can drop it (especially this one)
16:13:04 <EvanR> LCRERGO: strict field. But a ![String] field doesn't really do anything
16:14:14 <EvanR> it occurs to me that if someone wants a list that is always fully evaluated, you probably don't want a list
16:15:51 <EvanR> er, they don't
16:27:10 <monochrom> yeah probably an array instead
16:27:26 <monochrom> But python "contributed" to confusing the two.
16:27:47 <monochrom> Greatest contribution to humanity ever.
16:30:02 <EvanR> also don't tell lisp what i said
16:30:07 <koz_> EvanR: LOL
16:30:10 <Uniaika> monochrom: this and stack traces at the expense of TCO :P
16:30:22 <koz_> That right there is my _biggest_ gripe with Python.
16:31:38 <EvanR> python taught me that the difference between a tuple and a list is that tuples are immutable
16:32:11 * hackage git-config 0.1.2 - A simple parser for Git configuration files  https://hackage.haskell.org/package/git-config-0.1.2 (ffreire)
16:32:42 <EvanR> which seems like a totally random design decision
16:32:48 <Uniaika> I honestly think we could incorporate more FP techniques when teaching Python if we could have structural sharing (so that we can treat its data structures as immutable)
16:33:19 <Uniaika> (except of course for tuples, although I wonder to which extent they are immutable)
16:33:54 <Uniaika> anyway, I guess we'll have to fallback on the one true point-free functional programming language packaged with every computer on Earth: Excel! 
16:34:04 <Uniaika> good night :)
16:35:46 <jle`> koz_: my way of remembering foldr is to remember that foldr f z turns ':' into f, and [] into z
16:35:53 <jle`> koz_: and what's the type of (:)?
16:35:56 <jle`> :t (:)
16:35:58 <lambdabot> a -> [a] -> [a]
16:36:20 <jle`> and so foldr takes an `a -> b -> b` and a `b`
16:36:31 <koz_> jle`: Yeah, that actually makes a lot of sense.
16:36:41 <jle`> so i remember it by recalling the type of (:) :)
16:37:17 <koz_> Yeah, that's sensible.
16:40:02 <dsal> I just remember it because I like foldr and the args are x o
16:40:12 <dsal> Of course, if you don't name the args x o, then that's less useful.
16:40:17 <hpc> there's a more general idea behind that mnemonic for foldr that applies to other types
16:40:40 <hpc> i don't know what the name of the generalization is, but you basically just take all the constructors in order, do a simple translation to function parameters, and bam you have foldr
16:41:11 <hpc> :t maybe
16:41:12 <lambdabot> b -> (a -> b) -> Maybe a -> b
16:41:15 <hpc> :t either
16:41:16 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
16:41:24 <hpc> those are the same concept applied to Maybe and Either
16:41:53 <jle`> yeah, foldr, maybe, either, bool can be said to have to 'typecheck' to be 'id' when their constructors are given
16:41:56 <jle`> :t foldr (:) []
16:41:58 <lambdabot> Foldable t => t a -> [a]
16:42:03 <jle`> :t maybe Nothing Just
16:42:04 <lambdabot> Maybe a -> Maybe a
16:42:06 <jle`> :t either Left Right
16:42:07 <lambdabot> Either a b -> Either a b
16:42:21 <jle`> :t bool False True
16:42:22 <lambdabot> Bool -> Bool
16:42:31 <jle`> (constructors are given and in order)
16:42:35 <jle`> :t uncurry (,)
16:42:37 <lambdabot> (a, b) -> (a, b)
16:42:47 <jle`> ^ in case you ever wanted to remember the order of parameters in uncurry
16:42:57 <sleblanc> neat
16:43:49 <hpc> these sorts of functions can define any function on their respective data types
16:44:18 <hpc> so like for foldr, something like "for all f, there exists x and y such that foldr x y = f"
16:45:25 <hpc> because if you expand out foldr, you get something like
16:45:30 <hpc> foldr [] = y
16:45:35 <hpc> foldr (a:as) = x a as
16:51:40 <monochrom> catamorphism
16:54:01 <evelyn> some of those recursion are called really quite ridiculous things
16:54:06 <evelyn> recursion schemes*
16:55:42 * hackage lambda-options 1.0.2.0 - Declarative command-line parser using type-driven pattern matching.  https://hackage.haskell.org/package/lambda-options-1.0.2.0 (ThomasEding)
17:29:07 <talles> Hi, is there anybody online?
17:29:24 <koz_> talles: Sure. Feel free to ask whatever questions you may have, as long as they're on topic.
17:29:46 <talles> Thanks koz_
17:30:17 <talles> I'm have a question about tuples in Haskell,
17:31:13 <talles> I have a random integer tuple, [(a,b)] and a matrix. I need to use these random numbers as the coordinates in the matrix, to populate it with a value 
17:31:38 <talles> There is the function setElem (setElem :: a -> (Int, Int) -> Matrix a -> Matrix a)
17:31:58 <koz_> [(a,b)] isn't a _single_ tuple, it's a list of them.
17:32:06 <talles> In this case, I need to use the pairs in the tuple (a,b) as the parameter in the setElem
17:32:18 <talles> I'm very new in Haskell, so I apologize if I say something stupid 
17:32:32 <koz_> talles: It's fine - I'm not assuming anything, just wanted to make sure I understood correctly.
17:32:33 <talles> A list of tuples
17:34:03 <koz_> Well, a list of 'any old' tuples won't do - they have to be specifically (Int,Int).
17:34:05 <talles> I've googled a lot, read many articles about, but I didn't get an answer to go around this problema 
17:34:46 <koz_> That signature for setElem says 'if you give me an element (that's the a), and a row-column location (that's the (Int, Int)), and a Matrix full of as, I'll give you a Matrix full of as (with the thing you want replaced in that place)'.
17:35:37 <koz_> So, what exactly do you have a list of random of?
17:36:35 <talles> I'm developing a minesweeper game, the random numbers are the coordinates in the matrix. The range is from 1 to 20, for x and y. I generate a list of x random numbers 
17:36:46 <talles> then a list of y random numbers, then I combine them in a list 
17:36:56 <koz_> So what you're saying is that you have [(Int, Int)], right?
17:37:02 <talles> yeap 
17:37:12 <koz_> OK, that makes sense. So then, what's the 'a' in your Matrix?
17:37:19 <talles> Can I send to you the functions?
17:37:36 <koz_> talles: You can - use a paste service please. gist.github.org is preferred, but anythign will do in a pinch.
17:38:55 <talles> This the functions, of combine and random 
17:38:56 <talles> https://gist.github.com/InluxBDX/3dccb7239432d3eea50807c71037b9b3
17:43:15 <koz_> Thanks, but this doesn't quite answer my question. 
17:43:27 <koz_> Matrix a means 'a matrix full of a'.
17:43:37 <koz_> You've generated a bunch of random _positions_ in said matrix.
17:43:48 <koz_> You haven't told me _what_ goes in said matrix at those, or indeed, any other, positions.
17:46:15 <talles> So, in these positions I will place a value that represents a mine. 
17:46:30 <koz_> Let's keep it simple then.
17:46:40 <koz_> data CellType = Mine | Empty
17:46:52 <koz_> (you can elaborate on that as much as you like later)
17:46:57 <koz_> So, let's look at that function again.
17:47:11 <koz_> setElem :: a -> (Int, Int) -> Matrix a -> Matrix a
17:47:22 <koz_> In our case, since we have a matrix full of CellTypes, this becomes
17:47:37 <koz_> setElem :: CellType -> (Int, Int) -> Matrix CellType -> Matrix CellType
17:47:43 <talles> I think the way I generate the matrix is wrong 
17:47:44 <koz_> With me so far?
17:47:52 <talles> Yes 
17:47:53 <koz_> Hold up, let's not get ahead of ourselves.
17:48:01 <koz_> So, what you wanna do is roughly this:
17:48:05 <koz_> 1) Generate your mine positions, somehow.
17:48:21 <koz_> 2) Create a Matrix where _every_ cell is Empty.
17:48:38 <koz_> 3) Rip through the list from 1), and replace each of those positions with Mine.
17:48:40 <koz_> Sound about right?
17:49:48 <talles> Yes, but I didn't get the point of how I'll generate the matrix using the list of random numbers 
17:50:00 <koz_> We're not there yet, lol.
17:50:10 <koz_> You _first_ need a matrix where every cell is empty. Can you see why?
17:50:50 <talles> Each empty cell will receive the mines, given the random positions 
17:51:03 <koz_> But we still have to have something _in all the others_, right?
17:51:19 <koz_> Now, judging by what you've written, you've got 1) down.
17:51:23 <koz_> So let's think about 2).
17:51:30 <koz_> What Matrix library are you using?
17:51:48 <talles> Data.Matrix 
17:52:08 <talles> I create the matrix this way = table = matrix 20 20 $ \(i,j) -> "#
17:52:10 <koz_> Library, not package.
17:52:54 <koz_> This one? https://hackage.haskell.org/package/hmatrix
17:53:12 * hackage hopenpgp-tools 0.22 - hOpenPGP-based command-line tools  https://hackage.haskell.org/package/hopenpgp-tools-0.22 (ClintAdams)
17:53:14 <talles> This one 
17:53:15 <talles> https://hackage.haskell.org/package/matrix-0.2.2/docs/Data-Matrix.html
17:53:21 <koz_> Ah, OK.
17:53:50 <koz_> Now, what you pasted is close, but not quite what we need.
17:53:56 <koz_> Let's look at the type of matrix.
17:54:09 <koz_> It's matrix :: Int -> Int -> ((Int, Int) -> a) -> Matrix a
17:54:17 <koz_> And, as we recall, we have CellType for a.
17:54:20 <koz_> So, filling this in, we have
17:54:33 <koz_> matrix :: Int -> Int -> ((Int, Int) -> CellType) -> Matrix CellType
17:54:42 * hackage red-black-record 2.1.0.3 - Extensible records and variants indexed by a type-level Red-Black tree.  https://hackage.haskell.org/package/red-black-record-2.1.0.3 (DanielDiazCarrete)
17:55:10 <talles> Ok
17:55:23 <koz_> This says something like 'If you give me a number of rows, a number of columns, and a rule which translates a row,column pair into an element, I'll make you a Matrix with that rule applied everywhere, of those dimensions'.
17:55:42 <koz_> Now, for a matrix where _every_ cell is Empty, the rule is easy - 'ignore the position and put Empty'.
17:55:49 <koz_> So how would we write this?
17:56:42 * hackage rainbox 0.24.2.0 - Two-dimensional box pretty printing, with colors  https://hackage.haskell.org/package/rainbox-0.24.2.0 (OmariNorman)
17:56:56 <talles> m = matrix 20 20 $\(i,j) -> Empty ?
17:57:02 <koz_> Yep, that works.
17:57:06 <koz_> So that 2) covered.
17:57:08 <koz_> Now for 3.
17:57:14 <koz_> Have you seen this function before?
17:57:16 <koz_> :t foldr
17:57:17 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
17:58:29 <talles> Yes, but I didn't use yet 
17:58:36 <koz_> Do you have an idea of what it does?
18:00:03 <talles> receive 03 values 
18:00:27 <koz_> So, no? :P
18:00:29 <koz_> That's OK.
18:00:30 <talles> No,
18:00:40 <koz_> So, the idea is roughly thus:
18:01:05 <koz_> We take a 'combiner' and a 'place to start', as well as a list of things to 'feed' to the combiner, and get 'the final place'.
18:01:08 <koz_> Let me show an example:
18:01:17 <koz_> > foldr (+) 1 [2, 3, 4, 5]
18:01:19 <lambdabot>  15
18:01:45 <koz_> So we 'start' at 1, then we repeatedly feed stuff into + with whatever we have 'so far' from the list, and give back whatever we get at the end.
18:01:53 <koz_> A slightly more interesting example:
18:02:29 <koz_> > foldr (\elem blob -> blob ++ show elem) "" [1, 2, 3, 4, 5]
18:02:32 <lambdabot>  "54321"
18:02:51 <koz_> Do you see how this might be helpful to us to achieve step 3?
18:04:26 <talles> we can use it to generate the random numbers by combining the list?
18:04:38 <koz_> We're past the generation step - we did that in step 1.
18:04:43 <koz_> (and you've shown that you can do it already)
18:04:54 <koz_> Do you need me to remind you how I ordered the steps for you in this process?
18:05:54 <talles> 1) get the mine positions; 2) create the matrix; 3) rip replace the positions (random numbers) with Mine
18:06:18 <koz_> Yep, so therefore, I'm saying that foldr could be helpful for 3). If you can't see why, that's OK - let me know and we'll dig a bit deeper.
18:07:30 <talles> Ok, I think I didn't understand the usage of foldr in step 3, since we already have the random numbers (I mean, in that way I generated the random numbers in the list of tuples)
18:07:54 <koz_> Your goal is to have a Matrix representing your _finished_ minefield, right?
18:08:55 <talles> Yes, 
18:09:07 <koz_> So, after finishing step 2), we have two things:
18:09:13 <talles> and for every user input, I check if that input (x,y) has a mine
18:09:15 <koz_> a) A list of random positions, as row-column pairs.
18:09:21 <talles> Yes 
18:09:25 <koz_> b) A Matrix where every position is Empty.
18:09:31 <koz_> So we need to convert those two things into
18:09:45 <koz_> c) A Matrix where the positions from a) have Mines, and all others are Empty.
18:10:00 <koz_> This is where foldr can help us - it can help us turn a) and b) into c).
18:10:02 <talles> but I'm getting an error when I try to create the matrix, using the data CellType, Empty 
18:10:10 <koz_> How are you calling it?
18:10:49 <talles> I have a function inputCoordinates where I pass the list of tuples and the matrix creation 
18:10:52 <talles> inputCoordenadas sorted_list $ matrix 20 20 (\(i,j) -> Empty)
18:11:07 <koz_> This isn't what step 2) corresponds to.
18:11:27 <koz_> We're not _using_ a) for this at all.
18:11:41 <koz_> We're just making a 20 by 20 Matrix where every cell is Empty.
18:11:47 <talles> Ok, 
18:11:48 <koz_> Nowhere in here do we need a list of anything, sorted or not.
18:12:18 <talles> I'll create a separate file
18:12:57 <talles> with only the steps we are doing 
18:13:02 <koz_> Good idea. :)
18:14:23 <talles> Nothing in this but the step 2, directly in the main 
18:22:14 <talles> So, first I need to create the matrix withh CellType, but by doing this, I need to create the alternative setElem?
18:24:50 <koz_> You're jumping ahead again.
18:24:57 <koz_> For now, we aren't even considering that.
18:25:03 <koz_> We just want code that does steps 1 and 2.
18:25:08 <koz_> We can worry about step 3 after that's done.
18:28:38 <talles> Ok
18:29:19 <koz_> If you get stuck or lost, paste what you have, and we can go with that.
18:29:38 <talles> Ok, until now I have only this.
18:30:49 <talles> https://gist.github.com/InluxBDX/157a1b585b5bc5c203890d5b2c84f14f
18:31:58 <talles> I don't know if I'm keeping with you until now, 
18:35:59 <koz_> talles: Mostly. Let's tidy this up a bit.
18:38:40 <talles> I have that imperative language paradigm in mind that blows out everything.
18:38:49 <koz_> It's fine - you'll get better. :)
18:38:51 <talles> It's not possible to code in Haskell thinking in C style 
18:39:07 <talles> that's another world 
18:39:44 <koz_> talles: https://gist.github.com/kozross/fd5f4a4aa9b6ccc83c188a50da06e340
18:40:38 <koz_> Does this make a bit more sense now?
18:41:32 <niteenh> cabal v2-run ./install.hs --project-file install/shake.project <target>
18:41:46 <niteenh> what this <target> here?  from https://github.com/haskell/haskell-ide-engine#installation-from-source
18:42:56 <talles> yes, totally, you create a new type and then made a cast to create the Matrix, but what that unwrap means?
18:47:29 <talles> One thing about the random: I've tried to use this code too:
18:47:45 <talles> zipWith (,) <$> (replicateM 40 $ randomRIO (1,20)) <*> (replicateM 40 $ randomRIO (1,20))
18:47:59 <talles> but only in Prelude it worked, 
19:00:45 <talles> @koz_ I'm just like you in the revolution fighting :)
19:00:45 <lambdabot> Unknown command, try @list
19:02:43 <sleblanc> talles, "unwrap" is just a name for a field, that lets you access the Matrix itself (internal representation). it could have been name "getTheInternalMatrixIKnowWhatIAmDoing" for that matter
19:03:31 <niteenh> headM :: [a] -> Maybe a
19:03:40 <niteenh> headM [] = Nothing
19:03:57 <niteenh> headM x:xs = Just x
19:04:02 <niteenh> where's wrong?
19:04:27 <sleblanc> niteenh, what is the problem?
19:04:38 <niteenh> Parse eror
19:04:40 <ion> headM x:xs parses as (headM x):(xs)
19:04:53 <ion> The space binds tighter than any operator.
19:04:58 <niteenh> aha
19:05:16 <niteenh> sneaky
19:05:20 <nightw0lf> exit
19:09:41 * hackage wordchoice 0.1.2.8 - Get word counts and distributions  https://hackage.haskell.org/package/wordchoice-0.1.2.8 (vmchale)
19:10:03 <talles> Thanks sleblanc, is like an alias for the matrix, so ? 
19:10:57 <sleblanc> the way koz wrote it is to wrap your mine field into a more opaque container, so that you should not be tempted to poke inside the matrix if it is not warranted
19:12:33 <sm[m]> niteenh: the target is usually the same name as the package, but some packages define multiple targets (libraries or executables) with different names
19:12:36 <sleblanc> that way, you try to write most of your functions in terms of MineField. You should as few functions as required that actually understand Matrix, in a way that would let you swap out Matrix for another representation as easily as possible
19:12:51 <sleblanc> I don't want to get ahead of what koz was telling you, but this is how I understand it
19:13:48 <sim590> I'm trying to use `read` on [Char] but, I get no parse exception. I don,t get why ... Here https://paste.debian.net/1116593/, `hash` is a function returning BLU.ByteString (where BLU stands for Data.ByteString.Lazy.UTF8) and C stands for Data.ByteString.Lazy.Char8.
19:14:06 <sim590> I don't get what's the problem.
19:15:46 <koz_> talles: It's just a name for a function that turns a MineField into its underlying Matrix CellType.
19:15:52 <koz_> You can think of it as a shorthand for
19:16:00 <koz_> unwrap (MineField m) = m
19:16:24 <koz_> And sleblanc has the right idea.
19:16:42 <koz_> By writing MineField, and then defining functions in terms of it, we don't accidentally do things we're not supposed to.
19:16:57 <koz_> Anyway, talles, let's get back to step 3.
19:17:01 <koz_> Let's look at foldr again.
19:17:03 <koz_> :t foldr
19:17:04 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
19:17:24 <koz_> Now, after 1) and 2), we have a) a list of random positions and b) a MineField where there are no mines.
19:17:37 <koz_> So let's rewrite the signature with this information in mind.
19:17:38 <talles> So, this mean I can call the Matrix by the name unwrap, that will be the type of MineField?
19:18:01 <koz_> talles: If you have a variable of type MineField, you can 'extract' the Matrix CellType 'underneath' it.
19:18:27 <koz_> But anyway, so, at the end of 3), we want a 'finished' MineField, so let's paste in MineField for b in that signature.
19:18:34 <koz_> This becomes
19:18:52 <koz_> Foldable t => (a -> MineField -> MineField) -> MineField -> t a -> MineField
19:19:13 <koz_> Now, the 't a' thing - we only have one option, which is our list of random positions.
19:19:22 <koz_> So let's paste in [(Int, Int)] instead of 't a'. We get
19:20:00 <koz_> Foldable [] => ((Int, Int) -> MineField -> MineField) -> MineField -> [(Int, Int)] -> MineField
19:20:14 <koz_> Now, the fact that [] is Foldable is known to us (otherwise, this wouldn't work)
19:20:58 <koz_> So, this means foldr (for us, takes three things). Firstly, a function which takes a position, an 'old' MineField, and gives back a 'new' MineField. Secondly, a 'starting' MineField. And lastly, a list of positions.
19:21:07 <koz_> talles: Can you see how this is exactly what we need?
19:21:07 <wejetheman> so I have this "addOneIf :: [String] -> [String]; addOneIf = map (\x -> if length x < 2 then '1':x else x)" and it works fine, but it would be so much cooler if I could do something like this "addOneIf' = map (\x@[_] -> '1':x)" is there any way to complete the non exhaustive pattern inside a lamba like that?
19:21:08 <doyougnu> )
19:21:17 <doyougnu> woop
19:21:57 <koz_> wejetheman: You can do a pattern match. The clue is that the only lists whose length is less than two (other than _|_ of course) are [], and (x : []) for some x.
19:24:17 <wejetheman> but what is the syntax to define those cases?
19:24:44 <wejetheman> oh wait maybe i can just use a ;
19:25:31 <talles> I can't see how the random numbers will be placed on the MineField by this function, I mean,the MineField returned 
19:25:59 <koz_> talles: The idea is in foldr's first argument. That is the thing that does each 'placing'.
19:26:08 <koz_> Let me make an edit.
19:27:57 <koz_> talles: https://gist.github.com/kozross/fd5f4a4aa9b6ccc83c188a50da06e340#file-main-hs-L21
19:28:14 <koz_> In particular, note the signature, and compare it to the foldr stuff I said just before.
19:28:18 <koz_> Let's see if this helps.
19:28:34 <koz_> Sorry, wait, one fix.
19:28:53 <koz_> https://gist.github.com/kozross/fd5f4a4aa9b6ccc83c188a50da06e340#file-main-hs-L21
19:28:56 <koz_> talles: ^
19:30:29 <talles> Ok 
19:33:02 <talles> the pos will be the random pairs? the "." between the MineField and setElem does anything in particular or is just a way to write ? 
19:33:12 <koz_> :t (.)
19:33:13 <lambdabot> (b -> c) -> (a -> b) -> a -> c
19:33:18 <koz_> It's function composition.
19:33:49 <koz_> So placeMine says 'unwrap the MineField, scribble a Mine to pos in the underlying Matrix, then wrap it back up into a MineField'.
19:34:02 <koz_> I can re-write it without that if you prefer.
19:36:57 <talles> No, no, it's fine, I just asked because it seems to be advanced Haskell tips, everything you are doing, at least to me, but seems to be a very common place to you.
19:37:42 <koz_> It's something you will get used to over time.
19:38:03 <koz_> I just wanted to show you how it's done, so you have something to 'start from' and go back to later, when you try to do something similar.
19:38:09 <koz_> (which you will, often)
19:39:18 <wejetheman> nice to see someone else who isnt so advanced around here for once
19:39:35 <koz_> wejetheman: 'Advanced' is a relative term. Compared to some of the folks here, I'm a complete newbie.
19:39:39 <talles> Yes, you would not imagine how much you are helping me, I need to delivery this minesweeper game tomorrow, 
19:39:58 <koz_> talles: Yikes. But anyway, getting back to what we were doing - can you see how foldr can be used to finish step 3?
19:46:24 <dsal> I keep failing at lens.  What's the lens equivalent of  `map snd`  ?
19:46:24 <talles> Honestly, not completely, but what I think I could understand is the get the random numbers and will add a MineField to a MineField, like combining? But I'm not sure 
19:46:43 <koz_> OK, so let's have a look again. I'll make another note, and see if you can connect the pieces.
19:46:48 <koz_> If not, I'll show you.
19:48:04 <koz_> talles: https://gist.github.com/kozross/fd5f4a4aa9b6ccc83c188a50da06e340#file-main-hs-L24
19:53:01 <wejetheman> hey koz any chance you could elaborate a little more on what you said earlier
19:53:23 <commiesalty> guys, do you know why when creating a map.fromList it returns another fromList ?
19:53:46 <talles> the first argument of the foldr function, will be placeMine function with the positions to fold? 
19:53:53 <commiesalty> im expecting it returns a map ?
19:54:11 <dsal> commiesalty: It returns a Map k v
19:54:42 <commiesalty> it returns a fromList...
19:54:46 <commiesalty> in my ghci
19:54:53 <dsal> :t Map.fromList [('a', 1), ('b', 2)]
19:54:55 <lambdabot> error:
19:54:55 <lambdabot>     Not in scope: ‚ÄòMap.fromList‚Äô
19:54:55 <lambdabot>     Perhaps you meant one of these:
19:55:04 <dsal> % Map.fromList [('a', 1), ('b', 2)]
19:55:05 <yahb> dsal: ; <interactive>:83:1: error:; Not in scope: `Map.fromList'; Perhaps you meant one of these: `M.fromList' (imported from Data.Map), `S.fromList' (imported from Data.Set), `IM.fromList' (imported from Data.IntMap); No module named `Map' is imported.
19:55:10 <dsal> % M.fromList [('a', 1), ('b', 2)]
19:55:10 <yahb> dsal: fromList [('a',1),('b',2)]
19:55:12 <dsal> There.
19:55:18 <dsal> % :t M.fromList [('a', 1), ('b', 2)]
19:55:18 <yahb> dsal: Num a => M.Map Char a
19:55:23 <commiesalty> yeah.. it doesnt return a map 
19:55:28 <dsal> Why do you think it doesn't return a map?
19:55:32 <commiesalty> it returns a fromList 
19:55:39 <dsal> what is a "fromList" ?
19:55:43 <doyougnu> thats the show instance for Data.Map youre looking at
19:56:01 <dsal> Data types in Haskell don't start with lowercase letters.
19:56:07 <commiesalty> okay thanks doyougnu
19:57:46 <doyougnu> here: https://hackage.haskell.org/package/containers-0.4.0.0/docs/src/Data-Map.html#Map
19:58:39 <doyougnu> if you search for `Show (Map k a) where` you'll see that when `show`ing a Data.Map it adds a "fromList"
19:58:48 <commiesalty> thanks a lot
19:58:54 <commiesalty> I got mixed up.
19:59:18 <dsal> In general, if you want to know what the type of something is, :t is the easy way to find out.
19:59:30 <dsal> % :t it
19:59:30 <yahb> dsal: Num a => M.Map Char a
19:59:36 <doyougnu> you're welcome, I've been down that road before ;)
20:00:21 <commiesalty> also can i ask, when making a data type e.g : 
20:00:30 <dsal> Also, whenever show doesn't give you an easy way to reconstruct the value, it's sad.
20:00:54 <koz_> wejetheman: What do you mean?
20:01:06 <koz_> talles: Yep, you are right - the first argument to foldr will indeed be placeMines.
20:01:09 <koz_> What about the second?
20:01:16 <koz_> (here's a clue - we defined it in step 2))
20:01:36 <commiesalty> ah nvm
20:02:09 <wejetheman> "You can do a pattern match. The clue is that the only lists whose length is less than two (other than _|_ of course) are [], and (x : []) for some x." Its not enough of a clue, either im too dense or too new or some combination of the two.
20:02:15 <talles> the MineField, the matrix 20 by 20 
20:02:28 <talles> newMineField 
20:02:43 <koz_> talles: Yes, exactly - we want a MineField where everything is 'empty'.
20:02:44 <talles> the function newMineField, which is the matrix 20 by 20 
20:02:47 <koz_> wejetheman: One second.
20:03:13 <wejetheman> If only I was as good at haskall as I am rhyming.
20:04:34 <koz_> wejetheman: https://gist.github.com/kozross/51e80a26284ffb37bae511a5dfc21401
20:04:51 <koz_> talles: By this logic, the third argument is your randomly-generated list of positions.
20:04:57 <koz_> So with that, we can write...
20:05:55 <koz_> https://gist.github.com/kozross/fd5f4a4aa9b6ccc83c188a50da06e340#file-main-hs-L25
20:11:56 <ryan87> does anyone use emacs, and if so, how did you get your indentation right?
20:12:29 <doyougnu> ryan87: I use spacemacs, I just installed hindent and use dante/intero
20:12:48 <talles> the return of populateMineField will be another MineField?
20:13:05 <koz_> talles: Yes.
20:13:35 <koz_> Specifically, it'll be a MineField where the positions corresponding to what you passed in will be Mines, and all the others Empty.
20:17:38 <talles> Can I do this? 
20:18:09 <ryan87> doyougnu: thanks, I'll check it out
20:18:26 <talles> print $ populateMineField list_coord or newMineField = populateMineField list_coord? I mean, I need to declare another MineField that will receive the populateMineField to pass it forward
20:18:46 <talles> ?
20:18:50 <koz_> You don't need to 'declare' another anything.
20:19:01 <koz_> Whatever comes out of populateMineField is already 'declared'.
20:19:07 <koz_> So printing it directly is fine.
20:19:52 <hololeap> why is it that GADTs can't derive instances normally?
20:20:22 <koz_> hololeap: GADTs are a clever wrapper around existentials.
20:20:42 <koz_> With existentials, deriving stuff automagically becomes much more difficult (who the extensible effect knows what that existential is hiding).
20:21:23 <hololeap> ok, but then why is StandaloneDeriving any different?
20:21:31 <koz_> hololeap: Good question.
20:21:47 <koz_> That one I can't field.
20:22:58 <talles> I'm getting this error when printing directly 
20:23:00 <hololeap> could it be that StandaloneDeriving allows you to add constraints manually, which helps ghc figure out the deriving magic?
20:23:07 <talles>  No instance for (Show MineField) arising from a use of ‚Äòprint‚Äô
20:23:10 <ryan87> doyougnu: so it looks like dante is just a minor mode... are you still using haskell-mode as your major?
20:23:50 <koz_> talles: Add 'deriving Show' underneath the MineField definition.
20:24:05 <koz_> hololeap: Could be. Again, can't field, so your guess truly is as good as mine.
20:24:50 <hololeap> cool. i was just curious anyway. had a couple `deriving instance Functor (...)` and started wondering why i couldn't just use `deriving Functor (...)`
20:24:53 <doyougnu> ryan87: yes
20:27:49 <nshepperd_> hololeap: iirc, type inference with GADTs has difficulties, so it can't necessarily determine which constraints it needs
20:27:59 <talles> It worked koz_, the matrix was printed with all the mines placed in the random positions
20:28:06 <koz_> talles: There you go then. :D
20:28:12 <nshepperd_> StandaloneDeriving lets it punt and make you choose the constraints for it
20:28:31 <koz_> The general idea with Haskell is always the same - define types to talk about your problem, then write your functions bottom-up, just like we did.
20:29:06 <nshepperd_> this is related to the reason you need a type signature on a case expression of a GADT
20:30:09 <hololeap> nshepperd_: that makes sense and kind of what i was guessing. also, i didn't know about the type signature requirement. i put type signatures all over the place anyway, so maybe that's why i haven't been bit by it yet
20:33:18 <nshepperd_> there's an example in the OutsideIn paper of this... they show a function which has two possible type sigs. T a -> a -> a and T a -> Bool -> Bool neither of which is 'more general' than the other
20:34:39 <talles> koz_, thank you very much for the helping and for the time you've spent with me in this.
20:36:33 <koz_> talles: No worries - glad I could help.
20:37:17 <talles> I have two final questions about the Mine and Empty data. If I define, type Mine = String and Empty = String, in some part of the code, can I replace the words by the symbols? (like # for empty and * for the Mines?
20:37:32 <nshepperd_> https://research.microsoft.com/~simonpj/papers/constraints/jfp-outsidein.pdf page 4
20:38:06 <talles> when I print the board,it shows MineField {unwrap = matrix } if I use the putStrLnpretty, I can go around this?
20:39:23 <talles> I promise you I will not bother you anymore with this. I think you've showed me a lot of concepts about Haskell and it was a great!
20:40:41 <talles> I'm very thankful to you koz_, you are a great human being!
20:43:40 <MarcelineVQ> koz_: you are, however, a truly terrible jello cube
20:47:37 <koz_> talles: In this case, I would define a function stringify :: MineField -> String, and have it create whatever representation you want.
20:47:41 <koz_> Then putStrLn that.
20:48:24 <talles> Thanks, I'll do this
20:49:38 <koz_> In general, Show is for debugging only - if you want pretty output, you should write a function to do it.
21:05:58 <talles> I'm getting this error when I try to pass the populatedMineField returning 
21:06:05 <talles> Couldn't match expected type ‚ÄòMatrix CellType‚Äô               with actual type ‚ÄòMineField‚Äô
21:06:20 <talles> But I have no signature for the function I'm passing it
21:06:28 <talles>      inputCoordenadas (populateMineField list_coord)
21:10:09 <koz_> What's the type of inputCoordenadas?
21:11:15 <talles> there is no type at all 
21:11:33 <talles> I've tried something like this inputCoordenadas :: MineField
21:11:39 <talles> But it does not work 
21:11:52 <koz_> What's the function's implementation?
21:12:04 <koz_> (also, _always_ put types on your functions, and _always_ define them first)
21:13:02 <talles> https://gist.github.com/InluxBDX/f2296a11f6317b46020d32d7df7d0f4f
21:14:31 <koz_> talles: OK, inputCoordenadas (as far as I can tell) is meant to get ... something from the user?
21:14:46 <koz_> I don't speak Spanish (or Portuguese, I can't tell), so I dunno what exactly you're prompting for.
21:14:47 <talles> Yeap, the x  y coordinates 
21:15:17 <talles> in English would be something like inputCoordinates
21:15:40 <koz_> Well, I figured that much. So you ask the user for... one x, and one y?
21:16:01 <talles> Yes 
21:16:10 <koz_> OK, let's write that.
21:16:27 <koz_> What are the rules about what x and what y are OK?
21:17:15 <talles> Then I evaluate if that coordinates have a mine, if so, the user loses the game, otherwise, I need to expand and show a number that represents that 
21:17:23 <talles> right near there is a bomb
21:17:36 <koz_> Yeah, you're mashing together like six things.
21:17:38 <koz_> 1) User input
21:17:41 <koz_> 2) User validation
21:17:45 <koz_> 3) Checking for something
21:17:45 <talles> Yeap 
21:17:53 <koz_> 4) Performing an action based on 3)
21:18:00 <koz_> 5) Informing the user what happened
21:18:05 <koz_> (OK, 5, but yeah)
21:18:10 <koz_> This is far too much for 1 function.
21:18:16 <koz_> So we're gonna break it into _five_ functions.
21:18:20 <koz_> Get into this habit.
21:18:23 <koz_> You will be doing it often.
21:18:34 <koz_> So, let's start with 1).
21:18:41 <koz_> Let me just format a bit what you pasted.
21:19:22 <koz_> (also, Empty and Mine are _not_ Strings)
21:19:31 <koz_> Don't confuse output representation with game logic.
21:20:40 <talles> Yes, for sure, that function is so heavy and ugly, I was trying to get the minimal functionality and then refactoring everything
21:21:07 <talles> the rules of x and y, you mean what the user cannot input?
21:21:54 <koz_> talles: You're working top-down - a common C habit. Don't. :P
21:22:01 <koz_> I'll write something to get you started.
21:23:14 <talles> Yeap, C style, always in my mind, I've written so many code in C, that Haskell is breaking my mind, but I like to break paradigms and learn
21:24:07 <talles> something totally different, even if I'm a little dumb to new things
21:25:04 <koz_> talles: Yeah, working 'bottom-up' is the secret to (at least my) success. Write _very small pieces_, then put them together.
21:27:29 <irc27313> :t (>>)
21:27:31 <lambdabot> Monad m => m a -> m b -> m b
21:28:46 <irc27313> Nothing >> Just 3
21:32:12 <koz_> talles: https://gist.github.com/kozross/302ce1923094061056349f2cc2cdfa3d#file-main-hs-L61
21:32:29 <koz_> (also, try using Gist like I am - it makes it much easier for other people to read when it's highlighted like that)
21:32:29 <ryan87> talles: if you're looking for mind-breakage, I recommend SICP
21:33:08 <koz_> ryan87: It's... a different kind of mind-breakage.
21:33:19 <koz_> Let's stick with getting minesweeper going. :P
21:33:44 <ryan87> koz_: ;)
21:38:25 <talles> ryan87, I'll take a look 
21:43:31 <sm[m]> Minesweeper ? Yay!
21:43:59 <talles> I was forgetting to put the .hs in the Gist 
21:48:12 * hackage graphql-w-persistent 0.7.0.0 - GraphQL interface middleware for (SQL) databases.  https://hackage.haskell.org/package/graphql-w-persistent-0.7.0.0 (jasonsychau)
21:50:22 <ryan87> talles: glhf and don't forget to diddle your bits
21:56:19 <jzyamateur> If we have some type in type signature say `Mytype a b c d` where a, b , c, d are all type variables , is it same as writing `Mytype a b (c d)` ?
21:58:39 <yup> heyo, could anybody help me with converting a function to point free form?
21:59:35 <jle`> jzyamateur: no, it is (((MyType a) b) c) d
22:00:02 <jzyamateur> ok
22:00:46 <jle`> jzyamateur: just like for normal value-level application :)
22:03:47 <yup> can anybody explain how f = ((*) .) . (+) can be acquired from ((*) c) . ((+) a)?
22:03:49 <yup> im v lost
22:04:13 <jle`> what do you mean 'acquired' ?
22:04:21 <int-e> 'obtained'
22:04:36 <yup> obtained, yeah
22:04:53 <jle`> like, as a substitution command?
22:04:59 <int-e> @unpl  ((*) .) . (+)
22:04:59 <lambdabot> (\ x x0 -> (*) (x + x0))
22:05:03 <jle`> like string substitution?
22:05:25 <jle`> yup: are you looking for something like https://en.wikipedia.org/wiki/Levenshtein_distance ?
22:05:48 <yup> no, i just want to convert 'f a b c = (a + b) * c to point-free form
22:05:52 <jle`> you can turn the string "((*) c) . (+) a)" into the string "((*) .) . (+)" with character subistitutions
22:05:59 <yup> and the furthest I got was ((*) c) . ((+) a)
22:05:59 <jle`> yup: ah, i see
22:06:02 <yup> unless that's actually wrong
22:06:07 <int-e> @pl \a b c -> (a + b) * c
22:06:07 <lambdabot> ((*) .) . (+)
22:06:39 <int-e> @pl \b -> (a + b) * c
22:06:39 <lambdabot> (c *) . (a +)
22:06:52 <talles> koz_ https://gist.github.com/InluxBDX/3281ba94bc31e30701c051b0c5d62353
22:06:52 <jle`> so you want see how \c a -> ((*) c) . ((+) a) into ((*) .) . (+) ?
22:07:01 <jle`> s/into/is the same as
22:07:21 <int-e> they don't... there's a permutation of arguments involved as well
22:07:37 <jzyamateur> So `Compose Maybe [] Int` is `(((Compose Maybe) []) Int)` ? 
22:07:56 <jle`> jzyamateur: yes
22:07:57 <talles> how can I reply to a specific user? I've googled it but I've found nothing  
22:07:57 <yup> f a b c = (a+b) * c => (*) c (+) a b => ( (*) c ) ( (+) a ) b => ( (*) c ) . ( (+) a ) b => ( (*) c ) . ( (+) a )
22:08:02 <yup> those are my steps
22:08:07 <yup> idk where to go from that last step
22:08:41 <jle`> btw the first step is (*) c ((+) a b)
22:08:44 <jle`> if that is giving you any issues
22:09:22 <yup> i dont think so
22:09:32 <int-e> yup: how did you remove the b?
22:09:33 <yup> since my next step has ( (+) a ) b
22:09:42 <yup> cant you eta reduce to get rid of it?
22:09:47 <yup> or am i wrong
22:09:49 <hololeap> are there any big differences between defining a GADT as `data MyGADT (ss :: [Nat]) a` vs `data MyGADT :: [Nat] -> Type -> Type` ?
22:09:50 <int-e> yup: no, you can't
22:09:51 <jle`> you can only eta reduce if it's the 'same' last application
22:09:57 <int-e> yup: because b isn't the last argument of f
22:10:20 <jle`> yup: for example you can eta-reduce `foo a b = bar b` by peeling off the b on each end
22:10:33 <jle`> but what you have is foo a b c = bar b
22:10:36 <jle`> so no peeling
22:10:41 <yup> ah
22:11:04 <jle`> btw the third part is also going to be (((*) c) . ((+) a)) b
22:11:18 <jle`> or ((*) c . (+) a) b
22:11:37 <jle`> that part should make it clear what is going on
22:11:45 <jle`> f a b c = ((*) c . (+) a) b
22:11:54 <hololeap> talles, if you just want to "ping" them in the channel, just include their name in the text. if you want to PM them (outside the channel) that's another story
22:12:17 <talles> Got it 
22:12:33 <talles> like hololeap, and it appears in green to you?
22:13:17 <hololeap> yeah
22:13:27 <hololeap> (it's yellow for me, but same idea)
22:14:14 <talles> heheh thanks!
22:14:40 <hololeap> np
22:15:01 <yup> so what would the next step from ((*) c . (+) a) b be? since i thought you could eta reduce the b
22:16:17 <int-e> yup: you go back to (a+b) * c, then rewrite that as (*) (a+b) c, and you can eta-reduce the c.
22:22:24 <hololeap> talles: also keep in mind that some IRC clients allow you to do Tab-completion on names and/or click on a name to automatically type it
22:22:48 <talles> I'm using HexChat
22:23:25 <hololeap> i can't remember which one that uses. you'll have to try it (although i'm leaning toward tab-completion only)
22:23:41 <hololeap> it's a handy feature
22:24:22 <jzyamateur> So jle`, When I have a type signature like `Compose f g (p a)` , I cannot remove the parentheses right away?
22:24:56 <talles> hololeap: found it, hexchat has this feature 
22:27:52 <koz_> talles: You're not far off. Try writing it as a bunch of if-then-else statements first.
22:28:19 <koz_> (also, XOutOfBounds won't work here - you need Left XOutOfBounds)
22:28:32 <koz_> Since you're returning Either PositionError (Int, Int)
22:29:18 <hololeap> are there any big differences between defining a GADT as `data MyGADT (ss :: [Nat]) a` vs `data MyGADT :: [Nat] -> Type -> Type` ?
22:29:52 <jle`> jzyamateur: yeah that's like saying you need to keep the parents for x * (y + z)
22:30:13 <jle`> hololeap: documentation maybe, and it affects template haskell i believe
22:30:27 <jle`> i mean it affects the AST you get when you reify it in template haskell
22:30:34 <jle`> but other than that not really
22:30:53 <jle`> hololeap: oh, the second one fixes the kind of 'a' to be Type, but the first one is potentially poly-kinded
22:30:54 <talles> koz_: I really didn't get the Either PositionError (Int, Int), the Either means literally, I'll return one error or another? Why I need to return the (Int, Int)
22:31:25 <koz_> talles: This is an idea that Alexis King described very well: https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/
22:31:38 <hololeap> jle`: so the first one would be equivalent to `data MyGADT :: [Nat] -> Type -> k` ?
22:31:48 <jle`> [Nat] -> k -> Type
22:31:49 <koz_> Ideally, we'd actually have a proper Position type, instead of a bare (Int, Int), so then we would have it return Either PositionError Position.
22:31:55 <koz_> Either is 'one of two things'.
22:31:59 <jle`> hololeap: all type constructors must return Type in the end
22:32:04 <koz_> So Either a b means 'Left a, or Right b'.
22:32:09 <hololeap> oh, ok
22:32:12 <hololeap> that makes sense
22:32:23 <jle`> hololeap: but, it's not necessarily 'equivalent'
22:32:34 <jle`> hololeap: because if one of the consturctors use 'a' as Type, then it'll infer 'a' ot be Type
22:32:35 <jle`> not poly-kinded
22:35:08 <hololeap> ok
22:37:21 <talles> koz_: I think I will not get further today, it's almost morning here in Brazil, I'm working with this minesweeper since morning yesterday
22:37:35 <koz_> talles: Knowing your limits is a good idea.
22:37:54 <talles> I'll have to refactoring everything, since everything changed
22:38:32 * hololeap wonders if minesweeper would be a good place to use costate comonads
22:40:55 <talles> koz_: I don't know if I can do it, but I'll try tomorrow. Thanks!
22:41:20 <koz_> hololeap: Do you mean coalgebra costate comonads?
22:41:23 <koz_> (aka lenses)
22:43:42 <jle`> hololeap: yes it does remind me a lot of ed's cellular automata w/ store tutorial
22:43:55 <hololeap> koz_: ^
22:47:57 <koz_> I was more referring to https://twitter.com/PLT_Borat/status/228009057670291456
23:16:40 <hololeap> here's a tough one: https://gist.github.com/hololeap/e553118d5f979b5a604eea72823f25c9
23:17:12 <hololeap> is it possible to make that Functor constraint?
23:29:59 <MarcelineVQ> hololeap: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#quantified-constraints https://ryanglscott.github.io/2018/03/04/how-quantifiedconstraints-can-let-us-put-join-back-in-monad/
23:30:29 <jle`> hololeap: you can bring it into the typeclass for projectLL
23:30:41 <jle`> *type signature
23:30:44 <koz_> QuantifiedConstraints so good.
23:31:30 <MarcelineVQ> idk how it all applies with typefamilies but it's worth a shot
23:32:27 <hololeap> MarcelineVQ: thanks! i literally tried that hoping GHC would drop a hint of an available extension, but it didn't
23:32:45 <MarcelineVQ> hololeap: is the x in projectLL supposed to be the same x from the cosntraint?
23:32:49 <hololeap> oh, actually it does... hmm
23:33:18 <hololeap> MarcelineVQ: not necessarily
23:33:41 <hololeap> later i have deriving instance Functor (MultiDVectorF a s)
23:34:05 <hololeap> and type instance BaseLL (MultiDVector a) = MultiDVectorF a
23:34:13 <jonathan_> I'm trying to understand class a ~~ b. In the hackage description, it says: "Lifted, heterogeneous equality. By lifted, we mean that it can be bogus (deferred type error). By heterogeneous, the two types a and b might have different kinds". I get that this is type equality for types of different orders, but what is meant by "By lifted, we mean that it can be bogus"?
23:36:16 <ChaiTRex> jonathan_: not sure, but by the stuff in parentheses, presumably unlifted would be checked earlier
23:45:33 <jonathan_> ChaiTRex: meaning the compiler error will be more nonsensical? Or meaning it will be checked in runtime?
