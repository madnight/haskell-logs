00:03:17 <justsomeguy> Why does fmap (1+) (3,9)  return (3,10) instead of (4,10)?
00:04:27 <opqdonut> because that's what the functor instance does
00:04:40 <opqdonut> > fmap (1+) ("BOING",1)
00:04:42 <lambdabot>  ("BOING",2)
00:05:26 <opqdonut> the main reason for this is that the (,) type constructor takes two arguments
00:05:42 <opqdonut> so you can't write "instance Functor (,)"
00:06:03 <opqdonut> you'd need some thing like type-level lambdas: "instance Functor (\a -> (a,a))"
00:06:05 <opqdonut> or a newtype
00:07:34 <opqdonut> a newtype like "newtype Pair a = Pair (a,a)" that is
00:08:03 <opqdonut> then you could have: instance Functor Pair where fmap f (Pair (a,b)) = Pair (f a, f b)
00:09:02 <justsomeguy> Ah, so it's a limitation of the Functor type class method for tuples. I was surprised since other types behave predictably, like fmap (1+) [3..9] which would return [4,5,6,7,8,9,10].
00:09:15 <LysergicDreams> Or newtype Pair b a = Pair (a, b)
00:09:40 <opqdonut> justsomeguy: yeah, lists work fine because lists take only one type parameter
00:10:42 <jle`> justsomeguy: it's mostly only surprising if your tuples have the same type
00:10:54 <jle`> justsomeguy: but if your tuple values have different types, it arguably behaves like you would expect
00:11:00 <jle`> > fmap (+1) ("hi", 3)
00:11:02 <lambdabot>  ("hi",4)
00:11:06 <jle`> what could that return other than ("hi", 4) ?
00:11:14 <justsomeguy> A type error.
00:11:58 <justsomeguy> At least, that's what I would have expected.
00:12:42 <opqdonut> there are some ways to express the function you wanted
00:12:47 <jle`> justsomeguy: fair enough :) but then this looks less like a limitation, and more like an ability
00:12:54 <opqdonut> > bimap (+1) (+1) (3,9)
00:12:56 <lambdabot>  (4,10)
00:13:00 <opqdonut> > bimap (+1) (+1) ("HELLO",9)
00:13:02 <lambdabot>  error:
00:13:02 <lambdabot>      • Could not deduce (Num [Char]) arising from a use of ‘+’
00:13:02 <lambdabot>        from the context: Num d
00:13:07 <jle`> justsomeguy: the fact that you can fmap on tuples at all is 'useful', not a limitation :)
00:13:40 <opqdonut> > ((+1) *** (+1)) (3,9) -- using Control.Arrow.***
00:13:41 <f-a> we had a long long ML thread on that
00:13:42 <lambdabot>  (4,10)
00:14:09 <jle`> justsomeguy: one way to interpret tuple functor is that (String, a) is an a "tagged" with String data that hangs out alongside it
00:14:21 <jle`> justsomeguy: so its Applicative, Monad etc. instances respect this
00:14:29 <jle`> fmap would change the value, and leave the tag unchanged
00:14:43 <jle`> > fmap (+1) ("safe", 3)
00:14:45 <lambdabot>  ("safe",4)
00:15:36 <jle`> applicative combines the tags together (if you're familiar with applicative)
00:16:41 <jle`> but yeah, this behavior can be unexpected/unpredictable if you aren't using tuple as 'tagged data'.  which is admittedly a rare use case of tuples
00:16:53 <jle`> that's why i never use fmap except if i'm thinking of the tuple as tagged data
00:16:56 <jle`> i'd use 'first' or 'second'
00:17:19 <jle`> fmap on a tuple in most cases would definitely be confusing and is a source of potential errors
00:17:35 <jle`> using first or second makes it more clear what you want to do:
00:17:41 <jle`> > first negate (1,2)
00:17:43 <lambdabot>  (-1,2)
00:17:46 <jle`> > second (+3) (1,2)
00:17:48 <lambdabot>  (1,5)
00:18:26 <justsomeguy> Interesting! I'm glad I asked.
00:19:30 * justsomeguy has only started to learn about Functor less than an hour ago, so he's still pretty unfamiliar with all this stuff. Applicative comes next.
00:19:58 <jle`> there are looooots of bugs that come about because people use fmap by accident on a tuple when both fields are the same type, so it's definitely something to be suspicious about
00:20:30 <jle`> but fmap for tuples is a necessary evil of sorts, because Monad/Applicative on tuples are pretty useful...but those require a Functor superclass
00:20:47 <justsomeguy> Are there alternate preludes that try to prevent simple semantic errors like that?
00:21:01 <justsomeguy> (Not that I plan to use one, just curious.)
00:21:17 <f-a> justsomeguy: ther is a "warn on fmap on tuple" ghc proposal
00:21:37 <jle`> hm, i do know some alternative preludes that emit warnings
00:21:43 <jle`> on things similar to this
00:21:48 <justsomeguy> Ah, that seems like a good approach. But maybe even a linter would be adequate.
00:22:06 <jle`> for example you can always replace 'fmap' with 'second', which would make the code much easier to read and identify potential errors
00:22:15 <jle`> so a linter or a prelude with warning systems can be nice
00:22:48 <jle`> getting rid of fmap entirely might not be possible because of the superclass things i mentioned earlier. but at least warning people would be useful
00:23:32 <jle`> alternatively we can just completely scrap Monad/Applicative for tuples, but that would be a shame.
00:24:32 <jle`> the absolute worst offender in terms of higher-kinded tuple classes is definitely Foldable
00:24:52 <jle`> there is literally no reason to ever use any Foldable methods for tuples, so it's pretty much 100% a user error
00:25:21 <jle`> but we need Foldable for tuples so we can have Traversable for tuples, since Foldable is a superclass.  And Traversable is pretty useful
00:25:27 <jle`> > length (1,2)   -- whoops
00:25:29 <lambdabot>  1
00:26:06 <jle`> > sum (1,2)   -- double whoops
00:26:08 <lambdabot>  2
00:26:17 <dibblego> let it be known that not all agree
00:27:54 <jle`> i do admit that the value of Monad, Applicative, Traversable for `(,) w` is highly relative and I might place more worth in them than most, and sometimes i feel like they might not be worth keeping as well
00:44:43 <tdammers> my stance is that if a lawful instance exist, we might as well have it
00:45:46 <opqdonut> what if the instance is nonunique?
00:45:58 <opqdonut> (like Monoid Integer or something)
00:46:47 <dminuoso> opqdonut: If there's an obvious canonical instance, pick that - otherwise just provide newtypes?
00:47:33 <opqdonut> yeah that's what I think too
00:54:26 <tdammers> pretty much that, yes
01:03:40 <Phyx-> jusss: it takes long because gcc and ld are slow on Windows due to how they address files. and hsdev has a dependency chain from here to the moon.
01:24:16 <__dingbat__> I would like to restructure this case block better, can anyone help please?
01:24:24 <__dingbat__> https://www.codepile.net/pile/jBpnKw8A
01:25:37 <opqdonut> link doesn't work for me
01:26:07 <dminuoso> __dingbat__: Try a purists paste website perhaps?
01:27:36 <__dingbat__> sorry, try this- https://www.codepile.net/pile/KlYARplx   not sure what the issue was
01:30:37 <jusss> Phyx-: ok...
01:32:03 <dminuoso> __dingbat__: case (method x) of "get_block_hash" -> pure x; ...
01:32:18 <dminuoso> __dingbat__: Or perhaps rather...
01:33:20 <__dingbat__> dminuoso: I am not familiar with pure, will look into it..
01:34:05 <dminuoso> __dingbat__: let action = case (method x) of "get_block_hash" -> x; ... in do { val <- liftIO (action net (params x)); ... }
01:34:07 <__dingbat__> one of you have edited the link, and provided a alternative , I am afraid that does not work as the code will still be repeated, only within each of the xGetSomethingN's
01:34:49 <dminuoso> __dingbat__: Also it might improve readability to create a binding `foo = BSU.toString . B64.encode . L.toStrict . GZ.compress`
01:35:08 <__dingbat__> dminuoso: so the "in" clause is executed later? after the case blocks are evaluated?
01:35:27 <MarcelineVQ> I don't get what you're wanting to do then
01:36:31 <__dingbat__> dminuoso: thanks i will look into "in" too
01:45:40 <merijn> __dingbat__: there's no notion of "later" or "after"
01:47:22 <merijn> __dingbat__: Order of evaluation is unspecified and unknown, what you're probably *actually* asking is "is the ordering of effects that are executed the one I want", but that ordering is enforced by the Monad instance you are using, not by the evaluation order
01:48:01 <merijn> So whether the case block is evaluated first or later doesn't matter for the meaning of your code
01:55:48 <bwe> how can I change the resolution of a  Fixed E2  to  Fixed E1  (Data.Fixed)?
01:56:31 <bwe> >>> realToFrac (1.44 :: Centi) :: Fixed E1
01:56:42 <bwe> I feel this not to be the right way, however it works.
02:00:23 <merijn> bwe: Well, what other way would there be?
02:04:50 <Taneb> bwe: what are you trying to achieve in the end?
02:07:57 <bahamas> neat interpolation adds a newline to the end of the string it creates. is there a way to make it stop doing that?
02:08:14 <bahamas> I'm talking about this package http://hackage.haskell.org/package/neat-interpolation
02:09:16 <merijn> bahamas: You could just use Text.strip or something
02:09:27 <merijn> bahamas: Although I'd probably just use a prettyprinter instead
02:10:15 <bahamas> merijn: which one?
02:10:20 <merijn> @hackage prettyprinter
02:10:20 <lambdabot> http://hackage.haskell.org/package/prettyprinter
02:10:27 <merijn> The prettyprinter to rule them all
02:10:58 <bahamas> ok :) thanks
02:11:33 <__dingbat__> merijn: I see, that is interesting. Will take a look. Thanks
02:11:41 <srk> trying to support both cereal (ByteString) and aeson (Text) instances - is this an antipattern? https://gist.github.com/sorki/1591399cc0d397e86e6c6baa4da0759f
02:12:49 <merijn> srk: The only antipattern is not defining a functor instance instead of defining "convert"
02:13:37 <lortabac> it's more than an antipattern, it's almost a sin :P
02:13:58 <merijn> I think you could make a Foldable and Traversable instance too, tbh
02:14:19 <merijn> Applicative too, but not sure if that's even useful...)
02:14:42 * hackage libyaml 0.1.1.1 - Low-level, streaming YAML interface.  https://hackage.haskell.org/package/libyaml-0.1.1.1 (MichaelSnoyman)
02:14:52 <srk> merijn: ah!
02:15:39 <srk> I could possibly use generics to convert all 'a' record fields without explicitly listing all of them
02:15:42 * hackage yaml 0.11.2.0 - Support for parsing and rendering YAML documents.  https://hackage.haskell.org/package/yaml-0.11.2.0 (MichaelSnoyman)
02:15:57 <merijn> srk: You could, but I'm honestly not sure it's worth the effort
02:16:09 <merijn> Generics are kinda painful and this code isn't *that* bad
02:16:23 <merijn> Oh, guess it can't be Applicative due to multiple constructors with no sensible pure
02:16:32 <merijn> But Foldable/Traversable should work
02:16:52 <srk> right! :)
02:19:38 <lortabac> srk: you can derive Functor, Foldable and Traversable automatically if you enable some extensions
02:19:43 <lortabac> no need for Generics
02:21:34 <bwe> bahamas: I have found pPrint from https://hackage.haskell.org/package/pretty-simple quite useful for me.
02:22:48 <srk> lortabac: sounds good, will try it, thanks
02:30:36 <merijn> Sometimes packages are so close to having a nice clean API, but not quite due to legacy gunk for backwards compat...
02:42:12 * hackage box 0.0.1.4 - boxes  https://hackage.haskell.org/package/box-0.0.1.4 (tonyday567)
02:52:10 <Taneb> Is there a valid instance Monoid e => Alternative (Either e), with empty = Left mempty and Left x <|> Left y = Left (x <> y); Right x <|> _ = Right x; _ <|> Right y = Right y?
02:53:12 * hackage web-rep 0.1.1 - representations of a web pag  https://hackage.haskell.org/package/web-rep-0.1.1 (tonyday567)
02:53:19 <merijn> hmm, so I'm wondering, with ResourceT do you want it at the top of your stack so you limit the scope of resource usage?
02:54:42 * hackage numhask-space 0.2.0 - numerical spaces  https://hackage.haskell.org/package/numhask-space-0.2.0 (tonyday567)
05:15:13 <EvanR> so, (x - h) + h is not necessarily equal to x with floats. But quickcheck is finding examples where the difference is 1 ULP
05:15:36 <EvanR> is that always the case
05:18:12 <EvanR> nevermind
05:18:24 <merijn> EvanR: IEEE-754 guarantees that operations behave as if they were performed with infinite precision and then rounded to the nearest representible float value
05:18:53 <EvanR> so i've heard
05:19:03 <merijn> EvanR: So that behaviour seems not guaranteed, but something that should happen fairly requently
05:22:30 <mceier> > (16777218.0-1.0)+1.0::Float
05:22:32 <lambdabot>  1.6777216e7
05:23:51 <EvanR> > map decodeFloat [16777218.0, (16777218.0 - 1.0) + 1.0]
05:23:53 <lambdabot>  [(4503600164241408,-28),(4503600164241408,-28)]
05:23:54 <bahamas> merijn: I realized it now. I think you were suggesting I'd use prettyprinter instead of neat interpolation, right?
05:24:02 <EvanR> > map decodeFloat [16777218.0 :: Float, (16777218.0 - 1.0) + 1.0]
05:24:03 <lambdabot>  [(8388609,1),(8388608,1)]
05:24:08 <bahamas> not just for the extra newline in my text
05:24:14 <EvanR> 1 ULP...
05:24:16 <merijn> bahamas: Yes, depending on your exact use case
05:24:18 <bahamas> *not as a solution for ...
05:24:39 <bahamas> merijn: I'm passing this text to Turtle's procs command. I'm running stuff in the shell, basically
05:24:47 <bahamas> *procs function
05:24:52 <EvanR> merijn: it's like, if that's really how it works. How could it differ by more than 1 ULP
05:26:06 <merijn> EvanR: I don't know enough, to say
05:27:57 <EvanR> back to quickcheck with a more precise check
05:30:16 <opqdonut> hmm
05:30:35 <opqdonut> with suitable numbers it should be possible to get x+h to round up 1ULP, and the -h another 1ULP up
05:31:19 <EvanR> > map decodeFloat [-0.1605070368653489, ((-0.1605070368653489) - (-4.023514214611099))+(-4.023514214611099)]
05:31:21 <lambdabot>  [(-5782875451337022,-55),(-5782875451337024,-55)]
05:31:32 <opqdonut> there ya go
05:31:35 <EvanR> ok maybe the max is 2 ULP
05:31:39 * EvanR tries again
05:31:47 <merijn> EvanR: You probably wanna start using hex float output for checking things
05:32:25 <EvanR> i guess... though i would have to be eyeballing hex math
05:32:44 <merijn> EvanR: My point is that decimal output rounds and is the completely untrustworthy
05:33:11 <merijn> EvanR: There is zero guarantee that the decimal number you see corresponds exactly to the float your serialising
05:33:18 <EvanR> wait what
05:33:29 <EvanR> this is decode float, it's not based 10
05:33:32 <EvanR> > map decodeFloat [0.23815245322965736, (0.23815245322965736 - (-1.4454916757137188)) + (-1.4454916757137188)]
05:33:34 <lambdabot>  [(8580346396979635,-55),(8580346396979632,-55)]
05:33:48 <EvanR> oh well, me inputting the number is base 10
05:33:59 <EvanR> but i don't see why it's untrustworthy
05:34:11 <merijn> EvanR: oh, right I was eyeballing what you were running without reading :p
05:34:30 <EvanR> well that's a diff of 3, now i'm sure i don't get it :)
05:34:55 <opqdonut> weird
05:36:27 <EvanR> @check \x h -> let ((a,b),(c,d)) = (decodeFloat x, decodeFloat ((x-h)+h)) in b==d && (abs (a-c) <= 5)
05:36:29 <lambdabot>  *** Failed! Falsifiable (after 7 tests and 3 shrinks):
05:36:29 <lambdabot>  2.529039233331671e-2 -2.793794393370179
05:36:35 <EvanR> @check \x h -> let ((a,b),(c,d)) = (decodeFloat x, decodeFloat ((x-h)+h)) in b==d && (abs (a-c) <= 5)
05:36:38 <lambdabot>  *** Failed! Falsifiable (after 5 tests and 3 shrinks):
05:36:38 <lambdabot>  1.0064344115514458e-4 3.8866470469756265
05:36:49 <opqdonut> ah yeah if h is way bigger than x
05:36:50 <EvanR> ok, that one passed 100 tests 3 times before i tried it
05:37:03 <opqdonut> then my intuition is off
05:37:16 <EvanR> oh
05:38:11 <EvanR> > (1 - 1000) + 1000
05:38:13 <lambdabot>  1
05:38:15 <EvanR> > (1 - 1000) + 1000.0
05:38:17 <lambdabot>  1.0
05:38:38 <EvanR> my number fu sucks this morning
05:40:38 <EvanR> essentially, how big does your tolerance need to be to make (x-h)+h = x. I think merijn was asking this last week
05:41:41 <EvanR> x=-9.795829831527865e-3 h=-5.0792030589315225  gives a difference of over 100 ULP
05:41:52 <ooo_miguel> How are "errors" as non-exhaustive-pattern-matches propagated in haskell? is this possible "thanks" to the bottom value?
05:42:25 <opqdonut> EvanR: if h is orders of magnitude bigger than x, this the same as bignumber-bignumber, which is known to cause arbitarily large errors
05:43:18 <EvanR> ok.. (x-h)+h = (h-x)-h
05:43:58 <EvanR> er
05:44:03 <EvanR> h - (h-x)
05:44:27 <EvanR> so the difference can be arbitrarily large
05:44:31 <EvanR> that's great
05:45:14 <opqdonut> > (5+10e30)-10e30 :: Float
05:45:16 <lambdabot>  0.0
05:45:16 <merijn> ooo_miguel: They end up returning "error foo" which throws when evaluated
05:45:24 <EvanR> > 123456789 - (123456789 - 7)
05:45:26 <lambdabot>  7
05:45:43 <EvanR> > 123456789.3 - (123456789.3 - 7)
05:45:45 <lambdabot>  7.0
05:46:08 <opqdonut> max float is ~10e38
05:46:33 <EvanR> k why do you feel the need to use Float which is not default :)
05:47:17 <opqdonut> > (10e29+10e37)-10e37 :: Float
05:47:19 <lambdabot>  0.0
05:47:25 <opqdonut> that's about the largest error you can get on float :)
05:47:43 <opqdonut> I thought you were using Float?
05:47:45 <EvanR> > 7e300 - (7e300 - 2e150)
05:47:46 <lambdabot>  0.0
05:48:04 <EvanR> k that's damning
05:48:10 <ooo_miguel> Is every function allowed to call "error" or can I forbid this somehow
05:48:15 <merijn> Isn't that just because that evaluates to Infinity?
05:48:31 <opqdonut> > (10e290+10e307)-10e307 :: Double
05:48:33 <lambdabot>  0.0
05:48:39 <opqdonut> that's the same with Double
05:48:41 <EvanR> no 7e300 is fine
05:48:49 <merijn> ooo_miguel: You can't rule out bottom without ruling out Turing completeness
05:48:53 <merijn> > 7e300 :: Double
05:48:54 <EvanR> right, i'm just trying to save you typing ::Float everywhere :)
05:48:55 <lambdabot>  7.0e300
05:49:07 <opqdonut> max double is 1e308 or so
05:50:07 <EvanR> so the max error is a function of the relative magnitudes
05:50:13 <EvanR> i hope
05:50:31 <merijn> EvanR: Yes
05:50:41 <opqdonut> yeah
05:50:49 <exarkun> The max imprecision, at least
05:50:50 <merijn> EvanR: There's a lot of literature on how to minimise compound errors
05:51:06 <exarkun> The max error will depend on what operations you perform. :)
05:51:10 <ooo_miguel> merijn: ok I understand. But can I rule it out for parts of my programms (which do not rely on Touring-completeness)?
05:51:12 * hackage text-show 3.8.3 - Efficient conversion of values into Text  https://hackage.haskell.org/package/text-show-3.8.3 (ryanglscott)
05:51:17 <EvanR> the difference between (x-h)+h and x i'm going to call an error
05:51:47 <merijn> ooo_miguel: No, that requires a rather fundamentally different language design
05:52:12 <merijn> ooo_miguel: Even without error people can write partial patterns
05:53:06 <merijn> :t let unsafeHeadWithoutUndefined l = case l of [] -> let x = x in x; (x:xs) -> x in unsafeHeadWithoutUndefined
05:53:08 <lambdabot> [p] -> p
05:53:30 <merijn> ooo_miguel: error is just a convenience function to make that easier to detect
05:53:54 <EvanR> even without error or partial patterns you can write an infinite loop with recursion
05:53:55 <opqdonut> partial patterns are easy to forbid
05:54:01 <opqdonut> there's even a compiler flag for it!
05:54:17 <merijn> opqdonut: Not if you're trying to forbid them in the presence of dumb people
05:54:35 <opqdonut> I mean technically easy
05:54:52 <EvanR> the tricky part is forbidding bottom in the presence of smart people
05:54:55 <opqdonut> yes
05:55:10 <opqdonut> a haskell without partial pattern matches wouldn't be a "fundamentally different language design"
05:55:14 <opqdonut> but a total haskell totally would
05:55:37 <EvanR> or eliminate smart people
05:55:42 <merijn> ooo_miguel: So banning error won't really help you, the simplest solution is "grep codebase for 'error' and yell at colleagues"
05:57:16 <fendor> *politely yell at colleagues
05:57:55 <dmwit> *facepalm when git blame tells you it's your own damn fault
05:57:55 <EvanR> ask colleagues for proof that the code where error is can't ever run
05:58:12 * hackage rebase 1.4.1 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-1.4.1 (NikitaVolkov)
05:58:12 <EvanR> carefully ensure the proof survives refactoring
05:58:26 <EvanR> assuming proof is right
06:01:12 * hackage rerebase 1.4.1 - Reexports from "base" with a bunch of other standard libraries  https://hackage.haskell.org/package/rerebase-1.4.1 (NikitaVolkov)
06:02:20 <ooo_miguel> merijn: your unsafeHead example will enter an inifinite recursion which is equivalent to bottom or error, right? So I would have to ban (arbitrary) recursion if I would like get rid of "error and friends"?
06:06:29 <ooo_miguel> and I understand that in general we can not decide if an arbitrary computation will ever complete. On the other hand many many functions do not have recursion and incomplete patterns. Still there is no way to guarantee (on the language level) that they will  complete.
06:07:02 <EvanR> yeah banning recursion entirely would help
06:07:22 <EvanR> more practically you want some trusted ways to do fold over things
06:07:24 <ooo_miguel> I am just trying to understand what "classes" of functions can be (easily) proven to terminate. 
06:07:30 <EvanR> now the language is being redesigned
06:07:47 <opqdonut> ooo_miguel: are you familiar with idris?
06:07:59 <opqdonut> (or agda?)
06:08:26 <opqdonut> those are total programming languages which prove / require you to prove termination
06:08:27 <ooo_miguel> idris nope. I started to look into agda once, but did not get far (yet)
06:08:46 <EvanR> you might be inspired to consider every inductive data type coming with an induction principle, or recursion principle that allows you to write functions with it as the domain
06:08:58 <EvanR> which necessarily terminates
06:09:00 <ooo_miguel> but thanks for reminding me of agda. Maybe I should give it another try (just for some little experiments)
06:09:37 <EvanR> programming with only induction principles is an exercise in hairshirtism
06:09:41 <EvanR> but it works
06:09:44 <merijn> ooo_miguel: Correct
06:09:47 <EvanR> (doesn't freeze)
06:11:04 <ooo_miguel> ok thanks everybody for the clarfications and ideas
06:22:42 * hackage arrayfire 0.3.0.0 - Haskell bindings to the ArrayFire general-purpose GPU library  https://hackage.haskell.org/package/arrayfire-0.3.0.0 (DavidJohnson)
06:23:10 <EvanR> heh, so floats are often used when the domain of interest is an area say 0 to 100, or 0 to 1000. Like a quadrant of a cartesian plane. But this includes the zone around 0 which has unlimited different exponents. (ok limited by machine limitations). Would it not make more sense to shift your grid over so your plane is covering an area with all the same exponent
06:23:47 <EvanR> do calculations in 1000-2000 instead
06:25:16 <EvanR> sort of... fixed point within floating point
06:26:20 <EvanR> i guess 1024 .. 2048
06:28:09 <Ariakenom> what are ghc minimum ram requirements?
06:28:17 <EvanR> my poor, wrong, intuition of reals
06:28:19 <dminuoso> Ariakenom: That depends on your program you are compiling.
06:28:31 <dminuoso> Ariakenom: I have heard of folks buying 64GiB of RAM to compile their haskell programs.
06:28:37 <dminuoso> (True story)
06:29:38 <MarcelineVQ> I've managed to build everything so far under 4 gigs of ram
06:30:24 <EvanR> i failed to build certain things on raspberry pi
06:30:46 <hpc> @quote cost.me
06:30:46 <lambdabot> monochrom says: These 113 blogging accounts of course don't cost me.  But I still get the feeling of lying around with 113 prostitutes... XD
06:31:00 <Ariakenom>  was looking at the pinebook pro that has 4 GB and thinking it sounded little
06:31:20 <hpc> @quote bug.cost.me
06:31:20 <lambdabot> SimonMarlow says: This is the largest program (in terms of memory requirements) I've ever seen anyone run using GHC.  In fact there was no machine in our building capable of running it, I had to
06:31:21 <lambdabot> fire up the largest Amazon EC2 instance available (68GB) to debug it - this bug cost me $26.
06:31:42 <Ariakenom> :D
06:32:07 <hpc> all the same, i was able to build ghc on a gig of ram before
06:32:19 <hpc> it depends on what features you're using and how much code you have, and whatnot
06:33:36 <Ariakenom> building ghc on a gig. sounds impressive
06:35:41 <dminuoso> What exactly is `ghc-pkg`? What kind of database is that behind it? Does cabal v2- interact with that?
06:38:57 <merijn> dminuoso: ghc-pkg is GHC's package database tool it's how GHC resolves packages
06:39:25 <merijn> dminuoso: cabal v2- controls what GHC by selectively passing in/masking packages from GHC's package database
06:40:14 <dminuoso> merijn: So cabal specifies a bunch of -...-db flags to control the package database of GHC?
06:40:38 <merijn> dminuoso: Yes, you can see this in the .ghc.environment files (if you have cabal set to generate them)
06:44:15 <dminuoso> merijn: Oh! These are just command line flags to GHC. :o
06:45:41 <dminuoso> merijn: What exactly is a package though? I mean from Haskell I import from modules.
06:47:19 <dminuoso> Ah. I suppose to GHC a package is just a collection of modules.
06:50:16 <merijn> dminuoso: And interface files for inlining, etc.
06:51:07 <dminuoso> merijn: I see. So a package db is just a collection of available packages that I could expose using say `-package-id`
06:51:13 <merijn> Yeah
06:53:05 <dminuoso> So if I specify some package in my `build-depends` clause in cabal and then use v2-build, that causes the package to be build, installed, registered to an appropriate package-db, and an appropriate package-idfflag to be issued to GHC?
06:56:06 <merijn> afaik, yes
07:29:42 <mpickering> Does anyone know why streamly implements `runStream` on a deep embedding rather than the CPS variant?
07:50:49 <pie_> is there some easy way I can get `partitionEithers :: Functor f => f (Either a b) -> (f a, f b)`?
07:51:04 <pie_> i tried cannibalizing someones implementation but it just semed to cause a hang or something :(
07:51:14 <sshine> pie_, 'get'?
07:51:21 <pie_> i mean i need an implementation of it
07:51:39 <sshine> pie_, ah, and the library version uses list functor only, right?
07:51:50 <pie_> yeah
07:52:28 <pie_> actually hold on i might have forgotten where i got stuck
07:52:53 <sshine> pie_, I think you need Foldable f.
07:53:14 <pie_> i checked, its as i answered
07:53:42 <pie_> i saw it used somewhere else so i tried to use something from Control.FoldL but I couldnt figure out how to use it or the Fold a b type
07:54:27 <pie_> hm
07:54:42 <pie_> well, what I really want is to take one of these things http://hackage.haskell.org/package/turtle-1.5.15/docs/Turtle-Shell.html#t:Shell
07:54:54 <pie_> and split it in two based on a predicat
07:55:18 <pie_> *per-stream-element predicate
07:59:17 <pie_> be right back, im going to grab some food, but yeah im totally stuck on this. would be nice to get my script working
08:01:49 <lyxia> you might want to look into merging consumers instead of splitting producers
08:03:04 <sshine> pie_, the left side of the problem involves 'Functor f => f (Either a b) -> f a', which would be a generalisation of 'Data.Either.lefts'. but given only 'fmap', how can you turn [Left 1, Right 2] into [1]?
08:04:10 <lyxia> Shell (Either a b) -> (Shell a, Shell b) is hard because, if you run the Shell a component, it will run the Shell (Either a b) argument, but where do you store all the b's? How do you tell Shell b not to rerun Shell (Either a b) again?
08:06:34 <Ariakenom> (sshine: im unsure whether your question was for pedagogical purposes or not, but it's impossible)
08:06:46 <sshine> Ariakenom, it was.
08:07:08 <sshine> Ariakenom, thanks for noticing. :)
08:07:47 <sshine> Ariakenom, I figured it might be more clear to see that it's not possible by breaking it down into the smallest impossible sub-problem. :-P
08:07:52 <dmwit> pie_: You're going to need more than Functor. But e.g. Filterable would likely be enough: https://hackage.haskell.org/package/witherable-0.3.4/docs/Data-Witherable.html#t:Filterable
08:08:38 <Ariakenom> sshine: yeah, good technique. carry on :)
08:09:38 <sshine> dmwit, do you think Filterable might eventually end up in base?
08:09:42 * hackage lightstep-haskell 0.3.0 - LightStep OpenTracing client library  https://hackage.haskell.org/package/lightstep-haskell-0.3.0 (DmitryIvanov)
08:13:04 <dmwit> I dunno. I don't see a lot of pressure to add it, so probably not.
08:13:11 <dmwit> But "eventually" is a long time.
08:13:12 * hackage pell 0.1.2.0 - Package to solve the Generalized Pell Equation.  https://hackage.haskell.org/package/pell-0.1.2.0 (lbrunjes)
08:27:36 <pie_> sshine: oh hm i guess Functor doesnt give you head
08:27:43 <pie_> functors arent lists!
08:30:31 <EvanR> lists also don't give you head, or tail. They might be empty
08:30:36 <EvanR> Stream is where it's at
08:36:37 <pie_> sshine: hm ok i kind of et the stuff about rerunning
08:37:22 <pie_> i kind of assumed id get two streams that block until they are read
08:37:51 <TheCommieDuck> so I'm currently finding myself using data Foo a = Foo { blah :: X, blah2 :: Y ... extraStuff :: a }; type Foo1 = Foo X; type Foo2 = Foo Y; type Foo3 = Foo (Z, X, A, B); a lot. Is this a sign I'm doing something horribly wrong?
08:38:35 <pie_> the only way to unwrap Shell into IO seems to be the fold function they give, but unwrapping shell just to rewrap it somehow later seems bad
08:39:13 <benjwadams> Is an "arrow" the same as a "morphism" in the nomenclature of category theory?
08:39:45 <merijn> benjwadams: Yes
08:39:49 <benjwadams> Maybe this isn't a pure Haskell question, but I'm trying to understand some categories and how they're used
08:39:59 <EvanR> ok, i think this is true. Let a and b be floating point numbers in the range 2^n to 2^n-1. Then (a - b) + b = a for serious this time.
08:40:05 <EvanR> er
08:40:11 <EvanR> 2^n to 2^(n+1)-1
08:40:24 <EvanR> like 1024 to 2047
08:40:29 <f-a> TheCommieDuck: well it is parametrised, I don't see much problems with it
08:40:30 <EvanR> .999
08:40:58 <EvanR> [2^n, 2^(n+1))
08:41:46 <EvanR> basically if they have the same exponent, then you can get their difference and the difference can be added back exactly
08:41:55 <benjwadams> What's a good resource if I want to understand general category theory concepts as pertains to programming and functional languages.  I took a Uni math course and the prof suggested "Categories for the Working Mathematician", but it seems to require a bit more of a math background than what I was exposed to
08:42:10 <EvanR> should work even with denormals
08:43:10 <dminuoso> benjwadams: Bartosz Milewski has a series of lectures on video, uploaded to youtube. They are of really good quality and from a programmers perspective.
08:43:18 <merijn> benjwadams: tbh, I don't think one exists, because I haven't found one for myself :p
08:43:25 <dminuoso> benjwadams: Equivalently he has an online book and a large series of blog posts. :)
08:43:46 <merijn> benjwadams: On the upside, you don't really need to write useful stuff :p
08:43:52 <TheCommieDuck> okay cool, I was wondering if it was in some way better done with data families, but I don't think so
08:44:02 <benjwadams> dminuoso: I saw a number of Bartosz's blog posts and they seemed helpful.  Albeit I didn't go through all of them.
08:44:11 <TheCommieDuck> just after I found myself repeating said pattern 3 times
08:44:22 <dminuoso> benjwadams: Have you tried his lectures on youtube?
08:44:45 <benjwadams> dminuoso: I wasn't aware of them.
08:44:47 <dminuoso> benjwadams: https://www.youtube.com/playlist?list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_
08:44:52 <benjwadams> I'll have a gander, thanks for the info.
08:45:14 <dminuoso> benjwadams: (He has two more series for more advanced category theory). They connect well and connections to programming are made regularly.
08:49:26 <EvanR> so if you have all "points" in a plane within the [2,4]x[2,4] square, you can rely on the difference law working. If you add a different of points to a point you get the other "difftrahend" back
08:49:45 <EvanR> unintuitive since we always like to use [0,1] x [0,1]
08:49:46 <dminuoso> benjwadams: Another decent resource might be "Conceptual Mathematics: A First Introduction to Categories"
08:54:15 <dminuoso> benjwadams: Its less programming focused, but the real value in category theory becomes when you generalize across fields, transport problems and solutions..
08:55:19 <benjwadams> My coworkers don't believe me on that front :(
08:55:52 <dminuoso> benjwadams: What company do you work for?
08:57:17 <phadej> CT is in a way useful alone too. "I have this thing Foo", Can I combine two Foos into one Foo? Oh, CT has this concept of product, product should ... and when you find product you know it's the one
08:58:07 <phadej> i.e. you may have confident "it must be it" moments, not due "gut feeling" but due "math".
08:58:34 <merijn> hmm, cabal-install is very robust against getting killed while updating the package list >.>
08:58:48 <phadej> merijn: or building dependencies :)
08:59:02 <merijn> phadej: Haven't had issues with that
08:59:11 <geekosaur> haskell doesn't run signal handlers directly like C does, so it can defer most of them (aside from SIGKILL)
08:59:21 <geekosaur> well, ghc doesn't
08:59:29 <merijn> geekosaur: I fail to see how that relates
08:59:48 <phadej> you might have too long masked sections, yes.
08:59:50 <geekosaur> maybe I misunderstood "robust again st"
09:00:07 <merijn> geekosaur: I mean that it leaves the index in an incorrect state and then refuses to do anything
09:00:12 <geekosaur> recovers from, or delays to?
09:00:29 <merijn> And nuking it doesn't work apparently, because now it complains it can't get file time of 01-index.tar
09:00:31 <phadej> oh, I meant in the sense that `cabal v2-build` is sometimes hard to kill
09:00:49 <geekosaur> yes, there's more than one possible interpretation there
09:01:05 <merijn> "cabal corrupts its own global state unrecoverably upon SIGINT"
09:01:25 <geekosaur> that'd be unfortunate, yes
09:06:54 <pie_> dmwit: sshine: funny, someone just asked for mapmaybe
09:06:55 <pie_> https://github.com/Gabriel439/Haskell-Turtle-Library/issues/366
09:13:08 <pie_> dmwit: sshine: well actually, mfilter is given because Shell has MonadPlus
09:13:28 <sclv> benjwadams: start with lawvere and schanuels “conceptual mathematics” for an easier onramp
09:24:05 <efm> benjwadams: I found https://math.mit.edu/~dspivak/teaching/sp18/7Sketches.pdf and https://arxiv.org/pdf/1809.05923.pdf to be clear starting points for category theory
09:24:32 <pie_> it remains an open question whether my partitionShellEithers will deadlock
09:25:47 <sshine> pie_, how'd you make it?
09:28:45 <sshine> pie_, the MonadPlus variant of mapMaybe?
09:33:12 * hackage refined-http-api-data 0.1.0.0 - http-api-data instances for refined types  https://hackage.haskell.org/package/refined-http-api-data-0.1.0.0 (brandonhamilton)
09:34:17 <pie_> holy "+!% my code works! I think!
09:34:27 <merijn> :)
09:34:42 <pie_> its probably subtly buggy but gotta start somewhere
09:34:53 <pie_> sshine: please excuse my sins:
09:36:01 <pie_> sshine: https://bpaste.net/show/4QVRY
09:38:17 <pie_> the code is suspiciously slow
09:39:30 <heath> any ideas why this might be failing? https://gist.github.com/heath/89f951d57864dc827ae300841a1ca675
09:39:51 <heath> I was pointed to https://github.com/digital-asset/daml/blob/master/language-support/hs/bindings/README.md#using-these-bindings-outside-of-this-repository which is great, but now I'm wondering why what I did might be failing
09:41:45 <pie_> maybe not slow
09:44:42 * hackage aeson-yaml 1.0.4.0 - Output any Aeson value as YAML (pure Haskell library)  https://hackage.haskell.org/package/aeson-yaml-1.0.4.0 (patrick)
09:48:42 * hackage months 0.1 - Month, YearMonth, Quarter, YearQuarter types  https://hackage.haskell.org/package/months-0.1 (phadej)
09:48:59 <N3RGY> Does anyone have any recommendations for highly principled GUI libraries? Some things I have been pleased with in the path include Elm's highly restrictive UI paradigm and Purescript's Halogen. Lately, I've been thinking that there are some interesting possibilities for semi-mechanically constructing UIs using lenses, but I wouldn't be surprised if something like this already existed
09:49:42 * hackage hkd 0.1 - "higher-kinded data"  https://hackage.haskell.org/package/hkd-0.1 (phadej)
09:50:33 <dminuoso> N3RGY: What kind of GUI are you thinking about?
09:50:48 <dminuoso> N3RGY: You mentioned Elm, which strongly suggest web frontends, or are you looking for something else?
09:52:11 <N3RGY> dminuoso: I'm mostly looking for inspiration and techniques - this isn't for any particular task. My UI-foo is quite bad
09:52:54 <N3RGY> I don't really care too much about the underlying technology, although I think something native rather than web based would be more useful to me in the context of Haskell programming
09:53:04 <dminuoso> N3RGY: Have you looked into FRP in the sense of Conal Elliott?
09:53:23 <N3RGY> I'm pretty familiar with Conal's Lambda-CCC, but only passingly familiar with his FRP stuff
09:53:43 <N3RGY> I've looked into FRP a number of times but never found it too compelling
09:53:58 <ysangkok> why not?
09:54:16 <dminuoso> N3RGY: It's quite possible that you looked into something not quite FRP. :)
09:54:35 <pie_> apparently reflex is good?
09:54:46 <N3RGY> Every time I've looked into it, I've never felt like I was discovering some amazing simplifying abstraction. It just feels like yet another kind of messy way of getting OK UIs with a lot of work
09:55:01 <N3RGY> dminuoso: Possible, but I've looked at a bunch of different things. I remember the name reactive-banana, but there were some others too
09:57:07 <N3RGY> The vague thing I'm thinking now is that it would be cool to construct some sort of mapping between a data type representing the UI state and various standardized ways of representing different kinds of constructors
09:58:05 <N3RGY> e.g. if you had a type T with a bunch of unary constructors, you would have something like "dropdown :: (Enum t, Bounded t) => UI t" and you could use this to instantiate a dropdown menu for T
09:58:41 <dminuoso> N3RGY: So according to Conal, two core properties of the FRP he's thinking about relies on being continous and denotational.
09:59:12 <N3RGY> Yeah, I'm not a big fan of the continuous aspect
09:59:15 <dminuoso> If you step into some of hipster "reactive" sounding projects, a lot of them are neither.
09:59:18 <N3RGY> I like the idea of discrete UIs
09:59:40 <N3RGY> Modern UIs are way too "continuous" for my tastes, in the sense that they continuously update when I'm trying to click on them :)
10:00:06 <N3RGY> (One of my motivating pet peeves for getting better at UIs is live-updating search results)
10:00:40 <N3RGY> I also remember that a lot of FRP things had a notion of time built in, which I thought seemed kind of overkill
10:02:15 <N3RGY> This is why I liked the Elm paradigm a lot - it's about plumbing discrete events up and down your UI data structure
10:02:51 <ysangkok> isn't it necessary to talk about time to be more efficient? you could say "batch all these updates into one quantum"
10:03:40 <N3RGY> I don't think that should happen at the UI layer
10:03:51 <N3RGY> Just an aesthetic preference, I don't have any super principled reason for believing that
10:05:05 <N3RGY> The discrete state transition model also has its own performance benefits - e.g. there is lots of work on diffing two UI model states to incrementally update the visible representation of the UI
10:05:49 <conal> N3RGY: if you don't see value in continuous time, don't worry about it. if you drop the (even more fundamental) denotative / "genuinely functional" nature, however, you'll lose the precise, implementation-independent (non-operational) specification, so the implementation will be "not even wrong". the denotational discipline ensures consistency and absence of abstraction leaks and enables practical rigor/dependability.
10:07:14 <conal> discrete time systems have fundamental problems (hence frp), but they're hard to see without the clarity & rigor of the denotational discipline.
10:09:56 <N3RGY> That's basically what I'm after - a way of adding denotational semantics to the Elm model. I think the thing I mentioned earlier could work well for that. If you have a type T underlying your UI, you create an object like "Iso T G", where G is composed of types that correspond to standard UI elements. E.g. if you have "data T = T Bool Bool", you could have something like "ui :: Iso T (VerticalStack (Dropdown Bool) (D
10:09:56 <N3RGY> ropdown Bool))"
10:10:45 <N3RGY> And then the UI library knows how to render these standardized elements, and can use the Iso to update your underlying data model. Or something like that - there are lots of details it would make sense to change
10:11:03 <N3RGY> What are some fundamental problems with discrete time systems?
10:13:25 <conal> N3RGY: Great. I encourage you to work out the denotation rigorously, and ensure to explain *everything* in your API in terms of the denotation (otherwise it isn't an genuine spec for your API), and then ask others to check it. I'm always happy to look at attempts to specify things denotationally and give feedback.
10:14:50 <N3RGY> Conal, which FRP library is yours? I want to see what the denotative spec looks like
10:18:47 <conal> N3RGY: Start at https://github.com/conal/talk-2014-lambdajam-denotational-design and follow the links there, including two other talks and a paper. Also http://conal.net/papers/push-pull-frp/, which gives a denotation. Very little has to do with continuous vs discrete, so that topic can be postponed until more shared denotational context is available.
10:19:17 <N3RGY> thanks
10:19:32 <conal> N3RGY: some people have also found this conversation helpful: https://www.haskellcast.com/episode/009-conal-elliott-on-frp-and-denotational-design . 
10:20:23 <conal> N3RGY: you're welcome. have fun! i'm often on #haskell and happy to answer questions.
10:25:11 <N3RGY> As I probably should have done earlier, I googled "haskell lens GUI" and found lgtk, which seems like it at least has the right words in it. Is anyone familiar with this?
10:25:39 <purelazy> Haskell cannot "show" functions. Is there a a functional language which can?
10:25:40 <conal> N3RGY: As a teaser for a later continulity/ous-vs-discrete conversation, advantages of continuous include well-definedness, quality/precision, and efficiency.
10:25:50 <koz_> purelazy: How do you show a function in general?
10:25:57 <koz_> (suppose it has an infinite domain)
10:26:44 <N3RGY> purelazy: Some languages allow you to inspect a simplified representation of the function, at least in the REPL if not necessarily at runtime. I suppose GHCi could show you bytecode or core
10:28:22 <purelazy> I was wondering if anyone knows of an interpreted FP language, which kept a lot of the text representation.
10:28:22 <conal> purelazy: except for IO & friends, Haskell is a denotative / "genuinely functional" language, and so does not allow one to distinguish between things that are denotationally equal such as functions (for which equality is extensional). 
10:29:14 <conal> purelazy: showing one text representation (of which there are many) would violate this central principle of denotative languages.
10:29:27 <conal> purelazy: which breaks reasoning.
10:29:28 <purelazy> Like doing a lambda evalutaion on paper
10:30:50 <N3RGY> conal: I'm struggling to see how disposing of cardinal time and switching to discrete steps (equivalent to ordinal time) would induce ill-definedness. Leaving "quality/precision" and "efficiency" for now - not sure what the former means and haven't thought about the latter
10:33:26 <N3RGY> Also, listening to your Haskell Cast thing now - I should probably mention that I have zero interest in timed animations
10:33:35 <N3RGY> Yet another pet peeve of mine
10:34:02 <EvanR> N3RGY: have you looked at "immediate mode gui"
10:34:02 <conal> N3RGY: A precise denotational specification exactly addresses questions of well-definedness.
10:34:06 <N3RGY> I want the computer to do things as quickly as it possibly can, not to waste my battery with zooms and fades and stuff
10:34:20 <conal> N3RGY: as I said, don't worry about continuous time or timed animations for now.
10:34:34 <conal> s/said/suggested/
10:34:41 <N3RGY> conal: Sure, but is there a short high-level teaser for why denotation is hard with discrete steps? It seems like it should be easier, naively
10:36:39 <EvanR> it's a pretty slick and efficient way to do a GUI. It's operational but good
10:36:51 <N3RGY> EvanR: I saw imgui at some point in the past. It looked cool but struck me as extremely non-compositional
10:37:15 <N3RGY> One of the things I like a lot about Elm (and the hypothetical imaginary thing I'm looking for at the moment) is that composition of UI components is trivial
10:37:38 <EvanR> you mean, layouting multiple sub-ui's in a frame?
10:37:44 <EvanR> it can do that
10:37:49 <N3RGY> Sure, or defining a single UI definition that you reuse many times
10:38:03 <EvanR> usually immediate mode guis don't have first class functions, so doing it in haskell should be even better
10:38:31 <EvanR> first class functions + first class "UI actions"
10:39:15 <N3RGY> OK, I will read about it some more. Looking at the github page, it still makes me uneasy to see the interleaving of state definitions and UI elements like that
10:39:15 <EvanR> imperative programming can be compositional if the language/api/datastructure has a proper denotational semantics
10:39:47 <EvanR> but it usually doesn't :)
10:40:10 <conal> EvanR: indeed. denotational semantics was invented exactly to explain imperative languages, because the languages of the day were imperative.
10:40:51 <conal> EvanR: doing so is very helpful in that the deep flaws of imperative languages come into sharp focus. See https://gist.github.com/conal/d578f9b47648338e3527 .
10:41:21 <EvanR> i didn't even know that, thx
10:41:35 <conal> EvanR: ditto for imperative/operational APIs.
10:41:40 <conal> EvanR: you're welcome!
10:44:12 * hackage arrayfire 0.4.0.0 - Haskell bindings to the ArrayFire general-purpose GPU library  https://hackage.haskell.org/package/arrayfire-0.4.0.0 (DavidJohnson)
10:46:25 <nshepperd> another way to conceive of the difference between continuous and discrete time is that the 'caller' of a continuous Behaviour gets to decide 'when' to evaluate it, whereas the 'caller' of a discrete Event just gets whatever events it's given
10:47:33 <conal> nshepperd: i agree. continuous is "resolution-independent", whether in space, time, or value.
10:47:49 <nshepperd> it's the difference between forall and exists
10:48:25 <conal> it's the central argument in "why functional programming matters". http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html
10:50:59 <N3RGY> nshepperd: I understand the thing you are analogizing continuous and discrete time to (choose/chosen and forall/exists), but I don't understand how the analogy is true. Could you expand on that a bit more?
10:54:54 <EvanR> if Behavior a = Time -> a and Event a = (Time,a), there's the analogy
10:55:11 <nshepperd> iirc the reference design defines a behaviour as a function of time: Behaviour a = Time -> a
10:55:11 <EvanR> you tell me a time, i tell you a time
10:55:13 <N3RGY> Oh ok. What about Event a = a
10:55:26 <N3RGY> That's what I want
10:55:29 <EvanR> Event a = a seems a bit dull
10:55:29 <N3RGY> throw time out the window
10:55:31 <nshepperd> and an Event as a sequence of (Time, a) pairs: Event a = [(Time, a)]
10:56:01 <N3RGY> EvanR: Dull is good for UIs
10:56:06 <nshepperd> throwing time out the window doesn't make any sense
10:56:18 <EvanR> the idea is you are talking about the entire behavior of the app through time, not at an instant
10:56:55 <EvanR> some apps do sit there and wait for you or some agent to do something
10:57:00 <EvanR> others have a time aspect
10:57:14 <EvanR> "windows will restart in 9 seconds..."
10:57:49 <EvanR> "bombaring the webserver at 10 ms intervals"
10:58:01 <EvanR> video games
10:58:13 <N3RGY> I find it's almost always much cleaner to tack time onto a program after the fact, using some kind of Tick event. An explicit dependency on time makes testing and such harder. Similar set of problems to those introduced by impurity
10:58:24 <EvanR> i do not, having done that millions of times
10:58:28 <EvanR> in different ways
10:58:37 <nshepperd> an example of Event is the keyboard :: Event Char.
10:59:13 <nshepperd> at various times, the user presses a key... this is discrete, it happens at a time decided by the user
10:59:33 <N3RGY> Interleaving timers into my program always makes them vastly more complicated. I wrote about this in the context of distributed systems at http://yager.io/Distributed/Distributed.html
10:59:41 <EvanR> an example of where tick events are very impractical is in audio programming
10:59:49 <N3RGY> I think the program shouldn't care when the user pressed the key
10:59:55 <nshepperd> 'interleaving' isn't really what we're describing here
10:59:57 <EvanR> in MOO servers, they are less efficient
11:00:09 <N3RGY> EvanR - this paradigm obviously doesn't apply for hard-realtime systems
11:00:11 <EvanR> on webpages it's a waste
11:00:17 <nshepperd> of course the program has to care when the user pressed the key, unless you want the text to come out backwards
11:00:20 <EvanR> N3RGY: why?
11:00:41 <N3RGY> nshepperd: The program has to care about the order of keys, not the cardinal time at which they happened
11:00:42 <nshepperd> in fact the program *must* care, because you can't get keypressed from the future
11:01:03 <N3RGY> EvanR: Because hard realtime systems are one of the few applications where explicit time handling is actually required
11:01:20 <N3RGY> I write those in C or Rust, not Haskell, and I don't give them GUIs :)
11:01:23 <EvanR> sorry, i guess you have it figured out
11:01:42 <nshepperd> I think you're bringing your own preconceptions here and coming to a false conclusion about what (Time, a) means
11:02:07 <N3RGY> Yeah, I think we're talking past each other a bit
11:02:25 <N3RGY> I'm kind of mystified why you guys are saying that the time at which something happens is important for constructing a UI
11:02:44 <N3RGY> I imagine computer programs as composed of a sequence of discrete state transitions, because this is mostly literally true
11:02:50 <nshepperd> it has to be part of the model, because you want the UI to react instantly
11:02:53 <EvanR> in real time video games, i do not want to think of it as sitting there waiting for a move. It's just not what my abstract model of that kind of world is
11:03:07 <EvanR> things are moving continuously through space, and time is passing
11:03:27 <N3RGY> nshepperd: I want the UI to react as fast as possible - why would this require me to explicitly model time?
11:03:27 <EvanR> the audio stream ought to be a discritization of a (synthetic) analog signal
11:03:57 <nshepperd> because you can't conceptualize 'as fast as possible' unless you know what time is?
11:04:04 <N3RGY> That is not at all true though
11:04:04 <EvanR> discrete time bullets pass through walls, which is silly
11:04:23 <N3RGY> If you want to do anything *except* as fast as possible, you need to account for time
11:04:24 <nshepperd> and yeah as EvanR says lots of applications have things happening independent of input
11:04:35 <N3RGY> If you want to go as fast as possible, you just let the computer rip
11:04:43 <N3RGY> Keeping track of time is extraneous
11:04:59 <nshepperd> keeping track of time != modeling time
11:05:05 <EvanR> many applications are modeling time for whatever reason, music player, video game, video editor
11:05:11 <N3RGY> nshepperd: I think that's better modeled by an external tick generator sending ticks to the discrete stepped process, most of the time
11:05:25 <N3RGY> Sure, but as I mentioned earlier none of my applications are doing things like animations
11:05:28 <EvanR> in a MUD, that'd be bad
11:05:43 <N3RGY> Why?
11:05:50 <EvanR> it's a waste of CPU
11:06:12 <N3RGY> The external tick generator paradigm should use, at worst, the same amount of CPU as interleaved timers
11:06:15 <EvanR> "minecraft does it" doesn't make it right
11:06:24 <chreekat> Perhaps you could say it's extraneous because it is happening in a part of the system you are not modeling. Like how do you denotate, "and here is where the computer rips". FRP tries to give that some meaning, I think
11:06:29 <EvanR> no, this is a question of polling vs event driven
11:06:39 <N3RGY> chreekat: Why would I bother modeling that for something like a text editor?
11:06:47 <nshepperd> 'external tick generator' is inserting time into your model in the worst way
11:06:54 <EvanR> when events are coming at less speed than a poll frequency, polling is worse
11:07:18 <nshepperd> and again 
11:07:21 <N3RGY> EvanR: You can easily recreate a polling program from an event driven one, but not vice versa
11:07:22 <EvanR> example, process switching vs cpu clock speed
11:07:22 <chreekat> Dunno. I use bash when it's appropriate, even though I love Haskell
11:07:28 <nshepperd> 'interleaved timers' isn't what frp is about
11:07:41 <EvanR> you don't want to check every process every cpu clock tick to see if it should switch
11:07:47 <EvanR> you want events, interrupts
11:08:03 <EvanR> agreed, events are better
11:08:46 <chreekat> N3RGY: to put it another way, I feel like your last question to me could be restated, "Why bother with formal methods when designing a text editor?"
11:08:47 <EvanR> uniform tick = polling
11:08:50 <nshepperd> N3RGY: i think you're actually arguing for frp without realising it
11:09:16 <N3RGY> chreekat: My thoughts are much more accurately described as "why bother modeling time when it's not relevant to the desired behavior of your system"
11:09:25 <N3RGY> Or rather, "why bother modeling *cardinal* time"
11:09:40 <EvanR> if the app literally sits there waiting for input that's fine
11:09:54 <EvanR> no need for time
11:10:06 <chreekat> N3RGY: i'm hearing conflicting things: time doesn't matter, but you want things to happen at certain times? "as fast as possible"
11:10:20 <N3RGY> chreekat: "as fast as possible" doesn't require me to schedule things
11:10:31 <N3RGY> It's literally the only paradigm that doesn't require you to schedule things
11:10:38 <EvanR> even microsoft paint has time though, the box surrounding a selection has an animated border
11:10:39 <chreekat> Ah, well modeling an Event as (Time, a) isn't about scheduling
11:10:41 <nshepperd> nobody mentioned 'scheduling'
11:10:59 <N3RGY> EvanR: I do not consider MS Paint a particularly admirable UI
11:11:05 <EvanR> you take that back
11:11:11 <EvanR> RIP ms paint
11:11:16 <N3RGY> nshepperd: "but you want things to happen at certain times" == scheduling
11:11:19 <nshepperd> no
11:12:13 <N3RGY> I don't want things to happen at a "certain" time - I don't care concretely when they happen. I just want the time at which they happen to be the soonest possible time. That's an ordinal constraint, not a cardinal one
11:12:28 <EvanR> and i'm not sure any "paradigm" is going to help in the area of "making a good UI" i.e. a design question
11:13:03 <N3RGY> My experience with using a few well-designed UI systems causes me to disagree
11:13:08 <chreekat> Modeling an Event as (Time, a) is about giving events a meaning that can be compared to other events happening in the system. Like, I could create an arbitrary list of keyboard events and an arbitrary list of mouse events, and since they are bundled with "the time that they occurred", I can combine those things to model the state of the system at a particular moment
11:13:40 <chreekat> where by arbitrary I mean in the QuickCheck sense
11:13:44 <N3RGY> chreekat: if I'm building a text editor, [(Time, Keypress)] is not more useful than [Keypress] as long as the latter comes in temporal order
11:13:58 <nshepperd> right, when you model events as (Time, a) you can compare them to determine which happens first
11:14:06 <EvanR> many editors do have the ability to record events and replay them in different circumstances
11:14:10 <nshepperd> N3RGY: [Keypress] is not composible
11:14:15 <N3RGY> Why would I bother doing that? I will just give them to the program already sorted!
11:14:33 <N3RGY> nshepperd: Not composable in what sense?
11:14:39 <nshepperd> N3RGY: you can't compare [Keypress] with [MouseEvent] to get [Either Keypress MouseEvent] because you don't know which happened first
11:14:54 <nshepperd> or which order to put them in
11:14:55 <EvanR> two sorted [(Time,a)] can be merged 
11:15:13 <EvanR> lazily
11:15:43 <N3RGY> That's why the core logic of my program would operate directly on [Either Keypress MouseEvent]. There is also a problem with [(Time, a)] - if you are merging two streams, you either need to have flush events in both streams, or you need to block indefinitely
11:15:55 <EvanR> not necessarily
11:15:55 <chreekat> N3RGY: i see what you're saying, and as long as you have a monolithic source of events, then yeah, time isn't super important. But you could bundle events with Times in order to allow more arbitrary combinations of event sources
11:16:31 <EvanR> you are jumping straight to implementation issues, and there are some cool techniques out there
11:16:43 <EvanR> but you asked about denotation first
11:16:46 * chreekat isn't convinced that this *model* of an event is critical to an actual implementation - only for modeling systems
11:16:55 <tsahyt> N3RGY: you're really just moving the problem to somewhere else, aren't you. If you have a sorted [Keypress], then how are they sorted if not by time. If you already have an [Either Keypress MouseEvent], where exactly does that come from and how was it merged?
11:17:24 <tsahyt> N3RGY: as a matter of modelling, time is just something you have to deal with one way or the other. Whether your actual implementation really does keep track of time values or not is another question entirely.
11:17:36 <N3RGY> tsahyt: This is an easily tractable problem that doesn't require me to complicate the relevant logic of my program
11:17:56 <tsahyt> and from what I've seen, FRP implementations do not keep timestamps around
11:18:06 <nshepperd> why are you making all these assumptions about complicating the logic
11:18:40 <tsahyt> N3RGY: You're just obscuring it, that's all. Time is still there in the logic of your program. and that can come back to bite you.
11:18:44 <N3RGY> What assumptions are you talking about? It is a fact that modeling cardinal time for a system that only cares about the order of events is complicating the system
11:19:12 <nshepperd> no
11:19:13 <N3RGY> tsahyt: Yes, as I have said many times, ordinal time is still there. I'm just throwing away the cardinal aspect, because I don't need it (for the hypothetical applications I'm talking about)
11:19:14 <EvanR> time is part of the denotation, not necessarily the implementation
11:20:04 <conal> It looks to me like most of this conversation lacks the foundation of having a precise specification and hence is getting mired in the usual way.
11:20:05 <N3RGY> It's easy to provide a denotation that A) has ordering and B) doesn't have real-valued Time in the description. I.e. the state monad
11:20:11 <conal> "As tedious as arguing about definitions is, it can't hold a candle to arguing without definitions." - [David R MacIver](http://www.drmaciver.com/tag/bad-arguments/)
11:21:14 <conal> So I recommend defining a (precise/unambiguous) denotation and hashing things out from there.
11:21:16 <conal> (my 2 cents)
11:21:18 <tsahyt> Hm. I'm not sure Time is even treated as a cardinal number in the denotational semantics either. At least it doesn't necessarily have to be, since it's only ever used for comparisons iirc
11:21:28 <tsahyt> but you still can't just throw it away
11:22:07 <N3RGY> If that's true, why can't you throw it away (assuming you've already dealt with merging events in temporal order)?
11:22:50 <EvanR> one global source of events, "the event queue", is one way to present a toolkit. But it is nice to be able to define new first class events from other ones
11:22:52 <nshepperd> "assuming you've already dealt with merging events" means that you can't have 'merge :: Event a -> Event b -> Event (Either a b)'
11:23:10 <EvanR> by merging, filtering, mapping
11:23:10 <nshepperd> or most of the other useful frp functions...
11:23:26 <EvanR> i.e. functional programming
11:23:33 <N3RGY> nshepperd: Right. I don't really see a reason to want that primitive though
11:23:49 <tsahyt> There we go. "Historically in FRP, T = R. As we'll see, however, the semantics of behaviors assumes only that T is totally ordered". citing from conal's Push-Pull FRP paper.
11:23:50 <EvanR> because functional programming rocks
11:24:02 <tsahyt> that's \mathbb{R} of course
11:24:05 <N3RGY> EvanR: you can merge/filter/map over a list even if it doesn't have time values in the list though... 
11:24:16 <nshepperd> personally i like my programs to be composable
11:25:10 <N3RGY> nshepperd: The discrete-time paradigm is composable. You define injectors which are used to construct the values of the sum type that's stuck into the event queue, and then you pattern match on events
11:25:11 <nshepperd> adding new event sources by defining them in their own file, instead of having to wire them into the monolithic AllInput.hs, sounds good to me
11:25:15 <tsahyt> N3RGY: taking that logic to the extreme case, "if the program is already written, there's no reason to talk about it anymore". well, yea, true.
11:25:17 <EvanR> N3RGY: well, in the semantics of FRP from the old days, the time is used for something. Whether you would have it available in real life is another story, in a real library. Of course, you'll notice toolkits all give you a timestamp for each event.
11:25:22 <EvanR> not even because of FRP
11:26:02 <EvanR> because you can't add time reliably to an event if it's not already there
11:26:06 <conal> tsahyt: unless you want differentiation & integration, which enable incredibly useful & natural ways to specify behavior. however, to me, having a denotation at all is a more fundamental choice, and eliminates a lot of operationally-motivated but denotationally inconsistent arguments.
11:27:15 <dmj`> phadej: ping
11:27:49 <tsahyt> conal: These are indeed very useful things to have, though wouldn't it suffice to add an event stream that just outputs time deltas periodically? You still don't need to have insight into what T is, the absolute time shouldn't matter.
11:27:55 <N3RGY> Like, have any of you guys used Elm? I'm not arguing for some entirely hypothetical paradigm here. The behavior of an elm UI is defined by a number of pure functions that are independent of time. You have a function (s -> a -> s) where "s" is your program state and "a" is an event type. This function is applied to events in the order they reach the runtime. This is sufficient to model... whatever you want, basically
11:28:36 <N3RGY> Functions of type (s -> a -> s) are also very friendly to model formally
11:28:40 <EvanR> yeah javascript is a non-concurrent single state at a time
11:28:47 <conal> interestingly, the discrete so-called "frp" systems i've seen all lack any precise denotational specification in addition to lacking continuous time (temporal modularity/resolution-independence).
11:28:53 <EvanR> all time happens through event handlers
11:28:55 <N3RGY> Right, this is how I think most UIs should work - non-concurrent single state
11:29:07 <chreekat> N3RGY: are a lot of your descriptions concerned with the implementation of a system?
11:29:24 <N3RGY> If "a system" includes things like "the contents of a body of text", then sure
11:29:46 <EvanR> i've found concurrency indispensible for GUI programming
11:29:57 <N3RGY> EvanR: how so?
11:30:16 <EvanR> i mean, are we not staring at an IRC client
11:30:29 <glguy> damn, you caught me
11:30:40 <N3RGY> Yes, but I'm not sure what that's intended to demonstrate
11:30:42 <lavalike> same
11:30:44 <EvanR> there are many concurrent processes going on in IRC at any given moment
11:30:53 <[exa]> completely unconcurrent event-driven one, in my case :]
11:30:54 <EvanR> uploads downloads windows
11:31:03 <chreekat> Something that took me a while to figure out is that denotational design starts with describing what you intend your program to do, rather than describing how it does it. Like, this Event a = (Time, a) is something that could make your user stories / functional requirements / customer promises more precise -- not something that gives you a totally rad library to design UIs
11:31:14 <tsahyt> EvanR: I for one am staring at a matrix client
11:31:42 <N3RGY> EvanR: "Things are happening at the same time" doesn't mean "my UI code needs to have multiple concurrent things going on"
11:31:43 <glguy> A bad IRC client is still an irc client
11:32:13 <N3RGY> In fact, an IRC client is an almost perfect example of something that can be entirely event-driven
11:32:15 <EvanR> you can implement concurrency manually, with single threaded techniques, and be merry, or gravitate to better language
11:32:22 <N3RGY> You could write an IRC client around a single epoll loop easily
11:32:37 <EvanR> concurrent programming isn't mutually exclusive to event drive
11:32:37 <EvanR> n
11:33:11 <N3RGY> I'm not opposed to having the program doing concurrent stuff in the background - if you recall, this was just about the UI. I don't see any compelling reason to update the user list and the message display in separate threads
11:33:56 <EvanR> i could keep trying to help you see reasons for doing things
11:34:10 <chreekat> epoll loop is an implementation detail, so we've already gone past a denotational design and have begun doing things without it. 
11:34:44 <N3RGY> chreekat: The denotational design would be the state update function. Whether you use an epoll loop or whatever is the implementation detail
11:34:48 <EvanR> denotation is about "what something is" rather than how it does something
11:35:03 <EvanR> i find it more compelling
11:35:10 <N3RGY> Yes, and we have a whole body of techniques for describing what a state update function "is"
11:35:38 <EvanR> for some programs a single state update function for a single state looping, waiting for the single source of events may work great
11:35:58 <tsahyt> N3RGY: what runs in which thread is again an implementation detail though. again, the actual FRP implementations I have seen do not just spawn threads all over the place, they break things down into a single thread. they just allow you to talk about multiple things going on, and how they relate to each other
11:36:28 <tsahyt> again, a difference between the model and the implementation
11:40:32 <N3RGY> So we've drifted pretty far from the original topic, but it sounds like the answer is that there is *not* some library which constructs UIs by relating a data structure to some equivalently-shaped description of a UI. I think for applications which are adequately represented by a pure state update function consuming ordered events, this would be quite useful (and denotational)
11:41:00 <nshepperd> N3RGY: "The discrete-time paradigm is composable. You define injectors" with FRP, those 'injectors'
11:41:07 <nshepperd> ...could be composable
11:41:11 <nshepperd> since they are just Events
11:41:20 <N3RGY> The injectors are composable in the paradigm I'm proposing as well
11:41:28 <N3RGY> Like "Right . Left"
11:41:44 <EvanR> no there isn't really a functional toolkit, but there was a combination of reactive-banana and wxWidgets at some point, i think
11:41:48 <nshepperd> [(Time, a)] is literally the denotation for those 'injectors' you are talking about
11:41:53 <N3RGY> Again, this is nothing new - it's basically how Elm works
11:42:08 <N3RGY> nshepperd: The injectors I'm describing are time-free
11:42:38 <nshepperd> N3RGY: in implementation, maybe
11:42:40 <N3RGY> Time is just an implementation detail :)
11:43:34 <nshepperd> that's perfectly backwards... time is a denotation detail which may not be part of the implementation
11:43:55 <N3RGY> And I think you have it backwards. You can have causality and ordering without tying them to any concrete time values
11:44:15 <nshepperd> 'concrete' is doing all the work there
11:44:47 <nshepperd> frp is certainly not about making the time values 'concrete'
11:45:18 <nshepperd> btw, we haven't got to continuous time at all yet, since you objected to the denotation of (discrete!) events
11:45:23 <chreekat> mmm you can have causality and ordering with monad alone, right? I really do think that a state transformer is a perfectly good denotation for some applications
11:45:25 <N3RGY> And not to get all hoo-hoo and mystical here, but if we take any hints from nature, sometimes causal ordering is the best you can do, and trying to assign a specific cardinal number to match that ordering is a lot of work
11:45:53 <nshepperd> Event is all about ordinal time
11:46:06 <Rian> Hello, I am completely new to Haskell and am having trouble installing it. Through the Haskell platform GHC was successfully installed, but Cabal failed. I was hoping someone in here could help me resolve this as I am eager to get started with Haskell.
11:46:19 <N3RGY> Great. An awesome simplification that only slightly reduces expressive power is to eliminate the Time values and just have a single stream, then
11:47:07 <nshepperd> if you're not willing to read what people are saying, i guess we can't help you
11:47:10 <N3RGY> You can't write (Event a -> Event b -> ...) anymore, so you just turn the problem around a bit and define injectors from various events to a single event type. 
11:47:15 <dmj`> FRP is great when it's not in a web browser.
11:47:34 <N3RGY> nshepperd: I'm reading everything you're saying, although it's possible I'm not understanding it. Trying though
11:47:52 <EvanR> a haskell version of elm ought to be pretty good, considering all the stuff elm is missing
11:47:55 <EvanR> the language
11:48:07 <N3RGY> PureScript sort of fills the gap
11:49:57 <chreekat> dmj`: yo :)
11:50:05 <dmj`> chreekat: BROOO
11:50:09 <dmj`> chreekat: what's good dude
11:50:17 <chreekat> Finland is good, man
11:50:18 <N3RGY> nshepperd: Here is where I'm at now: If I don't think I need a combinator like "Event a -> Event b -> Event (Either a b)", what is the denotational advantage of [(Time, a)] over [a]?
11:50:23 <dmj`> chreekat: finally got your ass out there
11:50:27 <chreekat> haha yep!
11:50:36 <dmj`> chreekat: good for you man, I'm pretty peanut butter and jealous
11:50:45 <EvanR> Monoid a => Event a -> Event a -> Event a pls :)
11:50:49 <chreekat> hahaha 
11:50:57 <dmj`> chreekat: PMs pms
11:51:38 <N3RGY> EvanR: What are the semantics of that one?
11:52:14 <EvanR> you'd have to say it in terms of the semantics for Event (to be denotational at least)
11:52:20 <N3RGY> Please do
11:53:20 <EvanR> occurs (merge x y) = merge (occurs x) (occurs y)
11:53:55 <N3RGY> What's occurs? Is merge the name of the function with the type signature you gave?
11:53:56 <EvanR> the second merge would be on lists
11:54:12 <EvanR> the first merge is the above sig
11:57:02 <nshepperd> N3RGY: when event x fires with value vx and event y fires with value vy simultaneously, (merge x y) fires with value (vx <> vy). otherwise, (merge x y) fires whenever x or y does, passing along the value
11:57:06 <nshepperd> something like that
11:57:35 <EvanR> yes the monoid resolves simultaneous occurs
11:57:52 <EvanR> (the Either function above kind of does not)
11:57:58 <N3RGY> How often does simultaneity occur in FRP? This is one thing where a cardinal model would be legitimately more powerful than an ordinal model
11:58:09 <EvanR> it can easily happen in a video game for instance
11:58:13 <nshepperd> yeah i guess the Either version is slightly wrong
11:58:48 <EvanR> if you defined game over to be caused by the same thing that causes health to decrease
11:58:59 <EvanR> they could happen at the same time
11:59:10 <EvanR> real life games usually "resolve" this by doing everything sequentially
11:59:15 <EvanR> mostly by accident
12:01:02 <EvanR> events can also happen simultaneously without any reference to time, in your pure elm API is the "currently occuring external events" a record of lists of values? well there you go
12:01:11 <N3RGY> So as a bit of an aesthetic argument, it seems like if you're (denotationally) using reals as the cardinal time carrier of your FRP, infinitesimal perturbations in the time of events should lead to infinitesimal perturbations in the behavior of your programs. I.e. a nice thing about discrete models is that it feels more "honest" about the fact that we're almost certainly using step functions, except in like physical 
12:01:11 <N3RGY> simulations
12:01:21 <EvanR> external events fill a queue, the runtime collects them all and provides them to the client code all at once
12:01:55 <nshepperd> N3RGY: imagine being able to write functions like 'isClickedWhenButtonEnabled :: Event ButtonState -> Event MouseClick -> Event ButtonActivated'
12:01:59 <EvanR> though you'd hope that the runtime looks at timestamps (provided by webbrowser and every toolkit in existence) to separate them in time
12:02:07 <jellostahps> How do I get this to work to return 4 if x is in the list? (\i x -> if i== 3 then x=4 else x=i) 1 [1,2,3,4]
12:02:10 <N3RGY> EvanR: I mean, in fact, no real-world events happen on the computer simultaneously, but I agree this is a weakness of a time-free model if simultaneity is important
12:02:16 <EvanR> that isn't true
12:02:21 <jellostahps> foldr (\i x -> if i== 3 then x=4 else x=i) 1 [1,2,3,4]
12:02:36 <nshepperd> N3RGY: which factors out the checking of whether the button is enabled, whether the mouse is in the right location, etc to a function
12:02:53 <N3RGY> nshepperd: You don't need to write that in the discrete model. Your state just keeps track of the state of the button
12:03:14 <nshepperd> you don't *need* to write anything
12:03:16 <N3RGY> I mean like, sure, you could argue your function is nicer, but that's not a difference in expressive power 
12:03:25 <nshepperd> you can write anything at all in C if you like
12:03:26 <N3RGY> (And I also don't think that looks much more convenient)
12:03:28 <EvanR> the motherboard or internal chipset contains a small army of microcontrollers all operting in parallel, to mediate the parallel behavior of the (multi-core) cpu, memory, pci-express bus, and USB
12:03:42 <EvanR> the CPUs are all operating independently in parallel
12:03:59 <EvanR> timer interrupts are trigger by an indepdent circuit running in parallel with the CPUs
12:04:02 <N3RGY> EvanR: And the behavior of the computer is hopefully not exquisitely sensitive to whether an event happens one nanosecond earlier or later
12:04:19 <N3RGY> The only time we don't actively seek to suppress such behavior is for time-based RNGs
12:04:29 <EvanR> just saying, in an abstract sense many things are happening in parallel on a computer
12:04:43 <EvanR> to arbitrarily sort them in a random way is an accident
12:04:45 <nshepperd> i dunno, i don't understand why you'd be writing haskell and saying being able to factor things into functions doesn't matter
12:05:05 <N3RGY> nshepperd: I don't think I've said anything even resembling that
12:05:21 <EvanR> in a game world, things happening simultaneously is natural and importing to many games actual rules
12:06:01 <EvanR> for example in smash bros, when someone presses punch and someone else presses block, 3 things can happen, not 2
12:06:24 <N3RGY> EvanR: Continuous-time games tend to try their best to avoid dependencies on nanosecond-scale time differences 
12:06:32 <N3RGY> Smash bros is based on intervals, not single points in time
12:06:50 <N3RGY> They're not modeling actual simultaneity 
12:07:17 <EvanR> it can be tough to come to terms with the role of time in semantics
12:07:28 <EvanR> precise definitions can help
12:07:35 <EvanR> preconceptions can hurt
12:08:17 <N3RGY> To be precise: I think it seems kind of silly to insist on using Reals to (denotationally) represent time if you're writing discontinuous functions anyway
12:08:36 <EvanR> i think reals are a red herring
12:08:52 <EvanR> but you're right, discontinuous functions would not even be possible in that case
12:09:31 <EvanR> continuity is a more abstract thing than real analysis
12:13:27 <koz_> :t (>>=)
12:13:28 <lambdabot> Monad m => m a -> (a -> m b) -> m b
12:13:35 <koz_> I can never remember which way around those go.
12:18:15 <dmwit> jellostahps: elem 4 ?
12:18:20 <dmwit> > elem 4 [1,2,3,4]
12:18:22 <lambdabot>  True
12:18:26 <dmwit> > elem 4 [1,2,3,5]
12:18:28 <lambdabot>  False
12:18:39 <EvanR> > elem 4 [1..]
12:18:41 <lambdabot>  True
12:19:17 <jellostahps> But is there a way to do elem using foldl or foldr?
12:19:17 <dmwit> Oh, I didn't read that correctly.
12:19:41 <jellostahps> not elem, but whtat i had written originally
12:19:41 <dmwit> :t \x xs -> if elem x xs then 4 else error "spec was incomplete"
12:19:43 <lambdabot> (Foldable t, Eq a, Num p) => a -> t a -> p
12:20:13 <dmwit> I don't know what you had written originally. But there is a way to do elem using foldr, yes.
12:33:29 <jellostahps> dmwit:   foldr (\i x -> if i== 3 then x=4 else x=i) 1 [1,2,3,4] is what I had originally. I am just wondering if the initial value of x can be an integer, and if that value can be changed by the end...when deadling with folds
12:33:44 <jellostahps> cuz u can have Bool, where you originally have False and a fold can change it to a True
12:34:20 <jellostahps> I am wondering if a fold can do the same with a simple integer
12:35:16 <LysergicDreams> > foldr (\i hasFour -> if hasFour || i == 4 then True else False) False [1,2,3,4]
12:35:18 <lambdabot>  True
12:35:26 <LysergicDreams> > foldr (\i hasFour -> if hasFour || i == 4 then True else False) False [1,2,3]
12:35:28 <lambdabot>  False
12:36:15 <jellostahps> I already know it works with Bool's. Does it work if you replaced True with 1, and False with 0?
12:36:50 <EvanR> or True with 'a' and False with 'b'
12:37:28 <EvanR> you're right, Bool returning functions are silly, they should all take 2 extra args to decide what to return
12:37:53 <EvanR> elem :: b -> b -> a -> [a] -> b
12:38:15 <LysergicDreams> > foldr (\i hasFour -> if hasFour == 1 || i == 4 then 1 else 0) 0 [1,2,3,4]
12:38:17 <lambdabot>  1
12:38:59 <LysergicDreams> :t \found notFound search -> foldr (\i hasThing -> if hasThing == found || i == search then found else notFound) notFound
12:39:00 <lambdabot> (Foldable t, Eq a1, Eq a2) => a1 -> a1 -> a2 -> t a2 -> a1
12:39:12 <EvanR> thought with Bool, your original if could be simplified (removed)
12:39:39 <EvanR> foldr (\i hasFour -> i==4 || hasfour) False
12:40:59 <LysergicDreams> ^ good catch, that's a post-REPL cleanup :P
12:43:20 <LysergicDreams> But in real code I'd just use `any (== 4)` :P
12:43:39 <EvanR> or... elem 4
12:44:28 <LysergicDreams> derp
13:02:06 <dmwit> jellostahps: Now that you know foldr works with more than just Bool, it is probably worth introspecting a little bit to see if you can work out what it is you thought foldr was doing that would make it only work with Bool.
13:02:22 <dmwit> (...and try to figure out whether you still believe that thought and its ramifications.)
13:03:00 <jellostahps> hmm idk how to be more specific with my question. I am not asking about Bool, or char or other data types. I am only wondering about a single integer. I know a fold works for more than just a Bool. That is exactly my question.
13:03:25 <jellostahps> Is Int in the scope of what 'works'
13:04:03 <dmwit> What makes integers special in your mind, compared to Bool or Char or other data types?
13:10:42 * hackage scientific-notation 0.1.1.0 - Scientific notation intended for tokenization  https://hackage.haskell.org/package/scientific-notation-0.1.1.0 (andrewthad)
13:19:29 <EvanR> "There was the possibility that -XTypeInType would allow you to shoot the gorillas (my suggestion for an update of "launch the rockets"; the latter seems just a bit too poignant these days) while -XPolyKinds -XDataKinds wouldn't. "
13:19:49 <EvanR> "shoot the gorillas" wth?
13:26:22 <jellostahps> dmwit: Just other languages where you cant change the value once u declare it. I guess int are nothing different then if u say so
13:27:42 * hackage box 0.0.1.5 - boxes  https://hackage.haskell.org/package/box-0.0.1.5 (tonyday567)
13:30:01 <dsal> jellostahps: It may just be the syntax confusing you.   (\i x -> if i== 3 then x=4 else x=i)   doesn't make sense, but you probably mean  (\i _ -> if i== 3 then 4 else i)
13:30:24 <jellostahps> i that foldl or foldr
13:30:47 <dsal> It's hard to say for sure.  x is just a parameter to the function.  It doesn't make sense  to try  to change the value of a parameter most of the time in most languages.
13:31:10 <dsal> That was from your foldl example.  l vs. r doesn't make much of a difference here.
13:32:29 <dsal> > let lm = foldr (\x o -> if x == 4 then True else o) False  in     lm [1..9999] 
13:32:31 <lambdabot>  True
13:32:37 <dsal> I don't think I completely understand what is confusing you, though.
13:33:10 <dsal> (note you can technically give that an infinite list, which isn't the case in foldl)
13:33:58 <jellostahps> If I had this (\i _ -> if i== 3 then 4 else i) , I would stil need an intial value for '_' so what would that initial value (value outside the bracket part of fold syntax)
13:34:34 <dsal> Well, for elem, it's False
13:34:55 <dsal> But I don't know what you want for your initial value in general.  You have to decide that.  That's why it's a parameter.
13:35:07 <dsal> :t fold
13:35:08 <lambdabot> (Foldable t, Monoid m) => t m -> m
13:35:24 <dsal> fold doesn't require an initial value because there's a known initial value already.
13:36:23 <jellostahps> ok
13:37:11 <dsal> What is your goal?
13:38:42 * hackage web-rep 0.1.2 - representations of a web pag  https://hackage.haskell.org/package/web-rep-0.1.2 (tonyday567)
13:49:37 <dmwit> I do not say that ints are nothing different.
13:50:35 <dmwit> It is also correct to say that Haskell does not let you change a value once you declare it. I'm not really sure how that's relevant to your confusion, but it is certainly true of Haskell.
14:20:42 * hackage hasql-transaction 0.10.0.1 - Composable abstraction over retryable transactions for Hasql  https://hackage.haskell.org/package/hasql-transaction-0.10.0.1 (NikitaVolkov)
14:39:42 * hackage git-annex 7.20191106 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-7.20191106 (JoeyHess)
15:03:04 <Squarism> I was looking into Thrift and gRPC (Protobuf3). The "type system" the IDL can describe for both these seems really limited and assumes you want to be able to modify protocol for existing endpoints. Maybe thats the future but isnt there a more expressive schema first protocol description language that doesnt isnt centred around removing / adding fields?
15:03:33 <Squarism> doenst isnt = isnt
15:10:32 <tdammers> SOAP / WSDL
15:10:37 <tdammers> but ugh
15:22:42 * hackage quokka 0.1.2 - Test helpers which help generate data for projects that use postgresql.  https://hackage.haskell.org/package/quokka-0.1.2 (shirren)
15:30:21 <purelazy> Why can't haskell print functions?
15:31:29 <merijn> purelazy: Well, what would that mean?
15:31:51 <purelazy> It would mean print the function.
15:32:06 <purelazy> What else would it mean?
15:32:07 <merijn> purelazy: "id x = x" what would "print id" print?
15:32:09 <boj> what would you expect it to print?
15:32:11 <ammar2> print the source of the function?
15:32:16 <merijn> Like, what does it show in my terminal?
15:32:21 <Axman6> what should print show produce?
15:34:03 <EvanR> i don't want to see source code, i want to see machine code. I mean expanded lambda terms. I mean optimized lambda terms. Or the documentation.
15:34:15 <EvanR> All of the above
15:34:16 <Axman6> sounds like you want julia
15:34:28 <EvanR> actually yeah
15:36:06 <EvanR> i do not want what most languages do instead, "Function", "Function(object,object)" "object -> object" or some such
15:36:22 <Axman6> > id
15:36:22 <EvanR> > print id
15:36:24 <lambdabot>  error:
15:36:24 <lambdabot>      • No instance for (Typeable a0)
15:36:24 <lambdabot>          arising from a use of ‘show_M65538257569973479318478’
15:36:24 <lambdabot>  error:
15:36:24 <lambdabot>      • No instance for (Typeable a0) arising from a use of ‘print’
15:36:26 <lambdabot>      • In the expression: print id
15:36:33 <EvanR> \o/
15:36:51 <EvanR> > print chr
15:36:53 <lambdabot>  <IO ()>
15:37:39 <nshepperd2> printing a function should display an ML-optimized image which hacks your brain and delivers the understanding of what the function does directly into your subconscious mind
15:38:08 <ammar2> that's a round-about way of saying "haskell source" ;)
15:39:01 <EvanR> you can imagine "printing" arrows in a category. It would show you the chain of . of more basic arrows, unless it's a basic arrow
15:39:13 <EvanR> s/chain/tree/
15:39:39 <EvanR> would be interesting if haskell was a category
15:40:34 <purelazy> Haskell is a category
15:40:56 <purelazy> Hask
15:41:04 <purelazy> apparently
15:41:12 <EvanR> if it were, i think my idea could be done
15:45:03 <EvanR> honestly i think it's appropriate that a function can only be observed by applying it to things
15:45:35 <EvanR> cracking into a string rep of the source code sounds ripe for abuse
15:46:26 * EvanR tells tales of the mythic and horrendous Javascript
15:47:42 <EvanR> Idris allows you to see lambda terms on the repl, but this is built in and is not a string you can do anything with
15:49:46 <nshepperd2> stringly typed haskell
15:49:59 <nshepperd2> instance IsString (a -> b)
15:50:33 <merijn> @hackage acme-php
15:50:33 <lambdabot> http://hackage.haskell.org/package/acme-php
15:54:06 <nshepperd2> aw the docs for that package seem broken
15:54:51 <nshepperd2> wow, there's a lot of acme libraries now
15:55:45 <shapr> glguy: is your list of AoC quickstart imports available?
15:55:56 <shapr> or should I build my own? I guess a jedi fashions their own lightsaber?
15:55:58 <shapr> hmm
15:55:59 <hpc> nshepperd2: all the jokes are in the source
15:56:08 <hpc> docs actually have some things i would consider spoilers
15:57:59 <nshepperd2> oh wow it is almost advent of code time again
15:58:06 <nshepperd2> how time flies...
15:59:49 <purelazy> Could haskell print functions?
16:00:36 <EvanR> % print chr
16:00:36 <yahb> EvanR: ; <interactive>:143:1: error:; * No instance for (Show (Int -> Char)) arising from a use of `print'; (maybe you haven't applied a function to enough arguments?); * In the expression: print chr; In an equation for `it': it = print chr
16:00:41 <EvanR> > show chr
16:00:43 <lambdabot>  "<Int -> Char>"
16:01:28 <EvanR> (the first result, suggesting i haven't applied enough functions, has helped me way more in reality than the alternative... somehow printing a function)
16:01:34 <EvanR> (enough args)
16:02:49 <[itchyjunk]> What does ghci stand for?
16:03:22 <merijn> [itchyjunk]: GHC interactive
16:03:41 <[itchyjunk]> :s
16:03:46 <[itchyjunk]> what does GHC stand for?
16:03:52 <merijn> [itchyjunk]: Glasgow Haskell Compiler
16:04:05 <[itchyjunk]> ah
16:05:19 <EvanR> Glorious
16:05:43 <EvanR> </worf>
16:07:26 <[itchyjunk]> I am trying to remember that set builder notation from yesterday but i can't seem to remember :'(
16:07:48 <EvanR> list builder notation, list comprehension
16:08:02 <Axman6> > [(a,b,c) | a <- [1..10], b <- [a+1..10], c <- [b+1..10], a^2 + b^2 == c^2]
16:08:04 <lambdabot>  [(3,4,5),(6,8,10)]
16:08:40 <Axman6> > let f n = [(a,b,c) | a <- [1..n], b <- [a..n], c <- [b..n], a^2 + b^2 == c^2] in f 100
16:08:42 <lambdabot>  [(3,4,5),(5,12,13),(6,8,10),(7,24,25),(8,15,17),(9,12,15),(9,40,41),(10,24,2...
16:09:13 <dmwit> purelazy: Sure, see http://hackage.haskell.org/package/universe-reverse-instances-1.1/docs/Data-Universe-Instances-Show.html (but you aren't going to like it).
16:09:17 <[itchyjunk]> oh <- .. damnit i was trying stuff like "in" haha
16:09:20 <[itchyjunk]> thanks Axman6 
16:09:32 <jackdk> I would not bother with comprehensions. introductory material has an inexplicable love affair with them, but I don't get a lot of use from them
16:09:32 <[itchyjunk]> oh there is "let" also?
16:09:52 <jackdk> there are occasional uses for them once you're on your way
16:10:09 <[itchyjunk]> but aren't most things just sets with structure?
16:10:13 <jackdk> and yeah, there's `let...in` expressions
16:10:23 <EvanR> what... no! :'(
16:10:27 <dmwit> Most things are not just sets with structure.
16:10:34 <[itchyjunk]> say i want to find primitive roots in some Z/pZ
16:10:45 <EvanR> data Ord = O 
16:11:00 <EvanR> data Ord = O | S Ord | Lim (N -> Ord)
16:11:14 <EvanR> got your non-set right here
16:11:34 <purelazy> It's weird that so-called first-class citizens (functions) are nothing like 1st-class xitizens
16:11:41 <purelazy> It's weird that so-called first-class citizens (functions) are nothing like 1st-class citizens
16:11:48 <[itchyjunk]> EvanR, i don't understand that though :x
16:11:55 <purelazy> Unprintable
16:12:09 <EvanR> you can create a Show instance for whatever type you want
16:12:14 <merijn> purelazy: Well, you still haven't answered what they should print
16:12:14 <[itchyjunk]> jackdk, so what should i bother with?
16:12:27 <[itchyjunk]> i just wanna learn some programming like the cool kids :(
16:12:51 <EvanR> [itchyjunk]: ordinals
16:12:56 <purelazy> merijn: The function
16:13:01 <ammar2> lol
16:13:05 <ammar2> what does that mean
16:13:12 <merijn> purelazy: What does that mean? The source code? The binary memory representation? The assmebly?
16:13:14 <ammar2> what about the function should it print
16:13:22 <ammar2> :info id
16:13:28 <ammar2> will get you pretty far
16:13:29 <[itchyjunk]> ah generalization of natural numbers?
16:13:31 <nshepperd2> if a function should speak, we shall not understand it
16:13:36 <EvanR> perhaps purelazy wants a tabulation of all the input/output pairs
16:13:44 <[itchyjunk]> so sequences are functions that maps ordinals to some set then?
16:13:54 <jackdk> [itchyjunk]: work through some introductory material, and gloss lightly over list comprehensions.
16:14:05 <jackdk> what are you currently using as your reference?
16:14:10 <[itchyjunk]> i was looking at uuhh
16:14:10 <Axman6> if you want the source code, that that makes sense for anything which was defined in a file, but we can create new functions at runtime - we we have to keep track of all the syntax which was used to create that function too?
16:14:18 <[itchyjunk]> learn you some haskell or something
16:14:24 <[itchyjunk]> let me google what i was using
16:14:41 <[itchyjunk]> "Learn you a haskell for great good"
16:14:55 <EvanR> for functions with a domain with certain support, you could try showing the tabulation or graph of the function
16:15:24 <EvanR> though it may be huge
16:15:46 <Axman6> At this point I assume purelazy is just a troll, it's not worth going any further with this question
16:16:09 <EvanR> i enjoyed wondering
16:16:10 <ammar2> yeah...they keep just repeating the same thing without answering the key question
16:16:40 <EvanR> conal's video on tangible values shows functions, interactively :)
16:16:42 <monochrom> too lazy to answer :)
16:17:32 <Axman6> compiling to categories talks about it too - to show a function you just print its graph
16:17:38 <Axman6> "just"
16:17:41 <nshepperd2> dhall can print lambda terms because of being strongly normalizing
16:18:14 <conal> EvanR: thanks for the plug (http://conal.net/papers/Eros/). indeed it does!
16:18:30 <conal> (paper and talks via that link)
16:18:31 <EvanR> ah eros
16:19:00 <[itchyjunk]> wait a second
16:19:14 <monochrom> nshepperd2: If a function should speak, it would say "I don't want to be anthropomorphized" >:)
16:19:23 <[itchyjunk]> that book says the author lurks in freenode
16:19:29 <[itchyjunk]> Anyone heard of him?
16:19:51 <conal> Axman6: yep! it also shows functions as GPU-accelerated shaders (http://conal.net/papers/compiling-to-categories/) .
16:20:04 <dmwit> purelazy: Why do you say "unprintable" when I linked you to the documentation for a way to print them?
16:20:08 * dmwit boggles
16:20:08 <monochrom> Yes he lurked. But disappeared a long time ago.
16:20:31 <[itchyjunk]> Ahh
16:20:46 <[itchyjunk]> Is his book still relevent?
16:20:51 <EvanR> too many people bashed LYAH
16:21:03 <[itchyjunk]> or should i be looking at some other tutorial?
16:21:07 <monochrom> No I think the bashing began after he disappeared >:)
16:22:26 <monochrom> I think it comes down to this.  Some people can create their own exercises and experiments and probing around. (I'm one.)  Some other people need to be provided exercises.  LYAH suits the former.
16:22:41 <monochrom> The latter though is the majority.
16:23:00 <monochrom> Like, you know what, A Gentle Introduction worked superb for me too.
16:23:24 <EvanR> some people can draw their own funny pictures, some people need to be provided. LYAH suits the later
16:23:31 <monochrom> haha
16:24:06 <purelazy> If there is an answer to the question "Why can't haskell print functions?", I would like to know.
16:24:07 <Axman6> conal: I don't remember that being in your LambdaJam talk when I was there, the function -> function + AD derivative -> (graph representation, HDL) was super interesting though, one of the best talks I've been to at LJ
16:24:17 <monochrom> People bashed Gentle Introduction before bashing LYAH was cool.
16:24:34 <Axman6> It was great to have my mind completely blown by someone who wasn't edwardk :P
16:24:50 <conal> Axman6: the gpu graphics example went by quickly.
16:25:26 <purelazy> Anyone calling me a troll should not be a teacher.
16:25:37 <conal> Axman6: i assume you mean the LJ 2017 talk: https://github.com/conal/2017-talk-teaching-new-tricks-to-old-programs#readme
16:25:49 <Axman6> purelazy: any student who won't answer questions isn't a student
16:25:53 <monochrom> Now, we need someone to bash Hutton's computerphile videos on monad and lambda calculus >:)
16:25:56 <Axman6> yep
16:26:34 <dmwit> purelazy: ...Yes there is an answer. And I've given it to you.
16:26:37 <monochrom> I don't think dmwit claims to be a teacher anyway.
16:27:05 <monochrom> But let me up the game.
16:27:08 <conal> Axman6: the graphics example is a few seconds after this spot: https://youtu.be/vzLK_xE9Zy8?t=2184
16:27:16 <monochrom> Anyone calling me a troll should not be a human.  There!
16:28:48 <dmwit> I guess I don't claim to be a teacher. But also I didn't call them a troll (yet). ^_^
16:28:57 <conal> Axman6: it was crazy easy to implement the GPU compiler in compiling-to-categories compared to the earlier deep embeddings.
16:28:57 <MarcelineVQ> What if the real troll was the friends we made along the way
16:29:20 <nshepperd2> trolling is more a way of life than an identity
16:29:34 <monochrom> Oh wait that's Axman6 heh
16:38:36 <[itchyjunk]> hmmm
16:39:04 <[itchyjunk]> question: why does a <- [1..10] work but not [1..10] -> a  ?
16:39:59 <dsal> Because this isn't R?  :)
16:40:22 <[itchyjunk]> R the programming language or the R the set of real number? :x
16:40:34 <koz_> [itchyjunk]: The programming language.
16:40:40 <[itchyjunk]> ah
16:40:46 <koz_> (I guess also the other one, but it's more obvious)
16:41:08 <[itchyjunk]> well, what exactly is '<-' then?
16:41:12 <dsal> Sometimes there are operators in both directions.  There's =<< and >>= but not for everything.
16:41:16 <[itchyjunk]> i figured if thats a map, either way would work
16:41:21 <dsal> <- is a fancy thing used in do syntax.
16:41:28 <koz_> It is _very much_ not a map.
16:41:29 <dsal> Some argue do syntax  is confusing for beginners.
16:42:17 <MarcelineVQ> 40 hellens agree
16:42:20 <[itchyjunk]> oh i thought a <- [1..10] means each element of the list was getting mapped to a :s
16:42:32 <[itchyjunk]> so it some do thingy that idk about
16:42:58 <dsal> Diving into a list monad on day one in do syntax might be a little confusing.
16:43:21 <[itchyjunk]> :s
16:44:58 <EvanR> [itchyjunk]: list comprehension is going through each combination from items from each urn, in a predictable order, filtering them out, and forming some expression with each "hand"
16:45:07 <EvanR> combination of items
16:45:51 <dsal> > [ (a,b,a+b) | a <- [1..3], b <- 2..5], odd (a+b)]
16:45:53 <lambdabot>  <hint>:1:34: error: parse error on input ‘..’
16:45:56 <dsal> damn me.
16:46:03 <dsal> > [ (a,b,a+b) | a <- [1..3], b <- [2..5], odd (a+b)]
16:46:05 <lambdabot>  [(1,2,3),(1,4,5),(2,3,5),(2,5,7),(3,2,5),(3,4,7)]
16:46:17 <EvanR> > [f x y | x <- [0..1], y <- [0..1] ]
16:46:19 <lambdabot>  error:
16:46:19 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M650537300507...
16:46:19 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
16:47:04 <EvanR> > [f x y | x <- [0..1], y <- [0..1] ] :: [Expr]
16:47:06 <lambdabot>  [f 0 0,f 0 1,f 1 0,f 1 1]
16:47:24 <wildtrees> > [(x,y) | x <- [0..1] , y <- [0..1] ]
16:47:25 <lambdabot>  [(0,0),(0,1),(1,0),(1,1)]
16:47:39 <Axman6> [itchyjunk]: read a <- xs as "a drawn from xs"
16:47:51 <[itchyjunk]> ah i see
16:48:01 <Axman6> or for each (but backwards)
16:48:11 <EvanR> which is pretty much what set builder notation does
16:48:18 <EvanR> which i only really got after doing haskell
16:58:39 <TheCommieDuck> so I can just about grok monads, but I can't quite grok IO. I want to write a lambda \w -> putStrLn "blah something here" >> (w, True) or something similar, a -> (a, Bool). the thing I've currently got results in an IO monad floating about. can I not somehow cancel down the IO context? or is this a monad transformer thing?
16:59:31 <Axman6> no, never
17:00:26 <jackdk> do not think about making the IO "go away". instead think about lifting your other functions to working over IO values, using the tools available: fmap (aka (<$>)); pure (nee return); (<*>); and (>>=)
17:00:27 <EvanR> quick Axman6 deploy the bat IO tutorial
17:00:57 <MarcelineVQ> http://www.vex.net/~trebla/haskell/IO.xhtml
17:01:22 <TheCommieDuck> yep, you're right about not making the IO go away; so basically I just end up threading an IO () through the code?
17:01:22 <EvanR> BAM
17:01:46 <Axman6> you end up threading your code through IO
17:02:12 <EvanR> you should really think about it another way. Are you writing an IO action? Or is it some other form of computation that doesn't need IO
17:02:26 <EvanR> not everything should be an IO action
17:03:03 <TheCommieDuck> yeah, that's why I got confused. this specific thing is an IO action - it prints some text to stdout. however not everything will always be IO actions
17:03:11 <EvanR> right
17:03:25 <TheCommieDuck> it's a list of rules that get executed at various times, some will just compute purely and some will...not
17:03:58 <EvanR> the pure ones tend to be more flexible
17:04:33 <EvanR> useful in more places
17:05:11 <TheCommieDuck> reading the tutorial now. 
17:05:39 <TheCommieDuck> I think monads will click eventually. functors have, applicative sort of has.
17:06:18 <EvanR> IO itself is kind of orthogonal to "monads"
17:06:43 <monochrom> I wouldn't say that.
17:07:23 <monochrom> I would say one of these two: I/O is orthogonal to monads; IO is a special case of monads.
17:07:38 <monochrom> For the latter, as usual, you learn the special case first.
17:07:59 <TheCommieDuck> a monad is a context you work in and can sequence functions within that context.
17:08:03 <monochrom> No one goes into ##math asking "I need to grok ring theory so that I can add and multiply integers".
17:08:14 <TheCommieDuck> probably shouldn't have typed thatbecause now I will be ganged up on lol
17:08:19 <EvanR> IO is also Functor and Applicative
17:08:22 <EvanR> and other things
17:08:30 <MarcelineVQ> TheCommieDuck: That just means a lot of people want to help
17:08:48 <monochrom> It's always the other way round.  You grok integers, and a bunch of other things, and after them you're ready to try ring theory.
17:08:50 <TheCommieDuck> haha :)
17:08:59 <TheCommieDuck> so I was thinking of writing a monad tutorial
17:09:04 <EvanR> IO () is a Monoid
17:10:43 <jusss> :i State
17:11:10 <jusss> newtype State s a = State { runState :: s -> (a,s) }
17:11:28 <jusss> >>= :: State s a -> (a -> State s b) -> State s b
17:11:29 <Axman6> you can think of IO as building up a lot of callbacks using (>>=). getLine >>= \theLine -> putStrLn theLine >>= \_ignoredUnit -> print (map toUpper theLine)
17:12:03 <jusss> can we get the definition of >>= about State based on those two types?
17:12:44 <Axman6> runGet line and pass its result to th elambda which prints the line and when that's dont it passes its returt (which we ignore) to the function which prints the result of applying map toUpper to that same line, etc.
17:13:35 <Axman6> and that forms an IO action itself, so you can compose it eith other IO actions ad infinium
17:14:42 <[itchyjunk]> dang it, the book is telling me 5 /= 5 is false and 5 /= 4 is true but not what /= does!
17:14:56 <monochrom> the negation of ==
17:14:57 <[itchyjunk]> hey does this bot answer questions about syntax btw?
17:15:06 <[itchyjunk]> ah thanks
17:15:06 <EvanR> = <backspace> /
17:15:12 <EvanR> trigraph
17:15:15 <Axman6> @src Eq
17:15:15 <lambdabot> class Eq a where
17:15:15 <lambdabot>     (==), (/=) :: a -> a -> Bool
17:16:07 <Axman6> the default definitions for those functiosn are: (==) a b = not ((/=) a b); (/=) a b = not ((==) a b)
17:17:46 <[itchyjunk]> ouch
17:18:07 <[itchyjunk]> de morgan!
17:18:36 <monochrom> I love de Morgan.
17:18:39 <EvanR> de morgan can't hear you. There's no AND or OR here
17:18:51 <monochrom> This is why I don't love intuitionistic logic.
17:20:23 <EvanR> linear logic restores the symmetry
17:26:26 <glguy> shapr: my aoc quick start is usually the union of the imports from my previous solutions along with some code to open the input file in the location I plan to save it
17:33:41 <shapr> glguy: very sensible
17:35:43 <mmaruseacph2> I used to do the same, but didn't do aoc last year
17:51:05 <dmwit> jusss: No, you can't.
17:51:32 <jusss> dmwit: ok
17:51:33 <dmwit> There are multiple extensionally distinct implementations of the type given.
17:52:13 <jusss> dmwit: what we think about the context about monad, it's a value form or type form?
17:52:42 <jusss> like can we think the context is Just or Nothing in Maybe monad
17:52:46 <dmwit> I refuse to answer the question on the grounds that I believe it is not useful.
17:53:02 <jusss> ...
17:57:06 <jusss> dmwit: another question, is there a better repl than ghci?
17:58:43 <dmwit> I don't know of one.
17:59:01 <dmwit> IHaskell exists, but it is difficult to install and it is not at all clear to me that it is "better".
17:59:04 <dmwit> YMMV
19:16:42 * hackage apecs 0.8.2 - Fast Entity-Component-System library for game programming  https://hackage.haskell.org/package/apecs-0.8.2 (jonascarpay)
19:20:22 <monochrom> The "context" narrative for monad is just as meaningless as the "container" and "computation" narratives.
19:20:58 <jusss> monochrom: it can help people to think what are passing in the >>=
19:21:10 <monochrom> No.
19:21:19 <jusss> Just 3 >>= f, Just is passing
19:21:33 <monochrom> All three buzzwords help people to fool themselves.
19:21:49 <pikajude> yeah, unfortunately there is no narrative about monad that means anything
19:21:58 <jusss> monochrom: then how you can build the intutive?
19:22:03 <pikajude> you don't
19:22:07 <monochrom> Practice?
19:22:15 <jusss> intuitive
19:22:22 <pikajude> intuition is the word
19:22:25 <monochrom> How do people build intuition about Chess?
19:22:46 <pikajude> what
19:22:47 <f-a> by using simplified "rules" at first
19:22:54 <monochrom> Do they indulge in stories like "the horse jumps around"?
19:22:59 <f-a> ("don't bring your Queen out too early" etc)
19:23:10 <monochrom> Or do they just accept the rules and play?
19:23:21 <pikajude> not the best metaphor
19:23:54 <EvanR> i still understand monads
19:24:00 <EvanR> er, do not understand
19:24:02 <monochrom> Like what is the intuition behind a "castle" that moves around, even at unlimited speed.
19:24:06 <Axman6> monads are just continuations that don't suck
19:24:29 <pikajude> well the speed is limited by how fast you can move your arm
19:24:40 <monochrom> And a king that has minimum mobility but his consort moves faster than bishops.
19:25:29 <jusss> but queen and king we can see, we can touch, 
19:25:43 <jusss> we know how they worked directly
19:26:01 <jusss> but what monad looks like? is it red or green?
19:26:23 <jusss> what colors it has, what smell it has, what it's made of?
19:29:26 <EvanR> like, i'm waiting for wizard of oz to come out from behind the curtain and reveal how they solve every problem in universal algebra or something
19:29:26 <pikajude> now that you mention it, i'm starting to think chess has a lot of plot holes
19:29:27 <pikajude> i wonder if they should patch it
19:29:27 <maerwald> IMO, this "just look at many monad instances" is also a fallacy, because all you'll realise is that the semantics can be so vastly different that you sometimes wish you wouldn't have that abstraction in the first place
19:29:27 <monochrom> A pawn that can't go back, except if it hits the other side it becomes anything you like.
19:29:27 <pikajude> so what does bind do? well, it takes m a and a -> m b and returns m b
19:29:27 <pikajude> boom! monads explained
19:29:28 <EvanR> don't bring your monads out too early
19:29:28 <f-a> excellent advice
19:29:28 <maerwald> EvanR++
19:29:28 <pikajude> "so what's a scenario in which i could use a monad?" "i can't tell you that, because you might form an imperfect intuition of what a monad 'is' based on how it's used."
19:29:28 <EvanR> worse things have happened
19:29:28 <maerwald> See, we don't even understand monads properly and now people want dependent types =)
19:29:29 <pikajude> so what does GHC do? well, i can't tell you that...
19:29:29 <dsal> I want dependent types so I can understand monads better.
19:29:36 <pikajude> why were those messages all sent at once?
19:29:59 <maerwald> jusss: wait, you smell your chess pieces?
19:30:02 <pikajude> anyway, monads are blue, smell like popcorn, and are made of nylon
19:30:06 <pikajude> that's on the wiki
19:30:18 <pikajude> but that's not relevant to what you can use them for
19:30:21 <monochrom> Chess has rules and monads have laws.
19:30:42 <monochrom> You accept the chess rules and you follow the monad laws.  That's it.
19:30:51 <maerwald> What if you break them :)
19:30:58 <maerwald> Because in haskell, you can
19:31:07 <monochrom> To make it more concrete, you play chess games and you study monad examples.
19:31:24 <EvanR> a particular chess match, a monad instance
19:31:26 <dsal> What color is a neutron?
19:31:27 <EvanR> your move
19:31:29 <jusss> maerwald: it's just a metaphor, I even never see a chess
19:31:36 <glguy> dsal: white
19:31:44 <pikajude> wait, isn't the danger of monad examples the whole point of this discussion
19:32:08 <maerwald> so we moved from burritos to chess
19:32:17 <pikajude> i hope we go back to burritos soon
19:32:21 <glguy> Also, what color is the number 5?
19:32:26 <pikajude> gray
19:32:31 <pikajude> well, unless i type it
19:32:34 <monochrom> There can be high-level advice such as "control the centre" and "like an embedded language" but you have to have practised for a while before those make sense.
19:32:34 <EvanR> bronze
19:32:37 <dsal> It's very dark, though.  Almost black.  Slightly blue.
19:33:14 <EvanR> if you find or write a monad instance obeying the laws, you win
19:33:16 <jusss> who discovered the term "monad" ?
19:33:27 <EvanR> leibneiz
19:33:28 <jusss> he may know it
19:33:39 <jusss> EvanR: Really?
19:33:42 <EvanR> leibniz*
19:33:54 <EvanR> probably on opium
19:34:22 <lyxia> I heard the way it got used in category theory was totally an accident unrelated to leibniz
19:35:00 <EvanR> i would hope so because... what a bad connection :)
19:35:51 <jusss> I use that `context' to help me think about `monad', now you tell me that's wrong... 
19:36:07 <jusss> I don't know about `monad' at all
19:36:08 <monochrom> I use monad laws to think about monad.
19:36:19 <lyxia> https://english.stackexchange.com/questions/30654/where-does-the-term-monad-come-from/30661#30661
19:36:27 <jackdk> the most satisfying story I've seen (in terms of apparent effect on students) is the claim "Monad is a software engineering pattern to control the repetition of code."
19:36:29 <pikajude> if you start thinking about monads, you're already too far gone
19:36:33 <jusss> monochrom: but that three laws we don't use them a lot
19:36:37 <jusss> in coding
19:36:53 <monochrom> I do.
19:37:04 <monochrom> If you don't that's your problem.
19:37:14 <monochrom> Hell, that explains your problem.
19:37:24 <jackdk> and as with the typeclasses you show people before instance (Functor, Applicative), you show which types have valid instances, and then what things the abstraction allows you to say without thinking of any particular instance.
19:37:40 <jusss> monochrom: you use associativity law and identity law a lot ?
19:37:48 <monochrom> I even re-expressed the monad laws in do-notation to show why you need them and hell you have always presumed them.
19:37:55 <monochrom> All the time.
19:38:32 <jusss> sorry, I forget
19:38:39 <monochrom> Read it: https://wiki.haskell.org/Monad_laws
19:39:23 <monochrom> If you have ever refactored a do-block into two you have used the associative law.
19:39:42 <monochrom> If you have ever added or remove a spurrious "return" you have used the identity law.
19:40:14 <f-a> *spurious
19:40:16 <EvanR> well that just makes monads seem trivial!
19:40:28 <monochrom> Because there is no reason I can't make a monad instance that completely breaks the most trivial refactoring, if not for the monad laws
19:41:13 <pikajude> you could write your own Maybe where bind and return always produce Nothing
19:41:18 <pikajude> and it would typecheck
19:41:19 <jusss> wait a sec, but Monoid has associtivity law and identity law!
19:41:26 <pikajude> but it is unlikely to be useful
19:41:33 <EvanR> so does Functor
19:41:41 <EvanR> and Category
19:41:44 <pikajude> wait a minute, so does Integral
19:41:57 <pikajude> or, should I say, addition
19:42:01 <EvanR> and Applicative in the other formulation
19:42:21 <jusss> monochrom: now what the special about monad ?
19:42:30 <monochrom> eh? Applicative has the same laws in all formulations. Just that some of them get ugly.
19:42:37 <pikajude> you can't write `>>=` for a monoid
19:42:43 <monochrom> You tell me.  Never thought it was special.
19:42:53 * lyxia jokes about endofunctors.
19:43:13 <monochrom> Nothing is special.  No one is special.
19:43:15 <jusss> monochrom: this three law , they have too, and they act like monad?
19:43:25 <pikajude> who?
19:43:26 <monochrom> No understand.
19:43:31 <EvanR> 0th law, 1st law, 2nd law?
19:43:32 <pikajude> who acts like monad
19:43:49 <jusss> I mean on one
19:44:02 <jusss> did you don't see `?' in the last...
19:44:02 <pikajude> hmm nope, still don't get the question
19:44:11 <pikajude> no
19:44:24 <monochrom> \∩/ "monad is like thermodynamics, there are 3 laws"...
19:44:42 <EvanR> supposedly monads come up way more in math than in programming, and i know zero examples
19:45:13 <ammar2> math monads?
19:45:28 <EvanR> mothnads
19:46:05 <maerwald> I've never seen someone go "ah, these are the monad laws... now I'm starting to build intuition"
19:46:10 <monochrom> I kind of know (heard of) some math examples.  If you recall "let F be a functor, then you have an F-algebra...", in math sometimes they insist F to be a monad before they talk about F-algebras.
19:46:27 <maerwald> In fact, they're probably more confusing to most people who are not deeply into CT
19:46:42 <EvanR> k i heard of F-algebra
19:46:47 <maerwald> so rather useless as a fixpoint of teaching
19:46:49 <pikajude> sure, but on the plus side, you get to be on the theoretical high ground in internet discussions
19:47:03 <f-a> haha true
19:47:05 <monochrom> maerwald but you're against teaching anyway.
19:47:10 <EvanR> the theoretical fool on the hill
19:47:16 <maerwald> s/teaching/learning/ :)
19:48:09 <monochrom> Well like I've always said, you don't go "how do I grok ring theory? I need to add and multiply integers"
19:48:40 <monochrom> You add and multiply integers first, then maybe polynomials, then maybe a couple of harder things.  And then you're ready to try ring theory.
19:48:45 <EvanR> apparently there's a 3rd law of thermo but nobody ever gets that far
19:49:28 <monochrom> But if you do try ring theory, you go by the ring laws, you don't fool yourself with feel-good stories like "a ring is like a merry-go-around".
19:49:30 <maerwald> https://stackoverflow.com/a/17412969/2976251 this is the only explanation that ever improved my understanding of such concepts and it doesn't make use of weird analogies. It separates things into "result flow" and "effect flow" though.
19:49:31 <maerwald> Basically things that are not really on the theory side of things, but from the perspection of someone who's actually programming
19:49:56 <maerwald> Programming is an odd mixture of tech, arts and madness
19:50:31 <jusss> and math is ？
19:51:15 <maerwald> jusss: ask someone who doesn't know about maths :)
19:51:19 <jackdk> "A monad must not harm a human, or through inaction, allow a human to come to harm"
19:51:21 <monochrom> Did you know that Wadler et al. are developing a "selective" type class to cover these ifM and whileM without going all out for monad? >:)
19:52:33 <jusss> about abstract, what it is used for?
19:52:48 <EvanR> that wadler... at it again
19:52:51 <jusss> not to build a intuition?
20:03:15 <monochrom> I tell the effect-and-result narrative in my course.
20:04:46 <MarcelineVQ> monochrom: related to https://www.staff.ncl.ac.uk/andrey.mokhov/selective-functors.pdf ?
20:05:41 <monochrom> Yeah, actually that one. I think I misremembered about Wadler.
20:05:54 <monochrom> No wonder I can't find it among Wadler's papers!
20:06:21 <monochrom> http://hackage.haskell.org/package/selective  \∩/
20:07:04 <monochrom> Control.Selective.Rigid.Free haha rigid and free.
20:07:14 <monochrom> "I'm a conservative liberal"
20:11:41 <jollygood2> hello. when loading json with aeson package is it possible to automatically convert missing Maybe fields to Nothing?
20:14:07 <Axman6> I think you can do that with optional:
20:14:11 <Axman6> :t optional
20:14:12 <lambdabot> Alternative f => f a -> f (Maybe a)
20:14:26 <Axman6> optional (o .: "foo")
20:15:49 <monochrom> "optional" is in Control.Applicative
20:15:52 <jollygood2> not sure where I'm supposed to do that? I'm just calling eitherDecode :: ByteString -> Either String a
20:16:17 <monochrom> In your FromJSON instance.
20:16:22 <Axman6> oh, that has to be in your FromJSON instance
20:16:41 <jollygood2> oh
20:18:38 <jollygood2> ok, so I have to manually define FromJSON instance to do this? right now I am autogenerating them
20:19:12 <Axman6> the default instance for FromJSON (Maybe a) assumes that the field will exist and be 'null' if the value isn't present
20:19:29 <Axman6> you can change the settings used in the auto generation if you're doing it via generic
20:20:53 <Axman6> instance FromJSON Foo where parseJSON = genericPArseJSON defaultOptions{ omitNothingFields = True}
20:21:03 <jollygood2> do you know off hand how to change it?
20:21:43 <maerwald> monochrom: wait, so for 'selective' the second effect *may* be skipped (or not), depending on the instance definition? So basically I get less reasoning and have to read all instance definitions, because I cannot trust whether it runs the effect?
20:24:26 <monochrom> Oh, heh
20:24:42 <monochrom> Spectre at the Haskell level
20:25:10 <maerwald> with applicative I can say: effect flow always static, with monad I can say, well always depends on the result value of the first effect, with selective I can say... err, well, maybe, maybe not
20:25:52 <monochrom> Maybe somewhere in the middle of the paper they explain why they allow this.
20:27:12 <MarcelineVQ> So that you can staticly analyse or efficiently not run things you don't need to with the same code, by selecting the instance you want. section 2.2 and beyond cover this idea
20:28:14 <MarcelineVQ> 2.2 in the paper I mean
20:29:08 <MarcelineVQ> which I imagine is nicer than making an interpreter to do both as the other option, but idk
20:37:12 * hackage diagrams-lib 1.4.3 - Embedded domain-specific language for declarative graphics  https://hackage.haskell.org/package/diagrams-lib-1.4.3 (BrentYorgey)
20:39:31 <flebron> Hi folks. Golfing game :) I have a list x of 5 chars, each char is 'x' or ' '. I have a list y of 5 ints. What's the shortest way to select the entries of y, such that the corresponding entry of x is 'x'? I thought this would work using ParallelListComp, but it just gives me the first k things in y, where k is the number of 'x' in x. [b|b<-y|d<-x,d=='x']
20:41:04 <Axman6> example inputs and outputs please :)
20:42:27 <flebron> For x = "x  x ", and y = "73562", the expected result is "76".
20:42:33 <MarcelineVQ> the idea being  \xs ys -> map snd . filter ((=='x') . fst) $ zip xs ys)  but you're wanting to golf so this needs to be shorter and more awful
20:42:42 <flebron> Yup :)
20:43:05 <flebron> I thought ParallelListComp would work, but I must be misunderstanding how it works.
20:44:22 <flebron> I guess it's evaluating the "|" with higher precedence than ",", so it "first" does d<-x,d=='x', and only then zips that with b<-y.
20:45:18 <flebron> Ah it seems it's a known thing. https://prime.haskell.org/wiki/ParallelListComp says "Cannot express filters of zips. If you want to filter the list returned by a parallel list comprehension, you have to go back to using the zip form, or separately filter the result.
20:46:08 <Axman6> > let f xs ys =  [y|x <- xs|y <- ys | x=='x'] in f "x  x " "73562"
20:46:10 <lambdabot>  error:
20:46:10 <lambdabot>      • Couldn't match expected type ‘Expr’ with actual type ‘Char’
20:46:10 <lambdabot>      • In the second argument of ‘(==)’, namely ‘'x'’
20:47:55 <jollygood2> > let xs = "x  x "; ys = "73562" in [y | x <- xs, x == 'x' | y <- ys]
20:47:57 <lambdabot>  "73"
20:48:45 <Axman6> nearly
20:48:58 <jollygood2> I did the same mistake in ghci 
20:49:38 <jollygood2> works: [y|x<-xs,x=='x'|y<-ys]
20:50:16 <Axman6> except it's the wrong answer
20:50:40 <jollygood2> hmm?
20:50:58 <jollygood2> I see it, but I'm not sure I understand it
20:51:30 <flebron> [b|(a,b)<-zip x y,a=='x']
20:51:43 <jollygood2> x == 'x' part filters only the x?
20:52:02 <flebron> Yes, but that happens before the |, so that's equivalent to x<-['x','x'] :)
20:52:17 <jollygood2> can it be done with just list comprehensions?
20:52:47 <flebron> Well the one I wrote above does it, it's just longer than I'd like (have to explicitly say zip)
20:52:59 <jollygood2> that's what I meant, without the zip
20:55:14 <jle`> flebron: list comprehension bindings are normal patterns
20:55:26 <jle`> so you should be able to do [b|b<-y|'x'<-x]
20:56:07 <jle`> > let f x y = [b|b<-y|'x'<-x] in f "x  x " "73562"
20:56:09 <lambdabot>  "73"
20:57:02 <jle`> the zip way might be nice too
20:57:10 <jollygood2> that's the same as my initial version.. it filters just the x, b goes in order
20:57:18 <jollygood2> not sure I like that behavior
20:57:42 <jle`> > let f x y = [b|('x',b)<-x`zip`y] in f "x  x " "73562"
20:57:44 <lambdabot>  "76"
20:58:00 <flebron> Ah nice :D
20:58:32 <jle`> ah that one works actually
20:59:52 <jollygood2> prefix zip takes the same space
21:00:04 <jle`> but is it as cool
21:00:09 <jollygood2> no :)
21:00:25 <jle`> hm, i wonder if there's a way to get it down
21:01:28 <jle`> that's all i got
21:02:43 <flebron> That was very nice, thank you :)
21:04:47 <EvanR> APL people would be proud
21:05:11 <sarahzrf> would they
21:06:02 <jle`> :t catMaybes.zipWith(($>).guard).map(=='x')
21:06:03 <lambdabot> error:
21:06:03 <lambdabot>     • Couldn't match type ‘[b0] -> [f0 b0]’ with ‘[Maybe a]’
21:06:03 <lambdabot>       Expected type: [Char] -> [Maybe a]
21:06:38 <jle`> :t zipWith(($>).guard.map(=='x'))
21:06:39 <lambdabot> error:
21:06:39 <lambdabot>     • Couldn't match type ‘[Bool]’ with ‘Bool’
21:06:39 <lambdabot>       Expected type: [Char] -> Bool
21:06:54 <jle`> :t zipWith(($>).guard.(=='x'))
21:06:56 <lambdabot> Alternative f => [Char] -> [b] -> [f b]
21:07:05 <jle`> hm, still a little longer
21:07:20 <jle`> but at least it's point free
21:08:24 <jle`> s/but at least/and unfortunately
21:09:21 <jle`> > let f = (catMaybes.).zipWith(($>).guard.(=='x')) in f "x  x " "73562"
21:09:23 <lambdabot>  "76"
21:10:24 <johnw> If I'm running on Intel, does anyone know the fastest build options are to pass to cryptonite?
21:11:09 <sarahzrf> just checked, J for this function is:    ('x' = x) # y
21:11:18 <sarahzrf> so no, i don't think APL people would be proud :)
21:12:43 <sarahzrf> https://benzrf.com/uploads/602aaec98136dff3.png
21:13:22 <jle`> J wins
21:13:56 <jle`> i think the matlab version is pretty nice too
21:14:02 <jle`> y(x=='x')
21:14:49 <sarahzrf> hmmmm
21:14:53 <jollygood2> what is J?
21:14:56 <EvanR> k i had low expectation i was right
21:15:06 <sarahzrf> jollygood2: successor to apl
21:15:06 <jle`> i think the principle is the same too
21:15:09 <jle`> logical indexing is neat
21:15:17 <jollygood2> it has a successor :|
21:15:41 <sarahzrf> it uses ascii syntax
21:15:51 <sarahzrf> but it makes up for it by being even more line noise
21:16:03 <jle`> i wonder if we can emulate logical indexing in haskell
21:16:12 <jle`> probably the zip version is the closest way
21:16:52 <jle`> or else abstract it in a logicalIndex function
21:16:59 <sarahzrf> it's not quite logical indexing jle`
21:17:09 <sarahzrf> to be precise, it's this:
21:17:23 <ball> nitrix: Mornin'
21:17:29 <nitrix> :)
21:17:53 <sarahzrf> @let jHash ns l = concat (zipWith replicate ns l)
21:17:55 <lambdabot>  Defined.
21:17:55 <nitrix> ball, there's #haskell-beginners for if/when you bite the bullet.
21:18:02 <jle`> @let logix xs is = [x|(x,True)<-zip xs is]
21:18:03 <ball> Thanks
21:18:04 <lambdabot>  Defined.
21:18:28 <jle`> > "73562" `logix` ((== x)<$>"x  x ")
21:18:30 <lambdabot>  error:
21:18:30 <lambdabot>      • Couldn't match type ‘Char’ with ‘Expr’
21:18:30 <lambdabot>        Expected type: [Expr]
21:18:36 <sarahzrf> :3c
21:18:36 <jle`> > "73562" `logix` ((== 'x')<$>"x  x ")
21:18:38 <lambdabot>  "76"
21:18:49 <jle`> sarahzrf: ah, interesting
21:19:26 <sarahzrf> although full disclosure i didn't know that myself until i saw so while looking up what j's logical indexing operator was :)
21:19:33 <sarahzrf> i don't remember much J off the top of my head
21:19:40 <jle`> so it is basically like a tree branching function
21:19:46 <sarahzrf> hmm, i dunno about that
21:19:46 <jle`> growing, and re-concatenating
21:19:55 <sarahzrf> oh, maybe
21:20:18 <jle`> [1 2 2 0 1] # "abcde"   => "abbcce"
21:20:27 <jle`> i'm not sure why i thought of tree there
21:21:09 <koz_> Oooh, array things!
21:21:57 <sarahzrf> hah, your sample is neither valid J nor haskell syntax
21:22:24 <jollygood2> doesn't parsec already have a parser like this? I thought it was called `line'.  many1 (noneOf "\r\n")
21:23:21 <EvanR> shouldn't it be sepBy newline or some such
21:24:12 <jollygood2> wouldn't that fetch two lines separated by newline?
21:24:22 <EvanR> many lines
21:24:37 <jollygood2> I want just one, current one
21:25:10 <jollygood2> "first line\nsecond line" -> "first line"
21:32:45 <glguy> \n is a terminator, so you'd want endBy
21:32:53 <glguy> or manyTill
21:46:09 <jollygood2> endBy newline
21:47:15 <jollygood2> no, fails to compile
21:53:16 <mjrosenb> newtype RWST r w s m a = RWST { runRWST :: r -> s -> m (a, s, w) }
21:54:06 <mjrosenb> so... if m == Maybe, and something along the way results in a Nothing, then the writer stream goes away?
21:58:22 <dsal> I was going to try polysemy real quick, but then I didn't.
22:03:36 <koz_> dsal: There's a certain Afroman song I'm thinking of...
22:04:23 <dsal> ha
22:04:37 <koz_> "I was gonna try Polysemy, but then I got high..."
22:04:56 <dsal> I've only used transformers once.  It wasn't that bad, but most of my programs don't really *seem* to benefit from such things.
22:05:05 <koz_> "Out-benchmark MTL, but then I got high"
22:05:09 <koz_> Sorry, I'll stop.
22:06:18 <dsal> One problem with polysemy is that it requires a large number of language extensions I don't know how to use and a ghc plugin, whatever that is.
22:08:37 <dsal> Maybe I should read his book.
22:09:21 <koz_> dsal: I would recommend it, but it doesn't mention polysemy, or anything related to it, anywhere.
22:09:38 <koz_> Polysemy needs all the extensions due to its type-level magic.
22:09:54 <dsal> I know.  It's the prerequisites I should understand.
22:11:04 <koz_> But yeah, Sandy's book is good reading.
22:14:38 <dsal> I was at a stage for a while where I got MTL/transformers, but didn't have a use for them.  Then I tried them out and they helped a little in one program.  I think I kind of get polysemy, but don't quite know how to apply it to my life.
22:14:49 <dsal> Similarly, GADTs and stuff.  I kind of get it, but I don't, you know, think in types.
22:18:18 <koz_> dsal: Yeah, _definitely_ read Sandy's book.
22:20:49 <mjrosenb> which book is this?
22:20:52 <dsal> I've had this tab open for a while... I think the book cost a good deal less then.  :)
22:20:56 <dsal> https://leanpub.com/thinking-with-types
22:24:06 <int-e> "Haskell is an untyped, interpreted programming language"
22:24:37 * jusss wow
22:24:42 * hackage tmp-postgres 1.2.0.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.2.0.0 (JonathanFischoff)
22:24:44 <int-e> (A bit dated.)
22:24:46 <ammar2> sounds about right
22:26:39 <int-e> I got the quote wrong. It's "Haskell is a dynamically-typed, interpreted language.": https://aphyr.com/posts/342-typing-the-technical-interview 
22:27:03 <jusss> about (->) in the type, like f :: Int -> Int, apply 3 on f and get another valule has Int, what about f :: T Int -> Int?
22:27:54 <Axman6> what is T?
22:28:00 <jusss> what value has Reader r a?
22:28:05 <int-e> Nevertheless that's what I think of whenever people talk about type-level programming. It's great that it can be done but I'm never convinced that it should be done.
22:28:09 <jusss> Axman6: just a type constructor
22:28:29 <jusss> data Reader r a = Raader r -> a
22:28:48 <jusss> what value would have Reader r a
22:29:11 <int-e> depends on Raader?
22:29:12 <koz_> int-e: To each their own. I've found it both useful and rewarding, but I understand there's people who disagree.
22:29:26 <jusss> int-e: it's typo
22:29:27 <Axman6> I assume you mean data Reader r a = Raader (r -> a)
22:29:37 <int-e> jusss: It's also a syntax error, as I realized a bit too late
22:30:00 <jusss> Axman6: yeah, what value has that?
22:30:24 <koz_> Reader r a is a fancy way of talking about 'functions which take things of type r as input, and return things of type a'.
22:31:21 <jusss> I like `f >>= g = \x -> g (f x) x' without Reader 
22:32:38 <monochrom> So don't use Reader.
22:32:54 <koz_> Reader is a bit of a niche tool.
22:32:59 <jusss> monochrom: but there're also Writer and State...
22:33:00 <koz_> (at least in my experience)
22:33:06 <Axman6> ReaderT is very useful though
22:33:06 <koz_> jusss: They're different things.
22:33:07 <monochrom> So?
22:33:08 <jusss> so I have to understand them...
22:33:10 <koz_> Axman6: Agreed!
22:33:12 <monochrom> Your point?
22:33:14 <dsal> I thought I needed Reader recently.  Set it all up and then didn't even use the stuff I put in it.
22:33:21 <dsal> (Well, ReaderT, that is)
22:33:22 <koz_> (in fact, something I'm working on right now leans heavily on ReaderT)
22:33:40 <monochrom> If ReaderT exists then Reader = ReaderT Identity exists.
22:33:49 <int-e> ReaderT is useful as a part of a monad stack for dealing with "global" configuration.
22:33:54 <monochrom> You can't wish it away.
22:34:15 <jusss> could you tell what value form it is? the value which has Reader r a?
22:34:29 <jusss> Reader (r->a) is ?
22:34:50 <monochrom> Reader even, Reader not, Reader (\x -> even x || odd x)
22:34:51 <int-e> jusss: can you rephrase?
22:35:09 <int-e> I don't undertand "value form".
22:35:51 <jusss> int-e: data Maybe a = Just a | Nothing,    a is a type, and I think Just a is not a type, is a value form
22:36:02 <int-e> Oh. terms.
22:36:08 <jusss> Just 3 :: Maybe Int
22:36:09 <dsal> When people say “but most business logic bugs aren’t type errors,” I just want to show them how to make bugs into type errors. -- Matt Parsons
22:36:14 * dsal just bought that book...
22:36:30 <koz_> dsal: You're helping a good cause (namely, Sandy writing more).
22:36:39 <dminuoso_> jusss: The data syntax is very terse and interleaves types and terms.
22:36:44 <int-e> ask = Reader id :: Reader r r
22:36:48 <dminuoso_> jusss: Perhaps GADTStyle is a bit more helpful for you.
22:36:49 <koz_> Disclaimer: I bought the book on release.
22:36:53 <dminuoso_> *GADTSyntax
22:36:57 <dsal> Yeah.  He seems pretty great.  I had to turn it down a bit from $80, though.
22:37:06 <koz_> Yeah, fair enough.
22:37:18 <dminuoso_> jusss: data Maybe a where Just :: a -> Maybe a; Nothing :: Maybe a
22:37:22 <dminuoso_> jusss: ^- is this more clear?
22:37:23 <monochrom> GADT syntax can't do newtype.
22:37:31 <int-e> jusss: So the `Reader` data constructor takes one argument which must be a function.
22:37:38 <dminuoso_> monochrom: Let's just gloss over that.
22:37:43 <monochrom> OK!
22:37:48 <dminuoso_> monochrom: (Because this argument is really not helpful at this point)
22:38:42 * hackage cobot 0.1.1.0 - Computational biology toolkit to collaborate with researchers in constructive protein engineering  https://hackage.haskell.org/package/cobot-0.1.1.0 (zmactep)
22:39:26 <jusss> so `Reader a-function' :: Reader r a,   and a-function :: r -> a?
22:39:35 <int-e> monochrom: Re: "Reader exitst"... yes, it exists, and I hardly ever use it. But ReaderT as part of a custom monad... is useful.
22:40:06 <dminuoso_> jusss: Yes. Albeit your pseudo syntax is a bit confusing.
22:40:43 <dminuoso_> jusss: Think of Reader as just (->) but in prefix position. :)
22:40:46 <int-e> :t \a function -> a-function
22:40:47 <lambdabot> Num a => a -> a -> a
22:41:35 <dminuoso_> juss: T `Reader` A ~= T -> A
22:41:42 * hackage cobot-io 0.1.2.0 - Biological data file formats and IO  https://hackage.haskell.org/package/cobot-io-0.1.2.0 (zmactep)
22:42:05 <int-e> eww.
22:42:20 <jusss> dminuoso_: I see, Reader (->) r a
22:43:19 <dminuoso_> Though arguably Reader is somewhat useless..
22:43:20 <int-e> Reader T A ~= (->) T A = T -> A
22:43:41 <jusss> how we can get a by the way?
22:43:47 <jusss> from Reader (->) r a
22:43:57 <monochrom> Provide r.
22:43:59 <dminuoso_> jusss: How can you get a `Bool` given some `Int -> Bool`?
22:44:16 <jusss> monochrom: provide r with Reader prefix?
22:44:22 <koz_> :t runReader
22:44:23 <lambdabot> Reader r a -> r -> a
22:44:25 <jusss> dminuoso_: give a Int
22:44:40 <int-e> jusss: What do you mean by  Reader (->) r a -- the (->) argument makes no sense.
22:44:41 <jusss> f :: Int -> Boot,  f Int :: Boot
22:44:50 <int-e> (to me)
22:45:12 <int-e> ...
22:45:21 <int-e> f (_ :: Int) :: Boot
22:45:26 <jusss> int-e: (->) is the function, r is the parameter type, a is the result type
22:45:57 <dminuoso_> jusss: Piece of advice. You very frequently make up very confusing non-sense syntax. Perhaps try to learn to be precise with your syntax and your language?
22:46:02 <int-e> jusss: oh so you mean the Reader data constructor. But that one takes only one argument!
22:46:38 <jusss> dminuoso_: ok...
22:46:39 <int-e> We have  Reader (_ :: r -> a) :: Reader r a
22:46:42 <dminuoso_> `f :: Int -> Boot,  f Int :: Boot` <- this for example is nonsense. :)
22:46:42 * hackage tmp-postgres 1.2.0.1 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.2.0.1 (JonathanFischoff)
22:47:08 <dminuoso_> f is a value level term. So if `f :: Int -> Bool`, then you cannot apply `f` to `Int` because Int is a type-level term.
22:47:19 <dminuoso_> You can apply `f` to a *value* of type Int.
22:47:29 <dminuoso_> So `f (x :: Int) :: Bool` would be a correct statement
22:47:40 <int-e> And if we have data Reader r a = Reader { runReader :: r -> a }, then  runReader (Reader (_ :: r -> a)) (_ :: r) :: a
22:47:59 <jusss> ok
22:50:32 <jusss> > t = Reader (+1)
22:50:34 <lambdabot>  <hint>:1:3: error:
22:50:34 <lambdabot>      parse error on input ‘=’
22:50:34 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
22:50:52 <jusss> why this is wrong?
22:50:59 <jusss> > let t = Reader (+1)
22:51:01 <lambdabot>  <no location info>: error: not an expression: ‘let t = Reader (+1)’
22:51:16 <jusss> :t (+1)
22:51:18 <lambdabot> Num a => a -> a
22:51:21 <int-e> lambdabot expects an expression.
22:51:26 <int-e> > Reader (+1)
22:51:28 <lambdabot>  error:
22:51:28 <lambdabot>      • Data constructor not in scope:
22:51:28 <lambdabot>          Reader :: (Integer -> Integer) -> t
22:51:39 <int-e> (and of course this one doesn't really work)
22:51:54 <int-e> @let newtype Reader r a = Reader { runReader :: r -> a }
22:51:55 <lambdabot>  Defined.
22:52:02 <int-e> :t Reader (+1)
22:52:03 <lambdabot> Num a => L.Reader a a
22:52:19 <int-e> :t reader
22:52:20 <lambdabot> MonadReader r m => (r -> a) -> m a
22:52:32 <jusss> :t Reader id
22:52:33 <lambdabot> L.Reader a a
22:53:24 <jusss> where this Reader is defined? not in Control.Monad.Reader?
22:53:31 <int-e> @undef
22:53:31 <lambdabot> Undefined.
22:53:41 <int-e> :t reader (+1) :: Reader Int Int
22:53:42 <lambdabot> Reader Int Int
22:54:04 <jusss> @hoogle Reader
22:54:04 <lambdabot> Data.Text.Lazy.Read type Reader a = IReader Text a
22:54:04 <lambdabot> Data.Text.Read type Reader a = IReader Text a
22:54:04 <lambdabot> module Control.Monad.Trans.Reader
22:54:31 <int-e> > runReader (do x <- ask; return (x+x)) 42
22:54:33 <lambdabot>  84
22:55:12 * hackage cobot-tools 0.1.0.1 - Biological data file formats and IO  https://hackage.haskell.org/package/cobot-tools-0.1.0.1 (ozzzzz)
22:55:19 <int-e> type Reader r = ReaderT r Identity -- Defined in ‘Control.Monad.Trans.Reader’
22:55:36 <jle`> jusss: the equivalent to your 'Reader' would be 'reader', or 'asks'
22:56:00 <int-e> This is isomorphic to the type we're discussing, but there is no actual `Reader` data constructor.
22:56:36 <int-e> But `reader` generalizes that data constructor, so no functionality is lost.
22:57:45 <zeta_0> hello guys, in emacs i am getting this language server protocol error when haskell-ide-engine gets activated, why is that and how do i fix it ? https://hastebin.com/gewebalume.php https://hastebin.com/urahuzilay.nginx
23:00:50 <zeta_0> i don't even understand the: `haskell-lsp:configuration parse error` ?
23:01:33 <jusss> int-e: oh wait, so we have to use `reader' to generate `Reader ' type?
23:01:44 <jusss> why we don't define it...
23:02:16 <jle`> jusss: it's what we call a 'smart transformer'
23:02:21 <jle`> er
23:02:23 <jle`> 'smart constructor'
23:02:28 <jle`> reader :: (r -> a) -> Reader r a
23:02:44 <jle`> there's also 'ask'
23:02:52 <jle`> asks :: (r -> a) -> Reader r a
23:03:01 <jle`> two ways to create a Reader from a function
23:03:20 <int-e> jusss: Making Reader a type synonym avoids code duplication. Arguably there could be a pattern synonym for it...
23:03:32 <dminuoso_> jle`: Though... reader really isnt a smart constructor, is it?
23:03:46 <dminuoso_> I mean a smart constructor would, to me at least, suggest that it somehow constrains the constructor.
23:03:59 <jle`> maybe 'abstract constructor' is a better word
23:04:15 <jusss> jle`: ok...
23:04:21 <jle`> but smart constructor doesn't necessarily mean constraint, there's singleton :: k -> a -> Map k a
23:04:37 <jusss> jle`: Writer and State are `smart constructor'?
23:04:43 <jle`> 'writer' and 'state'
23:04:51 <jusss> same?
23:04:53 <jle`> Writer and State as data constructors do not exist in transformers
23:04:58 <jle`> but we have:
23:05:14 <jle`> writer :: (a, w) -> Writer w a    -- why isn't this curried? we may never know
23:05:21 <jle`> state :: (s -> (a, s)) -> State s a
23:06:00 <jle`> but, *usually*, we don't work with Reader/Writer/State using reader/writer/state
23:06:05 <jusss> then why we don't use `smart constructor' to generate every type?
23:06:18 <jle`> we're generating values here, not types
23:06:40 <jle`> and, these sorts of 'type primitives' are pretty common in most type API's
23:06:59 <jle`> but for some times like Maybe, we already have constructors, Just, and Nothing, that do the job fine
23:07:04 <jusss> the whole thing is too weird to me
23:07:19 <jle`> jusss: i was saying, we usually don't use reader/writer/state in practice
23:07:27 <jle`> we usually use 'ask' for reader
23:07:31 <jle`> 'tell' for Writer
23:07:39 <jle`> and 'modify' and 'get' for State
23:07:46 <jusss> and `put'?
23:07:48 <jle`> ask :: Reader r r
23:08:03 <jle`> tell :: w -> Writer w ()
23:08:13 <jle`> modify :: (s -> s) -> State s ()
23:08:18 <jle`> get :: State s s
23:08:27 <jle`> those are sort of the canonical "abstract interface" of reader, writer, and state
23:08:41 <jle`> so you build complex reader/writer/state actions by sequencing calls to ask, tell, and modify
23:09:09 <dminuoso_> Similarly, how `putStrLn`, `getLine`, etc. form the "abstract interface" of IO.
23:10:41 <jle`> > execWriter $ do tell "hi"; tell "bye"
23:10:44 <lambdabot>  "hibye"
23:11:04 <jle`> > execState (do modify (+1); modify (*10); modify negate) 3
23:11:05 <lambdabot>  -40
23:11:41 <jle`> > runReader (do x <- ask; y <- ask; pure (x+y)) 7
23:11:43 <lambdabot>  14
23:12:37 <jle`> so the person who gave us the IO type also gave us things to make 'simple IO actions', like putStrLn, getLine.  we can use those simple Io actions to build more complex and interesting ones, by sequencing them and stuff like that
23:13:09 <jle`> the person who gave us the State s type also gives us things to make 'simple State actions', like modify, put, get.  we use those simple State actions to build more complex and interesting State actions, by sequencing them with >>/do notation and stuff like that
23:13:56 <jle`> it's rare to actually use 'state', but we can define it in terms of modify and get: `state f = do s <- get; let (x, s') = f s; put s'; return x`
23:14:42 <jle`> likewise it's rare to actually use 'writer', but we can define it in terms of tell: `writer (x, w) = do tell w; return x`
23:21:26 <monochrom> You don't need an abstract constructor (or abstract type) if you have nothing to hide.
23:24:26 <int-e> pattern Reader :: (r -> a) -> Reader r a; pattern Reader f <- ((runIdentity .) . runReaderT -> f) where Reader f = reader f -- somehow, pattern synonyms are not beautiful.
23:46:29 <evocatus> can I tie the knot using where clauses?
23:49:39 <dminuoso_> evocatus: Yes.
23:49:53 <dminuoso_> evocatus: `where` just desugars into `let-in`
23:50:15 <evocatus> dminuoso_: ah ok, didn't know that... must have just messed something up here then
23:51:23 <dminuoso_> evocatus: More generally, if its named (top level declaration, where declaration, let binding) it can be shared. :)
23:51:59 <dminuoso_> evocatus: Is the type of it polymorphic perhaps?
23:52:17 <dminuoso_> (Because polymorphism prevents sharing)
23:56:41 <kenran> I'm trying to build a project someone sent me with old-style (v1) cabal commands. This worked two weeks ago with `cabal new-build`, but now it doesn't anymore (with neither new- nor v1-build). The problem is: with new-build I get one linker error (-lz missing), while `v1-install --only-dependencies` fails in the `Linker` step for every single package (-liconv missing this time). I'm on macOS catalina btw. 
23:56:47 <kenran> Does anyone have an idea how I can start attacking this issue?
23:57:02 <evocatus> dminuoso_: eh, maybe that is it? I am trying to build a `BinarySearchTree a` with bidirectional links from child->parent and parent->child
23:57:20 <kenran> Something in the environment seems to be seriously damaged, but I don't know how to find out why `ld` is not finding the necessary stuff.
23:57:55 <[exa]> kenran: is there a complete build log? you might find how `ld` is invoked
