00:00:02 <jle`> HM_Having_a_go: honestly, better to just ask your question :)
00:00:09 <jle`> if it isn't good, you'll find out then
00:02:49 <Ariakenom> @quote Ask.x
00:02:49 <lambdabot> Ariakenom says: join :: Ask (Ask x) -> Ask x
00:03:51 <jle`> clever :)
00:09:50 <Ariakenom> apparently someone else has made that joke since then
00:09:52 <iqubic> Asking to ask is just a prelude to asking.
00:09:52 <Ariakenom> @quote ask.something
00:09:53 <lambdabot> BMeph says: Haskell: Where even the newest newcomer acts monadically: join :: ask (ask something) -> ask something
00:12:05 <iqubic> What they should really do is just 'return :: a -> Ask a'
00:12:32 <iqubic> If you give me a topic, I'll give you you a question about that topic
00:16:29 <Ariakenom> cardinality from that link as something I implemented a few times last year
00:17:38 <iqubic> Yeah. It's good.
00:56:07 <robotmay> Anyone know how to write a multi-line parser in megaparsec? Feel like I'm missing something, haven't found any obvious examples of how it works
00:56:35 <robotmay> i.e. I want to parse multiple lines and return them as a list of records
00:58:15 <glguy> Each record being terminated by a newline?
00:58:48 <robotmay> Yeah
00:59:07 <glguy> endBy parseThing newline
00:59:57 <robotmay> Ooh cool I'll check it out
01:01:08 * hackage tidal 1.4.5 - Pattern language for improvised music  https://hackage.haskell.org/package/tidal-1.4.5 (AlexMcLean)
01:06:08 <absence> has anyone used vinyl? i'm having some trouble going from Rec MyFields LabelledFieldTypes to Rec Identity FieldTypes
01:14:22 <glguy> Probably more people can help you do that than use vinyl
01:20:09 * hackage broadcast-chan 0.2.1 - Closable, fair, single-wakeup channel type that avoids 0reader space leaks.  https://hackage.haskell.org/package/broadcast-chan-0.2.1 (MerijnVerstraaten)
01:21:06 <jle`> absence: i think there should be some functions in .Derived that do that
01:21:09 * hackage broadcast-chan-conduit 0.2.1, broadcast-chan-pipes 0.2.1, broadcast-chan-tests 0.2.1 (MerijnVerstraaten): https://qbin.io/third-coal-l5wk
01:21:57 <jle`> absence: i think stripNames
01:22:29 <merijn> Whoo! Fixing obscure race conditions with no easy way to test against regression! \o/
01:22:35 <jle`>  /o\
01:23:35 <merijn> jle`: I know!
01:25:41 <merijn> Feel free to help create one if you like puzzling, because I've spend 3 days thinking about how to reliably reproduce it, despite knowing the exact problem and I have no clue :p
01:28:51 <jle`> if there's anything more frustrating than fixing a race condition, it's reproducing one
01:31:00 <merijn> On a related note, despite the (in hindsight) somewhat misnomer of the package broadcast-chan-conduit is probably the single most useful piece of code I've written in a long time and anyone who's running slow IO operations inside a conduit should totally have a look :p
01:32:01 <asheshambasta> What can be done to fix this: https://gist.github.com/asheshambasta/7e00b0f9abdee6caeb23fa658f3d28df 
01:33:55 <merijn> asheshambasta: That's hard to say without seeing the cabal file?
01:36:10 <asheshambasta> merijn: actually, I got what the issue was: the project was called 'diagrams', which is the same name as one of its dependencies. 
01:36:24 <merijn> I was thinking that might be it :p
01:36:49 <asheshambasta> but the error message is unhelpful: in this case stack/cabal should just reject building the thing 
01:37:25 <merijn> Well it did reject building
01:37:53 <absence> jle`: thanks, that sounds like what i want, but the types don't quite line up: Expected type: Rec ElField ts Actual type: Rec Attr '[ 'Name, 'Age, 'Sleeping] (it's the type from the tutorial)
01:38:37 <jle`> absence: it should only work if you have specific types in your record
01:38:42 <jle`> instead of a variable like 'ts'
01:40:08 <absence> jle`: ts is the expected type, i don't have a ts
01:40:50 <jle`> absence: hm, how is ts coming up?
01:42:22 <absence> jle`: this is the record: (SName =:: "jon") :& (SAge =:: 23) :& (SSleeping =:: False) :& RNil :: Rec Attr [Name, Age, Sleeping]
01:43:42 <absence> jle`: if i use stripNames on it, i get a type error: Couldn't match type `Attr' with `ElField' Expected type: Rec ElField ts
01:45:47 <jle`> absence: hm, where is Attr from?
01:47:13 <absence> jle`: it's the newtype wrapper for the type family in the tutorial: http://hackage.haskell.org/package/vinyl-0.12.0/docs/Data-Vinyl-Tutorial-Overview.html
01:47:37 <asheshambasta> merijn: not really telling me why though :-P 
01:48:33 <jle`> absence: ah, it looks like Attr is basically a "re-implemtation" of ElField
01:48:50 <merijn> asheshambasta: I did, though?
01:48:50 <jle`> or at least that's what it looks like from first glance
01:48:55 <merijn> asheshambasta: "Components in the package depend on each other in a cyclic way: 'library' depends on 'library'"
01:49:34 <jle`> absence: hm actually let me check to make sure that's what it is
01:52:10 <asheshambasta> merijn: it still doesn't make sense to me :-) 
01:52:30 <absence> jle`: since it contains a value of the ElF type family also defined in the tutorial, i guess it's not exactly the same, but maybe defining fields can/should be done in terms of ElField?
01:53:41 <jle`> absence: yeah it's weird, i've never actually looked at what the tutorial is suggestiong
01:53:50 <jle`> i've always just used ElField and its ecosystem
01:54:09 <jle`> i think the tutorial was written before ElField was introduced
01:54:22 <jle`> since basically it is reproducing the API from scratch
01:54:50 <jle`> and a lot of utilities (like stripNames) are missing and probably have to be written from scratch as well
01:55:23 <merijn> asheshambasta: It's saying the library is depending on itself because it depends on 'diagrams'
01:55:37 <merijn> asheshambasta: Which is the library in your package
01:55:48 <absence> jle`: do you know of some resource that shows how to do this the proper way?
01:55:50 <jle`> absence: yeah, the difference between Attr and ElField is that instead of using an ADT to label the fields (Name/Age/Sleeping/etc.), ElField uses symbols, so you don't need to make your own type from scratch
01:56:00 <jle`> absence: you'd use "Name"/"Age"/"Sleeping"
01:56:25 <jle`> also it includes singletons for you so you don't have to generate singletons yourself using templat ehaskell
01:56:32 <jle`> which is kind of gross
01:56:55 <absence> sounds very nice
01:56:59 <jle`> in modern times you'd use OverloadedLabels instead
01:57:19 <jle`> i think the documentation in Data.Vinyl.Derived should be a good introduction ... but i think it needs a lot less of an introduction than the method in the tutorial
01:58:44 <jle`> basically you'd write (#name = "jon") :& (#age =: 23) :& (#sleeping =: False) :& RNil :: Rec Attr ["name" ::: String, "age" ::: Int, "sleeping" ::: Bool]
01:58:56 <merijn> In modern times I would recommend trying to avoid these sorts of overcomplicated abstractions :p
01:59:24 <jle`> i guess usability wise it means you also have to specify the type as well, since now you just have a string
01:59:38 <jle`> then stripNames would do what you want.  
01:59:41 <jle`> s/Attr/ElField
02:00:02 <jle`> or actually you can just use the synonym FieldRec ["name" ::: String ... ]
02:00:10 <jle`> merijn: that's fair too :)
02:00:21 <jle`> i end up using vinyl in application code when i have a lot of "overlapping" records
02:00:24 <jle`> record types
02:00:38 <merijn> Like, I'm not sure what you're trying to do, but I'm pretty confident it doesn't have to be this damn complicated
02:00:40 <jle`> so like two types that are almost close but differing by adding on a field or so
02:01:14 <absence> merijn: extensible records basically
02:01:30 <jle`> well, you just have (#name =: "jon") =:= (#age =: 23)
02:01:33 <merijn> My recommendation is "Stop wanting those in Haskell"
02:01:49 <jle`> er, #name =: "jon" :& #age =:= 23
02:02:01 <jle`> as the pojo of {name: "jon", age: 23}
02:02:11 <Jon> hello :-)
02:02:21 <Jon> nearer double 23, but thanks, that's flattering :P
02:02:27 <jle`> Jon: greetings :)
02:02:46 <jle`> i mean, we didn't specify the units ;)
02:02:48 <merijn> At some point you have to wonder whether the amount of "boilerplate death machine" you're building outweighs just doing the simple thing >.>
02:03:15 <Jon> haha 
02:03:21 <jle`> yeah, there's a high bar for me when i'd switch from using records to using extensible records like vinyl
02:03:23 <Jon> I guess everyone is 23, their base just varies
02:03:40 <jle`> but in those cases i've been happy
02:03:46 <absence> merijn: if the "simple thing" is to stop wanting to do it in haskell, should i rewrite everything in javascript or what? :p
02:04:02 <merijn> absence: What is the problem that extensible records are supposed to solve?
02:04:48 <absence> merijn: dealing with "field soup" i guess?
02:05:29 <merijn> absence: I mean, is it substantially better than just "Map String MyADT" where MyADT handles the different types?
02:05:31 <jle`> for me it cleans up situations where i have multiple record types that differ just very slightly
02:05:46 <jle`> in what fields they have
02:06:06 <jle`> then i don't have to declare a whole new record from scratch foe very single variation of my type
02:06:39 <absence> jle`: what language extension do i need for #name etc? not quite sure what to google for
02:06:45 <jle`> so the boilerplate it reduces is having sAge, pAge, qAge, rAge, sprAge
02:07:00 <jle`> absence: OverloadedLabels, it should be noted in the docs for =:
02:07:19 <jle`> i definitely didn't intend to spell out SPQR
02:07:20 <iqubic`> @pl \x f -> f x
02:07:21 <lambdabot> flip id
02:07:26 <absence> merijn: you get compile-time vs runtime errors if i understand correctly
02:07:33 <iqubic`> Hello?
02:07:40 <merijn> absence: Sure
02:07:45 <jle`> but if i had like records A, B, C, D, E, and they all have age, i'd have aAge, bAge, cAge, dAge, eAge
02:07:59 <merijn> absence: On the other hand, you won't have to spend 3 weeks fighting and struggling with all this nonsense...
02:08:11 <merijn> absence: So you have to ask yourself which saves more time :p
02:08:51 <absence> merijn: that argument could be used about learning haskell at all ;) the goal isn't always to save time, robustness is nice too
02:08:52 <merijn> I mean, I admit that I too love knowing at compile time things can't go wrong, but at some point it's more pain than it provides useful guarantees
02:09:13 <iqubic`> @pl \x f -> f x
02:09:13 <lambdabot> flip id
02:10:04 <jle`> merijn: i agree that it's a measuring game
02:12:22 <iqubic> @pl \x f -> f x
02:12:23 <lambdabot> flip id
02:12:35 <iqubic> Huh? How does that work?
02:12:51 <jle`> @src flip
02:12:51 <lambdabot> flip f x y = f y x
02:12:52 <iqubic> Oh. I see.
02:13:04 <iqubic> Right.
02:13:26 <absence> jle`: thanks for the help, that got me a bit further
02:13:33 <iqubic> I just wrote a small little interface to your AoC library.
02:13:46 <iqubic> Now, how the heck do I get my auth token?
02:14:06 <Ariakenom> iqubic: x & f = f x
02:14:40 <iqubic> I see.
02:15:58 <Ariakenom> > x & f :: Expr
02:16:00 <lambdabot>  f x
02:23:37 <absence> jle`: hmm... "Couldn't match type `Data.Vinyl.Functor.Identity' with `Identity'" do you know why it doesn't use Data.Functor.Identity?
02:25:45 <jle`> absence: judging from https://hackage.haskell.org/package/vinyl-0.12.0/docs/Data-Vinyl-Functor.html#t:Identity, it's for the 'show' instance
02:26:41 <berndl> I've been wondering about something: Why are there blog posts & talks about free monad vs tagless final and free monad vs monad transformers, but nothing about tagless final vs monad transformers?
02:27:43 <amalloy> iqubic: are you looking for "session keys" in https://hackage.haskell.org/package/advent-of-code-api ?
02:28:06 <iqubic> I am.
02:28:12 <iqubic> And I found what I needed,
02:28:27 <iqubic> Shift-F9 on firefox got me the right value.
02:30:03 <merijn> berndl: Because those two are not necessarily orthogonal
02:30:22 <iqubic> It's Identity.
02:30:48 <iqubic> How many functions of type 'a -> a' can you write? One.
02:30:53 <iqubic> id x = x.
02:31:06 <bjs> iqubic: `id x = id x` :)
02:31:23 <bjs> althoguh I guess that's not 'a -> 'a so nvm
02:34:08 <berndl> merijn: Still though, in the context of effect systems, I would expect at least some observations about monad transformers and tagless final.
02:35:06 <lortabac> berndl: I remember Edward Kmett talking about using transformers without mtl at Zurihac 2015, I don't know if the video is available online
02:35:07 <berndl> This whole effects mumbo jumbo has confused me.
02:35:40 <zincy_> What confused you? The word "effect"
02:36:01 <berndl> That's one thing.
02:36:14 <berndl> Now I realize an "effect" is a relative thing.
02:36:28 <zincy_> An effect is just the context of a computation
02:36:48 <berndl> zincy_: that says nothing unless you define "context" and "computation".
02:37:43 <zincy_> Lets say a computation is a pure function of its inputs
02:38:17 <zincy_> it can be nested as part of a larger value
02:38:35 <jle`> in my head i've come to think of effect as "whatever is left unchanged by fmap"
02:38:40 <zincy_> The larger value is the "context" and what it gives the computation is a notion of non-determinism.
02:39:03 <berndl> zincy_: So a computation is a function? Then just call  it a function.
02:39:24 <zincy_> So one computation can change the context and then it is passed to the next computation
02:39:56 <zincy_> A computation is more general than a function because it isn't pure
02:40:12 <zincy_> pure functions can be embedded in computations
02:40:13 <berndl> So a computation is like a subroutine?
02:40:25 <zincy_> Whats a subroutine?
02:40:38 <berndl> https://en.wikipedia.org/wiki/Subroutine
02:42:40 <berndl> Basically subroutine is what Joe-programmer is talking about when he says the word "function". For me, a function is either a lambda term or a set of ordered pairs (depending on which foundation you're using).
02:44:22 <tom_> berndl: I dont know if subroutine is interchangeable with "computation"
02:46:12 <berndl> tom_: How do you define "computation"? Isn't "computation" just beta-reduction in the lambda calculus?
02:46:32 <merijn> berndl: "computation" here is just a handwave
02:46:54 <berndl> And that's where my confusion starts.
02:47:00 <merijn> berndl: "Some defined abstract evaluation"
02:47:47 <typetetris> With cabal 3.0.0.0 the commands are the former v2-* commands? Why does the user then still emphasis sandboxes so much?
02:49:18 <merijn> typetetris: Because no one has contributed a patch to the documentation yet and cabal-install is way undermanned
02:49:34 <merijn> So, basically a case of "patches welcome" :)
02:51:00 <berndl> merijn: that make sense to me if we're abstracting over all computational models, but I'm pretty sure that's not what's going on.
02:51:02 <merijn> afaik there's like 3-5 main contributors and a handful more incidental contributors all of them only working parttime and "fixing the code" is mostly prioritised over "improving the docs", so that's an easy way to contribute :)
02:51:41 <merijn> berndl: Well, how do you describe what 'm' means in '(>>=) :: Monad m => m a -> (a -> m b) -> m b'?
02:51:54 <typetetris> If I decided to prepare patches for cabal-install, I would be afraid nothing I did would be judged good enough.
02:52:12 <merijn> typetetris: I can tell you from experience that the threshold is really not that high :p
02:52:38 <berndl> merijn: It's just a unary type constructor with a Monad instance.
02:53:14 <merijn> berndl: Yeah, but how do you talk about what monad laws mean, for example? Generally people handwave and say "computation"
02:53:33 <merijn> berndl: Your problem appears to be "looking for meaning/definitions where none exist"
02:53:43 <iqubic> I was just using the hackage quick jump feature and got this message: "Left "no matches for 'nub'" :: Either String (NonEmpty SearchResult)"
03:09:44 <berndl> merijn: I'm looking for understanding that doesn't rely on handwaving.
03:10:56 <EvanR> what was the question? "what is computation?" ?
03:11:29 <kuribas> monad is a form of computation, like pretty much every typeclass in haskell
03:11:35 <berndl> Actually, it started with "effect".
03:12:16 <kuribas> I like effect for applicative, even though it's technically wrong.  It's more like emulating effects.
03:12:16 <EvanR> effects correspond to side-effects in other languages, but... just not side
03:12:29 <kuribas> But then is non-determinism an effect?
03:12:43 <kuribas> I suppose in prolog it is
03:14:26 <kuribas> EvanR: right
03:14:47 <kuribas> in applicative the effects don't depend on each other, in monad they do.  
03:14:53 <kuribas> Or at least can.
03:15:43 <berndl> What about arrows?
03:15:59 <jle`> arrow is a different discussion, it's of a different kind :)
03:16:40 <berndl> Really, aren't arrows just functors (more specifically strong profunctors)?
03:16:44 <jle`> but, Arrow as an abstraction was an exploration that eventually yielded Applicative as the result of that exploration
03:16:57 <jle`> arrows are * -> * -> *, applicative/monad are * -> *
03:17:22 <iqubic> It was a different kind of result than we expected, but a result nonetheless.
03:17:27 <jle`> basically we looked at arrow as a way to get some benefits maybe, but it turns out Applicative got all the benefits that mattered
03:17:57 <iqubic> Also, I just made the same joke as jle` just did.
03:18:16 <jle`> so once we realized how awesome Applicative was (around 2008), Arrow sort of died as an abstraction
03:18:31 <jle`> oh hey i just realized Applicative turned 10 and i didn't even realize
03:18:37 <kuribas> isn't an arrow a category ?
03:18:53 <jle`> Category is a superclass of Arrow if that's what you mean
03:19:04 <iqubic> I still see some Arrow tutorials floating around on the web, but I don't want to learn the,.
03:19:04 <jle`> and Category isn't really any more vibrant of an abstraction either these days
03:19:24 <iqubic> Does GHC still support proc notation?
03:19:34 <kuribas> some libraries use it.  For xml parsing for example
03:19:55 <kuribas> iqubic: proc notation is the most confusing thing ever
03:19:59 <berndl> Category is a half-assed abstraction in Haskell.
03:20:23 <iqubic> I kinda understand proc notation, but not really.
03:22:38 * hackage fast-downward 0.2.0.0 - Solve classical planning problems (STRIPS/SAS+) using Haskell & Fast Downward.  https://hackage.haskell.org/package/fast-downward-0.2.0.0 (OliverCharles)
03:57:13 <gauga> hello haskell experts! could somebody help a haskell newbie? 
03:58:11 <gauga> I am trying to write a function that would take two lists and return a list with the numbers of how many times each element from the first list appears in the second list
03:58:38 <gauga> I am getting a error non-exhaustive patterns although I've defined my base cases
03:59:05 <gauga> this is what I have: numTimesFound x xs = length $ filter (\e -> (e == x ) || (e == swap x)) xs 
03:59:11 <gauga> listOccurences [] [a] = []
03:59:34 <gauga> I am getting a non-exhaustive patterns error when calling the function listOccurences 
04:00:09 <dminuoso> gauga: What if the first parameter has more than one element? or the second one has 0 or many elements?
04:00:38 <gauga> hi dminuoso, do you mean I should write more base cases?
04:01:10 <gauga> I have added this one: listOccurences [a] [] = [] and listOccurences [] [] = [] but still getting the same damn error
04:02:51 <dminuoso> gauga: Can you perhaps share your entire code?
04:03:22 <gauga> sure!
04:03:48 <gauga> numTimesFound x xs = length $ filter (\e -> (e == x ) || (e == swap x)) xs
04:05:24 <gauga> and I am getting the message Exception: Non-exhaustive patterns in function listOccurences
04:07:30 <Ariakenom> gauga: paste your entire code and the error into your favorite paste site, for example https://gist.github.com/
04:12:52 <gauga> will do!
04:13:07 <absence> in example code i often see typelevel lists prefixed by ' (e.g '[...]), but it seems to compile without the ' as well. what's the difference?
04:13:22 <dminuoso> absence: The ' is for resolving ambiguity.
04:13:47 <dminuoso> absence: Consider the difference between `T '
04:13:57 <dminuoso> absence: Consider the difference between `T []` and `T '[]`
04:14:44 <absence> dminuoso: ah right, so it's superfluous in type signatures, but it's different when passing type level lists as parameters
04:14:56 <dminuoso> absence: Or put it differently, if you have a `data Bool = True | False` and for some reason you have some `data True = MkTrue`, then the `backtick` is for referring to value-level identifiers in the type level.
04:15:03 <dminuoso> absence: It might not be superfluous.
04:16:08 <dminuoso> absence: If its non ambiguous, its superfluous. But if there is ambiguity (by that identifier/operator existing in the type level as well as the term level) then GHC will default to picking the type level one. The backtick lets you tap into the term level one.
04:16:24 <dminuoso> This only makes sense if we enable DataKinds or something that implies it of course
04:17:01 <dminuoso> % :set -XDataKinds
04:17:01 <yahb> dminuoso: 
04:17:07 <dminuoso> % data Dat = Two Int Int
04:17:07 <yahb> dminuoso: 
04:17:12 <dminuoso> %  data Two = MkTwo
04:17:12 <yahb> dminuoso: 
04:17:15 <dminuoso> % :k Two
04:17:15 <yahb> dminuoso: Two :: *
04:17:17 <dminuoso> % :k 'Two
04:17:18 <yahb> dminuoso: 'Two :: Int -> Int -> Dat
04:17:36 <dminuoso> % data Three = Three Int Int Int
04:17:37 <yahb> dminuoso: 
04:17:38 <dminuoso> % :k Three
04:17:39 <yahb> dminuoso: Three :: *
04:17:54 <dminuoso> % data Dat2 = Four Int Int Int Int
04:17:54 <yahb> dminuoso: 
04:17:55 <yushyin> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#promoted-list-and-tuple-types
04:17:57 <dminuoso> % :k Four
04:17:57 <yahb> dminuoso: Four :: Int -> Int -> Int -> Int -> Dat2
04:20:13 <dminuoso> In some sense this "lifting" is perhaps oddly phrased. It appears that rather than "DataKinds" lifting things, it exposes them.
04:29:57 <haskeldjiq> guys is there something like
04:30:02 <haskeldjiq> text `contains` "something"
04:30:17 <Athas> Data.List.infixOf.
04:30:33 <haskeldjiq> thanks
04:30:45 <haskeldjiq> yeah great that's exactly what I need
04:30:55 <Athas> Or Data.Text.infixOf.
04:34:06 <absence> dminuoso: i think i get it :) thanks
04:36:27 <m1cl> }
04:36:35 <m1cl> }
05:05:07 <robotmay> How on earth do you match any string in megaparsec? alphaNumChar doesn't do symbols, I just want to match anything until the next token
05:08:33 <yushyin> skipManyTill/skipSomeTill
05:09:13 <robotmay> Can that capture the content too?
05:12:57 <merijn> manyTill/someTill? :p
05:13:18 <yushyin> was just about to mention it.
05:14:49 <robotmay> Haha thanks. Must admit I am not sold on parsers so far, for my use-case. Took me minutes to write a regular expression to do this task in Elixir :\
05:15:25 <merijn> robotmay: What kinda things are you parsing?
05:15:57 <robotmay> Just some log lines from the Heroku log drain delivery, e.g. `83 <40>1 2012-11-30T06:45:29+00:00 host app web.3 - State changed from starting to up`
05:16:01 <merijn> megaparsec has quite some boilerplate to make it easy/possible to write parsers that produce high quality errors. Which may be overkill
05:16:41 <robotmay> It's pretty basic what I want really. Don't care about anything before the timestamp, parse timestamp, return message
05:17:03 <robotmay> Then later on probably parse the message into a usable data structure, e.g. key=value pairs or JSON
05:17:20 <merijn> robotmay: For something like that I'd probably consider using attoparsec which has a much more minimal API that doesn't really try to produce helpful errors (because it's intended for use with machine produced formats, rather than human written)
05:17:47 <robotmay> Ah ok, I'll check that out :)
05:17:50 <merijn> Might not be worth switching now if you already have a bunch of megaparsec stuff, but maybe useful to keep in mind for the future
05:18:05 <merijn> Since you, presumably, already wrote most of that boilerplatey stuff by now :p
05:18:25 <dibblego> there is also the parsers library, which generalises them all
05:18:29 <merijn> robotmay: Can you show what you've got so far and what the comparable regular expression would be
05:18:48 <robotmay> Haha not too much thankfully. Spending most of my time trying to figure out how to even use libraries based on the very confusing docs :D
05:18:58 <merijn> dibblego: It "generalises them all" by making you depend on both attoparsec and parsec, though
05:19:16 <dibblego> ya
05:19:18 <robotmay> Yeah the regex is very simple, assuming you do the date parsing afterwards: /^\d+ <\d+>\d+ (.{25}) (.*)$/im
05:19:49 <merijn> robotmay: Did you go over the tutorial? (Admittedly I haven't, but it looks rather complete)
05:20:16 <merijn> i.e. https://markkarpov.com/tutorial/megaparsec.html
05:20:35 <robotmay> merijn: Yeah. It's almost useful ;) Like a lot of things I'm finding in Haskell so far, it sort of covers everything but also totally misses out on important steps
05:20:46 <robotmay> Like that tutorial doesn't mention how to parse multiple lines at all
05:20:58 <robotmay> I ended up using a CSV parser as a reference for that
05:22:13 <merijn> robotmay: The problem is that once you've written something non-trivial with any of the parser combinator libraries they all feel kinda obvious and it becomes really hard to realise what people don't know :)
05:22:28 <robotmay> Haha yeah I totally get that
05:22:58 <robotmay> I think it's why people have such a hard time in general explaining Haskell concepts to new Haskellers too. What seems so obvious once you know it makes almost 0 sense until that point :D
05:23:27 <yushyin> the hardest thing I had to learn was the fact, that most regex engines to a lot of backtracking by default and parser-combinators like megaparsec do not. So when I tried megaparsec the first time I constantly parsed to much from my input.
05:23:40 <berndl> I think "obvious" is the wrong term. "Familiar", yes; "obvious" no.
05:23:44 <robotmay> Ooh good to know
05:23:46 <merijn> robotmay: I mean, once you get the general idea of "write parser that parses a single line, then just run that with 'many'" it feels very obvious :)
05:23:47 <yushyin> do a lot of backtracking*
05:24:46 <robotmay> To be fair, the only good all-encompassing documentation/tutorials I've done recently were in Elixir. Even Elm has major steps missing from the docs
05:25:00 <robotmay> At least it has a very nice compiler
05:26:42 <robotmay> Just gonna try matching the timestamp/message parts and then I'll paste up my compiler. It's probably very naff :D
05:26:50 <robotmay> *parser, not compiler
05:29:30 <robotmay> Er, how do you match any char? Docs for manyTill say `anyChar` but that's not in scope apparently
05:30:47 <yushyin> satisfy (const True) -- maybe?
05:32:06 <yushyin> robotmay: it was renamed to anySingle
05:32:22 <robotmay> Aaah
05:32:29 <yushyin> http://hackage.haskell.org/package/megaparsec-8.0.0/docs/Text-Megaparsec.html#v:anySingle
05:32:56 <robotmay> I somehow ended up on an old docs link then I think, thanks
05:33:22 <merijn> robotmay: On hackage, you mean?
05:33:30 <robotmay> Aye
05:33:48 <merijn> robotmay: Yeah, Google often links to very old versions
05:33:54 <merijn> If you use Chrome I can recommend: https://chrome.google.com/webstore/detail/hackage-fu/dnpldbohleinhdgfnhlkofpgkdcfcfmf
05:34:07 <merijn> Which warns if you're looking at old docs
05:34:37 <robotmay> Haha yes I've noticed that my learning so far seems to be best served by totall ignoring haskell.org links. I'm on Firefox myself but I may use Chromium with that for now to help ease the suffering :D
05:35:38 <merijn> robotmay: There might be a similar Firefox plugin
05:36:09 <merijn> robotmay: Naah, the solution is to just click "contents" in the top right, which takes you to the package page and then switching to the latest version
05:40:03 <robotmay> merijn: Haha thanks, I hadn't found that
05:41:16 <maralorn> I have a function which takes a list. It will never make sense and be a waste of resources to call it with an empty list. But it will not error. Should I let it take a NonEmpty instead?
05:41:55 <maralorn> Its a library function so maybe someone will need it sometime.
05:47:09 <merijn> maralorn: I wouldn't bother
05:47:26 <merijn> maralorn: "NonEmpty a -> [a]" already exists, so they can just convert before calling your function
05:47:41 <Ariakenom> it would be correct but a bit of a hassle
05:52:11 <Ariakenom> I want to weaken my statement into "It would be correct" the hassle level probably depends
05:54:21 <gauga> hi guys, anyone know why this code results in non-exhaustive patterns error? 
05:54:31 <gauga> numTimesFound x xs = length $ filter (\e -> (e == x ) || (e == swap x)) xs
05:55:58 <berndl> gauga: works fine for me.
06:02:22 <gauga> what am I doing wrong then? it gives me a non-exhaustive pattern error
06:03:01 <merijn> gauga: Can you paste the surrounding code?
06:03:16 <merijn> Because that one can't have a non-exhaustive pattern
06:04:55 <gauga> pairsCount :: Pairs -> PairsTally
06:04:57 <gauga> adjacent pairs
06:09:09 * hackage tmp-postgres 1.23.0.2 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.23.0.2 (JonathanFischoff)
06:10:28 <maralorn> I think the most awesome ide-plugin would be something that looks at the types of a value, that you have declared and gives you, when it can, an info with "I have inferred how the body of this function needs to look like."
06:10:48 <maralorn> It could use something like https://www.joachim-breitner.de/blog/735-The_magic_%E2%80%9CJust_do_it%E2%80%9D_type_class
06:11:22 <merijn> maralorn: Have you seen Lambdu? And "literally everything pigworker has written"? ;)
06:26:53 <maralorn> merijn: No
06:26:57 <maralorn> Looks cool.
06:28:23 <merijn> maralorn: pigworker's entire thesis is on interactively filling typed holes with compiler help :)
06:28:37 <merijn> It's fascinating but...not for the feint of heart xD
06:28:58 <merijn> faint of heart? Someone please patch English to be sensible...
06:29:30 <Rembane> feaynt! 
06:32:11 <bahamas> I had a realization that a function in a pure functional language can be considered a mapping. is this a correct intuition? is it helpful in any way?
06:32:39 <merijn> bahamas: Is it correct, yes. Is it helpful? Maybe, probably not, though :p
06:32:49 <Rembane> bahamas: This is a correct intuition, I think it is helpful, but I don't know if it is in a practical manner.
06:34:59 <berndl> bahamas: that's what people in math mean when they say "function".
06:35:12 <bahamas> berndl: a mapping?
06:35:20 <berndl> Yes.
06:35:44 <bahamas> between the domain and co-domain, I assume. or whatever the terms were for the set of inputs and the set of outputs
06:35:45 <berndl> For example, sin is a mapping taking x to sin(x).
06:35:51 <Rembane> In a more computery way it is a lookup table. 
06:36:48 <berndl> Yep, you can think of sin as a two-column table: an x column (for the input) and sin(x) column for the output.
06:37:32 <berndl> And then you can query it with SQL: select sin(x) from sin where x = pi.
06:37:34 <bahamas> Rembane: yes. you replace the hash function (or whatever you call the function that takes the input and retrieves the output) with any function from your program
06:37:51 <berndl> (I think I took that analogy too far.)
06:38:38 <bahamas> berndl: well, you could a statistical analysis of Haskell code bases and save some outpus for some inputs. then, you could look them up so you don't have to perform the computation
06:38:49 <bahamas> worldwide memoization if you want
07:06:27 * nshepperd1 . o O (select x from f(x) where f(x) = y)
07:12:55 <nshepperd2> Hm, would it make sense to allow typeclass instances of type families if they are marked as INCOHERENT. I just realised this is basically what i am implementing with this type checker plugin
07:13:45 <dmwit> I think basically no.
07:14:45 <nshepperd2> Like, incoherence is afaik the only real danger with writing something like instance (KnownNat a, KnownNat b) => KnownNat (a + b)
07:15:35 <nshepperd2> Because a + b can't be proved to be apart from any other instance
07:16:15 <dmwit> nshepperd2: Perhaps you are looking for ghc-typelits-natnormalise
07:16:37 <nshepperd2> That's what I'm using now
07:16:48 <Putonlalla> Is there an option to have GHC produce less verbose error messages? I'd prefer a single line that says "you fucked up on line $x of file $y".
07:17:07 <dmwit> nshepperd2: Sorry, I meant ghc-typelits-knownnat
07:17:14 <nshepperd2> Yeah
07:18:00 <dmwit> Putonlalla: ghc | sed ?
07:18:12 <merijn> dmwit: Not very helpful when building with cabal
07:18:22 <Putonlalla> Can't do that without breaking GHCi, dmwit.
07:18:22 <dmwit> cabal | sed ? ;-)
07:18:31 <dmwit> ghci is harder
07:18:36 <merijn> Putonlalla: There's some flags to reduce it a bit, but not a lot, sadly
07:18:56 <nshepperd2> But all that plugin really does is define extra instances for KnownNat (who are coherent, but this can't be proved by ghc)
07:18:56 <merijn> It's a shame because GHC's formatting of error context seems to be retarded in some cases
07:19:11 <Putonlalla> It's not uncommon to get hundreds of errors after refactoring, each of which is obvious.
07:19:54 <dmwit> nshepperd2: It gets you (KnownNat a, KnownNat b) => KnownNat (a+b), though, yeah?
07:20:10 <nshepperd2> Yes
07:20:21 <Rembane> Is there a ticket on the issue tracker or is it worth creating one about succinct error messages? 
07:20:43 <Putonlalla> I could do that later.
07:21:13 <nshepperd2> It just seems like this could be a facility the compiler itself could provide, since it already lets you define your own possibly-incoherent instances
07:21:58 <nshepperd2> More convenient to extend by writing instances than writing type checker plugins
07:25:45 <nshepperd2> I guess one problem is that such instances would normally be orphans, which isn't a problem with type checker plugins because putting -fplugin=foo in a file clearly delimits where the instances apply
07:38:05 <ph88> if in the cabal file there is   logging >= 1.3.0  does that match version 3.0.5 too ?  i couldn't find the right doc page in the cabal manual
07:38:30 <merijn> ph88: Yes
07:38:38 <merijn> ph88: Assuming there's no other bounds
07:38:55 <ph88> stack reports this:  logging must match >=1.3.0, but the stack configuration has no specified version  (latest matching version is 3.0.5) 
07:39:21 <merijn> ph88: Stack only finds packages included in stackage snapshots by default
07:39:29 <ph88> i see
07:40:03 <merijn> You need to explicit add any dependencies no in the stack resolver you're using
07:44:56 <sm> under "extra-deps:". https://www.stackage.org/package/logging shows if something is in stackage
07:48:48 <robotmay> I _think_ my parser is almost there, only now it's globbing all the lines in the first parse. Any tips? https://gist.github.com/robotmay/2c93c59f2e51b7c5da7e011e4c21e37d
07:49:21 <robotmay> I thought the sepBy1 bit in pLogs would run each line through the pLog parser
07:49:45 <merijn> robotmay: anySingle is gobbling the newline :p
07:50:22 <merijn> Wait, no
07:50:22 <robotmay> merijn: Yeah, though I thought the pLogs parser would have only given the pLog parser the individual line due to the sepBy bit
07:50:26 <merijn> It's takeRest :)
07:50:52 <robotmay> So I figured takeRest would just be returning the rest of the line, and the pLogs parser would then move onto the next line
07:50:57 <merijn> robotmay: takeRest is, well, taking the rest :)
07:51:08 <merijn> robotmay: Why would you figure that? :p
07:52:03 <merijn> Also your use of notFollowedBy seems weird
07:52:08 <robotmay> I thought `sepBy1 pLog eol` would be separating by newlines, is that not how it works? e.g. in Ruby it'd be like doing `string.split("\n").map(&:parse_line)`
07:52:39 <merijn> robotmay: No, there is no "first" operation
07:52:44 <robotmay> Er, am I using notFollowedBy? :D
07:52:52 <merijn> robotmay: Line 9
07:53:04 <robotmay> Aaah, I copied that from a CSV parser
07:53:12 <robotmay> Don't think it actually changed anything
07:53:23 <merijn> robotmay: "sepBy1 foo bar" first applies parser "foo" to the parser, then "bar" on the remainder, and then repeats
07:53:30 <robotmay> Aaaah
07:53:38 <merijn> robotmay: So if foo consumes your entire document, then it's done
07:53:50 <robotmay> merijn: Gotcha, thanks for clarifying that
07:54:08 <merijn> You probably want, like "takeTill anySignle eol" (or whatever the correct parser for line endings is)
07:55:16 <merijn> But, you know, with less typos >.>
07:56:17 <robotmay> I think I tried that before and it throws an error. Will try again and see what happens
07:57:39 <merijn> oh, I know the problem
07:58:32 <merijn> "takeTill anySingle (lookahead eol)", or alternatively keep using "takeTill anySingle eol" and replace "sepBy1" in pLogs with many
07:58:52 <robotmay> merijn: Ooh ok will try that
07:59:03 <merijn> robotmay: The problem is that "takeTill anySingle eol" consumes the newlines and your pLogs thing tries to consume them *again*
08:00:10 <robotmay> merijn: I _think_ it almost works as `someTill anySingle eol`, except it dies on the last line
08:01:29 <merijn> robotmay: Probably no end of line after your last line of input :)
08:01:46 <merijn> (eol <|> eof)
08:01:48 <robotmay> Haha yeah. I guess make the someTill optional on the last line and do takeRest instead or something?
08:02:18 <merijn> Naah, just check for "eol" OR "eof" like my example above
08:02:54 <robotmay> Rather oddly that gives a weird error, just gonna poke it for a sec
08:03:06 <robotmay> I did try that before and figured I was doing it wrong
08:04:30 <robotmay> Gives this back: https://gist.github.com/robotmay/82b35a101cfaeb4b5ac346533e2509cd
08:05:03 <yushyin> i guess <|> does not work because of the different types of eol and eof
08:05:17 <yushyin> eof is m ()
08:05:43 <merijn> void eol <|> eof
08:06:42 <robotmay> Weirdly gives the same error
08:07:26 <f_n> Hi, I have a function of type (a,a->Maybe a) -> b, and I want to add a counter to it. it is like an unfold crossed with a fold, ie, it produces several values of type `a' (until it reaches Nothing) and each of these is used to generate a value of type `b', as if the resulting list were being folded over
08:08:06 <dminuoso> f_n: Are you sure the type is correct?
08:08:16 <dminuoso> f_n: Because other than bottom that does not appear to have a sensible implementation.
08:08:26 <f_n> does anyone know if there is a nice way to be able to make it be more like (a,Int) -> b -> b than a -> b -> b ?
08:09:08 <f_n> dminuoso: b is supposed to be like IO (), as in, it could just print each consecutive `a'
08:09:29 <dminuoso> f_n: A function with that type lets me, the consumer, pick whatever I want for b. Including Void.
08:09:57 <f_n> oh ok, well we could just take a specific type then, eg IO ()
08:10:09 <robotmay> Urgh, gonna take a break for a bit and come back to this. Thanks for the help guys :)
08:10:25 <f_n> it shouldnt be able to return any possible `b' thats for sure
08:10:57 <dminuoso> f_n: StateT Int ?
08:11:19 <dminuoso> Or perhaps even just `Writer (Sum Int)`
08:11:59 <f_n> yeah, was thinking that might work, but just wasnt sure how to combine it with this unfolding/folding type function
08:12:26 <ph88> how can i find the minimum version of a library if i know which functions i want to use ?
08:12:30 <dminuoso> I dont quite understand what you mean by that "unfolding" function.
08:12:33 <f_n> the original use was for GL which took a value and a modifier which it ran at each frame
08:12:39 <dminuoso> ph88: Try it out? :<
08:12:45 <dminuoso> ph88: Does the package respect PVP?
08:13:09 <f_n> dminuoso, in that the type is dual to the type of fold, it takes the same arguments as unfold
08:13:29 <dminuoso> ph88: A usual answer is, be pessimistic and just tell what you tested it with. It might be work with older versions.
08:13:29 <f_n> but it does not unfold a list, it has an IO () action instead
08:13:48 <dminuoso> f_n: That's called traverse...
08:13:54 <f_n> which is why it seems like its folding at the same time, since it basically accumulates the result 
08:13:59 <yushyin> robotmay: I also try to learn a bit megaparsec and wrote a little parser which just extracts all number strings from the input, wanna see? (I don't know if it is much good or anything) https://paste.xinu.at/jGFh/
08:14:13 <dminuoso> % :t traverse
08:14:13 <yahb> dminuoso: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
08:14:32 <merijn> ph88: I usually just use "whatever the current version I'm compiling against" as minimum version
08:14:48 <merijn> ph88: Can always relax the minimum version later if it works and anyone needs it
08:15:17 <f_n> so then (a,a -> Maybe a) would be `Traversable t => t a'
08:15:20 <merijn> ph88: Also, now that you've felt this pain you know that you should always add @since annotations to functions in haddocks :p
08:15:41 <f_n> im not sure if thats right, since there is just a plain IO () left at the end
08:16:23 <ph88> merijn, yes i have yet to dive into haddock .. do you have any other tips about writing documentation ?
08:16:47 <f_n> i was thinking i could put the Int like `IO Int' or (Int,IO ()) for the carried value of the fold
08:16:48 <merijn> Not really, it always takes me crazy amounts of effort
08:17:08 <f_n> yeah, its not a traverse, since it really does fold up the result into just one value, its a combination of unfold and fold.
08:17:27 <f_n> maybe its just a foldable instance on that type, which is the type taken by unfold...
08:17:45 <siraben> I want to use a list as the monoid in the Writer monad, but unfortunately list append is O(n) in the first argument, what's a good package to replace this?
08:19:09 <f_n> but then thats not really right, since this is just one such function, there could be many, so it does not make a good instance
08:20:25 <merijn> siraben: http://h2.jaguarpaw.co.uk/posts/demystifying-dlist/
08:21:14 <typetetris> is there a 'forgot password' button somewhere on hackage?
08:21:28 <f_n> i guess i want; ((a,a->Maybe a) -> IO ()) -> ((a,(Int,a)->Maybe a) -> IO ()) 
08:21:47 <merijn> typetetris: https://hackage.haskell.org/accounts
08:22:30 <f_n> sorry this seems really confusing, i guess thats why I was asking for help...
08:23:17 <f_n> it just seemed like since it was consuming values it shouldnt be difficult to have it consuming values paired with Int's indicating which position they were
08:23:26 <typetetris> merijn: thank
08:24:48 <f_n> sorry that type above is wrong it could be more like ((a -> IO ()) -> (a,a->Maybe a) -> IO ()) -> (((Int,a) -> IO ()) -> (a,a->Maybe a) -> IO ())
08:24:54 <f_n> ((a -> IO ()) -> (a,a->Maybe a) -> IO ()) -> (((Int,a) -> IO ()) -> (a,a->Maybe a) -> IO ())
08:26:36 <siraben> merijn:  Thanks
08:27:42 <f_n> where this seems to be like consting away the IO () like by using >>, ie (a -> IO ()) is really (a -> IO () -> IO ()) of foldr
08:35:01 <ph88> Anyone know where these .chs files are supposed to come from which this guide talks about?  https://github.com/haskell/c2hs/wiki/Usage-of-c2hs 
08:35:13 <f_n> is there a monad or something that could capture the nonempty-list-like nature of (a,a->Maybe a) so it could be combined with StateT?
08:36:58 <f_n> is that something like a fold state transformer? im confused...
08:37:18 <f_n> FoldableT ?
08:37:25 <jle`> do you have any specific code you are trying to implement?
08:38:00 <f_n> yeah, i want to combine a logging interface with the GL simulate function
08:38:04 <kuribas> the applicative of (s, b) is folding the s
08:38:11 <jle`> you might be trying to describe a more general problem than you actually want to solve
08:38:27 <f_n> so that as it produces new frames it saves them as bitmaps, but it needs the frame number to name them 
08:38:51 <c_wraith> f_n: looks like Moore, roughtly:  https://hackage.haskell.org/package/machines-0.7/docs/Data-Machine-Moore.html
08:39:01 <c_wraith> ....
08:39:05 <c_wraith> great timing!
08:40:43 <merijn> ph88: You write them
08:40:50 <f_n> c_wraith: precisely 
08:41:12 <merijn> ph88: Are you sure you need c2hs, though?
08:41:30 <c_wraith> f_n: but there's an issue with the monad instance there - it's as slow as it promises.
08:42:09 <ph88> merijn, no i was using c2hsc and hsc2hs before .. which didn't require me to write stuff. But when i process a header file it doesn't pick up on includes
08:42:12 <c_wraith> f_n: It's more general than what you want, I think.
08:42:41 <f_n> yeah, i dont need it to be able to return a new machine which contains a new machine returning function
08:42:51 <f_n> :t foldr
08:42:53 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
08:43:05 <f_n> its easier just to consider unfold 
08:43:08 * hackage ormolu 0.0.2.0 - A formatter for Haskell source code  https://hackage.haskell.org/package/ormolu-0.0.2.0 (mrkkrp)
08:43:14 <typetetris> can't hackage use ssh-keys somehow ?
08:43:32 <f_n> but i guess its the Monad instance thats of interest...
08:43:35 <merijn> typetetris: For uploading packages, you mean?
08:43:40 <typetetris> yup
08:43:50 <f_n> actually, wouldnt it just be the same as the [] monad instance?
08:43:56 <merijn> ph88: Do you modify/operate on structs? If you only work on pointers you can just bind things manually
08:44:08 <f_n> something to do with foldable things being isomorphic to lists
08:44:11 <merijn> typetetris: cabal-install supports password manager integration if that helps?
08:44:22 <f_n> unfoldable* ... still confused
08:44:23 <ph88> merijn, it's not my library for which i'm writing bindings ..
08:44:30 <typetetris> merijn: need to check that out
08:44:54 <merijn> typetetris: https://github.com/merijn/dotfiles/blob/master/install/cabal/config#L120
08:45:07 <c_wraith> f_n: alternatively, it's Cofree Maybe a, but the Monad instance there probably isn't what you want either.
08:45:07 <f_n> kuribas: what were you saying about applicative?
08:45:19 <merijn> typetetris: It will read the password from stdout of the password-command
08:45:40 <typetetris> merijn, hmm I'll will see.
08:45:49 <c_wraith> f_n: still, coiter is a fun conversion between the representation you have and Cofree
08:45:53 <kuribas> f_n: Monoid s => (,) s has an applicative which combines s
08:47:39 * hackage sdl-try-drivers 0.0.0.1 - small testing tool for sdl2 and accelerated drivers  https://hackage.haskell.org/package/sdl-try-drivers-0.0.0.1 (typetetris)
08:48:22 <f_n> im still thinking it might just be the foldable instance for that encoding of a list, but the thing is that the list never gets produced, as its GL that calls the (a -> Maybe a) function
08:49:31 <f_n> i guess it needs that to be wrapped in IO () to enable it to have the side effect of saving the frame as a bitmap
08:50:38 <f_n> http://hackage.haskell.org/package/gloss-1.13.1.1/docs/Graphics-Gloss-Interface-IO-Simulate.html
08:51:04 <f_n> basically it has args; model -> (model -> IO Picture)
08:52:11 <f_n> so that is producing a stream of Pictures, and the (model -> IO Picture) can have side effects embeded
08:52:32 <f_n> but then i want to make it be like ((Int,model) -> IO Picture)
08:52:42 <f_n> since i can easily keep track of which frame it is
08:52:59 <f_n> and the side effect of writing a bitmap needs the number of the frame
08:56:24 <jle`> f_n: if you have IO, you already have effects
08:56:28 <jle`> you can use an IORef
08:56:33 <f_n> oh
08:56:40 <f_n> hmm
08:57:14 <f_n> i was thinking since it seems to be basically unfolding and folding at the same time i would need to somehow insert a modified folding function and got confused
08:57:20 <f_n> how would IORef work?
08:57:35 <jle`> myRef <- writeIORef 0
08:57:41 <jle`> then when you need to use it, readIORef myRef
08:58:01 <f_n> ah, you mean like embed the Int in IO
08:58:04 <jle`> but also if you're using gloss then you could just incorporate counter into your model type as well
08:58:13 <f_n> thats kind of the same as writing the Int counter to a file
08:58:14 <jle`> since you have a model updating function
08:58:38 <jle`> sorta, except you don't have to deal with disk issues and stuff
08:58:54 <jle`> it's closer to having a mutable variable
08:59:01 <jle`> like 'int x = 0' in c
08:59:17 <f_n> yeah, i was trying to think in terms of transformer stacks and got confused
08:59:33 <jle`> but, if you're using gloss, you can also just put your Int in your model type because you have a model updating function you can use
08:59:36 <f_n> it seemed like a state trasformer would be used for the counter
09:00:04 <jle`> there are no monads in that function, so no place to put any monads or monad transformers
09:00:13 <jle`> no type variables that are monads, that is
09:00:48 <jle`> but yeah, i'd probably just add the Int to your model type, or if you really wanted to keep it out of the model you can have it in an IORef
09:01:11 <f_n> right, but its kind of like a wierd way of encoding a list, so i thought that was maybe where to get a monad
09:01:12 <jle`> the only type variable in that function is 'model', and that's kind *
09:01:28 <jle`> you could maybe imagine one, but it's not one that would be usable
09:02:08 <jle`> you can maybe have your computation be Model -> State Int Model and then runState that over an Int you save in an IORef
09:02:15 <jle`> using modifyIORef/updateIORef or something
09:02:26 <jle`> but that's essentially just using an Int -> (Model, Int)
09:03:24 <jle`> and in that case you aren't using it as a monad anymore but just a normal function
09:03:36 <jle`> since the updating is in the IORef
09:04:12 <jle`> f_n: but yeah, you can tell that a monad wouldn't be directly useful here because the only type parameters you have are kind *
09:04:28 <jle`> if you have a * -> * kinded type parameter (like ie a monad tranformer) then you can maybe have some fun with a choice of monad
09:04:33 <f_n> the thing is, instead of having ((Int,Model),(Int,Model) -> Maybe (Int,Model)), which is like [(Int,Model)], it seems like it should be possible just to have [Model] since this could be folded over with something that generated the Int during the folding process.
09:05:01 <jle`> f_n: in that case you can just store your [Model] in an IOREf
09:05:11 <jle`> and peel it off at every step
09:05:27 <jle`> models <- newIORef allMyModels
09:05:29 <f_n> no but it needs fusion
09:05:37 <jle`> what is fusion?
09:05:41 <jle`> in this context
09:05:44 <f_n> to do that without clogging up the memory of holding all the frames in memory
09:05:56 <jle`> IORefs are lazy, it wouldn't hold all the frames in memory
09:06:00 <f_n> it wants to be able to garbage collect the previous frame
09:06:33 <jle`> yeah, when you have your step, you'd read the IORef, take the head, use the head (it gets GCd), then put the tail back in the IORef
09:07:25 <f_n> if you passed it [Model] and had the update be tail, then it would just be turning it into a fold (ie, doing the unfold part it normally does in a sperate place)
09:07:47 <f_n> where then you would have to hope it didnt literally try and hold the whole list in memory
09:08:06 <jle`> i mean you know it won't, because that's how lists work in haskell
09:08:13 <jle`> that's like saying i have to hope and cross my fingers when i do something like:
09:08:18 <jle`> > sum . take 3 $ [1..]
09:08:20 <lambdabot>  6
09:08:41 <f_n> right, but this isnt actually using fold, which has a fusion rule
09:08:47 <f_n> sum does
09:08:58 <jle`> fusion isn't the reason why that is lazy
09:09:12 <jle`> @let mySum [] = 0; mySum (x:xs) = x + mySum xs
09:09:14 <lambdabot>  Defined.
09:09:21 <jle`> > mySum . take 3 $ [1..]
09:09:23 <lambdabot>  6
09:09:33 <jle`> fusion plays pretty much zero role in making that work :)
09:09:38 <f_n> hmm, ok
09:09:48 <jle`> that would work without any fusion at all
09:10:23 <f_n> then it seems like the idea is that any time something like GL tries to give a fold+unfold style thing like (a,a->Maybe a) -> IO ()
09:10:25 <jle`> @let myTake 0 _ = []; myTake n [] = []; myTake n (x:xs) = x : myTake (n - 1) xs
09:10:26 <lambdabot>  Defined.
09:10:41 <jle`> > mySum . myTake 3 $ [1..]
09:10:41 <f_n> that it be unfolded elsewhere. hadnt thought of that...
09:10:43 <lambdabot>  6
09:10:49 <jle`> no fusion :)
09:10:58 <jle`> it just comes from the normal semantics of evaluation in haskell
09:11:07 <jle`> the only thing fusion does is remove a potential constant factor
09:11:13 <f_n> still isnt really the nice idea of somehow being able to insert a better folding function into it though, but maybe that was never possbile anyway
09:11:30 <jle`> myFrames <- newIORef $ unfoldr myFunc 0
09:11:46 <jle`> that captures the idea of the whole thing being an unfoldr :)
09:12:03 <jle`> you use the unfoldr to build your model frames, and then what gloss does is read the results
09:12:40 <f_n> i was hoping there was some nice thing to do with functions that had type like that Simulate function, that both do unfold and fold
09:12:56 <jle`> ah no, gloss is very minimal in its API
09:13:00 <f_n> but it seems like they should be avoided, and just folds over lists should be used
09:13:03 <jle`> it's very low-level
09:13:13 <jle`> the idea is that people would write their high-level abstractions over a low-level API
09:13:17 <robotmay> yushyin: Thanks! Will take a look :D
09:13:20 <jle`> and unfoldr is one such high level abstraction
09:13:33 <f_n> which is not as fancy, i thought there could be a new thing
09:14:00 <jle`> the abstraction you use can be as fancy as you like :)
09:14:06 <jle`> it's just that gloss isn't the one that's going to be using it for you
09:14:20 <f_n> but it kind of makes sense since there was no way to get between the fold and the unfold to decorate the values with positions
09:14:30 <jle`> also in haskell we like to choose the less fancy option
09:14:35 <f_n> thanks jle' !
09:14:37 <jle`> if possible
09:14:47 <jle`> np :)
09:15:00 <jle`> if an unfoldr works then i'm not sure why you would want to look for anything more complicated
09:15:06 <jle`> just by virtue of perceived fanciness
09:16:10 <jle`> to me it was always 'if the simple solution works, use it'
09:16:19 <jle`> not 'if the simple solution works, drop it and find a more complicated one'
09:16:53 <jle`> maybe sometimes it's 'drop it and find a simpler one' :)
09:17:39 * hackage tmp-postgres 1.23.0.3 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.23.0.3 (JonathanFischoff)
09:25:52 <glittershark> Is there a known issue with ghc-mod (via haskell-ide-engine) not handling hs-boot files?
09:26:38 <glittershark> getting ghcmod: /run/user/1000/ghc-mod229529/ModuleA229526-598.hs:18:33: error: Can't find /run/user/1337/ghc-mod229527/ModuleB229526-0.hs-boot
09:26:53 <glittershark> er, ghcmod: /run/user/1000/ghc-mod229529/ModuleA229526-598.hs:18:33: error: Can't find /run/user/1000/ghc-mod229527/ModuleB229526-0.hs-boot
09:54:38 <lionrouge> hi !
09:54:51 <lionrouge> what is the best Haskell plugin for Visual Studio Code?
09:55:09 * hackage mmsyn6ukr 0.3.1.0 - Can be used as a musical instrument synthesizer or for Ukrainian language listening  https://hackage.haskell.org/package/mmsyn6ukr-0.3.1.0 (OleksandrZhabenko)
09:55:59 <svipal> just notice there is no `elem` in Data.Text 
10:03:28 <cocreature> svipal: "elem c = any (== c)" is one easy option for implementing it
10:04:18 <svipal> yep, I ended up using any and all, was way easier than the and/or (fmap f) I had in mind
10:04:56 <svipal> wanted to do and (fmap (`elem` list)) text to begin with
10:06:16 <cocreature> interestingly the internal stream fusion representation has "elem" and it looks like "isInfixOf (singleton c)" gets rewritten to make use of that
10:08:10 <cocreature> oh it looks like elem actually existed at some point and got removed in favor of isInfixOf (singleton c) https://github.com/haskell/text/commit/a2a45248e6ce7363cbf99c29896940bdef7e99b0
10:08:18 <cocreature> not quite sure why you would get rid of elem though
10:13:59 <svipal> Yep, that's why I was surprised !
10:19:08 * hackage hedgehog-golden 1.0.0 - Golden testing capabilities for hedgehog using Aeson  https://hackage.haskell.org/package/hedgehog-golden-1.0.0 (felixmulder)
10:38:53 <sicklorkin> Does anyone know where you need to add rtsopts to stack.yaml? I'm following the examples on hpack's github page but they don't seem to work for me.
10:39:35 <merijn> sicklorkin: hpack + stack.yaml sounds like you're confused
10:40:19 <sicklorkin> merijn: doesn't stack.yaml get built by hpack to produce a cabal file?
10:40:20 <merijn> hpack is a yaml format for generating cabal files (which I would personally recommend against using), stack.yaml is a yaml file for configuring your stack resolver
10:40:29 <merijn> sicklorkin: No, that's package.yaml
10:40:44 <sicklorkin> oh. well that would be my problem.
10:40:51 <merijn> sicklorkin: hpack isn't actually a part of nor required for stack :)
10:41:22 * sicklorkin has been down this road with you before :)
11:09:09 * hackage mmsyn6ukr 0.3.2.0 - Can be used as a musical instrument synthesizer or for Ukrainian language listening  https://hackage.haskell.org/package/mmsyn6ukr-0.3.2.0 (OleksandrZhabenko)
11:10:22 <dsal> I was searching around for some kind of   Monad m => Bool -> m a -> m a -> m a   and then I realized that's "if"
11:11:29 <merijn> :t bool -- note that this is a different order than you expect
11:11:31 <lambdabot> a -> a -> Bool -> a
11:12:52 <dsal> Yeah, bool would  also work, but it'd be kind of ugly  here.
11:13:33 <dsal> In the meantime, I can do stuff to my car via mqtt.  So that's nice.
11:13:50 <koz_> Something something Car monad.
11:14:26 <dsal> You laugh...   wheelHeaterOn :: Car CommandResponse
11:21:58 <MaXoS> Hello? I'm new to IRC and Haskell
11:31:16 <maralorn> Is there a canonical function for "Monad m => m a -> SomeTransformerT m a"?
11:31:27 <merijn> eh...lift?
11:31:35 <djanatyn> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#arrow-notation -- how widespread is use of the Arrow extension in GHC on hackage? i've seen at least a couple libraries shadowing proc?
11:31:48 <sarahzrf> i can tell you that i almost never see it myself
11:31:48 <merijn> djanatyn: Not at all
11:32:07 <sarahzrf> that might be a pity, when i think about it, tho
11:32:22 <merijn> djanatyn: Considering I saw a post earlier this week that noted that arrow notation has, apparently been completely broken since GHC 7.10 and no one noticed
11:32:27 <sarahzrf> D:
11:32:29 <sarahzrf> lmao
11:32:37 <djanatyn> yep, i also saw that same post which is why i was looking!
11:32:40 <sarahzrf> i think i saw a post the other day mentioning sth about how it's probably a good approach to "co-do" notation
11:33:04 <sarahzrf> or at least, one which would work for the time being
11:33:07 <maralorn> merijn: ^^
11:33:19 <maralorn> I have not worked with mtl before.
11:33:40 <djanatyn> i'd really like to look at some case studies of solving the same problem using monads and arrows separately, and comparing the strengths of each approach
11:33:55 <sarahzrf> well, arrows are more general
11:34:07 <merijn> Arrows have mostly been obsoleted
11:34:11 <sarahzrf> oh yeah?
11:34:16 <merijn> By Category, Profunctor and Applicative
11:34:23 <sarahzrf> 🤔
11:34:24 <merijn> Which turn out to be more useful
11:37:36 <mycroftiv> speaking of categories, is there anyone who has a take on infinity categories vs lawvere hyperdoctrines vs traditional model theoretic ultrapowers and whether or not the haskell codensity monad can be used to implement some kind of filtered colimit?
11:38:03 <sarahzrf> how are any of those first 3 things comparable :?
11:38:42 <sarahzrf> i'm not terribly familiar with hyperdoctrines, so i can't necessarily speak to that one, but certainly i don't see a clear line between infinity categories and ultrapowers
11:39:00 <sarahzrf> what little i do know of hyperdoctrines, im not sure how they apply to either of the above, tho
11:39:22 <mycroftiv> sarahzrf: i dont really know if they are, theres this line of research on language translations and model theoretic constructions and how we translate between formal systems, and it seems like there is some overall generalization of boolean-algebra set theoretic models in play
11:39:54 <sarahzrf> topoi seem more relevant than infty-categories to that
11:40:27 <sarahzrf> but ultrapowers are not a generalization of set theoretic models—indeed, they are a way of getting new ordinary tarskian models from old ones
11:41:27 <mycroftiv> sarahzrf: it sounds like you have a much more precise understanding of these things, i understand very little of category theory, trying to understand the research connected to ultrafilters and the codensity monad brought me to a lot of math i dont grasp at all
11:41:49 <sarahzrf> ☺
11:42:17 <sarahzrf> i dont know anything about codensity, tho
11:42:19 <mycroftiv> i have some understanding of how you go from ultrafilters -> equivalence classes/ultrapowers and how those relate to models and embeddings in set theoretic stuff...
11:43:36 <sarahzrf> infty-categories are about higher morphisms
11:43:42 <mycroftiv> sarahzrf: http://www.tac.mta.ca/tac/volumes/28/13/28-13.pdf is the leinster paper ive been trying to understand, because we have codensity monad we can use in haskell
11:44:15 <sarahzrf> >the codensity monad of the inclusion of (finite sets) into (sets) is the ultrafilter monad
11:44:17 <sarahzrf> o_O
11:45:02 <djanatyn> this sounds fun and is more than a bit over my head
11:45:08 <mycroftiv> there are a series of blog posts explaining this paper, 4 of them, and in one of them a connection to martin escardo's "selection monad" is pointed out, and this makes sense because there are deep connections between ultrafilters and forcing and set theoretic choice principles
11:45:25 <sarahzrf> well, the haskell "codensity monad" is just for endofunctors on Hask
11:45:29 <sarahzrf> i think
11:45:46 <sarahzrf> whereas that paper is talking about the inclusion of a subcategory
11:46:24 <mycroftiv> yeah there is a difference between the haskell versions of these things and the full categorical abstractions, and trying to understand just what is going on in that regard is an ongoing project
11:46:47 <sarahzrf> i really ought to check out escardo's stuff one of these days
11:46:50 <sarahzrf> it looks really cool
11:47:04 <mycroftiv> its the whole source of this thread for me, it connects to really interesting places
11:47:27 <mycroftiv> ive been working in agda trying to do things based on a lot of his stuff (much simplified) to get a handle on these ultrafiltration/forcing type constrctions
11:48:10 <mycroftiv> its deeply related to bar induction and the boundaries between constructive and classical math and type theories
11:48:19 <sarahzrf> i need to learn some intuitionistic math one of these days—like math by the actual intuitionist school, not just stuff you can do in """intuitionistic logic"""
11:49:23 <mycroftiv> the escardo work related to choice sequences and the topology of compact/searchable spaces and how that is a code level formalization of brouwerian bar induction and it corresponds to forcing in set theory is really cool
11:49:44 <sarahzrf> ^^^
11:50:03 <mycroftiv> the brouwerian idea of the creating subject seems so philosophical and non-formalizable, but it leads to really deep insight i feel
11:50:30 <mycroftiv> because in that light, the indeterminacy of the power set operation on infinities corresponds to the inherent indeterminacy of future choices made by the creating subject
12:02:01 <gnezdo> Hi, I wrote this and can't seem to find a library providing something like it:
12:02:04 <gnezdo> -- | Produces runs of elements that match the given predicate until it
12:02:05 <gnezdo> -- fails to hold (e.g. continuation lines indicated by trailing \\).
12:02:05 <gnezdo> runsWhile :: (a -> Bool) -> [a] -> [[a]]
12:02:05 <gnezdo> runsWhile p as = go id as
12:02:05 <gnezdo>   where go acc [] = [acc []]
12:02:07 <gnezdo>         go acc (a : as) | p a = go (acc . (a:)) as
12:04:18 <merijn> @hackage monad-loops <- this?
12:04:18 <lambdabot> http://hackage.haskell.org/package/monad-loops <- this?
12:05:29 <yushyin> they got kicked by freenode :/
12:12:28 --- mode: ChanServ set +o glguy
12:12:42 <glguy> yushyin: fixed
12:12:46 --- mode: glguy set -o glguy
12:19:14 <dsal> Does anyone use monad-logger?  The API looks a little gross, so I want to know if I'm failing to understand it or something.
12:25:12 <dsal> I'll just brute force it in and see.  There's a bunch I don't like about hslogger, but it runs with a bit of IO magic, so you can log anywhere you can get to IO, which is convenient when you've got a bunch of different threads and callbacks and stuff where there's no other Monad  to carry the logging.
12:26:15 <mycroftiv> sarahzrf: http://www.math.jhu.edu/~eriehl/construction.pdf on limits and colimits in inf-categories and using them to construct equivalences and the view of ultraproducts as a generalizaton of limit and how it captures structure for model-translation, and similar use of filtered colimits in lawvere's constructions was why i thought my initial question might make sense
12:27:52 <mycroftiv> i may be totally seeing cloud-faces based on limited technical understanding, but it seems like there is a common thread of looking at the limiting process of the discrete->continuous transformation as a way of understanding the overall structure of a large collection and translating it to another system
12:28:24 <mycroftiv> based on the generation of equivalence classes
12:29:29 <mycroftiv> in a haskell context, which is obviously more limited and finitary, these kind of techniques seem to translate into recursive search/optimization methods
12:30:36 <mycroftiv> i think some work of oleg kiselyov on optimization in continuations is actually related as well, because of the connection between codensity and continuation monad
12:40:01 <refusenick> I see GHC has support for compiling to LLVM. Can't LLVM be used to generate wasm?
12:44:27 <phadej> that's what WebGHC project tries to do
12:47:11 <refusenick> phadej: Is it still maintained? Looks like wasm-cross hasn't been updated in some time (by Haskell standards)
12:47:38 * hackage pipes 4.3.13 - Compositional pipelines  https://hackage.haskell.org/package/pipes-4.3.13 (GabrielGonzalez)
12:48:59 <phadej> refusenick: well, my wild guess is that asterius ate the WebGHC authors motivation
12:49:44 <geekosaur> I was under the impression theey were waiting for improvements to the llvm backend
12:49:51 <geekosaur> not sure what the status of those is
13:16:04 <fresheyeball> how can I make a random sublist of a list?
13:16:12 <fresheyeball> I have this thing now
13:16:32 <fresheyeball> pickRandom xs = first (toList xs !!) . randomR (1, length xs)
13:16:38 <fresheyeball> and it gets one thing from a list
13:16:49 <fresheyeball> but what if I want a random sublist? as in pick n things from the list
13:16:59 <fresheyeball> and don't pick the same thing twice
13:17:09 <fresheyeball> (by same thing, I mean by index position, not Eq)
13:29:05 <dsal> fresheyeball: are you wanting a shuffle?
13:29:47 <dsal> Though list seems bad for that kind of thing.
13:30:24 <Clint> shuffle and then take a random number of elements?
13:36:30 <Lears> % :t \g l -> [x | (x, True) <- zip l (randoms g)]
13:36:30 <yahb> Lears: RandomGen g => g -> [a] -> [a]
13:37:00 <Lears> I don't usually like list comprehensions very much, but it's nice for this if you want a true (ordered) sublist.
13:37:16 <Lears> fresheyeball: ^
13:42:37 <fresheyeball> Lears: I think that works, if I shuffle then I can also make a random Int and take
13:42:44 <fresheyeball> but the goal is a sublist, not a shuffle
13:43:47 <fresheyeball> sublist order doesn't matter in this case
13:44:12 <fresheyeball> oh wait I see how it works
13:44:21 <fresheyeball> you are chosing True or False each time
13:44:26 <fresheyeball> so it will be a random sublist
13:44:29 <fresheyeball> nice!
13:46:59 <fresheyeball> Lears: what about the new generator though? what if I need to do this more than once?
13:47:36 <ChaiTRex> > filterM (const [True, False]) [1..3]
13:47:38 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
13:48:19 <amalloy> fresheyeball: split the generator first?
13:48:39 <fresheyeball> amalloy: nice! I did not know about that function
13:48:42 <fresheyeball> how lovely
13:49:19 <Lears> Yeah, something like that. Tbh, I don't pass generators around explicitly very often; I'd use something like MonadRandom to handle it for me.
13:55:10 <chewzerita> join #voidlinux
13:57:07 <dimitropoulos> can anyone point me in the right direction on installing haskell-package that has ghc 8.6.5?
13:57:34 <dimitropoulos> *haskell-platform
13:57:57 <dimitropoulos> when I install using `sudo apt-get install haskell-platform` it only gives me ghc 8.4.4 : https://packages.ubuntu.com/disco/haskell-platform
14:11:26 <yushyin> dimitropoulos: you can (and should) just use https://gitlab.haskell.org/haskell/ghcup or stack
14:14:32 <dimitropoulos> yushyin: thanks, I'll try that now
14:24:48 <fresheyeball> ok
14:24:56 <fresheyeball> so lets a say I have a function like this
14:25:17 <fresheyeball> doThing :: RandomGen g => g -> Foo -> (Foo, g)
14:25:22 <fresheyeball> and a list like this
14:25:28 <fresheyeball> foos :: [Foo]
14:25:39 <fresheyeball> how can I apply doThing to each
14:25:52 <siraben> Anyone have a good link to a paper/resource on foldables and traversables?
14:26:09 <fresheyeball> doThings :: RandomGen g => g -> [Foo] -> ([Foo], g)
14:26:11 <fresheyeball> ?
14:26:19 <fresheyeball> is there a way to handle this recursion?
14:26:31 <fresheyeball> I am not happy with what I am writing for this
14:28:57 <ChaiTRex> fresheyeball: Something like: doThings gen [] = ([], gen); doThings gen (x:xs) = let (y, gen') = doThing gen x; (ys, gen'') = doThings gen' xs in ((y:ys), gen'')
14:29:17 <fresheyeball> ChaiTRex: yeah that is kinda like what I was doing
14:29:33 <fresheyeball> but I suspect there is something more elegant, that knows to pass the g into the next round automatically
14:29:39 <fresheyeball> without having to write explict recursion
14:29:48 <ChaiTRex> fresheyeball: You could probably do a fold.
14:31:15 <Raito_Bezarius> Hi, is there any way to measure CPU/RAM consumption for specific Haskell functions?
14:31:23 <fresheyeball> ChaiTRex: yeah, I have
14:31:28 <Raito_Bezarius> (I'd like to do profiling on specific and known in advance lines of code)
14:31:44 <Raito_Bezarius> I wonder if that's something I can trigger inside of Haskell or something which requires an external tool
14:32:18 <fresheyeball> fst . foldl' (\(g,ws) x -> let (w, g1) = doThing g x in (g1, w:ws)) (g, []) 
14:32:24 <fresheyeball> it works, but its ugly
14:35:00 <maralorn> Is there an alias for "pure ()"?
14:35:19 <sm[m]> Raito_Bezarius: quick & easy: there’s a package timeit 
14:35:24 <maralorn> something like "empty" but for applicative?
14:36:31 <sm[m]> called timeit. Next, there’s criterion. Or, I believe you can annotate just certain cost centers and do standard profiling
14:38:37 <Raito_Bezarius> sm[m]: what about RAM consumption? is that feasible?
14:38:45 <Raito_Bezarius> (timeit sounds exactly what I need)
14:39:26 <Raito_Bezarius> criterion sounds even more awesome
14:40:40 <sm[m]> aside from profiling, you could compare the allocations reported by +RTS -s
14:42:21 <Raito_Bezarius> sm[m]: how to do this?
14:44:58 <sm[m]> You build an executable (possibly with -rtsopts ghc flag, but I think not), then run it adding +RTS -s on the command line
14:45:20 <Raito_Bezarius> Alright
14:57:21 <dsal> criterion is nice.  You have to  use it a bit carefully, though.  It'll tell you about how it can complete an infinite loop in 10ns if you do it wrong.
15:01:38 <Lears> fresheyeball: you're just rewriting `mapM`/`traverse` for the State monad. This should be `doThings = traverse doThing`.
15:02:09 * hackage tmp-postgres 1.24.0.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.24.0.0 (JonathanFischoff)
15:04:53 <fresheyeball> Lears: now that sounds right
15:13:09 * hackage tmp-postgres 1.25.0.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.25.0.0 (JonathanFischoff)
15:13:20 <fresheyeball> https://hackage.haskell.org/package/hip-1.5.3.0/docs/Graphics-Image-Processing.html#v:superimpose
15:13:25 <fresheyeball> so this didn't work at all like expected
15:13:53 <fresheyeball> I have an png file with an alpha channel, and it superimposed completely ignoring the alpha
15:14:09 * hackage rainbow 0.34.2.2 - Print text to terminal with colors and effects  https://hackage.haskell.org/package/rainbow-0.34.2.2 (OmariNorman)
15:27:38 <Raito_Bezarius> dsal: hahaha, alright, I don't use any infinite list for now ; I have some Big-O results that I expect, I want to see how much reality is close to theory
15:34:38 * hackage tmp-postgres 1.25.0.1 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.25.0.1 (JonathanFischoff)
15:53:23 <dsal> Raito_Bezarius: Well, issue still applies.  If you're not careful, you won't measure what you think you're measuring.
16:35:21 <crestfallen> hi in the applicative laws, the 3rd one (the textbook says) "when an effectful function is applied to a pure argument, the order in which we evaluate the two components doesn't matter."    x <*> pure y = pure (\g -> g y) <*> x     so I take that to mean that g is an effectful function, correct?
16:36:23 <crestfallen> but g is with a function definition within pure. so what is going on there..
16:36:30 <crestfallen> is *within
16:37:40 <crestfallen> so on the lhs there is no mention of the function
16:38:49 <crestfallen> so I don't know how that equation illustrates this law, or how we know what pure y on the lhs signifies
16:39:14 <MarcelineVQ> the effectful function is x in both cases
16:39:50 <MarcelineVQ> pure (\g -> g y) <*> x   says that should x produce a function we call it g and apply it to y
16:41:00 <crestfallen> ok yes thanks got it. so the law is written in spartan terms, it seems to me... MarcelineVQ 
16:41:50 <crestfallen> so if you could give an example since I don't know if I've seen it in action
16:42:22 <MarcelineVQ> maybe, I think it's it's too verbose to say "when an effectful function is applied to a pure argument, the order in which we evaluate the two components doesn't matter." since it uses a lot of words that a person can misinterpret. it's best to just state the laws as they are, the interchange law states:  x <*> pure y = pure (\g -> g y) <*> 
16:42:54 <MarcelineVQ> * x <*> pure y = pure (\g -> g y) <*> x
16:43:23 <crestfallen> ok someone mentioned the interchange law, a word not used in the book... one moment pls.
16:44:17 <MarcelineVQ> these are the list of laws that I got that name from https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Applicative
16:44:42 <crestfallen> thanks a member used it recently, and I hadn't heard it
16:46:42 <crestfallen> sorry could you check if you have a type (paste?) in that longer rendition of the law you posted? MarcelineVQ 
16:47:07 <crestfallen> typo*
16:47:46 <MarcelineVQ> well, that page writes   u <*> pure y = pure ($ y) <*> u   but it's the same as   x <*> pure y = pure (\g -> g y) <*> x
16:48:09 <MarcelineVQ> since (\g -> g y) is the same as ($ y)
16:48:35 <crestfallen> so the last <*> pure y on the lhs that is for clarification? (sans * that I believe is a typo
16:48:41 <ion> Maybe thinking of it in do notation would be helpful.
16:48:42 <ion> x <*> pure y = do { x' <- x; y' <- pure y; pure (x' y') } = do { x' <- x; pure (x' y) }
16:48:45 <ion> pure (\g -> g y) <*> x = do { f <- pure (\g -> g y); x' <- x; pure (f x') } = do { x' <- x; pure ((\g -> g y) x') } = do { x' <- x; pure (x' y) }
16:49:00 <chewzerita> @2 + 2
16:49:01 <lambdabot> Maybe you meant: v @ ? .
16:50:39 <MarcelineVQ> crestfallen: I don't understand your question
16:52:06 <crestfallen> on your post 5 above, on the lhs you added <*> pure y just before the equals sign
16:52:26 <crestfallen> that is additional to what is in the book
16:52:36 <fresheyeball> I am messing up some very basic math
16:52:39 <MarcelineVQ> What is in the book?
16:52:48 <fresheyeball> I have a Double between 0 and 1
16:52:54 <crestfallen> let me post it:
16:52:54 <fresheyeball> and when it's 1 it needs to be 0
16:52:59 <fresheyeball> and when its 0 it needs to be 1
16:53:04 <fresheyeball> when its 1/2 it stays the same
16:53:12 <ion> 1-x
16:53:31 <fresheyeball> omg
16:54:41 <crestfallen> correction, not on the lhs, but the end of the second rendition in your post:  pure (\g -> g y) <*> * x <*> pure y
16:55:03 <crestfallen> assuming the typo
16:55:45 <crestfallen>  x <*> pure y = pure (\g -> g y) <*> x    textbook rendition
16:56:08 <MarcelineVQ> Oh I see, * notation in chats is to indicate a correction, it's actually a correction of a typo :> "<MarcelineVQ> * x <*> pure y = pure (\g -> g y) <*> x" means "I meant to write x <*> pure y = pure (\g -> g y) <*> x previously."
16:56:34 <fresheyeball> ion++
16:56:40 <MarcelineVQ> because I had left off the x on the line before
16:57:39 <crestfallen> oh got it.. thanks. so we just need know that the that x on either side is being fed as an impure function in pure (\g -> g y)
16:58:21 <crestfallen> meaning this part:   (\g -> g y) <*> x
17:00:07 <MarcelineVQ> that isn't a part by itself   pure (\g -> g y) <*> x   is read as   (pure (\g -> g y)) <*> x
17:00:28 <crestfallen> oh yeah I see you had the substitution on a separate line " * ... "
17:01:11 <crestfallen> copy that thanks, yeah I meant with pure ...
17:02:38 <crestfallen> so it couldn't be any other way: x must be an impure function there. its the only thing to substitute for g 
17:03:33 <crestfallen> ion, thanks I need to look at the do notation approach tonight..
17:06:00 <crestfallen> so the fact that x is impure, if it were pure the order of evaluation still would nt matter right MarcelineVQ ? my point is why does that only handle a case when x is impure?
17:08:51 <ion> It works for all x, whether pure or impure
17:10:24 <MarcelineVQ> for all x that are valid to have as the second argument to <*>
17:11:20 <crestfallen> but its specific to law which handles an impure function, so I'm missing something
17:11:26 <MarcelineVQ> crestfallen: it's not impure, that has a different meaning, so hopefully your book doesn't call it that. which 'that' are you refering to?
17:11:44 <MarcelineVQ> "my point is why does that only handle a case when x is impure?"
17:13:29 <crestfallen> re: my initial post above: when an effectful function is applied to a pure argument, the order is which we evaluate the two components doesn't matter". I'm using impure in place of effectful
17:14:08 <crestfallen> in* which
17:14:11 <ion> In the whole expression there is only one effectful value, there are no effects to reorder
17:14:19 <ion> namely x
17:14:43 <crestfallen> ion no effects to reorder?
17:15:24 <ion> Whether x is on the left or the right side of the <*> can not change the order of effects if the expression on the other side is pure.
17:16:16 <crestfallen> ok fair enough. but <*> is pretty much always ambidextrous so to speak right?
17:17:10 <MarcelineVQ> this law isn't about always :>
17:17:46 <ion> The effect on the left side, if any, happens before the effect on the right side, if any.
17:18:14 <fresheyeball> ok I am losing it
17:18:17 <fresheyeball> https://gitlab.com/snippets/1918214
17:18:27 <fresheyeball> I can not figure out what is wrong with this function, and spending way to much time on it
17:18:59 <fresheyeball> I just want to overlay one png file ontop of another in a manner that respects alpha channels
17:19:14 <fresheyeball> like I pasted on onto a layer above the other in photoshop
17:19:36 <fresheyeball> overlayAlpha is just wrong somehow, and I don't see how
17:19:45 <fresheyeball> I have worked out the math on my whiteboard twice now
17:19:54 <fresheyeball> a is a number between 0 and 1
17:19:55 <crestfallen> well that's what I mean; it's specific to an effectful function x. what do you mean MarcelineVQ ? why does the law specify the effectful function x. so it's unique, sorry I don't understand
17:23:31 <ion> fresheyeball: Is it possible that liftPx2 applies the computation to all four channels including alpha? Also, I think it should be doable without any branching based on pixel values, something like (1 - a) * b + a * o
17:24:15 <ion> (This expression is assuming the alpha channel of b is 1)
17:24:24 <fresheyeball> ion: I am setting alpha to 1 after the fact
17:24:53 <fresheyeball> setPxc pixel AlphaRGBA 1 
17:24:57 <fresheyeball> set's it to 1
17:39:17 <fresheyeball> ha! I got it
17:39:55 <fresheyeball> https://gitlab.com/snippets/1918214
17:40:05 <fresheyeball> ion: want to give removing the guards a shot?
17:40:08 <fresheyeball> this uuuugly
17:41:27 <crestfallen> ok I'm going to spend time on wikibooks ..hopefully the use of the word morphism there won't throw me :)   they use the notation    pure ($ y) with an apologetic note preamble. so perhaps its not easy to teach this, which is a mild relief.. 
17:42:21 <dsal> pure ($ y)    itself doesn't look confusing.
17:43:59 <crestfallen> dsal yeah came across it in member's post for the first recently.
17:44:06 <crestfallen> first time*
17:44:40 <crestfallen> they are using the morphism term
17:44:59 <mycroftiv> crestfallen: you can mentally substitute 'function' for morphism and probably do fine
17:46:19 <crestfallen> mycroftiv, thanks yeah the chapter on functor/applicative/monads in my book is highly regarded, but I'm getting tripped up on every page
17:47:21 <mycroftiv> crestfallen: i think its quite challenging to learn, people want to encourage learning by saying that it isnt that hard to learn haskell and advanced math isnt required, but i think it might be more honest to say its a challenge, but a worthwhile one
17:48:29 <mycroftiv> my recommendation is to try to stay close to the code and play with a lot of examples in ghci and try to write your own small things to see if your understanding is working
17:49:35 <crestfallen> mycroftiv, thanks kindly. the thing the book says is that the "morphism" is effectful, which term a member suggested that was possibly misleading. thanks yeah, what would you use in ghci to see that law working, considering its correct to think the function is "effectful"?
17:50:07 <crestfallen> if you'd say it that way at all
17:51:03 <mycroftiv> i think id have to see particular code under discussion to have a meaningful take on that, and i should also disclose that despite nearly a year of work learning haskell and dependent typed coding and as much math as i can read, im probably still about as confused as you are :)
17:52:01 <crestfallen> a sympathizer !!
17:52:06 <mycroftiv> i can often write code that does what i want, that i have more or less no ability to use the correct type-and-category vocabulary to describe, and i often read papers talking about code constructions that i use, described in ways that i am rather baffled by
17:53:09 <crestfallen> the thing in question was the applicative interchange law : x <*> pure y = pure ($ y) <*> x
17:53:32 <mycroftiv> well that isnt too hard really, the idea is that applicative stuff has a side effect
17:54:19 <crestfallen> but the law is specifically for x as an effectful function, and not any function. I haven't figured out what's what.
17:54:39 <ion> fresheyeball: If you just take the first expression and remove the branches, does it work?
17:55:32 <mycroftiv> crestfallen: here is where i recommend playing with examples in ghci using applicative functors and the <*> operator to see what happens in practice, i dont trust my own 'generic' answer without myself playing with code to check what im saying
17:56:29 <crestfallen> thanks kindly. my cafe is closing. have a great evening/day. mycroftiv 
17:57:00 <crestfallen> yikes! sorry!
17:57:06 <mycroftiv> good luck with the learning cresftallen
17:57:13 <crestfallen> thanks pax
17:57:24 <mycroftiv> im probably gonna have to play with that example myself now that you directed my attention to it 
18:04:46 <fresheyeball> ion: yes
18:04:51 <fresheyeball> how did you know that?
18:04:56 <fresheyeball> teach me your ways
18:05:09 <ion> Because it looked like the right computation independent of whether b < o
18:07:03 <ion> I also got nerdsniped to deriving an expression for blending two RGBA pixels, I didn't verify whether I got it right though. a = a1 * (1 - a2) + a2; c = (a1 * (1 - a2) * c1 + a2 * c2) / a
18:07:44 <fresheyeball> nice!
18:07:46 <fresheyeball> glad to snipe
18:28:39 * hackage tmp-postgres 1.26.0.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.26.0.0 (JonathanFischoff)
18:40:48 <iqubic> Well, I wish succ and pred would loop around.
18:41:33 <iqubic> I have "data Dir = North | East | South | West deriving (Eq, Enum, Ord)" And I'm trying to define "turnLeft :: Dir -> Dir"
18:43:03 <iqubic> I have no idea how to do that, except with 4 pattern matches.
18:43:50 <mycroftiv> i think thats a simple and effective solution, trying to map things to rotations in the complex plane via multiplication by i or something is probably overkill
18:44:10 <iqubic> Yeah.
18:44:15 <ion> Using the Enum instance, integer addition and modulo would work, not very pretty though.
18:44:33 <iqubic> I'm also going to be creating turnRight and uTurn too.
18:44:50 <fresheyeball> lame
18:44:59 <fresheyeball> it looks like `state` in Control.Monad.State
18:45:07 <fresheyeball> wants (s -> (s, a))
18:45:14 <fresheyeball> but System.Random is largely
18:45:19 <fresheyeball> (g -> (a, g))
18:45:37 <iqubic> Oh. Oh that's weird.
18:45:54 <fresheyeball> its just wrong enough to make refactoring this suck
18:46:20 <fresheyeball> is there a version of `state` where the tuple is swapped?
18:46:53 <fresheyeball> I don't like all this g1 g2 g3 random gen book keeping in my code
18:47:29 <ion> I'm pretty sure there's a package with a random monad which is pretty much that.
18:48:43 <fresheyeball> ion: there is MonadRandom
18:48:49 <fresheyeball> but I don't have a monad to transform
18:48:57 <fresheyeball> I just want to use raw State monad
18:51:05 <fresheyeball> oh no I am wrong
18:51:07 <fresheyeball> hmmm
18:54:07 <ChaiTRex> fresheyeball: Isn't there a Random monad?
18:54:31 <ChaiTRex> fresheyeball: Forget what it's called exactly.
18:55:03 <fresheyeball> ChaiTRex: yeah, but it's for an mtl pattern thing as far as I know
18:58:16 <ChaiTRex> fresheyeball: Ahh, OK.
19:00:37 <fresheyeball> oh beauty beyond measure
19:00:49 <fresheyeball> I have purged the ugly book keeping from my code
19:00:56 <fresheyeball> praise the holy Monad
19:01:56 <dsal> iqubic:  https://www.irccloud.com/pastebin/VdRPviHo/succular.hs
19:02:27 <iqubic> Why am I getting a non-exhastive pattern match warning here? http://dpaste.com/30DXAX5
19:02:32 <dsal> It requires Eq, but otherwise does the thing.  I've used it for the same type of thing you're describing.
19:03:40 <iqubic> Wait... The compiler isn't smart enough to tell that I have covered all the cases. I have switched to using otherwise for the last case.
19:04:01 <iqubic> And that works in the way I want it too.
19:04:13 <ion> Instead of recursion with x + 1, how about x + n?
19:04:35 <iqubic> Why?
19:04:48 <iqubic> Also, is that for my move function?
19:04:57 <ion> yes
19:05:19 <iqubic> Oh. I'm so stupid.
19:06:20 <dsal> Make  addPos :: Num a => (a,a) -> (a,a) -> (a,a)      then you can just   (1,2)  `addPos` (0, -3)
19:06:31 <iqubic> That's so much better.
19:07:21 <dsal> iqubic: Are you doing AoC stuff?  This sounds a lot like a file I have open from last year.  :)
19:07:37 <iqubic> This is just a small little library of helpper functions for Advent of Code. It doesn't need to be pretty.
19:08:12 <dsal> I think some people didn't like my succ' and pred' as if it were a form of abuse, but I found it pretty useful for making circular enums.
19:09:44 <iqubic> I've also got both manhatten :: Coord -> Coord -> Int and chebyshev :: Coord -> Coord -> Int too.
19:09:59 <iqubic> Two different ways of computing distance.
19:10:20 <iqubic> manhatten (x, y) (x', y') = abs (x - x') + abs (y - y')
19:10:25 <iqubic> chebyshev (x, y) (x', y') = max (abs $ x - x') (abs $ y - y')
19:11:08 * hackage libarchive 2.1.0.0 - Haskell interface to libarchive  https://hackage.haskell.org/package/libarchive-2.1.0.0 (vmchale)
19:12:14 <dsal> I  should probably do that if I'm going to dig in.  I have some stuff from last year.
19:12:33 <dmwit> iqubic: You can use `case compare n 1 of LT -> ...; EQ -> ...; GT -> ...` to avoid needing an additional case.
19:12:43 <iqubic> I see.
19:12:50 <dsal> Heh, I have 1 through 4 dimensional manhattan distance.
19:12:58 <iqubic> What? Why?
19:13:51 <iqubic> manhatten is dx + dy. Chebyshev is max dx dy
19:14:16 <dsal> Just stuff I needed when  solving last year.
19:14:47 <iqubic> I see. I'll write the 1, 3, and 4 dimensional stuff later when I need that.
19:15:16 <dsal> yeah, looks like I needed 4 on day 25.
19:15:39 <dsal> Man, hopefully not a spoiler, but this function made my life so much easier:    autoBinSearch :: Integral a => (a -> Ordering) -> a
19:15:58 <iqubic> what does that do?
19:16:02 <dsal> It's a binary search.
19:16:06 <dsal> But you don't have to give it bounds.
19:16:13 <iqubic> But how does that help?
19:16:16 <dsal> Just  like... figure it out.
19:17:12 <dsal> Like, if you have a "find the largest less than X" kind of case, you just feed it the one thing and it discovers the bounds and searches within  them.
19:17:29 <iqubic> But that must be hard to write.
19:17:41 <iqubic> How do you discover the bounds?
19:17:45 <dsal> Nah, it was pretty easy.
19:18:22 <iqubic> How do you discover the bounds?
19:18:50 <dsal> This is the whole thing: https://www.irccloud.com/pastebin/KNRwbvFl/autoBinSearch.hs
19:18:51 <ion> I would imagine starting from 1 and incrementing exponentially until you hit LT and then doing a binary search between that and the previous number.
19:19:49 <dsal> Weird, I also have binSearchM, but didn't seem to use it.
19:19:55 <iqubic> I don't see when that would ever work.
19:20:11 <iqubic> Also, I now need binSearch to be defined.
19:20:14 <dsal> It worked on many of the puzzles from last year.  :)
19:20:16 <dsal> Yeah, I already had binSearch.
19:20:33 <dsal> I would just manually poke numbers in a few times.  I got tired of doing it manually, so I wrote autoBinSearch to do the part I was doing manually.
19:20:57 <iqubic> But how does it work? What does it do?
19:21:32 <dsal> I used it on Day 10 last year:  https://adventofcode.com/2018/day/10
19:21:39 <dsal> And day 15 and day  24
19:22:17 <iqubic> Do you have the code for binSearch anywhere?
19:24:32 <dsal> Yeah, but once you get too much of this kit, it's a lot of what you have to do to solve the problems.  :) https://www.irccloud.com/pastebin/tNWiPmk8/searches.hs
19:25:17 <dsal> I wrote this code a year ago and am having trouble recognizing all of it. heh
19:27:16 <dsal> Heh, I wrote unit tests for all this stuff, too.  autoBinSearch is mildly confusing:
19:27:17 <dsal> propAutoBinSearch :: Int -> Bool
19:27:17 <dsal> propAutoBinSearch a = autoBinSearch (flip compare a) == a
19:28:33 <iqubic> So how does autoBinSearch work? Why do you use it?
19:33:08 <dsal> Well, think of a number.
19:33:17 <dsal> Then I guess 0.  You say whether it's higher or lower.
19:33:42 <dsal> As long  as my guess is too low, I keep going higher until I've passed your guess.  Then iI have bounds.
19:37:58 <dsal> That's what the test does there.  Given any number, just use compare to figure out which direction to go.  In actual use, the problems are more complicated.  See problems 10, 15, and 24.  :)
19:38:40 <iqubic> I see.
19:40:08 * hackage MemoTrie 0.6.10 - Trie-based memo functions  https://hackage.haskell.org/package/MemoTrie-0.6.10 (ConalElliott)
19:57:43 <slack1256> How do you declare non-haskell dependencies on haskell projects? Currently I am using nix as a environment setup, but I wonder if there is a pure cabal solution.
20:02:04 <iqubic> I'm almost certain there's a way to write this as a fold or a foldMap and remove the call to toList, but I just can't quite see it.
20:02:05 <iqubic> http://dpaste.com/02TV88M
20:03:17 <iqubic> Can I get some help here?
20:03:36 <iqubic> I think it will need to use something like All.
20:04:54 <iqubic> The All newtype wrapper is what I'm thinking.
20:05:41 <slack1256> iqubic: I am thinking that you will need a `scanr` more than a pure `foldr/foldMap`
20:06:03 <leifm> FoldM with either?
20:07:34 <iqubic> slack1256: How would that work?
20:09:17 <slack1256> iqubic: I am working it out myself. But the idea is that scanr return accumulations at each level, maybe you can separate the conditions on (&&) onto two passes.
20:09:19 <leifm> Fold with a function like `alg :: Maybe (Set a) -> a -> Maybe (Set a)
20:09:59 <leifm> I found that foldM with Either works as well as scan
20:11:34 <slack1256> iqubic: checkout `inits`
20:11:37 <fresheyeball> ok this function is turning out to be hard as well
20:11:42 <slack1256> > inits [3, 9, 11, 29]
20:11:45 <lambdabot>  [[],[3],[3,9],[3,9,11],[3,9,11,29]]
20:11:53 <fresheyeball> https://hackage.haskell.org/package/hip-1.5.3.0/docs/Graphics-Image-Processing.html#v:rotate
20:12:10 <fresheyeball> lets say I rotate an image by radian `r`
20:12:23 <iqubic> fresheyeball: Are you doing AoC prep?
20:12:34 <slack1256> iqubic: I mean `tails`
20:12:37 <fresheyeball> and I have a coordinate on that image (x,y) :: (Float, Float)
20:12:39 <slack1256> > tails [3, 9, 11, 29]
20:12:41 <lambdabot>  [[3,9,11,29],[9,11,29],[11,29],[29],[]]
20:12:45 <fresheyeball> I need to rotate that corridate as well
20:12:50 <fresheyeball> iqubic: what is AoC?
20:12:51 <slack1256> and use notElem on each list
20:13:05 <iqubic> fresheyeball: Advent of Code.
20:13:13 <fresheyeball> oh no I am not
20:13:15 <slack1256> Or a foldr for a dynamic programming solution
20:13:24 <fresheyeball> I am writing a thing to generate data for OpenCV
20:13:28 <iqubic> slack1256: How will that help me?
20:13:35 <fresheyeball> I didn't find anything that works for me
20:13:40 <iqubic> I want this to work on any foldable.
20:13:51 <iqubic> I don't want to restrict myself to List.
20:13:55 <slack1256> Oh, that is really required?
20:14:13 <iqubic> No. It's not required, but it would be nice.
20:14:17 <leifm> http://dpaste.com/28R70QF
20:14:20 <leifm> What about this?
20:14:56 <iqubic> How does that work?
20:15:39 <leifm> err... it doesn't, yet. One secccc
20:16:51 <iqubic> That was my though. Also, I want to return a Bool.
20:18:08 <leifm> Alright it works now: http://dpaste.com/2214XQQ
20:19:18 <iqubic> That doesn't have the type signature I want.
20:19:30 <iqubic> That doesn't even do what I want.
20:20:21 <iqubic> I said I wanted it to return a bool, and not an Either.
20:20:49 <leifm> You can chuck an `either (id False) (id True)` in front which should do what you want
20:21:34 <iqubic> I know. But it still it look worse than what I have. I'll keep thinking about this.
20:21:34 <ChaiTRex> leifm: do  you mean const False?
20:21:49 <leifm> Yeah definitely const not id there whoops
20:24:22 <leifm> Basically `alg` takes in each element, checks if it's been seen, and either returns the element (if it has been seen) or returns the new list of elements that have been seen already (if the element has not been seen)
20:25:03 <leifm> The either monad acts as a sort of 'short circuit' so you don't have to run through the whole list to find a duplicate.
20:27:08 <iqubic> The and in my code also short circuits.
20:27:46 <leifm> what if the list is infinite, and the first item is unique in the list?
20:28:30 <leifm> for example what would `allUnique $ 100:[1 ..]` return
20:28:44 <iqubic> Well, your example is still going to choke on that too.
20:29:12 <iqubic> Also, that would return false fairly quickly:
20:29:32 <iqubic> > 100 `elem` [1..]
20:29:34 <lambdabot>  True
20:29:42 <iqubic> And after that it stops.
20:30:34 <iqubic> But yeah. I'm going to note that this doesn't work on infinite lists.
20:30:37 <slack1256> iqubic: isn't that function just a fancy way to check if all the elements on the list are unique?
20:31:00 <iqubic> Yes.
20:31:09 * hackage tmp-postgres 1.27.0.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.27.0.0 (JonathanFischoff)
20:31:15 <iqubic> Hence the name of the function "alUnique"
20:31:27 * slack1256 feels dumb
20:31:48 <slack1256> Well maybe a recursive formulation on lists isn't right
20:31:53 <iqubic> Why not?
20:32:03 <iqubic> What would be a better way of tackling this?
20:32:04 <slack1256> I would compare the sizes of the generated Set and the length of the list for the finite case.
20:32:25 <iqubic> I see.
20:32:32 <iqubic> But what about an infinite list?
20:32:40 <slack1256> for the infinite case, I don't know, but notElem wouldn't work with infinite list already.
20:32:58 <iqubic> I'm just going to accept this doesn't work on infinite lists.
20:33:12 <slack1256> I mean it partially works
20:33:16 <iqubic> And I'm going stick with what I have.
20:33:36 <leifm> This works well on infinite lists I think? http://dpaste.com/1H118RH
20:33:48 <slack1256> your function works for `[2,2] ++ [3..]` saying it's false
20:34:00 <leifm> Really not sure about laziness/space efficiency though
20:34:08 <slack1256> but it can't never tell a True value on a infinite list.
20:34:20 <iqubic> leifm: That won't work for [1..]
20:34:44 <leifm> I mean lists like 100:[1..]
20:34:45 <iqubic> that will just go on forever and ever, due to the call to the `elem`
20:34:57 <leifm> Where it is possible to give an answer
20:35:26 <leifm> I'll stop splitting my messages across multiple lines, sorry.
20:35:46 <iqubic> Mine also works on infinite lists too.
20:36:06 <slack1256> iqubic: funny enough, you can give a *mathier* answer to your question for infinite list via the boltzano-weistrass theorems for all bounded types, lol.
20:36:25 <MarcelineVQ> leifm: f has to check every element of the list you're building each iteration so it'll get slow pretty quick. the common tactic is to keep a Set of 'seen so far' elements, and ask if our current element is in that Set since checking Set membership is vastly faster than list membership.
20:37:01 <iqubic> MarcelineVQ: I'm not following what you are saying.
20:37:02 <leifm> Sorry that was a bad example, try `1: 2 : 100 : [3..]`
20:37:29 <leifm> I just a list set implementation for simplicity
20:37:41 <leifm> s/just/used/
20:37:43 <slack1256> Which basically says that all bounded infinite sequences have a infinite subsequence that is monotonous and accumulates on a single point.
20:38:23 <slack1256> But for Ints and the like, that has to be a "tail" of a singular value.
20:38:39 <leifm> for me, `f $ 1 : 100 : [2 ..]` returns while `allUnique $ 1 : 100 : [2..]` doesn't
20:39:19 <iqubic> MarcelineVQ: What are you saying I should do?
20:40:06 <leifm> I think they mean something like http://dpaste.com/1H118RH but using the `insert` and `elem` operations for Data.Set rather than Data.List
20:40:21 <MarcelineVQ> yes
20:41:24 <leifm> Would I need to do anything special about laziness? I'm scared that this (http://dpaste.com/1H118RH) would have some sort of space problem?
20:42:58 <leifm> I guess the `elem` call means that isn't a problem.
20:45:11 <iqubic> MarcelineVQ: Can you write a version with Set for me?
20:45:56 <MarcelineVQ> "<leifm> I think they mean something like http://dpaste.com/1H118RH but using the `insert` and `elem` operations for Data.Set rather than Data.List" elem is called member, for Set
20:46:53 <leifm> Just replace all lists with sets, so `insert` becomes `Set.insert`, and `[a]` becomes `Set a`.
20:48:46 <leifm> You shouldn't worry about this too much though. It's just changing one set implementation (albeit a very inefficient one) for another.
20:49:12 <iqubic> Is't FoldM just traverse?
20:49:18 <ChaiTRex> Set is limited to maxBound :: Int elements.
20:49:24 <iqubic> I know.
20:49:27 <iqubic> That's fine.
20:49:46 <MarcelineVQ> mapM is traverse
20:50:46 <leifm> foldM needs a Monad, whereas traverse needs applicative
20:51:01 <iqubic> But both will work here, right?
20:51:37 <leifm> You need the algebra to be able to 'see' the result of the previous computation, so you need a monad.
20:52:31 <iqubic> MarcelineVQ: Set.elem doesn't see to exist.
20:52:51 <MarcelineVQ> Oh, my bad
20:53:08 <leifm> eek, it's called `member`
20:53:19 <MarcelineVQ> If only someone could have warned us :(
20:55:52 <iqubic> Now I have a working version of this.
21:02:47 <iqubic> Is `fmap (const ())` really the same thing as `void`?
21:03:54 <iqubic> It is.
21:03:57 <ChaiTRex> @src void
21:03:57 <lambdabot> void = fmap (const ())
21:04:26 <iqubic> HLint is useful.
21:04:39 <iqubic> It yells at me all the time to improve my code.
21:05:36 <iqubic> It turns out that when my code fails to find a duplicate, I don't actually care about the value stored in the either.
21:35:20 <iqubic> I'm so ready for AoC.
21:36:22 <leifm> Is there a place to share cool solutions?
21:37:54 <fresheyeball> https://hackage.haskell.org/package/hip-1.5.3.0/docs/src/Graphics-Image-Processing-Geometric.html#rotate
21:38:01 <fresheyeball> if anyone wants to look at this
21:38:12 <fresheyeball> I am trying to alter this function
21:38:22 <fresheyeball> so that the source image is
21:38:43 <fresheyeball> (Image arr cs e, (Float,Float)) -> (Image arr cs e, (Float,Float))
21:38:59 <fresheyeball> so that I pass a coordinate in the orginal image
21:39:04 <fresheyeball> and get the rotated image back
21:39:08 <MarcelineVQ> leifm: there's usually a leaderboard join code in the channel topic and some people link their github accounts where they post solutions
21:39:12 <fresheyeball> AND that cordinate back as well
21:39:21 <dmj`> #adventofcode
21:40:32 <fresheyeball> what is AoC?
21:40:38 <fresheyeball> lots of chatter about it
21:40:46 <fresheyeball> I don't understand from the website
21:40:55 <fresheyeball> its just some puzzles?
21:41:19 <leifm> Yeah, one per day. It's meant to be an advent calendar, but for coding puzzles instead of lollies
21:41:28 <fresheyeball> oh fun
21:42:56 <fresheyeball> so I guess people are waiting around to be the first to solve a thing?
21:43:33 <ChaiTRex> Wait, you can submit solutions to the Advent of Code?
21:43:44 <fresheyeball> Idk
21:43:49 <fresheyeball> just learning about it now
21:43:55 <leifm> Yeah, there's a leaderboard
21:44:11 <leifm> https://adventofcode.com/2018/leaderboard
21:44:15 <leifm> From last year
21:50:59 <MarcelineVQ> ChaiTRex: yeah, that's what it's for :D
21:52:06 <MarcelineVQ> There's private leaderboards as well including a haskeller one, it's usually in the channel topic near this time, idk how to share it :/
21:52:51 <iqubic> The haskell leaderboard uses this code:
21:52:52 <iqubic> 43100-84040706
21:53:02 <iqubic> jle` gave it to me.
22:58:56 <greymalkin> Is there a good example of using `streaming` in a bracket-like way?
23:00:05 <libertyprime> Hey guys. Noob speaking. I have made a function (here it is: http://ix.io/23ad). Here is how it works: https://asciinema.org/a/OFRGAtEEG8VTGKk0ntNb1GxPI
23:00:11 <libertyprime> I would like to make this function into String -> String but do not know how. I assume the IO monad will still be involved.
23:02:29 <ChaiTRex> libertyprime: Try converting it to String -> IO String
23:02:34 <greymalkin> libertyprime: It should be `String -> IO String` and you can then remove the last line and the `dateOut <-` portion of the line above (since the last thing returned would be an IO String from hGetContents.
23:04:26 <libertyprime> Awesome! This is what I needed to know. Thanks!
23:04:56 <vaibhavsagar> how do I `-hide-package` on a .ghc.environment file?
23:16:07 <m1scy[m]> wtf is this
23:16:19 <iqubic> This is IRC.
23:16:26 <iqubic> It is a live chat system.
23:16:45 <iqubic> You are currently logged in to the #haskell chat room.
23:17:06 <iqubic> This is the place to ask any and all questions about the haskell programming language.
23:17:14 <m1scy[m]> seems like some lazy ass programming language
23:17:23 <iqubic> Why do you say that?
23:17:24 <m1scy[m]> like
23:18:08 <m1scy[m]> lemme take a closer look at it
23:19:04 <dsal> Man.  It took me a long time to get MonadLogger working and it was a massive, rather invasive change with a bit of unliftio and some fairly difficult types, but it seems OK.
23:19:14 <m1scy[m]> there doesnt seem to be many conditional statements in the syntax
23:20:01 <dsal> There's not a whole lot of syntax, really.
23:21:22 <vaibhavsagar> freenode_m1scy[m]: haskell is pretty lazy
23:21:46 <iqubic> It's more true than he knows.
23:22:17 <dsal> I've benchmarked infinite loops in 10ns.
23:22:32 <iqubic> How?
23:22:32 <ChaiTRex> What is there that's conditional other than pattern matching and if?
23:22:47 <ChaiTRex> (in syntax)
23:23:02 <vaibhavsagar> guards?
23:23:07 <iqubic> I was going to say case statements.
23:23:14 <iqubic> Also, this:
23:23:19 <ChaiTRex> case is just pattern matching
23:23:28 <dsal> iqubic: If you don't use the results, it doesn't take any time.
23:23:59 <dsal> It's one of the problems when you're learning criterion.  What are you measuring?
23:24:16 <iqubic> > [x | x <- [1..], x < 10] -- Conditionals in list comprehension
23:24:22 <lambdabot>  mueval-core: Time limit exceeded
23:24:35 <iqubic> Oh, that doesn't work in the way I want it too.
23:25:04 <iqubic> > takeWhile (x < 10) [1..]
23:25:06 <lambdabot>  error:
23:25:06 <lambdabot>      • Couldn't match expected type ‘a -> Bool’ with actual type ‘Bool’
23:25:06 <lambdabot>      • Possible cause: ‘(<)’ is applied to too many arguments
23:25:22 <iqubic> > takeWhile (< 10) [1..]
23:25:25 <lambdabot>  [1,2,3,4,5,6,7,8,9]
23:25:36 <iqubic> I was expecting the list comprehension to work like that.
23:26:19 <iqubic> But the point is, the list comprehension allows for conditionals.
23:26:20 <ChaiTRex> iqubic: It does, except it has to check x < 10 on everything in [1 ..], which takes a little while.
23:26:53 <iqubic> ChaiTRex: I realized that after lambdabot terminated the infinite loop for me.
23:28:04 <dsal> iqubic: It doesn't know that you won't have smaller values again in the list.
23:28:48 <dsal> > take 10 [ x | x <- cycle [1..7], x < 5]
23:28:51 <lambdabot>  [1,2,3,4,1,2,3,4,1,2]
23:29:41 <iqubic> How does that produce output? And why is it _that_ output?
23:30:29 <iqubic> Like what the heck is that doing there???
23:30:32 <ChaiTRex> iqubic: cycle [1..7] produces [1..7] ++ [1..7] ++ [1..7] ++ ....
23:30:38 <iqubic> I know that.
23:30:50 <ChaiTRex> iqubic: x < 5 filters that to [1..5] ++ [1..5] ++ ....
23:31:02 <ChaiTRex> Oh, 1..4
23:31:09 <ChaiTRex> iqubic: Then, take 10 takes 10.
23:31:09 <iqubic> Why does your filter work, and mine fail?
23:31:34 <ChaiTRex> iqubic: Yours stops producing inputs that pass the filter.
23:31:43 <ChaiTRex> iqubic: This doesn't stop producing inputs that pass the filter.
23:31:52 <iqubic> Huh?
23:32:00 <iqubic> I'm a little lost here.
23:32:22 <ChaiTRex> iqubic: filter (<10) [1 ..] will produce 9 elements and then stop producing elements forever.
23:32:40 <iqubic> Right.
23:32:46 <ChaiTRex> iqubic: filter (<5) (cycle [1..7] will produce infinite elements without stopping.
23:32:47 <dsal> iqubic: It keeps looking for another number that passes your filter.
23:32:53 <iqubic> I see.
23:33:31 <iqubic> > take 5 [x | x <- [1..], x < 10] -- I hope this works
23:33:34 <lambdabot>  [1,2,3,4,5]
23:33:41 <iqubic> Huh???
23:33:51 <iqubic> Now I'm so very confused.
23:33:52 <dsal> Something about a virtue.
23:34:01 <dsal> > head [1..]
23:34:03 <lambdabot>  1
23:34:03 <ChaiTRex> iqubic: It hasn't stopped up forever yet.
23:34:30 <ChaiTRex> > take 9 [ x | x <- [1 ..], x < 10 ]
23:34:33 <lambdabot>  [1,2,3,4,5,6,7,8,9]
23:34:36 <iqubic> Why doesn't lambdabot print the first few results found?
23:34:41 <ChaiTRex> > take 10 [ x | x <- [1 ..], x < 10 ]
23:34:47 <lambdabot>  mueval-core: Time limit exceeded
23:34:58 <iqubic> And it's trying to find a 10th item to take.
23:34:59 <ChaiTRex> iqubic: It's set to produce the error message only if it gets an error.
23:35:24 <ChaiTRex> iqubic: It could probably be written to produce output like GHCi, but it's just not written that way.
23:35:49 <iqubic> > let ones = 1:ones in ones
23:35:51 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
23:36:00 <iqubic> That produces output.
23:36:08 <Lears> > [x | x <- [1..], x < 100]
23:36:15 <lambdabot>  mueval-core: Time limit exceeded
23:36:15 <ChaiTRex> iqubic: Right, but it doesn't produce an error.
23:36:18 <Lears> > [x | x <- [1..], x < 1000]
23:36:20 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
23:36:25 <iqubic> What??!?!?!?
23:36:28 <dsal> iqubic: Your example stops producing output until it times out.
23:36:36 <dsal> > repeat 1
23:36:39 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
23:36:40 <Lears> There. If it finds enough to produce a line of text, it doesn't need to look further.
23:36:44 <dsal> produces output forever, so it can just truncate.
23:36:45 <ChaiTRex> iqubic: let ones = 1:ones in ones doesn't produce an error.
23:37:04 <iqubic> Haskell is wack.
23:37:26 <iqubic> I'm going to have such a good time using it for AoC this year.
23:38:03 <iqubic> I have my small little library of helper functions ready to use.
23:40:20 <dsal> Some of the problems were excessively easy in  haskell last year.
23:40:48 <dsal> The hardest ones were mostly exercises in reading comprehension.
23:41:16 <ChaiTRex> iqubic: I think the reason that repeat 1 or your equivalent code works is that lambdabot essentially does a (take n) on the String of output, so it doesn't exceed evaluation time because the first n characters come quickly (it's not exactly take n, but close enough, I think).
23:42:37 <dsal> > "what does lambdabot do if you just give it a really long string to display?  Perhaps it just does the string conversion and only takes the first few characters in any  case."
23:42:39 <lambdabot>  "what does lambdabot do if you just give it a really long string to display?...
23:43:04 <dsal> > cycle "ha"
23:43:07 <lambdabot>  "hahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahah...
23:43:21 <jle`> it basically gets the result in ghci and truncates the output
23:43:55 <jle`> it runs a little mini-ghci session
23:45:59 <ChaiTRex> > replicate 1000 1 ++ filter (< 0) (repeat 1)
23:46:01 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
23:46:16 <dsal> Now that I've done all the work...  I had    `type Car = ReaderT CarEnv IO` and as part of my MonadLogger conversion replaced IO with (MonadIO m =>) m everywhere.  Is there a way  to express that as a type?
23:48:15 <dsal> Can I use a pattern synonym or something?
23:49:12 <jle`> type Car = ReaderT CarEnv
23:49:29 <jle`> but really if you're going MonadIO/MTL style, you might as well go all the way
23:49:41 <jle`> and just use (MonadReader CarEnv m, MonadIO m) => ...
23:51:16 <dsal> I've just got like, a lot of that.  I was hoping not to say it everywhere.  Most of my functions are tiny:  https://github.com/dustin/tesladb/blob/master/src/Tesla/Command/Alerts.hs#L13
23:52:46 <dsal> The MonadReader constraint seems interesting.  Why would I do that?
23:54:07 <m1scy[m]> what a stupid concept for a programming language
23:54:15 <jle`> dsal: same reason why you wouilkd use MonadIO m instead of IO
23:54:23 <m1scy[m]> wow and my comment got deleted
23:54:26 <jle`> dsal: but also in some cases you "only" do IO, so you can have only MOnadIO m => ...
23:54:39 <jle`> dsal: and also some cases if you "only" do reader stuff, you can only have MOnadReader CarEnv m => ..
23:54:43 <maerwald> ghcjs has no release tarballs? 
23:54:47 <jle`> it lets you pick and choose kinda
23:55:12 <dsal> Hmm...  OK.  That's interesting.  I guess I need to do this a bit more and not look at my exact use case.  heh
23:55:59 <jle`> dsal: but yeah, sometimes people also have like a master type synonym for all the constraints
23:56:11 <jle`> type MonadCar m = (MonadIO m, MOnadReader CarEnv m)
23:56:19 <jle`> but i think this defeats the whole purpose of mtl style in the first place
23:56:34 <jle`> in that case you could write foo :: MonadCar m => ...
23:56:43 <jle`> but the idea of mtl style is you can choose to only use the constraints that your thing specificially needs
23:56:57 <jle`> and normal typeclass constraint unification is the magic that combines your effects
23:57:50 <dsal> Hmm...  I'll consider that.  The main reason I did all that was just to get MonadLogger working.  Quite a yak shave tonight.
23:58:19 <jle`> yeah, moving to MonadLogger m => ... is the first step in mtl-izing
23:58:37 <jle`> you've taken your first steps into a larger world :)
23:58:57 <maerwald> Next step: effects systems xD
23:58:57 <dsal> I'm still not sure I'm using it correctly.  They hint at some ability to <> stuff together that I don't see.  I ended up just using Text everywhere.
23:59:41 <dsal> I've been doing more mtl stuff lately.  It's not bad.  It does feel like a weird path that many people have gone down and left behind, but I have to go through it anyway.
