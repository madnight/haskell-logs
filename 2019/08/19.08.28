00:00:09 <ski> and what's the particular type of this usage of `filter' ?
00:01:28 <jusss> filter . (<=) :: Integer -> [Integer] -> [Integer]
00:01:35 <ski> yes
00:01:50 <ski> and `filter' ?
00:02:09 <jusss> ski: check some list if they <= 0
00:02:41 <ski> the composition will do something along those lines, yes
00:02:45 <jusss> get the new list , which elements which is <= 0
00:03:17 <ski> well, the elements which are `(<=) 0'. iow which are `(0 <=)'. iow which are at *least* zero (not at most)
00:03:45 <jusss> ok
00:03:46 <ski> (so gives the non-negative numbers (non-negative integers, aka natural numbers), in the list)
00:03:51 <ski> but what's the particular type of `filter' here ?
00:04:21 <ski> what is the result of matching the output type of `(<=)', namely `Integer -> Bool', with the input type of `filter', namely `a -> Bool' ?
00:06:03 <jusss> filter now take Integer->Bool as input type and [Integer] as result type
00:06:36 <jusss> no
00:07:16 <jusss> ski: sorry, I don't follow your words...
00:08:11 <jusss> filter's a will be Integer?
00:08:22 <ski> yes
00:08:25 <ski> that's right
00:08:27 <ski> so ..
00:08:32 <ski>   filter :: (a -> Bool) -> ([a] -> [a])
00:08:37 <ski> will therefore become ?
00:08:56 <jusss>   filter :: (Integer -> Bool) -> ([Integer] -> [Integer])
00:10:31 <ski> yes, right
00:11:13 <ski> and so the input type of `filter . (<=)' is the input type of `(<=)', which is `Integer'. and the output type of `filter . (<=)' is the output type of `filter', which is .. ?
00:12:06 <jusss> ([Integer] -> [Integer])
00:12:12 <ski> right
00:12:28 <ski> so the type signature of the composition is
00:12:46 <ski>   filter . (<=) :: Integer -> ([Integer] -> [Integer])
00:12:51 <jusss> yes
00:12:54 <ski> which can be abbreviated as just
00:12:56 <ski>   filter . (<=) :: Integer -> [Integer] -> [Integer]
00:13:13 <ski> in Haskell, which is (of course) what you already said above
00:13:24 <ski> now, here's an example of using this function
00:13:30 <ski> > (filter . (<=)) 0 [13,-8,5,-3,2,-1,1,0,1,1,2,3,5,8,13]
00:13:32 <lambdabot>  [13,5,2,1,0,1,1,2,3,5,8,13]
00:14:05 <ski> so, we feed a number (`0') as input to `(<=)'. it outputs a function that waits for a second number to compare `0' with
00:14:36 <ski> this *function* is passed as input to `filter', which outputs another *function, which we immediately pass a list as input
00:15:33 <ski> the definition of `filter' will then call the intermediate function, the one in the middle of the "pipeline", on every element of that list, and discard those elements where that function yeilds `False' (keeping those that it yields `True' for)
00:15:50 <ski> so, we keep all numbers in the list which are at *least* zero
00:16:03 <ski> jusss : i hope this example makes sense, now
00:16:10 <jusss> ski:yes
00:16:34 <jusss> ski: and about Functor?
00:16:42 <ski> the interesting part here, was that the "intermediate" type was a function type, not a "simpler" type like `Integer' or `[Integer]' or `(String,Integer)'
00:20:45 <ski> hm
00:21:07 <ski> jusss : do you want to hear a Haskell story, or a category theory story ? (or maybe both ?)
00:32:12 <jusss> ski: sorry, busy, I'd like to heard both :)
00:32:35 <jusss> only child do choice, we adults want all :)
00:33:13 <ski> ok, do you think you know the basic definition of what a category is ?
00:33:33 <jusss> ski: not exactly
00:36:19 <ski> should we start with that, then ?
00:36:28 <jusss> ski: ok
00:37:28 <ski> ok
00:37:52 <ski> so, category theory can be seen as an abstract theory of functions and function *composition* (not application)
00:37:54 <jusss> "the absence abstract"
00:38:31 <ski> we know there's an identity function, for every type / (structural) set, in Haskell `id' has type `a -> a', for any type `a', e.g. `Integer'
00:38:52 <ski> each particular choice of `a' will give an identity function, for the chosen type
00:39:08 <ski> so the identity function on `Integer' has type `Integer -> Integer'
00:39:30 <ski> the interesting thing about the identity function, in relation to composition, is that composing with it changes nothing
00:39:41 <jusss> f . id = f
00:39:52 <jusss> id is the unit
00:39:54 <ski> so `f . id' is `f', for any function `f'. and that is equal to `id . f'
00:39:55 <ski> yes
00:40:25 <jusss> monoid (.), id is the unit
00:40:43 <ski> this is similar to `x + 0 = x',`x = 0 + x'. and `xs ++ [] = xs',`xs = [] ++ xs'. and `x * 1 = x',`x = 1 * x'
00:40:53 <jusss> ok
00:41:46 <ski> yes. but if we talk about monoids, then we talk about *endo*functions, so `id' has type `a -> a', for some type `a', and `f' *also* has type `a -> a' (for the same choice of `a'), in those equations/laws involving `id' above
00:42:10 <ski> however, even if `f :: a -> b', then `f . id = f' (where here `id :: a -> a')
00:42:25 <ski> and also, if `f :: a -> b', then `f = id . f' (where here `id :: b -> b')
00:42:41 <ski> and this is *not* captured by the monoid idea (but is similar to it)
00:42:46 <ski> jusss : okay ?
00:42:51 <jusss> ski: ok
00:43:49 <ski> in the monoid case, we also have `(h . g) . f = h . (g . f)' (just as we have `(x + y) + z = x + (y + z)',`(xs ++ ys) ++ zs = xs ++ (ys ++ zs)',`(x * y) * z = x * (y * z)')
00:44:09 <jusss> the associativity law
00:44:25 <ski> and, in the monoid case, this is assuming that `f,g,h :: a -> a', for some particular type `a' (for each choice of `a', we get a different endofunction monoid on `a')
00:44:28 <ski> yes
00:44:45 <jusss> because become a monid, must become a semigroup first
00:44:58 <ski> now, what we do in category theory is we generalize from this monoid case, to the corresponding case that looks like function composition
00:45:00 <jusss> and semigroup has the associativity law
00:45:30 <dminuoso> jusss: Its not about semigroup, its about that monoid requires the arguments and result to be of the same "group of things"
00:45:42 <ski> so, instead of just having "elements" of a monoid, which we can "combine"/"compose". now we have "morphisms" of a category, which we can "compose" -- but *only* if they are "compsable"
00:45:49 <jusss> dminuoso: ok
00:46:12 <ski> in a monoid, all elements can be combined together, using the monoid combination operation
00:46:51 <ski> in a category, each morphism has a "source"/"domain" (you can think "input type"), and a "target"/"codomain" (you can think "output type")
00:47:33 <jusss> ski: what is "the monoid combination operation"?
00:47:56 <ski> and we can only compose a morphism `g' after a morphism `f', yielding a composition `g . f', in case the target/codomain ("output type") of `f' matches (is the same as, is equal to) the source/domain ("input type") of `g'
00:48:29 <jusss> ok
00:49:06 <ski> jusss : in the monoid `(Integer,0,(+))', the (binary) operation is `(+)'. in the monoid `(Integer,1,(*))', it is `(*)', in the monoid `([a],[],(++))' (one monoid for each choice of the type `a'), it is `(++)'
00:49:39 <jusss> ski: yes
00:50:06 <ski> (a monoid is a triple `(M,neut,comb)' of a type / (structural) set `M', an element `neut' (neutral element) of `M', and a binary operation `comb' on `M' (which can combine any two elements of `M' into an element of `M'))
00:52:03 <ski> (well, a monoid is such a triple, that *satisfies* the monoid laws, `forall (x :: M). comb x neut = x',`forall (x :: M). x = comb neut x',`forall (x :: M) (y :: M) (z :: M). comb (comb x y) z = comb x (comb y z)' .. one could write the combination as an infix symbol instead, say `<>', and then the laws would look more similar, syntactically, to what we had above)
00:54:20 <Silent_Alex> how to send the word with the symbol for underscore
00:55:12 <ski> jusss : ok, so
00:55:40 <ski> for a category, we can't just compose any two morphisms (also called arrows) with each other, they must be composable
00:55:47 <ski> instead of writing say
00:55:50 <ski>   x :: M
00:56:03 <jusss> ski: I don't now how we get here, but we start with Functor....
00:56:09 * dminuoso smiles
00:56:11 <ski> to mean that `x' is an element of the monoid `M' (really of a monoid whose carrier set/type is `M')
00:56:30 <ski> jusss : functors comes after categories. one step at a time
00:56:50 <ski> instead of saying that, we say
00:57:00 <ski>   f : A >--->_C B
00:57:05 <ski> or, for short
00:57:06 <ski>   f : A >---> B
00:57:18 <jusss> ok
00:57:35 <ski> where `C' is the category that our morphism/arrow `f' lies in (just like `M' was the monoid that the monoid element `x' belonged to)
00:58:45 <ski> and now we can't just say what category (namely `C' here) that `f' belongs to, we must also specify for each morphism `f' (in our category `C') its source/domain/"input type" and target/codomain/"output type"
00:58:51 <ski> which would be `A' and `B' above
00:59:24 <jusss> ok
00:59:37 <ski> a monoid just "contains" elements. a category "contains" morphisms. but in order to keep track of when they're composable, we also need these "types", which are called "objects"
00:59:50 <ski> so, `A' and `B' above are objects of the category `C'
01:00:16 <ski> now, let's for a moment step back to the endofunction monoid `(a -> a,id,(.))'
01:00:23 <jusss> wait a sec
01:00:27 <ski> ok
01:01:03 <dminuoso> Given some monad M, and some `T -> M X`, how can I turn `M T` into `M (T, X)` in a concise manner?
01:01:06 <jusss> C is the categroy, and C has types A and B, 
01:01:48 <dminuoso> Or is ⌜do t <- a; q <- b t; pure (t, q)⌝ the most sensible way?
01:02:02 <jusss> and C has monoid in it?
01:02:28 <ski> jusss : the concept of a category is a generalization of the concept of a monoid
01:03:28 <jusss> ski: a monoid is a category?
01:03:29 <ski> in a monoid, we can combine any two elements. in a category, we can only compose "composable" morphism. where "composable" means that the "input type" of the "later" morphism equals the "output type" of the "earlier" morphism
01:03:38 <dminuoso> jusss: a monoid is a special case of a category, yes.
01:03:41 <ski> jusss : yes, every monoid can be considered to be a category
01:03:50 <dminuoso> jusss: every monoid is a category, but not every category is a monoid.
01:04:07 <ski> (or, "is a category", if we're being slightly sloppy with our words, for the sake of brevity)
01:04:47 <jusss> ski dminuoso ok
01:07:46 <jusss> in a monoid, "input type" can point "output type" through "later" morphism?
01:07:46 <ski> jusss : let's make a pictoresque analogy
01:08:02 <ski> think of the elemnts in a monoid as small lumps of clay (or something similar), having somewhat different qualities (say color). and you can take two elements, and mold them together into a new element
01:08:08 <ski> you can combine any two elements
01:08:25 <jusss> ok
01:08:37 <jusss> two become one
03:11:13 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org'
03:11:13 --- topic: set by glguy on [Sat Jan 05 07:21:52 2019]
03:11:13 --- names: list (clog cybai ub Phillemann howdoi freeman42x]NixOS zaquest encod3 zargoertzel the_true_potato o1lo01ol1o mikolaj skim_ rruizt laem xff0x doublex MarconM Ariakenom cfricke baskebol` boxscape acidjnk ph88 fendor kubek2k tabaqui iuno samebchase Lord_of_Life jose_zap gehmehgeh DavidEichmann plutoniix Insanity_ chr15 cosimone Zer0xp DigitalKiwi noan housecarpenter thc202 knupfer m0rphism1 danvet kuribas yoneda Silent_Alex spion raichoo ilikeheaps milanj tromp_)
03:11:13 --- names: list (reactormonk ctag1 cynick nfd9001 ggole actuallybatman shiradz mostendocrine Sk01 chele cods dansho alanz DariusTheMede asheshambasta lastmanstanding Amras0000 sword865 sQVe linarcx esph edwardk vlatkoB jneira _vaibhavingale_ cyphase lions[m] esrse echoreply thonkpod EvanR sagax piyush-kurur Unhammer jokester fjellfras poljar1 theDon matej58 pfurla lagothrix felixfoertsch pi__ shutdown_-h_now polman jluttine_ conal MindlessDrone Guest93722 olligobber ciet[m])
03:11:13 --- names: list (grag[m] ircer[m] ookfof[m] fiddeldibu[m] unclechu atopuzov[m] arianvp[m] Grgoire[m] uelen[m] biox[m] jrozanski alko[m]1 SmiVan[m] laniusfnv[m] hsw[m] patonw[m] vpei[m] ldesgoui[m] sielicki wildtrees[m] imposs[m] pagoda_5b[m] aqtusia[m] illandan[m] noteventime krhubert[m] fswalker[m] LasEspuelas Bimmie[m] kumarbis[m] danielbmarkham[m hkimhvyh[m] aruncom2006[m] M2en[m] teej adaizen[m] bgamari andreabedini _janne pie_ MarcelineVQ gabiruh MonkeyNOS yaroot pavonia)
03:11:13 --- names: list (Jesin hive-mind hukyld suppi kAworu dstolfa blazered_ Xeyame lukelau kaol jgt inkbottle iqubic alicemaz xelxebar ravenous_ evanjs sim590 shwouchk davr0s_ davr0s Anthaas involans Lowl3v3l ClaudiusMaximus monochrom danpalmer miklcct carter Lears ralu SCHAPiE s00pcan atomi mudri Sgeo_ raatiniemi megaTherion DTZUZO carlomagno kuttifunk kori Natch Majiir ravenousmoose shafox wonko7 roman4 swalladge _dga sshaaf Axman6 alx741 rsoeldner gentauro nshepperd Sonokinetic)
03:11:13 --- names: list (notzmv hololeap gbellinoz CSP-SOFTWARE kingofmemes droplet AGmotive[m] mkoenig hc sdrodge ziyourenxiang jb55 dysfigured Rama[m] orzo tomboy64 cantstanya andreas303 klntsky phreedom khisanth_ mceier johnw hegge revprez_anzio nshepperd2 nshepperd1 jakalx acarrico lassulus tv JoelMcCracken amb007[m] saml carif luite seanparsons theorbtwo Neo-- Saulzar_ chin-tastic n3t daGrevis dennisb nahra ruffy_ cp- nesqi zfnmxt laith1[m] phaul lemmih totte AWizzArd Fischmiep)
03:11:13 --- names: list (DTZUZU thunderrd_ ziman restrictedchoice diginet abra0 reorder_ ephemera_ atk bydo justanotheruser hiptobecubic Vq Fubar^ dTal edwtjo devalot unlink2 pyan Wamanuz stepnem juri_ nisstyre gienah_ flux fliife sukbeom tombusby amiri marble_visions hovgaard[m] kini fantasti` noCheese puffnfresh Seich BoneTone marmalodak mnrmnaugh Tourist coddinkn Rich[m]11 cbarrett atraii jrm avn Rudd0 Neuromancer tlax mjuad no-n moldybits dolio Deadhand rom1504 fionnan nekomune)
03:11:13 --- names: list (srnty jlvvlj[m] goulix haasn nicoulaj jle` hvr TimWolla petermw thaumavorio a3f kyleondy[m] NinjaTrappeur keep-learning[m] quaestor glguy violeta wagle scal Ekho jchia RusAlex pent aetherfreak zekt srk dolanbatar Adluc drbean_ nil m4lvin Klumben xacktm SolarAqu- cheers Moyst bartavelle moobar graingert theNeuron barrucadu drewr systemfault bolverkr hongminhee elcaro petercommand eagleflo markus1189 nullifidian caasih aidecoe w1gz bjs m1dnight_ i7c sicklorkin)
03:11:13 --- names: list (gonz_ mountaingoat remexre rann stux|RC nyuszika7h pothyurf[m] yur3shmukcik[m] betz[m] ist5shreawf[m] cawal[m] jeeg[m] etjet[m] cesar[m] EuAndreh[m] contrun[m] mat8913[m] e godva[m] jak[m] josef[m] somni[m] wuxianhuiyi[m] wrunt[m] boistordu pineapple[m] M0ddba11[m] thekyriarchy jonreeve[m] GNULizard[m]1 Hanma[m] Artifth[m] fulgjon kaychaks[m] ghastfilms[m] eyenx[m] simbergm vikraman NickHu1 cbg[m] yoltid[m] ad5twoknebor[m] avocado derberg[m]1 runningriot9[m])
03:11:13 --- names: list (hans[m]5 ppseafield[m] whoops periapseez[m] Brio[m] iarp[m] wobbol[m] peter-js[m] papazeus[m] Chromad[m] pong vigilian[m] ilmu[m] steshaw[m] arturo[m] MonsieurArcher[m reedhhw[m] ovigren[m] hjoest[m] Jonathan[m]2 zopsi[m] Guest63612 EmilKarlson alxev[m] zmlww[m] natmac[m] gandi[m] gspia[m] ajirx[m] bee[m]1 lukasubo[m]1 yi[m] lmolr[m] miseenplace[m] likliklik cosson[m] joe[m]31 sayukimans[m] tops[m] aloiscochard[m] charliebucket[m] midi[m] Ekho[m] aearnus[m])
03:11:13 --- names: list (cepxuo rowan[m] potato44[m] roberth lapav[m] mobile_x[m] reconmaster[m] bkl[m] nolep[m] oniani[m] xlogan[m] GreenKarm[m] roninkaizen[m] tomtau[m] macerbi[m] iceychris[m] d1mur4tdj[m] torkel[m]1 nartir[m] veeee[m] nonlinear[m] freu[m] coil[m] iantownsend abbe[m] suppenkasper[m] hifutakiko[m] benzoid[m] undu[m] steamedbun[m] dag[m] fgaz siraben fiberpunk[m] humanwire[m] DenisLehmann[m]1 ClownMaster[m] lierdakil[m] Godel[m] atpotts danielemarsella[ beaky)
03:11:13 --- names: list (nullheroes[m] dustyp[m] souldev[m] tmallard[m] laniu[m]1 JulesRen-George4 Mesa[m]11 markus[m]21 kitsune[m]1 josiah_sama rihardsk[m] Richy[m]1 MerlinGttlinger[ Guy[m]1 mattia[m] sriehl[m] buggeas40d[m] PotatoRick[m] dumuzid[m] sm[m] blakec[m] labs[m] davex32[m] stan[m] vaibhavsagar javjarfer[m] spacekitteh[m] sergiotarxz[m] sylvie[m] ninjatrappeur[m] mithrandi[m] friedm[m] domenkozar[m] hdurer[m] jonge[m] tswett[m] mujx[m4 infinisil masaeedu[m] dude[m]1)
03:11:13 --- names: list (corin[m] aquarial[m] ShujaRafi[m] themsay[m] JoGoSi[m] thekyriarchy[m]1 gkobeaga[m] gentlehelm[m] jak[m]1 maigel[m] nh2[m] matrixyz[m] WeiTang[m] krowlan3[m] sudorebootsudor4 shiroeni[m]1 Syllo[m] jhgarner[m] neat72[m] Vincent[m]2 jesusvega[m] gswuichet[m]1 dlilja[m]1 jumzi[m] edwel[m] corin[m]1 aitzol[m]1 buster528[m]1 deikatsuo[m] jwerner[m] unitymember[m]1 vespuccy[m] peel Pete[m] dxml[m] Surgeon[m] luisjira[m] intellection3to3 vancha112[m] themadman[m]1)
03:11:13 --- names: list (PoopSick[m] lihram hogarth[m] Orbstheorem[m] Kenneth[m] asonixDogHeThey[ luftmensch[m] tempaccount1[m] brandon123[m] jochens[m] glothit7ok[m] giuseppe[m] schum mssx89m[m]1 inflationova[m] eckt[m] dice[m]1 imp0s5ible tuxsoy bt[m]1 georgescratcherd null14[m] zorkedon[m] rainbyte[m] gmips[m] Noughtmare[m] Tom[m]7 amerocu[m] pietromrtn[m] tarigo[m]1 Alec[m]2 GhostofaConsole[ Mougan[m]1 vkleen tejok[m] foxadee[m] brevalda[m]1 adziahel[m] kerru[m] excel_gate[m])
03:11:13 --- names: list (kylos[m] alibabzo abdolence[m]1 asayers[m]1 Godslatestgift[4 MartinKlimi[m] GNULambda[m] Cenion[m] yrid[m] PrimeSeeker[m] M31violet13[m] rahduro[m] beatricejensen[m aquarial triskeon[m] sphalerit anton-latukha[m] JoelMcCracken[m] texpat[m] mmynsted[m] pschooom[m] sepp2k phanimahesh[m] pebeto[m] apurvapavaskar bobach[m] weebull[m] m00n[m] sghir_med[m] odd13[m]1 abc123zzz[m] M|GNUisnotLinux[ joenase[m] alexfmpe[m] ChristopherBurg[ unrooted[m]1 Lite[m] vorbex[m])
03:11:13 --- names: list (jibby[m]1 supersweetsweet4 xethrog42[m] nybble41[m] soaoaig[m] afontain[m] AMlivinfree[m] PonyLoop1000[m] olmvnec[m] twom[m] jwaksbaum[m] tindvik[m] apx[m] talvdav[m] pqwy[m] thosgood[m] ineff testacc3[m] n0ma_d[m] NickHu gmind[m] qasim[m] triste[m] cjwelborn PhilipWhite[m] SFL[m] vsts[m] teaknow[m] link2xt[m] jibby kaiyou[m] Marceline[m] jg[m] jdks[m] kai10[m] heyakyra[m] dopplergange MichalLaskus[m] imdoor[m] korlaplankton[m] gd2398[m] JakeO[m] deklund[m])
03:11:13 --- names: list (nalix[m] ludovicdanjoumad johanejg[m] admdch[m] mouse008[m] cale[m] cjskaggs[m] Paavo[m] beaverfever[m] Cloud[m] maxmaguire[m] kicker22004[m] grorg[m] Kimani[m] k4l1gr4[m] AkikoHimenokoji[ Kit[m] actartis[m] limabeans[m] AaronWeiss[m] keith[m] supersven[m] max3raza[m] chris[m]15 jennie[m] godzilla[m] alana[m]1 cyclops19[m] tinwood S007 rgh[m]2 Hakan[m] ManiacTwister paulus[m] scheming_around pdgwien pierrot averell jammar typedrat Ericson2314 kubrat nckx)
03:11:13 --- names: list (Bigcheese hexagoxel Cale nurupo sputny[m] xalek[m] haskelllisp[m] luminousnine[m] alex[m]14 MarquisKurt[m]1 akt[m] GregKNicholson[m kahuna[m] hackeryarn[m] Wizek[m] shanesveller[m] vk3wtf[m] javbit[m]1 tkots[m] mujx[m]1 vars[m] popo[m] shachiku[m] petrolifero[m] rinor[m] kapilp_ cemerick jorj nopf __4matter_ ski APic Jonno_FTW Nik05 furnost Eliel flogfr ecx86 runawayfive RoguePointer suzu rootmos zv stvc pacak stefan-__ Flonk gargawel_ shapr digia CindyLinz)
03:11:13 --- names: list (SlashLife qz swater rotaerk sbrg catern Ulrar arianvp Drezil charukiewicz dilinger wtw Tene ByronJohnson alp gspia [exa] arw scinawa jrslepak Someguy123 daissgr Ornedan cheater uberj dustinm- glamas opqdonut Taneb delYsid Bergle_1 kjak thjread oleks kark Putonlalla mimi_vx cchalmers Foritus dmiles hpc davean rodgzilla deni locallycompact connrs_ freusque Batholith sigmundv- travv0 ynyounuo Squarism jtcs Dykam kqr lpsmith qzo srhb tstat mupf nivpgir_)
03:11:13 --- names: list (jdevlieghere beka dyl_ reyu bollu noko_ DDR shadowdaemon SquidDev clynamen_ maerwald ftop divVerent Profpatsch sarahzrf gluegadget cheshircat vimto PtxDK erikd sw1nn runde benwr_ jackdk terrorjack__ RecursiveG koankeeper kraem ZoFLo cocreature ammar2 PHO c-rog dredozubov noctux apeyeoux _guios energizer_ Sparadox nonzen adamse ocharles lstdgtfp jbetz johnstein wayne deu evilmonads bcmiller fr33domlover tristanC bdw sm asm89 tsani Intensity Athas lugh heath)
03:11:13 --- names: list (zerokarmaleft jol madnight chindy a3Dman mxf thebnq implementation Jello_Raptor statusbot bsima xtsee flebron dan64 sea-gull Jacoby6000 michalisko jonge Remavas tsahyt jzl niklasb_ UserOO7 betawaffle sqrt2 dxtr mccoyc dave_uy DwarfMaster cyberlard sudden acro joeytwiddle iron_houzi markhuge jinblack djanatyn anderson avp sssilver luigy geal eldritch exio4 carbolymer coldpress Aleksejs [df] connrs- gambpang gsingh93 michalrus Phyx- exarkun Rembane bob_twinkles)
03:11:13 --- names: list (simon Heffalump greeny__ AkhILman Firedancer_ canta mikolaj_ Arguggi jvanbure TommyC stilgart Unode ion otulp waskell hjozwiak ap5 MatrixBot3 wadadli e2 artem Mo0O pcoutin rodlogic tms_ enemeth79 raoul troydm bind sterni rzmt wraithm telser xarian sdx23 mniip greymalkin seliopou jonatan a7250ag styledash ft fryguybob so M2tias mmaruseacph2 immae subfacto1 apoc kipras`away cross Zemyla Maxdamantus ereu lyxia gothos phadej zenzike Logio freeside cjay- spoonm)
03:11:13 --- names: list (polux7 abuss saidinwot1 sandman13 bengt_ bendo _ht Entroacceptor adadelta malthe bbear_ moocow_ duairc Robin_Jadoul Chousuke albel727 lkurusa Nikotiini oeblink Vtec234 yahb jix drewbarbs datajerk Sose Niamkik dqd Arahael rosalux sobhan PlasmaStar adamCS Deewiant exferenceBot lortabac bcoppens crooked d3lxa adarshaj Xandaros wz1000 fiatjaf pharaun kosmikus tchakka fiddlerwoaroof blackdog hodapp haveo johs pasukon Guillaum dfordivam ullbeking drdo JSharp koz_)
03:11:13 --- names: list (krystianbajno tureba Igloo epta zymurgy vktec yumh codedmart andromeda-galaxy Cathy nitrix myme topos cjh` lambdabot int-e mulk rotty micro abrar w1d3m0d3 forell Cthalupa zzz raek Bish bbear TMA pingiun theophil893 kav jwynn6 atle catsup ycheng gregberns lowryder Guest69260 mrus hsiktas Kneiva PierreM Tspoon_ mjrosenb jameekim relrod saurik bwe ambrosia_ SegFaultAX intelux matheus mikeplus64 Forkk arsdragonfly Hotbees Enigmagic bspar lexi-lambda haroldwu)
03:11:13 --- names: list (Guest39039 agrif infandum NightA typetetris_ PoliticsII_ idupree2 amatecha_ ab9rf tazjin nlofaro_ mitchellsalad_ eacameron phaazon thi_ jophish dsal_ azahi dumptruckman dani- ekleog absence Kiruwa dh statusfailed s94a84d2e wildsebastian VSpike jackhill adius silver_needles d0liver ghuntley metalrain tabaqui1 ebutleriv J_Arcane teehemkay affinespaces darthThorik benl23 ajmcmiddlin EduardoBautista runeks georgew kloeri solarus _flow_ sivs lurkless t36s jmsx)
03:11:13 --- names: list (vjoki twk- fiQ2 aristid amuck phlym leah2 Adeon Geekingfrog defanor vqrs dequbed akermu copypasteque maralorn uwap mingc lsix ryjm TallerGhostWalt_ liif newhoggy dexterfoo nh2_ riasue_ mjlee integral SrPx_ sebastianrkg verlet64 rootnode_ sethetter Jon Tristan-Speccy spamlessj Guest81022 ProofTechnique rizary_ dmj` cyjiao__ AndreasK tolt ibloom higherorder lightandlight spinda kip mankyKitty raid @ChanServ grumble @Sigyn nikivi bitonic alunduil iravid Lermex)
03:11:13 --- names: list (tehidiot epicallan Kamuela monad_cat alexelcu bradparker winny linoge nkaretnikov Nascha entel dpn` jsatk fredcy- hodlwave_ glowpelt trucy natim87 rubik sphalerite Remy^ yushyin obfusk__ Jaxan Blkt amosbird feuerbach_ glowcoil banjiewen mpickering rajivr___ quarters seventh__ michaelpj interruptinuse PyroLagus zabracks nuxdie Randy ryzokuken feepo unsymbol morgib dukedave nbouscal duncan Jabbslad joel135 elvishjerricco sebhoss sgraf simony AfC billstclair)
03:11:13 --- names: list (refreshing_drink ephemeron fingerzam rslima___ xnyhps heyj datapup_ sis7 jlpeters Firedancer raoulb devurandom srid Konehaltia jonrh scav Shun131 coot alexknvl NemesisD casdr_ ixian Ferdirand milessabin liquorice paf31_ edmundnoble christopher jesyspa aib bjobjo stylewarning bananagram `slikts mstruebing dxld griddle dgpratt bs zxrf m-renaud sclv kyagrd__ jetpack_joe Peter_Storm abbe Reisen lieven _6a68 xyggos tomjaguarpaw scivola dongcarl Netwolf andyo nyaomi)
03:11:13 --- names: list (Chobbes jstolarek hackage Digit recj _ashbreeze_ boj ysangkok dmwit c_wraith dibblego tnks angerman vk3wtf tdammers xstill dixie_ Clint tomku obiwahn strangeglyph Paks bandali pingu_ urdh dcoutts earthy hiredman DustyDingo lispy sud0 Ankhers comboy h30 Meanirelli ent tA- hsyl20 klugez mrsbear lavalike andjjj23 joeyh Nevoic yorick robogoat bitemyapp koala_man Annihitek Guest6007 jdt monokrome tumdedum noexcept_ crtschin_ arkeet` chirpsalot meck aldum)
03:11:13 --- names: list (keep_learning ahri xplat jlamothe s4msung leothrix rembo10 yitz Tuplanolla Ckat cgfbee tessier PragCypher valdyn sellout- net4all gilbertw1 aesi irclogger_com dminuoso Twey enragedjam vin-ivar sms Ranhir aplainzetakind jfredett joehillen Ring0` Mon_Ouie infinity0 lachenmayer nibbling_ mtjmullen brisbin umachan Hijiri pdxleif dashkal habbah Ke Philonous thallada stiell cpape lemald __name__ loc rkrishnan vodkaInferno chivay MasseR)
03:11:38 <Phillemann> Okay, you convinced me to at least take a look at it again. My API is extremely simple, so maybe I'm lucky.
03:27:40 <nbouscal> I'm in the middle of converting my production web app to PostgREST and am super happy with it, especially for simple APIs
03:28:14 <nbouscal> Haskell code is great but no code is better :)
03:28:21 <ClaudiusMaximus> is there a way in cabal to test for pkg-config --modversion to do conditional compilation (eg, support newer features if available)?
04:01:38 <hvr> ClaudiusMaximus: kinda; there's `pkgconfig-depends` via which you can impose constraints on the modversion
04:02:05 <hvr> ClaudiusMaximus: so you can control the setting of an automatic cabal flag depending on the version of modversion
04:03:25 <hvr> and once you can do that, you can use on of the ways to perform conditional compilation (e.g. via CPP, or also at the .cabal level by swapping out modules)
04:08:43 <ClaudiusMaximus> hvr: cool, i think i can get that working
04:08:46 <ClaudiusMaximus> hvr: thanks
04:10:44 <ClaudiusMaximus> but i guess it is a bad thing to make the exposed API depend on pkg-config modversion?
04:11:03 <ClaudiusMaximus> because flags can't be depended
04:54:25 <boxscape> Just discovered that the formatting tool brittany only indents `where` in a function by half an indent (and the line below it by another half indent, so a full indent together). Is that common practice? I don't think I've ever noticed it anywhere
04:57:44 <boxscape> i.e. like this https://i.imgur.com/A4mMoe0.png
04:58:07 <boxscape> with only one space in front of where and an additional space before the following lile
04:58:10 <boxscape> s/lilie/line
04:58:11 <hpc> i do it sometimes
04:58:16 <boxscape> okay
05:01:06 <hexagoxel> boxscape: it is configurable inline via "-- brittany { lconfig_indentWhereSpecial: False }" or the same field in the config file
05:01:20 <boxscape> ah, that's good to know, thanks
05:05:53 <boxscape> hexagoxel Overall I'm impressed by it fwiw, nice work
05:07:57 <hexagoxel> thanks!
05:27:42 * hackage hs-rqlite 0.1.2.0 - A Haskell client for RQlite  https://hackage.haskell.org/package/hs-rqlite-0.1.2.0 (kderme)
05:31:39 <fweht> its fascinating that monads are just monoids in the category of endofunctors...  monoids always deemed me as simple object, but it took me some time to get used to monoids...  is it because the definition of monoids in monoidal categories cannot speak about objects and is therefore more intricate?
05:31:52 <fweht> anyway, not really a question, just wanted to share this feeling ;)
05:32:33 <fweht> s/get used to monoids/get used to monads
05:33:04 <ski> there's monoids, and there's monoid objects in monoidal categories. monads are monoid objects in particular monoidal categories
05:33:27 <Cale> fweht: There's a generalisation of the definition of a monoid, so that it applies not just to the (monoidal) category of sets, with the cartesian product as the tensor product on objects, and a one-element set as the unit object, but to other monoidal categories as well
05:33:54 <Cale> If you look here, you can see that definition: https://en.wikipedia.org/wiki/Monoid_(category_theory)
05:34:06 <fweht> Cale: yes, i meant this one!
05:34:10 <ski> so "monads are just monoids in the category of endofunctors" should more accurately be "monads are just monoid objects in the monoidal category of endofunctors (equipped with functor identity and composition as the monoidal structure)"
05:34:19 <fweht> ski: i see
05:34:38 <Cale> If we replace tensor product with Cartesian product, and I with some one-element set, and take the objects to be sets, that's a definition of a monoid
05:35:08 <boxscape> can you have non-monoid objects in a monoidal category?
05:35:22 <ski> you i suppose people say "monoid in category `C'" as short for "monoid object in the monoidal category `C', with monoidal structure being specified in context, or taken in the most obvious way"
05:35:22 <Cale> yes
05:35:42 <Cale> If instead, we take the objects to be endofunctors on some category C, and the tensor product to be composition of functors, and the arrows to be natural transformations, then it becomes the definition of a monad on C.
05:36:07 <Cale> I the identity functor as well
05:36:14 <fweht> Cale: yes!  i got that, i was just amazed, that you get from the definition of a monoid to the definition of a monad so easily (maybe the definition of monoid object is the non-trivial part)
05:36:47 <fweht> Cale:  but if i just look at the definition of monoid object and think about the category of sets, it seems pretty straightforward still
05:37:27 <ski> boxscape : an object being (taken as) a monoid object isn't a property. it's not yes/no. it's structure. so "non-monoid objects" doesn't really make sense. "monoid object" means "object, and also blahblahblah"
05:37:57 <boxscape> I see
05:38:18 <Cale> But also, there will tend to be many objects which have no monoid structure on them.
05:39:11 <Cale> But yeah, in the category of sets, every set can be made into a monoid in usually many different ways
05:39:38 <ski> boxscape : you have objects in your category (such as a monoidal one (the monoidal part there also being additional structure over the mere category)). then, for each such object, there may be one, or more than one, way to *equip* it with monoid structure (wrt the monoidal structure of the category). and possibly, for some objects in the category, there may be zero ways to equip it as a monoid object
05:40:05 <boxscape> So "Monoidal category" means there are some prerequisited (e.g. associative bifuncor) that you need to be able to have monoid objects in it?
05:40:19 <boxscape> s/prerequisited/prerequisites
05:40:44 <ski> boxscape : i'm not sure to which extent this really makes sense, unless you have an idea about what "monoidal category" means, and then "monoid object in a monoidal category" means. but if have have enough of an idea, perhaps my elaboration helps
05:41:32 <ski> boxscape : in short, i'm not saying that you can't have "non-monoid objects" in your monoidal category. i'm saying that the question didn't make any sense
05:42:21 <boxscape> yeah it mostly makes sense
05:42:27 <Cale> A monoid object in the category of monoids ends up being a commutative monoid, for example, so there are lots of cases there where you can't equip a monoid with an additional monoid structure.
05:42:43 <fweht> boxscape: i would imagine you *could* also define monoid objects in a regular category, if you specify all the properties of MxM, e.g. you say a monoid object is an object M with an object MxM (just a name), an object I (again just a name) and then put all the relevant stuff in the definition of monoid object
05:42:43 <ski> boxscape : yes, an associative (at least up to isomorphis) bifunctor, with a neutral (upto isomorphism) object wrt it
05:43:22 <fweht> but in monoidal categories its very straight forward since you already have the relevant structure at hand
05:44:40 <ski> fweht : "maybe the definition of monoid object is the non-trivial part" -- yes, or at least the one that may be unexpected
05:44:51 <Cale> fweht: You mean we can turn an arbitrary category into a monoidal category if products and a terminal object exists?
05:45:19 <Cale> (This is true)
05:45:44 <Cale> But you need finite products for that to happen.
05:46:22 <Cale> However, not every monoidal category is one of that form.
05:46:39 <boxscape> How does this relate to a monoid in the sense of a category with a single object?
05:47:11 <Cale> boxscape: Those monoids are monoid objects in (Set, ×, 1)
05:47:22 <boxscape> ok, I see
05:47:37 <boxscape> 1 being the set with one element?
05:47:51 <Cale> yeah
05:47:53 <boxscape> ok
05:49:21 <fweht> Cale: i meant more that i dont know if there is way to make formal sense of the statement 'you need monoidal structure to define monoid object', but that was not boxscape's point i now realize
05:50:08 <fweht> like, if you want to lift some set level definition on category (or monoidal category) level, my impression was that there is no canonical way of doing so
05:51:17 * ski . o O ( <https://ncatlab.org/nlab/show/Lawvere+theory> )
05:51:28 <Cale> correct, there's not necessarily a canonical way of lifting every set theoretical definition (though there are some common strategies which tend to work, replacing requirements that an element exists with arrows from a 1-object set, and then generalising to an arrow from a terminal object, or the unit of a monoidal category)
05:53:31 <Cale> btw, we also have that a (small) strong monoidal category is a monoid object in Cat -- but that isn't very useful as an initial definition :D
05:54:36 <fweht> :D
05:55:31 <fweht> so now i go back to work to gain intuition about adjoints  functors as generalized inverses
05:56:56 <Cale> er, strict, not strong
06:11:13 * hackage boots 0.2 - IoC Monad in Haskell  https://hackage.haskell.org/package/boots-0.2 (leptonyu)
06:18:12 * hackage boots-app 0.2 - Factory for quickly building an application  https://hackage.haskell.org/package/boots-app-0.2 (leptonyu)
06:21:13 * hackage boots-web 0.2 - Factory for quickly building a web application  https://hackage.haskell.org/package/boots-web-0.2 (leptonyu)
06:24:13 * hackage boots-cloud 0.2 - Factory for quickly building a microservice  https://hackage.haskell.org/package/boots-cloud-0.2 (leptonyu)
06:28:54 <dminuoso> boxscape: Consider the monoidal category of endofunctors equipped with endofunctor composition as its tensor. Some of these objects are monoids (exactly those endofunctors which are monads), and others that are not. If we take the Haskell perspective, then in that category Maybe is a monoid (e.g. its a monad), but others like ZipList do not yield monoids.
06:29:50 <dminuoso> Oopos. I was not scrolled down it seems. :)
06:30:34 <boxscape> still, interesting perspective
06:31:37 <dminuoso> boxscape: It was in response to your "can you have non-monoid objects in a monoidal category?" message. I didn't see anything below that.
06:31:52 <boxscape> yeah, I thought so :)
06:32:38 <dminuoso> (And to be precise, by Haskell perspective Im considering the category of endofunctors over Hask, equipped with Compose/Identity for the monoidal structure.
06:33:39 <boxscape> so if I'm seeing this correctly, all monoid objects have something like pure and join, and just in the category of endofunctors they coincide with Monad's pure and join
06:36:16 <boxscape> hmm why is join not part of the Monad class, anyway? Would be nice to be able to define a Monad in terms of join instead of in terms of bind
06:36:27 <ski> boxscape : a monoid object `M' has `neut : I >---> M' and `comb : M (*) M >---> M'
06:36:50 <dminuoso> boxscape: In CT we call them μ and η
06:36:57 <boxscape> ok
06:37:07 <ski> boxscape : for a monad `M', this becomes `eta : Identity >---> M' and `mu : M . M >---> M', yes
06:37:07 <dminuoso> boxscape: So Monad is the monoid where μ is called join and η is called return
06:37:21 <boxscape> that makes sense
06:37:50 <dminuoso> boxscape: There's at least one other common monoid in the world of Haskell that you regularly use
06:38:36 <boxscape> ...what is it?
06:38:58 <dminuoso> boxscape: If we equip the category of endofunctors not with Compose/Identity (such that ⌜μ : forall m. Compose m m ~> m⌝ and ⌜η : forall m. Identity a -> m a⌝) which would give us Monad
06:39:10 <dminuoso> boxscape: We could equip it with some other tensors. One example is a tensor called Day.
06:39:30 <dminuoso> boxscape: And now, monoids in that monoidal category are applicative functors.
06:39:51 <boxscape> hm, okay
06:40:06 <dminuoso> And above, I should for consistency have written: ⌜μ : forall m. Compose m m ~> m⌝ and ⌜η : forall m. Identity ~> m⌝) 
06:40:12 <dminuoso> Where ~> denotes natural transformation
06:40:53 <boxscape> why is it called day?
06:41:30 <dminuoso> boxscape: It's properly called the Day convolution operation, after its discoverer Bryan Day.
06:41:43 <boxscape> I see
06:44:24 <dminuoso> boxscape: So Applicative can too be considered to come with some sort of "join" and "return". The join of Applicative would take the shape of: `join :: Applicative f => Day f f a -> f a` and `pure :: Applicative f => Identity a -> Day a`
06:45:02 <dminuoso> Equivalently Monad would, if we are verbose, equipped with: `joinM :: Monad m => Compose m m a -> m a` and `return :: Monad m => Identity a -> m a`
06:45:23 <boxscape> okay
06:45:27 <dminuoso> Oops!  `pure :: Applicative f => Identity a -> f a`
06:45:27 <dminuoso> Of course. :)
06:45:51 <boxscape> right
06:46:29 <dminuoso> boxscape: Or, I personally prefer infix notation and ~>, then: ⌜joinA :: Applicative f => f `Day` f ~> f⌝ and ⌜joinM :: Monad m => m `Compose` m ~> m⌝
06:47:49 <dminuoso> we could then take one step further, and consider some: class EFMonoid t i f where μ :: f `t` f ~> f; η :: i ~> f
06:47:53 <boxscape> so.. these are natural transformations over endofunctors over Hask (not sure about the prepositions here) and thus at the same time morphisms/functions within Hask, right?
06:48:26 <dminuoso> boxscape: Well we are considering a category in which objects are endofunctors, and morphisms between them are natural transformations.
06:49:25 <dminuoso> boxscape: In Haskell it follows from a free theorem that `forall a. F a -> F a` for any choice of F is a natural transformation
06:49:35 <dminuoso> Err
06:49:40 <dminuoso> `forall a. F a -> G a` :)
06:49:44 <dminuoso> If both F and G are endofunctors
06:49:58 <boxscape> okay, interesting
06:50:22 <dminuoso> boxscape: So by using ~> Im merely emphasizing on the natural transformation part, and showing that the choice of `a` is irrelevant there.
06:50:32 <boxscape> okay
06:50:46 <dminuoso> % :t join
06:50:46 <yahb> dminuoso: Monad m => m (m a) -> m a
06:51:23 <dminuoso> boxscape: If we pick some monad, say Maybe, then `join :: Maybe (Maybe a)` for *any* choice of a, it's irrelevant. join behaves uniformly for any choice.
06:51:47 <boxscape> ok
06:52:28 <dminuoso> boxscape: But at any rate, the naturality are conditions already imposed by the definition of a monoid, which stipulates that μ and η must be natural transformations. :)
06:52:45 <boxscape> ah, right
07:00:19 <maerwald> what do you call `f :: (Monad m, Monad n) => m a -> n b`?
07:01:29 <Cale> maerwald: Presumably you mean m a -> n a ?
07:01:31 <dminuoso> maerwald: A lie?
07:01:44 <maerwald> Cale: nope, n b
07:01:52 <maerwald> a hoist and then a map
07:02:05 <Cale> Is it really that polymorphic, or do you mean there are particular monads?
07:02:12 <maerwald> particular, probably
07:02:53 <dminuoso> I cant think of how that'd work out
07:02:54 <maerwald> was just wondering if there is a CT term for it
07:03:12 <maerwald> dminuoso: it's exactly what I want to do in streamly :P
07:03:15 <dminuoso> maerwald: If you merely constraint it by Applicative and constrain it by Contravariant, it exists
07:03:31 <Cale> Well, there's a notion of "monad homomorphism", but... usually that's a natural transformation
07:03:37 <dminuoso> Well or at least a resricted form
07:03:38 <maerwald> m a -> n a is already possible
07:03:49 <maerwald> but m a -> n b, no idea
07:03:55 <dminuoso> phantom :: (Functor f, Contravariant f) => f a -> f b
07:03:56 <dminuoso> Is a thing
07:04:19 <dminuoso> (This in effect has just a single instance in Haskell)
07:04:33 <maerwald> Cale: value non-preserving homomorphism?
07:04:47 <dminuoso> maerwald: It wouldnt just be non-preserving, you'd have to make up values.
07:05:09 <dminuoso> maerwald: Since it's monad, (>>=) demands that you somehow must be able to produce values of the inner type
07:05:39 <maerwald> imagine: SerialT m Int -> SerialT n (Maybe Int)
07:05:48 <Cale> maerwald: It doesn't quite make sense that it would take any type to any other type there. Any such thing would produce _|_
07:05:53 <maerwald> where m could e something like ExceptT
07:05:56 <dminuoso> maerwald: Well yes. For concrete types that works
07:06:05 <dminuoso> maerwald: But if you universally quantify over it, parametricity takes hold
07:06:22 <maerwald> haven't figured out how to do that in streamly yet, so was looking for pointers what to google, maybe
07:06:26 <dminuoso> You'd have to make some `n b` for *any* choice of b, including Void.
07:06:31 <dminuoso> And you cant make values of Void
07:06:48 <dminuoso> And the reason you must be able to produce values, is because of how (>>=) works
07:07:33 <dminuoso> So indeed what Cale said. The only implementation for `f :: Monad m => Monad n => n a -> n b` is bottom.
07:10:27 <Cale> Well, you can do stuff with the monad structure on top of that, but it's like, some natural transformation composed with fmap (const undefined)
07:19:01 <boxscape> % data T k (a :: k) = MkT k
07:19:01 <yahb> boxscape: 
07:19:08 <boxscape> % :t MkT 3
07:19:09 <yahb> boxscape: forall k (a :: k). Num k => T k a
07:19:24 <boxscape> Is there any concrete, non-parametric type that I can give MkT 3?
07:20:22 <boxscape> (I think that would only be possible if we had type-level Int literals?)
07:21:09 <boxscape> % :k T -- also I didn't know that this syntax actually already exists in ghci type signatures, that's neat
07:21:09 <yahb> boxscape: T -- also I didn't know that this syntax actually already exists in ghci type signatures, that's neat :: forall k -> k -> *
07:21:30 <boxscape> (i.e. forall k -> k -> *)
07:21:54 <boxscape> s/type/kind
07:28:12 * hackage replace-megaparsec 1.0.1.0 - Stream editing with parsers  https://hackage.haskell.org/package/replace-megaparsec-1.0.1.0 (JamesBrock)
07:45:38 <boxscape> anyway it seems kind of weird to be able to construct a value but not give it a concrete type
07:55:01 <boxscape> actually it's similar for things like
07:55:09 <boxscape> % :t MkT not
07:55:09 <yahb> boxscape: T (Bool -> Bool) a
07:55:22 <boxscape> I don't think this can be constructed without unsaturated type families being allowed
07:55:42 <boxscape> maybe I'm missing some way in which defunctionalization trickery could help though
07:56:02 <boxscape> well, it can be construced
07:56:09 <boxscape> it just cannot be given a concrete type
07:58:14 <dmwit> I don't think Bool -> Bool or Num k are special. You can't even do this with MkT True, right?
07:58:28 <dmwit> Even though we have a lifted Bool, the lifted Bool and the unlifted Bool are not the same thing. Or are they?
07:58:54 <dmwit> % case MkT True :: T Bool True of _ -> "wow"
07:58:54 <yahb> dmwit: "wow"
07:59:05 <dmwit> Huh! Okay, then.
07:59:52 <mycroftiv> is there a good trick to change code back and forth from using Integer to Int? I have two versions of a program to compare performance and im wondering if i can parameterize this at the source level somehow
08:00:22 <dmwit> mycroftiv: Use Integral + SPECIALIZE everywhere?
08:00:36 <mycroftiv> i will look up what SPECIALIZE is, thanks
08:03:12 * hackage generic-constraints 1.0.0 - Constraints via Generic  https://hackage.haskell.org/package/generic-constraints-1.0.0 (YairChuchem)
08:06:01 <boxscape> Actually it's not that weird - after all, you can make
08:06:13 <boxscape> % data D (a :: Void) = MkD
08:06:14 <yahb> boxscape: 
08:06:27 <boxscape> but you certainly wouldn't want to be able to give that a concrete type
08:06:37 <boxscape> % :t MkD
08:06:37 <yahb> boxscape: D a
08:09:03 <boxscape> (excluding type level bottom)
08:09:13 <boxscape> (which would also work for the other examples)
08:18:13 * hackage generic-constraints 1.1.0 - Constraints via Generic  https://hackage.haskell.org/package/generic-constraints-1.1.0 (YairChuchem)
08:26:13 * hackage BiobaseBlast 0.3.1.0 - BLAST-related tools  https://hackage.haskell.org/package/BiobaseBlast-0.3.1.0 (ChristianHoener)
08:27:43 * hackage generic-constraints 1.1.1 - Constraints via Generic  https://hackage.haskell.org/package/generic-constraints-1.1.1 (YairChuchem)
08:47:27 <hoppfull> Hello, at work we are creating what I'd call a typed computation tree. Currently all possible permutations are modeled with ADTs which is quite difficult to work with. Correctness is very important. I'm getting my feet wet with Haskell and I know there are usually well studied constructs to deal with most problems.
08:48:19 <hoppfull> A requirement is that we should not only produce a result of the calculation but also represent that calculation as a tree of nodes that the end user can connect and disconnect.
08:49:34 <hoppfull> So my mind has wandered to comonads, indexed monads and free monads but I thought I'd come by here, sometimes someone has and idea of something that I may not have thought of. I don't know if I've provided enough information.
08:51:38 <hoppfull> In essence we're allowing an unskilled user to build up a calculation that is typed such that they can't make invalid connections. We're using haskell because correctness and reliability is of high priority.
08:51:48 <lyxia> That all seems too vague.
08:52:09 <hoppfull> I can't say too much but I'll try and reformulate the problem.
09:02:30 <hoppfull> Let's say I want to build a function at runtime, I can just compose them together like ((* 2) . (+ 1) . (- 2) . (* 3)) but is there a way to represent this code as a datastructure that can be manipulated?
09:03:01 <EvanR> yep
09:03:03 <hoppfull> Well, obviously there is, we are now but is there a simple way to do it? An ideomatic way to do it?
09:03:22 <EvanR> data Fun a b = Fun (a -> b)
09:03:24 <wroathe> Does anyone know if there's an easy way to conditionally enable these preprocessors based on a flag? https://www.haskell.org/cabal/users-guide/developing-packages.html#modules-and-preprocessors
09:03:57 <wroathe> Moreover, is there a way to get Cabal to write the result of preprocessing into the source directory instead of the dist directory?
09:04:13 <glguy> hoppfull: You decide what syntax you want to be able to manipulate and then you define a new datatype with the constructors corresponding to the syntax you picked in the first step
09:04:29 <wroathe> Like if I want to cabal to run alex and write the output to src/foo/bar/Scanner.hs, but only if the "dev" flag is enabled
09:04:59 <phadej> wroathe: dev flag is a code-smell
09:05:04 <hoppfull> glguy: The syntax is a graphical user interface that is a node tree generated based on the computation.
09:05:11 <phadej> wroathe: use Makefile for preprocessing sources, if you want to
09:05:16 <wroathe> phadej: I'm open to alternatives
09:05:27 <phadej> (not have alex run all the time)
09:05:31 <glguy> hoppfull: No, graphical user iterface doesn't feature at this level
09:05:37 <hoppfull> ok
09:05:47 <EvanR> hoppfull: any data structure is a programming language if you look at it right
09:05:48 <wroathe> phadej: Ah, Make is usually my go to, but I was just exploring whether or not it was possible to do this entirely with Cabal
09:06:06 <wroathe> phadej: I'm wondering why Cabal even has the ability to run alex/happy
09:06:10 <EvanR> you are basically coming up with a small programming language
09:06:15 <hoppfull> yeah, I know
09:06:27 <wroathe> As it currently exists it seems pretty useless\
09:06:29 <phadej> wroathe: because it can, and it's simple. Iw onder why you don't want let Cabal to do preprocessing for you?
09:06:44 <EvanR> the techniques for this in haskell reach to the moon
09:07:06 <hoppfull> I just want a nice way of building it up. One idea was to create a small algebra describing the operations and then create a free monad and build the datastructure like that.
09:07:32 <EvanR> you can just start with the AST
09:07:37 <wroathe> Well, as I understand it (and correct me if I'm wrong), if I publish a dist of my package that contains a Scanner.x file, then that causes whomever installs my package to have to run alex to generate the haskell sources
09:08:00 <phadej> yes, and that's completely fine!?
09:08:02 <wroathe> The packages that I've found that use alex all seem to do the preprocessing as part of a build of their package, and then go out of their way to make sure that Cabal doesn't run alex on the user's machine
09:08:15 <wroathe> even the Alex package does that
09:08:21 <hoppfull> Right now it's such a nightmare to unit test that no one wants to unit test. Too much of a pain.
09:08:26 <phadej> alex and happy are special packages as their bootstrapping is circular
09:08:32 <wroathe> http://hackage.haskell.org/package/alex-3.2.4/src/
09:08:33 <phadej> they are not good representatives of how to use either
09:08:43 <phadej> ghc is not "ordinary Cabal package" either
09:08:46 <phadej> for "reasons"
09:08:59 <EvanR> with GADTs you can go farther and make the AST typed
09:09:31 <hoppfull> EvanR: I think we're using GADTs. Do you have any reading materal for what you describe?
09:09:58 <wroathe> phadej: Can you point me to a popular package that does require the user to preprocess the file with Alex? And what would be the advantage of doing that when you can just generate the haskell source at build time and check it into your repo?
09:10:06 <EvanR> with HOAS you can go farther and use haskell functions to represent functions, which gives a speed boost and can be tricked into being serializable. 
09:10:15 <hoppfull> Sorry, I don't have a computer science degree. I understand if these questions are too annoying.
09:10:23 <phadej> wroathe: alex, cannot say for sure
09:10:28 <hoppfull> HOAS?
09:10:29 <phadej> but for happy: https://hackage.haskell.org/package/haskell-src-exts-1.21.0/src/
09:10:36 <EvanR> higher order abstract syntax
09:10:45 <EvanR> the universe of possibilities just keeps going
09:11:25 <hoppfull> I think I have some reading material now. Thanks a ton, guys!
09:11:26 <tsahyt> can I safely refer to values contained in the result when using Data.Vector.generate? e.g. for lazy dynamic programming purposes. I know it works with array, but I'm not sure about vector
09:11:37 <wroathe> I just don't see the advantage to requiring the preprocessing at install time
09:12:05 <phadej> the fact that you distribute 
09:12:09 <phadej> "human readable sources"
09:12:28 <phadej> and there are less opportunities for mistakes
09:12:36 <phadej> (e.g. forgetting to preprocess it before packaging)
09:12:40 <phadej> and it's convinient
09:13:21 <phadej> tasty-discover and hspec-discover are preprocessors as well, of a kind
09:13:30 <phadej> convinience
09:14:40 <Cale> wroathe: It's not install-time, it's build-time
09:15:29 <wroathe> Cale: Yes, sorry. Bad nomenclature.
09:16:37 <wroathe> In fact, it actually seems like requiring them to preprocess Alex/Happy files would open you up to MORE mistakes if you build-tool-depends a range, rather than an exact version of Happy/Alex that you know generates the correct Haskell module
09:16:47 <wroathe> (the chances of that becoming are low, but it is possible)
09:17:32 <wroathe> Publishing the preprocessed haskell module removes that possibility and absolves them of the need to have those two tools on their system
09:17:41 <Cale> wroathe: Well, any self-respecting build-tool should be able to run preprocessors for you...
09:18:04 <wroathe> Cale: I agree, but I don't see the value with these two particular preprocessors
09:18:22 <Cale> You shouldn't need to have those things on your system just to install the package, I agree.
09:18:32 <Cale> (In particular, you ought to be able to get these things from binary caches)
09:19:03 <tsahyt> apparently I can
09:19:07 <tsahyt> very nice
09:19:35 <Cale> tsahyt: Ah, missed the question -- yeah, this works with boxed vectors
09:19:45 <tsahyt> ah but not with storable or unboxed?
09:19:59 <Cale> unboxed vectors/arrays specifically remove the facility that's required for lazy evaluation
09:19:59 <tsahyt> hm, it would make sense for that not to work
09:20:02 <tsahyt> yes
09:20:16 <tsahyt> well that is slightly annoying, although understandable
09:20:22 <wroathe> brb
09:22:01 <tsahyt> Cale: so by extension, does this work for any data structure that is lazy in its values?
09:22:11 <tsahyt> I think I've done it with IntMaps too at some point
09:22:17 <Cale> Yeah, you can typically define things recursively when they're lazy
09:22:27 <tsahyt> that is very nice
09:22:57 <tsahyt> unfortunately the restriction of having boxed values means that I can't actually apply it right now, but it's good to keep it in mind
09:23:49 <tsahyt> I'd need it in a vector with something on the order of 96 million floats in it. having a boxed vector for that sounds like it'd perform rather bad
09:28:04 <Ariakenom> not sure I'm being relevant but you can't define values depending on each other in a Data.Map
09:28:48 <Cale> hm?
09:28:51 <Cale> You can
09:29:20 <solonarv> you definitely can if you use the lazy functions, not sure about strict
09:31:16 <Cale> Yeah, if you use the functions in the .Strict module, you might force the evaluation too soon.
09:31:37 <Cale> Also, it's only possible to do with the values, not the keys
09:33:57 <Ariakenom> oh yeah. I was clumsy with words. I meant keys too
09:34:12 <tsahyt> both the Data.Maps are strict in their keys iirc
09:35:12 <Ariakenom> it's more about the structure of the map than the keys themselves
09:37:41 <wroathe> Back, sorry
09:38:09 <wroathe> But yeah, phadej, I get your point about the build system needing to be able to run preprocessors generally
09:39:28 <geekosaur> maybe the more important point is needing to deal with packaged build artifacts is a major complication in build and deployment systems
09:40:06 <geekosaur> C dealt with it for years because yacc and lex were only available on Real Unix(tm) for a decade or so
09:40:42 <wroathe> geekosaur: Yeah, I was just thinking about this in terms of Lex/Yacc
09:40:52 <geekosaur> and in many cases ony if you had the developer toolkit license
09:42:42 * hackage bytestring-progress 1.4 - A library for tracking the consumption of a lazy ByteString  https://hackage.haskell.org/package/bytestring-progress-1.4 (AdamWick)
09:47:37 <wroathe> Now the question becomes, how I do tell Cabal to stop processing .x files in the event I want Scanner.x and Scanner.hs to reside in the same directory
10:15:01 <NemesisD> is there such a thing as a type-level non-empty list?
10:17:34 <boxscape> NemesisD you might be able to just use (x : xs) as a type
10:17:43 <boxscape> this won't be unifiable with any empty lists
10:18:23 <boxscape> (actually not sure whether "unification" is the right term here)
10:19:24 <lyxia> NemesisD: NonEmpty
10:19:48 <NemesisD> lyxia: oh wait, do you mean the constructors for Data.List.NonEmpty are already promoted?
10:20:33 <Geekingfrog> Hello there. I have a bunch of parsers (json): parseA, parseB, of type `Parser Foo`. I'd like to run all of them on the same object, and returns a list of successful parse: Parser [Foo]. I currently have something hideous: x <- sequence [(Just <$> parseA) <|> (pure Nothing), (Just <$> parseB) <|> (pure Nothing)]; catMaybes x. What would be a better way ?
10:21:19 <lyxia> NemesisD: all data types are promoted
10:22:17 <lyxia> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#overview
10:22:36 <glguy> Geekingfrog: catMaybes <$> traverse optional [parseA, parseB, ...]
10:22:39 <glguy> that ought to do it
10:23:25 <boxscape> NemesisD can I ask what you want to use it for?
10:23:31 <Geekingfrog> glguy, indeed, thanks.
10:24:34 <dmwit> Even if NonEmpty weren't promoted, there's always (a, '[a])
10:24:52 <NemesisD> boxscape: i'm creating a gadt with Cons and LastItem constructors that track each cons by adding to a type-level list, but it is not possible to have an empty type-level list
10:25:26 <boxscape> I see
10:28:19 <boxscape> Actually I'm slightly confused about my suggestion
10:28:27 <boxscape> % f :: Proxy (x:xs) -> Int; f = undefined
10:28:27 <yahb> boxscape: 
10:28:34 <boxscape> % f @(Proxy '[]) Proxy
10:28:34 <yahb> boxscape: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:162:31 in interactive:Ghci70
10:28:40 <boxscape> I'm not sure why this doesn't throw a type error
10:29:12 <NemesisD> i think maybe what i'm asking for isn't necessary. this type-level stuff is melting my brain and i probably should have read Sandy's book on it before starting lol
10:29:24 <jle`> boxscape: the type variables are x and xs
10:29:35 <jle`> here:
10:29:42 <jle`> % :t f @(Proxy '[])
10:29:42 <yahb> jle`: Proxy (Proxy '[] : xs) -> Int
10:29:42 <koz_> NemesisD: jle`'s Introduction to Singletons is also massively useful.
10:29:49 <jle`> you're substituting x for Proxy '[]
10:29:59 <boxscape> oh, okay
10:30:00 <boxscape> thanks
10:30:10 <jle`> but this should error:
10:30:17 <jle`> % :t f (Proxy @'[])
10:30:18 <yahb> jle`: ; <interactive>:1:4: error:; * Couldn't match type '[] with `x0 : xs0'; Expected type: Proxy (x0 : xs0); Actual type: Proxy '[]; * In the first argument of `f', namely `(Proxy @'[])'; In the expression: f (Proxy @'[])
10:30:28 <boxscape> yeah, ok
10:30:36 <jle`> remember that type applications doesn't supply the type of the first argument
10:30:45 <jle`> it supplies the type variables to be filled in
10:31:11 <boxscape> maybe I should just get used to writing explicit foralls in all my typelevel stuff so I'm not confused by that
10:31:19 <jle`> % :t map @[]
10:31:19 <yahb> jle`: ; <interactive>:1:6: error:; * Expecting one more argument to `[]'; Expected a type, but `[]' has kind `* -> *'; * In the type `[]'; In the expression: map @[]
10:31:22 <koz_> boxscape: I do that and it helps a lot.
10:31:23 <jle`> % :t fmap @[]
10:31:23 <yahb> jle`: (a -> b) -> [a] -> [b]
10:31:31 <jle`> ^ you don't give it the (a -> b), but rather the f
10:31:39 <boxscape> yeah it makes sense
10:32:05 <koz_> It actually caught me doing silly things at least once already.
10:32:51 <koz_> Plus, it means you can make it easier for folks using TypeApplications by putting things most likely in need of explicit annotation first.
10:33:04 <koz_> (i.e. the ones that the user would most likely want to direct)
10:33:20 <koz_> s/user/caller/ I guess.
10:33:43 <jle`> NemesisD: if it helps, if you're looking for a vinyl Rec type thing but non-empty, i have one in my functor-products package
10:34:04 <jle`> NemesisD: Rec f '[a,b,c] is a tuple of f a, f b, f c
10:34:24 <jle`> so that package has NERec f (a ':| '[b,c])
10:35:34 <boxscape> hm, IIRC you cannot use TypeApplication on inferred foralls (like if you just write "test = id" in ghci without annotation), because ghc changes might change the order of those in the future. But simply leaving off the top-level declaration doesn't count as "inferred", judging from :type +v, and also from the fact that you can use TA. What's the di
10:35:34 <boxscape> fference there? Couldn't the order of those change as well?
10:36:58 <boxscape> wait
10:37:22 <boxscape> instead of "leaving off top-level declaration"
10:37:30 <boxscape> it should read "not specifying the foralls yourself"
10:37:45 <boxscape> though it does make sense that there are rules in that case
10:37:57 <boxscape> I guess the foralls are just in the order that variables appear in the type?
10:40:43 <jle`> yeah, that order is at least unambiguous
10:40:47 <monochrom> No, explicit forall isn't necessary. I just tried.  Your "test = id" example admits two competing explanations and you haven't ruled out either.
10:41:09 <boxscape> What are the two competing explanations?
10:41:28 <monochrom> "no explicit forall" and "no type sig at all".  (Hey they rhyme!)
10:42:03 <boxscape> my current understanding is: Top level with forall -> everything's fine. Top level without forall -> ghc makes foralls in order of appearance. No top level -> type inferred, no TA possible.
10:42:08 <monochrom> As a scientist I tried "g :: a->a; g = id" to refute one of them.
10:43:33 <monochrom> . o O ( radio :: g a -> g a )
10:46:48 <monochrom> Your statement needs s/top level/type sig/
10:48:41 <boxscape> ah, ture
10:48:43 <boxscape> true
11:11:56 <NemesisD> more stupid type-level questions incoming. this has me stumped: https://gist.github.com/MichaelXavier/7958576c4ee9be1c705c76c732b3426a
11:12:51 <Cale> NemesisD: Perhaps it should be a type class function, since presumably it needs to be implemented differently for different types
11:13:49 <nshepperd> isn't the relevant difference for TypeApplications between these two sorts of forall: g = id without a type sig gets 'forall {a}. a -> a'.  g :: a -> a; g = id gets 'forall a. a -> a'
11:14:27 <nshepperd> which you see if you :set -fprint-explicit-foralls and do :t +v g
11:14:58 <boxscape> yeah, my question was more or less isomorphic to "why are there no braces if you don't write explicit foralls", I guess
11:15:41 <NemesisD> Cale: i'm having a tough time figuring out the signature of that typeclass. i was hoping since NativeType was a closed type family from sql types to native types that i could only have to write one implementation
11:16:31 <dmwit> NemesisD: What does $(singletons) give you?
11:16:36 <nshepperd> probably for hysterical raisins
11:16:43 <dmwit> If it gives you a singleton, presumably you can match on that in `uh`.
11:17:06 <dmwit> uh :: SQLTypeSing field -> SQLValue -> Maybe (NativeType field)
11:17:32 <NemesisD> i believe its from `Data.Singletons.TH`
11:18:01 <boxscape> (NemesisD Just an aside but as far as I can tell it looks like * will be deprecated in a couple years, personally I'd recommend getting used to Type instead)
11:18:03 <nshepperd> everything in base was written without explicit foralls when TypeApplications was invented (and still is), but people wanted to be able to use TypeApplications on them
11:18:52 <NemesisD> boxscape: oh, didn't know that. seems easy to switch
11:19:05 <nshepperd> and making the implicit foralls go in the same order that the type variables appear sort of works
11:19:08 <boxscape> here's the accepted proposal, fwiw https://github.com/ghc-proposals/ghc-proposals/pull/143
11:19:37 <boxscape> yeah that makes sense actually nshepperd
11:19:39 <Cale> I really dislike that property of TypeApplications, because it means that library authors need to be aware of TypeApplications even if they don't use it themselves
11:20:20 <Cale> If you explicitly quantify your type variables (e.g. to use ScopedTypeVariables), you have to be careful that you do it in the same order that GHC does it automatically
11:20:30 <boxscape> hm, is it possible to accidentally make a breaking change by changing the order of Constraints (assuming no foralls)?
11:20:40 <Cale> Or else you can break the code of people using TypeApplications
11:20:57 <dmwit> NemesisD: I agree it's from there. But that doesn't help me, because the documentation doesn't really say what it does; and the README it points to doesn't really, either.
11:21:09 <dmwit> NemesisD: I was hoping you knew.
11:21:59 <NemesisD> dmwit: i think this might be it: https://github.com/goldfirere/singletons/blob/master/README.md#definitions-used-to-support-singletons this is the thing i hate about TH though, it isn't clear what its defining
11:22:39 <dmwit> I read that already.
11:22:55 <boxscape> pretty sure the answer to my question is yes
11:22:57 <boxscape> that seems worrying
11:22:59 <NemesisD> the part that's breaking my brain is that i don't see how i could define a function at the value level that could handle all cases here
11:23:20 <NemesisD> since the `NativeType field` is dependent on the input
11:23:22 <nshepperd> boxscape: yeah. because it can change the order that the type variables are introduced
11:23:34 <dmwit> NemesisD: I recommend -ddump-splices. I bet the TH has produced a suitable data definition for pattern matching on.
11:23:58 <boxscape> I've read at least twice "changing the order of foralls is now a breaking change" but that's actually an understatement
11:26:13 * hackage postgres-options 0.1.0.1 - An Options type representing options for postgres connections  https://hackage.haskell.org/package/postgres-options-0.1.0.1 (JonathanFischoff)
11:27:58 <NemesisD> dmwit: do i need a typeclass or something to accomplish this?  even if i have a data definition to pattern match on, i don't see how one function body could produce `NativeType field`
11:29:51 <Cale> NemesisD: Presumably if you're pattern matching on singletons (or on values of a GADT), the branches of the case expression all have different types, corresponding to the type index of the GADT constructors
11:30:31 <nshepperd> Maybe we could add a NoImplicitForAllIsVisible extension
11:30:45 <nshepperd> (together with ImplicitForAllIsVisible)
11:30:51 <NemesisD> oh right! i think i have to put `SQLValue` into the singletons splice too since it should give me a GADT
11:31:12 <boxscape> nshepperd there's a proposal for adding an extension that forces you to write forall, but maybe that's not quite the same thing
11:31:13 <nshepperd> which you could enable in your library to stop people from using TypeApplications except when explicit foralls are given
11:31:20 <dmwit> NemesisD: uh :: Sing field -> SQLValue -> Maybe (NativeType field); uh SSQLType_String (SQLValue_String s) = Just s
11:31:47 <dmwit> NemesisD: That typechecks. Add a case for SSQLType_Int, and a fallthrough that returns Nothing, and you should be good to go.
11:32:47 <nshepperd> after that, only changing explicitly forall'd type variables would be a breaking change
11:33:24 <dmwit> NemesisD: Minimal example included as a comment on your gist.
11:33:36 <boxscape> hm actually I can't find the proposal anymore, strange
11:34:43 <nshepperd> and if people ask for explicit type variables to make things usable for TypeApplications, you could do it on a case by case basis in a minor release
11:34:45 <dmwit> NemesisD: (I was right: -ddump-splices was very informative. I again heartily recommend you try it yourself.)
11:35:32 <boxscape> nshepperd or, due to the current state of affairs without that extension, you could just leave off type annotations everywhere in your library to achieve a similar effect :P
11:35:49 <nshepperd> a terrifying prospect
11:36:54 <NemesisD> dmwit: thank you! the part that i think i had a hard time understanding is you have a case of the function returning `(Just (s :: String))` and another case that returns `Just (n :: Int)`, which just feels so strange coming from normal value-level haskell
11:37:13 * hackage postgresql-simple-opts 0.4.0.0 - An optparse-applicative parser for postgresql-simple's connection options  https://hackage.haskell.org/package/postgresql-simple-opts-0.4.0.0 (JonathanFischoff)
11:38:36 <dmwit> NemesisD: Yep. But in those cases, you have learned (from the pattern match on SSQLType_String/SSQLType_Int) that those are the appropriate types to return.
11:39:51 <NemesisD> dmwit: so basically it can be statically known that some of the cases of that function pattern match are unreachable, right? like if we know that we're matching `SSQLType_String`,  the compiler needn't consider the cases for `SSQLType_Int`?
11:46:12 * hackage ghc-exactprint 0.6.2 - ExactPrint for GHC  https://hackage.haskell.org/package/ghc-exactprint-0.6.2 (AlanZimmerman)
11:58:48 <Guest55> How can I see the result of the application of a type family in ghci?
11:59:45 <Guest55> I'm trying `:kind! MyTypeFamily ...` with no success, it only returns me this same expression.
12:01:15 <Cale> Guest55: Are you certain there's an instance available for it to be able to reduce?
12:03:00 <Guest55> You're right, I think it doesn't.
12:08:18 <boxscape> always seemed a bit strange to me that it doesn't throw a type error in those cases, but I guess irreducible type family applications are useful for something?
12:11:48 <Guest55> boxscape: given a (Rep a) I'd like to know if it "has" b.
12:12:43 <boxscape> hmm, I'm not sure what that means or how to relate it to my question
12:12:48 <Guest55> i.e: `type family RepHas b (f :: k -> *) :: Bool where RepHas b U1 = 'False; RepHas b (M1 i t f) = RepHas b f ...`
12:13:15 <Guest55> But it's not quite working. hehe
12:15:28 <Guest55> Oh. I know what i did wrong. xd
12:19:11 <dmwit> NemesisD: Err?
12:19:21 <dmwit> NemesisD: I don't think so? We covered all the cases, no?
12:32:29 <NemesisD> dmwit: i mean when `field` is made concrete, it can only hit a subset of the function's cases
12:36:13 <hololeap> i find it really unintuitive that [1,1..1] === [1..]
12:37:13 <hololeap> for instance, if i have range like [s,s+q..s+f*q], i have to manually check for the case of q=0, otherwise i suddenly get an infinite list
12:37:50 <Ariakenom> hololeap: what do you do to stop the infinite list?
12:38:35 <hololeap> well, in my code, it didn't stop and it took me a while to figure out what was causing the unexpected loop
12:38:58 <hololeap> % [1 .. 1]
12:38:58 <yahb> hololeap: [1]
12:39:02 <hololeap> % [1,1 .. 1]
12:39:08 <yahb> hololeap: [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
12:39:12 <hololeap> it just seems unintuitive
12:39:47 <Ariakenom> hololeap: oh you had an === instead of /= in your msg. I got confused
12:40:16 <hololeap> what i meant was that [1,1..1] and [1..] create the same result
12:40:28 <cocreature> Ariakenom: == is right, it’s == [1..] and /= [1..1]
12:40:57 <Ariakenom> oh I see, yes
12:41:08 * Ariakenom stops trying to read code for the night
12:44:15 <dmwit> NemesisD: Ah, yep.
12:45:26 <Ariakenom> I think that [..] example might behave better with exclusive ends
12:45:51 <dmwit> hololeap: Interesting. I guess you can either specify [a,b..c] to say "once it produces c, it stops" or "it keeps going until the next thing it would produce would be over c".
12:46:04 <dmwit> hololeap: The former seems like it would be sort of unintuitive in case c<a.
12:46:41 <dmwit> (I mean, even if you change it to say "once it produces something over c, it stops", you'd get lists with elements in them, which seems weird and probably usually wrong.)
12:46:51 <Ariakenom> dmwit: or when a+b*N never equals c
12:46:52 <dmwit> [1,2..0] should be [], not [1].
12:47:01 <dmwit> Ariakenom: See my fix in parentheses above.
12:47:36 <Ariakenom> yeah race condition
12:47:45 <dmwit> yeah =)
12:48:20 <hololeap> dmwit: fair enough, but i think there is an implied "this list will terminate" when you have something past the ellipsis
12:49:04 <hololeap> (would that be called an ellipsis?)
12:49:20 <boxscape> % [1..] == [1,1..1]
12:49:20 <yahb> boxscape: False
12:49:45 <hololeap> % [1..]
12:49:46 <boxscape> it sounded to me like you were saying this should be true but maybe I misunderstood?
12:49:51 <yahb> hololeap: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127
12:49:53 <boxscape> s/should be/is
12:50:37 <hololeap> sorry, i stated that poolry at the beginning. my concern is that [1,1..1] creates an infinite list, which is unintuitive
12:50:42 <boxscape> okay
12:50:58 <boxscape> (I agree)
12:51:24 <hololeap> i was mostly asking in here to see if there was a good reason for the unintuitve semantics
12:51:58 <Ariakenom> again, my intuition is that inclusive ends are annoying like 1-indexing is annoying
12:52:13 <boxscape> they do seem kind of related
12:52:33 <boxscape> I think Dijkstra actually refers to both of them in his essay on 0-indexing
12:53:23 <bwe> for which reason is  randomIO :: IO Int  freezing on Mac OS X?
12:53:25 <boxscape> https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html
12:53:44 <mycroftiv> my 'lifescore' of off-by-one errors i have written in code is probably getting close to 500,000
12:54:07 <boxscape> I think you mean 499,999
12:54:12 <hololeap> ^
12:54:37 <gammastorm> noone is answering, so here something really off-topic :-) https://tarot-sessions.4lima.de/ 
12:55:12 <gammastorm> for sweetening your pc work
12:55:53 <Ariakenom> boxscape: I was about to link it :)
12:57:35 --- mode: ChanServ set +o dmwit
12:58:16 --- mode: dmwit set +b *!*thorsten@*.hsi5.kabel-badenwuerttemberg.de
12:58:16 --- kick: gammastorm was kicked by dmwit (not answering is not license to spam)
12:58:28 --- mode: dmwit set -o dmwit
12:58:44 <Ariakenom> boxscape: I had the feeling Dijkstra was great for forming strong opinions on odd things. Can't think of another article right now though.
12:59:10 <boxscape> He introduced the whole "considered harmful" meme with goto
12:59:23 <boxscape> I guess that's not that odd though, at least today
12:59:34 <mycroftiv> as well as the whole 'simple languages harm the brain' meme if i recall
12:59:47 <hololeap> maybe Haskell could take something from Ruby, which is [a..b] has an inclusive and [a...b] has an exclusive end
12:59:49 <Ariakenom> mod and rem for computing fits the bill though not by EWD https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/divmodnote-letter.pdf
12:59:54 <boxscape> that sounds like the Sapir-Whorf hypothesis
13:00:09 <boxscape> (almost)
13:00:19 <mycroftiv> boxscape: i believe he has a quote about how teaching BASIC programming cripples the mind and should be forbidden :) lemme find it
13:00:47 <boxscape> hololeap hm I think i'd prefer syntax that's a little easier to distinguish
13:01:19 <Ariakenom> a man of taste, of course "Finally, in the specific comparison of Haskell versus Java, Haskell, though not perfect, is of a quality that is several orders of magnitude higher than Java" https://chrisdone.com/posts/dijkstra-haskell-java/
13:01:35 <mycroftiv> "It is practically impossible to teach good programming to students that have had a prior exposure to BASIC: as potential programmers they are mentally mutilated beyond hope of regeneration.The use of COBOL cripples the mind; its teaching should, therefore, be regarded as a criminal offence." -djikstra
13:01:48 <dmwit> > [2^53-1, 2^53 .. 2^53+2]
13:01:50 <lambdabot>  [9007199254740991,9007199254740992,9007199254740993,9007199254740994]
13:02:01 <dmwit> > [2^53-1, 2^53 .. 2^53+2] :: [Double]
13:02:03 <lambdabot>  [9.007199254740991e15,9.007199254740992e15,9.007199254740992e15,9.0071992547...
13:02:36 <dmwit> hololeap: ^ That list is also infinite. So I don't think acting as if ellipsis implies termination is a good idea.
13:02:43 <boxscape> not sure why it would seem like a good idea to make Float and Double Enums
13:03:15 <dmwit> hololeap: I can think of at least one more type where there is a sensible Enum instance whose .. may not terminate even though the endpoints are not equal.
13:03:23 <hololeap> dmwit: point taken. this should be taught early on in beginner haskell books/tutorials IMO =)
13:03:52 <hololeap> cuz yeah it kind of blidsided me
13:04:44 <hololeap> especially because i'm not fully solid on how to correctly use laziness, so when my function didn't terminate, i felt like the potential problem could be anywhere
13:04:56 <dmwit> I can see this being frustrating.
13:05:59 * hololeap really needs to learn how to do profiling in Haskell
13:06:27 <dmwit> I wonder what we would find unintuitive with the spec "when you are about to produce an element, use >= to decide whether to terminate and <= to decide whether to include it". (For increasing integral ..'s, with the obvious tweaks for decreasing ..'s.)
13:07:44 <dmwit> With this spec, [1,2 ..0] would be [] as desired, and [1,1 .. 1] would be [1], perhaps also as desired.
13:08:26 <hololeap> i think the problem is that not many people would even read the spec, because it seems so "simple", but the seemingly iron-clad patterns in how it behaves break down with certain edge-cases
13:10:18 <hololeap> oh, you're saying change its implementation :o
13:10:54 <hololeap> there's probably someone out there that relies on [1,1..1] instead of (repeat 1)
13:10:58 <hololeap> :p
13:11:05 <dmwit> I am dreaming about the counterfactual world in which I have a time machine which lets me go back and give advice to the Haskell Committee.
13:11:48 <dmwit> This proposed spec has the nice property that [1,x .. 1] = [1] for all x.
13:11:48 <ais> Is it normal/usual for `stack install somepackage` to throw "ExitFailure 1"? Today i have tried to install "cabal-install", "jack" and "reactive-jack". They all end up with "ExitFailure 1". 
13:12:08 <dmwit> No, it is not normal.
13:12:18 <dmwit> There should be detailed build logs somewhere for you to inspect.
13:12:33 <ais> i tried adding "--verbose"
13:13:01 <ais> but i'm not sure what is going on there
13:13:33 <ais> "jack> (>=0.118 && <1) || (>=1.9.8 && <2) is required but it could not be found"
13:14:23 <dmwit> Is that the exact error, or may it have typos from hand-typing it into IRC?
13:15:37 <ais> https://paste.ubuntu.com/p/72T8QvzhPZ/
13:15:40 <dmwit> Oh, perhaps that's about the version of the C library. In which case it's likely a pkgconfig thing.
13:16:03 <dmwit> Do you have the jack C library installed properly?
13:16:36 <ais> it's a new linux distro 
13:16:39 <ais> so i might not
13:20:27 <ais> thanks, i installed "jack-audio-connection-kit-devel" and now it works
13:21:31 <leshow> say I have a typeclass class Mut m where { type Ref m :: Type -> Type; newRef :: a -> m (Ref m a); }  and I make an instance for IO
13:21:54 <leshow> instance Mut IO where { type Ref IO = IORef; newRef = newIORef; }
13:22:09 <leshow> how would I pass Mut polymorphically into a function?
13:22:39 <leshow> If I have a function, I want it to take any Mut thing, and have access to the newRef function
13:27:59 <MarcelineVQ> leshow: You just have foo :: Mut m => ... As the most direct example: useMut :: Mut m => a -> m (Ref m a); useMut = newRef
13:28:38 <leshow> I wasn't aware you could use 'Ref' outside of the typeclass it was declared in
13:30:26 <hololeap> leshow: this works fine, not sure what else you want: http://dpaste.com/0ESQ0GP
13:31:20 <leshow> I'm not using it practically for anything, I just read a blog post about typefamilies and this was used as an example, so I wanted to see what it would look like
13:31:22 <leshow> thanks
13:38:22 <vaibhavsagar> how do I update `configuration-ghc-8.8.x.nix`? I made a PR once but peti yelled at me because the file is automatically generated
13:40:31 --- mode: ChanServ set +o Sigyn
13:43:15 <fresheyeball> newtype OrdSet a = Ord a => OrdSet (Set a)
13:43:19 <fresheyeball> is it a Functor?
13:44:07 <mycroftiv> id watch that gameshow
13:44:39 --- mode: ChanServ set +o Sigyn
13:44:43 <fresheyeball> mycroftiv: and thats functorwang
13:47:54 <hololeap> Ein Functorwäng
13:49:24 <dmwit> fresheyeball: Did you try writing an instance and proving the Functor laws?
13:59:20 <jle`> fresheyeball: i'd try seeing if it's even possible to write an instance first ;)
14:00:36 <jle`> hopefully my winky face gives a clue to the result to expect
14:28:39 --- mode: ChanServ set +o Sigyn
14:36:13 * hackage ghc-datasize 0.2.1 - Determine the size of data structures in GHC's memory  https://hackage.haskell.org/package/ghc-datasize-0.2.1 (DennisFelsing)
14:51:37 <maralorn> I‘d like to write a reflex application, where the webserver pushes changes in the displayed data to the browser and then the browser updates the display via reflex.
14:52:03 <maralorn> I am wondering does it make sense to also use reflex in the backend for this? Would that even be feasible?
14:52:35 <vaibhavsagar> sure
14:52:38 <Cale> Apart from the fact that Reflex is single threaded, I think it makes sense.
14:52:56 <vaibhavsagar> how are you planning to have the server push updates? most of the reflex apps I've seen use websockets
14:55:56 <maralorn> I am still looking for a simple example on how to have a webserver and a reflex thread running in the backend.
14:56:58 <vaibhavsagar> `ob init`
14:57:01 <Cale> At Obsidian, we haven't really tried using Reflex on the backend
14:57:06 <maralorn> I found some resources for running a reflex network but it looked kinda complicated.
14:57:32 <Cale> You might want to look at reflex-vty for a well-commented example of how to set up a reflex host
14:58:09 <maralorn> Cale: Thanks, that looks interesting.
14:58:50 <Cale> You might also want to start simpler, and just see if you can write the interaction you want on the backend in a more direct way. Where are the changes coming from in your case?
14:58:57 <maralorn> I tried obelisk and was a little put off by it trying to do all work for me, while I didn‘t understand what work needed to be done.
14:59:36 <jackdk> see also: reflex-basic-host: https://github.com/qfpl/reflex-basic-host for a general-purpose host. I'm hoping its 0.2 release will happen soon
14:59:39 <Cale> Obelisk still gives you a way to get back down into Snap and write handlers directly on the backend.
14:59:40 <vaibhavsagar> maralorn: the fastest way to find out is to try using `reflex-platform` yourself
15:00:26 <maralorn> Cale: I guess the easiest way would be to trigger a reload from the underlying database (where also other software could have written to).
15:00:29 <Cale> But for serving the frontend, it sort of takes control of a lot of how that's done
15:00:55 <Cale> maralorn: We've often used postgres' NOTIFY/LISTEN to send ourselves messages
15:01:00 <maralorn> Next step could be to register a hook in the db, that the server is actually informed about changes.
15:01:00 <vaibhavsagar> sounds like you want our extremely new and shiny incremental view stuff
15:01:26 <Cale> vaibhavsagar: Which sadly isn't quite ready yet
15:01:31 <maralorn> vaibhavsagar: Sounds intriguing.^^ Where do I find it?
15:01:37 <Cale> It's not available yet
15:01:41 <maralorn> Okay
15:01:55 <Cale> But Ryan's working on a way of consuming the postgres writeahead log directly
15:02:19 <maralorn> Well it‘s just about a few todos. So I can probably get away to push all of them through the websocket.
15:02:21 <Cale> and has a first-order but highly concurrent FRP system of sorts for managing that
15:02:39 <maralorn> The backend is sadly not postgres but taskwarrior.
15:04:12 * hackage BlastHTTP 1.4.1 - Libary to interface with the NCBI blast REST interface  https://hackage.haskell.org/package/BlastHTTP-1.4.1 (FlorianEggenhofer)
15:13:43 * hackage haskell-ci 0.4 - Cabal package script generator for Travis-CI  https://hackage.haskell.org/package/haskell-ci-0.4 (phadej)
15:19:18 <jackdk> man I wish I saw Ryan speak at ZuriHac. Did his talk ever get online?
15:59:51 <teratee> For straightforward parsing of huge files requiring non-lazy-io, without getting into Snoyman-esque conduits, what are the modern library suggestions equivalent to Parsec and Iteratee?  I noticed those but they seem really old.
16:08:47 <teratee> I found pipes-attoparsec.  I think this is what I'm looking for.
18:54:12 * hackage hpack 0.32.0 - A modern format for Haskell packages  https://hackage.haskell.org/package/hpack-0.32.0 (SimonHengel)
20:08:37 <jackdk> I have a package that can compile against some package P-0.6.2.4, but cabal new-configure will only give me P-0.6.1 unless I pass a --constraint arg. how can I find out why?
21:24:41 <jle`> @tell teratee are you making a distinction between snoyman-esque conduits and normal conduits?
21:24:41 <lambdabot> Consider it noted.
21:26:04 <MarcelineVQ> is there one?
21:26:13 <MarcelineVQ> That is to ask, what are normal conduits
21:28:41 <EvanR> two conduits which intersect at 90 deg?
21:29:53 <jle`> yeah, i'm trying to interpret the question. a modern version of iteratees is probably conduit, but i'm not sure what they mean by snoyman-esque conduits
21:30:43 <jle`> are they saying that they are open to non snoyman-esque conduits? or are they saying that libraries like conduit and pipes are not suitable solutions for their use case
21:31:20 <jle`> or are they talking about not wanting to go into the conduit ecosystem
21:31:37 <jle`> also i just realized that i'm responding to a question asked five hours ago
21:53:32 <iqubic> What is iteratees?
21:54:03 <jle`> in this context, it's a library :)
21:55:20 <jle`> a somewhat old one
21:55:28 <jle`> the ancestor of libraries like conduit and pipes
22:23:47 <vaibhavsagar> jackdk: unfortunately there was an issue with the ZuriHac recordings, so it might not ever get uploaded
22:24:02 <vaibhavsagar> it's a shame, I thought it was  a great talk
22:24:21 <jackdk> :'[
22:27:42 * hackage salak 0.3.5.3 - Configuration (re)Loader and Parser.  https://hackage.haskell.org/package/salak-0.3.5.3 (leptonyu)
22:30:12 * hackage salak-yaml 0.3.5.3 - Configuration Loader for yaml  https://hackage.haskell.org/package/salak-yaml-0.3.5.3 (leptonyu)
22:44:42 * hackage pg-transact 0.1.2.0 - Another postgresql-simple transaction monad  https://hackage.haskell.org/package/pg-transact-0.1.2.0 (JonathanFischoff)
22:47:55 <jackdk> Why do so many "transaction monads" have MonadIO instances? Surely one of the benefits of a separate transaction monad is that you can't accidentally lift random IO actions into it?
22:49:18 <jackdk> (last time I reinvented that particular wheel I didn't include the MonadIO instance, and instead provided `unsafeIOToTransaction :: IO a -> Transaction a`
22:49:20 <jackdk> )
23:00:50 <cocreature> jackdk: at least in some cases it’s more an artifact of the implementation rather than a deliberate design decision. e.g. for the pg-transact package it uses the MonadIO constraint to interact with the DB and ends up leaking that to the user instead of keeping it abstract
23:18:30 <jusss> so quiet
23:38:48 <tdammers> hmm, can I make ghcid reload things when a local dependency changes instead of one of the modules of the target itself? (using cabal v2-repl, that is)
23:39:54 <dminuoso> tdammers: Ive been wondering about that for a while now. If you do find out, let me know :)
23:40:09 <tdammers> not the answer I was hoping for :(
23:59:54 <jusss> data Writer w a = Writer { runWriter :: (a, w) }
23:59:56 <cocreature> tdammers: afaik the easiest solution is to not use cabal v2-repl but instead have a .ghci file that loads everything as a single component by just setting abunch of -i flags
