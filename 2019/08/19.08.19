00:14:38 <dminuoso> jusss: Don't use ⌜return⌝
00:15:01 <jusss> dminuoso: then how I suppose to get m a?
00:15:31 <dminuoso> jusss: Read the type signature as follows:
00:15:51 <dminuoso> (>>=) :: Monad m => m k -> (k -> m t) -> m t
00:20:44 <jusss> dminuoso: and?
00:27:29 <jusss> :t (>=> (return . id))
00:27:31 <lambdabot> Monad m => (a -> m c) -> a -> m c
00:28:20 <dminuoso> jusss: So I think the confusion comes from not understanding type variables correctly.
00:28:33 <AfC> For a long time *trifecta*, although "slow" was the goto because it had "good error messages".
00:28:37 <AfC> Lately *megaparsec* seems to be getting a lot of attention.
00:28:56 <AfC> Does anyone have a view about one vs the other?
00:29:05 <jusss> dminuoso: yeah
00:29:20 <dminuoso> jusss: So type variables can be picked by one party.
00:29:36 <dminuoso> jusss: Remember how we talked about "the consumer of a polymorphic function can decide what the type variables are going to be"?
00:30:12 <jusss> dminuoso: a few days ago?
00:30:16 <dminuoso> Yes.
00:30:31 <dminuoso> jusss: If we take: 
00:30:35 <dminuoso> % :t ($)
00:30:35 <yahb> dminuoso: (a -> b) -> a -> b
00:31:31 <dminuoso> jusss: There's two type variables, ⌜a⌝ and ⌜b⌝. They merely serve as placeholders. A more verbose way to write the same thing would be: ⌜($) :: forall a b. (a -> b) -> a -> b⌝ which means "forall choices of some types a and b, ($) has the type ⌜(a -> b) -> a -> b⌝
00:31:51 <dminuoso> jusss: In this case, the consumer/caller/user of ($) must (!) what a and b are going to be.
00:31:57 <dminuoso> *must pick
00:32:57 <jusss> and ?
00:33:15 <dminuoso> jusss: Now lets take the perspective of the implementor. Now from their perspective, the first argument has some concrete, but unknown (!) type. You merely know that the consumer ends up picking some type for it, let's call it ⌜_k0⌝
00:33:51 <dminuoso> So from the perspective of the implementor ⌜f $ x = ...⌝, the argument f has type ⌜_k0⌝ - we dont know what the type is, we just give it some anonymous looking name.
00:35:25 <dminuoso> jusss: The important thing to note, type variables from different functions are, in general, unrelated.
00:35:34 <dminuoso> % :t (>>=)
00:35:34 <yahb> dminuoso: Monad m => m a -> (a -> m b) -> m b
00:35:36 <dminuoso> % :t (>=>)
00:35:36 <yahb> dminuoso: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
00:35:45 <dminuoso> The ⌜m⌝, ⌜a⌝ and ⌜b⌝ are unrelated.
00:36:00 <jusss> dminuoso: ok
00:36:54 <dminuoso> jusss: If you put yourself into the implementor position of ⌜(>=>) :: (a -> m b) -> (b -> m c) -> a -> m c; kf >=> kg = \x -> undefined⌝, then the type of ⌜kf⌝ could be called ⌜_t0⌝ (or any other random name, just make one up that looks harmless)
00:37:27 <dminuoso> Equivalently the type of ⌜kg⌝ could be called ⌜_t1⌝, it's some other unknown type
00:38:47 <dminuoso> jusss: I started that wrong. Mmm.
00:38:56 <jusss> dminuoso: ...
00:40:46 <dminuoso> jusss: Im writing it down in a gist for readability.
00:48:07 <dminuoso> jusss: https://gist.github.com/dminuoso/4d6888c0dbd27b78236f00bb519234af
00:49:04 <dminuoso> jusss: Type variables act like parameters. So it's sort of the difference between "being outside and having control over what you pass in" and "being inside, having no control over what you get, and being ready to take anything"
00:54:08 <jusss> >>= (kf x) kg :: _m0 _t0
00:54:10 <dminuoso> jusss: Note that in that gist, types that start with an underscore are not type variables (in the sense that you know them)
00:54:30 <jusss> dminuoso: >>= (kf x) kg :: _m0 _t0
00:54:42 <dminuoso> jusss: Great! 
00:54:58 <dminuoso> jusss: So the full solution is?
00:57:06 <jusss> dminuoso: (>=>) kf kg x  =  (>>=) (kf x) kg
00:57:27 <dminuoso> jusss: Great, and with infix notation?
00:57:51 <jusss> dminuoso: kf >=> kg = \x -> (kf x) >>= kg
00:57:55 <dminuoso> Very good.
00:58:19 <dminuoso> jusss: Now just implement (>>=) in terms of (>=>), its no different than how I outlined it in the gist. :)
00:58:25 <dminuoso> jusss: It's no more complicated.
00:58:51 <jusss> dminuoso: I'm really got  used to use the sugar syntax about move x from the left side to right and give it a lambda form
00:59:14 <jusss> really not
00:59:42 <dminuoso> jusss: That's fine. Just accept that they are (mostly) the same. :)
01:00:04 <jusss> dminuoso: aha, mostly, what's the except?
01:00:27 <jusss> exception
01:00:41 <dminuoso> jusss: It's a really minor detail that only surfaces when pattern mattching. 
01:00:50 <dminuoso> jusss: It's not relevant, I shouldn't have mentioned it. :)
01:01:41 <dminuoso> You can safely assume that they are fully equivalent.
01:05:08 <jusss> dminuoso: wait, kf :: _r0 -> _m0 _s0 :: a->m b,   >>=:: _m0 _s0 :: m a,   you replace a with b here
01:06:08 <dminuoso> jusss: I dont understand, you seem to have garbled that message a bit.
01:08:05 <jusss> :t (>=>)
01:08:07 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
01:08:27 <dminuoso> jusss: Ah there was a typo in the original type signature. I incorroectly wrote ⌜(>=>) :: Monad m => (a -> m a) -> ...⌝ when it should have read ⌜(>=>) :: Monad m => (a -> m b) -> ...⌝
01:08:35 <jusss> dminuoso: it's a-> m b in >=>, not a->m a
01:08:42 <dminuoso> jusss: Yes, good catch.
01:12:59 <jusss> dminuoso: then your (>>=) :: _m0 _s0 -> (_s0 -> _m0 _t0) -> _m0 _t0 is >>= m b -> (b -> m c) -> m c
01:13:27 <jusss> dminuoso:  >>= :: m b -> (b-> m c) -> m c
01:13:32 <dminuoso> jusss: No/
01:13:49 <dminuoso> jusss: Let me give you an unrelated, but spiritual similar, example:
01:13:55 <dminuoso> f x = 123 + x
01:14:02 <dminuoso> g x = "foo" ++ x
01:14:12 <dminuoso> jusss: Do you agree that these two occurences of "x" are completely unrelated?
01:15:02 <dminuoso> They just happen to have the same name. The reason is: convenience.
01:15:08 <dminuoso> Similarly:
01:15:13 <dminuoso> % :t (>=>)
01:15:13 <yahb> dminuoso: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
01:15:15 <dminuoso> % :t (>>=)
01:15:15 <yahb> dminuoso: Monad m => m a -> (a -> m b) -> m b
01:15:26 <dminuoso> Just happen to reuse the same type variables. The reason is merely: convenience.
01:16:40 <dminuoso> jusss: Read this as: "For some choices of four types... let's call them a, b, c and m in the following..."
01:17:23 <dminuoso> jusss: Inside the definition they have these concrete but known types (the ones with underscores!)
01:17:26 <dminuoso> So the transformation you tried:
01:17:31 <dminuoso> 10:12:38       jusss | dminuoso: then your (>>=) :: _m0 _s0 -> (_s0 -> _m0 _t0) -> _m0 _t0 is >>= m b -> (b -> m c) -> m c
01:17:33 <dminuoso> Doesnt work that way.
01:17:44 <dminuoso> It works the other way. 
01:18:00 <jusss> dminuoso: wait
01:19:12 <jusss> dminuoso: >>= :: _m0 _s0 -> (_s0 -> _m0 _t0) -> _m0 _t0,  this last _m0 is same with the first _m0 right? also the _t0
01:19:22 <dminuoso> jusss: Right!
01:19:37 <dminuoso> jusss: These are not normal type variables. They are just names for concrete types we are being given.
01:19:46 <jusss> dminuoso: so what's >>= :: m b-> (b-> m c) -> m c wrong?
01:20:21 <jusss> dminuoso: this last c is same with the previous c
01:22:25 <jusss> dminuoso:  >>= :: m b -> (b-> m c) -> m c is totally fine to me
01:22:42 <jusss> >>= :: m a -> (a -> m b) -> m b
01:22:59 <jusss> >>= :: m c -> (c -> m b) -> m b
01:23:24 <jusss> >>= :: m a -> (a -> c) -> m c
01:23:31 <jusss> a -> m c
01:34:46 <jusss> dminuoso: this is what you express https://paste.ubuntu.com/p/CRnb85TVGb/
01:42:23 <kuribas> @hoogle (Applicative f, Monoid m) => [f m] -> f m
01:42:24 <lambdabot> Text.Pretty.Simple.Internal.OutputPrinter sequenceFold :: (Monad f, Monoid a, Traversable t) => t (f a) -> f a
01:42:24 <lambdabot> Linear.Vector sumV :: (Foldable f, Additive v, Num a) => f (v a) -> v a
01:42:41 <kuribas> :t traverse (<>)
01:42:43 <lambdabot> (Traversable t, Semigroup b) => t b -> b -> t b
01:43:45 <kuribas> :t fmap fold . sequence
01:43:47 <lambdabot> (Monoid b, Traversable t, Monad f) => t (f b) -> f b
01:44:26 <ski> @type foldr (liftA2 mappend) (pure mempty)
01:44:28 <lambdabot> (Foldable t, Applicative f, Monoid c) => t (f c) -> f c
01:45:44 <dminuoso> jusss: The type unification really works out the way I outlined it in the gist.
01:50:26 <jusss> dminuoso: if you wrote >>= :: m b -> (b-> m c) -> m c , that I may understand early :)
01:52:28 <jusss> dminuoso: is there the next task for me ?
01:54:07 <dminuoso> jusss: So things get easier if we adopt the explicit forall notation.
01:54:40 <dminuoso> (>>=) :: forall m a b. Monad m => m a -> (a -> m b) -> m b
01:56:02 <dminuoso> The "forall m a b" merely means "for every choice of m, a, b ... ", which indicates that the occurance of "m", "a", and "b" in the right side is actually introduced through "forall"
01:58:37 <dminuoso> jusss: There's another fancy task I could give you indeed.
01:58:59 <jusss> dminuoso: ok
02:00:33 <dminuoso> jusss: https://gist.github.com/dminuoso/636ecd03d035e7dcb0bf238454d4b126 these two typeclasses are equivalent. 
02:01:32 <dminuoso> jusss: Write an ⌜instance Applicative f => ApplicativeAlt f⌝ and an ⌜instance ApplicativeAlt f => Applicative f⌝ - such that Applicative is implemented in terms of ApplicativeAlt and vice versa.
02:02:12 <dminuoso> jusss: These are two separate tasks of course. 
02:05:09 <jusss> dminuoso: what is ( ) ?
02:05:16 <dminuoso> jusss: the unit type
02:05:29 <dminuoso> () :: ()
02:05:39 <dminuoso> () is a type that has just a single value, also called ()
02:05:49 <dminuoso> It's semantically equivalent to say "void" from C.
02:05:58 <dminuoso> It's what you use when you have to use a type but dont want to convey any information.
02:06:29 <dminuoso> ⌜IO ()⌝ for example is an action that, as the result of its execution, returns no information
02:07:11 <dminuoso> It strictly returns a value of type (), which can only be (). But we understand that it contains no information, so it's the minimal thing to describe "there's no information here"
02:09:31 <TrueBoxGuy> Hi! 
02:09:33 <TrueBoxGuy> abal.config
02:10:17 <TrueBoxGuy> Hi :)
02:11:55 <ski> (if a type can have `n' different values (say `n = 2^m'), then it can (at least approximatively) be coded into `log_2 n' bits (that would be `m' bits). since the type `()' has one value, and `log_2 1 = 0', one could argue that, at least conceptually, one requires zero bits to store a value (which can only be the value, also written `()' in Haskell) of type `()')
02:12:48 <ski> (this ignores considerations about Haskell values possibly being nonterminating, though)
02:13:03 <TrueBoxGuy> Well
02:13:16 <TrueBoxGuy> Haskell doesn't work like low level languages
02:13:18 <TrueBoxGuy> **thunk**
02:13:48 <TrueBoxGuy> I'm not sure about 1 needing 0 bits to store tho
02:14:09 <TrueBoxGuy> Cus you're treating that as the special value
02:14:12 <ski> (i suppose an unboxed array with elements of type `()' could actually use zero bits to store the values, hmm)
02:14:13 <TrueBoxGuy> Not some number like 0
02:14:32 <ski> (s/store the values/store the elements/)
02:14:38 <TrueBoxGuy> Yeah sure 
02:14:42 <TrueBoxGuy> But why would it be 1 
02:14:53 * ski isn't sure what TrueBoxGuy is asking
02:14:54 <TrueBoxGuy> And I doubt unboxed types still work like that
02:15:23 <TrueBoxGuy> * TrueBoxGuy is sad
02:15:28 <TrueBoxGuy> Lol
02:15:29 <TrueBoxGuy> So 
02:15:52 <TrueBoxGuy> What I'm saying is that you need some way to store 0
02:16:04 <TrueBoxGuy> Are you doing natural numbers with or without 0?
02:16:35 <ski> i wasn't talking about natural numbers at all really (apart from counting the number of inhabitants/values in a type)
02:16:49 <ski> (i certainly wasn't talking about storing numbers of any kind)
02:16:49 <TrueBoxGuy> Were you talking about storing numbers?
02:16:53 <TrueBoxGuy> mmlul
02:17:29 <TrueBoxGuy> Are you saying if you have a type that only has one value
02:17:40 <TrueBoxGuy> You don't have to represent the value or use no storage to represent it?
02:17:44 <ski> yes
02:18:12 <ski> because the logarithm of `1' is `0'
02:19:27 <ski> (by that logic, the number of bits required to store values of type `Void' (by which i mean a type with no values/inhabitants at all), would be `log 0 = -inf', so negative infinity, huh !? .. reasoning seems to break down, here)
02:21:28 * hackage ginger 0.9.1.0 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.9.1.0 (TobiasDammers)
02:23:39 <dminuoso> 11:13:51         ski | (i suppose an unboxed array with elements of type `()' could actually use zero bits to store the values, hmm)
02:25:14 <dminuoso> ⌜State# RealWorld⌝ is an unlifted unit with no storage overhead.
02:25:44 <TrueBoxGuy> Yeah
02:25:50 <TrueBoxGuy> Anyone have any idea about my question
02:26:25 <dminuoso> ski: And indeed ⌜(State# RealWorld -> (# State# RealWorld, a #))⌝ is, in its representation, just an ⌜a⌝, 
02:26:46 <mniip> :thonk:
02:26:54 <TrueBoxGuy> Mnoop hi
02:26:58 <TrueBoxGuy> Pogey
02:27:17 <ski> yea, but i don't consider `State# RealWorld' conceptually as being a singleton type
02:27:32 <mniip> I do
02:27:42 <ski> TrueBoxGuy : i'm sorry, what was your question ?
02:27:52 <tdammers> RealWorld is essentially unit
02:27:53 <mniip> the singleton is the baton that you pass around to ensure that IO actions are evaluated in sequence
02:27:59 <TrueBoxGuy> https://cdn.discordapp.com/attachments/269153257023209473/612731547568701495/unknown.png
02:28:00 <TrueBoxGuy>  wrong context
02:29:10 <ski> (at least, one ought to include all the memory storage of the mutable objects allocated, like `IORef's and `IOArrays'. and probably also the entire state (at least as far as can be discerned from the program) of the external world. but this ties back into the inadequacies of `State (State# RealWorld)' as a model of `IO')
02:29:50 <ski> (even taking the "moral" uniqueness of it into account)
02:30:35 <mniip> State (State# RealWorld) isn't supposed to be a mathematical model, but it's a good engineering approximation given the operational semantics of GHC
02:31:12 <dminuoso> I mean if ⌜State# RealWorld⌝ is not an unlifted unit, then I dont know what is.
02:31:17 <aleator> Hi! I want to convert a string (plugin argument) into Type in GHC-typechecker plugin. Does anyone know if this is even reasonable thing to ask for?
02:31:25 <mniip> it's efficient and various code transformations preserve correctness of the encoding
02:31:48 <ski> (descriptions of the semantics of assembler instructions commonly treat memory as another "register" that's accessed and mutated by instructions)
02:37:29 <mniip> it's an array register though, meaning mutation happens at a computed address
02:37:44 <mniip> which is different from most registers because otherwise a register name is usually hardcoded into an instruction
02:42:50 * ski nods
02:46:39 <TrueBoxGuy> :(
02:48:31 <philipp> hope you're all doing good. diggin into "haskell programing from first principles" and there's a excercise in which you have to figure out the type results from applying some or all of the arguments. And there's one excercise which I don't get:  If the type of kessel is (Ord a, Num b) => a -> b -> a, then the type of kessel 1 (2 :: Integer). It's s
02:48:32 <philipp> upposed to be (Num a, Ord a) => a. But I thought it's Integer. Any explanation would be much appreciated, thx
02:51:15 <mniip> philipp, what's the type of 1
02:51:16 <dminuoso> philipp: I dont fully follow, could you try rephrasing the problem you have?
02:51:16 <TrueBoxGuy> It goes to a 
02:51:27 <TrueBoxGuy> Yep
02:51:32 <TrueBoxGuy> It's the type of 1 not of 2
02:52:02 <TrueBoxGuy> And both what you give and the type of the function influence the answer
02:52:12 <dminuoso> ski: Do you know of any decent resources teaching type unification, and - not necessarily using those words - covers universal quantified type variables, skolem type variables, etc?
02:52:33 <TrueBoxGuy> Anyone hab any clue about my questionb
02:52:37 <TrueBoxGuy> soz for repeat
02:52:39 <dminuoso> ski: Earlier the discussion with jusss I realized, that I haven't stumbled over any resource that appropriately teaches what type variables really mean and how they work.
02:52:52 <dminuoso> It seems that type variables are always introduced with so much handwaving, that things dont make much sense.
02:53:19 <mniip> dminuoso, TaPL but in fairness me myself I figured out how it all works from example before actually reading the formal definitions there
02:53:48 <dminuoso> mniip: Mmm, TaPL is a bit heavy for someone just learning Haskell though.
02:53:53 <mniip> right
02:54:31 <mniip> if they have a maths background just explain everything with ExplicitForAll
02:54:33 <mniip> :P
02:54:35 <TrueBoxGuy> :P
02:54:46 <philipp> thanks, TrueBoxGuy, but I'm passing both arguments by passing kessel 1 (::Integer) 
02:54:53 <TrueBoxGuy> ?
02:55:03 <mniip> philipp, can you tell me what are the types of the arguments?
02:55:07 <TrueBoxGuy> Show me your code lul
02:55:18 <TrueBoxGuy> You're only doing the second one 
02:55:19 <mniip> TrueBoxGuy: shoo
02:55:29 <TrueBoxGuy> ;(
02:55:40 <TrueBoxGuy> will u give me good cat points later if I shush
02:56:31 <philipp> TrueBoxGuy see here https://github.com/mvaldesdeleon/haskell-book/blob/master/ch05/exerises.md question 8
02:57:05 <TrueBoxGuy> Yes
02:57:12 <TrueBoxGuy> 1 isn't made to be an integer
02:57:13 <TrueBoxGuy> 2 is
02:57:19 <TrueBoxGuy> The annotation is around 2
02:58:58 <lortabac> philipp: by passing 1 as the first argument, you add a 'Num a' constraint. The type of the second argument does not influence the return type
02:59:26 <TrueBoxGuy> philipp: Look at the next example in those exercises to see what I mean
03:00:25 <ski> dminuoso : hm, maybe, to some extent
03:00:29 <philipp> ah, thx a lot lortabac & TrueBoxGuy ! 
03:00:33 <ski> @where polymorphic-type-inference
03:00:33 <lambdabot> "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <https://cs.au.dk/~mis/typeinf.p(s|df)>,<http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.57.1493>
03:00:43 <ski> (i remember it helped me, when i found it)
03:01:44 <ski> (i suppose, if someone already has experience with Prolog, that may also help)
03:03:32 <lortabac> ski: btw thanks for your suggestion to learn Prolog, it's a fascinating language
03:03:44 <ski> it is
03:05:02 <lortabac> ski: I managed to implemented a Hindley-Milner inference algorithm by simply copying the rules, it's magic :)
03:05:25 <TrueBoxGuy> Anyone have any idea about my cabal q
03:05:33 <ski> well, the `let'-rule is a bit tricky
03:06:22 <kuribas> ugh, non-empty should have a foldl1 function
03:07:55 <mniip> :t foldl1 @(NonEmpty _)
03:07:57 <lambdabot> error:
03:07:57 <lambdabot>     Pattern syntax in expression context: foldl1@(NonEmpty _)
03:07:57 <lambdabot>     Did you mean to enable TypeApplications?
03:08:01 <mniip> % :t foldl1 @(NonEmpty _)
03:08:01 <yahb> mniip: ; <interactive>:1:10: error:; Not in scope: type constructor or class `NonEmpty'; Perhaps you meant `NonEmptyF' (imported from Data.Functor.Base)
03:08:11 <mniip> % :t foldl1 @(NE.NonEmpty _)
03:08:11 <yahb> mniip: ; <interactive>:1:10: error:; Not in scope: type constructor or class `NE.NonEmpty'; No module named `NE' is imported.
03:08:25 <mniip> % :t foldl1 @(Data.List.NonEmpty.NonEmpty _)
03:08:25 <yahb> mniip: ; <interactive>:1:10: error:; * Expected kind `* -> *', but `GHC.Base.NonEmpty _' has kind `*'; * In the type `(GHC.Base.NonEmpty _)'; In the expression: foldl1 @(GHC.Base.NonEmpty _)
03:08:29 <mniip> % :t foldl1 @(Data.List.NonEmpty.NonEmpty)
03:08:29 <yahb> mniip: (a -> a -> a) -> GHC.Base.NonEmpty a -> a
03:08:50 <TrueBoxGuy> yahbad
03:09:57 <lortabac> ski: I don't want to hijack this channel to talk about Prolog, but the most naive translation seems to work correctly (maybe I need to test more complex cases)
03:12:11 <__monty__> Heh, was also gonna suggest prolog.
03:13:39 <dminuoso> ski: The paper is suitable for people who have done some undergrad work on formal semantics of languages or people with a good formal background. For others, Im not so sure.
03:15:34 * ski nods
03:15:47 <ski> (i just found it on my own, and dived in)
03:16:17 <TrueBoxGuy> Ok so I think I understood the cabal docs 
03:16:32 <TrueBoxGuy> but can someone tell me if my understanding is right
03:17:20 <TrueBoxGuy> https://cdn.discordapp.com/attachments/269153257023209473/612731547568701495/unknown.png in this section here
03:17:29 <TrueBoxGuy> Are they describing putting it in the cabal.project file
03:17:35 <TrueBoxGuy> Or actually running it on the command line
03:17:45 <TrueBoxGuy> And if so why isn't there a -- and the use of =
03:18:28 * hackage hpdft 0.1.0.5 - A tool for looking through PDF file using Haskell  https://hackage.haskell.org/package/hpdft-0.1.0.5 (keiichiroShikano)
03:18:29 <TrueBoxGuy> I doubt that's why tho
03:18:46 <TrueBoxGuy> I just don't understand why they use quotes
03:18:49 <TrueBoxGuy> When if I use quotes
03:18:55 <TrueBoxGuy> It puts them in the directory
03:19:18 <TrueBoxGuy> And on GH I don't see any files using quotes
03:22:58 <MarcelineVQ> They say why it's quoted in the part you circled in red :X
03:23:21 <__monty__> MarcelineVQ: They're saying that it behaves wrong when they do that in cabal.project though.
03:23:54 <TrueBoxGuy> Yep
03:23:57 <TrueBoxGuy> Exactly montyu
03:24:10 <__monty__> From their description it looks like the docs are wrong. Unless cabal.project clauses are fed verbatim to a shell command?
03:24:16 <MarcelineVQ> what does it mean to "put them in the directory"
03:24:20 <TrueBoxGuy> Ah ok
03:24:36 <TrueBoxGuy> So when I click on the link that it generates
03:24:40 <TrueBoxGuy> The quotes are in it 
03:24:43 <TrueBoxGuy> As in 
03:24:51 <__monty__> TrueBoxGuy: In the examples you found on GH were any using `$something` syntax?
03:24:53 <philipp> TrueBoxGuy sry, one another question: https://github.com/mvaldesdeleon/haskell-book/blob/master/ch05/exerises.md , Question 4. why is  the return type then not Num b => b instead of Double ? =# 
03:24:54 <TrueBoxGuy> example.com/docs/'linked
03:25:03 <TrueBoxGuy> No
03:25:06 <TrueBoxGuy> They were all unquoted
03:25:14 <TrueBoxGuy> But I'm wondering what the docs say
03:25:18 <__monty__> But did any have $something?
03:25:25 <TrueBoxGuy> $pkg ?
03:25:30 <TrueBoxGuy> But not in ````
03:25:38 <__monty__> Or another variable.
03:25:44 <TrueBoxGuy> I can check
03:25:56 <TrueBoxGuy> philpp I'll answer shortly
03:26:04 <mniip> philipp, the second argument of the function is Double, so b~Double, and the return type of the function is b
03:28:07 <TrueBoxGuy> github is loading a bit slow
03:28:09 <philipp> thx, mniip but why is the return type of question 8 (Num a, Ord a) => a as it's basically the same and I'm applying a Num constraint by the first argument
03:28:17 <TrueBoxGuy> Because of 1's type
03:28:29 <TrueBoxGuy> 1 is of type essentially Num a => a
03:28:35 <TrueBoxGuy> You didn't give it a param
03:28:48 <TrueBoxGuy> But then the type of the function has another constraint 
03:28:49 <TrueBoxGuy> of Ord
03:29:47 <mniip> philipp, they're not the same at all
03:30:41 <TrueBoxGuy> __monty__: no, but there's not much choice and most are commented out
03:30:42 <TrueBoxGuy> https://cdn.discordapp.com/attachments/269153257023209473/612956413936795658/unknown.png
03:30:43 <mniip> I think TrueBoxGuy didn't give you a through enough explanation for why the answer for 8 is what it is
03:30:56 <TrueBoxGuy> :(
03:31:05 <TrueBoxGuy> Sorry philipp and mniip
03:31:42 <philipp> TrueBoxGuy and mniip I feat it's rather me being dumb
03:31:47 <philipp> fear
03:31:51 <TrueBoxGuy> doubt
03:32:01 <mniip> philipp, so let's go back to 8
03:32:03 <TrueBoxGuy> You probably haven't been taught what the function trype means
03:32:10 <TrueBoxGuy> And "a" and stuff
03:32:34 <mniip> philipp, again what is the type of `kessel`, `1`, and `(2 :: Integer)`
03:33:57 <philipp> mniip, I guess 1 is Num and 2  is explicitly bounded to be of type Integer
03:34:09 <mniip> Num is not a type
03:34:14 <mniip> it's a constraint
03:34:17 <philipp> type constrant
03:34:19 <philipp> yes
03:34:26 <mniip> right, so what is the type of `1`
03:34:40 <philipp> Char
03:34:50 <philipp> if enclosed in brackets
03:34:55 <philipp> backtics
03:35:00 <mniip> uhh those aren't meant to be single quotes
03:35:05 <[exa]> those '1'
03:35:28 <[exa]> philipp: backticks are usually meant to delimit code here, as with markdown
03:35:45 <mniip> ski likes to use weird japanese quotes
03:36:13 <[exa]> «those are also nice»
03:36:14 <Phyx-> @tell fog, you don't have to be in msys2 to build network. Cabal just needs to be properly set up to detect the msys2 distro. Plus I do have an actual fix/workaround for MAX_PATH slated for GHC 8.10, and a way to get the same to work for 8.6 and 8.8
03:36:14 <lambdabot> Consider it noted.
03:36:17 <philipp> ah, ok, sorry. 
03:36:26 <mniip> so, what is the type of:  1
03:36:38 <Phyx-> @tell fog, it requires cabal 2.4+ though
03:36:39 <lambdabot> Consider it noted.
03:37:00 <philipp> Integer
03:37:06 <mniip> nope
03:37:54 <mniip> the type of a numeric literal is `Num a => a`
03:38:35 * ski didn't know they were japanese
03:38:38 <mniip> when we say (2 :: Integer) we have that `a` instantiated with Integer, obtaining `Num Integer => Integer`, and the  constraint is discarded because Integer is indeed an instance of Num
03:39:34 <MarcelineVQ> ski: that's what `you' get for mixing quote ticks
03:39:46 <philipp> mniip, ok, I see
03:40:06 <mniip> MarcelineVQ, I think you mean ``you''
03:40:58 <MarcelineVQ> how dare ```you'''
03:41:25 <mniip> philipp, so, we are applying a function (Ord a, Num b) => a -> b -> a  to two arguments, one of type Num c => c (I renamed the type variable to avoid name clash) and another of type Integer
03:42:02 <mniip> so the result type is (Ord a, Num b, Num c) => a  but also we know that a~c and b~Integer
03:42:09 <mniip> where ~ means "equal types"
03:42:47 <mniip> note that we're just adding constraints together, and removing arguments from the function's type
03:43:04 <mniip> but for each argument we have an equation between the argument's type in the function's type, and the argument's actual type
03:43:40 <mniip> now we can simplify those equations obtaining (Ord a, Num Integer, Num a) => a, and then Num Integer is discarded
03:45:40 <mniip> if you were to do the same for the question 4 you'd find that in the simplification process you'd get a totally different answer
03:49:30 <philipp> mniip, thanks four your explanation, thing's are becoming more clear now
03:50:31 <Phyx-> @tell fog, also with new-build you can use --store-dir to shorten the paths
03:50:31 <lambdabot> Consider it noted.
03:51:32 <ski> MarcelineVQ, heh
03:52:19 <TrueBoxGuy> __monty__: are you still hjere?
03:52:26 <philipp> and also thx again, TrueBoxGuy
03:52:35 <TrueBoxGuy> Yey
03:52:35 <TrueBoxGuy> :)
03:52:40 <TrueBoxGuy> Thank you
03:54:04 <__monty__> TrueBoxGuy: Yes, I submitted this PR https://github.com/haskell/cabal/pull/6199 If what we think is wrong I'm sure someone from the team'll comment on that.
03:54:13 <TrueBoxGuy> Oh wow
03:54:19 <TrueBoxGuy> So it apparently is wrong hehe
03:54:31 <TrueBoxGuy> Thanks so much
03:54:49 <TrueBoxGuy> Should I escape that user each time
03:55:00 <TrueBoxGuy> Can't imagine the amount of pings they have
03:56:06 <TrueBoxGuy> I'm gonna read these changes to understand stuff
03:56:20 <TrueBoxGuy> Yep
03:56:22 <TrueBoxGuy> I get it :)
04:30:58 * hackage typed-uuid 0.0.0.0 - Phantom-Typed version of UUID  https://hackage.haskell.org/package/typed-uuid-0.0.0.0 (Norfair)
04:31:57 * hackage genvalidity-typed-uuid 0.0.0.0 - Generators for Phantom-Typed version of UUID  https://hackage.haskell.org/package/genvalidity-typed-uuid-0.0.0.0 (Norfair)
04:59:11 <dminuoso> Why do I have to pass "--enable-tests" when trying to build my test target?
05:00:34 <lyxia> I don't know either but it does seem redundant.
05:05:48 <dminuoso> Why do I have to pass "--enable-tests" when trying to build my test target?
05:05:57 <dminuoso> Ops! That was the wrong terminal, pardon me.
05:07:01 <maerwald> hopefully not the root terminal
05:07:25 <dminuoso> No, it was supposed to be my terminal (not) running ghcid. ;)
05:32:11 <Zemyla> I'm thinking about these two functions which seem to define a composed monad.
05:33:26 <Zemyla> @let liftInner :: (Applicative f, Monad t, Traversable t) => t a -> ContT b (Compose f t) a; liftInner t = ContT $ \c -> Compose $ fmap (>>= id) $ traverse (getCompose . c) t
05:33:28 <lambdabot>  Defined.
05:34:30 <Zemyla> @let liftOuter :: Monad f => f a -> ContT b (Compose f t) a; liftOuter m = ContT $ \c -> Compose $ m >>= getCompose . c
05:34:32 <lambdabot>  Defined.
05:35:58 <Zemyla> :t liftInner [1, 2, 3] >>= liftOuter . putStrLn
05:35:59 <lambdabot> error:
05:35:59 <lambdabot>     • No instance for (Num String) arising from the literal ‘1’
05:35:59 <lambdabot>     • In the expression: 1
05:36:06 <Zemyla> :t liftInner [1, 2, 3] >>= liftOuter . print
05:36:08 <lambdabot> ContT b (Compose IO []) ()
05:44:04 <Zemyla> Also, could functions over certain types be Traversable?
05:45:38 <Zemyla> @let traverseF :: (Ix e, Bounded e, Applicative f) => (a -> f b) -> (e -> a) -> f (e -> b); traverseF = (\b -> let qb = Seq.fromList $ range b in \f r -> fmap (\q -> Seq.index q . index b) $ traverse (f . r) qb) (minBound, maxBound)
05:45:41 <lambdabot>  Defined.
05:51:17 <Zemyla> @let instance (Ix e, Bounded e) => Foldable ((->) e) where { foldMap f r = foldMap (f . r) $ range (minBound, maxBound); foldr f z r = foldr (f . r) z $ range (minBound, maxBound); length = let { lB :: (Bounded e, Ix e) => (e, e) -> f e a -> Int; lB p = const $ rangeSize p } in lB (minBound, maxBound); null = let { nB :: (Bounded e, Ix e) => (e, e) -> f e a -> Bool; nB p = const $ rangeSize (minBound, maxBound) > 0 } in nB (minBound
05:51:17 <lambdabot>  Parse failed: Parse error: EOF
05:52:42 <Zemyla> @let instance (Ix e, Bounded e) => Foldable ((->) e) where { foldMap f r = foldMap (f . r) $ range (minBound, maxBound); foldr f z r = foldr (f . r) z $ range (minBound, maxBound); length = let { lB :: (Bounded e, Ix e) => (e, e) -> f e a -> Int; lB p = const $ rangeSize p } in lB (minBound, maxBound)}
05:52:45 <lambdabot>  Defined.
05:53:40 <Zemyla> @let instance (Ix e, Bounded e) => Traversable ((->) e) where traverse = (\b -> let qb = Seq.fromList $ range b in \f r -> fmap (\q -> Seq.index q . index b) $ traverse (f . r) qb) (minBound, maxBound)
05:53:43 <lambdabot>  Defined.
05:56:18 <Zemyla> @let instance (Ix e, Bounded e) => Eq1 ((->) e) where liftEq eq = \fa fb -> let { go [] = True; go (e:es) = eq (fa e) (fb e) && go es } in go $ range (minBound, maxBound)
05:56:22 <lambdabot>  Defined.
05:56:46 <Zemyla> @let instance (Ix e, Bounded e, Eq a) => Eq (e -> a) where (==) = liftEq (==)
05:56:49 <lambdabot>  Defined.
06:14:18 <dminuoso> Mmm, in Test.QuickCheck.Monadic, what's the difference between ⌜pre⌝ and ⌜assert⌝? I cant make sense of the haddoc documentation, which it seems requires a mathematical background to make sense of.
06:14:54 <opqdonut> well the docs say
06:14:56 <opqdonut> > Tests preconditions. Unlike assert this does not cause the property to fail, rather it discards them
06:14:59 <lambdabot>  <hint>:1:76: error: parse error on input ‘,’
06:15:08 <opqdonut> oops right, don't use > as quote here
06:15:38 <opqdonut> anyway, so quickcheck has support for discarding test cases, in which case quickcheck generates a new test case
06:15:45 <dminuoso> opqdonut: But what's the use case?
06:16:04 <opqdonut> the same as for ==>. you want to only test foo if condition bar holds
06:16:14 <opqdonut> but you don't have a method for generating inputs for which bar always holds
06:16:32 <dminuoso> opqdonut: Ohh, so it could be some larger prop in which you may assert some things, and then assert some others if some additional precondition holds?
06:16:36 <opqdonut> yeah
06:16:37 <dminuoso> opqdonut: so "pre" is basically a sort of "when" ?
06:16:49 <dminuoso> Gotcha! :)
06:17:27 <opqdonut> or just for something like `divisor /= 0 ==> x/divisor == 3`
06:18:13 <dminuoso> opqdonut: I see! Until now I've modified my generators instead. What reasoning would you use to encode this with ==> rather than adapting your generators?
06:24:18 <opqdonut> dminuoso: I guess ==> is more of a quick-and-dirty solution. if you can easily generate the right data, do it
06:24:43 <dminuoso> gotcha
06:24:56 <opqdonut> especially if you try to ==> a rare condition, your tests might become really slow
06:25:12 <dminuoso> Yeah that makes perfect sense
06:25:42 <dminuoso> In my case ==> is a lot more useful because I dont have full control over the data (since Im doing monadic properties)
06:26:50 <opqdonut> yeah, that's what it's for
06:49:46 <Zemyla> > showsPrec1 0 not ""
06:49:49 <lambdabot>  "[(False,True),(True,False)]"
06:50:35 <Zemyla> > join (&&) == id
06:50:38 <lambdabot>  True
06:51:40 <saml> how can function be equal
06:51:56 <saml> > (id . id) == id
06:51:59 <lambdabot>  True
06:58:20 <Zemyla> > True && read "[((False, False), True), ((False, True), False), ((True, True), True), ((True, False), False)]" (True, False)
06:58:23 <lambdabot>  error:
06:58:24 <lambdabot>      • No instance for (Read ((Bool, Bool) -> Bool))
06:58:24 <lambdabot>          arising from a use of ‘read’
07:01:29 <Zemyla> > True && read "[((False, False), True), ((False, True), False), ((True, True), True), ((True, False), False)]" (True, False)
07:01:33 <lambdabot>  False
07:03:34 <Ariakenom> saml: im guessing someone defined an Eq instance in lambdabot based on generating inputs
07:03:38 <libertyprime> hey guys. i just discovered the importify and fix-imports packages and they look very useful. could anyone here please suggest some more useful tools they consider essential for writing haskell
07:04:05 <lyxia> Zemyla: Functions on finite domains are indeed traversable
07:04:43 <dminuoso> lyxia: Couldn't functions on infinite domains be traversable too, in principle?
07:04:55 <dminuoso> Every countable domain should work.
07:05:09 <Ariakenom> libertyprime: is considering those essential for writing haskell necessary for answering? :p
07:05:33 <Zemyla> It depends on the Applicative you're traversing them with, I tink.
07:06:03 <dminuoso> Zemyla: Why?
07:06:09 <merijn> Honestly, since none of the editor integration tools are still broken with v2-build the only "essential" tools I'm using at the moment are cabal-install and ghc >.>
07:07:05 <Ariakenom> merijn: :D getting to the essence of essential
07:07:10 <lyxia> dminuoso: infinite traversals tend to become infinite loops
07:08:17 <libertyprime> Ariakenom: my question is a probe into what others deem essential. its up to you how you answer. however, i will consider ghc and the scientific method to be not very helpful
07:08:49 <dminuoso> lyxia: Ah, is that in response to "dminuoso | Zemyla: Why?" ?
07:09:57 <lyxia> yeh
07:10:50 <Zemyla> Yeah, I defined Eq, Ord, and Read, as well as Foldable and Traversable, based on (Ix e, Bounded e) => thing ((->) e).
07:11:37 <Zemyla> Also, Show1, but unfortunately I couldn't redefine Show.
07:11:47 <Zemyla> > show1 (&&)
07:11:49 <lambdabot>  error:
07:11:49 <lambdabot>      • Variable not in scope: show1 :: (Bool -> Bool -> Bool) -> t
07:11:49 <lambdabot>      • Perhaps you meant one of these:
07:11:54 <dminuoso> lyxia: Right, but that's not necessarily an issue for the traversable instance itself, is it? I mean we admit Traversable on lists too.
07:12:02 <Zemyla> > showsPrec1 0 (&&) ""
07:12:05 <lambdabot>  "[(False,<Bool -> Bool>),(True,<Bool -> Bool>)]"
07:12:19 <dminuoso> Or can that lead to law violations
07:12:38 <Zemyla> > liftShowsPrec showsPrec1 showList1 0 (&&) ""
07:12:42 <lambdabot>  error:
07:12:42 <lambdabot>      • Variable not in scope: showList1 :: [Bool -> Bool] -> ShowS
07:12:42 <lambdabot>      • Perhaps you meant ‘showList’ (imported from Prelude)
07:12:56 <Zemyla> > liftShowsPrec showsPrec1 (liftShowList showsPrec showList) 0 (&&) ""
07:13:00 <lambdabot>  "[(False,[(False,False),(True,False)]),(True,[(False,False),(True,True)])]"
07:15:53 <lyxia> dminuoso: most assume lists are finite so I don't think that's a compelling point either way.
07:16:31 <dminuoso> lyxia: Lets take ⌜data Stream a = Cons a (Stream a)⌝ then
07:17:45 <Zemyla> @let instance Ix a => Ix (Down a) where { range (Down u, Down l) = reverse $ fmap Down $ range (l, u); rangeSize (Down u, Down l) = rangeSize (l, u); inRange (Down u, Down l) (Down x) = inRange (l, u) x; index (Down u, Down l) (Down x) = rangeSize (l, u) - 1 - index (l, u) x }
07:17:48 <lyxia> It looks like they carefully avoided an obvious issue by making the identity law  traverse Identity = Identity  instead of  "traverse pure = pure  for all Applicative functors".
07:17:48 <lambdabot>  Defined.
07:20:58 * hackage egison 3.9.1 - Programming language with non-linear pattern-matching against non-free data  https://hackage.haskell.org/package/egison-3.9.1 (SatoshiEgi)
07:21:07 <lyxia> dminuoso: so it seems it may be lawful, but that doesn't necessarily mean it behaves intuitively.
07:30:01 <infandum`> I've been trying to fix possible space leaks in my code. I think I found one that I'm not sure how to fix. The result of -xc was: 
07:30:01 <infandum`> *** Exception (reporting due to +RTS -xc): (THUNK_STATIC), stack trace:
07:30:02 <infandum`>   Data.Sparse.Utils.indexed,                                           
07:30:02 <infandum`>   called from Data.Sparse.SpVector.createv,                            
07:30:09 <infandum`> That's from https://hackage.haskell.org/package/sparse-linear-algebra-0.3.1/docs/Data-Sparse-SpVector.html
07:30:25 <infandum`> Does this mean createv is causing it or indexed?
07:30:38 <infandum`> And what is causing it?
07:31:57 <infandum`> indexed is from https://github.com/ocramz/sparse-linear-algebra/blob/master/src/Data/Sparse/Utils.hs
07:31:59 <merijn> infandum`: I frequently see THUNK_STATIC exceptions when running with -xc. I'm not sure what's causing them or how to eliminate them...
07:33:14 <infandum`> merijn: I ran with -K30K and the message immediately following the exception was:
07:33:28 <infandum`> Stack space overflow: current size 33568 bytes.
07:33:28 <infandum`> Use `+RTS -Ksize -RTS' to increase it.         
07:33:55 <infandum`> That 33568 is incorrect (looks like a ghc bug) but the point is that that's where the overflow occurred with -K30K
07:34:21 <infandum`> I think that ghc bug has been fixed in later versions, but that's unrelated
07:34:48 <infandum`> I'm following http://neilmitchell.blogspot.com/2015/09/detecting-space-leaks.html
07:36:33 <infandum`> I assumed it was because "indexed' (length xs) xs" kept xs around as it's referenced twice, so I just used "zip [0..]" but the same exception occurred
07:38:08 <infandum`> Here's his talk about finding space leaks as well
07:38:13 <infandum`> https://ndmitchell.com/downloads/slides-plugging_space_leaks_improving_performance-06_oct_2016.pdf
07:38:34 <infandum`> He says it should work with -K1K (probably depends on the application)
07:39:35 <Zemyla> :t \ls -> foldr (\a r i -> seq i $ (i, a):r (i + 1)) (const []) ls 0
07:39:38 <lambdabot> (Foldable t1, Num t2) => t1 b -> [(t2, b)]
07:39:53 <Zemyla> I would bet that works better?
07:42:31 <infandum`> Zemyla: what would be wrong with zip [0..] though?
07:42:44 <Zemyla> I'm not quite sure it's a good consumer over both sides.
07:43:01 <Zemyla> In fact, I'm pretty sure it's not a good consumer over both sides, because doing that requires hyperfunctions.
07:47:00 <AWizzArd> The fast-logger lib has a module `System.Log.FastLogger.File`. I am not supposed to make direkt use of this, right? Instead `System.Log.FastLogger` contains everything I need.
07:47:16 <AWizzArd> direkt => direct
07:47:41 <dminuoso> AWizzArd: Why do you feel you shouldn't make use of that module?
07:48:00 <dminuoso> AWizzArd: Its exported, its haddoc doesnt tell you "keep your fingers away", and nothing is marked internal...
07:48:34 <AWizzArd> dminuoso: I noticed this and wondered already, why it is not marked as internal.
07:48:39 <dminuoso> AWizzArd: In fact, it'd be very hard to define a LogFile logger without using that module.. :)\
07:50:32 <tabaqui> I want to send a PR in Cabal
07:50:52 <tabaqui> But I want to discuss some moments before
07:51:19 <dminuoso> tabaqui: I think the cabal discussions happen in #hackage
07:51:34 <tabaqui> dminuoso: ok, I'll write there
08:07:48 <ocharles> mpickering: do I need to run my program with any special arguments to use it with eventlog2html, if I have a multithreaded program? I'm profiling a warp application
08:07:57 <ocharles> Your docs suggest `-l-au` is only for single threaded
08:10:59 <tabaqui> I'm wondering
08:11:12 <tabaqui> Can I write *exclusive* constraint?
08:11:53 <tabaqui> class (Num a, not Fractional a) => MyNum a where...
08:12:06 <hyperisco> no
08:13:07 <tabaqui> ok
08:14:24 <tabaqui> I some very specific cases for such feature, but they aren't much obvious
08:14:39 <tabaqui> *I think about some
08:14:48 <mpickering> ocharles: does it work?
08:15:11 <mpickering> The point about -l-au is that it reduces the size of the eventlog
08:16:09 <dminuoso> tabaqui: Given the open world assumption, a "not" constraint would be hard to prove.
08:16:43 <dminuoso> I suppose it would require providing some proof an instance couldn't exist.
08:17:20 <tabaqui> I don't think it is a big issue
08:17:46 <tabaqui> The problem here is that user can accidantly break MyNum instance for an external type
08:17:51 <tabaqui> by adding Fractional locally
08:18:08 <dminuoso> tabaqui: Here comes a question: What does merely adding an instance change?
08:18:15 <dminuoso> tabaqui: are you fiddling around with overlapping instances?
08:18:20 <dminuoso> (Or incoherent instances)
08:18:38 <ski> (i suppose sometimes, with FDs, one could show an instance can't be)
08:19:58 <dminuoso> Mmm, is there some sort of monadic Arbitrary I could use to generate unique values?
08:20:07 <tabaqui> I dunno, in Haskell prove that instance exists is as much complex as prove that it doesn't exist
08:20:10 <dminuoso> Im tempted to just use unsafePerformIO
08:20:45 <tabaqui> I mean, without special extensions that allow very liberal constraints
08:20:51 <dminuoso> tabaqui: proving an instance exists is actually trivial for any non-empty typeclass since you can just sprinkle bottom all over it.
08:21:27 <dminuoso> (Haskell is an inconsistent logic)
08:22:02 <tabaqui> it is not a real math world here, if we cannot prove that instance exists then it doesn't
08:22:29 <tabaqui> ah, messed with grammar as usual, sry
08:22:30 <Ariakenom> the difference is between "there exists an instance" and "there can't ever exist an instance"
08:22:43 <tabaqui> the world *ever*, right
08:22:46 <tabaqui> *the word
08:23:11 <tabaqui> but right now, in current context we can derive it
08:23:12 <dminuoso> There is actually one typeclass you cant have an instance of.
08:23:25 <dminuoso> ⌜class Any => Bottom where no :: a⌝
08:24:26 <tabaqui> https://hackage.haskell.org/package/constraints-0.11/docs/Data-Constraint.html#t:Bottom
08:25:02 <dminuoso> It's a fun little class because it acts as an initial object in the category of constraints.
08:26:36 <ocharles> mpickering: oh, sorry, I meant to say "it doesn't work. I get the correct x axis, but the y axis (allocations) is constantly 0"
08:27:15 <ocharles> mpickering - I just get this https://usercontent.irccloud-cdn.com/file/z8UH5uPT/image.png
08:27:37 <ocharles> the .eventlog is 16mb
08:27:59 <mpickering> What profiling mode are you using?
08:28:20 <ocharles> `-hc`
08:28:36 <ocharles> `+RTS -hc -l-au` is my command line
08:28:52 <mpickering> Can you see the profiling events in the eventlog?
08:29:33 <mpickering> ghc-events has an option to dump the contents
08:29:39 <ocharles> I'm not sure, the eventlog file looks binary to me
08:29:40 <mpickering> Does it work with just -l
08:29:54 <ocharles> I'll give that a try
08:30:20 <mpickering> It looks like there are no profiling events
08:30:58 <Guest_32> sprint is not working since I have upgraded ghc, what can I do to evaluate expressions again ?
08:31:40 <dminuoso> Guest_32: What do you mean by "not working"?
08:31:51 <dminuoso> Guest_32: Do you get an error message? Which GHC version is GHCi reporting?
08:32:16 <Guest_32> GHC version 8.6.5
08:32:30 <Guest_32> I tried "let xs = [1..10]"
08:32:38 <Guest_32> then "sum xs"
08:33:03 <ocharles> mpickering: I get this on STDOUT btw: `[Frame 9.0721e-5 [],Frame 5.9119e-4 [],Frame 1.132967324 [],Frame 2.134089814 [],Frame 115.21031936600001 [],Frame 116.18275740200001 [],Frame 116.73504789600001 [],Frame 117.06812951200001 [],Frame 118.10639257800001 [],Frame 119.263322281 [],Frame 120.25897202600001 [],Frame 121.26064613000001 [],Frame 122.264032064 [],Frame 123.276531312 [],Frame 124.275906977 [],Frame 125.265781927 [],Frame
08:33:03 <ocharles> 126.26817159500001 [], ...]`
08:33:10 <ocharles> Repeating up to Frame 481
08:33:15 <Guest_32> then ":sprint xs", but result is always "xs = _"
08:33:51 <mpickering> ocharles: err ok. that doesn't happen for me locally
08:34:08 <ocharles> Same result with just `-l` unfortunately.
08:34:12 <mpickering> Can you send me the eventlog?
08:34:14 <ocharles> You mean you get nothing on stdout/stderr?
08:34:17 <ocharles> Yea sure, one sec
08:34:20 <mpickering> Yeah
08:34:24 <mpickering> Email it to me
08:34:55 <mpickering> You can use -p to render a .hp file
08:35:03 <mpickering> But you don't get traces
08:36:48 <dminuoso> Guest_32: The reason is the polymorphism on the integer.
08:37:16 <dminuoso> Guest_32: If you annotate and pick a concrete type, it'll work.
08:37:26 <dminuoso> Guest_32: rationale: you can only share/memoize if its monomorphic.
08:38:24 <Guest_32> Fantastic!! great, it is now showing the progress in the evaluation of an expression. Thanks
08:38:50 <dminuoso> Guest_32: if it used to behave differently, its possible that for some reason (perhaps ghci configuration/default settings) type defaulting rules have changed for you.
08:39:32 <ocharles> mpickering: ok, emailed
08:40:21 <ocharles> mpickering: -p produces: eventlog2html: circuithub-api.eventlog: hGetContents: invalid argument (invalid byte sequence)
08:42:22 <mpickering> Yeah run it on the hp file
08:42:25 <mpickering> ;)
08:43:54 <ocharles> oh, ha
08:44:23 <ocharles> ah cool, that does actually give me a graph
08:44:58 <mpickering> Still useful for filtering and zooming
08:45:19 <ocharles> Yea, for sure
08:45:54 <ocharles> And works well for `-L500` which completely breaks hp2ps
08:46:24 <dminuoso> Okay, I think unsafePerformIO for generating unique data with Arbitrary seems safe.
08:46:32 <dminuoso> Any thoughts? :)
08:50:29 <ysangkok> why wouldn't it be, for example? i don't know much about it but i don't understand the question
08:51:01 <dminuoso> ysangkok: Well the thing Im not quite certain about, is reproducability of tests.
08:51:29 <ysangkok> but it is possible to write IO code that always produces the same result
08:51:47 <dminuoso> If I had some counter that got bumped with atomicModifyIORef to add some sort of unique tag to my data, then this would greatly depend on the order of my tests.
08:52:16 <dminuoso> But I cant find any kind of ArbitraryIO
08:53:11 <AWizzArd> I would like to use fast-logger to output timestamps. I have a FormattedTime (`type FormattedTime = ByteString`) and do `show time`. This results in the timestamps being enclosed in doublequotes in my log file. Is there a simple trick to get rid of them?
08:53:29 <dminuoso> AWizzArd: Dont fast-logger? :)
08:54:34 <AWizzArd> dminuoso: what do you mean?
08:54:46 <ysangkok> btw i am still having my "too many pending signals" problem if anybody has a clue about that...
09:10:11 <infandum`> If I have negative productivity, does that mean there is a lot of GC?
09:10:31 <merijn> *negative* productivity? o.O
09:11:02 <dminuoso> Someone didnt like their performance review!
09:11:10 <merijn> infandum`: A really tiny number would be lots of GC
09:11:23 <merijn> infandum`: negative productivity doesn't make logica sense
09:11:56 <merijn> That's like negative distance
09:13:08 <infandum`> merijn: I somehow got -6.0% productivity
09:13:31 <merijn> infandum`: That's...worrying :)
09:14:13 <infandum`> merijn: It's...annoying ahah
09:14:41 <infandum`> Looks like most allocation was in Data.IntMap
09:14:55 <infandum`> intersectionWithKey, insert, and map.go
09:15:18 <infandum`> Is that a leak, or is that just big data?
09:15:56 <merijn> Depends on allocation size and amount of data? :)
09:17:12 <infandum`> merijn: Does it? Why would insert take up allocation at all?
09:17:45 <merijn> infandum`: insert needs to create a copy with the new key inserted?
09:17:54 <dmwit> What's your plan for implementing insert without allocation?
09:19:10 <infandum`> merijn: Wouldn't that remove the parent?
09:19:27 <merijn> hmm?
09:19:43 <infandum`> The old IntMap would be deleted, right?
09:19:52 <Taneb> Not until it's garbage collected
09:19:59 <merijn> infandum`: Sure, but that means it will be garbage collected later
09:20:25 <merijn> infandum`: You don't magically reuse the space of the old IntMap, since parts will be reused in the new one and the new one is bigger anyway
09:21:26 <infandum`> So there's nothing that can be done about functions like insert and intersectionWithKey?
09:21:37 <infandum`> Because it seems to take up a lot of memory
09:22:31 <infandum`> If I have a 4g file with 4 columns, and I replace those columns with a single number and put them into a 2D IntMap, would the IntMap not be smaller than the file?
09:22:56 <merijn> infandum`: 4 columns as in 4 characters or what?
09:23:41 <infandum`> Yet if 15% of the allocation is there, and it can reach like 200g at max memory usage or higher, something feels off
09:23:48 <infandum`> merijn: 4 strings
09:23:57 <infandum`> about 80 characters in all
09:24:01 <infandum`> each line
09:24:37 <infandum`> I stream them in one by one to a data type, convert to an index in the 2D IntMap as a matrix from sparse-linear-algebra
09:26:17 <infandum`> All of my profiling points to Data.IntMap.Strict functions as the memory hogs, but I cannot tell if it's because of a leak or just "big data"
09:26:50 <infandum`> But because of the vast amounts of memory, I assume a leak is somewhere, even if it's not in IntMap, but the profiling isn't showing me any other large functions
09:28:59 <pong> :t writeBeamer
09:29:01 <lambdabot> error: Variable not in scope: writeBeamer
09:29:14 <pong> :t Text.Pandoc.writeBeamer
09:29:16 <lambdabot> error:
09:29:16 <lambdabot>     Not in scope: ‘Text.Pandoc.writeBeamer’
09:29:16 <lambdabot>     No module named ‘Text.Pandoc’ is imported.
09:29:22 <pong> oops
09:29:24 <dmwit> infandum`: Are you actually using String?
09:29:27 * hackage git-annex 7.20190819 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-7.20190819 (JoeyHess)
09:29:32 <dmwit> (As opposed to, say, Text or ByteString.)
09:30:53 <dmwit> If so... don't. String is wildly memory-inefficient.
09:31:19 <dmwit> And if you're doing lazy IO, it seems possible to me that it would blame the IntMap operations instead of the lazy IO operations for those memory costs.
09:33:04 <dmwit> On 64-bit machines, I expect a String to cost 24 bytes per character.
09:33:15 <dmwit> (Plus some negligible overhead.)
09:34:36 <infandum`> dmwit: Text
09:34:52 <infandum`> Streaming using streaming-cassava
09:36:07 <dmwit> Text should be fine, just over 2 bytes per character in most situations.
10:06:39 <lavalike> what's the intuition behind monoid homomorphisms, I know for groups sending generators to generators describes them, but monoids?
10:08:27 <ski> the idea about homomorphisms is preserving operations
10:13:50 <nshepperd> 'fold :: Monoid a => [a] -> a' is a monoid homomorphism because it doesn't mess with the order of the list elements
10:14:32 * nshepperd pretends infinite lists don't exist
10:14:34 <[exa]> lavalike: the generators-to-generators map of homomorphisms is a result that is kindof specific to groups; when there are no easy generator structures, you need to look at operations
10:16:15 <[exa]> nshepperd: there is no problem with element ordering (e.g. reverse is okay if the homomorphised operation also appends the other way)
10:17:18 <nshepperd> err
10:18:09 <nshepperd> well, if [1,2,3] <> [4,5,6] was [4,5,6,1,2,3] we'd probably call them snoc lists and write them from right to left
10:18:57 <[exa]> yes, the homomorphism is from lists to snoc-lists
10:19:27 <[exa]> (certainly not automorphism though)
10:19:42 <nshepperd> i'm talking about haskell lists though
10:22:06 <[exa]> oh yes, in haskell you need finiteness and some technical tool to mark the snoc-lists
10:28:26 <nshepperd> what i said is actually just a trivial restatement of the monoid homomorphism requirements. fold is a monoid homomorphism because fold ([1,2] <> [3,4]) = fold [1,2] <> fold [3,4] = fold [1] <> fold [2,3,4]
10:28:37 <nshepperd> and so on for every way you care to divide the list
10:29:03 <nshepperd> which basically means the elements are folded in order
10:33:38 <[exa]> oh this way, yes
10:38:05 <ohko> any nice way to convert`[[]]` into `Nothing`, `[ [1], [2], [] ]` into `Nothing`, and `[ [1], [2], [3] ]` into `Just [ 1, 2 ,3 ]`?
10:38:39 <ohko> I want `Just [ ... ]` of the sublist's first element, but only if each sublist has an element
10:38:43 <ohko> otherwise `Nothing`
10:39:44 <ohko> i can do it using lots of conditionals but i feel like an elegant fold/recursion is escaping me
10:39:58 <cocreature> > traverse listToMaybe [[1],[2],[3]]
10:39:58 <Ferdirand> :t sequence . listToMaybe
10:40:00 <lambdabot> Monad m => [m a] -> m (Maybe a)
10:40:01 <lambdabot>  Just [1,2,3]
10:40:05 <cocreature> > traverse listToMaybe [[1],[2],[3],[]]
10:40:07 <lambdabot>  Nothing
10:41:14 <ohko> > traverse listToMaybe [[]]
10:41:18 <lambdabot>  Nothing
10:41:22 <ohko> > traverse listToMaybe []
10:41:26 <lambdabot>  Just []
10:41:40 <ohko> ok that last one i would need to be `Nothing` as well
10:41:58 <c_wraith> are you sure? there were no empty lists in the input. 
10:42:42 <cocreature> > toList $ nonEmpty $ traverse listToMaybe []
10:42:47 <lambdabot>  error:
10:42:47 <lambdabot>      Ambiguous occurrence ‘toList’
10:42:47 <lambdabot>      It could refer to either ‘F.toList’,
10:42:51 <cocreature> eh that’s wrong
10:42:58 <cocreature> > fmap F.toList $ nonEmpty $ traverse listToMaybe []
10:43:01 <lambdabot>  error:
10:43:01 <lambdabot>      • Variable not in scope: nonEmpty :: Maybe [b0] -> f [a]
10:43:01 <lambdabot>      • Perhaps you meant data constructor ‘NonEmpty’ (imported from Lambdabot...
10:43:36 <ohko> I could just do
10:43:36 <ohko> fn [] = Nothing
10:43:37 <ohko> fn xs = traverse listToMaybe xs
10:43:49 <ohko> maybe that's better?
10:44:39 <cocreature> :t \xs -> Data.List.NonEmpty.nonEmpty =<< traverse listToMaybe xs
10:44:41 <lambdabot> [[a]] -> Maybe (GHC.Base.NonEmpty a)
10:45:09 <cocreature> That reflects the fact that you can never get back Just []
10:59:40 <dmwit> I'm with c_wraith. I bet you don't need [] to become Nothing.
11:00:11 <dmwit> :t listToMaybe . sequence
11:00:14 <lambdabot> Traversable t => t [a] -> Maybe (t a)
11:00:24 <dmwit> ^ another way
11:00:47 <ohko> dmwit: i am contemplating this and yes i think i agree
11:01:10 <lavalike> isn't that nice
11:02:00 <infandum`> Zemyla: The foldr implementation also has a stack overflow, pointing to "\" (the lambda of the foldr)
11:17:32 <infandum`> Zemyla: Ah, replacing the function BEFORE indexed did it! So it needs some fine-tuning.
11:19:57 * hackage lingo 0.1.0.0 - File extension based programming language detection  https://hackage.haskell.org/package/lingo-0.1.0.0 (tclem)
11:24:27 * hackage lingo 0.1.0.1 - File extension based programming language detection  https://hackage.haskell.org/package/lingo-0.1.0.1 (tclem)
11:28:10 <Dark_Furia> Hello! I have a question. Is there a convinien way to iterate over a list, until difference between two last elements is bigger than some epsilon?
11:29:41 <hyperisco> Dark_Furia,  join (zip . drop 1)  gives you pairs of consecutive elements
11:33:47 <Dark_Furia> Thank you:)
11:33:56 <int-e> also keep in mind that sometimes explicit recursion is the clearest way to express these ideas
11:34:26 <Dark_Furia> I want to implement Newtons method to find square root
11:35:30 <dmwit> Dark_Furia: `myIterator (x:y:rest) = if abs (y-x) < epsilon then y else myIterator (y:rest)` or so?
11:35:47 <dmwit> Looks pretty convenient to me.
11:36:25 <dmwit> You can use @-patterns to avoid the allocation implied by recursing on `y:rest`, but that's just polish.
11:37:11 <int-e> > let mySqrt x = go 1 where { go z | abs (z-z') < 0.001 = z' | otherwise = go z' where { z' = (x/z + z)/2 } } in mySqrt 2
11:37:15 <lambdabot>  1.4142135623746899
11:37:52 <dmwit> Nice!
11:39:31 <dmwit> > let hm x = go (abs (x/2)) where go z | z'==z = z | otherwise = go z' where z' = (x/z + z)/2 in hm 2
11:39:35 <lambdabot>  1.414213562373095
11:39:40 <int-e> (The point is the explicit recursion. I'd be ware of the numerics... what happens for for large x, or for negative x... tricky!)
11:40:18 <dmwit> > sqrt 2
11:40:21 <lambdabot>  1.4142135623730951
11:40:30 <int-e> and for the starting value you really should use some sort of logarithm
11:40:40 <int-e> abs (x/2) is basically saving you one iteration.
11:41:14 <dmwit> int-e: Ah, indeed.
11:42:50 <Dark_Furia> let sqrt x0 = head $ (dropWhile (abs(last xs - last . init $ xs) > x0 * 1e-6) xs where xs = iterate (newt f f') x0)
11:43:06 <Dark_Furia> why I have parse error on input where on this line?
11:43:07 <int-e> Oh, typo... I guess "be ware" is a combination of "beware" and "be wary".
11:43:41 <dmwit> Dark_Furia: `where` attaches to bindings; it is not valid in all expressions.
11:43:56 <dmwit> You may use `let` instead; or you may close the parentheses before the `where`.
11:44:19 <dmwit> (Of course, there are other problems here.)
11:44:43 <dmwit> :t decodeFloat
11:44:46 <lambdabot> RealFloat a => a -> (Integer, Int)
11:46:10 <dmwit> > let approxSqrt x = encodeFloat m (e`div`2) where (m,e) = decodeFloat x in approxSqrt 2
11:46:15 <lambdabot>  6.7108864e7
11:48:14 <dmwit> Oh, I guess you need to also approximate the sqrt of m. Bummer.
11:50:43 <dmwit> > let approxSqrtInteger = go 1 where {go acc 0 = acc; go acc n = go (acc`shiftL`1) (n`shiftR`2)}; approxSqrtDouble x = encodeFloat (approxSqrtInteger m) (e`div`2) where (m,e) = decodeFloat x in approxSqrtDouble 2
11:50:46 <lambdabot>  2.0
11:54:53 <dmwit> > let approxSqrtInteger = go 1 where {go acc n = if n <= 1 then acc else go (acc`shiftL`1) (n`shiftR`2)}; approxSqrtDouble x = encodeFloat (approxSqrtInteger m) (e`div`2) where (m,e) = decodeFloat x in approxSqrtDouble 256
11:54:56 <lambdabot>  16.0
11:55:06 <dmwit> int-e: Something log-ish. ^_^
11:57:02 <infandum`> Unfortunately I still have negative (-4%) productivity
11:57:31 <infandum`> Looks like for MUT there was 0.000s (-115.915s elapsed)
11:57:36 <infandum`> that might be doing it
11:58:12 <infandum`> Ah, perhaps it is https://gitlab.haskell.org/ghc/ghc/issues/15897
11:58:14 <dmwit> I would suggest reporting this as a bug.
11:58:21 <dmwit> ...ah, you got beat to it, maybe. =)
11:58:29 <EvanR> > let approxSqrtInteger = go 1 where {go acc n = if n <= 1 then acc else go (acc`shiftL`1) (n`shiftR`2)}; approxSqrtDouble x = encodeFloat (approxSqrtInteger m) (e`div`2) where (m,e) = decodeFloat x in approxSqrtDouble (0/0)
11:58:32 <lambdabot>  1.997919072202235e146
11:58:34 <EvanR> works
11:58:35 <infandum`> So it's probably due to -h
11:59:06 <int-e> dmwit: yeah, something like that. bonus points if you look at a couple of bits of the mantissa as well.
11:59:39 <dmwit> EvanR: Makes sense.
11:59:59 <EvanR> > 146 + 146
12:00:03 <lambdabot>  292
12:00:05 <int-e> dmwit: (That's how I'd expect FPUs to operate: have a small lookup table of approximations of the square root based on a few mantissa bits and the parity of the exponent, then do a few Newton iterations)
12:00:06 <EvanR> hmm.
12:00:11 <infandum`> Looks like there may be another spaceleak in https://github.com/ocramz/sparse-linear-algebra/blob/master/src/Data/Sparse/SpMatrix.hs for matMatUnsafeWith, does anyone see a likely leak there?
12:00:30 <int-e> dmwit: And then curse about denormals :)
12:02:19 <dmwit> Given how quickly NR converges, it might not be worth spending any extra computation looking at mantissa bits.
12:02:37 <dmwit> (On the software side. On the hardware side it's free because it can be done in parallel.)
12:03:09 <dmwit> As you say: looking at mantissa bits saves you one iteration. =P
12:03:52 <infandum`> Is there a strict pragma such that I can say this entire function is strict, but only this function?
12:04:20 <int-e> dmwit: It may actually save you a bit more (precision bits double in each iteration when you're close enough... so an 8 bit approximation can save 3 iterations over a stupid single bit one). Of course one should do the actual math :)
12:05:07 <int-e> > let it x = (1/x + x)/2 in map it [1 + 1/2^n | n <- [0..5]]
12:05:10 <lambdabot>  [1.25,1.0833333333333333,1.025,1.0069444444444444,1.0018382352941178,1.00047...
12:10:15 <int-e> > let it x = (1/x + x)/2 in [round ((-log (it (1 + 1/2^n) - 1)/log 2 - fromIntegral n)*100) | n <- [0..]] -- centibits of precision gained in first iteration for relative error 1/2^n (n = 0..).
12:10:18 <lambdabot>  [200,258,332,417,509,604,702,801,901,1000,1100,1200,1300,1400,1500,1600,1700...
12:11:57 <int-e> :t logBase
12:11:59 <lambdabot> Floating a => a -> a -> a
12:12:27 <infandum`> Assume there are no "shortcuts" and no infinite anything and everything will be evaluated eventually -- is there a downside to using too many bangpatterns other than pointlessness?
12:13:29 <jle`> infandum`: well, lazy and strict are just two different things
12:13:43 <jle`> that's like saying "if i'm just using whole numbers, is there any downside to using integer instead of double?"
12:14:27 <int-e> . o O ( Bang Bang (My Baby Shot Me Down) )
12:14:34 <jle`> there is no inherent downside about strict evaluation other than the fact that sometimes you want strict, some times you want non-strict
12:14:38 <infandum`> jle`: Depends -- if you are using functions which can result in doubles than you should not use integers.
12:14:53 <jle`> right, my point is that the situation depends on what you need
12:14:59 <infandum`> So if there are no infinite lists etc...
12:15:07 <jle`> there isn't any inherent downside to using integers other than the fact that they are integers
12:15:35 <jle`> infandum`: if you use bang patterns in a case where you meant to be lazy, i wouildn't consider that a "downside"
12:15:53 <jle`> just like if you used integers in a case where you use fractional numbers, i wouldn't conside rtha ta "downside" of using integers
12:16:07 <jle`> it's just...well, integers are not the right type in that specific situation
12:16:41 <jle`> infandum`: if you use bang patterns everywhere, then you might end up being strict in a case where *mentally*, you wanted to be non-strict
12:16:54 <jle`> like, the way you reason about the problem is assuming it's non-strict
12:17:11 <jle`> and that's not a "downside" of strict behavior, that's just using the wrong tool for the wrong job
12:17:14 <infandum`> jle`: Let's say we have sum $ fmap (+ 1) xs, and xs is spine strict, would it matter if I use $ or $!, right?
12:17:39 <infandum`> Obviously, however, if xs were a lazy list, it would make sense to use $ instead of $!
12:17:44 <infandum`> is this correct?
12:18:06 <jle`> i don't think there's a difference there as long as your Num type is strict
12:18:25 <jle`> even if xs was a lazy list
12:18:34 <jle`> hm, er sorry
12:18:45 <jle`> if xs was a lazy list and your Num type is non-strict, then it would matter
12:18:47 <infandum`> jle`: There would be a difference, as the strict spine xs would keep have to build up all memory, right?
12:18:52 <infandum`> yeah
12:19:11 <jle`> for example sum for a bounded integer type might be short-circuiting if it was implemented using foldr
12:19:16 <infandum`> like you said though, if it's spine strict it wouldn't matter
12:19:23 <collector1871> hi all, on my Arch Linux installation i have many files like : /usr/lib/ghc-8.6.5/package.conf.d/primitive-0.6.4.0-ILgywxtLpvnAOlEISPpP5b.conf or /usr/lib/ghc-8.6.5/package.conf.d/HTTP-4000.3.14-1VW1i4Z81phL0XXbl3wuji.conf . All these files are not tracked by pacman (pkg manager). Can i remove files inside /usr/lib/ghc* ?
12:19:32 <jle`> yeah, since $! only evaluates to WHNF
12:19:47 <jle`> if it was spine strict then sum could potentially waste space
12:19:53 <infandum`> jle`: Okay, I think there shouldn't be an issue then
12:19:58 <jle`> because it could ignore computing the second half of the list
12:20:07 <infandum`> Why?
12:20:21 <infandum`> it would compute the whole list either way, right?
12:20:31 <jle`> hm, you're right, either way it would compute the spine and potentially not the items in the list
12:20:31 <infandum`> but one is like a loop and the other keeps it all in memory
12:20:38 <jle`> it might make a difference if you were doing a deepseq-$!
12:20:44 <infandum`> ah
12:20:57 <dminuoso> collector1871: package.conf.d/ is the package database of ghc. Dont directly delete these directories.
12:20:58 <jle`> but yeah, in specific small circumstances like this, it makes sense to reason about strict or non-strict
12:21:00 <infandum`> I'm having the time of my life finding these leaks upstream haha
12:21:14 <dminuoso> collector1871: If you do need to interact with them, use ⌜ghc-pkg⌝
12:21:25 <jle`> it doesn't make sense to reason about strict vs. non-strict in a blanket sort of statement i think
12:21:38 <jle`> infandum`: if you're having trouble tracking down space leaks, you can maybe try turning everything strict-by-default
12:21:50 <jle`> and progressively add laziness/non-strictness
12:22:25 <infandum`> jle`: I didn't want to go that far, just maybe function by function
12:22:39 <infandum`> is there a pragma for strictness recursively within only a function
12:22:57 <collector1871> dminuoso: do you know why i have different versions of /usr/lib/ghc* for example: 8-4.2 or 8-6.5
12:23:25 <dminuoso> collector1871: No idea, honestly. How did you install ghc? pacman? ghcup? Manually?
12:23:39 <int-e> collector1871: with hyphens?
12:25:03 <collector1871> i installed package pandoc (and i am using it, very useful), and it seems pandoc has very heavy haskell dependency
12:25:08 <int-e> Two theories (of many): a) leftover from an old installation, or 2) distro packages for haskell programs that have not been updated to ghc-8.6 yet.
12:26:00 <collector1871> this is old arch installation
12:26:05 <collector1871> 4 years or more
12:26:42 <dminuoso> Oh yeah, the wonders of arch rolling release where you incrementally clutter up your system.
12:27:36 <int-e> dminuoso: mm that wasn't my experience. otoh while I did use Arch for a while I never used the distro packages for ghc stuff, except for bootstrapping my own
12:28:37 <int-e> (two reasons: one, I did actually want to have several ghc versions installed at the same time; two: I didn't want a system update to break my own ghc-compiled binaries.
12:28:40 <int-e> )
12:29:59 <__monty__> collector1871: Arch maintainers are boneheaded about haskell packaging. There's a thread on r/haskell somewhere.
12:31:35 <collector1871> https://dpaste.de/9pMU > this is the full list , (lostfiles is command to detect files not tracked by pkg manager, "orphan" files). As you can see all files are inside */package.conf.d/*
12:48:25 <Boarders> how unsafe is it to do:
12:49:01 <Boarders> \v val -> runST $ do {mv <- unsafeThaw v; write mv k val; unsafeFreeze mv}
12:49:54 <dminuoso> Boarders: Depends, do you intend to use that vector afterwards? ;)
12:50:11 <Boarders> I see
12:50:13 <c_wraith> that seems to be on the scary end. 
12:50:55 <dminuoso> I mean that seems to be just an elaborate way to do unsafePerformIO.
12:51:07 <Boarders> if you want, yes
12:51:27 <Boarders> practically speaking does it mean that if I ever call that function on a vector v then I can't expect to safely be able to use v again in my program?
12:51:49 <c_wraith> it means you can't expect any changes to v to be reflected in uses of it later. 
12:51:54 <dminuoso> Boarders: You can't reasonably predict what's going to happen
12:52:04 <c_wraith> because ghc is free to assume it doesn't change. 
12:52:27 <c_wraith> there's just so many different ways that could manifest. 
12:52:53 <dminuoso> Boarders: You get the same guarantees that unsafePerformIO gives you: none. Perhaps the effect is never carried out, maybe its carried out one time at the expected moment, perhaps its reordered, perhaps the effects are carried out multiple times in various locations.
12:53:13 <Boarders> that makes sense, thanks
12:53:46 <Boarders> which is a polymorphic container which allows better ability to perform a set operation like that
12:53:54 <Boarders> and has similarly good look up
12:54:03 <Boarders> well not constant time
12:54:07 <Boarders> but at least log n on both
12:54:22 <c_wraith> Unless you have benchmarks showing Map (or IntMap) is a problem, start there. 
12:54:58 <Boarders> Map is definitely hugely slow for the sort of thing I am doing
12:55:03 <fog> ok, i have reinstalled windows and the first thing i did was get msys2 and then download the stack installer
12:55:21 <fog> then i uninstalled msys2 because there is one that is bundled with stack
12:55:43 <fog> now how do i build libs that require unix toolchains?
12:55:58 <fog> if i open the stack mingw64 there is no cabal...
12:56:07 <c_wraith> in benchmarks? I mean, it can be slow. but unless you have benchmarks, it just sounds like making assumptions. 
12:56:55 <Boarders> I am not going to write my executable with every known container type to benchmark each of them, I have a rough estimate of the kinds of operations I am doing and how much they cost for maps
12:57:20 <Boarders> Map is hugely slower than IntMap, I have seen plenty of benchmarks showing that
12:57:56 <c_wraith> it's not always. depends on the use case. (but I also said "or IntMap", which shouldn't be ignored.) 
12:58:12 <Boarders> yes, well nevertheless this was using unboxed vectors anyway
12:58:21 <fog> hmm, there only seems to be a "sandboxed" version of ghci, that i can run with "stack ghci" but no ghci or cabal to be called from the windows command prompt
12:58:23 <phanimahesh[m]> What's the usecase?
12:58:38 <Boarders> but regardless I am not obliged to run benchmarks to prove that every known thing is not appropriate
12:58:39 <Boarders> that is silly
12:59:01 <Boarders> and not a practice I believe many actually do
12:59:30 <c_wraith> saying "Map is slow" when the problem is elsewhere is very common, though. 
12:59:45 <fog> Boarders: good to be able to though, you could set up a way to switch to various implementations easily incase you want to test it
13:00:27 <fog> its common functionality right? maybe you could use backpack!
13:00:59 <phanimahesh[m]> You don't have to run benchmarks for everything. Reasonable arguments for why a certain datatype won't work are usually good enough. That depends on the usecase. And sometimes the hidden constant factors make seemingly worse datatypes perform faster for some sizes of data
13:01:04 <Boarders> I would not use backpack as I have had no luck with boot files
13:01:17 <Boarders> but a common API for list-like containers would be quite nice
13:01:46 <Boarders> the only problem is it should ideally include things like DList or other delayed or CPS style representations
13:01:47 <fog> does anyone know if i should install *another* ghc other than the one that stack built when doing "stack setup" ?
13:01:51 <Boarders> and those are really quite different
13:01:55 <hexagoxel> Boarders: but you don't need to use the input `v` again in your program, right? you only use `v'` that is returned from runST.
13:02:29 <fog> Boarders: but they still have interfaces like !! and ++
13:02:40 <Boarders> hexagoxel: unclear but given what my betters of irc have said, I wouldn't feel confident about it
13:02:49 <ysangkok> fog: you can do it if you want to, stack installs the ghc (not builds) to a directory that isn't global.
13:03:00 <fog> well, those functions could be used to *define* an interface...
13:03:04 <Boarders> fog: true but they dont' have something like splitAt
13:03:11 * hexagoxel is a bit confused that dminuoso and c_wraith only seem to consider one "instance" of a vector around this example
13:03:31 <fog> Boarders: thats no problem, you can have an *incomple* backpack
13:03:50 <fog> the benchmark would just be over the least functionality you wanted to use for some particular thing
13:03:53 <ysangkok> fog: you can find the ghc that stack downloads and link it to %PATH%
13:04:17 <fog> what about cabal?
13:04:32 <dminuoso> hexagoxel: What did you have in mind?
13:05:58 <hexagoxel> if you have v' = runST (.. unsafe unsafe v), then using v' should be safe, right?
13:06:18 <dminuoso> hexagoxel: Depends on what you mean by safe, really.
13:06:21 <fog> stack seems to be placing things in; AppData\Local\Programs\stack\x86_64-windows
13:06:24 <hexagoxel> the problem is if you use v "again", where "again" refers to evaluation order
13:06:32 <fog> there is ghc and msys2 but no cabal
13:07:10 <fog> though there is a Cabal directory in the ghc/lib
13:07:39 <hexagoxel> "safe" as in "behaves similarly to an IntMap that you modified purely, without any unsafe* involved"
13:07:58 <dminuoso> hexagoxel: The problem is that you're thawing and modifying the original without copying
13:08:03 <dminuoso> hexagoxel: So you are mutating references
13:08:21 <dminuoso> And depending on how you trip into thunks, this could potentially happen multiple times too.
13:08:34 <hexagoxel> which affects v, not v'
13:08:43 <dminuoso> hexagoxel: it affects v' too.
13:09:23 <dminuoso> hexagoxel: Imagine for some reason you have two uses of v' and one gets inlined.
13:10:33 <dminuoso> Or both get inlined.
13:12:16 <hexagoxel> and for both you access the value at index k, and get different results?
13:12:30 <dminuoso> hexagoxel: Potentially, yes?
13:14:22 <dminuoso> hexagoxel: If you have ⌜f = ... v' ...⌝ and ⌜g = ... v' ...⌝, and v' gets inlined into both, then you might observe different values. Perhaps you can even get into fancy race conditions because the operation is not atomic.
13:14:50 <dminuoso> I dont see how this is anything but a recipe for disaster. ;)
13:15:36 <hexagoxel> but at worst, you mutate the underlying vector twice, setting the value at index `k` twice.. to the same value
13:15:40 <fog> i added AppData\Local\Programs\stack\x86_64-windows\ghc-8.6.5\bin to the PATH and now i can open ghci from the command line wihtout having to type "stack ghci", but there is still no cabal. do i need cabal if using stack? how would i build a package that needs unix like network?
13:16:16 <hexagoxel> to the same *thunk
13:16:29 <dminuoso> hexagoxel: Is that the worst? I dont know enough about GHC, but I'd assume its reasonable that you could trip into a race condition if you have concurrent mutation going on.
13:16:54 <dminuoso> hexagoxel: And it wouldnt just be double mutation, it'd be one part seeing a single mutation, the next perhaps 2 mutations...
13:17:10 <dminuoso> So v' might mean different things in different parts of the program.
13:21:59 <hexagoxel> why does it matter if you set a value twice? If I had a proper mutable vector, I would really assume that `race (write vect k v) (write vect k v)` would behave just like `write vect k v`.
13:24:08 <MarcelineVQ> I thought ST was for avoiding this sort of situation
13:28:34 <hexagoxel> I thought rust was for safe, low-level mutation code :>
13:29:30 <fog> im confused, are you talking about Map still?
13:30:41 <fog> is the idea to compare the "interface" / "api" to the immutable and mutable varients of list?
13:31:38 <fog> like, i guess with the freeze/thaw calls etc they have differences in their functionality, but they still have a commonality though right?
13:33:14 <fog> or is the point that if you were trying to benchmark them then you would *need* the extra functionality to change if it was making copies or mutating or whatver
13:34:23 <geekosaur> only if the write is guaranteed atomic
13:37:06 <dminuoso> hexagoxel: Ah I guess multiple writes is not an issue. But you could have situations where v' might in one place, refer to an updated vector, and in another place refer to an unupdated vector.
13:37:12 <dmwit> hexagoxel: The unsafe freezing and thawing also changes some marks that the GC looks at. I could imagine some oddities there, where both mark it as mutable, then one marks it as immutable, then GC fires, then mutation happens again and maybe now we have some wrong pointers or something?
13:37:39 <dmwit> hexagoxel: So I think you'd definitely want to NOINLINE v'.
13:38:16 <fog> ok, so i did "stack install network" and now when i enter ghci with "stack ghci" i can write :m Network.Socket
13:39:01 <fog> but if i just type "ghci" in either the windows or mingw terminal, then :m Network.Socket throws an error
13:39:44 <infandum`> How can I have stack.yaml extra-deps point to https://github.com/haskell/containers as a package?
13:40:00 <infandum`> The issue is that the cabal file is within the containers folder on that repository
13:40:42 <fog> dont you use a cabal.project file for that?
13:40:50 <hexagoxel> fog: we don't really compare two different APIs. As I understand it, the goal is to get the performance of a mutating container behind an interface that pretends to be pure. And you can't, not safely. The question is just "how unsafe".
13:41:40 * hexagoxel still does not see how the atomicity would change things
13:41:55 <fog> but why not just extend the API in that case to include the extra functionality to get the safe behaviour?
13:42:18 <EvanR> that's a curious dichotomy, mutable "containers" hiding behind a pure interface happens all over haskell's implementation. But you can't do the same thing from inside the language?
13:42:28 <fog> hmm, i guess the benchmarks would need to be updated then also to use these extra calls
13:44:24 <fog> i dont get what it means anyway about atomicity and freeze/thaw mutability... you would just have something like a lens with you could use to "edit" the value at some location....
13:44:36 <hexagoxel> dminuoso: you mean, because one of them has not been forced yet?
13:44:37 <fog> i guess if its frozen it just doesnt update right?
13:45:24 <fog> so if its using it as if it were pure, then there would be no concurrent editing happening elsewhere to require these aspects right?
13:46:00 <fog> oh, its about strictness?
13:46:28 <fog> criterion has something to do with evaluating it into whnf 
13:46:42 <fog> or just nf... i cant remember 
13:47:10 <hexagoxel> dmwit: if that was really unsafe, then my `race` example would be in the same way unsafe, would it not?
13:47:36 <fog> anyway, the point is just that the benchmarks for the immutable containers would just work for the mutable versions right? because they wouldnt have any race conditions or anything
13:48:53 <hexagoxel> EvanR: "all over haskell's implementation" just means "how thunks are evaluated", is it not? And that is fairly contained. Am I missing some other stuff?
13:48:56 <fog> its just one thread editing one container, if its copied to update it or it just stores the edit as an unevaluated thunk or if there is a mutable thing under the hood shouldnt change anything...
13:54:03 <fog> basically the benchmarks wouldnt be getting any advantage from the "sharing" capability of the mutable container, but for a benchmark designed on the restricted use case specified by the benchmarks for immutable list variants, it shoudnt matter
13:55:35 <fog> the idea basically is that the "restricted" functionality of the "common" aspects of these various interfaces fortunately in this case is not affected by the extra functionality of the different implementations
13:56:56 <fog> still confused about backpack to do this though... like a class should be enough...
13:57:15 <fog> the only time backpack seems nesacary is when the interface itself consists of classes
13:58:58 <orzo> I currently have an associated type family declared "type Scalar v :: *" within a class definition.  I'm using a default signature for that type to make declaring instances easier.  But it so happens I've encountered an error I'm trying to partially apply that Scalar function.  In order to satisfy the compiler I need a family declared with * -> *.  However, this would ruin my defaulting.	Is
13:59:04 <orzo> there anyway to recover the defaulting behavior?
13:59:45 <orzo> i have a lot of instances using the default
14:00:05 <orzo> it's annoying and verbose to change them all
14:02:01 <fog> you cant have a partially applied type family 
14:02:25 <orzo> yeah, but i can change the family to *->* and take it out od the class
14:02:34 <orzo> then it's not partially applied
14:02:55 <orzo> but every instance whrer i used the default now needs an explicit declaration
14:03:03 <fog> did you try defunctionalising?
14:03:12 <orzo> what's that?
14:03:41 <fog> its where you just have a datatype which pretends it has the partially applied type
14:03:53 <fog> there is documentation on it its pretty hard to describe
14:04:17 <fog> i cant understand from your description thought if its the correct solution
14:04:52 <fog> but its something to be aware of when trying to define paritally applied type families, and ends up at singletons
14:06:05 <orzo> i have a class (ModuleOverIntegers v) with a member (type Scalar v :: *) but i'm trying to write a function that requires the constraint (ForEach ((~) (Scalar x)) (Map Scalar xs)).
14:06:10 <hexagoxel> (of course me plainly rejecting some counterarguments in no way confirms my idea that this usage of unsafe* functions would be safe.)
14:06:58 <orzo> The  ForEach maps a constraint function over a type-level list of types.  The Map function applies a type function to a list of types to get a new lit of types
14:07:05 <hexagoxel> (but I _do_ think that coming up with a working example that breaks (reading different values from the save vector etc.) is a bit less trivial than what you have presented so far :p)
14:07:16 <orzo> i cant do the Map though because that's partially applying the Scalar
14:08:07 <orzo> the solution to me seems to change Scalar to be a stand-alone type family with kind * -> *
14:08:34 <orzo> it's just that it would ruin my defaulting system
14:08:34 <fog> yes, you need a "defunctionalisation symbol" to define your FMap
14:08:40 <MarcelineVQ> infandum`: https://gist.github.com/MarcelineVQ/104b5d3f0ba91ffbc4e2a2859beb3c2a
14:09:52 <fog> it takes an argument of type (* ~> *)  instead of (* -> *)
14:09:52 <fog> and has uses "apply" written as @@
14:09:52 <fog> there is a paper, ill find it one sec
14:10:38 <fog> https://repository.brynmawr.edu/cgi/viewcontent.cgi?article=1000&context=compsci_pubs
14:10:57 <fog> Promoting Functions to Type Families in Haskell
14:11:17 <orzo> thanks, ill read that
14:13:47 <fog> so if im using stack do i need cabal at all? or is the project.caba and cabal files redundant?
14:14:02 <fog> cabal.project*
14:14:09 <MarcelineVQ> fog: did you check the stack documentation?
14:14:29 <fog> i found this;
14:14:30 <fog> https://docs.haskellstack.org/en/stable/stack_yaml_vs_cabal_package_file/
14:14:33 <sclv> they are two different tools. you can use one or the other
14:14:36 <sclv> you get to pick
14:14:38 <MarcelineVQ> That's the important one
14:15:14 <MarcelineVQ> cabal.project files aren't used by stack but the myproject.cabal file is
14:15:22 <fog> i was having trouble with cabal and was advised to try stack, and i dont want to mess up the stack environement by trying to mix them together if thats not how they are supposed to be used
14:15:30 <MarcelineVQ> and you don't generally need cabal-install if you use stack
14:15:38 <sclv> and you don't need stack if you use cabal
14:15:57 <sclv> some packages are built to be developed on with one or the other, but you can always write the missing bit by hand to do it the other way
14:16:27 <fog> ok so i still need to write cabal files for each package, but do i need the actual cabal tool to do eg cabal v2-build, or do i just replace those calls with stack build for example, like how i can use stack install somepackage...
14:17:29 <sclv> have you read the stack and cabal manuals?
14:17:46 <fog> yeah ill just try it and see i guess
14:18:04 <fog> shortest path and all that
14:19:38 <fog> but yeah, just reading that link above
14:26:02 <fog> huh those instructions are confusing...
14:26:30 <fog> seems like i only need to specify packages in the stack.yaml if they are not in a snapshot via resolver
14:32:23 <ysangkok> i get a "missing binary operator before (" error on a line like "#if !(MIN_VERSION_base(4,5,0))", but only when building the executable, not when building the library
14:33:06 <ysangkok> i thought it was because i didn't have the CPP extension enabled, but it can't be that, since the error message says "`gcc' failed in phase `C pre-processor'. (Exit code: 1)"
14:33:37 <ysangkok> i googled the error and it seems like there are a bunch of reasons why you could get this error
14:35:01 <ysangkok> aaaaah, it could be base missing from build-depends... so i get the CPP error even though it is after the import because CPP is running before the haskell syntax is checked...
14:40:14 <fog> stack doesnt seem to have a "get" so i donwloaded to broken dependency haskoin-utils to build it locally
14:41:54 <fog> i did stack init --omit-packages (it was complaining about it being totally ancient), and then stack build haskoin-utils, which required writing allow-newer: true in the st/config.yaml
14:42:47 <fog> that seemed to work, but it spent ages building dependencies, and to check to make sure it wasnt just installing them locally i deleted the directory and unziped a clean copy
14:43:06 <fog> init and build then started it building all the packages again
14:43:16 <fog> how do i get it to build the packages it needs globally?
14:44:09 <ysangkok> i don't think stack really does anything globally
14:44:13 <MarcelineVQ> fog: stack does have a get
14:44:15 <MarcelineVQ> stack --help
14:44:37 <ysangkok> fog: when all of this is over you should have a look at nix :)
14:44:52 <fog> i saw that nix is not the thing for this project
14:45:09 <ysangkok> well nix is definitely the thing for reproducable environments
14:46:11 <fog> when i did stack install network, this was a global install
14:46:33 <ysangkok> i think that is specific to the current resolver 
14:46:56 <fog> i cant use any respolver thats why it needs the ommit-packages flag
14:47:12 <fog> it is such an old package it would require a previous version of ghc
14:47:23 <fog> the reason its broken is it was before monad applicative
14:47:55 <fog> im just trying to add this superclass to the source and build it globally so the things downstream of it will build as usual 
14:48:13 <fog> i want to be able to run stack install haskoin
14:48:28 <ysangkok> hmmm ok seems reasonable
14:48:33 <ysangkok> what is the ancient package?
14:48:41 <fog> haskoin-utils
14:49:10 <fog> a dependency of haskoin, a branch depreciated in favour of haskoin-core
14:49:46 <fog> it has a pure implementation of an the eliptic curve cryptography libary which i cant build the c version of in windows
14:51:04 <ysangkok> funny, i am just working on secp256k1 myself
14:52:05 <ysangkok> i applaud your efforts, but secp256k1 is a well-maintained c-library, it should definitely be possible to build it on windows
14:52:07 <fog> right, its the "build steps" at https://github.com/bitcoin-core/secp256k1
14:52:45 <ysangkok> there is an msvc adaptation of bitcoin-core, which needs secp256k1: https://github.com/kobake/bitcoin-msvc
14:52:51 <fog> they fail on windows, mingw64 has its own version of libtools which seems unable to manage
14:54:24 <fog> you think the visual studio build could work huh
14:54:40 <ysangkok> nuget has secp256k1 packaged too: https://www.nuget.org/packages?q=secp256k1
14:55:23 <fog> whats that!? already built things?
14:55:31 <ysangkok> well, i just think doing ECC math in pure haskell is a futile effort. it will be a lot slower than secp256k1, and it will be really hard to make constnnt-time. it only has educational value.
14:55:58 <MarcelineVQ> fog: doesn't mysys2 and such have pacman? pacman might have your lib
14:56:27 <fog> i hadnt thought of pacmaning the lib... only to pacman the build tools to build the lib off github which failed
14:57:02 <MarcelineVQ> failing that, what you need to do is bump versions in the relevant cabal files (in haskoin and haskoin-util) and fix the errors you get from doing so. --omit-packages and other flags aren't going to get you there
14:57:03 <fog> anyway, the project is to replace all the unpure stuff via compartmentalised backpacks
14:57:18 <MarcelineVQ> There's no compiler flag for "make my library modern"
14:57:37 <fog> i have a version which runs the eliptic curve stuff via open-ssh
14:58:20 <fog> i dont really see why building the c lib for this specific unpure haskell implementation would be part of the plan
14:59:22 <fog> MarcelineVQ: its just adding a one line applicative instance...
14:59:40 <ysangkok> your project is to get rid of "unpure" cryptography simply because it is unpure? and then you have an implementation that is suspectible to timing attacks. what is the value of this? is it a university project?
15:00:21 <fog> im not sure i understand this fear
15:00:24 <MarcelineVQ> If it's just that then bump the required versions, or remove the version requirements (other than bumped up base version), it'll work just fine
15:00:43 <MarcelineVQ> it's probbaly not just that, but if it's that easy then it's that easy
15:01:03 <fog> well now its complaing about pbkdf
15:01:04 <MarcelineVQ> *fix that and bump up the required versions,
15:01:22 <ysangkok> fog: you don't understand why timing attacks can be a problem?
15:02:18 <ysangkok> well, i don't understand what's wrong with properly wrapped unpure code. secp256k1-haskell by xenog works great on my machine. if it doesn't build on windows, that can be fixed
15:03:51 <fog> well its got the word attack in the name, so i guess i get that it could be a problem
15:04:15 <fog> but i dont know what it is or how to not be affected by it
15:04:23 <fog> like, why is the haskell version bad?
15:05:38 <fog> it *can* be fixed, but it isnt, and thats the problem...
15:06:28 <fog> but your right, if i can just get the already built version thats actually a shorter path than all this building via stack
15:06:46 <ysangkok> if you are implementing ECC math in haskell yourself, you are almost certainly not going to make it as fast as secp256k1, that is the first problem.
15:07:03 <fog> but if it requires visual studio...
15:07:44 <fog> small performance differences and being vulnerable to attack are seemingly different levels of badness
15:08:10 <ysangkok> the second problem is timing attacks, you will have to look that up. it is harder to reason about the runtime of haskell than c, that is why it is easier to make code suspectible to timing attacks in haskell.
15:08:39 <ysangkok> look at the amount of effort that went into secp256k1 and ask yourself if you have the same kind of knowledge around ECC math.
15:09:04 <fog> googling it shows this; http://hackage.haskell.org/package/eccrypto
15:09:27 <fog> effort to make a comple library is one thing, it being insecure is another
15:10:14 <fog> the implementation in haskoin is very simple, its just some biginteger sums its fine
15:10:14 <ysangkok> yeah, and i assure you that your time is better spent working on the build system than reimplementing the ECC math
15:10:40 <fog> its already implemented, im just trying to build it... or is that what you were saying
15:10:55 <boj> that is exactly what they are saying
15:11:45 <fog> i mean, like, how is timing a thing!? its not like someone is timing how long things take to do on my machine!
15:12:02 * boj sighs
15:12:35 <fog> eg its use in haskoin is just to make a public private key pair
15:12:40 <fog> you can do that offline
15:12:51 <fog> i cant see how performance could possibly enter
15:12:54 <MarcelineVQ> you gotta pick one target fen, bouncing around just ends you back up where you started
15:13:04 <MarcelineVQ> What problem do you want to solve today?
15:13:41 <fog> currently im defending using pure haskell eliptic curve cryptography via an ancient library im trying to build in stack
15:13:51 --- mode: ChanServ set +o shapr
15:16:28 <fog> its not vulnerable to timing attacks since its not leaking information in response to queries... but thanks for pointing out the concept, maybe for things like https certificates it might be more critical 
15:18:51 <ysangkok> well i guess this is motivation for me to fix secp256k1-haskell on windows then...
15:19:56 <fog> but thats an issue with mingw building a c lib, nothing to do with haskell... and if its buildable via VC then its not exactly broken
15:20:34 <fog> if i really wanted to use haskoin-core it would just have to be via a linux VM
15:21:00 <ysangkok> but if i stack install a library with native lib requirements on windows, doesn't stack have some way of building those requirements?
15:21:27 <fog> normally it would just throw a missing c lib error
15:21:28 <ysangkok> i know cryptonite packages c-files in a source directory called cbits
15:22:02 <ysangkok> fog: i think the package author can decide whether to package the c sources or not. so it could be made easier for sure
15:22:05 <fog> if it has FFI sometimes the c source is bundled alongside the haskell source
15:22:40 <fog> but if its an external lib like SDL or something, it requires these to be installed and visible 
15:23:10 <ysangkok> yeah ok, but secp256k1 is tiny and has no platform dependencies, it is easy to bundle and build
15:24:28 <MarcelineVQ> To re-confirm, what problem did you want to solve today?
15:26:38 <fog> thats weird, i edited the .hs file at; 
15:26:49 <fog> Network\Haskoin\Util\BuildMonad.hs:122:10:
15:26:55 <fog> but it still throws an error
15:27:05 <fog> does stack cache a previous build attempt or something?
15:27:42 <MarcelineVQ> It can usually tell when files have changed, you can stack clean or stack clean --full to make sure nothing's confusing it
15:27:45 <fog> i ran stack install haskoin to get it to build all the other dependencies globally
15:28:31 <fog> the --full option gives a permission error
15:28:54 <MarcelineVQ> Not quite globally, just for the current snapsnot/resolver version. stack has a store for reach snapshot version.
15:29:01 <MarcelineVQ> oh joy permission errors
15:29:38 <fog> so its cached that the dependency haskoin-util should be obtained from the hackage repo instead of the local version
15:29:43 <fog> thats annoying
15:30:02 <EvanR> you could also static link SDL
15:31:48 <fog> is there a way i can edit where its trying to obtain it from?
15:32:05 <fog> i would like to not have it forget all the other dependencies it installed
15:33:28 <MarcelineVQ> Telling stack where to get things is the purpose of the extra-deps section in the stack.yam
15:35:21 <MarcelineVQ> wait uh, why are you building haskcoin-util ?
15:38:17 <MarcelineVQ> "<fog> haskoin-utils <fog> a dependency of haskoin," haskoin doesn't need util, haskoin replaces haskoin-util "haskoin-util: Deprecated. in favor of haskoin"
15:38:29 <fog> thats the tarball i obtained, im trying to add the missing applicative instances
15:39:44 <fog> oh crap!
15:39:47 <fog> your totally right
15:39:58 <fog> it doesnt even have the libs i needed
15:40:06 <fog> total confusion, thanks
15:42:10 <fog> ha! haskoin has a similar error but with nfdata and generics, ok ill try to work on that instead...
15:42:25 <fog> more difficult instance...
15:42:32 <MarcelineVQ> should be googleable
15:46:10 <xenon-> I'm trying to defeat a website with seemingly pretty sophisticated anti-scraping code. what library do you recommend? selenium? puppeteer? something else?
15:46:42 <ysangkok> xenon-: i used this the other day: https://github.com/tatut/clj-chrome-devtools
15:46:55 <ysangkok> xenon-: not haskell but works :)
15:47:14 <ysangkok> xenon-: selenium would work for you, but i don't know if you can find any nice haskell bindings
15:47:42 <solonarv> there are haskell bindings IIRC
15:47:50 <solonarv> but I don't know if they are nice
15:48:19 <fog> hmm, stack in efforts to be reporducable is trying to build an old version of ghc... should i prevent it from doing so to try and fix the instance?
15:48:23 <ysangkok> now that chrome has it's own remoting interface, and so many browsers are based on chromium, i don't know if the extra layer that selenium is, is worth it
15:49:10 <fog> assuming it is, how do i get stack to just use the new version of ghc?
15:49:26 <ysangkok> fog: adjust the resolver in stack.yaml
15:51:14 <fog> i added;
15:51:15 <fog> resolver: nightly-2019-08-19
15:51:30 <MarcelineVQ> I'd just use lts-14.1 myself
15:52:11 <fog> well it still says its incompatible with either of those because of its old ghc
15:52:20 <MarcelineVQ> what says
15:52:40 <MarcelineVQ> That is to say,what did you type to make it say this thing, and what was the thing said
15:52:42 <fog> stack init has generated a stack.yaml with a coomented out line saying;
15:52:43 <fog> # resolver: ghc-7.10.2
15:52:52 <MarcelineVQ> don't bother with init
15:53:33 <MarcelineVQ> make a stack.yaml with the line "resolver: lts-14.1" and remove the version requirements from everything in haskoin.cabal except base, then try a stack build
15:53:53 <fog> ok ill re unzip it
15:53:54 <MarcelineVQ> Then follow the error it gives you
15:54:04 <MarcelineVQ> re-unzip?
15:54:17 <fog> i downloaded the tarball from the hackage page
15:54:33 <fog> so i can get a clean version by unziping that again
15:54:40 <MarcelineVQ> ah, I mentioned earlier than stack has a 'get'. it's called stack unpack
15:54:57 <fog> oh ok, i tried the help page but didnt see "get"
15:59:03 <fog> wouldnt it be faster to just add "allow-newer: true" in the stack.yaml ?
16:01:00 <MarcelineVQ> if that works sure, I've nevered looked into exactly what it implies
16:01:34 <fog> i assume it does something similar to --allow-new in cabal command line options
16:01:53 <fog> which stops it complaining about wrong versions of base etc
16:02:23 <fog> seems like a better option than --force-reinstalls which would break everything
16:10:46 <dmwit> hexagoxel: No, I don't think so; your race example doesn't include any changes to the GC marks.
16:15:30 <fog> now it says Could not find module `Control.Monad.Trans.Either'
16:16:14 <fog> and i cant do :m Control.Monad.Trans.Either in ghci
16:16:40 <MarcelineVQ> does it still do that if you remove the versions of things that aren't base instead of using --allow-newer?
16:16:43 <fog> when i write "stack install either" it does nothing
16:18:02 <MarcelineVQ> Control.Monad.Trans.Either is probbaly deprecated out of existence, I don't see it on hoogle. anyway that's not how stack works, you don't 'install' things to make them available
16:18:25 <fog> yeah, i set allow-newer: true in the stack.yaml instead of deleting the version flags in the cabal file
16:18:25 <fog> which works
16:18:25 <fog> it was producing the same error on the version where i tried this before reobtaining a clean version using stack unpack
16:18:35 <MarcelineVQ> To make something available to your project you add it to the build deps in your cabal file
16:18:43 <fog> its already there
16:18:57 <fog> i just wanted to try and use it in ghci
16:19:14 <MarcelineVQ> stack ghci --package either is a good way to do that
16:20:12 <fog> that throws the same error
16:20:40 <MarcelineVQ> what is 'that' and what is the error
16:20:56 <fog> oh wait, i was still in the haskoin directory
16:21:13 <fog>  Could not find module `Control.Monad.Trans.Either'
16:21:36 <fog> it was trying to build the project for some reason when i wrote "stack ghci --package either"
16:23:13 <fog> in a different dir it complains about not having a stack.yaml to read to find the packages or extra-deps
16:23:36 <MarcelineVQ> but only complains right, it's not an error?
16:23:51 <fog> well it refuses to open ghci
16:24:05 <fog> and if i open it and try :m Control.Monad.Trans.Either
16:24:13 <fog> it says it cant find it
16:24:21 <fog> and if i try to install it it just doesnt do anything
16:24:24 <MarcelineVQ> why did you expect it to?
16:24:52 <MarcelineVQ> That is to say, more plainly, why did you expect 'either' to give you that module?
16:24:55 <fog> because when i did stack install network i could then open ghci and write :m Network.Socket
16:25:50 <fog> https://hackage.haskell.org/package/either-4.4.1
16:26:01 <fog> hmm, the newer versions dont have that
16:26:04 <MarcelineVQ> is that the version in your resolver?
16:26:15 <fog> https://hackage.haskell.org/package/either-5.0.1.1
16:26:26 <MarcelineVQ> This is what I meant by deprecated out of existence
16:26:33 <fog> ah ok
16:26:51 <fog> but the respolver is just a nightly build, so i point that to whenever this was active?
16:27:19 <fog> its resolver: 14.1 
16:27:30 <fog> so thats trying to get the newest version
16:28:00 <fog> if i do stack install either-4.4.1 how do i get it to use that installed version?
16:28:05 <MarcelineVQ> That's an option to check though chances are it'll restrict you quite a bit in what ghc you can use, or you could update haskoin to work with the newer things
16:28:26 <MarcelineVQ> let's see what the last lts version to have 4.4.1 is..
16:30:05 <fog> there is no stack.yaml in; https://hackage.haskell.org/package/either-4.4.1/src/
16:30:41 <fog> it says; Last success reported on 2015-05-29
16:30:43 <MarcelineVQ> That's not required
16:30:51 <fog> ill try that nightly build?
16:31:01 <fog> i was just looking for the lts 
16:31:24 <MarcelineVQ> you can get a list here https://www.stackage.org/package/either/snapshots and search for 4.4.1
16:32:06 <MarcelineVQ> which seems to be lts-9.21, which is ghc 8.0.2
16:32:21 <fog> argh then it starts building an old ghc!!
16:32:28 <MarcelineVQ> yes it would
16:33:13 <fog> well i guess unless i wanted to change it to use the more up to date library im stuck with it doing that?
16:33:30 <MarcelineVQ> Pretty much
16:34:15 <fog> no way of getting it to use the more up to date version thats already installed?
16:34:38 <MarcelineVQ> more up to date version of what?
16:34:43 <fog> ghc
16:35:09 <c_wraith> ghc version is a rather critical part of a stack resolver. 
16:35:13 <MarcelineVQ> yes, but you'd need to use more up to date libraries
16:36:07 <fog> i dont want to have to wait for it to build ghc-8.0.2, or have many versions... i just want to use the global ghc build
16:36:19 <fog> the old libraries still build on the new ghc
16:36:41 <fog> its not like they are from before applicative monad
16:37:05 <fog> if it did, then i would change the source
16:40:24 <MarcelineVQ> "<fog> if i do stack install either-4.4.1 how do i get it to use that installed version?" This isn't a thing, it's not how stack works. stack install either-4.4.1 does not install either-4.4.1 globally, in fact it doesn't install either-4.4.1 at all, it's a terrible name. it builds either-4.4.1, this happens to put the built either-4.4.1 in the store of the snapshot (resolver) that 4.1.1 came from, the store specific to lts-9.21, it 
16:40:24 <MarcelineVQ> then copies any exectuables the package might have into a particular directory. it has no bearing on your project what-so-ever because what's available to your project is solely determined by your stack.yaml and your myproject.cabal file
16:42:46 <fog> ok, so it will never use a globally installed version even if there was such a thing, it will just use the resolver which cant be made to point to an old package...
16:43:16 <fog> like, i cant use tonights nightly build to get it to use the most recent ghc, but have it also use a locally built library
16:44:17 <fog> i guess that saves the possibility of going wrong, ie it gives *reporoducable* builds, but it does not give things which bulid with the current version of ghc
16:45:17 <MarcelineVQ> "<fog> ... it will just use the resolver which cant be made to point to an old package..." You can specify that you want a specific package, extra-deps is for that which I mentioned earlier. a problem is that older packages can incur older bounds
16:45:25 <fog> if it were cabal i could say force reinstalls, and it would use the current ghc and just get the respective libs
16:46:27 <MarcelineVQ> you can try to add either-4.4.1 to extra deps, idk if it'll work out, it might ask for other things to be added as well, but if it starts to ask for things that come with ghc it's a wash
16:46:53 <fog> well the previous lts with the 8.0.2 ghc didnt work
16:47:20 <fog> While building package async-2.1.1.1 Exit failiure 1
16:47:28 <fog> :-(
16:48:12 <MarcelineVQ> What was the rest of the error
16:50:20 <fog> well im trying with the extra-deps so its a different error
16:50:24 <fog> seems hopeless now
16:50:40 <fog> it fails saying that NFData and generics error
16:50:49 <fog> but its from the json-rpc package
16:50:59 <fog> i dont want to have to try and locally build that too...
16:51:14 <fog> and it seems that the version of either isnt even working!
16:51:33 <fog> Not in scope: type variable `p' either > | either > 120 | type Iso s t a b = (Profunctor p, Functor f) => p a (f b) -> p s (f t)
16:51:59 <fog> that just plain doesnt typecheck! nothing to do with versions... in no time would that ever be correct
16:52:13 <fog> i swear this build is impossible...
16:54:18 <fog> what a palaver 
16:54:25 <fog> thanks for your help
16:54:50 * nfd sees "NFData"
16:54:56 <nfd> hmmm
17:21:28 * hackage sensu-run 0.7.0.3 - A tool to send command execution results to Sensu  https://hackage.haskell.org/package/sensu-run-0.7.0.3 (MitsutoshiAoe)
17:38:26 <M2en[m]> Is a type constructor a higher-kinded type?
17:40:35 <hpc> it's just parameterized
17:40:41 <hpc> Either is more like (+) than it is like fmap
17:40:58 <hpc> usually
17:41:09 <hpc> it could be like fmap, it just depends on what it is
17:48:26 <libertyprime> is a let construct not an expression? http://ix.io/1SMm
17:54:12 <jackdk> libertyprime: let ... in is an expression. let on its own in a do-block is not
18:08:27 * hackage serverless-haskell 0.8.10 - Deploying Haskell code onto AWS Lambda using Serverless  https://hackage.haskell.org/package/serverless-haskell-0.8.10 (AlexeyKotlyarov)
18:38:20 <dmwit> M2en[m]: Not necessarily. Bool is a type constructor with a very simple kind.
18:39:36 <dmwit> Maybe is a type constructor of kind * -> *; its order is 1. Whether that qualifies as "higher-kinded" depends on whether your "higher" means "higher than 0" or "higher than 1" (and different people choose differently here).
18:39:59 <dmwit> N.B. `Either Int` is not a type constructor, even though it has an order-1 kind.
18:40:05 <jle`> M2en[m]: a type constructor is a syntactic construct, that can represent something higher-kinded or not higher-kinded
18:40:43 <dmwit> (or, spelling that sentence differently: ...even though it has an arrow in its kind.)
18:50:23 <M2en[m]> jle`: Right, like a type constant or unary type constructor are not higher-kinded.
19:01:43 * ski wouldn't call `not' higher-order, but would so call `interact'
19:02:16 <ski> (and ditto for `Maybe' vs. `Fix')
19:09:05 <dmwit> ski: I'd like to briefly play devil's advocate and provide a point in favor of "`Maybe` is higher-kinded".
19:09:27 <dmwit> ski: We don't think of order-1 functions as higher-order, because pretty much every language from C up has order-1 functions.
19:09:54 <dmwit> But most of the languages that were popular at the time the terminology were forming didn't have order-2 functions. So those qualify as higher-order.
19:10:16 <dmwit> Now at the type level, C and many of the other popular languages of the time didn't even have order-1 types.
19:10:31 <dmwit> So for a lot of people, making it to order 1 was already higher-kinded than they were used to.
19:11:35 <dmwit> e.g. it was a big innovation when Java started allowing types to be parameterized; C++ was a big deal in part because of its parameterization; it was a time when that was an exciting innovation, not a background idea that every language just had by default.
19:40:55 <porrifolius> Hi, I'm trying to understand practical application of category theory, so... questions!
19:41:14 <porrifolius> A category is partly defined by the class Ob(C) of objects it contains.  Naively I think in terms of a set of objects, but it could be a proper class
19:41:14 <porrifolius> I don't think I understand 'proper class'... so the same object could be in the category twice?  With different morphisms to/from each occurrence?  What is an example of a category over a proper class?
19:42:04 <jusss> what is an action?
19:42:50 <jusss> what is a context which related with monad?
19:43:58 <heatsink> An action isn't Haskell terminology, but some people use "action" as a metaphor
19:45:10 <heatsink> It is helpful to think about values of some monad types, such as IO, as actions that can be executed.
19:45:58 <heatsink> For example, when 'getLine' runs, it reads a string and returns it.  You could call getLine an IO action.
19:46:15 <jusss> heatsink: why not just call it a function?
19:46:39 <heatsink> getLine is not a function
19:46:44 <heatsink> You can't pass arguments to it
19:46:54 <heatsink> This is an error:
19:46:55 <heatsink> > getLine "hello"
19:46:58 <lambdabot>  error:
19:46:58 <lambdabot>      • Couldn't match expected type ‘[Char] -> t’
19:46:58 <lambdabot>                    with actual type ‘IO String’
19:48:10 <jusss> :t getLine
19:48:12 <lambdabot> IO String
19:48:51 <jusss> heatsink: if it's not a function then why it can run?
19:50:00 <jusss> :t (Just 3)
19:50:03 <lambdabot> Num a => Maybe a
19:50:29 <jusss> :t (Just Int)
19:50:32 <lambdabot> error:
19:50:32 <lambdabot>     • Data constructor not in scope: Int
19:50:32 <lambdabot>     • Perhaps you meant one of these:
19:52:05 <heatsink> Why can't it run?  We have lots of things that aren't functions but can run.  SQL queries, regular expressions, shell commands...
19:53:12 <jusss> heatsink: but that's not in a language, they're in a system
19:53:37 <jusss> heatsink: function can return Int, String, they can't return String in the system
19:54:26 <heatsink> Think of IO as a system like that
19:54:29 <jusss> a program in the system can not return String or any other types, they can only return 0~255
19:54:54 <heatsink> The Haskell language doesn't have any built-in ability to do IO, but it has a standard library that can construct IO commands and ask them to run
19:55:31 <heatsink> I should say, it can construct IO actions and ask them to run
19:56:20 <jusss> ok
20:01:56 <dmwit> porrifolius: "proper class" doesn't mean "two copies of a thing", it means "a bigger collection than standard set theory is prepared to describe"
20:02:28 <dmwit> porrifolius: There's foundational issues with talking about the "set of all sets". So you need another meta-level. You can talk about the "proper class of all sets".
20:03:04 <dmwit> porrifolius: And indeed one standard category that people talk about is traditionally named SET, and its objects is the proper class of sets. Arrows in this category or normal set-theoretic functions; composition is standard function composition.
20:04:06 <dmwit> jusss: If I write down a definition of the list of Fibonacci numbers, can it "run"? I say yes. But it is not a function.
20:04:20 <dmwit> jusss: "function" and "can it run" are just separate properties. Not related.
20:32:09 <monochrom> My computer cannot run.
20:32:41 <glguy> because it's old enough that it can only walk?
20:32:51 <monochrom> No, it has no legs.
20:33:46 <monochrom> If it could run, next time there is an "electroincs recycling day" I would not need to carry it myself, I would just tell it to run there.
20:41:59 <maerwald> technically you can also run with your arms (although more challenging)
20:44:52 <MarcelineVQ> monochrom: my computer has no nose
20:46:29 <monochrom> That's good news, because "code smell" cannot exist without a computer nose!
20:47:28 <porrifolius> Ok, I get the necessity of the meta-level.  So a distinction would be drawn between the category SET (which is a large category?) and a category Some_Sets whose Ob(C) was a (possibly infinite?) set of sets but not all of them?  There would probably be different morphisms and functors for each category, even though they sort of look similar.
20:47:29 <porrifolius> So, in practical terms, and especially given how limited my mathematical knowledge is, when I'm trying to use categories to help me write software I'm probably going to be dealing with an Ob(C) which is a set?  But a strength of category theory is that the fundamental techniques work for proper classes as well.
20:51:27 <jusss> dmwit: how you can write a fibonacci definition without a function?
20:51:44 <jusss> the definition itself is a function
20:52:24 <glguy> jusss: If fibs :: [Int], then it's not a function
20:52:47 <jusss> glguy: yeah, that is a normal value, how you can run it then?
20:56:26 <monochrom> Depends on what you want to observe when you run it?
21:05:47 <dmwit> jusss: "how you can run it then?" By typing `fibs` into ghci.
21:06:43 <jusss> dmwit: fibs::[Int] is not a expression, it's just type signature
21:07:24 <jusss> dmwit: so I dont think `By typing `fibs` into ghci.` will get an proper result
21:08:40 <monochrom> I think we're done.
21:10:48 * dmwit squints
21:11:48 <porrifolius> dmwit:  Another thing I'm struggling with is trying to envisage morphisms that aren't functions.  I've just learned (I think!) that category theory is stricter in it's definitions in that a function is defined in part by it's domain and codomain rather than just... umm... image and preimage?  In any event, that's helping me see that two different morphisms in the category between different pairs of objects are different things 
21:11:48 <porrifolius> even though they may be, for me, the same thing conceptually.
21:11:51 <dmwit> porrifolius: All of that sounds basically right to me.
21:12:14 <dmwit> Whoops, didn't see your latest message yet. "All of that" refers to the messages beginning "Ok, I get the necessity of the meta-level." and "So, in practical terms...".
21:12:34 <porrifolius> dmwit: But I still can't get my head around a morphism between two objects not actually being a function.
21:12:34 <porrifolius> dmwit: Hmmm... lightbulb.  I was going to ask for an example where the morphisms are not functions, but... how about the Monoid category?  The morphisms are not functions, they are the pieces of data being appended?  And the object is the function?
21:12:34 <porrifolius> dmwit: In that case, am I right and thinking that it's not just that a conceptually 'equivalent' thing has different... um... occurrences when it's represented by morphisms between different pairs of objects, it can also have different occurrences when it's represented by the same single morphism?  And that's because it can have multiple positions in the composition path.  For example, 5 is conceptually a single thing for me, 
21:12:36 <porrifolius> but in the (+) Monoid category it can appear in multiple places in a composition path and each occurrence is, in some sense, a different thing.
21:12:39 <porrifolius> dmwit: Am I even remotely close to thinking about this the correct way?
21:13:05 <porrifolius> dmwit:  Haha, I understand.  Sorry to dump such a lot of message on you at once!
21:14:05 <dmwit> Hm. If you're familiar with the standard way of turning any given monoid into a category with a single object, that seems like a pretty good example of a category whose arrows are not functions.
21:14:11 <dmwit> So I'm with you on that.
21:14:15 <porrifolius> dmwit: Understand the accidental interleaving of your response that is.  Not category theory, unfortunately.
21:14:33 <dmwit> I think I'm not with you on "5 can appear in multiple places and each occurrence is different", though.
21:15:46 <dmwit> In the one-object category whose arrows are numbers and whose arrow composition is addition, the composition 5 . 7 *is* the arrow 12. There is no way to distinguish between the arrow 12 and the arrow 5.7
21:16:15 <dmwit> (s/numbers/integers/ so that we don't need to wonder if 5.7 means 5+7/10 or 5 compose 7, hah!)
21:19:08 <mjrosenb> Is there anything like zipWith, but for Arrays?
21:20:12 <dmwit> Huh! Not that I know of. But you can build it out of listArray and indexing, I guess.
21:20:48 <dmwit> Possibly a bit annoying to fix up the bounds right...
21:21:30 <mjrosenb> yeah.  that is what I was stumbling over.
21:22:05 <dmwit> Let's see...
21:22:08 <mjrosenb> also, unless fusion is doing something very clever, I suspect it'll be slower than a good implementation that has access to the library.
21:22:08 <jackdk> the class Semialign from package semialign has a zipWith as one of its methods but does not provide an instance for Arrays
21:22:29 <jackdk> it does provide an instance for Vector, if that's any help
21:22:34 <mjrosenb> also, if it helps, I'm already using lenses, and suspect they can be made to do something like this.
21:24:25 <dmwit> mjrosenb: I guess you should be able to write, like `if inRange (lo',hi') lo then lo else lo'` to choose the new lower bound, and similarly for the new higher bound. Then `range` will get you the indices that are in range for both bounds.
21:25:40 <dmwit> You should be able to use the accessors that don't do bounds checks after that for a small speed boost compared to plain (!).
21:26:32 <dmwit> hrm, no longer so certain I believe my previous claim about how to compute the new lower bound
21:26:46 <dmwit> I'd want to do a bit of pencil-and-paper work.
21:26:50 <dmwit> How annoying!
21:27:27 <dmwit> Ah, yeah, that can't possibly work right; e.g. if the indices are tuples, we might have to pick the first part of one lower bound and the second part of the other.
21:27:50 <dmwit> Okay, now I think it's not possible to do in general. You'll have to make a new class or pick a specific Ix instance if you want to do this.
21:28:22 <dmwit> class IntersectionIx a where intersect :: (a,a) -> (a,a) -> (a,a) -- or something
21:33:16 <porrifolius> dmwit: Ok, 5 . 7 *is* the arrow 12 is because of path equivalence, right?  I didn't feel good about saying the 'multiple occurrence' stuff... I think I was resorting to it to try and clarify the difference between a morphism and a standard function over haskell data types.
21:33:17 <porrifolius> dmwit: A morphism is between two particular objects in the category, not a function from type to type, right?  I was/am struggling to keep that separation.
21:33:17 <porrifolius> dmwit: A category where Ob(C) is a set of Strings might have multiple arrows labelled "append 'x'" between different String elements of the set Ob(C)... naively it looks like there is one function to me.  But a functor would be mapping _different_ "append 'x'" morphisms with (co)domains of :X->Y, :A->B, etc onto (potentially) different morphisms in a target category.  Is that reasonably correct?
21:34:52 <mjrosenb> are you sure that 5 . 7 isn't 35?
21:36:20 <monochrom> I think they're working in a monoid or category in which composition becomes addition.
21:36:23 <porrifolius> mjrosenb: 5 . 7 we're talking about composition in a monoid category with (+) as the operator.
21:41:26 <ullbeking> hi all
21:41:45 <ullbeking> is anybody here working from hudak's "the haskell school of expression"?
21:42:25 <ullbeking> i just started reading it and i'm going to have to hunt around for the multimedia libraries, they have probably suffered bitrot, etc
21:44:02 <mjrosenb> there are probably better resources for learning haskell. (was that even haskell 98?)
21:49:36 <ullbeking> mjrosenb: i already learned it in 98.  i'm not refreshing my knnowledge.  i always wanted to read this book :-)
21:51:56 <kosmikus> ullbeking: HGL claims to have a School of Expression compatibility module Graphics.SOE and looks like it would probably still build on current GHCs.
21:52:30 <ullbeking> kosmikus: what is HGL?
21:52:50 <kosmikus> ullbeking: a package
21:53:15 <kosmikus> http://hackage.haskell.org/package/HGL
21:53:44 <ullbeking> ty kosmikus 
21:54:01 <kosmikus> ullbeking: for music, there's also the much more recent book "The Haskell School of Music" which is based on http://hackage.haskell.org/package/Euterpea
21:54:22 <ullbeking> is hackage different to cabal, or do they both do complementary things on the same package collections?
21:54:23 <kosmikus> ullbeking: see http://euterpea.com/haskell-school-of-music/
21:54:31 <ullbeking> ooooh!
21:54:33 <ullbeking> wow
21:54:50 <sclv> hackage is a package repository
21:54:59 <sclv> cabal is a tool that uses it
21:55:14 <ullbeking> gotcha
21:55:25 <ullbeking> last time i learned haskell it was on hugs 98
21:56:00 <kosmikus> nice. I started with hugs as well, because ghci did not exist at the time :)
21:56:04 <heatsink> How many times have you learned haskell so far?
21:56:21 <ullbeking> once
21:56:25 <ullbeking> this is the second time
21:57:16 <ullbeking> it's not like c++ where i've tried lots of times but i can't find a project interesting enough to keep me sticking to it :-(
21:57:29 <heatsink> Haskell distribution has changed since I learned it.  It had cabal, but now there's also stack and ghcup
21:57:58 <ullbeking> eeek.  hope it doesn't turn into the packaging mess that python did
21:58:49 <ullbeking> ok, this is all great, and enough to get my unstuck and moving
21:58:51 <heatsink> C++ is more tedious to deal with, which makes it less fun to learn
21:59:08 <sclv> ghcup is just a way to install ghc and cabal\
21:59:13 <sclv> its just an install script
21:59:13 <ullbeking> heatsink: it's just that i can't find anything about it to keep me glued to it
21:59:33 <sclv> once you're using things, you can stick to ghc and cabal just like before -- no changes!
22:00:03 <heatsink> oh, ok
22:00:38 <sclv> (well, cabal has changed a bunch and improved the workflow, but... you know :-))
22:03:22 <heatsink> Cabal is easier to use offline than several other programming languages
22:03:50 <heatsink> It's surprising how many package managers just won't work if you're not connected to the internet
22:04:22 <sclv> the v2/new stuff still isn't as good as the old style in that regard
22:04:26 <sclv> though its better in almost any other
22:04:44 <sclv> (you can do it with v2 but its not seamless still -- there's some tickets on it)
22:07:27 * hackage conferer 0.1.0.0 - Configuration management library  https://hackage.haskell.org/package/conferer-0.1.0.0 (ludat)
22:51:58 <ullbeking> ty sclv heatsink kosmikus :D
23:10:57 * hackage yesod-core 1.6.15 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-core-1.6.15 (MichaelSnoyman)
23:21:27 * hackage yesod-test 1.6.6.2 - integration testing for WAI/Yesod Applications  https://hackage.haskell.org/package/yesod-test-1.6.6.2 (MichaelSnoyman)
23:27:57 * hackage search-algorithms 0.3.1 - Common graph search algorithms  https://hackage.haskell.org/package/search-algorithms-0.3.1 (devonhollowood)
