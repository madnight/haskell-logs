01:01:50 <blowtorch> so what can i used haskell for? Not that i havent googled it.
01:03:37 <lavalike> most important it's fundamental to the existence of this channel!
01:09:44 <maerwald> blowtorch: programming
01:26:20 <mycroftiv> with haskell, i can use a bitstring to parameterize the mapping functions that generate the universe of functions that generate the bitstrings which represent the true/false equivalent of the different members of the parameterized family of functions on the bitstrings
01:27:06 <mycroftiv> mbin :: Integer -> (Integer -> Cantor -> Integer) -> (Integer -> Integer) -> (Integer -> Cantor -> Integer) -> (Integer -> Integer) -> [Integer]
01:27:35 <mycroftiv> bah he left already, oh well
01:37:42 <koz_> mycroftiv: What's the Cantor type from?
01:38:23 <mycroftiv> koz_: its boolean function over the integers
01:38:54 <mycroftiv> so its just an arbitrary infinite bitstring
01:39:03 <koz_> Ah.
01:39:22 <mycroftiv> let me link this crazy file ive got
01:39:33 <mycroftiv> i just managed to get a huge layer of infinities to eat their own tail
01:41:57 <mycroftiv> this is kind of exploratory work in progress but by the end of the file things are kind of ridiculous: http://wiki.9gridchan.org/incoming/mycro/impossible/impossible.hs
01:43:23 <mycroftiv> i think to run in ghc rather than hugs it needs a single Cont changed to cont or something like that
01:44:09 * koz_ doesn't even pretend to know what's going on there.
01:44:16 <koz_> I look forward to the library I guess? :P
01:44:38 <mycroftiv> its searching for equivalent functions, which is a pretty powerful thing and cant be done in general due to turing limits of course
01:45:11 <mycroftiv> but escardo has really cool code for searching for equivalence of a certain family of functions, and im evolving it in combination with kiselyov's lazy infinite search trees
01:45:52 <mycroftiv> ive been able to use it to 'teach the computer to understand' that certain classes of functions are equivalent
01:47:04 <mycroftiv> by using the infinite comparison 'equal' operation that escardo defines as the comparison function for the infinite search trees that kiselyov defines
01:47:29 <mycroftiv> so i get infinite lazy search trees of equivalence relations of families of functions which operate on infinite bitstrings (in general boolean functions)
01:48:02 <mycroftiv> the really crazy thing is that since the output is a set of true/false statements about the function families, that output is *itself* a cantor bitstring
01:48:31 <mycroftiv> so the trick i just worked out is using that cantor bitstring generated by the search across the families of functions to parameterize the mapping which generates the infinite families you are searching
02:08:42 * hackage joint 0.1.0 - Trying to compose non-composable  https://hackage.haskell.org/package/joint-0.1.0 (iokasimovmt)
02:40:57 <ski> @where impossible
02:40:57 <lambdabot> <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>,<http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/>
02:41:02 <ski> koz_ ^
03:09:40 <merijn> Anyone know how I can easily install/bring a library into scope with a cabal.project?
03:09:53 <merijn> I know there was a way, but I'll be damned if I remember >.>
03:17:31 <MarcelineVQ> merijn: https://cabal.readthedocs.io/en/latest/nix-local-build.html#cfg-field-packages did you mean this?
03:18:40 <merijn> MarcelineVQ: No, I remember there were selectible/activatable package environments that worked globally (somewhat like virtualenv, but like, less broken) but I can't recall how they work
03:27:31 <MarcelineVQ> huh, no idea, a local repo or world file are the only almost related things I can see in the docs
03:28:20 <merijn> I managed to find something which works which was simply doing "cabal v2-install --package-env=.ghc.environment..." to inject it into my current cabal.project environment :)
03:29:19 <MarcelineVQ> there sure are a lot of files to have to remember these days
03:30:30 <merijn> MarcelineVQ: Well, you don't have to remember them
03:30:59 <merijn> MarcelineVQ: .ghc.environment is what cabal generates so that running "ghci" within a cabal.project loads all the project's dependencies automatically
03:31:50 <MarcelineVQ> https://cabal.readthedocs.io/en/latest/nix-local-build.html#cabal-v2-install seems to have a bit to say about your method at the end if you've not seen, dunno if useful
03:41:13 <no-n> @where tapl
03:41:13 <lambdabot> "Types and Programming Languages" by Benjamin C. Pierce in 2002-02-01 at <https://www.cis.upenn.edu/~bcpierce/tapl/>
03:41:52 <no-n> is there only one edition of that book?
03:42:03 <no-n> (just to make sure I'm getting the latest)
03:42:26 <merijn> no-n: I think so
03:48:17 <MarcelineVQ> I noticed you were asking about haskell books earlier. TAPL is not a haskell learning book in case that's important
03:48:38 <no-n> I know
03:48:58 <MarcelineVQ> k np, mentioning just in case
03:49:04 <no-n> sure :)
03:49:41 <no-n> I have so much I want to read it's just difficult to decide what to read *next*
03:50:11 <no-n> guerss I need to learn patience
03:52:32 <MarcelineVQ> 'Everything we do we rush through so we can do something else' :>
03:52:55 <no-n> yeah, that's me in a nutshell ;/
05:14:42 * hackage chart-cli 0.1.0.0 - Command-line utility to draw charts from input data easily  https://hackage.haskell.org/package/chart-cli-0.1.0.0 (IlyaPortnov)
05:38:17 <sm[m]> ooh nice
05:42:42 * hackage git-brunch 1.0.5.0 - git checkout command-line tool  https://hackage.haskell.org/package/git-brunch-1.0.5.0 (andys8)
05:45:23 <sm[m]> to try it with stack: stack install chart-cli Chart-cairo dates cairo gtk2hs-buildtools
05:47:13 <sm[m]> portnov1: thanks for this. Were you answering "needs a plotting lib" from the "make haskell popular" reddit thread ?
05:54:49 <boxscape> ghc doesn't have -Wextra, right? For some reason I put that in a bunch of my cabal files without ever checking whether it actually exists
05:55:45 <MarcelineVQ> no https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html
05:55:54 <boxscape> okay, thanks
06:11:26 <Lycurgus> wedify are you here with a new nick?
06:16:34 <boxscape> So, I have a function timesOne :: a -> ((), a). I then wrote a function timesOneInj :: timesOne x :~: timesOne y -> x :~: y. If I pattern match on the argument with Refl, ghc knows that x must be equal to y. Does it infer that by going through the implementation of timesOne?
06:18:24 <boxscape> Actually feels pretty weird to use functions on the type level that aren't type families
06:19:26 <MarcelineVQ> you didn't timesOneInj :: timesOne x :~: timesOne y -> x :~: y is equivalent to timesOneInj :: z x :~: z y -> x :~: y
06:19:43 <boxscape> ahhh that makes sense
06:20:01 <MarcelineVQ> i.e. lower case identifiers are variables
06:20:08 <boxscape> but how does it know that x and y must be the same?
06:20:38 <boxscape> as in, if I pattern match on z x :~: z y with Refl
06:20:45 <boxscape> the type of the right side becomes x :~ x
06:20:50 <boxscape> instead of x :~: y
06:21:07 <MarcelineVQ> because of the definition of Refl, if you have a Refl at all then x must be y, since Refl can only be constructed when x and y are actually the same
06:21:39 <boxscape> isn't that only true if z is injective?
06:22:47 <MarcelineVQ> hmm
06:23:40 <boxscape> I guess I'll try writing a non-injective type family and see if I can generate an element of Void, I expect I'll get stuck somewhere
06:25:46 <boxscape> s/generate/construct
06:25:58 <MarcelineVQ> I guess I'm not sure what mechanism is responsible for the gurantee, this exists so it's not a weird thing that's happening at least http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Type-Equality.html#v:inner
06:26:40 <boxscape> hm, interesting
06:26:53 <c_wraith> the guarantee comes from the fact that normal type constructors are injective
06:27:00 <c_wraith> and, in fact, generative
06:27:11 <c_wraith> and a type variable cannot stand for a type family
06:27:19 <boxscape> ahh
06:28:35 <boxscape> is that how I have to understand the error message "GHC doesn't yet support impredicative polymorphism"?
06:31:06 <boxscape> And is there a way to encode type family injectivity then?
06:33:01 <MarcelineVQ> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#injective-type-families
06:34:59 <boxscape> hm, okay, thanks, so this allows me to guarantee inside a type family that it's injective - is there a way to have a type that only accepts injective type families as argument?
06:35:06 <boxscape> I guess maybe I should just read the paper linked there
06:48:30 <boxscape> I think you can do it if you use defunctionalized type families
07:01:26 <boxscape> (the only problem being that now that I've encoded it, I don't know how to prove it)
07:14:32 <boxscape> okay I did it, I think
07:14:54 <boxscape> or actually maybe not
07:19:22 <MarcelineVQ> there's also closed type families if they might fit your task better
07:19:34 <boxscape> I think I'm exclusively using those
07:19:45 <boxscape> those are the type families with "where" in the definition, right?
07:20:04 <boxscape> I'm trying to prove that a closed type family is injective
07:21:55 <aveltras> how can i compile a package (more precisely an executable in a cabal file) with cabal v1, ghcjs is on PATH
07:33:37 <boxscape> hm is there way to get around this?  https://gist.github.com/JakobBruenker/702c53e302a43cace72e64fe0013eeaa
07:35:09 <boxscape> I tried instead using `forall a. (a ~ 'Refl) => a` instead of the right side of the type family, but then it complains that it expects a type but a is of kind 'a0 :~: a0' :(
07:37:30 <boxscape> the thing is if I type '() on the right side ghc actually tells me that it expected kind y0 :~: y0
07:37:36 <boxscape> which means it can infer that they ought to be the same
07:37:41 <boxscape> which makes me feel like I'm really close
07:39:55 <inkbottle> I am surprised I don't find so many recursive descent parsers for the Haskell language itself. (actually the only thing I found are Lexer.x & Parser.y which together amount 8000 lines; I was thinking of something much more toy like)
07:45:05 <boxscape> oh shoot it works if I just use a type variable instead of trying to pattern match on 'Refl
07:46:34 <boxscape> uhg, except now somehow I can prove that y is equal to z, so nevermind, it's still not right
07:46:49 <boxscape> (even though I don't know anything about z)
08:01:07 <portnov1> sm[m]: I just need to draw quick plots from time to time, and gnuplot was too complex :)
08:01:28 <boxscape> hmm so, I have OneIsZero :: 1 :~: 0, where OneIsZero is on the type level and 1:~: 0 is the kind. Would I be able to use this for anything nefarious or is this still all as intended?
08:06:53 <sm[m]> portnov1++, this is the first "simple enough" haskell plotting tool I've seen
08:07:21 <sm[m]> just needs a console output option :)
08:08:39 <MarcelineVQ> What is OneIsZero? 'cause you can have x :~: y any way you like, it's constructing a value of this type that requires them to actually be the same
08:09:28 <boxscape> https://gist.github.com/JakobBruenker/702c53e302a43cace72e64fe0013eeaa#gistcomment-3007647
08:09:35 <boxscape> ^ MarcelineVQ
08:09:59 <boxscape> If I try to use 'Refl directly instead of AllTheSame ghc complains
08:10:02 <boxscape> because 1 isn't 0
08:13:12 <MarcelineVQ> " if you use the experimental extension UndecidableInstances, both the Paterson Conditions and the Coverage Condition (described in Instance termination rules) are lifted." <_<
08:13:50 <boxscape> I see
08:14:25 <boxscape> though it still seems a bit strange that you can define AllTheSame without UndecidableInstances, but maybe that means you'd never be able to use it
08:15:30 <MarcelineVQ> I quoted that because on my ghci here it can't be defined without UndecidableInstances, so I assumed you had it on
08:15:42 <boxscape> yeah, but only for OneIsZero
08:15:46 <boxscape> you don't need it for AllTheSame
08:15:57 <MarcelineVQ> Oh okay I see
08:16:58 <boxscape> I mean if it's expecting kind x :~: z I don't really understand why giving it 'Refl doesn't cause an error
08:17:55 <MarcelineVQ> I guess it means x will have to unify with z where this is used
08:18:19 <boxscape> but shouldn't it then throw an error in the definition of OneIsZero, even with UndecidableInstances?
08:19:07 <boxscape> Or.. maybe UndecidableInstances means it doesn't bother checking what it should be
08:19:37 <boxscape> because it doesn't know if checking would terminate
08:20:23 <MarcelineVQ> idk :X
08:22:34 <boxscape> but even without UndecidableInstances I can have Proxy :: Proxy (AllTheSame :: 0 :~: 1), which seems to go against that
08:23:59 <c_wraith> The thing is, the proof of :~: is at runtime.  If you can't pattern-match on it, you don't have a proof.
08:24:24 <aveltras> is there a way to find programmatically the directory where cabal new-build outputs files ? right now it uses a mix of platform, compiler version and package version
08:24:52 <hvr> aveltras: see http://hackage.haskell.org/package/cabal-plan
08:25:13 <hvr> that shows how to find the location *after* a build-plan was computed
08:25:46 <boxscape> c_wraith But how is it possible that I can use 'Refl :: forall k (a :: k). a :~: a in a context that expects kind x :~: z?
08:25:49 <hvr> finding out the output folders before a build-plan has been computed is more complicated (as it depends in various input parameters whcih can affect the location)
08:28:23 <boxscape> MarcelineVQ by the way, I don't even need UndecidableInstances for OneIsZero if I use a type synonym instead of a type family
08:28:54 <aveltras> hvr: i just want to move ghcjs output files to another directory after compilation
08:29:37 <boxscape> MarcelineVQ c_wraith and this would fail, incidentally: type AllTheSame = ('Refl :: x :~: z)
08:30:29 <boxscape> Anyway I'll just try to construct a Void element and probably get stuck somewhere
08:34:14 <aveltras> hvr: worked fine thanks
08:47:09 <boxscape> Well, my constructing a Void value seems to get stuck on there not being a SingI instance for my Void type, and I'm not sure it's possible to make one, so I guess having a type of a kind that shouldn't have any types isn't as bad as the same thing on the value and type level?
08:53:14 <boxscape> oh, actually I think I figured it out...
08:53:21 <boxscape> it's just that AllTheSame is a partial type family
08:53:47 <boxscape> it will only be reduced if the kind is x :~: x
08:58:26 <boxscape> ... I think ultimately that means I can define Injectivity the way I wanted to
09:06:04 <delYsid> Is there a function somewhere to escape or replace path separator and other strange characters in a FilePath?
09:06:18 <iqubic> What does this command do: "cabal build --ghc-option=-ferror-spans"?
09:07:11 <iqubic> Does that just compile my entire haskell project?
09:17:37 <sclv> yes, cabal build builds the project
09:17:56 <iqubic> Cool. Good to know.
09:27:11 <PotatoRick[m]> hey guys, can i describe this kind of instance automatically?: `instance (Foldable f, Monoid (f a)) => Monoid1 f`
09:27:35 <PotatoRick[m]> `a` here can't be deduced, so `Monoid (f a)` can't be too
09:28:44 <PotatoRick[m]> i want to define instance which applies to all `f` which has general `Monoid (f a)` instance
09:29:30 <EvanR> maybe by specifying it as Monoid b, b ~ f a
09:29:47 <PotatoRick[m]> like `[]` has `Monoid [a]` instance
09:30:21 <portnov1> technically it should've been (forall a => Monoid (f a)) => Monoid f
09:30:29 <portnov1> but I doubt ghc can parse that
09:30:42 <portnov1> (forall a . Monoid (f a)) 
09:31:05 <portnov1> smth like Rank2Types, but in context position
09:31:14 <EvanR> rank n constraint
09:32:01 <PotatoRick[m]> portnov1: now i have `Could not deduce (Monoid (f a0)) from the context: Monoid (f a)`
09:32:48 <PotatoRick[m]> for `instance forall f a. Monoid (f a) => Monoid1 f` instance
09:33:43 <PotatoRick[m]> portnov1: ghc actually can parse it, bot it can't deduce `a`
09:33:57 <portnov1> it can't unify a wqith a0...
09:34:09 <portnov1> try with {-# LANGUAGE ScopedTypeVariables #-}
09:34:15 <portnov1> who knows, maybe it will help...
09:34:39 <PotatoRick[m]> i'm already turned that on
09:37:00 <PotatoRick[m]> for `instance (forall a. Monoid (f a)) => Monoid1 f` it says "Illegal polymorphic type: forall a. Monoid (f a) A constraint must be a monotype"
09:37:28 <PotatoRick[m]> it must be a crime to try to do so
10:01:12 <boxscape> Is there a way to declare the variables x and y here in such a way that they're not shadowed? I want them to mean the same across the whole type declaration https://gist.github.com/JakobBruenker/30bb9b1fce459f1b281440c03cf1efad
10:05:07 <boxscape> also does there happen to be a function in singletons with a type something like "a ~> b -> Demote a -> Demote b"? I.e. a type that gets the original value level function to a corresponding type level function
10:20:42 <arpl> I dropped in here briefly yesterday and saw some of you talking about Sandy Maguire´s Thinking with Types. I have read a prerelease version, but it was clearly above my skill level. (It is still on my reading list though.)
10:20:42 <arpl> Saw in Haskell Weekly that Renzo Carbonara <https://github.com/k0001> is also writing a book <https://atypeofprogramming.com/>. Has anyone read the prerelease version? Opinions?
10:27:14 <cocreature> arpl: I read the part of Renzo’s book that was available just after it was released and found it quite enjoyable but it has beeen expanded significantly since then and I haven’t had time to read on
10:31:12 * hackage typography-geometry 1.0.1.0 - Drawings for printed text documents  https://hackage.haskell.org/package/typography-geometry-1.0.1.0 (JeanPhilippeBernardy)
10:31:39 <lyxia> PotatoRick[m]: that instance overlaps with every other instance, so it's a bad idea, but you can write it using QuantifiedConstraints which is a very recent extension.
10:33:59 <PotatoRick[m]> lyxia in the project i'm using ghc 8.0.2 so that extension probably wouldn't be there yet
10:34:46 <PotatoRick[m]> lyxia: but thanks for the advice, pretty interesting extension
10:34:53 <PotatoRick[m]> didn't know about it
10:34:55 <arpl> cocreature: I read that part too and I found it enjoyable as well. Also seemed to be better suited to my capacity of dealing with too much abstraction at once. : ) And when I look at the exinst library it certainly look like Renzo could take it to the same ´destination´ as Sandy but in a way that works better for me.
10:47:42 * hackage mssql-simple 0.5.0.0 - SQL Server client library implemented in Haskell  https://hackage.haskell.org/package/mssql-simple-0.5.0.0 (tkmsm)
11:02:29 <PotatoRick[m]> lyxia: yes, QuantifiedConstraints works for me, i don't even need that Monoid1 since i need to write forall a. Monoid (f a) in place i use it, so i can just use `Monoid` directly
11:03:20 <PotatoRick[m]> in that my current project i can't use it since ghc version is below 8.6, but in the future i will keep that in mind
11:05:25 <lyxia> PotatoRick[m]: well the Monoid1 thing is basically a pattern to workaround the lack of quantified constraints, so it's kind of natural that 1) without the extension, it can't be automated, 2) with the extension, the pattern is made redundant.
11:06:48 <PotatoRick[m]> yeah, exactly that, i'm really happy i know now about this extension, it will make life a lot easier
11:13:12 * hackage reactive-banana-automation 0.5.2 - home (etc) automation using reactive-banana  https://hackage.haskell.org/package/reactive-banana-automation-0.5.2 (JoeyHess)
11:14:12 * hackage lp-diagrams 2.1.1 - An EDSL for diagrams based based on linear constraints  https://hackage.haskell.org/package/lp-diagrams-2.1.1 (JeanPhilippeBernardy)
11:28:17 <turion> I have quickcheck tests that I'm testing through cabal new-test. I've organised them with test-framework. I only want to run certain sub-tests, specified by a testGroup. How does that work?
11:30:32 <cocreature> turion: tasty which is mostly API compatible with test-framework has a "-p" option for selecting tests that match a pattern. Not sure if test-framework has that as well but you might want to consider switching to tasty as a more modern and fully featured alternative either way :)
11:31:42 * hackage marxup 3.1.1.0 - Markup language preprocessor for Haskell  https://hackage.haskell.org/package/marxup-3.1.1.0 (JeanPhilippeBernardy)
12:05:21 <turion> cocreature: Yes, I'll check it out!
12:07:00 <turion> cocreature: Hmm, how do I even pass command line arguments to the executable that cabal test produces?
12:20:16 <cocreature> turion: an easy option is to run the test suite via "cabal (new-)run"
12:20:30 <cocreature> I think there is also some flag but I don’t recall the name. --help should do the trick
12:32:12 <EvanR> has anyone tried NuPRL, seems interesting
12:37:35 <hololeap> if i have a do block where every line reduces down to m (), would there be a good chance that ApplicativeDo and -foptimal-applicative-do would speed up performance?
12:39:56 <hololeap> for instance, if the monad is something like  WriterT w (State s) ()
12:40:24 <hololeap> and every line in the do block is `modify ...`, `tell ...`, or `put ...`
12:40:47 <hololeap> (or let ... = ...)
13:08:37 <Heffalump> is there a way to declare in a cabal file that a test harness depends on an executable in the same cabal file?
13:08:46 <Heffalump> (because it will shell out to the executable)
13:16:54 <geekosaur> isn't that covered by build-depends on the package?
13:19:56 <MarcelineVQ> https://cabal.readthedocs.io/en/latest/developing-packages.html#pkg-field-build-tool-depends
13:20:16 <MarcelineVQ> Oh I'm blind, thanks geekosaur :>
13:21:43 <Heffalump> geekosaur: that's on the library, not the exe
13:22:48 <MarcelineVQ> Heffalump: check that link for your use-case
13:24:27 <geekosaur> Heffalump, afaik it's on the whole package, normal install assumed which means all default executables
13:24:52 <geekosaur> if you have a custom executable needed only for testing, hm, seems to me the intent would be to make it the test suite executable
13:26:23 <Heffalump> MarcelineVQ: ah, yes, thanks.
13:26:42 <Heffalump> geekosaur: cabal v2-run test:foo wasn't building the exe it needed to run
13:29:54 <Heffalump> the executable is the main executable we build (darcs) and the test harness (darcs-test) shells out to it. I've just started using cabal v2-run but cabal v2-run test:darcs-test wasn't making sure that the darcs exe was built first.
13:38:42 * hackage dyepack 0.1.0.0 - Programatically identify space leaks in your program.  https://hackage.haskell.org/package/dyepack-0.1.0.0 (mpickering)
13:45:53 <turion> cocreature: Ah, the cabal new-run hint is great! For example, cabal new-run test:your-test-suite -- -t PATTERN will work already for test-framework
13:46:42 * hackage perceptual-hash 0.1.1.1 - Find duplicate images  https://hackage.haskell.org/package/perceptual-hash-0.1.1.1 (vmchale)
14:00:12 * hackage doctemplates 0.5 - Pandoc-style document templates  https://hackage.haskell.org/package/doctemplates-0.5 (JohnMacFarlane)
14:04:57 <Guest_99> Has anyone had an issue with installing ghcup?
14:05:07 <Guest_99> Specifically running 'curl https://get-ghcup.haskell.org -sSf | sh'
14:05:14 <Guest_99> https://www.haskell.org/ghcup/
14:08:12 * hackage dzen-dhall 1.0.0 - Configure dzen2 bars in Dhall language  https://hackage.haskell.org/package/dzen-dhall-1.0.0 (klntsky)
15:37:41 <hukyld> helloi
15:42:21 <no-n> hi
15:43:35 <hukyld> sorry, tmux got stuck, involuntary helloi :)
15:49:20 <hpc> math sinners go to hellois :D
17:24:42 * hackage cabal-debian 5.0 - Create a Debianization for a Cabal package  https://hackage.haskell.org/package/cabal-debian-5.0 (ClintAdams)
18:12:15 <no-n> how do I install a hackage project with stack?
18:14:48 <Axman6> stack install <library> - if it's not in the stackage snapshop you're using you may need to also specify its version, and possibly the versions of any dependencies it relies on which aren't in t he snapshot; it'll tell you if you need to do that. stack install foo-0.1.0.3 dep-0.0.2.3 dep2-1.2.3.4
18:15:02 <Axman6> snapshot*
18:15:49 <no-n> thanks
19:26:39 <inkbottle> When I try to use Intero in emacs I get an error: "Intero is not installed in the Stack environment... Plan construction failed."; In the error message I can see a reference to a globally installed Intero; Which seems a bad idea. How can I straighten that?
19:28:39 <inkbottle> I've tried installation through emacs, as suggested there (https://github.com/chrisdone/intero/issues/490); but it results in a message telling me that intero is already installed
19:29:21 <inkbottle> I very often has this error; and never found a reproducible solution to it
19:30:00 <inkbottle> Probably same complaint as https://github.com/chrisdone/intero/issues/413
19:31:03 <inkbottle> Which says "Intero should not be installed anywhere except by the mode itself.", which doesn't seem to ring a bell
19:32:11 <MarcelineVQ> you can write stack build intero on a per project basis, if your editor utilises stack then this should place an intero appropriate to your project's setup on the path
19:32:47 <MarcelineVQ> I should add that I don't use intero but I've had similar problems with tooling for which this was the solution
19:33:00 <inkbottle> MarcelineVQ: I did that already, I might want to remove the "global" version which I'm doing now.
19:33:08 <MarcelineVQ> likely
19:34:41 <MarcelineVQ> per-project is technically not neccesary, there's a way to do it per ghc version, but I don't remember how and per project is pretty painless
19:35:54 <MarcelineVQ> I think it's related to the --copy-compiler-tool flag
19:36:04 <inkbottle> I've removed the executable suggested by the output of "stack path --local-bin", but it doesn't work yet (I did found some solution in a former life, I'll probably remember it"
19:36:47 <inkbottle> What editor do you use?
19:36:52 <MarcelineVQ> atom mostly
19:37:18 <MarcelineVQ> but I don't use intero, I had this sort of issue with ghc-mod when I used to use that
19:39:44 <inkbottle> (I spend far to much time to my taste fixing my editor, or modes)
19:40:17 <MarcelineVQ> When you're at your wits end after a bunch of changes don't forget that a reboot can magically solve some things
19:44:41 <Guest22> Hey. I would like to know if it is bad practice to have something like:
19:45:33 <Guest22> `data family MkExampleDF (idx :: Symbol)`
19:46:19 <Guest22> And then have an instance/use `MkExampleDF "Error"` instead of the more conventional `MkExampleError`
19:47:42 <Guest22> Maybe have `type family MkPatientDefaultTF (idx :: Symbol) (a :: k)` for e.g `MkPatientDefaultTF "Validation"`
19:56:13 <hololeap> did this ever get into ghc? it doesn't seem to work for me: https://typesandkinds.wordpress.com/2012/12/22/ordered-overlapping-type-family-instances/
19:58:25 <Heffalump> hololeap: did you try using a closed type family?
20:00:46 <hololeap> Heffalump: the blog post uses the syntax: `type instance where`
20:01:03 <Heffalump> hololeap: yeah. It's weird as it says it was merged, but I've never come across it.
20:02:41 <hololeap> ultimately, i want to pattern match over types like you can do in a function
20:02:46 <Heffalump> https://wiki.haskell.org/GHC/Type_families#Closed_family_simplification suggests you can write overlapping things that way though
20:04:01 <hololeap> oh, yeah i guess it does work with closed type families :/
20:04:16 <Heffalump> I wonder if the feature got replaced/subsumed by those
20:04:43 <Heffalump> there's a later paper by Eisenberg about it: https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/popl137-eisenberg.pdf
20:08:08 <newhoggy> Anyone successfully used `polysemy` for callbacks?
20:37:12 * hackage shake-ext 3.1.0.1 - Helper functions for linting with shake  https://hackage.haskell.org/package/shake-ext-3.1.0.1 (vmchale)
20:42:12 * hackage shake-ext 3.1.0.2 - Helper functions for linting with shake  https://hackage.haskell.org/package/shake-ext-3.1.0.2 (vmchale)
20:43:12 * hackage list-witnesses 0.1.3.2 - Witnesses for working with type-level lists  https://hackage.haskell.org/package/list-witnesses-0.1.3.2 (jle)
20:45:31 <crestfallen> hi I have some questions about ' instance Monad []    https://termbin.com/946o
20:46:41 <inkbottle> MarcelineVQ [the following is not really understandable, don't read it]: emacs "(package-install 'intero)", puts a file in ~/.emacs.d/.../intero-20190530.1308/intero.el. This file contains a hard coded reference to the version of intero to use "(defcustom intero-package-version...". But emacs do not reinstall this file if the file is already installed: hence a wrong reference to the version of intero to be used
20:47:16 <inkbottle> How could I put that in words, but not too many? Nevermind
20:47:56 <crestfallen> I'd like to use a function (a -> [b]) with the (>>=) operator , without the do notation
20:48:46 <crestfallen> so I don't quite see how to use lines 8,9
20:50:34 <MarcelineVQ> inkbottle: dunno, I don't use intero or emacs :(
20:51:18 <crestfallen> no line numbers..
20:52:52 <jusss> :t (>=>)
20:52:54 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
20:52:58 <jackdk> > [1..3] >>= \x -> [x-1,x,x+1] -- crestfallen
20:53:00 <lambdabot>  [0,1,2,1,2,3,2,3,4]
20:53:21 <jackdk> I'm not sure I understand the difficulty you are facing. Can you be more specific?
20:54:22 <crestfallen> jackdk, thanks so much, I'm a bit confused. It's my first exposure to monad. the textbook went from the Monad definition for lists to the pairs function and do notation very quickly
20:54:50 <crestfallen> the pairs function looks more like (>>) to me
20:55:15 <jackdk> I see. `do`-notation is syntactic sugar only, it doesn't do anything you can't do by applying the operators directly
20:55:37 <jackdk> I don't know which book you are referring to, nor which definition of the pairs function
20:56:01 <crestfallen> the pairs function on the paste
20:56:19 <crestfallen> the book is hutton.
20:57:20 <crestfallen> so yeah I do understand your example above . though not jusss 's example  ??
20:58:00 <jackdk> I don't have that book, so I'll have to go on your paste.
20:58:03 <inkbottle> crestfallen: you cannot build the pair with (>>), you need (>>=), (or <*>, but it's another story)
20:58:14 <jackdk> I'm not sure what jusss was getting at with that function
20:58:33 <dmwit> crestfallen: `pairs xs ys = xs >>= \x -> ys >>= \y -> return (x,y)` is the mechanical translation out of do notation and into operators
20:58:43 <jackdk> here is how do-notation desugars, with some strange layout to show the mechanics:  https://www.irccloud.com/pastebin/VUI1byoc/
20:58:59 <jackdk> dmwit quick on the trigger, as usual ;-)
20:59:09 <crestfallen> thanks all one sec
20:59:39 <inkbottle> crestfallen: the 9th line you are refering to is the implementation of the specific instance of >>= when the monad is []
21:00:00 <crestfallen> copy that inkbottle thanks
21:02:49 <crestfallen> in pairs, where is the actual argument of the Monad (a -> [b])  ?... its not : return (x,y)
21:03:14 <crestfallen> so is it everything in the do clauses?
21:03:44 <jackdk> crestfallen: it is the two lambdas generated by the desugaring. one `\x -> ...` and one `\y -> ...` inside it
21:04:42 <crestfallen> right that's what I thought. so I'm a little fuzzy, you don't need (a -> [b]) explicitly in the pairs type signature
21:04:49 <crestfallen> jackdk, 
21:05:49 <crestfallen> the pairs function has (a -> [b]) unified into it?
21:06:17 <crestfallen> if that makes sense
21:08:36 <jackdk> crestfallen: I do not understand what you are saying, so I'll try spelling out what I wanted to say and hope it helps?
21:08:55 <crestfallen> ok please
21:09:16 <jackdk> stand by... ASCII art incoming
21:09:25 <crestfallen> uh oh
21:10:07 <jusss> the associativity law is that (m >>= f) >>= g = m >>= (f >>= g) ?
21:10:21 <jackdk> with an extra lambda to make things line up
21:10:48 <jusss> m >>= f >>= g = m >>= (\x-> f x >>= g)
21:11:05 <dmwit> jusss: Yes to the second version.
21:11:23 <jusss> but f >>= g = \x -> (f x) >>= g
21:11:36 <dmwit> I do not agree with this equation.
21:11:52 <dmwit> For one, the thing on the left need not even be a function.
21:12:07 <crestfallen> that's lost on me for one
21:12:28 <dmwit> I don't think jusss is trying to help you, anyway. They are musing and exploring for themselves.
21:12:36 <crestfallen> cool
21:12:55 <jusss> dmwit: did f <=< (g <=< h)  =   (f<=<g) <=< h?
21:13:19 <dmwit> That equation is fine.
21:14:11 <crestfallen> I did some work with unifying types to a degree of success. so this pairs function is pretty straightforward but I don't know how the function is the proof to the type (proposition). ie if there is (>>=) operating in the do notation
21:14:23 <jusss> dmwit: and m >>= f >>= g is not equal m >>= (f >>= g) ?
21:14:33 <dmwit> no
21:14:40 <jackdk> crestfallen: here is an expansion of the previous paste. I wrote the type signatures of different parts underneath so you can see how the bits nest:  https://www.irccloud.com/pastebin/W11rxVaK/
21:14:44 <jackdk> I hope this helps
21:14:47 <crestfallen> how is it expressed in the pairs type declaration?
21:15:04 <jusss> dmwit: 'cause the lambda associativity?
21:15:14 <crestfallen> thanks jackdk working...
21:15:23 <jackdk> >>= will appear in the desugaring of a do-block anywhere you bind a variable name like `x <- `
21:15:24 <dmwit> There is no lambda. Also I don't know what you mean by "lambda associativity".
21:15:26 <jusss> I forget that how the lambda associativity
21:16:18 <jusss> m x >>= \x -> m y >>= \y -> x+y
21:16:52 <arsdragonfly> Has anyone worked with the simple GHC integration plugin in VSCode? I tried shift+alt+enter to run my current file in GHCi but nothing happens
21:17:05 <jusss> equal m x >>= \x -> ( m y >>= \y -> x + y) ?
21:17:16 <dmwit> yes
21:17:41 <sarahzrf> edwardk_: ping
21:18:55 <arsdragonfly> or, is there any plugin that allows me to evaluate selected code in GHCi
21:20:49 <crestfallen> jackdk, yeah I understand the expanded version and your last comment above. so the (>>=) operator in the do block essentially extracts a from [a] and b from [b]    and ...
21:21:54 <crestfallen> that is represented in the (>>=) signature as [a] -> (a -> [b])     ? 
21:22:06 <jusss> m >>= f >>= g  =   m >>= (\x -> f x >>= g)
21:22:20 <jusss> f >=> g = \x->(f x) >>= g
21:22:23 <jusss> so ?
21:23:02 <jusss> m >>= f >>= g = m >>= (f >=> g) ? 
21:23:23 <dmwit> No, your very first equation is incorrect.
21:23:28 <dmwit> As I said multiple times now.
21:23:47 <dmwit> Sorry.
21:23:51 <dmwit> Scratch that, I didn't read carefully.
21:24:03 <dmwit> First equation is fine. All three are fine.
21:24:21 <jusss> I don't understand...
21:24:24 <crestfallen> its the extraction of a and b elements from [a] and [b]   in totality its m a -> (a -> m b) for each line of the do block   jackdk  that must be it!
21:24:31 <dmwit> jusss: I made a mistake. You are correct.
21:24:37 <dmwit> jusss: All three equations are correct.
21:24:55 <jusss> dmwit: really?
21:25:08 <dmwit> Really.
21:25:50 <jackdk> crestfallen: you can often think of >>= as giving a name to some "thing", like the "result" of an action or "some element" of a list. This is why it's called "bind" - it binds a name to that "thing"
21:26:07 <crestfallen> so for each line of the do block you are doing a ' m a -> (a -> m b) '   
21:26:23 <jackdk> crestfallen: yes, that's why I laid out the desugared version that way.
21:26:30 <jackdk> crestfallen: excellent work.
21:26:44 <crestfallen> !! 
21:27:04 <crestfallen> that's why I was confused because each line is applying >>=
21:27:44 <crestfallen> not the do block as a whole. thanks jackdk kindly!
21:27:50 <jackdk> yes
21:28:03 <jackdk> yeah I think I see where you were tripping up
21:28:09 <jackdk> crestfallen: Expect your understanding to feel shaky for a while as you find your feet with this stuff. Something that helped me a lot was to write the Functor, Applicative, Monad instances for a bunch of different types ([], ((->) t), Maybe, (Either e)), and also writing out a bunch of functions that only use the monad operators (sequence, replicateM, join, most of Control.Monad really)
21:28:55 <jackdk> another useful exercise is to write (>=>)/(>>=)/join in terms of each other, as they're equally powerful
21:30:23 <crestfallen> yeah actually this example (both our pastes) makes perfect sense. but I was skittish and thought that I would see '[a] -> (a -> [b]) somewhere in the pairs type sig
21:31:45 <crestfallen> I'll work tomorrow on the above suggestions thanks again jackdk 
21:33:11 <jackdk> good plan, do a bit each day
22:38:02 <xacktm> error handling question..  I have a list comprehension [ y | x <- xs, let Just y = M.lookup x someMap ] , how do I have the list comprehension not emit anything when the lookup returns Nothing?
22:38:45 <Axman6> looks like a more complicated mapMaybe
22:39:09 <Axman6> mapMaybe (\x -> lookup x someMap) xs
22:39:12 <jackdk> what is the question you're trying to solve? find the values for every keys that happen to be in the map? If so, I think Axman6 is right
22:39:20 <jackdk> :t mapMaybe
22:39:22 <lambdabot> (a -> Maybe b) -> [a] -> [b]
22:39:34 <Axman6> if you want to fail if any key fails, then use traverse: traverse (\x -> lookup x someMap) xs
22:40:14 <jackdk> :t traverse @[] @Maybe
22:40:16 <lambdabot> error: parse error on input ‘@’
22:40:45 <jackdk> % :t traverse @[] @Maybe
22:40:45 <yahb> jackdk: (a -> Maybe b) -> [a] -> Maybe [b]
22:42:48 <xacktm> yeah, I have a master key list type x and a "decoding" map type y, so [x] and a Map x y, and just want to discard failures because the map might have keys that aren't in the master key list
22:43:05 <xacktm> I'll take a look at mapMaybe thx
22:47:12 * hackage salak 0.3.5.2 - Configuration (re)Loader and Parser.  https://hackage.haskell.org/package/salak-0.3.5.2 (leptonyu)
22:48:16 <dminuoso> xacktm: As a more immediate answer to your question, if you insist on a list-comprehension you could also use  [ y | x <- xs, Just y <- [M.lookup x someMap] ] 
22:48:47 <dminuoso> Though mapMaybe is the better approach. :)
22:49:58 <xacktm> huh, clever
22:50:12 <xacktm> but yeah, I prefer to "upgrade" my code as I learn more :)
22:51:59 <dminuoso> xacktm: I learned to appreciate this trick for this style of code https://gist.github.com/dminuoso/cf08ef768da79f75572026dd2493ca7b
22:55:29 <xacktm> nice, comprehensions make sense there for updating records as new events come in
22:55:46 <xacktm> I'm just building a kv list for an inverted map
22:56:45 <jusss> dminuoso: those are equal?   https://paste.ubuntu.com/p/q4rqGcVnwD/   
22:57:14 <dminuoso> jusss: You could answer this question yourself.
22:57:27 <jusss> dminuoso: by check the types?
22:57:37 <dminuoso> jusss: There's some errors paste. 
22:57:56 <jusss> dminuoso: which ones?
22:58:16 <dminuoso> (m >>= f) >>= g      =        m >>= (f >>= g)
22:58:19 <dminuoso> This one.
22:58:49 <jusss> dminuoso: do (f.g).h = f.(g.h) ?
22:59:28 <jusss> dminuoso: and others?
22:59:36 <dminuoso> jusss: Pick some values for m, f and g. Use any Monad instance you like and try it out.
23:00:43 <jusss> fmap and >=> are ok with this (a b) c = a (b c), but >>= and applicative are not?
23:04:41 <dminuoso> jusss: What do you mean by "fmap [is] okay with with this..." ?
23:04:49 <jusss> dminuoso: (.)
23:04:58 <dminuoso> jusss: Specify the law you have in mind
23:05:29 <jusss> dminuoso: (f . g) . h = f . (g . h)  right?
23:05:42 <jusss> dminuoso: f <=< (g <=< h)        =       (f<=<g) <=< h     right?
23:05:58 <dminuoso> jusss: Yup.
23:06:16 <jusss> dminuoso: but (m >>= f) >>= g      =        m >>= (f >>= g)   incorrect?
23:06:22 <dminuoso> jusss: It wouldnt type check.
23:06:53 <dminuoso> jusss: With (>>=) you can still specify the associativity law, it just doesn't look so symmetrical anymore.
23:07:33 <dminuoso> (m >>= f) >>= g   ≡   m >>= (\x -> f x >>= g)
23:07:41 <dminuoso> That is the associativity law, expressed in terms of (>>=)
23:07:50 <dminuoso> It's completely equivalent to:
23:07:59 <jusss> dminuoso: but f >=>g = \x -> f x >>= g
23:08:08 <dminuoso> f >=> (g >=> h)   ≡    (f >=> g) >=> h
23:08:22 <dminuoso> jusss: Spot on.
23:09:24 <jusss> dminuoso: (m >>= f) >>=g  ==  m >>= (f >=>g) ?
23:09:40 <dminuoso> jusss: That's an alternate way of putting it, yes. :)
23:09:59 <jusss> dminuoso: but f :: e->a in the >>=, and a->e->b in >=>
23:10:17 <jusss> that f have diffrent types in >>= and >=> , that's ok?
23:10:33 <dminuoso> jusss: What do you mean "f have different types in >>= and >=>" ?
23:10:55 <dminuoso> % :t (>=>)
23:10:55 <yahb> dminuoso: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
23:10:57 <dminuoso> % :t (>>=)
23:10:57 <yahb> dminuoso: Monad m => m a -> (a -> m b) -> m b
23:11:06 <dminuoso> Let's rename the type variables to avoid confusion
23:11:07 <jusss> dminuoso: oh
23:11:26 <dminuoso> (>>=) :: Monad q => q r -> (r -> q t) -> q t
23:12:43 <dminuoso> jusss: But indeed, (.) is very closely related to (<=<)/(>=>) :)
23:12:58 <jusss> dminuoso: and applicative?
23:13:33 <dminuoso> jusss: Applicative has a beautiful specification of applicative laws if at some time finish my excercise with ApplicativeAlt.
23:14:32 <jusss> dminuoso: which is?
23:15:54 <dminuoso> jusss: You remember plus and unit?
23:16:37 <jusss> dminuoso: that I didn't solve one?
23:16:51 <dminuoso> Right.
23:16:56 <jusss> dminuoso: yeah
23:17:39 <dminuoso> jusss: We could write plus as an operator, say <+>, or whatever you prefer. Then the law is ⌜f <+> (g <+> h) ≃ (f <+> g) <+> h⌝, ⌜f <+> unit ≃ f⌝ and ⌜unit <+> f ≃ f⌝
23:18:10 <dminuoso> jusss: note that ≃ here means "is isomorphic to", so its slightly weaker than "equal" because it requires an additional invertible conversion function.
23:18:35 <dminuoso> But in general we understand "is isomorphic to" to be worth about as much as "is equal to" :)
23:25:56 <dminuoso> jusss: https://gist.github.com/dminuoso/042ab43e6d865a194904e4aa4a8d8e83
23:26:16 <dminuoso> Monoids are everywhere. :)
23:27:55 <LarryTheCow> Hi. Has anyone here learned Category Theory before properly learning Abstract Algebra?
23:27:57 <tdammers> IRC is a monoid
23:28:21 <MarcelineVQ> ​
23:29:17 <LarryTheCow> ^^^ mempty?
23:29:44 <MarcelineVQ> :>
23:29:45 <tdammers> mempty is not loggin in at all, or, if you're already logged in, remaining silent
23:30:19 <LarryTheCow> would saying something be (<>)?
23:32:43 <xacktm> hmm I think order matters?  messages f <> (g <> h) can't happen because (g <> h) needs f imo
23:33:48 <MarcelineVQ> there's no real linkage between messages, irc is fairly asyncronous
23:34:39 <tdammers> order matters
23:34:48 <tdammers> at least on a per-channel basis
23:47:05 <LarryTheCow> Taking a break from monoid irc discussion, Is Bartosz's book good for learning Category Theory?
