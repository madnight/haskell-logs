00:14:21 <sim590> How can I import a file that has a module instruction inside in ghci? It complains that it doesn't like that.
00:15:13 <dminuoso> sim590: What is a "module instruction"?
00:15:30 <dminuoso> sim590: Which exact error are you seeing, and what command did you use to trigger it?
00:15:38 <sim590> dminuoso: module <name of my module> where
00:16:17 <dminuoso> sim590: Just import them with ⌜import ...⌝
00:16:28 <sim590> https://paste.debian.net/1094561/
00:16:58 <dminuoso> sim590: A module name must start with a capital letter.
00:16:58 <sim590> WHen I try to import, it doesn't find it. I get <interactive>:38:8: error: parse error on input ‘recursion’.
00:18:26 <sim590> Duh. It reaaaaaaaaaaaaaaallly needs a capital letter....
00:20:14 <[exa]> sim590: capitalized names serve for removing a bit of ambiguity when parsing some constructions
00:31:31 <dminuoso> sim590: https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-980005 - See the production rule ⌜modid  →  {conid .} conid⌝
00:34:48 <dminuoso> Together with ⌜conid → large { small | large | digit | ’ }⌝
00:35:22 <dminuoso> Which is the same rule used for non-operator constructor names.
00:35:28 <dminuoso> like data constructors.
00:37:27 * hackage registry 0.1.7.0 - data structure for assembling components  https://hackage.haskell.org/package/registry-0.1.7.0 (etorreborre)
01:53:58 * hackage boots-app 0.1.0.1 - Startup factories using IoC monad  https://hackage.haskell.org/package/boots-app-0.1.0.1 (leptonyu)
01:55:11 <Jinna> Is there a way to specify the type of `val` in do-notation for `val <- f x`?
01:57:03 <simon> Jinna, if you do `(val :: ...) <- f x`, I think it complains that you need to enable some GHC extension.
01:58:24 <simon> Jinna, you can do `val <- f x :: m ...` for some concrete `m`, but that's not exactly the same.
01:58:42 <simon> Jinna, or you can make sure that whatever you use `val` for implies this type.
01:59:54 <simon> ScopedTypeVariables, that is.
02:01:06 <ski> % myDouble :: Double <- readIO "945"
02:01:06 <yahb> ski: 
02:01:08 <ski> % myDouble
02:01:09 <yahb> ski: 945.0
02:01:20 <ski> (no brackets required)
02:01:24 <simon> ah, ok.
02:03:42 * ski is perhaps sometimes a bit allergic to redundant brackets .. unless they were inserted to ephasize something in particular
02:03:47 <ski> e.g.
02:04:12 <ski>   map :: ( a  ->  b )
02:04:13 <ski>       -> ([a] -> [b])
02:04:30 <ski> but writing e.g.
02:04:39 <simon> ski, I placed them out of ignorance. :)
02:04:41 <ski>   (Foo x) >>= k = ..x..k..
02:04:49 <ski> just looks silly, to me
02:04:54 <simon> ((I agree.))
02:04:59 <ski> or
02:05:03 <ski>   case ... of
02:05:16 <ski>     (x:xs) -> ..x..xs..
02:05:24 <ski>     _      -> ...
02:08:57 <ski> (if you insert extra, strictly speaking redundant, brackets, to shield the reader (e.g. yourself) from having to recall the relative precedence levels (and possibly associativity) of operators, that's also okay. but it ought to be a "reasonable" case, i suppose. writing `(foo x) + ((bar x y) * z)' also looks silly)
02:08:58 * hackage boots-app 0.1.0.2 - Startup factories using IoC monad  https://hackage.haskell.org/package/boots-app-0.1.0.2 (leptonyu)
02:10:23 <ski> (i think it would possibly be better if precedence levels weren't totally ordered ..)
02:15:58 * hackage salak 0.3.3.1 - Configuration (re)Loader and Parser.  https://hackage.haskell.org/package/salak-0.3.3.1 (leptonyu)
02:19:14 <off537[m]> Loops are worst complexity in programming. Change my mind
02:22:41 <dminuoso> off537[m]: There's elegant abstractions over loops like folds and traverses?
02:23:11 <Rembane> off537[m]: What about recursion?
02:23:19 <dminuoso> Or yeah recursion heh.
02:23:26 <dminuoso> ⌜traverse_ print [1,2,3,4]⌝ I'd say is an elegant way to "loop over a list and print each element"
02:23:53 <Rembane> I am very fond of that phrase. 
02:25:38 <dminuoso> I think loops might look nasty if you employ "first loop over each element, then do this and then do that" type of imperative thinking. The problem there though is not loops, its the imperative approach of trying to dissect a complex operation into small commands.
02:29:24 <ski> it has been argued that explicit recursion is the `goto' of FP
02:30:56 <ski> otoh, sometimes combinator approaches are less composable than desirable, though they can certainly sometimes be great
02:34:35 <ski> "The Anatomy of a Loop: a Story of Scope and Control" by Olin Shivers in 2005-09 at <http://www.ccs.neu.edu/home/shivers/citations.html#loop> is interesting. also cf. Riastradh's "foof-loop" <https://mumble.net/~campbell/scheme/foof-loop.txt>, or the ECL^{i}PS^{e} (do)/2 looping construct <http://eclipseclp.org/doc/tutorial/tutorial025.html>,<http://eclipseclp.org/doc/userman/umsroot023.html>
02:35:28 * Rembane does the recursion scheme dance
02:37:10 <ski> one could view the list comprehension language (including parallel list comprehensions <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#parallel-list-comprehensions>, and certainly also generalized (SQL-like) ones <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#generalised-sql-like-list-comprehensions>) as attempts in the same direction, though not as polished
02:37:48 <dminuoso> ski: In a lot of sense that makes sense because "breaking out of a loop" is usually implemented a jump, and the end of a loop is essentially also just a (conditional) jump.
02:38:13 <ski> "that" in "that makes sense" referring to ?
02:38:21 <dminuoso> ⌜11:29:03             ski | it has been argued that explicit recursion is the `goto' of FP⌝
02:38:33 <dminuoso> or wait
02:38:49 <dminuoso> Well, Id have to reformulate that to make better sense.
02:39:37 <ski> you can literally implement a state machine with `goto's jumping inbetween code blocks as (mutual tail-)recursion among functions
02:47:12 <ski> "The Swine Before Perl" (talk) by Shriram Krishnamurthi in 2001-11 at <https://cs.brown.edu/~sk/Publications/Talks/SwineBeforePerl/> is quite nice in illustrating this
03:15:38 <fuzzy_id> how do i get a function `(b -> Maybe c) -> Maybe (a, b) -> Maybe (a, c)`
03:16:31 <fuzzy_id> completely stuck
03:16:37 <[exa]> fuzzy_id: how nice do you want the solution to be?
03:16:41 <Rembane> :t second
03:16:43 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
03:16:49 <Rembane> :(
03:17:19 <fuzzy_id> [exa]: i mainly don't want to pattern match the whole thing together
03:17:41 <[exa]> it's a combo of 'join' and 'second' which Rembane suggested
03:17:49 <Rembane> :t \f mt -> fmap (second f)
03:17:52 <lambdabot> Functor f => (b -> c) -> p -> f (d, b) -> f (d, c)
03:18:00 <Rembane> something like that?
03:18:12 <Rembane> Hm... to many p
03:18:33 <[exa]> Rembane: he needs 'b-> f c' in the first arg
03:19:08 <Rembane> [exa]: Got it! 
03:19:15 <fuzzy_id> i can switch first and second argument, that's not a problem
03:19:32 <[exa]> fuzzy_id: in fact the second is better because 'fmap' works with it directly
03:20:43 <ski> @type (=<<) . traverse :: (b -> Maybe c) -> Maybe (a, b) -> Maybe (a, c)
03:20:46 <lambdabot> (b -> Maybe c) -> Maybe (a, b) -> Maybe (a, c)
03:21:42 <Rembane> That's nice. 
03:21:45 <fuzzy_id> yeah!
03:21:52 <dminuoso> Traversable ((,) a)
03:22:01 <ski> yep
03:22:03 <dminuoso> That's brilliant. :)
03:22:26 <[exa]> I should start remembering traverse as a Compose flip
03:23:02 <dminuoso> [exa]: Compose flip?
03:23:37 <[exa]> dminuoso: :t traverse.fmap
03:23:41 <ski> "distributive law", presumably
03:24:18 <[exa]> ski: yes that would probably describe it best
03:24:25 <[exa]> thanks :]
03:25:08 <[exa]> (ok, s/traverse/sequence)
03:25:19 <ski> @type sequenceA
03:25:20 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
03:25:22 <ski> @type (. sequenceA) . (fmap . fmap)
03:25:25 <lambdabot> (Traversable t, Applicative f) => (a -> b) -> t (f a) -> f (t b)
03:25:38 <ski> @type traverse . fmap
03:25:40 <lambdabot> (Traversable t, Applicative f) => (a -> b) -> t (f a) -> f (t b)
03:27:43 <ski> @type (=<<) . traverse
03:27:45 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> m (t a) -> m (t b)
03:33:23 <ski> @type ((sequenceA =<<) .) . fmap . second :: (b -> Maybe c) -> Maybe (a,b) -> Maybe (a,c)
03:33:25 <lambdabot> (b -> Maybe c) -> Maybe (a, b) -> Maybe (a, c)
03:34:20 <ski> @type (sequenceA =<<)
03:34:22 <lambdabot> (Monad m, Traversable t) => m (t (m a)) -> m (t a)
03:34:34 <fuzzy_id> i still have to digest this – so we use the applicative instance of maybe and the traversable of ((,) a), correct?
03:34:55 <ski> `Monad Maybe' and `Traversable (a,)'
03:35:49 <ski> (yea, i could have said `sequence' instead of `sequenceA', and `mapM' instead of `traverse' ..)
03:35:59 <ski> @type sequenceA
03:36:01 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
03:36:02 <ski> @type sequence
03:36:04 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
03:36:07 <ski> @type traverse
03:36:09 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
03:36:10 <ski> @type mapM
03:36:11 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
03:37:06 <fuzzy_id> uuuuh! that's an insight! Traversable wasn't really on my radar yet. but traverse is to applicatve what mapM is to monad. that's interesting!
03:37:18 <[exa]> fuzzy_id: (btw, without monad instance you can't squash the maybe-in-maybe)
03:37:52 <ski> yep, we really need `join :: Maybe (Maybe (a,c)) -> Maybe (a,c)' here
03:38:25 <fuzzy_id> that makes sense
03:38:30 <ski> (that's the `(=<<)' i was using, since `join (fmap f ma) = f =<< ma'. for lists `concat (map f xs) = concatMap f xs')
03:39:40 <ski> however, `sequence' and `mapM' are really idiomatic, they don't use the full dynamic sequencing power of monads. so, especially now that `Applicative' is finally a superclass of `Monad', one might just as well use `sequenceA' and `traverse' instead
03:40:33 <ski> (except, perhaps, if one's juggling both an idiom and a monad, one could possibly use `sequence' and `mapM' to emphasize which deals with the monad, and which deals with the idiom ..)
03:41:04 <fuzzy_id> what's an idiom?
03:41:18 <ski> (idioms express "static sequencing", and that's just what `sequence' and `mapM' really does/needs)
03:41:24 <ski> a synonym for "applicative functor"
03:44:49 <ski> (more or less, the existence of separate operations `sequence',`sequence_',`mapM',`mapM_',`forM',`forM_' over `sequenceA',`sequenceA_',`traverse',`traverse_',`for',`for_' is a historical accident. if we'd make a clean slate with what we know today, not caring about backwards compatibility, then the former six would probably not exist as separate operations)
03:46:12 <fuzzy_id> yeah, i just noticed that mapM is simply defined as traverse. anyways i like to have the `for`-functions around. looks more expressive than `flip map`
03:46:42 <fuzzy_id> well, not expressive. but expresses more clearly the job it's going to do…
03:47:56 <fuzzy_id> yeah! kewl! thank you very much!
03:48:27 * ski nods
03:48:30 <ski> np :)
03:52:57 * hackage bzlib-conduit 0.3.0.2 - Streaming compression/decompression via conduits.  https://hackage.haskell.org/package/bzlib-conduit-0.3.0.2 (MichaelSnoyman)
04:27:53 <dminuoso> fuzzy_id: And for full disclosure, for/for_/forM/forM_ are just flipped versions of traverse/traverse_/mapM/mapM_
04:55:28 * hackage hakyll-images 0.4.3 - Hakyll utilities to work with images  https://hackage.haskell.org/package/hakyll-images-0.4.3 (LaurentRDC)
05:09:18 <elcid> @pl \xs n -> take n xs
05:09:18 <lambdabot> flip take
05:09:44 <elcid> @pl scale ps n = [scaleString p n| p <- ps]
05:09:44 <lambdabot> scale = flip flip [] . ((:) .) . flip ((<-) . (| p) . scaleString p)
05:10:28 <elcid> @pl replicate n $ concatMap (replicate n) xs
05:10:29 <lambdabot> replicate n (replicate n =<< xs)
05:12:27 <elcid> @pl intercalate "\n" $ replicate n (replicate n =<< xs)
05:12:27 <lambdabot> intercalate "\n" (replicate n (replicate n =<< xs))
05:12:59 <elcid> @pl scaleString xs n =  intercalate "\n" $ replicate n (replicate n =<< xs)
05:12:59 <lambdabot> scaleString = (intercalate "\n" .) . ap replicate . (. replicate) . (>>=)
05:19:45 <Axman6> q
05:19:47 <Axman6> oops
05:29:27 * hackage oidc-client 0.4.0.1 - OpenID Connect 1.0 library for RP  https://hackage.haskell.org/package/oidc-client-0.4.0.1 (ShoKuroda)
05:45:44 <dminuoso> Interesting, so Bartosz described that the reason Product and Coproduct are so different from another has to do with functions being biased in the sense that one "end" can be lossy, but the other not.
05:47:17 <Rembane> Is there an adjunction hiding there? 
05:47:23 <Rembane> What's an end in this case?
05:48:14 <dminuoso> Rembane: If you think of a function as an arrow from a domain and pointing into the codomain.
05:50:15 <Rembane> dminuoso: Got it! 
05:50:39 <Rembane> dminuoso: And the domain -> codomain direction is easy and the other way around is hard?
06:09:27 * hackage timeutils 0.1.0 - Time utilities  https://hackage.haskell.org/package/timeutils-0.1.0 (jlamothe)
06:14:32 <ski> dminuoso : what's one way to think about it
06:19:54 <ski> s/what/that/
06:20:28 * hackage ghc-lib-parser 0.20190806 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-parser-0.20190806 (shayne_fletcher)
06:21:27 * hackage ghc-lib 0.20190806 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-0.20190806 (shayne_fletcher)
06:38:59 <tabaqui> cabal provides special call "getDataFileName" that allows including in run-time
06:39:15 <tabaqui> does it provide similar call to lookup resource file in *compilation*?
06:43:12 <tabaqui> hm, probably is useless anywhere except of TH
06:43:19 <tabaqui> *it is useless
07:09:49 <Boomerang> Hi! I have a library that uses doctest. Currently I'm finding all the .hs files and giving them to doctest. However only a couple modules actually contain doctest tests. If I change to an explicit list of modules that test-suite takes 1 minute instead of 5.
07:11:18 <Boom_Rang> Is there a way to both make the test-suite fast and not keep an explicit list of modules containing doctest tests?
07:12:30 <dmwit> Is the extra 4 minutes spent in finding the files or in having doctest run on them and do nothing?
07:12:45 <dmwit> If the latter, perhaps a quick first-pass grep would do you.
07:12:51 <Boom_Rang> I'm guessing the latter
07:13:12 <Boom_Rang> So use a regex library from Haskell? Any recommended one?
07:13:35 <dmwit> I'd literally use grep. `grep -Rl . '>>>'`
07:14:23 <dmwit> It's probably possible to get a few false positives that way but it'll likely still be better than doctesting literally all of the files.
07:14:30 <Boom_Rang> I'm using a lot of Control.Category.>>>, hopefully `\-\- >>>` is enough
07:14:41 <dmwit> Sure.
07:14:50 <dmwit> Don't forget to use -e to "escape" the pattern that starts with a -
07:15:00 <dmwit> grep -Rl . -e '-- >>>'
07:15:29 <Boom_Rang> But the grep method is what I do to get the list of modules manually. I'm worried I'll add more doctest in the future in modules that are not in the explicit list
07:16:04 <Boom_Rang> I have tried the doctest-discover package but that doesn't seem to solve this particular issue (it also includes all sources by default)
07:18:41 <elcid> @pl maxLength ps = maximum $ map length ps
07:18:41 <lambdabot> maxLength = maximum . map length
07:19:58 * hackage mssql-simple 0.4.0.0 - SQL Server client library implemented in Haskell  https://hackage.haskell.org/package/mssql-simple-0.4.0.0 (tkmsm)
07:32:57 * hackage PyF 0.8.0.0 - Quasiquotations for a python like interpolated string formater  https://hackage.haskell.org/package/PyF-0.8.0.0 (guibou)
07:47:17 <rubik> has anyone advice how to get history in this scheme interpreter? i'm about to use inline-c for that
07:53:35 <Cale> rubik: inline-c? How is that going to help?
07:53:55 <Cale> Maybe I don't understand what you're trying to get?
07:54:21 <rubik> Cale: that is possible
07:54:36 <dmwit> (What scheme interpreter?)
07:54:37 <Cale> Just like, line history?
07:54:48 <rubik> hmm, i want to cycle between the typed in commands i entered
07:56:20 <Cale> You could use a library like haskeline, or you could just do it yourself and hang on to the list of commands as an argument to your repl (assuming it's recursive)
07:57:39 <Cale> Well, implementing line editing yourself is probably a bit of a pain
07:59:08 <Cale> http://hackage.haskell.org/package/repline also looks nice for this kind of thing
07:59:24 <rubik> ok thx, will look for haskeline
07:59:27 <Cale> (just wraps haskeline in a way that makes the common case easy)
07:59:33 <Cale> http://hackage.haskell.org/package/haskeline
08:07:25 <Boarders> Could someone tell me what it means if allocated:iters is very high when I run benchmark?
08:08:12 <Boarders> I presume the number indicated the total number of bytes allocated during a single run of the benchmark
08:08:59 <Boarders> I ask  because I am perplexed by this issue: https://github.com/Gabriel439/Haskell-Foldl-Library/pull/142
08:17:28 <kuribas> isn't the writer monad very inefficient for writing many strings?
08:17:56 <portnov1> hi all
08:18:05 <rubik> portnov1: hi
08:18:11 <Taneb> kuribas: yeah, Writer is kind of bad
08:18:24 <portnov1> https://gist.github.com/portnov/012d3282093d0d85fb7f4a9b21522d23
08:18:27 <kuribas> I suppose I could wrap it in Endo
08:18:38 <portnov1> is there some problem with lts-14.0 ?
08:18:42 <kuribas> I just want to collect a bunch of strings to output
08:19:00 <Cale> Yeah, try Endo. The efficiency for writing strings depends on how your computation is associated, while it won't with Endo.
08:19:02 <kuribas> or is there a good monad for that?
08:20:04 <kuribas> but "tell $ Endo $ (: "message") " is a bit of a code smell
08:20:57 * hackage mssql-simple 0.4.0.1 - SQL Server client library implemented in Haskell  https://hackage.haskell.org/package/mssql-simple-0.4.0.1 (tkmsm)
08:21:17 <Taneb> kuribas: have you seen the DList package?
08:21:44 <Taneb> It's got a monoid which is essentially Endo [a], which has an IsString instance if a ~ Char
08:21:56 <Cale> kuribas: You mean tell $ Endo ("message" :)
08:22:13 <Cale> but also, you can simply define a function which does that
08:22:19 <kuribas> Cale: yes
08:22:44 <Cale> tellMsg m = tell (Endo (m :))
08:23:59 <Cale> Unless the amount of code which is written using a transformer is quite small, I usually try to get away from the mtl classes almost immediately anyway
08:24:39 <Boarders> kuribas: also after using some variant on DList or other text builder type you could try benchmarking with this version of writer: https://hackage.haskell.org/package/writer-cps-mtl-0.1.1.6
08:24:42 <Cale> It's almost always better to have your own type class with more meaningful/application specific operations.
08:24:53 <Boarders> since the mtl one is supposed to have a space leak problem
08:26:07 <Boarders> kuribas: if you don't need string then something like this might be faster: http://hackage.haskell.org/package/text-1.2.3.1/docs/Data-Text-Lazy-Builder.html
08:28:38 <kuribas> Boarders: right, a lazy builder may be the best option here
08:30:38 <dexterfoo> Why doesn't the last one work the same as the others?  (1 +) (1 /) (1 *) (1 -)
08:31:09 <merijn> dexterfoo: In what way is it different?
08:32:25 <dexterfoo> oops i think i meant (-1)
08:32:39 <Cale> Well, (-1) doesn't work like (+1) because it's negative 1
08:32:45 <jollygood2> (-1) is a syntax wart
08:32:48 <dexterfoo> but before i was having problem also with (1-)
08:33:05 <Cale> Negation takes priority over forming an operator section
08:33:12 <Cale> > (1-) 5
08:33:14 <jollygood2> negate 
08:33:15 <lambdabot>  -4
08:33:16 <jollygood2> negate 
08:33:20 <jollygood2> > negate 5
08:33:23 <lambdabot>  -5
08:33:36 <Cale> > subtract 1 5
08:33:39 <lambdabot>  4
08:33:43 <jollygood2> that's the one!
08:33:47 <dexterfoo> @pl (\x -> x + 1)
08:33:47 <lambdabot> (1 +)
08:33:49 <dexterfoo> @pl (\x -> x - 1)
08:33:49 <lambdabot> subtract 1
08:34:42 <Cale> If you're really code golfing, you can write (+(-1))
08:34:45 <jollygood2> > flip (-) 1 5
08:34:48 <lambdabot>  4
08:42:16 <tabaqui> I heard that badasses use (<<<) instead of (.)
08:44:39 <dmj`> badasses use <$> or <&>
08:45:49 <tabaqui> (->) instances of Applicator/Monad? Cool stuff too
08:46:35 <tabaqui> f >>= g == \x -> g (f x) x; f <*> g = \x -> f x (g x)
08:52:27 <Boarders> does anyone know of any benchmarking framework that tests maximum heap usage as opposed to total number of allocations?
08:52:38 <domenkozar[m]> Is there a way to print CallStack when catching exceptions with `try`?
08:53:07 <Boarders> also should I worry if I produce code that is faster that produces more allocations but which has the same residency?
08:54:25 <merijn> Boarders: Allocations are basically irrelevant, because they're super cheap
08:54:43 <Boarders> ah I see, thank you
08:55:11 <merijn> As long as residency and GC time are fine I wouldn't even look at it
08:59:12 <dmj`> domenkozar[m]: pretty sure you need to compile with -profiled and use -xc 
08:59:36 <dmj`> domenkozar[m]: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html?highlight=xc#rts-flag--xc
08:59:42 <merijn> dmj`: That or explicitly use HasCallstack
09:01:30 <Boarders> is there a haskell library for benchmarking residency?
09:01:54 <merijn> Boarders: Is "+RTS -sstderr" not sufficient?
09:02:13 <Boarders> I want to run it on several different functions in a benchmarking suite
09:02:50 <merijn> Boarders: Not aware of any libraries, but there's: https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Stats.html
09:03:13 <dmj`> @package weigh
09:03:13 <lambdabot> http://hackage.haskell.org/package/weigh
09:03:25 <Boarders> weigh is about total number of allocations I think
09:03:42 <Boarders> Is it just the case that maximum residency is not useful for a single function?
09:04:04 <Boarders> and you would only look into it if you notice your whole application has too high a memory usage
09:04:06 <Boarders> ?
09:04:06 <merijn> Boarders: What exactly can you learn from max residency that you can't from max allocation?
09:04:25 <domenkozar[m]> dmj`: merijn so this doesn't work https://gist.github.com/domenkozar/a886d7de4cefaaa8c8d3a5d7bff6b0e5
09:05:03 <Boarders> merijn: does weigh include max allocation?
09:05:25 <merijn> Boarders: GHC.Stats which I just linked does
09:06:05 <Boarders> oh yes, I am just incompetent to be able to use that library
09:06:29 <dmj`> domenkozar[m]: nix-shell -p ghc --run 'ghc -fprof-auto -prof -rtsopts -threaded Main.hs -o main'
09:06:39 <dmj`> domenkozar[m]: *** Exception (reporting due to +RTS -xc): (THUNK_2_0), stack trace:
09:07:00 <dmj`> Boarders: there is a library called ekg
09:07:05 <domenkozar[m]> yeah but still no stack :)
09:07:23 <dmj`> domenkozar[m]: it shows a stack :)
09:07:30 <dmj`> *** Exception (reporting due to +RTS -xc): (THUNK_2_0), stack trace: 
09:07:30 <dmj`>   Main.g,
09:07:30 <dmj`>   called from Main.f,
09:07:30 <dmj`>   called from Main.main
09:07:30 <dmj`> ""
09:07:57 <dmj`> Boarders: ekg uses GHC.Stats
09:08:09 <dmj`> but gives you a nice UI for watching the haskell heap
09:08:30 <domenkozar[m]> dmj`: I see, I was missing -fprof-auto
09:08:42 <domenkozar[m]> how much overhead does -xc add?
09:08:49 <ski> hmm .. i wonder whether it would be possible to see such a stack trace as a nested expression
09:09:34 <dmj`> domenkozar[m]: it's significant, every heap object now is tagged with profile info. If speed is an issue you might want to consider, but I know companies in production with profiling solely because they get stack traces like this
09:09:44 <dmj`> s/consider/reconsider
09:10:25 <domenkozar[m]> I guess hardware is cheaper than my time
09:10:45 <dmj`> domenkozar[m]: compiled haskell is fast, even w/ profiling enabled
09:11:21 <domenkozar[m]> I guess we'll roll out profiling then once GHC 8.8 hits
09:11:33 <domenkozar[m]> (can't use it now due to some CPP trickery)
09:11:58 <dmj`> domenkozar[m]: hits nixpkgs ? that's how I define "landed" :)
09:12:19 <domenkozar[m]> exactly
09:12:24 <domenkozar[m]> thanks
09:12:30 <dmj`> np
09:13:30 <jollygood2> what haskell libraries should one use to fetch web content through tor?
09:15:05 <shapr> jollygood2: I think you can set tor as a proxy? I've seen that tor browser exists, I suspect it uses the same old web content things with proxy settings?
09:16:35 <jollygood2> shapr I believe so. but I still some tor library for interacting with tor servers. I see several on hackage, but I'm not sure which one is suitable
09:17:04 <shapr> jollygood2: perhaps check the matching source repositories for recent activity?
09:17:20 <shapr> what counts as suitable?
09:17:51 <jollygood2> something that works 
09:18:26 <jollygood2> also, I need more than one proxy at a time
09:27:16 <wroathe> So with DataKinds, if I have a data Foo = Foo, and now I have a type 'Foo, how do I go about constructing a value of type 'Foo?
09:27:44 <wroathe> 'Foo's kind seems to be Foo, and GHC complains that that's not a type
09:31:27 <geekosaur> there are no values, because values are only possessed by things of kind * (old name) or Type (new)
09:31:36 <geekosaur> kind Foo will not have types that possess values
09:32:25 <wroathe> Thanks for confirming
09:32:45 <EvanR> "not a type" vs "not a Type"
09:33:51 <geekosaur> mostly you do this for type level things like tagging a type with values to constrain where it can be used.
09:35:12 <geekosaur> I rather suspect needin g to deal with non-Type kinded values would be an utter nightmare
09:36:55 <wroathe> geekosaur: I was hoping to use this as a quick way to create a bunch of unit types from a datatype with many value constructors
09:37:06 <geekosaur> well, yes, that last is rather loose at best
09:37:22 <geekosaur> (er, that wasn't about your most recent remark, but about mine)
09:37:51 <geekosaur> Proxy :: Proxy Foo, Proxy :: Proxy Bar, ...
09:37:58 <geekosaur> depending on what you're doing
09:39:30 * ski rather suspects it needn't be
09:45:11 <wroathe> geekosaur: That actually solves my problem just fine
09:45:17 <wroathe> geekosaur: I keep forgetting about Proxy
09:48:27 * hackage stratosphere 0.41.0 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.41.0 (jdreaver)
09:48:35 <saml> https://medium.com/better-programming/fp-toy-7f52ea0a947e
10:17:59 <dmj`> dependency injection is like a poor man's free monad
10:21:29 <wroathe> So say I've got a bunch of newtype Foo = Foo newtype Bar = Bar, ... and I want to still be able to have a list of all of these related datatypes
10:21:54 <wroathe> I could create a datatype wrapper for this like, data Token = Foo Foo | Bar Bar | ...
10:22:07 <wroathe> So I can do [Token]
10:22:27 <ski> are they `newtypes' of the same thing ?
10:23:23 <wroathe> ski: Yeah, I'm still working on this parser and I think I see an opportunity to specify precisely the grammatical structure of my input file using just types and really improving type safety, but I still want the ability to parse the file as a stream of Tokens if I feel like it
10:23:35 <ski> do you need to be able to refer to the different token types, as separate types ?
10:24:31 <wroathe> So an example production rule might look like this: | GrammarFile [PrologueDecl] PercentPercent_ Grammar (Maybe Epilogue_)
10:24:58 <wroathe> Where PercentPercent_ is just a newtype PercentPercent_ = PercentPercent_
10:25:14 <wroathe> and Epilogue is newtype Epilogue_ = Epilogue_ Text
10:25:15 <ski> i suppose you mean a `()' at the end of that
10:25:27 <ski> (the `PercentPercent_' one)
10:25:54 <wroathe> Oh, no, I mean data PercentPercent_ = PercentPercent_ then
10:26:11 <wroathe> Well, it doesn't really matter, the idea being the same and all
10:26:20 <ski> ok, `data'
10:26:21 <wroathe> I've got 50 or so of these Foo_ types
10:26:28 <ski> so, it seems you're building a parse tree, rather than an abstract syntax tree ?
10:26:33 <wroathe> and I want to be able to still lex the file into a stream of tokens
10:27:11 <wroathe> Well, the types model a parse tree, but the end result of parsing would technically be an AST, right?
10:27:42 <wroathe> https://github.com/JustinChristensen/bison-grammar-codegen/blob/master/src/Bison/Grammar/Types.hs#L88 Ignore the 'a's and the functor stuff in this
10:27:45 <wroathe> I'm redoing it
10:28:26 <ski> depends on whether the end result will use the types you sketched above, or not, no ?
10:29:20 <wroathe> The issue more generally is that paramterizing these with "a" and having that be the Token type above makes it so there are many valid parser functions I can write to create values of this type
10:29:50 <ski> ok, so `a' is the token type
10:30:02 <ski> (perhaps i'd call it `t' or `tok')
10:30:11 <wroathe> Where it would be more correct to specify that a single rule is something like: Production1 NonTerminal Terminal [Terminal] NonTerminal
10:30:20 <wroathe> I'm getting rid of the a
10:30:23 <wroathe> Ignore that
10:30:24 <ski> okay
10:30:40 <wroathe> data GrammarFileF a is becoming just data GrammarFile
10:31:08 <wroathe> In that example I've got Production1 NonTerminal a [a] NonTerminal, which isn't as type safe as I'd like it to be
10:31:22 <ski> why not ?
10:33:04 <wroathe> Well, maybe type safety isn't the issue. I'm trying to make it so that it would be invalid to write something like: GrammarDecl <$> rules <*> colon_, when I know the actual grammatical structure is GrammarDecl <$> rules <*> semicolon_
10:33:54 <wroathe> By specifying that the second parameter of GrammarDecl can be ANY token that means there are multiple valid ways to get a value of that type, but in reality the grammatical structure should only allow for semicolon_
10:34:37 <wroathe> So rather than GrammarDecl [Rule] Token, I want to have something like GrammarDecl [Rule] Semicolon_
10:35:40 <wroathe> See, Token has many possible values, but only one is actually correct here
10:35:47 <ski> hm
10:35:47 <wroathe> Hence splitting it up into newtypes
10:35:59 <wroathe> But I still want the ability just to scan my file as a stream of Tokens
10:36:05 <wroathe> Get it?
10:36:26 <ski> i thinkn
10:36:54 <wroathe> I think I might just have to bite the bullet and do it all by hand (write the wrapper Token type in terms of the smaller newtypes being used in the grammar)
10:37:26 <dmj`> wroathe: what language are you trying to lex / parser, does it have a bnf ?
10:37:39 <wroathe> dmj`: Yacc files
10:37:48 <wroathe> dmj`: And yes, it's literally a BNF
10:38:45 <dmj`> wroathe: you could probably use alex / happy then if its well defined, what GHC uses
10:39:14 <wroathe> dmj`: For now I'm just going to do this in terms of parser combinators
10:39:20 <wroathe> dmj`: Unless performance becauses a big concern
10:39:25 <wroathe> becomes a*
10:39:50 <wroathe> So far this tokenizes a file with 200000 lines in like 5 seconds
10:41:00 <wroathe> Also, this is becoming an experiment in expressing a program's structure in terms of types. It's cool to think you define an entire grammar at the type level
10:41:08 * ski . o O ( "Happy Happy, Yacc Yacc." )
10:41:38 <iqubic> Is there a BNF grammar that specifies proper BNF syntax?
10:42:39 <hyperisco> iqubic, yes, read the Wikipedia page
10:42:55 <dmj`> iqubic: haha
10:43:28 <dmj`> wroathe: at the type level ?
10:43:46 <dmj`> why not at the value level, then just promote ?
10:45:03 * ski did a small DSL in Prolog, for describing the intended shape of data (a bit like a `data' type declaration, but implemented as a predicate, possibly also doing more advanced run-time checks), and described the intended DSL format in itself
10:48:28 <wroathe> ski: This makes sense right? I'm not trying too hard on this?
10:50:10 <wroathe> feels a bit weird writing newtype Semicolon_ = Semicolon_ ()
10:52:35 <ski> sortof
10:54:04 <ski> i was wondering whether it would be more likely to make the kind of mistake, like `Colon_' instead of `Semicolon_', rather than making the mistake of defining `colon_' with the wrong type (`Parser Semicolon_')
10:54:46 <wroathe> I think I'm just going to do a middle ground and not capture that part of the structure in the types
10:59:06 <iqubic> Make sure the values being parsed have semicolons, but just drop them from the types. Sounds good.
11:07:25 <Gander01> Is there an easy way to change the value of a variable depending on the "type" of input from a data type I created? In one of my functions I need a variable to differ depending on where something is a variable, abstraction or application
11:09:37 <Gander01> It isn't one of the function inputs and I'm not allowed to edit that
11:10:23 <Cale> Gander01: You probably don't mean type (though that is also possible), you probably just mean which data constructor it is
11:10:32 <Cale> You can write a case expression to pattern match
11:10:37 <Cale> case input of
11:10:41 <Cale>   Var x -> ...
11:10:59 <Cale>   Abs name body -> ...
11:11:04 <Cale>   App e1 e2 -> ...
11:11:32 <ski> you could also define a local function, by pattern-matching "in the head"
11:12:00 <ski>   foo x y = blah input
11:12:04 <ski>     where
11:12:10 <ski>     blah (Var x) = ...
11:12:19 <ski>     blah (Abs name body) = ...
11:12:26 <ski>     blah (App e e0) = ...
11:13:47 <Gander01> Okay, I'll give that a go. Cheers guys :D
11:19:57 * hackage cmptype 0.1.0.0 - Compare types of any kinds  https://hackage.haskell.org/package/cmptype-0.1.0.0 (isovector)
11:30:17 <st8less> Super-stupid question, but I'm not phrasing it right in the search engine.  I have a variable that is a long-ish list.  How do I break that up over a few lines?  I tried '\', but ghci is still mad.
11:31:33 <merijn> st8less: I don't think anyone ever bothered to do that in ghci, at this point people would just write it in a file
11:32:02 <st8less> Yeah, I'm loading it from a .hs file
11:32:24 <Boarders> could you paste what you are currently doing
11:32:30 <Boarders> usually something like
11:32:31 <Boarders> ```
11:32:47 <Boarders> ``` [1,2,3,\n 4,5,6]```
11:32:48 <Boarders> should work
11:33:23 <st8less> Yeah, it's stupid simple, just a list of a few primes.  ```primes = [2, 3, 5, ```
11:34:47 <ski> just indent the continuation
11:34:57 <ski> and don't write any `\'s at end of line
11:35:39 <ski> (btw, if you wanted to, you could define a list of all (say positive) primes)
11:35:48 <st8less> ski: Awesome, thanks!  Coming from python you would think I'd have tried that.
11:37:24 <st8less> Define a list differently than the above?  I have a function that generates primes, but what I'm writing takes a small number of primes and runs combinations through a function, so I'm statically defining them.
11:38:07 <st8less> I'm just playing around with some project euler problems and trying to learn some functional programming along the way.  Really have no idea what I'm doing.  :)
11:40:30 <merijn> st8less: tbh, I think project euler is kinda bad for learning to program in general and Haskell in particular (because it forces you to work in one of the slightly messier bits of the language)
11:40:55 <merijn> (Not to say Euler is bad in general/not fun, just bad for practicing programming, as opposed to, say, number theory)
11:46:35 <ski> st8less : hm, i didn't follow what you were using those small number of primes for
11:49:13 <st8less> Day job is already as a developer.  This is just brain exercise.  I'm not particularly good at any of it, but I like to mess with numbers.  Some PE problems suck to figure out in Haskell, but a few lend themselves pretty nicely to it.  It's really challenged me when thinking about stuff like recursion.
11:54:22 <ski> practicing recursive thinking is good
11:54:30 <jollygood2> with Options.Applicative, is it possible to require one or other option? myprog --once  or  myprog --loop. anything else should print usage or help
11:54:54 <ski> st8less : if you were using those small number of primes, to define an infinite list of primes, then you don't need to do that. you can define it in terms of itself
11:55:16 <merijn> jollygood2: Parser from optparse-applicative is an instance of Alternative, so yes
11:55:21 <ski> primes are the integers greater than `1', which are not composite
11:56:25 <ski> (positive) composites are those numbers which are a product of a prime, and an integer greater than `1'
11:56:57 <ski> this (more or less) will work to define these two infinite lists of numbers
11:57:52 <jollygood2> merijn, am I suppose to use option :: ReadM a -> Mod OptionFields a -> Parser a   or something else?
11:58:21 <jollygood2> I guess you're implying that I should use <|>
11:58:54 <cocreature> jollygood2: exactly, <|> should do the trick
11:59:11 <st8less> ski: Thanks, I found the Haskell wiki link on it.  I'll read through that next.
11:59:30 * ski is unsure about which wiki page st8less found
12:01:13 <ski> st8less : i suppose you did see the Fibonacci thing "chasing its own tail" ?
12:02:12 <st8less> https://wiki.haskell.org/Prime_numbers, no didn't see the Fibonacci thing.  I read about doing it with linear algebra the other day.  That was interesting.
12:02:34 <merijn> jollygood2: Yeah, you can just combine things with <|> and many, I think the readme also has a whole bunch of examples
12:02:49 <ski> well, you know the usual definition
12:02:55 <ski>   fib :: Integer -> Integer
12:02:57 <ski>   fib 0 = 0
12:02:59 <ski>   fib 1 = 1
12:03:15 <ski>   fib n = fib (n-1) + fib (n-2)
12:03:34 <st8less> Yeah
12:03:39 <ski> which is exponential in time (while one could expect linear complexity)
12:04:24 <ski> and one typical approach (to do a limited form of dynamic programming) is to "cache the last two results"
12:04:31 <Cale> A nice way to think about the complexity of that fib function is that it has to be adding at least fib n ones together to produce its result
12:04:51 <ski>   fib :: Integer -> Integer
12:04:58 <ski>   fib = fibStep 1 0
12:05:00 <ski>     where
12:05:14 <ski>     fibStep :: Integer -> Integer -> Integer -> Integer
12:06:06 <ski>     fibStep fib_n_1 fib_n 0 = fib_n
12:06:25 <ski>     fibStep fib_n_1 fib_n i = fibStep fib_n (fib_n_1 + fib_n) (i-1)
12:07:22 <ski> however, you can define an infinite sequence `[fib i | i <- [0 ..]]' directly
12:07:24 <ski> instead of
12:07:53 <ski> well, scratch that. you define
12:07:56 <ski>   fibs :: [Integer]
12:08:20 <ski>   fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
12:09:13 <st8less> Ok, cool, I'll definitely mess around with that.
12:09:30 <ski> so, you know the first two elements are `0' and `1'. to compute the next one, `zipWith' needs to know the first one, of `fibs' and `tail fibs', which we just saw was `0' and `1'. so the next is also `1'
12:09:57 <dasli> Is there a good way to forward-declare a type in one package that can be defined in a separate package?
12:09:58 <jgt> these fibs implementations remind me of this classsic: https://www.cs.utexas.edu/~cannata/cs345/Class%20Notes/10%20Haskell%20Programmer%20Evolution.html
12:10:06 <ski> the next after that requires getting the second element of `fibs', which is `1', and the second of `tail fibs', which is `1' (as we just computed)
12:10:09 <ski> and so one
12:10:44 <ski> st8less : so, it's like a cat chasing its own tail, but never reaches it (and so we continue producing element after element)
12:10:50 <dasli> I had some success by defining a type family of zero indices, but it always felt wrong.
12:10:57 <st8less> Awesome, thanks again!
12:11:45 <dasli> And now I'm running into some seeming limitations that imposes, namely that I can't include a phantom type variable in the type family instance
12:13:26 <ski> @where evolution
12:13:26 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
12:13:33 <ski> jgt, yea :)
12:18:33 <jollygood2> does this look good? I'm pretty new to options applicative.   data Mode = Loop | Once String   options = ProgOptions <$> modeParser;   modeParser :: Parser Mode ...
12:20:21 <jollygood2> hmm, this is wrong. help file suggests loop should accept an argument, but it doesn't.  ( option (return Loop) ( long "loop" ))
12:20:38 <jollygood2> myprog --once arg  or myprog --loop
12:20:49 <merijn> jollygood2:  You probably want flag instead of option?
12:21:17 <merijn> jollygood2: I suggest having a good look at the readme, as it has quite a lot of examples
12:21:45 <jollygood2> I checked hackage and readme, and I understand most examples, but what I'm trying to do is kind out unconventional
12:21:58 <merijn> jollygood2: How so?
12:22:02 <jollygood2> replacing option with flag gave me errors
12:23:30 <jollygood2> merijn, I think the usual way to do this would be --mode loop | --mode once, but I don't like that
12:24:58 * hackage taskell 1.5.0.0 - A command-line kanban board/task manager  https://hackage.haskell.org/package/taskell-1.5.0.0 (smallhadroncollider)
12:25:07 <jollygood2> and any two options/flags are usually independent
12:25:30 <merijn> jollygood2: You can make sets of flags dependent easily enough in optparse
12:26:17 <merijn> I mean, as far as I can tell you just have 1 option and 1 flag and you need to select between those? That's seems rather straightforward
12:28:26 <merijn> jollygood2: All you do is define "onceOption :: Parser Mode" and "loopFlag :: Parser Mode" and then do "onceOption <|> loopFlag"?
12:32:04 <jollygood2> I got it to compile. ( option (Once <$> str) ... ) <|> ( flag Loop Loop ...)
12:32:23 <jollygood2> looks pretty weird. but I'll take it
12:32:41 <merijn> I think you want "flag' Loop ..."
12:32:55 <jollygood2> it takes two arguments. one when flag is set, and one when it isn't
12:33:15 <merijn> jollygood2: Right, so if you do "flag Loop Loop" it will always succeed parsing loop
12:33:30 <merijn> What you want is flag' which takes only one argument and fails if the flag isn't specified
12:33:36 <jollygood2> I'm assuming option Once will have precedence (have yet to test it)
12:33:53 <merijn> it does, but will you remember that when you refactor a year from now? :p
12:34:12 <jgt> @i printf
12:34:12 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect irc-password irc-persist-connect v @ ? .
12:34:13 <jollygood2> well what else would you put there? error?
12:34:39 <jgt> > printf "%0.*f" 5 1.2
12:34:44 <lambdabot>  error:
12:34:44 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M338092150886...
12:34:44 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
12:34:56 <merijn> jollygood2: If you use flag' they HAVE to use either --once or --loop, else it will return an error and print the help
12:35:03 <jgt> > printf "%0.*f" (5 :: Int) (1.2 :: Double)
12:35:05 <lambdabot>  error:
12:35:05 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M824339143491...
12:35:06 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
12:35:15 <merijn> jollygood2: With your definition if someone doesn't specify any flag it will silently treat that as --loop
12:35:19 <jgt> > printf "%0.*f" (5 :: Int) (1.2 :: Double) :: String
12:35:22 <lambdabot>  "1.20000"
12:35:33 <jgt> how do I make that output "1.2"?
12:35:52 <merijn> If that's what you want, then why bother using --loop as flag at all? Then you could just do "onceOption <|> pure Loop"
12:35:53 <jgt> I don't want the accuracy to always be to five places
12:35:56 <jollygood2> oh, I did not notice ' in flag in your message
12:36:03 <jgt> I want it to be at _most_ five places
12:37:45 <jollygood2> yeah, flag' works
12:38:22 <jollygood2> (and just flag doesn't. it returns Loop when I don't pass any argument)
12:38:42 <jollygood2> which is exactly what I told it to do
12:44:48 <jgt> how do I turn a number like 8.33333333333333e-2 into one that doesn't have an `e` in it?
12:45:08 <geekosaur> use f instead of e or g in printf
12:45:38 <geekosaur> if you mean show instance, that's using g format via Show instance; use the formatters in the Numeric module explicitly instead, or printf if you must
12:45:42 <Cale> Or Numeric.showFFloat
12:45:46 <Cale> yeah
12:45:49 <geekosaur> I stronly suggest Numeric because printf's a hack
12:45:56 <geekosaur> and possibly buggy as with your question
12:46:21 <geekosaur> (other printf-s I just tested elide trailing zeros as documented for g format spec)
12:46:54 <geekosaur> hm, except I have a vague recollection we found the same bug in Numeric a few months back...
12:47:12 <monochrom> > showFFloat (Just 3) 1.2 ""
12:47:15 <lambdabot>  "1.200"
12:47:23 <Cale> > showFFloat Nothing (5/6) ""
12:47:26 <lambdabot>  "0.8333333333333334"
12:47:37 <Cale> > showFFloat (Just 3) (5/6) ""
12:47:41 <lambdabot>  "0.833"
12:48:00 <jgt> monochrom: is there a way to get "1.2" instead of "1.200"?
12:48:33 <monochrom> No.
12:48:48 <monochrom> In C I get "1.200000" too.
12:49:00 <Cale> Well, there's surely a way :D
12:49:24 <Cale> (But it might not already be in the library)
12:49:48 <monochrom> In fact I support trailing zeros to remind all of us that we have no confidence about 1.2 exact.
12:49:55 <jollygood2> removing trailing 0s shouldn't be hard
12:50:08 <jollygood2> monochrom user of the program doesn't need that reminder
12:50:12 <geekosaur> only if you force trailing ., or check for 0 first
12:50:35 <geekosaur> that is, removing trailing zeros from the value 0 is not quite doing what you usually want
12:51:49 <jollygood2> geekosaur, still qualifies as not hard
12:53:37 <jollygood2> I'm surprised that a library dedicated to nothing more than showing floats doens't support that.. or using somethign other than '.' for decimal point, for that matter
13:00:07 <jgt> > reverse (dropWhile (== '0') (reverse (showFFloat (Just 5) (0 :: Double) "")))
13:00:10 <lambdabot>  "0."
13:00:19 <jgt> that's as far as I've come
13:01:30 <monochrom> You know what, I would brute force it.  Find the shortest prefix such that parsing it gives you the number you want.
13:11:00 <jgt> monochrom: how about this?
13:11:02 <jgt> showPercent :: Double -> Text
13:11:03 <jgt> showPercent d =
13:11:05 <jgt>   case dropWhile (== '0') (reverse (showFFloat (Just 5) d "")) of
13:11:07 <jgt>     s@(h:r) -> pack $ if h == '.' then reverse r else reverse s
13:11:09 <jgt>     []      -> "0"
13:14:01 <jgt> it seems to be working with all the test cases I've thrown at it
13:25:57 <hyperisco> If you're rounding, 1.2 is not the same as 1.20
13:37:13 <jgt> how are they not the same?
13:37:29 <jle`> from a notational standpoint?
13:37:44 <jgt> like, I just want to display a number, for humans, as text
13:37:54 <jgt> I'm not doing further computations with it
13:38:00 <geekosaur> "rounding"
13:38:23 <geekosaur> this is not rounding like "just show it to humans", there's a whole thing about runding for computation to minimize errors
13:38:31 <jle`> i mean, 1.2 and 1.20 is interpreted differently from a human standpoint
13:38:44 <jgt> jle`: when?
13:38:57 <geekosaur> and yes, we do infer things from that too. 1.20 is understood as more precise
13:39:03 <jle`> if i tell you a stick is 1.2 meters long vs. 1.20 meters long, it says different things
13:39:05 <merijn> jgt: Generally different significance
13:39:24 <jle`> compare if i say i am 1.6 meters tall vs. 1.60 meters tall
13:39:29 <jgt> right, that makes sense
13:39:30 <jgt> but
13:39:34 <jgt> who cares about this?
13:39:38 <jgt> and I don't mean that sarcastically
13:39:42 <geekosaur> uh
13:39:46 <jle`> well, if your point is to convey information
13:39:47 <jgt> I mean, perhaps engineers and mathematicians care
13:39:51 <jle`> the two different ones convey different information
13:39:54 <jgt> but so insurance salesmen, for example?
13:40:03 <geekosaur> sometimes, yes
13:40:03 <jgt> s/so/do/
13:40:06 <geekosaur> depends on the context
13:40:08 <monochrom> "1.2" means you don't promise whether it's "1.21", "1.19", or "1.20".  "1.20" makes a stronger promise.  But you and jollygood2 disbelieve that.  OK, do what you need, you don't need my approval, I'm done arguing.
13:40:16 <jgt> right, I'm asking about the context
13:40:24 <merijn> jgt: tbh, if you're dealing with insurance salesmen I should hope to god you're not using floats anyway, since those are presumably dealing with money
13:40:40 <merijn> And using floats for money is a deadly sin
13:40:43 <geekosaur> you're the one who knows the context. for an insurance salesman, if it's for an actuarial table and determines what rate someone's paying, you bet they care
13:40:43 <jgt> …
13:40:46 <jgt> -_-
13:40:48 <jle`> also keep in mind i jumped in during the middle of this conversation so i have no idea what we are actually talking about, i'm just saying that displaying 1.2 and displaying 1.20 mean two different things to a human
13:40:52 <jgt> I'm using safe-money for anything to do with money
13:40:53 <jle`> heh
13:41:06 <jle`> so i don't really have the full context to appreciate the nuances of the actual discussion
13:41:54 <jle`> > printf "%s" (show 0.2)
13:41:58 <lambdabot>  error:
13:41:58 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M538345492294...
13:41:58 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
13:42:03 <jgt> geekosaur: that's a good answer. I believe in my context, the variable degree of rendered accuracy is not an issue, since exact rates (and calculated amounts) end up in legal contracts anyway
13:42:10 <jle`> > printf "%s" (show 0.2) :: String
13:42:14 <lambdabot>  "0.2"
13:43:21 <jgt> monochrom: that's also a fair point. I had not considered that a human might interpret "1.2" as "possibly "1.19"
13:43:40 <jgt> that seems really rather weird to me
13:44:25 * ski . o O ( "interval arithmetic" )
13:44:27 <monochrom> Oh I agree about random innumerate people on the street who haven't thought it through.  But I'm trained in science.
13:44:42 <jle`> i mean, it's a common occurance to report something like $2,498,534 as "two and a half mi9llion dollars"
13:45:09 <jgt> in this case, what I'm really trying to avoid is rendering "rate: 0.323076923076923%"
13:45:30 <jgt> which is actually what appeared on the page — not a random number I button-mashed
13:45:30 <jle`> well, in that case i'd always want to be reported 1.20 instead of 1.2
13:45:41 <jle`> because 1.2 means it could be 1.21, but it's rounded away
13:45:47 <jle`> but 1.20 means it's actually 1.20
13:45:59 <electricityZZZZ> i am finally getting around to building a simple haskell web server. yesod is too full featured, i am looking for something fast and simple. i am trying to work with snap but it's hard to get it working with stack. what now?
13:46:02 <monochrom> I would even add "±0.005" or something.
13:46:16 <monochrom> If you're rounding, tell people you're rounding.
13:46:18 <merijn> electricityZZZZ: Servant seems to be popular, but I haven't used it
13:46:26 <jle`> i'm not sure if that part is necessary.  but if someone measured something as "1.20" and wrote down "1.2" i'd get pretty frustrated
13:46:26 <jgt> jle`: I wonder if a user would feel better seeing "5.00000%" instead of "5%"
13:46:46 <geekosaur> that said, depends on who you're presenting to and why. the flip side of my comment about insurance salesmen is other situations, it might be easier to read without it because it's unnecessary extra load 
13:46:53 <geekosaur> cognitive load // extra information
13:46:56 <dmj`> electricityZZZZ: use servant, it's easier
13:46:58 <monochrom> See at this point I don't understand because I see a self-contradition.
13:47:08 <jle`> jgt: i think it's also the fact that it's alongside *other* %0.2fs
13:47:13 <jgt> monochrom: I agree with "if you're rounding, tell people you're rounding". I had not thought of this, and this is really good advice. Thanks.
13:47:35 <jle`> if you have a bunch of %0.5f's, where a bunch of things are all 5.82341
13:47:38 <jgt> electricityZZZZ: just use Yesod? It's fast and simple.
13:47:38 <geekosaur> monochrom, I don't. this does matter. too much information is as bad as too little
13:47:47 <jle`> and all of a sudden you see, exactly, 5.00000
13:47:49 <geekosaur> yesod? simple?
13:47:56 <jle`> you know that something significant probably just happened
13:48:08 <jgt> I think Yesod is the best documented of all the frameworks out there
13:48:14 <jgt> and yeah, it's pretty simple
13:48:26 <merijn> Yesod is a big giant pile of auto-generated voodoo
13:48:27 <monochrom> First you say this number is on a contract so you're comitted to it.  If you write "0.32%" then you mean 0.32% no more no less, you don't even secretly have 0.320001% in mind.  OK, sure, on a contract there is no difference between "0.32%" and "0.3200000000%".
13:48:31 <electricityZZZZ> ...the stack template is broken?
13:48:33 <merijn> It's the utter opposite of simple >.>
13:48:39 <jle`> in the context if most of your things have an inherent precision (like money, integer percentages, etc.) then you only need to go as far as the inherent precision
13:48:51 <geekosaur> that I won't argue. but lots of complex moving parts, for all that they may provide templates for simple uses
13:49:03 <monochrom> Then you say "but ah it's really 0.323076923076923% but I want to print only '0.32%'.  ON THE CONTRACT".  OK, are you lying?
13:49:09 <electricityZZZZ> https://paste.rs/ftQ
13:49:13 * merijn mumbles something about Fixed
13:49:23 <jle`> but if i have an actual experimentally measured number 5.000000 (that doesn't have any inherent precision), i'm going to appreciate it
13:49:35 <electricityZZZZ> i am looking for the haskell equivalent of flask
13:49:38 <jle`> this reminds me of that story of when people originally measured the height of mount everest
13:49:51 <merijn> jle`: And the guy added 2 feet? ;)
13:49:56 <geekosaur> monochrom, if the context wants no more than that, then yes. as with bankers rounding which compensates for fixed precision
13:50:01 <jgt> monochrom: the underlying contract is the point of truth; the web UI is to ease day-to-day workflow
13:50:02 <jle`> yeah, they measured 29,000. ft
13:50:08 <merijn> jle`: I see I am not the only one who watches QI ;)
13:50:17 <geekosaur> because fixed precision is required under a number of situations with legal ramifications
13:50:29 <jgt> ah yeah, "who was the first person to put two feet on Everest"?
13:50:39 <jle`> heh, i didn't get it from QI :O but i'm sure i'd appreciate it
13:50:40 <merijn> jgt: Have you considered using Fixed instead of Double/Float?
13:50:48 <jgt> merijn: I have not
13:51:02 <merijn> jgt: That provides fixed precision decimals
13:51:06 <jle`> if someone told me that something is 2.9k ft, it means something different than saying something is 2.900k ft, and i'd appreciate if they told me the extra two zeroes
13:51:17 <merijn> > 0.28782 :: Centi
13:51:20 <lambdabot>  0.28
13:51:27 <merijn> > 0.28782 :: Milli
13:51:29 <lambdabot>  0.287
13:51:41 <jle`> but if someone told me that they had $1.53, i wouldn't appreciate it if they told me they had $1.530000000000000
13:51:45 <tabaqui> % :i Centi
13:51:47 <yahb> tabaqui: type Centi = Fixed E2 -- Defined in `Data.Fixed'
13:51:49 <merijn> jgt: You can even define your own precision if the one you care about isn't there
13:52:08 <jle`> no siree
13:52:32 <merijn> tabaqui: Fixed has a phantom param to control the precision and some simple type aliases for common precisions (like most of the SI ones)
13:52:40 <jle`> if i read siree in isolation it looks like a word describing a person being sired
13:52:53 <jle`> (or is it the sirer)
13:53:13 <jgt> jle`: I think it's the former
13:53:14 <monochrom> Clearly, siree = sir. :)
13:53:15 <tabaqui> merijn: just wanted to know which package it belongs
13:53:27 <merijn> tabaqui: Base :)
13:53:41 <merijn> tabaqui: There's a surprising amount of useful stuff in base no one ever thinks about
13:53:52 <jgt> > 5.00000 :: Centi
13:53:56 <lambdabot>  5.00
13:54:01 <jgt> > 5.00000 :: Milli
13:54:04 <lambdabot>  5.000
13:54:05 <merijn> I wholly recommend taking a couple of moments and just randomly browsing through base's module hierarchy
13:54:08 <tabaqui> yeah, I discover new feature every month
13:54:14 <jle`> thank you based base
13:54:18 <tabaqui> for three years :)
13:54:29 <tabaqui> but not thank you for the Prelude
13:54:35 <jgt> I don't think I want "5.00%" or "5.000%". I think I just want "5%".
13:55:12 <merijn> > showFixed (5.287 :: Centi)
13:55:14 <lambdabot>  error:
13:55:14 <lambdabot>      • Couldn't match type ‘Data.Fixed.Fixed E2’ with ‘Bool’
13:55:14 <lambdabot>        Expected type: Bool
13:55:21 <tabaqui> :i showFFloat
13:55:22 <merijn> eh, lemme try again
13:55:31 <merijn> > showFixed False (5.00 :: Centi)
13:55:34 <lambdabot>  "5.00"
13:55:39 <merijn> > showFixed True (5.00 :: Centi)
13:55:42 <lambdabot>  "5"
13:55:46 <merijn> base handles every thing!
13:55:50 <tabaqui> showFFloat (Just 3) 123.34567 ""
13:55:51 <merijn> > showFixed True (5.10 :: Centi)
13:55:54 <lambdabot>  "5.1"
13:55:55 <tabaqui> % showFFloat (Just 3) 123.34567 ""
13:55:55 <yahb> tabaqui: "123.346"
13:56:18 <jgt> merijn: that looks more like what I want
13:56:20 <merijn> jgt: Docs for Fixed say showFixed chops of trailing zeroes :)
13:57:07 <merijn> Anyway, the cat has reached critical "give me food or I'll annoy you"-levels, so I'm off :p
13:57:19 <monochrom> Does safe-money use Data.Fixed already?
13:57:42 <jgt> merijn: ok, so this looks like what I wanted all along. Thanks for this.
13:58:21 <tabaqui> btw, avoid Text.Printf as long as possible
13:58:23 <jgt> > showFixed True (1000000.123123123123123123 :: Micro)
13:58:27 <lambdabot>  "1000000.123123"
13:58:36 <tabaqui> it can solve the problem, but is is not safe
13:58:44 <jgt> > showFixed True (8.33333333333333e-2 :: Micro)
13:58:48 <lambdabot>  "0.083333"
13:59:08 <tabaqui> % printf "%.4f" (1 :: Float)
13:59:08 <yahb> tabaqui: 1.0000
13:59:10 <tabaqui> but
13:59:12 <jgt> … umm
13:59:13 <tabaqui> % printf "%.4f" 1
13:59:13 <yahb> tabaqui: *** Exception: printf: bad formatting char 'f'
14:03:30 <geekosaur> tabaqui, you do know the usual default is Integer? for which "f" is an invalid conversion
14:03:50 <tabaqui> sure
14:03:53 <geekosaur> it'd only pick Double if necessary, but nothing in the type of printf tells it it's necessary
14:04:05 <geekosaur> and ghc is not going to look for the "f" conversion and infer a Double
14:04:19 <geekosaur> this is why printf in Haskell is especially bad
14:04:31 <tabaqui> but I didn't know that Integer is invalid for "%f" for the first time
14:04:36 <jgt> how do I get from a Double to a Fixed?
14:04:55 <jgt> like this? http://hackage.haskell.org/package/fixed-0.3/docs/src/Numeric.Fixed.html#toFixed
14:05:09 <geekosaur> I'd have to wonder what you think would happen in C
14:05:27 <tabaqui> UB
14:05:34 <geekosaur> (well, with modern C compilers and warnings enabled, it'll tell you you're doing something wrong)
14:05:36 <[exa]> sadly, this one is defined
14:06:22 <tabaqui> geekosaur: probably not, gcc/clang/vsc allow you to pass char into a function that wants int
14:06:43 <[exa]> (printf format string is perfectly specified byte-crunching, and floats follow the floaty standard)
14:06:45 <geekosaur> er, C allows that, it's called promotion
14:06:46 <tabaqui> and the warning is not included in Wall
14:07:00 <geekosaur> and it's a defined part of the language
14:07:02 <tabaqui> but that totally, undoubly sucks
14:07:10 <tabaqui> *undoubtly
14:19:36 <zeta_0> does ihaskell only work with certain versions of ghc?
14:22:07 <zeta_0> has anyone here tried `ihaskell`
14:22:27 <Cale> vaibhavsagar: ^^ :D
14:22:35 <jle`> jgt: you should be able to just use realToFrac
14:23:30 <jgt> jle`: yeah that works
14:23:54 <jgt> ended up with:
14:23:56 <jgt> showPercent :: Micro -> Text
14:23:58 <jgt> showPercent = pack . showFixed True
14:24:22 <jgt> which is much nicer than my manual string manipulation
14:27:51 <jackdk> zeta_0: https://vaibhavsagar.com/blog/2017/08/13/i-haskell-a-git/ appears to have
14:32:18 <zeta_0> well i am struggling to install ihaskell in nixos with nix(home.nix), and i am running ghc865?
14:36:15 <bsima> when i do `haddock --hoogle`, where does the output .hoo file go? i can't find it
14:36:38 <hpc> it joins the other .hoos down in .hoo ville
14:37:02 <bsima> -_-
14:37:23 <hpc> "find | grep '.foo$'" might locate it
14:38:18 <jle`> that's...one way to use find
14:38:47 <bsima> i tried a few find invocations without much luck
14:38:59 <hpc> i never get bsd-style flags right
14:39:24 <bsima> i would think haddock would place it in the same place as --odir but i don't see it
14:41:15 <jumper149> Hi, I wonder whether my style is overly expressive or not. Are classes without methods unnecessary or do they help the reader by naming things?
14:41:34 <jumper149> You can have a look at an example here: https://github.com/jumper149/go/blob/master/src/Board.hs
14:42:37 <bsima> i don't think it outputs it anywhere, if i do just --hoogle (no --html) then there's nothing in my output dir...
14:43:49 <jle`> jumper149: hm, i think it's somewhat unusual. why not just use a Coord type?
14:44:00 <jle`> and a Player type
14:44:11 <Cale> Yeah, this seems way more abstracted than is probably reasonable
14:44:24 <Cale> How many instances of these classes are there in the world?
14:44:31 <jle`> unless you want Coord/Player to be determined by each instance of Board
14:44:37 <jle`> in which case you can use an associated type *maybe*
14:44:47 <jumper149> I am using exactly that for a default board, but want to be able to implement other boards or maybe more players later on
14:45:05 <Cale> and even if you want these things to be quite general, remember that there's also the option of making a record type with a bunch of function fields
14:45:15 <jle`> in that case it might be clearer to use associated types instead of fundeps+empty type classes
14:45:28 <jle`> but still it'd probably be better to write towards the monomorphic case first
14:45:32 <jle`> and then generalize later
14:45:40 <jle`> from a developmental process standpoint
14:46:00 <jumper149> jle`: that's exactly what i was doing :p
14:46:18 <jumper149> ill check out associated types tho ty :)
14:49:45 <jackdk> zeta_0: sorry, I am not viabhav and don't have time for a debugging session before work :S
15:01:36 <zeta_0> vaibhavsagar: hello there are you one of the developers of `ihaskell` because i need some help?
15:02:56 <vaibhavsagar> zeta_0: we have an issue tracker :)
15:03:49 <vaibhavsagar> zeta_0: you might find my notebooks repo useful https://github.com/vaibhavsagar/notebooks/
15:07:05 <zeta_0> vaibhavsagar: i am currently running nixos stable(19.03) i think maybe ihaskell is broken because i am running the wrong ghc version(ghc 865), so i need to switch back to ghc 864, is this correct: https://github.com/gibiansky/IHaskell/blob/master/release-8.6.nix
15:08:52 <boj> zeta_0: maybe try a different compiler - nix-shell -p haskell.compiler.ghc844
15:09:50 <Cale> I was able to nix-build that release-8.6.nix
15:10:07 <Cale> I'll try setting it to use 8.6.5 and see if it makes a difference
15:10:32 <vaibhavsagar> zeta_0: ihaskell works fine, just use my notebooks repo
15:11:47 <vaibhavsagar> the concept of 'installing' it is out of date anyway, especially on NixOS
15:12:59 <vaibhavsagar> There are also instructions in the README.
15:14:23 <zeta_0> vaibhavsagar: well i want it locally installed on my machine, did you mean to run it in the browser instead because i don't want to do that?
15:16:05 <jollygood2> I want to create Money datatype. I want to be able to do calculations with different currencies. How do I handle this, given that 1) I need IO to get todays' currency rate 2) relevant operators (of Num, Eq and Ord class) can't accept additional argument (currency rate)
15:16:32 <zeta_0> Cale: so were you able to get it to work?
15:17:06 <vaibhavsagar> zeta_0: no, that's not what I meant
15:17:08 <vaibhavsagar> You can have it locally available without 'installing' it
15:18:12 <vaibhavsagar> zeta_0: did you follow the instructions on the README on GitHub?
15:21:59 <zeta_0> vaibhavsagar: so i just read the nix section of the readme, so i am guessing i am going to have to switch back to ghc844 for ihaskell to work, here is what my home.nix looks like: https://gist.github.com/zeta-00/a14987b1109c47b18efc15d69257f404
15:23:21 <vaibhavsagar> It works great, I used it today
15:23:56 <vaibhavsagar> zeta_0: it works with GHC 8.6
15:24:31 <zeta_0> vaibhavsagar: does it have to be ghc864 instead of ghc865?
15:26:03 <vaibhavsagar> No, it will work with GHC 8.6.5
15:26:04 <vaibhavsagar> I think you're going about this in a way that is unnecessarily difficult
15:26:31 <jackdk> jollygood2: see if the safe-money package is useful to you. Generally, I'd use functions that take and apply some currency rate, and in some other part of the program do the IO to get and pass in a currency rate
15:26:44 <vaibhavsagar> IHaskell is a Jupyter kernel, so it needs a properly configured Python environment
15:27:36 <jollygood2> jackdk, I'll take a look. I wanted to use +, <, etc operators though, and was wondering how one could do that
15:27:40 <vaibhavsagar> And the ihaskell package on 19.03 might be out of date, which is why the README recommends using the latest `master`
15:27:45 <zeta_0> vaibhavsagar: well, i always do everything in home.nix, and oh i thought ihaskell already comes with the jupyter kernel, so it has outside dependencies?
15:29:24 <jollygood2> how about having two types, data Money, data MoneyNum, and toMoneyNum :: CurrencyRate -> Money -> MoneyNum?
15:29:29 <vaibhavsagar> Yes, it does
15:29:57 <srid> heya people; i'm looking to improve my writing skills re: docs and guides. so i decided to document a project of mine (static site generator). is this a good enough 'getting started' guide? are there ways to improve it? https://rib.srid.ca/getting-started
15:31:38 <jackdk> jollygood2: there are Num instances in safe-money
15:31:39 <jollygood2> only MoneyNum would implemenet Num, Ord, Eq instance, and you'd need currencyRate to create MoneyNum
15:31:54 <jollygood2> did they do something similar?
15:32:24 <jackdk> it's in the haddocks, sorry I gotta go to work. I don't know the guts of this library too well, but I found the blog post that introduces the lib: https://ren.zone/articles/safe-money
15:32:38 <zeta_0> vaibhavsagar: also, i wanted to install ihaskell with all of ihaskell's packages included, in the nix store it looks like if install it in the body of haskell.packages, i will have to install all of the packages seperately, but if i leave like i currently have it, oustside the body of ihaskell.packages ihaskell will come with all of the packages included, is this correct
15:33:47 <jackdk> srid: http://esr.ibiblio.org/?p=8175 is good general advice imho
15:34:17 <srid> jackdk: thanks; wasn't aware of that post.
15:34:44 <vaibhavsagar> No, that's not correct
15:35:35 <srid> i do want to make sure that i create decent docs _before_ i announce it on places like reddit as i surely think esr is right when he says "people will pre-judge the quality of your software by how clearly you can write about it"
15:39:09 <zeta_0> vaibhavsagar: so `haskellPackages.ihaskell`(says: A Haskell backend kernel for the IPython project) and `ihaskell`(by itself says: ihaskell-with-packages) so i thought they were different, could you clarify this for me, thanks
15:43:56 <zeta_0> vaibhavsagar: so to install ihaskell with all of it's packages included, will both of these pastebins work? https://gist.github.com/zeta-00/167728d7212add48402664caa7eb26e4 https://gist.github.com/zeta-00/d07b035968f390215789b3a55a1aaaef
15:44:50 <vaibhavsagar> That means you can configure other haskell packages to be available to IHaskell
15:45:50 <vaibhavsagar> <zeta_0 "vaibhavsagar: so to install ihas"> No, that won't work
15:48:19 <zeta_0> vaibhavsagar: so what is the difference between those two gists that i paste bined?
15:49:23 <zeta_0> vaibhavsagar: sorry for asking so many questions, i am just very confused and haven't been able to get this configured correctly and getting it to work
15:52:28 <jollygood2> I don't have time to figure out safe-money, I was more interested in design aspect of creating money datatype
15:52:42 <jollygood2> (at this moment, I'll look at it at some other time)
15:54:31 <vaibhavsagar> zeta_0: you haven't read the instructions and it seems like you are asking me to come up with a specific nix expression for your niche installation method
15:54:32 <vaibhavsagar> This is outside the bounds of the support I am willing to provide
15:54:32 <vaibhavsagar> Especially at the end of my workday
15:54:42 <zeta_0> vaibhavsagar: ok, so if i understand you correctly i need to install ihaskell within the body of haskell.packages in order for other haskell packages to be available for ihaskell, is that correct?
15:55:43 <vaibhavsagar> No
15:55:43 <zeta_0> vaibhavsagar: ok, i things that i can try, i'll let you know if it works or not
15:56:50 <zeta_0> vaibhavsagar: the instructions are for imperative installation(nix-env) not for declarative installation(home.nix), i think that's where my confusion is at
15:58:50 <zeta_0> vaibhavsagar: i think one of the other guys told me you were not at your computer(you are on phone), if you are busy now, i could come back later to ask for help?
15:59:09 <Cale> zeta_0: That was just earlier when he didn't reply immediately
15:59:16 <vaibhavsagar> zeta_0: where does it say `nix-env`
16:00:51 <zeta_0> vaibhavsagar: you said it is the end of your work day, do you want me to ask these questions tomorrow instead, i don't want to bother you?
16:01:25 <vaibhavsagar> zeta_0: that ship has sailed :)
16:03:32 <zeta_0> vaibhavsagar: oh, well is it ok if i ask you for help tomorrow?
16:06:04 <Cale> zeta_0: Did you try the repo that Vaibhav suggested originally? If you take a look at the default.nix in some of those examples, it gives a decent idea for how to use it.
16:06:41 <Cale> You can specify the compiler you want, and the packages
16:07:24 <Cale> https://github.com/vaibhavsagar/notebooks/blob/master/refactoring-tarjan/default.nix
16:07:45 <vaibhavsagar> thank you Cale
16:09:41 <vaibhavsagar> okay, I'm back on a computer now
16:10:45 <zeta_0> if you guys are busy right now or have to go, i could get back on irc later on?
16:13:25 <zeta_0> i am currently learning haskell right now, i think i am going to have to set aside some time to learn the nix language because i still don't understand it very well outside of doing very simple things
16:13:52 <vaibhavsagar> zeta_0: why are you using home.nix then?
16:14:32 <vaibhavsagar> clone my notebooks repo, cd to the `deriving-via` directory, and run `$(nix-build)/bin/ihaskell-notebook`
16:15:48 <zeta_0> vaibhavsagar: ok i'll try that out, and so for i really like home.nix
16:16:40 <srid> jackdk: made it a bit more narrative-like :) https://rib.srid.ca/getting-started
16:16:56 <srid> i think i understand why a narrative-based guide helps
16:17:07 <vaibhavsagar> home.nix might be the best thing in the entire universe, but I don't support it
16:17:08 <vaibhavsagar> and my lack of support does not mean that IHaskell is broken
16:17:33 <srid> what's home.nix? home-manager?
16:18:16 <zeta_0> srid: yes
16:23:06 <infinisil> vaibhavsagar: Do you have some reason for not supporting it?
16:23:55 <jackdk> srid: I had to back up to your intro page to get a handle on what rib was, but it seems to have a good flow. There are some grammar errors but I do not have time to do a detailed proofread. The general message does come through well. Consider saying what the nix-shell --run command does at a high level ("you get a hot-reload workflow: a local HTTP server which serves that generated files and that which automatically reloads
16:23:55 <jackdk> when either the content (a/) or the HTML/CSS/build-actions (Main.hs) changes.") first, then dive into the machinery of how it works?
16:24:57 <srid> ah yea, good suggestion
16:25:20 <vaibhavsagar> infinisil: it works just fine with `nix-build`, I don't think I need to additionally explicitly support `home-manager`
16:25:38 <vaibhavsagar> I already support Stack, Cabal, Nix, and Docker
16:25:51 <vaibhavsagar> don't ask me for more without a very very good reason
16:26:27 <infinisil> Ah, I understood it as "I don't support home-manager [in general because it's a bad idea]"
16:26:58 <vaibhavsagar> I don't have a problem with home-manager, AFAICT it seems pretty great
16:27:22 <infinisil> Yeah no reason to have something home-manager specific for your project. People who use home-manager should be able to adapt the normal nix installation method
16:27:22 <jackdk> srid: generally when I lay out ideas (in text or code), I try to do so from high-level down (if the objective is clear, so people can drill down to the depth they need) or from primitives up (less often)
16:27:39 <vaibhavsagar> infinisil: that's what I thought too :)
16:28:58 <zeta_0> well nixos is definitely not beginner friendly
16:32:16 <zeta_0> well thanks guys, i'm done for the day, i'll be back later, i'll let you guys know if i still can't get ihaskell working
16:32:18 <vaibhavsagar> that's not an issue with IHaskell
16:36:25 <zeta_0> vaibhavsagar: before i go, i forgot to ask: does ihaskell work within emacs?
16:37:51 <vaibhavsagar> zeta_0: there's https://github.com/millejoh/emacs-ipython-notebook, but I've never used it
16:39:22 <zeta_0> vaibhavsagar: oh cool, i'll try that out later as well, thanks
18:00:58 * hackage magic-tyfams 0.1.0.2 - Write plugins for magic type families with ease  https://hackage.haskell.org/package/magic-tyfams-0.1.0.2 (isovector)
18:01:57 * hackage cmptype 0.1.0.1 - Compare types of any kinds  https://hackage.haskell.org/package/cmptype-0.1.0.1 (isovector)
18:14:01 <nshepperd> ooh, magic type families, huh
18:14:04 <nshepperd> looks cool
18:21:13 <nshepperd> bleh, i left signing up for icfp too late
18:22:12 <nshepperd> everything's gotten expensive
18:22:25 <nshepperd> would be nice if I could watch the haskell talks from here
18:56:53 <vaibhavsagar> extremely same
20:46:40 <fog> has anyone read this? https://www.cs.purdue.edu/homes/rompf/papers/wang-icfp19.pdf
20:47:13 <fog> "reverse-mode AD as a specific form of symbolic differentiation of CPS-transformed programs"
20:47:18 <fog> ?
20:47:44 <jackdk> yes
20:47:53 <jackdk> (I haven't read it, but that's the answer to the question you asked)
20:48:25 <fog> whats it doing with shift/reset?
20:48:34 <jackdk> I don't know, I haven't read it
20:48:50 <fog> wiat, what were you answering?
20:49:13 <jackdk> 'has anyone read "reverse-mode AD as a specific form of symbolic differentiation of CPS-transformed programs"?'
20:49:27 <fog> what!?
20:49:34 <jackdk> if it was accepted into ICFP then someone has read it
20:49:42 <fog> you mean to say that *someone has read them*
20:49:47 <fog> !?!?!
20:50:03 <fog> sillyness of the most severe kind
20:50:23 <fog> i was looking for a simple explanation of the idea
20:51:00 <fog> as my own; "backpropegation is like sending messages back through the program which is kind of like a "credit card" transform" 
20:51:10 <fog> seems like it could be an oversimplification
20:51:26 <fog> and i can hardly see how that constitutes differentiation of any kind
20:51:40 <jackdk> then ask that instead of seeing if anyone has read the pdf first. in the process of formulating your question, you may answer it, and even if not you will probably pose a better question that might catch the eye of someone who knows the field but not necessarily that PDF in particular
20:52:23 <MarcelineVQ> that's a really interesting paper synopsis
20:54:08 <monochrom> I'm sorry but I can't just see "has anyone read?" and infer "oh you mean you want someone here to explain", much less "simple".
20:54:13 <MarcelineVQ> seeing increased useage of modal logic (e.g. stating) in papers lately
20:54:21 <MarcelineVQ> *staging
20:54:54 <monochrom> Because the alternative inference is "is it good? do you recommend it?"
20:55:41 <fog> monochrom, but at least you could expect the answer "yeah" to correspond more likely to "yeah, i have" than "yeah someone has" which is a pedantic and facetious tautology 
20:56:07 <monochrom> Facetious question gets facetious answer.  That's the tautology.
20:56:09 <MarcelineVQ> the latter yeah is a hint to ask a more specific question, rather than being snide or pedantic
20:56:18 <fog> its more of an invitation for constructive comment than an invitation to bea teased
20:56:47 <monochrom> Between someone who asks poorly and someone else who interprets superficially, I'll always side with the latter.  I'm fed up with asker entitlement attitude.
20:56:53 <fog> i just want to talk about the paper
20:57:08 <fog> if all you want to do is chastise me then could you just not
20:57:35 <monochrom> No, all I want is to tell people "don't answer to answer, just don't answer".
20:57:49 <monochrom> (Yes I'm also done with "don't ask to ask, just ask".)
20:58:31 <monochrom> Don't waste time with poorly formulated questions.  Trust natural selection.
20:58:35 <fog> i thought automatic differentiation was like, in a high dimensional space, using successive "samples" to approximate a gradient where quadrature or finite difference approximations were rpohibitivly costly 
21:00:08 <fog> which makes sense in the traditional setting of gradient descent, where backpropegation is normally used and where we get most of our intuition 
21:01:54 <fog> i think that we look to this literature to understand what is meant by a "differential program" 
21:02:11 <fog> differentiable*
21:02:43 <fog> but i dont see how continuations manage that
21:03:07 <fog> monochrom: thats as best as i can phrase the question
21:11:15 <fog> they link this but its in scala; https://github.com/feiwang3311/Lantern
21:13:15 <fog> their example is of symbolic differentiation...
21:13:42 <fog> ie, it differentiates a polynomial in x
21:14:04 <fog> but the concept that is difficult to understand is how to differentiate a program
21:14:33 <fog> finding gradients of vector fields and differentiating polynomials is easy already
21:19:19 <fog> i think the reason this seems lacking is because it resorts to the use of continuous variables 
21:19:39 <fog> ie a polynomial in (x :: Double) 
21:20:14 <fog> whereas when we struggle to comprehend the differentiation of a computer program it is because of the lack of infinitesimals 
21:21:12 <fog> the only way i can understand how to get round this is to use fuzzy logic or probabilistic programming
21:22:17 <fog> where partial membership or continuous probability distributions (measure 1 with measure 0 tangents) support small changes
21:23:41 <fog> i tried to read Conel's version using categorties and that at "therisingsea" using pretty intense programing language math, but still have no conceptual idea of how this works at all...
21:28:33 <c_wraith> fog: automatic differentiation is based on infinitesimals, actually.
21:29:14 <c_wraith> fog: it uses the chain rule and the fact that an infinitesimal squared is zero.
21:29:37 <fog> how does that work with programs?
21:29:47 <c_wraith> https://en.wikipedia.org/wiki/Automatic_differentiation#Automatic_differentiation_using_dual_numbers
21:31:12 <fog> we dont have infinitesimal programs though
21:32:33 <c_wraith> that doesn't change the math.
21:32:45 <fog> that was my point to begin with, i dont understand how this isnt just more reference about conventional differentiation 
21:32:58 <fog> what do you mean "doesnt change the math" ?
21:33:35 <fog> how can these papers to be claiming to differentiate things which have no notion of continuousness 
21:33:51 <c_wraith> The math of using infinitesimals doesn't actually *use* infinitesimals.  It's all just ordinary arithmetic operations on ordinary values.
21:34:17 <c_wraith> That math all still works on more complex values
21:34:42 <fog> i know what math is! i think its a strange comment to just explain what is algebraic opperations 
21:35:28 <fog> "you can add complex numbers just like real numbers".... yeah they are an algebra. ok. thats basically beside the point
21:36:18 <c_wraith> Well no.  That's the whole point.  It's just a different model.
21:36:32 <fog> if you cant explain how your comment isnt irrelavent ill just have to assume it is
21:36:52 <fog> im pretty sure it is
21:37:48 <c_wraith> You're working really hard to overcomplicate things.
21:39:02 <fog> and your trying to simplify them i suppose, but i cant understand how you dont manage
21:39:24 <c_wraith> step 1. implement dual numbers.  that's it.  there aren't more steps!
21:40:02 <fog> linking an explanation of automatic differentiation using infinitesimals does not explain how it can be done on the discrete space of programs  
21:40:27 <fog> whats a dual number? something that returns a number?
21:40:43 <c_wraith> I gave you the link to dual numbers
21:41:01 <fog> is my understanding of them not correct?
21:41:41 <c_wraith> they don't return anything.  the *are* something.
21:42:01 <fog> dual -> "functional" -> covector -> partially applied inner product
21:42:39 <fog> yeah they *are something which returns a number*...
21:43:21 <c_wraith> returning is a very imperative idea.  they are just values.
21:43:45 <fog> so unless this is some kind of stange variation on the standard notion of what is meant by dual (they link "dual space, which gives a page on functionals")
21:44:03 <fog> yeah, functions are values
21:44:11 <fog> but they also have return types
21:45:09 <fog> anyway, by any idea of "dual" i cant see how it would render something continuous from something discrete
21:45:19 <c_wraith> it turns out the math just works
21:45:29 <fog> that is NOT an explanation
21:45:59 <fog> if anything its just gives the indication of bs
21:46:04 <c_wraith> perhaps continuity is a lot less important for calculus than you've been led to believe.
21:46:34 <fog> perhaps thats what im being led to believe... but without explanation, you could give better direction!
21:47:05 <monochrom> Or you could show less entitlement attitude.
21:47:12 <c_wraith> My friend who's done a ton of research into non-standard numbers could explain this better than me, but it more or less is the transfer principle
21:47:25 <fog> monochrom: quit cramping my style
21:47:35 <monochrom> OK that's it.
21:47:38 --- mode: ChanServ set +o monochrom
21:47:42 --- mode: monochrom set +b *!*@185.204.212.77
21:47:42 --- kick: fog was kicked by monochrom (fog)
21:47:59 --- mode: monochrom set -o monochrom
21:49:06 <c_wraith> I was about to tell him that I've got a friend who quit a PhD program working on non-standard analysis, but if he wants to pick up the research, the transfer principle there is why it works.
22:03:27 * hackage th-data-compat 0.1.0.0 - Compatibility for data definition template of TH  https://hackage.haskell.org/package/th-data-compat-0.1.0.0 (KeiHibino)
22:33:08 <yummycouple> minepi.com/thatbadmonster
22:44:05 <plakband> Does anybody know of a random generating monad similar to QuickCheck's Gen, but that has a more sophisticated size parameter? In particular, I'm looking for some kind of balancing, such that e.g. `arbitrary :: ([()],[()])` has about the same size as `arbitrary :: [()]` or even `[[()]]`.
22:44:38 <jle`> are you looking for a monad or a function?
22:44:49 <jle`> er, a specific generator itself
22:45:06 <jle`> or maybe a typeclass
22:45:34 <jle`> maybe you're looking for a way to generate a ([()],[()]) of some specific size
22:46:03 <jle`> or maybe you're looking for a way to generate many things of different types while enforcing that all things you ever generate have a consistent side
22:46:06 <jle`> *size
22:49:44 <plakband> jle`: I'm trying to write a DSL for generating random data that's very similar to Gen, but the property checking function is very expensive, so we need to take care to grow the expressions more carefully than QuickCheck does
22:50:06 <plakband> Also, there is no shrink
22:50:31 <jle`> are you trying to design something similar to Gen, or something similar to Arbitrary?
22:52:17 <plakband> Gen, there is a small number of given primitive generators, but they should compose (monadically)
22:52:25 <plakband> (ideally)
22:52:33 <jle`> the things you are describing are things that Arbitrary does
22:52:48 <jle`> and less related to Gen, i feel
22:54:08 <jle`> hm, ah, Gen also has facilities for controlling size
22:55:00 <jle`> that's interesting
22:55:33 <jle`> i feel like this is something that would make more sense to handle when defining your generators, and not the generator monad
22:55:45 <plakband> My problem with arbitrary is that the size parameter seems 1) somewhat ill defined 2) the "length" of e.g.[[()]] is the square (I think) of [()] for the same size
22:55:59 <plakband> Maybe
22:56:37 <jle`> yeah, Gen is basically ReaderT over a 'normal' random generator, it looks like
22:57:03 <plakband> which is great for simple property checking
22:57:18 <jle`> hm, you can use something like hedgehog's random generator system maybe
22:57:28 <jle`> where all the sizes are given explicitly at every step
22:57:49 <jle`> but the 'size' type is sophisticated enough to be scaled, shifted, etc.
22:58:31 <jle`> so say if you want to build a Size -> ([a],[a]), you could do something like (,) <$> mkList (
22:58:32 <plakband> Let me check, I've never used it but looking through the source yesterday it seemed like they did the same thing as QuickCheck
22:58:46 <jle`> er, \size -> (,) <$> mkList (size / 2) <*> mkList (size / 2)
22:59:24 <jle`> i think the size parameter in hedgehog is like a global scaling parameter, and not something that affects everything absolutely
22:59:47 <jle`> so if you handle your sizes carefully with the generation, the only thing the Gen's internal Size does is let you scale everything linearly
23:00:19 <jle`> but locally, within each complicated generator, you are free to do your own first-class manipulations of sizes
23:00:41 <jle`> so you can do some manual manipulation like what i put above
23:02:22 <jle`> you might be able to build an 'automatic' system over this. i wonder if there is a way to bake it into the monad, but i'm not sure
23:02:40 <plakband> that is very close to what I'm doing now
23:03:05 <plakband> I was looking for some inspirition on how to do that automatic step :)
23:03:20 <plakband> to make it automatically balance
23:07:27 <plakband> I have a suspicion that it might only work for Applicative, since I'm not sure how `join` would work
23:14:25 <ski> hm, i suppose instead of dividing up `size' in equal parts, one could partition it randomly (uniform distribution ?)
23:16:09 <ski> (however, perhaps one could "reach a dead end", in some cases ? which would then suggest state instead, hmm .. but that's not so nice)
23:26:01 <flebron> Hi folks. I have a type like https://pastebin.com/mYv1iUxR. Is there a sensible way in which I can make this a Category, so that baz = bar . foo?
23:28:07 <plakband> flebron: I don't think you have an identity
23:28:45 <flebron> Isn't X :: Foo a a an identity?
23:30:35 <plakband> Ah
23:31:12 <jackdk> what happens if you write instance Category Foo where ... , and use typed holes and follow-the-types ? do you get stuck somewhere in particular?
23:33:12 <c_wraith> it looks like it has the wrong variance, to me.
23:33:13 <int-e> monochrom: heh, 2 X-Y-problems + bad attitude = ban :)
23:45:45 <flebron> jackdk: (Y f p) . (Y g q) = _ :) I want a Foo a c, and not sure how to get it.
23:46:40 <flebron> (I also feel like if I knew that b was a, or b was c, I would implement this (.) different. But I'm not sure how to make my implementation depend on such type equalities.)
23:46:50 <Cale> flebron: Is there a difference in meaning between Z f and Y f when both typecheck?
23:46:57 <jackdk> so the left `Y` is constructing a `Foo a b` and the right `Y` is constructing a `Foo b c`?
23:47:16 <flebron> jackdk: The other way around, but yeah.
23:47:51 <Guest_40> Good evening. I'm trying to install the Haskell Platform on MacOS. Using ghcup installs everything in my home directory. Is there a simple way to install the platform globally?
23:48:00 * jackdk . o O ( it's been over 15 years since I was first shown function composition and i still get it wrong )
23:48:03 <flebron> Cale: Yes, I'd prefer to use Y when the types are identical.
23:49:02 <flebron> The background is that this is a series of compiler optimization passes. Some of these passes can change the internal structure (Z), some do not (Y). The user is free to skip some of the Y's, but they cannot skip the Z's, since the types change there.
23:49:08 <jackdk> I don't see any promising constructions. You could be silly and use X to drop stuff on the floor
23:50:22 <Cale> flebron: Given the type of X, it's hard for it to serve as an identity, because you want to be able to write something like
23:50:27 <jackdk> flebron: here's how I test for type equality in some other stuff I was working on. Maybe it helps:  https://www.irccloud.com/pastebin/6Ek3iTlV/type-equality.hs
23:50:29 <Cale> X . a = a; a . X = a
23:50:33 <Cale> as part of the definition of (.)
23:50:44 <Cale> but that's not necessarily going to typecheck
23:51:02 <flebron> (Think of internal representations AST and LLVMIR. You're free to skip a Y (f :: AST -> AST), but when I chain these passes together, I can't let you skip a Z (g :: AST -> LLVM), since I won't know how to do that transformation from AST to LLVM otherwise.
23:51:28 <Cale> Maybe it would help to have more details rather than this stripped-down naming scheme?
23:51:59 <flebron> It's literally compiler optimization passes :)
23:52:22 <Cale> What things are X, Y and Z?
23:52:24 <jackdk> alternatively, would splitting things into Endo AST, functions AST -> LLVM, and Endo LLVM help?
23:52:40 <flebron> X is Finished, Y is Pass, Z is PassTransform.
23:53:24 <flebron> jackdk: Yes, that's doable, though not too scalable when I get more than those 2 representations :)
23:53:34 <Cale> What are the type arguments?
23:53:58 <Cale> Like, if I write  Finished :: CompilerPass a b
23:54:00 <Cale> what does that mean?
23:54:00 <flebron> Some opaque datatypes. Can't name them exactly, but think of them as AST (for abstract syntax tree) and LLVM IR.
23:54:30 <flebron> Oh, that's clearly wrong. It shoul dbe Finished :: CompilerPass a a.
23:54:35 <Cale> okay, that helps
23:54:57 <flebron> Sorry, I'm not able to edit the pastebin :s (And hpaste.org seems to be... dead?)
23:55:17 <jackdk> data Phase a b = Phase (Endo a) a -> b would easily have an instance. you could use [Endo a] or [a -> a] or (a -> a) or whatever, to taste
23:55:25 <cocreature> Is there a fast Int -> Text function? GHC doesn’t seem to optimize away the String in "T.pack . show"
23:55:59 <Cale> flebron: Does  Pass f a . Pass g b = Pass (f . g) (a . b) make sense?
23:56:25 <cocreature> Ah, I think text-show might have something
23:56:29 <Cale> Or is that pulling things out of their correct order?
23:56:50 <Cale> (I can imagine this might have a meaning where a and g are being "swapped" in some sense)
23:58:11 <flebron> That should be fine, the semantics I'm after is.. "after". Meaning, I want p1 . p2 to be "Perform p1 after p2."
23:59:51 * flebron should be competent at type juggling at this point... siiiiigh.
23:59:52 <ski>   data StrangePath :: * -> * -> * where Id :: forall a. StrangePath a a; ComposeLiftEndo :: forall a b. (a -> a) -> StrangePath a b -> StrangePath a b; ComposeLift :: forall a b c. (a -> b) -> StrangePath b c -> StrangePath a c
