00:02:50 <s00pcan> oh, not network audio dante?
00:23:24 <dminuoso> alexelcu: Whatever floats your boat is fine.
00:23:35 <dminuoso> alexelcu: I use emacs with plain haskell mode and ghcid with compilation mode
00:31:55 <tsaka_> when compiling a simple binary on one machine and deploying on another, I get errors about libm/glibc version mismatch
00:32:02 <tsaka_> how to deal with that?
00:34:00 <tsaka_> the binary is made with `stack script --compile`
01:16:46 <Abednego> I am running ghc 8.6.5
01:17:25 <Abednego> For a bit of code that used to work I now get "Could not deduce (Control.Monad.Fail.MonadFail (M.Matcher s1))"
01:17:40 <Abednego> Maybe I should try with an earlier ghc
01:20:01 <merijn> Abednego: So, there's an ongoing transition to remove the "fail" function from Monad, because it's widely considered a mistake
01:20:36 <Abednego> merijn: is 8.4 going to work for me?
01:21:18 <merijn> Abednego: People usually don't use "fail" directly, but partail pattern matches in do notation (like "Just foo <- myAct; bar foo") desugar to "myAct >> \x -> case x of Just foo -> bar foo; Nothing -> fail "Failed pattern""
01:22:34 <merijn> Abednego: As a result of moving "fail" to a separate MonadFail class, GHC will now disallow partial patterns like that, unless your type is a MonadFail instance. So this error means you have a (potential) bug/partial pattern lurking in the code
01:23:00 <merijn> Abednego: Downgrading would work, but I'd recommend just fixing it (how depends on what Matcher does)
01:24:16 <Abednego> merijn: it may already be fixed upstream I suppose
01:24:20 * Abednego goes to look
01:24:37 <merijn> Abednego: But even with 8.6 MonadFail should still be opt-in
01:27:31 <Abednego> https://github.com/tweag/HaskellR/commit/84fe7a666dbfe2c4a8c48e103f48282404ba1ab2
01:27:53 <Abednego> So all I have to do is use the git repo rather than hackage
01:27:59 * Abednego sighs a bit
01:28:57 * hackage apecs-physics 0.4.1 - 2D physics for apecs  https://hackage.haskell.org/package/apecs-physics-0.4.1 (jonascarpay)
01:45:57 * hackage Persistence 2.0.1 - A versatile library for topological data analysis.  https://hackage.haskell.org/package/Persistence-2.0.1 (Ebanflo)
01:46:50 <cocreature> Is there a version of read that doesn’t silently truncate?
01:47:05 <merijn> truncate what?
01:48:03 <cocreature> sorry should have been more precise
01:48:15 <cocreature> % read "1.23" :: Deci
01:48:15 <yahb> cocreature: 1.2
01:48:40 <merijn> cocreature: That...seems right to me?
01:49:03 <cocreature> merijn: I would like an Either or an Exception for values that I cannot represent exactly
01:49:06 <merijn> I don't think that has to do with Read, but with fromRational
01:49:13 <merijn> > 1.23 :: Deci
01:49:16 <lambdabot>  1.2
01:50:13 <cocreature> well, I want a parse function that doesn’t behave like that :) whether it’s called "read" or not doesn’t matter :r
01:50:19 <cocreature> :)
01:50:49 <merijn> Not sure one exists
01:50:54 <__monty__> cocreature: Is this for floats? How about hexadecimal float literals?
01:51:11 <merijn> __monty__: Deci suggests it's not for floats
01:51:19 <cocreature> yeah, Data.Fixed
01:51:32 <merijn> __monty__: Or are you just excited to point out you finished implementing the Numeric stuff for those ;)
01:52:12 <__monty__> merijn: Not quite, code's ready but I've been blocked on coming up with good tests tbh.
01:52:19 <jusss> what is the monad transformer?
01:52:20 <merijn> Ah, bummer
01:52:46 <dminuoso> jusss: A monad transformer is a way to turn one monad into a another monad by imbuing it with effects of a precusor monad.
01:53:15 <dminuoso> So MaybeT takes an arbitrary monad, gives it some "exception semantics" - returning a new monad.
01:54:10 <jusss> is there a simple example?
01:54:10 <dminuoso> (That is, it sort of adds "Maybe" flavour to another monad)
01:54:17 <dminuoso> jusss: MaybeT IO
01:55:08 <iqubic> That lets you create IO functions that might succeed and return a Just (IO a), or might fail and return Nothing
01:55:31 <dminuoso> iqubic: Mind you, "IO functions" is very deceiving.
01:55:37 <dminuoso> iqubic: It's better to call them IO actions.
01:55:41 <iqubic> Right.
01:55:47 <dminuoso> iqubic: also you mixed up the order in that.
01:55:48 <iqubic> But the point still stands.
01:55:58 <dminuoso> MaybeT IO a ~ IO (Maybe a)
01:56:03 <iqubic> Yeah.
01:56:10 <dminuoso> iqubic: So your example was quite wrong. :)
01:56:15 <iqubic> That reversal there always trips me up.
01:56:42 <iqubic> I have never consistently gotten that right way around.
01:57:25 <dminuoso> jusss: So one motivating part might be this: You have a lot of IO code. And at some point you want to add the semantic of "any part of the code should be able to set an error, such that all further IO actions are skipped - an exception basically"
01:58:35 <iqubic> I prefer ExceprT, because it lets you tag failure with a value.
01:58:48 <iqubic> ExceptT () IO ~ MaybeT IO
01:58:57 <jusss> and 'bout EitherT?
01:59:16 <iqubic> EitherT is deprecated, use ExceptT instead
01:59:18 <dminuoso> jusss: EitherT is called ExceptT for historic reasons.
01:59:47 <dminuoso> jusss: "ExceptT e IO a" is basically just "Either e (IO a)" 
02:00:25 <dminuoso> jusss: Using my previous example, ExceptT would not just let you "set an error", but also set error details, such as "what went wrong"
02:00:51 <iqubic> Which is what I was getting at when I claimed you could tag errors with a value.
02:01:01 <dminuoso> MaybeT adds exceptions, ExceptT adds "named" exceptions, ListT adds non-determinism, StateT adds state etc
02:01:26 <iqubic> ContT adds 100% more confusion to everything.
02:01:48 <dminuoso> Cont is probably the one monad where it's hard to talk about "what exact effect does this have" :P\
02:02:08 <merijn> iqubic: >100% for sure
02:02:17 <iqubic> ContT is another ball game. It's a rabbit hole that goes way deep into the bowels of haskell.
02:02:58 <dminuoso> jusss: Are you familiar with how parsers can be constructed in Haskell using "newtype Parser a = Parser { runParser :: String -> [(String, a)] }" ?
02:03:41 <iqubic> What's the list contain?
02:03:55 <dminuoso> iqubic: What would you say is the effect that a list encodes?
02:05:18 <iqubic> I'd say it takes an input string and returns a list of tuples where the first element is the part of the input string that has not yet been parsed, and the second element is the value being parsed.
02:05:39 <iqubic> And it's a list because there are multiple ways to parse a given input.
02:05:45 <dminuoso> iqubic: In general a list, with its functor/applicative/monad instance, encodes non-determinism.
02:06:02 <iqubic> Right. Which is needed when parsing.
02:06:04 <dminuoso> iqubic: Indeed. This is what gives us backtracking.
02:06:24 <dminuoso> And ambiguous parses
02:07:16 <iqubic> If you have "1 + 2 * 3 + 4" You need to backtrack to parse that into a proper AST
02:07:32 <dminuoso> iqubic: That depends on what grammar you have.
02:07:40 <iqubic> I suppose.
02:08:08 <iqubic> Converting a given BNF grammar into a valid parser for said grammar is still tricky for me.
02:08:18 <jusss> dminuoso: no... I hate record syntax...
02:08:59 <iqubic> juss: That's an issue. Much of haskell is filled with newtype wrappers like this that use records
02:09:18 <dminuoso> jusss: The record syntax is indeed very terse, but you get used to it.
02:09:28 <vancha112[m]> hey all :) can anyone recommend a good recent haskell tutorial, that also explains the concept of functional programming in addition to the language?
02:09:30 <dminuoso> jusss: If you prefer, you can write data records using GADTSyntax if you like by the way.
02:09:58 <dminuoso> vancha112[m]: Any Haskell resource would do that automatically, since Haskell promotes functional programming very strongly.
02:10:11 <iqubic> I don't even know how to write that without the record syntax, for the record. Pun Intended
02:10:45 <merijn> iqubic: You don't have to backtrack for that, you can mimic GHC's hackery
02:11:03 <iqubic> "that" being the Parser Newtype definition given earlier
02:11:18 <dminuoso> jusss: I found that GADTSyntax is one of the finest extensions for beginners if data declarations are too confusing to you. :)
02:11:30 <vancha112[m]> > vancha112: Any Haskell resource would do that automatically, since Haskell promotes functional programming very strongly.
02:11:31 <vancha112[m]> Hmm sounds like there's no use to learn the general concept of functional programming then? In that case I'm looking for just a good recent haskell tutorial i guess ^ ^ 
02:11:34 <lambdabot>  <hint>:1:39: error:
02:11:34 <lambdabot>      Unexpected do block in function application:
02:11:34 <lambdabot>          do that automatically
02:11:50 <jusss> dminuoso: I just like ADT
02:11:55 <dminuoso> vancha112[m]: What kind of background do you have?
02:12:05 <dminuoso> jusss: That's fine. You can write plain ADTs with that.
02:12:19 <dminuoso> jusss: The purpose of GADTSyntax is not to enable extra features, it just lets you write it more visually and explicitly.
02:12:24 <iqubic> dminuoso: Does GADTsyntax differ from plain GADTs?
02:12:28 <vancha112[m]> > vancha112: What kind of background do you have?
02:12:29 <vancha112[m]> I'm a beginner, I wrote some python and i work as a wordpress developer. so basically i will have to learn it from scratch
02:12:31 <lambdabot>  <hint>:1:22: error: parse error on input ‘of’
02:12:41 <dminuoso> vancha112[m]: Do you have any background in other sciences?
02:12:48 <dminuoso> Maybe in math?
02:12:58 <vancha112[m]> no I have discalculia :(
02:13:14 <dminuoso> That's perfectly fine.
02:13:15 <vancha112[m]> I'm an aspiring software engineer though
02:13:25 <dminuoso> Just trying to get an idea what kind of material might be appropriate to you.
02:13:33 <vancha112[m]> alright :)
02:13:39 <dminuoso> vancha112[m]: Do you prefer something easy going, or something in the style of a uni course?
02:13:49 <vancha112[m]> easy going would be better ^ ^ 
02:14:06 <dminuoso> vancha112[m]: The Haskell book is probably a fine pick. It assumes no previous knowledge and is very easy going.
02:14:17 <vancha112[m]> theres so many languages we covered at school that felt like a math quiz, i learn it and don't really know whats actually going on :)
02:14:17 <dminuoso> vancha112[m]: http://haskellbook.com/
02:14:23 <iqubic> When I first learned Haskell, the only other computer programming language I knew was Java. My first few months of Haskell were quite hard.
02:14:46 <dminuoso> vancha112[m]: There's a large free sample you can try to get an idea whether it suits you.
02:15:02 <iqubic> OOP is much much different from FP.
02:15:11 <vancha112[m]> alright cool :) I'll add it as a bookmark ^ ^ 
02:15:21 <iqubic> After like 3 years of Haskell, I have come to prefer FP over OOP.
02:15:39 <dminuoso> iqubic: I reckon its closer to 1 1/2 years for you, no?
02:15:44 <vancha112[m]> i have "learned" java, C, amanda (haskell look-a-like for educational purposes),python,c++, but i remembered nothing.
02:15:55 <vancha112[m]> university is going too fast for me :P
02:16:14 <vancha112[m]> but then i took it up as a hobby
02:16:15 <vancha112[m]> and thigns start to make sense
02:16:45 <vancha112[m]> that book seems math heavy though :P
02:17:05 <iqubic> dminuoso: That sounds right. It feels like 3 years though
02:17:35 <dminuoso> iqubic: I just know because I remember you started a few months after I did. :)
02:17:40 <vancha112[m]> i really have no idea how much fp is used in "real life" :o
02:17:43 <dminuoso> And for me it's barely 2 years now.
02:17:53 <vancha112[m]> i was actually surprised the haskell community on matrix is as large as it is :P
02:17:53 <iqubic> I see. That sounds about right.
02:18:18 <iqubic> Actually, many of us are on IRC. But yeah, it's a big world here.
02:19:11 <vancha112[m]> many people seem to still be on irc :(
02:20:40 <jusss> I haven't learn Cont Monad yet, I think it's too hard for me now
02:20:58 <dminuoso> jusss: Dont worry about it, really.
02:21:05 <dminuoso> jusss: I take it you are a very fresh beginner?
02:21:07 <jusss> but I have learned Continuation in Scheme, which is take me a few days
02:21:30 <jusss> dminuoso: I'm a beginner
02:22:04 <dminuoso> jusss: Yeah dont worry too much about Cont. I've been into Haskell for about 2 years and never used it once outside of just experimentation.
02:22:19 <jusss> I saw some articles said Cont Monad is the mother of all Monads
02:22:37 <iqubic> I haven't even touched it in a safe and controlled testing environment.
02:23:15 <dminuoso> jusss: It is in a fun sense, indeed.
02:23:38 <dminuoso> jusss: Think of it as a mere philosophical statement, rather than a technically relevant one.
02:23:45 <iqubic> It
02:24:10 <jusss> dminuoso: CPS is another interesting thing
02:24:23 <jusss> dminuoso: does it relate to Monad?
02:24:36 <iqubic> It's like the saying "A Monad is just a Monoid in the category of Endo-functors. What's the problem?"
02:24:37 <jusss> Continuation Passing Style
02:25:08 <iqubic> Yes it's a true statement, but it's not all that helpful to state.
02:25:08 <jusss> some people always like to compare CPS with Monad
02:25:18 <dminuoso> jusss: Well yes actually, and that "Cont is the mother of all.." is that connection.
02:25:22 <dminuoso> But its really not useful.
02:25:24 <jgt> iqubic: I think that phrase is helpful once you learn what all the words mean
02:25:27 <iqubic> Those two aren't the same in my humble opinion
02:25:39 <iqubic> jgt: I do know what all the words mean.
02:25:41 <dminuoso> jusss: Monad is, basically, a very abstract interface that is not easy to understand. 
02:25:49 <iqubic> I am a learned man.
02:25:49 <jgt> iqubic: I'm not suggesting you don't
02:25:54 <dminuoso> jgt: Monad is just a pair of two functions following a very particular shape. Nothing more, nothing less.
02:26:01 <dminuoso> Its not <insert random word here>
02:26:07 <dminuoso> Err jusss ^-
02:26:35 <jgt> iqubic: I just think most people who have an issue with that phrase don't know what those words mean
02:26:41 <jgt> that was certainly the case for me initially
02:27:04 <dminuoso> jgt: Indeed. For me that sentence condences a very important property of Monads - its that they have a certain monoidal structure that we intuitively rely on.
02:27:22 <dminuoso> jgt: For example "the ability to move code into a separate routine/IO action" is justified by associativity.
02:27:54 <iqubic> Right. People hear the phrase and assume it's a simplified explanation of a Monad, when it reality, it is only simpler if you know all the terms being used.
02:27:57 <jgt> dminuoso: right. If you don't know what a monoid is, it's opaque. But if you know that a monoid is just a thing that can be joined with other monoids, it's like "oh right, so monads can _also_ be joined together. That makes sense."
02:28:07 <dminuoso> Like, if you said "Just move that part into a separate function and call it instead" - you'd realize that this is, behaviorally, the same thing. And the reason we intuitively believe this, is because we accept associativity there.
02:28:25 <iqubic> And most people don't understand the endofunctor part.
02:29:17 <jgt> yeah
02:29:18 <dminuoso> iqubic: I once saw someone link a particularly hilarious JavaScript tutorial that equated Monad to: the ability to have an extraction function `extract : m a -> a`
02:29:31 <iqubic> But really that's just a constraint on the type of monoid. A monoid in the category of endofunctors is "instance Monoid (M -> M)"
02:29:36 <dminuoso> And I can certainly understand why someone would say this.
02:29:37 <jgt> though most programmers can get functor if you explain it in terms of "mappable" things
02:30:04 <dminuoso> Or in terms of "container" things.
02:30:05 <jgt> but then I'd always add the footnote that that's not the entire story with functor
02:30:15 <jgt> but it's good enough for our purposes
02:30:24 <dminuoso> And Ive grown quite fond of thinking of Functor in Haskell as the generalized notion of container.
02:30:38 <dminuoso> If you expand your mind a bit, its a susprisingly good analogy even in edge cases.
02:30:54 <iqubic> Most JS programmers understand monads in terms of "flatMap" and "join" which disgusts me so god damn much.
02:30:55 <jusss> and 'bout Kleisli ?
02:31:32 <jgt> iqubic: I think it comes from that YouTube guy mpjme
02:31:32 <iqubic> Kleisli Arrows are related but different.
02:31:41 <jgt> and his unbelievably shitty explanation of Haskell and monads
02:31:51 <__monty__> vancha112[m]: Why the :(? Irc's great.
02:31:53 <jgt> God I hate that guy
02:31:58 <iqubic> I still find that representation awful.
02:32:01 <dminuoso> iqubic: Actually the flatMap/join is quite fine, really.
02:32:32 <iqubic> But that's not the haskell defintion.
02:32:36 <vancha112[m]> > vancha112: Why the :(? Irc's great.
02:32:36 <vancha112[m]> yeah it's not irc thats the problem, it's the fact that a lot of people are on there, and not here :P
02:32:41 <lambdabot>  <hint>:1:36: error:
02:32:41 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
02:33:23 <jgt> it's a little unfortunate that lambdabot's prompt clashes with the commonly used symbol for denoting quotes
02:33:50 <iqubic> Yeah. I know.
02:33:51 <jusss> now I found three terms I still don't understand "Monad Transformer" "Kleisli Arrow" and "CPS" yet, 
02:34:14 <iqubic> I only sorta understand transformers.
02:34:43 <merijn> iqubic: They are fairly easy to understand if you implement one
02:34:44 <__monty__> jgt: OTOH, "quotes have served quoting needs for ages, just fine."
02:34:46 <jgt> jusss: I don't know those three things either, and yet Haskell is my full-time job :)
02:34:56 <__monty__> This isn't email : >
02:35:08 <merijn> iqubic: Fortunately for you, I already wrote out the homework: https://gist.github.com/merijn/098106abd45c940dab09
02:35:30 <jusss> jgt: lucky for you
02:35:56 <merijn> iqubic: Simply start by implementing "classic" State, then generalise to StateT and enlightenment follows after staring at the result for a long time ;)
02:36:09 <jgt> jusss: it's worth mentioning also that despite not knowing how transformers work, I still use them every day since they're used a fair bit in Yesod
02:36:20 <jgt> jusss: and luck had nothing to do with it :P
02:36:41 <jgt> my point is: it's ok to not know stuff yet. Don't let that discourage you.
02:37:16 <jusss> jgt: I mean Haskell is you full-time job, it's lucky
02:38:16 <jgt> yeah but making it my full-time job involved starting a few companies, talking to a bunch of investors, hiring people, etc
02:38:30 <jgt> and I certainly don't make the same salary now as when I was consulting
02:38:35 <jgt> so it's a big risk on my part
02:43:28 <dminuoso> iqubic: Honestly the "return" part is not as relevant as the bind part. You could think Monad as Bind and Pointed.
02:44:23 <dminuoso> jusss: Give it time. Dont rush through these things. Understanding what Monad is, is neither important nor required. Its also not very useful.
02:44:46 <dminuoso> jusss: Its better to just focus on each Monad instance, beacuse understanding what those instances do is trivial and simple.
02:44:53 <dminuoso> (The understanding what Monad is comes on its own)
02:45:42 <merijn> It is important, it just that the understanding boils down to "Monad is an abstract interface and several laws on how that interface behaves that happens to match many frequent programming problems"
02:45:51 <merijn> Which just doesn't tell you all that much useful :)
02:47:55 <dminuoso> merijn: Its not really important unless you write code that is polymorphic over Monad.
02:49:49 <dminuoso> merijn: That word Monad only appears in things polymorphic over Monad - but those are not the things beginners write - they just appear in things that beginners *use* - and for that its sufficient to understand that Monad is basically just a restriction of "which type am I allowed to pick for it"
02:56:38 <hc> hey folks, OT question, but anyone got an idea for a minimal language to target webassembly?
02:56:51 <hc> Like, embeddably like Lua, only to not use its own bytecode but wasm instead? :-)
02:58:12 <merijn> brainfuck? >.>
02:58:41 <hc> :-)
03:13:09 <Arahael> hc: "Old" languages can be esoteric and - sometimes - "minimal", too, eg... qbasic?
03:13:38 <Arahael> The catch is they often have a huge number of reserved words, compared to clean languages.
03:13:50 <hc> Arahael: yes, what are you trying to tell me? :)
03:14:06 <hc> I specifically said, like Lua, which is a well enough designed language
03:14:38 <Arahael> hc: I suppose lua is kinda well enough designed.  The scoping is annoying, though.
03:15:08 <hc> Yeah, but I was specifically not referring to weird and unfree languages like qbasic, so I don't get your point so far...? :)
03:16:15 <Arahael> hc: Well, perhaps not specifically qbasic, but there are a whole class of languages there with *extremely* tiny implementations.
03:16:35 <Arahael> You could always just do a lisp.
03:16:47 <hc> I could, surely, but is there something of the likes already done?
03:16:53 <hc> (I'm asking because I'm about to do it myself)
03:16:56 <yushyin> e.g. MAL lisp
03:17:08 <Arahael> I'm sure there are a ton of existing implementations for basic and lisp and the like!
03:18:06 <yushyin> oops, MAL lisp already has a wasm implementation ^^
03:22:12 <Arahael> Right, there's a ton of existing stuff out there.
03:43:12 <aditya> f . g = \x -> f ( g (x) ) but what is (. f) ?
03:44:28 <Ferdirand> it's the function \g -> g . f
03:44:51 <aditya> oh so what is. ((.(>>=)).(>>=)) then?
03:45:00 <aditya> >>= is same as concatMap
03:45:22 <aditya> so is it \f g -> concatMap f . concatMap g ? 
03:45:52 <Taneb> @unpl ((.(>>=)).(>>=))
03:45:52 <lambdabot> (\ x x0 -> x >>= (>>=) x0)
03:46:30 <Phyx-> monochrom: you should try chocolatey, with ghc 8.8, choco install ghc msys2 will automatically configure things to work out of the box with no global state changes. the uninstall is essentially an rm of that folder and removing an entry from PATH.
03:46:41 <Ferdirand> @pl (\a b c -> a >>= b >>= c)
03:46:42 <lambdabot> ((>>=) .) . (>>=)
03:46:59 <Ferdirand> @pl (\a b c -> a >>= c >>= b)
03:46:59 <lambdabot> flip . ((>>=) .) . (>>=)
03:47:00 <lavalike> \x x0 -> x >>= (\f -> x0 >>= f) may be clearer
03:47:44 <Phyx-> monochrom: I'll have an easier way as well which i'll post about on 8.8 and cabal 3.0 release, along with some other stuff to make it even simpler on Windows :)
03:49:03 <Ferdirand> what's the proper way of including dependencies that are not part of the resolver, nowadays, with stack ?
03:49:45 <Ferdirand> if i add it in extra-deps in stack.yaml, ghc complains that the package is hidden and that i should fix my .cabal file
03:49:56 <Ferdirand> but my .cabal file is auto-generated
03:50:57 <Ferdirand> and if i add said package under "dependencies" in package.yaml, stack complains that this package cannot be found
03:51:16 <kuribas> At this point I'd be happy to have breakpoints like in imperative languages
03:51:22 <kuribas> And then inspect the values
03:51:46 <kuribas> I tried show and read, but I get a shitty read: no parse
03:52:02 <kuribas> to dump an result to a file using debug trace, then read it back
04:03:04 <jgt> is there a nicer way to conditionally apply some function than this rather verbose way?
04:03:06 <jgt>   makeSessionBackend app = case appEnvironment app of
04:03:07 <jgt>     Development -> Just <$> envClientSessionBackend 120 "SESSION_KEY"
04:03:09 <jgt>     _           -> sslOnlySessions $ Just <$> envClientSessionBackend 120 "SESSION_KEY"
04:03:26 <lyxia> Ferdirand: both stack.yaml and package.yaml
04:03:45 <jgt> I'm thinking there's some way to do this with `unless (appEnvironment app == Development)`
04:03:55 <kuribas> jgt: I often do "if pred then fun else id"
04:04:04 <kuribas> jgt: can work with a case statement also
04:04:09 <jgt> oh that makes sense
04:04:31 <brschkv> Has somebody tried to use servant-elm generated code with Elm 0.19 recently? (Just for a sanity check, my generated client code is not usable and I would like to see if the problem is me or Elm 0.19)
04:05:35 <Ferdirand> lyxia: that's what I tried
04:06:25 <Ferdirand> seems like it does not pickup the change in extra-deps, and i don't know how to investigate why
04:06:46 <jgt> kuribas: I ended up with this:
04:06:48 <jgt>   makeSessionBackend app = case appEnvironment app of
04:06:50 <jgt>     let env = appEnvironment app
04:06:52 <jgt>         ssl = if (env == Development) then id else sslOnlySessions
04:06:54 <jgt>      in ssl $ Just <$> envClientSessionBackend 120 "SESSION_KEY"
04:06:57 <jgt> oh whoops; need to remove that case
04:06:57 <lyxia> Ferdirand: in extra-deps it needs to come with the full version number
04:08:06 <Ferdirand> lyxia: yes, i see that with just the name it thinks it's a local directory
04:08:10 <Ferdirand> but here's the funny thing
04:08:19 <Ferdirand> if i put an invalid version on purpose, it complains this version does not exist
04:09:04 <Ferdirand> yeah ok nevermind i'm a moron
04:09:20 <jgt> Ferdirand: happens to the best of us
04:11:07 <kuribas> ugh, read: no parse is so shitty
04:11:27 <Ferdirand> i put the wrong name in package.yaml (foo-blah instead of blah-foo)
04:11:34 <merijn> kuribas: That's why you have readMaybe :p
04:11:37 <Ferdirand> and reread it a dozen times without noticing
04:12:24 <jgt> kuribas: I don't use the standard Prelude in any of my projects; I use ClassyPrelude which hides things like `read`
04:14:07 <lyxia> do you need things to be hidden to not use them
04:23:15 <kuribas> merijn: I mean it's shitty that it doesn't give more information
04:23:49 <kuribas> merijn: I dumped a trace to a file, to read it back using read, but I only get this shitty error message.
04:27:11 <jgt> lyxia: when I was a beginner it certainly would have helped
04:27:40 <jgt> lyxia: and on a team, yeah, generally I'd say it's better to hide away the subset of the language that doesn't work very well
04:28:17 <jgt> this is the same reason why someone had to write JavaScript: The Good Parts
04:28:34 <jgt> (the word "good" being especially relative in this case)
04:38:29 <merijn> Man, haskell-ci is pretty sweet...I already knew that, but still :>
04:43:57 <jgt> I'm getting a Hydra setup for CI
04:44:17 <jgt> since everything else is running on Nix anyway
04:45:21 <merijn> jgt: haskell-ci is a script that generates (complex) Travis CI setups for you, so you can plug into travis with minimal effort
04:46:40 <jgt> merijn: yeah, I hadn't heard of it but I looked it up after you mentioned it. I'm going to run my own Hydra instead of using TravisCI.
04:48:00 <dminuoso> jgt: Amusingly that book was surprisingly small.
04:49:40 <jgt> dminuoso: https://i.redd.it/h7nt4keyd7oy.jpg
05:09:20 <dminuoso> jgt: :)
05:13:13 <dminuoso> Ive been wondering, why is it that Haskell uses "of" in case-of?
05:14:00 <merijn> dminuoso: As opposed to?
05:14:17 <dminuoso> merijn: Well let's say "in", which has been used by bash and other languages.
05:14:44 <merijn> dminuoso: In sounds like a set, whereas a constructor is one out of many options
05:15:09 <merijn> Something is one of many patterns, so seems fairly logical
05:16:00 <dminuoso> I guess there's also the expression "in case of [emergency]"...
05:16:34 <arianvp[m]> test
05:16:53 <dminuoso> arianvp[m]: pong.
05:16:58 * pong
05:17:02 <arianvp> cool matrix seems to work
05:40:06 <elcid> @pl makeImage ps pos = (ps, pos)
05:40:06 <lambdabot> makeImage = (,)
05:40:20 <absence> how do i parse expressions like "(3 + 8) + 5" using attoparsec without triggering an infinite loop? apparently it's something about left recursion, but i can't find a working example, though parsec ones mention chainl
05:43:41 <opqdonut> absence: consider attoparsec-expr
05:45:57 <opqdonut> or google left-factoring
05:46:54 <opqdonut> oh ok chainl1 seems to work out pretty well too
05:47:15 <opqdonut> the example in the docs is literally arithmetic expression parsing
05:47:20 <absence> opqdonut: nice, thanks
05:47:24 <elcid> @pl changePosition im pos = (fst im, pos)
05:47:24 <lambdabot> changePosition = (,) . fst
05:47:27 <absence> opqdonut: chainl1 isn't in attoparsec though?
05:48:28 <opqdonut> yeah it could be because attoparsec doesn't do backtracking (IIRC?) which you would need for defining chainl?
05:48:39 <opqdonut> I'm not that familiar with attoparsec, just normal parsec
05:48:58 <merijn> Any specific reason you're using attoparsec?
05:50:41 <elcid> @pl moveImage img xMove yMove = (fst img, (xMove, yMove))
05:50:41 <lambdabot> moveImage = (. (,)) . (.) . (,) . fst
05:51:11 <lavalike> perfect
05:53:15 <dminuoso> elcid: Much better.
05:54:30 <dminuoso> % (.^...^.) = (. (,)) . (.) . (,) . fst
05:54:31 <yahb> dminuoso: 
05:54:35 <dminuoso> This should be in base.
05:58:26 <nil> can i define a Monad instance and let Haskell derive the "default" Applicative instance for it? or do i have to write something like  instance Applicative Foo where (<*>) = ap  ?
05:59:14 <Taneb> nil: you have to write (<*>) = ap; pure = return
05:59:28 <nil> ok
05:59:49 <nil> yeah, i was forgetting that pure is part of the MCD
06:00:18 <merijn> MCD?
06:01:18 <nil> minimal complete definition
06:03:47 <kuribas> > minimum [1 % 4::Ratio Int, maxBound % 1, 2 % 3]
06:03:51 <lambdabot>  2 % 3
06:04:07 <kuribas> I found the problem ^^
06:04:18 <kuribas> shouldn't that be 1 % 4?
06:05:28 <kuribas> > min (1 % 4::Ratio Int) (maxBound % 1)
06:05:31 <lambdabot>  9223372036854775807 % 1
06:05:37 <kuribas> bug in the standard library
06:05:47 <lavalike> > min (1%4 :: Ratio Int) (maxBound % 1)
06:05:51 <lavalike> oops
06:05:51 <lambdabot>  9223372036854775807 % 1
06:06:03 <dexterfoo> hello. i believe that the stm library is missing a version of "evaluate". what do you guys think?  evaluateSTM :: a -> STM a
06:08:40 <arianvp> > :t pure @STM
06:08:45 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
06:08:52 <arianvp> > pure @STM
06:08:55 <lambdabot>  error:
06:08:55 <lambdabot>      Pattern syntax in expression context: pure@STM
06:08:56 <lambdabot>      Did you mean to enable TypeApplications?
06:09:01 <arianvp> yes I did!
06:09:09 <arianvp> > pure :: (a -> STM a)
06:09:12 <lambdabot>  error:
06:09:12 <lambdabot>      Not in scope: type constructor or class ‘STM’
06:09:12 <lambdabot>      Perhaps you meant ‘ST’ (imported from Control.Monad.ST)
06:09:26 <arianvp> sigh, but the point id dexterfoo  that function exists. it's called pure
06:10:18 <dminuoso> nil: No there's no way to automatically have it derived.
06:10:35 <dminuoso> nil: (Well you probably could with TH)
06:10:58 <kuribas> > min (1 % 4::Ratio Int) (9223372036854775807 % 1)
06:11:02 <lambdabot>  9223372036854775807 % 1
06:11:05 <kuribas> > min (1 % 4::Ratio Int) (922337203685477580 % 1)
06:11:07 <lambdabot>  1 % 4
06:11:16 <kuribas> It seems like it flip at big numbers
06:11:28 <kuribas> as if big numbers are treaded as negative
06:13:39 <dexterfoo> arianvp: but that won't strictly evaluate it. if i wrap my code with "catchSTM" then an "error" call can sneak through it
06:14:12 <kuribas> > min (0 :: Ratio Int) (maxbound % 1)
06:14:18 <lambdabot>  error:
06:14:18 <lambdabot>      • Variable not in scope: maxbound :: Int
06:14:18 <lambdabot>      • Perhaps you meant ‘maxBound’ (imported from Prelude)
06:14:21 <nil> dminuoso: ok
06:14:23 <kuribas> > min (0 :: Ratio Int) (maxBound % 1)
06:14:26 <lambdabot>  0 % 1
06:14:29 <nil> any thoughts on this?:
06:14:31 <nil> instance Applicative f => Semigroup (f ()) where (<>) = (*>)
06:14:31 <nil> instance Applicative f => Monoid (f ())    where mempty = pure ()
06:14:38 <nil> i think it's neat
06:14:40 <kuribas> yep it seems it becomes negative!
06:15:19 <kuribas> is there a list for bugs?
06:16:46 <arianvp> dexterfoo: why would it matter whether it's strict or not ?
06:17:40 <arianvp> ah exceptions
06:18:24 <merijn> nil: It doesn't exists because it overlaps too many things
06:18:28 <dexterfoo> atomically $ (1 + (error "oops") `catchSTM` (\(e::SomeException) -> pure 2))
06:18:40 <arianvp> dexterfoo: you should use throwSTM instead of throw / error
06:18:47 <arianvp> http://hackage.haskell.org/package/stm-2.5.0.0/docs/Control-Monad-STM.html#v:throwSTM
06:18:48 <nil> merijn: makes sense
06:18:57 <merijn> nil: Any applicative can trivially be a Monoid via "mempty = pure mempty; mappend = liftA2 mappend"
06:19:02 <arianvp> that will make sure the exception doesn't escape the STM boundary
06:19:08 <merijn> nil: But then, for example, list couldn't be a Monoid anymore
06:19:08 <arianvp> i know that's not very satisfactory :P
06:19:19 <nil> merijn: right
06:19:24 <nil> the two instances would conflict
06:19:47 <merijn> nil: But, for example, IO and attoparsec's Parser do have Monoid instances and they're pretty useful
06:19:48 <dexterfoo> arianvp: that makes sense. but this is for a last-line-of-defense to catch "unexpected" code errors
06:20:09 <arianvp> dexterfoo: you can also  call seq on the final result I suppose
06:20:11 <merijn> It's nearly impossible to reliably catch error
06:20:13 <nil> merijn: i've seen (Applicative f, Semigroup a) => Semigroup (Ap f a) and the Monoid equivalent, i guess that's to prevent this
06:20:24 <merijn> nil: Yeah
06:20:24 <nil> Ap being just a "witness"
06:21:13 <merijn> arianvp: seq is not sufficient to guarantee there's no errors lurking in the result
06:21:32 <dexterfoo> merijn: why? if my result is a single "Int" and I "evaluate" it, then i will always reliably catch error. right?
06:21:41 <merijn> ah, for Int it would be
06:21:58 <kuribas> Ah I understand what's happening, the comparison is overflowing 
06:22:18 <dexterfoo> I'm gonna try (unsafeIOToSTM . evaluate)
06:22:41 <merijn> dexterfoo: That's an insanely big hammer
06:22:54 <arianvp>  atomically (return $! error "hello") should work right?
06:23:28 <absence> opqdonut: strange, i get infinite loop with attoparsec-expr as well
06:23:40 <merijn> absence: Can you pastebin your parser?
06:26:42 <absence> merijn: i'll try to remove all the irrelevant stuff
06:28:58 <dminuoso> nil: I suppose in that sense traverse_ is similar to foldMap.
06:29:44 <nil> in the  f ()  instance, traverse_ is similar to mconcat
06:30:08 <dminuoso> nil: well mconcat would be similar to sequence_
06:30:26 <nil> indeed
06:30:52 <dminuoso> nil: And indeed, if you look close enough - there is a Monoid actually hiding beneath Applicative.
06:31:24 <nil> monoids are everywhere
06:31:38 <merijn> @quote beaky monoids
06:31:38 <lambdabot> beaky says: i love monoids / they are so easy
06:31:48 <dminuoso> nil: One way to visualize this, is by representing Applicative differently: "class Functor f => Monoidal f where (<.>) :: f a -> f b -> f (a, b); unit :: m ()"
06:31:58 <merijn> dminuoso, nil: There's at least 4 or 8 monoids hiding beneath Applicative
06:31:59 <nil> oh yeah, i'm familiar with that
06:32:04 <nil> it's quite elegant
06:32:33 <merijn> There's the obvious one, Dual, First, Last...
06:32:58 <nil> merijn: corresponding to different ways of chaining values together, i suppose?
06:33:14 <dminuoso> nil: There's yet another interesting monoid representation of Applicative that makes it interestingly similar to Monad.
06:33:18 <asheshambasta> is it just me or is the wording in this lib. completely opaque? http://hackage.haskell.org/package/these-0.4.2/docs/Control-Monad-Chronicle.html 
06:33:19 <merijn> nil: First just throws away everything but the first (so mappend is just const)
06:33:38 <nil> ah
06:33:59 <nil> well that doesn't really make use of Applicative does it
06:34:24 <dminuoso> nil: So the third version is: class Functor f => EFMonoid t i f where join :: f `t` f ~> funit :: i ~> f
06:34:44 <dminuoso> nil: Now, for Applicative you set t ~ Day and i ~ Identity.
06:34:50 <asheshambasta> any advice on what kind of monad transformer stack can be used to 'record failures' (that is multiple failures can happen); and with each failure; the context of the failure also needs to be captured. 
06:35:08 <merijn> nil: Well, you can have a version that runs all effects but returns the first value (which would use Applicative)
06:35:16 <merijn> nil: You can also run all effects and return the last
06:35:22 <nil> dminuoso: and for Monad?
06:35:25 <asheshambasta> For example; for validating JSON; I'd like to be able to collect all validation failures in the JSON value along with its 'context' (e.g. path)
06:35:26 <merijn> You can run all effects, but mappend in reverse order, etc.
06:35:37 <dminuoso> nil: t ~ Compose and i ~ Identity
06:35:48 <dminuoso> nil: There's also other interesting choices for t and i.
06:35:52 <merijn> @hackage monad-validate
06:35:53 <lambdabot> http://hackage.haskell.org/package/monad-validate
06:35:54 <nil> dminuoso: what's ~> ?
06:35:57 <merijn> asheshambasta: ^^ that?
06:36:02 <dminuoso> nil: type (~>) f g = forall a. f a -> g a
06:36:08 <dminuoso> nil: A natural transformation.
06:36:36 <dminuoso> nil: "f ~> g" is just a more tense way of saying "forall a. f a -> g a"
06:36:42 <nil> i see
06:36:58 <nil> i have to research Day
06:37:06 <dminuoso> nil: data Day f g a where Day :: f x -> g y -> (x -> y -> a) -> Day f g a
06:37:08 <asheshambasta> merijn: yeah; that looks good thanks
06:37:32 <asheshambasta> and wow that is well documented. 
06:37:51 <dminuoso> nil: If you ever heard about "A monad is just a monoid...", this is it: class Functor f => EFMonoid t i f where join :: f `t` f ~> funit :: i ~> f
06:38:06 <nil> dminuoso: i have, was about to mention it
06:38:21 <nil> but i need a bit of time to parse that thing
06:39:31 <nil> dminuoso: why that name? EFMonoid?
06:40:01 <dminuoso> nil: Its a monoid in the category of endofunctors.
06:40:13 <dminuoso> Hence, EFMonoid. I was not being very creative there.
06:40:27 <nil> dminuoso: i think i had trouble parsing because you're missing a newline/semicolon between "f" and "unit"
06:40:44 <dminuoso> nil: Oh. Copy paste mishap it seems.,
06:40:47 <nil> it looks more familiar now :')
06:41:55 <nil> ok, i can see that EFMonoid Compose Identity is Monad
06:42:02 <nil> now for that Day thing...
06:43:24 <jumper149> Hi, can I export a class from a module with some class methods hidden like `module M (C (.. hiding m)) where ...`
06:44:22 <dminuoso> nil: Note that this monoid still has "monoid laws", but they are a bit turned sideways and not the same as from classic algebra. They might be better described with diagrams, https://gist.github.com/dminuoso/d5ab4ba5d8a5142dde9f4d4c736e3ecb
06:45:42 <dminuoso> jumper149: You have to explicitly list them.
06:46:24 <dminuoso> jumper149: https://www.haskell.org/definition/haskell2010.pdf section 5.2, in the list below under 4. you can see the ways how to export a class.
06:50:53 <nil> dminuoso: so, in EFMonoid Day Identity, we'd have  a <.> b = join (Day a b (,))  , correct?
06:51:17 <nil> and  a <*> b = join (Day a b ($))  ?
06:53:40 <dminuoso> nil: Looks right
06:54:29 <nil> thanks, this was interesting
06:54:43 <dminuoso> nil: https://upload.wikimedia.org/wikipedia/commons/thumb/3/39/Monoid_multiplication.svg/825px-Monoid_multiplication.svg.png https://en.wikipedia.org/wiki/Monoid_(category_theory)#/media/File:Monoid_unit_svg.svg
06:54:59 <dminuoso> nil: These diagrams must all lead to the same result, no matter how you go.
06:55:27 <dminuoso> nil: ⊗ is just ⌜t⌝, I is ⌜i⌝, μ is just ⌜join⌝
06:56:18 <nil> dminuoso: yeah
06:57:09 <dminuoso> nil: Thanks to jle` I discovered other monoids to. There's a few simpler but also interesting tensors to pick.
06:57:30 <nil> dminuoso: so, basically, "All told, an applicative functor in X is just a monoid in the category of endofunctors of X, with product × replaced by Day convolution of endofunctors and unit set by the identity endofunctor." ?
06:57:41 <dminuoso> nil: Spot on.
06:57:44 <nil> this is an interesting variation
06:57:50 <nil> are there other interesting choices for i ?
06:57:57 <dminuoso> nil: The choices of i depend on the tensor.
06:58:10 <dminuoso> nil: Basically the joke is still somewhat incomplete as its terse.
06:58:12 <nil> i'm all ears
06:58:35 <dminuoso> nil: All told, an applicative functor in X is just a monoid in the *monoidal* category of endofunctors of X, with *the tensor* × replaced by Day convolution of endofunctors and its unit set by the identity endofunctor."
06:58:41 <dminuoso> nil: There I added some clues.
06:59:02 <dminuoso> nil: You cant pick just any tensor, it has to be one for which additional coherence laws are satisfied.
06:59:13 <dminuoso> that tensor itself must have a certain monoidal structure to begin with
06:59:46 <nil> like  (a :.: b) :.: c ~ a :.: (b :.: c)  ?
06:59:55 <dminuoso> nil: Yeah.
07:00:11 <dminuoso> nil: And also "T :.: Identity ~~~ T"
07:00:15 <dminuoso> nil: And the other side.
07:00:19 <nil> what's ~~~ ?
07:00:22 <dminuoso> nil: Isomorphic to.
07:00:26 <nil> ok
07:00:30 <dminuoso> nil: I personall reserve ~ to denote actual type equality.
07:00:32 <dminuoso> So..
07:00:40 <nil> sensible
07:00:44 <dminuoso> nil: Also your equation would only hold up to isomorphism.
07:01:07 <nil> yeah
07:01:17 <dminuoso> nil: So you might notice that the identity would depend on the tensor, really.
07:01:29 <nil> indeed
07:01:44 <nil> not that i can think of a tensor with a different identity
07:01:53 <dminuoso> nil: Two good candidates are Sum and Product.
07:02:05 <nil> right, with i ~ ()
07:02:13 <nil> er, for product at least
07:02:14 <dminuoso> nil: Careful.
07:02:27 <dminuoso> nil: I urge you to think slowly. :-)
07:02:39 <dminuoso> nil: Remember that this is the category of endofunctors.
07:03:31 <nil> aah
07:03:35 <nil> Void?
07:03:51 <nil> no, wait, how is it called
07:04:30 <nil> Const ()
07:05:36 <nil> dminuoso: Product T (Const ()) ~~~ T, right?
07:06:06 <elcid> @pl makeTotal xs =  sum (map snd xs)
07:06:06 <lambdabot> makeTotal = sum . map snd
07:10:27 <dminuoso> nil: Construct a proof?
07:10:44 <dminuoso> nil: And which tensor are you considering?
07:11:00 <nil> well the Product tensor
07:11:13 <nil> what would a proof of this kind of statements look like?
07:11:27 <nil> constructing a bijection from one to another?
07:11:28 <asheshambasta> merijn: that library looks kind of new no? I'm using this on an ancient stackage resolver; so I'm not sure if I can compile this. 
07:12:04 <dminuoso> nil: So there are certain monoidal laws that need to be satisfied up to isomorphism.
07:12:12 <dminuoso> nil: That means its enough that these isomorphisms exist.
07:12:29 <dminuoso> *to show
07:12:59 <merijn> asheshambasta: It was released just this week, so yes :p
07:13:29 <asheshambasta> merijn: makes me want to move my workflow from Stack to Nix; given that I'm already a nix user. 
07:13:49 <asheshambasta> unsurprisingly the library is not on Stackage. 
07:13:49 <nil> dminuoso:  f :: T a -> Product T (Const ())   f x = Pair x (Const ())
07:14:11 <dminuoso> nil: e.g. show that: assocL :: ((a `t` b) `t` c) ~> (a `t` (b `t` c); assocR :: (a `t` (b `t` c) -> (a `t` b) `t` c) exist and that they are isomorphisms.
07:14:12 <nil> er,
07:14:15 <nil> dminuoso:  f :: T a -> Product T (Const ()) a   f x = Pair x (Const ())
07:14:22 <dminuoso> nil: And equivalently for the unit laws (you end up with quite a few functions)
07:14:41 <dminuoso> nil: And I may have dropped a few parens above, I just noticed.
07:14:43 <merijn> asheshambasta: I'm  using cabal-install anyway, so I never really think about how new things are
07:14:53 <nil> dminuoso: i'm just considering the unit laws for now
07:15:19 <nil> as you suggested Product and Sum. i'm fairly confident that Const () is the identity we need for Product, but i'm not sure about Sum
07:15:30 <asheshambasta> merijn: I'm tempted to jump ship; but I've grown quite fond of intero; which, unfortunately, need stack.
07:16:08 <nil> perhaps Const Void?
07:16:50 <nil> it would be interesting to note that () has 1 inhabitant, and Void has 0
07:17:11 <nil> 1 being the identity for product, and 0 being the identity for sum
07:18:07 <dminuoso> nil: You should try and reason about this yourself.
07:18:17 <nil> ok.
07:18:22 <dminuoso> nil: You could simply write an instance for: class Category hom => MonoidalCategory hom neut comb | hom comb -> neut where neutL_ :: (neut `comb` i) `hom` i; neut_L :: i `hom` (neut `comb` i); neut_R :: i `hom` (i `comb` neut); neutR_ :: (i `comb` neut) `hom` i; assocLR :: ((i `comb` j) `comb` k) `hom` (i `comb` (j `comb` k)); assocRL :: (i `comb` (j `comb` k)) `hom` ((i `comb` j) `comb` k)
07:18:50 <dminuoso> This looks like quite a mouthful, but if we set ⌜hom ~ (->)⌝, then you will see that these methods correspond to the isomorphisms of that monoidal category
07:18:56 <dminuoso> here neut is i and comb is t
07:19:37 <nil> i see
07:19:48 <dminuoso> nil: Then all you need to do is prove that neutL_ and neut_L form an isomorphism, neut_R and neutR_, and assocLR and assorRL
07:20:45 <dminuoso> (The reason this class is different is because I copied it straight from a previous, related, discussion)
07:27:27 * hackage pandoc-pyplot 2.1.5.1 - A Pandoc filter to include figures generated from Python code blocks  https://hackage.haskell.org/package/pandoc-pyplot-2.1.5.1 (LaurentRDC)
08:04:38 <dminuoso> nil: I wasnt really paying attention earlier. Your guesses regarding <.> and <*> were quite off.
08:05:04 <dminuoso> nil: Consider the type of join specialized to Day
08:05:53 <nil> join :: Day f f ~> f
08:06:05 <nil> join :: Day f f a -> f a
08:06:12 <dminuoso> Ohh nevermind. Its all good. :)
08:06:15 <nil> :D
08:09:04 <dminuoso> nil: So in some sense, if we allow yourself to think of endofunctors as representing effectful computations, then different EFMonoids give us different modes of "execution" so to speak.
08:09:35 <dminuoso> nil: One cool think about Day in general, is that it lets you express running two different computations (different in their type even!), but combine their output.
08:09:35 <dminuoso> So it's a sort of diamond.
08:09:50 <nil> diamond?
08:10:00 <dminuoso> It's particularly a diamond when Day is constrained to the same type in both arguments, eg when you use it as: f `Day` f
08:10:37 <kuribas> > min (1 % 2::Ratio Int) (maxBound % 1)
08:10:40 <lambdabot>  9223372036854775807 % 1
08:10:52 <merijn> hmmm, I wish travis' macOS tests were faster so it didn't take a million years to check if all tests pass >.>
08:11:00 <kuribas> > min (1 % 2::Ratio Word) (maxBound % 1)
08:11:05 <lambdabot>  1 % 2
08:11:24 <dminuoso> nil: So Applicative has no sequencing built into it, the computations are unrelated
08:12:11 <dminuoso> % :t (<*>)
08:12:11 <dminuoso> The second argument does not depend on the first argument
08:12:11 <dminuoso> nil: So `Day f f` sort of describes "two effects in parallel", and join fuses them together.
08:12:11 <yahb> dminuoso: Applicative f => f (a -> b) -> f a -> f b
08:12:20 <Taneb> kuribas: that looks a tad worrying
08:12:29 <kuribas> Taneb: it's overflowing
08:12:54 <kuribas> > 2 * (maxBound :: Int) < 1
08:13:00 <lambdabot>  True
08:13:05 <nil> dminuoso: if i understand correctly, Day contains both the effects *and* a pure function for combining their outcomes?
08:13:16 <dminuoso> nil: But mind you, this is just for some sense of "parallel". 
08:13:16 <dminuoso> nil: join essentially brings their effects/results together.
08:13:30 <dminuoso> nil: What Day contains is not as interesting as what you can do with it.
08:13:51 <dminuoso> nil: Things are characterized by what you can do with them, not what you can place into them.
08:13:58 <nil> ok
08:14:12 <dminuoso> nil: The relevant thing is
08:14:28 <dminuoso> nil: Day gives rise to a monoid that looks like: join :: f `Day` f ~> f
08:14:40 <dminuoso> nil: Just like Compose gives rise to a monoid that looks like: join :: f `Compose` f ~> f
08:14:47 <dminuoso> They mean completely different things though.
08:31:18 <infandum> Is there a way to add "-std=c++14" to the stack.yaml or .cabal file for building?
08:31:41 <infandum> Instead of ~/.stack/programs/x86_64-linux/ghc-8.6.3/lib/ghc-8.6.3/settings
08:32:58 <vaibhavsagar> stack is omakase
08:33:09 <vpei[m]> 😄
08:33:21 <merijn> infandum: cxx-options, presumably
08:33:55 <merijn> infandum: https://cabal.readthedocs.io/en/latest/developing-packages.html#pkg-field-cxx-options
08:43:13 <infandum> merijn: Fantastic, thank you!
08:46:28 * hackage spectral-clustering 0.3.1.1 - Library for spectral clustering.  https://hackage.haskell.org/package/spectral-clustering-0.3.1.1 (GregorySchwartz)
08:51:35 <jgt> vaibhavsagar: https://twitter.com/tomdale/status/291788972961701888?lang=en
08:52:27 * hackage modularity 0.2.1.1 - Find the modularity of a network.  https://hackage.haskell.org/package/modularity-0.2.1.1 (GregorySchwartz)
08:54:04 <MarcelineVQ> ^ "Report Q, the Newman-Girvan modularity of an adjacency matrix." you guys sure do say some things sometimes, whatever they are or mean
08:55:59 <infandum> MarcelineVQ: https://en.wikipedia.org/wiki/Modularity_(networks)
08:56:04 <infandum> Very specialized :)
08:57:25 <MarcelineVQ> oh graph clustering? neat
08:57:59 <MarcelineVQ> This is relevant to my interests in fact, nice link infandum
08:58:44 <wroathe> ^ look at this fancy pants throwing around words like "clustering" and "graph"
08:59:12 <MarcelineVQ> I have become the beast
09:09:28 * hackage hierarchical-spectral-clustering 0.4.1.2 - Hierarchical spectral clustering of a graph.  https://hackage.haskell.org/package/hierarchical-spectral-clustering-0.4.1.2 (GregorySchwartz)
09:16:57 * hackage birch-beer 0.1.4.4 - Plot a colorful tree.  https://hackage.haskell.org/package/birch-beer-0.1.4.4 (GregorySchwartz)
09:49:28 * hackage too-many-cells 0.1.12.3 - Cluster single cells and analyze cell clade relationships.  https://hackage.haskell.org/package/too-many-cells-0.1.12.3 (GregorySchwartz)
09:57:42 <wroathe> https://gist.github.com/JustinChristensen/699596434c2e776b55274efbd8a435c2
09:58:10 <wroathe> So I'm drawing a blank on how to implement this so that I don't care what monad the inner reader is based on
09:59:22 <wroathe> :t liftIO
09:59:25 <lambdabot> MonadIO m => IO a -> m a
09:59:33 <wroathe> I need like an inverse liftIO
09:59:58 <merijn> wroathe: MonadUnliftIO?
10:00:03 <merijn> @hackage unliftio-core
10:00:03 <lambdabot> http://hackage.haskell.org/package/unliftio-core
10:00:04 <c_wraith> that's a problem with many painful solutions.
10:00:18 <merijn> c_wraith: And one very unpainful one nowadays :)
10:00:49 <wroathe> c_wraith: As in my solution is painful? 
10:01:31 <merijn> wroathe: Well, things like MonadBaseControl were invented to do that, but then everyone realised that MonadBaseControl is super confusing and painful to use and still accident prone
10:02:29 <merijn> wroathe: MonadUnliftIO is a severely restricted version of MonadBaseControl which is much simpler, the downside is that it only works for "ReaderT-like things", but that covers a huge part of the useful transformers (like LoggingT, ResourceT, etc.)
10:03:03 <arianvp> wondering if something like this already exists
10:03:39 <arianvp> I have a     [Either w a]   and I want to find the first Right, but collect All the Lefts along the way
10:03:41 <arianvp> so
10:04:13 <arianvp> f [Left [1], Left [2], Left [3], Right "yo", Left 5] == ([1,2,3], "yo")
10:04:29 <arianvp> aka "try a bunch of parsers until one succeeds"
10:04:44 <lavalike> :t partitionEithers
10:04:47 <lambdabot> [Either a b] -> ([a], [b])
10:04:48 <merijn> I don't think that exists
10:04:54 <merijn> lavalike: won't work
10:05:00 <arianvp> that's too eager
10:05:07 <merijn> lavalike: Unable to tell which Left's are after the first Right
10:05:17 <lavalike> ah you want it to stop there
10:05:17 <arianvp> also it will not stop after the first Right either
10:05:25 <lavalike> I missed that
10:05:36 <arianvp> I first thought this was the validation applicative. but it isnt :')
10:06:59 <arianvp> it's close though.
10:07:00 <lavalike> :t bimap lefts rights . partition isLeft
10:07:02 <lambdabot> [Either a b] -> ([a], [b])
10:07:19 <lavalike> prob still wrong
10:08:52 <lavalike> :t bimap lefts rights . span isLeft
10:08:54 <lambdabot> [Either a b] -> ([a], [b])
10:08:57 <lavalike> closer!
10:09:04 <Cale> merijn: MonadUnliftIO is better, but I still think it's fairly accident-prone, particularly when the ReaderTs carry mutable state cells, because it ignores the meaning of the operation being lifted, and how that might interact with the meaning of the environment / state cells.
10:09:23 <Cale> (oh, also wroathe)
10:09:32 <merijn> Cale: Sure, naively making everything MonadUnliftIO is dangerous
10:09:42 <merijn> Cale: But for many simple things it's fine
10:09:52 <Cale> I tend to prefer the option of defining a class for the thing I'm lifting
10:10:14 <merijn> Cale: That's not really helpful in library code, though
10:10:16 <Cale> and then implementing instances for the transformers that I'm using, which gives me the opportunity to check that it's meaningful and makes sense
10:10:56 <Cale> Isn't it?
10:10:58 <lavalike> > bimap lefts (maybeToList . listToMaybe . rights) . span isLeft $ [Left [1], Left [2], Left [3], Right "yo", Left [5], Right "meep"]
10:11:02 <lambdabot>  ([[1],[2],[3]],["yo"])
10:11:34 <merijn> Cale: In the sense that without MonadUnliftIO this function would be a lot less useful: https://hackage.haskell.org/package/broadcast-chan-conduit-0.2.0.2/docs/BroadcastChan-Conduit.html#v:parMapM
10:12:23 <Cale> merijn: It should be just as useful, it would just have a different constraint in place of that
10:12:33 <wroathe> Well, the basic goal here is to interpret this DSL differently based on whether the inner reader is based on IO or Identity
10:12:36 <merijn> Cale: Like?
10:12:59 <wroathe> https://gist.github.com/JustinChristensen/2dd52d273c0e4e3b156faa11e920d6fb
10:13:08 <wroathe> I'm still working out what the API is going to look like
10:14:27 <merijn> heh, I just realised I can ditch the MonadResource constraint on that function
10:14:29 <merijn> \o/
10:14:38 <Cale> merijn: Presumably something which explained how to run an action asynchronously in m
10:15:12 <Cale> runParallel could be made into a class method
10:15:26 <merijn> Cale: If I define my own class in that library I basically end up forcing everyone in the world to define orphan instances of that class or depend on me
10:15:56 <merijn> Cale: MonadUnliftIO has many instances, unliftio-core is super lightweight as a dependency, making it much more likely for people to define instances for it
10:15:58 * hackage quickcheck-classes-base 0.6.0.0 - QuickCheck common typeclasses from `base`  https://hackage.haskell.org/package/quickcheck-classes-base-0.6.0.0 (andrewthad)
10:16:17 <merijn> Cale: Using any other custom class will just make it much more of a hassle to use
10:16:32 <wroathe> Oh, I'm being dumb. Ignore me.
10:17:34 <Cale> I guess I worry a bit less about orphans, in that while it's good to move them such that they're no longer orphans, it's also possible to segregate them into their own module and only import that module in executable rather than library contexts.
10:18:02 <Cale> (You can always defer the need for an instance)
10:18:19 <merijn> Cale: Only if no one wants to make a library that uses broadcast-chan internally
10:18:40 <merijn> Which would kinda defeat the purpose of having packages to depend on...
10:18:51 <Cale> merijn: Even if they do want to use it internally, they can propagate whatever constraints come from not having those instances
10:19:10 <Cale> No?
10:19:19 <merijn> That's not obvious to me
10:19:58 <Cale> I guess it typically requires FlexibleInstances, but that's no big deal
10:20:05 <Cale> Er, FlexibleContexts
10:22:57 <merijn> hmm, ok, maybe I can't make it work without MonadResource...
10:29:57 * hackage esqueleto 3.1.0 - Type-safe EDSL for SQL queries on persistent backends.  https://hackage.haskell.org/package/esqueleto-3.1.0 (parsonsmatt)
10:30:57 * hackage persistent 2.10.1 - Type-safe, multi-backend data serialization.  https://hackage.haskell.org/package/persistent-2.10.1 (parsonsmatt)
10:31:58 * hackage persistent-mysql 2.10.1 - Backend for the persistent library using MySQL database server.  https://hackage.haskell.org/package/persistent-mysql-2.10.1 (parsonsmatt)
10:33:28 * hackage quickcheck-classes 0.6.3.0 - QuickCheck common typeclasses  https://hackage.haskell.org/package/quickcheck-classes-0.6.3.0 (andrewthad)
11:54:29 <shapr> good afternoon!
12:01:13 <Boarders> If I want to remove the ith element of a vector what would be the quickest way to do so?
12:01:33 <Boarders> I could do splitAt and then append after dropping the first element 
12:03:54 <ovitus> Hi, I'm wondering how I might covert a list of int [0..7] to string ["1","2","3","4","5","6","7"] ?
12:04:06 <cocreature> > map show [0..7]
12:04:13 <lambdabot>  mueval-core: Time limit exceeded
12:04:21 <cocreature> % map show [0..7]
12:04:22 <yahb> cocreature: ; <interactive>:298:1: error:; Ambiguous occurrence `map'; It could refer to either `Data.List.NonEmpty.map', imported from `Data.List.NonEmpty'; or `Prelude.map', imported from `Prelude' (and originally defined in `GHC.Base')
12:04:31 <cocreature> % Prelude.map show [0..7]
12:04:32 <yahb> cocreature: ["0","1","2","3","4","5","6","7"]
12:04:45 <ovitus> nice thanks!
12:06:22 <ovitus> also.. how might I make a double into an in?
12:06:29 <ovitus> round it?
12:06:35 <ovitus> into an int  **
12:07:21 <cocreature> ovitus: how do you want to convert? round? floor? ceiling?
12:07:58 * hackage too-many-cells 0.1.12.4 - Cluster single cells and analyze cell clade relationships.  https://hackage.haskell.org/package/too-many-cells-0.1.12.4 (GregorySchwartz)
12:08:04 <ovitus> whats the major difference between them?
12:08:11 <ovitus>     • Couldn't match type ‘Double’ with ‘Int’      Expected type: Pattern Int        Actual type: Pattern Double
12:08:20 <ovitus> that's the error I get
12:08:22 <jle`> ovitus: given 2.3, do you want 2 or 3 ?
12:08:26 <ovitus> this is in tidalcycles
12:08:35 <ovitus> closest
12:08:35 <ovitus> 2
12:08:40 <jle`> ah, you want the closest integer
12:08:49 <jle`> so you want to round it
12:08:53 <jle`> try `round` :)
12:09:02 <jle`> > round 2.3
12:09:06 <lambdabot>  2
12:22:50 <srid> if I want a type safe version of `FilePath` is this the best available candidate? http://hackage.haskell.org/package/path
12:23:03 <merijn> srid: Probably, yes
12:33:15 <dansimon> Hi guys, does anyone know how I can convert getArgs to a string, so putStrLn can print it..?
12:33:49 <cocreature> dansimon: are you familiar with do-notation?
12:33:50 <merijn> dansimon: Well, that depends on you want to format it
12:34:02 <merijn> dansimon: And perhaps also relevant, do you know of:
12:34:03 <merijn> :t print
12:34:10 <lambdabot> Show a => a -> IO ()
12:34:20 <dansimon> as a single string, where the elements are separated by a space
12:34:33 <dansimon> and a newline at the end...
12:34:53 <merijn> > unwords ["this","is","a","list","containing","multiple", "words"]
12:34:56 <lambdabot>  "this is a list containing multiple words"
12:35:09 <dansimon> Aha... interesting!
12:36:49 <dansimon> thanks!
12:50:11 <basic> if i have an array/triple of 3 eleements, how would i apply these to a function?
12:50:38 <merijn> basic: By extracting them and applying them?
12:50:49 <geekosaur> deconstruct with a pattern and apply; there's nothing that converts an n-tuple or list to flat parameters
12:51:08 <geekosaur> and can't be, if you think about how function application works
12:51:54 <geekosaur> hm, suppose the PrintfType trick might work, btu you'd need instances for a lot of types
12:52:23 <geekosaur> or pray that overlap does the right thing, maybe
12:56:17 <merijn> In summary: You do it the dumb verbose way
13:02:57 <basic> merijn: how do i do that inside a if statement?
13:03:10 <basic> i mean i can't do things sequentially, do i?
13:03:20 <merijn> basic: I'm not sure what you mean by that?
13:03:29 <basic> i have
13:03:37 <basic> if ... then ... else Block [a,b,c]
13:03:44 <basic> while Block is a constructor
13:03:49 <basic> and i want Block a b c
13:03:51 <merijn> Also, note that there are not if statements (or any statements, for that matter), if/then/else is just an expression (similar to the ternary operator in, say, C
13:04:04 <basic> well.. isn't that a statement?
13:04:21 <merijn> basic: Eh, you just write "Block a b c" instead of "Block [a,b,c]"?
13:04:30 <basic> well, but i have an array, the pattern is actually
13:04:33 <monochrom> if ... then ... else Block a b c  ?
13:04:43 <basic> Block ((replicateM 3 something) !! 3)
13:04:44 <merijn> monochrom: Too slow! :p
13:04:47 <lavalike> maybe you're missing something like: let [a,b,c] = xs in Block a b c
13:04:55 <merijn> ^^
13:05:03 <merijn> Yeah, what lavalike says
13:05:08 <merijn> That's perfectly fine
13:05:14 <basic> well, hm, but isn't there like scoping issues?
13:05:21 <basic> i will try that, thanks
13:05:27 <merijn> basic: Scoping issue how?
13:05:43 <basic> well, i can't say where in the end of the function "block"
13:05:52 <basic> because that would make no sense.. because these things don't exist
13:06:05 <basic> in that "context" it's further down.. maybe im just getting it wrong
13:06:08 <merijn> basic: "let ... in .." is another expression, and can go anywhere
13:06:16 <basic> yeah i didn't think about that one
13:06:26 <basic> is there replicateM for tuples?
13:06:48 <merijn> basic: Can you rewind and explain what you're using replicateM for?
13:07:10 <basic> phew.. i have a tri-tree (k-tree with k = 3)
13:07:30 <lavalike> a "three" if you will *chuckles*
13:07:58 <basic> and i want to have an endless list of all possible trees, however: i wan't them in an order that makes sense.. breath(forgot that spelling) first
13:08:11 <basic> and im trying different approaches for that to learn haskell
13:08:31 <basic> im trying the fibs approach, the "nextTree" approach (which is kinda like this one)
13:08:41 <basic> and i realized that's like counting in binary
13:09:04 <basic> so that's why i used replicateM to count in binaries where EndNode is 0 and Node EndNode EndNode EndNode is 1
13:09:18 <basic> if i have a carry ⇒ next "depth"
13:09:36 <basic> and sure it's not counting in binary, it's in base 3
13:09:42 <basic> wait, no binary.
13:10:36 <basic> and i wanna try these approaches and test for performance, i also wonder how would i do that
13:29:26 <wroathe> Is there a way I can write this AST type so that it's more easily traversable? https://github.com/JustinChristensen/bison-grammar-codegen/blob/master/src/Bison/Grammar/Types.hs#L111
13:29:32 <wroathe> The reason I ask is because I'm going to end up with a lot of code that looks like this: https://github.com/JustinChristensen/bison-grammar-codegen/blob/master/src/Bison/Grammar/Utils.hs#L25
13:29:37 <wroathe> Every time I need to pull some data from it
13:30:57 <wroathe> I started out making each type a functor, but I found that to be too polymorphic for the leaf nodes of the tree
13:32:12 <wroathe> For instance, it doesnt make sense to write CodeGD (Maybe IdT) BracedCodeT as CodeGD (Maybe a) a when I know what both of those as need to be
13:33:21 <wroathe> both of those a's
13:53:29 * geekosaur wonders if this calls for mono-traversable and friends
13:53:54 * geekosaur also hit the wrong key first, sigh
13:58:47 <wroathe> geekosaur: Talking about my thing?
13:58:57 <geekosaur> yes
13:59:40 <geekosaur> I didn't look at it though (not the best of setups here, and stuck on webchat too)
14:00:28 <wroathe> geekosaur: Well, even if I don't end up using that it's still a good tip. I was having trouble thinking of how to phrase the question for future research
14:00:35 <wroathe> And monomorphic container captures that perfectly
14:01:50 <geekosaur> I'm not actually fond of that package because it often gives ghc too much rope, but that's more because it's mostly used to overload lots of string-like types and ghc can decide to convert when you don't expect it
14:02:26 <geekosaur> (fancy RULES that can backfire, presumably not a problem in your case unless you try to get clever with IsString)
14:13:09 <wroathe> Yeah, the Foldable/Traversable stuff is awesome to have for free with polymorphic containers, but it obviously breaks down as soon as you can't talk about a thing being full of some type a
14:13:58 * hackage criterion-measurement 0.1.2.0 - Criterion measurement functionality and associated types  https://hackage.haskell.org/package/criterion-measurement-0.1.2.0 (ryanglscott)
14:50:30 <josiah_sama> I'm using the Frames library to build out some stuff for experimenting with data modeling and ML (as I'm learning it), and I'm trying now to figure out how to efficiently divide an in-memory frame by unique values of a column.  So, I've figured out how to filter a Frame on a column value (https://github.com/josiah14-MachineLearning/ID3-and-Derivatives/blob/master/ID3/haskell/sequential/hid3-and-seq/src/Lib.hs#L98), but
14:50:30 <josiah_sama> what I'd like to do is instead of just getting back one Frame filtered on one value in the column, I'd like to get back a List of N Frames for N unique values in the filtering column.  Obviously, I could just run `filterFrame` for each unique value in the column and return the resulting List, but that would be inefficient because I'd be traversing the entire Frame N times.  I'd prefer a way to be able to do this in a
14:50:31 <josiah_sama> single traversal. 
14:51:00 <josiah_sama> Docs for Frames: https://hackage.haskell.org/package/Frames
15:01:29 * hackage DataVersion 0.1.0.0 - Type safe data migrations  https://hackage.haskell.org/package/DataVersion-0.1.0.0 (agentultra)
15:05:33 <orzo> anyone use hmatrix and have any opinions on the design and type-classes?
15:07:00 <orzo> I have a fork where i removed the Member class and made it so that Storable is all you need to implement for your type to occupy a Matrix
15:07:15 <orzo> in doing so, i got rid of a lot of specialization
15:08:07 <orzo> but the specilization intentions aren't documented anywhere and it a lot of it doesn't *look* worthwhile
15:09:37 <orzo> if we're going to uglify the code for performance reasons, there should at least be some standard benchmarks to maintain
15:27:39 <jle`> i have a lot of scattered opinions on the design of hmatrix
15:28:19 <jle`> but they're a bit everywhere from the many years i've been using it :)
15:29:54 <jle`> i'm not sure whta the Member class is, but i suspect the reason matrix members are so limited is because it was originally meant for most of the operations to be done with blas/lapack
15:39:57 <crestfallen> > pure 5 :: [Int]
15:40:01 <lambdabot>  [5]
15:40:20 <crestfallen> hi why do I need to specify the type here?
15:40:32 <crestfallen> > pure 5
15:40:35 <lambdabot>  error:
15:40:35 <lambdabot>      • Ambiguous type variable ‘f0’ arising from a use of ‘show_M566981383817...
15:40:35 <lambdabot>        prevents the constraint ‘(Show (f0 Integer))’ from being solved.
15:40:43 <hpc> what should it show?
15:41:05 <hpc> > pure 5 :: Maybe Int
15:41:10 <lambdabot>  Just 5
15:41:10 <hpc> > pure 5 :: IO Int
15:41:14 <lambdabot>  <IO Int>
15:41:22 <hpc> > pure 5 :: (Int -> Int)
15:41:30 <lambdabot>  mueval-core: Time limit exceeded
15:42:00 <crestfallen> the instance declaration for applicative []  is pure x = [x]
15:42:44 <hpc> why should it look at that instance in the first place?
15:43:08 <crestfallen> I dont know
15:43:11 <boj> :t pure
15:43:14 <lambdabot> Applicative f => a -> f a
15:43:18 <hpc> it could pick any of the others i showed
15:43:24 <hpc> or ones that your module doesn't even know about yet
15:43:25 <boj> there's no way it can know what f you are talking about
15:44:25 <basic> http://dpaste.com/155YMA9
15:44:38 <basic> can somebody tell me whats the problem here? i don't see it
15:44:45 <hpc> fun fact: this happens all the time
15:44:55 <crestfallen> what does
15:45:03 <hpc> ambiguous type variables
15:45:06 <hpc> :t 5
15:45:09 <lambdabot> Num p => p
15:45:10 <hpc> > 5
15:45:11 <orzo> i found some benchmarks and ran them and compared.  It solved linear problems with 500,1000,and 1500 samples respectively.  My branch did way worse with 500 samples, but did noticably better with 1000 and about the same with 1500
15:45:14 <lambdabot>  5
15:45:18 <orzo> not what i expected heh
15:45:37 <hpc> here it doesn't know if it should be Int or Double or Complex or Rational or what
15:45:48 <hpc> but only for numbers, the type gets defaulted
15:46:03 <hpc> if it's Num p, it picks Int (or Integer?)
15:46:18 <hpc> if it's Floating p, it picks DOuble
15:46:22 <hpc> > 5.0
15:46:26 <lambdabot>  5.0
15:46:26 <hpc> :t 5.0
15:46:28 <lambdabot> Fractional p => p
15:46:30 <crestfallen> hpc yeah somehow I thought it defaults to List but there's no reason for that
15:46:33 <hpc> ah, Fractional
15:46:42 <basic> crestfallen: do you know the track by soilwork?
15:46:51 <crestfallen> ?
15:46:56 <hpc> there are extended defaulting rules
15:47:06 <hpc> but i think that just means as a last ditch effort pick ()
15:47:14 <basic> crestfallen: there is a song, crestfallen by soilwork, it's great
15:47:33 <crestfallen> kraftwerk I remember back in the day
15:47:49 <crestfallen> oh my namesake I see :)
15:48:18 <crestfallen> great word, too pretty to change though I'm essentially an eternal optimist
15:48:22 <hpc> i thought it came from a tragic toothpaste accident ;)
15:48:37 <crestfallen> hpc that's funny
15:49:09 <crestfallen> used primarily for birds and mammals
15:50:14 <crestfallen> I tried taking a class on ethereum. what a pain. asked for a refund
15:52:55 <hpc> basic: what do you want the type of allBlocks to be?
15:53:14 <crestfallen> basic holy smokes listening now...
15:53:15 <hpc> (trying to see if i can get a better error message)
15:55:32 <orzo> jle`: I meant the Element class, not Member.  Is that more familiar?
15:57:05 <basic> crestfallen be thy name
15:57:09 <jle`> orzo: ah yeah, that's what i suspected
15:57:14 <basic> hpc: all possible Threes
15:57:21 <basic> (named by someone earlier)
15:57:28 <basic> Threes = k-tree with k = 3
15:57:50 <basic> https://stackoverflow.com/questions/28100650/generate-all-possible-trees trying to apply this to a 3-tree
15:57:57 * hackage X 0.3.0.0 - A light-weight XML library  https://hackage.haskell.org/package/X-0.3.0.0 (HerbertValerioRiedel)
15:57:58 <jle`> orzo: yeah, the reason why Element exists is because effectively all non-trivial operations are outsourced to blas/lapack, which only supports those specific monomorphic types
15:58:15 <jle`> orzo: so the typeclass basically selects the C API call to dispatch
15:58:17 <basic> i don't know what "inits" does there, and what the equivalent for zip smaller (reverse smaller) 
15:58:19 <hpc> basic: ah, here we go
15:58:27 <hpc> replicateM 3 $ concat groups :: [[Block a]]
15:58:30 <basic> i mean, i know what inits does, but not why he does it
15:58:33 <hpc> go :: [[[Block a]]] -> [Block a]
15:58:40 <hpc> :t inits
15:58:43 <lambdabot> [a] -> [[a]]
15:58:57 <jle`> orzo: technically Matrix should be able to store anything storable, but you can't really do anything with it within hmatrix without having it be cblas-compatible
15:58:57 <basic> as i said, i know what inits does :/ but not why he uses it
15:59:16 <jle`> orzo: it's kind of like how technically you can store any type in a Set, but pretty much all of the operations require Ord
15:59:20 <basic> and that the type is different, the compiler told me that, also :/
15:59:22 <hpc> yeah, trying to think through this
15:59:53 <basic> well, i found out why, by now, and moved one already :/
16:00:53 <basic> i do not even know if replicateM would be the correct way
16:01:27 <basic> basicially i want to create trees of length n+1 while having all trees of length n
16:01:30 <basic> depth, whatever
16:01:39 <hpc> ah
16:01:48 <hpc> okay, so i guess you want something like this?
16:01:49 <hpc> *Main> go [[[EndBlock], [EndBlock], [EndBlock]]]
16:01:49 <hpc> [Block EndBlock EndBlock EndBlock]
16:02:03 <hpc> but replicateM 3 $ concat groups = [[EndBlock,EndBlock,EndBlock]]
16:02:04 <basic> more like
16:02:36 <basic> go [[EndBlock ]] ⇒ [[Block EndBlock EndBlock EndBlock]]
16:02:38 <basic> (not sure)
16:03:14 <hpc> hmm
16:03:29 <hpc> extract go from the where block, and try and get that to do what you want individually
16:03:38 <hpc> since it's not really dependent on anything else being defined
16:03:49 <hpc> since it sounds like that's not quite right
16:03:54 <basic> :'(
16:04:28 <basic> oh, i think i know what inits is for there
16:04:30 * basic thinks
16:06:39 <basic> http://dpaste.com/2HRVG2K
16:06:50 <basic> this is correct for the first two, which isn't special
16:10:11 <basic> oh i killed my ram with that cody :(
16:14:01 <basic> :( gotta go to sleep, but i have to think about this either way
16:14:11 <basic> learning haskell takes a long time, ay?
16:16:58 <basic> gn
16:40:19 <crestfallen> hi I'm still wondering about pure. in the example on line 7 , what does pure do with the (*) .. ie does it need to convert (*) to something before it can operate on the two lists?  https://paste.ee/p/awVqE
16:44:35 <jackdk> what do you mean by "convert"? if you remove the `pure` there, it will fail to typecheck.
16:46:27 <crestfallen> jackdk: I'm trying to figure out why line 3 is written that way:      pure x = [x]
16:47:08 <crestfallen> so the way I read that is ..
16:47:27 <crestfallen> that pure takes a function, say, (*)
16:47:58 <crestfallen> and give us this [(*)]
16:48:18 <crestfallen> so I'm missing something
16:48:32 <crestfallen> gives*
16:48:46 <hpc> that's what it does
16:48:53 <hpc> now look at the thing that's using [(*)]
16:49:01 <crestfallen> [(*)]   ?
16:49:09 <hpc> and consider what other values you could use besides [(*)]
16:49:12 <hpc> what if the list was empty?
16:49:20 <hpc> what if it had two different functions in it?
16:49:31 <hpc> (<*>)
16:50:36 <crestfallen> what if it had two different functions in it?      
16:50:48 <jle`> [(*),(+)]
16:51:22 <jle`> crestfallen: pure x takes x and returns [x]
16:51:29 <jle`> so pure (*) takes (*) and returns [(*)]
16:51:36 <jle`> just like how pure 1 takes 1 and returns [1]
16:51:45 <jle`> it doesn't really convert 1 into anything, all it does is put it in a list
16:52:10 <crestfallen> so <*> is operating inside that initial list which contains the (*)    ie [(*)]     ?
16:52:34 <jle`> yeah, (<*>) is a function that takes two lists, and does stuff with the items in both lists
16:53:08 <crestfallen> so it might look like this   [[1,2,3] <*> (*) <*> [10,20]] or something   ?
16:53:29 <jle`> not sure what "it" means here or what you are trying to give an example of
16:53:45 <hpc> take the ghci line in your paste
16:54:01 <hpc> and experiment with the start of it, where you pass the function(s)
16:54:35 <jle`> crestfallen: (<*>) for lists is defined so that [f,g,h] <*> [x,y,z] = [f x, f y, f z, g x, g y, g z, h x, h y, h z]
16:54:44 <jle`> > [f,g] <*> [x,y]
16:54:48 <lambdabot>  error:
16:54:48 <lambdabot>      Ambiguous occurrence ‘f’
16:54:48 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.f’,
16:54:54 <jle`> > [f,g] <*> [x,y] :: [Expr]
16:54:59 <jle`> oh, who defined f in lambdabot
16:54:59 <lambdabot>  error:
16:54:59 <lambdabot>      Ambiguous occurrence ‘f’
16:54:59 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.f’,
16:55:04 <jle`> @undefine
16:55:04 <lambdabot> Undefined.
16:55:06 <jle`> oh, who defined f in lambdabot
16:55:08 <jle`> > [f,g] <*> [x,y] :: [Expr]
16:55:11 <lambdabot>  [f x,f y,g x,g y]
16:55:20 <crestfallen> that much I understand
16:55:47 <jle`> > [negate] <*> [1,2,3]
16:55:50 <lambdabot>  [-1,-2,-3]
16:55:53 <jle`> > pure negate <*> [1,2,3]
16:55:56 <lambdabot>  [-1,-2,-3]
16:55:59 <jle`> pure negate is just a fancy way of writing [negate]
16:56:09 <crestfallen> ok so the function (*) just sits in the first place with its own <*>   ie..
16:56:32 <jle`> do you understand `pure negate <*> [1,2,3]` ?
16:56:37 <crestfallen> [(*)] <*> [1,2,3] <*> [10,20]
16:56:52 <jle`> yeah, that's what pure (*) <*> [1,2,3] <*> [10,20] turns into
16:57:00 <jle`> because in haskell you can always replace function calls by their definitions
16:57:12 <hpc> the value of pure here is, what if you're not operating on lists
16:57:12 <jle`> and pure x = [x], so you can replace `pure (*)` with `[(*)]`
16:58:07 <jle`> also probably important, you should know how (<*>) associates
16:58:26 <jle`> fs <*> xs <*> ys is associated as (fs <*> xs) <*> ys
16:59:07 <crestfallen> that's interesting . its simply that using <*> each operand needs to be of the same type : [(*)] , [1,2] etc
16:59:36 <jle`> well, both sides of <*> have to have the same 'f' (Applicative instance)
16:59:50 <jle`> but the parameter to f doesn't have to be the same necessarily
17:00:07 <jle`> consider the case of [negate] <*> [1,2,3], where the left hand side is [Int -> Int] and the right hand side is [Int]
17:00:16 <pyan> Is self-application of a monomorphic value even possible?
17:00:23 <jle`> :t id id
17:00:25 <pyan> Errr, of a value of monomorphic type.
17:00:28 <lambdabot> a -> a
17:00:38 <pyan> jle`: Those id's don't have the same monomorphic type.
17:00:40 <jle`> hehe
17:00:51 <jle`> no, \f -> f f doesn't typecheck in haskell
17:01:02 <crestfallen> ok yeah so bottom line is line 3 produces [(*)] .. oh reading those last posts...
17:02:28 <crestfallen> that's like  '  fmap id = id      id on each side has a different type
17:02:46 <jle`> do you mean on both sides of the equal sign?
17:02:49 <crestfallen> yeah
17:04:14 <crestfallen> fmap id    would give    f a -> f a  on the rhs
17:04:36 <jle`> well, the equals sign there doesn't quite mean anything in haskell
17:04:50 <jle`> but yeah it's a generally accepted convention that the things on both sides of an equal sign are meant to be equal
17:04:57 <jle`> as a notational convention
17:05:56 <jle`> when someone says "fmap id = id" as a law, it's not quite something that exists using that syntax in haskell
17:06:09 <crestfallen> well I guess it means that the a is preserved, but its now inside the f :  '  f a  '
17:06:11 <jle`> but they are trying to convey that "fmap id" and "id" should be replaceable with each other within a program
17:06:44 <crestfallen> that last comment of yours I would love to see an example..
17:06:47 <jle`> well, the statement "fmap id = id" is a non-haskell-syntax statement that you should be able to replace "fmap id" with "id" (and vice versa) within a program without changing the meaning
17:06:59 <jle`> that's what the equals sign there means, when people talk about it as a law
17:07:21 <jle`> they don't actually mean to refer to any '=' syntax within haskell, it's more of an informal human-level statement
17:07:47 <jle`> crestfallen: yeah, the law says that if you ever see 'fmap id x' in a program, you can just replace it with 'id x' without changing the meaning
17:08:07 <crestfallen> it means that the a -> a part is preserved, but its in a context now
17:08:11 <jle`> for example if i ever saw someone write "fmap id [1,2,3]", i would say "why are you writing fmap id [1,2,3], don't you know about the functor laws? you can just write 'id [1,2,3]'. which is just [1,2,3]"
17:08:33 <jle`> i might use a different tone though :)
17:08:47 <pyan> No Haskell type is discrete, or even T1, I think, so equality testing is a brutal act of discontinuity, anyway.
17:08:52 <crestfallen> right, the fmap just falls off whenever you see id [1,2,3]
17:09:13 <jle`> crestfallen: well remember that fmap id [1,2,3] is associated as (fmap id) [1,2,3]
17:09:18 <jle`> so it means that (fmap id) is just (id)
17:09:34 <pyan> And rightfully “undefined == undefined” returns neither True nor False.
17:10:32 <jle`> crestfallen: so my point is that, when someone says "blah = blahblah", the implication is yes, blah and blahblah have the same type. because they are meant to be interchangeable with each other
17:11:02 <jle`> i just wanted to give an answer "yes, because..." instead of just "yes" :)
17:11:05 <crestfallen> jle`: if I could extend this idea.. is this like the combinators id flip const    and all that business?
17:11:38 <jle`> things like const id = flip const ?
17:11:48 <jle`> yeah, the = there as i use it has the same meaning
17:11:58 <crestfallen> > fmap id [1,2,3]
17:12:01 <lambdabot>  [1,2,3]
17:12:12 <crestfallen> yeah looks awfully familiar
17:12:37 <crestfallen> > const id 5
17:12:44 <iqubic> :t const id
17:12:44 <lambdabot>  mueval-core: Time limit exceeded
17:12:47 <lambdabot> b -> a -> a
17:13:28 <crestfallen> wait a minute :)
17:13:54 <crestfallen> > const id 5 "t"
17:14:00 <lambdabot>  "t"
17:15:52 <crestfallen> so what I don't see is why these seem to be important combinators :    const id flip        ie. I read little tutorials about them but don't really see how they work in programs
17:16:39 <jle`> their definitions are pretty simple, so "how they work" isn't too tricky, is it?
17:16:47 <jle`> const x y = x, const just ignores the second argument
17:16:55 <jle`> id x = x, it just returns its argument as-is
17:17:14 <crestfallen> yeah but first off, why are they combinators? I mean, whats a combinator?
17:17:54 <crestfallen> const ignores the 2nd arg, is that for say currying?
17:18:00 <jle`> combinator doesn't really mean anything formal, the most general sort of meaning they evoke is that they can be used to build complicated things from simple building blocks
17:18:18 <jle`> in haskell they usually just mean "higher order functions"
17:18:24 <crestfallen> does that tie into SKI calculus ?
17:19:05 <jle`> a lot of times when working with higher order functions in haskell, you only really need to pass in simple functions
17:19:29 <crestfallen> like where would you pass in const say?
17:20:07 <jle`> for example a lot of people use const to replace the result of a Functor value
17:20:11 <jle`> > map (const ()) [1,2,3,4]
17:20:15 <lambdabot>  [(),(),(),()]
17:20:22 <jle`> this is in the standard libraries as "void"
17:20:50 <jle`> or you can use it with, say, zipWith to ignore items in the second list and only use items in the first list
17:20:56 <jle`> > zipWith const [1,2,3] [4,5]
17:21:01 <lambdabot>  [1,2]
17:21:17 <jle`> i don't think there is any "big picture" overall idea that unites all usages of const
17:21:33 <crestfallen> the zipWith example...
17:21:40 <crestfallen> what happened there?
17:21:41 <jle`> it's just that (\x _ -> x) comes up here and there often enough in different places for different usages that it's useful enough to justify giving it a common name
17:21:59 <jle`> well zipWith f [x,y,z] [a,b] = [f x a, f y b]
17:22:11 <jle`> it just zips the values in two lists together, using a combining function
17:22:26 <jle`> but if you only care about the items in the first list...then you can do something like zipWith (\x _ -> x) [1,2,3] [4,5]
17:22:41 <jle`> it's not like this is a fundamental deep and powerful property of const
17:22:49 <jle`> it's just that 'const' takes less characters than (\x _ -> x)
17:22:53 <jle`> and is probably more readable :)
17:23:42 <crestfallen> > zipWith const [1,2,3,4] [4,5] 
17:23:46 <lambdabot>  [1,2]
17:24:17 <jle`> ah yeah also remember that zip drops the items from the longer list
17:24:21 <jle`> > zip [1,2,3,4] [4,5]
17:24:25 <lambdabot>  [(1,4),(2,5)]
17:24:42 <crestfallen> ok yeah
17:24:50 <jle`> so this is not some deep mystical property of const
17:24:58 <jle`> if you wanted to do this you might just write zipWith (\x _ -> x)
17:25:11 <jle`> and if you wanted to replace all the items in a list with () you might just do map (\_ -> ()) [1,2,3]
17:25:15 <crestfallen> so even though [4,5] is dropped, the first list reflects the number of elements
17:25:34 <crestfallen> of the lesser list
17:25:45 <jle`> it's just that when you work with higher order functions enough times, similar functions pop up here and there and it's common enough that it's useful to give them names for readability
17:26:24 <crestfallen> thanks jle` kindly. are my last 2 posts correct 
17:26:24 <crestfallen> ?
17:26:37 <jle`> the values 4 and 5 are dropped
17:26:44 <jle`> but the shape of the list (the length) persists
17:27:04 <crestfallen> so zip chooses the first 2 elements of [1,2,3,4] ?
17:27:26 <jle`> yeah, it matches the elements until it runs out on either list
17:27:29 <jle`> @src zip
17:27:30 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
17:27:30 <lambdabot> zip _      _      = []
17:28:24 <crestfallen> actually sometimes I find elemental functions like this hard to get.
17:28:55 <crestfallen> appreciate it ! jle`
17:29:13 <boj> > zipWith (+) [1,2,3,4] [9,8]
17:29:15 <lambdabot>  [10,10]
17:29:24 <jle`> no problem :)
17:29:49 <jle`> i don't mean to give the definition to show that it is simple/elementary, but rather to give you the tools to be able to work through the conclusion yourself :)
17:30:15 <crestfallen> no I wasn't referring to the definition you gave
17:30:55 <crestfallen> but in the case of using zipWith const   ...
17:30:57 <crestfallen> still ..
17:31:05 <crestfallen> if you drop the second list
17:31:56 <crestfallen> you are ' matching the elements '   ,  really just the first two elements of the first list, given the number of elements in the 2nd list? what good is that?
17:32:21 <crestfallen> > zipWith const [1,2,3,4] [4,5]
17:32:26 <lambdabot>  [1,2]
17:32:34 <jle`> small random things like this come up all the time in everyday program
17:32:51 <jle`> so this question is like "if you add two to 56, you get 58 ... what good is that?"
17:32:57 <jle`> *everyday programming
17:33:04 <crestfallen> :) !!
17:33:21 <jle`> it's not like "what good is adding 3 to a number?" has a real answer
17:33:21 <Axman6> "I need these lists to be the same length because I'm making an HTML table, and I don't want to use length because it's unnecessarilly strict"
17:33:32 <jle`> it's just ... sometimes you need to add something, and sometimes it's just three
17:33:38 <crestfallen>  no but it is not zipping, those elements are just at index 0,1 of the first list
17:34:04 <jle`> yeah, it can be useful for limiting your lists to a given length
17:34:13 <Axman6> \row ->  zipWith const row headers -- will ensure the row is the same length as the list of headers, or less
17:34:26 <jle`> so if i had headers = ["Color", "Length", "Weight"]
17:34:38 <jle`> then zipWith const myRow headers will limit myRow to the number of items that headers has
17:35:29 <crestfallen> ok good example
17:35:41 <crestfallen> thanks .. see! one needs to know this !
17:40:01 <srid> are things like free(r) monads and (now) polysemy still in 'research' phrase ... or are people already using them (instead of mtl) in real world projects?
18:00:43 <oats> so I discovered and ended up using this python module at work today: https://docs.python.org/3.1/library/textwrap.html
18:00:55 <oats> and it got me wondering what an idiomatic haskell equivalent could look like
18:01:26 <oats> basically what it is is a module for wrapping long strings in a really flexible way
18:01:51 <oats> you instantiate an object with the settings you want for your line-wrapping, like indendation and rules for what to do with whitespace and such
18:02:05 <oats> then call a method on the object with the string you actually want to wrap
18:02:24 <oats> kinda yucky, it feels like python encourages overuse of classes
18:03:11 <nisstyre> oats: you don't need python style classes to do that
18:03:24 <oats> anyways, I think functions that take a huge number of "configuration" arguments or a single large "config" value don't feel very haskelly at all
18:03:45 <oats> would a more haskelly approach be something like break up all this functionality into multiple functions?
18:03:59 <nisstyre> oats: define a type for it that holds the "settings" and the function to convert with them
18:04:49 <nisstyre> then have a generic function to do the converting or whatever that takes that type as an argument, along with the string
18:05:38 <nisstyre> use data-default where necessary to avoid boilerplate
18:06:01 <oats> nisstyre: so a big ol' WrappingConfig data type wouldn't feel out-of-place?
18:06:17 <nisstyre> if you need to configure stuff, you need to configure it.
18:06:21 <nisstyre> how else are you going to handle that?
18:06:32 <oats> ¯\_(ツ)_/¯
18:06:37 <nisstyre> you can provide defaults but you can't automagically generate it
18:07:08 <oats> I went off on a little mental tangent trying to think of what a "function builder" pattern might look like, à la OOP
18:07:14 <oats> despite my distate for OOP
18:07:15 <nisstyre> you can provide a default configuration object that you override
18:07:16 <nisstyre> if needed
18:07:22 <nisstyre> that seems to be how most libraries in Haskell do this
18:07:30 <oats> oh, that makes loads of senes
18:07:36 <oats> s/senes/sense
18:07:49 <nisstyre> oats: I find that most people who hate OOP confuse it with what I call "class oriented programming"
18:07:53 <nisstyre> they're not really the same thing at all
18:08:00 <nisstyre> for example Erlang is object oriented arguably
18:08:06 <nisstyre> even more than Java
18:08:09 <nisstyre> but it has no classes
18:08:15 <oats> nisstyre: hmm, could be. Do you consider rust to be object-oriented?
18:08:32 <nisstyre> I've never used it but from what I can tell it does not encourage an OOP style of programming
18:08:45 <oats> I haven't used erlang
18:08:52 <nisstyre> you should check it out
18:09:07 <oats> why do you say it's object-oriented but not class-oriented?
18:09:25 <nisstyre> here's a good overview and contrast of Haskell and Erlang https://www.infoq.com/interviews/armstrong-peyton-jones-erlang-haskell/
18:09:47 <nisstyre> oats: because it doesn't have classes, as you would think of them from Java/Python/C++/etc
18:09:55 <nisstyre> but it has all the necessary ingredients for OOP
18:10:03 <nisstyre> encapsulation, message passing, etc
18:10:28 <oats> ooh, is it actor-model?
18:10:35 <nisstyre> Java arguably has encapsulation, but does a crappy job of message passing
18:10:45 <nisstyre> Python has neither really, but it has classes, so YOLO or w/e
18:11:01 <nisstyre> oats: yeah, but arguably OOP is a subset of the actor model
18:11:04 <nisstyre> or at least closely related
18:11:22 <oats> I'm very intrigued by actor-model languages
18:11:35 <oats> nisstyre: I think it's probably inheritance that leaves a bad taste in my mouth
18:11:55 <nisstyre> oats: well, that can be done without classes too
18:11:59 <oats> Pony is a really interesting object-oriented actor model language, and it has classes but no inheritance
18:12:03 <nisstyre> for example Racket has subtyping
18:12:10 <nisstyre> but you don't need classes for that
18:12:24 <nisstyre> oats: it has subtyping
18:12:38 <nisstyre> nominal and structural subtyping in fact
18:14:16 <nisstyre> https://tutorial.ponylang.io/types/traits-and-interfaces.html
18:15:10 <nisstyre> arguably a nicer model than inheritance, but it gives you similar benefits
18:15:39 <nisstyre> in that you can have a broad category of types like Fruit, and then particular instances like Watermelon, Pear, etc
18:15:59 <oats> so could it be said that haskell typeclasses enable a form of nominal subtyping?
18:16:11 <nisstyre> No, I don't think I would say that
18:16:30 <nisstyre> subtyping kinda breaks type inference in ways that Haskell can't handle afaik
18:17:09 <nisstyre> how do you decide if something is a Watermelon or a Pear without annotations?
18:17:15 <nisstyre> and how do you infer that it's a Fruit
18:19:16 <nisstyre> I mean you can argue that type classes are kinda similar to traits, but they don't give you subtypes
18:22:11 <oats> ah, gotcha
18:54:28 * hackage stylist 1.0.0.0 - Apply CSS styles to a document tree.  https://hackage.haskell.org/package/stylist-1.0.0.0 (alcinnz)
19:05:57 * hackage xml-conduit-stylist 1.0.0.0 - Bridge between xml-conduit/html-conduit and stylist  https://hackage.haskell.org/package/xml-conduit-stylist-1.0.0.0 (alcinnz)
19:09:28 * hackage Cabal 3.0.0.0 - A framework for packaging Haskell software  https://hackage.haskell.org/package/Cabal-3.0.0.0 (MikhailGlushenkov)
19:15:02 <infinisil> Oh, Cabal 3.0.0.0?
19:16:05 <infinisil> "multiple public libraries" :o
19:16:35 <infinisil> "Add --enable-executable-static flag for building fully static executables" :o
19:55:00 <Axman6> Which language extension do I need to use to be able to make a in scope inside f when I have type prop_foo :: forall a. (Arbitrary a) => Spec; prop_foo = prop "Something" $ \(x :: a) -> somePropertyOf a
19:55:45 <Axman6> trying to make something which allows me to write prop_foo @MyType, but I'm getting Could not deduce (Arbitrary a0) from the context: (Arbitrary a)
19:55:50 <MarcelineVQ> ScopedTypeVariables
19:55:54 <Axman6> I have scoped type variables
19:56:01 <MarcelineVQ> err, hmm
19:56:03 <Axman6> ha, beat me
19:56:17 <Axman6> oh it might be something else...
19:56:51 <Axman6> I was missing a do, but that didn't fix it
19:58:04 <MarcelineVQ> what's the type of "somePropertyOf a" and prop?
19:58:21 <Axman6> a -> Spec I think
20:04:04 <MarcelineVQ> might need AllowAmbiguousTypes if a isn't going to be mentioned to the right of => in prop_foo's type, not sure exactly
20:05:12 <Axman6> argh, it even says that in the error, just not quite where I was expecting
20:05:57 * hackage stripe-core 2.5.0 - Stripe API for Haskell - Pure Core  https://hackage.haskell.org/package/stripe-core-2.5.0 (DavidJohnson)
20:06:58 * hackage stripe-tests 2.5.0, stripe-http-client 2.5.0, stripe-haskell 2.5.0 (DavidJohnson)
20:13:14 <natechan> What is Curried from the kan-extensions package?  I see the comment "by the uniqueness of adjoints, when f is a left adjoint, Curried f ~ Rift f", but I don't understand it.  Is Rift here Rift from the profunctors package or is Rift the Rift that was in earlier versions of the kan-extensions package removed in https://github.com/ekmett/kan-extensions/commit/e1293e7f95639681017f366caba9e0170b655778 ?  It
20:13:16 <natechan> seems like it can't be the former since that Rift deals with * -> * -> * rather than * -> *.
20:14:10 <ashratempel>  hi there, i wrote a hex string to base64 converter. i would love to hear your opinions 
20:14:17 <ashratempel>  can i share the code?
20:14:29 <ashratempel>  i posted it on stack exchange's code review
20:18:24 <dmwit> It's certainly allowed/on-topic to share your code here, too. Please give us a link rather than pasting directly into the channel, of course.
20:19:01 <ashratempel> cool! here it is: https://codereview.stackexchange.com/questions/225804/hex-string-to-base64-in-haskell
20:19:30 <ashratempel> i'm sure there are way more efficient ways to do this
20:38:37 <hololeap> ashratempel: first thing that catches my eye is that your variable `base64` would be better suited as an IntMap instead of a list, for faster lookups
20:41:43 <ashratempel> hololeap: thanks! you're right
20:47:55 <jle`> ashratempel, hololeap: if you have a contiguous list and you look up by index, you might as well use Vector too
20:48:42 <jle`> also it's not too well known, but Seq is also good for fast indexing
20:54:04 <hololeap> jle`: the only thing is that some of these online challenges limit what libraries are available, which is why i chose something from the core libraries
20:55:04 <jle`> Seq is from the same package that IntMap is from :)
20:55:21 <jle`> but yeah, that's a good consideration
20:55:40 <ashratempel> i now using an intmap for the base64 dictionary
20:56:38 <Axman6> jle`: A function is also good for static indexing =)
20:59:07 <jle`> well, that depends on how you write your function :3
20:59:41 <jle`> if it is convert i = (Seq.fromList ['a'..'z']) `Seq.index` i, that isn't too bad
20:59:57 <dmj`> IntMap is underrated
21:02:53 <Axman6> indeed
21:05:01 <Axman6> I watched a good talk about its implementation a while ago, can't remember who it was though
21:06:15 <koz_> I have something like 'either (g . f) (h . f)'. Can I somehow avoid duplicating 'f' there?
21:06:21 <koz_> Also hi jle`!
21:06:32 <koz_> Nice blog post recently - that's actually really cool.
21:06:54 <Axman6> jle` always has cool blog posts (and also has a patreon if you really like them =)
21:07:02 <koz_> Axman6: I am aware of both of these facts. :P
21:07:05 <jle`> koz_: hi, and thanks :D
21:07:26 <jle`> koz_: if f is monomorphic you can do either g h . over both f, maybe, but not sure if that's any cleaner
21:07:41 <koz_> over both is lens stuff right?
21:07:44 <koz_> :t over both
21:07:46 <lambdabot> Data.Bitraversable.Bitraversable r => (a -> b) -> r a a -> r b b
21:07:59 <koz_> Yeah, that's not really any cleaner, I agree.
21:08:20 <jle`> yea both just from an ad-hoc typeclass that abstracts over these kinds of things
21:08:36 <koz_> :t both
21:08:39 <lambdabot> (Data.Bitraversable.Bitraversable r, Applicative f) => (a -> f b) -> r a a -> f (r b b)
21:09:03 <jle`> oh huh i guess i'm wrong
21:09:08 <jle`> i must have been thinking about 'Each'
21:09:18 <koz_> Truthfully I don't think I can even do that, because I don't think f is monomorphic - it produces two _different_ types of Finite.
21:09:23 <jle`> over both is just basically \f -> bimap f f
21:09:29 <koz_> (Finite n for one, Finite m for the other)
21:09:46 <jle`> ah yeah, that's what my disclaimer was about
21:10:07 <koz_> Oh well, it's not that repetitive I guess.
21:10:18 <jle`> well, if they are different functions, then i would suggest maybe you don't even want to de-duplicate them
21:10:22 <jle`> since they do different things
21:10:26 <koz_> Typeclass method.
21:10:38 <koz_> So it's got the same name, but in truth it _is_ two different functions.
21:10:50 <jle`> yeah, and deduplicating it might obscure that fact
21:11:09 <jle`> well, you "pull out" the composition by doing `either g h . bimap f f`
21:11:25 <jle`> it's kind of a law that `either (a . b) (c . d)` == `either a c . bimap b d
21:11:45 <koz_> Yeah, that makes sense.
21:11:51 <jle`> but yeah, not sure if it's any cleaner. usually you'd use the "law" to go the other way
21:12:01 <jle`> (to simplify either a c . bimap b d to be either (a . b) (c . d))
21:12:05 <koz_> Yeah, you 'crush together' applications to one or the other side.
21:12:18 <koz_> Kinda like the whole fmap f . fmap g == fmap (f . g) thing.
21:12:27 <jle`> yeah, exactly
21:13:17 <koz_> I guess that's basically the same idea, if you squint.
21:13:24 <jle`> it's "basically" foldMap (f . g) == foldMap f . fmap g
21:13:36 <koz_> Hmm, I never thought about it that way.
21:13:50 <koz_> (well, insofar as foldMap follows any laws at all)
21:14:09 <koz_> (you could re-spell it using traverse and Const I guess)
21:18:51 <koz_> Also, am I missing something here? I have a constraint like (k ~ (n * m)), but GHC complains about expecting kind '* -> Nat -> Nat', but n has kind 'Nat'. I'm trying to use the * from GHC.TypeNats here.
21:19:13 <jle`> you might need to turn on/off -XNoTypeIsStar
21:19:21 <jle`> because it might be interpreting n as a function that takes * and m
21:19:31 <koz_> Is that on by default or something?
21:19:53 <jle`> yeah, the deafult is -XTypeIsStar, so you need to -XNoTypeIsStar to disable it
21:19:58 <jle`> alternatively i think you can just turn on -XTypeInType
21:20:09 <jle`> hm, maybe you can't do that second one
21:20:10 <koz_> I have TypeInType on.
21:20:37 <jle`> ah yeah, probably need -XNoTypeIsStar then. i remember needing to turn it on for vector-sized
21:20:53 <koz_> Can I do that using {-# LANGUAGE NoTypeIsStar #-}?
21:21:42 <jle`> yeah
21:22:05 <koz_> Apparently not a supported extension according to GHC. I'm on 8.6.
21:22:06 <jle`> haskell parsing history is...unfortunate
21:22:50 <jle`> oh, it's -XNoStarIsType heh, sorry
21:23:05 <koz_> Yep, that did it.
21:23:24 <koz_> The number of extensions I'm having to enable with scary names is scary.
21:23:48 <koz_> UndecidableInstances especially.
21:24:06 <koz_> Maybe that's me wearing my computer scientist hat, but when I see 'undecidable' I go 'eek'.
21:24:19 <jle`> yeah that's a particularly scary-sounding one
21:24:38 <jle`> i also think AllowAmbiguousTypes is also disproportionately scary-sounding for what it actually does 
21:25:00 <jle`> "why would i want my types to be ambiguous? i want type safety!"
21:25:16 <koz_> AllowAmbiguousTypes just kicks certain checks to runtime right?
21:25:29 <jle`> that's DeferTypeErrors i think
21:25:33 <koz_> Oh, yeah.
21:25:38 <koz_> I forget what it does then.
21:25:39 <jle`> AllowAmbiguousTypes just allows functions that require explicit type annotations to run
21:25:53 <jle`> since some type variables are not possible to be type-inference'd
21:25:54 <koz_> Ah, yeah.
21:26:03 <jle`> s/to run/to be defined
21:26:08 <koz_> Well, there are limits to type inference. I think GHC even struggles with runST.
21:26:12 <jle`> er, s/to run/to run to be defined
21:26:26 <koz_> (although I think last year or so SPJ and some friends wrote a paper on a typechecker which can type runST properly)
21:26:35 <koz_> :t curry
21:26:37 <lambdabot> ((a, b) -> c) -> a -> b -> c
21:27:04 <jle`> yeah the problem with functions that require AllowAmbiguousTypes is that the type variable doesn't appear anywhere in the type of the arguments or result of the function, so like what can you do
21:27:04 <koz_> :t uncurry
21:27:07 <lambdabot> (a -> b -> c) -> (a, b) -> c
21:27:12 <jle`> like myFunction :: forall a. Int
21:27:17 <jle`> er, myInt
21:27:20 <hololeap> ashratempel: i think you should also consider using Data.Bits and write out the part that converts to/from decimal
21:27:26 <koz_> Yeah, you're basically saying 'read my mind'.
21:28:32 <koz_> But that can be fixed by being honest about your type variables.
21:28:47 <koz_> The runST stuff is a bit less easy.
21:29:55 <ashratempel> hololeap: thanks! im going to take a look at the docs
21:37:10 <koz_> http://hackage.haskell.org/package/finite-typelits-0.1.4.2/docs/Data-Finite.html#v:separateProduct <-- what it does mean by 'fst-biased' here?
21:39:55 <MarcelineVQ> combineProduct has a fst-biased result, the source code for it may show what that means
21:43:07 <Axman6> I only found AlowAmbigupusTypes was a thing today, it's definitely necessary in the post-Proxy-as-the-way-to-specify-a-type-without-having-the-type world
21:43:29 <koz_> Axman6: That's a very long-winded world. Did Java win or something?
21:43:41 <koz_> MarcelineVQ: OK, thanks. I keep forgetting 'check the sauce code' is a thing I can just do.
21:58:03 <crestfallen> hi one more thing about pure. we can't do:
21:58:44 <crestfallen> > pure ((*),(+)) <*> [1,2] <*> [10,20]
21:58:46 <lambdabot>  error:
21:58:46 <lambdabot>      • Couldn't match type ‘(Integer -> Integer -> Integer,
21:58:46 <lambdabot>                              Integer -> Integer -> Integer)’
21:59:04 <crestfallen> so pure only takes one function:
21:59:18 <jle`> well, you can give pure a tuple, but that gives you [((*),(+))]
21:59:49 <crestfallen> but that won't work in ghci right?
21:59:55 <crestfallen> as above
22:02:13 <crestfallen> so how to apply pure to 2 or more functions, since this is redundant I guess:
22:02:54 <crestfallen> > pure [(*),(+)] <*> [1,2] <*> [10,20]
22:02:56 <lambdabot>  error:
22:02:56 <lambdabot>      • Couldn't match type ‘[Integer -> Integer -> Integer]’
22:02:56 <lambdabot>                       with ‘Integer -> Integer -> b’
22:03:14 <jle`> > [(*),(+)] <*> [1,2] <*> [10,20]
22:03:19 <lambdabot>  [10,20,20,40,11,21,12,22]
22:03:29 <jle`> remember pure is only a shortcut to write a single-item list
22:03:30 <crestfallen> so if you have multiple functions, they would only logical be in list notation
22:03:36 <jle`> so if you want a two-item list, you would just use a two-item list
22:03:42 <jle`> you don't even need pure
22:03:54 <jle`> you don't need pure in the single-item list in the first place
22:04:53 <crestfallen> what if two or more functions were passed in from multiple parts of the program, and not in a list yet?
22:05:05 <crestfallen> but we wanted to purify them
22:05:16 <rotaerk> purify?
22:06:16 <crestfallen> or would you always pass in functions in a list, singleton or not.?
22:07:12 <jle`> crestfallen: you never need pure, if you have a function you could just write [f] <*> xs <*> ys
22:07:18 <jle`> or you can write [f,g] <*> xs <*> ys
22:07:32 <jle`> you can always just put items in a list with list literal syntax
22:07:41 <jle`> the bracket-comma syntax
22:07:47 <jle`> [items,in,my,list]
22:08:02 <jle`> if you have two or more functions passed from multiple parts of the program, call them f and g, you can just type in [f,g] :)
22:08:14 <rotaerk> > pure (*) <*> Just 2 <*> Just 3
22:08:17 <lambdabot>  Just 6
22:08:19 <rotaerk> > Just (*) <*> Just 2 <*> Just 3
22:08:22 <lambdabot>  Just 6
22:08:33 <jle`> if you have a tuple of functions, you can pattern match on the tuple \(f,g) -> [f,y] <*> xs <*> ys
22:08:55 <rotaerk> pure is an abstraction; when you know the specific instance you're dealing with, you can just construct your values using that specific type's mechanisms
22:09:15 <crestfallen> ok well enough, pure is to create a singleton list of one function
22:09:36 <crestfallen> jle`, still working on that last post
22:10:33 <crestfallen> thanks ALL
22:11:16 <crestfallen> jle`, there's not a typo in your last post?
22:12:26 <jle`> which post?
22:12:36 <jle`> if you're talking about a blog post, then it would be unlikely that there are no typos heh
22:12:42 <crestfallen> the pattern match above
22:12:57 <jle`> ah yeah, it should be [f,g] <*> xs <*> ys probably :)
22:13:29 <crestfallen> ok thanks kindly
22:14:35 <crestfallen> that example answers my question and is interesting!
22:16:54 <MarcelineVQ> specifically "pure :: Applicative f => a -> f a" creates a singleton list when f is a list. when f is Maybe, pure x creates Just x, which is what rotaerk is conveying, that f can be many things and what that thing is matters to pure
22:24:28 * hackage githud 3.0.1 - More efficient replacement to the great git-radar  https://hackage.haskell.org/package/githud-3.0.1 (gbataille)
22:24:40 <crestfallen> rotaerk, MarcelineVQ copy that, thank you
22:44:07 <dminuoso> jle`: It just occured to me, that the theme of sequencing in Monad can also be observed in the nature of Compose, which is a sort of "first this, then that" if you squint a bit.
22:45:33 <jle`> ah yeah, i've started associating characteristics of monad/applicative/etc. in terms of characteristics of their defining tensor
22:45:41 <jle`> Compose is the thing that imposes the "sequentiality"
22:45:57 <jle`> before we even think about monad :O
22:46:04 <dminuoso> Indeed!
22:47:02 <dminuoso> jle`: My next goal is to understand the deeper nature of Day - I think you once said that there's a way to look at it and see it as a true convolution.
22:47:23 <jle`> even `Compose Foo Bar` imposes sequentiality, where the two arguments are different
22:47:23 <dminuoso> You wouldn't happen to recall where in the logs I would have to dig?
22:47:35 <jle`> it must have been a long time ago heh
22:47:48 <jle`> it's also buried somewhere in my twitter :) some people replied to me with a good description
22:47:54 <dminuoso> jle`: I suppose the requirement that both types be equal is just so that you can sensibly combine then.
22:48:03 <jle`> but i don't think that relating it to the functional analysis convolution was really too insightful
22:48:15 <dminuoso> Mmm.
22:48:23 <jle`> it seemed more like a notational trick to me
22:48:25 <jle`> but ymmv
22:48:45 <jle`> dminuoso: yeah, i'm saying that even without ever thinking about Monad and Compose m m, Compose f g already carries a sequential nature
22:48:55 <jle`> in a sense that is more general than Monad itself
22:48:56 <dminuoso> Right.
22:50:34 <dminuoso> jle`: So we talked about other tensors a while back, and I just realized that the monoid given by picking Product as its tensor essentially gives me a plain Monoid inside an arbitrary functor.
22:50:42 <dminuoso> It seemed quite blant.
22:51:04 <dminuoso> Even Sum seemed not as interesting.
22:53:00 <jle`> well, in hask, you get a "higher-ranked monoid", which is kind of interesting from a practical point of view
22:53:09 <jle`> the appending has to be parametrically polymorphic over the type parameter
22:53:37 <jle`> so you can't do anything like instance Plus Maybe where (<!>) = mappend
22:53:46 <jle`> since that requires the Maybe value to be Monoid
22:55:17 <jle`> Sum though is kind of weird to me, i have read mentions of it here and there but never any detailed breakdown
22:55:43 <jle`> the "free monoid" over it is some sort of Compose ((,) Natural)
22:55:58 <jle`> so it's like an inverted Writer
22:56:22 <jle`> or like the Traced comonad
22:56:56 <jle`> hm not Traced, Env
23:03:03 <dminuoso> jle`: Traced Ive never able to get a hold on, heh
23:04:03 <jle`> it's "just" Reader :)
23:04:21 <jle`> type Traced m a = m -> a
23:11:09 <jle`> dminuoso: the free monoid on Sum sort of feels like a single 'f a' located at some single "point" on a stream. it's either L x, or R (L x), or R (R (L x)), etc.
23:11:37 <jle`> but also one interesting tensor i looked into was These1, from the these library
23:12:01 <jle`> dminuoso: the free monoid with These1 ends up being something kind of surprising
23:12:13 <jle`> but i'll hold back the spoilers if you want to find out yourself :)
23:12:17 <dminuoso> jle`: Dont spoil the fun then, Ill take a peek at it. :)
23:12:35 <jle`> i don't know exactly what their associated typeclasses/abstractions would look like
