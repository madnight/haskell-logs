00:01:22 <c_wraith> Yeah, Haskell is not a small language
00:01:38 <c_wraith> It's not big like C++, but it has a lot of redundancies.
00:05:08 <c_wraith> even without enabling extensions... guards and if/then/else both are sugar for pattern matching Bool values.  list comprehensions and do notation are sugar for a couple higher-order functions.  and so on.
00:08:38 <mycroftiv> yeah, im getting most of that straight now. im actually just trying to learn haskell 98 for now, once i feel fluent in that base ill learn more about all the fancy ghc extensions
00:09:31 <c_wraith> It's ok to accept a few extra extensions when you run into them.  FlexibleContexts and FlexibleInstances are completely harmless relaxations of a couple super-conservative restrictions in Haskell98, for instance.
00:09:57 <c_wraith> But definitely don't worry about them until you run into them.
00:10:31 <maerwald> IMO, don't bother with language features, look at problems. If it so happens you are stuck with a problem, then there is a chance a GHC extension can help you. In that case ask here
00:11:05 <c_wraith> also, if the compiler asks you to turn on OverlappingInstances, abort immediately.  That's not the direction you want to go. :)
00:11:09 <maerwald> you'll now when something feels clunky, weird etc. If not, then just carry on :)
00:11:19 <mxf> Hey *, how do I build ghc with DWARF symbols? I tried `hadrian/build.sh "stage1.*.ghc.*.opts += -g"` but that errors out with: http://sprunge.us/YXVgTy (previously built it with no opts)
00:13:58 <mycroftiv> thanks for all the tips, wish i had started learning haskell back in 2005, but better late than never!
00:14:25 <c_wraith> in all honesty, there are advantages to starting later.  There are a lot more resources now.
00:16:00 <mycroftiv> yeah but also way more to learn and a lot more interedependent complexity as the ecosystem has grown. to be honest im mostly using HUGS in plan 9 with GHC in debian as a backup. i find contemorary 'software ecosystems' in general to be so complicated
00:17:12 <mycroftiv> if i can just grab some code and run it and not have to manage any dependencies whatsoever, im very happy
00:22:34 <ski> mycroftiv : "i thought when typed addthis 2 3 and then it went to addthis a b =  that it had 'matched the pattern' of my input" -- yes. however, one might argue that this is a trivial sense of pattern-matching, as opposed to actually matching on some data constructor(s)
00:26:08 <dminuoso> 09:25:10     c_wraith | [06:47:03] mycroftiv: Ah, that's true.  a function declared with syntactic arguments is (except for some details about how ghc optimizes) equivalent to declaring a value bound to a lambda.
00:26:12 <dminuoso> Only up to strictness.
00:26:30 <dminuoso> If those syntactic arguments contain pattern matches, then they are subtly different.
00:26:42 <dminuoso> (WHNF blabalbla)
00:27:15 <dminuoso> And that's not an optimization topic.
00:27:47 <dminuoso> Oh no. I misread that.
00:27:50 <dminuoso> You are right, Im wrong.
00:31:05 <ski> > let !_ = (\() () -> ()) undefined in ()
00:31:08 <lambdabot>  ()
00:31:08 <ski> > let !_ = (\() -> \() -> ()) undefined in ()
00:31:11 <lambdabot>  *Exception: Prelude.undefined
00:31:12 <ski> > let !_ = f undefined where f () () = () in ()
00:31:15 <lambdabot>  ()
00:31:18 <ski> > let !_ = f undefined where f () = \() -> () in ()
00:31:20 <lambdabot>  *Exception: Prelude.undefined
00:31:59 <dminuoso> ski: Right thats what I was getting at, but I mixed up two notions. If you merely compare `f a b c = ...` with `f = \a b c -> ...` then there's little difference between them (ignoring things like MMR)
00:32:20 <dminuoso> It's when you start comparing `f a b c = ...` with `f = \a -> \b -> \c -> ...` that things get interesting
00:32:55 <dminuoso> (Or equivalently, `\a b c -> ...` with `\a -> \b -> \c -> ...`)
00:33:08 <ski> so, perhaps one could argue that this is really about `\<pat 0> <pat 1> -> <expr>' vs. `\<pat 0> -> \<pat 1> -> <expr>'
00:33:15 <dminuoso> ski: Yes
00:33:32 <dminuoso> ski: At least if pat 0 is refutable
00:33:45 <ski> seeing as `f <pat 0> <pat 1> = <expr>' would be equivalent to `f = \<pat 0> <pat 1> -> <expr>' (assuming no additional definition equations for `f')
00:33:56 <dminuoso> Right
00:34:51 <ski> i suppose one could also compare `f <pat 0> <pat 1> = <expr>' vs. `f <pat 0> = g where g <pat 1> = <expr>', if one wants to express it in a lambda-less form
00:35:50 <ski> > let !_ = f undefined where f () = g where g () = () in ()
00:35:53 <lambdabot>  *Exception: Prelude.undefined
00:57:51 <dminuoso> ski: Im still annoyed that you showed to me, how identity is not perfectly respected in some monad instances. :(
00:58:05 <dminuoso> I had this imaginary palace of mathematical beauty.
00:58:32 <dminuoso> ski: By the way, do you know whether there's a semigroup equivalent of a monoid in a category?
00:59:57 <dminuoso> That is, is it enough to assume a semigroupoidial category as one equipped with a bifunctor that is assoc up to natural iso?
02:49:38 <hexagoxel> can anyone decode this cabal error message? "[__3] rejecting: clock-0.8, clock-0.7.2, clock-0.7.1.1, clock-0.7.1 (conflict: requires ViewPatterns)"
02:49:49 <phadej> rm -rf dist-newstyle
02:49:58 <phadej> and try again
02:50:07 <dminuoso> phadej: Why would that help?
02:50:19 <phadej> caches aren't validated
02:50:25 <phadej> properly
02:50:52 <hexagoxel> thanks.
02:51:00 <dminuoso> Interesting.
02:51:01 <hexagoxel> (intuitive error message as usual :D)
02:56:43 * hackage hakyll 4.13.0.0 - A static website compiler library  https://hackage.haskell.org/package/hakyll-4.13.0.0 (JasperVanDerJeugt)
02:58:34 <nil> is there a point to using liftM instead of fmap in new Haskell code? as i understand it, the reason for its existence is historical, from a time where Monad wasn't a subclass of Functor
02:59:40 <dminuoso> nil: Not really
02:59:50 <dminuoso> nil: It could be used if you want to really emphasize that its lifted into a monad.
02:59:50 <nil> (the same question applies to ap and (<*>) i suppose)
03:00:01 <nil> ok
03:00:21 <dminuoso> nil: and there's one other use case of liftM:
03:00:48 <nil> when you need to guarantee the arguments are monadic?
03:01:03 <dminuoso> nil: writing boilerplate implementations for functor/applicative
03:01:12 <dminuoso> nil: say you just implement Monad, and then Functor/Applicative in terms of Monad
03:01:17 <dminuoso> instance Functor where fmap = liftM
03:01:24 <dminuoso> instance Functor T where fmap = liftM
03:01:35 <nil> ah yes
03:01:44 <dminuoso> (and same for ap)
03:01:56 <dminuoso> 12:00:27          nil | when you need to guarantee the arguments are monadic?
03:02:07 <dminuoso> nil: That wouldnt be necessary. You can assume coherence.
03:02:20 <dminuoso> nil: That is, if an instance Monad exists, you can safely assume that fmap = liftM
03:02:33 <nil> sure
03:03:06 <dminuoso> nil: A more interesting discussion would be pure vs return.
03:03:32 <dminuoso> Some people like to use pure only if they want to empasize they are using the Applicative instance, I use pure exlusively because its less to type, and doesn't sound as confusing as return.
03:04:14 <nil> hmm
03:05:01 <dminuoso> ski: I remember you showed me an old paper, that explained why adding abstract langauge features is better than sticking to assembly (that's the shortest way I could put it). Do you recall which paper that was?
03:05:42 <dminuoso> It was some relatively short paper, exclusively behind academic paywalls, and it used various examples illustrating how constraining you with features in abstraction layers allows for better code reasoning
03:09:23 <jusss> where I can find the definitions about Reader State and Writer?
03:09:35 <dminuoso> jusss: Use Hoogle
03:09:46 <Rembane> jusss: Like this? http://adit.io/posts/2013-06-10-three-useful-monads.html
03:10:24 <Rembane> jusss: A search for "reader state writer monad" in Duckduckgo gives a quite good first page of search results. 
03:12:21 <dminuoso> This has to be the first time of this year that someone uses "duckduckgo" instead of google in IRC. :)
03:12:27 <dminuoso> Rembane: +1
03:12:28 <nil> if you just want the definitions, just use hoogle
03:12:32 <nil> @hoogle Reader
03:12:32 <lambdabot> Data.Text.Lazy.Read type Reader a = IReader Text a
03:12:32 <lambdabot> Data.Text.Read type Reader a = IReader Text a
03:12:32 <lambdabot> module Control.Monad.Trans.Reader
03:12:35 <jusss> Rembane: dminuoso I lack of comprehension...
03:12:45 <dminuoso> jusss: https://hoogle.haskell.org/?hoogle=Reader
03:13:13 <dminuoso> jusss: Its like google. You just type an identifier, and it will search through stackage (by default) for all packages that export said identifier. You can also search by type.
03:14:16 <Rembane> dminuoso: I do things that nobody else does. :D
03:14:42 <Rembane> jusss: What do you not comprehend? We have quite some moving parts here.
03:15:38 <dminuoso> Rembane: Wow that article "three useful monads" seems incredibly bad
03:16:02 <Rembane> dminuoso: :D
03:16:04 <dminuoso> Perfect example of monad tutorial fallacy. Just look at these pictures.
03:16:21 <dminuoso> Writer is a pencil, reader is an egg and state is a book?
03:17:48 <jgt> dminuoso: â€¦so which one is the donkey?
03:17:48 <Rembane> dminuoso: I like the pictures, gives hooks in brain, but it's a bit verbose. 
03:18:06 <dminuoso> Rembane: Monad tutorial fallacy. At every point. :p
03:18:13 <Rembane> dminuoso: Bah! :D
03:18:45 <Rembane> This is some order of magnitudes better: https://wiki.haskell.org/All_About_Monads
03:18:46 <nil> the haskell blog tutorial fallacy
03:21:00 <Rembane> https://wadler.blogspot.com/2013/11/the-monad-tutorial-fallacy.html :D
03:21:20 <Rembane> Also: https://two-wrongs.com/the-what-are-monads-fallacy
03:22:35 <jusss> Rembane: I actually really don't understand why you people always call it Reader Monad when m is e-> ?
03:23:16 <Clement96> Rembane I was wondering where were the fallacy. thank you for the links
03:23:38 <jusss> those articles takes lots of my time and I still don't understand what those monads are... 
03:23:57 <jusss> only Maybe and Either a, I can get know
03:24:08 <jusss> I can know
03:24:17 <Rembane> Clement96: No worries. :)
03:24:44 <Rembane> jusss: Because it lets us Read a context. 
03:25:02 * Rembane kicks internet in the shin
03:25:52 <jusss> Rembane: then what is the CONTEXT in the Reader?
03:26:25 <dminuoso> jusss: Forget the word "context" in my opinion.
03:26:26 <Rembane> jusss: The e I believe, but I might be wrong there.
03:26:40 <Rembane> dminuoso: What's your take on the reader monad?
03:26:45 <jusss> why people don't make a clear definition for the word CONTEXT?
03:26:58 <dminuoso> jusss: Here's the reason:
03:27:25 <dminuoso> jusss: Monad is an abstract interface, with no suitable... "visual guides" to explain what its about.
03:28:18 <dminuoso> jusss: And equivalently Functor is an abstract interface. For someone who does understand and see the pattern, the word "context" makes sense.
03:28:35 <dminuoso> Its not something to understand, its rather something where you sit there and say "Ohh... its sort of like XYZ..."
03:28:42 <jusss> dminuoso: then how you know you are right or not about it?
03:28:48 <Rembane> Laws! 
03:29:26 <tdammers> to me, the mental breakthrough came when I stopped trying to grok what Functor or Monad or any of these "are", or how to "visualize" them, and just accepted that the formal definitions and laws are really all there is to them
03:29:36 <dminuoso> jusss: That's a good question.
03:29:38 <tdammers> the best intuition for "Functor
03:29:44 <tdammers> ", IMO, is "something you can fmap over"
03:30:23 <dminuoso> Indeed.
03:30:31 <Rembane> I stare at the types and use the functions that let me do what I want with them. Important functions there are fmap, (<*>) and (>>=)
03:30:34 <dminuoso> Though I still think "functor is a container" can work reasonably well.
03:30:44 <tdammers> "oh, look, it's the same shape; let's see if the laws also hold... yep, they do, OK, I'll accept that this is a Functor, and that everything I know about Functors also applies to this thing"
03:30:53 <dminuoso> I still havent found a motivating counter example that doesnt work with "functor is a container"
03:31:06 <tdammers> (->)
03:31:13 <dminuoso> tdammers: Representable Functor ring a bell?
03:31:23 <tdammers> dminuoso: vaguely
03:31:39 <dminuoso> tdammers: `Int -> Bool` is, roughly, `[Bool]`
03:31:47 <dminuoso> Or rather `Nat -> Bool` I suppose
03:31:49 <dminuoso> :)
03:31:50 <tdammers> oh, right, yeah
03:31:57 <dminuoso> Though since they are countable, both work
03:32:15 <tdammers> so the fun part is that the functor instance also works for uncountable ones
03:32:30 <tdammers> which kind of stretches the mental model of "container", but it still kind of works
03:32:34 <dminuoso> tdammers: My point is the core intuition about why they are containers are still good.
03:32:46 <tdammers> sure. I understand that, and I think I agree.
03:32:48 <dminuoso> You have some sort of index that you can supply and get the value out of it :)
03:32:58 <dminuoso> though
03:32:58 <tdammers> what about IO?
03:33:04 <dminuoso> tdammers: Mind you, container doesnt mean extractability
03:33:20 <Rembane> dminuoso: Do you use the lookup-table-intuition for functions to make it work with the functor container intuition?
03:33:23 <tdammers> no, but saying that getLine "contains" a String isn't quite how I usually think about it
03:33:56 <tdammers> getLine is an action that is capable of producing a string when executed; but "contain" doesn't sound quite right
03:34:11 <dminuoso> tdammers: I have a few mind models that allow me to think of getLine as containing a string.
03:34:52 <tdammers> dminuoso: yeah, it works once you've grokked it, but it doesn't seem intuitive to me, not for a newcomer anyway, so I'm not so sure the "container" model aids understanding here
03:35:13 <dminuoso> tdammers: well it aids in the sense that you can sort of "apply the function to the contained elements"
03:35:28 <dminuoso> tdammers: the "something you can map over" is again very vague and hard to grok
03:35:42 <dminuoso> "what does it mean to map over"
03:35:57 <tdammers> I like the "A-of-B" terminology. getLine is an IO of String, [1,2,3] is a list of integers; what exactly the "of" means is up to the concrete instance
03:36:30 <tdammers> and with a functor, you retain the "A" part, but you can manipulate the "B" part through the functor
03:36:36 <tdammers> that's what fmap does
03:36:50 <tdammers> and it is quite literally what its type says
03:36:57 <tdammers> (a -> b) -> f a -> f b
03:37:00 <dminuoso> tdammers: In my mind IO String is kind of like a box with schroedingers cat. You sort of dont know whats inside until you actually open it. :P
03:37:08 <dminuoso> At least in the "functor as a container" mind model.
03:37:14 <dminuoso> But indeed, thats stretching it a bit
03:37:15 <tdammers> "given a way to turn an a into a b, fmap turns an f-of-a into an f-of-b"
03:37:39 <dminuoso> tdammers: For me, I didn't understand this properly until I understood Day convolution.
03:37:41 <Phillemann> In Servant, can't I just use "throwError err401" in my handler? ghc tells me it can't match IOException with ServerError
03:37:46 <tdammers> but yeah, let's just say the "container" analogy is less wrong than you'd initially expect it to be
03:37:59 <dminuoso> tdammers: In the sense of, types dont define what they mean - its the functions that use your type that define what they mean.
03:38:03 <dminuoso> (Fully in the spirit of category theory)
03:38:13 <dminuoso> (This revelation was interesting)
03:38:17 <tdammers> ah yes
03:38:49 <dminuoso> Phillemann: Did you use hoistServer/hoistServerWithContext?
03:39:23 <Phillemann> dminuoso: No, never saw those functions
03:39:41 <dminuoso> Phillemann: Can you supply the code provoking the error and the type error?
03:39:46 <dminuoso> (Say in a gist)
03:41:54 <Phillemann> dminuoso: Ah, while trying to minimize the problem, I think I found it.
03:42:23 <Phillemann> My handler looks like this: handle = withSql (\conn -> doStuff); and withSql is withSql :: MonadIO m => (Connection -> IO a) -> m a
03:42:32 <Phillemann> So probably withSqls type is too narow/too broad.
03:43:04 <Phillemann> This should probably be...(Connection -> m a) -> m a or something.
03:46:18 <alp> correct
03:46:28 <alp> or you need to try and fetch what you want in that withSql thing
03:46:48 <alp> and later decide whether to error out or return your value, depending on what you got back from withSql, in your comfy Handler or custom monad
03:47:02 <alp> where there is a way to abort with an error value
03:48:28 <jusss> data Reader r a = Reader {  runReader :: r -> a }, it means `data Reader r a = Reader r->a` and `runReader Reader r a :: r->a` ,  Reader r is the monad?  put a function r->a into Reader ?
03:48:48 <jusss> Reader r->a :: Reader r a
03:48:59 <dminuoso> jusss: For every choice of some type `r`, `Reader r` is a monad
03:49:10 <Phillemann> alp: Ah, I see what you're getting at. Ideally, I'd like to just do everything inside the withSql action. But type-wise, this seems nontrivial.
03:49:43 <jusss> dminuoso: what's the point? put a function r->a into a value constructor Reader?
03:49:57 <dminuoso> jusss: Essentially it boils down to this:
03:50:09 <dminuoso> jusss: Imagine you have a program and some global environment, say the config file you loaded at startup.
03:50:25 <dminuoso> jusss: Now, a lot of your program parts need access to that config file, because it contains relevant configuration.
03:50:49 <dminuoso> jusss: So one reasonable way of doing this, is adding a `Config -> ...` parameter to every function, and explicitly passing that config file everywhere.
03:50:52 <Phillemann> withSql is based on withConnection which is (Connection -> IO a) -> IO a
03:51:00 <dminuoso> jusss: Does this make sense so far?
03:51:43 <jusss> dminuoso: why people alwasy use read config or read database as example for Reader? I don't know how this is related with the function r->a
03:52:00 <dminuoso> jusss: Does my example make sense?
03:52:52 <jusss> dminuoso: Config -> will return what to every function?
03:53:48 <dminuoso> jusss: No I mean you have some config file of type Config that you load at startup. Now perhaps your `fetchData :: IO Data` needs that config, so in reality you'd rather write `fetchData :: Config -> IO Data`, now fetchData can use this config file
03:54:01 <dminuoso> jusss: But in turn, you need to explicitly pass that config file to fetchData.
03:54:05 <dminuoso> jusss: Is this clear?
03:54:19 <jusss> dminuoso: go on
03:55:18 <dminuoso> jusss: Now lets just assume that not just fetchData, but perhaps a lot of parts need that Config file, so you add an additional Config parameter: `writeDb :: Config -> Data -> IO ()`, or `notifyUser :: Config -> IO ()`, etc...
03:55:33 <jusss> dminuoso: ok
03:55:45 <dminuoso> jusss: So at some point most, if not your entire, program somehow carries this argument/parameter, and you keep passing it down
03:55:49 <jusss> lots of function take the same input
03:56:00 <dminuoso> jusss: Right! And you keep passing that config file onto other functions.
03:56:44 <dminuoso> `doSomething cfg = do { user <- getUser cfg; checkUser cfg user; writeDb cfg someData }` 
03:56:55 <dminuoso> So you keep passing that same config file around.
03:58:31 <dminuoso> Reader/ReaderT merely make it, so that the cfg parameter gets passed around implicitly. So instead of writing `doSomething cfg = do { user <- getUser cfg; checkUser cfg user; writeDb cfg someData }` you'd write `doSomething = { user <- getUser; checkUser user; writeDb someData }` - the cfg parameter is sort of just "hidden", and you can explicitly grab it by writing `ask`
03:58:58 <dminuoso> So all Reader/ReaderT do, is make parameter passing implicit
03:59:19 <dminuoso> But by effect, you have access to that same parameter everywhere. It acts like a global read-only environment.
03:59:38 <dminuoso> Just like it was with that cfg parameter you pass around everywhere, except you dont have to explicitly pass it around. It happens implicitly
04:00:22 <jusss> dminuoso: wait a sec, do I need to change getUser or checkUser functions?
04:01:03 <alp> Phillemann, I don't think it's a bad thing. after all, it's not useful to your app to keep SQL connections alive for longer than necessary
04:01:07 <dminuoso> jusss: Yes.
04:01:29 <dminuoso> jusss: The Reader monad instance is a bit simpler and not that useful in general.
04:02:02 <dminuoso> jusss: Im willing to argue, that `instance Monad ((->) e)` exists mainly for code golfing. ={
04:02:21 <dminuoso> jusss: But ReaderT is sort of useful, but it doesnt really add much value. You might as well just pass around a parameter by hand.
04:02:30 <dminuoso> It's situational.
04:03:13 <jusss> dminuoso: I feel it looks like (let ((cfg config)) (getUser cfg) (checkUser cfg) (writeDb cfg)) to (let ((cfg config)) (getUser) (checkUser) (writeDb))
04:03:36 <dminuoso> jusss: I dont know what that syntax means.
04:03:54 <jusss> dminuoso: sorry. it's scheme...
04:05:45 <dminuoso> jusss: Even the Functor instance of `((->) e)` is rarely interesting. It's used mostly in more exotic settings. :)
04:06:42 <jusss> dminuoso: and Writer?
04:07:45 <dminuoso> jusss: Writer is largely unused because it doesn't perform nicely.
04:07:49 <dminuoso> (At least thats the way I understand it)
04:08:24 <jusss> dminuoso: and State? why those three are related?
04:08:42 <dminuoso> jusss: Reader is a read-only environment.
04:08:47 <dminuoso> jusss: State makes it mutable.
04:10:26 <Phillemann> alp: Absolutely true. I'm going that way.
04:11:06 <fendor> When I use Data.Generics `everything`, does that traverse always "everything"? Assuming an AST, and I only want to look at top-level expressions, would `everything` traverse further in the AST assuming a fitting Data instance?
04:11:27 <jusss> dminuoso: Reader, it seems to me like it bind its value into a namespace, and other function in that namespace can visit its value...
04:11:37 <dminuoso> alp: By the way, regarding unfolding servant types.. I think it should be mentioned somewhere in the client. Or at least, a client with BasicAuth should have a documented example, because its more likely people will use BasicAuth distributed over a set of endpoints, rather than BasicAuth stuck to each separate endpoint.
04:12:02 <dminuoso> jusss: If that mental model helps you. :)
04:12:13 <jusss> dminuoso: but that's meaningless
04:12:20 <dminuoso> jusss: It's just a mind model.
04:13:08 <jusss> dminuoso: 'cause pass the value as argument to the function and visit some identifiers to get its value inside the function, are not diffrent
04:13:28 <dminuoso> jusss: What do you mean by "visit some identifiers to get its value inside the function"?
04:13:52 <dminuoso> jusss: All Reader does, is making the "argument passing" as "automatic/implicit/hidden behind the scenes". You dont even name the parameter explicit anymore.
04:14:12 <dminuoso> (And because its not even named, you need a special gadged to get access to it)
04:14:23 <dminuoso> *gadget
04:14:48 <alp> dminuoso, https://haskell-servant.readthedocs.io/en/stable/cookbook/basic-auth/BasicAuth.html could indeed be updated that way. Would you feel like submitting a patch? :-) (to https://github.com/haskell-servant/servant/blob/master/doc/cookbook/basic-auth/BasicAuth.lhs)
04:14:52 <jusss> dminuoso: let's assume function f and identifier x which has value 3 at the same namespace, so (f x) and f = \_ -> x are the same, I don't know how to express in haskell...
04:15:14 <jusss> let x=3 in \_ -> x
04:17:06 <jusss> dminuoso: wait , no named ?
04:18:50 <jusss> oh, f >>= g = \x -> g (f x) x, use >>= to chain those functions, 
04:19:14 <jusss> those functions all can get the input x, 
04:19:28 <jusss> dminuoso: this is what you mean?
04:28:00 * hackage morpheus-graphql 0.2.2 - Morpheus GraphQL  https://hackage.haskell.org/package/morpheus-graphql-0.2.2 (nalchevanidze)
05:03:36 <ski> dminuoso : hm, can you tell me more about this "identity is not perfectly respected in some monad instances" thing ?
05:03:48 <ski> dminuoso : "do you know whether there's a semigroup equivalent of a monoid in a category?","is it enough to assume a semigroupoidial category as one equipped with a bifunctor that is assoc up to natural iso?" -- hm, i think so ?
05:03:56 <ski> dminuoso : hm, might've been "Sacrificing the Calf of Flexibility on the Altar of Reliability" by Peter J. Denning in 1976 at <https://dl.acm.org/citation.cfm?id=807704> (pdf),<https://app.box.com/s/dhztnnmr997auzkw8gxy> (djvu)
05:12:55 <freeman42x[NixOS> let's start a war: HSpec or Tasty... which is BEST?
05:14:04 <freeman42x[NixOS> or HUnit?
05:14:21 <freeman42x[NixOS> or EasyTest?
05:14:41 <Clint> go on
05:16:13 <freeman42x[NixOS> the fact that EastyTest is based on Hedgehog and it can do quickcheck and unit tests is quite appealing
05:16:20 <maralorn> I wouldnâ€˜t have phrased it that way, but I was curious about it too. But as far as I understand there are nice compitibility layers between them so you donâ€˜t really have to decide.
05:17:19 <freeman42x[NixOS> this thing about Tasy sounds really good: "It lets you combine your unit tests, golden tests, QuickCheck/SmallCheck properties, and any other types of tests into a single test suite."
05:18:16 <freeman42x[NixOS> so based on a quickassesment it looks like Tasty is the best
05:20:02 <lyxia> yes tasty is the nicest now
05:22:50 <maralorn> I feel like i prefer the monadic HSpec syntax. But I havenâ€˜t actually used any of them.
05:24:52 <pigmej[m]> Heya again,
05:25:06 <pigmej[m]> what's the currently recommended lightweight REST api approach ?
05:25:28 <pigmej[m]> servant seems to be overkill, am I right?
05:29:49 <asheshambasta> pigmej[m]: why is servant overkill? I think the most lightweight and barebones is Scotty; and lower still can be Wai/Warp 
05:30:17 <pacak> A bit more  advertising for a different timezone: https://www.reddit.com/r/haskell/comments/cx8yei/tsuru_capital_is_looking_for_haskell_interns/ - Tsuru Capital is looking for interns
05:30:33 <pigmej[m]> asheshambasta: I need to spawn shitload of these, I need it for microservices
05:30:46 <pigmej[m]> so my thinking is that servant is a bit overkill because of:
05:30:47 <pigmej[m]> 1) memory
05:30:47 <pigmej[m]> 2) from what I see latency is kinda high with servant
05:31:06 <asheshambasta> well, we're using Servant quite extensively in a distributed setting, with quite good results 
05:31:45 <asheshambasta> Servant, by itself, AFAICS doesn't incur much overhead, and I think above all, if you're dealing with a lot of services communicating with each other over HTTP, Servant provides some great guarantees.
05:31:56 <pigmej[m]> I have rather simple API
05:32:31 <asheshambasta> in my experience, however, interconnecting services and letting them talk to each other over HTTP in 'micro'-services settings has always turned out to be quite a big mistake 
05:32:31 <pigmej[m]> the flow is more like few apis => shitload of apis <=> two apis
05:32:46 <asheshambasta> and in the end, you end up with a microservices-monolith :-) 
05:32:48 <boxscape> hmm lambdabot just told me to "report this as a ghc bug" when I tried producing a large type signature and it couldn't commit 1 million bytes of memory, but I can't reproduce it :/
05:32:57 <pigmej[m]> no it's not that kinda design asheshambasta :)
05:33:35 <asheshambasta> from what I know, Servant is probably the best approach, even for simple APIs 
05:34:01 <pigmej[m]> how's whe production experience with it? Any quirks?
05:34:07 <asheshambasta> its the most future proof and the safest; and I don't really consider it heavy-weight. 
05:34:44 <asheshambasta> pigmej[m]: the one sticking point is that it only supports String as the error type when say a parameter cannot be deserialised in a request 
05:35:06 <pigmej[m]> hmmm..... and responds with text/plain then?
05:35:55 <asheshambasta> yeah; but then we have a bunch of services exposing servant APIs underneath an API gateway (also written in Haskell); which tries to parse these Strings (we resort to JSON strings as more expressive errors at this level)
05:36:03 <jgt> asheshambasta: I think this opinion is wildy understated
05:36:46 <jgt> it's true â€” splitting up a single system into lots of little systems that replaced function calls with network requests is a *really* bad idea
05:36:57 <jgt> for most businesses anyway
05:38:26 <asheshambasta> jgt: yeah, you end up with a slower and less type-safe monolith 
05:40:08 <jgt> exactly
05:40:22 <asheshambasta> a lot of thought needs to go into the 'service boundaries' 
05:41:26 <asheshambasta> if you're getting into a situation where you need realtime 'answers' from across services to perform operations in one of your services, it is a sure shot sign that you've over-granularised. 
05:42:11 <jgt> yeah, that's definitely not something I'm going to do with my business
05:42:41 <jgt> cross-cutting concerns are always hand-waved at in microservices discussion
05:43:15 <jgt> and one of my greatest leverages with my business is myself and my colleagues being able to make grand sweeping changes with confidence as the needs of the business evolve
05:43:33 <jgt> confidence, _and_ speed
05:43:50 <asheshambasta> yeah, and in our experience Haskell is quite great for that 
05:49:43 <maralorn> I am wondering: When I write a servant API with "a <|> b" where a and b have the same return type. And then I implement a server for that. Is there anything saving me from falsely swaping "bServe <|> aServe"?
05:50:30 <asheshambasta> maralorn: also depends on the types of the query params; headers; body etc.
05:50:39 <asheshambasta> + the apth 
05:50:42 <asheshambasta> path*
05:51:02 <asheshambasta> + request method 
05:52:06 <jgt> pigmej[m]: Yesod is good for writing API services
05:52:59 <maralorn> asheshambasta: But when I look at the second server in this tutorial ("server2") https://haskell-servant.readthedocs.io/en/stable/tutorial/Server.html it doesnâ€˜t seem like the Server variable even knows what path it is connected to and it just depends on the order of endpoints.
05:53:53 <alp> maralorn, no. the generic/record-based approach makes things less error prone: https://haskell-servant.readthedocs.io/en/stable/cookbook/generic/Generic.html
05:53:54 <maralorn> In that specific example it would be a really easy bug to serve Albert at /isaac and Isaac alt /albert.
05:55:00 <asheshambasta> maralorn: yes, that can happen, however, the UserAPI2 type itself maps on to the handlers defined in the server. 
05:55:15 <maralorn> alp: Ah, that looks safer. thx
06:03:58 <pigmej[m]> asheshambasta: what are you running exactly? (Can you share?)
06:09:42 <alp> maralorn, note that you can still erroneously swap the two endpoint handlers, GHC still won't complain but it should be more obvious (from the name of the fields) that you're getting it wrong. e.g MyAPI { serveAlbert = return isaac, serveIsaac = return albert } 
06:12:10 <maralorn> alp: Yeah, obviously.
06:12:14 <maralorn> thx
06:13:39 <freeman42x[NixOS> ah, Tasty needs to use HSpec or HUnit... which is best?
06:14:13 <tabaqui> hspec is a framework to unite other tests
06:14:25 <tabaqui> including hunit which just provides unit tests
06:15:05 <tabaqui> probably if you don't need property tests (quickcheck), you can try the hunit as a simplier one
06:15:26 <maralorn> tabaqui: But one can also use quickcheck directly with tasty?
06:15:38 <tabaqui> dunno, I don't use tasty
06:15:55 <tabaqui> I used tests-framework before, but imo hspec is much better
06:16:25 <tabaqui> because it composes tests with monad not with haskell lists
06:16:45 <lyxia> that's better?
06:17:12 <tabaqui> imo, yes
06:17:43 <maralorn> tabaqui: Because itâ€˜s nicer to read or because it has semantic advantages?
06:18:01 <tabaqui> f.e. with hspec you can mark some tests as focused, or restrict parallel execution for a specific branch
06:18:45 <tabaqui> or you can define some actions to run before and after test execution
06:19:08 <tabaqui> I dunno, if Tasty can such things too, maybe it can
06:19:27 <lyxia> tasty is on the same level as hspec and test-framework
06:19:50 <tabaqui> tests-framework seemed less flexible to me
06:20:13 <tabaqui> and do-notation is nicer to read, ofc
06:57:24 <Boarders> Does anyone know in megaparsec how to consume newline separated text that will work for both something like fold ["hi\n", "ho\n", "hum"] and fold ["hi\n", "ho\n" "hum\n"]?
06:58:14 <Boarders> I have tried "sepBy1 textInput (some (char '\n'))" but that is not right
06:59:45 <lyxia> sepBy1 textInput (char '\n') <* optional (char '\n')
07:06:01 <Boarders> lyxia: do you know how it interacts with endb
07:06:06 <Boarders> eof*
07:06:42 <Boarders> I have the following:
07:07:10 <Boarders> ident :: TextParserident = lexeme spaceP (cons <$> lowerChar <*> takeWhileP Nothing (isAlphaNum))
07:11:45 <Boarders> https://gist.github.com/Boarders/022369de1777a656dc999008c0644c36
07:25:28 <Brekker> Hey guys, I'm currently learning haskell, but I've hit a bit of a wall when it comes to Functors and Monads. Does anyone know where I can get my hands on some exercises I can work through? I've always been more of a hands on learner.
07:25:39 <Nolrai> So is there a word for weather a factor is above or below 1? Like how sign is the word for a term being above or below 0?
07:26:03 <topos> Brekker https://github.com/data61/fp-course
07:26:10 <lyxia> Boarders: sepBy1 doesn't do anything special with eof
07:26:11 <topos> here's a bunch of hands-on exercises
07:26:23 <Brekker> topos: Thanks!
07:26:54 <Boarders> Brekker: this is a quirky collection of exercises you might enjoy: https://blog.tmorris.net/posts/20-intermediate-haskell-exercises/index.html
07:26:56 <lyxia> Boarders: what's lexemeS
07:27:20 <Boarders> it is lexeme spaces (sorry I'll edit)
07:28:53 <topos> Boarders HA he's been blocked by the transpennine express train wifi filter
07:29:10 <topos> RIP tony
07:29:14 <dminuoso> Brekker: Honestly? I recommend not focusing on these words.
07:29:19 <Nolrai> @topos: Do you know of good sources for topos theory? For someone who only has a begining understanding of locals, but has non-enriched non-higher category theory pretty down?
07:29:19 <lambdabot> Unknown command, try @list
07:29:26 <dminuoso> Brekker: Do you know, in general, what an interface is (say from Java)?
07:29:51 <topos> Nolrai stone spaces by johnstone or higher topos theory by Lurie
07:30:00 <Nolrai> Thanks!
07:31:54 <Brekker> dminuoso: Yeah I'm familiar, though I'm finding them to be more similar to Rust's traits
07:31:55 <lyxia> Boarders: I think what I wrote doesn't work because sepBy1 consumes the last newline, then tries to parse the next nonexistent line, and fails but does not backtrack because (char '\n') succeeded.
07:32:36 <lyxia> Boarders: have you seen sepEndBy1
07:32:37 <dminuoso> Brekker: Okay. So Monad is an interface consisting of two functions. The purpose is quite abstract and not important for actually using it. You can get by, using Monad without understanding the first thing about it.
07:33:42 <Boarders> lyxia: I have not, I will have a look. Thank you!
07:33:53 <dminuoso> Brekker: Most of the intuition will come over time, by simply using concrete instances (i.e. implementations) of that interface. Tutorials are very unlikely to generate much useful intuition. :)
07:34:16 <dminuoso> On its own, without you even trying to. :)
07:35:31 <topos> monads are chalupas
07:35:38 <topos> did i get that right
07:35:45 <Brekker> dimuoso: Okay, that's helpful, thanks
07:39:15 <FabianW> So, about the layout rule: Is is just that once a level of indentation has been set by where,let,of or do, anything that takes more than one line should have all its continuation-lines indented further to the right than the current level of indentation? And all the other alignment is just for aesthetics?
07:39:46 <Boarders> lyxia: using the implementation from parsec seems to work, thank you again
07:40:17 <FabianW> Because I'm reading "Practical Haskell" and it says that all branches of an if-then-else expression have to be indented at the same level, but that does not seem to matter.
07:41:29 <dminuoso> Brekker: I have adopted this perspective, that when you see something like `Monad m => (a -> m b) -> m a -> m b`, that it's best to understand a type variable as "the consumer picks a type for it". And the "Monad m" merely constrains your choice - but here comes the catch, in most cases you've already decided what that type `m` is going to be.
07:43:02 <dminuoso> Brekker: So if you, as the caller/consumer of these "monadic things" just realize that "Monad m" means "You can pick m to equal IO, a to equal Int and b to equal Bool", then suddenly that type sort of collapses into "(Int -> IO Bool) -> IO Int -> IO Bool", and now the discussion is no longer about monads, but rather "What does this function do?"
07:43:20 <dminuoso> Brekker: And for most instances, that question "what does this function" is usually easily explained in 5 minutes or less. :)
07:44:11 <Brekker> dminuoso: Ahh, I see 
07:44:21 <Brekker> dminuoso: It's so much easier to think of it in those terms
07:49:17 <dminuoso> Brekker: This intuition works with any type signature. If you see some binding that has type variables, don't be intimidated by them. It just means you can pick whatever type you like. :)
07:51:58 <dminuoso> And if there's a context, that is something with `=>` in its type signature, that context merely constrains your choices so you cant pick them completely arbitrarily. 
07:52:44 <dminuoso> `Functor f => f a -> f ()` means you can pick whatever you want for type `a`, and whatever you want for type `f` as long as there exists an `instance Functor f` anywhere in scope.
07:57:02 <maralorn> I might be wrong about this, but I always feel like 50% of the Monad confusion is, that other Languages donâ€˜t have an IO Type. So when people hear "IO Monad" they are confused because there are two things they donâ€˜t know.
08:00:18 <dmj`> in other languages everything is in the IO monad
08:01:23 <dminuoso> The choice of words "IO monad" I feel might not be the best idea.
08:01:31 * hackage ttl-hashtables 1.3.1.1 - Extends hashtables so that entries added can be expired after a TTL  https://hackage.haskell.org/package/ttl-hashtables-1.3.1.1 (erick)
08:02:19 <dminuoso> Because it suggests that IO itself is something "monadic"
08:02:42 <dminuoso> I dont hear people talking about "The Integer Semigroup"
08:03:27 <boxscape> It does feel right do attach *something* to the letters "IO", because the kind is Type -> Type, which isn't the case with Integer
08:03:39 <boxscape> (to me, at least)
08:04:00 <dminuoso> boxscape: Why do we need to attach the name of a typeclass to a type?
08:04:17 <dminuoso> boxscape: The typeclass does not fully characterize the type. 
08:04:46 <boxscape> I'm not saying we should be saying "IO Monad", I'm just saying that simply saying "the type IO" or something like that doesn't feel right to me
08:04:57 <dminuoso> Why not?
08:05:13 <boxscape> because it's a type constructor
08:05:14 <dminuoso> boxscape: Perhaps you just need to let go of the notion that a type level value must be a classification of values.
08:05:22 <boxscape> maybe
08:05:27 <glguy> boxscape: Int is also a type constructor
08:05:29 <dminuoso> boxscape: So? Its still a type.
08:05:40 <dminuoso> boxscape: Here's a value-level comparison. Would you say a function is a value?
08:05:49 <dminuoso> Is `id` a value?
08:05:54 <boxscape> hm, it's confusing that "type" has a different meaning from Data.Kind.Type
08:06:01 <boxscape> I would, I suppose
08:06:31 <davean> boxscape: we got TypeInType, so whatever :)
08:06:34 <dminuoso> boxscape: IO is all three: 1. a type, 2. a type constructor and 3. a type function.
08:06:49 <boxscape> but that just means (Type -> Type) :: Type, not (Type -> Type) ~ Type, davean
08:07:16 <dminuoso> boxscape: The fact that IO is a type constructor merely means, that once you apply `IO` to an argument, it will construct/return a completely new (anonymous) type.
08:07:25 <glguy> No, that's not what it means
08:07:37 <Lears> IO is an abstract datatype; its defined by the interface its given. Since Monad is an absolute core part of that interface, I think its very reasonable to attach it to IO in casual use.
08:07:41 <glguy> type constructor doesn't mean type function
08:08:18 <dminuoso> glguy: Sure. Though I can see how my phrasing could be misunderstood that way.
08:08:33 <glguy> The fact that IO is a type constructor does not merely mean you can apply it to anything
08:09:27 <dminuoso> glguy: What does "being a type constructor" really mean? That I can "pattern match" on it in tyfams and typeclass instances?
08:09:44 <dminuoso> Sort of analogue to how data constructor means you can pattern match on it with case-of?
08:10:11 <glguy> yes
08:10:32 <dminuoso> Okay that sounds more reasonable indeed. :)
08:10:38 <glguy> there are type constructors and type variables, and they mean the same thing as at the value level where one binds in patterns and one matches
08:14:27 <dminuoso> glguy: Just to be sure, when you talk about how "type variables mean the same thing..." that's only one particular notion of type variables in tyfams and typeclasses right?
08:15:05 <glguy> It's how they work in the matching cases
08:15:14 <glguy> type variables are just the lower-cased type identifiers
08:16:39 <dmj`> life is IO monad
08:18:01 <heath> from the A History of Haskell paper:   "The after-dinner talk was given by Barkley Rosser, and received two ovations in the middle, once when he presented the proof of Curryâ€™s paradox, relating it to the Y combinator, and once when he presented a new proof of the Church-Rosser theorem." I'm missing something. Why are we still using the lambda calculus? 
08:18:24 <geekosaur> it's still useful?
08:19:14 <heath> (one second, phone call)
08:22:51 <geekosaur> System Fc is an elaboration on lambda calculus; it's not unusual to refer to all such systems as "lambda calculus". Indeed, once you reduce GHC Core into STG, the relationship is much more obvious because STG is basically a bunch of lambda bindings
08:24:17 <geekosaur> (indeed, there's no single "lambda calculus". even at the most basic level there's untyped, simply typed, ...)
08:38:59 <maralorn> Lears: In general I agree. But for beginners saying "IO Monad" seems to imply, that you have to understand "what a monad is" (whatever thatâ€˜s supposed to be) to understand IO.
09:32:30 * hackage PrimitiveArray 0.10.0.0 - Efficient multidimensional arrays  https://hackage.haskell.org/package/PrimitiveArray-0.10.0.0 (ChristianHoener)
09:35:33 <ski> dminuoso : any feedback ? :)
09:55:37 <monochrom> Why are we still using numbers?  >:)
09:56:47 <wroathe> when we could be using ideas?
09:57:26 <monochrom> I think people already do.
09:58:01 <glguy> But then there's the risk that people will start getting "big" ideas
09:58:01 <geekosaur> numbers are ideas. show me a "3". not a digit 3 written somewhere, but a 3 itself.
09:58:33 <maerwald> ideas are preconceived
09:58:47 <maerwald> they are not pure
09:58:49 <monochrom> What have I done?!
09:59:49 <monochrom> Oh I misread wroathe's sentence.
09:59:56 <tabaqui> oh, show me anything but numbers
10:00:13 <tabaqui> wake up, Neo
10:00:26 <monochrom> But I wrote "why are we still using numbers?" in response to heath's "why are we still using lambda calculus?".
10:00:37 <tabaqui> ah, ok
10:01:55 <wroathe> monochrom: I didn't see what you were replying to, so I made up my own story ;)
10:02:11 <monochrom> Yeah, heath's was like 2 hours ago.
10:05:19 <wroathe> can you factor ideas?
10:05:45 <monochrom> Why are we still using factoring?  <duck>
10:05:46 <Desesp> Someone knows how to generate the levenshtein table row by row. This is to generate a table row by row using a function that generates successive rows.
10:05:55 <monochrom> > undefined :: *
10:05:59 <lambdabot>  error:
10:05:59 <lambdabot>      â€¢ No instance for (Show *)
10:05:59 <lambdabot>          arising from a use of â€˜show_M363981695399185313221268â€™
10:06:06 <monochrom> Oh heh
10:06:32 <maerwald> stop that black magic
10:06:35 <monochrom> haha
10:08:28 * ski grins
10:08:48 <monochrom> The logical conclusion of Type :: Type
10:09:19 <Desesp> newrow :: Char -> String -> [Int]-> [Int]
10:10:38 <monochrom> it occurred to be I could read "Type :: Type" backwards and deduce "therefore it is legal to have myValue :: Type, OK sure I don't have an interesting term/value for myValue other than bottom"
10:12:21 <dmwit> ?let instance Show * where show _ = "wow"
10:12:21 <lambdabot>  Parse failed: Parse error: where
10:13:05 <dmwit> ?let instance Show Data.Kind.Type where show _ = "wow"
10:13:07 <lambdabot>  .L.hs:236:15: error:
10:13:07 <lambdabot>      Not in scope: type constructor or class â€˜Data.Kind.Typeâ€™
10:13:07 <lambdabot>      No module named â€˜Data.Kindâ€™ is imported.
10:13:21 <monochrom> yahb has Type
10:13:34 <dmwit> > undefined :: *
10:13:36 <lambdabot>  wow
10:14:53 <glguy> Computer scientists were so preoccupied with whether or not they could have values with type Type they didn't stop to think if they should.
10:16:51 <monochrom> w00t!
10:16:51 <monochrom> BTW how do I tell yahb to reset i.e. forget user definitions?
10:17:26 <iqubic> How do you do it in a normal repl?
10:17:33 <iqubic> % :unload
10:17:33 <yahb> iqubic: unknown command ':unload'; use :? for help.
10:17:40 <iqubic> % :?
10:17:40 <yahb> iqubic:  Commands available from the prompt:; <statement> evaluate/run <statement>; : repeat last command; :{\n ..lines.. \n:}\n multiline command; :add [*]<module> ... add module(s) to the current target set; :browse[!] [[*]<mod>] display the names defined by module <mod>; (!: more details; *: all top-le
10:17:56 <glguy> % :r
10:17:57 <yahb> glguy: Ok, no modules loaded.
10:18:25 <iqubic> I haven't seen you around in a long while glguy.
10:22:05 <monochrom> Oh! Is :r the same as :reload ?
10:22:27 <glguy> It is.
10:22:55 <glguy> But to get the ! variant you have to type it all the way out :(
10:23:03 <glguy> There's no :r!
10:23:22 <monochrom> I like typing commands in full, don't worry. :)
10:23:52 <glguy> I add the milliseconds saved onto my life counter each time
10:24:09 <EvanR> monochrom is an academic, he has infinite time
10:24:36 <glguy> Oh, I guess I picked the wrong industry to go into
10:26:59 <sim590> I'm trying to use natural numbers. I saw that Prelude doesn't give a standard definition for this. I tried this approach: https://paste.debian.net/1098036/ where I catch runtime errors with Maybe and so my program doesn't crash if some value -5 would be given to it.
10:27:51 <sim590> There's also this approach: https://paste.debian.net/1098037/ with no Maybes and an error if some negative number is given.
10:28:32 <sim590> I don't like either of those. The first I don't like because it's heavy just to use natural numbers. The second one crashes at runtime so that's bad.
10:28:57 <sim590> What's the right way?
10:29:55 <glguy> newtype Positive = MkPositive Integer ; positive :: Integer -> Maybe Positive. You have to have the Maybe around since some of the arguments will be invalid
10:30:06 <glguy> If you want some compile-time checking you can use template-haskell
10:30:13 <glguy> for literals
10:30:15 <monochrom> OK firstly would you rather import Numeric.Natural and use its Natural?
10:30:27 <glguy> Natural is different than what you defined, it has 0
10:35:37 <ski> sim590 : why does `fibo' take a `Maybe Natural', rather than a `Natural' ?
10:36:50 <sim590> ski: Because I wanted to feed the output of toNatural to fibo so that it's easy to put numbers.
10:37:00 <ski> sim590 : instead of having `toNatural' repeatedly unwrap and wrap `Maybe', you can just do a single comparision at the start, and then use a helper function which doesn't give a `Maybe Natural', just a `Natural', avoiding the rewrapping
10:37:07 <sim590> otherwise, it's like Succ(Succ(Succ(...)))
10:37:30 <glguy> Yeah, that succs
10:37:35 <sim590> :D
10:38:09 <glguy> You should only use the Succ|One representation if you really need to have lazily defined numbers
10:38:12 <ski> sim590 : then you can use `fibo <$> toNatural 12', which is the same as `fmap fibo (toNatural 12)', that will call `fibo' on the `Natural' inside the `Maybe', in case there is one
10:38:34 <ski> sim590 : also, it seems perhaps a little bit weird that the return type of `fibo' isn't also `Natural'
10:39:04 * ski assumes sim590 wants to experiment with basic pattern-matching, and the like
10:39:30 <sim590> monochrom: I could import some package gladly. I'd prefer what is the most near of standard (not some obscure package that could give problems in the long run).
10:41:40 <monochrom> Numeric.Natural comes with GHC and is right in base. This is not what anyone would call "obscure".
10:42:00 <sim590> monochrom: Then that's perfect
10:46:20 <sim590> So I tried Numeric.Natural (https://paste.debian.net/1098039/), and I get a warning at compile time for some bad definition, but it still compiles. I guess that's the best I can do?
10:46:59 <monochrom> What is the exact error message?
10:47:09 <monochrom> Err exact warning message
10:47:27 <sim590> ski: About the return type, I didn't define arithmetic for my Natural def, so I was not able to just sum the Naturals.
10:47:47 <sim590> monochrom: https://paste.debian.net/1098040/
10:48:38 <cocreature> sim590: If you compile with "-Werror=overflowed-literals" it will be an error
10:48:50 <monochrom> You understand that -5 is negative and not a good Natural, right?
10:49:10 <sim590> monochrom: Yes. I wanted to trigger that error.
10:49:17 <monochrom> OK then we're fine.
10:49:51 <sim590> cocreature: thanks
10:50:25 <EvanR> it's an accident of history we don't call negatives "bad natural numbers"
10:50:43 <EvanR> are you a bad enough natural
10:51:19 <cocreature> theyâ€™re good naturals brent
11:00:02 <nil> Data.List has uncons, but not unsnoc? :/
11:01:05 <Rembane> nil: unsnoc is very expensive, I think that's why it wasn't implemented.
11:01:24 <nil> yeah, now that i think about it
11:01:35 <nil> it makes more sense for ByteStrings than for lists
11:01:40 <iqubic> What is uncons?
11:01:45 <iqubic> :t uncons
11:01:47 <lambdabot> [a] -> Maybe (a, [a])
11:01:51 <iqubic> Oh, I see.
11:01:54 <nil> > uncons [1..3]
11:01:57 <lambdabot>  Just (1,[2,3])
11:02:02 <nil> > uncons []
11:02:06 <lambdabot>  Nothing
11:02:16 <iqubic> :t safeHead
11:02:18 <lambdabot> error: Variable not in scope: safeHead
11:02:32 <iqubic> safeHead :: [a] -> Maybe a
11:02:41 <EvanR> uncons :: NonEmpty a -> (a, [a])
11:02:52 <EvanR> hehe
11:02:56 <iqubic> What is non-empty?
11:03:11 <iqubic> data NonEmpty a = (a, [a])?
11:03:21 <EvanR> data NonEmpty a = a :| [a]
11:03:34 <iqubic> I see.
11:03:36 <EvanR> so basically yes
11:04:07 <iqubic> yeah. It's just the product of a and [a], whichever way you choose to write it.
11:06:00 <EvanR> the knowledge that a list is non-empty is easily invalidated
11:06:16 <iqubic> How so?
11:06:42 <EvanR> you take it apart once and you're back to "may be empty, maybe not"
11:06:55 <EvanR> regardless of how many times you cons onto something
11:13:11 <boxscape> luckily length indexed vector types exist
11:13:33 <iqubic> Right. Knowing you have a first element tells you nothing about the length of the list other than: "âˆƒ(n :: Int) (n >= 0) => length ~ n + 1
11:13:37 <iqubic> ""
11:14:39 <iqubic> In other words, "data NonEmpty a = a :| [a]" ensures that the length of the list is (n + 1), where n >= and whole.
11:14:52 <iqubic> But it doesn't ensure there is a second element.
11:15:05 <EvanR> same situation as Vect (S n) a
11:15:22 <iqubic> Yes. Correct.
11:21:30 * hackage tmp-postgres 0.3.0.0 - Start and stop a temporary postgres for testing  https://hackage.haskell.org/package/tmp-postgres-0.3.0.0 (JonathanFischoff)
11:26:36 <ski> sim590 : (return type) -- yes
11:37:38 <wildtrees> could Data.ByteString.putStrLn and its putStr variant, be causing a multithread program to lock up bad? 
11:37:51 <wildtrees> if I am calling it from different concurrent threads 
11:40:38 <kaol> Have I gone too far if I use ExceptT a (->) b?
11:40:59 <dmwit> Nah, seems fine to me.
11:41:06 <dmwit> ?unmtl ExceptT a ((->) b)
11:41:06 <lambdabot> ExceptT a ((->) b)
11:41:12 <dmwit> ?unmtl ErrorT a ((->) b)
11:41:13 <lambdabot> Plugin `unmtl' failed with: `ErrorT a ((->) b)' is not applied to enough arguments, giving `/\A. (->) b (Either a A)'
11:41:16 <dmwit> ?unmtl ErrorT a ((->) b) c
11:41:16 <lambdabot> (->) b (Either a c)
11:50:27 <pigmej[m]> hmm am I doing something wrong or Cabal 3.0.0 ignores "--only-dependencies" in install ?
11:51:09 <exarkun> What if I want to write a test that uses the result of `memory` in https://github.com/PrivateStorageio/PaymentServer/blob/master/test/SpecStripe.hs#L79-L83 ?
11:51:25 <exarkun> uses it directly.  instead of indirectly through `app`.
11:51:32 <exarkun> How do I get the value?
11:51:36 <merijn> pigmej[m]: In 3.0 v2 commands are the new default
11:51:46 <merijn> pigmej[m]: If you want the old behaviour, use v1-install
11:51:52 <pigmej[m]> hmmmm
11:52:05 <merijn> pigmej[m]: Although I'd recommend adopting the new glorious v2 world unless you're in the small minority that can't :)
11:52:20 <pigmej[m]> so
11:52:32 <pigmej[m]> new-build instead ?
11:52:35 <pigmej[m]> cabal build --only-dependencies ?
11:52:57 <pigmej[m]> or what's the correct flow... sorry but finding docs for cabal 3 is close to impossible (at least my google fu says so...)
11:53:03 <merijn> pigmej[m]: Depends what exactly your goal is? you're trying to install the dependencies for a project you're working on?
11:53:11 <pigmej[m]> yes
11:53:48 <wildtrees> are Data.ByteString.Char8 operations strict by default? 
11:53:59 <merijn> pigmej[m]: Essentially, the solutions is "you don't have to do that anymore", v2-build (well, "build" now, I suppose) automatically fetches and builds dependencies before building your project
11:54:03 <vaibhavsagar> coyoneda is just boneless continuations
11:54:15 <merijn> pigmej[m]: So you'd just do "cabal build" to build dependencies and your code in one go
11:54:33 <merijn> pigmej[m]: An overview of how v2-style builds work can be found here: https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
11:54:34 <pigmej[m]> merijn hmmm
11:54:38 <pigmej[m]> then some wtf is happening there
11:55:18 <pigmej[m]> let me kill all ghcis...
11:57:41 <pigmej[m]> ok something is wrong with my base path and :load
11:58:54 <pigmej[m]> ok, simple GHC from VSCode improperly detects project root in my case (takes .git not .cabal location...)
11:59:06 <pigmej[m]> and dante with my emacs is complaining about multiple exec stuff.....
12:01:57 <merijn> pigmej[m]: hmm, external tools might want/expect v1 interface still, but I dunno if dante has an easy way to tell it to use a different command. If not the 2 simplest solutions I can think of are downgrading cabal-install to 2.4, or writing a small shellscript named cabal in your path that prepends the command with v1- before exec'ing cabal-install 3.0
12:02:14 <pigmej[m]> dante and simple ghc knows the "new" stuff
12:03:24 <pigmej[m]> but it's complaining about one cabal file with two executables to build.... (well ghci is complaining..)
12:03:46 <pigmej[m]> but yeah downgrade to 2.4 is probably the smartest solution for now because it seems that tools are getting confused
12:05:47 <pigmej[m]> frankly speaking all that stack vs cabal vs cabal "new" vs cabal 3 is... huge showstopper for newcomers
12:06:57 <sclv> the showstopper for you is you're trying to set up an ide
12:07:24 <sclv> and we just released cabal 3 which changes to the newstyle by default roughly _two days ago_
12:07:30 <sclv> so the ide tooling hasn't caught up to it
12:08:12 <sclv> ok, maybe closer to a week now, but still :-P
12:08:14 <merijn> I agree that the fact that tooling hasn't caught up to v2-build is rather obnoxious. OTOH, v2-build is massively better and beginner friendly (in terms of behaviour, perhaps not yet in terms of UI polish/debugging)
12:09:41 <jle`> kaol: a lot of times if you're using `(->) r` as a part of a generic monad combinator, people like to use `ExceptT a (Reader b)` instead
12:09:44 <jle`> s/r/b
12:10:00 <jle`> just for readability sometimes
12:11:12 <pigmej[m]> sclv well.... even before it's not much "cleaner"
12:14:30 <merijn> pigmej[m]: Editor integration has been kinda a mess for a while, there's a bunch of things in progress that should hopefully improve things, but it's slow going because there's very little people working on it and those who are, are doing so in their spare time
12:15:14 <merijn> I saw there was new work on show-build-info, which lets tools query cabal-install about the right flags/config to build stuff with, which should make developing editor plugins/language servers easier once it makes it into a released version
12:15:41 <merijn> And once we have a decent LSP implementation using that I hope things will be in much better shape
12:16:14 <pigmej[m]> LSP.... well....
12:16:25 <pigmej[m]> it will take a while :)
12:23:45 <pigmej[m]> I'm pretty happy with Dante because it works
12:26:50 <pigmej[m]> too bad that HIE doesn't support "new" stuff ;/ (or maybe it's ghc-mod lib)
12:29:53 <merijn> I heard it has some experimental v2 support, but HIE is still pretty brittle judging by some of the problems I see here/on reddit
12:32:40 <pigmej[m]> yeah
12:35:32 <exarkun> How do I replace "abcdefg" in https://github.com/PrivateStorageio/PaymentServer/blob/7.redeem-interface/test/SpecRedemption.hs#L79 with a QuickCheck arbitrary?
12:38:25 <iqubic> Is HIE quite brittle?
12:42:00 * hackage brick 0.48 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.48 (JonathanDaugherty)
12:42:48 <AviD> Anyone know the status of https://github.com/mpickering/haskell-ide-engine aka hie-bios ingratiation?
12:47:08 <merijn> iqubic: The process to build/install it, I mean
12:47:33 <AviD> iqubic: Yes HIE is brittle, or more specifically ghc-mod is brittle. It does not handle many build environments and if your module is not building it's useless. When upgrading old packages hie still really is not useful at all. I love Hie, but it is brittle
12:49:49 <maerwald> good tooling, good language... pick one!
12:50:00 <maerwald> Go has amazing tooling btw
12:50:28 <merijn> maerwald: Easier to fix tooling than fix a language ;)
12:50:32 <vaibhavsagar> maerwald: does it have typed holes
12:50:33 <maerwald> is it? :P
12:51:20 <vaibhavsagar> yes
12:51:28 <vaibhavsagar> can't publish papers about tooling improvements though
12:51:32 <iqubic> Does HIE work with nix?
12:51:43 <vaibhavsagar> iqubic: yes
12:51:44 <AviD> maerwald: While observationally your right. it does not have to be that way.
12:51:50 <iqubic> vaibhavsagar: Nice..
12:52:25 <maerwald> AviD: not sure about that. The simplicity of the Go language is one of the reasons that writing tooling for it is fairly straight forward
12:53:27 <vaibhavsagar> I think the causality runs the other way
12:53:42 <vaibhavsagar> i.e. the language is not very complex, so you need tooling to get anything reasonable done
12:53:55 <maerwald> vaibhavsagar: you don't need
12:54:09 <vaibhavsagar> whereas you can go a long way with GHCi and your favourite text editor
12:54:22 <maerwald> you can do Go just fine with just terminal and compiler
12:54:30 <maerwald> but don't ask me whether it's fun
12:54:36 <vaibhavsagar> exactly my point
12:54:45 <maerwald> you can get a lot of stuff done
12:54:47 <vaibhavsagar> you can also write C with a text editor and GCC
12:54:52 <maerwald> so your point was different
12:55:02 <maerwald> pleasure != productivity
12:55:03 <vaibhavsagar> no, that was exactly my point
12:55:04 <mycroftiv> people who develop skills can get things done in any environment they care to learn, you can get a lot done in bare-metal forth if you are chuck moore
12:55:37 <maerwald> and industry is short-sighted, so just pick something you write a lot of LOC with! :P
12:55:58 <iqubic> I actually have direnv + nix set up so that I can just run "cabal new-build" from the right directory and things just work
13:13:56 <iqubic> Does HIE have an emacs frontend?
13:15:20 <fendor_> iqubic, it uses the lsp protocol
13:16:16 <iqubic> So...???
13:16:43 <fendor_> iqubic, so, you just need an lsp-client in emacs to use it
13:16:57 <fendor_> https://github.com/haskell/haskell-ide-engine#using-hie-with-emacs
13:16:59 <iqubic> ah. I see.
13:17:08 <iqubic> Does it work well?
13:17:18 <fendor_> i dont use emacs, sorry :/ 
13:18:20 <iqubic> What do you use for editing haskell code?
13:18:25 <fendor_> vscode + hie
13:18:52 <iqubic> does HIE work well in VSCode?
13:20:07 <fendor_> well, yes, it works well in vscode. However, hie itself has its problems, such as sometimes crashes, huge memory footprint and slow response times
13:20:39 <maerwald> and vscode also has huge memory footprint
13:20:48 <iqubic> I'm not going to use hie.
13:20:57 <fendor_> also, I use stack, since hie seems to work better with stack based projects. However, I build my packages with cabal
13:21:08 <iqubic> I might start using ghcid, but I'm not going to use hie.
13:21:17 <iqubic> is ghcid worth the effort?
13:21:58 <maerwald> I moved away from interactive programming approach in haskell. Instead I just start coding for a while and then enter the compile -> fix -> compile -> fix session
13:22:03 <maerwald> also improves discipline
13:22:19 <fendor_> ghics is great
13:22:39 <fendor_> s/ghics/ghcid
13:22:46 <iqubic> What benefits does ghcid give me?
13:23:00 <fendor_> very fast compile -> fix loop
13:23:10 <iqubic> I see.
13:23:16 <fendor_> also, with emacs, jump right to compile error
13:23:46 <iqubic> nice. nice. nice.
13:23:56 <iqubic> I think I'll get ghcid working.
13:23:58 <fendor_> I appreciate hie, although it has its problems. I just like the features of hsimport, documentation and completion
13:24:15 <iqubic> What is hsimport?
13:24:27 <fendor_> hsimport is a small tool to import symbols
13:24:31 <iqubic> which works better? ghcid or hie?
13:24:34 <fendor_> ghcid
13:25:07 <fendor_> hie has more features, imo, but ghcid is reliable and gives you what you would expect from it
13:25:27 <iqubic> nice.
13:26:15 <fendor_> yesterday, there was an discussion around tooling in haskell and a lot of tools where named, for emacs esp. iirc
13:29:30 <iqubic> I wasn't here for that. Shoot
13:29:53 <pigmej[m]> Emacs with dante works pretty well
13:30:01 <iqubic> I can imagine.
13:30:08 <iqubic> I might use that.
13:30:18 <pigmej[m]> And it works with cabal, stack, new-cabal and cabal3
13:30:37 <iqubic> I use nix.
13:30:54 <iqubic> Well, nix + cabal
13:32:11 <fendor_> it was recommended to take a look at  https://gitlab.com/tseenshe/haskell-tng.el
13:32:30 <fendor_> that is also for emacs, i think
13:32:53 <fendor_> however, you read the exact discussion and knowledge exchange in the logs
13:33:00 <athan> \quit
13:33:00 * hackage tmp-postgres 0.3.0.1 - Start and stop a temporary postgres for testing  https://hackage.haskell.org/package/tmp-postgres-0.3.0.1 (JonathanFischoff)
13:45:20 <maralorn> iqubic: There is a link to the log of this channel in the topic. (Since you seemed disappointed that you missed that.)
13:48:43 <sicklorkin> What's the canonical way to deal with apis that return inconsistent types for the same field? In my case sometimes its' text and sometimes it's a number.
13:49:18 <sicklorkin> eitherDecodeLenient?
13:50:42 <pigmej[m]> iqubic works with nix too
13:51:04 <pigmej[m]> https://github.com/jyp/dante/blob/master/dante.el#L103
13:53:01 <c_wraith> sicklorkin: yelp at the provider. :P
13:53:16 <c_wraith> *yell
13:54:45 <c_wraith> sicklorkin: more practically, parse it to a sum type that covers all the options. 
13:55:00 * hackage joint 0.1.1 - Trying to compose non-composable  https://hackage.haskell.org/package/joint-0.1.1 (iokasimovmt)
13:56:16 <sicklorkin> c_wraith: +1
13:56:20 <EvanR> data CrazyResultAPI = CRAPText Text | CRAPNum Int | CRAPBadResult ByteString
13:57:02 <EvanR> you could make several types to be more specific about the possibilities
13:57:28 <EvanR> but it's a slippery slope because... reasons
16:28:30 * hackage brick 0.49 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.49 (JonathanDaugherty)
16:57:26 <iqubic> So HIE is still really brittle? Is that an issue?
17:06:00 <iqubic> What do people think about hasklig?
17:07:00 * hackage canon 0.1.1.3 - Arithmetic for Psychedelically Large Numbers  https://hackage.haskell.org/package/canon-0.1.1.3 (grandpascorpion)
17:09:21 <MarcelineVQ> You didn't ask that exactly but you did ask about that 5 weeks ago :>
17:11:12 <iqubic> I recall. I don't know where the logs are, but I'd like too see what people think.
17:11:27 <iqubic> I also didn't think the logs from 5 weeks ago were still around.
18:01:14 <MarcelineVQ> Little question about holes and reuctions of type families if someone has time: https://gist.github.com/MarcelineVQ/47068845db53a1beb98647c0486e08e1
18:10:33 <dmwit> MarcelineVQ: :kind! TensorRank (SS (SS SZ)) Char
18:10:51 <dmwit> I don't know of a way to have GHC do this in its error message.
18:18:52 <MarcelineVQ> yeah :kind! can tell me but I was hoping for an option to reduce the types for me especially when there's no type variables in sight. Maybe this sort of thing sidetracks into the old discussion about where/when it makes sense to say String vs [Char], idk
18:40:21 <steve-chavez> Hello. I'm having a difficulty with Control.Lens. I have this working: row ^? L.nth 0 . L.key "Plan" .  L.key "Plan Rows" . L._Integral
18:41:35 <steve-chavez> But now I have "row" wrapped in a Maybe. How can I apply ^? inside the row now?
18:42:01 <steve-chavez> Something like: row <$> (^? L.nth 0 . L.key "Plan" .  L.key "Plan Rows" . L._Integral)
18:43:35 <steve-chavez> Or `L._Integral .  L.key "Plan Rows" .  L.key "Plan" . L.nth 0 . (^?)) <$> row` 
18:43:53 <steve-chavez> Don't work.
18:58:22 <dmwit> Wow, the error reporting in cabal-install 2.4.1.0 is really bad.
18:58:40 <dmwit> MarcelineVQ: Yes, I believe that is essentially the question.
18:59:09 <dmwit> If you write a type signature yourself, GHC tries really hard to keep it exactly as you wrote it.
18:59:26 <MarcelineVQ> maybe there's an fprint-* for type reducing then, I'll have to check later the manual isn't loading for me just now
18:59:34 <dmwit> That includes not expanding type aliases or families; it figures you had a reason not to expand them yourself.
19:00:47 <dmwit> I suspect if you had, for example, a `class Dec a where dec :: TensorRank a Char -> Int` and wrote an `instance Dec (SS (SS SZ)) where dec k = _`, it would indeed expand the type family.
19:01:27 <dmwit> i.e. put it in a situation where it inferred the type you want rather than being told it by you.
19:02:34 <dmwit> steve-chavez: What does "apply ^? inside the row" mean?
19:04:24 <dmwit> (Or: what are you *hoping* will happen if one of those prisms tries to access a key that isn't there or whatever?)
19:04:29 <iqubic> test = id id id id id id id id id id id id id id id id id id id id id id id id id id id 234
19:04:33 <iqubic> > test = id id id id id id id id id id id id id id id id id id id id id id id id id id id 234
19:04:35 <lambdabot>  <hint>:1:6: error:
19:04:35 <lambdabot>      parse error on input â€˜=â€™
19:04:35 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
19:04:46 <iqubic> > id id id id id id id id id id id id id id id id id id id id id id id id id id id 234
19:04:53 <lambdabot>  mueval-core: Time limit exceeded
19:05:05 <iqubic> WHAT THE HECK!?!?!
19:05:24 <dmwit> \bot has been having some trouble spinning up its mueval core quick enough to survive a timeout.
19:05:38 <dmwit> I believe the timeout length has been bumped a few times, but it doesn't really seem to be helping.
19:07:18 <iqubic> > id 5
19:07:21 <lambdabot>  5
19:07:31 <iqubic> > id id id id id id id id 5
19:07:34 <lambdabot>  5
19:08:02 <iqubic> Yeah, but that long string of ids crashed ghc when I tried type checking it.
19:09:06 <steve-chavez> dmwit: Hey, I figured it out. I needed _Just(from Control.Lens.Combinators) applied.
19:09:07 <MarcelineVQ> it's something to do with typechecking the chain of id's iirc, though :t doesn't suffer from the issue
19:09:42 <dmwit> iqubic: Yes, it's well-known that HM type inference is asymptotically doubly-exponential. This is a particularly simple example that hits the (singly-)exponential regime of that.
19:09:55 <iqubic> I did not know that.
19:09:56 <MarcelineVQ> ah the inference
19:12:26 <dmwit> FWIW it doesn't crash here, though it does push the memory residence up to 37GB. ^_^
19:15:45 <iqubic> dmwit: Add more id.
19:17:52 <dmwit> Yes, I know how "exponential" works. Mostly just boasting about how much RAM I have.
19:18:37 <MarcelineVQ> almost enough to compile agda
19:25:09 <threewood> What's a practical/non-contrived example of a multi-parameter type class that doesn't have functional dependencies?
19:26:47 <wroathe_> @dmwit where are the performance characteristics of HM type inference documented, that you've seen?
19:26:47 <lambdabot> Unknown command, try @list
19:27:15 <nshepperd2> threewood: Coercible
19:28:54 <threewood> nshepperd2:  Yeah, that's true.  Thanks
19:29:40 <nshepperd2> also, MVector and Vector from the `vector` package
19:32:33 <threewood> nshepperd2: Hmmm, Vector seems to be single parameter: 
19:32:34 <threewood> class (BasicVector v, Num v, Fractional v) => Vector v
19:38:30 <nshepperd2> I mean https://hackage.haskell.org/package/vector-0.12.0.3/docs/Data-Vector-Generic.html#t:Vector
19:38:54 <slack1256> With extension in mind, what interpreted language has a good binding/library support on haskell to enable a plugin interface on a haskell app?
19:39:05 <threewood> nshepperd2: Ah, thanks. 
19:39:19 <slack1256> I am doing a kind of vector graphic editor, but I would like people to be able to do scripts.
19:43:25 <rajivr___> I am new to Haskell. I would like to confirm my intuition that a function type  can never have an instance of  `Eq` typeclass. So the only way to test if two functions are equal (and other properties such as associativity) would be to feed the function values with a value and check the result?
19:44:02 <captjakk> yes
19:44:22 <captjakk> it's also why Set isn't a Monad
19:45:19 <rajivr___> captjakk:  Thanks! :-) I've not get gotten to understanding Monads yet. Just wanted to make sure that there was nothing subtle going on.
19:45:42 <captjakk> yeah the issue is that there is no computationally tractable way to compute equality of functions
19:46:01 <captjakk> and since Eq is about equality by value, you can't cheat with reference equality either
19:46:24 <threewood> "a function type  can never have an instance of  `Eq` typeclass."   Is that strictly true?  You could implement Eq (Bool -> Int) pretty easily, couldn't you?  
19:46:57 <threewood> Or are there rules that you can't do that?
19:50:36 <dmwit> wroathe: Oh, goodness. I don't even know.
19:51:22 <dmwit> slack1256: lua
19:52:16 <wroathe> I only ask because I've been able to find surprisingly little information on concrete well-studied algorithms around the HM type system
19:53:09 <wroathe> Which I attributed to it being relatively cutting-edge as far as algorithms are concerned
19:53:15 <nshepperd2> you can write an Eq instance for a function type like Bool -> Int. but such an instance would indeed involve passing values and comparing the outputs
19:54:26 <nshepperd2> f == g  =  [f False, f True] == [g False, g True]
19:54:49 <dmwit> threewood: http://hackage.haskell.org/package/universe-reverse-instances-1.1/docs/Data-Universe-Instances-Eq.html
19:55:11 <dmwit> N.B. instance (Finite a, Eq b) => Eq (a -> b)
19:55:49 <threewood> dmwit: Thanks.  Yeah I'd forgotten
19:56:36 <dmwit> rajivr___: So, to conclude, you are wrong that a function type cannot have an `Eq` instance. But you are correct that the only way to test if two functions are equal would be to feed the function values and check the result.
19:56:48 <dmwit> (And this is what correct Eq instances do.)
19:58:57 <rajivr___> dmwit:  Thanks  for the pointer. :-) I now see that.
20:00:30 <dmwit> wroathe: Looks like Wikipedia's got your back. https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system#cite_note-5
20:00:50 <nshepperd2> (But you could use pointer equality as an optimization! reallyUnsafePtrEquality f g || [f False, f True] == [g False, g True])
20:01:18 <dmwit> I was wrong about doubly-exponential!
20:02:10 <dmwit> nshepperd2: I think that's probably not a correct optimization. In particular, it may make some checks terminate when they oughtn't.
20:02:17 <wroathe> yeah, I was going to say...
20:02:32 <dmwit> (That's the usual complaint about using reallyUnsafePtrEquality as a fast-path for Eq instances.)
20:03:18 <wroathe> I had read that article before, but I didn't see any mention of exponential time
20:03:43 <dmwit> It is hidden in a note.
20:03:47 <iqubic> :t reallyUnsafePtrEquality
20:03:48 <lambdabot> error:
20:03:48 <lambdabot>     Variable not in scope: reallyUnsafePtrEquality
20:03:56 <iqubic> What is the type of that?
20:04:04 <dmwit> ?hoogle reallyUnsafePtrEquality
20:04:05 <lambdabot> GHC.Exts reallyUnsafePtrEquality# :: () => a -> a -> Int#
20:04:05 <lambdabot> GHC.Prim reallyUnsafePtrEquality# :: a -> a -> Int#
20:04:05 <lambdabot> GHC.PrimopWrappers reallyUnsafePtrEquality# :: a -> a -> Int#
20:04:14 <iqubic> Huh?!?!
20:04:29 <dmwit> It could probably even be generalized to `a -> b -> Int#`.
20:04:31 <nshepperd2> I don't think it's usually a problem for something to sometimes return the correct answer instead of âŠ¥
20:05:15 <dmwit> nshepperd2: That depends a lot on what you mean by "correct answer". In this particular case, you would be violating referential transparency.
20:05:26 <nshepperd2> it does make it kind of unpredictable though (non referentially transparent) so there's that
20:06:19 <dmwit> (For me, it's pretty hard to defend non-referentially-transparent behavior as the correct answer. Not impossible, but v. hard.)
20:12:50 <threewood> Aren't there examples of referentially transparent functions that you can write that require thunk pointer comparison?
20:13:20 <nshepperd2> well... i would say it's rare for relevant program behaviour to rely on pure functions returning âŠ¥
20:14:50 <nshepperd2> the more likely problem is if you start relying on pointer equality to short circuit a non-terminating comparison, then you change something in your program and it stops working and you are sad 
20:15:27 <threewood> nshepperd2: I think the example I was thinking of was distinguishing between (const True :: Bool -> Bool) and (\x :: Bool -> if x then True else False)
20:15:32 <threewood> Or something like that
20:15:55 <nshepperd2> solution: MORE DAKKA^W^W (flipCoin () && reallyUnsafePointerEquality f g) || compareNormally f g
20:16:08 <threewood> heh
20:17:06 <threewood> Though you may need more than thunk comparison to solve that problem I mentioned...
20:25:10 <dmwit> threewood: I sort of doubt there is any referentially-transparent function that uses reallyUnsafePtrEquality in an interesting way.
20:25:46 <nshepperd2> I mean, you can use it in a referentially transparent way
20:25:57 <dmwit> As for distinguishing `const True` and your strangely-spelled `id`, that seems sort of easy to me? Not sure I understand that example.
20:26:08 <dmwit> nshepperd2: Can you? How?
20:26:21 <nshepperd2> as long as you confine its use to a situation where you know the comparison would terminate
20:27:09 <dmwit> How can you know that from inside the implementation of the function we're imagining writing?
20:27:29 <nshepperd2> you can't
20:27:35 <threewood> dmwit:  Should have been (\x :: Bool -> if x then True else True) -- sorry
20:27:40 <nshepperd2> but you can use that function as an implementation detail of something else
20:28:11 <threewood> dmwit: The problem is to distinguish the constant function that looks at its argument from the one that doesn't
20:28:21 <dmwit> Okay, but that's not the question, is it? " Aren't there examples of referentially transparent functions that you can write that require thunk pointer comparison?" is the question.
20:28:24 <nshepperd2> for the last advent of code I implemented hashlife using StableName hashing (basically pointers but with some magic so that GC can still move the values) for hash consing
20:29:08 <dmwit> Oh, I see what you're claiming.
20:29:09 <dmwit> Okay!
20:29:12 <dmwit> Cute. =)
20:30:06 <dmwit> threewood: I guess ($undefined) distinguishes them, no?
20:30:27 <nshepperd2> =)
20:30:49 <threewood> dmwit: The question is can you determine whether they're equal and continue computing
20:31:07 <threewood> or just identify which one you have
20:31:13 <threewood> but without bottoming out
20:33:42 <dmwit> I believe the answer to that is no.
20:33:48 <dmwit> (Except by resorting to unsafe*.)
20:33:53 * nshepperd2 . o O (and [spoon (f x) == spoon (g x) | x <- [undefined, False, True]])
20:33:56 <threewood> dmwit: I agree
20:37:28 * nshepperd2 doesn't actually condone using 'spoon', except for the purpose of being amused by the names of its functions
20:51:11 <threewood> nshepperd2: (MVector v a) is a bit weird because it seems to only ever use (v a) as a type.  Never (v b) for some b.  It looks like you could re-write it to be (MVector v' a) with a functional dependency of a on v'.  
21:17:30 <masaeedu[m]> anyone been using hie with cabal 3?
21:55:00 * hackage viewprof 0.0.0.29 - Text-based interactive GHC .prof viewer  https://hackage.haskell.org/package/viewprof-0.0.0.29 (MitsutoshiAoe)
23:17:03 <contrun[m]> Any convenient way to run example with cabal and stack?
23:18:02 <Rembane> contrun[m]: It's hard to say without more context. What are you trying to do? 
23:21:17 <contrun[m]> This is actually context-free. `cargo`, for example, provides `cargo run --example demo`. I am wondering if cabal or stack can do that. That is my question. The context, if that is relevant, is I am trying to understand how ghc generics works. So I am playing with this library. https://github.com/soenkehahn/generics-eot I want to run the examples.
23:23:59 <[exa]> contrun[m]: usually I somehow get into a running repl with the library loaded (cabal repl, something similar with stack) and :load or run the examples there manually
23:27:13 <[exa]> (not sure at all whether haskell packaging even recognizes examples as separate objects.. these should be part of documentation so would probably belong closer to haddock)
23:28:44 <contrun[m]> [exa]: Thank you for the advice. ghci is great. I don't think haskell packaging recongize examples. I hope haskell tooling is more ergonomic.
23:34:46 <[exa]> contrun[m]: I don't know if this property has a name, but because of language purity the haskell examples are usually kindof more self-contained and thus likely to be useful in the interpreter
23:41:30 * hackage mssql-simple 0.5.0.1 - SQL Server client library implemented in Haskell  https://hackage.haskell.org/package/mssql-simple-0.5.0.1 (tkmsm)
