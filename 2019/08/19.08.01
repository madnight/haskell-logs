00:00:05 <davean> I often leave "???" in my code for the processing inside the flows.
00:00:14 <davean> and fill thta in as a second step
00:05:33 <Cale> davean: Are you familiar with monoidal categories? You might like the abstraction just based on how you think about computation.
00:05:51 <davean> Cale: nope! I'd be interested in looking though.
00:09:25 <Cale> It's a bit of a mouthful to write out the definition, but the idea is basically that you have this particular "tensor product" bifunctor (which you can think of as being an abstraction of the pair type), and it needs to be associative and have a unit (up to explicit isomorphisms), and then on top of that you can add in things like a diagonal map A -> A (x) A, or symmetry A (x) B -> B (x) A and such
00:09:51 <Cale> http://hackage.haskell.org/package/categories-1.0.7 formulates a Haskell-y version of the idea
00:10:43 <Cale> http://hackage.haskell.org/package/categories-1.0.7/docs/Control-Category-Cartesian.html
00:10:48 <Cale> ^^ diag is your dup
00:12:18 <Cale> It's good for explicitly describing how things are wired up, it's annoying because you have to explicitly describe how things are wired up :D
00:12:20 <davean> yah, diag/dup are clear.
00:12:38 <davean> making my way through the monoidal though.
01:41:22 <absence> :t void -- is there a similar "a -> f ()" lurking in some library?
01:41:25 <lambdabot> Functor f => f a -> f ()
01:41:57 <Rembane> :t void . pure 
01:42:00 <lambdabot> Applicative f => a -> f ()
01:42:06 <Rembane> absence: ...perhaps?
01:43:47 <phadej> maybe absence is looking for
01:43:51 <phadej> :t (>>)
01:43:54 <lambdabot> Monad m => m a -> m b -> m b
01:43:55 <phadej> or 
01:43:56 <pyan> Wait, how can you create a value of type f () only knowing that f is a Functor?
01:43:59 <phadej> :t (*>)
01:44:03 <lambdabot> Applicative f => f a -> f b -> f b
01:44:05 <pyan> Oh, I misread.
01:44:21 <pyan> No, wait. I did not.
01:44:36 <pyan> ‚ÄúFunctor f => a -> f ()‚Äù simply seems impossible to satisfy.
01:45:16 <Rembane> pyan: If you run that function in a context where f is known, it is possible.
01:45:35 <pyan> Yeah, but then it would not be ‚Äúforall f.‚Äù anymore.
01:45:55 <pyan> Or at least there would be more constraints on it than just Functor.
01:46:10 <Rembane> Which constraints do you think are needed?
01:46:48 <pyan> Something that, at the very least, rules out ‚Äúdata Foo a‚Äù (assuming -XEmptyDataDecls).
01:46:53 <pyan> Which is a perfectly fine Functor.
01:46:56 <absence> i was essentially looking for a "void . pure" combination. i guess it's too simple to have a separate function
01:47:18 <absence> thanks!
01:50:21 <Rembane> absence: I find it harder to give a good name than to compose the two functions. 
01:51:10 <Rembane> pyan: That is indeed true, but data Foo a is not an instance of the typeclass Functor which is the only thing the typechecker (and the runtime system) is concerned about in this case.
01:52:29 <absence> somewhat related, traverse can run an effect when a Maybe is Just. is there a trick to run one when it's Nothing instead? if it was Either i could use bitraverse, but of course there's no instance for Maybe
01:53:01 <Rembane> absence: I use fromMaybe for that. 
01:53:06 <Rembane> :t fromMaybe
01:53:08 <lambdabot> a -> Maybe a -> a
01:53:28 <dminuoso> 10:52:26          pyan | [08:43:35] Wait, how can you create a value of type f () only knowing that f is a Functor?
01:53:42 <dminuoso> pyan: In principle that is possible if f is also Pointed.
01:53:50 <Rembane> > fromMaybe (putStrLn "Nothing") void
01:53:53 <lambdabot>  error:
01:53:54 <lambdabot>      ‚Ä¢ Couldn't match expected type ‚ÄòMaybe (IO ())‚Äô
01:53:54 <lambdabot>                    with actual type ‚Äòf0 a0 -> f0 ()‚Äô
01:54:12 <Rembane> > fromMaybe (putStrLn "Nothing") Nothing
01:54:15 <lambdabot>  <IO ()>
01:54:59 <absence> > fromMaybe (putStrLn "Nothing") (Just 123)
01:55:02 <lambdabot>  error:
01:55:02 <lambdabot>      ‚Ä¢ No instance for (Num (IO ())) arising from the literal ‚Äò123‚Äô
01:55:02 <lambdabot>      ‚Ä¢ In the first argument of ‚ÄòJust‚Äô, namely ‚Äò123‚Äô
01:55:41 <Rembane> Good point, I missed a layer. I really need my coffee. I'm back in a bit. 
01:56:53 <absence> needs some more i guess :) "maybe effect (void . pure)" does the trick, but it's a bit of a mouthful, so was just curious if there's a nifty trick to get around it
02:13:04 <dminuoso> absence: ‚åúfromMaybeM effect‚åù could get you half the way.
02:13:17 <dminuoso> e.g. ‚åúvoid . fromMaybeM effect‚åù
02:14:20 <dminuoso> If you write a lot of monadic code, things like maybeM or fromMaybeM can be useful.
02:16:40 <dminuoso> I suppose for your code it'd be ‚åúfromMaybe effect . void‚åù rather
02:16:56 <dminuoso> Err. ‚åúfromMaybeM effect . void‚åù
02:30:09 <jle`> absence: the best way for that is probably just manuall case statements/pattern matching
02:30:12 <jle`> honestly
02:30:44 <jle`> case myThing of Just x -> putStrLn x; Nothing -> putStrLn "Nope"
02:31:12 <jle`> i can't think of anything more readable
02:36:02 <phadej> putStrLn $ fromMaybe "Nope" myThing
02:43:43 <contrun[m]> Any one has success in https://blog.latukha.com/NixOS-HIE-Emacs/? Here is my emacs config.  https://paste.ubuntu.com/p/zZXmfxHGvK/ I got  Process hie stderr finished
02:43:44 <contrun[m]> error: getting status of '/home/e/Local/cql/hie-wrapper --lsp -d -l /tmp/hie.log': No such file or directory
02:43:45 <contrun[m]> error: getting status of '/home/e/Local/cql/hie-wrapper --lsp -d -l /tmp/hie.log': No such file or directory
02:44:04 <contrun[m]> I really do not understand why my hie-wrapper is expanded to /home/e/Local/cql/hie-wrapper
02:58:05 * contrun[m] uploaded an image: screenshot-2019-08-01-17-57-19.png (11KB) < https://matrix.org/_matrix/media/v1/download/matrix.org/nhVXFAQDKniwWpgZXKUEndoc >
02:58:27 <contrun[m]> Am I the only one who always get  import module error on hie?
02:59:09 <contrun[m]> I really want to know how to set up hie on nix. I've tried a few time without much success.
03:41:29 <freefu> how can I fix `<command line>: can't load .so/.DLL for: libGL.so (libGL.so: cannot open shared object file: No such file or directory)` from cabal new-build? I tried `--extra-lib-dirs` to point it to the right place, but the same error happens
04:08:03 <petersen> freefu: the file is there?
04:09:47 <freefu> petersen: it is
04:12:13 <sicklorkin> freefu: what does `whereis libGL.so` say?
04:15:41 <sicklorkin> Also, `ldd path/to/libGL.so`; check for any missing paths
04:18:05 <sicklorkin> if everything still llooks correct then try `LD_LIBRARY_PATH:/dir/where/libGL/is:$LD_LIBRARY_PATH cabal new-build`
04:21:51 <freefu> sicklorkin: that did it, thanks. I think this is the cause: https://github.com/NixOS/nixpkgs/pull/37369
04:25:43 <sicklorkin> freefu: Are you running cabal under nix-shell?
04:28:49 <freefu> sicklorkin: I did try with `nix-shell -p libGL libGL.dev`
04:31:00 <contrun[m]> freefu: It could be the problem of pkg-config. Try nix-shell -p libGL libGL.dev pkg-config
04:44:40 <pzp> I'm trying to gain a more intuitive understanding of why the ST monad is safe. I've read and understood the rank-2 types explanation but that's really explaining the implementation details that enforce the constraint that makes "local" mutation safe rather than the constraint itself.
04:46:31 <merijn> pzp: Well, ST only admits memory mutation which (in a single-threaded setting) is deterministic
04:46:51 <merijn> pzp: So given the same input, the function well perform the exact same mutation steps and produce the exact same result
04:47:40 <merijn> pzp: Since no one else can observe the mutations going on (that's enforced by the Rank2 stuff), no one outside the function can even tell mutation is happening, they just see "function produces same results when giving same inputs" which is what pure meant in the first place :)
04:48:00 <pzp> My current understanding is that any function that has pure-valued inputs can safely create an empty state, mutate it, discard it, and return a pure value
04:49:15 <pzp> The whole ST monad thing is just a compositional way of building up a mutable function that starts with the empty state and returns a pure value
04:49:51 <pzp> Of course I am probably omitting some of the finer details, but is that understanding on track?
04:50:28 <merijn> pzp: And to enforce that we can't leak part of our private state to functions that we call from within our ST "thread"(execution block, whatever...)
04:52:35 <pzp> Right, that last point is important. I'm not sure if my simplified model captures that
05:04:21 * jlamothe accidentally fork bombed  himself. :/
05:06:50 <pzp> So suppose we make a type `State` that has no inhabitants and provide a set of `State -> State` primitives for creating/mutating references within the given `State`. Whenever a `State -> pureValue` function is called, the runtime will supply that function with a clean state. Is my proposed model as safe as the ST monad for implementing local mutation?
05:20:31 <merijn> pzp: I think so? I mean, it sounds like basically the same as what ST does
05:22:50 <int-e> nah, that doesn't protect against a state being forked
05:23:12 <int-e> consider f s = f1 s + f2 s, where f, f1, f2 : State -> Int
05:24:17 <int-e> (hmm, needs a bit more. imagine f, f1 and f2 also take a reference to some mutable variable)
05:24:43 <int-e> And then do f r s = f1 r s + f2 r s, where r is that reference.
05:25:39 <int-e> ST prevents this by never exposing the state token but hiding it in a monad.
05:29:00 <hyperisco> I don't know how ST is implemented but I'd think it doesn't need to hide anything
05:29:03 <int-e> pzp: On the other hand, if you look inside GHC.Base you'll find plenty of functions with that pattern.
05:29:10 <int-e> :t GHC.Base.readArray#
05:29:13 <lambdabot> GHC.Prim.MutableArray# d a -> GHC.Prim.Int# -> GHC.Prim.State# d -> (# GHC.Prim.State# d, a #)
05:29:13 <hyperisco> If you have ST at two different state types then you cannot use them together
05:29:21 <merijn> hyperisco: It's implemented as State#
05:29:31 <hyperisco> Which is transparent
05:29:34 <merijn> hyperisco: Which is the underlying State monad used by both ST and IO
05:30:37 <int-e> hyperisco: In ghc, ST is built on top of such primitives that thread a State# s  token (in the suggested  State# s -> State# s  fashion). There's a  State# s  token, and it *is* hidden inside the  ST s a  type.
05:31:09 <fog> the problem with trying to split mixins over two packages (core and use) is that; the backends needed by the core package should be exported incase the use package needs to use these for its own mixins.. and that the core package seems not to be able to export the various module renamings specified by the mixins. ie, they can only be used by eg an 
05:31:10 <fog> internal exe
05:31:13 <hyperisco> I have a suspicion this token is useless
05:31:27 <int-e> (I don't think that there's any deep reason for having the (phantom) s type attached to the State# token... it gives more compile-time errors for incorrect code.)
05:31:38 <hyperisco> i.e. even if it leaked the state token it wouldn't matter
05:32:01 <fog> so you cant "recompile" the core module from the usecase .cabal...
05:32:17 <int-e> hyperisco: It would matter.
05:32:59 <int-e> hyperisco: Well, it would matter if you could use it to start a computation. Which with the public interface you can't... I guess.
05:34:05 <hyperisco> Last I knew this sort of token passing is only to explain referential transparency
05:34:12 <int-e> (it's worth pointing out that  unsafePerformIO  basically conjures a  State# RealWorld  token out of thin air, and passes it to the function embedded in the  IO a  value.)
05:35:05 <int-e> (And it's also worth noting that we're discussing implementation details of GHC's runtime right now.)
05:37:52 <int-e> The state tokens don't exist at runtime, maybe that's what you mean by "useless". But they are essential for the compiler not to mess up the evaluation order of IO and ST actions (they introduce data dependencies), so they are really far from useless.
05:38:36 <hyperisco> I mean "useless" in that they do not leak anything about the actual state.
05:40:00 <merijn> hyperisco: Well, it's important because if you can conjure up a token, you can pass it to two different computations (as int-e mentioned earlier) and suddenly the order in which those functions are evaluated becomes important, which it wasn't before
05:40:04 <int-e> Oh. Yes, that's what I realized earlier when I added another argument to my f, f1 and f2 functions.
05:40:48 <int-e> (Though I suppose you *could* attach information to the state token. But GHC doesn't.)
05:41:37 <hyperisco> Where do I pass it? Are you additionally assuming I can unwrap an ST?
05:41:50 <int-e> :t GHC.Exts.myThreadId# -- or maybe it does!
05:41:52 <lambdabot> GHC.Prim.State# RealWorld -> (# GHC.Prim.State# RealWorld, GHC.Prim.ThreadId# #)
05:42:37 <int-e> (Tricky one. You can build several mentals here, some with information attached to the state token, some without.)
05:43:19 <int-e> hyperisco: "Well, it would matter if you could use it to start a computation. Which with the public interface you can't... I guess."
05:44:58 <hyperisco> You can have the lock or the key but never both.
05:46:13 <int-e> hyperisco: Well the starting point was working with State -> State and then you'd have both.
05:46:35 <hyperisco> Wasn't here for that. With side effects?
05:47:44 <int-e> hyperisco: Oh I didn't realize, see privmsg
05:49:10 <hyperisco> Thanks. I don't fully understand the description, but my guess is "no". The idea of a phantom State type is fine, but the referential transparency is the problem.
05:49:30 <hyperisco> So that is readily solved with choosing  State -> IO State  functions or even  State -> ST s State  functions, whichever
05:51:14 <hyperisco> I fear what GHC might do in optimisations about a phantom type though‚Ä¶ I wager there is a better way to do that
05:51:22 <hyperisco> if the intent was to have State represent some foreign value
05:54:10 <hyperisco> (f x, f x)  lets say f increments a mutable int and returns the int, then what does this 2-tuple reduce to?
05:54:28 <hyperisco> I am sure that is the sort of problem you were describing int-e.
05:54:58 <hyperisco> referential transparency says it must be (y, y) for some y
05:57:40 <hyperisco> I suppose there are some ways to have the execution race and produce (y, y) :P
06:14:37 <fog> here is as close as i can get to a working distributed backpack over 2 packages; https://github.com/fog-hs/rotateDist2
06:15:18 <fog> https://raw.githubusercontent.com/fog-hs/rotateDist2/master/rotate%20use/rotateUse.cabal
06:15:19 <fog> https://raw.githubusercontent.com/fog-hs/rotateDist2/master/rotate/rotate.cabal
06:16:26 <fog> it says;
06:16:26 <fog> Error: Non-library component has unfilled requirements: LinearRotate VectRotate In the stanza executable rotate-example
06:26:53 <fog> I would expect these to be provided by rotate.cabal; library rotate-backpack ...  exposed-modules: LinearRotate,VectRotate
06:27:35 <fog> maybe thats just an "internal library" ?
06:29:52 <c4droid> Hi, I want to learn and write the haskell anytime, anywhere, using the termux app. I don't know how to setup the environment, Does anyone's know how to setup environment?
06:31:05 <fog> thats a linux emulator for android right?
06:31:21 <c4droid> Yeah.
06:31:31 <fog> do you know which version of linux it runs?
06:31:57 <[exa]> I thought it's just a ssh client?
06:31:57 <c4droid> My phone is aarch64 architecture
06:33:41 <c4droid> And running linux 4.9.97
06:33:56 <fog> yeah but which linux?
06:34:04 <Entroacceptor> I don't think you'll have too much luck with that. 
06:34:16 <c4droid> Emmm..
06:34:22 <[exa]> c4droid: try this: https://play.google.com/store/apps/details?id=tech.ula
06:34:36 <[exa]> c4droid: it provides debian packaging that you can use to get ghc&pals
06:34:47 <[exa]> you do _not_ want to compile ghc on a phone.
06:34:53 <hyperisco> c4droid, a pencil and paper is quite portable and doesn't even require an outlet or battery!
06:35:27 <fog> yeah, debian at least is a linux
06:35:38 <hyperisco> And yes I am serious.
06:36:03 <fog> so was I! is termux even a linux!?
06:36:26 <fog> that UserLAnd looks much better
06:36:40 <fog> then you can get an actual linux and install haskell on it no bother
06:36:50 <c4droid> Ok.
06:37:33 <c4droid> fog: Thanks
06:37:37 <fog> but just to be sure, did you try apt-get ?
06:38:01 <fog> normally on linux you would just write;
06:38:01 <fog> sudo apt-get install haskell-platform
06:38:15 <fog> you could try that on termux and see if it works
06:38:34 <c4droid> The termux apt repository not haskell-platform
06:39:03 <fog> right yeah that makes sense, sounds like its its ownd kind of linux
06:39:13 <fog> normally its best to go with the main linux distros
06:39:25 <fog> they eg have better supported apt repos
06:39:38 <c4droid> You are right.
06:41:31 <fog> let us know how you get on
06:41:45 <fog> i would be interested to see if you can run a yesod server
06:42:29 <fog> or even to do HTTP-Simple requests
06:44:13 <fog> its not exactly compiling a haskell program to APK, but if it can let you write web services in haskell for android just to run in ghci then thats a start
07:14:15 <AWizzArd> Is there any Haskell lib for programming AMD GPUs with https://rocm.github.io/ ?
08:01:31 <fog> i really want to solve this issue about trying to provide a backpack to an external library
08:01:43 <fog> is anyone around who could help/
08:01:44 <fog> ?
08:06:57 <fog> hmm, changing from cabal configure to cabal new-configure gives a different error message
08:07:26 <fog> now when compiling this;
08:07:27 <fog> https://github.com/fog-hs/rotateDist2/blob/master/rotate%20use/rotateUse.cabal
08:07:41 <fog> it says;
08:07:41 <fog> unknown package: rotate (dependency of rotateUse)
08:10:06 <fog> i have done "cabal new-install" in the directory; https://github.com/fog-hs/rotateDist2/tree/master/rotate
08:10:18 <fog> why cant it "see" the installed library rotate?
08:11:03 <fog> actually, it was;
08:11:04 <fog> cabal new-install --lib 
08:11:33 <fog> which it seemed to need because there is no executable in; https://github.com/fog-hs/rotateDist2/blob/master/rotate/rotate.cabal
08:12:22 <fog> it having been moved to the rotateUse package in an attempt to backpack the imported module
08:13:19 <fog> when comparing with the working version all contained in one package; https://github.com/fog-hs/rotate
08:14:14 <dmwit> Under normal circumstances, you wouldn't use new-install at all.
08:14:38 <dmwit> Just new-build, with a suitable cabal.project file pointing at any directories that have packages not already available from Hackage.
08:15:21 <dmwit> (The way you did should be fine, I guess, just informing you of options you have for future use.)
08:16:01 <dmwit> I haven't played with backpack at all, though, so I can't help you with the issue you're seeing.
08:20:53 <nil> hi, what's the easiest way to generate the infinite list ["a", "b", ..., "z", "aa", "ab", ..., "zz", "aaa", ...] ?
08:24:17 <Taneb> > let alpha = [1,2,3]; x = [] : ((++) <$> x <*> map pure alpha); in take 10 x
08:24:20 <lambdabot>  [[],[1],[2],[3],[1,1],[1,2],[1,3],[2,1],[2,2],[2,3]]
08:24:24 <fog> % sequence $ replicate 3 [1,2,3]
08:24:25 <yahb> fog: [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2,1,1],[2,1,2],[2,1,3],[2,2,1],[2,2,2],[2,2,3],[2,3,1],[2,3,2],[2,3,3],[3,1,1],[3,1,2],[3,1,3],[3,2,1],[3,2,2],[3,2,3],[3,3,1],[3,3,2],[3,3,3]]
08:25:43 <fog> > let alpha = [1,2]; x = [] : ((++) <$> x <*> map pure alpha); in take 10 x
08:25:46 <lambdabot>  [[],[1],[2],[1,1],[1,2],[2,1],[2,2],[1,1,1],[1,1,2],[1,2,1]]
08:25:51 <fog> hmm
08:25:55 <sicklorkin> nil: cycle [0..]
08:26:18 <fog> > take 10 $ cycle [0..]
08:26:21 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
08:26:28 <sicklorkin> not sure if a,aa,aaa is important or not
08:26:40 <fog> > take 10 $ cycle [1,2]
08:26:45 <lambdabot>  [1,2,1,2,1,2,1,2,1,2]
08:26:52 <fog> what, thats not right at all
08:26:59 <sicklorkin> fog: why?
08:27:10 <fog> well its got the wrong type for a start
08:28:01 <nil> sicklorkin: cycle [0..] is just [0..]
08:28:15 <nil> Taneb: i'll study this
08:28:22 <fog> when i try cabal new-configure i get;
08:28:22 <fog> (conflict: vect => vect:setup.Cabal>=1.6 && <1.25
08:28:49 <sicklorkin> nil: is it? I thought once it hit the maxBound it would start over
08:29:07 <nil> what maxBound?
08:29:13 <Taneb> sicklorkin: either way it's not what nil was asking for
08:29:18 <sicklorkin> :P
08:29:20 <Taneb> > maxBound :: Int
08:29:25 <lambdabot>  9223372036854775807
08:29:41 <Taneb> Might take a little while to get there
08:29:49 <Lycurgus> > maxBound :: Integer
08:29:54 <lambdabot>  error:
08:29:54 <lambdabot>      ‚Ä¢ No instance for (Bounded Integer)
08:29:54 <lambdabot>          arising from a use of ‚ÄòmaxBound‚Äô
08:30:18 <sicklorkin> > [0..] :: [Integer]
08:30:21 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
08:32:56 <nil> Taneb: that's a very interesting use of recursion
08:33:31 <Taneb> nil: sadly it winds up inefficient do to the association of (++)
08:33:39 <nil> yeah, i can imagine that
08:33:53 <Taneb> You can mitigate that a bit with dlists or similar
08:33:58 <nil> why not use (:) instead?
08:34:08 <Taneb> You don't get the same order
08:34:19 <nil> what if you reverse alpha?
08:34:51 <nil> > let alpha = [1,2,3]; x = [] : ((:) <$> reverse alpha <*> x); in take 10 x 
08:34:54 <lambdabot>  [[],[3],[3,3],[3,3,3],[3,3,3,3],[3,3,3,3,3],[3,3,3,3,3,3],[3,3,3,3,3,3,3],[3...
08:34:55 <Taneb> Using : makes the quickest moving place the beginning, reversing alpha makes the quickest moving place go backwards
08:35:00 <nil> ah, i see
08:35:34 <nil> i can't intuit what "quickest moving place" means
08:35:52 <Bish> is there a vim plugin to autoreload ghci?
08:35:57 <Bish> i might be to stupid to google, yes
08:35:58 <Taneb> nil: If you have "111", what's the next string?
08:36:11 <nil> normally, 112
08:36:23 <Taneb> So the last character is moving quicker than all the others
08:36:41 <Taneb> It changes every step, where the others change every n steps, n^2 steps, etc
08:36:49 <nil> right
08:38:27 <nil> > let alpha = [1,2,3]; x = [] : (flip (:) <$> x <*> alpha); in take 10 x
08:38:30 <lambdabot>  [[],[1],[2],[3],[1,1],[2,1],[3,1],[1,2],[2,2],[3,2]]
08:38:33 <nil> there :')
08:38:57 <Taneb> In that version, the quickest moving character is the first one
08:39:03 <Taneb> So the sequence is in a different order
08:39:07 <Taneb> That may be OK for you, thoguh
08:39:08 <nil> indeed
08:39:18 <nil> i can always map reverse
08:40:16 <nil> i guess it's efficiency vs. elegance
08:41:41 <t__> hi guys -- what documentation would you recommend for a complete beginner in haskell, with a big background in C and some ocaml like 15 years ago?
08:41:50 <Taneb> > let alpha = [1,2,3]; x' = [] : ((.) <$> x' <*> map (:) alpha); x = map ($ []) x'; in take 10 x
08:41:53 <lambdabot>  error:
08:41:53 <lambdabot>      ‚Ä¢ Couldn't match type ‚Äò[a0]‚Äô with ‚Äò[a1] -> c‚Äô
08:41:53 <lambdabot>        Expected type: [[a1] -> c]
08:42:03 <Taneb> > let alpha = [1,2,3]; x' = id : ((.) <$> x' <*> map (:) alpha); x = map ($ []) x'; in take 10 x
08:42:06 <lambdabot>  [[],[1],[2],[3],[1,1],[1,2],[1,3],[2,1],[2,2],[2,3]]
08:42:12 <Taneb> nil: how's that
08:42:27 <nil> oh bo
08:42:28 <nil> y
08:42:38 <Taneb> Using dlists to get O(1) snoc
08:42:54 <dmwit> > [1..] >>= flip replicateM ['a'..'z']
08:42:57 <lambdabot>  ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s"...
08:43:01 <dmwit> > [1..] >>= flip replicateM ['a'..'c']
08:43:04 <lambdabot>  ["a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aac",...
08:43:07 <sm[m]> t__: @where htac
08:43:21 <sm[m]> @where htac ?
08:43:21 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
08:43:22 <nil> i'm not familiar with dlists so i need time to understand this
08:43:34 <t__> sm[m]: i'll take a look, thank you
08:43:48 <nil> dmwit: woah.
08:44:13 <nil> i see how that works. i should have thought of it
08:45:41 <nil> thanks.
08:45:44 <Taneb> dmwit: my dlist solution seems to be more efficient, experimentally
08:45:57 <nil> oh
08:46:04 * dmwit nods agreeably
08:46:50 <Taneb> Although I guess if you're not trying to find the 10 millionth element or whatever it doens't matter so much
08:46:58 <fog> ok, i have got the error reproduced without any use of backpack, so now it is just a cabal issue
08:47:26 <dmwit> Actually, how did you test efficiency? If you tested by getting the n'th element only, you may get a different answer than if you get all of the first n elements.
08:48:19 <dmwit> Although even fully forcing I don't expect the replicateM version to be the most efficient. It doesn't make any attempt at sharing, really.
08:48:20 <fog> https://github.com/fog-hs/errorWithoutBackpack/tree/master/rotateNoBackpack
08:48:29 <Taneb> dmwit: getting n'th element
08:48:36 <fog> the error is;
08:48:37 <fog> Non-library component has unfilled requirements: Rotate
08:49:01 <dmwit> Yeah, okay, with getting just the n'th element, you don't pay the cost that people always forget with dlists: evaluating it twice costs twice as much.
08:49:34 <Taneb> I'd definitely forgotten that cost
08:49:40 <fog> in directory rotate i call; cabal new-install --lib
08:49:52 <dmwit> (I mean if `foo` is a dlist, evaluating `foo []` twice does the full work both times. This matters for your creation because although there's sharing in the creation of the dlists, your `map ($[])` essentially does this, meaning the sharing is wasted.)
08:50:15 <fog> and in directory "cabal use" i call; cabal install --libdir="rotateNoBackpack/rotate"
08:53:20 <dmwit> > let f xs xss = do stop <- [True, False]; if stop then xss else f xs (liftA2 (:) xs xss) in f "abc" [""]
08:53:23 <lambdabot>  ["","a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aa...
08:53:43 <dmwit> This one is careful about getting maximum sharing.
08:54:20 <Taneb> I can't immediately see how it works
08:54:40 <dmwit> > let f xs xss = xss ++ f xs (liftA2 (:) xs xss) in f "abc" [""]
08:54:44 <lambdabot>  ["","a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aa...
08:55:02 <dmwit> ^ same thing, but less obtuse
08:56:16 <Taneb> OK, nice, I like that
08:57:08 <nil> interesting. this looks a lot like the thing that generated ["", "3", "33", ...] earlier
08:57:14 <nil> except it works
08:57:24 <dmwit> ^_^
08:58:03 <nil> and i'm not sure i can see the difference. is it because you used liftA2 instead of <$> <*> ?
08:58:14 <dmwit> No, it's because I did xss ++ at the beginning.
08:58:53 <dmwit> Instead of [] :
08:59:20 <nil> ah
09:02:24 <dmwit> (That said, I do like liftA2 instead of <$> <*>. I think it more clearly indicates intent.)
09:02:28 <merijn> hmmm, there's no conduit function for composing a "Producer () a m r" with "a -> Conduit () b m r" or something like that?
09:02:36 <fog> is there anyone online that could help with a cabal issue?
09:02:42 <dmwit> (Then again I also like pure <*> <*> instead of <$> <*>.)
09:04:23 <hyperisco> > foldr (\x xs -> [[x]] <> map (x:) xs <> xs) [] "abc"
09:04:27 <lambdabot>  ["a","ab","abc","ac","b","bc","c"]
09:05:36 <hyperisco> not solving the same problem but maybe you can adapt it
09:06:24 <fog> i wrote the issue up nearly above, i dont want to jam up the channel needlessly by repeating the question
09:07:19 <fog> i understand that people dont have experience using backpack, so have removed all reference to it
09:07:32 <fog> now it should be easy for someone whith experience using cabal to help with
09:15:24 <mpiechotka> What is equivalent of cabal sandbox new-source for the nix style build?
09:16:31 <merijn> mpiechotka: You mean for depending on local packages?
09:16:44 <mpiechotka> merijn: Yes
09:16:59 <mpiechotka> Ok
09:17:07 <mpiechotka> NM - I figured this one out
09:17:27 <mpiechotka> I shouldn't specify the current package in the field which wasn't clear from docs.
09:17:30 <merijn> mpiechotka: Either you add them to either the "packages" or "optional-packages" list in cabal.project
09:17:32 <Cale> fog: What the heck is "Rotate"?
09:17:46 <merijn> mpiechotka: Depending on the purpose of the dependency
09:17:49 <fog> idk, thats just what cabal is complaining about
09:17:50 <Cale> fog: It doesn't seem to be mentioned anywhere in either of those directories
09:18:06 <mpiechotka> merijn: Thanks. 
09:18:10 <fog> i thought it was just capitalising the rotate lib
09:18:16 <Cale> and I've never seen an error message with that wording
09:18:18 <fog> hmm, maybe its another globally defined thing
09:18:24 <Cale> It will never mess with capitalisation
09:18:33 <Cale> (it's case sensitive, even)
09:18:54 <fog> ah, so it must be trying to use a different library
09:18:58 <merijn> mpiechotka: i.e. packages generally contains the packages that belong to your repo, whereas optional-packages is more for external packages where you're, for example, testing an upstream bugfix
09:19:02 <fog> no wonder its been acting so off
09:19:04 <Cale> There's something weird going on
09:19:24 <fog> so i need a dedicated environment to do all these different builds
09:20:34 <fog> it says sandbox is part of the legacy v1 style
09:23:36 <fog> cabal new-sandbox is unrecognised, even though it is advised by the warning issued when trying to use sandbox
09:24:10 <fog> is there any way to clean all the locally built projects?
09:24:19 <c_wraith> is there a v1-new-sandbox command?
09:24:35 <merijn> c_wraith: Wut?
09:25:03 <c_wraith> delete ~/.ghc is the nuclear option for cleaning out your locally installed packages
09:25:14 <merijn> fog: That's almost certainly a mistake of blindly applying that warning header to all old commands
09:25:34 <merijn> fog: With new-build sandboxes are obsolete, so there is no new-sandbox
09:25:35 <sclv> fog: use the equiv of sharing a local env for a group of local packages is a .project file
09:25:38 <merijn> Because it'd be pointless
09:25:46 <sclv> you have all your packages together in subdirectories of some dir
09:25:50 <sclv> and a project file in the top dir
09:26:11 <sclv> and then cabal can use all those local packages together in tandem
09:26:49 <c_wraith> oh. man, I misread that. that's new-style, not create a new sandbox.
09:29:10 <fog> hmm
09:29:12 <fog> ok
09:29:42 <fog> not sure if project is the right way, since this is supposed to emulate two different libraries installed from hackage
09:31:21 <fog> c_wraith where would i find this .ghc file?
09:33:18 <fog> oh, so it could be something to do with mixing up v1 and new- commands
09:36:29 <fog> ok, now it gives a more reasonable error;
09:36:30 <fog> unknown package: rotate
09:36:43 <fog>  cabal new-configure --libdir="rotateNoBackpack/rotate"
09:37:10 <fog> having done "cabal new-install --lib" in that directory
09:40:38 <fog> why cant it see that lib?
09:43:10 <fog> i guess the .project approach would be worth seeing if it worked with backpack, so ill try that
09:50:53 <fog> now it complains there are no executables in the rotateUse cabal when there clearly are
09:51:17 <fog> thats with cabal new-install in rotateUse dir
09:51:32 <sclv> newinstall doesn't install into a directory
09:51:55 <sclv> it installs into the global store, then adds an entry making it available in the global environment file
09:51:57 <fog> cabal new-configure throws errors about the version of vect
09:52:29 <fog> cabal new-configure --allow-new just gives a list of things that "would" be built...
09:52:48 <fog> after which
09:52:52 <fog> cabal new-build
09:53:04 <fog> says; cabal.exe: No targets given and there is no package in the current directory.
09:53:33 <sclv> use a project file
09:53:36 <mniip> I need naming suggestions
09:53:36 <mniip> data M r a = M { runM :: r (M r) -> a }
09:53:36 <sclv> they're documented
09:53:37 <mniip> it's like a reader monad but it's recursive in that the environment knows what monad it's in
09:53:38 <mniip> like some sort of third person reader
09:53:48 <sclv> read :clap: the :clap: cabal :clap: manual
09:54:04 <fog> where?
09:54:05 * mniip hands sclv a üëè
09:54:22 <sclv> https://cabal.readthedocs.io/en/latest/
09:54:51 <fog> thanks, ill get a snack and settle down for some light reading
09:56:34 <fog> anyway i wrote a .project file but it seems not to have worked, and the docs dint give hardly any info on how it was supposed to be used...
09:58:26 <fog> wouldnt it be easier and better for leaning all round if someone just packaged up a working build with decent instructions based on the attempt provided?
09:58:34 <fog> and then do the same with the backpack version!
10:00:28 <fog> here look, this works and can be used as a template for building a backpack project; https://github.com/fog-hs/rotate
10:06:51 <fog> i an see this wasting my entire day and still not being able to do the backpack version
10:08:47 <hyperisco> Don't use it then
10:09:26 <fog> thats not helpful
10:10:01 <fog> i dont want to ask for help just to open myself up for disparaging remarks
10:10:28 <fog> the advice given is iffy at best
10:10:50 <sclv> look you're coming in with basically zero here
10:10:53 <fog> and me noting as such being met with sentiments of "just give up" are pretty offensive
10:11:15 <sclv> and you keep trying things and asking for help, and haven't taken the time to just read the docs carefully and work thing through
10:11:32 <sclv> so you're giving a stream of consciousness updates on everything
10:11:40 <sclv> instead of being able to have distinct focused questions
10:11:45 <sclv> and its obviously very draining
10:12:01 <sclv> i promise you project files are the way to glue together multiple local projects
10:12:03 <fog> and your criticising me for giving clear and concise error reports allowing to reproduce the errors 
10:12:20 <sclv> "anyway i wrote a .project file but it seems not to have worked,"
10:12:25 <hyperisco> I am just trying to give you permission to accept the reality of the problem
10:12:28 <sclv> this is not a clear and concise error report
10:12:31 <fog> claiming the only rout to a poitive result is one that requires literally the least effort for you
10:12:37 <hyperisco> that it is poorly documented and not many people evidently have answers for you
10:12:37 <merijn> fog: Well, yes
10:12:40 <sclv> you didn't say what you tried and how it failed
10:12:53 <sclv> you're asking *other* people for help
10:12:58 <merijn> fog: No one here is getting paid to help anyone else, so if it costs people effort to help, they won't
10:13:07 <sclv> so it is the polite thing to do, to try to make it as easy as possible to help you
10:13:35 <sclv> backpack is so experimental that virtually nobody here uses it yet, even though this channel is full of experts
10:13:54 <fog> im not saying all the help is useless... right now im trying to follow advice given that a project file would help. i have the cabal documentation for project files open infront of me and it is not clear how to proceed
10:14:10 <sclv> as i said, have multiple libs each in subdirs of a main dir
10:14:13 <fog> every time i have ever learned anything it is by tinkering with a working example
10:14:15 <sclv> put a basic project file in the main dir
10:14:19 <hyperisco> I appreciate that you're trying to rustle up attention though. I'm guilty of the same thing sometimes.
10:14:53 <sclv> now, in the main dir, your cabal-new commands can target any of the cabal libs/exes in the subdirs
10:14:55 <fog> i have no such working example to use at this point, and when i ask if someone would be kind enough to provide one based on the version i have submitted with the reporducable errors described
10:15:07 <mniip> what's a whack name for a monad transformer
10:15:16 <fog> despite this seeming to be a reasonable way to collaberate on solving an issue to the benifit of the comunity
10:15:22 <fog> i am insulted
10:15:37 <sclv> fog: if you distill everything down to just one thing, then it may be easier to do a higher latency form of question asking about it, such as on SO
10:15:43 <sclv> irc is for quick back and forth
10:16:15 <sclv> also, i thought you had everything working, but then failed to get two different libs to work together
10:16:28 <sclv> and i told you how to do that -- use a project file
10:16:57 <sclv> otherwise, please tell us what the actual problem you are trying to solve is. the immediate one.
10:17:05 <sclv> not the long term "just use backpack to do a bunch of stuff" one
10:17:30 <fog> you can say im in the wrong for asking for help, you can claim im going about it in the wrong way, you can do anything that is not helpful, but you cant just do what would be helpful and litterally work on something with me which is to create a clear and concise utility of a tool which clearly needs as such
10:17:56 <sclv> https://meta.stackoverflow.com/questions/258206/what-is-a-help-vampire
10:18:02 <sclv> you are being a help vampire now
10:18:03 <sclv> stop
10:18:27 <fog> you cant just say "your the only person that wants to use backpack and doesnt know how so you have to figure out how to do so without anyone else contributing working versions of your best attempty" 
10:18:45 <sclv> if you can distill down your questions, people might be able to help you
10:18:53 <fog> sclv: i want to complete this project, not defend myself to you so stop attacking me
10:19:16 <sclv> at this point, you're alienating all the people that tried to help you. please chill out.
10:19:59 <fog> right, the whole thing is counterproductive as soon as it begins on this avenue. i wont be pushed down this avenue lightly
10:20:09 <geekosaur> let's put it this way. you're attacking the people you want to get help from. this is not a way forward unless you want to be on everyone's /ignore list
10:20:45 <fog> a user feels ignored, and says so, justifying being ignored
10:20:53 <nitrix> Already did here. People stirring drama wont receive my help.
10:20:55 <fog> not a comunity i really want to help develop 
10:21:04 <fog> and yet despite this...
10:21:06 <sclv> look, please take a day off this, chill out, try some stuff on your own, then come back and ask questions once you can ask them more clearly
10:21:26 <sclv> you're frustrated at not being able to do a complicated thing
10:21:31 <fog> i have asked very clearly
10:21:32 <sclv> people would like to help
10:21:37 <sclv> but you're too frustrated to ask the qeustions well
10:21:40 <fog> your claiming that would help at all
10:21:42 <beka[slacking]> are there good ways to use a data declaration to generate a schema? not for any particular DB, i'm not looking for existing such things, but rather the technique, if there is one
10:21:45 <sclv> and too frustrated to accept feedback on how to ask them better
10:21:49 <fog> which seems contrary to evedence
10:21:52 <sclv> i've been there. i understand
10:22:02 <sclv> but the discussion is in no state to be productive
10:22:15 <fog> if you want to help why cant you just post a working version in a repo!?
10:22:18 <[exa]> beka[slacking]: by 'data declaration' you mean the actual 'data XXX = ...' definition?
10:22:40 <fog> instead of saying "read some behemoth docs that wouldnt help anyway"
10:22:47 <sclv> fog: try asking on stackoverflow. its a good question for it, since its longform
10:23:00 <fog> "try going away, maybe that will help"
10:24:01 <sclv> beka[slacking]: the general technique is to use generics, although that's vague :-)
10:24:27 <sclv> you can inductively walk the structure to generate information about it which can then be emitted into a schema declaration
10:24:50 <beka[slacking]> sclv: :p   is there a good tutorial anywhere on using generics to grab a data decl? i've used it for grabbing SOP reps of data but not the decls
10:24:57 <beka[slacking]> [exa]: ya
10:25:02 * shapr is awake
10:25:12 <geekosaur> beka[slacking], I'd say there are ways but few general ones. because there's no guaranteed 1 to 1 mapping for types
10:26:10 <beka[slacking]> i want McBride's Desc, almost, but we're not all the way to dependent haskell yet are we
10:26:26 <[exa]> beka[slacking]: Data/Generic is probably the best way then. SYB tutorial is extremely useful
10:26:37 <beka[slacking]> [exa]: okiedoke!
10:26:53 <sclv> syb is the old way, doing it with new generics is certainly better, but yeah i don't know of a good tutorial
10:26:56 <cocreature> beka[slacking]: by decl instead of SOP reps you mean that you want things like field and constructor names?
10:26:59 <sclv> i stumble my way around still
10:27:11 <[exa]> sclv: would you suggest uniplate?
10:27:29 <sclv> no -- this is all about extracting the information about the type, not about working with a concrete bit
10:27:34 <beka[slacking]> cocreature: i mean like i want to traverse `data Foo = ...` rather than traverse `foo` which happens to have type `Foo`
10:27:55 <beka[slacking]> so i can't exactly convert an *element* to SOP, rather i want the declaration itself as something to inspect
10:27:59 <cocreature> oh I see
10:28:35 <beka[slacking]> also hey folx, long time no chat :p
10:28:38 <[exa]> beka[slacking]: the other common way is to process the fields with a bit of template haskell, similarly as with autogenerating lenses
10:28:40 <cocreature> Generics do give you the `Rep` type family to get a type-level representation of the decl
10:28:47 <beka[slacking]> i think the last time i was really active in here i was still going by augur
10:28:47 <cocreature> but TH is probably easier
10:29:01 <cocreature> oh, I think I remember augur :)
10:29:07 <cocreature> welcome back!
10:29:32 <beka[slacking]> yeah i got bored with IRC for a bit, bought a new gender, etc etc
10:30:11 <beka[slacking]> cocreature: blegh, I hate TH, i'm morally opposed to that sort of nonsense U.U
10:31:06 <cocreature> understandable but it might still be the easier option here :)
10:32:36 <[exa]> "m4 veterans love template haskell"
10:32:53 <sclv> beka[slacking]: here's an example of using generics to get data about the declaration itself https://hackage.haskell.org/package/generic-deriving-1.12.4/docs/Generics-Deriving-ConNames.html
10:33:15 <hyperisco> beka[slacking], oh, hi augur
10:33:27 <sclv> you can pass in (undefined :: a) for the type itself or rework it to use a proxy
10:33:46 <sclv> idk if there's code lying around to do the field names instead of the conNames but it should be similar
10:34:27 * geekosaur would guess soem could be borrowed from e.g. any of the lens packages woth TH helpers
10:34:34 <geekosaur> modifying as appropriate for SQL names
10:34:56 <sclv> yeah i know how to do it with th, but i think generics would be cleaner :-)
10:35:07 <sclv> i use th when i'm generating code where efficiency is at a premium
10:35:11 <beka[slacking]> hyperisco: heyo
10:35:18 <sclv> but in this case since you only need the schema "once" it matters less probably
10:36:29 <beka[slacking]> sclv: so Data.Generic + Rep?
10:36:54 <beka[slacking]> er, GHC.Generics :P
10:38:01 <sclv> yeah thats my guess as to a good approach
10:38:10 <sclv> if it works for constructor names, you can make it work for fieldnames too
10:38:21 <cocreature> hm, it seems like there is an opportunity here for a generics-sop-like gadt/singletons representation of Rep
10:38:24 <beka[slacking]> oh but rep is the SOP representation type, is there a way to inspect it??
10:39:28 <sclv> you gotta do type level things to inspect it
10:39:29 <cocreature> beka[slacking]: make a typeclass and provide instances for the various parts of the representation
10:39:35 <cocreature> (commonly called typeclass induction)
10:40:07 <sclv> yeah, i agree a lib that converted all the different Reps to a uniform type, like `SimpleRep` that you could just walk over on the value level would be nice
10:40:20 <[exa]> anyway, is there any good textbook on CT that I should give to students? (additionally to the one from Bartosz M)
10:40:24 <sclv> for if you want to query stuff about a type, but not actually do anything fancy
10:40:31 <sclv> [exa]: what level students, with what background?
10:40:56 <beka[slacking]> cocreature: hm. that sounds like something i was thinking off. have some type of codes for data decls, and then for any given Generics, have an instance of some class that has a single field, `code`, which is the code for that type??
10:41:17 <sclv> (i don't think of bartosz' book as a good textbook on CT. i think its more complementary to one tbh)
10:41:49 <beka[slacking]> basically i want to have a data declaration, and be able to spit it out into a text file as a custom DB schema
10:41:52 <[exa]> freshman CS bachelors; they know formal logic, set theory, lot of linear/abstract algebra, 3 semesters of calculus, 4 of graph/combinatorics theory, all of knuth.
10:42:14 <beka[slacking]> and then also take some pile of data in that type and spit it out into text following that schema, of course
10:42:33 <cocreature> beka[slacking]: yeah that sounds about right
10:42:34 <sclv> imho Lawvere and Schanuel is the best thing for that background/level
10:42:40 <sclv> but it might not cover what you want
10:42:42 <[exa]> I was actually seeking something that would give topological intuition, which this doesn't really give
10:42:54 <cocreature> [exa]: I did read awodey‚Äôs book during my bachelor‚Äôs and found it quite accessible
10:43:09 <beka[slacking]> i preferred Awodey's lectures from OPLSS to his book
10:43:19 <sclv> if they don't have any topology background, how can it give topological intuition?
10:43:23 <beka[slacking]> also Catsters, for the stuff beyond defs of categories and functors
10:43:28 <sclv> riehl's is probably the best for top intuition
10:43:43 <[exa]> ok so there we go with 5 recommendations, thank you all :]
10:43:45 <sclv> but unless they have some higher-division undergrad top under their belt it may well send them screaming for the hills
10:44:03 <[exa]> 'higher-division undergrad' ?
10:44:17 <sclv> er, like major-specific courses in topology
10:44:28 <sclv> that you usually take in the 3rd or fourth year
10:44:32 <beka[slacking]> there's also the topos theory book which is related to topology???
10:44:48 <beka[slacking]> some people love that as a category theory book
10:44:54 <kosmikus> anything I could help with re generics(-sop)? haven't read the backlog, so don't know what the original problem was/is ...
10:45:13 <sclv> yeah -- that isn't about cat theory in general. its about only one (ok two) special classes of categories which are "like" categories of spaces
10:45:13 <[exa]> sclv: that's the problem, closest to topology we get them is from the calculus side
10:46:03 <sclv> kosmikus: the basic question is "given a data type, how do we get the structure of all constructors and fields in a simple way (to generate a db schema with)"
10:46:08 <beka[slacking]> kosmikus: maybe! :)   i want to use a data decl to define a db schema
10:47:03 <sclv> the topos theory book is great, don't get me wrong. it just covers an idiosyncratic slice of basic CT
10:47:27 <sclv> (but i will say it taught me about how to "do" CT since it uses it to get other results instead of just giving the internal basic results)
10:48:03 <cocreature> I love how you can count on kosmikus showing up whenever you mention generics-sop :)
10:48:06 <beka[slacking]> slice of CT, coslice of CT ü§î
10:48:15 <sclv> bet he has an irc alert set :-P
10:48:20 <topos> so many highlights
10:48:26 <kosmikus> sclv: indeed
10:48:49 <kosmikus> is this for generating text?
10:48:56 <beka[slacking]> topos: well who's fault is that
10:48:57 <kosmikus> i.e., the textual description of a DB schema?
10:49:04 <beka[slacking]> kosmikus: ya
10:49:22 <topos> hahhah
10:49:26 <beka[slacking]> but not for any well known DB system, so i can't use anything that already exists
10:49:32 <kosmikus> right
10:49:37 <topos> hello, i don't mind it's just funny every time
10:49:57 <beka[slacking]> i would also settle for going the other way and taking a description and getting to a datatype that uses it, which may be more feasible??
10:50:12 <beka[slacking]> probably that's easier, with DataKinds?? hmm
10:50:13 <sclv> oh they're both feasible, just different
10:50:36 <sclv> i like to generate from an IDL these days, like protos
10:50:47 <sclv> helps different teams to collab better, gives a versioned "source of truth"
10:50:52 <kosmikus> beka[slacking]: so for the metadata (names, number of constructors, number of fields) in generics-sop you can use http://hackage.haskell.org/package/generics-sop-0.5.0.0/docs/Generics-SOP-Universe.html#v:datatypeInfo
10:50:57 <beka[slacking]> sclv: IDL?
10:51:04 <sclv> intermediate description langauge
10:51:11 <kosmikus> which gives you a value of the DatatypeInfo type which you can just traverse
10:51:13 <beka[slacking]> ah. what's that workflow look like?
10:51:43 <sclv> kosmikus: ooh, pretty!
10:51:45 <beka[slacking]> kosmikus: rad, thanks!
10:52:14 <sclv> the workflow is that we have .proto files which are the "core" data structures we share between projects and languages
10:52:23 <sclv> and use in messaging and also in the database
10:52:31 <kosmikus> there are additional functions in http://hackage.haskell.org/package/generics-sop-0.5.0.0/docs/Generics-SOP-Metadata.html which extract certain parts of DatatypeInfo which may help
10:52:47 <beka[slacking]> sclv: are these google protobuf's?
10:52:48 <sclv> and each language/team uses whatever tools they want to generate the in-language datatypes or the db schema or whatever from those files
10:52:51 <sclv> yeah
10:53:04 <sclv> we happen to actually use protos as a wire format between different components too
10:53:07 <beka[slacking]> god i hate protobuf's. x.x
10:53:18 <kosmikus> beka[slacking]: for the type information, you probably want to define a class that you instantiate for "supported" types, and that provides a method somehow explaining how the corresponding DB type would look like
10:53:19 <beka[slacking]> are you at google?
10:53:29 <sclv> but it works even if you don't actually use them as a wire format, but just use the .proto language to define "language indep data structures"
10:53:33 <saml> i'm at google
10:53:54 <kosmikus> beka[slacking]: and then you'd call some form of hpure in order to produce all these values for the type in question
10:53:55 <sclv> i'm not at google. the proto language is fine. i hate only one specific aspect of protos, which is the varint128 encoding
10:54:14 <beka[slacking]> wow, a non-google team using protobuf, this is amazing :o
10:54:15 <beka[slacking]> :P
10:54:16 <sclv> which privileges a _lot_ of processor cycles to encode over a _small_ space usage benefit
10:56:33 <hyperisco> Google listens to me any time I start a sentence with "Hey Google". Does that count?
10:57:15 <cocreature> beka[slacking]: I‚Äôm also not at google and we use protobuf :)
10:58:51 <hyperisco> Is this more or less like XML or JSON schemas?
11:00:36 <cocreature> hyperisco: yeah pretty much
11:00:47 <hyperisco> More reigned in, seems like.
11:01:22 <hyperisco> Worth considering anyways. Attractive.
11:04:31 <beka[slacking]> blegh, i can't use Desc-style stuff b/c i can't lift runtime code to the type level ;( 
11:04:55 <beka[slacking]> well, maybe i don't need to enforce well-structured-ness for my purposes. hmm
11:05:23 <maartz> Hi ! I'm pretty new in the Haskell community, i've just bought LYHFGG.
11:05:31 <beka[slacking]> hey maartz, welcome! :)
11:06:48 <beka[slacking]> if i may, i'd also recommend checking out Graham Hutton's book Programming in Haskell. it's imo the best Haskell book out there :)
11:07:56 <maartz> thanks beka[slacking]
11:08:59 <beka[slacking]> maartz: it's a challenging book, but i'm a huge fan, and i'm always happy to help folx learn haskell, so if you have questions, feel free to ping me :)
11:09:23 <KyleWins> also new in the haskell community and im about the thrid of the way through Haskell programming from first principles i was wondering what yalls take is on this book? 
11:10:48 <maartz> I've heard it is well written. Thanks for your help ! It's very pleasant to find helpful people :) I'll not hesitate if i've any questions ;)
11:10:49 <beka[slacking]> what i've read of HPFFP is .. not ideal? it has a weird approach to things, everything feels backwards and too abrupt for my tastes. like it dumps a lot of stuff on you. almost like its showing off, not teaching? i don't know
11:10:54 <merijn> KyleWins: Bit verbose, but at least it's very thorough and doesn't leave much room for wrong understanding (something that Learn You a Haskell is prone to do)
11:14:49 <sarahzrf> one time i tried to get into a political argument with the co-author and he sent me a video of a pig being slaughtered
11:15:15 <sarahzrf> or something alogn those lines
11:15:17 <sarahzrf> just a fun fact
11:16:03 <EvanR> heh
11:16:06 <KyleWins> its very wordy!!! ive been periodically trying to go through 99 problems wiki. the first 8 are pretty straight forward and then it gets tough
11:16:08 <KyleWins> LOL
11:16:25 <EvanR> shooting the messenger rather than the message, makes sense
11:16:30 <beka[slacking]> sarahzrf: i was at queerious labs the other day chatting, and two separate people started complaining about some asshole haskeller in texas, and i was like "is this ***** *****?" and they were both like "YES! omg"
11:16:52 <beka[slacking]> also he's sometimes in here? or was a few years ago, so heads up.
11:17:03 <glguy> KyleWins: If you're looking for programming exercises I liked the ones at adventofcode.com
11:17:24 <sarahzrf> lol
11:17:35 <EvanR> adventofcode rocks
11:17:46 <rotaerk> I think LYAH is good enough; you don't really need a thorough book necessarily, just something to give you a core understanding that you can build upon as needed in an ad-hoc manner
11:17:56 <merijn> I think LYAH is pretty bad, tbh
11:17:59 <sarahzrf> yeah
11:18:06 <sarahzrf> it doesnt have exercises
11:18:07 <EvanR> A Gentle Introduction > LYAH
11:18:08 <sarahzrf> that's critical!!!
11:18:14 <merijn> In the sense that, if you can learn from LYAH, you'd probably learn just as well without LYAH...
11:18:59 <rotaerk> I never read "A Gentle Introduction"
11:19:07 <merijn> I've never seen him cross the line in hear, but I know many people complain about Chris, so I'd assume there's at least some truth there. On the other hand, I don't really know a more suitable book to recommend
11:19:19 <EvanR> somehow A Gentle Introduction resonated with me
11:19:36 <merijn> rotaerk: The Gentle intro was written in the time that the people learning all already knew ML, which means it's not...quite as gentle when you come from an imperative world
11:19:36 <geekosaur> my take on LYAH is it needs exercises to not be "15 countries in 15 days"
11:19:40 <KyleWins> ill try adventofcode, for python i love Leetcode but i havent really found anything similar for Haskell
11:19:41 <merijn> @quote brend gentle.intro
11:19:41 <lambdabot> No quotes for this person.
11:19:42 <glguy> I'd recommend Programming in Haskell and a couple others before HP:FFP
11:19:47 <merijn> @quote brend gentle
11:19:47 <lambdabot> No quotes for this person. And you call yourself a Rocket Surgeon!
11:19:53 <merijn> ah, come on lambdabot
11:19:53 <rotaerk> heh
11:20:01 <merijn> Don't tell me your case sensitive
11:20:08 <geekosaur> and I did fine with Gentle Introduction, but I had some SMLNJ to start with
11:20:15 <merijn> @quote Brend gentle
11:20:16 <lambdabot> Brend says: Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something.
11:20:25 <beka[slacking]> lol
11:20:28 <merijn> Spoiler, lambdabot *is* case sensitive >.>
11:20:34 <geekosaur> that part, yes
11:20:34 <glguy> KyleWins: If you start on adventofcode.com I and a number of other Haskellers have published solutions you can compare your own to. Since a lot of us have done those problems we'll also be equiped to help you along, so feel free to ask here
11:20:40 <rotaerk> someone in another server has been reading LYAH and messaged me after chapter 5 saying he was "bored"
11:21:00 <geekosaur> name is case sensitive and doesn't support wildcards
11:21:03 <EvanR> i don't know ML, but at the time i was steeped in scheme
11:21:20 <beka[slacking]> so must be so frustrated by their name choice right now lol
11:21:23 <geekosaur> so it's better to use a regex search without a username, I think
11:21:28 <geekosaur> "right now"?
11:22:03 <beka[slacking]> geekosaur: :p
11:22:39 <merijn> glguy: Perhaps, but I don't know those books. My girlfriend's been working through HP:FFP (with no programming knowledge beyond playing with some geophysical modeling scripts) and she's been doing quite well with it
11:23:09 <merijn> glguy: So at least I feel I can somewhat judge the strong/weak points of it
11:23:10 <glguy> merijn: I find that it teachings people incorrect intuitions and meanings that have to be disentangled on IRC
11:23:38 * geekosaur also notes there's more than one book/resource for a reason‚Ä¶ different people learn in different ways
11:23:43 <KyleWins> glguy I will definitly try it out 
11:23:57 <maartz> And what do you think of Practical Haskell V2 ?
11:24:06 <EvanR> on the value of incorrect intuitions, perhaps these make people faster sometimes? : )
11:24:23 <EvanR> like a destructive performance enhancing drug
11:24:54 <EvanR> alternate history, if windows were written in haskell
11:28:36 <beka[slacking]> EvanR: i've been talking with some folx about building a linux-inspired OS in a new purely functional OS, so who knows :p
11:29:33 <fog> ok, so it turns out that with --force-reinstalls it was able to get past the conflict that was preventing it from progressing
11:29:42 <EvanR> i imagine you need some whizbang theoretical language from an obscure paper for a kernel
11:29:54 <EvanR> functional kernel
11:29:57 <merijn> beka[slacking]: Are you familiar with Habit?
11:30:18 <fog> EvanR: like for a reproducing kernal hilbert space?
11:30:21 <merijn> (well, the idea/spec, I don't think they ever really started implementing it)
11:30:49 <beka[slacking]> merijn: I'm not! should i look it up? :p
11:30:53 <Lycurgus> kernal
11:31:02 <Lycurgus> attaturk
11:31:29 <fog> oh, the kind using cgroups
11:31:38 <merijn> beka[slacking]: It was a group in portland working on a Haskell dialect for systems programming (like OS kernels)
11:31:47 <merijn> beka[slacking]: They wrote up a language report and everything
11:31:56 <Lycurgus> and every damn thing
11:32:09 <merijn> beka[slacking]: Lots of good ideas/interesting things for people considering that sorta :)
11:32:21 <merijn> beka[slacking]: https://hasp.cs.pdx.edu/habit-report-Nov2010.pdf
11:32:23 <beka[slacking]> this looks interesting
11:32:34 <beka[slacking]> will read!
11:33:53 <fog> call by value and bit representation conducive to systems level programming 
11:34:29 <fog> i still cant understand the difference between a kernal and a server running as an exe
11:34:32 <merijn> beka[slacking]: They spend a bunch of time thinking about things that I think are sorely lacking in Haskell. Like writing safe, portable code that works with things like machine level words
11:36:58 <fog> so whats the idea then? its supposed to be OS independent or not need an OS or what?
11:37:05 <hyperisco> Linear types are supposed to make some sense of memory use right? Guess that's a start.
11:37:18 <merijn> hyperisco: Not the kind you want/need for an OS
11:37:22 <beka[slacking]> merijn: it'll be interesting to see what they say. part of my philosophy for the new language + OS is that we should push all the low level stuff into the compiler, b/c you don't actually *need* low level programming if you have a well-designed system
11:37:38 <merijn> hyperisco: What you need with an OS is a way of talking about memory allocations and sizes
11:38:12 <fog> or is it more like a virtual machine so you can install linux on it and run it on windows?
11:38:20 <beka[slacking]> but itll be interesting to see how that comes about, i guess. :)
11:38:57 <hyperisco> I've written a microkernel. I am just thinking of a starting place.
11:39:21 <fog> hyperisco: in haskell?
11:39:31 <hyperisco> C and C++
11:39:39 <beka[slacking]> RIP
11:39:54 <hyperisco> C++ because the templates were useful at times
11:40:21 <fog> is there a challenge to doing this in haskell
11:40:43 <fog> like, Habit mentions ways to improve on haskell for the task, but i cant see why it wouldnt still be possible in haskell
11:40:59 <hyperisco> The entire runtime is unsuitable, so that's one reason
11:41:17 <fog> oh idk what that is
11:43:14 <fog> can you give an example of an aspect of the runtime which is unsuitable?
11:43:38 <fog> that would help understand what a runtime consist of 
11:44:19 <hyperisco> It depends on having facilities like a memory allocator, which doesn't exist
11:44:25 <fog> do you just mean about how it has to go via C for memory access?
11:44:43 <merijn> The runtime doesn't go via C for memory accesses...
11:44:49 <fog> oh...
11:44:59 <fog> memory allocation?
11:45:01 <hyperisco> Even when you write a kernel in C or C++ you don't have a malloc or new
11:45:13 <fog> whoa
11:45:36 <fog> i cant see how thats even possible
11:45:43 <hyperisco> Well, those are implemented by the OS, which you're defining
11:46:32 <fog> oh so it has to use the hardware calls directly to give this functionality to the compilers that would run on it?
11:46:53 <fog> what do you call them, machine calls or something
11:47:03 <hyperisco> CPU instructions
11:47:17 <fog> like these;
11:47:18 <fog> http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042f/IHI0042F_aapcs.pdf
11:47:28 <hyperisco> You use those to configure memory, handle interrupts, and many other things
11:47:47 <hyperisco> You have to implement memory allocation though, as well as scheduling
11:48:00 <hyperisco> And both those things a language runtime typically depends
11:48:02 <hyperisco> on
11:49:01 <fog> isnt there standards for that?
11:49:17 <hyperisco> Absolutely, x86 for example
11:49:19 <fog> like, cant you just import at thread library or something
11:49:25 <fog> no i mean, for the interfaces
11:49:45 <fog> like you shouldnt have to actually invent how to do it...
11:50:11 <hyperisco> Typically a thread library is going to ultimately depend on system calls
11:50:44 <fog> you would just be making a choice of hardware architecture and a choice of how to do the threading and stuff and plumbing the machine calls to the lib providing some style of memory handling
11:51:25 <fog> it can abstract over the system calls though?
11:51:37 <gabbiel> is there scanf like procedure in haskell?
11:51:54 <hyperisco> merijn, If one can implement a boot loader in the language that is probably all the relevant problems solved :P
11:52:40 <merijn> gabbiel: I don't know, but even if there is, you shouldn't use it
11:52:50 <fog> isnt there something like cgroups for that, like, not just for servers but for vms
11:52:57 <merijn> gabbiel: Sounds like you just want one of the many parser combinator libraries, tbh?
11:53:34 <gabbiel> merijn: scanf seems a million times simpler than that
11:53:54 <merijn> gabbiel: If you really need to quickly read one thing, there's:
11:53:59 <merijn> :t Text.Read.readMaybe
11:54:01 <lambdabot> Read a => String -> Maybe a
11:54:05 <merijn> gabbiel: What are you trying to do?
11:55:05 <gabbiel> wait, now thinking about it, scanf would be bad cause it changes values of pointers
11:55:15 <fog> you should just be able to emulate the hardware by making functions for all the x86 calls, like implementing the system calls standard
11:55:40 <fog> then you could test the kernal and booter libs on the virtual environment
11:55:41 <merijn> gabbiel: I assume you want to, like, read in formatted data from a file or something?
11:56:01 <c_wraith> gabbiel, also, scanf isn't really simpler than parsing libraries in Haskell.
11:56:01 <gabbiel> yeah, but even then, that's impossible because lists are homogenous in haskell
11:56:07 <fog> it would be really neat to see a version of virtualbox written in haskell
11:56:14 <gabbiel> i imagine a haskell version would return a list
11:56:25 <merijn> gabbiel: DO you have an example of what you're trying to read and what you wanna do with it afterwards?
11:56:38 <gabbiel> like so: scanf "%s %i" => [some_string, int]
11:56:41 <gabbiel> but thats impossible
11:56:59 <fog> https://www.virtualbox.org/browser/vbox/trunk
11:57:25 <merijn> gabbiel: Parser combinators and some custom datatypes are pretty easy, tbh
11:57:27 <gabbiel> merijn: i was just wondering, i dont really need scanf right now
11:57:40 <fog> seems like a job for genetic haskell
11:58:01 <merijn> gabbiel: It can be as simple/basic as: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/ingest-src/Parsers.hs#L77-L85
11:58:13 <gabbiel> is there a book to teach me this?
11:58:32 <fog> but you would have to have something to fool it into thinking it had access to a screen etc to test the output pins
11:58:33 <c_wraith> gabbiel, look into things people have done for the advent of code in Haskell, for examples of quick and dirty input handling.
11:58:40 <merijn> gabbiel: As a bonus, most parser combinator libraries have support for streaming libraries so you can easilly stream large amounts of data, too
11:59:19 <merijn> gabbiel: Real World Haskell has a chapter on parsec. Most of the code examples have bitrotted (and you should probably use megaparsec for new code), but ideas behind the API are the same, so I thought it was still helpful
11:59:57 <gabbiel> ill look into that
12:00:00 <gabbiel> thanks
12:01:01 <merijn> gabbiel: The megaparsec github also has links to several tutorials: https://github.com/mrkkrp/megaparsec
12:01:12 <fog> maybe you could just replace every c source file with something that wrapped over a haskell function
12:01:37 <fog> then swapping out each file one at a time would give eventually the whole functionality
12:02:48 <fog> like, using the rest of the program as a unit test for rewriting each C function one at a time
12:03:09 <merijn> gabbiel: Basically, once you get the idea of parsec, all the major libraries should be obvious, because they use the same typeclasses and similar designs and should all be pretty easy to use. The most important ones are: attoparsec for stuff where you want speed and don't care about readable parse errors, like protocols/binary files, megaparsec for human written data that you wanna give good errors for, 
12:03:15 <merijn> and binary for encoding/decoding binary data
12:03:25 <fog> then you could train a net to read c and output haskell
12:04:20 <hyperisco> You could write a C interpreter in Haskell.
12:04:37 <gabbiel> sounds pretty cool, cant wait to learn parsing
12:05:36 <gabbiel> hyperisco: i wrote one in lisp but it still has a little bit of bugs
12:06:00 <hyperisco> Just market that as part of the authentic C experience.
12:06:10 <fog> i guess thats the barrier, between a net given no training data and just a binary test "yes, you translated that correctly" and one that was provided with training data and somehow made to be able to understand how it could incorperate a parser and understand how the compiler worked
12:06:33 <fog> like, giving it access to both compilers source code could speed up learning... but only if it was able to read that...
12:07:30 <fog> i guess a large amount of training data could allow it to infer the way the compiler works
12:07:38 <fog> that how humans learn anyway...
12:07:44 <fog> still cant read the compiler source code!
12:08:31 <fog> giving it the human readable language spec is probably the most difficult way...
12:08:52 <ZoFLo> javascript is the thinking mans haskell
12:09:15 <hyperisco> Haskell is the working man's JavaScript
12:09:43 <fog> your saying you could just give it all the languages and all the programs and have it output an optimally expressive language?
12:10:15 <fog> parse error...
12:20:52 <Cale> ZoFLo: Javascript is the modern practical man's assembly language
12:23:53 <hyperisco> Oh so that's why I have to upgrade my computer every 5 years‚Ä¶
12:24:52 <Cale> hyperisco: Pretty much. Hopefully wasm will help some, but I dunno
12:25:17 <Cale> almost everything is a web application now
12:34:05 <hyperisco> If you have to marshal with JavaScript to use any APIs then it won't be that attractive for‚Ä¶ most things.
12:35:37 <Cale> Well, that's already the position we're in, kind of
12:35:53 <Cale> (Compiling Haskell to Javascript)
12:42:15 <Boarders> if I have a vector from Data.Vector.Primitive which is represented as a length, offset and bytearray and I create a empty vector does it just create Vector 0 0 byArr where byArr is just what you get when you create a new byte array of length zero
12:43:10 <Boarders> oh yes, I think that is what basicUnsafeNew is saying
12:43:34 <lyxia> Does "empty" mean "of length 0", "uninitialized", something else?/
12:44:06 <Boarders> I think it means of length 0
13:07:34 <fog> https://github.com/fog-hs/rotateDistributedWorking
13:07:34 <fog> https://github.com/fog-hs/rotateDistributedNotWorking
13:08:26 <gabbiel> is there a way to compose IO functions?
13:08:29 <fog> comparing these should show the error currently preventing a package exporting a signature from also exporting implementations 
13:08:40 <fog> gabbiel: yes!
13:08:47 <fog> % :t (>>=)
13:08:48 <yahb> fog: Monad m => m a -> (a -> m b) -> m b
13:09:07 <fog> % :t (>>=) :: IO a -> (a -> IO b) -> IO b
13:09:08 <yahb> fog: IO a -> (a -> IO b) -> IO b
13:09:11 <gabbiel> i mean, like (.)
13:09:18 <hexagoxel> :t (>=>)
13:09:20 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
13:09:36 <dmwit> :t (<=<) -- to get even closer to (.)
13:09:37 <gabbiel> whats the op called
13:09:38 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
13:09:50 <fog> thats the klisli arrow
13:09:56 <dmwit> You could call it Kleisli composition if you wanted.
13:09:58 <gabbiel> Data.Arrow?
13:10:23 <gabbiel> oh nvm its not Data
13:10:25 <gabbiel> its something else
13:10:28 <fog> :t (>>>)
13:10:30 <lambdabot> forall k (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
13:10:36 <fog> argh
13:10:39 <gabbiel> Control.Arrow right
13:10:40 <dmwit> There is a Kleisli instance of Arrow, but you don't need it for this.
13:11:13 <fog> :t \ a b -> a >>= return . b
13:11:15 <lambdabot> Monad m => m a -> (a -> b) -> m b
13:11:29 <fog> thats like flip fmap
13:11:54 <fog> :t \ f b a -> f a >>= return . b
13:11:56 <lambdabot> Monad m => (t -> m a) -> (a -> b) -> t -> m b
13:12:15 <fog> thats like some hellish pointless style thing
13:12:30 <gabbiel> wait so >=> is the one I want right
13:12:44 <gabbiel> and <=< is flip (>=>) 
13:12:50 <gabbiel> but what is even >>>
13:12:52 <fog> yeah, sorry
13:13:05 <fog> >>> is flip (.)
13:13:21 <gabbiel> lol why
13:13:24 <fog> so if your writing like;
13:13:30 <gabbiel> also where is this >=> binding @
13:13:40 <fog> a >>= b >>> c
13:13:43 <gabbiel> i Imported Control.Arrow but its not there
13:13:58 <fog> instead of; 
13:13:58 <fog> a >>= c . b
13:14:05 <gabbiel> oh i see
13:14:10 <gabbiel> pretty cool 
13:14:14 <fog> but i think you have to make a synonym of it and give it fixity 2
13:20:25 <fog> here;
13:20:26 <fog> https://pastebin.com/raw/MRYE2wqz
13:20:34 <fog> thats a nice collection
13:21:38 <fog> it might seem "pointless"
13:21:41 <fog> but its ok
13:21:50 <fog> (.) is used commonly in this way
13:21:59 <TradeGirl97> +++ Anyone wants trading? Add me and let's trade nudes::: https://3no.ro/user-TradeGirl97 ‚ô•
13:30:34 <gabbiel> forM  = flip mapM ?
13:32:15 <[exa]> gabbiel: iirc that holds by definition
13:33:43 <fog> i cant understand why moving the modules instantiating the signature into the package exporting the signature would break it
13:36:00 <fog> so far i can import the signature, but not its implementations...
13:36:31 <fog> i cant figure out if this is by design, or a bug, or something im doing wrong...
13:38:09 <fog> here is the cabal file;
13:38:09 <fog> https://github.com/fog-hs/rotateDistributedNotWorking/blob/master/rotateDistributedNotWorking/rotateUse/rotateUse.cabal
13:38:19 <[exa]> fog: could you post diff -ur between your two repositories (I'm not at a capable workstation now)
13:38:37 <fog> how do i do that?
13:38:49 <fog> is that a linux command? im on windows
13:39:29 <[exa]> if you have a commandline you can try diff -ur directory1 dirODODODODODODODODODODODODODODODODODODectory2
13:39:47 <fog> !
13:39:52 <[exa]> oh noes my irc client is suboptimal as well, it should have been 'directory2'... :]
13:40:10 <fog> diff command not found
13:40:52 <[exa]> ok nevermind
13:41:12 <fog> basically just moved the 2 implementation files (LinearRotate.hs,VectRotate.hs) from the rotateUse/example directory to the rotate/src directory and changed the cabal files accordingly
13:43:25 <fog> https://github.com/fog-hs/rotateDistributedNotWorking/blob/master/rotateDistributedNotWorking/rotate/rotate.cabal
13:43:26 <fog> https://github.com/fog-hs/rotateDistributedWorking/blob/master/rotateDistributedWorking/rotate/rotate.cabal
13:43:54 <[exa]> did you fill in the reexported modules?
13:44:11 <fog> thats adding the extra exposed modules;
13:44:12 <fog> exposed-modules: TestRotate,LinearRotate,VectRotate
13:47:03 <[exa]> ok I guess I get it now
13:55:15 <fog> really?
13:56:04 <fog> is still get;
13:56:08 <fog>     Non-library component has unfilled requirements:
13:56:48 <fog>  LinearRotate
13:56:52 <fog>  VectRotate
13:57:06 <[exa]> what exact command do you use to run the whole thing?
13:59:11 <fog> cabal new-build all --allow-new
14:01:28 <fog> that reproduces the error in;
14:01:29 <fog> rotateDistributedWorking
14:01:34 <fog> (top dir)
14:03:16 <fog> cabal new-run rotateUse --allow-new
14:03:52 <fog> that should also work (it runs the example, doing configure and build stages) as it does in the rotateDistributedWorking directory
14:04:15 <fog> wait there is a type above, obviously its the rotateDistributedNotWorking directory in which the error is returned 
14:04:34 <[exa]> yeah
14:05:03 <fog> what do you recon? 
14:05:45 <fog> seems strange not to be able to use imported modules as mixins...
14:07:38 <_kwstas> hello there! I tried to use the `<|>` operator on lists and to my surprise the function concatenates the two lists instead of trying to select the non-empty one! Does anyone know why is the function implemented like this? Also ,is there any other function that I can use instead? 
14:08:22 <fog> what are you trying to do?
14:08:33 <phadej> I'd bet, a parser
14:08:53 <phadej> or some search algorithm
14:09:00 <lyxia> _kwstas: that fits the interpretation of (<|>) as nondeterministic choice.
14:09:16 <fog> % [] <> [1,2,3]
14:09:16 <yahb> fog: [1,2,3]
14:09:28 <fog> % [0] <> [1,2,3]
14:09:29 <yahb> fog: [0,1,2,3]
14:09:48 <fog> % [0] <|> [1,2,3]
14:09:49 <yahb> fog: [0,1,2,3]
14:09:56 <[exa]> fog: aren't you affected by the warning at the end of 3.3.2.9 of cabal manual?
14:10:13 <_kwstas> no it's not in the scope of parser
14:10:18 <jollygood2> > Just "hi" <|> Nothing
14:10:21 <lambdabot>  Just "hi"
14:10:27 <_kwstas> I just want to initialize a list in case its empty
14:11:07 <_kwstas> [] <<>> [a,b] ~> [a,b] while [a] <<>> [b,c,..] ~> [a]
14:11:33 <fog> [exa]: i think thats why --allow-new is needed?
14:11:59 <jollygood2> _kwstas, not sure if there's a function/operator that does that. plain if-then-else works though
14:12:21 <Rembane> _kwstas: You could use the lazy nature of lists and put all potential lists in a list and pick the first non-empty one.
14:12:21 <EvanR> plain case works
14:12:36 <dmwit> > head . filter (not.null) $ [[], [a,b,c]]
14:12:39 <lambdabot>  [a,b,c]
14:12:43 <dmwit> > head . filter (not.null) $ [[a], [a,b,c]]
14:12:46 <lambdabot>  [a]
14:12:49 <dmwit> gross
14:12:54 <Rembane> BUT FUN! 
14:13:04 <jollygood2> not sure case is cleaner. 
14:13:06 <jollygood2> > let xs = []; ys = [1] in if null xs then ys else xs
14:13:08 <lambdabot>  [1]
14:13:27 <Rembane> If there are many lists involved I prefer the list-list solution.
14:13:49 <EvanR> > (\case [] -> [0]; xs -> xs) []
14:13:51 <lambdabot>  [0]
14:13:53 <EvanR> > (\case [] -> [0]; xs -> xs) [1,2,3]
14:13:56 <lambdabot>  [1,2,3]
14:14:05 <EvanR> k thats not plain case 
14:14:07 <fog> % (\ a b -> if null a then b else a) [] [1,2]
14:14:07 <yahb> fog: [1,2]
14:14:11 <fog> % (\ a b -> if null a then b else a) [0] [1,2]
14:14:11 <yahb> fog: [0]
14:14:19 <_kwstas> yes i currently use if... but i don'tl like it :D. I just can understand why the existing implementation has been selected. I mean IRL when we have alternatives, it means that we will select one of them..not all of them :O 
14:14:35 <[exa]> fog: afaik not, --allow-new just ignores some dependency limitations
14:14:56 <_kwstas> *cannot
14:15:02 <fog> what were you talking about this wildcard error?
14:15:06 <dmwit> _kwstas: But the interpretation of [a,b,c] is that there are already three alternatives.
14:15:44 <dmwit> _kwstas: In such a case, it is much clearer for `alternatives1 <|> alternatives2` to return all the available alternatives, not arbitrarily select some subset of them.
14:15:54 <jollygood2> it doesn't seem terribly useful that behavior is <|> for list is the same as <>
14:16:04 <_kwstas> :dmwit, ok I see know... so yes in that case makes sense :)
14:16:18 <fog> jollygood2: <|> is <> for monads
14:16:35 <jollygood2> fog it is? hmm
14:16:44 <dmwit> ehhh.... I don't subscribe to "<|> is <> for monads"
14:16:53 <fog> really its [a] that has a Semigroup instance, while its [] that has an Alternative instance
14:16:54 <jollygood2> fog is that a requirement?
14:16:54 <[exa]> `mplus` is for monads, <|> is for applicatives/alternatives
14:17:18 <fog> in the case that the alternative is a monad...
14:17:19 <dmwit> <|> gives rise to a monoid.
14:17:25 <dmwit> But by no means is it the clear winning choice of monoid.
14:17:34 <monochrom> <|> isn't even monadic.
14:17:35 <fog> ok its a monoid for functors then
14:17:49 <fog> wait, Applicatives
14:17:57 <dmwit> I am okay with "<|> is *a* <> for monads".
14:18:31 <fog> its not a theorem that its *the* <> for Applicatives?
14:18:37 <dmwit> Certainly not!
14:18:42 <fog> aha!
14:19:06 <fog> [exa]: how are you getting on?
14:21:17 <dmwit> ?let import qualified Data.List.NonEmpty as NE
14:21:20 <lambdabot>  Defined.
14:21:42 <dmwit> > fromMaybe (a NE.:| []) (NE.nonEmpty [a,b,c])
14:21:45 <lambdabot>  a :| [b,c]
14:21:52 <dmwit> > toList $ fromMaybe (a NE.:| []) (NE.nonEmpty [a,b,c])
14:21:55 <lambdabot>  error:
14:21:55 <lambdabot>      Ambiguous occurrence ‚ÄòtoList‚Äô
14:21:55 <lambdabot>      It could refer to either ‚ÄòF.toList‚Äô,
14:22:00 <dmwit> > NE.toList $ fromMaybe (a NE.:| []) (NE.nonEmpty [a,b,c])
14:22:05 <lambdabot>  [a,b,c]
14:22:09 <dmwit> > NE.toList $ fromMaybe (a NE.:| []) (NE.nonEmpty [])
14:22:16 <lambdabot>  mueval-core: Time limit exceeded
14:22:19 <dmwit> whatever
14:22:21 <dmwit> anyway, less gross
14:22:58 <dmwit> :t \a -> NE.toList . fromMaybe a . NE.nonEmpty
14:23:03 <lambdabot> NE.NonEmpty a -> [a] -> [a]
14:26:03 <fog> awaiting for [exa] imminently to return with a solution to the issue with backpack...
14:26:35 <monochrom> Wow you're really aggressive in demanding free labour from others.
14:26:57 <monochrom> Yeah I'm waiting for a moderator to end this aggression too.
14:27:11 <monochrom> Any time now when you're ready, moderators!
14:28:17 <fog> maybe im misinterpreting that as a joke...
14:28:26 <monochrom> No joke.
14:28:29 <[exa]> fog: dude, you spent a whole day on that, how's anyone supposed to get it ready in 5 minutes? :D
14:28:47 <fog> 3 days!
14:29:06 <Cale> It's not a joke, people here are generally pretty nice about offering their time to help out with things, but nobody is *obligated* to provide any help.
14:29:26 <fog> jump in to help!
14:29:29 <Cale> Treating them as such is unacceptable
14:29:37 <fog> agreed
14:29:41 <fog> my appologies
14:29:49 <fog> very frustrating 
14:31:46 <fog> the worst thing is your accusations make me seem ungrateful for the help i receive
14:32:08 <fog> im idling now, iv done what i can, i didnt mean to pressure anyone
14:32:09 <[exa]> fog: anyway, you need to: 1] fill in the build dependencies of the rotate library correctly, 2] add explicit mixins of the VectRotate and LinearRotate to the mixins of rotateUse, like `mixins: rotate(Lin..,Vect..),   rotate ...your aliases here...'
14:32:15 <[exa]> then it works
14:32:18 <fog> im almost convinced its a bug with backpack
14:32:25 <fog> iv tried everything
14:32:54 <[exa]> it's a corner behavior, documented in the corner
14:33:10 <fog> oh wow you got it working!?
14:33:22 <Cale> fog: It wouldn't surprise me if backpack had some bugs still -- almost nobody is really putting it through its paces yet.
14:34:18 <fog> can you post your working version?
14:34:22 <[exa]> hopefully it is the correct corner documentation and not a good luck
14:34:36 <fog> what?
14:34:45 <fog> your just guessing?
14:34:57 <fog> maan, i htought you had it working there for a seccond
14:35:07 <[exa]> yeah it's working, it builds and installs
14:35:32 <fog> its going to be too much hassle to try and describe the steps you took?
14:35:56 <fog> im happy to write it up if i can reverse engineer the steps from a working example
14:37:20 <fog> well, willing to... 
14:37:26 <[exa]> oh f I broke the cabal db
14:37:46 <fog> our dreams are dashed 
14:39:25 <[exa]> anyway, by filling the build-depends for rotate correctly you won't break anything, and add 'rotate (LinearRotate, VectRotate)' is documented as required as I got it
14:39:33 <[exa]> (in the mixins)
14:39:52 <[exa]> then it worked and now I broke reflection pkg
14:40:11 <fog> thats not precise enough to comprehend
14:40:57 <[exa]> I've got to afk, it's like midnight here
14:41:17 <fog> well at least im not expecting you to leave me hanging anymore
14:41:21 <[exa]> please re-read the backlog
14:41:35 <[exa]> it should certainly push you from this weird error
14:42:06 <[exa]>   mixins: rotate (LinearRotate, VectRotate), ...etc
14:42:21 <fog> i have nothing more to go on and exhausted every possible combination
14:42:31 <fog> what your saying isnt even the right syntax
14:42:44 <boj> fog: time to take a break!
14:42:50 <fog> im convinced by now its impossible
14:43:03 <fog> its a reasonable conclusion given the steps taken to reach it
14:43:35 <fog> unless given compelling reason to believe otherwise i have no reason to attempt anything else
14:43:40 <[exa]> fog: cabal manual: "Note that renaming a module like this will hide all the modules that are not explicitly named."
14:45:01 <fog> hmm, now your saying the modules are named wrong, and i should try and find reference to that passage of the cabal manual to understand what kind of wrong namings it could be referring too
14:45:30 <fog> what section, i cant ctrl-f the whole document
14:45:52 <[exa]> 3.3.2.9... you're naming them right, but VectRotate and LinearRotate disappear by the other renaming
14:46:02 <[exa]> so you need to appear them back
14:46:16 <[exa]> "appear something" oh man I need sleep
14:46:52 <monochrom> Yes.
14:47:12 <fog> what other renaming?
14:48:49 <fog> im not sure this is a relevant error at all.. 
14:49:09 <fog> cant you just paste your code?
14:49:41 <fog> i dont know whats worse to be honest...
14:49:53 <boj> >.<
14:51:47 <wroathe> So the Parsec monad defined in Megaparsec has Semigroup and Monoid instances, but if I wrap it using StateT the resulting state monad does not have semigroup/monoid
14:52:26 <wroathe> Is there anything wrong with adding Monoid/Semigroup for StateT in my library?
14:52:47 <dmwit> You may recover them with Ap.
14:52:58 <dmwit> https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Monoid.html#t:Ap
14:54:15 <wroathe> Hmm, it's not immediately obvious to me how that works, but I'll do some reading
14:54:25 <dmwit> Anyway, yes, there is something wrong with adding Monoid/Semigroup for StateT in your library.
14:54:50 <dmwit> But if you wanted to make a separate library that offered them and claimed to be the canonical source for this orphan instance, and then depend on that library, *I* think that would be okay but most of the community would still hate it.
14:55:33 <dmwit> (Of course, the downside of Ap (StateT s Parsec) is that it doesn't have a MonadState instance... yeesh.)
14:55:56 <dmwit> wroathe: Well, I'm not sure what reading you plan to do.
14:56:02 <wroathe> ha
14:56:08 <monochrom> I wonder if you're better off relying on Alternative instead.
14:56:31 <dmwit> wroathe: Just to check: are you *sure* you want StateT over Parsec?
14:56:36 <wroathe> The use case is appending text between sequenced parsers
14:56:48 <monochrom> hee hee that too, Parsec has user state.
14:56:49 <dmwit> I don't know about megaparsec, but in parsec the parser monad itself offers stateful tools.
14:56:56 <wroathe> Well, there's probably other ways to do it, but yeah... I need a nesting counter and a way to track the section of file I'm on
14:57:16 <dmwit> And you generally want the ones offered by the parser monad itself, because the state is carefully backtracked as the parser itself backtracks, whereas the StateT version... won't do that.
14:57:24 <wroathe> data ScanState = ScanState { section :: ScanSection , nesting :: Int } deriving (Show, Read, Eq)
14:57:46 <wroathe> with type Scanner = StateT ScanState (Parsec Void Text)
14:57:54 <TextbookCyberBul> has anyone got experience with Haxl?
14:58:18 <wroathe> And the use case for Semigroup is:
14:58:37 <wroathe> parseTest (string "foo" <> string "bar") "foobar"
14:58:41 <Cale> dmwit: hmm... interesting. StateT over list will cause backtracking of the state...
14:59:01 <wroathe> AFAIK <> is the only operator he's got defined for appending
14:59:03 <Cale> dmwit: I guess it depends pretty intimately on how the parser monad is implemented
14:59:27 <dmwit> wroathe: liftA2 (<>) (string "foo") (string "bar") will work, though I agree it is less convenient.
14:59:40 <dmwit> Cale: I think it does, yeah.
14:59:42 <wroathe> dmwit: I've got a lot of this in my code :/
14:59:49 <dmwit> wroathe: Yep, I'm sympathetic.
15:00:14 <dmwit> wroathe: Here is what nobody in the community would hate: a newtype around StateT s (ParsecT whatever) that defined MonadState and Monoid instances.
15:00:22 <wroathe> I could newtype it
15:00:23 <wroathe> Yeah
15:00:26 <wroathe> That's what I was thinking
15:00:38 <wroathe> But honestly I hate doing that too, even with GeneralizedNewtypeDeriving
15:00:52 <TextbookCyberBul> im trying to recover using a log from a critical failure of an IO action, can Haxl help? 
15:00:54 <monochrom> Counterexample :)
15:01:19 <wroathe> I could manually pass my state around
15:01:21 <dmwit> monochrom: why hate
15:02:39 <monochrom> But measure theory can help.  "almost everywhere" and "null set = a set of measure zero".
15:02:59 <dmwit> TextbookCyberBul: I don't know the answer, but I'd just like to say your second question is significantly improved over your first one. =)
15:04:23 <dmwit> monochrom: You are naughty, in the original sense of the word meaning "of measure naught".
15:04:31 <monochrom> haha
15:06:05 <wroathe> More generally, why doesn't StateT have Monoid/Semigroup defined?
15:06:49 <wroathe> Actually, why does his Parsec type
15:06:50 <TextbookCyberBul> its a data stream from the Gaudi Cathedral, and its costly to read in. i was hoping to log the change of pixels and the initial image in binary as its unchanging except for lighting conditions for long periods of time
15:07:36 <wroathe> instance (Semigroup a) => Semigroup (StateT s m a)
15:07:58 <wroathe> and etc, for the other monad types
15:08:18 <TextbookCyberBul> also, given serious interruptions, the data is lost permanently - so a backup using Haxl could be used to recover the previous state and allow seemless continuation
15:08:53 <dmwit> wroathe: There is no good reason not to have them.
15:09:04 <dmwit> wroathe: I encourage you to write up a patch to the transformers library.
15:10:42 <wroathe> I might start just by raising an issue and seeing if it's been discussed at all
15:13:37 <dmwit> With a new enough GHC, it's just `deriving Monoid via Ap`. ;-)
15:13:46 <TextbookCyberBul> we are trying to fix the sensor, which would give a constant stream of data, and lower the burden on the processor. Haxl seemed like a good option in the interim 
15:15:30 <wroathe> dmwit: black magic
15:16:33 <jollygood2> anything in safe package or prelude that does this?
15:16:39 <jollygood2> > fromMaybe (error "My error message") (headMay [])
15:16:41 <lambdabot>  error:
15:16:41 <lambdabot>      Variable not in scope: headMay :: [a0] -> Maybe a
15:16:50 <jollygood2> headNote is closest, but I don't like error message
15:17:07 <jollygood2> "Safe.headNote [], my error message"
15:22:53 <infinisil> It kind of bothers me that depending on the order of type parameters, you can't make your type an instance of some typeclass that would fit
15:23:54 <infinisil> For example Pipes usually are `Pipe i o m a`, and it can't be a `Category` because the i and o aren't at the last positions
15:23:58 <__monty__> infinisil: Surely there's an extension that does that?
15:24:17 <infinisil> There is..?
16:01:18 <wroathe> dmwit: https://gitlab.haskell.org/JustinChristensen/transformers/commit/17b64dbdab69ce6330b902c97fdbdccaa4b0e9db
16:03:30 <wroathe> Unfortunately I don't have permission to open merge requests against the original repo :(
16:13:06 <jollygood2> does that include argv[0]?
16:13:09 <jollygood2> wrong channel
16:14:56 <wroathe> Shoot, the transformers libraries' maintainer is english
16:15:00 <wroathe> and it's midnight there :(
16:15:13 <wroathe> Shot him an email, we'll see how he responds
16:22:34 <fog> figured out where [exa] and i got out wires crossed, there were 2 "warnings" on the page, and we were both referring to the opposite
16:22:48 <fog> basically, it confirms that what was being attempted was impossible!
16:23:13 <fog> i have cobbled together something equivalent which does work and will submit it 
16:28:34 <fog> here is the working example;
16:28:35 <fog> https://github.com/fog-hs/rotateDistributed/tree/master/rotateDistributed
16:29:00 <fog> sorry...
16:29:01 <fog> https://github.com/fog-hs/rotateDistributed
17:17:01 <electricityZZZZ> wow, official arrayfire bindings for haskell?
17:36:03 <Axman6> electricityZZZZ: link?
17:37:22 <Axman6> found this, looks not so useful... https://github.com/arrayfire/arrayfire-haskell
17:37:43 <electricityZZZZ> saw a post saying they are in the pipeline
17:58:46 <rubik> anyone of you here actually employed working with Haskell or another functional programming language? 
18:00:46 <Cale> *waves hand*
18:03:52 <hpc> if puppet counts, yep
18:04:42 <rubik> it's sad .. in the region of Germany where i live no company uses (or even *knows*) that stuff, it's mostly C# or Java
18:04:55 <rubik> hpc: counts
18:05:05 * electricityZZZZ does rust which is the most imperative functional language
18:05:21 <electricityZZZZ> unlike haskell, which is the most functional imperative language
18:06:17 <Axman6> I am also employed to write Haskell
18:06:18 <rubik> electricityZZZZ: hehe, yeah rust is nice. i made some rust shirts last week with the gear and ferris
18:06:39 <Axman6> this is also my fifth job using Haskell
18:06:49 <electricityZZZZ> axman6: where, what industry?
18:08:38 <Axman6> Australia's largest job ad company
18:09:47 <electricityZZZZ> kewl,... so you must know everything about haskell job ads in australia ;-)
18:11:23 <rubik> that's cool
18:11:44 <electricityZZZZ> axman6: webdev?
18:12:34 <Axman6> no :)
18:13:04 <electricityZZZZ> wha..? what then
18:13:56 <rubik> electricityZZZZ: what not? :)
18:14:41 <electricityZZZZ> well what else is in a job ad other than a website...?
18:14:52 <electricityZZZZ> resume parsing or something?
18:15:02 <rubik> ahh, sorry, you meant that aspect
18:15:22 <rubik> some backend i think or a DSL for the API?
18:16:11 <rubik> so Cale what are you up to day to day?
18:18:07 <nitrix> Any of you feeling like naming my toy lisp interpreter?
18:18:15 <nitrix> Naming things is always the hardest part.
18:19:18 * ski . o O ( "Toy Lisp" )
18:19:21 <MarcelineVQ> Kapra
18:20:01 <rubik> hisp
18:20:36 <electricityZZZZ> how about lisp--
18:21:21 * nitrix writes it all down.
18:21:33 <electricityZZZZ> or maybe --lisp
18:21:36 <nitrix> The 8 ball will ultimately decide :P
18:21:50 <MarcelineVQ> call it 9Ball
18:22:13 <rubik> nitrix: do you have a repo? i also worked with "write yourself a scheme" the last days and am mostly finished
18:22:38 <nitrix> rubik, there will be a one once it has a name! :P
18:23:25 <nitrix> It's based mostly on newLISP, without a GC and pass-by-value semantics, in the spirit of Haskell I suppose.
18:23:36 <Cale> rubik: We build web and mobile applications for a variety of clients, as well as maintaining a bunch of open source Haskell stuff (Reflex, Reflex-DOM and Obelisk being the biggest things)
18:24:19 <Cale> rubik: My job function is to hop around between projects and make sure that everything is going smoothly, try to answer questions, pair with people and stuff.
18:26:29 <rubik> Cale: and is it fullfilling?
18:26:36 <Cale> Yeah, it's pretty good!
18:27:37 <nitrix> Back in my days, developers would write code! And the more senior and experienced at it they'd become, the more they'd write!
18:28:10 <Cale> haha
18:28:17 <Cale> Well, I do write some code
18:28:29 <electricityZZZZ> is anyone talking about building a more systems-friendly haskell?
18:29:23 <rubik> i also enjoy teaching haskell stuff and the thinking to other people. my "padawan" in the hackerspace is nearly 15 and understands more after some sessions as students at college which had to do it, but didn't really get to know it
18:30:00 <Cale> electricityZZZZ: I don't know what that would entail, Haskell is already pretty systems-friendly
18:30:01 <rubik> electricityZZZZ: what do you have in mind?
18:30:25 <electricityZZZZ> i know next to nothing about haskell but as i get started:
18:30:43 <Cale> electricityZZZZ: Depends a little on what systems in particular -- I suppose if you're building microcontroller software with very limited memory, cross compiling Haskell to it is probably not a great plan.
18:30:44 <rubik> cited from a stackoverflow: "why is GHC so darn fast?" "25 years of hard work"
18:30:54 <electricityZZZZ> 1 - afaik rust enforces utf8 strings "everywhere" except where explicitly appropriate
18:31:21 <Cale> But you might use Haskell as a metalanguage to build software for microcontrollers -- write a library for one-shot compilers that produce the software you'll run.
18:31:35 <Cale> (That's been done successfully a number of times)
18:31:51 <electricityZZZZ> 2 - if i pull in a haskell library, did they use a sensible integer type like i32/i64, or did they use an Integer?
18:31:57 <nitrix> Haskell has specific types for chaarcter, text and byte manipulation.
18:31:59 <electricityZZZZ> like arbitrary-ish precision haskell integer
18:32:01 <Cale> and of course, where I write, we write apps for mobile devices in Haskell, but those things are pretty beefy
18:32:38 <Cale> electricityZZZZ: Is Integer not sensible?
18:32:41 <rubik> OR use this one Haskell compiler to produce FPGA code from yours ...
18:33:06 <rubik> https://clash-lang.org/
18:33:15 <electricityZZZZ> Cale: yeah i don't think that for most use cases an arbitrary precision integer is a good idea
18:33:28 <Cale> electricityZZZZ: Any reason in particular?
18:33:32 <electricityZZZZ> lots of reasons
18:33:53 <electricityZZZZ> one is that if your integer is so big that you need such a thing, the odds are very good that there is a bug in your code
18:33:55 <nitrix> electricityZZZZ, most of them uses Int for the usual cases like for an offset or similar.
18:34:15 <electricityZZZZ> isn't it hard to enforce that across libraries that you pull in?
18:34:32 <Cale> electricityZZZZ: There's not really a need to enforce it...
18:35:20 <electricityZZZZ> and likewise 3) strictness across libraries -- although lazy vs strict is a point i really don't understand terribly well
18:35:22 <Cale> Usually I prefer to have the piece of mind that calculations I'm performing can't overflow
18:35:25 <nitrix> You don't really enforce it as much as you pick what's necessary. Usually the problem at hand will call for arbitrary precision and the libraries that'll help you solve the problem also acknowledge that and will be using arbitrary precision.
18:35:40 <nitrix> More realistically, you'll get functions typed `Num a`.
18:35:42 <Cale> peace*
18:35:42 <electricityZZZZ> Cale: i would rather the programmer be forced to handle the overflow
18:36:04 <Cale> electricityZZZZ: But then prior to each arithmetic operation, you need to do range testing
18:36:17 <Cale> Integer does that for you, and you can check at the end.
18:36:28 <Cale> (If you really want to squish the result into an Int)
18:37:08 <nitrix> electricityZZZZ, the library author should be able to write polymorphic function with a constraint on `Num` allowing you to use the numeric type of your choice.
18:37:11 <Cale> and it's nearly as fast as Int anyway
18:37:19 <Cale> (for Int-sized values)
18:37:30 <electricityZZZZ> nitrix: i don't agree here
18:37:36 <Cale> and yeah, a lot of things are polymorphic
18:37:40 <electricityZZZZ> for example see the problems that ruse has with Ord vs PartialOrd
18:37:53 <MarcelineVQ> I think Fin 256 is kind of a cool type, if it ever gets nice to use
18:38:01 <electricityZZZZ> different numeric types can have very different behavior
18:38:06 <nitrix> You agreeing doesn't change the answer though.
18:38:10 <Cale> electricityZZZZ: I don't know rust, but we get a *lot* of code reuse out of type classes.
18:38:34 <rubik> and that's totally awesome
18:39:00 <Cale> electricityZZZZ: Also, using Num, etc. means that your computations will work with AD
18:39:10 <Cale> i.e. you can automatically differentiate
18:39:14 <electricityZZZZ> i am saying this as a matlab jockey, different numeric types can be surprisingly different and subtle in their behavior
18:39:30 <Cale> Conversions between numeric types in Haskell are always explicit
18:39:44 <electricityZZZZ> so even if the language can allow you to abstract over them, the behavior of those types may be rather different...
18:39:52 <Cale> But it's possible to write programs which are polymorphic and work with any law-abiding numeric type
18:39:54 <nitrix> That's.... why they are different. You pick the one you need, but the author can still write their code to be polymorphic.
18:40:05 <electricityZZZZ> so i would be surprised if correct programs can themselves abstract over those types
18:40:14 <Cale> Be surprised then :D
18:40:14 <electricityZZZZ> in "many or most circumstances"
18:40:23 <nitrix> Well, you have laws for our type classes.
18:40:26 <rubik> nitrix: do you even have a macro system in your lisp? i'm thinking about how to do that the last few days
18:40:31 <Cale> http://hackage.haskell.org/package/ad
18:40:42 <Cale> ^^ check this out for a cool application of polymorphism
18:41:00 <nitrix> rubik, not yet on this project but I've done another one before.
18:41:30 <electricityZZZZ> it's easy to take a derivative incorrectly
18:41:57 <Cale> This stuff works as well as symbolic differentiation would
18:42:11 <rubik> nitrix: impressive. i have so much to learn
18:42:11 <electricityZZZZ> this is doing numeric differentiation?
18:42:17 <Cale> no
18:42:22 <Cale> It's doing automatic differentiation
18:42:37 <electricityZZZZ> symbolic?
18:42:44 <Cale> Not symbolic per-se
18:42:47 <nitrix> rubik, I'm not doing fancy quasiquotes. The macro receives the arguments unevaluated and you explicitly invoke eval on the parts you want evaluated. The macro returns a list that gets evaluated.
18:42:57 <electricityZZZZ> ...what else is there?
18:43:05 <Cale> https://en.wikipedia.org/wiki/Automatic_differentiation
18:43:07 <rubik> but lazy evaluation is now more clear after i studied a macro for that in common lisp
18:44:12 <Cale> electricityZZZZ: Basically, instead of working with numbers, you work with (lazily infinite) towers of derivatives.
18:44:17 <rubik> in this scheme interpreter i will try to bring in quasiquoting so you can unquote stuff that should be evaluated
18:44:30 <electricityZZZZ> so... symbolic
18:44:46 <Cale> You're not computing symbolic representations of the derivative
18:45:10 <rubik> electricityZZZZ: this can also be a data type. sometimes called symbol or atom
18:45:13 <Cale> You're basically building functions which manipulate lists of numbers which look like they manipulate single numbers
18:45:36 <Cale> A simple version (only good for first derivatives)
18:45:44 <Cale> would be to only keep track of pairs
18:46:20 * ski . o O ( <https://en.wikipedia.org/wiki/Dual_number> )
18:46:36 <Cale> So you augment your ordinary numbers with a "first derivative", and use the chain rule and rules from calculus to determine how basic operations are implemented
18:46:42 <nitrix> rubik, fyi, it's more than lazy evaluation. It's not just a thunk that gets evaluated later, you can actually crack the expressions open as if they are normal lists (because they are).
18:46:46 <electricityZZZZ> um i think this is saying that you're symbolically differentating on parts of the symbol tree and then numericaly evaluating or something,...?
18:46:59 <ski> electricityZZZZ, nope
18:47:05 <Cale> e.g. sin (x,dx) = (sin x, cos x * dx)
18:47:13 <rubik> electricityZZZZ: https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-16.html#%_sec_2.3
18:47:46 <Cale> electricityZZZZ: So then if you want the derivative at a, you can plug in (a,1) and look at the second component of the result of your operation on these numbers
18:47:56 <rubik> nitrix: didn't mean that, just thought out loud...
18:47:59 <electricityZZZZ> i dont understand your notation, sin takes one argument
18:48:11 <Cale> electricityZZZZ: We're defining sin on a pair
18:48:28 <Cale> electricityZZZZ: i.e. our new type of numbers are represented by pairs of numbers
18:48:36 <rubik> had a conversation with my padawan why C macros are not the same kind of stuff as lisp macros
18:49:22 <nitrix> rubik, e.g. (macro (foo expr) (replace (first expr) -) (eval expr))   (foo (+ 1 1))  replaces the + for - before evaluating the expression.
18:49:38 <Cale> electricityZZZZ: The idea is similar to the idea of implementing complex numbers, except instead of i^2 = -1, we're trying to get a new number epsilon for which epsilon^2 = 0
18:50:03 <rubik> nitrix: jep, macroexpansion before compiling or even evaluating
18:50:05 <Cale> and then every element of our new type of numbers can be written in the form a + b * epsilon, or represented by the pair (a,b)
18:51:08 <Cale> and by extending various arithmetic operations and basic functions to this type of numbers, we can compute derivatives of our composed functions at the same time as doing ordinary computations.
18:51:48 <electricityZZZZ> http://www.columbia.edu/~ahd2125/post/2015/12/5/ is a better explanation than wikipedia
18:51:49 <nitrix> rubik, my macro system is a bit different; they don't run during compilation... I decided to make that its own orthogonal feature. So, macros in my case are exactly like functions in terms of execution, but the arguments aren't evaluated.
18:52:08 <nitrix> rubik, in other words, fexprs if you're familiar with that.
18:52:31 <rubik> does that mean function exprs?
18:52:36 * ski was just about to ask about FEXPRs
18:52:47 <rubik> i knew symbolic and quote exprs
18:52:49 <nitrix> rubik, https://en.wikipedia.org/wiki/Fexpr
18:53:12 <Cale> rubik: So, we're not building up runtime representations of function expressions, we're writing functions which manipulate pairs of numbers really
18:53:31 <Cale> oh, sorry, I thought you were talking about AD as well :D
18:53:42 <nitrix> Some lisps go as far as having ONLY Fexprs, to unify functions and macros into a single concept. It's elegant, but it doesn't work in practice.
18:54:30 <nitrix> You get abysmal performance and your compiler is unable to do any static analysis.
18:54:41 <Cale> electricityZZZZ: So yeah, we can do this trick, only in even greater generality such that we can ask for as many derivatives as we like, and in some modes, have vector derivatives of various sorts, etc.
18:55:08 <electricityZZZZ> i'm still pretty confused here, because you can have a division operator in this tree
18:55:09 <Cale> electricityZZZZ: and it works perfectly well with library functions, so long as those library functions are polymorphic
18:55:14 <electricityZZZZ> and then my head hurts from thinking about the error analysis
18:55:30 <electricityZZZZ> not uncommonly you need to worry about needing to log transform your numbers when they get too small
18:55:56 <Cale> Well, sure, it's not necessarily going to work out perfectly near singularities, just as ordinary computations on numbers wouldn't.
18:55:58 <electricityZZZZ> the best solution isn't necessarily just using a 4096bit float or whatever
18:56:09 <electricityZZZZ> but um, that's the whole hard part
18:56:24 <electricityZZZZ> otherwise why wouldn't you just do naieve symbolic differentiation?
18:56:30 <Cale> But in general, it's a very practical technique. I know a guy who did some really neat stuff with GANs using it
18:56:42 <electricityZZZZ> i know the "inventor of gans"
18:57:29 <Cale> It's nice to be able to write an algorithm which does too much linear algebra to think about all at once, and then automatically pull out a derivative which is about as efficient to compute
18:58:25 <electricityZZZZ> why do i want an activation function which is so complex that i need to automatically differentiate it?
18:58:47 <Cale> Well, you're trying to do optimisation, right?
18:59:04 <Cale> It would be nice to know how changing the inputs affects the results you're getting
18:59:38 <rubik> and if your system grows, you want to control complexity and have high composability in the long run
19:00:12 <Cale> Yeah, rethinking the entire computation you're doing, but differentiated, is a lot more work.
19:00:18 <electricityZZZZ> um i think you might not be seeing what i am saying here
19:01:12 <electricityZZZZ> if my activation function is sin(cos(x*y)/y + log(x)^y) and then might change to sin(x^4*(cos(y))^5)*cos(x) shortly thereafter, this is useful
19:01:51 <electricityZZZZ> but there are very few "useful" activation functions
19:01:59 <ski> ("GAN" being ?)
19:02:10 <Cale> Generative Adversarial Network
19:02:13 <argent0> generative adversarial network
19:03:26 <electricityZZZZ> ski: generative adversarial network. it is an unsupervised (rather than supervised) machine learning technique which can generate a distribution on your data by having a neural network try to guess when a "generating" neural network is selecting a sample from your data or from the synthetic model
19:03:30 <ski> (you can use conditionals, and loops, with AD)
19:03:41 <electricityZZZZ> ski: okay now i'm interested
19:04:09 <Cale> yeah, I guess I neglected to mention that
19:05:01 <Cale> Since these things are just like any other numbers you're using, essentially the entire programming language is available
19:05:30 <electricityZZZZ> okay now that's interesting
19:05:38 <electricityZZZZ> but i dont know what that would mean in regards to optimization
19:05:52 <electricityZZZZ> and furthermore there is a topic of research called derivative-free optimization,...
19:05:55 <Cale> Well, being able to compute gradients lets you do gradient descent
19:06:05 <nshepperd1> With conditionals only the path that is actually taken gets differentiated through
19:06:25 <electricityZZZZ> right, do derivative-free methods perform way worse than SGD etc?
19:06:27 <Cale> nshepperd1: Yeah, if your conditionals are too wacky, it breaks down
19:07:07 <electricityZZZZ> honestly i dont understand the obsession with gradient descent, it should taper off in utility,...
19:08:07 <electricityZZZZ> is there a good example of gradient descent on programs (if need be, on haskell programs)?
19:08:15 <Cale> electricityZZZZ: I don't know the details (and they're secret), but supposedly ekmett managed to train a GAN to perform the task of rotating 2D images of 3D objects with 100x less training input than existing methods, and something about it involved automatically differentiating the whole thing
19:08:16 <sclv> does anyone remember the blogpost/discussion where ghc effectively stopped putting in a stack limit?
19:08:38 <sclv> and/or does anyone know of any current bugs where ghc accidentally puts in a stack limit anyway?
19:09:09 <Cale> (and also using techniques like CycleGAN where he was following around a big category-theoretical diagram of GANs and getting loss functions around many commuting faces)
19:10:37 <electricityZZZZ> ski: training a model on programs? 
19:10:58 <rubik> Cale: sounds like some kind of magic
19:11:06 <c_wraith> that was a long time ago now.
19:12:07 <sclv> we're hitting a problem where unless we set an explict stack size we get overflows at low stack usages
19:12:08 <electricityZZZZ> cale: sorry this doesn't sound relevant, differentiation is simply not a limiting factor in GAN training, you can even write the derivatives by hand once since they typically use ReLU units
19:12:16 <sclv> on some beefy AWS box
19:12:25 <sclv> so I think ghc might be calculating something wrong
19:12:50 <Cale> electricityZZZZ: I don't know exactly what the details are, maybe Ed would be willing to part with some additional ones, but I don't think he's here right at the moment.
19:13:08 <sclv> but also i want the post (i think it was by neil) that argued to get rid of stack size limits, to prove to my team that "no, this isn't a space leak, its just a ghc bug"
19:13:33 <electricityZZZZ> i am waiting for the machine learning research community to hit the limits of gradient descent and jump on to some other optimization technique
19:14:02 <rubik> sclv: so it's time to call the haskell research team
19:15:04 <Cale> electricityZZZZ: It's hard to imagine that you'd want to fail to exploit that kind of structure when you had it.
19:16:18 <rubik> i'm going to sleep now. read you later :)
19:21:22 <electricityZZZZ> so anyway,... for systems programming, the simple things that come to mind are 1) strings being difficult, not enforced across libs 2) numeric types not thought out (imo) 3) laziness-first doesn't seem to make sense (although i'm not 100% sure of this) 4) gc latency,... do linear types take care of these concerns? 5) getting to consistently good performance appears to require an intimidating amount of language 
19:21:22 <electricityZZZZ> mastery 6) lists are rather cache unfriendly, and again are probably ubiquitous in the library ecosystem... is this an issue?
19:22:18 <dmwit> ?tell wroathe Nice! I wonder... do the instances still fly if you relax the Monad m constraint to Applicative m?
19:22:19 <lambdabot> Consider it noted.
19:23:11 <dmwit> electricityZZZZ: You might like "The Simple Essence of Automatic Differentiation", http://conal.net/papers/essence-of-ad/essence-of-ad-icfp.pdf
19:23:27 <Cale> electricityZZZZ: For what it's worth on the first point, a lot of the important stuff uses either Text or ByteString
19:23:34 <Cale> (as appropriate)
19:23:55 <dmwit> Hm. Reading more of your messages, perhaps you might not like it. =P
19:23:59 <Cale> On #3, laziness first is the only way to make laziness valuable at all
19:24:10 <electricityZZZZ> oh yeah the target guy :)
19:24:22 <Cale> Most of the benefit of laziness comes from the fact that it lets you compose functions together that you could not otherwise compose
19:24:28 <Cale> But laziness is a recessive trait
19:24:47 <Cale> If something forces too much computation to occur, there's no way to take it back
19:25:01 <electricityZZZZ> so if i strictify something that propagates down the thunks all the way?
19:25:56 <Cale> Well, it means that if the user of the thing you strictified would rather the things it additionally evaluated weren't so, they can't undo that.
19:26:25 <Cale> But if you produce a thing which only evaluates what's required, someone else can always come along and force more evaluation to occur
19:27:25 <Cale> and the main benefit of laziness is that it lets you break down problems into parts that you otherwise couldn't
19:27:45 <Cale> Like, generating a tree of options in a game, and then traversing only the interesting part of that tree
19:28:03 <Cale> (in possibly multiple different ways)
19:28:32 <Cale> It's more compositional than if you have to mix up the logic of which nodes to explore and how to generate them
19:28:53 <electricityZZZZ> right but i rarely compute things that i don't need to when i write code
19:28:57 <dmwit> ?tell wroathe Also, why only Reader and State? =P
19:28:57 <lambdabot> Consider it noted.
19:29:15 <Cale> Think about it as *specifying* things that you might not need to compute
19:29:23 <electricityZZZZ> and if i am computing things that i don't need to, typically i would need a better algorithm or somesuch
19:29:25 <Cale> because you may or may not need them
19:29:46 <Cale> (but the rest of your program can figure that out later)
19:30:09 <Cale> Often you define functions at points where you don't evaluate them, I'm sure
19:30:11 <electricityZZZZ> well no i understand the concept of laziness, the issue is that it looks like 1) there might be certain applications (database queries or somesuch) where lazy batching of requests might actually be useful and
19:30:39 <dmwit> electricityZZZZ: Non-Trivial Lazy Evaluation https://stackoverflow.com/q/7868507/791604
19:30:40 <electricityZZZZ> 2) (most of the time) laziness is just a memory leak and unnecessary program pausing
19:30:53 <Cale> That's quite untrue
19:31:12 <electricityZZZZ> i find it dubious that "most of the time" an automatic system could find inefficiencies in my code worth removing
19:31:13 <Axman6> electricityZZZZ: you sounds like you need to learn a lot more Haskell before trying to make the changes you believe are necessary
19:31:50 <Cale> Think about it like this -- we can classify functions vaguely into 4 (or 5) types based on whether they consume or produce things which have many separately evaluatable parts
19:31:56 <Axman6> most of what you've said is the last 20 minutes is untrue and bassed on not understanding how things work
19:32:01 <dmwit> You say, "I rarely compute things that are unnecessary". I think that's probably right. But the way you achieve this is unfortunate: you achieve it by modifying the function/procedure/whatever that produces data to look at, so that it is aware of what data the consumer wants to look at.
19:32:21 <dmwit> Lazy evaluation lets you separate the concerns of producing data (just write a function which is capable of producing it all) and deciding what to look at.
19:32:24 <Axman6> like Integer, it is nearly exactly as fast as Int for values which fit in Ints because it has a special case for small numbers:
19:32:28 <Axman6> @src Integer
19:32:28 <lambdabot> data Integer = S# Int#
19:32:28 <lambdabot>              | J# Int# ByteArray#
19:32:30 <Cale> I'll call a data structure "small" if it has few parts which we could separately evaluate (even if that thing itself might take a bunch of memory)
19:32:39 <Cale> and large if it has many parts
19:32:43 <heatsink> I don't know what's typical practice now, but I've heard the advice that you should declare datatype fields strict unless you have a reason not to
19:32:56 <Cale> So we have 4 cases: small -> small, small -> large, large -> small and large -> large
19:33:16 <Cale> small -> small, basically nobody cares about the evaluation mechanism
19:33:24 <Cale> Strict and lazy are going to be about the same
19:33:46 <Cale> small -> large, you might gain benefit from laziness because you may not have to produce the entirety of the result
19:34:19 <Cale> large -> large, you might benefit from streaming (being able to produce part of the result from part of the input)
19:34:24 <Axman6> Also, I very happily do quite low level, performance sensitive programming in Haskell all the time. I wasd writing some code last night for doping a specialised sort of millions of integers of a particular form, which ended up being able to handle something like 4 million integers per second, while keeping the code generic enough to support all types which implement FiniteBits
19:34:34 <Cale> large -> small is where strictness is really needed
19:34:45 <Cale> Well, and even this breaks down into cases a bit
19:34:54 <Cale> You might benefit from laziness if you're searching for something
19:35:05 <Cale> If you're using all the input though to form a "summary"
19:35:13 <Cale> that's where you want the strictness annotation
19:35:18 <Axman6> heatsink: you should declare it strict if it's likely to lead to a thunk building up if it is not strict
19:35:34 <Cale> In basically all the other cases, laziness is equal to or better than strictness.
19:35:58 <Axman6> most often I do this with the arguments to recursive worker functions
19:36:07 <Cale> Axman6 just gave another characterisation which is basically equivalent to what I'm saying :)
19:36:45 * Axman6 doubts that, as Cale knows a lot more about... most thing... than himself
19:36:45 <Cale> "Is it likely to build up a large thunk?" is roughly the same thing as "Am I taking many separate little pieces and combining them together into something which must be evaluated all at once?"
19:36:52 <Axman6> s*
19:37:12 <Cale> We have the same rule of thumb for strictness, pretty much :)
19:37:30 <Axman6> :highfive:
19:37:42 <Cale> electricityZZZZ: Does that make sense?
19:38:31 <Cale> electricityZZZZ: It takes a while getting used to it, but eventually it's really not a daily sort of worry, and you eventually can see 99% of situations where you'll need strictness from a mile away.
19:38:37 <electricityZZZZ> small -> small can lead to death by a thousand cuts, i think (?)
19:39:07 * Axman6 agrees with Cale
19:39:07 <electricityZZZZ> why can't haskell automatically manage strictness annotation
19:39:14 <electricityZZZZ> to achieve a certain level of responsiveness
19:39:18 <Axman6> it does, so some extent
19:39:18 <Cale> electricityZZZZ: Well, if you're evaluating something small which depends on something small, it can't cause a problem, and you're evaluating exactly as much as you would be under strict evaluation.
19:39:26 <Axman6> GHC has a strictness analyser
19:39:46 <Cale> electricityZZZZ: and probably the compiler is already going to make things like that stricter for you if it can benefit from that
19:39:57 <Axman6> electricityZZZZ: the wording of your question implies you don't have a good grasp of laziness though
19:40:06 <electricityZZZZ> i'm not saying i do,
19:40:27 <electricityZZZZ> i have dabbled in haskell and am thinking of dabbling again but have some reservations...
19:40:41 <Cale> electricityZZZZ: Yeah, Haskell isn't really "lazily evaluated" even though we tend to say this
19:41:08 <Cale> It's really a language "with nonstrict semantics", which means that the termination behaviour and result of a Haskell program must be as if it were lazily evaluated
19:41:17 <electricityZZZZ> ok
19:41:27 <Cale> But the compiler may rearrange the order of evaluation however it sees fit if it can prove you're going to evaluate things
19:42:02 <Cale> So for some things where it's clear that if you demand the result, then you demand the input, you'll get strict evaluation
19:44:25 <Axman6> electricityZZZZ: I ashould add, I care a lot aboutperformance (much more than I should). All the stuff you do to make programs fast in languages like Rust are also available to us (baring the ownership stuff, though immutability by default is close). I find writing low level code in Haskell quite pleasant, I can do all the mit manipulation tricks I want (I keep my copy of Hacker's Delight right by me), and all the mutable algorithms which dep
19:44:25 <Axman6> end on contiguous data in memory are a pleasure to write, because we can write them in a way which is guaranteed to be pure on the outside (using the ST monad)
19:45:00 <Cale> It's not always perfect about it though, so for cases where you'd accidentally use a really egregious amount of memory if the compiler screws up, you'll want to explicitly annotate from time to time. This happens astoundingly little in the sort of work that I do (which is mostly web and mobile applications) -- in some sorts of programs though, you really do have to care.
19:45:11 <heatsink> Axman6: Do you read core when you're optimizing for performance
19:45:13 <heatsink> ?
19:45:15 <Axman6> when I'm writing that sort of code, I tend not to use much laziness at all, but that's because I do have that choice
19:45:24 <Axman6> heatsink: rarely
19:45:48 <Axman6> I tend to just go off benchmarking results to see if something's faster, it's not very precise
19:46:07 <Cale> If you know that you can't benefit from laziness, it can make sense to add some strictness annotations to your datatypes especially.
19:46:24 <electricityZZZZ> so "lists everywhere and cache unfriendliness" isn't a concern?
19:46:44 <Axman6> no, most lists don't exist at runtime anyway
19:46:50 <Axman6> lists are control flow
19:47:10 <Cale> electricityZZZZ: Well, cache unfriendliness is a concern, but it's something we just accept for the most part, with the knowledge that if we need to implement something in C or assembly and link it in, we can do that easily enough.
19:47:24 <Cale> and yeah, lists aren't so much a data structure as a control structure
19:47:42 <Axman6> it's also not particularly difficult to write code which can improve cache friendliness
19:47:45 <Cale> Lists are ubiquitous in Haskell for the same reason that loops are ubiquitous in every imperative language
19:48:14 <Cale> Just as a loop may have no iterations (because its precondition isn't met) or consists of a single iteration followed by another loop
19:48:16 <heatsink> Nice to know.  I've found it hard to write allocation-free loops without reading the core code
19:48:18 <Axman6> a list is a stream which tells you what the nex element is or if there aren't any more elements
19:48:20 <electricityZZZZ> also this is a super lame data point, but i have visited various websites which say their backend is written in haskell, and they are invariably laggy...
19:48:32 <Cale> Lists are either empty, or consist of a single element followed by another list
19:48:40 <electricityZZZZ> if they still exist at all
19:49:24 <Cale> I apologize that this site still sucks right now (we're writing a new one) but try https://reflex-frp.org/getstarted
19:49:52 <Cale> There's not much to it, but eh, it puts something on the screen rather quickly :)
19:50:22 <electricityZZZZ> sure looks like the images load a bit slowly
19:51:04 <Cale> Well, the images might not be optimised for size, but they're just being served statically
19:51:37 <Cale> The DOM is being rendered to HTML by the backend, and then javascript is being loaded which takes over the elements
19:51:52 <electricityZZZZ> but yeah otherwise it is snappy
19:52:10 <electricityZZZZ> takes a little bit of time to hydrate...
19:52:20 <electricityZZZZ> like two seconds or something
19:52:21 <Axman6> Looks lik enginx is serving the images
19:52:25 <Axman6> nginx*
19:52:49 <electricityZZZZ> is that warp on the backend?
19:52:55 <Cale> Snap
19:53:06 <Axman6> which uses warp yeah?
19:53:18 <Cale> snap uses snap-server
19:53:27 <Cale> I think?
19:54:24 <Cale> We have some jsaddle-warp stuff in Obelisk, which runs the code which controls the DOM in native code, and serves up a tiny bit of javascript that takes orders from it
19:54:31 <Cale> (via an additional websocket)
19:54:49 <Cale> That's how we do debugging (running such a server in GHCi, basically)
19:55:08 <Cale> and it's similar in nature to what we do on mobile
19:55:29 <Cale> (The Haskell runs in native code, and controls the contents of the DOM in a web view)
19:57:23 <electricityZZZZ> yeah it is nifty
19:59:09 <Cale> http://reply.obsidian.systems/ -- here's a lisp interpreter that was built in a weekend. It was from before we had this hydration stuff available though.
20:00:03 <Cale> But it runs entirely client-side and evaluates your program after each keystroke, so you should be able to get some sense of performance from that
20:01:06 <Cale> Try something like (define (f x) (* x x)) and then (f 5)
20:01:16 <Cale> and then try editing the definition of f :)
20:02:06 <heatsink> It doesn't seem very responsive to me, but maybe that's because I tried evaluating (Omega Omega)
20:02:12 <Cale> lol
20:03:04 <electricityZZZZ> cute
20:04:12 <sicklorkin> that's pretty cool.. only 5.6M :)
20:04:38 <Cale> Haha, that sounds like it might not be compressed
20:04:47 <monochrom> Yes I was thinking (lambda (x) (x x)) too.
20:04:50 <sicklorkin> yeah 577 compressed
20:04:57 <monochrom> I just taught that to my students today.
20:07:48 <Cale> https://cale.l5.ca/Demos/PrismataUnits/PrismataUnits.jsexe/
20:08:35 <Cale> hmm, looks like they added black backgrounds to the images, they used to be transparent...
20:09:04 <Cale> (all this data is coming from a site I don't control, this is another old demo of mine)
20:10:10 <Cale> https://cale.l5.ca/Demos/PrismataUnits/PrismataUnits.hs -- the code for it :)
20:10:31 <Nevoic> Hey, I was doing a coding challenge and I tried it in Haskell, but since it was timed I gave up half way through and swapped to Kotlin because I couldn't figure it out. Here's the Haskell code, incomplete, https://bpaste.net/show/H09g and the respective Kotlin code: https://bpaste.net/show/-oXS (tried to make them as similar as possible). Any help 
20:10:31 <Nevoic> would be appreciated :)
20:10:49 <Cale> Btw, can anyone tell me if you're getting warnings about phishing? I was having trouble earlier because I think my subdomain provider got mistakenly flagged as a whole.
20:11:11 <heatsink> I didn't get a warning
20:11:21 <Nevoic> I did try changing the result of `f` to be an IO Int, but that made the fold not function, and I couldn't really unwrap the IO inside a lambda that I passed to fold, so that didn't seem like a viable path.
20:11:21 <sicklorkin> Cale: flagged by who? maybe I can help w/that
20:11:27 <Cale> cool, they must have fixed it
20:11:29 <Cale> Google
20:11:50 <sicklorkin> I'm not getting a warning
20:12:09 <Axman6> Nevoic: you probably want foldM in that cased
20:12:12 <Axman6> -d
20:12:13 <Cale> Nevoic: If you want your function to be able to do IO, it should produce IO actions.
20:12:18 <Axman6> :t foldM
20:12:20 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
20:12:51 <Axman6> f :: Int -> String -> IO Int
20:13:13 <Nevoic> I had the presence of mind to do that, I just couldn't make the implementation work. I think foldM was what I was missing.
20:13:37 <Cale> You can also just write a loop recursively
20:13:47 <Nevoic> I'm not a fan of imperative code.
20:14:02 <Nevoic> It'd be ironic to move from Kotlin -> Haskell and write more imperative code instead of less lol
20:14:16 <Axman6> and where you just return an int, you need pure or return: f n "inc" = pure $ n + 1
20:14:23 <Nevoic> oh wait nvm, I thought you meant iteratively (like a for loop)
20:14:29 <Nevoic> I guess recursively probably wouldn't be imperative? shrug
20:14:34 <Axman6> well, you're doing IO, so it's going to be somewhat imperative
20:14:44 <monochrom> Depends on what you mean by "imperative".
20:15:05 <monochrom> The problem specification though looks very effectful on purpose.
20:15:12 <Nevoic> I thought the distinction was imperative code describes how to do something, and declarative code describes what to do.
20:15:21 <Axman6> "of vital importance, crucial" =)
20:15:34 <EvanR> how to do something, vs what something IS
20:15:42 <Nevoic> So in my mind it was a sliding scale, where all the way down at machine code you'd write ultimate imperative code, and that would describe how to do something.
20:15:50 <Nevoic> And then as we abstract levels you're able to write things like "print"
20:15:57 <Nevoic> And that describes what to do (printing) instead of how to do it.
20:15:59 <Cale> Nevoic: Like, repl :: Int -> IO (), and then you have repl read a command, apply f to it, performing whatever action to get a new n, and then apply itself to the new value of n.
20:16:12 <Nevoic> I don't see how IO (like printing/receiving input) is inherently imperative though.
20:16:25 <Nevoic> So I don't follow how "you're oding IO, so it's going to be somewhat imperative"
20:16:29 <EvanR> "what to do" doesn't get far enough away from imperative, since you're still talking about doing stuff
20:16:30 <Axman6> well, it's not really
20:16:49 <monochrom> Well this is why I brought up "what you mean".
20:17:02 <Cale> It's not *inherently* imperative, but the IO monad is vaguely imperative, insofar as you combine IO action values to describe a sequence of actions to perform.
20:17:06 <monochrom> Because other people have other meanings in mind.
20:17:06 <Nevoic> monochrom: I posted the distinction I'm using.
20:17:23 <Nevoic> "I thought the distinction was imperative code describes how to do something, and declarative code describes what to do." is this generally an agreed upon definition?
20:17:39 <monochrom> For example other people mean effectful. So IO is tautologically "imperative" just because effectful.
20:17:39 <EvanR> declarative code describes what something is
20:17:43 <heatsink> Imperative code describes what sequence of actions to perform
20:18:12 <EvanR> HTML, json, declarative langauges
20:18:24 <Nevoic> Those two definitions that were given are not mutually exclusive.
20:18:35 <Nevoic> I.E if "something" is a sequence of actions, then it fits both definitions.
20:18:47 <ski> in "Do this ! Then, do that !", the "then" is typically considered a crucial part
20:18:53 <Nevoic> because you'd be describing what "something" is (a sequence of actions) and you'd be describing what sequence of actions to perform.
20:19:08 <heatsink> Sure.  For some problems, a sequence of actions is the clearest description
20:19:18 <heatsink> clearest description of what you want to accomplish
20:19:32 <Nevoic> I always thought imperative/declarative was a dichotomy. 
20:19:36 <Nevoic> But you're saying it's not?
20:19:37 <EvanR> yep imperative code could be given in a declarative language
20:19:43 <EvanR> see XML...
20:20:10 <Axman6> :'(
20:20:20 <Nevoic> The second paragraph of "imperative programming" on the wiki page: "The term is often used in contrast to declarative programming, which focuses on what the program should accomplish without specifying how the program should achieve the result."
20:20:25 <monochrom> This is why I have stopped using those words for a long time.
20:20:26 <Nevoic> This is the definition I generally use.
20:20:36 <Nevoic> But it seems that the waters are very muddied here.
20:20:51 <EvanR> well as long as you give the definition at some point youre good
20:20:53 <Nevoic> I've never had issue talking to people about what imperative meant, didn't know this was like a conflicting thing.
20:21:08 <monochrom> Hell I have completely abandoned "paradigms" for a long time.
20:21:22 <EvanR> yeah haskell really makes to reevaluate sometimes
20:21:26 <EvanR> makes you*
20:21:47 <Axman6> but only when you've written your code not to use sharing
20:21:55 <Nevoic> I'm fine with having to rethink things, but not for absolutely no reason. Can someone provide an alternative definition and a source for it?
20:22:00 <EvanR> badum ch
20:22:07 <Axman6> =)
20:22:07 <Nevoic> Since it seems about 0 people here use the definition from the page I cited.
20:22:33 <EvanR> wikipedia def comes from many angles, people with many different backgrounds
20:22:46 <heatsink> There isn't broad agreement on what "declarative" means.  Nevoic's quote is a reasonable way to put it
20:22:49 <EvanR> but i don't think it's contradicting anyone right now?
20:23:16 <monochrom> Oh I use that definition too. But even with a Wikipedia definition for "tall" vs "short" we still won't ever agree on whether Bruce Lee was tall or short.
20:23:27 <Kuleshov> https://www.youtube.com/watch?v=bY7-hqtSpTY –ö–∏–Ω–æ - –ú–∞–º–∞ –ê–Ω–∞—Ä—Ö–∏—è (Mother Anarchy)
20:23:39 --- mode: ChanServ set +o monochrom
20:23:48 --- mode: monochrom set +b *!*@128.0.141.165
20:23:48 --- kick: Kuleshov was kicked by monochrom (Kuleshov)
20:23:59 <Nevoic> Earlier you had said ""what to do" doesn't get far enough away from imperative, since you're still talking about doing stuff" EvanR
20:24:09 <Nevoic> So my understanding was you didn't agree with the definition.
20:24:28 <EvanR> "what to do" still sounds imperative to me
20:24:58 <Nevoic> Are you distinguishing between the word "do" and "accomplish"?
20:25:09 <Nevoic> "The term is often used in contrast to declarative programming, which focuses on what the program should accomplish without specifying how the program should achieve the result."
20:25:14 <heatsink> You could take "what to do" to mean either "what action to perform" or "what the program should accomplish"
20:25:35 --- mode: monochrom set -b *!*@128.0.141.165
20:25:42 --- mode: monochrom set -o monochrom
20:26:17 <EvanR> accomplish might mean for example, merely define a data structure to be interpreted in a way to be determined later
20:26:32 <Nevoic> I can't tell if English is just an absolutely terrible language or if everyone in here is being extremely pedantic.
20:26:43 <monochrom> IMO yes to both.
20:27:05 <EvanR> hey, there's no one true definition of something
20:27:09 <monochrom> Plus arguing whether Bruce Lee is tall or short is futile regardless of language.
20:27:11 <EvanR> no one's wrong
20:27:20 <heatsink> When I ask someone to tell me what their function does, some people will literally interpret it in their head and say what happens step by step
20:27:25 <Nevoic> It's not about being wrong/right, words lose their meaning without a shared definition.
20:27:25 <heatsink> other people will tell me what the function achieves
20:27:34 <Axman6> On this blessed day, we are all wrong
20:27:38 <Nevoic> You're right semantics is a field without a "true" answer, but without any answer language becomes useless.
20:27:39 <heatsink> Because of that, I try to avoid the phrase and use more precise language
20:27:41 <monochrom> Because you are only supposed to compare two persons, not assert that a person is "tall" in isolation.
20:28:33 <monochrom> Oh add: People are also lazy in wording.
20:28:36 <Nevoic> monochrom: I fall into agreement with you, like I said earlier imperative/declarative is a scale to me. That's why it's odd when someone says "this *is* imperative"
20:28:46 <Nevoic> IIRC I only ever said "X is more imperative than Y" or something like that.
20:29:18 <Nevoic> but some people have said things like "IO is inherently somewhat imperative" or "X is an imperative language" etc.
20:29:30 <Nevoic> and those things don't resonate with me or the only definition of the word "imperative" in regards to programming I've found.
20:29:52 <EvanR> ok
20:29:54 <Nevoic> like I said earlier, if someone has an alternative definition and a source for it I'd be happy to read it, otherwise I feel like we're changing the meaning of words for no reason.
20:47:38 <maralorn> :t maybe false (== "bump") . listToMaybe
20:47:40 <lambdabot> error:
20:47:40 <lambdabot>     ‚Ä¢ Variable not in scope: false :: Bool
20:47:40 <lambdabot>     ‚Ä¢ Perhaps you meant data constructor ‚ÄòFalse‚Äô (imported from Data.Bool)
20:47:50 <maralorn> :t maybe False (== "bump") . listToMaybe
20:47:52 <lambdabot> [[Char]] -> Bool
21:31:02 <Nevoic> Does anyone know of a function of type `Monad m => (b -> m a) -> b -> m b`?
21:31:06 <Nevoic> I searched Hoogle for it and didn't find it.
21:31:48 <Axman6> feels related to (<$)
21:31:52 <Axman6> :t (<$)
21:31:53 <Lears> id?
21:31:54 <lambdabot> Functor f => a -> f b -> f a
21:32:06 <Lears> Oh, nvm.
21:32:10 <Nevoic> The name I would give the function is `also` and the purpose would be to be able to say things like "name `also` print", instead of "do; print name; return name"
21:32:30 <sarahzrf> u cld at least say for short `name <$ print name'
21:32:31 <Axman6> @pl \f b -> b <$ f b
21:32:31 <lambdabot> ap (<$)
21:32:32 <Nevoic> Mimicking `also` from Kotlin or `tap` from Ruby.
21:32:40 <sarahzrf> haha i was about to mention `tap'
21:33:29 <Nevoic> Yeah I suppose `<$` is close enough to what I'm looking for.
21:33:38 <Nevoic> Would be cool if I could do `name <$ print` instead of `name <$ print name`
21:34:05 <Axman6> make it
21:34:08 <jackdk> `tap = ap (<$)`, so `tap = (<$) & ap`, so `t = (<$) &`
21:34:15 <sarahzrf> ha
21:34:20 <Nevoic> Yeah I did, I just mean in the std lib.
21:34:21 <Axman6> a <! f = a <$ f a
21:34:33 <Axman6> jackdk: <3
21:34:42 <sarahzrf> :t ((<$) &)
21:34:44 <lambdabot> Functor f => ((a -> f b1 -> f a) -> b2) -> b2
21:34:53 <Nevoic> The way I discovered the type was by making the type I want and having the type inference figure out the type for me.
21:34:55 <Nevoic> lol
21:35:01 <Nevoic> making the function*
21:35:08 <Nevoic> So I had a functioning `also`.
21:35:20 <jackdk> Axman6: `(<!)` has unfortunate connotations wrt Data.Functor.Alt from semigroupoids
21:35:23 <Nevoic> I kinda like `<!` there though.
21:35:59 <jackdk> Be funny if you could make `(<3)` work through the creation of a truly unholy `Num` instance
21:36:22 <sarahzrf> :t (<3)
21:36:24 <lambdabot> (Ord a, Num a) => a -> Bool
21:39:49 <ski> Nevoic : you could call it `before', perhaps
21:40:24 <Nevoic> I would probably call it `also` or `tap` if I were to use a word instead of an operator.
21:40:27 <Nevoic> to mimic Ruby/Kotlin.
21:40:29 <Nevoic> shrug
21:41:08 <ski> (iirc something like this is called `before', in OCaml)
21:41:09 <sarahzrf> i tap `name' to add 3 mana to my pool
21:46:14 <Axman6> let f &> a = f a $> a
21:54:03 <Nevoic> https://bpaste.net/show/6gdq which function do you guys like better? I would assume pretty much everyone would say f2
21:54:29 <Nevoic> Because f2 returns an IO Int and f1 returns an Int, which is lying.
21:54:37 <Nevoic> "lying".
21:56:42 <Axman6> uh definitely f2, there is absolutely no need to use unsafePerformIO
22:04:55 <ski> someone might say `f1', if you're okay with those effects happening out of order, or more than once, or not at all
22:10:43 <monochrom> Yeah unsafePerformIO is fragile if you actually care about the effect.
22:11:31 <monochrom> There are some safe restricted use cases, but normal output is not one.
22:13:19 <EvanR> "if something does IO, then it had better say so in the type"
22:13:34 <EvanR> (if the IO is observable in a way i care about, maybe)
22:23:04 <Nevoic> I mean I tested it and it worked as expected.
22:23:11 <Nevoic> idk what people are talking about with out of order etc.
22:23:48 <Axman6> it worked this time
22:24:01 <ski> think of it as the implementation being *allowed* to change order, &c.
22:24:13 <ski> it might do it once in a blue moon
22:24:17 <Axman6> it's certainly not guaranteed to work in the future. since you've lied about thew types, GHC is free to change your code in ways which believe those lies
22:24:41 * ski . o O ( "If you lie to the implementation, the implementation will get its revenge !" )
22:24:57 <dminuoso> Nevoic: "It worked for me" and "It is guaranteed to work" are two completely different stories
22:36:10 <int-e> Nevoic: https://bpaste.net/show/bEUo is about the simplest scenario for things going wrong. And even if it happens to work for your (fairly simple, I think) program... this approach doesn't scale; you will find your program behaving strangely, depending on how exactly you compile it, and it will be nearly impossible to figure out why.
22:37:12 <Nevoic> I have no idea what !_ is or what compiling with -0 vs not with -0 means.
22:37:28 <int-e> -O (a letter) turns on optimizations.
22:40:29 <sigmatau> -O -O1 -O2 
22:40:33 <sigmatau> Do this
22:41:28 <Nevoic> from now on I'm just going to run all my programs with -O9999
22:41:30 <Nevoic> for ultimate speed
22:42:23 <sigmatau> int main(int argc, argc *argv[]) { int a, b, c; c = a + b; b = c * a; a = c - b; return 0} gcc -Og -S prog.c; gdb prog; (inside of gdb) b main; run; disass 
22:42:26 <sigmatau> then 
22:42:35 <sigmatau> gcc -O2 -g -S prog.c 
22:42:38 <sigmatau> and gdb that 
22:42:41 <sigmatau> it will be different. 
22:42:49 <sigmatau> 'compiler optimizations'
22:43:03 <int-e> all I see is undefined behavior.
22:43:13 <int-e> oh and a syntax error.
22:44:05 <sigmatau> the undefined behavior doesn't matter
22:44:09 <sigmatau> and i'm sure he can insert ; here
22:44:16 <sigmatau> the point is looking at the code
22:44:20 <sigmatau> you dont even have to set the breakpoint.
22:44:26 <sigmatau> just disass main 
22:44:40 <sigmatau> on -O -O1 and -O2 
22:44:51 <int-e> You won't even get an executable.
22:45:13 <sigmatau> leaq   2(%rsi, %rdi, 4), %rax <--- it will do things like this 
22:45:21 <sigmatau> it's not actually doing what you think 
22:45:30 <sigmatau> that is 2(4x + y)
22:46:31 <sigmatau> and yeah 
22:46:36 <sigmatau> gcc -c blah.s 
22:46:40 <sigmatau> gdb blah.o 
22:46:42 * sigmatau shrugs
22:46:47 <sigmatau> i think he knows how a compiler works. 
22:46:50 <sigmatau> or just 
22:46:52 <sigmatau> cat code.s 
22:46:58 <sigmatau> im sure he knows how to do that as well 
22:47:47 <sigmatau> objdump -d blah.o !??!?!?!
22:47:54 <sigmatau> lol
22:48:09 <int-e> why don't you  cat prog.s
22:48:31 <int-e> Anyway, this is pretty far removed from Haskell.
22:48:34 <sigmatau> To demonstrate there's multiple ways to see what's going on. 
22:48:39 <sigmatau> And its not. 
22:48:57 <sigmatau> it's a far easier way to understand what an optimization is. 
22:49:04 <sigmatau> Or what the hell do I know. 
22:49:11 * sigmatau shrugs
23:05:19 <int-e> . o O ( unsafeOpenSurprise )
23:08:59 <dminuoso> Nevoic: And then there's the business of unsafePerformIO of having the following guarantee: It will be executed 0 times, 1 time, or many - possibly infinite - times. All depending on how GHC transforms your code, which could be affected by remote code changes, say because a thing gets small enough to be inlined..
23:09:48 <Nevoic> Why do they have it so easily accessible? Seems like it should take at least a language extension to use if it's literally this prone to so many issues.
23:09:58 <dminuoso> Nevoic: It does say *unsafe*, does it not?
23:10:10 <Nevoic> It does.
23:11:04 <Nevoic> I don't see how that answers my point, but aight.
23:13:09 <Axman6> i mean, it's not as unsafe as accursedUnutterablePerformIO but it is, like, right there in the name, and the docs, and it's also not part of the language IIRC, it's part of GHC
23:14:01 <dminuoso> Nevoic: You also have to import System.IO.Unsafe, so it's not directly accessible unless you a) disregard the word "Unsafe" in that module name, b) disregard the documentation of the module, c) disregard the documentation of unsafePerformIO and d) disregard the unsafe prefix in the identifier name. 
23:15:01 <Nevoic> Alright.
23:15:37 <Axman6> it's like saying why is rust's unsafe so easy to use
23:16:18 <dminuoso> Honestly Ive used unsafePerformIO a few times, and I think so far I've been punished every time by making wrong assumptions about GHC.
23:16:48 <dminuoso> Despite all the warnings.
23:17:41 <ski> (perhaps Nevoic expected a full incantation like "Y'AI 'NG'NGAH YOG-SOTHOTH [part elided for sanity] UAAAH", to be able to use it)
23:18:24 <Nevoic> Or, like I suggested, enable a language extension. I feel like that's a bit of a straw man you're propping up ski.
23:18:52 <dminuoso> My attitude was "Im smart enough, I know better than GHC". Was proven wrong every time.
23:19:40 <ski> Nevoic : yea, i think i'd like it better if it was a pragma or a new language construct (like in Mercury), rather than something that looks like a function
23:21:07 <ski> (in Mercury, it's `promise_pure', iirc. i like the "promise" marker better than the, imho, vague, "unsafe")
23:23:40 <MarcelineVQ> believe_me
23:26:54 <dminuoso> ski: Im not convinced of that. If "import System.IO.Unsafe (unsafePerformIO)" does not get your attention, then a pragma wont either.
23:27:25 <dminuoso> ski: I think Haskell beginners might be just as eager to flip on an extension to do something as they'd be ready to import some unknown module without consulting its documentation.
23:27:46 <ski> no, i mean that `unsafePerformIO' seems vague to me. unsafe in what way, exactly ?
23:28:12 <ski> (of course i agree with what you just said)
23:28:13 <Axman6> "Unsafe in which way?" "Yes"
23:28:21 <monochrom> haha
23:28:26 <dminuoso> ski: But that's just a matter of documentation. I mean what does "mappend" do exactly? What does it append?
23:29:46 <monochrom> People refuse to read the doc.
23:30:58 <Axman6> m's
23:31:02 <Axman6> it's in the type
23:31:08 <Axman6> m -> m -> m
23:31:12 <monochrom> And when finally forced to read the doc, they refuse to read the sentence that applies to them.
23:31:51 <ski> dminuoso : sure, `mappend' isn't the greatest of names, either
23:31:56 <monochrom> Their brain somehow has a way to read the n-1 sentences irrelevant to their use case and turn a blind eye on the 1 sentence they need.
23:32:10 <Nevoic> `mappend` doesn't read as `m append` to me off the top.
23:32:19 <Nevoic> I read it as `map p end`
23:32:21 <monochrom> I know because my students consistently exhibit this behaviour right in front of me.
23:32:46 <Nevoic> idk why they didn't just call it `mAppend`
23:32:55 <Axman6> monochrom: I'm definitely guilty of this
23:32:55 <Nevoic> Would clear all ambiguity.
23:33:00 * ski imagines monochrom's students does that for assignment descriptions, as well
23:33:09 <Axman6> m'append
23:33:11 <monochrom> Yes.
23:33:20 * Axman6 tips fedora
23:33:26 <Nevoic> Axman6 yeah I mean whatever works. Definitely not `mappend` though lol
23:33:31 <monochrom> Both assignment handout and man pages (the course is on C and Unix syscalls)
23:34:07 <Axman6> mappend is pronounced (<>) anyway
23:34:40 <EvanR> mempty dempty sat on a wall
23:34:43 <dminuoso> Axman6: My point is that the identifier doesn't really tell you what's going on with most bindings.
23:35:07 <monochrom> haha EvanR
23:35:15 <dminuoso> Haha
23:35:56 <monochrom> But do you understand how annoying camel case is to type?
23:36:40 <Axman6> and (<>) is pronounced "The binary associative semigroup operation"
23:37:17 <MarcelineVQ> it's pronounced wakka-wakka
23:37:20 <monochrom> If you're annoyed by being required to press ctrl or alt 5% of the time, you should be more annoyed by begin required to press shift 20% of the time.
23:37:32 <Axman6> monochrom: I see you've done dibblego's Data61 course
23:37:47 <monochrom> Err no, what's that?!
23:37:49 <dibblego> sup
23:37:54 <ski> @where Data61
23:37:54 <lambdabot> Data61 Functional Programming Course <https://github.com/data61/fp-course>,<https://qfpl.io/links/2017-october-fp-course/> by Tony Morris,Mark Hibberd. Also see the channel #qfpl
23:38:24 <monochrom> Ah that one
23:39:32 <Axman6> uh, I meant MarcelineVQ
23:39:46 <monochrom> Oh haha
23:40:05 <monochrom> And functor is a fruit or something.
23:40:11 <dminuoso> monochrom: Perhaps the authors shift key was broken when mappend was added.
23:40:14 <dibblego> in the old days yeah
23:40:22 <Axman6> that was the 20 intermediate haskell exercises
23:41:36 <monochrom> time flies like an arrow, fruit flies like a functor
23:41:50 <MarcelineVQ> Axman6: I did that one, It was super hard at the time :O probably still is
23:42:21 <dibblego> MarcelineVQ: come to Melbourne in September
23:42:45 <dibblego> https://groups.google.com/forum/#!topic/nicta-fp/HpMyVakkaBY
23:42:56 <monochrom> Is there a sequel called Control61 that has you reinvent lens? >:)
23:43:05 <dibblego> yes
23:43:05 <MarcelineVQ> That's not the most likely thing to happen but the world is a strange place so who knows :>
23:43:10 <dibblego> http://github.com/data61/lets-lens
23:43:12 <monochrom> Oh noes.
23:43:21 * Axman6 will be coming to melbourne in September
23:43:29 <MarcelineVQ> monochrom: there is a lens one ;>
23:43:38 <monochrom> Actually I should do the lens one.
23:44:14 <Axman6> it's a good course
