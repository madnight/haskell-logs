00:00:08 <jusss> runWriter :: Writer w a -> (a, w),  this (a,w) is a value
00:00:09 <cocreature> that‚Äôs one of the few cases where ghc environment files do come in handy.
00:00:20 <jusss> why it shows up in type signature?
00:00:44 <jusss> newtype
00:09:43 * hackage generic-constraints 1.1.1.1 - Constraints via Generic  https://hackage.haskell.org/package/generic-constraints-1.1.1.1 (YairChuchem)
00:14:31 <ski> jusss : that `(a,w)' is a type
00:15:22 <jusss> ski: then what its value looks like?
00:22:30 <ski> jusss : well, e.g. `(x,l)', if `x :: a' and `l :: w'
00:22:56 <ski> (and yes, i think it was a mistake to use the same syntax for tuples, as for tuple types (the types of types))
00:23:30 <jusss> ski: it's not called unit?
00:23:36 <jusss> the unit type?
00:23:46 <jusss> :t ()
00:23:48 <lambdabot> ()
00:24:01 <Axman6> unit could be called the zero-tuple
00:24:22 <ski> the value, that is
00:24:57 <ski> i call the type "unit" or "the unit type" or "the empty tuple type", usually
00:25:09 <ski> (and the value, "the empty tuple")
00:26:12 <ski> in the MLs, you have `(2,"true",false) : int * string * bool' and `() : unit'
00:26:58 <EvanR> *bold 1*
00:27:59 <ski>   ùüô
00:29:27 <Ariakenom> ski: is the ML type x * y * z special syntax or some inductive tuple?
00:30:17 <tdammers> cocreature: oof. I don't think I'm willing to invest this much time right now, I think I'll just run the tests in a hand-written inotify loop for now
00:30:58 <Athas> Ariakenom: it's just (x,y,z).
00:31:20 <Athas> ML has odd syntax, including postfix application of type constructors.
00:32:09 <EvanR> i know x * y * z is effectively (x,y,z), but that doesn't tell me whether (x * y) * z means the same thing or different thing as x * (y * z)
00:32:19 <Ariakenom> Athas: so (x * y) * z  /=  x * (y * z)  /=  x * y * z ?
00:32:42 <Athas> Right.
00:32:45 <Ariakenom> (I meant to say they're all different)
00:32:57 <EvanR> wacky
00:33:05 <Athas> It's still magical syntax, even though it looks like repeated application of an infix operator.
00:33:54 <Athas> Haskell did this one better.
00:34:04 <Athas> (As with most things syntax.)
00:34:45 * EvanR doesn't mention record field syntax
00:35:12 <Athas> Everybody lost that battle, except OCaml.
00:35:15 <no-n> what are sum and product types
00:35:47 <Athas> no-n: that depends on your level of pedantry.  For practical Haskell purposes, product types are tuples, and sum types are multi-constructor types defined with 'data'.
00:36:02 <no-n> ahh
00:36:22 <EvanR> products = records. sums = variants
00:36:48 <cocreature> tdammers: ime, it‚Äôs often not as bad as it seems. The .ghci file often ends up being something like ":set -isrc; :set -itest; :l test/Main.hs"
00:37:31 <maralorn> :t fmap (const ())
00:37:32 <lambdabot> Functor f => f b -> f ()
00:37:42 <maralorn> :t void
00:37:44 <lambdabot> Functor f => f a -> f ()
00:48:46 <jusss> :t fmap (()->Int) (Maybe ())
00:48:48 <lambdabot> error:
00:48:48 <lambdabot>     Pattern syntax in expression context: () -> Int
00:50:42 <jusss> :t (Maybe ())
00:50:43 <lambdabot> error:
00:50:44 <lambdabot>     ‚Ä¢ Data constructor not in scope: Maybe :: () -> t
00:50:44 <lambdabot>     ‚Ä¢ Perhaps you meant variable ‚Äòmaybe‚Äô (imported from Data.Maybe)
00:50:55 <jusss> :t (Just ())
00:50:57 <lambdabot> Maybe ()
00:55:04 <jusss> :k (Maybe())
00:55:06 <lambdabot> *
00:55:46 <maralorn> Is there a dedicated reflex channel?
01:07:05 <Axman6> jackdk: Do you know about ^
01:26:02 <Ariakenom> maralorn: #reflex-frp
01:32:45 <ski> Ariakenom : not inductive, no
01:33:15 <Ariakenom> ski: yeah Athas explained
01:33:38 <ski> tuples are records, in ML
01:36:42 * hackage hw-hspec-hedgehog 0.1.0.8 - Interoperability between hspec and hedgehog  https://hackage.haskell.org/package/hw-hspec-hedgehog-0.1.0.8 (haskellworks)
01:39:12 * hackage tasty-expected-failure 0.11.1.2 - Mark tasty tests as failure expected  https://hackage.haskell.org/package/tasty-expected-failure-0.11.1.2 (JoachimBreitner)
01:42:42 * hackage RNAlien 1.7.0 - Unsupervized construction of RNA family models  https://hackage.haskell.org/package/RNAlien-1.7.0 (FlorianEggenhofer)
02:11:37 <boxscape> nshepperd remember when you talked about having an extension that would allow you prevent users from using TypeApplication on your functions? There's an accepted proposal for something similar https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0099-explicit-specificity.rst
02:45:09 <asheshambasta> being relatively new to haskell, I feel a little tricked by the orphan instance warnings on enabling -wall 
02:45:46 <asheshambasta> especially for my older projects when I was quite inexperienced with Haskell and its ecosystem. 
02:46:08 <maerwald> what's the point of typeclasses, if you can't write orphans :)
02:46:58 <asheshambasta> there are legit arguments why orphan instances can lead to pitfalls
02:47:57 <maerwald> I'm tired of forking projects for a few instances more :P
02:48:34 <asheshambasta> but yes, enabling -wall somewhere *during* the development of a large project can really feel like all hell breaking loose 
02:49:19 <asheshambasta> for now I will resort to -fno-warn-orphans in conjunction with -wall 
02:50:23 <maerwald> I don't know why those are warnings at all. You don't accidentially write an orphan instance really. So why would I want a warning
02:50:29 <asheshambasta> maerwald: I reckon wrapping things into newtypes in order to write additional instances is not too bad, but that is a lot of boilerplate. 
02:50:44 <asheshambasta> maerwald: good point 
02:51:34 <asheshambasta> also that you cannot have overlapping instances without being explicit 
02:55:06 <asheshambasta> also, you only have as much time to fork things. In most of my cases, I ended up writing some typeclasses and I wanted to write instances of some types supplied by some external library; in these cases forking is not necessary since its local to your business logic/requirements. 
02:57:37 <phadej> instances can be left behind when moving code, etc. Having a legit warning is 0-cost. Orphans are often a smell of bad module hierarchy design. Also for public libraries (as uploaded to Hackage) "hidden" orphans (which you don't expect to be there) are huge surprise
02:59:17 <asheshambasta> phadej: what would the hidden orphans be? Moreover, say a library like Aeson provides FromJSON ToJSON instances for common types (Int, Text, String etc.); are those considered orphans as well? 
02:59:36 <phadej> they aren't orphans, as aeson defines FromJSON type-classes
02:59:58 <phadej> instances are non-orphan if they are defined in either a module which defines a data type OR a type-class
03:00:59 <asheshambasta> phadej: hm, makes sense. 
03:01:49 <asheshambasta> however, I'm yet to come across hidden orphans in a lib.
03:03:50 <phadej> I remember two examples right away
03:05:17 <phadej> e.g. https://github.com/alanz/ghc-exactprint/pull/73/files
03:07:03 <phadej> another one is: https://hackage.haskell.org/package/beam-core-0.8.0.0/docs/Database-Beam-Backend-SQL-Row.html#section.orphans
03:07:46 <phadej> it's quite unluckily that someone else would define orphan Generic (a,b,c,d,e,f,g,h) (8-tuple) somewhere; but who knows
03:08:57 <asheshambasta> interesting 
03:16:29 <phadej> point is, both don't need to be there (former is removed in that PR, and latter isn't actually used anywhere if I remember correctly, the test examples need only up to 7-tuples which are in base/GHC.Generics)
03:17:26 <phadej> yet; in few bigger recent work projects (across ~5 years) we had `OurService.Orphans` which are relatively large indeed
03:18:05 <phadej> simply because one combines parts which are across ecosystem
03:20:25 <phadej> though, looking at those, I have no idea why I needed Hashable (Map k v)
03:22:06 <__monty__> maerwald: The warning's useful for orphans in code you didn't write though. And it's a warning, not an error, unless you promote warnings to errors : )
03:33:14 <maerwald> __monty__: I think these days you rarely see code compilation warnings, unless you use --jobs=1
03:33:50 <__monty__> maerwald: Isn't that what you want, to not notice them?
03:53:13 * hackage linnet 0.1.0.2 - Lightweight library for building HTTP API  https://hackage.haskell.org/package/linnet-0.1.0.2 (sergeykolbasov)
03:54:13 * hackage linnet-aeson 0.1.0.2 - Aeson JSON support for Linnet  https://hackage.haskell.org/package/linnet-aeson-0.1.0.2 (sergeykolbasov)
04:19:39 <Athas> Installed GHC 8.8.1, yay!  Now things don't build.
04:19:42 <Athas> Time to go knock on doors.
04:21:58 <Ariakenom> Ghost of Versions Present
04:22:44 <hpc> ghost in the $SHELL
04:27:47 <Athas> This upper bound stuff is really killing me.
05:12:33 <dminuoso> Athas: Yes. Maintaining stable software is really annoying.
05:12:47 <absence> is there a way to get rid of the boilerplate in expressions like "getCompose $ f <$> Compose a <*> Compose b"?
05:13:26 <dminuoso> absence: coerce, I wonder?
05:15:04 <dmwit> Just trading one boilerplate for another.
05:15:20 <dmwit> absence: In that specific case you could inline the instance.
05:15:25 <dmwit> (liftA2 . liftA2) f a b
05:16:01 <dmwit> (Somebody should convince me some day to prefer <$>+<*> over liftA2.)
05:16:40 <boxscape> I like liftA2, I just think it looks a bit ugly with the uppercase letter and the digit
05:16:45 <stilgart> :t (liftA2 . liftA2) f a b
05:16:47 <lambdabot> error:
05:16:47 <lambdabot>     ‚Ä¢ Couldn't match expected type ‚Äòf (f1 ())‚Äô with actual type ‚ÄòExpr‚Äô
05:16:47 <lambdabot>     ‚Ä¢ In the second argument of ‚ÄòliftA2 . liftA2‚Äô, namely ‚Äòa‚Äô
05:16:56 <stilgart> :t \f a b - (liftA2 . liftA2) f a b
05:16:57 <lambdabot> error: parse error on input ‚Äò-‚Äô
05:17:21 <stilgart> :t \f a b -> (liftA2 . liftA2) f a b
05:17:22 <lambdabot> (Applicative f1, Applicative f2) => (a -> b -> c) -> f1 (f2 a) -> f1 (f2 b) -> f1 (f2 c)
05:17:54 <stilgart> :t \f a b -> f <$> a <*> b
05:17:56 <lambdabot> Applicative f => (a1 -> a2 -> b) -> f a1 -> f a2 -> f b
05:17:57 <dminuoso> boxscape: You can write a generic lift that works with any number of arguments..
05:18:21 <boxscape> hm, maybe I'll try doing that
05:18:28 <absence> dmwit: liftA2 is great until you have more than two arguments :) (or three, since there's liftA3)
05:18:29 <stilgart> ok, it's not exactly the same
05:18:36 <dminuoso> boxscape: It's a fun challenge, don't cheat.
05:18:43 <boxscape> ok :)
05:19:03 <dminuoso> boxscape: Ill give you one hint though. You'll need to make use of extensions.
05:19:21 <dmwit> :t \f a b -> getCompose $ f <$> Compose a <*> Compose b -- stilgart, this is what it's exactly the same as
05:19:23 <lambdabot> error:
05:19:23 <lambdabot>     Variable not in scope: getCompose :: f0 b -> t2
05:19:23 <lambdabot> error:
05:19:30 <boxscape> seems like that would almost be equivalent to idiom brackets
05:20:21 <boxscape> as in (lift f a b c ... z) == [| f a b c ... z |]
05:20:30 <dmwit> :t \f a b -> getCompose $ f <$> Compose a <*> Compose b
05:20:32 <lambdabot> forall k1 (f :: k1 -> *) (g :: * -> k1) a1 a2 a3. Applicative (Compose f g) => (a1 -> a2 -> a3) -> f (g a1) -> f (g a2) -> f (g a3)
05:21:15 <dminuoso> boxscape: Well TH and QQ are not an option for obvious reasons.
05:21:20 <dminuoso> They make for lame solutions.
05:21:22 <dminuoso> :p
05:21:59 <boxscape> dminuoso I wasn't trying to imply TH with my syntax, it's the syntax of Idris's idiom brackets
05:22:08 <dminuoso> Ahh
05:22:30 <absence> dmwit: it's a nice alternative in this case though, thanks!
05:35:12 * hackage fortran-src 0.4.0 - Parser and anlyses for Fortran standards 66, 77, 90 and 95.  https://hackage.haskell.org/package/fortran-src-0.4.0 (mdanish)
05:54:43 * hackage nixfmt 0.3.0 - An opinionated formatter for Nix  https://hackage.haskell.org/package/nixfmt-0.3.0 (LarsJellema)
06:01:26 <spoonm> is there significant additional cost in using something like `r <- return $ f a` instead of just `let r = f a`?
06:03:18 <fendor> spoonm, I would assume that ghc can rewrite it if does make a differnce
06:03:19 <ski> probably not that much, but would depend on the exact implementation of `return' or `(>>=)' i assume
06:04:26 <spoonm> I was hoping it would optimize it away, but I guess it doesn't make that huge a difference in legibility so I won't fiddle with it too much
06:04:29 <ski> it's basically about whether it can simplify `return a >>= k' to `k a' (one of the monadic laws) (by possibly unfolding `return' and `(>>=)' and simplifying), or if not, how big the run-time difference is
06:05:11 <ski> (i'm assuming `r' is simple variable pattern (or an irrefutible pattern at least))
06:05:36 <spoonm> it is, yeah
06:05:36 <dminuoso> Another thing is, if there's a concrete monad or whether its monad polymorphic.
06:05:47 <dminuoso> If its polymorphic over any monad, you might have to pay for it
06:06:42 <dminuoso> Does GHC even assume monad laws to hold?
06:07:11 <ski> i don't think it uses them in rewriting (or other reasoning which it might do, i dunno)
06:07:24 <fendor> i dont think it would be wise to assume the monad laws
06:07:52 <dminuoso> It's so amusing. We call them laws, document them anywhere, but claim that it's not wise to assume they hold?
06:08:10 <dminuoso> What's the point of these laws if we cant assume that they are respected? :p
06:08:44 <ski> (i remember in MetaML (an ML with support for staged / meta- programming) you could turn on an option to make it employ monadic laws to simplify generated code (to make it more readable, mostly, i think ?)
06:10:26 <ski> hm. maybe there are some (more used) instances of `Monad', where the laws doesn't hold strictly speaking, when taking partiality (bottoms) into account
06:10:53 <ski> (hm, istr there were some such case with `IO', dunno whether it's changed)
06:11:07 <dminuoso> ski: Can you explain?
06:11:21 <boxscape> Hmm, maybe once we have dependent haskell the compiler could optimize code with polymorphic verified Monads better than polymorphic non-verified ones?
06:11:52 <ski> > let !_ = return =<< (undefined :: IO ()) in ()
06:11:54 <ski> > let !_ = undefined :: IO () in ()
06:11:55 <lambdabot>  ()
06:11:57 <lambdabot>  *Exception: Prelude.undefined
06:12:21 <ski> i think it was that
06:12:48 <dminuoso> ski: Is that even specific to IO at all?
06:13:06 <dminuoso> > let !_ = return =<< (undefined :: Maybe ()) in ()
06:13:08 <lambdabot>  *Exception: Prelude.undefined
06:13:11 <dminuoso> Oh?
06:13:30 <dminuoso> What's going on here
06:14:44 <int-e> > let !_ = return =<< (undefined :: State () ()) in ()
06:14:46 <lambdabot>  ()
06:15:17 <int-e> This happens if >>= builds a function.
06:15:40 <dminuoso> int-e: Ahh because it provides an additional layer for WHNF?
06:15:41 * ski nods
06:15:51 <dminuoso> Mmm
06:16:01 <dminuoso> I suppose it's the same thing in IO
06:16:16 <dminuoso> Give that it's similar to State, internally
06:18:13 * hackage reanimate-svg 0.9.0.1 - SVG file loader and serializer  https://hackage.haskell.org/package/reanimate-svg-0.9.0.1 (DavidHimmelstrup)
06:24:12 <dminuoso> ski: Then here's an honest question: Why do we actually care about monad laws?
06:24:59 <dminuoso> I mean let's take the case of the naive ListT implementation. Why does it matter whether it's associative or not, as long as we understand that its not? What's the point of rigorously testing these monad laws, when even things like State or IO only satisfy them up to strictness.
06:26:49 <int-e> dminuoso: I don't think we care much about bottom monad actions. We care about associativity when splitting a do block into several when refactoring.
06:27:35 <ski> yes, refactoring i think is probably the most important
06:27:55 <ski> (and, other reasoning, like proving properties about code)
06:28:09 <int-e> We may be happy with a "moral" version of the monad laws... for ListT, as long as the set of results is the same, we're probably fine most of the time.
06:28:19 <dminuoso> But that would imply its only associativity that we care about, not identity.
06:28:42 * hackage tuples 0.1.0.0 - Small monomorphic tuples  https://hackage.haskell.org/package/tuples-0.1.0.0 (andrewthad)
06:29:01 <dminuoso> (In CT are there semigroupoidial categories?)
06:29:27 <int-e> (ListT is worrying because IIRC the multiplicity of answers can change, not just their order. So performance of the code can change when associativity is involved in refactoring. Do I misremember?)
06:29:47 <dminuoso> ski: But if refactoring based on the identity law changes the semantics wrt to strictness, then such code transformations do change the meaning.
06:30:37 <ski> in Prolog, `foo,( bar ; baz )' gives the same solutions (under some purity assumptions) as `( foo,bar ; foo,baz )' (distributive law, "and" over "or"), but the latter can give solutions in a different order (and, this can be detected programmatically, with some operations. like collecting a list of all solutions to a goal)
06:31:36 <ski> in Mercury, the corresponding operation to collect all solutions return a *set* of solutions (which internally may be represented by a list or balanced tree or something)
06:32:22 <ski> so, the implementation is the same, basically, but the types prevent us from observing the order
06:32:28 <dminuoso> ski: I suppose part of the problem in Haskell, wrt to List, is that List doesn't actually models raw non-determinism, because [] has additional structure: ordering
06:32:55 <dminuoso> And in some sense, if we just care about the non-determinism part, non-associativity of ListT can be perfectly fine, because it'd still be associative up to... something.
06:33:16 <ski> it is possible to get a list (not just sorted) from the set, but that's a nondeterministic operation which can in principle return any ordering of the list. in practice, it will probably give the internal order (unless SSC)
06:33:26 <dminuoso> Right
06:33:33 <dminuoso> (SSC?)
06:33:44 <hyperisco> Not having ordering is rather problematic if you are dealing with infinite lists, or sets
06:33:45 <ski> (Sufficiently Smart Compiler)
06:34:09 <dminuoso> hyperisco: Sure that's fine. My point is just that Monad [] models more than just non-determinism.
06:34:29 <ski> and then you can use a `promise_equivalent_solutions' pragma, wrapping a computation involving that list, to promise to the compiler that by the time it finished that computation, the answer will be the same, regardless of which list representation of the set was nondeterministically chosen
06:35:00 <dminuoso> hyperisco: (And the naive implementation of ListT pretends that it models *just* non-determism, and that lists dont have additional structure)
06:35:09 <ski> (that pragma gets rid of the (committed-choice) nondeterminism, which otherwise would taint and spread, like `IO' in Haskell)
06:35:29 <boxscape> Hmm is there any way I can write a constraint that tells ghc that a type must not be a function type?
06:35:41 <boxscape> (I'm guessing no?)
06:35:52 <hyperisco> boxscape, yes
06:35:56 <boxscape> how
06:36:23 <hyperisco> I know how to implement it but I don't recall the libraries that already have these definitions built up
06:36:47 <hyperisco> Basically, you'll have something like  (a == b -> c) ~ False
06:36:50 <boxscape> I see
06:37:24 <fizbin> Anyone feel really good about their abilities to refactor Haskell? I'm trying to apply a technique I only remember vaguely from reading blog posts about free monads ages ago, and I'm getting stuck. Specifically, getting stuck by the fact that type aliases can't be recursive.
06:37:46 <hyperisco> It is in base now, apparently https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Type-Equality.html#t:-61--61-
06:38:07 <ski> (the) Mercury (compiler) doesn't give guarantees on the nondeterminism ordering (well, you can compile in a grade where it does, if you want that)
06:38:51 <hyperisco> fizbin, then you use Mu or define your own data type or newtype
06:39:27 <fizbin> Basically, I have a type that's recursive and already heavily used across hundreds of lines of code. For simplicity, let's say it's 'data MyTree a = TwoNode (MyTree a) (MyTree a) | NNode [MyTree a] | Leaf (Maybe a)' .
06:39:42 <boxscape> hyperisco, I see , thanks
06:39:58 <ski> you can write effectively a `while' loop on the solutions of a goal, but you're not supposed to depend on the order there (you get nondeterminism which you can promise away as above. and "if you like to the implementation, the implementation will get its revenge")
06:40:14 <hyperisco> Alright, well, off the bat, hundreds of lines is small. Maybe just make the change if it'd be more convenient in the end.
06:40:16 <dminuoso> boxscape: Proof of non-equality a a difficult subject in Haskell.
06:40:47 <fizbin> Now, I want to turn this into something like 'data MyTreeF inner a = TwoNode (MyTreeF inner a) (MyTreeF inner a) | NNode [MyTreeF inner a] | Leaf (Maybe a)'
06:41:16 <fizbin> And then define 'MyTree' as something so that I don't need to redo all my existing code that uses MyTree.
06:41:21 <boxscape> dminuoso btw I'm thinking about this because I'm trying to sole the challenge you posed me but I'm probably overcomplicating things
06:41:41 <boxscape> (I feel like this would be a lot easier if I could pattern match on types)
06:41:45 <fizbin> See, if I could just do 'type MyTree = MyTreeF MyTree' , that'd be ideal.
06:41:49 <fizbin> But I can't.
06:42:10 <dminuoso> boxscape: Well the solutions Ive seen so far are not trivial.
06:42:13 <hyperisco> If the goal is to bend backwards to save a few hundred lines of code my recommendation is to not bother :P
06:42:17 <boxscape> ok, good to know
06:42:21 <dminuoso> boxscape: Pattern matching on types works in Haskell!
06:42:39 <fizbin> hyperisco: Well, why on earth do I have to bend over backwards to do this?
06:42:43 <dminuoso> boxscape: Both tyfams and tyclasses give you sort of pattern matching semantics.
06:42:50 <dminuoso> boxscape: And fundeps.
06:42:53 <boxscape> Yeah that's sort of the direction I'm going in
06:43:03 <typetetris_> How can I determine which options have been set for a program with `-with-rtsopts` at link time, given the executable? (I tried to find an rts option for that, but couldn't find one. +RTS --info didn't print anything related, as far as I can tell.)
06:43:09 <ski> see unsorted_solutions/2,unsorted_aggregate/4,do_while/4 at <https://www.mercurylang.org/information/doc-latest/mercury_library/solutions.html>
06:43:18 <fizbin> That's what I want to know. It seems like it should be a straightforward refactoring.
06:43:40 <hyperisco> fizbin, you already answered why. Because aliases cannot be recursive.
06:44:00 <hyperisco> It is straight-forward but you will have to make modifications.
06:44:30 <ski> otoh, in Prolog, ordering of solutions is most definitely a part of the behaviour of the language that you're supposed to be able to depend on. so an implementation can do as much highlevel transformations of code, like aforementioned distributive law, unless it can prove the solutions will be in the same order (e.g. if `foo' has at most one solution)
06:45:03 <fizbin> Okay, but I feel like there must be something I'm missing. Because right now, it seems like a huge amount of work to make this change. Are there best practices for how to do this that make this kind of refactoring easier?
06:45:28 <hyperisco> Patience and practice :)
06:45:44 <hyperisco> Or is that "practise"?
06:46:17 <dminuoso> boxscape: By the way, consider why type inequality proofs are somewhat tough. 
06:46:50 <fizbin> Yeah, I'll apply the patience, but avoiding practice is what communication is for. If I can absorb someone else's tale of dead ends that didn't work out and avoid those, I'd rather do that.
06:47:03 <hyperisco> Okay: free monads are a waste of time.
06:47:43 <boxscape> dminuoso well... You can build equality proofs out of transformations to a form that's syntactically the same, but for inequality you'd have to prove that no such transformation exists?
06:48:32 <boxscape> I'm not sure if that's really applicable to haskell in the form I phrased it
06:48:43 * hackage grid 7.8.14 - Tools for working with regular grids (graphs, lattices).  https://hackage.haskell.org/package/grid-7.8.14 (AmyDeBuitleir)
06:48:44 <fizbin> Okay, what then is the accepted solution for the problem "I've got a recursive data structure with several different constructors and I want to take this data structure and annotate each piece of it with another piece of data"?
06:49:10 <dminuoso> boxscape: Well someone has to construct proof for what you are asking for.
06:49:18 <hyperisco> There are specific situations in which it is convenient to put some functors together into a free monad, but the extreme of doing everything with free monads is a waste of time, is my finding.
06:49:38 <hyperisco> fizbin, "trees that grow"
06:50:42 * hackage gray-extended 1.5.8 - Gray encoding schemes  https://hackage.haskell.org/package/gray-extended-1.5.8 (AmyDeBuitleir)
06:51:04 <boxscape> dminuoso I'm not sure whether to take that as agreement, disagreement, or something inbetween
06:52:17 <AviD> Are there any recomened talks that explain how to use trees that grow?
06:52:58 <hyperisco> There's a paper but I haven't watched any talks on it myself
06:55:32 <boxscape> dminuoso Usually I would expect a proof of inequality to look something like ((a ~ b) => Void) but I'm not sure I've ever seen anyone use something like this in haskell
06:56:25 <fizbin> hyperisco: Ah, that's more like it, and the piece I was missing (well, one of them) was pattern synonyms.
06:59:49 <fizbin> Unfortunately, pattern synonyms don't actually seem to exist yet in ghc.
06:59:52 <dminuoso> boxscape: https://mail.haskell.org/pipermail/haskell-prime/2006-March/000936.html 
07:01:48 <fizbin> Or maybe they do. I wish that the ghc wiki were more explicit about what's actually implemented (and in what version), and what is only a proposal.
07:03:09 <boxscape> dminuoso: interesting, thank you
07:03:38 <boxscape> Thinking about this just let me figure out that TypeApplication also works for constraints, so that's good to know
07:03:52 <boxscape> (seems like that would interact really nicely with named instances, actually)
07:04:04 <boxscape> (maybe)
07:04:54 <dminuoso> boxscape: It doesnt work 
07:04:58 <dminuoso> "for constraints"
07:05:08 <boxscape> % :t ((undefined :: forall k. k => Int) @(Functor Maybe))
07:05:09 <yahb> boxscape: ; <interactive>:1:16: error:; * Could not deduce: k0; from the context: k; bound by an expression type signature:; forall (k :: Constraint). k => Int; at <interactive>:1:16-33; * In the ambiguity check for an expression type signature; To defer the ambiguity check to use sites, enable AllowAmbiguousTypes; In an expression type signature: forall k
07:05:21 <dminuoso> boxscape: It rather works on the type variables from the universal quantification.
07:05:47 <boxscape> Yes, but I mean it works for type variables whose kind is Constraint
07:06:42 <dminuoso> % :t Dict
07:06:42 <yahb> dminuoso: a => Dict a
07:07:02 <dminuoso> boxscape: I suppose that's one of the few places you could sensibly use it in. :P
07:07:47 <dminuoso> % d = Dict @(Funtor Maybe)
07:07:47 <yahb> dminuoso: ; <interactive>:3:12: error:; Not in scope: type constructor or class `Funtor'; Perhaps you meant one of these: `Functor' (imported from Prelude), `FunPtr' (imported from GHC.Exts)
07:07:51 <dminuoso> % d = Dict @(Functor Maybe)
07:07:52 <yahb> dminuoso: 
07:08:52 <boxscape> hm, I haven't actually seen Dict before
07:09:16 <dminuoso> boxscape: https://hackage.haskell.org/package/constraints-0.11.1
07:09:21 <dminuoso> Its a pretty fancy library :)
07:09:24 <boxscape> thanks
07:20:12 * hackage tidal-vis 1.0.15 - Visual rendering for Tidal patterns and osc messages  https://hackage.haskell.org/package/tidal-vis-1.0.15 (AlexMcLean)
07:34:16 <tabaqui> Dict is just a Proxy but for constraints
07:34:42 <tabaqui> and this approach is really weird
07:34:49 <Cale> kind of... except that its runtime representation actually carries a dictionary
07:35:10 <tabaqui> yeah, you deliver constraints as types
07:35:24 <tabaqui> and this works somehow
07:35:32 <tabaqui> s/this/it
07:39:55 <boxscape> sounds roughly like what would've happened if way back when people had decided to use explicit records instead of type classes
07:41:03 <dminuoso> boxscape: The difference is this plays nicely with the type system
07:41:15 <boxscape> okay
07:41:23 <dminuoso> boxscape: http://hackage.haskell.org/package/constraints-extras takes constraints to an entirely new level
07:41:27 <dminuoso> Enabling you to do Pi level constraints
07:41:51 <boxscape> sounds neat
07:41:52 <Cale> I wonder whether I should make Has the type class there
07:42:11 <dminuoso> Or rather I should say "constraint-level Pi", that makes more sense :)
07:42:14 <Cale> It's what we always end up using anyway
07:42:24 <Cale> yeah
07:42:25 <boxscape> it does
07:43:14 <Cale> It basically gives you a way of saying "given a value k of type k a, I will discharge a constraint of type c (f a)"
07:44:42 <Cale> (and then you pick the type k to be some GADT)
07:45:14 <boxscape> There isn't a way to have something like `or` for constraints, right? Say, for a functions (a ~ b || a ~ c) => (c, b) -> a or something along those lines
07:45:27 <tabaqui> uhm, I always thought, that right side of data declaration may contain only completed types
07:45:41 <tabaqui> but in constraints-extras there is an example
07:45:56 <tabaqui> data V :: (* -> *) -> * where V_a :: A Int -> V A
07:46:10 <dminuoso> boxscape: https://www.reddit.com/r/haskell/comments/6k86je/constraint_unions_bringing_or_to_the_language_of/
07:46:13 <tabaqui> ah, fine
07:46:17 <tabaqui> no problems
07:46:24 <boxscape> dminuoso oh, nice, thank you
07:47:18 <boxscape> I actually just tried writing a kind polymorphic either but got stuck on ghc complaining that it's supposed to produce something of kind Type
07:51:28 <dminuoso> boxscape: Well it has to be inhabitatable at least, and that means kind *.
07:51:36 <boxscape> Ah, that makes sense
07:53:03 <boxscape> hmm, even with -XNoStarIsType ghc still complains about a "non-* return kind"
07:53:08 <boxscape> that seems like an oversight
07:53:14 <boxscape> maybe it's fixed in 8.8
07:53:38 <boxscape> wait
07:54:05 <boxscape> yeah no I stand by it
07:54:25 <boxscape> (I didn't have it enabled in ghci before but it doesn't make a difference)
07:54:41 <dminuoso> boxscape: Yeah that's probably just an oversight.
07:56:45 <dminuoso> boxscape: constraints basically is a trick to extend that rule, such that you cant just have values of some *-kinded type in there, but so you can also have constraint-kinded types as first-class values in your data constructor.
07:57:41 <dminuoso> So its reified constraints, and it works in such a pleasant way, that you can pass it around and open it, such that its constraint can be used to discharge proof obligations.
07:57:59 <boxscape> "constraints" as in the constraints package?
07:58:03 <dminuoso> Yes.
07:58:08 <boxscape> I see
07:58:10 <dminuoso> So if you hold some `Dict C` in your hand, and you have something `C => T`, then you can use your dict to get to that T.
07:58:20 <dminuoso> If you squint a bit, => starts to look like a function. ;)
07:59:19 <boxscape> well, if you look at goldfirere's proposed quantifiers it makes it look like the only difference between -> and => is that one is visible and the other isn't
07:59:25 <boxscape> or wait
07:59:45 <boxscape> you said "looks like a function", not "looks like ->"
08:00:02 <dminuoso> (\\) :: a => (b => r) -> (a :- b) -> r
08:00:17 <dminuoso> This captures what constraints is about nicely.
08:00:33 <dminuoso> (Do take note of the position of the parens there)
08:01:11 <dminuoso> "If we have some `r` that demands proof of `b`, and we have proof that `a entails b`, then if we have proof of `a` we can obtain `r`
08:01:23 <boxscape> that sounds reasonable
08:02:39 <dminuoso> withDict :: HasDict c e => e -> (c => r) -> r 
08:03:35 <dminuoso> class HasDict c e | e -> c where evidence :: e -> Dict c 
08:03:51 <dminuoso> That's what I talked about before
08:04:09 <boxscape> yeah, I can see the connection
08:07:12 * hackage list-transformer 1.0.5 - List monad transformer  https://hackage.haskell.org/package/list-transformer-1.0.5 (GabrielGonzalez)
08:09:12 * hackage camfort 1.0 - CamFort - Cambridge Fortran infrastructure  https://hackage.haskell.org/package/camfort-1.0 (mdanish)
08:15:03 <shapr> jle`: excellent suggestion, anyone else I should meet?
08:15:15 <shapr> dmj`: was nice to meet you, let's hang out more!
08:16:04 <dmj`> shapr: likewise ! good times :) 
08:17:12 * hackage PyF 0.8.0.2 - Quasiquotations for a python like interpolated string formater  https://hackage.haskell.org/package/PyF-0.8.0.2 (guibou)
08:17:57 <dmj`> shapr: for sure
08:20:55 <dmwit> dminuoso: Oh my. "type p? a = MaybeC (p a)" made me throw up in my mouth a little, thanks.
08:22:00 <pigmej> Hey folks, I'm kinda new to Haskell world (not that much n00b though to FP), I have one question that kinda bothers me and I can't wrap my head around it.
08:22:20 <t7> has anyone ever done some await like tranform in haskell?:    foo (await (bar baz)) 123    =>    bar baz >>= \x -> return (foo x 123)
08:22:42 <t7> or maybe without the return 
08:22:48 <pigmej> I want to use req library (works fine), but I have one fundamental problem, parseUrlHttps is `parseUrlHttps :: C.ByteString -> Maybe (Url 'Https, Option scheme)`
08:22:54 <dmwit> t7: Maybe you want the async package?
08:23:16 <t7> i figured it would be a macro 
08:23:20 <dmwit> t7: Or possibly https://hackage.haskell.org/package/io-memoize
08:23:22 <pigmej> and I really have no idea how can I use in `req`.
08:23:48 <pigmej> so basically my question is, how the heck design function / flow that is aware of Maybe (It seems that I'm struggling with some control flow...)
08:24:37 <dmwit> pigmej: The most basic, beginner-friendly way is to simply pattern match on the Maybe.
08:24:49 <pigmej> yeah but ... it makes the stuff super ugly
08:25:25 <dmwit> Slightly better is to use the Monad or Traversable instances for Maybe.
08:25:36 <pigmej> let me try to show
08:25:39 <dmwit> But it depends a lot on context and what you want to do.
08:25:54 <dmwit> It's hard to say much more than "get familiar with the libraries available for using Maybe".
08:26:02 <pigmej> https://pastebin.com/p4Hrw7tL
08:26:40 <pigmej> `urlBytes` is result of `C.pack url`
08:26:45 <dmwit> But what do you want that to do if the URL is invalid?
08:27:04 <pigmej> so I'm using `fail "Some message"` in other places
08:27:05 <pigmej> like 
08:27:20 <pigmej> https://pastebin.com/gVTBLzt2
08:27:34 <pigmej> but I have a feeling that I'm missing something obvious...
08:28:15 <pigmej> that decode is Aeson thingy if sth.
08:31:59 <pigmej> dmwit any help appreciated (links to RTFM too)
08:35:42 <Chobbes> Does haskell-mode work with cabal v2-build / v2-repl?
08:35:53 <Chobbes> (for C-c C-l to load ghci)
08:40:02 <Geekingfrog> pigmej, this usage of fail will probably bite you later on. Prefer throwing an expection (throwIO in a MonadIO, throwError in a MonadError), or returning something like an Either with the description of what went wrong.
08:40:56 <pigmej> Yeah I had that feeling but my Haskell fu is not yet there ;/ Could you pls share a snippet ? (Btw that fail is in main so it's less problematic I guess)
08:41:05 <jle`> shapr: how about vaibhavsagar ?  but, we are quickly running through my list of NYC haskellers i know heh
08:41:20 <hvr> Chobbes: quick search reveals https://github.com/haskell/haskell-mode/issues/1676
08:41:46 <hvr> Chobbes: not quite what you asked for, but I recall that e.g. https://github.com/jyp/dante works reasonably well with v2-build
08:42:01 <pigmej> I'm using dante and yes it works flawlessly 
08:42:16 <c_wraith> I'm an emacs heretic. I use it as an editor and am happy using a terminal emulator as a terminal
08:42:58 <hvr> c_wraith: so you're not using term-mode ;->
08:43:30 <c_wraith> well, it's one way to guarantee a v2-repl
08:44:39 <hvr> I do so as well often; but the one thing I miss is the jump-to-error and send-region-to-ghci features you'd have with tighter integration (same applies to ghcid)
08:44:59 <Chobbes> hvr: thanks. I was hoping that there was a way to make process-type auto work, but this is helpful too :).
08:45:13 <Geekingfrog> https://0bin.net/paste/+FAcJhVdOgr5b5Ju#heIUVwJriHcwTyiEtHDIDMs97UALk8deURTaowsnMYq > pigmej 
08:45:15 <Geekingfrog> for example
08:45:31 <vaibhavsagar> jle`: shapr and I hang out frequently :)
08:45:40 <hvr> Chobbes: but I suspect this should be easy to fix in haskell-mode
08:45:58 <pigmej> Geekingfrog ok, thx. 
08:46:09 <pigmej> Any help with the second part of my "problem"?
08:46:10 <Chobbes> hvr: I have had bad experiences with dante / intero... In particular intero was downloading a new GHC every time I opened a haskell file and I was sad... Is it... Better now?
08:48:47 <hvr> Chobbes: well, I'm not recommending intero :-)
08:48:57 <hvr> and dante certainly won't auto-download ghc
08:49:10 <Geekingfrog> pigmej, what's the second part? I missed it.
08:49:59 <hvr> (at least as long as Dante doesn't try to use Stack)
08:50:26 <fendor> > sequence [Just 2, Nothing, Just 3]
08:50:28 <lambdabot>  Nothing
08:50:30 <pigmej> Geekingfrog so, I seem to have problems with understanding the proper flow with "Maybes"
08:50:43 <asheshambasta> Chobbes: intero works quite well for me 
08:51:02 <pigmej> https://pastebin.com/uwTNG461 let's say that part of the code
08:51:14 <pigmej> `parseUrlHttps :: C.ByteString -> Maybe (Url 'Https, Option scheme)`
08:51:15 <asheshambasta> last I checked; dante didn't really support goto definition, but I might be mistaken or my opinion outdated 
08:52:08 <fendor> is there something like fold but with an alternative cosntraint? E.g. I want: [Just 3, Nothing, Just 5] == Just 3
08:52:24 <pigmej> and my problem Geekingfrog is that well... I have no idea how to handle Maybe in proper way.
08:53:15 <Geekingfrog> pigmej, what you've been told before, pattern matching on the maybe works fine. If you get a Nothing, you can always throwIO (or use `error ...`, which is unrecoverable), that will abort everything.
08:53:26 <pigmej> ok, so that's the proper way then?
08:53:35 <pigmej> I had a feeling that there is some "more pretty" way
08:53:50 <fendor> > asum  [Just 3, Nothing, Just 5]
08:53:52 <asheshambasta> but however, Intero is a memory hog, and since I'm on nixos I'm going to look into replacing it with nix later 
08:53:53 <lambdabot>  Just 3
08:53:55 <Geekingfrog> pigmej, I'd suggest you do that first. When you start having a bit too many nested `case ... of`, come back to find a solution.
08:54:22 <pigmej> ok, because the code with cases and pattern matching for that startst to be spaghetti ;/ 
08:54:27 <pigmej> spaghetti*
08:54:43 <maerwald> asheshambasta: yeah, because it loads ALL type info afaik, not incrementally, right?
08:54:49 <pigmej> I was trying to do sth with fmap but that was total fail
08:55:20 <asheshambasta> maerwald: yeah, that is what it seems like
08:55:45 <asheshambasta> maerwald: https://github.com/chrisdone/intero/issues/620 
08:56:22 <asheshambasta> maerwald: the performance issues with intero have to do with more than just the memory it seems
08:56:49 <maerwald> https://github.com/chrisdone/intero/issues/566
08:57:06 <maerwald> this happens when I try to use it
08:57:56 <asheshambasta> ouch 
08:58:25 <maerwald> writing memory efficient haskell code isn't that easy :)
08:58:50 <asheshambasta> I'm working on a rather large project with 180-ish modules and intero works ok, I do need to restart it once in a while 
08:59:36 <asheshambasta> I moved to intero after hie, which a year ago, was very hard to set up and used to break intermittently 
08:59:42 <asheshambasta> s/break/crash 
09:00:15 <maerwald> hies scope is too big imo, unlikely it will get stable, too much stuff to work on
09:00:20 <asheshambasta> imho, a more nixish approach is the most efficient/performant way to go 
09:00:32 <asheshambasta> maerwald: I agree 
09:02:29 <asheshambasta> currently what bothers me most about intero, however, is not the mem. footprint (which is worrisome), but the laggy performance within emacs 
09:02:42 <asheshambasta> afaics that profiling report shows 
09:03:10 <hvr> asheshambasta: fwiw, I'd also keep an eye on https://gitlab.com/tseenshe/haskell-tng.el
09:03:28 <asheshambasta> its decent -ish on my TR desktop at home, but on my office laptop its laggy enough to completely break my typing
09:04:51 <asheshambasta> hvr: that looks cool, but I also think its overreaching in the same lines as HIE :-) (just my opinion btw)
09:05:23 <hvr> maybe; but it doesn't as high as HIE :-)
09:05:23 <asheshambasta> replacing 25k LOC with a rewrite is a massive undertaking 
09:05:56 <hvr> its main scope is Emacs; not every editor on earth
09:06:13 <asheshambasta> hvr: also, tbh, I'm happy with a combination of projectile/error&warning highlighting/goto-def
09:06:14 <pigmej> language server protocol is ...... bloated at best :)
09:06:25 <hvr> and it seems to be cabal centric
09:06:34 <hvr> which also reduces the scope
09:06:40 <asheshambasta> pigmej: you can implement a subset of the protocol right? 
09:06:49 <Geekingfrog> https://0bin.net/paste/Om4q-3yG9Cr9w+Br#eyVwN+R8ShPMun64e-XfXoFgCFoieB7YXwwSwbXx1QP > pigmej if you are always in IO, that can be a solution to avoid nesting too many things. It's the equivalent of if err != nil { return err; } in go
09:07:15 <pigmej> ok
09:07:20 <pigmej> Geekingfrog thx
09:07:31 <pigmej> asheshambasta sure.... then you have subset of functionality :)
09:08:04 <hvr> asheshambasta: yeah; I'm just pointing out the tooling I'm currently aware of; I'm currently using a simple haskell-mode based setup with M-x haskell-compile; and with the occasional ghci in a terminal
09:08:05 <asheshambasta> pigmej: which is fine 
09:09:02 <hvr> asheshambasta: partly because I don't have time to figure out a more advanced setup and need something that's rock solid
09:09:26 <hvr> even if it means that I'm losing on some convenience features
09:09:29 <pigmej> Geekingfrog https://pastebin.com/UJ0tfkhQ so... exceptions doesn't work like that :/
09:10:08 <asheshambasta> hvr: tbh, I'm tending towards that as well 
09:10:20 <geekosaur> if you're in pure code, you use Maybe/EIther or you use error. the former strongly recommended
09:10:30 <asheshambasta> I'm not sure anything advanced when it comes to IDE tooling is mature/reliable enough in the Haskell world, sadky. 
09:10:41 <asheshambasta> But that means there's room to improve things.
09:10:48 <Geekingfrog> pigmej, you need to use `pure parsed`. Remember you are in IO, so both branches of the case must return the same thing
09:10:57 <geekosaur> throwIO, as its name says, is for use in IO, and in general exception handling only works well in IO
09:11:20 <geekosaur> (in particular, you must be in IO to catch an exception)
09:11:21 <hvr> asheshambasta: yeah; I'm keeping my eyes open... things might improve; slowly
09:12:15 <asheshambasta> hvr: on emacs, there's also the limitation imposed by emacs itself 
09:14:59 <pigmej> geekosaur I'm in the IO function within do block
09:15:26 <monochrom> Then what's with this "Url 'Https" business?
09:15:47 <geekosaur> then you can
09:16:06 <geekosaur> t just toss back "parsed" like that, because it's not an IO action
09:16:19 <geekosaur> presumably it's what monochrom just asked about
09:21:13 * hackage ft-generator 1.0.1 - implementation accompanying a WFLP'19 paper  https://hackage.haskell.org/package/ft-generator-1.0.1 (JanisVoigtlaender)
09:23:04 <maerwald> hvr: you mean I have to give in and abandon vim? :(
09:24:34 <maerwald> already using vscode for some stuff, but I guess you need an IDE for every language today
09:27:55 <hvr> maerwald: viper-mode *cough* :-)
09:28:15 <hvr> "Viper-mode or just Viper is an Emacs mode that emulates vi key bindings. Besides being the newest variety of vi emulation, it also provides users different levels of emulation to help vi addicts kick the habit."
09:29:05 <shapr> or evil-mode
09:29:53 <maerwald> hvr: my biggest problem is booting up emacs and the buffer mess. I'm used to frequently open and close windows with no shared buffers
09:29:55 <infandum> I have the issue: "Codec.Compression.Zlib: premature end of compressed data stream" when using http://hackage.haskell.org/package/streaming-utils , however "zcat file.tsv.gz" works. What would be the issue here?
09:30:19 <hvr> maerwald: I have emacs-server for that :-)
09:30:32 <AviD> hvr:  out of curiosity why would I want to kick the habbit?
09:30:46 <hvr> AviD: dunno =)
09:31:06 <hvr> AviD: maybe because you can't entertain having both an Emacs and a VIM addiction at the same time?
09:31:29 <shapr> maerwald: yeah, gnuserv can do that
09:31:45 <infandum> NEVERMIND, wrong file being called, silly me
09:32:04 <maerwald> my point is... I do not want to reuse... but opening emacs processes is slow
09:33:13 * hackage language-lua 0.11.0.1 - Lua parser and pretty-printer  https://hackage.haskell.org/package/language-lua-0.11.0.1 (EricMertens)
09:33:32 <maerwald> then again, haskell isn't that bad on vscode and I already use it for typescript
09:35:05 <shapr> maerwald: right, but gnuserv does not open a new emacs process
09:35:40 <shapr> maerwald: instead it leave an emacs process running, and supports the vim command line workflow by opening a new window when you open a file. It's very fast
09:35:54 <shapr> roughly the FastCGI approach where you left the program running and only fed it new inputs :-)
09:36:19 <maerwald> and it does not share buffers?
09:36:56 <shapr> maerwald: I'm not sure what that means
09:38:16 <maerwald> buffers are open files, no?
09:38:36 <maerwald> so if you open a new window with the same emacs process, buffer holds all files of all "windows"
09:39:26 <maerwald> compared to vim, it behaves more like a tab
09:39:42 <davean> Huh?
09:40:09 <davean> "buffer holds all files of all "windows" <-- what?
09:41:09 <shapr> maerwald: if you use emacs with gnuserv, it functions very much like vim in that whatever file you pass an argument gets opened
09:41:16 <Phyx-> lol, I wish irssi's notifications were context sensitive :p
09:41:27 <maerwald> shapr: yes, but buffer is per process I think, not per window
09:41:28 <shapr> maerwald: I don't think previously opened files are closed when you close that window, but that would be easy to change
09:42:22 <davean> maerwald: I'm really unsure whta your concern is
09:42:46 <maerwald> davean: a buffer with stuff overloaded from unrelated windows
09:42:48 <nshepperd> he means that the buffer list in emacs shows all open files from all emacses
09:43:02 <shapr> oh yeah, that's the default behavior with gnuserv
09:43:02 <davean> maerwald: with emacs-server buffers are associated with windows
09:43:08 <shapr> but you could easily change that
09:43:31 <shapr> would be easy enough to hook window close to also close all buffers
09:43:43 <shapr> maerwald: would you like details on how to do that?
09:43:43 <davean> maerwald: so it woudln't be overloaded with ones you closed the display of
09:44:00 <shapr> oh ok then
09:44:45 <maerwald> shapr: you have a link?
09:45:28 <maerwald> ww
09:45:42 <maerwald> so many options
09:48:32 <nshepperd> it would be nice to have something exactly like opening a new emacs, but fast
09:48:46 <shapr> maerwald: meeting, I'll be back in an hour
10:27:31 <texasmynsted> I have a number of things installed (on macos) in ~/Library/Haskell/bin. My cabal is installed in some place the I am unclear how it got there.
10:27:42 <texasmynsted> I want to upgrade with instructions from here https://www.haskell.org/ghcup/
10:28:08 <texasmynsted> Will this break anything?
10:29:12 <texasmynsted> it seems like it might not since there is a .cabal directory with configuration. My guess is that the new location for cabal (cabal-install) will continue to use these configs?
10:32:13 * hackage dzen-dhall 1.0.1 - Configure dzen2 bars in Dhall language  https://hackage.haskell.org/package/dzen-dhall-1.0.1 (klntsky)
10:37:13 * hackage composite-base 0.6.0.0 - Shared utilities for composite-* packages.  https://hackage.haskell.org/package/composite-base-0.6.0.0 (dfithian)
10:38:13 * hackage composite-swagger 0.6.0.0, composite-opaleye 0.6.0.0, composite-ekg 0.6.0.0, composite-aeson-refined 0.6.0.0, composite-aeson 0.6.0.0 (dfithian)
10:51:55 <mycroftiv> is there a system for getting and managing older version dependencies? i constantly get errors about having too recent versions installed relative to package compatibilty
10:53:40 <EvanR> there's cabal sandboxes, stack, nix, ...
10:53:43 <mycroftiv> in fact almost nothing i try to install with cabal succeeds for this reason and i wonder if im doing something wrong or misunderstanding
10:53:54 <EvanR> no you're spot on
10:54:08 <sclv> mycroftiv: it depends what you're trying to do
10:54:12 <sclv> often things really have bitrotted
10:54:16 <sclv> and won't build on newer ghcs
10:54:20 <mycroftiv> just 'cabal install nameofthing'
10:54:21 <sclv> and there's not much to do about it but fix em
10:54:42 <sclv> which thing, which ghc
10:54:54 <sclv> and which version cabal
10:55:34 <sclv> also is this a lib you want to depend on, or an executable
10:55:45 <mycroftiv> so people dont really try to make ghc stay backwards compatible with the existing software universe as an ecosystem goal? im just using whatever debian has installed in debian stretch
10:55:58 <sclv> no we can't keep ghc backwards compatible
10:56:00 <sclv> libs evolve
10:56:09 <mycroftiv> sclv: its generally just whatever random thing looks interesting from scanning hackage package list
10:56:35 <sclv> lots of stuff there is bitrotted
10:56:46 <sclv> you can check the build matrix links from hackage
10:56:53 <sclv> to see what versions it builds with
10:57:02 <sclv> alternately, you may have _too old_ a ghc
10:57:47 <sclv> hrm -- stretch is 8.0.1
10:57:54 <sclv> so that's pretty old, but not insanely so
10:58:29 <sclv> anyway, with a recent enough ghc and cabal, the way to use packages is via the cabal v2-build and v2-install commands
10:58:50 <sclv> on the very latest cabal (3.0, released a few days ago) those are now not named v2- any more, but just "build" and "install"
10:59:10 <sclv> they build each thing without reference to the existing installed package store (but sharing caching)
10:59:27 <sclv> so you don't have a global package database where incompatibilities can be generated spuriously
10:59:29 <mycroftiv> does that mean they retrieve the needed older versions?
10:59:31 <jle`> shapr, vaibhavsagar: i'm out of names :)
10:59:48 <sclv> cabal always retrieves the needed older versions of packages
11:00:05 <mycroftiv> it always says it cant so far as i can tell, like this:
11:00:06 <sclv> the issue is sometimes just that it couldn't keep all the different versions installed at once and put together in a sane way
11:00:14 <mycroftiv> rejecting: base-4.9.0.0/installed-4.9... (conflict: miniforth => base>=4.7 && <4.8)
11:00:18 <sclv> what you can never retrieve an older version of is base
11:00:30 <mycroftiv> thats the conflict i get all the time
11:00:32 <sclv> so yeah -- that says that "miniforth" is constrained to work on an old base
11:00:42 <sclv> i.e. it is not compatible with newer ghcs
11:00:47 <sclv> base ships with ghc and can't be reinstalled
11:01:17 <plasticchicken> why does cabal install require the '--lib' flag now?
11:02:00 <shapr> jle`: are you in NYC?
11:02:16 <sclv> mycroftiv: its easy enough to try to rescue that stuff. just "cabal unpack" it, then fix it up by hand in terms of deps, and perform the typical migrations necessary for base upgrades along the way (https://gitlab.haskell.org/ghc/ghc/wikis/migration#migration-guide)
11:02:29 <jle`> shapr: i'm in LA region
11:02:46 <sclv> plasticchicken: to distinguish between installing exes, which is typically what people want, and just puts the exes in your path
11:03:13 <sclv> and "installing" libs, which builds them into the store, and then adds an entry referencing them to a global ghc environment file
11:03:26 <shapr> jle`: if you come visit NYC before Halloween, let's meet up!
11:03:29 <sclv> which is new behavior with all the new-install commands
11:03:43 <sclv> and very often is not what people were expecting, so now they need to ask for it explicitly
11:04:11 <sclv> i.e. the recommended way to use a lib is not to install it anymore -- its just to build a project that depends on it, or pull up a repl while passing in the dependency on the command line
11:04:17 <jle`> shapr: for sure :) not sure if i have any plans to swing by but you never know
11:04:23 <plasticchicken> sclv: where is this documented? I'm pretending I'm new to Haskell, trying to use a package in my code.
11:04:53 <sclv> https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
11:05:20 <sclv> i see we need to update the docs further since the cabal 3.0 release actually made the new-* commands standard
11:07:04 <mycroftiv> does anyone maintain a compatibility list of haskell software that is 'base standard haskell' like haskell 98 and will remain working ?
11:07:32 <sclv> there's no guarantee that anything will remain working
11:07:39 <sclv> occasionally ghc makes divergences from h98
11:07:54 <sclv> the best thing you can do is just look at the constraints of a package on hackage
11:08:07 <sclv> and see if they allow building with your ghc or not
11:08:15 <sclv> i.e. if the "base" constraint matches
11:14:19 <plasticchicken> sclv: thanks. Can that information be placed on page 1 of the manual instead of section 5.4?
11:19:21 <mycroftiv> sclv: thanks for all the information. im finding it a bit hard to navigate the modern ghc ecosystem in comparison to using hugs and older-ish haskell code from the pre 2010 era
11:37:36 <uberj> https://gist.github.com/uberj/ac7626dbfbd7caa35f1e3869338ba7fb ghci can't find the variable, so it recommends I use that same variable -- what am I doing wrong?
11:38:42 <sclv> uberj: i think one has a capital letter 'o' and the other is a zero
11:39:05 <uberj> ha
11:39:08 <jle`> > filter isDigit "run0"
11:39:09 <uberj> you are right
11:39:11 <lambdabot>  "0"
11:39:13 <jle`> > filter isDigit "runO"
11:39:15 <lambdabot>  ""
11:40:00 <uberj> thanks
11:40:31 <jle`> admittedly my terminal font doesn't distinguish them very well. i should probably switch it
11:40:42 <jle`> the font on the gist makes the distinction very clear
11:47:30 * ski . o O ( isn't it great how `O' and `0' are close to each other on Qwerty ? )
11:47:42 <ski> (you don't have to search for the one, when looking for the other)
11:48:33 <int-e> . o 0 ( ... )
11:55:42 <jle`> .oO0Oo.
12:05:40 <hyperisco> That is why you put a dot or a line in your zeroes. I have a few fonts that really struggle with Il1 though.
12:13:50 <boxscape> How come ghc isn't complaining about Overlapping instances here? It seems like the latter instance could apply to any type, and the first one at least to some, meaning there should be at least some types to which both apply, no? https://gist.github.com/JakobBruenker/e70f394900dd3799ab7a8a6fe9f32e2a
12:15:08 <jle`> boxscape: usually the complaint happens when you try to use the instances
12:15:22 <boxscape> Ahh, okay
12:15:30 <jle`> and yes those instaces are super overlappy
12:15:32 <boxscape> although..
12:15:38 <boxscape> I tried :t test show in the repl
12:15:42 <boxscape> and it didn't complain
12:15:52 <jle`> :o
12:16:05 <jle`> well, i suppose the type is unambiguous
12:16:06 <boxscape> or does it not happen if I just do :t
12:16:08 <boxscape> yeah okay
12:16:45 <jle`> try setting it to be a non-monomorphic value
12:16:54 <jle`> let x = test show :: Test (Int -> String)
12:17:07 <boxscape> yeah that doess it
12:17:09 <boxscape> thanks
12:17:14 <jle`> np
12:25:45 <basic> how exactly is indentation forced in haskell?
12:25:52 <basic> especially when doing do blocks
12:26:18 <basic> hlint shows a warning if i have less than 10 spaces in the next line
12:26:32 <basic> oh that's a lie, 8 lines
12:27:40 <boxscape> basic: if you want to know why it warns there it's probably easier to answer if you post that segment of code
12:27:48 <basic> okay une seconde
12:27:54 <boxscape> (on pastebin or something)
12:28:16 <basic> http://dpaste.com/2BVYF4J
12:28:51 <basic> i especially wonder why the functions get indented (automaticially) differently
12:28:53 <tabaqui> you should shift a little on lines 11-12
12:29:03 <basic> yeah i didn't do that by hand
12:29:31 <tabaqui> lines 11 starts on the same row as function declaration on line 10
12:29:49 <boxscape> sounds like whatever you're using for auto-indentation then might not be doing it quite right?
12:29:58 <tabaqui> so GHC doesn't know if "(ls, rs) <-..." is another declaration or a part of do-block
12:30:10 <basic> but that works, btw
12:30:30 <basic> i use "the best indentation tool for haskell" (tm)
12:30:40 <basic> itchyny/vim-haskell-indent
12:31:57 <boxscape> I'm guessing that technically you only have to indent it farther than the where block to have it be part of the do
12:32:17 <boxscape> or farther than the "where", rather
12:33:04 <basic> what should i use?
12:33:45 <boxscape> I would indent it one level further than the beginning of the function name
12:33:57 <boxscape> And I would claim that that's probably common practice
12:33:59 <basic> no i mean, automagic tools
12:34:02 <boxscape> oh
12:34:11 <dmwit> Here is the correct rule: after a block herald (like "where", "let", "of"), the next non-whitespace character sets the indentation level of the block.
12:34:16 <tabaqui> according to my style, I would place function declaration on the next row after the "where"
12:34:26 <dmwit> Each block must be indented at least as much as its enclosing block.
12:34:42 <basic> dmwit: oh yeah that would be clever, maybe that confuses the indentation tool
12:34:45 <tabaqui> and shift the do-block 2 positions further
12:35:04 <dmwit> So what's happening here on 11-12 is that you are starting a new block, at the *same* indentation level as the surrounding block. This is allowed, but does mean that you won't be able to add any more definitions to the enclosing block.
12:35:24 <boxscape> basic: I recently switched to neovimhaskell/haskell-vim and it seems to work well, but the developer of your plugin responded to an issue from me yesterday so he's probably open to ssuggestions
12:35:26 <dmwit> ("do" is also a block herald)
12:35:46 <basic> dmwit: and how many spaces from 'where' to "go"
12:35:55 <basic> or rather, how much more spaces, relative?
12:36:05 <dmwit> That is an aesthetic choice that you, the programmer, must make.
12:36:16 <dmwit> Like I said: the first non-whitespace character after the where sets the indentation level.
12:36:58 <dmwit> So you may use as much or as little space as you like... so long as the column you arrive at is *at least as deep* as any surrounding blocks (here, the module's implicit `where` block, so any depth is fine, even not indented at all.)
12:37:55 <dmwit> (...though to be clear: while it's allowed, I do not recommend starting the where block in column 0.)
12:38:14 <boxscape> maybe I missed something but why doesn't the explicit where count as a surrounding block?
12:38:43 <boxscape> or wait
12:38:44 <dmwit> Why would it count as a surrounding block?
12:39:09 <boxscape> hold on, you're saying the "go" can be not indented, or the (ls...) can be?
12:40:14 <dmwit> I believe all the code pasted is correct.
12:41:09 <boxscape> yes, I mean when you said "even not indented at all.", what were you referring to that could be not indented at all?
12:42:05 <dmwit> Also, it seems I am incorrect. I have reviewed the documentation, and the corrected rule is: the indentation must be deeper for let, where, or of, and may only be the same if the block herald is do.
12:42:26 <dmwit> So "even not indented at all" in particular was incorrect.
12:45:06 <dmwit> If the question is a stylistic one, my own preferred style puts a newline after every `where`.
12:46:35 <dmwit> (...and generally after the other block heralds if they are not the first token on the line, too.)
12:49:42 * hackage rounded 0.2 - Correctly-rounded arbitrary-precision floating-point arithmetic  https://hackage.haskell.org/package/rounded-0.2 (ClaudeHeilandAllen)
12:50:43 * hackage rounded 1.0 - Correctly-rounded arbitrary-precision floating-point arithmetic  https://hackage.haskell.org/package/rounded-1.0 (ClaudeHeilandAllen)
12:51:15 <maralorn> 0.2 -> 1.0 looks like rounding mistake to me.
12:52:11 <ClaudiusMaximus> maralorn: 0.x is for mpfr 3.1, 1.x adds stuff from mpfr 4.0
13:01:19 <boxscape> is there a word for non-function types?
13:03:51 <glguy> Not really. If you want to be specific you can give the kind
13:04:04 <glguy> there isn't a word for non-function values, either
13:04:15 <Cale> "non-function types"
13:04:31 <boxscape> I might juts  call my constructors something with "function" and something with "value" and pretend that functions aren't values
13:06:51 <boxscape> hmm does ghc not check whether constraints of instances are solvable when checking for overlapping instances?
13:07:13 * hackage shelly 1.9.0 - shell-like (systems) programming in Haskell  https://hackage.haskell.org/package/shelly-1.9.0 (GregWeber)
13:09:19 <boxscape> I guess not, considering it still says it even if I give (1 ~ 2) as constraint
13:20:24 <wildtrees> if a udp server socket is bound as address family AF_INET6 , is it still reachable via ip4 by clients? 
13:26:02 <glguy> wildtrees: It can be if you've bound to the wildcard address and you have your IP stack to allow IPv4 connections to the IPv6 wildcard
13:27:21 <wildtrees> I am binding using Nothing for the address in getAddrInfo to make the socket , and I am on windows 
13:37:33 <glguy> wildtrees: It looks like on Windows you might need to set the socket option IPV6_V6ONLY to 0
14:07:52 <boxscape> hmmmm when I import every module that's imported in Data.Singletons.Prelude everything is fine, but if I import Data.Singletons.Prelude itself, with the code fragment I have, ghc seems to not terminate
14:08:45 <wildtrees> would i be better off just binding the server socket to 127.0.0.1 if I just care about ipv4? 
14:09:38 <DrDuck> Does haskell provide first-class continuations?
14:11:18 <boxscape> Oh actually it does terminate it just takes a few minutes
14:11:21 <Rembane> DrDuck: Like this? https://en.wikibooks.org/wiki/Haskell/Continuation_passing_style
14:12:54 <DrDuck> yeah thanks
14:14:33 <Rembane> DrDuck: No worries, good luck! 
14:16:24 <boxscape> hm the type error ghc gives me contains the type variable k1 4946 times
14:17:30 <boxscape> (this is for a 20 line file)
14:20:56 <ski> DrDuck : "Does haskell provide first-class continuations?" -- no, not in the sense of Scheme,SML/NJ (and, iirc some Smalltalk implementation, maybe Ruby,&c. ?)
14:21:07 <ski> DrDuck : you can still use CPS, though, as in that link
14:22:52 <ski> (and `Cont',`ContT',`Codensity' will hide the CPS for you)
14:25:34 <boxscape> this whole thing makes me want to see a competition of people trying to produce the longest type errors with the least code
14:26:01 <c_wraith> I'm sure I've seen that before. 
14:28:14 <basic> woah is there really no good hs identation for vim?
14:28:52 <wildtrees> basic, space space ! 
14:29:03 <basic> i mean there is hlint
14:29:14 <basic> why not just "make it so"
14:29:29 <Lycurgus> woah, basic, vim, cognitive consonance!
14:29:58 <boxscape> I mean hlint isn't really primarily for formatting, those external tools are more brittany and stylish-haskell and such
14:30:12 * hackage yesod-auth-oauth2 0.6.1.2 - OAuth 2.0 authentication plugins  https://hackage.haskell.org/package/yesod-auth-oauth2-0.6.1.2 (PatrickBrisbin)
14:31:47 <ski> @where polymorphic-type-inference
14:31:47 <lambdabot> "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <https://cs.au.dk/~mis/typeinf.p(s|df)>,<http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.57.1493>
14:31:53 <ski> (p. 17 - 19)
14:33:06 <maralorn> basic: I use brittany + vim-autoformat, works very smooth.
14:38:23 <ski> @type let pair x y = \z -> z x y; x0 = \y -> pair y y; x1 = \y -> x0 (x0 y); x2 = \y -> x1 (x1 y); x3 = \y -> x2 (x2 y) in x3 (\z -> z)
14:38:25 <lambdabot> ((((((((((((((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) -> t1) -> t1) -> t2) -> t2) -> (((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) -> t1) -> t1) -> t2) -> t2)
14:38:25 <lambdabot>  -> t3) -> t3) -> (((((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) -> t1) -> t1) -> t2) -> t2) -> (((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) -> t1) -> t1) ->
14:38:25 <lambdabot> t2) -> t2) -> t3) -> t3) -> t4) -> t4) -> (((((((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) -> t1) -> t1) -> t2) -> t2) -> (((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (
14:38:25 <lambdabot> p -> p) -> t1) -> t1) -> t2) -> t2) -> t3) -> t3) -> (((((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) -> t1) -> t1) -> t2) -> t2) -> (((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -
14:38:25 <lambdabot> > p) -> (p -> p) -> t1) -> t1) -> t2) -> t2) -> t3) -> t3) -> t4) -> t4) -> t5) -> t5) -> (((((((((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) -> t1) -> t1) -> t2) -> t2) -> (((((p
14:38:27 <lambdabot> [32 @more lines]
14:38:32 <lavalike> that's a lot of type
14:38:51 <boxscape> hm, not bad
14:39:00 <ski> (see paper)
14:39:05 <boxscape> ok
14:40:46 <shapr> argh, I cannot figure out how to use ghcid to restart my scotty webapp
14:41:57 <shapr> Does anyone know how I can kill the executable, and then do "cabal new-run" whenever there are changes to any of src/Main.hs src/Lib.hs or myproject.cabal ?
14:42:24 <tabaqui> make refresh
14:42:43 <shapr> is refresh part of ghcid or cabal?
14:42:48 <tabaqui> GNU Make, of course :)
14:42:52 <tabaqui> sry, RMS
14:43:31 <tabaqui> oh, you're using ghcid
14:43:39 <shapr> I'm not picky
14:43:49 <shapr> I think I'll try entr next ( http://eradman.com/entrproject/ )
14:43:59 <hukyld> is there a way to tell stack script not to install ghc and use system one?
14:44:21 <shapr> don't think so
14:44:25 <tabaqui> hukyld, sure it is
14:44:29 <tabaqui> wait a sec
14:44:30 <shapr> oh?
14:44:34 * shapr learns something
14:44:52 <tabaqui> https://docs.haskellstack.org/en/stable/yaml_configuration/#system-ghc
14:44:59 <basic> how would you call: zip a (reverse a)
14:44:59 <basic> ?
14:45:04 <basic> that operation
14:45:18 <basic> it's not permutation, it's not combination what is it :o 
14:45:22 <shapr> > let a = [1..9] in zip a (reverse a)
14:45:25 <lambdabot>  [(1,9),(2,8),(3,7),(4,6),(5,5),(6,4),(7,3),(8,2),(9,1)]
14:45:31 <shapr> basic: oh, what's it named?
14:45:37 <EvanR> zipWith f xs (reverse ys) is a kind of convolution
14:45:38 <ski> > (zip `ap` reverse) [0,1,2,3]
14:45:40 <lambdabot>  [(0,3),(1,2),(2,1),(3,0)]
14:45:46 <basic> i wonder what it's equivalent would be for 3 parameters
14:46:01 <ski> looks like another Aztec god ?
14:46:13 <basic> Quezacotl?
14:46:14 <ski> (or maybe Mixtec, or Toltec or something ?)
14:46:36 <shapr> where did the aztecs get into the conversation?
14:46:38 <ski> @quote aztec.god
14:46:38 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
14:46:40 <EvanR> sum of zipWith (*) xs (reverse ys) is convolution
14:46:41 <shapr> oh
14:46:45 <hukyld> tabaqui: in my ~/.stack/config.yaml I have install-ghc: false \n system-ghc: true \n but for some reason stack script command is not picking it up (that is #!/usr/bin/env stack)
14:46:51 <ski> > (zip`ap`tail) [0,1,2,3]
14:46:53 <lambdabot>  [(0,1),(1,2),(2,3)]
14:47:05 <hukyld> tabaqui: works fine for real projects though
14:47:10 <tabaqui> hukyld: do you have GHC in your PATH?
14:47:24 <basic> so does that thing have a name?
14:47:42 <tabaqui> and try to add these lines in ~/.stack/global-project/stack.yaml
14:47:43 <ski> basic : s/za/tzal/
14:48:13 <basic> can't find any za :D
14:48:13 <hukyld> tabaqui: yep, /usr/local/bin/ghc 8.6.5 and I'm using lts-14.3 resolver. ok, let me try global
14:48:23 <basic> ah i c
14:48:31 <tabaqui> usually stack parses config located in "global-project" if is running outside of any repo
14:48:42 <hukyld> ah, that makes sense
14:48:59 <boxscape> These 22 lines of code produces 5000 lines of type error https://gist.github.com/JakobBruenker/02a9d69ae6bfbf8305f16c2e2cfac659
14:49:05 <shapr> ooh, we need a contest
14:49:32 <boxscape> (though I guess importing another package like here is cheating)
14:49:39 <shapr> I should restart the iohcc
14:50:03 <shapr> it's been decades
14:50:51 <tabaqui> hukyld: s/global-project/global
14:53:29 <tabaqui> boxscape: hmm, my ghci showed only 100 lines of errors
14:53:42 * hackage th-expand-syns 0.4.5.0 - Expands type synonyms in Template Haskell ASTs  https://hackage.haskell.org/package/th-expand-syns-0.4.5.0 (DanielSchuessler)
14:53:43 <boxscape> tabaqui what's your version of ghc and singletonss~
14:53:44 <boxscape> ?
14:53:44 <tabaqui> Could not deduce... and found hole...
14:54:00 <tabaqui> ghc-8.6.5 and no singletons at all
14:54:07 <tabaqui> I just didn't import them
14:54:08 <shapr> not a singleton one!
14:54:12 <tabaqui> is it sufficient?
14:54:22 <boxscape> tabaqui but that's the whole point, it only does it if you import the singletons prelude
14:54:41 <tabaqui> ok, what package does it belong?
14:54:44 <hukyld> tabaqui: doesn't seem to help (tried all, global-project|global config.yaml/stack.yaml) - does it work for you with "-- stack --resolver lts-12.21 script" ?
14:54:47 <boxscape> the singletons package
14:54:55 <hukyld> sorry, resolver 14.3
14:55:06 <shapr> I wonder if cabal accepts -HUP to reload/restart?
14:55:07 <shapr> I bet not
14:55:27 <shapr> nope, just stops
14:55:33 <tabaqui> hukyld: dunno, this station has no system ghc, I can test later on another one
14:56:13 <hukyld> tabaqui: no worries. thank you!
14:56:43 <tabaqui> welcome
14:57:49 <tabaqui> all right, what's wrong with singletons haddock?
14:57:57 <shapr> there can be only one?
14:58:28 <boxscape> tabaqui FWIW, this is the 5000 line error I'm getting https://termbin.com/pqgg
14:58:53 <shapr> wow, so pretty
14:59:09 <tabaqui> and it is still unfinished
14:59:22 <tabaqui> k1)))))))))))))))))))))))))))))))))))))))))))))))))))
14:59:25 <tabaqui> smells lispy
14:59:50 <boxscape> oh yeah, the pastebin cut off the bottom of it it seems
15:00:15 <shapr> tabaqui: this is blog post worthy
15:00:15 <tabaqui> looks like an issue with AmbigiousTypes and infinite type
15:00:49 <boxscape> I'm kind of confused as to why it just stops at some point rather than going on forever
15:00:57 <shapr> me too
15:01:02 <shapr> perhaps it ran out of buffer space?
15:01:06 <shapr> you may have found a bug!
15:01:24 <boxscape> but if it ran out of buffer space wouldn't it say that?
15:01:24 <c_wraith> maybe it hit an intentional depth limit? 
15:01:44 <boxscape> well, the typical depth limit is 200 for type family evaluation or whatever, I think, and it tells you when it hits that
15:02:00 <boxscape> could be a different limit of course
15:03:11 <shapr> tabaqui: is the source for that available?
15:03:29 <tabaqui> huh?
15:03:36 <boxscape> since I don't really know if it's a problem with ghc I was considering reporting it as a singletons issue, but I don't really think they can do much about it...
15:04:26 <shapr> tabaqui: could I get the source code that produces that massive error?
15:04:44 <boxscape> shapr I potsed it
15:04:51 <boxscape> unless you mean some other error
15:04:52 <tabaqui> shapr: oh, it wasn't my code :)
15:04:55 <shapr> oh sorry
15:04:56 <shapr> ahem
15:05:02 <shapr> hi boxscape, could I get the source for your amazing error?
15:05:05 <boxscape> https://gist.github.com/JakobBruenker/02a9d69ae6bfbf8305f16c2e2cfac659
15:05:24 <tabaqui> uhm, guys, do you think this should be in documentation?
15:05:25 <tabaqui> https://hackage.haskell.org/package/singletons-2.6/docs/Data-Singletons.html#t:-64--64--64--35--64--36-
15:06:16 <tabaqui> what a mess
15:06:19 <boxscape> tabaqui, the newest version of singletons has only been on hackage since I think today, so maybe not, but generally speaking you'll see a lot of weird stuff in their haddock because a lot is generated by template haskell
15:06:29 <Fendor> did hackage change today? 0.o
15:06:37 <boxscape> yeah it looks like new packages have a new look
15:06:40 <boxscape> the old ones are still the same
15:06:58 <Fendor> weird
15:07:12 <tabaqui> ok, 2.5.1 has fine decoration, but a lot of generated code still
15:07:19 <shapr> boxscape: super cool
15:07:40 <boxscape> thanks, I came across it while failing to write a general liftA function
15:08:41 <shapr> there's a contest for C++ where your score is the number of lines of input vs the number of lines of output errors
15:09:03 <boxscape> neat
15:09:10 <shapr> I think you're already ahead
15:09:19 <boxscape> does it count though if you import third party packages?
15:09:26 <shapr> I don't know
15:09:53 <Fendor> i feel like the new design is slower
15:18:46 <iqubic> :t (.)$(.)
15:18:48 <lambdabot> (a1 -> b -> c) -> a1 -> (a2 -> b) -> a2 -> c
15:20:35 <boxscape> :t (.) (.)
15:20:37 <lambdabot> (a1 -> b -> c) -> a1 -> (a2 -> b) -> a2 -> c
15:20:49 <iqubic> :t (.).(.)
15:20:50 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
15:21:05 <shapr> I gave up on ghcid and switched to entr instead: ls src/*.hs *cabal static/* |entr -r cabal new-run
15:21:21 <iqubic> I actually know why those have te type signatures they do.
15:21:52 <boxscape> I find it easier to think about it in terms of fmap . fmap
15:28:45 <EvanR> thinking of . as being composition of arrows in a category, i find it odd it can be passed to itself
15:29:27 <EvanR> as if you considered (+) (+)
15:30:22 <boxscape> That's what you get when composition of morphisms is a morphism I suppose
15:30:39 <boxscape> should be the case in Set as well, I think?
15:33:58 <boxscape> (I don't mean "the composition of two morphisms is a morphism", I mean "the concept of composition is a morphism")
15:36:11 <ElectroStatik> a composition of functors is surely a morphism
15:46:54 <basic> can i has multithreaded infinite list of pi digits?
15:47:46 <shapr> basic: spin off number of cores of closed form pi digit generation code?
15:47:58 <basic> well what i actually want to know
15:48:06 <basic> if i had algorithm x for generating digits
15:48:14 <basic> and i multiread it, can i have it has infinite list?
15:48:23 <basic> multithread*
15:48:42 <basic> tl;dr: can i create a list that is created on all cores
15:49:48 <shapr> basic: https://stackoverflow.com/questions/15193283/parallel-parmap-and-strategies ?
15:52:08 <shapr> basic: that looks like yes to me
15:52:40 <shapr> though in one memorable instance I fired off several hundred thousand sparks, and my laptop slowed to a crawl
15:53:01 <shapr> then I switched to parBuffer and fired off only a few hundred sparks for my eight cores, and it was *fast*
15:53:14 <shapr> and when I fired off exactly eight sparks, it was not fast
15:57:10 <basic> but you wouldn't be able to do it with concurrency, right?
15:57:25 <hexagoxel> ghc-8.8 was not announced on the haskell.org ML, was it?
16:02:13 <ElectroStatik> you want take N <list_comprehension> where the list comprehension contains an infinite list enumerating results of the RNG; then you can parallelize the lazy list result 
16:02:19 <hexagoxel> (and this is not a complaint-phrased-as-question; I may have messed up my mail sorting scripts)
16:02:35 <dmwit> shapr: What shell? I would think src/*.hs isn't Enough Stuff.
16:06:12 <ElectroStatik> you want take N <list_comprehension> where the list comprehension contains an infinite list enumerating results of the RNG; then you can parallelize the lazy list result 
16:12:51 <eivnwgxlbjf> Hello
16:13:06 <eivnwgxlbjf> If I havePrelude> :t twicetwice :: (t -> t) -> t -> t
16:13:15 <eivnwgxlbjf> Prelude> :t twicetwice :: (t -> t) -> t -> t
16:13:29 <eivnwgxlbjf> twice :: (t -> t) -> t -> t
16:13:39 <eivnwgxlbjf> when I ask for :t twice
16:13:46 <eivnwgxlbjf> then is that the same type  as
16:13:56 <eivnwgxlbjf> twice :: (a -> a) -> a -> a
16:14:18 <eivnwgxlbjf> or does the `a` vs the `t` in the type signature given by :type have any significance?
16:15:13 <boxscape> as long as all the type variables that were equal are still equal, changing the names of them doesn't make a difference
16:15:26 <boxscape> so, no, it doesn't have significance
16:15:26 <eivnwgxlbjf> thanks
17:08:53 <pinecamp> if I have a value of a type that is a synonym for another more common type, how can I pass its underlying value to a function expecting that original type?
17:09:32 <lyxia> you just pass it
17:09:51 <jle`> pinecamp: if it's a type synonym, it's more or less a purely lexical alias
17:09:58 <jle`> so to the type system, the two are the same
17:10:15 <pacak> Is it OK to advertise a position for haskell related internship a bit?
17:11:23 <pinecamp> thanks lyxia and jle`! turns out what I'm passing is not a synonym for the type I thought it was :) 
17:11:48 <Axman6> Reddit seems to be the main place that happend pacak, but feel free to share a link here too
17:12:47 <pacak> https://www.reddit.com/r/haskell/comments/cx8yei/tsuru_capital_is_looking_for_haskell_interns/ - reddit you say...
17:13:08 <Axman6> Hey I was an intern at Tsuru, it was great 
17:13:17 <Axman6> I'm heading back to Japan on Wednesday actually
17:13:34 <pacak> So yea, internship at Tsuru capital. 3-6 months, Tokyo. Haskell. A big coffee machine.
17:13:48 <pacak> Axman6: Yea, still cleaning up some of your code :)
17:13:57 <Axman6> They used to have a tiny but excellent coffee machine
17:14:00 <Axman6> :|
17:14:18 <MarcelineVQ> :>
17:14:21 <Axman6> I'm glad my legacy has lasted so long!
17:14:40 <pacak> There are still bits left.
17:15:10 <Axman6> All the code I wrote used to be ruby, so be thankful it's not that =)
17:16:01 <pacak> Was it? I think I saw haskell. Anyway, ruby is gone now.
17:29:12 * hackage gscholar-rss 0.2.3.0 - scrapes google scholar, provides RSS feed  https://hackage.haskell.org/package/gscholar-rss-0.2.3.0 (fffaaa)
17:30:12 * hackage gscholar-rss 0.2.3.1 - scrapes google scholar, provides RSS feed  https://hackage.haskell.org/package/gscholar-rss-0.2.3.1 (fffaaa)
18:33:10 <Axman6> pacak: my job was replacing the ruby with Haskell
18:34:00 <pacak> Good times :)
18:35:38 <fresheyeball> Axman6: that is beautiful 
18:43:20 <monochrom> hexagoxel: Seems to be true! I saw GHC 8.8.1 on haskell-cafe but not on haskell.
19:05:12 * hackage salak-toml 0.3.5.3 - Configuration Loader for toml  https://hackage.haskell.org/package/salak-toml-0.3.5.3 (leptonyu)
19:07:45 <iqubic> What new features are going to be in GHC 8.8.1?
19:09:54 <lyxia> iqubic: https://www.reddit.com/r/haskell/comments/cvloc4/announce_ghc_881_released/
19:12:16 <iqubic> Thank you.
19:13:50 <suzu> omg omg
19:13:54 <suzu> new ghc ayyyy
19:14:11 <Clint> gawrsh
19:17:08 <iqubic> The biggest change, in my eyes is deprecating StarIsType.
19:18:03 <suzu> so you /must/ use Type in kind signatures?
19:19:11 <iqubic> I think that is the idea, yes.
19:21:10 <Axman6> biggest change is definitely the amd64 performance improvements
19:21:50 <nshepperd2> Can we still use the Unicode star though
19:24:03 <Axman6> Yes but you need to use the ‚≠êÔ∏èIsType extension
19:24:14 <Axman6> hmmm... that did not render at all correctly for me
19:31:06 <jusss> :t (+1)
19:31:07 <lambdabot> Num a => a -> a
19:31:52 <jusss> Just x >>= \x -> Just (doSomething x),  right?
19:32:04 <jusss> :t Just
19:32:06 <lambdabot> a -> Maybe a
19:32:45 <jusss> is (+1) is a monad?
19:34:14 <winny> :t (+)
19:34:16 <lambdabot> Num a => a -> a -> a
19:35:05 <winny> :t (+) 1
19:35:06 <lambdabot> Num a => a -> a
19:35:17 <pacak> > join (+) 1
19:35:19 <lambdabot>  2
19:35:36 <pacak> jusss: It's a function a -> a which comes with a bunch of instances.
19:36:10 <jusss> pacak: what's the context in the function?
19:36:36 <pacak> A reader monad?
19:36:48 <jusss> like in Maybe, there're Just and Nothing in the context, so what's in the context of functions?
19:38:07 <pacak> It passes around  value you pass in.
19:38:49 <jusss> pacak: so if e->a and e-> is the monad, then a is the result of the function, right?
19:39:00 <pacak> http://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#line-828
19:39:11 <jusss> pacak: and the context is the function (->) and input e
19:39:13 <jusss> Ôºü
19:39:35 <pacak> I guess so
19:40:36 <jusss> :t (.)
19:40:38 <lambdabot> (b -> c) -> (a -> b) -> a -> c
19:44:24 <jusss> if a-> is the context, input a and function (->) is the context, the result b is the a in f a, right? so (.) will apply a function (b->c) on another function (a->b) and get a new function (a->c) , which has the same context (a->) but changed the result
19:44:29 <jusss> ?
19:45:45 <pacak> (a->) stays the same, value changes.
19:46:20 <jusss> pacak: but hey, when it's in >>= , it seems diffrent
19:46:26 <jusss> :t (>>=)
19:46:28 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:46:43 <pacak> (a ->) sits inside m
19:46:48 <jusss> >>= :: (e->a) -> (a->(e->b)) -> (e->b)
19:46:54 <pacak> :t Reader
19:46:56 <lambdabot> error:
19:46:56 <lambdabot>     ‚Ä¢ Data constructor not in scope: Reader
19:46:56 <lambdabot>     ‚Ä¢ Perhaps you meant one of these:
19:47:58 <pacak> Hmmm...  It's a type alias. Anyway, (a->) is a reader monad just with less types
20:14:01 <fizbin> Can someone check my code for me? I think I've found a pretty fundamental bug in the library 'hashtables', and I want to be sure I'm not misunderstanding something.
20:14:16 <fizbin> Code is up at https://github.com/fizbin/disorientation/blob/master/src/Main.hs
20:14:42 <fizbin> And at https://github.com/fizbin/disorientation in general.
20:21:05 <Cale> fizbin: Yeah, that's pretty weird
20:21:57 <fizbin> Yeah. I'm minimizing it to remove the extraneous dependency on containers; I was just writing it up because I couldn't believe what I was seeing in my code.
20:22:37 <pacak> What's the ghc version btw?
20:23:47 <Cale> 8.6.4 in my case
20:24:03 <Cale> (I'm able to reproduce the issue)
20:24:55 <fizbin> I'm a bit surprised that hashtables could fail such a simple test and not fail its own unit tests.
20:26:13 <Cale> Yeah, the same thing happens without any involvement of IntMap/IntSet
20:26:30 <pacak> It can be a bug in ghc. There was one similar two years ago https://gitlab.haskell.org/ghc/ghc/issues/13615
20:26:33 <Cale> (Just made it into a Hashtable s Int Int)
20:26:52 <fizbin> Cale: Yeah, I just pushed similar.
20:26:54 <pacak> It depended on ST Monad and GC
20:28:20 <pacak> fizbin: If you change insertions from being in a single call of ST monad into several smaller steps - is it still reproduceable?
20:29:34 <pacak> Also it seems hashtables comes with a whole bunch of unsafe flags.
20:29:39 <pacak> Try disabling some of them
20:30:20 <fizbin> Oh, this is nice: if I use H.insert instead of H.mutate to add things, I don't get the error.
20:32:54 <Cale> fizbin: Yeah, also, fromList doesn't cause it
20:33:30 <fizbin> But what does is using H.insert on [1..64], and then H.mutate on 65
20:33:31 <pacak> fromList is implemented in terms of insert
20:34:00 <fizbin> pacak: I'm implementing the two-ST-invocations trial now.
20:34:53 <pacak> https://github.com/gregorycollins/hashtables/issues/55
20:36:47 <fizbin> Ha! Okay. So, this basically makes the cuckoo hash hashtable unusable for my purposes and is a *really* nasty bug.
20:36:51 <pacak> So it's a known bug in hashtables. I'd switch to some other library.
20:40:57 <fizbin> pacak: Is there some other library that supplies similar functionality? I guess I can go use simple Data.Map Maps, but I was trying to address the huge amount of time I spent in compare when using that.
20:41:31 <pacak> What kind of functionality do you need?
20:43:25 <pacak> There's unordered-containers
20:45:05 <fizbin> Basically, I need a map that's faster than Map, and my keys are Hashable but compare on them is a bit slow. I'll look at unordered-containers.
20:45:37 <Axman6> unordered-containers is the standard answer to exactly that problem
20:51:17 <lyxia> it's sad how undiscoverable the name is
20:54:19 <jle`> ooh i just visited tokyo for the first time about a month ago.  would definitely be nice to have a haskell gig there
21:05:40 <rajivr___> I am learning Haskell. I was wondering if there was a way to deconstruct `Combine` by writing a function similar to how `newtype` is doing it? https://gist.github.com/rajivr/00dc7a29c474819cd4d8f899fca16aae
21:05:44 <pacak> jle`: If you are very good you can get a permanent position as well. Same process
21:07:50 <jle`> ah yeah, i'm sort of at the stage in my career where an internship isn't viable. if only i was born later :'(
21:08:15 <jle`> rajivr___: you can pattern match
21:08:21 <jle`> but you can also use record syntax in gadt syntax
21:08:43 <jle`> data Combine :: Type -> Type -> Type where Combine :: { unCombine :: a -> b } -> Combine a b
21:08:56 <jle`> (you could even say newtype there)
21:09:06 <jle`> or else you can pattern match, unCombine (Combine f) = f
21:09:32 <pacak> I got an internship at Tsuru something like 7 years after finishing my degree.
21:10:18 <rajivr___> jle`:  Thanks a lot. Let me try the pattern match route. I didn't realize that would have been possible.
21:13:16 <rajivr___> jle`:  It worked! Thanks again! :-)
21:13:30 <jle`> :D
21:13:48 <jle`> rajivr___: yeah, in the case you're using it here, it's equivalent to just a normal data declaration
21:14:02 <jle`> rajivr___: you can think of them as just two syntaxes for defining the same thing internally
21:14:11 <jle`> rajivr___: in fact, you don't even need -XGADTs, you can just use -XGADTSyntax
21:14:28 <jle`> at that point the two data types are identical when you use them.
21:20:06 <Axman6> pacak: you should just hire jle`, I would
21:21:21 <pacak> Only after looking at the code sample solution.
21:22:28 <Axman6> Read his blog, you'll see hwta I mean =)
21:22:33 <pacak> I don't think we fired anyone right after 3 months.
21:23:00 <Axman6> How long have you been there anyway?
21:23:17 <jle`> ah, don't take me too seriously -- i was only day dreaming about a short term internship
21:24:05 <Axman6> I miss the yakatory place downstairs from the office, and the awesome raman place we used to go to D:
21:24:07 <pacak> There's a process we follow for hiring and getting stuff in production. When we deviate from that process usually bad things happen.
21:24:24 <pacak> Axman6: I'm in Singapore :)
21:24:49 <Axman6> Oh yeah I forgot about the move, is there still a Tokyo office?
21:25:00 <pacak> There is and it's still there.
21:25:01 <Axman6> I guess there is if there's an internship there
21:25:06 <pacak> There's no Singapore office though.
21:25:07 <jle`> oh i just visited singapore for the first time too last month
21:25:21 <jle`> i saw the standard chartered building and thought "there must be some haskell going on in there right now"
21:25:27 <Axman6> I could see myself living in )singapore, it seems like a great place
21:25:34 <Axman6> ha
21:25:53 <pacak> There are monthly haskell meetups in there.
21:25:53 <jle`> maybe if i walked in and asked nicely they'd show me their fork of ghc
21:26:10 <Axman6> and then kill you
21:26:16 <pacak> I'm not sure if it's a fork of ghc or a fork of something else
21:26:24 <jle`> Axman6: sounds like SOP yeah
21:26:50 <pacak> jle`: So which place was better? Tokyo or Singapore? :)
21:27:09 <jle`> it's hard to compare, they both had very different sorts of atmosphere to me
21:27:38 <pacak> Just remember - Tokyo gets cold every once in a while. It's always nice and warm in SG
21:28:17 <Axman6> I'd take cold any day over humidity
21:28:22 <jle`> ah yeah, being at 89¬∞ latitude would do that
21:28:26 * Axman6 lives in Canberra
21:29:09 <Axman6> 40C and 0% humidity <3, 20C and 100% humidity :'(
21:29:16 <pacak> Upsidedown country where spiders have their own HP bars and everything wants to kill you?
21:29:40 <pacak> 30C and 90% humidity is not that bad actually
21:29:53 <jle`> i'm somewhat used to a slightly less extreme version of singapore weather, my family is from an SE Asia country and i visit often
21:30:31 <rajivr___> We used to jokingly  say there are two seasons in s'pore - rainy and shiny. They occur on the same day throughout the year.
21:30:59 <pacak> rajivr___: There's also a hazy one.
21:31:27 <rajivr___> that's a friendly gift from our neighbors.
21:32:00 <Axman6> we were there almost exactly a year ago, and I was impressed how consistent the weather way. rain fell about the same time everyday
21:32:23 <Axman6> Thanbks Winnie
21:34:18 <jle`> for me one of the more jarring things was the time zone
21:40:13 * hackage network-run 0.2.0 - Simple network runner library  https://hackage.haskell.org/package/network-run-0.2.0 (KazuYamamoto)
21:50:23 <Axman6> Anyone know what the state of GHC/Haskell on ARM is these days?
21:59:09 <iqubic> Who uses ARM these days? /s
22:02:39 <pacak> I think angerman did some cross compilation work related to arm.
22:04:37 <pacak> iqubic: Raspberry pi would like to have a word with you.
22:05:06 <angerman> Axman6: if you read the 8.8 release notes, you'll find a small section on arm.
22:05:33 <pacak> angerman: o/
22:06:18 <angerman> Axman6: I doubt we have native ghc binaries right now. nixos apparently can't provide them as they are past the 2GB limit they have imposed on derivation outputs, which is somewhat sad. You can still build ghc's on arm. Or well cross compile to arm.
22:06:30 <angerman> (or use qemu, ...)
22:07:30 <angerman> Axman6: for cross compilation you'll run into a bit of an issue with TH. Most (not process/file IO usually) of which will *just* work if you go down the iserv route (either via a real target or some emulated one).
22:07:36 <angerman> pacak: \o
22:16:31 <greysunshine> Hello guys, I'm trying to use Graphics.GD library to draw some pixels. I'm getting type error with this https://gist.github.com/vasanthaganeshk/15cdb89286644d217fc5e5ded4a12d69. What am I doing wrong?
22:18:13 <pacak> You are not showing us the type error. That's wrong.
22:19:28 <pacak> You also use setPixel in a wrong way. You need mapM_ or forM_ instead of fold.
22:20:24 <pacak> Also I'm pretty sure mandlebrot is more than 2 pixels.
22:21:06 <EvanR> mandlebrot is at least 45,000,000,000 pixels. perhaps more
22:23:38 <greysunshine> Yeah, you are are right. I tried to give a minimal example of what was not working. I just wanted to set some pixels. Thanks! I'll try mapM_ and forM_.
22:25:18 <greysunshine> My type error: https://gist.github.com/vasanthaganeshk/3e244bf1ff95102628f564f18ff24792
22:26:04 <pacak> Can you explain your understanding of it?
22:33:25 <greysunshine> The next value generated by application of fold yields a different type than expected.
22:40:41 * jgt says Good Morning to the Haskellers while continuing to rock out to the new Tool album
22:41:08 <no-n> I didn't know there was a new Tool album
22:41:30 <jgt> just came out today
22:41:35 <jgt> after 13 years
22:43:09 <no-n> I see :o
22:46:51 <Axman6> greysunshine: What is the type of savePngFile? what is the type of c?
22:49:31 <greysunshine> It should have been `b' and not c. But I used mapM and it worked.
22:51:09 <greysunshine> pacak: Thanks!
22:51:14 <dminuoso> tdammers: Heh, it seems they did listen to our advice. Even published it the same day https://twitter.com/razvan_panda/status/1166376127163772935 :)
22:52:21 <pacak> greysunshine: Most likely you want mapM_
22:53:22 <tdammers> dminuoso: cool
22:53:55 <tdammers> the hashtag list is kind of funny
22:54:11 <tdammers> "#kanban #agile #scrum"
22:54:27 <dminuoso> Heh
22:55:51 <dminuoso> tdammers: Im just somewhat surprised there's barely any code there. Originally I assumed this was already some working skeleton.
22:56:30 <greysunshine> pacak: Yeah. I'll use mapM_ instead.
22:59:24 <tdammers> dminuoso: so, typical example of "extremely valuable idea" then?
22:59:46 <MarcelineVQ> tool to fix stack build issues, project uses nix, waitaminute...
23:00:31 <tdammers> IIUC the tool is supposed to parse stack build output, figure out what you did wrong, and automatically fix it for you, like missing imports and such
23:00:49 <tdammers> you don't need to use stack to build that tool just because it interfaces with stack at runtime
23:01:09 <maerwald> there's a nice talk from the SVN developers, where they explained the best way to trash your project is to invite contributors at a too early stage
23:01:21 <MarcelineVQ> I think it's more about build-deps, because the guy had issues getting stack extra deps sorted out if it's the same person I'm thinking of
23:01:29 <dminuoso> Im not convinced SVN developers are the best source of advice.
23:01:30 <dminuoso> :-p
23:01:31 <maerwald> when you start a project, you want no contributors, because your idea is not clear enough
23:01:52 <maerwald> dminuoso: exactly, it's about their arguments
23:01:58 <pacak> https://www.reddit.com/r/haskell/comments/cx8yei/tsuru_capital_is_looking_for_haskell_interns/ - Tsuru Capital is looking for interns
23:02:32 <tdammers> I'd argue that much of SVN's badness is due to the SVN people not listening enough to their users
23:02:39 <dminuoso> pacak: Oh shoow, that's nice. :)
23:02:46 <dminuoso> pacak: Didn't know Japan had a Haskell scene.
23:03:16 <maerwald> tdammers: there is a point where contributors will derail your project, because the vision is not clear enough yet
23:03:16 <pacak> https://www.reddit.com/r/haskell_jp/
23:03:18 <monochrom> Don't forget that the network package came from Japan!
23:03:21 <jgt> iirc one of the main warp maintainers is a Japanese guy
23:03:32 <dminuoso> TIL
23:03:51 <tdammers> maerwald: I'd argue that a project doesn't need vision, just a sufficiently small scope
23:03:59 <maerwald> write some code, harden your vision, do some substantial work, then go advertise it 
23:04:16 <maerwald> if you just advertise your ideas without code... well
23:04:20 <dminuoso> It's not ideas that are valuable, it's products.
23:04:20 <tdammers> write some code, reduce your scope to the bare essentials, implement that, then go advertise it
23:04:39 <tdammers> but yes, code talks, ideas alone are a dime a dozen
23:04:40 <maerwald> dminuoso: hmm, not sure I agree :)
23:04:55 <tdammers> if you can't reduce your idea to something you can implement in a week, then it might not be a great idea after all
23:05:00 <tdammers> (or simply not feasible)
23:05:15 <maerwald> solutions are valuable. You then use solutions to build whatever product you want
23:05:21 <maerwald> products are secondary
23:05:22 <tdammers> and the one-week impl doesn't have to be perfect or production-ready or any of that, but it should demonstrate the usefulness and feasibility of the idea
23:05:29 <dminuoso> tdammers: Well Im not sure I agree with that assessment. Some ideas take a lot longer to implement, say if you had some great idea about a new kernel architecture.
23:06:05 <jgt> yeah I don't agree with that idea either
23:06:20 <jgt> for some products that's certainly true
23:06:23 <maerwald> tdammers: I think that tool could even be written in shell. Log parsing and then doing stuff seems simple enough
23:06:30 <maerwald> then you have an MPV in ~2 weeks
23:06:34 <maerwald> *MVP
23:07:19 <tdammers> I'm exaggerating a bit, but I think even with something like a kernel architecture, you can get enough work done in a week to assess whether the idea is worth further investment. maybe not actual code, just something like a paper, or a more detailed design that highlights and addresses the most important design considerations
23:07:47 <maerwald> tdammers: a plan? you're not agile enough :P
23:08:04 <dminuoso> Why do people conflate "agile" with "just start working and see what happens" ?
23:08:18 <maerwald> because that's how it works in industry
23:08:22 <tdammers> maerwald: I didn't say "plan". I said "design".
23:08:26 <dminuoso> It doesn't really, maerwald.
23:08:27 <maerwald> Whether that corresponds to the agile manifesto is another topic
23:08:31 <maerwald> dminuoso: it does.
23:08:34 <tdammers> maerwald: also, you misspelled "Agile‚Ñ¢"
23:08:56 <maerwald> yeah, agile manifesto is barely implemented
23:09:00 <jgt> all of my experiences with Agile have been ceremony and charlatanry
23:09:19 <tdammers> the whole point of the manifesto is that "agile" is not something you "implement"
23:09:32 <dminuoso> jgt: It depends a bit on the company. I know some that try to condence agile about the main idea: short feedback loops.
23:09:34 <maerwald> tdammers: but managers want to implement these things, otherwise...
23:09:41 <maerwald> tdammers: you'd have to trust your engineers :o
23:10:09 <tdammers> it tries to avoid giving you a list of rules to "implement", and instead tries to describe a mindset. and of course that doesn't fly, because your typical manager can only work with rules and hard metrics
23:10:36 <jgt> dminuoso: that's fair enough, but it sounds like it has the same marketing issue as matrimony or feminism ‚Äî it means very different things to different people
23:11:03 <maerwald> tdammers: yep, but even short feedback loops are not always what you want.
23:11:16 <maerwald> So it is also flawed in believing that always works
23:11:34 <tdammers> I like to say that the best methodology is to hire the best engineers you can get, put them in a room with a bunch of whiteboards, enough computers, and a phone that they can use to call the client at any time, and leave them to it for maybe 3 weeks, unless they come to you, in which case you fucking solve the problems they're experiencing
23:11:34 <maerwald> TL;DR: have people, who know what they are doing, lol
23:11:41 <jgt> maerwald: when do you not? (Not saying you're wrong, just can't immediately think of an example)
23:11:49 <maerwald> jgt: safety critical systems
23:12:12 <tdammers> the most blatant problem in all those "methodologies" is that they tend to reverse the problem-solution ordering
23:12:18 <dminuoso> tdammers: Well if they are the best engineers, chances are they will intuitively apply  the important parts of the agile mindset already.
23:12:24 <jgt> tdammers: that's what I'm doing, except I don't put people in rooms with whiteboards
23:12:44 <maerwald> tdammers: have you applied big data already? 
23:12:50 <tdammers> dminuoso: exactly
23:13:31 <dminuoso> tdammers: So agile is about "what if you dont have the best engineers". How do you turn your inexperienced "hired out of high school javascript developer" into one that can work effectively.
23:13:40 <nshepperd> "just start working and see what happens" is pretty much what I do
23:13:44 <maerwald> dminuoso: mentoring :)
23:13:45 <dminuoso> Whether it's good at that is debatable
23:13:47 <tdammers> the main point about the "room with whiteboards" thing is that it doesn't attempt to solve problems that may not even exist at this point
23:13:50 <maerwald> But there's a huge problem with that
23:14:33 <nshepperd> somehow I never get around to releasing any of my personal projects, which either means that agile doesn't or does work ;)
23:14:51 <tdammers> so you hired one awesome programmer and two fresh-out-of-highschool people
23:15:09 <tdammers> that's fine, it'll work, as long as your expectations are adequate
23:15:22 <jgt> nshepperd: my way to overcome that problem was to put my work in front of other people (and paying people)
23:15:33 <jgt> so I'm sort of forced to get things done
23:15:41 <maerwald> tdammers: burn out the freshmen, fire them, hire 2 new, while the awesome programmer gets a steady payraise and works full-time on features
23:15:51 <tdammers> your awesome programmer will spend a lot of time looking after the two juniors, so the overall productivity might actually be less than what you had gotten from the awesome programmer alone
23:16:04 <tdammers> yeah, you could do that.
23:16:30 <tdammers> or you could consider it an investment, because after maybe 2 years, your juniors will have learned a lot, and now the scale tips in the other direction
23:16:30 <maerwald> Well, I wouldn't :P
23:16:53 <maerwald> tdammers: long-term planning doesn't work well in start-ups, so yeah, there is that
23:16:59 <tdammers> they start being more self-sufficient, and they have spent 2 years growing into being a team
23:17:02 <tdammers> ofc
23:17:25 <tdammers> also, in many startups, the more pressing issue is that the first couple developers you can work with are the founders
23:17:27 <maerwald> the companies that do that usually are japanese or german :P
23:17:42 <maerwald> (investing long-term in employees, so I think there is a cultural part)
23:17:50 <tdammers> oh yes, germany still has this "one job should last a lifetime" culture
23:17:55 <maerwald> yeah
23:18:13 * hackage yesod-auth 1.6.8, yesod-core 1.6.16 (MichaelSnoyman): https://qbin.io/bank-fleet-6wu7
23:18:18 <tdammers> you go to school, you get an education, and then you find the one job that you will ride out until retirement
23:18:33 <maerwald> we're obsessed with stability
23:18:39 * pacak been working  for 8 years at the same place, happy so far
23:18:44 <maerwald> (and thus we build stable cars, lol)
23:18:53 <tdammers> the same culture also exists wrt homes - you save up until you can afford the downpayment, and then you buy the home that you will spend the rest of your life in
23:19:17 <dminuoso> tdammers: That's why we didn't commit to a house. We prefer a rented flat, giving us maximum flexibility.
23:19:24 <tdammers> whereas Dutch culture is more like, OK, so I'll buy a house now, finance it such that I'm not making a loss over the next 10 years or so, and when the time is good, I'll sell and find a better one
23:20:01 <dminuoso> (Plus, owning an entire home creates tons of extra work)
23:20:06 <jgt> Yeah! Michael merged my latest yesod-core patch! :D
23:23:17 <maerwald> tdammers: what do you prefer?
23:23:39 <tdammers> let's say I emigrated from Germany to NL for a reason
23:23:52 <jgt> tdammers: is it true that you can get a mortgage on a yacht in NL?
23:24:19 <tdammers> jgt: I have no idea. Never tried. Wouldn't surprise me though, after all, you can get a mortgage on a houseboat.
23:24:42 <tdammers> could be that the law is sufficiently vague that a yacht that you use as your main residence could qualify
23:24:50 <jgt> that's my goal
23:25:05 <tdammers> simply because the law does an insufficient job at defining what is and is not a houseboat
23:25:19 <dminuoso> This discussion has shifted completely into -ot though
23:25:40 * jgt profusely apologises
23:35:02 <jusss> what's in the context when you think functor or monad are e-> ?
23:35:46 <dminuoso> jusss: The context is that "additional thing"
23:36:06 <jusss> dminuoso: is the input in the context?
23:36:16 <dminuoso> jusss: What do you mean by input?
23:36:37 <jusss> dminuoso: function take a input and return a ouput
23:37:13 <dminuoso> jusss: We call this applicative/monad instance of (e -> _) "reader". So the point of reader is to give you read-only access to a global/shared environment.
23:37:50 <dminuoso> jusss: So the context in this monad, is that "shared environment"
23:39:06 * ski calls it "environment" (or maybe "input")
23:40:07 <ski> ("read-only access, with possibility to shadow / local override")
23:40:16 <jusss> I suddently know nothing about e-> as monad or functor...
23:40:36 <dminuoso> jusss: Write out the monad instance for ((->) e)
23:40:42 <dminuoso> jusss: It's a useful excercise. :)
23:43:16 <mycroftiv> really basic question here - it suddenly dawned on me (way too late) that pattern matching is generally equivalent to making a lambda, but for some reason it hasnt been presented that way and when i look back at my learning materials, they dont seem to state this. have i confused myself?
23:43:20 * koz_ is hype for GHC 8.8 and cabal-install-3
23:43:50 <jusss> dminuoso: f >>= g = \x -> g (f x) x
23:45:04 <jusss> dminuoso: I can do type inference to get this function definition through its type signature, but what I don't know is how to think it, how to understand the context, 
23:45:07 <c_wraith> mycroftiv: I'd say you've confused yourself.
23:45:42 <mycroftiv> c_wraith: i believe you, but so far as i can tell addone x = x + 1 seems the same as addone = \x -> x + 1 >
23:45:51 <mycroftiv> err, that > was supposed to be a ?
23:45:58 <jusss> e-> is not like the others, it's special 
23:47:02 <jgt> mycroftiv: those are for practical purposes equivalent, but that's not _exactly_ a discussion about pattern matching
23:47:24 <c_wraith> mycroftiv: Ah, that's true.  a function declared with syntactic arguments is (except for some details about how ghc optimizes) equivalent to declaring a value bound to a lambda.
23:47:59 <mycroftiv> ok, so that is basically true in the context of functiond defintion, i understand pattern matching can be used in contexts where a lambda expression wouldnt fit
23:48:18 <c_wraith> mycroftiv: or pattern matching can be used in a lambda.  they're orthogonal
23:48:44 <c_wraith> > (\(x, y) -> x + y) (2, 8)
23:48:46 <lambdabot>  10
23:48:57 <c_wraith> mycroftiv: that's a pattern match in a lambda.
23:49:50 <mycroftiv> yeah, im just trying to make sure that the basic insight that if you have a function foo a b c = whatever that could be written foo = \a b c ->
23:50:07 <c_wraith> yes, but it's better to talk about that as "syntactic arguments"
23:50:19 <c_wraith> pattern matching implies there's a pattern being destructured most of the time.
23:50:41 <mycroftiv> wait syntactic arguments arent an example of pattern matching?
23:51:16 <mycroftiv> or just not a very interesting example unless you are doing more than just binding variable names?
23:51:29 <c_wraith> That's not how you'd usually describe pattern matching.  Pattern matching usually requires...  *matching*
23:51:56 <c_wraith> that's what makes it different than just having arguments.
23:52:05 <mycroftiv> i thought when typed addthis 2 3 and then it went to addthis a b =  that it had 'matched the pattern' of my input
23:52:51 <c_wraith> :t let addthis a b = a + b in addthis 5
23:52:53 <lambdabot> Num a => a -> a
23:53:41 <c_wraith> Still means something, even though there was only one argument provided to something that has two syntactic parameters.
23:54:30 <mycroftiv> isnt that 'just' currying?
23:54:52 <c_wraith> mycroftiv: I'm not disagreeing with your core realization.  Just your terminology.  Your core realization is right.  Except for some tiny details about how ghc handles optimization, syntactic parameters are sugar for lambdas.
23:55:08 <mycroftiv> yeah i understand you are helping me with the vocabulary, i appreciate it
23:55:29 <c_wraith> Oh, there are some other cases....
23:55:30 <mycroftiv> so we have syntactic arguments which may or may not involve a pattern matching construction, which would occupy the 
23:55:35 <mycroftiv> 'same place' in the syntax
23:55:53 <c_wraith> :t let f (Just x) = x ; f = 0 in f
23:55:56 <lambdabot> error:
23:55:56 <lambdabot>     ‚Ä¢ Equations for ‚Äòf‚Äô have different numbers of arguments
23:55:56 <lambdabot>         <interactive>:1:5-18
23:56:07 <c_wraith> there are some other restrictions when using syntactic parameters.
23:56:24 <c_wraith> oops, even if I fixed the implementation. :)
23:56:31 <c_wraith> :t let f (Just x) = x ; f = \_ -> 0 in f
23:56:32 <lambdabot> error:
23:56:32 <lambdabot>     ‚Ä¢ Equations for ‚Äòf‚Äô have different numbers of arguments
23:56:32 <lambdabot>         <interactive>:1:5-18
23:57:14 <c_wraith> that's just a haskell rule with no deep logic.  Just an assumption that if multiple equations have different numbers of arguments, you probably didn't mean to do that.
23:59:54 <mycroftiv> thanks for the clarifications, im putting a lot of time into learning haskell and its amazingly rewarding but im having a hard time feeling like im solid on the basics, maybe because there are often a lot of different syntactic constructs that are equivalent
