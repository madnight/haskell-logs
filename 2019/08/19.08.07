00:00:08 <ski>   instance Category StrangePath where id = Id; q . Id = q; q . ComposeLiftEndo e p = ComposeLiftEndo e (q . p); q . ComposeLift f p = ComposeLift f (q . p)
00:00:16 <ski> @type frob1
00:00:20 <lambdabot> T012 -> T012
00:00:21 <ski> @type frob2
00:00:26 <lambdabot> T012 -> T012
00:00:27 <Cale> oh, wait, that doesn't work, because the passes may not be composable
00:00:27 <ski> @type frob3
00:00:30 <ski> @type frob4
00:00:32 <lambdabot> T012 -> T34
00:00:36 <lambdabot> T34 -> T34
00:00:42 <ski> @type foof
00:00:46 <lambdabot> StrangePath T012 T012
00:00:47 <ski> @type barf
00:00:51 <lambdabot> StrangePath T012 T34
00:00:51 <ski> @type bazf
00:00:55 <Cale> flebron: We have two passes both of which go from a to b, and so we can't just compose them. What do you want to do?
00:00:58 <lambdabot> StrangePath T012 T34
00:01:15 <ski> (it's just list concatenation)
00:01:22 <jackdk> the type of (.) will fail to match, no?
00:01:46 <flebron> Cale: Do we? Won't the (.) only get applied to (Pass b c) . (Pass a b)? So I don't have to worry about that case you mention.
00:02:32 <Cale> Oh, I see, ski figured out a thing we can do :D
00:02:43 <jackdk> flebron: consider: `data Phase a b = Phase (a -> a) (a -> b)`. This should have a sensible Category instance (as well as Functor,Applicative,Monad)
00:03:00 <flebron> ski: Where are the foof and frob and stuff coming from? What are their defns? O.o
00:03:21 <ski> (if you want to, i could give the source of `foof',`barf',`bazf', and perhaps also `frob1',`frob2',`frob3',`frob4', if you wonder)
00:03:50 <ski>   foof :: StrangePath T012 T012; foof = (ComposeLiftEndo frob1 . ComposeLiftEndo frob2) Id; barf :: StrangePath T012 T34; barf = (ComposeLift frob3 . ComposeLiftEndo frob4) Id; bazf :: StrangePath T012 T34; bazf = (ComposeLiftEndo frob1 . ComposeLiftEndo frob2 . ComposeLift frob3 . ComposeLiftEndo frob4) Id
00:03:51 <jackdk> then to chain phases do your GADT-swizzling, which is going to be some kind of type-aligned-sequence thing, which should also have a category instance
00:03:51 <flebron> Oh did you send a privmsg to lambdabot and it remembers those?
00:04:01 <ski>   frob1 :: T012 -> T012; frob1 = id; frob2 :: T012 -> T012; frob2 = id; frob3 :: T012 -> T34; frob3 = MkT34; frob4 :: T34 -> T34; frob4 = id
00:04:25 <ski>   data T012; data T34 = MkT34 T012
00:04:38 <ski> flebron : yes
00:14:40 <flebron> :D That works. Thanks folks!
00:26:58 <aditya> hi
00:54:13 <trcc> I have an issue with Scotty and CORS. I am using simpleCors from wai. When I send a request from javascript I get: "Access to XMLHttpRequest at 'http://localhost:3000/FMIChecker' from origin 'http://localhost:8000' has been blocked by CORS policy: Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource" Scotty source is here: https://githu
00:54:13 <trcc> b.com/CThuleHansen/HsBeFMI/blob/master/src/Lib.hs Any ideas?
00:54:36 <trcc> https://github.com/CThuleHansen/HsBeFMI/blob/master/src/Lib.hs 
00:57:24 <merijn> trcc: Well, presumably you'd need to add a "Access-Control-Allow-Origin" header from whatever application is making the request? :p
00:58:01 <trcc> It seems to be a server thing
00:58:05 <trcc> not a frontend thing
00:58:10 <trcc> as far as I can understand it
01:01:43 <trcc> Found this: https://stackoverflow.com/questions/41399055/haskell-yesod-cors-problems-with-browsers-options-requests-when-doing-post-req/56256513#56256513 fixed it
01:08:25 <dminuoso> trcc: That is wildly dangerous and silly.
01:08:42 <trcc> dminuoso: enlighten me please :)
01:09:48 <dminuoso> trcc: In simple terms, a web browser is required to constrain a page in certain ways. Through various tags and scripts you may not make web requests towards any server that is, essentially, not the exact web page the page is loaded from.
01:10:33 <dminuoso> trcc: This is called the single origin policy. CORS is a mechanism by which the server hosting the page can *relax* those constraints. The server can tell the browser "Look, you may send requests to other origins too"
01:11:03 <dminuoso> trcc: If you do this, you should be explicit about which origins those are. The snippet you are using is basically a blanket "allow it for all hosts" because it sets corsOrigins = Nothing
01:11:23 <trcc> ahh ok. So I should clarify which others hosts it can make requests to
01:11:26 <dminuoso> Yes.
01:11:51 <dminuoso> trcc: Note that the corsOrigins is implicit set by the "simpleCorsResourcePolicy"
01:11:54 <merijn> dminuoso: You should probably comment/edit that answer to point that out :)
01:13:55 <trcc> Thank you very much
01:14:52 <dminuoso> merijn: Arguably wai-cors should be fixed too.
01:15:06 <dminuoso> Having such a default is not the brightest idea..
01:15:12 <merijn> dminuoso: You know what to do!
01:15:17 <dminuoso> Yeah. :(
01:16:13 <merijn> dminuoso: Be the change you want to see in the world! :D
01:32:07 <maerwald> hey boys
01:32:28 <maerwald> why is ghc-8.8 dragging so long
01:32:56 <maerwald> SPJ spending more time with his family? :P
01:36:49 <jgt> I sure hope so
01:37:01 <jgt> that man is the reason I don't hate my job
01:39:44 <mxf> Hi *, is there any trick to add a Functor constraint to an associated type family, eg: `class (Functor AssocTy) => Foo a where type AssocTy a; …`?
01:40:20 <mxf> I tried using data families, but ghc errors out when I try to derive Functor in my instances.
01:41:08 <mxf> I could of course use fundeps/mptc, I think, but I'd prefer the cleaner interface of an associated type, if possible
01:42:01 <Taneb> mxf: does "class Functor (AssocTy a) => Foo a where type AssocTy a" work?
01:53:58 <dminuoso> Taneb: That wouldn't kind check.
01:54:01 <mxf> Taneb, sort of. I would have to write function signatures like: `foo :: a -> AssocTy x a -> a` (not sure about the ordering of the type variables), because it would have a different kind. I'm also not sure how to construct such a value.
01:54:42 <mxf> Is my thinking correct?
01:55:08 <dminuoso> Oh well, I guess it wouldnt on just an empty class
01:55:14 <dminuoso> % class Functor (AssocTy a) => Foo (a :: * -> *) where type (AssocTy a) :: (* -> *);
01:55:14 <yahb> dminuoso: 
01:59:06 <maerwald> hoogle down?
02:00:10 <Taneb> maerwald: the one on Haskell.org seems to be.
02:00:26 <plakband> It's back up for me
02:00:35 <Taneb> Same here
02:00:48 <dminuoso> % class Copointed (AssocTy a) => Foo a where type (AssocTy a) :: (* -> *); extract :: Proxy x -> AssocTy x a -> a
02:00:49 <yahb> dminuoso: 
02:00:53 <dminuoso> % instance Foo Int where type AssocTy Int = NonEmpty; extract _ = copoint
02:00:54 <yahb> dminuoso: ; <interactive>:287:65: error:; * No instance for (Copointed (AssocTy x)) arising from a use of `copoint'; * In the expression: copoint; In an equation for `extract': extract _ = copoint; In the instance declaration for `Foo Int'
02:00:57 <dminuoso> Taneb: ^- mmm
02:01:16 <dminuoso> Ohh.
02:02:23 <dminuoso> % class Copointed (AssocTy a) => Foo a where type (AssocTy a) :: (* -> *); extract :: Proxy a -> AssocTy a x -> x
02:02:23 <yahb> dminuoso: 
02:02:30 <dminuoso> % instance Foo Int where type AssocTy Int = NonEmpty; extract _ = copoint
02:02:30 <yahb> dminuoso: 
02:02:36 <dminuoso> Flipped the type variables around there without noticing. :)
02:05:52 <mxf> dminuoso, hmmm, how does this work? Is `Proxy a` a witness for my instance of the constraint? I'm not sure I get how this works.
02:06:43 <merijn> mxf: Without the proxy how would it infer which instance to use?
02:07:29 <mxf> (also I didn't know you could put parenthesis around `type (AssocTy a) :: …`)
02:08:42 * ski isn't sure why those brackets were added, either
02:08:45 <mxf> merijn, ah, ok, so my thinking was on the right track, I guess.
02:12:56 <mxf> well… I think that doesn't lead to a less noisy API, unless there's another way to get rid of Proxy's and the additional type variable in AssocTy.
02:13:28 <mxf> I guess I'll just try to implement it in terms of mptc and fundeps
02:13:41 <mxf> thanks folks :)
02:14:22 <dminuoso> ski: I wasnt sure about precedence. :)
02:15:20 <dminuoso> mxf: You could also use an injective type family.
02:15:21 <mxf> I'm still unclear why I can't derive data family instances in instances of my type class
02:15:33 <dminuoso> (That way you wont need MPTC with fundeps)
02:15:43 <dminuoso> Or proxy
02:16:03 <mxf> eh, derive eg. Functor for data fam instances, I mean
02:17:19 <mxf> dminuoso, I don't think I'm familiar with injective type families, thanks, I'll have a look at them.
02:19:10 <dminuoso> % :set -XTypeFamilyDependencies
02:19:11 <yahb> dminuoso: 
02:19:14 <dminuoso> % class Copointed (AssocTy a) => Foo a where type AssocTy a = (t :: * -> *) | t -> a ; extract :: AssocTy a x -> x
02:19:15 <yahb> dminuoso: 
02:19:18 <dminuoso> mxf: ^- this
02:19:38 <dminuoso> Think of it like fundeps except the other way around. :)
02:20:17 <mxf> well, the only reason I didn't go with MPTC and fundeps was mainly asthetics and not having used assoc types before. Are there any real problems with using fundeps?
02:20:55 <dminuoso> mxf: For your case MPTC with fundeps and injective associated type families should be the same.
02:21:19 <dminuoso> mxf: Unless you want that associated type family in other places of course.
02:21:46 <dminuoso> Without knowing how this is going to be used its hard to tell though.
02:23:41 <mxf> oooh, ok. hmmm. I guess you can't get rid of the multiple params in AssocTy (say via a type synonym or similar)
02:24:15 <dminuoso> mxf: AssocTy doesnt have multiple params? It has just one.
02:24:55 <mxf> dminuoso, it's basically just a container like type class, where I want to choose a single container for a specific element type.
02:26:30 <dminuoso> mxf: Fundeps and injectivity serve the same purpose, where as knowing one thing lets you determine the other side - they just operate in the opposite direction. :)
02:26:35 <mxf> In the type signatures of for example `extract` I'd have to use `AssocTy a x` instead of the more "logical" `AssocTy a`
02:27:11 <mxf> dminuoso, ah, thanks for clarifying that for me. :)
02:27:12 <dminuoso> mxf: You can write "(AssocTy a) x" if that makes more sense to you.
02:27:59 * ski . o O ( `AssocTy a ~> Identity' )
02:29:14 <dminuoso> mxf: Concretely, if T was marked injective, and we know that "T Int = Float", and we somewhere observe "T x" and we know that this is going to be "Float", the type checker can infer that "x ~ Int" (and enforce this)
02:30:31 <dminuoso> Imagine if you used "extract" from above. If you used it on a NonEmpty, it would infer that the "instance Foo Int" *must* be the correct one.
02:31:08 <dminuoso> It couldnt be any other instance, since no other instance could have AssocTy produce NonEmpty (as that would violate injectivity)
02:31:23 <dminuoso> So it'd let us avoid the Proxy.
02:31:36 <dminuoso> (Or type applications, or mptc+fundeps)
02:35:03 <dminuoso> Question, Why would `ghcid -c "cabal new-repl" --color=always` not pick up modifications to my source code?
02:35:19 <dminuoso> `cabal new-build` picks them up as it should
02:38:46 <mxf> dminuoso, thanks a lot, that was very helpful.
02:39:35 <merijn> dminuoso: I think new-repl only loads a single component, because of restrictions in ghci, so it only detects changes in that component
02:40:54 <mxf> So, to reiterate… my simple "solution" doesn't work, because the type checker tries to solve the constraint for the type class itself and for the code to work, it would have to defer the solving while type checking the instance?
02:41:07 <dminuoso> merijn: Ah spot on. :)
02:41:16 <mxf> which ghc doesn't support
03:45:19 <elcid> @pl transformPicture ps = [ concatMap printHelp p | p <- ps]
03:45:20 <lambdabot> transformPicture = return . (((printHelp =<< p) | p) <-)
03:46:13 <Taneb> elcid: (>>= concatMap printHelp) I think
03:46:32 <Taneb> It seems the list comprehension confused pl
03:47:39 <elcid> let me try, thanks
03:48:38 <Taneb> Equivalently, concatMap (concatMap printHelp)
03:51:43 <ClaudiusMaximus> :t let printHelp p = [] in \ps -> [ concatMap printHelp p | p <- ps ]
03:51:47 <lambdabot> Foldable t => [t p] -> [[b]]
03:52:43 <ClaudiusMaximus> :t let printHelp p = [] in map (concatMap printHelp)
03:52:45 <lambdabot> Foldable t => [t p] -> [[b]]
04:08:28 <elcid> I got it : map $ concatMap printHelp
04:13:11 <ski> @type concatMap
04:13:15 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
04:13:17 <ski> @type concatMap . concatMap
04:13:19 <lambdabot> (Foldable t1, Foldable t2) => (a -> [b]) -> t1 (t2 a) -> [b]
04:13:35 <ski> @type map . concatMap
04:13:38 <lambdabot> Foldable t => (a -> [b]) -> [t a] -> [[b]]
04:19:14 <dminuoso> Taneb: Mmm, is there some typeclass that witnesses the composition of two monads be a monad?
04:19:49 <Taneb> Not as far as I know
04:20:03 <merijn> dminuoso: MonadTrans?
04:20:34 <dminuoso> merijn: Mmm I have something different in mind.
04:20:35 <merijn> Or you mean "(Monad m, Monad n) => Monad (Compose m n)"?
04:20:39 <dminuoso> merijn: That yes.
04:20:47 <fendor> how can I obtain coverage statistics in a cabal package?
04:20:47 <Taneb> I believe it's always the case that Monad m => Monad (Compose m m)
04:21:05 <fendor> oh right, hpc, correct?
04:21:09 <merijn> dminuoso: How would you define that?
04:22:30 <Taneb> With class Commutes m n where commute :: n (m a) -> m (n a), I think you can do (Monad m, Monad n, Commutes m n) => Monad (Compose m n)
04:23:05 <merijn> dminuoso: I assume you've already looked in mmorph?
04:25:03 <dminuoso> merijn: Ah yes. That's it.
04:25:59 <dminuoso> instance (MFunctor f, MonadTrans f, MonadTrans g) => MonadTrans (ComposeT f g) where lift = ComposeT . hoist lift . lift
04:26:01 <dminuoso> This looks about right
04:27:10 <dminuoso> Taneb: That's interesting. If that were true, there should be an instance in base, shouldn't it?
04:27:35 <dminuoso> wrt "I believe it's always the case that Monad m => Monad (Compose m m)"
04:28:20 <merijn> Is that a Monad, though?
04:28:27 <merijn> I'm not convinced that's obvious
04:29:43 <dminuoso> merijn: There's at least one trivial and silly version of it..
04:30:33 <merijn> dminuoso: Which is?
04:33:32 <dminuoso> merijn: `join = fmap join . join; pure = pure . pure` (?)
04:35:52 <merijn> hmm, I'd have to think on the join bit
04:38:25 <fendor> alright, still require help, cabal v2-test --enable-coverage stops with an error. is that not right?
04:39:22 <dminuoso> merijn: Okay Im going to sink some thoughts myself. Proving that it satisfies any of the constructions in http://web.cecs.pdx.edu/~mpj/pubs/RR-1004.pdf should be enough I think.
04:39:44 <merijn> fendor: That would depend on what the error is, no?
04:40:07 <merijn> dminuoso: I mean, the fact that it's not immediately obvious to me that "it's obvious" suggest that it is, in fact, not obvious ;)
04:40:07 <dminuoso> Oh heh. The paper actually disproves it already.,
04:40:23 <dminuoso> Taneb: ^- the paper above argues that List cannot be composed with itself.
04:40:46 <dminuoso> (Which is enough to show that a generic `instance Monad m => Monad (Compose m m)` cant exist
04:40:56 <dminuoso> And it covers composing a monad with itself.
04:41:17 <fendor> right, error when trying to create coverage statistics: https://pastebin.com/DB08vq1f
04:41:52 <merijn> fendor: Well, that seems fairly self-explanatory?
04:42:21 <merijn> fendor: What happens if you remove the "test:tests" part of the command?
04:42:42 <fendor> merijn, then I just dont get it. Same error.
04:44:33 <merijn> fendor: Are you using internal libraries?
04:45:49 <fendor> merijn, possibly? it is not my project, but hsimport, but there is a entry `library library-internal`: https://github.com/dan-t/hsimport/blob/master/hsimport.cabal
04:46:18 <merijn> fendor: Right, so that can't work (at least not now)
04:47:31 <fendor> library library-internal is some magic to let cabal know that nobody can access this? So, I can never get program coverage if I directly depend on an internal library, or what?
04:48:33 <merijn> I wouldn't call it magic
04:48:51 <fendor> but built-in behaviour?
04:49:13 <merijn> Previously the cabal spec only allowed for a single library per package, the current spec allows for multiple internal libraries
04:50:06 <merijn> It's just that uses (as the error says) "per component builds" and apparently no one got around to adding support for coverage to those
04:50:27 <fendor> alright, but why cant I obtain coverage for an internal library?
04:50:39 <fendor> oh, so, no reason, someone just has to do it?
04:51:39 <merijn> fendor: per-component builds are new and a different way of building packages and that error says pretty explicitly that coverage doesn't support those. I don't expect there's a fundamental reason it doesn't support those, most likely it's just "no one has needed it badly enough to finish implementing this"
04:53:21 <fendor> merijn, what are per-component builds? the nix-style builds or something newer?
04:55:08 <merijn> fendor: Previously cabal build-plans would always build entire packages (so library + executables, etc.) afaik per-component builds are a way to depend on just PARTS of a package (and they're part of/included in v2-build)
04:57:12 <fendor> merijn, I see. So, there is either already an issue about it or it should probably be opened, right?
04:57:46 <merijn> yeah
04:58:37 <merijn> Although, in all honesty new feature additions are prioritised pretty much 100% based on the principle of "does someone care enough to implement it?"
04:59:42 <fendor> merijn, I dont have a problem with trying to implement it, so... let's see :)
05:00:13 <merijn> fendor: You can ask around in #hackage to see what's missing/what stopped it from being implemented so far
05:02:57 * hackage hasbolt 0.1.3.4 - Haskell driver for Neo4j 3+ (BOLT protocol)  https://hackage.haskell.org/package/hasbolt-0.1.3.4 (zmactep)
05:40:19 <oleks> Hi, is there a convenient way to maintain a list of named elements in Haskell? I would like to refer to both individual elements of the list, and the overall list? Currently, the solution I see is to have my list encoded in a tuple, and to generate a sea of functions for refering to the individual elements of the "tuple".
05:40:49 <oleks> And a function to convert the tuple to a list..
05:43:24 <lortabac> oleks: what do you mean by "list of named elements"? are all the elements of the same type, or are they heterogeneous?
05:43:27 <jollygood2> oleks, does efficiency matter? if so, having two Maps would do
05:43:52 <oleks> lortabac: all have the same type
05:44:14 <lortabac> so, why do you need a tuple?
05:45:37 <oleks> jollygood2: true
05:46:05 <oleks> lortabac: to avoid defining partial functions
05:46:34 <basic> if i have created my own tree datatype(binary) how would i create a endless list over all possible combinations?
05:46:43 <basic> i am ashamed this problem fucks me up
05:46:45 <lortabac> oleks: is the length of the list fixed and known in advance?
05:47:01 <oleks> lortabac: yes
05:47:16 <lortabac> oleks: maybe you can use a record
05:48:04 <oleks> lortabac: how do I convert a record to a list? but yes, its prettier than the tuple approach
05:48:24 <lortabac> oleks: if it's not too big, I would do it manually
05:48:58 <lortabac> lortabac: otherwise you can automatize the conversion with Generic
05:49:02 <lortabac> oleks: ^
05:49:45 <Boomerang> Hi! I have more issues with doctest today. I have a cabal test-suite with doctest setup. If I run it, it take 6mins. If instead I do cabal new-repl test:doctest and then run main. It runs in 8 seconds.
05:50:14 <oleks> lortabac: that sounds fun - how?
05:50:16 <Boomerang> Any idea how I should go about making the cabal new-test way of running it faster?
05:50:22 <dminuoso> In sqlite-simple, can I reuse the same Connection across multiple threads or do I have create a new connection for each thread?
05:52:19 <lortabac> oleks: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.12.0.0/GHC-Generics.html
05:53:16 <lortabac> oleks: Generics are great but a little hard to learn
05:53:23 <oleks> lortabac: alright, I'll look into it
05:53:25 <oleks> thanks
05:53:43 <dminuoso> oleks: Write a Foldable instance for it?
05:54:09 <dminuoso> Or do I misunderstand your issue?
05:56:15 <lortabac> dminuoso: it depends if they need the labels too
05:57:06 <lortabac> if they only need the elements, Foldable is the easiest solution. The instance can be generated automatically with DeriveFoldable
05:57:47 <absence> "bitraverse id pure . (first f1 <=< first f2)" looks like some kind of pattern/structure, but does it have a name or look like anything existing?
05:57:55 <__monty__> Boomerang: How long does compiling the testsuite take?
05:58:01 <jprider63> Hi. I'm trying to use Safe haskell, but my library depends on fgl. Is there a way to mark fgl and it's modules as trusted? 
05:58:56 <Boomerang> __monty__ not very long, it has few dependencies. I can open the repl in a matter of seconds
05:59:15 <__monty__> Boomerang: The repl interprets, it doesn't compile.
06:00:28 <Boomerang> time cabal new-build test:doctest takes 1.7 seconds
06:00:36 <Boomerang> Or is that not enough?
06:01:08 <__monty__> Boomerang: It's not if it was already built.
06:01:57 <__monty__> Thought it'd be strange if cabal new-test always takes lon.
06:01:58 <Boomerang> 5.4 seconds after a cabal new-clean
06:02:24 <__monty__> Hmm, I can't explain the big discrepancy.
06:02:54 <Boomerang> The modules containing tests use ghc plugins, so maybe that influences it?
06:03:17 <Boomerang> (I saw an earlier version of doctest was struggling with those)
06:03:31 <Boomerang> But I don't understand why cabal being in the way makes it slower
06:04:01 <Boomerang> Does `cabal new-test` need to rebuild the library too?
06:04:13 <__monty__> If it changed.
06:04:14 <dcoutts> It has to check the testsuite executable is up to date.
06:04:49 <__monty__> dcoutts: Yeah but 6mins v. 8s?
06:05:14 <dcoutts> Oh, that's a lot. Are you sure it's not actually building it?
06:05:48 <dcoutts> If you "cabal new-build the-testsuite" first then you can distinguish the time to build vs time to run
06:05:49 <Boomerang> It's difficult to tell. I might try with some verbose flags on
06:06:12 <Boomerang> Oh the new-build test:doctest is pretty quick!
06:11:27 * hackage hakyll-images 0.4.4 - Hakyll utilities to work with images  https://hackage.haskell.org/package/hakyll-images-0.4.4 (LaurentRDC)
06:13:27 * hackage postgresql-binary 0.12.1.3 - Encoders and decoders for the PostgreSQL's binary format  https://hackage.haskell.org/package/postgresql-binary-0.12.1.3 (NikitaVolkov)
06:16:53 <kuribas> can you run a webserver in ghci in the background, and inspect the runtime data in ghci?
06:17:11 <dminuoso> kuribas: In principle, yes.
06:17:26 <kuribas> dminuoso: how would that work, run the webserver in a background thread?
06:17:35 <dminuoso> kuribas: Sure. Just run it in async.
06:18:16 <dminuoso> kuribas: Sharing data could happen via shared memory regions (perhaps synchronized via STM)
06:19:02 <kuribas> dminuoso: well, in our case everything is in the DB, so it's stateless...
06:19:12 <dminuoso> kuribas: What exactly do you want to inspect?
06:19:17 <kuribas> but it could be handy to see errors on standard output
06:19:38 <dminuoso> This might sound silly but.. log them to stdout then?
06:19:50 <kuribas> sure, that would work
06:20:18 <kuribas> it's also nice to see which functions are called
06:20:31 <kuribas> then in the repl experiment
06:20:40 <kuribas> to see where it went wrong
06:21:05 <dminuoso> kuribas: Add more logging functions - and have some mechanism to talk about log levels such that you can disable debugging output for production builds?
06:21:29 <kuribas> dminuoso: in clojure we current can turn on trace for any function, without having to add boilerplate to every function.
06:21:55 <kuribas> http logging can be done on wai level of course
06:22:21 <dminuoso> kuribas: Well ghci comes with a full fleged debugger..
06:22:28 <dminuoso> It can do tracing too..
06:22:47 <kuribas> it can?
06:22:57 <dminuoso> Well yeah. Its just different then what you might expect.
06:23:14 <dminuoso> kuribas: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#ghci-debugger
06:23:20 <kuribas> dminuoso: the last time I tried the ghci debugger I found it underwhelming and even painful.
06:24:24 <kuribas> dminuoso: oh, tracing means something else in clojure.  It means writing the inputs and outputs to standard error.
06:25:25 <kuribas> dminuoso: even on a running production system
06:26:01 <dminuoso> Yeah Haskell doesn't have that.
06:26:05 <dminuoso> Or GHC rather.
06:27:49 <merijn> @quote stream.of.conciousness
06:27:49 <lambdabot> No quotes match. My brain just exploded
06:27:51 <merijn> aww
06:28:06 <merijn> @quote cmccann stream.of
06:28:06 <lambdabot> cmccann says: you want a debugger? GHC has one. Except that stepping through lazy evaluation is like listening to a stream of consciousness narrative told by a 5-year-old with ADHD.
06:28:44 <dminuoso> Honestly I find that quote mildly offensive.
06:28:57 <kuribas> merijn: what I would like in a debugger is the ability to choose what to evaluate
06:29:17 <Inari-> Hi. Is asking something about haskell related projects (in this case haskell-ide-engine) on-topic here?
06:29:23 <dminuoso> lambdabot: Absolutely, yes.
06:29:28 <dminuoso> Inari-: ^- :)
06:29:30 <kuribas> merijn: not imperative-style stepping through
06:30:16 <merijn> I think HIE also has a dedicated channel, so that may (or may not) have better odds at getting a useful response 
06:30:20 <dminuoso> Inari-: We're really not strict about what you discussin here, we sometimes even discuss math, other languages, linux.. if it strays too far off, you might just get asked to carry on in #haskell-offtopic :)
06:30:45 <Inari-> So trying to learn Haskell some more. And the best sounding VSCode extension I've seen seems to use that project. However kind of stuck with using it. I've followed the instructions (clone it, then run stack ./install.hs build-all). And it's been sort of building for over 2 hours now, often seemingly giving me the same lines I've already seen. Wondered if anyone else had that kinda issue with it. 
06:30:49 <Inari-> Maybe I'll open a ticket on the tracker though
06:31:25 <kuribas> merijn: I don't care about in which order ghci evaluates stuff, I care about how it gets to the result.
06:31:30 <dminuoso> Inari-: If you are new to Haskell I recommend you stick to a simple editor you already enjoy - and then use ghcid alongside.
06:31:39 <merijn> Inari-: I've heard that before, but I don't know how/if people solved it
06:31:41 <kuribas> merijn: IMO that makes the ghci debugger useless
06:32:05 <Inari-> dminuoso: Maybe, just would find it useful to get linting stuff and such directly in the editor
06:32:12 <dminuoso> Inari-: Hence ghcid.
06:32:47 <dminuoso> Inari-: ghcid is a miniature wrapper around ghci that continously compiles your code as files get modified and instantly gives you errors with coloring. :)
06:32:54 <Inari-> Ah, I see
06:34:05 <Inari-> What I also hoped the language server would give me is e.g. I'd write "import Data." and it opens a list of modules under Data to choose from
06:34:24 <dminuoso> Inari-: The point is not that I want to sell you ghcid, but I want to give you a low effort option such that you can get into writing code faster, instead of trying to set up your environment. 
06:35:02 <Boomerang> __monty__ dcoutts I got my doctest cabal run down to 17 seconds by adding -dynamic to ghc-options. :D
06:35:35 <Inari-> dminuoso: Sure, just wondering about such options :D
06:37:23 <dminuoso> Inari-: I personally have given up trying the options. The tooling landscape in Haskell is particularly bad - though for what its worth haskell-ide-engine is, from what I hear, currently the "best option" that has your requested features.
06:39:15 <dminuoso> Inari-: If you are an emacs user, you can trivially use ghcid in conjunction with compilation mode by the way. That way you get clickable error locations. :)
06:39:44 <Inari-> dminuoso: A VSCode user haha
06:40:08 <Inari-> Thanks for the help, will try with ghcid for now, can at least start trying around more with that haha
06:40:23 <Inari-> Maybe the issue is because I've installed stack with scoop
06:40:43 <dminuoso> Inari-: Oh you are on Windows?
06:41:17 <dminuoso> Inari-: At any rate, for ide questions - like merijn said - you might want to try #haskell-ide-engine - until then you can use ghcid. :)
06:41:41 <Inari-> Yeah, didn't even know they had a channel before.
06:41:52 <Inari-> And yes, Windows
06:42:25 <dminuoso> Inari-: It shouldnt matter how you installed stack, really.
06:43:37 <dminuoso> Inari-: I wonder whether windows has the same problem as the arch package, which builds ide for every GHC version.....
06:43:53 <Inari-> Haha, that'd explain why I seemingly saw the same stuff so often
06:44:26 <dminuoso> And by *ide I meant *hie
07:38:34 <merijn> Does anyone know if there's a way to make GHC be less verbose about reporting the context of a type error if said context is a multi-line expression/binding?
07:44:38 <kuribas> merijn: that's something that should be cleaned up
07:45:16 <merijn> Right now I get <1 full error in the 55 lines my terminal is high >.>
07:59:22 <fizbin> Can anyone think of a nicer way to write this?  myNodeIndex = fst <$> listToMaybe (filter (finderF . snd) $ zip [(0::Int)..] nodeList)
08:00:19 <fizbin> Basically, "Just index" of the first thing finderF finds, and Nothing if it finds nothing.
08:00:56 <merijn> :t find
08:00:59 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
08:01:09 <merijn> ^^^ like that? ;)
08:01:25 <c_wraith> no, that returns the value.
08:01:40 <merijn> c_wraith: He could still simplify his code using that, but I meant
08:01:45 <merijn> :t findIndex
08:01:47 <lambdabot> (a -> Bool) -> [a] -> Maybe Int
08:03:05 <vaibhavsagar> still salty about the person who came in yesterday, new to both Nix and Haskell, but kept insisting that IHaskell was broken because it wasn't immediately obvious how to use it with home-manager
08:07:46 <fizbin> Ah, findIndex. Thanks, merijn.
08:07:55 <jumper149> Hi I want to create a type with `data Type x = T x` but want to add a constraint to `x`, like for example `data Eq x => Type x = T x`.
08:08:17 <merijn> MonadResource question: Does this make sense? https://paste.debian.net/1094810/
08:08:25 <merijn> jumper149: tbh, you don't want that
08:08:29 <jumper149> When I use DatatypeContexts I can do this
08:08:35 <jumper149> but the compiler tells me its deprecated
08:08:46 <jumper149> merijn: why is that?
08:08:59 <merijn> jumper149: DatatypeContexts was removed in Haskell2010 (It was part of Haskell98) because it's essentially useless
08:09:25 <merijn> jumper149: Because it doesn't do what most people that want to do it hope it does :)
08:09:38 <merijn> jumper149: Lets rewind: Why do you want to do that?
08:10:31 <jumper149> I want `x` to be part of the classes `Eq, Enum`
08:10:42 <merijn> jumper149: Right, but why?
08:11:02 <jumper149> because I will use those classes later on in another class to define some methods
08:11:27 <merijn> jumper149: You can just add those constraints when defining the class/instance, though?
08:11:57 <jumper149> I guess I should put the constraint into that latter class?
08:12:15 <merijn> jumper149: 90% of the times I see someone try to use DatatypeContexts what it boils down to is usually "I don't want to write that class constraint on each function", but you still have to do that when you use that
08:13:09 <jumper149> Ye I think that is what I want from it 
08:13:25 <merijn> jumper149: Suppose you have class Foo and you want to use Eq/Enum together with Type, the usual way to deal with that is: "instance (Eq a, Enum a) => Foo (Type a)" <- i.e. "Type a is an instance of Foo IF and only IF 'a' is an instance of Eq/Enum"
08:14:36 <merijn> jumper149: The constraint on the datatype *only* restricts what you can put "inside" Type, it does *not* let GHC see that the thing inside Type has those classes (GHC needs to get the instance from somewhere), so you still need an Eq/Show constraint on any function that takes a Type as argument :)
08:15:08 <jumper149> merijn: Alright thank you
08:19:46 <merijn> hmm, monad-logger doesn't have a way to extract the logging function, does it?
08:21:49 <c_wraith> merijn, the MonadLoggerIO class appears to do that.
08:23:41 <merijn> Ah, I can probably cobble something together on top of that
09:09:51 <Boarders> if I had a linked list of Ints, then roughly how large would it have to be to take up over 1MB in memory?
09:10:16 <Boarders> just the Ints themselves should be something like 9 bytes for a header and payload I'm not sure beyond that
09:16:57 <dminuoso> Boarders: Depends on how that linked list is made.
09:17:15 <dminuoso> Boarders: Are you using raw pointers? Or are you talking about [Int] ?
09:30:51 <wroathe> So I've got a huge AST data structure, and I'm going to write a routine to pretty print it... When is it appropriate to hijack Show for pretty printing?
09:31:22 <wroathe> Or should this have nothing to do with the semantics of Show?
09:31:53 <dminuoso> wroathe: When you just want it for debugging purposes I'd say.
09:32:23 <dminuoso> wroathe: I use pretty-simple ontop of Show for such cases fairly often. If however a user of my software expects to see output, then it gets some custom ppr function.
09:32:41 <[exa]> wroathe: Show stuff should be Read-able back, and look like source code in general
09:32:54 <dminuoso> [exa]: "should" in what sense?
09:33:29 <wroathe> Ah, so I'm basically shooting myself in the foot then
09:33:37 <dminuoso> wroathe: Not really.
09:33:55 <wroathe> Because I've already parsed the source file into this AST, it would be silly to pretty print it only to have to turn around and write another parser in Read
09:34:04 <[exa]> I've been told several times that Show instances should work in the way that read.show would work like identity
09:34:26 <dminuoso> [exa]: That's probably a long urban myth generated from the Haskell report mandating this for deriving generated instances.
09:34:58 <[exa]> well I can certainly say I have quite a bit of Show instances that are not even close
09:35:40 <[exa]> but generally I thought that practice is widely frowned upon
09:36:15 <dminuoso> [exa]: Perhaps bringing it up in -cafe would be an interesting discussion. Im of the perspective that there should not be any such restriction.
09:36:27 <dminuoso> There's far too many libraries not doing this, so relying on it is a bad idea.
09:36:51 <[exa]> good to know, thanks
09:37:03 <dminuoso> And the reason why I assume people say this is merely because again the Haskell report demands implementations do this for deriving generated instances. I dont think there's any good or valid reason to expect show.read = id
09:37:27 <dminuoso> (for non-deriving generated instances that is)
09:38:01 <wroathe> Maybe Show should have an optional method, pretty
09:38:04 <dminuoso> Even more so since there doesnt really exist canonical libraries that make use of such an assumption.
09:38:06 <wroathe> for just this purpose
09:38:12 <dminuoso> wroathe: Id say show is exactly that
09:38:59 <dminuoso> And if you do have multiple representations, you could newtype it.
09:39:12 <wroathe> I think really the debate is whether or not show/read should behave like a toString/fromString pair
09:39:16 <dminuoso> Though arguably you are better off with some Pretty class that uses Text rather.
09:39:36 <dminuoso> wroathe: What do you mean? they are just that.
09:40:04 <wroathe> When I see toString/fromString in any language I make the assumption that toString . fromString = id
09:40:07 <wroathe> Just semantically
09:40:15 <wroathe> and it sounds like show/read don't have any such semantics defined
09:40:36 <dminuoso> wroathe: We could also take guidance from the haddock documentation in base: https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Show
09:40:46 <dminuoso> You will find that its not even recommended.
09:40:55 <dminuoso> There's also nothing about "this should produce valid haskell code"
09:41:46 <dminuoso> wroathe: And for some cases it may not even be possible. For example IEEE 754 floating numbers.
09:42:08 <dminuoso> Depending on the choie of representation I mena.
10:18:45 <Philonous> I wonder if the choice for how overloaded lists are handled was intentional. Desugaring [a,b,c] to (a `cons` (b `cons` (c `cons` nil))) and making »cons« and »nil« overloadable would have enabled the syntax to be used with things like e.g. HLists and vinyl-style records 
10:20:00 <Philonous> Maybe even allow cons and nil to be pattern synonyms
10:23:07 <dmwit> Who can explain this to me? https://gist.github.com/dmwit/66b23bf2cd72441bc76e9913c8ee7d16
10:25:21 <infinisil> Philonous: In Idris it works like that I think
10:25:48 <infinisil> Philonous: For any type that defines a `Nil` and `Cons` constructor you can use the `[]` syntax
10:25:57 <infinisil> Iirc
10:27:26 <vaibhavsagar> Philonous: how would this work with Vectors?
10:29:44 <Philonous> vaibhavsagar, Vectors have empty and cons
10:30:14 <geekosaur> dmwit: works here, once I undo some of the hackery I have in place for xmonad
10:30:32 <Philonous> vaibhavsagar, And the obvious performance problems should be easily solvable with rewrite rules 
10:30:44 <aoeu256> you can use [1, 2, 3] syntax yfor vectors?
10:31:00 <geekosaur> you might verify the expected ghci is being used; shell hashing/caching can cause surprises
10:31:06 <vaibhavsagar> aoeu256: yes, with OverloadedLists
10:31:12 <Philonous> aoeu256, :set -XOverloadedLists 
10:31:34 <vaibhavsagar> Philonous: you didn't mention this earlier
10:31:43 <vaibhavsagar> also, how would you fix it with a rewrite rule?
10:32:03 <aoeu256> is there a way to use hashtables / assoc lists more conviniently as well?
10:32:29 <Philonous> What did I not mention earlier?
10:32:57 * hackage pandoc-pyplot 2.1.5.0 - A Pandoc filter to include figures generated from Python code blocks  https://hackage.haskell.org/package/pandoc-pyplot-2.1.5.0 (LaurentRDC)
10:33:07 <geekosaur> OverloadedLists just wraps list uses in fromList if an IsList instance is in scope. more or less.
10:33:12 <vaibhavsagar> Philonous: rewrite rules
10:33:24 <vaibhavsagar> aoeu256: Data.Map works with OverloadedLists
10:33:34 <geekosaur> convenient, potentially slower than doing things more directly
10:33:48 <geekosaur> although for many things you'd be doing the fromList anyway
10:34:05 <Philonous> Also, rerite »cons x nil« to »fromList [x]« and »cons x (fromList xs)« to »fromList (x:xs)« and you have the same performance as you do now
10:34:55 <dmwit> geekosaur: which ghci and which ghc-pkg say they're coming from /usr/local/bin, even after a rehash.
10:35:14 <geekosaur> dmwit, hm. it may still be possible to get gnuish stuff to use + for long options (that was the ancient way) which would affect your echo
10:35:18 <dmwit> (And the output I pasted say both are 8.4.2.)
10:35:28 <geekosaur> come to think of it, %... csh? zsh?
10:35:30 <dmwit> It's not the echo.
10:35:37 <geekosaur> ok
10:35:39 <dmwit> I get the same result from typing directly into ghci.
10:36:01 <dmwit> (Just wanted to make sure that for the demo my only input came from lines starting with %.)
10:36:24 <geekosaur> that makes a little more sense, I think. but I olnly reproduced that when I had the wrong ghci vs. ghc-pkg (xmonad rebuild hack; someday I should switch to a build script)
10:37:11 <dmwit> I'm sorry, what do you mean by "that makes more sense"?
10:37:44 <geekosaur> that echo vs. typing does the same thing
10:38:28 <dmwit> Oh, you thought maybe the echo was done to contrast vs typing directly. Ouch, I hadn't considered that confusing implication, sorry.
10:38:40 <geekosaur> also I don't quite trust same version because I can have ghc froom multiple sources including hvr and nix
10:38:47 <geekosaur> right
10:42:27 * hackage units-defs 2.1.0.1 - Definitions for use with the units package  https://hackage.haskell.org/package/units-defs-2.1.0.1 (RichardEisenberg)
10:42:53 <geekosaur> oh, one more suggestion, given the other warning message: ghci -ignore-dot-ghci
10:43:14 <geekosaur> and then look through what said dot-ghci might have lurking other than what got complained about
10:43:58 <geekosaur> (in particular, on the unexpected side: :def for something starting with m...)
10:46:02 <geekosaur> ...I'm wondering why "Prelude" got printed, is why I suggested that; seems like a wrapper for :m that does something unexpected, maybe on the assumption that "import" would be used instead of ":m +"
10:49:09 <dmwit> Good suggestion! It still can't find System.Random  with -ignore-dot-ghci, though.
10:49:48 <Boarders> dminuoso: I was talking about [Int]
10:50:15 <dminuoso> Boarders: How in depth do you want to go?
10:50:31 <Boarders> I just wanted a back of the envelope calculation
10:50:48 <Boarders> it's basically just a benchmark to make sure the list is streamed
10:51:03 <Boarders> and so I want it to be above 1Mb but not needlessly so to make it slow to run
10:51:21 <dminuoso> Boarders: https://wiki.haskell.org/GHC/Memory_Footprint might still be valid.
10:51:26 <geekosaur> if this is zsh, "type ghci". (if csh, "alias -t" iirc; it's been a while. maybe just "alias" and check the tracked aliases). but I'm running out of ideas; most things would affect both ghci and ghc-pkg
10:52:06 <geekosaur> yep, csh wants alias -t
10:53:04 <Boarders> dminuoso: thanks
10:53:15 <geekosaur> ("type" also works for POSIX shells)
10:54:27 <geekosaur> this will show if it's using an alias or shell function, or potentially a different one than you think on $PATH
10:55:19 <dmwit> It's zsh. type and which agree.
11:11:21 <aoeu256> Is there a way to change the GHCI prompt so that it shows you the argument names, types, show which statements group, and maybe test values sort of like lighttable and jupiter notebooks?
11:13:12 <trcc> Hi. I am quite new to web development, and I am working on an Elm frontend with a Haskell backend (Scotty). My question is - what is the approach on serving the front-end pages? Should scotty do this?
11:18:57 <Boarders> What is the difference in the report given by +RTS -s between maximum residency and total memory in use?
11:19:41 <monochrom> "total memory" does not subtract freed memory IIRC
11:20:25 <Boarders> it looks to me like maximum residency misreports the amount if you have a streaming function
11:20:31 <Boarders> or not misreports
11:20:33 <Boarders> sorry
11:20:46 <Boarders> I just mean it looks like it is not the relevant number for maximum total heap usage
11:20:52 <Boarders> but I am wondering what is
11:21:43 <monochrom> Ah, maximum residency is from sampling IIRC.
11:22:17 <off537[m]> Lol...offtopic. but I have installed Alpine Linux in Android chroot :))
11:22:18 <off537[m]> Moving haskell projects to there
11:22:32 <Boarders> what difference does it make with sampling?
11:22:44 <Boarders> is it somehow overcounting from things that might be deallocated?
11:23:31 <vaibhavsagar> aoeu256: have you seen IHaskell? https://github.com/gibiansky/IHaskell
11:24:02 <monochrom> Every time unit you take a look at resident memory amount. This means you are missing out anything interesting at 3.14 time units for example.
11:25:28 * hackage quickcheck-simple 0.1.1.1 - Test properties and default-mains for QuickCheck  https://hackage.haskell.org/package/quickcheck-simple-0.1.1.1 (KeiHibino)
11:26:58 <EvanR> and the faster you sample the slower the program runs, until it turns into quantum zeno effect
11:27:35 <Boarders> ah I see
11:39:44 <infinisil> Hehe, never heard of the quantum zeno effect
11:39:46 <infinisil> Pretty coooool
11:39:57 <infinisil> (whoops, my keyboard repeat is very quick)
12:00:50 <Cale> trcc: If you're not going to use Scotty to serve your frontend, what else would it be doing?
12:01:40 <cocreature> Cale: serve an API?
12:01:48 <Cale> I guess!
12:01:49 <trcc> cocreature: yes exactly
12:02:06 <trcc> but I think it will serve my front-end
12:02:14 <trcc> as well
12:02:19 <Cale> But yeah, you probably just use the same webserver to serve the frontend unless there's a good reason not to
12:02:39 <cocreature> often you can get away with wai-app-static for serving your frontend
12:02:52 <trcc> i'll look that up
12:03:20 <trcc> Thank you both
12:09:38 <monochrom> Wait, so "quantum zeno effect" was not a joke?! Hehe.
12:10:13 * monochrom digs Turing-anything though.
12:13:24 <EvanR> a particle in a box concentrated between x=a and x=b, if you measured (a,b) to see if the particle is there before it spills away, you will probably find it, which causes the little bits outside (a,b) to go away (and its probability returned to (a,b)) rinse repeat
12:15:51 <monochrom> Today I have students taking a deferred exam, and I have to visit them a few times in case they need clarifications.  This is most apt --- if I visit them too many times, it would stall their progress!  TEEHEEHEE
12:16:20 <monochrom> But this one is merely classical, not quantum.
12:20:39 <Cale> monochrom: "I just really want to be sure you're sure you don't need any clarifications..."
12:21:41 <EvanR> i just want to say good luck. We're all counting on you
12:22:08 <iqubic> > (++) "Hello " "World!!"
12:22:12 <lambdabot>  "Hello World!!"
12:22:53 <Cale> "What about question 3? Did you read that one yet? Is it clear? I thought maybe there would be a problem with part (k)... no? It's okay? All right, I'll be back in 30 seconds, gotta check with the other student."
12:22:57 * hackage gothic 0.1.0 - A Haskell Vault KVv2 secret engine client  https://hackage.haskell.org/package/gothic-0.1.0 (MichelBoucey)
12:23:18 <iqubic> > ((+5) . (*10)) 1
12:23:21 <lambdabot>  15
12:27:49 <iqubic> > (((++) "hello") . id . ((++) "world") . (const "")) ""
12:27:55 <lambdabot>  "helloworld"
12:27:57 * hackage galois-field 0.4.0 - Galois field library  https://hackage.haskell.org/package/galois-field-0.4.0 (sdiehl)
12:28:02 <iqubic> HOW DOES THAT WORK?
12:29:35 <Cale> hm?
12:30:10 <iqubic> I don't understand how that code gets the result of "helloworld"
12:30:35 <merijn> iqubic: Work it out by hand? :)
12:30:40 <Cale> Well, first of all, remove the id
12:31:08 <iqubic> It seems like the (++) "world" should be evaluated before the (++) "hello" resulting in "worldhello"
12:31:28 <Cale> (++) "world" is the function which adds world to the beginning of any string it's applied to
12:31:35 <Cale> > (++) "world" "hello"
12:31:40 <lambdabot>  "worldhello"
12:31:44 <boxscapeR> If I do a lookup over a fixed list, like say `fromMaybe someValueD $ lookup stringVar [("ABC", someValueA), ("DEF", someValueB), ("GHI", someValueC)]`, will GHC optimize that to the point where it's simply a case expression?
12:31:54 <EvanR> you wrote a pipeline of 4 functions. they will be "applied" to (rightmost) "" in order from right to left. 
12:32:01 <Cale> iqubic: But what do you mean by "before"
12:32:11 <merijn> hmm, there's no conduit operator for composing "ConduitT a b m r" and "b -> ConduitT b c m r" into "ConduitT a c m r"?
12:32:17 <Cale> (++) "world" is being applied to the result of (const ""), which we know is ""
12:32:24 <Cale> (++) "world" ""
12:32:25 <EvanR> (f . g . h . w) x = f (g (h (w x)))
12:32:30 <Cale> > (++) "world" ""
12:32:34 <lambdabot>  "world"
12:32:35 <merijn> Anyone got suggestions what'd be a good name for an operator like that?
12:32:49 <Cale> and we know that (++) "hello" is being applied to the result of that
12:33:45 <iqubic> I understand how this works now.
12:34:01 <Cale> merijn: Is that roughly "for" from Pipes?
12:34:07 <merijn> Cale: Basically
12:34:13 <iqubic> I'm just trying to understand this little gem of a thing: https://themonadreader.files.wordpress.com/2014/04/fizzbuzz.pdf
12:34:52 <merijn> Cale: There's "awaitForever :: (a -> ConduitT a b m r) -> ConduitT a b m r", but that seems common enough that it'd be cleaner than doing "foo .| awaitForever foo" all the time
12:35:13 <EvanR> iqubic: incidentally wondering what is evaluated first doesn't really help here
12:35:15 <Cale> iqubic: Another thing you ought to be aware of, though it's a little deeper than your confusion was just now is that when you have f (g (h x)), it's f which is evaluated first
12:35:33 <Cale> iqubic: f is applied to the as-yet-unevaluated expression g (h x)
12:35:42 <iqubic> Right. I see.
12:36:17 <iqubic> I was mainly just trying to understand the snippet of code at the bottom of page 7.
12:36:27 <iqubic> Of the fizzbuzz article.
12:36:40 <merijn> That seems like an overly ungeneric solution for one that involves defining a DSL
12:37:59 <geekosaur> iqubic, each production except halt is an incomplete expression
12:38:01 <Cale> merijn: Well, in the end, it's not too bad
12:38:08 <geekosaur> so: print x becomes x ++
12:38:16 <iqubic> merijn: look at what thye wind up with at the end.
12:38:19 <merijn> Cale: I prefer my "World's most general FizzBuzz" version ;)
12:38:21 <merijn> https://gist.github.com/merijn/cd0e7918a96fe913cf7d66833e8da354
12:38:30 <iqubic> merijn: Top of page 9.
12:38:40 <merijn> It's generic in its input, output and predicate :p
12:39:01 <Cale> yeah
12:39:07 <iqubic> What does that actually do?
12:39:27 * hackage type-sets 0.1.0.0 - Type-level sets  https://hackage.haskell.org/package/type-sets-0.1.0.0 (isovector)
12:39:28 <merijn> iqubic: It lets you trivially implement arbitrary fizzbuzzes :p
12:39:42 <merijn> iqubic: You can even try it, that code should run as is :p
12:39:49 <iqubic> But how is it generic?
12:40:18 <iqubic> What is def?
12:40:18 <merijn> iqubic: It lets you define fizzbuzzes that work on any type of input, using any arbitrary binary predicate and producing (almost) any output
12:40:39 <merijn> iqubic: def is the "default" behaviour if no predicate matches
12:40:49 <iqubic> Which in this case is Show.
12:40:54 <merijn> iqubic: Correct
12:41:19 <iqubic> But what do you do for 15?
12:41:22 <merijn> iqubic: Next argument is a binary predicate (division, in classic fizzbuzz), followed by a Foldable container giving the cases
12:41:36 <merijn> iqubic: Try it and see ;)
12:42:02 <iqubic> Why is the conditions a tuple?
12:42:10 <iqubic> like (3, "fizz")?
12:42:44 <merijn> iqubic: If the result of the input, predicate and 3 is true, return "Fizz"
12:43:19 <merijn> iqubic: So for all inputs it tries the predicate against all the values in the Foldable and produces the outputs in that order
12:44:06 <iqubic> How is Maybe a monoid?
12:44:29 <merijn> > Just (Sum 1) <> Just (Sum 3)
12:44:34 <lambdabot>  Just (Sum {getSum = 4})
12:44:36 <iqubic> Is it "Instance (Moniod m) => Monoid (Maybe m) where ..."?
12:44:39 <merijn> > Just (Sum 1) <> Nothing
12:44:44 <lambdabot>  Just (Sum {getSum = 1})
12:44:51 <Cale> It's instance Semigroup m => Monoid (Maybe m)
12:44:51 <merijn> iqubic: "instance Semigroup m => Monoid (Maybe m)" nowadays
12:45:20 <merijn> It's further abusing the best monoid instance ever
12:45:22 <iqubic> Ah. Right. Because you don't actually need an identity for the m.
12:45:36 <merijn> "instance Monoid r => Monoid (a -> r)"
12:45:48 <merijn> <3 that instance
12:46:10 <infinisil> merijn: What's the `b` do in `ConduitT b c m r`?
12:46:18 <infinisil> Oh, I was way back in scrollback
12:46:50 <iqubic> Isn't that just (., id)?
12:47:00 <iqubic> The monoid for (a -> r)?
12:47:13 <iqubic> Or perhaps not.
12:47:14 <merijn> iqubic: No, you're thinking of Endo
12:47:20 <iqubic> Ah.
12:47:24 <merijn> iqubic: "newtype Endo a = Endo (a -> a)"
12:47:29 <iqubic> How does this work?
12:47:35 <merijn> Which is indeed a Monoid with . and id
12:47:43 <merijn> But it's far less useful than that one
12:47:47 <iqubic> How does Monoid (a -> r) work?
12:48:00 <merijn> iqubic: "mappend f g = \x -> mappen (f x) (g x)
12:48:05 <iqubic> Right.
12:48:07 <merijn> Minus typos >.>
12:48:24 <iqubic> Right.
12:48:26 <Philonous> merijn, Your fizzbuzz can be generalized btw :P 
12:48:29 <merijn> iqubic: So all the predicates return "Just" or "Nothing" depending on the predicate match
12:48:35 <iqubic> Right.
12:48:52 <iqubic> But how do you deal with 15, where mulitple predicates match?
12:48:57 <merijn> iqubic: And all the Nothing's disappear, so since 15 is divisible by 3 and 5 you get 'Just "FizzBuzz"' :)
12:49:07 <iqubic> How?
12:49:15 <Cale> > map (\n -> fromMaybe (show n) $ ("fizz" <$ guard (n `mod` 3 == 0)) <> ("buzz" <$ guard (n `mod` 5 == 0))) [1..15]
12:49:16 <merijn> iqubic: The 3 case return Just "Fizz"
12:49:19 <lambdabot>  ["1","2","fizz","4","buzz","fizz","7","8","fizz","buzz","11","fizz","13","14...
12:49:27 <merijn> iqubic: 5 case returns Just "Buzz"
12:49:34 <merijn> :t foldMap
12:49:36 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
12:49:39 <Philonous> merijn, Here's a more general type:  generalisedFizzBuzz :: forall a b f m . (Foldable f, Semigroup m) => (a -> m) -> (b -> a -> Bool) -> f (b, m) -> a -> m
12:50:02 <Philonous> (Code stays the same) 
12:50:10 <iqubic> Does 15 return "fizzbuzz" by using the List monoid to combine the results?
12:50:15 <geekosaur> the Monoid "inherits" (uses) the Monoid of the underlying type which is String. its sappend / mappend is (++)
12:50:16 <Cale> yeah
12:50:23 <geekosaur> and yes, that's list underneath
12:50:31 <merijn> iqubic: "wrap" creates an "a -> Maybe m"
12:50:36 <Cale> (or if we want to be more pedantic, it uses the Semigroup instance for lists)
12:50:47 <geekosaur> hinted at by "sappend" there :)
12:50:56 <merijn> iqubic: foldMap applies wrap to the entire foldable, building a "a -> Maybe m" that mappends all predicate results
12:51:10 <Cale> > (\n -> fromMaybe (show n) $ ("fizz" <$ guard (n `mod` 3 == 0)) <> ("buzz" <$ guard (n `mod` 5 == 0))) 15
12:51:12 <merijn> (Because of the monoid instance of functions mentioned earlier)
12:51:16 <lambdabot>  "fizzbuzz"
12:51:31 <iqubic> And then you use the most awesome Monoid to combine all the (a -> Maybe m) into one value, of type (Maybe m)?
12:51:46 <merijn> iqubic: Well into a value "a -> Maybe m", but yes
12:51:58 <merijn> iqubic: And the beauty is that, if no predicate matched, the entire thing is Nothing
12:52:06 <iqubic> How?
12:52:08 <merijn> So handling the fallback case is trivial via "fromMaybe"
12:52:11 <iqubic> I see.
12:52:14 <merijn> > Nothing <> Nothing
12:52:18 <lambdabot>  Nothing
12:52:33 <merijn> iqubic: If all predicates return Nothing, we just mappend a whole lot of Nothing and get...Nothing
12:52:36 <iqubic> Evaluate returns a Maybe m.
12:52:46 <iqubic> evaluate :: a -> Maybe m
12:52:51 <iqubic> What is the a there?
12:52:52 <merijn> If even one predicate is true, the entire thing will be Just, because Nothing = mempty
12:52:59 <Cale> > sortBy (comparing length <> compare) (words "here is a bunch of words to sort first by length and then alphabetically")
12:53:04 <lambdabot>  ["a","by","is","of","to","and","here","sort","then","bunch","first","words",...
12:53:07 <merijn> iqubic: The input elements of FizzBuzz (so, numbers from 1 through 100)
12:53:12 <iqubic> Oh, a is the input
12:53:23 <Cale> ^^ there's another nice monoid puzzle for you :D
12:53:59 <iqubic> :t comparing
12:54:02 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
12:54:09 <iqubic> :t compare
12:54:11 <lambdabot> Ord a => a -> a -> Ordering
12:54:23 <iqubic> Are you using the Ordering Monoid?
12:54:30 <iqubic> :t sortBy
12:54:32 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
12:54:33 <Cale> We're using the a -> a -> Ordering monoid
12:54:48 <iqubic> Oh. I see.
12:55:26 <iqubic> That works because (a -> (a -> Ordering)) has monoid because (a -> Ordering) is monoid.
12:55:31 <merijn> iqubic: Right
12:55:47 <iqubic> But I don't get why you need two different comparing functions to be used there.
12:56:07 <merijn> iqubic: Compare by length *first*, then by regular comparison second
12:56:12 <iqubic> I see.
12:56:17 <merijn> iqubic: Note how all equal length words are sorted alphabetically
12:56:19 <iqubic> That makes sense.
12:56:33 <merijn> iqubic: So you can compose arbitrarily complex comparisons
12:56:47 <iqubic> :t (comparing length <> compare)
12:56:50 <lambdabot> (Foldable t, Ord (t a)) => t a -> t a -> Ordering
12:57:09 <iqubic> Huh?? What is that type signature???
12:57:16 <merijn> iqubic: length :)
12:57:17 <merijn> :t length
12:57:19 <lambdabot> Foldable t => t a -> Int
12:57:32 <Cale> That still gets me as well
12:57:35 <iqubic> I don't get it.
12:57:41 <merijn> :t comparing
12:57:43 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
12:57:48 <Cale> You can think of that as [a] -> [a] -> Ordering
12:57:52 <merijn> :t comparing `asAppliedTo` length
12:57:55 <lambdabot> Foldable t => (t a -> Int) -> t a -> t a -> Ordering
12:57:58 <Cale> If it makes you more comfortable :)
12:58:00 <merijn> :t comparing length
12:58:03 <lambdabot> Foldable t => t a -> t a -> Ordering
12:58:12 <iqubic> What the hell is `asAppliedTo`?
12:58:18 <iqubic> :t asAppliedTo
12:58:21 <merijn> iqubic: const with a fancy type signature
12:58:21 <lambdabot> (a -> b) -> a -> a -> b
12:58:47 <iqubic> I see. That's just (a -> b) -> a -> (a -> b)
12:59:08 <iqubic> So composing comparisons is a thing that works.
12:59:19 <Cale> Yeah, it's just a handy lambdabot thing for checking how the types of functions specialise
12:59:59 <iqubic> > sortBy (compare <> comparing length) (words "here is a bunch of words to sort first alphabetically and then by length")
13:00:00 <Cale> iqubic: and yeah, composing comparisons works because there's an instance of Monoid for Ordering which, if the first Ordering is EQ, picks the second one, and otherwise, picks the first.
13:00:02 <lambdabot>  ["a","alphabetically","and","bunch","by","first","here","is","length","of","...
13:00:13 <iqubic> How the heck did that work?
13:00:43 <iqubic> Wait... The second comparison is used to break ties on the first comparison.
13:01:26 <lavalike> https://www.stackage.org/haddock/lts-14.0/base-4.12.0.0/src/GHC-Base.html
13:01:27 <iqubic> I love these haskell puzzles.
13:01:32 <Cale> Well, compare never produced an EQ result
13:01:33 <lavalike> search for "instance Semigroup Ordering"
13:01:42 <Cale> So the comparing length probably never got involved
13:01:47 <Cale> Let's try...
13:01:55 <Cale> > sortBy (compare <> undefined) (words "here is a bunch of words to sort first alphabetically and then by length")
13:01:59 <lambdabot>  ["a","alphabetically","and","bunch","by","first","here","is","length","of","...
13:02:28 <iqubic> There are no ties there.
13:02:34 <Cale> right
13:03:00 <iqubic> > sortBy (compare <> undefined) (words "here is a bunch of words to sort first alphabetically and then uhh erm uhh")
13:03:04 <lambdabot>  ["a","alphabetically","and","bunch","erm","first","here","is","of","sort","t...
13:03:11 <iqubic> How does that not fail?
13:03:31 <Cale> Well, that just proves it never needed to break a tie
13:03:46 <zeta_0> vaibhavsagar: hello there, could you resend me the links to your ihaskell notebooks you showed me yesterday, i am still getting the packages broken error when trying to install ihaskell in home.nix, so i'll try other ways to get ihaskell to install in home.nix
13:03:49 <iqubic> > sortBy (compare <> undefined) (words "here is a bunch of words to sort sort sort sort sort")
13:03:53 <lambdabot>  *Exception: Prelude.undefined
13:04:24 <iqubic> Alright. So, sometimes sorting needs to break ties, and sometimes it doesn't. Even when the same word is used twice.
13:05:56 <iqubic> Anyways I have to go now.
13:06:24 <dmwit> Cale: But it *did* need to break a tie. The end says "uhh erm uhh", and surely "uhh" ties with "uhh"...
13:06:49 <iqubic> Also, `comparing x` seems like an alternative for "compare `on` x"
13:06:58 <dmwit> Yes. In fact, that is its definition.
13:07:02 <dmwit> ?src comparing
13:07:03 <lambdabot> comparing p x y = compare (p x) (p y)
13:07:07 <iqubic> Nope.
13:07:10 <iqubic> ?src on
13:07:11 <lambdabot> (*) `on` f = \x y -> f x * f y
13:07:12 <merijn> comparing predates on
13:07:23 <lavalike> > sortBy (compare <> undefined) (words "uhh erm uhh")
13:07:23 <iqubic> Well, that's a thing.
13:07:27 <lambdabot>  ["erm"*Exception: Prelude.undefined
13:07:32 <iqubic> Oh. I see.
13:07:32 <lavalike> it just didn't get that far
13:08:03 <iqubic> > sortBy (compare <> undefined) (words "here is a bunch of words to sort sort sort sort sort")
13:08:06 <lambdabot>  *Exception: Prelude.undefined
13:08:08 <dmwit> lavalike: Then why does "here is a bunch of words to sort sort sort sort sort" produce undefined immediately...?
13:08:21 <iqubic> But this fails with out any list at al.
13:08:44 <lavalike> @src sortBy
13:08:45 <lambdabot> -- The actual definition used by GHC is an optimised mergesort.
13:08:45 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
13:09:12 <iqubic> I'll read all of this later.
13:11:31 <zeta_0> Cale: hello there, could you resend me the links to those ihaskell notebooks from yesterday, i can't seem to find them, i am still figuring out how to install ihaskell and it's packages in home.nix
13:12:25 <geekosaur> right, sppecifically comparing was proposed and accepted, then someone noted the further abstraction and proposed on
13:23:51 <jumper149> How are ghc extensions exchangeable? In one file of a library I have a class with FunctionaLDependencies and in another I have an instance of this class, but hlint wants me to use MultiParamTypeClasses. Is that good style?
13:32:15 <c_wraith> for extensions, I prefer to enable them only if needed.
13:37:01 <davean> jumper149: You either need the extension or you don't.
13:37:16 <davean> A few imply others
13:37:48 <davean> Maybe the implicite enablement is what you mean by "exchangeable"?
13:38:42 <jumper149> davean: I was just bamboozled because I need FunDeps for the class definition but only MultiParam for the instances.
13:39:05 <davean> Sure - they're different
13:39:10 <geekosaur> you don't put fundeps on the instances, they're part of the class
13:39:16 <davean> Right
13:39:31 <geekosaur> I'd expect MPTC needed for both, but as fundeps are only meaningful with MPTC it may be implied
13:41:35 <geekosaur> and indeed FunctionalDependencies enables MultiParamTypeClasses
13:41:44 <davean> I was just trying to look that up :/
13:41:51 <davean> you beat me handily
13:42:20 * geekosaur was digging in the manual earlier so it was handy
13:47:25 <davean> jumper149: other definitions of exchangeablility might be "can perform the same tasks" in which case associated types come in, if you're interested at looking at hte options. I personally find FunDeps far easier to understand but AssocTypes seems to be more popular and I've come around to using htem a lot.
13:52:42 <merijn> <3 conduit
14:00:22 <shapr> @src flip
14:00:22 <lambdabot> flip f x y = f y x
14:05:31 <jumper149> What is the best source to read up on extensions? For most stuff I use wiki.haskell.org and hackage.
14:05:46 <dmwit> The official documentation is very good.
14:06:08 <Cale> Yeah, the GHC User's Guide
14:06:12 <dmwit> Often there is an associated academic paper which goes into further detail; usually linked from the official documentation as well.
14:07:03 <infinisil> jumper149: I have this page bookmarked: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html
14:10:44 <_kwstas> hi there! I have the following code `fmap show [1..]`. and I need to annotate the 1 with ::Int otherwise I get `...Defaulting the following constraints to type ‘Integer’`. is there any way to use TypeApplications extension in order to avoid using the ::Int?
14:11:58 <geekosaur> (show @Int), or (show :: Int -> String)
14:12:04 <geekosaur> or just disable the warning
14:13:11 <_kwstas> geekosaur: thx! (show @Int) was the one i was looking for :)
14:17:28 * hackage hashtables 1.2.3.4 - Mutable hash tables in the ST monad  https://hackage.haskell.org/package/hashtables-1.2.3.4 (ErikDeCastroLopo)
14:18:27 * hackage either-both 0.1.1.0 - Either or both  https://hackage.haskell.org/package/either-both-0.1.1.0 (MatthewFarkasDyck)
14:21:49 * geekosaur wonders what was wrong with These
14:23:40 <jumper149> What actually is a `kind`?
14:23:52 <geekosaur> the "type" of a type
14:24:21 <geekosaur> so Maybe has kind Type -> Type, meaning you apply it to a Type and it gives you another Type
14:24:23 <jumper149> Are there other elements of `kind` other than `Type`?
14:25:04 <geekosaur> you can use the DataKinds extension to promote user-defined types into kinds
14:25:12 <geekosaur> otherwise, it's mostly used to keep track of things like
14:25:16 <geekosaur> :k StateT
14:25:19 <lambdabot> * -> (* -> *) -> * -> *
14:25:26 <jumper149> nvm I think that was a stupid question
14:25:40 <geekosaur> which uses the older notation * instead of Type
14:25:52 <jumper149> ty that clears things up :)
14:25:57 <Denommus> hey
14:26:00 <iqubic> DataKinds are way cool.
14:26:00 <vaibhavsagar>                                                                                                                                     jumper149 there is kind `#`
14:26:02 <geekosaur> which is going away because type level operators are becoming more common and having * be both a kind and an operator is ... painful
14:26:09 <geekosaur> not really any more
14:26:16 <Denommus> I'm doing a freer-simple DSL
14:26:30 <geekosaur> it's been generalized into lifting and RuntimeRep
14:26:52 <Denommus> and the DSL represents a "builder" of a type, and it builds many entities, and I should be able to list the entities that are already created
14:27:15 <Denommus> but the entity type depends on the interpreter of the DSL
14:27:43 <Denommus> so I thought of doing something like data SurveyBuilder survey r where ...
14:27:58 * hackage gothic 0.1.1 - A Haskell Vault KVv2 secret engine client  https://hackage.haskell.org/package/gothic-0.1.1 (MichelBoucey)
14:28:11 <Denommus> where survey is the type variable that's going to be replaced by the concrete type
14:33:58 <Vtec234> Hello! I'm relatively new to Haskell and trying to build a site using Hakyll. I came across this issue: I have some data, say `let m :: Metadata`, and want to extract from it a date. Unfortunately it seems the only way to extract a date from metadata is using getItemUTC (https://github.com/jaspervdj/hakyll/blob/41e7b8cf18ae29a57b518437c706a7c7c377fc15/lib/Hakyll/Web/Template/Context.hs#L302), which is in
14:34:00 <Vtec234> MonadMetadata. Now a MonadMetadata m (https://github.com/jaspervdj/hakyll/blob/master/lib/Hakyll/Core/Metadata.hs#L48) requires a function w/ signature Identifier -> m Metadata, which looks to me like it can't be pure, because there is no Metadata in an Identifier. So I can't extract it from the argument and hence must use side effects. Is this understanding correct?
14:34:20 <Denommus> this is what I have in mind: https://gist.github.com/Denommus/832697eba7a9099eb8ab43d922aa6ed5
14:34:26 <Denommus> but I'm getting a lot of errors
14:35:08 <Denommus> related to overlapping instances and ambiguous types
14:35:24 <Denommus> is it possible to have a type variable like that in freer-simple?
14:35:37 <merijn> Vtec234: Is this understanding correct? Almost certainly not, but pinpointing where it is incorrect is less obvious
14:36:30 <merijn> Vtec234: MonadMetadata means the operation has to take place in some monad (which you can consider the context in the case of Hakyll), you can look up things from this context
14:37:45 <merijn> Vtec234: Does looking something up in a context require side-effects/is it impure? Generally, the answer is no. For example Reader gives you a context to look things up in, but it's still pure (hell, if we're going to be pedantic even IO is pure, that's the entire point of having IO!)
14:39:45 <merijn> Vtec234: To get somewhere more useful for your question, if we look up the haddocks for MonadMetadata, we see that is has two instances
14:39:57 <merijn> 1) Compiler and 2) Rules
14:40:13 <merijn> So presumably you want this lookup to take place *within* a Compiler/Rules
14:44:56 <Vtec234> Yep, that's what would normally happen. However, I'm trying to lookup a date from the metadata in a metadataRoute (https://hackage.haskell.org/package/hakyll-4.12.5.2/docs/Hakyll-Core-Routes.html), which only provides a pure Metadata value. So what I would like, ideally, is to create another instance of MonadMetadata m for an m which just contains a value that was, for example, passed to runPureMetadata
14:44:58 <Vtec234> (like ReaderT).
14:46:00 <merijn> Vtec234: You could do "instance MonadMetadata m => MonadMetadata (ReaderT r m) where ..."
14:47:24 <Vtec234> merijn: That's exactly what I wanted to do. But I'm not sure how to provide the required definitions for the instance - `getMetadata :: Identifier -> m Metadata` would require me to somehow make up a value of metadata out of thin air, no? Or is it just `ask`?
14:47:51 <merijn> Vtec234: You can just use "lift" and get it for free? :)
14:48:40 <Vtec234> Sorry I misread your proposal, I want to do this in a pure context, so something like "instance MonadMetadata (ReaderT Metadata Identity)"
14:50:09 <merijn> Vtec234: Ah, but the idea of MonadMetadata is that you are tracking multiple different "files" (or whatever) who all have their own metadata
14:50:26 <merijn> Vtec234: So presumably you'd sooner want something like "ReaderT (Map Identifier Metadata) m"
14:52:41 <Vtec234> Yeah, it's really kind of a hack. A much better way would be to have a pure func. to extract dates from a Metadata value. I was hoping to be kind of lazy here and make an instance that just returns the same Metadata ignoring the identifier so that I can get the damn date out :P
15:00:31 <Vtec234> In fact I should really just write the pure version and maybe PR it. Thanks for the help though!
15:05:30 <jumper149> Am I right that type variables are just valid to one type declaration?
15:07:18 <jumper149> So if I have something like `f :: a -> b` and `f = ... where x = (... :: a)` the type variable a in the where statement is a different one
15:08:39 <merijn> jumper149: Correct
15:08:54 <merijn> jumper149: But you can use the ScopedTypeVariables extension to fix that
15:23:23 <tsaka_> Couldn't match type ‘IO Bool’ with ‘Bool’
15:23:32 <tsaka_> (files, dirs) <- partitionM (liftM2 (||) doesFileExist pathIsSymbolicLink) dirCntntPaths
15:23:35 <tsaka_> hmm??
15:23:53 <tsaka_> this works fine:         (files, dirs) <- partitionM doesFileExist dirCntntPaths
15:25:38 <Cale> I think you meant liftM2 (liftM2 (||))
15:25:58 * hackage filtrable 0.1.2.0 - Class of filtrable containers  https://hackage.haskell.org/package/filtrable-0.1.2.0 (MatthewFarkasDyck)
15:25:59 <Cale> Because you're distributing over the function argument and then IO
15:26:39 <wroathe> Writing a nontrivial parser using parser combinators is giving me a whole new level of respect for people who write and maintain parsers for programming languages... Mad men and women, all of them.
15:28:59 <merijn> wroathe: Properly designing a grammar a head of time helps...A LOT
15:29:19 <wroathe> merijn: That part is already done for me... I'm parsing Bison grammar files
15:29:38 <wroathe> https://github.com/JustinChristensen/bison-grammar-codegen/blob/master/src/Bison/Grammar/Parser.hs#L339
15:30:23 <merijn> wroathe: prologueDecl needs more asum
15:30:26 <merijn> :t asum
15:30:28 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
15:31:00 <wroathe> merijn: Shhh
15:31:20 <wroathe> :p I've got plenty of kinks to work out
15:32:35 <merijn> Looks pretty reasonable too be
15:34:52 <fragamus> Hi I wanted to ask a general question about record syntax. Why do we have it? Could we get along very happily without it?
15:35:40 <wroathe> fragamus: For records with lots of fields
15:36:05 <wroathe> fragamus: Try writing a function to access the 19th field of a 20 field record
15:36:26 <fragamus> generic lens?
15:36:43 <fragamus> but yeah I can kind of see why
15:37:52 <Denommus> I tried to convert from freer-simple to freer, with the same results :-/
15:38:08 <Denommus> I think I kinda understand why it happens, but I don't know how to solve it
15:41:40 <infinisil> fragamus: Imagine a language like C or Rust without structs
15:42:21 <infinisil> Records are pretty much structs
15:43:10 <jumper149> i(^[18a_,^[a,x,_)
15:43:24 <jumper149> to access the 19 element :p
15:44:04 <fragamus> I was working on a delegation model that involved higher order functions that performed "join" operations on functions that take named arguments. I can definitely see why having named arguments is sometimes preferable to an ordered list of arguments
15:44:45 <fragamus> but I don't know if record syntax could be used in such a model
15:46:19 <fragamus> jumper: can you point me to some reading material on that i(^[18a blah blah
15:46:33 <infinisil> Haha
15:47:21 <infinisil> fragamus: `man vim`
15:47:23 <jumper149> maybe define a class for the data type and give the class methods that access the necessary entries
15:47:35 <fragamus> lol ok
15:50:57 <jumper149> Am I losing any type checking safety if I use AllowAmbiguousTypes?
15:53:40 <infinisil> jumper149: Nope
16:32:13 <Denommus> I found out
16:32:39 <Denommus> it gives me an error when I don't use the `survey` type in the type of the function
16:32:47 <Denommus> I still don't know how to work around that, though
16:35:40 <Denommus> I *could* associate the survey type to the methods that use it, but I don't like this idea
16:55:21 <orzo> Is it not allowed to make CPP macros that expand to pragmas?
16:55:38 <orzo> i'm trying to do that and can't get it to compile
16:57:20 <lavalike> orzo: something like this? https://stackoverflow.com/a/3030312
16:58:12 <orzo> no
16:58:23 <hpc> {-# this stuff? #-}
16:58:25 <orzo> this is #haskell
16:58:42 <lavalike> the cpp preprocessor is the same cpp preprocessor as that one aiui
16:58:59 <orzo> i'm using LANGUAGE CPP to allow me to define macros, and i have a macro attempting to expand to a series of SPECIALIZE pragmas
16:59:30 <lavalike> I see, not cpp pragmas
17:00:03 <orzo> for example, #define SPECIALIZED(fname) {-# SPECIALIZE fname :: Sig_/**/fname (Double) #-}
17:01:57 <orzo> hmm, my example worked
17:02:17 <orzo> i gues sthe problem is when i trey to add multiple lines to the macro with \ and have multiple SPECIALIZE pragmas
17:04:25 <orzo> Anyone know a way to modify my example to specialize for Float as well as Double?
17:06:11 <orzo> maybe this is a bug?
17:09:36 <orzo> I think the issue is that \ to continue a macro is actually removing the newline character on expansion and the SPECIALIZE macro is required to be at the start of a line
17:10:07 <orzo> is there a way to expand a macro to multiple lines with line terminators?
17:16:00 <orzo> maybe template haskell is the only way
17:16:50 <orzo> its frustrating
17:17:21 <lavalike> cpp can't output multiple lines, but you can provide your own post processor apparently
17:18:18 <orzo> i think the rules for SPECIALIZE are pointlesly restrictive
17:18:47 <orzo> it shouldn't have to be the start of the line and if a function is INLINEABLE then it shouldn't even have to be in the same module
17:20:21 <orzo> the vector math situation is pretty bad because theres no clear standard vector library.  If specialize could be outside the module than a library could provide generic vector-math functions without forcing a particular representation
17:49:26 <iqubic> I hate it when I screw up my system and my WM no longer works.
18:37:47 <wagle> what do you do if uninstall-hs deletes NOTHING except itself?
18:41:51 <monochrom> Reset computer from backup?
18:43:04 <monochrom> This is why normally I only trust a few well-understood or well-proven-to-be-trustworthy auto-installers.
18:43:19 <iqubic> No. This is NixOS. I can fix this by changing my system config
18:43:26 <iqubic> I don't need to rollback
18:45:04 <monochrom> But I was commenting on "uninstall-hs", not NixOS. Not every sentence is about you.
18:45:22 <wagle> ick, but plausible
18:45:57 <wagle> ha!  It just finished backing up the mess
18:46:14 <jusss> what is eitherT ?
18:46:22 <jusss> and what it's used to?
18:46:47 <iqubic> It's depreciated. Use ExceptT instead.
18:46:53 <monochrom> I have never heard of uninstall-hs.  I would not use it.  But now that damage is done, I would find out what its installer did, mainly where it put the files so I can manually delete them.
18:46:57 <iqubic> It's the Monad Transformer of Either.
18:47:25 <jusss> wow, I just saw there're also StateT and ReaderT
18:47:46 <iqubic> Those are the monad transformers for State and Reader.
18:48:10 <jusss> then what is the monad transformers and what it's used to...
18:48:11 <jackdk> monochrom: IIRC uninstall-hs is shipped with the macOS version of the Haskell Platform and is meant to be the "expected" way to uninstall it
18:48:37 <monochrom> For an example of trustworthy auto-installers (apart from linux distro stuff and most for-Windows installers), I trust ghcup, actually because it earns my trust, it's very transparent and forthcoming about which directory to delete.
18:49:09 <iqubic> Aren't these auto-uninstallers actually?
18:49:13 <monochrom> For an example of untrustworthy auto-installer because opacity and pretended abstraction: stack.
18:50:50 <monochrom> And the thorny case: For an example of untrustworthy, opague, pretended-abstract auto-installer that I end up using because it's a necessary evil so I personally figure out its file structure: cabal (both lib and exe)
18:52:23 <monochrom> Maybe uninstall-hs just needs to be run as root?
18:54:52 <wagle> yeah, but is deleted itself, which was the joke
18:55:07 <monochrom> Oh, right, oops.
18:56:58 <monochrom> I haven't use the installer from Haskell Platform for a long time.  It has other problems such as unrelocatable URLs in the library docs it included.  (I am not going to install into the default /usr/local.)
18:57:16 <wagle>  2017?
18:57:21 <wagle> haha
18:57:54 <wagle> I'm uninstalling so I can do it today's version of "right"
18:58:21 <monochrom> So I install GHC from the GHC website bindist, then steal the library list of Haskell Platform, kick out a few and add a few of my choice, then cabal-install them semi-manually.
18:59:08 <wagle> just saw something about ghcup?
18:59:31 <monochrom> Yeah I recommend ghcup too for other people.
19:00:14 <wagle> whats the drawback?
19:00:29 <monochrom> I don't want my copies of GHCs in my home directory.
19:00:43 <wagle> ah
19:01:26 <monochrom> It is actually not too much a hassle to manually do most of the things ghcup does.
19:02:02 <wagle> installing haskell remains a hassle (pun failure)
19:02:08 <monochrom> haha
19:03:38 <wagle> oh hell, I'm going to break gitit again
19:06:04 <wagle> damn kids!  they leave crap all over my lawn..  er...  filesystem
19:07:11 <wagle> found a new stack in ~/.local/bin  
19:14:32 <wagle> old haskell stuff everywhere!  </froth>
19:15:17 <monochrom> Haskell infestation!
19:15:28 * hackage recursion 2.2.4.0 - A recursion schemes library for GHC.  https://hackage.haskell.org/package/recursion-2.2.4.0 (vmchale)
19:24:58 <sclv> for future knowledge, the haskell platform for mac and windows is just ghcup
19:25:03 <sclv> which installs everything in .ghcup
19:25:11 <sclv> these days
19:26:12 <sclv> wagle: if you want to see all the stuff uninstall-hs is supposed to uninstall, here you go https://github.com/haskell/haskell-platform/blob/master/hptool/os-extras/osx/bin/uninstall-hs.hs
19:29:09 <wagle> sclv: seems too easy
19:29:21 <wagle> thanks!
20:53:17 <wikiemol> Hello, I am trying to compile and run this simple program `main = readLn >>= (\x -> putStr x)` and I get "main: user error (Prelude.readIO: no parse)" what the heck is going on?
20:54:00 <heatsink> When you call readLn, it is trying to read a string in haskell syntax
20:54:17 <heatsink> It tries to read a string because you pass it to putStr, which takes a string
20:54:27 <sarahzrf> you might have wanted to use getLine
20:54:36 <sarahzrf> :t readLn
20:54:39 <lambdabot> Read a => IO a
20:54:39 <sarahzrf> :t getLine
20:54:42 <lambdabot> IO String
20:54:43 <heatsink> So, if you don't write a string complete with " symbols, it will give a parse error
20:55:28 <Axman6> wikiemoit may have worked if you'd entered \"\"
20:55:57 <Axman6> > show "Hello"
20:56:00 <Cale> (except without literal backslashes)
20:56:00 <lambdabot>  "\"Hello\""
20:56:14 <Cale> You'd just type the quotes on either end
20:57:07 <wikiemol> Interesting okay thanks everyone
20:57:53 <Cale> The thing that readLn tries to parse depends on how you use the result, so if you'd used it as an Integer, say, it would have wanted you to type a number.
21:01:53 <wikiemol> Gotcha, I should've read the docs
21:32:57 * hackage heredocs 0.1.5 - heredocument  https://hackage.haskell.org/package/heredocs-0.1.5 (KatsutoshiItoh)
22:02:16 <electricityZZZZ> what is the name of this weird notation i see in programming language papers with like a division symbol and sideways letter T characters
22:07:11 <ysangkok> i think they are just called inference rules
22:16:32 <sarahzrf> ⊢
22:16:41 <sarahzrf> electricityZZZZ: deductive systems?
22:16:42 <electricityZZZZ> yeah thanks unicode-keyboard person
22:16:59 <sarahzrf> "⊢" is pronounced "entails" and is called a "turnstile"
22:17:13 <electricityZZZZ> i mean, i don't know, i've thumbed through some programming language papers and i see big ugly expressions i've never seen elsewhere
22:17:35 <electricityZZZZ> and it looks like things are being "divided" ... is there a guide to reading these things somewhere?
22:18:14 <sarahzrf> the things on top of the line are premises, andd the thing on the bottom is a conclusion
22:18:27 <sarahzrf> if you have derived the things on the top, you can proceed to derive the thing on the bottom
22:18:34 <sarahzrf> i don't know of a source sorry :c
22:19:23 <electricityZZZZ> ok,...  (related question) is there a "notation for programming languages"?
22:20:32 <sarahzrf> damn
22:20:34 <sarahzrf> that's a tough question
22:21:16 <wikiemol> I do not understand why this is doing weird stuff https://pastebin.com/tASArYxS Essentially, in the "then" part of the if statement, all of the `putStr "Try again bozo"` statements aren't running until a valid input is entered. Whats going?
22:21:37 <electricityZZZZ> i kinda thought that's what i was seeing when saw the notation in those papers but it sounds like these are just incidental deductions which maybe are optimizations or somesuch
22:22:28 <Axman6> I would say there are many notations for programming languages. 
22:22:45 <electricityZZZZ> please don't say lisp :-P
22:23:05 <Axman6> I mean things like notations for operational semantics of the language
22:23:19 <sarahzrf> wikiemol: output buffering
22:23:25 <sarahzrf> wikiemol: use putStrLn instead
22:23:48 <sarahzrf> they are getting written, but without a newline they all end up on the same line, and they dont get displayed until the stream is flushed or there's a newline
22:24:18 <Axman6> stdout by default is line buffered, text isn't output until a new line is encountered
22:24:41 <electricityZZZZ> haha it says try again bozo
22:24:50 <wikiemol> sarahzrf: !!!!! That makes so much sense
22:24:54 <wikiemol> Thank you!
22:24:56 <sarahzrf> np :)
22:26:07 <wikiemol> Im obviously new to Haskell... but so far every time something goes wrong I realize its 100% my fault and not a language design flaw...
22:26:24 <sarahzrf> ehhhh, i wouldn't put it that way
22:26:37 <sarahzrf> fyi, although tbf, line buffering isn't a haskell thing
22:26:38 <wikiemol> Well, from what you are saying, It did exactly what I wanted it to do... 
22:26:40 <Axman6> nah that one's an annoying gotchya that's completely unobvious
22:27:03 <wikiemol> sarahzrf: Thats what I mean. Line buffering is part of the terminal I am using
22:27:35 <jackdk> yeah I'm gonna agree with Axman6 here: that's nothing to do with haskell, but like "hey do you happen to know this thing about how terminals tend to buffer?"
22:29:13 <wikiemol> Well I guess they could have put a flush as part of put str but I could see this feature being useful 
22:29:49 <Axman6> The answer is usually to set the buggering of stdout to NoBuffering
22:30:02 <sarahzrf> now was that a type....
22:30:04 <sarahzrf> *typo
22:30:27 <wikiemol> No, I forget to set my buggering all the time...
22:30:28 <Axman6> I'm ok with this
22:32:08 <wikiemol> When Axman6 told me to set my buggering to NoBuggering,  it was so my code wouldn't have any buggers any more
22:32:26 <mankyKitty> It has been ... debuggered
22:32:56 <ysangkok> electricityZZZZ: i think this book introduces the notation https://www.amazon.com/Formal-Semantics-Programming-Languages-Winskel/dp/0262731037
22:34:55 <jackdk> Axman6: if it was hSetBuggering stdout NoBuggering I'd be asking lambdabot to remember it for posterity
22:35:11 <Axman6> Thow shalt not...
22:35:21 <electricityZZZZ> ysangkok: taking a look, thanks,...
22:38:30 <ysangkok> electricityZZZZ: can't find it in the pages google shows me, FYI...
22:38:58 <ysangkok> probably somewhere between page 15 and 35
22:39:46 <electricityZZZZ> heh well it was trivial to find the book ;-) ... so is this how programming languages are described?
22:40:03 <Axman6> sometimes
22:40:15 <Axman6> other times they're YOLO described by having an implementation
22:40:23 <electricityZZZZ> haha
22:40:31 <ysangkok> electricityZZZZ: i linked this book because this is what we used in my undergraduate course
22:40:36 <electricityZZZZ> rust is YOLO'ed?
22:41:04 <ysangkok> it's not really YOLO if you know what you're doing...
22:41:19 <ysangkok> i wouldn't even say java was YOLO'ed even though it was proven unsound...
22:41:39 <ysangkok> because in fact the theory was all right, but the implementation allowed for more than the theory...
22:41:58 <electricityZZZZ> haha wow proven unsound
22:42:05 <electricityZZZZ> i didn't know about that one holy crap
22:42:40 <ysangkok> it is not fundamentally unsound, and it has been patched...
22:43:16 <ysangkok> electricityZZZZ: https://dl.acm.org/citation.cfm?id=2984004
22:44:19 <electricityZZZZ> yeah
22:44:20 <electricityZZZZ> crazy
22:46:37 <electricityZZZZ> it seems like all programming languages have outrageous, glaring flaws once you get into them,...
22:47:51 <ysangkok> i would say the problem is mostly with execution/interpretation :P so strictly not the language itself
22:47:55 <sarahzrf> very, very few languages have actual formally written down semantics
22:48:01 <sarahzrf> haskell certainly doesn't
22:48:06 <sarahzrf> SML does, off the top of my head
22:54:58 * hackage boots-app 0.1.0.3 - Startup factories using IoC monad  https://hackage.haskell.org/package/boots-app-0.1.0.3 (leptonyu)
22:58:23 <electricityZZZZ> wow github is turning to shit? i just searched for haskell projects, sorted by stars, and it says that i triggered an abuse detection mechanism. welcome to the machine learning era :-P
22:58:57 <electricityZZZZ> yep just happened again
22:59:00 <Axman6> Are you using a VPN?
22:59:03 <electricityZZZZ> nope
22:59:13 <electricityZZZZ> ive never been accused of anything fishy
23:02:10 <electricityZZZZ> try it? search for all haskell projects and then sort by most starred
23:04:12 <maerwald> electricityZZZZ: accounts get randomly locked for false-positives in spam detection as well
23:04:35 <maerwald> then you have to contact support, meanwhile all your profile, projects and even COMMENTS on entire github are hidden
23:04:41 <maerwald> bad platform
23:05:21 <electricityZZZZ> im not logged in :-P
23:05:41 <maerwald> that's why you triggered the abuse detection mechanism xD
23:05:48 <electricityZZZZ> wat
23:05:53 <electricityZZZZ> i cant sort on stars if i am not logged in
23:05:53 <maerwald> jk
23:06:12 <electricityZZZZ> i am thinking this is AI
23:06:41 <maerwald> probably at the level of a 13 years old troll
23:06:58 <maerwald> welcome to the age of AI
23:07:12 <electricityZZZZ> nah i mean somebody thinks their neural net is fighting robots or something
23:21:53 <electricityZZZZ> there... now it works...
23:46:27 <alexelcu> Hi all, I'm a perpetual newbie, playing with Haskell again ...
23:46:28 <alexelcu> So what editors / plugins do you use for editing code? Is Intero for Emacs still recommended? What about the haskell-ide-engine for VS Code?
23:47:22 <Axman6> I use VS Code with HIE quite happily (though HIE needs to be restarted about once a day to stay happy)
23:52:45 <jackdk> I am quite happy with dante and emacs
23:59:52 <alexelcu> jackdk: looks cool, did not know about dante
