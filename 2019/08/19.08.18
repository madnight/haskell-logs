00:26:58 * hackage salak 0.3.4 - Configuration (re)Loader and Parser.  https://hackage.haskell.org/package/salak-0.3.4 (leptonyu)
00:27:58 * hackage salak-toml 0.3.4, salak-yaml 0.3.4 (leptonyu): https://qbin.io/decide-oldest-f4xy
00:29:28 * hackage hmatrix-backprop 0.1.3.0 - hmatrix operations lifted for backprop  https://hackage.haskell.org/package/hmatrix-backprop-0.1.3.0 (jle)
00:32:53 <fog> now when i try to build a project which previously built it fails, because the path is too long because of mingw prefixes and cabal directory with long hash on the lib directory name
00:33:17 <fog> so, trying with cabal from the windows prompt to try and get a shorter path
00:33:28 <fog> then it fails to see the packages built in mingw
00:33:43 <fog> i have to build eg network in mingw because it requires the unix toolchain
00:34:28 <fog> also, when writing cabal new-install network in mingw it complains about dependency conflicts of a local project in a different location!
00:35:12 <fog> this means that somehow by building projects locally, it has broken the ability for mingw to install packages from hackage
00:36:06 <fog> so, how can i fix the environment so that i can see the network package built in mingw
00:36:44 <fog> and how can i make it so i dont need to supply --allow-new to cabal new-install network to get it to not complain about some local project in a different location
00:37:22 <fog> and is there any way to fix this path length thing so i can just build everything in mingw?
00:42:30 <maerwald> fog: ghc-8.6?
01:01:19 <fog> 8.6.5
01:01:33 <fog> maerwald: ^
01:06:56 <maerwald> https://github.com/haskell/cabal/issues/3972 suggests parts of these issues should be resolved if cabal was compiled with ghc-8.6?
01:45:51 <fog> compiled!? i just get the haskell platform and it makes cabal available
01:46:54 <fog> i thought maybe there was some way to change the max_length either in windows or mingw that would work
01:47:34 <fog> and i just reinstalled the haskell platform and it is exactly the same
01:51:39 <fog> there seems to be a bunch of supposed "fixes" all of which dont work for various things to do with haskell via mingw
01:52:51 <fog> eg apparently there is a special version of libtools for mingw that is supposed to get round the problems of tring to build c libs from source
01:53:13 <fog> just gives the same "lib command missing" error
01:53:51 <fog> all this makes it seem like mingw for interfacing with C libs on windows is not going to work at all
01:54:11 <fog> though its still needed for eg installing the network library
01:55:43 <fog> but the fact that cabal is trying to build a local repo when i write cabal new-install network is strange
01:55:53 <fog> it being in a totally different directory
01:56:17 <fog> removing the cabal %appdata% dir and reinstalling the haskell platform doesnt help
01:56:34 <fog> so i figure it might be some path to do with the mingw envoronment
01:57:25 <fog> and having unistalled that now all the libtools and everything need to be reinstalled and they wernt working anyway so im just giving up on this trying to backpack c libraries thing, total waste of time
01:57:50 <fog> you would think with haskell being developed at microsoft that they would have their build tools in order...
01:57:55 <sm[m]> fog: stack, also provided by haskell platformm has a lot of windows/mingw knowledge built in; worth trying it to help with troubleshooting ?
01:59:20 <fog> you think that could fix these fourfold mingw vs. windows cmd  X v1 vs. v2 installs ?
02:01:50 <sm[m]> I haven’t read your problems in detail. If it were me, I would definitely spend some time trying it
02:01:50 <fog> i guess somewhere everything is getting confused. there was even a really strange error where everything built and i could open it in ghci but when i ran the main test it gave a really wierd error where GHC was complaining about installing the same library from 2 places
02:01:50 <fog> should have probably logged that as a bug when i encountered it, cant seem to reproduce it
02:02:03 <fog> sm[m] but then it probably goes down the path towards nix where everything is just mirrored and there are only stable binaries to access
02:02:23 <fog> i want a reproducible build... maybe stack would help
02:02:35 <fog> but i wanted to stay as clase to cabal as possible
02:03:04 <sm[m]> I wasn’t suggesting nix, but that might be a third option, if it supports windows yet. My point is that a lot of windows-related issues have been dealt with in stack, so it might be a good idea to at least compare it
02:04:48 <fog> yeah, if i were just trying to document all the bugs
02:04:48 <sm[m]> Or search their issue tracker for some of your issues
02:04:48 <davean> uh, you might be getting a .ghci file in hte folder
02:04:48 <fog> i was using cabal.project instead of .ghci files, which dont seem to work anymore either!
02:04:48 <davean> cabal.project produces a .ghci
02:04:48 <fog> the whole thing seems to have broken... 
02:04:48 <fog> not sure if it has something to do with these;
02:04:48 <fog> .ghc.environment.x86_64-mingw32-8.6.5
02:04:51 <fog> files that its generating
02:04:52 <davean> yes
02:06:11 <fog> its a bit annoying that before using cabal, and just placing .ghci files in dirs with :set -i../ 
02:06:14 <fog> which worked
02:06:37 <fog> now attempting to use cabal these seem to be invalidated
02:06:52 <fog> so *everything* has to use cabal, and then cabal itself doesnt work!!!
02:07:49 <fog> but i guess if the haskell community just gave up trying to fix cabal and switched to stack i guess i should follow
02:09:23 <sm[m]> No need to be so dramatic :) But if you find it works better on windows, you could use it; or copy whatever it does to make cabal work
02:12:11 <sm[m]> stack has pretty good windows support, and trying multiple approaches can help with troubleshooting, is all I’m saying really. AFK a bit, good luck
02:12:11 <fog> honestly im quite convinced by now that the universe is conspiring to prevent the project from building and to make me encounter every conceivable problem. im not it the right mood to try and venture down another totally unknown path with all new issues to encounter  
02:12:36 <fog> cheers
02:34:53 <tdammers> https://github.com/haskell/cabal/issues/6198 - cabal v2-test -- -t 1 # doesn't work. Am I doing something wrong here? Neither --help nor the manual provide any insight.
02:43:23 <freeman42x> wat? https://gist.github.com/razvan-panda/26ff66bc2110ea337f38c5b047c608bc
02:46:00 <maralorn> freeman42x: That looks very much like an error message of nix.
02:46:17 <tdammers> freeman42x: that error may not be coming from stack
02:46:22 <maralorn> Apparently stack doesn’t pass that option to nix.
02:47:13 <freeman42x> I see, makes sense now
03:36:57 * hackage hierarchical-clustering 0.4.7 - Fast algorithms for single, average/UPGMA and complete linkage clustering.  https://hackage.haskell.org/package/hierarchical-clustering-0.4.7 (FelipeLessa)
04:42:58 * hackage log4hs 0.0.6.0 - A python logging style log library  https://hackage.haskell.org/package/log4hs-0.0.6.0 (gqk007)
05:15:02 <hexagoxel> tdammers: have you tried t2-running the test-suite?
05:21:08 <tdammers> hexagoxel: might as well just cabal v2-build --enable-tests and then manually run the test suite
05:21:13 <tdammers> which is what I'm doing now
05:34:57 * hackage git-brunch 1.0.3.0 - git checkout command-line tool  https://hackage.haskell.org/package/git-brunch-1.0.3.0 (andys8)
05:36:44 <fendor_> can I get the packagedb location from which ghc-pkg reads?
05:37:42 <fendor_> ghc-pkg list dumps a lot of info, maybe there is something interesting
05:38:43 <__monty__> fendor_: It really sounds like you're trying to fight cabal hard, are you sure there's no other solutions? A nix solution would be to overlay the package you want to change, that way everything'll use that version as a dependency.
05:41:03 <fendor_> __monty__, yeah, I am fighting with cabal. I am not sure, actually. I want to deploy an instance of lambdabot, but lambdabot is marked as broken in nix, currently. 
05:41:28 <fendor_> To work around that, I tried to get more familiar with nix and tried to build lambdabot with haskell.nix which succeeded after a lot of hassle
05:42:22 <fendor_> now the invocation of lambdabot fails with messages such as https://pastebin.com/1LLXeTFU
05:42:40 <fendor_> and I thought, it may be related to the .ghc.environment file that is generated by cabal
05:43:49 <fendor_> or in other words, that it uses not the packagedb that I hoped it would
05:44:16 <__monty__> Can you show your nix expression?
05:46:14 <fendor_> https://github.com/fendor/lambdabot 
05:46:34 <fendor_> I tried to use shell2.nix to get a dev env for lambdabot
05:46:59 <fendor_> also `nix build -f default.nix lambdabot.components.exes.lamdbabot` which succeeds
05:47:34 <freeman42x> infinisil, how can I obtain a list of all versions of all-hies?
05:48:51 <freeman42x> are these all the possible versions? https://i.imgur.com/KdJbNxx.png
05:50:42 <fendor_> freeman42x, yes, that are all versions that are currently supported
05:50:51 <freeman42x> fendor_, cheers
05:51:12 <freeman42x> that means I will need to update a project from 802 to at least 822 to be able to use HIE on it
05:51:56 <fendor_> freeman42x, yes, or use an older hie version. Like, 0.4.0.0 or something like that
05:55:41 <fendor_> __monty__, maybe for my purposes mueval is enough and simpler to install? 
05:57:52 <__monty__> fendor_: What exactly do you want to do?
05:58:26 <fendor_> __monty__, for a mattermost instance the possibility to evaluate haskell code
06:04:00 <fendor_> yeah, lambdabot is too much work, mueval works perfectly well for what I intend
06:16:20 <freeman42x> uhm, any ideas? https://gist.github.com/razvan-panda/4f5a982680063f66d05b4fa6f1be44ac
06:25:28 * hackage git-brunch 1.0.4.0 - git checkout command-line tool  https://hackage.haskell.org/package/git-brunch-1.0.4.0 (andys8)
06:33:07 <fendor_> freeman42x, you are on nix, right? did you configure stack correctly to use nix?
07:03:27 * hackage purescript 0.13.3 - PureScript Programming Language Compiler  https://hackage.haskell.org/package/purescript-0.13.3 (hdgarrood)
07:09:11 <inkbottle> How do I translate this into applicative style: paren = (char '(' >> paren >>= \x -> char ')' >> return x :: GenParser Char st Char) <|> (char 'x')
07:11:26 <mniip> char '(' *> paren <* char ')'
07:11:58 <mniip> or, which is the same,
07:12:12 <mniip> const const <$> char '(' <*> paren <*> char ')'
07:13:35 <lavalike> strange parser
07:16:00 <lavalike> doesn't it only parse ((...((x))...)) where ... are matching parens (0+)
07:16:39 <mniip> I'm assuming this is a minimal example
07:17:43 <inkbottle> my, my, my... (reading)
07:20:55 <inkbottle> mniip: Thanks; yes, sort of minimal example. I chew your 3rd line and come back if I fail to make sense of it.
07:25:28 <lavalike> how does the const const <$> one work?
07:25:47 <dmwit> tdammers: You can run tests with v2-run...
07:25:52 <dmwit> tdammers: I think that's what the documentation is trying to say.
07:26:16 <dmwit> tdammers: as in `cabal v2-run test:whatever-you-named-it -- --foo`
07:27:31 <dmwit> inkbottle: const const is probably cuter than would be clear
07:27:58 <dmwit> inkbottle: The clear version is `(\_ x _ -> x) <$> char '(' <*> paren <*> char ')'`.
07:28:44 <dmwit> (...or `pure (\_ x _ -> x) <*> char '(' <*> paren <*> char ')'`)
07:35:55 <lavalike> ah!
07:36:37 <lavalike> const const picking the second, cute
07:47:49 <freeman42x> any ideas? https://github.com/commercialhaskell/stack/issues/5007
07:47:53 <inkbottle> Is parsec preloaded here?
07:50:17 <lavalike> :t Text.Parsec.try
07:50:19 <lambdabot> Text.Parsec.Prim.ParsecT s u m a -> Text.Parsec.Prim.ParsecT s u m a
07:50:22 <lavalike> at least some of it
07:50:41 <lavalike> you can try your expression in private with lambdabot 
07:50:42 <inkbottle> > runParser ((\x y -> x:y:[]) <$> char '(' <*> char ')' :: GenParser Char st String) "hello" "world" "()"
07:50:47 <lambdabot>  error:
07:50:47 <lambdabot>      Not in scope: type constructor or class ‘GenParser’
07:50:47 <inkbottle> OK
07:51:00 <inkbottle> will do
08:07:05 <inkbottle> mniip, dmwit: got it (to some point). It seems we really do catch the monoidal part of monad with applicative, because the parsers seem monoidaly combined.
08:07:51 <mniip> inkbottle, categorically, an applicative functor is a lax monoidal functor
08:08:01 <mniip> in haskell in particular the monoidal structure is that of (,)
08:31:12 <isovector1> how can i hand-roll an instance of `Data` that just stops any SYB that might want to go through it?
08:36:41 <c_wraith> well, no matter what, toConstr and dataTypeOf need to be defined.  Is that enough to break your intended use?
08:40:07 <hexagoxel> use Uniplate.Direct, write custom instances for everything, benefit from more performance?
08:41:40 <isovector1> i'm hacking on ghc; trying to expose the relevant hole bindings in the AST. but doing that breaks the `Data` instances, so now trying to recover htem
08:47:45 <c_wraith> isovector1: oh, interesting.  Turns out that you get what you want by writing a minimal instance of Data, not including gfoldl
08:47:58 --- mode: ChanServ set +o monochrom
08:47:59 <c_wraith> isovector1: the default implementation of gfoldl already ignores the substructure
08:48:23 --- mode: monochrom set -bo *!*@185.204.212.77 monochrom
08:49:48 <isovector1> c_wraith: cool, thanks!
10:08:34 <freeman42x> does this mean that the build succeeded without any errors? https://i.imgur.com/Vy0tBdj.png
10:14:35 <freeman42x> in the .cabal file is it possible to specify build-depends that are being obtained from a git repository, like on github for example?
10:19:43 <lyxia> I think that's the role of cabal.project, not *.cabal files.
10:19:44 <merijn> freeman42x: No, but you can use cabal.project to do so
10:21:00 <freeman42x> there is a cabal.project file where I am running this command: https://i.imgur.com/ie2uVKb.png any idea why it is not picking it up?
10:22:35 <freeman42x> nvm, it just wanted me to run `cabal new-build all`
10:22:43 <merijn> freeman42x: It's saying there's multiple packages listed and you need to say which to build
10:22:52 <merijn> Or, indeed, telling it to build everything :)
10:23:56 <freeman42x> yup, merijn++
10:25:14 <fendor> @karma+ merijn
10:25:14 <lambdabot> merijn's karma raised to 68.
10:26:06 <freeman42x> merijn, do you happen to have an example of a cabal.project that is referencing a git repository? the project I am looking at does not even have a .project file
10:26:45 <freeman42x> fendor, cheers @karma+ fendor @karma+ merijin
10:27:09 <freeman42x> oh :/ damn `(*>﹏<*)′
10:28:36 <merijn> freeman42x: https://github.com/merijn/GPU-benchmarks/blob/3ba4bd589b4de2808dcbe9d3af5c1a118234a50b/cabal.project
10:29:17 <freeman42x> @karma+ merijn
10:29:17 <lambdabot> merijn's karma raised to 69.
10:31:42 <iqubic> How does one get started making web applets using Reflex?
10:41:25 <blankhart> is there a way to observe the kind of a type constructor using Data.Typeable or similar (e.g., for Either)? the easiest way seems to pass in dummy type parameters and then use typeRepArgs
10:53:33 <isovector1> blankhart: what's the use caes?
10:55:58 <iqubic> *case
11:00:33 <mniip> so here's an odd question
11:00:45 <mniip> haskell recognizes vertical tab as whitespace, how does it interact with layout?
11:03:06 <blankhart> isovector1, i want to reflect type information to data somewhat in a form as if it had been parsed from source for use in bridging to another language
11:03:40 <lyxia> blankhart: https://hackage.haskell.org/package/base-4.12.0.0/docs/Type-Reflection.html#v:typeRepKind ??
11:04:34 <freeman42x> I created: https://github.com/razvan-panda/snowdrift/blob/upgrade-ghc-and-libraries/cabal.project but when I am building the project I think that `stack build` is still using the package on hackage instead https://gist.github.com/razvan-panda/4cc3c341d6150e1ca06e584267672587
11:06:20 * ski sometimes uses form feed in source
11:06:36 <mniip> the report conveniently omits a description
11:08:27 <MarcelineVQ> freeman42x: stack doesn't use cabal.project files, it uses stack.yaml
11:12:00 <MarcelineVQ> freeman42x: https://docs.haskellstack.org/en/stable/yaml_configuration/#extra-deps
11:12:14 <blankhart> lyxia thank you!
11:20:14 <freeman42x> MarcelineVQ, doh, thank you! dunno why I was going for the .project file
11:20:38 <freeman42x> @karma+ MarcelineVQ
11:20:38 <lambdabot> MarcelineVQ's karma raised to -8765.
11:21:04 <freeman42x> -8765? MINUS 8765? we have on under/overflow here
11:26:40 <MarcelineVQ> :>
11:34:58 * hackage to 1.2.0 - Simple, safe, boring type conversions  https://hackage.haskell.org/package/to-1.2.0 (Artyom)
11:43:24 <hexagoxel> mniip: https://www.haskell.org/onlinereport/haskell2010/haskellch10.html#x17-17800010.3
11:44:12 <mniip> where's anything regarding vertical tabs in there?
11:44:50 <hexagoxel> "Tab stops are 8 characters apart."
11:45:07 <monochrom> That's for horizontal tabs.
11:45:40 <monochrom> Or alternatively, what does "8 characters" mean vertically?
11:46:54 <nshepperd> 8 lines, maybe
11:47:42 <hexagoxel> sorry, i have no idea
11:48:57 <nshepperd> i would hope that the compiler should treat it as equivalent to whatever combination of newlines and spaces makes it appear the same way as a vertical tab usually renders
11:49:28 <nshepperd> although i just checked and emacs just renders it as a little VT
11:50:26 <monochrom> Yeah I would love to bet that vt becomes nl's, and Haskell is not particularly sensitive to nl's, so it doesn't matter how many.  But the question was not about my bet.
11:53:17 <hexagoxel> ghc seems to interpret them like a single space
11:53:49 <monochrom> w00t I'm going to indent with VTs now!
11:54:20 <EvanR> source code with horizontal and vertical transposed
11:54:39 <EvanR> if japan won the war... might have happened
11:54:49 <monochrom> haha
11:55:22 * hpc . o O ( the sysadmin's haiku )
11:57:57 <lavalike> > isSpace '\x0b'
11:58:01 <lambdabot>  True
11:58:22 <freeman42x> any suggestions? https://github.com/commercialhaskell/stack/issues/5008
11:58:30 <monochrom> > isSpace '\n'
11:58:33 <lambdabot>  True
12:01:02 <mniip> indeed it seems to be equivalent to a single space
12:01:07 <mniip> empirically
12:01:14 <lavalike> the code uses isSpace almost everywhere
12:01:56 <mniip> lavalike, the behavior of \t and \n is drastically different from that of ' '
12:02:04 <lavalike> for sure
12:02:17 <monochrom> isSpace is almost informationless on this.
12:02:42 <monochrom> I mean we are not looking at the difference between '0' and VT.
12:03:05 <monochrom> Confirmation bias is hardcoded in the brain.
12:05:46 <lavalike> https://github.com/ghc/ghc/blob/1befd2/compiler/parser/Lexer.x#L206
12:06:50 <lavalike> \v seems to be handled on its own
12:07:11 <lavalike> I don't know! maybe your answer is close to here
12:08:02 <lavalike> some of the issues linked from that source are funny https://gitlab.haskell.org/ghc/ghc/issues/7650
12:08:15 <monochrom> Oh hehe
12:10:16 <tdammers> dmwit: ah, oh, hmm. then the documentation is maybe somewhat suboptimal.
12:16:54 <Zemyla> I kind of wish that, in addition to the standard RandomGen, there was a MutableRandomGen with like nextST :: g s -> ST s Int and splitST :: g s -> ST s (g s)
12:17:07 <Zemyla> And that the Random typeclass supported it as well.
12:17:42 <EvanR> mutable state but you have to pass generators around anyway... how annoying
12:19:37 <freeman42x> anyone got a link to a cabal.project file that contains an example of how to specify using a package at a specific version?
12:35:58 <slack1256> freeman42x: isn't just specifies 'containers == 0.5.4,' on build-depends enough?
12:36:29 <slack1256> You could also search on hackage for the cabal file of any package and see how the build-depends are specified.
12:41:51 <freeman42x> slack1256, it is called `build-depends` for a .cabal file but I think it is called something different for a cabal.project file
12:53:31 <slack1256> packages:
12:53:31 <slack1256>   lib/irc-core.cabal
12:53:31 <slack1256>   bot/irc-core-bot.cabal
12:53:31 <slack1256>   hookup/hookup.cabal
12:53:31 <slack1256>   glirc.cabal
12:53:33 <slack1256> optional-packages:
12:53:35 <slack1256>   config-schema/
12:53:37 <slack1256>   config-value/
12:53:59 <slack1256> At least the cabal.project files I've seen, they are a simple enumeration of the subprojects on a directory, see above.
12:54:08 <heatsink> Please don't paste multi-line text here.  You can put it on a pastebin and link to that
12:56:03 <slack1256> ok
12:57:08 <isovector1> has anyone managed to get a self-compiled version of the ghc package working as a dependency in a project managed by stack?
13:00:20 <freeman42x> if I do a stack build on this project: https://github.com/razvan-panda/postgresql-simple-migration-patches/blob/stack-build-failure/stack.yaml it gives following error: https://gist.github.com/razvan-panda/792ded51844fa90c6c13e259beed59e6
13:08:25 <freeman42x> created a ticket for it: https://github.com/commercialhaskell/stack/issues/5009
13:08:37 <freeman42x> is there a haskell stack support irc channel?
13:08:43 <boxscape> What's the point of adding a MonadPlus category when it doesn't really add any methods over what Monad and Alternative already have?
13:09:11 <boxscape> and I'm not sure why I said category
13:09:12 <boxscape> I mean class
13:10:18 <Zemyla> It's a legacy class, back before Functor was a superclass of Monad and Applicative existed.
13:10:28 <boxscape> I see
13:15:10 <slack1256> I remember there were different laws between Alternative and MonadPlus. Moreover, the community didn't reach a consensus on what the MonadPlus laws ought to be.
13:15:20 <boxscape> hm, interesting
13:15:56 <boxscape> having the Alternative methods as default implementations for the MonadPlus methods sounds problematic if the laws are different
13:16:37 <boxscape> freeman42x #haskell-stack exists apparently
13:17:54 <MarcelineVQ> boxscape: idk about now but back when I was in that channel there wasn't much in the wasy of activity
13:18:32 <MarcelineVQ> I guess that's not that useful a thing to add
13:19:16 <freeman42x> @karma+ boxscape
13:19:16 <lambdabot> boxscape's karma raised to 3.
13:19:33 <boxscape> neat, I didn't even know I had 2 karma before
13:20:05 <freeman42x> boxscape, shut up and take all of my karma! つ ◕_◕ ༽つ
13:20:10 <boxscape> okay
13:20:18 <MarcelineVQ> @karma+ boxscape
13:20:18 <lambdabot> boxscape's karma raised to 4.
13:20:22 <boxscape> :o
13:20:31 <MarcelineVQ> at this rate you'll be karma king by thursday
13:20:36 <boxscape> hell yeah
13:29:22 <maralorn> Does the bot somehow/somewhere print karma highscores?
13:31:17 <MarcelineVQ> in a list? dunno, you can ask about levels by not adding + though, /msg lambdabot @karma maralorn
13:34:44 * ski would prefer not
13:35:56 <lavalike> @karma-all
13:35:56 <lambdabot>  blah                 31337
13:35:56 <lambdabot>  egrep                31337
13:35:56 <lambdabot>  zgrep                31337
13:35:56 <lambdabot>  C/C                  2091
13:35:57 <lambdabot>  nobody               2000
13:35:59 <lambdabot> [6603 @more lines]
13:36:18 <MarcelineVQ> ski: I was also hoping it wasn't a think, appearantly it is though hehe
13:36:21 <MarcelineVQ> *thing
13:37:51 <heatsink> lots of karma bestowed on C/C++, probably stolen from poor C--
13:47:48 <monochrom> Those 31337s look like made up. :)
13:48:41 <MarcelineVQ> I thought at first it was a 2^15 cap or but that's not quite right
13:48:49 <boxscape> they're just the karma elite
13:48:55 <monochrom> 31337 is a prime number!
13:49:07 <MarcelineVQ> and also means elite
13:49:12 <monochrom> 2^15 is 32768
13:49:30 <monochrom> Yes I have 2^n memorized for up to 16.
13:49:35 <monochrom> I mean up to n=16.
13:49:38 <boxscape> @more
13:49:38 <lambdabot> Plugin `more' failed with: Prelude.init: empty list
13:50:35 <boxscape> so 2^2^2^n up to n = 2
13:51:00 <monochrom> Um that's not quite the same
13:51:05 <boxscape> it's a subset
13:51:18 <ski> (itym `2^2^2^2^2^n' up to `n = 0')
13:59:58 * hackage regex-applicative 0.3.3.1 - Regex-based parsing with applicative interface  https://hackage.haskell.org/package/regex-applicative-0.3.3.1 (RomanCheplyaka)
14:28:28 <arpl> Hello! Learning Haskell and I was looking at the algebraic properties of (finite) types. Trying to encode it (with data Void for 0, data Unit = Unit for 1, Either for addition, pairs for multiplication and functions for  exponentiation). 
14:28:28 <arpl> Made a typeclass: class Finite a => Cardinality a where cardinality :: Integer
14:28:28 <arpl> with instances like: instance Cardinality a => Cardinality (Maybe a) where cardinality = 1 + cardinality @a
14:28:28 <arpl> and: instance (Cardinality a, Cardinality b) => Cardinality (a -> b)     where cardinality = cardinality @b ^ cardinality @a
14:28:28 <arpl> It works. cardinality @((Bool->Bool), Maybe Bool) gives 12 (2^2 * 3)
14:28:28 <arpl> 2 types are isomorphic if their cardinalities are the same. cardinality @(Either Unit Unit) == cardinality @Bool returns True.
14:28:29 <arpl> So I want to define a function isomorphic :: (Cardinality a, Cardinality b) => a -> b -> Bool
14:28:29 <arpl> How do I write isomorphic a b so it matches up with cardinality @a == cardinality @b?
14:29:09 <dmwit> What's wrong with literally that implementation?
14:29:25 <dmwit> isomorphic _ _ = cardinality @a == cardinality @b
14:29:47 <dmwit> (Which highlights the fact that you don't actually need those arguments, and so could just write `isomorphic :: (Cardinality a, Cardinality b) => Bool`.)
14:30:19 <dmwit> Presumably you already have ScopedTypeVariables on for your `a -> b` instance.
14:30:31 <dmwit> Ah, perhaps you forgot the `forall` in the type signature of `isomorphic`?
14:30:44 <dmwit> isomorphic :: forall a b. (Cardinality a, Cardinality b) => Bool
14:31:14 <arpl> Of course! : )        Got the errors about them not being in scope. And indeed I don´t need the arguments.         Sometimes you stare at something too long.
14:31:14 <arpl> dmwit: Thank you. Now I got things to try.
14:31:47 <dmwit> Forgetting the forall's is like the archetypical ScopedTypeVariables mistake.
14:33:08 <arpl> Used these extensions: {-# LANGUAGE AllowAmbiguousTypes   #-} {-# LANGUAGE TypeApplications      #-} {-# LANGUAGE ScopedTypeVariables   #-}{-# LANGUAGE MultiParamTypeClasses #-}        Will look at forall.         Thanks again.
14:51:27 <dmwit> arpl: By the way, you might like http://hackage.haskell.org/package/universe-1.1/docs/Data-Universe.html#t:Finite =)
14:53:30 <arpl> Will look at that.       The forall did indeed the trick.
14:57:59 <jabyrwock> the Aeson docs say that ToJSON instances "should (but don't need to) specify toEncoding", which surprised me because I hadn't seen much mention of that function elsewhere. is it really something that is expected to be implemented?
14:58:29 <dmwit> It's an efficiency thing.
14:58:39 <dmwit> If you care about efficiency, define it for all your instance.s
14:58:56 <jabyrwock> gotcha
15:07:11 <wroathe> It seems like all of the main data types the GHC library defines as instances of Outputable should also have Show instances
15:07:37 <mniip> it seems so but it's not so
15:07:51 <wroathe> In fact, I'm curious as to why Outputable exists
15:08:06 <mniip> there's a lot of types in GHC that have fields that Outputable doesn't show
15:08:31 <mniip> for various reasons
15:08:40 <wroathe> Well, they obviously need pretty printing to support the various -ddump flags
15:09:05 <wroathe> And Show + newtypes seems like the way to do that
15:09:27 <wroathe> (newtypes to give you more than one projection of the type as a string)
15:09:34 <isovector1> outputable lets ghc do smart things like resizing error message widths
15:09:41 <mniip> that would be too many newtypes
15:10:10 <isovector1> hughes' paper on pretty printers is a worthwhile read
15:10:28 <mniip> consider e.g. a type variable
15:10:46 <mniip> if it's a TcTyVar then it has a TcTyVarDetails
15:10:47 <wroathe> thanks isovector1 , I'll check it out
15:10:59 <mniip> which has an IORef
15:11:08 <mniip> how do you pretty print that?
15:11:22 <wroathe> You either skip it, or print that there's an IO ref here
15:11:40 <isovector1> mniip: yeah, you can just ignore it, which is what the outputable instance does anyway
15:11:47 <mniip> again we're not printing the *structure* of the tyvar
15:11:53 <mniip> we're printing *a tyvar*
15:12:02 <mniip> that's the difference between Outputable of Show
15:12:06 <mniip> and Show*
15:12:38 <isovector1> ehh. there are no rules for what a show instance should look like
15:13:05 <wroathe> The semantics are whatever you define them to be. I'm bringing this up because -ddump-parsed-ast uses showAstData to print a very Show-like representation of the synax tree, but later on -ddump-rn uses Outputable and prints the syntax as you might encounter it in the source file
15:13:07 <isovector1> i'd be willing to bet good money that the reason for outputable is that sdocs compose better and are easier to work with and can do resizable wrapping
15:13:21 <wroathe> I'd prefer to see another Show-like view of the data from the renamer
15:13:58 <isovector1> wroathe: there is showAstData??? amazing. thanks for the tip !
15:14:29 <mniip> yeah I'm saying it's more complicated than just deriving show for everything
15:14:36 <wroathe> Yeah, but that all seems like it should be neatly packaged away behind one typeclass and instances for each "view" you want to see
15:14:45 <wroathe> I'm not saying derive show mniip :P follow along
15:15:28 * hackage S3 0.1.0.0 - Library for accessing S3 compatible storage services  https://hackage.haskell.org/package/S3-0.1.0.0 (HerbertValerioRiedel)
15:15:29 <mniip> maybe you could add an option to Outputtable to make the output more structural
15:16:45 <wroathe> Or you could just define a newtype like newtype DataConsView a, and then an instance of Outputable for the data constructor view of a given type, and thena  SourceView a for a source view, etc
15:17:09 <wroathe> The idea being that a compiler probably has a variety of ways it needs to project the core datatypes as strings
15:17:28 <wroathe> newtype SourceView a, newtype DataConsView a, etc
15:17:59 <wroathe> showAstData should not exist
15:18:02 <wroathe> Is my point
15:18:06 <mniip> the problem is that when you write implementations for these you need to not only unwrap the newtypes, but to also rewrap them in child calls
15:20:06 <isovector1> anyway here's the ppr paper; it's excellent reading: belle.sourceforge.net/doc/hughes95design.pdf
15:21:00 <wroathe> You could also designate a view with a type synonym, right? Using TypeSynonymInstances
15:21:11 <mniip> that sounds worse
15:21:13 <wroathe> Idk, these are just details
15:21:27 <wroathe> The core point is that the pretty printing story in GHC seems messy
15:23:01 <mniip> suppose you have `data D = D [E]` and you have a newtype N that you use to affect how D is pretty printed
15:23:19 <mniip> in Show (N D) you would like to invoke Show (N E), for which you would need to map the N over the list
15:23:37 <mniip> and this only gets worse with more complicated structures
15:23:59 <wroathe> mniip: Focusing on the details of how I'd propose to do it misses the entire point of what I've been saying :P
15:24:18 <wroathe> mniip: I'm just simply stating that the pretty printing story of GHC could be cleaned up a bit.
15:24:29 <wroathe> mniip: If you have an excellent way of doing that then great
15:24:38 <mniip> I'm saying that your proposed benefit doesn't outweigh the implementation costs in my opinion
15:24:53 <wroathe> fair enough
15:25:11 <merijn> wroathe: Improving pretty printing is pretty low priority compared to all the other things GHC devs can be working on, so unless someone contributes it (in a way that doesn't break everyone's long running branches) I don't see it happening
15:26:22 <wroathe> merijn: Agreed. I'm just gauging whether anyone thinks this is worth logging a ticket for.
15:32:11 <wroathe> merijn: Also, as I think about it I don't know that I'd say it is such a low priority that it's not worth doing. Those diagnostic tools the command line offers are pretty valuable to the end user.
15:34:26 <merijn> wroathe: By low priority I mean: No one is getting paid to implement it OR getting papers out of it, so no one who's getting paid to work on GHC will do it. Anyone who *isn't* getting paid will have to care more about improving the prettyprinting than anything else they could/want to contribute to GHC
15:35:21 <merijn> Which is the long way of saying "I wouldn't hold my breath"
15:45:57 * hackage lenz 0.3.1.0 - Van Laarhoven lenses  https://hackage.haskell.org/package/lenz-0.3.1.0 (MatthewFarkasDyck)
16:32:09 <tomsen> wanted to build hie, 3h and 20gb later its still building against lots of ghc version. can i deprecate all version but newest?
16:32:43 <infinisil> tomsen: Deprecate how?
16:33:35 <infinisil> And if you don't want to build it yourself, you could use the cached versions from https://github.com/infinisil/all-hies
16:36:26 <tomsen> i thought there might be a config tool where you select which versions should be build, idk. i'm just guessing. would you recommend nix as haskell env for other distributions than nixos?
16:45:05 <Axman6> tomsen: you can just specify which versions you want. ./install.sh ghc-8.6.5 is basically all you need really (I think, check ./install.sh --help)
16:57:30 <tomsen> thanks for pointing me in the right direction, may i ask, will this install it globally and work with stack projects which have local .stack folders?
17:04:21 <Axman6> it will be installed for your user, not globally to the machine
17:17:50 <tomsen> thats alright, i should read through stack docs
17:24:22 <freeman42y> how do you import a newtype? https://i.imgur.com/WPOPRPK.png
17:25:53 <lyxia> PortNumber's constructor is not exported so you can't import it.
17:26:25 <lyxia> if it were exported that would be imported the same way as any other 'data' type
17:26:32 <monochrom> In general :info tells you more than is exported.  Visible by :info does not mean usable.
17:27:19 <monochrom> this one is exported from Network.Socket.Internal only.  It pays to poke around the docs.
17:33:18 <freeman42y> monochrom, couldn't import it: https://i.imgur.com/79h0npa.png
17:33:37 <monochrom> Phone number? Excuse me?
17:34:03 <monochrom> I be damned if my laptop had a phone number...
17:35:12 <hpc> my laptop's phone number is 127.0.0.1
17:36:26 <freeman42y> tried importing as here and it still does not work: https://github.com/lambdabot/lambdabot/search?q=PortNumber&unscoped_q=PortNumber&type=Code
17:36:50 <monochrom> I think you need sleep.
17:37:38 <hpc> look at the usage information for PortNumber
17:37:46 <hpc> you don't need access to the data constructor
17:37:56 <hpc> (on hackage)
17:38:11 <MarcelineVQ> PortNumber is already in scope (imported) when you import Network.Socket. if you want to create a PortNumber you can use its Num instance. or take advantage of its IsString instance by using OverloadedStrings like the examples show
17:38:33 <MarcelineVQ> the examples meaning https://hackage.haskell.org/package/network-3.1.0.1/docs/Network-Socket.html
17:39:23 <MarcelineVQ> oh maybe it doesn't have OverloadedStrings, lemme doublecheck that. you can use Num at least
17:40:56 <hpc> treating port numbers as strings is only done in the special hell
17:41:26 <hpc> for hackers, and people who forget semicolons in javascript :D
17:41:33 <MarcelineVQ> yeah this example doesn't show that sorry for being misleading, best to stick to fromInteger if you need to make a port yourself
17:51:57 <freeman42y> if I build the project https://github.com/razvan-panda/lambdabot/tree/nix-build I am getting these errors: https://gist.github.com/razvan-panda/8d5be3d2e43fa99759e518eb92929cd9
17:55:28 <lyxia> freeman42y: you are trying to use the data constructor PortNumber, but it's not in scope, instead of "PortNumber . fromInteger" you can write "fromInteger"
17:57:06 <dmwit> freeman42y: lambdabot imports a type constructor named PortNumber, but not a data constructor named PortNumber.
17:58:28 <dmwit> (As an aside, that doesn't affect you in this particular case: network has made a non-idiomatic choice here in that the PortNumber data constructor's return type is not a PortNumber!)
18:03:28 <freeman42y> @karma+ lyxia
18:03:28 <lambdabot> lyxia's karma raised to 15.
18:04:58 * hackage pretty-simple 3.1.0.0 - pretty printer for data types with a 'Show' instance.  https://hackage.haskell.org/package/pretty-simple-3.1.0.0 (cdepillabout)
18:17:56 <freeman42y> is there any tool to convert cabal.project to stack.yaml? even partially, and let the user fill up the rest
18:18:45 <sclv> No, i think
18:19:01 <freeman42y> the opposite exists: http://hackage.haskell.org/package/stackage-to-hackage do we have a co-opposite? (ง •_•)ง
18:22:57 <jusss> :t fmap
18:22:59 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:23:11 <jusss> :t (>>=)
18:23:13 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:23:22 <jusss> how I can get >>= through fmap?
18:24:52 <jackdk> do you mean "define `(>>=)` in terms of `fmap`"? Not possible, in general
18:28:56 <jusss> jackdk: I mean the equality betwen those two or three
18:29:14 <jusss> fmap x x x = >>= x x sort of
18:29:59 <jackdk> I have no idea what you just wrote
18:30:53 <jusss> jackdk: like j <$> i = (pure j) <*> i
18:31:25 <jackdk> oh right yeah you can implement `fmap` using `(>>=)`
18:31:48 <jusss> I'm stucked with a-> m b
18:32:10 <jusss> 'cause there's no such thing in fmap::(a->b)->f a -> f b 
18:33:20 <jusss> :k (>=>)
18:33:22 <lambdabot> error:
18:33:22 <lambdabot>     Not in scope: type constructor or class ‘>=>’
18:33:52 <Axman6> can you turn an a into an m a?
18:34:04 <jusss> Axman6: yeah, with return
18:34:07 <jusss> :t return
18:34:09 <lambdabot> Monad m => a -> m a
18:34:11 <Axman6> (or, can you turn a b into an m b?)
18:34:26 <Axman6> can you turn an a into a b?
18:34:44 <jusss> Axman6: I can't
18:35:10 <Axman6> sure you can, you have a function a -> b
18:35:40 <jusss> "a into a b" ?
18:36:17 <Axman6> that's what a -> b means
18:36:23 <Axman6> take an a, give back a b
18:37:12 <jusss> wait a sec, even if there's a function a->b, how I suppose to turn an a into a->b?
18:37:27 <jusss> 'cause I already have got a->b
18:38:13 <Axman6> no, turn one a into one b
18:38:36 <jusss> Axman6: then yes, f::a->b ,  f a :: b
18:39:12 <jusss> a -> m b, is the part I don't know how to get
18:39:55 <Axman6> so you can turn an a into a b, and you can turn a b into an m b, correct?
18:40:15 <Axman6> you have f :: a -> b, and return :: b -> m b, right?
18:40:25 <Axman6> how can you make a -> m b from those two pieces?
18:40:25 <jusss> Axman6: yeah
18:40:37 <jusss> return (f a)
18:40:44 <jusss> no
18:41:09 <jusss> return (f a) :: m b,  not a -> m b
18:41:40 <Axman6> this is true, but what if you don't give it the a
18:41:51 <Axman6> a small hint: (.)
18:42:27 <jusss> return f :: (a->b) -> m (a -> b)
18:42:56 <Axman6> :t (.)
18:42:58 <lambdabot> (b -> c) -> (a -> b) -> a -> c
18:43:12 <Axman6> what happens if c = m b?
18:43:59 <jusss> Axman6: then how you know c should be m b?
18:44:13 <Axman6> I'm giving you a hind
18:44:16 <Axman6> hint*
18:44:28 <jusss> (b -> m b) -> (a -> b) -> (a -> m b)
18:45:03 <Axman6> do you have a b -> m b? do you have an a -> b?
18:45:45 <Axman6> 9and isn't your goal to make an a -> m b?
18:45:48 <jusss> return b :: b -> m b,  f :: a-> b, so return . f :: a-> m b
18:46:00 <Axman6> looks good to me
18:46:39 <Axman6> thhough, return b :: m b, but return :: b -> m b
18:46:53 <jusss> Axman6: but the question is how you know that we should give m b to c, or that is possible to do that? or how you think about (.) ?
18:47:42 <jusss> this m b instead of c in b -> c is possible? or can I use m a = c?
18:48:03 <dmwit> I suspect first Axman6 solved your puzzle, then backported his solution to use (.), then stared at the type of (.) and lined it up with the solution in his head.
18:48:05 <jusss> (b -> m a) -> (a -> b) -> (a -> m a)
18:48:46 <dmwit> So the answer to "how should I mechanically go from this puzzle description to knowing that I should use (.) and pick c = m b" is "by solving the puzzle first".
18:49:43 <jusss> dmwit: so how and that is ok to use m b instead of c?
18:50:30 <jusss> . x f :: return, and how I get x through . and f ?
18:50:50 <Axman6> well no, it's looking at what I know, and what I need. I always know I have (.), and I know we have pieces like f :: a -> b, return :: a -> m b, and many other functions. Haskell is all about composing functions to make new functions, and (.) is one of the fundamental building blocks we use to do that
18:51:10 <jusss> base on (b -> m a) -> (a -> b) -> (a -> m a),  x . f = return
18:51:54 <dmwit> jusss: I don't understand any of your last three lines.
18:52:55 <Axman6> "so how and that is ok to use m b instead of c?" because any type variable can be specialised to any other type if we like
18:53:06 <dmwit> Why don't I understand "how and that is ok to use m b instead of c?"? The grammar is so bad I can't understand it.
18:53:18 <jusss> Axman6: dmwit use "c = m b" is ok?  what if "c = m a" ? and we get (.) :: (b-> m a) -> (a->b) -> (a -> m a), so x . f = return, so  x = ?
18:53:35 <dmwit> Why don't I understand ". x f :: return, and how I get x through . and f ?"? Because ". x f :: return" isn't sensible: return is a term, and the right-hand side of :: should be a type, not a term.
18:53:57 <jusss> Axman6: sorry, my Englis is not good
18:54:06 <dmwit> Why don't I understand "base on (b -> m a) -> (a -> b) -> (a -> m a), x . f = return"? Because "x . f = return" is not an equation that appeared anywhere else in the discussion.
18:54:10 <and_pete> It feels like jusss’s question is more about variable substitution in a more general sense. And why are we allowed to do it? And perhaps doesnt quite understand that the “a” “b” and “c” themselves are meaningless and could represent any type
18:55:00 <dmwit> jusss: You, the user of (.), get to choose any type you want for c. If you thought it would be useful to choose c = m a, that's allowed. It just isn't useful *here*, and the only way Axman6 knew that was by having chosen how the arguments he wanted before suggesting the hint that c = m b.
18:55:16 <monochrom> This is what's wrong with implicit forall.
18:55:18 <jusss> and_pete: yeah
18:56:09 <and_pete> Where if you choose to replace any of the “c”s that are in the type signature of (.) with a “m b”, that you must do it for all of them. Just like if you replaced an “a” with a concrete type like “Int”, you must then replace all of the “a”s with Int also. etc.
18:56:13 <dmwit> jusss: I am okay with "my English is not good". I will mentally correct it for you as well as I can. I am also trying to stay in simple English in my responses. I will only complain when the bad English prevents me from understanding you.
18:56:15 <jusss> like in math, a + b = c, we can get a = c - b, 
18:56:26 <jusss> so I wonder if x . f = return, what x = ?
18:56:41 <monochrom> + is invertible, . is not
18:57:01 <Axman6> jusss: are you happy with if I have f :: Int -> String, and g :: String -> Bool then I can use (.) :: (b -> c) -> (a -> b) -> (a -> c) by choosing a = Int, b = String and c = Bool, and then using g . f to get Int -> Bool
18:57:57 <Axman6> "Are you happy with" = "do you understand and are comfortable with the fact that"* - probab;ly shouldn't use confusing English :)
18:59:09 <jusss> Axman6: ok
19:00:39 <jusss> monochrom: is there inverse function stuff in hasekll?
19:00:46 <monochrom> No.
19:01:14 <and_pete> contramap? :p
19:01:28 <dmwit> ...is different from inverting a function.
19:01:28 <jusss> monochrom: why?
19:01:52 <jusss> dmwit: not like in math?
19:02:02 <dmwit> What is not like in math?
19:02:11 <dmwit> It is also the case in math that contramap is not about inverting functions.
19:02:16 <monochrom> dmwit was answering and_pete.
19:02:17 <freeman42y> which is usually better for solving stack build package conflicts: "allow-newer" or "stack solver"? (⓿_⓿)
19:02:56 <Axman6> functions in maths aren't invertable. f(x) = 1 isn't invertable
19:03:14 <jusss> ok
19:03:25 <monochrom> Do you really need to solve "x . f = return" for x?
19:03:42 <and_pete> What is it that enables `fmap` to be defined like `fmap f x = x >>= (pure . f)` (or using `return` instead of `pure`), given that the `Functor` instance has to be defined before the `Applicative` and`Monad` instances? That still kind of confuses me.
19:03:43 <jusss> is there possible to do this?
19:03:43 <monochrom> Or is it another case of "x . y = problem"?
19:04:27 <monochrom> and_pete: Your premise of "before" is wrong.
19:04:34 <dmwit> and_pete: Easy. Your claim that the `Functor` instance has to be defined before the `Applicative` and `Monad` instances is incorrect.
19:04:51 <and_pete> Ah that would explain it then.
19:04:56 <dmwit> and_pete: They can be mutually recursive, just like literally every other collection of definitions in Haskell.
19:05:46 <monochrom> You simply cannot bring the chronological definition mindset from C to Haskell.
19:05:53 <and_pete> Right. Mutually recursive is okay, but am I right in my understanding that the `Applicative` instance could not be defined in isolation without `Functor`?
19:06:04 <dmwit> Yes, that understanding is correct.
19:06:06 <monochrom> That is right.
19:06:12 <and_pete> (don’t worry, I don’t know any C :) )
19:06:33 <dmwit> hm
19:06:37 <and_pete> Thanks!
19:06:37 <monochrom> Mutual recursion = Permit forward references.
19:06:40 <dmwit> % data Foo a = Foo
19:06:40 <yahb> dmwit: 
19:06:56 <dmwit> % instance Functor Foo => Applicative Foo
19:06:56 <yahb> dmwit: ; <interactive>:8:10: error:; * The constraint `Functor Foo' is no smaller than the instance head `Applicative Foo'; (Use UndecidableInstances to permit this); * In the instance declaration for `Applicative Foo'
19:07:03 <dmwit> % :set -XUndecidableInstances
19:07:03 <yahb> dmwit: 
19:07:05 <dmwit> % instance Functor Foo => Applicative Foo
19:07:05 <yahb> dmwit: ; <interactive>:10:10: warning: [-Wmissing-methods]; * No explicit implementation for; `pure' and (either `<*>' or `liftA2'); * In the instance declaration for `Applicative Foo'
19:07:10 <dmwit> neat!
19:07:31 <dmwit> You *can* define an Applicative instance in isolation without Functor. Just can't use it until you set up that Functor instance. =)
19:07:33 <monochrom> The most extreme example being: You can define "f MyCtor = 0" at line 3, and postpone the data type that introduces MyCtor until line 1000000.
19:08:01 <monochrom> Furthermore the type signature for f, "f :: MyType -> Int", can postpone until line 100000000000000000.
19:08:25 <dmwit> (Nevertheless, "you can't define an Applicative instance in isolation without Functor" is a good summary of the way people normally write Haskell.)
19:08:53 <monochrom> Think strongly-connected component rather than chain.
19:09:08 <dmwit> monochrom: Might be tough to find a compiler fast enough to use your program if it has that many lines, though. ^_^
19:09:32 <monochrom> Oh I think the intervening lines are all VTs.
19:10:05 <monochrom> OK fine 100000000000000000 takes forever even at 1 line per nanosecond.
19:10:51 <monochrom> 100000000000000000 lines of code is how I create a small black hole when I try to put it on my USB thumb drive.
19:11:49 <dmwit> Perhaps we can design a v. clever sparse filesystem, and a compiler that understands it well enough. But it would be a pretty big engineering effort.
19:12:56 <monochrom> The "strongly-connected component" part is no joke.  It is specified in the Haskell Report.
19:17:30 <jusss> >>= g (return . f) = fmap f g
19:18:09 <jusss> another question in that (.) :: (b-> m b) -> (a->b) -> (a-> m b), and return :: a -> m a, we change to return :: b -> m b, is that ok?
19:20:42 <monochrom> Or you start with  (.) :: (a-> m a) -> (b->a) -> (b-> m a)  in the first place.
19:21:57 <jusss> monochrom: f :: b -> a,  return . f :: b -> m a
19:23:04 <dmwit> Perhaps we should have both explicit foralls *and* explicit type lambdas.
19:23:23 <dmwit> fmap :: forall a b f. Functor f => (a -> b) -> f a -> f b
19:24:12 <dmwit> fmap = /\a -> /\b -> /\f -> \f -> ...
19:24:53 <monochrom> OTOH implicit forall is pervasive in math.  If someone comes to you to say "commutative law for addition: y+x=x+y" you don't go "no no no in my book it's x+y=y+x".
19:25:21 <jusss> ...
19:25:27 <dmwit> Then we can distinguish between `return :: forall a m. Monad m => a -> m a` and `return @b @f :: b -> f b` in the body of `fmap`.
19:26:06 <jusss> I just don't know the rules what I can do or I can't 
19:26:07 <dmwit> (N.B. no forall's in the second one! That's on purpose.)
19:26:33 <jusss> like I don't know we can change c with m b before, 
19:27:28 <monochrom> http://www.vex.net/~trebla/haskell/prerequisite.xhtml#substitution
19:27:32 <jusss> I don't when f :: a->b and return :: a -> m a in (.)::...  we can chage to return :: b -> m b
19:27:44 <and_pete> @jusss: you could also have `f :: something -> else` and `return :: stuff -> somemonad stuff` and `return . f :: something -> somemonad else`. You don’t have to use one letter type variables. You can use longer lower-case words if they’re more descriptive and helpful to you than `a`, `b`, `c`, and `m`.
19:27:44 <lambdabot> Unknown command, try @list
19:28:13 <dmwit> jusss: In the absence of fancy language extensions, I believe the following holds: if you can write `foo :: ... a ... a ... a ...` where the `...`s do not mention `a`, and `a` is literally a lower-case `a`, then you may pick any type (including one with other type variables in it) and replace all the occurrences of `a` with that type.
19:28:37 <dmwit> jusss: This is true of any type variable, not just `a`.
19:28:52 <dmwit> jusss: There is a kinding restriction, of course.
19:29:23 <dmwit> jusss: Saying that the type you pick and the type variable you replace must have the same kind (which is a sort of summary of "how parameterized" the type is).
19:30:01 <dmwit> I was wondering when monochrom would link his substitution writeup. ^_^
19:30:24 <monochrom> haha
19:30:50 <monochrom> substitution is the easy part. there is also unification.
19:32:12 <jusss> dmwit: ok
19:33:08 <jusss> :t (>=>)
19:33:10 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
19:33:16 <jusss> :t (>>=)
19:33:18 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:34:32 <and_pete> this bot does’t handle -XTypeApplications, right?
19:34:56 <jusss> fmap <*> and >>= all the last value have f b, but >=> have (a-> m c), how to do that >>= with (>=>) ?
19:35:06 <jusss> or can?
19:35:21 <dmwit> You know those fancy apps that help you find where you've used a lot of space on your disk? They show a pie chart or similar, with each slice being a directory, and you can click on a slice to get a new pie chart that's just for that directory, again with slices being directory entries.
19:35:31 <MarcelineVQ> and_pete: lambdabot doesn't but yahb can, you can use % to talk to it
19:35:40 <dmwit> Is there something like that for exploring the output of GHC's profiling time statistics?
19:36:27 <jusss> dmwit: ncdu?
19:36:49 <dmwit> I don't want something for finding disk usage. I want something for GHC's profiling output.
19:38:15 <MarcelineVQ> hmm...does sound like something someone would have made with diagrams already
19:39:13 <MarcelineVQ> since all you'd need is a parse and to set the depth to display
19:48:09 <dmwit> Have you ever had that feeling where you need a thing to go 100x faster and you can only think of a way to make it 2x faster?
19:49:57 <Axman6> :'(
19:50:02 <Axman6> that's the feeling
19:50:08 <monochrom> Yes. I need to mark my assignments 100x faster.
19:50:28 <monochrom> I also need to write shell scripts 100x faster. (I am already 100x faster with Haskell.)
19:50:33 <Axman6> monochrom: hire more tutors
19:50:44 <monochrom> Cannot afford.
19:50:51 <Axman6> :'(
19:50:54 <dmwit> Can confirm: 100xmonochrom is v. expensive
19:51:10 <dmwit> And no guarantees you get linear speedup, either.
19:51:15 <Axman6> nah, just 100x second year's
19:51:31 <monochrom> Our second year students are clueless.
19:52:00 <Axman6> Didn't you teach them? :thinking_face:
19:52:18 <jackdk> even with all the warnings about "due diligence" and lucidity? =|
19:52:40 <monochrom> On the C programming exam, I put a question "I give you this binary search tree node struct definition. Part (a): print the keys in decreasing order."
19:53:28 <monochrom> All my colleagues (the profs) and my TAs looked at it and said "dude, monochrom, why are you giving out free marks"
19:53:47 <monochrom> But no, the students had to write 10 lines of code and make sure it's wrong.
19:54:24 <jusss> >=> (return . f) return x = (>>=) (return x) (return . f)
19:54:55 <jusss> can we remove that (return . f) at both side?
19:55:45 <jackdk> why not try it and see?
19:56:35 <dmwit> The equation isn't even right to begin with.
19:56:45 <dmwit> Even after fixing `>=>` -> `(>=>)`.
19:57:37 <jusss> :t (>=>)
19:57:39 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
19:58:14 <jusss> or my fault
19:58:43 <jusss> I thought it was >=> :: (a-> m b) -> (b->m c) -> (a-> m c)
19:59:38 * dmwit squints
19:59:41 <dmwit> It... is.
20:00:46 <jusss> >=> :: (a->m b) -> (b->m c)->(a->m c) can I use b to instead of c here?
20:01:04 <jusss> >=> ::(a->m b)->(b-> m b) -> (a-> m b) is ok?
20:01:58 <jusss> sorry, remove the last ()...
20:03:27 <jusss> >=> end with m c, and >>= end with m b, how to make those two connection?
20:03:32 <jusss> connect
20:04:44 <dmwit> Yes, your proposed substitution is okay.
20:05:20 <dmwit> Including the last () or not is both fine. The function arrow is right associative.
20:05:43 <jusss> return . f :: a->m b
20:05:44 <dmwit> So `S -> T -> U` means exactly the same thing as `S -> (T -> U)`.
20:06:45 <jusss> >=> (return . f) return :: a -> m b, right?
20:07:23 <jusss> f :: a->b
20:10:17 <dmwit> Looks right to me.
20:10:21 <dmwit> Why not ask GHC?
20:10:34 <dmwit> :t \f -> (>=>) (return . f) return
20:10:36 <lambdabot> Monad m => (a -> c) -> a -> m c
20:11:05 <dmwit> So you were close. You just missed a Monad constraint.
20:11:09 <dmwit> (I missed it, too!)
20:12:04 <jusss> x :: a
20:12:44 <jusss> >=> (return . f) return x :: m b :: >>= (return x) (return . f)
20:13:15 <jusss> except that "Monad m =>" where were wrong/
20:17:45 <jusss> :t \x -> (>>=) (return x)
20:17:47 <lambdabot> Monad m => a -> (a -> m b) -> m b
20:23:34 <jusss> dmwit: I don't now how to check this is right or wrong in ghci...
20:24:33 <dmwit> What does "this" refer to in that sentence?
20:24:54 <jusss> >=> (return  . (+1)) 2 first it tells me >=> is not defined, so I import Control.Monad, then it tells me it needs FlexibleContexts, then I :set -XFlexibleContexts,
20:25:25 <jusss> now it tells me no instance for (Show (Integer ->  m0 c0))...
20:25:33 <dmwit> jusss: Try giving 2 a type signature. (You will find it hard, and then you will know what your problem is. I hope.)
20:25:49 <dmwit> (>=>) (return . (+1)) (2 :: {- you fill this in -})
20:26:08 <jusss> dmwit: wait, ghci doesn't now 2 is Int?
20:26:13 <dmwit> Certainly not!
20:26:14 <dmwit> :t 2
20:26:16 <lambdabot> Num p => p
20:26:16 <jusss> or Integer something
20:26:43 <dmwit> > 2 :: Complex Rational
20:26:45 <lambdabot>  error:
20:26:45 <lambdabot>      • No instance for (RealFloat (Ratio Integer))
20:26:45 <lambdabot>          arising from the literal ‘2’
20:26:47 <dmwit> > 2 :: CReal
20:26:50 <lambdabot>  2.0
20:28:06 <jusss> (>=>) (return . (+1)) (2 :: {- Int -})  parse error on input ')'
20:28:07 <jusss> ...
20:28:12 <jusss> what a repl!
20:28:26 <dmwit> (...ah, RealFloat is needed for Complex's abs. Gross.)
20:28:36 <dmwit> jusss: {- -} is for comments
20:28:45 <dmwit> you want (2 :: Int)...
20:29:06 <jusss>  ? Couldn't match expected type ‘b -> m c’ with actual type ‘Int’
20:29:14 <dmwit> Correct. Do you now see what your problem is?
20:30:05 <dmwit> (I am not telling you how to fix things. I am trying to teach you how to fix them yourself. Declaring what type you think things should have to get better error messages is one frequently-used trick for that.)
20:30:34 <jusss> dmwit: I shouldn't use f::a->b = (+1) ?
20:32:05 <dmwit> Are you guessing? If so, can you think of a way to test your guess?
20:33:23 <rajivr___> Would it be correct to think of the definition of Monoid `class Monoid m where` to be equivalent to `class Monoid (m :: *) where` or is there a subtlety that I might be missing?
20:36:00 <jusss> dmwit: actually I don't understand this " ? Couldn't match expected type ‘b -> m c’ with actual type ‘Int’" means... it means I should give it a Int, which it except b -> m c?
20:37:06 <jusss> >=> (return . f) return x :: m b 
20:37:40 <monochrom> rajivr___: Yes it's (m :: *)
20:38:02 <rajivr___> Thanks @monochrom  :-)
20:38:53 <jusss> if f::a->b = (+1) and x ::Int = 2, it suppose that m b should be a function
20:39:39 <jusss> wait, you mean there's no m here?
20:52:28 * hackage Persistence 2.0.2 - A versatile library for topological data analysis.  https://hackage.haskell.org/package/Persistence-2.0.2 (Ebanflo)
20:55:11 <ysangkok> what does "too many pending signals" mean?
20:55:18 <ysangkok> if i remove my FFI call, i don't get the error...
20:55:33 <ysangkok> i read that it is might mean you did a segfault
20:55:47 <ysangkok> can anyone confirm that?
21:29:57 * hackage Persistence 2.0.3 - A versatile library for topological data analysis.  https://hackage.haskell.org/package/Persistence-2.0.3 (Ebanflo)
21:47:55 <isovector1> anyone know what the ghc flag for adding linker flags is?
21:49:51 <Axman6> -optl
21:50:10 <Axman6> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flags.html#forcing-options-to-particular-phases
21:52:05 <dmwit> jusss: No, the other way: you gave it (>=>) an Int, and it expected a b -> m c.
21:52:23 <dmwit> Delete "it" from that sentence, please.
21:52:31 <dmwit> The first one.
22:03:28 * hackage postgresql-simple-interpolate 0.1 - Interpolated SQL queries via quasiquotation  https://hackage.haskell.org/package/postgresql-simple-interpolate-0.1 (3noch)
22:20:53 <isovector1> Axman6: thanks
22:23:09 <Axman6> No worries
23:19:21 <jusss> dmwit: sorry, I really don't understand where I'm wrong, >=> ::(a->m b) -> (b-> m b)->(a->m b) , f::a->b=(+1) , return . f :: a-> m b, return :: b -> m b,  >=> (return . (+1)) return :: Int-> Int-> Int is ok?
23:22:30 <dminuoso> jusss: Perhaps this modification helpsÖ
23:24:38 <dminuoso> jusss: The type checker has to unify the type of the expression you are giving it, with its type signature.
23:25:36 <dminuoso> jusss: "Couldn't match expected type 'someTy' with actual type 'anotherTy'" means you supplied an expression in some spot that GHC expected, for some reason or another, to have type 'someTy', but it was actually of type 'anotherTy'
23:25:59 <dminuoso> % f :: Int; f = "foo"
23:25:59 <yahb> dminuoso: ; <interactive>:12:15: error:; * Couldn't match expected type `Int' with actual type `[Char]'; * In the expression: "foo"; In an equation for `f': f = "foo"
23:26:22 <dminuoso> It expected something of type 'Int' (because of the type signature), but I gave it something of type String/[Char].
23:26:57 <dminuoso> jusss: Does this make sense?
23:27:12 <jusss> dminuoso: yeah
23:28:00 <jusss> dminuoso: (>=>) (return . f) return x = (>>=) (return x) (return . f), is this right?
23:28:40 <jusss> :t (>=>)
23:28:41 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
23:29:04 <jusss> we have already know that return . f :: a-> m b
23:29:35 <jusss> so >=> (return . f) return :: a-> m b
23:29:59 <jusss> x :: a
23:30:12 <jusss> >=> (return . f) return x :: m b
23:30:17 <jusss> :t (>>=)
23:30:18 <lambdabot> Monad m => m a -> (a -> m b) -> m b
23:30:29 <dminuoso> jusss: Please try to use >=> and >>= in infix notation, its much easier to read
23:31:03 <dminuoso> jusss: return is an identity for (>=>). By that I mean ⌜f >=> return = f⌝ for any choice of f.
23:31:14 <jusss> (return x) >>= (return . f) :: m b
23:32:26 <dminuoso> jusss: Did you implement ⌜fmap⌝ in term of ⌜>>=⌝ and ⌜return⌝ by the way?
23:33:00 <jusss> dminuoso: yeah, f <$> x = x >>= (return . f)
23:33:41 <jusss> dminuoso: the hard part is (.) return f :: a-> m b
23:34:12 <dminuoso> jusss: You can, always, start with writing an explicit lambda function. That might be easier to start with. ;)
23:34:14 <jusss> so now, I get j <$> i = (pure j) <*> i  and  f <$> x = x >>= (return . f)
23:35:39 <dminuoso> jusss: Okay. Did you notice that you didn't pick any functor/applicative/monad there? You wrote it generically to work with any choice of them.
23:36:05 <jusss> dminuoso: yeah
23:36:51 <dminuoso> jusss: So for the final task, lets flip it around. Do the same thing you've done for "implement fmap in terms of pure/<*>" and "implement fmap in terms of >>=/return" 
23:37:03 <dminuoso> jusss: Except the task is: implement (>=>) in terms of (>>=)
23:37:21 <dminuoso> jusss: This might be easier than the other way around. We can do what you have been trying to do as the last task, perhaps.
23:37:38 <dminuoso> jusss: Note, no ⌜return⌝ is needed.
23:38:44 <dminuoso> % :t (>=>)
23:38:44 <yahb> dminuoso: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
23:40:06 <dminuoso> jusss: So start by writing ⌜kcomp :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c; kcomp kf kg x = undefined⌝, keep telling yourself what the type of your 3 arguments are, and think about how you could reasonably construct something of type ⌜m c⌝ given what you have, and given (>>=)
23:42:30 <jusss> dminuoso: I don't understand, make m concret?
23:42:39 <dminuoso> jusss: Nope? 
23:42:47 <dminuoso> jusss: Its no different than the first two tasks involving fmap
23:43:16 <dminuoso> jusss: Given that type signature, what's the type of kf inside the definition?
23:43:40 <jusss> dminuoso: kf:: a->m b
23:43:51 <jusss> dminuoso: kg:: b-> m c
23:43:56 <jusss> x:: a
23:44:24 <jusss> kcomp kf kg x::m c
23:49:49 <jusss> :t (>=>)
23:49:51 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
23:50:37 <jusss> let b instead of c,  >=> :: (a->m b)->(b->m b) -> a -> m b
23:50:45 <jusss> :t (>>=)
23:50:47 <lambdabot> Monad m => m a -> (a -> m b) -> m b
23:51:24 <jusss> >=> kf kg x :: m b :: >>= (m a) kf
23:52:19 <jusss> dminuoso: kf (>=>) kg = \x -> (return x) >>= kf ?
23:53:30 <jusss> dminuoso: sorry, I don't know how to get that m a if there's no return 
