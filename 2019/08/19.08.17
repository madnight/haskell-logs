00:59:51 <klntsky> Why isn't there a `throw` function for MaybeT in Control.Monad.Trans.Maybe? Should I use exceptToMaybeT and throwE?
01:03:54 <EvanR> i'm thinking ExceptT is more conventional than MaybeT
01:05:40 <klntsky> EvanR: "conventional" in what sense?
01:07:20 <klntsky> I see no point in passing unit value through the computation with `ExceptT m ()` for example
01:11:27 <dibblego> the monad behaves differently
01:19:22 <EvanR> i mean you wanted to throw something so 
02:00:30 <ap5> In http://haskellbook.com/assets/img/sample.pdf it says to use "let" in REPL to reuse variables, but I can do it without "let". Is the sample outdated, or? It says it in section 2.7: "As we saw above with the triple function, we have to use let to declare something in the REPL."
02:02:22 <dibblego> older versions of GHCi you needed to use let
02:02:32 <ap5> Thanks :)
02:02:48 <ap5> I like to get basics right from the start
02:37:04 <tdammers> this is a fairly new feature, at the time haskellbook was published, you still had to use let
02:41:50 <MarcelineVQ> the sample at least, the book versions I have doen't ask you to use let
02:43:48 <tdammers> ah, OK. that's kind of neat then.
02:57:17 <amosbird> Could not find a ghc to bootstrap with.
02:57:24 <amosbird> heh, there isn't a way to boostrap ghc on android?
03:00:37 <tdammers> there isn't a way to bootstrap ghc out of thin air on anything, you always need a working ghc
03:01:11 <tdammers> to port ghc to a previously unsupported platform, you'd use a cross compiler to bootstrap
03:03:32 <amosbird> ok, I wish there is a shellcheck binary for my android
03:04:49 <__monty__> amosbird: shellcheck.net?
03:07:06 <amosbird> yes
03:07:15 <amosbird> but as a binary not online service
03:07:34 <__monty__> I was suggesting it as the closest thing currently.
04:41:58 * hackage yesod-form-multi 1.6.0 - Multi-input form handling for Yesod Web Framework  https://hackage.haskell.org/package/yesod-form-multi-1.6.0 (Burtannia)
05:07:37 <rsoeldner> Morning, trying to implement servant streaming endpoint combined with postgresql-simple using the `servant-pipes` and `pipes-postgresql-simple` package. Until now I have a resource pool and I used `withResource` to perform my query. Is this still possible\safe for the pipes query ?
05:24:59 <maralorn> I want to write a small script for a system I don‘t administrate. What is the easiest way to install ghc in $HOME and how much space do I need? Wondering if it‘s worth it to do it in Haskell or if I just use python.
05:28:33 <__monty__> A quite check tells me my GHC install is 2.1GB, that's the entire closure though.
05:28:46 <__monty__> *quick
05:58:29 <jusss> can I get >>= with fmap and return or <*> with pure?
05:58:40 <jusss> :t (>>=)
05:58:42 <lambdabot> Monad m => m a -> (a -> m b) -> m b
05:58:47 <jusss> :t fmap
05:58:48 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:58:52 <jusss> :t return
05:58:53 <lambdabot> Monad m => a -> m a
05:59:54 <jusss> the hard part is that a -> m b, how I can transform something to a -> m b?
06:04:57 <tdammers> the documentation for cabal v2-test says to look at the documentation for v2-run for passing additional args to the test suite
06:05:16 <tdammers> the v2-run documentation says to use -- to separate cabal args from args for the target program
06:05:41 <tdammers> but cabal v2-test -- --quickcheck-verbose interprets '--quickcheck-verbose' as a component name
06:05:56 <tdammers> so clearly this is not how it's done
06:06:06 <tdammers> anyone know how it *is* done?
06:40:03 <ap5> let {assignments} in {expressions} i like it :D
06:40:16 <ap5> (i am learning Haskell)
06:42:33 <tdammers> technically it's let {bindings} in {expression}
06:43:52 <tdammers> i.e., you bind variables, nothing gets "assigned" in the usual sense, you just bind names to definitions
06:45:02 <tdammers> and it's "expression" (singular), because having more than one expression there wouldn't make sense - the only thing you can meaningfully do with an expression is evaluate it, but since evaluation has no side effects, having multiple expressions means you can only use the value of one of them
06:48:05 <__monty__> Though a single expression can contain multiple expressions.
06:53:47 <ap5> tdammers, ok. Thanks.
07:39:17 <freeman42x> how can I create 2 `Gen a` values to pass to this function? https://gist.github.com/razvan-panda/a8a80e5bb362c3f4c36773ebe4f62f64#file-hedgehog-fn-hs-L44
07:50:24 <freeman42x> how can I hoogle for what `Gen a` is?
07:51:08 <fendor> @hoogle Gen
07:51:09 <lambdabot> Test.QuickCheck data Gen a
07:51:09 <lambdabot> module Test.QuickCheck.Gen
07:51:09 <lambdabot> Test.QuickCheck.Gen newtype Gen a
07:53:06 <fendor> freeman42x, https://hackage.haskell.org/package/QuickCheck-2.13.2/docs/Test-QuickCheck.html#t:Gen ?
07:53:35 <freeman42x> fendor, `Gen a` from the hedgehog library, not from QuickCheck
07:54:04 <freeman42x> I could clone the hedgehog source and search the files of `Gen a` but being able to know how to hoogle for it would very useful
07:55:01 <fendor> @hoogle Gen module:hedgehog
07:55:01 <lambdabot> Hedgehog type Gen = GenT Identity
07:55:01 <lambdabot> module Hedgehog.Gen
07:55:01 <lambdabot> module Hedgehog.Internal.Gen
07:55:24 <fendor> https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog-Gen.html
07:57:36 <freeman42x> fendor, thank you! that's nice that you constrain hoogle to search specific modules
07:58:02 <fendor> freeman42x, yeah, there is quite a lot of syntax you can use, unfortunately hard to disover
07:58:22 <fendor> also interesting is "is:exact" which searches for the exact term, not just roughly the term
08:00:58 * hackage I1M 0.0.1 - Code for the Haskell course taught at the University od Seville.  https://hackage.haskell.org/package/I1M-0.0.1 (Jose_A_Alonso)
08:07:31 <freeman42x> fendor, based on the results from hoogle. can you tell how to construct a `Gen a` value?
08:10:54 <dmwit> freeman42x: If you know it's in a particular package, and Hoogle doesn't index that package, you can visit its documentation on Hackage and click "Index" to get an alphabetical listing of defined names.
08:11:18 <dmwit> http://hackage.haskell.org/package/hedgehog-1.0/docs/doc-index-G.html
08:15:34 <freeman42x> How to create a value of the Haskell hedgehog type `Gen a`? https://stackoverflow.com/q/57537503/750216
08:17:13 <fendor> freeman42x, i dunno, maybe there is some documentation for it
08:17:52 <freeman42x> fendor, I tried to find that documentation but could not. Anyway, answering that question will be useful to others
08:19:48 <fendor> freeman42x, main documentation has an example on how to create and use generators https://hackage.haskell.org/package/hedgehog
08:20:04 <fendor> the README not the main documentation
08:20:55 <freeman42x> fendor, the readme example just shows concrete generators, not how to get a `Gen a`
08:21:53 <__monty__> freeman42x: There's a bunch of ways to get generators in Hedgehog.Gen
08:22:25 <__monty__> You can't create an abstract "Gen a" for any "a" though.
08:22:31 <fendor> freeman42x, how would you create a Gen a? Or what should a Gen a do? You have to create a concrete Generator at some point.
08:23:47 <freeman42x> I have my concrete question in the link above. if I don't need a `Gen a` value then what can I pass to get that test working?
08:25:29 <fendor> freeman42x, 
08:26:22 <fendor> freeman42x, you have to create generator that produces values that are instances of the given typeclasses. In this case `Vary`, `Arg`, `Eq` and `Show`
08:26:52 <freeman42x> fendor, ok, but how do I do that?
08:27:35 <fendor> do you know of a value that is an instance of all these type classes?
08:30:35 <freeman42x> fendor, I don't know what being an instance of Vary or Arg means. I will have a look at their definitions
08:32:28 <freeman42x> fendor, so, the type Int is an instance of these typeclasses: `Vary`, `Arg`, `Eq` and `Show`. Does that imply that I need an Int generator?
08:32:49 <freeman42x> as one possibility I mean
08:32:52 <fendor> yes
08:33:10 <freeman42x> cool, I just need to figure out how to get a Gen of Int
08:34:30 <fendor> freeman42x, maybe `fun_cong_equality (Gen.int32 (Range.linear 1 100)) (Gen.int32 (Range.linear 1 100))`?
08:34:51 <freeman42x> fendor, so I can use `Gen.int :: MonadGen m => Range Int -> m Int` but I don't know yet how to create a `Range Int`
08:35:34 <fendor> freeman42x, Range.linear 1 100 seems to define a range between 1 and 100
08:35:50 <fendor> look at https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog-Range.html for more Ranges
08:36:24 <freeman42x> fendor, it doesn't work, hmm: https://i.imgur.com/0gS1nyg.png
08:40:54 <freeman42x> fendor, lol, I am so silly, DOH, this works: fun_cong_equality (Gen.int (Range.linear 1 100)) (Gen.int (Range.linear 1 100))
08:41:08 <freeman42x> fendor, thank you very much for your help. Want to provide an answer on SO?
08:41:37 <fendor> freeman42x, the ($) made a difference? 0.o did not expect that. 
08:41:57 <fendor> you can answer it on SO, if you want to
08:42:09 <fendor> since you now know it
08:44:15 <freeman42x> fendor, ok, I will then
08:44:59 <__monty__> fendor: The second $ means you're trying to apply the first Gen to the second.
08:45:34 <fendor> @type ($)
08:45:36 <lambdabot> (a -> b) -> a -> b
08:46:34 <fendor> __monty__, yeah, absolutely right. still got me
08:47:38 <__monty__> I agree the error message isn't clear though. I'd expect it to complain about Gen not being a function.
09:18:27 * hackage I1M 0.0.2 - Code for the Haskell course taught at the University of Seville.  https://hackage.haskell.org/package/I1M-0.0.2 (Jose_A_Alonso)
09:39:41 <lavalike> ^ neat, my first year cs course wasn't as cute https://www.cs.us.es/~jalonso/cursos/i1m-18/temas/tema-0.html
09:46:20 <mreh> https://gist.github.com/mrehayden1/8f32f2718825a86ef677cddd189fac65
09:46:42 <mreh> do I need to give GHC some help with this definition, I'm doing the sized vector tutorial
09:49:42 <lavalike> what is sized-vector-tutorial?
09:50:32 <mreh> lavalike: it's a folder on my filesystem
09:50:35 <mreh> https://www.schoolofhaskell.com/user/konn/prove-your-haskell-for-great-safety/dependent-types-in-haskell
09:50:56 <dmwit> mreh: Yes, you need to do an actual pattern match on cons (rather than just the wildcard pattern) for GHC to learn that it's okay to apply init.
09:51:05 <dmwit> mreh: Otherwise it doesn't know that `xs` has a non-zero length.
09:51:44 <dmwit> (The `Nil` case tells it that `xs` has a zero length. But that doesn't imply that the length can't be zero in other cases, too.)
09:52:36 <mreh> dmwit: oh, how interesting
09:54:24 <dmwit> You might wish that `_` gets expanded out into one case for each constructor not yet listed, this bringing into scope on the right-hand-side of -> any evidence carried by the constructors not yet listed.
09:54:29 <sm> I think I'll cc this here.. did y'all know about yesod's LiteApp ? no TH/QQ/boilerplate, a tiny api, but the full power of yesod-core still available. https://termbin.com/8c1h
09:54:42 <dmwit> But this isn't done, because not all other patterns may be well-typed, and it's tough to know in advance which will be and which won't.
09:57:53 <mreh> dmwit: my experience tells me that there's only one pattern left, so it should be about to work it out
09:58:27 * hackage express 0.1.2 - Dynamically-typed expressions involving applications and variables.  https://hackage.haskell.org/package/express-0.1.2 (rudymatela)
10:01:38 <dmwit> mreh: GADTs introduce something seriously new to the world of pattern matching.
10:02:13 <dmwit> And again: it's not clear *before* typechecking is done whether that one additional pattern will even be well-typed.
10:02:14 <mreh> dmwit: right... that's what's different
10:10:39 <fog> im trying to build a package from hackage but it says it was before applicative was a superclass to monad
10:11:17 <fog> but when i download the source tarball and with mingw64 write; cabal new-install it says "up to date"
10:13:05 <fog> also, the package is the dependency of another package im trying to install from hackage, will a local install satisfy its dependencies if i add applicative instances and solve the error above?
10:14:52 <tdammers> fog: which package are we talking?
10:15:01 <fog> any
10:17:16 <fog> also, its strange because it asks that --allow-new be supplied during the install from hackage, but throws no version errors when running install in the dowloaded directory
10:17:57 <fog> (im just downloading manually by getting the tarball from next to where it says "browse" on the hackage contents page for the package)
10:19:12 <fog> why would it not complain about the version or the lack of applicative superclasses in the local install?
10:20:18 <tdammers> that sounds very strange
10:20:25 <MarcelineVQ> cabal/stack update
10:20:27 <tdammers> also there isn't a package named "any" afaik
10:21:39 <fog> im on windows and have mingw64 terminal installs which may be conflicting with installs from the windows terminal, and versions built without the "new" flag 
10:23:32 <fog> and also an old version of ghc which i uninstalled and tried deleting the %appdata% cabal directory after a reinstall of the haskell platform didnt solve a previous error that might have been to do with these conflicting installs... it somehow managed to import the same package from two different locations and failed terribly 
10:24:30 <fog> so its either a problem with my system or with not understanding how to do local cabal installs
10:24:56 <fog> MarcelineVQ: i ran cabal update but the problem persists 
10:24:58 <MarcelineVQ> This is the point where people need to see what you see to say anything more, e.g what cli things you typed and what you got from them. -any means any version, if that's what you're seeing
10:25:11 <tdammers> indeed
10:25:14 <aveltras> has anyone encountered the error "haskellPackages.multi-ghc-travis has been renamedto haskell-ci, which is now on hackage" while using the nix haskell infrastructure ?
10:25:55 <fog> MarcelineVQ: thats assuming its a problem with my setup
10:27:41 <fog> i think its to do with local cabal installs
10:28:28 <fog> perhaps it would be easier to answer the question about if i can locally install a dependency after having added the new superclasses
10:28:34 <fog> that has nothing to do with my machine
10:29:05 <MarcelineVQ> I think it's a pixie, or a brownie maybe, some some sort of faery that's sprinkling problem dust all over the computer case. But we can check and see if the problem is elsewhere first since other things would be simpler to solve.
10:29:07 <fog> (and have this local install visible globally to future hackage cabal installs)
10:30:12 <fog> i guess its a pretty general problem about old packages and changes to the supperclasses
10:30:32 <fog> monad applicative and monoid semigroup cause bitrot in these old packages
10:31:26 <fog> it would be good to understand how to locally replace a dependency which fails to install since these instances are trivial to insert
10:32:23 <MarcelineVQ> yes that is a good skill to have
10:33:11 <fog> MarcelineVQ: good idea, i would like to be sure i understand whats going on with cabal before i resort to reinstalling windows, especially since cabal seems to be causing conflicts quite often since i dont really understand what its doing
10:34:14 <fog> MarcelineVQ: its possible then? 
10:34:59 <MarcelineVQ> what is?
10:35:05 <MarcelineVQ> oh, local changes? yeah
10:35:15 <MarcelineVQ> for instance with stack I'd get the thing via stack unpack foo, I'd open foo and make my changes, and then I'd put the path to foo under extra-deps: in my stack.yaml
10:35:29 <MarcelineVQ> I'm not sure what the process is with cabal-install but it shouldn't be too dissimilar
10:35:54 <fog> but with installing from hackage you wouldnt be able to change the projects yaml
10:36:15 <fog> or is that some local path setting?
10:36:43 <fog> in which case wouldnt i just be able to add the locall install directory to the windows path in the environmental variables?
10:37:32 <fog> and does that then imply that the locall install cannot simply be visible globally like the installs from hackage are?
10:38:12 <fog> (this seems to be the case, as opeing ghci and typing :m to try and access the locally installed packages doesnt work)
10:40:02 <fog> i tried the -lib option in the hope it would make writing cabal new-install in the downloaded directory perform a globally visible install, but this did not work
10:41:13 <MarcelineVQ> don't install from hackage if that route won't work for you. unpack, or 'get' in cabal's case, make your changes, and install from that if you need to install something. You really should't be installing libs globally though if that's what your doing, install is best used for executables
10:42:03 <fog> thats what i was doing...
10:42:19 <fog> well except the "get" part, thats nice
10:42:53 <fog> why do you say trying to install globally isnt advised?
10:44:01 <fog> its default using install from hackage (writing it in any directory other than the downloaded dir with the Setup file at the top) 
10:44:20 <fog> i tried doing "runhaskell Setup" but that didnt work either
10:44:55 <MarcelineVQ> installing libraries globally. but I've still no idea what you're actually typing so I can't say if you're doing things in a normal way
10:46:18 <fog> i said i cd into the directory and type cabal new-install
10:47:04 <fog> it says up to date... i cant see how this can be the case, it shouldnt build at all as i havnt written the instances it needs yet!
10:47:42 <fog> oh, i add the --allow-new option to the cabal install
10:48:10 <fog> and --lib so it doesnt complain about executables 
10:48:47 <fog> i type cabal new-clean
10:49:08 <fog> and then cabal install again (with the options), and it still says up to date!
10:50:09 <fog> even rm the dist dir and it still says "up to date"
10:50:44 <MarcelineVQ> huh.. I don't understand why new-insall would have a --lib option in the first place so I'm a little confused
10:52:19 <MarcelineVQ> That's my own confusion I should mention, it's not something you said
10:52:22 <fog> new-build seems to get it to build its dependencies, but then when it fails to build the actual package new-build starts getting all the packages again like if it didnt install them at all
10:52:52 <fog> so i was having to cd into a different directory and get the dependencies by installing from hackage so they were visible globally
10:53:07 <MarcelineVQ> As in I'm the impression that the new- commands are project-centric so I don't understand why there's a notion of 'installing libraries' at all
10:53:33 <Boarders> just to check if I have a primitive vector of Word8's I know Word8 is stored as a machine sized word but in this case I assume they are tightly packed in a bytearray?
10:53:39 <fog> ah right yeah, i did notice that i was having to not use the new prefix if i wanted things to install properly
10:54:23 <dmwit> MarcelineVQ: v2-install --lib exists so that you can use libraries in ghci outside of a project.
10:54:41 <fog> wait is v2 not the same as new?
10:54:49 <dmwit> v2 is the preferred name for new.
10:54:54 <dmwit> Because it isn't new any more. =)
10:54:58 <fog> fair
10:55:00 <dmwit> And who knows, eventually there may be a v3!
10:55:14 <dmwit> And then it would be even weirder to keep saying new.
10:56:37 <MarcelineVQ> dmwit: ghci, or cabal new-repl?
10:56:40 <fog> so if i want to "cabal get", then cd into the dir and run v2-install --lib, then i should be able to cd somewhere else and open ghci and import the module using :m ? (thats what i mean it is "globally" visible, like it would be off hackage) 
10:57:16 <dmwit> MarcelineVQ: ghci
10:57:34 <dmwit> fog: Something like that, yes.
10:57:35 <fog> yeah, and also, this thing with new-build getting all the dependencies again seems to imply its just building locally
10:57:53 <fog> how do i get it to build them globally too?
10:58:16 <MarcelineVQ> dmwit: does that mean --lib adds them to the package db?
10:58:59 <dmwit> fog: Have you been taught the distinction between local packages and external packages?
10:59:19 <fog> something to do with the path?
10:59:32 <fog> "taught" ?
10:59:34 <dmwit> MarcelineVQ: It adds them to an environment file. It is not clear to me why we need to distinguish between environment files and package dbs, but there we are.
10:59:46 <dmwit> fog: https://www.haskell.org/cabal/users-guide/nix-local-build.html#local-versus-external-packages
10:59:47 <fog> im not sure i have exhausted every permutation yet...
10:59:58 <fog> NIX!?
11:00:00 <fog> no 
11:00:04 <fog> cabal...
11:00:07 <dmwit> fog: local package build artifacts are not shared between projects. external package build artifacts are.
11:00:15 * dmwit sighs
11:00:20 <dmwit> fog: Just... click it, please.
11:01:09 <fog> should i just move something from the "dist" dir into the %appdata% cabal dir?
11:01:27 <MarcelineVQ> dmwit: And it does this in a way that doesn't cause the original dependency issues v2 stuff was intended to stop? I don't know much about this part of things so that question's a bit vague.
11:02:28 <dmwit> I'm not sure. I don't have much experience with them. I believe yes: during constraint-solving, version coherence is checked. But I am only maybe 60% confident of this.
11:05:36 <fog> ok that seems to say that cabal new-install makes exes global 
11:05:57 <fog> and that the --lib should put it in the %appdata% globally visible path with a hash
11:07:01 <fog> ooh, there is even a --store-dir option 
11:07:16 <MarcelineVQ> dmwit: alright, just seems strange. from a UX perspective I understand somewhat. but in something like stack when you type stack ghci your ghci does get access to the local store of packages that's been built up over different installs and resolved dependencies, but only for the snapshot version in the settings relevant to that stack ghci invocation. so either the one your project has or the global stack yaml. You don't affect plain 
11:07:17 <MarcelineVQ> ghci whatsoever
11:13:02 <fog> well all this doesnt explain why cabal new-install --lib says up to date even when cabal new-build complains about the missing superclasses
11:14:04 <fog> oooh, it needed an "all" 
11:15:19 <fog> ok, so having provided the instances and performing; cabal new-install all --lib --allow-new
11:15:37 <fog> it says it builds the module instead of just claiming to be up to date
11:16:39 <fog> but then cd into another directory, opening ghci and :m says;  Could not find module .. It is not a module in the current program, or in any known package.
11:17:36 <fog> i checked in; \AppData\Roaming\cabal\x86_64-windows-ghc-8.6.5
11:17:55 <fog> and there is no sign of the module
11:20:24 <fog> the module has appeared locally in; dist-newstyle\build\x86_64-windows\ghc-8.6.5
11:21:18 <fog> but it does not look like it can simply be copied to the appdata global directory because it does not have a hash as part of its directory name as a suffix
11:21:49 <fog> i dont want to just copy it over incase the hash actually corresponds to something it checks
11:22:27 <fog> however, if its just a randomish number to make it likely to be unique, then i can just give it a made up suffix thats kind of random?
11:24:34 <fog> right, well that doesnt work!
11:25:03 <fog> opening ghci and trying :m says; Could not find module
11:31:06 <fog> argh, the --store-dir just specifies where to get packages from, not where to place them
11:31:15 <dmwit> fog: cabal v2-install --lib doesn't affect what dependency decisions cabal v2-build makes at all.
11:31:41 <dmwit> fog: In particular, installing a modified library does not convince v2-build to use the modified library instead of drawing from what's on Hackage.
11:31:41 <fog> yeah, it would have to somehow place it in the store-dir
11:32:00 <dmwit> fog: The store is not consulted during dependency resolution.
11:32:14 <dmwit> So storing things there does not affect what dependency decisions v2-build makes.
11:32:37 <fog> it must be otherwise how would it know you already had some packages installed?
11:32:49 <dmwit> That check happens after the dependency decisions are made.
11:33:33 <fog> thats ok, i just need to to see that the locally modified and globally installed library is to be used in the installation of subsequent installs from hackage
11:33:59 <fog> so i need a flag to give to new-install that puts them in the store 
11:34:10 <fog> (thats what i thought --lib was doing, its not...)
11:34:25 <dmwit> That is what --lib is doing.
11:34:35 <dmwit> But you're not listening to what I'm saying.
11:35:00 <dmwit> What libraries are globally installed *does not change* the decisions made about what libraries to actually use.
11:35:06 <fog> it doesnt place the package in %appdata% its still ending up in dist-newstyle
11:35:15 <dmwit> Installing something globally just does not affect where it chooses to get its code from.
11:36:12 <dmwit> It affects *only* whether it has to invoke the compiler on the code it got, or can reuse a cached result.
11:36:53 <fog> well i figure the reason it does not reinstall libraries is because it checks in the %appdata% store to see which packages are installed globally... oh, maybe there is some log that needs to be updated also
11:37:05 <dmwit> If it is choosing to get the code from Hackage, then *nothing* you do locally to build a modified version of that and put it in the store or anywhere else on your disk will have any effect on whether it chooses to get its code from Hackage instead of your modified source.
11:37:22 * dmwit sighs
11:37:36 <dmwit> I tried. I don't know any more ways to spell this that will connect with you better. Somebody else will have to try.
11:37:57 <fog> there must be something i can do to get it to use a locally built library instead of a dependency from hackage
11:38:19 <fog> dmwit: dont be exhasperated, i understood what you say
11:38:22 <dmwit> Yes, you may use a local package instead of an external package. See my link above.
11:38:49 <dmwit> The build artifacts created in this way will not be shared across projects.
11:39:12 <fog> so there is no flag to make them be shared?
11:39:22 <dmwit> You could set up a local package repository.
11:39:28 <dmwit> There are also instructions on that at the documentation I linked.
11:39:38 <fog> so nix is the only way?
11:40:48 <fog> i coulndt see any instructions to do this here; https://www.haskell.org/cabal/users-guide/nix-local-build.html#local-versus-external-packages
11:41:06 <dmwit> https://www.haskell.org/cabal/users-guide/installing-packages.html#repository-specification
11:41:10 <dmwit> It isn't nix.
11:41:14 <dmwit> You haven't read carefully.
11:41:39 <dmwit> You have looked at the URL and made a snap assumption that isn't correct.
11:42:01 <fog> !
11:43:44 <fog> so does it use the %appdata% store as a repository?
11:43:54 <dmwit> No. The store is not a repository.
11:44:03 <dmwit> Repositories have source code. The store has binaries.
11:44:49 <fog> oh, well i wanted to place the .o and .a files in the %appdata% so when downloading from hackage it would check to see that its dependencies were satisfied
11:46:19 <fog> but they end up in dist-newstyle and cabal only check this if im in the directory with the cabal.project file
11:46:22 <fog> (ghci too)
11:48:14 <fog> i can see eg. lib-dir options, but i would prefer to just be able to place the locally built packages in the appdata so they are treated the same way as if they had been installed from hackage
11:48:34 <fog> oh, you mean maybe if i build from a local repo it will place them there?
11:48:58 <fog> seems like a hack...
11:49:08 <fog> would that even work?
11:53:51 <fog> it says i should use runhaskell Setup to build a binary
11:54:21 <fog> but it says ;
11:54:23 <fog>  Could not load module `Distribution.Simple'
11:54:42 <fog> runhaskell Setup configure -package Cabal
11:54:48 <fog> gives the same error...
11:55:13 <fog> i cant see how i could use :set at the command line...
12:00:47 <fog> even with the --global option it still places everything in the newstyle-dist directory
12:01:34 <fog> oh that option must just be if its being installed from hackage
12:01:55 <fog> seems like the local repo hack might be the only option
12:02:01 <fog> i wonder if it would work...
12:02:25 <fog> i would have thought Setup would work but there is no mention of a fix on the stackoverflow post
12:02:55 <dmwit> Did you even read the documentation I linked you?
12:03:01 <fog> yes!
12:03:34 <fog> which part do you think would be the solution?
12:03:37 <dmwit> Okay. Then what `repository` lines did you add to your cabal config?
12:04:00 <fog> ok, lets try this
12:05:07 <dmwit> (FWIW, I think this way forward is not smart. It's much simpler to just use local packages for something like this. The cost of rebuilding occasionally will never come close to the cost you have already sunk in avoiding the rebuilds.)
12:05:37 <fog> but i cant change the online version
12:05:50 <dmwit> (...and you are not more than halfway to having done the work you need to do to avoid rebuilds.)
12:05:59 <dmwit> fog: I agree with that.
12:06:11 <fog> this seems like the only way to use bitrotten code since the applicative monad and semigroup monoid proposals 
12:06:30 <dmwit> I don't know what "this" refers to in your latest message.
12:06:53 <fog> well at the minute nothing has worked so far
12:07:14 <fog> so "this" is your proposal of hacking it with a local repo, which seems like a decent idea
12:07:23 <dmwit> Just add `packages: /path/to/your/fixed/package/source` to `cabal.project.local` in the project you want to use the fixed source in.
12:07:37 <dmwit> Then be on your way.
12:07:40 <tydeu> Question: Why are the results of Template Haskell splices affected by the RebindableSyntax extension? It seems more logical to leave them unaffected  (just like derived instances). 
12:07:53 <dmwit> That is the smart way. This local repo stuff is not the smart way.
12:08:11 <fog> that wont work!!
12:08:14 <fog> i cant do that
12:08:15 <dmwit> It is the way I am recommending to conform to your demands, which I believe are misguided.
12:08:25 <dmwit> Why can't you do that?
12:08:27 <fog> because the things being downloaded are off hackage
12:08:38 <fog> that would mean i would have to "get" everything 
12:08:43 <dmwit> They will not be downloaded off Hackage if you do what I suggest.
12:08:56 <fog> yeah, thats not a solution
12:09:00 * dmwit shrugs
12:09:01 <MarcelineVQ> exaclty how many packages have this problem you're trying to change?
12:09:17 <MarcelineVQ> What are you downloading that's so broad yet out of date
12:09:35 <dmwit> I'm completely lost, honestly.
12:09:45 <dmwit> You still have to get everything to fix it to run a local repo.
12:10:07 <fog> ah, so there is no decent infrastructure to support bitrotten revamps because for anything important it would be done at the hackage level instead of locally
12:10:07 <dmwit> In fact, you still have to get everything to fix it, period, no matter what solution you use for linking against that code afterwards.
12:10:51 <dmwit> (Or, like... how were you imagining fixing code without having a copy of it?)
12:11:27 <fog> i just wanted to fix one broken dependency of another install from hackage
12:11:37 <dmwit> So just do that.
12:11:50 <__monty__> dmwit: The old meta-X-butterfly?
12:11:54 <fog> instead of having to build everything downstream of the broken install by manually downloading it first
12:11:57 <dmwit> Grab a copy, fix it, add the path to your fixed source to cabal.project.local, and move on with your life.
12:12:00 <dmwit> I don't get it.
12:12:52 <MarcelineVQ> you want to fix dependency X of package Y? did you try bumping version bounds in Y?
12:12:53 <fog> i guess the problem is then that everything that depends on this lib would need to communicate with it locally
12:13:07 <fog> ie, i would have to place it in a cabal.project
12:13:21 <fog> and have the source directory adjacent or with a lib flag
12:13:21 <dmwit> Correct.
12:13:55 <fog> if i could just change the upstream dependency like with the local repo hack, then i can get the downstream lib off hackage and it will just work as normal
12:14:13 <fog> a much nicer development environment than having to use cabal.project files
12:14:25 <fog> eg; it would be visible in ghci anywhere
12:15:02 <fog> i guess there is some ghci flag in some global ghci config i could set but if it just installed from hackage i wouldnt need to worry about that
12:16:24 <fog> so whats the protocal for renovating bitrotten libraries?
12:16:40 <fog> do you just upload it again with a different name?
12:17:15 <shapr> you could NMU it if you have a hackage account
12:17:18 <MarcelineVQ> often there's a git repo for a package and you can make an issue or PR there
12:17:19 <shapr> or if the author is active, put up a PR
12:17:28 <fog> or can you just add new versions to a hackage repo without needing to contact the maintainer that has left a project abandoned for 6 years!
12:18:17 <fog> shapr: im not a hackage trustee!
12:19:02 <MarcelineVQ> which project is this?
12:19:14 <fog> i guess this might be more of a thing trying to backpack things
12:19:36 <fog> there were some crypto primatives for eliptic curves
12:19:57 <fog> the new haskoin-core switched to using c libs
12:20:24 <fog> but there is nice pure haskell code at Network.Haskoin.Util
12:20:54 <fog> i was trying to backpack compare the c libs against the pure code
12:21:39 <fog> it seemed like a good test case, as these primatives are frequently resort the C code
12:22:03 <fog> and the FFI libs can be backpacked to switch the dependencies to pure haskell code
12:23:26 <fog> oh wait, thats the upstream dependency
12:23:32 <MarcelineVQ> I just meant what was the package name you were downloading :>
12:23:45 <fog> just haskoin, not haskoin-core
12:23:55 <fog> a dead branch from ages ago
12:24:03 <fog> but with pure implementations...
12:24:08 <dmwit> What am I doing wrong here? https://gist.github.com/dmwit/51bc849f792f8540204c53c00c7e5226
12:25:08 <dmwit> Oops, I meant to include the cabal version there, too. Anyway it's 2.4.1.0 (executable and Cabal both), which I believe is the latest release.
12:26:54 <fog> the C libs are a pain to build on windows, but they provide good unit test for trying to gather together these different implementations from different projects - which is what i was trying to develop a backpack process to do
12:27:22 <MarcelineVQ> given that it's an exception and repl is afaik still in flux you're probably not doing anything wrong <_<
12:28:21 <dmwit> ...oh
12:28:56 <fog> the worst part is that C, pearl, ruby and python libs all bundled up into command line exes then need bash scripts to provide the input args to sequence them together
12:29:00 <dmwit> Okay, yeah, v2-build is working fine. I never even considered the possibility that it was v2-repl specifically that was going wrong.
12:29:05 <dmwit> That's fine then, I guess.
12:29:13 <dmwit> v2-exec ghci should still be ok
12:31:34 <davean> dmwit: there is 3.0.0.0 out
12:33:05 <dmwit> davean: Not listed here? http://hackage.haskell.org/package/cabal-install
12:33:08 <cocreature> Cabal 3.0 is out, cabal-install 3.0 isn’t
12:33:36 <lavalike> how do you check what cabal install cabal new-install cabal-install will install?
12:33:39 <tydeu> Take a look at this magic: https://gist.github.com/tydeu/9ecdf536ba397cd85215ca811525ca7c
12:34:03 <davean> lavalike: cabal info
12:34:17 <lavalike> thanks
12:34:42 <dmwit> lavalike: --dry-run
12:35:04 <lavalike> that works too (:
12:35:09 <davean> if yo uwant the full install plan
12:35:28 <lavalike> curious info says "Versions installed: [ Unknown ]"
12:35:34 <davean> I guess its how you parse lavalike's ambiguous grammar 
12:35:52 <lavalike> >:)
12:37:03 <fog> so what happens if i rebuild these old libs with the new superclasses and then want to put something on hackage that depends on them?
12:38:08 <fog> do i need to just copy the parts of the libs i need into the source code of the current project - or redeploy a copy of the old libs, or get a trustee to fix the superclasses...
12:38:52 <davean> you can submit patches ot the maintainers, or request a package takeover if the maintainer is absentee
12:39:07 <fog> i dont want to have to maintain a fully fledged version of a dependency library just to use one of its functions in a project...
12:40:00 <fog> and if they were actively developing the project it wouldnt be this out of date...
12:40:19 <davean> you say that
12:40:37 <fog> well i guess they just moved to a newer branch
12:41:18 <davean> I've found packages last updated in 2009 with active git repos and 6 year old "get a new upload on hackage, its long overdue"
12:41:32 <davean> I've found people using stack basicly unaware of new GHC releases ...
12:41:38 <davean> life is weird
12:42:53 <MarcelineVQ> just as a note, it's not quite abandoned or out of date, it's deprecated. meaning there's an intention that people move onto something else, not a lack of maintaining
12:46:02 <MarcelineVQ> or not _just_ a lack of maintaining, depending on your pov
12:46:52 <fog> right, the point is *they* didnt want to have to maintain the primatives either!
12:47:09 <fog> so they moved to a branch with FFI dependencies instead
12:47:45 <fog> there is something about immutable foreign libraries that is reassuring to people 
12:48:01 <fog> "well if i cant change it, it cant break" kind of thing
12:49:06 <fog> especially since its normally just part of a very complete collection that is ever needed
12:49:42 <fog> i guess then there is the question about FFI'ing all the function calls and making a decent library or just accessing those needed
12:50:47 <fog> then there is the whole, cabal vs built-utils automake etc
12:51:08 <fog> i guess thats probably one of the biggest barriers to haskell in industry
12:51:44 <fog> people actually dont code in particular languages, they just need the shared libraries to build in part of their toolchain
12:53:27 <fog> but from a haskell perspective, using command line exes via System.Process is not really good for anything except testing comparison outputs
12:54:06 <fog> i guess i could FFI into the libs, but thats crazy difficult, with all kinds of new errors to get used to
12:54:22 <fog> i dont even know what a dll is for...
12:55:32 <fog> even locally building these FFI libs is throwing errors iv never seen before when the firectory structure for the cabal project isnt right
12:57:11 <fog> pure haskell is defiantly the way forward, but i wonder how it is for people trying to incorporate haskell libs in their toolchain... mingw has pacman ffs! windows development is really hard
13:34:36 <Zemyla> Should Down have an instance of Bounded?
13:35:00 <Zemyla> instance Bounded a => Bounded (Down a) where { minBound = Down maxBound; maxBound = Down minBound }
13:35:48 <lavalike> what's Down?
13:36:12 <Boarders> What's the easiest way with Vector make all unit vectors of dimension n for unknown Integer n
13:36:15 <Zemyla> It's a newtype whose primary use is that compare (Down a) (Down b) = compare b a.
13:36:50 <Boarders> i.e. e_1 = (1,...,0), ..., e_n = (0,...,1)
13:37:28 <lavalike> ah interesting I usually end up using the Monoid Ordering instance when I want to do that
13:38:08 <Zemyla> I also kind of want Ix (Down a) to be defined such that range (Down u, Down l) = fmap Down $ reverse $ range (l, u).
13:39:24 <lavalike> seems like it would work
13:59:36 <wildtrees> is there a way using do notation, but not <- syntax to thread the results of one computation into another? 
14:00:36 <JoelMcCracken[m]> you can use >>= alongside do notation
14:00:40 <JoelMcCracken[m]> is that wahat you mean
14:02:44 <wildtrees> would I want to put the >>= at the front of a line or the end, or does it matter? 
14:04:44 <iqubic> Has anyone tried doing Machine Learning in Haskell?
14:04:54 <iqubic> Are there any good resources for that?
14:06:04 <iqubic> it seems like, if you build the library the right way, you should be able to encode the structure of the neural net solely in the types
14:06:24 <__monty__> iqubic: There's something out there that does so.
14:06:37 <__monty__> You'll have to break out the google-fu though.
14:06:41 <iqubic> Oh. I see.
14:07:33 <tydeu> Why does `:k $(return $ UnboxedTupleT 32)` give the error 'A 64-tuple is too large for GHC' in GHCi? Shouldn't `UnboxedTupleT 32` be a 32-tuple?
14:11:46 <iqubic> __monty__: I just found like 4 things.
14:11:52 <iqubic> http://dpaste.com/209Q2C0
14:13:29 <iqubic> Not sure which of those is the best.
14:14:09 <__monty__> Me either : )
14:26:25 <turab> >:i (>>=)
14:26:31 <turab> :i (>>=)
14:26:36 <turab> hm
14:28:10 <Fendor> @type (>>=)
14:28:12 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:28:14 <Fendor> @src (>>=)
14:28:14 <lambdabot> Source not found. Just try something else.
14:28:33 <turab> wildtrees: >>= is used as an infix function
14:29:04 <turab> Not sure how you are using it so can't say where exactly it will go in your usage
14:29:11 <wildtrees> yea I am working on using a StateT transformer stack now to thread the results 
14:49:58 <jle`> iqubic: check out the datahaskell people there are alot of comparisons on there i think
14:50:19 <jle`> and also i talk about statically typed trainable models and NN's in a few blog posts
14:51:26 <MarcelineVQ> grenade is the something out there
14:51:28 * hackage to 1.1.0 - Simple, safe, boring type conversions  https://hackage.haskell.org/package/to-1.1.0 (Artyom)
15:11:27 * hackage verifiable-expressions 0.6.0 - An intermediate language for Hoare logic style verification.  https://hackage.haskell.org/package/verifiable-expressions-0.6.0 (mdanish)
15:14:06 <d34df00d> Hi!
15:14:22 <d34df00d> Can I combine exception handlers nicely, if they catch the same exception type?
15:15:06 <d34df00d> Let's say I have an HTTP exception handler that deals with 403 errors, and another one that handles response timeouts. Looking at `catches`, looks like it'll just try the first handler listed.
15:15:26 <d34df00d> Do I have a better option than nesting the handlers and rethrowing the exception if it cannot be handled?
15:16:36 <d34df00d> I basically want a hybrid of `catches` and `catchIf`.
15:42:09 <hexagoxel> d34df00d: Unfortunately I cannot figure out if this exists. But you can just implement the hybrid, it is not that hard.
15:43:06 <hexagoxel> data CondHandler a = forall e . Exception e => CondHandler (e -> Maybe (IO a))
15:47:12 <d34df00d> hexagoxel: yeah... It's getting a bit messy once you have a catch-all exception handler (for a given error type, like a generic HTTP error logger) — the logic of blindly doing foldr/foldl no longer works.
15:47:15 <d34df00d> But I guess I'll figure it out.
15:48:23 <d34df00d> I guess I could just use msum and assert that most specific handlers come first.
15:48:27 <d34df00d> s/assert/require/
15:48:59 <hexagoxel> well yeah, it is order-dependent if it is overlapping. Just like regular `catches` is (although there is less risk of accidental overlaps for that, I suppose)
15:50:56 <dmwit> What do you do if a handler you try throws an exception? Keep scanning, start over?
15:51:24 <d34df00d> It shouldn't really, so I don't care (or, in other words, I rethrow).
16:05:21 <oats> speaking of which, could someone recommend a good exceptions tutorial? No idea where to start with those; been meaning to get around to them for a while
16:07:14 <jle`> oats: my favorite has been the exceptions chapter in Parallel and Concurrent Haskell
16:07:52 <jle`> er, parallel and concurrent programming in haskell
16:08:13 <jle`> the entire book is available online for free :)
16:12:08 <koala_man> amosbird: yeah, too bad the armv6hf binary doesn't work
16:12:27 <koala_man> it uses some syscall Android doesn't like, but I haven't narrowed down which
17:11:33 <dmwit> I have a partial order (which I'm interpreting as "how good a solution is").
17:11:53 <dmwit> I'd like to maintain a set of candidate solutions, with the property that no element of the set is strictly less than any other.
17:12:14 <dmwit> So they'll all be pairwise incomparable. I think.
17:12:27 <dmwit> Is there a good data structure for doing this efficiently?
17:12:36 <dmwit> Or will I have to know special properties of my partial order to do it well?
17:14:15 <dmwit> (What do I want to happen if I try to insert an element that would violate the invariant? I want to temporarily violate the invariant, then restore it by deleting any element which is strictly greater than another. It shouldn't matter what order these deletions are done in, I think?)
17:20:09 <MarcelineVQ> I'm the wrong person anyway but I'm not sure I get the last part, if you had [5,5,5] and you inserted 4, you end up with [4] ?
17:20:20 <dmwit> yep
17:20:52 <argent0> also the wrong person. So you only use the fact that you have a partial order when you insert
17:21:05 <dmwit> I'm willing to use more facts.
17:21:23 <dmwit> The specification of what I want only needs a partial order, but if efficiency demands that I have more structure than that, I'm listening.
17:23:51 <argent0> (the wrong person) so the only relations would be a <= a, and the partial order would be "trivial" like [5,5,5]
17:24:09 <argent0> forall a*
17:24:19 <dmwit> err?
17:24:28 <dmwit> There's a binary relation. We can call it <= if you want.
17:24:44 <dmwit> It certainly satisfies forall a. a <= a; and transitivity, too.
17:24:56 <dmwit> I don't know what "the partial order would be 'trivial' like [5,5,5]" means.
17:26:27 <argent0> y mean discrete. where all elements are related only to themselves. Given your requirement that "no element of the set is strictly less than any other."
17:26:52 <dmwit> I want to maintain a subset of the complete poset that has that property.
17:27:33 <dmwit> Anyway no, my partial order definitely won't be discrete.
17:27:36 <shapr> is there a cabal command that will create a cabal.project file? hmmm
17:27:50 <dmwit> shapr: cabal v2-configure will create a cabal.project.local file.
17:27:59 <shapr> oh nice!
17:28:04 <argent0> ok, I understand better now
17:28:08 <shapr> dmwit: you have all the answers! yay!
17:28:11 * shapr hugs dmwit
17:28:14 <dmwit> cheers!
17:28:37 <shapr> gosh that was easy
17:29:15 <shapr> I always forget the format of those files, I wish it would give me a commented out something like it does for "informative cabal file comments"
17:29:44 <dmwit> Yeah. I am constantly trying to find examples I've already written to cargo cult.
17:29:51 <shapr> yeah, me too
17:30:03 <shapr> is a cabal.project.local the same as a cabal.project?
17:30:09 <dmwit> Yep.
17:30:16 <shapr> thanks!
17:30:25 <dmwit> Well, same format. Different meaning.
17:30:56 <shapr> oh?
17:31:31 <dmwit> The cabal.project file is supposed to reflect what's needed to build the thing properly; meanwhile the cabal.project.local is supposed to be for tweaks needed on your specific development system.
17:31:37 <shapr> hm, I wonder if I can convince cabal to generate me a test-suite stanza as well
17:31:38 <shapr>  
17:31:41 <shapr> oh, I see
17:31:54 <dmwit> So cabal.project.local overrides cabal.project if they both exist. And you generally shouldn't check .local into your revision control, e.g.
17:32:06 <shapr> that's helpful, htanks
17:43:00 <freeman42y> any ideas how to fix this? https://gist.github.com/razvan-panda/b9e48aba7397dcbef8fb752505ce8acd
18:01:28 <freeman42y> ^ nvm, issues does not happen in latest stack version
18:11:17 <freeman42y> actually, it does throw the same error but much later in the process
18:11:18 <amosbird> koala_man: hmm, where can I find that binary?
18:19:01 <freeman42y> I created a stack bug report for it: https://github.com/commercialhaskell/stack/issues/5005
19:05:16 <amosbird> hmm, how can I cabal install <package> using static-build?
19:10:09 <dmwit> What is static-build?
19:10:47 <amosbird> I've finally setup an android-ghc
19:10:53 <amosbird> I'd like to build a static binary of https://github.com/koalaman/shellcheck
19:11:08 <amosbird> what's the command of using cabal to do that?
19:14:02 <freeman42y> amosbird, I think you would need to change its cabal file to use the static field and then build it: https://www.haskell.org/cabal/users-guide/cabal-projectindex.html
19:14:26 <amosbird> https://la.wentropy.com/OSq5
19:14:33 <amosbird> hmm, the error looks weird
19:15:48 <freeman42y> amosbird, what is inside: /home/androidbuilder/.cabal/logs/ShellCheck-0.7.0.log ?
19:17:35 <amosbird> very much useless https://la.wentropy.com/Lfds
19:24:17 <amosbird> how can I supply that `static` flag into .cabal file?
19:28:29 <dmwit> "Ignoring unknown section type: custom-setup" suggests to me that you may be using an older Cabal (or possibly older cabal-install) than is needed by shellcheck.
19:32:01 <amosbird> ok, does cabal provide a way to upgrade itself?
19:32:37 <shapr> cabal new-install Cabal ?
19:32:54 <sclv> Well you want the exe not the lib
19:33:01 <amosbird> cabal: unrecognised command: new-install (try --help)
19:33:13 <shapr> oh, older Cabal
19:33:16 <sclv> cabal install cabal-install
19:33:57 <amosbird> cabal: The following packages are likely to be broken by the reinstalls: hackage-security-0.5.2.2 HTTP-4000.3.7
19:33:58 <sclv> or use yr package manager of choice for a binary pkg
19:34:23 <sclv> what os/distro?
19:34:28 <amosbird> cabal install Cabal somehow works
19:34:40 <amosbird> ubuntu
19:34:47 <amosbird> it's a customized ghc for android
19:35:03 <amosbird> docker  toktoknet/ghc-android:latest.aarch64
19:35:58 <sclv> idk what the latest "official" ubuntu is but you can download a generic linux binary from here https://www.haskell.org/cabal/download.html
19:36:01 <sclv> or use ghcup to get one
19:37:23 <dmwit> amosbird: The usual fix for that is to just tag them on the end of the command.
19:37:31 <dmwit> cabal install cabal-install hackage-security HTTP
19:37:48 <dmwit> Toss on the version numbers too for good measure.
19:37:49 <amosbird> doesn't work
19:37:53 <amosbird> it says Use --force-reinstalls if you want to install anyway.
19:37:59 <dmwit> cabal install cabal-install hackage-security-0.5.2.2 HTTP-4000.3.7
19:38:03 <dmwit> Don't use --force-reinstalls.
19:38:19 <amosbird> ok
19:38:25 <amosbird> it's installing
19:40:04 <amosbird> heh, https://la.wentropy.com/xe7k
19:41:24 <sclv> amosbird: just download a binary, i think your toolchain may be a bit too old/weird to bootstrap simply
19:42:24 <amosbird> sclv: will it break the android toolchain?
19:42:55 <sclv> don't delete the old cabal binary, just in case
19:42:59 <sclv> and it won't mess with ghc
19:43:09 <sclv> its just a build tool, so its independent of any of that
19:44:12 <amosbird> oh
19:45:51 <amosbird> it seems the cabal downloaded is too new
19:45:53 <amosbird> cabal: symlink-bindir is not defined. Set it in your cabal config file or use
19:46:06 <sclv> what are you doing with it?
19:46:16 <amosbird> install shellcheck
19:46:24 <sclv> it tells you what to do tho
19:46:35 <sclv> you can either pass in the parameter for where to symlink the exe into
19:46:44 <sclv> or set symlink-bindir in your ~/.cabal/config file once and for all
19:47:49 <amosbird> hmm,  cabal: filepath wildcard 'shellcheck.1' does not match any files.
19:48:07 <amosbird> that is from  "<new-cabal> new-install shellcheck
19:49:12 <amosbird> btw, any hero could try this?   docker -it  toktoknet/ghc-android:latest.aarch64 bash   and  then   cabal install shellcheck?   it's very easy to reproduce
19:50:02 <sclv> are you sure you shouldn't say ShellCheck instead of shellcheck?
19:50:30 <amosbird> it's the same
19:51:51 <sclv> for me the uncap version doesn't even find the pkg to install
19:52:35 <amosbird> sclv: hmm, lemme try the original cabal
19:52:40 <amosbird> the new cabal yields the same error
19:52:56 <sclv> are you trying to install it from hackage or from somewhere else?
19:53:12 <amosbird> I guess it's hackage
19:53:22 <amosbird> I'm not sure, all I did is that docker command
19:53:22 <sclv> ok i'm building it now on os x and it seems to be fine
19:53:27 <amosbird> hmm
19:53:32 <sclv> cabal 2.4.1.0
19:53:47 <sclv> there's no globbing in the cabal file: https://hackage.haskell.org/package/ShellCheck-0.7.0/ShellCheck.cabal
19:54:00 <amosbird> sclv: what command do you use to install?
19:54:42 <dmwit> An error message only a programmer could love. https://gist.github.com/dmwit/9b4a60fca3da09f65b5820e74243ee73
19:55:40 <sclv> amosbird: cabal new-install  ShellCheck --symlink-bindir=.cabal/bin/
19:55:47 <amosbird> sclv: ok, can you try building a static one?
19:55:58 <sclv> idk how to do that
19:56:04 <sclv> so, no :-)
19:56:53 <amosbird> I'm trying to find out how to do that. From the doc https://www.haskell.org/cabal/users-guide/nix-local-build.html#cfg-field-static  but I really don't know how to supply that flag
19:58:14 <heatsink> It bugs me that Show is supposed to format exceptions as human-readable text, because it's supposed to format everything else as a Haskell expression
20:01:05 <sclv> It only works with ghc 8.4 or above, so idk if you have that?
20:02:34 <dmwit> heatsink: Me, too. They even added a displayException to the Exception class... but then they don't use it when it comes time to display an exception. WTF
20:05:12 <amosbird> sclv: ...
20:05:15 <amosbird> I don't
20:55:56 <slack1256> It there a restricted IO datatype just for pure computations that should be able to catch (not just throw) exceptions?
20:56:54 <argent0> a transformer?
20:57:30 <argent0> ExceptT
21:19:45 <slack1256> Mmm yes but it is not what I am looking for. (Except e) works well as a monad if `e` is fixed. On IO you have extensible exceptions
21:27:32 <jackdk> slack1256: I was going to say MonadCatch but it requires MonadThrow: https://hackage.haskell.org/package/exceptions-0.10.0/docs/Control-Monad-Catch.html#t:MonadCatch
21:28:10 <jackdk> are we talking about exceptions exceptions or "exceptions" as in "I want error handling behaviour in my monad"?
21:29:38 <slack1256> I just want to signal that some pure functions can fail with unspecified errors on its type signature. EitherT always get bind to a single exception type where IO is extensible
21:30:48 <jackdk> can you back up a step for me?
21:30:59 <jackdk> I'm not 100% clear on what you're trying to do
21:32:08 <jackdk> if the problem you're solving is "I have different parts of my application that want different errors in their ExceptT and eventually I want to unify them", then classy prisms are a great way to do that: https://www.youtube.com/watch?v=GZPup5Iuaqw
21:32:24 <slack1256> That is exactly my problem
21:32:41 <slack1256> I was thinking on an open union type but it seems curbersome
21:32:53 <slack1256> but declaring all the possible errors upfront also is
21:34:23 <jackdk> so the approach in that talk I linked does end up with a top-level `data AppError = DBError DBError | PermissionError PermissionError | ...`, but the classy prisms avoid the boilerplate you are probably fearing from having to wrangle DBErrors up into AppErrors etc
21:34:38 <jackdk> I have used it in a medium-sized codebase and been very happy with it
21:35:05 <slack1256> Mmmm I will see the video now
21:35:12 <slack1256> thank for the reference
21:35:52 <jackdk> You get type signatures that look like `(MonadError e m, AsDbError e) => ... -> m ()` which roughly means "this monad might throw `DbError`s into `e`, but doesn't care what `e` is beyond that. 
21:36:07 <jackdk> I'm heading out for a bit, leave a ping if you've watched the vid and things are unclear
21:36:47 <dmwit> I mean, you can also just steal the IO exception mechanism wholesale and use `Except SomeException`.
21:40:00 <slack1256> !! you are right!
23:54:58 * hackage hmatrix-vector-sized 0.1.2.0 - Conversions between hmatrix and vector-sized types  https://hackage.haskell.org/package/hmatrix-vector-sized-0.1.2.0 (jle)
