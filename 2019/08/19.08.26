00:34:18 <jusss> dminuoso: and now I don't know about Monoid now
00:34:44 <jusss> dminuoso: x <+> (y <+> z) ~~~ (x <+> y) <+> z  what is <+> and ~~~ ?
00:34:45 <dminuoso> jusss: In my gist, do you see there's a sort of repeating pattern?
00:34:53 <dminuoso> jusss: <+> is plus from that excercise earlier
00:35:22 <jusss> dminuoso: yeah that pattern, like (a b) c = a (b c) in my way
00:35:25 <dminuoso> jusss: And ~~~ is just a different way of writing ≃
00:35:30 <dminuoso> jusss: that is "is isomorphic to"
00:36:01 <dminuoso> jusss: And the identity laws too!
00:36:39 <dminuoso> jusss: Without the identity laws this pattern of: f `op` (g `op` h) = (f `op` g) `op` h  is called Semigroup
00:36:42 <dminuoso> And indeed:
00:36:46 <dminuoso> % :i Semigroup
00:36:46 <yahb> dminuoso: class Semigroup a where; (<>) :: a -> a -> a; GHC.Base.sconcat :: GHC.Base.NonEmpty a -> a; GHC.Base.stimes :: Integral b => b -> a -> a; {-# MINIMAL (<>) #-}; -- Defined in `GHC.Base'; instance [safe] Applicative f => Semigroup (Traversed a f) -- Defined in `Control.Lens.Internal.Fold'; instance [safe] Monad m => Semigroup (Sequenced a m) -- Defined in `Control.Lens.Internal.Fold'; instance [s
00:37:13 <dminuoso> Semigroup has the law: f <> (g <> h) = (f <> g) <> h
00:37:23 <dminuoso> Monoid takes Semigroup and adds the identity laws.
00:38:15 <jusss> dminuoso: wow, semigroup!
00:39:13 <jusss> dminuoso: the identity laws have something to do with "unit" ?
00:39:17 <dminuoso> jusss: Right.
00:39:28 <dminuoso> jusss: Here's a simple example every school kid knows:
00:39:47 <dminuoso> jusss: Addition of integers has a unit, such that adding that number on either side doesn't do anything. Which integer is that?
00:40:00 <[exa]> reality correction: s/knows/really should know upon leaving the school/
00:40:01 <jusss> 0
00:40:05 <jusss> dminuoso: 0
00:40:15 <dminuoso> jusss: Good. Is addition of numbers associative?
00:40:41 <jusss> dminuoso: yeah, (a+b)+c=a+(b+c)
00:40:52 <jusss> also a+b=b+a
00:40:56 <dminuoso> jusss: In other words, addition over integers is a monoid (where 0 is the identity/unit)
00:41:19 <dminuoso> jusss: Sure, that is called commutativity. Lets ignore that for now.
00:41:28 <jusss> and 1 is the identity on multiple?
00:41:43 <dminuoso> jusss: You tell me.
00:42:14 <jusss> dminuoso: yeah?  a x 1 = a, sorry my English is not good
00:42:25 <dminuoso> jusss: That's the right identity, good. Test the left identity too.
00:42:52 <jusss> 1 x a = a?
00:42:56 <dminuoso> jusss: Right. 
00:43:10 <jusss> dminuoso: but that's like a+b=b+a
00:43:13 <dminuoso> jusss: It may not be obvious, but sometimes you only have a one-sided identity, Ill show you an example in a moment.
00:43:22 <jusss> dminuoso: a x 1 = 1 x a
00:43:36 <dminuoso> jusss: Well yes, that's only because integer multiplication happens to be commutative.
00:43:38 <jusss> commutativity
00:43:52 <dminuoso> There exist examples where ⌜a * b /= b * a⌝, but where * is still a monoid.
00:44:03 <dminuoso> (Note that * just denotes some operator, not necessarily multiplication)
00:44:16 <jusss> dminuoso: wait
00:44:26 <jusss> dminuoso: the operation is the monoid?
00:44:34 <jusss> operator
00:44:59 <dminuoso> jusss: Well if we are very precise, then you'd say the tuple of "the operation, the set and the empty/unit/identity/zero element" is called the monoid.
00:45:15 <dminuoso> jusss: But sometimes we are being a bit handwavy and think of just the operator as the monoid.
00:45:18 <jusss> dminuoso: and sloop?
00:45:39 <dminuoso> So {Integer, *, 1} is a Monoid
00:45:44 <dminuoso> {Integer, +, 0} is a Monoid
00:46:12 * hackage tidal 1.4.1 - Pattern language for improvised music  https://hackage.haskell.org/package/tidal-1.4.1 (AlexMcLean)
00:47:12 <dminuoso> jusss: In Haskell, we can usually say that a *type* is a Monoid because you can have only one Monoid instance per type.
00:47:47 <jusss> dminuoso: but not every type has unit
00:47:56 <dminuoso> jusss: Right! And those wouldn't give us Monoid instances! 
00:48:08 <dminuoso> jusss: If they still have a binary associative operation, we'd still have Semigroup.
00:48:28 <dminuoso> And if they dont even have that, well that's okay too - we are not required to have instances Semigroup or Monoid. 
00:48:52 <dminuoso> jusss: I wanted to give you an example of one-sided identities.
00:49:27 <dminuoso> jusss: Integer division (after remainder) for example combines two numbers into a third number. Do you think division is associative?
00:49:56 <jusss> dminuoso: no
00:50:16 <dminuoso> jusss: Good. So division doesnt give us a Semigroup even. But, let's for the sake of discussion, see if there's an identity.
00:50:52 <jusss> dminuoso: but wait a sec, I thought that two become one is a semigroup
00:51:02 <dminuoso> jusss: Only if that operation is associative.
00:52:01 <jusss> dminuoso: so semigroup has associative law,and add identity law (find its unit) become monoid
00:52:08 <dminuoso> jusss: Precisely :)
00:52:23 <jusss> dminuoso: wait a sec, what about it's more than 2?
00:52:38 <jusss> dminuoso: a+b+c+d = a+(b+c)+d 
00:52:43 <jusss> this is semigroup?
00:53:12 <dminuoso> jusss: Test this yourself.
00:53:23 <dminuoso> jusss: Use the associativity law to see if you can prove this.
00:54:07 <jusss> dminuoso: what is the associativity law ?
00:54:51 <jusss> a+((b+c)+d) = (a+(b+c))+d ?
00:55:59 <jusss> "In mathematics, the associative property[1] is a property of some binary operations. "
00:59:12 * hackage hsc2hs 0.68.6 - A preprocessor that helps with writing Haskell bindings to C code  https://hackage.haskell.org/package/hsc2hs-0.68.6 (HerbertValerioRiedel)
01:16:23 <u-ou> @where ffi
01:16:23 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/haskellch8.html
01:25:17 <dminuoso> jusss: Associativity law is ⌜a * (b * c) = (a * b) * c⌝
01:25:30 <dminuoso> jusss: Is an operation * satisfies that law, that operation is said to be associative.
01:25:55 <dminuoso> + is an associative operation because it satisfies the associativity law above.
01:30:09 <Brekker> hey guys, I want to start learning Haskell, but after a google search I've found so many resources I'm not sure where to start. Can anyone give me some direction?
01:31:16 <Ariakenom> Brekker: I've seen this course recommended before https://www.seas.upenn.edu/~cis194/spring13/lectures.html
01:31:29 <Brekker> Thanks! I'll take a look
01:31:37 <u-ou> Brekker: haskellbook.com
01:32:38 <Ariakenom> I haven't used it myself. It would be interesting to hear from people who have learned haskell from a resource. And people who failed to from a resource.
01:34:15 <Brekker> That course looks pretty good
01:44:52 <u-ou> :i (->)
01:46:35 <Ariakenom> % :i (->) -- u-ou 
01:46:35 <yahb> Ariakenom: ; <interactive>:1:3: error: parse error (possibly incorrect indentation or mismatched brackets)
01:46:42 * hackage resolv 0.1.1.3 - Domain Name Service (DNS) lookup via the libresolv standard library routines  https://hackage.haskell.org/package/resolv-0.1.1.3 (HerbertValerioRiedel)
01:46:46 <Ariakenom> % :i (->)
01:46:46 <yahb> Ariakenom: data (->) (a :: TYPE q) (b :: TYPE r) -- Defined in `GHC.Prim'; infixr 0 ->; instance Applicative ((->) a) -- Defined in `GHC.Base'; instance Functor ((->) r) -- Defined in `GHC.Base'; instance Monad ((->) r) -- Defined in `GHC.Base'; instance Monoid b => Monoid (a -> b) -- Defined in `GHC.Base'; instance Semigroup b => Semigroup (a -> b) -- Defined in `GHC.Base'; instance [safe] (PrintfArg a, HPrintfTy
01:46:52 <u-ou> ty
01:50:11 <u-ou> @where
01:50:12 <lambdabot>  @where <key>, return element associated with key
02:07:09 <dminuoso> % :i ($)
02:07:09 <yahb> dminuoso: ($) :: (a -> b) -> a -> b -- Defined in `GHC.Base'; infixr 0 $
02:10:27 <dminuoso> % :t runST
02:10:27 <yahb> dminuoso: (forall s. ST s a) -> a
02:12:06 <kwerls> Hello, I'm very noob in Haskell and I encountered a problem
02:12:10 <kwerls> I have a file where I declare a data type:
02:12:16 <kwerls> data DiGraph a  = DG [a] (a -> [a])
02:12:24 <kwerls> It is exported correctly and I import it in other file.However, I do not know how to use it:
02:12:59 <kwerls> https://pastebin.com/4qGi3VZQ
02:13:10 <kwerls> What is the problem here? Thanks you VERY much!
02:14:26 <Ariakenom> kwerls: I think you are exporting the type DiGraph but not the data constructor DG
02:14:44 <kwerls> How would be the correct syntax to achieve that?
02:14:50 <kuribas> @hoogle Monad m => (s -> a -> m (b, s)) -> [a] -> s -> [b]
02:14:51 <lambdabot> No results found
02:15:06 <Ariakenom> DiGraph -> DiGraph(DG) in the export list, iirc
02:16:51 <kwerls> I get an error while doing that too
02:16:59 <kwerls> DataStructures/Graph/DiGraph.hs:12:5: error: Not in scope: type constructor or class ‘DG’
02:23:41 <Ariakenom> kwerls: you didn't paste the export list so I don't know what you have. But if you look up the syntax I'm sure you'll get it.
02:25:01 <kwerls> module DataStructures.Graph.DiGraph (DiGraph (DG), ... ) where
02:29:39 <kwerls> I don't know why but I think it works now, thanks Ariakenom 
02:33:05 <jusss> dminuoso: f >>= g   =    \x -> f x >>= g  right?
02:33:43 <dminuoso> jusss: No.
02:34:03 <dminuoso> jusss: Look closer to what you wrote.
02:34:20 <dminuoso> jusss: You are very close, maybe even thinking it right. But there's mistakes in what yohu are writing.
02:34:57 <jusss> f >>=g = \x -> (f x) >>= g ?
02:35:29 <dminuoso> jusss: They are not equal.
02:35:49 <jusss> dminuoso: wait... f >=> g = \x -> (f x) >>=g
02:35:57 <dminuoso> jusss: That looks better. :)
02:37:16 <jusss> dminuoso: what's the right for f >>= g?
02:37:24 <dminuoso> jusss: You tell me.
02:37:45 <jusss> dminuoso: I don't think you want f >>=g = \x -> f (g x)...
02:38:36 <jusss> dminuoso: I don't know what you're thinking what I want...
02:38:55 <jusss> 'cause I don't know what I want...
02:43:03 <jusss> monad follow the three laws, every instance of monad has a unit?
02:43:40 <dminuoso> jusss: Yes, return is that unit.
02:44:17 <dminuoso> jusss: In usual talk we express it like this: "return lifts a value into m, in an effect-free manner", where effect-free means that it sort of "doesnt do anything wrt to >>=/>=>"
02:44:28 <dminuoso> jusss: In the >=> we can observe this as: f >=> return   =   f
02:44:38 <dminuoso> Or: return >=> f   =   f
02:44:55 <dminuoso> Concretely this means, if we are writing IO code:
02:45:22 <dminuoso> Whether we write "pure 10" there or not, doesn't produce any measurable difference: do { pure 10; putStrLn "foo" }
02:46:09 <jusss> dminuoso: so every instance of monad, it has to be instance of monoid and semigroup?
02:46:18 <dminuoso> jusss: No.
02:46:29 <dminuoso> jusss: But it is a good instinct you have.
02:46:31 <jusss> dminuoso: but they follow the three laws
02:46:36 <dminuoso> jusss: The monoidal structure of Monad is turned sideways.
02:46:42 * hackage tar 0.5.1.1 - Reading, writing and manipulating ".tar" archive files.  https://hackage.haskell.org/package/tar-0.5.1.1 (HerbertValerioRiedel)
02:47:22 <dminuoso> jusss: It takes some extra work to get instances of Semigroup and Applicative.
02:48:53 <dminuoso> Some extraordinary work, I'd say
02:49:49 <dminuoso> jusss: The typeclass Monoid itself captures a specific subset of monoids, so its perhaps somewhat misleadingly named.
02:49:57 <dminuoso> Not all monoids are captured by Monoid, only some.
02:50:36 <jusss> dminuoso: does semigroup need to make two to one? 2+1=3
02:50:41 <dminuoso> jusss: In truth I lied about one thing: there's an additional requirement for a monoid
02:50:45 <dminuoso> (and semigroup)
02:51:17 <dminuoso> jusss: Yes, in some way. Whatever that "making two into one" means.
02:51:30 <dminuoso> jusss: Semigroup indeed captures the general notion of "combining two into one in an associative manner"
02:51:40 <jusss> dminuoso: but some types cann't make two to one?
02:51:47 <dminuoso> jusss: You generally always can!
02:51:54 <dminuoso> There's a least some trivial ways.
02:51:58 <jusss> dminuoso: for example?
02:52:04 <dminuoso> For example, you could always "pick the first out of two"
02:52:22 <dminuoso> Such that: x <> y = x
02:52:42 <dminuoso> Or the "second out of two", so you have at least two Semigroup instances that work with any type
02:52:51 <jusss> Just 3 <> Nothing = ?
02:53:07 <dminuoso> jusss: We need an additional newtype wrapper
02:53:23 <dminuoso> We can have only one Semigroup instance per type, so we use newtype wrappers to separate different instances.
02:53:32 <dminuoso> Let's call that newtype wrapper: newtype First a = First a
02:53:41 <dminuoso> It only wraps a type, nothing special about it.
02:54:00 <dminuoso> Now you can write: instance Semigroup (First a) where First l <> First _r = First l
02:54:14 <dminuoso> % newtype First a = First a 
02:54:14 <yahb> dminuoso: 
02:54:19 <dminuoso> % instance Semigroup (First a) where First l <> First _r = First l
02:54:19 <yahb> dminuoso: 
02:54:26 <dminuoso> % First 10 <> First 20
02:54:26 <yahb> dminuoso: ; <interactive>:27:1: error:; * No instance for (Show (First Integer)) arising from a use of `print'; There are instances for similar types:; instance Show a => Show (Data.Semigroup.First a) -- Defined in `Data.Semigroup'; instance Show a => Show (Control.Monad.RWS.First a) -- Defined in `Data.Monoid'; * In a stmt of an interactive GHCi command: print it
02:54:38 <dminuoso> % newtype First a = First a deriving (Eq, Show)
02:54:38 <yahb> dminuoso: 
02:54:40 <dminuoso> % instance Semigroup (First a) where First l <> First _r = First l
02:54:40 <yahb> dminuoso: 
02:54:43 <dminuoso> % First 10 <> First 20
02:54:43 <yahb> dminuoso: First 10
02:54:49 <dminuoso> % First 10 <> First 20 <> First 30 <> First 40
02:54:49 <yahb> dminuoso: First 10
02:56:12 <dminuoso> jusss: Does this make sene?
02:56:12 * hackage tidal 1.4.2 - Pattern language for improvised music  https://hackage.haskell.org/package/tidal-1.4.2 (AlexMcLean)
02:57:13 <dminuoso> jusss: So here's the lie: the additional requirement for Semigroup and Monoid is something called "closure". The operation in question must take two things of exact same type and return something of the exact same type back.
02:57:30 <dminuoso> % :t (>=>)
02:57:30 <yahb> dminuoso: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
02:57:37 <dminuoso> As you can see this doesnt fit the bill, becaue the types vary.
02:57:52 <dminuoso> We could however make it a monoid if we somewhat constrict it.
02:58:37 <dminuoso> If we say "what if a ~ b ~ c", then we'd have `(a -> m a) -> (a -> m a) -> (a -> m a)` and we could certainly make a Semigroup and Monoid instance for that.
02:58:57 <jusss> dminuoso: wow
02:59:40 <dminuoso> jusss: Its the same thing with (.) by the way. And there is a newtype wrapper that does exactly that, its called Endo.
02:59:49 <jusss> :t (>>=)
02:59:51 <lambdabot> Monad m => m a -> (a -> m b) -> m b
03:00:08 <jusss> m a ->(a -> m a) -> m a?
03:00:53 <dminuoso> jusss: Doesnt fit the "both input types and the output types must be the same" rule
03:01:02 <jusss> dminuoso: no
03:01:17 <dminuoso> jusss: But we could use it as the underlying implementation regardless
03:01:24 <dminuoso> jusss: So this is what the Monoid would look like:
03:01:43 <dminuoso> % newtype EndoKleisli m a = EndoKleisli { appEndoKleisli :: a -> m a }
03:01:43 <yahb> dminuoso: 
03:02:11 <dminuoso> % instance Monad m => Semigroup (EndoKleisli m a) where EndoKleisli kl <> EndoKleisli kr = EndoKleisli kl >=> kr
03:02:11 <yahb> dminuoso: ; <interactive>:34:90: error:; * Couldn't match expected type `a0 -> m a' with actual type `EndoKleisli m a'; * Possible cause: `EndoKleisli' is applied to too many arguments; In the first argument of `(>=>)', namely `EndoKleisli kl'; In the expression: EndoKleisli kl >=> kr; In an equation for `<>': EndoKleisli kl <> EndoKleisli kr = EndoKleisli kl >=> kr; * Relevant bindin
03:02:20 <dminuoso> % instance Monad m => Semigroup (EndoKleisli m a) where EndoKleisli kl <> EndoKleisli kr = EndoKleisli (kl >=> kr)
03:02:20 <yahb> dminuoso: 
03:02:47 <dminuoso> % instance Monad m => Monoid (EndoKleisli m a) where mempty = EndoKleisli return
03:02:47 <yahb> dminuoso: 
03:04:41 <dminuoso> jusss: So (>=>) is actually something more general than a Monoid because the types sort of vary, and we don't call this "A semigroup" or "A monoid" but "A category". :)
03:05:52 <dminuoso> But this is quickly getting into mathematical topics
03:06:05 <jusss> dminuoso: instances of monads can turn to instances of monoid and semigroup?
03:06:33 <dminuoso> jusss: Yes, for example through the EndoKleisli construction I have just shown you.
03:06:54 <jusss> dminuoso: I think I can't follow this right now...
03:07:34 <dminuoso> jusss: Then dont. Note that none of this is relevant to practical Haskell programming, you can become a proficient programmer without understanding any of this.
03:07:38 <dminuoso> I just sort of digressed.
03:09:10 <jusss> dminuoso: the unit, if return is the unit, then f >>= return = f?
03:09:12 * hackage zlib 0.6.2.1 - Compression and decompression in the gzip and zlib formats  https://hackage.haskell.org/package/zlib-0.6.2.1 (HerbertValerioRiedel)
03:09:17 <dminuoso> jusss: Yes!
03:09:29 <dminuoso> jusss: https://wiki.haskell.org/Monad_laws
03:09:46 <jusss> dminuoso: wait a sec, just "return" is the unit, right?
03:09:49 <dminuoso> jusss: These laws are exactly the same laws as specified with (>=>), they are just not as easy to read. :)
03:09:56 <dminuoso> jusss: Yup. :)
03:09:57 <jusss> dminuoso: I mean what it means to do return 3?
03:10:10 <dminuoso> jusss: That depends on the Monad instance.
03:10:43 <dminuoso> jusss: If we allow ourselves to think of the ⌜m⌝ as capturing some sort of effect, then "return" places a value inside an "effect-less action"
03:10:44 <jusss> dminuoso: return 3 :: Maybe a
03:11:07 <dminuoso> jusss: In case of Maybe think of the effect being "exceptions", so you can "throw" an exception by producing Null at some point.
03:11:24 <dminuoso> jusss: so "return 3" places a value without an effect, in this case an exception, so "return 3 = Just 3"
03:11:34 <dminuoso> It's, granted, a bit boring.
03:12:24 <jusss> dminuoso: and can return 3 to equal Nothing?
03:12:30 <dminuoso> jusss: No.
03:15:42 <jusss> dminuoso: about Either monad, I forget its type
03:16:14 <jusss> dminuoso: there're two types in Either, what's the point to the one we don't want to care
03:16:19 <dminuoso> jusss: The Either Monad instance is like Maybe, except you can attach information to the "exception" to communicate "what went wrong"
03:17:18 <jusss> dminuoso: the Either type I can understand, but Either monad I have some confused
03:17:49 <jusss> 'cause Either a is the monad
03:22:34 <jusss> (>>=) :: Either e a -> (a -> Either e b) -> Either e b 
03:23:11 <jusss> return :: a -> Either e a 
03:24:45 <jusss> Left and Right both are holded in the context ?
03:27:21 <christiaanb> How do  I stop cabal from building `Cabal-2.4` on GHC 8.8 and force all packages to use the bundled Cabal-3.0 ?
03:27:53 <christiaanb> I added `constraints: Cabal == 3.0` to my `cabal.project` file, but that doesn't seem to work
03:42:12 * hackage publicsuffix 0.20190826 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20190826 (wereHamster)
03:46:44 <boxscape> How long does it usually take once a ghc version is released before there's a stackage snapshot with that version?
03:54:07 <u-ou> @where regex
03:54:07 <lambdabot> I know nothing about regex.
04:40:00 <christiaanb> okay, solved it. I needed the cabal-install-3.0 executable because of custom Setup.hs scripts
04:50:54 <simon> u-ou, what are you looking for?
05:05:42 <Ariakenom> Out of the blue, here is a cool regex-lens library https://github.com/ChrisPenner/lens-regex-pcre
05:24:42 * hackage doctest 0.16.2 - Test interactive Haskell examples  https://hackage.haskell.org/package/doctest-0.16.2 (quasicomputational)
05:33:53 <lyxia> boxscape: GHC 8.6.1 was released 21-09-2018 and the first nightly with that version is nightly-2018-09-29
05:34:27 <boxscape> lyxia I see, thank you, that's pretty quick
05:37:09 <lyxia> indeed!
05:57:51 <MasseR> Can I have ghc show much memory it uses for compilation? We have a module that's right at the edge of our CI pipelines resources
05:58:03 <MasseR> I want to optimize it, but it's kinda difficult if I have no numbers
05:58:22 <davean> MasseR: "time" does that inhernatly on Posix, but oyu can get GC information
05:58:23 <MasseR> I tried adding `+RTS -s` to ghc-options
05:59:28 <davean> MasseR: which does have maximum residency 
05:59:46 <MasseR> How do I get the gc info?
06:00:10 <davean> MasseR: when you provide that flag its printed out on program exit
06:00:46 <davean> specificly to stderr
06:01:03 <davean> you can change the destination to a file if you don't want to look at cabal's logs or enable streaming output during compile from cabal.
06:01:23 <davean> which it details as part of the documentation of the -s flag
06:02:19 <MasseR> also the hint on 'time' worked, I just needed to figure out how to get zsh to output memory info
06:05:27 <ac> hey
06:05:42 <ac> wow
06:05:43 * hackage rio 0.1.12.0 - A standard library for Haskell  https://hackage.haskell.org/package/rio-0.1.12.0 (MichaelSnoyman)
06:05:49 <ac> ;=(
06:06:51 <davean> well that was weird
06:23:42 * hackage reflex-vty 0.1.1.1 - Reflex FRP host and widgets for vty applications  https://hackage.haskell.org/package/reflex-vty-0.1.1.1 (abrar)
06:23:46 <t7> :k forall a. Int
06:23:47 <lambdabot> *
06:23:51 <t7> how?
06:24:38 <t7> do i misunderstand kinds?
06:24:49 <t7> ah yes i do
06:25:07 <t7> wait do i ?
06:25:47 <boxscape> What would you expect the kind to be?
06:26:23 <t7> I am mixing up system f with not system f here
06:26:55 <t7> i thought a compiler would insert a type application in here, but this is not the same as a type level application right?
06:30:04 <simon> :k Int
06:30:06 <lambdabot> *
06:30:20 <simon> :k forall a. a
06:30:22 <lambdabot> k
06:34:34 <ggole> Think GHC is simplifying that first forall for you
06:38:42 * hackage clckwrks 0.25.1 - A secure, reliable content management system (CMS) and blogging platform  https://hackage.haskell.org/package/clckwrks-0.25.1 (JeremyShaw)
06:54:12 * hackage ghc-lib-parser 8.8.1 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-parser-8.8.1 (shayne_fletcher)
07:03:42 * hackage ghc-lib 8.8.1 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-8.8.1 (shayne_fletcher)
07:04:14 <lyxia> I don't see what there is to simplify
07:04:35 <dmwit> t7: Type applications are a term-level thing, not type-level. There's nothing to insert.
07:04:42 * hackage ghc-typelits-natnormalise 0.7 - GHC typechecker plugin for types of kind GHC.TypeLits.Nat  https://hackage.haskell.org/package/ghc-typelits-natnormalise-0.7 (ChristiaanBaaij)
07:05:33 <dmwit> t7: You get kinds with arrows in them by having something that's parameterized, not by having something that's polymorphic.
07:05:40 <dmwit> :k Maybe
07:05:41 <lambdabot> * -> *
07:07:07 <Ariakenom> % :k Maybe Int
07:07:07 <yahb> Ariakenom: Maybe Int :: *
07:07:09 <Ariakenom> % :k forall a. Maybe a
07:07:09 <yahb> Ariakenom: forall a. Maybe a :: *
07:08:47 <infandum`> How come in https://hackage.haskell.org/package/sparse-linear-algebra-0.3.1/docs/src/Data.Sparse.SpMatrix.html#MatProd_ "m1 ## transposeSM m2" is much, much faster than "m1 ##^ m2"? Should it not be the other way around as the latter does NOT require a transpose?
07:13:42 * hackage ghc-typelits-knownnat 0.7 - Derive KnownNat constraints from other KnownNat constraints  https://hackage.haskell.org/package/ghc-typelits-knownnat-0.7 (ChristiaanBaaij)
07:16:42 * hackage ghc-typelits-extra 0.3.1 - Additional type-level operations on GHC.TypeLits.Nat  https://hackage.haskell.org/package/ghc-typelits-extra-0.3.1 (ChristiaanBaaij)
07:17:42 * hackage cabal-doctest 1.0.7 - A Setup.hs helper for doctests running  https://hackage.haskell.org/package/cabal-doctest-1.0.7 (phadej)
07:18:42 * hackage mixpanel-client 0.2.1 - Mixpanel client  https://hackage.haskell.org/package/mixpanel-client-0.2.1 (domenkozar)
07:33:43 * hackage clckwrks 0.25.2 - A secure, reliable content management system (CMS) and blogging platform  https://hackage.haskell.org/package/clckwrks-0.25.2 (JeremyShaw)
07:35:18 <ggole> lyxia: forall a. Int => Int
07:36:27 <lyxia> the kind is * whether you "simplify" this or not
08:06:00 <jgt> how long does it usually take for a package (in this case yesod-core) to get on Hackage?
08:06:10 <jgt> the latest patch version, I mean
08:08:13 <tdammers> that's up to the author, isn't it
08:08:41 <tdammers> for my packages, I can flip the switch and have the version on hackage within a second or so
08:11:43 * hackage bcp47 0.1.0.0 - Language tags as specified by BCP 47  https://hackage.haskell.org/package/bcp47-0.1.0.0 (dukerutledge)
08:11:44 <jgt> ah, I wasn't sure if it was a manual thing, or it just lags behind (like nixpkgs)
08:21:45 <tdammers> hackage is very manual; the hackage server doesn't even know that git is a thing (beyond faithfully showing the declared source-repository URL on the package overview page)
08:21:55 <gobby> After running `stack build my-exec --profile` and then running `stack exec my-exec +RTS -p` I get `the flag -p requires the program to be built with -prof`
08:22:19 <gobby> I thought the `--profile` flag does this for me?
08:25:45 <jle`> t7: consider how things work syntactically
08:26:02 <jle`> t7: `(forall a. Maybe a) Int` is not the same as `Maybe Int`
08:26:43 <jle`> the forall isn't a lambda that can be applied at the type level
08:27:01 <cocreature> gobby: iirc you need to pass --profile to "stack exec" as well in recent versions of stack
08:30:27 * shapr hops quietly
08:32:44 <portnov> gobby: stack exec -- my-exec +RTS -p
08:32:55 * lyxia hops louder
08:33:25 <jle`> t7: i believe system f doesn't work this way either... type abstractions are different than type lambdas
08:33:31 <jle`> s/this/that
08:35:02 <dminuoso> jle`: The lambda cube really put things into perspective for me.
08:36:12 * hackage postgresql-query 3.6.0 - Sql interpolating quasiquote plus some kind of primitive ORMusing it  https://hackage.haskell.org/package/postgresql-query-3.6.0 (AlekseyUymanov)
08:36:14 <dminuoso> Understanding that forall quantification is value-level terms that bind types.
08:38:06 <jle`> as for me i didn't fully understand how everything fit together until i tried implementing it, heh
09:02:54 <boxscape> Kind of fun to see that something I encountered for the first time two days ago and asked about here was included as a feature in ghc yesterday
09:04:23 <boxscape> (as in, included in 8.8)
09:04:31 <boxscape> (specifically being able to use foralls in more places)
09:12:19 <jle`> boxscape: you're on the cutting edge :)
09:12:42 * hackage spdx 1.0.0.1 - SPDX license expression language, Extras  https://hackage.haskell.org/package/spdx-1.0.0.1 (phadej)
09:13:12 <inkbottle> I can't find description of `char` here http://hackage.haskell.org/package/parsec3-1.0.1.8/docs/Text-Parsec.html, though `import Text.Parsec` does provide me with a `char` function
09:14:39 <phadej> inkbottle: there is Character Parsing section which re-exports module Text.Parsec.Char
09:15:15 <inkbottle> what is re-exports?
09:15:46 <phadej> module Foo (module Bar, ...) where import Bar -- module Foo re-exports Bar (and other stuff)
09:15:48 <inkbottle> which re-export, ok
09:15:56 <inkbottle> s*
09:25:12 * hackage hmatrix-sundials 0.20.1.0 - hmatrix interface to sundials  https://hackage.haskell.org/package/hmatrix-sundials-0.20.1.0 (DominicSteinitz)
09:29:13 <inkbottle> phadej: I found the relevant lines in the sources; thanks
09:59:06 <tabaqui> thrift library on hackage is nothing but a piece of s**t
09:59:13 <tabaqui> *sigh
10:01:04 <sm[m]> First time I heard that about something on hackage. Another milestone for haskell ! ?
10:01:49 <tabaqui> I dunno, it is grammatically correct Haskell programm
10:01:57 <tabaqui> but is written by non-haskellers
10:02:12 <tabaqui> just every convention is broken
10:15:10 <int-e> tabaqui: meh don't mention stuff like this... now I have to look!
10:16:21 <EvanR> slowly drives past thrift package, making traffic worse
10:16:43 <EvanR> /me
10:16:47 <int-e> . o O ( Heh a Setup.lhs file with a license... I don't think that's even copyrightable. )
10:18:09 <__monty__> int-e: Law departments are often "It can't hurt."
10:18:22 <int-e> __monty__: I almost added that :)
10:37:37 <Guest62653> https://get.cryptobrowser.site/8585912
10:50:52 <maralorn> I am wondering: What Haskell util libraries should I use in every project? I mean there are libraries for easier typeconversion, for stringinterpolation, different preludes, include helpers, liquid Haskell. I feel like every week I meet another tool/lib which is not problem specific but just a convenience/change to the default way to use Haskell. It even seems like a lot of community effort is flowing into
10:50:54 <maralorn> those tools. But I feel like I am not getting the mileage out of it, that I could.
10:51:38 <tabaqui> dunno, it depends on your style and choosen extensions
10:51:56 <tabaqui> I know that many writes their own Prelude and include it in every project
10:52:09 <tabaqui> I am doing this too :)
10:53:17 <tabaqui> speaking about externals, I usually include transformers/mtl, monad-control/monad-lifted, monad-logger, monad-resource and so on
10:53:47 <maralorn> Yeah, effect/monad construction is another choice.
10:54:25 <tabaqui> right
10:54:35 <maralorn> Also documentation and tests …
10:54:51 <tabaqui> HSpec + HUnit + QuickCheck
10:55:02 <maralorn> For everything I feel there are towns of tools.
10:55:04 <tabaqui> I used TestFramework before, but HSpec imo is much better
10:55:12 <tabaqui> some sort of
10:55:21 <tabaqui> I don't think it is bad
10:55:21 <maralorn> Hm, interesting I am gonna look into that.
10:55:34 <tabaqui> docs - just plain haddock
10:55:53 <maralorn> Well tons of tools is a good thing. It just makes the choice hard.
10:56:05 <jle`> maralorn: i don't think there's a set of tools that i use for 'every' project
10:56:07 <tabaqui> I think that cool guys that like TypeFamilies have another tools
10:56:09 <__monty__> Did you look into tasty?
10:56:09 <jle`> i usually add them as they are useful
10:56:53 <jle`> i think it makes sense if you are coordinating a large project with many people to start looking at unifying an alternative prelude/helpers/stuff like that
10:57:12 <tabaqui> hspec declares test cases as monadic actions, what is butter than common list
10:57:15 <jle`> but for most of my projects i don't really have a list of libraries i "have" to lose
10:57:20 <jle`> *have to use
11:07:12 <jle`> is the new ghc announcement a release candidate or an actual release? 
11:17:42 * hackage yaml 0.11.1.2 - Support for parsing and rendering YAML documents.  https://hackage.haskell.org/package/yaml-0.11.1.2 (MichaelSnoyman)
11:27:48 <boxscape> an actual release
11:34:37 <Athas> Does GHC 8.8 require cabal-install 3?
11:35:50 <Athas> Can't find any mention of that in the release docs... can't imagine where I heard that.
11:36:53 <jle`> boxscape: that's what i thought, but the release announcement calls it a release candidate
11:37:30 <cocreature> jle`: it does? I don’t see that word anywhere on https://www.haskell.org/ghc/blog/20190825-ghc-8.8.1-released.html
11:37:40 <boxscape> jle` does it still? It also said 2019-07 earlier but that's been fixed
11:37:49 <shapr> ooh, 8.8.1 !! hurrah!
11:38:01 <cocreature> Athas: I think in general cabal-install does not guarantee forwards compatibility. At best you might get lucky
11:38:02 * shapr is so excited!
11:38:14 <jle`> i wanted to post about how fail is no longe rin monad
11:38:17 <jle`> but the new base is not on hackag eyet
11:38:59 <jle`> those were some weird typos
11:41:06 <shapr> jle`: I'll notify you when I finish hacking up a chording keyboard :-P
11:41:35 <shapr> at least, when I make those kind of typos it because I hit space at the wrong time to separate a word from another word
11:43:10 <Athas> cocreature: cabal-install 3 is not out yet, so that would be a problem.
11:45:38 <jle`> indeed. gotta remap spacebar to something small
11:46:06 <cocreature> Athas: I guess in that case, hope you get luck yor build it yourself :)
11:47:38 <vaibhavsagar> SBV is back! https://github.com/LeventErkok/sbv
11:47:54 <hvr> ...where did it go?
11:47:56 <sarahzrf> edwardk_: yo, you around?
11:48:14 <cocreature> vaibhavsagar: awesome!
11:48:28 <vaibhavsagar> hvr: https://www.reddit.com/r/haskell/comments/cpncqb/where_did_the_sbv_github_repo_go/
11:51:08 <shapr> vaibhavsagar: yay it's back! I've been using my local copy
11:52:15 <hvr> "lawyers are involved" sounded worrying
11:52:36 <jle`> cocreature, boxscape: ah, it looks like it doesn't say it anymore :) or maybe i had receieved a wrong link earlier
11:56:09 <jle`> but yeah effectively ghc 8.8 isn't super usable for releasing things yet; the base it requires isn't even on hackage. but maybe it's built into ghc so it doesn't matter?
12:06:39 <Athas> Maybe that's why they (in some places?) call it a release candidate.
12:06:41 <geekosaur> hackage base is mostly for docs. but I thought this was actually a release candidate?
12:06:42 <Athas> It's very confusing!
12:06:57 <Athas> Is it actually a release, or merely a release candidate?
12:07:10 <Athas> GHC releases don't tend to be probability distributions.
12:09:22 <geekosaur> I don't recall an earlier release candidate, so Id be surprised if this were a full release. Exc ept haskell.org/ghc calls it a release :(
12:09:39 <c_wraith> there were alphas
12:09:47 <boxscape> I think earlier I saw an announcement on reddit from a month ago about an 8.8 release candidate
12:09:51 <boxscape> earlier today*
12:10:41 <boxscape> might be it was a different ghc version but then I would also have to be wrong about it being from a month ago
12:11:05 <boxscape> but I can't find it anymore so idk
12:11:29 <boxscape> https://www.haskell.org/ghc/blog/20190722-ghc-8.8.1-rc1-released.html
12:11:31 <boxscape> never mind I found it
12:12:20 <geekosaur> guess I missed it. someone just found a different issue in #ghc though, so it sounds like we have a few problems with the new release
12:12:44 <geekosaur> the combination of faster releases and moving to gitlab did releases no favors
12:12:54 <c_wraith> making a release is sadly the only way to make people get serious about finding bugs. 
12:13:04 <c_wraith> even RCs don't get enough attention 
12:13:30 <boxscape> was the move to gitlab recent?
12:13:51 <geekosaur> ish. couple months back
12:14:04 <boxscape> ok
12:14:05 <geekosaur> they're still fixing issues with the wiki, links in issues, etc.
12:15:18 <Athas> In principle I like the faster release schedule (and the compiler does seem to have stabilised after some dreadfully buggy years), but the many upper bounds on Hackage make it fairly painful.
12:15:44 <Athas> I guess GHC 8.8 bumps base as well?  That means a lovely few weeks/months of prodding absentee package maintainers to relax their bounds.
12:15:57 <geekosaur> yes
12:15:58 <Athas> (And if you're really unlucky, actually changing their code...)
12:16:20 <boxscape> What's the usual upper bound packages have on base right now?
12:16:43 <jle`> a lot of templates default to <5, so it shouldn't break a lot of packages in terms of base
12:16:58 <jle`> well, the packages that care enough to set upper bounds wouild be broken, heh
12:17:05 <Athas> Ah yeah, last time around it was the bump of 'containers' that caused a lot of churn.
12:17:41 <Athas> Looks like containers has not been bumped.  Crossing my fingers for an easy upgrade this time...
12:17:42 * hackage cpsa 3.6.3 - Symbolic cryptographic protocol analyzer  https://hackage.haskell.org/package/cpsa-3.6.3 (mliskov)
12:17:53 <Athas> Of course, the MonadFail change may cause some excitement.
12:18:09 <jle`> yeah, after all these years of complaining, fail is no longer in Monad :)
12:18:18 <jle`> so no more footnotes about "well technically..."
12:18:28 <Athas> It's a good change!
12:18:29 <davean> It is a joyous occasion
12:18:36 <Athas> And the migration has been relatively painless as well so far.
12:19:00 <davean> I really love everytime issues like that are finally cleaned up
12:19:06 <davean> I have a whole lot of code I can go simplify
12:19:31 <jle`> i've had some pain but only because i was doing programming wrong
12:19:34 <jle`> it forced me to be honest
12:25:23 <dmwit> Speaking of which... dminuoso, did fail _ = retry get any traction? Or did you end up like me, unmotivated? =)
12:28:03 <dmwit> Good news: nobody has registered lift.io yet.
12:29:07 <shapr> dmwit: and now you have?
12:29:25 <dmwit> I'm happy with dmwit.com =)
12:29:34 <jle`> he can have it if he paypals me $0.05
12:29:48 <jle`> aw nvm. i guess time to find someone else to squat
12:30:52 <jle`> i wonder what you could do with lift.io; presumably the subdomains would be apt for creative expression
12:30:58 <jle`> https://Control.Monad.Lift.IO
12:33:05 <shapr> I often wanted a custom domain for the monad.reader
12:41:19 <boxscape> what do the {} indicate when you use -fprint-explicit-foralls?
12:42:25 <geekosaur> which type variables are "visible" to type application, iirc?
12:42:44 <boxscape> as in, the ones with {} are visible, or are not visible?
12:43:05 <boxscape> (I haven't seen an example where it doesn't print {} for something, actually)
12:43:15 <geekosaur> visible, iirc, but I may be confused
12:43:22 <boxscape> hm, okay
12:46:02 <geekosaur> ok, was thinking f something else
12:46:04 <geekosaur> "This flag also enables the printing of inferred type variables inside braces. See Inferred vs. specified type variables."
12:46:20 <geekosaur> so braced means it's inferred instead of explicit in the source
12:47:11 <geekosaur> that may actually mean the opposite of what I said since it's hard to figure out how they affect type application otherwise
12:47:33 <boxscape> % :t undefined :: forall a b. a -> b
12:47:33 <yahb> boxscape: forall {a} {b}. a -> b
12:47:51 <boxscape> maybe it should be "inferrable" rather than "inferred" considering they're explicitly given in this case?
12:48:07 * geekosaur is not sure, but notes he got 8.8 and things changed there
12:48:15 <boxscape> ok
12:49:00 <boxscape> % :set -XImpredicativeTypes
12:49:00 <yahb> boxscape: 
12:49:04 <boxscape> % undefined :: forall b. (forall a. a -> a) -> b
12:49:05 <yahb> boxscape: ; <interactive>:60:1: error:; * No instance for (Show ((forall a. a -> a) -> b0)) arising from a use of `print'; (maybe you haven't applied a function to enough arguments?); * In a stmt of an interactive GHCi command: print it
12:49:11 <boxscape> % :t undefined :: forall b. (forall a. a -> a) -> b
12:49:11 <yahb> boxscape: forall {b}. (forall a. a -> a) -> b
12:49:13 <geekosaur> https://downloads.haskell.org/ghc/latest/docs/html/users_guide/glasgow_exts.html#inferred-vs-specified
12:49:22 <boxscape> that's an example of one without braces at least
12:49:48 <geekosaur> ah, inferrable does seem to make more sense per that link. nowhere is a or b specified, so.
12:50:33 <geekosaur> and it is related to TypeApplications, so I wasn't misremembering
12:51:14 <geekosaur> and that it has to do with things not specified that could confuse knowing which names can be applied otherwise, since the user can't see them
12:51:27 <geekosaur> (without this explicit foralls flag, at least)
12:52:32 <boxscape> okay
12:53:55 <boxscape> seems like "inferred" rather than "inferrable" makes sense as long as you use :type +v rather than :type
12:54:41 <geekosaur> I suspect we're both being confused by something related to 8.8's addition of kind applications, and doc changes related thereto that might need some more work.
12:55:39 <boxscape> I don't feel all that confused right now but maybe
12:57:55 <geekosaur> the thing I first quoted at you was from 8.8 and seems backwards-ish, but might be talking about inferred kinds rather than inferred types
12:58:09 <geekosaur> since that becomes an issue with kind application
12:59:58 <boxscape> hm, well at least the part where you see braces with :t but don't with :t +v makes sense to me after reading that link
13:21:18 <boxscape> % :t undefined :: Int -> (forall a. a -> a)
13:21:18 <yahb> boxscape: ; <interactive>:1:14: error:; * Illegal polymorphic type: forall a. a -> a; Perhaps you intended to use RankNTypes or Rank2Types; * In an expression type signature: Int -> (forall a. a -> a); In the expression: undefined :: Int -> (forall a. a -> a)
13:21:23 <boxscape> isn't that a rank 1 type?
13:21:36 <boxscape> does this just mean that even without RankNTypes not all rank 1 types are supported?
13:23:56 <argent0> Hi, what's the popular (?) way to do: `instance MonadIO m => MySubSetOfIO m`? Is UndecidableInstances always required? B.c the constraint `MonadIO m` is no smaller than the instance head.
13:24:12 * hackage base-noprelude 4.13.0.0 - "base" package sans "Prelude" module  https://hackage.haskell.org/package/base-noprelude-4.13.0.0 (HerbertValerioRiedel)
13:24:49 <jle`> argent0: the only sane way would be a newtype wrapper, or defining an instance for every MonadIO instance individually
13:25:02 <jle`> you're basically defining an instance that overlaps with every other instance ever
13:25:10 <bwe> f (Just 1) (Just 2) -- expected result of f: Just 3
13:25:29 <argent0> jle`: makes sense, thanks
13:25:56 <bwe> I basically want an fmap that has values present at the same time. 
13:26:09 <jle`> argent0: you can also just have that behavior as the defualt instance definitions
13:26:25 <boxscape> > liftA2 (+) (Just 1) (Just 2)
13:26:28 <lambdabot>  Just 3
13:26:28 <jle`> argent0: to make it easier to define instances that are MonadIO; you can just write it with an empty body
13:26:36 <jle`> argent0: what do you want to do if one of the items is Nothing?
13:26:57 <argent0> boxscape: ^
13:27:05 <argent0> bwe: ^^
13:27:59 <argent0> jle`: Ok, I'll give that a go
13:28:05 <boxscape> bwe: You seem to have discovered that applicative functors are useful
13:28:28 <bwe> boxscape: indeed =)
13:33:34 <bwe> > data MyType = MyType Double deriving Show
13:33:36 <lambdabot>  <hint>:1:1: error: parse error on input ‘data’
13:33:54 <boxscape> % data MyType = MyType Double deriving Show
13:33:54 <yahb> boxscape: 
13:34:03 <boxscape> % MyType 4.5
13:34:03 <yahb> boxscape: MyType 4.5
13:34:07 <bwe> > liftA2 (-) (MyType 1) (MyType 1) -- expected: MyType 0
13:34:09 <lambdabot>  error:
13:34:09 <lambdabot>      Data constructor not in scope: MyType :: Integer -> f cerror:
13:34:10 <lambdabot>      Data constructor not in scope: MyType :: Integer -> f c
13:34:14 <boxscape> use yahb
13:34:16 <boxscape> with %
13:34:20 <bwe> % liftA2 (-) (MyType 1) (MyType 1) -- expected: MyType 0
13:34:21 <yahb> bwe: ; <interactive>:71:13: error:; * Couldn't match expected type `f c' with actual type `MyType'; * In the second argument of `liftA2', namely `(MyType 1)'; In the expression: liftA2 (-) (MyType 1) (MyType 1); In an equation for `it': it = liftA2 (-) (MyType 1) (MyType 1); * Relevant bindings include it :: f c (bound at <interactive>:71:1); <interactive>:71:24: error:; * Couldn't
13:35:28 <boxscape> the problem appears to be that you haven't defined an Applicative instance for MyType bwe
13:35:58 <bwe> okay, thanks for decoding that rather mysterious error msg for me
13:36:14 <boxscape> tbh I'm not sure why it doesn't just say that it can't find an instance
13:36:33 <boxscape> oh
13:36:40 <boxscape> it's actually something else bwe
13:36:44 <boxscape> @ :k Maybe
13:36:51 <boxscape> % :k Maybe
13:36:51 <yahb> boxscape: Maybe :: * -> *
13:36:55 <boxscape> % :k MyType
13:36:55 <yahb> boxscape: MyType :: *
13:37:00 <boxscape> notice how the kinds are different
13:37:09 <boxscape> because Maybe is defined as Maybe a = ...
13:37:14 <boxscape> whereas MyType is defined as MyType ...
13:37:24 <boxscape> the extra type variable there changes the kind
13:37:32 <bwe> Applicative does only work with kind * -> *
13:37:36 <boxscape> exactly
13:37:53 <bwe> boxscape: so I need to add a type parameter to MyType (which I otherwise would not need)
13:38:15 <bwe> boxscape: can I make it default to a predefined type then?
13:38:35 <boxscape> in what context would you want it to default?
13:39:25 <bwe> in any
13:40:05 <boxscape> You could define a function (Int -> Int -> Int) -> MyType -> MyType -> MyType that does what liftA2 would do if it were an Applicative, if you don't want the extra type parameter
13:40:30 <boxscape> generally speaking I don't think you can really make it default, there might be a way to exploit an existing Applicative instance to define such a function though, I'm not sure
13:41:08 <boxscape> % toId (MyType x) = Identity x
13:41:08 <yahb> boxscape: 
13:41:31 <boxscape> % liftA2 (-) (toId $ MyType 1) (toId $ MyType 1)
13:41:31 <yahb> boxscape: Identity 0.0
13:41:46 <boxscape> well, with that route you'd also have to convert it back to MyType after that
13:41:49 <boxscape> there might be a nicer way to do this
13:43:13 <boxscape> or...
13:43:26 <boxscape> wait a second
13:44:29 <boxscape> I guess you could do something like
13:44:37 <boxscape> % type MyType' = Identity Int
13:44:38 <yahb> boxscape: 
13:44:50 <boxscape> but then of course it's not a new type
13:46:11 <boxscape> s/Int/Double
13:46:42 <hexagoxel> make it a newtype, then use coerce. unless your real use case is more complex.
13:46:51 <hexagoxel> % newtype MyNewType = MyNewType Double deriving Show
13:46:51 <yahb> hexagoxel: 
13:46:58 <hexagoxel> % coerce @(Double -> _ -> _) (+) (MyNewType 1) (MyNewType 2) :: MyNewType
13:46:59 <yahb> hexagoxel: MyNewType 3.0
13:47:07 <boxscape> neat
13:47:45 <hexagoxel> % coerce ((+) @ Double) (MyNewType 1) (MyNewType 2) :: MyNewType
13:47:45 <yahb> hexagoxel: MyNewType 3.0
13:48:28 <tabaqui> how should I use pragmas with lhs2tex correcly?
13:48:58 <tabaqui> if I just declare {-# LANGUAGE ... #-} inside a code block, I'll get "You can't use `macro parameter character #' in restricted horizontal mode." error
13:48:59 <wroathe> exit
13:49:05 <wroathe> whoops, wrong window
13:49:25 <hexagoxel> but at that point, you could just newtype-derive Num or whatever you want. But I assume you have more operations in mind.
13:59:15 <tabaqui> allright, using "birds" instead of block sections helped
13:59:46 <tabaqui> no, it didn't
14:00:25 <boxscape> I don't expect this to work at all but have you by chance tried \# instead of #haskell
14:00:28 <boxscape> oops
14:00:35 <boxscape> I meant \# instead of # 
14:01:55 <tabaqui> sure, but Cabal can't build the source then
14:02:02 <boxscape> hm, okay
14:16:37 <boxscape> https://gist.github.com/JakobBruenker/3256d96db6946650bceff6014a5a85a0 are these two instances the same? I wrote the first one, Thinking with Types suggests the second one. They look different to me, but I thought you couldn't really accidentally write a wrong Functor instance so... yeah
14:19:34 <tabaqui> you want to implement CPS monad? The second one seems correct
14:20:18 <boxscape> yeah the second one is the one I took from the book
14:20:29 <tabaqui> I am not sure, but DeriveFunctor could make the same
14:20:38 <boxscape> but I thought there was always a unique Functor instance. Or does that not apply to higher rank types
14:21:25 <tabaqui> still trying to understand how the first one can pass the typechecker
14:22:18 <tabaqui> ah, got it
14:22:38 <tabaqui> yeah, that is the reason why I don't like CPS
14:23:09 <boxscape> what is the reason?
14:23:26 <tabaqui> too complicated and provoke human errors
14:24:17 <boxscape> I guess the reason DeriveFunctor still works is because my implementation probably doesn't follow the Functor laws?
14:24:29 <tabaqui> and sometimes it is can be perflecty replaced with common bracket speaking of Haskell
14:25:32 <tabaqui> s/is//
14:26:40 <vaibhavsagar> the first one seems like the right one to me: https://www.bbc.co.uk/newsround/36489213
14:26:43 <vaibhavsagar> whoops
14:26:52 <vaibhavsagar> http://hackage.haskell.org/package/kan-extensions-5.2/docs/src/Control.Monad.Codensity.html#line-87
14:26:57 <boxscape> nice to see BBC talking about haskell :)
14:27:09 <boxscape> I guess maybe they *are* equivalent after all?
14:28:51 <boxscape> they seem to produce the same results, anyway
14:37:39 <wroathe> What's up with haskell-src-exts, and by extension haskell-src-meta, using it's own parser? https://github.com/haskell-suite/haskell-src-exts/blob/master/src/Language/Haskell/Exts/InternalParser.ly I would think it would make more sense just to depend on GHC's Parser
14:38:02 <wroathe> They've got support for parsing some extensions, but I'm sure GHC's Parser can handle that too
14:41:18 <jle`> it might be a stability thing
14:41:20 <MarcelineVQ> Not having to depend on ghc as a library which iiuc has a brittle api
14:43:04 <MarcelineVQ> For some reason I was under the impression that src-exts was on the way out though, dunno if that's just a fever dream I had though. could ask mpickering
14:44:02 <wroathe> Well, I have a need to turn a String into an Exp at compile time, and the best way I see to currently do that would be to use GHC's Parser to get a HsExpr and then map that to an Exp
14:44:13 <wroathe> That's the way that makes the most sense to me anyway
14:45:03 <Guest_91> Following instructions, I assumed I installed the Haskell platform using curl https://get-ghcup.haskell.org -sSf | sh  but I don't see anywhere to click for the IDE.  I'm on a mac.
14:47:02 <wroathe> It seemed like src-exts would be a good candidate for that, but I'm just perplexed at the decision to not use GHC's Parser. I don't know quite what you mean by stability jle`?
14:47:36 <vaibhavsagar> wroathe: you could try using `ghc-lib-parser`
14:48:18 <wroathe> vaibhavsagar: Oh snap. Thanks.
14:48:51 <jle`> wroathe: basically what MarcelineVQ said, the GHC API is unstable, so depending on it means having to rewrite the api calls every release
14:49:06 <jle`> if you write your own parser then that isn't a big issue, you just won't be able to parse the new stuff i suppose
14:49:17 <vaibhavsagar> also it breaks backward incompatibility with each release
14:49:27 <vaibhavsagar> *backwards compatibility
14:49:57 <boxscape> speaking of, I think I just found a bug in the haskell-src-exts parser... though I need to make sure it's still in HEAD
14:49:59 <vaibhavsagar> there's some incredibly jank CPP I have to use in order to support multiple GHC versions in one codebase
14:51:45 <rhylx> Hi guys :D. I wanned to know if some of your guys already tried to build an instant messaging server (like for WhatsApp for example). I wanned to do it in haskell. After looking up a bit I found the wire messenger project and was wondering what do you think of it? Is it a good starting point to reach my goal, or should I try to do it all from scratch again? Do you know other similar projects that could help me?
14:51:48 <wroathe> jle`: Ah, I see. Also, I didn't realize the version of the GHC lib was tied to the compiler you're using. 
14:52:00 <wroathe> I figured it'd be like any other library
14:54:00 <wroathe> vaibhavsagar: Hah, "The lack of runtime means you can't run code, which includes running code at compile time, e.g. TemplateHaskell.
14:54:03 <wroathe> "
14:54:07 <wroathe> There's always a catch
14:55:59 <vaibhavsagar> wroathe: that's why I'm still using the GHC API directly for IHaskell
14:57:50 <wroathe> vaibhavsagar: Yeah, I might just have to bite the bullet and roll up my incredibly janky CPP sleeves
14:58:41 <vaibhavsagar> wroathe: maybe this will help? https://github.com/gibiansky/IHaskell/blob/93bfa3a7a434c1dfe6873c2105c43856c282e183/src/IHaskell/Eval/Evaluate.hs
15:02:23 <wroathe> vaibhavsagar: Thanks
15:03:58 <boxscape> How can I tell my package.yaml to depend on a package I've built in a local directory rather than on stackage?
15:17:44 <lyxia> you tell that to stack.yaml, not package.yaml
15:18:29 <boxscape> ah that's awkward because I'm actually not using stack...
15:18:52 <lyxia> if you're using cabal, you tell that to cabal.project
15:19:10 <boxscape> that works even if I use hpack?
15:19:23 <lyxia> yes
15:19:39 <boxscape> ok I see if I can figure that out
15:20:02 <lyxia> hpack is merely another syntax for the package's cabal file, it's entirely agnostic to where the packages live.
15:20:36 <lyxia> boxscape: the doc is here https://www.haskell.org/cabal/users-guide/nix-local-build.html#configuring-builds-with-cabal-project
15:20:56 <boxscape> okay, I'm actually indirectly using cabal2nix so I'll have to figure out whether that supports cabal.project, but I would assume so
15:23:08 <boxscape> hm, doesn't actually look like it. I suppose I'll just have to override the package in my nix file, which actually shouldn't be that big of a deal
15:25:56 <lyxia> I haven't used nix, I suppose nix has yet another way of doing this, and that might be it.
15:33:36 <boxscape> for posterity (i.e. the logs), you can use the source-overrides argument in developPackage to use a local package in nix
16:01:55 <boxscape> From what I can see it looks like you can't make a closed data family, is that right? (I guess it would just be a GADT?)
16:09:32 <lyxia> I'm not sure what you can do with it that you couldn't encode with a closed type family and a bunch of separate data types.
16:14:14 <MarcelineVQ> boxscape: some interesting opinions on that here https://www.reddit.com/r/haskell/comments/4tiwvj/gadt_vs_data_families_in_practice/
16:15:19 <boxscape> lyxia: yeah I'm not necessarily saying it would enable you to do new things, just surprised me intially because it's not consistent with the options we have for type families
16:15:24 <boxscape> MarcelineVQ: thanks
16:16:09 <jle`> data families are a little different
16:16:17 <jle`> from GADTs
16:16:35 <jle`> iirc they don't provide any type unification upon pattern matching
16:17:21 <boxscape> as in, you can't say that f ~ g if f a ~ g b?
16:17:41 <boxscape> wait I guess that's not really pattern matching
16:17:46 <jle`> so if you have data MyGADT :: Type -> Type where AnInt :: MyGADT Int; ABool :: MyGADTBool
16:17:55 <jle`> if you pattern match on AnInt, it'll resolve the type parameter to be Int
16:17:59 <jle`> but you don't get that for data families
16:18:02 <boxscape> Ah, I see
16:18:18 <jle`> @let data family MyFam a
16:18:20 <lambdabot>  Defined.
16:18:32 <jle`> @let data instance MyFam Int = IntFam
16:18:34 <lambdabot>  Defined.
16:18:40 <jle`> @let data instance MyFam Bool = BoolFam
16:18:42 <lambdabot>  Defined.
16:19:19 <jle`> @let testFunc :: MyFam a -> a -> Bool; testFunc = \case IntFam -> even; BoolFam -> id
16:19:21 <lambdabot>  .L.hs:184:9: error:
16:19:21 <lambdabot>      • Couldn't match type ‘a’ with ‘Int’
16:19:21 <lambdabot>        ‘a’ is a rigid type variable bound by
16:19:35 <jle`> if it was a GADT with constructors, matching on IntFam would tell ghc that a ~ Int, and this would be ok
16:19:37 <boxscape> okay
16:19:51 <boxscape> so that means GADTs are more powerful, though, right?
16:19:57 <boxscape> (if you wanted a closed data family)
16:20:12 <jle`> i think they're different tools. "more powerful" seems to imply that one subsumes the other in utility
16:20:32 <boxscape> well, yeah, part of my question is whether that's the case :)
16:20:45 <boxscape> specifically wrt closed data families though
16:21:02 <jle`> i'm not sure if i'd say 'more powerful'; just doing different things. i don't think that you can use one to implement the other necessarily
16:21:08 <boxscape> okay
16:21:20 <jle`> data families basically are injective type families with a cleaner namespace
16:21:55 <jle`> but now that we have actual injective type families, their utility is a little less clear
16:22:52 <jle`> maybe mostly the namespace thing?
16:23:02 <boxscape> here's an interesting couple lines connected to this from the reddit thread:
16:23:05 <boxscape> GADTs: If you match on the constructors, you can find out the type.Data families: If you know the type, you can match on the constructors.
16:23:39 <jle`> yeah, now that we have injective type families, you can think of data families purely as sugar for injective type families, i believe
16:23:52 <jle`> in terms of how they interact with the type system and how you use values of their type
16:24:05 <boxscape> I see
16:24:12 <jle`> i'm not sure if this is 100% true, but that's how i see them
16:24:42 <boxscape> I duplicated all my type families as data families in my first singletons project because I didn't know that injective type families were a thing...
16:24:46 <jle`> ie in the example above, it's the same as `type family MyFam a = b | b -> a; data IntFam = IntFam; data BoolFam = BoolFam`
16:24:59 <boxscape> ok
16:25:05 <jle`> and then type instance MyFam Int = IntFam; type instance MyFam Bool = BoolFam
16:25:12 <jle`> and actually using this equivalence, you can make a fake closed data family
16:25:19 <boxscape> ah, good point
16:25:24 <jle`> type family MyFam a = b | b -> a where MyFam Int = IntFam; MyFam Bool = BoolFam
16:26:13 <jle`> but using type families in this way, you do introduce a lot of what could potentially be just noise into your namespace
16:26:59 <jle`> and you run into the problem of naming all your instances
16:27:05 <jle`> and we all know how much haskellers hate naming
16:27:39 <boxscape> yeah...
17:00:56 <nshepperd2> data families are different from injective type families in that they're generative
17:02:09 <boxscape> right, so I guess that was the reason why jle` made data declarations in addition to the injective type family, right?
17:02:10 <nshepperd2> which means that you can unify f a ~ MyDataFamily Int to get (f ~ MyDataFamily, a ~ Int)
17:02:15 <lyxia> is that a useful feature
17:02:27 <jle`> nshepperd2: ah, that's important
17:03:30 <boxscape> lyxia: I think type inference relies on this sort of matchability?
17:03:52 <boxscape> if I remember correctly from reading the -XDependentHaskell proposal
17:03:56 <lyxia> yes I understand how it works in the typechecker
17:04:41 <lyxia> I mean show me a use case where you really need it.
17:07:44 <lyxia> I feel like it adds a lot of complexity for little benefit.
17:08:14 <lyxia> though I could be overstating the complexity and understating the benefits.
17:11:42 <nshepperd2> The "vector" package uses this fact to provide typeclass instances for Unboxed vectors
17:12:22 <nshepperd2> Data.Vector.Unboxed.Vector is a data family
17:15:12 <lyxia> that's fair. But this encoding seems just as good:    newtype Vector a = Vector (Vector_ a)   ;   type family Vector_ a
17:18:15 <lyxia> Is the point to avoid that intermediate name?
17:25:45 <nshepperd2> I suppose that is something it accomplishes
17:28:23 <nshepperd2> also avoids the intermediate names for each instance as jle` mentioned
19:05:22 <jusss> how I can get all the built-in function definitions?
19:05:54 <jusss> I want to know Either's implement for Monad
19:06:02 <jusss> use :i in ghci?
19:06:30 <Silent-Alex> no,it's haskell
19:07:04 <jusss> I don't follow, more specific please
19:07:30 <argent0> jusss: http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Either.html 
19:07:38 <argent0> then find Monad, then click source
19:07:54 <jusss> http://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html
19:08:02 <argent0> which leads you to: http://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.Either.html#line-155
19:08:10 <jusss> argent0: thanks
19:14:30 <orzo> I'm having trouble with GeneralizedNewtypeDeriving because my newtype wrapper is wrapping an object that involves a type-family application.
19:14:43 <orzo> It's not clear to me why that should give GHC trouble.
19:15:05 <orzo> newtype Matrix c r = Matrix (Vector (RepeatBy c (Vector r)))
19:15:18 <orzo> where RepeatBy is a type family
19:26:29 <jusss> how to get value from Either a b?   if you don't know it's Left x or Right x
19:27:39 <jusss> getMv (Just x) = x;  getMv (Just 3) = 3
19:32:28 <Silent_Alex> Hi..
19:33:03 <Silent_Alex> k
19:34:46 <argent0> jusss: You can either get an `a` or a `b`. Depenging wether it is Left or Right
19:39:18 <orzo> I guess i need role annotations for type famlies
19:40:34 <maerwald> hvr: release cabal-install-3 already :P
19:49:41 <turab> :t either
19:49:42 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
19:49:47 <turab> jusss: ^
19:58:19 <jusss> turab: aha, either id id (Left 3) = 3
19:59:43 <jusss> how I can get either's function definition?
20:07:38 <turab> jusss: There are better ways but I just check the source from the documentation
20:07:40 <turab> http://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.Either.html#either
20:10:58 <jusss> turab: can I get that from ghci?
20:20:53 <dmwit> Currently no.
20:20:57 <dmwit> Perhaps someday :doc will do this.
20:21:25 <dmwit> But there is only one possible (total) implementation.
20:21:41 <dmwit> ?. djinn type either
20:21:43 <lambdabot> f a b c =
20:21:43 <lambdabot>     case c of
20:21:43 <lambdabot>     Left d -> a d
20:21:43 <lambdabot>     Right e -> b e
20:22:07 <EvanR> @src either
20:22:07 <lambdabot> either f _ (Left x)  = f x
20:22:07 <lambdabot> either _ g (Right y) = g y
20:22:22 <EvanR> (always fun)
20:34:50 <jusss> dmwit: ok
21:07:30 <tomito> how do i install gchcup or run the terminal? im a noob
21:07:54 <maerwald> tomito: https://www.haskell.org/ghcup/
21:08:35 <tomito> yes what do i do next
21:08:40 <maerwald> did you run it?
21:08:42 <tomito> i run that link 
21:08:47 <tomito> it downloaded me a file
21:08:52 <maerwald> and then you followed the instructions?
21:09:22 <tomito> oh i had to open it in a txt
21:09:24 <tomito> im so dumb
21:10:22 <tomito> thanks
21:19:12 * hackage http-client-overrides 0.1.0.0 - HTTP client overrides  https://hackage.haskell.org/package/http-client-overrides-0.1.0.0 (robbiemcmichael)
21:35:09 <tomito> how do i continue?
21:35:23 <tomito> In order to run ghc and cabal, you need to adjust your PATH variable.You may want to source '/Users/****/.ghcup/env' in your shellconfiguration to do so (e.g. ~/.bashrc).
21:36:35 <tomito> im stuck in this step of the installation 
21:36:41 <tomito> In order to run ghc and cabal, you need to adjust your PATH variable.You may want to source '/Users/******/.ghcup/env' in your shellconfiguration to do so (e.g. ~/.bashrc).
21:37:02 <tomito> can someone help please
21:37:05 <maerwald> tomito: the installation process suggests to do that for you, did you read that part?
21:37:18 <maerwald> or did you just press enter
21:37:41 <tomito> where it suggest so?
21:38:33 <bur57f1r3> mrs count
21:38:38 <tomito> i pressed enter to begin the installation, it was done successfully 
21:38:43 <bur57f1r3> muppets
21:38:49 <bur57f1r3> mrs count
21:38:57 <bur57f1r3> sesame street
21:38:59 <tomito> and at the last part this text appears 
21:39:06 <bur57f1r3> open Zesame
21:39:14 <maerwald> tomito: do you have a ~/.bashrc?
21:39:18 <bur57f1r3> open zesame!
21:39:28 <tomito> i don't know 
21:41:04 <tomito> how do i know?
21:51:25 <tomito> please how do i continue
21:51:37 <tomito> In order to run ghc and cabal, you need to adjust your PATH variable.You may want to source '/Users/t****/.ghcup/env' in your shellconfiguration to do so (e.g. ~/.bashrc).
21:54:45 --- mode: ChanServ set +o dmwit
21:54:52 --- kick: bur57f1r3 was kicked by dmwit (No thanks.)
21:55:01 --- mode: dmwit set +b *!*irc4andro@172.56.12.*
21:55:01 --- kick: bur57f1r3 was kicked by dmwit (bur57f1r3)
21:55:34 --- mode: dmwit set -o dmwit
21:56:21 <dmwit> tomito: Windows, OSX, Linux?
21:56:31 <tomito> OSX
22:07:43 <rajivr___> I am new to Haskell and I've run into a type system issue that I simply can't seem to figure out. https://gist.github.com/rajivr/d03aedfd72ed040016da32f58ede8c27
22:09:20 <rajivr___> Could anybody please give me pointer as to why I can't use a type `forall a. Num a => Optional a` in a constructor of form `forall a. Optional a -> First' a`
22:13:12 <dmwit> rajivr___: Because there's lots of different types that implement Num, and they would be printed in different ways.
22:13:34 <dmwit> Try replacing 1 with (1 :: Int).
22:13:46 <dmwit> ...or (1 :: Double), to see why it complains.
22:14:19 <rajivr___> dmwit: Thanks. Let me try.
22:14:28 <dmwit> Oh, well.
22:14:38 <dmwit> Also because you have written a silly extra constraint in your instances.
22:14:57 <dmwit> You should go ahead and delete the `Semigroup a =>` and the `Monoid a =>` from lines 55 and 58.
22:19:56 <rajivr___> dmwit: Yes, removing the constrains did it. I don't recall why I added those extra constrains. 
22:20:06 <rajivr___> Thanks again for the help.
22:22:57 <dmwit> rajivr___: By the way, when defining a new type just to hang some instances off of, it's better to use newtype than data.
22:23:33 <dmwit> newtypes use the same underlying representation as the type they wrap, whereas data introduces an extra layer of indirection that has a small but noticeable runtime cost.
22:24:58 <rajivr___> I am aware of that. Because I am still learning haskell I am writing both `newtype` and `data` syntax to develop my intuition.
22:42:10 <josiah_sama> Why isn't Vector.Unboxed.Vector an instance of any types like Functor, Applicative, Monoid, etc.
22:43:50 <opqdonut> josiah_sama: it can't be a functor because it would be a "restricted functor"
22:44:06 <opqdonut> the type of fmap wouldn't be (a -> b) -> Vector a -> Vector b
22:44:09 <josiah_sama> how-so?
22:44:25 <opqdonut> but: (Unboxed a, Unboxed b) => (a -> b) -> Vector a -> Vector b
22:44:44 <josiah_sama> ah, I see
22:44:57 <opqdonut> (oh right the type class is called Unbox, not Unboxed)
22:45:15 <opqdonut> this is roughly the same reason as why Data.Set is not a Functor
22:45:24 <josiah_sama> yah, but I got the concept
23:09:27 <tsahyt_> am I right to assume that GHC still cannot unpack strict polymorphic fields? e.g. in V3 Double (from linear), the doubles are behind pointers?
23:10:25 <tsahyt> I've found a 6 year old issue about this on the GHC issue tracker, but it seems no progress was made
23:13:27 <Axman6> it's difficult to do because somethingof type V3 a -> V3 b needs to still work when you have V3 Double
23:14:18 <tsahyt> Axman6: couldn't GHC generate specialized versions, much like C++ templates work?
23:14:37 <tsahyt> so if a ~ Double, it turns into SpecialV3Double -> V3 b
23:17:32 <tsahyt> but in any case, I guess that means that I'll have to write a monomorphic unpacked V3. Unfortunately this won't fit nicely into linear's type classes because the kind would be different :/
23:18:28 <Axman6> how should it do that for a library which has already been compiled?
23:20:42 <tsahyt> Axman6: hm, I don't know. I haven't really thought that deeply about it, I just thought that maybe someone had tackled the issue successfully already.
23:20:53 <tsahyt> doesn't hurt to ask
23:25:54 <c_wraith> what about somewhere in between: SPECIALIZE pragmas for data types?
23:26:10 <Axman6> I would like that
23:26:49 <tsahyt> I think it would solve the problem in most cases
23:27:34 <tsahyt> e.g. in the linear case, there's really only a handful of types you realistically use in a high performance scenario where the unpacking would really matter
23:27:53 <tsahyt> having a few specialized versions for those would already suffice
23:39:08 <Axman6> I feel like edwardk_ might have done some work on making very raw data types which might be interesting, in the structs package: https://hackage.haskell.org/package/structs
