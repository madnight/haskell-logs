00:34:42 * hackage boots-app 0.1.0.7 - Startup factories using IoC monad  https://hackage.haskell.org/package/boots-app-0.1.0.7 (leptonyu)
00:38:17 <jgt> Good morning
00:38:54 <jgt> :t showFixed
00:38:57 <lambdabot> HasResolution a => Bool -> Data.Fixed.Fixed a -> String
00:39:43 <jgt> :t realToFrac
00:39:45 <lambdabot> (Real a, Fractional b) => a -> b
00:42:29 <jgt> > (showFixed True :: Micro -> String) 10.1
00:42:33 <lambdabot>  "10.1"
00:42:44 <jgt> > (showFixed True :: Micro -> String) (realToFrac 10.1)
00:42:47 <lambdabot>  "10.099999"
00:42:54 <jgt> now what is going on there?
00:42:57 <Axman6> @pl f a b c = g x $ h a b c
00:42:57 <lambdabot> f = ((g x .) .) . h
01:03:39 <jusss> :t fmap (-) [3,4]
01:03:42 <lambdabot> Num a => [a -> a]
01:03:48 <jusss> :t (-)
01:03:50 <lambdabot> Num a => a -> a -> a
01:03:55 <jusss> :t fmap
01:03:59 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:04:31 <jusss> why we can put (-) into fmap?
01:04:46 <merijn> jusss: Well, why not?
01:04:58 <jusss> merijn: 'cause it's (a->b)
01:05:11 <merijn> jusss: 'b' is allowed to be 'a -> a'
01:05:28 <merijn> jusss: Remember that "a -> b -> c" is equivalent to  "a -> (b -> c)"
01:06:02 <jusss> merijn: so it's fmap :: (a->(a->a)) -> f a -> f (a->a) ?
01:06:09 <merijn> jusss: Yes
01:07:44 <jusss> and fmap (-) [3,4] == [(-)3 , (-) 4] ?
01:09:33 <merijn> Yes
01:10:11 <merijn> > map ($1) {- passing 1 as argument to every function in a list -} $ fmap (-) [1..5]
01:10:15 <lambdabot>  [0,1,2,3,4]
01:10:43 <jusss> merijn: but why [(-) 3, (-) 4] <*> [1,2,3] =[2,1,0,3,2,1] ?
01:11:33 <merijn> jusss: Because the Applicative for list does cross-product
01:11:46 <merijn> It applies every function from the first list to every value from the second
01:12:18 <merijn> jusss: There are, in fact, two lawful Applicatives for lists. Cross product (the default one) and "zip"
01:12:45 <jusss> merijn: then it should be [2,1,0,3,2,1]
01:12:53 <merijn> > (-) <$> ZipList [3,4] <*> ZipList [1,2,3]
01:12:56 <lambdabot>  ZipList {getZipList = [2,2]}
01:13:16 <jusss> yeah, map (-) 3 on the second list get [2,1,0]
01:43:55 <cheater> hi.
01:44:18 <cheater> i'm trying to use a class method but importing the module doesn't seem to importing it. why would that be?
01:44:21 <cheater> this is it http://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Tree.html#v:foldl-39-
01:44:50 <davean> ecause it doesn't export the class methods it only impliments them
01:45:00 <cheater> i did import qualified Data.Tree as T, and then tried using T.foldl'. ghc told me this: Module ‚ÄòData.Tree‚Äô does not export ‚Äòfoldl'‚Äô.
01:45:04 <cheater> oh, uh
01:45:26 <boxscape> @hoogle foldl'
01:45:26 <lambdabot> Data.List foldl' :: Foldable t => (b -> a -> b) -> b -> t a -> b
01:45:26 <lambdabot> Data.Foldable foldl' :: Foldable t => (b -> a -> b) -> b -> t a -> b
01:45:26 <lambdabot> GHC.List foldl' :: forall a b . (b -> a -> b) -> b -> [a] -> b
01:45:44 <boxscape> Seems like the Data.Foldable import would be most appropriate here
01:45:49 <davean> Yes
01:46:00 <cheater> yeah
01:46:10 <Ariakenom> % :t foldl'
01:46:11 <yahb> Ariakenom: Foldable t => (b -> a -> b) -> b -> t a -> b
01:46:27 <cheater> thank you
01:46:29 <boxscape> % :i foldl'
01:46:30 <yahb> boxscape: class Foldable (t :: * -> *) where; ...; foldl' :: (b -> a -> b) -> b -> t a -> b; ...; -- Defined in `Data.Foldable'
01:46:40 <Ariakenom> you may not need any import afaict
01:53:40 <dminuoso> https://gist.github.com/dminuoso/dff6c9ff2d0ae4f27094644be96cc086 is there any room for improvement?
01:54:31 <dminuoso> (Records can be really annoying to work with, heh)
01:58:09 <dminuoso> I could also mimic the same behavior, by using a mutable (IORef) MailService and then using whenJust
01:58:26 <boxscape> could you do something like `foo ms pa =  [ (\m -> m {ms = x}) | Just x <- [pa pat] ` and then zipWith foo [paFirstName, ...] [msFirstName, ...]?
01:58:56 <boxscape> (or maybe `map foo [(paFirstName, msFirstName), ...]`
01:58:58 <boxscape> )
01:59:06 <dminuoso> boxscape: No because there's more than just Text fields.
01:59:13 <boxscape> ah
01:59:57 <boxscape> if only haskell were dynamically typed :P
01:59:59 <dminuoso> whenJust (paFirstName pat) (\n -> modifyIORef ref (\x -> x { msFirstName = n }) )
02:00:08 <dminuoso> boxscape: In all fairness, you can use Dynamic.
02:00:12 <boxscape> okay
02:00:12 <dminuoso> We do have that feature.
02:01:30 <dminuoso> Actually... there is one improvement I could do.
02:05:53 <dminuoso> I was thinking about perhaps writing ‚åúwhenJustA :: Alternative f => Maybe a -> (a -> f b) -> f b‚åù
02:06:24 <dminuoso> but that's just a visually different way of doing the same thing in the gist
02:18:15 <cheater> in my .cabal, what does base ^>=4.12.0.0 mean? what is the ^ ?
02:19:06 <cheater> Ariakenom: i got confused because Map required an import, and its foldl' wasn't the class one, just one defined as a top level function :)
02:19:19 <dminuoso> cheater: Check https://www.haskell.org/cabal/users-guide/developing-packages.html#pkg-field-build-depends
02:19:36 <cheater> thanks, dminuoso!
02:22:10 <cheater> that explained it well =)
02:30:43 * hackage salak 0.3.5.1 - Configuration (re)Loader and Parser.  https://hackage.haskell.org/package/salak-0.3.5.1 (leptonyu)
02:31:42 <cocreature> I have a project containing of two packages A and A-gen with A-gen depending on A. A-gen is a code generator that generates code that depends on A. Currently the test suite of A-gen shells out to GHC and assumes that A is in the package db for compiling the generated code (it‚Äôs a single file). Is there a nicer way of doing this with just cabal or do I need something external to drive the generation?
02:31:43 * hackage salak-toml 0.3.5.1, salak-yaml 0.3.5.1 (leptonyu): https://qbin.io/fresh-rome-u06a
02:32:47 <merijn> cocreature: I would assume that if A-gen is in scope A would be too?
02:33:13 <cocreature> merijn: but how do I get a GHC with A-gen in scope in my test-suite to compile the generated files?
02:33:13 <merijn> Although you'd have to explicitly depend on A to compile anything generated with A-gen anyway, so it seems kinda moot?
02:33:40 <merijn> cocreature: Sounds like A-gen should be a build-tool-depends for the test suite?
02:36:10 <cocreature> merijn: hm, how would I actually call the generator during the build process? Sounds like a custom setup :/
02:36:36 <merijn> cocreature: Probably
02:37:55 <cocreature> merijn: thanks, I‚Äôll see if I can get something working.
02:38:32 <merijn> I mean, I don't see how cabal could ever be taught about arbitrary code generators without something like Custom setup
02:39:15 <cocreature> yeah makes sense
02:42:49 <merijn> Best ICFP quote I've seen on twitter so far: "I'm going to talk about Haskell 98, by which I mean Haskell with 98 extensions enabled"
02:44:13 * hackage boots 0.1.1 - IoC Monad in Haskell  https://hackage.haskell.org/package/boots-0.1.1 (leptonyu)
02:45:12 * hackage boots-app 0.1.1 - Startup factories using IoC monad  https://hackage.haskell.org/package/boots-app-0.1.1 (leptonyu)
02:47:20 <jusss> merijn: I heard there're lots of wonderful people, can I go there if I wasn't an expert or something?
02:50:08 <merijn> jusss: Sure, it's not like there's any requirements for going to conferences, besides paying (which immediately is the major problem, because conferences are expensive, hence why I vicariously experience ICFP over twitter, rather than being there :p)
02:52:33 <dminuoso> jusss: Haskell eXchange, Munihac, Zurhac - those are great events to attend if you're in Europe. They all have tracks well suited for beginners.
02:54:15 <jusss> dminuoso: I'm not in Europe...
02:54:25 <dminuoso> jusss: Where do you live?
02:54:52 <jusss> dminuoso: a place you may not like
02:55:08 <dminuoso> How do you know what places I like?
02:56:22 <jusss> dminuoso: it's not a democracy country
02:56:55 <dminuoso> jusss: Honestly I dont judge people by the democracy of their country.
02:57:01 <jusss> dminuoso: China
03:04:23 <maerwald> dminuoso: do you judge countries by the democracy of their country? ;)
03:05:18 <dminuoso> jusss: well you could always hop on a plane.. not sure what Haskell events are available in the Asia region.
03:05:18 <maerwald> We've had a few applicants from China, haskell seems to get traction there, but I'm not away of any meetups (it's a big country... kinda...)
03:05:21 <maerwald> *aware
03:07:30 <tdammers> afaik there is some activity in singapore and hong kong, but in general haskell doesn't seem to be anywhere near as popular in asia as it is in europe or the us
03:07:59 <jusss> dminuoso: yeah, there's only a few Conf for other languages like PyCon or RustCon, no scheme or haskell :(
03:09:19 <jusss> it's not a democracy country, so I think it's not easy to travel 
03:09:53 <jusss> or do the invert
03:11:45 <jusss> dminuoso: do you know Sapir‚ÄìWhorf hypothesis
03:12:10 <jusss> aka linguistic relativity
03:12:39 <dminuoso> jusss: No.
03:13:09 <jusss> https://en.wikipedia.org/wiki/Linguistic_relativity
03:14:04 <jusss> I think it works in programming languages
03:15:48 <dminuoso> jusss: Can you be more precise, what do you mean by that?
03:16:13 <jusss> if my mother language is English, I think I can learn Haskell easier
03:17:13 <dminuoso> jusss: Well I think that's true to some degree, but not in the sense of the Sapir-Whorf hypothesis, but rather mere availability of learning material.
03:17:26 <jusss> dminuoso: in programming languages, haskell has lots of monads, scheme has closures, python has decorators, js has promises
03:17:30 <dminuoso> If the majority of learning material is written in English, then knowing English makes learning Haskell easier on the basis of having better access to resources.
03:18:43 <jusss> dminuoso: make a loop, python and C people perfer iteration, but scheme people perfer recursive
03:20:01 <jusss> python people perfer object-class, and scheme peopel perfer closures
03:21:01 <jusss> dminuoso: but I never work it out about how to do a closure like scheme in haskell
03:21:02 <dminuoso> jusss: Well if, resuming yesterdays discussion, people used ‰∏ä‰∏ãÊñá instead of context when talking about Functor/Applicative/Monad, would that realistically make any difference to you? You'd wonder what that even means.
03:21:40 <yushyin> what is a closure like scheme?
03:21:56 <jusss> or in java, I can't image to do that closure or other thing in java
03:22:20 <tdammers> sapir-whorf certainly applies to programming languages - whatever is easy or obvious in a programming language you are familiar with will be more easy to access mentally
03:22:35 <jusss> yushyin: https://stackoverflow.com/questions/36636/what-is-a-closure
03:22:36 <tdammers> java can do closures though, you just have to make them objects
03:22:43 <yushyin> jusss: I know hat a closure is
03:23:00 <tdammers> but closures are a great example, actually
03:23:01 <dminuoso> jusss: learning haskell is more difficult than say scheme because you don't have the same imperative backdoors to fall back on.
03:23:12 <yushyin> I ask for the specific 'scheme closure'
03:23:29 <tdammers> you can implement a closure mechanism in C, with lots of boilerplate, syntactic noise, and godawful CPP macro abuse
03:23:35 <yushyin> I use closures often in java/c++/haskell
03:23:37 <tdammers> but it is not an obvious thing to do
03:23:42 <jusss> tdammers: see that's the point, if you have objects, then what's the point to use closure ?
03:25:04 <dminuoso> jusss: Sometimes the comparisons take a broader perspective. For example, based on the notion of "keeping data together, encapsulating access" that Java has, we can do exactly the same thing! Create a data type, add some functions that operate on said data type.
03:25:15 <tdammers> jusss: are you familiar with the Runnable pattern in Java? That's basically a closure. You create an instance of an anonymous class that closes over some local variables, and pass that object into a context where the closed-over variables are no longer in scope
03:25:29 <dminuoso> This "a->b" or "a.b()" is just syntax, where in Haskell you'd write b(a) rather.
03:25:33 <dminuoso> or ‚åúb a‚åù I meant :)
03:26:08 <tdammers> dminuoso: not entirely. a.b() also passes an implicit "this" pointer
03:26:24 <dminuoso> tdammers: b(a) is that.
03:26:31 <dminuoso> tdammers: you pass the reference to a to b
03:26:47 <dminuoso> tdammers: It's merely syntactic sugar
03:27:09 <tdammers> well, it is as long as you don't have any actual "methods"
03:27:24 <dminuoso> what is a method, really but a function that implicitly takes some relevant object to operate on?
03:27:29 <tdammers> effectively, b() can be polymorphic over the runtime value of a
03:27:36 <jusss> yushyin: (define count  (let ((n 0)) (lambda () (set! n (+ n 1)) n)))
03:28:25 <tdammers> a.b(), in a typical OOP language, means "look up the 'b' method in the vtable that comes with the 'a' object, then pass 'a' to that method"
03:28:46 <dminuoso> tdammers: The only special feature you end up finding is inheritance, really.
03:29:00 <dminuoso> So its inheritance that sets java's system apart from ours. Not this notion of "classes" or "objects"
03:29:21 <tdammers> not necessarily inheritance, but open recursion (which, however, is really only practically useful with inheritance or monkey-patching or a similar mechanism)
03:29:25 <jusss> tdammers: I'm not familiar with java yet...
03:29:35 <dminuoso> tdammers: right.
03:29:50 <tdammers> jusss: the same considerations hold for any OOP language - even JS or Python
03:30:13 <dminuoso> tdammers: The point Im making is just that there's often discussions about "OOP" vs "FP" that are silly because they appear to be discussions about syntactical niceties, not about type systems involving inheritance 
03:30:29 <tdammers> dminuoso: absolutely, a lot of people are completely missing the point
03:30:41 <tdammers> dminuoso: for starters, you can have functional object-oriented programming just fine
03:30:46 <dminuoso> indeed :)
03:31:22 <tdammers> dminuoso: it just so happens that all the popular OOP languages aren't very functional, and all the popular FP languages don't come with OOP features (though you can, with a bit of persistence, build them yourself)
03:31:30 <jusss> tdammers: but we can do closure without OO in JS and Python like Scheme, just return a function which is with a lexical namespace if I describe properly
03:31:49 <tdammers> plus the fact that there are at least two classes of definitions of FP that effectively mean completely different things
03:32:06 <tdammers> jusss: sure. "closures" and "OOP" are completely unrelated language features
03:32:34 <jusss> tdammers: I know there're OO based on class or prototype, even based on closure
03:33:04 <jusss> JS is based on prototype, which is weird, I only know it's not based on class
03:33:19 <jusss> otherwise like java or python , I think they're based on class
03:33:36 <tdammers> JS' prototype OOP was a mistake IMO
03:33:49 <tdammers> but "classes" in OOP are really kind of a compiler performance hack
03:33:49 <dminuoso> jusss: JS has strange semantics because it was rushed by a single person in 10 days without any thought, design or theory.
03:34:05 <jusss> tdammers: 'cause the creator want to implement a scheme in the original design
03:34:17 <dminuoso> jusss: People have developed a habit of using what JS has produced, and calling parts of it as "design", "principle" or "patterns"
03:34:26 <jgt> dminuoso: there was thought, but there were also temporal and political constraints
03:34:28 <jusss> dminuoso: hey, but JS is so popular now
03:34:36 <tdammers> yes. and then some pointy-haired boss said "java is the future, make it more like java", and he changed the syntax to look like java, and added "OOP"
03:35:07 <jgt> I had a play with Io which is a prototypal language, and I thought it was pretty neat
03:35:38 <jgt> I'm not defending JS of course. It's always been bad, and somehow it seems to have gotten worse these past few years.
03:35:42 <tdammers> given the insane constraints, I think JS turned out pretty amazing
03:35:56 <maerwald> ts is nice
03:36:02 <jusss> tdammers: but to me, Java is a completly disaster
03:36:11 <dminuoso> tdammers: Well even PHP has turned into being usable after Facebook has invested millions of fixing all the flaws and baking it into Hack.
03:36:14 <tdammers> IMO java belongs in a museum
03:36:35 <tdammers> nah, PHP is still fundamentally flawed, the real problems with it are unfixable
03:36:36 <maerwald> structural typing is more intuitive than haskells type system, although a little bit less expressive in the case of ts
03:36:37 <dminuoso> Given enough money and time, you can hammer out some of the oddities.
03:36:38 <jusss> Java is really shouldn't be learn by people 
03:36:46 <dminuoso> tdammers: Have you tried Hack?
03:36:56 <tdammers> dminuoso: that's not PHP though is it
03:37:35 <dminuoso> tdammers: Well Hack is a spiritual successor just as much as current ECMAScript is a successor to the 10-day Eich Marathon.
03:37:40 <jusss> it's 2019, and Java still doesn't support async programming, what the heck they're thinking?
03:38:36 <jusss> and their syntax are really horriable
03:38:38 <tdammers> jusss: Java gambled hard on multithreading and has all sorts of support for that wired into the core language. I'm pretty sure you can get async-style concurrency with suitable libraries though
03:39:05 <jusss> tdammers: yeah, there's vert.x stuff, but not stdlib
03:39:13 <tdammers> and syntax? syntax matters, but I wouldn't dismiss a language for its syntax, unless an equivalent with significantly better syntax were available
03:39:39 <tdammers> fwiw, haskell doesn't provide async primitives either, you have to use a library that gives you those
03:39:44 <jusss> tdammers: I think if there's no IDE, you can not write a simple Java program
03:39:55 <tdammers> yes you can, I have, it's just not fun
03:40:02 <dminuoso> In fact, JVM started out with green threads even - but their implementation was really lacking. It wasnt until GHC that I truly appreciated green threads. :-p
03:40:20 <tdammers> erlang did a lot of pioneering work in that area though
03:40:26 <jusss> if there's no auto-complete and auto-indent in that Java IDE, I think nobody could write a simple java code
03:40:34 <tdammers> ("Erlang, the only actual OOP language that people still use")
03:40:42 <tdammers> jusss: sure. I have.
03:40:44 <dminuoso> tdammers: I bet they did. Erlang is that language I have some rudimentary skills at but never dived in.
03:41:10 <tdammers> dminuoso: same here. I know the concepts, I know roughly how you'd apply them in principle, but I've never written a single line of Erlang :D
03:41:27 <dminuoso> Erlang is a really odd language in that the semantics are weird and not very nice, but OTS more than makes up for it all - from what Ive heard.
03:41:49 <dminuoso> *OTP
03:42:01 <jusss> and what 'bout scheme?
03:42:09 <jusss> or common lisp
03:42:15 <dminuoso> Ive dabbled a bit with Elixir at least, which is a horrid language.
03:42:31 <dminuoso> Elixir is a demonstration of how not to write a language.
03:42:57 <dminuoso> The benefits of BEAM and OTP are great in our code base, but the ergonomics of the language drive you crazy
03:43:06 <jusss> dminuoso: do you try idris?
03:43:07 <dminuoso> We should have done it in Erlang.
03:43:49 <dminuoso> jusss: Beyond installing it on my machine and typing a few lines? No.
03:43:52 <tdammers> haven't tried common lisp, but it seems fairly niche these days; clojure and scheme (and racket) are probably the lisps to look into these days
03:43:59 <tdammers> personally, I found all of them disappointing
03:44:24 <jusss> tdammers: CPS is really an interesting stuff 
03:44:27 <tdammers> but maybe that's due to people calling them "functional"
03:44:35 <dminuoso> tdammers: Have you checked out carp? That's an interesting project.
03:44:38 <jusss> but I don't know it well yet
03:44:41 <tdammers> dminuoso: nope - linky?
03:44:45 <dminuoso> tdammers: https://github.com/carp-lang/Carp
03:44:54 <jusss> tdammers: scheme is not really a functional...
03:45:14 <tdammers> jusss: no, it's not. neither is clojure, or racket, or CL
03:45:31 <jusss> tdammers: but they have AST
03:45:34 <dminuoso> servant-client question, how do you make that work with BasicAuthCheck? I cant figure out how to produce a client :o
03:46:02 <tdammers> jusss: "having an AST" is an implementation detail. the kicker with lisps is that they *expose* the AST directly, and allow you to manipulate it
03:46:29 <jusss> tdammers: so we have have wonderful *macro* in lisp
03:46:44 <dminuoso> jusss: The problem is that the barrier where this happens is invisible.
03:46:46 <jusss> I never saw something like macro in other languages
03:46:53 <dminuoso> jusss: We have it.
03:47:01 <dminuoso> jusss: It's called Template Haskell.
03:47:12 <dminuoso> jusss: Elixir has it in the same form that Lisp does too.
03:47:14 <tdammers> jusss: yes. macros. they're insanely neat, from a geek factor perspective, but in practice, it turns out they're actually downright terrible, because they make a principled, reasoning-driven workflow completely infeasible
03:47:31 <jusss> dminuoso: then continuation?
03:47:37 <dminuoso> jusss: ?
03:47:47 <jusss> dminuoso: do they have that continuation?
03:47:52 <dminuoso> jusss: What do you mean?
03:47:53 <tdammers> jusss: and Template Haskell pretty much has the same problems as Lisp macros in that regard, which is why it is generally recommended to avoid it if possible
03:48:09 <dminuoso> Though TH has its valid uses.
03:48:18 <jusss> dminuoso: lisp has a function called call-cc
03:48:19 <tdammers> you could also say that eval() in a dynamic language is essentially a macro feature
03:48:24 <dminuoso> Luckily TH is not overused because the difficulty threshold of using TH is pretty high.
03:48:30 <tdammers> dminuoso: yes, that's why I said "avoid", not "never use"
03:48:43 <dminuoso> So only competent people often feel equipped to use TH, and they have a tendency to know when not to use it.
03:49:06 <tdammers> dminuoso: except for yesod. TH usage in yesod is just off the charts.
03:49:12 <dminuoso> jusss: call-cc.. yeah we have that.
03:49:19 <yushyin> jusss: we do have Control.Monad.Cont.callCC
03:49:29 <dminuoso> % :t callCC
03:49:30 <yahb> dminuoso: MonadCont m => ((a -> m b) -> m a) -> m a
03:49:34 <dminuoso> It's exactly that.
03:49:36 <jusss> dminuoso: yushyin ... 
03:49:38 <dminuoso> The monster of spaghetti code.
03:49:49 <jusss> I haven't known haskell well yet
03:50:07 <tdammers> PureScript, a language that is very similar to Haskell and heavily influenced by it, but designed to compile to JS and integrate with its ecosystem, has a CPS abstraction called Aff
03:50:16 <dminuoso> Continuations is the best way to turn your code into "Ive written it and no idea what it means or does" 
03:50:30 <jusss> and some people call the Cont monad is the mother of all the monads
03:50:31 <tdammers> it's pretty neat - it allows you to write what is essentially async/await code as if it were plain old linear code
03:50:49 <tdammers> jusss: and then you have people who argue that Cont is not an actual Monad
03:51:12 <dminuoso> tdammers: Perhaps because of that exactly. Cont doesnt carry any specific semantics, it carries all of them.
03:51:16 <jusss> tdammers: and I heard before monad, haskell use CPS to do IO stuff
03:51:37 <dminuoso> jusss: Nope. IO is done by GHC and you dont need to know how.
03:51:38 <tdammers> also, re CPS; it's interesting how much effort the JS community puts into writing frameworks that can do concurrent stuff without having to explicitly write CPS code
03:52:27 <tdammers> the way we "do IO" in Haskell is basically that we write pure code (no side effects) that outputs abstract, opaque values representing effectful programs
03:52:31 <dminuoso> jusss: Before IO your main used to be a function [Response] -> [Request]
03:52:57 <dminuoso> jusss: So you'd issue side effects by emitting a request, and then reading from your response list to get the result
03:53:10 <tdammers> we cannot conjure up these effectful programs out of thin air; we have to build them using primitives provided by the compiler
03:53:16 <tdammers> we can only combine existing primitives
03:53:32 <jusss> dminuoso: so can CPS instead of Monad on something?
03:53:52 <dminuoso> jusss: That sentence is gibberish. Can you please rephrsae?
03:54:13 * hackage now-haskell 0.1.0.0 - Zeit Now haskell-side integration and introspection tools.  https://hackage.haskell.org/package/now-haskell-0.1.0.0 (IanDuncan)
03:54:33 <tdammers> so instead of writing a program that reads a line from stdin and echos it on stdout, we write a Haskell program that constructs an imperative program that reads a line from stdin and echos it on stdout, by using the "read a line from stdin" primitive, the "write a string to stdout" primitive, and the "bind" combinator that combines two programs into one, connecting the output of the first to the input of the
03:54:35 <tdammers> second
03:54:41 <jusss> dminuoso: if somewhere we used monad, can we use CPS to instead of monad there?
03:54:56 <tdammers> note that this has absolutely nothing to do with monads; the "magic" is in the IO type, not in the fact that it's a monad
03:55:36 <tdammers> we could still do the same thing if the Monad abstraction had never been discovered, we would just be unable to generalize the "bind" combinator to other monads like lists, optionals, continuations, etc.
03:55:54 <tdammers> jusss: no, we cannot "use CPS instead of monad"
03:57:13 <jusss> tdammers: so I wonder how haskell handle IO before monad was found
03:57:26 <dminuoso> 12:52:08        dminuoso | jusss: Before IO your main used to be a function [Response] -> [Request]
03:57:40 <jusss> dminuoso: ok
03:57:45 <dminuoso> 12:52:35        dminuoso | jusss: So you'd issue side effects by emitting a request, and then reading from your response list to get the result
04:05:37 <maerwald> you could also remove the Monad instance from IO and write custom combinator functions. There is really not much to it
04:05:51 <maerwald> You just lose the free "monad facilities"
04:06:35 <mimmone> hi guys, i'm in trouble installing ghcup, is there anyone that can help me?
04:06:40 <maerwald> yes
04:08:00 <mimmone> thanks, so after i digit ‚Äú curl https://get-ghcup.haskell.org -sSf | sh ‚Äú in the terminal, it gives me this message "Following commands are required, but missing, please install:  xz"
04:08:12 <maerwald> OS?
04:08:35 <mimmone> macOS Mojave
04:08:38 <maerwald> oh, second
04:08:46 <mimmone> 10.14.1
04:08:53 <maerwald> You probably missed some of the messages during install, there is some documentation about package install
04:09:08 <maerwald> https://gitlab.haskell.org/haskell/ghcup/blob/master/.requirements/ghc/darwin
04:09:42 <merijn> mimmone: Do you have XCode + command line tools installed?
04:09:51 <mimmone> nope 
04:09:56 <merijn> mimmone: You need those
04:10:23 <maerwald> is that still recent?
04:11:08 <maerwald> xz is not needed
04:11:14 <maerwald> https://gitlab.haskell.org/haskell/ghcup/merge_requests/109
04:11:16 <mimmone> for install it, i need to upgrade macOS
04:11:17 <merijn> mimmone: You can install XCode via app store, then run "xcode-select --install" in the terminal to install commandline tools
04:11:21 <maerwald> we remove that requirement for OSX
04:11:34 <maerwald> ghcup doesn't use xz on mac
04:11:35 <merijn> maerwald: You still need commandline tools + XCode for a working GHC :)
04:11:54 <maerwald> but it's fishy that it is checking for xz
04:12:29 <merijn> mimmone: Why would you need to upgrade macOS to install xcode?
04:12:42 <maerwald> it suggests that distro detection didn't work
04:13:16 <maerwald> https://gitlab.haskell.org/haskell/ghcup/blob/master/ghcup#L600-605
04:13:55 <maerwald> mimmone: can you run ~/.ghcup/bin/ghcup debug-info
04:14:29 <mimmone> it keeps sending that i require xz 
04:15:59 <maerwald> mimmone: can you add an empty executable script file 'xz' to your path temporarily?
04:16:11 <maerwald> just so you can run debug-info
04:18:50 <mimmone> don't know how to 
04:20:12 <maerwald> touch xz && chmod +x xz && PATH=".:$PATH" ~/.ghcup/bin/ghcup debug-info
04:24:21 <mimmone> Script variables:  GHC install location:     /Users/DDP/.ghcup/ghc  Binary install location:  /Users/DDP/.ghcup/bin  Tarball cache location:   /Users/DDP/.ghcup/cache  Downloader:               curl -L --fail -O <url>  Script update url:        https://gitlab.haskell.org/haskell/ghcup/raw/master//ghcup  GHC download baseurl:     https://downloads.h
04:24:21 <mimmone> askell.org/~ghc  Meta download url         https://gitlab.haskell.org/haskell/ghcup/raw/master//.download-urls  Meta download format      1  Meta version url          https://gitlab.haskell.org/haskell/ghcup/raw/master//.available-versions  Meta version format       1Detected system information:  Architecture:   x86_64  Distribution:   Darwin  Dist
04:24:22 <mimmone> ro alias:   darwin  Distro version: 18.2.0
04:25:52 <maerwald> right, I think it's a bug
04:29:10 <maerwald> ok, run "curl https://get-ghcup.haskell.org -sSf | sh" again
04:31:41 <mimmone> well
04:31:56 <mimmone> bro it works now 
04:31:59 <maerwald> :D
04:32:21 <mimmone> thanks man 
04:33:55 <freeman[w]__> anyone know what the fix to this is? https://github.com/phoityne/hdx4vsc/issues/5
04:39:42 * hackage alarmclock 0.7.0.2 - Wake up and perform an action at a certain time.  https://hackage.haskell.org/package/alarmclock-0.7.0.2 (dcturner)
04:40:42 * hackage bank-holidays-england 0.2.0.2 - Calculation of bank holidays in England and Wales  https://hackage.haskell.org/package/bank-holidays-england-0.2.0.2 (dcturner)
04:51:11 <freeman[w]__> also run into this issue: https://github.com/phoityne/phoityne-vscode/issues/46
05:00:12 * hackage ghc-paths 0.1.0.12 - Knowledge of GHC's installation directories  https://hackage.haskell.org/package/ghc-paths-0.1.0.12 (SimonMarlow)
06:11:58 <mimmone> guys cabal isn't working for me 
06:12:04 <mimmone> i can't install tidal 
06:14:39 <maerwald> what is the error? Can you use a pastebin service to show the message?
06:14:45 <maerwald> @pastebin
06:14:45 <lambdabot> Unknown command, try @list
06:15:54 <mimmone> Installing GHC-8.6.5 for Darwin on architecture x86_64GHC already installed in /Users/DDP/.ghcup/ghc/8.6.5, use --force to overwriteSetting GHC to 8.6.5DoneInstalling cabal-install-2.4.1.0 into "/Users/DDP/.ghcup/bin"Successfully installed cabal-install into  /Users/DDP/.ghcup/binDownloading the latest package list from hackage.haskell.orgTo revert
06:15:55 <mimmone>  to previous state run:    cabal new-update 'hackage.haskell.org,2019-08-21T11:58:57Z'Installation done!Don't forget to source /Users/DDP/.ghcup/env in your ~/.bashrc or similar.
06:16:44 <maerwald> plase use a pastebin service
06:16:46 <maerwald> https://privatebin.net/
06:16:50 <mimmone> this is the last message after the installation, but when i try to install tidal via "cabal install tidal", it says "cabal: command not found"
06:17:14 <maerwald> mimmone: yes, follow the instrutions when using ghcup
06:17:22 <maerwald> "Don't forget to source /Users/DDP/.ghcup/env in your ~/.bashrc or similar"
06:17:31 <mimmone> https://privatebin.net/?6fc4c46a1c65fc2d#FP1mhbvKFwRmxnPnqdjAMskogNjvbTZuAo1uQyoq6Aww
06:17:33 <maerwald> you are using bash I assume?
06:17:39 <mimmone> yep
06:17:59 <maerwald> then add 'source /Users/DDP/.ghcup/env" at the end of your ~/.bashrc
06:18:18 <maerwald> without the broken quotes
06:20:08 <mimmone> seems like is working
06:47:34 <jle`> üéø surely it doesn't catche results of calls like id 1, id True ?
06:49:57 <Guest_58> Hey! i can't seem to figure out how i get GHCi running in terminal. On Os X. Installed all the components i was instructed to do at haskell.org, but terminal can't find my ghci command. Anyone got a clue what might have happened?
06:50:43 <dminuoso> Guest_58: Which installation method did you use?
06:51:15 <Guest_58> curl https://get-ghcup.haskell.org -sSf | sh in terminal 
06:52:40 <dminuoso> Guest_58: Did you install any ghc version already?
06:53:45 <Guest_58> Yes, i tried with the link download yesterday 
06:54:12 <dminuoso> Guest_58: I meant, did you actually use ghcup to install ghc already? :)
06:54:54 <Guest_58> I've only done that once. If that was the question :)  
06:56:49 <dminuoso> Guest_58: Did you also use ‚åúghcup set‚åù to select that version as the active GHC?
06:58:15 <Guest_58> Probably not
07:06:25 <libertyprime> can the = operator be written in prefix form?
07:06:42 <merijn> libertyprime: No, because there is no = operator
07:08:07 <libertyprime> cool thanks
07:09:12 * hackage essence-of-live-coding 0.1.0.0 - General purpose live coding framework  https://hackage.haskell.org/package/essence-of-live-coding-0.1.0.0 (turion)
07:09:21 <tdammers> (for giggles, try to come up with a type for (=)...)
07:11:25 <maerwald> dminuoso: when running that curl | sh thing, then the script already runs "ghcup set"
07:12:02 <maerwald> I suspect (s)he didn't adjust PATH
07:12:10 <maerwald> seems to be a recurring problem
07:12:10 <libertyprime> tdammers: i will try that once i have become graduated from being a noob
07:12:50 <tdammers> libertyprime: well, once you're no longer a noob, it will become obvious why that would be a nonsensical thing to try
07:13:55 <tdammers> mainly because = never appears on its own, it's always part of one of a handful of syntax constructs - a top-level binding, a where clause, or a let binding
07:17:50 <joeyh> if I have a mutable vector input, is there any way to freeze it in pure code? ST defeated me doing this, and I'm not sure if it was intentional..
07:18:53 <joeyh> I mean to say, make a immutable frozen copy so I can extract values from it
07:19:16 <voyons_osti> yes, that's exactly what it does
07:19:34 <comerijn> joeyh: You have to freeze it before handing it to pure code
07:20:27 <hyperisco> tdammers, (=) :: (funlhs | pat^0 | var) -> rhs -> (decl | cdecl | idecl)
07:20:27 <joeyh> thanks, I thought so -- all the examples with ST make the immutable vector inside ST and so the types then line up and it can be frozen and returned
07:20:38 <vancha112[m]> would it make sense that someone with discalculia will have a hard time learning haskell?
07:20:55 <comerijn> joeyh: You can really usefully return a mutable ST vector from an ST action, though...
07:21:05 <comerijn> joeyh: So how are you getting said vector in the first place?
07:21:10 <c_wraith> I think that should be "can't"
07:21:17 <comerijn> s/can/can't/ yes
07:21:50 <joeyh> comerijn: I'm building it with Mutable.replicate ... I actually use the vector as a memory buffer in a FFI interface, which is why I made it mutable
07:22:13 <joeyh> but perhaps my FFI should handle the freezing it something like that
07:22:17 <comerijn> joeyh: My point is that if you're getting "MVector s a" and you're not inside ST already, you're getting something useless
07:22:29 <joeyh> sure, it's an IOVector currently
07:22:56 <comerijn> joeyh: Oh, then it's possible. But I'd say your FFI should freeze before returning
07:23:30 <comerijn> joeyh: I assume you have a mutable buffer and you want to periodically return the contents as Vector or something along those lines?
07:23:33 <joeyh> thing is part of the FFI interface involves the user changing values in the vector and calling it, so they need mutability too
07:23:51 <joeyh> but I could have two different data types, one for reading, and one for writing or something
07:23:55 <comerijn> joeyh: I don't really see how those two things conflict?
07:24:05 <comerijn> joeyh: You always have two, freeze makes a copy
07:24:09 <tdammers> vancha112[m]: no idea... I'd expect Haskell to not be different from any other general-purpose programming language in that regard though. Haskell has an image of being "mathy", but that refers to its (mostly cultural) links to abstract mathematics, it doesn't mean that you need to do any more "math" (calculus) than in the next language
07:24:11 <comerijn> That's the entire point of freeze
07:24:33 <comerijn> joeyh: Hence why "unsafeFreeze" is, well, unsafe :)
07:24:43 <tdammers> vancha112[m]: but I'm not familiar with what exactly discalculia entails, so it may still be more difficult to learn programming in general
07:24:58 <kuribas> tdammers: it also leads people to believe that doing math in haskell is easier, which it isn't necessarily
07:25:09 <tdammers> kuribas: that too.
07:25:21 <jgt> yeah I really don't get numbers in Haskell
07:25:23 <jgt> for example
07:25:25 <tdammers> kuribas: at least for the "math == calculus" interpretation
07:25:29 <jgt> > (showFixed True :: Micro -> String) 10.1
07:25:32 <maerwald> tdammers: and maths is easier in python =)
07:25:33 <lambdabot>  "10.1"
07:25:34 <jgt> > (showFixed True :: Micro -> String) (realToFrac 10.1)
07:25:37 <lambdabot>  "10.099999"
07:25:53 <tdammers> it *is* often easier to implement mathematical theorems in haskell than in, say, C
07:26:00 <comerijn> jgt: "Defaulting"
07:26:02 <tdammers> (or rather, direct applications of theorems)
07:26:36 <joeyh> hmm, if the FFI freezes though, it seems it would need to allocate a new buffer for each call. So far I've avoided repeated allocation, the MVector can be reused
07:26:41 <vancha112[m]> maybe haskell is just geared towards solving different problems then (or more easily used to solve certain problems) that what i'm used to.
07:26:50 <kuribas> tdammers: symbolic computation could be pretty awesome in haskell, with a good library (which doesn't exist).
07:26:54 <jgt> comerijn: oh, so is this solved by adding an explicit type?
07:27:15 <kuribas> tdammers: if there was a good port of NumPy to haskell, I'd use that too.
07:27:16 <vancha112[m]> I can't really undertand the whole concept of lambda calculus. which i feel interferes with my ability to write good haskell
07:27:19 <vancha112[m]> *understand
07:27:30 <comerijn> jgt: Micro is a type synonym for Fixed (which has an exact) precision and decimal literals are interpreted via Rational (which is also exact)
07:27:30 <kuribas> vancha112[m]: lambda calculus is really simple
07:27:49 <vancha112[m]> kuribas isn't anything if you know how it works? :P
07:27:50 <comerijn> jgt: So form literal directly to Micro is exact
07:27:59 <kuribas> vancha112[m]: http://www.nyu.edu/projects/barker/Lambda/barendregt.94.pdf
07:28:04 <kuribas> vancha112[m]: not really, no
07:28:16 <comerijn> jgt: However, realToFrac probably ends up defaulting to Double before the conversion to Fixed, which loses exactness
07:28:43 <comerijn> joeyh: You can't directly return the MVector's buffer, because if you mutate it on the next call the pure vector would be changed and all purity broken
07:28:47 <jgt> :t 10.1
07:28:49 <lambdabot> Fractional p => p
07:28:59 <jgt> :t (realtoFrac 10.1)
07:29:02 <lambdabot> error:
07:29:02 <lambdabot>     ‚Ä¢ Variable not in scope: realtoFrac :: Double -> t
07:29:02 <lambdabot>     ‚Ä¢ Perhaps you meant ‚ÄòrealToFrac‚Äô (imported from Prelude)
07:29:04 <vancha112[m]> I'll read through that pdf, but i've read a lot of explanations already. so i don't have high hopes of getting it this time :o
07:29:15 <jgt> :t (realToFrac 10.1)
07:29:17 <vancha112[m]> thanks though ;)
07:29:18 <lambdabot> Fractional b => b
07:29:56 <comerijn> jgt: Fractional uses "fromRational :: Fractional a => Rational -> a" and since numeric literals are always finite length you can always create an exact Rational for them
07:30:19 <comerijn> > realToFrac 10.1 :: Micro
07:30:22 <lambdabot>  10.099999
07:30:30 <comerijn> > realToFrac (10.1 :: Rational) :: Micro
07:30:36 <lambdabot>  mueval-core: Time limit exceeded
07:30:40 <comerijn> > realToFrac (10.1 :: Rational) :: Micro
07:30:43 <jgt> lol
07:30:44 <lambdabot>  10.100000
07:31:03 <comerijn> jgt: lambdabot's VPS is overloaded :)
07:31:15 <kuribas> vancha112[m]: really, lambda calculus is not much more than just substitution
07:31:25 <c_wraith> vancha112[m]: Haskell might have some advantages for you, too.  One of the effects wikipedia lists is a reduction in working memory.  Working memory is always an issue in keeping track of a program's behavior, and Haskell's purity and type system mean you can keep smaller pieces in your head at once without suffering.
07:31:49 <kuribas> vancha112[m]: the lambda expression tells you what to substitute where, and the application does the substitution
07:31:58 <comerijn> jgt: So the problem is that realToFrac is polymorphic in its input type and GHC ends up defaulting it to Double (which is the default for the Fractional class), which messes you up
07:32:02 <libertyprime> random question: Is there a sexp syntax sugar out there for haskell?
07:32:12 * hackage extra 1.6.18 - Extra functions I use.  https://hackage.haskell.org/package/extra-1.6.18 (NeilMitchell)
07:32:23 <kuribas> vancha112[m]: think of a lambda expression as a macro, then application is macro expansion.
07:32:53 <c_wraith> libertyprime: someone was working on a racket dialect that was basically Haskell.  I can't remember the name of it, but it'd be close to what you're asking.
07:33:40 <c_wraith> libertyprime: oh.  it might be the easiest possible portmanteau pun:  https://lexi-lambda.github.io/blog/2017/01/02/rascal-a-haskell-with-more-parentheses/
07:33:43 <comerijn> jgt: I would recommend enabling -Wtype-defaults for this reason
07:33:58 <comerijn> jgt: It warns if/when GHC ends up using defaulting because types can't be inferred
07:33:59 <ClaudiusMaximus> libertyprime: historically "liskell" (2007, probably bitrotted)
07:34:08 <vancha112[m]> kuribas that kind of sounds like the way functional programming in general was explained to me :o
07:34:11 <comerijn> And I just learned that's not in -Wall :O
07:34:21 <kuribas> vancha112[m]: good :)
07:34:40 <comerijn> Oh wait, looks like -Wall should indeed turn it on
07:35:05 <vancha112[m]> working through the explanation in the pdf first. see if i can work through the first chapter ^^
07:36:59 <jgt> comerijn: yeah that's good advice, and I do do that
07:38:12 <comerijn> jgt: If you try running that example in ghci after doing ":seti -Wtype-defaults" you will indeed get two warnings :)
07:38:23 <jgt> comerijn: that's really helpful. Thanks Merƒ≥n.
07:38:34 <comerijn> But yeah, Num and co is for sure one of the ugliest parts of Haskell
07:38:45 <jgt> I had been getting the warnings all along, but I ignored them!
07:38:46 <kuribas> vancha112[m]: for example  "\x . x + 1" means, x is is placeholder for anything else, applying this function will replace the x in the body with whatever you apply it to.
07:39:15 <comerijn> jgt: Often they're fine, but I find the cost of adding a single type annotation fairly small if it avoids these potential issues :)
07:39:41 <kuribas> vancha112[m]: though in the pure lambda calculus "+" and "1" are also functions (so lambda expressions)
07:41:16 <vancha112[m]> kuribas the first part still makes sense. I can see the x being a variable that contains a certain value. I don't see how something that looks like the smallest possible unit of an expression (atom?) could be a function.
07:41:30 <boxscape> > (floor $ 0/0) `div` ((2^64)^16) -- kind of an interesting equation
07:41:34 <lambdabot>  -2
07:41:42 * hackage sparse-tensor 0.2 - typesafe tensor algebra library  https://hackage.haskell.org/package/sparse-tensor-0.2 (nalex)
07:42:23 <kuribas> vancha112[m]: I didn't understand those terms
07:42:45 <dmwit> dminuoso: Basically, yes.
07:43:02 <kuribas> vancha112[m]: you mean how "1" and "+" can be a function?
07:43:10 <vancha112[m]> sorry :) I just don't really understand what it means for an operator to be a function.
07:43:15 <vancha112[m]> yes :o
07:43:17 <libertyprime> c_wraith: ClaudiusMaximus: thanks for the suggestions. 
07:43:21 <comerijn> > floor $ 0/0
07:43:24 <lambdabot>  -269653970229347386159395778618353710042696546841345985910145121736599013708...
07:43:33 <comerijn> That's...bad
07:43:37 <maerwald> lol
07:43:39 <dmwit> dminuoso: Also, I think the argument that Hackage could provide a service but doesn't is not actually uninteresting; the situation would be strictly worse if it were not possible to design a service that mitigated costs.
07:43:45 <boxscape> > floor (0/0) :: Int
07:43:48 <lambdabot>  0
07:43:58 <kuribas> :t (+) -- vancha112[m] 
07:44:00 <lambdabot> Num a => a -> a -> a
07:44:03 <comerijn> Another reason to support the long term plan of getting rid of value NaN!
07:44:31 <comerijn> > floor (1/0) :: Int
07:44:31 <kuribas> vancha112[m]: to understand how 1 can be a function you need to read the paper :)
07:44:32 <Ariakenom> comerijn, that's ambitious! tell me more
07:44:34 <lambdabot>  0
07:44:42 <comerijn> Infinity rounds to 0? What?
07:44:52 <boxscape> And not be IEEE754 compliant anymore? That sounds very adventurous
07:44:53 <kuribas> vancha112[m]: it's lambda expression all the way down :)
07:44:53 <vancha112[m]> I'm trying :) kuribas ;)
07:44:58 <comerijn> boxscape: Wrong!
07:45:10 <comerijn> boxscape: IEEE-754 doesn't require value NaN, that's the great thing :)
07:45:16 <boxscape> ohh interesting
07:45:18 <vancha112[m]> I got stuck at chapter one, with the explanation of E[P] -> E[P']
07:45:51 <comerijn> boxscape: IEEE-754 allows for both value NaN (i.e. values) and trapping NaN (i.e. exception style things)
07:46:27 <maerwald> Today I looked into js libraries and remembered how I rant about the state of haskell libraries... and it made me rethink my position. Api documentation is like "This argument is required if, but not if, and sometimes, ..." and "returns an object that has a similar structure to foo, but only if you passed a function"
07:46:32 <comerijn> boxscape: So it's perfectly legal and valid to make floating point operations that produce NaN produce an exception
07:46:54 <maerwald> I don't understand how people do not go crazy with such APIs
07:46:59 <comerijn> boxscape: This is supported by all CPUs GHC supports, but almost no language makes use of that
07:47:19 <Ariakenom> you don't need CPU support though
07:47:23 <boxscape> hmm but doesn't that also mean that you introduce more partial functions?
07:47:34 <comerijn> Ariakenom: CPU support means you can even trap NaNs in FFI code :)
07:47:34 <ysangkok> maerwald: because if it works in your demo, it looks really simply and convenient, that is a moral booster, enables devs to have continous encouragement while developing
07:47:35 <Ariakenom> and changing float flags is iffy. can break ffi and whatnot
07:48:10 <Ariakenom> oh you wanna use ffi traps! ambitious
07:48:12 <comerijn> Ariakenom: Well, the idea carter and I floated is to basically add a new calling convention to foreign imports that deals with float flags
07:48:35 <ysangkok> maerwald: did you see that new dynamic typing library for haskell? if you wanna save all those js people, that might be the best way :P
07:48:37 <comerijn> Ariakenom: Probably changing the default everywhere is a bit risky, especially on FFI imports
07:49:20 <Ariakenom> you can't just get my hopes up and then dash them like that
07:49:31 <maerwald> ysangkok: I am using typescript for frontend and was trying to write missing type definitions for a js library. So I looked at the API documentation to figure out the types... aaand into the rabbit hole. It is simply impossible (unless you wrote it)
07:49:36 <comerijn> Ariakenom: But there's no reason you couldn't add a new FFI calling convetion that's just "ccall, but trapping FP", so people can opt-in to value NaN free FFI code and also banish them from all your Haskell code
07:49:56 <comerijn> Ariakenom: The goal is to make it at least possible to opt your own code into "no value NaNs"
07:50:38 <c_wraith> maerwald: once you start to see it, it's hard to think other languages have api documentation at all. "but what can I pass to this?!?" 
07:50:54 <comerijn> maerwald: Well, I think this mimics most people's experience, Haskell documentation and tooling seem bad, until you look at how god awful the rest of languages are :p
07:50:56 <Ariakenom> NaNs are probably important for some ffi code, internally and externally. so yeah
07:51:16 <boxscape> come to think of it I probably would have saved a few hours of debugging in my life if NaNs hrew exceptions in C and such
07:51:18 <ysangkok> comerijn: when you say "trap FP" do you mean on with an x86 floating point exception handler or something?
07:51:20 <kuribas> vancha112[m]: you know, with this stuff you have to let it sink.  Read the paper first without fully understanding it, let the ideas sink in, then read it again, and it will make more sense.
07:51:25 <maerwald> c_wraith: well, this library has kinda well documented API... except it's all "may return this, or that and may accept this, but also that, but only if you also pass in this"
07:51:28 <comerijn> Ariakenom: Same way you can already opt-in to interruptible foreign calls
07:51:35 <comerijn> ysangkok: Yes
07:52:13 <maerwald> c_wraith: which makes me think that loose typing really makes people more lazy wrt API design
07:52:16 <ysangkok> comerijn: interesting, but i wonder how many libraries produce a NaN and then throw it away and use a fallback algorithm or something. i guess it wouldn't work on those
07:52:38 <comerijn> ysangkok: Hence why I said it's probably only safe as opt-in method
07:52:49 <ysangkok> comerijn: all right, gotcha
07:53:00 <Ariakenom> comerijn: I agree about IEE754 not needing NaN from my own reading but do you have a succint argument with references I can steal for future use?
07:54:32 <c_wraith> maerwald: good news! whenever dependent Haskell arrives, we'll be able to do the same thing in Haskell APIs! :P
07:55:12 <comerijn> Ariakenom: Not of the top of my head
07:56:06 <Ariakenom> it's definitely something that I've said and people haven't bought it. maybe the internet has something
07:56:27 <maerwald> c_wraith: blergh!
07:56:49 <comerijn> Ariakenom: I mean, you can just quote the literal IEEE-754 standard :p
07:56:59 <ysangkok> i guess it depends how you define NaN. if you don't have NaN as a value, you just have NaN as an exception...
07:57:00 <c_wraith> wow, that opens up entirely new avenues for acme-* packages. 
07:57:01 <comerijn> Ariakenom: It's not particularly ambiguous on this
07:57:25 <comerijn> ysangkok: Well, this is kinda important though, because some class/types are completely broken with value level NaN
07:57:27 <vancha112[m]> I'll just save that file kuribas, i realize i'm looking at it but i can't make out meaning. I'll try again later because it seems like it can explain a lot :)
07:57:50 <Ariakenom> comerijn: it was a while ago but I remember it being hard to point to a single place
07:57:56 <Ariakenom> in the standard
07:58:04 <comerijn> ysangkok: For example, NaN completely breaks the Ord and Eq instance for Double and thus anything with Double can't really sanely be put into a Set or used as key in a Map
07:58:35 <comerijn> Not like "a little bit" I mean "breaks to the point of complete uselessness with no reasonable workarounds"
07:58:54 <comerijn> ysangkok: If you have trapping NaN all that disappears, since NaN just becomes bottom which is fine
07:59:02 <comerijn> We already have bottom anyway
07:59:32 <Ariakenom> I did write a float newtype that errors on NaN in Eq and Ord, that works too
08:00:17 <ysangkok> well yeah, i am totally convinced regarding the extra ccall form. i was just saying that it is not really "doing away with NaN", it is moving it from value level
08:00:38 <Ariakenom> NaN reminds me a lot of bottom actually
08:00:42 <comerijn> ysangkok: Sure, but that is enough to make many things more pleasant :)
08:00:53 <Ariakenom> a lazy contaminating error
08:01:20 <boxscape> Using Eq on Double sounds pretty weird to me anyway, though
08:01:27 <ysangkok> i guess it is close enough that i can go around the world saying "Haskell has no NaN". by the time people find out that it has some exception they have to handle instead, they'll be knee-deep in haskell muahahah
08:01:33 <boxscape> I guess there might be some use cases where it makes sense
08:02:24 <comerijn> boxscape: Why? You've never wanted to, say, "sort a sequence by the value of a Double"?
08:02:27 <ysangkok> or i'll just say "why didn't you prove the absence of NaN with dependent type theory" :P
08:04:48 <dminuoso> 17:00:58        boxscape | Using Eq on Double sounds pretty weird to me anyway, though
08:04:51 <dminuoso> boxscape: why is it weird?
08:05:15 <dminuoso> There's nothing inherently wrong with testing IEEE754 for exact equality, assuming that thats what you really want
08:05:20 <boxscape> comerijn Okay you need Eq for that but you're mostly using the Ord instance
08:05:22 <vancha112[m]> cool, thanks for being helpful :) I have to go ^^ I'll be back once i understand more.
08:05:52 <boxscape> dminuoso just seems like in most applications where you need a double it's be hard to guarantee that you're getting the exact same number
08:06:01 <boxscape> s/it's/it'd
08:06:40 <sicklork1n> I need to bake some git-rev info into my binaries.. i was thinking about using TH but am concerned it's gonna trigger unwanted recompliations anytime there's a new commit.  Is there any nice solutions to this that don't involve CCP? 
08:07:21 <ysangkok> by CCP you mean CPP?
08:07:33 <infinisil> sicklork1n: Probably something with data-files
08:07:33 <sicklork1n> yes, i just made up CCP
08:07:52 <ysangkok> so that it looks more soviet? :P
08:07:59 <boxscape> don't let the chinese coomunist party know
08:08:04 <boxscape> communist*
08:08:50 <sicklork1n> infinisil: humm.. are there any tricks like assert uses with -fno-assert?
08:09:42 <sicklork1n> in dev i dont' want recompition in prod (test,stage,master) branches I only build these once..
08:12:26 <jgt> sicklork1n: my application has a type called UserSimpleSearchResult. My colleague wrote a function to convert from a User database row to this type. It's called userRowToUSSR.
08:13:12 * hackage servant-github-webhook 0.4.2.0 - Servant combinators to facilitate writing GitHub webhooks.  https://hackage.haskell.org/package/servant-github-webhook-0.4.2.0 (tsani)
08:15:13 <sicklork1n> jgt: ehehe.. `how come there's no corntab on this machine..`
08:15:33 <ysangkok> sicklork1n: according to this answer comment it is problematic to include files even now https://stackoverflow.com/a/8570772/309483 if files are hard, getting haskell to execute git-rev surely is even harder...
08:16:34 <sicklork1n> ysangkok: these binaries don't run in a repo dir.
08:17:48 <infandum> The majority of time spent in my program is in compareText called from fromList from Data.Set. Any recommendations to speed this up? Different data types for instance?
08:17:55 <infandum> Err, lower memory I mean
08:18:01 <infandum> and speed would be nic3e4
08:18:50 <infandum> I just want to nub the list, so Set.toList . Set.fromList was always my go to, but here it's taking up a lot of memory
08:19:08 <ysangkok> sicklork1n: what do you mean by "these binaries"?
08:20:53 <comerijn> infandum: What elements are you storing into said Set?
08:21:16 <ullbeking> do many people use haskell for signal processing?  my particular application is music and audio.  i would like to know if they are a natural fit or if i am trying to fit a square peg in a round hole.
08:21:31 <sicklork1n> ysangkok: binaries == my compile programs
08:21:40 <sicklork1n> *compiled
08:21:45 <Ariakenom> infandum: if you have a benchmark at hand you can try "map head . group . sort" instead
08:21:48 <comerijn> ullbeking: Depends, are you doing realtime or offline? :)
08:22:32 <ullbeking> comerijn: offline.  any "realtime" would simply be fast processing/soft realitime
08:22:33 <infandum> comerijn: Text
08:22:38 <ullbeking> no hard RT
08:22:50 <ullbeking> at least not yet
08:23:03 <comerijn> ullbeking: I'd sayin Haskell probably isn't great for realtime, although I do know some people use it for live coding (i.e. tidal)
08:23:18 <ullbeking> comerijn: yes, i've seen tidal.  not sure how i feel about it.
08:23:41 <ysangkok> sicklork1n: sorry i am being daft, but the code i linked is using TH, surely it is evaluated at compile time, how does it matter which directory the compiled binaries are running from?
08:23:48 <comerijn> ullbeking: Just this morning I saw a link on someone announcing a Haskell based thing for editing video streams
08:24:08 <ullbeking> whoa
08:24:12 <ullbeking> comerijn: link please?
08:24:21 <comerijn> ullbeking: I'm trying to find it, but reddit is down :p
08:24:30 <ysangkok> ullbeking: it is called Komposition
08:24:33 <comerijn> ullbeking: Anyway, I think for offline signal processing haskell should be fine
08:24:42 <ysangkok> by oscar wickstr√∂m IIRC
08:24:55 <comerijn> ullbeking: I assume if you have signal processing experience it was probably in something like C or something?
08:25:06 <ullbeking> fantastic, thank you comerijn and ysangkok 
08:25:14 <sicklork1n> ysangkok: that's what i'm doing now
08:25:20 <Ariakenom> yes, just listened to him talk about nix on a podcast yesterday actually
08:25:25 <ullbeking> comerijn: yes, i have used C, C++, Python, Matlab, and Octave
08:25:35 <ysangkok> Ariakenom: which podcast is that?
08:25:49 <Ariakenom> kodsnack, it's in swedish
08:26:20 <ullbeking> ah, here we go: https://haskellweekly.news/issues/127.html
08:26:27 <comerijn> ullbeking: Haskell's C FFI is amazingly simple and lightweight, so I would argue Haskell would be great even IF (unlikely) you had to write all the signal processing code in C, because using Haskell as high-level wrapper for C code is something it's honestly really great at
08:26:48 <ullbeking> comerijn: in that case i would assume that it already has bindings to BLAS, LAPACK, etc..?
08:27:24 <comerijn> ullbeking: Definitely for BLAS, and I would assume LAPACK too
08:27:45 <comerijn> ullbeking: THere's also #numerical-haskell where people should know all the details of that stuff :)
08:27:55 <ullbeking> oh wow
08:28:02 <ullbeking> yeah, that sounds like the ticket!
08:28:06 <ullbeking> thanks comerijn !
08:28:56 <comerijn> ullbeking: Basically, as long as your FFI stuff only needs to interact with pointers and primitive types (i.e. there's no struct passed by values) and you don't want to mutate structs from within Haskell, the FFI is super simple. If you want to mutate structs from within Haskell it's a bit more cumbersome, but still much less work than many other languages
08:29:30 <comerijn> ullbeking: GHC nowadays even has a foreign import that automatically generates wrappers so you can use CPP macros via foreign imports :)
08:30:08 <ullbeking> connrs_: "so you can use CPP macros via foreign imports" i have to ruminate on this for a little while...
08:31:11 <comerijn> ullbeking: i.e. if someone does "#define PI 3.14" most languages won't let you import PI as foreign symbol. With the CApiFFI in GHC you can simply foreign import it and the compiler will generate what you need :)
08:31:51 <ullbeking> comerijn: that's pretty cool, i think...?  is there a signifcan't advantage to this?
08:32:15 <ysangkok> " most languages won't let you import PI as foreign symbol"
08:32:25 <comerijn> ullbeking: Otherwise you have to manually lookup the value of the macro and write that value in your code instead
08:32:44 <comerijn> ullbeking: Anyway, here's a bunch of example imports I've been using with SQLite: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/src/SQLiteExts.hs#L41-L73
08:33:16 <comerijn> ullbeking: (And that's literally all the required Haskell code to call those SQLite functions)
08:34:22 <ysangkok> one thing i was impressed about with the haskell FFI is that if you have a 32-byte buffer, you can put that in the FFI signature, it doesn't need to be a primitive type, it just needs a Storable instance, if I understood it correctly
08:36:21 <ullbeking> ok, now this is sounding compelling and very nice
08:36:31 * ullbeking is looking at comerijn's code...
08:37:03 <ullbeking> wow, that IS indeed simple :-)
08:37:17 <adamCS> ullbeking: for LAPACk and BLAS, see https://github.com/haskell-numerics/hmatrix.   
08:37:51 <comerijn> ullbeking: The best starting point for the FFI (assuming your somewhat comfortable with the basics of Haskell) is chapter 8 of the Haskell2010 Report and the GHC user's guide on the FFI
08:37:56 <comerijn> @where report
08:37:56 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
08:37:59 <comerijn> @where userguide
08:37:59 <lambdabot> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/
08:38:57 <ullbeking> adamCS: there are some really lovely examples in https://github.com/haskell-numerics/hmatrix/tree/master/examples
08:39:17 <ullbeking> this is all looking very promising
08:39:45 <infandum> Anyone have any experience with Streaming.Prelude (http://hackage.haskell.org/package/streaming-0.2.2.0/docs/Streaming-Prelude.html)? Is there a S.toList which returns a lazy list such that  fmap (take 3) . S.toList_ $ S.each [1..] would work?
08:40:30 <adamCS> ullbeking: Also, check out  http://www.datahaskell.org/docs/, which might have some other useful things for what you want to do.
08:40:58 <comerijn> ullbeking: Despite Haskell's reputation for being all pure and abstract, there are a TON of tools for writing/interacting with low level code :) Hell, in recent GHC you can even write SIMD intrinsics if you *really* want to
08:41:01 <ullbeking> this is all amazing, so far advanced compared to my best expectations when i asked the question just before
08:41:08 <ski> comerijn : hm, i suppose GHC grovels, then (?)
08:41:40 <ullbeking> thank you adamCS , comerijn , and ysangkok 
08:41:46 <ullbeking> :D
08:42:17 <adamCS> ullbeking: np!  The more people use this stuff, the better it gets...
08:42:35 <comerijn> ullbeking: See for example GHC.Prim https://hackage.haskell.org/package/ghc-prim-0.5.3/docs/GHC-Prim.html#g:29 this stuff isn't really packaged/polished yet, but the nice thing is that if you only need small numeric kernels you can easily wrap this stuff up into a nice high-level API and then write all the surrounding code (stuff like input parsers, commandline parsers, etc.) in a nice high-level, 
08:42:41 <comerijn> garbage collected world :)
08:43:21 <ullbeking> adamCS: exactly!!  this is also why I use Btrfs, i want it to improve and get better and succeed.
08:44:15 <ullbeking> comerijn: primitive stuff like this is SUPER useful.  once you have all that stuff, and matrix algebra, who can build up your Fourier transforms, and once you have that everything else falls into place
08:44:22 <ullbeking> s/who/you/
08:44:44 <comerijn> Anyway, gym time
08:46:45 <adamCS> ullbeking: https://hackage.haskell.org/package/fft and https://hackage.haskell.org/package/fftwRaw might also be useful.
08:47:08 <adamCS> Also https://hackage.haskell.org/package/vector-fftw
08:47:32 <ullbeking> adamCS: you rock :D
08:48:03 <adamCS> ullbeking: :D
08:48:27 <ullbeking> thanks again to you all
08:48:39 <ullbeking> i have to go to an appointment now, will be back online in a couple of hours
08:50:42 * hackage futhark 0.12.1 - An optimising compiler for a functional, array-oriented language.  https://hackage.haskell.org/package/futhark-0.12.1 (TroelsHenriksen)
08:54:12 * hackage libmodbus 1.1.0 - Haskell bindings to the C modbus library  https://hackage.haskell.org/package/libmodbus-1.1.0 (JoeyHess)
09:26:13 * hackage git-lfs 1.0.0 - git-lfs protocol  https://hackage.haskell.org/package/git-lfs-1.0.0 (JoeyHess)
09:29:21 <boxscape> So, this is pretty interesting
09:29:25 <boxscape> I've been messing with type level computation
09:29:36 <boxscape> seeing if type synonyms or type classes are faster
09:29:48 <boxscape> and it looks like even with fairly similar use cases there can be drastic differences
09:29:49 <boxscape> https://gist.github.com/JakobBruenker/50c48c8bed2e151921a11f693686428a
09:29:54 <boxscape> in the first file, type is 10x faster
09:30:04 <boxscape> but in the second file, type is 4x slower
09:30:19 <boxscape> even though they're fairly similar in what they do, mostly just going through a list
09:30:48 <boxscape> (kind of unfortunate because I wanted to use a type synonym with Prime because it's more closed than the very open type class)
09:32:19 <boxscape> (and overall, wow, type level computation is pretty slow)
09:36:34 <boxscape> If anyone has any idea where there's such a huge difference between the cases (40x in total I guess), I'd love to hear it
09:36:39 <boxscape> s/where/why
10:23:49 <lyxia> that's so strange
10:24:22 <lyxia> I wouldn't have suspected there to be a measurable difference since both are essentially LastZero xs ~ True
10:25:38 <boxscape> I would have guessed that maybe in general classes could be a bit slower because they're more complex, but certainly not this extreme, and, well, I would have expected it to be consistent
10:34:08 <EvanR> clearly we need a compiler to compile the type level computation before it runs
10:34:23 <EvanR> and one for the kind level, and so on
10:34:28 <EvanR> compilers all the way down
10:35:05 <boxscape> yeah, run -O2 on the type level computations or something
10:36:21 <EvanR> i mean, that seems like an obvious source of slowness, the computation is running in an interpreter as part of the original compiler
10:37:08 <EvanR> even if it may involve HOAS or something 
10:38:35 <boxscape> Given the 18 (out of 20) second overhead it seems like the computation itself isn't really the slow part though
10:39:12 * hackage essence-of-live-coding 0.1.0.1 - General purpose live coding framework  https://hackage.haskell.org/package/essence-of-live-coding-0.1.0.1 (turion)
10:40:08 <boxscape> and ghci is also interpreted, right?
10:40:10 <boxscape> and it's much faster
10:40:13 * hackage essence-of-live-coding-pulse 0.1.0.1 - General purpose live coding framework - pulse backend  https://hackage.haskell.org/package/essence-of-live-coding-pulse-0.1.0.1 (turion)
10:40:20 <boxscape> on the value level
10:40:57 <boxscape> takes 0.02 seconds
10:41:12 * hackage essence-of-live-coding-gloss 0.1.0.1 - General purpose live coding framework - Gloss backend  https://hackage.haskell.org/package/essence-of-live-coding-gloss-0.1.0.1 (turion)
10:44:03 <boxscape> though for what it's worth, `Proxy :: Proxy (IsLastZero (FromNatDown 1000))` also takes two seconds, so the type synonym actually doesn't add much overhead in this case
10:46:38 <boxscape> somehow `Proxy :: Proxy (IsPrime 199)` takes 10 seconds, making it slower than the wrapping typeclass
10:46:50 <tsizz> Hello. I was wondering if anyone can help me with problem 3 here: https://www.seas.upenn.edu/~cis194/fall14/spring13/hw/03-rec-poly.pdf
10:47:06 <tsizz> I am almost done. Just not sure how to print the asteriks correctly
10:50:54 <boxscape> which part of printing them are you having trouble with?
10:51:49 <tsizz> boxscape so lets say for example i am trying to plot list [1,2,2,3,3,3]
10:52:19 <lavalike> dang you have haskell homework, that's cool
10:52:28 <tsizz> i already have a count function and i get [0,1,2,3,0,0,0,0,0,0]
10:52:43 <tsizz> list[1] = 1 bc there is one 1
10:52:50 <tsizz> list[2] = 2 bc there is two 2's etc.
10:52:57 <tsizz> im not sure if that is the correct way, but its what i have so far
10:53:04 <boxscape> that looks fine to me
10:53:21 <tsizz> but then idk how to print the asteriks accordingly 
10:54:02 <boxscape> what is the problem you encounter if you try to think about what you have to do to print them?
10:54:25 <tsizz> hm. how to print them vertically i guess
10:55:10 <tsizz> im thinking i can loop through the list of count and print asteriks the number of times at the index. so like list [2] would loop twice to print two.
10:55:25 <tsizz> something like that?
10:55:46 <boxscape> that sounds like what you would have to do to print them horizontally
10:56:18 <boxscape> well, maybe it's true more generally. It depends on what exactly you meant
10:57:08 <boxscape> in general I can see two approaches here:
10:57:44 <boxscape> 1. go through each line, and at each step, print an asterisk if the current index reaches up to that line, and a space if it doesn't 
10:58:04 <boxscape> 2. make a list of horizontal strings, and write a function that takes and makes it vertical
10:58:24 <turab> Hello! I think I managed to find a case where I could utilize TardisT but not sure how to use it properly. I want to allow top level mutually recursive functions in a simple interpreter and this is what I have: https://gist.github.com/trajafri/2aec2faa179da68bdc1e96c9cf01539f
10:59:35 <turab> From what I have understood, I think the problem is that the forward state is depending on the the backwards state, which causes evalList yield bottom
11:00:22 <turab> Perhaps there is some guide on how to use Tardis without running into issues like this? I haven't been able to find one myself
11:01:44 <tsizz> boxscape what do you mean in 1. go through each line? as in each horizontal line going down the y axis?
11:02:04 <boxscape> wouldn't horizontal lines go down the x axis?
11:02:10 <tsizz> like y = 10 horizontal line, y = 9 line
11:02:14 <boxscape> ah 
11:02:15 <boxscape> yes
11:02:35 <boxscape> it's kind of the imperative solution I suppose - outer loop going vertical, inner loop horizontal
11:02:57 <tsizz> hm so should i not go the imerpative route
11:03:03 <tsizz> 1. did sound more like what i was thinking
11:03:22 <boxscape> it's up to you I suppose. 2. works best I think if you make all your initial horizontal equally long, i.e. fill them up with spaces at the end
11:03:32 <boxscape> all your initial horizontal lines*
11:04:22 <boxscape> (and also there's also a library function that converts horizontal lines into vertical lines)
11:04:24 <boxscape> :t transpose
11:04:26 <lambdabot> [[a]] -> [[a]]
11:05:07 <boxscape> > transpose ["***", "*  ", "** "]
11:05:10 <lambdabot>  ["***","* *","*  "]
11:05:26 <boxscape> well, my initial list isn't quite right, but you get the idea, maybe
11:05:54 <boxscape> trying to implement transpose is a good exercise in and of itself
11:07:08 <MarcelineVQ> > transpose [[1,2,3],[4,5,6],[7,8,9]] -- easier to see what it's doing with numbers
11:07:13 <lambdabot>  [[1,4,7],[2,5,8],[3,6,9]]
11:07:15 <boxscape> fair point
11:09:12 <tsizz> boxscape so are you saying i should start off filling all lines with spaces. then filling it in with * accordingly?
11:10:01 <turab> Oh actually both future and past states are dependent on each other which makes it even worse
11:10:07 <boxscape> not quite, basically I'm saying make your lines the correct number of asterisks and then make sure all lines are equally long by appending or prepending spacess
11:14:56 <Ariakenom> tsizz: this is close to boxscape's 1 but it might be a useful perspective. 1: figure out a way to maybe print an asterisk at each possible location. 2: figure out the logic that decides yes or no for one location.
11:15:24 <Boarders> I have a bytestring and a vector of indices that I wish to perform a permutation of the bytestring with, what is the best way? I *think* I can do it by using a storable mutable vector of word8's and converting that to a bytestring but is there a better way?
11:22:08 <tsizz> Ariakenom ok i like that start. not sure how to start tho. like not sure how to get a y axis started
11:22:43 * hackage linnet 0.1.0.0 - Lightweight library for building HTTP API  https://hackage.haskell.org/package/linnet-0.1.0.0 (sergeykolbasov)
11:23:07 <Ariakenom> tsizz: what moves you in the y axis?
11:28:41 <tsizz> Ariakenom how do you mean
11:29:49 <Ariakenom> tsizz: I guess that wasn't very clear of me. Can you make a column 1 wide and 2 high?
11:31:26 <tsizz> Ariakenom yes, but not sure how to move to the next column
11:31:40 <tsizz> i did a recrusive function to print an asterick a number of times vertically using putStrLn
11:32:51 <Ariakenom> tsizz: ok so what did you use to move vertically as opposed to horizontally?
11:33:30 <boxscape> note that the exercise actually requires you to produce a String, rather than to print something
11:34:35 <tsizz> Ariakenom putStrLn? i think makes a new line after each print
11:34:42 <tsizz> boxscape oh 
11:40:02 <tsizz> i changed putStrLn "*" to print * and it doesn't work anymore o.O
11:40:07 <tsizz> but print "*" works
11:40:16 <tsizz> but prints the " " as well
11:40:35 <lavalike> what instance is picked in fold xs where xs :: [a->a] ?
11:40:49 <boxscape> > print * -- what would you expect this to do?
11:40:52 <lavalike> tsizz: print calls show on the argument
11:40:53 <lambdabot>  <hint>:1:45: error:
11:40:53 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
11:40:55 <lavalike> @src print
11:40:55 <lambdabot> print x = putStrLn (show x)
11:41:17 <tsizz> mhm so how comes print * doesnt work
11:41:25 <tsizz> it says my next line is indented wrong if i do that
11:41:31 <lavalike> > show "*"
11:41:33 <lambdabot>  "\"*\""
11:41:34 <boxscape> `print *` is the same as `putStrLn show *`
11:42:45 <Ariakenom> tsizz: * without quotes isn't a string it's the multiplication operator
11:42:56 <tdammers> because * on its own is a (binary) operator, and `print *` isn't valid Haskell
11:43:05 <tsizz> ah.
11:43:09 <lavalike> :t fold [id,id,id]
11:43:11 <lambdabot> Monoid a => a -> a
11:43:13 <lavalike> which instance is this?
11:43:23 <tdammers> print * 1 -- would be well-formed Haskell, but it would mean "the print function multiplied by 1", which doesn't typecheck
11:43:23 <tsizz> hm so how would i print * without " "
11:43:30 <tdammers> by using putStrLn
11:43:33 <boxscape> > putStrLn "*"
11:43:36 <lambdabot>  <IO ()>
11:43:44 <boxscape> well, lambdabot doesn't do IO actions
11:43:51 <tdammers> your mental model of "removing the quotes" is wrong
11:43:55 <tsizz> but i thought i had use print strings
11:44:16 <tdammers> you can use print on strings, but it will first call `show` on them
11:44:27 <tdammers> and `show` adds quotes and escapes existing quotes
11:44:27 <boxscape> "print" is typically used to print anything other than String - unless you explicitly want to print a String with quotes around it
11:44:32 <tdammers> @src print
11:44:32 <lambdabot> print x = putStrLn (show x)
11:44:34 <jle`> putStrLn is used to print strings
11:44:42 <jle`> print is used more for debugging than anyhting
11:44:45 <tdammers> ^ this is literally how print is defined
11:45:02 <jle`> print would print the string literal you would need to type to create that string
11:45:30 <jle`> or whatever literal you would need to type to create whatever thing you give to it
11:45:34 <lavalike> > read (show "*") :: String
11:45:38 <jle`> it's more of a debugging tool than an actual thing you want people to see
11:45:41 <lambdabot>  mueval-core: Time limit exceeded
11:45:53 <Ariakenom> tsizz: maybe you were looking for putStr instead of putStrLn?
11:46:02 <lavalike> Ariakenom: can't help but think that
11:46:04 <tsizz> Ariakenom that works for printing horizontally
11:46:27 <boxscape> > read (show "*") :: String
11:46:34 <lambdabot>  mueval-core: Time limit exceeded
11:46:39 <jle`> print "*" will literally print "*", since that's the string literal you would type to create the "*" string. putStrLn "*" would just print the contents of the string
11:47:13 <jle`> print doesn't print string representations, it displays what 'you would type' into a haskell source file to create that value. mostly useful for debugging purposes
11:47:48 <jle`> if you have a value and you want to debug/trace how you would recreate that value in a source file, for testing purposes
11:48:18 <Ariakenom> % putStr "1\n2\n3\n4\n"
11:48:18 <yahb> Ariakenom: 1; 2; 3; 4
11:48:50 <Ariakenom> well yeah ok I can see where I went wrong there yahb
11:49:12 <lavalike> :t fold [succ,pred,succ]
11:49:15 <lambdabot> (Monoid a, Enum a) => a -> a
11:49:30 <Ariakenom> tsizz: you can create a line in a string with \n: "line 1\nline 2\n"
11:49:31 <lavalike> oh maybe  Reader a  monoid?
11:49:41 <jle`> lavalike: yeah, that's what's happening
11:49:47 <jle`> > fold [take 3, reverse, drop 2] "hello"
11:49:50 <lambdabot>  "helollehllo"
11:49:54 <lavalike> and (<>) is *not* composition
11:50:14 <lavalike> but what else could it be
11:50:17 <jle`> yeah. that instance is defined for (a -> b) in "general", not necessarily endofunctions
11:50:24 <lavalike> I see
11:50:36 <jle`> it's point-wise combination; it's actually a generic Monoid instance you can write for all Applicative instances
11:50:45 <jle`> mempty = pure mempty; mappend = liftA2 mappend
11:50:47 <lavalike> so it's applying the same thing to each
11:50:51 <lavalike> and the concatenating
11:51:00 <jle`> for functions it becomes mempty _ = mempty; mappend f g x = f x <> g x
11:51:12 <lavalike> gotcha!
11:51:14 <jle`> yes
11:51:28 <lavalike> my golf has annoying appEndo Endo sprinkled in because of that instance >:)
11:51:29 <jle`> usually people say that it's useful for combining ordering functions
11:51:54 <lavalike> oooh I never thought of using list and fold, usually do the <> by hand on Ordering
11:51:55 <Ariakenom> jle`: 'Monoid b => (a -> b) in "general"'
11:52:05 <jle`> ^
11:52:18 <lavalike> makes sense, that b the Monoid a lambdabot showed
11:52:26 <lavalike> I the verb
11:52:51 <jle`> you really only ever need Endo/appEndo if you are using monoid-polymorphic functions though
11:52:55 <lavalike> > (\xs -> reverse . transpose . map (\(i,xs) -> show i ++ "=" ++ xs) . M.toAscList . (\m -> let n = maximum (M.elems m) in take n . (++ repeat ' ') . flip replicate '*' <$> m) . (\h -> let ((min,_),(max,_)) = (M.findMin h,M.findMax h) in appEndo (fold [Endo $ M.insertWith (flip const) x 0 | x <- [min..max]]) h) . appEndo (fold [ Endo $ M.insertWith (+) x 1 | x <- xs ]) $ M.empty) [0,3,4,7,1,4,5,7,1,4,8]
11:52:58 <jle`> it might be shorter to just use (.)/id instead
11:52:59 <lambdabot>  ["    *    "," *  *  * ","** *** **","=========","012345678"]
11:53:03 <jle`> :t foldr(.)id
11:53:05 <lambdabot> Foldable t => t (b -> b) -> b -> b
11:53:26 <lavalike> I was dead set on using fold, I get you
11:53:41 <jle`> you can use foldMap Endo instead of fold + map Endo
11:53:48 <lavalike> nice
11:53:51 <boxscape> apparently when I did that exercise a few months ago I decided that it would be a good idea to golf it and ended up with this
11:53:55 <boxscape> histogram=p.h where p l=unlines.reverse$"0123456789":r 10'=':transpose(map((\n->r n '*'++r (m l-n)' ').f)l);m l=f$ maximum l;f=fromEnum;r=replicate;h l=map(`c`l)[0..9];c d=genericLength.filter(== d)
11:54:14 <lavalike> heh
11:54:39 <lavalike> I even use multi-character variable names, much more readable >:)
11:54:45 <boxscape> true
11:56:47 <Ariakenom> % sortBy (comparing length <> comparing id) ["aa","b","c"]
11:56:47 <yahb> Ariakenom: ["b","c","aa"]
11:57:15 <Ariakenom> ^ the combining comparing functions jle` talked about
11:59:31 <lavalike> ah but you can't foldMap comparing [length, id]
12:11:55 <Ariakenom> tsizz: are you still working on it?
12:12:48 <tsizz> Ariakenom yup im eeating a little bit, but i thinking of loopping through my count array [0,1,2,3,0,0,0,0,0,0] where list[1] = 1 bc there is one 1. 
12:12:54 <tsizz> and printing vertically that number of times
12:13:36 <tsizz> hm but going to the next column. i might need to think about
12:15:02 <tsizz> hm how do i traverse a list returned by a function call o.O
12:16:58 <hyperisco_> tsizz, traverse (f xs) ?
12:17:24 <Ariakenom> yeah. funnily there's a function called traverse that is relevant :D. but you should do it pretty much like whatever you did before
12:17:28 <hyperisco_> I am thinking  for (f xs)
12:17:40 <lavalike> hyperisco_: that's probably the wrong argument tho (:
12:18:33 <hyperisco> Always annoyed me how HexChat cannot deal with disconnects
12:19:08 <lavalike> too young, gotta use a older more battle tested irc client for that
12:19:35 <hyperisco> there is a way to script the release commands but I forget how every time I set HexChat up again
12:31:43 <exarkun> I get errors trying to generate UTCTime w/ `(arbitrary :: UTCTime)`.  Is there really no Arbitrary instance for UTCTime or am I screwing something up?
12:31:52 <exarkun> ahem
12:31:57 <exarkun> (arbitrary :: Gen UTCTime)
12:32:13 <Lears> lavalike: Just btw, you can do something like `foldMap comparing [length, id]` with the right supporting machinery: https://gist.github.com/LSLeary/042c4bb97c3bcc5c07207e32935825eb
12:34:32 <lavalike> exarkun: maybe  instance Arbitrary UTCTime where arbitrary = UTCTime <$> arbitrary <*> arbitrary  but havn't thought this through, it's not provided
12:34:50 <lavalike> Lears: aah that machinery (:
12:35:46 <lavalike> Lears: I was mostly figuring out why I don't end up using fold(Map) but do the <> by hand, thanks for the example!
12:37:45 <lavalike> this is nice too https://github.com/mongodb-haskell/bson/blob/08113947af/tests/Data/Bson/Tests.hs#L38-L43
13:23:22 <z0> @pl \f g a b ->  f(g a b)
13:23:22 <lambdabot> (.) . (.)
13:23:32 <z0> nice
13:23:39 <lavalike> sometimes spelled (.:)
13:23:59 <z0> thanks lavalike
13:24:20 <z0> the Blackbird combinator
13:27:36 <haskellFinance> I haven't programed in a couple years and I'm looking for someone who can give me a refresher
13:27:45 <haskellFinance> but I have 8 years of exp.
13:28:17 <haskellFinance> I'm stuck trying IO in haskell
13:28:24 * hyperisco splashes cold water on haskellFinance
13:28:35 <haskellFinance> I'm getting a weird error and as far as I can tell I'm doing it right.
13:28:46 * haskellFinance gets a towel and dies off.
13:28:52 <threewood> rip
13:28:56 <hyperisco> oO
13:29:00 <haskellFinance> https://www.haskell.org/tutorial/io.html
13:29:38 <threewood> haskellFianance:  That all looks right
13:29:41 <haskellFinance> I copied and pasted some code and tried to run it but it won't work in my web compiler
13:29:56 <haskellFinance> https://paiza.io/projects/p19JB8vxVhV3rKZMU5MJJw?language=haskell
13:30:17 <haskellFinance> maybe it's a problem with my web compilers
13:30:20 <hyperisco> Your indentation is off
13:30:43 <hyperisco> Try that https://paiza.io/projects/0-b5K8jFR-DmPDrbr-T83g?language=haskell
13:30:47 <haskellFinance> oh thanks
13:31:46 <haskellFinance> hyperisco: I tried to run what you sent but I get this error message...
13:31:58 <boxscape> haskellFinance FWIW you can also start a new line immediately after the do, which might make indentation slightly less confusing
13:32:00 <haskellFinance> Runtime error(Exit status:1)
13:32:18 <hyperisco> You can't get a char if there are no chars
13:32:47 <haskellFinance> so I have to enter input but how do I do that\
13:32:50 <boxscape> you have to click on the input tab
13:32:55 <boxscape> in the bottom pane
13:32:56 <hyperisco> I don't know. I haven't used that tool.
13:33:00 <boxscape> and then type something
13:33:12 <boxscape> or just install ghc locally instead of using a website
13:34:02 <haskellFinance>  I'm at rehab so talk to me about on here #haskell-offtopic
13:34:20 <haskellFinance> So I don't have a laptop of my own
13:34:25 <boxscape> fair enough
13:35:14 <haskellFinance> I need help finding a web compiler that functions
13:36:26 <haskellFinance> Also I want to write a library for algorithimic trading in haskell
13:36:56 <haskellFinance> quantopian is a good algorithmic trading library but it's python and I prefer to program in haskell
13:40:18 <z0> haskellFinance: why  not just use ghci?
13:40:54 <boxscape> z0 they said they don't have a laptop to install it on
13:41:43 <haskellFinance> yep, I'm inbetween a rock and a hard place, I think I will just keep trying online compilers until I find one that will work
13:42:03 <haskellFinance> But another topic, who wants to make an algorithmic trading library for haskell?
13:42:37 <EvanR> is this a solicitation
13:43:19 <haskellFinance> What do you mean solicitation? I think it is a group project
13:44:47 <Boarders> it sounds like a group project that would make one party a lot of money
13:45:44 <haskellFinance> It would still be a fun project
13:46:32 <EvanR> my exploitation sense is tingling
13:47:09 <haskellFinance> How would it be exploited?
13:48:30 <Boarders> it is the kind of project which someone would usually be paid a lot of money to do and so I don't see many people who are capable of doing it wishing to do it for free
13:48:30 <z0> @src []
13:48:30 <lambdabot> data [] a = [] | a : [a]
13:49:07 <z0> this is kind of a lie, right?
13:49:17 <monochrom> Yes.
13:49:29 <z0> ok
13:50:08 <haskellFinance> Change of topic. Is there a computer vision library for haskell that works well?
13:51:47 <boxscape> :i []
13:51:52 <geekosaur> no :i
13:51:57 <boxscape> :(
13:52:04 <monochrom> lambdabot is not ghci
13:52:12 <boxscape> % :i []
13:52:13 <yahb> boxscape: data [] a = [] | a : [a] -- Defined in `GHC.Types'; instance Alternative [] -- Defined in `GHC.Base'; instance Applicative [] -- Defined in `GHC.Base'; instance Eq a => Eq [a] -- Defined in `GHC.Classes'; instance Functor [] -- Defined in `GHC.Base'; instance Monad [] -- Defined in `GHC.Base'; instance MonadPlus [] -- Defined in `GHC.Base'; instance Monoid [a] -- Defined in `GHC.Base'; instance Ord a => 
13:52:35 <geekosaur> you probbably wanted %%
13:52:55 <boxscape> hm, but this worked?
13:52:56 <geekosaur> (yahb sends long output to a pastebin with %%)
13:53:01 <boxscape> ah
13:53:29 <boxscape> I can't find [] in GHC.Types..
13:53:43 <boxscape> wait I can
13:53:45 <geekosaur> GHC.Types is a bit of a lie itself
13:53:47 <boxscape> it's just not in the API
13:53:49 <boxscape> okay
13:54:00 <haskellFinance> Goodbye and thanks to teaching me I will be back tomorrow.
13:54:05 <boxscape>  NB: lists are built-in syntax, and hence not explicitly exported
13:54:06 <boxscape> got it
13:54:18 <geekosaur> it's wired into the compiler; the definition exists (a) to give haddock a documentation hook (b) to create the info table entry used by everything else
13:54:19 <boxscape> bye haskellFinance
13:54:30 <boxscape> I see
13:54:57 <boxscape> so built in syntax is a bit of an understatement, then? It's actually a built-in type?
13:55:34 <geekosaur> that's a compiler internal thing, you'd have to study the compiler guts to see what it's about but it's e.g. used by the garbage collector to know what size things are and what within is a gc-able object pointer, etc.
13:56:03 <boxscape> ok
13:56:18 <monochrom> If the syntax is builtin then the type needs to be builtin too.
13:56:39 <geekosaur> at the moment it's a built-in type as well as wired-in syntax. there have been proposals to expand it so the syntax can be used directly instead of via an IsList typeclass with other types
13:56:41 <boxscape> well, not necessarily, it could just be syntax sugar redirecting to something like data List a = Cons a | Nil
13:57:04 <monochrom> OK
14:00:43 * hackage byteslice 0.1.2.0 - Slicing managed and unmanaged memory  https://hackage.haskell.org/package/byteslice-0.1.2.0 (andrewthad)
14:05:43 * hackage sequence-formats 1.3.1 - A package with basic parsing utilities for several Bioinformatic data formats.  https://hackage.haskell.org/package/sequence-formats-1.3.1 (stephan_schiffels)
14:06:42 * hackage pipes-ordered-zip 1.0.1 - merge two ordered Producers into a new Producer  https://hackage.haskell.org/package/pipes-ordered-zip-1.0.1 (stephan_schiffels)
14:10:31 <exarkun> struggling to understand how to combine hspec and wai and quickcheck
14:32:50 <shapr> exarkun: well that sounds cool
15:27:13 <NemesisD> is there a way to impose a constraint on a type parameter of an empty data declaration? something like `data Column (KnownSymbol name => name :: Symbol)`
15:29:39 <lyxia> I don't think so
16:00:27 <exarkun> shapr: does it?  cool
16:00:35 <exarkun> also putting kids to bed and doing dishes
16:00:44 <exarkun> also cool things, I insist
16:00:48 <shapr> exarkun: have you tried hedgehog?
16:01:04 <exarkun> shapr: practically speaking, no
16:01:16 <exarkun> shapr: is it easier than Hspec?
16:01:32 <shapr> er, I swapped it into the place of quickcheck for most things
16:01:35 <shapr> but you can use both together
16:01:45 <shapr> hold on, I think I have some code
16:01:52 <exarkun> oh huh, ok
16:02:05 <exarkun> for some reason I thought it was more like test suite framework than quickcheck replacement
16:02:36 <shapr> exarkun: https://github.com/shapr/httplogmonitor/blob/master/test/Test.hs#L64
16:02:55 <shapr> have you ever had to wrap a newtype around Int to get a different Arbitrary instance?
16:03:26 <shapr> hedgehog simplifies that by letting you specify explicit ranges
16:03:45 <exarkun> I feel like I should probably at least understand why my quickcheck code fails before switching to something else
16:03:57 <exarkun> now would be a good time to switch though, I only have about 100 lines of quickcheck in this project so far
16:04:04 <shapr> hedgehog also has round trip and other useful properties included
16:04:11 --- mode: shapr set -o shapr
16:04:47 <shapr> here's round trip code: https://github.com/shapr/httplogmonitor/blob/master/test/Test.hs#L33
16:04:48 <exarkun> https://gist.github.com/exarkun/6e1a9e2d5c51d4704ecfcb5cfb290898 is the specific form that my difficulties take today
16:05:13 <exarkun> shapr: are any of these examples testing monadic properties?
16:05:28 <exarkun> checkAlert looks like it might be but it's commented out
16:05:38 <shapr> I don't think so, but I remember hedgehog was *much* easier than QuickCheckM
16:05:46 <shapr> nah, checkAlert was also pure
16:05:57 <shapr> but I did try a bunch of monadic stuff when I was figuring out hedgehog
16:06:10 <shapr> don't think I save any of the code, but iirc it was almost as easy as the pure code
16:06:45 <exarkun> won't using an easy-to-use library stunt my haskell growth
16:07:18 <shapr> oh I forgot, we need to be able to tell the new people we walked uphill both ways in the snow
16:07:50 <EvanR> i program with 100 lb weights on both my hands
16:07:57 <EvanR> just so i dont get soft
16:08:13 <shapr> EvanR: wow!
16:08:18 <exarkun> Okay I'll try rewriting this test suite with hedgehog and see what happens
16:08:36 <exarkun> wonder if I can do it in 12 minutes
16:08:39 <EvanR> its basically DBZ of code
16:09:27 <exarkun> EvanR: is your haskell over 9000
16:10:50 <shapr> exarkun: I look forward to hearing what you think of qc vs hedgehog
16:11:15 <exarkun> It'll be a novice's opinion
16:11:32 <shapr> that's often the best opinion
16:11:40 <shapr> thus my interest!
16:11:46 <exarkun> okay then, with that endorsement
16:11:55 <exarkun> I wish haskell didn't have "import Foo"
16:12:02 <shapr> what would be better?
16:12:14 <exarkun> only having "import qualified Foo" and "import Foo (bar)"
16:12:25 <shapr> hm, good point
16:12:26 <exarkun> (as forms can stay too)
16:12:31 <exarkun> "as" forms
16:12:38 <shapr> perhaps ghc could add a qualified only warning?
16:12:41 <c_wraith> that would make me miserable
16:12:52 <shapr> now that you mention it, import Foo is much like python's "import * from module"
16:12:54 <EvanR> i wish it did have imports and pretty much knew what i was talking about, perhaps making me spell it out in detail only near the end of development
16:12:57 <EvanR> didnt*
16:13:05 <shapr> oh wait, didn't mankyKitty write some code to do this?
16:13:11 <exarkun> EvanR: Maybe the compiler is smart enough to deal with that
16:13:13 <EvanR> probably
16:13:16 <exarkun> EvanR: _I'm_ not
16:13:25 <shapr> mankyKitty: didn't you have a blog post to convert a module to explicit imports?
16:14:00 <exarkun> And there goes 5 of my minutes on complaining
16:14:01 <c_wraith> I don't like namespace noise on identifier use, and I don't like import churn when I edit code. 
16:14:33 <exarkun> I don't like needing to spend 10 minutes tracking down where an identifier in someone else's code comes from
16:14:39 <shapr> c_wraith: perhaps the editor should handle it on a save hook?
16:14:40 <exarkun> x20
16:14:42 <c_wraith> iirc, ghc stopped doing explicit imports when they discovered that a high percentage of every diff they git was import chur. 
16:14:45 <c_wraith> *churn
16:14:47 <shapr> hm
16:14:56 <c_wraith> *got
16:15:08 <exarkun> were they running out of space for their git repo or something?
16:15:18 <c_wraith> they were trying to read diffs. 
16:15:23 <Boarders> I wish haskell could do type directed namespace disambiguation like agda
16:15:30 <exarkun> it's pretty easy to not read the import parts of a diff
16:16:15 * exarkun shrugs
16:17:45 <exarkun> I'll do this tomorrow I guess, I don't have the energy to hunt down dozens of unqualified identifies atm
16:18:02 <shapr> aw
16:18:07 * shapr hugs exarkun
16:18:10 <c_wraith> how does that take effort? you just ask ghc where they came from. 
16:18:18 <exarkun> c_wraith: I don't know how to do that
16:18:21 <shapr> exarkun: you still in bean town?
16:18:29 <exarkun> shapr: nope, not for a long time
16:18:36 <exarkun> shapr: about 4h north
16:18:45 <c_wraith> use :i in ghc
16:18:53 <c_wraith> err, ghci
16:18:56 <shapr> oh, I'm in Brooklyn, means you're probably not anywhere close
16:19:27 <exarkun> depends, did someone deploy retail-grade suborbital ballistic transit yet
16:19:42 <mankyKitty> shapr: I'm not sure.. Do you just mean qualified imports? 
16:19:43 <shapr> I think we would have heard about it... via sonic boom if nothing else
16:20:06 <exarkun> c_wraith: so clone the git repo and then `stack repl` and :i each identifier I'm curious about?
16:20:11 <shapr> mankyKitty: yeah, I thought you wrote some code to convert code between all qualified imports and all unqualified imports?
16:20:31 <exarkun> not as inconvenient as loading 30 pages on hackage, not as convenient as just having qualified identifiers
16:20:32 <shapr> I kinda want that code in emacs for a save hook now
16:20:37 <mankyKitty> Ohh that wasn't me, that was DigitalKiwi I think
16:20:41 <shapr> ohh
16:20:47 <shapr> sorry for the confusion
16:21:02 <mankyKitty> On their github iirc, no wukkas. :) 
16:21:47 <DigitalKiwi> yeah that was me
16:21:48 <c_wraith> exarkun are you using the index pages on hackage? I do that if I don't have the thing installed. (why does no one seem to know about the index-all page?) 
16:22:25 <shapr> the what?
16:22:31 <exarkun> c_wraith: I couldn't be said to have a concrete methodology yet.  It's a liberal mix of google, hoogle, clicking links, and url editing.
16:23:04 <shapr> one trick I learned from twitter is to use "hackage cabbagename" in google, that takes you straight to hackage pages
16:23:19 <c_wraith> for instance, https://hackage.haskell.org/package/lens-4.17.1/docs/doc-index-All.html
16:23:42 <c_wraith> just quick links to every identifier in a package. 
16:23:46 <exarkun>   Ah, no, I don't think I've seen that kind of page before
16:24:12 <DigitalKiwi> shapr: https://mostlyabsurd.github.io/posts/2019/06/09/minimal-imports-maximal-imports-examples/ it's somewhere in a gist here or the other. i have a slightly better version too if you want it. i need to put it in a real repo but i've been mostly painting
16:24:13 <c_wraith> they're helpful! :) 
16:24:32 <dyl> Interestingly enough, !h takes you to Hoogle with DDG.
16:24:42 <shapr> DigitalKiwi: thanks for the link!
16:24:43 <dyl> I know this because many of my Google searches have been accidentally routed to Hoogle.
16:25:38 <shapr> DigitalKiwi: yeah, I'd love to see your improved version!
16:26:38 <aearnus[m]> I set up a firefox keyword to search hoogle with `!h <term>`. so my workflow is usually just m-<tab> c-t !h ...
16:32:13 <DigitalKiwi> shapr: https://gist.github.com/Kiwi/4e970f6b937ef4fcaa14e3038b57dbc2 https://gist.github.com/Kiwi/cc35dbfc1b50e8995a709d1402ee5804
16:32:31 <shapr> thanks!
16:32:34 <DigitalKiwi> mostly it got rid of dependency on Safe
16:32:44 <DigitalKiwi> i don't remember what else
16:33:20 <DigitalKiwi> also it's probably kind of hacky so if you see improvements let me know
16:37:43 * hackage Map 0.0.2.0 - Class of key-value maps  https://hackage.haskell.org/package/Map-0.0.2.0 (MatthewFarkasDyck)
16:52:43 * hackage unipatterns 0.0.0.0 - Helpers which allow safe partial pattern matching in lambdas  https://hackage.haskell.org/package/unipatterns-0.0.0.0 (ChrisPenner)
16:57:22 <NemesisD> is anyone aware of a type-level list subset constraint that exists?
16:57:48 <jle`> NemesisD: the vinyl library has something along those lines, using typeclasses
16:58:46 <NemesisD> jle`: i'm depending on vinyl but i'm not seeing a version of that that isn't tied to records. it looks like it used to have a `Witnesses` module but that's gone now. i've also stumbled across your library decidable but i think it might not apply here
17:03:23 <jle`> yeah decidable is more for value-level stuff
17:04:43 * hackage RabbitMQ 0.1.0.0 - AMQP 0-9-1 client library for RabbitMQ servers  https://hackage.haskell.org/package/RabbitMQ-0.1.0.0 (HerbertValerioRiedel)
17:04:44 <jle`> NemesisD: in vinyl i see the RecSubset class
17:05:11 <jle`> alternatively you can manage subsets using data types and GADTs instead of constraints
17:05:13 <NemesisD> jle`: that seems to take a record type parameter though
17:05:45 <jle`> it might be a dummy parameter i think, i wonder if it would work if you just use Rec? it depends on what you want to use the constraint for
17:06:15 <jle`> `Rec (Index as) bs` is essentially a witness that bs is a subset of as, except it might include items in as more than once
17:06:28 <NemesisD> woah yeah it "just worked"
17:06:53 <jle`> Rec is really just a generic sort of recursive structural combinator
17:07:03 <jle`> it's more generic than the library seems to use it for
17:07:29 <jle`> so using Rec as your record basically forces the typeclass to use the inductive list structure
17:07:35 <NemesisD> i did `data DataSource keyColumns columns = DataSource (keyColumns <: columns) => ....`
17:09:42 * hackage rib 0.3.0.0 - Static site generator using Shake  https://hackage.haskell.org/package/rib-0.3.0.0 (sridca)
17:11:48 <srid> \o/
17:20:05 <jle`> srid: congrats :D
17:26:20 <DrDuck> Anyone happen to know how I can install the latest Haskell on CentOS, without compiling from sources? :P
17:26:32 <ysangkok> DrDuck: stack
17:31:45 <jackdk> isn't that the problem ghcup solves?
17:33:51 <hpc> you probably want ghcup over stack
17:34:05 <hpc> stack doesn't really give you access to the language tools directly, it wraps them
17:34:28 <hpc> so you'll forever be creating new projects and running "stack ghci"
17:34:56 <hpc> and using their package set instead of hackage proper
17:36:16 <tdammers> or, put differently, using stack just to install GHC is overkill, and not even a very good way of doing it
17:36:49 <tdammers> I wonder, though, whether the "generic Linux" tarball would work, and if not, why
17:41:18 <DrDuck> "Don't forget to source /home/lovesock/.ghcup/env in your ~/.bashrc or similar."
17:41:37 <DrDuck> What is meant by this? Just copy the contents of the env file to my .bashrc?
17:43:28 <DrDuck> This was after successfully installing ghcup. :)
18:13:32 --- mode: tolkien.freenode.net set +oo Sigyn ChanServ
18:42:49 <dmwit> DrDuck: Copying would work, but there is also a source builtin in bash, so adding a line like `source ~/.ghcup/env` somewhere in your .bashrc would also do the trick.
19:16:47 <sobhan> Hi
19:21:39 <NemesisD> hi all, i'm struggling with vinyl. it seems like vinyl records maintain some sort of association between some sort of field type and the value within. i've got a type `data ColumnType name ty` and a `data ColumnValue name ty` and I'm trying to write `singletonRec :: proxy (ColumnType name ty) -> ColumnValue name ty -> Rec f '[ColumnType name ty]`
19:22:05 <orzo> What does "subdirs:" mean exactly in a stack.yaml?  I have a fuzzy idea but the docs at https://docs.haskellstack.org/en/latest/yaml_configuration/ show many examples of subdirs without ever any formal description
19:22:32 <NemesisD> i'd like to be able to take that record, merge it with others and be able to write a getter or lens that when given a `ColumnType name ty` gives me back that `ColumnValue name ty`, but i'm failing to see where it would get that mapping
19:23:35 <orzo> one of my dependencies is a little odd and has a git repo with symlinks (possibly generated) in it and stack cannot seem to handle it
19:28:48 <lyxia> orzo: one repo can contain multiple package, each with a subdir
19:32:03 <orzo> i have a repo that contains a subdir with the package i want, but all the source files there are symlinks to files using ../ paths that are generated by project in another sub directory
19:32:44 <orzo> so it looks like that even though those files are generated, they are checked in to git also
19:34:08 <orzo> so i think i can ignore the generating project and do things normally, but stack fails.  It gives me an error message saying it may be a git-anex repository, which is not the case.
19:34:39 <orzo> "foo.tar: Symbolic link dest not found"
19:34:49 <orzo> "This may indicate that the source is a git archive which uses git-annex."
19:35:12 <orzo> but foo.tar is some kind of stack thing and nothing to do with the upstream repository
19:35:52 <lyxia> Do these links point to existing files? 
19:36:33 <orzo> the symlinks are linking files that exist in the same git repository
19:37:02 <orzo> the files dont actually exist until i clone a working tree
19:37:37 <orzo> but i'm trying to specify the dependency using - git: under the extra-deps: section for my project
19:37:58 <dima__> Hi folks, can anyone help with stack picking the right ghc version globally (without any local settings)? For some unclear reason, `stack` is referring to `lts-11.9`. But where is it defined? 
19:38:06 <dima__> https://gist.github.com/dmitriz/2b63319b52b2347d36bde6524bdf896b#file-stack-struggles
19:38:22 <lyxia> I see. I have no idea how stack interacts with symbolic links in git repositories.
19:41:05 <lyxia> dima__: have you looked in .stack/global-project/stack.yaml
19:42:16 <dima__> lyxia: ah yes, it is there, thanks!
19:48:00 <dima__> lyxia: so all I needed was to remove that pesky file, who could have thought, thanks again!
20:22:35 <maerwald> anyone good with collections who can explain how exactly vectors are more space efficient than lists?
20:31:11 <nisstyre> maerwald: I assume vectors are more tightly packed in memory (maybe unboxed? not sure)
20:32:02 <nisstyre> linked lists would need a pointer to each element
20:32:22 <nisstyre> unless the compiler can somehow optimize things
20:32:53 <nisstyre> if you're referring to https://hackage.haskell.org/package/vector then it does look like it allows for unboxed types
20:32:57 <nisstyre> so that would explain the space efficiency
20:37:13 * hackage sexpr-parser 0.2.0.0 - Simple s-expression parser  https://hackage.haskell.org/package/sexpr-parser-0.2.0.0 (rcook)
20:50:34 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org'
20:50:34 --- topic: set by glguy on [Sat Jan 05 07:21:52 2019]
20:50:34 --- names: list (clog freeman[w]_ kaimi1 merijn texasmynsted freeman[w] nesqi neightchan heatsink toblorone GoldRin Sheilong otto_s_ emptyflask laem zacts dfeuer_ wroathe xff0x theDon xcmw Guest56492 Stanley00 lagothrix tomboy64_ MarcelineVQ Saukk freeman42y felixfoertsch jokester ndesai arpl1 rann thunderrd wildlander stux|RC nyuszika7h_ pothyurf[m] yur3shmukcik[m] betz[m] ist5shreawf[m] cawal[m] jeeg[m] etjet[m] cesar[m] EuAndreh[m] contrun[m] mat8913[m] e godva[m])
20:50:34 --- names: list (mostendocrine jak[m] josef[m] somni[m] wuxianhuiyi[m] wrunt[m] boistordu pineapple[m] M0ddba11[m] thekyriarchy jonreeve[m] fiddeldibu[m] GNULizard[m]1 Hanma[m] Artifth[m] fulgjon atopuzov[m] kaychaks[m] ghastfilms[m] eyenx[m] simbergm vikraman NickHu1 cbg[m] yoltid[m] ad5twoknebor[m] ookfof[m] avocado derberg[m]1 runningriot9[m] hans[m]5 ppseafield[m] whoops periapseez[m] Brio[m] iarp[m] wobbol[m] peter-js[m] papazeus[m] Chromad[m] pong vigilian[m])
20:50:34 --- names: list (ilmu[m] steshaw[m] arturo[m] MonsieurArcher[m reedhhw[m] ovigren[m] hjoest[m] Jonathan[m]2 zopsi[m] Guest63612 vpei[m] grag[m] EmilKarlson alxev[m] zmlww[m] Ekho keepLearning512 natmac[m] gandi[m] gspia[m] ajirx[m] bee[m]1 lukasubo[m]1 yi[m] Axman6 lmolr[m] miseenplace[m] likliklik Grgoire[m] cosson[m] joe[m]31 sayukimans[m] tops[m] aloiscochard[m] charliebucket[m] midi[m] Ekho[m] krhubert[m] aearnus[m] unclechu cepxuo jrozanski rowan[m] potato44[m])
20:50:34 --- names: list (roberth aqtusia[m] lapav[m] mobile_x[m] reconmaster[m] bkl[m] nolep[m] oniani[m] xlogan[m] GreenKarm[m] roninkaizen[m] tomtau[m] macerbi[m] iceychris[m] d1mur4tdj[m] torkel[m]1 nartir[m] veeee[m] nonlinear[m] freu[m] coil[m] iantownsend abbe[m] suppenkasper[m] hifutakiko[m] benzoid[m] undu[m] steamedbun[m] dag[m] fgaz siraben fiberpunk[m] humanwire[m] DenisLehmann[m]1 ClownMaster[m] lierdakil[m] Godel[m] atpotts danielemarsella[ beaky nullheroes[m])
20:50:34 --- names: list (dustyp[m] souldev[m] tmallard[m] laniu[m]1 JulesRen-George4 Mesa[m]11 markus[m]21 kitsune[m]1 josiah_sama rihardsk[m] Richy[m]1 MerlinGttlinger[ Guy[m]1 mattia[m] sriehl[m] buggeas40d[m] PotatoRick[m] dumuzid[m] Fns[m] sm[m] blakec[m] labs[m] davex32[m] stan[m] vaibhavsagar javjarfer[m] spacekitteh[m] sergiotarxz[m] sylvie[m] ninjatrappeur[m] mithrandi[m] friedm[m] domenkozar[m] hdurer[m] jonge[m] tswett[m] mujx[m4 infinisil masaeedu[m] ircer[m] dude[m]1)
20:50:34 --- names: list (corin[m] aquarial[m] ShujaRafi[m] themsay[m] JoGoSi[m] thekyriarchy[m]1 gkobeaga[m] gentlehelm[m] jak[m]1 uelen[m] maigel[m] LasEspuelas nh2[m] matrixyz[m] WeiTang[m] krowlan3[m] sudorebootsudor4 shiroeni[m]1 Syllo[m] jhgarner[m] neat72[m] mrtnmrtn[m] Vincent[m]2 jesusvega[m] gswuichet[m]1 dlilja[m]1 jumzi[m] edwel[m] corin[m]1 aitzol[m]1 buster528[m]1 wildtrees[m] patonw[m] kumarbis[m] deikatsuo[m] jwerner[m] unitymember[m]1 vespuccy[m] peel Pete[m])
20:50:34 --- names: list (dxml[m] Surgeon[m] luisjira[m] intellection3to3 vancha112[m] themadman[m]1 PoopSick[m] lihram hogarth[m] Orbstheorem[m] Kenneth[m] asonixDogHeThey[ sielicki luftmensch[m] tempaccount1[m] Lears adaizen[m] ciet[m] brandon123[m] jochens[m] glothit7ok[m] giuseppe[m] schum mssx89m[m]1 inflationova[m] eckt[m] dice[m]1 imp0s5ible tuxsoy bt[m]1 georgescratcherd null14[m] zorkedon[m] rainbyte[m] gmips[m] Noughtmare[m] Tom[m]7 lambda-11235 hsw[m] andreas303)
20:50:34 --- names: list (amerocu[m] alko[m]1 pietromrtn[m] tarigo[m]1 laniusfnv[m] Alec[m]2 GhostofaConsole[ Mougan[m]1 vkleen tejok[m] foxadee[m] brevalda[m]1 adziahel[m] kerru[m] excel_gate[m] kylos[m] alibabzo abdolence[m]1 asayers[m]1 Godslatestgift[4 MartinKlimi[m] GNULambda[m] Cenion[m] yrid[m] PrimeSeeker[m] M31violet13[m] justanotheruser rahduro[m] beatricejensen[m aquarial triskeon[m] sphalerit anton-latukha[m] JoelMcCracken[m] texpat[m] mmynsted[m] imposs[m])
20:50:34 --- names: list (pschooom[m] sepp2k phanimahesh[m] pebeto[m] apurvapavaskar bobach[m] weebull[m] m00n[m] sghir_med[m] odd13[m]1 abc123zzz[m] M|GNUisnotLinux[ joenase[m] alexfmpe[m] ChristopherBurg[ unrooted[m]1 Lite[m] vorbex[m] ldesgoui[m] M2en[m] biox[m] jibby[m]1 supersweetsweet4 xethrog42[m] nybble41[m] soaoaig[m] afontain[m] AMlivinfree[m] PonyLoop1000[m] olmvnec[m] twom[m] n3t_ jwaksbaum[m] tindvik[m] apx[m] talvdav[m] pqwy[m] thosgood[m] ineff testacc3[m])
20:50:34 --- names: list (n0ma_d[m] NickHu gmind[m] qasim[m] triste[m] cjwelborn PhilipWhite[m] SFL[m] vsts[m] teaknow[m] link2xt[m] jibby kaiyou[m] Marceline[m] pagoda_5b[m] jg[m] jdks[m] kai10[m] heyakyra[m] dopplergange MichalLaskus[m] imdoor[m] korlaplankton[m] gd2398[m] aruncom2006[m] JakeO[m] deklund[m] nalix[m] ludovicdanjoumad johanejg[m] admdch[m] mouse008[m] cale[m] cjskaggs[m] Paavo[m] beaverfever[m] Cloud[m] danielbmarkham[m maxmaguire[m] kicker22004[m] grorg[m])
20:50:34 --- names: list (Kimani[m] k4l1gr4[m] AkikoHimenokoji[ Kit[m] actartis[m] limabeans[m] AaronWeiss[m] keith[m] illandan[m] supersven[m] max3raza[m] chris[m]15 jennie[m] godzilla[m] hkimhvyh[m] alana[m]1 cyclops19[m] tinwood bydo miklcct S007 rgh[m]2 Bimmie[m] Hakan[m] cybai Majiir ManiacTwister teardown paulus[m] devalot btbuddha pdgwien pierrot kini is_null averell jammar typedrat Ericson2314 kubrat nckx Bigcheese hexagoxel Cale nurupo noteventime sputny[m] xalek[m])
20:50:34 --- names: list (haskelllisp[m] luminousnine[m] alex[m]14 MarquisKurt[m]1 akt[m] GregKNicholson[m kahuna[m] arianvp[m] hackeryarn[m] Wizek[m] polman chalkmonster shanesveller[m] vk3wtf[m] javbit[m]1 tkots[m] mujx[m]1 vars[m] popo[m] shachiku[m] SmiVan[m] petrolifero[m] rinor[m] kapilp_ cemerick jorj ktonga luminar nopf Fischmiep __4matter_ teej Rudd0 ephemera_ ski Jonno_FTW Nik05 furnost Eliel flogfr ecx86 runawayfive RoguePointer suzu rootmos zv stvc pacak stefan-__)
20:50:34 --- names: list (Flonk gargawel_ shapr digia srk CindyLinz SlashLife qz swater rotaerk sbrg catern Ulrar arianvp Drezil charukiewicz dilinger wtw Tene ByronJohnson alp gspia [exa] arw scinawa jrslepak Someguy123 daissgr Ornedan hiptobecubic cheater uberj dustinm- glamas haasn opqdonut Taneb delYsid Bergle_1 raatiniemi treehaqr kjak dTal Tesseraction thjread oleks kark marek blankhart dolio MindlessDrone Putonlalla mimi_vx tabaqui cchalmers Foritus mkoenig aarvar verement)
20:50:34 --- names: list (dmiles aoeu256 ilikeheaps hexfive hpc revprez_anzio subttle z0 pipqw jb55 cantstanya xelxebar_ tombusby klntsky phreedom gxt CurryWurst davean rodgzilla deni locallycompact connrs_ freusque Batholith sigmundv- travv0 ynyounuo Squarism jtcs Dykam kqr lpsmith qzo srhb tstat mupf nivpgir_ vzdraz jdevlieghere beka dyl_ reyu fliife bollu noko_ DDR Folkol shadowdaemon SquidDev clynamen_ amx maerwald ftop divVerent Profpatsch sarahzrf gluegadget theNeuron)
20:50:34 --- names: list (cheshircat vimto lassulus tv PtxDK erikd sw1nn kuttifunk atk gabiruh sukbeom nshepperd m0rphism runde benwr_ jackdk terrorjack__ RecursiveG noCheese graingert_ koankeeper kraem ZoFLo luckin cocreature hegge megaTherion APic ammar2 PHO c-rog dredozubov noctux AJTJ apeyeoux orzo _guios energizer_ Sparadox nonzen adamse ocharles lstdgtfp jbetz nemesit|znc johnstein wayne deu evilmonads restrictedchoice bcmiller fr33domlover tristanC bdw sm asm89 tsani)
20:50:34 --- names: list (Intensity Athas DigitalKiwi lugh heath zerokarmaleft jol madnight chindy a3Dman mxf thebnq implementation Jello_Raptor xante statusbot bsima xtsee flebron dan64 sea-gull Jacoby6000 michalisko jonge Remavas tsahyt_ jzl niklasb_ UserOO7 betawaffle theorbtwo devopsdeluxe sqrt2 dxtr mccoyc Natch cp dave_uy monochrom mountaingoat hive-mind DwarfMaster cyberlard sudden slomo inkbottle s00pcan spion notzmv piyush-kurur darjeeli1 acro petersen fphilipe_)
20:50:34 --- names: list (nullifidian__ @ChanServ grumble @Sigyn pie_ nikivi mjuad bitonic alunduil iravid carter Lermex tehidiot no-n epicallan Kamuela monad_cat alexelcu bradparker winny linoge nkaretnikov Nascha entel dpn` jsatk fredcy- hodlwave_ p0lyph3m glowpelt trucy pyan natim87 kori rubik sphalerite Remy^ yushyin obfusk__ Jaxan Blkt amosbird shutdown_-h_now m4lvin bgamari feuerbach_ glowcoil banjiewen mpickering rajivr___ quarters alanz seventh__ michaelpj interruptinuse)
20:50:34 --- names: list (TimWolla PyroLagus Adluc zabracks nuxdie a3f Randy ryzokuken feepo unsymbol morgib dukedave nbouscal duncan Jabbslad joel135 elvishjerricco sebhoss sgraf simony AfC billstclair DrDuck ephemeron fingerzam rslima___ xnyhps heyj datapup_ sis7 ruffy_ jlpeters Firedancer raoulb devurandom rom1504 andreabedini srid Konehaltia jonrh scav Shun131 coot alexknvl NemesisD casdr_ ixian Ferdirand milessabin liquorice paf31_ edmundnoble christopher jesyspa aib bjobjo)
20:50:34 --- names: list (stylewarning bananagram `slikts mstruebing dolanbatar dxld griddle noan dgpratt bs zxrf m-renaud sclv kyagrd__ jetpack_joe Peter_Storm abbe Reisen lieven _6a68 jchia xyggos afk tomjaguarpaw scivola eiGHttt dongcarl_ poljar1 plutoniix alx741 Netwolf Sgeo_ zfnmxt tromp_ threewood dale ravenousmoose cynick andyo nyaomi mceier hc petercommand Chobbes jstolarek sicklork1n hackage drbean amiri acarrico jle` jrm Digit recj _ashbreeze_ boj ysangkok dmwit)
20:50:34 --- names: list (thaumavorio bvad c_wraith dibblego tnks angerman vk3wtf tdammers xstill dixie_ Clint tomku obiwahn strangeglyph Paks bandali pingu_ urdh dcoutts earthy kaol hiredman hongminhee DustyDingo lispy sud0 nshepperd2 Ankhers dstolfa comboy oats h30 Meanirelli ent tA- hsyl20 klugez aidecoe mrsbear lavalike andjjj23 joeyh Nevoic pent Guest19885 robogoat atomi bitemyapp koala_man Fubar^ Annihitek Guest6007 jdt monokrome nahra Guest41444 tumdedum noexcept_)
20:50:34 --- names: list (crtschin_ methos1 arkeet` dansho_ cpup sshaaf lastmanstanding Kaivo YongJoon Tops21 khisanth_ chirpsalot meck gienah_ aldum mikolaj keep_learning DTZUZU sektor Lowl3v3l ahri xplat dennisb jlamothe s4msung SCHAPiE ClaudiusMaximus leothrix rembo10 yitz Tuplanolla Ckat cgfbee tessier PragCypher valdyn ozychhi sellout- net4all cods gilbertw1 glguy aesi irclogger_com dminuoso Twey avn enragedjam vin-ivar sms Ranhir aplainzetakind jfredett joehillen Ring0`)
20:50:34 --- names: list (Mon_Ouie violeta infinity0 Deadhand lachenmayer nibbling_ mtjmullen brisbin umachan Hijiri pdxleif dashkal habbah Ke Philonous thallada stiell cpape lemald __name__ loc rkrishnan vodkaInferno chivay MasseR raid trebuh mankyKitty kip systemfault spinda lightandlight higherorder ibloom tolt AndreasK cyjiao__ dmj` rizary_ ProofTechnique Guest81022 spamlessj Guest88641 Jon bjs_ sethetter rootnode_ verlet64 newhoggy_ sebastianrkg SrPx_ edwardk_ and_pete)
20:50:34 --- names: list (integral mjlee_ riasue_ mudri_ nh2_ dexter newhoggy liif nshepperd_ TallerGhostWalt_ ryjm lsix mingc unlink2 uwap maralorn copypasteque akermu dequbed vqrs defanor Geekingfrog Adeon leah2 phlym amuck aristid fiQ2 twk- vjoki jmsx t36s lurkless sivs _flow_ solarus kloeri Boarders georgew runeks EduardoBautista ajmcmiddlin nisstyre benl23 darthThorik affinespaces teehemkay J_Arcane ebutleriv tabaqui1 metalrain ghuntley d0liver silver_needles adius jackhill)
20:50:34 --- names: list (VSpike wildsebastian s94a84d2e Guest36717 dh Kiruwa absence m1dnight_ NinjaTrappeur Guest42983 ekleog dani- dumptruckman azahi jluttine_ dsal_ jophish_ thi_ phaazon1 eacameron mitchellsalad_ gonz__ nlofaro_ cbarrett_ caasih tazjin ab9rf_ cheers- amatecha_ idupree2 user1_ PoliticsII_ typetetris_ ohko ensyde ltriant porrifolius MonkeyNOS NightA is_null_ drewr infandum ericsagnes agrif Guest39039 haroldwu lexi-lambda bspar Enigmagic Hotbees arsdragonfly)
20:50:34 --- names: list (milli Forkk mikeplus64 matheus intelux SegFaultAX ambrosia_ bwe saurik AWizzArd luite reactormonk relrod jameekim markus1189 mjrosenb w1gz Tspoon_ PierreM Kneiva hsiktas ddellacosta mrus Guest69260 dysfigured lowryder Lord_of_Life echoreply noumenon srnty_ gregberns ycheng nil Anthaas catsup atle giraffe jwynn6 ziman kav CSP-SOFTWARE RusAlex remexre saml theophil893 reorder_ pingiun TMA chin-tastic bbear Bish raek zzz reggie_ Cthalupa forell w1d3m0d3)
20:50:34 --- names: list (mycroftiv thonkpod kAworu abrar Tourist micro rotty mulk int-e lambdabot cjh` topos myme nitrix Cathy andromeda-galaxy codedmart yumh vktec zymurgy epta Igloo tureba krystianbajno koz_ JSharp drdo ullbeking dfordivam Guillaum pasukon johs haveo hodapp blackdog fiddlerwoaroof tchakka kosmikus pharaun fiatjaf wz1000 Xandaros eagleflo adarshaj d3lxa crooked EvanR abra0 Seich bcoppens lortabac exferenceBot Deewiant adamCS PlasmaStar sobhan machinedgod)
20:50:34 --- names: list (vicfred rosalux libertyprime stepnem revprez_stg _dga Arahael jedws dqd Niamkik Sose datajerk mnrmnaugh drewbarbs jix sim590 nicoulaj yahb Vtec234 cyphase oeblink Nikotiini Vq lkurusa albel727 Chousuke bolverkr Robin_Jadoul duairc moocow_ bbear_ malthe adadelta Entroacceptor _ht bendo edwtjo sdrodge bengt_ sandman13 saidinwot1 abuss polux7 swalladge quaestor spoonm cjay- freeside roflik marble_visions daGrevis Logio zenzike phadej gothos lyxia ereu)
20:50:34 --- names: list (elcaro Maxdamantus wrengr_away Zemyla cross kipras`away d6e apoc subfacto1 immae mmaruseacph2 M2tias so ziyourenxiang sebboh zaquest sagax Sk01 pavonia rruizt fryguybob moldybits pinecamp ft Ewout ctag_ styledash atraii davr0s__ linduxed a7250ag jonatan seliopou greymalkin seanparsons mniip sdx23 xarian telser wraithm yaroot rzmt sterni bind troydm raoul enemeth79 tms_ rodlogic pcoutin juri_ Mo0O artem e2 wadadli fantasti` MatrixBot3 ap5 wagle hjozwiak)
20:50:34 --- names: list (waskell otulp ion petermw totte Unode stilgart TommyC jvanbure nekomune Arguggi mikolaj_ _janne canta Firedancer_ AkhILman greeny__ Heffalump simon bob_twinkles Rembane exarkun Phyx- michalrus gsingh93 scal gambpang connrs- [df] Aleksejs coldpress carbolymer exio4 puffnfresh barrucadu eldritch geal luigy sssilver avp anderson djanatyn jinblack markhuge iron_houzi joeytwiddle)
20:50:56 <EvanR> but that only assumes you "materialize" the entire list. Lazy algorithms can avoid that
20:51:12 <maerwald> in my case it's definitely materialized
20:52:02 <EvanR> if the size doesn't change then consider using vector
20:53:42 <jle`> maerwald: in memory a vector is essentially [size,x,y,z...]; a linked list would be [cons,x,pointer] [cons,y,pointer] [cons,z,pointer] ... [nil]
20:54:09 <EvanR> plus heap object headers, however big that is
20:54:29 <jle`> not only does each node store the item and the pointer to the next item, it also has to store the tag on whether or not it is a cons or a nil
21:07:34 <hamechi> guys, I'm very newbie...
21:07:48 <hamechi> how can I define a naive monoid of String
21:08:02 <hamechi> data Str
21:08:02 <hamechi> instance Semigroup Str a where
21:08:03 <hamechi>  (<>) = mappend
21:08:04 <hamechi> instance Monoid Str a where
21:08:05 <hamechi>     mempty  = ""
21:08:06 <hamechi>     mappend = (++)
21:08:43 <hamechi> woops
21:08:44 <hamechi> sorry
21:08:46 <hamechi> https://pastebin.com/t7BzPQzY
21:08:58 <hamechi> what's wrong on mine naive type
21:08:59 <hamechi> ??
21:11:12 <dmwit> There's several things wrong.
21:11:38 <dmwit> `data Str` declares a new type `Str`, but it declares that there are no ways to build terms of type `Str`.
21:12:14 <dmwit> Under normal circumstances, you would want to include at least one constructor, and given what you're trying to do, it should probably include a field, too.
21:12:27 <hamechi> hum... 
21:12:32 <hamechi> like Str a
21:12:34 <hamechi> ?
21:12:42 <dmwit> The next thing wrong is that you're trying to apply the `Semigroup` and `Monoid` classes to two arguments each, but they are single-argument classes.
21:13:02 <dmwit> And then again the implementations you've given are good implementations for `String`, but that's a different type than `Str`.
21:13:08 <hamechi> aw, ok
21:13:19 <dmwit> If you are doing this as an exercise, I recommend trying to read a bit more tutorial first.
21:13:31 <hamechi> where? =)
21:13:38 <dmwit> If you're not, then I recommend skipping this entirely, as `String` is already an instance of Monoid with the implementations you proposed.
21:13:44 <dmwit> ?where tutorials
21:13:44 <lambdabot> http://haskell.org/haskellwiki/Tutorials
21:13:53 <hamechi> I'm doing as an exercise
21:13:58 <hamechi> thanks!
21:14:29 <hamechi> Everytime I try to instantiate a Monoid
21:14:36 <hamechi> I need a Semigroup?
21:14:41 <dmwit> Yes.
21:14:46 <hamechi> why?
21:15:01 <hamechi> there's some place that I can read it?
21:15:08 <hamechi> thanks =)
21:15:12 <EvanR> some bozo decided that all monoids are semigroups
21:15:27 <dmwit> There's a couple directions an answer to that question could go.
21:16:02 <dmwit> For example: why does the compiler force you to write a Semigroup instance/what existing code is the compiler reading to determine that it should demand a Semigroup instance?
21:16:24 <dmwit> For another example: somebody sat and wrote some code that forces you to write a Semigroup instance every time you write a Monoid instance. Why did they write that code?
21:16:35 <dmwit> Which of those questions (or perhaps some other one!) are you asking?
21:16:53 <hamechi> the first one
21:17:14 <dmwit> You may read the source of Monoid here: https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#Monoid
21:17:29 <hamechi> Why not every Monad itself implements a semigroup to the compiler?
21:17:32 <hamechi> ops
21:17:40 <hamechi> Why not every *monoid
21:17:41 <dmwit> I found that by going to Hoogle (http://hoogle.haskell.org), typing Monoid, clicking the first result, then clicking the "Source" link to the far right.
21:17:53 <hamechi> thanks!
21:22:48 <jle`> hamechi: for a more familiar example, it's the same deal with Eq and Ord
21:23:02 <jle`> hamechi: if you try to define an Ord instance for your type, ghc will complain unless you also define an Eq instance
21:23:40 <jle`> it's "because" Eq is a superclass of Ord; a requirement for something having an Ord instance is that it has an Eq instance
21:23:51 <jle`> class Eq a => Ord a where
21:24:05 <hamechi> hummm ! =O 
21:24:37 <jle`> as for why superclasses is a thing...it helps impose a sort of hierarchy of interfaces
21:24:50 <jle`> for example if you ever write a function Ord a => a -> a ...
21:24:55 <jle`> then you can "rest assured" that a also has an Eq instance
21:25:10 <jle`> otherwise, you'd have to write a type signature like (Ord a, Eq a) => a -> a ...
21:25:32 <jle`> same for Fractional (the ability to divide) and Num (the ability to add, subtract, multiply...)
21:25:53 <jle`> Num being a superclass for Fractional lets me write myFunc :: Fractional a => a -> a -> a; myFunc x y = (x / y) + x
21:26:04 <jle`> otherwise i would have to give it the type signature (Fractional a, Num a) => ...
21:26:47 <hamechi> wow! thanks, it kinda cleared the need and gave more urge to study =)
21:27:09 <jle`> no problem :)
21:27:26 <jle`> Semigroup/Monoid actually have a neat property (that Eq/Ord also has), in that using Monoid methods, you can implement Semigroup methods
21:27:29 <hamechi> cleared my need to understand and see values ocurring
21:27:50 <jle`> so you get a "free" definition of Semigroup you can write/copy and paste
21:28:10 <jle`> instance Semigroup MyType where (<>) = mappend
21:28:26 <jle`> so if you write a Monoid instance, you can just fill that out as boilerplate
21:28:52 <hamechi> Aw, You can implement Semigroup methods using Monoids
21:29:13 <jle`> yeah; same for Eq, actually; instance Eq MyType where x == y = compare x y == Eq
21:29:18 <jle`> * compare x y == EQ
21:29:32 <hamechi> because monoids are more restrictive than semigroups, you can build semigroups 
21:29:33 <hamechi> =O
21:29:42 <hamechi> nice
21:29:51 <jle`> this is actually a historical accident from the fact that mappend is a method of Monoid, even though it shouldn't be, heh
21:30:04 <hamechi> why? it shouldn't be?
21:30:22 <jle`> well, it doesn't need to; if a type is a Monoid instance, then it also has a Semigroup instance, so you can just use (<>)
21:30:24 <jle`> (semigroup append)
21:30:31 <hamechi> hum
21:30:35 <dmwit> The One True Way is to implement (<>) and mempty and never bother implementing mappend.
21:30:56 <dmwit> (The compiler will insert `mappend = (<>)` for you if you don't explicitly define mappend.)
21:31:16 <jle`> hamechi: but, Monoid was in the standard libraries before Semigroup was
21:31:21 <jle`> so now we're in this awkward position
21:31:40 <hamechi> yeah, but Semigroup does not need mempty, does it?
21:31:49 <jle`> it does not
21:31:53 <jle`> the ideal interface would be:
21:32:01 <jle`> class Semgroup a where (<>) :: a -> a -> a
21:32:07 <jle`> class Semigroup a => Monoid a where mempty :: a
21:32:13 <hamechi> wow ! 
21:32:17 <hamechi> cleared out
21:32:18 <hamechi> =)
21:32:43 <jle`> but back in the day we did not believe that semigroup was a useful abstraction
21:33:07 <jle`> nowadays it's still slightly controversial, but enough people believe it is useful to warrant adding it into the libraries, but it broke a lot of code.  as you are experiencing now
21:34:01 <hamechi> ow, I see
21:34:09 <hamechi> thanks! 
21:34:24 <hamechi> It gave me a good comprehension, now let's study more =)
21:35:03 <jle`> nice that the macbook air emits a useful part message when going to sleep
21:35:24 <suzu> lol
21:41:06 <jle`> woo hoo just figured out how to write a particularly hairy lens. i forgot the thrill of this all
21:51:22 <olligobber> I'm having trouble getting seq to work how I would expect it to
21:51:30 <gustavo> ?src ($)
21:51:30 <lambdabot> f $ x = f x
21:51:48 <gustavo> ?src (rem)
21:51:48 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
21:52:00 <olligobber> ?src rem
21:52:01 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
21:52:36 <suzu> lol these quotes
21:52:38 <suzu> ?src _
21:52:38 <lambdabot> Source not found. Just try something else.
21:52:40 <suzu> ?src _
21:52:40 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
21:52:43 <suzu> ?src _
21:52:43 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
21:52:47 <suzu> lol
21:53:07 <gustavo> ?src rem
21:53:07 <lambdabot> Source not found. Abort, Retry, Panic?
21:54:33 <gustavo> ?src (+)
21:54:33 <lambdabot> Source not found. Whoa.
21:54:48 <olligobber> the code where I'm trying to use seq is at https://gist.github.com/olligobber/fa2360bae5efba16475795c4784679de
21:55:15 <olligobber> but when I use the Trie I find that the first lookup takes much longer than later ones
21:56:21 <jle`> olligobber: the first lookup is what evaluates the trie
21:56:24 <olligobber> gustavo, it can't find the source since the implementation depends on the type
21:56:35 <jle`> olligobber: remember, seq doesn't say "evaluate this now"
21:56:46 <jle`> it says "seq x y" says "when you evaluate y, also evaluate x"
21:57:19 <olligobber> jle`, oh I see, how do I force it to evaluate something before IO prompts then
21:57:40 <EvanR> :t evaluate
21:57:42 <lambdabot> a -> IO a
21:57:55 <EvanR> evaluates the argument as an IO action
21:58:06 <jle`> evaluate will only resolve to WHNF; some thing you can do is perform some computation to figure out the sturcture of the tree
21:58:11 <jle`> and that computation would require the evaluation of the tree
21:58:23 <jle`> for example, computing the size of the tree would require looking at every leaf of the tree
21:58:50 <gustavo> Ok. Thanks man.
21:59:45 <EvanR> if you werent prepared to evaluate a whole tree, its a bit awkward. In which case deepseq is a convenient sledgehammer
22:00:01 <olligobber> ok, I'll try measuring the size of the tree
22:00:19 <iqubic> How long until dependent haskell becomes a reality?
22:00:20 <EvanR> theres usually a reason you don't need this. Like having your structure already evaluated
22:00:40 <EvanR> evaluated as its constructed in the first place
22:01:04 <nshepperd> for that matter, seq only evaluates its first argument to whnf
22:01:35 <cocreature> and you pay for unnecessary deepseqs. I recently shaved 2s of a 3s computation at work by removing a bunch of deepseqs
22:01:39 <olligobber> that's why I have every single child node seq'd to its parent
22:01:52 <olligobber> it still didn't work though
22:01:53 <nshepperd> so putting 'seq newchild ...' is only requiring the outer Trie constructor of newchild to be evaluated when ... is
22:02:05 <olligobber> oh, but not the array, I see
22:02:09 <nshepperd> it won't cause evaluation of the array or the set
22:03:16 <olligobber> ok, I'll just do the size thing
22:04:22 <EvanR> if the entire tree is rigged with seqs (or equivalent) then evaluate the root in IO would do the ignition
22:04:55 <EvanR> simply defining the size somewhere and not printing it out would not
22:05:49 <EvanR> its funny how none of this comes up when you are actually trying to solve a real problem or do real work
22:07:16 <nshepperd> making the two fields of the Trie strict would do the trick, i think
22:07:40 <nshepperd> 'children :: !Array Char (Maybe Trie)' or whatever the syntax was
22:09:58 <EvanR> is there a strict Array 
22:12:07 <nshepperd> dunno. unboxed arrays are strict in their values
22:12:15 <nshepperd> boxed arrays usually seem to be lazy
22:18:48 <nshepperd> EvanR: in my experience usually you don't have to care about evaluation order, except when you do
22:20:21 <EvanR> yes strict fields is prob way to when building a tree
22:20:30 <EvanR> way to go
22:20:47 <EvanR> unless its "bottomless data"
22:32:19 <jgt> Good morning
22:37:59 <Guest_93> configure: error: C compiler cannot create executables
22:38:12 <Guest_93> What does this mean when I am installing Haskell
22:38:24 <Axman6> how are you installing it?
22:38:48 <Guest_93> I went to the Haskell website and typed in the curl command for Mac
22:39:30 <Guest_93> Another error listed is this - Failed to install, consider updating this script via: ghcup upgrade"ghcup --cache install" failed!
22:39:49 <Axman6> Do you have Xcode installed?
22:40:17 <jackdk> xcode-select --install is the command to install the commandline tools iirc
22:40:41 <Guest_93> I had it before on my computer, but I uninstalled it a while ago
22:40:58 <Axman6> You'll need to have it to get the C compiler
22:41:06 <Guest_93> Ok 
22:41:20 <Guest_93> So I should reinstall it and then try to install again?
22:41:25 <Axman6> yes
22:41:29 <Guest_93> Ok thank you!
22:41:29 <jgt> Guest_93: bear in mind there is a difference between Xcode and the Xcode Command Line Tools
22:41:36 <Axman6> run the command jackdk gave you
22:41:39 <jgt> or, there used to be
22:41:46 <jgt> I'm not sure now
22:41:52 <Axman6> I believe there stil is
22:41:58 <Guest_93> Ok so that command should install it?
22:42:06 <Axman6> xcode-select --install
22:42:10 <Guest_93> Previously I think I installed through the app store
22:42:15 <Guest_93> But yeah that seems easier
22:42:24 <Axman6> yes (I think, I haven't needed to do it for a very long time)
22:42:45 <Axman6> sure, but I think you'll still need to run that to get the command line tools
22:42:52 <Axman6> which is what contains the C compiler
22:43:23 <Guest_93> Ok thank you I will do these steps
23:01:35 <dminuoso> This is syntactically invalid; https://gist.github.com/dminuoso/cc473e947b4222340e19b32068ca5fd9 
23:01:48 <orzo> Is there a way to override any resolver in any stack.yaml with a global config to set a single preferred resolver?
23:01:51 <dminuoso> Is there a way to transform it in such a way, that I dont have to put the entire pattern onto a single line?
23:02:26 <orzo> i know i can override it on the command line, but i tend to mess that up and i don't want to run stack with another resolver ever because i'm short on space
23:07:59 <jgt> orzo: I haven't tried it, but maybe you could symlink the directory where stack stores everything to a directory on another drive, like a USB stick
23:08:26 <jgt> I'm also short on space and I often have to resort to tricks like this
23:09:59 <cocreature> dminuoso: what happens if you indent the lines after the first one more than the first one?
23:13:09 <Flooooooora> Hi I'm totally new to Haskell, just downloaded ghc and cabal-install and stack, but now ghci won't start.
23:14:12 <Flooooooora> error is -bash: ghci: command not found, is it related to env vars not being set correctly?
23:14:38 <maerwald> Flooooooora: how did you install?
23:14:50 <orzo> it means ghci is not in your PATH
23:15:14 <dminuoso> cocreature: Mmm doesnt work. What does work is putting the :<|> at the end of the previous lines though.
23:15:20 <dminuoso> I find that curious
23:15:30 <Flooooooora> To install I ran curl https://get-ghcup.haskell.org -sSf | sh then curl -sSL https://get.haskellstack.org/ | sh
23:15:41 <orzo> dminuoso: i tried cocreatures sugestion on your thing and got it to compile
23:15:56 <orzo> after adding some declarations of course
23:16:08 <jgt> Flooooooora: if I remember correctly, it should be enough to install stack. The stack tool is meant to take care of installing GHC for you.
23:16:14 <maerwald> Flooooooora: did you source ~/.ghcup/env in your ~/.bashrc?
23:16:37 <dminuoso> orzo: There must be something else, can you share what you tried? I had to add some parens.
23:17:28 <Flooooooora> I couldn't find a bashrc in my mac.. there're only .bash_profile and .bash_history
23:18:04 <orzo> dminuoso: https://paste.ee/p/6Ufkx
23:18:07 <maerwald> Flooooooora: then add it to ~/.bash_profile
23:18:09 <Flooooooora> but I did tried adding the PATH for one session: PATH=/Users/flora/Desktop/google-cloud-sdk/bin:/anaconda3/bin:/Users/flora/Desktop/google-cloud-sdk/bin:/anaconda3/bin:/usr/bin:/usr/sbin:/bin:/sbin:/usr/X11R6/bin:/Users/flora/Desktop/cbsi:/Users/flora/Desktop/new tools/cute_haskell:/Users/flora/.local/bin:/Users/flora/.ghcup/env
23:18:28 <maerwald> Flooooooora: no, /Users/flora/.ghcup/env is a file, not a directory
23:18:40 <maerwald> add 'source /Users/flora/.ghcup/env' to your ~/.bash_profile
23:18:48 <Flooooooora> got it, let me try
23:19:22 <dminuoso> orzo: Ohh I see, I made a subtle other typo. Thanks cocreature and orzo :)
23:19:54 <Flooooooora> that works, thank you all so much!
23:19:57 <maerwald> Flooooooora: after doing so enter a new bash shell, then it should work (stack should already work, it's separate from ghcup)
23:19:59 <maerwald> kk
23:20:21 <Flooooooora> maerwald thank u
23:21:02 <Flooooooora> now it also works on another terminal
23:21:39 <zeta_0> how do i generate a local hoogle database ?
23:25:42 <zeta_0> never mind, emacs has hoogle built-in
