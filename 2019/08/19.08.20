00:06:31 <dmwit> porrifolius: Yes, that's correct!
00:07:09 <dmwit> porrifolius: Indeed, it is relatively common for a careful formalization of "arrow" to need to include the domain and codomain in the "data structure" that represents the arrow.
00:07:47 <dmwit> Not in every category, but in many, and in particular in the one you're describing where objects are strings and there is an arrow labeled T from the string S to the string S++T.
00:08:22 <dmwit> Then the "data structure" representing that arrow needs to at least store S, too (though it need not store S++T, since that's recoverable from the data (S,T)).
00:17:51 <philipp10> hello haskellers! newbie question: is the `$` operator "just" syntactic sugar to avoid cluttering code with parentheses - or does he have any additional feature I'm not aware of? thx
00:18:06 <Axman6> that's pretty much it really
00:18:23 <Axman6> it lets you write f . g . h $ x instead of (f . g . h) x
00:18:25 <philipp10> Axman6, thx
00:18:34 <dminuoso> philipp10: Its better than syntactic sugar! It's a regular operator! :)
00:18:44 <Axman6> It's just a function D:
00:18:46 <dminuoso> philipp10: It's a function/operator that is simply defined using plain Haskell!
00:18:56 <Axman6> @src ($)
00:18:56 <lambdabot> f $ x = f x
00:19:22 <philipp10> dminuoso, yeah it's full grown function/operator of course. sorry for messing up ;-)  
00:19:26 <dminuoso> infixr 0 $
00:19:38 <dminuoso> philipp10: ^- the trick about that operator is merely its fixity declaration. :)
00:19:39 <Axman6> yeah that's the important bit
00:20:34 <dminuoso> philipp10: That fixity declaration just says "it's right associative, and it has the lowest precedence possible"
00:21:40 <philipp10> dminuoso, another newbie question: function composition with `.` is being evaluated from right -> left, innit? 
00:22:16 <dminuoso> philipp10: Evaluation order works different in Haskell.
00:22:50 <dminuoso> philipp10: Evaluation happens on demand, not according to rigid "from left to right" specifications.
00:23:05 <mjrosenb> and composition is associative, so you can't really say that it "starts" at one side or the other.
00:27:00 <EvanR> on one hand, associativity makes it easier to reason semantically about function chains
00:27:23 <EvanR> on the other hand, now it's not immediately obvious "what happens first"
00:27:32 <philipp10> dminuoso, as an example of function composition: `interact $ show . sum . map read . words ` can you elaborate how this's is being evaluated? 
00:28:10 <dminuoso> philipp10: Im assuming that this is the definition of ⌜main⌝, is that correct?
00:33:31 <jusss> dminuoso: the tasks you left yesterday, I don't understand what it means... "Write an ⌜instance Applicative f => ApplicativeAlt f⌝ and an  ⌜instance ApplicativeAlt f => Applicative f⌝ - such that  Applicative is implemented in terms of ApplicativeAlt and vice  versa." you want me make Maybe as their instance?
00:33:42 <dminuoso> jusss: No.
00:34:22 <lavalike> mjrosenb: that seems misleading, it is right associative in hs
00:34:35 <philipp10> dminuoso, yes, correct
00:34:35 <dminuoso> jusss: I want you to write "plus" in terms of "<*> and pure" (do you need both? figure it out!), and "unit" in terms of "<*> and pure" (do you too need both? figure it out!)
00:36:11 <philipp10> dminuoso, sorry for not pasting the whole block, so it goes: ` main = interact $ show . sum . map read . words`
00:37:20 <dminuoso> % :t interact $ show . sum . map read . words
00:37:20 <yahb> dminuoso: IO ()
00:37:24 <dminuoso> % :t show . sum . map read . words
00:37:24 <yahb> dminuoso: String -> String
00:37:37 <EvanR> > (length . group . undefined . const 9) "flooz"
00:37:40 <lambdabot>  *Exception: Prelude.undefined
00:38:08 <EvanR> > (((length . group) . undefined) . const 9) "flooz"
00:38:11 <lambdabot>  *Exception: Prelude.undefined
00:38:57 <dminuoso> philipp10: Give me a moment to gather my thoughts how to best explain this
00:39:23 <merijn> dminuoso: Simple, you just link Heinrich Apfelmus's site :p
00:39:24 <philipp10> dminuoso, sure, of course. don't hurry ;-)  
00:39:36 <dminuoso> merijn: Perfect, do you have the link at hand?
00:40:05 <merijn> No, I always google it >.>
00:40:29 <merijn> mmm, looks like the site broke, that's a bummer
00:41:04 <merijn> Well bollocks
00:41:17 <EvanR> google? unsurprised
00:41:52 <dminuoso> philipp10: https://web.archive.org/web/20170430095057/https://hackhands.com/lazy-evaluation-works-haskell/
00:42:15 <merijn> dminuoso: The individual sublinks don't work
00:42:25 <merijn> Ah, wait, that's the archive
00:42:34 <merijn> I just found a broken github mirror :)
00:42:46 <EvanR> > (const 9 . undefined . length . group) "flooz"
00:42:49 <lambdabot>  9
00:43:31 <merijn> Should probably ask Heinrich permision to mirror that article on the wiki or something. It's a pretty good simple intro
00:52:32 <philipp10> thanks for the link, dminuoso
01:06:05 <jusss> dminuoso: https://paste.ubuntu.com/p/zjWFMtSJXj/
01:06:44 <dminuoso> jusss: I invite you to write them as actual instances.
01:06:50 <dminuoso> jusss: Your type checker will help you.
01:08:25 <jusss> dminuoso: I don't the transformer about (a,b) 
01:08:28 <jusss> know
01:10:07 <dminuoso> jusss: If you already knew the solution, it wouldn't be a challenge. :)
01:10:34 <dminuoso> jusss: There is too much pseudo annotation that I cant understand in that paste.
01:13:53 <jusss> dminuoso: https://paste.ubuntu.com/p/Fj3gR6SfQW/
01:15:02 <jusss> dminuoso: this is ok?
01:17:08 <dminuoso> jusss: That looks wrong.
01:17:22 <dminuoso> jusss: What are ⌜get⌝ and ⌜g⌝ exactly?
01:19:15 <jusss> dminuoso: g::a->(a,b); get::(a,b)->b
01:19:25 <jusss> I just made it up
01:20:48 <jackzhang> H
01:26:42 * hackage tidal 1.4.0 - Pattern language for improvised music  https://hackage.haskell.org/package/tidal-1.4.0 (AlexMcLean)
01:37:47 <Ariakenom> Hey #haskell. What is Haskell's biggest weakness, to you?
01:42:21 <merijn> Ariakenom: Messy Num hierarchy, unchecked exceptions, async exceptions being ultra-hard to reason about (see also, Control.Exception's bracket & co still being broken as pointed out by me an Peaker years ago)...
01:42:47 <merijn> Ariakenom: Also v2-build having broken all editor integration for the near future >.>
01:42:59 <tdammers> Ariakenom: I would have to say "performance"
01:43:38 <tdammers> not in the "it's not fast enough" sense, but in the "it's too difficult to reason about performance" sense, and also in the "it's too difficult to make informed decisions wrt performance tradeoffs"
01:44:04 <merijn> I was about to say, because usually it is more than fast enough for me :p
01:44:12 <Ariakenom> merijn: interesting, how's bracket broken?
01:44:45 <tdammers> it is more than fast enough in terms of throughput, but sometimes, you want to favor latency (particularly in realtime applications), and the current stop-the-world GC makes that very difficult
01:44:49 <merijn> Ariakenom: It uses interruptible mask for cleanup, so if you do a blocking operation in cleanup you can be async exceptioned during cleanup and not complete it
01:45:04 <tdammers> granted, this is probably in large part a matter of implementation more than language spec
01:45:08 <merijn> Since blocking operations explicitly unmask anything except uninterruptible mask
01:45:28 <merijn> tdammers: That's why the new GC is in development, no? :)
01:45:47 <AWizzArd> merijn: link?
01:45:48 <tdammers> merijn: yes.
01:46:09 <merijn> AWizzArd: To what?
01:46:18 <AWizzArd> merijn: I would like to know more about that new GC.
01:47:36 <dminuoso> jusss: If you make up functions, implement them.
01:48:02 <dminuoso> jusss: How would ⌜g :: a -> (a, b)⌝ be implemented, exactly?
01:48:20 <tdammers> AWizzArd: https://www.youtube.com/watch?v=7_ig6r2C-d4 - this is Ben Gamari, the main guy behind the new GC (and also one of the secret main people behind GHC) explaining how it works
01:48:29 <merijn> AWizzArd: Work in progress for 8.10 https://github.com/pepeiborra/gc-benchmarks/blob/1b24c5c0a06c004740caabe4776af0bf21b6f6ee/README.md
01:48:57 <Ariakenom> GC discussions confuse me. afaict pretty much every GC has unbounded stop-the-world, even though it is short for those that claim to not have it.
01:49:22 <dminuoso> Ariakenom: Nope.
01:50:13 <AWizzArd> Ariakenom: also Go’s GC?
01:51:09 <Ariakenom> AWizzArd: yeah, from what I remember
01:52:24 <dminuoso> Is there an equivalent of hspec's around/around_ for tasty?
01:53:06 <merijn> dminuoso: It'd probably help to say what those functions do?
01:53:27 <merijn> Ariakenom: No? Why would you *need* stop-the-world?
01:53:34 <dminuoso> merijn: Ah it's basically a bracket_ around each individual test.
01:54:17 <merijn> dminuoso: withResource ?
01:54:24 <Ariakenom> also reference counting seems popular to me. but in the little testing I've found it's not the greatest https://www.hpl.hp.com/techreports/2003/HPL-2003-215.pdf
01:54:35 <dminuoso> merijn: That doesn't wrap each individual leaf, but only the entire tree
01:54:53 <merijn> dminuoso: You'd have to apply it for each leaf, sure
01:55:27 <Ariakenom> merijn: some step in the mark of mark-sweep always does it iirc
01:57:40 <Ariakenom> tdammers: very interesting. do you have ideas on what's needed to solve those performance issues? in what situations is it a problem?
02:00:35 <jusss> dminuoso: oops, there's no g::a->(a,b)...
02:01:00 <jusss> g:: a b ->(a,b) should be ok
02:01:26 <jusss> g x y = (x,y)
02:01:35 <dminuoso> jusss: I recommend you dont write in notepad/gist, write your code using an editor and try it with GHC.
02:01:41 <dminuoso> jusss: You would have noticed that error immediately.
02:02:06 <dminuoso> jusss: By the way, that function already exists! It's called (,) :)
02:02:13 <dminuoso> % :t (,)
02:02:13 <yahb> dminuoso: a -> b -> (a, b)
02:02:53 <jusss> dminuoso: aha, I found a function which is already existed!
02:03:34 <tdammers> Ariakenom: it's a problem, usually, when latency is important, so that's typically realtime applications: games, multimedia, industrial control, etc.
02:04:27 <dminuoso> Ariakenom: Matthew did a nice presentation last year on munihac: https://www.youtube.com/watch?v=7_ig6r2C-d4
02:05:04 <Ariakenom> dminuoso: yes I've seen it
02:06:13 <Ariakenom> tdammers: ah yeah. I was thinking of examples where you had run into it yourself
02:06:42 * hackage salak 0.3.4.1 - Configuration (re)Loader and Parser.  https://hackage.haskell.org/package/salak-0.3.4.1 (leptonyu)
02:07:42 * hackage salak-toml 0.3.4.1, salak-yaml 0.3.4.1 (leptonyu): https://qbin.io/gays-fonts-ullh
02:10:20 <jusss> dminuoso: can you give out the left part of '=' ?
02:10:48 <jusss> give
02:10:56 <dminuoso> jusss: What do you mean?
02:11:55 <jusss> dminuoso: plus x y z =?
02:12:36 <dminuoso> jusss: Look at the type signature, you can see how many arguments.
02:12:50 <jusss> dminuoso: three?
02:13:22 <dminuoso> jusss: What is the type signature?
02:13:25 <jusss> or how do you know what is the number of arguments based on the type signature?
02:13:39 <dminuoso> jusss: What else would tell you?
02:14:02 <dminuoso> jusss: If that is really your question, then we should stop this excercise.
02:14:23 <dminuoso> I clearly misjudged your progress in Haskell.
02:15:34 <jusss> two
02:16:20 <dminuoso> jusss: You shouldn't be dabbling with these sort of excercises if you aren't sure how many arguments a given function has when looking at its type signature. :)
02:16:31 <dminuoso> It may be more effective to return to simpler excercises.
02:20:26 <jgt> jusss: f :: a -> a
02:20:31 <jgt> jusss: how many arguments?
02:26:02 <jusss> jgt: that's one, what make me confused is the applicative f, should it be an argument?
02:26:20 <jusss> or Monad m, should it be an argument?
02:26:25 <dminuoso> jusss: It's not an argument.
02:26:36 <jusss> dminuoso: ok
02:26:41 <Ariakenom> . o O (f f 1)
02:27:14 <dminuoso> jusss: The thing to the left of a => is called the context and contains multiple so-called constraints.
02:27:35 <dminuoso> jusss: "Applicative f" is a constraint that says "Whateve the choice of f, there must be an instance Applicatie f"
02:28:29 <dminuoso> jusss: So remember that when calling/using/consuming a polymorphic thing containing type variables, that the consumer can pick what those type variables can be?
02:28:35 <jusss> dminuoso: then what is "context" here?
02:29:01 <dminuoso> jusss: Constraints acts as limits to those choices. So when you have "f :: a -> a", you can pick any type for ⌜a⌝ without any limitation.
02:29:44 <dminuoso> If however you have: ⌜g :: Applicative f => a -> f a⌝, then you can pick any type you want for ⌜a⌝, but the choice for ⌜f⌝ is limited by the constraint.
02:30:04 <dminuoso> That type signature reads:
02:30:32 <Phyx-> ysangkok: what exactly is the problem with compiling the library?
02:30:34 <dminuoso> "For every choice of some types ⌜a⌝ and ⌜f⌝, in which there must be an ⌜instance Applicative f⌝, g has the type "a -> f a"
02:31:09 <dminuoso> jusss: Does this make sense?
02:31:12 <jusss> dminuoso: and Applicative f has to have <*> and pure two methods,
02:31:39 <dminuoso> jusss: Yes! So from the perspective of the *caller* its just important that "instance Applicative f" is satisfied.
02:31:58 <jusss> dminuoso: and g may to connect with <*> and pure?
02:32:10 <jgt> I'm losing track of exactly what jusss is confused about
02:32:51 <jusss> jgt: applicative f in f a or monad m in m a should have arguments or not, they shouldn't 
02:33:19 <jusss> 'cause f a is the type who has value, and f is a type who hasn't value
02:33:27 <dminuoso> jusss: We could, in spirit, think of "Applicative f" as a dictionary containing the class methods
02:33:35 <dminuoso> jusss: But again, this is just in spirit.
02:34:05 <jusss> dminuoso: ok, what is "context" now?
02:34:12 <jusss> or computation
02:34:30 <jusss> I don't understand why there're so many terms in haskell which are not in other languages
02:34:54 <dminuoso> jusss: Context has multiple meanings. The meaning Im referring to, is that in a type signature "f :: Ctxt f => ..." the stuff to the left of the => is called context.
02:35:12 <jusss> for example, exceptions, in other language it means runtime exceptions, but in haskell it may not, reference to Either
02:35:15 <jgt> I'd call that a constraint, not a context
02:35:21 <jgt> I mean, it _is_ a context
02:35:23 <dminuoso> jgt: Constraints are the individual parts of the context.
02:35:29 <jgt> but constraint seems a little more specific
02:35:35 <jgt> fair enough
02:36:00 <dminuoso> jgt: ⌜Eq :: * -> Constraint⌝ if that makes sense to you :)
02:36:03 <jusss> dminuoso: namespace or envrionment, or context are same thing in other languages, so I don't know if they're in haskell?
02:36:39 <jgt> jusss: in English, a single word can have multiple meanings
02:36:53 <jgt> jusss: this is often the case with generic words like "context"
02:37:07 <dminuoso> jusss: Dont worry too much about the word "context". It's just what we call that thing to the left of => :)
02:37:18 <dminuoso> jusss: we have to call it something, dont we?
02:37:20 <jusss> jgt: but namespace is specific
02:37:33 <dminuoso> jusss: In English context is a rather generic term, honestly.
02:37:35 <jgt> jusss: are we talking about "namespace" or "context"?
02:37:38 <jusss> it's where the values stored
02:38:10 <dminuoso> jusss: A context is the stuff/surroundings/additional bits of something.
02:38:10 <jusss> dminuoso: what is the specific name for context in haskell? or near?
02:38:25 <dminuoso> jusss: context is a generic English word.
02:38:52 <jusss> dminuoso: no definition in math?
02:38:57 <porrifolius> dmwit: Ah, great, good to know I'm at least in the ballpark! :)  Thanks for the help... time for some more reading, and digestion, I think.
02:39:09 <jusss> dminuoso: ok, 
02:39:27 <dminuoso> jusss: It probably isnt too helpful to look into math for meaning, because math frequently reuses terminology for other things
02:39:54 <dminuoso> jusss: Merely accept that, in a type signature, when you have a double arrow =>, the thing to left is called context.
02:39:58 <jusss> dminuoso: and computation?
02:40:15 <dminuoso> jusss: The word context is used multiple times, confusingly. ;)
02:40:21 <dminuoso> And they have unrelated meanings.
02:40:41 <no-n> oh, so context means something else under a different context
02:40:43 <dminuoso> jusss: If you prefer we can simply say "constraints in a type signature" instead.
02:40:55 <jgt> dminuoso: I also want to say that "in Haskell, the number of arguments a function takes is exactly equal to the number of times you see `->` in the type signature"
02:41:07 <dminuoso> jgt: That doest work.
02:41:09 <jusss> dminuoso: that's ok, I can take the left part of => as "context"
02:41:19 <dminuoso> jusss: Alright. :)
02:41:21 <jgt> dminuoso: this is of course ignoring the fact that every function only actually takes one argument
02:41:31 <dminuoso> jgt: Sure, but its still false
02:41:34 <yushyin> wow, first time seeing that the left part of => is called context, but I just checked the haskellreport and of course dminuoso is right. TIL I guess ;P
02:41:47 <dminuoso> jgt: How many arguments does ⌜f :: (a -> a) -> a⌝ take? ;)
02:42:05 <jusss> dminuoso: wait, what's a double arrow?
02:42:08 <jgt> dminuoso: oh, bollocks. Yes, that's pretty much exactly what I realised right before you wrote it :)
02:42:11 <dminuoso> jusss: =>
02:42:17 <jusss> dminuoso: ok
02:42:54 <jgt> dminuoso: but ignoring the arrows inside parens, it's true then isn't it?
02:43:15 <dminuoso> jgt: ⌜f :: a -> (a -> a)⌝ ?
02:43:19 <jusss> dminuoso: then "computation" and "action" what're they meaning?
02:43:33 <jgt> dminuoso: I'd count that as "arrows inside parens"
02:43:34 <jusss> dminuoso: jgt one
02:43:51 <jgt> and also I'm wondering if some extension like DataKinds would also falsify my statement
02:44:02 <dminuoso> jgt: So according to your logic ⌜f :: a -> (a -> a)⌝ takes a different number of arugments than ⌜g :: a -> a -> a⌝ ?
02:44:06 <dminuoso> Interesting.
02:44:38 <jgt> dminuoso: yeah I think my statement was just wrong :)
02:44:51 <jgt> sometimes this simplified summaries work; sometimes not
02:44:54 <jgt> this time I failed
02:45:03 <jgt> these*
02:46:08 <dminuoso> jusss: Honesty I dont know how to formally define these words.
02:50:12 <jusss> dminuoso: wait a sec, >=>::(a->e->b)->(b->e->c)->a->e->c there would be four arguments, right?
02:50:25 <jusss> >=> f g x y = g (f x y) y
02:51:12 <jgt> jusss: for practical purposes, yes
02:51:14 <jusss> and >=> :: (a->m b) -> (b->m c) -> (a->m c) would have ?
02:51:22 <jgt> two
02:51:40 <jgt> but technically, alll functions in Haskell take exactly one argument
02:53:17 <jusss> :t fmap
02:53:21 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:53:59 <jgt> "fmap takes some function from a to b, and a functor of a, and produces a functor of b"
02:54:03 <jgt> that's how I'd read that
02:54:29 <jusss> the numbers of arguments depends its result I think
02:54:44 <jusss> :t (.)
02:54:47 <lambdabot> (b -> c) -> (a -> b) -> a -> c
02:54:53 <jgt> …?
02:54:54 <maerwald> jgt: that's not really useful to talk about functions (except reminding people about what currying is) and afais the haskell report doesn't use it that way either
02:55:18 <jgt> maerwald: which isn't useful? Saying that every function takes exactly one argument?
02:55:22 <jusss> jgt: what the number of arugments of （.)?
02:55:22 <maerwald> yes
02:56:22 <jusss> you give (.) two and (.) give you (a->c), you give (.) three and (.) give you c
02:56:35 <jgt> jusss: I'd say three, but I think my explanations just aren't helping today, so I give up
02:56:48 <fog> nothing seems to be able to get haskoin to build with stack... but adding the flag ./configure --host=x86_64-w64-mingw32
02:57:47 <jusss> why there's no rules that explein about this...
02:57:59 <dminuoso> There's in the end multiple intuitions.
02:58:10 <dminuoso> The technically correct way to put it, is that (.) takes a single argument.
02:58:15 <jgt> jusss: well yes, but the distinction is in whether or not you want your function to be fully applied
02:58:34 <dminuoso> The intuitively useful way to think of it, is that (.) takes two arguments on the idea that (.) composes two functions together to form a third.
02:58:34 <jgt> or at least, that's the distinction I _thought_ you were after
02:59:05 <jusss> dminuoso: but we can give three, right?
02:59:33 <davean> you can keep giving arguments to the thing (.) returns
02:59:40 <dminuoso> jusss: Sure.
03:00:01 <dminuoso> jusss: It's just a matter of perspective, really. Its useful to be able to recognize all three perspectives as sort of "valid"
03:00:12 <dminuoso> jusss: And be able to instantly switch them to understand your code better.
03:00:40 <davean> jusss: you could supply a 4th argument if c is a function too
03:00:54 <jusss> dminuoso: so how you're sure how many arguments a given function has when looking at its type signature?
03:01:08 <davean> jusss: how many is it useful to give?
03:01:49 <dminuoso> ^- that :)
03:01:53 <jusss> davean: how you know what is "useful" ?
03:02:05 <dminuoso> jusss: Good question, that depends on the code and what you are doing.
03:02:08 <davean> jusss: Well you have to know what you want to accomplish
03:02:21 <dminuoso> jusss: Take (+) for example. Its a function
03:02:30 <dminuoso> There's a notion in which it takes just one argument:
03:02:41 <dminuoso> (1+) creates an 1-adder function. so we could think of + as creating adder functions.
03:03:08 <dminuoso> (1+2) can be thought as "adding two numbers together", or perhaps as "creating a 1-adder function, and applying that to two"
03:03:28 <MarcelineVQ> If I want to write specifically (.) why might 3 arguments be a good place to start? What hints do I have that this is the case?
03:03:28 <dminuoso> They are operationally the same, which perspective is better depends on how you look at your code.
03:04:38 <davean> jusss: I'll note some "functions" when you're viewing them as the multiargument form, you can't tell how many they take untill you stop giving them (printf)
03:04:44 <jusss> dminuoso: ok, 
03:05:14 <davean> jusss: http://hackage.haskell.org/package/base-4.12.0.0/docs/Text-Printf.html
03:05:21 <davean> takes as many arguements as you give it
03:05:25 <MarcelineVQ> it's all well and good that some functions can take more than I, such as if c is also a function type, but does that change how I write (.) ?
03:05:34 <MarcelineVQ> *more than I expect
03:05:38 <jusss> dminuoso: I still want to know "compustation" and "action" in haskell would like? and why those terms "computation" "action" and "context" always come with monad?
03:05:56 <dminuoso> jusss: That's a good question, actually.
03:05:58 <davean> MarcelineVQ: I'm not sure what you're asking
03:06:05 <dminuoso> jusss: I can, at least, talk about why "context" is frequently used
03:06:08 <davean> MarcelineVQ: are you talking about implimenting (.)?
03:06:10 <jusss> sometimes, it not the term monad make people confused, it's the way you describe it
03:06:18 <dminuoso> jusss: To do that, we need to explore linguistics a bit. Do you know what context is in linguistics?
03:06:28 <dminuoso> jusss: Yes! I fully agree.
03:07:23 <jusss> dminuoso: my mother lanagues is not English...
03:07:28 <MarcelineVQ> Yes, because earlier before I dc'd the confusion on jusss end was understanding how a type sig informs you what your argument are, so I assume it still is
03:07:29 <dminuoso> jusss: That's fine.
03:08:18 <dminuoso> jusss: If you are reading some historical article about world war II, then context is all that extra stuff/knowledge in your head, that allows you to understand the text.
03:08:27 <dminuoso> jusss: Its the stuff not in the text, but relevant to the meaning of the text.
03:08:47 <jusss> dminuoso: yes
03:08:47 <dminuoso> jusss: This is a relatively lose notion
03:11:24 <jusss> dminuoso: and "computation " "action"?
03:12:26 <dminuoso> jusss: The issue at the end is, that they are just mind models that people have developed after understanding monad.
03:12:42 <dminuoso> jusss: They are not vessels to explain it, they are individual mental models.
03:12:44 <jusss> dminuoso: so monad is still unspeakable?
03:13:20 <dminuoso> jusss: It's just highly abstract, which is why people seem to like using abstract terms for it.
03:14:13 <dminuoso> jusss: There's a simple way to approach it, and that's "its an interface consisting of two functions" 
03:14:14 <maerwald> dminuoso: so monads are world war 2?
03:14:18 <maerwald> :D
03:14:39 <jusss> dminuoso: and how you know your abstract term and his abstract term are the same thing? 'cause they're all abstract :)
03:15:12 <maerwald> I think this is the best monad metaphor so far
03:15:35 <dminuoso> jusss: Sometimes they are not.
03:16:29 <jusss> dminuoso: I feel it like something like the zen...
03:16:33 <dminuoso> jusss: https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
03:16:50 <dminuoso> jusss: This is a useful read. It wont explain what Monad is, but it sort of explores why people like you are having so many troubles.
03:17:24 <jusss> I saw this before, “Monads are Burritos,”
03:18:52 <jusss> time is abstract, can we make time concret?
03:19:03 <jusss> 1 is abstract, can we make 1 concret?
03:19:49 <dminuoso> jusss: Numbers are also a good example. 
03:20:09 <dminuoso> jusss: In the peano construction 1 is defined to be the successor (whatever a successor is, we dont know) of 0.
03:20:23 <dminuoso> And 0 is just defined to exist.
03:21:12 <jusss> dminuoso: I think we can back to your tasks...
03:21:20 <davean> he mental models more represent how those people are using monads than even their understanding of a monad really IMO
03:22:15 <dminuoso> davean: The deepest truth I found in that joke.. but that joke is not a means of arriving at understanding, it's rather the goal.
03:26:11 <MarcelineVQ> <dminuoso> jusss: There's a simple way to approach it, and that's "its an interface consisting of two functions"
03:26:35 <MarcelineVQ> feel like that was missed
03:27:17 <jusss> dminuoso: the transformation about (a,b), how I can get (a,b) through <*> and pure's type, 'cause (a,b) doesn't existed between them
03:27:40 <dminuoso> jusss: No parse. Can you rephrase?
03:29:05 <jusss> :t <*>
03:29:07 <lambdabot> error: parse error on input ‘<*>’
03:29:13 <jusss> :t (<*>)
03:29:16 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
03:29:21 <jusss> :t pure
03:29:23 <lambdabot> Applicative f => a -> f a
03:29:39 <jusss> plus :: f a -> f b -> f (a, b)
03:30:00 <dminuoso> jusss: That signature is missing a context. :)
03:30:00 <jusss> dminuoso: there's no such thing like (a,b) in <*> and pure's type
03:30:13 <dminuoso> jusss: Indeed!
03:30:16 <jusss> dminuoso: oh, context again!
03:30:34 <jusss> this is the term I heard lots of
03:30:39 <jusss> read
03:31:10 <dminuoso> jusss: I did that intentionally. I just meant that the type signature of plus is missing a constraint Applicative f.
03:31:33 <jusss> dminuoso: and you suppose I give it a function which has that type?
03:31:57 <dminuoso> jusss: What do you think a constraint is?
03:32:20 <dminuoso> jusss: What do you mean by "I give it a function which has that type"
03:32:22 <jusss> dminuoso: Int, so it must be -xx to + xx, x is the number I forget
03:32:37 <jusss> dminuoso: complete the missing (a,b)
03:32:46 <dminuoso> jusss: There are no values of type "Applicative f" because "Applicative f" is a constraint, it's not a type.
03:33:10 <dminuoso> jusss: What do you mean "complete the missing (a,b)"
03:33:10 <jusss> dminuoso: and?
03:33:35 <dminuoso> jusss: Do you understand how typeclasses work, at all?
03:33:40 <jusss> dminuoso: make the them equal
03:34:21 <jusss> dminuoso: an instance of a typeclass which it must implement those functions which defined in the typeclass
03:35:27 <jusss> like object and class, every object should have the method which defined in the class
03:35:42 <jusss> but it's polymorphic here in haskell
03:35:54 <jusss> dminuoso: right?
03:36:06 <dminuoso> jusss: Typeclasses have no relationship to objects/classes from traditional OOP languages.
03:36:22 <jusss> I said "like"
03:36:36 <dminuoso> jusss: They are very much different.
03:36:37 <jusss> interface in Java
03:36:45 <dminuoso> jusss: Right, typeclasses are closer to interfaces
03:36:52 <jusss> @abstractmethod in python
03:36:52 <lambdabot> Unknown command, try @list
03:37:19 <dminuoso> jusss: And what we call typeclass instances, is similar to an interface implementation in Java.
03:37:54 <lavalike> remind me an applicative that is not a monad?
03:38:01 <dminuoso> lavalike: ZipList
03:38:06 <dminuoso> lavalike: Haxl
03:38:21 <MarcelineVQ> lavalike: Const, iirc
03:38:31 <jusss> lavalike: applicative f has no >>= function
03:39:20 <dminuoso> MarcelineVQ: Depends. ⌜Const ()⌝ should work, no?
03:39:50 <davean> jusss: the Applicative type has no Monad (>>=) but many things that are Applicative have a Monad (>>=), they were asking for things that were Applicative and could not have a Monad (>>=)
03:40:32 <jusss> davean: you confused me
03:40:38 <dminuoso> lavalike: Ah ignore Haxl, ZipList is always my go-to "not-a-monad" :)
03:40:59 <lavalike> jusss: every monad is applicative, but not every applicative is a monad, looking for examples of the latter
03:41:11 <lavalike> dminuoso: aye
03:41:11 <Taneb> lavalike: Concurrently from the async package
03:41:25 <dminuoso> lavalike: Control.Applicative.Free -- does that count?
03:41:30 <jusss> dminuoso: let's back to ...
03:41:36 * dminuoso chuckles
03:42:47 <jusss> to your tasks, it seems I misunderstand or don't understand what are your tasks...
03:42:56 <jusss> sorry, my English is not good...
03:43:19 <dminuoso> jusss: I recommend you dial it back and take easier excercises. Perhaps approach them later when you have more experience.
03:43:32 <lavalike> Taneb: never seen that before, nice
03:44:34 <jusss> dminuoso: haha, I remember I come here with a monad transformer concepts, and now I have lots of I-don't-know concepts
03:44:58 <jusss> the more I know, the more I don't know
03:45:34 <dminuoso> lavalike: ⌜data P a = Nil | P a a⌝
03:46:08 <[exa]> dminuoso: is there a compose shortcut for the ⌜⌝ brackets?
03:46:26 <dminuoso> [exa]: For me? Yes.
03:46:34 <dminuoso> [exa]: I use XCompose.
03:46:47 <dminuoso> lavalike: Parser from optparse-applicative
03:47:15 <[exa]> dminuoso: so I guess it's not in the default xcompose config?
03:47:33 <dminuoso> [exa]: No idea, I have my own XCompose config. :)
03:48:22 <dminuoso> [exa]: ⊥ ∀ ∃ ≃ ⌜ ⌝ and all the greek letters is what I have
03:49:25 <davean> Why do you do ⌜ ⌝?
03:49:52 <[exa]> dminuoso: anyway what's your shortcut for the brackets? I'm in fact trying to invent a good one :D
03:50:02 <MarcelineVQ> cause it's not confused for code :>
03:50:12 <dminuoso> [exa]: So I use US layout, it made sense to use Capslock and []
03:51:15 <dminuoso> davean: ski introduced it a while ago, and I liked it as an alternative to separate between metalanguage and some other language of interest.
03:52:51 <[exa]> oh ⌜yes⌝
03:53:03 <lavalike> error: Variable not in scope: yes
03:53:47 <[exa]> :'(
03:54:09 <dminuoso> [exa]: My only issue is that with XCompose you cant seem to hold the multikey and then issue multiple sequences.
03:54:28 <dminuoso> You have to release and repress the multikey between two sequence.s
03:55:00 <[exa]> I use it in sequence, multikey -> key -> key, without holding
03:55:20 <[exa]> (I thought that's the standard way)
03:55:26 <davean> MarcelineVQ: how is it not confused for code? Thats a valid Haskell identifier
03:55:38 <dminuoso> [exa]: No I mean: I'd love to press the multikey, hold it, and then press [ followed by ]
03:55:44 <dminuoso> [exa]: And then end up with ⌜⌝
03:55:54 <dminuoso> Such that the multikey acts like a modifier key
03:55:56 <aveltras> anyone having problems with cabal right now ? it can't find warp as a dependency (and other packages too)
03:56:03 <[exa]> davean: lavalike: guys stop :D
03:56:12 <dminuoso> aveltras: Did you run ⌜cabal v2-update⌝ ?
03:56:58 <[exa]> dminuoso: this works for me: <Multi_key> <bracketleft> <bracketright> : "⌜⌝"
03:57:00 <aveltras> i did now, but it's to be used with hie which doesn't support v2 i think
03:57:05 <dminuoso> [exa]: !!!
03:57:17 <dminuoso> [exa]: Oh man. It took me half a year to not arrive at that idea.
03:57:32 <merijn> aveltras: v2-update just updates the package index (just like "update" does)
03:58:08 <dminuoso> [exa]: Thanks for that tip. :)
03:58:28 <[exa]> dminuoso: it would be cool to place the cursor in the middle of those right
03:58:44 <dminuoso> [exa]: You can do that by inserting the appropriate ANSI sequence probably
03:59:29 <[exa]> dminuoso: that's gonna break non-terminal stuff, I recall there was a way even with Xcompose
03:59:47 <merijn> dminuoso: You used v2-run for running executables, right? Have you come up with a convenient workflow to switch between running profiled/unprofiled?
04:00:08 <jusss>  /quit
04:02:24 <dminuoso> merijn: What do you find inconvenient?
04:02:58 <dminuoso> [exa]: I wonder, if not via ANSI sequences - how else could XCompose do it? I mean cursor movement is not something that X understands.
04:03:47 <dminuoso> [exa]: Also, its sad that the solution makes this not trigger: <Multi_key> <bracketleft> : "⌜"
04:04:03 <dminuoso> I mean I could of course use separate keys or add in additional key
04:04:20 <merijn> dminuoso: I use a shell script in my path (with the name of the executable) to easily use tools while I develop them, but then switching to a profiled build requires me editing that script and adding --enable-profiling everywhere, which is rather annoying to do, because then I also need to switch back later. I'm wondering if there's a better approach or if I should just make a profiled version of said 
04:04:26 <merijn> shell script that always passes --enable-profiling
04:04:57 <[exa]> dminuoso: there's something in man XCompose about exact matches
04:05:08 <[exa]> but you're right, cursor won't work
04:07:04 <dminuoso> merijn: Out of convenience, I'd probably have two shell scripts foo and foo-prof
04:09:12 <dminuoso> merijn: or, you could of course have your script accept some "-prof" flag that automatically adds ⌜--enable-profiling⌝ and ⌜-- +RTS ... -RTS⌝ to the invocation of ⌜cabal v2-run⌝
04:09:33 <lavalike> you need other parens for commands!
04:12:16 <dminuoso> lavalike: ⌞--enable-profiling⌟ is that better?
04:12:33 <lavalike> hah yes
04:14:04 <merijn> Honestly, both the kinds of marks are kinda annoying to read >.>
04:14:24 <dminuoso> merijn: Don't worry, soon you can afford better fonts.
04:14:35 <merijn> I dunno how they render for everyone else, but here they look much more annoying than "
04:14:53 <merijn> dminuoso: I already have the perfect font, Monaco is objectively the best monospace font!
04:14:55 <dminuoso> merijn: I find them pleasant to look at in fira :)
04:15:08 <dminuoso> Or wait. No, this is Pragmata Pro.
04:15:57 <dminuoso> merijn: Do you prefer ᚜--enable-profiling᚛ ?
04:16:16 <merijn> That's even worse, because the opening spacing is very large, but the closing spacing is not
04:16:55 <opqdonut> qw/--enable-profiling/
04:17:23 <dminuoso> Or perhaps we should just adopt the QQ syntax - then we can always name the language we are quoting.
04:17:37 <opqdonut> (I guess I meant q//)
04:17:45 <dminuoso> [bash| cabal v2-run --enable-profiling ... ]
04:18:21 <merijn> dminuoso: http://files.inconsistent.nl/irc-quotes.png 
04:18:49 <merijn> As you can see the spacing of that ᚜ ᚛ is godawful
04:19:21 <dminuoso> merijn: interesting, ⌜⌝ really dont appear at the top in your font.
04:19:33 <dminuoso> Bad glyphs Id say
04:20:01 <dminuoso> merijn: So much or your fancy font, Id say.
04:20:11 <dminuoso> merijn: Perhaps Im just spoiled with Pragmata Pro.
04:20:52 <merijn> dminuoso: Assuming any sort of consistent look/rendering of anything out of latin1 seems like an absolutely foolish idea
04:21:35 <yushyin> »foo«
04:21:36 <lavalike> dminuoso: rather narrow!
04:22:05 <merijn> lavalike: Yeah, too narrow for me
04:22:30 <dminuoso> ωαιτ υντιλ ι αβυσε υνιξοδε το ιτσ φυλλεστ εχτενδ
04:22:30 <lavalike> it probably counts as a feature if you want to stack multiple text windows side by side
04:22:59 <dminuoso> lavalike: Indeed, its narrow - but the glyphs are just amazing.
04:23:00 <lavalike> why did fullest use tau but extent delta
04:23:36 <lavalike> dminuoso: I'm warming up to it
04:25:55 <dminuoso> lavalike: Oh heh, my greek letters are mapped to letters. So behind "a" I have "α", behind b there is "β", etc. And I was just typing using the final latin characters in the xcompose sequence
04:26:06 <ullbeking> i learned haskell in the 90's on hugs 98, and liked it very much.  as i was saying yesterday, i haven't used it much since then but i am now re-acquainting myself with it.  at what point in haskell's history, and why, did ghc overtake hugs as the primary interpreterr and/compiler?  is this even a correct thing to say, i.e., is hugs still used much?
04:26:24 <merijn> ullbeking: Hugs is dead
04:26:39 <ullbeking> "i haven't used it much since then" => "it" == Haskell
04:26:48 <ullbeking> merijn: oh :-(
04:26:51 <ullbeking> what happened?
04:26:52 <lavalike> :/
04:26:59 <merijn> ullbeking: GHC is undisputed king, as has been since at least 2008/2009 when I started learning
04:27:10 <lavalike> it must have hugged the wrong person
04:27:12 <ullbeking> merijn: that was 10 years after i learned
04:27:31 <merijn> ullbeking: UHC is still actively worked on, but mostly for their own research, not sure how much of Hackage it supports (it supports Haskell2010 and some GHC extensions at least)
04:27:50 <ullbeking> from i don't know of UHC, i will have a look
04:28:09 <ullbeking> do you folks know of a language called mercury?
04:28:10 <merijn> ullbeking: People considered it easier to try and get their work into GHC and piggyback on all the other work/performance/optimisations was more worthwhile than trying to replicate them
04:28:24 <merijn> I've heard of Mercury, but never looked into it
04:28:51 <ullbeking> merijn: you mean the optimizations were in the interpreter or in the way the haskell code was written?
04:28:57 <merijn> ullbeking: Also, being implemented in C Hugs was obviously more hassle to work on
04:29:35 <ullbeking> and wrt to merucry, it was developed very actively in the university i went to so mercury was a big focus for declarative programming
04:29:55 <ullbeking> merijn: was it badly written c?
04:29:55 <merijn> ullbeking: I mean that if you make your experiment work in GHC, then anyone using your stuff will get that + all the other work on GHC, if you implemented something in Hugs, you wouldn't have the performance your code would have had in GHC
04:30:06 <ullbeking> merijn: i see
04:30:13 <merijn> ullbeking: I don't know, tbh, I've never really looked into Hugs
04:30:20 <ullbeking> sure
04:30:34 <ullbeking> it's very old, way before you even learned ghc
04:30:55 <ullbeking> i'm just curious about it becuase it would have been the first then i went off to try to find otherwise ;-)
04:32:05 <ullbeking> what about miranda?  is that still being used?
04:32:29 <merijn> It depends on how you define "being used" :)
04:39:53 <fog> i thought the stack build of haskoin-core had succeeded but when i try "stack ghci" in the directory obtained via stack unpack it throws an error
04:39:53 <ullbeking> merijn: my favorite book on fp is bird+wadler's "introduction to functional programming", 1st ed.  the 2nd ed. was great, and it was called "intro to fp using haskell", but it lost a LOT of the charm of the 1st edition, for some reason.  the 1st edition used miranda and it was extremely readable even with a passing knowledge of haskell.
04:41:27 <fog> it says; ghc.exe: unable to load package `secp256k1-haskell-0.1.4' unknown symbol `secp256k1_ecdsa_verify'
04:41:43 <fog> how can it claim to have succeded in the build and then fail to work
04:43:32 <merijn> fog: Which platform?
04:43:50 <fog> windows using the mingw64 provided by stack
04:44:11 <merijn> fog: I can think of lots of reasons why things would fail and indeed "windows" is one of them ;)
04:44:29 <merijn> fog: It looks like it's trying to load compiled object code into GHCi
04:44:58 <fog> if i try in a different directory it cant see the stack build of haskoin-core
04:45:26 <merijn> fog: I know there's quite some oddities with both the linking involve in dynamically loading compiled code from ghci AND I know there are (or at least used to be until very recently) oddities in how linking works on Windows
04:45:44 <fog> i tried stack ghci --package haskoin-core, and stack ghci --package secp256k1-haskell-0.1.4, neither of which work
04:45:52 <cinimod> I am doing cabal install cabal-install but get * Missing (or bad) header file: zlib.h
04:46:12 <cinimod> I have done sudo apt-get install libz-dev
04:46:15 <merijn> cinimod: You, apparently, do not have zlib installed? :)
04:46:33 <merijn> cinimod: Do you have pkg-config on your system? If yes, does it list zlib?
04:46:55 <cinimod> No but I can install it
04:47:04 <cinimod> I am trying to debug a nix problem lol
04:47:40 <cocreature> It sounds like you don’t have zlib in your nix shell
04:47:55 <cinimod> I am not in a nix shell
04:48:15 <cocreature> So how is this is a nix problem?
04:48:47 <cinimod> I was using a nix shell `nix-shell -p cabal-install pkg-config liblapack darcs gfortran`
04:49:04 <cocreature> So are you in a nix-shell or not? I’m confused
04:49:11 <cinimod> and trying to `cabal new-test` a package
04:49:32 <cinimod> I am not now but I was when I hit a problem so I thought I would use vanilla ubuntu
04:50:02 <cinimod> I also stupidly asked what I thought was a simple problem just as I am about to go and catch my train
04:51:40 <cinimod> pkg-config --list-all -> zlib               zlib - zlib compression library
04:51:42 <fog> hmm, i was only using stack to try and get an old package to build (which didnt work) i guess ill try cabal
04:52:16 <cinimod> So I do have zlib installed
04:53:17 <fog> libsecp256k1    libsecp256k1 - Optimized C library for EC operations on curve secp256k1
04:53:24 <cocreature> cinimod: I wonder if the environment from the nix-shell might have persisted in some way in cabal’s cache. Did you "cabal new-clean" after leaving the nix-shell?
04:53:24 <cinimod> Any other suggestions?
04:54:27 <cinimod> I can't do new-clean as apt installs an old version so I was doing cabal install cabal-install to get a new version
04:54:46 * cinimod has to run for train
04:54:58 <Ariakenom> ullbeking: i've heard ski talk about mercury a bunch around here
04:55:11 <cocreature> cinimod: you can recent versions of cabal and ghc from True
04:55:23 <cocreature> cinimod: eh https://launchpad.net/~hvr/+archive/ubuntu/ghc, copy paste is hard
04:57:40 <ullbeking> thank you Ariakenom.  i will ping ski next time i see them here, if i remember :-)
05:00:22 <fog> maybe its something to do with the lib not being in the path?
05:00:58 <fog> but if pkg-config can see it...
05:02:17 <fog> would it still list it if "make" or "make install" failed?
05:05:53 <dminuoso> So at times, Im tempted to intentionally use bottom inside a field that needs to be initialized later. This is just in 1-2 edge cases where the entire code is under my control.
05:06:24 <dminuoso> The effort of rewriting this into 2 data types would require tremendous effort without much gains, it seems. Do people do this?
05:06:59 <tdammers> I don't, but it makes me wish for anonymous extensible record types
05:07:07 <merijn> dminuoso: Or just take 1-2 arguments and return a fully filled out record? :p
05:07:25 <dminuoso> merijn: Wont fit
05:07:31 <merijn> dminuoso: How so?
05:13:11 <vunguyenhung> hello
05:19:24 <dminuoso> merijn: So one example I have, is that I have this large ⌜data Foo = Foo { ..., userDb :: UserDb }⌝, where that userDb is a Map with some crypto sprinkled over it.
05:20:27 <dminuoso> merijn: Right now, that UserDb is constructed from my optparse-applicative parser, but for tests I dont want to rely on an external file. So of course I could create a huge smart constructor that is essentially Foo, except taking a UserDb it takes some [(String, String)]
05:20:44 <dminuoso> merijn: But I dont want to write a function taking 20 arguments because its just a recipe for screwing things up.
05:21:36 <higherorder> Hello! Quick question: would you say it is useful/desirable to track bounds for text at the type level in Haskell? e.g. using a type `Sized m n Text`, with two phantom parameters trakcing the bounds, e.g. `Sized 1 50 Text`
05:21:49 <dminuoso> merijn: It's easier to just construct some ⌜f = Foo { ...; userDb = undefined }⌝ and push it through some "initDb" function - for the single and sole purpose of tests.
05:22:12 <dminuoso> higherorder: Possibly, yes!
05:27:51 <higherorder> dminuoso: possibly? :P
05:29:09 <dminuoso> higherorder: Yes. It leads to the usual quirks of trying to mimic dependent type systems.
05:29:29 <dminuoso> higherorder: It kind of depends on what you intend to do with it, and why you want to keep it at the type level.
05:29:41 <Phyx-> fog: because building and linking are two different things
05:30:32 <Phyx-> fog: that seems like you have a missing native dependency
05:31:00 <ski> dmwit : ty
05:32:51 <Phyx-> fog: does your project contain the appropriate extra-libraries: entry or whatever the stack equivalent is
05:35:10 <AWizzArd> I have a file Types.hs, in which I wanted to collect all kinds of… types. Now however I have an import circle, because I need in my Logger module the AppT type (this one is in Types.hs), for which I want to implement an instance of MonadLogger.
05:35:21 <AWizzArd> How typical is it to have instance implementations inside a Types.hs file?
05:37:04 <dminuoso> AWizzArd: Here's some tricks I use to break import cycles: Writing code in specific locations to use mtl-style typeclasses rather than concrete types. Splitting off modules, joining modules.
05:37:23 <dminuoso> That first one is arguably a nasty hack, but if it's an isolated incident, it can work reasonably work.
05:39:07 <dminuoso> AWizzArd: Why does your Logger module need to know about AppT?
05:46:48 <AWizzArd> dminuoso: instance MonadIO m => MonadLogger (AppT m) where
05:49:55 <AWizzArd> dminuoso: And I thought that a good place for this implementation could be the Logger.hs file.
05:50:24 <AWizzArd> dminuoso: I can resolve the circle by moving the type LoggerEnv into Types.hs though. So, nothing is lost (:
05:55:23 <dminuoso> AWizzArd: What is LoggerEnv?
05:58:49 <dminuoso> AWizzArd: Its hard to say without seeing your modules.
06:00:10 <fog> how is it that i cant do big-int multiplication on windows!?
06:01:08 <fog> this is ridiculous. the choices remaining are; abandon project, write it out by hand
06:03:15 <EvanR> i had to scroll up a ways to get enough context to see that fog's complain wasn't totally off
06:03:18 <fog> i dont need to use linux to cross compile secp2561k to windows, i can run openssl on windows without bother. the bitcoin-core team have expressly placed a warning against use of this unstable library in its deployment, i dont see why the haskoin-core developers have opted for it over more stable libraries
06:03:29 <EvanR> Integer does work on windows
06:05:01 <fog> EvanR: search for "instance Fractional (BigWord ModP) where" in http://hackage.haskell.org/package/haskoin-0.1.0.2/src/Network/Haskoin/Crypto/BigWord.hs
06:06:02 <fog> looks like the only way to get a windows build is to find a complete FFI wrapper around openSSL or to hack out this part of that code
06:06:37 <EvanR> what wild goose chase are you sending me on?
06:06:40 <fog> i cant get that library to build using any stack things
06:07:05 <fog> EvanR: its bigint not just plain Integer like you said
06:07:32 <fog> idk, maybe there is a better bigint library ill check
06:07:36 <EvanR> i have no doubt that your build-fu needs to be 1 or 2 orders of magnitude greater to survive on windows
06:07:50 <EvanR> which suggests to me that you fog should not be on windows
06:08:26 <fog> the entire point is to get something which builds on windows with no fuss!
06:09:06 <EvanR> contact the maintainer about that entire point then
06:09:17 <fog> if i hack the relavent big int fractional instace i can do the simple eliptic curve multiplication and bundle in in a repo that will build on windows with simple cabal install
06:09:55 <EvanR> that sounds terrible
06:10:03 <fog> EvanR: sorry for my frustration. perhaps the calm way to ask is, does anyone know of a bigint library that i could use instead of trying to gut this ancient package?
06:13:24 <__monty__> fog: To clear up EvanR's first comment Integer *is* an infinite precision integer.
06:13:26 <merijn> fog: What's wrong with Integer for multiplying big ints?
06:13:46 <fog> or how to call "openssl ec" from a FFI binding?
06:14:07 <merijn> > 1337^1337
06:14:11 <lambdabot>  4342016897902897469403500760137597113653058229257224877226895823934931297349...
06:14:13 <fog> monty, merijn: oh ok
06:14:18 <merijn> Seems fine?
06:14:44 <fog> oh so the fractional instance works as part of base... nice
06:14:49 <merijn> fog: Integer is just libgmp underneath
06:15:11 <fog> well i guess that makes it seem like the hacking way seems less difficult
06:15:35 <merijn> fog: In fact, GHC has one of the crazy fastest libgmp bindings of any language ;) http://www.wilfred.me.uk/blog/2014/10/20/the-fastest-bigint-in-the-west/
06:16:35 <fog> heres what i have so far... https://pastebin.com/rfzrcX1Y
06:17:03 <fog> it needed to build the haskoin dependency to get at their bigints.. so maybe i can easily do just using Integer
06:18:10 <fog> what? haskell is the fastest!?
06:18:13 <fog> awesome!
06:19:41 <__monty__> Though I guess there *is* integer-simple. So don't rely on Integer if you might run into licensing trouble : )
06:19:59 <fog> argh, witout being able to build haskoin i cant check to see if my implementation would work
06:20:04 <fog> ok fine, to linux
06:20:53 <fog> just to check, i just use Integer everywhere they use their bigword and everything sould just work?
06:21:14 <mniip> is there a comonad that is a mix between NonEmpty and Store Int
06:21:32 <mniip> I basically want a nonempty list with a highlighted element, but it doesn't have the be the first
06:22:00 <__monty__> Sounds like a zipper?
06:22:07 <fog> dont you just want Z+ which is like Nat - {0} instead of Int for the Store key?
06:22:38 <fog> you could just use Nonempty ()
06:22:53 <__monty__> Maybe I'm confusing zippers and cursors?
06:23:47 <fog> its more like a zipper with an unevaluated navigation you can edit without having to navigate the zipper
06:24:36 <dminuoso> mniip: Sounds like regular ComonadStore interface of NonEmpty
06:26:03 <mniip> but extract = head
06:26:25 <mniip> I don't see NonEmpty having a ComonadStore
06:26:42 <mniip> I like the idea of Zipper NonEmpty, but its ComonadStore Int instance seems unsafe
06:28:11 <dminuoso> mniip: extract = head, but what you are asking for is pos, rather than heda.
06:28:39 <mniip> no
06:28:49 <mniip> I'm asking about extract exactly
06:29:25 <mniip> in a ComonadStore, extract x = peek (pos x) x
06:29:37 <mniip> meaning pos would have to be 0
06:29:45 <mniip> meaning you can't implement seek
06:33:10 <dminuoso> mniip: Yeah but.. what's wrong with ⌜Store Int⌝ (or Store Nat if you prefer)?
06:33:24 <mniip> because finite list
06:33:31 <dminuoso> Ah
06:35:58 <__monty__> Clearly what we need here is Fin, where's dependent types when we need them : )
06:40:14 <fog> but head would always work?
06:40:44 <AWizzArd> Interesting. I see my first case where I import ():   import Logger ()     - its effect is to make instance implementations available.
06:40:56 <fog> why cant you just use "type ZPlus = Nonempty ()" instead of Int? 
06:41:17 <fog> like, its the list version that wouldnt have extract
06:42:19 <dminuoso> fog: Yeah but if you have a ⌜Store Int⌝ tacked onto a finite NonEmpty, then you can force empty by just seek/peeking out of bounds
06:42:23 <fog> or do you mean like `() |: []' is more like 1 than 0 so you think that set . get would shift it by one index
06:42:26 <dminuoso> *force bottom
06:43:36 <fog> as in how head is the same as !! 0 not !! 1
06:44:29 <fog> i guess then you would have to think of () :| [] as 0
06:45:03 <fog> which makes sense as its like length - 1
06:47:11 <fog> these was a library about that i was trying to make but i had to do some stuff with noisy quantum channels
06:47:52 <fog> maybe one day we will have approximate message passing on loopy graphs!
06:48:24 <fog> could probably use TVars or something, might be simpler...
07:03:47 <fog> whats the abstract interface for parallel/concurrent communication between variables anyway?
07:04:06 <fog> is there one abstraction that could capture eg conduit and mutable varibles?
07:04:39 <fog> like, if i wanted to set up a backpack for benchmarking
07:06:51 <fog> i know the MPI folks like to set up coms on a circle of nodes
07:07:08 <fog> maybe with a scatter & gather...
07:07:48 <fog> but i have never used mutable variables so i dont know if thats basically the extent of thier functionality
07:08:11 <fog> basically just assuming they are equivalent to a distributed cluster of servers
07:08:30 <fog> like, with listen and respond...
07:08:45 <fog> there must be a standard thought right?
07:09:42 <fog> maybe they are called factor graphs or petri nets or something
07:10:08 <cinimod> cocreature: I am on my train now with wifi :) I can install a modern version of cabal with nix itself - it's disappointing I couldn't go apt and cabal install though
07:10:14 <fog> i remember some comparison with actor models with haskell MVars being much faster...
07:10:59 <fog> cinimod: cant you just do stack install cabal-install ?
07:11:12 <fog> idk about nix sorry
07:11:43 <mniip> gdi
07:11:47 <mniip> comonad-extras not in stack
07:13:54 <cinimod> fog: probably
07:14:22 * cinimod wonders why so much ad-hocery is necessary
07:14:37 <fog> i guess actor models are a bit much because they have sctors being able to create new actors etc, but maybe there is a limited version of this which is basically like conduit servers which can be equivalent to TVars
07:16:23 <fog> probably should just read simon marlows book... probably should get back to trying to build these c libraries...
07:18:23 <Axman6> fog: as much as I have no idea what you're on about, it sounds like you might be interested in propogators: https://www.youtube.com/watch?v=DyPzPeOPgUE
07:18:40 <Axman6> and yes you should definitely read Simon's book
07:34:30 <Phyx-> 14:05:40 < fog> looks like the only way to get a windows build is to find a complete FFI wrapper around openSSL or to hack out this part of that code <-- no you don't
07:34:38 <Phyx-> but you're not explaining what you're doing
07:34:50 <Phyx-> saying you're doing "stack ghci" is not very helpful
07:35:28 <Phyx-> you're getting a linker error because you didn't give it a dependency or you gave it the wrong version of the dependency. 
07:35:44 <Phyx-> but in either case, if you want help, I need more than "stack ghci" 
07:38:22 <cinimod> cabal: parsing output of pkg-config --modversion failed
07:38:33 <cinimod> I've never seen that before
07:40:21 --- mode: ChanServ set +o monochrom
07:40:44 --- mode: monochrom set +b *!*@185.204.212.*
07:40:55 --- mode: monochrom set -o monochrom
07:50:40 <jumper149> I want to derive an instance of a class after declaring an instance of a superclass manually
07:50:50 <jumper149> In particular: https://github.com/jumper149/go/tree/master/src/Board
07:51:04 <jumper149> In Default I define instances for Board and Game
07:51:39 <jumper149> and want to derive Game after manually creating a Game instance for BoardLoop
07:51:45 <merijn> jumper149: So what's the problem?
07:51:58 <fendor> can I query for global cabal configs? e.g. path to extra-prog-path?
07:53:00 <jumper149> merijn: If you look into Loop.hs you can see I hardcoded some hardcoded some methods for the Board instance
07:53:05 <merijn> jumper149: Unrelatedly: Are you sure you want Board/Game/TermGame classes? It seems unlikely you'd want classes here
07:54:31 <jumper149> merijn: Well I want to be able allow other Boards (like Loop) and still apply the same functions over the methods defined in the classes
07:55:15 <jumper149> The game class allows to use other sets of players (currently only PlayerBW)
07:56:19 <jumper149> The TermGame has superclasses (Show board, Show player) and will have something like `Read coord` in the future
07:58:10 <AWizzArd> Is there a way to resolve env vars in a .stack file?
08:05:17 <jumper149> merijn: I can define the Game-instances sort of trivially, I was just wondering if there is a way to automatically derive it
08:05:32 <jumper149> This is what I mean in particular: http://ix.io/1SPp
08:14:19 <dmwit> jumper149: If you make BoardLoop a newtype instead of data, it's possible GeneralizedNewtypeDeriving will get you where you need to go.
08:14:50 <dmwit> jumper149: {-# language GeneralizedNewtypeDeriving, StandaloneDeriving #-}; newtype BoardLoop = BLoop BoardSquare; deriving instance Game BoardLoop CoordXY PlayerBW
08:15:06 <dmwit> I didn't test it, though; perhaps MPTCs make GND harder.
08:15:49 <jumper149> dmwit: Did you notice that the Board-instance is not derived, but it is a superclass of Game?
08:16:41 <dmwit> No. But I don't think it changes my answer. What makes you think it should?
08:20:36 <jumper149> I'm not sure but with the newtype deriving it looks like the Board-instance will also get derived, am I wrong?
08:21:35 <jumper149> I want to make changes to the Board instance, but not the Game instance
08:22:33 <augusta> Hey Guys, Check this out http://augusta.cf
08:22:38 <dmwit> Why would the Board instance also get derived?
08:22:44 --- mode: ChanServ set +o dmwit
08:23:05 --- kick: augusta was kicked by dmwit (augusta)
08:24:01 --- mode: dmwit set +b *!*@45.116.113.113
08:24:06 --- mode: dmwit set -o dmwit
08:24:13 <tsizz> hello
08:24:33 <tsizz> i was wondering if i could get help with this hw assignment. its from a while ago, so i forgot a bit of haskell D:
08:25:07 <jumper149> dmwit: I thought deriving might be done before defining instances manually but that is probably wrong. I mean Haskell is lazy after all^^
08:25:26 <dmwit> What is this "before"?
08:26:26 <dminuoso> tsizz: Just ask away
08:26:28 <dmwit> tsizz: If you ask a good question, where you show us what efforts you have made and talk about why you believe you are stuck, we will help you get over your current hump. Then of course it will be back on you to make further progress once you're unstuck.
08:27:22 <jumper149> Not sure. Everything is handled at compile-time anyways
08:27:39 <jumper149> or is it?
08:27:47 <dmwit> Certainly not everything.
08:28:05 <dmwit> But definition order (including instance definition order) generally doesn't matter until you start using Template Haskell.
08:28:23 <tsizz> so i have a function [a] -> [[a]]. first list of output is the whole input list, then the second list in the output should containevery second element from the input list, and the nth list in the output should contain every nth element from the input list.
08:28:23 <dmwit> I mean, the order things appear in your file doesn't matter.
08:28:27 <jumper149> ok
08:28:33 <dminuoso> Or insane and dangerous extensions like IncoherentInstances or OverlappingIntsances..
08:28:37 <tsizz> i just don't know how to start really
08:29:04 <jumper149> I will definetely check out DNG later today, but I gotta go now
08:29:12 <dmwit> tsizz: Can you write the easier function of type Int -> [a] -> [a] which when applied to n and a list returns every nth element of xs?
08:29:13 <jumper149> dmwit: thank you for helping :)
08:29:17 <dmwit> -xs +the list
08:29:37 <tsizz> dmwit hm okay i just read that idea on stackoverflow. will try it out
08:29:43 <tsizz> then just map with that function
08:33:09 <dminuoso> optparse-applicative error: option -d: cannot parse value `:memory:'  -- https://gist.github.com/dminuoso/7476be9e8d95af6db056d775a9caa55a
08:33:39 <dminuoso> Im just passing "-d :memory:" - Ive been staring at this for so long, I dont get it.
08:34:17 <merijn> dminuoso: Oh!
08:34:20 <merijn> dminuoso: I know!
08:34:26 <merijn> dminuoso: Took me ages when I ran into this
08:34:45 <merijn> dminuoso: You want to s/option/strOption :)
08:34:54 <merijn> dminuoso: option uses auto, which uses read
08:35:01 <dminuoso> merijn: Oh my. Oh my. Wow.
08:35:05 <merijn> Which means...quotes!
08:35:22 <merijn> > read "foo" :: String
08:35:26 <lambdabot>  "*Exception: Prelude.read: no parse
08:35:28 <merijn> > read "\"foo\"" :: String
08:35:29 <dminuoso> Gotcha, yeah.
08:35:33 <lambdabot>  "foo"
08:35:52 <dminuoso> merijn: Thanks, this has cost me about 30 minutes of staring in disbelief.
08:36:04 <merijn> I feel your pain :)
08:50:22 <dminuoso> QuickCheck question, is there a way to embed a ⌜Property⌝ inside some ⌜PropertyM IO α⌝ ?
08:50:39 <tsizz>  @dmwit what i have so fargetEveryNth n lst   | n > 0 = (take n lst)   | otherwise = error "Pick positive n"
08:50:47 <phaazon> aaaaaaaaaand done
08:50:48 <dminuoso> Concretely, I want to use (===) inside my monadicIO
08:50:51 <phaazon> after 160+ errors
08:50:57 <tsizz> sorry that was bad format
08:51:03 <phaazon> luminance now compiles with #![deny(missing_docs)]
08:51:05 * phaazon :3
08:51:20 <phaazon> and no, I didn’t put /// TODO everywhere
08:51:22 <phaazon> :D
08:53:54 <Taneb> phaazon: well done!
08:54:11 <phaazon> and I also didn’t mean to say that on that channel :D
08:54:15 <phaazon> but thanks :D
08:54:47 <Taneb> I thought the syntax seemed a bit rusty
08:57:19 <phaazon> it is :)
08:59:46 <xenon-> hi. is there a library similar to selenium that doesn't depend on external third party programs?
09:01:19 <xenon-> is this worth a look? it isn't on hackage unfortunately. https://github.com/GoogleChrome/puppeteer   
09:02:09 <ddellacosta> can anyone tell me what Conor McBride means by "vectorization" in his first question here? https://stackoverflow.com/a/10242673
09:02:42 <stevejb> Hello, I have a somewhat memory / CPU intensive simulation that I wrote, which I would like to have a colleague run on their computer. They run Windows, so I shipped shipped them a Docker container made with `stack image container`.  However, the program seems to just stop about halfway through. No errors or anything like that. I am not sure how to
09:02:43 <stevejb>  diagnose what is going on.
09:03:32 <xenon->  /join ##woodworking
09:03:35 <xenon-> ops
09:03:36 <xenon-> :)
09:03:49 <heatsink> dellacosta: I think he's making an analogy to vector instructions.  The majority of vector instructions perform the same operation independently on all elements of an array
09:03:53 <AWizzArd> How can I import the implementation for (<>) from Data.Text?
09:04:17 <heatsink> import Data.Text((<>))
09:04:20 <heatsink> note the extra parentheses
09:04:46 <ddellacosta> heatsink: I see, thanks!
09:05:03 <AWizzArd> heatsink: ah okay yes, that extra layer of parens. Thx!
09:06:00 <tsizz> um how come this line doesnt work in prelude? take 2 [2,3,4] : drop 2 [2,3,4]
09:06:23 <dminuoso> Or am I not supposed to put Property into PropertyM? :/
09:06:27 <heatsink> stevejb: To start with, I would check the system monitor and see whether that process is using CPU, paging memory, or suspended
09:06:47 <xenon-> tsizz, types don't match
09:06:51 <xenon-> :t (:)
09:06:54 <lambdabot> a -> [a] -> [a]
09:06:56 <xenon-> you want ++
09:07:00 <xenon-> :t (++)
09:07:02 <lambdabot> [a] -> [a] -> [a]
09:07:07 <dminuoso> Things like assert seem to be highly annoying to use, because they dont print counterexamples.
09:07:32 <tsizz> xenon- hm okay i dont really understand what is happening
09:07:44 <lavalike> tsizz: take returns a list, : takes an element as its first argument
09:07:50 <stevejb> heatsink ok thank you will check
09:08:08 <xenon-> tsizz, do you understand why [1,2] : [3,4] doesn't work?
09:09:05 <tsizz> xenon- no i need a refresher :(
09:09:27 <tsizz> there are pair data strcutre?
09:12:54 <tsizz> ok i think i remember cons as pairs basically (:)
09:13:07 <tsizz> so how come [1,2] :  [3,4] doesn't work?
09:13:08 <lavalike> :t (:)
09:13:10 <lambdabot> a -> [a] -> [a]
09:13:18 <lavalike> you see, it gets a single elements, and a list of elements, and produces a new list
09:13:28 <lavalike> *a single element
09:13:31 <tsizz> ahhh
09:13:40 <tsizz> so it has to be ONE ELEMENT: [any list]
09:13:49 <tsizz> ?
09:14:58 <heatsink> the item on the left must have the same type as the items in the list.  You can have a list of lists
09:14:59 <heatsink> > [1, 2] : [[3]], [[4]]
09:15:01 <turab> More precisely, (element of type A) : (list containing elements of type A)
09:15:04 <lambdabot>  <hint>:1:15: error: parse error on input ‘,’
09:15:20 <heatsink> > [1, 2] : [[3], [4]]
09:15:26 <lambdabot>  mueval-core: Time limit exceeded
09:15:30 <heatsink> what
09:15:37 <heatsink> > [1, 2] : [[3], [4]]
09:15:38 <turab> lol
09:15:41 <lambdabot>  [[1,2],[3],[4]]
09:15:46 <dminuoso> turab: Here's a more verbose but fully equivalent definition of []: data List a = Cons a (List a) | Nil
09:15:50 <dminuoso> Err, tsizz ^-
09:16:05 <dminuoso> tsizz: Here Cons takes the role of (:) and Nil takes the role of [].
09:16:32 * nil = []
09:17:07 <tsizz> hm okay. makes more sense with what im doing now 
09:17:10 <dminuoso> So a list [1,2,3,4] would be represented: Cons 1 (Cons 2 (Cons 3 Nil)), or using infix notation: 1 `Cons` (2 `Cons` (3 `Cons` Nil))
09:17:25 <dminuoso> Ops, that'd be for [1,2,3] of course. :)
09:17:33 <tsizz> i understand that well ^
09:17:39 <tsizz> list of lists gets a little confusing to me
09:17:53 <dminuoso> tsizz: It's no different. :)
09:17:56 <tsizz> [[1,2],[3],[4]] != [1,2,3,4] at all right
09:18:02 <tsizz> completely different?
09:18:03 <dminuoso> tsizz: Right!
09:18:17 <dminuoso> tsizz: Almost completely, yes.
09:18:38 <dminuoso> tsizz: Im saying almost, because you can sort of "flatten" the former into the latter using a function called "join"
09:18:53 <dminuoso> tsizz: But beyond that, they are completely different.
09:20:08 <tsizz> ok thanks!
09:20:23 <tsizz> just fyi i am trying to understand this implementation of getting everyNth element of a list 
09:20:24 <tsizz> https://stackoverflow.com/questions/12876384/grouping-a-list-into-lists-of-n-elements-in-haskell
09:21:17 <lavalike> finally something to golf >:)
09:22:03 <tsizz> im so confused bc it seems to me that the : won't work in that implementation o.O
09:22:04 <lavalike> dang they already give the unfoldr version that's the one I like
09:22:42 <lavalike> there's a big difference there, you wanted to do take xs : drop xs, they do something else with the result of dropping
09:22:59 <lavalike> they feed it to group n again, which returns [[a]]
09:23:01 <tsizz> i am trying the example on "hello!"
09:23:11 <tsizz> trying out n = 2
09:23:29 <lavalike> am I right you're looking at Mihai Maruseac's answer?
09:23:53 <tsizz> so i get [h,e] : ([l,l] : [o,!]) 
09:23:59 <tsizz> lavalike correct
09:24:04 <lavalike> ok, the point is you don't
09:24:46 <tsizz> HM?
09:24:49 <tsizz> hm?*
09:24:50 <lavalike> you get ['h','e'] : group 2 "llo", which gets you ['h','e'] : (['l','l'] : group 2 "o")
09:25:21 <lavalike> happily every element of the cons list is of the same type
09:25:57 <lavalike> then in turn it becomes ['h','e'] : (['l','l'] : (['o'] : group 2 []))
09:26:09 <lavalike> which ends up as ['h','e'] : (['l','l'] : (['o'] : []))
09:26:29 <lavalike> which is a different way of writing [['h','e'], ['l','l'], ['o']]
09:26:39 <lavalike> or ["he","ll","o"] if you want
09:27:15 <lavalike> just take care of substituting with the actual definition, without skipping steps
09:30:30 <tsizz> lavalike ok got it thanks a lot for that explaination
09:31:14 <lavalike> np!
09:31:25 <tsizz> oh gosh how do i test this now lol
09:32:02 <tsizz> ghci the file then the function is availble to test in prelude?
09:32:03 <tsizz> i think lol
09:34:02 <dminuoso> Im starting to wonder whether anyone actually uses monadicIO with QuickCheck, the interface seems very cumbersome. :(
09:35:05 <dminuoso> Wish that ⌜assert :: Testable a => Monad m => a -> PropertyM m ()⌝ :(
09:51:12 * hackage quickspec 2.1.2 - Equational laws for free!  https://hackage.haskell.org/package/quickspec-2.1.2 (NickSmallbone)
10:00:40 <tsizz> lavalike any chance you could help me. im confused how to map this getEveryNth function now :(
10:01:24 <tsizz> oh wait i found this map (\n -> everyNth n xs)
10:01:27 <dminuoso> I totally read that as "quickspec - Emotional laws for free!"
10:01:38 <tsizz> \n?
10:03:16 <dminuoso> Gah, impredicativity. Start working.
10:04:20 <freeman[w]_> which is the best parser combinator library? only bad answers please, with explanation as to why if possible
10:05:18 <dminuoso> freeman[w]_: trifecta because reasons.
10:05:30 <dminuoso> (You did ask for bad answers, did you not?)
10:07:31 <freeman[w]_> dminuoso, what about megaparsec? seems like people are saying it has good error messages, good tutorials and it is actively maintained
10:11:55 <aoeu256> Hey guys.  I just had an ahah moment... you know how f a is f $ a... what if...
10:12:12 <aoeu256> f a was actually f =<< a
10:12:18 <__monty__> freeman[w]_: Megaparsec, trifecta, attoparsec, they're all well-liked. Also, Parsec still because it's in base.
10:12:31 <aoeu256> f a = f =<< a *
10:12:57 <freeman[w]_> __monty__, "which is the best parser combinator library" emphasis on BEST. Pick your own meaning of BEST though :p
10:13:05 <dminuoso> aoeu256: In some sense that is what traditional languages imperative actually do.
10:13:12 <dminuoso> *traditional imperative languages
10:13:27 <__monty__> freeman[w]_: I refuse to answer the question because it doesn't make sense to me.
10:14:04 <aoeu256> dminuoso: but you can always use $ if you only want functions hmm maybe i need to think more
10:14:09 <freeman[w]_> __monty__, I appreciate that you are being honest. It makes perfect sense to me though
10:14:21 <EvanR> traditional imperative language has unsafePerformIO around every expression
10:14:39 <dminuoso> EvanR: Or you could think of function application actually being sort of >>= :P
10:14:46 <EvanR> that too
10:15:04 <freeman[w]_> is there any library for accessing and updating stack.yaml files? same question for .cabal files
10:15:07 <dminuoso> Or rather, they'd call it "function calling"
10:15:23 <dminuoso> freeman[w]_: Any yaml library? :)
10:15:48 <EvanR> f(x,y) = unsafePerformIO f =<< (unsafePerformIO x, unsafePerformIO y)
10:16:01 <freeman[w]_> dminuoso, I would prefer a library that offers its own custom data types specific to the formats being read
10:16:20 <freeman[w]_> I think this maybe: http://hackage.haskell.org/package/stack-yaml
10:16:25 <MarcelineVQ> EvanR: don't forget to inlcude strict evaluation
10:16:32 <dminuoso> freeman[w]_: Well hpack implements that, sort of.
10:16:36 <aoeu256> evanR: yeah f =<< a isn't the same as f(a) in imperative languages
10:17:08 <dminuoso> aoeu256: So I think the benefits of using juxtaposition is because function application occurs way more often than bind.
10:17:10 <tsizz> how do i get map to take a function with 2 parameters?
10:17:14 <freeman[w]_> dminuoso, but does hpack expose the capability to use that? eg. read a stack.yaml and operate on its structure?
10:17:40 <dminuoso> freeman[w]_: Yes.
10:17:44 <dminuoso> freeman[w]_: https://hackage.haskell.org/package/hpack
10:17:50 <EvanR> MarcelineVQ: i can't think of a good way lol
10:18:02 <EvanR> -XTerrible
10:18:04 <MarcelineVQ> dminuoso: a stack.yaml ?
10:18:08 <freeman[w]_> dminuoso, are there any hpack examples of how to do that?
10:18:29 <dminuoso> MarcelineVQ: Oh. Heh. I see your point!
10:18:41 <dminuoso> MarcelineVQ: Im not a stack user, and I kept thinking stack.yaml was package.yaml :)
10:18:49 <MarcelineVQ> ah no
10:19:16 <MarcelineVQ> stack.yaml is more akin to the .project file, iiuc
10:19:33 <MarcelineVQ> whereas package.yaml is more related to the .cabal
10:19:34 <freeman[w]_> dminuoso, looking at this: https://github.com/phlummox/stack-yaml/blob/master/src/Data/Stack/Yaml.hs it seems to give correct stack.yaml data structures, but I do not think it is complete
10:19:46 <dminuoso> tsizz: That's what Applicative is.
10:19:57 <tsizz> ?
10:20:04 <dminuoso> tsizz: Functor works with functions taking 1-argument, Applicative generalizes this to n-arguments (0, 1, 2, etc...)
10:20:09 <freeman[w]_> oh... so hpack can't parse the stack.yaml then?
10:20:53 <MarcelineVQ> it shouldn't be able to no. Why not use stack to read stack files? it's implemented in haskell
10:21:06 <tsizz> i dont think we learned that :O
10:21:32 <freeman[w]_> MarcelineVQ, but does the stack package expose a way to do that? do you have any example?
10:21:40 <dminuoso> tsizz: What exactly are you trying to do? What line of thought provoked your question "how do i get map to take a function with 2 parameters?"?
10:21:52 <MarcelineVQ> I don't, you'll have to explore it
10:22:01 <tsizz> dminuoso https://codereview.stackexchange.com/questions/85095/upenn-homework-3-skips-function
10:22:05 <tsizz> trying to understand/ do the second answer
10:22:05 <freeman[w]_> MarcelineVQ, ah, ok. Anyway, it is a good advice
10:22:12 <freeman[w]_> @karma+ MarcelineVQ 
10:22:12 <lambdabot> MarcelineVQ's karma raised to -8764.
10:22:42 <tsizz> specfically im on the second part of the second answer*
10:22:51 <tsizz> but im confused by the map part..
10:23:20 <freeman[w]_> MarcelineVQ, is this what you meant for me to use? http://hackage.haskell.org/package/stack-lib
10:23:43 <dminuoso> tsizz: I advise you to not use stackexchange to do your homework.
10:24:10 <dminuoso> tsizz: There's little benefit in terms of gaining understanding and developing skills.
10:24:16 <MarcelineVQ> no I mean stack itself, or whatever stack uses https://hackage.haskell.org/package/stack but if that package seems like it'll work go for it, it doesn't seem as up to date though
10:24:46 <MarcelineVQ> *stack itself, but as a library
10:25:05 <freeman[w]_> dminuoso, he is just asking for advice on something he already written. What is wrong with that? (っ °Д °;)っ
10:26:26 <freeman[w]_> MarcelineVQ, ah, so stack itself exposes itself as a library that can be used also?
10:27:36 <freeman[w]_> anyway, I think one of these 3 methods should work
10:27:38 <MarcelineVQ> it does, with the caveat that they don't make gurantees about its api consistency between versions
10:27:49 <freeman[w]_> what about reading and updating .cabal files? what could I use for that?
10:27:58 <MarcelineVQ> Cabal :>
10:29:58 <tsizz> dminuoso im just lost so thats my only reference as of now 
10:30:59 <dminuoso> tsizz: dmwit gave you a good starting point, how far did you get from there?
10:31:07 <freeman[w]> MarcelineVQ, what about cabal? ( •̀ ω •́ )y
10:31:47 <__monty__> freeman[w]: Cabal-the-library is distinct from cabal-install the cabal executable.
10:31:52 <MarcelineVQ> as in what about lower case cabal? that's a short name for cabal-install which is a sort of frontend for Cabal
10:32:55 <tsizz> dminuoso i have the getEveryNth function correctly written. I just need to apply it to every element in a list (which outputs a list and i need to take the last character of each element) and then combine it
10:33:11 <freeman[w]> __monty__, "Cabal-the-library is distinct from cabal-install the cabal executable." I am aware of that. is that related somehow?
10:33:26 <MarcelineVQ> that depends on what your last question meant
10:33:29 <dminuoso> tsizz: Start with that, try to construct a naive solution.
10:33:46 <freeman[w]> my question is: `what about reading and updating .cabal files?`
10:34:00 <dminuoso> tsizz: And close that stackexchange website, you wont need it for your homework. :)
10:34:01 <MarcelineVQ> you'd reach for Cabal
10:34:51 <MarcelineVQ> and use it to parse your file, do your edits then prettyprint a new file. I've not done this myself so the last step might be different but I assume that's the flow
10:35:47 <freeman[w]> I asked on reddit: https://www.reddit.com/r/haskell/comments/ct2rn1/haskell_library_for_parsing_changing_and_saving_a/?
10:36:06 <freeman[w]> MarcelineVQ, yeah, cabal library seems to be one way to do it
10:36:15 <freeman[w]> @karma+ MarcelineVQ
10:36:15 <lambdabot> MarcelineVQ's karma raised to -8763.
10:36:40 <tsizz> dminuoso so i do map last (getEveryNth 3 "hello!"), which gets me the correct answer for the getting every third element
10:36:54 <tsizz> but how do i arbitrarily handle the "3" part 
10:37:07 <tsizz> i could do this in javascript probably bc it saves index o.O
10:37:28 <dminuoso> tsizz: Let's build up to that, shall we?
10:37:33 <tsizz> okay =)
10:37:45 <tsizz> i definitely need 2 maps
10:38:29 <dminuoso> tsizz: Let me modify the task. Assume you must only produce a list of 3 elements, the first contains the entire original lits, the second contains every second element, the third contains every third element.
10:39:24 <tsizz> [map last (getEveryNth 1 "hello!"), map last (getEveryNth 2 "hello!"), map last (getEveryNth 3 "hello!")]
10:40:01 <tsizz> dminuoso ^ 
10:40:20 <tsizz> well assuming the input string is "hello!"
10:40:52 <dminuoso> tsizz: Why is there a "last" ?
10:42:03 <tsizz> dminuoso bc getEveryNth splits the list every N. so getEveryNth 2 "hello!" returns ["he", "ll", "o!"]. then i want the last of each part
10:42:23 <dminuoso> tsizz: Then your getEveryNth is inadequately written.
10:42:51 <tsizz> dminuoso so you suggest putting the last part in the getEveryNth function?
10:42:59 <dminuoso> tsizz: Make it so ⌜getEveryNth 2 [1,2,3,4,5,6..] = [2,4,6,..]⌝
10:43:09 <tsizz> okay i can do that
10:43:11 <dminuoso> (Or [1,3,5,...] depending on what your original task demands)
10:47:16 <tsizz> jk i can't do it lolo
10:56:48 <tsizz> dminuoso yeah im not sure how to do that in one function, which is why i wanted to do it in the map part 
10:57:05 <tsizz> im sorry im frustrated ive only written 2 lines of code in like 3 hours lol
10:58:12 <tsizz> anyway i can just implement this part [map last (getEveryNth 1 "hello!"), map last (getEveryNth 2 "hello!"), map last (getEveryNth 3 "hello!")]
11:04:06 <tsizz> dminuoso i can do getLast n xs = map last (getEveryNth n xs). and get the answer. but i just need the index to equal n when im mapping again
11:18:55 <freeman42x[m]> Is there a way to reserve a Haskell package name on hackage? or would I need to push unfinished code just to reduce chance of someone else taking the name?
11:24:20 <__monty__> freeman42x[m]: The proper solution is to stop worrying about names.
11:24:26 <__monty__> ; )
11:24:45 <cocreature> freeman42x[m]: iirc uploading a candidate reserves the name but I wouldn’t recommend doing that. Just wait until you’re ready to upload and if someone comes first, well then they had their stuff ready first so it’s only reasonable they get the name
11:26:35 <Phyx-> stevejb: what's running in the container?
11:27:58 <stevejb> Phyx- just the program I wrote
11:28:29 <freeman42x[m]> cocreature, I'll look into how to upload a candidate since I don't want any issues later
11:28:54 <freeman42x[m]> @karma+ cocreature
11:28:54 <lambdabot> cocreature's karma raised to 33.
11:29:06 <stevejb> Phyx- base 
11:29:07 <stevejb> resolver: lts-13.27docker:  enable: trueimage:  container:    name: stevejbs-program    base: fpco/stack-run
11:29:11 <stevejb> ```
11:29:26 <stevejb> oops, sorry for the formatting. Those are the relevant lines from my docker container
11:31:30 <Phyx-> I disconnected for a bit so not sure if you answered stevejb
11:31:45 <stevejb> Phyx- I just replied, 
11:32:01 <stevejb> its just the app that I wrote
11:32:03 <boxscape> > floor $ 0/0
11:32:06 <lambdabot>  -269653970229347386159395778618353710042696546841345985910145121736599013708...
11:32:08 <boxscape> that's nice
11:32:15 <dminuoso> o_o
11:32:17 <boxscape> CMV floor should return a Maybe
11:32:39 <dminuoso> > floor NaN
11:32:43 <lambdabot>  error:
11:32:43 <lambdabot>      Data constructor not in scope: NaN :: Double
11:32:52 <dminuoso> > floor nan
11:32:57 <lambdabot>  error:
11:32:57 <lambdabot>      • Variable not in scope: nan :: Double
11:32:57 <lambdabot>      • Perhaps you meant one of these:
11:33:01 <boxscape> > floor (0/0 :: Float) == floor (0/0 Double)
11:33:04 <lambdabot>  error:
11:33:05 <lambdabot>      • Data constructor not in scope: Double
11:33:05 <lambdabot>      • Perhaps you meant variable ‘double’ (imported from Text.PrettyPrint.Hu...
11:33:09 <jle`> there is no NaN literal
11:33:10 <boxscape> > floor (0/0 :: Float) == floor (0/0 :: Double)
11:33:13 <dminuoso> jle`: Ah.
11:33:13 <lambdabot>  False
11:33:21 <dminuoso> jle`: Why not?
11:33:55 <jle`> i don't know if any language has a NaN literal
11:34:09 <jle`> oh, javascript does, after a quick test
11:34:39 <jle`> dminuoso: a more general answer might be that Haskell doesn't have floating point or double literals in the first place
11:34:49 <jle`> it only has Rational/Fractional literals
11:35:23 <jle`> and there is no NaN Rational
11:37:42 * hackage happstack-authenticate 2.4.0 - Happstack Authentication Library  https://hackage.haskell.org/package/happstack-authenticate-2.4.0 (JeremyShaw)
11:38:42 * hackage clckwrks 0.25.0 - A secure, reliable content management system (CMS) and blogging platform  https://hackage.haskell.org/package/clckwrks-0.25.0 (JeremyShaw)
11:38:54 <boxscape> So for example something like 4.5 is internally 45%10?
11:39:44 <jle`> if you type in 4.5 then it is interpreted as fromRational (45%10)
11:39:48 <boxscape> okay
11:40:43 * hackage clckwrks-plugin-page 0.4.3.18 - support for CMS/Blogging in clckwrks  https://hackage.haskell.org/package/clckwrks-plugin-page-0.4.3.18 (JeremyShaw)
11:40:58 <boxscape> incidentally the Int results make marginally more sense than the Integer results
11:41:12 <boxscape> > (floor $ 0/0 :: Int, floor $ 0/0 :: Integer)
11:41:16 <lambdabot>  (0,-269653970229347386159395778618353710042696546841345985910145121736599013...
11:41:19 <boxscape> (same for infinities)
11:42:07 <Phyx-> stevejb: yes but which os is this? Is this a windows docker on Windows or a Linux docker on Windows. I'm trying to understand what architecture the code is running :) 
11:42:30 <jle`> > fromInteger $ floor (0/0)
11:42:34 <lambdabot>  -269653970229347386159395778618353710042696546841345985910145121736599013708...
11:42:42 <jle`> > fromInteger $ floor (0/0) :: Int
11:42:46 <lambdabot>  0
11:42:46 <stevejb> Phyx- ah okay, I made the container on linux, but it is running on Windows
11:43:06 <stevejb> Phyx- I was struggling to get the code to compile natively on Windows
11:43:12 <boxscape> hmm interesting
11:43:40 <boxscape> so it's a multiple of 2^64
11:48:05 <dminuoso> jle`: Does this look right to you? https://gist.github.com/dminuoso/66131c69a75bb592bb3802578310ea1b
11:48:47 <dminuoso> (I think I may have fallen down the stairs in this rabbit hole)
11:48:50 <Phyx-> stevejb: ah, well I'd love to hear what your difficulties were with native compilation on Windows but that's not the issue at hand :) silly question when the app exists did you check the exit code?
11:49:22 <Phyx-> stevejb: that should be the first clue, otherwise attach gdb and compile with -debug and see what it gives
11:49:27 <dminuoso> The unit seems so utterly wrong, but I dont understand how to show this.
11:49:32 <jle`> dminuoso: the identity isn't Proxy
11:49:43 <jle`> because These1 Proxy f a is not the same as f a
11:50:15 <jle`> `These1 Proxy f a` can be This1 x, That1 Proxy, or These1 Proxy x
11:50:31 <jle`> so `These1 Proxy f a` is actually 2 + f a
11:50:56 <dminuoso> jle`: Hold on, why 2 + f a?
11:51:02 <jle`> because there are two extra inhabitants
11:51:04 <dminuoso> jle`: Shouldnt it be 2 * f a + 1?
11:51:20 <jle`> oh ah
11:51:23 <jle`> yeah, that's right
11:51:28 <jle`> two times extra inhabitants, plus an extra one :)
11:51:38 <jle`> (f a) + 1 + (f a) = 2*(fa) + 1
11:51:45 <dminuoso> :)
11:52:20 <stevejb> Phyx- not sure how to check the exit code on windows
11:52:39 <dminuoso> jle`: This is sort of rank 1 algebraic data types..
11:52:48 <dminuoso> Crazyness.
11:53:14 <dminuoso> (Or would it be called rank 2 here?)
11:53:15 <jle`> well in this case we're treating `f a` as a single 
11:53:18 <jle`> thing
11:53:48 <dminuoso> jle`: so Im seeing product, sum.. are we inside some cartesian closed category here?
11:53:53 <jle`> the higher rankedness would be saying that `These1 Proxy f` is `f :+: f :+: Proxy`
11:54:03 <dminuoso> Right
11:54:17 <Phyx-> stevejb: wait I'm confused. I thought you said the app exits. In which case it's dying in the Linux container no? So can't you login to the container in interactive mode and run it and see? Exit code on windows depends on which shell you're using
11:54:23 <jle`> or ((,) Bool :*: f) :+: Proxy
11:54:26 <dminuoso> Ah, I think I have an idea how to approach it then
11:55:40 <jle`> btw i'm not sure exactly what the abstraction it reprensents is
11:55:48 <jle`> but i found that its 'free monoid' was interesitng
11:56:12 <dminuoso> jle`: Do you mean the monoid on These1?
11:56:47 <jle`> yeah
11:56:54 <jle`> the analogy of Free for Compose
11:57:10 <boxscape> > uncurry encodeFloat $ decodeFloat (0/0) -- another fun NaN thing
11:57:12 * hackage clckwrks-cli 0.3.0 - a command-line interface for adminstrating some aspects of clckwrks  https://hackage.haskell.org/package/clckwrks-cli-0.3.0 (JeremyShaw)
11:57:13 <dminuoso> Huh okay, dont give me any more spoilers. Im on a completely wrong track
11:57:15 <lambdabot>  -Infinity
11:57:16 <jle`> or (Compose []) for (:*:)
11:57:31 <dminuoso> jle`: I was led under the assumption that Product is a sort of free monoid
11:57:45 <jle`> Product like :*:?
11:57:47 <dminuoso> Yes.
11:58:43 <jle`> i would say it is a specific monoid, not necessarily a free one
11:59:00 <dminuoso> jle`: Here's how
11:59:23 <dminuoso> jle`: (This is going to be a handwavy construction because I havent tried to construct a category yet)
12:01:46 <dminuoso> Oh.
12:02:03 <dminuoso> Yeah trying to formulate it shows that I was wrong.
12:03:27 <dminuoso> jle`: Im guessing the solution is tied to some specific (set of) endofunctor(s) ?
12:03:43 <jle`> as for the free monoid construction?
12:03:46 <dminuoso> Yeah
12:03:52 <jle`> it's somewhat straightforward from the construction of Free
12:04:10 <jle`> Free f = 1_x + (f x f)
12:04:26 <dminuoso> jle`: Free as in free monad?
12:04:32 <jle`> yeah
12:04:47 <jle`> for the actual free monad, that's Free f = Identity :+: (f :*: f)
12:05:22 <jle`> er sorry, i mean Free f = Identity :+: (f :.: f)
12:05:35 <jle`> um, Free f = Identity :+: (f :.: Free f)
12:05:38 <stevejb> Phyx- duh, you're right. That is a good idea. I have been running it with --rm and passing all the arguments into docker run. I will try it in interactive mode. Thanks1
12:06:30 <jle`> data TList t i f a = TNil (i a) | TCons (t f (TList t i f) a)
12:06:44 <jle`> so the Free Monad is `TList (:.:) Identity`
12:06:54 <jle`> the Free Plus is `TList (:*:) Proxy`
12:07:07 <jle`> the Free Applicative is TList Day Identity
12:07:18 <jle`> etc.
12:07:23 <dminuoso> jle`: Wow!
12:07:51 <jle`> the construction is similar to data List a = Nil | Cons a (List a)
12:08:13 <jle`> except instead of Nil you have the Identity, and instead of Cons you have the recursive tensor product
12:08:24 <jle`> instead of the recursive 'normal' product
12:09:48 <dminuoso> jle`: well I can reasonably say that I couldn't have come up with it, but I can certainly make sense of this.
12:10:26 <jle`> yeah, it's looking at the free monad and the free applicative, and then isolating what's common and what's different between them :)
12:10:42 <jle`> the interesting thing that happens i think is looking at these types and then seeing how they are equivalent to simpler types
12:10:51 <jle`> for example TList (:*:) Proxy is Compose [], even though that's not obvious
12:11:33 <jle`> so also `TList (:+:) ???` and `TList These1 ???` are also equivalent to simpler types
12:18:02 <dminuoso> jle`: What's the endofunctor monoid construction here?
12:20:31 <jle`> if f is a monoidal endofunctor under t then you would be able to collapse a TList t i f a to an f a 
12:20:42 <jle`> for example if f is a Monad, you can collapse TList Monad Identity f a into f a
12:21:28 <dminuoso> jle`: No I mean in a monoidal category of endof equipped with These1 as its tensor
12:21:34 <boxscape> So, as I understand it, the main reason why you'd want to use `data` instead of `newtype` is to have the laziness of the extra constructor, so for example something like `data A Int = A Int; A undefined` can be pattern matched without an error. Is there any reason to use data (when you could be using newtype) when the constructor is strict in its a
12:21:34 <boxscape> rgument?
12:22:27 <boxscape> though... actually I need to rethink this, because you can pattern match the same thing without problems if you use newtype, I just found out
12:22:38 <dminuoso> boxscape: There's some subtle difference though.
12:22:48 <boxscape> between what and what?
12:23:09 <dminuoso> boxscape: ⌜newtype N = N a⌝ leads to irrefutable pattern matches if you have ⌜N pat⌝ for some pattern pat (for obvious reasons)
12:23:11 <boxscape> (also it's supposed to be data A, not data A Int)
12:23:12 <stevejb> I just tried compiling my project on my windows VM, it seemed to bring in all the dependencies, but then when it got to building the project itself, it complained that there is no cabal file
12:23:59 <dminuoso> boxscape: (The reason its irrefutable because there's nothing to assert - after type erasure there's nothing you could test)
12:24:15 <boxscape> I'm not quite sure what it means for a pattern to be refutable if there's only one possible constructor
12:24:32 <jle`> dminuoso: are you asking what the identity of These1 should be?
12:24:38 <dminuoso> jle`: Yes.
12:24:39 <EvanR> > (\case (Identity _) -> 0) (Identity undefined)
12:24:42 <lambdabot>  0
12:24:46 <dminuoso> jle`: It's essentially just that. ;)
12:24:46 <EvanR> HMMMM
12:24:58 <dminuoso> boxscape: ^- what EvanR just did.
12:25:24 <EvanR> how didn't it crash
12:25:25 <boxscape> okay but Identity is a newtype isn't it?
12:25:27 <jle`> dminuoso: think of a functor where `These1 I f a` ~ `f a`
12:25:31 <dminuoso> boxscape: Yes.
12:25:36 <boxscape> EvanR yeah that's what I was wondering a minute ago as well
12:25:43 <jle`> boxscape: it's a bit tricky. i wouldn't think of the difference between newtype/data as laziness
12:26:03 <jle`> i would say it's that newtyped types have the same runtime representation as the types they wrap
12:26:08 <dminuoso> boxscape: The difference between newtype and data is that newtype creates a raw compiler-time type wrapper.
12:26:11 <jle`> whereas data creates a "new" type of runtime rep
12:26:18 <dminuoso> ^- he was faster :)
12:26:44 <jle`> `These1 ??? f a` ~ `f a`
12:26:49 <boxscape> what's the actual semantic difference in practice? (i.e. leaving aside performance)
12:26:51 <EvanR> right, so Identity undefined is some explosion, not a rep
12:26:55 <dminuoso> EvanR: The reason it doesnt crash is becuase "Identity _" is an irrefutable pattern.
12:26:58 <EvanR> oh
12:27:03 <dminuoso> EvanR: And if you ponder about it, this makes only sense.
12:27:08 <MarcelineVQ> > (\case _ -> 0) undefined
12:27:09 <EvanR> sure but dang
12:27:11 <lambdabot>  0
12:27:13 <dminuoso> EvanR: Consider an implementation perspective, what should that do?
12:27:29 <dminuoso> EvanR: You want to assert the data constructor is really Identity. But there's no data constructor in reality, so there's no knowledge you could uncover.
12:27:42 <dminuoso> There's no actual Identity.
12:27:47 <EvanR> oh, there can't be another ctor anyway
12:28:01 <dminuoso> EvanR: More to the point, the one you are testing against *doesnt exist*
12:28:21 <EvanR> it can't exist, so the test for existence can't fail. got it
12:28:50 <jle`> boxscape: when you pattern match on a 'data' type, first you match on the "constructor tag" (you check what constructor the type was made with) and then you check the value "inside".  (with enough laziness at the matchtime, both of these could be skipped)
12:28:59 <jle`> boxscape: for newtypes, the first check doesn't happen
12:29:07 <jle`> a data type with a single constructor still semantically has a constructor to be checked
12:29:31 <boxscape> ah
12:29:34 <boxscape> so
12:29:36 <jle`> even though (Int,Bool) only has a single constructor, we still ahve to 'check' that it's (,)
12:29:41 <boxscape> > (\case (Identity _) -> 0) (undefined)
12:29:45 <lambdabot>  0
12:29:48 <boxscape> that's the actual case that only works for newtypes
12:29:54 <jle`> indeed
12:30:09 <jle`> for both lazy and strict 'data', it'll check for the constructor
12:30:13 <boxscape> so is there a reason you'd ever want to use data over newtype?
12:30:14 <jle`> but no constructor was used --- it's undefined
12:30:26 <dminuoso> boxscape: If a newtype would work? Probably not.
12:30:40 <jle`> sometimes you want the extra level of indirection
12:30:45 <boxscape> okay
12:31:04 <jle`> for example let's say you had a 'strict tuple' type
12:31:07 <EvanR> > (\case !(Identity _) -> 0) undefined
12:31:08 <dminuoso> boxscape: If a newtype is enough, then you might pay extra for data because of extra runtime representation if GHC cant optimize it away.
12:31:12 <lambdabot>  *Exception: Prelude.undefined
12:31:16 <EvanR> wahaha
12:31:30 <jle`> then using a dummy data type in your fields would turn your strict tuple back into a lazy tuple
12:31:31 <EvanR> > (\case ~(Identity _) -> 0) undefined
12:31:32 <dminuoso> EvanR: The real question now is if you can do this:
12:31:34 <lambdabot>  0
12:31:40 <dminuoso> > (\case ~(!(Identity _)) -> 0) undefined
12:31:44 <lambdabot>  0
12:31:55 <EvanR> > (\case !(~(Identity _)) -> 0) undefined
12:31:58 <lambdabot>  *Exception: Prelude.undefined
12:32:00 <stevejb> Phyx- I think I got it to compile on my Windows VM. Would I be able to move the EXE over to another Windows machine to have it run?
12:32:02 <EvanR> i call bs
12:32:03 <boxscape> okay I see jle`
12:32:09 <jle`> that's what the vinyl library does
12:32:21 <jle`> Rec f '[a,b,c] is basically a strict tuple (f a, f b, f c)
12:32:35 <jle`> so Rec Identity '[a,b,c] is a strict 3-tuple (a,b,c)
12:32:54 <jle`> but Rec DummySingleFieldData '[a,b,c] is a lazy 3-tuple (a,b,c), just like the old classics
12:33:05 <dminuoso> jle`: Ah I suppose that'd be ⌜Const Void⌝
12:33:11 <dminuoso> (Or Void1 if you will)
12:33:27 <boxscape> so, to go back to my original question, is there a reason you'd ever want to use data with a strict field over newtype?
12:33:32 <jle`> boxscape: i guess the 'big picture' here is that you are using a "wrpper-polymorphic" abstraction
12:33:38 <jle`> and you have to pass in *some* type of wrapper
12:33:42 <boxscape> ok
12:33:45 <dminuoso> boxscape: Only if you want that barrier to control lazyness.
12:33:55 <jle`> but you don't want it to be strict, you want that wrapper to still have some level of indirection
12:34:22 <jle`> remember that even data types with a strict field can be lazy on the constructor
12:34:25 <jle`> at matchtime
12:34:26 <mreh> is access to type level values way outside of what's possible right now? 
12:34:34 <boxscape> ah, well I don't remember that but it's good to know
12:34:39 <dminuoso> mreh: what kind of access are you looking for
12:34:52 <jle`> mreh: it's 'possible' but it depends on what really you want to do
12:35:01 <jle`> dminuoso: yeah, Void1 :)
12:35:14 <mreh> dminuoso: well, like how in Idris I've seen you can access type level values, but in Haskell you have to jump through lots of hoops with singleton types
12:35:33 <dminuoso> % import GHC.TypeNats
12:35:33 <yahb> dminuoso: 
12:35:39 <jle`> so did you just answer your own question? ;)
12:35:43 <dminuoso> % :t natVal
12:35:43 <yahb> dminuoso: KnownNat n => proxy n -> GHC.Natural.Natural
12:35:44 <freeman42x> if all I need to do is run the command `stack build` from Haskell, would I need to use the turtle library http://hackage.haskell.org/package/turtle ?
12:36:00 <dminuoso> mreh: Unless you mean that, you have to be a bit more specific.
12:36:03 <jle`> mreh: ^ (so did you just answer your own question?)
12:36:07 <mreh> jle`: I meant easily :)
12:36:11 <Phyx-> stevejb, sure the haskell exe is fully statically linked on windows. If you've linked against any native dependencies such as a dll then just copy those too and put them in the same folder as the exe
12:36:27 <mreh> it comes down to type erasure doesn't it?
12:36:49 <jle`> yeah, there's no support directly built-into the language, but you can build that functionality yourself within the language
12:37:06 <jle`> the exception being some specific kinds that GHC has out-of-the-box reflection support for: Nat, Symbol, and Type
12:37:16 <jle`> s/refletion/reification
12:37:35 <mreh> jle` oh so there are native type level natural numbers?
12:37:50 <MarcelineVQ> freeman42x: the most direct option is to use process for that
12:37:55 <jle`> yeah, in GHC.TypeNats :)
12:37:56 <dminuoso> mreh: Yes. 
12:38:05 <dminuoso> mreh: See the primitive I just invoked above?
12:38:09 <jle`> dminuoso: btw if you haven't already, maybe try doing :+: instead of These1 first
12:38:20 <jle`> since it's simpler
12:38:24 <dminuoso> jle`: well Ive done :+: and :*: both :)
12:38:41 <dminuoso> jle`: I think I confused myself too much.
12:38:44 <jle`> ah, alright :)
12:38:49 <jle`> yeah, :+: has the same identity as These1
12:39:53 <jle`> but that's probably a part of where you got the inspiration from for Const Void/Void1 :)
12:40:05 <mreh> what are Symbol and Type?
12:40:19 <mreh> I should probably google this
12:40:31 <mreh> I'm very green to dependent typing
12:40:34 <jle`> Symbol is like a type-level Text
12:40:39 <c_wraith> Type is the new name for *
12:40:48 <jle`> it's the kind of type-level string literals
12:40:51 <jle`> :k "hello"
12:40:53 <lambdabot> GHC.Types.Symbol
12:41:02 <freeman42x> MarcelineVQ, yeah, like, I don't think I need turtle... but, do I? :D
12:41:03 <mreh> jle`: yes, I've seen those before come to think of it
12:41:16 <dminuoso> jle`: ⌜Const Void⌝ and ⌜Const ()⌝ were too obvious. It took me less than a few seconds to come up with those :P
12:41:19 <mreh> c_wraith: as in * the kind?
12:41:25 <c_wraith> Type has the advantage that it's lexically correct when you collapse types and kinds down to the same thing, as * is an operator character. 
12:41:26 <jle`> i say Text not String because it's "atomic", it's not built on a list of chars
12:41:36 <jle`> mreh: yeah, Nat, Symbol, and Type are all kinds
12:41:45 <jle`> and they are kinds that GHC natively supports reification and reflection for
12:41:56 <jle`> so, the ability to promote and demote between type and value levels
12:42:03 <jle`> the rest...we have to do ourselves
12:42:48 <MarcelineVQ> freeman42x: no
12:42:53 <MarcelineVQ> the most direct option is to use process for that
12:43:04 <c_wraith> jle`: have you seen that amazing hack to destructure symbols? (it's a fun proof of concept and the fact that it's been done proves we really need a right way to do it) 
12:43:16 <dminuoso> jle`: TList is quite a mouthful though. :)
12:43:33 <jle`> c_wraith: ah yes, i have seen it
12:43:42 <jle`> 'amazing' is just one way to describe it ;)
12:43:47 <jle`> horrifying is another
12:44:19 <boxscape> c_wraith do you happen to have a link?
12:44:23 <jle`> dminuoso: it gets cleaner if you just `TList t f a` and have some type family to associate t with its identity.  but i like the way TLIst t i f a works
12:44:29 <jle`> rolls off the tongue :)
12:44:37 <mreh> what are the hot new categories then? :) it's been ages since I studied any new Haskell
12:45:01 <MarcelineVQ> freeman42x: as in the package called process
12:45:04 <jle`> dminuoso: phaazon calls it Free h i f a
12:45:23 <jle`> oh i meant phadej 
12:46:21 <jle`> in that blog post uniting free monad and free applicative
12:46:39 <jle`> i would paste it but i'm using an experimental build of a terminal app that doesn't support clipboard yet :|
12:46:59 <c_wraith> boxscape: the code is in here. can't recall where the blog post is, but I'd check csongor's blog. https://hackage.haskell.org/package/symbols
12:47:14 <jle`> oh wait, it does
12:47:18 <jle`> dminuoso: http://oleg.fi/gists/posts/2018-02-21-single-free.html
12:47:21 <jle`> ya hah!
12:47:27 <jle`> i was thinking about URL clicking support, that's still in the works
12:47:33 <boxscape> c_wraith thanks!
12:48:28 <boxscape> https://kcsongor.github.io/symbol-parsing-haskell/
12:48:45 <dminuoso> jle`: Great, thanks.
12:48:56 <dminuoso> jle`: Ive stumbled over this a while ago, when it was just gibberish to me.
12:49:10 <jle`> your powers have doubled since you last met
12:49:46 <freeman42x> streaming parsing Haskell `stack build` errors using Haskell and megaparsec https://www.twitch.tv/freeman42x
12:55:59 <boxscape> > mySV :: forall n. KnownSymbol n => String; mySV = symbolVal (Proxy :: Proxy n) -- I actually find it a bit odd that a function like this doesn't exist since you can totally use it with TypeApplication (though I don't know if lambdabot has the necessary extensions to compile it)
12:56:02 <lambdabot>  <hint>:1:42: error: parse error on input ‘;’
12:56:07 <boxscape> or that
12:58:15 <jle`> i suppose you just have to settle with symbolVal @"blah" Proxy
12:58:19 <boxscape> yeah
12:58:27 <boxscape> (or make my own function))
13:01:05 <boxscape> how do you use symbolVal' ? I'm not quite sure how I would construct a value with Proxy#
13:02:37 <jle`> "you can't"
13:03:06 <jle`> you have to use undefined or some other trick
13:03:07 <boxscape> okay, but can I still use the function if I can't do that?
13:03:10 <boxscape> ahh
13:03:24 <jle`> oh wait, you have `proxy# @_ @a`
13:03:33 <c_wraith> um. isn't Proxy# the "constructor" for Proxy#  ? 
13:03:52 <jle`> Proxy# has no constructor
13:03:56 <c_wraith> you notably cannot use undefined for Proxy#
13:04:02 <jle`> that's sort of the "point", i suppose, of using Proxy# over Proxy
13:04:05 <c_wraith> because Proxy# is unlifted. 
13:04:07 <boxscape> maybe I'm missing an extension or something but I'm getting a parseError if I try to use # on the value level
13:04:15 <jle`> yeah, proxy# is the pseudo-constructor
13:04:17 <dminuoso> data Proxy# :: forall k0. k0 -> TYPE (TupleRep ([] :: [RuntimeRep])) 
13:04:27 <jle`> boxscape: you need to turn on MagicHash
13:04:37 <boxscape> ahh
13:05:12 <dminuoso> c_wraith: I'd say this is a proper Void type.
13:05:14 <jle`> sorry for the confusion :) yeah, it has no runtime reps, so it's not going to be passed around
13:05:23 <jle`> well, it's not Void, it has an inhabitant, proxy#
13:05:43 <dminuoso> c_wraith: `TYPE (TupleRep [])` is as empty as it can get :P
13:05:58 <jle`> but one of the semantic advantages is that if you take Proxy, it's sort of ambiguous how the function will use the Proxy
13:06:20 <dminuoso> jle`: Wow that's interesting.
13:06:52 <jle`> since it can be `myFunc Proxy = ...`, or `myFunc _ = ...`/`myFunc ~Proxy = ...`
13:06:57 <dminuoso> jle`: I like it, its a better candidate for an unlifted unit then.
13:07:07 <c_wraith> a function should basically never take a Proxy as a parameter. 
13:07:17 <dminuoso> That dethrones ⌜State# RealWorld⌝ for me :)
13:07:29 <jle`> there are some advantages of Proxy# over explicit type applications
13:07:36 <c_wraith> if it's in a negative position, just use a type variable like proxy 
13:07:59 <jle`> hm...i guess the advantages aren't too great
13:08:11 <jle`> ryan scott does a good run-down of the different methods
13:08:15 <jle`> https://ryanglscott.github.io/2019/02/06/proxy-arguments-in-class-methods/
13:08:17 <c_wraith> Proxy# has uses, yes. it was Proxy I was referring to 
13:09:59 <jle`> taking proxy a -> ... has a downside; it's incompatible with GeneralizedNetwypeDeriving if you're using it as a typeclass method, except with some tricks to get around it
13:12:27 <iqubic> What is proxy even used for?
13:12:50 <boxscape> symbolVal for example
13:13:00 <iqubic> How so?
13:13:03 <boxscape> symbolVal :: KnownSymbol n => proxy n -> String
13:13:14 <boxscape> symbolVal @"test" Proxy == "test"
13:14:39 <boxscape> the first test being a Symbol, a type level string literal, whereas the second "test" is just a regular old String
13:15:22 <jle`> the blog post i linked to has some example usages of proxy as well :)
13:15:42 <iqubic> I don't understand what KnownSymbol is.
13:16:30 <c_wraith> it's what lets you turn the type info a value. 
13:16:45 <boxscape> If I understand it correctly it tells you that you know at compile time what the symbol is
13:16:56 <jle`> not necessarily compile time
13:16:59 <boxscape> ok
13:17:08 <jle`> for the most part you can think of it as just being a normal typeclass
13:17:15 <jle`> where there is an instance for every possible string literal
13:17:24 <jle`> er, string :)
13:17:36 <jle`> class KnownSymbol s where symbolVal :: proxy s -> String
13:17:47 <c_wraith> classes are (in some sense) functions from types to values. KnownSymbol is roughly a function from Symbol to String
13:18:27 <iqubic> how is a class a function from Types to Values?
13:18:28 <jle`> as a user of GHC.TypeLits you can think of it as the same as any other typeclass. the main thing that makes it 'magic' is that GHC gives you the instances, instead of you usually defining them yourselves
13:19:12 <c_wraith> iqibic: the type selects the value. how is that not a function? 
13:19:20 <c_wraith> *iqubic
13:19:42 <iqubic> Huh???
13:19:45 <c_wraith> it's not a *haskell* function, but it's certainly a function. 
13:19:54 <iqubic> I'm not sure I follow.
13:20:22 <jle`> > mempty :: String
13:20:29 <lambdabot>  mueval-core: Time limit exceeded
13:20:31 <jle`> > mempty :: Sum Int
13:20:35 <lambdabot>  Sum {getSum = 0}
13:20:38 <jle`> > mempty :: String
13:20:41 <lambdabot>  ""
13:20:52 <iqubic> Oh, right. The type selects the value.
13:21:10 <jle`> you can think of the Monoid typeclass providing a 'function'  mempty from type (Sum Int, String) to a value
13:21:34 <c_wraith> it's not a Haskell function, but it's definitely a mathematical function. 
13:21:46 <iqubic> Except that the list of Types you can take an input is rather large.
13:22:07 <jle`> well, list of values you can take as input is rather large for many normal haskell functions too
13:22:30 <jle`> for example any `Integer -> X` function can take one of an infinite number of Integers 
13:22:50 <jle`> it can take 0, 1, 2 ... even 3 :)
13:22:55 <jle`> the possibilities are endless
13:22:55 <iqubic> As anyone can see by looking at the number of instances Monoid, the number of types you can specialize mempty to is large. And it's an open set.
13:23:26 <boxscape> hmm can you make closed type classes?
13:23:35 <jle`> yeah, the number of types that you can specialise mempty to is also infinite. but i'm saying that that's not special to typeclasses
13:23:42 <jle`> it's something that is true for normal functions too
13:23:48 <iqubic> boxscape: I'm not sure.
13:24:00 <jle`> so not "Except", but "And"
13:26:07 <iqubic> So, KnownNat and KnownSymbol and all that are confusing me so much.
13:26:34 <jle`> as a user, you can just think of KnownSymbol as a normal typeclass
13:26:44 <jle`> class KnownSymbol s where symbolVal :: proxy s -> String
13:26:47 <jle`> and you have a bunch of instances
13:26:49 <boxscape> (to answer my question, you apparently sort of can if you have a constraint as "superclass" that you define with a closed type family)
13:26:59 <jle`> instance KnownSymbol "hello" where symbolVal _ = "hello"
13:27:07 <jle`> instance KnownSymbol "world" where symbolVal _ = "world"
13:27:21 <iqubic> I feel like this is going to slowly descend into a talk about dependant types.
13:27:25 <jle`> instance KnownSymbol "goodbye" where symbolVal _ = "goodbye"
13:27:33 <iqubic> How do these relate to dependant types?
13:27:38 <jle`> it doesn't :D
13:27:43 <jle`> well, not as we are using it now
13:27:47 <iqubic> Huh? Why not?
13:28:06 <jle`> well...there's nothing dependent going on here
13:28:22 <jle`> it's the same thing as Monoid
13:28:35 <jle`> do you understand KnownSymbol now as i have defined it?
13:28:39 <iqubic> But how do you use these typeclasses to implement dependent types.
13:29:11 <jle`> what part makes you think you can use them to implement dependent types?
13:29:27 <jle`> but probably most importantly, do you understand KnownSymbol now?
13:29:48 <jle`> it's like how we have Monoid, instance Monoid [a] where mempty = []
13:29:58 <jle`> instance KnownSymbol "blah" where symbolVal _ = "blah"
13:30:54 <jle`> so that means that the type "blah" has an instance of KnownSymbol
13:30:56 <iqubic> Well, you have a whole 4 part blog post series about dependant types, and near the end of it you mention KnownNat.
13:31:01 <jle`> and that instance is defined as symbolVal _ = "blah"
13:31:07 <jle`> iqubic: well, near the beginning of it in mention Int's
13:31:17 <iqubic> Huh?
13:31:20 <jle`> just because i mention something doesn't mean that it's needed to talk about dependent types :)
13:31:59 * EvanR looks around for dependent haskell
13:32:13 <iqubic> See, the whole concept of dependant types in Haskell confuses the heck out of me.
13:32:21 <EvanR> why
13:32:30 <jle`> do you at least understand the non-dependent-types KnownSymbol typeclass?
13:32:41 <iqubic> Yes.
13:32:58 <iqubic> It's a way of linking a type to a specific value.
13:33:01 <boxscape> Whenever I try to implement something with the dependent haskell features I feel like it works out way better than my understanding of it ought to allow
13:33:28 <jle`> iqubic: yeah :) actually Haskell98 has a very similar typeclass, so it's not necessarily really related to dependent haskell
13:33:37 <iqubic> Oh.
13:33:38 <jle`> the Storable typeclass is similar in structure
13:33:47 <jle`> KnownSymbol links a type to a String
13:33:50 <iqubic> Yeah. I See.
13:33:52 <jle`> Storable links a type to an Int
13:33:58 <EvanR> it's like alien tech, no one can explain it but the protagonists can easily use it to further the plot
13:34:03 <boxscape> > sizeOf (undefined :: Int)
13:34:05 <lambdabot>  error:
13:34:05 <lambdabot>      • Variable not in scope: sizeOf :: Int -> t
13:34:05 <lambdabot>      • Perhaps you meant one of these:
13:34:08 <boxscape> :(
13:34:18 <iqubic> I get the idea of that.
13:34:40 <iqubic> So, jle` How do dependent types in Haskell work?
13:34:41 <jle`> one way this does come up in the topic of dependent types is that it can be used as one half of a reify/reflect pair
13:34:56 <jle`> reify = bring from value level to type level
13:34:59 <hyperisco> Does Haskell have dependent MacGuffin's yet?
13:35:03 <jle`> reflect = bring from type level back to value level
13:35:12 <iqubic> I don't understand how either reify or reflect work.
13:35:31 <jle`> i'm talking about these as general concepts/roles that functions can play
13:35:35 <iqubic> Ah. I see.
13:35:38 <jle`> you see how reflect works
13:35:44 <jle`> symbolVal is basically reflection
13:35:49 <iqubic> Yes. I get that.
13:35:49 <jle`> it brings something from the type level to the value level
13:36:01 <iqubic> Correct.
13:36:05 <jle`> so the mysterious thing is reification
13:36:18 <iqubic> How do you go from a value to a type?
13:36:41 <EvanR> to implement sizeOf with dependent types, i would first throw typeclasses out the window and define a universe of codes for types that have a size
13:36:52 <EvanR> then you define a regular function (rather than a type family) which sends codes to types
13:36:56 <jle`> reification is the part where dependent types come into play.  at that point, you might ask the question "what good is bringing a value to the type level if you can't bring it back down to the value level eventually?"
13:37:00 <EvanR> then a regular function from codes to sizes
13:37:11 <jle`> that's where reflection comes in --- and where functions like KnownSymbol can be useful
13:37:45 <EvanR> or a function from code to (Type,Int)
13:38:06 <iqubic> jle`: I feel like the most common example for how dependent types can be used is in creating length indexed vectors.
13:38:06 <jle`> so the reason why KnownSymbol comes up often in dependent types discussion is that it is one of the things that makes reification useful in the first place
13:38:23 <iqubic> I see.
13:38:32 <jle`> from the fact that it is a method of reflection
13:38:37 <iqubic> So how does reification work?
13:38:49 <iqubic> And are there other forms of reflection?
13:38:57 <jle`> that's....slightly more complicated heh
13:39:03 <iqubic> I see.
13:39:22 <jle`> but in haskell the main form of reflections are through typeclasses or GADTs
13:39:54 <iqubic> GADTs?!?!
13:39:58 <iqubic> How?
13:40:20 <jle`> data IntOrBool :: Type -> Type where ItsAnInt :: IntOrBool Int; ItsABool :: IntOrBool Bool
13:40:26 <jle`> intOrBool :: IntOrBool a -> String
13:40:36 <jle`> intOrBool ItsAnInt = "'a' is an Int"
13:40:43 <jle`> intOrBol ItsABool = "'a' is Bool"
13:40:48 <jle`> * 'a' is Int
13:41:22 <jle`> with the GADT you can check if 'a' is an Int or Bool, essentially turning 'a' into a String
13:41:39 <iqubic> I see.
13:41:55 <iqubic> But how would you use this to create dependent types?
13:42:09 <jle`> this just gives you the reflection part ;)
13:42:15 <jle`> not the reification part
13:42:22 <iqubic> How does reification work?
13:44:30 <jle`> it's a longer story
13:47:40 <EvanR> mySizeOf :: IntOrBool t -> Int
13:47:53 <EvanR> mySizeOf ItsAndInt = 4
13:48:04 <EvanR> mySizeOF ItsABool = 1 -- sizes not to scale
13:48:41 <jle`> when will my reflection show ... who i am inside?
13:48:42 <EvanR> myPeek :: Ptr t -> IntOrBool t -> IO t
13:48:51 <hyperisco> iqubic, you need some way to test that the data represents a particular type.
13:48:59 <EvanR> myPeek ptr w = rawpeek ptr (mySizeOf w)
13:49:49 <hyperisco> iqubic, a way to do this is to come up with a generic and consistent way to encode all data types.
13:50:27 <EvanR> depending on use case you don't need to represent literally all types
13:51:11 <EvanR> the feat kind of makes no sense from  a polymorphism view
13:51:55 <hyperisco> iqubic, or just use JavaScript and do  if (typeof x === 'string')  and it is a string ;)
13:52:58 <hyperisco> In dynamic languages all values are tagged with their type.
13:53:49 <iqubic> How do length indexed vectors work in Haskell?
13:54:09 <iqubic> that's the canonical example of dependent types.
13:54:14 <EvanR> hyperisco: you're suspended, please turn in your lambda and license to curry
13:54:43 * hyperisco reluctantly complies
13:55:01 <iqubic> I also know that dependent sums and witnesses are also things that make dependent types easier to work with.
13:55:23 <iqubic> But I don't know how any of that works in Haskell.
13:55:40 <EvanR> iqubic: there is a straightforward paper on dependent haskell
13:56:08 <hyperisco> The vector has a number as part of its type, and that number signifies the length. When doing vector operations, the bounds can be checked by the type system.
13:57:54 <iqubic> EvanR: Where might I find this paper?
13:58:04 <hyperisco> Any DT examples in Haskell right now are skewed, because Haskell doesn't have DTs… instead it is reimagined to all work with singletons. You don't need any of that for length indexed vectors though…
13:58:27 <iqubic> hyperisco: Is it pssible to write a function that only takes vectors of an even length?
13:58:52 <hyperisco> Yes…
13:59:10 <iqubic> It seems like doing that would require running some sort of isEven function on the length of the vector, at compile time.
13:59:28 <iqubic> So, I'm not sure how that could be done in haskell.
13:59:46 <boxscape> I imagine it would have a type more or less like `takeEven :: forall n a. Even n ~ 'True => Vect n a -> Vect n a`
14:00:02 <boxscape> Even being a type family
14:00:08 <boxscape> (which is just a type level function)
14:00:24 <iqubic> What would that type family look like?
14:00:25 <boxscape> and 'True being the type level version of True
14:00:29 <iqubic> Right.
14:00:41 <iqubic> And (~) is...???
14:01:27 <boxscape> type family Even :: Nat -> Nat where Even 0 = True; Even n = Even (n - 2) -- something along these lines? This might not be entirely correct
14:02:15 <EvanR> iqubic: you can define an arbitrary property with dependent types
14:02:24 <iqubic> And then what is (~) and what would the vector typeclass look like?
14:02:50 <koz_> If I wanna do non-trivial things with type-level lists, do I need to drag in singletons?
14:02:56 <EvanR> but then you'd have to prove the property is satisfied anywhere it's required
14:03:04 <iqubic> How would I do that?
14:03:14 <EvanR> it depends on the construction rules for that property
14:03:15 <hyperisco> You can use a type function… if they are Peano Nats then you can peel off S constructors.
14:03:24 <hyperisco> Another way is to define a GADT which constructs the even numbers.
14:03:25 <EvanR> 0 is even, and if n is even, n + 2 is even
14:03:25 <boxscape> ~ denotes equality (that might not be quite the right term for it though) on a type level, vector would be a datatype, not a typeclass
14:03:35 <iqubic> How would I provide a witness that my vector actually is event?
14:03:36 <hyperisco> Even n -> Vec n a -> ...
14:04:14 <hyperisco> data Even n where EZ :: Even Z; ES :: Even n -> Even (S (S n))
14:04:23 <iqubic> I see.
14:04:30 <EvanR> you construct the proof piece by piece, or carefully design vectors to have the property by construction
14:04:41 <boxscape> I made my type family work: type family Even (n :: Nat) :: Bool where Even 0 = True; Even n = Even (n - 2)
14:05:22 <EvanR> the real answer is, you give up because its too hard. probably
14:05:28 <boxscape> for example :kind! Even 4 in ghci will give you 'True, but Even 5 will only resolve to Even (1 - 2), which you can't prove is ~ 'True
14:06:05 <hyperisco> That's the ultimate conclusion, I think… fun as a toy though.
14:06:12 <iqubic> See, some properties get hard to ecode, like, "this function only works for vectors of a prime length."
14:06:16 <aarvar> why not Vec (2 * n) a -> ...
14:06:27 <EvanR> primality and other number theory concepts can be encoded
14:06:37 <EvanR> then you need to be a grad student to write code
14:07:04 <hyperisco> You start needing to prove that certain things in gives you certain things out
14:07:12 <iqubic> EvanR: It would be hard to encode primality into Haskell, the way things are now.
14:07:13 <hyperisco> That leads to hugely complicated definitions
14:07:35 <EvanR> some of these superrecord libs encode set theory...
14:07:40 <EvanR> in haskell
14:08:40 <hyperisco> Your implementation has to painstakingly explain to the type checker that everything is cromulent
14:08:43 <boxscape> primality seems fairly easy, no? You just need to construct a list from 2 to the number you want to test and see if any numbers in that list divide without rest. Not terribly efficient, but it happens at compile time, so meh
14:09:19 <koz_> boxscape: Spoken like a true Rust programmer. :P
14:09:23 <iqubic> What I'd like is the ability to run arbitrary functions at compile time.
14:09:24 <EvanR> well, many things can be auto derived by instance selection and type inference. Other things need an inexplicable number in the type
14:09:37 <EvanR> boxscape: division... lol
14:09:48 <boxscape> integer division is just repeated subtraction
14:09:51 <hyperisco> Basic stuff like associativity, commutativity, distributivity… it is all nonintuitive to the checker. There is some special sauce for the built in Nat or w/e.
14:09:52 <boxscape> and subtraction is built in
14:09:53 <EvanR> there is a hidden datatype for this deep in idris
14:10:20 <koz_> hyperisco: ghc-typelits-knownnat and ghc-typelits-natnormalise?
14:10:21 <EvanR> which takes into account division by zero, etc
14:10:53 <iqubic> How long until true dependent types arrive in Haskell.
14:10:54 <EvanR> the important part of division is that there exists yadda yadda such that q*b + r = a
14:11:13 <EvanR> plus some accillary uniqueness stuff
14:11:36 <dmwit> Unpopular opinion bear: primality is not a useful type-level predicate to have.
14:11:53 <koz_> dmwit: Why _bear_?
14:12:02 <boxscape> it is if your goal is to only accept vectors that have a prime length
14:12:05 <EvanR> you are spoiled by decades of people allowing "just let me divide dammit"
14:12:09 <iqubic> dmwit: I agree.
14:12:31 <dmwit> koz_: It was a mistake. I pictured the confession bear in my head.
14:12:49 <koz_> dmwit: Fair enough.
14:12:59 <dmwit> boxscape: Right. But I claim that the number of functions which only sensibly work on prime-length vectors is 0.
14:13:03 <iqubic> So what does the data declaration for the length encoded vector look like?
14:13:09 <boxscape> that's fair
14:13:10 <koz_> These days, I never know if some kind of unusual meme is doing the rounds.
14:14:09 <iqubic> Surely the data declaration for the length encoded vector uses GADTs or something
14:14:25 <EvanR> you were just complaining that this was the only example anyone gives
14:14:30 <iqubic> I know.
14:14:31 <EvanR> just look at one of those
14:14:36 <iqubic> I will.
14:14:53 <EvanR> honestly i'd look for other examples, perhaps in vain
14:15:11 <iqubic> Also, what would the definition of takeWhile on length encoded vectors look like?
14:15:17 <EvanR> but like i said there is a well typed division function in idris
14:15:27 <EvanR> that i don't think anyone uses
14:16:07 <boxscape> Actually even Mod is defined in TypeLits already
14:16:07 <iqubic> Because there's no way to know how many elements will be removed from the front of the vector until you run the function. So what would the final return type be?
14:16:38 <EvanR> such an operation could require the population be enough
14:16:42 <EvanR> then you know how many will be removed
14:16:51 <iqubic> Huh? What does that mean?
14:16:58 <EvanR> to remove 5 you need at least 5 in there first
14:17:37 <EvanR> incidentally once you start realizing how loosely described many of our operations are, you start going squirrely, trying to define and prove everything in sight
14:17:50 <iqubic> Right... I see. But what if I want to remove the first run of elements where a given predicate p returns true?
14:18:06 <iqubic> Like takeWhile from Data.List does.
14:18:15 <iqubic> :t takeWhile
14:18:17 <lambdabot> (a -> Bool) -> [a] -> [a]
14:18:26 <EvanR> that sounds exceedingly complicated even without DT
14:18:39 <lavalike> :t dropWhile
14:18:39 <EvanR> ok, so you aren't specifying a number after all
14:18:42 <lambdabot> (a -> Bool) -> [a] -> [a]
14:18:45 <iqubic> No. I'm not.
14:19:03 <iqubic> I'm specifiying a bool.
14:19:10 <EvanR> in this case you may want to return a sum type, the result vector as well as the "fact" that everything in there satisfies some decidable predicate
14:19:24 <EvanR> and the runtime number of things in it
14:19:36 <EvanR> you went from a statically known number to a dynamically known number
14:19:39 <iqubic> So you return a dependent sum?
14:19:47 <iqubic> What would that look like?
14:19:48 <koz_> EvanR: I like to think of dependently-typed programming in GHC as 'teaching GHC first-year logic'.
14:19:49 <EvanR> you could
14:20:44 <aarvar> takeWhile :: (a -> Maybe b) -> [a] -> [b]
14:22:47 <boxscape> Ugh, looks like typelevel functions for lists aren't defined in base, only in singletonss
14:22:55 <boxscape> guess I'll have to make my own
14:23:02 <boxscape> (if I don't want to depend on singletons)
14:23:56 <boxscape> wait how do you make higher order type families
14:24:08 <boxscape> as in, type families that take type families as arguments
14:24:14 <aarvar> using a trick
14:24:17 <EvanR> iqubic: dependent sum type is like "i have here an x of type T such that whatever property x"
14:24:19 <boxscape> ohh I remember
14:24:32 <boxscape> vaguely
14:24:41 <EvanR> such that <any statement involving x, and whatever else was introduce earlier>
14:25:03 <boxscape> it seems like the sort of thing for which you *would* want singeltons because it's probably tedious to define the prerequisites
14:26:52 <aarvar> what's tedious?
14:27:18 <boxscape> you need to like wrap your type families in wrapped function kinds or something, right?
14:27:29 <boxscape> defining those wrappers and surrounding stuff seems like it could be tedious
14:27:55 <boxscape> but I don't really remember how exactly it works so maybe that's wrong
14:28:03 <aarvar> you have to pass in a tag for the function, and use an Apply type family to apply it
14:28:10 <boxscape> okay
14:28:19 <boxscape> this feels an awful lot like lambdas in Java all of a sudden
14:28:26 <aarvar> something like type family Apply (f :: Tag a b) (x :: a) :: b
14:28:34 <boxscape> I see
14:28:57 <aarvar> where Tag uses another trick to define an "open kind"
14:29:54 <cheater> how can i take a single character inside a ByteString, and output it to stdout? my bytestring is bs, the char is a Word8 obtained with bs `index` 1, and i'm not sure how to put that out. there are no funny encodings, ascii only.
14:30:13 <aarvar> actually, I think one can improve on this and just have type family I (x :: Tag a) :: a
14:30:18 <boxscape> aarvar: that's the TyCon things in singletons, right?
14:30:36 <aarvar> and then use a -> Tag b for functions
14:30:37 <aarvar> yes
14:30:43 <aarvar> er, no
14:31:11 <boxscape> oh
14:31:13 <boxscape> TyFun?
14:31:16 <aarvar> yes
14:31:22 <aarvar> iirc
14:31:28 <iqubic> The heck is a tag?
14:31:29 <boxscape> okay
14:32:00 <aarvar> iirc TyCon is a newtype TyCon :: (a ~> b) -> a -> b
14:32:12 * hackage persistent-sqlite 2.10.5 - Backend for the persistent library using sqlite3.  https://hackage.haskell.org/package/persistent-sqlite-2.10.5 (parsonsmatt)
14:32:28 <aarvar> which maps one of these tags into a type constructor
14:32:51 <aarvar> (~> being what I called "Tag")
14:32:54 <boxscape> type TyCon1 = (TyCon :: (k1 -> k2) -> k1 ~> k2) 
14:32:58 <boxscape> looks like it's the other way around?
14:33:12 * hackage persistent-mongoDB 2.9.0 - Backend for the persistent library using mongoDB.  https://hackage.haskell.org/package/persistent-mongoDB-2.9.0 (parsonsmatt)
14:33:13 <aarvar> oh right
14:35:52 <aarvar> boxscape: and it's worse than lambdas in java
14:35:58 <boxscape> okay
14:36:15 <boxscape> still more fun though :)
14:39:18 <boxscape> hmm is there something like type level lambdas? I imagine the answer is no and I just have to define a type family
14:39:39 <aarvar> no, this is how you have to encode type level lambdas
14:39:58 <aarvar> singletons can generate the tags with template haskell though
14:40:14 <boxscape> I was under the impression that this is how you encode type level functions rather than type level lambdas
14:40:23 <boxscape> altough
14:40:24 <boxscape> eh
14:40:28 <aarvar> er, yes, you're right
14:40:29 <boxscape> I can see what you mean
14:40:39 <boxscape> I mostly meant is there a way to write an anonymous function
14:41:02 <aarvar> by lambdas I meant "functions that don't have to be type constructors"
14:41:07 <boxscape> okay
14:41:18 <aarvar> if you want anonymous functions you can always use combinators though!
14:42:27 <boxscape> okay, so, say, if I wanted to have an anonymous function that tests equality with zero I would have some sort of application combinator (like $), and my (==) function and 0?
14:42:42 <boxscape> uuh
14:42:46 <boxscape> In fact exactly that I suppose
14:42:54 <boxscape> because singletons defines $ on the type level
14:43:10 <boxscape> just need to find the defunctionalized version of (==)
14:45:25 <boxscape> cheater: could you just do putChar . toEnum . fromIntegral?
14:48:13 <aarvar> the best thing about trying to prove things in haskell is that after going to great lengths to get more type safety, you then have to use unsafeCoerce if you don't want the proofs to have to run at runtime :)
14:49:04 <boxscape> isn't that how agda compiles code? Just wrap every expression in unsafeCoerce?
14:50:33 <koz_> There needs to be a {-# LANGUAGE DependentHaskell #-} already. Half my source file is LANGUAGE pragmata at this point lol.
14:50:56 <aarvar> well, agda typechecks your code so that the generated unsafeCoerce is safe
14:51:31 <boxscape> I mean, that makes sense, but it's still a bit funny
14:51:48 <aarvar> I mean, in haskell if you want to convert a Vec (m * n) to a Vec (n * m) you have to run a proof at runtime
14:51:49 <boxscape> koz_ just put them all as default extensions into a .cabal file :P
14:52:13 <koz_> boxscape: Yeah, I guess I could.
14:53:30 <boxscape> hm weirdly enough ghci couldn't evaluate :kind! All (TyCon1 ((==) 0)) '[4, 0, 3] to 'False until I reloaded my hs file (before it was just partly evaluated until it was a bunch of applies) but I guess that works
14:54:15 <aarvar> you shouldn't have to use TyCon1
14:54:26 <aarvar> there should be another version of (==), I think
14:54:31 <aarvar> ==$ or something
14:54:44 <boxscape> yeah I couldn't find it...
14:55:17 <boxscape> the docs are kind of hard to read when half of it is machine generated functions with just 20 digit numbers as type variable names
14:55:58 <boxscape> but even then, I'm not sure how much it would help? I'm not applying TyCon to (==), I'm applying it to ((==) 0)
14:56:27 * Digit squirms, giggling, "eeehehehe, tickles"
14:57:08 <aarvar> I guess you want ==@#@$$
14:57:17 <boxscape> jesus what a name
14:57:26 <aarvar> did the naming convention change?
14:57:27 <iqubic> WTF is that name?
14:57:43 <boxscape> systematically machine generated iqubic
14:57:55 <boxscape> but yeah that function looks like it would work
14:58:02 <lavalike> that's hilarious
14:58:34 <boxscape> :kind! Any ((==@#@$$) 0) '[4, 0, 3] has the same results, so yeah
15:00:48 <boxscape> amazingly (==@#@$$$) seems to be just the same as (==) again
15:01:10 <lavalike> just for fun what do those sigils mean after the ==
15:01:49 <boxscape> @#@ is just what they chose to denote a defunctionalized version of an operator, and the number of dollar signs is in how many arguments it's defunctionalized, or something to that effect
15:01:49 <lambdabot>  is just what they chose to denote a defunctionalized version of an operator, and the number of dollar signs is in how many arguments it's defunctionalized, or something to that effect
15:02:00 <boxscape> yes, quite, lambdabot
15:02:06 <lavalike> haha
15:02:25 <iqubic> And what does ($$$) represent?
15:03:41 <boxscape> I'm not entirely sure what the right wording is, but the types are this: (==@#@$) :: a ~> a ~> Bool; (==@#@$$) :: a -> a ~> Bool; (==@#@$$$) :: a -> a -> Bool
15:04:01 <boxscape> so the number of dollar signs is like the inverse of how many of the arrows are converted to squiggly arrows
15:04:07 <iqubic> what is (~>)
15:04:21 <iqubic> And the conversion goes from right to the left.
15:04:28 <iqubic> :t (~>)
15:04:30 <lambdabot> error:
15:04:30 <lambdabot>     • Variable not in scope: ~>
15:04:30 <lambdabot>     • Perhaps you meant one of these:
15:04:34 <boxscape> it's a defunctionalized type level function, so you can use it like a type instead of as a type level function
15:04:41 <boxscape> :k (~>) -- probably not in scpoe
15:04:43 <lambdabot> error:
15:04:43 <lambdabot>     Not in scope: type constructor or class ‘~>’
15:04:45 <boxscape> uh
15:04:51 <iqubic> What does defunctionalized mean?
15:04:52 <boxscape> does lambdabot even have the :k thing?
15:04:55 <boxscape> I guess so
15:05:05 <boxscape> it means that it's not a function anymore but just a type
15:05:17 <lavalike> @kind (->)
15:05:17 <boxscape> but you can convert it back into a function once you need to
15:05:18 <iqubic> :k (->)
15:05:19 <lambdabot> * -> * -> *
15:05:21 <lambdabot> * -> * -> *
15:05:31 <iqubic> What is the kind of (~>)
15:05:39 <boxscape> actually (~>) has the same kind, hm
15:05:41 <lavalike> wiggly stars
15:05:47 <iqubic> I see.
15:06:03 <iqubic> (->) is a vastly overloaded symbol.
15:06:14 <boxscape> I should note that I'm very far from being an expert in this, so take my explanations with a big grain of salt
15:07:40 <lavalike> can't leave all the fun to experts
15:08:07 <boxscape> true
15:14:28 <freeman42x> we are doing a Haskell swarm development session on Twitch, anyone want to join or watch? https://twitter.com/razvan_panda/status/1163936915630034945
15:18:26 <koz_> iqubic: I cannot recommend jle`'s Introduction to Singletons enough.
15:18:37 <koz_> It's really very readable and will help with a lot of the stuff you've been asking about in a big way.
15:20:38 <iqubic> I don't understand it though.
15:20:48 <iqubic> I've read it twice and don't understand it.
15:20:55 <koz_> iqubic: Anything in particular trips you up?
15:21:02 <koz_> I'm far from an expert myself, but I might be of some help.
15:21:26 <iqubic> I have to reboot my computer now, but I'd love to discuss this in a bit when my machine turns back on.
15:23:03 <koz_> iqubic: I won't be around for too long, but hopefully jle` will see these notifications and might be able to pick up where I left off.
15:23:23 <iqubic> Well, I'm back.
15:24:27 <iqubic> Phantom types are simple enough.
15:26:59 <boxscape> iqubic: I've finally done it. I've made a type class that only has instances for Natural numbers that are prime https://pastebin.com/e16Xhyfe
15:27:43 <boxscape> not sure if this is better or if a type family IsPrime :: Nat -> Bool would be
15:27:57 <iqubic> boxscape: I hope you realize that it was just a dummy example of a thing that was supposed to be super hard?
15:28:10 <iqubic> And that I didn't actually need it for any project of mine.
15:28:17 <boxscape> it's not actually hard tbh, the tooling just takes some getting used to
15:28:23 <iqubic> And that I totally didn't expect you to do it.
15:28:24 <boxscape> I realized that you don't need it, I juts wanted to do it :)
15:28:48 <iqubic> Why did you need (==@#@$$)???
15:29:09 <boxscape> because the kind of Any is (a ~> Bool) -> t a -> Bool
15:29:12 <koz_> I think it's defunctionalized equality.
15:29:15 <iqubic> In fact, how does that work?
15:29:21 <boxscape> how does which part work?
15:29:23 <iqubic> koz_: it is.
15:29:48 <iqubic> It's 'a ~> a ~> Bool'
15:29:59 <iqubic> I don't understand any of it.
15:30:00 <koz_> iqubic: Basically, there are no functions at the type level - there are only type families, and among other things, they can't be easily used in the same way functions can: they can't be partially applied, passing them around is annoying, etc.
15:30:20 <koz_> So instead, we define a _symbol_ representing that function, and then have a family called 'Apply' that defines what it does.
15:30:24 <koz_> This is defunctionalization.
15:30:24 <boxscape> btw what this enables you to do for example is write something like "Proxy :: Prime 5 => Proxy ()" in ghci and it will throw a type error if 5 isn't a prime
15:30:52 <iqubic> So, either 'n == 2' or something else crazy is tested.
15:31:05 <koz_> In this case, this is used to great effect here, because it allows us to do the equivalent of (== 0), but at the type level.
15:31:12 <koz_> (that is, partial application).
15:31:13 * hackage tagsoup-navigate 0.1.0.2 - Tagsoup Navigate  https://hackage.haskell.org/package/tagsoup-navigate-0.1.0.2 (TonyMorris)
15:31:27 <iqubic> are (==) and (||) type level functions here?
15:31:33 <koz_> Nope.
15:31:39 <koz_> Well, == is.
15:31:39 <boxscape> yes they are
15:31:42 <boxscape> both are
15:31:45 <koz_> Sorry, my bad.
15:31:49 <koz_> My reading is bad today.
15:31:51 <iqubic> What is $(genDefunSymbols [''Mod]) doing?
15:32:04 <koz_> Generates defunctionalization symbols for Mod.
15:32:07 <iqubic> Why do you need Template Haskell here???
15:32:10 <boxscape>  because that's not part of GHC.TypeLits
15:32:13 <koz_> So like, it gives us all the defunctionalizations for the modulo function.
15:32:24 <koz_> So we can use it at the type level to full effect (partial application etc).
15:32:37 <koz_> We need TH because GHC can't autogenerate them, and writing them manually is possible, but very tedious.
15:32:38 <boxscape> if you translate it to a value level function it's actually quite straightforward: (n == 2 || not (any (== 0) (map (mod n) [2..n - 1]) == True
15:32:47 <iqubic> Is that TH being used to turn the Mod function into a Type Level function?
15:32:55 <boxscape> Mod is already a type level function
15:33:02 <boxscape> the TH is being used to generate the defun symbols
15:33:12 <boxscape> i.e. defunctionalized symbols
15:33:17 <koz_> iqubic: Not quite. It's producing a bunch of symbols to allow its partial application. For example, ModSym1 is mod, partially applied to one argument.
15:33:20 <iqubic> And why do you need that?
15:33:23 <koz_> iqubic: ^
15:33:41 <boxscape> because Map doesn't take a type level function, its kind is (a ~> b) -> [a] -> [b]
15:33:57 <koz_> Also, you can't partially apply type families.
15:34:02 <iqubic> Oh, the Template Haskell gives you curried form of a type level function?
15:34:18 <boxscape> more or less
15:34:35 <boxscape> and yeah what koz_ said is why Map has that kind in the first place
15:34:37 <iqubic> Why do you need EnumToFrom???
15:34:53 <iqubic> or rather, EnumToFrom.
15:35:02 <boxscape> it's basically [2..n - 1], I'm checking if it's divisible by any number from 2 to itself
15:35:14 <boxscape> > enumFromTo 2 7
15:35:14 <koz_> That basically generates [2 ... n - 1], except at the type level.
15:35:18 <lambdabot>  [2,3,4,5,6,7]
15:35:27 <koz_> It's 'promoted' enumFromTo.
15:35:35 <iqubic> What does a type level list even look like?
15:35:44 <boxscape> '[1, 2, 3] would be an example
15:35:50 <koz_> :k '[1,2,3]
15:35:52 <lambdabot> [GHC.Types.Nat]
15:35:55 <koz_> Here you go.
15:35:56 <iqubic> Oh. I see.
15:36:03 <boxscape> (though you can leave off the apostrophe if it's not an empty list)
15:36:11 <koz_> This is true, but I prefer to leave it in.
15:36:33 <boxscape> it does generate a warning with -Wall too if you leave it off
15:36:44 <lavalike> 'tis like that
15:37:32 <koz_> Basically, singletons (the library) does all the boring hard work of promoting base, insofar as it can.
15:37:47 <boxscape> it's kind of annoying how :kind! allows you to partially apply type families, but actual code does not
15:37:51 <boxscape> very misleading
15:37:55 <koz_> boxscape: Agreed.
15:40:59 <inkbottle> What is the applicative operator that drops everything: (<*) holds on the first value, (*>) on the second,...
15:41:11 <inkbottle> Why isn't there one?
15:41:35 <boxscape> what would you expect the type to be?
15:41:58 <inkbottle> yes, what I thought
15:43:02 <boxscape> If that's an answer to my question I think you misread my question
15:45:04 <runner> .
15:46:48 <iqubic> Why is DataKinds even a thing that is useful ever?
15:47:00 <koz_> iqubic: Because it allows promotion of data types to the type level.
15:47:22 <boxscape> The one related extension I've never had a use for is TypeInType
15:47:28 <koz_> So if you have data Foo = Bar | Baz, DataKinds gives you a new _kind_ Foo, with types Bar and Baz in it.
15:47:34 <iqubic> I se.
15:47:39 <koz_> boxscape: It's just a collection of useful pragmata.
15:47:45 <inkbottle> boxscape: maybe I've been mistaken altogether, sorry about that.
15:47:47 <koz_> I enable it every time instead of going through all the others.
15:47:53 <koz_> (DataKinds, KindSignatures, etc)
15:47:56 <boxscape> ah, that's good to know
15:48:04 <iqubic> But I thought Bar and Baz would have been values.
15:48:07 <koz_> Type :: Type is just a thing in GHC now, enabled or not.
15:48:12 <koz_> iqubic: Yes, at the _value_ level.
15:48:16 <iqubic> I see.
15:48:21 <koz_> At that level, Foo is a type, Bar and Baz are values.
15:48:34 <koz_> At the _type_ level, with DataKinds, Foo becomes a _kind_, and 'Bar and 'Baz types.
15:48:57 <koz_> You can think of it as a hierarchy of value -> type -> kind -> sort -> wriggle (or whatever)
15:48:58 <koz_> etc
15:49:04 <iqubic> What is a sort?
15:49:09 <koz_> A kind of kinds.
15:49:11 <yitz> Catergory?
15:49:13 <koz_> (apparently)
15:49:14 <iqubic> Are sorts ever used ever?
15:49:24 <koz_> iqubic: I've heard an explanation in my direction here involving sorts once.
15:49:32 <koz_> I believe at the time I understood perhaps 50% of it.
15:49:38 <koz_> (it involved levity polymorphism)
15:49:42 <koz_> (it was also a while ago)
15:50:01 <iqubic> What the heck is levity polymorphism?
15:50:11 <koz_> iqubic: Let me fish out the relevant SPJ paper.
15:50:25 <iqubic> I only know the ad-hoc and parametric types of polymorphism.
15:50:30 <koz_> https://cs.brynmawr.edu/~rae/papers/2017/levity/levity-extended.pdf
15:50:42 <koz_> It's an Eisenberg-Peyton-Jones special.
15:51:03 <koz_> It is such readable, very recommend, amaze.
15:51:13 <boxscape> huh I thought the fact that Type :: Type means that haskell doesn't go beyond kinds
15:51:14 <koz_> (sorry, couldn't help myself)
15:51:18 <boxscape> will read though
15:51:34 <koz_> boxscape: I think it's mostly used for didactic purposes.
15:51:38 <boxscape> okay
15:51:43 <koz_> (or at least, the explanation in my direction did)
15:51:45 <koz_> (I think)
15:52:11 <koz_> (also, I'm amazed I am able to talk about this stuff coherently)
15:52:18 <koz_> (feels like only yesterday I was super-confused)
15:52:39 <boxscape> I relearn everything about dependent types in haskell every few months
15:52:40 <iqubic> I know
15:52:46 <boxscape> maybe at some point I'll remember
15:52:54 <koz_> boxscape: I think it's _starting_ to sink into my brain.
15:52:55 <iqubic> boxscape: That's the same story with me.
15:53:07 <iqubic> I'm currently in the relearning phase.
15:53:15 <koz_> I guess it's a mixture of 'dependent typing is something I'm not used to' and 'Haskell isn't really dependently typed, but we can fake it'.
15:53:33 <iqubic> koz_: That's the same boat I'm in.
15:53:42 <koz_> I think that second thing especially makes it a bit odd, because you kinda end up going 'OK, I get the logic, but why are we wrangling this poor language like that?'.
15:53:50 <koz_> It's like trying to play Through the Fire and the Flames on a ukelele.
15:55:01 <boxscape> I was wondering earlier today if Haskell will have to get rid of Type :: Type at some point like Agda does if it wants to go fully dependent
15:55:21 <koz_> boxscape: That's probbo a question in Richard Eisenberg's direction.
15:55:26 <iqubic> God... This jle` blog post series on dependent types is such a big pain to understand.
15:55:41 <koz_> iqubic: It's dense, but actually has quite a lot of gems.
15:55:46 <iqubic> https://blog.jle.im/entry/introduction-to-singletons-1.html#the-singleton-pattern
15:55:51 <koz_> It's definitely something that requires multiple readings.
15:56:14 <boxscape> I thought the singletons paper was quite a nice read as well
15:56:20 <iqubic> Why do we need singletons to construct a particular type of door from a run-time value?
15:56:27 <koz_> OK, gotta run and teach first-year C programmers.
15:56:28 <boxscape> probably mostly the same information though
15:56:32 <boxscape> have fun
15:56:40 <koz_> 'Fun', lol.
15:57:07 <iqubic> First year C programmers must be so clueless about types and how they actually work.
15:57:41 <iqubic> There's not really a concept of types in C. At least not in the same way there are types in Haskell.
15:57:42 <boxscape> I'm just waiting for dependently typed C
15:57:56 <iqubic> You'll have to write that yourself.
15:58:16 <iqubic> I think the first step would be statically typed C.
15:59:35 <boxscape> it's already purely functional so that's a good first step http://conal.net/blog/posts/the-c-language-is-purely-functional
16:00:25 <iqubic> So I'm reading this section: https://blog.jle.im/entry/introduction-to-singletons-1.html#the-power-of-the-pattern-match
16:00:56 <iqubic> And it seems that the SingDS is just a witness that our Door really does have state s.
16:01:35 <boxscape> that sounds right I think
16:02:33 <jle`> iqubic: check out the section before, 'The Phantom Menace' -- it shows us trying to write a function to construct a particular type of door from a run-time value and why the naive approach doesn't work
16:02:52 <jle`> and yeah, the second after it tells us how to use SingDS in a way that does work :)
16:02:56 <jle`> *section after
16:03:12 <iqubic> I know.
16:03:18 <iqubic> Type Erasure is a thing.
16:03:33 <iqubic> You literally cannot pattern match on a phantom type.
16:03:34 <jle`> right, i'm just answering the question you asked earlier, "why do we need singletons to construct a particular type of door from a run-time value?"
16:04:02 <iqubic> But this method seems rather verbose.
16:04:32 <jle`> indeed it is rather verbose
16:04:48 <iqubic> It still requires you to know the type of the door at compile time, so you know what value of SingDS s to pass in to the first argument.
16:05:26 <jle`> yes
16:05:31 <jle`> Part 1 doesn't involve dependent types at all
16:05:36 <iqubic> Oh. I see.
16:06:20 <jle`> hm, i guess tha'ts technically not true. the line is a little blurred
16:06:34 <jle`> but yeah, everything at this point is only things you can know at compiletime essentially, with no reification or moving from value to types
16:07:17 <iqubic> The doorStatus function is just really really silly without dependent types.
16:07:48 <iqubic> If you already know what the type of your door is at runtime, you don't need to call a function to tell you the type of the door.
16:08:01 <iqubic> s/runtime/compile time/
16:08:06 <jle`> how else would you know the type of the door, without a function?
16:08:09 <jle`> or a pattern match?
16:08:17 <jle`> oh ah, you mean knowing the 's' type
16:08:32 <iqubic> yes, you know the type of s.
16:08:33 <jle`> yeah, the main benefit is being able to write "state-polymorphic" functions
16:08:42 <iqubic> Oh? How so?
16:08:43 <jle`> that can take doors of any state
16:09:01 <iqubic> Oh?
16:09:04 <jle`> so you, creating a door state that you know at a compiletime, can pass it to a state-polymorphic function
16:09:17 <iqubic> Oh, it's like the lockAnyDoor function.
16:09:35 <jle`> yeah. but without any sort of reflection, our state-polymorphic function has to be parametrically polymorphic
16:09:36 <cheater> boxscape: thanks
16:09:49 <jle`> it *has* to ignore the 's', essentially
16:10:03 <jle`> but with a reflection method -- like singletons, or maybe a typeclass (like Storable or Typeable), it can branch on 's'
16:10:05 <cheater> hey guys, what's the best way to get a Data.Sequence from an ascii file? it's a pretty large ascii file so i'd like to use something that's good for that.
16:10:15 <iqubic> Why do you need doorStatus if you already have a way to pattern match on the 'SingDS s'
16:10:37 <jle`> so even though the caller of lockAnyDoor might know 's' at compile-time, the person who wrote lockANyDoor must deal with an s that they do not know at compiletime
16:11:09 <iqubic> Which is done with a pattern match.
16:11:17 <jle`> mhm
16:11:35 <jle`> yeah, if you have reflection, doorStatus is just like a convenient utility function
16:11:44 <iqubic> Oh, wait... doorState and lockAnyDoor are very very similar.
16:11:46 <jle`> like const or something like that
16:11:59 <cheater> (each element should be a single ascii char, or Word8, or something like that)
16:12:12 <iqubic> But still, having to explicitly pass in a SingDS s is a pain.
16:12:13 <jle`> cheater: hm, remember Data.Sequence is strict on its spine
16:12:37 <jle`> iqubic: yeah, it is. there are some methods to get around it though, with implicit passing
16:12:39 <iqubic> Ah. That's where SingDSI comes in.
16:12:44 <cheater> jle`: not sure how to use that knowledge
16:12:46 <jle`> cheater: so you can't get around storing the whole thing in memory eventually
16:12:57 <jle`> even if you're doing some fancy streaming IO tricks
16:13:32 <jle`> so probably `Seq.fromList <$> readFile` is close to as good as you're going to get for atomic io
16:13:40 <jle`> er, Seq.fromList <$> readFile "myfile.txt"
16:14:04 <iqubic> jle`: How is it possible that lockAnyDoor_ doesn't use any sort of depenedent types?
16:14:18 <jle`> iqubic: well, what do you think the definition of dependent types is?
16:14:29 <iqubic> A type that depends on a value.
16:14:33 <jle`> right
16:14:42 <jle`> well, that's part of the answer. the relevant part, at least
16:14:47 <jle`> so, where do we have a type that depends on a value?
16:14:53 <iqubic> Nowhere.
16:14:56 <iqubic> I see.
16:15:15 <iqubic> :t (=>)
16:15:18 <lambdabot> error: parse error on input ‘=>’
16:15:28 <iqubic> :k (=>)
16:15:31 <lambdabot> error: parse error on input ‘=>’
16:15:40 <jle`> hm, i guess we can think of dependent pattern matching as having a type in the clause that depends on a value
16:15:54 <jle`> so maybe that can count as dependently typed programming
16:15:54 <iqubic> gosh darn it Lambdabot. Please give me the info I want.
16:16:02 <jle`> (=>) is actually syntax
16:16:06 <jle`> it's kind of weird
16:16:07 <iqubic> Oh?
16:16:23 <jle`> if it had a kind it'd be something like (Constraint -> Type -> Type)
16:16:24 <iqubic> (=>) is syntax but (->) isn't?
16:16:33 <jle`> yeah :|
16:16:37 <iqubic> :k (->)
16:16:39 <lambdabot> * -> * -> *
16:16:43 <iqubic> WTF is life!?!
16:16:44 <jle`> well, (->) is syntax, but it is also a type constructor
16:16:52 <boxscape> :k () => ()
16:16:54 <lambdabot> *
16:17:00 <jle`> but (=>) isn't a first-class construct you can use
16:17:18 <boxscape> :t () :: () => ()
16:17:21 <lambdabot> ()
16:17:23 <iqubic> The issue is that (->) is so heavily overloaded.
16:17:48 <iqubic> fundeps, list comprehension, functions, types, and most likely a few more.
16:17:52 <jle`> indeed the overloading story with -> is quite a mess
16:18:03 <jle`> case statements too :)
16:18:11 <jle`> i think either -> or | is the most overloaded syntax
16:18:16 <iqubic> Lambda statements too.
16:18:20 <boxscape> and multiway if, though that's arguibly the same as case
16:18:23 <iqubic> > \x -> x
16:18:27 <lambdabot>  error:
16:18:27 <lambdabot>      • No instance for (Typeable p0)
16:18:27 <lambdabot>          arising from a use of ‘show_M27055438168811764105346’
16:18:45 <boxscape> View patterns
16:19:02 <iqubic> > let id = \x -> x in id 1
16:19:06 <lambdabot>  1
16:19:12 <iqubic> That took a while.
16:19:20 <boxscape> > case () of () -> () | (() -> ()) <- () -> ()
16:19:24 <lambdabot>  <hint>:1:21: error: parse error on input ‘|’
16:19:26 <boxscape> oops
16:20:06 <iqubic> Back to jle's blog post.
16:20:44 <iqubic> jle`: What the heck is this type signature: "withSingDSI :: SingDS s -> (SingDSI s => r) -> r"
16:20:44 <boxscape> (-.- I was trying to use () as a function anyway)
16:21:07 <iqubic> It looks like a continuation, but I'm not sure.
16:21:51 <jle`> a value of type (SingDSI s => r) can be any 'r', as long as 's' is an instance of SingDSI
16:22:13 <jle`> and it's kind of like continuation in a way
16:22:18 <iqubic> But 'r' and 's' are not even the same.
16:22:34 <jle`> yeah, constraints can be like that
16:22:43 <jle`> Typeable a => String
16:22:50 <iqubic> What the heck?
16:23:22 <jle`> but it might help if you start looking at instantiations of the type variables
16:23:37 <jle`> for exmaple, look at the type of doorStatus_
16:23:37 <boxscape> personally I find it a bit clearer if there's an explicit forall
16:23:42 <iqubic> Why can't you rewrite the type signature as "withSingDSI :: SingDSI s => SingDS s -> r -> r"
16:24:06 <jle`> the type of doorStatus_ is (SingDSI s => Door s -> DoorState)
16:24:18 <iqubic> Sure.
16:24:30 <jle`> so if we say `withSingDSI blahblah doorStatus_`
16:24:36 <Batzy> Prelude> g(n) = 10*g(n-1) + 2
16:24:37 <Batzy> Prelude> g(1) = 1
16:24:39 <Batzy> Prelude> g(2)
16:24:39 <jle`> then r ~ (SingDSI s => Door s -> DoorState)
16:24:41 <Batzy> *** Exception: <interactive>:19:1-8: Non-exhaustive patterns in function g
16:24:45 <Batzy> wtf is wrong with this..
16:25:07 <iqubic> What is the type of g?
16:25:09 <jle`> so that's withSingDSI :: SingDS s -> (SingDSI s => Door s -> DoorState) -> Door s -> DoorState
16:25:10 <ClaudiusMaximus> Batzy: needs more :{   }:
16:25:18 <Batzy> what?
16:25:19 <iqubic> Or that.
16:25:26 <ClaudiusMaximus> Batzy: otherwise you are defining 2 g, the second shadows the first
16:25:28 <jle`> Batzy: it's because thoes are treated as two different shadowed definitions that overwrite each other
16:25:37 <jle`> iqubic: so in that case, the s is in the 'r'
16:25:54 <Batzy> I'm confused
16:26:01 <Batzy> hwy does this treatment work with factorial and not this
16:26:09 <jle`> Batzy: it shouldn't work with factorial either if you type in that way
16:26:28 <iqubic> Why can't you rewrite the type signature as "withSingDSI :: SingDSI s => SingDS s -> r -> r"
16:26:33 <jle`> Batzy: since the definitions are on different <enter>'d lines, you're basically defining g1 n = 10 * g1(n-1)+2
16:26:33 <iqubic> Is that still valid?
16:26:38 <jle`> Batzy: and then g2 = 1
16:26:40 <ClaudiusMaximus> Batzy: if you put it in a file and load it then it shold work too
16:26:44 <jle`> and then calling g2 on the second line
16:26:54 <ClaudiusMaximus> Batzy: because files are parsed all at once
16:26:55 <jle`> iqubic: that's saying something different
16:26:56 <boxscape> Batzy: not directly related to your problem, but I'm pretty sure you have to define g(1) before g(n), otherwise it'll never terminate
16:27:22 <jle`> iqubic: that's saying "It's a SingDS s -> r -> r, as long as we have an isntance of SingDSI s"
16:27:31 <Batzy> haskell is crappy
16:27:34 <Batzy> okay what is the fix
16:27:50 <boxscape> g(n) = 10*g(n-1) + 2; g(1) = 1      works in ghci
16:28:07 <jle`> iqubic: but 'SingDS s -> (SingDSI s => r) -> r' is saying that given SingDS s, and a value that would require a SingDSI s instance, you can create that value. 
16:28:18 <iqubic> Right.
16:28:20 <iqubic> I see.
16:28:26 <jle`> but the difference is subtle
16:28:52 <iqubic> And then there's lockAnyDoor__
16:28:57 <jle`> and i agree it's not the clearest syntax
16:28:59 <iqubic> With two underscores.
16:30:31 <iqubic> I love how you got back around to mkDoor.
16:30:37 <iqubic> And made it safe with types.
16:31:09 <jle`> heh, it all comes around :)
16:32:16 <Batzy_> why is haskell garbage
16:32:17 <Batzy_> okay
16:32:20 <Batzy_> I missed the responses
16:32:26 <Batzy> how do I get this to work?
16:32:37 <boxscape> Batzy g(n) = 10*g(n-1) + 2; g(1) = 1 works in ghci
16:33:05 <boxscape> though you need to put the g(1) definition first, otherwise it'll loop forever
16:33:14 <iqubic> mkDoorFromString :: String -> Maybe (Door s)
16:33:22 <Batzy> why
16:33:25 <Batzy> how si that different
16:33:28 <Batzy> is*
16:33:34 <Batzy> why does it suddenly work this way
16:33:38 <boxscape> it always chooses the first pattern that matches
16:33:49 <boxscape> ah
16:33:58 <boxscape> it's written on a single line
16:34:02 <jle`> Batzy: the main problem is that every hard enter in ghci declares a new declaration
16:34:03 <boxscape> so ghci loads it all at once
16:34:04 <Batzy> no that didnt even work
16:34:11 <Batzy> haskell is garbage
16:34:13 <jle`> Batzy: so before you were essentially overwriting your previous definition of 'g'
16:34:20 <jle`> like saying n = 1, then n = 2 on the next line
16:34:30 <Batzy> Prelude> g(n) = 10*g(n-1) + 2; g(1) = 1
16:34:30 <Batzy> <interactive>:1:23: warning: [-Woverlapping-patterns]
16:34:30 <Batzy>     Pattern match is redundant
16:34:30 <Batzy>     In an equation for `g': g (1) = ...
16:34:34 <Batzy> garbage language
16:34:42 <boxscape> it's working though, that's just a warning
16:35:03 <Batzy> yes except g(2) gave me a stack overflow
16:35:08 <Batzy> garbage language
16:35:15 <boxscape> yes, as I said, you should put the g(1) definition first
16:35:18 <jle`> right, it's kind of like case statements in other languages -- it tries out each branch until it finds one that matches
16:35:18 <iqubic> Right. Because it's an infinite loop.
16:35:31 <iqubic> jle`: What is SomeDoor?
16:35:38 <jle`> so it'll always match the g n branch, and never reach the second possible branch
16:36:01 <jle`> iqubic: i think it's defined somewhere before it's referenced?
16:36:04 <jle`> hopefully
16:36:12 <iqubic> It is.
16:36:23 <iqubic> I just don't understand the purpose of SomeDoor.
16:36:25 <jle`> Batzy: so try g 1 = 1; g n = 10 * g (n - 1)
16:36:53 <jle`> iqubic: sometimes we don't care about the type parameter
16:37:04 <Batzy> jle`,  it works
16:37:06 <jle`> :D
16:37:10 <boxscape> Batzy what language are you most familiar with?
16:37:16 <Batzy> but nice we just decided to make this language as nonsensical as fucking possible
16:37:24 <Batzy> D, Python
16:37:24 <Batzy> C#
16:37:28 <Batzy> oh most familiar
16:37:28 <Batzy> Python I guess
16:37:30 <boxscape> okay
16:37:46 <Batzy> Yeh it has awful tail recursio
16:37:48 <Batzy> recursion*
16:37:51 <Batzy> not the best comparison
16:37:52 <iqubic> It's not nonsensical. It's just that in those languages the order of functions doesn't really matter.
16:37:54 <jle`> ah yeah, this is actually the behavior of switch/case in most languages too
16:38:20 <iqubic> Yes. Pattern Matching is a lot like evaluating a switch statement.
16:38:27 <jle`> usually in switch/case, the branches are tried out in order until one that matches is found
16:38:32 <jle`> that way we can encode logic/fallback cases
16:38:50 <Batzy> this is just a garbage language, I understand
16:39:07 <jle`> i believe C# switch case statements have the same semantics as well
16:39:15 <iqubic> It's really not garbage. It's just something that you aren't familiar with.
16:39:22 <iqubic> jle`:  they do.
16:39:40 <Batzy> It's pretty garbage
16:39:45 <jle`> each line defining a new thing is also the main behavior in most repl's as well
16:39:53 <cheater> jle`: sure, i just wanted to do something relatively non-unefficient.
16:39:53 <jle`> it's the default behavior in ruby, python, nodejs repls
16:40:16 <cheater> jle`: i ended up loading a BS, processing that via fold (i have to do that anyways), and building up a Seq with |>
16:40:19 <iqubic> Batzy: What specific aspect of the language do you think is bad?
16:40:35 <Batzy> you can't do anything without trouble shooting because it's bullshit
16:40:48 <jle`> Batzy: i try it out on python, and i get the same behavior
16:40:53 <jle`> def func1(x): return x;
16:40:57 <jle`> def func1(x); return x*2;
16:41:07 <jle`> func(3)   => returns 6, not 3
16:41:27 <Batzy> If I was going to design a more nonsensical way to define recursive functions
16:41:29 <Batzy> I couldn't do it
16:41:59 <boxscape> you don't have to use this syntax, you can define recursive functions in plenty of other ways
16:42:11 <jle`> so how would you design a way to define recursive functions?
16:42:29 <jle`> g n = if n == 1 then 1 else 10 * g (n-1), maybe?
16:42:33 <jle`> that's valid in haskell too :)
16:42:37 <iqubic> Batzy: When writing a recursive function in C# you usually put the base case first, with an if statement.
16:42:49 <jle`> @let myFunc n = if n == 1 then 1 else 10 * myFunc (n - 1)
16:42:53 <lambdabot>  Defined.
16:42:55 <jle`> > myFunc 3
16:42:57 <lambdabot>  100
16:43:04 * jgt is amazed by the patience of some of the people in this room
16:43:07 <Batzy> I think you guys are mad that your language is garbage
16:43:16 <iqubic> In C# if you don't put the base case first, you get an infinite loop.
16:43:19 <Batzy> need to put the definition on the same line? like come the fuck on
16:43:49 <jle`> it's mostly an interactive repl thing; you can put definitions on more than one line in a source file
16:43:50 <boxscape> generally speaking I'd avoid writing complicated definitions inside ghci, and rather load them from a file, where you don't have to write them on one line
16:44:02 <jle`> it's the same in most languages, as well -- defining multiple line things in a repl just isn't fun
16:44:16 <jle`> usually the multi-line functions you'd write in a file, and then load it up in a repl for interactive usage
16:44:18 <iqubic> Batzy: If you tried to write the same sort of function in the python repl, you'd have to write it all on the same line there.
16:44:58 <Batzy> Not really
16:45:00 <Batzy> sort of
16:45:07 <Batzy> but also not really
16:45:18 <iqubic> Can you explain why you say "not really"?
16:45:24 <jle`> python repl has multiline input turned on by default if it knows that you aren't at the end of a declaration
16:45:32 <iqubic> Ah. I see.
16:45:33 <Batzy> ^
16:45:37 <iqubic> I didn't know that.
16:45:52 <jle`> ghci has multiline input too, but it's off by default
16:46:31 <jle`> :set +m should turn it on if you find yourself often writing multiline declarations in ghci
16:46:43 <jle`> but even still, in python repl, multiline declarations aren't very fun to write
16:46:48 <jle`> it messes with history and tab completion
16:47:07 <jle`> it's not something i'd recommend people to do :)
16:47:57 <iqubic> It seems like batzy is most used to having multiline input.
16:49:07 <jle`> cheater: i don't think that'd be too different than using readFile and Seq.fromList
16:49:27 <freeman42x> looking for a solution to currently just running `stack build` from Haskell, what would be best: https://twitter.com/razvan_panda/status/1163957114206924800   ?
16:50:27 <jle`> freeman42x: if you're looking for an example, running stack build is something i do from this script https://github.com/mstksg/jle-utils/blob/master/app/git-haddocks.hs#L88
16:50:27 <Batzy> ALso used to languages that aren't garbage
16:50:35 <Axman6> freeman42x: I don't understand what the problem is
16:51:37 <Axman6> @where ops
16:51:37 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw mniip monochrom quicksilver shachaf shapr ski
16:52:12 <MarcelineVQ> Axman6: it's okay, haskell is garbage collected
16:52:13 <freeman42x> Axman6, it's a question - which would be best for my use case?
16:52:20 <jle`> freeman42x: i would probably just use process
16:52:31 <jackdk> freeman42x: i don't think that was directed at you
16:52:32 <jle`> turtle is a whole shell scripting framework
16:52:38 <Axman6> freeman42x: in that case I don't see why you wouldn't use process
16:52:47 <Axman6> yeah the ops call was directed at Batzy
16:52:49 <jle`> you don't want to do shell scripting, you just want to shell out a single command :)
16:53:18 <Axman6> process ships with GHC right?
16:53:33 <freeman42x> jle`, true, currently I just want to shell out one command, but I might need more shell stuff later, so I see no reason not to use something like Shelly or Turtle
16:53:49 <jgt> Batzy: is somebody forcing you to use Haskell?
16:54:22 <jle`> freeman42x: sounds like a premature abstraction kind of situation
16:54:32 <boxscape> What does MonoLocalBinds do?
16:54:44 <jle`> boxscape: it's like a restricted version of the DMR
16:54:48 <jle`> monomorphism restriction
16:54:53 <boxscape> ..uh what's DMR?
16:54:54 <jle`> it only applies to "local" bindings
16:54:57 <jle`> @where dmr
16:54:58 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
16:55:13 <jle`> so bindings in let statements, and not top-level bindings
16:55:21 <freeman42x> jle`, I don't want to waste time switching from process lib code to other library when I know that it is pretty probably I will need to run other shell type stuff
16:55:25 <boxscape> where does the D come from?
16:55:46 <jle`> "dreaded", heh
16:55:50 <boxscape> ah
16:55:52 <boxscape> okay, thankss
16:56:17 <jle`> it's an old in-joke because the first time people encounter the monomorphism restriction first-hand, it's in an "i don't want it" kind of way
16:56:31 <boxscape> I see
16:56:37 <Axman6> when do people want it?
16:56:39 <jle`> even though they have probably benefited from it without knowing more often
16:56:49 <jle`> it's just when it works, you don't realize it :)
16:56:56 <jle`> but maybe it's time to shed the in-joke
16:56:57 <boxscape> that makes sense
16:57:22 <jle`> for example if you say let x = (some complex computation) in ..., you only want to compute x once
16:57:23 <MarcelineVQ> jle`: just say it stands for Delightful when asked
16:57:28 <jle`> haha
16:57:32 <boxscape> so ghci is warning me to enable MonoLocalBinds because the expressions entered in ghci are kind of like let statements?
16:57:59 <cheater> i want to iterate from 1 to 10 and, inside that, print the number. this is because the outer loop is for formatting. how do i best do this?
16:58:07 <jle`> ghci has the Delightful MR turned off by default
16:58:17 <boxscape> ah, right I remember something like that
16:58:32 <jle`> the problem with keeping things 'too polymorphic' is that ghc can't cache polymorphic values
16:58:38 <boxscape> so MonoLocalBinds is only necessary if DMR is off, yes?
16:58:53 <jle`> yeah. well, it's never necessary, but it can save recomputation
16:58:57 <boxscape> right, okay
16:58:59 <iqubic> jle`: Isn't is Dreaded, not Delightful?
16:59:07 <jle`> see MarcelineVQ's suggestion :)
16:59:07 <boxscape> heh
16:59:28 <jle`> cheater: if you have a function (Int -> IO ()), you can mapM_ printingFunc [1..10]
16:59:45 <jle`> there's also a common idiom for writing it directly without a helper function, forM_ [1..10] $ \i -> ...
17:01:17 <jle`> (where the lambda is Int -> IO ())
17:09:36 <boxscape> hm unfortunate but I suppose understandable that type level || and && are not short circuiting. That would offer easy ways to improve typechecking performance in some cases
17:09:44 <boxscape> (like, say, when you're checking a large number for primality)
17:09:56 <boxscape> or rather, a potentially large number
17:12:38 <cheater> jle`: i don't. i want to, basically, iterate over i and j from 1 to 10, and at each step j print (i, j), and at step of i, print a newline.
17:13:10 <Axman6> wounds like forM_ to me
17:13:13 <Axman6> sounds*
17:13:22 <jle`> yeah, you can do nested forM_
17:13:44 <jle`> forM_ [1..10] $ \i ->
17:13:51 <jle`>   forM_ [1..10] $ \j -> ...
17:14:02 <jle`> but also by "if you have", i meant "if you write"
17:25:17 <cheater> yes, i understood that part :)
17:25:23 <cheater> :t forM_
17:25:27 <lambdabot> (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
17:25:32 <cheater> thanks
17:44:29 <freeman42x> how can I execute the `stack build` command using https://hackage.haskell.org/package/turtle-1.5.14/docs/Turtle-Tutorial.html ?
17:45:37 <freeman42x> oh... is it by using the `shell` command? https://hackage.haskell.org/package/turtle-1.5.14/docs/Turtle-Tutorial.html#g:7
17:46:14 <Axman6> freeman42x: any reason why you'd prefer to use turtle?
17:46:52 <freeman42x> Axman6, "I don't want to waste time switching from process lib code to other library when I know that it is pretty probably I will need to run other shell type stuff"
17:47:12 <Axman6> Ah I missed that
17:48:18 <Axman6> well shell "stack" "build" looks lik eit would work
17:49:39 <M2en[m]> I feel like I'm using `if ... then ... else` too much, like I'm can't let go of imperative style.
17:49:49 <M2en[m]>  * I feel like I'm using `if ... then ... else` too much, like I can't let go of imperative style.
17:50:09 <Axman6> M2en[m]: How are you using it?
17:51:36 <M2en[m]> All of the time. I think maybe it would be more elegant to just use `case ... of`.
17:51:51 <Axman6> can you give an example of how you use it though?
17:52:05 <Axman6> I almost never use if statements in Haskell
17:52:26 <wildtrees[m]> Use case and the move to maybe or eithers and use fmap and join with them or bind or do notation
17:52:47 <wildtrees[m]> Then move to evrn
17:53:47 * M2en[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/nJDiFhJGpAUTzxgOLkUOfeCS >
17:53:57 <M2en[m]>  * `countTheBeforeVowel :: String -> IntegercountTheBeforeVowel s = case ws of [] -> 0 (w:(n:s)) -> if w == "the" && vowelInitial n then 1 + countTheBeforeVowel (unwords s) else countTheBeforeVowel (unwords s) where ws = words s`
17:55:03 <M2en[m]> countTheBeforeVowel :: String -> Integer
17:55:07 <Axman6> well you can use case ws of ("the":n:s) -> ...; (w:n:s) -> ...;  -> ...;
17:55:38 <M2en[m]> Ah that's much simpler
17:55:49 <Axman6> uh, or case ws of ("the":n:s) | vowedInitial n -> ... |  otherwise -> ...
17:56:16 <M2en[m]> I guess I didn't realize how much you can do with pattern matching
17:56:21 <Axman6> I rarely find that I need to use == in Haskell either
17:56:38 <M2en[m]> Yeah it seemed like a style smell to me
17:57:26 <M2en[m]> Thanks for the advice, I'll try to use case and drop the double equals
17:58:32 <freeman42x> how can I fix this issue? https://i.imgur.com/gooqyjt.png
18:00:41 <EvanR> in that case the == is being used implicitly, good to keep in mind in case == has some costly or oddball implementation for the type in question
18:04:49 <lyxia> freeman42x: you are constructing a String because you used ++, but shell expects a Text
18:06:03 <lyxia> use Text.append instead of (++)
18:06:06 <freeman42x> lyxia, I get that but I am not sure how to fix it. Do I need to use Data.Text.pack or Data.Text.unpack?
18:08:21 <lyxia> "cd " <> stackProjectLocation
18:10:47 <freeman42x> lyxia, awesome, thank you
18:10:56 <freeman42x> @karma+ lyxia
18:10:56 <lambdabot> lyxia's karma raised to 16.
18:11:19 <EvanR> its bad luck to reveal the karma rating
18:30:55 <Axman6> Someone got annoyed with me once and decided to make mine very negative
18:31:00 <Axman6> it was a sad day
18:33:17 <lyxia> Axman6++
18:33:50 <Axman6> <3
18:34:27 <M2en[m]> Axman6++
18:34:35 <M2en[m]> Have some more
18:35:05 <mjrosenb> Axman6++
18:35:24 <Axman6> Is this IRC equivalent of reddit's "This will only get 7 upvotes" karma whoring? 
18:35:34 <freeman42x> not sure how to fix this `stack build` issue: https://i.imgur.com/Slf9M2R.png
18:35:37 <M2en[m]> Yes :)
18:36:49 <Axman6> M2en[m]: I'm pretty sure you wan tto use shell "stack" "build" (though that's unrelated to your error)
18:36:56 <Axman6> which OS are you on?
18:38:35 <M2en[m]> Is anyone here getting paid to write Haskell?
18:38:44 <Axman6> Me
18:39:03 <M2en[m]> What did you write today?
18:41:11 <Axman6> Todat, not much yet
18:43:56 <pinecamp> hello all
18:44:52 <pinecamp> I have a function with the signature Response (ByteString) -> Text. is there a way for me to use this inside the IO monad, to turn an IO (Response (ByteString)) into IO (Text) ?
18:45:12 <pinecamp> I feel like the answer must be simple, but I just don't know it yet
18:46:29 <Axman6> that's fmap
18:48:08 <pinecamp> Axman6: so if a :: Response (ByteString) -> Text, and b :: IO (Response (ByteString)), my solution is simply a <$> b?
18:48:56 <Axman6> yep
18:49:05 <Axman6> or fmap a b, whichever you prefer
18:49:25 <pinecamp> awesome--thanks so much! :) 
18:50:42 * hackage libmodbus 1.0.0 - Haskell bindings to the C modbus library  https://hackage.haskell.org/package/libmodbus-1.0.0 (JoeyHess)
18:53:21 <freeman42x> Axman6, I'm using NixOS. The issue I had was that shell "cd ..." empty part did not actually change the pwd
18:57:01 <M2en[m]> Beautiful
19:04:58 <freeman42x> how do I obtain just a FilePath and not an IO FilePath? https://i.imgur.com/R28fEAe.png
19:06:04 <cheater> I have a Map (Int, Int) a. How can I turn it into a Map Int (Map Int a)?
19:06:45 <freeman42x> oh, I figured it out: https://i.imgur.com/vLur8Ic.png
19:07:37 <solonarv> cheater: the straightforward solution is to turn it into a list, do some processing, and turn the resulting list back into a map (of maps)
19:08:39 <solonarv> like so: Map.fromListWith (Map.union) [(x, Map.singleton y v) | ((x,y), v) <- Map.toAscList inputMap]
19:09:09 <cheater> solonarv: hmm yes
19:09:41 <cheater> but i could also use partitionWithKey
19:10:13 <solonarv> I don't see how that helps you
19:17:52 <cheater> i can just check fst of key equals what i want
19:18:08 <cheater> and that partitions my stuff
19:19:22 <rajivr___> I am new to Haksell. I was wondering why does `:t ([2, 4, 6] :: [Product Int])` type check when the type of `[2, 4, 6]` is actually  `forall a. Num a => [a]`? 
19:19:54 <rajivr___> `Product` is from `Data.Monoid`
19:20:18 <rajivr___> Does Haksell also have something similar to a `From` trait in Rust?
19:21:37 <freeman42x> how can I run `stack build` using Turtle and get the console output from it inside Haskell? https://hackage.haskell.org/package/turtle-1.5.14/docs/Turtle-Tutorial.html
19:26:22 <cheater> rajivr___: look here https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Monoid.html#t:Product
19:26:34 <cheater> it has a Num class defined. Num a => Num Product a
19:26:47 <cheater> it means that if a has class Num defined, then so does Product a
19:26:58 <cheater> this means that Product Int has the Num class defined, since Int does
19:27:09 <cheater> the Num class has the method fromInteger
19:27:40 <cheater> i think that's what is being used there. numbers in literals are overloaded.
19:28:42 * hackage cuckoo 0.2.0.0 - Haskell Implementation of Cuckoo Filters  https://hackage.haskell.org/package/cuckoo-0.2.0.0 (larsk)
19:28:55 <rajivr___> cheater: Thanks a lot! :-) Let me take a look.
19:30:46 <freeman42x> got it: https://i.imgur.com/Qp6sCba.png
19:31:04 <freeman42x> just need to figure out how to actually use that value as Strings and not Line
19:43:38 <freeman42x> how do you: putStrLn Data.Text ?
19:44:32 <monochrom> Find it in Data.Text.IO
19:44:56 <solonarv> you probably want to import it qualified, since it has the same name as the putStrLn from the Prelude
19:49:06 <freeman42x> @karma+ monochrom
19:49:06 <lambdabot> monochrom's karma raised to 137.
20:05:05 <lyxia> freeman42x++   <- write it like this to not trigger lambdabot
20:05:53 <freeman42x> lyxia, nice, but... but how do we know that it work? :(
20:06:46 <freeman42x> how can I pattern match and get the success line or the error line? https://i.imgur.com/9E3lIxU.png
20:17:14 <lyxia> eitherSuccessOrErrorLines <- inshellWithErr ...
20:17:47 <lyxia> you might want to go through a Haskell tutorial
20:20:36 <freeman42x> lyxia, you can't do this: "eitherSuccessOrErrorLines <- inshellWithErr"
20:25:47 <lyxia> why not
20:30:04 <freeman42x> lyxia, because you are in the IO monad
20:35:01 <cheater> i would like to write a depth first search in haskell that could lead me to visit the same nodes several times. i would not like to process them on subsequent occasions. how can i accomplish this? i would do something like dfs (Node id connectedNodes) = if not (id in visited nodes) (add id to visited nodes) dfs <$> connectedNodes    i'm just not sure how to pass around the "visited" or use some sort ...
20:35:07 <cheater> ... of "global ref"
20:35:40 <lyxia> freeman42x: then be in the Shell monad and use liftIO if you want to do IO stuff
20:36:01 <dmwit> cheater: Seems like a nice application for a State monad.
20:36:03 <freeman42x> lyxia, yup, that is correct, but I do not need that... or do I?
20:36:11 <cheater> dmwit: how would you do this with the state monad?
20:36:11 <dmwit> Keep your visited-set in the state component.
20:36:12 <freeman42x> lyxia, I'm stuck on this: https://i.imgur.com/E1TLMFf.png
20:36:25 <cheater> i'm not sure how to use state together with a recursive function.
20:36:36 <cheater> yes, i thought of that, but not sure how
20:36:56 <dmwit> cheater: I would do it like this: https://github.com/dmwit/nurse-sveta/blob/master/src/Dr/Mario/Sveta.hs#L259-L263 =P
20:37:16 <cheater> oh https://wiki.haskell.org/State_Monad
20:37:23 <cheater> playGame is an example
20:37:24 <zeta_0> how do i find what library i need to import for functions that i want to use in haskell ?
20:38:14 <cheater> use hoogle
20:38:19 <cheater> often cabal will tell you on its own
20:40:42 <cheater> thank you dmwit :)
20:40:57 <ysangkok> Phyx-: with compiling secp256k1-haskell for windows? i don't know, I assumed fog must have had issues with it since he resorted to trying getting alternatives working
20:43:00 <lyxia> freeman42x: it really has to use a bind ("<-") somewhere, so you need a Shell do-block somewhere.
20:47:10 <zeta_0> thanks
20:50:18 <freeman42x> what do you call that thing where you inline an expression and that is supposed to be functionally equivalent? is that referential transparency?
20:50:42 <lyxia> yes
20:52:03 <freeman42x> hmm, might be wrong, doesn't seem to fit the description: https://wiki.haskell.org/Referential_transparency
20:55:19 <freeman42x> lyxia, "you need a Shell do-block somewhere" could you give a concrete example please?
20:57:02 <freeman42x> are there any online Haskell editors that allow installing custom libraries?
21:15:48 <freeman42x> created a ticket for the issue: https://stackoverflow.com/q/57584340/750216
21:18:31 <MarcelineVQ> You forgot to include a question in your question
21:19:12 * hackage markov-realization 0.3.1 - Realizations of Markov chains.  https://hackage.haskell.org/package/markov-realization-0.3.1 (alexloomis)
21:20:44 <lyxia> freeman42x: https://dpaste.de/0B3r
21:25:36 <freeman42x> lyxia, it gives error: https://i.imgur.com/JKqqDsm.png
21:29:10 <dmwit> That is a puzzling error.
21:29:20 <dmwit> I wonder what function it thinks is being applied there?
21:29:40 <dmwit> oh lol
21:29:45 <dmwit> You need to indent Left and Right more
21:30:50 <dmwit> (Farther than the beginning of stackBuildOutput.)
21:31:28 <dmwit> Despite the fact that I'm confident you need to fix that, it's not clear what mistaken thing it is thinking as a result of that mistake that is producing that error.
21:31:33 <dmwit> It's a thinker.
21:32:31 <lyxia> heh
21:33:03 <freeman42x> dmwit, yeah, that was it, the case indentation
21:33:30 <freeman42x> lyxia, it is still giving errors :( https://i.imgur.com/9HRN84h.png
21:34:17 <freeman42x> lyxia, current version: https://gist.github.com/razvan-panda/6895e15d89486e966d6ce2a4ae63d279
21:34:58 <lyxia> why are you sticking "strict" in random places
21:36:13 * hackage incremental 0.1 - incremental update library  https://hackage.haskell.org/package/incremental-0.1 (FumiakiKinoshita)
21:41:13 * hackage cuckoo 0.2.0.1 - Haskell Implementation of Cuckoo Filters  https://hackage.haskell.org/package/cuckoo-0.2.0.1 (larsk)
21:45:09 <freeman42x> lyxia, how do I call `myFunction :: Shell ()` in main :: IO ()?
21:45:39 <freeman42x> almost got it figured out, just need to call it in main
21:48:49 <iqubic> You need a function of type 'Shell () -> IO a' in order to do that.
21:50:12 * hackage markov-realization 0.3.2 - Realizations of Markov chains.  https://hackage.haskell.org/package/markov-realization-0.3.2 (alexloomis)
21:52:34 <lyxia> freeman42x: sh myFunction
21:52:58 <lyxia> freeman42x: have you read the tutorial https://hackage.haskell.org/package/turtle-1.5.14/docs/Turtle-Tutorial.html
21:53:30 <freeman42x> lyxia, yeah, I gone through the tutorial, I think I needed to use the function view. it is compiling but the console output is wrong
21:56:00 <freeman42x> lyxia, it is giving me this weird output: https://i.imgur.com/QaFagAC.png
21:56:09 <freeman42x> see, all those () interspersed with normal output
21:56:30 <lyxia> because you're using view
21:57:22 <lyxia> view prints the result of the action you give it.
21:57:30 <lyxia> you gave it the action myFunction
21:57:36 <lyxia> the result of myFunction is a ()
21:57:39 <lyxia> so view prints a ()
21:58:26 <lyxia> BTW you can remove line 42 and just replace "output" with "stackBuildOutput"
22:01:05 <freeman42x> lyxia, not possible to replace it: https://i.imgur.com/MIgVw8a.png
22:01:44 <puffnfresh> you want lineToText
22:01:46 <puffnfresh> probably
22:02:59 <inkbottle> Where is the cabal file of http://hackage.haskell.org/package/haskell-src-1.0.1.6/docs/Language-Haskell-Parser.html
22:03:04 <lyxia> oh yeah, lineToText
22:03:34 <freeman42x> puffnfresh, oh hey! :D good to see you
22:03:43 <puffnfresh> freeman42x: putStrLn (lineToText (bifold out))
22:03:47 <puffnfresh> I'd probs do something like that
22:06:44 <freeman42x> puffnfresh, lineToText works great, like this for example: https://i.imgur.com/l2LbNqt.png
22:07:09 <puffnfresh> yeah ship it mate
22:08:25 <freeman42x> puffnfresh, the only thing it is currently doing is do `stack build` and output to console... which is broken cause of ()s. So can't ship yet :/
22:08:54 <puffnfresh> what's this about ()?
22:11:36 <lyxia> applying view to myFunction :: Shell ()
22:11:40 <freeman42x> puffnfresh, yeah, much better with your change: https://gist.github.com/razvan-panda/6895e15d89486e966d6ce2a4ae63d279
22:11:58 <freeman42x> lyxia, so I can't use view cause it does those ()s. What can I use then?
22:12:16 <lyxia> sh
22:12:30 <puffnfresh> view :: (MonadIO io, Show a) => Shell a -> io ()
22:12:35 <puffnfresh> see how it says "Show a"
22:12:42 <puffnfresh> because it prints that "a"
22:12:48 <puffnfresh> in your case the "a" is "()"
22:12:53 <puffnfresh> therefore it prints ()
22:13:14 <puffnfresh> sh :: MonadIO io => Shell a -> io ()
22:13:27 <puffnfresh> notice that "sh" does not require "Show a" so it can't possibly print it
22:17:43 <freeman42x> puffnfresh, thank you. I managed to figure out sh is needed by myself also puffnfresh++ lyxia++
22:21:45 <freeman42x> at this point I got working a program that runs `stack build` and obtains a Text value of the console output from it. Thank your very much for your help, puffnfresh, lyxia, etc.
22:22:50 <dmwit> inkbottle: Click "contents" at the top, then "package description".
22:23:45 <dmwit> inkbottle: (These are general instructions that work from the haddocks of any module.)
22:37:42 * hackage hslua 1.0.3.2 - Bindings to Lua, an embeddable scripting language  https://hackage.haskell.org/package/hslua-1.0.3.2 (tarleb)
22:38:08 <ski> jle` : s/can't cache polymorphic/can't cache constrained/
22:38:42 * hackage shh 0.7.0.3 - Simple shell scripting from Haskell  https://hackage.haskell.org/package/shh-0.7.0.3 (lukec)
22:48:42 * hackage salak 0.3.5 - Configuration (re)Loader and Parser.  https://hackage.haskell.org/package/salak-0.3.5 (leptonyu)
22:49:42 * hackage salak-toml 0.3.5, salak-yaml 0.3.5 (leptonyu): https://qbin.io/ri-timer-3hi1
23:12:41 <dminuoso> Can we ban data-default-class from hackage please?
23:13:36 <dminuoso> Not only is it ill-principled, but package have an incredibly annoying tendency of not giving you a binding for what they consider good "default settings", forcing you to constantly add that package to your dependency list just to get what the package could have given you in some simple "defaultSettings" binding. :|
23:15:06 <jackdk> I only use it because everyone else uses it. I would rather write defaultConfig or defaultReaderConfig or defaultExporterSettings or whatever
23:15:28 <jackdk> I also prefer the values in https://hackage.haskell.org/package/acme-default
23:15:38 <EvanR> i used it once but removed it after getting flamed
23:16:04 <dminuoso> jackdk: acme-default really does capture what's wrong with data-default-class well. I miss ertes :)
23:16:58 <jackdk> I do wish that instance Default String had been included, with the full text of Moby Dick
23:17:09 <opqdonut> :D
23:18:10 <EvanR> you're just trying to get included!
23:18:30 <EvanR> that would be a pretty handy default string you have to admit
23:20:33 <jackdk> someone else filed an issue about it, and I heard about it in a georgew talk. the fact class Default makes some people go "from hell's heart I stab at thee" is an added bonus
23:20:34 <dminuoso> jackdk: You could follow the hackage procedure, contact admin@hackage.haskell.org and make a suitable adjustment to include that overlapping instance for String. 
23:20:51 <dminuoso> I'd fight for you.
23:21:18 <dminuoso> jackdk: What acme-default is really lacking, is IncoherentInstances.
23:21:25 <dminuoso> For maximum fun.
23:23:01 <jackdk> :set -XYoloInstances
23:25:55 <dminuoso> What's even worse, is if the only way to obtain some data is via def.
23:30:28 <DigitalKiwi> "Some people are satisfied with situation and others are not." lol (from the wiki for referential transparency)
23:30:49 <dmwit> I like Default.
23:31:25 <DigitalKiwi> "a third group of people are indifferent"
23:33:02 <EvanR> duck duck go just gave me the simple english wikipedia for referential transparency
23:33:03 <dmwit> I don't understand what the name `defaultConfig` buys you that `default @Config` doesn't.
23:33:10 <EvanR> is this ironic or
23:34:08 <DigitalKiwi> https://wiki.haskell.org/Referential_transparency
23:34:09 <dmwit> I also like the `instance a ~ () => Default (FancyRecord a)` trick for forcing somebody to initialize certain fields.
23:34:37 <dminuoso> dmwit: So there's, for example, an ⌜instance Default Int⌝ -- what does it give you? What makes 0 a better default than 1, 99 or 4096?
23:34:42 <dmwit> (This is not a point in favor of Default vs. not-Default, it's just a trick I like.)
23:34:55 <DigitalKiwi> dmwit: well it's 2 fewer characters
23:35:01 <EvanR> the great thing about defaults is there are so many to choose from
23:35:18 <dmwit> dminuoso: Yes, yes, everybody makes this complaint. But here's the thing: I don't care.
23:35:30 <dminuoso> dmwit: Well either way. You should at least re-export def then.
23:35:38 <dmwit> I have to know (or have an abstraction of) the implementation of all the other instance methods I use. Why should def be different?
23:35:47 <dminuoso> I dont want to have to depend on an extra package just for the sake of using yours.
23:36:16 <dmwit> So I have to know which choice the writer of `instance Default Int` made. So what? That's the same situation I'm in with every other instance I use on a daily basis.
23:36:28 <dmwit> dminuoso: Well, sure, I'm in favor of re-export it.
23:37:05 <EvanR> is there a case where you want to take a polymorphic Default
23:37:19 <dminuoso> dmwit: I think another issue is that if you want to ship multiple defaults. Say you have some HTTP settings, one with tls and one without. Do you newtype just to be able to have two Default instances?
23:37:25 <dmwit> EvanR: I haven't seen one.
23:37:38 <dminuoso> dmwit: Im not sure what Default realistically buys you, since it removes the ability to document intend on the naming of the identifier.
23:37:46 <EvanR> i mean... 
23:37:46 <dmwit> dminuoso: Nah. You have one named tls and one named http.
23:37:47 <EvanR> :t maybe
23:37:49 <lambdabot> b -> (a -> b) -> Maybe a -> b
23:38:14 <dmwit> dminuoso: I'm not, like, mandating that every type have a Default instance or anything like that.
23:38:20 <EvanR> Default b => (a -> b) -> Maybe a -> b
23:38:35 <dminuoso> dmwit: Of course not, we can agree on that. :)
23:38:38 <dmwit> You're not *obligated* to use Default just because there is a possible collection of default settings.
23:38:58 <dmwit> If there really are two wildly popular choices of defaults... just don't use Default. NBD
23:40:02 <dmwit> I like Monoid, too, even though most types have an unbearably huge number of possible monoid instances.
23:40:52 <dmwit> And it's okay to have an API that includes operations that happen to form a monoid without making them part of an instance.
23:40:57 <dmwit> We've got (&&), we've got (||).
23:41:45 <dmwit> (And we have (/=), too, but no popular instance that uses that as its operator, unlike (&&) or (||).)
23:41:59 <dminuoso> dmwit: Perhaps one good measure of the usefulness of a typeclass, is how useful it is to write polymorphic code over it. What can you do with some ⌜f :: Default def => ..." realistically?
23:42:17 <dmwit> Another good measure is "do I find it useful?".
23:42:26 <dmwit> And I've used Default on a handful of occasions and found it useful.
23:42:26 <EvanR> Default seems to me like the infamous class Lookup c k a, lookup :: k -> c -> Maybe a
23:42:38 <EvanR> seemingly obviously useful but is it
23:43:16 <dminuoso> EvanR: It sort of seems like a cut down Representable :P
23:43:25 <dmwit> It's just *handy* to have a part of your API where people look at the instance list and go, "hey, cool, I don't necessarily have to think about how to set all the fields of this thing".
23:43:45 <dmwit> "I can get something running and think about it later if it doesn't work the way I want."
23:44:02 <dmwit> (...and think about it never if it does work the way I want!)
23:44:03 <dminuoso> dmwit: Yeah but you dont need Default for that. If I just give you "defaultSettings" instead, that same goal has been reached.
23:44:17 <dminuoso> But sure, it saves you from finding a name for it.
23:44:33 <dmwit> Right. I get to share the same name, and don't have to do some stupid Hungarian notation.
23:44:36 <dminuoso> Either way, I didn't mean to kick off a discussion about this. I kind of feel bad now. :)
23:44:58 <dminuoso> Or perhaps I did. Mmm
23:45:19 <EvanR> the discussion size inversely proportional to the importance of the feature
23:45:53 <dmwit> I like Default, Foldable ((,) a), tabs, and orphan instances. =)
23:45:56 <dmwit> bring it
23:47:26 <dminuoso> dmwit: This is out of curiosity - I really do want to understand your motivation here: Why do you like orphan instances?
23:48:18 <dminuoso> I surely dont need to bring the common arguments why they are hated, you know all about them.
23:51:16 <dmwit> They are needed when you want to bring together a package that provides a data type you like and a different package that provides a class you like.
23:51:23 <dmwit> The main complaint is that if two people want to do this, they might clash.
23:51:42 * hackage boots-app 0.1.0.6 - Startup factories using IoC monad  https://hackage.haskell.org/package/boots-app-0.1.0.6 (leptonyu)
23:51:43 <dmwit> The solution is to have a central repository of orphan instances that's easy to report to and search.
23:51:56 <dmwit> We don't have that, which is a shame. Hackage could provide that service, with some engineering effort.
23:52:35 <dmwit> In the absence of such a service, I agree things are occasionally problematic. But in my experience the problems are much rarer than people seem to worry about.
23:53:13 <dmwit> So basically it boils down to this: I think the complaints are overblown; essentially the same opinion I hold about the complaints against Default.
23:53:19 <dmwit> The complaints are real, but overvalued.
23:54:21 <dminuoso> dmwit: So you'd argue the benefits of just writing an orphan instance greatly outweigh the consequences of the odd incoherent program?
23:54:48 <dminuoso> (I mean the argument that hackage could provide such a solution is uninteresting because it doesn't right now)
