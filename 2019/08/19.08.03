02:08:36 <jgt> > all [ True, True 
02:08:38 <jgt> ]
02:08:40 <jgt> damn
02:08:41 <lambdabot>  <hint>:1:18: error:
02:08:41 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
02:08:46 <jgt> > all [ True, True ]
02:08:49 <lambdabot>  error:
02:08:49 <lambdabot>      • Couldn't match expected type ‘a -> Bool’
02:08:49 <lambdabot>                    with actual type ‘[Bool]’
02:09:08 <jgt> :i all
02:09:16 <jgt> @i all
02:09:16 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect irc-password irc-persist-connect v @ ? .
02:09:23 <jgt> -_-
02:10:07 <jgt> > and [ True, True ]
02:10:10 <lambdabot>  True
02:10:52 <lavalike> jgt: I always get them mixed up too!
02:11:07 <jgt> I'm wondering which other crappy language has confused me
02:11:18 <jgt> EczemaScript? Ruby?
02:12:00 <lavalike> all any, and or, it always makes sense post hoc
02:13:16 <jgt> I'm using this to eliminate long && chains
02:14:02 <jgt> and I had thought "if this list of conditions are _all_ true…"
02:14:11 <lavalike> same
02:24:16 <ski> @type all :: (a -> Bool) -> [a] -> Bool
02:24:18 <lambdabot> (a -> Bool) -> [a] -> Bool
02:24:21 <ski> @type all
02:24:23 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
02:24:34 <ski> % :t all @[]
02:24:34 <yahb> ski: (a -> Bool) -> [a] -> Bool
02:25:00 <ski> there is no `info' command in lambdabot
02:25:07 <ski> @info all
02:25:07 <lambdabot> all
02:27:05 <lavalike> @index all
02:27:06 <lambdabot> Data.Foldable, Data.List, Prelude, GHC.OldList, Data.ByteString.Lazy.Char8, Data.ByteString.Lazy, Data.ByteString.Char8, Data.ByteString
02:27:29 <ski> @src all
02:27:29 <lambdabot> all p = and . map p
02:27:32 <ski> @src any
02:27:33 <lambdabot> any p = or . map p
02:28:04 <lavalike> .oO( .: )
02:28:14 * ski grins
02:28:45 * ski can't recall when they made up the name `.:'
02:29:06 <lavalike> must have been many years ago
02:29:21 <ski> yea
02:29:46 <ski> perhaps around 2006 or something
02:38:53 <jgt> this is a little weird http://ix.io/1Qsi
02:39:05 <jgt> how does that work? The non-exhaustive guard
02:39:39 <lavalike> it's like an and
02:39:40 <jgt> Nothing | riskMarketplaceState risk ->
02:39:48 <jgt> oh
02:39:55 <lavalike> of the Nothing matches, it filters down to only those that evaluate the guard to true
02:40:29 <jgt> `riskMarketplaceState risk` is a Bool in this context
02:41:13 <jgt> so it's like "if `mbRar` is `Nothing` and `riskMarketplaceState risk` is `True`, do database stuff, otherwise do nothing"
02:41:16 <jgt> is that right?
02:41:19 <lavalike> yeap
02:41:27 <lavalike> it's the same as `when (isNothing mbRar && riskMarkeplaceState risk) $ runDB ..`
02:41:58 <jgt> I think I prefer the `when`
02:42:51 <jgt> it's a little frustrating this thought of "is this construct weird? Or do I just not know enough Haskell?"
02:43:49 <lavalike> there are many ways to go about this
02:45:38 <jgt> lavalike: I refactored that function to this: http://ix.io/1Qsn
02:46:23 <jgt> this is part of a refactoring where I change `riskMarketplaceState risk` from a `Bool`, to avoid boolean blindness
02:46:58 <lavalike> jgt: I'd have guessed it's sort of the opposite, i.e. when Nothing is returned from the DB it has to ask for access to figure out if it's permitted, but I don't know
02:47:22 <lavalike> you could also use Nothing | InMarketplace <- riskMarketplaceState risk in the previous formulation :D
02:48:42 <jgt> it looks to me like the Nothing is making sure a risk access request doesn't already exist, since there should only be one
02:49:30 <jgt> and I'm not thrilled about that either; it feels like that idempotency should be handle by the database, not by my application
02:49:39 <jgt> s/handle/handled/
02:57:46 <ski>   maybe (when (riskMarketplaceState risk) (runDB (handle (RequestAccess rid uwId)))) (\_ -> pure ()) mbRar  -- probably not really clearer
02:58:40 <jgt> I've written a todo comment that says we should either handle the idempotency in the database if possible, or move that whole construct out to some "service" function
02:58:51 <jgt> I'm not too cool with all of this sitting in a http handler
02:59:32 <ski> @hoogle m () -> Maybe a -> m ()
02:59:33 <lambdabot> Control.FromSum fromMaybeM_ :: (Applicative m, Monoid b) => m b -> Maybe a -> m b
02:59:33 <lambdabot> Universum.Monad.Maybe whenNothing_ :: Applicative f => Maybe a -> f () -> f ()
02:59:33 <lambdabot> Relude.Monad.Maybe whenNothing_ :: Applicative f => Maybe a -> f () -> f ()
02:59:38 <ski> @hoogle Maybe a -> m () -> m ()
02:59:39 <lambdabot> Universum.Monad.Maybe whenNothing_ :: Applicative f => Maybe a -> f () -> f ()
02:59:39 <lambdabot> Relude.Monad.Maybe whenNothing_ :: Applicative f => Maybe a -> f () -> f ()
02:59:39 <lambdabot> Control.FromSum fromMaybeOrM_ :: (Applicative m, Monoid b) => Maybe a -> m b -> m b
02:59:53 <ski> hm, i wonder which packages those are in ..
03:33:31 <lyxia> My guess: universum, relude, control. :p
03:39:26 <ski> hm, `control' seems to be something else, but those first two are strikes :)
03:51:52 <simg> Hi, would someone be able to take a look at my first attempt at using StateT monad transformer which fails to compile when I try to use "get"? https://gist.github.com/simg/97a83a9a355ea9aef464c54f9c52dc0b
03:56:20 <int-e> simg: well, `withArchive
03:56:30 <int-e> oops. `withArchive` lands you in a different monad
03:56:52 <ski> hm, i suppose you want `execStateT' in place of `runStateT' ?
03:57:31 <simg> ski: why? (I have no idea)
03:57:50 <ski> (and you can use `forM_' (or `for_') in place of `mapM_' (or `traverse_'), for convenience)
03:58:19 <simg> int-e: I kind of realise that, but don't know if that matters or what to do about it?
03:58:29 <ski> `runStateT' will give you both the final version of the state, and also the monadic result of the action you run (which i suspect is `()' anyway)
03:59:09 <int-e> simg: it matters; ZipArchive has no MonadState instance, as the error message says.
03:59:48 <simg> int-e: ah, I see. so what can I do about it?
04:00:08 <int-e> simg: As for what to do about it... I suppose you can get the state immediately before the `withArchive` call, and do another execState or runState inside; then set the resulting state
04:00:19 <ski> yes, what's the type of `withArchive' ?
04:00:25 <int-e> Or just don't use a state monad at all.
04:00:44 <int-e> https://hackage.haskell.org/package/zip-0.1.10/docs/Codec-Archive-Zip.html#v:withArchive
04:01:45 <int-e> (Sometimes monad transformers are more of a hassle than a benefit.)
04:02:02 <simg> how could I keep track of the state without using a state monad?
04:02:06 <int-e> (But I'm not sure how I'd balance this case.)
04:03:00 <int-e> :t Control.Monad.foldM
04:03:03 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
04:03:11 <simg> ski: I probably will want to return the final value at some point (and it doesn't seem like the use of execStateT or runStateT is related to my compilation error?
04:03:13 <int-e> There are always folds or explicit recursion.
04:04:51 <ski> hm, is `(MonadIO m,MonadThrow m) => Path b File -> StateT s ZipArchive a -> StateT s m a' possible ?
04:05:57 <ski> i suppose that's probably a `hoist' ?
04:06:10 <int-e> ski: As I said, you can get the state from the outer monad and do a runStateT on the inside.
04:06:20 <ski> @hackage mmorph
04:06:20 <lambdabot> http://hackage.haskell.org/package/mmorph
04:07:24 <ski> (i'm not sure how much clearer it would be with `hoist', but from what i can see, it could work)
04:09:27 <int-e> Yeah `hoist` looks good here.
04:10:26 <int-e> `hoist nat m = S.StateT (\s -> nat (S.runStateT m s))`  <-- and of course you don't have to play with get/set to access the outer monad state.
04:10:53 <simg> thanks. I can see how either foldM would work or putting runStateT inside withArchive. I think I'll leave hoist for another day!
04:11:01 <int-e> (that's how mmorph implements `hoist` for the state transformer)
04:11:12 <ski> simg : and you can probably just drop the `return summary' line (`summary' isn't in scope, anyway)
04:11:27 * hackage range-set-list 0.1.3.1 - Memory efficient sets with ranges of elements.  https://hackage.haskell.org/package/range-set-list-0.1.3.1 (phadej)
04:12:23 <ski> simg : should there be a `Monoid' instance for `Summary' ?
04:12:40 <simg> ski: thanks. the code I posted is a simplified sample of the code I'm actually working with
04:13:06 <simg> ski: as for Monoid instance, I have. absolutely. no. idea.
04:13:13 <ski>   (`runStateT` Summary empty empty) $
04:13:26 <int-e> ski: I was wondering about that... and about using WriterT
04:13:34 <ski>     hoist (withArchive infile) $ do
04:13:54 <ski>       zipEntries <- keys <$> lift getEntries
04:14:14 <ski>       for_ zipEntries $ \(i,entry) -> do
04:14:18 <ski>         ...
04:14:23 <ski> something like that, perhaps
04:14:34 <int-e> :t for_
04:14:35 <lambdabot> (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
04:15:09 <simg> ski: hmm, interesting might also give hoist a try then.
04:15:41 <ski> you'll need to `lift' the call to `getEntry' as well
04:15:50 <ski> and instead of `get' and `put', you can probably use `modify'
04:16:12 <ski> (and perhaps the first parameter of `addSummaries' ought to be put last)
04:17:22 <simg> that's useful thanks!
04:18:34 <ski> (you could probably put `parseEntry' on the same line as `getEntry', not mentioning `content'. unless you also want to extract out some other stuff from it, in your real code)
04:19:43 <ski> (er, sorry, forgot to replace `runStateT' with `execStateT', in the sketch above)
04:20:12 <simg> I'll forgive you!
04:21:55 <ski> so, `addSummaries' adds a new entry to a summary. it's an "insert" type of operation. if you can define a sensible "merge" operation (which should be at least associative (if not commutative), with `Summary mempty mempty' as neutral element), that could be your `Monoid' instance
04:22:40 <ski> as for the point of adding that .. perhaps one could use `WriterT' instead of `StateT', then
04:23:13 <ski> (if you try that, you should probably compare the performance ..)
04:26:00 <simg> ski: oh, I see... that's going to take some thinking about but I can see why that would be useful.
04:29:11 <ski> (having to muck around with `lift' (and `hoist') is perhaps a bit unfortunate (if you decide to add other transformer layers, you'll need to adapt those). but seems like it might be the most straightforward way to not complicate the code more with explicit state-passing or what-not)
04:41:15 <simg> well, part of my purpose is understanding how to use monad transformers. so regardless of the approach I end up taking, the answers to this question has been very enlightening
04:47:17 <ski> simg : anyway, you know `fmap' takes you from `a -> b' to `f a -> f b', for `f' an instance of `Functor'. so it allows you to "operate inside an `f' layer, changing `a' to `b' inside"
04:48:11 <simg> yes
04:48:35 <ski> or, `fmap' "endows/embellishes" yous transformation from `a' to `b', into one from `f a' to `f b', "carrying along the `f' layer on the outside"
04:49:58 <ski> similarly, `hoist' takes you from `forall a. m a -> n a' to `forall b. t m b -> t n b', for `t' an instance of `MFunctor' (and `m' being an instance of `Monad'. probably it could have been `n' instead, if preferred)
04:50:28 <ski> so, it allows you to "operate inside a monad transformer `t' layer, changing `m' into `n' inside"
04:51:15 <ski> or "endows/embellishes" your natural transformation (technical category theory term) from `m' to `n', into one from `t m' to `t n', "carrying along the `t' layer on the outside"
04:52:39 <ski> so, the problem with `withArchive infile' is that it goes from `ZipArchive a' to `m a' (for *any* `a' you (the caller) like). but you'd like to not have `ZipArchive' in the domain there but rather `StateT s ZipArchive' (also getting `StateT s m' in the codomain)
04:54:19 <ski> so, `hoist' will allow us to "lift the outer `StateT s' layer", so that `withArchive infile' doesn't get to see it (be troubled by it). or, it allows us to "enhance" (all these vague terms !) it so that it can operate on `StateT s' things (in this case. could also be other monad transformers that are instances of `MFunctor')
04:54:19 <int-e> ski: now that you mention it, I wonder whether that Monad constraint is actually used in any of the instances.
04:56:09 <ski> int-e : good question
04:56:14 <simg> ok, that makes sense. are there significant performance implications to this kind of thing?
04:56:26 <ski> simg : anyway, i hope that sortof make sense of what `hoist' is doing, here
04:57:03 <ski> the typical `hoist' implementation is pretty trivial, see <https://hackage.haskell.org/package/mmorph-1.1.3/docs/src/Control.Monad.Morph.html#line-146> e.g.
04:57:54 <int-e> ski: and the answer is no :)
04:58:28 <ski> (one can note that `ContT o' is conspicuously missing from that collection of `MFunctor' instances)
05:11:31 <simg> ski: thanks, that does make perfect sense. 
05:53:27 * hackage hit-on 0.1.0.0 - Haskell Git Helper Tool  https://hackage.haskell.org/package/hit-on-0.1.0.0 (vrom911)
06:50:11 <kwak> How would I use the bound library to represent pi-calculus terms? I suspect that I need ScopeH from bound-extras but I'm not sure how to write the term type
06:51:59 <phadej> kwak: http://oleg.fi/haddocks/language-pts/Language-PTS-Term.html
06:52:25 <phadej> you might, or might not need bound-extras
06:52:43 <phadej> ah, pi-calculus; not depedent-types
06:53:37 <phadej> .. anyway, similarly if you have different syntactic constructs abstracting over each other
06:53:53 <kwak> yeah i've seen your bidirectional stlc implementation
06:54:30 <kwak> the problem is that variables are not processes
06:54:34 <phadej> I don't know pi-calculus that well to help more than ^
06:55:03 <kwak> ok, thank you anyway
06:55:04 <phadej> what variables are then
06:55:35 <phadej> it might help to think the type of substitution :: Variable -> What -> Where -> Result
06:55:43 <kwak> they're ports that processes can input from/output to
06:55:59 <kwak> there's no `Var :: a -> Process a` construct
06:56:25 <phadej> but is there a concept of substitution?
06:57:04 <kwak> yes, it's something like `substitute :: Variable -> Variable -> Process -> Process`
06:57:29 <phadej> you substitute variables for variables?
06:57:35 <kwak> yes
07:01:24 <phadej> hmm, then it might look like: http://oleg.fi/haddocks/language-pts/Language-PTS-Value.html i.e. you'd have newtype Varible a = V a; and data Process = ... | Input (ScopeH ...)
07:01:42 <phadej> i'm not sure I'm telling your the right things, as again, i'm not familiar with pi-calculus
07:01:49 <kwak> something like `Module Identity Process`?
07:02:08 <phadej> (i vague remember that you could send process to other process)
07:02:55 <kwak> you can't in vanilla pi-calculus but there exists higher-order calculi based on pi calc
07:05:13 <phadej> i see
07:06:17 <kwak> isn't `Module Identity f` just `Functor f`?
07:07:18 <kwak> wait it's ` Functor f => Module f Identity`
07:07:21 <phadej> Functor f => Module f Identity 
07:07:22 <phadej> yes
07:07:32 <phadej> I don't remember which way there are myself either
07:08:04 <kwak> i c/p it from hackage so it should be right
07:08:18 <phadej> so, to rehash: for each syntactic construct you should have a type
07:08:46 <phadej> also, you might try to google for "de Bruijn pi-calculus" if it shows something reasonable
07:09:12 <phadej> I'm not sure what kind of scoping happens in pi-calculus, i.e. if bound-approach even make sense
07:11:11 <kwak> you have something called scope extrusion which is basically P|(new x)Q = (new)(P|Q) if x not in freeVars(P)
07:11:47 <kwak> where | is parallel evaluation and (new x)P declares a new name x in P
07:17:27 * hackage servant 0.16.2 - A family of combinators for defining webservices APIs  https://hackage.haskell.org/package/servant-0.16.2 (phadej)
07:18:27 * hackage servant-server 0.16.2 - A family of combinators for defining webservices APIs and serving them  https://hackage.haskell.org/package/servant-server-0.16.2 (phadej)
07:22:22 <kwak> is the unbound package good? http://hackage.haskell.org/package/unbound
07:23:16 <phadej> it's "different" than bound
08:24:42 <arsdragonfly> can I use where in do notation?
08:25:37 <monochrom> No.
08:35:40 <basic> can somebody lead me into a good direction on developing in vimh
08:35:44 <basic> there are so many plugins
08:36:09 <basic> i want a linter & quickfix marking for errors and a ghci that reloades automaticially if syntax is correct
08:36:18 <basic> and im struggling to find a good one
09:12:23 <lavalike> basic: running ghcid in a different session is as far as I go when I'm using vim, maybe that works for you, it's super fast
09:12:52 <basic> well there has to be something talking to ghcid, right?
09:13:10 <lavalike> it's not exactly how it works
09:13:20 <basic> eh?
09:13:48 <lavalike> https://github.com/ndmitchell/ghcid#what-you-get
09:14:37 <basic> well, but you won't get quickfix that way, do you?
09:14:48 <lavalike> I'm not saying it's impossible that one could conjure up a way to make vim aware of what ghcid says, just that by default it does a job and does it fast, printing on the standard output, and that *might* or might not be enough for you (:
09:14:55 <lavalike> dunno what quickfix is
09:15:18 <basic> markings in the file, that shows where the error is that ghcid reports ( there are multiple vim plugins for that )
09:15:32 <basic> i figured many people over-tooled here, i might be wrong tho
09:15:34 <lavalike> the vim link in the editor integration paragraph is curiously named vim-ghcid-quickfix maybe that's up your alley!
09:16:11 <basic> but is there also ghci session then, that i can use ?
09:16:18 <basic> or will it just print error messages like it's 1999
09:16:40 <lavalike> it'll print them like it's 2019 and that's it
09:17:00 <basic> well, then i could just go with a rerun script that runs ghc, that's not 2019
09:17:18 <lavalike> I don't know how to help you
09:17:18 <basic> don't see the benefit
09:17:39 <basic> well, my question states that really explicitly
09:17:58 <basic> i want: quickfix annotation, a ghci session that reloads if syntax is correct
09:18:03 <basic> and typemagic, that is
09:23:50 <basic> and how is debug prints a 2019 thing, that's the step after turing watched at baremetal-ram on CRT strokes
09:24:15 <c_wraith> it's a 2019 thing because it never stopped working
09:24:47 * basic wonders why we are not using real printers anymore
09:24:58 <c_wraith> I used a printer last week
09:25:06 <basic> for printouts of your terminal?
09:25:35 <c_wraith> for printing code, at least.
09:25:46 <basic> well that's wasteful
09:27:07 <c_wraith> a monitor is definitely better than a printer for most cases.  That's not true of a debugger.  Most debuggers are actively worse than just understanding your code.
09:27:37 <basic> never was talking about debugger, but a software that prints me the lines instead of "marking" them so i can see directly is just a debug print
09:29:58 <c_wraith> Ah.  I think your problem is that very few people who work with haskell *want* an integrated environment, and that's a self-reinforcing condition.  I have no use for an integrated environment, so I don't build one.  People who do want one can't find one and leave instead of building one.
09:32:04 <monochrom> You will also judge me for still using a fountain pen on paper in 2019.
09:32:22 <mjrosenb> monochrom: yes.
09:32:25 <mjrosenb> monochrom: that is awesome.
09:32:29 <monochrom> haha
09:32:32 <c_wraith> I also judge that awesome
09:33:16 <basic> i don't know what integrated environment means, if i used a complicated term like that, i wouldn't use it for "send the string ":reload" to the stdin of a process"
09:33:42 <c_wraith> you've described a process for integrating editing and compiling
09:34:07 <basic> well, which is also just sending some bytes to vim instead of stoud
09:34:28 <mjrosenb> I have a bit of a quandry.  I want to generate some html slides from a .lhs file.  Is there anything approaching a reasonable path to do this?
09:34:57 <monochrom> Does pandoc help?
09:35:04 <c_wraith> hmmm.  pandoc can go to a blog post, but slides are another step
09:50:04 <lyxia> you can make a polyglot LHS-LaTeX file to pass to pandoc
09:50:38 <[exa]> mjrosenb: lhs2html doesn't work?
10:11:25 <mjrosenb> lyxia: and use beamer?
10:12:13 <mjrosenb> [exa]: ditto.
10:28:30 <lyxia> yeah pandoc can make beamer slides. Actually the source doesn't need to be LaTeX, it could be markdown.
10:29:20 <lyxia> it's not really flexible though, in case you need fine-grained animations or typesetting...
10:31:51 <mjrosenb> really, any beamer -> html will be fantastic.
11:03:18 <d34df00d> Hi!
11:03:32 <d34df00d> Is it possible to link to another module's type in Haddock documentation without `import`ing the corresponding module?
11:03:57 <d34df00d> I don't really depend on that module and that type at compile time so I don't want to introduce an unnecessary dependency just for the sake of docs.
11:07:57 <lyxia> Try using the fully qualified name
11:10:37 <d34df00d> lyxia: it shows up as hyperlinked, but when I click on it in the locally generated docs, it shows 404 (looks like haddock assumes it's in my own package). Will it be OK on the hackage haddock?
11:14:36 <lyxia> I'm not sure, if it's not in a package you depend on it might be a problem.
11:14:58 * hackage quickcheck-arbitrary-template 0.2.1.0 - Generate QuickCheck Gen for Sum Types  https://hackage.haskell.org/package/quickcheck-arbitrary-template-0.2.1.0 (mchaver)
11:16:35 <hpc> see if cabal has a way to express docs-only dependencies?
11:22:05 <d34df00d> hpc: nah, at leat I couldn't find it.
11:35:15 <Zemyla> {-# RULES "traverse/(->)" forall f t. traverse f t = \e -> fmap (flip f e) t #-}
11:37:27 <d34df00d> Hmm, can I document a default method in a class separately?
11:37:44 <d34df00d> Haddock seems to copy the documentation from the method definition.
11:38:05 <merijn> d34df00d: not yet, that's a thing being worked on, I recall there being an open issue for that with haddock
11:39:21 <d34df00d> merijn: cool, glad to know, thanks! I guess I'll just copy the docs about the default behaviour to the method type definition docs.
12:30:32 <mjrosenb> I have not figured out how to get pandoc to do the right thing for a beamer -> html conversion
12:31:04 <kreetx> good evening, I have the following issue: in stack.yaml I list some local packages to be loaded, but two of them have a module with the same name. And when I do stack repl it seems that just one of them gets used -- even for the other package!
12:31:29 <kreetx> the named module is in both packages listed in the other-modules in their respective .cabal files
12:34:43 <MarcelineVQ> are you intending those other packages to be part of your project or are they dependencies?
12:36:59 <kreetx> I'm hoping to modify them
12:37:37 <kreetx> the packages are tls and tls-session-manager, both from the same repo
12:37:58 <kreetx> and the clashing module is Network.TLS.Imports, and it's in the other-modules section of both
12:38:27 <kreetx> and my cabal package depends on them both
12:39:00 <merijn> kreetx: There are no nice ways to use clashing modules, GHC has the PackageImports extension that lets you work around it, but it will never be nice
12:39:12 <kreetx> yup
12:39:26 <MarcelineVQ> If they're dependencies they should be in the extra-deps section rather than the packages section. packages is for when you want to literally include another packages files into yours afaik
12:39:45 <kreetx> I found that if I do stack repl --no-load, and then :m Main, then it kind of works 
12:40:20 <kreetx> it's just the stack repl with no --no-load, that gave me a missing Int64 error, and it took a while to understand why
12:49:29 <kreetx> MarcelineVQ: I think I figured it out how I can use them and it's just me being a noob at this. But since I want to develop those dependencies (and use my own project just as a test case) then I need to have them in the packages section of stack.yaml (and load the project by stack repl --no-load, and then do :l exact/modul/path.hs -- if I wanted to use any of those clashing modules specifically)
13:22:06 <wuschel>  /join openra
13:22:16 <wuschel>  /join #openra
13:23:57 * hackage envy 2.0.0.0 - An environmentally friendly way to deal with environment variables  https://hackage.haskell.org/package/envy-2.0.0.0 (DavidJohnson)
13:40:56 <crestfallen> http://paste.debian.net/1094278/    hi I'm having trouble seeing how the where statement works lines 28-30. I see that its substituting for (++) but I find this very hard to follow. please see lines 18,19 as well, so that I can evaluate it systematically. thanks
13:41:53 <crestfallen> i.e. I'd like to use the technique on lines 18,19 but am somewhat confused by that
13:43:00 <Cale> crestfallen: I'm not sure I understand what you're confused by...
13:43:15 <Cale> You can't actually eliminate the definition of app by substitution because it's recursive
13:43:55 <Cale> (and besides that, you can't match a pattern, so you'd be substituting in a case expression, matching on the fmap g xs)
13:45:16 <Cale> You could, however, lift the definition of app out of the where clause, placing it at the top level. It's a useful function on lists in its own right.
13:50:02 <crestfallen> Cale thanks one moment
13:51:25 <crestfallen> Cale this is the solution of another member. do you think this is the best/most obvious solution to break the fmap id rule?
13:51:58 <Cale> There's an easier one
13:52:10 <Cale> fmap g = Nil
13:53:30 <crestfallen> tbh I'm pretty confused. line 29 has app Nil ys on the lhs ..
13:53:40 <Cale> But the one which reverses the list will also fail to have fmap f . fmap g = fmap (f . g)
13:53:53 <Cale> because the left side will reverse twice, and the right side will reverse only once
13:54:25 <Cale> Yeah, that's saying that appending Nil to ys results in ys
13:58:25 <crestfallen> so first off, line 26 reverses it the first time, since ' Cons (g x) Nil ' is listed last
14:00:09 <Cale> crestfallen: Yeah, it's saying "In order to fmap g over (Cons x xs), take the result of fmapping g over xs, and append the list (Cons (g x) Nil) to the end
14:00:41 <Cale> Which will mean that g applied to the first element of the input list ends up at the end of the resulting list.
14:01:00 <crestfallen> right ok so far so good
14:01:44 <crestfallen> I'd like to experiment with your suggestion: running app as a separate func...
14:01:58 <crestfallen> ...
14:10:33 <crestfallen> Cale ok so app works precisely like (++) with our differing type constructors
14:11:09 <crestfallen> if I express it correctly
14:11:28 * hackage can-i-haz 0.1.0.1 - Generic implementation of the Has pattern  https://hackage.haskell.org/package/can-i-haz-0.1.0.1 (0xd34df00d)
14:11:42 <lavalike> o_O
14:12:02 <crestfallen> Cale do I speak truthfully?
14:12:16 <Cale> crestfallen: Yeah, it's an implementation of append on lists
14:12:34 <Cale> Only for your new list type, rather than the built-in one
14:12:49 <crestfallen> thanks right. what was your easier solution about?
14:13:55 <Cale> Well, if fmap g xs = Nil for any xs, then fmap id (Cons u us) = Nil which is not the same as Cons u us
14:15:20 <crestfallen> hold on please I'm tripping
14:15:58 <crestfallen> this regards line 29 right?
14:16:45 <Cale> no
14:17:01 <crestfallen> the initial base case
14:17:01 <Cale> This regards the entirety of the definition of fmap
14:17:16 <Cale> You could replace the entire definition of fmap with fmap f xs = Nil
14:17:32 <Cale> and it wouldn't satisfy the law that fmap id xs = xs
14:17:45 <crestfallen> youre joking hold on trying to see this
14:18:55 <crestfallen> your variable names u us I'm still on that..
14:19:05 <Cale> They're arbitrary
14:19:23 <crestfallen> yes thanks working..
14:19:37 <Cale> If you prefer a concrete example,  fmap id (Cons 1 Nil) = Nil
14:33:34 <crestfallen> Cale that last post of yours, you're saying that if you set any lhs to Nil , you'll get Nil
14:45:20 <Cale> crestfallen: Yeah, and in particular, you'll get Nil even if you fmap id over a Cons, which will break the law
14:55:34 <crestfallen> Cale very sorry its not working . please let me paste ... 
14:56:26 <crestfallen> http://paste.debian.net/1094284/
14:58:03 <crestfallen> this gives a warning ' No explicit implementation for 'Prelude.fmap'   but then loads .. then when I run fmap id (Cons 1 Nil) I get the Ambiguous occurrence 'fmap' error
14:58:54 <infinisil> crestfallen: Indentation matters
14:59:00 <infinisil> You forgot to indent the fmap definition
14:59:03 <Cale> crestfallen: You didn't indent your definition of fmap, so it's not part of the instance declaration
14:59:07 <crestfallen> dangit
14:59:49 <crestfallen> 4 spaces standard in that case?
15:00:15 <Cale> I usually go with 2 spaces
15:00:23 <infinisil> 2 as well here
15:00:24 * ski would do two, but different people prefer different amounts
15:00:32 <crestfallen> getting new error..
15:00:41 <ski> that's progress :)
15:00:51 <Cale> It doesn't really matter, so long as it starts in a deeper column and things line up correctly
15:00:52 <crestfallen> Illegal type signature in instance declaration :)
15:01:15 <crestfallen> fmap :: (a -> b) -> List a -> List b
15:01:36 <ski> add `{-# LANGUAGE InstanceSigs #-}' to the top of your file, to allow them
15:02:41 <_kwstas> hi there! I have a list `[3,4,5,2,3,4,5]` and I want to take all the elements after the first occurrence of 5. Apart from `dropWhile`, `span` etc (which will require to drop the head) is there any other function in base that can do the desired functionality?
15:03:54 <ski> > head [xs | 5:xs <- tails [3,4,5,2,3,4,5]]
15:03:57 <lambdabot>  [2,3,4,5]
15:04:24 <crestfallen> ski but why didn't I have that issue with the reverse implementation we all love?
15:04:39 <Cale> crestfallen: I think you had the signature commented out
15:04:49 <ski> `reverse' wasn't a class method ?
15:04:56 <Cale> crestfallen: Usually you're not allowed to write type signatures inside instance declarations
15:05:02 <Cale> (without that extension)
15:05:03 <crestfallen> oh yes thats it Cale
15:05:12 * ski hasn't been following along, hasn't seen crestfallen's `reverse'
15:05:18 <crestfallen> so please bear with me..
15:05:29 <Cale> ski: There was another example fmap which breaks the Functor laws, which also reversed the list, earlier
15:05:44 <crestfallen> I have to look at the book..
15:05:45 <ski> i'm not sure they didn't allow such signatures in the base language, to begin with
15:06:16 <ski> s/sure/sure why/
15:07:03 <_kwstas> ski: thx ,but no, I do not like list comprehensions. I was hoping for an existing function ;)
15:08:08 <crestfallen> http://paste.debian.net/1094285/   ski
15:09:28 * hackage cmake-syntax 0.1.0.0 - Parser for the CMake syntax (CMakeLists.txt and .cmake files)  https://hackage.haskell.org/package/cmake-syntax-0.1.0.0 (0xd34df00d)
15:09:41 <ski> crestfallen : did you try enabling `InstanceSigs', yet ?
15:15:44 <crestfallen> yeah ski that worked thanks .. however I'm trying to understand Cale 's example .. the first rule states that ...
15:17:59 <crestfallen> in ' fmap id = id ' the two id 's are not the same type. we have a -> a and then f a -> f a 
15:18:19 <crestfallen> which I understand fine
15:19:19 * ski nods
15:20:30 <crestfallen> so Ca.le's example beginning with {-# LANGUAGE InstanceSigs #-}
15:21:09 <crestfallen> what are we doing there? in regards to the reverse fmap breaking the rule
15:22:24 <ski> in that paste, you also reverse the list ?
15:22:33 * ski isn't sure what crestfallen is asking
15:23:13 <crestfallen> Ca.le gave me this as a simpler example of fmap, but I don't see how it relates to the reverse fmap
15:23:27 <infinisil> crestfallen: `fmap id = id` is just a functor law, and if your type's fmap doesn't work for it, it breaks the law
15:23:48 <infinisil> And that's the case for the reversing fmap
15:23:51 * ski assumes Cale might be more equipped to answer what they had in mind
15:24:33 <infinisil> Because `fmap id [1, 2, 3]` will be `[3, 2, 1]`, whereas according to the functor law it should be `fmap id [1, 2, 3] = id [1, 2, 3] = [1, 2, 3]`
15:25:05 <crestfallen> that part I understand infinisil 
15:26:01 <infinisil> Then I don't understand what you don't understand
15:29:06 <gobby> I'm using `servant-server` and currently I have an API that fetches things from a db. However I would also like to upload images to this db. I understand that I cannot incorporate file uploads to the same API, but I was wondering how is this usually done?Do people usually run a separate API specifically for file uploads and have it listen on a diff
15:29:06 <gobby> erent port?
15:31:11 <jle`> gobby: is this a general web architecture question?
15:31:22 <gobby> jle`, yep
15:31:46 <gobby> but specific to `servant`
15:32:11 <gobby> it seems like you can't have file uploads and other HTTP requests in the same `API`
15:32:30 <crestfallen> infinisil, *sorry*   .    I asked Ca.le if the reversal fmap was the most obvious solution. And I thought he suggested the ' fmap g xs = Nil ' as a simpler solution. so I'm confused once again. ski   
15:32:58 * ski idly wonders why crestfallen writes "Ca.le", rather than "Cale"
15:32:59 <gobby> obviously you would want one `API` but I was wondering what is the best practice here
15:33:18 <crestfallen> cuz I pinged him enough today
15:33:32 <crestfallen> now its *your* turn :)
15:33:52 <ski> crestfallen : `fmap g xs = Nil' is a simpler solution for *breaking* the law `fmap id = id', yes
15:34:12 <crestfallen> oh its another way to break the law
15:35:42 <infinisil> Even simpler: `fmap = undefined` :)
15:36:28 <crestfallen> I was asking with something specific in mind, how to implement the reverse fmap, so that is why I was confused. ski thanks ALL I see now. fmap = undefined   ..  ? infinisil 
15:37:04 <infinisil> `fmap = undefined` is another way to break the functor law, which is even simpler
15:37:41 <ski> yea, but that's partial, so "cheating" :)
15:38:51 <infinisil> Fair enough
15:39:01 <crestfallen> also app Nil ys = ys in the where statement  ..  that's still bugging me
15:39:17 <infinisil> I remember there being some flag or so that warns on undefined's
15:39:30 <merijn> Or just never use undefined :p
15:40:49 <hpc> holes are better anyway
15:41:16 <hpc> or error
15:41:28 <merijn> Yeah, I was thinking holes
15:41:31 <cjay-> how are holes better when you want to implement something else first?
15:41:37 <crestfallen> that's not a base case then on line 29 , or is it?  http://paste.debian.net/1094278/
15:41:42 <infinisil> I do like myself some holes to fill
15:42:08 <merijn> cjay-: Well, unlike undefined holes have a corresponding warning, so theyre strictly better than undefined :p
15:42:10 <crestfallen> reel it in .. :)
15:42:48 <cjay-> merijn: yeah, but when working on something else, I don't want my warnings and errors cluttered with other stuff
15:43:13 <merijn> cjay-: That's why you use -Wno-typed-holes while working on other things and only enable them again at the end :p
15:43:55 <crestfallen> never mind I see it. thanks!!
15:44:24 <cjay-> merijn: what if I want holes while working on the other thing? :p
15:44:42 <merijn> cjay-: That just disables the warning, not the holes
15:45:20 <cjay-> hmm ok I could use editor integration to query the type of specific holes I guess
15:45:43 <infinisil> cjay-: Yeah I often use undefined and then let HIE tell me the type of it
15:45:49 <merijn> You can even use -fdefer-typed-holes to run code that has holes unfilled
15:48:01 <iqubic> How?
15:48:10 <iqubic> Will they just be treated as thunks?
15:48:20 <iqubic> they == the holes.
15:48:25 <merijn> iqubic: They'll turn into runtime exceptions
15:48:42 <merijn> iqubic: So they throw an exception with the warning text at runtime when you try to evaluate them
15:48:53 <merijn> It's basically -fdefer-type-errors, but for holes only
15:48:53 <iqubic> Ah. One of the rare times Haskell will produce a runtime exception.
15:49:30 <iqubic> Does division by 0 throw a runtime error?
15:49:36 <merijn> yeah
15:49:41 <merijn> > 5 `div` 0
15:49:44 <lambdabot>  *Exception: divide by zero
15:50:23 <cjay-> most partial functions throw runtime errors
15:51:03 <ski> > 5 `mod` 0  -- ought to give `5', imho
15:51:06 <lambdabot>  *Exception: divide by zero
15:51:09 <iqubic> Nope.
15:52:43 <hpc> > 5 `divMod` 0 -- it comes from this, i suspect
15:52:46 <lambdabot>  *Exception: divide by zero
15:54:00 <nil> ski: why should 5 mod 0 be 5?
15:59:19 <ski> nil : because ⌜ℤ ∕ (0⋅ℤ)⌝ is isomorphic (as a ring) to ⌜ℤ⌝ ?
16:00:28 <ski> of course, we still have
16:00:32 <ski> > 0 * undefined
16:00:38 <lambdabot>  *Exception: Prelude.undefined
16:00:41 <jle`> i normally expect x `div` y to never return a value equal to or greater than y
16:00:49 <jle`> er, `mod`
16:00:54 <nil> i guess that's true
16:01:33 <ski> so  d * (n `div` d) + n `mod` d = n  would still fail, when `d = 0'
16:03:10 <crestfallen> apparently in middle school math, a teacher must accept this as correct:
16:03:32 <crestfallen> > 8 / 2*(2*2)
16:03:35 <lambdabot>  16.0
16:03:56 <crestfallen> since the student should not have to understand precedence rules
16:04:01 <crestfallen> is that wrong?
16:04:03 <Cale> > 8/2
16:04:06 <lambdabot>  4.0
16:04:12 <MarcelineVQ> is what wrong, specifically
16:04:14 <Cale> > 4*(2*2)
16:04:17 <lambdabot>  16
16:04:21 <iqubic> It's not wrong.
16:04:47 <crestfallen> > div 8 (2*(2*2))
16:04:51 <lambdabot>  1
16:04:58 <iqubic> Most middle school math students are required to understand order of operations.
16:04:58 <Cale> * and / are both infixl 7
16:05:21 <Cale> If you wanted 8 / (2*(2*2)) you should have written that :)
16:05:24 <iqubic> > 8 / (2*(2*2)) == div 8 (2*(2*2))
16:05:28 <lambdabot>  error:
16:05:28 <lambdabot>      • Ambiguous type variable ‘a0’ arising from the literal ‘8’
16:05:28 <lambdabot>        prevents the constraint ‘(Num a0)’ from being solved.
16:05:35 <iqubic> Huh??
16:05:42 <Cale> There's no way that can typecheck
16:05:46 <iqubic> Why?
16:05:58 <Cale>  / can only produce instances of Fractional and div can only produce instances of Integral
16:06:02 <iqubic> I see.
16:06:08 <ski> `div' is integral division. `(/)' is exact (more or less) division
16:06:09 <hpc> beyond that, it doesn't know what Num instance to use
16:06:16 <Cale> (and those classes have no instances in common)
16:06:32 <iqubic> > fromIntergral $ 8 / (2*(2*2)) == fromIntergral $ div 8 (2*(2*2))
16:06:35 <lambdabot>  error:
16:06:35 <lambdabot>      • Variable not in scope: fromIntergral :: t0 -> t
16:06:35 <lambdabot>      • Perhaps you meant ‘fromIntegral’ (imported from Prelude)error:
16:06:51 <iqubic> > fromIntegral $ 8 / (2*(2*2)) == fromIntegral $          div 8 (2*(2*2))
16:06:54 <lambdabot>  error:
16:06:54 <lambdabot>      • Couldn't match expected type ‘Integer -> Integer’
16:06:54 <lambdabot>                    with actual type ‘Bool’
16:06:59 <iqubic> Huh???
16:07:10 <Cale> Now your problem is that $ has lower precedence than ==
16:07:23 <iqubic> > fromIntegral (8 / (2*(2*2))) == fromIntegral          (div 8 (2*(2*2)))
16:07:28 <lambdabot>  error:
16:07:28 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘fromIntegral’
16:07:28 <lambdabot>        prevents the constraint ‘(Integral a0)’ from being solved.
16:07:33 <iqubic> Huh???
16:07:40 * Clint chuckles.
16:07:55 <iqubic> look. Numbers are confusing.
16:08:27 <crestfallen> but if parentheses exist anywhere, shouldn't the student resolve that first, if the precedence is the same? or is that just CS?
16:09:05 <ski> > 8 `div'` (2*(2*2)) == 8 `div` (2*(2*2))
16:09:09 <lambdabot>  True
16:09:41 <ski> (perhaps `fDiv',`fMod',`fDivMod' could have been better names ?)
16:10:26 <jle`> iqubic: remember that $ is just a normal operator
16:10:52 <jle`> iqubic: so fromIntegral $ x == y is fromIntegral (x == y)
16:11:40 <MarcelineVQ> crestfallen: yes, they should, and would get 16 given 8 / 2*(2*2)
16:12:11 <iqubic> jle`: I recall that.
16:13:16 <iqubic> Relevant YouTube video: https://www.youtube.com/watch?v=vaitsBUyiNQ
16:14:58 <MarcelineVQ> crestfallen: however the precedence isn't the same for the student, pedmas puts division before multplication
16:15:45 <hpc> i suppose the most complete answer here is
16:16:02 <hpc> if you're doing computations, write it in the form the computer expects
16:16:16 <hpc> if you're just writing it on paper, the only consumer of it is people, so write it so people can understand it
16:16:18 <crestfallen> ...
16:16:30 <iqubic> MarcelineVQ: I think nowadays young students are taught that multiplication and division should be evaluated from left to right.
16:16:50 <MarcelineVQ> iqubic: alright, 16 is still correct in that case though
16:17:02 <MarcelineVQ> 8 / 2*(2*2) ~> 8 / 2*4 ~> 4*4 ~> 16
16:17:05 <crestfallen> iqubic, yeah a NYT article was explaining it according to my landlady
16:17:14 <iqubic> Yes. Correct.
16:31:26 <siwica> Is there an irc channel concerned with language-agnostic questions regarding software architecture/design principles/language choice?
16:39:11 <crestfallen> > (2*2)*2 / 8
16:39:13 <lambdabot>  1.0
16:39:36 <nil> siwica: ##programming?
17:09:05 <dada_cetacean> i have a datatype `a` with a lot of constructors, but i want to only do something with an `a` inside a parser if it is made with a particular constructor
17:10:03 <dada_cetacean> is there a more efficient way to do this than to case on literally every constructor of `a`?
17:11:48 <hpc> so say you have data YourThing = One | Two | Three | ...
17:12:01 <hpc> what you want is perhaps something like
17:12:19 <hpc> case yourthing of {SeventyFive -> do something; _ -> do nothing}
17:13:47 <dada_cetacean> hpc, thanks! that's exactly what i want
17:39:34 <oats> out of curiosity, anyone here found good use for the function Monad?
17:39:55 <oats> I've tried to think of ways it could be useful and I haven't been successful lol
17:41:29 <lyxia> "the function Monad"? what do you mean?
17:41:48 <oats> > 2 >>= (+1) >>= (*2)
17:41:52 <iqubic> oats: Do you perhaps mean: the reader monad?
17:41:53 <lambdabot>  error:
17:41:53 <lambdabot>      • Ambiguous type variables ‘m0’,
17:41:53 <lambdabot>                                 ‘b0’ arising from a use of ‘show_M57781821194...
17:41:59 <oats> :<
17:42:08 <oats> > 2 :: Int >>= (+1) >>= (*2)
17:42:09 <iqubic> It's called the Reader Monad.
17:42:11 <lambdabot>  <hint>:1:15: error: Operator applied to too few arguments: +
17:42:33 <vaibhavsagar> oats: you mean the Reader instance for (-> e)?
17:42:49 <lyxia> > liftA2 (*) (+ 1) (+ 2) a
17:42:51 <oats> I mean the monad instance for the function constructor
17:42:52 <lambdabot>  (a + 1) * (a + 2)
17:43:16 <iqubic> oats: That's called the Reader Monad.
17:43:43 <lyxia> https://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Reader.html
17:43:51 <oats> huh, I've confused myself
17:45:25 <oats> https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#line-828
17:45:33 <oats> Monad ((->) r)
17:45:56 <oats> could someone help me understand what that has to do with the reader monad?
17:48:19 <Lears> @src Reader
17:48:19 <lambdabot> type Reader r = ReaderT r Identity
17:48:19 <lambdabot> --OR
17:48:19 <lambdabot> data Reader r a = Reader { runReader :: r -> a }
17:49:17 <Lears> `Reader r` is the same thing as `(->) r`, under the hood.
18:02:43 <libertyprime> hey guys. looking through haskell docs at the moment: https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Sequence.html#v:-124--62-
18:03:12 <libertyprime> im curious about the algorithmic complexity. does haskell have ways to work these things out automatically?
18:03:19 <iqubic> No.
18:03:24 <iqubic> I don't think so.
18:03:52 <oats> that'd be cool if you could programatically calculate complexity
18:07:50 <nil> you can estimate it experimentally by plotting the time (or number of evaluation steps, if you have access to that) as a function of input size
18:39:28 * hackage reflex-vty 0.1.0.0 - Reflex FRP host and widgets for vty applications  https://hackage.haskell.org/package/reflex-vty-0.1.0.0 (abrar)
18:46:58 * hackage call-stack 0.2.0 - Use GHC call-stacks in a backward compatible way  https://hackage.haskell.org/package/call-stack-0.2.0 (SimonHengel)
19:42:10 <Cale> Ali Abrar (abrar) and I just published https://github.com/reflex-frp/reflex-vty to hackage. It's still pretty experimental and there are a lot of widgets left on our TODO list, but if anyone's looking for an FRP way to put together terminal-graphics applications, it might be worth a look.
19:42:46 <Cale> Highlights include a multiline text input widget, drag and drop, and the beginnings of constraint-based screen layout.
19:56:23 <electricityZZZZ> so at some point haskell decides to allocate memory for a variable... is it possible to sacrifice a little more memory use and pre-allocate a bit ahead to reduce or eliminate the latency induced by allocating?
19:57:04 <Cale> electricityZZZZ: There are various RTS options to control the behaviour of the garbage collector
19:57:19 <electricityZZZZ> well garbage is after i have allocated,...
19:57:26 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html#rts-options-to-control-the-garbage-collector
19:57:44 <Cale> Well, it's also what does the actual allocation of system memory in the first place
19:58:31 <electricityZZZZ> so i'm not really trying to talk about the heap size here
19:58:35 <electricityZZZZ> at least not directly
19:58:42 <MarcelineVQ> could this be called speculative allocation
19:59:08 <electricityZZZZ> yep, speculative allocation
19:59:55 <electricityZZZZ> exactly
20:33:32 * libertyprime wonders how to turn this into a regex crossword solver: https://github.com/audreyt/regex-genex
20:37:37 <glguy> libertyprime: I have some code that compiles regular expressions to SAT problems and solves them using off-the-shelf sat solvers
20:39:19 <libertyprime> thats probably far more efficient
20:40:28 * hackage log4hs 0.0.3.0 - A python logging style log library  https://hackage.haskell.org/package/log4hs-0.0.3.0 (gqk007)
20:41:57 <libertyprime> glguy: is it written in haskell? i would love love love to see it
20:42:35 <glguy> It's part of my "solve things with sat" repo: https://github.com/glguy/5puzzle/tree/master/src/RegExp
20:42:52 <glguy> There are two implementations, one efficient one when you actually have a regular expression and one less efficient one when you have back-references
20:43:22 <glguy> The hexagonal regexp puzzle is solves is here: https://github.com/glguy/5puzzle/blob/master/RegExp.hs#L57-L97
20:43:36 <glguy> https://gregable.com/p/regexp-puzzle.html online version
20:45:11 <libertyprime> amazing. thags glguy! did not expect such an epic response
20:45:15 <libertyprime> thanks*
20:48:42 <ski> hm, is it possible to put `!'s on top-level bindings ?
20:49:46 <vaibhavsagar> glguy: why ersatz instead of sbv?
20:50:17 <dmwit> ski: nope
20:50:28 <dmwit> ski: Nobody has got a clue what it should mean, so it's simply disallowed.
20:51:32 <sarahzrf> lol
20:53:17 <jle`> Cale: hooray :D
20:53:43 <Cale> jle`: Yeah, it's finally out :D
20:54:32 <Cale> jle`: I don't really know why we waited to this point to release anything at all, but without the layout stuff, it was pretty annoying to actually use, and that's what we just finished.
20:55:04 <jle`> that's fair :)
21:03:13 <int-e> dmwit: hmm, that would be a cute way to express compile-time evaluation :P
21:24:57 <libertyprime> any way to search for modules?
21:25:02 <libertyprime> say with hoogle or hackage?
21:28:42 <nfd9001> big brain idea i recently had: use infixed U+0971 as "flip (.)"
21:29:02 <nfd9001> big, big brain XD
21:57:35 <iqubic> ॱ
21:57:39 <iqubic> that?
21:57:49 <iqubic> That's an odd thing to do.
22:45:57 * hackage list-witnesses 0.1.1.1 - Witnesses for working with type-level lists  https://hackage.haskell.org/package/list-witnesses-0.1.1.1 (jle)
22:59:57 * hackage net-spider-cli 0.1.0.0 - CLI option parsers for NetSpider objects  https://hackage.haskell.org/package/net-spider-cli-0.1.0.0 (debugito)
23:10:28 * hackage net-spider 0.3.2.0 - A graph database middleware to maintain a time-varying graph.  https://hackage.haskell.org/package/net-spider-0.3.2.0 (debugito)
23:12:57 * hackage net-spider-cli 0.1.0.1 - CLI option parsers for NetSpider objects  https://hackage.haskell.org/package/net-spider-cli-0.1.0.1 (debugito)
