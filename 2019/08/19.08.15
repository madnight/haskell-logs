00:07:11 <dmitri> @list
00:07:11 <lambdabot> What module?  Try @listmodules for some ideas.
00:07:25 <dmitri> @listmodules
00:07:25 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
00:07:25 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
00:07:32 <Axman6> dmitri: please do that in pm
00:07:43 <Axman6> use /msg lambdabot @lostmodules
00:08:07 <Axman6> (there can be a lot of output once you start exploring lambdabot's functionality :)
00:08:11 <dmitri> Axman6: thanks and sorry, didn't expect it going out
00:24:06 <EvanR> lambdabot: the lost modules
00:43:05 <jusss> can we get bind through >=> and return?
00:43:56 <dminuoso> Is there some sort of dual of Applicative that gives me ⌜(<+>) :: ... => m a -> m b -> m (Either a b)⌝ as a sort of exclusive choice where only one succeed may and must succeed?
00:43:59 <dminuoso> jusss: Yes.
00:44:06 <dminuoso> jusss: I invite you to try and figure it out yourself.
00:45:08 <jusss> dminuoso: it's not beyound my knowlege now?
00:45:17 <[exa]> dminuoso: does the alternative-style choice count? (fmap Left a <|> fmap Right b)
00:45:37 <[exa]> oh noes that doesn't work
00:45:38 <dminuoso> [exa]: Nope.
00:45:58 <jle`> jusss: you can probably actually just do it using type tetris :)
00:46:11 <jle`> playing around until the types match
00:46:29 <dminuoso> jusss: Im convinced you have the necessary tools. It might take a while, but try to solve it on your own without hint or help. :)_
00:46:45 <jusss> dminuoso: jle` ok
00:46:57 <jle`> dminuoso: selectable functors maybe?
00:47:13 <jle`> not sure if that is what you are looking for
00:47:16 <jle`> but the type signature looks familiar
00:47:42 <dminuoso> jle`: I was just sitting here with two parsers for optparse-applicative, and was wondering whether there was a sort of "must supply either, but not both" combinator.
00:47:52 <dminuoso> I pondered about it and tried to generalize the idea.
00:48:03 <jusss> wait a sec, how I can get the type define of a function in GHCi?
00:48:09 <jusss> :i ?
00:48:13 <[exa]> :t
00:48:33 <dminuoso> jle`: What I found interesting was that it reminded me of the definition of Monoidal.
00:48:57 <jle`> that sounds like something you can define for parser combinators using only applicative/alternative though
00:49:15 <dminuoso> jle`: Well yeah, I can handcraft this - thats not the point. :)
00:49:40 <dminuoso> jle`: In my mind I thought about ⌜(><) :: Monoidal f => f a -> f b -> f (a, b)⌝ and realized hey, what if there was something similar but with Coproduct rather than Product in the result.
00:51:39 <[exa]> :t \a b -> (a *> fmap Left a) <|> (b *> fmap Right b)
00:51:42 <lambdabot> Alternative f => f a -> f b -> f (Either a b)
00:52:32 <dminuoso> [exa]: If we use Alternative, there has to be some newtype wrapper at the very least.
00:52:46 <dminuoso> [exa]: Reason is, if the left side succeeds the right might not be tried depending on the instance.
00:53:00 <dminuoso> So it'd have left bias
00:53:07 <[exa]> oh so, I get it now
00:58:47 <dminuoso> jle`: Yeah, selective functors seem to capture it.
00:59:33 <dminuoso> jle`: It seems like ⌜<+>⌝ would be to ⌜select⌝ as ⌜><⌝ is to ⌜<*>⌝
00:59:43 <dminuoso> At first glance
01:06:30 <dmitri> Having problem with `stack install` that is trying to install ghc-8.6.4, while I already have 8.6.5  installed, is there any way to make `stack` use it instead?
01:09:21 <comerijn> dmitri: Probably, but that's pretty much against stack's workflow. The entire idea is to have a fixed snapshot (including GHC version) and build with that, and then upgrading your snapshot when you want to move to newer versions
01:11:21 <dmitri> comerijn: so I am expected to install the older version? 215MB?
01:12:02 <dminuoso> dmitri: No, stack will do it for you.
01:12:16 <dmitri> that is exactly the problem :(
01:12:30 <dminuoso> dmitri: What is?
01:12:31 <dmitri> it is another 215MB
01:12:47 <dmitri> for the older version that is only patch away
01:12:54 <merijn> dmitri: If you want a single system wide GHC, you probably don't want stack...
01:12:59 <dminuoso> dmitri: If you want something more minimalistic, stack might not be for.
01:13:02 <dminuoso> *be for you
01:13:45 <dminuoso> dmitri: You could just use raw ⌜cabal v2-*⌝ and manage your GHC with ghcup.
01:14:02 <dmitri> ok, I don't really need it, all I want is to install this better REPL: https://github.com/litxio/ptghci
01:14:20 <dminuoso> dmitri: You can build that with cabal too
01:14:23 <dmitri> which requires me to run `stack install`
01:14:32 <dminuoso> dmitri: No, you can just run "cabal v2-build" :)
01:15:00 <dmitri> getting: `cabal: unrecognised command: v2-build (try --help)
01:15:01 <dmitri> `
01:15:10 <davean> your cabal must be really old
01:15:19 <dmitri> likely :(
01:15:29 <davean> as they said above, ghcup would solve getting both ghc and cabal
01:15:30 <dminuoso> dmitri: You can just grab a new one, its just a single binary?
01:15:59 <dminuoso> dmitri: If your cabal is so old that it doesnt recognize v2-*, you really should get a newer version. :)
01:16:10 <davean> Get a modern GHC, get a modern cabal, ditch stack
01:16:23 <dmitri> what is the easiest way to get the new cabal?
01:16:28 <dminuoso> dmitri: ghcup
01:16:35 <dminuoso> dmitri: Let it manage your GHC and cabal for you.
01:16:56 <dminuoso> dmitri: https://github.com/haskell/ghcup#usage
01:17:27 <merijn> Or just "cabal install cabal-install" :p
01:17:39 <dminuoso> merijn: wow what does that even do 
01:17:50 <dmitri> dminuoso: thank you, trying now
01:17:58 <dminuoso> merijn: This would require shadowing the installation path of your old cabal with the cabal bin path, wouldnt it?
01:18:06 <merijn> dminuoso: It installs cabal-install?
01:18:27 <merijn> dminuoso: By default cabal is in ~/.cabal/bin and that's where cabal-installs binaries so it'd just overwrite
01:18:38 <merijn> dminuoso: Like...this has worked for over a decade
01:18:43 <dminuoso> merijn: I find that.. amusing. :)
01:18:50 <dminuoso> Okay I see
01:19:16 <merijn> dminuoso: v2-install doesn't overwrite unless prompted, so you need a flag to install, but v1-install on old versions will just work
01:19:47 <dminuoso> merijn: I see. I dont use v1 much anymore.
01:19:59 <maerwald> dminuoso: github is btw now a mirror
01:20:06 <merijn> Neither do I, but v2-install will just prompt you "hey you need this flag"
01:20:29 <dminuoso> maerwald: I instinctively avoided the gitlab repo since I wanted the website to work when they clicked on it.
01:20:36 <maerwald> hehe
01:21:02 <dminuoso> merijn: can you even use v2-install outside a project?>
01:21:13 <maerwald> yes
01:21:15 <merijn> dminuoso: eh...yes? That's the default
01:21:20 <dminuoso> Uh. Where do things get installed to?
01:21:25 <merijn> dminuoso: What does "inside a project" even mean for isntallation
01:21:26 <dminuoso> Or is there some sort of global profile?
01:21:35 <dminuoso> merijn: Mmm, I guess so.
01:21:46 <merijn> dminuoso: Why would you need a project file? There's only a global store anyway
01:21:59 <dminuoso> merijn: I wasnt aware you could manage a global profile
01:22:05 <dminuoso> I thought you only had project specific profiles
01:22:42 <merijn> dminuoso: What do you mean by "profile"?
01:23:31 <dminuoso> merijn: Im not sure what cabal calls it. So in nix you have the concept of a profile which is basically an environment in which you can see packages that are currently "activated" so to speak.
01:23:47 <merijn> dminuoso: libraries just get installed in the store (which is not very useful by itself) and executables get symlink into --symlink-bindir (which defaults to ~/.cabal/bin) and warns if there is already a symlink
01:23:54 <dminuoso> (Which consists mainly of symlinks from the global nix store inside some profile ⌜~/.nix-profile⌝
01:24:35 <merijn> There are also global profiles you can activate, but I forget how they work, tbh. Ask hvr :p
01:25:49 <dmitri> dminuoso: And even more problems with cabal :( https://gist.github.com/dmitriz/9a88a725c21225c868064f827044e140
01:26:16 <dminuoso> dmitri: You need to run ⌜cabal v2-update⌝ once, probably :)
01:26:51 <dmitri> I did and it is again trying to download: Downloading the latest package list from hackage.haskell.org
01:27:02 <merijn> dminuoso: The backtrace is saying python3 isn't in his pkgconfig
01:27:09 <dmitri> but the UX is much worse: no information whatsoever
01:27:20 <dmitri> at least stack informed me about the version
01:27:25 <dminuoso> merijn: Its also saying that no package list exists.
01:27:26 <dmitri> and the ETA
01:27:40 <merijn> dminuoso: oh, right
01:28:07 <dmitri> yes, I've also tried `cabal update`, see the gist
01:28:24 <dminuoso> dmitri: You need to run that first, then cabal v2-build
01:28:51 <maerwald> isn't it cabal v2-update?
01:29:07 <merijn> maerwald: iirc either works
01:29:53 <dminuoso> dmitri: Essentially "cabal [v2-]update" is akin to say "apt-get update" which grabs a new package list, such that cabal knows whats available in what version and so on.
01:29:58 <dmitri> dminuoso: still the same problem: how to get my latest version recognised?
01:30:16 <dmitri> I just need to build that package
01:30:20 <dminuoso> dmitri: Ahh I see.
01:30:47 <dmitri> btw, I had even tried to install that other one
01:31:02 <dmitri> but it is 215MB and got dropped in the middle :(
01:31:03 <dminuoso> dmitri: Can you share the full output you are getting?
01:31:24 <dmitri> https://gist.github.com/dmitriz/9a88a725c21225c868064f827044e140
01:31:46 <dminuoso> dmitri: Did you run "cabal v2-build" *after* update?
01:32:58 <dmitri> yes, after, before there were more errors
01:33:19 <dminuoso> dmitri: Can you try "cabal v2-update" rather than "cabal update", and then try another "cabal v2-build" ?
01:33:32 <dminuoso> dmitri: It's working for me, so it really should work for you too.
01:34:53 <dmitri> It is "working" for me too, in the sense that it proceeds to download that unspecified version :(
01:35:09 <dminuoso> dmitri: "download that unspecified version" ?
01:35:10 <dmitri> Downloading the latest package list from hackage.haskell.org
01:35:28 <dminuoso> dmitri: That updates cabal such that cabal knows about the current package list on hackage, our package repository.
01:35:43 <dmitri> at least stack gave some details
01:35:43 <dminuoso> dmitri: Without that, cabal doesnt know what packages/versions exist, how to get them, etc.
01:36:30 <dmitri> cabal cannot find my ghc?
01:36:35 <dmitri> why?
01:37:00 <maerwald> it can't?
01:37:14 <dminuoso> dmitri: What operating system are you on?
01:37:24 <dmitri> OSX 10.8.5
01:38:08 <dmitri> You mean it needs "latest package list from hackage.haskell.org"?
01:38:28 <dminuoso> dmitri: Do you have some ghc installed right now?
01:38:32 <dmitri> yes
01:38:36 <dmitri> the latest :)
01:39:35 <maerwald> how
01:39:49 <dmitri> with ghcup
01:39:56 <maerwald> did you follow the post-install instructions?
01:40:08 <dmitri> yes, everything worked fine
01:40:12 <maerwald> ghc --version
01:40:36 <maerwald> so you are sourcing the env file in your .bashrc?
01:40:36 <dmitri> The Glorious Glasgow Haskell Compilation System, version 8.6.5
01:41:05 <maerwald> then cabal should be able to find your ghc
01:41:07 <dmitri> I am on zsh, but the path seems working
01:43:40 <dmitri> possibly my version is not identified as "the latest"
01:44:44 <dmitri> and `cabal v2-update` runs `Downloading the latest package list from hackage.haskell.org` in what seems to run for indefinite time :(
01:44:51 <dmitri> frustrating :(
01:45:42 <dminuoso> 10:36:08       dmitri | cabal cannot find my ghc?
01:45:53 <dminuoso> dmitri: cabal just requires that the ghc binary be on the PATH in its environment.
01:46:59 <dmitri> yes, it is in `~/.ghcup/bin/ghc`
01:47:11 <dmitri> and it is in my path
01:47:19 <dminuoso> dmitri: Why did you ask that question, mind me?
01:47:41 <dminuoso> dmitri: Is it still trying to download the latest package list, by the way?
01:48:26 <dminuoso> I think the current package list is about 80MiB in size.
01:48:47 <dmitri> dminuoso: yes, that download is still ongoing, which question?
01:48:54 <dmitri> oh no :(
01:49:18 <dmitri> why does it need all 80MB on my drive?
01:50:14 <dmitri> no wait, it stopped
01:50:25 <dminuoso> dmitri: It's the full package list for all packages on hackage.
01:50:30 <dminuoso> dmitri: cabal needs it to function.
01:50:41 <dminuoso> dmitri: Without that package list, cabal couldnt create build plans, and so on
01:51:17 <dminuoso> (Well its not strictly true, but its true enough for most people)
01:51:20 <dmitri> so that is done, and the warning is gone, but now I am getting the same errors :(
01:51:33 <dminuoso> dmitri: Can you run "cabal v2-build -v3" and gist the output?
01:52:06 <merijn> $10 says *still* no python3 in pkgconfig, because that was in the first error and no amount of updating package lists is going to fix that
01:52:48 <dminuoso> Oh heh.
01:52:50 <dminuoso> True.
01:52:54 <dmitri> that prints a 64K file of logs
01:53:21 <dminuoso> dmitri: Im sorry, the last few bits I led you onto the wrong trail, that was my wrongdoing. merijn is absolutely right.
01:53:26 <dmitri> maybe this error: `[__0] rejecting: ptghci-0.1.0.0 (conflict: pkg-config package python3-any, not
01:53:27 <dmitri> found in the pkg-config database)
01:53:35 <dminuoso> dmitri: But for what its worth, updating cabal you had to do anyway. :)
01:54:54 <dmitri> *still* no python3 in pkgconfig? 
01:57:57 <dmitri> merijn: any way I can add my python3 there? so frustrating it is not recognised
01:58:49 <merijn> Do you have pkg-config installed at all (it's not by default on macOS) and the next question would be: do you have python3 installed, because that's also not on macOS by default
02:06:16 <dmitri> merijn: yes, both installed manually with macports
02:07:02 <dmitri> pkg-config --version
02:07:02 <dmitri> 0.29.2
02:08:02 <dmitri> please see here: https://gist.github.com/dmitriz/9a88a725c21225c868064f827044e140#gistcomment-2999178
02:19:07 <jusss> I don't know how to do it...
02:19:18 <jusss> get bind through >=> and return
02:19:45 <pong> :t (>=>)
02:19:48 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
02:20:01 <jusss> :t return
02:20:03 <lambdabot> Monad m => a -> m a
02:20:54 <Taneb> :t (>>=)
02:20:57 <lambdabot> Monad m => m a -> (a -> m b) -> m b
02:21:18 <jusss> and?
02:22:15 <Taneb> (it's helpful to be able to see what the shape of the answer should be, to me)
02:23:44 <merijn> :t \x f -> (const x >=> f) ()
02:23:46 <lambdabot> Monad m => m b -> (b -> m c) -> m c
02:24:58 <merijn> Actually
02:25:07 <merijn> :t \x f -> (id >=> f) x
02:25:10 <lambdabot> Monad m => m b -> (b -> m c) -> m c
02:25:56 <jusss> merijn: how we can get that throught the type inference?
02:26:35 <merijn> jusss: What do you mean by that?
02:26:44 <boxscape> can you get return from (>=>)? I think no?
02:27:54 <merijn> boxscape: No
02:27:59 <boxscape> okay
02:28:17 <jusss> merijn: how we get >>='s type throught >=> and return
02:28:25 <merijn> jusss: You don't
02:29:21 <merijn> You need something else, you can create >>= from just >=> and return
02:29:37 <jusss> x >>= f = (id >=> f) x  ?
02:31:18 <merijn> jusss: For example
02:33:06 <jusss> "<merijn> :t \x f -> (id >=> f) x  <lambdabot> Monad m => m b -> (b -> m c) -> m c"
02:33:27 <jusss> "<Taneb> :t (>>=) <lambdabot> Monad m => m a -> (a -> m b) -> m b"
02:34:28 * hackage log4hs 0.0.5.0 - A python logging style log library  https://hackage.haskell.org/package/log4hs-0.0.5.0 (gqk007)
02:34:52 <jusss> g >>= f = g (f x) x;    
02:35:12 <jusss> g >>= f = f (g x) x
02:35:12 <merijn> That's not the right type
02:35:23 <merijn> :t \g f -> f (g x) x
02:35:28 <lambdabot> (Expr -> t1) -> (t1 -> Expr -> t2) -> t2
02:35:41 <merijn> Wait, x isn't even a variable there
02:36:20 <jusss> g >>= f = (id >=> f) g
02:39:11 <jusss> wait, id can pass to >=> ?  <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
02:39:25 <jusss> :t id
02:39:30 <lambdabot> a -> a
02:39:42 <jusss> id is a->a not a-> m b
02:39:57 <boxscape> :t id :: (a -> m b) -> (a -> m b)
02:40:00 <lambdabot> forall k a (m :: k -> *) (b :: k). (a -> m b) -> a -> m b
02:40:11 <boxscape> oh that type ended up looking a bit more messy than I expected
02:41:00 <boxscape> (also I think it's not actually the type id has in this case)
02:41:04 <merijn> jusss: "id :: a -> a" so if I apply id to a value with type "m b" it's type becomes?
02:41:30 <jusss> m b?
02:41:33 <merijn> boxscape: That's also the wrong type in that code :p
02:41:51 <boxscape> yeah as I said :P
02:41:54 <merijn> :t id `asAppliedTo` (undefined :: IO Int)
02:41:57 <lambdabot> IO Int -> IO Int
02:42:05 <dramforever> > x + y
02:42:06 <boxscape> oh I didn't know about that function
02:42:07 <jusss> f >=> g = g(f y x) y  if we put id to f or g, but id will take two parameters
02:42:09 <lambdabot>  x + y
02:42:15 <merijn> :t id >=> return
02:42:18 <lambdabot> Monad m => m c -> m c
02:42:33 <merijn> :t id >=> (undefined :: Int -> IO Bool)
02:42:36 <lambdabot> IO Int -> IO Bool
02:42:54 <jusss> :t id >=> id
02:42:58 <lambdabot> Monad m => m (m c) -> m c
02:43:13 <merijn> That's the same as join, aka
02:43:19 <merijn> :t (>>= id)
02:43:22 <lambdabot> Monad m => m (m b) -> m b
02:44:09 <merijn> jusss: Type variables are just place holders
02:44:10 <merijn> :t id
02:44:12 <lambdabot> a -> a
02:44:15 <merijn> :t (>=>)
02:44:17 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
02:44:26 <merijn> Let's say "id :: x -> x" for simplicity
02:44:28 * hackage elliptic-curve 0.2.2 - Elliptic curve library  https://hackage.haskell.org/package/elliptic-curve-0.2.2 (sdiehl)
02:44:30 <jusss> I don't understand, f >=> g that f and g suppose to be binary functions, not unary
02:44:46 <merijn> jusss: Why are f and g supposed to be binary?
02:44:50 <jusss> but id is an unary funciton,
02:45:18 <jusss> merijn: f >=> g = g(f y x) y
02:45:19 <merijn> jusss: 1) all function in haskell are unary, 2) even if we pretend there are "binary functions" then the arguments of >=> still wouldn't b binary functions
02:45:30 <merijn> jusss: I don't know where you got that code from
02:45:45 <merijn> jusss: It doesn't parse, because 'x' is not in scope
02:45:45 <jusss> merijn: and that's wrong?
02:45:51 <tdammers> :t (>=>)
02:45:54 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
02:46:12 <tdammers> first and second arguments are both unary
02:46:23 <jusss> merijn: so what's the function defination of >=> ?
02:46:33 <tdammers> @source (>=>)
02:46:33 <lambdabot> Unknown command, try @list
02:46:39 <tdammers> @src (>=>)
02:46:39 <lambdabot> Source not found. I feel much better now.
02:46:49 <tdammers> brrr
02:46:54 <jusss> one shape which is properly for its type signature
02:47:02 <boxscape> :t \x -> f x >>= g
02:47:05 <lambdabot> (Monad m, Show a, Show t, FromExpr (m b), FromExpr (m a)) => t -> m b
02:47:25 <simon> isn't there another name for (.) . (.)?
02:47:27 <boxscape> oops forgot to include the arguments
02:47:29 <merijn> boxscape: f and g are not in scope
02:47:31 <boxscape> f >=> g   = \x -> f x >>= g
02:47:34 <tdammers> https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Control.Monad.html#%3E%3D%3E <- if you want to know, but for the learning experience, you might want to implement >=> yourself, in terms of the Monad methods
02:47:42 <merijn> simon: "Semantic Editor Combinators"?
02:48:00 <simon> merijn, sorry, I meant, was there a library that gives this its own identifier?
02:48:15 <simon> merijn, and thanks for that word :)
02:49:16 <jusss> merijn: what's the one function definition of >=> ?
02:49:28 <simon> merijn, I recall that maybe it was (.:)
02:49:57 <merijn> simon: Some people use .: but honestly, you shouldn't
02:50:08 <merijn> jusss: boxscape already gave it
02:50:13 <merijn> (or one of the possible ones)
02:50:27 <jusss> add:: Int -> Int      add x = x + x  or add x = x + 1 both are add :: Int -> Int
02:50:55 <jusss> merijn: you mean "<boxscape> f >=> g   = \x -> f x >>= g" ? 
02:50:59 <boxscape> simon this looks like a library https://hackage.haskell.org/package/composition-1.0.2.1/docs/Data-Composition.html
02:51:52 <MarcelineVQ> simon: also https://hackage.haskell.org/package/data-aviary
02:51:52 <jusss> then where I got this shape f >=> g = g(f y x) y ???
02:52:29 <MarcelineVQ> simon: note its readme though
02:53:04 <boxscape>  > Removed the "useful" combinators (to emphasize that Data.Aviary is not a utility library).
02:53:05 <boxscape> lol, ok
02:53:59 <boxscape> jusss I would imagine that you know better than any of us where you got that from
02:54:40 <jusss> boxscape: from internet
02:54:48 <boxscape> alright
02:55:50 <jusss> boxscape: and it's wrong?
02:55:55 <boxscape> yes
02:56:02 <jusss> holy 
02:56:19 <boxscape> I mean it's not even wrong, it doesn't mean anything, because x and y aren't defined
02:56:23 <dminuoso> jusss: I told you to not look for hints or solutions. ;)
02:57:02 <jusss> dminuoso: I don't know how to do type inference through two function's type to get another
02:58:19 <jusss> if we don't have function definition in the value level, only have type signature in the type level, can we get another's type signature through those two known type signatures?
02:59:06 <dminuoso> jusss: Do you have a simple example?
03:00:28 <jusss> dminuoso: we have known >=> and return's type signatures, can we get >>='s signature throught operating >=> and return's type signatures?
03:01:35 <jusss> >=>  return and >>= are values
03:01:57 <dminuoso> jusss: Widen your horzion, you are free to use any function at your disposal.
03:02:24 <dminuoso> jusss: Dont limit yourself to using only ⌜>=>⌝ and ⌜return⌝
03:04:30 <dminuoso> jusss: You can also just construct functions out of nothing
03:04:55 <jusss> dminuoso: totally confused
03:05:03 <dminuoso> % :t (>=>)
03:05:04 <yahb> dminuoso: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
03:05:12 <jusss> I have no idea about anything now
03:05:17 <dminuoso> % :t (>>=)
03:05:17 <yahb> dminuoso: Monad m => m a -> (a -> m b) -> m b
03:07:45 <dminuoso> jusss: Start by writing: ⌜f :: Monad m => m a -> (a -> m b) -> m b; f a b = undefined⌝ - now implement f.
03:08:01 <dminuoso> jusss: And constantly remind yourself of what the type of say "a" or "b" is in that.
03:08:21 <dminuoso> Or, to avoid potential confusion, name the parameters perhaps "s" and "t"
03:09:12 <jusss> dminuoso: ok, I will try it
03:09:33 <jusss> it may take several mins
03:09:46 <dminuoso> jusss: Of course you are not allowed to use (>>=), that'd be a silly thing to do.
03:09:50 <dminuoso> jusss: That's the rule of the game.
03:09:58 <dminuoso> You are also not allowed to use join.
03:10:24 <jusss> dminuoso: but that m how I can use a value to express it
03:10:35 <jusss> 'cause m has no value
03:10:50 <dminuoso> jusss: You dont need to be able to express it.
03:11:02 <jusss> ok
03:11:22 <dminuoso> jusss: "m" is basically some type you dont have control over, the caller of your function picks it.
03:11:59 <dminuoso> jusss: Remember how I told you, that you as the consumer of a polymorphic function, get to decide what the type variables are going to be?
03:12:19 <dramforever> Maybe try writing (>=>) using (>>=) first, then figure out how to 'reverse' that?
03:12:34 <dminuoso> Now you are the implementor, the roles have been switched.
03:37:57 * hackage pairing 0.5.0 - Bilinear pairings  https://hackage.haskell.org/package/pairing-0.5.0 (sdiehl)
04:00:22 <jusss> dminuoso: let's assume s :: y a, t :: a -> y b and y :: m so  a = s y; y b = t a = t (s y); f s t y = t (s y) y = b ?
04:00:40 <jusss> something's wrong
04:11:55 <kuribas> why doesn't NonEmpty have a foldMap using semigroup?
04:13:33 <kuribas> and fold?
04:14:38 <merijn> kuribas: Because those functions are from Foldable
04:14:43 <Taneb> kuribas: there's one in the semigroupoids library http://hoogle.jeeves.myrtle/file/nix/store/ga5ya9i6fgb3dnm6h5cl37m9drcf8ax5-semigroupoids-5.2.2-doc/share/doc/semigroupoids-5.2.2/html/Data-Semigroup-Foldable.html#t:Foldable1
04:14:45 <merijn> kuribas: And Foldable constrains them to Monoid
04:14:48 <Taneb> No that's a local link
04:15:03 <Taneb> http://hackage.haskell.org/package/semigroupoids-5.3.2/docs/Data-Semigroup-Foldable.html
04:15:09 <Taneb> ereu: 
04:15:17 <Taneb> (sorry, can't type today)
04:15:29 <merijn> kuribas: Also, Semigroup already has sconcat
04:15:31 <merijn> :t sconcat
04:15:33 <jusss> dminuoso: sorry, I have to go, see you later
04:15:34 <lambdabot> error:
04:15:34 <lambdabot>     • Variable not in scope: sconcat
04:15:34 <lambdabot>     • Perhaps you meant one of these:
04:15:41 <merijn> :t Data.Semigroup.sconcat
04:15:42 <Taneb> merijn: Foldable doesn't help you if you genuinely want to fold with a semigroup, with no reasonable identity
04:15:43 <lambdabot> Semigroup a => GHC.Base.NonEmpty a -> a
04:15:56 <merijn> Taneb: I know, I was just observing the reason
04:33:59 <kuribas> merijn: ah thanks, sconcat is what I was after
04:34:45 <kuribas> merijn: no sconcatMap?
04:34:56 <merijn> Dunno?
05:01:50 <infinisil> kuribas: mono-traversable has some methods for that: https://hackage.haskell.org/package/mono-traversable-1.0.12.0/docs/Data-NonNull.html#v:ofoldMap1
05:08:58 * hackage tagsoup-navigate 0.1.0.0 - Tagsoup Navigate  https://hackage.haskell.org/package/tagsoup-navigate-0.1.0.0 (TonyMorris)
05:32:09 <literall1Crevice> Is there a prettier way of doing `case maybeVar of { Nothing -> return (); Just t -> killThread t }`?
05:32:25 <dminuoso> literall1Crevice: maybe (return ()) killThread
05:32:31 <dminuoso> literall1Crevice: when
05:32:35 <dminuoso> Probably when :)
05:32:41 <literall1Crevice> :t when
05:32:43 <lambdabot> Applicative f => Bool -> f () -> f ()
05:32:44 <dminuoso> Oh, that doesnt work on Maybe ah 
05:32:56 <literall1Crevice> I could do isJust I guess
05:33:12 <dminuoso> literall1Crevice: Nah, that's not enough.
05:33:41 <literall1Crevice> Oh, isJust and fromJust but that's just ugly yeah
05:34:05 <dminuoso> literall1Crevice: Id just use the case-of and live with it. Its what I do.
05:34:15 <dminuoso> literall1Crevice: You could also use a separate function, perhaps.
05:34:28 <dminuoso> ⌜f Nothing = pure (); f (Just t) = killThread t⌝
05:35:50 <literall1Crevice> Yep, creating my function ended up being the best way for me
05:38:21 <Ariakenom> it might make sense to replace (or augment) the Maybe ThreadId with a IO () cleanup action
05:38:53 <fendor> literall1Crevice, there is also `whenJust` in `extra` 
05:38:59 <fendor> @type whenJust
05:39:01 <lambdabot> error: Variable not in scope: whenJust
05:39:03 <MarcelineVQ> % :t mapM_ killThread
05:39:03 <yahb> MarcelineVQ: Foldable t => t ThreadId -> IO ()
05:39:22 <literall1Crevice> Oh that's cool
05:39:33 <Ariakenom> traverse is always the answer
05:39:36 <dminuoso> fendor: Ah good catch. extra has some nice combinators, but I rarely feel its worth pulling that package in.
05:39:56 <dminuoso> MarcelineVQ: You win. :)
05:40:07 <dminuoso> MarcelineVQ: Though I'd use traverse_ rather than mapM_
05:40:09 <fendor> dminuoso, agreed
05:40:56 <MarcelineVQ> I'd probably use the helper function :>
05:41:10 <MarcelineVQ> since you can give it an informative name
05:41:56 <dminuoso> MarcelineVQ: That actually makes it way more difficult, naming is one of the hardest things.
05:44:13 <Ariakenom> dminuoso: nah a name can certainly be useful and easy here
05:44:54 <dminuoso> Ariakenom: Sure, I suppose in this case its easy naming it, since it's effectively just Maybe flavoured killThread 
06:29:07 <Licumbre> Hi!
06:29:10 <Licumbre> Anyone there?
06:29:18 <tdammers> no
06:29:43 <Licumbre> I'll take that as a yes, thank you.
06:29:44 <tdammers> (in other news, this is one of the busiest channels on IRC, but still, if you have a question, just ask)
06:30:24 <Licumbre> OK
06:30:26 <Licumbre> thx
06:31:11 <Licumbre> So I've just started out with Haskell, and this is my first functional language.
06:31:16 <Licumbre> And this code:
06:31:31 <Licumbre> divtup :: (Int, Int) -> Double; divtup (x,y)=x/y
06:31:46 <tdammers> yeah, that doesn't work
06:32:11 <Licumbre> oh sorry
06:32:16 <tdammers> the / operator isn't integer division, and it's not defined for integers
06:32:38 <Licumbre> ok so should i use div?
06:32:44 <tdammers> if you make it :: (Double, Double) -> Double -- then it would work
06:32:52 <tdammers> or you could use div, yes, that one does integer division
06:32:58 <tdammers> and then the return value also must be Int
06:33:01 <Licumbre> by the way the double wasn't meant to be there
06:33:05 <Licumbre> that's why I said sorry
06:33:09 <tdammers> oh, OK
06:33:19 <Licumbre> OK. Thanks very much for the help!
06:33:27 <tdammers> so divtup :: (Int, Int) -> Int; divtup (x,y) = x `div` y -- ?
06:33:42 <Licumbre> Yeah. That's what I had in the first place.
06:33:48 <tdammers> that should work
06:34:44 <Licumbre> Well it gave me 'divtup :: (Int, Int) -> Double; divtup (x,y)=x/y'
06:34:54 <Licumbre> I mean
06:34:57 <tdammers> "it" being?
06:35:08 <Licumbre> GHCI (Arch)
06:35:28 <Licumbre> No instance for (Fractional Int) arising from a use of '/'
06:35:33 <tdammers> right, yes
06:35:44 <tdammers> that's GHC's way of telling you that the / operator isn't defined for Int
06:36:03 <Licumbre> ok. thanks very much.
06:36:11 <tdammers> you see, (/) is a perfectly normal function, there is nothing special about it, but it does have to work for more than type
06:36:24 <tdammers> you can use it on Double, Float, Scientific, Rational, etc.
06:36:36 <tdammers> in order to allow that, it has to be polymorphic
06:36:38 <tdammers> :t (/)
06:36:40 <lambdabot> Fractional a => a -> a -> a
06:36:59 <Licumbre> Ah.
06:37:08 <Licumbre> Well that's good to know.
06:37:11 <tdammers> see that? that basically says, the type of (/) is a -> a -> a, and there must exist an instance Fractional a (i.e., a must have a Fractional instance)
06:37:27 <tdammers> but Int doesn't have a Fractional instance, so you can't use / on it
06:37:44 <tdammers> and that is actually correct, because you can't do proper division on integers
06:37:54 <tdammers> (you can't really do it on floats either, but that's a whole different can of worms)
06:38:03 <tdammers> whereas:
06:38:05 <tdammers> :t div
06:38:07 <lambdabot> Integral a => a -> a -> a
06:38:16 <Licumbre> Yeah, but that returns an Int, right?
06:38:33 <tdammers> it returns whatever you give it, but that whatever must have an Integral instance
06:38:40 <tdammers> which Int does
06:38:47 <tdammers> however, observe:
06:38:57 <tdammers> :t (1 :: Int) `div` (2 :: Int)
06:38:59 <lambdabot> Int
06:39:04 <tdammers> :t (1 :: Integer) `div` (2 :: Integer)
06:39:05 <lambdabot> Integer
06:39:13 <tdammers> :t (1 :: Word8) `div` (2 :: Word8)
06:39:15 <lambdabot> Word8
06:39:24 <tdammers> and also:
06:39:27 <tdammers> :t (1 :: Word8) `div` (2 :: Int)
06:39:29 <lambdabot> error:
06:39:29 <lambdabot>     • Couldn't match expected type ‘Word8’ with actual type ‘Int’
06:39:29 <lambdabot>     • In the second argument of ‘div’, namely ‘(2 :: Int)’
06:39:39 <tdammers> it doesn't work if both operands aren't the same type
06:40:03 <tdammers> you can pick any "a" you like that has a suitable instance, but once you pick it, it must be the same "a" for the entire type signature
06:40:55 <Licumbre> Once again, thanks. That was really helpful and I learned something!
06:45:21 <jollygood2> > let divtup = uncurry div in divtup (10, 3)
06:45:24 <lambdabot>  3
06:45:57 <jollygood2> > uncurry div (10, 3)
06:46:01 <lambdabot>  3
06:47:21 <tdammers> jollygood2: yes, uncurry also works, but I feel that would have induced a bit too much brain pain
06:52:27 * hackage apecs-physics 0.4.3 - 2D physics for apecs  https://hackage.haskell.org/package/apecs-physics-0.4.3 (jonascarpay)
07:04:43 <literall1Crevice> Reading the documentation for threadDelay, I see that there is no guarantee that it will run right after the delay has expired. How common is that and what should I do (other than busywaiting) if I want to guarantee the thread will resume right after the delay ended?
07:06:05 <Ariakenom> literall1Crevice: busy waiting also won't guarantee that it will run right after. due to haskell scheduling and os scheduling. so use threadDelay.
07:07:03 <literall1Crevice> Alright, thanks
07:07:04 <dmitri> Hi folks, anyone knows how to get syntax highlighting in GHCi repo? 
07:07:08 <dmitri> repl
07:07:19 <Bish> is that a thing?
07:07:36 <dminuoso> dmitri: Where do you want the syntax hilighting to occur?
07:07:43 <dminuoso> dmitri: On past commands?
07:07:45 <merijn> Bish: You could override the output print to ANSI formatting
07:08:02 <dmitri> similar to iPython
07:08:03 <merijn> literall1Crevice: Define "right after"
07:08:15 <dminuoso> dmitri: I do not know iPython.
07:08:20 <literall1Crevice> merijn: ASAP
07:08:32 <merijn> literall1Crevice: threadDelay will already be ASAP, tbh
07:08:34 <dmitri> just some syntax highlighting on the commands I am entering
07:08:42 <literall1Crevice> Then that's what I'll go for
07:08:45 <dmitri> everything is black right now
07:08:47 <literall1Crevice> Hopefully this won't be an issue
07:08:57 <merijn> literall1Crevice: The RTS sets a timer then gets notified via epoll when the timer expires
07:09:01 <dminuoso> dmitri: Generally GHCi is not used much for active development.
07:09:15 <dminuoso> dmitri: Rather write your code in an editor with syntax hilighting support, perhaps?
07:10:01 <merijn> literall1Crevice: What that warning means is: If the OS doesn't schedule the program to run (because of high load) then you obviously won't wake up until the program runs again, etc.
07:10:15 <merijn> literall1Crevice: Guaranteeing realtime response requires stuff like custom kernels, etc.
07:10:29 <literall1Crevice> But under regular conditions everything should be fine?
07:10:43 <merijn> yeah
07:10:56 <merijn> literall1Crevice: It's not like its going to randomly wait for 10 seconds
07:11:07 <dmitri> dminuoso: Can I run code from editor? I am testing it in GHCi. 
07:11:18 <merijn> literall1Crevice: It's just not *guaranteeing* immediate response, because that can't really be done
07:11:29 <literall1Crevice> Alright, that's great
07:11:37 <dminuoso> dmitri: Interactive development not well suited for Haskell.
07:11:42 <literall1Crevice> Although my design (in other parts) is very hacky so let's see how it goes
07:12:06 <dminuoso> dmitri: The closest thing is writing code in your editor, while having a GHCi session and reloading the code you have written.
07:12:13 <jgt> dmitri: are you sure you want syntax highlighting? Or do you just want coloured output?
07:12:37 <jgt> oh, sorry, I missed where you said that already
07:12:52 <jgt> I don't think GHCi knows how to do that
07:13:58 <dmitri> jgt: yes, coloured output would be fine too
07:14:25 <dmitri> it is mostly to test new patterns
07:14:50 <jgt> dmitri: https://wiki.haskell.org/GHCi_in_colour
07:14:50 <dminuoso> dmitri: I have found that the behavior of "constantly testing code and visually inspecting output in an interactive manner" is indicative of not willing to accept abstractions.
07:15:05 <dminuoso> dmitri: I mean you generally dont run your code through QEMU just to interactively see whats going on in your processor, do you?
07:16:53 <dminuoso> Perhaps it comes from languages that are so stateful that you can't keep the state of your program in your head anymore, such that you have to constantly check to verify whether your assumed state of the program is correct.
07:17:11 <boxscape> dmitri: probably not what you want, but there *is* a haskell kernel for IPython, fwiw https://github.com/gibiansky/IHaskell
07:17:17 <dmitri> dminuoso: I mean small code fragments, to test 
07:17:18 <dminuoso> Or when there's no type system to help ou express these assertions. :)
07:17:35 <__monty__> dminuoso: You have to familiarise yourself with the abstractions somehow though.
07:17:37 <dmitri> > indicative of not willing to accept abstractions. -- can you explain?
07:17:39 <lambdabot>  <hint>:1:12: error: parse error on input ‘of’
07:17:52 <mycroftiv> i love abstractions, but im just not good enough to get things right without constant testing. i think i reloaded my .hs definitions file 200 times in the past three hours
07:18:17 <dmitri> boxscape: been trying to install it but having massive problems unfortunately
07:18:26 <boxscape> hm, I see
07:18:46 <dmitri> And this one as well: https://gist.github.com/dmitriz/c112328cbee95fa38f10448e5bd44cea
07:20:01 <dmitri> jgt: thank you, will check it out!
07:21:42 <maralorn> I guess what the above mentioned warning is saying is: Don‘t program a clock based threadDelay. It will go to slow. For nearly anything else it’s fine.
07:21:55 <dmitri> dminuoso: I'm still learning at this stage, no serious code
07:22:03 <merijn> maralorn: Well, also don't do real time using threadDelay..
07:22:04 <tdammers> dminuoso: it's an entirely different mindset - rather than trying to write correct code, you embrace incorrectness and failure, and just write code that doesn't fall on its face entirely when encountering failure
07:22:25 <tdammers> dminuoso: personally, I cannot manage to be productive in that mindset, but I have seen people who can, idk
07:22:29 <dmitri> My most code is in JS, but lots of patterns are from Haskell
07:22:46 <dminuoso> dmitri: I recommend the "editor" with GHCi in another window approach.
07:22:46 <dminuoso> dmitri: If you use emacs you can do both inside the same editor.
07:22:46 <dminuoso> __monty__: Mmm perhaps.
07:23:35 <tdammers> my usual setup is editor in one terminal, and then one or two terminals 'off hand' constantly showing compilation output and/or test results
07:23:44 <__monty__> Oh, editor integration. Yeah, I've kinda given up on that for now.
07:23:52 <mycroftiv> i dont think the use of a tight iterative testing loop means you dont want to write correct code. i evolved that pattern because it seemd to help produce software that fulfilled the spec reliably in practice
07:24:02 <tdammers> the worst part about editor integration is that it's so bloody language-specific
07:24:13 <tdammers> the whole point of learning vim is that you only have to do it once
07:24:22 <merijn> tdammers: That's why we all cross our fingers and hope for LSP to take off
07:24:34 <tdammers> my setup works for all languages, even those that haven't been invented yet
07:24:36 <tdammers> merijn: LSP?
07:24:51 <__monty__> tdammers: What HIE uses under the hood.
07:25:02 <mycroftiv> and the reason i reloaded my .hs file 200 times is that im actually pursuing formal correctness and trying to use haskell to help me achieve it. its really hard learning but entirely worth it. pursuing formal correctness i dont see as against hands on testing
07:25:04 <tdammers> oh, OK
07:25:07 <merijn> tdammers: https://langserver.org/
07:25:55 <maralorn> tdammers: dminuoso: I must admit I often work with „not sure what this function/option/program does, let’s just try and recompile/restart/reboot“ I think it’s especially common with people who are selftaught.
07:26:03 <Ariakenom> maralorn: what do you mean with "program a clock based threadDelay"
07:26:59 <maralorn> But otoh often when doing pair programing I am startled at how often my partner is okay with testing (to compile) a program for which we have no indication it should work.
07:27:15 <tdammers> personally, I don't think there is anything wrong with fast feedback cycles; the thing I have a problem with is relying on experimental data alone to assert correctness
07:27:28 <boxscape> maralorn what sort of compilation time are we talking here?
07:28:11 <tdammers> i.e., rather than knowing that certain properties hold because you constructed your code that way, and your toolchain has verified that your construction does indeed guarantee the desired property, you just write the bloody code and then tinker with it in a REPL, or pepper it with unit tests, until you are convinced that you have probably covered all the possible edge cases
07:28:25 <maralorn> Ariakenom: I mean "loop = threadDelay 60 >> printTime >> loop".
07:28:53 <mycroftiv> tdammers: i agree with the caveat that with some software and problem domains, automated testing can provide 100% assurance if the input/output space is small enough to be exhaustively verified, of course this is just a different way to skin the formal verification cat
07:28:59 <maralorn> boxscape: Short, but it seems like a waist to me anyway. Writing Code without trying to understand it.
07:29:07 <boxscape> yeah that makes sense
07:29:47 <maralorn> Ariakenom: No, that’s actually not what I meant.^^
07:29:47 <tdammers> mycroftiv: yes, of course. if you can test 100% of inputs, then that's of course fine. And I'm not saying you shouldn't resort to automated tests when correctness by construction is no longer feasible, or comes at too high a cost
07:30:27 <maralorn> loop time = threadDelay 60 >> printTime (time + 60) >> loop (time + 60)
07:30:42 <mycroftiv> sometimes there can be a really cool union of the logical level correctness and exhaustive testing, like in this code: http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
07:32:50 <Ariakenom> maralorn: that would drift even if threadDelay was "prompt" because there is some other overhead
07:36:37 <maralorn> well it probably would.
07:37:00 <maralorn> depends on how precise you want your clock to be.
07:37:48 <maralorn> I once programed a clock on my TI-83 by first benchmarking some slowoperation and tuning it to take "exactly" one second.^^
07:38:16 <maralorn> An empty for loop or something.^^
07:39:28 * hackage hoauth2 1.8.9 - Haskell OAuth2 authentication client  https://hackage.haskell.org/package/hoauth2-1.8.9 (HaishengWu)
07:44:50 <Ariakenom> maralorn: TI was how I started programming. I remember optimising a friends snake game so it became playable
07:47:17 <mmfood> New to haskell and tried this https://repl.it/repls/MerryWonderfulCustomers -- I understand that the type of [] is ambiguous since there is no element to induce the type and so the print statement doesn't know how to print it. But how do I make this work?
07:47:38 <literall1Crevice> mmfood: Give it a type. [] :: [Int]
07:47:48 <literall1Crevice> (didn't read the code, just went off your description)
07:48:32 <Ariakenom> yes, but you will need parens ([] :: [Int])
07:48:43 <Ariakenom> in this case
07:48:50 <mmfood> literall1Crevice: ok, where do I put that? Like this: print( makeSet [] :: [int]) -- 
07:49:09 <ski> needs more brackets
07:50:02 <mmfood> huh, that worked. Thought I'd tried that
07:51:50 <mmfood> alright, thanks for the quick feedback :)
08:05:34 <dmitri> Has anyone been using colorising packages like this one: https://hackage.haskell.org/package/hscolour
08:05:45 <dmitri> hscolour: Colourise Haskell code.
08:07:03 <dmitri> I was able to install it with cabal but still miss how to actually use it with GHCi
08:08:17 <dminuoso> dmitri: GHCi is not made for syntax hilighting, honestly.
08:08:22 <boxscape> dmitri I believe the basic idea is that you simply run `ghci | hscolour` instead of `ghci`
08:09:11 <dminuoso> boxscape: That will likely misbehave because there's terminal control characters being sent too.
08:09:16 <dmitri> dminuoso: I don't understand why
08:09:43 <dminuoso> dmitri: Even GHCi is a weird imitation. It's not true repl because Haskell code needs to be type checked and compiled.
08:10:19 <boxscape> on the page linked above they say "this works relatively nicely"  ghci 2>&1 | HsColour -tty
08:10:22 <boxscape> the page being https://wiki.haskell.org/GHCi_in_colour
08:10:26 <dmitri> is "hscolour" supposed to be created by cabal?
08:10:40 <dminuoso> boxscape: Interesting, okay.
08:10:51 <boxscape> well it's HsColour apparently, I got the capitalization wrong dmitri
08:11:23 <dmitri> I only have HsColour.hs
08:12:22 <boxscape> by the way there's this reddit post linked in the wiki as well which has some interesting ideas https://old.reddit.com/r/haskell/comments/144biy/pretty_output_in_ghci_howto_in_comments/
08:12:46 <boxscape> dmitri I think if you ran "cabal install" it should have created an executable, maybe the directory isn't in your PATH
08:13:13 <dmitri> boxscape: yes, that is 6 yrs old, and linked to  http://www.haskell.org/haskellwiki/GHCi_in_colour
08:13:40 <boxscape> hm, they link to each otehr
08:14:27 <dmitri> boxscape: isn't it cabal v2-build?
08:14:48 <boxscape> I haven't used cabal in ages, but I would expect that it only creates an executable if you run install
08:14:54 <dmitri> cabal v2-install: cabal: symlink-bindir is not defined. Set it in your cabal config file or use
08:15:07 <dmitri> --symlink-bindir=<path>
08:15:24 <boxscape> ideally I'd recommend using stack over cabal
08:15:40 <boxscape> although I haven't used that either in a while since I'm on nixos
08:16:28 <dmitri> dminuoso: I've tried to use my console in editor but there is no colour there either
08:17:22 <dmitri> boxscape: can I use nixos instead of cabal?
08:17:59 <boxscape> only if you feel like installing a different operating system. You could still use nix (without nixos), but I think probably makes more sense to use stack for most people
08:19:03 <jumper149> Do you have any recommendation on GUI libraries for a 3-dimensional turn based game?
08:19:48 <asheshambasta> https://gist.github.com/asheshambasta/a55471d05ac31b470197d9f04257d16f -- why does the commented part cause ambiguity? 
08:22:09 <int-e> asheshambasta: As the error message says, it can't figure out what a is from just DBId a.
08:22:40 <int-e> asheshambasta: Apparently the line before that works because `a` can be determined from `IntegrationEvent a` instead.
08:23:07 <int-e> Err, wait.
08:23:26 <int-e> No, don't wait. I think that's the right explanation.
08:23:29 <dmitri> boxscape: running stack install begins downloading some old version, which is around 200MB :(
08:23:47 <int-e> asheshambasta: maybe you can get away with replacing (DBId a) by a type variable?
08:23:57 <asheshambasta> int-e: I only added the `IntegrationEvents a` constraint to the constructor later; it compiles with just `SubAffectedReportable (DBId a)`
08:24:19 <boxscape> dmitri: old version of what?
08:24:19 <asheshambasta> (the `SubAffectedIntegration` constructor; that is.)
08:25:16 <int-e> asheshambasta: I mean the `IntegrationEvent a` type, not the `IntegrationEvents a` constraint.
08:25:47 <dmitri> ghc-8.2.2:  100.53 KiB / 183.55 MiB (  0.05%) downloaded
08:26:42 <asheshambasta> int-e: see https://gist.github.com/asheshambasta/a55471d05ac31b470197d9f04257d16f#file-alsocompiles-hs (and `Compiles.hs`))
08:27:35 <dmitri> boxscape: I had asked about this problem and was told to use cabal instead
08:27:49 <int-e> asheshambasta: The constraints hardly matter. If you have a type family  Foo a,  then any function or constructor like  foo :: Foo a -> ()  will cause an ambiguous type error because `a` cannot be determined from `Foo a`. This can be resolved by mentioning `a` explicitly in the signature, foo :: Foo a -> Proxy a -> ()
08:27:50 <dmitri> why do you recommend stack over cabal?
08:28:26 <int-e> asheshambasta: as I said, apparently the compiler can figure out `a` from `IntegrationEvent a`.
08:28:49 <boxscape> dmitri as far as I know stack is recommended much more these days, because it makes dependency management much, much easier. I believe if you run "stack install hscolour" it takes a version of ghc that it knows works with hscolour, so I assume that's why it's using 2.2. Though for details, other people here are better sources, because as I've said 
08:28:49 <boxscape> I haven't used it in a while
08:29:09 <int-e> asheshambasta: if you change that to `IntegrationEvent b` you'll get the same compilation error. The constraints should not affect this at all.
08:29:13 <boxscape> 8.2.2, rather
08:29:30 <asheshambasta> int-e: I see; yeah I had thought of adding the `Proxy a`; but I was thinking that I was missing something obvious here. 
08:30:25 <boxscape> though hscolour is in stackage snapshots labeled "ghc-8.6.5", so I don't really know tbh
08:33:10 <llars> heeeeeeelp me I am diein... how to install haskel on mac??? There says in the end of termianl installation something like 'Installation done!Don't forget to source /Users/----------/.ghcup/env in your ~/.bashrc or similar.'
08:33:54 <llars> what does thies mean to source?
08:35:50 <boxscape> I... maybe this is getting repetitive, but I would recommend installing ghc via stack, llars. https://docs.haskellstack.org/en/stable/install_and_upgrade/#macos
08:36:28 <boxscape> though "source <filename>" is a command that they recommend you add to your ~/.bashrc file, with the filename being, I suppose, /Users/.../.ghcup/env
08:41:15 <asheshambasta> int-e: as I understand it (from what you say); the compiler here wants to know what `a` is based on the arguments to the constructor; right? And given that DBId a is non-injective, it can't. 
08:41:23 <asheshambasta> thanks; that cleared things up for me. 
08:41:49 <llars> yeah i try what you say, thx big thaaaanks for support
08:44:11 <llars> okok i was confused and i should stuture my problem a bit better...
08:45:21 <__monty__> llars: The .bashrc question is eminently googleable btw.
08:48:25 <llars> I found out if i run the code line that stands in env ( /Users/.../.ghcup/env )(this is the code line: export PATH="$HOME/.cabal/bin:${GHCUP_INSTALL_BASE_PREFIX:=$HOME}/.ghcup/bin:$PATH")  then every thing works and i can use the command ghc, so where i have this line. I really dont understand what ~/.bashrc is, because its not on my computer. even
08:48:25 <llars>  if i look on the hidden files.
08:49:28 <wildtrees[m]> You might have to make .bashrc
08:49:31 <llars> and yeah of course i google it, bu f y I am sitting now for 3h on this shit 
08:49:37 <boxscape> can you run "ls ~/.bashrc"?
08:50:25 <wildtrees[m]> It is a file run by bash on startup for a given user
08:50:28 <llars> no i cant run it
08:50:48 <boxscape> You can't run it or you run it and it gives you an error?
08:50:50 <llars> ohmen i am such a noob
08:51:09 <boxscape> we all were at some point
08:52:18 <wildtrees[m]> I just use the haskell platform when I dont need a specific version
08:52:28 <llars> i just need this f programming langue for university and i never used it but i hate it right now
08:52:46 <jgt> llars: sucking at something is always the first step towards being good at something
08:53:02 <llars> your e tottaly right!
08:53:03 <boxscape> llars when you say "you can't run it", does that mean it gives you an error or that you don't know how to run it?
08:53:57 <llars> hahah boxscape the second.... I dont know I typed 'cd bla bla' then 'run .bashrc'nnothing happend
08:54:37 <boxscape> just type "ls ~./bashrc", and press enter
08:54:39 <wildtrees[m]> If you are computer major learning some unix command line tools will only help you
08:54:41 <boxscape> ah wait
08:54:43 <boxscape> I mistyped
08:54:47 <boxscape> ls ~/.bashrc
08:54:52 <boxscape> and press enter
08:55:06 <boxscape> (ls checks whether the file exists)
08:55:50 <llars> no such file
08:56:01 <boxscape> okay
08:56:37 <boxscape> do you have an editor you edit text files with usually?
08:57:18 <boxscape> (if yes, we'll use it, if no, we'll do it without an editor)
08:58:12 <llars> like i sad i have the code line in 'Users/.../ghcup/env' this codeline works and the installer of haskel told i have to source it in ~/.bashrc
08:58:19 <llars> what does this mean
08:58:31 <llars> what should i do with this editor
08:58:42 <boxscape> there is a unix command called "source", which takes the commands inside of a file and run it
08:59:07 <boxscape> so if you open a new file, put in the command "source Users/.../ghcup/env"
08:59:14 <boxscape> and save it as .bashrc in your home directory
08:59:31 <boxscape> it will run the commands in that file every time you open up your terminal
08:59:41 <boxscape> because everything in .bashrc is run every time you open your terminal
08:59:47 <llars> ahhhhhh thats what i want i love you
09:00:26 <llars> i try
09:01:39 <llars> how to save it as a bash ?
09:02:04 <boxscape> don't save it.. as a bash, save it under the name .bashrc
09:02:09 <boxscape> in your home directory
09:04:33 <llars> boxscape I love you <3
09:04:43 <llars> it worked
09:04:43 <boxscape> you're welcome. Does it work?
09:04:45 <boxscape> nice
09:05:08 <llars> really big THANK YOU
09:05:12 <boxscape> no problem :)
09:20:09 <lihram> Hey guys! does someone have time to help me with a simple type exception I'm getting?
09:20:35 <glguy> lihram: On IRC you just ask your questions and provide enough detail so that other users can tell if they'll be able to help you
09:20:50 <glguy> and then wait to let people see it as people come and go
09:22:14 <lihram> <glguy "lihram: On IRC you just ask your"> Thanks! I'm using matrix, but is there a general standard for formatting code on IRC, or do you prefer pastebin/gist etc?
09:22:39 <jgt> pastebin/gist
09:22:40 <glguy> This matrix channel is just a bridge into the freenode #haskell IRC channel
09:22:45 <glguy> You can put code on a pastebin
09:23:22 <__monty__> I think the matrix bridge automatically pastebins long content though.
09:23:40 <glguy> but it doesn't do syntax highlighting, support comments, etc
09:23:49 <glguy> better to use a real pastebin
09:24:20 <__monty__> lihram: I *would* like to ask you not to quote or reply-to though. It makes it a lot more confusing to follow the conversation on the other side of the bridge.
09:25:11 <wildtrees> lihram, "The matrix has you!" 
09:26:08 <lihram> __monty__: Yeah, sorry, I realized afterwards
09:26:48 <__monty__> lihram: np, just mentioned it because other matrix users didn't catch on so quick.
09:53:13 <wildtrees> so if I want a semigroup on Maybe that propagates failures/Nothing as an absorber of Just, what do I do? 
09:54:06 <glguy> wildtrees: Maybe already has a Semigroup instance, so you can't make a new instance. If you want to make a different type you can use a newtype
09:55:13 <phadej> that won't be lawful semigroup
09:55:25 <phadej> ah, it will be a semigroup, but not monoid
09:55:30 <dmwit> wildtrees: You might like Ap.
09:56:04 <dmwit> > Ap (Just "Hello, ") <> Ap (Just "world!")
09:56:06 <lambdabot>  Ap {getAp = Just "Hello, world!"}
09:56:13 <dmwit> > Ap (Just "Hello, ") <> Ap Nothing
09:56:16 <lambdabot>  Ap {getAp = Nothing}
09:56:56 <dmwit> Ap has a fine monoid instance, too.
09:56:58 <phadej> > Ap (Just "Hello, ") <> mempty
09:57:01 <lambdabot>  Ap {getAp = Just "Hello, "}
09:57:04 <phadej> ah, yes.
09:57:08 <phadej> i'm silly
09:57:58 <boxscape> is that derived from the Applicative instance?
09:58:09 <phadej> yes
09:58:11 <boxscape> I see
10:02:59 <wildtrees> dmwit, where do I get this Ap instance from? 
10:03:11 <phadej> :i Ap
10:03:15 <phadej> :(
10:03:20 <phadej> % :i Ap
10:03:20 <yahb> phadej: type role Ap representational nominal; newtype Ap (f :: k -> *) (a :: k) = Ap {getAp :: f a}; -- Defined in `Data.Monoid'; instance Alternative f => Alternative (Ap f) -- Defined in `Data.Monoid'; instance Applicative f => Applicative (Ap f) -- Defined in `Data.Monoid'; instance forall k (f :: k -> *) (a :: k). Eq (f a) => Eq (Ap f a) -- Defined in `Data.Monoid'; instance Functor f => Functor (Ap f) 
10:03:37 <wildtrees> hmmm ty! 
10:03:45 <dmwit> (short answer: Data.Monoid)
10:03:58 <boxscape> "type role Ap representational nominal" what does this mean?
10:04:51 <phadej> thing for Coercible/coerce, https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/coercible.pdf
10:04:59 <boxscape> okay
10:05:07 <boxscape> thanks
10:08:37 <wildtrees> uhh my base is too old, 4.11 , since 4.12 :( 
10:10:13 <phadej> https://hackage.haskell.org/package/reducers-3.12.3/docs/Data-Semigroup-Apply.html#t:App
10:10:40 <phadej> sorry, https://hackage.haskell.org/package/reducers-3.12.3/docs/Data-Semigroup-Applicative.html#t:Ap
10:11:02 <mniip> :D
10:11:11 <mniip> shameless plug http://hackage.haskell.org/package/coercion-extras
10:19:25 <tchakka> Anyone experience with TQueues?
10:20:13 <tchakka> If I use tryReadTQueue, I'm interpreting the docs as this also returning Nothing when another transaction tries to write to that same queue. But... what?
10:20:42 <tchakka> Or will it only return Nothing when the queue is empty, and silently retry only itself when something else writes to the queue?
10:24:10 <tchakka> Context: I'm getting a whole bunch of `(Key, Payload)` tuples from somewhere, and dealing with all of those sequentially causes a lot of delay. Now, it's important that they run sequentially per Key, but each Key can be processed concurrently.
10:25:01 <tchakka> So the idea is to have a Map Key (TQueue Payload) somewhere, and worker-threads per Key.
10:25:23 <dmwit> tchakka: You must distinguish between "calls the retry function" and "runtime system causes it to be aborted and restarted because of contention".
10:25:36 <dmwit> tryReadTQueue does not call the retry function, but it may be aborted and restarted.
10:26:30 <tchakka> Now there can be many different Keys, and messages typically come in bursts, and I don't want the map clogged up with queues that have been empty for a while.
10:26:33 <tchakka> Ah, check.
10:26:42 <phadej> tryReadTQueue is "non-blocking" read. If there's nothing in the queue, you'll get Nothing
10:27:12 <tchakka> So... if tryReadTQueue returns Nothing, and I then remove that TQueue from the map in the same transaction, then I'm good to go?
10:27:12 <dmwit> phadej: That doesn't address the actual question, though, which is: if it is currently empty, and somebody else puts something in while I'm checking whether it's empty, what happens?
10:27:27 <phadej> dmwit: non-determism happens
10:27:43 <tchakka> As in, if something writes to it, it retries, and tryReadTQueue will then be Just. And if nothing writes to it, it'll be gone.
10:28:02 <int-e> tryReadTQueue c = fmap Just (readTQueue c) `orElse` return Nothing -- I think what matters here is under which circumstances readTQueue calls `retry` and that only happens if it sees that the queue is empty.
10:28:15 <dmwit> tchakka: Yes, then you're good to go.
10:28:33 <tchakka> But yeah, "runtime system causes abort and restart because of contention" being different from "programmer wrote 'retry'" is a good point. Cheers!
10:29:17 <int-e> As far as I understand STM, that's the only case where the `return Nothing`  is allowed to proceed.
10:30:40 <phadej> If I understand right, then no, removing the key from map is not safe
10:30:42 <MarcelineVQ> 'cause orElse is so darn cool
10:30:59 <phadej> it depends on when the keys are also inserted into TVar (Map Keu (TQueue Payload))
10:30:59 <MarcelineVQ> https://www.oreilly.com/library/view/parallel-and-concurrent/9781449335939/ch10.html#sec_stm-merging
10:31:26 <phadej> and when stuff is written from "TQueue (Key, Payload)" to TQueue Payload for that key
10:32:52 <phadej> because if it's removed too early, some other worker could pick the same queue with other worker still working on that same Key
10:32:57 <phadej> is that a problem? not described.
10:33:39 <tchakka> If a message comes in then I imagine the following in a single transaction: read the map for the key, if Nothing: new queue, insert to it, return Just queue; if Just: write to queue, return Nothing. If transaction returned Just queue, launch worker for that queue.
10:34:20 <tchakka> The idea is that each queue only has a single worker. Creation of queue implies creation of worker. Hopefully, because concurrency occasionally breaks my brain <_< >_>
10:34:47 <phadej> than worker would remove the queue from map immediately, if messages come too slowly
10:35:23 <tchakka> It will at least have one message, namely the message that caused the queue to be created in the first place.
10:35:58 <tchakka> Then if nothing writes to that Key during the processing of that message, that's fine!
10:36:09 <tchakka> Right now we have pile-up because *everything* is sequential.
10:37:33 <phadej> ok. The important bit here wasthat workers don't switch keys, they just die.
10:37:43 <phadej> i.e. you have "exactly one worker per key" invariant
10:37:54 <tchakka> Right, yeah. That's a thing, oops.
10:38:26 <tchakka> I figured that forkIO/async is cheap, so we might as well slaughter worker threads as we go.
10:39:37 <tabaqui> I'm trying to add preprocessor for the Thrift DSL, but custom setup doesn't see my "*.thrift" files. Right now I have such code:
10:39:41 <tabaqui> defaultMainWithHooks $ addThriftPP simpleUserHooks
10:39:46 <tabaqui> addThriftPP uh = uh { hookedPreProcessors = thriftPP:hookedPreProcessors uh }
10:39:49 <tabaqui> but "stack install" returns error "setup: can't find source for Common_types in src, thrift
10:40:29 <tabaqui> It's weird, simpleUserHooks has an empty hookedPreProcessors list, but hsc works well still
10:43:51 <lihram> Hopefully someone here can help me with this. I'm using a function which evaluates a list of tuples and returns a boolean if there are no duplicates. https://gist.github.com/LiHRaM/65eb461b0f2b9d07af66b2958c6a06d6 It relies on two classes, HashMap and Hashable, and I thought I was defining the types correctly, but it returns an error regardless. Anyone got an idea why?
10:45:01 <geekosaur> lihram, the fact that it includes a version on the constraint makes me suspicious that you have multiple versions of Data.Hashable in use
10:45:56 <tabaqui> probably, your hashable and unordered-containers are incompatible to each other
10:46:03 <lihram> geekosaur: Right? But the only other reference to Hashable in my code is by reference to the library
10:46:22 <tabaqui> HashMap requires proper Hashable instance
10:46:35 <geekosaur> what tabaqui said, basically
10:47:01 <geekosaur> if your unordered-containers (whiich has Data.HashMap) uses a different version of the hashable package, you need to use that specific version
10:47:05 <lihram> tabaqui: Could you elaborate on *proper instance*?
10:47:22 <tabaqui> which package tool do you use? Cabal, Stack?
10:47:23 <lihram> Right, so reference the correct version
10:47:56 <lihram> I used stack to set the project up, but am running the repl with just ghci
10:48:58 <geekosaur> stack ghci, or stack exec ghci
10:49:24 <geekosaur> stack keeps its own environmeent unrelated to whatever your system has installed
10:49:32 <geekosaur> different ghc, different packages, etc.
10:49:44 <lihram> Right, so this is where that sort of behavior becomes important
10:50:30 <lihram> Using stack ghci I get a missing module error, which I guess is good news :P
10:51:08 <tabaqui> I think, that using pure system ghc is bad idea
10:51:38 <tabaqui> probably, wrap all development in stack would be better
10:51:57 <lihram> just like python's virtual envs etc
10:52:33 <tabaqui> not really, you can use ".stack/global/stack.yaml" to manage system-wide packages
10:52:51 <tabaqui> at least they will not interfere with you dev environment
10:53:06 <tabaqui> or will, if it is sane
10:56:18 <lihram> tabaqui Wait, so there's a stack.yaml file in each project which manages system-wide packages? Do you mean how the project interacts with them?
10:56:44 <tabaqui> sorry, I meant "$HOME/.stack/global/stack.yaml"
10:57:02 <tabaqui> it is parsed when you run "stack install xmonad" outside of any project
10:57:43 <lihram> So stack install <packagename> adds packages to the local project (if it is found) and globally otherwise?
10:57:49 <tabaqui> and if you use the same resolver for global stack.yaml and for your project
10:57:58 <tabaqui> then stack can reuse system packages for the project
10:58:17 <tabaqui> lihram: somewhat
11:08:40 <boxscape> so, `join (liftA2 (,))` is an elegant way of making a cartesian product of a list with itself.is there a nice way to make only elements where the first element is less or equal the second element? (without using filter - I only want to have to compute half of it)
11:09:44 <tabaqui> boxscape: comprehensions?
11:10:13 <tabaqui> % [(a, b) | a <- [1,2,3], b <- [1,2,3], a <= b]
11:10:13 <yahb> tabaqui: [(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)]
11:11:07 <boxscape> ah, I think comprehensions is a good idea, but more something like let xs = [1..5] in [ (y, x) | x <- xs, y <- [head xs..x] ]
11:11:15 <boxscape> otherwise I'm still computing and comparing every pair
11:11:37 <tabaqui> only if your list is already sorted
11:11:53 <boxscape> ah, yes, I should have mentioned that, I suppose - I'm constructing it from a range
11:12:03 <int-e> > let xs = [1..5] in [(x, y) | ys@(x:_) <- tails xs, y <- ys]
11:12:07 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(2,2),(2,3),(2,4),(2,5),(3,3),(3,4),(3,5),(4,...
11:12:12 <boxscape> nice
11:13:14 <int-e> (doesn't work for infinite lists)
11:13:28 <boxscape> that's acceptable
11:13:31 <tabaqui> and required MonadFail instance for pattern matching
11:13:57 <int-e> tabaqui: I'm assuming list comprehensions here...
11:14:05 <int-e> tabaqui: so that's not an issue
11:14:23 <tabaqui> yeah, I'm not sure about monadfail desugariting in ghc-8.2
11:14:49 <tabaqui> btw, there is an extension extending LC for an arbitrary Monad
11:15:01 <tabaqui> *desugarating
11:15:23 <boxscape> just asked about that yesterday, actually
11:15:28 <boxscape> -XMonadComprehensions
11:15:35 <int-e> tabaqui: that code will be fine for ghc-6 to ghc-8 at least. (And I knew about the extension; I tried to express that I was assuming that you were not using that extension)
11:27:37 <lavalike> > ((join .) $ join $ liftA2 (\x y -> bool mempty (pure (x,y)) (x<y))) [1..5::Int]
11:27:40 <lambdabot>  [(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)]
11:27:46 <boxscape> oh neat
11:27:48 <boxscape> I was about to post
11:27:49 <boxscape> > filter (not . null) (tails [1..5]) >>= \ys@(x:_) -> ys >>= \y -> pure (x, y) -- here's a non LC version without MonadFail or partial functions, though it's much longer
11:27:52 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(2,2),(2,3),(2,4),(2,5),(3,3),(3,4),(3,5),(4,...
11:28:13 <boxscape> ah yours doesn't contain the (x,x) elements
11:28:21 <boxscape> but that's easy to change
11:28:39 <lavalike> not in love with it just playing around (:
11:31:46 <lavalike> > mconcat . join (liftA2 (\x y -> bool mempty (pure (x,y)) (x<=y))) $ [1..4] :: [(Int,Int)]
11:31:49 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(2,2),(2,3),(2,4),(3,3),(3,4),(4,4)]
11:32:47 <lavalike> :t mconcat . join (liftA2 (\x y -> bool mempty (pure (x,y)) (x<=y)))
11:32:49 <lambdabot> (Monoid (f (a, a)), Applicative f, Ord a) => [a] -> f (a, a)
11:32:53 <lavalike> not too bad
11:33:50 <boxscape> is there some version of init that returns the empty list if given the empty list?
11:34:21 <boxscape> I suppose there is in the safe package
11:39:53 <boxscape> > init (tails [1..5]) >>= \ys@(x:_) -> ys >>= pure . (x,)
11:39:55 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(2,2),(2,3),(2,4),(2,5),(3,3),(3,4),(3,5),(4,...
11:47:45 <nil> > [1..5] >>= \x -> fmap (x,) [x..5]
11:47:48 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(2,2),(2,3),(2,4),(2,5),(3,3),(3,4),(3,5),(4,...
11:47:59 <boxscape> oh, that's nice
12:05:06 <wildtrees> does trace from debug trace, not always fire from a first run of freshly loaded code in ghci? 
12:11:58 <c_wraith> wildtrees: I've never observed that. it's more likely that either the trace isn't getting evaluated or (sometimes this is a real issue) is getting buried in all the other ghci output 
12:14:40 <nil> boxscape: it might be written more naturally as   do x <- [1..5]; y <- [x..5]; return (x, y)   , by the way
12:15:17 <boxscape> ah, yeah
12:15:28 <nil> or, equivalently,   [(x, y) | x <- [1..5], y <- [x..5]]
12:22:13 <magneticduck> is there a way to give type signatures to sub-expressions that depend on a type variable in the signature for an outer expression? for example, I would like to write "x :: a; x = f undefined where f :: a -> a; f = id"
12:22:47 <boxscape> sounds like a job for -XScopedTypeVariables?
12:23:38 <boxscape> though...
12:23:40 <boxscape> I'm not entirely sure
12:24:52 <dmwit> > [(x,y) | x:ys <- tails [1..5], y <- ys]
12:24:54 <lambdabot>  [(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)]
12:25:11 <dmwit> ^ this way isn't specific to the [x..y] way of generating a list, it works for any list
12:25:54 <dmwit> Oh, int-e already posted it.
12:26:06 <dmwit> It can be made to work for infinite lists using the universe package if you need that.
12:26:59 <dmwit> diagonal [map ((,) x) ys | x:ys <- tails [1..5]]
12:27:26 <boxscape> magneticduck I think it should work with ScopedTypeVariables if you introduce a in as "x :: forall a. a"
12:37:10 <ysangkok> i fixed all gmane links on the haskell wiki
12:41:20 <wildtrees> c_wraith, not getting evaluated was what was going on! though some of it was, so the lazy evaluation sometimes evaluates things partially? 
12:41:47 <dmwit> ysangkok: Nice!
12:42:02 <c_wraith> things are only evaluated as much as necessary. 
12:42:19 <c_wraith> where "necessary" can take a while to understand 
12:42:41 <dmwit> wildtrees: Yes, lazy evaluation sometimes only evaluates things partially. (This is truly fundamental to the design and use of Haskell.)
12:42:56 <int-e> > let xs = [1..] in [(x,y) | ys@(x:_) <- scanl (flip (:)) [] xs, y <- ys] -- infinite list support
12:43:00 <lambdabot>  [(1,1),(2,2),(2,1),(3,3),(3,2),(3,1),(4,4),(4,3),(4,2),(4,1),(5,5),(5,4),(5,...
12:43:40 <wildtrees> I tended to think it was more all or nothing evaluation , but I have used infinite data structures, so I guess I have a small hole in my thinking! 
13:31:34 <ysangkok> seems like ghc is not finding native libraries in /usr/local/lib, how can i enable that?
13:34:23 <Lycurgus> set a path prolly
13:35:40 <turab> Hello. I was going through a simple servant tutorial and came across the following line which I don't quite understand:
13:35:42 <turab> getUsers :<|> getUser :<|> getPackages = client hackageAPI (BaseUrl Http "hackage.haskell.org" 80)
13:35:59 <ysangkok> Lycurgus: yes, but how? it is weird that gcc can find it but ghc can't 
13:35:59 <turab> This shows up at the very end of the following tutorial: https://www.servant.dev/client-in-5-minutes.html
13:36:13 <ysangkok> Lycurgus: i would think ghc would use the same search path as gcc for libraries
13:36:31 <lavalike> turab: it's like [a,b,c] = someListProducingFunction
13:36:47 <turab> Ahh I see
13:41:14 <ysangkok> aaah i figured it out, simply -L/usr/local/lib for ghc fixes it
13:47:46 <cohn> hi, what's the correct way to handle MonadFail in a do block?
13:53:00 <EvanR> :t fail
13:53:03 <lambdabot> Monad m => String -> m a
13:53:23 <ysangkok> is that the old type? i thought fail wasn't in Monad anymore
13:53:54 <EvanR> MonadFail m => String m a
13:54:35 <lavalike> :t Control.Monad.Fail.fail
13:54:38 <lambdabot> Control.Monad.Fail.MonadFail m => String -> m a
13:56:13 <EvanR> so two classes have the same method ...
13:56:34 <cohn> thanks!  :D
13:57:01 <EvanR> i guess you have to import hiding?
13:57:02 <lavalike> it comes with a comment "As part of the MonadFail proposal (MFP), this function is moved to its own class 'MonadFail' (see "Control.Monad.Fail" for more details). The definition here will be removed in a future release."
13:57:42 <jumper149> How long does MonadFail exist?
13:58:20 <afontain[m]> having `fail` inside Monad seems to be often considered as an « error born from `do` notation »
13:58:43 <afontain[m]> because it means any Monad can fail unexpectedly, and the ones who cannot fail in se sensible way just call `error`
13:58:55 <afontain[m]> * in a sensible way
13:59:28 * hackage git-brunch 1.0.0.0 -   https://hackage.haskell.org/package/git-brunch-1.0.0.0 (andys8)
14:00:44 <afontain[m]> It's much better to require a `MonadFail m =>`, so it doesn't compile if the monad cannot fail in a sensible way instead of failling at runtime
14:01:27 * hackage git-brunch 1.0.1.0 -   https://hackage.haskell.org/package/git-brunch-1.0.1.0 (andys8)
14:02:06 <crestfallen> https://paste.ee/p/8cUKv    hello I got this error while trying to install lambdabot on a osX. ' $ lambdabot ' does not invoke the program
14:02:37 <something> Anybody else getting timeout errors using "stack new"?
14:03:43 <crestfallen> I used a deprecated command but it began to load ok
14:04:06 <something> its getting a "RedownloadInvalidResponse Request" when downloading the lts-14.1 build plan
14:05:20 <something> https://raw.githubusercontent.com/fpco/lts-haskell/master/lts-14.1.yaml, looks like that doesn't exist
14:05:54 <something> err, without the comma
14:08:33 <crestfallen> more generally, should I use lambdabot or ghci .. I don't have a grip on the distinctions yet
14:09:42 <EvanR> somehow I don't expect lambdabot to always be around, so better prepare for the inevitable and learn GHCI
14:09:57 <EvanR> lambdabot is getting pretty old
14:10:38 <crestfallen> thanks, yeah focus on one in any case? it's bloody complicated. I think it loaded but how do you invoke it EvanR ?
14:11:08 <EvanR> eh?
14:11:15 <EvanR> $> ghci
14:11:27 <crestfallen> no I mean lambdabot
14:11:39 <crestfallen> if it did indeed install
14:11:49 <crestfallen> fully
14:12:00 <EvanR> oh, a local lambdabot? That does seem complicated and not fully documented
14:12:06 <crestfallen> from the cli I mean
14:12:18 <crestfallen> really? ok I'm junking it.
14:13:15 <crestfallen> EvanR: thanks for responding . if I could show you something here in lambdabot ...
14:13:30 <MarcelineVQ> Things that end with "ExitFailure 1" did not install
14:13:47 <crestfallen> thanks MarcelineVQ ! good to know
14:14:52 <crestfallen> thing is, will the irc lambdabot have say Data.Typeable and Debug.Trace installed, or can I/we install that?
14:16:00 <MarcelineVQ> will the lambdabot in this room let you install things? no
14:16:32 <MarcelineVQ> But in addition there's plenty of things your ghci has lambdabot doesn't because lambdabot only imports certain safe things
14:16:38 <EvanR> lambdabot is a curmudgeon. but theres another bot in here
14:16:49 <MarcelineVQ> there is, but ghci is pretttty great
14:17:05 <EvanR> % 2 + 2
14:17:06 <yahb> EvanR: 4
14:17:31 <EvanR> yahb is the T-1000 to lambdabots regular terminator
14:17:35 <MarcelineVQ> And the ghci on your computer should be the first thing you learn to use when learning haskell, because it'll always be there
14:17:38 <crestfallen> reason is, I learned of the typeOf function and have some questions about it and showTrace. I think these tools would be indispensable for me
14:17:42 <crestfallen> EvanR:  !!
14:18:14 <EvanR> ghci easily lets you try typeOf and stuff to your hearts content
14:18:32 <crestfallen> @let x = traceShow (typeOf x) $ pure 123 in x
14:18:32 <lambdabot>  Parse failed: Parse error: in
14:18:37 <crestfallen> ok
14:19:11 <crestfallen> why a Parse error?
14:19:29 <crestfallen> wouldn't it catch the non-existence of the functions first?
14:19:55 <EvanR> i would not think so
14:20:17 <EvanR> if it can't parse, might as well not try to figure out what is even a name, much less function name
14:20:18 <crestfallen> generally you can't do a let .. in statement here?
14:20:48 <EvanR> this is not ghci-valid, but 
14:20:55 <MarcelineVQ> ​@let is a command, it's not let ... in ...
14:20:55 <EvanR> @let x = traceShow (typeOf x) $ pure 123
14:20:57 <lambdabot>  .L.hs:161:23: error:
14:20:57 <lambdabot>      Ambiguous occurrence ‘x’
14:20:57 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.x’,
14:21:19 <EvanR> also did you mean to write a recursively defined dynamic type
14:21:35 <MarcelineVQ> you can use let ... in ... anywhere an expression is valid but @let isn't the way
14:21:46 <EvanR> actually this makes no sense, you are hereby assigned to 9 minutes of learning haskell
14:21:52 <EvanR> begone
14:22:04 <MarcelineVQ> In my little opinion asAppliedTo is more useful than typeOf or trace for understanding what is going on.
14:22:11 <MarcelineVQ> % asAppliedTo :: (a -> b) -> a -> a -> b; asAppliedTo = const
14:22:12 <yahb> MarcelineVQ: 
14:22:19 <MarcelineVQ> :t map `asAppliedTo` (+1)
14:22:22 <lambdabot> Num b => (b -> b) -> [b] -> [b]
14:22:26 <crestfallen> why it works beautifully in ghci EvanR ?
14:22:34 <MarcelineVQ> woops, mixed bots, oh well
14:22:40 <EvanR> :t map (+1)
14:22:42 <lambdabot> Num b => [b] -> [b]
14:22:47 <EvanR> hmm yeah
14:23:18 <crestfallen> are you begoning me ?   :)
14:23:38 <EvanR> :t map `asAppliedTo` (+1) `asAppliedTo` [5 :: Int]
14:23:40 <lambdabot> error:
14:23:40 <lambdabot>     • Couldn't match expected type ‘b -> b’ with actual type ‘[Int]’
14:23:40 <lambdabot>     • In the second argument of ‘asAppliedTo’, namely ‘[5 :: Int]’
14:24:11 <EvanR> heh, 5 `asAppliedTo` wont work :(
14:25:57 <MarcelineVQ> 5 asAppliedTo?
14:27:01 <crestfallen> so with traceShow and typeOf    ,    how would I apply those to sequenceA here ?   https://paste.ee/p/OAPiQ
14:27:30 <crestfallen> I never know how to place traceShow precisely. it seems to be different in every case
14:28:05 <crestfallen> so that I could get similar results to      let x = traceShow (typeOf x) $ pure 123 in x
14:28:34 <crestfallen> with the cherished evaluation steps
14:28:35 <EvanR> how does that even
14:30:23 <turab> Has anyone here used telegram-api?
14:30:24 <MarcelineVQ> EvanR: you had your coffee?
14:30:40 <EvanR> yeah
14:31:58 * hackage polysemy 1.1.0.0 - Higher-order, low-boilerplate, zero-cost free monads.  https://hackage.haskell.org/package/polysemy-1.1.0.0 (isovector)
14:32:57 <crestfallen> am I still begoned? I'd like to master those tools because I can't learn anything without knowing the evaluation steps
14:33:59 <EvanR> typeOf and traceShow involve typeclasses, so evaluation depends on results of type checking
14:34:15 <EvanR> so before you learn evaluation steps you have to learn type checking steps
14:35:13 <EvanR> luckily in haskell you can learn typechecking without knowing evaluation, unlike idris
14:37:08 <crestfallen> EvanR: I'm familiar with evaluation steps particularly with recursion but the recursion of applicatives is weird
14:37:38 <crestfallen> can I not use trace and typeOf there?
14:42:18 <EvanR> where are you stuck
14:46:51 <dmwit> (Why `let x = ... in x` instead of just `...`?)
14:47:22 <dmwit> Oh... because `...` mentions `x`. Gross.
14:47:42 <dmwit> Why not just do `:t pure 123`?
14:48:42 <dmwit> (Perhaps to see which instance was chosen...?)
14:48:46 <mwelt> hey there! Maybe some might shed some light onto my profiling with stack issue
14:49:38 <mwelt> stack build --profile && stack exec -- my-exe +RTS -p is quited with "program needs to be compiled with -prof option"
14:50:39 <mwelt> as far as I understood --profile implies --ghc-options=-prof (which is discouraged by stack) 
14:50:59 <dmwit> I suspect you will need stack exec -- my-exe --RTS +RTS -p
14:51:11 <dmwit> So that the RTS options are passed to my-exe instead of stack.
14:51:42 <mwelt> -p is recognized, otherwise the runtime wont complain about "missing -prof compile option", would it?
14:52:02 <dmwit> I don't know. But it's irrelevant.
14:53:09 <MarcelineVQ> dmwit: the -- should be enough
14:53:15 <dmwit> No, it should not.
14:53:21 <mwelt> ok the --RTS seems to work. I was under the impression stack exec -- <-- everything behind that would be interpreted as belonging to executable
14:53:34 <dmwit> Your impression was incorrect.
14:53:49 <crestfallen>    :t   doesn't give the nice  readout of the evaluation steps. I need to sink my teeth into whatever seems good for now :)
14:53:51 <dmwit> The RTS gets first claim on the arguments.
14:54:00 <mwelt> at least that's what i found on the internets :)
14:54:06 <dmwit> It sees (and erases) RTS options before passing them on to the underlying executable.
14:54:06 <MarcelineVQ> hmm odd, then I'm experiencing a different issue when trying to reproduce this
14:54:41 <sicklorkin> Can anyone explain what the difference between explicitforall and scopedtypevariables is?
14:54:56 <dmwit> If the full argument parsing, including RTS-options-parsing, was under stack's control, then it would be possible for -- to do what you say. But that is not how it works.
14:55:16 <crestfallen> dmwit  gross and ... what was it? blech the other day :)
14:55:23 <dmwit> sicklorkin: Sure, explicitforall lets you write explicit foralls, but doesn't bring the variables introduced by those foralls into scope in the body of the definition.
14:55:52 <sicklorkin> dmwit: okay.. 
14:55:55 <dmwit> crestfallen: I... actually think this is a completely reasonable technical decision to make.
14:56:16 <dmwit> It would be too easy for program writers to forget to do the right thing otherwise.
14:56:30 <crestfallen> not following sorry
14:56:38 <MarcelineVQ> dmwit: he's asking about the words gross and blech
14:56:51 <crestfallen> Ha!
14:57:18 <crestfallen> no about why I can't use trace to get the output of any program using recursion or not
14:58:34 <MarcelineVQ> mwelt: for me just now stack exec wasn't finding the executable when built with --profile, but did find it when built without --profile, meaning exec was loading the non-profile exe when it existed. stack build --profile --exec the-exe found the right one, so if you get more weirndess then it could be related to that
14:58:41 <dmwit> Anyway, "everything behind -- goes to the executable" is a good first approximation, because most people forget that RTS options are a thing when writing that kind of summary. But for these purposes, "everything" does not include RTS options.
15:00:07 <dmwit> MarcelineVQ: (That sounds plausible to me. I'm not a stack expert. But you will definitely still need --RTS if you actually want to pass RTS options to the-exe rather than just running it plain.)
15:00:23 <mwelt> MarcelineVQ: Thx for this suggestion. Currently it seems to run correctly, as I can see the propagated RTS parameter to the executable in htop :)
15:01:53 <dmwit> sicklorkin: It might be more helpful to give an example?
15:02:18 <dmwit> sicklorkin: Take `dmwitID :: forall a. a -> a; dmwitID x = (x :: a)`.
15:02:45 <dmwit> sicklorkin: With ScopedTypeVariables, this works fine: the `a` type ascription in the body of `dmwitID` refers to the same type as the `a` bound in the type signature of `dmwitID`.
15:03:09 <mwelt> dmwit: thx for your exploration :)
15:03:18 <dmwit> sicklorkin: With ExplicitForalls but not ScopedTypeVariables, this is a type error: the `a` in the body of `dmwitID` is fresh, and the compiler complains that it can't verify that it is equal to the `a` in the type signature.
15:03:28 <mwelt> err. elaboration -.-
15:03:56 <dmwit> mwelt: cheers =)
15:04:22 <sicklorkin> dmwit: thanks.. 
15:04:31 <sicklorkin> dmwit: i'll get you an example just a sec.
15:04:56 <dmwit> I suspect ExplicitForalls exists not as a useful extension of its own, but as a dependency target so that RankNTypes and ScopedTypeVariables can share code somehow.
15:05:14 <sicklorkin> dmwit: this does seem to be the case
15:05:29 <crestfallen> please at least comment: is my query invalid or irrelavent? I don't understand whether its worth knowing how to do a trace where a program is vaguely understood
15:07:55 <MarcelineVQ> crestfallen: I don't think it's invalid or irrelivant. maybe you missed this "<crestfallen> can I not use trace and typeOf there?" "<EvanR> where are you stuck"
15:07:55 <sicklorkin> dmwit: So my example isn't any different from yours. I was adding some types to a rather long where clause and I got a type error. I saw LANG.. ExtensionForAll and wasn't sure what it was doing and why suddenly it failed to compile..
15:08:31 <sicklorkin> dmwit: since I was adding a type to the were close I thought I was doing what ScropedTypeVariables was doing
15:08:39 <sicklorkin> s/close/clause
15:09:38 <dmwit> Oh. If the error for putting `forall` in suggests turning on ExplicitForalls, that seems like a UX bug. It should definitely suggest RankNTypes or ScopedTypeVariables instead.
15:10:07 <dmwit> (Depending on whether the forall appears at a rank-1 position or not.)
15:10:21 <sicklorkin> no no, someone added ExplicitForAll, this is old code
15:10:38 <sicklorkin> if I remove forall it suggests ScopredType
15:11:10 <crestfallen> I was asking about the use of traceShow and typeOf 
15:11:30 <crestfallen> on a particular program
15:12:31 <MarcelineVQ> yes, that part isn't unclear to anyone, EvanR was essentially asking what have you tried
15:12:52 <turab> In cabal config, assume for package foo, version 0.7 exists. Then, does it matter if a package depends on foo ^>=0.5 and foo ^>=0.6? 
15:13:24 <MarcelineVQ> "where are you stuck" can be read as "how far did you get when you tried, show it to me"
15:13:27 <turab> I am trying to understand if the ^ operator works the way I expect it to
15:22:28 * hackage git-brunch 1.0.2.0 -   https://hackage.haskell.org/package/git-brunch-1.0.2.0 (andys8)
15:28:31 <turab> *foo ^>=0.5 or foo ^>=0.6
15:29:24 <hexagoxel> given that the cabal userguide first explain the semantic difference between ^>= and >= + <, only to then end the section with the postulation that the two are "equivalent", I feel unable to give any advice on this matter.
15:30:13 <turab> Okay, I am struggling to find what exactly ^ means which is why I asked.
15:30:29 <turab> Thanks for replying hexagoxel 
15:30:56 <hexagoxel> I think that both ^>=0.5  and  ^>=0.6  reject 0.7
15:32:16 <hexagoxel> I advice against the operators until the devs bother to specify the semantics consistently, of course.
15:32:26 <hexagoxel> *the operator
15:33:27 <turab> Understood
15:36:08 <freeman42x> I don't understand this lorry (https://github.com/target/lorri) setup instructions: On NixOS, we have a simple service for installing and enabling the needed direnv version at ./direnv/nixos.nix. Download this file and add imports = [ ./direnv.nix ]; to your system's configuration.nix.
15:36:15 <freeman42x> what should I do with that nix file?
15:37:39 <sicklorkin> freeman42x:  -> #nix
15:38:04 <freeman42x> sicklorkin, right, sorry
15:38:28 * hexagoxel .oO "Cannot join #nix (Channel is invite only)"
15:38:36 <hexagoxel> (there is #nixos however)
15:55:44 <Guest_79> Hey- can someone help me with a Haskell install?
15:55:57 <Guest_79> totally new to this, and keep getting this: "-bash: cabal: command not found"
15:56:15 <sarahzrf> Guest_79: how did you install it?
15:58:23 <Guest_79> I've been following instructions on this website (https://tidalcycles.org/index.php/MacOS_installation) to install Tidalcycles, and I just used the text given on Haskell's website...
15:58:48 <Guest_79> (curl https://get-ghcup.haskell.org -sSf | sh)
15:59:51 <Guest_79> oh... i guess I should try installing Haskell Tool Stack first before I start asking questions...
16:00:57 <sarahzrf> heh
16:01:10 <sarahzrf> does anybody know the history/etymology behind the name 'Prelude'
16:01:18 <sarahzrf> what does it mean, & where does it come from
16:02:20 <Guest_79> mid 16th century: from French prélude, from medieval Latin praeludium, from Latin praeludere ‘play beforehand’, from prae ‘before’ + ludere ‘to play’.
16:06:25 <sm[m]> hi Guest_79 .. where did you find that instruction on Haskell's website ?
16:17:33 <dmwit> turab, hexagoxel: The difference between the two is that there is a flag that relaxes only ^>= constraints (but not >= + < constraints).
16:19:44 <dmwit> https://cabal.readthedocs.io/en/latest/nix-local-build.html#cfg-field-allow-newer
16:20:43 <dmwit> --allow-newer ^all
16:32:10 <hexagoxel> of course  ^>=0.1 || >=0.5 && <0.6.2  together with  --allow-newer ^all  will happily accept 0.6.2
16:32:15 <hexagoxel> which may or may not be surprising
16:35:48 <hexagoxel> and which may or may not suggest that a ^>= should only be used on the highest version (if you have multiple constraints with ||)
16:36:33 <hexagoxel> and you should get warnings otherwise
16:41:12 * hexagoxel repeats that all of this should be properly documented and thought through before such a feature is introduced
16:41:35 * hexagoxel could keep on rambling in this direction, but knows that its not very constructive and walks away..
17:12:50 <jle`> hm, i wonder what is holding up the new stackage nightlies
17:12:54 <jle`> ah, maybe cabal 3.0
17:18:34 <Guest_26> Hi all, I asked this question about an hour ago, but was kicked off my network, so sorry to anyone who was trying to help me then... I am having problems with an installation, and I am completely unfamiliar with Haskell...
17:18:38 <Guest_26> Basically, i keep getting a "-bash: cabal: command not found" error when i try and run cabal functions like "cabal update" or similar...
17:18:40 <Guest_26> I tried to install Haskell according to the instructions on their website using "curl https://get-ghcup.haskell.org -sSf | sh" and then Haskell Stack with "curl -sSL https://get.haskellstack.org/ | sh", and when I then try to run the cabal update I get the "-bash: cabal: command not found" error... am I doing something completely idiotically wrong 
17:18:41 <Guest_26> here?
17:18:50 <Guest_26> Many thanks in advance for anyone's help
17:19:16 <jle`> maybe make sure that either of those scripts install cabal to a place that is in your $PATH?
17:19:20 <aplainzetakind> I'm trying out Network.HTTP.Simple, but I can't figure out why `defaultRequest { host = "google.com" }` is telling me why `host` is not in scope.
17:19:41 <Guest_26> How do I do that?
17:20:08 <jle`> Guest_26: check where those scripts install cabal
17:20:12 <jle`> and then see if that is in your $PATH :)
17:20:26 <jle`> if not, modify your $PATH to include it
17:20:53 <aplainzetakind> Guest_26: most likely places are ~/.cabal/bin and ~/.ghcup/bin
17:21:31 <Guest_26> sorry... what is the $PATH?
17:22:22 <Guest_26> okay, so it's in .ghcup/bin
17:22:38 <Guest_26> so, what do I do to make sure it's in my $PATH?
17:22:48 <jle`> is it listed when you type `echo $PATH` ?
17:23:25 <Guest_26> -bash: /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin: No such file or directory
17:23:28 <Guest_26> I guess not
17:23:42 <jle`> the answer depends on your os/how things are configured, so maybe the best way to move from here is to search for something like 'how to add directory to PATH' on a search engine and find the answer that works for your setup
17:23:54 <Guest_26> fair enough
17:24:16 <Guest_26> Thanks for pointing me in the right direction
17:25:02 <sm[m]> hi Guest_26 . https://github.com/tidalcycles/Tidal/issues/526 may be a good place to get more specific help/contribute bug reports from/to the author
17:27:58 * hackage Map 0.0.1.0 - Class of key-value maps  https://hackage.haskell.org/package/Map-0.0.1.0 (MatthewFarkasDyck)
17:28:47 <sm[m]> also, the installation troubleshooting doc mentions that you can also install with stack. On my system, "stack install tidal" seems to be willing to install tidal-1.3.0
17:30:37 <Guest_26> thank you- this is helpful. A backup in case my adding to the path doesn't work...
17:31:01 <Guest_26> i've installed tidal on two different computers before, and each time, i seemed to have to go through different steps...
17:31:01 <freeman42x> are there any example haskell library packages? kind like a library hello world
17:36:38 <sm[m]> freeman42x: "stack new simple-library" will make one
17:36:43 <dmwit> freeman42x: http://hackage.haskell.org/package/hello
17:36:50 <sm[m]> ack
17:37:11 <freeman42x> dmwit, seen that, looking for a lib not executable
17:37:19 <freeman42x> sm[m], I'm not using stack, using Nix
17:38:29 <dmwit> A library isn't really that different. You just write `library` instead of `executable hello`, and drop the `main-is`.
17:39:03 <dmwit> (...in the .cabal file)
17:39:29 <dmwit> You can also just `cabal init` to create a skeleton for you.
17:43:20 <freeman42x> dmwit, I know. Ended up using ACME package, cause it's funny xD
17:52:28 * hackage barbly 0.1.0.0 - Create status bar menus for macOS from executables  https://hackage.haskell.org/package/barbly-0.1.0.0 (lukec)
17:55:27 * hackage Map 0.0.1.1 - Class of key-value maps  https://hackage.haskell.org/package/Map-0.0.1.1 (MatthewFarkasDyck)
18:09:48 <jusss> dminuoso: hi
18:16:37 <freeman42x> anything else I need to do to access a package in cabal new-repl besides adding it to build depends? https://i.imgur.com/wvYYVyI.png
18:18:27 * hackage wu-wei 0.1.0.2 - Unimportant Unix adminstration tool  https://hackage.haskell.org/package/wu-wei-0.1.0.2 (fuzz)
18:24:53 <alx741> freeman42x: did you restart `cabal new-repl` after adding that dependency in the cabal file?
18:25:03 <freeman42x> alx741, I did
18:26:19 <freeman42x> and I can't import Control.Lens.Combinators
18:29:03 <alx741> how about killing the repl, running `cabal new-build` and then staring the repl again?
18:30:57 <freeman42x> alx741, the solution was to use: cabal new-repl exe:example --flags="build-examples"
18:37:46 <jusss> base on >>=:: m a -> (a -> m b) -> m b, let's assume f :: m a, g :: a-> m b, and x :: m, so we can get >>= f g x == b == g ( f x ) x,   is there anything wrong here?
18:38:31 <c_wraith> juss: x :: m appears to be a kind error. 
18:38:48 <Axman6> the x :: m doesn't seem to make sense
18:40:42 <dmwit> jusss: `m a` does not mean "a function from `m` to `a`".
18:41:08 <dmwit> It means that `m` is going to be instantiated with a parameterized type, and `a` is going to play the role of that parameter.
18:41:34 <Axman6> m could be Maybe, or IO (not this is not Maybe a or IO a)
18:41:41 <dmwit> For example, one might choose `m` to be `[]` and `a` to be `Int`, so that `m a` means `[Int]`.
18:42:06 <dmwit> Or one might choose `m` to be `Maybe` and `a` to be `CrazyType`, so that `m a` means `Maybe CrazyType`.
18:46:01 <tydeu> Why does the type `((':) a b)` give the error  "Operator applied to too few arguments: :"?
18:48:33 <dmwit> % Proxy @((':) Int [Int])
18:48:33 <yahb> dmwit: ; <interactive>:37:10: error: Operator applied to too few arguments: :
18:48:37 <c_wraith> tydeu: sections aren't supported at the type level. 
18:48:47 <dmwit> heh
18:48:48 <c_wraith> they're a form of lambda, after all. 
18:49:04 <tydeu> c_wraith: it works with (->) and (~)
18:49:11 <dmwit> But prefix-form shouldn't run into any of the problems that make us want to avoid lambdas.
18:49:29 <Axman6> % Proxy @(Int ': [Int])
18:49:29 <yahb> Axman6: ; <interactive>:39:16: error:; * Expected kind `[*]', but `[Int]' has kind `*'; * In the second argument of `(:)', namely `[Int]'; In the type `(Int : [Int])'; In the expression: Proxy @(Int : [Int])
18:49:43 <Axman6> % Proxy @(Int ': '[Int])
18:49:43 <yahb> Axman6: Proxy
18:49:44 <Lears> % :k '(:)
18:49:44 <yahb> Lears: '(:) :: a -> [a] -> [a]
18:50:02 <dmwit> tydeu: It's gotta be `(:)
18:50:06 <dmwit> '(:) I mean
18:50:11 <dmwit> Not (':).
18:50:21 <Axman6> :o I had no idea that's how you'd do that. crazy
18:50:22 <dmwit> '(:) is the prefix form, ': is the infix form.
18:50:43 <dmwit> % Proxy @(Int ': '[Int])
18:50:43 <yahb> dmwit: Proxy
18:50:56 <dmwit> % Proxy @('(:) Int '[Int])
18:50:56 <yahb> dmwit: Proxy
18:50:58 <Axman6> % Proxy @(Int ': [Int,Char])
18:50:58 <yahb> Axman6: Proxy
18:52:09 <dmwit> % Proxy @((:) Int [Int,Char])
18:52:09 <yahb> dmwit: Proxy
18:52:20 <dmwit> tydeu: Or skip the quote entirely. =P
18:52:54 <dmwit> There is no non-DataKind type constructor named :, so no ambiguity.
18:53:10 <tydeu> dmwit: cool, thanks for the help
19:05:47 <turab> I was reading through the seq wiki and they use the following example: f !x !y = z
19:06:34 <turab> Actually wait I should read the whole wiki first
19:08:29 <jusss> is that true we can get one function definition from its type signature?
19:11:14 <jusss> add x = x,  add x = x+1, add x = x+2, all have type add :: Int -> Int
19:11:24 <dramforever> jusss: Not completely (otherwise why write function definitions :P), but you can certainly learn some important stuff about the function
19:11:59 <jusss> dramforever: but we can get add x = x through its type add :: Int -> Int, right？
19:12:04 <jusss> at least
19:12:33 <dramforever> Oh sure, you can play 'type tetris' to get a function that fits the signature
19:13:42 <dramforever> Also the more polymorphic the type is, the more information you can get
19:13:49 <dramforever> :t id
19:13:50 <lambdabot> a -> a
19:14:38 <dramforever> From this you can get that id takes one argument, can't really do anything about it, and needs to return something of the same type
19:15:10 <dramforever> And you really don't expect someone who just wrote  id x = error "this function is useless lol"
19:15:14 <Cale> If you want to be a bit of a troll about it, id can take as many arguments as you like though :D
19:15:27 <Cale> > id id id id id id id 5
19:15:29 <dramforever> So it's most likely id x = x
19:15:30 <lambdabot>  5
19:15:33 <jusss> dramforever: can we think type as a parameter and function definition as results?
19:15:43 <jusss> oh no
19:15:57 <jusss> one type may have multiple functions
19:16:10 <dramforever> Type is like a shape
19:16:31 <dramforever> It describes how it fits into other stuff
19:16:36 <Cale> jusss: right, any one type will have many values in general.
19:17:04 <jusss> Cale: so that won't describe as  a function
19:17:32 <jusss> if we say functions are parameter and type is the result
19:17:51 <jusss> but that's pointless...
19:19:29 <turab> Okay, if I understand seq correctly, then are the following two equivalent:
19:19:34 <turab> do{ digits <- many1 baseDigit
19:19:35 <turab>             ; let n = foldl (\x d -> base*x + toInteger (digitToInt d)) 0 digits
19:19:37 <turab>             ; seq n (return n)
19:19:39 <turab>             }
19:19:51 <dramforever> jusss: Quite like when you put jigsaw pieces together, you fit the protruding bits into the slots
19:20:07 <dramforever> (I'm sure those have actual names but whatever)
19:20:17 <turab> vs: let n = foldl' (\x d -> ... )
19:20:28 <turab>       return n
19:21:44 <jusss> dramforever: a way to describe the relation between types and its functions?
19:22:14 <dramforever> Typing rules?
19:22:16 <jusss> :t (>>=)
19:22:18 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:22:49 <dramforever> And...?
19:23:13 <jusss> dramforever: is there that rules?
19:23:42 <dramforever> I'm not sure what you're talking about
19:23:49 <jusss> dramforever: Cale let's assume that m is Maybe, so >>= :: Maybe a -> (a -> Maybe b) -> Maybe b , and f :: Maybe a, g :: (a -> Maybe b) , so >>= f g = ?
19:23:58 <dramforever> 'a way to describe the relation between types and its functions?' <- what kind of 'way'?
19:23:59 <jusss> dramforever: don't mind,
19:24:27 <dramforever> (>>=) f g :: Maybe b
19:24:47 <jusss> dramforever: I mean function definition
19:24:55 <jusss> not type
19:25:37 <dramforever> ... Not quite sure what you're talking about
19:25:47 <Axman6> :t id `asAppledTo` id id id id id id
19:25:51 <lambdabot> error:
19:25:51 <lambdabot>     • Variable not in scope:
19:25:51 <lambdabot>         asAppledTo :: (a0 -> a0) -> (a1 -> a1) -> t
19:25:58 <Axman6> :t id `asAppliedTo` id id id id id id
19:26:00 <lambdabot> (a -> a) -> a -> a
19:26:20 <jusss> dramforever: we got the >>='s type, can we get its function definition base on its type?
19:26:39 <jusss> at least one function fit that type
19:28:12 <Axman6> @djinn a -> b -> a
19:28:12 <lambdabot> f a _ = a
19:28:48 <Axman6> for some types, you can get the definition from the type, but not always, if that's what you're asking
19:29:10 <Axman6> @djinn Maybe a -> (a -> Maybe b) -> Maybe b
19:29:10 <lambdabot> f a b =
19:29:10 <lambdabot>     case a of
19:29:10 <lambdabot>     Nothing -> Nothing
19:29:10 <lambdabot>     Just c -> b c
19:29:39 <jusss> Axman6: and 'bout >>=? can we get its function from its type?
19:31:36 <Axman6> No, for two reason, m can be any Monad, so there isn't one definition. And for some types there may be multiple possible definitions for that type
19:34:31 <jusss> Axman6: then make m as Maybe, can we get its function?
19:34:50 <Axman6> yes, I did it above
19:34:53 <Axman6> @djinn Maybe a -> (a -> Maybe b) -> Maybe b
19:34:53 <lambdabot> f a b =
19:34:53 <lambdabot>     case a of
19:34:53 <lambdabot>     Nothing -> Nothing
19:34:53 <lambdabot>     Just c -> b c
19:35:10 <jusss> Axman6: how you got that?
19:36:04 <Axman6> ... I just did it, you saw how I got that :P
19:36:30 <jusss> I mean how you got by hand, by something inference stuff
19:36:36 <Axman6> djinn is a tool which can do that
19:37:01 <jusss> Axman6: and if there's no djinn?
19:37:55 <dramforever> jusss: There's no mechanical way to do generate from types function definitions that make sense
19:37:58 <Axman6> I don't understand the question
19:38:10 <Axman6> well, there is, in some cases
19:38:16 <dramforever> (Unlike the other way around, generating types for functions)
19:38:36 <dramforever> okay, *general mechanical
19:39:16 <bifunctorial> it's equivalent-ish to automated theorem proving
19:40:01 <dramforever> I don't think there's a 'good' way other than trying to make sense of the type and writing a function based on that 'sense'
19:40:52 <dramforever> For example for '(>>=) Maybe a -> (a -> Maybe b) -> Maybe b', well you can just do '(>>=) f g = Nothing', but that's most likely not intended
19:40:58 <bifunctorial> in general your types don't carry enough information to pick the right thing
19:41:17 <bifunctorial> when the types do then you probably won't be able to pick anything automatically
19:41:30 <bifunctorial> except if you cheat and use undefined
19:41:50 <dramforever> djinn and exference have certain heuristics that try to generate 'good' definitions
19:42:00 <dramforever> exference: https://github.com/lspitzner/exference
19:42:42 <bifunctorial> it's probably more useful in an interactive setting where you ask it to generate small parts of the function you ask for
19:42:45 <bifunctorial> thats just my intuition though
19:43:19 <dramforever> Like type-directed autocompletion on steroids?
19:43:34 <bifunctorial> yeah
19:44:07 <bifunctorial> agda can do a little bit of it iirc
19:49:28 * hackage symbolic-link 0.1.1.1 - Symlink functions  https://hackage.haskell.org/package/symbolic-link-0.1.1.1 (fuzz)
19:50:17 <jusss> bifunctorial: dramforever ok, so it's impossible to get function definitions from its type...
19:50:39 <jusss> in a general way
19:52:50 <jusss> but when that m is e->,  and x :: e,  >>= f g x = g(f x) x , that's right?
19:53:21 <Axman6> jusss: As an exercise, what is the function for the type [a] -> [a]?
19:54:17 <jusss> Axman6: make x::a, f [x] = [x]
19:54:30 <jusss> it fits
19:54:43 <Axman6> but is it the only function?
19:54:57 <jusss> Axman6: of course not
19:55:49 <jusss> Axman6: but hey, at least it does have one, right?
19:56:01 <Axman6> sure
19:56:09 <Axman6> what about a -> b -> c?
19:56:12 <slack1256> I remember a wiki page discussing how to make ghc compilation times shorter and reducing memory aloccation. Does anyone have a link?
19:56:22 <bifunctorial> every type is inhabited in haskell though
19:56:48 <jusss> Axman6: I assume that a->b->c is not right
19:57:00 <DigitalKiwi> https://wiki.haskell.org/Performance/GHC
19:57:27 <jusss> I'm afraid that there's no a function have a->b->c 
19:57:46 <DigitalKiwi> that might not be it hm
19:58:42 <slack1256> DigitalKiwi: That isn't what I had in mind :-P .
19:59:26 <slack1256> The ghc compiler itself is *slow* at compiling, plus it has 1G memory usage on certain setups.
20:00:33 <DigitalKiwi> there's some info here https://wiki.haskell.org/GHC/FAQ
20:00:44 <DigitalKiwi> dynamic vs static linking
20:00:55 <DigitalKiwi> is a big one I've seen matter a lot
20:01:02 <jusss> Axman6: there's?
20:02:01 <slack1256> Oh that can be, nixos default compiler mode for haskell programs is static.
20:04:15 <Axman6> jusss: correct, there is no function with that type
20:08:24 <bifunctorial> you can prove it to yourself by letting c = Void
20:24:50 <Axman6> jusss: this question about whether you can generate a function from its type is related to out types being algebraic. We can talk about how many functions there are of a given type. There is exactly one function for the tyoe () -> (), there's also exactly one function of the type a -> a. There's two of the type a -> a -> a, which are const and flip const. How many functions do you thing there are of type Bool -> Bool?
20:26:44 <jusss> Axman6: four?
20:27:11 <Axman6> sounds right to me
20:27:20 <Axman6> what about Bool -> Bool -> Bool?
20:27:42 <jusss> Axman6: I'm not good at maths, 2^3 ?
20:28:06 <Axman6> IIRC it's 2^(2^2)
20:36:25 <dmwit> turab: No, those are not equivalent.
20:36:38 <dmwit> turab: foldl' calls seq at each recursive step; your foldl+seq version doesn't.
20:40:32 <_Theo_> I'm curious about Haskell. How much of category theory is applicable to it? Not asking if it's necessary, just if Haskell and category theory complement each other well.
20:41:33 <jusss> Axman6: another question, >>= f g x = g (f x) x , this can be turn to >>= f g = \x -> g (f x) x ?
20:43:52 <anohigisavay> hi, i'm trying to install cabal-install with cabal, and i got this error
20:43:55 <anohigisavay> http://dpaste.com/36ZQKVW
20:44:04 <dramforever> jusss: yes
20:44:14 <jusss> dramforever: through?
20:44:58 <anohigisavay> dram大神泥壕啊
20:45:12 <dramforever> jusss: That's just syntax sugar
20:45:18 <dmwit> _Theo_: That's a pretty soft question. I don't think you're gonna get a very satisfying answer.
20:45:39 <jle`> _Theo_: it depends on what you mean by "applicable"
20:45:59 <Cale> _Theo_: A categorical way of thinking can be fairly fruitful
20:46:02 <jusss> dramforever: which has a name for it?
20:46:03 <jle`> do you mean how much category theory would help you in learning haskell?
20:46:16 <dmwit> jusss: `>>= f g x = ...` is defined to mean `>>= f g = \x -> ...` (and, therefore, to mean `>>= = \f -> \g -> \x -> ...`)
20:46:19 <jle`> or maybe in writing haskell?
20:47:02 <_Theo_> I'm pretty much new to both, and I'm finding what I'm learning about category theory interesting. In the same way, I'm finding Haskell interesting. So I guess my question is how much of category theory can be used in Haskell? Not sure if that's better rephrasing.
20:47:07 <jusss> dmwit: does this transformer or syntax sugar has a name?
20:47:19 <dmwit> Not one I know.
20:47:26 <jusss> ok then
20:48:13 * dmwit puts his tongue in his cheek and says "10%" in _Theo_'s general direction
20:48:39 <Cale> _Theo_: here's one package you could look at http://hackage.haskell.org/package/categories-1.0.7
20:48:59 <jle`> _Theo_: do you mean, can you do CAS-type stuff with category theory in Haskell?
20:49:02 <dmwit> Category theory is huge, and for any domain X, most of it is not useful for X.
20:49:13 <jle`> _Theo_: like, do you want to use Haskell to help you with Category Theory problems
20:49:24 <dmwit> This includes the domain X = Haskell programming.
20:49:41 <_Theo_> jle`, Yes, pretty much.
20:49:57 <jle`> hm, yeah, i think haskell is well-suited for doing a lot of mathematical based programming
20:50:29 <Cale> Haskell provides some decent examples of categories here and there (the category of Haskell types and functions between them being primary among those), and a fair number of the definitions from category theory specialise into useful things to discuss.
20:50:41 <jle`> if you, say, want to write a library that will help you solve category theory proofs and problems
20:50:53 <jle`> haskell gives you the tools to write such a library or program in a nice way
20:50:55 <dmwit> anohigisavay: Hm. Normally I would suggest running the proposed ghc-pkg check command, but that's... probably hard to do correctly with the way cabal v2-* stuff munges package databases.
20:52:29 <_Theo_> I see, I will try to look into this more. Regardless, I do want to learn Haskell. It would add to the level of fun (?) if it paired nicely with learning category theory.
20:52:40 <jle`> _Theo_: but i think one neat thing about haskell is that you can often apply principles and proofs/equivalences in category theory to reason about your programs, and make program refactorings/rewritings based on the conclusions of cattheo and other abstract maths
20:53:04 <jle`> in general for all programs, not just numerical/mathematics based programs
20:53:11 <turab> dmwit: That makes sense. Is it better to call seq at each step or at the end?
20:53:22 <jle`> _Theo_: ah, you might be interested in "Category Theory for Programmers", which actually teaches CT using Haskell to demonstrate examples
20:53:27 <jle`> Haskell and C, I believe
20:53:41 <jle`> but, it's aimed for people who are already familiar with programming principles
20:53:47 <_Theo_> Oh, nice. Thank you. I'll search it up now.
20:53:52 <anohigisavay> dmwit: seems `ghc-pkg check` is done against the global database. it lists megaparsec as a broken package which was installed from my Arch package manager
20:53:59 <jle`> so maybe not the best if you are learning progrmaming, but maybe good if you are learning haskell as a second or third language
20:54:02 <_Theo_> I am. I know C, actually.
20:54:36 <_Theo_> Yeah, I know Java as well, so pretty intermediate as a programmer, I guess.
20:54:49 <jle`> you're probably right in the audience range for that book then :)
20:55:02 <jle`> it's available for free online as a series of blog posts but there is also a print version for sale
20:55:14 <anohigisavay> dmwit: not sure if it's related but i better not touch it since it will break my system dependencies
20:55:49 <_Theo_> Hmm, I'd prefer something physical, but pdf or blog is okay.
20:56:22 <dmwit> turab: Of course the answer to any such question is "it depends" -- or else the compiler would do it for you, hey?
20:56:48 <dmwit> turab: However, in this case a rule of thumb applies: foldl' is almost always better than foldl.
20:57:07 <anohigisavay> actually i'm just trying to get a taste of liquidhaskell. but i can't install it successfully with either cabal or stack
20:57:45 <dmwit> anohigisavay: Oh, arch.
20:57:58 <dmwit> anohigisavay: Is GHC installed from the package manager?
20:58:11 <anohigisavay> dmwit: yes
20:58:34 <turab> dmwit: Thanks!
20:58:40 <turab> anohigisavay: I highly recommend ghcup
20:58:50 <dmwit> anohigisavay: I suggest getting a copy of GHC from somewhere else.
20:59:02 <dramforever> Not GHC from Arch...
20:59:07 <dmwit> But see also the Arch wiki page on Haskell, which has instructions if you want to try to weather the pain of the package-manager-ghc.
20:59:42 <turab> I tried other alternatives in hopes to learn more (which I did), but installing ghc using ghcup was painless
20:59:58 <anohigisavay> turab: dmwit: thanks i'll try it
21:00:13 <dmwit> anohigisavay: You can safely install a different GHC version from the official bindists alongside the one you currently have from the package manager; they won't fight or anything.
21:00:22 <anohigisavay> sounds something like rustup
21:00:30 <dmwit> ghcup was inspired by rustup, yes.
21:01:02 <habbah> https://hackage.haskell.org/package/megaparsec-7.0.5/docs/Text-Megaparsec-Char-Lexer.html#v:charLiteral
21:01:05 <habbah> charLiteral :: (MonadParsec e s m, Token s ~ Char) => m Char
21:01:14 <habbah> what is this saying?
21:02:04 <habbah> there's an equality constraint between Token s and Char
21:02:06 <dmwit> It says that `charLiteral` is a parser which works whenever the token type is characters, and returns a character.
21:02:45 <dmwit> Presumably Token is a type family, though I haven't looked at your link.
21:04:01 <jle`> habbah: yes, it's that m has to be an instance of MonadParsec e s m, and Token s has to be equal to Char
21:04:04 <dmwit> So if your confusion is something like "Well, `Maybe s` can't possibly be a `Char`, so how could `Token s` be a `Char`?" then you'll want to read the documentation on the TypeFamilies extension.
21:04:21 <jle`> 'Token s' is a type family, which is sort of like a type-level function or "property" of 's'
21:05:11 <jle`> so basically you can pick charLiteral for any e, s, m....as long as you have an instance MonadParsec e s m, and whatever 's' is, 'Token s' is Char
21:05:48 <dmwit> At a guess, for example `Token String ~ Char` is likely true.
21:06:03 <dmwit> (Probably `Token [a] ~ a`.)
21:07:48 <rajivr___> I am new to Haskell. I wanted to confirm that there is no difference between `length :: forall {t :: * -> *} {a}. Foldable t => t a -> Int` and `length :: forall {t :: * -> *} {a :: *}. Foldable t => t a -> Int`. Basically is `{a}` is syntactic sugar for `{a :: *}`?
21:08:15 <habbah> thank you both. this makes sense. I can see that the m needs to MondParsec e s m, I can accept that Char needs to be a Token s. I do need to read about type families at some point though.
21:10:13 <dmwit> rajivr___: The two alternatives are identical, but the conclusion ("`{a}` is syntactic sugar for `{a :: *}`") does not follow.
21:10:25 <dmwit> rajivr___: Just like there is type inference, there is also kind inference.
21:10:45 <dmwit> rajivr___: Kind inference tells us that because `t :: * -> *` and we have `t a` in the type, then `a :: *`.
21:11:21 <rajivr___> I see. Thanks Daniel! :-) 
21:12:28 <dmwit> rajivr___: Compare `lift :: forall {t :: (* -> *) -> * -> *} {m} {a}. (MonadTrans t, Monad m) => m a -> t m a`, which is equivalent to `lift :: forall { t :: (* -> *) -> * -> * } {m :: * -> *} {a :: *}. ...`.
21:12:46 <dmwit> rajivr___: There the `{m}` is expanded via kind inference to `{m :: * -> *}`, not `{m :: *}`.
21:15:18 <rajivr___> Thanks again dmwit  . I really hadn't though of it that way.
21:20:43 <anohigisavay> thank you! ghcup is cool
21:21:12 <turab> anohigisavay: I teared up a bit the first time I used it :)
21:47:57 * hackage fast-builder 0.1.0.2 - Fast ByteString Builder  https://hackage.haskell.org/package/fast-builder-0.1.0.2 (AkioTakano)
22:24:04 <jle`> rajivr___: i'd think of it like kind inference
22:24:23 <jle`> rajivr___: so it's on the same level of difference as differences in explicitness for type inference
22:24:38 <jle`> rajivr___: for example, (1 :: Int) + (2 :: Int) vs. (1 :: Int) + 2
22:25:01 <jle`> these two are equivalent, but we have the option to use a type annotation
22:25:26 <jle`> usually type annotations are not necessary, but we sometimes use them to improve readability and as self-documentation
22:25:56 <jle`> oh i basically just repeated what dmwit wrote
22:26:03 <jle`> i skimmed to quickly D:
22:26:19 <rajivr___> Thanks jle` :-) Yes, up until now I had not developed an intuition  / realization for kind inference.
22:27:00 <jle`> yeah, :: is "annotation" syntax when used in a type or value expression
22:27:14 <rajivr___> Haskell continues to blow my mind.
22:27:22 <jle`> so you can think of it as 'decorating' an expression, to either help inference or readability
22:27:41 <jle`> note that this is slightly different than the :: in 'length :: ...'
22:28:16 <jle`> in (1 :: Int) + (2 :: Int), the :: Int is a syntactically optional part of expression syntax, that decorates an expression to help inference or readability, or just for fun
22:28:43 <jle`> so as an expression you could always view it as syntactically optional, only sometimes necessary
22:30:12 <rajivr___> But isnt `...` in `length :: ...` also optional if type level inference can figure things out?
22:30:29 <jle`> syntactically optional, semantically (sometimes) necessary
22:30:52 <jle`> rajivr___: it's a bit subtle depending on the context that we're seeing length :: ...
22:31:14 <jle`> when we type `myFunction :: Int -> Bool; myFunction = ...`, this is a part of "declaration syntax"
22:31:30 <jle`> so :: here is not decorating an expression, but is rather a rigid part of the syntax for declaring a named binding
22:31:44 <jle`> (... :: ...; ... = ...)
22:32:40 <jle`> but if you're using length as a value/expression, then yeah, the type annotation is usually optional
22:32:59 <rajivr___> I see. Thanks for for clarifying. 
22:33:01 <jle`> > (length :: forall t a. Foldable t => t a -> Int) [1,2,3]    -- it's optional here
22:33:04 <lambdabot>  3
22:34:32 <jle`> well, it's optional as a declaration too. it's just that the two usages are slightly different to me, since they come from different parts of syntax
22:55:50 <rsoeldner> If I want to ship my sql migration files with the executable (&nix) is the right way to go using `data-files` ?
23:11:13 <dmwit> If you need the files at runtime, yes. If they're used at compile-time, then extra-source-files is correct.
23:13:52 <dmwit> There are certain extensions that make certain type signatures... well, "mandatory" isn't the right word. But less optional.
23:14:05 <dmwit> ScopedTypeVariables and TypeApplications, specifically.
23:14:18 <dmwit> But that nuance can come later maybe.
23:33:16 <rsoeldner> dmwit, and how does it differ from using `data-dir` ?
23:43:13 <dmwit> data-files are installed in a place the executable can find. extra-source-files are not. data-dir gives a directory to copy the data-files out of.
23:44:22 <rsoeldner> dmwit, thanks
23:46:59 <dminuoso> jusss: So I think you might have confused yourself too much, let's take the time and take a step backwards.
23:48:17 <jusss> dminuoso: when m is e-> in >>=, I have got >>= f g x = g (f x ) x
23:48:51 <dminuoso> jusss:  (>>=) is not somtehing you can just define on the spot.
23:49:00 <jusss> dminuoso: and only when m is e->, I think we can get its function definition from its type
23:49:08 <dminuoso> Ah.
23:49:29 <dminuoso> jusss: I missed that there was some new talk today. :)
23:49:53 <jusss> dminuoso: yeah, can we get its function definition from its type
23:50:08 <jusss> dminuoso: the answer it seems no
23:50:34 <dminuoso> jusss: We generally can, actually.
23:50:53 <dminuoso> jusss: It's what sometimes called "type tetris"
23:51:25 <jusss> dminuoso: aha, so tell me, >>= :: m a -> (a -> m b) -> m b, what function definition you can get?
23:52:00 <jusss> dminuoso: just one will be good,
23:52:04 <dminuoso> jusss: The original excercise was about defining >=> in terms of >>=
23:52:13 <jusss> even one type may have multiple function definitions
23:52:26 <dminuoso> jusss: Sometimes there may only be one in fact.
23:52:38 <dminuoso> jusss: The more general a function is (polymorphism), the less implementations it has.
23:52:55 <jusss> dminuoso: and what is >>= ?
23:53:04 <jusss> funtion definition
23:53:15 <dminuoso> jusss: Frequently you may have only one way or few ways to write a function that can even type check. It may not always give you a precise answer, but it wil tell you "it must be either one of these two" - then its just left to you to figure out which one the correct is.
23:53:44 <dminuoso> jusss: try implementing a definition for the following functoin:
23:54:00 <dminuoso> % f :: a -> (a -> b) -> b; f x y = undefined
23:54:01 <yahb> dminuoso: 
23:55:41 <dmwit> For almost every monad I can think of off the top of my head, there is more than one implementation of (>>=)'s type that typechecks (though perhaps violates the monad laws).
23:55:42 <dminuoso> If you just stare at "what do I need to produce" and "what things do I have", there's only a single way you can achive your goal. In this particular example its so strong, that there's only one way this can type check - and that happens to be the correct implementation.
23:55:45 <jusss> dminuoso: l :: a, g :: a->b, so f l g = g l
23:56:04 <dminuoso> jusss: Right. Are you convinced that's the only definition you could supply?
23:56:13 <jusss> dminuoso: of course not
23:56:16 <dminuoso> (Note that any forms of undefined/bottom/infinite recursion do not count)
23:56:19 <dminuoso> jusss: Then convince yourself.
23:56:44 <jusss> dminuoso: add :: Int -> Int,  add x =x and add x = x+1 both have add :: Int -> Int
23:57:07 <dminuoso> jusss: You are absolutely correct.
23:57:21 <dminuoso> jusss: The key thing to understand is that ⌜add⌝ is specialized to some types.
23:57:29 <jusss> dminuoso: like I said, one type may have multiple function definitions
23:58:10 <jusss> dminuoso: but the question is, can we get at least one fit function from its type
23:58:20 <dminuoso> jusss: How many implementations for ⌜Integer -> Integer⌝ do you think there exist?
23:58:30 <dmwit> I side with jusss: one type may have multiple definitions. I side with dminuoso: this does not imply that `a -> (a -> b) -> b` has multiple function definitions.
23:59:09 <dmwit> But mostly I side with myself: the whole discussion is weird, because dminuoso appears to care about proving uniqueness for a type that is not the one jusss asked about in the first place.
23:59:42 <dminuoso> dmwit: Well in honesty, the problem arised when I tasked them to implement (>=>) in terms of (>>=) by just using the types involved.
23:59:52 <jusss> dminuoso: infinite
