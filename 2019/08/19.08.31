00:32:16 <Phillemann> Hm, so Servant is nice if you're in its Handler monad, but once you want to add, say, a Reader monad to that, you're basically screwed because you have to rebuild everything inside Handler?
00:33:20 <Rembane> Phillemann: There's a blogpost on how to do this. Have you found it? 
00:34:13 <Phillemann> Rembane: No, sorry.
00:36:21 <Phillemann> Ah, maybe this helps https://docs.servant.dev/en/stable/cookbook/hoist-server-with-context/HoistServerWithContext.html
00:36:31 <Rembane> Phillemann: Yes! That's a good start. 
00:37:05 <Phillemann> I like what Handler does and I hope I can still use it and not rebuild it and write transformer instances :D
00:37:19 <Rembane> Phillemann: I think I used this in combination with the code: https://www.parsonsmatt.org/2015/06/07/servant-persistent.html
00:37:36 <Rembane> Phillemann: Here's my code for it: https://github.com/Rembane/lemmingpants/commit/246639953e9a15c61ceea908aea7d6c81df3e392#diff-2595c5955b83974c883cba9b4afa818eR32
00:50:25 <Phillemann> Rembane: Ok, I think I got it by emulating what's inside the servant cookbook.
00:50:39 <Phillemann> In recent history, this is the most "I have no idea what I'm doing" moment I've had.
00:52:46 <Rembane> Phillemann: Sweet! It's It's not trivial to get that to work, so I can absolutely see why. :)
00:55:28 <Phillemann> Rembane: Thanks for the support though!
00:55:40 <Rembane> Phillemann: No worries. 
00:55:42 <Phillemann> I can see why servant is great, but it's just not the vanilla Haskell I'm used to.
00:55:53 <Rembane> It's loads and loads of type trickery. 
01:36:14 <catchme> what is the best way to do += operator in haskell?
01:36:14 <catchme> I want to update value x with x += 1
01:39:54 <jgt> catchme: succ
01:40:00 <jgt> :t succ
01:40:02 <lambdabot> Enum a => a -> a
01:40:23 <jgt> > succ 1
01:40:26 <lambdabot>  2
01:41:23 <catchme> I am using `let ans = ans + distance p last_p` 
01:41:44 <catchme> succ won't replace that!
01:42:07 <ski> > let x = x + 1 in x
01:42:11 <lambdabot>  *Exception: <<loop>>
01:42:22 <ski> that defines `x' to be itself plus one
01:42:27 <ski> so, infinity, basically
01:42:32 <kaol> modifyIORef ans succ
01:42:33 <ski> that's an infinite loop
01:43:20 <catchme> https://www.irccloud.com/pastebin/zBpRbAnJ/
01:43:21 <no-n> let y = x + 1; x = 1 in y
01:43:25 <ski> catchme : your `let ans = ans + ...' is also an infinite loop (at least assuming you're using a number type with strict addition, like `Int',`Integer',`Float',`Double')
01:43:29 <jgt> it's like when children say "You're stupid times infinity!" "Yeah, we'll you're stupid times succ infinity!"
01:43:31 <no-n> I forgot the >
01:43:34 <catchme> I want to use the value of ans to increae it
01:43:34 <ski> > let y = x + 1; x = 1 in y
01:43:37 <lambdabot>  2
01:43:46 <no-n> thanks =)
01:44:02 <jgt> s/we'll/well/
01:44:11 <ski> catchme : rename `ans' to `ans2', and it should be fine
01:44:41 <catchme> ski: Is this a good style?
01:44:43 <ski> catchme : iow, `let ans2 = and + distance p last_p', and then use `ans2' in the last line, in place of `ans'
01:45:32 <ski> catchme : it's not really good style to use `do' here, no, since you don't use `<-' (and it would presumably be a type error to use it, i imagine)
01:45:43 <ski>   solveN n last_p ans =
01:45:51 <ski>     let p = parseLine
01:46:02 <ski>         ans' = ans + distance p last_p
01:46:16 <ski>      in solveN (n-1) last_p ans'
01:46:24 <ski> that will work, and is more idiomatic
01:46:26 <ski> you can also use
01:46:38 <ski>   solveN n last_p ans = ans''
01:46:40 <ski>     where
01:46:43 <ski>     p = parseLine
01:46:47 <ski>     ans' = ans + distance p last_p
01:46:53 <ski>     ans'' = solveN (n-1) last_p ans'
01:46:56 <ski> or
01:47:04 <ski>   solveN n last_p ans = solveN (n-1) last_p ans'
01:47:05 <ski>     where
01:47:11 <ski>     p = parseLine
01:47:14 <ski>     ans' = ans + distance p last_p
01:47:18 <ski> catchme : makes sense ?
01:47:46 <catchme> ski: yes, I think.
01:48:03 <ski> catchme : btw, note no-n's example
01:48:14 <catchme> ski: Thanks a bunch man
01:48:24 <ski> catchme : definitions in (a single) `let' or `where' are not computed in any particular order
01:48:43 <ski> catchme : in no-n's example, `y' is defined in terms of `x', which is defined after `y'. that is fine
01:49:14 <ski> catchme : similarly, the ordering of the definitions (with `=') in my uses of `let' and `where' doesn't really matter
01:50:15 <ski> catchme : btw, "what is the best way to do += operator in haskell?","I want to update value x with x += 1" makes no sense, you can't update / assign to variables. variables are immutable, you can't change them
01:50:31 <ski> catchme : that's why you had to introduce new variables, when you computed (possibly) new values
01:50:42 <ski> catchme : okay ?
01:51:00 <catchme> ski: aha I got that
01:51:16 <catchme> I wanted to destruct the old object the replace it with the new one
01:51:28 <catchme> and replace it**
01:52:00 <ski> (it is possible to get actually mutable things, which you can update / assign to. but those will not be variables, and it's better if you forget about those for a while, so you get used to using immutable stuff, first. so that you only reach for mutable stuff, when you really actually need it)
01:52:33 <ski> catchme : garbage collection will take care of the old value, in case it's not needed any more
01:53:39 <ski> (catchme : better say "value", not "object". "object" might suggest something with internal state, which can change. values don't change. e.g. you can't update the `3' value to suddenly be four, anywhere it occurs in the program)
01:55:13 <catchme> ski: OK, I think I understand that now.
01:57:39 <catchme> So I can't shadow variable like in lisp `(let ((x x)) (setf x 10) (print x))`
01:57:42 <ski> catchme : of course, you could also just avoid naming the intermediates
01:58:02 <ski>   solveN n last_p ans = solveN (n-1) last_p (ans + distance parseLine last_p)
01:58:26 <ski> catchme : btw, what's the expected type of this `solveN'
01:58:50 <catchme> IO ()
01:59:06 <ski> catchme : the `parseLine' (which i didn't notice 'til now) made me suspicious that `let p = parseLine' should perhaps really be `p <- parseLine'
02:00:11 <ski> catchme : "So I can't shadow variable like in lisp `(let ((x x)) (setf x 10) (print x))`" -- you can', but not with `let' or `where' (those are recursive, like `letrec' / `flet'/`flabels'/`labels' or whatever it's called in CL (i don't recall exactly))
02:01:03 <ski> catchme : oh, so i think `let p = parseLine' should actually be `p <- parseLine' (since otherwise, you're just giving a new name, `p' to the value `parseLine', which doesn't seem to be very useful)
02:01:48 <ski> catchme : presumably `parseLine' is an action, that you want to perform, and then name the *result* of that action `p', rather than giving an alias/synonym `p' to the action `parseLine' itelf (which is what `let p = parseLine' will do)
02:02:02 <catchme> ski: Thanks, I just checked https://stackoverflow.com/questions/28624408/equal-vs-left-arrow-symbols-in-haskell
02:02:20 <yorick> luite: uncaught exception in Haskell main thread: ReferenceError: h$ControlZCExceptionzubasezuGHCzziIOzucatchzuHPCzucc is not defined
02:02:41 <ski> so, lets step away from the `where'-versions (and also my `let'-version without `do') since those assumed there was no actual `<-' to perform in the `do' (making it redundant)
02:02:44 <ski> so
02:02:58 <ski>   solveN n last_p ans =
02:03:05 <ski>     do p <- parseLine
02:03:16 <ski>        let ans' = ans + distance p last_p
02:03:30 <ski>        solveN (n-1) last_p ans'
02:03:45 <ski> that sounds a bit more reasonable, i hope
02:04:02 <ski> it is still possible to replace the last two lines by
02:04:12 <ski>         solveN (n-1) last_p (ans + distance p last_p)
02:04:23 <ski> if you want to, avoiding naming the intermediate result
02:04:29 <ski> catchme : makes sense ?
02:04:41 <catchme> ski: Yes. Thanks a lot
02:09:30 <ski> catchme : there is possibly also a logical error, in that piece of code ..
02:10:03 <catchme> ski: `solveN (n-1) p (ans + distance p last_p)`
02:10:37 <ski> yep :)
02:11:12 <ski> (i hope you have a stopping condition, a base case)
02:11:34 <catchme> of course, :)
02:14:04 <PotatoRick[m]> hi there. is it possible to write `Eq` instance for such a rankntype: `data Foo = Foo (forall a. ToJSON a => a)`?
02:14:05 <PotatoRick[m]> i'm trying to write `instance Eq Foo where x == y = toJSON x == toJSON y` but get error about type ambiguity
02:14:58 <ski> PotatoRick[m] : what are the methods and superclasses of `ToJSON' ?
02:15:26 <ski> (i think the answer will be "no", but one could check those)
02:16:15 <PotatoRick[m]> method is `toJSON :: a -> Value` and no superclasses
02:16:21 <ski> basically, to check equality, you'd need to try instantiating `a' with every possible instance of `ToJSON', and then check equality
02:17:13 <ski> but that can't work, unless `ToJSON a' implies `Eq a', or if you somehow know that new types can't be made instances of `ToJSON', and that all existing instances are already instances of `Eq'
02:18:07 <ski> if there's some `a' not in `Eq', but in `ToJSON', then you can't use `(==)' to check for equality. but it could still be possible to extract out some information which lets you tell `x' and `y' apart -- so you're hosed, in that case
02:18:15 <ski> hmm
02:18:18 <ski> PotatoRick[m] : okay
02:18:59 <PotatoRick[m]> ski: but `Value` has `Eq` instance 
02:19:10 <PotatoRick[m]> why `a` should have it?
02:19:37 <ski> PotatoRick[m] : so `forall a. ToJSON a => a' is then roughly the same as `forall a. (a -> Value) -> a' (except that you can't pass any `a -> Value' in there, only an implementation of `toJSON', and there can be at most one, for any particular choice of `a')
02:20:58 <ski> PotatoRick[m] : consider this case : you can choose to instantiate `a' in both `x' and `y' to say `Int', then (assuming there is an instance `ToJSON Int'), `x' and `y' will both have type `Int'. now, converting them to `Value' will presumably not lose any information (and distinctions)
02:21:56 <ski> but if `toJSON' in some case loses information/distinctions (so fails to be an injective function), then it is not enough to just compare the results of `toJSON', you must somehow compare the original (monomorphized) `x' and `y'
02:22:26 <PotatoRick[m]> <ski "PotatoRick : consider this case "> i don't care actually about loosing information here, i just want to compare two `Value`s, which seems absolutely possible for me
02:23:04 <ski> PotatoRick[m] : anyway, the basic problem with `instance Eq Foo where x == y = toJSON x == toJSON y' is that you haven't told it *which* type `a' to pick. should it pick `a' be `Bool', or `Int', or ... (in fact you haven't told it that it must even pick the same type for `a', for both `x' and `y')
02:23:17 <ski> PotatoRick[m] : *however* ..
02:23:33 <ski> PotatoRick[m] : it occurs to me that, perhaps you don't actually want this definition of `Foo' at all
02:23:57 <PotatoRick[m]> <ski "PotatoRick : anyway, the basic p"> i've told that `a` is any time provided inside rankntype which implements `ToJSON`
02:24:15 <ski> PotatoRick[m] : perhaps you want to be able to store any value of any *particular* type, as long as the type is an instance of `ToJSON', inside a `Foo' ?
02:24:33 <PotatoRick[m]> <ski "PotatoRick : it occurs to me tha"> i actually really need it, this example isn't real
02:24:53 <ski> PotatoRick[m] : you actually really need *what* ?
02:25:00 <ski> (that's the question)
02:25:27 <ski> (and don't tell me that you actually really need this definition of `Foo'. tell me what information it is you need to store inside a `Foo')
02:25:36 <PotatoRick[m]> i want to be able to store any possible value which has `ToJSON` instance, and `Foo` can be not the only one constructor
02:25:59 <ski> PotatoRick[m] : right, that's what i suspected !
02:26:09 <ski> so `forall a. ToJSON a => a' is not what you want there
02:26:56 <PotatoRick[m]> okay, here it goes the, about what i'm trying to implement. i want to build raw SQL request with kinda interpolation, like inline substitution, instead of placeholders and values apart
02:27:04 <PotatoRick[m]> s/the/then/
02:27:12 <ski> the only values that you can store, with that definition of `Foo', the only values of type `forall a. ToJSON a => a', are values which *simultaneously* have type `Bool',`Integer',`String',&c. (assuming all these have `ToJSON' instances)
02:27:25 <ski> PotatoRick[m] : so `forall a. ToJSON a => a' is *not* what you want here, then
02:27:56 <ski> PotatoRick[m] : so, it sounds like you want an "existential", you want `exists a. ToJSON a *> a'
02:28:40 <ski> `forall a.' means that you have to provide a value that can work for *any* type `a' the user picks
02:29:01 <ski> `exists a.' means that *you*, you store a value inside a `Foo', get to pick the type `a'
02:29:17 <PotatoRick[m]> <ski "`forall a.' means that you have "> any type user picks which has `ToJSON` instance, right?
02:29:26 <ski> `ToJSON a =>' means that the user can actually only pick a type for `a', in case it has a `ToJSON' instance
02:29:58 <ski> `ToJSON a *>' means that, when *you* store a value inside a `Foo', *you* can only pick a type `a' that is actually an instance of `ToJSON'
02:30:24 <ski> PotatoRick[m] : i answered that question, with the follow-up
02:30:27 <ski> so, you want
02:30:29 <ski>   data Foo = Foo (exists a. ToJSON a *> a)
02:30:40 <ski> PotatoRick[m] : however, this is pseudo-Haskell, not implemented syntax
02:30:55 <ski> i still think it's good to think, conceptually, in hese terms, though
02:31:37 <ski> actually, let's rename the data constructor (but not the type constructor) from `Foo' to `MkFoo'
02:31:41 <ski>   data Foo = MkFoo (exists a. ToJSON a *> a)
02:31:50 <ski> now, consider what the type signature of the data constructor `MkFoo' will be here
02:31:58 <ski>   MkFoo :: (exists a. ToJSON a *> a) -> Foo
02:32:05 <ski> PotatoRick[m] : does that make sense, so far ?
02:32:54 <PotatoRick[m]> i can have `[Foo]` with different types inside `Foo` constructor, being able to `Show` original value and being able to compare database values of those value `data RawSqlPiece = RawValue (forall a. (Show a, PersistentField a) => a)`
02:33:11 <ski> ues, P
02:33:14 <ski> yes, PotatoRick[m]
02:33:29 <ski> but, again, it should not be
02:33:29 <PotatoRick[m]> <ski "now, consider what the type sign"> a -> Foo
02:33:36 <ski>   data RawSqlPiece = RawValue (forall a. (Show a, PersistentField a) => a)
02:33:37 <ski> but
02:33:46 <ski>   data RawSqlPiece = RawValue (exists a. (Show a, PersistentField a) *> a)
02:34:05 <ski> PotatoRick[m] : let's for a moment consider another function
02:34:12 <ski>   length :: [a] -> Int
02:34:17 <PotatoRick[m]> any `a` that implements `PersistField` and `Show` -> Foo
02:34:41 <ski> this is really an abbreviation, where we have elided a `forall', the proper, explicit, way to state this is
02:34:45 <ski>   length :: forall a. [a] -> Int
02:34:53 <ski> or, with brackets for extra emphasis
02:34:56 <ski>   length :: forall a. ([a] -> Int)
02:35:25 <ski> this says : for each type `a', if you apply `length' to a list with elements of type `a', you get an `Int' back as result
02:35:36 <ski> now, i'm claiming this is the same as
02:35:46 <ski>   length :: (exists a. [a]) -> Int
02:36:23 <ski> this says : the result of calling `length' will be an `Int', as long as there exists some type `a' such that the argument is a list with elements of type `a'
02:36:33 <ski> PotatoRick[m] : do you see that these two are really the same ?
02:36:39 <ski> logically
02:36:47 <ski>   (exists a. ..a..) -> ...
02:36:52 <ski> is equivalent to
02:36:59 <ski>   forall a. (..a.. -> ...)
02:37:14 <ski> therefore, going back to `MkFoo', we have that
02:37:20 <ski>   MkFoo :: (exists a. ToJSON a *> a) -> Foo
02:37:23 <ski> is equivalent to
02:37:34 <ski>   MkFoo :: forall a. ((ToJSON a *> a) -> Foo)
02:37:41 <ski> also, i will claim that
02:37:52 <ski>   (Cxt *> T) -> U
02:37:55 <ski> is equivalent to
02:38:03 <ski>   Cxt => (T -> U)
02:38:09 <ski> (this is sortof "currying")
02:38:13 <ski> and therefore
02:38:16 <ski>   MkFoo :: forall a. ((ToJSON a *> a) -> Foo)
02:38:21 <ski> in turn is equivalent to
02:38:30 * hackage attoparsec 0.13.2.3 - Fast combinator parsing for bytestrings and text  https://hackage.haskell.org/package/attoparsec-0.13.2.3 (BenGamari)
02:38:30 <ski>   MkFoo :: forall a. (ToJSON a => (a -> Foo))
02:38:39 <ski> or, without the redundant brackets
02:38:45 <ski>   MkFoo :: forall a. ToJSON a => a -> Foo
02:39:12 <bifunc2> Is there a ByteString -> Maybe Float function out there? It should return Nothing if either it's not a valid numbber, or it's too large/requires too much precision that Float can't handle.
02:39:25 <PotatoRick[m]> i see, but i don't see the problem converting them to a `Value` using `toJSON` to compare `Value`s
02:39:26 <ski> this says : for each type `a', as long as `a' is an instance of `ToJSON', we can apply `MkFoo' to an `a', and get a `Foo' back
02:39:28 <ski> while
02:39:35 <ski>   MkFoo :: (exists a. ToJSON a *> a) -> Foo
02:40:22 <ski> says that : calling `MkFoo' will give us back a `Foo', as long as there exists some type `a', being an instance of `ToJSON', such that the argument has type `a'
02:40:56 <ski> PotatoRick[m] : i already stated the problem with your code : it has no idea which actual type to use in place of `a'
02:41:09 <ski> if you say
02:41:14 <ski>   data Foo = MkFoo (forall a. ToJSON a => a)
02:41:31 <ski> then there *is* no "actual type `a' in there"
02:42:21 <ski> (or, you could say that *every* type `a', well every type which is an instance of `ToJSON', is in there, simultaneously -- which is not that helpful)
02:42:29 <ski> now, if you instead said, as i suggested
02:42:59 <ski>   data Foo = MkFoo (exists a. ToJSON a *> a)  -- still pseudo-Haskell, not supported syntax, this is just for discussing the concepts
02:43:15 <ski> then there *is* an "actual type `a' in there"
02:43:26 <ski> (one which is known to be an instance of `ToJSON')
02:43:30 <PotatoRick[m]> okay, it seems i'm starting to get it, why the compiler can't decide
02:43:47 <ski> PotatoRick[m] : based on what you've said, it sounds like you want `exists' over `forall'
02:43:52 <PotatoRick[m]> it has no info about the type inside after value is created
02:44:12 <ski> now, this is not actually implemente syntax (perhaps something like this will be implemented, at some point, hmm)
02:44:24 <PotatoRick[m]> which isn't exists in haskell for now, right?
02:44:37 <PotatoRick[m]> existing*
02:45:01 <ski> (there is an `exists' in UHC and LHC (but restricted, doesn't work in our case) -- but not in GHC)
02:45:24 <PotatoRick[m]> because of the type erasure?
02:45:25 <ski> (hm, actually, perhaps it would work in this case .. but not in GHC)
02:45:54 <ski> nope, just because the syntax isn't implemented (and there's some type checking/inference issues too, which i think is the main reason it's not implemented)
02:45:59 <ski> so
02:46:04 <ski>    data Foo = MkFoo (exists a. ToJSON a *> a)
02:46:18 <ski> anyway, we had considered the type signature of the data constructor `MkFoo', restating it from
02:46:31 <ski>   MkFoo :: (exists a. ToJSON a *> a) -> Foo
02:46:32 <ski> to
02:46:44 <ski>   MkFoo :: forall a. ToJSON a => a -> Foo
02:47:33 <ski> and this suggests the actual syntax implemented in GHC (with extension `ExistentialQuantification', which imho is a misnomer, since that extension sounds like it would enable the `exists' existential quantifier syntax .. but it doesn't, so ..)
02:47:54 <ski>   data Foo = forall a. ToJSON a => MkFoo a
02:48:16 <ski> note that the `forall' (and the constraint) is *before* the data constructor, not *after*
02:48:21 <ski> that makes all the difference
02:48:35 <ski> your original
02:48:47 <ski>   data Foo = MkFoo (forall a. ToJSON a => a)
02:48:50 <ski> would have given
02:49:04 <ski>   MkFoo :: (forall a. ToJSON a => a) -> Foo
02:49:11 <ski> which is *very* different from
02:49:18 <ski>   MkFoo :: (exists a. ToJSON a *> a) -> Foo
02:49:27 <ski> (which is the same as
02:49:35 <ski>   MkFoo :: forall a. ToJSON a => a -> Foo
02:49:36 <ski> )
02:49:39 <ski> in general
02:49:49 <ski>   foo :: (forall a. ..a..) -> ...
02:49:54 <ski> is *very* different from
02:50:04 <ski>   foo :: forall a. (..a.. -> ...)
02:50:35 <ski> the left-nesting of the `forall' *completely* changes what the type means, how you can use `foo', and what the implementation of it must provide
02:51:02 <ski> anyway, this is just stressing the point, hopefully giving you a somewhat better idea of the whole thing
02:51:22 <ski> summarizing, we have now gotten to the actual definition, working in GHC (with extension)
02:51:28 <ski>   data Foo = forall a. ToJSON a => MkFoo a
02:51:57 <ski> now, consider
02:52:04 <ski>   instance Eq Foo
02:52:06 <ski>     where
02:52:12 <ski>     x == y = toJSON x == toJSON y
02:52:27 <ski> note that we *don't* know that `x' and `y' have the same type `a'
02:52:41 <ski> in general, they could be of *different* types
02:53:08 <ski> oh, actually we should match on the data constructor
02:53:11 <ski>   instance Eq Foo
02:53:12 <ski>     where
02:53:19 <ski>     MkFoo x == MkFoo y = toJSON x == toJSON y
02:53:38 <ski> but, we still know that both types, the type of `x', and of `y', are instances of `ToJSON'
02:53:49 <PotatoRick[m]> yep
02:54:00 <ski> so, we can apply `toJSON' to both of them (which will possibly run different code, in case those are different types)
02:54:11 <ski> and we get back `Value's, which we can compare
02:54:23 <ski> now, there is one potential complication here
02:55:00 <ski> in case `toJSON' is not injective, in case it forgets some distinctions, then even if the `Value's are equal, could `x' and `y' still be different ?
02:55:38 <ski> *if* we could recover the types of `x' and `y' (which could be possible, with some other type class than `ToJSON'), then this could be the case !
02:55:56 <ski> but `ToJSON' doesn't allow any such type recovery
02:56:17 <PotatoRick[m]> <ski "in case `toJSON' is not injectiv"> they could (but in my case it isn't important)
02:56:25 <ski> as soon as we hide a type behind an `exists', it's forgotten/abstract/opaque/hidden (another term is "skolem")
02:56:55 <PotatoRick[m]> i can use `Typeable` if i need to recover types, right?
02:57:06 <ski> we can't recover it .. unless we have stored extra information inside the `exists' (such as a `Typeable a' constraint, e.g.), which would allow use to recover the type
02:57:25 <ski> (another way would be to have a value of some appropriate GADT type, parameterized by `a')
02:57:36 <ski> but that's not the case here, so we're safe !
02:57:41 <ski> in fact
02:58:06 <ski> the *only* thing we can do with an `x' inside `MkFoo x', after unpacking, is to call `toJSON' on it !
02:58:22 <ski> so .. why not instead store `MkFoo (toJSON x)' directly ?
02:58:27 <ski> iow, why not just
02:58:37 <ski>   data Foo = MkFoo Value
02:58:37 <ski> ?
02:58:52 <PotatoRick[m]> <ski "so .. why not instead store `MkF"> i also may want to use `Show` of original type
02:58:55 <ski> in fact, why define `Foo' at all, we could just say
02:59:03 <ski>   type Foo = Value
02:59:24 <PotatoRick[m]> `Foo` isn't the only one constructor in my case
02:59:27 <ski> using `toJSON x' in place of `MkFoo (toJSON x)' (which in turn was in place of `MkFoo x')
02:59:33 <ski> okay
02:59:38 <PotatoRick[m]> i'd have also `Table`, `Field`, etc.
02:59:46 <ski> still, you could store just a `Value'
03:00:11 <ski> but, that means that instead of constructing a `Foo' as `MkFoo x', you'd have to say `MkFoo (toJSON x)', which is a little bit more verbose
03:00:26 <PotatoRick[m]> i could, but `Show` wouldn't work 
03:00:42 <PotatoRick[m]> i mean, the result would be completely different
03:00:57 <ski> (but with the type synonym, or simply using `Value' directly in place of `Foo', you'd be replacing `MkFoo x' with `toJSON x', which is about as verbose, no bigh change)
03:01:19 <ski> PotatoRick[m] : right, good. so you're realizing the limits of parts of my argument here
03:01:36 <ski> for `Show' you could store a `String'
03:01:37 <PotatoRick[m]> ski: so, you answered my first question at some point, i should use `ExistentialQuantification` and declare constrant and `forall` before the constructor, not inside it
03:02:19 <ski> `exists a. Show a *> a' is basically just `String', just like `exists a. ToJSON a *> a' is basically just `Value'
03:02:39 <bifunc2> Someone must have implemented this already?
03:02:41 <ski> (actually `Show' also has a `showsPrec' method, which makes it slightly more involved .. but not much)
03:02:46 <bifunc2> Seems like a basic thing.
03:02:51 <bifunc2> "basic"
03:02:57 <ski> PotatoRick[m] : *nod*
03:03:10 <PotatoRick[m]> <ski "for `Show' you could store a `St"> in case i want to make datatype constructors public then i want them being safe and protected, so that wouldn't be safe enough for me, only if i hide the constructors and write value creators functions
03:03:24 <ski> PotatoRick[m] : good point
03:04:38 <ski> (that point is really about wanting to express a subtype of `String', namely those strings which can be the result of showing some value)
03:04:41 <PotatoRick[m]> thanks a lot for the explanation
03:05:10 <ski> PotatoRick[m] : i think you may be good to jump back in and tackle anew your situation, yea ?
03:05:59 <yorick> how do I demangle ghcjs names?
03:07:01 <PotatoRick[m]> ski:  think i'm going to stick to first solution i wanted from the start. and if dissatisfy about it at some point, then i'm going to change it
03:08:00 <ski> PotatoRick[m] : which was the first solution you wanted from the start ?
03:09:31 <PotatoRick[m]> it seems more elegant to me, since i could easily just add another typeclass constraint for a value constructor instead of invading the datatype with new and new fields
03:10:34 <PotatoRick[m]> i'm not sure, but the first solution is probably is more efficient in context of memory usage
03:11:21 <PotatoRick[m]> ski: first solution is `{-# LANGUAGE ExistentialQuantification #-}` and `data Foo = forall a. (Show a, ToJSON a) => Foo a`
03:12:48 <ski> okay
03:14:52 <tydeu> Is there any way to force a function to have one of n types? For example, `Type -> Type -> Type` or `Exp -> Exp -> Exp`?
03:19:08 <ski> tydeu : type classes is perhaps what you're looking for ?
03:22:53 <tydeu> ski: Unfortunately if a do something like `class Foo t where foo :: t; instance Foo (Type -> Type -> Type) where foo = ...;  instance Foo (Exp -> Exp -> Exp) where foo = ...` and use `foo` like so `foo expA someB`, GHC won't infer that someB and the result of `foo` should be of type `Exp`  because of the potential of future instances
03:24:46 <tydeu> I could use TypeFamilies like `instance (a ~ Exp, b ~ Exp) => (a -> b -> Exp)` or `instance (r ~ Exp) => (Exp -> Exp -> r)`, to help with the inference, but that will only allow me to go one way or the other (i.e. infer the arguments from the result from the arguments), not both (as far as I am aware)
03:25:14 <tydeu> *infer the arguments from the result or the result from the arguments
03:28:33 <tydeu> Essentially what I need to able to do is say that if one of the types is `Exp` use the `Exp` instance and if one of the types is `Type` use the `Type` instance. Otherwise, throw an error.
03:28:57 <ski> tydeu : hm, i was rather having something like `class Foo t where foo :: t -> t -> t', in mind ?
03:32:51 <bifunc2> Is there a ByteString -> Maybe Float function out there? It should return Nothing if either it's not a valid number, or it's too large/requires too much precision that Float can't handle.
03:33:24 <tydeu> ski: hadn't thought of that -- that does work for my example (and for any examples with the same types) -- which works for some of use casess, thanks!
03:33:46 <ski> tydeu : heh, okay :)
03:33:58 <tydeu> bifunc2: I assume you want it to use GHC native Float format?
03:34:26 <tydeu> because their are multiple ways to encode a Float
03:34:30 <bifunc2> tydeu is there any other Float? just the default Float :)
03:34:31 <ski> tydeu : i'm just not quite sure how you could think of doing stuff with `~' like that, without first thinking of what i suggested. the former would seem to me to be more advanced than the latter
03:34:31 <bifunc2> hmm
03:35:23 <bifunc2> I'm not talking binary encoding, sorry for the confusion. I'm  talking about a string like "1.12345" or "43.3e43"
03:35:48 <bifunc2> so "1.123456789123" would fail as it's too much precision for Float
03:37:16 <tydeu> bitfunc2: just any function from any package (or just from the builtin packages)?
03:37:30 <tydeu> *bifunc2
03:37:56 <bifunc2> tydeu well either builtin or some fairly well-known package  on hackage..
03:39:16 <tydeu> bifunc2: well there is there is `readMaybe` so you could do `readMaybe (toString bs) :: Maybe Float`
03:39:53 <bifunc2> tydeu this will parse "1.123456789123" but just  reduce the precision
03:43:31 * hackage free-category 0.0.3.0 - Free category  https://hackage.haskell.org/package/free-category-0.0.3.0 (coot)
03:48:35 <tydeu> bifunc2: the problem you are going to have is that GHC doesn't provide a way to detect Float overflow
03:54:49 <bifunc2> tydeu ok. i'll try to hack  something  together
03:55:17 <bifunc2> such as convert the string  into both Float and Scientific. Then convert the Float into Scientific and see if the diff  between the two Scientifics  are small enough
04:04:20 <tydeu> ski: Do know of a similar trick for a function with types `Name -> Pat -> Pat` or `Exp -> Type -> Exp`?
04:05:23 <jgt> bifunc2: you might want to look at showFixed
04:08:12 <Phillemann> Is anyone using servant with wai-cors? I tried just adding "simpleCors" as a middleware, but OPTIONA is apparently still not supported.
04:08:30 * hackage cgrep 6.6.30 - Command line tool  https://hackage.haskell.org/package/cgrep-6.6.30 (NicolaBonelli)
04:12:48 <Phillemann> Ok, apparently I have to do some mumbo jumbo with the content-type header policy.
04:16:39 <bifunc2> jgt how would you use that here?
04:33:10 <ski> tydeu : `class At t where at :: Name -> t -> t' and `class Ascribe t where ascribe :: t -> Type -> t', maybe ?
04:40:19 <jgt> bifunc2: I'm not sure _exactly_ what you're trying to achieve, but it seemed like you wanted to avoid numbers with scientific notation
04:40:56 <jgt> bifunc2: so I'd read your bytestring as a number, and then specify the degree of accuracy with showFixed
04:42:59 <jgt> but that might not be what you were trying to achieve
04:54:46 <pigmej[m]> Folks whats the opinion about RIO instead base/prelude ? I see that it have some nice features. Is it worth to start new project with RIO instead of Prelude (for a haskell beginner)
04:55:28 <maerwald> for a beginner? no, imo
04:55:48 <maerwald> don't think too much about making wrong decisions, just keep going
04:56:15 <jgt> when I was more of a beginner, I used ClassyPrelude since it was bundled with Yesod. I wish I had used it more instead of the standard Prelude. It would have lead me to ask the question "why doesn't ClassyPrelude have the head function? I just want the first element from this list"
04:56:49 <jgt> but also I agree with maerwald here; don't flirt with the idea of learning Haskell — just get your hands dirty
06:20:09 <sm[m]> pigmej[m]: it’ll be another layer of stuff separating you from the mainstream - it may invalidate stack overflow answers, you’ll have to explain it when you ask for support here, etc. But if you try it, I’d like to know how you get on.
06:20:32 <sm[m]> Are there nice features for beginners in particular ?
06:31:00 <muzzle> hi, So I'm looking at open unions in the fastsum package. Does anyone have an Idea why the 'r' in the Sum type has kind [* -> *] instead of just *
06:35:06 <muzzle> I've already read Oleg Kiselyov's writeup here http://okmij.org/ftp/Haskell/extensible/#open-union but it still doesn't make sense to me...
06:47:55 <catchme> Does haskell provide #define
06:47:55 <catchme> I want to use  `func :: IO [type]` where type is Double or Int and I won't change every occurrence of type
06:48:34 <muzzle> why not just use `func :: Num a => IO a` ?
06:49:11 <muzzle> or rather `func :: Num a => IO [a]` in your case?
06:49:37 <catchme> this is the last line of my function `return ((map read . words) input :: [Integer])` ,so what to do with Int?
06:50:21 <muzzle> in that case it would be `func :: (Num a, Read a) => IO [a]`
06:50:31 <muzzle> and you would have to remove the [Integer]
06:50:47 <hexagoxel> "..Type.hs:789:73: error: Found type wildcard ‘_’ standing for ‘_’"  ahh clever, ghc!
06:50:47 <muzzle> i.e. return ((map read . words) input)
06:51:16 <catchme> muzzle: thanks, I will adopt that
06:51:54 <muzzle> catchme: you don't even need the Num constraint btw :)
06:52:38 <catchme> muzzle: OK, thanks again
07:06:25 <pigmej[m]> Thx for input about rio ;)
07:16:17 <aisn> i'm trying to understand a function with nested lambdas: https://pastebin.ubuntu.com/p/PWX5YwHCSt/  How are "\client" "\input" "\output" arguments injected into it?
07:20:21 <lavalike> aisn: Jack.withClientDefault :: String -> (clienttype -> ..) i.e. the withClientDefault function takes 2 arguments, a string and a function, inside its definition has access to the client (of type clienttype which I don't know) and takes the function you pass to it, and applies the value to the function, thereby "injecting" as you say
07:25:04 <aisn> does this ever become easy to read?
07:25:18 <fendor> aisn, yes :)
07:25:23 <aisn> if i don't see some haskell code for a few weeks it bends my mind every time 
07:25:57 <fendor> I suppose, that's how it is with many languages that are not von-neumann languages.
07:27:34 <monochrom> It reads like math so it's easy to read for me.
07:28:45 <merijn> aisn: Bracket patterns like this are super common in Haskell code, so yes, you do get used to it
07:32:00 <aisn> i feel if i'm writing my own haskell code, i usually default to using it as a more standart language and if i read books, they have short specific examples that do not get cemented in my head, so i never quite get the flow of common haskell paradigms
07:32:46 <aisn> i guess is should read more source code 
07:32:56 <aisn> from various projects
07:33:37 <monochrom> People who comfort you with "no no you don't need math for haskell don't worry" are wrong. You need the math aptitude.
07:34:01 <merijn> aisn: brackets like that are usually to enforce safe resource allocation. Imagine you want to do "do { x <- allocateFoo; doStuffWith x; freeFoo x }", that works fine in the simple case, but what if "doStuffWith" throws an exception? Or worse, what if you're using multiple threads and throw asynchronous exceptions during the allocation of 'x'?
07:35:39 <merijn> aisn: So we have "bracket" (from Control.Exception) which blocks async exceptions during allocation and freeing and installs the necessary exception handlers to ensure the cleanup runs even if doWithStuff throws an exception (i.e. kinda like "try { ... } finally { ... }" in other languages
07:35:44 <fendor> monochrom, idk, i wouldnt say you need it as an application programmer.  
07:36:27 <merijn> aisn: Often times people write their own application/library specific brackets to handle similar scenarios (perhaps even using bracket underneath)
07:36:46 <aisn> monochrom: i'm not really avoiding math, if i can learn more of it, i would love to
07:37:23 <merijn> Note that monochrom didn't say you need actual math, merely the skillset you need for math and Haskell are the same/similar :)
07:37:40 <monochrom> aptitude != knowledge
07:37:46 <mycroftiv> i think also that haskell is an amazing way to build math fluency
07:37:59 <fendor> aah. I see. 
07:38:04 <merijn> mycroftiv: tbh, I think that's only true for certain subsets of math
07:38:34 <mycroftiv> im using it right now mostly to explore a mathematical domain, by just writing functions to express my ideas and then i can run the code and find out if im understanding things correctly - and im sure some domains are more or less suited
07:38:58 <merijn> So studying math helps you learn haskell, not because you learned math, but because you'll have practiced modes of thinking that will help you with haskell too
07:40:43 <mycroftiv> i think there are several aspects to this. there are certain fundamental ideas shared between 'general math' and most programming, haskell included. there is also specific mathematical content in functional programming and haskell's implementation thereof.
07:40:56 <mycroftiv> and then there is mathematical thinking and logical patterns in general - and all of these play into the specifics
07:42:31 <aisn> are there any particular areas in math that are better for sharpening you haskell wits?
07:42:38 <aisn> your*
07:42:41 <mycroftiv> lmabda calculus
07:42:53 <mycroftiv> type theory
07:42:57 <mycroftiv> argh, lambda
07:43:17 <mycroftiv> recursive algorithms
07:43:54 <aisn> by type theory, do you mean category theory?
07:43:57 <merijn> Also, just writing lots of Haskell and playing around with things
07:43:58 <merijn> aisn: No
07:44:24 <merijn> aisn: I would say that category theory has a very low/bad ROI for Haskell beginners
07:44:45 <mycroftiv> i agree, i havent needed to study any 'real' category theory at all to feel like im making good progress
07:44:46 <monochrom> Type theory is when you treat types as sentences, terms as proofs
07:46:32 <merijn> aisn: I know there's this meme going on about Haskell being based on category theory, but that's objectively nonsense. Category theory is super fascinating stuff, but also super abstract and therefore super confusing and intimidating. There are more useful things to study if the goal is "becoming better at Haskell" (if the goal is "CT sounds interesting and I'm curious, then sure, knock yourself out)
07:47:09 <monochrom> category theory : haskell :: ring theory : accounting
07:47:30 <aisn> :)
07:50:47 <monochrom> There is a double-standard there.  Accounting uses the commutative, associative, and distributive laws all the time, and somehow no one asks them "do you need ring theory?".
07:52:49 <monochrom> People simply scaremonger everything they're unfamiliar with.
07:56:43 <merijn> aisn: Incidentally, while I like type theory in think more should people should study it (and it's one of the things that most directly contributes to a better fundamental understanding of Haskell), I think even that's probably not as good a method of getting better at Haskell than just "writing more haskell" ;)
07:59:20 <aisn> i will keep that in mind, thanks
07:59:30 <lavalike> @remember monochrom category theory : haskell :: ring theory : accounting
07:59:30 <lambdabot> It is forever etched in my memory.
07:59:55 <mycroftiv> i agree and also i should really have framed it as type systems more than type theory, and in particular the haskell type system and the standard set of provided types
08:02:40 <merijn> aisn: For what it's worth, the way that code you linked is layouted is confusing and I'm not sure if it even parses without an extension that makes the layout less strict
08:03:34 <aisn> i don't really need to understand it, but i was curious how the library that i want to use works
08:03:54 <aisn> i'm now playing around with my midi keyboard and haskell
08:04:00 <merijn> aisn: If you indent to properly mimic the scope you'd get https://pastebin.ubuntu.com/p/syt5QFkb6Y/
08:04:41 <merijn> Which is obviously more annoying the way it marches of to the right, but it does properly show that every lambda there contains everything following inside its body
08:05:06 * homebeach[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/zEuWsYZPRWopmHtvelosAMlz >
08:05:20 <homebeach[m]> I keep getting this. What am I doing wrong?
08:05:20 <merijn> i.e. the "withPort" stuff isn't happening "after" withClientDefault, it's happening *inside* the lambda you're passing to withClientDefault
08:05:33 <aisn> i think i already understand it 
08:05:57 <aisn> i found that those functions were composed with these particular arguments
08:06:44 <aisn> i just needed a bit of a push, which i got here
08:06:50 <merijn> homebeach[m]: Honestly, almost everything? I'm a bit confused how you expect that code to parse or even work?
08:07:42 <merijn> homebeach[m]: Are you expecting it to magic an 'a' and 'b' variable from thin air and exhaustively try and solve those equations? That's far from what list comprehensions do
08:16:31 <homebeach[m]> Do I have to define value ranges for a and b?
08:17:27 <merijn> homebeach[m]: Which book/material are you using? Because you probably want to revisit the part on list comprehensions to see what sorta things are allowed within them
08:18:20 <homebeach[m]> I have been studying this: http://learnyouahaskell.com
08:43:24 <mycroftiv> homebeach[m]: here is a bit of code by oleg kiselyov that is a nice framework for rule based searches, and works on infinite lists too, with your logic as an example: http://wiki.9gridchan.org/incoming/mycro/homebeach.hs
08:43:45 <merijn> ...
08:44:24 <merijn> I'm not sure linking Oleg's code to people struggle with the basics is particularly helpful...especially if said code involves lots of use of Cont
08:45:02 <homebeach[m]> ok thanks I take a look at it
08:45:04 <mycroftiv> well, i thought maybe he wanted to do that particular thing, to see how it might work
08:45:53 <mycroftiv> homebeach: i dont recommend you try to write code exactly like that, but that is a piece of code you could use as a kind of 'library' for searches of this type
08:46:36 <homebeach[m]> ok I just started studying haskell so there is plenty for me to learn about it
08:47:54 <mycroftiv> homebeach: i myself am still working on understanding everything that goes into that style of code, its 'aspirational' to me as well, i find what haskell can do to be exciting 
08:55:04 <dmwit> homebeach[m]: Yes, you have to define value ranges for a and b.
08:56:02 <dmwit> homebeach[m]: Perhaps you intended something like this instead:
08:56:34 <dmwit> > let manhattan x = [(a,b) | a <- [0..x], b <- [0..x]] in manhattan 3
08:56:36 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3,...
08:56:50 <dmwit> (Then again perhaps not.)
08:56:58 <nshepperd> the best area of math to study to get better at Haskell is Haskell
09:26:30 <muzzle> Hi
09:46:08 <higherorder> Hello; quick question: would you make validation errors (things you return as the left side of an Either in functions dealing with user inputs) instances of Control.Exception? (to get hierarchy, etc)
09:47:22 <muzzle> hi, is there anyone here who can help me understand some stuff about open unions?
09:53:30 <dmwit> higherorder: I do that pretty rarely.
09:53:47 <higherorder> dmwit: what prompts you to do it when you do?
09:54:31 <dmwit> Wanting to run my validator in a context provided by some outside API that needs it. =P
09:54:52 <dmwit> (e.g. a thing which requires a plain-IO callback or similar)
09:55:30 <dmwit> muzzle: It's probably better to just ask your question.
09:55:33 <dmwit> ?where justask
09:55:33 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
09:56:00 <muzzle> dmwit: So in the fastsum implementation why is the set of types that can be in the Union of kind "* -> *"
09:56:04 <muzzle> and not simply *
09:56:14 <muzzle> as well in some other implementations as far as i can tell
09:57:09 <muzzle> I guess it has to do with some sort of typesystem constraint but I can't understand what that is?
09:57:46 <higherorder> dmwit: oh ok! and do you ever need to handle a hierarchy of validation exceptions? 
09:58:07 <higherorder> e.g. defining some validation errors in a "core" lib, then extend that in projects that use that lib
09:58:52 <dmwit> higherorder: Sure. Plain old ADTs work fine for that in almost all cases I've encountered.
09:59:32 <dmwit> e.g. `data ParserValidationError = MismatchedBrackets LineNumber | IndentationError LineNumber | LexerError LexerError` to embed lexer problems in the parser error type.
10:00:04 <dmwit> Parameterize the contained type if necessary.
10:04:36 <higherorder> dmwit: ah, ty! do you think a type like `data CoreValidationError a = Foo | Bar | Other a` would make sense? to allow a project using the "core" library to provide its own validation errors
10:07:36 <dmwit> Seems sensible to me.
10:07:59 <dmwit> There's always a question of which "direction" dependencies like this go.
10:08:13 <dmwit> I'm not sure I have a good rule of thumb to help you decide on that.
10:08:52 <higherorder> dmwit: alright; thanks :)
10:21:18 <glittershark> Is anyone aware of any template-haskell macros for including entire directories at compile time?
10:21:34 <glittershark> looking for basically something like https://docs.rs/include_dir/0.2.1/include_dir/
10:22:30 * hackage red-black-record 2.1.0.0 - Extensible records and variants indexed by a type-level Red-Black tree.  https://hackage.haskell.org/package/red-black-record-2.1.0.0 (DanielDiazCarrete)
10:22:48 <glittershark> nvm, google-fu finally paid off: http://hackage.haskell.org/package/file-embed-0.0.11/docs/Data-FileEmbed.html
10:22:58 <glittershark> that was surprisingly hard to find >.>
10:25:31 * hackage red-black-record 2.1.0.1 - Extensible records and variants indexed by a type-level Red-Black tree.  https://hackage.haskell.org/package/red-black-record-2.1.0.1 (DanielDiazCarrete)
10:26:08 <hololeap> glittershark: do you know about hoogle?
10:33:34 <homebeach[m]> ok if I define c <- [0..], it can be zero and above but how can I define it to be also negative?
10:35:28 <cocreature> homebeach[m]: what’s the exact list that you want to generate?
10:36:03 <homebeach[m]> manhattan :: Int -> [(Int,Int)]
10:36:04 <homebeach[m]> manhattan x = [ (a,b) | a <- [0..], b <- [0..], a + b <= x ]
10:36:24 <EvanR> [..., -2, -1, 0, 1, ...]
10:36:28 <homebeach[m]> This is the current program
10:37:30 <EvanR> you could construct a zipper at 0 which goes up by 1 infinitely in one way and down 1 infinitely in the other
10:38:45 <cocreature> it looks like you want to explore all numbers so something like [0,1,-1,2,-2,…] might be what you’re looking for
10:39:34 <cocreature> > 0 : concat $ zipWith (\x y -> [x,y]) [1..] [-1,-2..]
10:39:36 <lambdabot>  error:
10:39:36 <lambdabot>      • Couldn't match expected type ‘[[Integer]] -> t’
10:39:36 <lambdabot>                    with actual type ‘[Integer]’
10:39:58 <cocreature> > 0 : concat (zipWith (\x y -> [x,y]) [1..] [-1,-2..])
10:40:00 <lambdabot>  [0,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13,...
10:40:08 <dmwit> homebeach[m]: And what result do you want instead of what you're getting?
10:40:27 <dmwit> Say, for `manhattan 0` to keep it nice and small.
10:40:41 <dmwit> Or `manhattan 1` if you already get what you want for `manhattan 0`, or etc.
10:41:26 <homebeach[m]> it should contain also the list of negative values that have distance from 0 smaller than x
10:41:59 <dmwit> homebeach[m]: You could consider doing a little bit of algebra to figure out what the right bounds for `b` are once you know `a`.
10:42:16 <dmwit> (And what the right bounds for `a` are in the first place.)
10:42:21 <dmwit> So that you are never drawing from infinite lists.
10:43:28 <homebeach[m]> <homebeach[m] "it should contain also the list "> actually the list of values where a+b<x
10:43:29 <dmwit> (N.B. the correct condition is `abs a + abs b <= x`, not `a+b <= x`)
10:43:46 <dmwit> (If you are doing what I think you are doing, anyway.)
10:57:30 * hackage sbv 8.4 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  https://hackage.haskell.org/package/sbv-8.4 (LeventErkok)
11:31:50 <buhman> I'm using haskell-interactive on emacs, and when I do any multiline repl entry, the prompt breaks, printing Some flags have not been recognized: prompt2, 
11:32:30 * hackage set-cover 0.1 - Solve exact set cover problems like Sudoku, 8 Queens, Soma Cube, Tetris Cube  https://hackage.haskell.org/package/set-cover-0.1 (HenningThielemann)
11:32:46 <buhman> I read somewhere that prompt2 was renamed to prompt-cont. has anyone else encountered/fixed this?
12:16:25 * ski for a moment thought muzzle was talking about topology
12:17:51 <MarcelineVQ> buhman: I don't use that plugin but it is correct that prompt2 was renamed to prompt-cont
13:01:30 * hackage tweet-hs 1.0.2.1 - Command-line tool for twitter  https://hackage.haskell.org/package/tweet-hs-1.0.2.1 (vmchale)
13:30:00 * hackage frotate 0.1.0 - Advanced rotation of backups and other things  https://hackage.haskell.org/package/frotate-0.1.0 (ip1981)
13:31:30 * hackage net-mqtt 0.2.4.2 - An MQTT Protocol Implementation.  https://hackage.haskell.org/package/net-mqtt-0.2.4.2 (dustin)
13:32:45 <homebeach[m]> I should make a program that gets list of strings and I need to see if they contain a character. Is there any good example of iterating trough list of strings? This should be probably done with recursion?
13:33:33 <Rembane> homebeach[m]: Are you allowed to use higher order functions, or are you going to use recursion?
13:35:50 <homebeach[m]> I guess I can use those
13:36:22 <homebeach[m]> But what is the best way handling strings in string list? 
13:39:15 <Rembane> homebeach[m]: Treat them as lists containing characters. 
14:00:00 * hackage graphql-w-persistent 0.6.0.0 - GraphQL interface middleware for (SQL) databases.  https://hackage.haskell.org/package/graphql-w-persistent-0.6.0.0 (jasonsychau)
14:19:39 <Nolrai> So I want an Exp a be an a, or a F a, or G a, or an F (G a) or a G (F a) or a F (G (F a))..but not an F (F a) or an F (G (G (F a))); is there a reasonable way to do this?
14:20:10 <Nolrai> I probably should have used "t" instead of "a".
14:23:55 <Nolrai> Err..actually I also always want at least one layer of F and one of G..I already have a normalization problem dealing with singletons so maybe I just normalize away F (F a) -> F a and G (G a) -> a? 
14:24:58 <Nolrai> But kind of the whole point of not using a binary tree is removing as many semantically invisible differences as posible.
14:26:52 <Nolrai> (I need to keep F(G(F a)) terms as distinct from just G(F a) terms..)
14:27:44 <tn5421> When I went to install the packages for haskell on manjaro, pacman told me the package 'haddock' could not be found.  I was able to find it by it's long name 'haskell-haddock-library'.
14:35:52 <Nolrai> Seems pretty quiet on here.
14:38:33 <[exa]> Nolrai: weekend mood
14:39:33 <MartinKlimi[m]> Sleeep~
14:39:39 <koz_> Sleep(1)
14:40:07 <[exa]> Nolrai: btw Exp is a class and these are instances?
14:46:24 <Nolrai> Exp is an datatype, and those are .."cases" I guess?
14:55:03 <dmwit> Nolrai: `data ExpHelper f g a = Leaf a | Branch (f (ExpHelper g f a)); newtype Exp a = Exp (Either (ExpHelper F G a) (ExpHelper G F a))`?
14:55:59 <dmwit> (Just to get the simplest possible thing out there to complain about, you know?)
14:57:23 <ski> Nolrai : sounds like a swaplist, but for composition
14:58:39 <koz_> ski: What's a swaplist?
14:59:01 <ski>   data SwapList a b = Nil | Cons a (SwapList b a)  -- an irregular data type, because the recursion isn't on the same parameters, in the same order
14:59:11 <koz_> Ah, I see what you mean.
14:59:26 <koz_> So it's a sequence of alternating a and b?
14:59:31 <ski>   type SymmSwapList a b = Either (SwapList a b) (SwapList b a)
14:59:35 <ski> yes
15:00:50 <no-n> [Nothing, Nothing, Nothing, Just 1, Just 2, Just 3]
15:00:55 <no-n> How do I get the first Just value?
15:01:09 <dmwit> catMaybes, perhaps
15:01:24 <no-n> :t catMaybes
15:01:25 <lambdabot> [Maybe a] -> [a]
15:01:32 <no-n> ta
15:02:39 <dmwit> :t foldMap (foldMap pure)
15:02:41 <lambdabot> (Monoid (f a), Foldable t1, Foldable t2, Applicative f) => t1 (t2 a) -> f a
15:02:49 <ski> > (getFirst . mconcat . map First) [Nothing,Nothing,Nothing,Just 0,Just 1,Just 2]  -- no-n
15:02:51 <lambdabot>  Just 0
15:03:23 <no-n> > (getFirst . mconcat . map First) [Nothing, Nothing]
15:03:26 <lambdabot>  Nothing
15:03:30 <no-n> ski, nice
15:05:04 <dmwit> > (listToMaybe . catMaybes) [Nothing, Nothing, Nothing, Just 0, Just 1, Just 2]
15:05:07 <lambdabot>  Just 0
15:05:53 <no-n> > listToMaybe . catMaybes $ [Nothing]
15:05:57 <lambdabot>  Nothing
15:06:04 <dmwit> > foldMap (foldMap pure) [Nothing, Nothing, Nothing, Just 0, Just 1, Just 2] :: First Int
15:06:05 <no-n> > listToMaybe . catMaybes $  []
15:06:07 <lambdabot>  First {getFirst = Just 0}
15:06:08 <lambdabot>  Nothing
15:06:18 <dmwit> Whoops, sorry for the cross-talk on that last example.
15:07:03 <no-n> thx
15:07:26 <dmwit> There are many ways to skin this cat. But ski's is probably best, because it needs the least allocation, and can be modified to need none at all.
15:07:28 <homebeach[m]> Prelude> firstorlast [xs] y = [ x | x <- xs, head x == y || last x == y]
15:07:29 <homebeach[m]> <interactive>:13:20: parse error on input ‘=’
15:07:46 <homebeach[m]> I get error but do you think this function makes any sense?
15:08:30 <dmwit> It makes sense, but almost certainly doesn't do what you think it does.
15:09:02 <homebeach[m]> You should be able to give list of strings and a character and it should give you back those strings from the list that have that given character as head or last
15:09:10 <dmwit> It does not do that.
15:10:36 <homebeach[m]> firstorlast [xs] y = [ x | x <- xs, head xs == y || last xs == y]
15:10:44 <homebeach[m]> this is better
15:11:01 <dmwit> Looks identical to me.
15:12:32 <koz_> For something like newtype SizedVec (n :: Nat) a = SizedVec (Vector a), what role does the n parameter have?
15:12:37 <homebeach[m]> list of strings [xs], character y as input and x is xs if y is head or last of xs
15:12:39 <dmwit> Oh, I see what you changed now. No, the problem is that the pattern `[xs]` matches only singleton lists.
15:12:52 <koz_> I _guess_ phantom?
15:13:06 <dmwit> You don't need some special sigil to receive a list or something. (This seems to be a very common misconception, and I really don't understand where it comes from.)
15:13:13 <koz_> dmwit: Perl maybe?
15:13:19 <dmwit> koz_: Yes, phantom.
15:13:51 <koz_> OK, now suppose I did something like 'newtype Foo (n :: Nat) (a :: Type) = Foo (SizedVec n Bool)'? What's the role for n there?
15:14:00 <koz_> I'm guessing it's no longer phantom then?
15:14:03 <dmwit> koz_: Does Perl have some special name rules that variables must use if they are of some specific type?
15:14:16 <koz_> dmwit: You have sigils to indicate how something should be treated.
15:14:30 <koz_> Like, is this a collection of values, or just one thing, or w/e.
15:14:32 <dmwit> koz_: Both n and a are phantom there.
15:14:40 <koz_> Ah, that's interesting.
15:14:46 <koz_> I wasn't sure how the rules interacted there.
15:15:09 <koz_> I knew 'a' was phantom in that case, but wasn't sure about 'n'.
15:16:18 <dmwit> Well. The true rule is that by default it gives the same role to n as SizedVec gives it. It could be different if either of the types gave explicit role annotations.
15:16:49 <dmwit> ("either of the types" here scopes over SizedVec and Foo)
15:17:26 <koz_> dmwit: Yeah, I was asking under the assumption role annotations don't 'force' it into something less permissive.
15:17:32 <koz_> (should ahve made that more clear)
15:26:19 <homebeach[m]> Can you give example how to give string list and character as input for function properly?
15:28:26 <dmwit> firstorlast xs y = ...
15:30:08 <koz_> :t foldM_
15:30:09 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m ()
15:30:17 * koz_ can _never_ remember the order of those.
15:31:24 <hyperisco> You mean whether it is  b a  or  a b ?
15:31:40 <MarcelineVQ> homebeach[m]: they're not special so it'd be good to see what you have tried
15:32:00 <koz_> hyperisco: That, and whether the 'starting point' or the function comes first.
15:32:22 <hyperisco> The latter is the same for all folds. I hope.
15:32:42 <koz_> hyperisco: It is, but I _still_ can't remember it.
15:32:57 <koz_> Which is bizarre, because traverse_ is totally unforgettable for me somehow.
15:35:30 * hackage frotate 0.1.1 - Advanced rotation of backups and other things  https://hackage.haskell.org/package/frotate-0.1.1 (ip1981)
15:35:55 <homebeach[m]> <MarcelineVQ "homebeach: they're not special s"> Prelude> firstorlast xs y = [ x | x <- xs, head xs == y || last xs == y]
16:08:12 <RB`> :t sequence
16:08:14 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
16:08:57 <RB`> :t traverse
16:08:59 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
16:49:08 * dmwit . o O ( threadDelay :: Micro -> IO () )
16:49:46 <dmwit> It just makes too much sense.
16:50:04 <koz_> dmwit: Is there some equivalent to that somewhere, and if so, what is its type?
16:50:15 <dmwit> "equivalent"?
16:50:15 <jle`> dmwit: one can dream
16:50:20 <koz_> Hi jle`!
16:50:35 <jle`> koz_: hi :)
16:51:00 <dmwit> I'm assuming you already know about `threadDelay :: Int -> IO ()`? If not, that's certainly the answer to your question.
16:51:06 <dmwit> If so, then I'm not sure I know what the question even is.
16:52:09 <jle`> implementing the Micro version is not super trivial as you have to account for the fact that Micro can represent times longer than maxBound :: Int
16:52:22 * dmwit nods agreeably
16:52:26 <koz_> dmwit: I did not, so thanks!
16:52:26 <jle`> but it'd be nice to have it in base
16:52:55 <dmwit> http://hackage.haskell.org/package/unbounded-delays-0.1.1.0/docs/Control-Concurrent-Thread-Delay.html
16:53:05 <koz_> dmwit: TIL.
16:54:51 <dmwit> Probably better to check how long has passed at each maxBound iteration and subtract that rather than always subtracting maxBound, but... probably won't make much of a difference if you're actually trying to wait more than 2^64 microseconds... =P
16:56:04 * dmwit sits down for a cool 300 kiloyears, then complains about waking up 300 kiloyears + 10ms later
16:56:05 <koz_> That's like... how many years?
16:56:19 <koz_> Lol, just saw the '300 kiloyears'.
16:56:29 <dmwit> I always feel so disoriented when I oversleep my alarm like this.
16:56:48 <koz_> dmwit is, apparently, a highly punctual and organized immortal.
16:57:42 <dmwit> To be fair, on 32-bit machines, maxBound is only a bit over half an hour.
16:57:43 <jle`> @let maxMicro :: Micro; maxMicro = MkFixed (fromIntegral (maxBound :: Int))
16:57:45 <lambdabot>  Defined.
16:57:50 <jle`> maxMicro
16:57:54 <jle`> > maxMicro
16:57:57 <lambdabot>  9223372036854.775807
16:58:17 <dmwit> So it might actually be reasonable to worry about going off a few ms every hour, I dunno.
16:58:29 <dmwit> Can't think of a place where I'd care about that level of precision, but it might exist.
16:58:58 <dmwit> > maxMicro / 60 / 60 / 365
16:59:01 <lambdabot>  7019309.008260
16:59:11 <jle`> > maxMicro / 60 / 60 / 365.25
16:59:14 <lambdabot>  7014504.553087
16:59:17 <dmwit> > maxMicro / 60 / 60 / 24 / 365.25
16:59:20 <lambdabot>  292271.023045
16:59:33 <dmwit> There's my 300 kiloyears figure. ^_^
17:00:04 <jle`> > maxMicro / 60 / 60 / 24 / 365.2422
17:00:07 <lambdabot>  292277.264695
17:00:23 <koz_> I don't think I've ever heard that SI prefix used with _years_ before.
17:01:43 <jle`> i first heard it a few microyears ago
17:02:18 <koz_> Micro is 1/10^3?
17:02:31 <koz_> Or am I off by an order of magnitude or so?
17:02:59 <jle`> that's milli
17:03:33 <jle`> my own personal trick is that it's μ for μillionth
17:03:54 <koz_> So micro is 1/10^6?
17:04:04 * hackage ghc-source-gen 0.2 - Constructs Haskell syntax trees for the GHC API.  https://hackage.haskell.org/package/ghc-source-gen-0.2 (JudahJacobson)
17:04:11 <jle`> fun fact, 1 μyr is equivalent to about 31.54 Joules per Watt
17:04:24 <koz_> What's a yr?
17:04:35 <jle`> year :)
17:04:43 <koz_> Wait, how?
17:04:50 <jle`> it's a common abbreviation
17:05:04 <jle`> at least in scientific contexts i think
17:05:11 <koz_> No no, I mean, how did you get the timespan to energy per power conversion?
17:05:50 <jle`> energy per power has dimensions of time
17:06:10 <jle`> since power is [E]/[T], and so [[E]/([E]/[T])] = [T]
17:06:18 <koz_> Ah, I see.
17:06:43 <koz_> It's kinda like why specific impulse is measured in seconds, right?
17:07:31 <jle`> yeah, dimensions can be funny
17:07:56 <koz_> Because specific impulse is something like newtons per second per newton right?
17:08:37 <dmwit> My favorite example is the one Randall Munroe wrote about in a What If article: gas mileage has units of area, which you can picture as the cross-sectional size of the tube of gas you'd get spreading the gas out over the distance you traveled.
17:09:04 <koz_> dmwit: Gas mileage as in, miles per gallon, right?
17:09:14 <dmwit> Well, gallons per mile, as is sane.
17:09:29 <koz_> OK, yeah, put that way it makes more sense.
17:10:48 <dmwit> (Nobody goes, "Hey, I've got 5 gallons of gas, let's find something 100 miles from here to go to!". They say, "Hey, I want to go to thing X which is 100 miles away. How much gas do I need for that?". So "gallons per mile" is the right unit, because multiplication is Better than division.)
17:11:41 <jle`> i suppose it makes sense at the point of purchase of gas.  someone says "i'll sell you ten gallons" and you think "what good is ten gallons of gas to me?"
17:12:07 <jle`> but yes usually the amount someone sells is flexible, not the distance you need to go
17:12:39 <jle`> maybe MPG was chosen because the numbers felt bigger, so better for advertising
17:12:52 <hpc> or because people suck at fractions
17:13:12 <hpc> a good story i heard once, mcdonalds tried to sell a third-pounder for people who wanted more than a quarter-pounder
17:13:19 <jle`> that too. whole numbers are easier to work with
17:13:19 <hpc> but people kept thinking it was less food because 3 < 4
17:13:23 <jle`> heh
17:13:48 <jle`> sounds like the people who wonder why they would pay more for a large pizza if the medium pizza has the same number of slices
17:14:15 <hpc> i'll admit, i still get fooled occasionally by pizza sizes
17:14:25 <hpc> because they give the size in diameter but what really matters is surface area
17:15:11 <jle`> i feel like it would be advantageous to sell by area, not by diameter
17:15:30 <jle`> but then again the cost of making a pizza doesn't scale by area
17:15:42 <jle`> even though the amount consumed (and therefore material benefit) is
17:15:45 <EvanR> unfortunately a pizza r not square
17:18:36 <jle`> the physical interpretation of N Joules per Watt is probably the time taken to transfer N joules at a rate of one Watt 
17:18:47 <jle`> so now instead of saying seconds i'll just give my times in J/W
17:19:07 <jle`> the conversion is simple enough
17:20:15 <jle`> and 1 J/W is actually useful enough to use in daily life, as opposed to other weird things you get by combining units arbitrarily
17:20:27 <jle`> (it is a decent size/duration to describe human experiences)
17:21:18 <dmwit> https://youtu.be/lffshg6mxn0
17:22:06 <dmwit> Obviously the correct unit for pizza is volume, not area.
17:22:43 <DrAwesomeClaws> pizza has the best fpi 
17:23:22 <dmwit> (flavor per inch?)
17:23:30 <DrAwesomeClaws> food programmer interface 
17:23:48 <jle`> it has decent FTP as well
17:24:11 <jle`> at least for the major distributors
17:25:09 <dmwit> (foodenosine triphosphate?)
17:25:25 <jle`> koz_: have you tried configuring vector-sized with --allow-newer? it looks like the main configuration issue is the tight bounds for indexed-list-literals
17:25:37 <jle`> dmwit: i was going for Food Transfer Protocol
17:26:16 <jle`> koz_: it would be interesting to see if it builds at all with new base
17:36:56 <koz_> jle`: I can try right now?
17:38:55 <hpc> dmwit: only deep dish is measured by volume :D
17:39:06 <koz_> jle`: With --allow-newer, I get a successful build.
17:39:13 <jle`> koz_: hooray :D
17:39:23 <koz_> I'll add it to the issue I opened.
17:39:24 <jle`> it looks like the only problem is indexed-list-literal's tight version bounds
17:39:32 <koz_> Should we prod them about it then?
17:40:40 <jle`> yeah, there's nothing vector-sized can do. but you can send in a PR to indexed-list-literals that just bumps base >=4.9 && <4.14 to make it easier for them
17:40:47 <jle`> alternatively they can just changed the hackage metadata
17:40:50 <koz_> I'll do that, and reference the issue.
17:41:15 <jle`> but for if you want to use it in a project you can add --allow-newer temporarily
17:41:22 <jle`> oh boy i wonder how many of my packages are broken for 8.8
17:41:32 <koz_> I'm OK for now, just found it while testing with GHC 8.8.
17:42:08 <jle`> a lot of my travis builds break for 8.8 but i'm just assuming those are from transitive deps
17:42:31 <jle`> well, wishful thinking heh
17:43:39 <koz_> OK, and done.
17:44:02 <jle`> nice :) really appreciate it btw!
17:44:14 <koz_> We should probably add GHC 8.8 to the CI for vector-sized.
17:44:20 <koz_> I'd do it myself, but I have no idea how.
17:44:38 <jle`> oh heh looks like I did this for 8.6 about a year ago
17:44:41 <jle`> https://github.com/DavidM-D/indexed-list-literals/pull/8
17:44:46 <koz_> LOL
17:44:53 <koz_> I guess you're less lazy than I am.
17:44:58 <koz_> I just leave an issue and move on.
17:45:02 <koz_> (and wait)
17:45:23 <jle`> not trying to say you are lazy or anything haha :) just found it funny that this felt really familiar for some reason, and just realized why
17:45:50 <koz_> Well, to be fair, it's not like everyone goes 'Hey, new GHC, let's test if everything of mine works with it'.
17:46:24 <jle`> well if you put strict upper bounds on base, it's sort of assumed that you are expecting to test it when new ghc comes out. otherwise you would just leave it < 5 or something
17:46:46 <koz_> True.
17:48:08 <jle`> unless there's another reason i don't know about
17:56:13 <koz_> OK, this is weird. cabal new-build is rejecting ghc-typelits-knownnat, without telling me why.
17:57:07 <jle`> if you're using cabal-install-3.0, i think it's just cabal build now maybe? if that makes a difference
17:57:26 <koz_> Nope.
17:57:32 <koz_> (but good to know all the same)
17:58:27 <koz_> jle`: https://gist.github.com/kozross/0fc7eebaafa24ae552d28cb9715fd914 is all I get.
17:58:53 <koz_> I'm not using 8.8 for this.
18:00:29 <lie1023> Hello all, how would I structure a function that returns the handle (second argument) from the tuple returned from System.Process.createProcess? I'm having trouble with purifying the tuple.
18:01:08 <koz_> lie1023: What do you mean by 'purifying'?
18:01:12 <dmwit> Can't purify.
18:01:13 <koz_> That tuple comes back in IO.
18:01:27 <jle`> lie1023: you can pattern match on the result to bind the second argument
18:01:30 <koz_> <boromir>One does not simply... purify IO.</boromir>
18:01:32 <dmwit> But that's okay. There's no pure consumers of handles anyway; they all do IO.
18:01:43 <dmwit> So it's okay to force consumers of the handle to live in IO.
18:02:10 <jle`> lie1023: there's actually an example on how to 'access' the second item at the top of the documentation
18:02:24 <dmwit> :t (>>=) -- the canonical way to pass an IO-computed value to a function which expects just the value, but does IO on it
18:02:28 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:03:29 <lie1023> So I should be able to run `createProcess(...) >>= \x -> snd x`
18:03:35 <lie1023> To get a value of type Handle?
18:03:40 <dmwit> No.
18:03:48 <dmwit> That still returns a value of type IO Handle, if it even works.
18:03:49 <DrAwesomeClaws> monads, mo problems 
18:04:03 <lie1023> That's where I'm having trouble
18:04:06 <jle`> lie1023: remember the bigger context of what you are trying to do
18:04:12 <jle`> what do you want to *do* with the handle?
18:04:12 <dmwit> But that's okay: if you have any function which accepts a Handle, you can pass the value computed by the IO Handle computation to it with (>>=).
18:05:00 <jle`> lie1023: remember that IO actions describe what IO you want to do
18:05:06 <dmwit> So, e.g., you couldn't `hPutStrLn (createProcess ...) "hi!"`.
18:05:15 <jle`> they don't actually 'perform' any IO
18:05:27 <jle`> lie1023: what do you want to do with the handle value?
18:05:41 <lie1023> I would like to return it
18:05:48 <jle`> you can write a function `doMystuff :: BlahBlah -> IO Handle` to be an IO action that returns a handle
18:05:51 <dmwit> Because `hPutStrLn` expects a `Handle`, but `createProcess ...` creates an `IO Handle`. But you could `createProcess ... >>= \h hPutStrLn h "hi!"`.
18:06:09 <dmwit> lie1023: Too bad. You can't return it. Come up with a different plan.
18:06:14 <jle`> doMyStuff = do ...; (_, Just hout, _ _) <- createProcess ...; return hout
18:06:15 <dmwit> (We are outlining the usual plan here for you...)
18:06:25 <jle`> ^ that's how you would return it in IO, for doMyStuff :: BlahBlah -> IO Handle
18:06:54 <lie1023> Okay. Thank you all very much for the clarification. Have a good one.
18:06:59 <jle`> `doMyStuff inps` would describe an IO action that produces a handle 
18:07:40 <dmwit> (Whoops, typo: I meant `\h -> hPutStrLn ...`, not `\h hPutStrLn ...`!)
18:08:06 <dmwit> lie1023: You might also like sigfpe's "The IO Monad for People Who Simply Don't Care".
18:08:13 <dmwit> http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html
18:08:48 <veryjos> can u still not uninstall packages with cabal
18:08:54 <veryjos> i'm new to haskell and i'm reading that, but everything i see is from 2015
18:09:37 <dmwit> You can still not uninstall packages with cabal.
18:09:37 <jle`> 'uninstalling' an executable would be just deleting it from the folder where cabal puts it
18:13:00 <lyxia> doesn't cabal still think you have it installed?
18:13:26 <lyxia> and might you not still want to uninstall libraries??
18:13:27 <sclv> cabal doesn't track what exes are installed
18:13:35 <sclv> for libs, yeah, don't delete them
18:13:51 <sclv> the way you "uninstall" them can be deleting them, along with calling ghc-pkg unregister
18:13:57 <sclv> which removes them from the pkg directory
18:14:53 <lyxia> why is there no "uninstall" command
18:15:47 <dmwit> delete+unregister is a really unsatisfying answer. It's a really good way to break things that depend on that package.
18:16:04 <dmwit> It also has no hope of doing the "and also remove dependencies that were only installed because I wanted that" thing that most package managers do.
18:16:20 <dmwit> lyxia: Nobody needs it enough to write it, it seems.
18:16:57 <dmwit> There's no technical reason it can't be done.
18:19:35 <lyxia> so, business as usual (not enough manpower). I was somehow hoping that the answer would be that "uninstall" is a broken concept or something
18:19:50 <sclv> well there's a related answer
18:20:02 <sclv> which is that with new-build we really want a "garbage collect"
18:20:15 <sclv> that lets you delete all packages that aren't "roots" of stuff you want to keep around
18:20:28 <sclv> so you only delete stuff that's safe to delete
18:20:34 <sclv> and there is a design doc and plan for that
18:20:46 <sclv> but its still some time out
18:30:12 <koz_> jle`, or anyone else: Could you assist me with writing pattern synonyms again? https://gist.github.com/kozross/aeb46d675b5997f05317c2a1c164ebf3
18:31:17 <dmwit> koz_: Hrm. I don't think this is a good idea.
18:31:24 <koz_> dmwit: Why not?
18:32:19 <dmwit> Because usually when you pattern match, you bring into scope enough stuff that you could reconstruct the thing you matched against.
18:32:41 <dmwit> Here I think a Bool is probably not enough, if this is a continuation of our discussion from the other night.
18:32:47 <koz_> dmwit: It is indeed.
18:32:59 <dmwit> Perhaps a simple `neither :: Venn -> Bool` predicate is enough...?
18:33:09 <koz_> Yeah, point very well taken.
18:33:40 <dmwit> Or: if you want to be able to construct Venn's as well, perhaps you would prefer something like `pattern Regions :: Bool -> Bool -> Bool -> Bool -> Venn`.
18:34:01 <dmwit> Hm, I wonder if there's record syntax for pattern synonyms...
18:34:01 <koz_> dmwit: That... is an infinitely better plan, thanks.
18:34:04 <koz_> There is.
18:34:11 <koz_> Using curlies.
18:34:27 <dmwit> Then a field named `neither` seems sensible (along with three others).
18:34:34 <koz_> neither, left, right, both.
18:34:44 * koz_ goes and refreshes memory on this.
18:35:30 <dmwit> `pattern Venn :: { neither, left, right, both :: Bool } -> Venn` or something like that seems like a fine idea to me.
18:35:34 <koz_> dmwit: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#record-pattern-synonyms
18:36:08 <dmwit> Okay, cool.
18:36:16 <dmwit> So my syntax was off, but hopefully the idea came through anyway.
18:36:36 <koz_> Yeah, it did, thanks.
18:36:45 <koz_> (this is my first proper chance to hack on finitary a bit more)
18:37:17 <dmwit> I like this Word8 idea, by the way.
18:37:30 <koz_> I'm a bit of a space efficiency afficionado.
18:37:32 <dmwit> The monoid from the other night is just bitwise or then... which seems simply beautiful.
18:37:38 <koz_> Agreed!
18:38:37 * koz_ didn't even see that.
18:43:30 * hackage ghc-source-gen 0.2.0.1 - Constructs Haskell syntax trees for the GHC API.  https://hackage.haskell.org/package/ghc-source-gen-0.2.0.1 (JudahJacobson)
18:45:05 <koz_> OK, patterns are just throwing me lol.
18:46:19 <koz_> https://gist.github.com/kozross/aeb46d675b5997f05317c2a1c164ebf3 <-- assistance welcome
18:52:45 <dmwit> pattern Venn{left} <- Regions (testBit 0 -> left) where Venn{left} = Regions (if left then bit 0 else 0)
18:52:59 <dmwit> ^ an example for just one field. I'm confident you can adapt it to having more fields
18:56:04 <dmwit> Left a comment with an actually-tested version.
18:56:13 <dmwit> Sorry for going seat-of-pants there.
19:02:19 <AviD> Can Unboxed sum types be Ever be untagged
19:02:33 <koz_> AviD: Sorry, I don't understand your question.
19:05:14 <AviD> I'm implementing a champ hamt, but it calls for using two bit vectors to tag the type of a ptr.
19:08:13 <AviD> My current strategy is to use two vectors instead of one
19:09:42 <koz_> dmwit: https://gist.github.com/kozross/aeb46d675b5997f05317c2a1c164ebf3 <-- this is my next attempt, but the first part is definitely wrong and I'm not sure why.
19:09:53 <koz_> I think I don't get the bidirectional pattern synonym syntax's logic.
19:11:31 <dmwit> (\w -> (testBit w 0, testBit w 1)) -> (neither, left) -- sort of unfortunate, requires a tuple allocation
19:11:54 <koz_> Hmmm, OK.
19:11:55 <dmwit> ...maybe? Unless the optimizer manages to get its hands on it.
19:13:05 <dmwit> (GHC turns `case (foo, bar) of (pat1, pat2) -> ...; ...` into a nice efficient thing that doesn't actually construct and immediately destruct a tuple. So if the pattern is inlined enough maybe that's okay.)
19:14:18 <dmwit> Sorry, `(\(Regions w) -> ...) -> (neither, left)`.
19:16:00 <koz_> dmwit: Something like this? https://gist.github.com/kozross/aeb46d675b5997f05317c2a1c164ebf3
19:16:10 <koz_> (that makes GHC complain about name shadowing)
19:19:36 <dmwit> I'm surprised that passes the parser. You have `(\... -> ... -> ...)`, but should have `(\... -> ...) -> ...`
19:21:00 <koz_> OK, now I'm legitimately confused. Are you saying that to the right of the <-, I should have (\(Regions w) -> (..., ..., ..., ...)) -> (neither, ... , ..., ...) where
19:21:02 <koz_> ?
19:21:05 <koz_> Or should that be something else?
19:21:40 <dmwit> Yes, that is what I'm saying.
19:21:48 <koz_> _That_ doesn't pass the parser.
19:21:52 <dmwit> haha, what
19:22:42 <koz_> https://gist.github.com/kozross/aeb46d675b5997f05317c2a1c164ebf3
19:23:11 <dmwit> This whole ViewPatterns thing was a mistake. Scrap the language.
19:23:17 <koz_> LOL
19:23:25 <koz_> Its syntax is rather... cryptic.
19:23:29 <koz_> This is why I'm so confused.
19:24:40 <dmwit> Oh god.
19:25:34 <dmwit> Oh, wait.
19:25:38 <dmwit> YOu haven't turned on ViewPatterns.
19:26:11 <ski> `ViewPatterns' has a strange syntax, yes
19:26:41 <dmwit> ...but turning it on doesn't help.
19:26:45 <koz_> Nope, just tried.
19:26:57 <koz_> (updated the gist too)
19:28:43 <dmwit> Well, if it makes you feel any better, I don't understand why this fails either.
19:28:48 <koz_> Me neither.
19:28:53 <koz_> jle`: Maybe you might be able to help?
19:28:58 <koz_> (or indeed, anyone else)
19:29:05 <koz_> One of these days, I will write a blog post about it.
19:29:12 <koz_> With like, this _exact_ example.
19:29:26 <ski>   pattern (->) (f :: (a -> b)) :: b -> a
19:29:27 <ski>   pattern f -> f x = x
19:30:57 <dmwit> % :set -XViewPatterns
19:30:57 <yahb> dmwit: 
19:31:04 <dmwit> % view :: Word8 -> (Bool, Bool)
19:31:04 <yahb> dmwit: ; <interactive>:12:1: error:; * Couldn't match type `Word8' with `(Bool -> Const Bool Bool) -> s0 -> Const Bool s0'; Expected type: Word8 -> (Bool, Bool); Actual type: Getting Bool s0 Bool -> (Bool, Bool); * In the expression: view :: Word8 -> (Bool, Bool); In an equation for `it': it = view :: Word8 -> (Bool, Bool)
19:31:13 <dmwit> % view :: Word8 -> (Bool, Bool); view w = (testBit w 0, testBit w 1)
19:31:13 <yahb> dmwit: 
19:31:26 <dmwit> % f (view -> (a, b)) = a && b
19:31:26 <yahb> dmwit: 
19:31:33 <dmwit> % :set -XPatternSynonyms
19:31:33 <yahb> dmwit: 
19:31:53 <dmwit> % pattern Foo a b <- (view -> (a,b))
19:31:53 <yahb> dmwit: 
19:31:56 <dmwit> wat
19:33:10 <Nolrai> % f (Foo a b) = a && b
19:33:11 <yahb> Nolrai: 
19:38:58 <dmwit> koz_: You're going to die. RIP
19:39:20 <dmwit> koz_: Instead of `(\... -> ...) -> ...`, write `((\... -> ...) -> ...)`.
19:39:25 <dmwit> Yes, just add an extra set of parens.
19:41:21 <dmwit> Okay, hallway test. I'm writing a program that lets you explore a large tree. I have keys up for moving towards the root, down for looking at the children of the current node, left and right for moving among siblings.
19:42:01 <dmwit> You press "home" (resp. "end"). Do you expect it to go to the first (resp. last) sibling, or to the root (resp. some leaf chosen in an application-specific way)?
19:47:12 <koz_> Home, for me, means 'root'.
19:47:18 <koz_> dmwit: Lol, thanks.
19:47:21 * koz_ goes and tries.
19:48:25 <Welkin> go and zippers
19:48:27 <koz_> So what, this? https://gist.github.com/kozross/aeb46d675b5997f05317c2a1c164ebf3
19:50:39 <dmwit> koz_: yeah, WFM
19:50:54 <koz_> WFM?
19:50:57 <dmwit> works for me
19:50:57 <Welkin> Warm Fuzzy Monads?
19:51:06 <koz_> Ah, Works For Me.
19:51:22 <Welkin> hltuaal
19:51:33 <Welkin> jtuaiywtbclh
19:51:41 <Welkin> tell me what those mean
19:51:56 <koz_> I get a redundant bracket notification from hlint. And the name shadowing thing again.
19:52:00 <Welkin> (they are real acronyms)
19:52:03 <Welkin> I jsut made them up
19:54:37 <dmwit> koz_: Ah, that name shadowing thing is quite something. I'm tempted to say that's a bug.
19:54:57 * koz_ is gonna leave this for a moment and work on something else.
19:55:15 <dmwit> I'd complain on the GHC tracker for sure.
19:55:29 <dmwit> In the meantime, you can just prime the variables in the where if you want.
19:55:29 <koz_> I may just do that.
19:55:43 <koz_> Yeah, I guess that works.
19:55:49 <dmwit> ooooh
19:55:52 <dmwit> No, it's not a bug.
19:56:01 <dmwit> In the where clause, `neither` is the name of a field accessor....
19:56:24 <dmwit> Crazy.
19:56:28 <koz_> So wait, I have to name them differently?
19:56:35 <Welkin> shadowing names is a bad practice
19:56:36 <dmwit> I mean, I guess everything is recursive all the time in Haskell, so why not?
19:56:42 <dmwit> But it is wild that this is possible.
19:56:44 <koz_> Fair enough.
19:56:46 <Welkin> even if you can do it, it doesn't mean you should
19:56:52 <dmwit> koz_: So, yep, you have to name them differently.
19:56:58 <koz_> OK, no problem, can do.
19:57:19 <Welkin> when it comes to record accessors though, that's annoying
19:57:23 <Welkin> elm avoids that problem
19:57:33 <koz_> Also, this is confusing me: http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ord
19:57:53 <koz_> It says that Ord is used for _totally_ ordered datatypes, but the laws are described as being a non-strict _partial_ order.
19:57:55 <koz_> So which is it?
19:58:07 <koz_> I'm guessing it's a total order, as compare has no 'incomparable' option.
19:58:18 <dmwit> What? No, the laws are for a total order.
19:58:24 <dmwit> Antisymmetry is not a partial order thing.
19:58:37 <dmwit> err
19:58:43 <koz_> "However, <= is customarily expected to implement a non-strict partial order and have the following properties:"
19:58:48 <koz_> That is _literally_ what it says. :P
19:58:55 <koz_> (I noticed that just now and got confused)
19:58:57 <dmwit> I'm an idiot. -_-
19:59:12 <dmwit> Well, anyway, every total order is a partial order, so no problem there.
19:59:30 * hackage reanimate-svg 0.9.0.2 - SVG file loader and serializer  https://hackage.haskell.org/package/reanimate-svg-0.9.0.2 (DavidHimmelstrup)
19:59:38 <dmwit> And the fact that `<=` returns a `Bool` (and not a `Maybe Bool`) says it's got to be total.
19:59:43 <dmwit> So no law needed for that, I guess.
19:59:57 <koz_> I suppose, but the wording of the docs shouldn't refer to partial orders then.
20:00:15 <dmwit> It is a bit odd but not incorrect.
20:00:39 <koz_> Do you know if anyone provides a PartialOrd?
20:00:50 <dmwit> And probably was chosen because of what I said: only the partial order laws need to be checked; the type system checks the last one needed to go from partial order to total order.
20:01:37 <koz_> Fair enough.
20:01:49 <dmwit> koz_: So, I don't know, but I did recently write one myself (https://github.com/dmwit/nurse-sveta/blob/master/src/Dr/Mario/Sveta/Pathfinding.hs#L113) and what I found is that there's a hecking lot of possible instances for most things.
20:01:59 <koz_> dmwit: Unsurprisingly.
20:02:10 <dmwit> So you might find that in many cases it's not super clear which is the "canonical" instance for a given type.
20:04:05 <koz_> dmwit: https://hackage.haskell.org/package/lattices-2.0.1/docs/Algebra-PartialOrd.html <-- seems to be one.
20:05:03 <koz_> (although personally, I would argue that compare :: a -> a -> Maybe Ordering is a better design)
20:05:29 <Nolrai> It would be, yes. 
20:06:56 <dmwit> Oof, yes, this is an awful API.
20:06:57 <Nolrai> Is using ~ as a prefix ascii form of "^-1" in my DSL evil?
20:07:25 <dmwit> It's pretty bad.
20:07:35 <dmwit> Why not 1/ ?
20:08:09 <koz_> Given that it's by Oleg, I'm genuinely surprised.
20:08:19 <Nolrai> I guess I don't allow "/" anywhere else. 
20:08:25 <Nolrai> Thanks!
20:40:33 <iqubic> :t foldr
20:40:35 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
20:41:02 <iqubic> Can I see an example of foldr where the a and the b are different?
20:41:38 <koz_> I have one, though not specific to foldr.
20:41:53 <iqubic> That's fine.
20:42:01 <iqubic> I'd like to see that.
20:43:13 <koz_> iqubic: https://gist.github.com/kozross/19d6662ef15055f4e44cc67d09a66d8a#file-smallset-hs-L154
20:43:19 <koz_> You may require some contextual reading.
20:44:01 <koz_> Like, I _literally just wrote that_.
20:44:18 <koz_> Also, dmwit - thanks for the assistance, I managed to crack all the issues I was having with patterns and everything else too.
20:44:40 <iqubic> Also on a different note: I was on an airplane earlier today, and I pulled up my digital copy of Thinking With Types and fired up my haskell development environment too. I had to stop looking at haskell an hour into the flight because my brain had turned to mush. Sandy's book got really really confusing for me.
20:44:58 <koz_> iqubic: It's a lot to take in.
20:45:08 <iqubic> I know it is.
20:45:11 <koz_> I've re-read it a few times now, and there's still stuff there I don't fully follow.
20:45:31 <iqubic> So, what is this foldr, on line 180 doing?
20:45:58 <iqubic> (Set N) ~ t, I assume?
20:46:08 <iqubic> To make this line up more closely with this:
20:46:12 <iqubic> :t foldr
20:46:14 <koz_> I can't make Data.Finitary.SmallSet.Set a valid instance of Foldable.
20:46:14 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
20:46:22 <koz_> This is the next best thing.
20:46:30 <iqubic> koz_: Why can't you make it a foldable?
20:46:42 <koz_> Because I need a Finitary n a constraint to do pretty much anything.
20:46:58 <koz_> And Foldable wants a parameter of kind Type -> Type, which means I can't constrain a.
20:47:03 <koz_> (or even refer to it)
20:47:05 <iqubic> And you lose that constraint by making a type class?
20:47:08 <iqubic> How so?
20:47:18 <koz_> instance Foldable (Set n) where...
20:47:23 <koz_> See a notable absence of a?
20:47:28 <iqubic> Yeah.
20:47:30 <koz_> How then to spell a constraint that requires me to refer to it?
20:47:43 <iqubic> Why do need to constrain a?
20:47:48 <koz_> Finitary n a
20:47:50 <koz_> (as I just said)
20:47:56 <koz_> Notice how it refers to both n _and_ a?
20:48:06 <iqubic> Ah... The a needs to be the same.
20:48:53 <koz_> More precisely, I can't even write this constraint into the instance, because there's no 'a' for me to talk about.
20:49:12 <iqubic> What specifically do you need to constrain here?
20:49:13 <koz_> It's similar to why Data.Vector.Unboxed can't be Foldable legally.
20:49:25 <iqubic> Just that a is finite?
20:49:43 <koz_> I specifically need a Finitary n a constraint in scope for this instance (or rather, each of its methods).
20:49:50 <iqubic> Right. I see.
20:49:52 <koz_> Because otherwise, I can't do anything.
20:49:57 <iqubic> I see.
20:49:59 <koz_> (well, anything useful for Foldable implementation)
20:50:44 <iqubic> Why do you to make sure that Set has role nominal for both parameters?
20:51:35 <hololeap> would anyone be willing to help me optimize some code for a hackerrank challenge? i have a correct solution but it's ~3x too slow, and i don't know where to begin looking for optimization tweaks
20:52:02 <koz_> iqubic: Because otherwise, a is phantom.
20:52:08 <iqubic> And why is that bad?
20:52:22 <koz_> And that would allow coercions like 'Set n Word8 ~ Set n [Integer]'.
20:52:43 <koz_> Or 'Set n Word8 ~ Set n Void'.
20:52:55 <iqubic> And that's really not what you want.
20:53:26 <iqubic> Because a Set of Word8 has different properties from a Set of Void
20:53:43 <hololeap> here is my solution, if anyone is interested: http://dpaste.com/1CZH2S6 ; and the challenge: https://www.hackerrank.com/challenges/sherlock-and-the-maze/problem
20:54:22 <iqubic> What's the difference between a (Finitary n a) and a (Set n a)?
20:57:06 <koz_> iqubic: One has kind Constraint, and the other has kind Type?
20:57:30 <iqubic> I didn't catch that.
21:01:55 <hololeap> oh, wow, i had replicateM_ outside of evalUArrayMemo, so memoization wasn't persisting between test cases. i fixed that and it's 4x faster
21:04:01 <catchme> Why this result is wrong ??
21:04:01 <catchme> n = 499999999500000000
21:04:01 <catchme> k = 1000000000
21:04:01 <catchme> `((2 * k - 1 - sqrt ((1 - 2 * k) ^ 2 - 8 * n + 8)) / 2)` = 9.999999980857865e8
21:04:01 <catchme> it should be only `999999998`
21:04:15 <hololeap> Control.Monad.Memo.Array is some serious pwnage
21:04:23 <koz_> hololeap: What package?
21:04:38 <hololeap> monad-memo
21:05:26 <Axman6> catchme: because you're using Double's
21:05:50 <Axman6> > ((2 * k - 1 - sqrt ((1 - 2 * k) ^ 2 - 8 * n + 8)) / 2) :: Ratio -- this probably won't work
21:05:52 <lambdabot>  error:
21:05:52 <lambdabot>      • Expecting one more argument to ‘Ratio’
21:05:52 <lambdabot>        Expected a type, but ‘Ratio’ has kind ‘* -> *’
21:06:22 <Axman6> > let n = 499999999500000000; k = 1000000000 in  ((2 * k - 1 - sqrt ((1 - 2 * k) ^ 2 - 8 * n + 8)) / 2) :: Ratio Integer -- this probably won't work either
21:06:25 <lambdabot>  error:
21:06:25 <lambdabot>      • No instance for (Floating (Ratio Integer))
21:06:25 <lambdabot>          arising from a use of ‘sqrt’
21:06:39 <Axman6> > let n = 499999999500000000; k = 1000000000 in  ((2 * k - 1 - sqrt ((1 - 2 * k) ^ 2 - 8 * n + 8)) / 2) :: CReal -- This might...
21:06:41 <lambdabot>  999999998.0
21:06:45 <catchme> and I can not use div!
21:07:17 <Axman6> div only works on integral types
21:07:35 <Axman6> > pi :: CReal
21:07:37 <lambdabot>  3.1415926535897932384626433832795028841972
21:08:49 <catchme> Should I `import Data.Number`
21:11:21 <koz_> :t compare
21:11:23 <lambdabot> Ord a => a -> a -> Ordering
21:11:43 <iqubic> I don't know monad memo
21:12:47 <catchme> I got `Could not find module ‘Data.Number.CReal'`
21:22:30 <hololeap> monad-memo has a unboxed mutable array backend which is really fast. this was the first time i had used it
21:31:18 <iqubic> I don't know what interface it gives you.
21:31:23 <iqubic> How easy is it to learn?
21:32:11 <iqubic> Also, how practical is memoization in the real world?
21:33:28 <jle`> iqubic: by 'practical' do you mean 'useful'?
21:33:41 <hololeap> it wasn't hard for me to learn. it's set up to help speed up recursive calls.
21:33:58 <iqubic> jle`: Yes I do.
21:34:18 <jle`> it can be useful; a whole class of algorithms ('dynamic algorithms') are essentially built around memoization
21:34:47 <hololeap> for instance, if f(20) is defined in terms of f(19), which is defined in terms of f(18), and so on, f(20) is going to have to recompute f(19),f(18),f(17)... 
21:34:52 <iqubic> I did not know this.
21:35:12 <hololeap> memozation saves those results so they do not have to be recomputed if you call, say, f(21)
21:35:28 <jle`> memoization is related to cacheing, as well, which is useful in general (ie, don't repeat an expensive IO action if you just save the result), but cacheing in a good way can be sort of tricky
21:35:34 <iqubic> hololeap: The classic example of memoization is calculating Fibonacci numbers
21:35:56 <jle`> yeah, the memofib is a textbook example of a dynamic algorithm
21:35:57 <iqubic> f 0 = 1
21:36:01 <iqubic> f 1 = 1
21:36:19 <iqubic> f n = f (n - 1) + f (n - 2)
21:36:36 <iqubic> This is a really really silly way to do that.
21:36:39 <jle`> that's the non-memoizing version, yeah, and it's O(n^2). but if you memoize it then you get back to O(n) time and space
21:36:48 <dmwit> It isn't O(n^2). It's O(fib(n)).
21:36:55 <dmwit> Which is much, much bigger.
21:36:58 <iqubic> Oh lord.
21:36:59 <jle`> ah, indeed
21:37:06 <jle`> approximately exponential
21:37:10 <jle`> n^phi
21:37:17 <jle`> er, phi^n
21:39:11 <hololeap> iqubic: here is an example in the monad-memo docs for the Fibonacci sequence: http://hackage.haskell.org/package/monad-memo-0.5.1/docs/Control-Monad-Memo.html#g:14
21:39:37 <hololeap> if that helps you understand the interface
21:40:45 <jle`> if you want to see algorithms that take advantage of memoization in nice ways, check out the classic examples of dynamic programming
21:40:59 <jle`> er sorry, i said dynamic algorithms earlier but meant dynamic programming.
21:41:07 <hololeap> startEvalMemo is pure, and thus pretty slow. but if you tweak things to use the Array or Vector-based backends, it is really fast
21:41:34 <jle`> one of my favorite is Wagner-Fischer for calculating edit distances
21:44:09 <koz_> Floyd-Warshall is also pretty cool.
21:44:14 <koz_> (for all-pair shortest path)
21:45:00 <iqubic> What is an edit distance?
21:45:12 <iqubic> I don't know what these things are.
21:45:21 <koz_> iqubic: https://gist.github.com/kozross/19d6662ef15055f4e44cc67d09a66d8a#file-smallset-hs-L154
21:45:23 <koz_> Whoops.
21:45:28 <koz_> iqubic: https://en.wikipedia.org/wiki/Levenshtein_distance
21:45:51 <koz_> The other one is https://en.wikipedia.org/wiki/Shortest_path_problem#All-pairs_shortest_paths
21:46:05 <iqubic> But the memo monad is epic. I love it.
21:46:09 <jle`> iqubic: answering questions like how many insertions, deletions, or substitutions can turn a string like "hello" into another string like "bella"
21:46:28 <iqubic> It's two deletions and two insertions.
21:46:41 <iqubic> But how does one calculate that with code?
21:47:04 <jle`> you would use an algorithm :) like Wagner-Fischer
21:48:09 <koz_> Or rather, an _implementation_ of said.
21:48:22 <iqubic> I have no idea how the memo monad works, but I'm definately grabbing it when I need memoization ever.
21:50:48 <hololeap> iqubic: i'm pretty sure it works like `k -> State (Map k v) v`, in its most basic form, where it saves completed computations
21:51:01 <jle`> usually for plug-and-play memoization i like to use memo-combinators or MemoTrie
21:51:47 <iqubic> I see.
21:52:08 <hololeap> i was rolling my own memoization for these challenges until i saw that hackerrank has monad-memo available
21:52:25 <hololeap> jle`: it also has MemoTrie available, but i haven't tried it
21:52:26 <jle`> maybe i mean data memo-combinators?
21:53:05 <jle`> oh yeah i meant data-memocombinators or representable-tries
21:53:47 <jle`> as you can tell i haven't done any dynamic programming in a while
21:54:25 <koz_> jle`: This one's for you - https://gist.github.com/kozross/e140c8cdf8d08719eb8db8e31162fb66#file-partialord-hs-L27
21:55:18 <jle`> heh, sounds like a very uncertain bodyguard
21:55:23 <jle`> get down! ... maybe?
21:55:26 <koz_> LOL
21:55:37 <koz_> I was thinking of a very uncertain partygoer.
21:55:56 <iqubic> what is the point of a DownMaybe?
21:56:04 <koz_> iqubic: Reverses the partial order.
21:56:04 <jle`> american vs european
21:56:17 <koz_> Same as Down.
21:56:26 <iqubic> What is a partial order?
21:56:39 <koz_> A binary relation which is reflexive, anti-symmetric and transitive.
21:57:09 <iqubic> anti-symmetric?
21:57:26 <koz_> For all x y, if x is related to y and y is related to x, then x == y.
21:57:39 <iqubic> So if `compare x y == GT` then `compare y x == LT`?
21:58:01 <koz_> Nope.
21:58:07 <iqubic> Oh>
21:58:18 <iqubic> How is it anti-symmetric than?
21:58:21 <koz_> It's literally that 'if two things are related both ways, then they're the same thing'.
21:58:41 <koz_> It's because partial orders allow things to be incomparable.
21:58:49 <koz_> So on them, compare isn't even defined.
21:58:51 <iqubic> Why isn't that true of standard things?
21:58:59 <koz_> (hence my liberal use of Maybe)
21:59:09 <koz_> What do you mean by 'standard' (and 'things' while we're at it)?
21:59:21 <sclv> a partial order is what you have if you only have LT or NotLT
21:59:46 <iqubic> How does PartialOrder differ from Ord?
21:59:54 <koz_> iqubic: Look at the type signatures.
21:59:59 <koz_> Combine with my explanation above.
22:00:14 <iqubic> By standard things I meant types with Ord instances.
22:00:18 <koz_> (also, more things can be instances of PartialOrd than Ord - for instance, Sets by inclusion)
22:00:28 <koz_> Ord is a _total_ order - it requires trichotomy.
22:00:49 <koz_> (for all x y, x < y or x > y or x == y)
22:01:05 <koz_> (well, totality actually, since it's non-strict, but ehh)
22:05:39 <jle`> iqubic: you can sort of think of it like Ord where 'compare'/'>'/'<'/etc. is partial (not defined for all inputs)
22:05:50 <dmwit> koz_: compareMaybe (DownMaybe x) (DownMaybe y) = compareMaybe y x -- ?
22:06:01 <iqubic> I see.
22:06:20 <iqubic> It should be that, I think.
22:06:36 <jle`> iqubic: so now you can do things like call 'compare' on sets, where x < y if x is a subset of y
22:06:38 <koz_> dmwit: Is this a sign I'm tired?
22:06:54 <dmwit> Maybe!
22:06:59 <koz_> Just.
22:07:10 <koz_> (also rofl)
22:07:58 <iqubic> nothing
22:08:13 <jle`> > let sleep = pure "zzz" in getSum sleep
22:08:16 <lambdabot>  "zzz"
22:08:37 <iqubic> huh??
22:08:43 <iqubic> :t getSum
22:08:45 <lambdabot> Sum a -> a
22:08:45 <dmwit> ?remember jle` let sleep = pure "zzz" in getSum sleep
22:08:45 <lambdabot> Okay.
22:08:51 <jle`> > LET SLEEP = PURE "ZZZ" IN GETSUM SLEEP
22:08:53 <lambdabot>  <hint>:1:11: error:
22:08:53 <lambdabot>      parse error on input ‘=’
22:08:54 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
22:08:58 <iqubic> :t pure
22:08:59 <lambdabot> Applicative f => a -> f a
22:09:00 <jle`> i miss fortran
22:09:24 <iqubic> How does that actually return "zzz"?
22:09:36 <jle`> pure x = Sum x
22:09:39 <jle`> getSum (Sum x) = x
22:10:51 <iqubic> but (Sum "zzz") makes no sense as a concept.
22:11:01 <jle`> newtype Sum a = Sum a
22:11:09 <jle`> so it's basically like Identity
22:11:16 <iqubic> I know. I know.
22:11:29 <jle`> so, no problem :)
22:11:39 <iqubic> We use it for things like a monoid over ints using (+, 0)
22:11:56 <jle`> there is an alternative use
22:11:59 <dmwit> It turns out that computers don't bother with whether things make sense.
22:12:06 <jle`> which is, for making puns
22:12:07 <dmwit> And certainly not whether they make sense as a concept.
22:12:29 <jle`> ghc is so dumb, it'll compile anything that typechecks
22:12:34 <dmwit> I've asked my computer all sorts of nonsensical questions and gotten stupid answers I realized I didn't want.
22:39:48 <cheater> is there a function f such that f x = f for all x?
22:40:11 <cheater> i tried doing let f = const f
22:44:53 <ski> cheater : what would be its type ?
22:45:45 <ski>   f :: T
22:45:48 <ski>     where
22:45:50 <ski>     T = forall a. a -> T
22:45:55 <ski>   f _ = f
22:46:13 <ski> (you can express that in `ocaml -rectypes', actually)
22:47:55 <cheater> i mean we do have undefined
22:47:56 <cheater> and that fits
22:48:01 <cheater> but i was wondering if there are others
22:48:36 <jle`> cheater: undefined wouldn't really work either i think
22:48:43 <cheater> why?
22:48:50 <cheater> undefined x evaluates to undefined.
22:49:02 <jle`> but it doesn't typecheck
22:49:08 <jle`> unless we're talking about non-haskell functions i guess
22:49:14 <cheater> so? i never said anything about types :)
22:49:19 <cheater> i just said in haskell.
22:49:21 <jle`> ah, i thought we were talking about haskell functions
22:49:26 <cheater> yes, we were
22:49:32 <koz_> Can I write Word literals in hex, and if so, how?
22:49:34 <jle`> so, there is no haskell function that satisfies that
22:49:41 <cheater> undefined is a function
22:49:58 <jle`> can you create such a function in haskell that has that property?
22:50:03 <cheater> undefined is a function
22:50:06 <jle`> you can't, because every haskell function is necessarily typed
22:50:18 <jle`> koz_: 0x53 works right?
22:50:25 <koz_> Oh, just liek that? Cool.
22:50:35 <jle`> cheater: if it doesn't have a type, it can't be defined in haskell
22:50:46 <jle`> that's why the y combinator doesn't exist in haskell
22:51:59 <jle`> in haskell, (undefined :: Int -> Int) is not equal to (undefined :: Int)
22:53:28 <jle`> (undefined :: X -> Y) (undefined :: X) ~ (undefined :: Y), yes
22:53:38 <jle`> but you see the first (undefined :: X -> Y) is different than the second one (undefined :: Y)
22:54:30 <jle`> it's sort of like how mempty :: Compare is different from mempty :: String
22:54:37 <jle`> sure, they both have the same name
22:55:03 <jle`> * mempty :: Ordering
22:55:20 <jle`> but people wouldn't say that `mempty :: Ordering` is equivalent to `mempty :: String` just because they have the same name
22:56:04 <jle`> mempty is a polymorphic binding, like undefined.  when you choose different types to instantiate them, you get different values
22:57:38 <jle`> to be more precise we can use explicit type annotations, and say that the first is `mempty @Ordering` and the second is `mempty @String`.  so they are more clearly potentially different because you are applying a function to different values
22:57:56 <jle`> and in the case of undefined we have (undefined @(X -> Y)) (undefined @X) ~ undefined @Y
22:59:07 <ski> @type (undefined :: t) ()
22:59:09 <lambdabot> t
23:01:03 <jle`> :p
23:02:08 <cheater> are you saying undefined can't be defined?
23:02:57 <jle`> undefined is defined, but also different invocations of undefined can be not equal to each other
23:03:24 <cheater> we weren't talking about equality in that way though
23:03:32 <jle`> what are we talking about equality in terms of?
23:03:39 <jle`> "using the same name"?
23:03:44 <cheater> is undefined 2 the same thing as undefined :: t?
23:03:54 <cheater> or rather
23:04:02 <cheater> is undefined 2 :: t the same thing as undefined :: t?
23:04:06 <cheater> :i undefined
23:04:23 <cheater> huh. :i doesn't work here. i guess it would spam
23:04:27 <jle`> undefined 2 can be the same thing as undefined, but neither of those are the same thing as the undefined you use in 'undefined 2'
23:04:39 <cheater> well, looks like undefined is not something that normally will have Eq defined for it
23:04:42 <cheater> so
23:04:55 <jle`> you only think they are the same because you typed in the same letters for both of them
23:04:58 <cheater> we can't really say if (undefined 2) () will be the same thing as undefined ()
23:05:08 <jle`> we can, semantically
23:05:17 <cheater> no, i think they are the same because they will both evaluate to undefined and bottom out the evaluation
23:05:19 <jle`> because all bottoms of the same type are semantically indistinguishable
23:05:28 <cheater> not because i typed the same letters
23:05:43 <jle`> they evaluate to *different* undefineds
23:06:00 <cheater> how do you know they are different?
23:06:20 <jle`> because they have different types
23:06:25 <cheater> do they?
23:06:30 <cheater> :t (undefined 2) ()
23:06:32 <lambdabot> t
23:06:37 <cheater> :t undefined ()
23:06:39 <lambdabot> t
23:06:49 <nshepperd> :t undefined `asAppliedTo` 2
23:06:51 <lambdabot> Num a => a -> b
23:06:51 <cheater> doesn't look different to me, so what's missing?
23:06:56 <jle`> the second undefined is () -> t, the first one is Int -> () -> t
23:07:02 <jle`> and they both evaluate to undefined :: forall t. t
23:07:04 <cheater> no, no
23:07:06 <dmwit> % newtype T = T (T -> T)
23:07:06 <yahb> dmwit: 
23:07:19 <cheater> i said that (undefined 2) () and undefined () are the same.
23:07:39 <cheater> not that "the undefined in (undefined 2) ()" and "the undefined in undefined ()" are the same.
23:07:47 <jle`> yes, they both evaluate to bottom (so equivalent to undefined :: t). but in neither case is the result the same as the function
23:08:10 <cheater> what makes you think that it is not the same? looks the same to me. behaves the same.
23:08:28 <jle`> they have different types
23:08:34 <cheater> do they?
23:08:34 <jle`> so they can't be used in the same way
23:08:36 <cheater> :t undefined
23:08:38 <lambdabot> a
23:08:42 <cheater> :t (undefined 2) ()
23:08:44 <lambdabot> t
23:08:48 <cheater> looks the same to me
23:09:06 <cheater> :t undefined "flower" (5, 3)
23:09:08 <dmwit> % f = T (\x -> f)
23:09:08 <lambdabot> t
23:09:08 <yahb> dmwit: 
23:09:12 <cheater> also the same
23:09:14 <dmwit> cheater: ^
23:09:14 <jle`> the undefined you used first is different than the undefined you used in the second case
23:09:23 <cheater> you keep saying it's different
23:09:28 <jle`> the undefined in the second case is specialized to (Int -> () -> t)
23:09:30 <cheater> but you're not saying how to see it
23:09:32 <jle`> the undefined in the first case is forall t. t
23:09:36 <cheater> see that's the thing
23:09:38 <nshepperd> cheater: you're confusing the type of the result with the type of the undefined
23:09:46 <jle`> cheater: the easiest way to observe it is to just try to use it as a function
23:09:46 <cheater> no, i'm not
23:09:48 <jle`> you'll get a type error
23:09:52 <cheater> look what i said 2 minutes ago
23:09:55 <nshepperd> :t let u = undefined in (u 2 (), u)
23:09:57 <lambdabot> (a, b)
23:09:57 <cheater> 08:06 <   cheater > i said that (undefined 2) () and undefined () are the same.
23:09:58 <cheater> 08:07 <   cheater > not that "the undefined in (undefined 2) ()" and "the undefined in undefined ()" are the same.
23:10:05 <cheater> those are deeply different statements
23:10:20 <cheater> i made the first statement. jle` and nshepperd you are saying the second statement is false.
23:10:22 <nshepperd> cheater: yes, and jle` said 'in neither case is the result the same as the function'
23:10:26 <cheater> i have not made the second statement.
23:10:26 <jle`> cheater: when you say `undefined 2 == undefined`, the first undefined has type forall t. Int -> t, and the second has type forall t. t
23:10:36 <cheater> nshepperd: i disagree that in the first case it is not the same as the function.
23:10:48 <jle`> cheater: and you can observe this difference, if you try to use the first undefined to apply to a Bool, you cannot do it.  but you can use the second undefined to apply to a bool
23:11:17 <cheater> jle`: so what? the == is a statement about "undefined 2" (on the left) and "undefined" (on the right), not a statement about "undefined inside undefined 2" and "undefined.
23:11:20 <dmwit> In fact, you can even...
23:11:32 <jle`> cheater: you are asking if there is a function where 'f x = f'
23:11:34 <cheater> jle`: i mean that's pretty basic to me. i'm not sure where this confusion is coming from.
23:11:38 <jle`> in this case, f x /= f
23:11:42 <dmwit> % newtype T a = T (a -> T b)
23:11:42 <yahb> dmwit: ; <interactive>:20:25: error: Not in scope: type variable `b'
23:11:43 <cheater> ok, i see what you mean now
23:11:48 <jle`> because the f you use on the LHS is different than the result on the RHS
23:12:05 <jle`> so 'undefined x == undefined' is true, but does not satisfy f x = f
23:12:14 <jle`> because it's f x = something_different_than_f
23:12:18 <cheater> so you're saying that if i ask whether in "undefined 2", which evaluates to "undefined", that is an example of fx = f
23:12:22 <MechanicalError> I was wondering how I can pull a channel history on linux Im using irssi if that helps. The goal is to grep for '>'
23:12:22 <cheater> then it's not the case.
23:12:26 <cheater> ok, i see your objection.
23:12:28 <dmwit> % newtype T a = T (forall b. a -> T b)
23:12:28 <yahb> dmwit: 
23:12:35 <dmwit> % f = T (\x -> f)
23:12:36 <yahb> dmwit: ; <interactive>:22:14: error:; * Couldn't match type `b' with `a'; `b' is a rigid type variable bound by; a type expected by the context:; forall b. a -> T b; at <interactive>:22:5-15; `a' is a rigid type variable bound by; the inferred type of f :: T a; at <interactive>:22:1-15; Expected type: T b; Actual type: T a; * In the expressi
23:12:48 <dmwit> % f :: T a; f = T (\x -> f)
23:12:48 <yahb> dmwit: 
23:12:51 <dmwit> yay
23:13:13 <dmwit> MechanicalError: I believe there is a link to IRC logs in the topic.
23:13:17 <cheater> so now the question is whether asking about f x = f means that the function f has been monomorphised before naming it f, or it only gets monomorphised at time of evaluation.
23:13:22 <jle`> yeah, if we allow for function application to be abstracted, apply(f,x) == f, then dmwit's example works
23:13:24 <cheater> how do we resolve this?
23:13:39 <jle`> haskell functions must typecheck before they can be run
23:13:52 <cheater> yes, they do
23:13:57 <MechanicalError> dmwit: Noted. What if I wanted to do this with a channel that does not have that?
23:14:09 <cheater> however, that doesn't mean we can't make statements about application of functions and equality of those functions
23:14:25 <nshepperd> :t let f x = f in f -- the fact that this fails seems to be pretty conclusive about the fact that no function with f x = f exists...
23:14:27 <lambdabot> error:
23:14:27 <lambdabot>     • Occurs check: cannot construct the infinite type: t1 ~ p0 -> t1
23:14:27 <lambdabot>     • In the expression: let f x = f in f
23:14:27 <jle`> if you see 'undefined 2', then undefined has type forall t. Int -> t
23:14:29 <cheater> but maybe the syntax i used to ask the question is wrong for the semantics i wanted
23:14:36 <dmwit> MechanicalError: Then you will have to make the logs yourself by sitting in the channel a long time.
23:14:53 <jle`> it's sort of like saying if you see (== "hello"), then (==) has type String -> String -> Bool
23:15:07 <dmwit> MechanicalError: Then take a look in ~/.irssi/logs
23:15:43 <cheater> dmwit: i didn't understand your examples. mostly because it looks like there were some errors. would you mind explaining this from the start again?
23:15:45 <jle`> but yeah, if you do some tricks with recursive newtype wrappers, you can get a meaningful interpretation of apply(f,x) == f to be true
23:15:52 <MechanicalError> dmwit: oh, makes sense. So there is no way of pulling logs off of the channel and greping if I don't have the logs localy?
23:16:07 <cheater> no.
23:16:07 <dmwit> No.
23:16:14 <cheater> but there are rogue services that do this anyways.
23:16:22 <MechanicalError> Sad but thanks a bunch
23:16:25 <cheater> just go to google, duckduckgo, or yandex, and type in "logs for channelname"
23:16:34 <MechanicalError> OH!
23:16:44 <cheater> or rather "irc logs for channelname"
23:17:07 <jle`> keep in mind that they might not necessarily exist; a lot of channels actually have explicit policies against public logging
23:17:25 <cheater> yeah
23:17:43 <MechanicalError> cheater: thanks jle`: hmm, that is reasonable.
23:17:50 <jle`> you see, irc is sort of like shipping channels in the ocean
23:18:00 <jle`> you can't see them until a boat cuts through the water leaving a wake
23:18:01 <cheater> btw bear in mind that all three search engines will have vastly different results
23:18:08 <MechanicalError> Im really new to it, Im not even sure how the protocol works
23:18:10 <cheater> for example, yandex doesn't care about gdpr or privacy.
23:18:19 <dmwit> cheater: I dunno. What's to explain? There's just two lines of code. `newtype T a = T (forall b. a -> T b); f = T (\x -> f)`. The last equation is `f x = f` up to newtype wrappers.
23:18:20 <koz_> I'm getting 'unused top bind' warnings from GHC when I try to add methods to my type class. What's the deal with that?
23:18:43 <jle`> check out this accurate description of IRC from a television show https://www.youtube.com/watch?v=O2rGTXHvPCQ
23:19:07 <jle`> koz_: export the methods maybe?
23:19:09 <MechanicalError> jle`: much appreciated
23:19:11 <jle`> if they aren't already exported
23:19:25 <cheater> dmwit: so "apply f x" would be something like... apply f x = ($ x) <$> f ?
23:19:25 <koz_> I have the type class name in my export list. Is that not sufficient?
23:20:17 <cheater> i'm not sure if methods are exported together with the TC
23:20:19 <dmwit> apply (T f) x = f x
23:20:27 <cheater> dmwit: ah yes of course
23:21:52 <koz_> Never mind, I am dense.
23:22:10 <jle`> koz_: MyClass(method1, method2) or MyClass(..)
23:22:16 <jle`> if you just have MyClass then it hides the method names
23:22:20 <jle`> and only exports the typeclass
23:22:26 <koz_> Yeah, I had them as separate exports, lol.
23:22:29 * koz_ goes and fixes this.
23:25:17 <MechanicalError> I was wondering if haskell is well suited as a glue language. Im thinking like python
23:26:14 <dmwit> Listen.
23:26:36 <dmwit> Programming language channels are populated by people that like that language.
23:26:40 <jle`> cheater: note that this system formalizes your intuition that undefined should work, because you can do f2 = T undefined :)
23:28:21 <dmwit> I don't think `f2 = T undefined` is evidence of that at all.
23:28:34 <dmwit> Nobody has claimed that all inhabitants of type `T` have the desired property.
23:28:59 <dmwit> (And they would be wrong to.)
23:29:38 <jle`> well it at least bypasses my objection that the types don't match
23:30:47 <jle`> hm, oh wait, you're right
23:30:47 <dmwit> It doesn't, though.
23:31:00 <jle`> yeah, looking at the actual substitutions that are going on....
23:31:05 <jle`> T undefined doesn't quite cut it
23:31:31 <jle`> f = T (const f) is the only way it works out
23:31:33 <jle`> i think
23:33:54 <cheater> dmwit: could we just say apply (T f) = f?
23:47:53 <nshepperd> isn't it the case that, by definition, writing "f = T (const f)" in haskell gives you the least defined fix point of that equation?
23:48:12 <nshepperd> so anything less defined such as 'undefined' has to not work
23:49:30 * hackage array 0.5.4.0 - Mutable and immutable arrays  https://hackage.haskell.org/package/array-0.5.4.0 (HerbertValerioRiedel)
23:50:11 <nshepperd> :t let f x = TX f in f -- more direct way of writing the equation with the newtype wrapper in a different location
23:50:13 <lambdabot> a -> TX a
23:50:38 <nshepperd> (with newtype TX a = TX (a -> TX a))
23:51:16 <dmwit> cheater: sure
23:55:15 <cheater> dmwit: thanks
23:55:27 <Axman6> MechanicalError: In my esperience yes, we have a lot of tools for dealing with data in lots of different formats. it's possibly not as good or as commonly used to directly interact with different systems through the FFI, though that can also be done
23:58:36 <MechanicalError> would one be able to utilize FFI in a object oriented concurrent system?
23:59:24 <MechanicalError> Axman6: my apologies, Im new to irc.
