00:07:42 <isovector1> what's the syntax for a guard in a unidirectional pattern synonym?
00:10:30 <isovector1> ahh, you use a view pattern on it -_-
00:19:11 <mycroftiv> very new haskeller here, is there a pattern that helps with wrapping and unwrapping types from Maybe? my code looks a lot like this and im suspicious im doing it wrong: apl fn s = Just ((fromJust(fn(head (fromJust s))) ++ (fromJust s)))
00:23:36 <lavalike> :t fmap
00:23:37 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:24:20 <lavalike> this is a start, the Maybe instance applies the given function (a->b) to the a inside of a Maybe a, giving you a Maybe b in return
00:24:21 <Cale> mycroftiv: Use more pattern matching to start with
00:24:45 <Cale> fromJust is unsafe, because it crashes your program if given Nothing, so you should almost never use it
00:25:01 <Cale> same goes for head, it dies if the list is empty
00:25:10 <mycroftiv> in this case the crash is what im going for, because im using the haskell to validate/typecheck inputs that will be going to something else
00:25:32 <mycroftiv> so im trying to engineer it to 'crash as much as possible' when fed non-conforming inputs
00:25:42 <mycroftiv> thank you for the tips, i will work on restructuring
00:27:14 <mycroftiv> i think the fmap is exactly the ticket here
00:30:29 <lavalike> writing an equation for each constructor is also a true and tried method, very important
00:33:13 <mycroftiv> lavalike: im not sure what that means exactly, sorry, could you give an example? is that related to the pattern matching approach to this? i think i tried to write the pattern match and got the syntax wrong
00:34:29 <lavalike> mycroftiv: yes exactly
00:40:25 <lavalike> https://en.wikibooks.org/wiki/Haskell/Pattern_matching
00:40:55 <lavalike> working with a 'Maybe a' is the same as the example there with 'Foo'
00:41:15 <mycroftiv> thanks, i have a lot of reference tabs open in browser but that one looks very good
00:41:43 <lavalike> np!
00:41:44 <Cale> mycroftiv: There's no reasonable way to catch the exceptions thrown by head and fromJust, so in practice they only get used when one is certain that they'll succeed (and even then, it's worth being cautious)
00:42:03 <mycroftiv> Cale: I understand - I am literally wanting the crash to happen though
00:42:09 <Cale> That's fair
00:42:14 <Cale> I suppose :)
00:42:24 <lavalike> some people just want to see the world burn
00:42:41 <mycroftiv> i am having the Haskell layer prepare inputs that are sent along to Forth, and if the inputs arent correct, the forth layer of actually doing stuff will crash, so i want the haskell to crash with a type error on wrongly constructed stacks
00:43:17 <mycroftiv> so the behavior of fromJust when fed a Nothing is exactly the thing i want
00:43:45 <Cale> That's somewhat fair, but the message is usually less informative than one would hope for
00:43:50 <Cale> > fromJust Nothing
00:43:53 <lambdabot>  *Exception: Maybe.fromJust: Nothing
00:44:14 <Cale> ^^ this will be the same message no matter which fromJust in your entire program causes it
00:44:19 <mycroftiv> well, i admit i am probably not doing anything "the best way" because this is very much a learning and experiment project, so thank you for pointing out the issues
03:31:36 <maerwald> https://youtu.be/ecIWPzGEbFc "the future of programming". Found it interesting when he talked about our obsession with languages, yet we have done almost nothing to make programming a proper engineering discipline
03:32:06 <maerwald> minus the "agile" propaganda :P
03:33:37 <dexterfoo> everything uncle bob writes and talks about is only relevant to OOP java programmers. he doesn't have an expansive world-view of programming at large
03:34:15 <merijn> dexterfoo: I would argue a lot of his stuff isn't even relevant to them and that when he's right, he mostly right by accident...
03:34:15 <maerwald> The talk is neither about java, nor about OOP specifically
03:34:44 <maerwald> And I think he is right here about a few things (not agile though)
03:35:11 <dexterfoo> merijn: i haven't watched that talk, because i have been put-off by practially everything i've read by him. (including his most note-worthy book "clean code")
03:35:22 <maerwald> languages (no matter how good or bad) do not make programmers better engineers
03:35:45 <merijn> I disagree. Languages are scaling factors.
03:36:08 <dexterfoo> maerwald: i disagree. a language can change the way you think. there is a common quote: "Learning Haskell makes you a better programming in all other programming languages"
03:36:18 <merijn> You won't make them better engineers at a fundamental level, but you scale how much of their "engineeri-ness" is able to be expressed
03:36:23 <maerwald> dexterfoo: I think it is largely overrated
03:36:32 <maerwald> Engineering is about much more than thinking about types
03:37:13 <maerwald> It's about how to approach problems, processes, workflows, communication, problem solving, mapping domains knowledge to code solutions, ...
03:37:32 <dexterfoo> maerwald: Haskell is more about types. it's also about thinking in DSLs, aggressively trying to eliminate state, trying to arrive at a formal model for your problem domain
03:37:32 <maerwald> All things that happen before you even write a single line of code
03:38:46 <boxscapeR> If someone had only learned purely functional languages, would learning an imperative language make them a better coder as much as learning haskell supposedly improves imperative programmers?
03:38:53 <maerwald> dexterfoo: I think you may or may not think like you described, even when doing haskell
03:39:00 <maerwald> Some people do, some don't
03:39:36 <maerwald> boxscapeR: A better programmer yes, a better engineer? Not sure
03:39:49 <boxscapeR> fair
03:39:59 <dexterfoo> maerwald: but Haskell actively pushes you to structure your code according to the principals i described, while other languages the default is the opposite direction
03:40:10 <maerwald> dexterfoo: you have never seen messy haskell code? :)
03:41:00 <dexterfoo> maerwald: i am obviously haskell biased, but my answer is that the average haskell code is way way way more clean and high quality then the average any-other-language code
03:41:44 <maerwald> dexterfoo: well, that's exactly what the talk is about. It's not about languages, except that paradigm-shifts give us useful insights about what NOT to do
03:41:51 <maerwald> but they don't tell us what to do
03:43:43 <maerwald> approaching things more formally is definitely one of the things that sound right to me (and haskell might make this more easier, but in no way does it require you to)
03:43:58 <maerwald> So this is language-agnostic
04:18:08 <merijn> <3
04:18:48 <merijn> Do you sometimes love your past self for anticipating a future problem and leaving a super convenient point to extend your code to deal with it?
04:20:07 <ski> that's some cool cooperation between past you, and future you ;)
04:22:30 <merijn> ski: Basically, I wrote some boilerplate to migrate my persistent schema across different versions of my application and I anticipated that at some point I'd need a migration persistent couldn't handle automatically, so I had the migration function like "Version -> Migrate [EntityDef]" where I can run some custom SQL in "Migrate" (I was already using that), but also return a different persistent schema 
04:22:36 <merijn> and use that over the final one, so now that I need I just need to change the return value of one function :)
04:23:16 <magneticduck> I'm trying to use simple-sqlite to do some pretty lightweight database construction. I have a list a few thousand Ints, and I'm trying to enter them into a database with something like `executeMany conn "INSERT INTO table (value) VALUES (?)" (Only <$> [1 :: Int .. 1000])`
04:23:43 <magneticduck> this works and does the right thing when instead of 1000 I have 1, but it becomes extremely slow for numbers above 5
04:23:58 <magneticduck> it takes a perceptible amount of time to add 10 rows to the table!
04:23:59 <merijn> magneticduck: Can you somehow log what SQL it's generating to do that?
04:24:09 <magneticduck> hmm, I'll see
04:24:20 <merijn> Because it sounds like it's doing something stupid :)
04:24:39 <merijn> oh, wait...maybe it's query builder is accidentally quadratic?
04:25:43 <merijn> i.e. repeteadly copying/rewalking the thing to insert into ?
04:26:43 <kaol> Try and see if mapM_ (execute conn "...") (Only <$> [1 :: Int .. 1000]) is any better.
04:27:57 * hackage hedis 0.12.7 - Client library for the Redis datastore: supports full command set,pipelining.  https://hackage.haskell.org/package/hedis-0.12.7 (k_bx)
04:28:09 <magneticduck> I made it trace the concrete SQL it's sending
04:28:20 <magneticduck> it's just sending an INSERT for every value
04:29:38 <magneticduck> kaol, that generates the same SQL but is even slower
04:29:51 <magneticduck> hmmm O_o
04:30:16 <merijn> That's weird, because honestly just sending a 1000 inserts shouldn't be slow
04:31:54 <magneticduck> I suppose I'll try another library
04:32:16 <ski> merijn : cool :)
04:33:05 <magneticduck> oh, it might be the database itself https://stackoverflow.com/questions/3852068/sqlite-insert-very-slow
04:34:31 <kaol> Yeah, transactions are kind of important with any DB.
04:34:37 <magneticduck> which makes we wonder why executeMany doesn't automatically batch with BEGIN/END
04:35:24 <magneticduck> I guess I'm expected to `execute_ conn "BEGIN"` myself
04:35:54 <magneticduck> amateur hour
04:36:07 <kaol> Because you may already have a transaction open and the library doesn't even try to tell it. And sometimes you even might want the behavior where each insert is its own transaction.
04:36:34 <magneticduck> yeah, that makes sense
04:48:00 <merijn> magneticduck: It's definitely not the database...
04:48:42 <merijn> magneticduck: I'm doing several thousand inserts per second without any transaction wrapping in SQLite
04:55:09 <sicklorkin> merijn: Do you have a single writer thread?
04:56:06 <merijn> sicklorkin: yeah
04:56:38 <magneticduck> that's interesting. my app is working great with transaction wrapping now, in any case
04:57:35 <sicklorkin> merijn: Do you do any mantainence on your db file? e.g. vaccuum or hot backups?
04:58:16 <merijn> I vaccuum occasionally. There's really no sensible notion of "hot backup", though, since I'm using it as an application file format
04:59:15 <sicklorkin> no state required?
04:59:25 <merijn> sicklorkin: What do you mean?
05:00:50 <sicklorkin> merijn: I mean that the application file format doesn't keep anything that you can't recreate for free.. i'm trying to understand why you wouldn't want to defend against possible file corruption
05:01:59 <merijn> sicklorkin: I mean that I treat them as any other file/document, so there's no specific backup strategy for the databases that's different from the rest of my documents/files/etc.
05:02:23 <sicklorkin> oh.. but yuou can't copy a hot db i don't think.
05:02:51 <merijn> sicklorkin: You don't "hot backup" a text file while you type either
05:03:11 <sicklorkin> okay.. so your app has down time
05:03:36 <merijn> THat's what I mean by an application file format. It's not a service that people talk to via the internet or whatever
05:03:50 <merijn> It's literally something you run by hand as a command in the shell :)
05:04:09 <sicklorkin> :P
05:05:40 <dennisb> If you have a spinning disk (7200 rpms) you can commit at most 120 transactions per second.
05:07:27 <sicklorkin> dennisb: is that assuming yuou are writing each transaction to disk immedately?
05:08:29 <merijn> sicklorkin: I should hope so
05:08:41 <merijn> sicklorkin: The point of a transaction is that it maintains ACID guarantees
05:08:42 <dennisb> Yes, that's what commit means, That it's commited down to the disk and not only sitting in a cache or something. If you pull the power the row should still be there when you boot it up again
05:08:58 <merijn> sicklorkin: WIthout flushing to disk you'd have no D
05:11:31 <merijn> rats...
05:11:55 <merijn> speaking of databases...it's erroring out complaining about failed foreign key constraints, but not reporting which constraint failed... >.<
05:12:05 * Maxdamantus wishes databases separated that notion of "commit" from "make durable"
05:13:50 <sicklorkin> merijn: does sqlite even have proper foreign key constrains?
05:13:55 <merijn> sicklorkin: Yes
05:14:03 <merijn> You just need to enable them via pragma
05:14:13 <dennisb> merijn: that wasn't very helpful, I mostly use postgresql and it usually reports the actual values that made it fail (and what constraint of course)
05:14:33 <merijn> I'm not sure if it's SQLite that's not reporting it or persistent, though
05:15:21 <merijn> Sadly if I manually run the SQL it works fine >.<
05:15:22 <sicklorkin> oh my..  i dind't know they added it.. 
05:15:30 <merijn> sicklorkin: It's had that for...ages
05:15:56 <sicklorkin> merijn: i'm reading up on it now.
05:16:47 <sicklorkin> merijn: do you log all sql?
05:17:49 <sicklorkin> I'm using persistence too and i've got every transaction logged so I can replay it back it needed..
05:18:11 <sicklorkin> *if* can't  remember what I did for this.. but it might help you here.
05:19:12 <sicklorkin> Oh.. In order to use foreign key constraints in SQLite, the library must be compiled with neither SQLITE_OMIT_FOREIGN_KEY or SQLITE_OMIT_TRIGGER defined. If 
05:19:50 <merijn> sicklorkin: Yes, but like I said, if I manually run the SQL it works fine
05:20:08 <sicklorkin> merijn: use transactions then
05:20:56 <merijn> sicklorkin: How does this help? I'm already in a transaction
05:21:28 <merijn> The entire transaction aborts, but that doesn't help me figure out *why* it's aborting
05:21:30 <sicklorkin> merijn: Have a look at section 4. https://sqlite.org/foreignkeys.html
05:22:35 <merijn> I have been going over that entire page already
05:22:58 <merijn> I already know all that, none of it answers my question "which constraint is violated and by what?"
05:23:40 <sicklorkin> right.. it doesn't look like sqlite labels the errors w/the failing constraint
05:24:32 <sicklorkin> it seems reason to me to wrap every insert/update in a transcation 
05:24:38 <sicklorkin> *reasonable*
05:25:02 <merijn> I'm migrating from one schema to another, so updating entire tables, so that's not something I can do in any useful way
05:25:43 <sicklorkin> Now I see where you're coming from.
05:25:49 <merijn> hmm, wait, maybe I know what's going on
05:26:17 <magneticduck> how should I add options like `extensions` and `data-files` to a package.yaml file for use with stack? I know that I can edit the .cabal and have stack respect the options there, but I'd rather not if possible
05:28:35 <fendor_> magneticduck, with extensions you mean language-extensions? and did you try adding a `data-files` field to your project?
05:30:15 <magneticduck> yes, language-extensions
05:31:12 <magneticduck> hm, `data-files` seems to be recognized
05:31:16 <sicklorkin> default-extensions I think.
05:31:51 <sicklorkin> hpack docs should say what it is
05:32:29 <magneticduck> ah, hpack is the thing in charge of package.yaml ... was looking at stack docs
05:32:58 <merijn> I would recommend against hpack, tbh
05:33:20 <jgt> merijn: care to elaborate?
05:33:25 <merijn> jgt: https://twitter.com/g_lebec/status/1159450098746757121
05:34:20 <merijn> TL;DR: It adds little to no power/expressivity and makes it harder for others to build your code for no good reason
05:35:26 <jgt> wasn't so long; I read it
05:35:35 <jgt> and you make a fair argument
05:36:02 <jgt> I'm not using, but I sometimes consider it when I'm a few minutes into compiling for production and it fails because I forgot to add some module to the cabal file
05:36:12 <jgt> s/using/using it/
06:41:42 <merijn> oh, ffs
06:42:05 <merijn> sicklorkin: Good news, I figured out how to make SQLite report which constraint was violated
06:42:16 <merijn> Better news, my migration wasn't even broken!
06:42:34 <merijn> Sad news, I just spend three hours debugging the fact that my input data was already broken... >.>
06:44:18 <sicklorkin> merijn: how do you ask SQLIte to report contraint names?
06:45:18 <merijn> sicklorkin: "PRAGMA foreign_key_check;" checks if all foreign keys are correct (so you can, for example, validate a database that has been used without foreign key enforcement) and will report each individual row that violates a constraint
06:47:57 <sicklorkin> merijn: that sounds handy
06:48:22 <sicklorkin> my approach to migrations is always dump / alter / restore
06:48:29 <nil> how would you name a typeclass that provides  toFoo :: a -> Foo  and  fromFoo :: Foo -> Maybe a  ?
06:48:44 <nil> is there a convention/pattern for that?
06:48:47 <merijn> nil: That depends on why I'm making it a typeclass...
06:49:40 <nil> i have  data Value = Integer Integer | Double Double | ...
06:50:32 <nil> i'm trying to translate functions like Integer -> Double -> Whatever to functions like Value -> Value -> Whatever
06:50:57 <nil> and functions like Whatever -> Integer to Whatever -> Value
06:51:59 <nil> so i thought i'd make instances of that class for Integer, Double, etc., that look like  instance ToAndFromValue Integer where toValue = Integer; fromValue (Integer i) = Just i; fromValue _ = Nothing
06:52:41 <net4all> I am trying to understand the examples of the prettyprinter package. When I run the examples from the documentation I get a type error. It feels like I am missing something. Details: https://www.pastiebin.com/5d501d72ef082
06:53:12 <merijn> net4all: You don't have OverloadedStrings enabled
06:53:13 <net4all> (Apologies for pastebin, cannot login to github at the moment...)
06:53:52 <merijn> net4all: Doc has an overloaded string instance so you can easily write them as string literals, but that doesn't work without OverloadedStrings enabled :)
06:54:35 <merijn> nil: Why do you wanna lift the functions like that? That seems like it'd make a lot of things more error prone
06:55:15 <pong> nil: 
06:55:21 <nil> merijn: i don't think i have a choice. i'm making a simple stack-based programming language; the stack has type [Value]
06:55:25 <nil> hi pong
06:56:04 <merijn> nil: I mean that the typeclass doesn't add much
06:56:25 <nil> merijn: it allows me to write more generic functions
06:56:47 <nil> e.g.  ToAndFromValue v => (v -> r) -> (Value -> Maybe r)
06:56:48 <merijn> nil: The autowrapping of functions only really works if this is basically an embedded DSL in haskell
06:56:49 <net4all> merijn: Thankyou! I figured it was something like that.
06:57:49 <merijn> net4all: Generally if you see errors like "Couldn't match [Char] with <library type>." (or String) the first thing to check is "Do I need OverloadedStrings?"
07:01:02 <nil> merijn: i guess i'll go with Valuable or Valueish unless someone objects to a better name :D
07:14:54 <dmwit> nil: aeson uses FromJSON/ToJSON; cassava uses FromCSV/ToCSV
07:15:41 <dmwit> You could continue that pattern, giving one class for each direction, and naming it something descriptive. Like pick a name for your stack language, say, NFSL (nil's fancy stack language), then use FromNFSL/ToNFSL or something.
07:16:28 <nil> dmwit: i was thinking about that too, it might be a better idea than to merge the two directions in a single class
07:16:47 <nil> (the language is called Ni)
07:17:13 <infinisil> Hm, wouldn't it be easier to provide a lens-like thing?
07:17:29 <infinisil> I'm not sure if type classes are very good for such things
07:18:08 <dmwit> lens-like and typeclass are orthogonal.
07:18:31 <dmwit> A prism or similar seems like a sensible API choice. It can still go in a typeclass so that it has a single, global name for all the types you care about.
07:19:12 <infinisil> Couldn't a lens do that too with a Generic constraint?
07:19:20 <dmwit> Generic is a typeclass...
07:19:46 <infinisil> Yeah but not an additional one
07:20:30 <infinisil> Then you can still have a `defaultNFSL{Get,Set}` or so, but also have specialized functions, or functions taking arguments or whatever
07:20:44 <infinisil> Seems a whole lot more flexible than type classes
07:21:04 <infinisil> Or easier at least
07:21:13 <infinisil> With type classes you need newtypes for different behavior
07:22:50 <nil> i guess that's an interesting idea, but i don't know enough about lenses/prisms/Generic for now and i'm trying to keep it simple
07:37:58 * hackage rib 0.2.0.0 -   https://hackage.haskell.org/package/rib-0.2.0.0 (sridca)
07:39:09 <infinisil> nil: Well you don't even need to know about lens to do that. The idea is really just to provide a `from` and `to` function
07:39:30 <infinisil> Using lens for that is just a convenience bonus
07:41:53 <nil> then i don't get how that is different from what i'm doing now
07:42:36 <lavalike> merijn: btw how do you make sqlite report the constraint on error?
07:42:53 <merijn> lavalike: You don't, afaict >.>
07:43:11 <lavalike> you said you found a way!
07:43:27 <merijn> lavalike: You can check the entire database and list errors, yes
07:43:39 <merijn> lavalike: But I don't know a way to report a specific error as it happens
07:43:51 <lavalike> ah you found it out of band if you will
07:44:10 <merijn> right
07:46:25 <infinisil> nil: What are you doing right now?
07:46:41 <srid> Is it not possible to have Hackage render the images in README.md?
07:49:02 <infinisil> nil: Ah, you probably need something to write functions that have a type that has both `from` and `to`, there lens would step in so you could do `myFun :: Iso' a NFSL -> ...` instead of `myFun :: (FromNFSL a, ToNFSL a) => ...`
07:49:44 <infinisil> But yeah, the typeclasses might be better if you don't want to get involved with lens
08:03:07 <merijn> srid: Define render?
08:03:13 <merijn> srid: They work fine for me?
08:03:25 <srid> display image. cf http://hackage.haskell.org/package/rib
08:03:27 <merijn> srid: They have to be hosted outside of hackage, though
08:03:44 <merijn> srid: Use markdown notation
08:04:03 <merijn> srid: See the badges in README here: https://hackage.haskell.org/package/broadcast-chan
08:04:19 <srid> i see, thanks
08:04:24 <merijn> srid: Those are done using the same markdown syntax as github uses
08:04:43 <srid> markdown syntax doesn't allow setting image attributes, but i guess i have to live wit hthat
08:08:11 <srid> particularly image size
08:08:54 <merijn> srid: Just make a statically resized version for the README?
08:09:06 <srid> its an svg actually. 
08:18:28 * hackage cursor 0.1.0.1 - Purely Functional Cursors  https://hackage.haskell.org/package/cursor-0.1.0.1 (Norfair)
08:20:48 <infinisil> With Haskell you never know what you get when you check out a library, because the name of it might just be something completely different than what most people associate with it
08:25:53 <freeman42x> how can I define a Haskell value that can represent any Haskell function? and how could that value be used to call the function? I assume I need some special package to do that
08:26:32 <freeman42x> I think I need something that can represent an abstract syntax tree
08:27:01 <c_wraith> do you need to be able to inspect the function?
08:27:04 <merijn> freeman42x: What do you mean "any haskell function"?
08:27:33 <freeman42x> c_wraith, yes, it needs to be inspectable. Some kind of AST. And runnable
08:27:59 <c_wraith> see, that's a really important detail that you probably should have included at first. :)
08:28:31 <freeman42x> c_wraith, well, I did mention I need an AST and ASTs can be inspected. I also mentioned it needs to be able to be run
08:29:23 <c_wraith> Now, you need this to work for any haskell function at all?  that basically means you need a haskell parser + interpeter
08:30:29 <freeman42x> c_wraith, yeah, for any implementation of a Haskell function
08:30:59 <merijn> This sounds like an XY problem
08:31:03 <freeman42x> to be honest, the only requirement is that the function is turing complete, and that would be covered by "any Haskell function"
08:31:11 <dminuoso> freeman42x: What are you trying to do exactly?
08:32:56 <monochrom> Haskell doesn't have any reflection. You can't inspect the code of a received Haskell value.
08:33:18 <freeman42x> dminuoso, I'm trying to create a program that can achieve goals of any type. To do that I need a way to represent goals internally in a way in which they can be inspected, and to do that I can use Haskell AST representing a specific Haskell function
08:33:40 <dminuoso> freeman42x: What is a "goal"?
08:33:46 <c_wraith> Yeah, you're definitely going about this the hard way
08:33:47 <freeman42x> monochrom, you don't need reflection to make decisions in code based on the actual value
08:34:07 <monochrom> OK sure. So problem solved?
08:34:15 <freeman42x> c_wraith, "Yeah, you're definitely going about this the hard way" it would be useful if you said how it could be done easier...
08:35:08 <c_wraith> depends on the exact constraints.  maybe you just want a library that someone calls with code describing their goals.  that's how something like xmonad works.
08:35:40 <freeman42x> c_wraith, I told you the exact constraints
08:35:45 <c_wraith> no you didn't
08:35:51 <c_wraith> you told us the solution you have in mind
08:35:59 <freeman42x> there are not extra constraints in addition to what I said
08:36:13 <merijn> freeman42x: The constraints you gave have basically one solution: "Implement a Haskell interpreter + parser"
08:36:25 <merijn> Which seems unlikely to be what you want, but without context we're just guessing
08:36:34 <monochrom> Can you write down your type signatures?
08:37:06 <monochrom> I mean the desired type signatures.
08:37:27 <freeman42x> merijn, why would I need a parser? I just need a way to represent Haskell AST in code and run it. I will not parse Haskell code
08:37:45 <c_wraith> Maybe you want a plugin system where people write haskell files that your application picks up and adds to its internal context.
08:38:12 <c_wraith> Maybe you want a scripting language that's far simpler than haskell to work with.
08:38:21 <sarahzrf> freeman42x: if you want something turing complete, just use SKI
08:38:25 <freeman42x> c_wraith, no, I don't need that. I explained clearly what I am looking for: AST that can represent Haskell code and run it
08:38:32 <sarahzrf> thats very very quick and easy
08:38:46 <c_wraith> freeman42x: you have yet to explain how you're going to *get* that AST, which is the most important part.
08:38:47 <sarahzrf> 50% /s
08:39:23 <freeman42x> c_wraith, the AST will be generated at runtime
08:39:30 <c_wraith> that's not an answer
08:39:41 <merijn> generated from what?
08:40:54 <c_wraith> Might as well say I'm going to write a program that computes busy beaver numbers, all I need is to be told whether a turing machine halts or not at runtime.
08:41:55 <freeman42x> the system will have an initial goal, based on that it would generate plans and other goals. So that is how AST will be generated at run time
08:43:21 <c_wraith> ok, I think I'm starting to get this.  Definitely an XY problem.
08:43:45 <merijn> "the system" <- which system? "initial goal" <- what sort of goal? How do any of these things relate to a Haskell AST?
08:43:56 <c_wraith> you have a bunch of descriptions of goals.  You want to generate a plan from them.  No generation or interpretation of Haskell code is a necessary part of this.
08:45:46 <monochrom> Maybe you can just you GHC API or hint?  Or maybe you can just include a homebrew Scheme interpreter?
08:45:50 <freeman42x> c_wraith, it doesn't NEED to be Haskell code. But that is a good option. Have any better suggestion?
08:46:09 <monochrom> (Every sufficiently sophisticated Haskell program contains a homebrew Scheme? >:) )
08:46:28 <c_wraith> freeman42x: I disagree that it's a good option.
08:47:05 <c_wraith> freeman42x: my assessment is that it's a lot of indirection making things complicated to the edge of being a research problem to implement.
08:47:51 <monochrom> You will one day have to mathematically define "goal", you know that?
08:49:17 <monochrom> The earlier the better because any concrete attempt at a solution hinges on that.
08:49:55 <freeman42y> monochrom, what do you think I am doing? I need the AST value for the goal function to define the goal...
08:50:18 <monochrom> Have you defined your AST type?
08:51:17 <freeman42y> monochrom, that was my question: how can I represent any Haskell AST code and run it
08:51:46 <monochrom> You also said it doesn't have to be Haskell.
08:52:11 <monochrom> Also I cannot believe that "goal" is a synonym for "program".
08:55:20 <monochrom> Is this all a ciphertext for which the key to decipher to plaintext is "goal -> lambda term", "plan -> evaluation order"?
08:55:21 <freeman42y> monochrom, I did not say that "goal" is synonym for "program"
08:55:53 <monochrom> Therefore "goal" does not have to be "any AST"
08:56:13 <deech> Has anyone worked with Haskell + C/C++ on Windows using the Visual Studio C++ compiler ( i.e without dependence on mingw-* )?
08:56:15 <freeman42y> monochrom, "You also said it doesn't have to be Haskell." I also said that I need some implementation and I would go with Haskell for that
08:56:40 <monochrom> Surely at least "goal" has a type other than "oh I don't know, any type of kind *"
08:56:51 <mpickering> If I compile with `debug-info: 3` in my `cabal.project` file should that build all dependencies with debug info as well?
08:57:17 <monochrom> OK so go with hint?
08:57:56 <cocreature> mpickering: you need "package *\n  debug-info: 3" for that iirc
08:58:12 <mpickering> so what is the scope for debug-info: 3?
08:58:40 <freeman42y> monochrom, a goal is an AST that represents a function that takes a WorldState argument and returns a GoalAchieved value. So it's not ANY type of function, it's more constrained than that
08:58:46 <mpickering> cocreature: I'll try that thanks
08:58:49 <cocreature> mpickering: https://cabal.readthedocs.io/en/latest/nix-local-build.html#package-configuration-options
08:58:58 <cocreature> “They can be specified at the top-level, in which case they apply only to local package, or”
08:59:28 * hackage magic-tyfams 0.1.1.0 - Write plugins for magic type families with ease  https://hackage.haskell.org/package/magic-tyfams-0.1.1.0 (isovector)
09:00:17 <mpickering> cocreature: Thanks
09:00:29 * hackage cmptype 0.2.0.0 - Compare types of any kinds  https://hackage.haskell.org/package/cmptype-0.2.0.0 (isovector)
09:05:47 <freeman42y> monochrom, I think you are right. I might be able to use GHC API. I don't know where I could find how to use it though
09:06:28 * hackage type-sets 0.1.1.0 - Type-level sets  https://hackage.haskell.org/package/type-sets-0.1.1.0 (isovector)
09:16:52 <wroathe_> Is TemplateHaskell the only way to create an instance at runtime?
09:17:22 <merijn> wroathe_: Considering that TemplateHaskell doesn't work at runtime, that question doesn't make a lot of sense
09:17:28 <cocreature> wroathe_: depending on what exactly you want the "reflection" package might be worth a look
09:17:32 <wroathe_> merijn: Oh, duh
09:17:38 <merijn> wroathe_: Since, not running at runtime, Template Haskell doesn't create an instance at runtime :)
09:17:43 <wroathe_> yeah
09:18:19 <merijn> wroathe_: You could just use a record of fields to fake a typeclass, tbh
09:18:25 <merijn> And those are trivial to create at runtime
09:20:16 <wroathe_> I'm toying around with potentially making a template engine
09:20:17 <wroathe_> https://gist.github.com/JustinChristensen/222ec9d3a75e90b9c1bedbc05a996d6d
09:21:06 <wroathe_> And obviously you'd want the ability to render partial templates
09:22:13 <wroathe_> So I could have the user provide that in the scope, I could make the render run in IO and add a special "include" directive, or I could just have them create an instance of ToText
09:22:47 <wroathe_> I like the idea of doing the latter, but I'm not sure how I'd make that work with reading and compiling the template to get the toText implementation
09:27:18 <dminuoso> :q
09:27:28 <dminuoso> Wrong window, sorry.
09:27:33 <merijn> dminuoso: Conversation unsaved!
09:28:14 <jgt> you gotta get with those slick leader mappings
09:28:24 <jgt> none of the cool kids are doing :q these days
09:31:24 <wroathe> Oh, I could just use TH to splice in the result of compiling the template
09:34:27 * hackage apecs-physics 0.4.2 - 2D physics for apecs  https://hackage.haskell.org/package/apecs-physics-0.4.2 (jonascarpay)
10:04:58 <isovector1> edwardk: is there a lens for targeting a pattern synonym somewhere deep in my structure? in the spirit of `everywhere $ mkT matchOnMyPatternSyn`?
10:13:08 <isovector1> biplate doesn't work because it's inside a recursive structure :(
10:15:47 <edwardk> isovector1: no context. just looked at channel. what structure?
10:19:05 <isovector1> edwardk: in particular i'm trying to find specific `HsApp`s inside of a `GHC.HsExpr`
10:19:46 <isovector1> i can target it just fine via `Data.Generics.SYB.everywhere`, but the recursive nature of GHC.HsExpr seems to throw a wrench in any lens i try to write
10:21:07 <isovector1> things like `upon` and `biplate` don't search recursively inside of `HsExpr`
10:21:28 <edwardk> isovector1: this clearly wont be a lens
10:21:37 <edwardk> but a traversal is possible
10:21:46 <edwardk> GHC expressions are hard because they hide bottoms
10:24:25 <isovector1> edwardk: oops, yeah. i'm happy with a traversal
10:26:36 <isovector1> i'm dealing with HsExpr GhcPs, so (i think) i'm not too concerned about bottoms; syb works just fine https://github.com/isovector/dynahaskell/blob/master/src/Lib.hs#L76-L78
10:35:11 <isovector1> edwardk: sorted it out with `deepOf unplate mything`. thanks!
10:44:41 <freeman42y> Haskell type being able to represent a Haskell function and evaluate it https://stackoverflow.com/q/57452089/750216
10:48:30 <[exa]> freeman42y: but why?
10:49:30 <ski> freeman42y : sounds like it'd possibly be a "deep embedding" of an EDSL
10:50:24 <ski> @wiki Embedded domain specific language
10:50:24 <lambdabot> https://wiki.haskell.org/Embedded_domain_specific_language
10:50:43 <freeman42y> ski, my assumption is that there is some Haskell library that allows me to build the Haskell AST values and evaluate them
10:52:00 <ski> (but note that the target language, as mentioned in e.g. the "shallow embedding" point, doesn't need to have to be something "concrete" like a string. it could be a function from coordinate to color, or an I/O action, or a pair of a parser and a pretty-printer, &c.)
10:52:32 <[exa]> freeman42y: you can see ghc/ghci internals (which do exactly what you ask for), but I kindof guess that you want much less complexity
10:52:46 <ski> freeman42y : oh, you're talking about Haskell ADTs
10:53:06 * ski would have to repeat [exa]'s question
10:53:57 <ski> (oh, and i didn't understand the `WorldState' and `GoalAchieved' example)
10:54:25 * [exa] suspects unittesting
10:56:19 <[exa]> (or perhaps robots? these work with worlds and goals)
10:57:04 <MarcelineVQ> or a population of agents that write themselves
11:41:03 <bifunc2> How can you build Haskell projects with multiple test suites - or test suites that depend on, compile, launch, and pipe together multiple executables -  etc.?
11:41:15 <bifunc2> In other words, more sophisticated Haskell projects than cabal/stack seem to allow
11:44:47 <merijn> bifunc2: cabal already allows multiple test suites
11:45:12 <Athas> bifunc2: construct a cabal/stack project that generates multiple binaries, then glue these together as necessary (with another binary in the same project, if you wish).
11:45:14 <merijn> bifunc2: You could write haskell code that runs multiple executables and verifies their results
11:45:39 <merijn> bifunc2: If you really want more complex integration tests you probably want to build your own scripts to run those
11:47:13 <cocreature> if you put executables in build-tool-depends of your test suite cabal should make sure they get built and iirc it puts them in PATH when you run the test suite
11:48:55 <AnotherUser> Hey there, currently watching a video about abstractions/composition (in OOP, C#) and mark seeman states: "An interface is composable if all of it's methods' return types are monoids". I know what a monoid is but still struggle to understand this sentence as I'm talking about C#/Java interfaces. Can anyone here enlighten me?
11:48:57 <Athas> That said, don't feel bad for writing test suites that are not test suites as far as Cabal is concerned.  It's fine!
11:48:57 <bifunc2> is it common to create cabal projects that are only test suites? so just a dummy library that nobody uses, but the test suites in it are the important thing
12:04:20 <dminuoso> AnotherUser: Composability is a fuzzy term that means different things to different people in different contexts.
12:05:52 <dminuoso> AnotherUser: Some googling however suggests that he was talking about the Composite "design pattern"
12:06:20 <AnotherUser> dminuoso: yeah to clarify: In my context an interface is composable if it can be united into the composite design pattern
12:06:39 <AnotherUser> dminuoso: yep he was.
12:07:10 <dminuoso> AnotherUser: https://blog.ploeh.dk/2018/03/12/composite-as-a-monoid/ this seems to illustrate what he is talking about.
12:07:24 * ski idly wonders which video this was
12:07:31 <dminuoso> AnotherUser: The compositionality seems to be about combining entire interfaces.
12:08:17 <dminuoso> AnotherUser: In less fancy terms, it refers to the ability to have "instance (Monoid m, Monoid m2, ... Monoid mn) => Monoid (m, m2, ... mn)" 
12:08:38 <AnotherUser> ski: https://cleancoders.com/video-details/humane-code-real-episode-2
12:08:46 <merijn> There's no function "Monoid m => Bool -> m -> m" in base, is there?
12:08:57 <merijn> @hoogle Monoid m => Bool -> m -> m
12:08:58 <lambdabot> Data.Monoid.HT when :: Monoid m => Bool -> m -> m
12:08:58 <lambdabot> Network.URI.Template.Internal whenM :: Monoid m => Bool -> m -> m
12:08:58 <lambdabot> Data.Semigroup stimesMonoid :: (Integral b, Monoid a) => b -> a -> a
12:09:18 <dminuoso> merijn: What does that do?
12:09:32 <MarcelineVQ> mappens with m or mempty based on the bool I'd guess
12:09:34 <dminuoso> exponentiate of true?
12:09:42 <merijn> \b -> if b then id else const mempty
12:09:56 <MarcelineVQ> oh I'm an idiot there's only one m
12:10:27 <merijn> I currently have it defined in 4-5 different projects and it just keeps popping up more and more
12:11:13 <dminuoso> merijn: "bool m mempty" ?
12:11:29 <merijn> dminuoso: That's kinda long and rather opaque, though
12:12:03 <merijn> :t bool mempty -- although...
12:12:06 <lambdabot> Monoid a => a -> Bool -> a
12:12:08 <merijn> ah, no, that's wrong
12:12:29 <merijn> There's
12:12:34 <merijn> :t bool mempty id
12:12:36 <lambdabot> Monoid a => Bool -> a -> a
12:12:38 <merijn> But that's kinda opaque too
12:12:48 <dminuoso> AnotherUser: Please resume this discussion in here. :)
12:13:19 <merijn> I'm also unsure what to call it, atm I'm using "mIf", but that's not great
12:13:36 <AnotherUser> well I wanted to avoid saying it in public, but I actually dont have a clue about haskell. So what does " In less fancy terms, it refers to the ability to have "instance (Monoid m, Monoid m2, ... Monoid mn) => Monoid (m, m2, ... mn)" " mean?
12:13:55 <dmwit> merijn: Perhaps "indicator". https://en.wikipedia.org/wiki/Indicator_function
12:14:12 <dminuoso> AnotherUser: If m1 is a monoid and m2 is a monoid, then the pair (m1, m2) trivially forms a monoid too.
12:14:33 <dminuoso> AnotherUser: And its not limited to tuples of 2, so any tuple of monoids forms a trivial monoid.
12:15:03 <merijn> mwhen, might work..
12:15:32 <dminuoso> merijn: yeah I can totally see that not being confusing with mplus and mzero!
12:15:34 <AnotherUser> ok, but somehow there has to be some logic about which monoid function the monoid tupleis gonna use when it's applied
12:15:48 <dminuoso> AnotherUser: They would be used in parallel.
12:16:00 <merijn> dminuoso: I'm open to suggestions for better names
12:16:08 <dmwit> AnotherUser: Yep. That logic lives inside the instance (which you haven't finished writing yet).
12:16:23 <dmwit> Or whoever you're quoting hasn't finished writing, I guess.
12:17:22 <dmwit> AnotherUser: For example, for pairs, it looks like `instance (Monoid m1, Monoid m2) => Monoid (m1, m2) where mempty = (mempty, mempty); mappend (m11, m21) (m12, m22) = (mappend m11 m12, mappend m21 m22)`.
12:18:26 <dmwit> The first `mempty` and first `mappend` on the right hand side of these equations comes from the `Monoid m1` constraint; the second `mempty` and `mappend` on the right hand sides come from the `Monoid m2` constraint.
12:18:34 <andgate> I'm having some trouble with ghcjs. When I run all.js with d8, its prints the program output but then hangs at the end and doesn't close? I'm just testing with a simple hello world
12:18:37 <bifunc2> merijn where are integration tests normally located in haskell-based organizations? i wonder if there are any standards, or if it's just some organization-specific readme.txt file that explains how to run these tests.
12:19:08 <merijn> bifunc2: That depends on your CI setup, etc.
12:19:20 <AnotherUser> dmwit, dminuoso: thx
12:19:49 <merijn> bifunc2: Most of the big companies using Haskell have their own entire infrastructure. I know some use Nix, Standard Chartered doesn't use cabal at all, but uses Shake to build their codebase, etc.
12:20:05 <ski> AnotherUser, ty
12:21:50 <bifunc2> interesting, thanks merijn 
12:22:40 <merijn> bifunc2: You can have a look at the cabal/cabal-install, they do some pretty extensive/complex testing
12:23:13 <merijn> bifunc2: Another common trick is to turn your entire executable into library functions (called by said executable), so you can test them together simply by importing the various functions and running them
12:24:36 <AnotherUser> Basically, the following snipped represents my quote in code:
12:24:37 <AnotherUser> https://paste.ofcode.org/YwKqYNEZh26MakCQHMLjLf
12:24:37 <bifunc2> merijn now the question is, nix vs shake..
12:24:41 <bifunc2> :D
12:24:51 <merijn> bifunc2: Those two aren't really alternatives to each other :)
12:25:13 <merijn> bifunc2: Nix is a package manager, Shake is a buildsystem (or rather, a DSL for building buildsystems)
12:27:34 <rubik> Any advice for an advanced(?) Haskeller on how to get a job with it?
12:27:51 <merijn> Are you willing to move to Alaska? ;)
12:28:03 <merijn> (although I haven't seen those guys in a while...)
12:28:06 <rubik> uhm, why not?!
12:28:20 <AnotherUser> that's the spirit
12:28:33 <rubik> nothing binds me here
12:28:40 <dmwit> Galois is hiring in Arlington.
12:28:46 <merijn> rubik: There was a company looking for a haskell programmer, no experience required, only downside was it was a non-remote Alaska position. But it's been awhile since I saw it posting :p
12:29:11 <rubik> but the most companies want PhDs, don't they?
12:29:14 <merijn> rubik: Anyway, the "Haskell Weekly News" has a job opening section, /r/haskell sees recruitment posts reasonably often, so does the haskell-cafe mailing list
12:29:22 <merijn> rubik: There's also haskellers.com
12:29:38 <rubik> merijn: just have to get there :P
12:29:43 <monochrom> Is this why Haskellers are so active on IRC? Because they're like stuck in Alaska and Finland? >:)
12:29:46 <dmwit> merijn: Those are great suggestions.
12:30:16 <rubik> Finland would also be nice by climate. i like it cold
12:30:44 <merijn> I know it N=1 sample size, but I've been contacted twice from being on haskellers.com
12:31:01 <rubik> i'll visit the page now
12:31:46 <rubik> i'm not stucking in learning more haskell or fp etc, but in life and that is frustrating
12:32:12 <merijn> You can also just sneak Haskell into whatever company you're in subtly
12:32:21 <merijn> Like, not in the main codebase, that gets complaints
12:32:27 <rubik> yeah ... no, not here in germany :/
12:32:48 <rubik> they're too afraid
12:32:52 <merijn> But when you need a one-off migration script for the database, quickly write it in Haskell it's just a one off anyway and then people will start using it, etc. :p
12:33:02 <merijn> rubik: The trick is not to ask permission :p
12:33:29 <rubik> but it is so that some friends in my hackerspace call me "functional programming extremist"
12:33:34 <monochrom> Yes all legacy software today that we know will stay with us forever started as one-shot prototype scripts.
12:33:34 <merijn> Me and a colleague on a project snuck a bunch of haskell in (independently without knowing the other would) on all sorts of tangential tools/testing scripts :)
12:34:02 <rubik> merijn: not permission, but after it for ...? don't know the english word for it
12:34:29 <Tuplanolla> Forgiveness?
12:34:33 <monochrom> After-the-fact? Postmortem?
12:34:41 <rubik> yes! those easy words ...
12:34:58 <merijn> monochrom: Technically postmortem isn't the english word for anything ;)
12:35:10 <monochrom> There are a couple of peripheral things you don't need permission for because it doesn't harm anyone.
12:35:23 <rubik> you're very kind btw, thx, this is what i need now
12:36:13 <rubik> i would go to this conference in berlin in a few days but it's EXPENSIVE AS HELL
12:36:32 <srhb> ICFP, presumably..
12:36:34 <monochrom> Strictly speaking, language choice and design choice only need permission from someone who will co-work on it with you.
12:36:47 <merijn> I'm sad I'm not going to ICFP :\
12:36:49 <rubik> srhb: right, a friend from there told me about it
12:37:18 <rubik> some of the GHC gurus there too?
12:37:29 <lavalike> one time I went ahead and used R as a fast way to do k-means and that lived through the whole life of that project
12:37:48 <rubik> lavalike: also nice
12:37:51 <merijn> monochrom: I came to my sense and replaced my one-off python code with Haskell eventually! \o/
12:38:33 <rubik> i could now apply for a node.js job at a cloud company near Franfurt, but don't know if
12:38:57 <rubik> merijn: make runtime errors compile time errors :P
12:39:19 <monochrom> I and a colleague at the school CS department actually formed a tongue-in-cheek alliance "instructors against python".  But he is on the C side and I am on the Haskell side.
12:39:34 <merijn> rubik: Mostly it turned >45 minute compute times into <30s compute times :)
12:40:17 <rubik> merijn: nice well done
12:40:41 <Tuplanolla> How often do you quiz him on undefined behavior, monochrom?
12:40:58 <monochrom> None.
12:41:06 <lavalike> 6.0001 apparently is still python but I recently learned Sussman wrote a third chapter in the SICP, SICM, well, trilogy now
12:41:24 <rubik> Haskell has power and i want to become good at it some day to make some things better (very optimistic i know, forgive me)
12:41:52 <rubik> Tuplanolla: so what about Rust instead of C?
12:42:33 <Tuplanolla> I don't know what should be taught.
12:43:04 <Tuplanolla> I just like to make people uncomfortable.
12:43:10 <monochrom> Hey, I'm pretty interested in his Functional Differential Geometry now!
12:44:09 <merijn> hmm, why are unboxed vectors not Foldable?
12:44:23 <lavalike> monochrom: I know right? it's the best news I got all year so far
12:45:29 <monochrom> I heard him talking about this approach on youtube.  I want to dig deeper.
12:45:42 <rubik> merijn: did you find this experimentally?
12:45:51 <merijn> rubik: hmm?
12:46:04 <rubik> with the unboxed vectors
12:46:12 <[exa]> looking at the program of ICFP, what is differentiable programming??
12:46:18 <lavalike> monochrom: I also discovered the course site from 2016 has links to some hidden yt videos, but they are rather swift
12:46:19 <merijn> rubik: I looked in the Hackage docs and I don't see an instance there
12:46:29 <rubik> oh
12:46:51 <rubik> maybe some improvement is needed
12:47:06 <lavalike> running mit-scheme after all these years has also been fun
12:50:15 <lavalike> monochrom: do you have a link to the youtube video(s) you mentioned?
12:50:24 <monochrom> No.
12:50:40 <monochrom> Actually youtube may have my history...
12:51:02 <lavalike> under /feed/history
12:51:37 <monochrom> Ah no, can't find it again.
12:51:43 <merijn> Jesus...over a decade of Haskell and I still need ghci to check which way filter works...
12:51:49 <monochrom> It was several years ago.
12:51:54 <lavalike> ah (:
12:52:02 <rubik> hehe
12:57:03 <ggole> It's a pretty bad name
12:59:01 <nshepperd> merijn: because the representation depends on what it contains
13:00:02 <merijn> nshepperd: huh?
13:00:06 <nshepperd> the forall a in foldMap :: Monoid b => (a -> b) -> U.Vector a -> b is a problem
13:00:19 <merijn> nshepperd: Why?
13:01:00 <merijn> nshepperd: Are you confusing Foldable and Traversable?
13:01:03 <nshepperd> you can't extract the a without knowing how it's stored
13:01:17 <merijn> ah...hmmm
13:01:33 <nshepperd> Storable vectors also lack Foldable
13:01:59 <nshepperd> for much the same reason, though it's 'worse' for Data.Vector.Unboxed i suppose since it's a data family too
13:10:02 <nshepperd> you could stuff the vector into a GADT which also holds an Unbox dictionary and give that Foldable though
13:48:35 <d34df00d> Hi!
13:49:29 <d34df00d> So we have the Has pattern, used among other things to support MonadReaders with arbitrary contexts that can project out the piece that we are interested in.
13:49:59 <d34df00d> Is there a common name for the dual concept allowing injecting the piece we can produce into arbitrary type supporting that?
13:50:21 <d34df00d> The usecase I have in mind is (MonadError e m, CoHas MyErrorType e)
13:50:52 <merijn> d34df00d: Sounds like you just want extensible exceptions? :)
13:51:10 <d34df00d> merijn: sorta :)
13:51:20 <merijn> d34df00d: The Exception class is already setup to be able to create hierarchies of exceptions
13:51:34 <merijn> So you can easily catch groups of exceptions
13:51:37 <d34df00d> Uh, I cannot reason about what my pure function "throws" with Exceptions.
13:51:51 <d34df00d> So ideally I'd like to express that in types of the function.
13:52:09 <merijn> d34df00d: You can use the same infrastructure with MonadError
13:52:09 <d34df00d> But in a way that doesn't introduce coupling between possibly unrelated modules.
13:52:57 <d34df00d> merijn: does this mean I'd still have to do some sort of runtime reflection and introspection to get the specific error that occurred?
13:53:22 <d34df00d> Cause if I have something like `AppError = WebError WebErrorType | DbError DbErrorType`, then everything is obvious.
13:53:28 <merijn> Yeah, but I can't see a way of handling things where you don't have that
13:53:42 <merijn> d34df00d: You can set something like that up
13:53:55 <merijn> At least, I think it should be possible
13:58:06 <andgate> Does anyone know how lazy evaluation works in ghcjs?
13:59:13 <andgate> in general, looking for resources on ghcjs implementation details
14:05:26 <dminuoso> andgate: From the looks of it, it seems to be just an STG machine.
14:06:56 <dminuoso> andgate: ⌜src/Gen2/RtsTypes.hs⌝ should give some quick hints.
14:08:24 <dminuoso> andgate: The actual implementation is buried in ⌜Rts.hs⌝ it seems.
14:14:46 <andgate> Oh, so it is an stg machine
14:16:42 <andgate> I wonder how garbage collection works here. Is the ghcjs stg just letting javascript garbage collect thunks?
14:22:28 <mpickering> I am trying to implement an FFI call but the error makes no sense to me
14:22:41 <mpickering> `foreign import ccall unsafe "mblock_address_space.begin" address_space_start :: IO Int` but the error says "undefined symbol: address_space_start"
14:23:18 <merijn> mpickering: "mblock_address_space.begin" does not look like a legal symbol to me
14:23:28 <merijn> mpickering: Are you trying to access the element of a struct?
14:23:33 <mpickering> yes
14:23:42 <mpickering> I thought this would be a way to do it without anything more complicated..
14:23:45 <merijn> mpickering: That's not going to work, no
14:23:59 <merijn> mpickering: You can check if the CApiFFI extension lets you do that directly
14:24:09 <mpickering> The struct looks like `(gdb) p mblock_address_space 
14:24:09 <mpickering> $1 = {begin = 283467841536, end = 1382979469312, padding = {0, 0, 0, 0, 0, 0}}`
14:25:12 <mpickering> mblock_address_space is something the RTS defines
14:25:15 <merijn> mpickering: The ccall FFI can only deal with symbols, so top level names. Indexing a struct would require knowledge of 1) structs, 2) the contents of said struct, 3) the memory layout
14:25:58 <mpickering> ok sure, as it's the first word though in the struct then it should just work if I remove the `.begin`?
14:26:52 <merijn> mpickering: I think you still need CApiFFI then, because "IO Int" is going to be interpreted as "int foo();"
14:27:30 <mpickering> ok I will try this 
14:39:54 <andgate> does anyone know if ghc has a shared library for parsing stg?
14:45:37 <merijn> andgate: It doesn't, because afaik there's not even a real grammar for STG
15:00:57 <iqubic> How does one get started with making their own web server in Haskell?
15:02:56 <isovector1> alanz: i'm trying to insert nodes into an AST parsed via ghc-exactprint. however my new nodes don't show up after `exactPrint`. wondering if you know offhand what i might be doing wrong
15:04:28 <c_wraith> iqubic: You either start with an existing project like warp or snap-server, or you start by studying the HTTP specification
15:04:47 <iqubic> I want to start with an existing project.
15:04:58 <iqubic> What's an easy project to get started with?
15:07:13 <merijn> wai/warp, probably
15:10:17 <c_wraith> there are several things built on top of them which attempt to simplify as much as they can, like spock or scotty that you might want to look at
15:11:06 <iqubic> Where does Yesod lie in all of this?
15:11:14 <c_wraith> it's built on top of warp
15:11:22 <merijn> iqubic: Dark template haskell voodoo confusion
15:13:08 <iqubic> So I should steer clear of Yesod?
15:14:12 <dmwit> You're not going to get anybody to commit to that stance.
15:16:01 <iqubic> So are there any good tutorials for these frameworks?
15:24:36 <dmwit> Have you consulted your friendly local search engine?
15:35:26 <jgt> iqubic: I run three businesses on Yesod. I like it.
15:37:02 <jgt> and I pretty firmly disagree with "dark template haskell voodoo confusion"
15:37:05 <jgt> that's nonsense
15:38:18 <merijn> jgt: there's a bazillion datatypes and classes that are generated and thus have no easy way of being inspected/knowing what gets generated
15:38:39 <merijn> Admittedly, last time I used it was awhile ago, but if persistent is any indication I don't think it has meaningfully changed
15:41:27 <jgt> Yesod is not Persistent
15:41:36 <jgt> Yesod is also not Shakespeare
15:41:44 <merijn> jgt: It shares a lot of design choices
15:42:10 <merijn> jgt: Yesod's design was a lot like persistent in that a lot was generated via TH from specific formats
15:42:18 <jgt> the point being: if you don't like the TH it encourages, you're free to switch it out for something else
15:42:32 <jgt> (the libraries, I mean)
15:42:42 <merijn> Sure, you could do it by hand if you reimplement everything, but then why even use Yesod
15:43:28 <jgt> I think for someone interested in building a website in Haskell, starting with batteries included is better than starting with a blank slate, and not knowing even how to get rudimentary logging to work
15:43:35 <jgt> but that's just like, my opinion, man
15:43:57 <merijn> jgt: The question was for a simple/minimal framework
15:44:02 <merijn> Yesod is neither of those things
15:44:19 <jgt> and I disagree with you on that
15:44:45 <merijn> You literally just said Yesod is "batteries included" that's literally the opposite of minimal
15:45:10 <jgt> I think not having to think about mundane things like logging is what makes it minimal
15:46:03 <monochrom> Next: Is C minimal or is Python minimal now?
15:46:08 <jgt> I'm struggling to pick an analogy, but let me try
15:46:20 <jgt> "I'd like to light a fire. Which tool should I use?"
15:46:54 <jgt> "Don't use a lighter. They have these complex rolling flint mechanisms, and little gas chambers. Just rub some sticks together. That's minimal."
15:47:27 <wildtrees[m]> Iqubic try scotty its easy and simple
15:47:36 <monochrom> I would use a thermonuclear bomb.  Because afterwards everything would be minimal.
15:47:48 <jgt> thinking_man.gif
15:49:19 <monochrom> Also thermonuclear transaction > atomic transaction
15:49:59 <MarcelineVQ> either way you have to apply your tinder slowly to not snuff out the flame and increase the size of the pieces as the coals form. lighter or wood-drill, you've got work ahead of you
15:50:39 <merijn> On a completely unrelated note...
15:51:04 <monochrom> Wait, I thought it was for lighting up a cigarette, not coal.
15:51:18 <merijn> I've got a record that has 5 unpacked fields, now I find myself suddenly needing a second variant of each of those fields
15:51:39 <monochrom> This is what's wrong with analogies.
15:51:41 <merijn> I'm unsure how to best deal with this. If I use a tuple/Pair I lose the ability to unpack everything
15:52:24 <merijn> But I also don't really relish the idea of having to duplicate each field and come up with a suitable name for the new one...
15:52:54 <jgt> merijn: something something… TH? ;)
15:53:23 <merijn> That doesn't help, because the code needing with it would still need to be duplicated for each field
15:54:12 <merijn> Which is the part I'd like to avoid
15:54:31 <merijn> If I had a pair I could just lift the functions to be applied to both side of the tuple/pair
15:55:23 <dmj`> merijn: generics ?
15:56:05 <merijn> dmj`: Not sure how that helps/applies?
15:56:53 <dmj`> merijn: what's the operation being applied to both of the data types?
15:58:41 <merijn> dmj`: Basically I currently have 5 vectors that I'm doing pointwise operations on, except now I have two vectors for each of those fields and I can't simply concatnate them (because I'll lose the ability to tell which elements came from which)
16:00:44 <wildtrees[m]> Pass a functor as a parameter to your record and wrap each field with the functor?
16:02:52 <merijn> wildtrees[m]: That adds a whole bunch of indirection on top of the current unpacked version, though
16:03:48 <merijn> The functor parameter is generic so can't be unpacked and it's contents also can't be, so now instead of the current 0 indirect lookups I now have 4
16:04:50 <merijn> Which is painful in a strict fold that runs like a million iterations....
16:04:58 <dmj`> If you define your own tuple type, where everything is unpacked, and the field in the parent record is also unpacked, won't it all be unpacked
16:04:58 <wildtrees[m]> :(
16:05:04 <dmj`> data TupleVec = TupleVec { tVec1 :: {-#UNPACK #-} !(Vector Double), tvec2 :: {-#UNPACK#-} !(Vector Double) } data VecHolder = VecHolder { a :: {-# UNPACK #-} !TupleVec }
16:06:55 <merijn> dmj`: Yeah, except I have 3 different types of Vectors, so then I have to implement 3 different tuple types
16:08:04 <merijn> I think I just have to suck it up and deal with the ugly duplication everywhere
16:08:12 <dmj`> three different types meaning boxed immutable, boxed mutable, unboxed mutable, or three different types meaning different variations of TupleVec
16:08:32 <merijn> dmj`: I mean "Vector Double" "Vector Int64" etc.
16:08:45 <dmj`> Can you use Unbox a => a
16:09:14 <merijn> Yeah
16:09:52 <merijn> But I don't think that helps?
16:11:28 <dmj`> data TupleVec a b = TupleVec { tVec1 :: {-#UNPACK #-} !(Vector a), tvec2 :: {-#UNPACK#-} !(Vector b) } data VecHolder a b = VecHolder { foo :: {-# UNPACK #-} !(TupleVec a b\
16:11:28 <dmj`> ) } 
16:11:35 <dmj`> you'd have to thread the type variables through everything
16:11:43 <dmj`> but then you could just play with type synonyms
16:11:44 <MarcelineVQ> "<merijn> ... I can't simply concatnate them (because I'll lose the ability to tell which elements came from which)" wouldn't the indexes tell you which elements came from which?
16:12:08 <dmj`> type TupleVecInt = TupleVec Int Int
16:12:17 <merijn> MarcelineVQ: Only if I start also storing the lenghts
16:12:43 <merijn> dmj`: But it can't unpack like that, I think?
16:13:04 <merijn> dmj`: AFAIK you can unpack polymorphic arguments like that
16:14:13 <dmj`> merijn: it doesn't complain about having the unpack pragmas
16:14:28 <MarcelineVQ> Vector doesn't know how long it is?
16:14:29 <merijn> dmj`: It does here
16:14:36 <merijn> "Ignoring unusable UNPACK pragma"
16:14:52 <dmj`> ah, I did runghc w/o -Wall
16:15:48 <dmj`> merijn: which GHC are you on
16:15:53 <merijn> 8.6.5
16:17:07 <dmj`> me too ...
16:17:10 <dmj`> nix-shell -p 'haskellPackages.ghcWithPackages (p: with p; [ vector ])' --run 'ghc -Wall -funbox-strict-fields -Werror -O2 Main.hs'
16:17:17 <dmj`> [1 of 1] Compiling Main             ( Main.hs, Main.o ) [Optimisation flags changed]
16:17:17 <dmj`> Linking Main ...
16:18:16 <merijn> Lemme try adding -funbox-strict-fields
16:18:51 <dmj`> I'm on darwin, let me try linux
16:18:54 <merijn> I still get unusable UNPACK pragma
16:18:59 <merijn> dmj`: I'm on macOS :)
16:19:00 <dmj`> https://gist.github.com/60e0e9506f08b03d919dc82324e9d1d9
16:19:07 <dmj`> stranger than fiction
16:19:12 <dmj`> VecHolder {foo = TupleVec {tVec1 = [], tvec2 = []}}
16:19:35 <dmj`> merijn: can you show me where you're putting your type variables
16:20:10 <dmj`> ah-hah
16:20:19 <dmj`> ensure the type variable is in the Vector
16:20:27 <dmj`> not like this
16:20:27 <dmj`> data TupleVec a b = TupleVec { tVec1 :: {-# UNPACK #-} !a, tvec2 :: {-# UNPACK #-} !b }
16:20:34 <merijn> I was doing: "data TupleVec a = TupleVec { tVec1 :: {-# UNPACK #-} !(Vector a) , tVec2 :: {-# UNPACK #-} !(Vector a) }"
16:21:30 <dmj`> I did that too, and no unused warning
16:22:13 <dmj`> merijn: are you using nix
16:22:16 <merijn> No
16:22:40 <dmj`> should be ok
16:23:57 <dmj`> merijn: I'm baffled 😕 
16:24:19 <dmj`> merijn: when you compile my gist, does it also warn ?
16:24:37 <merijn> dmj`: I was working on trying that, but not sure how to easily tell it to look for vector
16:25:19 <dmj`> oh that's right, vector isn't a boot package yet is it, just array
16:26:26 <dmj`> cabal sandbox init && cabal install --dependencies-only vector && cabal exec ghc -O2 -funbox-strict-fields -Wall -o main && ./main
16:26:49 <dmj`> good old fashioned cabal sandboxes
16:27:08 <dmj`> a relic of the past
16:29:10 <dmj`> merijn: do you use stack?
16:29:52 <merijn> dmj`: No, v2-build for everything. I think there's a sandbox "create environment" UI, but I forgot what it was
16:30:02 <merijn> I'm just going the sandbox route now
16:30:26 <dmj`> there's gotta be a way to create an ad-hoc ghc pkg list in a shell 
16:30:31 <dmj`> remember hsenv
16:30:40 <merijn> dmj`: There is one builtin to v2-build
16:30:47 <merijn> I just never used it before so I don't remember
16:30:48 <dmj`> ah, that's great then
16:32:30 <merijn> hmm, your example works on my laptop, let's see on linux
16:33:06 <dmj`> there was a ghc bug a while ago where disabling optimizations would ignore unpack pragmas
16:33:11 <merijn> Ah!
16:33:13 <merijn> No
16:33:20 <dmj`> https://gitlab.haskell.org/ghc/ghc/issues/11270
16:33:25 <merijn> The problem is you used regular Vector, not unboxed
16:33:26 <dmj`> so its a linux thing?
16:33:40 <merijn> dmj`: If you change your import to Data.Vector.Unboxed it shows up
16:33:41 <dmj`> Ah I knew it, I was about to ask what kind of vector we wanted
16:33:44 <dmj`> ok let me try to be sure
16:34:23 <thryothorus> can someone look at my project euler solution to #3 and tell me why it never returns?
16:34:24 <thryothorus> https://pastebin.com/L342yJ6Q
16:35:32 <dmj`> thryothorus: probably the call to maximum ?
16:35:44 <dmj`> merijn: ok hold the phone, why can't unboxed vectors be unpacked again ? yet immutable ones can. Is it because they can change size
16:35:56 <merijn> thryothorus: Because you're building millions of lists, which is a *super* slow way of sieving
16:36:19 <thryothorus> dmj`: it's slow without the maximum call
16:36:25 <merijn> dmj`: unboxed vectors can be unpacked, because I'm unpacking them right now
16:36:46 <merijn> dmj`: It's just when you parameterise the vector type everything breaks
16:37:36 <thryothorus> merijn: is there a better way to sieve that doesn't look super complicated?
16:37:47 <thryothorus> i'm just learning haskell
16:38:47 <merijn> dmj`: ! I have a suspicion
16:38:59 <merijn> dmj`: Mailing list says you can only unpack single constructor types
16:39:08 <merijn> dmj`: unboxed vector is a datat family
16:39:29 <merijn> dmj`: I'm guessing that without instantiating the parameter it's impossible to determine whether it's single data constructor!
16:40:26 <dmj`> ahh, ok I follow you
16:40:40 <merijn> Well that sucks balls
16:41:03 <merijn> Because all the versions I want are individually unpackable, but I can't write some generic way of tupling them like this :\
16:42:20 <merijn> And I was using Unboxed instead of Storable because I can't have tuples in a Storable vector without a bunch of hassle >.>
16:43:30 <dmj`> I see
16:43:39 <merijn> This seems like a problem for tomorrow, it's way too late
16:43:47 <dmj`> is hmatrix an option here?
16:43:54 <dmj`> despite us just being against storable vectors
16:44:33 <merijn> No, that's way too much data shuffling for very little reason
16:45:04 <merijn> It'd be more efficient to write a custom Storable tuple and use that instead
16:45:24 <dmj`> @package storable-tuple
16:45:25 <lambdabot> http://hackage.haskell.org/package/storable-tuple
16:45:32 <dmj`> could work
16:46:17 <merijn> dmj`: I'd probably define a custom type instead
16:46:32 <merijn> Avoids the orphan and probably cleaner
16:47:28 <dmj`> had something like this for the array fire library
16:47:30 <dmj`> https://gist.github.com/dmjio/e86842afd0c81535bdcbd05aa7772893
16:47:36 <dmj`> but it used hsc2hs ofc 
16:48:26 <merijn> dmj`: You can just handwrite a Storable instance if you don't have to interoperate with anything else, much simpler
16:48:52 <merijn> Anyhoo, bedtime
16:49:33 <dmj`> sure
16:49:35 <dmj`> alright, cheers
17:05:55 <shapr> Is there a Haskell low level bit flipping tutorial?
17:06:15 <Axman6> Data.Bits
17:07:09 <shapr> so best is probably https://wiki.haskell.org/Dealing_with_binary_data ?
17:08:17 <shapr> I miss The Monad.Reader :-(
17:08:27 <shapr> Like, Haskell Weekly is cool and all
17:08:49 <shapr> but I want regular articles on requested topics
17:09:24 <shapr> I'd have to track down ezyang and get the keys to the kingdom
17:09:32 <shapr> but hey, I'm not really that busy at recurse center
17:09:37 * shapr is joking
17:14:39 <lyxia> shapr: ping me when you get it started again!
17:15:18 <shapr> lyxia: will do :-)
17:18:57 <MarcelineVQ> is Monad.Reader general fp or just haskell?
17:19:09 <shapr> so far, only Haskell
17:19:14 <shapr> MarcelineVQ: seen the back issues?
17:20:07 <shapr> MarcelineVQ: this is the most recent issue https://themonadreader.wordpress.com/
17:20:14 <MarcelineVQ> no I don't know anything about it though I see the links here on the wiki for older issues
17:20:25 <shapr> previous issues are https://wiki.haskell.org/The_Monad.Reader/Previous_issues
17:20:53 <shapr> MarcelineVQ: I started a semi-academic journal to find a midpoint between research papers and motivated commercial programmers
17:21:01 <shapr> lots of good results, including the Typeclassopedia
17:22:57 <shapr> at some point I got bored, handed it off to Wouter Swierstra
17:28:10 <nisstyre> shapr: you mean like a tutorial on packing your own bytestrings and stuff?
17:28:31 <shapr> nisstyre: I think so?
17:28:54 <shapr> I did the code katas years back, I'm digging into my old bloom filter code
17:29:01 <shapr> I remember it was a massive pain to figure out the first time
17:29:07 <nisstyre> I think you just have to be willing to figure out all of the bitwise operations needed
17:29:12 <nisstyre> yeah
17:29:52 <nisstyre> and use fixed width integer types everywhere
17:30:21 <nisstyre> shapr: I did the exact same project but in C https://github.com/weskerfoot/KataFilter/blob/master/bfilter.c
17:30:33 <nisstyre> and then wrapped it in Python
17:30:39 <shapr> neat
17:30:44 <shapr> I realize I never profiled this code
17:31:02 <shapr> there's not a huge pile of "how to profile your Haskell code and make it faster"
17:36:01 <nisstyre> yeah, that would be amazing if someone wrote a book on optimizing Haskell code
17:37:36 <dmj`> the end of real world haskell is still pretty good
17:39:30 <hpc> no spoilers
18:04:06 <crestfallen> https://paste.ee/p/Ltft5    hello it was associativity and not operator precedence that makes this program work unexpectedly. Am I correct in that?     https://paste.ee/p/Ltft5     
18:04:22 <crestfallen> ie....
18:04:48 <crestfallen> [1,2] is associated with the function first
18:05:13 <monochrom> You sure you don't have a typo with either [5,7] or [3,4] ?
18:05:34 <crestfallen> sorry I might , checking ..
18:10:50 <jle`> crestfallen: what is the unexpected behavior?
18:11:00 <crestfallen> sorry is there is typo?
18:11:01 <MarcelineVQ> I want to say yes but we can't know is unexpected here without you saying what you expected. But given that <*> has the same precedence as <*>, then associativity has to be what's responsible for pure f <*> g <*> h <*> i working as (pure f <*> g) <*> h <*> i
18:11:16 <MarcelineVQ> *can't know what is unexpected
18:11:35 <crestfallen> one sec pls
18:13:02 <jle`> maybe they were expecting x * y ^ z to be (x * y) ^ z ?
18:13:12 <jle`> instead of x * (y ^ z) ?
18:13:45 <crestfallen> jle`: isn't that second case how its working?
18:13:48 <MarcelineVQ> the paste's extra parens suggest it's something else but we'll find out shortly
18:14:27 <crestfallen> no I added the parens just to see if it ran correctly
18:14:29 <jle`> crestfallen: right, but we're not sure what you mean by "makes this program work unexpectedly".  what did you expect, and how did the result differ from what you expected?
18:14:31 <MarcelineVQ> monochrom's question is still pretty relevant though, and does lean towards your guess jle` :>
18:14:56 <jle`> maybe it would be helpful to tell us the answer you expected vs. what the answer you got
18:15:10 <crestfallen> where is the typo
18:19:09 <crestfallen> jle`:   the other day you wrote  (fs <*> xs) <*> ys    which in this case would be   (fs <*> xs) <*> ys <*> zs
18:19:58 <crestfallen> is that correct?
18:20:03 <jle`> yeah, or to be more explicit, ((fs <*> xs) <*> ys) <*> zs
18:22:16 <crestfallen> I'm just trying to figure out the order of operations 
18:23:14 <crestfallen> also I don't see a typo
18:26:30 <MarcelineVQ> crestfallen: your examples had two changes that point to different points of confusion, the changes were the extra ( ) and using [3,4] instead of [5,7]. the parens change suggested you were confused about <*> and the list change suggested you were confused about * and ^ monochrom was asking if the list change was a typo just in case it was unintentional
18:27:34 <crestfallen> also if you write it say    (pure (\x y z -> 1 * y ^ z)   <*>     first 4 exponentiations  ...   (pure (\x y z -> 2 * y ^ z)    <*>   last 4 exponents
18:27:48 <crestfallen> that's how I was trying to write it.
18:28:16 <crestfallen> sorry MarcelineVQ  the parens were only to prove to myself that the function worked the same and...
18:29:20 <crestfallen> I changed the ys list just because I wanted to check with a different example. why is that ys list problematic?
18:29:52 <crestfallen> the output looks right , does it not?
18:30:23 <monochrom> OK, so what's the question?
18:31:50 <jle`> if the output looks right, what is unexpected?
18:32:34 <crestfallen> actually I just wanted to make sure this is essentially what is happening :      (pure (\x y z -> 1 * y ^ z)   <*>     first 4 exponentiations    ...   (pure (\x y z -> 2 * y ^ z)    <*>   last 4 exponents
18:33:06 <crestfallen> exponentiations*
18:33:31 <jle`> one way to figure this out is to manually expand the applications :)
18:33:36 <jle`> with paper and pencil
18:33:58 <jle`> for [\x y z -> x * y ^ z] <*> [1,2]
18:34:27 <jle`> you get [(\y z -> 1 * y ^ z), (\y z -> 2 * y ^ z)]
18:34:40 <jle`> because [f] <*> [a,b] = [f a, f b]
18:35:03 <jle`> evaluation by substitution 
18:35:04 <crestfallen> yes, I see so you apply \x and it becomes \y z  ...
18:35:26 <crestfallen> that's how you would write it out
18:35:41 <jle`> yeah, because \x y z -> x * y ^ z is sugar for (\x -> (\y z -> x * y ^ z))
18:35:50 <jle`> so applying 1 to that function gives you the inner lambda back, with x = 1
18:36:24 <crestfallen> yeah dang it I couldn't figure out how to write it out. I'm meticulous about it. wait, the inner lambda?
18:36:37 <jle`> the (\y z -> x * y ^ z)
18:38:19 <crestfallen> thanks jle` a lot .. so in haskellbook there are some lambda reductions in the .. well very first section and ..
18:40:49 <crestfallen> the last two are really convoluted. I don't have it in front of me, but there are only a very limited number of lambda expressions. is that the full extent of the lambda calculus, say like 6 or 7 classic reductions  ?
18:42:05 <crestfallen> ie it's not extensive. I sort of just want to forget about that notation and work on examples like this one today
18:43:05 <crestfallen> and thanks a lot MarcelineVQ monochrom
19:07:27 * hackage unagi-chan 0.4.1.1 - Fast concurrent queues with a Chan-like API, and more  https://hackage.haskell.org/package/unagi-chan-0.4.1.1 (BrandonSimmons)
19:22:27 * hackage shh 0.7.0.1 - Simple shell scripting from Haskell  https://hackage.haskell.org/package/shh-0.7.0.1 (lukec)
20:13:54 <jusss`> which editor you guys use?
20:14:41 <Axman6> VS Code
20:15:32 <MarcelineVQ> atom
20:17:28 <glguy> vim
20:18:50 <infinisil> emacs
20:22:19 <jackdk> ed
20:24:08 <Axman6> forall X. "Does anyone use X to write haskell?" 
20:24:15 <infinisil> I think one of us is lying
20:24:32 <MarcelineVQ> infinisil: it's glguy
20:24:38 <infinisil> Definitely glguy
20:24:48 <sicklorkin> vim
20:25:02 <Axman6> jackdk definitely does actually use ed to write, Haskell, I've seen him do it
20:25:14 <Axman6> s/, Haskell/ Haskell/
20:26:17 <infinisil> Well damn
20:28:41 <sicklorkin> infinisil: I would have thought you switched to VS Code
20:29:15 <infinisil> How so?
20:30:11 <sicklorkin> infinisil: oops.. for somereason I thought you maintained some nix hie+vscode stuff
20:30:32 <infinisil> Ah, yes I do maintain https://github.com/Infinisil/all-hies
20:30:37 <infinisil> But it's not vscode specific
20:33:13 <sicklorkin> oh i never knew about doteditorconfig
20:37:44 <jackdk> tbf not always, but I have written stuff in ed, including a full configuration.nix for a rpi where ncurses was very confused
20:48:28 * hackage avro 0.4.5.2 - Avro serialization support for Haskell  https://hackage.haskell.org/package/avro-0.4.5.2 (haskellworks)
21:03:20 <gspia> jusss`: kakoune (see kakoune.org)
21:18:52 <Axman6> Another one!
21:22:38 <Axman6> wrunt[m] is also a kakoune user
21:25:22 <orion> I'm writing an application with servant and persistent, and I'm getting an error about MonadUnliftIO not having an instance for Handler. This came about as a result of using runSqlConn. Am I doing something wrong?
21:26:20 <orion> As I understand it, UnliftIO can only safely be used with ReaderT and IdentityT, however a Handler runs in ExceptT ServerError IO a.
21:26:59 <orion> Something something multiple exit points.
21:34:55 <dmj`> any happy experts online ?
21:41:14 <sicklorkin> dmj`: i've used it a bit, what's up?
21:43:04 <dmj`> sicklorkin: my grammar has some ambiguities in it that I'm trying to resolve to no avail
21:43:33 <dmj`> sicklorkin: one being () can either be the beginning of an empty function argument list, or the type Void
21:44:13 <dmj`> another being (Int), which can again be the beginning of an empty function argument list, or a parenthesized type
21:44:20 <dmj`> this is parsing the type level grammar
21:44:33 <dmj`> it chooses the wrong one (shortest one) and fails
21:45:04 <dmj`> sicklorkin: GHC probably has the same issue, but gets around it
21:45:40 <pavonia> We should have another parser generator called "grumpy", so users can make a choice based on their current mood
21:46:00 <dmj`> sicklorkin: FunctionType :: { Type } : '(' Type ')' { $2 } | '(' FunctionTypeArgumentClause ')' '->' Type { TypeFunction (FunctionType [] $2 $5) } 
21:46:50 <pavonia> Wasn't there a rule you can add which of the alternatives it should prefer?
21:47:01 <sicklorkin> dmj`: i'm check the docs for that now
21:48:32 <dmj`> pavonia: that sounds nice
21:48:36 <dmj`> sicklorkin: cool
21:55:37 <dmj`> sicklorkin: the only thing that mentions it in the docs is the precedence of the tokens
21:55:50 <sicklorkin> dmj`: It's not obvious to me what you need to do here, sorry I'm not able to help.  Have you tried modifying these precedence ruels?
21:57:57 <dmj`> yes, it's np. Not an easy problem to fix.
22:06:28 * hackage arbor-postgres 0.0.4 - Convenience types and functions for postgresql-simple.  https://hackage.haskell.org/package/arbor-postgres-0.0.4 (arbornetworks)
22:13:56 <dmj`> Can happy even do backtracking
22:20:13 <pavonia> I recall I read about exatly that problem once in another context. There's a way to refactor the grammar to solve it, but I don't remember which one. Something like putting both cases in a common non-terminal or so
22:29:44 <pavonia> dmj`: Here's a possible solution: https://stackoverflow.com/questions/43968490/yacc-grammar-for-arithmetic-expressions-with-no-surrounding-parentheses
22:44:05 <glguy> You use precedences to resolve those kinds of ambiguities if you don't want to refactor your grammar to eliminate them
22:45:13 <glguy> https://www.haskell.org/happy/doc/html/sec-Precedences.html goes into detail on this
