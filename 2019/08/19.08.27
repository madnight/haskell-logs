00:11:53 <jusss> :t liftM
00:11:55 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
00:12:07 <jusss> :t fmap
00:12:09 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:12:38 <jusss> this liftM is not fmap?
00:15:31 <tsahyt> it is
00:15:55 <jusss> tsahyt: then why it exists?
00:15:57 <tsahyt> well, liftM has the Monad constraint
00:16:03 <maerwald> why does mapM from streamly have a MonadThrow constraint?
00:16:05 <tsahyt> historical reasons mostly
00:16:09 <tsahyt> as far as I know
00:16:29 <jusss> tsahyt: and liftM2 is applicative?
00:16:35 <jusss> <*>
00:16:41 <tsahyt> :t liftM2
00:16:43 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
00:16:46 <jusss> :t <*>
00:16:48 <lambdabot> error: parse error on input ‘<*>’
00:16:52 <tsahyt> :t (<*>)
00:16:53 <jusss> :t (<*>)
00:16:54 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
00:16:54 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
00:16:56 <tsahyt> nope
00:17:16 <tsahyt> jusss: the "Monad" version of <*> is ap
00:17:18 <tsahyt> :t ap
00:17:20 <lambdabot> Monad m => m (a -> b) -> m a -> m b
00:17:34 <tsahyt> this is why all monads are applicatives
00:17:49 <tsahyt> whenever you have a monad, you can construct an applicative through ap
00:20:40 <tsahyt> well, making monomorphic unpacked versions of V3 brought down the time for this angle calculation (which happens hundreds of millions of times in my application) from 650ns to 24.8ns
00:20:43 <tsahyt> I call that a win
00:20:50 <jusss> tsahyt: to make a type as an instance of typeclass Monad, it has to implement how many functions at least?
00:21:31 <tsahyt> jusss: return and (>>=). but return is also in Applicative (called pure), so it's really just (>>=).
00:21:32 <jusss> like >>= and return is nessecary
00:22:00 <tsahyt> ah and indeed the docs now name (>>=) as the minimal complete definition
00:22:28 <tsahyt> so it's only >>= now, because Applicative is a superclass of monad
00:22:29 <jusss> tsahyt: does that mean it has to be an instance of Functor and Applicative first?
00:22:34 <tsahyt> yes
00:22:50 <tsahyt> all monads are applicatives, all applicatives are functors.
00:23:11 <tsahyt> but not the other way round. there are functors that aren't applicatives, and there are applicatives that aren't monads.
00:23:21 <jusss> for example?
00:24:11 <Ariakenom> tsahyt: nice. if you want speed there are some fast but unsafe float flags, right? hehe
00:24:13 <tsahyt> the Const functor apparently
00:24:21 <tsahyt> Ariakenom: such as?
00:24:32 <jusss> so there're four functions to make a type become an instance of monad, fmap, <*>, pure and >>= ?
00:24:49 <tsahyt> jusss: but perhaps most importantly, stuff you get out of Compose. you can compose functors together with it, and the composition of two applicatives are also always an applicative. but the composition of two monads may not be a monad.
00:25:17 <jusss> tsahyt: wait, that's not monad transformer?
00:25:36 <jusss> tsahyt: or >=>
00:25:50 <jusss> "the composition of two monads"
00:26:07 <tsahyt> Ariakenom: I'm starting to hit diminishing returns with the speed of this function. A ~26x speedup in the angle function only resulted in a 1.14x speedup of the whole calculation. so it's now time to start looking for something else.
00:26:30 <tsahyt> jusss: monad transformers are actually something you can use to "get around" the problem of composing monads.
00:26:39 <tsahyt> that's why they exist. otherwise we'd probably just use Composeb
00:26:41 <tsahyt> Compose*
00:27:40 <tsahyt> jusss: and >=> is composition of functions "into" monads (or Kleisli arrows, if you wanna be technical), not of the monads themselves
00:27:44 <Ariakenom> tsahyt: this has some flags https://wiki.haskell.org/Performance/Floating_point
00:27:58 <tsahyt> "-optc-march=pentium4"
00:28:01 <tsahyt> I think this might be outdated
00:28:48 <tsahyt> but generally, those seem to be GCC options, and GHC hasn't been using the C backend for a while now. I guess it can't hurt to comb through the manual a bit though
00:28:52 <Ariakenom> heh. it could be that it can ignore targets older than that
00:29:23 <tsahyt> switching to the LLVM backend results in a very minor speedup too, but fedora packages old LLVM versions in a way that makes stack complain, and LLVM 8 doesn't seem to be supported well by GHC. it works, but it gives me a bunch of warnings
00:29:29 <Ariakenom> I thought the user guide would have some but I didn't find anything
00:31:30 <jusss> tsahyt: then what is "the composition of two monads"?
00:31:39 <jusss> what it looks like?
00:31:48 <dminuoso> jusss: What does the composition of two functions look like?
00:32:03 <jusss> :t (.)
00:32:05 <lambdabot> (b -> c) -> (a -> b) -> a -> c
00:32:08 <tsahyt> :t Compose
00:32:10 <lambdabot> error:
00:32:10 <lambdabot>     • Data constructor not in scope: Compose
00:32:10 <lambdabot>     • Perhaps you meant variable ‘icompose’ (imported from Control.Lens)
00:32:11 <jusss> dminuoso: f . g
00:32:13 <tsahyt> aw
00:32:19 <tsahyt> :t Data.Functor.Compose.Compose
00:32:20 <dminuoso> jusss: Okay, and: f . g = ?
00:32:20 <lambdabot> forall k1 k (f :: k -> *) (g :: k1 -> k) (a :: k1). f (g a) -> Data.Functor.Compose.Compose f g a
00:32:36 <jusss> dminuoso: f . g = \x -> f (g x)
00:32:58 <dminuoso> jusss: Okay! Remember how an Monad is a type-function of kind * -> * ?
00:33:08 <jusss> dminuoso: yeah
00:33:21 <dminuoso> jusss: You can compose type-functions too!
00:33:28 <dminuoso> jusss: Just like you can with (.)
00:33:38 <dminuoso> jusss: Except it's called :.: instead of .
00:33:50 <jusss> :t (:.:)
00:33:52 <lambdabot> error: Data constructor not in scope: :.:
00:33:59 <dminuoso> jusss: Its a type level construct, so you have to use :k :)
00:34:14 <jusss> :k (:.:)
00:34:15 <lambdabot> error:
00:34:16 <lambdabot>     Not in scope: type constructor or class ‘:.:’
00:34:16 <lambdabot>     Perhaps you meant ‘:~:’ (imported from Data.Typeable)
00:34:29 <dminuoso> % import GHC.Generics
00:34:29 <yahb> dminuoso: 
00:34:34 <dminuoso> % :k (:.:)
00:34:34 <yahb> dminuoso: (:.:) :: (k2 -> *) -> (k1 -> k2) -> k1 -> *
00:35:29 <dminuoso> jusss: So if `(f . g) x = f (g x)`, can you solve `(Maybe :.: IO) Bool = ...`  ? :)
00:38:28 <jusss> dminuoso: Maybe (IO Bool) ?
00:38:42 * hackage cabal-install 3.0.0.0 - The command-line interface for Cabal and Hackage.  https://hackage.haskell.org/package/cabal-install-3.0.0.0 (MikhailGlushenkov)
00:39:00 <dminuoso> jusss: Indeed. Now they are not fully equal, but isomorphic. 
00:39:18 <dminuoso> jusss: So (Maybe :.: IO) is the composition of Maybe after IO.
00:39:33 <tsahyt> dminuoso: is that equivalent to Data.Functor.Compose?
00:39:40 <dminuoso> tsahyt: Yes, just as infix.
00:39:45 <tsahyt> oh nice
00:39:47 <tsahyt> I didn't know about that
00:40:20 <jusss> dminuoso: this isn't a monad transformer?
00:41:14 <freeman42x> looking for people interested in contributing to a Haskell free and open source project: https://twitter.com/razvan_panda/status/1166253123880607750
00:42:22 <dminuoso> So they want a resume to even know what this open source project is about? 
00:42:33 <dminuoso> jusss: monad transformers is something else
00:42:42 <MarcelineVQ> Be a really good idea to link the project even if it's just a readme at the moment
00:42:57 <dminuoso> jusss: A monad transformer is a type function that, itself, accepts a monad and gives you a new monad back
00:43:09 <dminuoso> jusss: So it sort of transforms a monad into a new monad.
00:44:05 <jusss> dminuoso: what it looks like?
00:44:11 <dminuoso> % :k MaybeT
00:44:11 <yahb> dminuoso: ; <interactive>:1:1: error:; Not in scope: type constructor or class `MaybeT'; Perhaps you meant `Maybe' (imported from Prelude)
00:44:23 <dminuoso> % import Control.Monad.Trans.Maybe
00:44:23 <yahb> dminuoso: 
00:44:24 <dminuoso> % :k MaybeT
00:44:24 <yahb> dminuoso: MaybeT :: (* -> *) -> * -> *
00:44:56 <dminuoso> This thing takes a monad (remember, they have kind * -> *), and it returns a monad (which again, all have kind * -> *)
00:45:04 <dminuoso> `MaybeT IO` gives you a new monad back
00:45:24 <jusss> `MaybeT Either a`?
00:45:39 <dminuoso> jusss: Pick a type for `a` and add parens.
00:46:00 <jusss> dminuoso: the `a` must be concret ?
00:46:04 <dminuoso> But yes, for every choice of a, `MaybeT (Either a)` gives you a monad.
00:46:55 <MarcelineVQ> jusss: because Either is * -> * -> *, (Either a) is * -> *
00:47:32 <dminuoso> jusss: Well if you dont pick a concrete type for a, then you dont get a single monad back, but a whole family of monads. :)
00:48:00 <jusss> Maybe (IO Bool) is monad compose, and MaybeT IO is monad transfromer and also a new monad?
00:48:32 <dminuoso> jusss: Not `Maybe (IO Bool)`, but `(Maybe :.: IO) Bool`, but here's the thing.
00:49:09 <MarcelineVQ> freeman42x: No one's going to send you something as personal as a resume if they don't know what they're hoping to work on
00:49:28 <dminuoso> jusss: If F is a functor, and G is a functor, then (F :.: G) is also a functor. but when both F and G are monad, then `F :.: G` is not necessarily a monad. So you cant combine them into new monads arbitrarily.
00:51:19 <dminuoso> jusss: Which is a shame, because it means we cant just arbitrarily compose the effects we want. So if we want the effect of both F and G we need something else, we can't just compose them together.
00:51:45 <davean> a resume for working on an open source project? Either you contribute code or you don't - theres no interview and acceptance process!
00:51:47 <jusss> dminuoso: that's why monad transformer come?
00:51:58 <dminuoso> jusss: Indeed.
00:52:18 <cocreature> “send us your resume and we might grant you the privilege of working for us for free”
00:52:46 <dminuoso> jusss: So instead of composing (Maybe :.: IO) and hoping for a monad, we create a type function that takes an arbitrary monad, say IO, and "gives it the exception-effect of Maybe" and returns the new monad.
00:52:57 <dminuoso> jusss: So MaybeT transforms an arbitrary monad by giving it "exception effects"
00:52:58 <EvanR> the working updates to the code is the resume
00:53:27 <dminuoso> jusss: The cool trick is, MaybeT works on *any* monad. :)
00:53:40 <jusss> dminuoso: even itself?
00:53:50 <EvanR> MaybeT isn't itself a monad
00:53:52 <dminuoso> jusss: MaybeT is not a monad, so it cant be applied to itself.
00:54:16 <jusss> it's a type function, right?
00:54:19 <dminuoso> jusss: Yes.
00:54:46 <jusss> dminuoso: can we compose those type functions?
00:54:59 <freeman42x> dminuoso, "So they want a resume to even know what this open source project is about?" No, you can ask and I will provide more details. Also I already said what the project is about if you pay attention.
00:55:03 <EvanR> MaybeT (MaybeT m) 
00:55:27 <jusss> EvanR: aha, just like f . g?
00:55:42 <dminuoso> jusss: Well yeah, except there's no generic (.) on the type system I think
00:55:43 <freeman42x> MarcelineVQ, unfortunately I can not make the GitHub repository public yet, that will happen in 1-2 days. There are some preliminaries that need to be met before making it public
00:55:58 <EvanR> there is type composition, but i don't know if you gain much
00:56:27 <jusss> dminuoso: but (->) is in value, type, and kind, why (.) isn't...
00:56:29 <dminuoso> EvanR: Its probably better not to touch something involving polykinds :-P
00:56:43 * hackage pantry 0.1.1.2 - Content addressable Haskell package management  https://hackage.haskell.org/package/pantry-0.1.1.2 (MichaelSnoyman)
00:56:48 <dminuoso> Though in all fairness I already did
00:56:53 <freeman42x> MarcelineVQ, "No one's going to send you something as personal as a resume if they don't know what they're hoping to work on" is this not clear enough about what the project is about? "free and open source project that would improve the quality of life of Haskell developers"
00:57:07 <MarcelineVQ> Not even a little
00:57:12 <dminuoso> jusss: The type system is a bit different in some respects.
00:57:17 <MarcelineVQ> That describes every single thing on hackage
00:57:27 <freeman42x> davean, "a resume for working on an open source project? Either you contribute code or you don't - theres no interview and acceptance process!" please abstain from imposing your rules onto how others do things. Thank you
00:57:33 <dminuoso> MarcelineVQ: Perhaps the project is about contributing on every single package on hackage?
00:57:42 <EvanR> is MaybeT a thing now? I thought it was ExceptT
00:57:52 <dminuoso> EvanR: huh?
00:57:56 <jusss> dminuoso: how to express "compose type functions"?
00:57:58 <EvanR> maybe i'm thinking of EitherT
00:58:00 <MarcelineVQ> EvanR: ? MaybeT is the first transformer I ever sawed
00:58:02 <dminuoso> EvanR: You probably are :)
00:58:14 <dminuoso> jusss: Strictly speaking you could use :.: I showed earlier
00:58:16 <dminuoso> jusss: However!\
00:58:20 <freeman42x> cocreature, "send us your resume and we might grant you the privilege of working for us for free" it's working for a free and open source project - no-one would get paid for working on it. But people working on it would benefit since they could showcase it in their projects portofolio
00:58:28 <dminuoso> jusss: The type system works differently, :.: is not exactly "evaluated to some definition"
00:58:40 <EvanR> :t runMaybeT
00:58:42 <lambdabot> error: Variable not in scope: runMaybeT
00:58:45 <dminuoso> jusss: So :.: sort of acts like composition, but it creates a new type in the process.
00:59:17 <dminuoso> jusss: Though I reckon you could write a type alias for composition if you wanted...
00:59:42 <MarcelineVQ> The point people are making is that requiring anything more than contribution isn't a productive route to starting OSS.
00:59:46 <freeman42x> dminuoso, "Perhaps the project is about contributing on every single package on hackage?" I would prefer to be clear in exactly what the project does after I make it public on GitHub in 1-2 days. To give more details: it will drastically reduce the time wasted on failed stack builds
01:00:06 <MarcelineVQ> Be aware as well that "they could showcase it in their projects portofolio" is the same as asking an artist to work "for exposure"
01:00:23 <freeman42x> MarcelineVQ, "requiring anything more than contribution" what do you mean by that?
01:00:48 <dminuoso> Asking people to send resumes before they even get told what kind of project it is, let alone contribute, is silly.
01:00:52 <freeman42x> MarcelineVQ, lots of people do work on free and open source projects. Why are you being so negative?
01:00:59 <dminuoso> I mean you are free to impose any restrictions you want, dont get me wrong.
01:01:29 <dminuoso> Even job avertisements, where you get paid for your work, tell you what your position entails and what you will be working on.
01:01:32 <dminuoso> Without sending a resume.
01:01:42 <jusss> dminuoso: then what it's used to? Maybe :.: IO
01:01:47 <freeman42x> dminuoso, are you even reading the share or the IRC messages above? "free and open source project that would improve the quality of life of Haskell developers" <- this limits the scope of what the project is about quite a lot
01:02:00 <MarcelineVQ> I'm not being negative, I'm trying to explain why you're not going to get any bites, so that you might do things in a way that could gain interest
01:02:00 <dminuoso> jusss: Its when we want to capture the composition as a separate entity.
01:02:04 <freeman42x> dminuoso, exactly, and I did say what the project is about
01:02:10 <dminuoso> freeman42x: No you did not.
01:02:22 <cocreature> you gave some vague hints at best
01:02:22 <freeman42x> dminuoso, "free and open source project that would improve the quality of life of Haskell developers"
01:02:22 <davean> freeman42x: the point is it is n't open source, do your project how ever you want but clearly hte source is closed.
01:02:27 <dminuoso> freeman42x: Is this a GHC type checker plugin for dependent typing? Is it an emacs integration fixing ghc mod?
01:02:32 <dminuoso> I have no idea what this is.
01:02:40 <winny> is it a devops gig to manage ci/cd
01:02:52 <winny> documentation writing?
01:02:55 <winny> yadda.
01:02:57 <dminuoso> Or perhaps a tool for assisting blind people writing haskell code?
01:03:02 <freeman42x> davean, "the point is it is n't open source, do your project how ever you want but clearly hte source is closed." this does not parse for me. I do not understand what you mean
01:03:15 <jusss> dminuoso: I don't get it...
01:03:26 <dminuoso> jusss: Here's the thought
01:03:28 <freeman42x> dminuoso, "Is this a GHC type checker plugin for dependent typing" no. as I said. it is a tool that would help reduce wasted time on failed stack builds
01:03:41 <dminuoso> freeman42x: An improved type system would do that.
01:03:55 <freeman42x> dminuoso, it could be many things, but saying what it is for is reason enough to get people interested
01:04:14 <Ferdirand> look, you know what's even more common than people working on open source projects ? people without clue who think they have a genius idea but are unable to implement it themselves, and want to get other people to do it but keep all the credit.
01:04:18 <freeman42x> anyway, advice taken
01:04:42 <rhylx> Hi guys :D. I wanned to know if some of your guys already tried to build an instant messaging server (like for WhatsApp for example). I wanned to do it in haskell. After looking up a bit I found the wire messenger project and was wondering what do you think of it? Is it a good starting point to reach my goal, or should I try to do it all from scratch again? Do you know other similar projects that could help me?
01:04:44 <Ferdirand> i'm not saying that's what you are, but you need to distinguish yourself from them if you want anyone to be interested
01:04:56 <freeman42x> when I make the project public on GitHub in the next 2 days it will be very clearly explained what its goal is and how it does it
01:05:13 <dminuoso> freeman42x: A more pragmatic approach is advertising your project in say reddit and the mailing list, outlining what your software does, how it works and how people benefit from it. People will contribute on their own if they consider your project useful or interesting enough. :)
01:05:23 <dminuoso> But asking for resumes, in my opinion, is not a fruitful approach.
01:05:24 <cocreature> freeman42x: what people here are trying to tell you is that it is not enough for them. ofc you might still get lucky and find others for whom it is enough but giving as much detail as possible might increase the pool of people that get interested.
01:05:56 <dminuoso> jusss: So (:.:) is a type constructor at the end, so its not just a type function.
01:06:16 <freeman42x> dminuoso, "A more pragmatic approach is advertising your project in say reddit and the mailing list, outlining what your software does, how it works and how people benefit from it." I totally agree. But the project is not published yet and not ready for reddit etc. The project is ready though to accept collaborators
01:06:42 <dminuoso> jusss: `(Maybe :.: IO) Bool` is not equal to `Maybe (IO Bool)`, it's rather comparable to it. The first gives you a brand new type in comparison.
01:06:49 <freeman42x> dminuoso, "But asking for resumes, in my opinion, is not a fruitful approach." I'm just trying to make sure that if someone joins very soon they would at least have a good track record and not do anything bad
01:07:02 <freeman42x> after I make the project public that will not matter anymore
01:07:06 <dminuoso> jusss: The usefulness stems from being able to write instances like `instance (Functor f, Functor g) => Functor (f :.: g)` which only works if :.: computes a new type
01:07:26 <dminuoso> freeman42x: Judge their PR requests, judge their feedback in issues then.
01:07:27 <MarcelineVQ> A resume is proof of previous experience usually used to guaged whether someone it worth working with. Asking for a resume is asking someone to share their personal history and information. This is not a thing you do for some random person on the internet, which is what people are in OSS.
01:07:37 <freeman42x> cocreature, yeah, I get that I gave only basic idea of what the project is about. But that is fine. I do not want too many people to join.
01:07:45 <freeman42x> We are already 3 people working on this.
01:08:03 <MarcelineVQ> You can ask for it but the asking is not going to draw people near, it'll push them away
01:08:20 <davean> freeman42x: open source definitionally is how people can interact with the project. This isn't open source right now.
01:08:38 <cocreature> Even if you are only looking for a small number of people, being able to draw from a larger pool can give you more qualified candidates.
01:08:38 <freeman42x> dminuoso, "Judge their PR requests, judge their feedback in issues then." sure. As I said, I asked for CV ONLY because I can not let anyone see the code before I make it public. That is the ONLY reason
01:08:49 <dminuoso> jusss: The thing is, while you have things like "type functions" and sort of "evaluation at the type level", its a different language. The type system in itself can be thought of a separate programming language that isnt concerned with "database calls" or "drawing images"
01:09:02 <tdammers> freeman42x: if you want to make it open source, just 1) write the code, 2) publish it (and tell people about it), 3) wait for people to offer help; when they do, there is no need to vet them as persons, all you need to do is audit their patches before you accept them
01:09:14 <MarcelineVQ> If you're that worried you should ask for a psych profile instead of a resume
01:09:22 <freeman42x> MarcelineVQ, "it'll push them away" again, this is fine. Also, not sure working with people that give up on an idea so easily are people you would want to work with
01:09:30 <MarcelineVQ> What idea?
01:09:31 <tdammers> freeman42x: if, however, you want to go the proprietary road, then you need to be prepared to pay people market salaries
01:10:03 <tdammers> in the latter case, asking for a resume is reasonable, but just for being "allowed" to give you free stuff? that's weird.
01:10:11 <freeman42x> tdammers, I agree, read my explanation: I asked for CV because I have not published the code yet. once the code is public CV would not matter anymore, only the PRs obviously
01:10:22 <tdammers> so it's proprietary
01:10:34 <dminuoso> Why not release your code now? 
01:10:53 <dminuoso> Whatever you seem to be doing, it's evidently not in the spirit of free and open software.
01:11:02 <cocreature> Or just wait 2 days until you can publish the code and start looking for contributors then
01:11:03 <tdammers> ^ this. if the goal is to go open source, then do it *right now*. release early, release often.
01:11:33 <tdammers> or, again, keep it proprietary and compensate people for their work
01:11:40 <freeman42x> I'm not releasing the code now since I still have a few steps until the program would be able to solve some classes of build issues. And let's just say that any person that would join the project before I would make it public would pose a risk to the project - not going to say what risk exactly
01:11:59 <Ferdirand> what will a single person be able to do in two days, that your existing team cannot do, anyway
01:11:59 <dminuoso> That sounds not fishy at all.
01:12:09 <freeman42x> cocreature, why can't we have BOTH? look for contributors now and look for contributors later? what is wrong with that? since that is what I am doing
01:12:12 <MarcelineVQ> Wouldn't want someone without a CV pressing the end the world button on the master ai
01:12:17 <jgt> haha wow
01:12:31 <jgt> send a résumé to contribute to open source, for free?!
01:13:00 <freeman42x> anyway, I'm out. It seems I have to re-explain what I said to every person who just pops in here and fails to read the messages. jgt cough
01:13:09 <MarcelineVQ> Nothing wrong with looking for constributors, you're willfully missing the point people are making, the issue is not being specific enough about what you're working on and asking for a resume.
01:13:10 <cocreature> freeman42x: because as you might have noticed from the conversation here, people are actively turned away from your project by this
01:13:18 <jgt> hey, if there are any takers for this, I can make you a better deal. Come and work on my software — no résumé necessary!
01:13:21 <MarcelineVQ> resume's have monetary value, they are personal information
01:13:21 <davean> freeman42x: Yah no one has bought your explanation yet
01:13:32 <davean> freeman42x: and it doesn't matter if they did, because its clearly not open source given said constraint.
01:13:37 <dminuoso> I somehow suspect that freeman42x has a business idea, and is trying to hire people without having to pay them.
01:13:39 <tdammers> freeman42x: the problem is not that people don't understand what you're saying. People do understand, we're just telling you that you're wrong.
01:14:05 <dminuoso> And he wants to have other people write proprietary code for them. It's just a theory..
01:14:29 <freeman42x> cocreature, it does not matter. I will make the project opened in about 2 days and then I will look for contributors again. Jesus. Is it that hard?!
01:14:33 <jgt> dminuoso: it's going to be amazing! It'll be like Facebook, but… better! And we'll make money from… ads? I don't know that's not important. Anyway, I'll tell you what I want, then you build it, and you'll get a share of the profits. Please sign this NDA.
01:14:50 <dminuoso> This "making it public now would pose a risk to the project - not going to say what risk exactly" sounds ultra fishy to me.
01:14:58 <MarcelineVQ> I doubt anything nefarious is happening here but it's really not a useful route.
01:15:16 <Ferdirand> freeman42x: come back in two days and stop wasting everyone's time then
01:15:32 <freeman42x> dminuoso, "I somehow suspect that freeman42x has a business idea, and is trying to hire people without having to pay them." jesus f## christ. REALLY dude? I am trying to get people to work for TWO days on proprietary software? what else? the earth is flat? fairies live in your head and... who knows what else
01:15:56 <tdammers> freeman42x: it's not hard at all. There are two ways of getting people to work on your project that work. The first one is to pay them for it. The second one is to give them the entire code, and allow them to do with it whatever they want (at your discretion with the sole restriction that whatever changes they make, they have to publish under the same conditions to anyone who wants them, including yourself)
01:16:00 <MarcelineVQ> dminuoso: how is Fairy Steve anyway?
01:16:07 <freeman42x> tdammers, "we're just telling you that you're wrong." and actually it is you who is wrong. There is nothing wrong with mentioning before or after making it open
01:16:20 <dminuoso> MarcelineVQ: Pardon me?
01:16:39 <MarcelineVQ> dminuoso: Fairy Steve, didn't he move in a couple months ago?
01:16:39 <tdammers> freeman42x: no, there's nothing wrong with it, we're just telling you that what you want won't happen. People will not contribute unless you a) pay them, or b) go open source
01:16:49 <davean> tdammers: having to republish is a GPL restriction, not an open source restriction
01:16:57 <dminuoso> MarcelineVQ: You lost me completely here.
01:16:58 <tdammers> davean: yes, hence, "at your discretion"
01:17:06 <freeman42x> tdammers, "people won't help you" there are already 2 other people working on it...
01:17:16 <freeman42x> ok, I am out for real now. closing IRC
01:17:54 <jgt> some people get really weird when you spell out reality for them
01:18:08 <tdammers> yup
01:18:18 <MarcelineVQ> that was really weird, he wasn't reacting to things people were actually saying
01:18:28 <davean> MarcelineVQ: thats not so weird sadly.
01:18:34 <tdammers> it's often easier, psychologically, to consider oneself attacked than to face reality
01:18:38 <davean> I'd like it to be weirder
01:19:04 <rhylx> Hi guys :D. I wanned to know if some of your guys already tried to build an instant messaging server (like for WhatsApp for example). I wanned to do it in haskell. After looking up a bit I found the wire messenger project and was wondering what do you think of it? Is it a good starting point to reach my goal, or should I try to do it all from scratch again? Do you know other similar projects that could help me?
01:19:05 <dminuoso> tdammers: In all fairness, everybody telling him that they are obviously doing it wrong could easily lead to feeling attacked
01:19:35 <tdammers> dminuoso: yes, but that's just human psychology. it happens even when people do it in the most respectful and factual manner possible
01:19:45 <tdammers> (which, granted, is not how IRC culture generally plays out)
01:20:09 <MarcelineVQ> rhylx: Depends a bit, do you just want to make an app or you want to learn all the parts building up to it?
01:21:01 <dminuoso> Honestly Im still trying to figure out what their motivation is.
01:21:08 <tsahyt> what tools are there to make core output more readable?
01:21:15 <tsahyt> or is everyone just doing this manually
01:21:21 <dminuoso> tsahyt: I think everyone is doing it manually
01:21:29 <tsahyt> ah well, okay
01:21:32 <davean> dminuoso: My best guess if they want to stay in control and in front of the project
01:21:36 <MarcelineVQ> -dsuppress-all is your friend
01:22:02 <MarcelineVQ> and other surpressing sort of things, 'cause I think it can get smaller than just what that option does
01:22:36 <hc> this git repository is going to be made public in 1-2 days, right? we'll find out then :)
01:23:02 <dminuoso> Or perhaps they are busy cleaning the git history?
01:23:07 <tdammers> oh dear
01:23:09 <tdammers> yeah
01:23:12 <tdammers> probably full of passwords
01:23:21 <jgt> rhylx: this might be a decent starting point: https://www.yesodweb.com/book/wiki-chat-example
01:23:38 <dminuoso> Honestly this is the one idea here that actually makes a bit of sense.
01:23:39 <rhylx> MarcelineVQ : the final goal is to have a working app, to have something "Facebook free", but I would like to understand how it is working. Actually, the best would be just to tweak and understand an existing project that's working :). But if it doesn't exist, and if it is not a life project, I'm ready to learn all the parts.
01:23:45 <tdammers> frankly, I don't even think you could get to the point where you can even start onboarding someone in only 2 days
01:24:06 <tsahyt> MarcelineVQ: thanks, I'll look into that
01:24:14 <dminuoso> tdammers: To even use the word "onboarding" for volunteering on an free OSS project is... strange.
01:24:18 <tsahyt> I should really learn how to read core efficiently
01:24:33 <davean> dminuoso: They don't need the history of course
01:24:51 <tdammers> dminuoso: I think we have, by now, established that this isn't an OSS project yet, and likely will not be in the future, not beyond "it's technically open source" at least
01:24:52 <MarcelineVQ> tsahyt: even ghc devs want core tools, I'm not really sure why something hasn't come along given how smart those guys are
01:25:53 <dminuoso> tdammers: I wonder whether it's actually that his lawyer needs 2 more days to hammer out the licensing, so he can have volunteers producing code for them - but maintain the monopoly of what he hopes to be a gold mine.
01:26:01 <tdammers> MarcelineVQ: "those guys" are smart and very busy writing smart code. Core tools aren't smart code, you don't get any papers out of writing them, you won't get any deep new insights, you just end up with a tool that works, which you already knew you could build when you started building it
01:26:31 <tdammers> dminuoso: could be. I guess we'll never find out.
01:26:33 <tsahyt> tdammers: but that tool might help you write papers down the line by making your life easier
01:26:48 <tsahyt> i.e. you have more time writing papers rather than studying core output
01:27:11 <MarcelineVQ> I wonder, I bet you could get a paper out of writing a core comparer and transformer
01:27:12 <tdammers> tsahyt: true. though IME smart people can be surprisingly un-pragmatic when it comes to practical things
01:27:25 <tsahyt> tdammers: or they don't expect the productivity boost to be worth the effort
01:27:41 <tdammers> tsahyt: also, you can hire people to study core output for you. this is in fact something that is happening.
01:27:47 <dminuoso> MarcelineVQ: Or perhaps publish a paper first and then have say Ryan implement it!
01:27:49 <tsahyt> ah yes, the infamous phd student
01:27:55 <freeman42x> ok, based on your feedback I added clear description of what the project goal is and how it achieves it: https://twitter.com/razvan_panda/status/1166253123880607750 also mentioned that it will be made open in about 2 days
01:28:25 <hc> why not look for contributors in 2 days, then?
01:28:29 <dminuoso> freeman42x: Cheers, that's really helpful. :)
01:29:18 <tsahyt> meanwhile I'm struggling to even connect the code to the core output in any meaningful way
01:29:22 <freeman42x> dminuoso, I do take feedback into account :p
01:29:35 <dminuoso> freeman42x: Mind my asking. Are you merely afraid that releasing non-functional code might deter people interested in your project?
01:29:45 <rhylx> MarcelineVQ: the final goal is to have a working app, to have something "Facebook free", but I would like to understand how it is working. Actually, the best would be just to tweak and understand an existing project that's working :). But if it doesn't exist, and if it is not a life project, I'm ready to learn all the parts. (sorry for that typo)
01:29:52 <tdammers> "Important note: this is not a paid job offer, but by contributing to this project you would have something useful to showcase in your resume." -- you realize that this is going to be considered a huge red flag by the majority of the target audience?
01:30:54 <dminuoso> But indeed, that remark is still truly strange.
01:31:02 <tdammers> most of us have been there a thousand times. someone trying to low-ball you, getting free labor out of you, saying things like "I can't afford to pay you right now, but it'll all be worth it in the future"; "I'll pay you in shares"; "It'll be great on your resume", etc.
01:31:03 <freeman42x> dminuoso, "Mind my asking. Are you merely afraid that releasing non-functional code might deter people interested in your project?" no, that is not the problem
01:31:15 <tdammers> any of those essentially means most people will be out
01:31:20 <davean> tdammers: code you already knew you could write is exactly what you put undergrads on :)
01:31:33 <freeman42x> dminuoso, ok, I will tell you why I am not making it public yet. because I do not want someone to possibly steal the hackage name for it...
01:31:55 <freeman42x> so I need to get it working before I publish to hackage because I do not want to publish a package that does not do what it says
01:31:59 <dminuoso> Oh right I remember, you did mention that some days ago. :)
01:32:06 <freeman42x> dminuoso, yeah, I did :)
01:32:22 <MarcelineVQ> This could be a good thing to add to stack instead of being a separate project depending on how it's to be tackled
01:32:42 <tdammers> so use a codename until you decide to pull the trigger
01:32:54 <dminuoso> freeman42x: See, had you mentioned that right away in your twitter, there wouldn't have been wild guessing around these mysterious "but why dont you"
01:32:55 <freeman42x> tdammers, "any of those essentially means most people will be out" this is perfectly fine! not EVERYONE needs to join. But anyone that WOULD join would be a great help for the Haskell community since creating this tool is something quite useful
01:33:17 <dminuoso> freeman42x: By keeping details hidden, it just creates distrust and that wont develop volunteers.
01:33:39 <freeman42x> MarcelineVQ, "This could be a good thing to add to stack instead of being a separate project depending on how it's to be tackled" of course I have considered this. The project will be usable as a library. If the stack folks want to use it they can import the library and add some stack argument to run it.
01:33:54 <davean> freeman42x: you can reserve the hackage name
01:33:56 <freeman42x> The reason I am not trying to do this in the stack codebase because I am pretty sure there would be resistance
01:34:08 <freeman42x> davean, how can I reserve a hackage name?
01:34:14 <dminuoso> davean: with an empty package?
01:34:17 <davean> dminuoso: yah
01:34:52 <freeman42x> dminuoso, "See, had you mentioned that right away in your twitter" <- I'm not perfect nor a mind reader. Your guys feedback is great and I appreciate it
01:35:17 <freeman42x> got some link to how I could reserve the name?
01:35:19 <tdammers> freeman42x: "most people" as in "practically everyone worth having on the project". you will be left with a bunch of inexperienced / naive people who don't have any significant real-world programming experience
01:36:03 <freeman42x> tdammers, "a bunch of inexperienced / naive people" do not underestimate people! also, if someone would be turned down by what I said then I would probably not want to work with them regardless. Too close minded
01:36:32 <tdammers> nothing to do with open-mindedness, it's just economics
01:36:43 <freeman42x> tdammers, <<"most people" as in "practically everyone worth having on the project">> <- also I am pretty sure you are wrong about this. Good people WILL join. I know for sure from past experience
01:36:49 <tdammers> I wouldn't want to sink my time into a project without at least some degree of confidence that it'll be worth it
01:37:02 <dminuoso> freeman42x: So here's some tips: If you have a good idea and want more help, release your code - and then tweet/mailing list/reddit about your project, saying what it does and how it works, how people benefit from it. Ask for volunteers, and don't mention this "this is not a paid job offer" - if people come they come, if they dont they dont. :)
01:37:12 <dminuoso> Just be open about everything.
01:37:12 <freeman42x> tdammers, do you think that this project will not be worth it?
01:37:14 <tdammers> I have actually joined such projects several times, and it never ended well
01:37:37 <tdammers> it might be worth it, but the evidence at hand says it's not likely
01:37:59 <dminuoso> freeman42x: Its hard to say in general. The general description in itself seems like a good idea, but one would have to look at the code to say.
01:38:00 <jgt> freeman42x: it may be a good idea for you to read Social Architecture by Pieter Hintjens
01:38:01 <freeman42x> dminuoso, "If you have a good idea and want more help, release your code - and then tweet/mailing list/reddit about your project, saying what it does and how it works, how people benefit from it." - I am well aware of this and this is exactly what I was going to do. BUT the project is not ready for reddit etc.
01:38:12 <freeman42x> the project will be ready for reddit after it is made public on GitHub
01:38:17 <dminuoso> freeman42x: Then dont tweet about it. Wait 2 days, and then do it fully public.
01:38:23 <dminuoso> :-)
01:38:27 <jgt> freeman42x: it may help you build the open source community you want, and to understand why people would join your cause, and why they might avoid working with you
01:38:48 <freeman42x> jgt, "Social Architecture by Pieter Hintjens" cheers, added to my reading list
01:39:05 <davean> freeman42x: there is a time for recruiting people pre-release but its usually from a pool of people you have an initial credability/social credit with.
01:39:14 <jgt> RIP, old drinking buddy
01:39:26 <freeman42x> dminuoso, "Then dont tweet about it." <- bad advice
01:39:56 <jgt> imho it was good advice
01:41:00 <rhylx> jgt: so according to you wire messenger isn't a decent starting point?
01:41:33 <jgt> rhylx: that's not what I said
01:41:44 <tdammers> but what's more important is that there are thousands of other things out there that I could work on, and they're all either open source or willing to pay me, so no matter which one I pick, I will at least get paid, or I will at least have something that I can use and share. That's what you're competing against.
01:41:47 <jgt> rhylx: it might be a good starting point; I'm just not familiar with it
01:41:49 <freeman42x> jgt, in my expert opinion your and his expert opinion is wrong. There is nothing wrong with the fact I shared about it on Twitter. I will just share again after I make it public
01:42:05 <rhylx> jgt: Okok :)
01:42:18 <dminuoso> freeman42x: Not the fact that you shared the idea, just the way you approached it.
01:42:39 <dminuoso> freeman42x: Anyway, that remark about "not a paid offer" is really a strong red flag for me.
01:42:59 <freeman42x> dminuoso, true, mistakes were made. I corrected them by listening to the feedback you guys gave: I provided concrete details of what the project is about and mentioned when it will be made public
01:43:00 <dminuoso> It really does have this taste of "Im planning to make money off of it, but I cant pay you - but it looks good on your resume, so consider it worth your time"
01:43:11 <dminuoso> Despite of what you actually intent to mean by it.
01:43:18 <dminuoso> It's merely what I understand when I read it.
01:43:19 <davean> I've never had to have it made clear to me it wasn't a paid offer even when it was freeware but not open source
01:43:26 <freeman42x> dminuoso, I was just being honest. Did not want people to contact me and want to be paid for something we are doing for the community for free...
01:43:49 <davean> (I use to work on Legends back when it was based off a closed-source engine but was done with an open source ethos as much as possible by the dev team)
01:44:16 <davean> freeman42x: if you thought there could be confusion you already knew there was a problem with how you framed it.
01:44:52 <jgt> freeman42x: I just don't understand your approach at all. If it were me, I'd make my own first stab at solving the problem. It would probably be a bad attempt, but hopefully I'd get _something_ working. *Then* I would present it to the community and say "Hey, here's this thing I made. It helps with x. Could you help me fix y?"
01:45:49 <jgt> if it's a successful open-source project, then contributors being able to show their contributions as experience is already a given
01:46:12 <jgt> it's not clear to me why it's important for you to have a pool of willing contributors ahead of time
01:46:14 <freeman42x> jgt, I'm trying to be more efficient by asking for help sooner. I think it is a good idea
01:46:39 <freeman42x> the sooner people contribute the sooner we deliver this free and open source software to the community
01:46:41 <Silent_Alex>  _something_ 
01:46:43 <freeman42x> it's win-win
01:46:43 <jgt> well I disagree. I just don't think people work that way, and I think my opinion is supported by the various responses you've seen here.
01:47:20 <Silent_Alex> how to send the word with the symbol for underline?
01:47:36 <davean> freeman42x: what you're saying makes sense but seems to miss important points - people remember. This isn't an isolated event. Your next action will come from this history.
01:47:37 <freeman42x> `I just don't think people work that way` it is fine. The people that would join early would be more fit for the project anyway
01:47:46 <jgt> Silent_Alex: are you asking what the word for `_` is?
01:48:02 <freeman42x> davean, what do you mean?
01:48:05 <Silent_Alex> yes, man!
01:48:10 <jgt> Silent_Alex: underscore
01:48:35 <cocreature> freeman42x: you might want to look into what haskell-ide-engine does. It has a bunch of “quickfixes” that turn GHC errors into quickfix hints that you can click on in your IDE to perform the change.
01:48:46 <Silent_Alex> Yes, underscore
01:49:05 <freeman42x> cocreature, yeah, I know that HIE does that. But how is that related to the project I presented?
01:49:21 <dminuoso> freeman42x: Well it's thematically related.
01:49:41 <jgt> yeah it does seem quite related
01:49:42 <freeman42x> dminuoso, so... why did you mention it?
01:50:47 <dminuoso> freeman42x: It was a helpful pointer I believe? Some sort of "Perhaps you don't want to have overlapping features, or perhaps you can integrate your project in a similar manner, or perhaps there's positive interaction between your project and the other project"
01:50:52 <dminuoso> That's how I'd take it.
01:51:52 <Silent_Alex> __s_
01:52:10 <cocreature> freeman42x: you want to parse errors and fix them automatically. haskell-ide-engine parses errors and turns them into edits that fix the error. That seems very much related.
01:52:53 <Unhammer> can I use a quickcheck generator directly in a test (e.g. in the repl) without making a new instance Arbitrary?
01:52:54 <Unhammer> let mygen=arbitrary`suchThat`foo in quickCheck (\x -> howDoIUseMyGenHere)?
01:55:25 <ski> @type forAll
01:55:27 <lambdabot> (Show a, STestable prop) => Gen a -> (a -> prop) -> Test.QuickCheck.Safe.SProperty
01:56:34 <freeman42x> dminuoso, the project we are working on will be a success if either it gets integrated into stack being used as a library and used as a build argument OR the folks that created stack will start implementing the automatic fixes as an optional stack argument as part of the stack codebase (so no weird parsing is required)
01:56:48 <dminuoso> ski: I wonder, why is there no exists?
01:57:12 <freeman42x> cocreature, I get that it is related. But... what is your point with it? I mean, look. Cats... are like dogs... do you get where I am going with this? Me neither...
01:57:12 <ski> what would a counter-example to it be ?
01:57:30 <ski> s/to/for/
01:57:31 <dminuoso> ski: Not being able to generate a value that satisfies the prop?
01:57:37 <dminuoso> Oh
01:57:39 <dminuoso> I see what you mean
01:58:03 <freeman42x> ehm. Does anyone know how I could reserve a hackage package name? the sooner I know the sooner I can publish it even though
01:58:09 <jgt> freeman42x: I believe his point was that the other project may provide inspiration for how you might implement your own project
01:58:15 <Taneb> dminuoso: smallcheck has an exists
01:58:24 <cocreature> freeman42x: I’m trying to give you helpful pointers that might help you with your projects. no need to get defensive
01:58:37 <jgt> freeman42x: and I don't think you'll get far by being rude to people who are trying to help you
01:59:05 <freeman42x> cocreature, I am not being defensive. I am just stating that I did not get what the purpose of comparing them was
01:59:19 <freeman42x> jgt, I am not being rude...
01:59:50 <jgt> freeman42x: since you are one person thinking you're not being rude, and you have several people here interpreting you as being rude, which do you think is the more likely case?
02:00:04 <ski> QuickCheck is sortof the scientific method, or dual-intuitionistic logic, or something. you try to thoroughly test a property by experiments, and assume it's plausibly true if none fails. if there's a failure, that will hopefully give you some concrete insight into why the property failed
02:00:32 <jgt> freeman42x: you might not intend to be rude (and hopefully that's the case), but the way you've communicated here has certainly been interpreted by most people as quite rude
02:00:38 <freeman42x> jgt, "several people here interpreting you as being rude" who are these several people? you are the first person to say anything at all
02:00:54 <cocreature> *raises hand*
02:00:59 <jgt> alright, I give up. Good luck with your project :)
02:01:02 <davean> freeman42x: I'll go on record as thinking you're rude. Others have been aluding to it
02:01:20 <freeman42x> cocreature, ah, ok. fair. I apologize if I sounded rude to anyone. That was definitely not my intention
02:02:18 <Unhammer> ski,  thanks! (I stupidly skipped reading about forAll because for some reason I thought it was the thing that runs everything that starts with prop_ …)
02:04:11 <ski> Taneb : interesting
02:04:50 <Taneb> ski: I've been told why it can do exists and quickcheck can't, but I really can't remember. It's something fundamental about how they generate test cases
02:06:06 <Taneb> Ah, section 3.5 of https://www.cs.york.ac.uk/fp/smallcheck/smallcheck.pdf
02:06:12 <cocreature> quickcheck doesn’t even have a semi-decision procedure for exists afaik since it isn’t guaranteed to get to any given element in the search space in finite time. smallcheck explores the search space exhaustively
02:06:13 <Taneb> smallcheck can exhaustively search for a small witness
02:08:26 <Ferdirand> how expensive are lift/hoist ? as a general principle, if I want to accept a pure monad stack and lift it in IO, is it okay to ask the caller to provide something polymorphic on the bottom monad type instead, and let it be specialized ?
02:09:28 <ski> Taneb : hm, yea, i was just thinking of covering the search space
02:09:43 * ski . o O ( Martín Escardó )
02:19:45 <freeman42x> so... is it possible to reserve a hackage name?
02:20:17 <Taneb> freeman42x: not until you've got something to put there, as far as I know
02:20:54 <freeman42x> Taneb, well, I got a project to put there. But I do not want to upload it since it is not yet doing what it says it does - it is only partly implemented
02:21:28 <Taneb> freeman42x: well, you'd better work quickly and hope nobody else takes the name ;)
02:21:43 <cocreature> freeman42x: have you tried the candidate suggestion I gave you a few days ago?
02:21:44 <Taneb> Actually, I'm not that up to date on policy. Maybe it's changed in the past few years
02:22:11 <freeman42x> Taneb, hahaha, let's be serious... they will never guess what I would call it!
02:22:37 <freeman42x> cocreature, I did already upload a candidate for it. Does that prevent other people from taking the name?
02:23:00 <cocreature> I think so but I’m not certain
02:24:16 <tsahyt> this might be getting a bit ridiculous, but is there a way to use SSE intrinsics in GHC? maybe via some primops magic?
02:24:47 <tsahyt> I'd like it to emit rsqrtss rather than doing a sqrt and a division.
02:24:51 <Putonlalla> I've used AVX with it before, so I'd imagine so, tsahyt.
02:25:04 <tsahyt> Putonlalla: can you point me to some resources on this?
02:25:13 <Putonlalla> https://github.com/Tuplanolla/ties341-profiling/blob/master/Step10.hs
02:25:49 <Putonlalla> It's a make-your-own-adventure kind of deal.
02:26:12 <ociule> hey guys, can you help me understand this function declaration ? "atStart :: Monad m => RSTParser m a -> RSTParser m a"
02:26:32 <tsahyt> Putonlalla: well ideally I want to end up with a function like rsqrt :: Double -> Double, which hides all the magic
02:27:05 <tsahyt> Putonlalla: this is btw not a packed instruction
02:27:18 <ociule> I read through the examples in learnyouahaskell, like "lucky :: (Integral a) => a -> String" that's easy, but in atStart, there's a whose type's was never defined whihc is confusing
02:27:34 <Putonlalla> I don't immediately see a way to do that, tsahyt.
02:29:06 <asheshambasta> http://hackage.haskell.org/package/hedis-0.12.7/docs/Database-Redis.html#v:setnx -- when dealing with Redis, this method lets you set a key only if it doesn't exist. It returns a Boolean. Now, I'd like to set something else if the result of this call was a True (see multiExec in this module). But it seems like the value returned is in a Queued type; which is a monad. How do I impose that condition? 
02:29:11 <tsahyt> I guess I could always go through the FFI, but that might cost more than its worth
02:30:05 <Putonlalla> I wonder if it's possible to write a GHC plugin that extends the primitive replacement rules.
02:33:16 <dmitri> Hey folks, anyone can help with stack install errors: https://gist.github.com/dmitriz/da2273909bae3cc45ca870427b32c6d5#file-install-errors
02:34:15 <dmitri> What exactly does this recommendation mean: try adding the following to your extra-deps
02:35:03 <dmitri> I don't have any "extra-deps" in that file
02:35:36 <hvr> that looks confusing...
02:39:13 <tsahyt> from what I can tell this would require modification of the compiler
02:39:17 <tsahyt> not exactly practical
02:46:34 <asheshambasta> dmitri: you need to add extra-deps in your stack.yaml 
02:47:07 <dmitri> asheshambasta: how precisely? any example?
02:47:50 <asheshambasta> dmitri: https://gist.github.com/asheshambasta/4cd56f2339443dba8e1e1b91a45aae24
02:48:51 <asheshambasta> dmitri: see https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md
02:56:12 * hackage sparse-tensor 0.2.1.1 - typesafe tensor algebra library  https://hackage.haskell.org/package/sparse-tensor-0.2.1.1 (nalex)
03:01:22 <pycer> is it correct that Haskell Programming from first principles has a new edition?
03:07:02 <no-n> I'm only aware of a new RC
03:09:18 <no-n> are you talking about RC4?
03:09:58 <no-n> that's the one I'm reading :I
03:10:07 <no-n> 1.0RC4
03:10:47 <jusss> dminuoso: I found out I misunderstand something, f . g is function composition, not Functor composition
03:11:12 <jusss> so what is Functor composition and what it's used to?
03:18:05 <nbouscal> jusss: not sure of the context here, but Functor composition would basically be fmap . fmap
03:23:49 <tsahyt> :t fmap . fmap
03:23:51 <lambdabot> (Functor f1, Functor f2) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
03:24:08 <tsahyt> nbouscal: or you could compose the functor types
03:24:19 <tsahyt> :t Data.Functor.Compose.Compose
03:24:20 <lambdabot> forall k1 k (f :: k -> *) (g :: k1 -> k) (a :: k1). f (g a) -> Data.Functor.Compose.Compose f g a
03:24:33 <tsahyt> which I guess is a bit scary because of all the kind signatures
03:24:37 <tsahyt> but it's rather straight forward
03:25:05 <tsahyt> :t GHC.Generics.(:.:)
03:25:06 <lambdabot> error:
03:25:06 <lambdabot>     Not in scope: data constructor ‘GHC.Generics’
03:25:07 <lambdabot>     No module named ‘GHC’ is imported.
03:25:13 <tsahyt> well, same thing though
03:25:23 <nbouscal> tsahyt: yep, then you have a newtype with a Functor instance where fmap = fmap . fmap :)
03:25:35 <tsahyt> exactly. so you compose two functors and get a functor.
03:26:01 <tsahyt> sometimes it's nice not to nest a bunch of fmaps
03:26:24 <nbouscal> note that jusss was the one asking about this :)
03:26:31 <ski> (it would be `(GHC.Generics.:.:)', anyway)
03:26:41 <tsahyt> oh right
03:27:59 <nbouscal> gs
03:28:13 <nbouscal> sorry mt
03:28:20 <kuribas> I know that lists can be used as streams, as they are garbage collected, but is there an abstraction for streams that doesn't allocate a list?  Or do you just rely on list fusion?
03:29:32 <nbouscal> kuribas: not sure if this is what you're asking, but there are quite a few streaming libraries, e.g. pipes, conduit, streamly, streaming, probably more
03:29:47 <kuribas> nbouscal: yeah, but they require IO
03:29:54 <tdammers> you can also think of Chan (and TChan, etc.) as streams
03:30:01 <tdammers> but they require IO, too
03:30:13 <kuribas> yeah, maybe that doesn't make sense without IO...
03:32:12 <tdammers> well, if you want a pure stream, then there are only so many ways you can write it; one way or another, it boils down to a lazy data structure that has one thunk for the "current item", and another thunk that holds a recipe for producing the remaining stream
03:32:15 <tdammers> but that's literally a list
03:32:25 <kuribas> yeah, that's true
03:32:50 <ski> @type GHC.Exts.build
03:32:52 <lambdabot> (forall b. (a -> b -> b) -> b -> b) -> [a]
03:32:53 <ski> @type flip (flip . foldr)
03:32:55 <lambdabot> Foldable t => t a -> (a -> c -> c) -> c -> c
03:32:55 <tdammers> you can of course provide stream-like interfaces over other data types, e.g. lazy bytestrings or lazy text
03:34:11 <tdammers> (in fact, I have just written one such abstraction to give me tightly-packed arbitrary-length bit arrays, using bytestrings under the hood)
03:34:19 <kuribas> and garbage collection is cheap in ghc right?
03:34:24 <ski> the Church encoding `forall o. (a -> o -> o) -> o -> o)' of `[a]' could perhaps in some sense be thought of as providing a stream, hmm ?
03:36:26 <ski> (but then one could consider alternative representations, like `forall o. (exists s. (s,s -> o,s -> a -> s)) -> o', or `forall s. (s -> a -> s) -> s -> s' which is intended to correspond to `foldl', while the previous one corresponded to `foldr')
03:36:36 <tdammers> kuribas: yes, it's fairly cheap, especially for things that are this fundamental to idiomatic Haskell
03:38:51 <ski> in the latter one, `[2,3,5,7]' is represented as `\step init -> step (step (step (step init 2) 3) 5) 7' (or, with the slightly more involved former one, `\(init,end,step) -> end (step (step (step (step init 2) 3) 5) 7)')
03:39:48 <ski> while with the previous one corresponding to `foldr', it'd be `\cons nil -> cons 2 (cons 3 (cons 5 (cons 7 nil))'. so the two are inside-out, as compared to each other
03:40:51 <kuribas> ski: but is it cheaper than a list?  A closure still needs to be allocated
03:41:08 <ski> in any case, you don't materialize cons cells. once you know what to do with the elements, know the consuming parts, you can start producing them, and just feed them to the consumption
03:42:18 <ski> so, the list is emphemeral. however, if you'd want to retain some part, you'd have to start converting back to something like `[a]', rather than just processing elements in your loop
03:43:56 <ski> kuribas : i think it depends on how you construct the element stream. if your basic operations support this kind of fusion idea, i think it could be fine
03:44:42 <ski> (i'm suspecting that the representation using both `forall' and `exists' could be preferable, for such purposes)
03:46:19 <ski> (s/start producing them/start producing the elements/)
03:52:54 <mycroftiv> tdammers: i saw you mention bitarray/bytestring code, im working with bitstrings of potentially infinite length and going back and forth between functions to produce them and lists of integers, wondering if the code you mentioned you wrote is up anywhere and could be referenced/borrowed
03:57:23 <tdammers> mycroftiv: unfortunately no, it's currently part of a package I am writing for a paying customer, so I cannot disclose, but it might be released as open-source at some point
03:58:22 <tdammers> the idea is fairly simple; you have a data structure that holds a bytestring with the raw data in it, plus two integers for the "lead" and the "trail", the number of bits to be ignored on either end of the bytestring
03:58:57 <tdammers> this way, you can do things like defer copying until you need to convert the bitstream into some other data format
03:59:19 <tdammers> things like take or drop are reduced to merely adjusting the lead or the trail
04:22:50 <mycroftiv> tdammers: thanks for the conceptual information
04:35:12 * hackage gscholar-rss 0.2.2.0 - scrapes google scholar, provides RSS feed  https://hackage.haskell.org/package/gscholar-rss-0.2.2.0 (fffaaa)
04:58:04 <jgt> looks like the `st` quasi-quoter in Shakespeare doesn't support comments :(
05:04:33 <Ferdirand> what's the story of Show1 in Data.Functor.Classes ?
05:05:28 <Ferdirand> I have code that used to work with an older GHC, using Show deriving, and it started complaining of a missing Show1 instance
05:06:10 <Ferdirand> there's a similar issue described on stackoverflow but the accepted answer is to enable TH and use deriving-compat, which sounds fishy
05:07:39 <lyxia> what's the problematic type definition?
05:08:14 <Ferdirand> newtype Coloring t = Coloring [(Style, t)]
05:08:21 <Ferdirand> Style is Show already
05:08:48 <Ferdirand> ghc 8.0 accepted "deriving Show" and would simply add (Show t) to the constraints
05:08:57 <kuribas> tdammers: isn't that how bytestrings works already?  If you drop some elements, it just advances the start index.
05:09:10 <Ferdirand> but i'm not sure if it is a problem of ghc version, or if it is because system-installed ghc vs stack
05:09:30 <lyxia> Show deriving shouldn't have changed for this type
05:09:48 <lyxia> what's the error message?
05:10:40 <lyxia> I mean, Show deriving hasn't changed ever. One possible scenario I could think of is if one of the types involved has changed its Show instance.
05:11:07 <kuribas> maybe because an enabled extension?  
05:11:19 <kuribas> like GeneralisedNewtypeDeriving, or DeriveAny?
05:11:28 <Ferdirand> ah sorry, it seems to be caused by the other type definition: newtype Colored s = Colored (Free Coloring s)
05:11:44 <Ferdirand>  Could not deduce (Show1 Coloring)
05:11:45 <Ferdirand>         arising from the first field of ‘Colored’ (type ‘Free Coloring s’)
05:12:20 <lyxia> in version 5 of the free library the Show instance of Free changed. https://hackage.haskell.org/package/free-5.1.1/changelog
05:13:51 <Ferdirand> i thought i would solve it by implementing Show1 by hand
05:14:04 <lyxia> yes that's one common way to do it.
05:14:07 <Ferdirand> but then it complains that showsPrec1 is a hidden method
05:14:26 <Ferdirand> so i thought i was definitely doing something wrong
05:15:05 <Ferdirand> ah, wrong base version when reading the docs, ok
05:16:41 <Ferdirand> thanks lyxia 
05:16:57 <lyxia> you're welcome!
05:22:09 <tdammers> kuribas: yes, but bytestrings have 8-bit granularity, I need 1-bit
05:33:48 <kuribas> ah right!
06:07:42 * hackage semigroups 0.19.1 - Anything that associates  https://hackage.haskell.org/package/semigroups-0.19.1 (ryanglscott)
06:09:42 * hackage hs-rqlite 0.1.1.0 - A Haskell client for RQlite  https://hackage.haskell.org/package/hs-rqlite-0.1.1.0 (kderme)
06:15:44 <duncan> Is it pronounced requelle-light? :)
06:23:42 * hackage bifunctors 5.5.5 - Bifunctors  https://hackage.haskell.org/package/bifunctors-5.5.5 (ryanglscott)
06:29:43 * hackage generic-deriving 1.13 - Generic programming library for generalised deriving.  https://hackage.haskell.org/package/generic-deriving-1.13 (ryanglscott)
06:33:19 <ypyf> \quit
06:37:42 * hackage semigroupoids 5.3.3 - Semigroupoids: Category sans id  https://hackage.haskell.org/package/semigroupoids-5.3.3 (ryanglscott)
06:39:13 * hackage reflection 2.1.5 - Reifies arbitrary terms into types that can be reflected back into terms  https://hackage.haskell.org/package/reflection-2.1.5 (ryanglscott)
06:41:57 <yorick> is there a way I can configure `stack` to cache built packages across CI runs?
06:43:05 <yorick> there's already a $HOME/.stack, but it doesn't cache dependencies
06:43:33 <vaibhavsagar> yorick: what about $PROJECT_ROOT/.stack-work
06:43:44 <yorick> projects are git cleaned between ci runs
06:44:09 <vaibhavsagar> well, that's probably why
06:46:05 <tdammers> for CI purposes, I'd prefer a slow but realistic run over an efficient but brittle one
06:46:29 <yorick> yeah, but, are dependency caches brittle?
06:46:35 <tdammers> I'd want the question I ask CI to be "if I take a pristine machine, download the code, and build it, will it work?"
06:46:52 <yorick> we mostly do nix-based CI, which does this for us
06:47:03 <tdammers> let's just say I've have to delete / flush package caches a few times with both stack and cabal
06:49:59 <cocreature> as long as I don’t install a custom exception handler, I shouldn’t see exception handlers being run on sigsegv right?
06:52:36 <asheshambasta> what's the recommended way to go if during upgrading to a new GHC version (in my case, a new stack resolver), fails due to a dependency no longer compiling? https://gist.github.com/asheshambasta/6332516ba31e987e28b25787644d9de6 
06:53:22 <cocreature> asheshambasta: patch the dependency and open a PR and while waiting for the PR to be merged and a new release point to your git branch in extra-deps
06:54:18 <asheshambasta> cocreature: also, is it safe to assume (since the dependency compiles with earlier versions of GHC) that this is due to breaking changes in GHC? 
06:54:27 <simon> yorick, I thought actually that the CI tool was responsible for caching the files that you point it to, e.g. Travis CI's 'cache: directories: - $HOME/.stack'
06:54:33 <asheshambasta> by 'breaking' I mean backwards incompatible. 
06:55:32 <cocreature> asheshambasta: existing code not compiling with newer versions is pretty much the definitions of “backwards incompatible”
06:55:42 <Taneb> asheshambasta: with a different resolver, not necessarily. It may have picked a different version of the library which made intentional changes
06:56:00 <cocreature> oh right, yeah it’s only true if everything else is fixed
06:57:23 <asheshambasta> Taneb: in this case, it is perplexing that this seems like a popular library which seems to be no longer maintained. 
06:57:35 <simon> yorick, sorry, didn't read what you wrote properly wrt. dependencies cache.
06:58:05 <asheshambasta> And it is not in lts-14.3; hence I'm just adding it as an extra-dep and pointing to its latest available version. 
06:58:21 <cocreature> asheshambasta: I think you might be overestimating the popularity of composite-base. This is the first I hear of it.
06:59:14 <asheshambasta> cocreature: Hackage reports 220 downloads in the last 30 days. 
07:00:09 <yorick> simon: I do cache $HOME/.stack, yeah
07:00:29 <Taneb> asheshambasta: which library?
07:01:00 <asheshambasta> Taneb: http://hackage.haskell.org/package/composite-base
07:01:05 <sm[m]> asheshambasta: those are probably not humans
07:01:12 * hackage stack-fix 0.1.0.0 - Console program used to fix Stack build errors automatically  https://hackage.haskell.org/package/stack-fix-0.1.0.0 (freeman42x)
07:01:35 <cocreature> hackage download numbers are weird. They exclude a fair amount of users since they get it not directly from hackage and include automatic mirrors and other automatic downloads.
07:02:13 <freeman42x> cocreature, there we go. I published it in an incomplete state heh
07:02:41 <asheshambasta> I see, and what is a good metric for estimating the popularity (and hence the future prospects of maintainability) of dependencies? This seems like a dead-end to me. I'm close to a release deadline and I, at present, cannot fork/patch a bunch of other libraries that no longer compile. 
07:03:24 <cocreature> postpone the upgrade after the release deadline :)
07:04:08 <maralorn> > I see, and what is a good metric for estimating the popularity (and hence the future prospects of maintainability) of dependencies?
07:04:10 <lambdabot>  <hint>:1:6: error: parse error on input ‘,’
07:04:18 <maralorn> I very much seond that question.
07:05:08 <maralorn> Deciding on which library to use seems to me to be the hardest part of real world Haskell right now.
07:05:11 <cocreature> reverse deps give you some idea but I don’t think there is a great way
07:07:34 <asheshambasta> I see, however this is becoming a huge problem with more devs in our team and with the size of the project (and hence its dependencies) also getting large. 
07:07:43 * hackage th-desugar 1.10 - Functions to desugar Template Haskell  https://hackage.haskell.org/package/th-desugar-1.10 (ryanglscott)
07:09:12 <asheshambasta> and is there a way on hackage to see the packages that depend on a certain package/version? 
07:09:14 <haasn> alternative is to not overuse dependencies
07:09:31 <haasn> sometimes you don't need that fancy library for X but a 100-line reimplementation would cover your needs
07:09:42 <asheshambasta> haasn: there's a fine line between that and reinventing the wheel, imo. 
07:10:10 <haasn> point is, if you're ever stuck in dependency hell, the way out of it is to reduce the number of dependencies
07:10:29 <haasn> )that doesn't mean never use them)
07:11:28 <asheshambasta> haasn: the thing is, the only way to do that is to reimplement the functionality yourself. Since the features your application must provide will keep increasing, so you either need to add more features in your application code: either by means of dependencies or by means of rewriting them yourself. 
07:12:21 <haasn> maybe the best approach is to use dependencies initially and replace them by in house reimplementations if those dependencies start being a problem
07:12:30 <__monty__> asheshambasta: This seems to list reverse deps: https://packdeps.haskellers.com/reverse Not sure if there's a more official way though.
07:12:48 <phadej> http://packdeps.haskellers.com/reverse/these
07:12:50 <phadej> e.g.
07:13:18 <phadej> but IMHO this is bad metric
07:13:38 <phadej> "I know a maintainer" emprically proved to be better
07:14:37 <dminuoso> phadej: Though realistically, how many people actually do *know* the maintainer?
07:14:58 <phadej> dminuoso: by name? a lot
07:15:06 <__monty__> Clearly it's time for X degrees : )
07:15:18 <__monty__> 6 is probably too many.
07:15:19 <asheshambasta> maybe a good metric could be running a quick regex on #haskell's logs :-) 
07:15:46 <dminuoso> phadej: My point is, I've talked to you a few times and I've seen you in London. But that won't really tell me much about the prospect of maintainability of any of your projects, no offense.
07:16:39 <phadej> dminuoso: yes, it's  not "he is a nice guy" but more of "I like a way how they maintain their libraries"
07:16:57 <phadej> i.e. there are libraries which I'd prefer not to depend upon, even they are popular
07:17:10 <phadej> but that's subjective
07:19:30 <asheshambasta> __monty__, phadej: thanks, that helps identify the culprit that depends on this package.
07:19:43 <dminuoso> I Its an interesting but complex topic. Other factors like blowing up compile time (some kmettiverse packages have a tendency to give you 10 extra minutes of sword fighting), or "the library is so small I could fix issues myself if the need aarises" come into play too
07:20:28 <phadej> yes, and those are preferences
07:20:32 <phadej> either you are ok, or not with them
07:35:32 <maralorn> dminuoso: Is there a map of the kmettiverse?^^
07:35:42 * hackage singletons 2.6 - A framework for generating singleton types  https://hackage.haskell.org/package/singletons-2.6 (ryanglscott)
07:35:57 <phadej> maralorn: https://github.com/phadej/acme-kmett#ghc-844
07:36:22 <tdammers> maralorn: someone started generating one based on available packages, but experts suspect this might not actually terminate
07:36:42 * hackage exceptions 0.10.3 - Extensible optionally-pure exceptions  https://hackage.haskell.org/package/exceptions-0.10.3 (ryanglscott)
07:39:26 <maralorn> Wow^^
07:39:27 <sm[m]> asheshambasta, maralorn: with practice you can judge a haskell package’s quality on various dimensions with pretty high accuracy in about 30s
07:40:13 * hackage hs-rqlite 0.1.1.1 - A Haskell client for RQlite  https://hackage.haskell.org/package/hs-rqlite-0.1.1.1 (kderme)
07:40:56 <sm[m]> Look at last upload date, number of releases, github commit/issue history, quality of readme & changelog, identity of author etc. 
07:42:08 <tsahyt> what if all candidate packages that solve your problem are 0.0.1.0, last uploaded in 2009 by some person you've never heard of, and are not hosted on github to begin with but have a repository link leading you to a long dead darcs repo?
07:42:17 <tsahyt> happens way too often to me
07:43:12 * hackage free 5.1.2 - Monads for free  https://hackage.haskell.org/package/free-5.1.2 (ryanglscott)
07:45:12 <dminuoso> I think `free` should rather have the package description "Money for nothing and the monads for free"
07:45:54 <tdammers> oh wow, "nothing" is still unused as a package name
07:48:12 * hackage constraints 0.11.1 - Constraint manipulation  https://hackage.haskell.org/package/constraints-0.11.1 (ryanglscott)
08:04:12 * hackage deriving-compat 0.5.7 - Backports of GHC deriving extensions  https://hackage.haskell.org/package/deriving-compat-0.5.7 (ryanglscott)
08:11:42 * hackage zeromq4-simple 0.0.0.1 - More constrained extensions to zeromq4-haskell  https://hackage.haskell.org/package/zeromq4-simple-0.0.0.1 (athanclark)
08:13:38 <joel135> When I write C++ my eyes are working full-time to remove the typing information. When I write haskell, they are working to remove variable names.
08:14:12 <sm[m]> tsahyt: then you know have a starting point, not a dependable lib, and act appropriately 😀
08:14:14 <joel135> It's a different focus.
08:15:33 <dminuoso> joel135: C++ has some good styles to make it easier.
08:16:59 <vaibhavsagar> can `criterion` measure memory use, or is it only for execution time?
08:21:54 <dminuoso> vaibhavsagar: The latter.
08:22:05 <dminuoso> vaibhavsagar: You can use RTS profiling to gain information about memory usage.
08:22:09 <vaibhavsagar> hmm, that's what I suspected
08:28:13 * hackage singleton-nats 0.4.3 - Unary natural numbers relying on the singletons infrastructure.  https://hackage.haskell.org/package/singleton-nats-0.4.3 (ryanglscott)
08:40:34 <t7> is there a `stack new` flag that only produces one Lib.hs file (and the stack yaml etc)
08:42:12 * hackage bytes 0.16 - Sharing code for serialization between binary and cereal  https://hackage.haskell.org/package/bytes-0.16 (ryanglscott)
08:43:12 * hackage pipes 4.3.12 - Compositional pipelines  https://hackage.haskell.org/package/pipes-4.3.12 (GabrielGonzalez)
08:44:43 <vaibhavsagar> t7: `stack new simple-library`
08:44:47 <lyxia> t7: you can customize your own templates
08:46:14 <vaibhavsagar> I don't think that's necessary for this particular use case, there are a lot of templates available already: https://github.com/commercialhaskell/stack-templates
08:46:42 <t7> vaibhavsagar: perfect thanks
08:46:46 <vaibhavsagar> weirdly, if you wanted to have a library with a `package.yaml` instead of a `.cabal` file, you might have to use your own template
08:52:13 * hackage eliminators 0.6 - Dependently typed elimination functions using singletons  https://hackage.haskell.org/package/eliminators-0.6 (ryanglscott)
08:55:07 <AWizzArd> Why would you use monad-logger over fast-logger?
08:57:29 <dminuoso> AWizzArd: monad-logger separates the "I want to log" with "how logging should be implemented"
08:58:20 <dminuoso> AWizzArd: So monad-logger is mainly useful if you write some library for someone else to use, and dont want to lock them into a particular logging framework.
08:59:38 <dminuoso> Or if you, yourself, want to replace the logging backend down the road, or even trially support multiple ones
08:59:38 <dminuoso> In addition monad-logger offers many quality of life utilities like TH helpres
09:00:24 <tabaqui> also, it is very usefull if you want to log in concurrent application
09:00:56 <tabaqui> s/in/inside a (?)
09:01:03 <AWizzArd> dminuoso: I like the TH helpers that come with monad-logger. But it basically locks me in to use one specific (fast-) logger configuration.
09:01:12 <dminuoso> AWizzArd: no it does not.
09:01:29 <dminuoso> AWizzArd: runLoggingT and supply your own logging implementation.
09:01:32 <dminuoso> voila.
09:01:45 <dminuoso> AWizzArd: monad-logger just happens to re-export fast-logger as some defaults for you to use
09:01:50 <AWizzArd> dminuoso: how would you specify in a call to  ($logInfo)  which of your three loggers you want to use?
09:01:56 <dminuoso> AWizzArd: You dont.
09:02:05 <dminuoso> AWizzArd: You specify it at your runLoggingT 
09:02:07 <tabaqui> right, you can run your own backend, f.e. STM.Queue in my case
09:02:26 <geekosaur> that's not how that works, although I suppose I could see a backend which had a way to select other backends based on various information
09:02:55 <dminuoso> Indeed, monad-logger assumes you have exactly one logging implementation which must be supplyed by the consumer of your LoggingT stack :)
09:03:50 <dminuoso> geekosaur: Though monad-logger could be used by supplying approprate tags in the Other log level, then your implementation can discriminate on that and pick different backends.
09:03:56 <AWizzArd> dminuoso: L's say you are working with a web server and have one  AppTpT  transformer, and for it you provided one implementation of MonadLogger.  Now every call to logSomething gets handled by this single implementation.
09:04:46 <c_wraith> dminuoso: or you could have a custom instance of MonadLogger that wraps StateT and uses the state to switch backends. 
09:05:32 <AWizzArd> dminuoso: I _could_ nearly use the Source as dispatcher. But I do't like this idea, as I can easily missspell those literal Text values.
09:05:46 <dminuoso> AWizzArd: Id say use LogOther
09:06:00 <c_wraith> (or for RIO compatibility, uses an IORef stored in the environment) 
09:06:16 <dminuoso> AWizzArd: And then have your implementation filter out LogOther and dispatch them to a separate backend. :)
09:06:17 <AWizzArd> dminuoso: I am thinking about having my own TH layer, which simply takes one extra arg, and on that one I can dispatch to any logger instance.
09:06:21 <geekosaur> AWizzArd, monad-logger gives you a thing-that-logs. It gives you a specific one that wirks for simple cases; other logging backends provide their own; or you can write a custom one that fits your needs, including picking between other dminuoso as dminuoso suggested
09:06:29 <geekosaur> er. oops
09:06:33 <geekosaur> between other backends
09:06:46 <AWizzArd> dminuoso: when using LogOther I still need to specify backend _and_ log level. This info is lost there.
09:06:48 * geekosaur is not sure what this webchat thought it was doing there
09:07:02 <dminuoso> AWizzArd: Sure. Im not saying it's ideal, but you could trivially encode it in the text.
09:07:11 <dminuoso> AWizzArd: Or you use an IORef or StateT like c_wraith suggested.
09:07:15 <geekosaur> didn't .. that
09:07:32 <geekosaur> I'd probably go wwith StateT unless IORef were really needed
09:08:04 <geekosaur> monad-logger is a minimal interface, not a maximal one; your instance can have a switch-target API of its own
09:08:06 <AWizzArd> geekosaur: in principle monad-logger's interface is fine. I just wanted something like logWarnS but with my own value instead of a Text.
09:08:28 <AWizzArd> How hard is it to have a thin TH layer above monad-logger's?
09:08:43 <dminuoso> AWizzArd: https://hackage.haskell.org/package/monad-logger-0.3.30/docs/Control-Monad-Logger.html#t:ToLogStr
09:08:43 <dminuoso> AWizzArd: You dont have to supply text!
09:08:43 <dminuoso> AWizzArd: Just implement that interface, then you can supply whatever you want.
09:09:42 <AWizzArd> dminuoso: https://hackage.haskell.org/package/monad-logger-0.3.30/docs/Control-Monad-Logger.html#v:logDebugS
09:09:43 <dminuoso> AWizzArd: Take note of the type signature in https://hackage.haskell.org/package/monad-logger-0.3.30/docs/Control-Monad-Logger.html#v:monadLoggerLog
09:10:03 <AWizzArd> This doc string says it takes a LogSource and I found:    type LogSource = Text
09:10:36 <dminuoso> AWizzArd: Well you could copy that implementation and use a different type :)
09:10:43 <dminuoso> logDebugS = [|\a b -> monadLoggerLog $(qLocation >>= liftLoc) a LevelDebug (b :: Text)|]
09:11:01 <dminuoso> logDebugSV = [|\a b -> monadLoggerLog $(qLocation >>= liftLoc) a LevelDebug (b :: V)|]
09:11:01 <AWizzArd> Okay, so that already IS the implementation of logDebugS?
09:11:07 <dminuoso> AWizzArd: Yes.
09:11:18 <dminuoso> AWizzArd: You can click on "Source" to the right on haddoc to quickly see source code
09:11:40 <AWizzArd> Do I just need to add {-# LANGUAGE TemplateHaskell #-} at the top of my file and can then start using TH?
09:12:07 <jgt> AWizzArd: yes
09:12:34 <AWizzArd> If [| ... |] is the quasiquoter - how does it know _which_ reader macro I want to run?
09:12:57 <AWizzArd> I would understand this if it said:  [logger| ...|]
09:13:26 <JoelMcCracken> can it tell based upon the type of the output? i wonder
09:13:36 <geekosaur> that's a TH quote, not a logger quote
09:13:39 <dminuoso> AWizzArd: Check the GHC manual on Th
09:13:57 <dminuoso> AWizzArd: It's a good read.
09:14:03 <geekosaur> and it knows from the type context of the splice what quoter to use
09:14:11 <dminuoso> AWizzArd: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-TemplateHaskell
09:14:13 <geekosaur> or, here, of the quoter
09:14:53 <dminuoso> geekosaur: I wonder, can you guess why the TH was monomorphized to Text there, and not polymorphic over ToLogStr?
09:15:38 <AWizzArd> dminuoso: +1 to that question
09:16:56 <geekosaur> at a guess, because it's supposed to be a convenient shorthand and they didn't think of that use case. the alternative is it gave ghc too much rope
09:17:04 <geekosaur> (consider Text vs. String)
09:17:29 <AWizzArd> Thx for your inputs guys.
09:17:55 <geekosaur> (the point of that one, if it's not clear, being that there might need to be a bunch of RULES pragmas to keep ghc from constantly unpacking and repacking things in some cases)
09:18:22 <geekosaur> mono-traversable package being an example of that
09:23:22 <AWizzArd> dminuoso: how can I specify that I don't want a V in your example, but instead an `a` which implements ToLogStr? I tried just adding that constraint to the signature of that macro and switched on ScopedTypeVariables
09:23:58 <AWizzArd> logDebugSV :: (ToLogStr a) => ExpQ     as the signature
09:24:03 <AWizzArd> logDebugSV = [|\a b -> monadLoggerLog $(qLocation >>= liftLoc) a LevelDebug (b :: a)|]
09:24:47 <AWizzArd> okay, the `a` is already used as parameter, but even if I exchange it with an `x` it won't accept this.
09:26:03 <AWizzArd> Or is there a way to add constraints to lambdas?
09:26:17 <AWizzArd> logDebugSV = [|(ToLogStr b) => \a b -> monadLoggerLog $(qLocation >>= liftLoc) a LevelDebug (b)|]
09:26:36 <geekosaur> you enabled it already
09:26:53 <geekosaur> with ScopedTypeVariables you can say \a (b :: x) -> ...
09:28:00 <geekosaur> but note that yyou also missed a step:  logDebugSV :: forall a. ToLogStr a => ExpQ
09:28:18 <AWizzArd> Ah, the forall, let me try that.
09:28:42 <geekosaur> not sure how that will work with TH though
09:28:55 <AWizzArd> geekosaur: this does not give compiler errors:
09:29:01 <AWizzArd> logDebugSV = [|\a (b :: (FL.ToLogStr x) => x) -> monadLoggerLog $(qLocation >>= liftLoc) a LevelDebug (b :: x)|]
09:29:31 <geekosaur> use it before asserting that :)
09:29:42 <AWizzArd> geekosaur: oki, le's see
09:34:14 <wroathe> With happy/alex (or other preprocessors), what would be the point of letting Cabal manage running those tools? Doesn't that just put unnecessary burden on the person who wants to install your package to have those tools on their system, when you can just run them before publishing your package?
09:35:02 <geekosaur> they have runtime components, which would need to be present
09:35:45 <geekosaur> with C, libfl runtimes etc. are usually installed already. not so for haskell lib runtimes
09:36:55 <wroathe> geekosaur: Huh? Doesn't happy just output a Haskell module?
09:39:40 <wroathe> Yeah, just as I thought, Happy doesn't even include it's own .y file in it's published package
09:40:41 <geekosaur> hm, so it seems. nor alex. I thought both had runtime componnts, but I see only templates
09:41:04 <geekosaur> which I presume are expanded to produce the output file, rather than referenced from it
09:41:12 <wroathe> Yup, you're correct
09:41:44 <wroathe> It would make sense to let Cabal manage this if it had different build modes depending on whether it's a development build or a regular build
09:41:53 <wroathe> Maybe Cabal does have that feature, which I'm not seeing?
09:42:03 <Phyx-> build flags?
09:42:08 <wroathe> i.e. maintainer-build vs just build
09:44:07 <wroathe> Phyx-: Looking
09:45:26 <wroathe> https://github.com/mrkkrp/megaparsec/blob/master/megaparsec.cabal#L61
09:45:37 <wroathe> Oh, you're talking about this. That should work just fine.
09:46:59 <wroathe> The need for if/else seems a little janky. I wonder if there's a build profiles style feature
09:47:38 <geekosaur> flags sometimes get used that way
09:50:13 <ski> hm, is there a name to do `let foo :: forall a. ..a..; foo = ..a.. in foo', without having to give a name to `foo' ?
09:52:51 <lyxia> (...a... :: forall a. ...a...)
09:56:43 <boxscape> Had a discussion here a few days ago whether you can have type application as something other than the first argument. The general consensus was that you can't, but I found out today that you *can*, you just need an appropriate type signature. For example, while `fromInteger 3 @Int` doesn't work, it *would* work if fromInteger had the type `Integer
09:56:44 <boxscape>  -> forall a. Show a => a`
09:56:52 <boxscape> (and you can write a wrapper around fromInteger with that type)
09:57:18 <ski> hm, i tried that, lyxia, but it seemed that the latter `a' wasn't in scope in the former. perhaps i misinterpreted some diagnostics, though
09:57:58 <lyxia> I'm positive ScopedTypeVariables allow that
09:59:28 <ski> yea, that's what i would have expected. i'll try again and try to figure out what went on. ty
10:16:38 <dmwit> % ([] @a :: forall a. [a]) :: String
10:16:39 <yahb> dmwit: ""
10:16:51 <dmwit> Seems to work.
10:18:24 <DigitalKiwi> i think pandoc is removing target and ref in anchor tags in my hakyll site?
10:19:32 <ski> (i suppose i was wanting the closest to `/\ a. ..a..')
10:20:21 <dmwit> wroathe: What is the benefit of distributing Haskell files instead of binaries?
10:20:35 <dmwit> The answer to "why distribute .y files instead of Haskell files" is essentially the same.
10:24:53 <dmwit> % ([] :: forall a. [a]) @Char
10:24:53 <yahb> dmwit: ""
10:25:05 <dmwit> ski: That seems also to be possible...?
10:25:31 <dmwit> % (fromInteger :: Integer -> forall a. Num a => a) 5 @Rational
10:25:31 <yahb> dmwit: ; <interactive>:104:17: error:; * Illegal polymorphic type: forall a. Num a => a; Perhaps you intended to use RankNTypes or Rank2Types; * In an expression type signature: Integer -> forall a. Num a => a; In the expression: fromInteger :: Integer -> forall a. Num a => a; In the expression: (fromInteger :: Integer -> forall a. Num a => a) 5 @Rational
10:25:58 <boxscape> % :set -XRankNTypes
10:25:58 <yahb> boxscape: 
10:26:04 <boxscape> % (fromInteger :: Integer -> forall a. Num a => a) 5 @Rational
10:26:04 <yahb> boxscape: 5 % 1
10:26:09 <ski> % ([] @a :: forall a. _)
10:26:09 <yahb> ski: ; <interactive>:108:21: error:; * Found type wildcard `_' standing for `[a1]'; Where: `a1' is a rigid type variable bound by; the inferred type of <expression> :: [a1]; at <interactive>:108:11-21; To use the inferred type, enable PartialTypeSignatures; * In an expression type signature: forall a. _; In the expression: ([] @a :: forall a. _); In 
10:26:11 <dmwit> neat
10:26:30 <ski> % :set -XPartialTypeSignatures
10:26:30 <yahb> ski: 
10:26:31 <ski> % ([] @a :: forall a. _)
10:26:31 <yahb> ski: ; <interactive>:110:21: warning: [-Wpartial-type-signatures]; * Found type wildcard `_' standing for `[a1]'; Where: `a1' is a rigid type variable bound by; the inferred type of <expression> :: [a1]; at <interactive>:110:11-21; * In an expression type signature: forall a. _; In the expression: ([] @a :: forall a. _); In an equation for `it': it = ([] 
10:27:00 <boxscape> % :set -Wno-partial-type-signatures
10:27:01 <yahb> boxscape: 
10:27:09 <boxscape> % ([] @a :: forall a. _)
10:27:09 <yahb> boxscape: []
10:27:14 <ski> hm, okay
10:27:41 <ski> a little bit awkward, but seems ok, i suppose
10:48:43 * hackage PyF 0.8.0.1 - Quasiquotations for a python like interpolated string formater  https://hackage.haskell.org/package/PyF-0.8.0.1 (guibou)
10:52:43 * hackage hsinspect 0.0.2 - Inspect Haskell source files.  https://hackage.haskell.org/package/hsinspect-0.0.2 (tseenshe)
11:16:27 <maralorn> So what is the realation between the GHC Proposals process and the Haskell 2020 process? Is GHC Proposals kindof trying to compensate for the lack of standardisation progress?
11:24:02 <lyxia> GHC proposals is to try out new features
11:26:51 <geekosaur> GHC standards are about the bleeding edge, H2020 is about the stable trailing edge
11:27:51 <geekosaur> ...and trying to entice other folks to write Haskell compilers, although I think at this point you need so many GHC extensions to compile most things that it's a lost cause :(
11:29:17 <maralorn> Well, how many common languages actually have different working compilers?
11:29:42 <dmwit> C and C++ at least
11:29:49 <dmwit> Python has multiple implementations
11:30:23 <dmwit> For Java there's the Oracle one and the Google one.
11:30:48 <dmwit> Javascript has like a bazillion implementations
11:30:51 <dmwit> So... a lot of them?
11:32:58 <davean> maralorn: what common languages don't?
11:33:03 <boxscape> eta is a non-ghc haskell implementation that works with most of hackage, though it is of course a fork of ghc
11:33:12 <davean> boxscape: non-GHC?
11:33:17 <boxscape> well, it's not ghc
11:33:18 <davean> boxscape: I tihnk you are mistaken
11:33:25 <davean> boxscape: I think you are mistaken
11:33:28 <boxscape> a fork of ghc isn't ghc, is it?
11:34:10 <davean> I mean by that definition basicly GHC isn't GHC, there seems to be thousands of forks of it, thats how the compiler is developed
11:34:34 <boxscape> But the goal of eta isn't to merge back into GHC, it's to be developed separately
11:34:56 <boxscape> they'll likely diverge more and more over time
11:35:11 <mycroftiv> im actually basing my work on older haskell and hugs because the contemporary ghc ecosystem and huge amount of extensions feel way too complicated for me. just a random perspective from a newcomer who loves haskell but also simplicity
11:36:01 <boxscape> what ecosystem do you use with hugs?
11:37:15 <mycroftiv> boxscape: i grab pieces of code from everywhere, see if they work, if they dont, see if theres a simple adjustment. im working on pretty abstract code investigating infinitary mathematics so i dont need a lot of things like web-related or gui-related libs
11:37:26 <boxscape> I see
11:38:08 <boxscape> is infinitary the culmination of n-ary?
11:38:09 <mycroftiv> its not uncommon for me to find interesting blog posts from the 2000-2010 era where the code runs unchnaged in hugs but needs (minor) adjustments for ghc
11:38:19 <boxscape> interesting
11:39:12 <mycroftiv> boxscape: infinitary stuff that is based on work of Martin Escardo's work on infinite sets that admit fast exhaustive search, the intro blog is http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
11:39:19 <boxscape> okay, thanks
11:41:50 <maralorn> dmwit: Perhaps rust?
11:42:06 <maralorn> Ah, davean: I meant. ^
11:42:17 <maralorn> But yeah, I see the point.
11:44:23 <davean> maralorn: definately a commonly talked about language - I tihnk going and saying its a common language already may be a bit premature.
11:44:51 <davean> I'd think go would be a better example from the new language group
11:50:52 <Ariakenom> of course the compatability within a language can vary. a colleague spent a few months porting embedded c between compilers
11:55:33 <rhylx> Hi there :)
11:57:14 <rhylx> I would like to know if someone knows  an instant messaging server project in haskell. I have found wire messenger. What do you think about it?
12:00:13 * hackage hsinspect 0.0.3 - Inspect Haskell source files.  https://hackage.haskell.org/package/hsinspect-0.0.3 (tseenshe)
12:11:42 * hackage hvega-theme 0.1.0.0 - Theme for hvega.  https://hackage.haskell.org/package/hvega-theme-0.1.0.0 (GregorySchwartz)
13:31:56 <vaibhavsagar> when was `>>=` introduced in Haskell?
13:32:08 <vaibhavsagar> the Wadler paper uses `(*)` instead
13:33:59 <vaibhavsagar> I'm looking at the Haskell 1.2 report and it doesn't seem to have any mention of `>>=`, also it uses `[Request] -> [Response]` for IO
13:34:16 <phadej> vaibhavsagar: https://www.haskell.org/definition/from12to13.html
13:34:55 <vaibhavsagar> phadej: I saw that, but it seemed like they already existed in 1.2, but they were moved into a typeclass?
13:34:56 <phadej> as do-notation, looks like it's Gofer heritage
13:35:37 <phadej> vaibhavsagar: monadic IO was also introduced in 1.3
13:35:53 <phadej> that's standard, not GHC tnough
13:35:59 <vaibhavsagar> cool, thanks!
13:35:59 <phadej> nor gofer nor ..
13:37:04 <phadej> anyway, it has been there long enough :)
13:38:29 <wroathe> vaibhavsagar: https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/history.pdf has some good information on the evolution of haskell's IO model
13:38:31 <phadej> so long, that you should either ask directly SPJ or Lennart Augustsson or Wader about those
13:40:11 <phadej> wroathe: it's brief overview, though it contains few anecdotes. lennart commented that e.g. do-notation come from Gofer
13:40:38 <phadej> so if one wants to know answers to "who's idea was to name it >>=" you really should ask those people
13:40:55 <wroathe> Yeah, I was just pointing out additional information
13:41:36 <wroathe> The overview in that paper on streams/continuations/monadic IO was pretty neat
13:51:13 <monochrom> onoes GHC 8.8.1
14:01:17 <boxscape> Seems strange to use * for bind, it looks commutative
14:01:39 <boxscape> or at least symmetric in some way
14:07:57 <monochrom> Oh ghcup has moved to gitlab?!
14:08:52 <monochrom> Ah but I can always refer people to https://www.haskell.org/ghcup/
14:10:21 <monochrom> Wait what is "web design from rustup" supposed to mean?! haha
14:10:43 <ysangkok> rustup is a rust compiler updater like ghcup
14:11:18 <fendor> monochrom, probably that the website design looks identical to the website of rustup?
14:11:25 <monochrom> Oh! It just means web page art-wise design.
14:11:38 <boxscape> What is the usecase for ghcup? (As opposed to, say, just using stack to install ghc?)
14:11:54 <monochrom> I refuse stack.
14:12:07 <boxscape> I suppose that is one valid usecase
14:12:21 <monochrom> More generally, the use case is when there is no use case for stack.
14:12:57 <hvr> boxscape: stack kinda conflates different concerns; sometimes you want just a radio without having to also buy the car around it ;)
14:13:05 <boxscape> okay
14:13:13 <monochrom> For example I inflict Haskell in a course, and most student would be uninterested in Haskell outside the course.  Then they don't need stack.
14:13:23 <boxscape> hm, that makes sense
14:13:28 <monochrom> Instead, they are really better off with ghcup and chocolatey.
14:14:17 <monochrom> In fact IMO stack's use case is a niche use case, not a wide one.  Namely, only when you're so paranoid about reproducible builds.
14:15:01 <fendor> isnt cabal also pretty reproducible if you have a freeze file?
14:15:07 <monochrom> Even cabal can do close-enough-to-reproducible builds now. Yeah, that.
14:15:33 <boxscape> (tbh I don't actually use stack either, I use nix, but of course that also prides itself on reproducible builds)
14:15:34 <vaibhavsagar> what does 'close-enough-to-reproducible' mean
14:16:00 <vaibhavsagar> fun fact, Nix can't do reproducible builds of Haskell packages
14:16:02 <hvr> fun fact: cabal supported reproducible builds long before stack existed :-)
14:16:40 <hvr> (for the meaning of "reproducible" as claimed by Stack)
14:18:01 <monochrom> close-enough means you are not paranoid enough to also pin the OS and the hardware.  There!
14:18:08 <shapr> dolio: would there happen to be existing code demonstrating your answer here: https://cs.stackexchange.com/questions/97031/differences-between-church-and-scott-encoding ?
14:18:29 <vaibhavsagar> monochrom: you don't have to do that in order to get different outputs for the same inputs
14:18:38 <vaibhavsagar> GHC is not yet deterministic
14:19:25 <monochrom> Actually what's GHC's source of non-determinism?
14:19:42 <jle`> i like to personalize all my library builds by using IO to get the current user account name
14:19:42 <vaibhavsagar> monochrom: the unique id supply is one source
14:19:55 <jle`> using TH
14:20:06 <monochrom> haha jle`
14:20:21 <monochrom> Watermarked builds.
14:20:22 <jle`> it gives a nice personal touch i think that many people appreciate
14:20:35 <jle`> like using their name in a newsletter subject
14:20:43 * hackage tidal 1.4.3 - Pattern language for improvised music  https://hackage.haskell.org/package/tidal-1.4.3 (AlexMcLean)
14:20:56 <vaibhavsagar> monochrom: https://gitlab.haskell.org/ghc/ghc/wikis/deterministic-builds#known-sources-of-nondeterminism
14:21:05 <shapr> but for some reason, nobody wants watermarked laptops
14:21:09 <monochrom> Laser-engrave your sweetheart's name on the *.so for the next Valentine's Day.
14:21:13 <vaibhavsagar> jle`: artisanally handcrafted binaries
14:21:39 <vaibhavsagar> haha, the ` in your name throws Matrix off
14:21:59 <vaibhavsagar> that's pretty funny
14:23:27 <jle`> oh, what Matrix?
14:23:47 <monochrom> The 4th Matrix movie Matrix. >:)
14:24:00 <ClaudiusMaximus> shapr: my performance at FARM 2017 https://www.youtube.com/watch?v=eXAURIGlCKw has some church vs scott encoding stuff
14:26:24 <jle`> hm i think it actually wouldn't be too hard to just throw a whoami call into Setup.hs
14:27:50 <monochrom> If I want to use ghcjs, do I build it from source?
14:28:42 <hvr> monochrom: what os/distro are you on?
14:28:45 <shapr> ClaudiusMaximus: whew, I'm not sure that helps me, but I'll watch it later :-)
14:28:47 <monochrom> ubuntu
14:29:17 <shapr> FARM at ICFP 2018 was amazing fun
14:29:28 <shapr> ClaudiusMaximus: is FARM at every ICFP?
14:29:28 <hvr> monochrom: https://launchpad.net/~hvr/+archive/ubuntu/ghcjs may or may not be useful to you
14:30:33 <shapr> any NYC haskellers I haven't met yet?
14:31:56 <ClaudiusMaximus> shapr: i don't know
14:33:01 <jle`> shapr: dmj` perhaps?
14:33:34 <shapr> good idea
14:34:09 <dmj`> shapr: yo
14:34:19 <dmj`> yea I'm here
14:34:27 <dmj`> shapr: you in manhattan?
14:34:58 <shapr> brooklyn, at recurse center
14:38:12 * hackage BNFC 2.8.3 - A compiler front-end generator.  https://hackage.haskell.org/package/BNFC-2.8.3 (AndreasAbel)
15:06:57 <cheater> hi
15:08:10 <cheater> i seem to remember some sort of web related validation api that was based on top of Arrow, but I don't remember what it was. does anyone know it?
15:08:41 <hpc> there's a session thing that uses continuations
15:08:58 <hpc> although, i forget what that's called too
15:09:09 <cheater> hmm...
15:09:26 <cheater> does Servant use Arrow anywhere for normal usage of it?
15:10:01 <alp> no
15:10:22 <cheater> thanks
15:14:23 <NemesisD> is it possible to apply a constraint to all members of a type-level list? e.g. something like `All MyTypeclass xs => proxy (xs :: [*]) -> ....`
15:14:50 <NemesisD> i'm already using singletons if that helps
15:18:12 <lyxia> NemesisD: https://hackage.haskell.org/package/sop-core-0.5.0.0/docs/Data-SOP-Constraint.html#t:All
15:20:57 <jle`> NemesisD: usually people do this with a custom type family or a custom typeclass
15:21:02 <jle`> there's no built-in way in haskell
15:21:27 <NemesisD> lyxia: thanks! this looks like it might work
15:21:58 <jle`> type family All cs where All '[] = '[]; All (c ': cs) = (c, All cs)   -- type family
15:22:33 <jle`> class All cs; instance All '[]; instance (c, All cs) => All (c ': cs)   -- typeclass
15:39:21 <NemesisD> another type-level question, how would you define a function that for instance produces a value for every value in a type-level list? i'm having a hard time figuring out how you'd write an impl for `a ': as` and `'[]`. do you have to use a typeclass?
15:40:03 <jle`> question is a bit unclear
15:40:14 <jle`> you're talking about instances so a typeclass is already presumed
15:40:27 <jle`> oh, you mean 'for instance' in the english sense, not typeclass instances
15:41:37 <jle`> the general thing you need to overcome is type erasure, to produce a value from a type.  so there are a few methods in haskell that allow you to get around type erasure, like GADTs (ie singletons) and typeclasses
15:41:46 <NemesisD> jle`: so i've got a function `f :: Proxy a -> String`, i'm trying to write `g :: Proxy (as :: [*]) -> String` that walks over each `a` and applies `f`
15:42:02 <NemesisD> and concatenates them
15:42:03 <jle`> each type 'a' ?
15:42:16 <jle`> ah yeah, the main thing you have to overcome there is type erasure
15:42:24 <jle`> since the 'as' in g doesn't exist at runtime as you have written it
15:42:27 <NemesisD> each application of `f` peels one value off the type level list
15:43:00 <jle`> the main ways are with typeclasses or gadt's (like singletons)
15:43:23 <jle`> both your f and g have issues of type erasure, actually
15:43:40 <jle`> but yeah, if you replaced Proxy with Sing, you can get `f :: Sing a -> String`; `g :: Proxy as -> String`
15:43:48 <jle`> er, g :: Sing as -> String
15:43:54 <jle`> g SNil = ""
15:44:03 <jle`> g (x `SCons` xs) = f x ++ g xs
15:45:06 <jle`> i tend to prefer GADT and other runtime value-based methods over typeclasses, because typeclasses are global compiler magic that can become unweildy at times 
15:45:16 <jle`> but a lot of people like typeclasses, like the vinyl library 
15:47:58 <delirehberi> Hello fellas
15:48:18 <delirehberi> i have a problem about developing unix socket client
15:48:47 <delirehberi> i am very beginner
15:49:37 <ysangkok> ask yo question
15:49:58 <delirehberi> i will, i paste my code to gist 
15:50:05 <delirehberi> there is my client code https://gist.github.com/delirehberi/c5c239b1134f8befb1c01e4ddf6f2748 
15:50:36 <delirehberi> service is running and socket file exists but i got this error inalys-exe: Network.Socket.connect: <socket: 39>: does not exist (No such file or directory) 
15:50:49 <delirehberi> and i have not any idea for fix it
15:51:17 <NemesisD> jle`: ah! okay. so because singletons gives you a combinator to build a heterogenous list out of singletons, it turns into value-level pattern matching rather than trying to do it in the types
15:51:24 <delirehberi> service socket file permissions is seems ok (srwxr-xr-x) and socket user is ok.
15:52:10 <delirehberi> i think this is not for me (NemesisD) 
15:52:35 <NemesisD> ?
15:53:52 <delirehberi> forget it, your answer, i missunderstood.
15:58:26 <delirehberi> has exists any tutorial about making unix-socket client?
16:17:44 <NemesisD> jle`: after struggling with it a bit i think i understand what you mean by GADTS. you can set up a little one of GADT with a cons/nil and pattern match off that. the benefit too is you can easily put whatever constraints you want into the constructors on that GADT
16:19:18 <NemesisD> plus you can make the GADT be a NonEmpty if you want, e.g. don't provide a Nil
16:23:41 <ysangkok> delirehberi: you should research haskell error handling mechanisms to find which line it occurs at
16:23:57 <ysangkok> delirehberi: or you can just sprinkle your code with Debug.Trace.trace
16:24:54 <delirehberi> unix socket address line occurs this error. haskell thinks socket file not exists
16:24:58 <delirehberi> but there is 
16:27:53 <ysangkok> delirehberi: it is a bit weird that you pass an url to SockAddrUnix, are you sure that is correct? the "unix" part would be redundant, no?
16:28:52 <maralorn> Do I understand correctly that GHC Default haskell (without any feature flags) is not Haskell98?
16:29:33 <delirehberi> ysangkok: this is function`s type: connect :: Socket -> SockAddr -> IO () 
16:30:13 <delirehberi> and thes are socketaddr`s constructors 
16:30:15 <delirehberi> SockAddrInet !PortNumber !HostAddress	 SockAddrInet6 !PortNumber !FlowInfo !HostAddress6 !ScopeID	 SockAddrUnix String
16:30:37 <ysangkok> yeah, that last constructor, why do you think the String is an URL?
16:31:21 <delirehberi> i think i don`t understand what do you mean. SockAddrUnix wants to string
16:31:35 <ysangkok> delirehberi: try removing "unix://"
16:31:42 <delirehberi> i tried allready
16:31:51 <delirehberi> and another error occured
16:31:54 <delirehberi> wait i second
16:32:28 <delirehberi> yes, error is "Left "Error in $: not enough input. Expecting object key""
16:32:41 <delirehberi> so i think it must be urls
16:33:11 <ysangkok> delirehberi: no, there is no reason to think SockAddrUnix takes an URL
16:33:34 <ysangkok> delirehberi: the other error sounds like a JSON error, so it is probably later in your program
16:34:07 <ysangkok> delirehberi: which means it probably didn't error at that earlier spot. but the real way to find out is to learn error handling, as i mentioned
16:34:39 <delirehberi> ysangkok: oh, i got it. you are right.
16:35:56 <delirehberi> thank you, yes left error is caused by another reason 
16:49:27 <cheater> how can Arrow be used for error handling?
17:08:04 <recj>  
17:08:28 <dmwit> ^ this tbh
17:16:43 * hackage Map 0.1.1.0 - Class of key-value maps  https://hackage.haskell.org/package/Map-0.1.1.0 (MatthewFarkasDyck)
17:22:02 <jle`> NemesisD: yeah that's it :)
17:22:50 <jle`> NemesisD: the singleton for list types is actually a special case of vinly's Rec, which you can use for similar GADT-ness
17:22:56 <jle`> *vinyl
17:24:30 <delirehberi> How can i merge two ByteString?
17:25:23 <delirehberi> i can`t find any solution for that, i think, my imo is wrong for this problem.
17:26:15 <delirehberi> i want to recursively run recv (for socket reading) function and merge all results in one variable.
17:26:52 <jle`> merge as in append?
17:27:48 <delirehberi> hmm, is it append in haskell? but how? it is not list or array-like thing. its ByteString
17:28:06 <delirehberi> but ofcourse its list of word8
17:28:07 <jle`> i'm using append as an english word to try to describe what you want to do
17:28:12 <jle`> not literally the append function :)
17:28:23 <delirehberi> hmm ok
17:28:31 <jle`> there are a couple of different ways to "merge" bytestrings
17:28:37 <jle`> or, i mean, to interpret a merger of bytestrings
17:28:49 <jle`> do you mean like a bit-wise & ?
17:28:56 <jle`> or do you mean append? etc.
17:29:37 <jle`> or maybe bit-wise xor, or some sort of zipping function
17:29:58 <delirehberi> i have 2 bytestrings ,  a <- recv socket 1024   and b <- recv socket 1024.  i need a+b. if it would be list i can resolve like that: a++b
17:30:08 <jle`> + as in, additino?
17:30:11 <jle`> *addition
17:30:24 <jle`> ah, you mean you want to append them end-to-end
17:30:32 <delirehberi> yes 
17:31:02 <jle`> you can use its Semigroup instance I think, with <>
17:31:04 <jle`> a <> b
17:31:41 <isovector1> does anyone know how sum types of nullary constructors is represented in memory?
17:31:59 <delirehberi> i don`t know how to work <> operator. but i find append function in bytestring document. append :: ByteString -> ByteString -> ByteString 
17:32:02 <isovector1> wondering just how unsafe it would be to unsafecoerce a bigger sum type into a smaller one
17:32:10 <delirehberi> maybe its resolve this
17:32:15 <jle`> delirehberi: just do `a <> b`
17:32:21 <jle`> it's not any special syntax
17:32:26 <jle`> it's just a normal function, like ++
17:32:31 <delirehberi> hmm i try jle`
17:32:39 <jle`> but yeah, append should work too
17:38:42 * hackage perceptual-hash 0.1.2.0 - Find duplicate images  https://hackage.haskell.org/package/perceptual-hash-0.1.2.0 (vmchale)
17:42:27 <delirehberi> in this gist ( https://gist.github.com/delirehberi/9aea64d6ae279ae445f8de2033c19157 ) i try to fecth full data from socket with recursive function, but i think i missing something. recursive function at after line 46
17:43:08 <delirehberi> i can`t matched types what i try
17:43:37 <delirehberi> it turns lazyBytestring when i use <> operator
17:45:33 <delirehberi> oh shit, i forget wrap with IO 
17:47:45 <jlamothe> Can anyone tell me why ghc's complaining about the type signature on line 189 of this file? https://github.com/mtlstats/mtlstats/blob/wip/test/TypesSpec.hs
17:48:31 <jlamothe> If you clone the repo, it's in the wip branch
18:00:00 <MarcelineVQ> What's the complaint?
18:12:24 <jle`> % unsafeCoerce True :: Ordering
18:12:24 <yahb> jle`: EQ
18:12:36 <jle`> % unsafeCoerce LT :: Bool
18:12:37 <yahb> jle`: False
18:12:39 <jle`> ^ isovector1 
18:12:51 <jle`> it appears to be some sort of byte tag
18:13:26 <jle`> basically the same as non-nullary constructors
18:13:45 <jle`> % unsafeCoerce (Right 3 :: Either Bool Int) :: Maybe Int
18:13:46 <yahb> jle`: Just 3
18:14:15 <jle`> same rules. but i wouldn't expect them to be robust vs optimizations
18:15:36 <jle`> unsafecoercing a bigger type into a smaller type wouldn't cause a segfault, just an out of bounds tag
18:15:46 <jle`> (bigger/smaller nullary Enum)
18:16:10 <jle`> > map unsafeCoerce [False, True] :: [Int]
18:16:12 <lambdabot>  error:
18:16:13 <lambdabot>      Variable not in scope: unsafeCoerce :: Bool -> Int
18:16:20 <jle`> % map unsafeCoerce [False, True] :: [Int]
18:16:20 <yahb> jle`: [140201938876032,-3458763966156717202]
18:16:30 <jle`> % map unsafeCoerce [False, True] :: [Ordering]
18:16:30 <yahb> jle`: [LT,EQ]
18:18:24 <jlamothe> MarcelineVQ: Illegal polymorphic type: Lens' s a  Perhaps you intended to use RankNTypes or Rank2Types
18:19:27 <jle`> jlamothe: well...did you try enabling RankNTypes or Rank2Types? :)
18:20:53 <jlamothe> jle`: Is that a language extension?
18:21:09 <jlamothe> I'm not familiar with it.
18:21:09 <jle`> yes
18:21:20 <jle`> well, what happens when you try enabling it?
18:21:20 <orzo> whenever i need that i always use RankNTypes
18:21:38 <jlamothe> Let me see...
18:21:41 <orzo> does anyone have use for Rank2Types without RankNTypes?
18:21:50 <jle`> Rank2Types is now just an alias for RankNTypes
18:22:12 <orzo> Well, maybe it should be deprecated instead
18:22:21 <orzo> and never mentioned in error messages
18:23:11 <orzo> Now every day, hundreds of people are out there pausing to decide whether to use Rank2Types or go all out with RankNTypes.
18:23:46 <jlamothe> jle`: That seems to have done it.
18:23:49 <jle`> hm yeah, i wonder why the error message would mention both
18:23:51 <jlamothe> Thx
18:24:05 <jle`> np :)
18:33:42 * hackage bowntz 2 - audio-visual pseudo-physical simulation of colliding circles  https://hackage.haskell.org/package/bowntz-2 (ClaudeHeilandAllen)
18:50:31 <dmwit> % map unsafeCoerce ([140201938876032, -3458763966156717202] :: [Int]) :: [Bool]
18:50:31 <yahb> dmwit: [False,False]
18:50:42 <dmwit> I'm starting to think this unsafeCoerce thing isn't a good idea.
18:52:27 <monochrom> @quote monochrom unsafeCoerce
18:52:28 <lambdabot> monochrom says: isTrue = (unsafeCoerce :: Either a b -> Bool) . (unsafeCoerce :: Maybe c -> Either a b) . (unsafeCoerce :: Bool -> Maybe c)
18:52:45 <monochrom> Mine is pretty OK! >:)
18:57:10 <Cale> % map unsafeCoerce (map unsafeCoerce ([140201938876032, -3458763966156717202] :: [Int]) :: [Bool]) :: [Int]
18:57:10 <yahb> Cale: [140201938876032,-3458763966156717202]
18:58:56 <iqubic> % :t unsafeCoerce
18:58:56 <yahb> iqubic: a -> b
19:00:01 <dolio> shapr: I don't know. Which part do you want an example of?
19:10:28 <MarcelineVQ> well now this is just an all around fascinating post http://comonad.com/reader/2011/free-monads-for-less-2/
19:11:05 <MarcelineVQ> was trying to search to see how scott encoding might be related to the codensity transformation and hit on that
19:37:44 <crestfallen> this is what my book says: In turn, the operator <*> applies a state transformer that returns a function to a state transformer that returns an argument to give a state transformer that returns the result of applying the function to the argument
19:38:32 <crestfallen> all the punctuation is included there
19:40:13 <crestfallen> depressing
19:41:54 <crestfallen> there is a diagram but the text does not describe it in a way that I can fathom
19:42:43 <MarcelineVQ> On its own that could be difficult to parse, especially if you've never tried to write your own version of State, but I would bet there's a lot before and after that in the book that prepare you to understand the line.
19:49:17 <MarcelineVQ> When something is completely inscrutable and you're not on chapter 1 of a text, it's usually beneficial to roll back a chapter or two and work back up to the question
20:35:50 <koz_> Do fmap and filter (on lists) fuse?
20:37:48 <koz_> @pl \x -> (x, fromFinite x)
20:37:48 <lambdabot> ap (,) fromFinite
20:42:29 <maerwald> now the useless base upper bound bumping starts again :>
21:02:34 <jackdk> it is our sacred ritual, to stand against the chaos of the unknown
21:04:48 <crestfallen> hi jackdk could you let me know if there are any typos in the paragraph beginning "In turn, the operator <*>..." on the lower left of this screenshot?   thanks   https://pasteboard.co/IuIKteJ.png
21:05:46 <crestfallen> the book just took off into hyperdrive
21:05:57 <jackdk> I do not believe so. (Why are you asking me, specifically?)
21:06:29 <crestfallen> only because you were helpful the other day
21:06:49 <crestfallen> that is such a horrendous paragraph to me
21:07:13 <jackdk> it's pretty hard to read
21:08:15 <turab> crestfallen: Do you think a type signature will help?
21:08:31 <turab> From my understanding, what is being said is the following
21:08:55 <MarcelineVQ> koz_: yes
21:09:09 <crestfallen> "that returns a function to a state transformer..."   which state transformer is receiving the the function, as shown in the diagram?
21:09:50 <crestfallen> the function looks like its being sent to fmap
21:09:55 <turab> <*> takes a an argument of type S (a ->b), and an argument of type S a, and returns S b
21:10:33 <crestfallen> or to function application $
21:11:16 <MarcelineVQ> koz_: You're looking for RULES that mention map and filter in places like https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#map https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.List.html#filter rules called FB and rules that cause the form 'build' to be present tend to be list fusion rules
21:11:19 <turab> Oh wait I just saw the function definition
21:14:02 <jackdk> crestfallen: I'm glad turab has time to help today because I'm busy. Good luck.
21:14:30 <turab> I can try :)
21:14:40 <jackdk> (not trying to be rude, not wording this well.)
21:14:46 <crestfallen> jackdk, turab thanks
21:14:56 <MarcelineVQ> koz_: I say map rather than mentioning fmap because iiuc {-# INLINE fmap #-} fmap = map should ensure that map is what matters
21:15:39 <crestfallen> turab, the 2 previous pages are here: https://pasteboard.co/IuJjn0c.png
21:16:01 <turab> When the book says "a State Transformer that returns a function", it basically means the type ST (a ->b)
21:16:30 <turab> Then when it says "a state transformer that returns an argument", it means the type ST a
21:17:01 <turab> Notice how I say (ST a) specifically. That's because the argument to (a -> b) should be of type a.
21:18:15 <turab> Then with: ST (a -> b) and ST a, <*> will apply (a -> b) to a, and give us a ST b
21:18:36 <turab> Again, notice how I say (ST b). That's because the return type of (a -> b) is type b
21:19:13 <crestfallen> phew
21:19:41 <turab> :/
21:20:44 <crestfallen> turab where the book says "..that returns a function to a state transformer that returns..."  is that 2nd transformer depicted on the diagram?
21:21:02 <crestfallen> ie "to a state transformer"
21:21:28 <crestfallen> depicted by stx in the box?
21:21:47 <crestfallen> the diagram doesn't match
21:22:02 <turab> I think so. I see the paragraph explained in the diagram on the bottom left.
21:22:35 <turab> The rectangle labeled `stf` is the "state transformer that returns a function"
21:22:36 <crestfallen> it looks like the function is sent directly to ($)
21:22:41 <crestfallen> f x
21:23:01 <turab> The rectangle labeled `stx` is the "state transformer that returns an argument"
21:23:22 <turab> crestfallen: Yes, you can see that in the definition of <*> 
21:23:35 <turab> Notice how in the end it says (f x , s'')
21:24:32 <crestfallen> yeah
21:25:47 <crestfallen> so the st being passed from stf to stx is actually the function
21:25:50 <crestfallen> turab, 
21:26:00 <crestfallen> sorry typo
21:26:15 <crestfallen> the state being passed from stf to stx ...
21:26:24 <turab> Did you mean to say something else instead of `st`?
21:26:30 <crestfallen> yeah state
21:27:12 <turab> The state being passed from `stf` to `stx` is s'
21:29:55 <MarcelineVQ> giving state to stf results in a tuple of a new state called s' and a function called f. this is what the line "let (f,s') = app stf s" is doing
21:32:50 <MarcelineVQ> that new state s' is then used to give state to stx, giving a another new state called s'' and a value called x. the last thing we do is apply our function f to our value x because that's what our type signature requires, and bundle that with the last state
21:35:00 <MarcelineVQ> *giving another new state called s'' and
21:36:01 <MarcelineVQ> If the text paragraph in the book is confusing you can throw it away, the code is what matters ultimately. ditto for the diagram since it's just another view of what the code does
21:36:50 <MarcelineVQ> It's a good diagram if you already understand the code hard to say if it's hepful when you don't
21:38:44 <turab> MarcelineVQ: Could one use <$> in the definition of <*> instead of manually applying it?
21:39:51 <rhylx> Hi :). Has anyone heard about wire messenger and has tried to host his own server?
21:40:03 <MarcelineVQ> does fmap give you a new state?
21:40:22 <turab> i.e, can I just say: app (f <$> stx) s'
21:40:27 <MarcelineVQ> Actually I should ask where you mean to use <$> first
21:42:13 <rhylx> MarcelineVQ: hi, I don't know if you gave me an answer concerning my instant messaging app :)?
21:43:21 <turab> MarcelineVQ: I think the use of fmap I wrote above is equivalent to the given definition.
21:43:23 <MarcelineVQ> turab: seems reasonable, I'd have to write that out to convince myself
21:43:50 <turab> I am sleepy so it doesn't seem convincing at this moment
21:44:18 <MarcelineVQ> rhylx: I meant to but not sure if I did, had a glance at wireapp and it seems like a neat thing to look at though it's got some advanced stuff in it like lenses
21:46:48 <MarcelineVQ> Which shouldn't scare you off just that it's another thing to have to learn to get going
21:47:09 <rhylx> MarcelineVQ: Okok. I will then dig deeper into it if you think that it is a good starting point :)
21:47:32 <turab> (x, s'') = app stx s' in (f x, s'')  == app (fmap f stx) s' == app (State $ \s' -> (x, s'') <- stx s'; (f x, s'')) 
21:48:28 <MarcelineVQ> rhylx: wish I could say for sure, I've never tried making something like that
21:48:45 <turab> Oki it's bed time now zZZZ
21:50:49 <rhylx> MarcelineVQ: okay. And I couldn't find the community around that project. They don't seem to have an irc and had just one answer on the subreddit...
22:00:36 <MarcelineVQ> yeah dunno about that
22:52:30 <jusss> what is Functor composition?
23:00:07 <ski> (didn't you ask about that, yesterday ?)
23:01:35 <jusss> ski: f . g is function composition?
23:03:26 <ski> if `f' is a function from `T' to `U', and `g' a function from `U' to `V', (`T',`U',`V' being types / (structural) sets), then `g . f' is a function from `T' to `V', the composition of `g' after `f'. defined by `(g . f) x = g (f x)', for all inhabitants/values `x' in `T'
23:05:37 <ski> if `F' is a functor from `C' to `D', and `G' a functor from `D' to `E', (`C',`D',`E' being categories), then `G . F' is a functor from `C' to `E', the composition of `G' after `F'. defined on all objects `A' of `C' by `(G . F) A = G (F A)' (result is an object in `E'); and defined, for all objects `A',`B' of `C', on all morphisms `f' (in `C') from `A' to `B', by `(G . F) f = G (F f)' (result is a morphism (in `E') from `G (F A)' to `G (F B)')
23:08:07 <ski> in Haskell, an instance `f' of the type class `Functor' (iow an `f' where `Functor f' holds) must be a type `f' of king `* -> *', so the from and to categories (say `C' and `D' above) would both be the same category, corresponding to `*', sometimes written `Hask'. so `f' is a functor from `Hask' to `Hask' (both `C' and `D' being `Hask'), iow an *endo*functor (on `Hask')
23:11:04 <ski> one could also talk about functors between other categories in Haskell, but they wouldn't be instance of the type class `Functor' (which is only for endofunctors on `Hask')
23:11:04 <ski> e.g. if one defines `newtype StreamVia f a = SV (f (a,StreamVia f a))', then `StreamVia' is a functor to `Hask', from : the category of all functors from `Hask' to `Hask'. iow from the category of endofunctors on `Hask'
23:11:12 <ski> er, actually, sorry, the "to" is also that functo category here, not `Hask'
23:11:50 <ski> let's say `newtype IntegerStreamVia f = ISV (f (Integer,IntegerStreamVia f))' instead, to remedy that
23:12:25 <MarcelineVQ> That is uhm, a lot to take in there. Where did you see the phrase "Functor composition" jusss?
23:12:46 <ski> in terms of Haskell kinds, we then have `IntegerStreamVia :: (* -> *) -> *' (`StreamVia :: (* -> *) -> (* -> *)' for the other one) -- but that doesn't say anything about `Functor'
23:14:14 <ski> one could imagine writing something like `IntegerStreamVia :: {f :: * -> * | Functor f} -> *', or `IntegerStreamVia : Hask^Hask >---> Hask' (in more "mathematical" notation)
23:15:36 <ski> for simpler cases, like `Maybe',`Either e' (for some `e :: *'), we get `Maybe :: * -> *',`Either e :: * -> *' (or `Maybe : Hask >---> Hask',`Either e : Hask >---> Hask')
23:16:27 <ski> we can compose `Maybe' and `Either e', in either way (let's take `Maybe' after), so `Maybe . Either e :: * -> *' (or `Maybe . Either e : Hask -> Hask')
23:17:03 * ski looks at jusss, idly wonders whether they're bewildered yet
23:20:02 <dminuoso> You probably intimidated them. ;)
23:20:04 <ski> (i dunno how much you're following here. e.g. if you're not following basic function composition, then chances are you'll not understand functor composition, either. but if you don't protest, or ask about something, or want more elaboration, i was having in mind to complete what i wanted to say, and maybe you'd sorta get a somewhat clearer idea as well ?)
23:20:34 <dminuoso> ski: The term came up yesterday, when I introduced the notion that the composition of two functors with (:.:) gives a functor in return.
23:20:47 <ski> (could be. or maybe they're busy looking at some site or book, or busy with something else, suddenly)
23:22:07 <dminuoso> ski: Judging from my past exchanges, I'd say you've intimidated them with what you've written. They have not made any implications to have any knowledge or interest about categories. :-P
23:22:27 * ski thinks it's quite possible, yea
23:22:30 <ski> anyway, `Either e' is a functor from `Hask' to `Hask', because it will accept one concrete type (like `Integer'), before producing a concrete type (then `Either e Integer') (assuming `e' is a concrete type, a type of kind `*', the type would be an object in the category `Hask' of all concrete types)
23:25:24 <ski> what then is `Either' ? it will accept a concrete type `e' (an object in `*' / `Hask'), and produce a type `Either e' (a functor from `*' / `Hask' to itself). iow produce an object in the category of endofunctors on `*' / `Hask', written `{f :: * -> * | Functor f}' / `Hask^Hask' above
23:26:41 <ski> iow, `Either :: * -> {f :: * -> * | Functor f}' is a functor from `*' to `{f :: * -> * | Functor f}'. in other notation, `Either : Hask >---> Hask^Hask'
23:27:50 <ski> combining that with `IntegerStreamVia :: {f :: * -> * | Functor f} -> *' / `IntegerStreamVia : Hask^Hask >---> Hask'. composing that functor `IntegerStreamVia' after `Either', we get `IntegerStreamVia . Either :: * -> *' / `IntegerStreamVia . Either : Hask >---> Hask'
23:28:51 <ski> (and i'll stop here. the point/goal was to show a slightly more complicated composition than say `Maybe . Maybe' or `Maybe . Either e', where the categories involved were not all `*' / `Hask')
23:31:08 <jusss> ski: sorry, I was busy
23:31:16 * ski nods
23:31:44 <jusss> MarcelineVQ: I heard "Functor composition" from here yesterday
23:31:48 <ski> jusss : tell me where you can't follow any longer, and we'll see what we can do
23:32:02 <ski> jusss : first things first, do you know about basic function composition ?
23:32:54 <jusss> ski: how to know if I know or don't know?
23:33:17 <jusss> f . g = \x -> f (g x) this one I know
23:33:54 <ski> can you predict what the type of e.g. `filter . (0 <=)' will be, just by looking at that (and perhaps writing on paper, or in a buffer. but not asking the interactor). you may assume `0' is an `Integer' here
23:33:58 <ski> ?
23:34:02 * ski nods
23:34:08 <ski> @src (.)
23:34:09 <lambdabot> (f . g) x = f (g x)
23:34:15 <ski> (which is the same thing)
23:34:58 <jusss> I can use type inference to get (f . g) x = f (g x) based on its type signature
23:35:00 <jusss> :t (.)
23:35:01 <lambdabot> (b -> c) -> (a -> b) -> a -> c
23:35:25 <ski> yes. can you do that in your head ? (or on paper, or writing in a text buffer)
23:35:47 <jusss> @src filter
23:35:47 <lambdabot> filter _ []     = []
23:35:48 <lambdabot> filter p (x:xs)
23:35:48 <lambdabot>     | p x       = x : filter p xs
23:35:48 <lambdabot>     | otherwise = filter p xs
23:35:59 <ski> @type filter
23:36:00 <lambdabot> (a -> Bool) -> [a] -> [a]
23:36:02 <ski> @type (<=)
23:36:04 <lambdabot> Ord a => a -> a -> Bool
23:37:24 <ski> `(<=)' here involves type class constraints. but since feed it `0' (as first argument), which we agreed to assume was an `Integer' in this case, we'll actually have
23:37:38 <jusss> sorry, network disconnected
23:37:41 <ski>   (<=) :: Ord Integer => Integer -> Integer -> Bool
23:38:16 <ski> and since we know `Integer' is an instance of `Ord' (iow we know `Ord Integer' holds), we can skip that (true/holding) constraint, getting
23:38:19 <ski>   (<=) :: Integer -> Integer -> Bool
23:38:23 <DariusTheMede> I am trying to install https://github.com/NixOS/cabal2nix/tree/master/hackage2nix
23:38:48 <DariusTheMede> I get * Missing (or bad) header file: openssl/evp.h
23:38:57 <ski> so, that's the type of `(<=)', in our case. and `(0 <=)' will do the same as `(<=) 0', so that's just feeding `0' as first argument to `(<=)'
23:39:09 <DariusTheMede> I have done sudo apt install libssl-dev
23:39:17 <DariusTheMede> But that hasn't fixed the problem
23:39:18 <ski> jusss : does that make any sense to you ?
23:39:27 <jusss> ski: yeah
23:39:54 <jusss> we feed another one Integer and get a Bool 
23:39:59 <ski> jusss : so, what's the type of `(<=) 0' (and thus of `(0 <=)') ?
23:40:17 <jusss> (<=) 0 :: Integer -> Bool
23:40:20 <ski> yes
23:40:22 <ski> now take
23:40:34 <DariusTheMede> Perhaps I should ask on #hackage
23:41:00 <ski>   (.) :: (b -> c) -> (a -> b) -> (a -> c)  -- the last pair of brackets here is redundant, but may help inserting here, for emphasis
23:41:28 <jusss> :t filter
23:41:29 <lambdabot> (a -> Bool) -> [a] -> [a]
23:41:30 <ski> however, let's rename `a',`b',`c' here, to not confuse them with the `a' in the signature of `filter'
23:41:44 <ski>   (.) :: (y -> z) -> (x -> y) -> (x -> z)
23:42:13 <ski>   filter :: (a -> Bool) -> ([a] -> [a])  -- last pair of brackets redundant, added for clarity / emphasis
23:42:21 <ski>   (<=) 0 :: Integer -> Bool
23:42:51 <ski> so, what will the type of `filter . (<=) 0' (or `filter . (0 <=)') become ?
23:43:13 <ski> and, what's the particular type of `filter' and `(.)', as used in this particular instance ?
23:43:42 <ski> jusss : try and see for a short while whether you can figure out the answer to those questions
23:43:46 <jusss> ski : Integer -> ([a]->[a]) ?
23:46:04 <ski> jusss : would that be an answer to the former or the latter of those two questions ?
23:46:23 <ski> oh
23:46:27 * ski smiles
23:46:55 * ski just realized a type error in the example
23:47:02 <jusss> ski: ...
23:47:05 <ski> jusss : can you spot it ?
23:47:14 <jusss> ski: wait a min
23:48:12 <ski> (that's probably what i get for trying to do two conversations at the same time. i'm sorry for the inconvenience. but perhaps it could be good practice trying to find it out, and what to do to fix it)
23:49:12 <ski> (jusss : probably you already have sortof an idea of what the intent of the example was to be)
23:51:59 <jusss> ski: function composition seems to me like connect two function to one, like t = f . g, t has g's input type, and t's result type is f's result type
23:52:20 <ski> yes, that's correct
23:52:28 <ski> it's like a "pipeline"
23:52:51 <jusss> yeah, connect them to new one
23:53:03 <ski>   V <--{ f }--< U <--{ g }--< T
23:53:05 <ski> assuming
23:53:09 <ski>   g :: T -> U
23:53:15 <ski>   f :: U -> V
23:53:22 <ski>   f . g :: T -> V
23:53:38 <jusss> yeah
23:54:06 <ski> however, if we consider `filter . (<=) 0', and the signatures for `(<=) 0' and `filter', we have
23:54:12 <ski>   (<=) 0 :: Integer -> Bool
23:54:16 <ski>   filter :: (a -> Bool) -> ([a] -> [a])
23:54:41 <hc> hi all, trying a simple example to run into mem exhaustion due to lazy evaluation; recent ghc seems to optimize that away?
23:54:47 <hc> incf i = if i == 1000000000 then i else (incf $ i + 1)
23:55:10 <ski> so the output type of the "previous" function, `(<=) 0', is `Bool', but the input type of the "next" function, `filter', is `(a -> Bool)', and these can't possibly match
23:55:24 <ski> however, we could *pass* `(<=) 0' as *input* to `filter'
23:55:39 <ski> iow, `filter ((<=) 0)' would be okay
23:55:53 <ski> but since `f (g x)' is `(f . g) x'
23:55:57 <ski> @src (.)
23:55:57 <lambdabot> (f . g) x = f (g x)
23:56:38 <ski> `filter ((<=) 0)' should then be `(filter . (<=)) 0', and so it looks like `filter . (<=)' is actually the composition that we probably had in mind here
23:56:47 <ski> so, then we want to compose instead
23:56:55 <ski>   (<=) :: Integer -> Integer -> Bool
23:57:00 <ski> before
23:57:05 <ski>   filter :: (a -> Bool) -> ([a] -> [a])
23:57:12 <ski> jusss : making sense ?
23:57:18 <jusss> ski: ok
23:57:28 <ski> or, let's clarify the signature of `(<=)' as
23:57:33 <ski>   (<=) :: Integer -> (Integer -> Bool)
23:57:45 <ski> by introducing an extra pair of (redundant) brackets
23:58:17 <ski> so, will the output type of the "previous" function now match the input type of the "next" function ?
23:58:35 <jusss> matched
23:59:57 <ski> so, what's the type of the whole composition `filter . (<=)' here ?
