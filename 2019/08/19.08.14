00:00:05 <Cale> > read "56" :: Int
00:00:07 <lambdabot>  56
00:00:11 <Cale> > read "56" :: Double
00:00:14 <lambdabot>  56.0
00:00:23 <Cale> > read "56" :: [Double]
00:00:29 <lambdabot>  mueval-core: Time limit exceeded
00:00:34 <Cale> weird
00:00:35 <Cale> > read "56" :: [Double]
00:00:38 <lambdabot>  *Exception: Prelude.read: no parse
00:00:40 <nullnullnull> yeah im getting this from args like this (h:p:t:_) <- getArgs   but the t should be converted to int only
00:00:42 <Cale> (I expected a different error, yeah)
00:00:47 <Cale> right
00:00:53 <Cale> So, t there is a String
00:00:59 <nullnullnull> yes mate
00:01:01 <Cale> You can read t to get an Int
00:01:14 <Cale> and if the parse fails, your program will stop with an error
00:01:36 <nullnullnull> yeah it's ok to throw error
00:03:10 <nullnullnull> read t :: Int
00:03:39 <nullnullnull> then Im sending the t to thread 
00:03:59 <Cale> You can give the explicit signature like that, or you can just provide (read t) as an argument to your tr function, and its type signature will disambiguate it for you
00:04:18 <nullnullnull> ah
00:05:32 <nullnullnull> so it will be like this: tr (read t)=do
00:05:39 <Cale> no
00:05:52 <Cale> That looks like the definition of tr
00:05:57 <Cale> You want tr to take a number
00:06:13 <Cale> You can call that number t there if you want, but it won't be the same t as the one in main
00:06:24 <Cale> (the t in main is a String)
00:06:29 <nullnullnull> yeah
00:06:37 <Cale> tr t = do ...
00:06:50 <Cale> main = do ...; tr (read t)
00:07:16 <Cale> It might be less confusing if the first line there were tr n = do ...
00:07:30 <Cale> But it doesn't matter, t is a local variable in both cases
00:07:47 <nullnullnull> so the function should accept string param not int cuz I sent string
00:07:49 <Axman6> You also mentioned that tr is uspposed to be a thread, so you will need to use forkIO to make it a thread
00:07:59 <nullnullnull> thread* yes
00:08:01 <Cale> No, I'm saying, you shouldn't send a String
00:08:19 <nullnullnull> but from main: I sent it as string
00:08:23 <nullnullnull> from the args
00:08:24 <Cale> You can change that
00:08:36 <Cale> Pass it the result of applying read to the String
00:09:03 <Axman6> you have a String, you need to send an Int, so you can use main = do ...; tr (read tWhichIsAString) and have tr :: Int -> IO (); tr tWhichIsAnInt = do ...
00:09:18 <Axman6> in main, you use read to turn the String into an Int
00:09:26 <Cale> yes
00:11:23 <nullnullnull> (h:p:t:_) <- getArgs;           read t;
00:11:27 <nullnullnull> from main
00:11:41 <Cale> You won't be able to write read t on its own like that because it's not an IO action
00:12:11 <Cale> But you can apply tr to it to get an IO action which you run there
00:12:41 <Axman6> nullnullnull: please read the code that we've written for you, we're showing you exactly how to solve the problem but you're not paying attention to what's been said
00:12:47 <Cale> (theoretically, if there were a Read instance for IO actions, you might be able to write that, but there isn't, so you can't)
00:13:06 <Axman6> Cale is like the nicest person on the planet, be nice to him back =)
00:13:17 <Cale> haha
00:13:19 <nullnullnull> :D
00:13:31 <nullnullnull> ah sorry guys, I was confused with the t "{
00:13:34 <nullnullnull> ;P
00:14:47 * Axman6 is pretty sure he wouldn't be the Haskeller he is today without Cale sitting down and spending hours teaching him various things over the years
00:15:13 <nullnullnull> maybe because I'm to new haskell, I got confused of what is "read" and stuff like that
00:15:40 <Axman6> it's just a function, nearly everything is just a function :P
00:16:44 <nullnullnull> would be easier if they made it like "int.parse" or something :P
00:17:04 <Axman6> but that only works for ints, and that's boring
00:17:15 <Axman6> read can work for _everything_*
00:17:22 <nullnullnull> oh
00:17:30 <nullnullnull> it's like object?
00:17:56 <Axman6> no
00:18:06 <Axman6> :i Read
00:18:15 <Axman6> % :info Read
00:18:16 <yahb> Axman6: class Read a where; readsPrec :: Int -> ReadS a; readList :: ReadS [a]; GHC.Read.readPrec :: Text.ParserCombinators.ReadPrec.ReadPrec a; GHC.Read.readListPrec :: Text.ParserCombinators.ReadPrec.ReadPrec [a]; {-# MINIMAL readsPrec | readPrec #-}; -- Defined in `GHC.Read'; instance [safe] (Read w, Data.Functor.Classes.Read1 m, Read a) => Read (WriterT w m a) -- Defined in `Control.Monad.Trans.
00:18:28 <Axman6> hmmmmm, baybe don't read that, ha
00:18:33 <nullnullnull> text praser
00:18:37 <nullnullnull> parser
00:18:43 <Axman6> basically, yes
00:19:05 <Axman6> anything which is an instance of the Read clasds can be parsed using read:
00:19:17 <Axman6> > read "True" :: Bool
00:19:21 <lambdabot>  True
00:19:39 <nullnullnull> ah nice :)
00:19:40 <Axman6> > read "()" :: ()
00:19:42 <lambdabot>  ()
00:19:57 <Axman6> > read "12345678901112" :: Int
00:20:01 <lambdabot>  12345678901112
00:20:13 <nullnullnull> but if i wanna force it, i can use this for example:   t = read t :: Integer
00:20:40 <Axman6> yep
00:20:51 <Axman6> of it can be inferred by how you use it
00:21:16 <Axman6> > let f :: Int -> Int; f x = x*x+1 in f (read "12345")
00:21:20 <lambdabot>  152399026
00:22:06 <maerwald> is there a useful percentage type somewhere? I cannot find any
00:22:15 <nullnullnull> thanks guys :) I got it now
00:22:17 <Axman6> Not that I know of
00:23:58 <Axman6> nullnullnull: there are other problems with your program though, the thread you're forking probably isn't going to do what you want it to do. Your program exists as soon as the main thread exist, so if you have a thread sitting there waiting for 2 seconds and main finished execution, the program willjust exit. If you wan to tlimit your program's runtime to 2 seconds then you're on the right track
00:24:32 <nullnullnull> yes mate, I wanna add the async there
00:24:41 <Axman6> using the async package?
00:24:46 <nullnullnull> I want to run it parallel
00:24:59 <nullnullnull> I mean to run thread and main on same time
00:25:23 <nullnullnull> I added this atm: import Control.Concurrent.Async(async);
00:25:54 <nullnullnull> now I just need to make the async thing
00:27:31 <nullnullnull> this is what im trying to do with my program:
00:27:53 <nullnullnull> im waiting for X seconds, then im terminating the app (timeout)
00:28:04 <nullnullnull> exitImmediately(ExitFailure 1);
00:28:10 <nullnullnull> it's something related to socket connection
00:30:54 <nullnullnull> I guess it's something like this:   tr <- async(n);
00:30:59 <nullnullnull> gonna check
00:31:10 <sm[m]> nullnullnull: how about showing your code on a paste site
00:31:17 <nullnullnull> ok sec 
00:31:20 <nullnullnull> I will upload it
00:31:45 <Axman6> nullnullnull: what is the type of async?
00:31:55 <sm[m]> you seem to be struggling with basic syntax, maybe get it working single threaded before messing with threads
00:32:10 <nullnullnull> yes mate I'm new to haskell :P
00:32:16 <nullnullnull> sec im uploading the ode
00:32:17 <nullnullnull> code
00:32:26 <sm[m]> great, welcome :)
00:32:47 <nullnullnull> https://pastebin.com/bQjGgD9J
00:32:58 <Axman6> sometimes stumbling around a bit can be useful... thoug I do recommend following a tutorial on Haskell before going much further, you're missing some pretty critical basics
00:33:00 <nullnullnull> it's almost complete there (just the async part to be fixed)
00:33:14 <Axman6> though*
00:33:15 <nullnullnull> Axman6, true true mate
00:33:22 <nullnullnull> I should read the tutorial
00:33:23 <Axman6> nullnullnull: so, what is the type of async?
00:33:31 <nullnullnull> hmm
00:33:43 <dminuoso> nullnullnull: You really should stop using parens for what you likely perceive as "function call parens"
00:34:00 <sm[m]> That’s.. cool :)
00:34:03 <nullnullnull> oh
00:34:05 <nullnullnull> sec
00:34:06 <sm[m]> Different style from what we’re used to
00:34:21 <dminuoso> nullnullnull: In Haskell we denote function application merely by juxtaposition. So where in C you would write f(x), in Haskell it would be conventional to just write ⌜f x⌝
00:34:42 <nullnullnull> ah
00:34:45 <Axman6> yes this is not how we write Haskell =)
00:34:56 <sm[m]> Hey, if it works..
00:35:02 <Axman6> There are many styles Haskell is written in, and this is not one of them :P
00:35:03 <nullnullnull> yeah sec , im trying to understand the async thing in haskell (reading about it)
00:35:28 <dminuoso> nullnullnull: Parens may be used to change how things associate, so for example if you want to apply f to the result of g applied to x, you would write it as ⌜f (g x)⌝
00:35:42 <dminuoso> nullnullnull: But there is no "function call parens" in Haskell like in many other languages.
00:37:33 <dminuoso> nullnullnull: And all of these semicolons are unnecessary and misleading.
00:37:56 <tdammers> sm[m]: the "hey if it works" attitude is what gave us PHP
00:38:30 <Axman6> and not the good one, Purescript, Haskell and PostgreSQL
00:38:34 <sm[m]> 1. This is a beginner and 2. PHP is quite useful :)
00:39:44 <sm[m]> nullnullnull: forkIO (tr 5000000)  is enough if you just want to fire up that thread and forget it
00:39:47 <dminuoso> nullnullnull: https://gist.github.com/dminuoso/945aaca1890421462e402f28f1c35c97 This is how you would write it, from a visual style point of view.
00:40:19 <sm[m]> The async lib is a souped-up version of the built in thread functions, you may not need it for simple things
00:40:20 <dminuoso> nullnullnull: Adapting the conventional style is useful because it helps understand how Haskell works better, and it also enables you to read other peoples code more easily. :)
00:40:38 <nullnullnull> sec
00:41:44 <dminuoso> nullnullnull: Did fine more cleaning up, if you like to reload. 
00:46:26 <nullnullnull> dminuoso, got your point mate :)
00:46:36 <nullnullnull> sm[m], is it possible without forkIO?
00:47:08 <sm[m]> nullnullnull: to start a separate thread ? Not really, others are some variant of that
00:47:17 <nullnullnull> ah
00:47:39 <rsoeldner>  Morning, struggle with nix, https://gist.github.com/rsoeldner/1a65277a8c7728915e7e46c1833548b3 when running `nix-build` I receive "ghc: can't find a package database at ....", someone can help out ?
00:47:53 <sm[m]> Well, you could call some external program and let it run in parallel
00:47:55 <dminuoso> nullnullnull: forkIO is just "run this IO action in a separate thread"
00:48:15 <dminuoso> The name is just a bit odd. :)
00:56:41 <nullnullnull> thanks guys :) it worked for me
01:01:27 <sm[m]> 👍🏻
01:03:09 <dminuoso> nullnullnull: And for whats worth, async is probably a better choice than raw liftIO. It's a really thin wrapper that improves semantics relating to how/when threads are stopped again.
01:03:14 <dminuoso> *forkIO heh
01:03:21 <dminuoso> Muscle-memory won there.
01:03:36 <nullnullnull> yeah :)
01:04:24 <nullnullnull> I liked the forkIO 
01:06:20 <dminuoso> nullnullnull: ⌜async⌝ is ⌜forkIO⌝ in a better way. So instead of ⌜forkIO foo⌝ you would just write ⌜async foo⌝ :)
01:06:34 <dminuoso> nullnullnull: But anyway, its not that relevant really - especially since you are just beginning.
01:07:11 <dminuoso> Im just mentioning it, hoping that if you build up more experience, you will remember that ⌜async⌝ is an effective abstraction for dealing with threads.
01:07:14 <nullnullnull> great!, thanks for the info mate :)
01:27:12 <jusss> State and Reader are types right？
01:27:17 <dminuoso> jusss: Yes.
01:28:26 <jusss> dminuoso: before it's a monad, it just is a type? until we implement that bind apply  fmap mempty functions
01:28:47 <merijn> jusss: "being a monad" is a property of some types
01:28:47 <dminuoso> jusss: "It being a monad" just means there exists an instance Monad for that type. :)
01:29:12 <dminuoso> jusss: Perhaps its cleaner to think "IO is not a monad. IO just have an instance Monad"
01:29:34 <merijn> jusss: "foo :: m Int" <- here 'm' is a type that has kind "* -> *"
01:29:35 <dminuoso> (It's technically not correct, but perhaps this mindmodel is more helpful for you)
01:30:08 <dminuoso> jusss: The usefulness from this phrasing is to stop thinking about 'what is it about IO that it makes a "monad" and what does "being a monad mean"'
01:30:16 <merijn> jusss: "bar :: Monad m => m Int" <- here 'm' is a type that has kind "* -> *" *and* that type has to have a Monad instance (alternatively "that type has to be a monad")
01:30:25 <dminuoso> jusss: And it introduces the idea that "Monad" is just an interface (like say in Java), consisting of just two functions.
01:30:28 <EvanR> sometimes you can implement a typeclass properly in more than 1 way
01:30:38 <dminuoso> jusss: And IO conforms to that interface.
01:31:21 <merijn> jusss: I always like to explain constraints like "foo :: Monad m => m Int" as: IFF 'm' has an instance of Monad THEN 'foo :: m Int' ELSE type error"
01:31:38 <dminuoso> jusss: So a typeclass in general can be thought of an interface, and writing an instance of an type for that typeclass can be thought of "writing an implementation for that interface" :)
01:33:01 <jusss> merijn: dminuoso I just wonder if we forget that monad things, can we use State or other monad types like regular types?
01:33:09 <dminuoso> jusss: Yes absolutely!
01:33:13 <dminuoso> jusss: State is just a type!
01:33:19 <dminuoso> jusss: You can use it without the monad interface just fine.
01:33:38 <jusss> dminuoso: and IO?
01:33:47 <merijn> jusss: IO (and Reader and everything) else would work just as well without a Monad instance
01:34:06 <dminuoso> jusss: In principle we could give you two functions "pack :: a -> IO a" and "then :: IO a -> (a -> IO b) -> IO b"
01:34:15 <merijn> jusss: What you lose is the ability to have a single set of operators used for each and the ability to write code that is generic across different monad instances
01:34:17 <dminuoso> jusss: The point of Monad is just this observation
01:34:27 * hackage boots 0.0.100 - IoC Monad in Haskell  https://hackage.haskell.org/package/boots-0.0.100 (leptonyu)
01:34:46 <dminuoso> You also have two functions packState :: a -> State s a; nextState :: State s a -> (a -> State s b) -> State s b
01:34:49 <merijn> jusss: Consider Maybe. If Monad disappeared we could still write "foo :: Maybe a -> (a -> Maybe b) -> Maybe b"
01:35:17 <dminuoso> jusss: Monad is just the observatoin that all these function look the same way. So instead of making up a new function name every time, they just share the same function name.
01:35:23 <dminuoso> That pretty much all there is to Monad.
01:35:44 <dminuoso> From a consumer perspective, you take (>>=) and set m to say "State Int"
01:35:55 <merijn> jusss: Monad instances don't add anything to a type, the same functionality would exist without Monad. The monad instances just allow us to conveniently reuse operators (and syntactic sugar) and write code that is generic across multiple instances of Monad
01:35:56 <dminuoso> then (>>=) :: State Int a -> (a -> State Int b) -> State Int b
01:36:18 <jusss> ok
01:37:43 <jusss> 'cause we have anonymous function like lambda, so I wonder is there anonymous type?
01:38:17 <dminuoso> jusss: I suppose every type not bound to a type alias is anonymous in a sense.
01:38:22 <dminuoso> jusss: or a type family
01:38:36 <merijn> jusss: You could have "type lambdas", yes. But we don't in Haskell because they make type checking undecidable
01:38:40 <dminuoso> jusss: If you just write ⌜Either Int Bool⌝ in the type system its anonymous because its not bound to any particular type.
01:38:56 <merijn> jusss: i.e. there would be no way to guarantee that typechecking doesn't infinite loop, additionally it breaks type inference
01:39:04 <dminuoso> merijn: We actually covered various forms of type functions yesterday. I think they rather care about the "anonymous" part. :)
01:39:19 <merijn> jusss: But there are type systems and languages where you can have anonymous type lambdas
01:39:37 <[exa]> jusss: you can get a similar feeling from types like (forall a. ... a ...) that are implicitly put into almost all types you see
01:40:12 <dminuoso> jusss: There exist a way to build anonymous functions even in the Haskell type system if you enable about 6 type extensions. At least conceptually
01:41:42 <dminuoso> [exa]: That's wildly different though.
01:42:03 <dminuoso> [exa]: The reason is that forall quantification in haskell gives you terms that can bind types.
01:42:55 <dminuoso> (where terms refers to value-level constructs)
01:43:39 <[exa]> dminuoso: I know, didn't want to imply it's the same technically
01:45:35 <[exa]> but it's generally interesting to compare the computational vs. symbolic value of (\a->f a) and (forall a.F a)
01:46:25 <dminuoso> jusss: My preferred way to think about Monad these days, is to just look at (>>=) and see it as a family of functions. You can pick one of those functions by setting m to some appropriate type (so you could say that it's indexed by the type m, sort of like a map from m to a function type)
01:47:36 <dminuoso> jusss: So the function (>>=) at m ~ IO gives you ⌜then :: IO a -> (a -> IO b) -> IO b⌝, (>>=) at m ~ State Int gives you ⌜nextState :: State Int a -> (a -> State Int b) -> State Int b⌝, and so forth. Do you notice how the word Monad has disappeared?
01:48:53 <dminuoso> jusss: The question is merely "but what do those functions do" - and Id say it doesnt matter. If you just know that the function ⌜IO a -> (a -> IO b) -> IO b⌝ is the one you want, then you can "grab and use it" so to speak. Ignore all the other functions, they are irrelevant to you.
01:49:00 <dminuoso> jusss: Does that make any sense?
01:49:42 <jusss> dminuoso: remove that m part?
01:50:06 <Cale> That's just a way of thinking about type classes in general though. It's important to know the meaning of the things that you're using...
01:50:10 <jusss> dminuoso: or why m is *->*
01:50:31 <Cale> But yeah, it's only important to know what the specific instance you're using does
01:50:37 <dminuoso> jusss: Look at the type signature of then/nextState, or the maybe function merijn mentioned above.
01:50:57 <dminuoso> jusss: Do you notice that if you set m ~ IO, then you end up with something like "IO a" 
01:51:35 <jusss> dminuoso: what it means m ~ IO?
01:51:44 <jusss> this symbol ~?
01:51:48 <dminuoso> jusss: ~ is to denote equality on the type level.
01:52:00 <dminuoso> % :t (>>=)
01:52:15 <dminuoso> :t (>>=)
01:52:18 <lambdabot> Monad m => m a -> (a -> m b) -> m b
01:52:22 <jusss> ok
01:52:28 * hackage salak 0.3.3.2 - Configuration (re)Loader and Parser.  https://hackage.haskell.org/package/salak-0.3.3.2 (leptonyu)
01:53:27 <dminuoso> jusss: You could read this as: "Pick m, a and b to be any type you want and Ill give you a function"
01:53:28 * hackage salak-toml 0.3.3.2, salak-yaml 0.3.3.2 (leptonyu): https://qbin.io/utah-debut-24u7
01:53:57 <dminuoso> jusss: Now as a disclaimer, you cant pick something completely arbitrary for m. You can only pick m out of a certain set.
01:54:17 <dminuoso> jusss: Lets ignore the a and b variables, and just focus on the type variable m.
01:54:38 <jusss> dminuoso: yeah
01:54:39 <dminuoso> jusss: Let's try and set m ~ Either
01:55:05 <dminuoso> jusss: What's the type of the function you get back?
01:55:19 <jusss> dminuoso: Either a b?
01:55:24 <dminuoso> :t (>>=)
01:55:29 <lambdabot> Monad m => m a -> (a -> m b) -> m b
01:55:33 <dminuoso> jusss: Just replace m with "Either" in that type signature.
01:56:22 <jusss> Either a 'a -> ( 'a -> (Either a b)) -> Either a b
01:56:32 <dminuoso> jusss: Wait. That's sneaky of you.
01:56:40 <dminuoso> jusss: We said "Either", not "Either a"
01:56:46 <jusss> haha
01:57:03 <jusss> Either a -> (a -> Either b) -> Either b
01:57:19 <dminuoso> jusss: So here comes the issue. This is a function demanding a value of type ⌜Either a⌝
01:57:21 <dminuoso> :k Either
01:57:23 <lambdabot> * -> * -> *
01:57:41 <dminuoso> jusss: Using the knowledge you obtained yesterday, can there be a value of ⌜Either a⌝ for some choice of a?
01:58:07 <jusss> :k (Either a)
01:58:10 <lambdabot> error: Not in scope: type variable ‘a’
01:58:22 <dminuoso> jusss: Pick some concrete type for a, say Int or whatever you like.
01:58:26 <jusss> :k Either Int
01:58:29 <lambdabot> * -> *
01:58:53 <jusss> no value has Either Int
01:59:12 <dminuoso> jusss: Is Either Int inhabitatable at all? Could we make up values of that type?
01:59:14 <jusss> 'cause values have types which's kind is *
01:59:29 <dminuoso> jusss: Right! And can types with a kind different from * have values at all?
01:59:50 <jusss> no
01:59:59 <dminuoso> jusss: Alright! So clearly setting m to a type of kind ⌜* -> * -> *⌝ is not valid. Do you agree?
02:00:18 <jusss> yes
02:00:32 <dminuoso> jusss: Try something else. Do you think we could set ⌜m ~ Bool⌝ perhaps?
02:01:01 <jusss> dminuoso: m is *->* and Bool is *, so no
02:01:18 <dminuoso> jusss: But why is m required to have a kind of ⌜* -> *⌝, really?
02:01:54 <jusss> dminuoso: that means why monad have to be *->*?
02:02:00 <dminuoso> jusss: It's because the function (>>=) would make any sense, otherwise. (>>=) takes that m, applies one type to it, and then demands that this type be inhabitatable (since eventually a function is produced, that demands value of m applied to that type, and it produces values of m applied to another type)
02:02:28 * hackage boots-app 0.1.0.5 - Startup factories using IoC monad  https://hackage.haskell.org/package/boots-app-0.1.0.5 (leptonyu)
02:02:57 <dminuoso> jusss: So if we again think of (>>=) as a family of functions indexed by a type m, then the index type is of kind (* -> *)
02:03:12 <jusss> dminuoso: ok
02:03:39 <dminuoso> jusss: Now, we still cant pick an arbitrary type of kind * -> * either.
02:04:01 <jusss> dminuoso: until?
02:04:24 <dminuoso> jusss: The limitation is, whatever type you pick, let's call it ⌜t0⌝, there must be an ⌜instance Monad t0⌝
02:04:28 <dminuoso> Nothing more.
02:04:55 <dminuoso> How do we know which ones have that instance? We can look at the haddoc documentation of Monad to get sizable list of instances.
02:05:18 <dminuoso> jusss: https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Monad scroll down to the section that says "instances"
02:05:38 <dminuoso> jusss: [] is a valid choice for m. Maybe is a valid choice for m, IO is a valid choice for m. Each "choice" gives you a different function (>>=)
02:05:57 <jusss> yeah
02:09:22 <dminuoso> jusss: So Monad can be viewed as "the collection of all those types that have an instance/the collection of all those types that are valid to pick for "m" in (>>=)"
02:09:45 <dminuoso> jusss: There's even a language to ask whether a type is a member of that collection, its constraints. 
02:09:52 <dminuoso> % data SomeType a = SomeType
02:09:53 <yahb> dminuoso: 
02:11:26 <dminuoso> jusss: So a constraint "Monad m" can be also be thought of as "m must be a member of Monad"/"Whatever the choice of m, there must be an instance Monad m"
02:11:59 <dminuoso> jusss: You see, the notion of "IO is a Monad" is slippery and not useful. Perhaps its better to say "IO conforms to the interface of Monad" or "IO has an instance Monad"
02:12:08 <dminuoso> jusss: The same applies to State, Reader, etc..
02:17:20 <jusss> dminuoso: ok
02:32:02 <jusss> dminuoso: we can say values have types, or types have values, can we say types have functions?
02:32:11 <jusss> 'cause functions are values
02:32:59 <dminuoso> jusss: Depending on the context that could be a valid thing to say, though Im not convinced that this is a particularly useful thing to say.
02:34:56 <dminuoso> jusss: I'd probably prefer to use the word "inhabitant/inhabited" rather than "have"
02:35:19 <dminuoso> jusss: e.g. "⌜Int -> Double⌝ is inhabited by functions/values"
02:44:06 <dminuoso> % i :: Either; i = undefined -- merijn 
02:44:06 <yahb> dminuoso: ; <interactive>:20:6: error:; * Expecting two more arguments to `Either'; Expected a type, but `Either' has kind `* -> * -> *'; * In the type signature: i :: Either
02:47:23 <Cale> That message should probably say "Expected a type of kind *, but `Either' has kind `* -> * -> *'"
02:47:49 <dminuoso> Cale: Indeed.
02:48:23 <dminuoso> Cale: I actually once prepared a patch for it, and then realized it would be a larger scale modification since there's a couple more diagnostics that'd have to change.
02:48:58 <MarcelineVQ> dminuoso: hey not so large, just have * say Type and change "Expected a type" to "Expected a Type"
02:49:52 <merijn> Does conduit have a way to generalise the underlying monad? i.e. "(forall a . m a -> n a) -> ConduitT a b m r -> ConduitT a b n r"?
02:51:07 <MarcelineVQ> hmm.. I swear someone asked that just the other day
02:51:14 <Cale> transPipe :: Monad m => (forall a. m a -> n a) -> ConduitM i o m r -> ConduitM i o n r
02:51:40 <Cale> Or hoist
02:53:36 <merijn> Cale: Yeah, I figured mmorph would work, but I wondered if there was already something in conduit
02:53:58 <tdammers> so I have a cabal project with a library (in ./src) and a test suite (in ./tests), the test suite depending on the library (rather than including the library source files directly). I can run two ghcid sessions, one watching the library and one watching the tests, and the test one runs the tests as well, but I can't get the test ghcid to re-run when one of the library source files have changed, any ideas how
02:54:00 <tdammers> I'd go about that?
02:54:48 <merijn> tdammers: You need to tell it to build all targets *and* enable tests
02:55:28 <tdammers> ghcid -c "cabal v2-repl pkg:mypackage:tests" --test=Main.main # is what I'm using currently, but that only watches the test suite, not the library
02:56:13 <tdammers> merijn: how?
02:56:27 <merijn> Ah, with v2-repl you're boned because it can only do 1 target at a time
02:57:12 <tdammers> ugh
02:59:17 <merijn> Why not "cabal v2-test"?
03:05:33 <tdammers> because that exits ghcid when the test suite fails
03:05:46 <tdammers> 'Command "cabal v2-test" exited unexpectedly'
03:45:15 <berndl> Is anyone familiar with the operational monad?
03:54:26 <merijn> tdammers: Maybe wrap v2-test with a shell script that captures the exit code?
04:04:12 <Artigiano> https://www.artigianoveronese.it/
04:05:55 <makalu> I don't know if stack people are active here but the doc site is down https://docs.haskellstack.org/
04:15:32 <tdammers> merijn: I settled for the oldschool solution: watch 'cabal v2-test | tail -n 20'
04:15:52 <tdammers> replace the 'tail' part with sth like 'grep FAIL' to only list the failed tests
04:18:47 <merijn> hmm, anyone have any suggestions on how to nicely linewrap existential datatypes?
04:19:02 <phadej> use GADTSyntax
04:19:49 <merijn> phadej: GADT record syntax is also quite ugly
04:20:02 <phadej> stop using Haskell? :)
04:20:16 <merijn> i.e. something like: https://hastebin.com/ubivejufip.pl
04:20:40 <phadej> GADT syntax with record is indeed ugly, though
04:23:56 <merijn> phadej: I mean, not convinced this is better: https://hastebin.com/cafegotaco.hs :p
04:24:49 <phadej> imho, not worse
04:25:17 <phadej> both are ugly if you'll need to split record on multiple line
04:25:23 <phadej> I have no idea how i'd format that
04:25:41 <phadej> but I never needed such structure, so...
04:26:08 <merijn> IMO one of the biggest flaws in Haskell is that no one in the committee considered ensuring all syntax has a logical/adequate way to line wrap it in a pretty way >.>
04:26:16 <merijn> That applies to all existing languages, tbh
04:37:51 <dminuoso> merijn: In all fairness, Haskell 2010 itself has received a fair amount of thought.
04:38:05 <dminuoso> It's the extensions that get added to GHC that are just wild additions.
04:38:30 <dminuoso> But since they are added as an afterthought, you cant get around that unless you create a new language at some point.
04:46:16 <Ariakenom> dminuoso: I see complaints about extensions every now and then but I can't relate. Is there a write up somewhere?
04:46:46 <dminuoso> Ariakenom: Note that I know of.
04:46:53 <dminuoso> *Not
04:47:44 <Ariakenom> ok, I was just looking to understand
04:50:46 <lyxia> "as an afterthought" is a pretty uncharitable way to put it, considering that experimentation is the main purpose.
04:51:13 <hpc> and there is a lot of thought put into making sure the extensions are well-behaved
04:51:30 <hpc> (except for certain ones that have "incoherent" right in the name lol)
04:51:30 <merijn> We were discussing syntax, though :)l
04:51:32 <dminuoso> hpc: Absolutely. My point is not that they are of low quality, just that syntactically they are bolted ontop of Haskell 2010.
04:51:41 <dminuoso> hpc: Nothing more.
04:52:14 <merijn> How do I pass RTS options to a program running via cabal v2-run?
04:52:20 <lyxia> fair enough
04:52:30 <dminuoso> merijn: -- +RTS ... -RTS ...
04:52:41 <merijn> dminuoso: If I recall correctly that doesn't work
04:52:46 <dminuoso> merijn: it works for me.
04:52:55 <AWizzArd> I have a frequencies map {"a" 1, "b" 2", "c" 3}. Is there a function that will take this map and a key and decrease the corresponding value by 1 – and if that would lead to a zero, then this key/value pair gets completly removed from the map?
04:52:59 <merijn> dminuoso: Because cabal's RTS parses those before passing them onto the executable
04:53:10 <merijn> dminuoso: lemme try
04:53:10 <dminuoso> merijn: See the double dash?
04:53:16 <lyxia> isn't there an -rts-opts flag
04:53:20 <dminuoso> merijn: ⌜cabal new-run foo -- +RTS ... -RTS ...
04:53:23 <merijn> dminuoso: The RTS parsing takes place before getArgs
04:53:31 <merijn> dminuoso: cabal itself never sees the +RTS
04:53:42 <merijn> But easy enough to check I suppose
04:54:10 <dminuoso> merijn: Huh? I regularly profile my apps with ⌜cabal new-run freyja -- +RTS ... -RTS ...⌝ :)
04:54:28 <merijn> dminuoso: I recall an earlier discussion saying that, but I'll have to check what happens
04:55:00 <cocreature> merijn: The Haskell RTS parser takes -- into account
04:55:06 <merijn> cocreature: ah, nice
04:58:07 <dminuoso> AWizzArd: You could unfold a map into a new map, I suppose.
04:58:42 <merijn> AWizzArd: alter?
04:59:05 <dminuoso> Ah just stumbled over ⌜alter⌝ too, that looks like it.
04:59:05 <merijn> AWizzArd: alter can delete or modify values
04:59:23 <dminuoso> Or alterF rather.
04:59:36 <Ferdirand> is there an easy way to disambiguate between packages defining the same module name, when using GHCi interactively ?
04:59:38 <dminuoso> (If you want to do this across an entire container)
05:01:26 <merijn> Whoo! Allocation rate: 4 GB/s :p
05:01:52 <dminuoso> Ferdirand: PackageImports ?
05:02:13 <Ferdirand> ah thanks
05:02:30 <dramforever> AWizzArd: lens can do that
05:02:45 <dramforever> > let m = M.fromList [ ("a", 1), ("b", 2), ("c", 3) ]; dec k = m & at k . non 0 -~ 1 in (dec "a", dec "b", dec "c")
05:02:49 <AWizzArd> merijn: I see alter now and next to it is updateWithKey, which looks exactly like what I’m looking for.
05:02:50 <lambdabot>  (fromList [("b",2),("c",3)],fromList [("a",1),("b",1),("c",3)],fromList [("a...
05:02:51 <merijn> dramforever: lens is a pretty big hammer for something that can be easily done with alter/alterF >.>
05:03:04 <dramforever> okay
05:03:08 <dramforever> microlens can do that
05:03:10 <dminuoso> % :t (-~)
05:03:11 <yahb> dminuoso: Num a => ASetter s t a a -> a -> s -> t
05:03:20 <AWizzArd> dramforever: but it looks cool anyway, thx (:
05:03:36 <dminuoso> dramforever: actually that's quite nice.
05:04:23 <dminuoso> Speaking of lens, how does one build an optic for a similar effect of mono-traversable?
05:04:27 <dramforever> I thought microlens didn't have (-~) but apparently it was added
05:04:36 <dminuoso> (or mono-foldable)
05:06:15 <dramforever> Just Traversal or Fold perhaps?
05:07:05 <dramforever> like Traversal' Text Char
05:07:22 <Ariakenom> merijn: Ooo 4 GB/S. what program and how did you reach it? I was amused by my 2 GB/s for AoC.
05:08:02 <merijn> Ariakenom: I'm working on a diff program, so it's basically just streaming lots of text through a conduit
05:09:32 <Ariakenom> ah
05:32:04 <berndl> Is anyone familiar with the operational monad of apfelmus?
05:35:15 <lyxia> many people are
05:38:48 <tdammers> berndl: I'm not, but just ask your question. tends to work better than first probing for the presence of qualified people.
05:39:48 <berndl> tdammers: Alright
05:40:30 <berndl> In https://apfelmus.nfshost.com/articles/operational-monad.html, there is a data type `Program instr a`.
05:40:52 <berndl> As a function of a, they show that this is a monad.
05:42:10 <berndl> Now, this `Program instr a` is just `FFree g a` from http://okmij.org/ftp/Computation/free-monad.html.
05:42:53 <berndl> Now, supposedly `Program instr a` is a free monad on `instr`, but I don't see how.
05:43:41 <berndl> In other words, I can't figure out how to "lift" a function f a -> g a (where g is a monad) to Program f a -> g a
05:44:57 * hackage graphql 0.5.0.0 - Haskell GraphQL implementation  https://hackage.haskell.org/package/graphql-0.5.0.0 (belka)
05:46:17 <berndl> I somehow need to get an f a from Program f a, but I don't see how in the case of Return.
05:48:14 <int-e> berndl: http://paste.debian.net/1095741/
05:48:21 <AWizzArd> Can I pattern-match Data.Map.Strict.empty
05:48:40 <dminuoso> AWizzArd: use a guard?
05:48:54 <berndl> int-e: Let me see...
05:49:46 <dminuoso> AWizzArd: You can only pattern match on data constructors. If what you hold is something different you can use guards or view patterns.
05:49:57 <berndl> int-e: Ah, nice. I forget to use the fact that g is a monad. Doh!
06:03:47 <AWizzArd> dminuoso: k thx!
06:07:03 <berndl> int-e: I'm just realizing that interpret isn't obviously total.
06:08:49 <int-e> berndl: well, there are non-terminating actions in any monad, like foo = return () >> foo...
06:10:54 <c_wraith> > let foo = return () >> foo in foo :: Proxy () -- int-e
06:10:56 <lambdabot>  Proxy
06:11:17 <c_wraith> that Monad ruins so many "all monads" assertions. :)
06:12:38 <dminuoso> c_wraith: Oh wow. There's an ⌜instance Monad Proxy⌝ :o
06:14:22 <c_wraith> yeah, though in practice I'm not sure where it would come up
06:15:07 <c_wraith> I've found good uses for pure with Proxy, but can't see where I'd end up wanting (<*>) or (>>=)
06:16:24 <AWizzArd> Is there a lazy version of (\\) (set/list difference) https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-List.html#v:-92--92- ?
06:16:40 <__Myst__> Is there a better way to write `foldr1 (<|>)` ?
06:16:47 <AWizzArd> "a" \\ repeat 'a' -- this never returns
06:16:50 <dminuoso> __Myst__: asum
06:17:17 <dminuoso> __Myst__: You might also find ⌜getAlt . foldMap Alt⌝ interesting.
06:17:27 <__Myst__> that's longer though
06:17:43 <dminuoso> __Myst__: Well it depends on the context. If you first "fmap and then asum", you could just foldMap via Alt instead.
06:17:45 <merijn> asum
06:17:57 <dminuoso> __Myst__: I just gave it because it belongs into the same corner.
06:17:59 <merijn> You could just asum directly
06:18:01 <merijn> :t asum
06:18:04 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
06:18:05 <dminuoso> merijn: Yeah I mentioend it first :P
06:18:48 <__Myst__> I'm using asum :D 
06:18:50 <__Myst__> ty all
06:20:12 <__Myst__> Is there a better way to, given a list, check if all its elements are the same and if so return the element?
06:20:44 <merijn> :t (==1) . S.size . S.fromList
06:20:47 <merijn> :p
06:20:47 <lambdabot> Ord a => [a] -> Bool
06:20:57 <merijn> > (==1) . S.size . S.fromList $ [1,1,1,1,]
06:20:59 <merijn> > (==1) . S.size . S.fromList $ [1,1,1,1,1]
06:21:02 <lambdabot>  <hint>:1:40: error: parse error on input ‘]’
06:21:03 <lambdabot>  True
06:21:09 <merijn> > (==1) . S.size . S.fromList $ [1,2,1,1,1,1]]
06:21:12 <lambdabot>  <hint>:1:44: error: parse error on input ‘]’
06:21:15 <__Myst__> yeah but I actually want that element
06:21:18 <merijn> typing is hard >.>
06:21:34 <Cale> Perhaps start with group
06:21:36 <dminuoso> __Myst__: case nub l of [x] -> x; _ -> ...
06:21:44 <dminuoso> Oh wait, not nub.
06:21:53 <dminuoso> Or no, nub is fine.
06:22:10 <Cale> Yeah, nub will work well too
06:22:23 <__Myst__> is there a `guard` that takes a f a?
06:22:34 <dminuoso> __Myst__: a what?
06:22:34 <__Myst__> guard :: Alternative f => Bool -> f a -> f a
06:22:40 <__Myst__> something like
06:22:52 <__Myst__> if x then y else empty
06:23:05 <Cale> The instant it finds a second element, it will stop because the pattern match is looking specifically for the singleton there
06:24:01 <dminuoso> % whenA ::  Alternative f => Bool -> f a -> f a; whenA True t = t; whenA False _ = empty
06:24:01 <yahb> dminuoso: 
06:25:49 <dminuoso> % case nub [1..] of [x] -> True; _ -> False
06:25:49 <yahb> dminuoso: False
06:25:56 <__Myst__> no prettier way to write that?
06:25:58 * hackage med-module 0.1.2 - Parse song module files from Amiga MED and OctaMED  https://hackage.haskell.org/package/med-module-0.1.2 (HenningThielemann)
06:26:15 <dminuoso> __Myst__: How is that not "pretty" or elegant?
06:26:15 <__Myst__> a 3-line case statement is kinda ugly in my eyes
06:26:31 <__Myst__> dminuoso: idk it's kinda long
06:26:41 <dminuoso> __Myst__: https://gist.github.com/dminuoso/5efa96c9766d0ac016a818aca5319112
06:26:42 <__Myst__> i mean the case statement, the nub thing is v elegant
06:27:09 <dminuoso> __Myst__: Im unsure how that is not the simplest solution to your problem. :)
06:27:29 <Cale> You can write it on one line ;)
06:27:39 <__Myst__> (\[x] -> return x) works
06:27:43 <__Myst__> but that's even uglier
06:28:00 <dminuoso> __Myst__: That wouldnt work.
06:28:00 <Cale> That doesn't really work because it crashes when the list isn't a singleton
06:28:18 <__Myst__> well actually i made a do statement
06:28:21 <dminuoso> __Myst__: What should it return if not all elements are the same?
06:28:24 <__Myst__> which calls MonadFail.fail which on Maybe is Nothin
06:28:44 <dminuoso> __Myst__: Still, pattern match failure like that only works inside do-notation pattern matches.
06:28:55 <dminuoso> __Myst__: e.g. ⌜[x] <- foo⌝
06:29:00 <Cale> I don't see how that's any nicer than using a case expression
06:29:03 <Ariakenom> monadfail is the worst tho
06:29:11 <__Myst__> ooh, I found a prettier to-my-eyes way
06:29:21 <dminuoso> __Myst__: Dont be afraid to use case-of :)
06:29:21 <__Myst__> onlyElement (nub -> [x]) = Just x; onlyElement _ = Nothing
06:29:26 <Cale> MonadFail isn't so bad. fail was terrible when it was part of Monad itself
06:29:51 <dminuoso> Cale: Heh, I recently spent an hour debugging when I realized that apparently there is two fail floating around. And they are not the same..
06:29:54 <Ariakenom> Cale: true, im confused
06:30:04 <__Myst__> dminuoso: i don't like it for whatever reason 
06:30:06 <__Myst__> haha
06:30:56 <Cale> I think it's when you start trying to figure out how your programs perform that perhaps you begin to like case expressions
06:31:28 <Cale> because their translation into the core is very direct (case expressions are still a thing in core, but the patterns can only match on one constructor at a time)
06:32:23 <Cale> Also, case expressions tend to be easier to work with in a lot of real-world situations than cute points-free expressions.
06:32:28 <dminuoso> Cale: case-of has also an interesting property of forcing you to write programs differently in a much more modular fashion.
06:32:52 <Cale> I might write a cute points-free expression if I expect the code not to change ever again
06:34:19 <dminuoso> mono-traversable question... what methods does MonoFoldable expect me to implement? Im staring at a huge mess of default implementations that I dont understand.
06:34:22 <Cale> But in cases where the thing you're doing isn't necessarily going to stay in some sort of mathematically perfect form, because it's actually determined by the whims of a customer or something, the explicit pattern matching somehow becomes easier to cope with.
06:34:37 <dminuoso> Or do I have to implement all 30ish of them?
06:34:42 <Cale> dminuoso: mu.
06:35:32 <Cale> (if you avoid MonoFoldable, etc. altogether you don't have to ask that question)
06:36:06 <dminuoso> Cale: I sense some sort of resentment against the typeclass.
06:36:15 <Cale> But probably you can get by only implementing foldMap?
06:36:52 <dminuoso> Cale: That was my instinct, Im staring at the class definition and I cant tell. The first weird thing to notice was that it has Nothing for miniminal methods
06:37:27 <Cale> The version I'm looking at says foldMap or foldr
06:37:41 <dminuoso> The default implementations further suggest that I need to supply ofoldMap, ofoldr, ofold' at the least because you may not have Foldable to rely on for their default definitions.
06:37:53 <dminuoso> Cale: Which version is that?
06:38:01 <Cale> oh, I see, yeah, I see the newer and even uglier one now
06:38:36 <Cale> oh good, the defaults write things in terms of Foldable, just to make it easy to write the instance in cases where you wouldn't need one
06:39:00 <dminuoso> Cale: Ah, so basically for the usecase of providing a degraded Foldable instance
06:39:38 <Cale> Well, okay, looking at this, ofoldMap, ofoldr and ofoldl' have those defaults in terms of Foldable
06:39:49 <Cale> and every other default is written in terms of those three things
06:39:54 <Cale> so, you can just define those
06:41:47 <dminuoso> Cale: Ah I suppose that you cant have the cake and eat it as well by specifying those three methods as minimal, and yet provide default implementations for them?
06:43:23 <Cale> You probably could write a MINIMAL pragma anyway
06:43:25 <dminuoso> Cale: The reason for wanting MonoFoldable is that I have quite a few functions ⌜f :: (T, [B] -> m) -> q -> m⌝ for varying choices of q floating around, I think its cleaner if I just wrap them up as MonoTraversable instances. :)
06:43:52 <dminuoso> Err, MonoFoldable I mean.
06:44:14 <dminuoso> I could even write a generic implementation for it
07:00:47 <aoeu256> I just had an idea...  instead of generalizing monads or the type system...  you can create your own embedded DSL by copying Lisp's/Haskell's metacircular evaluator(Lambda calculus?) then adding/removing your own features and then coding directly in it.  This will let you get potentially 100% static error checking and 100% flexibility.  Probably, someone else has already thought of this though.  Is there an easy way to augment and remove "expression 
07:00:47 <aoeu256> types" from Haskell's core AST?
07:02:07 <dminuoso> aoeu256: What is an "expression type"?
07:03:17 <__Myst__> better way to write `x <*> pure y`?
07:03:31 <dminuoso> __Myst__: fmap
07:03:42 <__Myst__> fmap x y?
07:03:49 <dminuoso> __Myst__: Close, think about it for a moment.
07:03:54 <aoeu256> dmnuoso: like the Haskell tree is something like Expr = Const | App a b | Lam a d, wait let me find it
07:03:56 <__Myst__> fmap y x
07:03:57 <dminuoso> __Myst__: Consider the types involved.
07:03:57 <__Myst__> genuis
07:04:04 <dminuoso> __Myst__: Still not quite, think about it. :)
07:04:13 <__Myst__> fmap (\f -> f y) [a -> b] would work
07:04:18 <dminuoso> __Myst__: Great!
07:04:29 <dminuoso> __Myst__: Or, in short, fmap ($ y)
07:04:35 <__Myst__> hwhat if I want this to be point-free?
07:04:51 <dminuoso> __Myst__: You ⌜fmap ($ y) fs⌝ is point-free, is it not?
07:05:29 <__Myst__> over y as well
07:05:44 <__Myst__> well rather
07:05:49 <__Myst__> I have fs and I want the y to be point-free
07:06:10 <dminuoso> __Myst__: You can also define this as an operator, if you use this frequently: ⌜f ?? y = ($ y) <$> f⌝, and then just write ⌜fs ?? y⌝
07:06:23 <aoeu256> dminuoso: https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/core-syn-type 
07:06:25 <dminuoso> (Sort of a "inverted fmap")
07:07:08 <aoeu256> dminuoso: data Expr b = Id
07:07:08 <aoeu256>   | Lit   Literal
07:07:09 <aoeu256>   | App   (Expr b) (Arg b)
07:07:09 <aoeu256>   | Lam   b (Expr b)
07:07:09 <aoeu256>   | Let   (Bind b) (Expr b)
07:07:09 <aoeu256>   | Case  (Expr b) b Type [Alt b]
07:07:13 <aoeu256>   | Cast  (Expr b) Coercion
07:07:15 <aoeu256>   | Tick  (Tickish Id) (Expr b)
07:07:17 <aoeu256>   | Type  Type
07:07:19 <aoeu256>  (is the unicode alright?)
07:07:25 <dminuoso> @pl \y -> fmap ($ y) [odd, even]
07:07:26 <lambdabot> flip fmap [odd, even] . flip id
07:07:30 <dminuoso> __Myst__: I guess :-P
07:07:39 <geekosaur58> o.O
07:07:44 <__Myst__> fmap ($) works actually, doesn't it?
07:07:47 <geekosaur58> maybe the bouncer came back
07:07:51 <dminuoso> __Myst__: No.
07:08:10 <dminuoso> __Myst__: flip fmap [odd, even] . flip ($)
07:08:31 <dminuoso> __Myst__: Honestly just write down the combinator from above if you really want it compact.
07:08:58 <__Myst__> i think this might be a case where it's better to just use the arg
07:09:27 <dminuoso> __Myst__: Ive found that making code point-free is frequently counterproductive.
07:09:46 <dminuoso> There's nothing wrong with parens, and nothing wrong with having explicit code.
07:09:51 <dminuoso> If code gets large, decompose into more bindings.
07:10:05 <dminuoso> Rather than trying to be clever and condensing into using fancy combinators and point free code.
07:10:45 <__Myst__> dminuoso: i don't disagree but it's like a game to me
07:10:52 <dminuoso> Fair enough
07:10:55 <__Myst__> and if you can't have fun doing something why do it at all
07:11:02 <dminuoso> __Myst__: You are absolutely correct. :)
07:11:09 <dminuoso> __Myst__: I didn't know your motivation.
07:11:13 <__Myst__> dminuoso: np :)
07:11:28 <__Myst__> i guess right now you're thinking "better hope i don't have to mantain __Myst__ ever writes"
07:11:30 <__Myst__> haha
07:11:46 <__Myst__> I promise i'm more sane in other langs
07:22:27 * hackage med-module 0.1.2.1 - Parse song module files from Amiga MED and OctaMED  https://hackage.haskell.org/package/med-module-0.1.2.1 (HenningThielemann)
07:26:49 <lavalike> :t (<&>)
07:26:50 <lambdabot> Functor f => f a -> (a -> b) -> f b
07:30:09 <dminuoso> lambdabot: ?? is for when the f is on the other side :)
07:30:09 <lambdabot>  is for when the f is on the other side :)
07:30:21 <dminuoso> Oh heh. I meant that send to lavalike 
07:31:57 * hackage super-user-spark 0.4.0.2 - Configure your dotfile deployment with a DSL.  https://hackage.haskell.org/package/super-user-spark-0.4.0.2 (Norfair)
07:32:57 * hackage super-user-spark 0.4.0.3 - Configure your dotfile deployment with a DSL.  https://hackage.haskell.org/package/super-user-spark-0.4.0.3 (Norfair)
07:35:27 <dminuoso> Cale: Im starting to dislike this MonoFoldable class. It looks like its what I want, but its painful to write instances for it.
07:37:38 <infinisil> dminuoso: Hm, is there a reason it doesn't have default impls?
07:38:08 <arianvp> oh no. I have a pure function that gives a different answer on two different computers 
07:38:10 <arianvp> :(
07:38:22 <Cale> infinisil: It does, it just has the wrong ones for dminuoso's purposes
07:38:36 <dminuoso> infinisil: I have no idea, but I have to write out ofoldMap, ofoldr, ofoldl', ofoldr1Ex, ofoldrl1Ex' and ofoldMap1Ex
07:38:58 <dminuoso> Cale: Well honestly those defaults are not even what MonoFoldable is for.
07:39:18 <Cale> yeah, those defaults only help you when you already had a Foldable instance you could have used instead
07:39:26 <dminuoso> Indeed.
07:39:43 <Cale> (which I guess happens less often in the presence of MonoFoldable because people might actually use MonoFoldable in place of Foldable in their constraints)
07:40:24 <c_wraith> arianvp, yes, Haskell purity is only within the context of a single program execution. there are some pure values exposed in some places that can change between runs of the same program in the same hardware.
07:40:48 <infinisil> Ah yeah, seems that if you have Foldable you don't even need to implement any
07:41:00 <dminuoso> arianvp: IEEE754 alone can produce different answers on different implementations.
07:41:26 <arianvp> Im not using floats anywhere
07:41:42 <arianvp> I am printing   getCallStack and the answer is different in ghc821 and ghc865
07:41:46 <c_wraith> dminuoso, have you considered lens? it's often an alternative to the MonoX classes. slightly different use pattern, but I find it easier to work with.
07:42:28 <infinisil> c_wraith: Huh, I'm not sure how lens could be used for what MonoX classes can do
07:43:02 <c_wraith> arianvp, that's not even using the same library code. why would you expect the call stack to be the same 
07:43:17 <Taneb> infinisil: instead of a MonoFoldable constraint, you can pass a Fold s a, for example
07:43:42 <infinisil> Taneb: And that could still benefit from the instance-specific optimizations?
07:44:16 <arianvp> Not expecting the callstacks to be the same, but the head of the callstack to be the same
07:44:23 <Taneb> infinisil: for stuff like the specialized "length"? No, I don't think so, sadly
07:44:53 <Taneb> But if you're just defining foldMap anyway, then it's at least as good
07:44:56 <arianvp> if I calll    foo from main, and log the callstack in foo. I expect it to be  foo:main:xs but it's foo:xs in ghc821
07:44:57 <infinisil> Taneb: Yeah so this is why I don't think lens could be used as a replacement for MonoX
07:45:15 <infinisil> (if you want good perf)
07:45:19 <Taneb> infinisil: from what dminuosohas described it can in their use-case
07:47:57 <infinisil> I see
07:48:42 <infinisil> I'd say MonoX classes is mainly useful for libraries to not constrain their implementations unnecessarily
07:49:26 <infinisil> s/is/are
07:49:59 <AWizzArd> I have multiple Maps from containers. How can I check if any of them is empty?   Something better than   if x == empty || y == empty || z == empty then ... else ...
07:50:37 <merijn> :t getAny . foldMap (Any . null)
07:50:41 <lambdabot> (Foldable t1, Foldable t2) => t1 (t2 a) -> Bool
07:50:41 <Cale> any M.null [x,y,z]
07:50:54 <eviltwin_b> arianvp, callstacks have been evolving, including what they contain and where they happen; there's no guarantees as to exact matches between versions
07:51:25 <merijn> :t getAny . foldMap (Any . null) $ [M.empty, M.fromList [(1,'c')]]
07:51:26 <lambdabot> Bool
07:51:29 <merijn> eh
07:51:32 <merijn> > getAny . foldMap (Any . null) $ [M.empty, M.fromList [(1,'c')]]
07:51:34 <lambdabot>  True
07:51:37 <Cale> :t any M.null
07:51:39 <lambdabot> Foldable t => t (M.Map k a) -> Bool
07:51:59 <AWizzArd> ah of course
07:51:59 <merijn> Cale: Monoids make everything better ;)
07:52:07 <Taneb> AWizzArd: Cale's suggestion is the way to go. any is a function which takes a predicate and a foldable container, such as a list, and does the sort of p x || p y || p z thing.
07:52:30 <tydeu> Is there any way to build a constant ByteArray# in O(1) time (i.e. without copying)?
07:52:36 <infandum> I have two identical giant IntMap (IntMap a) of x and y. How come a strict sum (foldl' (\acc x -> acc + foldl' (\a y -> a + y) 0 x) 0 x) take no memory at all basically, but intersectionWith (size . intersectionWith (intersectionWith (\ !x !y -> x * y)) x $ y) takes up a ton of memory?
07:53:04 <infandum> Sorry, the x and y in the functions are just anonymous
07:53:16 <infandum> Is there a memory leak with intersectionWith?
07:53:28 <infandum> in Data.IntMap.Strict?
07:53:30 <merijn> infandum: Are you using lazy or strict intersectionWith?
07:54:11 <infandum> merijn: everything is from Data.IntMap.Strict
07:54:16 <merijn> hmm
07:54:22 <c_wraith> tydeu, O(1) compared to what? an array uses enough memory for n entries. there is no possible way to initialize that in less time than it takes to initialize n entries.
07:54:26 <infandum> one sec, let me give you the example
07:54:57 <eviltwin_b> c_wraith, I think they want to turn something existing ino a ByteArray#, or equivalently get a ByteArray#-typed reference to something else
07:55:16 <eviltwin_b> to which the answer is no because gc wouldn't be able to track the multiple references, iirc
07:55:25 <tydeu> c_wraith: Not if its using constant data stored on the heap (like unboxed string literals)
07:56:27 <tydeu> Essentially I'm looking for some facsimile of a ByteArray# literal
07:56:32 <Cale> c_wraith: I wonder if it's possible to design RAM where you can open entire blocks to the bus uniformly...
07:56:40 <infandum> merijn: https://pastebin.com/P2BqQRCW
07:56:59 <infandum> Warning, the intersectionWith will blow up
07:57:29 <infandum> If they are both strict, I would think they would both perform similarly, maybe *2 for the second
07:57:33 <infandum> but it explodes
07:57:46 <Cale> c_wraith: Like, have an address and a mask for setting :D
07:58:02 <infandum> I tried bang patterns for multiplication and that had the same result
07:58:17 <infandum> ah, the original is intersectionWith (*) but you get the idea
07:59:16 <c_wraith> tydeu, that's not what ByteArray# is for. that's what Ptr (or its cousin, Storable vectors) are for
07:59:20 <infandum> It was a quick test, so the anonymous should be !a !b but you know...
08:01:24 <tydeu> c_wraith: interesting, then what exactly is ByteArray# for?
08:02:41 <c_wraith> ByteArray# is for raw bytes managed by ghc's garbage collector.
08:03:33 <tydeu> c_wraith: then why does BigNat use it?
08:04:27 <eviltwin_b> hm. so if I read Data.IntMap.Strict correctly, only the result is guaranteed to be strict; intermediate operations might not be
08:04:43 <eviltwin_b> documentation for it that is, not the implementation
08:05:22 <infinisil> eviltwin_b: What do you mean by result and intermediate operations?
08:05:27 <c_wraith> tydeu, so that it plays nicely with the garbage collector.
08:05:51 <tydeu> c_wraith: does that mean large integer literals are initialized limb by limb?
08:06:35 <c_wraith> eviltwin_b, when you force the evaluation of the IntMap to WHNF, it will also force evaluation of every value in the tree to WHNF.
08:07:14 <eviltwin_b> c_wraith, what I'm thinking is that intersectionWith might conceivably builld a big lazy intermediate, then force it when generating the final result
08:07:49 <eviltwin_b> the specific way Data.IntMap.Strict is documented leaves this possibility open
08:09:23 <infandum> That could be a problem
08:09:49 <c_wraith> tydeu, eh. there's some ugly deep integration between ghc and gmp when it's using gmp for Integer. I have no idea about the details, I just know that gmp is being used in a very unusual way.
08:11:02 <eviltwin_b> gmp is configured to allocate ByteArray#-s from ghc instead of using malloc. (this is why mixing C FFI code that uses gmp usually causes core dumps; sadly, the memory allocator config in gmp is global)
08:11:33 <eviltwin_b> but it means they don't need specific support to gc Integer and other types that have gmp backing (like BigNat)
08:12:06 <eviltwin_b> which may also simplify swapping between gmp and native Integer backends
08:13:21 <tydeu> c_wraith: that's unfortunate -- my use case is trying to lift an Integer to a Template Haskell Exp, since integer literals can be overloaded with RebindableSyntax, an Integer literal can be used in the lifting, I was trying to lift Integer's constructors, which requires lifting BigNat which requires lifting ByteArray# (and copying from an Addr# con
08:13:22 <tydeu> structing using an unboxed string literal did not seem like an optimal implementation)
08:13:37 <infandum> I also see heavy usage in fmap, but the documentation says that "Functor, Traversable and Data instances are the same as for the Data.IntMap.Lazy module, so if they are used the resulting map may contain suspended values (thunks)."
08:13:46 <dminuoso> Taneb: Mind my asking, how would one construct such a suitable Fold?
08:14:04 <dminuoso> Ive been staring at Control.Lens.Fold for a while now, not sure how that'd work.
08:14:57 * hackage refinery 0.1.0.0 - Toolkit for building proof automation systems  https://hackage.haskell.org/package/refinery-0.1.0.0 (ReedMullanix)
08:15:42 <dminuoso> Staring at the provided Fold implementations like ⌜folding sfa agb = phantom . traverse_ agb . sfa⌝ seems less than helpful
08:16:27 * hackage pipes-cborg 0.1 - Encode and decode cborg streams using the pipes and cborg libraries.  https://hackage.haskell.org/package/pipes-cborg-0.1 (RenzoCarbonara)
08:16:55 <c_wraith> dminuoso, usually I write them by hand, but I'm funny that way. :)
08:17:29 <merijn> tydeu: Why exactly do you need to lift Integer like that? i.e. what's your TH supposed to do?
08:18:13 <dminuoso> c_wraith: Do you have an example of what that would look like?
08:18:23 <dminuoso> c_wraith: My brain is melted after staring at lens types too long.
08:19:13 <dramforever> dminuoso: Specialize that to: folding :: (s -> [a]) -> Fold s a
08:19:22 <dramforever> :t toList
08:19:24 <lambdabot> error:
08:19:24 <lambdabot>     Ambiguous occurrence ‘toList’
08:19:25 <lambdabot>     It could refer to either ‘F.toList’,
08:19:46 <dramforever> whatever
08:20:08 <Taneb> dminuoso: Fold s a = Monoid r => (a -> Const r a) -> s -> Const r s, with a bit of squinting that's the same type as foldMap
08:20:12 <dramforever> you just pass folding a suitable 'toList' for your type
08:20:18 <c_wraith> tydeu, is there any reason you're not just generating an IntegerL literal?
08:20:26 <dminuoso> Taneb: Ah I see.
08:20:34 <dminuoso> Taneb: Okay, that made it click I think. )
08:20:36 <dminuoso> Thakns
08:20:40 <Taneb> :) happy to help
08:21:00 <tydeu> c_wraith, merlin: I need to lift an Integer in module that uses RebindableSyntax with a custom fromIntege, thus an IntegerL literal will not actually produce an integer
08:21:16 <tydeu> *fromInteger
08:21:35 <merijn> Why do you even need RebindableSyntax for fromInteger?
08:21:49 <merijn> You could just implement Num to get working literals
08:21:58 <dminuoso> Taneb: Why is the Fold generalized to any Applicative? What other choices for f are used for Folds?
08:22:01 <Taneb> dminuoso: ah, you need to do slightly more squinting than I remember
08:22:10 <Taneb> dminuoso: any Applicative that is also Contravariant
08:22:37 <dminuoso> Taneb: Oh, that effectively limits to do just Const, right?
08:22:44 <Taneb> Because it's Contravariant and Functor you can define something of type f a -> f b (that's in lens somewhere but I forget what it's called)
08:22:45 <dminuoso> (And things isomorphic to it)
08:22:48 <Taneb> YEah
08:23:23 <tydeu> merlin: because I need the type of an integer literal to not merely be contextual (i.e. not polymorphic)
08:23:33 <tydeu> *merijn
08:23:44 <dminuoso> Taneb: What's the point of this generalization? What other choices of Const are interesting?
08:24:00 <Taneb> I'm not sure. I think it makes type-checking easier for GHC
08:25:53 <c_wraith> it's so that you can use a Traversal as a Fold.
08:26:09 <Taneb> So, you essentially have "coerce . pure _" as your mempty and "coerce x <*> coerce y" as your mappend
08:26:25 <Taneb> (coerce is phantom in Data.Functor.Contravariant)
08:32:25 <maralorn> I am still not very comfortable with strict variables in Haskell. I think it’s easy to reason about strict, okay to reason about lazy but I am not sure how to reason about strict-lazy-mixed programs.
08:34:23 * infinisil likes writing `(x:) <$> f` in the definition of the recursive `f` because then it looks like tail-recursion, even though it's not
08:34:29 <dmj`> maralorn: just think of everything as strict until you hit a space leak. 
08:37:16 <dmj`> maralorn: then do some profiling, and sprinkle a couple of bangs around
08:45:31 <c_wraith> maralorn: it's all about creating evaluation dependencies. "when this expression has been evaluated to WHNF, so has that other one" 
08:48:41 <maralorn> dmj`: Exactly this mentality is the one which leaves me deeply uncertain about what is going on.
08:50:44 <maralorn> c_wraith: So when a chunk is evaluated to a point that it "sees" a function call and the parameters of those function call are strict it will force the evaluation of the parameters (but not the function)?
08:51:00 <maralorn> * a thunk
08:52:31 <dminuoso> maralorn: I imagine evaluation being a sort of "pointer" that walks around the AST forcing evaluation. So bang patterns are a way to say "when the pointer goes in there, that other thing is evaluated at the same time along with it"
08:53:02 <dmj`> maralorn: evaluation proceeds from the outside in, the graph will be reduced, thunks evaluated (some of which perform IO) and their results reused by other expressions. For large programs you almost can’t keep it all in your head, why a profiler is so valuable
08:53:54 <dminuoso> maralorn: In case of bang patterns on function arguments it means that entering the function will force the evaluation of those arguments.
08:55:11 <dmj`> maralorn: seq creates an artificial dependency on one expression against another, forcing evaluation of the first expression to WHNF (outermost constructor) before continuing evaluation
08:55:55 <dminuoso> maralorn: Debug.Trace.trace might be a helpful tool for experimentation to tag expressions with side effects to see when they are being forced.
08:56:43 <dmj`> maralorn: Well Typed has some visualization tools / languages of Haskell like languages that demonstrate lazy graph reduction
09:06:00 <dmj`> maralorn: someone should make a website that you can type any haskell expression into and it will step through the evaluation visually
09:06:20 <dminuoso> Sounds like a project for maralorn to start perhaps? :)
09:07:55 <dmj`> It's settled then, maralorn keep us appraised of your progress
09:08:06 <maerwald> dmj`: but seq doesn't have an evaluation order
09:10:23 <c_wraith> just pretend seq is always pseq. that could never be a lie! 
09:12:06 <dminuoso> c_wraith: I do for lambdabot because no pseq :<
09:12:22 <dminuoso> c_wraith: In the current state much of base assumes evaluation order for seq.
09:14:05 <maerwald> c_wraith: but pseq is not seq, because it's not strict in its second argument
09:15:21 <c_wraith> dminuoso: I think that's less true than you expect. many things don't require evaluation order guarantees on seq to work well enough (only one layer of slack in the worst case). given that, ghc optimizes the rest properly. 
09:16:41 <c_wraith> maerwald: huh? unless I'm remembering the type of pseq wrong, that's basically impossible... 
09:17:20 <maerwald> "This is why we have pseq.  In contrast to seq, pseq is only  strict in its first argument"
09:17:45 <infinisil> :t pseq
09:17:47 <lambdabot> error:
09:17:47 <lambdabot>     • Variable not in scope: pseq
09:17:47 <lambdabot>     • Perhaps you meant ‘seq’ (imported from Prelude)
09:18:04 <c_wraith>  maerwald: no, I remembered it properly. there is zero way to force `pseq x y` to WHNF without forcing y to WHNF 
09:18:35 <c_wraith> maerwald: where are you reading that? 
09:19:07 <maerwald> https://hackage.haskell.org/package/parallel-3.2.2.0/docs/Control-Parallel.html#v:pseq
09:19:55 <c_wraith> "(as far as the compiler is concerned)" is quite a huge caveat 
09:20:25 <maerwald> what does it mean?
09:20:29 <c_wraith> operationally, it's absolutely strict in the second argument, as that's required by the type. 
09:21:02 <c_wraith> it means the compiler isn't allowed to infer the second argument is used strictly when doing strictness analysis 
09:21:09 <maerwald> ah
09:42:54 <maralorn> dminuoso: dmj`: That sounds like a cool idea. I’ll write it on the things to do when I am bored after my retirement list.^^
09:45:40 <maralorn> But I feel it would only make sense if I can somehow piggyback on the evaluation process of say ghci. Reimplementing the interpreter on my own sounds like a ton of work.
09:46:58 <maralorn> otoh, ghci processes core and not haskell, right? So having a map from partially evaluated core back to the generating haskell sounds tough.
09:49:05 <inkbottle> Sometimes 'intero' stops working because GHC version of the project is different from that used by intero, or something of the like. Could it be possible to put intero in the dependencies of the project?
09:49:18 <inkbottle> I've tried but it's not a library
09:49:58 <inkbottle> Ive read sth about doing "stack build intero", instead of stack install intero
09:50:07 <inkbottle> but I'd like it in the cabal file
10:03:33 <devalot> inkbottle: I don't *think* you can do that.  But if you're interested in learning something new this is specifically the sort of problem that Nix solves very well.
10:06:17 <boxscape> Am I remembering correctly that list comprehensions used to work for all Monads at some point?
10:06:23 <boxscape> If so, what's the point of removing that feature?
10:08:39 <glguy> boxscape: The point would be to simplify the language and make it easier to know you were looking at a list when you saw []s
10:08:50 <glguy> boxscape: but you can restore the feature with the MonadComprehensions extension
10:08:55 <boxscape> Ah, I see
10:10:01 <inkbottle> devalot: Probably a good idea; any good intro to Nix; or rather diagrams or schematics of what it's doing
10:12:16 <inkbottle> There is a #nixos channel...
10:12:25 <inkbottle> I'll see there
10:19:54 <javjarfer[m]> Hi there, does anyone knows an elegant way to mix SqlPersistT with hspec?
10:20:25 <javjarfer[m]> Looks like there is no nice solution for wrapping a opened connection into several tests definitions
10:25:27 * hackage haskoin-store 0.17.1 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.17.1 (xenog)
10:28:08 <boxscape> is there some easy way to see which extensions are enabled in lambdabot?
10:29:44 <dmwit> ?where lambdabot
10:29:44 <lambdabot> http://haskell.org/haskellwiki/Lambdabot
10:31:31 <dmwit> boxscape: https://github.com/lambdabot/lambdabot/blob/master/lambdabot/State/Pristine.hs.default
10:31:41 <boxscape> thank you
10:32:18 <dmwit> ?where state
10:32:18 <lambdabot> http://silicon.int-e.eu/lambdabot/State/
10:33:07 <dmwit> boxscape: I guess http://silicon.int-e.eu/lambdabot/State/Pristine.hs has what's currently in the lambdabot sitting in this channel, which I guess might be different than what's in HEAD on the repo.
10:33:19 <boxscape> ok
10:33:23 <dmwit> Indeed, it does look to be a bit different.
10:34:02 <boxscape> > (\((+1) -> x) -> x) 4
10:34:04 <lambdabot>  5
10:34:11 <boxscape> yeah, view patterns are in one but not the other
10:38:36 <dmwit> huh
10:38:40 <dmwit> ?where stepeval -- maralorn
10:38:40 <lambdabot> <http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi>,<https://github.com/bmillwood/stepeval>
10:38:50 <dmwit> dminuoso, dmj` too
10:45:14 <owickstrom> Decided today to rewrite my articles on PBT (with Hedgehog) into a short book (60-70 pages). If you're interested, you can sign up at https://leanpub.com/property-based-testing-in-a-screencast-editor and get notified when it's done. :) Cheers!
10:46:54 <jgt1> owickstrom: fan va bra
10:47:02 <owickstrom> :D
10:57:31 <maralorn> dmwit: That postmortem describes fairly well why I expected this to be tough.
10:58:43 <maralorn> And of course for this to be really usefull fur debugging it should probably also evaluate exactly like ghc (including optimizations).
10:59:51 <Boarders> Does anyone know how I could use megaparsec to parse a bunch of "f = 1 \n "g = 2   \n h = \n    4" into something like ["f = 1", "g = 2", "h = 3"]
11:00:05 <Boarders> bunch of statements like*
11:00:36 <merijn> Boarders: "Yes", but I don't suppose that's very helpful ;)
11:01:05 <merijn> Boarders: You are missing: 1) a description of the grammar you mean to parse and 2) where you get stuck trying to parse it yourself
11:03:07 <Boarders> I don't know about a formal description of the grammar, I want it to be an identifier which is any text starting with a lower case letter followed by spaces, followed by equals, followed by text that might possibly be indented but has indentation beyond column 1
11:03:59 <Boarders> Where I get stuck is simply not knowing how to use megaparsec to do something like that
11:04:10 <Boarders> I can write a parser for an identifier and equals sign
11:04:40 <merijn> Boarders: I'd recommend spending some time defining an (e)BNF for your grammar, they're fairly easy so shouldn't take too long: http://matt.might.net/articles/grammars-bnf-ebnf/
11:04:49 <Boarders> ok thanks
11:05:27 <merijn> Boarders: Usually writing a parser for a given BNF is fairly straightforward, but defining your grammar as your implementing it is notoriously confusing and prone to mistakes
11:05:31 <Boarders> though I must say it would be better to have a formal way to specify a lexer than a grammar
11:05:44 <Boarders> because grammars tend not to concern themselves with rules for layout or whitespace
11:06:30 <lavalike> I guess the point is that probably you will want to get more structure out of your initial string than just a list of bindings as strings of the form "_ = _", is that the case?
11:06:36 <merijn> Boarders: Usually you start by implementing individual terminals (i.e. tokens) from your BNF, then writing combinators for more complex rules using those tokens
11:07:12 <Boarders> yes, I do want more structure, this is just meant to be a part of lexing
11:08:25 <lavalike> I guess there's nothing wrong with starting out with many bindings separated by newlines, and then get more specific, merijn?
11:08:51 <merijn> lavalike: Well, it's the complete opposite of how I like to write my parsers, but to each their own ;)
11:09:04 <lavalike> or try both ways!
11:18:13 <texasmynsted> So this course looks interesting but is archived. https://www.edx.org/course/introduction-functional-programming-delftx-fp101x-0
11:18:43 <texasmynsted> Anybody know a way to take it anyway? In particular the exams?
11:18:56 <texasmynsted> Not for credit, just for learning
11:19:36 <texasmynsted> Eric Meijer's Functional programming with Haskell course.
11:22:40 <texasmynsted> nm.
11:22:53 <texasmynsted> Looks like many if not all the materials are available.
11:24:06 <t7> is this silly:     Just $ fromMaybe a b
11:24:43 <merijn> t7: Most likely, but depends on context
11:27:13 <hyperisco> b $> a  ?
11:27:50 <merijn> hyperisco: That always returns a
11:28:51 <cocreature> There is no way to block on a QSem until every resource has been returned (signaled) right?
11:28:52 <glguy> Perhaps used inline and not as a section this could be better? (<|> Just a)
11:29:08 <merijn> cocreature: You want QSemN probably?
11:29:19 <merijn> cocreature: That lets you take/put quantities other than 1
11:29:24 <lavalike> :t \a b -> b <|> Just a -- t7 if you want (:
11:29:28 <lambdabot> a -> Maybe a -> Maybe a
11:29:33 <cocreature> merijn: perfect, thanks!
11:29:49 <lavalike> beaten to the punch
11:30:34 <merijn> I think all these suggestions ignore that there's probably surrounding context that'd lead to a more sensical version than unwrapping like this :)
11:34:33 <hyperisco> @hoogle option
11:34:33 <lambdabot> Data.Semigroup option :: b -> (a -> b) -> Option a -> b
11:34:34 <lambdabot> Text.ParserCombinators.ReadP option :: a -> ReadP a -> ReadP a
11:34:34 <lambdabot> Text.Parsec option :: (Stream s m t) => a -> ParsecT s u m a -> ParsecT s u m a
11:34:57 <hyperisco> https://hackage.haskell.org/package/attoparsec-0.13.2.2/docs/Data-Attoparsec-ByteString.html#v:option
11:56:56 <tabaqui> Are there any plans to add thrift support in Cabal?
11:57:32 <tabaqui> Any other popular compiled dsls like ProtoBuf
11:57:37 <tabaqui> *and
11:58:53 <merijn> tabaqui: What kind of support do you mean?
11:59:21 <tabaqui> I mean how Cabal deals with c2hs and hsc2hs tools
11:59:42 <merijn> tabaqui: You can add those yourself in Setup.hs if you use Custom build-type
11:59:53 <tabaqui> yeah, custom Setup, I know
12:00:08 <tabaqui> ProtoBuf is pretty popular today, as I think
12:01:05 <merijn> tabaqui: Cabal and cabal-install are, tbh, severely undermanned. So most things get added/implemented by people who want it
12:01:09 <tabaqui> I just asked, if Cabal devs are going to add support for these tools one day
12:01:20 <Franciman> why is go more popular than haskell? This world is unfair
12:01:29 <merijn> Franciman: Because Google
12:01:36 <Franciman> damn protobuf
12:01:38 <Franciman> and google
12:01:48 <tabaqui> merijn: fair enough
12:01:54 <Franciman> a new bad tide is grpc
12:02:01 <Franciman> it's related to protobuf and stuff
12:02:03 <Franciman> boy
12:02:11 <tabaqui> yeah, and facebook which maintains thrift
12:02:18 <merijn> tabaqui: The answer to almost all feature requests for Cabal is: Even if cabal devs are interested in having it, unless one needs it themselves or you implement it it's not happening anytime soon ;)
12:03:13 <tabaqui> maybe I'll do :)
12:03:17 <Franciman> cool tabaqui !
12:03:24 <merijn> tabaqui: That said, response times for patches/features is pretty good, although you might want to float the idea past #hackage first or in an issue to see if there's interest in external DSLs like that
12:03:27 <tabaqui> hey, it is not a promise!
12:04:55 <tabaqui> merijn: well, I think it takes less time than my PR in haskeline
12:05:37 * tabaqui is out
12:10:01 <leshow> how does one catch exceptions that can be thrown from pure code
12:10:14 <merijn> leshow: You don't
12:10:23 <merijn> leshow: At least not without A LOT of effort
12:10:32 <leshow> so you can't catch an exception from 'head' inside a pure function?
12:10:44 <boj> leshow: if you mean "errors" you could examine ExceptT
12:10:46 <merijn> You can't catch in pure code at all
12:10:52 <boj> ah
12:10:54 <leshow> well... shit
12:11:20 <merijn> leshow: Worse, you can reliably catch exceptions from pure functions (i.e. error and undefined) inside IO
12:11:28 <merijn> s/can/*can't*
12:13:25 <lyxia> catch and evaluate aren't reliable?
12:13:49 <dmj`> ghc -Wall should warn if there are unused record wild card unpackings
12:13:56 <merijn> lyxia: evaluate only goes to WHNF, so no
12:14:02 <leshow> lyxia: catch uses IO i think
12:14:38 <merijn> leshow: Yeah, he was trying to argue that catch + evaluate can reliably catch exceptions thrown in pure code, except they can't since it only goes to WHNF :)
12:14:53 <lyxia> I guess we don't have the same standards of "reliability"
12:14:59 <merijn> lyxia: You could try deepseq'ing everything, but that's a pretty big freaking hammer
12:15:13 <leshow> oh
12:15:43 <merijn> leshow: Why are you in a position of needing to catch something from/in pure code?
12:16:02 <lyxia> I mean I certainly don't use catch+evaluate every day, but when I use it I'll think about what I want to force to WHNF to get the exception I expect.
12:16:33 <leshow> I'm trying to use the heaps package and it has partial functions, all I want to do is catch the exception if an element isn't found and return a value, my function is pure
12:16:53 <leshow> for ex. Heap.minimum is partial
12:17:21 <merijn> leshow: You could wrap it and check size before calling it
12:17:22 <lyxia> The semantics are precise enough, that's what I would call "reliable". That it takes some effort to understand is a different matter.
12:18:05 <merijn> leshow: "newMinimum heap | size heap > 0 = minimum heap; | otherwise = defaultVal"
12:18:08 <leshow> merijn: yeah, i know, I was just going at it from a different direction. I though I may be able to wrap the call at the top level and just return something if an exception was thrown
12:18:36 <merijn> leshow: This way is *definitely* going to be easier than trying to catch :)
12:18:46 <leshow> fair enough
12:19:58 <cocreature> lyxia: that works if you control the code that produces the exception. If that is some library, having to digg through the source to figure out where it is throwing the exception can be rather tricky
12:20:40 <merijn> Incidentally terrible API design by that package
12:21:51 <dminuoso> cocreature: That's orthogonal to the reliability of said primitives.
12:22:06 <dminuoso> If something is unreliable, it means I couldn't trust it actually does what its advertised to do.
12:22:08 <merijn> dminuoso: I wasn't questioning the reliability of the primitives
12:22:57 <dminuoso> merijn: Well you did say you didn't consider them reliable so...
12:22:59 <merijn> dminuoso: I said it was hard to reliably catch. That doesn't necessarily say the primitives are unreliable, merely that using them is unreliable. And it is, because you need super detailed info in order to correctly predict the right way to use them
12:23:05 <cocreature> the primitives are reliable in themselves but they don’t give you a reliable way to catch exceptions from a third-party lib where you aren’t sure where they are thrown
12:23:13 <merijn> ^^ what he said
12:23:27 <dminuoso> merijn: "catch and evaluate aren't reliable?" "evaluate only goes to WHNF, so no"
12:23:35 <dminuoso> merijn: Sounded different to me, but ah well it doesnt matter. :)
12:24:09 <cocreature> evaluate 
12:24:19 <cocreature> evaluate + force works reasonably well
12:24:23 <cocreature> if there are no bogus instances
12:24:33 <leshow> merijn: yeah it's not great, I wish it had safe versions of the functions
12:24:37 <cocreature> but it’s also unnecessarily slow in a lot of cases and sometimes you don’t have the instance
12:24:42 <merijn> :O
12:24:50 <leshow> I found `uncons` though, it returns a Maybe
12:25:11 <merijn> It's original by edwardk! Revoke his Haskell license!
12:25:24 <leshow> yes it's kmett-senpai
12:26:25 <merijn> leshow: Submit a PR while you're at it? ;)
12:27:50 <leshow> good idea. is there an idiomatic name for a safe version of minimum? safeMinimum?
12:28:29 <jle`> leshow: i've heard it called minumum1
12:29:28 <merijn> minimum1 is generally the unsafe one
12:29:34 <jle`> :O
12:29:42 <merijn> Like foldr1, etc.
12:29:43 <jle`> it is in the scheme of Foldable1
12:29:54 <jle`> oh ah, i forgot about foldr1 convention
12:30:33 <jle`> i was thinking along the lines of Data.Semigroup.Foldable1
12:30:45 <jle`> where you can write minimum1 = coerce fold1
12:34:44 <leshow> is this what you were talking about with forcing evaluation? catch (pure $! div 10 0) (\(SomeException e) -> pure 0)
12:34:49 <leshow> how you have to do $!
12:35:19 <leshow> Ignore that you'd never actually want to write this line, I'm just trying to see how you'd do it
12:35:36 <ski> leshow : use `evaluate' ?
12:36:21 <jle`> evaluate is the IO action you are looking for, not pure
12:36:31 <jle`> pure :: a -> IO a
12:36:36 <jle`> evaluate :: a -> IO a
12:36:42 <jle`> pure produces no IO effects
12:36:49 <jle`> evaluate produces the IO 'effect' of evaluating its argument
12:37:36 <jle`> but yeah, i don't think anyone here would actually do this. if you have pure exceptions/errors you basically can't expect to ever be able to catch or handle any of them
12:37:48 <jle`> reliably or meaningfully
12:38:00 <leshow> that seems like something not great, lol.
12:38:17 <jle`> yeah, which is why you shouldn't ever use pure exceptions/errors :)
12:38:33 <leshow> the problem is they exist in the wild
12:38:57 <leshow> along with partial functions and stuff, it would be nice if the language just didn't support partial functions
12:39:00 <jle`> that is definitely a problem
12:39:11 <jle`> well haskell is a language that lets you be unsafe if you want to
12:39:30 <jle`> it gives you tools to be safe, and it says "use them if you want them"
12:40:21 <jle`> so things like bad pattern coverage can be 'pragmatically' useful in some situations, even if they can potentially ruin your entire program
12:40:23 <leshow> I'd prefer to have total functions be the default, and have to opt out of it explicitly like you have to do with unsafePerformIO or whatever
12:40:31 <ski> `foo' will be forced if `pure $! foo' is forced. while, `foo' will be forced is `evaluate foo' is *executed*
12:41:21 <jle`> leshow: but in that case, you still would have partial functions in the wild
12:42:22 <leshow> It's only one of the problems, the other problem is what you do when you get an exception in a partial function
12:42:26 <jle`> i think the real problem is that there are so many partial functions in base, it makes people think that partial functions are something you can handle sanely in haskell
12:43:16 <jle`> well, there is more than one real problem, heh
12:47:46 <leshow> http://hackage.haskell.org/package/spoon-0.3.1/docs/Control-Spoon.html
12:48:09 <leshow> it uses deepseq
12:50:17 <freeman42x> any ideas where I could find more examples of hedgehog-fn usages? https://github.com/qfpl/hedgehog-fn/blob/master/example/Example.hs
12:50:25 <freeman42x> these examples are too complicated for my brain
12:57:24 <lyxia> How much simpler do you want it to be considering that this is testing a pretty simple law already    map (f . g) xs = map f (map g xs)
12:57:26 <Cale> leshow: Don't actually use spoon :)
12:57:45 <dmwit> leshow: You might consider following the safe package's naming convention. minimumMay would be the choice then if it returns a Maybe.
13:06:27 <EvanR> i believe you that spoon is a bad idea, but i'm having trouble coming up with concrete examples why
13:07:05 <merijn> EvanR: You end up computing way more than needed
13:07:12 <stepcut> is there a way to disable all inlining?
13:07:18 <EvanR> ok so yeah, performance
13:07:36 <merijn> EvanR: deepseq and spoon walk the entire structure, so doing it repeatedly is easily accidentally quadratic
13:07:39 <EvanR> i mean, things that will happen and make you throw your computer through the cubical wall
13:07:54 <EvanR> once you realize what happened
13:07:58 <merijn> EvanR: accidentally quadratic slowdown definitely will :p
13:08:24 <merijn> EvanR: https://accidentallyquadratic.tumblr.com/ for inspiration/horror stories ;)
13:08:53 <EvanR> sure
13:08:59 <EvanR> but quadratic is not exponential
14:46:23 <___laika> if i have a type `Foo a` that's an instance of Monad and Applicative, is there any way to derive the Monad + Applicative instances for `newtype FooT a m = FooT { unFoo :: m (Foo a) }`? or do i have to write them by hand?
14:46:37 <jle`> ___laika: you can derive an Applicative instance
14:46:42 <jle`> but, a Monad instance might not exist
14:47:03 <___laika> `newtype ErrT m a = ErrT { runErrT :: m (Err a) }
14:47:04 <jle`> also important note: you can derive *an* Applicative instance, but not necessarily the useful instance that correpsonds to the Monad instance you want to write
14:47:05 <___laika>   deriving (Functor, Applicative)
14:47:07 <___laika> `
14:47:17 <___laika> gives me an error about eta reduction
14:47:31 <jle`> the deeper "error" is that a Monad might not exist
14:47:39 <___laika>  (even with cunning GeneralizedNewtypeDeriving):
14:47:41 <___laika>         cannot eta-reduce the representation type enough
14:47:51 <___laika> formatting--
14:48:48 <jle`> for an example where a Monad instance may not exist, see IO
14:49:09 <jle`> for an example where the Applicative instance exists, but the auto-derived one doesn't correspond to the desired one, see Maybe
14:49:27 <lyxia> ___laika: deriving Applicative via Compose m Foo    it's not newtype-derivable.
14:49:57 <jle`> ^ yes, that gives you *an* Applicative instance, but not necessarily the one you want
14:51:09 <lyxia> jle`++
14:53:40 <___laika> lyxia++ jle`++
14:55:08 <jle`> ___laika: basically, there is no general way to compose two monads in a way where the new one is also a monad. you will have to do it manually for Foo/Err by providing the meaning and semantics you want for >>=
14:55:20 <jle`> and what you want >>= to "mean"
15:06:39 <dmwit> ___laika: Does ExceptT not already cover the ground you want to cover?
15:22:10 <___laika> it does, im following a textbook that uses a code generator that introduces its own Err monad and im wrapping that in a transformer to use IO
15:23:05 <___laika> if i were working on an actual project id use ExceptT for this case
17:38:58 * hackage shake-minify-css 0.1.0.0 - Shake rules for CSS  https://hackage.haskell.org/package/shake-minify-css-0.1.0.0 (vmchale)
18:12:58 * hackage network-run 0.1.0 - Simple network runner library  https://hackage.haskell.org/package/network-run-0.1.0 (KazuYamamoto)
18:16:19 <josiah_sama> Why does `Pipes.Producer'` require a Monad in the second type argument?
18:16:40 <josiah_sama> oh, nevermind, found my answer just now in Proxy.
18:29:12 <alx741> hello all. How can I use as dependency a library that I keep only in github? (using cabal only)
18:38:11 <jackdk> you will want to set up a cabal.project file, and put in a source-repository-package stanza
18:47:59 <alx741> oh! so 'haskell.org/cabal/users-guid' is behind 'cabal.readthedocs.io'
18:48:07 <alx741> jackdk: will check that out, thanks!
19:23:58 * hackage concurrent-dns-cache 0.1.3 - Concurrent DNS cache  https://hackage.haskell.org/package/concurrent-dns-cache-0.1.3 (KazuYamamoto)
19:34:57 <rubik> anybody still awake?
19:35:15 <rubik> i'm spicking through the typeclassopedia currently
19:35:34 <dmwit> ?where justask
19:35:34 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
19:36:09 <monochrom> I think they're already typing in the question.
19:36:09 <rubik> ok sry
19:36:28 <monochrom> ?where dontanswer
19:36:28 <lambdabot> I know nothing about dontanswer.
19:37:21 <monochrom> ?where dontpressenter
19:37:22 <lambdabot> I know nothing about dontpressenter.
20:03:48 <Axman6> rubik: did you have a question about the typeclassopeadia?
20:51:39 <___laika> let me know if i have this right: haskell's Functor is, necessarily, an endofunctor for the category Hask. for Category y and Category z, a given haskell Functor could also be a "non endofunctor" mapping y to z, or an endofunctor for the arbitrary Category y, mapping y to y. does this make sense?
20:57:43 <___laika> or rather, for all a, Functor a is an endofunctor in Hask
21:06:06 <EvanR> for all Functor f, f is an endofunctor on Hask
21:06:53 <EvanR> handwaving for the sake of something what Hask is
21:09:18 <EvanR> just saying f is the type ctor, Functor f is the evidence that f is a functor
21:22:27 <jle`> ___laika: any functor represented by the Functor typeclass is from category Hask to category Hask
21:22:59 <jle`> we can represent other sorts of functors in a programming language, but specifically the Functor typeclass represents a functor from Hask to Hask
21:23:10 <___laika> that makes sense
21:23:16 <jle`> the Functor typeclass from the base library, in Data.Functor
21:23:34 <___laika> yes :) some of the category theory is just starting to stick...
21:23:51 <___laika> just a lil
22:09:55 <dmitri> Hey folks, can anyone help with problems installing ghcup?
22:10:27 <dmitri> getting this error: Failed to create temporary directory
22:10:27 <dmitri> "ghcup --cache install" failed!
22:10:43 <dmitri> trying to follow https://www.haskell.org/ghcup/#
22:27:28 * hackage antiope-s3 7.3.0 - Please see the README on Github at <https://github.com/arbor/antiope#readme>  https://hackage.haskell.org/package/antiope-s3-7.3.0 (arbornetworks)
22:28:27 * hackage antiope-athena 7.3.0, antiope-sqs 7.3.0, antiope-messages 7.3.0, antiope-swf 7.3.0, antiope-contract 7.3.0, antiope-sns 7.3.0, antiope-dynamodb 7.3.0, antiope-core 7.3.0, antiope-optparse-applicative 7.3.0 (arbornetworks)
22:34:46 <cocreature> dmitri: can you show more of the output you’re getting? maybe just put all of it in a github gist or some other pastebin site
22:43:56 <dmitri> @cocreature> please see errors here: https://gist.github.com/dmitriz/a128155631b40704cdd5ac6b0aba36a0
22:43:56 <lambdabot> Unknown command, try @list
22:45:14 <cocreature> dmitri: That’s macos’ mktemp being different from the gnu mktemp, see https://unix.stackexchange.com/questions/30091/fix-or-alternative-for-mktemp-in-os-x
22:46:08 <cocreature> The easiest fix is probably to patch the ghcup script and replace "mktemp -d" with "mktemp -d -t tmpdir"
22:47:30 <cocreature> Alternatively, get a gnu mktemp from somewhere and put it in PATH
22:48:30 <cocreature> probably worth reporting on the ghcup issue tracker if there is not already an issue
22:48:42 <dmitri> Ah thanks! How nice of them to make it different for MacOS :)
22:57:53 <dima14> @cocreature The patch had worked, thanks again!
22:57:53 <lambdabot> Unknown command, try @list
22:58:21 <Axman6> dima14: we don't use @ on IRC :)
22:59:32 <dima14> Axman6: I see, thanks
23:01:34 <dima14> I am really trying to install this better REPL: https://github.com/litxio/ptghci
23:03:14 <dima14> But my "stack" is too old, which of course I have only found out by googling the error
23:14:38 <dminuoso> Is this a buggy diagnostic? How does GHC come to the conclusion that the "Actual type" of exceptions is ⌜[E.Handler IO (Either ServerError a0)]⌝ https://gist.github.com/dminuoso/3e50d3f8cb179b659562d4580485142e 
23:14:50 <dminuoso> exceptions should fail to type check.
23:16:24 <dminuoso> It doesn't have any actual type.
23:18:27 <Cale> dminuoso: When there's more than one type mismatch, it can be hard to say which thing gets blamed
23:18:59 <Cale> If you add a type signature to exceptions, it should give you a better error.
23:19:18 <Cale> It determined the actual type by looking at the first element of the list
23:19:47 <dminuoso> Cale: So GHCs inference is fast and lose and doesn't fully infer the type, instead making a quick guess and later checking whether it was right?
23:19:47 <Cale> It would also have complained about the second element -- you might even also have that error message somewhere in your GHC output?
23:20:00 <dminuoso> Cale: No it didnt, it stopped right there.
23:21:01 <Cale> What happens if you swap the elements of the list?
23:21:35 <dminuoso> Cale: Then I get the expected diagnostic on ⌜exceptions⌝
23:21:53 <jle`> dminuoso: this looks like a property of Hindley Milner
23:22:14 <Cale> Yeah, it's probably just a property of the order in which the expression is being traversed during typechecking
23:22:25 <Cale> It's finding the outermost type error
23:22:29 <jle`> it tries to guess at a type by filling in holes (nondeterminstically), and as soon as it finds a contradiction, it poots out
23:22:32 <dminuoso> jle`: Ohh wow, actually that makes sense. I forgot how lists are defined. :)
23:23:07 <dminuoso> Since that list is actually (E.Handler prpgSrvErr : xs) it can use the type of : and the app rule to infer its type.
23:23:19 <Cale> yes
23:23:46 <Cale> and then the type that it infers from that is already a problem
23:23:52 <Cale> without having to consider xs
23:23:54 <dminuoso> Right
23:24:40 <dminuoso> Thank you both. :)
23:24:44 <Cale> Maybe it ought to be more aggressive and try to recover and typecheck exceptions on its own, but... there are certain concessions that are currently made
