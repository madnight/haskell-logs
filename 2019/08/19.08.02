00:05:38 <jonge[m]> does anybody have experience with `servant-docs`? i am trying to use the `pretty` function on my api to provide docs with pretty-printed JSON examples. this does work for `docs` and `docsWithIntros` but not `docsWith` because `JSON` and `PrettyJSON` don't match in the api type. https://github.com/haskell-servant/servant/issues/127
00:07:31 <dminuoso> jonge[m]: I dont see why "docsWithIntros" would work but not with "docsWith". Can you share your code and full error message in a gist?
00:09:33 <dminuoso> (My best guess is that your ExtraInfo has a different type than your api proxy)
00:10:32 <jonge[m]> dminuoso: i can't share the code. but i will build a minimal example for it if necessary. of course my extrainfo has a lot of proxy type descriptions that describe the individual routes... can you think of a way that i need to massage the extrainfos in order to make it work?
00:12:01 <dminuoso> jonge[m]: Id prefer to look at your code sample first to get an idea what you are trying to do exactly.
00:12:46 <dminuoso> jonge[m]: And by "different type" I mean that "newtype ExtraInfo api" - the type parameter itself must be the same as the one in the proxy.
00:13:37 <jonge[m]> ok i prepare a sample, one moment.
00:20:15 <Axman6> jonge[m]: I would usually just use swagger to do this
00:25:43 <jonge[m]> dminuoso: https://gist.github.com/tfc/f74e80a834c7af68f45e5e51e7ee4b3c
00:26:07 <dminuoso> jonge[m]: Ah.
00:26:13 <dminuoso> jonge[m]: Use the Pretty type family.
00:26:23 <jonge[m]> Axman6: looks like i should give it a look. currently i need to make it work with servant-docs, but i could settle over to swagger longterm if it's more awesome. thanks for pointing me there.
00:26:29 <dminuoso> jonge[m]: https://hackage.haskell.org/package/servant-docs-0.11.3/docs/Servant-Docs-Internal-Pretty.html#t:Pretty
00:26:30 <jonge[m]> dminuoso: how?
00:27:00 <dminuoso> jonge[m]: extra :: ExtraInfo (Pretty MyApi)
00:27:30 <dminuoso> jonge[m]: A type family is basically just a type level function. The Pretty type family takes some api type and transforms it such that it replaces all JSON with PrettyJSON
00:27:47 <dminuoso> jonge[m]: The reason you need this is:
00:27:58 <dminuoso> pretty :: Proxy api -> Proxy (Pretty api) 
00:28:07 <dminuoso> docsWith :: HasDocs api => DocOptions -> [DocIntro] -> ExtraInfo api -> Proxy api -> API 
00:28:25 <dminuoso> See how ⌜... ExtraInfo api -> Proxy api⌝ has the same type variable "api" ?
00:28:48 <jonge[m]> dminuoso: ok. when i import the pretty header and adapt the type of my extra info as you said, then i get complicated compiler error messages where it cannot deduce the types of the other things inside my extrainfo function
00:29:15 <dminuoso> Mmm, I gotta drop out (trains being trains).
00:29:43 <jonge[m]> dminuoso: any chance you could help me out later?
00:30:28 <dminuoso> jonge[m]: Unlikely Im out in the city. https://gist.github.com/tfc/f74e80a834c7af68f45e5e51e7ee4b3c#file-servant_docs_pretty-hs-L39-L42 contains a few type annotations that possibly need the same adjustment.
00:30:52 <dminuoso> But there's plenty of folks more competent than me in here that can help you out.
00:32:14 <jonge[m]> dminuoso: d'oh of course i needed to add `Pretty` to the proxy lines everywhere. this does now work!
00:32:38 <jonge[m]> dminuoso: thank you very much!
00:32:54 <jonge[m]> the solution is simple, i was just too dumb to do it without some hinting. :)
01:13:08 <Axman6> @hoogle Int# -> Bool
01:13:09 <lambdabot> GHC.Exts isTrue# :: Int# -> Bool
01:13:09 <lambdabot> GHC.Types isTrue# :: Int# -> Bool
01:13:10 <lambdabot> Data.Deriving.Internal isTrue# :: Int# -> Bool
01:26:26 <merijn> Axman6: Ah, you know it gets good when you have to -XMagicHash your way through a problem ;)
01:27:18 <cocreature> it is a well kept that to make your Haskell code fast, you have to add # to all names
01:29:32 <merijn> cocreature: And unsafe*
01:29:46 <merijn> cocreature: Of course it's best if you do both
01:30:11 <Taneb> unsafeConst#
01:30:27 <cocreature> merijn: and don’t forget to import all .Internal modules
01:30:59 <merijn> cocreature: Way ahead of you, did I ever show you this beauty? https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/src/Utils/Vector.hs
01:31:16 <merijn> The only thing missing is unsafeCoerce :p
01:31:26 <cocreature> merijn: yeah I think I remember that, lovely :)
01:32:27 <merijn> You can write C in any language :D
01:56:20 <Axman6> merijn: ha, yes indeed. Trying to wrie some branchless code
01:56:34 <Axman6> branchless merge to be precise
01:57:54 <Axman6> merijn: any reason to use (undefined `asTypeOf` VS.head v) and not just VS.head v?
01:58:36 <merijn> Axman6: The former is a no-op, the latter actually does something
01:59:04 <Axman6> but sizeOf shouldn't be forcing the result, so they should be no ops no?
01:59:29 <merijn> Lemme check what the code is doing anyway, it's been awhile and through several rounds of refactoring, so maybe I just didn't notice I left it there
02:44:03 <Axman6> @check \x y -> min x y == y - (x - y::Word32)
02:44:06 <lambdabot>  *** Failed! Falsifiable (after 1 test):
02:44:06 <lambdabot>  1 0
02:44:18 <Axman6> @check \x y -> min x y == y - (x - y::Int32)
02:44:21 <lambdabot>  *** Failed! Falsifiable (after 3 tests):
02:44:21 <lambdabot>  0 1
02:46:05 <Taneb> Axman6: both of those types wrap on underflow
02:47:51 <merijn> The second isn't underflowing, though :p
02:48:20 <Taneb> merijn: true
02:48:31 <Taneb> What I said wasn't false, just maybe not relevant
02:48:33 <Taneb> ;P
02:49:25 <Axman6> @check \x y -> min x y == y + (x - y::Int32)
02:49:29 <lambdabot>  *** Failed! Falsifiable (after 1 test and 1 shrink):
02:49:29 <lambdabot>  1 -1
02:49:53 <Taneb> Axman6: that's algebraically equivalent to min x y == x
02:51:19 <Axman6> yeah, I meant y - x
02:51:33 <Axman6> which is also wrong
03:04:19 <ski> (hm, are there processors with `min' and `max' instructions ?)
03:15:39 <Axman6> I believe there are for vectors on x86
03:16:44 <Axman6> @check \x y -> let dif = y - x; isNeg = dif `shiftR` (finiteBitSize dif - 1) in y - (dif * isNeg) == min x (y::Int32))
03:16:44 <lambdabot>  <unknown>.hs:1:111:Parse error: )
03:16:50 <Axman6> @check \x y -> let dif = y - x; isNeg = dif `shiftR` (finiteBitSize dif - 1) in y - (dif * isNeg) == min x (y::Int32)
03:16:54 <lambdabot>  *** Failed! Falsifiable (after 4 tests and 3 shrinks):
03:16:54 <lambdabot>  2 -2
03:35:38 <mniip> @let type Representable (f :: k -> l) = (forall a b. Coercible a b => Coercible (f a) (f b))
03:35:39 <lambdabot>  .L.hs:177:20: error:
03:35:40 <lambdabot>      Not in scope: type constructor or class ‘Coercible’
03:35:40 <lambdabot>      |
03:36:02 <mniip> @let type Representable (f :: k -> l) = (forall a b. Data.Coerce.Coercible a b => Data.Coerce.Coercible (f a) (f b))
03:36:03 <lambdabot>  .L.hs:177:20: error:
03:36:04 <lambdabot>      Not in scope: type constructor or class ‘Data.Coerce.Coercible’
03:36:04 <lambdabot>      No module named ‘Data.Coerce’ is imported.
03:36:15 <mniip> anyway,
03:36:21 <mniip> how do I make a quantified constraint synonym
03:36:35 <mniip> if I write "type F = a => b" it thinks "b" is a type
03:36:52 <mniip> and there's no place to stick a :: Constraint into
03:44:43 <iqubic> That seems like it should be possible, but I'm not sure how.
03:49:26 <[exa]> ski: MINPS?
03:57:35 <lyxia> type F a = (Show a => Eq a :: Constraint)
03:57:59 <lyxia> RankNTypes, KindSignatures
04:20:22 <merijn> So, is there any work on reflex for things that are *not* reflex-dom?
04:20:44 <merijn> (i.e. GUI bindings, OpenGL, that sorta thing)
04:25:17 <cocreature> merijn: iirc there are gloss bindings
04:26:16 <merijn> oh, neat
04:37:20 <maerwald> is there a special way you must kill an app so it writes profiling data?
04:38:10 <sicklorkin> maerwald: iirc sigterm should work
05:14:12 <hyperisco> Has anyone heard of an EDSL to generate documentation?
05:14:49 <hyperisco> Or really just documents… and not latex
05:16:13 <merijn> TeX? *duck*
05:17:59 <Axman6> Pandoc?
05:18:11 <Axman6> though its AST is very low level
05:18:19 <hyperisco> That's just to translate formats, no
05:18:36 <hyperisco> The point is to take advantage of all the usual facilities of a programming language to write documents
05:18:38 <Axman6> well, it has an AST
05:21:46 <hyperisco> That could be an implementation
05:21:51 <sicklorkin> hyperisco: are you lookin gfor something like overleaf?
05:22:17 <hyperisco> An online latex editor? no
05:23:28 <hyperisco> Guess I'll have to build it myself but using pandoc to implement is a good idea, thanks.
05:28:01 <[exa]> hyperisco: do you want to embed the documentation in code?
05:28:09 <hyperisco> no
05:28:48 <[exa]> hyperisco: otherwise most people just use markdown and convert to whatever they like
05:29:25 <[exa]> I guess you want some kind of macro support?
05:29:26 <hyperisco> Markdown does not have the static analysis that a PL does
05:29:46 <hyperisco> Such as checking variable scope, types, etc
05:30:10 <hyperisco> And a PL describes computations, which you can use to compose documents without repeating yourself
05:30:10 <sicklorkin> what does doctest use?
05:30:12 <merijn> markdown doesn't even have a consisten specification
05:30:29 <merijn> Do not use markdown if you want to do anything programmatic/systematics
05:30:34 <hyperisco> Which is also a boon to refactoring / revising documents
05:31:00 <merijn> reStructured Text is superior to markdown in every way except brevity and it's not *that* much more verbose...
05:31:11 <hyperisco> The biggest problem is that if I make a change, how do I know where all to propagate that change across my document?
05:31:17 <hyperisco> PLs can help in that regard
05:31:20 <[exa]> yeah reST is cool
05:32:11 <[exa]> hyperisco: so you basically want some lightweight version of latex that has types and does not necessarily output pages/pdfs?
05:32:37 <hyperisco> I don't know what is meant by "lightweight", but the output would be different formats
05:32:57 <[exa]> lightweight = without the 50 years of cruft
05:33:19 <hyperisco> I don't know latex well enough to determine how different it is
05:33:26 <hyperisco> I just know it is so confusing I don't even want to look at it
05:33:51 <[exa]> it's not, in fact it is a very simple language
05:34:18 <hyperisco> Somehow I can only make a simple one page document after extensive Googling and copy pasting
05:34:26 <hyperisco> and I don't know if it supports any of the actual features I am interested in
05:34:29 <hyperisco> I am not interested in formatting
05:34:48 <[exa]> well there is some weirdness about how the interpreter works (it is vaaaaaaaaguuuuuuueeeeeelllyyyyy close to postscript) :]
05:35:09 <[exa]> anyway if you don't want printed pages you don't want tex
05:35:29 <[exa]> perhaps some modern variants of roff?
05:35:33 <hyperisco> generating a Pandoc and then letting pandoc do the rest is fine by me
05:36:55 <hyperisco> I'm not sure how practical that is… it seems there is a lot of stringly typed stuff in Pandoc
05:38:25 <merijn> hyperisco: Have you looked at TeX, though?
05:38:32 <hyperisco> no
05:39:02 <merijn> hyperisco: I mean, LaTeX is years of crufty macros extended and piled on top of by hundreds/thousands of package authors, sure
05:39:22 <merijn> But TeX itself is pretty small and clean
05:39:44 <Axman6> There's also HTML >_>
05:39:48 <merijn> Sure, there's no good way to structure entire documents in it, but that's what you wanted to build, so it might be a good target language
05:40:20 <hyperisco> you guys are all talking about formats
05:40:25 <Axman6> which is probably structured eough, and could be converted with something like pandoc
05:40:26 <sicklorkin> hyperisco: https://docs.gitbook.com/ 
05:40:57 <hyperisco> it is like I am looking for a web framework and we're arguing about XML vs JSON
05:41:03 <Axman6> they're formats which provide structure though, and they also have DSL sfor generating them which might include what you want
05:41:36 <Axman6> for example, type-of-html
05:41:44 <gakusei> hi
05:41:53 <hyperisco> but I guess people haven't much thought of writing a program to produce a document
05:42:04 <gakusei> is there a way to get a random element from a list in haskell? Specifically i want to get a random char from a string
05:42:40 <Axman6> there are ways to get random integers, and ways to index lists, which can be combined to do that
05:42:51 <gakusei> that'll do
05:42:59 <gakusei> how do i get a random integer within the range of the list
05:43:04 <gakusei> so from 0 to length list
05:43:13 <[exa]> gakusei: what source of randomness do you have?
05:43:14 <Axman6> :t randomR
05:43:15 <lambdabot> (Random a, RandomGen g) => (a, a) -> g -> (a, g)
05:44:07 <sicklorkin> > randomRIO (0,99)
05:44:14 <lambdabot>  mueval-core: Time limit exceeded
05:44:30 <Axman6> :t newgen
05:44:32 <lambdabot> error: Variable not in scope: newgen
05:44:33 <Axman6> :t newGen
05:44:36 <lambdabot> error: Variable not in scope: newGen
05:44:49 <gakusei> sicklorkin: won't that return an IO Int?
05:45:16 <gakusei> which i can't use to access an element of a list i don't think
05:45:37 <Axman6> well, you can, but you'll have to do it from IO
05:45:44 <gakusei> [exa]: i'm not sure i understand the question, currently i have no randomness but i need it
05:45:51 <Axman6> :t mkStdGen
05:45:53 <lambdabot> Int -> StdGen
05:46:44 <gakusei> [exa]: i want semi-psuedo-randomness i guess
05:46:48 <Axman6> :t \seed xs -> randomR (0,length xs - 1) (mkStdGen seed)
05:46:50 <lambdabot> Foldable t => Int -> t a -> (Int, StdGen)
05:47:41 <Axman6> :t \seed xs -> case randomR (0,length xs - 1) (mkStdGen seed) of (idx,gen') -> (xs !! idx, gen')
05:47:43 <lambdabot> Int -> [a] -> (a, StdGen)
05:48:31 <Axman6> there's also randomRs:
05:48:35 <Axman6> :t randomRs
05:48:38 <lambdabot> (Random a, RandomGen g) => (a, a) -> g -> [a]
05:49:25 <Axman6> :t \seed xs -> map (xs !!) $ randomRs (0,length xs - 1) (mkStdGen seed)
05:49:27 <lambdabot> Int -> [a] -> [a]
05:49:47 <hyperisco> How well are row types doing in Haskell? I see https://hackage.haskell.org/package/row-types but how are they to use?
05:49:55 <Axman6> > (\seed xs -> map (xs !!) $ randomRs (0,length xs - 1) (mkStdGen seed)) ['A'..'Z'] 
05:49:59 <lambdabot>  error:
05:49:59 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘[Char]’
05:49:59 <lambdabot>      • In the first argument of ‘\ seed xs
05:50:10 <Axman6> > (\seed xs -> map (xs !!) $ randomRs (0,length xs - 1) (mkStdGen seed)) 31337 ['A'..'Z'] 
05:50:12 <lambdabot>  "XJFCBDOQULRWUTPRPXZJNFIRRLYJXOFAUIUYCPWHYQFZLJIIGRWMZFJWBFXAAFEXEGUXRXKQOPV...
05:50:30 <Axman6> > (\seed xs -> map (xs !!) $ randomRs (0,length xs - 1) (mkStdGen seed)) 31338 ['A'..'Z'] 
05:50:33 <lambdabot>  "XIJBDBEMTHBXOGGTFCCRTAQMXONFFSOEFDEIUQXAFCGJQLRIFQUWVHWWCFCLSGGGLSNQVIWTAXR...
05:51:55 <sicklorkin> hyperisco: how far could you go with dhall? i've been using it to generate templates for configs and it works great.
05:52:19 <sicklorkin> rather generate configs from templates
05:52:36 <hyperisco> I am not sure what it has to offer that, say, Haskell doesn't.
05:53:09 <gakusei> how can i generate a random number between 0 and the length of a list?
05:53:41 <gakusei> such that each time i run the program it generates a different number
05:54:13 <sicklorkin> hyperisco: that' cou'd be said aboutg anyting really
05:54:33 <hyperisco> PS has row types and I've grown fond of them. Just saying.
05:54:40 <hyperisco> I've found it! https://hackage.haskell.org/package/madlang
05:54:51 <Axman6> gakusei: you just need top generate a random seed at prograsm start in IO
05:54:56 <Axman6> to*
05:55:26 <gakusei> Axman6: then what? And how do i do that?
05:56:06 <sicklorkin> hyperisco: nice.. 
05:56:15 <Axman6> main = do seed <- randomIO; let xs = ['A'..'Z']; print $ map (xs !!) $ randomRs (0,length xs - 1) (mkStdGen seed)
05:57:41 <Axman6> once you have than random Int you can pasds it to any pure functions you want, and use it to seed any random operations you want
05:59:27 <gakusei> Axman6: doesn't that return a [Int] rather than an Int
05:59:38 <Axman6> which?
05:59:59 <Axman6> that program will print out an infinite String
06:00:25 <gakusei> oh, i thought that was the program to generate a random Int :P
06:00:47 <gakusei> a random char i mean
06:00:51 <gakusei> from a random int
06:01:08 <Axman6> randomRs produces an infinite list of random values
06:01:20 <gakusei> oh right
06:01:27 <Axman6> using a initial random generator
06:01:31 <gakusei> how do i get it to produce a random Int within a range?
06:02:23 <Axman6> well, randomRs (lo,hi) someStdGen will produce an infinite list of random Ints. randomR will give you back a new StdGen which can be used to generate your next random Int
06:02:33 <Axman6> :t randomR @Int
06:02:37 <lambdabot> error:
06:02:37 <lambdabot>     Pattern syntax in expression context: randomR@Int
06:02:37 <lambdabot>     Did you mean to enable TypeApplications?
06:02:43 <Axman6> % :t randomR @Int
06:02:44 <yahb> Axman6: RandomGen g => (Int, Int) -> g -> (Int, g)
06:02:53 <Axman6> % :t randomRs @Int
06:02:53 <yahb> Axman6: RandomGen g => (Int, Int) -> g -> [Int]
06:05:16 <Axman6> > randomR (0,10) (mkStdGen 39873)
06:05:21 <lambdabot>  (0,1595518236 40692)
06:05:29 <Axman6> > randomR (0,10) (mkStdGen 3987453)
06:05:32 <lambdabot>  (8,640200694 40692)
06:05:55 <Axman6> :t unfoldr
06:05:57 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
06:06:29 <Axman6> > unfoldr (Just . randomR (0,100)) (mkStdGen 239852) :: [Int]
06:06:34 <lambdabot>  [20,50,26,99,98,36,75,48,89,72,85,9,55,41,52,54,12,25,99,78,47,56,88,45,74,7...
06:08:34 <Axman6> gakusei: does any of that help?
06:09:45 <gakusei> Axman6: not really i'm not sure how it all fits together, i'm too new to haskell i guess
06:10:00 <gakusei> a code example would probably be helpful
06:10:12 <sicklorkin> gakusei: show us what you have so far
06:10:40 <gakusei> sicklorkin: i've tried various things and ended up deleting them
06:10:59 <Axman6> the code starting with main =  above is a whole program which shows generating a random Int at runtime, then using that seed the generation of pseudo-random Ints which are used to index a given list
06:12:13 <Axman6> main = do { seed <- randomIO :: IO Int; let selectionList = ['A'..'Z']; print $ map (selectionList !!) $ randomRs (0,length selectionList - 1) (mkStdGen seed) }
06:12:32 <Axman6> if System.Random is imported, this is all you need. 
06:12:43 <gakusei> ok i'll try it out 
06:12:44 <gakusei> one moment
06:13:19 <Axman6> you can replace the ;'s with new lines to make things clearer
06:13:24 <Axman6> main = do
06:13:28 <__monty__> hyperisco: Main differentiator between dhall and haskell afaik is totality. And I *think* that results in complete reproducibility for dhall.
06:13:32 <gakusei> okay thanks
06:13:32 <Axman6>   seed <- randomIO :: IO Int
06:13:40 <Axman6>   let selectionList = ['A'..'Z']
06:13:55 <Axman6>   print $ map (selectionList !!) $ randomRs (0,length selectionList - 1) (mkStdGen seed)
06:13:59 <__monty__> Axman6: Please pastebin rather than spamming the channel.
06:15:24 <hyperisco> Whoa, I installed Haskero with VS Code using stack and something amazing happened
06:15:25 <gakusei> Axman6: okay i did that and it generates an infinite string
06:15:27 <Axman6> I'd argue that 4 lines is hardly spam __monty__
06:15:35 <Axman6> hyperisco: it worked?
06:15:41 <gakusei> Axman6: should i just do head of that since i just want one char?
06:15:59 <hyperisco> 1) It built successfully the first time, 2) It ran successfully in the IDE the first time, 3) It told me the type of a term successfully the first time
06:16:22 <hyperisco> Hopefully it'll achieve 4) Works just as well tomorrow
06:16:29 <Axman6> gakusei: thewre's many different things you can do, it all depends on what you want to do next
06:16:37 <__monty__> Axman6: Any multi-line code sample is much more understandable in a paste and you've repeated this quite a bit of times now. It's a lot of noise in a busy channel.
06:17:19 <gakusei> Axman6: what's the function signature for that so i can wrap it in a function to call?
06:17:27 <hyperisco> Oh boy, "go to definition" worked
06:17:29 <gakusei> for the bit $ map (selectionList !!) etc
06:17:46 <hyperisco> It is reeeeally slow but it worked
06:18:09 <hyperisco> Takes 2-3 seconds to go to a definition within the same file
06:18:37 <Axman6> gakusei: that depends on what you want the function to do - do you want it to take in the list to select from? should it take in a StdGen or just a seed? so you need to generate more random values later? if you do you'll also need to return the new StdGen
06:18:43 <__monty__> hyperisco: Maybe only the first time? I hope it caches in a tags file.
06:19:06 <Axman6> hyperisco: I've found haskell-ide-engine also works quite well for a day, but needs restarting about once a day
06:19:21 <hyperisco> __monty__, every time
06:19:44 <gakusei> Axman6: don't worry i sorted it out
06:19:50 <gakusei> Axman6: thanks for your help, really appreciate it
06:20:15 <Axman6> feel free to share the code, we can give you suggestions to improve it
06:21:24 <hyperisco> Axman6, I never got that running
06:21:57 <hyperisco> Bah, Haskero doesn't help with compiler errors
06:22:07 <hyperisco> No highlighting, nothing
06:23:32 <Axman6> that works "fine" in hie, when it hasn't got itself stuck
06:24:01 <Axman6> I use it on a few quite large projects at work, it does o0k
06:24:01 <Axman6> ok*
06:24:11 <hyperisco> Haskero says it supports compiler errors and warnings but it isn't working
06:25:11 <hyperisco> It doesn't tell VS Code that the project can be built or how to build it
06:25:13 <hyperisco> maybe that is why
06:25:38 <aoeu256> is there an easy way of getting meta-information(its arguments/return value of functions, types) in haskell, like reflection in other languages in your program?
06:26:13 <merijn> aoeu256: There are some tools, but they are very heavy-handed and whether they're useful depends on what you want to do
06:26:28 <hyperisco> Restarted the IDE to see if that helps. Now is hanging.
06:26:50 <Cale> aoeu256: Note that in a compiled Haskell program, types don't exist as a concept any longer -- the process of compiling eliminates them
06:27:34 <Cale> aoeu256: However, there are things like Typeable which gives you the effect of runtime type information, via a typeclass
06:27:44 <Cale> :t typeOf
06:27:46 <gakusei> Axman6: is there a way to generate a new seed inside a function definition?
06:27:46 <lambdabot> Typeable a => a -> TypeRep
06:27:53 <hyperisco> Doesn't look like it will get to (4) but I'll wait a few minutes.
06:28:04 <gakusei> Axman6: so that if i call that function recursively the seed is different each time
06:28:20 <gakusei> Axman6: rather than just passing one seed to the function which is the same on each call
06:28:55 <Cale> aoeu256: Of course, like other type classes, it can't have separate instances for polymorphic types, so nothing will be able to tell you e.g. that id :: forall a. a -> a
06:30:14 <hyperisco> It is burning away the CPU but doesn't seem to be getting anywhere
06:30:46 <Cale> aoeu256: You might also be interested in looking into GADTs, which also give you a way to rediscover information about types by way of pattern matching on values.
06:31:45 <hyperisco> Actually intero never shut down after the IDE closed. Not good… will try again.
06:32:31 <aoeu256> cale: okay ill check out typeable and template haskell, and gadts haha
06:32:47 <hyperisco> Nope, dead.
06:33:04 <hyperisco> There is also Haskelly, so I will try that.
06:33:21 <__monty__> gakusei: randomIO already provides a ranodm generator with a random seed.
06:33:30 <hyperisco> I think it is intero hanging though so it probably won't help.
06:33:52 <hyperisco> Yup, still dead.
06:34:04 <hyperisco> Maybe next year Haskell… maybe next year…
06:34:22 <gakusei> __monty__: yeah but i'm passing that seed to a function that uses it, but the seed is the same each recursive call so i get the same values
06:35:10 <__monty__> gakusei: Then pass a RandomGen to the function instead.
06:35:27 <__monty__> Or an infinite list of numbers generated by a randomGen.
06:36:20 <Axman6> gakusei: randomr does exactly that
06:36:23 <Axman6> :t randomR
06:36:25 <lambdabot> (Random a, RandomGen g) => (a, a) -> g -> (a, g)
06:36:43 <Axman6> given a range and a generator, produce a value in that range and a new generator
06:37:57 <__monty__> gakusei: g <- getStdGen; randoms g -- would give you such an infinite list.
06:38:04 <hyperisco> Uh, apparently VS Code hangs now even with the extension uninstalled… sigh…
06:39:31 <sicklorkin> hyperisco: neovim + coc + hie + 64GB mem.. no issues :P
06:39:57 <sicklorkin> never restarted it
06:40:06 <hyperisco> everything was working fine in VS Code until I installed intero + Haskero
06:40:17 <hyperisco> can I stack uninstall stuff… lets see
06:40:23 <sicklorkin> hyperisco: people have been coming here with all sorts of stack woes..
06:40:36 <sicklorkin> hyperisco: you need to click the button to refresh the extensions
06:40:40 <hyperisco> well I don't get what is running that is hanging vscode now
06:40:53 <hyperisco> I've uninstalled every haskell extension
06:41:44 <sicklorkin> have you restarted VS since you uninstalled all-the-things?
06:41:49 <hyperisco> many times
06:42:00 <sicklorkin> did you find that blue button?
06:42:06 <hyperisco> what blue button?
06:42:48 <sicklorkin> lol, im not sure, but someone was here the other day and I was walking him through some issues that appeared here the day before. he said in the bottom corner there was a blue button.
06:43:44 <hyperisco> Well, all VS Code gave me for Haskell was a directory browser, over Notepad++
06:43:47 <sicklorkin> where does VS install to?
06:43:48 <hyperisco> so I guess it is back to Notepad++
06:43:57 <sicklorkin> /path/
06:44:11 <sicklorkin> hyperisco: have you tried ed?
06:44:13 <merijn> hyperisco: Just use vim ;)
06:44:43 <hyperisco> am I to believe the tooling is any better with vim?
06:45:14 <merijn> hyperisco: "It Depends" what kinda tooling you want and how your building stuff
06:45:33 <hyperisco> highlight compiler errors and warnings
06:45:35 <hyperisco> help me with imports
06:45:45 <hyperisco> syntax highlighting… go to definition… rename a definition
06:45:47 <hyperisco> I think that's about it
06:45:55 <merijn> If you use v2-build then at this point in time you are basically screwed, wrt tooling
06:47:52 <sicklorkin> merijn: does ghcid work?
06:48:06 <merijn> Define "work"
06:48:45 <merijn> If you run it in a separate terminal? Sure. But I just want something along the lines of hdevtools. i.e. automatic highlighting of errors/warnings and the ability to query the type of the expression under the cursor
06:49:16 <sicklorkin> neio vim has a terminal build in.. and you can use gf to go to the file
06:49:42 <merijn> sicklorkin: I don't want a builtin terminal, I literally just want it to setup neomake/syntastic flags in the file I have open
06:49:56 <hyperisco> I don't know how but lets say intero is still trying to run
06:50:01 <hyperisco> how can I uninstall stack stuff
06:50:47 <sicklorkin> merijn: humm.. it's really no different from what you'd do other wise.. just `wwgf` and you're at the problematic line
06:51:12 <sicklorkin> imagine a quickfix window 
06:51:16 <hyperisco> well I found intero.exe so I'll just delete that
06:51:22 <hyperisco> because apparently stack cannot uninstall its own stuff
06:51:34 <merijn>  sicklorkin: It is, because it takes up valuable screen estate and the GHC warnings are too big in size to scan like the quickfix window
06:51:46 <merijn> sicklorkin: And it still doesn't let me query the type of the expression under the cursor
06:52:49 <sicklorkin> no ghcid cannot do that
06:54:59 <sicklorkin> if you do go with hie i strongly suggest CoC over Ale tho..https://github.com/neoclide/coc.nvim
06:55:39 <hyperisco> I had to delete a lot of VS Code cache / config data to get this project open again
06:56:10 <hyperisco> will try the routine once more
06:58:35 <hyperisco> mkay, it is open with Haskero, but absolutely nothing is working now, except syntax highlighting
06:59:25 <sicklorkin> hyperisco: are you starting with a fresh project or opening up an existing one?
06:59:30 <hyperisco> it seems to think that everything should be a module now? I don't get it… "couldn't guess that module name"
06:59:33 <hyperisco> opening an existing one
06:59:42 <sicklorkin> cabal or stack?
06:59:48 <hyperisco> stack
06:59:51 <sicklorkin> ahh..
06:59:57 <sicklorkin> so you'll love this..
06:59:58 <hyperisco> it only works with stack
07:00:33 <sicklorkin> add those extensions to `extra-deps:`
07:00:35 <hyperisco> it still hasn't told VS Code how to build the project
07:00:38 <hyperisco> no build tasks available
07:00:49 <hyperisco> which extensions?
07:00:50 <sicklorkin> (this is just a work around)
07:01:15 <sicklorkin> packages I mean.. you wanted haskero? or something like that 
07:01:17 <dmj`> Anyone use threaded lexers w/ happy ? trying to parse a context sensitive grammar. Specifically n-many '<' and '>' in generic templates and expressions. Need communication between lexer and parser. Not clear to me how to go from [Token] in alex lexer to CPS style monad for lexing in happy parser.
07:01:30 <hyperisco> I already have it installed
07:01:53 <sicklorkin> hyperisco: humor me..
07:02:09 <hyperisco> I don't know what I am supposed to be adding to extra-deps
07:03:36 <sicklorkin> are logs working for the channel now?
07:04:07 <sicklorkin> i w
07:04:16 <sicklorkin> ooops ^ ignore
07:04:25 <saml> yes
07:04:51 <sicklorkin> saml: do u have a url? 
07:05:04 <sicklorkin> got it
07:05:12 <saml> yes
07:05:19 <sicklorkin> I mean I found it
07:05:22 <sicklorkin> it was down the other day
07:06:53 <saml> https://freenode.logbot.info/haskell
07:08:26 <sicklorkin> hyperisco: http://tunes.org/~nef/logs/haskell/19.07.24 @ 01:23:11
07:11:26 <hyperisco> I think it just doesn't understand my project at all
07:11:37 <hyperisco> Haskelly goes to the wrong directory to build for example
07:12:16 <hyperisco> I have a custom version of shelly in this project and maybe that is throwing it off
07:12:43 <hyperisco> might not be able to understand multiple packages…
07:14:52 <hyperisco> If I go to files in the shelly project the type info works fine
07:15:01 <hyperisco> if I go to the files in my own package it is all broken
07:18:13 <hyperisco> still doesn't report compilation errors though… geez
07:22:06 <__monty__> merijn: Quickfix has never worked with GHC errors for me. It can only kinda do multiline errors with kludges.
07:22:45 <__monty__> Or would you be fine with looking at ghcid for the errors but using quickfix to navigate to them?
07:22:58 <merijn> __monty__: I use syntastic/neomake for highlighting errors and those update quickfix too
07:23:31 <__monty__> Yeah but the error messages are useless/as good as unreadable.
07:23:54 <__monty__> At least were. I guess I'm asking whether this has been fixed?
07:24:45 <merijn> tbh, I hardly ever need to see the actual error, most problems can be solved by just knowing where I should look when I'm quickly doing stuff
07:25:50 <__monty__> What do you do when that's not enough though?
07:26:07 <hyperisco> I don't understand why it wouldn't register anything whatsoever with VS Code wrt building
07:26:44 <merijn> __monty__: Run "cabal build" in some terminal and stare at it properly
07:34:03 <hyperisco> __monty__, maybe the advantage is it has tooling that works well
07:34:58 <__monty__> hyperisco: : ) Dhall's compiler is pretty good. No ghcid-like or repl or fancy completions yet though.
07:38:14 <solonarv> dhall's compiler cheats though
07:38:22 <solonarv> it isn't turing complete!
07:38:33 <hyperisco> isn't the compiler I have a problem with
07:38:35 <solonarv> of course that is a feature, but it does make static analysis and program transofmrations easier
07:38:39 <hyperisco> it is the quality of life IDE features
07:38:48 <hyperisco> well I could use PureScript to generate a doc that pandoc understands
07:38:50 <solonarv> yeah, Haskell could stand to gain some in that area
07:39:00 <solonarv> fortunately things *are* getting better
07:39:18 <hyperisco> seems so… maybe next year I will be able to install an IDE extension and have it work
07:39:29 <solonarv> even direct compiler support with things like :doc in GHCi and .hie files
07:39:38 <hyperisco> at least type info worked this time, sort of
07:40:13 <merijn> solonarv: The main problem is that we're in a local minimum
07:40:31 <merijn> solonarv: The tooling used to be better (for me at least), but v2-build broke all that
07:40:47 <solonarv> yeah, that is a problem as well
07:40:57 <merijn> Now, v2-build itself is fantastic, but updating tools to work with it is *hard* and lots of people don't have the time/energy to do it
07:41:03 <solonarv> yup!
07:41:25 <merijn> I spend a bunch of weeks trying to fix ghc-mod to work, but it was hard and I didn't get very far, even with the author's help
07:41:52 <hyperisco> everything is a moving target
07:42:05 <hyperisco> both the IDEs you're trying to build extensions for and the language
07:42:09 <hyperisco> and the compiler
07:42:10 <merijn> hyperisco: Well, the targets are becoming less moving, but that takes a while
07:42:33 <merijn> LSP is helping on the IDE side, and GHC is getting these hie features
07:42:49 <merijn> There's work within cabal to support tools better too
07:43:03 <merijn> Or rather, there's a discussion on how to best do it
07:43:12 <merijn> But until all these things come to fruitition it's painful
07:43:24 <solonarv> also being able to just link against GHC is better than having your own parallel implementation that still has to keep up with GHC changes
07:48:52 <hyperisco> oh I didn't try leksah again
07:49:43 <hyperisco> what does it do different though other than spend effort redoing all the gui
07:50:40 <solonarv> I have tried it (only for a few minutes) and it seems to have built-in support for cabal v2, ghcjs, and nix stuff
07:51:02 <solonarv> heh, I probably spent more time installing it than trying it!
07:51:46 <merijn> hmmm, if I have a bracket like function, is there a decent way to wrap (part) of a conduit pipeline around it?
07:52:37 <solonarv> yes if there is a MonadUnliftIO instance for conduit (I don't remember if there is)
07:52:47 <hyperisco> oh, it doesn't run natively on Windows… never mind
07:52:47 <solonarv> or MonadBaseControl I suppose, but there be dragons
07:53:01 <merijn> I don't think there is a MonadUnliftIO instance for conduit
07:53:09 <solonarv> yeah, I wouldn't think so either
07:53:23 <solonarv> you could try using MonadResource instead of a bracket-like
07:53:31 <solonarv> conduit works well with that IIRC
07:54:12 <merijn> hmm, I suppose
07:54:34 <merijn> Although I'm always confused when exactly MonadResource cleans up in a conduit pipeline
07:55:05 <solonarv> I'm not sure either, but since bracket isn't available MonadResource is the next best option
07:55:54 <merijn> Well, conduit has it's own bracket like
07:56:30 <solonarv> oh, I didn't know
07:56:32 <solonarv> use that!
07:56:48 <solonarv> it uses resourcet under the hood anyway
07:58:03 <merijn> Yeah, but that means reworking my pre-existing bracket...
08:00:12 <solonarv> that was unavoidable anyway: ConduitT doesn't even have a MonadBaseControl instance
08:00:43 <solonarv> although you don't have to write a new function, you can just use 'Conduit.bracketP alloc free' directly
08:01:06 <merijn> solonarv: Right, but then I can't use said function anywhere else, so that all needs fixing
08:54:46 <fog> attempting to replace the cabal.project file and distributed .cabal files of https://github.com/fog-hs/rotateDistributed with one .cabal file in https://github.com/fog-hs/rotateRecombined results in an unexpected error.
08:55:08 <fog> can anyone see anything wrong with; https://github.com/fog-hs/rotateRecombined/blob/master/rotateRecombined/rotateRecombined.cabal
08:55:08 <fog> ?
08:56:03 <fog> otateRecombined\dist-newstyle\build\x86_64-windows\ghc-8.6.3\rotatePlugin-0\l\rotate\rotatePlugin-0-inplace-rotate+J2GqyQnwOe9EPaywJQDMxw\build\rotatePlugin-0-inplace-rotate+J2GqyQnwOe9EPaywJQDMxw\autogen\: openBinaryTempFileWithDefaultPermissions: invalid argument (invalid argument
08:56:14 <Hazalo1122> Hi
08:56:21 <Hazalo1122> Hello
08:56:22 <fog> sorry, basically thats the openBinaryTempFileWithDefaultPermissions error it throws
08:56:37 <Hazalo1122> Fog
08:56:47 <fog> yo
08:57:20 <heatsink> Does the temporary directory still exist, and can you find autogen?
08:57:37 <Hazalo1122> My battery still left 30% .. all the sudden phone turn off
08:57:49 <Hazalo1122> Any idea? 
08:59:05 <heatsink> Maybe it's caused by your phone's OS not being programmed in haskell.  Also, batteries tend to lose performance over time, so the software's estimate of available power becomes incorrect
08:59:36 <Hazalo1122> Lol
08:59:47 <heatsink> fog: My guess is that something in Backpack is attempting a file operation it can't do, like using 'autogen' as both a file and a directory, or incorrect handling of filenames with spaces
09:00:02 <fog> i can navigate to the autogen filepath it gives, but that directory is empty
09:00:35 <heatsink> fog: I think the message is saying it's trying to open autogen as a file.  It fails because autogen already exists and is a directory.
09:00:53 <fog> thats a ridiculous error
09:00:55 <heatsink> but I'm not sure about that
09:01:28 <fog> im trying to work by following; https://github.com/ekmett/coda/blob/master/coda.cabal
09:01:33 <ski> Hazalo1122 : perhaps do `/join ##iphone', and ask in there ?
09:02:48 <Hazalo1122> Im joking ;-)
09:03:52 <Hazalo1122> Yawn
09:06:23 <fog> there are no spaces in the filepath...
09:07:36 <fog> the example im working off uses alex, im not sure about what that is, or if maybe thats why that project builds and this one fails to
09:08:04 <heatsink> alex is a lexer generator.  It takes a grammar description and creates a Haskell module from it
09:08:10 <c_wraith> alex is a haskell lexer generator, like lex or flex for C
09:08:48 <heatsink> I'd be surprised if it's causing this problem
09:08:52 <fog> ok
09:09:10 <fog> its probably because the coda project is doing some language specification
09:09:26 <heatsink> One thing you might try is removing the backpack part, and see if it still has a problem
09:09:36 <fog> hmm ok
09:12:07 <fog> yeah that builds fine
09:12:36 <fog> main just prints "hello world" now, and it has no build depends or mixins
09:15:40 <heatsink> Alright.  Backpack isn't a commonly used feature.  You can try asking again later to catch someone who knows backpack
09:15:56 <fog> aha!
09:16:00 <fog> found the error
09:16:14 <heatsink> what was it?
09:16:15 <fog> it was to do with the overall cabal file having the wrong "name"
09:16:47 <fog> it had 2 libraries both with their own name and an exe also with a name (eg library rotate)
09:17:36 <fog> changing the name field in the header of the cabal file to rotate and removing this field from the "library rotate" to have it just be "library" 
09:17:38 <fog> that worked
09:21:07 <fog> i have updated the project at; https://github.com/fog-hs/rotateRecombined/blob/master/README.md
09:21:38 <fog> the updated .cabal file is here; https://github.com/fog-hs/rotateRecombined/blob/master/rotateRecombined/rotateRecombined.cabal
09:21:40 <fog> thanks
09:23:52 <wroathe> dmwit: Got a response from Ross on the Monoid/Semigroup transformers thing. He's not inclined to do it because there are multiple valid instances for Monoid/Semigroup for each transformer.
09:41:24 <merijn> hmm, suppose I have code like "MonadReader Foo m => m ()" and I want to use it in a context where I have "MonadReader Bar m => m ()" where Bar has a Foo field. Is there some easy/convenient way to generalise?
09:44:14 <ski> hm, `MonadReader r m' has an FD `m -> r'
09:44:42 <ski> (so the two `m's can't be the same, unless `Foo' is the same as `Bar')
09:56:34 <merijn> ski: Well, yes, I know that, hence why I want to know if there's a way to convert...with ReaderT directly there's "withReaderT", but that doesn't work here
10:09:49 <ski> would the desired type be `forall r0 r1 a. (r1 -> r0) -> (forall m. MonadReader r0 m => m a) -> (forall m. MonadReader r1 m => m a)', or what ?
10:25:01 <fog> ok the next stage in the backpack project is pretty involved
10:25:02 <fog> https://github.com/fog-hs/rotateExtended
10:25:28 <fog> not quite sure how to describe it, but adding the mixins gives an error...
10:25:49 <fog> https://github.com/fog-hs/rotateExtended/blob/master/rotateExtended/rotatePlugin/rotatePlugin.cabal
10:31:58 <electricityZZZZ> so for the first time recently i ran across a problem with my orm (which is not in haskell)--i was trying to run an insert with too many rows so the query failed and i had to manually chunk it. ...do haskell orms address this problem automatically?
10:36:40 <boj> electricityZZZZ: unlikely, since that sounds like a runtime problem
10:45:49 <fog> what is it an orm?
10:46:50 <fog> we dont have objects... how could we have an "object relational mapping" ?
10:47:09 <boj> just functions over records
10:47:11 <Cale> fog: We can simulate objects reasonably well in Haskell.
10:47:12 <fog> its some kind of graph or lookup table? is it like a Data.Map ?
10:47:31 <fog> boj: that sounds like a lens...
10:47:53 <boj> yeah, but usually an orm-like library interfaces with a SQL database
10:48:08 <boj> see: opaleye, beam, etc
10:48:13 <Cale> Since functions are first class, you can produce records of methods, and the functions which produce those records effectively "encapsulate" their arguments.
10:48:20 <fog> thats a kind of standardised way of taking slices through a square array?
10:48:33 <fog> or doing a lookup?
10:48:35 <fog> :t lookup
10:48:40 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
10:49:16 <Cale> But yeah, in this case, probably "ORM" doesn't refer to such a thing, and rather just mapping between values in Haskell and rows in the database in some fashion.
10:50:09 <fog> i guess i should check what the actual functions these libraries export are like
10:50:21 <fog> but what you were saying Cale sounds interesting
10:50:41 <fog> but i couldnt quite parse yor termaology where you were refereing to methods and encapsulation
10:50:51 <fog> were you interspersing OO language?
10:52:47 <fog> this says its an orm: https://github.com/tathougies/beam
10:52:55 <boj> correct
10:53:19 <fog> i wonder what a relational database is
10:53:31 <boj> have you heard of postgresql, mysql, etc?
10:53:44 <fog> i get that the idea is to make composable queiries
10:54:01 <fog> but i cant see clearly what format these queries appear as
10:54:10 <fog> i never use sql or anything 
10:54:16 <Cale> fog: Yeah, I'm explaining how OO concepts can be implemented in Haskell. The main reason that method implementations are tied to the types of objects (classes) in typed-OOP languages is mostly spurious.
10:54:17 <boj> they end up in SQL syntax
10:54:35 <boj> something like beam just gives a nice haskell-like interface around it
10:54:50 <boj> type safe data types and queries
10:55:05 <fog> Cale: so maybe what you said would be a way for a haskell language user to understand those OO terms you used.
10:55:10 <Cale> fog: It necessitates having subtyping in order to obtain objects of the "same type" (different subtypes of the same type) which have methods implemented differently
10:55:27 <Cale> But if you have first class functions, you no longer really need subtyping.
10:55:32 <Cale> (at least, not for that reason)
10:55:52 <electricityZZZZ> i am not trying to focus quite so much on object oriented versus haskell records or etc
10:56:01 <Cale> Instead, you can just make different values of your object type, which implement the methods differently by simply consisting of different records of functions.
10:56:11 <electricityZZZZ> my point is that i have data in my application language format which is being converted to a sql query
10:56:16 <fog> yeah, i dont know what is subtyping or "method implementaions"... i get that the types of objects are like classes because i know what haskell classes are
10:56:31 <Cale> Ah, I didn't mean Haskell classes at all
10:56:33 <electricityZZZZ> and my question is, can i prevent the sql query from failing by being too large, automatically?
10:56:38 <Cale> I meant OO classes :)
10:56:50 <comerijn> electricityZZZZ: What are you using to create/run the query?
10:56:52 <Cale> Haskell classes are an entirely different beast
10:57:06 <comerijn> electricityZZZZ: And how is it too large? You mean the result set is too big?
10:57:27 <fog> so your saying that because we have pattern matching and classes we dont have anything resembling OO
10:57:41 <Cale> OO classes <-> Haskell record types (vaguely, except that they usually come with implementations of the methods for no particularly great reason, rather than leaving that to the objects)
10:57:52 <Cale> OO objects <-> values of those record types
10:58:08 <fog> ah ok
10:58:24 <Cale> I'm saying that we can do OO programming in Haskell just fine.
10:58:29 <electricityZZZZ> not result set, this is an insert
10:58:41 <fog> objects = values, oo_classes = types
10:58:44 <electricityZZZZ> i am using rust's diesel orm
10:58:47 <Cale> yeah
10:58:57 <boj> electricityZZZZ: it's hard to understand your problem. you are trying to insert too many rows?
10:58:58 <fog> what do they do about actual classes then?
10:59:03 <electricityZZZZ> yep, inserting too many rows
10:59:14 <electricityZZZZ> and my question is, am i a dummy, or am i asking for an exotic or impossible feature
10:59:25 <Cale> fog: Well, they don't really have anything like that. The closest thing is "interfaces", but the analogy is a bit poor.
10:59:31 <comerijn> electricityZZZZ: If you're using rust's orm, then why are you asking here?
10:59:32 <fog> hmm
10:59:40 <fog> so whats the O in ORM in haskell?
10:59:43 <fog> and the RM...
10:59:54 <boj> fog: a record
11:00:14 <electricityZZZZ> because the haskell community is knowledgeable, because i am thinking of moving my application to haskell, and because i think this might be a circumstance where laziness might be relevant
11:00:22 <boj> it is quite boring. you are just mapping database rows to records in haskell
11:00:30 <fog> "just mapping between values in Haskell and rows in the database in some fashion."
11:00:38 <boj> usually with some functional machinery to do inserts, updates, and queries
11:00:39 <Cale> Well, in Haskell if I heard someone say "ORM", I probably wouldn't assume they were doing this encoding of OO via records of functions, and would probably just expect that they meant records that correspond more directly to the records in the database table.
11:01:12 <Cale> The whole discussion about encoding OO was just a bit of a tangent :D
11:01:26 <fog> yeah...
11:01:38 <Cale> Though you *could* do both, I don't know why you'd want to
11:01:46 <boj> electricityZZZZ: as i mentioned earlier, i believe that is a runtime problem. regardless of language, you would have to intelligently chunk your inerts, as it sounds like you already have
11:01:48 <Cale> OOP-style ORMs are ugly :P
11:01:53 <fog> but i guess if thats the terminology usually used to explain ORMs...
11:02:09 <fog> i still dont get whats sql though
11:02:19 <fog> inserts, updates, and queries
11:02:26 <fog> sounds like lens to me
11:02:32 <boj> fog: time to google "sql database"
11:03:06 <fog> yeah but they use lots of words and we have already got the ones we need
11:03:08 <electricityZZZZ> boj: i am not intelligently chunking my inserts because i am discovering these issues after they happen
11:03:13 <fog> sounds like lens to me
11:03:38 <fog> but i guess its a particular standard
11:03:43 <boj> fog: it has absolutely nothing to do with a programming language
11:03:57 <electricityZZZZ> fog: i agree i dont understand the obsession with databases. a smart friend told me that a database is the only way to write to disk reliably and that's why they are used
11:04:11 <comerijn> boj: Eh, excuse me?
11:04:13 <fog> your saying lens is to do with updating parts of composite types which is a language thing
11:04:18 <dmwit> wroathe: Huh. What's the next most obvious choice of instance?
11:04:23 <comerijn> boj: How is SQL not a programming language?
11:04:27 <boj> comerijn: that came out wrong, heh
11:05:03 <boj> i was focused more on the idea that it is a distinct process that runs on a server, uncoupled from your application
11:05:17 <comerijn> boj: That's also far from always true
11:05:18 <boj> or a format at rest on disk, such as sqlite
11:05:18 <fog> iv seen a few way, i like the idea of using generic and data.binary
11:05:38 <comerijn> boj: In fact, I'm willing to argue that the largest number of SQL deployments are not separate processes :p
11:05:45 <fog> but obviously then your stuk in haskell, and sql is supposed to be cross platform
11:05:46 <electricityZZZZ> boj: so my question is, does a good programmer defensively chunk inserts as a common practice, or am i doing something wrong?
11:06:22 <fog> so sql is like a way to make a common lens-like syntax between languages
11:06:26 <boj> comerijn: sure, i was just trying to find keywords to help someone not familiar with it :)
11:06:55 <fog> in which case the natural question is; are sql databases as expressive as haskell types
11:07:32 <fog> if we can use like traverse and biplate and stuff to navigate into a composite type and modify or access it
11:07:32 <boj> electricityZZZZ: it depends i suppose? if you are choking your application/database by trying to push a query string bigger than the database can reasonably handle, then chunking it makes sense
11:07:51 <fog> or extend it i guess... thats all the atomic functionalities right?
11:08:13 <fog> shape changing get and set and access
11:08:15 <_kwstas> electricityZZZZ: In my app I had a similar problem (was not using any ORM though) and I just keep track of the number of inserts and every x insert rows i executed the query and reseted the counter 
11:08:57 <electricityZZZZ> boj: yes chunking makes sense, the question is why the interface between the application language and the sql database doesn't handle it automatically, this seems like an easy and common cause of problems!
11:09:08 <fog> idk what an sql database is like, is it always square like a spreadsheet or a tensor? or can it be rows of different lengths like a list of lists?
11:09:31 <fog> Free []
11:09:57 <boj> electricityZZZZ: i see your point, however, i wouldn't want a library to artificially limit my throughput if i could do it better depending on my domain
11:09:59 * ski . o O ( "Modelling Large Datasets Using Algebraic Datatypes: A Case Study of the CONFMAN Database" by Markus Mottl in 2002-05-15 at <http://www.ofai.at/cgi-bin/get-tr?paper=oefai-tr-2002-27.pdf> )
11:10:36 <fog> sounds like sql = HFree HList
11:10:44 <boj> fog: your spreadsheet intuition is close
11:11:25 <fog> but thats a constraint between similar rank lengths.. like same row length or same column length etc for higher dimensions
11:11:30 <fog> "square"
11:11:51 <fog> then you wouldnt have like, delete from a Free [] that would change the length of just one row
11:12:23 <fog> i guess if its more like json or xml or something it wouldnt have such a constraint
11:12:36 <fog> sounds like typable
11:12:41 <ski> a relation in a relational database is a (finite sub)set of "tuples" (think "records"). since it's a set, it's not ordered (and you can't ask how many times a tuple is in a relation, it's either there, or it isn't)
11:13:19 <fog> oh so there are lookup and filter by type... hmm cool
11:13:38 <fog> actually sounds pretty difficult to do in haskell
11:13:57 <fog> i guess vinyl manages some of that 
11:14:54 <ski> the attributes of the tuples (think "fields of the records") tend to contain "simple" values. (but there may be cases where one's like to deviate from that)
11:15:04 <fog> not really sure about the difference between extensible records implemented via heterogeneous lists etc
11:15:49 <fog> you mean its just a record of atomic types? like, not a record of records...
11:16:14 <ski> more like a set of records (of the same record type)
11:16:17 <fog> so not like a HFree HList, just a plain ol' HList
11:16:26 <fog> wait, but then how do you get dimensionality?
11:16:52 <boj> perhaps this is a good point to break out to -offtopic?
11:17:02 <fog> is your "set" a square or cube or Free [] ?
11:17:18 <fog> off what topic?
11:17:30 <fog> im developing the HFree HList thing
11:17:46 <fog> sounds like its almost an sql. thats cool!!
11:18:29 <fog> wait, im assuming that termanolgy makes sense... sorry
11:18:44 <ski> one main concern is to represent relevant information in only one place, avoiding "update","insertion","deletion" anomalies ((uncontrolled) redundancy,inconsistent data,missing ("homeless") data)
11:21:45 <dminuoso> jonge[m]: Did you understand why it was necessary by the way?
11:22:22 <ski> and so, instead of nesting data ("has" in OO terminology), you tend to want data in one relation to refer to data in another relation, typically by the use of "keys" (which you can sortof-but-not-really think of as references/pointers). to "follow the pointer", you join two relations, on the common attribute (the key). however, this is not uni-directional, you can "go both ways"
11:23:29 <dmwit> (Minor feedback: I know what a join is, but I don't understand what you're driving at with unidirectional vs. both ways.)
11:23:53 <ski> relational databases are based on predicate logic. there are clear similarities to (and distinctions from) logic programming
11:25:13 <fog> navigations in and out, or up and down the tree structure (im assuming they dont support cycles) 
11:26:05 <ski> dmwit : if you have nested records, you can traverse from the containing record to the contained record, but not vice versa. if you have a tuple in a relation, containing a foreign key, you can join with the home relation of that key; but conversely, you could start from a tuple in that home relation, and join with the relation having the foreign key attribute
11:26:08 <fog> so there are algebraic relations for the navigations... 
11:26:46 <fog> do you get a quotient under an equivalence class!?
11:26:48 <ski> relational databases were designed to avoid tree and graph traversals
11:27:09 <ski> (of course you can still encode trees and graphs in them)
11:27:10 <jonge[m]> dminuoso: yes i think so
11:27:14 <fog> by traversal you mean visiting every element?
11:27:34 <ski> i mean visiting some parts
11:27:58 <fog> aha, like a higher vertex number version of a double linked list without cycles 
11:28:01 <ski> (it's not clear to me what "element" would mean, in this context)
11:28:17 <fog> leaf
11:28:29 <ski> (ditto for "leaf")
11:28:54 <fog> well you were saying you could navigate in and out of nested records, so this would be the nested most record
11:29:00 <fog> valus*
11:29:07 <fog> value*
11:29:15 <ski> they typically would not be nested, in a relational design
11:29:35 <fog> right so its more like memory layout with pointer references
11:29:38 <fog> like a turing tape
11:30:53 <fog> im not sure if thats the right picture but its what this has led too.. maybe i misunderstand how you could have *sets of not nested records*
11:31:53 <ski> "pointers/references" suggest a direction. that is, if not absent, at least much weaker, for keys in relational databases
11:32:14 <fog> if anything its constraining values to not consist of nested records thats the difficult part then
11:32:54 <dminuoso> jonge[m]: The implementation of ⌜pretty⌝ is pretty interesting too and tells stories about how servant functions. :)
11:33:08 <fog> why do they have that constraint? ohh thats the whole "relational" idea... so you have to navigate by following the keys
11:33:40 <fog> what a hellish design!
11:33:47 <ski> one reason is to be able to go both "forwards and backwards" in the structure
11:33:55 <jonge[m]> dminuoso: i wish i had the time to study the whole lib!
11:33:57 <fog> i guess its before recusive datatypes were a thing
11:34:36 <fog> ski: yeah, its difficult to make vertical pointers... 
11:34:43 <dminuoso> jonge[m]: Just give it a peek, you might be baffled.
11:34:44 <__monty__> fog: Nesting's not always a good thing. Sometimes you want to query things about properties themselves rather than their "owners."
11:34:55 <dminuoso> jonge[m]: servant is extremely simple actually.
11:35:00 <ski> another, is to be able change the (logical) design of the data, without having to change applications which refer to the data
11:35:14 <dminuoso> jonge[m]: But anyway, ⌜pretty⌝ has the simplest implementation you could think of.
11:35:32 <fog> ski: thats pretty hard to envisage 
11:35:55 <ski> i'm pretty sure recursively defined trees, as well as graphs, were well-known when Codd started all this
11:36:21 <dminuoso> jonge[m]: Essentially ⌜pretty⌝ is just a value-level primitive to apply the Pretty type family to some type. It works for when you want to apply Pretty to a type held by a Proxy. :)
11:36:38 <fog> i thought you needed haskell to typecheck all that recursive types...
11:37:16 <fog> hmmmm
11:37:20 <fog> its just a HList
11:37:38 <ski> fog : you change which base relations store the data, restructuring the data, but redefine the original relations as "synonyms" for corresponding queries (and also updates and insertions, though that's trickier) into the restructured data. applications don't have to be aware of this
11:37:45 <fog> because if you have a type level list of types and one of those types was a HList, then it would be a tree... and its not, its just a HList
11:37:58 <dminuoso> jonge[m]: You had the issue that the api type held by the proxy got changed, but the api type carried in the ExtraInfo did not. One could also write some ⌜prettyExtraInfo :: ExtraInfo api -> ExtraInfo (Pretty api); prettyExtraInfo = id⌝
11:38:10 <dminuoso> jonge[m]: That might actually be more expressive than manually adding Pretty annotations in those spots.
11:38:54 <fog> ski: like you could +1 to all the pointes
11:38:56 <ski> relational database theory is quite beautiful (having some limitations) (though SQL is very ugly, and implementations of SQL tend to be worse)
11:39:09 <fog> pointers* or keys...
11:39:38 <fog> i guess its also not constrained to have int keys...
11:39:49 <jonge[m]> dminuoso: oh, that it works completely on the type level with an `id` function is indeed awesome. i am going to try that out later
11:39:51 <fog> cant quite imagine how you would have a mixture of different types for keys...
11:39:57 * ski would prefer something like Datalog syntax (extended with records, or named attributes)
11:40:04 <dminuoso> jonge[m]: Yup. It'd be just like ⌜pretty⌝ in that sense.
11:40:29 <dminuoso> jonge[m]: Oh wait a second, haha that won't type check.
11:40:44 <dminuoso> Interesting.
11:40:56 <dminuoso> jonge[m]: You'd need ⌜coerce⌝
11:41:00 <fog> oh man apparently there are deductive databases too
11:41:35 <ski> yes
11:41:58 <fog> wonder if this is like the "rules" of a fuzzy rule system or decision network...
11:42:11 <dminuoso> ski: Perhaps (QQ driven?) implementation for relational algebra that generated trees, with database drivers that map that to concrete SQL for a supported platform, would be a nice middle ground?
11:42:23 <ski> ("QQ" ?)
11:42:51 <dminuoso> ski: QuasiQuotation
11:43:06 <fog> i wonder how many people using sql get how mental the database theory that must have led to its development was...
11:43:31 <ski> hm, not quite sure what you have in mind with tree generation
11:43:40 <fog> no wonder they are "stuck in a way of thinking" and so many employers need that paradigmatic experience
11:44:38 <fog> employers are like "go fetch me some data" and haskellers be like "using which algebra!?"
11:46:06 * ski . o O ( "Diagram" by Maria Kovalyova,Roman Cheplyaka in 2015-07-21 at <https://ro-che.info/ccc/29> )
11:48:01 <fog> i demand algebraic varieties enter this research! needs more mumford stacks...
11:49:06 <fog> what are morphisms in the category of query languages?
11:50:09 <fog> (by this point the employer is furiously awaiting their data)
11:50:28 <ski> (there are books like "Categories for Software Engineering" by José Luiz Fiadeiro in 2005-01 (you may also see "An Introduction to Category Theory for Software Engineers" (slides) by Steve Easterbrook in 1999 at <https://www.cs.toronto.edu/~sme/presentations/cat101.pdf>) .. perhaps there ought to be literature about CT for managers !?)
11:50:31 <dminuoso> ski: Mmm I guess beam does what Im talking about already.
11:50:40 <ski> mhm
11:50:44 <sigmaTau> what 
11:50:54 <sigmaTau> Wow i read that wrong wtf
11:51:11 <sigmaTau> I seriously just read "Mmmm Jim Beam ddosed me"
11:51:15 <boj> ski: i would love to see the latter
11:51:34 <ski> fog : there are papers relating DB queries to monads
11:51:48 <fog> thats almost what i meant...
11:52:11 <fog> but yeah, algebras and monoids seem pretty similar to me
11:52:15 <ski> also talking about stuff like pushouts in DB terms, iirc
11:53:17 <fog> but whats the one differential form for integrating over the space of these algebras...
11:53:36 <fog> i think my coffee was too strong... i need to do this backpack stuff sorry
11:53:44 <EvanR> differential form ... integration ...does not compute
11:53:57 <fog> the dx
11:54:08 <fog> nvm!
11:54:39 <nil> measure, perhaps
11:55:35 <fog> i was trying to do something with path integrals and variational bayes and i think it has broken my haskell.. 
11:55:56 <fog> nil: yeah, like hodge theory
11:56:17 <ski> chapter 3 of "Seven Sketches in Compositionality: An Invitation to Applied Category Theory" by Brendan Fong,David I. Spivak in 2018-(03-14 - 10-16) at <https://math.mit.edu/~dspivak/teaching/sp18/>,<https://arxiv.org/abs/1803.05316> is about databases
11:56:18 <fog> "im on top form!"
11:57:18 <fog> Chapter 7: Logic of behavior: sheaves toposes, and internal languages.
11:57:21 <fog> epic
11:57:55 <boj> their lectures are online as well
11:58:48 <fog> ok, i got to repost this incase edward or anyone is online that could maybe help with the error;
11:58:48 <fog> https://github.com/fog-hs/rotateExtended
12:03:34 <ski> hm, "Monad Comprehensions: A Versatile Representation for Queries" by ProfTeggy (Torsten Grust) at <https://www-db.in.tum.de/~grust/files/monad-comprehensions.pdf> is one such paper. there's probably more recent ones
12:03:59 <ski> <fog> cant quite imagine how you would have a mixture of different types for keys...
12:04:05 <ski> @hackage dependent-map
12:04:05 <lambdabot> http://hackage.haskell.org/package/dependent-map
12:04:07 <ski> perhaps ?
12:04:19 <fog> nice
12:04:37 <ski> <fog> wonder if this is like the "rules" of a fuzzy rule system or decision network...
12:04:59 <ski> like forward-chaining stimuli-to-action systems ? (RETE ?)
12:08:05 <fog> huh, a knowledge base...
12:09:00 <fog> something about dempster shafer theory of atoms of discrimination and belief nets too...
12:09:20 * ski . o O ( <https://en.wikipedia.org/wiki/Business_rule> )
12:10:01 <fog> but yeah, it seemed like the whole "decisions" approach was something like it would need formal language methods
12:10:32 <fog> that looks like hebbian learning
12:10:43 <fog> or a logistic regression
12:11:23 <fog> yeah and there was something with genetic algorithms needing "combination rules" as well
12:12:22 <fog> like, i get "approximating functions" with like a KL or wasserstien metric, but as soon as it starts talking about probabalistic rule sets im like "how are they interpreted!?"
12:13:24 <geekosaur> when it comes to big data, sometimes that's all you got
12:15:04 <fog> well then you get ensemble kalman particle filtering and mixtures of experts  
12:16:03 <fog> far far from haskell land
12:17:20 <fog> trying to find low rank representatives for regions in the space of approximators defined by metaheuristic algorithms...
12:17:33 <fog> etc..
12:34:05 <EvanR> far from haskell land, the enthralling drama of the haskeller who is forced into a job programming in an imperative language, coming this fall
12:34:17 <fog> nooooo
12:35:51 <fog> id rather become a circus pirate
12:37:23 <fog> i wonder what is the geodesic distance of the path of rearranging characters in this .cabal file until the mixins are correct...
12:37:24 <fog> https://github.com/fog-hs/rotateExtended/blob/master/rotateExtended/rotatePlugin/rotatePlugin.cabal
12:39:01 <fog> oh wait, that version didnt have any mixins at all!!
12:39:12 <fog> i have updated it to something that is also wrong..
12:39:32 <fog> but at least there is a greater probablity that some permutation of it is correct...
12:40:38 <fog> the original version had rotate.hsig implemented by the backpacks LinearRotate and VectRotate
12:41:32 <fog> then, there is another new signature rotatePlugin.hsig which imports rotate (and so needs mixins of it.?) and implementations of this LinearRotatePlugina and VectRotatePlugin
12:42:42 <fog> this also use Rotate... but specific implementations of it, so almost tempted not to import Rotate at all but directly import LinearRotate and not use mixins for that
12:44:06 <fog> because it might be a problem if it tried to mix up the mixins... like if the backpack LinearRotatePlugin (implementing the signature RotatePlugin) by importing Rotate, could have this implemented by the wrong backpack! namely VectRotate...
12:46:43 <fog> so it seems like the only thing that should actually have any mixins at all is the example itself; RotatePluginUse, which imports both the instantiations of RotatePlugin (LinearRotatePlugin and VectRotatePlugin) , AND it imports RotateUse, which itself imports both the original backpacks VectRotate and LiearRotate...
12:48:03 <fog> i guess the original backpacks are supplied to RotateUse in the original package... so no extra mixins requred there...
12:49:45 <EvanR> is typing all this into notepad.exe different from typing it here when no one is responding
12:50:03 <EvanR> or is this like trees falling in the woods
12:53:02 <fog> well i did type it all into a compiling thing (with error) and paste that
12:53:12 <fog> but i guess that requires clicking on links and stuff
12:53:24 <fog> and that description is about as informative as i can get it
12:54:41 <fog> infact, reading that probably gives you a clearer version of it than my thoughts. like, i dont think it would be reasonable to expect someone to seccond guess the justification for the approach taken without an explanation
12:55:01 <fog> clears up any pottential ambiguity which is essential
12:56:08 <fog> its certainly more directed than just shuffling around the syntax at random
12:56:50 <fog> and yeah, its a complex dependency tree which i think anyone helping would have to be basically managing to follow
12:58:41 <fog> and im not sure if i agree that placing the text in a different location would have any effect...
12:59:04 <fog> hey man, this is as best as i can get it you know?
12:59:24 <fog> make me justify myself again
13:03:41 * EvanR turns on the myst sound track while reading fog
13:04:32 <fog> yeah, amusing 
13:06:57 <fog> actually you are right, its far too easy to spam immediately after someones diligent efforts - you have convinced me. i will add the explanation to the github 
13:10:28 <fog> man it seems even less comprehensible in that format;
13:10:29 <fog> https://github.com/fog-hs/rotateExtended/blob/master/README.md
13:13:02 --- mode: ChanServ set +o glguy
13:13:02 --- mode: glguy set -bbbb asheshambasta_m*!~asheshamb@d8d87d1b0.access.telenet.be$##fix_your_connection *!*2e189a4b@*.com/ip.46.24.154.75 *!*570f50d7@*.com/ip.87.15.80.215 *!*5335a4db@*.com/ip.83.53.164.219
13:15:04 --- mode: glguy set -bbbb *!*@*.109.227.93.164 *!*@*/ip.107.150.30.118 *!*@ip-173-138-135-25.phnxaz.spcsdns.net *!*@gateway/web/freenode/ip.46.21.151.107
13:15:04 --- mode: glguy set -bbbb *!*@gateway/web/freenode/ip.193.148.16.211 *!*@199.249.230.22 *!*@gateway/web/freenode/ip.103.16.27.26 *!*@gateway/web/freenode/ip.62.102.148.166
13:15:04 --- mode: glguy set -bbbb *!*@gateway/web/freenode/ip.89.238.166.235 *!*@gateway/web/freenode/ip.62.102.148.164 *!*@gateway/shell/matrix.org/x-iqrsvoysdhigktle *!?id302178@gateway/web/irccloud.com/*
13:15:04 --- mode: glguy set -b *!*@2600:1700:7d20:ae60::/64
13:15:40 <fog> and have updated the mixins to reflect this line of reasoning... 
13:15:41 <fog> https://github.com/fog-hs/rotateExtended/blob/master/rotateExtended/rotatePlugin/rotatePlugin.cabal
13:15:47 <fog> still gives the same error though
13:16:47 --- mode: glguy set -bbbb *!*050edb2d@*.com/ip.5.14.219.45 *!*@120.188.86.5 *!*bc815ee6@217.29.117.* *!*533254dd@*.com/ip.83.50.84.221
13:16:47 --- mode: glguy set -b *!*@71-92-120-45.dhcp.knwc.wa.charter.com
13:42:58 * hackage hoogle 5.0.17.10 - Haskell API Search  https://hackage.haskell.org/package/hoogle-5.0.17.10 (NeilMitchell)
14:14:37 <jabyrwock> so I got around to using MTL and custom classes and such instead of IO-ing everything. but now a structure that used to store a cached monadic computation of type 'IO ()' has become 'forall m. (MonadRandom m, MonadDB m) => m ()' and whoops, {-# LANGUAGE ImpredicativeTypes #-}
14:14:45 <jabyrwock> is there a better way to do this?
14:15:52 <solonarv> yes: for example, you can just make 'm' a parameter of the datatype you defined
14:16:40 <jabyrwock> I tried that, but then I couldn't figure out how to pass the structure up the stack
14:16:47 <jabyrwock> suddenly it's m doesn't match m0
14:17:03 <solonarv> could you post some code that did/didn't/should/you want to work?
14:17:19 <jabyrwock> yeah gimme a sec, I'll make a gist
14:17:21 <jabyrwock> thanks btw!
14:29:30 <glguy> jabyrwock: To store something with type: (forall m. MonadDB m => m ()) you can use the RankNTypes extension
14:29:56 <glguy> data Example = MkExample { startup :: forall m. MonadDB m => m (), shutdown :: forall m. MonadDB m => m () }
14:30:54 <glguy> You might want to just make a newtype for these kinds of things: newtype DBThing a = MkDBThing (forall m. MonadDB m => m a)
14:31:18 <glguy> that way you could do things like make a list of them: [DBThing Int]
14:31:52 <glguy> and the above would become: data Example = MkExample { startup :: DBThing (), shutdown :: DBThing () }
14:34:39 <jabyrwock> huh. yeah, both of those work. I don't know why I was uing ImpredicativeTypes instead of RankNTypes. I could have sworn the compiler told me to use it
14:34:45 <jabyrwock> well. thanks!
14:38:56 <mniip> hmm
14:39:29 <mniip> % data Representation (f :: k -> l) where Representation :: (forall a b. Coercible a b => Coercible (f a) (f b)) => Representation f
14:39:29 <yahb> mniip: 
14:40:18 <mniip> % apply :: forall f g a b. Representation f -> Coercion f g -> Coercion a b -> Coercion (f a) (g b); apply Representation Coercion Coercion = Coercion
14:40:18 <yahb> mniip: ; <interactive>:235:46: error: Not in scope: type constructor or class `Coercion'; <interactive>:235:62: error: Not in scope: type constructor or class `Coercion'; <interactive>:235:78: error: Not in scope: type constructor or class `Coercion'; <interactive>:235:121: error: Not in scope: data constructor `Coercion'; <interactive>:235:130: error: Not in scope: data constructor `Coercion'
14:40:25 <mniip> this fails
14:40:29 <mniip> yet this succeeds
14:40:52 <mniip> % apply :: forall f g a b. Representation f -> Coercion f g -> Coercion a b -> Coercion (f a) (g b); apply Representation Coercion Coercion = case Coercion :: Coercion (f a) (f b) of Coercion -> Coercion
14:40:53 <yahb> mniip: ; <interactive>:236:46: error: Not in scope: type constructor or class `Coercion'; <interactive>:236:62: error: Not in scope: type constructor or class `Coercion'; <interactive>:236:78: error: Not in scope: type constructor or class `Coercion'; <interactive>:236:121: error: Not in scope: data constructor `Coercion'; <interactive>:236:130: error: Not in scope: data constructor `Coercion'; <interacti
14:41:04 <mniip> dammit
14:41:35 <mniip> % apply :: forall f g a b. Representation f -> Coercion f g -> Coercion a b -> Coercion (f a) (g b); apply Representation Coercion Coercion = case Coercion :: Coercion (f a) (f b) of Coercion -> Coercion
14:41:35 <yahb> mniip: 
14:41:38 <mniip> ok this here succeeds
14:41:48 <mniip> but this one fails
14:41:49 <mniip> % apply :: forall f g a b. Representation f -> Coercion f g -> Coercion a b -> Coercion (f a) (g b); apply Representation Coercion Coercion = Coercion
14:41:49 <yahb> mniip: ; <interactive>:241:141: error:; * Couldn't match representation of type `g a' with that of `g b' arising from a use of `Coercion'; NB: We cannot know what roles the parameters to `g' have; we must assume that the role is nominal; * In the expression: Coercion; In an equation for `apply': apply Representation Coercion Coercion = Coercion; * Relevant bindings include apply :: Repr
14:50:12 <jle`> my blog post project for the weekend ended up being completed too quickly and now i just have to sit on it for the whole weekend to wait for the monday cycle
14:51:35 <EvanR> gotta manage those expectations
15:07:43 <mniip> whoa oh
15:20:54 <Mrbuck> I compromised with python in a rushfor job but after giving couple of interviews I realized it is a bad programming language to start with. When I had started with haskell I reall learned good things like type annotation 
15:21:44 <Mrbuck> programming communities sucks they dont know which language to suggest to newbiws
15:22:33 <ski> @quote please.talk
15:22:33 <lambdabot> Dave_Benjamin says: please talk to your son or daughter about parametric polymorphism
15:42:48 <captjakk> what do you guys think of -XStrictData
15:43:04 <captjakk> I'm considering turning it on by default in a project of mine
15:43:12 <captjakk> rather than putting !'s everywhere
15:47:30 <glguy> captjakk: I prefer to put the !s to reduce confusion
15:48:19 <captjakk> Is that for compatibility with the habits of veterans or is there an intrinsic confusion there?
15:48:48 <glguy> compatibility with anyone who knows what the normal meaning of a data declaration is
15:49:14 <glguy> and who didn't happen to check the top of your file or .cabal file to see if the meaning has changed
15:49:24 <captjakk> well I say it that way because I only started learning Haskell after everyone figured out that strict data fields were the norm
15:51:53 <glguy> You have to be careful using strict fields to not create even more thunks than before; it's good to know they are there
15:53:40 <captjakk> I'm not sure I understand, how would Strict fields create MORE thunks?
15:53:59 <glguy> Without strict fields something like: let x = C y z
15:54:06 <glguy> wouldn't create a new thunk
15:54:10 <maralorn> Without knowing what I am talking about: Won‘t StrictData completely fail when you have an infinite List as Data?
15:54:25 <glguy> but if C has strict fields and you don't immediately force x then you get a new thunk
15:54:50 <captjakk> maralorn: I just checked this at ghci and it appears not
15:54:55 <glguy> maralorn: Turning on that extension doesn't affect pre-existing types like the built-in [] type
15:55:21 <captjakk> also "lazy" (~) tags can be added to invert the default strictness
15:55:52 <captjakk> The extension does not reduce the expressiveness provided by BangPatterns so much as it just inverts the defaults
15:56:11 <captjakk> They are equally powerful, just not necessarily equally convenient
15:56:18 <glguy> Ironically it's for when you're too lazy to write the bangs
15:56:22 <captjakk> yes
15:56:25 <captjakk> which I am :)
15:56:34 <captjakk> or rather, which I'd like to be
15:56:40 <glguy> As long as I don't have to read your code I don't mind :)
15:56:50 <captjakk> do you work in the Bitcoin industry?
15:57:10 <glguy> No, we're not currently doing any bitcoin projects
15:57:17 <captjakk> then it's unlikely! :D
15:57:21 <glguy> perfect
15:57:23 <captjakk> hahaha
16:10:30 <ski> (perhaps one could imagine writing `data! Blah = ...' to get strict fields ?)
16:11:06 <basic> quick question: don't people write type signatures for constructors?
16:14:04 <boj> basic: you technically can using GADTs
16:16:46 <boj> maybe i misunderstood what you are asking though
16:17:18 <basic> data Piece n e s w = Piece n e s w
16:17:28 <basic> how do i make sure n e w s are "Blocks" ?
16:17:52 <boj> by making them concretely Block, otherwise you leave it up to the caller to choose
16:18:09 <basic> yeah i mean how would i write that
16:18:27 <basic> i tried Piece :: (Block -> Block -> Block -> Block -> Piece)
16:18:53 <boj> data Piece = Piece Block Block Block Block
16:19:21 <basic> uhm, block is "BLock l m r = EmptyBlock | Block l m r
16:19:31 <boj> that's fine
16:19:39 <boj> oh i see
16:20:02 <boj> data Piece l m r = (Block l m r) -- etc
16:20:14 <boj> data Piece l m r = Piece (Block l m r) -- etc
16:21:14 <basic> ah.. okay
16:21:35 <basic> thanks
16:21:59 <basic> but piece holds 4 Blocks that would mean a lot of writing right?
16:22:02 <wroathe> Yay, my lexer works... Now to figure out how to keep the location data for my actual parser pass with Megaparsec
16:22:13 <boj> basic: true, in which case maybe you use a type synonym
16:22:21 <basic> how would that look?
16:22:26 <wroathe> It purports to support custom streams of lexemes, so lets put it to the test
16:22:49 <boj> type MyBlock = Block Some Concrete Types, data Piece = Piece MyBlock -- etc
16:23:09 <basic> ah okay
16:23:13 <basic> thanks alot :) and good night
16:27:55 <solonarv> honestly I quite like GADT syntax even for "normal" data types
16:28:10 <boj> it does read nicely
16:28:32 <jackdk> I think it would teach well also, but I haven't tried that
16:28:39 <solonarv> it would look like this: data Piece where Piece :: Block -> Block -> Block -> Block -> Piece
16:29:16 <solonarv> aw man, basic left already - I was going to recommend record syntax, since it looks like they were trying to name the fields
17:23:20 * ski idly wonders whether there was a point to `Block' being parameterized
17:29:38 <Gander01> indexOf :: Eq a => a -> [a] -> IntindexOf x p = n where [(m,n)] = (filter ((==x).fst) (zip p [0..length p]))
17:29:59 <Gander01> How can I get this indexing to work on infinite lists?
17:30:20 <Gander01> It feels like it keeps zipping and won't give output unless list is finite
17:30:53 <Gander01> indexOf :: Eq a => a -> [a] -> Int
17:30:56 <Gander01> indexOf x p = n where [(m,n)] = (filter ((==x).fst) (zip p [0..length p]))
17:31:00 <Gander01> that's easier to look at
17:32:16 <hpc> when you match on [(m,n)], it has to search the whole list to ensure there's exactly one result
17:32:31 <nil> (m,n):_
17:33:39 <MarcelineVQ> additionally length p isn't going to be so hot on an infinite list
17:34:09 <hpc> ah yeah, that too
17:34:18 <hpc> zipping with [0..] will work just as well
17:34:20 <Gander01> true, I can leave that as [0..] but it's better for shorter lists. I don't know how to terminate after it finds results
17:34:24 <MarcelineVQ> take 1 and [0..] are good things to try out
17:34:32 <hpc> > zip [1, 2, 3] [1..]
17:34:37 <lambdabot>  [(1,1),(2,2),(3,3)]
17:35:45 <hpc> Gander01: so, you do roughly filter predicate list
17:35:50 <hpc> that produces a list of results
17:36:01 <hpc> the first item in the list is the first result you find
17:36:04 <hpc> and that's all you care about
17:36:09 <Gander01> yeah
17:36:21 <hpc> so that pattern is ((m,n) : _)
17:36:31 <hpc> you've written [(m,n)]
17:36:38 <hpc> which is ((m,n) : [])
17:37:06 <hpc> that means it has to evaluate the tail of the list, which means looking for a second result
17:37:33 <hpc> if it finds it, that's ((m,n) : (_ : _))
17:37:51 <hpc> that's the (:) constructor instead of [], and it fails the match and indexOf errors out
17:37:58 <solonarv> it isn't any better for short lists, actually - where did you get that idea?
17:38:11 <hpc> otherwise it has to search the entire rest of the list to conclude there's no more matches
17:38:30 <hpc> all you have to do is make the pattern not care about the parts that you yourself don't care about
17:39:07 <solonarv> Haskell is lazy, so the tail of the infinite list won't be evaluated if it isn't needed
17:39:36 <Gander01> Cheers guys, that's fixed it. Your helps is appreciated <3
17:45:00 <Gander01> If it doesn't match it crashes on infinite lists, I guess that's unavoidable as search continues infinitely though
17:46:46 <hpc> yep
17:47:04 <hpc> if you know the list is sorted, you can use dropWhile and (<x)
17:47:09 <hpc> or some other sort of constraint like that
17:47:56 <nil> you could add a limit argument
17:50:52 <EvanR> when you limit your arguments you argue for limits
18:12:26 <dmwit> ?src findIndices
18:12:26 <lambdabot> findIndices p xs = [ i | (x,i) <- zip xs [0..], p x]
18:12:41 <dmwit> But then, they're already gone.
18:43:51 <maralorn> I never noticed how the four cardinal directions give together "news".
18:53:49 <DigitalKiwi> never eat soggy waffles
19:13:29 <osxcatalnia> hello all
19:14:03 <osxcatalnia> I need a little help with my new setup on macos x catalinaI obtain 
19:14:49 <osxcatalnia> I obtain this error : configure: error: C99-compatible compiler needed
19:19:31 <glguy> osxcatalnia: Do you already have the xcode command-line utilities installed?
19:19:49 <osxcatalnia> Yes, I have Xcode and Xcode cli utilities installed
19:19:56 <osxcatalnia> it's needed for homebrew
19:25:01 <osxcatalnia> glguy : have you another idea ?
19:25:39 <glguy> Now you've got to start poking through the configure logs and seeing what test is failing
19:28:48 <osxcatalnia> glguy : with the --verbose of stack, I obtain :  checking for gcc option to accept ISO C99... unsupported[error] configure: error: C99-compatible compiler needed
19:29:26 <glguy> Oh, for debugging this I'd just work with the GHC install directly; no need to involve stack yet
19:30:30 <osxcatalnia> I want to compile an open source software on my laptop (mac), and the building is done via a make build which use stack
19:31:10 <glguy> That's fine, but you have to focus on GHC first, so you can knock stack out until that's solved
19:31:55 <osxcatalnia> ok, I go back to gchup or other way
19:32:43 <glguy> Like you'd download the .tar.xz installer and manually run configure and look at the log files it generates
19:37:42 <osxcatalnia> glguy : I see nothing very special in the log : https://paste.ee/p/ZPZc7
19:38:28 <osxcatalnia> ow yes, clang and not gcc-9 or gcc-7
20:06:44 <maerwald> gcc is a symlink to clang? lol
21:31:36 <off537[m]> In Android, termux uses gcc->clang
21:42:35 <off537[m]> lulz..
21:42:36 <off537[m]> All I wanted is a banana, but to get it I needed to call getBanana on some object, eg an instance of the Gorilla class. That banana object then likely contains a reference to the gorilla it belongs to and that gorilla object will in turn have a reference to the forest it belongs to. So I ask for a banana, but encapsulated behind that is the entire jungle.
21:43:17 <off537[m]> rip oo
21:44:47 <MarcelineVQ> rip gc
21:48:59 <off537[m]> Well, I am learning functional programming and this is day 2.
21:49:51 <int-e> well in Haskell you ask for a banana and you'll get a set of instructions for growing it, together with a reference to the whole jungle :P
21:50:12 <MarcelineVQ> have fun there's plenty of fun stuff to learn
21:50:13 <int-e> (oh I forgot the conclusion: "rip laziness")
21:50:57 <off537[m]> Yeah. Things are different here
21:51:27 <off537[m]> I am using "Learn Haskell" reference book.
21:58:29 <nshepperd> the true name of a banana
21:59:52 <heatsink> ...is "Big Mike"
22:03:37 <bma> Hi, guys. I'm new here. I've decided to learn it because I'm interested in functional programming concepts. I'm involved in Web with JavaScript. 
22:04:08 <bma> How can I start, do official docs exist?
22:05:23 <heatsink> Welcome, bma.  If you're interested in studying Haskell, there's a list of tutorials at https://www.haskell.org/documentation/ (scroll down a bit)
22:05:54 <heatsink> I don't remember which one was good as a starting point.  If you give me a bit I can try to find it
22:06:50 <nfd9001> (And, y'know, different resources are more-helpful for people with different backgrounds. Naturally.)
22:08:36 <bma> What's about book 'Learn You a Haskell for Great Good'? Is it Ok for start?
22:09:11 <nfd9001> Lots of people think it's helpful; you may very well be one of those lots of people :D
22:10:00 <nfd9001> How do you tend to learn new languages/techniques, usually?
22:10:39 <maerwald> off537[m]: well, some programs really only compile with gcc, not clang and thus they hardcode gcc in their build system. Others do it out of ignorance/laziness. So that's where the problem lies.
22:11:11 <maerwald> So lazy distributors will do the symlink approach, instead of fixing stuff
22:16:46 <bma> I have a bit of experience with C, Java, JavaScript. I learnt C with university lectures, Java with Schildt and O'Reilt books and JS with MDN. So it was different approaches. Most of all I liked to fiddle with docs, I think.
22:17:29 <bma> were*
22:17:51 <bma> was* (Sorry for my English :))
22:23:27 * hackage alist 0.1.2.7 - lists with O(1) append  https://hackage.haskell.org/package/alist-0.1.2.7 (AlanHawkins)
22:47:27 * hackage apecs 0.8.1 - Fast Entity-Component-System library for game programming  https://hackage.haskell.org/package/apecs-0.8.1 (jonascarpay)
23:03:55 <ski> off537[m] : ooc, what's that book ?
