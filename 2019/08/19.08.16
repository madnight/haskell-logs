00:00:35 <dmwit> There are infinitely many type-correct implementations of (>=>).
00:01:15 <dminuoso> dmwit: In terms of (>>=) too? 
00:01:19 <dmwit> Yes.
00:01:48 <jusss> dmwit: so I care about can we get at least one fit  function from its type
00:01:53 <dminuoso> dmwit: How?
00:02:27 <dmwit> create :: Monad m => Positive -> (a -> m b) -> (b -> m c) -> (a -> m c); create 1 f g a = f a >>= g; create n f g a = f a >>= \_ -> create (n-1) f g a
00:02:49 <dminuoso> dmwit: We were assuming it to be completely generalized.
00:02:57 <dmwit> That type is completely generalized.
00:04:09 <dminuoso> dmwit: But that's effectively still the same as the canonical definition, isnt it?
00:04:13 <dmwit> No.
00:04:20 <dmwit> create 2 f g a runs f a twice.
00:04:25 <dminuoso> Oh.
00:04:31 <dmwit> There are more definitions, too.
00:04:36 <dminuoso> dmwit: fair enough, I can see what you are getting at
00:04:51 <dminuoso> dmwit: Anyway, uniqueness was not the point actually.
00:05:20 <dminuoso> dmwit: I was just building up to the intuition that you can rule out classes of "you cant do this" and "at the very least you have to do that"
00:05:37 <dminuoso> Anyway. This got sidetracked a lot.
00:05:42 <dmwit> Like I said: the whole discussion is weird.
00:07:05 <dminuoso> dmwit: What do you propose instead?
00:07:13 <dmwit> jusss: In the presence of RankNTypes or typeclasses I believe it is undecidable whether a given type signature is inhabited.
00:07:49 <dminuoso> Because it is my stance that, using basic principles of parametricity, you can guide yourself to the correct implementation by "following the types"
00:07:53 <jusss> dmwit: and?
00:08:32 <dmwit> ...and that answers your question: "Can we get at least one fit function from its type?" "No, there is no algorithm which can reliably do that."
00:08:56 <jusss> dmwit: good, at least I got an answer
00:09:15 <MarcelineVQ> what is 'it' here?
00:09:57 <dminuoso> I understood jusss' question in the context of the discussions we've been having over the past few days. Yesterday they failed to implement (>>=) in terms of (>=>) (being told to follow the types), asking "how can I use the types to find the implementation"
00:10:16 <dmwit> MarcelineVQ: I think a fixed version of the question is "Is there an algorithm which takes a type as input and spits out an implementation of that type (or says it's unimplementable)?".
00:10:21 <jusss> dmwit: or in which conditions it is decidable whether a given type signature is inhabited?
00:10:22 <dminuoso> dmwit: You seem to have understood it as a more generalized question "can you do this in a strict sense at all"
00:12:29 <MarcelineVQ> dmwit: ok, just wanted to make sure that was the topic, since another 'it' could be "can we find one fit function from the type of >=>"
00:12:38 <jusss> dmwit: "Is there an algorithm which takes a type as input and spits out an implementation of that type (or says it's unimplementable)?"  yeah, is there a way to describe the relation between type and function ?
00:12:43 <dminuoso> jusss: Anyway. The point I was getting at, is that (>>=) is universally quantified a lot, which greatly limits the ways you can implement it. So if you get something that typechecks, its likely to be correct or at the very least a good starting point.
00:13:21 <dmwit> There is a relation between terms and types, and we have an algorithm for checking whether a particular pair is in the relation.
00:13:52 <dminuoso> But perhaps I was wrong and you just care to understand type theory better. :)
00:14:46 <jusss> dminuoso: I have known nothing about type theory yet ...
00:16:43 <jusss> dminuoso: the original question is can we get >>= through >=> and return, then I found I can't even implement for >>= ... 'cause when m is e->, I don't know how to implemnet
00:17:07 <jusss> when m is not e->
00:17:22 <dmwit> "in which conditions it is decidable whether a given type signature is inhabited?" For rank-1 types only and no typeclasses, djinn is such a decision procedure.
00:17:22 <dminuoso> jusss: Right! And that's what Im getting at, you cant know what m is because its quantified over.
00:17:29 <dmwit> Bute you were told this earlier and didn't like it, so...?
00:17:51 <dminuoso> jusss: Your implementation must work with *all* choices of m.
00:17:59 <jusss> if m is Maybe, then >>= :: Maybe a -> (a -> Maybe b) -> Mabye b, so how to implement a function for this type? the answer is no
00:18:22 <dmwit> jusss: But you are not being asked to implement >>=. You are being asked to implement >=> under the assumption that *somebody else* has implemented >>=.
00:18:46 <dmwit> Wait. The answer to that is not no. But the answer to that is also not relevant to dminuoso's exercise.
00:19:13 <jusss> aha
00:19:25 <MarcelineVQ> just curiousity, it's not important, but who asked you to use >=> and return to write >>= or where did you see that as an exercise?
00:19:49 <dminuoso> MarcelineVQ: I did, possibly under the assumption they were ready for it.
00:19:51 <dminuoso> Perhaps I was wrong.
00:20:00 <jusss> dmwit: my question was can we implement >>= by >=> and return ,  of course >>= is not implemented 
00:21:08 <jusss> dmwit: so how to implement for >>= :: Maybe a -> (a -> Maybe b) -> Mabye b
00:21:28 <jusss> you said "The answer to that is not no"
00:22:01 <dmwit> 1. The type Maybe a -> (a -> Maybe b) -> Maybe b is inhabited. 2. That isn't relevant for the exercise.
00:22:08 <dminuoso> jusss: Here's the thing: it doesnt matter 
00:22:22 <dminuoso> jusss: The implementation is the same for m ~ Maybe, as it is for m ~ IO. It's not about what m could be.
00:22:46 <dminuoso> jusss: That's what the quantification over m means, you must provide a single implementation that works for all possible choices of m
00:23:01 <jusss> dminuoso: wait a sec, when m is e->, we asssume x is e, so we f :: e->b   f x :: b can get b
00:23:23 <jusss> dminuoso: but when it's Maybe, how to get that a which is in Maybe a
00:23:45 <dmwit> jusss: Instead of using e-> and Maybe-specific operations, you should use >=>.
00:24:22 <jusss> :t >=>
00:24:25 <lambdabot> error: parse error on input ‘>=>’
00:24:26 <dmwit> :t (>=>)
00:24:29 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
00:24:46 <jusss> wait a moment, I will try it
00:25:03 <jusss> but I can only assume m is e->
00:25:15 <dmwit> (The "e-> specific operation" you used in your previous implementation was you applied the function to an argument.)
00:25:23 <dminuoso> jusss: Don't assume it's anything!
00:25:23 <dmwit> No. You may not assume that m is e->.
00:25:43 <jusss> dminuoso: dmwit then I don't know how to get b in m b
00:25:48 <dminuoso> You cant know what m is going to be picked, period. All you know is that it must satisfy ⌜Monad m⌝, nothing more.
00:25:56 <dminuoso> jusss: Good!
00:26:00 <dminuoso> jusss: That's the first step.
00:26:04 <dminuoso> You cant in genreal.
00:26:29 <jusss> then I can't do implement  for it
00:26:37 <jusss> or can I?
00:27:02 <dminuoso> 09:24:17       dmwit | jusss: Instead of using e-> and Maybe-specific operations, you should use >=>.
00:27:33 <jusss> dminuoso: I don't understand
00:27:41 <jusss> use >=> as m ?
00:27:41 <dmwit> jusss: To avoid type variable name clashes, let's write the type signatures `(>>=) :: Monad m => m a -> (a -> m b) -> m b` and `(>=>) :: Monad n => (c -> n d) -> (d -> n e) -> (c -> n e)` instead. Okay?
00:27:54 <jusss> ok]
00:29:05 <dmwit> Okay. Then one way to get your hands on an `m b` would be to pick `n ~ m` and `e ~ b`, then try to figure out what this means you would have to supply as the first three arguments to `(>=>)`.
00:30:20 <dmwit> (Do you know what I mean when I write the syntax `n ~ m`? If not, I can say it another less precise but more approachable way.)
00:30:51 <jusss> n equal m?
00:31:38 <dmwit> yes
00:31:39 <jusss> no
00:31:47 <dmwit> uh oh =)
00:33:28 <jusss> I think maybe I did this befor, but I forget the rules...
00:34:33 <jusss> I maybe eavl fmap . fmap's type
00:34:58 <jusss> :t (fmap . fmap)
00:35:00 <lambdabot> (Functor f1, Functor f2) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
00:35:48 <dminuoso> jusss: It has occured to me, that perhaps I overestimated your progress. We could simplify the task to a similar but simpler version of it.
00:37:37 <jusss> dminuoso: ok
00:38:51 <dminuoso> jusss: You could try to implement ⌜fmap⌝ in terms of ⌜<*>⌝ and ⌜pure⌝, perhaps.
00:40:21 <jusss> :t (<*>)
00:40:21 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
00:40:26 <jusss> :t pure
00:40:30 <lambdabot> Applicative f => a -> f a
00:41:11 <dminuoso> That is, implement a function that has the same type signature of fmap - it should also behave the same way as the original fmap, but we will cover that later.
00:41:30 <dminuoso> Using nothing but ⌜<*>⌝ and ⌜pure⌝ 
00:41:45 <jusss> :t fmap
00:41:46 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:41:46 <dminuoso> Note there will be a slight difference because it will have a different constraint Applicative instead of Functor, we shall gloss over that.
00:42:29 <dminuoso> So you must implement: ⌜myApplFmap :: Applicative f => (a -> b) -> f a -> f b⌝ using only ⌜<*>⌝ and ⌜pure⌝ as external tools.
00:43:26 <jusss> I need a little time
00:50:27 <jusss> f :: a->b
00:51:41 <jusss> a :: a->b
00:52:17 <jusss> pure :: a -> b
00:53:31 <jusss> dminuoso: sorry, I don't know the way
00:55:31 <Axman6> start with what you do know: myApplFmap :: Applicative f => (a -> b) -> f a -> f b. so we know it's going to look like: myApplFmap funcAtoB fOfA = ...
00:55:46 <Axman6> fOfA :: f a
00:56:06 <Axman6> funcuAtoB :: (a -> b)
00:56:31 <Axman6> pure :: x -> f x
00:56:52 <jusss> Axman6: but that a or b , how I can get them from f a or f b
00:56:53 <Axman6> (<*>) :: f (i -> j) -> f i -> f j
00:57:39 <Axman6> what happens if you pass funcAtoB to pure? what is the type of the result?
00:58:41 <jusss> pass funcuAtoB to pure will get f (a -> b)
00:58:51 <Axman6> yes!
00:58:58 <Axman6> does that look like something else we need?
00:59:11 <jusss> but I want get a or b from f a or f b
00:59:32 <Axman6> no, you want to get f b from f (a -> b) and f a
00:59:41 <jusss> no?
01:00:14 <Axman6> our goal is to get f b isn';t it?
01:00:46 <Axman6> myApplFmap :: Applicative f => (a -> b) -> f a -> f b
01:01:31 <jusss> ok
01:03:20 <jusss> f fOfA funcuAtoB :: f b = ?
01:04:10 <jusss> pure funcuAtoB :: f (a->b)
01:07:03 <jusss> when a is x, fOfA :: f x, pure x = f x = fOfA
01:07:08 <__Myst__> Is the `liftM` family of functions useful for anything? It seems to me like their job is already done by the Functor and Applicative side of things
01:09:26 <Rembane> __Myst__: They were more useful before Applicative was found. Now they are imo mostly a historical artifact. 
01:09:49 <__Myst__> Rembane: Ah. In which temple was Applicative found?
01:11:02 <MarcelineVQ> the mottled temple of mcbride and paterson
01:11:43 <Rembane> __Myst__: What MarcelineVQ said. There's more about it here: http://www.staff.city.ac.uk/~ross/papers/Applicative.pdf
01:11:53 <Axman6> We knew about Monad before we knew that Applicative fit between it and Functor
01:12:15 <merijn> __Myst__: In the past Applicative was not a superclass of Monad, therefore you weren't always allowed to use Applicative functions with any random Monad
01:13:01 <merijn> __Myst__: A few years ago, this gigantic historical mistakes was rectified, but deleting all the liftM functions now would break old code using them for no real reason
01:13:10 <tdammers> or, a more practical problem, if you wanted to use Applicative methods in a function that you parametrized over some Monad m, you would have to add an Applicative constraint as well
01:13:39 <merijn> tdammers: That was what I meant, but was too lazy to write ;)
01:13:42 <tdammers> so you'd have a lot of functions with signatures like (Functor m, Applicative m, Monad m) => ... -> m a
01:13:54 <merijn> tdammers: Nuhuh :p
01:13:58 <mniip> applicative was always a subclass of functor
01:14:01 <tdammers> whereas today you can just write Monad m => ... -> m a
01:14:04 <merijn> tdammers: Functor was always a superclass of Applicative ;)
01:14:09 <tdammers> ah yes, right
01:14:38 * tdammers 's memory had a habit of exaggerating things for dramatic effect
01:14:58 <merijn> __Myst__: So the answer to "are they useful for anything?" is "No, but we keep them around to avoid gratuitously breaking existing codebases"
01:17:00 <gentauro> anybody will be at ICFP upcoming week?
01:17:19 <Axman6> One year I'll go to ICFP :(
01:17:33 <gentauro> Axman6: I had to go this year cos Berlin
01:17:40 <gentauro> I mean, it's so close to CPH :D
01:18:14 <lihram> What are tickets like from CPH to Berlin?
01:18:56 <gentauro> lihram: Athas and me are going for the night train
01:19:13 <gentauro> so it's a bit more expensive that flying (you can get it as low as less than a 100 EUR)
01:19:24 <tdammers> depends on the flight though
01:19:25 <lihram> Oh, through Jylland?
01:19:28 <lihram> makes sense
01:19:32 <gentauro> yeah
01:19:41 <merijn> I was to busy to talk my boss into paying for me to go >.> But I hear carter is visiting NL after ICFP
01:19:53 <gentauro> I'm a bit "meh" cos I wanted to go over the "boat" to buy british sweets (<3 them)
01:19:53 <__Myst__> ty 
01:20:11 <tdammers> and at least to me, time on a train isn't lost the way time driving or flying is
01:20:23 <gentauro> tdammers: that's a good point
01:20:44 <gentauro> tdammers: we just thought that we have to sleep, so why not use that time on a train :)
01:21:08 <tdammers> yeah, exactly
01:21:24 <tdammers> I'd want that to be a proper sleeper train though, trying to sleep in regular train seats is not fun
01:21:41 <tdammers> did that for last year's zurihac, but ended up basically not sleeping at all that night
01:21:46 <gentauro> tdammers: yeah, that's what we are looking forward to tonight ...
01:22:03 <Rembane> gentauro: Bring a really boring, recorded lecture. 
01:22:15 <tdammers> this year I took a regular daytime train; the ride takes 8 hours, but those were 8 very productive hours, so that's fine by me
01:22:36 <gentauro> tdammers: now with EU and romaing it's actually doable
01:22:41 <gentauro> Rembane: why? xD
01:23:03 <tdammers> gentauro: yeah, that's exactly what I did
01:23:39 <tdammers> except of course that Switzerland isn't EU, so I had to splurge a little
01:23:46 <Rembane> gentauro: I sleep my best sitting at lectures, so I just assume that everyone else does too. :D
01:24:04 <tdammers> for munihac I will be flying, but it was a close call
01:24:52 <gentauro> tdammers: you live in NL right?
01:24:55 <tdammers> yeah
01:25:40 <lihram> Anyone know why stack complains about hidden packages when they've been added via stack.yaml's extra-deps?
01:25:40 <gentauro> Rembane: xD (then I will bring some snooker from Eurosport)
01:26:01 <gentauro> lihram: it's normally dependencies that you haven't addded
01:26:17 <tdammers> what I hate the most about flying is that you spend so much time not flying, but also not doing any other useful things
01:26:23 <Rembane> gentauro: Sweet! Good luck! :)
01:27:45 <lihram> gentauro: Right, so if I've included e.g. unordered-containers in my extra-deps, I should be able to import Data.HashMaps.Lazy, no?
01:27:45 <merijn> tdammers: Word.
01:27:54 <merijn> ICE to germany is pretty good, though
01:28:14 <tdammers> so for a 1-hour flight, you might actually be occupied for 5 hours straight, and there's hardly any of that time that can be used productively
01:28:19 <lihram> It says I should include the deps in my cabal file, but I thought the point of stack.yaml was so that you wouldn't have to manage dependencies via cabal
01:28:40 <Rembane> lihram: You still use the cabal file for adding dependencies. The stack.yaml file is very seldom touched. 
01:28:42 <merijn> lihram: No, stack.yaml means not having to manage *versions* of dependencies
01:29:02 <gentauro> lihram: have you tried to add it as a package dependency? I normally do that ...
01:29:17 <merijn> lihram: My (the?) Stack/Cabal disambiguation guide: https://gist.github.com/merijn/8152d561fb8b011f9313c48d876ceb07
01:29:23 <lihram> in the .cabal file, then?
01:29:24 <tdammers> merijn: yeah, I like ICE. they have power outlets and somewhat working internet, and unlike regional trains, DB prioritizes the ICE business, so they tend to be somewhat reliable
01:29:56 <merijn> lihram: Stack is not independent of .cabal files (unless you use package.yaml, which 1) you shouldn't and 2) I guess it still depends on .cabal file, but an autogenerated one)
01:30:05 <gentauro> `power outlets` <- for the win !!!
01:30:08 <MarcelineVQ> in fact the stack docs relate the distinction https://docs.haskellstack.org/en/stable/stack_yaml_vs_cabal_package_file/
01:31:33 <lihram> Ahhh... right. Okay, fair enough
01:34:17 <tdammers> stack does incentivize the use of pathological .cabal files though (ones without version bounds)
01:34:46 <lihram> IT WORKS
01:34:48 <lihram> thanks guys
01:35:59 <merijn> tdammers: Yes, and that annoys me greatly >.<
01:36:33 <merijn> tdammers: But I try and pick my battles, if I can just at least get people to stop using hpack my life will already be easier :)
01:38:53 <maerwald> merijn: hpack is fine if people commit their .cabal files
01:39:31 <merijn> maerwald: Yeah, but they don't and once you do that, hpack just becomes "cabal files with extra steps"
01:39:52 <lortabac> to be fair, stack provides a command to generate the bounds before uploading a package to Hackage
01:40:13 <lortabac> the "pathological" .cabal files are not meant to be published
01:41:02 <merijn> lortabac: "aren't meant to be" and "what people actually do" are, unfortunately, mostly unrelated :)
01:41:19 <lortabac> merijn: fair point :)
01:42:41 <MarcelineVQ> merijn: are you telling me that author: Author name here maintainer: example@example.com aren't real people!?
01:42:52 <merijn> MarcelineVQ: :p
01:48:19 <Rembane> MarcelineVQ: I must change my name to "Author name here" and start claiming packages. :D
01:56:27 * hackage fast-builder 0.1.1.0 - Fast ByteString Builder  https://hackage.haskell.org/package/fast-builder-0.1.1.0 (AkioTakano)
02:06:01 <jgt> Rembane: reminds me of this: https://www.wired.com/story/null-license-plate-landed-one-hacker-ticket-hell/
02:08:16 <Rembane> jgt: Ouch! :D
02:41:50 <tdammers> with hpack, committing cabal files to source control would be morally wrong - the whole point of hpack is to turn the .cabal file into an intermediate build artifact, and those don't go into source control
02:42:19 <merijn> tdammers: Not committing .cabal files is also morally wrong, ergo hpack is morally wrong ;)
02:42:40 <jgt> tdammers: I like merijn's line of reasoning on hpack vs cabal
02:43:14 <jgt> hpack has fewer features, and less of the market
02:43:17 <tdammers> jgt: a guy I worked with had 8 given names, because his father knew the administrative software used for official purposes had 7 fields for given names, but the law doesn't put any limits on the number of given names
02:43:43 <tdammers> merijn: commit whatever you want, as long as the hackage entry has a proper .cabal file
02:44:04 <tdammers> but frankly, one way or another I agree on the "don't use hpack" sentiment
02:44:29 <merijn> tdammers: A number of times I've wanted to patch/fix something in a package only to find out the repo didn't have a cabal file and I am, frankly, too lazy to install stack or hpack
02:44:30 <tdammers> IME it doesn't add anything of actual value, just needlessly complicates things and fractures the audience (or the ecosystem)
02:44:41 <jgt> tdammers: I'm not sure what the motivation is there. Is it to protect his son from law enforcement? Or was it just to be a troll?
02:44:47 <tdammers> jgt: the latter
02:45:02 <jgt> ah. I think we need more of those in the world.
02:45:07 <tdammers> the son was an accident anyway, so maybe the idea was even to punish him for existing
02:45:13 <jgt> …ouch!
02:45:25 <tdammers> for that reason, his first name, pronounced like "michael", is actually spelled "maycel"
02:45:33 <tdammers> you know, just to make his life a little bit less convenient
02:45:46 <jgt> I sympathise somewhat… My name is Jezen
02:45:53 <jgt> everyone else in my family has a normal name
02:45:59 <tdammers> basically everyone would first pronounce it "my-cell", and then he'd have to correct them
02:46:15 <merijn> tdammers: Similarly, someone has asked me to add my package to stackage, but they want you to test it builds with stack before submitting a PR, so I haven't bothered yet, because that sounds like work >.>
02:46:21 <tdammers> "Jezen", pronounced like "jazzin'"? I'm guessing probably not?
02:46:44 <merijn> jgt: Normal names don't save you :p
02:46:50 <tdammers> merijn: yeah, my yeshql package is still held back from stackage due to depending on optparse-applicative < 0.15
02:47:06 <jgt> tdammers: I guess? Except e sounds, rather than a or i.
02:47:18 <tdammers> fwiw, the correct pronunciation of my last name, "Dammers", sounds like "dumbass"
02:47:18 <merijn> jgt: I have a perfectly name, but no one outside of the country can pronounce it or even spell it right >.>
02:47:37 <tdammers> "merĳn"
02:47:45 <jgt> merijn: I'm imagining a cross between "merry" and "marine"
02:47:53 <tdammers> technically, hardly anyone inside the country spells it correctly either
02:47:57 <merijn> jgt: And you'd be very wrong ;)
02:48:06 <jgt> merijn: and I think you probably come from the land of 'Stroop Wafels'
02:48:12 <Taneb> I have an uncommon (in this country) surname that's way too easy to misread and assume I'm a supervillain
02:48:20 <jgt> met roomboter bereid
02:48:27 <merijn> tdammers: Yeah, all these damn sloppy programmers and poor support for unicode results in stupid things like people thinking my name is 6 letters long >.>
02:49:02 <jgt> oh right! I didn't know that was only one character
02:49:11 <merijn> It's been 5 all my life and I'll be damned if I'm going to revise my opinion to appease shitty software and a bunch of foreigners!
02:49:15 <tdammers> nah, it's those pesky non-English languages insisting on using nonexistent letters and putting dots and dashes everywhere
02:49:50 <tdammers> but seriously, even Dutch culture doesn't agree on whether "ĳ" is one letter or two. it's supposed to be one, but routinely gets treated as two even in official contexts
02:50:44 <merijn> tdammers: I did get Paradox Interactive to patch Crusader Kings so that all Dutch names starting with Ĳ are properly capitalised ;)
02:50:54 <tdammers> hmm, now I'm wondering where the ĳ grapheme originated - is it an amalgamation of i and j, or is it a dotted y?
02:51:15 <tdammers> ah yes, initial Ĳ... even official government documents and websites get this wrong
02:51:16 <merijn> tdammers: That's mostly due to people adopting to the cultural hegemony of US software
02:51:29 <tdammers> yeah, I guess
02:51:37 <merijn> At least text gets it right
02:51:55 <merijn> Char too, I suppose
02:52:02 <merijn> > text $ toUpper 'ĳ'
02:52:04 <lambdabot>  error:
02:52:04 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Char]’
02:52:04 <lambdabot>        Expected type: String
02:52:09 <merijn> > text . pure $ toUpper 'ĳ'
02:52:13 <lambdabot>  Ĳ
02:52:17 <tdammers> at least German ß can't easily fall prey to that because 1) it never occurs in word-initial position, so the capitalization question never occurs, and 2) one of the two letters it was originally composed of (tall "s") no longer exists in the German alphabet
02:53:01 <tdammers> OTOH, I heard learners of German as a second language are routinely taught to just use B for ß, which is, frankly, plain wrong and looks weird to German eyes
02:53:11 <merijn> I tried setting my IRC name right, but freenode only allows ascii nicknames :\
02:53:19 <tdammers> "meryn" then
02:53:37 <tdammers> if it's good enough for Afrikaans, then sure it must be good enough for English
02:53:46 <merijn> If we're compromosing then at least merÿn :p
02:53:55 <tdammers> that ain't ascii though
02:54:01 <jgt> "merijn (THE IJ IS ACTUALLY ONE CHARACTER YOU FOOLS)"
02:54:13 <jgt> although that might not fit in my nick sidebar
02:54:26 <tdammers> I think freenode also has a limit on nick length
02:54:28 <merijn> tdammers: I don't care, I will insist on crashing everyone's shitty software until they fix it >.<
02:54:47 <tdammers> I love how that article quotes a guy whose legit last name is Null
02:55:05 <merijn> tdammers: I considered adopting merĳn as my email address, but it'd make emailing me a bit tricky, I suppose xD
02:56:14 <tdammers> register "ĳn" as a TLD, then you can have me@r.ĳn
02:56:33 <tdammers> I'm sure this will lead to absolutely no problems whatsoever
02:56:53 <tdammers> or what about those poor sods who have nothing but a first name
02:57:09 <tdammers> IIRC there are a few thousand people in Brazil alone, whose full name is just "João"
02:58:08 <tdammers> or how about those people in backcountry China, whose names contain Chinese characters that nobody else (especially not the Unicode consortium) even knew existed anymore, so you can't even enter them anywhere, let alone get them past validation
02:58:08 <jgt> tdammers: that name sounds more like onomatopoeia than a name
02:58:25 <tdammers> jgt: it's the portuguese version of "John", and it's about as popular
02:58:36 <jgt> tdammers: like, if you're out surfing and you see a whale breach the surface, and you exclaim 'JWOW!!!!"
02:58:41 <jgt> tdammers: I know :P
02:58:56 <tdammers> but yeah, it's kind of a strange combination of sounds
02:59:06 <tdammers> especially the nasalized vowel between two non-nasalized ones
03:07:51 <sicklorkin> is there a lens setting that works like fromMaybe i.e. data Foo { fooInt :: Int }; let x = Foo 1 ; x & fooInt ??? (Nothing) == 1; fooInt ??? (Just 2) == 2
03:07:56 <sicklorkin> s/setting/setter
03:13:34 <sicklorkin> `over l (flip fromMaybe m'fooInt)` is what i'm aiming for
03:14:12 <sicklorkin> `over fooInt (flip fromMaybe m'fooInt)`
03:33:50 <jusss> Axman6: dminuoso I got it, <*> (pure funcuAtoB) fOfA = fmap fOfA funcuAtoB
03:54:14 <jusss> j <$> i = (pure j) <*> i
03:58:30 <MarcelineVQ> yes
03:59:10 <jusss> MarcelineVQ: :)
04:00:55 <jusss> :t (>=>)
04:00:57 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
04:01:07 <jusss> :t (>>=)
04:01:10 <lambdabot> Monad m => m a -> (a -> m b) -> m b
04:01:16 <jusss> :t return
04:01:18 <lambdabot> Monad m => a -> m a
04:05:38 <jusss> :t (<=<)
04:05:40 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
04:06:48 <rsoeldner> Currently I do the db migration while starting my main app which I deploy with nixops. Is adding `data-files` to cabal the way to go or is there an alternative ?
04:07:22 <merijn> rsoeldner: What would you add to "data-files"?
04:08:33 <rsoeldner> merijn, sql files so that the `postgresql-simple-migration` can pick them
04:08:41 <jusss> MarcelineVQ: but >=> and >>= with return, there's no equal part like <$> and <*> have f b, so how to make this equal ?
04:08:43 <merijn> rsoeldner: Are these files static?
04:09:51 <rsoeldner> merijn, basically it is a directory containing several sql files, but the content is static for a build
04:10:31 <merijn> rsoeldner: data-files is fine as long as they're read only
04:13:01 <MarcelineVQ> jusss: if you're trying to make >>= from >=> you don't have to use return, in fact I don't see how you could
04:14:33 <merijn> MarcelineVQ: That's what I said 1 or 2 days ago already :)
04:14:35 <rsoeldner> merijn, thank you :)
04:14:44 <MarcelineVQ> merijn: yes, though you also had a typo at that time :X
04:14:51 <MarcelineVQ> and said 'can'
04:16:01 <merijn> Typing is hard!
04:18:33 <Ariakenom> merijn: heathen! dont spread your untyped ways here
04:26:48 <maralorn> How often/how regularly/when does hackage "get merged" into nixpkgs?
04:35:55 <int-e> :t \s -> getDual (foldMap (Dual . Endo . (:)) s) `appEndo` [] -- does this have a name?
04:35:57 <lambdabot> Foldable t => t a -> [a]
04:36:44 <merijn> int-e: reverse? *ducks*
04:36:58 <dmitri> Hi folks, anyone knows what is happening here: https://github.com/litxio/ptghci/issues/14
04:37:02 <int-e> merijn: well I'm using it for Data.Sequence.Seq...
04:37:55 <merijn> dmitri: Two different modules are exporting the & operator, so you have two different versions of & in scope and need to tell the compiler which to use
04:39:05 <dmitri> merijn: thanks, this is my first time, so I have to ask the embarrassing question: how can i do it?
04:39:43 <merijn> dmitri: As the error suggest you can prefix the operator with the name of the module, alternatively you can change one of the imports to "import Foo hiding ((&))" to hide the operator from the import
04:39:45 <dmitri> how to tell the compiler which to use?
04:40:24 <merijn> so "x & f" -> "x MicroLens.& f" (although this is ugly, so I'd probably use hiding)
04:40:47 <int-e> merijn: I guess I should use Data.Foldable.foldl, noting its default implementation is  foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z
04:41:03 <dmitri> merijn: you mean in the source files?
04:41:24 <merijn> dmitri: In "src/Language/Haskell/PtGhci/Prelude.hs"
04:41:28 <dmitri> or the cabal command line?
04:41:33 <merijn> In the file, yes
04:42:05 <dmitri> change this line? `import Lens.Micro as MicroLens`
04:42:41 <merijn> Yeah, although I don't remember of "hiding ((&))" goes before or after as
04:42:57 * hackage Monadoro 0.2.1.2 - A minimalistic CLI Pomodoro timer.  https://hackage.haskell.org/package/Monadoro-0.2.1.2 (patryk_kocielnik)
04:44:57 * hackage Monadoro 0.2.1.3 - A minimalistic CLI Pomodoro timer.  https://hackage.haskell.org/package/Monadoro-0.2.1.3 (patryk_kocielnik)
04:46:58 <dmitri> merijn: new error now, please see https://github.com/litxio/ptghci/issues/14#issuecomment-521981915
04:48:27 * hackage Monadoro 0.2.1.4 - A minimalistic CLI Pomodoro timer.  https://hackage.haskell.org/package/Monadoro-0.2.1.4 (patryk_kocielnik)
04:53:57 * hackage Monadoro 0.2.1.5 - A minimalistic CLI Pomodoro timer.  https://hackage.haskell.org/package/Monadoro-0.2.1.5 (patryk_kocielnik)
05:13:03 <lihram> Hey, trying to return a curried function: findfun l = lookup (fromList l)
05:13:22 <lihram> where findFun returns a function that takes the key for the dictionary
05:13:53 <lihram> Sorry, I mean Data.HashMap, not dictionary
05:14:12 <lihram> lookup and fromList are both from Data.HashMap.Strict module
05:14:23 <dminuoso> lihram: Strictly speaking all functions in Haskell are unary, so no further action is needed? :)
05:15:14 <dminuoso> lihram: If you have some function that appears to take multiple arguments, and you apply that ⌜f 100 "foobar"⌝ then that is not 'f applied to 100 and "foobar"', but rather 'f applied to 100, and then applying the resulting function to "foobar"'
05:16:50 <dminuoso> So "returning a curried function" likely just means "returning a function" :)
05:16:50 <lihram> dminuoso: Makes sense, but I think the problem here is that the lookup function expects they key before the value
05:17:04 <dminuoso> lihram: eta-extend or make use of flip
05:18:28 * hackage tagsoup-navigate 0.1.0.1 - Tagsoup Navigate  https://hackage.haskell.org/package/tagsoup-navigate-0.1.0.1 (TonyMorris)
05:18:35 <dminuoso> lihram: i.e. ⌜findfun l f = lookup f (fromList l)⌝ or ⌜findfund l = flip lookup (fromList l)⌝ - both give you the same result.
05:19:01 <dminuoso> lihram: Personally I think using extra arguments leads to better readable code. :0
05:19:42 <lihram> dminuoso: Ahh, right right, because I can just choose not to apply the second variable yet. Smart! thanks
05:20:57 <dminuoso> lihram: And if you want it point free, you could write: ⌜findfun = flip lookup . fromList⌝
05:21:19 <dminuoso> Just for completeness. :)
05:21:27 <lihram> Point free?
05:22:20 <dminuoso> lihram: Pointfree means "no visible arguments (which we sometimes call points)"
05:22:22 <merijn> pointfree = without variable names
05:23:05 <lihram> Ah, thanks. It's impressive how elegant solutions can be in Haskell
05:23:12 <Ariakenom> lihram, you can always just make a function: findfun l = \key -> lookup key (fromList l). And note that f a = \b -> x is the same as f a b = x
05:24:51 <lihram> Ariakenom: Interesting, that makes the purpose of it very clear
05:25:09 <dminuoso> lihram: In general I'd say its better to just add it as an additional argument, and just view it exactly like you said
05:25:23 <dminuoso> lihram: "You can just apply it to fewer arguments and get a function taking the remaining"
05:26:44 <lihram> dminuoso: I'll keep that in mind, thanks. ^^
05:26:59 <Ariakenom> My point is that if you want to return a function, jus create a function. keep it simple
05:40:54 <lihram> Thanks for the help guys, really appreciate it :)
05:44:40 <Ariakenom> lihram: np. what are you writing?
05:58:57 <lihram> Just some homework assignments for next semester, starting my graduate course this fall :)
05:59:18 <dminuoso> lihram: Ah, which uni are you at?
05:59:30 <lihram> Aalborg university in Denmark
06:06:58 * hackage hjugement-protocol 0.0.7.20190815 - A cryptographic protocol for the Majority Judgment.  https://hackage.haskell.org/package/hjugement-protocol-0.0.7.20190815 (julm)
06:07:57 * hackage hjugement-cli 0.0.0.20190815 - Majority Judgment and Helios-C command line tool  https://hackage.haskell.org/package/hjugement-cli-0.0.0.20190815 (julm)
06:22:32 <maralorn> Something which bothers me very much about Haskell: What happens if two packages define the same Module? Does that clash immediately or only if you use a variable defined in both?
06:22:53 <dminuoso> maralorn: Check PackageImports
06:23:22 <dminuoso> maralorn: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-PackageImports
06:23:30 <maralorn> dminuoso: Ah, thx.
06:24:05 <dminuoso> maralorn: Oh, apparently that's not what one should use anymore. https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/packages.html#package-thinning-and-renaming
06:25:11 <merijn> You shouldn't really use package imports anyway
06:25:22 <merijn> You should yell at package authors to not do that >.>
06:26:16 * int-e starts making a series of packages that all export a module called Module because it can be renamed to whatever you like when the package is imported.
06:26:34 <dminuoso> @tell Ferdirand ^- I gave you bad advice there, it seems.
06:26:34 <lambdabot> Consider it noted.
06:27:28 <MarcelineVQ> but can you call it Art
06:29:05 <maralorn> What do you think about https://theam.github.io/require/ then?
06:29:19 <maralorn> Looks cool to me.
06:32:12 <dminuoso> maralorn: I am not convinced. Being explicit about import lists can be a highly valuable tool.
06:33:11 <merijn> dminuoso: The need to duplicate every import to import both qualified and the type is annoying though
06:33:20 <dminuoso> Plus, this requires anyone using your project to instll some preprocessor plugin into their GHC
06:33:37 <merijn> I'd rather see imports chaned so that "import qualified Data.Text (Text) as T" imports Text unqualified and the rest qualified
06:33:44 <dminuoso> merijn: Sure, but the price of being able to use your project is high, in comparison.
06:35:23 <maralorn> Just to be sure: Is it possible for two packages that I import to depend on the same third package with different versions?
06:35:58 <merijn> maralorn: I think with recent GHCs it should be possible IFF the types never touch
06:36:08 <merijn> But I'm not entirely sure
06:36:33 <maralorn> merijn: The question would also be, if cabal/whatever else supports it.
06:37:10 <maralorn> merijn: Yeah, of course that Type mismatch problem happens often in Rust.
06:37:40 <maralorn> But it still seems better then categorical not being able to combine to packages which internally rely on different versions of the same package.
06:39:27 <maralorn> But I thought that this is the big problem of dependency resolution in cabal, that it trys to unify all dependency constraints, of all dependencies, which might result in no solution.
06:40:05 <carter> Honestly having all instances of a package in a program be the same version avoids a lot of scary bugs that can happen otherwise
06:40:10 <merijn> maralorn: Which is why I'm not sure to what extend it currently works if you use cabal etc
06:40:30 <int-e> yeah I don't think Cabal supports this (and I'm not sure that it should)
06:40:34 <carter> And just forces maintainers to think about their relationships with packages they use more carefully. Which is a good thing I think
06:40:42 <carter> merijn: no icfp for you?
06:40:57 <merijn> carter: Nope, you already asked ;)
06:41:02 <dminuoso> carter: And it avoids weird diagnostics. Say you have some "T" and some "T -> A", but you cant apply the latter to the former because they originate from different versions and are potentially incompatible.
06:41:38 <maralorn> Well that’s what I know from Rust and node.js.
06:42:05 <maralorn> (although with node.js it‘s deadly because there is no typechecking)
06:42:28 <maralorn> (otoh sometimes it may just work …)
06:42:45 <merijn> maralorn: Generally its easier/less work to just fix the bounds on the offending conflicting package
06:43:06 <merijn> Because in most cases the real issue is the bounds, not actual breakage
06:43:31 <carter> Yeah.  And end user / build can tell cabal to relax constraints or add stronger constraints as needed
06:43:45 <maralorn> Well it feels a bit in contrast to the nix philosophy which is quite liberal with giving every software what it wants.
06:44:14 <carter> maralorn: nix work flow makes sense when the end goal is the application outputs
06:44:43 <carter> But ... nix also assumes there’s only a single version of a thingy mostly
06:44:47 <carter> Afaict
06:45:13 <carter> That different applications can have different single versions of stuff linked in is still that
06:45:54 <merijn> carter: The downside of not working for companies doing FP is that people don't want to pay for me to go to ICFP ;) I'll try to make my next job a Haskell one ;)
06:45:55 <carter> You generally don’t wanna dynamic link in two different versions of the same c lib without taking some careful steps to keep it sane.
06:49:13 <maralorn> carter: Seems reasonable.
06:50:27 * hackage sparse-tensor 0.1.0.0 - typesafe tensor algebra library  https://hackage.haskell.org/package/sparse-tensor-0.1.0.0 (nalex)
06:50:49 <maralorn> But I fell that in practice this means that unmaintained packages become unusable quickly when any of their dependencies changes their API.
06:51:22 <carter> Easy to fix
06:51:30 <carter> We have decent type errors
06:51:42 <carter> They help sooo much
06:52:21 <carter> My first few years of Haskell oss contribs were mostly me trying out new ghc and sending author / maintainers patches so stuff would build
06:54:26 <merijn> Yeah, if packages aren't actively maintained fixing them is usually not such a big problem and getting those fixes into hackage is usually fairly doable too
06:55:54 <maralorn> Still sounds like an effort I usually wouldn’t undertake.
06:58:41 <merijn> The alternative is depending on abandoned, bitrotting packages ;)
07:00:33 <maralorn> Not sure what‘s the lesser evil. Considering that hackage seems to me to be full of small useful but often unmaintained packages.
07:01:27 * hackage chronos 1.0.7 - A performant time library  https://hackage.haskell.org/package/chronos-1.0.7 (chessai)
07:04:59 <maralorn> By the way: Is there a haskell library for calculating relative human readable times?
07:06:31 <merijn> maralorn: What do you mean "human readable"?
07:06:33 <maerwald> merijn: fork, fork, fork
07:07:22 <maerwald> Also, maintainers are sometimes so opinionated about small things (e.g. exposing internal API, because you need to do something unorthodox), that you still end up forking
07:08:52 <merijn> maralorn: Normally you'd do the calculations on abstract time datatypes and then format those to something human readable
07:15:00 <lortabac> maralorn: do you mean something like https://momentjs.com/ ?
07:17:19 <maralorn> merijn: lortabac: I mean something like "in 3 minutes" "5 seconds ago" "last month".
07:17:49 <tolarz> lambdabot: help
07:17:59 <tolarz> I've been told this lambdadot can do pointfree conversions
07:18:25 <merijn> maralorn: time has CalenderDiffTime you'd manually need to do pretty formatting, though
07:18:37 <lyxia> @pl \f x y -> f x y
07:18:38 <lambdabot> id
07:19:07 <tolarz> @pl \f x -> x + 1
07:19:07 <lambdabot> const (1 +)
07:19:35 <maralorn> > id x y
07:19:37 <lambdabot>  error:
07:19:37 <lambdabot>      • Couldn't match expected type ‘Expr -> t’ with actual type ‘Expr’
07:19:37 <lambdabot>      • The function ‘id’ is applied to two arguments,
07:19:40 <tolarz> @pl \f x -> foldr (+) 0 x
07:19:40 <lambdabot> const (foldr (+) 0)
07:19:47 <int-e> @pl \f x -> x - 1
07:19:47 <lambdabot> const (subtract 1)
07:19:56 <tolarz> this would have been SUPER HELPFUL one semester ago xD
07:20:29 <tolarz> can we write every function this style?
07:20:45 <tolarz> or, perhaps, every primitive recursive one
07:21:07 <tolarz> @pl \f x -> 3
07:21:07 <lambdabot> const (const 3)
07:21:09 <merijn> tolarz: Can we? Sure. Should we? Definitely not.
07:21:21 <tolarz> this was more a theoretical Q
07:21:23 <tolarz> why can we?
07:21:35 <int-e> @pl f x = 1 + f x
07:21:35 <lambdabot> f = fix ((1 +) .)
07:21:48 <maralorn> merijn: What about something which consumes x twice?
07:22:05 <int-e> @pl f x = x + f (1 + x)
07:22:05 <lambdabot> f = fix (ap (+) . (. (1 +)))
07:22:07 <tolarz> @pl f x = (x, x)
07:22:07 <lambdabot> f = join (,)
07:22:21 <maralorn> @pl f x y = x*x*y
07:22:22 <lambdabot> f = (*) . join (*)
07:22:26 <int-e> maralorn: welcome to the reader monad
07:22:38 <tolarz> @pl f x = (x, 2+x)
07:22:38 <lambdabot> f = ap (,) (2 +)
07:22:45 <maralorn> int-e: It’s just (a ->) right?
07:22:46 <merijn> maralorn: Well, SKI combinator calculus has only 3 combinators (i.e. no arguments and thus no names) and is Turing complete
07:22:50 <int-e> maralorn: yes
07:23:06 <merijn> maralorn: So at the very least you could encode SKI in Haskell and write it in that?
07:23:09 <int-e> and I = SKK
07:23:10 <tolarz> oh
07:23:11 <maralorn> cool
07:23:44 <int-e> > let s = ap; k = const; i = id in s k k i 42
07:23:48 <merijn> Of course it will be completely unreadable to us mortals :p
07:23:48 <lambdabot>  42
07:23:49 <tolarz> so we can even encode *every* computable function pointfree?
07:24:19 <maralorn> That‘s why they call it pointless.^^
07:24:47 <merijn> maralorn: If you really wanna know, it's called pointfree because the term comes from algebraic geometry :)
07:24:51 <int-e> Well, Haskell is typed, so SKI are not enough. You need `fix` as well, and something to work with datatypes.
07:25:35 <int-e> "pl" stands for "pointless" because of how useful it generally is
07:25:35 <merijn> maralorn: Where functions are generally over "points" in a space, functions with no named arguments are therefore "pointfree" (since you're not naming specific points)
07:25:37 <tolarz> I mean, how would you write addition pointfree?
07:25:42 <tolarz> perhaps with Church encoding?
07:26:01 <tolarz> @pl x + y
07:26:01 <lambdabot> x + y
07:26:08 <tolarz> @pl f x y = x + y
07:26:08 <lambdabot> f = (+)
07:26:18 <tolarz> sure but how is + defined...
07:26:26 <maralorn> merijn: I figured es much, but I didn’t know that it’s specific to algebraic geometry.
07:26:46 <maralorn> I mean even in simple calculus x and y usually are points.
07:29:43 <Ariakenom> you don't need to be able to produce every haskell term, like datatypes, to be turing complete
07:33:06 <Ariakenom> tolarz: you can imagine it boiling down to a special compiler function addInt
07:33:55 <tolarz> Ariakenom: now that's lame
07:33:57 <tolarz> :-)
07:34:25 <Ariakenom> for the type Int. you can always do the church encoded version too
07:34:39 <tolarz> can't you do
07:34:49 <tolarz> (+) := fold (+1)
07:34:57 <tolarz> or rather, (+) := fold succ
07:35:06 <tolarz> @pl fold succ
07:35:06 <lambdabot> fold succ
07:35:14 <tolarz> @pl fold succ 3 4
07:35:14 <lambdabot> fold succ 3 4
07:35:18 <tolarz> > fold succ 3 4
07:35:21 <lambdabot>  error:
07:35:21 <lambdabot>      • Could not deduce (Foldable ((->) (t0 -> t1 -> t3)))
07:35:21 <lambdabot>        from the context: (Foldable ((->) (t -> t2 -> t3)), Monoid t3,
07:35:41 <tolarz> hm
07:36:12 <tolarz> > succ
07:36:15 <lambdabot>  error:
07:36:15 <lambdabot>      • No instance for (Typeable a0)
07:36:15 <lambdabot>          arising from a use of ‘show_M876099185813988863627780’
07:36:30 <tolarz> huh
07:36:35 <int-e> > let fold f z n = iterate f z !! n in fold succ 3 4
07:36:40 <lambdabot>  7
07:36:53 <tolarz> what was the problem?
07:37:05 <int-e> "fold" isn't "fold"
07:37:25 <tolarz> now you're entering scary NaN != NaN territory!
07:37:37 <int-e> tolarz: I defined a new "fold" function there.
07:37:59 <int-e> There is no Foldable instance for numbers; it doesn't make sense because numbers don't contain any elements.
07:38:14 <winny> :t fold
07:38:16 <lambdabot> (Foldable t, Monoid m) => t m -> m
07:38:17 <tolarz> for me it makes sense for every inductive datatype?
07:38:55 <int-e> tolarz: Foldable isn't what you expect then.
07:39:02 <tolarz> :|
07:39:29 <int-e> Catamorphisms can't be abstracted into a type class, I think. Not easily, anyway; you'll end up in Generics territory.
07:40:05 <c_wraith> um. isn't that what Recursive from recursion-schemes does? 
07:40:11 <tolarz> yes, idk how datatypes are defined in haskell, but I would envision an autogenerated fold function
07:40:57 <c_wraith> the trick being that Recursive requires two data types.. the type it operates on and a base Functor for that type. 
07:41:23 <tolarz> http://hackage.haskell.org/package/recursion-schemes-5.1.3/docs/Data-Functor-Foldable.html#v:cata
07:42:17 <int-e> I conveniently forgot about Fix. Nevertheless extracting the underlying functor from a datatype is roughly what I had in mind with "Generics territory".
07:42:55 <c_wraith> you don't need Fix for that library. it provides Recursive instances for types not using it, like [] 
07:43:46 <tolarz> manual extraction of the functor doesn't sound like fun
07:43:50 <tolarz> this is something the language should cater for
07:43:57 <tolarz> *catermorphism for lol
07:44:27 <c_wraith> there are libraries that use TH to generate the base functor for you 
07:44:52 <c_wraith> since it is that mechanical of a process. 
07:44:58 <tolarz> yup
07:46:34 <c_wraith> but in general, recursion schemes aren't something Haskell is designed to abstract over. the only way to have a uniform type is to pull all the varying bits into a new type. 
07:46:49 <tolarz> meh
07:47:10 <tolarz> is there any recursion scheme oriented lang?
07:49:22 <c_wraith> not with any kind of library ecosystem. there might be some more esoteric languages, but none that are used even semi-broadly. 
07:50:06 <c_wraith> most of the lisp variants can probably use macros to do essentially the same thing as is done in TH 
07:51:05 <tolarz> I am into esoteric languages
07:51:18 <c_wraith> but then you're using lisp and don't have type inference to guide code generation 
07:51:28 <tolarz> found some cool ones, e.g. one allowing typed holes
07:57:11 <maralorn> tolarz: What do you mean by that? Doesn’t Haskell allow typed holes?
07:58:06 <maralorn> That being said: Are there editor extensions which can add toplevel type annotations?
07:58:09 <c_wraith> I think that was the point. (despite Haskell not fitting the traditional definition of an esolang) 
07:59:10 <tabaqui> hello, it's me again with Cabal issue
07:59:31 <tabaqui> I want to add new preprocessor into custom Setup.hs
07:59:41 <tabaqui> using defaultMainWithHooks
07:59:57 <tabaqui> but it looks like, preprocessor is never called
08:00:11 <tabaqui> main = defaultMainWithHooks $ addThriftPP simpleUserHooks
08:00:20 <tabaqui> addThriftPP uh = uh { hookedPreProcessors = thriftPP:hookedPreProcessors uh }
08:00:22 <tabaqui> like so
08:00:39 <c_wraith> do you have the flag set to tell cabal to use setup.hs? 
08:00:51 <tabaqui> yes
08:01:29 <tabaqui> I played around with the Setup.hs and found that buildHook failed with an error "can't find source for Common_Types in src, thrift"
08:01:48 <tabaqui> and it doesn't even try to call Thrift preprocessor
08:03:03 <tabaqui> now I stopped with modified hookedPreProcessors and hookedPrograms, but I can't understand which place should I patch next
08:05:30 <tabaqui> s/stopped/ended up
08:26:31 <tabaqui> allright, now I see that is cannot handle wile with .thrift extension
08:27:01 <tabaqui> buildHook = \a b c d -> build a b d [("hsc", undefined)] raises and undefined error, if "Test.hsc" exists
08:27:17 <tabaqui> while [("thrift", undefined)] does not if "Test.thrift" exists
08:29:30 <tabaqui> s/wile/file
08:30:51 <tabaqui> yeah, I got it
08:31:12 <tabaqui> preprocessor looks for a files named exactly as <module_name>.<extension>
08:31:53 <tabaqui> but Thrift can translate, f.e. "common.thrift" into "Common_Types.hs" and "Common_Constants.hs"
08:32:28 <tabaqui> so it's not as simple as add new Preprocessor, I need to modife buildHook as well
09:01:27 * hackage githud 3.1.0 - Heads up, and you see your GIT context  https://hackage.haskell.org/package/githud-3.1.0 (gbataille)
09:14:03 <wroathe> Holy crap does Gitlab ever grind on the haskell site
09:14:17 <wroathe> Every page takes a minimum of 15 seconds to load
09:14:48 <Taneb> wroathe: I've not had that experience. Where are you? Might be to do with ping time
09:15:17 <wroathe> Minnesota
09:15:19 <wroathe> https://gitlab.haskell.org/ghc/ghc/wikis/commentary/pipeline
09:15:47 <wroathe> my ping to that server averages like 40ms
09:15:51 <Taneb> Oooh boy, that one is slow
09:15:57 <Taneb> Huh
09:19:57 <srid> Cale: have you seen https://github.com/kowainik/typerep-map ? I wonder if you have any thoughts on its comparison to dependent-map.
10:30:28 * hackage hsinspect 0.0.1 - Inspect Haskell source files.  https://hackage.haskell.org/package/hsinspect-0.0.1 (tseenshe)
10:54:28 <wroathe> Hmm, this is a nifty way to do multi-way if https://gitlab.haskell.org/ghc/ghc/blob/ghc-8.6.5-release/compiler/main/GhcMake.hs#L1486
10:56:17 <dmwit> Yep, it's a nice trick.
10:58:36 <jle`> wroathe: i think it's self-hosted, and they're currently working through a few kinks
11:00:02 <wroathe> jle`: Oh, on the gitlab instance?
11:00:58 <wroathe> jle`: I'm sure it is self hosted. I've used Gitlab in a few enterprises in the past and it usually chugs along unless you through a ridiculous amount of resources at it
11:02:17 <wroathe> you throw*
11:16:57 <jumper149> Is there a convention for the order in `where` clauses like when I just divide an algorithm into steps should the order be procedural or the finished result at the top and the specific steps below?
11:23:17 <maralorn> jumper149: I don‘t know of any (and the number of equivalent possibilities drives me crazy). But I‘d use the same convention I‘d use in a mathematical text. If the meaning of the formula is intuitively clear to the reader without the definitions, but them behind (e.g. where x,y,z are real numbers). If the formula is only understandable with the definitions, make the reader read them before.
11:23:44 <maralorn> *put them behind
11:25:21 <jle`> jumper149: yeah, try to tell a "story" that readers can follow along to, with logical steps
11:25:22 <maralorn> Like when you need some semantically irrelevant type conversions (encoding, etc.) I‘d put them in a where.
11:26:03 <maralorn> But if it get‘s more complex linearly is often easier.
11:27:00 <jumper149> maralorn: I guess that sounds reasonable, I think in doubt it's better to put the finished product at the top though, since it lets the reader chase down variable names found outside of the where.
11:28:14 <jumper149> Is `let` lazy?
11:28:50 <Boarders> If I have a byte array in C then gcc will, to some extent, vectorise instructions in 256 bit chunks
11:29:05 <maralorn> jumper149: Yes.
11:29:32 <Boarders> is there a reason why there is not a bit vector library that does something like that?
11:29:48 <Boarders> would it be too costly to keep crossing for such operations?
11:29:55 <Boarders> ffi*
11:30:05 <maralorn> jumper149: And where just desugars to let so for the behaviour of the program it doesn‘t matter at all.
11:30:57 <jumper149> Alright, well I think for `let` it's still easier to write procedural.
11:31:12 <jumper149> To me `let` always feels like lisp
11:31:24 <yushyin> Boarders: simd instructions are a work in progress in GHC https://gitlab.haskell.org/ghc/ghc/wikis/simd
11:34:21 <jumper149> Does ghc do eta conversions automatically? Shouldn't it be a relatively simple optimization?
11:34:45 <lavalike> I believe there is a library for data parallel code, what is it called hm
11:35:52 <lavalike> this http://repa.ouroborus.net
11:36:52 <lavalike> I might be wrong
11:37:29 <wroathe> bgamari: Not that I have the expertise to work on this, but is there a checklist of what's been done and what remains to be done anywhere for https://gitlab.haskell.org/ghc/ghc/issues/4012?
11:38:21 <isovector1> cocreature: i literally just hit this: https://github.com/mpickering/hie-bios/pull/15. your timing is impeccable!
11:39:34 <cocreature> isovector1: hah, glad it helps. I’m not using stack myself. I just fixed it for Shayne :)
11:40:20 <Boarders> yushyin: I didn't mean using SIMD instructions in GHC but using the code that gcc outputs which is vectorised
11:40:22 <maralorn> jumper149: ghc will probably do the eta conversion, if you enable optimisation passes. but I always life with the slightly uneasy feeling, that it might not catch it in every case. (I‘d like to know more about it.)
11:43:11 <maralorn> jumper149: But I am pretty sure that ghc will catch everything hlint would for example.
11:44:59 <maralorn> The problem is that sometimes making expressions pointfree will have effects on evaluation order. I‘d be curious to learn how liberal ghc is with that. (I think not very much.)
11:49:19 <jumper149> Here https://wiki.haskell.org/Let_vs._Where I just read, that eta reduction will reduce time complexity, but might be worse for space complexity, so I guess a compiler can only do so much...
11:50:04 <dmwit> jumper149: The convention I use is to put things in top-down order (each definition depends only on later definitions) when using where; bottom-up (each definition only mentions already-defined things) when using let.
11:50:29 <dmwit> jumper149: Additionally, I find bottom-up/let style easier to deal with when writing monadic code, and generally prefer top-down/where-style otherwise.
11:50:52 <dmwit> This is an expression of my preferences, and may not be reflective of the wider community. I have been known to have... unpopular preferences.
11:51:24 <dmwit> I suspect GHC will not do eta-reduction, because it is not semantics-preserving.
11:52:02 <dmwit> You can find out for sure in particular cases with -ddump-simpl as usual.
11:52:28 <dmwit> Boarders: What does "vectorised" mean, if not SIMD?
11:53:28 <Boarders> I did mean SIMD, I just had thought it is different if the instruction is produced by gcc as opposed to a prim op in GHC
11:53:35 <jumper149> dmwit: -ddump returns Haskell core?
11:53:49 <Boarders> that might just be a misunderstanding from me on how FFI works
11:53:52 <dmwit> -ddump-simpl prints Haskell core, yes.
11:54:11 <dmwit> -ddump is not a flag, though there are many flags that begin with -ddump.
11:54:39 <dmwit> Boarders: I would assume that the end goal would be to not involve the FFI at all.
11:54:53 <dmwit> And not involve gcc at all, either.
11:56:03 <Boarders> absolutely, I had just wondered if for instance I had a pined byte array and a 256 chunked operation (e.g. xor) that is vectorised by gcc if one could leverage that to have it on the haskell side
11:56:22 <Boarders> I'm not sure if such an operation would ever be worth the ffi call, I don't know
11:56:22 <jumper149> Ye, I was looking up the man page. They all seemed to return some language Haskell get's compiled to, so I guess core, but it seems like there are other options which do differently like -ddump-llvm.
11:56:55 <dmwit> Boarders: I second yushyin's response: doing that vectorisation in GHC itself is a work in progress. I don't see why you're so set on wanting to use gcc and FFI instead.
11:57:09 <dmwit> s/Haskell core/GHC core/ whoops!
11:57:24 <jumper149> Why doesn't ghc use 2 dashes -- for options with more than one character 
11:57:33 * jumper149 is bamboozled
11:57:34 <Boarders> dmwit: I am not set on it! I had just wondered if it was possible and how worth it it would be from someone who better understands this sort of thing
11:57:40 <dmwit> jumper149: I suspect hysterical raisins.
11:58:55 <dmwit> Boarders: Unless you have a very large chunk that you're vectorizing (say, a couple thousand vectored instructions), I would expect the FFI boundary cost to outweigh the benefit. Primops would be much cheaper.
11:59:23 <Boarders> dmwit: thanks for the insight!
11:59:27 <dmwit> The bookkeeping needed for crossing FFI boundaries is pretty nontrivial.
12:04:41 <Boarders> is there a safe way to convert a Data.Vector.Unboxed.Vector Bool to a Primtiive.Vector Word8
12:04:55 <Boarders> the first is a newtype instance of the second but the module does not export the constructor
12:05:03 <Boarders> and so they cannot be coerced
12:05:41 <Welkin> but can they be tortured?
12:05:51 <Welkin> I mean
12:05:56 <Welkin> enhacned interrogated
12:07:53 <dmwit> Boarders: Only the sad way of reading each index.
12:08:32 <Boarders> how bad taste is it to use unsafeCoerce in such scenarios?
12:10:11 <Welkin> like eating shit
12:10:24 <spoonm> lol
12:15:22 <jumper149> Why isn't `read` defined as `read :: Read a => String -> Maybe a` and instead throws an exception when it fails... is there a way to write a wrapper to catch the exception?
12:16:34 <jumper149> nvm...
12:16:48 <jumper149> @t readMaybe
12:16:48 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
12:16:53 <jumper149> :t readMaybe
12:16:55 <lambdabot> error: Variable not in scope: readMaybe
12:17:11 <jumper149> :t Text.Read.readMaybe
12:17:12 <lambdabot> Read a => String -> Maybe a
12:19:11 <c_wraith> :t reads -- jumper149 fwiw, this is the base operation on the class. 
12:19:12 <Boarders> Is it possible to convert between different types of primitive vectors?
12:19:13 <lambdabot> Read a => ReadS a
12:19:32 <Boarders> e.g. consider a Primitive.Vector Word8 as Primitive.Vector Word64 etc
12:19:42 <EvanR> why are there so many types of vector...
12:20:09 <c_wraith> same reason there are so many types of string. they do different things. 
12:20:11 <Boarders> because haskell allows polymorphism, boxing etc etc
12:20:30 <EvanR> why not just boxed and unboxed then
12:21:06 <c_wraith> you need Storable too, for ffi use
12:21:41 <EvanR> seems like that is necessarily some kind of unboxed
12:21:43 <Boarders> and primitive seems mostly just the underlying representation for unboxed
12:22:23 <c_wraith> EvanR: the important part is that it's using the C data representation. that requires doing things differently 
12:22:47 <EvanR> ok yeah... js has something like that
12:22:57 <EvanR> a packed vector thing
12:24:08 <Welkin> unit8
12:24:10 <Welkin> uint8
12:24:57 <c_wraith> for example, you can have a Storable vector of things that can't be unboxed. 
12:25:18 <c_wraith> that's actually moderately common, even. 
12:31:33 <EvanR> but you could argue that everything that can be unboxed can be made storable? this would also cover the ByteString
12:32:34 <EvanR> basically making Storable vector the catch all for packing vectors
12:33:06 <EvanR> and the implementation of vectors of regular values
12:33:20 <EvanR> so it could have a zero cost coercion
12:43:59 <dmwit> Storable vectors probably also have to uses pinned memory, which is less friendly to GC than the memory used by non-Storable boxed vectors.
12:44:08 <dmwit> non-Storable unboxed vectors, I m ean.
12:48:17 <lyxia> EvanR: https://github.com/haskell/vector/issues/250
12:49:24 <isovector1> yall got a nice combinator that takes every nth element of a list?
12:50:31 <isovector1> in particular i just want n=2
12:58:05 <MarcelineVQ> every 2 has a fun little thing: fst . foldr (\x ~(xs,ys) -> (ys,x:xs)) ([],[]) and you can just flip which side you add x to to change which n you start from
12:58:17 <MarcelineVQ> nooo why did you leave, you know how irc works
12:58:36 <MarcelineVQ> or I guess you can just use snd as well :>
13:01:54 <dmwit> % :set -XDataKinds
13:01:55 <yahb> dmwit: 
13:02:20 <dmwit> % data Hum a where A :: Hum A
13:02:20 <yahb> dmwit: ; <interactive>:64:27: error:; * Data constructor `A' cannot be used here (it is defined and used in the same recursive group); * In the first argument of `Hum', namely `A'; In the type `Hum A'; In the definition of data constructor `A'
13:02:27 <dmwit> oh well
13:02:32 <Welkin> :t second
13:02:35 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
13:02:51 <Welkin> arrows
13:02:57 <Welkin> who uses those anymore
13:03:29 <dmwit> ?tell isovector1 You could use `map head . chunksOf 2` to get every second element.
13:03:30 <lambdabot> Consider it noted.
13:07:34 <MarcelineVQ> dmwit: that's probably better than the agda error for the same which will just tell you that A isn't in scope, which is true but not entirely obvious
13:07:43 <dmwit> :t zipWithM
13:07:45 <lambdabot> Applicative m => (a -> b -> m c) -> [a] -> [b] -> m [c]
13:08:20 <dmwit> > zipWithM ($) (cycle [pure, const []]) "abcdefghi"
13:08:22 <lambdabot>  []
13:08:58 <dmwit> > concat . zipWith ($) (cycle [pure, const []]) $ "abcdefghi"
13:09:01 <lambdabot>  "acegi"
13:09:18 <Welkin> what is this abomination!?
13:09:29 <dmwit> oh, even cuter
13:09:31 <MarcelineVQ> now do a monoid versio
13:09:32 * Welkin flicks holy water
13:09:35 <dmwit> > concat . zipWith ($) (cycle [pure, pure []]) $ "abcdefghi"
13:09:37 <lambdabot>  "acegi"
13:09:38 <Welkin> the power of Church compels you!
13:10:17 <Welkin> I won't be going to this year's Strange Loop
13:10:34 <Welkin> but last year's was fun, even though I got horribly sick for weeks
13:18:24 <dmwit> ?let frst (a,_,_) = a
13:18:25 <lambdabot>  Defined.
13:18:56 <dmwit> > frst . foldr (\x (xs, f, g) -> (f x xs, g, f)) ([], (:), flip const) $ "abcdefghi"
13:19:00 <lambdabot>  "acegi"
13:20:23 <Welkin> frist
13:20:25 <Welkin> haha
13:20:36 <Welkin> make it frisch
13:20:59 <MarcelineVQ> that's neat, swapping the functions instead of the list you prepend
13:22:17 <absence> the hasql library derives Contravariant for a type, but i can't find much info about how that works. does anyone know if it's supported in ghc itself, or via some package?
13:22:29 <MarcelineVQ> it's not quite as lazy though
13:22:29 <absence> http://hackage.haskell.org/package/hasql-1.4/docs/src/Hasql.Private.Encoders.html#Params
13:24:29 <MarcelineVQ> absence: I think that'd be using DeriveAnyClass, maybe the cabal file has some extentions set project-wide, since that file doesn't have any
13:25:51 <absence> MarcelineVQ: it does indeed have extensions, but not DeriveAnyClass: https://github.com/nikita-volkov/hasql/blob/master/hasql.cabal
13:26:34 <dmwit> > frst . foldr (\x (xs, f, g) -> (f x xs, g, f)) ([], (:), flip const) $ ['a'..]
13:26:37 <lambdabot>  "acegikmoqsuwy{}\DEL\129\131\133\135\137\139\141\143\145\147\149\151\153\155...
13:26:41 <dmwit> Looks lazy to me?
13:27:04 <MarcelineVQ> absence: ah yeah it's got a big old list of default extentions set in the cabal file, not a fan of that personally though I understand it, maybe it's GeneralizedNewtypeDeriving then, would have to look at the classes and see if they fit that
13:27:09 <dmwit> I guess that's not good evidence.
13:27:14 <dmwit> > frst . foldr (\x (xs, f, g) -> (f x xs, g, f)) ([], (:), flip const) $ [1..]
13:27:21 <lambdabot>  mueval-core: Time limit exceeded
13:27:24 <dmwit> huh
13:27:28 <dmwit> > frst . foldr (\x ~(xs, f, g) -> (f x xs, g, f)) ([], (:), flip const) $ [1..]
13:27:35 <lambdabot>  mueval-core: Time limit exceeded
13:27:43 <dmwit> Works locally...
13:28:06 <MarcelineVQ> dmwit: I used take 5 or similar as a stopper instead of printing to see if things are lazy
13:28:51 <dmwit> wait
13:28:57 <dmwit> I had something working locally. But not that apparently.
13:30:03 <absence> MarcelineVQ: ah, good point! following the newtype wrappers, it ends up with Op, which of course has Contravariant
13:30:55 <absence> thanks for the help
13:34:06 <MarcelineVQ> absence: if you intend to use that mechanic yourself you should read about https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-DerivingVia which is a more powerful way to go about things if a person needs to
13:39:16 <dmwit> Neat. This isn't a foldr.
13:39:32 <Welkin> it's a directory
13:46:43 <inkbottle> Parser a → Parser (a → b) → Parser b; "due to parametricity, the second parser will never depend on the (runtime) result of the first".
13:46:49 <inkbottle> Parser a → (a → Parser b) → Parser b; "the second parser will always depend on the (runtime) result of the first".
13:48:01 <inkbottle> If someone could provide an example to help me understand the statements above.
13:48:15 <inkbottle> from: https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/parsec-paper-letter.pdf
13:50:44 <inkbottle> Parametricity must be about 'a' does not stand for a fixed type, but can be replaced by String, or Int
13:51:32 <inkbottle> Oh, yes, OK I got it
13:51:34 <inkbottle> I think
13:52:02 <inkbottle> In the second type we have an indexed array of parser
13:52:28 <inkbottle> (or indexed family)
13:54:34 <wroathe> Is there a way to set the cwd for cabal v2-run?
13:58:57 <MarcelineVQ> inkbottle: (a → Parser b) isn't even a Parser until we can give it an a, in that sense it depends on the result of Parser a. I don't have an explanation for the first example though, other than the observation that it's already a Parser, it doesn't need something else in order to exist. related, though not to parsing, info here https://stackoverflow.com/questions/20590710/applicative-functors-analysis
13:59:50 <Boarders> if I want to do an operation on unboxed vectors where they both need to have the same length what is my best bet? I can either keep them immutable and append zeroes or I can make them mutable and then grow the one?
14:18:38 <freeman42x> is there any TypeApplications for Dummies tutorial or something?
14:25:45 <MarcelineVQ> ye https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-TypeApplications gotta read it really well though
14:29:27 <infinisil> Boarders: What's the operation?
14:30:18 <infinisil> I'd use whatever could be faster for the operation
14:35:30 <freeman42x> MarcelineVQ, I've gone through that and it was not enough for me to understand :( like... what decides the name of the type application? what are valid identifiers for the type application?
14:37:34 <dmwit> Boarders: You could also shorten the longer one. The take operation is very cheap (does not copy, just record's the new slice boundaries).
14:37:46 <freeman42x> this has some better examples imo: https://blog.sumtypeofway.com/fluent-polymorphism-with-visible-type-applications/
14:38:31 <Boarders> dmwit: ah good idea, thank you
14:49:28 <tabaqui> yeah, I've finished Setup.hs for thrift language
14:49:40 <tabaqui> I'll try to prepare PR on weekend
14:52:47 <MarcelineVQ> freeman42x: I don't know what you mean by the name or identifier of type applications
14:53:38 <freeman42x> MarcelineVQ, the identifier of the TypeApplication is the symbol name after the @ sign
14:54:00 <MarcelineVQ> That's the type you're assigning to a type variable
14:54:41 <MarcelineVQ> foo :: a -> b -> a; foo a b = a; if I wrote foo @Int, then a is Int
14:54:56 <MarcelineVQ> % :q
14:54:56 <yahb> MarcelineVQ: 
14:55:02 <MarcelineVQ> % foo :: a -> b -> a; foo a b = a
14:55:03 <yahb> MarcelineVQ: 
14:55:10 <MarcelineVQ> % :t foo @Int
14:55:10 <yahb> MarcelineVQ: Int -> b -> Int
14:55:37 <monochrom> I might call it "actual type parameter". Because at the value level, in "f (x+1)" we say that x+1 is the actual parameter.
14:56:01 <monochrom> (And in "f = \v -> v*2", we say that v is the formal parameter.)
14:56:43 <MarcelineVQ> Whatever you want to call it it's the first pararaph of the manual page, so I'm having trouble understanding the non-understanding :X
14:57:02 <jle`> in f (x+1), x+1 is the argument, isn't it?
14:57:09 <monochrom> Oh haha
14:57:20 <jle`> or maybe actual parameter is a formal word for argument
14:57:32 <rotaerk> yeah I've generally called the x in "\x -> ..." a parameter, and the value provided when applying the function is the argument
14:58:01 <jle`> that's the technical distinction i've learned in classes/have passed on to my students, at least :)
14:58:02 <rotaerk> so Int is the type *argument* of `id @Int`
14:58:07 <monochrom> Yes there are two conventions. One is "formal vs actual", the other is "parameter vs argument".  But I can never memorize how to use the latter convention.
14:58:34 <monochrom> IMO "formal" and "actual" is self-documenting and does not require rote memorization.
14:58:43 <jle`> yeah, param/arg is kind of arbitrary
14:59:04 <monochrom> param : arg : port :: starboard
14:59:59 <jle`>  :: left : right
15:00:05 <jle`> well actually i suppose left/right isn't arbitrary
15:00:12 <jle`> given its etymology
15:00:36 <monochrom> left:right is that kind where everyone is taught early on so at least you can claim universality.
15:01:00 <monochrom> param:arg is pretty obscure and seldom taught, even among CS and programmers.
15:01:52 <monochrom> It was widely taught before OOP came around and ruined CS education. Recall that before OOP it was a procedural and functional world, and both needed the vocabulary.
15:02:47 <jle`> left:right is actually linked to human physiology so it can claim non-arbitrariness
15:02:53 <monochrom> Now people only know about object vs class vs interface vs abstract class vs mixin
15:03:15 <jle`> what kind of world did OOP leave us :'(
15:04:45 <jle`> are we in the darkest timeline
15:05:10 <monochrom> No, it is brighter now than 15 years ago.
15:05:36 <monochrom> 15 years ago it looked like people were on to the next level of OOP, known as AOP.
15:05:51 <jle`> there's a lot to be hopeful for, i suppose :)
15:05:53 <monochrom> Thank God AOP is even more obscure than param-vs-arg today!
15:08:20 <freeman42x> MarcelineVQ, I get that actual types can be used, but what about this? f <- forAllFn $ fn @a genA <- how does this work. `a` seems to be some generic parameter
15:10:52 <MarcelineVQ> no it'll come into scope somewhere, possibly by a forall in the top-level signature of what you got that from
15:11:20 <jle`> freeman42x: in that case 'a' can't be a free variable, it has to bedefined or bound somewhere
15:11:28 <jle`> if 'a' wasn't in scope you'd get an out of scope error
15:11:41 <jle`> just like if you wrote `myFunction x`, and x isn't defined anywhere
15:12:16 <freeman42x> MarcelineVQ, jle` I understand now guys, thank you!
15:12:22 <jle`> basically the same as genA in your example
15:12:23 <dyl> -> it has to bedefined
15:12:28 <dyl> -> it has to beefdined
15:12:38 <freeman42x> are these 2 lines functionally equivalent? https://gist.github.com/razvan-panda/a8a80e5bb362c3f4c36773ebe4f62f64#file-hedgehog-fn-hs-L21-L22
15:12:43 <jle`> you can't use genA unless you define it somewhere or if it's in scope
15:12:43 <dyl> beef dine your variables, folks.
15:13:05 <jle`> only free range variables
15:14:26 <jle`> freeman42x: are you asking if (fmap apply . forAll) is the same as (forAllFn) ?
15:14:56 <jle`> if that's what you are asking, then that really depends on how all of those functions are defined and what they mean
15:15:12 <jle`> and not on any haskell syntactic rules
15:15:16 <dyl> monochrom I think your take on "before OO it was a procedural and functional world" is a bit spicy (and misleading ;p).
15:15:54 <monochrom> Europeans used spices to mislead.
15:16:07 <dyl> "param:arg is pretty obscure and seldom taught" is also not true today at all.
15:16:24 <dyl> Nearly every up-and-coming language uses postfix type annotations.
15:17:02 <freeman42x> jle`, (fmap apply . forAll) being functionally equivalent to (forAllFn), yes. That's the question. They are from hedgehog-fn https://github.com/qfpl/hedgehog-fn
15:18:02 <freeman42x> after replacing the first with the 2nd I am getting the same test failure
15:20:12 <dyl> ah, I misread, my bad.
15:21:55 <dyl> I think the parameter/argument confusion goes back any further. As I understand it, in e.g. \log_b(x), b is a parameter and x is an argument (and arguments are particular sort of parameter).
15:22:15 <dyl> But the common jargon for adding an argument is "parameterizing"...
15:22:33 <monochrom> Yeah
15:25:28 <dyl> Not to mention f(x1, x2, ... ; a1, a2, ...) syntax.
15:25:30 <dyl> ;p 
15:25:39 <freeman42x> jle`, they don't seem to be exactly the same: https://i.imgur.com/e4UwvKn.png they lead to different test output, one does not print the generated function
15:27:08 <dyl> monochrom one other thing: it's not really the fault of the object-oriented paradigm that its own bastardizations were poorly taught.
15:27:38 <dyl> A fun experiment, in the following expression: `foo.do_bar(x)`... what is the name of the syntactic position `foo` occupies?
15:28:08 <dyl> OO had a name for this before Java ate the world :). Now it's largely forgotten on account of misleading (and imo bad) syntax.
15:28:13 <freeman42x> jle`, they seem to be functionally equivalent... but they lead to different testing output, well, this makes no sense haha
15:29:10 <orzo> I'm struggling with a type error, https://paste.ee/p/MzyPs
15:29:18 <dyl> If one interprets `do_bar` as a message, then `foo` is the "receiver".
15:29:19 <dyl> So, I don't blame "OO" abstractly, but rather the questionable decision to divorce OO (message passing) semantics from the surface syntax.
15:29:28 <orzo> It works fine for specific cases, but I want full polymorphism
15:30:31 <jle`> freeman42x: what makes you think they shouild be functionally equivalent?
15:30:52 <orzo> my paste compiles if you disable the line the error is on
15:31:15 <freeman42x> jle`, I don't think they should, but it seems they are
15:31:29 <orzo> (line 32)
15:31:53 <jle`> orzo: ambiguous type errors usually means that type inference can't figure out what a given type variable should be instantianted as
15:32:25 <jle`> one way to track it down is to explicitly apply type variables
15:32:33 <jle`> freeman42x: but they lead to different testing output?
15:32:39 <jle`> what do you mean by 'seems' ?
15:33:18 <freeman42x> jle`, I mean, I quote "this makes no sense haha"
15:34:33 <orzo> jle`: what makes it hard is that i have an arbitrary chain of arrows (a -> ... -> c) and c is the amiguous one
15:36:50 <orzo> i do have another function acquired through fix that is another, unequal, chain of arrows , but has the same return type in the end.  Can you think of a way I can use that value (variable s) to hint the (f . g) expression?
15:37:21 <sarahzrf> is it possible to convince ghc to unify typelevel "Not (Not b)" with "b"
15:37:34 <sarahzrf> before someone goes off on me about intuitionistic logic: b is a boolean here
15:40:42 <hpc> what is Not?
15:41:42 <hpc> if it's "type aliasy", it should work i think
15:41:50 <hpc> like the "type" keyword, or type families
15:43:13 <orzo> type Not b = b -- will do the trick ;)
15:43:40 <sarahzrf> type family
15:43:44 <sarahzrf> from Data.Type.Bool
15:44:19 <sarahzrf> and that doesnt work as written, nor should that be surprising
15:44:30 <sarahzrf> eh, this is probably an xy problem
15:44:38 <hpc> hmm
15:44:51 <hpc> i could have sworn that works
15:45:16 <sarahzrf> well, let me double check really quick
15:45:38 <Lears> I think if you rewrote `Not` defunctionalised you could include `instance Eval (Not (Not b)) = b`.
15:45:50 <Lears> Or something like that.
15:46:05 <sarahzrf> hpc: yeah, check this ou
15:46:06 <sarahzrf> t
15:46:12 <sarahzrf> % import Data.Type.Bool
15:46:13 <yahb> sarahzrf: 
15:46:33 <sarahzrf> % data Foo (b :: Bool)
15:46:33 <yahb> sarahzrf: 
15:46:48 <sarahzrf> % :t id :: Foo b -> Foo (Not (Not b))
15:46:48 <yahb> sarahzrf: ; <interactive>:1:1: error:; * Couldn't match type `b1' with `Not (Not b1)'; `b1' is a rigid type variable bound by; an expression type signature:; forall (b1 :: Bool). Foo b1 -> Foo (Not (Not b1)); at <interactive>:1:7-32; Expected type: Foo b1 -> Foo (Not (Not b1)); Actual type: Foo b1 -> Foo b1; * In the expression: id :: Foo b -> Foo (Not (Not b))
15:48:09 <hpc> % :t id :: Foo 'False -> Foo (Not (Not 'False))
15:48:09 <yahb> hpc: Foo 'False -> Foo 'False
15:48:14 <hpc> oh, that's what it was
15:48:37 <MarcelineVQ> type family Not describes what we do with 'True or 'False, it doesn't say what we do with Not, so we need to know what b is, iiuc
15:48:45 <sarahzrf> yeah
15:48:47 <orzo> what if Not had a 3rd case Not (Not b) = b
15:49:09 <sarahzrf> orzo: i kinda wondered what would happen if i tried that lol
15:49:13 <sarahzrf> so i did it with a custom type
15:49:32 <sarahzrf> and i got this error: ghc: panic! (the 'impossible' happened)   (GHC version 8.0.2 for x86_64-unknown-linux): isInjectiveTyCon sees a TcTyCon Opponent
15:49:44 <hpc> nice
15:49:55 <orzo> 8.0.2 is old
15:49:56 <hpc> see if that panics on latest ghc
15:50:05 <sarahzrf> go see for yourself :þ
15:50:11 <hpc> heh
15:51:51 <jle`> sarahzrf: you can use a typechecker plugin
15:52:01 <jle`> or you can manually bring in a proof
15:52:05 <sarahzrf> ehhhh i dont feel like going that far heh
15:52:15 <sarahzrf> also this is in a type family so i dont think bringing in a proof is an option
15:52:16 <jle`> the lightest way would probably just bring in a proof specifically
15:52:17 <sarahzrf> not sure
15:52:19 <MarcelineVQ> orzo: how do you write that?
15:52:37 <jle`> notNot :: Sing a -> (a :~: Not (Not a))
15:52:41 <jle`> notNot SFalse = Refl
15:52:44 <jle`> notNot STrue = Refl
15:52:45 <orzo> Illegal type synonym family application in instance
15:53:05 <sm[m]> Hi all. I want to deprecate a package on hackage.. what are some standard things to do ? One final release with updated README/CHANGES ? Should I mess with deps to make it uninstallable ?
15:53:20 <jle`> orzo: you can use an explicit type nanotation, like (:: ...)
15:53:22 <jle`> or type applications
15:53:30 <MarcelineVQ> sm[m]: as in unable to be installed? nah
15:53:36 <sarahzrf> jle`: was that meant @ me?
15:53:48 <jle`> sm[m]: make sure to deprecate it on hackage :)
15:53:53 <sarahzrf> cuz i just figured out the explicit annotation :V
15:53:53 <jle`> sarahzrf: the notNot was meant for you :)
15:54:17 <jle`> the thing is that ghc knows that a ~ Not (Not a) for any specific 'a'
15:54:24 <jle`> but it can't go from that to proving that it is true for "all" a
15:54:32 <sarahzrf> oh trust me i know all about that :V
15:54:36 <sm[m]> jle` yes but how would you do that ?
15:54:40 <orzo> MarcelineVQ: how do i write what?  Are you asking about the chain of arrows thing?  I have a type family Fun xs r which expands the argument list and return value.  See my paste, https://paste.ee/p/MzyPs
15:54:40 <jle`> writing the proof notNot gives it that ability
15:54:46 <jle`> since you explicitly handle every 'a' in notNot
15:54:48 <sarahzrf> i have coq experience
15:54:49 <jle`> sm[m]: there is a button
15:55:01 <sm[m]> Aha, thanks
15:55:03 <MarcelineVQ> no how do you add Not (Not b) to the type family
15:55:16 <MarcelineVQ> *Not (Not b) = b
15:55:26 <sm[m]> Though the last release is still usable, so maybe I just leave it.. we’ll see
15:55:28 <orzo> oh, yeah, i try tried and got "Illegal type synonym family application in instance", so i dont know
15:55:29 <jle`> you cannot at the moment
15:55:48 <jle`> sm[m]: it's under "edit package information"
15:56:42 <jle`> sarahzrf: barring a type checker plugin i'd probably use an explicit proof like notNot
15:56:59 <sarahzrf> i dont think u can do that in a type family
15:57:10 <jle`> you can even write notNot to not require the singleton with unsafeCoerce Refl, but that depends on how confident you are that a ~ Not (Not a) :)
15:57:22 <jle`> sarahzrf: oh, you mean you are trying to *define* a type family?
15:57:28 <sarahzrf> type family Neg (g :: Game p) :: Game (Opponent p) where
15:57:29 <jle`> and not a normal value level function?
15:57:50 <jle`> ah okay.  where do you need a ~ not (not a), then?
15:59:05 <sarahzrf> technically i need de morgan duality, & for a custom type rather than bools, but i asked the q i did bc i figured the answer would apply equivalently, and if it didnt, id be able to rewrite my code to need not not instead
15:59:25 <jle`> how you bring it about will probably depend on the situation you are using it in
15:59:31 <jle`> maybe you can show a simple self-contained example?
15:59:38 <sarahzrf> well, rn im going to try matching on p
15:59:48 <sarahzrf> this may turn out to be more trouble than its worth
16:00:36 <jle`> i've gotten stuck before in places somewhat near where you are approaching
16:00:44 <sarahzrf> meh
16:00:49 <sarahzrf> maybe ill just give up and switch to idris :]
16:01:22 <sarahzrf> somewhere edwin brady is rubbing his hands together
16:03:12 <sarahzrf> ...okay, adding cases worked fine
16:03:14 <sarahzrf> huh
16:03:16 <sarahzrf> nice!
16:04:50 <jle`> :D
16:04:52 <sarahzrf> verbose, though
16:06:00 <sarahzrf> i *never* would have expected this to work https://benzrf.com/uploads/2271143cea51b23f.png
16:07:24 <sarahzrf> i 100% wouldve guessed that it wouldve spat an error about how i cant assume it's such a specific kind
16:07:32 <sarahzrf> but i guess it interprets it as a constraint on the clause!
16:07:44 <sarahzrf> bizarre
16:12:06 <Lears> MarcelineVQ, orzo, sarahzrf: https://gist.github.com/LSLeary/bba0aa6bdd1515513f21aa707deb4144
16:13:31 <sarahzrf> ._.
16:17:38 <freeman42x> say you have 2 (or more) randomly generated functions. what properties could you test for them? in addition to: fmap (f . g) xs === fmap f (fmap g xs)
16:22:09 <jle`> you could test if they form an isomorphism?
16:22:16 <jle`> if f . g == g . f
16:22:22 <jle`> er, i mean, if f . g == id
16:22:48 <jle`> testing fmap (f . g) sounds more like testing properties of fmap
16:22:52 <sarahzrf> and g . f = id
16:23:08 <sarahzrf> o/w ur only testing if they form a split epi/mono pair
16:23:26 <jle`> or are you asking, what properties should *all* functions follow?
16:23:53 <zeta_0> how do i set the `\` character in haskell, xmonad is throwing an error when i am trying to set: M-\ and M-shift-\
16:23:56 <zeta_0> ?
16:24:00 <jle`> if so, that might be a bit of a boring question since i don't think there is anything that isn't already enforced by the type system
16:24:37 <jle`> maybe all functions should obey `x == y => f x == f y`, to test if you used unsafePerformIO correctly
16:24:49 <jle`> s/correctly/incorrectly
16:25:25 <sarahzrf> zeta_0: double backslash, probably
16:25:52 <zeta_0> sarahzrf: thanks
16:26:21 <sarahzrf> o:
16:27:37 <jle`> bullseye
16:45:00 <turab> I was thinking about trying Polysemy but I ended up learning about freer-simple and fused-effects. How often are these two libraries used instead of mtl?
16:51:26 <freeman42x> jle`, this might be a good property tot test: x == y => f x == f y
16:51:57 <wildtrees> is there anyway I can get this fire for all monads something something = let x = "error message" in fail (trace x x) ? or how do I get some error message out of a monad fail without rewriting everything to have IO?
16:51:59 <freeman42x> jle`, I was considering testing that f composed with inverse of f = id, but to test that I would need a hedgehog-fn generator that generates only bijective functions
16:52:05 <freeman42x> any idea if this is possible?
16:57:13 <crestfallen> hello I made numerous attempts to get traceShow to work on this program; including within seqA and getChars' .. and using main (the main function listed here also fails) thanks for any guidance; generally I don't understand how to use traceShow.   https://paste.ee/p/M0jyy
17:00:38 <crestfallen> I did ' seqA (x:xs) | traceShow (x) False = undefined '   and also   ' seqA (x:xs) | traceShow (x:xs) False = undefined '
17:01:07 <crestfallen> and then moved to getChars' without success
17:02:55 <crestfallen> so I guess I'll ask is it possible to do a trace on IO return values
17:03:01 <crestfallen> at all?
17:10:33 <freeman42x> crestfallen, what do you mean by "IO return values" ? like strings read from input?
17:11:15 <crestfallen> yes thanks freeman42x this returns a string
17:11:28 <EvanR> traceShowIO :: Show a => IO a -> IO a, it's even easier to write than a non-IO trace
17:12:27 <crestfallen> just have a second type signature?
17:14:10 <MarcelineVQ> he's showing you a different function called traceShowIO
17:15:38 <dmwit> What went wrong with `seqA (x:xs) | traceShow x False = undefined`?
17:15:50 <freeman42x> asked on SO: https://stackoverflow.com/q/57532363/750216
17:16:22 <crestfallen> dmwit looking at error ...
17:17:35 <jle`> crestfallen: you can think of `traceShow w x` as attaching a sort of runtime flag to x, for the runtime system to use
17:17:44 <dmwit> ?tell wildtrees You can `let x = "error message" in trace x (fail x)`. But don't. Instead, toss an `ExceptT` on top and use a proper structured error type.
17:17:44 <lambdabot> Consider it noted.
17:17:49 <jle`> crestfallen: whenever the runtime system inspects x, it then knows to emit 'w' as well when it does so
17:18:03 <jle`> traceShow doesn't actually print anything to the screen
17:18:19 <jle`> it's just like attaching a little note for the runtime system to use whenever it tries to touch 'x'
17:18:21 <freeman42x> is there a name for this mathematical property? x == y => f x == f y
17:18:30 <crestfallen> Could not deduce (Show (f a)) arising from a use of 'traceShow' from the context: Applicative f '
17:18:38 <crestfallen> dmwit: ^
17:18:40 <jle`> that means that there is no instance of Show for (f a)
17:18:44 <dmwit> freeman42x: Leibniz equality
17:18:56 <dmwit> crestfallen: What happens when you follow the advice in the error for fixing this problem?
17:20:56 <crestfallen> there's no advice that I can ascertain anyway
17:21:26 <freeman42x> dmwit, seems it might also be called being `congruent on equality`
17:24:26 <crestfallen> dmwit Is it the False that is causing the error?
17:25:02 <dmwit> crestfallen: There is no sentence starting "Probable fix: ..."?
17:26:12 <dmwit> No, I see there is not.
17:26:14 <crestfallen> no . it's isolating In a stmt of a pattern guard for an equation for 'seqA': ' traceShow (x) False '   
17:26:16 <dmwit> I wonder when that changed.
17:26:28 <dmwit> Anyway, try adding `Show (f a)` to the context of the type signature.
17:26:47 <crestfallen> I don't know tbh I can use the error messages to my advantage only rarely.
17:26:53 <crestfallen> I haven't gotten there yet
17:27:10 <crestfallen> ok
17:27:28 <dmwit> (Of course, then you'll get a more enlightening error.)
17:27:41 <jle`> crestfallen: "cannot deduce SomeClass SomeType" usually can be fixed by adding SOmeClass SomeType => ... as a cosntraint
17:28:03 <crestfallen> youre talking about the type signature for seqA 
17:28:07 <jle`> @let myFunc :: a -> a -> Bool; myFunc x y = x == y
17:28:09 <lambdabot>  .L.hs:167:14: error:
17:28:09 <lambdabot>      • No instance for (Eq a) arising from a use of ‘==’
17:28:09 <lambdabot>        Possible fix:
17:28:16 <jle`> @let myFunc :: Eq a => a -> a -> Bool; myFunc x y = x == y
17:28:18 <lambdabot>  Defined.
17:28:21 <jle`> hm, that was a different wording, i wonder why
17:28:35 <jle`> maybe it's a ghc version thing?
17:29:10 <jle`> oh, maybe i'm mixing things up
17:31:53 <dmwit> ?let myFunc :: Show a => a -> a -> Bool; myFunc = (==)
17:31:55 <lambdabot>  .L.hs:165:1: error:
17:31:55 <lambdabot>      Duplicate type signatures for ‘myFunc’
17:31:55 <lambdabot>      at .L.hs:163:1-6
17:32:12 <dmwit> ?let dmwit'sFunc :: Show a => a -> a -> Bool; dmwit'sFunc = (==)
17:32:14 <lambdabot>  .L.hs:166:15: error:
17:32:14 <lambdabot>      • Could not deduce (Eq a) arising from a use of ‘==’
17:32:14 <lambdabot>        from the context: Show a
17:32:25 <dmwit> ?more
17:32:34 <dmwit> =(
17:32:50 <oats> how frowned upon would it be to stick some IORefs in the State of a `ReaderT State IO`?
17:33:16 <oats> since that effectively introduces "global mutable variables" to anything of this type
17:33:36 <jle`> it's a common pattern
17:33:42 <oats> oh is it?
17:33:42 <jle`> but the weird thing is calling it State
17:34:01 <jle`> not only does it shadow a popular type's name, it's also...not really state
17:34:21 <jle`> but yeah, ReaderT (IORef X) is a common pattern
17:34:23 <oats> eh, it's not called "State" in the thing I'm working on. Just seemed like a good general descriptor
17:35:02 <oats> in my toy IRC bot, it stores a handle to the bot's socket and configuration
17:35:34 <jle`> that handle doesn't sound like it should need to be an in IORef
17:35:44 <jle`> but the configuration could plausibly be so, if it changes over the runtime
17:35:55 <crestfallen> brutal
17:36:18 <freeman42x> how can multiple assertions be done in hedgehog? for example, how to check that x === y AND f x === f y both hold?
17:36:32 <jle`> freeman42x: i think hedgehog assertions are monadic, so you can just use >>
17:36:40 <jle`> or separate lines in do notation
17:37:18 <jle`> but also i think that's different than what were are talking about before
17:37:42 <jle`> (x == y) ==> (f x == f y) is not the same as (x == y) && (f x == f y)
17:40:45 <crucify_me> << crestfallen has changed their nick to
17:50:08 <freeman42x> what can I use here for arguments? https://i.imgur.com/sTIArmE.png I tried: Gen.bool Gen.bool but that does not work
17:50:29 <crestfallen> dmwit: and others  please take another look : lines 9 and 14.  https://paste.ee/p/36c76
17:50:37 <jle`> freeman42x: what do you mean by "does not work"?
17:51:04 <freeman42x> jle`, for Haskell, does not work usually means: it does not type check
17:51:38 <jle`> what's the error?
17:54:15 <dmwit> freeman42x: Why have you written this property? It's literally not possible to distinguish in Haskell between `f a` and `f b`. That is the meaning of referential transparency: the referent (the `b` in `f b`) may be replaced with the referred-to thing (`a`) without changing the meaning of the term.
17:56:26 <crestfallen> any help I'm at wit's end
17:57:19 <freeman42x> dmwit, that's true, but the same thing applies in math. so then what is the point of the congruence of equality rule?
17:57:30 <jle`> freeman42x: you have to generate two different x and y
17:57:36 <jle`> and proceed if they are equal
17:57:52 <crestfallen> I changed the constraint in seqA to (Applicative f, Show (f a)) =>    and getChars' signature to getChars' :: Int -> ShowIO String   
17:58:49 <freeman42x> jle`, but that's exactly functionally equivalent to what I am doing
17:59:00 <jle`> that's different than what's going here
17:59:07 <jle`> in ghc this is a lexical substitution
18:00:05 <freeman42x> I know, but they are functionally equivalent. so why does it matter how you obtain the same value twice?
18:00:42 <jle`> it depends on what you are trying to test
18:00:57 <jle`> because ghc literally reduces what you wrote to f x == f x
18:01:12 <jle`> let y = x in ... is reduced to substituting y for x
18:01:26 <jle`> even as it compiles, sometimes
18:01:54 <jle`> ghc sees let y = x in f x === f y, and compiles that to f x === f x
18:02:13 <jle`> but if you pick two different values, then we ahve two different 'thunks', they exist in different locations at the runtime
18:02:59 <MarcelineVQ> crestfallen: and then what happened?
18:02:59 <jle`> and there many ways that (x == y) ==> (f x == f y) could potentially fail
18:03:07 <freeman42x> jle`, I am aware of what you explained but those thunks have the same value, so the code is functionally equivalent
18:03:14 <freeman42x> jle`, anyway, this is the error: https://i.imgur.com/JoVd14Y.png
18:03:25 <jle`> there are many ways that (x == y) ==> (f x == f y) could fail, where (f x === f x) could not
18:03:37 <freeman42x> but for curiosity, how would I filter out values for when (x === y) ?
18:03:42 <jle`> for instance, the type of x and y could have an Eq instance that does an abstract equality
18:03:57 <jle`> for example, they could be a tuple type where == only compares the first value, like Arg from Data.Semigroup
18:04:31 <jle`> then in that case, f x == f y would fail if f is \(Arg _ z) -> z
18:04:44 <jle`> another case would be if f used unsafePerformIO, or was otherwise impure
18:05:00 <dmwit> I don't understand what you're trying to accomplish with hedgehog in the first place. "How would I test two arbitrary functions" is such a weird question to me. Like... to what end? Usually when I sit down to write some tests I have a goal in mind, some *thing* that I want to behave in a certain way. But you don't... appear to have a behavior you care about? IDGI
18:05:03 <jle`> if f used unsafePerformIO, then given the same input, it could produce two different results
18:05:20 <jle`> dmwit: i think this is more of way to practice how the functions in the library typecheck and fit together
18:05:53 <jle`> freeman42x: so, if f used unsafePerformIO, then f x === f x would not catch this, since they could potentailly be CSE'd together
18:06:04 <jle`> and refer to the same value in memory
18:06:05 <oats> could someone remind me why unsafePerformIO exists again?
18:06:22 <jle`> oats: low-level tools for FFI and stuff like that
18:06:39 <oats> ah. so you have to promise that the foreign functions are pure
18:06:43 <dmwit> right
18:06:48 <jle`> for example, if you used a C library for adding Double's, you would use an FFI call to add the doubles in IO, and then wrap it in unsafePErformIO before returning it to your user
18:07:11 <jle`> right, it's a function that breaks the guaruntees of haskell, but is useful for low-level implementations
18:07:27 <jle`> freeman42x: you can check if x == y first, and then pure ()-out (auto-success) if they are not equal
18:07:50 <jle`> since p ==> q is (not p) || q
18:08:22 <dmwit> It's probably better to write a generator function which takes x and produces a random y such that x === y.
18:08:39 <dmwit> Otherwise for most types you'll pure ()-out except in vanishingly unlikely situations.
18:10:02 <freeman42x> jle`, I get your point now, thank you for the examples
18:10:13 <dmwit> (Q: How do I write such a generator function? A: It depends on how (==) is implemented for the type you're trying to do this for. You'll need to inspect that implementation, then think hard.)
18:10:17 <crestfallen> MarcelineVQ: what happened was that people continually stood by and watched me squirm 
18:10:21 <freeman42x> jle`, how would what you described work in the code though?
18:11:05 <freeman42x> dmwit, "think hard" best advice! :D
18:11:07 <dmwit> crestfallen: You can't show IO actions. If you want to see how seqA proceeds, you will need to use an Applicative that can be shown.
18:12:21 <dmwit> For example, ZipList or Maybe.
18:12:25 <MarcelineVQ> I'm a sking what error you got or what problem you're having now, since you're at your wits end you must be having one. If you think the free time people have poured into you in here has been in order to watch you squirm then go squirm somewhere else.
18:12:32 <oats> 'pure' seems like a really unintuitively-named function
18:12:46 <dmwit> better than return...
18:12:58 <oats> return *almost* makes sense to me
18:13:19 <oats> especially since it's often used last in do-notation
18:13:23 <dmwit> pure embeds the pure language into the impure DSL you're currently using
18:13:50 <MarcelineVQ> People are hoping you work on a given step and understand it instead of just asking for the next step, that's teaching, if you think that's squirming then you're not going to get it.
18:15:22 <dmwit> (Yes, yes, we all know: everything in Haskell is pure. Nevertheless "impure" is a convenient shorthand for "this pure computation that models an impure one in an effective way".)
18:16:09 <crestfallen> dmwit that is helpful :  "this pure computation that models an impure one in an effective way"
18:58:51 <jackdk> I found pure a much more helpful name than return, because I didn't have to reject all the mental baggage "return" brought over from imperative languages
18:59:38 <jackdk> jle`: you can foreign import functions with a pure signature, btw
19:30:55 <oats> that is true, 'return' would be confusing for newcomers from languages where that's a keyword
19:31:40 <oats> if I were making haskell from scratch, I'd be tempted to call it 'wrap'
19:36:07 <jackdk> personally, I have thought pure was fine from the moment I first saw it.
19:38:21 <oats> whatever boats your goat ¯\_(ツ)_/¯
19:47:55 <MarcelineVQ> I'd have called it pfah
19:49:18 <MarcelineVQ> since there's really no connotations to be burdened with. no idea returning rom a statement, no mind-clouding with the echos of impure, just a little noise, pfah
19:51:20 <MarcelineVQ> it's an onomatopoeia for a fart, but we'll keep that between us, wouldn't want to introduce code smell
19:52:27 <oats>  lol, that's great
19:55:48 <dmitri> Hi folks, any help with these errors: https://gist.github.com/dmitriz/962093f13ca2b556d432a01f1813c65d
19:56:55 <heatsink> What is f?
19:58:04 * dmwit bets on bottom
19:58:23 <dmwit> Hm.
19:58:27 <dmwit> > 3 :: Complex Double
19:58:30 <lambdabot>  3.0 :+ 0.0
19:58:35 <dmwit> > pure 3 :: Complex Double
19:58:37 <lambdabot>  3.0 :+ 3.0
19:58:45 <dmwit> Okay, I want to place a new bet on pure instead of bottom.
19:58:48 <oats> huh, Complex is applicative
20:00:42 <dmwit> Anyway, the help is to follow the advice in the "probable fix".
20:18:54 <jle`> oats: pure is a bit weird in haskell convention because usually in haskell we name functions based on what they return, not what they take
20:19:00 <jle`> fromPure would be more consistent I think
20:19:33 <jle`> even though i don't like the conflation if pure/impure with all Applicative in general
20:23:02 <[Leary]> I don't think we need to avoid connotations. Is there anything wrong with "embed"?
20:24:34 <[Leary]> Are there sane Applicatives for which pure is not injective?
20:25:14 <[Leary]> Well, I'm stretching "sane". Something like Proxy obviously won't have an injective pure.
20:27:08 <heatsink> > (pure 1 :: Const [] Int) == (pure 2 :: Const [] Int)
20:27:11 <lambdabot>  error:
20:27:11 <lambdabot>      • Expecting one more argument to ‘[]’
20:27:11 <lambdabot>        Expected a type, but ‘[]’ has kind ‘* -> *’
20:27:20 <heatsink> > (pure 1 :: Const [Int] Int) == (pure 2 :: Const [Int] Int)
20:27:24 <lambdabot>  True
20:30:26 <[Leary]> `Const a` is an example, but it's "something like Proxy" in that the tyvar is phantom. I'd be interested in a non-phantom example, or an argument that it's not possible.
20:32:03 <heatsink> If you can retrieve the `x` from `pure x`, which is often the case, pure would have to be injective
20:33:31 <jle`> embed isn't too bad i think, or even lift or lift0
20:33:53 <jle`> since we already have liftA2, liftA3 ... pure would be liftA0
20:35:38 <MarcelineVQ> might as well drop the A's, that way murphy can come around and discover a new abstraction hidden between things that'll need the A's
20:36:56 <jle`> yeah, drop the A's, who needs 'em
20:37:07 <jle`> but also we have a problem because 'lift' has been taken by MonadTrans
20:38:18 <MarcelineVQ> np, just add function overloading and resolve it by type
20:38:59 <MarcelineVQ> we'll call it OverloadedHaskell as a little joke
20:39:13 <MarcelineVQ> No one will suspect it was on purpose
21:38:48 <eacameron> haskell-src-meta is a thing, but is it still the best way?
22:24:04 <dmwit> jle`: That's not a problem, because we won't be squatting on lift. Only lift0, lift1, lift2, ...
22:25:39 <dmwit> (lift1 is fmap, of course)
23:08:57 * hackage cuckoo 0.1.0.0 - Haskell Implementation of Cuckoo Filters  https://hackage.haskell.org/package/cuckoo-0.1.0.0 (larsk)
