00:00:28 <freeman42y> dmwit, cheers
00:32:24 <lavalike> @pl \fs xs -> sequence fs <$> xs
00:32:24 <lambdabot> (<$>) . sequence
00:32:35 <lavalike> does this have another common representation
00:34:22 <sclv> ?ty (<$>) . sequence
00:34:24 <lambdabot> (Traversable t, Functor f) => t (a1 -> a2) -> f a1 -> f (t a2)
00:34:31 <sclv> ?ty (<$>) . sequence
00:34:33 <lambdabot> (Traversable t, Functor f) => t (a1 -> a2) -> f a1 -> f (t a2)
00:36:22 <sclv> ?ty fmap . traverse ($)
00:36:24 <lambdabot> (Traversable t, Functor f) => t (a -> b) -> f a -> f (t b)
00:36:33 <sclv> that looks a bit more standard :-)
00:36:57 <lavalike> idk (:
00:37:13 * hackage gogol-core 0.5.0 - Core data types and functionality for Gogol libraries.  https://hackage.haskell.org/package/gogol-core-0.5.0 (BrendanHay)
00:38:13 <hackage> ACTION gogol-spectrum 0.5.0, gogol-apps-reseller 0.5.0, gogol-dlp 0.5.0, gogol-driveactivity 0.5.0, gogol-appengine 0.5.0, gogol-android-publisher 0.5.0, gogol-adexchange-seller 0.5.0, gogol-pubsub 0.5.0, gogol-cloudscheduler 0.5.0, gogol-sqladmin 0.5.0, gogol-iap 0.5.0, gogol-servicecontrol 0.5.0, gogol-adexchangebuyer2 0.5.0, gogol-blogger 0.5.0, gogol-analytics 0.5.0, gogol-tracing 0.5.0, gogol-androiddeviceprovisioning 0.5.0, gogol-games-configurat
00:38:33 <lavalike> that's a lot of gogols
00:39:13 <hackage> ACTION gogol-classroom 0.5.0, gogol-plus-domains 0.5.0, gogol-clouderrorreporting 0.5.0, gogol-civicinfo 0.5.0, gogol-dataflow 0.5.0, gogol-firestore 0.5.0, gogol-resourcemanager 0.5.0, gogol-cloudfunctions 0.5.0, gogol-analyticsreporting 0.5.0, gogol-dialogflow 0.5.0, gogol-bigtableadmin 0.5.0, gogol-adsense-host 0.5.0, gogol-docs 0.5.0, gogol-containerbuilder 0.5.0, gogol-bigquery 0.5.0, gogol-containeranalysis 0.5.0, gogol-play-moviespartner 0.5.0, 
00:39:26 <lavalike> …and it was just the beginning!
00:40:13 <hackage> ACTION gogol-file 0.5.0, gogol-cloudshell 0.5.0, gogol-sourcerepo 0.5.0, gogol-jobs 0.5.0, gogol-playcustomapp 0.5.0, gogol-container 0.5.0, gogol-tagmanager 0.5.0, gogol-billing 0.5.0, gogol-apps-activity 0.5.0, gogol-surveys 0.5.0, gogol-streetviewpublish 0.5.0, gogol-healthcare 0.5.0, gogol-slides 0.5.0, gogol-storage-transfer 0.5.0, gogol-testing 0.5.0, gogol-speech 0.5.0, gogol-debugger 0.5.0, gogol-safebrowsing 0.5.0, gogol-partners 0.5.0, gogol-
00:41:13 <hackage> ACTION gogol-iamcredentials 0.5.0, gogol-cloudtrace 0.5.0, gogol-adexperiencereport 0.5.0, gogol-datafusion 0.5.0, gogol-dns 0.5.0, gogol-identity-toolkit 0.5.0, gogol-accessapproval 0.5.0, gogol-deploymentmanager 0.5.0, gogol-genomics 0.5.0, gogol-admin-directory 0.5.0, gogol-doubleclick-bids 0.5.0, gogol-dfareporting 0.5.0, gogol-discovery 0.5.0, gogol-manufacturers 0.5.0, gogol-cloudprivatecatalog 0.5.0, gogol-bigquerydatatransfer 0.5.0, gogol-pages
00:41:39 <lavalike> I'm overgogoled
00:41:57 <dminuoso> That's gogoltastic.
00:42:13 <hackage> ACTION gogol-books 0.5.0, gogol-toolresults 0.5.0, gogol-oslogin 0.5.0, gogol-searchconsole 0.5.0, gogol-serviceusage 0.5.0, gogol-adexchange-buyer 0.5.0, gogol-acceleratedmobilepageurl 0.5.0, gogol-people 0.5.0, gogol-games-management 0.5.0, gogol-customsearch 0.5.0, gogol-groups-migration 0.5.0, gogol-siteverification 0.5.0, gogol-ml 0.5.0, gogol-sheets 0.5.0, gogol-script 0.5.0, gogol-fusiontables 0.5.0, gogol-logging 0.5.0, gogol-compute 0.5.0, gog
00:42:16 <dminuoso> Curiously there is no gogol-gogol.
00:43:18 <lavalike> but there are in fact gogol-x for all other words x apparently
00:51:14 <jgt> Gogol Morning to you all
00:51:41 <dminuoso> lavalike: Know what's still missing?
00:51:45 <dminuoso> The gogol-haskell-compiler
00:53:02 <lavalike> we'll never know
01:50:55 <tdammers> dminuoso: gogol-gogol doesn't exist, but you can easily gain it by specializing the a-a package to gogol
01:51:46 <dminuoso> tdammers: polymorphic cabal is a thing already?!
01:53:12 <tdammers> dminuoso: dream on
02:12:05 <zzz> is it me or has haskell been gaining a lot of traction lately?
02:12:20 <merijn> zzz: It's been slowly gaining traction for over a decade ;)
02:15:30 <kuribas> a lot, or some?
02:15:49 <dminuoso> I think that'd be a very hard quantity to measure
02:16:09 <dminuoso> How do you even define that quantity in such a way that you can measure it?
02:16:23 <merijn> kuribas: Well, the number of "big companies" publically adopting it is steadily increasing, which is generally a good sign :p
02:17:00 <merijn> And even in big mission critical systems
02:17:29 <kuribas> I wonder if ghc is stable enough for mission critical systems
02:17:56 <merijn> kuribas: Why do you think Facebook is paying Simon Marlowe? ;)
02:18:17 <MarcelineVQ> to keep him quiet about all the things he saw there :>
02:18:21 <dminuoso> kuribas: Haskell enjoys fairly wide use in fintech
02:18:45 <merijn> dminuoso: Target is using it a bunch for data science and logistics
02:18:53 <dminuoso> kuribas: So I think that's a strong indicator that they consider it relevant enough to bet money on it.
02:19:10 <dminuoso> merijn: How do you know facebook is paying him? 
02:19:13 <dminuoso> Perhaps he's just a volunteer!
02:22:02 <Ariakenom> google trends on haskell https://trends.google.com/trends/explore?date=all&q=%2Fm%2F03j_q
02:23:49 <zzz> aren't there any public stats on things like ghc downloads?
02:23:51 <dminuoso> Ariakenom: The regional trends are also interesting.
02:24:58 <Ariakenom> sweden best confirmed
02:25:33 <Ariakenom> (I don't know anything about google trends. accuracy etc)
02:25:56 <merijn> Ariakenom: Sweden has some pretty big FP research groups
02:26:03 <merijn> (and companies)
02:26:33 <zzz> Ariakenom: "Hfeflflfo"
02:27:40 <zzz> interestingly enough, this was the video that introduced me to haskell back in the day https://www.youtube.com/watch?v=RqvCNb7fKsg
02:28:57 <Ariakenom> zzz: it took me a while but is that some american fake swedish?
02:29:32 <Ariakenom> merijn: do you have a list? :)
02:30:07 <zzz> it's a reference to my favourite haskell video ever
02:30:33 <Ariakenom> oh right. I've seen that one
02:32:13 * hackage reflex 0.6.2.3 - Higher-order Functional Reactive Programming  https://hackage.haskell.org/package/reflex-0.6.2.3 (abrar)
02:32:13 <davean> Ariakenom: so, that graph shows that the less technical people got on the internet? :)
02:32:42 <Ariakenom> davean: could be
02:36:37 <zzz> `swedish = intersperse "f"` — "That little trick works in most languages, and by most languages I mean most languages... including bytecode."
02:38:38 <zzz> ok sorry back to work
02:40:18 <Ariakenom> davean: comparing to "programming" supports your idea https://trends.google.com/trends/explore?date=all&q=%2Fm%2F03j_q,programming
02:40:44 <davean> Ariakenom: Yes, that curve is classic - thats the consumerisation curve.
02:41:27 <davean> Ariakenom: which is really showing that we have too noisy a background to see a signal.
02:41:33 <davean> We've lost it in the scaling
02:56:13 <absence> is it possible to create new types with ghc.generics, or is templatehaskell needed for that?
02:58:50 <merijn> absence: You need templatehaskell, but why do you need this in the first place?
03:05:23 <absence> merijn: generate types from a schema
03:20:49 <freeman[w]__> Anyone here using Emacs, Neovim or Vim could help me with setting up working Haskell plugins for them? I had no luck setting up HIE on any of them
03:23:43 <dminuoso> absence: GHC.Generics is about producing/working on data in a generic fashion. E.g. in the sense how Aeson can deserialize bytes into any ADT, and equivalently serialize them back into bytes.
03:26:07 <absence> dminuoso: right, so the types already have to exist compile-time of course. i see
03:30:33 <dminuoso> absence: Right. Their existence is what drives GHC.Generics, in fact. There's this tyfam called Rep which translates some existing data type into a different type that represents the internal structure on the type level.
03:30:54 <dminuoso> absence: And you usually use typeclasses to recurse/traverse this type structure.
03:44:29 <boxscape> If I have dependencies on packages A and B, and B depends on A, do I have to specify them both as dependencies myself in the .cabal file? (I suspect I *should*, but is it necessary?)
03:45:26 <merijn> boxscape: You do, yes
03:45:35 <boxscape> ok
03:45:55 <boxscape> thanks
03:46:01 <merijn> And you also should, because your package and B may have different constraints on A's version
03:46:14 <boxscape> ah, that makes sense
03:46:15 <dminuoso> cabal admits circular dependencies?
03:46:29 <boxscape> I don't think there's anything circular here?
03:46:57 <dminuoso> boxscape: Ah
03:57:32 <ac> hello
04:01:31 <ac> back
04:01:39 <ac> how is everyone
04:03:23 <Ariakenom> ac: good <localtimeofday> to you
04:03:42 <ac> lmao, thanks 
04:04:13 <ac> wow, there's a lot of people in here
04:04:15 <ac> hello
04:24:12 * hackage log4hs 0.1.0.0 - A python logging style log library  https://hackage.haskell.org/package/log4hs-0.1.0.0 (gqk007)
04:30:45 <thorsten`> which package (and which module) contains the EitherT monad transformer? I've found https://hackage.haskell.org/package/EitherT but it says 'Deprecated in favor of either'. 'either' refers to https://hackage.haskell.org/package/either which does not provide EitherT
04:31:20 <thorsten`> (and Validation in Data.Either.Validation provides no monad transformer)
04:31:32 <Axman6> I believe you want ExceptT these days
04:31:52 <merijn> thorsten`: You want ExceptT
04:31:56 <freeman[w]__> does anyone know of any other Haskell streamers I could add to this list? https://github.com/razvan-panda/haskell-streamers
04:32:41 <thorsten`> Axman6: merijn: Thanks a lot!
05:05:30 <jchia_1> I can't use .. notation for an Enum, can I? I suppose the closest I can get is to use enumFromTo?
05:06:07 <Ariakenom> :t \a b -> [a .. b]
05:06:09 <lambdabot> Enum a => a -> a -> [a]
05:07:16 <Ariakenom> jchia_1: you mean like that?
05:08:50 <Ariakenom> [a..b] = enumFromTo a b    just syntax sugar
05:09:34 <jchia_1> Ariakenom: I tried [A..B] but got an error about missing module. I added spaces around '..' and the error went away.
05:10:54 <Ariakenom> jchia_1: ok looks like ghc thought A was supposed to be a module
05:11:10 <jchia_1> yeah
05:11:22 <merijn> You need spaces to disambiguate sometimes
05:11:29 <merijn> But it works just fine
05:11:33 <merijn> > [False ..]
05:11:36 <lambdabot>  [False,True]
05:11:37 <merijn> > [False..]
05:11:40 <lambdabot>  <hint>:1:9: error: parse error on input ‘]’
05:11:58 <merijn> . is too overloaded :)
05:12:02 <jchia_1> > [False .. ]
05:12:04 <lambdabot>  [False,True]
05:13:19 <zzz> why is Bool Enum?
05:14:24 <lyxia> because you can enumerate them
05:15:05 <merijn> zzz: Why not?
05:15:18 <merijn> zzz: It's a finite set of tags, why wouldn't it be enumerable?
05:16:30 <zzz> question withdrawn
05:17:08 <merijn> > [minBound ..] :: Maybe Bool -- :p
05:17:10 <lambdabot>  error:
05:17:10 <lambdabot>      • Couldn't match expected type ‘Maybe Bool’ with actual type ‘[a0]’
05:17:10 <lambdabot>      • In the expression: [minBound .. ] :: Maybe Bool
05:17:17 <merijn> aww...really?
05:17:24 <merijn> What kinda nonsense is that
05:18:26 <zzz> wait what?
05:18:43 <zzz> > [minBound ..] :: [Bool] -- didn't you mean this?
05:18:45 <lambdabot>  [False,True]
05:19:21 <merijn> I was assuming Maybe was an instance of Enum and Bounded if it's argument type was, but it's not which is clearly nonsense >.>
05:19:39 <zzz> hum
05:20:33 <zzz> Nothing < Just ()
05:20:37 <zzz> > Nothing < Just ()
05:20:39 <lambdabot>  True
05:21:17 <zzz> > minBound :: Maybe a
05:21:20 <lambdabot>  error:
05:21:20 <lambdabot>      • No instance for (Bounded (Maybe a1))
05:21:20 <lambdabot>          arising from a use of ‘minBound’
05:21:25 <zzz> ah
05:22:26 <boxscape> what would maxBound be for that instance?
05:22:44 <zzz> what would you expect `succ Nothing :: Maybe Int` to be?
05:23:07 <merijn> boxscape: "Just maxBound"
05:23:42 <boxscape> > Just (minBound :: Int) -- so this would be the answer to zzz's question?
05:23:45 <lambdabot>  Just (-9223372036854775808)
05:24:01 <zzz> lol
05:24:07 <merijn> boxscape: Yeah
05:24:20 <zzz> I'm kind of glad it isn't
05:28:17 <cpressey> Hello. The docs for Control.Concurrent.MVar mention that they "are very simple and susceptible to race conditions, deadlocks or uncaught exceptions". I can see how they might deadlock or fail to catch exceptions, but I don't know what "race conditions" this refers to. Would someone here know?
05:28:19 <Ariakenom> > [minBound ..] :: [Maybe Bool]
05:28:21 <lambdabot>  error:
05:28:21 <lambdabot>      • No instance for (Enum (Maybe Bool))
05:28:21 <lambdabot>          arising from the arithmetic sequence ‘minBound .. ’
05:29:05 <lyxia> fromEnum (Just (minBound :: Int))   or   fromEnum (Just (maxBound :: Int))   would be weird
05:29:38 <boxscape> You can't really have a nice Enum instance for Maybe Int because it has one more value than Int
05:29:44 <boxscape> :t fromEnum
05:29:46 <lambdabot> Enum a => a -> Int
05:30:28 <boxscape> > minBound :: Maybe Bool
05:30:30 <lambdabot>  Nothing
05:31:49 <merijn> cpressey: If the order in which threads put/take matters you get races
05:32:24 <Ariakenom> cpressey: note that MVars themselves don't have those issues. The warning is about what a user might build.
05:35:33 <cpressey> merijn: Ariakenom: OK, that clarifies it a little. Thanks.
05:35:59 <maralorn> Hey, any tips with what lib you would write an IRC bot?
05:36:56 <maralorn> https://github.com/stepcut/ircbot seems to be the most mature on hackage, but it says it‘s not really maintained anymore and could be done better.
05:37:44 <phadej> I'd fork lambdabot :)
06:02:23 <Ferdirand> is it just me or is part of ghc's online user guide broken ?
06:02:42 <Ferdirand> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/lang.html <- looks like most (all) of the sub-pages here link to empty content ?
06:03:07 <tabaqui> fine with me
06:03:24 <merijn> Ferdirand: Works fine here?
06:03:50 <tabaqui> browser issues, probably
06:04:29 <boxscape> Ferdirand doesn't work for me either
06:05:09 <Ferdirand> ah, but it works with curl
06:05:11 <boxscape> though actually it works now after I reloaded
06:05:53 <Ferdirand> browser issue indeed
06:06:00 <Ferdirand> it works with chromium but breaks with brave
06:06:01 <bezirg> Is <planet.haskell.org> still maintained/updated? There seems to show posts in wrong data order for me.
06:06:17 <bezirg> I mean *wrong date order
06:07:22 <Ferdirand> but it works with brave if I save the page and load it afterwards
06:07:37 <tabaqui> switch on Firefox :)
06:07:43 <tabaqui> FF is the best
06:10:36 <boxscape> FF didn't work for me at first with this page
06:10:39 <Hounded> Seems ok to me on Firefox
06:11:31 <Ferdirand> but why does it affect only this specific section of the manual ?
06:12:12 <tabaqui> well, it could be a server problem at specific time
06:12:20 <tabaqui> considering boxscape's case
06:12:32 <Ferdirand> ok, wtf, it's working now
06:13:19 <Ferdirand> ah, could be caused by the inclusion of mathjax from a third-party domain maybe
06:14:21 <boxscape> maybe the browser console would've shown errors
06:14:24 <boxscape> but I guess it
06:14:28 <boxscape> 's too late now
06:15:20 <Ferdirand> i disabled the privacy blocking, and it started working, and now it keeps working even with the privacy block reenabled
06:15:23 <Ferdirand> strange
06:16:56 <boxscape> Oh I just found out that ghc has hexadecimal floating point literals, that's not something you see every day
06:17:01 <boxscape> or in every compiler
06:17:07 <boxscape> or even the windows calculator
06:18:15 <merijn> boxscape: It's part of IEEE-754
06:18:26 <boxscape> interesting
06:18:44 <merijn> boxscape: It's because converting to decimal means you can't losslessly serialise floats
06:18:50 <merijn> boxscape: Since almost all pretty printers rounds
06:19:05 <boxscape> it always annoys me when people just disable non-integers just because it's not decimal
06:19:14 <merijn> The hex float notation is guaranteed to give the exact float (like, bit-for-bit) when read back in
06:19:20 <boxscape> that makes sense
06:19:37 <merijn> Including NaNs (there's multiple ones!) and infinity
06:19:46 <tabaqui> % print 0xa.0
06:19:46 <yahb> tabaqui: ; <interactive>:67:1: error:; * Couldn't match expected type `b0 -> c' with actual type `IO ()'; * Possible cause: `print' is applied to too many arguments; In the first argument of `(.)', namely `print 0xa'; In the expression: print 0xa . 0; In an equation for `it': it = print 0xa . 0; * Relevant bindings include it :: a -> c (bound at <interactive>:67:1)
06:20:00 <tabaqui> % print 0x5p1
06:20:00 <yahb> tabaqui: ; <interactive>:68:10: error:; * Variable not in scope: p1; * Perhaps you meant one of these: `pi' (imported from Prelude), `_1' (imported from Control.Lens)
06:20:03 <merijn> tabaqui: They're a GHC extension for not
06:20:06 <merijn> s/not/now
06:20:07 <boxscape> > print 1_000
06:20:10 <lambdabot>  <hint>:1:7: error:
06:20:10 <lambdabot>      Use NumericUnderscores to allow underscores in integer literals
06:20:12 <merijn> Since they're not in the report
06:20:24 <boxscape> lambdabots need more extensions enabled :(
06:23:51 <tabaqui> still cannot see hexadecimal floats
06:24:18 <boxscape> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-HexFloatLiterals
06:24:39 <tabaqui> oh, I was looking at wrong ext
06:24:42 <tabaqui> thanks
06:25:23 <tabaqui> wow, it is cool, really
06:30:13 <ski> boxscape : "it always annoys me when people just disable non-integers just because it's not decimal" -- yes
06:31:13 <ski> % :set -XHexFloatLiterals
06:31:13 <yahb> ski: 
06:31:18 <ski> % print 0xa.0
06:31:18 <yahb> ski: 10.0
06:31:20 <ski> % print 0x5p1
06:31:20 <yahb> ski: 10.0
06:31:54 <boxscape> oh good to know that you can enable exts with yahb
06:34:19 <boxscape> % :q
06:34:20 <yahb> boxscape: 
06:34:23 <boxscape> hmm
06:39:19 <boxscape> % listDirectory "../bin"
06:39:19 <yahb> boxscape: ["mv","md5sum.textutils","ln","echo","dircolors","whoami","uname","base64","pathchk","expand","luac5.0","nl","sh","luac5.1","sum","comm","dd","tsort","link","cut","tac","stty","env","chmod","chgrp","printenv","seq","basename","ls","luac","sort","df","du","md5sum","numfmt","luac4.0","rm","sha512sum","nproc","pwd","realpath","tail","factor","false","csplit","lua5.0","who","[","chcon","lua5.2","pr","
06:39:53 <lavalike> "["
06:40:08 <merijn> lavalike: That's test
06:40:31 <boxscape> % readFile "../bin/["
06:40:31 <yahb> boxscape: "\DELELF\STX\SOH\SOH\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\STX\NUL>\NUL\SOH\NUL\NUL\NUL*** Exception: ../bin/[: hGetContents: invalid argument (invalid byte sequence)
06:40:32 <tabaqui> :% listDirectory "../../../../../../etc/passwd"
06:40:37 <tabaqui> % listDirectory "../../../../../../etc/passwd"
06:40:37 <yahb> tabaqui: *** Exception: ../../../../../../etc/passwd: getDirectoryContents:openDirStream: does not exist (No such file or directory)
06:40:37 <lavalike> I was wondering is there the equivalent of NAND for binary logic for compuation? SKI is 3, 2 I guess, is there a single combinator that's universal for predicate logic?
06:40:53 <merijn> tabaqui: Please use private message for failing to break yahb :)
06:40:59 <boxscape> How can there be an invalid byte sequence?
06:41:08 <tabaqui> merijn: already doing :)
06:41:22 <merijn> boxscape: Because readFile returns String which is text which is implicitly decoded
06:42:44 <boxscape> Hmm okay, I guess I would've just expected all byte sequences to correspond to characters somehow. Like, when you open a binary file in an editor, it typically doesn't complain about invalid byte sequences
06:43:29 <merijn> boxscape: No, not all byte sequence are valid in every encoding of text
06:43:50 <boxscape> Which encoding does readFile use?
06:44:13 <merijn> boxscape: Whatever you explicitly set in the RTS and if you don't set an encoding it will base it on your locale
06:44:19 <boxscape> I see
06:50:42 * hackage apecs-gloss 0.2.3 - Simple gloss renderer for apecs  https://hackage.haskell.org/package/apecs-gloss-0.2.3 (jonascarpay)
06:53:38 <tabaqui> looks like a bug in haddock
06:53:46 <tabaqui> class Foo a where
06:54:00 <tabaqui>   type Foo a :: * -> *             -- ^ Some documentation
06:54:15 <tabaqui>   foo :: a -> a                -- ^ Some more documentation
06:54:41 <tabaqui> and haddock will fail on the second line, but not on the third
06:56:37 <boxscape> % 4 + 5
06:56:37 <yahb> boxscape: 
06:56:46 <boxscape> I think I may actually have broken yahb
06:56:47 <boxscape> tbh
06:56:51 <boxscape> % 4 + 5
06:56:51 <yahb> boxscape: 
06:57:07 <boxscape> mniip?
06:57:09 <tabaqui> good catch!
06:57:43 <boxscape> (I think I broke it by running ghci with readProcess)
06:59:57 <tabaqui> next time do not disclose details so soon
07:00:20 <tabaqui> give the maintainer time to fix it
07:00:30 <boxscape> Oh, yeah sorry
07:09:51 <Ariakenom> %kill
07:09:51 <yahb> Ariakenom: Done
07:09:57 <Ariakenom> % 5 + 4
07:09:58 <yahb> Ariakenom: 9
07:21:04 <cpressey> lavalike: Possibly Fokker's X combinator? https://codegolf.stackexchange.com/questions/154617/design-a-one-instruction-set-computer/155301#155301
08:08:57 <Guest_77> hell
08:08:59 <Guest_77> hello
08:09:12 <Guest_77> hi
08:10:32 <exarkun> trying out haddock for the first time, `stack haddock MyPackage` is crashing on some error from `basement-0.0.11`.  can I just build my own docs?
08:11:18 <monochrom> Does it crash on another package too?
08:12:10 <exarkun> not super obviously
08:12:34 <exarkun> The last line is
08:12:36 <exarkun>     Warning: 'haddock: internal error: <stdout>: commitBuffer: invalid argument (invalid character)
08:13:08 <exarkun> it seems to be making progress through a big pile of other projects if I repeatedly invoke it, but it only runs until basement
08:13:18 <exarkun> also I'm not sure why it's building basement docs when I asked for `MyPackage` docs
08:16:17 <dmwit> Guest_77: sup
08:17:35 <dmwit> % last [1..] -- perhaps we can get it to kill itself and restart
08:17:40 <yahb> dmwit: [Timed out]
08:17:43 <dmwit> % 4+5
08:17:44 <yahb> dmwit: 9
08:18:01 <dmwit> boxscape: Still, probably good to find some non-IRC way to contact mniip about this.
08:18:08 <dmwit> (It's too easy to miss messages here.)
08:18:19 <boxscape> good point
08:18:44 <dmwit> Oh, Ariakenom had already fixed it. Ariakenom++
08:22:25 <Ariakenom> dmwit: :)
08:25:12 <megatr0nz> hello, anyone familiar with compilers and llvm?
08:30:24 <tabaqui> dmwit: you can send a message either in PM or with lambdabot
08:30:35 <tabaqui> usually, one of these is enough
08:33:11 <boxscape> @query mniip
08:33:11 <lambdabot> Unknown command, try @list
08:33:14 <boxscape> whoops
08:33:17 <boxscape> wrong special symbol
08:56:13 * hackage hoogle 5.0.17.11 - Haskell API Search  https://hackage.haskell.org/package/hoogle-5.0.17.11 (NeilMitchell)
09:27:22 <warbo> hi, I'm playing with TypeApplications and noticed that when I do `0 @Int` I get an error "Cannot apply expression of type ‘p0’ to a visible type argument ‘Int’"
09:27:27 <warbo> is that expected, or a bug?
09:28:06 <warbo> (I know I can do `0 :: Int` to get the result I'm after)
09:30:52 <Ferdirand> :t 0
09:30:53 <lambdabot> Num p => p
09:32:57 <Ferdirand> % 0 @Int
09:32:57 <yahb> Ferdirand: ; <interactive>:2:1: error:; * Cannot apply expression of type `p0'; to a visible type argument `Int'; * In the expression: 0 @Int; In an equation for `it': it = 0 @Int
09:33:06 <Ferdirand> % (0 :: Num p => p) @Int
09:33:06 <yahb> Ferdirand: 0
09:33:30 <Ferdirand> could that relate to defaulting ?
09:35:45 <warbo> I've found this which might be related https://gitlab.haskell.org/ghc/ghc/issues/13060
09:35:55 <warbo> marked as closed?
09:37:58 <warbo> (the fact your explicitly annotated version worked makes me think it's the same thing, since the title mentions "inferred types")
09:38:43 * hackage dependent-sum-aeson-orphans 0.2.1.0 - JSON instances for DSum, DMap, and Some  https://hackage.haskell.org/package/dependent-sum-aeson-orphans-0.2.1.0 (abrar)
09:58:12 <lox15866> Hai
09:58:24 <lox15866> Hai
09:58:26 <lox15866> Hai
09:58:28 <lox15866> Hai
09:58:51 <lox15866> 7,949,11
09:58:55 <lox15866> La
09:58:58 <lox15866> Lll
09:59:08 <lox15866> Sanyo
09:59:11 <lox15866> G
09:59:12 <lox15866> H
09:59:13 <lox15866> K
09:59:15 <lox15866> L
09:59:26 <lavalike> @tell cpressey beautiful! thanks for the pointer to the Fokker's X combinator
09:59:26 <lambdabot> Consider it noted.
09:59:42 <lox15866> Hey?
09:59:54 <lox15866> Hey..?
10:00:11 <lox15866> *crying*
10:00:52 <lox15866> I am noob pls help
10:01:03 <lox15866> How to chat
10:01:24 <lox15866> *crying*
10:01:46 <lox15866> I am noob help plz
10:01:55 <fresheyeball> I never noticed this before
10:02:21 <fresheyeball> but `Set.insert x . Set.remove x /= Set.remove x . Set.insert x`
10:02:27 <lox15866> Help pls
10:02:35 <fresheyeball> lox15866: k
10:02:38 <[exa]> lox15866: with what?
10:02:39 <lavalike> fresheyeball: reasonable
10:02:59 <lavalike> S.insert . S.remove = S.insert
10:03:09 <lox15866> I dont know what is irc
10:03:10 <lavalike> S.remove . S.insert = S.remove
10:03:20 <fresheyeball> lavalike: that's nifty
10:03:22 <[exa]> lox15866: you are looking at one
10:03:33 <lox15866> Ha...ha....
10:03:58 <lox15866> Who know more popular channels
10:04:09 <lavalike> try #freenode
10:04:17 <lox15866> Thx
10:04:37 <lox15866> I afk there few minutes
10:05:09 <lox15866> I am Russian and my English is bad
10:05:19 <Ferdirand> going from "I don't know what is irc" to "what are the popular channels" in 1 minute, that's some pretty fast learning
10:05:34 <Ferdirand> you'd probably learn haskell pretty fast
10:05:39 <lavalike> this channel is mostly for discussion around the Haskell programming language
10:05:53 <[exa]> lox15866: anyway please keep the discussion on the channels on topic, this is mainly for haskell.
10:06:28 <lox15866> HI
10:06:56 <lavalike> failing the turing test
10:07:05 --- mode: ChanServ set +o monochrom
10:07:55 <monochrom> Based on past experience, they don't understand (or care) what "this channel is for haskell" means.
10:08:56 <lox15866> On  #freenode ch no peoples
10:09:16 <monochrom> That still doesn't mean we're obliged to help you.
10:09:32 <lox15866> How to use Irc
10:09:46 --- mode: monochrom set +b *!*@145.255.164.139
10:37:21 <fresheyeball> lavalike: so I like those as laws for delete and insert on sets
10:37:29 <fresheyeball> but how would this work for non-empty sets?
10:38:04 <fresheyeball> delete :: a -> NonEmptySet a -> Maybe (NonEmptySet a)
10:38:54 <lavalike> … -> Set a  >:)
10:39:11 <fresheyeball> with a nonempty set type
10:39:18 <fresheyeball> delete x . insert x = delete x
10:39:20 <fresheyeball> still holds
10:39:41 <fresheyeball> but insert x . delete x = insert x
10:39:50 <fresheyeball> is now a type error, and I don't see how to express it
10:40:41 <fresheyeball> maybe x insert $ delete y x = insert y x
10:40:43 <fresheyeball> ??
10:49:51 <dmwit> maybe (singleton y) insert $ delete y x = insert y x -- would be my preference
10:50:04 <dmwit> err
10:50:18 <dmwit> maybe (singleton y) (insert y) $ delete y x = insert y x
10:50:48 <dmwit> After all, there's no guarantee that (==) implies (=)
10:51:04 <dmwit> (tongue in cheek on that last sentence)
10:52:04 <dmwit> You can still go pointfree if you want: maybe (singleton x) (insert x) . delete x = insert x
10:52:15 <lavalike> ap ((.) . liftM2 maybe singleton insert) delete -- duh
10:53:33 <dmwit> delete >>= liftM2 maybe singleton insert -- possibly more readable
10:54:11 <dmwit> s/>>=/>=>/
10:55:07 <dmwit> :t \f g => ((.) . f) <*> g
10:55:09 <lambdabot> error: parse error on input ‘=>’
10:55:13 <dmwit> :t \f g -> ((.) . f) <*> g
10:55:15 <lambdabot> (a1 -> b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
10:55:44 <dmwit> :t (<=<) @((->) Int)
10:55:45 <lambdabot> error: parse error on input ‘->’
10:55:55 <dmwit> % :t (<=<) @((->) Int)
10:55:55 <yahb> dmwit: (b -> Int -> c) -> (a -> Int -> b) -> a -> Int -> c
11:12:02 <dmwit> I kind of which `count p = length . filter p` were in Prelude. It seems to come up pretty regularly for me.
11:12:08 <fendor> can I force cabal to show all current warnings?
11:12:17 <dmwit> no =(
11:13:03 <fendor> neither does stack, right?
11:13:34 <dmwit> (I see your question, but am not answering because I am not a stack expert. Perhaps somebody else will chime in.)
11:14:42 <hyperisco> What are "current" warnings?
11:15:03 <fendor> hyperisco, all warnings that I have in a project, without recompiling the whole project
11:15:14 <hyperisco> Without recompiling? I don't know.
11:15:40 <cocreature> neither stack nor cabal store warnings and GHC only shows them if you recompile
11:16:53 <fendor> is there a reason for that or is it a deliberate decision and I am the only one whose pr regurarly fail because I overlooked some warning? I mean, I can always use `-Werror` but especially during development it is a bit annoying
11:22:21 <MarcelineVQ> why does your pr fail due to a warniing without -Werror
11:23:00 <fendor> because CI executes the build with werror
11:23:43 * hackage doclayout 0.1 - A prettyprinting library for laying out text documents.  https://hackage.haskell.org/package/doclayout-0.1 (JohnMacFarlane)
11:24:48 <xenon-> hello. I am trying to scrap a webpage with anti-scraping protection using haskell bindings to selenium webdriver. if I run non-headless, everything is green in the following table. https://intoli.com/blog/not-possible-to-block-chrome-headless/chrome-headless-test.html
11:24:55 <xenon-> but if I run it headless, I get this: https://i.imgur.com/UZbQXt7.png
11:25:44 <sclv> fendor: use -Werror
11:25:48 <sclv> its supposed to be annoying
11:26:00 <sclv> annoying you into... doing the right thing!
11:26:49 <fendor> sclv, I dont have a problem that it annoys me, but I would prefer it if it would annoy me when I am preparing the actual commit, not during it. Maybe I just need to add a good pre-commit hook.
11:26:53 <cocreature> I usually have -Werror disabled in ghci and enabled outside of it. That works nicely for not pissing me off during development due to unused definitions while making sure I don’t push crap.
11:27:10 <turab> @pl \x y -> f x y a
11:27:10 <lambdabot> flip flip a . f
11:27:14 <fendor> cocreature, that makes sense and seems practical
11:27:19 <fendor> thanks!
11:27:29 <xenon-> user agent is easy to fix, but what about the rest? https://intoli.com/blog/making-chrome-headless-undetectable/ has some suggestions in python, running some javascript code, but I was not able to translate that to haskell succesfully
11:28:51 <sclv> actually lol i don't use -Werror, i just realized, just -Wall. I'm just fastidious about cleaning up warnings
11:33:07 <fendor> sclv, most warnings I have are unused import errors since I am sometimes not sure if I am gonna use that import in next second, e.g. when refactoring code.
11:44:42 * hackage postgres-options 0.1.0.0 - An Options type representing options for postgres connections  https://hackage.haskell.org/package/postgres-options-0.1.0.0 (JonathanFischoff)
11:47:18 <leshow> I'd like to experiment with pipes using a unix socket, does anyone know of a good library to use for that? I was looking at 'daemons'
11:51:01 <exarkun> When I have a record value with many fields, once of which is a data that has a list of text pairs and I want a new record value that's the same except there's an extra text pair in that list ... is this when I reach for lens?  or ...?
11:54:58 <turab> @pl \(x, y) -> f x y
11:54:58 <lambdabot> uncurry f
11:56:29 <orzo> never reach for lens
11:57:28 <orzo> just use some wonky record update syntax
11:57:39 <orzo> and *like* it
11:57:44 <sm[m]> it’ll bite ya!
12:00:36 <infinisil> exarkun: Well with lens it would just be `the_field_lens %~ (new_item :)` I think
12:01:16 <orzo> why do you mention that the record has "many" fields?
12:01:48 <orzo> the lens syntax isn't going to make it more efficient
12:01:52 <xenon-> .
12:02:53 <orzo> You could do something like Data.Dependent.Map to get logarithmic update
12:03:49 <exarkun> orzo: I was thinking more about how many keystrokes it would take
12:04:22 <exarkun> and the implementation I can think of involves typing out each field
12:04:41 <orzo> But (\x -> x { listfield = new_item : listfield x }) takes the same number of keystrokes regardless of the number of fields in the record
12:05:25 <exarkun> oh yea I forgot about that syntax.
12:05:27 <exarkun> thanks.
12:09:32 <xenon-> do executeJS [] "Object.defineProperty(navigator, 'languages', {get: function() {return ['en-US', 'en'];}, });"; openPage url   <- should executed javascript have effect on the language variable when executing openPage url?
12:09:40 <xenon-> because it doesn't
12:10:35 <xenon-> so my question really is, how do I execute some custom javascript while opening a page?
12:22:13 * hackage pickle 0.1.0.0 - Instant StatsD in Haskell  https://hackage.haskell.org/package/pickle-0.1.0.0 (Luabee)
12:33:49 <thegentleman> join #haskell-br
12:48:20 <xenon-> https://pastebin.com/y4p7zwb4   executeJS on page 23 has no effect on either line 24, when I print the same value, or when opening a page. what am I doing wrong?
12:50:13 * hackage pandoc-types 1.17.6 - Types for representing a structured document  https://hackage.haskell.org/package/pandoc-types-1.17.6 (JohnMacFarlane)
12:59:29 <fresheyeball> how can I delete all members of one set from another set?
12:59:58 <fresheyeball> {1,2,3} - {2,4} = {1,3}
13:00:57 <nil> Data.List has (\\)
13:02:18 <nil> > [1, 2, 3] \\ [2, 4]
13:02:21 <lambdabot>  [1,3]
13:03:59 <fresheyeball> oh nice
13:06:36 <xenon-> though that will be more efficient with Data.Set 
13:07:36 <xenon-> @hoogle Ord a => Set a -> Set a -> Set a
13:07:37 <lambdabot> Data.Set union :: Ord a => Set a -> Set a -> Set a
13:07:37 <lambdabot> Data.Set difference :: Ord a => Set a -> Set a -> Set a
13:07:37 <lambdabot> Data.Set (\\) :: Ord a => Set a -> Set a -> Set a
13:22:18 <koz_> xenon-: Is (\\) an escaped set-difference symbol or something?
13:22:24 <koz_> I only _just_ noticed that.
13:25:00 <xenon-> yes, \\ is the same as difference
13:25:32 <xenon-> Data.Set.\\ that is
13:25:36 <koz_> xenon-: I was more talking about the choice of name there. Set difference is designated with \, but backslashes need escaping. :P
13:26:02 <xenon-> oh. no idea what inspired the name. but you could be right
13:26:13 <koz_> I only just noticed it myself.
13:27:17 <WASD> I am using the xml library and have a function 'isItem (Elem (Element (QName elemName _ _) _ _ _)) = elemName == "item"'. It feels a bit clumsy. Disregarding there might being better ways to use the library (looking into its functions now), are the other ways to perform pattern matching suitible for such deep structures?
13:27:28 <koz_> WASD: Lenses maybe?
13:32:12 <WASD> koz_: I have a vague understanding of them, but I was suspecting that as well. I will do some reading about it. Thanks.
13:32:40 <koz_> WASD: If you've got deeply-nested stuff like that, lenses can make it much easier to work with.
13:32:46 <koz_> I can provide some links if you want.
13:32:47 <xenon-> koz_, it appears that (\) is not a valid operator name. so that could be the reason why they used (\\)
13:33:24 <koz_> xenon-: Yeah, it wouldn't surprise me, as backslashes are normally used for escaping things.
13:34:07 <MarcelineVQ> yeah lenses probably, given how nested xml can get, though you can match Elem and compose record fields to get there in in this particular case, 'isItem (Elem e) = (== "item") . qName . elName $ e
13:34:35 <koz_> MarcelineVQ: Lenses would also give you some sick tricks to do stuff like traversals, modifications, conversions (via Iso or Prism) etc.
13:34:42 <xenon-> not sure why (\) isn't legal? i can't think of any haskell syntax it would be clashing with
13:35:18 <WASD> MarcelineVQ: cool! Didn't think of that.
13:35:28 <koz_> xenon-: Does Haskell use \ as an escape character in Strings, say?
13:35:49 <xenon-> yes. but that is only legal in string literals, and operators can't be used there
13:36:01 <koz_> xenon-: Hmm, yeah, that is an interesting question.
13:36:08 <MarcelineVQ> it does and also for lambda, it's not a clash exactly but it yet another parsing thing to manage
13:36:20 <xenon-> ah, of course, lambda
13:36:31 <koz_> Yeah, not everyone has a Unicode keyboard, lol.
13:36:42 <geekosaur> clashes aren't the only possible problem. some things imply unbounded lookahead
13:36:51 <geekosaur> which is a fairly nasty thing to do to a parser
13:36:52 <MarcelineVQ> yes since you'r elooking for -> now
13:38:24 <koz_> Ah, yeah, that might be far away.
13:38:39 <koz_> Also, can someone help me figure out why this singletons TH is saying weird things to me? https://gist.github.com/kozross/8541e2c90ff1b9d71d834c60f3fb7e9d
13:40:04 <MarcelineVQ> koz_: tried turning datakinds on? no idea if that's even relevant
13:40:13 <koz_> MarcelineVQ: TypeInType should enable this already.
13:41:22 <xenon-> why is https://pastebin.com/s7weWmaj on line 27 having no effect? when I try to fetch the value back I get Null
13:41:34 <xenon-> why is executeJS on line 27, even
13:42:22 <koz_> MarcelineVQ: Tried turning on DataKinds anyway, same issue.
13:44:01 <koz_> Do I have to hand-spell these or something?
13:44:04 <geekosaur> si Natural the right thing to use there? I thought it was positive-or-zero Integer, not value level Nat as such (i..e. no mapping?_
13:44:28 <koz_> geekosaur: Demote Nat ~ Natural as far as I can tell, so I guessed that was the right thing to use?
13:44:45 <geekosaur> but you said Natural, so it's doing Demote Natural
13:44:59 <koz_> So I need to write it as 'Dim Nat'?
13:45:05 <geekosaur> I think so
13:45:10 <koz_> OK, let me try that.
13:45:27 <geekosaur> I'm still a little weak on this bit that is how I read that error
13:45:40 <koz_> Hmm, that gives a different kind of error, let me update.
13:46:26 <koz_> https://gist.github.com/kozross/8541e2c90ff1b9d71d834c60f3fb7e9d
13:46:36 <geekosaur> the other thing is I can't imagine Demote x ~ x for any x is liked by the typechecker (isn't it an infinite type?), which might be a System F restriction
13:46:45 <koz_> geekosaur: Yeah, indeed.
13:47:45 <geekosaur> oh, sigh, it can't be Nat at type level. this is a bit tricky
13:48:00 <koz_> geekosaur: I figured something like that. Do I have to hand-roll each key instance or something?
13:48:01 <geekosaur> probably beyond my current level fo tricky given the other one
13:48:29 <geekosaur> possibly. or there may be some way to do it that I don't know yet; still learning singletons and defunctionalization
13:48:42 * hackage doctemplates 0.4 - Pandoc-style document templates  https://hackage.haskell.org/package/doctemplates-0.4 (JohnMacFarlane)
13:48:59 <koz_> geekosaur: Alrighty, I'll try it and see if maybe jle` can chime in and assist.
13:49:05 * geekosaur needs to learn the New Haskell
13:49:09 <koz_> Might help me learn things anyway.
13:50:03 <MarcelineVQ> xenon-: no idea here, just know you're not being ignored, people just don't have an answer currently
13:50:27 * geekosaur knows very little JS and has no idea what the context of those questions even is
13:50:36 <geekosaur> (framework, etc.)
13:51:35 <xenon-> MarcelineVQ, that's fine! I foigured that was the case. if I tried setting navigator.languages variable twice, and I got the exception. so it is seemingly executing javascript, yet it doesn't show when printing navigator.languages value.  https://pastebin.com/Z6b1ZiiT 
13:51:50 <leshow> Has anyone used pipes? I have a Producer that yields values from a unix socket, but I want to run close socket after the Producer finishes
13:52:12 <xenon-> geekosaur, I know little JS, and syntax seems to be correct. do you think this is more of a javascript question, not a question about haskell webdriver library? I can always ask in ##javascript
13:53:39 <xenon-> I tried copy/pasting javascript string to chrome's console, and it changes the variable, so javascript part is correct
13:55:30 <geekosaur> JS has been more than just the language for decades, and "webdriver" is already more than I knew (and yet less)
13:56:20 * geekosaur does not for example know if ignoreReturn might be ignoring something helpful in figuring this out...
13:59:39 <xenon-> I could replaced that with executeJS [] js :: WD Value, and then Null is returned
13:59:47 <xenon-> replace*
14:06:18 <jle`> koz_: the issue is because singletons tries to make sense of your type at the value level too
14:06:26 <jle`> but it doesn't really make sense, because there is no Nat type
14:06:31 <koz_> Ah, hi jle`!
14:06:41 <jle`> hi :)
14:06:47 <koz_> So how would I go about doing this?
14:07:02 <jle`> singleton pairs the term level with the lifted type level
14:07:14 <jle`> but there's no term value associated with "Dim 1"
14:07:32 <jle`> so what would fromSing be?
14:07:37 <koz_> Ah, OK, I think I understand.
14:08:02 <jle`> the only way to get around this afaik is to paramaterize your type on your nat type
14:08:14 <jle`> data Shape nat = Scalar | Dim nat
14:08:22 <koz_> I see.
14:08:35 <koz_> Let me try and better explain what I was working towards.
14:08:38 <koz_> Maybe there's an easier way.
14:08:41 <jle`> so the kind would be Shape Nat, and your type would be Shape Natural
14:08:58 <jle`> alternatively you can use your own custom Nat type and not GHC.TypeNats
14:09:14 <koz_> Basically, I wanna have a synonym for type-level lists full of Nats called Shape.
14:09:29 <koz_> And be able to reify that down into something that I can work with at the term level too.
14:09:46 <koz_> Should I just use type-level lists of Nats and leave a comment saying 'that's what a shape is, kay?'.
14:09:52 <koz_> s/\./?/
14:10:34 <jle`> what would Scalar be for?
14:10:43 <jle`> but yeah, [Nat] makes sense because its demoted type is [Natural]
14:11:10 <jle`> type instance Demote Nat = Natural
14:11:15 <jle`> type instance Demote [a] = [Demote a]
14:11:18 <koz_> Scalar corresponds to the empty shape.
14:11:30 <koz_> I guess I just wanted a more descriptive name.
14:11:32 <jle`> so one thing you can do is use a Maybe-like type, since we have
14:11:39 <jle`> type instance Demote (Maybe a) = Maybe (Demote a)
14:11:52 <jle`> so :kind! Demote [Maybe Nat]  ==> [Maybe Natural]
14:12:05 <koz_> I basically want exactly type-level-list-of-Nat, except with a different name.
14:12:10 <koz_> (at both the type and term level)
14:12:11 <jle`> you could make your own more-descriptive Maybe name, but it'd have to be parameterized
14:12:31 <jle`> different name, as in type synonym? or newtype wrapped?
14:12:50 <koz_> newtype-wrapped ideally. That way I can define only sensible Shape functions on it.
14:13:12 * hackage morpheus-graphql 0.2.0 - Morpheus GraphQL  https://hackage.haskell.org/package/morpheus-graphql-0.2.0 (nalchevanidze)
14:13:19 <jle`> hm yeah, there isn't any way to get around having to get Nat/Natural from a type parameter i think
14:13:28 <jle`> so you could newtype wrap a list, newtype ShapeList a = ShapeList [a]
14:13:38 <jle`> but you can't pre-apply the Nat/Natural itself
14:13:45 <koz_> Hmmm.
14:14:01 <koz_> I guess I'll just bite the bullet and use [Nat] then.
14:14:02 <jle`> this could be solved 'if only' GHC united Nat and Natural, which it maybe should have done from the start
14:14:13 <jle`> koz_: type synonym, maybe? :)
14:14:21 <koz_> I guess that's close.
14:14:29 <koz_> Would I also get a _kind_ synonym?
14:14:50 <koz_> In fact, is that even a thing?
14:14:52 <jle`> hm, i think it might be both?
14:14:58 <jle`> kind synonyms with TypeInType are just type synonyms
14:15:06 <jle`> since kinds would just be types
14:15:10 <koz_> Oh yeah, I keep forgetting that Type :: Type is a thing now.
14:15:14 <koz_> OK, let me try that then.
14:17:27 <koz_> OK, what am I doing incorrectly now? https://gist.github.com/kozross/8541e2c90ff1b9d71d834c60f3fb7e9d
14:18:15 <jle`> is that supposed to be the singleton list?
14:18:20 <koz_> jle`: Indeed.
14:18:31 <jle`> you'd have to write '[n], since [n] is interpreted as the list type, like [Int]
14:18:37 <koz_> Ah.
14:18:39 <jle`> [n] is interpreted like [] n
14:18:48 <jle`> and [] :: Type -> Type
14:19:29 <koz_> Thanks, that's perfect!
14:19:59 <jle`> :D
14:21:07 <koz_> Also, what's the proper way to sing down the length of a type-level list?
14:21:26 <koz_> (yes, 'sing down' is how I call reification-via-singletons)
14:21:47 <geekosaur> .oO { chant }
14:21:56 <geekosaur> (no, don't do that)
14:21:58 <jle`> do you mean reflection?
14:22:17 <koz_> jle`: I mean 'grab a Sing of'.
14:22:27 <koz_> Isn't that reification? I thought reflection goes the _other_ way?
14:22:40 <jle`> ah, i always felt like reification was 'up' in haskell, and reflection was 'down'
14:22:50 <jle`> even though it's the opposite in most other contexts where reification/reflection is used
14:23:10 <koz_> jle`: It always confuses me - I'm trying to use the terminology from your Introduction to Singletons series.
14:23:30 <jle`> if you have `Sing '[4,6,1]` and want to get `Sing 3`, you can use sLength
14:23:39 <koz_> I don't have a Sing of the list.
14:23:53 <jle`> what do you have then exactly?
14:23:53 <koz_> I have a type, which is a type-level list, and I wanna get the Sing corresponding to its length.
14:24:02 <jle`> ah. well, you need to ge ta hold of the sing of the list somehow
14:24:15 <koz_> Ah, so I do have to have that 'intermediate' Sing?
14:24:24 <jle`> mhm, otherwise type erasure and stuff
14:24:36 <koz_> I always thought I could grab a Sing of Length '[1, 2, 3] directly.
14:25:20 <koz_> But I can use sLength after singing down the type-level list.
14:25:24 <jle`> you can only get a sing if someone gives it to you (either manually or typeclass), or you do stuff with sings people have already given you
14:25:30 <koz_> Ah.
14:25:37 <jle`> so you can ask for Sing (Length '[1,2,3])
14:25:43 <jle`> or you can askf or Sing '[1,2,3] and get Sing 3 from that
14:26:11 <koz_> In the former case, can I then demote it to something at the value level?
14:26:22 <jle`> but be careful because you're going from an inductive type (lists) to a non-inductive type (Nat), so it might not always work the way you think
14:26:25 <koz_> Sorry, 'demote' is the wrong language.
14:26:34 <jle`> yeah, you can reflect it to the value level
14:26:37 <koz_> De-sing?
14:26:50 <jle`> fromSing :: Sing (a :: k) -> Demote k
14:26:53 <koz_> Ah.
14:27:00 <koz_> So I'd basically go something like
14:27:00 <jle`> fromSing (_ :: Sing 3) :: Natural
14:27:11 <koz_> 1) Sing down (Length s).
14:27:20 <koz_> 2) fromSing that into ... something
14:27:22 <koz_> 3) fromIntegral?
14:27:40 <koz_> (with the obligatory .... n - 1) ??? and n) Profit!, of course)
14:27:44 <jle`> yeah. or well, the way i'd recommend is to get a hold of Sing '[1,2,3], use sLength to get Sing 3, use fromSing to turn that into 3
14:27:54 <jle`> (3 :: Natural), value level
14:28:21 <koz_> What's the advantage of going that route, as opposed to singing down Length s then de-singing that?
14:28:32 <jle`> really we are just using singletons to simulate matching on the types themselves
14:28:55 <jle`> so matching onto '[1,2,3] to get a Sing '[1,2,3] is closer to the intent of singletons
14:29:17 <koz_> Ah, I see.
14:29:29 <jle`> well, that's my gut feeling at least. but there might be some practical benefits
14:29:35 <jle`> remember these singletons have to come from *somewhere*
14:29:58 <jle`> and you're more likely to already have a Sing '[1,2,3] -- corresponding directly to the type -- than a Sing (Length '[1,2,3])
14:30:39 <koz_> Yeah, fair point.
14:31:02 <jle`> and especially if you ask for it implicitly via a typeclass
14:31:21 <jle`> SingI (Length as) is not something you would probably already have around in the context
14:31:27 <jle`> but you might already have SingI as
14:33:43 * hackage morpheus-graphql 0.2.1 - Morpheus GraphQL  https://hackage.haskell.org/package/morpheus-graphql-0.2.1 (nalchevanidze)
14:34:11 <koz_> jle`: So what I want is something like
14:34:22 <koz_> rank :: forall (s :: Shape) . (Sing I s) => Int
14:34:31 <koz_> rank = fromIntegral . fromSing . sLength $ sing @s
14:34:34 <koz_> ?
14:35:35 <koz_> Although technically that _could_ be more general.
14:35:38 <jle`> yeah, that should work. i don't think rank :: Sing s -> Int is too bad either
14:35:52 <koz_> So explicit versus implicit?
14:36:05 <koz_> I guess you can always go to implicit using ... something from singletons whose name I can't remember.
14:36:05 <jle`> yeah, i suppose that's just a style choice
14:36:13 <jle`> yeah, withSingI
14:36:20 <koz_> implicitlySing
14:36:52 <koz_> :t fromIntegral
14:36:53 <lambdabot> (Integral a, Num b) => a -> b
14:37:26 <koz_> I guess it's a bit better because the types aren't ambiguous then?
14:38:36 <jle`> sLength on a list would fix the type inference
14:38:45 <jle`> fix as in hold-in-place
14:39:17 <inkbottle> "In practice, there are many languages that require arbitrary lookahead; for example, type signatures in Haskell" (https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/parsec-paper-letter.pdf)
14:39:19 <koz_> Yeah, but the way I have it there, it forces AllowAmbiguousTypes, because s could be a lot of different things.
14:39:19 <inkbottle> Could one explain the very intriguing statement above?
14:39:24 <jle`> it could really be as general as rank :: forall (s :: t k). (STraversable t, Num a) => Sing s -> a
14:39:47 <koz_> Whereas if I write it the way you suggest, AllowAmbiguousTypes is no longer needed.
14:40:06 <jle`> ah yeah. the type error would be nicer with explicit singleton
14:40:18 <jle`> either you call rank @s, or you call rank s/rank (sing @s)
14:40:19 <koz_> I think I'll go with explicits just for that.
14:43:01 <koz_> How would I make synonyms of SNil and SCons? Patterns?
14:43:04 <turab> @pl \x y -> let [x] y
14:43:05 <lambdabot> (line 1, column 13):
14:43:05 <lambdabot> unexpected "["
14:43:05 <lambdabot> expecting "()", natural, identifier or "in"
14:43:18 <turab> @pl \x y -> let (x) y
14:43:18 <lambdabot> (line 1, column 13):
14:43:19 <lambdabot> unexpected "("
14:43:19 <lambdabot> expecting "()", natural, identifier or "in"
14:43:30 <turab> @pl \x y -> f (x) y
14:43:30 <lambdabot> f
14:43:31 <jle`> koz_: you can alias them to use them to make snil/scons, but to pattern match on them you'd probably need pattern synonyms yea
14:43:36 <turab> @pl \x y -> f [x] y
14:43:37 <lambdabot> f . return
14:43:46 <koz_> jle`: Figures lol.
14:44:08 <koz_> Now I have to remind myself how that goes.
14:44:38 <koz_> Basically I need to name SNil 'Scalar', and SCons 'Dim'.
14:45:33 <jle`> you could also just make a whole new type instead of list, if you want to completely abstract away the fact that it's a list
14:45:49 <koz_> I'd rather do that actually.
14:46:20 <koz_> But I think at the type level, you end up coming back to a type-level list eventually anyway right?
14:47:54 <jle`> you can write (S [1,2,3]), where S is a function that converts a list into your type level list
14:48:00 <jle`> but the type errors might be a bit not-so-great
14:48:54 <literall1Crevice> What's the best (shortest, cleanest) way to construct the function `consMay :: Maybe a -> [a] -> [a]`?
14:49:07 <koz_> :t maybe
14:49:08 <lambdabot> b -> (a -> b) -> Maybe a -> b
14:49:11 <koz_> May be of use.
14:49:13 * hackage sequence-formats 1.3.2.1 - A package with basic parsing utilities for several Bioinformatic data formats.  https://hackage.haskell.org/package/sequence-formats-1.3.2.1 (stephan_schiffels)
14:49:23 <literall1Crevice> :t maybe [] (:)
14:49:25 <lambdabot> error:
14:49:25 <lambdabot>     • Couldn't match type ‘[a] -> [a]’ with ‘[a1]’
14:49:25 <lambdabot>       Expected type: a -> [a1]
14:50:12 <literall1Crevice> :t maybe [] (:[])
14:50:14 <lambdabot> Maybe a -> [a]
14:51:17 <literall1Crevice> @pf consMay xs = maybe xs (:xs)
14:51:17 <lambdabot> Maybe you meant: pl bf
14:51:30 <literall1Crevice> @pl consMay xs = maybe xs (:xs)
14:51:30 <lambdabot> consMay = ap maybe (flip (:))
14:51:41 <literall1Crevice> Ugh, hideous
14:51:58 <literall1Crevice> I'll go with the first one though, thanks koz_ ! I keep forgetting about how useful maybe is
14:52:12 <koz_> consMay x xs = maybe xs (: xs) x
14:52:30 <koz_> Could be done more neatly by switching around the Maybe and list args.
14:52:50 <koz_> Since that would be something like 'consMay xs = maybe xs (: xs)
14:52:53 <koz_> '
14:53:53 <koz_> Oh, never mind, that's exactly what you just said, literall1Crevice.
14:54:12 <koz_> jle`: I think I'll stick to type-level lists and synonyms, but I dunno how to write those patterns, argh.
14:56:20 <jle`> koz_: does pattern Scalar = SNil work? and pattern (Dim x xs) = SCons x xs
14:57:06 <jle`> literall1Crevice: maybe id (:) would work, but i'm not sure if it's cleaner than manual pattern matching
14:57:14 <jle`> > maybe id (:) (Just 1) [2,3,4]
14:57:16 <lambdabot>  [1,2,3,4]
14:57:22 <jle`> > maybe id (:) Nothing [2,3,4]
14:57:25 <lambdabot>  [2,3,4]
14:57:29 <koz_> jle`: That's incredibly clever.
14:58:04 <jle`> the "leave same if Nothing" pattern is `maybe id`, and from there it's just picking what the consing function is...and it's cons :)
14:58:12 <jle`> but i'm not sure if it's readable
14:58:18 <koz_> I get a parse error on 'pattern (Dim x xs) = SCons x xs'. Did I forget to enable something?
14:58:19 <jle`> :t maybe id
14:58:21 <lambdabot> (a1 -> a2 -> a2) -> Maybe a1 -> a2 -> a2
14:58:26 <jle`> koz_: PatternSynonyms?
14:58:30 <koz_> Enabled.
14:58:43 <jle`> oh, maybe no parentheses
14:59:05 <koz_> Yeah, that did it.
14:59:14 <koz_> Now I just gotta give them type sigs and mark them as complete.
14:59:31 <koz_> The signatures it suggests are hilarious.
14:59:57 <jle`> hah
15:00:08 <koz_> pattern Scalar :: forall a (b :: [a]) . () => (b ~ '[]) => Sing b
15:00:15 <koz_> What's with the _two_ =>s?
15:03:44 <jle`> ah yeah pattern synonym constraints are tricky, because with patterns you have tow constraints
15:03:45 <jle`> *two
15:03:59 <jle`> one set of constraints is the constraints you need to *match* on a pattern, and the other is the constraints that the pattern brings into scope
15:04:15 <koz_> Ah, so I guess that's the first => and the second => respectively?
15:04:18 <jle`> this is saying that you don't need any constraints to match on Scalar, but if you do match on Scalar, you have b ~ '[] in scope
15:04:33 <jle`> or maybe it's opposite...i always mix them up heh
15:04:34 <koz_> That's pretty cool.
15:04:41 <koz_> I've got these sigs:
15:04:53 <koz_> pattern Scalar :: forall (s :: Shape) . (s ~ Point) => Sing s
15:04:55 <koz_> and
15:05:12 <koz_> pattern Dim :: forall (s :: Shape) (n :: Nat) (s' :: Shape) . (s ~ (n ': s')) => Sing n -> Sing s' -> Sing s
15:05:14 <koz_> Seems OK?
15:06:08 <jle`> hm, i always get confused by pattern synonym signatures, so i suggest maybe just try using them and seeing if they do what you expect
15:06:17 <jle`> also didn't you define Point as a singleton list earlier?
15:06:28 <jle`> oh wait, that was Line
15:07:51 <koz_> I have a good use case, but now I need to think about it. I wanna define size, which is 'length of outermost dimension'. However, this makes no sense for Point as a Shape. I guess I should define it as being usable only on Line or 'more dimensional'?
15:08:20 <koz_> How would I say 's is not ~ to Point'?
15:09:43 * hackage Map 0.1.0.0 - Class of key-value maps  https://hackage.haskell.org/package/Map-0.1.0.0 (MatthewFarkasDyck)
15:10:40 <koz_> Type family?
15:10:59 <jle`> s ~ (n ': s')
15:11:08 <koz_> Yeah, I guess that also works, lol.
15:11:12 * koz_ just used it one second ago.
15:11:24 <jle`> or just use (n ': s) instead of s :)
15:11:53 <koz_> Oh wait, I can _do_ that?
15:12:03 <koz_> (like, in the forall you mean?)
15:16:26 <koz_> Hmm, it seems even with a COMPLETE pragma, those synonyms don't work.
15:16:43 <koz_> GHC doesn't believe me that in the case of s ~ n ': s', Scalar won't possibly be a match.
15:32:26 <koz_> jle`: OK, I decided to rethink and rewrite based on that, but now I'm stumped in a different way: https://gist.github.com/kozross/faad1a27d4a2d9af9ff97a0163d0abce
15:34:02 <jle`> hm yeah, pattern synonym complete pragma might be weird in the case of polymorphism like this
15:34:12 <koz_> It's unworkable - GHC can't see the connection.
15:34:24 <jle`> :'(
15:34:41 <koz_> My more-current problem _might_ have a solution.
15:34:52 <koz_> At least I figured out _one_ way of doing my original thought.
15:35:25 <jle`> wher eare your pattern synonyms defined?
15:35:28 <koz_> (reminded of it by the 'trick' used by recursion schemes with Mu, or maybe Nu, I forget which)
15:35:58 <koz_> jle`: Older file. I can paste the whole thing of that if you wanna try that fix too. I'm curious about my most current option also.
15:36:14 <jle`> yeah the way you're using the pattern synonyms is a bit confusing
15:36:34 <jle`> you're doing it forall ns. is SDim supposed to imply that ns ~ Shape something?
15:38:13 <koz_> Synonyms issue is here: https://gist.github.com/kozross/35f6955405e90d48d7db31549a093101
15:38:48 <koz_> For the other one - yes, that's the idea.
15:39:26 <jle`> just fyi, i have to head out now. but wishing you best of luck with this :)
15:39:35 <koz_> So the ns is meant to be filled only with more Shape n' ns'.
15:39:35 <koz_> Not only that, but the first type should _always_ be Nat.
15:39:35 <koz_> Lol, no worries - thanks for all the help!
15:40:06 <jle`> oh if that's the case then your Shape type might not make sense
15:40:12 <koz_> That's what I was thinking.
15:40:26 <koz_> Unsure how to define it correctly though.
15:40:48 <jle`> er actually it might. in analogy to like the Cons a b type
15:41:04 <koz_> Where can I find said type?
16:32:43 * hackage hspec-parsec 0 - Hspec expectations for testing Parsec parsers  https://hackage.haskell.org/package/hspec-parsec-0 (sjakobi)
16:39:43 * hackage list-witnesses 0.1.3.0 - Witnesses for working with type-level lists  https://hackage.haskell.org/package/list-witnesses-0.1.3.0 (jle)
17:17:08 <iqubic> what is the point of list-witnesses.
17:17:13 <iqubic> ??
17:17:59 <koz_> iqubic: To prove stuff about typelevel lists at compile time.
17:18:17 <koz_> For example, Insert is basically a way to prove that 'if I insert this thing into this list, I will get this other list'.
17:23:27 <iqubic> How does that work?
17:23:43 <koz_> How does what work? The idea of proving things to the compiler?
17:24:14 <iqubic> Why do you want such a thing?
17:24:23 <koz_> iqubic: Because GHC isn't all that smart about that.
17:24:35 <koz_> A lot of the time, we need to give it very strong evidence of something being true before it will accept our program.
17:24:57 <iqubic> I see.
17:25:06 <koz_> _You_ certainly know that if [1] ++ [2, 3] is [1,2,3], but GHC doesn't. By having this _witness_ to this fact, GHC is convinced.
17:25:25 <koz_> (because if this were false, we could never construct such a thing)
17:25:36 <koz_> Introduction to Singletons shows this with the Knockable GADT.
17:25:49 <iqubic> What's the difference between InsZ and InsS?
17:26:00 <iqubic> Is that something about Peano Numbers?
17:26:33 <koz_> InZ is a proof that x consed to as is ... well, x, then as.
17:27:13 <koz_> InsS is that, but in other positions.
17:27:22 <koz_> InsZ is short for 'insert zero' (that is, base case).
17:27:32 <koz_> InsS is short for 'insert successor' (that is, inductive case).
17:27:34 <iqubic> I see
17:28:11 <iqubic> This seems like dependent type stuff.
17:28:18 <koz_> That is the entire point.
17:28:48 <iqubic> Ah.
17:29:23 <iqubic> What is the Knockable GADT you mentioned?
17:29:32 <koz_> It's from Part 3 of Introduction to Singletons.
17:29:54 <koz_> https://blog.jle.im/entry/introduction-to-singletons-3.html#dependently-typed-proofs
17:29:57 <koz_> First code block.
17:31:21 <iqubic> I'm going to read part 2 first.
17:31:44 <koz_> I'm around to answer any questions, although I may not be the best person to ask, since I'm not really smart enough to write Introduction to Singletons myself yet. :P
17:31:53 <koz_> s/smart/knowledgeable/ but ehh
17:32:33 <iqubic> I know.
17:40:52 <iqubic> How does one take a value level list, and turn it into a type level list?
17:41:52 <koz_> That's https://blog.jle.im/entry/introduction-to-singletons-2.html#reflection-and-reification
17:42:07 <koz_> The whole idea is that SomeSing k is a 'lifted' k.
17:42:22 <iqubic> I see.
17:42:23 <koz_> (we use SomeSing because we're not sure what precise type we have)
17:42:31 <koz_> (since that obviously depends on the value being so lifted)
17:43:05 <MarcelineVQ> gosh reflection and reification are weird words, the use I'm familiar with is the exact opposite of the described one here :X
17:43:17 <iqubic> Really?
17:43:17 <koz_> MarcelineVQ: It's a very unfortunate choice of terminology, honestly.
17:43:32 <koz_> iqubic: Usually, 'reification' implies moving toward something _more_ concrete.
17:43:56 <koz_> However, most people (myself included) consider going from value-level to type-level to be a shift to the abstract.
17:44:28 <koz_> These days, I prefer to talk about 'down-singing' and 'up-singing', but that's likely even more confusing.
17:44:30 <iqubic> Ah.
17:44:47 <koz_> (where 'down' and 'up' refer to the values -> types -> kinds -> sorts -> wriggles or whatever they're called hierarchy)
17:44:48 <iqubic> I want mainline Haskell to have dependent types now.
17:44:54 <koz_> iqubic: Welcome to the club. :P
17:45:05 <iqubic> When is it going to happen?
17:45:10 <MarcelineVQ> reification, to make real, certainly implies to me to take types to values, since types don't exist when you're all done with your code :X
17:45:37 <koz_> MarcelineVQ: Again, I don't love this terminology, but prescriptivism as a hat gets quite annoying to wear after the tenth or so confusion episode.
17:45:50 <koz_> (as evidenced by _literally a few hours ago in this very chat argh_)
17:46:09 <MarcelineVQ> Maybe but I've seen this use when talking about types, so I wonder where the disconnect is that creates this useage here
17:46:31 <koz_> I believe Edward did a Stack Overflow answer on this one.
17:46:39 <MarcelineVQ> I'll have to make a note when I see the other way and compare.
17:46:51 <koz_> You could probably even just prod him and ask?
17:47:20 * koz_ is amused by the fact that I don't even have to specify _which_ Edward. :P
17:55:50 <iqubic> :t (~)
17:55:52 <lambdabot> error: parse error on input ‘)’
17:55:58 <koz_> :t ~
17:56:00 <lambdabot> error:
17:56:00 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
17:56:10 <koz_> :t Bool ~ Bool
17:56:11 <lambdabot> error:
17:56:12 <lambdabot>     Pattern syntax in expression context: ~Bool
17:56:14 <iqubic> I assume it's 'a -> b -> Constraint'
17:56:17 <koz_> :k Bool ~ Bool
17:56:18 <lambdabot> Constraint
17:56:21 <koz_> Yep.
17:56:26 <iqubic> :k (~)
17:56:27 <lambdabot> k -> k -> Constraint
17:56:28 <koz_> :k Int ~ Bool
17:56:29 <lambdabot> Constraint
17:56:32 <iqubic> There we go.
17:56:55 <iqubic> Wait... why is the :k using k twice?
17:57:06 <iqubic> Can't those k be different types?
17:57:13 * hackage debian 4.0.0 - Modules for working with the Debian package system  https://hackage.haskell.org/package/debian-4.0.0 (ClintAdams)
17:57:19 <koz_> k is a kind.
17:57:21 <koz_> So yes?
17:57:31 <koz_> Like, Int and Bool are both of kind Type.
17:57:41 <koz_> As are 'Maybe Int' and 'Either Bool String'.
17:57:42 <koz_> Etc.
17:58:35 <iqubic> The third code block here has an error: https://blog.jle.im/entry/introduction-to-singletons-3.html#type-level-functions
17:58:50 <iqubic> it reads "knockP :: (StatePass s ~ 'Obstruct) => Door s -> IO ()"
17:59:01 <iqubic> When I think it should be 'Allow
17:59:12 <iqubic> jle`: Care to comment on this?
17:59:14 <koz_> The whole point is that you _can't_ knock on open doors.
17:59:26 <iqubic> I know.
17:59:51 <iqubic> But there seems to be a mismatch between the provided code and the explanation below it.
17:59:51 <koz_> So if StatePass s ~ 'Allow, that's only possible if the door is open, right?
17:59:57 <koz_> Ah.
18:00:06 <iqubic> This constraint means that calling knock requires that StatePass s is equal to (or unifies with) 'Allow
18:00:08 <koz_> That, on the other hand, agreed.
18:00:15 <iqubic> Which is just wrong.
18:00:31 <koz_> The text is definitely not correct there.
18:00:37 <iqubic> I see.
18:06:02 <iqubic> Why are singletons so darn complex?
18:06:27 <koz_> Mostly because there's currently no better way to do this stuff within the confines of what GHC gives us.
18:07:00 <koz_> Like, we currently basically need a _quadruplicate_ construction, whose interconnections GHC understands _nothing_ about, to achieve this stuff.
18:07:11 <koz_> That... naturally makes things somewhat awkward in places.
18:08:13 <iqubic> You have Sing, SingI, SomeSing, SomeSingI, and all that gets confusing.
18:08:36 <iqubic> When you said "quadruplicate" what 4 things were you talking about?
18:10:08 <koz_> The type, the kind, its singletons and their demotions.
18:10:23 <koz_> Actually, sorry.
18:10:35 <koz_> The type, the kind, its singletons and its SingI instances.
18:10:51 <iqubic> I see.
18:11:27 <koz_> There are also some interesting mismatches (like the Nat-Natural situation I've been working around since this morning).
18:11:51 <koz_> While it was certainly a kind (hue hue) of instructive to write all the singletons machinery by hand, it's not fun.
18:12:28 <iqubic> Can I just use the singletons library to do this for me?
18:12:43 <koz_> Yes, and you should.
18:12:47 <koz_> In my case, I _can't_.
18:12:52 <koz_> (or at least, not the TH parts anyway)
18:13:41 <iqubic> Well, I've gotten to part 4, which introduces type level lists.
18:14:06 <koz_> This is where the real singletons begin. </dark_souls_joke>
18:14:26 <iqubic> Basically, we are creating a hallway, which is just a line of doors in a row.
18:14:31 <koz_> Yup.
18:15:47 <iqubic> And now we want to fold this type level list using the mergeDoor function.
18:15:56 <iqubic> Holy crap this is getting hard.
18:16:03 <koz_> Yep.
18:16:12 <koz_> If you prefer, think of this as a typelevel list-max.
18:16:23 <koz_> (which is essentially what this is, modulo all the door-related terminology)
18:16:28 <iqubic> right. That makes sense.
18:16:46 <iqubic> Because mergeState is essentially just max.
18:16:50 <koz_> Yes.
18:17:03 <koz_> (well, possibly min, depending on how you wanna order DoorStates, but I digress)
18:19:22 <iqubic> At long last, I now understand why defunctionalization is so powerful.
18:19:27 <koz_> Yay!
18:20:09 <iqubic> It lets us get around the restriction that every type level function, made with a type family, needs to be fully applied.
18:20:31 <koz_> Yep.
18:20:40 <koz_> (or 'saturated' to use established terminology)
18:21:03 <iqubic> Sure.
18:21:29 <dmwit> Is this my cue to tell you that GHC may soon allow non-saturated type families?
18:21:38 <koz_> dmwit: Yes it is!
18:21:40 <koz_> I had no idea.
18:21:40 <iqubic> It will?
18:21:43 <koz_> When did this happen?
18:21:57 <koz_> s/did/will/ I guess
18:22:12 <koz_> s/happen/decision happen/ also works I guess
18:22:14 <iqubic> This is going to make things like type level foldr so much easier to write.
18:23:07 <iqubic> So, when is this going to happen?
18:24:13 <dmwit> I'm trying to re-find the paper on it.
18:25:15 <turab> ICFP paper by Simon and CSonger Kiss?
18:26:18 <dmwit> https://www.microsoft.com/en-us/research/uploads/prod/2019/03/ho-haskell.pdf
18:26:21 <dmwit> turab: yep
18:27:36 <iqubic> So, when is this going to be a reality?
18:28:32 <turab> @pl \(a, b) x -> f a b (g x)
18:28:33 <lambdabot> uncurry (flip flip g . ((.) .) . f)
18:29:27 <koz_> Already implemented according to the paper.
18:29:46 <iqubic> That's not true, is it?
18:30:12 <koz_> We have a fork of GHC that implements a new language extension,UnsaturatedFamilies, whichsupports all the features described in this paper, including their interaction with GADTs, datafamilies,  pattern  synonyms,  etc  which  we  have  not  described  at  all.  Our  language  design  isbackward-compatible, so that all existing Haskell programs continue to work, even when theUnsaturatedFamiliesextension is
18:30:15 <koz_> enabled.
18:30:18 <koz_> So... yes it is?
18:31:07 <iqubic> How long until this fork of GHC becames the mainline GHC?
18:36:52 <koz_> That I do not know.
18:46:57 <infinisil> I have been wondering what caused so bad concurrency perf for my program for some time now
18:47:03 <infinisil> But I think I might have figured it out
18:48:09 <infinisil> The program really only does stupid parallelism, no dependencies between threads
18:49:07 <infinisil> But even still, with only one thread it would run at 100% productivity, one core fully used. But with more than one, productivity would go down a lot
18:49:41 <infinisil> So far as that with e.g. 6 threads, only about 2-3 cores would be fully used
18:50:17 <infinisil> I think I figured it out: the program is allocating (and deallocating) so much memory that the system allocator can't keep up
18:51:16 <infinisil> So one thread works just fine because the allocator only has to allocate memory for a single program instance, but with 2 it struggles because it needs to allocate twice as fast
18:53:52 <infinisil> I think that might be the only explanation for this symptom (good productivity with one thread, bad productivity with more, for an embarassingly parallel program)
18:54:45 <infinisil> (yeah this kind of program is called https://en.wikipedia.org/wiki/Embarrassingly_parallel )
19:23:04 <iqubic> koz_: KnownNat n is just a witness that n is a nat, right?
19:23:18 <iqubic> Or am I massively misunderstanding?
19:23:51 <koz_> The way I understand it is that it's a witness that n is a _sensible_ Nat.
19:24:13 <koz_> But I'm not sure really - I just stuff it anywhere GHC asks me to.
19:24:14 <iqubic> define sensible, please.
19:24:25 <koz_> iqubic: That's exactly it - I don't exactly understand myself.
19:24:30 <koz_> jle` might know.
19:24:32 <koz_> Or someone else.
20:11:08 <nshepperd> KnownNat n is more like a witness that someone knows *which* nat n is
20:12:12 <nshepperd> hence Known
20:14:12 <nshepperd> which I suppose also does mean that n is a 'sensible' nat such as 4, instead of being, say, a stuck type family
20:31:49 <sarahzrf> KnownNat is just a class whose dictionary contains a value indicating which nat it is
20:33:13 <sarahzrf> the known is known /at runtime/
20:49:58 <koz_> nshepperd, sarahzrf: Thanks, that actually explains it.
20:54:54 <iqubic> Yeah that makes a lot of sense.
20:58:43 <koz_> 'Such instance, very define' <-- are these commit messages a sign that I should stop, or keep going?
21:05:03 <MarcelineVQ> are you the one writing them?
21:05:16 <koz_> MarcelineVQ: Yes.
21:06:53 <koz_> :t fromIntegral
21:06:55 <lambdabot> (Integral a, Num b) => a -> b
21:07:08 <MarcelineVQ> well, keep at it I guess, but be sure to also include a line saying what you're talking about :>
21:07:56 <MarcelineVQ> or like: add missing Glob instances for shaped arrays\nSuch instance, very define
21:08:22 <koz_> MarcelineVQ: Lol, the fact you guessed I'm working on shaped arrays amuses me no end.
21:08:39 <MarcelineVQ> But I've known all along.
21:09:01 <koz_> Given my volume of questions about that, I'm not surprised.
21:12:36 <iqubic> koz_: What are shaped arrays?
21:12:54 <koz_> iqubic: Higher-dimensional versions of Vector which have their dimensions in their types.
21:13:13 <koz_> It's vector-sized, but for 2D, 3D, ... any D you want.
21:13:32 <iqubic> So it's dependently typed?
21:14:00 <koz_> iqubic: Well, that might be a bit too strong a statement - it's more typesafe, as the dimensions of the arrays are known at compile time.
21:14:06 <koz_> (and indeed, indicated by their types)
21:14:23 <iqubic> What is the difference between what you just said, and what I said?
21:15:05 <koz_> iqubic: I guess 'dependently typed' to me sounds more general - it implies all kinds of typelevel stuff. Type-level sizes are probably the simplest use of this kinda thing.
21:15:24 <koz_> So that's why I think calling it 'dependently typed' might be too strong a statement, though not incorrect per se.
21:15:33 <koz_> (sadly, I have to drag in singletons anyway)
21:15:39 <koz_> (unlike vector-sized)
21:15:47 <iqubic> What other things do you associate with dependent types?
21:16:00 <koz_> Proving things to the compiler.
21:16:08 <koz_> (like in Introduction to Singletons part 3)
21:16:17 <koz_> Type level functions.
21:16:23 <koz_> That kinda thing.
21:17:14 <iqubic> type families don't need dependent types. Not really.
21:17:57 <koz_> Hence why I said 'type level functions' - type families have to (currently) be saturated, while dependently-typed things like singletons allow us to get around that.
21:18:09 <iqubic> But partially applied type level functions are just weird to use are just a pain.
21:18:17 <koz_> (and thus, allow us to basically compute at the type level)
21:18:20 <iqubic> Defunctionalization symbols are weird to work with.
21:18:24 <koz_> Agreed.
21:18:29 <koz_> It's not an ideal situation by any means.
21:18:35 <iqubic> That apply type class is is janky as all heck.
21:18:53 <iqubic> We really need a better system for that.
21:19:42 <koz_> Well, maybe when the fork mentioned in that paper lands, we'll have one.
21:19:47 <iqubic> Being able to run functions at the type leve is great.
21:19:50 <koz_> I, for one, look forward to it very much.
21:19:58 <iqubic> koz_: I totally agree.
21:20:23 <iqubic> it would make things like a type level map function for type level lists so much easier.
21:20:34 <iqubic> Or a type level foldr.
21:21:08 <iqubic> Basically it would make higher order type level functions easier to write.
21:23:47 <koz_> What other nice typeclasses could I get definitions for if I had proof that a type was finite?
21:23:55 <koz_> I already have Storable, Binary, Unbox.
21:24:53 <iqubic> I'm not sure what you are asking about.
21:25:30 <koz_> iqubic: Just a general query about what more things I could write instances for. I've written a typeclass called 'Finitary' which basically says 'type a is finite, and has exactly n inhabitants'.
21:25:50 <koz_> I've defined some nice Generic machinery around that, which means adding it to user-defined types is easy.
21:26:05 --- mode: monochrom set -o monochrom
21:26:07 <koz_> And by way of that, I can define some other useful typeclasses, such as the ones listed above.
21:26:12 <koz_> I was wondering if there were any others.
21:26:57 <iqubic> What does the definition of Finitary look like? Can I see it?
21:27:56 <koz_> iqubic: Sure. https://gist.github.com/kozross/1283a3f5b4e7a771fd277bfc240665d4
21:28:30 <koz_> Yes, there is a scary number of extensions on.
21:29:12 <iqubic> Why do you have so many extensions?
21:29:18 <iqubic> Do you know what they all do?
21:29:29 <koz_> Fundeps are necessary because otherwise type inference on Finitary falls the hell over.
21:29:59 <iqubic> Generics confuse the hell out of me.
21:30:07 <koz_> FlexCons and FlexInstances are generally very useful, because they allow definitions of typeclass instances that aren't otherwise OK (for example, that Maybe a instance at the bottom).
21:30:34 <koz_> DefaultSignatures is used to work the GFinitary magic - if you have a Generic instance, you can automagically derive Finitary for your type, assuming it's finite.
21:30:52 <koz_> TypeInType is just a jumble of 'let's do typelevel things, GHC stop yelling at me plz'.
21:31:02 <koz_> TypeOperators allows my use of + and * for Nats.
21:31:34 <koz_> ScopedTypeVariables means I can refer to type variables inside my definitions (as is needed, for example, to direct those weakenN and shiftN and friends from Data.Finite).
21:31:47 <koz_> TypeApplications also - that's all the @n, @m etc.
21:32:46 <koz_> UndecidableInstances is scary-sounding, but ultimately comes down to 'GHC's derived typeclass resolution is very conservative, so anything more complex than that requires it to be on'. Specifically the Maybe instance I think.
21:33:25 <paulotorrens> is this a good place to ask about GHC's internals?
21:33:26 <koz_> AllowAmbiguousTypes is necessary because I don't always have a concrete value for an argument where types matter (again, derived instances).
21:33:42 <koz_> paulotorrens: You can ask, but I think there's a GHC-specific channel that might be better.
21:33:45 <koz_> I forget what it is though.
21:33:56 <iqubic> it's #ghc
21:33:59 <koz_> TypeFamilies are needed for those ~ constraints you see.
21:34:11 <koz_> And NoStarIsType is so that GHC knows that * means 'typelevel times' not 'Type'.
21:34:17 <koz_> So, iqubic, to answer - yes, I do know what they all do. :P
21:34:24 <iqubic> I see.
21:34:28 <paulotorrens> my question would be regarding Cmm's implementation inside GHC, and how much it differs from the original paper about C--
21:34:41 <iqubic> I do not understand how generics work, at all.
21:34:41 <koz_> paulotorrens: Definitely better to ask in #ghc.
21:34:51 <paulotorrens> koz_: thank you
21:34:52 <koz_> iqubic: Have you read Thinking with Types by Sandy?
21:35:03 <koz_> If not, _do_. I basically wrote that based on his chapter on generics.
21:35:13 <iqubic> I haven't read that book
21:35:19 <koz_> I recommend it very much.
21:35:31 <koz_> It does a bunch of typelevel stuff, but its explanations of some of the basics are really accessible.
21:35:48 <koz_> (generics, type families, ST are just the ones that come to mind)
21:36:21 <iqubic> Also, I just realized that Finitary is just defining an isomorphism between (Finite n) and a for some given type a
21:36:39 <iqubic> Well, defining and proving it.
21:36:43 <koz_> iqubic: You would indeed be right.
21:36:51 <koz_> I even wrote some Isos for it.
21:36:54 <koz_> (as in the lens things)
21:37:51 <koz_> https://gist.github.com/kozross/9631f5d0f4c7341f1717e9ab65cf316e
21:38:03 <iqubic> Also, fromFinite :: Finitary 0 -> Void == absurd, I think.
21:38:06 <koz_> (that type translates to Iso' (Finite n) a)
21:38:15 <koz_> iqubic: Yeah, that's a good point.
21:38:20 <koz_> I should really fix that.
21:39:31 <iqubic> And you can use an empty case statement to create the toFinite, I think. Not sure though.
21:39:39 <koz_> I think I can, yeah.
21:40:25 <iqubic> How does the Finitary instance for Word8 work?
21:40:34 <koz_> Just munge it to the equivalent unsigned integer.
21:40:37 <iqubic> Why are both functions fromIntegral?
21:40:38 <koz_> (and from)
21:40:52 <koz_> Because fromIntegral is your general 'I wanna munge and integer to something else numeric' function.
21:40:57 <koz_> s/and/an/
21:40:57 <iqubic> Ah.
21:40:59 <iqubic> I see.
21:41:12 <iqubic> Why are the Int typeclasses different?
21:41:20 <koz_> Different sizes?
21:41:27 <iqubic> Really?
21:41:37 <koz_> Int8 has a very different number of inhabitants to Int64.
21:41:38 <iqubic> instance Finitary 256 Int8 where
21:41:43 <iqubic> fromFinite = fromIntegral . subtract 32768 . fromIntegral @_ @Int32
21:41:48 <iqubic> toFinite = fromIntegral . (+ 32768) . fromIntegral @_ @Int32
21:41:48 <koz_> Ah, that.
21:41:58 <koz_> I use Finite 0 to encode 'smallest possible value'.
21:42:00 <iqubic> Is that dealing with negative numbers?
21:42:02 <koz_> Hence the maths.
21:42:03 <koz_> Yeah.
21:42:08 <iqubic> Ah, I see.
21:42:11 <koz_> It's at its most awkward for Int64.
21:42:23 <koz_> This is how I discovered that GHC is bounds-aware. :P
21:42:44 <iqubic> What are shift and unshift in the Maybe and Either instances?
21:42:51 <koz_> From Data.Finite.
21:42:55 <iqubic> Ah. I see.
21:43:04 <koz_> http://hackage.haskell.org/package/finite-typelits-0.1.4.2/docs/Data-Finite.html#v:shift
21:43:15 <koz_> unshift is just below - the docs are quite self-explanatory I think.
21:43:15 <iqubic> I assume Data.Finite also exports combineProduct and separateProduct?
21:43:21 <koz_> Yep.
21:43:30 <koz_> Data.Finite made some of this _super_ easy to write.
21:44:54 <iqubic> Hoogle doesn't know about Data.Finite it would seem.
21:46:25 <koz_> Strange.
21:46:40 <koz_> Yeah it does.
21:46:42 <koz_> Fourth entry for me.
21:46:47 <koz_> https://hoogle.haskell.org/?hoogle=Data.Finite
21:46:47 <iqubic> I see.
21:47:02 <iqubic> Alright... Looks like Hoogle is case sensitive.
21:47:05 <iqubic> TIL.
21:47:16 <iqubic> https://hoogle.haskell.org/?hoogle=data.finite
21:47:20 <iqubic> Compare.
21:49:28 <iqubic> koz_: You mentioned a book called Thinking With Types? Is that available digitally?
21:57:33 <nshepperd> for 'fromFinite :: Finitary 0 -> Void' I would probably do fromFinite !x = undefined
21:59:52 <nshepperd> making it strict means that if someone passed you a Finite 0 that throws an exception you get the exception back instead of a generic undefined
22:01:23 <mycroftiv> speaking of the opposite of finite, im very interested in code that works with infinitary objects. I'm familiar with Martin Escardo's "seemingly impossible" programs and Oleg Kiselyov's "lazy infinite search trees", anyone have other cool examples?
22:01:52 <mycroftiv> http://www.cs.bham.ac.uk/~mhe/papers/seemingly-impossible.html and http://okmij.org/ftp/continuations/Searches.hs are my references there
22:02:37 <nshepperd> extra fancy would be fromFinite (Finite !n) = error (show n ++ " :: Finite 0")
22:03:31 <nshepperd> so that if you're a fool and abuse the internal interface to construct a Finite 0 containing a real integer, you get to see what integer it was in the error message
22:05:39 <nshepperd> > absurd (error "absurd is strict too")
22:05:41 <lambdabot>  *Exception: absurd is strict too
22:06:08 <koz_> iqubic: Yep. https://leanpub.com/thinking-with-types
22:06:17 <koz_> nshepperd: Those are awesome suggestions and I will definitely use them.
22:06:19 <iqubic> Why is it so expensive?
22:06:37 <koz_> That's between you and Sandy.
22:06:52 <iqubic> I don't know Sandy.
22:10:05 <koz_> mycroftiv: Unfortunately, those are the only two I know. Both interesting though.
22:12:03 <learninghaskell> i have filesnames.txt with a list of filenames, which I'm binding and then parse into a variable listOfFileNames of type [String]. I'm trying to read all of these files into a single list [String] in IO, but I can't figure out how to do this - anyone have any suggestions/can point me in the right direction?
22:12:08 <Ouyuegu> Hi there everyone- need a bit of help trying to install the Tidalcycles package using the "cabal install tidal" command. I keep getting a number of failures during the install (see below) any ideas what I can do to diagnose this problem?Thanks in advance for your help.Resolving dependencies...Configuring primitive-0.7.0.0...Failed to install primit
22:12:09 <Ouyuegu> ive-0.7.0.0Build log ( /Users/logictest/.cabal/logs/ghc-8.2.1/primitive-0.7.0.0-1rqSA3iNIcc2vIuRgdFLF1.log ):cabal: Entering directory '/var/folders/lq/dh20f9zx6dvgn16s3jyjrm4w0000gp/T/cabal-tmp-21392/primitive-0.7.0.0'cabal: Leaving directory '/var/folders/lq/dh20f9zx6dvgn16s3jyjrm4w0000gp/T/cabal-tmp-21392/primitive-0.7.0.0'cabal: Error: some pac
22:12:09 <Ouyuegu> kages failed to install:math-functions-0.3.1.0-6ECtSGapHdr4KRDqynQ8EC depends onmath-functions-0.3.1.0 which failed to install.mwc-random-0.14.0.0-AJQYEpWGrW8GMihfalrxUM depends on mwc-random-0.14.0.0which failed to install.primitive-0.7.0.0-1rqSA3iNIcc2vIuRgdFLF1 failed during the configure step. Theexception was:dieVerbatim: user error (cabal: Th
22:12:10 <Ouyuegu> e package 'primitive' requires Cabal libraryversion -any && >=2.2but no suitable version is installed.)tidal-1.4.0-6A9xRKbQvPvEi0h0zekF8V depends on tidal-1.4.0 which failed toinstall.vector-0.12.0.3-HqVH9N0dVY123yj19gotKT depends on vector-0.12.0.3 which failedto install.vector-th-unbox-0.2.1.6-FthS2tH3P1FFREv0mfEQpk depends onvector-th-unbox-0.2.
22:12:10 <Ouyuegu> 1.6 which failed to install.
22:12:46 <Ouyuegu> sorry- awful formatting on that message
22:13:07 <Ouyuegu> Resolving dependencies...<br>Configuring primitive-0.7.0.0...Failed to install primitive-0.7.0.0Build log ( /Users/logictest/.cabal/logs/ghc-8.2.1/primitive-0.7.0.0-1rqSA3iNIcc2vIuRgdFLF1.log ):cabal: Entering directory '/var/folders/lq/dh20f9zx6dvgn16s3jyjrm4w0000gp/T/cabal-tmp-21392/primitive-0.7.0.0'cabal: Leaving directory '/var/folders/lq/dh20
22:13:08 <Ouyuegu> f9zx6dvgn16s3jyjrm4w0000gp/T/cabal-tmp-21392/primitive-0.7.0.0'cabal: Error: some packages failed to install:math-functions-0.3.1.0-6ECtSGapHdr4KRDqynQ8EC depends onmath-functions-0.3.1.0 which failed to install.mwc-random-0.14.0.0-AJQYEpWGrW8GMihfalrxUM depends on mwc-random-0.14.0.0which failed to install.primitive-0.7.0.0-1rqSA3iNIcc2vIuRgdFLF1 
22:13:08 <Ouyuegu> failed during the configure step. Theexception was:dieVerbatim: user error (cabal: The package 'primitive' requires Cabal libraryversion -any && >=2.2but no suitable version is installed.)tidal-1.4.0-6A9xRKbQvPvEi0h0zekF8V depends on tidal-1.4.0 which failed toinstall.vector-0.12.0.3-HqVH9N0dVY123yj19gotKT depends on vector-0.12.0.3 which failedto 
22:13:09 <Ouyuegu> install.vector-th-unbox-0.2.1.6-FthS2tH3P1FFREv0mfEQpk depends onvector-th-unbox-0.2.1.6 which failed to install.
22:13:16 <koz_> Ouyuegu: Pastebin please.
22:13:19 <iqubic> Ouyuegu: Next time you have a lengthy error messae or a section of code you want to show us, can you please pastebin it, and just put a link here. We don't need that long message flooding the channel. Thanks.
22:13:39 <Ouyuegu> Sorry, didn't realise that would happen- not used this forum before.
22:13:52 <koz_> learninghaskell: Do I understand right that you want the final result to be [String], where each element is the contents of one of the files you get earlier?
22:14:14 <learninghaskell> yeah, that's right
22:14:47 <koz_> learninghaskell: Let's thing about what we've got going on here. Based on what I've read so far, you know how to read _one_ file into an IO String, right?
22:14:49 <learninghaskell> each String in [String] should be the contents from binding readFile(filename) for each of the filenames in my list of filenames
22:15:12 <learninghaskell> yeah
22:15:17 <Ouyuegu> I'll try again...
22:15:19 <Ouyuegu> https://pastebin.com/r88dfcBx
22:15:36 <koz_> Ouyuegu: Much better, thanks!
22:15:38 <Ouyuegu> Can someone take a look and help me out trying to figure out how to diagnose my issue?
22:15:51 <koz_> learninghaskell: OK, so we have [String], and a function String -> IO String.
22:16:08 <koz_> And what we want is IO [String].
22:16:18 <koz_> :t traverse
22:16:19 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
22:16:29 <koz_> Substitute t for [], and f for IO in that.
22:16:32 <koz_> What do you get?
22:16:49 <koz_> s/for/with/g
22:18:53 <koz_> Ouyuegu: What exactly did you run to get this output?
22:20:56 <Ouyuegu> koz_$  cabal install tidal
22:21:28 <koz_> Ouyuegu: What does cabal --version give you?
22:21:52 <Ouyuegu> cabal-install version 2.0.0.0compiled using version 2.0.0.2 of the Cabal library 
22:22:28 <koz_> That's fairly old. Current is 2.4.1.0. Is this from a system package?
22:22:28 <iqubic> Now that is an acceptable time to put the entire output here.
22:22:40 <iqubic> Ouyuegu: How did you install Cabal?
22:23:28 <Ouyuegu> how do i install the latest cabal version?
22:23:43 <iqubic> How did you install your current version of Cabal?
22:23:51 <koz_> Ouyuegu: There's a few ways. It would first help us to know how you got your current one.
22:25:35 <Ouyuegu> i followed instructions on Tidalcycles website-
22:25:37 <Ouyuegu> curl https://get-ghcup.haskell.org -sSf | sh
22:25:54 <Ouyuegu> curl -sSL https://get.haskellstack.org/ | sh
22:26:06 <koz_> Ouyuegu: So wait, did you do both of those?
22:26:07 <Ouyuegu>  cabal update
22:26:09 <koz_> Or just one?
22:26:18 <Ouyuegu> both...
22:26:30 <koz_> Both are generally not necessary.
22:27:18 <Ouyuegu> ok. Is there a way to remove everything and start again, then?
22:27:31 <koz_> Ouyuegu: Let me have a read of what they suggest so I have some idea what this might have involved.
22:28:04 <koz_> Ouyuegu: I guess you did these instructions? https://tidalcycles.org/index.php/Linux_installation
22:28:40 <Ouyuegu> no, the Mac OS ones: https://tidalcycles.org/index.php/MacOS_installation
22:28:47 <koz_> Ah, OK.
22:29:16 <koz_> Do you have a ~/.ghcup/bin directory?
22:30:01 <Ouyuegu> yes
22:30:07 <koz_> OK.
22:30:23 <koz_> Could you please run ~/.ghcup/bin/ghc --version and tell me what version that gives you?
22:30:33 <koz_> Also ~/.ghcup/bin/cabal --version
22:31:23 <Ouyuegu> The Glorious Glasgow Haskell Compilation System, version 8.6.5
22:31:34 <iqubic> koz_: I just purchased the ebook version of Thinking With Types. I hop I don't regret this.
22:31:41 <koz_> iqubic: You won't.
22:31:43 <iqubic> It was $50 USD.
22:32:24 <iqubic> Whoops..
22:32:50 <iqubic> Accidentally hit the wrong key binding and closed my #Haskell IRC window.
22:32:54 <iqubic> I'm still here.
22:33:02 <koz_> Ehh, happens to me all the time.
22:34:00 <koz_> Ouyuegu: OK, thanks. how about ~/.ghcup/bin/cabal --version?
22:34:32 <Ouyuegu> cabal-install version 2.4.1.0compiled using version 2.4.1.0 of the Cabal library 
22:34:36 <iqubic> Yeah. I've been using this tiling WM for like 1.5 years. I should know what keybindings I've set up. But it is what it is.
22:34:49 <jle`> iqubic: Obstruct is correct, i think, because it only makes sense to knock on a door that is closed or locked
22:34:52 <koz_> Ouyuegu: OK, it seems you have a _global_ Haskell install that's much older than your ghcup one.
22:35:02 <koz_> jle`: Yeah, the code is right, but the text below disagrees with it.
22:35:08 <koz_> Also welcome back - I solved my problem!
22:35:24 <jle`> ah i see, yes, that next paragraph is a problem haha
22:35:26 <jle`> koz_: hooray :D
22:35:44 <koz_> Ouyuegu: What you probably wanted to do was to use that one. Specifically, the instructions say "If you installed haskell with 'ghcup', then you may get command not found errors above. In that case, you try this instead: ".
22:35:50 <koz_> So try running those instead.
22:36:03 <koz_> jle`: It involved some wrangling, but it all works now, and I got everything I wanted.
22:36:24 <Ouyuegu> koz_: ok, i'll give that a go, thanks
22:36:32 <jle`> yup we're definitely in wild west territory
22:37:01 <iqubic> koz_: Here's a thing you can do, but most likely shouldn't: Create a Finitary instance for length indexed vectors.
22:37:09 <koz_> iqubic: You read my mind.
22:37:13 <koz_> It's on the cards.
22:37:16 <iqubic> Oh. I see.
22:37:19 <koz_> jle`: https://gist.github.com/kozross/06f89e04c2157ce17cd6013b72b6c089 if you're curious.
22:37:54 <jle`> was just going to ask :)
22:37:54 <koz_> That double withSomeSing is a particular point of pride for me.
22:38:29 <iqubic> Nested withSomeSing sounds hard.
22:38:37 <koz_> iqubic: It's really not - it's just tedious.
22:38:45 <koz_> Type holes are your friend definitely.
22:38:50 <iqubic> Which part has the double withSomeSing?
22:38:59 <koz_> https://gist.github.com/kozross/06f89e04c2157ce17cd6013b72b6c089#file-shape-hs-L61
22:39:25 <koz_> If that's meant to be some kind of pun, I am amused.
22:39:30 <koz_> (someSing is very nearly 'something')
22:40:02 <iqubic> It's not intended as a pun. I swear it was coincidental
22:40:12 * hackage list-witnesses 0.1.3.1 - Witnesses for working with type-level lists  https://hackage.haskell.org/package/list-witnesses-0.1.3.1 (jle)
22:40:32 <jle`> nice :)
22:40:42 <koz_> I'm actually happy I figured that out.
22:40:49 <jle`> you can actually get rid of the withSomeSing if you want with the FromSing pattern synonym
22:41:00 <koz_> Oh? Where is that defined?
22:41:04 <jle`> Data.Singletons
22:41:21 <jle`> DimVal (FromSing n) (FromSing sh) -> SomeSing (SDim n sh)
22:41:29 <koz_> Oh that's much nicer.
22:41:33 <koz_> Will definitely do that then.
22:41:41 <koz_> Also, is the name SomeShape appropriately used here?
22:41:43 <jle`> it's cute i think because it mirrors line 58
22:42:01 <koz_> In that case, it's _definitely_ being used.
22:42:08 <iqubic> This quote inspires me so much: "When people say 'but most business logic bugs aren’t type errors,' I just want to show them how to make bugs into type errors." -- Matt Parsons
22:42:17 <jle`> where you can write SDim n sh -> DimVal (FromSing n) (FromSing sh)
22:42:31 <jle`> iqubic: words to live by :)
22:42:51 <iqubic> Yeah. I just picked up the Ebook of Thinking With Types by Sandy Maguire.
22:43:07 <koz_> jle`: Translation - I'm helping sell Sandy's book. Again.
22:43:10 <iqubic> Looking forward to sinking my teeth into it.
22:43:26 <iqubic> koz_: That is what happened.
22:43:45 <jle`> koz_: it's closer to SomeSShape, to be consistent
22:43:56 <jle`> but i don't relaly know a better name
22:44:03 <koz_> jle`: Why SomeSShape?
22:44:49 <iqubic> Oh, this is a recent book. That good.
22:44:56 <jle`> it's exists s. SShape s
22:45:03 <koz_> Ah, OK.
22:45:06 <koz_> Yeah, that I get.
22:45:33 <iqubic> I know that type level programming in Haskell is always evolving, so a recent book on the subject is awesome.
22:45:34 <user1_> what means sshape
22:45:47 <koz_> user1_: Singleton for Shape.
22:45:49 <jle`> your SomeShape and Shape is really supposed to be the same type, ideally :'(
22:45:56 <koz_> jle`: Ideally yes.
22:46:00 <jle`> user1_: it's a user-defined type in a code snippet we were looking at
22:46:07 <iqubic> Haskell doesn't have a proper exists keyword, does it?
22:46:16 <koz_> Ideally we also wouldn't need a four-way construction for dependent types in Haskell, but yet here we are. :P
22:46:17 <jle`> not at the moment no
22:46:31 <jle`> user1_: it's not a part of haskell the language ... just a user-defined type :)
22:46:46 <iqubic> A four-way construction that is a pain to even begin to understand.
22:47:04 <jle`> koz_: i've seen some people calling it Shape and Shape'
22:47:14 <koz_> I dunno - singletons (the library) makes it about as logical as is reasonable under the circumstances.
22:47:16 <jle`> but the prime naming convention thing is always really weird for readability
22:47:28 <user1_> ok i get it
22:47:35 <koz_> jle`: That was my original plan. I decided SomeShape was a better choice not least of all because of that.
22:47:50 <iqubic> But you're fine with DataKinds using a prepended prime?
22:48:04 <jle`> maybe ShapeVal and ShapeKind, but that's kind of verbose and gets in the way of the intent maybe
22:48:11 <jle`> iqubic: that's not a naming convention, that's just syntax
22:48:20 <koz_> jle`: Yeah, I thought of that one too, but it is a bit verbose.
22:48:29 <koz_> ShapeDammitGHC
22:48:32 <jle`> * ShapeTerm, ShapeType ? yeah :|
22:48:39 <koz_> ShapeUseThisOneAtTheTypeLevel.
22:48:43 <jle`> i keep on using the word value where i mean to say term
22:49:24 <Ouyuegu> koz_: thanks for your help, it seems to be working fine now.
22:49:31 <iqubic> Why can't we just have types be first class citizens, dammit ghc.
22:49:37 <koz_> Ouyuegu: No problem! Have fun with Tidal.
22:49:47 <koz_> iqubic: It'll happen if Richard has his way.
22:49:54 <koz_> THere's a lot of subtleties there.
22:50:02 <koz_> And GHC is a pretty sophisticated piece of engineering already.
22:50:12 <koz_> (frankly, it's smarter than me on numerous counts at this point)
22:50:14 <iqubic> I want my dependent types, and I want them now. Is that to much to ask for, dammit??
22:50:27 <koz_> iqubic: You can have them with singletons (the library and I guess the concept)?
22:50:39 <iqubic> koz_: hlint is also a super advanced too.
22:50:58 <jle`> it's tricky, i still think the idea that dependent types can be generally useful or worth the weight is still controversial
22:51:02 <jle`> i'm not totally convinced
22:51:24 <iqubic> But you wrote a 4 part blog post on the subject.
22:51:34 <jle`> i think it's worth investigating
22:51:35 <koz_> iqubic: You gotta understand something to meaningfully critique it.
22:51:41 <iqubic> I see.
22:52:07 <koz_> Frankly, my opinion is close to Edwin, Conor and, in a way, Voevodsky.
22:52:15 <koz_> (although the last of those in a _very_ indirect sense)
22:52:35 <iqubic> My lack of knowledge is why I currently do not know know what my opinions on dependent types are.
22:53:34 <iqubic> "But make no mistake—this book is primarily about reducing thecircumstances under which a program compiles." I love that. I love it so much.
22:54:06 <koz_> Sandy's writing style is.. interesting.
22:54:49 <iqubic> I like it... I think...
22:55:22 <koz_> Interestingly, jle`'s writing helped me see the benefits of dependent typing in a very practical way.
22:55:30 <koz_> (which is why I can't stop doing it now)
23:01:14 <iqubic> can we please create a type safe printf? Please?
23:01:31 <koz_> iqubic: Thinking with Types does this.
23:01:34 <koz_> (forget which chapter)
23:01:52 <iqubic> Oh. I see.
23:02:32 <iqubic> All I know is that the introduction states that it can be done.
23:03:16 <iqubic> koz_: Why did you call it Finitary, and not Cardinality?
23:03:35 <koz_> iqubic: I guess I felt an adjective more suitable here than a noun?
23:03:42 <koz_> Arguments can be made for Cardinality as a name though.
23:04:01 * koz_ mumbles something about there only being ten hard problems in computer science.
23:04:24 <MarcelineVQ> jle`: "jle`'s writing helped me see the benefits of dependent typing in a very practical way." monochrom's gonna come get you :O
23:04:45 <koz_> MarcelineVQ: I think I'm the one that needs to worry.
23:06:59 <user1_> nothing to worry
23:07:05 <jle`> iqubic: i think we have a type-safe printf already :O
23:07:23 <koz_> jle`: Is that the one in base?
23:26:00 <jle`> no, that one is not type-safe :'(
23:26:41 <jle`> well there are a few designs
23:34:12 <maerwald> type-safe printf is one of those things no one needs imo
23:35:31 <orzo> I have a terminology question regarding the term "continuation".  Suppose I have a church-encoded vector: a function that applies its argument to a bunch of values.  Is it proper to call this vector a "continuation" or would is it more apt to refer to the function you pass to it that receives the values as a "continuation" or both?
23:37:05 <jle`> orzo: i'd call the function you pass a continuation, and the encoded vector CPS style, maybe
23:37:33 <jle`> maerwald: i'd say that too, but it's bitten me in the past
23:37:37 <slack1256> Not an expert, but I would call the first alternative, that vector "a continuation" because it reifies the program flow as a continuation function. The second alternative is just the binding to a concrete function of the continuation.
23:37:51 <jle`> a quick edit-and-compile-and-run loop
23:37:57 <jle`> to run a computation that takes 10 minutes
23:38:05 <jle`> only to have it runtime error when i try to print out the result
23:38:14 <maerwald> jle`: if I use printf I sanitize the input before and all I care is that (if I really got it wrong, which is unlikely) that it doesn't crash and is memory safe
23:38:22 <slack1256> I also call the second argument of (>>=) a continuation for this reason.
23:38:33 <jle`> maerwald: i'm talking more about iterative/exploratory usage
23:38:45 <jle`> where i make a small change, compile, and run to observe the changes
23:39:06 <jle`> i've been bitten by losing a lot of computation time to this, heh
23:39:07 <maerwald> design > types ;P
23:39:44 <jle`> they can work together :)
23:40:00 <orzo> the second argument to >>= seems more like the argument to the vector that jle` would call continuation rather than the vector which i was understanding you were advocating for the title
23:40:46 <maerwald> jle`: sometimes
23:40:52 <slack1256> orzo: Re-reading what jle` wrote, I agree.
23:43:20 <orzo> the cps-style descriptor seems wrong as i'm explicitly using this vector as data and have even wrapped the function in a newtype so that it can be treated like most other data normally
23:44:52 <orzo> i guess church-encoded is the best description
23:46:14 <orzo> the package fixed-vector implements these things cand calls them continuations
23:52:18 <orzo> reading wikipedia, i think church-encoding might not be very good since it seems to imply lambda-calculus, whereas i have primitive types in the vector that i'm not representing as lambdas
23:52:55 <maerwald> is there a class of things that are convertible to Either?
23:54:41 <orzo> theres the MonadError class
23:54:54 <maerwald> without being a Monad
23:56:35 <orzo> you can convert any trivial empty functor to another such via fmap undefined
23:58:11 <maerwald> ?
