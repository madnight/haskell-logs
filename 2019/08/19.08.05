00:44:41 <sim590> I,m trying to validate input from IO: https://paste.debian.net/1094401/. How can I directly put getLine's result into baseConv (and hauteurConv) instead of passing through base (and conv)?
00:44:57 <sim590> base (and hauteur) that is.
00:46:01 <Rembane> sim590: <$> could be of help. 
00:46:04 <Rembane> :t (<$>)
00:46:06 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:46:12 <sim590> I don't like that getLine is not called directly with readMaybe. I can't figure out how to put them together,.
00:46:37 <sim590> Rembane: OK. I will look into that.
00:47:52 <Rembane> sim590: Something like this: md <- (readMaybe :: Maybe Double) <$> getLine 
00:53:53 <merijn> Rembane: That type signature seems like it would certainly fail :p
00:54:29 <sim590> it does fail. I'm not sure what to do. I don't understand functors yet.
00:54:37 <int-e> :t readMaybe
00:54:39 <lambdabot> error: Variable not in scope: readMaybe
00:54:52 <merijn> :t Text.Read.readMaybe
00:54:54 <lambdabot> Read a => String -> Maybe a
00:55:17 <merijn> :t fmap readMaybe `asAppliedTo` (undefined :: IO String)
00:55:19 <lambdabot> error:
00:55:19 <lambdabot>     Variable not in scope: readMaybe :: String -> b
00:55:26 <merijn> :t fmap Text.Read.readMaybe `asAppliedTo` (undefined :: IO String)
00:55:29 <lambdabot> Read a => IO String -> IO (Maybe a)
00:55:34 <merijn> bah, made the same mistake myself >.>
00:55:56 <Rembane> merijn: Good point. :D
00:56:28 <Rembane> merijn: In my imaginary world fail doesn't exist. So I have a tendency to ignore it. 
00:56:37 <dminuoso> sim590: Putting them together is captured by MaybeT.
00:56:59 <merijn> Rembane: My point was that readMaybe is a function, but your type signature wasn't a function :p
00:57:58 <int-e> md :: Maybe Double <- ...  mayb be cleanest (but needs the ScopedTypeVariables extension)
00:58:09 <Rembane> merijn: That's true. :)
00:58:15 <sim590> dminuoso: I don't understand.
01:04:15 <dminuoso> sim590: Oh I guess not. But anyway, creating a separate binding might actually be the cleanest.
01:04:54 <sim590> is a "binding" a name for the returned value by getLine?
01:05:21 <dminuoso> sim590: e.g. ⌜readM :: String -> IO Double; readM b = fromNothing (error "La base n'est pas un nombre.") (readMaybe b)⌝
01:05:38 <dminuoso> sim590: And then just use ⌜readM⌝ in your code
01:05:49 <dminuoso> oh actually
01:06:02 <dminuoso>  ⌜readM :: String -> IO Double; readM b = maybe (error "La base n'est pas un nombre.") pure (readMaybe b)⌝
01:06:20 <dminuoso> Noting that the choice of "error" there is not ideal.
01:07:45 <dminuoso> sim590: A binding is what you get by specifying ⌜identifier = expr⌝ because it binds ⌜identifier⌝ to some ⌜expr⌝
01:08:01 <dminuoso> that is, a declaration.
01:08:30 <dminuoso> (a binding is a special kind of declaration)
01:10:32 <ski> @type readIO
01:10:34 <lambdabot> Read a => String -> IO a
01:12:01 <sim590> All I want is that I don't have to do the line of code `base <- getLine` ... That's rather simple in other languages. Can't I do that here? I thought that I could do something like "case readMaybe {something} getLine of {...}". Is it not possible?
01:13:19 <Rembane> LambdaCase! :D
01:14:46 <ski>   readMaybe <$> getLine >>= \case
01:14:53 <ski>     Nothing -> ...
01:15:03 <ski>     Just x  -> ..x..
01:15:32 <merijn> I don't think all the 20 different variations including extensions is really conducive to sim590's understanding of what's going on and why things didn't work...
01:15:42 <ski> `readIO' will just raise an I/O exception, on parse failure
01:16:34 <dmwit> readLn?
01:16:41 <merijn> dmwit: Also throws
01:16:45 <merijn> :t readLn
01:16:47 <lambdabot> Read a => IO a
01:16:54 <dmwit> Isn't that the intended coping strat?
01:17:17 <merijn> dmwit: Intended by whom?
01:17:26 * dmwit shrugs
01:17:35 <dmwit> You said it as if you were objecting. Perhaps you weren't.
01:18:17 <ski> er, `readLn' i mean, yea
01:18:26 <merijn> dmwit: I do object :p I prefer clear/explicit failure cases for code I recommend to beginners
01:24:14 <sim590> ski: I don't understand. \case is not the same as "case". What's going on? I get the error "error: parse error on input ‘case’" when compiling.
01:24:45 <sim590> I've tried this: https://paste.debian.net/1094405/
01:24:50 <ski> `\case' requires the `LambdaCase' extension, that Rembane mentioned
01:25:31 <ski> the only point of using `\case', is avoiding having to name the intermediate result that executing `readMaybe <$> getLine' gives you
01:25:32 <merijn> Using LambdaCase si really not helping
01:25:39 <sim590> Is an extension the same as a library?
01:25:43 <ski> no
01:26:00 <ski> if you name the intermediate result, it will look like
01:26:14 <ski>   mx <- readMaybe <$> getLine
01:26:17 <ski>   case mx of
01:26:22 <ski>     Nothing -> ...
01:26:27 <merijn> sim590: There's nothing wrong with the approach on line 14-17
01:26:28 <ski>     Just x  -> ..x..
01:26:56 <merijn> sim590: It's a little more verbose, but that's fine when you're just getting the hang of things
01:27:51 <ski> (you can't say `case ..(readMaybe <$> getLine).. of Nothing -> ...; Just x -> ..x..'. can't put an I/O-action inbetween `case' and `of', in that way)
01:28:01 <sim590> In every languages I use, I normally don't like naming some output value of a function that I have to convert to use anyway and then only use the converted value. Therefore, I get a named value that is not used.
01:28:33 <ski> hence i brought up `\case'
01:29:30 <sim590> OK, but then adding that extension, does that generate a dependency on runtime or is it just at compile time?
01:29:52 <ski> it's just a compile time flag thing, telling the compiler that you're using this syntactic extension
01:30:17 <ski> (to turn on the language extension `LambdaCase', you'd put `{-# LANGUAGE LambdaCase #-}' at the top of your module (above the `module ...' line, if any))
01:30:53 <sim590> But then I have to install the extension, right?
01:30:55 <ski> (and it's a "benign" or pretty reasonable extension)
01:31:10 <ski> nope, with a recent enought compiler you just have to turn it on
01:31:48 <ski> (i don't recall when it was added to GHC, but unless you're using an ancient system, i think you should have it)
01:32:34 <Taneb> 7.6
01:32:41 <ski> `LambdaCase' just allows you to write \case ..branches here..', rather than `\foo -> case foo of ..branches here..'
01:33:02 <Taneb> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#lambda-case
01:33:14 <ski> the `mx <- readMaybe <$> getLine; case mx of ...' above is the same as
01:33:27 <ski>   readMaybe <$> getLine >>= \mx -> case mx of
01:33:30 <ski>     ...
01:34:02 * ski hopes this isn't muddling things together too much for sim590
01:34:19 <ski> (but you did ask to avoid naming the intermediate)
01:36:20 <ski> i see in your case you have `Just x -> return x' .. in this case, it might perhaps be nicer to use the utility function `maybe' (which internally just does pattern-matching on the `Maybe', with a `case' if you will)
01:36:24 <int-e> what a way to go... buried in syntactic sugar.
01:36:45 * ski nods
01:37:26 <ski>   baseConv <- maybe (error "...") return . readMaybe <$> getLine
01:37:34 <merijn> tbh, I think the more beginner friendly approach would've just been to write a helper function for reading lines >.>
01:40:37 <Rembane> The horror of #haskell, the tendency to enumerate ALL solutions to a problem. :)
01:42:30 <int-e> @quote fugue
01:42:30 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
01:43:19 <merijn> sim590: Ok, my recommended solution (which ditches all the fancy operators and extensions, and does more sensible error handling too!): https://paste.debian.net/1094407/
01:43:26 * ski supposes sim590 could also try out merijn suggestion, *if* they feel like trying out that alternative, to see how it differs, and how it's alike
01:43:47 <Rembane> int-e: Exactly! 
01:44:42 <merijn> I mean, for all the effort in all the other versions they still handle any errors in a lousy way...
01:46:22 <ski> yea (i was only considering refactorings, preserving the possibly lousy error checking behaviour, expressing it differently, syntaxtically)
01:46:39 * ski looks at sim590
01:47:29 <sim590> merijn: Why `readConversion errorMsg` at the end of `readConversion` function?
01:47:38 <ski> sim590 : to try again
01:47:46 <int-e> merijn: I like the "Try again" :)
01:48:02 <merijn> sim590: If it fails (because the input is not a number) it will rerun readConversion to read a new line and retry
01:48:21 <merijn> sim590: Basically, it retries until you *do* enter a number
01:48:37 <ski> (that may or may not be what you really wanted. but it's good to see how you'd do that, if you wanted to)
01:48:40 <sim590> Oh right OK.
01:49:57 * ski would also say `putStrLn (show (base * hauteur / 2))', or at least `putStrLn $ show (base * hauteur / 2)' (or maybe `(putStrLn . show) (base * hauteur / 2)')
01:49:58 * hackage registry 0.1.6.3 - data structure for assembling components  https://hackage.haskell.org/package/registry-0.1.6.3 (etorreborre)
01:50:04 <ski> though in this particular case
01:50:08 <ski> @src print
01:50:08 <lambdabot> print x = putStrLn (show x)
01:50:24 <ski> so it just becomes `print (base * hauteur / 2)'
01:53:46 <ski> sim590 : oh, it's also good to know that it'll default to using `Double' (since you used `/'), because there's nothing telling it to use another (fractional) number type (like e.g. `Rational' or `Float' or `Complex Double')
01:54:16 <sim590> Yes. I removed the :: part.
01:56:35 * ski supposes `Rational' and `Complex Double' would be less than ideal here (even disregarding that it probably doesn't make much sense to have a triangle with proper complex base or height ..)
01:56:59 <ski> > read "2" :: Double
01:57:02 <lambdabot>  2.0
01:57:04 <ski> > read "2" :: Rational
01:57:07 <lambdabot>  *Exception: Prelude.read: no parse
01:57:09 <ski> > read "2 % 1" :: Rational
01:57:13 <lambdabot>  2 % 1
01:57:14 <ski> > read "2" :: Complex Double
01:57:18 <lambdabot>  *Exception: Prelude.read: no parse
01:57:21 <ski> > read "2 :+ 0" :: Complex Double
01:57:24 <lambdabot>  2.0 :+ 0.0
02:00:00 <ski> (would it make sense to extend the `Read' instances to also parse those (more trivial/simple) cases ? the instances for `Float' and `Double' already parses ones without a decimal point)
02:00:46 <merijn> tbh, no
02:00:56 <merijn> Because that'd just encourage people to use Read
02:01:22 <ski> (also, why is `2.' and `.5' not a thing ?)
02:01:51 <int-e> :t (2.)
02:01:53 <lambdabot> Num (b -> c) => (a -> b) -> a -> c
02:02:13 <int-e> I suspect that kind of ambiguity is why.
02:02:24 <ski> perhaps so
02:02:26 <int-e> > [2..]
02:02:29 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
02:02:45 <int-e> (perhaps that is more convincing)
02:02:57 <int-e> > [2..5] -- should've used this, of course.
02:03:01 <lambdabot>  [2,3,4,5]
02:03:30 <ski> > [2. ..4]
02:03:32 <lambdabot>  error:
02:03:32 <lambdabot>      A section must be enclosed in parentheses thus: (2 .)
02:03:45 <ski> i can't recall seeing that before
02:04:22 <int-e> :t 1.2.3.4 -- the current situation is confusing, of course
02:04:24 <lambdabot> (Fractional (b -> c), Fractional (a -> b)) => a -> c
02:04:41 * ski nods
02:05:30 <ski> i suppose one answer to my question could be that `%' and `:+' isn't part of numeric literal syntax
02:05:36 <ski> (unlike in Scheme, say)
02:06:26 <ski> > read "- 5" :: Double  -- hmm
02:06:29 <lambdabot>  -5.0
02:06:32 <int-e> Read is supposed to be the counterpart to Show, and Show is supposed to produce valid Haskell expressions.
02:07:24 <ski> (one could also ponder allowing say `_' in numeric literals, as extra spacing)
02:07:36 <int-e> (And I keep violating these rules in one-off code for convenience reasons. I suppose I'm not along in that.)
02:07:48 <int-e> *alone
02:09:03 * ski tends to usually go the extra step to make sure `Read' can handle what `Show' produces, and that it produces valid Haskell
02:09:30 <ski> > 0/0  -- and this is infuriating :)
02:09:33 <lambdabot>  NaN
02:10:01 <ski> > mkStdGen 1234  -- and this even more. also various exception types
02:10:04 <lambdabot>  1235 1
02:10:21 <merijn> ski: What's infuriating about the 0/0 case?
02:10:27 <int-e> > NaN
02:10:28 <ski> > NaN
02:10:30 <lambdabot>  error: Data constructor not in scope: NaN
02:10:30 <lambdabot>  error: Data constructor not in scope: NaN
02:10:39 <ski> (ditto for infinities)
02:10:55 <aveltras> anyone using haskell ide engine with nix ? is there a way to prevent it to use classic cabal to get packages information ? Right now it complains about a missing dependency for "morpheus-graphql" even if it's on hackage
02:11:04 <merijn> Time for a pattern synonym for Infinity ;)
02:11:14 <ski> heh :)
02:11:28 <merijn> But not for NaN, as that runs counter to my propaganda with carter to rid Haskell of value NaNs
02:11:32 <iqubic> I love that.
02:11:43 <merijn> Join our crusade!
02:11:52 <iqubic> type Time = Infinity
02:12:16 <ski> merijn : i suppose a pattern synonym would actually be a reasonable thing to suggest, in this case. ty
02:12:18 <Taneb> > read "NaN" :: Float
02:12:21 <lambdabot>  NaN
02:12:27 * ski nods
02:12:48 <ski> iqubic ?
02:13:02 <merijn> Value NaNs are an abomination unto the lord, all hail our trapping NaN overlord!
02:13:17 <Taneb> Ah, I missed ski also saying "valid Haskell" in the same line
02:14:34 <ski> merijn : would it still conform to IEEE 754 ?
02:14:41 <merijn> ski: Yes, that's the beauty :)
02:15:01 <merijn> ski: IEEE explicitly allows for both trapping and value based interpretations of NaN
02:15:11 <int-e> It's probably fine until you do FFI with numeric libraries...
02:15:19 <merijn> ski: The only real reason value NaN is in there is because not all micro controllers can reasonably trap
02:15:21 <ski> and it'd generate an imprecise exception, then ?
02:15:26 <merijn> ski: Yeah
02:15:29 <merijn> int-e: How so?
02:15:54 <merijn> int-e: Trapping on NaN is a CPU setting, unless your numeric library touches those CPU flags it'd still work, that's the beauty!
02:16:14 <int-e> merijn: You mean it'll trap when I don't want it to :P
02:16:47 <ski> `(==)' violating `forall x y. x == y = True => x = y' for `Float' and `Double' is really a wart
02:16:57 <merijn> int-e: There was some email discussion in the past, the idea is to make value NaN opt-in instead of the default
02:17:13 <merijn> ski: The beauty of trapping NaN is that that wrongness goes away too ;)
02:17:30 <int-e> (TBH I don't know how common it is to rely on NaNs in numerical code. I expect it's rare, but I wouldn't want to debug it when it happens.)
02:17:46 <ski> (and i kinda wish Haskell had a language feature for indicating that you have a factor/quotient type (when doing abstract data types), like Mercury does)
02:17:58 <merijn> int-e: If you get NaN in your output you're already super boned
02:18:08 <merijn> int-e: For example, it completely breaks Set
02:18:26 <ski> (Mercury really needs to, since it uses (=)/2 both for equality checking, and for binding purposes, which Haskell doesn't)
02:19:15 <ggole> Sets of floats is a pretty dodgy proposition from the start tbh
02:19:29 <int-e> merijn: I know about the broken Ord instance. I'd be okay with failing a conversion of an NaN CDouble to a Double.
02:19:45 <merijn> ggole: In my case I was trying to sort vectors of doubles
02:19:53 <int-e> merijn: I'm, perhaps irrationally, worried about breaking code that relies on non-trapping NaNs internally.
02:20:06 <int-e> (foreign code)
02:20:38 <ggole> Right, it would be nice if that worked.
02:26:39 * ski recalls the type being named `real' in SML
02:29:27 * hackage monad-validate 1.1.0.0 - A monad transformer for data validation.  https://hackage.haskell.org/package/monad-validate-1.1.0.0 (lexi_lambda)
02:55:39 <dminuoso> So it occured to me, that even the Num instances for Double and Float are morally incorrect since IEEE 754 operations are not associative.
02:55:43 <dminuoso> They are just "almost associative".
02:59:45 <ski> yes
03:00:01 <ski> imprecise arithmetic is a mess :/
03:00:38 <ski> (or would it be called "inexact" ?)
03:01:03 <opqdonut> inconvenient?
03:01:18 <no-n> incompetent arithmetic
03:02:47 <int-e> dminuoso: But convenience trumps correctness.
03:04:08 <int-e> (at least as long as we don't allow the compiler to use those laws)
03:04:45 * ski . o O ( numerical analysis,numerically stable algorithm,well- vs. ill- conditioned problem )
03:05:45 <ski> hm, could the monad laws of some probability monad depend on associativity and distributivity ?
03:06:59 <int-e> They probably do. Commutativity too (though I guess that's not an issue).
03:07:40 <ski> (hm, seems that it's called "inexact", in Scheme, at least)
03:08:07 * ski nods
03:08:27 <ski> @where floating-point
03:08:27 <lambdabot> "What Every Programmer Should Know About Floating-Point Arithmetic" at <http://floating-point-gui.de/> and "What Every Computer Scientist Should Know About Floating-Point Arithmetic" by David
03:08:27 <lambdabot> Goldberg in 1991 at <http://docs.sun.com/source/806-3568/ncg_goldberg.html> and <http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.102.244>
03:11:49 <int-e> ski: I suppose it depends on the precise formulation of the probability monad (you can always use Codensity after all and the monad laws will hold). If you use a list-like monad, [(Double,a)], then distributivity and associativity certainly play a role.
03:12:33 <int-e> (Or some other Fractional type instead of Double.)
03:13:01 <int-e> hmm
03:14:43 <dminuoso> int-e: If that were true, then all laws associated with typeclasses would be just "suggestions". I mean we tend to respect typeclass laws on the basis of being able to refactor code.
03:14:44 <int-e> Actually that only uses asociativity of multiplication... distributivity comes up when you collapse equal intermediate states.
03:15:59 <dminuoso> int-e: Since, for example, the compiler doesn't actually use (I'm out on a limb a bit here, it's just an educated guess) associativity laws of Monad for example.
03:16:03 <int-e> dminuoso: So what laws does the compiler actually rely on? I can only think of Monad and Arrow laws in the context of do notation...
03:16:16 <int-e> (let's say "the compiler" is ghc to keep this simple)
03:16:46 <dminuoso> int-e: What about the identity law then?
03:17:06 <dminuoso> As far as I can tell GHC does not rely on that in do-notation, does it?
03:17:22 <int-e> Actually 'do' notation is completely specified for monads so again it won't rely on any laws there.
03:17:55 <dminuoso> int-e: Surely you would agree that writing a Monad instance for ZipList would be a bad idea though, wouldn't you?
03:18:47 <dminuoso> (Im not actually sure whether there's proof that a valid Monad instance cant exist, lets just assume for the sake of the argument that it cant)
03:19:00 <int-e> Heh I'm confused about whether that's a law-abiding monad or not.
03:19:30 <dminuoso> int-e: As far as I know any type checking implementation would violate associativity.
03:22:04 <int-e> dminuoso: I guess I'll have to work it out.
03:22:53 <dminuoso> int-e: Anyway, my argument is not about ZipList in particular. Hence my suggestion to assume one cant write a lawful monad instance.
03:22:57 <int-e> dminuoso: Anyway, Arrow 'do' notation is the only thing I can think of that (as far as I'm aware) is so underspecified (namely, how exactly intermediate results are tupled) that the outcome would be unpredictable without the Arrow laws.
03:23:10 <dminuoso> Mmm
03:23:42 <dminuoso> Now I know that arrow do-notation exists, and at some point I even learned what it did - but honestly I cant remember what it is and what it does.
03:24:05 <dminuoso> Presumably its useful for arrow frp?
03:24:54 <ski> (hm, i have a vague memory i did make a law-abiding instance, at one point .. by introducing more bottoms than what one's expect, i think)
03:25:23 <ski> (perhaps i didn't actually go through with it completely, but that was the aim, i think)
03:26:00 <int-e> dminuoso: I have not used arrow notation (much), but basically it's syntactic sugar that saves you the effort of lifting individual arrows c -> c' to tuples (a,b,c,d,e) -> (a,b,c',d,e) when you work on several values simultaneously.
03:26:37 <int-e> (Hmm, I shoul write ~> instead of -> there)
03:26:37 <ski> it's sortof like an internal language in a topos thing
03:26:51 * ski misses variable type operators
03:28:06 <int-e> Oh https://www.haskell.org/arrows/syntax.html has some nice diagrams :)
03:29:36 * ski idly ponders the constant vs. variable distinction, in Haskell,Prolog,Mercury,lambdaProlog,Twelf in the context of implicit quantification insertion
03:32:06 <asheshambasta> Are case statements inside of ApplicativeDo allowed? 
03:34:59 <int-e> dminuoso: Ah, it's not just `do` notation. Control.Arrow has RULES that rely on the Arrow laws.
03:35:43 <ski> hm, i don't think there are any `case' commands at all (except with `proc')
03:35:47 <int-e> dminuoso: https://gitlab.haskell.org/ghc/ghc/blob/master/libraries/base/Control/Arrow.hs#L127-142 and there's another RULES block further down in the same file.
03:36:33 <ski> asheshambasta ^
03:38:34 <asheshambasta> thanks; but my question is unrelated to arrows; I'd just be able to do: `do x <- xpr1; y <- xpr2; case y of Foo -> pure $ Something ; Bar -> pure $ SomethingElse ` 
03:38:55 <ski> asheshambasta : in any case, `case'-*expressions* are allowed. but any further `do' inside will be a separate thing
03:38:59 <int-e> dminuoso: So getting back to the non-law-abiding monad case, I think it's a terrible idea, but it nevertheless leads to predictable results.
03:39:01 <ski> (a nested thing)
03:39:09 <asheshambasta> and GHC seems to complain about a missing monad instance 
03:39:24 <ski> interesting case, asheshambasta
03:39:39 <ski> hmm
03:39:43 <int-e> dminuoso: (It's terrible because as a programmer, one might rely on monad laws to refactor code... and that can obviously go wrong if they don't hold.)
03:40:27 <ski> asheshambasta : actually, you're (at least on the surface of it) depending on run-time results, so that's monadic ("dynamic") sequencing, not merely idiomatic ("static") sequencing
03:40:43 <ski> (and if you count bottoms, there is a difference)
03:40:58 <ski> asheshambasta : in your case, however, factor out the `pure' from the branches
03:41:25 <asheshambasta> ski: as in replace pure with something else? 
03:41:33 <ski> asheshambasta : no, factor it out
03:42:31 <asheshambasta> okay; interesting
03:42:35 <jacks2> is there a base function that can pad leading 0s in front of a number? maybe let num = 1 in <somefun> 3 num  ->  "001"
03:42:53 <ski> instead of `case ... of ... -> pure (...); ...', do `pure case ... of ... -> ...; ...'
03:43:18 <ski> (with `BlockArguments', or with `$' if you insist)
03:44:14 <asheshambasta> ski: https://gist.github.com/asheshambasta/13b02cfe72b53b0893e863f69373e3e3 doesn't seem to do the trick though. 
03:44:30 <ski> (the bottom / definedness difference here is that in case the scrutinee is bottom, the former will be bottom, but the latter won't (assuming the scrutinee is forced, which is the case here))
03:45:49 <ski> asheshambasta : you don't (only) have `pure (...)' in the branch bodies, there
03:47:05 <ski> that `jsonRead' definition looks like it's actually wanting to do dynamic sequencing
03:48:39 <ski> (perhaps your `do x <- xpr1; y <- xpr2; case y of Foo -> pure Something; Bar -> pure SomethingElse' wasn't representative of what you actually wanted to do. i used the fact that every branch was of the form `pure (...)' there, but that's not the case in your paste)
03:50:02 <asheshambasta> I see; however, the pure at the top level of the case is quite limiting; in this case; I want to read values that fit into one of 2 data constructors with differing numbers of arguments and therfore different constraints.
03:50:29 <asheshambasta> For example; data SpecialHrsNoId = SpeciallyOpen !Reason !(NonEmpty Hours) | SpeciallyClosed !Reason 
03:50:36 <ski> asheshambasta : if you have a definite set of `RangeState' you want to handle, i suggest using `<|>' with branches including code which succeeds parsing the individual various options
03:50:48 <asheshambasta> So depending on the reason; I'd like to be able to constrain on the constructors 
03:50:57 <ski> (assuming `Alternative JsRead' holds)
03:52:32 <ski> so, you could have `readSpeciallyOpen :: JsRead (Reason,NonEmpty Hours)' and `readSpeciallyClosed :: JsRead Reason'
03:53:17 <asheshambasta> ski: ah yes! Correct. 
03:53:28 <ski> oh, sorry, `SpeciallyClosed' is what you wanted to generate
03:53:46 <ski> well, let's say
03:54:08 <ski>   eatOpen,eatClosed :: JsRead ()
03:57:25 <ski> and then you'd have something like
03:57:33 <ski>       SpeciallyOpen   <$ eatOpen   <*> jsonRead
03:57:35 <ski>   <|> SpeciallyClosed <$ eatClosed <*> jsonRead
03:57:37 <ski> i suppose ?
03:58:00 <asheshambasta> ski: yeah; something like that should do the trick here.
03:58:01 <ski> (i didn't see your `Closed -> SpeciallyClosed <$> jsonRead' branch, i'm just assuming that's what you had)
03:58:31 <ski> anyway, this is the standard trick to do this kind of thing idiomatically, like in parsers
03:58:34 <int-e> presumably the code is pretty much there in the JSONRead instance for RangeState.
03:59:00 <int-e> (the code for eatOpen respectively eatClosed that is)
03:59:34 <ski> oh, i suppose `SpeciallyOpen' has two separate arguments
03:59:45 <asheshambasta> RangeState has no role but to translate the json intention to the data constructors in Haskell; and I think it will cause more ambiguities than solve them, I think I should remove that field altogether from the JSON schema. 
03:59:55 <ski> so add `<*> jsonRead' to the end of the first alternative, i suppose
04:00:06 <ski> or use `uncurry' or something
04:00:07 <asheshambasta> And instead; rely on the list of "hours" being empty/nonEmpty to encode that information. 
04:01:26 <asheshambasta> so I get: https://gist.github.com/asheshambasta/13b02cfe72b53b0893e863f69373e3e3#file-alternative-hs
04:01:59 <asheshambasta> basically; eagerly try to parse the hours list; if non-empty; succeed; if not, fallback to assuming closed 
04:02:45 <int-e> but now you're ignoring the "type" field completely
04:03:08 <asheshambasta> yeah; I realise now that the type field was adding ambiguity, if anything. 
04:03:29 <asheshambasta> what if: type = Open and hours = [] 
04:03:36 <ski> oh, there's no part in the format corresponding to `readAt "type"' ?
04:03:51 <ski> (or perhaps you just removed it)
04:04:12 <asheshambasta> that would be one more illegal state to handle; instead if the hours list is  non-empty; I assume that it means a specially open value. 
04:04:26 <ski> asheshambasta : dunno, would that be a valid `SpecialHrsNoId' ?
04:05:14 <asheshambasta> no; `data SpecialHrsNoId = SpeciallyClosed !Reason | SpeciallyOpen !Reason !(NonEmpty Hour)`
04:05:22 <ski> if there's no hours part, would you prefer to parse as `SpeciallyClosed' ?
04:05:31 <ski> if there's an empty hours part, would you prefer to parse as `SpeciallyClosed' ?
04:05:45 <asheshambasta> yes 
04:05:55 <ski> to which of those ? :)
04:05:58 * hackage pretty-simple 3.0.0.0 - pretty printer for data types with a 'Show' instance.  https://hackage.haskell.org/package/pretty-simple-3.0.0.0 (cdepillabout)
04:06:29 <asheshambasta> ski: more like: if hours field is present; it must be non-empty. 
04:07:00 <ski> you could probably factor out the parsing of the first `Reason' part (assuming you don't have, or just removed, a preceding "type" part)
04:07:07 <asheshambasta> actually no. If hours part is present and is non-empty; read as SpeciallyOpen; in all other cases, read as SpeciallyClosed 
04:07:55 <ski> ok, so yes to both questions
04:08:09 <asheshambasta> yeah
04:08:27 * hackage log4hs 0.0.4.0 - A python logging style log library  https://hackage.haskell.org/package/log4hs-0.0.4.0 (gqk007)
04:08:50 <asheshambasta> this was quite enlightening; thanks ski 
04:09:26 <ski>   buildSpecialHrsNoId <$> jsonRead <*> optional (readAt "single_day_hours")
04:10:04 <ski>   buildSpecialHrsNoId :: Reason -> Maybe [Hours] -> SpecialHrsNoId
04:10:07 <ski> perhaps
04:10:48 <asheshambasta> ski: yeah, that will be better 
04:10:51 <ski> (where you check for `Nothing' and empty, in `buildSpecialHrsNoId')
04:11:25 * ski doesn't know how `JSONRead' instances for `[Hours]' and `NonEmpty Hours' will differ
04:11:37 <ski> but i imagine something like that could work
04:12:31 <ski> btw, answering "yes" to "if there's an empty hours part, would you prefer to parse as `SpeciallyClosed' ?" is not obvious to me
04:12:50 <ski> (but i don't know details of what you're doing, so ..)
04:13:50 <asheshambasta> ski: yes, in that case I'd like to be able to parse as SpeciallyClosed; in all cases outside of non-empty "hours" field, we should parse as SpeciallyClosed 
04:14:17 * ski will take asheshambasta's word for it
04:16:13 <ski> (it's just that often, it's better to loudly complain about strange/weird, or unexpected cases, rather than to silently "try to guess what was expected". of course (obviously ?), one should distinguish trivial/empty/"useless" cases from the former cases)
04:16:14 <asheshambasta> ski: so, the JSONRead instance of NonEmpty a derives from a JSONRead instance of [a] ]
04:16:34 <asheshambasta> its rather simple; where I just do case nonEmpty as of ... 
04:16:56 <asheshambasta> And also; JSONRead a => JSONRead (Maybe a) ... 
04:17:14 <asheshambasta> (in this case, either the field being read is absent or is a JSON `null' value)
04:21:55 <ski> asheshambasta : ok, so it uses the same serialization format, just with a subset/subtype restriction
04:22:06 <asheshambasta> yeah 
04:22:06 <ski> (hm, i'm not sure i like that `Maybe' case)
04:22:15 <asheshambasta> ski: why? 
04:23:29 <ski> "domain contagion", see the 2006-02-03 entry "Option types, optional parameters" in Riastradh's blag at <https://mumble.net/~campbell/blag.txt>,(RSS) <http://vrici.lojban.org/~cowan/blag.xml>
04:23:42 <ski> basically, how to distinguish between `Nothing' and `Just Nothing' ?
04:23:59 <ski> (both of type `Maybe (Maybe T)', for some `T')
04:24:45 <ski> (otoh, presumably there's no such problem with having the representation for `NonEmpty' be a subrepresentation for `[]')
04:26:35 <asheshambasta> ski: yeah; that's a known limitation for now that I've accepted. For those fields where their being `null` must be distinguished from being absent from the enclosing json value; I have a sum type: `data JSONField a = Absent | Present !(Maybe a) ` 
04:27:18 <ski> i see
04:28:39 <ski> in many dynamically typed languages, looking up a key in a finite map, will give back some "falsey" value, like `#f' (false) in Scheme, or a value like `null'
04:29:02 <ski> but that precludes that value for being a legitimate value in the key-value associations
04:32:03 <asheshambasta> I'm not sure  I understand the last statement 
04:32:23 <ski> alternatives are using an `option'/`Maybe' construction, using an exception in the "not found" case (i consider setting an error flag more or less the same thing, in this consideration at least), and using multiple alternative return paths (like explicit success & failure continuation callbacks. or implicitly passing multiple continuations, which can be seen as an "optimization" on the first alternative)
04:33:29 <ski> > lookup "foo" [("foo",Just "fubar"),("baz",Nothing)]
04:33:31 <lambdabot>  Just (Just "fubar")
04:33:32 <ski> > lookup "bar" [("foo",Just "fubar"),("baz",Nothing)]
04:33:36 <lambdabot>  Nothing
04:33:36 <ski> > lookup "baz" [("foo",Just "fubar"),("baz",Nothing)]
04:33:38 <lambdabot>  Just Nothing
04:33:53 <ski> we want to be able to distinguish the last two cases
04:34:06 <asheshambasta> yeah; correct 
04:34:37 <ski> for parametricity reasons (related to ease of refactoring, and so on), `lookup' shouldn't have to bother with what kind of values we're dealing with
04:35:34 <ski>   lookupCase :: Eq k => k -> [(k,v)] -> o -> (v -> o) -> o
04:35:58 <ski>   lookupCase needle haystack = maybe (lookup needle haystack)
04:36:20 <ski> that's the "explicit success & failure continuation callbacks" variant
04:37:01 <asheshambasta> interesting 
04:37:44 <asheshambasta> especially with JSON and some `null`s to represent 'emptying a value' this kind of distinguishing helps 
04:38:15 <ski> you may cf. to the multiple distinct things that a `NULL' in SQL can be used to represent
04:38:38 <ski> ("no value","missing information",&c.)
04:38:44 <asheshambasta> the absence of a field, altogether, means to ignore something; the presence of a field means to update it, however 
04:38:58 <ski> in your use case ?
04:39:22 <asheshambasta> ski: but isn't that somewhat a loss of context? For example, I'd not be able to tell what the intention behind a `null' is 
04:39:52 <asheshambasta> ski: yeah; we have PATCH api endpoints that do this; the presence of a field matters in that case. 
04:40:37 <asheshambasta> eg. `PATCH /user { firstname : null , lastname : Bar } ` will set the lastname and empty the firstname; and leave other user fields unchanged. 
04:41:06 <carter> merijn: your not on our channel :(((
04:44:21 <asheshambasta> ski: and for large json payloads, this becomes a huge advantage. 
04:46:57 * hackage dlist 0.8.0.7 - Difference lists  https://hackage.haskell.org/package/dlist-0.8.0.7 (SeanLeather)
04:56:50 <ski> asheshambasta : "loss of context" -- yes. but often even if you see the original context, it's not obvious which interpretation was intended. and with implicit propagation of it, possibly combining from multiple sources with different intended interpretations ..
04:57:58 * ski idly wonders which channel carter is on
04:58:09 <merijn> ski: #numerical-haskell
04:58:14 <carter> Many
04:58:17 <carter> ;)
04:58:25 <ski> asheshambasta, i see
04:58:32 * ski grins
05:04:27 <lemmih> I've build a library with 'stack build --profile' and I'm trying to build an executable with profiling ('stack ghc -- prog.hs -prof') but it complains that my library hasn't been built with profiling enabled.
05:09:27 <hc> I think you need the --profile switch for the stack ghc command also
05:09:33 <hc> stack ghc --profile -- ...
05:11:45 <lemmih> hc: Thanks!
05:17:47 <ski> s/it/`NULL'/
05:48:05 <ski> @type flip ((. (: [])) . (++))
05:48:07 <lambdabot> a -> [a] -> [a]
05:48:11 <ski> @type flip (++) . (: [])
05:48:13 <lambdabot> a -> [a] -> [a]
05:48:17 <ski> > mapAccumR divMod 2919571 [7,24,60,60]
05:48:19 <lambdabot>  (4,[5,18,59,31])
05:48:21 <ski> > mapAccumL divMod 2919571 [60,60,24,7]
05:48:24 <lambdabot>  (4,[31,59,18,5])
05:48:27 <ski> @type \f z xs -> uncurry (:) (mapAccumR f z xs)
05:48:30 <lambdabot> (a -> b -> (a, a)) -> a -> [b] -> [a]
05:48:33 <ski> @type \f z xs -> uncurry (flip (++) . (: [])) (mapAccumL f z xs)
05:48:36 <lambdabot> (a -> b -> (a, a)) -> a -> [b] -> [a]
05:48:39 <ski> > (\f z xs -> uncurry (:) (mapAccumR f z xs)) divMod 2919571 [7,24,60,60]
05:48:43 <lambdabot>  [4,5,18,59,31]
05:48:43 <ski> > (\f z xs -> uncurry (flip (++) . (: [])) (mapAccumL f z xs)) divMod 2919571 [60,60,24,7]
05:48:48 <lambdabot>  [31,59,18,5,4]
05:49:27 <ski> @hoogle (s -> a -> (s,s)) -> s -> [a] -> [s]
05:49:28 <lambdabot> No results found
05:54:50 <asheshambasta> ski: correct 
06:18:32 <infinisil> What prevents Haskell from evaluating `let x :: Int = undefined; in x == x` to True?
06:18:50 <infinisil> Because it could see that both sides of the `==` point to the same thunk
06:19:37 <infinisil> I feel like this somehow breaks ref transparency, but I don't see how
06:21:02 <int-e> infinisil: consider a naive evaluation of let x = undefined; y = undefined in x == y, where x and y somehow end up being different thunks... yet referential transparency demands that this has the same result as your let x = undefined in x == x...
06:21:56 <int-e> :t GHC.Exts.reallyUnsafePtrEquality# -- there's a reason for this name :)
06:21:58 <lambdabot> a -> a -> GHC.Prim.Int#
06:24:29 <infinisil> I see thanks
06:35:00 <bruschkv> Is anyone here working with beam and can answer a quick (and probably really stupid) question about it?
06:35:51 <__monty__> infinisil, int-e: Is this related to extensional v. intensional equality?
06:38:26 <jacks2> is it possible to write a function that accepts a number (a literal, so known at compile time) and a tuple, where the number determines the number of elements in that tuple?
06:39:10 <infinisil> jacks2: Type families, probably
06:39:17 <merijn> jacks2: Not for tuples specifically, but you could do something like that for indexed lists/vector
06:39:45 <jacks2> merijn I want to get compile error if passed number doesn't match the number of elements
06:40:01 <infinisil> Ah, type families would probably only allow you to do something like `(((((a, b), c), d), e), f)`, not `(a, b, c, d, e, f)`
06:40:44 <merijn> jacks2: What's the end goal here?
06:41:13 <dminuoso> jacks2: TempateHaskell?
06:41:28 <jacks2> to avoid code duplication when writing functions like liftA2, liftA3, etc
06:41:44 <merijn> dminuoso: Yes, I was gonna suggest that depending on the actual use case
06:41:59 <dminuoso> jacks2: Oh there is a way to write a generic lift function!
06:42:04 <merijn> jacks2: Most uses of liftAN can be replaced with <$> and <*> though
06:42:57 <jacks2> my function is unrelated to liftAN, I just used that as an example of having to write a bunch of nearly identical functions with a lot of code duplicatoin
06:45:49 <dminuoso> jacks2: https://gist.github.com/dminuoso/c687510db79940a8c903b6c1bbd08934
06:46:02 <dminuoso> Just for amusement, of course.
06:47:32 <merijn> jacks2: It's almost impossible to give general advise here, so without you telling us what the end goal is, it's nearly impossible to give useful advice
06:51:33 <dminuoso> jacks2: But indeed, the general case is to just use <$> and <*>. If you squint a bit and blur over these operators, then it looks a lot like function application.
06:52:01 <dminuoso> jacks2: ⌜f <$> a1 <*> a2 <*> a3 <*> a4⌝ kind of looks like ⌜f a1 a2 a3 a4⌝ :)
06:54:15 <infinisil> Also: https://hackage.haskell.org/package/applicative-quoters-0.1.0.8/docs/Control-Applicative-QQ-Idiom.html
06:55:08 <dminuoso> infinisil: Oh that's a really neat idea. :)
06:55:40 <dminuoso> The ado I think Ive seen already.
06:55:45 <infinisil> Idris has such syntax built-in: http://docs.idris-lang.org/en/latest/tutorial/interfaces.html#idiom-brackets
06:57:37 <Cale> bruschkv: what's the question?
07:03:17 <__monty__> infinisil, int-e: Did I miss any discussion?
07:03:52 <infinisil> Nah, no idea about existential/intensional equality
07:07:46 <infinisil> @printdef sort
07:07:46 <lambdabot> Unknown command, try @list
07:07:53 <infinisil> @src sort
07:07:54 <lambdabot> sort = sortBy compare
07:07:57 <infinisil> @src sortBy
07:07:57 <lambdabot> -- The actual definition used by GHC is an optimised mergesort.
07:07:57 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
07:08:32 <infinisil> I was just wondering whether sort was implemented with ST
07:08:37 <infinisil> It might be
07:08:47 <merijn> infinisil: It's not and that wouldn't really help with list
07:09:26 <infinisil> merijn: Reading a list into an array, then sorting it and putting it back into a list wouldn't help with big lists?
07:10:17 <merijn> infinisil: Then you lose any of the cool laziness stuff
07:10:26 <merijn> infinisil: Like "take 10 . sort"
07:10:55 <infinisil> Hmm I guess
07:11:11 <infinisil> Almost feels a bit wrong to use sort if you don't need the whole thing sorted
07:12:08 <dminuoso> merijn: Why would you lose out on laziness? Doesn't a generic sort force the entire list anyway?
07:13:38 <infinisil> That is a good point
07:13:51 <merijn> dminuoso: It doesn't sort the entire list, no
07:13:57 <merijn> dminuoso: So you're doing strictly more work
07:14:04 <dminuoso> merijn: Huh?
07:14:36 <merijn> dminuoso: If you do "take 10 . sort" you only have to continue until you have sorted enough to compute the first 10, not the entire list
07:14:45 <infinisil> Ah right
07:14:55 <dminuoso> merijn: You still have to force the entire list to even take a single element though.
07:15:05 <infinisil> But the output doesn't have to be forced
07:15:06 <dminuoso> merijn: You won't know whether the least element is found until you have forced every element.
07:15:38 <dminuoso> infinisil: It does if the Ord instance does anything non-trivial
07:15:58 <merijn> dminuoso: sorting computed elements is still work
07:16:02 <infinisil> A lazy `take 10 . sort` can have complexity `O(10 * n)`, whereas a strict version is always `O(n log n)`
07:16:33 <merijn> dminuoso: Especially if comparisons are expensive'
07:17:19 <erisco> How do I safely nuke all the data a resolver has downloaded with stack? It failed to build happy and I want to try again
07:17:36 <dminuoso> merijn: Im not saying you should precompute the entire sorted lits.
07:17:44 <erisco> in C:\sr
07:18:15 <int-e> infinisil: take k . sort can take as little as O(n + k log k), I think. Lazy merge sort (which dynamically is really a tree-based heap sort) accomplishes O(n + k log n).
07:18:15 <dminuoso> merijn: Im just saying that the argument "you lose out on cool laziness stuff" is orthogonal to using ST to sort the list.
07:19:26 <infinisil> int-e: Neat
07:21:27 <infinisil> dminuoso: Oh you mean to use Lazy ST?
07:22:59 <dminuoso> infinisil: Yes.
07:23:46 <infinisil> I see, yeah that might work
07:37:31 <infinisil> I think lazy ST is quite a bit slower than strict ST though
07:37:48 <infinisil> Would probably still pay out for large inputs though
07:37:51 <infinisil> Maybe
07:46:29 <erisco> How can I get stack to rebuild everything from the top? It screwed up building ghc
07:46:38 <erisco> And now it seems to be cached and I am not sure what to delete
07:51:45 <erisco> Found it at C:\Users\erisco\AppData\Local\Programs\stack\x86_64-windows
07:53:27 <erisco> Huh, didn't work the second time either... Cabal-simple_Z6RU0evB_2.4.0.1_ghc-8.6.5.exe: The program 'happy' version
07:53:27 <erisco> ==1.19.9 is required but it could not be found.
07:55:52 <merijn> erisco: Did you manually install happy?
07:56:06 <erisco> No, I just ran "stack build" on a project
07:57:41 <merijn> erisco: For a long time it wasn't possible to have executable dependencies automatically installed
07:57:55 <erisco> SO is saying to install with cabal but I don't know if that's right
07:58:03 <erisco> I thought everything was highly version sensitive
07:58:05 <merijn> erisco: Old packages may not have cabal files that list those dependencies (like happy)
07:58:53 <erisco> Am I supposed to install happy 1.19.9 globally with cabal?
07:58:57 <merijn> So in all likelihood the error you have is just: "happy is not installed" and stack doesn't know how to install it and/or the package you're building doesn't correctly declare the happy dependency in a way that it's detected
07:59:02 <merijn> erisco: Yes, no, maybe
07:59:08 <erisco> It is a dep
07:59:21 <merijn> erisco: What package are you building? pastebin the cabal file
08:00:11 <erisco> purescript
08:00:26 <erisco> https://github.com/purescript/purescript/blob/master/stack.yaml
08:01:49 <erisco> https://gist.github.com/erisco/45ec545766ea34e83b424f8f567af23a
08:02:33 <merijn> That's the cabal file, tbh I have no idea how stack turns stack.yaml into a cabal package, so I'm not sure if the extra-depends like that is supposed to work
08:02:59 <merijn> erisco: That paste starts with cabal-version: 1.12, which is stupid old
08:03:44 <erisco> I can just delete the cabal file right?
08:03:51 <merijn> erisco: Support for listing dependencies on build tools (like happy) wasn't added until cabal-version: 2.0
08:04:33 <merijn> erisco: If you use hpack then you can nuke it and regenerate it, yes
08:04:33 <erisco> I deleted it so stack would rebuild it, but still version 1.12
08:04:51 <erisco> I have stack 2.1.3
08:04:51 <merijn> erisco: I don't know if stack or hpack support newer cabal versions
08:05:24 <merijn> tbh, this is why I think hpack is a bad idea. People get arbitrarily limited by how of cabal hpack actually supports...
08:06:17 <merijn> Maybe your hpack version is outdated and there's a newer more modern version? I have no idea how people normally build purescript, tbh
08:06:38 <erisco> Well, on my other machine I just ran "stack build"
08:06:57 <merijn> package.yaml does list happy as build-tool
08:07:09 <merijn> So I suspect your hpack is too old to deal with that?
08:07:21 <merijn> What's the version of hpack on your system?
08:07:36 <erisco> hpack --version   is not a command so where is that
08:08:11 * merijn shrugs
08:08:16 <erisco> I'll ask the PS people, maybe they've had the error
08:13:56 <erisco> In the .lock file it lists happy-1.19.9
08:14:01 <erisco> Why would it do that if it doesn't exist
08:14:59 <erisco> I think it has some cache saying it was built but it wasn't
08:15:03 <erisco> I don't know how to fully wipe it
08:15:12 <int-e> erisco: maybe it installed the library? or maybe the executable is installed as well but it doesn't find it?
08:15:34 <int-e> The ways of the stack are mysterious (I'm not a user).
08:15:35 <erisco> maybe if I just reinstall stack... hopefully it cleans up its files
08:16:33 <erisco> the uninstaller lets me just nuke the snapshots so I'll see
08:20:55 <erisco> yeah, no, failed again in the same way
08:21:41 <merijn> The problem, presumably, is simply that happy is not on your path
08:22:13 <erisco> erisco@ERICWIN C:\Users\erisco\Documents\haskell\purescript
08:22:30 <erisco> Sorry.. $ stack install happy
08:22:30 <erisco> Couldn't find executable happy in directory C:\sr\snapshots\7e8e10a6\bin\
08:22:59 <off537[m]> ∆windskell
08:25:16 <off537[m]> I wonder why it is called Haskell?
08:25:57 <merijn> off537[m]: Named after the logician Haskell Curry
08:26:08 <merijn> off537[m]: https://en.wikipedia.org/wiki/Haskell_Curry
08:26:54 <merijn> The Haskell committee asked his widow for permission to use his name, only to learn that he had always hated the name Haskell :p
08:28:29 <erisco> Ah ha there was a cache at C:\sr\snapshots\7e8e10a6\installed-packages !
08:28:45 <erisco> I delete that and now it is building happy
08:29:05 <erisco> Now I have happy
08:34:26 <off537[m]> <merijn "The Haskell committee asked his "> Interesting! 
08:34:44 <off537[m]> Same here xD
08:41:52 <asheshambasta> I'm still stumped by the "no instance for (Monad ... )" errors in ApplicativeDo. :-( )
08:43:48 <glguy> asheshambasta: An easy way to get a Monad constraint is with a pattern match on the left side of a <- that isn't irrefutable
08:43:56 <glguy> e.g.:   do Just x <- m; ...
08:44:32 <glguy> another way is to use the variables bound on the left side of an <- in anything but a final return/pure expression
08:46:21 <asheshambasta> glguy: I'm not really doing any of that; and it seems correct to me https://gist.github.com/asheshambasta/660fc35e3dfaebeff8ee1d9438b23b8a
08:46:52 <asheshambasta> either the reason why GHC expects the desugaring to be inside a monad isn't clear to me; or at best, ApplicativeDo is really hard to understand :-) 
08:48:14 <geekosaur> you're reusing meta in the next <-
08:48:24 <geekosaur> not only in the final pure
08:49:10 <asheshambasta> geekosaur: is that incorrect? 
08:49:17 <geekosaur> this needs Monad, Applicative is insufficient (it's building a liftA... for you, each expression has to be independent and only combined at the end
08:49:45 <geekosaur> try building that expression yourself as a liftA2 and see what goes wrong
08:50:03 <asheshambasta> so there's no way to use a previous value from a do block inside of an ApplicativeDo ? 
08:50:12 <geekosaur> correct becuse that needs Monad
08:50:20 <geekosaur> it cant be done with only Applicative
08:51:18 <geekosaur> like I said, try to write a liftA... expressing this yourself
08:51:25 <geekosaur> without using ApplicativeDo
08:51:42 <infinisil> That's like the essence of a monad, being able to have one computation depend on the result of another
08:51:54 <geekosaur> you'll find that meta isn't in scope there
08:52:35 <infinisil> :t (>>=)
08:52:37 <lambdabot> Monad m => m a -> (a -> m b) -> m b
08:52:41 <asheshambasta> geekosaur: I see. 
08:52:42 <geekosaur> and yes, this isn't sme magic that do notation allows you, it's the magic that Monad allows you
08:53:08 <Redrield_> I'm trying to follow https://gitlab.haskell.org/ghc/ghc/wikis/building/cross-compiling for building a ghc cross compiler for arm-gnueabi, after some fiddling with the linker it's using I managed to get it to configure, but when i try to `make` it runs into an issue the first thing it tries to compile. https://hasteb.in/nolafaxo.lua
08:53:37 <infinisil> Redrield_: Probably better for #ghc
08:53:54 <Redrield_> Kk, thanks
08:55:47 <abbe> :t (>>>)
08:55:49 <lambdabot> forall k (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
08:59:52 <ski> @where Haskel
08:59:53 <lambdabot> <http://web.archive.org/web/20070703001910/http://www.cs.chalmers.se/~augustss/pics/haskel.gif>
09:00:07 <ski> dminuoso,infinisil : yea, idiom brackets was one inspiration for my "reflective (effectful) syntax" idea ..
09:30:55 <berndl> Is anyone familiar with FFree (the Free-er monad) from Kiselyov & Ishii?
09:31:41 <Rembane> berndl: I bet a tuppence that at least one here is, what concerns do you have? 
09:32:20 <berndl> Well, for one thing I can't get the Monad instance working.
09:32:43 <berndl> The second thing is that I don't think that construction gives you a free/forgetful adjunction.
09:33:02 <berndl> At least, I can't figure out what the counit for it is.
09:33:42 <berndl> The bit of code from the paper with the Monad instance doesn't even type check.
09:46:20 <erisco> Where can I read on how GHC does optimisations? Particularly I am interested in how it recursively applies optimizers
09:51:33 <Gander01> deBruijn :: Term -> TermDB                                           deBruijn (Variable x) = (VariableDB (indexOf x v))                                         deBruijn (Lambda x m) = (LambdaDB (deBruijn m))                                      deBruijn (Apply m n)  = (ApplyDB (deBruijn m) (deBruijn n))        How can I get the list v of free varia
09:51:34 <Gander01> bles to change depending on whether the input is variable or lambda?                              
09:52:23 <cocreature> erisco: iirc there is a paper called “a transformation-based optimizer for Haskell” and a corresponding phd thesis that have quite a few details. not sure how up2date they are
09:53:55 <int-e> Gander01: I'd make the list of variables an argument of deBruijn
09:55:37 <ski> worker-wrapper
09:55:42 <int-e> yeah or that
09:56:36 <int-e> (A lot depends on whether we ever want this to work on open terms... and if so, how to treat free variables in that case.)
09:56:51 <Gander01> I'm not allowed to change the number of input args
09:57:01 <int-e> yeah then make a helper function
09:59:49 <int-e> Btw, in general it's better to paste the code for such implementation questions somewhere... ideally code that can be compiled (or has a meaningful compilation error). It's not a given that we can fill in the data type declarations and their semantics. Though I guess in this case it worked fine.
10:07:30 <geekosaur> if somewhat painfully
10:45:12 <erisco> cocreature, hrm, I just skimmed it but it doesn't seem to go into detail of how it makes multiple passes efficient
10:45:12 <wroathe> say I've got a context free grammar where a production has a lot of potential rules, and I'm writing a parser for it... What's the cleanest way to represent that at the type level?
10:45:20 <erisco> other than to say that it tries to do as much as it can in one pass
10:45:25 <wroathe> I was hoping to get away with having one single AST datatype
10:45:38 <wroathe> GrammarNode a or something like that
10:45:47 <wroathe> But now I'm thinking it's going to be a whole family of types
10:45:50 <erisco> so I am guessing at the end of the day it just computes equality of the program the expensive way, and runs the whole thing again if it changed
10:47:45 <wroathe> So do people typically do one type per nonterminal in this situation?
10:48:03 <erisco> I think it makes sense then to do this recursion at every node
10:48:21 <erisco> bottom-up of course
10:49:19 * geekosaur wonders about TTG or the way ghc used to do it with a config record?
10:49:43 <erisco> is that a musing about what I'm talking about?
10:49:49 <geekosaur> (TTG = Trees That Grow)
10:49:58 <geekosaur> wroath, sorry
10:49:58 <erisco> then no
10:50:03 <geekosaur> wroathe
10:50:49 <geekosaur> anyway the old way had a parameterized AST and the parameter could be used to "customize" types in different compiler passes, iirc
10:52:12 <cocreature> erisco: rather than computing equality you can make the optimizer keep track of whether it changed anything
10:52:33 <erisco> An honour system eh, well I suppose
10:52:46 <geekosaur> consider simplifier ticks
10:52:52 <geekosaur> I think there's some other uses of that in ghc.
10:53:07 <geekosaur> one can use that in reverse, if no ticks get used then nothing happened
10:53:14 <erisco> I keep running into the need for adaptive computation heh
10:53:41 <dmwit> wroathe: One type per nonterminal sounds completely reasonable to me.
10:53:56 <erisco> I am not sure how the ticks work. I am just figuring I'll cap iterations per node
10:54:16 <erisco> in a bottom-up traversal
10:54:17 <wroathe> http://hackage.haskell.org/package/template-haskell-2.14.0.0/docs/Language-Haskell-TH-Syntax.html
10:54:25 <wroathe> Yeah, now that I think about it that's what template haskell does
10:54:46 <dmwit> I think geekosaur's TTG suggestion is not super relevant to the question at hand. TTG is great when you have many very similar types that you are converting between (e.g. compiler phases that have similar but not quite identical IRs).
10:55:07 <wroathe> dmwit: Well, I'm mainly looking for a way to express that these types are all somehow related
10:55:44 <dmwit> I don't think that changes anything about my answer.
10:55:49 <geekosaur> [05 17:44:50] <wroathe> say I've got a context free grammar where a production has a lot of potential rules, and I'm writing a parser for it... What's the cleanest way to represent that at the type level?
10:55:56 <wroathe> It doesn't, and thanks for the validation
10:56:11 <erisco> I guess that can get exponentially ugly
10:56:25 <geekosaur> and I'm not sure if it's relevant either, basically tossing possibilities because this description is a bit too vague
10:56:31 * dmwit nods
10:56:42 <geekosaur> things to think about
10:57:12 <dmwit> Even with TTG you will likely have separate (now parameterized) types per nonterminal.
10:57:27 <wroathe> It's not that vague... https://github.com/akimd/bison/blob/master/src/parse-gram.y#L302
10:57:47 <wroathe> A production with lots of rules is pretty concrete IMO
10:58:09 <dmwit> And of course often a bunch of nonterminals will exist just to get precedence right, so you can collapse those into one type in your AST.
10:58:27 <wroathe> dmwit: Yup
11:01:54 <wroathe> Oh, typeclasses, duh
11:02:03 <wroathe> I'm really brain failing today
11:02:07 <wroathe> I don't brain good
11:04:00 <iqubic> ASTs and parsing is rather hard. I still struggle to correctly parse operators that have the same precedence but different associativities.
11:09:28 <wroathe> Actually Haskell's expressiveness just has me thinking about the possibilities here. Right now I've got a single Token type for all of my non-terminals, but there's no reason I couldn't lift the data constructors to the type level
11:10:15 <wroathe> So instead of Expr, followed by Token, followed by Expr, I could say Expr, followed by Operator, followed by Expr or something like that
11:10:34 <wroathe> for all of my terminals*, sorry
11:10:37 <wroathe> not non-terminals
11:17:05 <ski> wroathe : hm, do you want GADTs ?
11:17:50 <wroathe> ski: Nah, I think I know where I'm going with this. 
11:17:57 <wroathe> Or at least a rough idea
11:18:42 <ski> wroathe : there's a trick you can do, if you want DecoratingStructures or IndirectComposite
11:19:01 <ski> when you have mutually recursive ASTs, i mean
11:19:16 <ski> (your non-terminals)
11:19:54 <wroathe> I'm unfamiliar with DecoratingStructures and IndirectComposite
11:20:01 <wroathe> Looking it up now
11:20:21 <ski> @where DecoratingStructures
11:20:21 <lambdabot> <http://web.archive.org/web/20051126143527/http://haskell.org/hawiki/DecoratingStructures>
11:20:25 <ski> @where IndirectComposite
11:20:25 <lambdabot> <http://web.archive.org/web/20051126141834/http://haskell.org/hawiki/IndirectComposite>
11:20:32 <ski> fancy names for something simple
11:21:48 <ski> one might want to annotate nodes with source location info. or expression nodes with types. or with free variables
11:21:53 <ski> (hmm <https://en.wikipedia.org/wiki/Spaghetti_stack#Use_in_compilers>)
11:22:36 <ski> one might want to work on incomplete source, with holes in it
11:24:11 <ski> (also ties into catamorphisms,&c. and stuff like SYB,uniplate,biplate,multiplate,Compos,&c.)
11:24:21 <ski> anyway, the basic `Fix'/`Mu' idea doesn't work that well, when you have mutually recursive ASTs
11:24:28 <wroathe> What I'm thinking right now is that it might be possible to represent a complete EBNF as a type and derive a parser from it
11:24:39 <wroathe> Using DataKinds
11:24:42 <ski> you might have
11:24:48 <ski>   data Expr :: *
11:24:50 <ski>     where
11:25:02 <wroathe> ski: Maybe gist it?
11:25:04 <ski>     Let :: Decl -> Expr -> Expr
11:25:08 <ski>     ...
11:25:12 <vaibhavsagar> where did https://github.com/LeventErkok/sbv go?
11:25:16 <ski>   data Decl :: *
11:25:17 <ski>     where
11:25:41 <ski>     FunBind :: Ident -> [Pat] -> Expr -> Decl
11:25:44 <ski>     ...
11:26:06 <pyan> What is the fascination among some people with manually tying their fixed points?
11:27:10 <ski> vaibhavsagar : hm, that was mentioned about thirteen hours and three quarters of an hour ago, in here
11:27:21 <ski> (no resolution, though)
11:28:09 <ski> pyan : having a custom `fix' for instrumentation can occasionally be useful
11:29:03 <ski> anyway, to untie these, one would need one parameter for `decl' and another for `expr' .. well, perhaps now one could pass a pair of types (not a pair type) as a parameter
11:29:17 <ski> but disregarding that, one can merge into
11:29:32 <ski>   data Tag = TExpr | TDecl
11:29:51 <ski>   data AST (ast :: Tag -> *) :: Tag -> *
11:29:53 <ski>     where
11:30:15 <ski>     Let :: ast TDecl -> ast TExpr -> AST ast TExpr
11:30:39 <pyan> data Mu1 f g = Mu1 (f (Mu1 f g) (Mu2 f g))
11:30:40 <pyan> data Mu2 f g = Mu2 (g (Mu1 f g) (Mu2 f g))
11:30:40 <ski>     FunBind :: Ident -> [ast TPat] -> ast TExpr -> AST ast TDecl
11:30:44 <ski>     ...
11:30:46 <wroathe> ski: I get it, also gists exist
11:30:53 <wroathe> https://gist.github.com
11:31:13 <ski> pyan : yea, but that gets annoying, when you start to have three or more "self" parameters
11:31:36 <pyan> ski: I don't disagree that it is annoying. That is why I simply don't manually tie my fixpoints.
11:32:05 <ski> (hm, makes me wonder whether there's anything similar in an OO setting. mutually recursive classes, with open recursion, perhaps ?)
11:32:46 <pyan> Mmm, as far as I can tell, in Java and C#, classes are always mutually recursive, without you doing anything special.
11:32:56 <ski> pyan : you mean you prefer having a type class or type family that associate the recursive type to its corresponding selected functor ?
11:33:24 <ski> pyan : yea, but i'm talking about being able to insert arbitrary lawyers inbetween the cycles
11:33:45 <pyan> Could you give a use case?
11:33:51 <tabaqui> how can I pass a variable from "stack path" into the code?
11:34:03 <tabaqui> for TH purpose
11:34:24 <tabaqui> "stack exec env" doesn't show any variables from "stack path"
11:34:37 <tabaqui> but I need an access to project-root
11:37:46 <wroathe> Anyone here ever see an EBNF specified in terms of DataKinds/PolyKinds at the type level?
11:38:04 <wroathe> As I think about it I don't see why I couldn't just do this all with types
11:39:00 <ski> pyan : not off-hand. i'd have to mull it over a bit, to make sense of it (if there's any sense to be had)
11:39:43 <ski> wroathe : well, iiuc, there's no anonymous gists, anymore ..
11:41:08 <wroathe> ski: Why not just get a github account?
11:42:10 <ski> (i don't think it should be required, for such things. it's annoying me enough to not want to use gists at all)
11:42:33 <geekosaur> tabaqui, "stack pah" shows stack internal state, pretty sure you have to run that command and parse its output
11:43:21 <geekosaur> (or reconsider what yu're doing that needs that information, since it usually means you're trying to muck with something stack thinks it controls)
11:49:05 <tabaqui1> I have some data = $(embedFile "res/resource"), but it makes me pain with multiproject root and "stack ghci"
11:49:43 <tabaqui1> I could parse "stack path" inside of macro call, but it will be ugly
11:52:31 <geekosaur> I think this is a known unsolved issue, and for example last I'd heard, stack had simply dropped support for the equivalent hackery with Paths modules figuring out compiled vs. ghci.
11:52:39 <geekosaur> or in build tree vs. deployed\
11:52:54 <geekosaur> this is ugly no matter how you slice it
11:56:17 <dmwit> pyan: The unification-fd package offers a nice use case.
11:56:36 <dmwit> pyan: It has two type-level fix operators, one that inserts fresh unification variables everywhere and one that doesn't.
11:57:07 <dmwit> pyan: Then it has a library call to "freeze" values of the one kind of fix into the other, throwing a unification error if there turns out to be any variables left undetermined.
11:57:23 <dmwit> (i.e. the "freeze" call is monadic)
11:58:05 <dmwit> http://hackage.haskell.org/package/unification-fd-0.10.0.1/docs/Control-Unification.html#t:UTerm
12:00:18 <dmwit> And see also http://hackage.haskell.org/package/unification-fd-0.10.0.1/docs/Control-Unification.html#v:zipMatch which exploits the openness of the recursion in a third way.
12:01:33 <tabaqui1> geekosaur: ok, I get it, thanks 
12:02:12 <tabaqui1> It would be cool, if stack generates some module like Paths_package in Cabal
12:03:09 <dcoutts> tabaqui: the Paths_$package is generated of course.
12:03:31 <dcoutts> or did you mean there's a use case for generating something else too?
12:07:17 <tabaqui1> dcoutts: yeah, I meant variables from "stack path" output
12:26:28 <jle`> any r/haskell mods online atm by any chance? :)
12:30:36 <ski> dmwit : heh, i remember doing something like that, in my logic programming prototype (with implicational goals (nestable also in the antecedent), and universal goals)
12:31:56 <ski> (though i think i didn't use a general IndirectComposite, i had just parameterized data types on a reference type, which could either be `Identity', or `Maybe' (partial terms), or logic variables (implemented with `STRef' after Koen Classens follow up paper after Seres & Spivey))
12:45:43 <dmwit> (I guess "inserts fresh unification variables everywhere" isn't super precise. "inserts the possibility of a unification variable at every level" may be better.)
12:57:32 <texasmynsted> is there some common way that people move files to a compressed location over time? Like I could create a folder and add to it, then zip it but I would need to unzip before every add.
12:57:43 <texasmynsted> At least from the GUI
12:58:26 <texasmynsted> I thought about a compressed disk image
12:58:46 <lavalike> texasmynsted: I'm curious what Haskell you're thinking about with this question
12:58:55 <texasmynsted> Oh snap
12:59:00 <texasmynsted> wrong channel
12:59:06 <Rembane> texasmynsted: gzip first, then add with tar. Good luck! 
12:59:08 <lavalike> hah no worries
12:59:10 <texasmynsted> LOL
13:22:04 * texasmynsted hides
13:27:43 <Boarders> Does anyone have any good examples of algorithms written using STRef that are faster (hopefully significantly) than their pure equivalent?
13:28:03 <Boarders> every time I try using an imperative algrorithm and benchmarking GHC does a better job with the pure version
13:28:25 <Boarders> so I would like to gain some better intuition on when it is effective
13:29:49 <Boarders> I have used various mutable vector producing faster algorithms than just doing the immutable version
13:35:29 <Hindude> Hello, does there exist a soruce for me to format my haskel code file
13:42:47 <geekosaur> there's a couple of programs, but note that (a) programs with incorrect indentation are often ambiguous (b) there's no single "correct" style
13:42:55 <geekosaur> hindent and brittany are the tools I know of
13:46:14 <Boarders> does stylish-haskell count, I only use it to clear up whitespace and my imports and language extensions
13:46:39 <Boarders> I think there are options to have it mess with your indenting but I find that easier to do myself
13:50:28 <dmj`> jle`: nice post, you should flex the deriving strategies, "deriving anyclass (ToJSON, FromJSON)"
13:58:14 <monochrom> Boarders: Tiny STRefs such as STRef Int are totally not worth it for obvious overheads.  To worth the trouble you will need at least a large mutable array, e.g., sorting, shuffling, FFT.  Even then you may also need to prescribe unboxed arrays.
13:59:08 <Boarders> monochrom: thanks that fits with my expectations, though forgive the naive question but at that point why not just use a mutable array or mutable prim vector or the like?
13:59:39 <monochrom> Yeah, but they will run under runST.
14:00:18 <monochrom> So yeah, I guess not STRefs themselves.
14:00:37 <Boarders> yeah, I have come across the ST monad itself being useful
14:00:45 <Boarders> I guess STRefs might be more useful in a library
14:01:39 <Boarders> What about libraries like System.Random using IORef to store two Word32's as state for seed generation
14:01:51 <Boarders> would they be better off being completely pure?
14:01:54 <monochrom> IORef is just as slow as STRef :)
14:02:13 <Boarders> I could only imagine it helping when the state is actually a vector or similar
14:02:32 <koala_man> it would be really annoying if you had to supply your own seed every time you wanted a random number
14:02:51 <Boarders> you could still get a seed from udev/random or from system time
14:03:32 <monochrom> System.Random offers two interfaces, the IO one and the state transition function one.  They both have use cases.
14:04:44 <monochrom> tf-random's state is 4 Word64.
14:05:18 <monochrom> Internally it uses a low level byte array.
14:07:27 <monochrom> I think STRef and IORef shine when you have a record of a dozen of them.  Recall that clone-except-change-one-field on a large record is even slower than a single modifyIORef or modifySTRef.
14:08:15 <Boarders> ahh that seems like a good use case
14:08:33 <Boarders> thank you for the example
14:48:28 * hackage coercion-extras 0.1.0.0 - Extra utilities for manipulating nominal and representational coercions  https://hackage.haskell.org/package/coercion-extras-0.1.0.0 (mniip)
14:53:32 <SolarAquarion> merijn: hi
14:55:58 * hackage magic-tyfams 0.1.0.0 - Write plugins for magic type families with ease  https://hackage.haskell.org/package/magic-tyfams-0.1.0.0 (isovector)
14:56:49 <merijn> SolarAquarion: ola
14:57:28 <SolarAquarion> merijn: so i think i reported a issue that i have with my system and how it's seemingly not picking up "broadcast-chan" which is weird
14:58:08 <SolarAquarion> https://aur.archlinux.org/cgit/aur.git/tree/PKGBUILD?h=haskell-broadcast-chan
14:58:37 <SolarAquarion> think is the PKGBUILD that i created to be on my system in the "Arch" way
14:58:48 <merijn> Oh goodie, arch... >.>
14:59:18 <SolarAquarion> yeah, and it's not even in the official repo's yet
14:59:55 <SolarAquarion> which means i need to rebuild it like once to twice a week
15:00:01 <merijn> tbh, my recommendation would be to avoid Arch's haskell packaging like the plague :)
15:00:46 <SolarAquarion> eh, it works for me, otherwise things'll get weird, but it works for me as long as I stay to the PKGABUILDs
15:00:59 <jle`> dmj`: ah that's pretty nice :)
15:01:15 <merijn> SolarAquarion: If you run "ghc-pkg list" is it in there?
15:01:27 <dibblego> @hoogle Iso (Maybe a) (Maybe b) (Either () a) (Either () b)
15:01:27 <lambdabot> No results found
15:01:47 <SolarAquarion> strange, it's really strange
15:03:12 <SolarAquarion> oh, i think it's a Packaging mistake
15:03:20 <mniip> dibblego, you can probably go via some generics magic
15:03:54 <mniip> Iso (f a) (f b) (Rep1 f a) (Rep1 f b)
15:04:02 <mniip> then some sort of iso that ignores the metadata
15:04:20 <dibblego> mniip: yeah cheers, I was hoping for a library function(s) without generics
15:05:36 <SolarAquarion> merijn: i compared haskell-zlib to haskell-broadcast-chan and it seems that it was picking up the "registeration"
15:06:53 <mniip> registerization?
15:07:02 <SolarAquarion> register.sh
15:07:06 <merijn> SolarAquarion: From GHC/cabal's perspective, if its not listed in "ghc-pkg list", it doesn't exist
15:07:20 <SolarAquarion> yeah, i get it now
15:10:12 <SolarAquarion> thanks for the fact
15:10:29 <SolarAquarion> yeah, it was a packaging mistake that caused it to not pick it up
15:11:46 <devalot> Is there a better (read: less manual) way of writing this lens? https://gist.github.com/pjones/9a69eaf259933994d4693a031ed5a2d5
15:12:58 * hackage magic-tyfams 0.1.0.1 - Write plugins for magic type families with ease  https://hackage.haskell.org/package/magic-tyfams-0.1.0.1 (isovector)
15:17:03 <lyxia> devalot: what's Rank
15:17:32 <devalot> data Rank a = Rank Int a
15:17:59 <lyxia> generic-lens seems relevant, in particular the "Typed" module
15:18:40 <devalot> lyxia: Hmm, that sounds wonderful.  Looking at it now.
15:19:05 <lyxia> ah darn, its Types that does the recursive traversal, and it only does Traversals.
15:20:51 <devalot> I guess I'll keep what I have now until I see something better.
15:27:31 <lyxia> devalot: I added a comment to your gist
15:28:13 <devalot> lyxia: ooh, that's pretty.
15:28:14 <devalot> Thanks!
15:30:01 <lyxia> Why is it a Lens'
15:30:14 <lyxia> It should be Lens
15:37:15 <devalot> lyxia: Because I don't know what I'm doing ;)
15:38:01 <lyxia> that's fair :)
15:50:33 <fog> what do you call a VM with a simple OS running on it?
15:50:54 <fog> and is that what ghci is?
15:51:42 <fog> wait thats totally wrong, i cant run cabal in ghci...
15:51:45 <Cale> That is not what ghci is
15:52:11 <Cale> Though, I guess the GHC runtime system is kind of approaching a lot of what an OS has to do
15:52:18 <fog> like i can run apt-get on a vm with linux on
15:52:29 <hpc> ghci is a repl
15:52:52 <fog> so i guess its because you cant install things on it that its not an VM+OS (whatver thats called)
15:52:55 <hpc> it's more like just the bash prompt
15:53:02 <hpc> rather than all of linux, glibc, etc
15:53:25 <fog> hpc, a "read eval print loop" ?
15:53:29 <hpc> yeah
15:53:54 <fog> basically want to have the least sufficient thing to be able to install haskell on
15:54:12 <fog> i was saying cabal because thats like apt-get
15:54:29 <hpc> if you don't mind it probably not working very well, there's a project for running a haskell program as a xen guest
15:54:30 <fog> but i dont need to be able to build from the linux repos
15:54:41 <fog> on windows?
15:54:41 <monochrom> Why is this in #haskell?
15:55:12 <hpc> does the base os have to be windows?
15:55:51 <fog> monochrom: i was wondering about the thing don stewart was talking about to do with hot-swapping on the haskell cast, it seemed like the main thing to do with security could be phrased in terms of "not being able to ssh from the VM+OS onto the host"
15:56:26 <boj> fog: perhaps look at HaLVM
15:56:29 <fog> hpc: the best situation would be if it could run on itself, but i guess there has to be a basecase, and windows i guess isnt probably the best for eg a server farm, but for personal dev, yeah, i run windows
15:56:47 <devalot> lyxia: I thought Lens' is a synonym for Lens when s ~ t and a ~ b.  If that's true, why is making this a Lens better than a Lens'?
15:57:02 <boj> be wary though, unikernels haven't really seemed to have caught on...
15:57:10 <monochrom> OK so why are you talking about VM and OS instead of hot-swapping on Haskell?
15:57:24 <fog> it would be good to be able to eg install putty on it though, or at least some kind of way to ssh into the internal layers
15:57:47 <fog> monochrom, because thats the closest i have atm, currently running debian on virtualbox
15:58:05 <fog> i dont know what even to call that thing, and how to develop a version of it in haskell
15:58:24 <fog> i dont need a full linux, or a full vm
15:58:55 <fog> just to be able to run ghc cabal and an ssh... oh, and compile to it, thats important too
15:58:56 <monochrom> Haskell is not designed for this. This has nothing to do with Haskell.
15:59:08 <fog> what? i can write anything in haskell
15:59:20 <boj> no you can't
15:59:36 <fog> oh right, the thing about Habit being specifically designed by having machine code instead of a C backend
15:59:40 <fog> im not sure about that
15:59:59 <fog> like, you wouldnt be targeting machine code, as its a VM that your running on
16:00:13 <fog> so i guess it needs to have a C compiler run on it tooo
16:00:44 <c_wraith> In theory you could do this in Haskell.  But it would be roughly equivalent to writing an OS in Haskell.  Not impossible, as projects like HalVM have shown, but it's a lot of work compared to starting someplace where most of the work is already done.
16:01:55 <fog> i donk know if that managed to satisfy the specification or description given..
16:02:19 <fog> like, isnt Xen baremetal, so then you couldnt run a HalVM on Xen on HalVM...
16:02:33 <c_wraith> No, Xen is not bare metal.  It's Xen.
16:02:43 <fog> can you run it on HalVM?
16:02:48 <c_wraith> No
16:03:02 <hpc> you should look at what halvm is, i think that will answer a lot of your questions
16:03:05 <fog> but not because its baremetal...
16:03:26 <fog> yeah i suppose im confusing it with an OS
16:04:04 <hpc> "OS" isn't really a single layer
16:04:19 <hpc> take a look at how computers boot as well, perhaps
16:04:31 <fog> i would consider that part of the VM
16:04:36 <hpc> going through bios, bootloader, etc
16:05:03 <hpc> and understand what layer things get installed at
16:05:09 <hpc> and what layer the next thing is on top of that
16:05:36 <fog> like, a linux Iso on virtualbox, virtualbox provides eg a virtual cd drive for the Iso, and other hardware emulation like sockets etc
16:06:18 <hpc> virtualbox provides hardware and bios
16:06:34 <fog> and linux has the bootloader ok
16:06:36 <hpc> then the next part, which the user of virtualbox has complete control over
16:06:43 <hpc> is everything on the hard drive
16:06:54 <hpc> linux is the kernel, it's after the bootloader
16:06:57 <hpc> grub is a bootloader
16:07:23 <hpc> windows, which is very hard to examine the layers of, also has a bootloader of its own
16:07:31 <hpc> you can boot into linux from the windows bootloader even
16:08:04 <hpc> this is getting off topic though
16:08:36 <fog> thats to provide the interface to the machine code? again im not sure about that being really nesacarry. obviously linux as an OS expects to be installed like that, but if its just supposed to be a VM+OS that is not supposed to be able to support all OS's just the haskell version, then it can do without much of these things right?
16:10:11 <fog> i want to be able to compile haskell onto it, so i guess it needs some form of machine instructions, but as they are virtual to begin with... yeah sorry its confusing
16:12:05 <fog> i guess the briefest way to state it is crosscompiling haskell to run on a haskell program
16:15:12 <fog> why does halvm need to run on a hypervisor?
16:17:11 <hpc> it's written specifically for xen
16:22:44 <fog> seems like its got the right frontend, in that it is a "lightweight" VM, not providing for arbitrary OS's, and allowing haskell packages to be built, but by running on something that is itself *not* a haskell package its not quite what im describing 
16:23:31 <fog> maybe a haskell version of Xen could be easy to get HalVM to run on
16:28:05 <fog> this looks opes source enough to copy from? https://github.com/xcp-ng/
16:29:12 <fog> ooh look there is even some OCaml; https://github.com/xcp-ng/xen-api
17:26:54 <Jello_Raptor__> So, I'm stumped. Is there any way to turn a functional dependency into an equality constraint? say `(MonadError e m, MonadError e' m) => proxy m -> e :~: e' or '(MonadError e m, MonadError e' m) :- (e ~ e')` ? 
17:29:08 <Axman6> so, I've been trying to find a generic way to do the following: Given a type which is an instance of FiniteBits and two values of that type, return the minimum of the two values in a branchless way. There's a way to do it in C which uses -(a < b), but we don't, as far as i can tell, have a generic way to get 1 or 0 from a comparison (there are ways to do it for specific unboxed types though)
17:31:13 <Axman6> for (for reference, the version in C is r = y ^ ((x ^ y) & -(x < y))
17:31:51 <Axman6> trying to avoid writing a COrdering class
17:32:06 <c_wraith> I don't think there's anything other than the branchless primitives for specific types
17:35:26 <dmwit> Jello_Raptor__: Nope.
17:35:33 <dmwit> unsafeCoerce, of course
17:37:36 <hpc> i wonder if that's a safe deduction
17:39:35 <Jello_Raptor__> @hpc: It seems like no? though I don't understand what's happening in the example https://stackoverflow.com/questions/34645745/can-i-magic-up-type-equality-from-a-functional-dependency
17:39:35 <lambdabot> Unknown command, try @list
17:41:16 <jackdk> IRC doesn't use leading-@ before people's names.
17:41:46 <Jello_Raptor__> I'd expect D to produce an error  when you import those two conflicting instances 
17:42:06 <Jello_Raptor__> jackdk: thanks
17:43:57 <hpc> yeah, i would expect the same
17:47:28 <hpc> whoa, it loads
17:51:24 <Jello_Raptor__> Then I'm stuck and have no idea how I'd write a `MonadError` instance for my transformer, since I can't just lift the error through nicely :/
17:51:52 <Jello_Raptor__> well, I can't lift `catchError` through the transformer. 
17:58:58 <dmwit> Jello_Raptor__: Lifting catchError through your transformer generally involves "run"ning the transformer.
18:02:32 <dmwit> (What is your transformer?0
18:05:04 <Jello_Raptor__> dmwit: Some weird monstrosity that is probably a combination of a FreeT, ListT, StateT and ContT which represents a non-deterministic computation which I can run in discrete steps while keeping track of resource dependencies. 
18:07:02 <wroathe> So I'm thinking of ways to improve the type safety of this, and at the same time retain my functor instances (and foldable/traversable when I get around to defining them)
18:08:21 <wroathe> So I'm thinking of ways to improve the type safety of this, and at the same time retain my functor instances (and foldable/traversable when I get around to defining them)
18:08:50 <wroathe> https://github.com/JustinChristensen/bison-grammar-codegen/blob/master/src/Bison/Grammar/Types.hs#L85
18:09:44 <wroathe> in this AST definition I've got it parameterized by a, and down below I've got aliases that apply the type Token, that I've defined above
18:11:09 <wroathe> But on the line I linked, the second parameter a can really only be the token PERCENT_PERCENT that I've defined above
18:11:49 <wroathe> and so with datakinds I could promote that to a type and say that the second a is actually 'PERCENT_PERCENT
18:12:21 <wroathe> but if I do that then my GrammarFile AST becomes hard to traverse
18:14:05 <wroathe> is there a nice way to model this?
18:19:57 <lyxia> I don't understand why it's a field at all if it can only have one value
18:20:00 <dmwit> Jello_Raptor__: Oh, yeah, well... catching errors in a nondeterministic monad seems strange to begin with.
18:20:28 <dmwit> Jello_Raptor__: Perhaps you could just offer a part of your API for throwing errors, but no corresponding part for catching them? Do you really need catchError?
18:21:33 <Jello_Raptor__> dmwit: Right now that's what I'm doing with a bright red warning in the haddocks. 
18:21:49 <dmwit> No, I mean, like, don't instantiate MonadError.
18:22:18 <dmwit> Just offer a (potentially even non-typeclassy) primitive action for throwing errors in your monad.
18:22:40 <dmwit> wroathe: Why do *any* of these things contain tokens?
18:23:58 <Jello_Raptor__> dmwit: I need monad error to save myself some effort in the backend, but none of the visible API will have those instances.
18:24:24 * dmwit squints
18:25:50 <Jello_Raptor__> yeah :/  It's all very skeevy
18:30:50 <wroathe> lyxia, dmwit, good points :P
18:31:39 <wroathe> I really wasn't thinking about what I was doing today
18:35:54 <wroathe> when you consider what my ultimate goal is with this it's even more shameful that I went into autopilot on this :P
18:39:18 <wroathe> part of it is that I started out doing a separate pass with a lexer I realized it makes more sense just to leverage parser combinators to a greater extent
20:13:27 * hackage shh 0.7.0.0 - Simple shell scripting from Haskell  https://hackage.haskell.org/package/shh-0.7.0.0 (lukec)
21:14:57 * hackage termonad 2.0.0.0 - Terminal emulator configurable in Haskell  https://hackage.haskell.org/package/termonad-2.0.0.0 (cdepillabout)
