00:00:03 <jle`> sort of, but that's not quite how i'd put it
00:00:10 <jle`> it'd put it as you assuming you know more than you actually do ;)
00:00:14 <koz_> LOL
00:00:20 <koz_> Well, I can't think of a case where this instance would fail.
00:00:24 <jle`> not in terms of general knowledge, but in terms of the guarantees of b -> n
00:00:39 <jle`> okay say i have newtype Blah = Blah Word8
00:01:03 <jle`> and newtype Floop = Floop Word8
00:01:11 <jle`> i could define instance Finitary 100 Blah
00:01:18 <jle`> and instance Finitary 1000 Floop
00:01:19 <koz_> Oh, I see.
00:01:27 <jle`> now both Blah and Floop are coercible with Word8
00:01:31 <jle`> which instance would this pick?
00:01:38 <koz_> Hmm, I see.
00:02:03 <jle`> (assuming we're deriving Word8's instance here)
00:02:07 <koz_> What would you think would be a good way to 'drag' Finitary instances through newtypes (which is what I really want)?
00:02:09 <jle`> (so that might have been a bad example)
00:02:48 <jle`> i think the most pragmatic way would be to just define a separate instance for each newtype
00:02:55 <koz_> No, the example makes a valid point - I was assuming people wouldn't inadvertently lie to GHC about the cardinality of their types.
00:02:56 <jle`> knowing that the Generic construction will auto-derive the bodies of those instances
00:03:05 <koz_> Ah, I guess if we lean on Generic it should be OK.
00:03:31 <jle`> because also what you have is pretty scary too, it's an `instance Fintary n b`
00:03:50 <jle`> remember that instance resolution matches on the instance heads, and doesn't really do reliable backtracking normally
00:03:59 <jle`> so that instance would match on...literally every type
00:04:10 <jle`> it would make every single instance an overlapping instance
00:04:20 <koz_> Oh yeah, that's _explosive_.
00:04:30 <jusss> about Monad transformer, when and what situation I should use it?
00:04:44 <koz_> jusss: Whenever you want to compose monads.
00:04:47 <jle`> jusss: i think that depends on the specific trasnformer
00:04:50 <Axman6> when you need the effects from two or more monads
00:05:10 <koz_> Although to be fair, you may want to consider mtl rather than 'raw' transformers in many cases.
00:05:22 <jusss> what is mtl?
00:05:22 <jle`> but i use it when i want to enhance a monad with some extra sort of effects, like using IO with some environment, or maybe some short circuiting failure
00:05:54 <Axman6> and want to be explicit about which manad you're using (with the alternative being to use mtl style where you only list constraints about what your monad can do)
00:05:56 <jle`> mtl provides typeclasses for monads that have different sort of effects, so you can write to all of them polymorphically
00:06:41 <koz_> So instead of 'forcing' yourself into a specific monad stack, you specify what effects you want, and any stack that can service those effects would do.
00:07:07 <jle`> so monad transformers in specific i use when i want to 'enhance' the effects that a monad has, so to speak
00:07:07 <Axman6> IT's the difference between foo :: ReaderT Config IO a and foo :: (MonadReader Config m, MonadIO m) => m a
00:07:33 <jle`> whereas mtl is useful for a program architecture perspective, thinking about how you want to structure the architecture of your application
00:07:43 <jle`> from a high level view
00:07:51 <jle`> transformers and mtl sort of solve different problems, i wouldn't mix the two
00:08:45 <jusss> what about the simple EitherT, what it's used to ?
00:09:09 <Axman6> adding exception like behaviour to other monads
00:09:16 <jle`> one way i usually think of monad transformers is as just newtype wrappers to provide 'alternative' instances for values
00:09:21 <koz_> I gotta say, Data.Finite gives me a _lot_ of tools for writing Finitary instances.
00:09:24 <jle`> for example, we have Product and Sum
00:09:37 <koz_> For example, the Maybe a (for Finitary n a) instance is like, super-nice.
00:09:37 <jle`> which lets us pick how Monoid behaves for numbers
00:09:41 <jle`> > foldMap Product [1..10]
00:09:43 <lambdabot>  Product {getProduct = 3628800}
00:09:45 <jle`> > foldMap Sum [1..10]
00:09:45 <dminuoso> jle`: Mmm that seems workable.
00:09:48 <lambdabot>  Sum {getSum = 55}
00:09:57 <koz_> fromFinite = fmap fromFinite . unshift; toFinite = maybe 0 (shift . toFinite)
00:10:00 <jle`> the newtype wrapper becomes a hack for selecting what <>, mempty are
00:10:25 <jle`> so for MaybeT, for example, newtype MaybeT m a = MaybeT (m (Maybe a))
00:11:00 <jle`> so it provides a lot of new instances for 'm'...for example, it provides an alternative Monad instance, where >>= does something different than it would normally do for 'm'
00:11:15 <jle`> in particular, >>= is now "aware" of Nothing/Just, so it can choose to short-circuit in case of a Nothing
00:11:43 <jle`> so one way you can look at using MaybeT is, ">>= for IO doesn't do what I want.  it doesn't short circuit when I hit a Nothing.  but if i wrap it in this newtype wrapper, >>= will do what i want it to do"
00:11:54 <jle`> >>= for MaybeT IO, that is
00:12:13 <dminuoso> jle`: Its just mildly annoying to have to put the element to scrutenize into a singleton list, otoh list does give me necessary effect.
00:12:23 <jusss> do I need to implement an new >>= for MaybeT ?
00:12:42 <jle`> jusss: not if you import the MaybeT from transformers :)
00:12:47 <jle`> it defines it for you
00:13:12 <jusss> and where I can import those transformers?
00:13:15 <dminuoso> jusss: from mtl.
00:13:23 <jle`> Control.Monad.Trans.Maybe
00:13:28 <dminuoso> jusss: MaybeT is, at the end, just a newtype.
00:13:56 <jle`> so for example i have `do action1; action2`.  and both of them are `IO (Maybe Int)`
00:14:05 <jle`> normally for IO, >> will do one, then the other
00:14:11 <jle`> it won't care if action1 returns Just or Nothing
00:14:18 <dminuoso> newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) } -- with the implicit understanding that "m" usually has an instance Monad.
00:14:22 <jusss> dminuoso: jle` can I think it's just a monadic type in another monadic type?
00:14:28 <dminuoso> jusss: Not quite.
00:14:35 <jle`> but we want a different >>; we want one that will stop as soon as it sees a Nothing
00:14:52 <jle`> so you can do MaybeT action1; MaybeT action2, and now this will not perform action2 if action1 returns Nothing
00:15:07 <jle`> jusss: do you understand the Product/Sum example>
00:15:09 <jle`> ?
00:15:28 <jle`> i wouldn't call "Sum" a "monoid inside another monoid"
00:15:44 <jle`> it's just something that imbues a *different* sort of monoid behavior on top of a data type
00:15:46 <jusss> jle`: no, 
00:16:01 <jle`> so if i apply MaybeT to IO, then `MaybeT IO` is just a slightly different version of IO with a slightly different Monad instance
00:16:01 <koz_> jle`: Yo dawg, we heard you like monoids? :P
00:16:12 <jle`> like a Monad -> Monad type-level function, in a way
00:16:16 <dminuoso> jusss: The usual monad transformers take a base monad, a precursor monad and then imbue the base monad with the effect of the precursor monad, somehow.
00:16:29 <jle`> jusss: are you familiar with monoids?
00:16:39 <dminuoso> jle`: In case of "MaybeT IO" the base monad is IO, and it gets imbued with the effect from Maybe, somehow.
00:16:39 <jle`> > [1,2,3] <> [4,5,6]
00:16:42 <lambdabot>  [1,2,3,4,5,6]
00:16:48 <jusss> jle`: actually I have never understand why you people call Either can catch the exceptions,
00:16:50 <dminuoso> Oops, tab completion mistake.
00:17:11 <dminuoso> jusss: You can catch an exception by pattern matching on some "Either E T"
00:17:16 <jle`> jusss:  have you tried writing the Monad instance for `Either e`?
00:17:23 <jle`> it can be pretty illuminating
00:17:27 <jusss> like python or java they do have try ... except statement for catching exceptions
00:17:43 <jle`> ah, "exceptions" here is something slightly different
00:17:43 <lavalike> because when things don't go Right that's what you're Left with
00:17:54 <jle`> what you are talking about in python or java is exceptions as a language feature
00:17:59 <koz_> lavalike: That's a nice mnemonic.
00:18:00 <jle`> and a feature of the runtime
00:18:06 <dminuoso> jusss: By exception we mean the generalized notion of "here we set an error state and shortcircuit any further computation until some "catching" mechanism.
00:18:19 <jle`> when people talk about Either, we're more talking about the abstract "idea" of an error
00:18:26 <jle`> and not an actual built-in language feature
00:18:33 <jle`> the idea of "something going wrong", as a first-class value
00:18:48 <jle`> we're implementing a sort of error system "inside" the language, using normal values
00:18:55 <jle`> instead of relying on built-in features of the language/runtime
00:19:19 <jle`> that's what haskell does a lot: in a lot of other languages, things that are built in and magical in the language become just normal functions and values you can define and write within haskell
00:19:38 <jusss> ok, it seems to me like it can be Left a or Right b, because they both have Either a b,
00:19:56 <jle`> right. now, the behavior of >> is to stop as soon as it sees a Left
00:20:10 <jle`> > Right 1 >> Right 2 >> Right 3
00:20:10 <jusss> and it seems there's no type inheritance in haskell, but in kotlin or java, it seems there're type inheritance
00:20:14 <lambdabot>  Right 3
00:20:19 <jle`> > Right 1 >> Right 2 >> Right 3 >> Left True >> Right 4
00:20:21 <lambdabot>  Left True
00:20:27 <dminuoso> jusss: Right, we dont have the usual concept of inheritance at all.
00:20:31 <jle`> so if there is any Left, >> will pattern match it and return the Left
00:20:57 <jle`> this is 'short-circuiting', like with Maybe. but you also return the 'reason' why it short circuits: the value inside the Left
00:21:08 <jle`> note nothing is magical here.  >> is defined within haskell and is just a normal haskell function
00:21:13 <jusss> jle`: yeah, I saw those usage, and some js people turn it to a way to instead of some if-else usage
00:21:14 <jle`> all that's happening here is normal pattern matching
00:21:25 <jle`> do you understand that usage?
00:21:32 <jusss> jle`: kind of
00:21:50 <jle`> so we don't really say "Either can catch the exceptions".  instead, we say that Either can be used to model exception-handling in a first-class value sort of way
00:22:05 <jle`> we can use Either e and its monad instance to simulate some sort of exception system
00:22:14 <jle`> but this doesn't mean "Either can catch runtime exceptions"
00:22:32 <jusss> fine, but that's really weird, 'cause exception in haskell doesn't mean what it means in other languages
00:22:33 <jle`> fwiw, Haskell actually *does* have a runtime exception system, within IO and its runtime
00:22:49 <jle`> and haskell has actual runtime exceptions and a try/catch system like python/java
00:22:54 <jle`> that system is unrelated to Either
00:23:04 <jusss> ok, I have read that part yet
00:23:07 <jusss> havn't
00:23:11 <jle`> that exception system is similar to what other languages have
00:23:21 <jle`> and is not related to Either
00:23:46 <jle`> that's why i usually don't like to call Left/Either "exceptions"
00:24:08 <jle`> because it gets confused with the actual "exceptions" system that is built into Haskell
00:24:17 <jusss> yeah
00:25:10 <jusss> let me guess, Either T should be  newtype EitherT = EitherT a m b?
00:25:27 * hackage list-witnesses 0.1.2.0 - Witnesses for working with type-level lists  https://hackage.haskell.org/package/list-witnesses-0.1.2.0 (jle)
00:25:33 <jle`> that's not quite valid syntax, but also there isn't really any straightforward way of turning a monad into a monad transformer
00:25:41 <jle`> that's why i don't really like to think of monad transformers as "combining monads"
00:26:07 <jle`> i don't think of MaybeT IO as "combining IO and Maybe"
00:26:17 <jusss> and what do you think of it?
00:26:31 <jle`> MaybeT m is a way of enhancing an 'm' with short-circuiting >>=
00:26:47 <jle`> the emphasis is on what the 'm' already does, and what it adds to the 'm'
00:26:55 <jle`> and this is a specific statement that isn't ambiguous
00:27:13 <jle`> whereas "combining IO and Maybe" is sort of ambiguous and doesn't really mean anything specific
00:27:41 <jusss> MaybeT is a monad?
00:27:49 <jle`> MaybeT is not a monad, but `MaybeT m` is a monad
00:27:56 <jle`> it takes a monad (m) and returns a new monad (MaybeT m)
00:27:59 <jusss> aha
00:28:04 <jle`> just like 'negate' returns a number and returns a new number
00:29:45 <jusss> wait a sec, but m in `MaybeT m` is already a monad
00:30:05 <jle`> right
00:30:09 <jle`> just like 1 is already a number
00:30:14 <jle`> 'negate 1' is also a number
00:30:19 <jle`> (it's a different number)
00:30:36 <koz_> :t compare
00:30:38 <jle`> m is a monad, and MaybeT m is a different monad
00:30:38 <lambdabot> Ord a => a -> a -> Ordering
00:31:14 <Ariakenom> > negate minBound == (minBound :: Int)
00:31:16 <lambdabot>  True
00:31:39 <MarcelineVQ> You've gone mad with power
00:31:40 <jusss> jle`: let's assume that m is Either a, so MaybeT Either a is a monad?
00:31:50 <jle`> MaybeT (Either a) is a monad, yes
00:32:01 <jackdk> is there a common name for the function with type forall a . a -> (a, a) ?
00:32:09 <jle`> jackdk: dup?
00:32:11 <MarcelineVQ> dup
00:32:15 <jle`> goose
00:32:16 <lavalike> :t join (,)
00:32:18 <lambdabot> b -> (b, b)
00:32:20 <jusss> I forget that kind stuff about monad, 
00:32:46 <Axman6> MAybeT (Either e) a is a monad
00:32:52 <Axman6> MaybeT*
00:32:57 <jusss> and MaybeT (Either a) need a type b so it can be a type?
00:33:03 <lavalike> :t join (&&&) id
00:33:05 <lambdabot> a -> (a, a)
00:33:17 <jle`> well, it's already a type. but you can only have values of type `MaybeT (Either e) a`, for instance
00:33:25 <Axman6> (uh, well technically MAybeT (Either e) is a monad)
00:33:28 <jle`> `MaybeT (Either a)` is a monad, so it's kind * -> *
00:33:29 <comerijn> jusss: It's already a type, it just not a type with kind * (all values have types with kind *)
00:33:41 <jle`> so it follows all of the kind rules of any other monad
00:33:50 <jle`> ie, you can't have values of type Maybe, but you can have values of type Maybe Int
00:34:02 <jusss> wait a sec, what stuff about monad should follow about kind?
00:34:04 <jle`> you can't have values of type MaybeT (Either String), but you can have values of type MaybeT (Either String) Int
00:34:05 <jusss> *->*?
00:34:15 <jle`> well, all monads are kind * -> *
00:34:33 <jusss> and Maybe a is ?
00:34:35 <jle`> Maybe, IO, Either e, (->) r, (,) w, etc.
00:34:40 <jle`> `Maybe a` is kind *
00:34:54 <merijn> jusss: "Maybe :: * -> *", "Int :: *", so "Maybe Int :: *"
00:34:54 <jle`> values of type `Maybe a` we often call 'monadic values'
00:34:55 <jusss> Maybe is ?
00:35:05 <jle`> Maybe, IO, Either e, (->) r, (,) w, etc. are all * -> *
00:35:07 <jle`> :k Maybe
00:35:10 <lambdabot> * -> *
00:35:15 <merijn> jle`: Man, you wrote a blogpost against that terminology and now you're using it!
00:35:17 <jle`> :k MaybeT (Either String)
00:35:19 <lambdabot> error:
00:35:19 <lambdabot>     Not in scope: type constructor or class ‘MaybeT’
00:35:19 <lambdabot>     Perhaps you meant ‘Maybe’ (imported from Data.Maybe)
00:35:28 <jle`> merijn: i have become the very thing i swore to destroy D:
00:35:35 <jusss> so we give a 'a' to Maybe and we get Maybe a, right/
00:35:42 <jle`> yup
00:35:59 <jle`> merijn: although i don't really know a better name for such values. i like to call them motes
00:36:36 <jle`> @let import Control.Monad.Trans.Maybe
00:36:37 <jusss> and we give a 'b' to MaybeT (Either a) , we get MaybeT (Either a) b, which is also a type, but MaybeT (Either a) is already a type ?
00:36:39 <lambdabot>  Defined.
00:36:41 <jle`> :k MaybeT (Either String)
00:36:43 <lambdabot> * -> *
00:36:58 <jle`> jusss: MaybeT (Either String) is * -> *
00:36:59 <jackdk> thanks team. I like the name dup, and it's also dupe in the extra package.
00:37:04 <MarcelineVQ> jle`: hoho c'mon now that's quite a deep joke, it's so deep​ I'll have to google it myself to explain it
00:37:15 <jusss> jle`: I have a little confused, is it a type?
00:37:26 <jusss> MaybeT (Either String) is a type?
00:37:38 <jle`> some people (including me) call it a type, but it's not a type that can have values
00:37:42 <jle`> it's not a *-kinded type
00:37:51 <jle`> it's not a "fully saturated" type
00:37:58 <jle`> but, it is a Monad
00:38:03 <Ariakenom> type is not Type and also not TYPE
00:39:04 <koz_> Or tYPe (but that's just trolling).
00:39:15 <jusss> jle`: then we may shouldn't call it a type...
00:39:37 <dminuoso> jusss: It is a type.
00:39:48 <dminuoso> jusss: A type is something that exists on the type level.
00:39:49 <jusss> dminuoso: then which value can have that type?
00:40:02 <jusss> values have types
00:40:04 <dminuoso> jusss: The kind system basically tells you.
00:40:13 <jle`> jusss: values have types, but not all types can have values
00:40:20 <dminuoso> jusss: Only types of kind * can be inhabitated.
00:40:21 <jackdk> yes, but not every type classifies values
00:40:31 <jle`> it's kind of like, squares are rectangles, but not all rectangles are squares
00:40:49 <dminuoso> jusss: Just like the type system classifies values, the kind system classifies types. So by looking at the kind of a type, you can tell whether a type is even inhabitatable.
00:41:03 <dminuoso> It wont tell you whether it is actually inhabitated for other reasons, but that's a far less interesting topic.
00:42:01 <jle`> "squares are rectangles. but this rectangle is not a square. maybe we shouldn't call it a rectangle."
00:43:05 <jle`> some confusion comes from baggage coming from other languages, though.  in other languages, the only context in which you hear about types is by how they classify values
00:43:16 <jle`> so you start to believe that the only use of types is for classifying values
00:43:17 <DigitalKiwi> what do you call a rectangle if not a rectangle?
00:43:29 <jle`> DigitalKiwi: that's my point :)
00:43:33 <mycroftiv> in an pure math sense could there always be an instance of a type for any type? but not every possible abstraction is necessarily bindable to a specific named runtime data structure within haskell?
00:43:45 <dminuoso> mycroftiv: No.
00:43:56 <jle`> you could associate a value to any type arbitrarily
00:44:07 <jle`> but that doesn't mean that it'll show up when you do :t (that value) in ghci
00:44:31 <mycroftiv> dminuoso: what is an example of type with no possible example, in the sense of just mathematical definitions, not code?
00:44:35 <jusss> that's null in jave
00:44:59 <DigitalKiwi> jle`: you said don't call rectangles rectangles...what do you call them then
00:45:12 <dminuoso> mycroftiv: So if we define the usual infinite tower, and we just define that any type with a kind other than ⌜*⌝ is not inhabitatable...
00:45:19 <DigitalKiwi> oh, wait, i misread
00:45:22 <DigitalKiwi> nvrm
00:45:59 <jle`> mycroftiv: "just mathematical definitions" --- remember that the idea of a type, term, value, etc. aren't universally defined
00:46:05 <jle`> they only exist within the construct of a type system
00:46:32 <dminuoso> And even an inhabitatable type can be uninhabitated, if the type system allows for it.
00:46:33 <jle`> and most type systems that support higher-kinded types will restrict inhabitable types in that way
00:47:13 <jle`> it's not like Integer where there is one canonical 'definition' and behavior within mathematics (with some other fringe nonstandard numerals to the side)
00:47:41 <jle`> it's more like "identity element" where every monoid has a different identity element, and it doesn't make sense to talk about an identity element without referring to the monoid structure
00:51:03 <dminuoso> jusss: A motivating example to see how things like (->) and Either themselves are types, is understanding that on the value level not only ⌜1⌝ and ⌜"foobar"⌝ are values, but functions like ⌜\x -> x + 10⌝ themselves are values too.
00:51:53 <dminuoso> jusss: So on that basis you can also understand (->) and Either as type functions, but that does not preclude them from being types.
00:52:01 <mycroftiv> hmm, i guess i had thought from studying logic that any consistent structure definable in um first order logic(?) has a model and that would apply to any type definable within a finite axiom schema, but i think im in way over my head talking about this
00:52:06 <dminuoso> Similarly how "value functions" are functions too.
00:52:26 <dminuoso> Err how "value functions" are values too. :)
00:53:41 <dminuoso> Either is all three: a) a type, b) a type function (that is a function acting on types), and c) a type constructor
00:54:58 <dminuoso> Right is also all three: a) a value, b) a (value-level) function, and c) a data constructor
00:55:47 <jusss> dminuoso: Either is a type? Either a b is a type
00:56:06 <jusss> and also Right b is a value, Right is a value?
00:56:14 <dminuoso> Yes.
00:56:35 <dminuoso> jusss: The key part is what jle` said:
00:56:38 <dminuoso> 09:42:43        jle` | some confusion comes from baggage coming from other languages, though.  in other languages, the only context in which you hear about types is by how they classify values
00:56:39 <dminuoso> 09:42:54        jle` | so you start to believe that the only use of types is for classifying values
00:56:42 <jusss> they're type/value constructor, I can understand, because they need a type or value to consturct an new one
00:57:07 <dminuoso> jusss: Formally speaking, a type is just something that exists on the type level.
00:57:15 <dminuoso> jusss: Just like a value is something that exists on the value level.
00:57:45 <jusss> dminuoso: and 'bout that kind?
00:57:50 <jusss> kind stuff
00:57:50 <jle`> jusss: 'Right' is a value, right?
00:58:02 <jle`> do you agree that 'Right' is worth calling a value, as an expression?
00:58:06 <jusss> jle`: base your story, it is
00:58:09 <jle`> it's something you can pass to 'id'
00:58:15 <jle`> or any other higher-order function
00:58:29 <jle`> functions are all values in Haskell, because they aren't any different from any other values
00:58:35 <jle`> they obey the same rules that all values have to obey
00:58:47 <jle`> and you can do with functions what you can do with any other sort of value in haskell
00:59:16 <dminuoso> jusss: Forget the notion that a "type is something that has values", its a dangerous assumption that holds true for only the simplest type systems. Lets just define the type system as a separate detached universe in which objects are allowed to exist.
00:59:25 <jusss> I can pass Right String to function id, but I don't think I can pass Right to id
00:59:25 <dminuoso> jusss: Elements inside that universe are called types.
00:59:37 <jle`> jusss: try :)
00:59:39 <jle`> :t id Right
00:59:41 <lambdabot> b -> Either a b
00:59:44 <jle`> ta dah ~
00:59:50 <jusss> jle`: no, that's currying
00:59:54 <jle`> > let f = id Right in f 10
00:59:55 <dminuoso> jusss: No its not.
00:59:57 <lambdabot>  Right 10
01:00:01 <dminuoso> jusss: Its proper function application.
01:00:02 <jle`> jusss: what is being curried here?
01:00:30 <jle`> `id x = x`, and you evaluate that by substituting `id x` with `x`.  that's what's going on here: how do you evaluate `id Right`?
01:00:34 <jusss> wait, I will try it
01:00:37 <jle`> you look at the rule `id x = x`, so `id Right = Right`
01:00:49 <jle`> > let f = const Left "hello" in f True
01:00:53 <lambdabot>  Left True
01:01:04 <jle`> > let f = const Left Just in f True
01:01:07 <lambdabot>  Left True
01:01:12 <jle`> here we pass both Left *and* Just to 'const'
01:01:18 <jle`> and apply that result to True :)
01:01:30 <jle`> to evaluate this we, look at the rules of function evaluation for values
01:01:33 <jle`> `const x y = x`
01:01:39 <jle`> so `const Left Just = Left`.
01:01:52 <jusss> ok, f = id Right, it's fine
01:01:52 <jle`> simple. that's because we don't treat Left any different...it's just like any other value we could pass to 'const'
01:02:04 <jusss> Right is a value,
01:02:29 <dminuoso> jusss: The specialty of Right is just that it's also a data constructor. The relevance of that is merely that you can do pattern matching with it.
01:02:32 <jusss> so can we say monad is a type now?
01:02:41 <jusss> Maybe is a type?
01:02:41 <jle`> well, a monad like Maybe is a type
01:03:21 <jusss> ok then, you guys blow up my mind, I remember some people told me that Maybe is not a type, Maybe a is a type
01:03:47 <dminuoso> jusss: monad itself is a typeclass now!
01:03:54 <merijn> jusss: There's a lot of people using very sloppy terminology, unfortunately
01:04:04 <jusss> dminuoso: I mean type, not typeclass stuff
01:04:35 <jle`> honestly i don't think it's a universal consensus and you'll get different people saying different things on whether or not type-level terms can be called types
01:04:48 <jle`> in the end the terminology is a tool to aid in understanding
01:04:54 <jusss> dminuoso: merijn jle` does this type Maybe has a value?
01:05:02 <dminuoso> jusss: Nope!
01:05:02 <jle`> nope, Maybe has no values of that type
01:05:10 <jusss> or monad can have value?
01:05:12 <MarcelineVQ> Maybe being a type isn't too contentious. The more common confusion is when someone says Either is a type constructor but Either e isn't
01:05:14 <jle`> or more importantly, "X is a type" doesn't mean that there are values of type X
01:05:20 <dminuoso> jusss: Now the interesting part is, you can use the kind system to classify types according to whether they can have inhabitants at all.
01:05:38 <dminuoso> jusss: Some types can have values, others cant.
01:06:01 <dminuoso> jusss: We use the kind system to, amongst other things, classify types to say whether/when a type can have inhabitants at all.,
01:06:09 <jusss> dminuoso: how to use this kind system
01:06:15 <jle`> MarcelineVQ: i think it's the opposite.  'Either e' definitely is unambigously not a type constructor, but the report is sort of not straightforward on whether non-* kinds are types. it contradicts itself
01:06:35 <dminuoso> jusss: In Haskell its tied into the type system automatically, just like the type system is tied into the value world.
01:07:22 <dminuoso> jusss: Your question is like "how to use this type system" 
01:07:32 <dminuoso> jusss: You can use :k in ghci to ask a type for its kind
01:07:36 <dminuoso> % :k Either
01:07:36 <yahb> dminuoso: Either :: * -> * -> *
01:07:39 <jle`> jusss: one basic way to utilize it is that only types of kind * can be inhabited
01:07:43 <dminuoso> So the kind of Either is "* -> * -> *"
01:08:03 <dminuoso> Since, like jle` just said, only types of kind * can be inhabitated, Either cannot because it does not have kind *.
01:08:38 <jle`> so you can answer your question: "does Maybe have any values of this type", by looking at the kind of Maybe
01:08:40 <jle`> :D
01:08:56 <jusss> dminuoso: jle` sorry, is there another word can express this to instead 'inhabited'?  English is not my mother togue
01:09:10 <dminuoso> jusss: If a type is inhabitated, there exist values of that type.
01:09:14 <jle`> "can have a type"
01:09:23 <merijn> jusss: "type Foo is inhabited" = "there is at least one value with type Foo"
01:09:56 <merijn> jusss: And reversed: "type Foo is uninhabited" = "there are no values with type Foo"
01:10:05 <dminuoso> jusss: Note that we also use "inhabitatable" which has a slightly different connotation.
01:10:30 <dminuoso> jusss: We say that types of kind * are inhabitatable, which means that they *could* be inhabitated. (We dont know for sure, but the kind system at least allows for it)
01:12:36 <dminuoso> So a type of kind * is, by the rules of the kind system, allowed to have values - but its allowed to have none. Contrarily a type of kind (* -> *) is not allowed to have any values.
01:13:15 <jusss> so if a type's kind is *, it can have values, otherwise it can't?
01:13:23 <dminuoso> jusss: Precisely.
01:13:35 <merijn> dminuoso: We do know it's inhabited
01:13:44 <merijn> dminuoso: Since bottom inhabits every type of kind * :)
01:14:07 <dminuoso> merijn: If we want to employ pedantry, we could imagine an empty type of kind TYPE UnliftedRep
01:14:14 <dminuoso> Couldn't we?
01:14:56 <dminuoso> (Im not sure whether GHC in its current state actually allows for that, but surely such a modification would be minor and morally correct)
01:15:15 <dminuoso> Besides, we should probably ignore bottom :)
01:15:19 <jusss> wait a sec, [] is *->*
01:15:38 <dminuoso> jusss: [] is just a bit weird because it has special cased syntax.
01:15:51 <dminuoso> jusss: You could imagine ⌜[Int]⌝ as just ⌜List Int⌝
01:15:52 <jusss> [Int] is *
01:16:06 <tdammers> it sometimes help to think of [] (the type) as an alias for List, and [a] as an alias for List a
01:16:33 <jusss> but it seems ghci doesn't auto import the type List
01:16:42 <dminuoso> jusss: For what its worth, you could also write: ([]) Int
01:16:45 <jusss> :k List got error
01:16:47 <lambdabot> error: Not in scope: type variable ‘got’
01:16:47 <lambdabot> error: Not in scope: type variable ‘error’
01:16:48 <merijn> dminuoso: UnliftedRep doesn't exist in Haskell
01:16:58 <jusss> :k List
01:16:59 <lambdabot> error:
01:17:00 <lambdabot>     • Pattern synonym ‘List’ used as a type
01:17:00 <lambdabot>     • In the type ‘List’
01:17:00 <dminuoso> jusss: It doesnt actually exist.
01:17:10 <dminuoso> jusss: Im just saying imagine that type constructor existed.
01:17:18 <jusss> dminuoso: ...
01:17:30 <dminuoso> jusss: My point is, [a] is just special because it has special application syntax.
01:17:39 <dminuoso> But you could also apply [] to another type via juxtaposition
01:17:45 <merijn> > [1..5] :: [] Int -- doesn't even need parenthesis
01:17:47 <lambdabot>  [1,2,3,4,5]
01:17:47 <dminuoso> % :k [] Int
01:17:48 <yahb> dminuoso: [] Int :: *
01:17:59 <dminuoso> jusss: ^- see? You can write "[] Int" just fine. :p
01:18:09 <dminuoso> jusss: It's just that [Int] means "[] Int" really
01:18:35 <jusss> dminuoso: why not List, people prefer names I think,not symbols
01:18:44 <dminuoso> jusss: Good question, it was a design decision.
01:19:03 <dminuoso> jusss: It could have been List just as well, really. But [] won.
01:19:27 <dminuoso> jusss: Next up, the kind system tells you how application can work
01:19:29 <dminuoso> jusss: For example
01:19:30 <jusss> I never found >>= <*> that stuff, I like to call it bind and apply
01:19:31 <dminuoso> % ;k []
01:19:31 <yahb> dminuoso: ; <interactive>:341:2: error:; Parse error: module header, import declaration; or top-level declaration expected.
01:19:35 <dminuoso> % :k []
01:19:35 <yahb> dminuoso: [] :: * -> *
01:19:50 <dminuoso> jusss: Do you think [Maybe] is a valid type? Make an arugment for your position.
01:20:14 <jusss> :t [Maybe]
01:20:15 <lambdabot> error:
01:20:15 <lambdabot>     • Data constructor not in scope: Maybe
01:20:15 <lambdabot>     • Perhaps you meant one of these:
01:20:34 <dminuoso> jusss: :t operates on value level constructs. So you give :t a value-level expression, and it tells you its type.
01:20:51 <dminuoso> jusss: similarly how :k takes a type-level expression, and it tells you its kind.
01:20:53 <Axman6> :t undefined :: [Maybe]
01:20:57 <lambdabot> error:
01:20:57 <lambdabot>     • Expecting one more argument to ‘Maybe’
01:20:57 <lambdabot>       Expected a type, but ‘Maybe’ has kind ‘* -> *’
01:21:12 <dminuoso> That kind error is somewhat misleading. :)
01:21:56 <jusss> :t [Nothing]
01:22:00 <lambdabot> [Maybe a]
01:25:30 <Ariakenom> dminuoso: lesson sabotaged by GHC itself :p
01:28:12 <mycroftiv> is there a bit of haskell code that you can feed haskell code into and it will convert f(g(x)) notation into . and/or $ notation?
01:28:33 <cocreature> @pl \x -> f (g x)
01:28:33 <lambdabot> f . g
01:28:35 <cocreature> ^ mycroftiv 
01:28:48 <cocreature> You can query lambdabot in private messages or download the tool standalone
01:29:00 <plakband> http://pointfree.io/
01:29:02 <Ariakenom> this talk of magichash reminded me of this
01:29:05 <Ariakenom> % let x = normalFunction undefined in 3
01:29:05 <yahb> Ariakenom: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:351:24 in interactive:Ghci127
01:29:11 <mycroftiv> cool thanks!
01:31:06 <koz_> @pl is amazing
01:31:06 <lambdabot> is amazing
01:31:14 <koz_> You said it lambdabot.
01:39:46 <mycroftiv> hmm lambdabot is giving me my code back from @pl unchanged: stk2d (pushInputBind (Inputtoken 17, oneplus (tostack (pushInputBind (Inputtoken 16, s2da (pushInputBind (Inputtoken 20, quote (Just [Inputtoken 10], " "))))))))
01:39:59 <mycroftiv> is it because of the use of tuples in the pipeline?
01:40:20 <dminuoso> jusss: My point is, the kind system tells you that [] takes a type of kind * and it returns a type of kind *
01:40:40 <dminuoso> jusss: So [] applied to Maybe will not kind check, since [] expects a type of kind *, but Maybe :: * -> *
01:43:15 <MarcelineVQ> mycroftiv: points are the bindings in an expression "\x y -> x + y" \x y -> are the things @pl (pointless) removes
01:43:33 <dminuoso> jusss: The kind system is to the type system as the type system is to the value world. Just like the type system classifies values and creates limitations about what you can and cant do in the value world, the kind system classifies types and it creates limitations about what you cant and can do in the type world.
01:43:45 <dminuoso> jusss: And just like you can do computation in the value world, computation in the type world is possible too.
01:44:08 <mycroftiv> i see, so it doesnt generally convert continuous function application to . notation, it gets rid of the named pattern matched variables?
01:44:44 <jle`> indeed :) but you can trick it into doing that by taking those values as parameters in a function
01:44:52 <fendor> @pl (\conn -> forM_ mails $ \mail -> sendMail mail conn)
01:44:52 <lambdabot> forM_ mails . flip sendMail
01:48:36 <mycroftiv> thanks, ill play around with the tool and renotating stuff.
01:51:45 <jusss> dminuoso: and what about Rank-N and higher logic stuff
01:52:26 <jusss> higher-order logic
01:52:39 <jusss> it's related to kind?
01:52:45 <dminuoso> jusss: Nope
01:52:45 <merijn> jusss: RankN isn't really
01:53:00 <dminuoso> jusss: Its basically about extending where you can put universal quantification in.
01:53:42 <merijn> jusss: This is the simplest example of exactly what problem RankN types solve: https://gist.github.com/merijn/77e3fa9757658e59b01d
01:53:56 <jusss> the latest ghci version did something about the kind system?
01:54:18 <jusss> or updated?
01:54:38 <dminuoso> jusss: In very short terms, RankNTypes is, amongst other things, what allows you to specify "my argument itself must be a polymorphic function"
01:55:16 <dminuoso> So with rank 1, you can only produce polymorphic things, but you cant demand that your consumer must pass you a polymorphic thing.
01:56:19 <jusss> ok, and higher-order logic?
01:56:38 <dminuoso> Well that's a logic topic, isn't it? :)
01:57:05 <jusss> did we use that stuff in haskell? :)
01:57:48 <jusss> type for value, kind for type, so what for kind?
01:57:58 <jusss> kind for kind?
01:58:10 <dminuoso> jusss: the next layer is called "sort" in haskell, but its blant and boring.
01:58:27 * hackage backprop 0.2.6.3 - Heterogeneous automatic differentation  https://hackage.haskell.org/package/backprop-0.2.6.3 (jle)
01:58:34 <dminuoso> Its boring because there exists only a single sort called "BOX"
01:58:44 <dminuoso> So there's no useful classification anymore.
01:58:49 <jusss> dminuoso: what type system haskell use?
01:58:56 <dminuoso> jusss: Some other languages have infinite towers.
01:59:45 <jusss> about those type systems, there're differences among them?
02:01:39 <dminuoso> jusss: So in Agda for example you have ⌜Set : Set1⌝, ⌜Set1 : Set2⌝, ⌜Set2 : Set3⌝ and so forth
02:01:43 <dminuoso> Ad infinitum.
02:02:14 <dminuoso> jusss: In Haskell however we are making a move to change our type and kind system to do something completely different
02:02:35 <dminuoso> Called TypeInType where we crush the tower of "types, kinds and the rest" into just the "type world"
02:02:43 <dminuoso> Such that: Type :: Type
02:03:19 <dminuoso> So values have types, and types have a types.
02:04:09 <Ariakenom> 1 :: Int, Int :: Type, Type :: Type. (Type is same as *)
02:04:42 <merijn> I don't think introducing TypeInType to beginners is really helpful >.>
02:04:52 <merijn> Also, TypeInType is an abomination
02:05:13 <merijn> I'll take stratified universes over it any day
02:06:57 <dminuoso> jusss: Regarding your question "what kind of type system does Haskell have" - I dont think it has a particular name other than "the type system of Haskell/GHC". Some features are inherited, such as inference coming from Hindley Milner.
02:07:03 <jusss> wow, types have types?
02:07:37 <dminuoso> jusss: Well yeah. Anyway, you probably best forget it again - it's just what the future holds for us. Until then, types have *kinds*
02:08:02 <dminuoso> And after kinds there's nothing really.
02:08:09 <merijn> Sorts!
02:08:25 <dminuoso> merijn: I did mention it and point out that it was trivial, so..
02:08:34 <dminuoso> We might as well pretend that it didnt exist.
02:09:41 <dminuoso> jusss: At the end the kind system is very simple, consisting of, essentially, just two primitives. * and (->). A confusing part here is that (->) is a construct that exists in all three worlds. It exists, syntactically at least, in the value world, it exists as a type, and it exists as a kind.
02:10:11 <dminuoso> Unlike types which can be much richer since you can have type families and type constructors
02:11:23 <mycroftiv> is it possible to define a type that is a kind of 'postive version' of russel's barber paradox? aka a function which accepts functions as input, and demands that those functions accept the same kind of input as the function whose type is being defined?
02:12:09 <mycroftiv> oops i should have said 'same type of input' i wasnt trying to reference the kind vs type thing
02:12:31 <dminuoso> mycroftiv: Well you can implement SKI combinator calculus in the type system... is that enough?
02:12:51 <mycroftiv> i have no idea, ill look that up and think about it, thank you for the reference
02:15:30 <jusss> dminuoso: and what that (->) is named? and it's related to Kleisli arrow?
02:15:58 <dminuoso> jusss: I'd say "function" 
02:16:25 <dminuoso> So the kind (* -> *) is the kind of all type functions taking a type of kind * and returning a type of kind *
02:16:36 <dminuoso> Maybe is one inhabitant of that kind.
02:16:43 <dminuoso> Either Int is another inhabitant of that kind.
02:16:49 <dminuoso> Const () is yet another.
02:17:03 <dminuoso> (All three are type functions)
02:17:28 <dminuoso> Equivalently, the type "Int -> Char" is inhabitated by all the functions taking an Int and returning a Char.
02:18:30 <mycroftiv> dminuso: thanks this is exactly what i was looking for!
02:19:58 <jusss> dminuoso: and *->*->* is a type function which take two types of kind * and return one type of kind *?
02:20:19 <dminuoso> jusss:  *->*->* is a *kind*
02:20:27 <Ariakenom> % :k Void#
02:20:28 <yahb> Ariakenom: Void# :: TYPE ('TupleRep '[])
02:20:47 <dminuoso> jusss: This might sound like pedantry, but being careful about the terminology can save you from confusion. And not exactly actually
02:21:06 <dminuoso> jusss:  * -> * -> * is the kind of all types, who take something of kind * and return a type of kind * -> *
02:21:25 <dminuoso> Just like in the value level, all type functions take just a single argument.
02:21:33 <dminuoso> Ariakenom: Shush!
02:21:53 * Ariakenom hisses and runs away
02:21:55 <dminuoso> Ariakenom: Thats interesting though. Is that lifted?
02:22:04 <jusss> dminuoso: aha, but in the value level, we can say take two parameter and return one value
02:22:13 <dminuoso> jusss: But its not really two parameters on the value level either.
02:22:26 <dminuoso> ⌜f :: Int -> Double -> Char⌝ formally takes only a single argument.
02:22:51 <jusss> dminuoso: it depends what it function definition, not types 
02:22:57 <Ariakenom> dminuoso: it's C's void. Haskell's ()
02:23:05 <dminuoso> ⌜f 1 10.0⌝ is not "f applied to two arguments", its rather "f applied to 1, producting a new function, which in turn is applied to 10.0"
02:23:22 <dminuoso> jusss: All functions in Haskell take a single argument.
02:23:24 <Arahael> Ariakenom: Isn't C's void "int"? ;)
02:23:24 <Ariakenom> void# :: Void#
02:23:26 <jusss> dminuoso: that's currying
02:23:33 <dminuoso> jusss: Currying exists in your head.
02:23:37 <dminuoso> jusss: But sure, if that helps.
02:24:11 <jusss> dminuoso: yeah, all functions are unary functions in haskell
02:24:17 <dminuoso> jusss: Right. Same thing on the type level. :)
02:24:19 <merijn> jusss: "\x y -> x + y" is just syntactic sugar for "\x -> (\y -> x + y)"
02:24:54 <jusss> ok
02:25:08 <dminuoso> jusss: Of course sometimes we employ different mind models.
02:25:34 <dminuoso> jusss: Once you have completely accepted that functions can take only single arguments, we sometimes pretend that "f :: Int -> Float -> Char" takes two arguments, understanding that its a function that returns a function.
02:25:45 <dminuoso> jusss: The same holds true on the type level.
02:26:04 <jusss> so there're three levels, kind, type and value, right?
02:26:05 <dminuoso> So we could view Either as a type function taking two arguments, or think of it as a type function that returns a type function.
02:26:09 <dminuoso> jusss: Right.
02:26:28 <jusss> and (->) you called function is in all of them
02:27:15 <jusss> about Either a b = Left a | Right b, how I can think it as a type function?
02:27:30 <dminuoso> jusss: So the "Either" part is a type function.
02:27:42 <dminuoso> jusss: It acts a sum/plus if you want. So Either "adds" two types together.
02:27:46 <jusss> and it takes a type a then?
02:28:32 <dminuoso> jusss: Sure, so using our previous knowledge, we could say Either takes two types and it "computes/constructs" a new type.
02:28:36 <jusss> Either adds a and b return Either a b?
02:29:39 <jusss> it's interesting about those three levels, to think data Either a b = Left a | Right b again, this `data` connect that type level and value level
02:30:08 <jusss> use '=' is really interesting part, types are equals to values
02:31:11 <mniip> I think I found a bug in timezone-olson
02:32:28 <lortabac> jusss: in data declarations '=' does not mean equality
02:32:40 <jusss> dminuoso: so is there another keyword that connect kind level with type level?
02:32:51 <dminuoso> jusss: Its the same as type and value level, ::
02:32:52 <lortabac> it's just a way to introduce the definition of a data type
02:34:06 <jusss> lortabac: maybe we should use another symbol
02:34:19 <dminuoso> jusss: You can use GADTSyntax if you prefer.
02:34:39 <dminuoso> data Either a b where Left :: a -> Either a b; Right :: b -> Either a b
02:34:44 <jusss> dminuoso: the simple ADT is good for me :)
02:35:08 <jusss> I really don't like record syntax...
02:35:17 <dminuoso> jusss: Thats not record syntax. Its GADTSyntax.
02:35:27 <jusss> dminuoso: I know...
02:35:38 <jusss> I mean that {...}
02:35:52 <dminuoso> jusss: You get used to it.
02:36:04 <jusss> dminuoso: yeah
02:36:33 <dminuoso> jusss: Anyhow. The relevant part is not the sum part, that's merely how the new type acts. It's that Either takes two types and it returns another type.
02:36:49 <jusss> dminuoso: what it returns?
02:36:59 <jusss> Either a b?
02:37:11 <dminuoso> jusss: A new type that doesnt have a name of its own.
02:37:21 <dminuoso> jusss: We just identify it by the same name how it was constructed.
02:37:30 <dminuoso> jusss: This is what we mean by "Either is a type constructor"
02:38:16 <jusss> dminuoso: so what we think about like Int?
02:38:24 <dminuoso> jusss: What do you mean?
02:38:28 <jusss> Int is a type function?
02:38:36 <merijn> % :k Int
02:38:37 <yahb> merijn: Int :: *
02:38:37 <dminuoso> jusss: No.
02:38:44 <dminuoso> jusss: ^- what merijn just did :)
02:38:45 <jusss> Either is a type function which take two parameters
02:38:54 <jusss> :k Either
02:38:57 <merijn> % :k Either
02:38:57 <yahb> merijn: Either :: * -> * -> *
02:38:57 <lambdabot> * -> * -> *
02:39:25 <dminuoso> jusss: Note, because I think this is a good fit now, there are other type functions.
02:39:36 <jusss> dminuoso: like what?
02:39:40 <dminuoso> jusss: type families for example are type functions that return known types!
02:40:03 <dminuoso> (Rather than constructing new ones, like type constructors)
02:40:16 <jusss> what are type families?
02:40:22 <dminuoso> You could have a type function First which takes two type arguments and always returns the first type.
02:40:46 <dminuoso> jusss: just type functions, where you can say ⌜F Int = Double; F Char = String⌝
02:41:07 <dminuoso> Such that when you use ⌜F Int⌝ somewhere in the type system, it evaluates to Double.
02:41:15 <jusss> wow, we can use patter matching in type level?
02:41:20 <dminuoso> Yes! :)
02:41:34 <jusss> how we can do that?
02:41:59 <dminuoso> % type family F p
02:42:00 <yahb> dminuoso: 
02:42:11 <dminuoso> % type instance F Int = Double
02:42:11 <yahb> dminuoso: 
02:42:17 <dminuoso> % type instance F Char = String
02:42:17 <yahb> dminuoso: 
02:42:30 <dminuoso> % x :: F Char; x = "foobar"
02:42:31 <yahb> dminuoso: 
02:43:48 <dminuoso> jusss: There's also a different pattern matching on types, which is implemented by typeclasses.
02:44:03 <jusss> dminuoso: ok, 
02:45:04 <dminuoso> jusss: Note that F is vastly different from a type constructor. That is, "F Int" is not a new type of its own. Rather, F is applied to Int, computing the type "Double" in its place.
02:45:39 <dminuoso> jusss: But both type families and type constructors functions are type functions that take some types and return types.
02:45:46 <maralorn> So, why doesn‘t run TypeInType in all the Russel‘s Paradoxon problems?
02:45:53 <merijn> maralorn: It does
02:46:02 <merijn> TypeInType isn't consistent
02:46:04 <dminuoso> maralorn: It does, but the reasoning is that the type system is crapped anyway :)
02:46:13 <dminuoso> merijn: So adding TypeInType doesnt lead to additional inconsistency.
02:46:17 <dminuoso> Err maralorn ^-
02:46:39 <dminuoso> maralorn: https://www.seas.upenn.edu/~sweirich/papers/fckinds.pdf explains why
02:46:47 <maralorn> dminuoso: Thx
02:47:21 <mniip> that's hardly an explanation
02:47:32 <jusss> since we have value function and type function, so we have kind function too?
02:47:54 <merijn> jusss: Conceptually you could, but they're not expressible in Haskell+extensions
02:48:08 <merijn> jusss: There are languages with type systems where such things exist
02:48:27 <dminuoso> jusss: Note that TypeInType allows you express that idea.
02:48:40 <jusss> merijn: dminuoso ok
02:49:41 <dramforever> How do I build documentation for clash-prelude? I tried stack haddock, but it seems like -fplugin isn't honored when building documentation, which leads to failed typechecking.
02:49:42 <dminuoso> maralorn: The relevant paragraph quoted: "Languages such as Coq and Agda avoid the *:* axiom because it introduces inconsistency, but that is not an issue here. The FCtype language is already inconsistent in the sense that all kinds are inhabited. The type safety property of FC depends on theconsistenc"
02:49:49 <jusss> those three worlds, kind type and value, change my mind
02:49:51 <dramforever> I'm using a just cloned clash-compiler repo (81e2350) and the full log of 'stack haddock' is here: https://gist.github.com/dramforever/d9a7b9650074cfd59d91ca14af679a9c
02:49:57 <dminuoso> Because mniip didn't like me linking an entire paper to answer a simple question, justifiedly. :P
02:50:18 <dminuoso> Oh gosh, what did weechat do to that paste.
02:50:39 <mniip> nah it was more of a, the explanation in the paper is not sufficient imo
02:50:46 <dramforever> More generally, how do I build documentation for code that require something like {-# OPTIONS_GHC -fplugin GHC.TypeLits.KnownNat.Solver #-} to work?
02:51:14 <kuribas> is there a newtype to reverse a comparison?
02:51:34 <merijn> kuribas: Down?
02:51:37 <dminuoso> jusss: Either is still an interesting type constructor because it acts as a "sum" in the sense of addition of types. So "Either Int Char" is the disjoint sum of the Int and Char type. :)
02:51:42 <kuribas> merijn: thanks
02:51:48 <kuribas> :t Down
02:51:49 <merijn> > sort (map Down [1..5])
02:51:51 <lambdabot> a -> Down a
02:51:52 <lambdabot>  [Down 5,Down 4,Down 3,Down 2,Down 1]
02:52:43 <dminuoso> jusss: Once you get into this business, there's lots of trivialities to discover. Like there is a type with no inhabitants, called Void. So just like "a + 0 = a" you get "Either a Void ~ a". You can start to think of ADTs are just adding and multiplying types together. :)
02:52:55 <dramforever> > sortOn Down [1..5]
02:52:59 <lambdabot>  [5,4,3,2,1]
02:53:10 <dminuoso> jusss: (,) takes the role of multipyling two types, with () as its unit. 
02:53:27 <kuribas> dminuoso: except that every type in haskell is inhabited with bottom
02:54:04 <dminuoso> kuribas: I honestly wonder what the point of raising that point is, repeatedly. :p
02:54:13 <jusss> dminuoso: we can do function on type level that is really change my mind about type stuff
02:54:50 <kuribas> dminuoso: ah, I didn't see you already mentioned it...
02:55:00 <dminuoso> kuribas: No and I didnt intend to, honestly.
02:55:14 <lortabac> maralorn: probably the simplest explanation of why Type :: Type is not a problem is that Haskell is not meant to be used as a proof-assistant
02:55:18 <dminuoso> kuribas: Im not sure this "bottom disclaimer" is going to help newcomers.
02:55:41 <jusss> dminuoso: is there only two functions on type level? add and multipy?
02:56:02 <dminuoso> jusss: Well you can make your own type constructors which use them inside.
02:56:17 <kuribas> dminuoso: because it makes the Void type useless in haskell
02:56:21 <jusss> dminuoso: for example?
02:56:38 <MarcelineVQ> can't be that useless, it's occupying space in base
02:56:42 <dminuoso> jusss: Using a pseudo language you could make "T a b = (a * b) + b" - in actual Haskell that would look: newtype T a b = L a b | R b
02:57:24 <dminuoso> Err, data type of course!
02:57:37 <jusss> dminuoso: yeah, but that's still just multipy and add, any others?
02:57:47 <kuribas> MarcelineVQ: for completeness probably
02:58:11 <dminuoso> jusss: You can use type families too!
02:58:17 <dramforever> jusss: you can also throw recursive data types in the mix
02:58:44 <jusss> dramforever: wow, you mean do recursive in the type function?
02:59:03 <dramforever> Uhh not really
02:59:03 <jusss> that sounds what should I say
02:59:18 <dminuoso> jusss: So for example you could make some ⌜T a b = (Better a b) + b⌝, which would be encoded by : ⌜data T a b = L (Better a b) | R b⌝
02:59:36 <dminuoso> Where Better is some suitable type function (could be a type family or a type constructor)
02:59:48 <dramforever> But consider data List a = Nil | Cons a (List a)
02:59:56 <dminuoso> jusss: You can achieve full computational power in the type system, so you can do complicated type computations.
03:00:05 <dramforever> List *is* of kind * -> *
03:00:21 <dramforever> I don't know if you consider that a 'type function'
03:00:56 <dramforever> (The built-in List is called [] in Haskell)
03:01:16 <dminuoso> dramforever: We've been operating under the assumption that any type of kind ⌜g -> k⌝ for some choices of g and k are type functions.
03:01:38 <dramforever> Then it is
03:02:15 <jusss> about type families, this is an exist term?
03:02:30 <dminuoso> jusss: I just made one earlier, did I not? :)
03:02:46 <jusss> dminuoso: I'm not familiar with it yet :(
03:03:37 <dminuoso> jusss: A type family is just a "mapping from types to types" basically. This should be familiar, remember how (value) functions are just mappings from values to values?
03:04:06 <jusss> dminuoso: yeah
03:04:30 <dminuoso> % type family F x where F Int = Char; f x = Int
03:04:31 <yahb> dminuoso: ; <interactive>:359:37: error: Malformed head of type or class declaration: f x
03:04:54 <dminuoso> % type family F x where F Int = Char; F x = Int
03:04:54 <yahb> dminuoso: 
03:04:56 <MarcelineVQ> kuribas: That's not especially compelling, there's plenty of things missing from base, should be put them in there? :> https://www.fpcomplete.com/blog/2017/07/to-void-or-to-void is a reason Void is pretty neat, there's probably more compact examples out there though
03:05:07 <dminuoso> jusss: ^- this is a simple type family mapping Int to Char, and every other type to Int.
03:05:23 <jusss> dminuoso: ok
03:05:29 <dminuoso> jusss: Which type does ⌜F String⌝ evaluate to?
03:05:44 <jusss> Int
03:05:51 <dminuoso> jusss: And ⌜F Int⌝ ?
03:05:56 <jusss> dminuoso: Char
03:06:10 <dminuoso> jusss: There you go. That's a type family in a nutshell.
03:06:21 <jusss> dminuoso: ok
03:06:46 <kuribas> MarcelineVQ: none of that requires Void
03:07:24 <MarcelineVQ> All the parts involving Void do, but you don't have to write them how they're written no
03:07:48 <dminuoso> kuribas: For what its worth, the usefulness of Void and the usefulness of Void for beginners are different topics.
03:08:23 <dminuoso> kuribas: I use Void regularly to represent guaranteed bottoms, since its easier to mentally parse than to encode it with a universal quantification (because you always have to visually parse how/where the quantification happens)
03:08:58 <dminuoso> kuribas: otoh much of the reasoning of ADTs disappears if we dont pretend bottom is impossible.
03:10:57 <dminuoso> jusss: There's of course further type computation you can do by means of type application.
03:11:38 <jusss> dminuoso: like?
03:12:16 <dminuoso> jusss: Phantom types is a very simple example of how one can leverage the type system to produce guarantees.
03:14:53 <dminuoso> jusss: https://gist.github.com/dminuoso/bb97536e4c38ce7e0040b1b04f69e522
03:15:16 <dminuoso> jusss: Guaranteeing that no unsanitized input ever goes into the database.
03:16:39 <dminuoso> jusss: Anyway. There's many other ways to express ideas in the type system. 
03:16:50 <jusss> dminuoso: yeah
03:17:11 <dminuoso> jusss: Notice how the parameter to Input is completely disregarded? It doesn't correspond to any values.
03:17:11 <maralorn> What does it mean for a kind to be inhabitate?
03:17:25 <dminuoso> maralorn: It would mean that it can have types belonging to it.
03:17:54 <dminuoso> maralorn: There is no kind that is not inhabitated by a type.
03:18:07 <dminuoso> iow every kind is inhabitated by some type
03:18:28 <dminuoso> *inhabited.
03:18:49 <dminuoso> (* -> *) e.g. is inhabited by Maybe, Const (), Either Int etc...
03:20:04 <maralorn> So I have this strong association Types <-> Sets, Kinds <-> Classes. Is there some way to translate "We have a consistency problem if every kind is inhabited" to "we have a consistency problem if all classes …"?
03:20:28 <maralorn> Or am I completely off-road there?
03:20:50 <maralorn> Alternatively why is it a consistency problem that every Kind is inhabited?
03:22:37 <dminuoso> maralorn: Consider the type system for a moment.
03:22:48 <maralorn> (ftr I looked at that paper, it’s interesting. Now I just need to learn what those words mean.)
03:23:23 <dminuoso> maralorn: If via the curry howard isomorphism types are propositions, and programs are proofs - then if every saturated type is inhabitated, then there's a trivial proof for any proposition.
03:23:36 <dminuoso> Since you could just write f = undefined regardless of its type.
03:24:10 <dminuoso> Im not sure whether thats relevant to the TypeInType discussion, but that's what I know.
03:24:26 <maralorn> dminuoso: Ah, that makes sense.
03:24:43 <dminuoso> maralorn: So haskells value/type system is inconsistens as a logic system.
03:27:40 <maralorn> dminuoso: So in laymans terms: It doesn‘t matter that TypeInType is inconsistent because when you prove falsity you already have done something where you now that your program will crash?
03:27:55 <maralorn> *you know
03:28:36 <dminuoso> maralorn: Id rather you dont ask me.
03:28:41 <maralorn> ^^
03:28:54 <dminuoso> Im just a layman, so Im not qualified to answer that.
03:30:23 <mycroftiv> im actually curious how to turn this into actual code, how do i declare an 'inconsistent' or self-contradictory or 'false' type?
03:30:25 <maralorn> I wonder what an example is of a kind which one wouldn’t want to be inhabited but it is in Haskell anyways.
03:30:36 <dminuoso> mycroftiv: Void
03:30:52 <opqdonut> Void is false but not inconsistent of self-contradictory
03:31:08 <dminuoso> % :t absurd
03:31:08 <yahb> dminuoso: Void -> a
03:31:21 <opqdonut> but of course once you do "undefined :: Void" you have an inconsistency :)
03:31:28 <dminuoso> mycroftiv: This is EFQ.
03:32:52 <dminuoso> mycroftiv: (Amusingly this primitive has its uses, even in production code...)
03:33:05 <maralorn> So the "undefined :: Void" example is kinda boring. It’s like: Technically you are right, but this does obviously not matter for writing a working a program.
03:33:30 <dminuoso> maralorn: The point is, by writing "undefined :: Void" you have created a proof of falsity.
03:33:35 <maralorn> What happens if I exclude "undefined" from Haskell, can I still make it inconsistent?
03:33:41 <maralorn> dminuoso: I get that.
03:33:50 <mycroftiv> im looking for what EFQ is and ddg is being unhelpful
03:33:59 <dminuoso> mycroftiv: From falsity anything follows.
03:34:05 <dminuoso> mycroftiv: ex falso quodlibet
03:34:06 <mycroftiv> oh sure
03:35:12 <mycroftiv> yeah i understand that, i also get how undefined :: Void is a contradiction, im just more interested in encoding liar paradox into type system or somethign
03:35:17 <tdammers> maralorn: a Haskell without bottoms could not be Turing-complete
03:35:42 <maralorn> tdammers: So it‘s the bottoms. I wondered about that.^^
03:35:45 <dminuoso> mycroftiv: It's enough to implement SKI
03:36:35 <dminuoso> maralorn: Once you have that, you can use S(K(SII))(S(S(KS)K)(K(SII))) 
03:36:47 <dminuoso> mycroftiv: this gives you the y combinator, giving you general recursion
03:37:44 <maralorn> I obviously can write a function which diverges in haskell. But I cannot write it in a way that the typechecker let’s me assign Void as return type, can I?
03:37:47 <dminuoso> mycroftiv: dmwit has a good example on stack overflow https://stackoverflow.com/a/34003628
03:38:03 <dminuoso> maralorn: Well I guess the idea is to write a type where type checking diverges.
03:38:24 <Taneb> :t let maralorn :: Void; maralorn = maralorn in maralorn
03:38:27 <lambdabot> Void
03:39:57 * hackage llvm-hs-pretty 0.6.2.0 - A pretty printer for LLVM IR.  https://hackage.haskell.org/package/llvm-hs-pretty-0.6.2.0 (sdiehl)
03:40:23 <mycroftiv> thanks a lot, i figured the SKI recursion stuff would let that happen
03:40:35 <maralorn> Taneb: I feel false now.
03:40:40 <maralorn> Taneb: Thx!
03:43:44 <maralorn> So when we say any kind is inhabited, I should think of: Well there is always bottom? I mean I know bottom lifes in Types does it life in kinds?
03:43:50 <mniip> that reminds me of the one trick you can use to evaluate something at "application" time
03:44:13 <dminuoso> mniip: bottom lives in the value world, actually. :-p
03:44:21 <dminuoso> ARgh! Tab completion nightmare. maralorn I mean.
03:44:31 <Taneb> I don't think you can lift a bottom to the type level
03:45:09 <dminuoso> Taneb: In the sense of having a type inhabiated by every kind?
03:45:28 * hackage cursor-brick 0.1.0.0 -   https://hackage.haskell.org/package/cursor-brick-0.1.0.0 (Norfair)
03:45:28 <dminuoso> (Or is it "a type inhabiating every kind"?)
03:45:41 <dminuoso> Its not even inhabiating. Mmm.
03:45:42 <maralorn> Other question: Is Void the intial and terminal object of the category of all Haskell Types?
03:45:52 <mniip> wait huh
03:45:57 <Taneb> maralorn: how fast and loose do you like to reason
03:45:57 <mniip> did the trick stop working
03:46:04 <mniip> maralorn, initial not terminal
03:46:31 <mniip> unless you mean including bottoms
03:46:38 <maralorn> Taneb: Not sure, what you mean.
03:46:47 <maralorn> mniip: That’s exactly what I meant.
03:46:51 <dminuoso> maralorn: In the category Hask (which is not defined anywhere), in which types form objects and functions form morphisms, the terminal object is () and the initial object is Void.
03:47:09 <mniip> in that case yes
03:47:10 <dminuoso> maralorn: Interestingly you have Product, Coproduct, and all the usual connections work. 
03:47:12 <mniip> Void is the zero object
03:47:26 <mniip> and for any X, Y you have the zero morphism undefined :: X -> Y
03:48:45 <maralorn> dminuoso: I feel like () is not the terminal object when you regard "undefined :: a -> Void"
03:49:00 <mniip> once you stop being fast and loose though there's several catches to be aware of
03:49:08 <Taneb> I think if you have bottoms Void isn't initial. Consider "f = const 1" and "g = const 2" :: Void -> Int, if it were the initial object, then f = g and so f _|_ = g _|_ but f _|_ = 1 and g _|_ = 2
03:49:13 <mniip> e.g. undefined vs const undefined
03:49:19 <mniip> and f . undefined
03:49:27 * hackage enumset 0.0.5 - Sets of enumeration values represented by machine words  https://hackage.haskell.org/package/enumset-0.0.5 (HenningThielemann)
03:50:10 <maralorn> Uh, I forgot that you can recover from a bottom.
03:50:14 <mniip> nothing
03:50:19 <mniip> oops
03:50:31 <Ariakenom> dminuoso: about Void# you said "Thats interesting though. Is that lifted?". It's unlifted but it's not uninhabited, it uses void from C terminology. Why do you ask?
03:51:11 <mniip> Void# is the empty unlifted product
03:51:20 <mniip> it has 1 inhabitant that takes up 0 bytes
03:51:50 <Ariakenom> basically ()#
03:51:53 <maralorn> In my "Mathematical Foundations of functional programing" lecture we had a f _|_ = _|_. Which I guess makes sense in strict evaluation mode.
03:52:13 <mniip> that equation is the definition of f being strict
03:52:24 <mniip> haskell allows non-strict functions
03:52:24 <Ariakenom> % let x = normalFunction undefined in 3
03:52:24 <yahb> Ariakenom: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:369:24 in interactive:Ghci134
03:52:27 * hackage shell-utility 0.0 - Utility functions for writing command-line programs  https://hackage.haskell.org/package/shell-utility-0.0 (HenningThielemann)
03:52:34 <mniip> ah yes
03:52:37 <mniip> that was the trick
03:52:44 <mniip> apparently it doesn't work if you use _ instead of x
03:53:04 <Ariakenom> mine?
03:53:05 <Ariakenom> % let _ = normalFunction undefined in 3
03:53:05 <yahb> Ariakenom: 3
03:53:08 <Ariakenom> interesting
03:53:09 <mniip> yes
03:53:20 <mniip> % :i trick
03:53:20 <yahb> mniip: trick :: a -> Void# -- Defined at <interactive>:362:1
03:53:24 <mniip> % :i normalFunction
03:53:25 <yahb> mniip: normalFunction :: t -> Void# -- Defined at <interactive>:349:5
03:53:34 <mniip> :P
03:53:43 <Ariakenom> :D
03:54:54 <Ariakenom> % const 3 (normalFunction undefined)
03:54:54 <yahb> Ariakenom: ; <interactive>:373:10: error:; * Couldn't match a lifted type with an unlifted type; When matching types; b0 :: *; Void# :: TYPE ('TupleRep '[]); * In the second argument of `const', namely `(normalFunction undefined)'; In the expression: const 3 (normalFunction undefined); In an equation for `it': it = const 3 (normalFunction undefined)
03:59:52 <spoonm> what's normalFunction? I don't think I know that one :/
04:00:01 <spoonm> that or I missed the discussion, and hoogle isn't helping
04:00:31 <mniip>  -- Defined at <interactive>:349:5
04:01:40 <maralorn> How long does this interactive session normally life?
04:02:06 <mniip> indefinitely until the process dies from either crashing or taking too long to finish
04:02:18 <mniip> or a server reboot
04:02:48 <mniip> or if one does :quit or %kill
04:03:28 <maralorn> And what‘s the difference between yahb and lambdabot?
04:03:39 <mniip> they're just different bots in general
04:04:01 <spoonm> % normalFunction (+) 3 3
04:04:01 <yahb> spoonm: ; <interactive>:374:1: error:; * Couldn't match expected type `Integer -> Integer -> t' with actual type `Void#'; * The function `normalFunction' is applied to three arguments,; but its type `(Integer -> Integer -> Integer) -> Void#' has only one; In the expression: normalFunction (+) 3 3; In an equation for `it': it = normalFunction (+) 3 3; * Relevant bindings include it :
04:04:05 <maralorn> They seam redundant in some features.^^
04:04:30 <mniip> lambdabot runs mueval, whose security is ensured by SafeHaskell
04:04:32 <spoonm> % :t normalFunction 3
04:04:33 <yahb> spoonm: Void#
04:04:38 <spoonm> % :t normalFunction
04:04:39 <yahb> spoonm: t -> Void#
04:04:40 <spoonm> I see
04:04:50 <spoonm> well, I don't, but that much I get
04:04:51 <mniip> yahb runs an actual ghci, with a process level sandbox
04:05:02 <maralorn> Ah, okay.
04:05:38 <mniip> lambdabot has marginally better control over the session as even if your code takes too long your session isn't reset
04:05:46 <mniip> yahb on the other hand is much much less restricted
04:06:31 <mniip> % unsafeCoerce (print "hello") () :: ()
04:06:31 <yahb> mniip: "hello"; [Segmentation fault]
04:07:26 <mniip> lambdabot obviously cannot allow anything like that or any IO at all because there would be nothing stopping you from doing something evil
04:14:32 <int-e> mniip: that's not entirely true anymore, since I don't quite trust Typeable.
04:15:00 <mniip> hmm?
04:15:18 <int-e> But I do embrace the idea that the type system should be the first line of defense.
04:15:32 <mniip> are you saying how you're running it in a container
04:15:44 <maralorn> Can I import any Hackage Package?
04:15:53 <int-e> mniip: I actually have a wrapper around mueval that acts as a lightweight sandbox (a new namespace, and a different user).
04:16:02 <mniip> maralorn, import where
04:18:01 <maralorn> % System.Directory.getDirectoryContents "."
04:18:02 <yahb> maralorn: [".","..","ghci",".ghc","test.lua","LensSplice.hs","slkfhl.hs","LensSplice.hi","LensSplice.dyn_hi","a.c","THTest.hs","foo"]
04:18:49 <Ariakenom> spoonm: let normalFunction x = x `seq` void#
04:18:56 <Ariakenom> if any of that means anything to you :)
04:20:54 <mniip> maralorn, here's something for a surprise
04:21:01 <mniip> % System.Directory.getDirectoryContents "/"
04:21:01 <yahb> mniip: *** Exception: /: getDirectoryContents:openDirStream: does not exist (No such file or directory)
04:26:55 <Ariakenom> who need a root directory anyways?
04:34:18 <maralorn> mniip: Well, there is one "reasonable" explanition. ;-)
04:34:28 <maralorn> % System.Directory.getDirectoryContents "C:"
04:34:28 <yahb> maralorn: *** Exception: C:: getDirectoryContents:openDirStream: does not exist (No such file or directory)
04:34:37 <merijn> I asked yesterday, but I don't think anyone answered: Is there a Haskell library to guess which unicode encoding a file is in?
04:36:44 <mniip> maralorn, ../../../../../.. is missing too
04:37:15 <MarcelineVQ> Z drive is there though
04:42:39 <merijn> Also, is there a strict Identity somewhere already?
04:44:35 <spoonm> Ariakenom: save for `void#'
04:46:54 <Ariakenom> void# is an unboxed (). Unboxed means it has restrictions on what you can do with it, less space overhead and it's strict.
04:47:22 <AWizzArd> I would like to use monad-logger to log something in `emptyPageHandler`. How can I achieve this? https://pastecode.xyz/view/31c2acea
04:47:22 <Ariakenom> "less space overhead" it takes 0 bytes :D
04:48:17 <merijn> AWizzArd: What don't you understand?
04:48:57 <merijn> AWizzArd: You just...call one of the logging functions?
04:51:01 <jgt> AWizzArd: if you're really stuck, you can search GitHub for usage examples of the function you're interested in
04:51:55 <jgt> AWizzArd: https://github.com/search?q=MonadLogger+language%3Ahaskell&type=Code
04:52:10 <int-e> or the documentation, https://hackage.haskell.org/package/monad-logger-0.3.30/docs/Control-Monad-Logger.html#g:8
04:52:32 <int-e> (hmm, what verb... "look at the documentation")
04:53:05 <merijn> AWizzArd: I suspect your problem is that "convertApp" forces "AppT IO a", but IO is not an instance of MonadLogger, therefore your AppT isn't a MonadLogger instance either
04:54:45 <merijn> I'm confused, why can I have a strictness annotation on a newtype?
04:56:09 <int-e> merijn: you can? newtype X = X !Int  produces an error for me (ghc 8.6.5; actually ghci)
04:56:21 <merijn> eh s/can/can't
04:56:31 <int-e> merijn: because it's redundant, therefore misleading
04:57:02 <dminuoso> maralorn: Much of the category theory surrounding Hask pretends that things like seq and bottom dont exist.
04:57:17 <dminuoso> maralorn: Otherwise you cant do much reasoning.
04:57:21 <merijn> I really just want strictness polymorphic code >.>
04:58:18 <int-e> merijn: I mean it's an arbitrary choice, but those would be my reasons to disallow it. I'm not creative enough to come up with a usecase, not even with your keyword.
04:58:48 <AWizzArd> jgt: good trick, thx
04:58:59 <merijn> int-e: I just want an easy way to make, e.g. "foldMap" strict in the monoid
04:59:23 <dminuoso> maralorn: So if we pretend that bottom is not a thing, then suddenly "absurd" becomes a family of functions (this is how we tend to view polymorphic functions in category theory). for every type e, there exists a unique morphism from the initial object. absurd is the set of those functions.
04:59:27 <int-e> merijn: you can't, without generating different code for foldMap?
05:00:00 <int-e> merijn: gut reaction... if this is still a topic in 30 minutes I may think a bit harder
05:00:06 <merijn> int-e: Sure you can, newtype + monoid/semigroup instance that's strict
05:00:40 <merijn> int-e: But I guess I indeed have to manually define each of the instances for that to work
05:00:43 <int-e> merijn: so you want to avoid writing that monoid instance?
05:00:46 <dminuoso> maralorn: Now since Hask is considered a subcategory of Hask, then Void is equal/isomorphic to the empty set. And in fact, there exists a unique function from the empty set to any other set. 
05:01:04 <int-e> merijn: I see. (but afk for a bit)
05:01:11 <merijn> int-e: Writing just the monoid instance would be fine, but I have to write all the other instances too
05:01:20 <dminuoso> maralorn: Err heh. Of course I meant that Hask is a subcategory of Set. :)
05:02:48 <int-e> merijn: hrm, but I'm back to my gut reaction, except now it's the class methods of monoid and semigroups that you need different code for (in contrast to ordinary newtype deriving)
05:03:45 <dminuoso> Ariakenom: If void# is unboxed, then its necessarily unlifted.
05:03:54 <merijn> int-e: I know, you need, e.g. "newtype Strict a = Strict a; instance Monoid a => Monoid (Strict a) where mempty = Strict $! mempty; mappend (Strict x) (Strict y) = Strict $! mappend x y"
05:04:02 <dminuoso> Ariakenom: But I can see my confusion. I was hoping for a Void# that was an unlifted Void, rather than an unboxed (). :)
05:05:57 <merijn> int-e: That should work, I think?
05:09:04 <merijn> Is there an easy way to export darcs to a VC that's actually widely used? >.>
05:10:11 <dminuoso> AWizzArd: Remember that MonadLogger is, essentially, equivalent to some "MonadReader Logger" where Logger is just something akin to "Loc -> LogSource -> LogLevel -> String -> IO ()". The method monadLoggerLog basically just asks for that logging function, and passes the arguments to it.
05:10:31 <dminuoso> (There's slightly more technical detail to it, but as a rough sketch it works)
05:11:40 <dminuoso> AWizzArd: The main ways to log something is via the various TH logging functions see https://hackage.haskell.org/package/monad-logger-0.3.30/docs/Control-Monad-Logger.html#g:4 and following sections, and non-TH logging functions, see https://hackage.haskell.org/package/monad-logger-0.3.30/docs/Control-Monad-Logger.html#g:8 and following sections
05:13:59 <AWizzArd> dminuoso: such as logInfo
05:14:38 <merijn> AWizzArd: Did you see my comments?
05:15:35 <dminuoso> AWizzArd: Sure. logInfo ends up calling monadLoggerLog with some values set already. :)
05:17:12 <dminuoso> AWizzArd: ⌜logInfoN = monadLoggerLog defaultLoc "" LevelInfo⌝ basically
05:17:46 <AWizzArd> merijn: yes, cocreature helped me to patch `convertApp`.
05:20:40 <AWizzArd> dminuoso: does TH modify the defaultLoc somehow, to include the true line in which the logging occurred?
05:21:25 <dminuoso> AWizzArd: That's precisely what the TH logging functions are for.
05:22:22 <dminuoso> AWizzArd: Well, the *S logging functions, at least. :)
05:23:18 <dminuoso> Or I have to check. I think they all put in the exact code location.
05:23:21 <AWizzArd> dminuoso: I read that someone modified the lib to use “CallStack” to gather this information, without the use of TH.
05:24:10 <merijn> CallStack has performance impact, though
05:24:20 <dminuoso> AWizzArd: https://hackage.haskell.org/package/monad-logger-0.3.30/docs/src/Control.Monad.Logger.html#logTH
05:24:30 <dminuoso> AWizzArd: So qLocation is the mechanism used. 
05:25:16 <dminuoso> AWizzArd: monad-logger also has support for Callstack, which is this module http://hackage.haskell.org/package/monad-logger-0.3.30/docs/Control-Monad-Logger-CallStack.html
05:25:20 <dminuoso> But that's seems to be separate.
05:26:52 <dminuoso> AWizzArd: And qLocation is the TH magic to produce a Loc from the point where the splice occured.
05:30:30 <dminuoso> cabal question, how do I get access to the version in my cabal file inside my source code? I'd like to report the version of my software without having to keep cabal and my source code in sync.
05:30:47 <dminuoso> Does cabal introduce some CPP macro?
05:30:56 <merijn> dminuoso: Paths_package
05:31:05 <merijn> Should export a version
05:31:31 <dminuoso> merijn: What is Paths_package exactly?
05:31:56 <merijn> dminuoso: An auto-generated modules that exposes the version and paths to datafiles, etc.
05:31:59 <merijn> https://stackoverflow.com/questions/2892586/how-can-my-haskell-program-or-library-find-its-version-number
05:32:12 <dminuoso> merijn: Can I find any documentation about this?
05:32:22 <dminuoso> Google doesnt seem to give me any useful results.
05:32:34 <merijn> dminuoso: The cabal docs should have a section
05:32:57 <merijn> dminuoso: https://cabal.readthedocs.io/en/latest/developing-packages.html?highlight=getDataDir#accessing-data-files-from-package-code
05:33:08 <dminuoso> merijn: Ah cheers. I see
05:48:08 <int-e> merijn: (back from errand) nah, Strict $! isn't doing anything... newtype constructors are strict
05:49:00 <int-e> merijn: to be strict(er), mappend would have to force its arguments before passing them on.
05:50:48 <dminuoso> Mmm, what was the subtle difference between a newtype and a data type with a bang?
05:51:24 <opqdonut> newtypes get optimized away?
05:51:27 <sicklorkin> dminuoso: unpack?
05:51:28 <[exa]> dminuoso: IIRC the datatype still has the box that you can match
05:51:58 <dminuoso> [exa]: Mmm right. It was something about pattern matching
05:52:09 <int-e> dminuoso: Hmm... representation... also if you do  date Foo = Foo !Int, you may lose sharing if the Int becomes unboxed.
05:52:22 <int-e> date -> data
05:52:44 <[exa]> dminuoso: or, to be more precise, there is difference between 'undefined' and 'Foo undefined' that disappears with newtype
05:53:18 <int-e> [exa]: but if the field is strict then Foo undefined cannot exist... well theoretically at least
05:53:19 <dminuoso> [exa]: Mmm, quchen once introduced it. I remember something incredibly subtle about how the Haskell report is phrased.
05:53:46 <int-e> [exa]: In practice you can do unsafe stuff and still produce Foo undefined.
05:53:46 <[exa]> int-e: hm good point
05:57:16 <dminuoso> % data DA = DA !Bool
05:57:17 <yahb> dminuoso: 
05:57:21 <dminuoso> % data NT = NT Bool
05:57:21 <yahb> dminuoso: 
05:58:08 <dminuoso> Argh I cant reconstruct it anymore. There was something surprising and non-obvious about it.
05:58:41 <dminuoso> Something where newtype surprisingly doesnt diverge, where data would.
05:59:37 <merijn> Is there a darcs-to-git?
06:00:09 <dminuoso> merijn: you can use "darcs convert export"
06:00:52 <dminuoso> Or do you mean some sort "interacting with git repos from darcs" like in hg?
06:03:46 <merijn> dminuoso: I don't use darcs, there's just some old packages that only list a darcs repo that I want to make patches for, but I'd rather not first spend a bunch of time learning darcs...
06:05:49 <dminuoso> % case undefined of NT x -> ()
06:05:50 <yahb> dminuoso: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:8:1 in interactive:Ghci7
06:05:59 <dminuoso> % newtype NT = NT Bool
06:06:00 <yahb> dminuoso: 
06:06:01 <dminuoso> % case undefined of DT x -> ()
06:06:02 <yahb> dminuoso: ; <interactive>:10:19: error:; Not in scope: data constructor `DT'; Perhaps you meant one of these: `D#' (imported from GHC.Exts), `LT' (imported from Prelude), `GT' (imported from Prelude)
06:06:04 <dminuoso> % case undefined of NT x -> ()
06:06:04 <yahb> dminuoso: ()
06:06:06 <dminuoso> This. :)
06:06:37 <sm[m]> merijn: as dminuoso says, darcs can export to git; you could optionally then convert your git repo back to darcs if you need to send darcs patches upstream
06:06:59 <dminuoso> [exa]: Thats what I was referring to.
06:07:19 <sm[m]> though, learning enough darcs to make patches takes a few seconds
06:12:21 <AWizzArd> dminuoso: line 85 in https://gist.github.com/dminuoso/0c01e714f1ccd0c5986ee6ed5af0c2fe
06:12:39 <AWizzArd> Is this TH syntax? To put a macro between $( and )?
06:14:57 <int-e> merijn: The basic rule of thumb that I have for strictness which usually serves me well is that strictness must come from outside (in terms of how functions are applied; arguments are inside the function that is applied to them). So if you want a stricter fold, you have to start with the fold, not with the data represented inside. There are some tricks around this (you can build foldl' from foldr...
06:15:04 <int-e> ...if you like), but not many.
06:22:01 <jumper149> Hi, I'm reading the typeclassopedia atm and was wondering about monad laws
06:25:02 <jumper149> it holds `(g >=> h) >=> k = g >=> (h >=> k)`, but what about `(g >>= h) >>= k ?= g >>= (h >>= k)`
06:25:47 <merijn> jumper149: That holds too
06:26:05 <merijn> jumper149: It's just that the identity law for return is much uglier when you use >=>
06:26:10 <merijn> eh
06:26:14 <merijn> when you use >>= I mean
06:26:35 <Putonlalla> Is the question meaningful, that is, does the expression type check, jumper149?
06:26:48 <Putonlalla> Hint: no.
06:27:12 <merijn> jumper149: With >=> the identiy becomes "return >=> f" = "f" = "f >=> return"
06:27:58 <lyxia> jumper149: https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad the law is a bit more complicated to state correctly
06:28:05 <merijn> Oh, and yeah the >>= needs some more lambdas
06:28:14 <jumper149> Putonlalla: g, h and k are not the same in the 2 examples if that is what you mean
06:28:31 <Putonlalla> They ought to be the same on both sides of the same `=`, jumper149.
06:28:46 <dminuoso> AWizzArd: So template haskell is haskell code that is executed in the compiler during the parsing stage.
06:29:24 <jumper149> merijn: I just also noticed that you can define >>= in terms of >=> and return 
06:29:41 <merijn> jumper149: Well, yes
06:29:51 <dminuoso> AWizzArd: The general protocol is, roughly, that during parsing, if a splice $() is detected the parsing is halted - the template haskell code is executed, which is expected to return some kind of AST, and then the result is inserted in the splicing location.
06:30:09 <merijn> jumper149: >=> is defined in terms of >>= right now
06:30:16 <merijn> jumper149: They are equivalently powerful
06:32:05 <dminuoso> AWizzArd: So it probably produces something along the lines of  ⌜let f l = monadLoggerLog (toLoc l) LevelWarn in f⌝ inside that splicing location.
06:33:22 <jumper149> Putonlalla: Ah now I see, it becomes `(g >>= h) >>= k == g >>= (\ x -> h x >>= k)`
06:34:59 <dminuoso> jumper149: Here's a third way to describe the laws in terms of join, visualized with little ASCII drawings. https://gist.github.com/dminuoso/d5ab4ba5d8a5142dde9f4d4c736e3ecb
06:35:40 <dminuoso> jumper149: Where :.: is just composition, so ⌜(T :.: T) a ~ T (T a)⌝
06:38:04 <merijn> There's no package that just turns ansi escape sequence like colours into ByteString is there?
06:38:24 <Putonlalla> Doesn't `ansi-terminal` do that, merijn?
06:38:42 <merijn> Putonlalla: No, that just has IO operations for outputting said sequence to a Handle
06:39:16 <dminuoso> merijn, you're just so damn picky sometimes.
06:39:26 <merijn> dminuoso: hmm?
06:39:26 <dminuoso> :)
06:39:39 <Putonlalla> It used to.
06:39:44 <dminuoso> merijn: Oh it was meant as a friendly joke.
06:39:47 <dmwit> merijn: http://hackage.haskell.org/package/ansi-terminal-0.9.1/docs/System-Console-ANSI-Codes.html
06:40:07 <dminuoso> dmwit: Now he'll tell you that it's not ByteString. :-P
06:40:17 <dmwit> Yeah. But he knows how to go the last millimeter.
06:40:20 <Putonlalla> There it is, named `setSGRCode`.
06:40:21 <merijn> dmwit: Ugh...String, but I guess I'll have to live with that
06:53:16 <inkbottle> Is there a simple way to view GHC's generated AST for some Haskell code?
06:55:05 <vaibhavsagar> does anyone know what happened with `sbv`?
06:55:31 <merijn> vaibhavsagar: Being audited, apparently
06:55:47 <vaibhavsagar> what does that mean?
06:55:59 <vaibhavsagar> can it not be on GitHub while it's being audited?
06:56:02 <merijn> vaibhavsagar: Someone on reddit mentioned mailing the author, who has said it's offline while his new company is auditing it for licensing issues, etc. should be back up soon according to him
06:56:15 <AWizzArd> dminuoso: okay, so  $()  marks splices in TH. I just wanted to make sure that the parens () are for prioritizing computations, i.e. (3+7)*5,  and that the $ is not the `$` operator. 
06:56:19 <dramforever> inkbottle: Try -ddump-parsed-ast
06:56:21 <vaibhavsagar> oh, cool
06:56:29 <vaibhavsagar> thanks merijn
06:56:43 <inkbottle> dramforever: OK
06:56:43 <merijn> vaibhavsagar: https://www.reddit.com/r/haskell/comments/cpncqb/where_did_the_sbv_github_repo_go/ewqlgvn
06:57:46 <AWizzArd> dminuoso: log $(3+7) * 10
06:58:07 <dminuoso> AWizzArd: So a splice is expected to return an AST.
06:58:17 <dminuoso> Or rather, the code inside a splice needs to return some kind of AST.
06:58:27 <AWizzArd> dminuoso: yes, that aspect is clear.
06:58:38 <AWizzArd> dminuoso: I just did not know that $() is the splice syntax.
06:58:42 <dminuoso> AWizzArd: Ah gotcha.
06:58:45 <AWizzArd> I thought that $ is the operator.
06:59:09 <dminuoso> AWizzArd: I invite you to give this a brief read https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-TemplateHaskell
06:59:10 <AWizzArd> But not with TH. With TH $() is syntax and has nothing to do with $(3+7)
06:59:29 <dminuoso> AWizzArd: It covers the various splicing and quotation syntaxes.
07:00:11 <AWizzArd> dminuoso: good.
07:02:18 <AWizzArd> dminuoso: do you have a code snippet that demonstrates using fast-logger as backend/implementation for monad-logger?
07:02:40 <dminuoso> AWizzArd: monad-logger comes with some stable bindings already.
07:02:59 <dminuoso> AWizzArd: https://hackage.haskell.org/package/monad-logger-0.3.30/docs/Control-Monad-Logger.html#v:runStdoutLoggingT
07:03:09 <dminuoso> AWizzArd: You can inspect the source code if you are curious and want to write your own.
07:06:49 <merijn> Is ByteString's builder faster when you want to concatenate small numbers of small chunks very often?
07:06:51 <AWizzArd> dminuoso: good, that makes sense. I want the runFileLoggingT.
07:07:00 <merijn> Or should I just use <>
07:12:18 <monochrom> merijn: I think builder is faster. (Haven't measured!)
07:13:06 <monochrom> However, builder is also a monoid, you can <> builders :)
07:13:16 <monochrom> Hell, you must, there is no other API.
07:13:33 <monochrom> s/API/operation/
07:17:33 <AWizzArd> monochrom: sounds like a good thing (that there is just <> as API).
07:18:13 <monochrom> Yeah!
07:19:09 <merijn> monochrom: I know, it's just that I'm in an awkward position of doing a bunch of conversions between Text/ByteString and trying to minimise the conversion overhead, so finding the right level at which to concat things is annoying :)
07:19:44 <monochrom> Hey there is also Text builder!
07:20:49 <duncan> I'm trying to get completion support in emacs, but it's not clear how: https://haskell.github.io/haskell-mode/manual/latest/Completion-support.html#Completion-support
07:21:20 <duncan> I have enabled Haskell-interactive-mode, but there's not an obvious means to complete as demonstrated there. 
07:21:37 <merijn> monochrom: I know
07:24:04 <merijn> hmm, and all the conduit streams only support utf8 conversions between Text and ByteString and the "Text -> ByteString.Builder" also only exists for utf8...ugh
07:26:57 * hackage synthesizer-llvm 0.8.2 - Efficient signal processing using runtime compilation  https://hackage.haskell.org/package/synthesizer-llvm-0.8.2 (HenningThielemann)
07:40:48 <pierreimmo> Hi, I run into stack's issue #4993 and tried to set the default resolver in my ~/.stack/config.yaml
07:41:01 <pierreimmo> just a line `resolver: lts-11.22`
07:41:33 <pierreimmo> but doing `stack new` still fails whereas `stack new --resolver lts-11.22` works
07:41:49 <pierreimmo> what am I doing wrong in my config? 
07:45:48 <lyxia> I think stack new ignores that config
07:50:46 <turion> Your opinion: What's a better package name, "essenceoflivecoding" or "essence-of-live-coding"?
07:51:11 <turion> Is one of them more usual in the hackage universe?
07:53:51 <tdammers> package names are a mess
07:54:05 <tdammers> but I'd use the latter, simply because it's easier on the eyes
07:56:03 <dminuoso> It's also more common, if you skim hackage a bit.
07:58:15 <maerwald> EssenceOfLiveCoding?
07:58:58 <maerwald> or eSSENCEoFlIVEcODING
07:59:06 <lyxia> pierreimmo: https://docs.haskellstack.org/en/stable/yaml_configuration/#non-project-specific-config "resolver" doesn't seem listed in these options.
07:59:10 <ysangkok> what is an easy way to convert from base16 to a escaped haskell string literal encoding?
08:00:15 <ysangkok> as used here https://github.com/haskell-crypto/cryptonite/blob/master/tests/ECC/Edwards25519.hs
08:01:27 * hackage bulletproofs 1.0.1 -   https://hackage.haskell.org/package/bulletproofs-1.0.1 (sdiehl)
08:01:44 <ysangkok> ah i guess i can just insert \x every 2 bytes of the base16 string...
08:02:06 <ysangkok> seems like that would be allowed from spec https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-200002.6
08:09:09 <turion> tdammers, dminuoso: Ok, will go with that :)
08:09:28 <devalot> duncan: I've found that to get decent completion you need to bring in another package.  I use dante: https://github.com/jyp/dante
08:09:40 <turion> maerwald: Yampa has an upper case package name and it's really annoying because cabal is actually case sensitive :/ so I think I'll stick with lower case
08:10:12 <tdammers> yes, that tends to annoy me too... uppercase package names... ugh...
08:10:57 <turion> Once I sat for a long time figuring out why it wouldn't find the damn package
08:11:44 <tdammers> also, case sensitivity is something you can't possibly get right
08:11:48 <tdammers> both choices are wrong
08:12:05 * tdammers remembers being bitten by that once while using svn on windows
08:16:45 <duncan> devalot: Thanks - I'll have a look! 
08:28:04 <dminuoso>  Let's say I have some ⌜data Foo = Foo { f1 :: T1, f2 :: T2, f3 :: T3, ... } ⌝, and an instance Show for each field. Is there some sort of foldMap that would stuff each field into ⌜show⌝, and then feed my foldMap function?
08:28:57 <dminuoso> Or is Generics/TH the only way?
08:29:11 <dminuoso> Oh wait. This is basically MonoTraversable.
08:29:33 <dminuoso> (Or MonoFoldable)
08:29:46 <dminuoso> Oh yes. Brilliant. :)
08:30:46 <Zemyla> I find myself thinking about Distributive Traversables.
08:31:26 <Zemyla> Normally, a Traversal s t a b = s -> exists n. (Vec n a, Vec n b -> t).
08:32:08 <Zemyla> And any Traversing Profunctor must be both Strong and Choice.
08:33:08 <Zemyla> However, if you restrict yourself to Traversable instances that are Distributive as well, then it becomes DistTraversal s t a b = exists n. s -> (Vec n a, Vec n b -> t).
08:53:17 <maralorn> dminuoso: Okay, I get how Hask works without bottoms. Thanks. Although it‘s a bit unintuitive to me as in the lecture I attended, we looked at the category of Scott domains. They have bottoms.
09:02:12 <dminuoso> maralorn: Interesting. Well you should know that not any category is "the right one" - they are just exploration spaces for discovering propertie.s
09:02:57 <dminuoso> maralorn: Hask gives us, if we pretend the absence of seq and bottom a cartesian closed category. It being a subcategory of Set we get all the usual insights (like Yoneda lemma) for free too.
09:04:03 <dminuoso> maralorn: Im curious, what does that category of Scott domains look like?
09:07:37 <rosalux> I am setting up a website and found the package "Network.HaskellNet.SMTP.SSL" which works great and is super useful, but I saw a bunch of places where people said something to the effect of "Heads up this does use HaskellNet." Is there a problem with using HaskellNet or could it be insecure?
09:07:38 <turion> dminuoso: It basically contains bottom ;)
09:09:43 <turion> There is some topology defined on Scott domains which I don't recall
09:18:28 * hackage birch-beer 0.1.4.5 - Plot a colorful tree.  https://hackage.haskell.org/package/birch-beer-0.1.4.5 (GregorySchwartz)
09:25:05 <geekosaur> rosalux, on the one hand are people who want all-Haskell solutions or trust type safety more than C code that regularly has new flaws discovered in it; on the other are those who want to see a detailed security audit of HaskellNet first. so neither side is quite suitable for everyone
09:26:33 <hc> btw, is there any research as to haskell's type system preventing security bugs that other memory-safe languages such as java don't prevent?
09:27:21 <geekosaur> MSR did some work iirc
09:28:43 <hc> Microsoft Semigroup Research?
09:29:10 <hc> oh, MSR does mean Microsoft Research :)
09:29:24 <geekosaur> semigroupoids guy's at facebook iirc :p
09:39:01 <boxscape> Apparently one "disadvantage" with using haskell a lot is that you (or at least I) start to just assume functions in other languages are pure, when there's no such guarantee. I spent an hour or more debugging extremely simple code today because I expected RegExp.test(string) in Javascript to be pure...
09:39:23 <boxscape> maybe I'll be able to introduce purescript at my work at some point, who knows
09:39:35 <merijn> boxscape: And forgetting about deep vs shallow copying >.>
09:39:41 <boxscape> oh yeah, that too
09:39:53 <merijn> Spend ages debugging a recursive python function due to that...
09:42:37 <hyperisco> merijn, the curse of object identity
09:43:10 <dminuoso> Or importing a module that doesn't exist, giving you an undefined that will blow up callback handlers when you click on some button with no meaningful way to debug it, other than backwards print debugging through dozens of files.
09:43:23 <dminuoso> This is one of my favourite JavaScript debugging sessions.
09:43:49 <boxscape> oh boy
09:43:51 <boxscape> hours of fun
09:43:53 <infinisil> boxscape: Huh, how was RegExp.test impure? I can't think of anything reasonable
09:44:07 <dminuoso> (Or wait, rather importing things from a module that dont exist)
09:44:23 <merijn> dminuoso: Don't forget "import runs arbitrary code/logic"
09:44:29 <dminuoso> merijn: Oh that's wonderful too.
09:44:49 <dminuoso> Using shallow import statements to cause side effects is the "pattern" employed by some pretty popular libraries.
09:44:51 <boxscape> infinisil oh, I didn't say it was _reasonable_. Apparently when you match a string the regex remember the lastIndex position where it matched and that means if you match the same string again, it will have 0 matches. (But only for regexes with the g flag) 
09:45:29 <boxscape> (and if you match it again after that, it'll have the original matches)
09:45:52 <infinisil> Oh :/
09:46:05 <infinisil> Long live Haskell's purity
09:46:28 * dminuoso hides his side effects inside infinisil's poket using unsafePerformIO
09:46:33 <rosalux> geekosaur: thanks!
09:46:41 <Cale> boxscape: Personally, I found it makes me more acutely aware of the fact that everything might not be pure, which is almost paralysing.
09:46:47 * infinisil draws his special card, SafeHaskell!
09:47:09 * dminuoso plays GhcPlugin
09:47:27 <boxscape> yeah.. maybe I'll slowly move over to that attitude if I have more debugging sessions like this Cale
09:50:10 <dminuoso> boxscape: A while ago I spent the better part of a day debugging a sporadic failure that was caused by a race condition in getaddrinfo in macOS - which is apparently not reentrant, contrary to its documentation.
09:50:56 <boxscape> oh wow, I don't actually think I've ever had to debug something because the documentation was wrong
09:53:09 <ap5> I think you get this a lot, but does there exist a goto place on the web, that explains to me how to get properly started with haskell? I have installed all the tools, i can run stack etc, but i need a book/guide/some articles that takes me beyond the hello world example. I have looked at https://haskell.fpcomplete.com/learn, but the Tutorials sections ... I dont feel it is ... what do you 
09:53:09 <ap5> call it, connected? It is just a bunch of (well written) articles that explains some areas well. I need a place with a red line, if you understand?
09:54:26 <ap5> I have 15 years of experince into programming in various languages, lisp, C#, Java, C so I am also interested into the tooling as well as the language itself
09:54:36 <boj> ap5: if you are a haskell learner coming from another language, you likely won't find a tutorial to help bootstrap your mind. you probably want to look into a haskell book first
09:54:55 <ap5> Yes :) and what book should that be?
09:55:08 <boxscape> @where haskellbook
09:55:08 <lambdabot> http://haskellbook.com
09:55:11 <ap5> I have found the http://haskellbook.com/
09:55:18 <boj> that one is decent
09:55:27 <ap5> Ah ok. So this is actually a goto book. Didn't know that
09:55:31 <ap5> thanks so much
09:55:43 <boj> well, a goto book :)
09:55:56 <boxscape> that gives me a great idea
09:55:56 <boj> @where typeclassopedia
09:55:57 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
09:56:02 <boxscape> let's introduce goto statements in haskell
09:56:02 <merijn> ap5: I've also heard good things about "Programming in Haskell" by Graham Hutton
09:56:06 <boj> add that to your readking as well
09:56:10 <mycroftiv> ap5: im in the midst of the learning process myself and the thing i most recommend is playing with a lot of small toy examples
09:56:33 <merijn> boxscape: You're several years too late
09:56:38 <boxscape> oh, really?
09:56:42 <merijn> boxscape: https://www.reddit.com/r/haskell/comments/1jk06q/goto_in_haskell/
09:56:43 <ap5> mycroftiv: yes ofc, but i need a good starting ground
09:56:46 <boxscape> nice
09:57:15 <boxscape> oh hey I've spoken with the author even in a completely different context
09:57:22 <boxscape> (i.e. a non-haskell context)
09:57:28 <boj> ap5: on key point you may want to keep in mind given your 15 years of experience is that you will need to spend a bit of time *unlearning* some things :)
09:57:30 <mycroftiv> ap5: yes i agree with finding good books and guides too, i have 30000 tabs open in browser, i have just noticed that compared to other languages i have learned, i need to do way more tiny variations on things to get the feel
09:59:38 <sm[m]> ap5: try also:
09:59:38 <sm[m]> @where that
09:59:38 <lambdabot> I know nothing about that.
09:59:44 <sm[m]> @where HTAC
09:59:44 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
10:00:10 <mycroftiv> ive also learned its surprisingly easy to write really really bad haskell where you get lost in wrapping and unrwapping your types - and this is good, because it means you arent thinking clearly, so you make yourself think clearly and then the code semimagically clarifies
10:02:06 <sm[m]> ap5: also https://typeclasses.com/phrasebook
10:06:18 <sm[m]> @where+ THP https://typeclasses.com/phrasebook
10:06:19 <lambdabot> Okay.
10:17:30 <dmwit> ?where tutorials
10:17:30 <lambdabot> http://haskell.org/haskellwiki/Tutorials
10:18:01 <jumper149> From reading the Typeclassopedia I get the impression, that Applicate wasn't always a superclass of Monad
10:18:09 <jumper149> *Applicative
10:18:19 <dmwit> Correct.
10:18:22 <boj> yep, it was only within the last few years that happened
10:18:34 <jumper149> Why was there trouble with it?
10:18:47 <boj> no trouble, evolution
10:18:59 <jumper149> The concept of Applicative seems a lot more natural than Monad to me
10:19:14 <jumper149> since it is so similar to Functor I guess
10:20:08 <slack1256alt> All Monads are Applicatives on haskell (not on general CT), but when haskell started to use Monad, Applicative weren't defined nor were popular (I think they got popular with parsing combinators). The class constrains were a backward incompatible change so they were on hold for a good while.
10:20:08 <boj> jumper149: this may be of some interest, historically - https://wiki.haskell.org/Functor-Applicative-Monad_Proposal
10:21:53 <jumper149> slack1256alt: Do you mean class constraints in general or specifically the constraint Applicative for Monad
10:22:32 <slack1256alt> The Applicative constrain for Monad, ie `class Applicative m => Monad m where`.
10:23:14 <ironhaven> I have a simple problem i am trying to use groupBy but it just makes 2 groups
10:23:16 <ironhaven> https://pastebin.com/iheFQuxG
10:23:53 <sm[m]> Just a guess, ironhaven: you know you need to sort before grouping ?
10:24:22 <ironhaven> camleSplit "camelCaseVar" is ["camel", "CaseVar"] not ["camel","Case","Var"]
10:24:39 <slack1256alt> That's used for default definitions and says that you have an Applicative instance if you have a Monad instance by `pure = return` and `(<*>) = liftM`.
10:25:58 <ironhaven> so is groupby the wrong function for what i am trying to do?
10:26:41 <slack1256alt> > :t breakOn
10:26:44 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
10:26:49 <slack1256alt> @type breakOn
10:26:51 <lambdabot> error:
10:26:51 <lambdabot>     • Variable not in scope: breakOn
10:26:51 <lambdabot>     • Perhaps you meant one of these:
10:27:36 <boxscape> :t splitOn
10:27:38 <lambdabot> Eq a => [a] -> [a] -> [[a]]
10:28:15 <slack1256alt> @type break isUpper
10:28:16 <boxscape> though... splitOn doesn't seem like the right function here
10:28:18 <lambdabot> [Char] -> ([Char], [Char])
10:28:33 <slack1256alt> > break isUpper "camelCaseLol"
10:28:35 <lambdabot>  ("camel","CaseLol")
10:29:14 <slack1256alt> Meh, good enough. You could re-apply break on the second result until you get a "".
10:29:39 <ironhaven> i was worried i would have to do that
10:30:21 <ironhaven> another issue is i also have to split "CamelCase"
10:30:37 <ironhaven> and that would just return the whole string
10:31:46 <slack1256alt> I mean, you could also write your own by hand
10:31:53 <ironhaven> i am thinging of finding all of the indexes of breakpoints and splitting with that list
10:31:53 <sm[m]> ironhaven: I wasn't sure why your example did that, this shows why: T.groupBy (\x y -> trace (show (x,y)) $ not $ isLower x && isUpper y) $ T.pack $ "camelCaseVar"
10:32:17 <boxscape> the split package has splitWhen :: (a -> Bool) -> [a] -> [[a]]  which I think would be appropriate
10:32:34 <slack1256alt> ^ this
10:32:43 <ironhaven> cool!
10:33:24 <slack1256alt> > splitWhen isUpper "CamelCaseLol"
10:33:29 <lambdabot>  ["","amel","ase","ol"]
10:33:45 <boxscape> uh hm
10:34:27 <boxscape> >  split . whenElt isUpper $ "CamelCaseLol"
10:34:32 <lambdabot>  error:
10:34:32 <lambdabot>      • Couldn't match expected type ‘[Char] -> Splitter a’
10:34:32 <lambdabot>                    with actual type ‘Splitter Char’
10:34:54 <boxscape> >  split $ whenElt isUpper $ "CamelCaseLol"
10:34:57 <lambdabot>  error:
10:34:57 <lambdabot>      • Couldn't match expected type ‘[Char] -> Splitter a’
10:34:57 <lambdabot>                    with actual type ‘Splitter Char’
10:35:00 <boxscape> egh
10:35:10 <boxscape> I don't actually know how to use this library
10:36:22 <ironhaven> i will try to work with what is here
10:36:54 <boxscape> >  split (keepDelimsL (whenElt isUpper)) "CamelCaseLol"
10:36:55 <boxscape> there you go
10:36:57 <lambdabot>  ["","Camel","Case","Lol"]
10:37:04 <ironhaven> btw this is a exercism.io if anybody was wondering
10:37:42 <slack1256alt> ;_;
10:37:42 <ironhaven> well the reason i have "not $ isLower x && isUpper y"
10:38:04 <ironhaven> is because camelSplit "PNG" -> ["PNG"]
10:38:14 <ironhaven> is what i want
10:38:24 <ironhaven> well i will look at this split library
10:38:46 <ironhaven> thanks
10:40:26 <sm[m]> I don’t think you can do it with the split lib; it only looks at one element at a time
10:41:46 <sm[m]> Until we hear otherwise, it’s probably best to write your own custom recursive split function
10:45:42 <dmwit> > map concat . groupBy (\x y -> case (x, y) of ([_],[_]) -> True; _ -> False) . splitWhen isUpper $ "CamelCaseLOL"
10:45:46 <lambdabot>  ["","amel","ase","","",""]
10:46:09 <dmwit> > map concat . groupBy (\x y -> case (x, y) of ([_],[_]) -> True; _ -> False) . split (keepDelimsL (whenElt isUpper)) $ "CamelCaseLOL"
10:46:12 <lambdabot>  ["","Camel","Case","LOL"]
10:47:08 <boxscape> you can't use LambdaCase with more than one parameter, can you? :(
10:47:14 <dmwit> no =(
10:47:24 <boxscape> I guess you could wrap it in curry or uncurry or something
10:47:27 <dmwit> I really wish there were two variants.
10:48:02 <sm[m]> dmwit what are you doing.. my eyes..
10:48:16 <sm[m]> exercism probably won’t allow split anyway
10:48:52 <dmwit> sm[m]: Just a quick post-processing of the solution already posted: after splitting, jam together any adjacent elements that are length-1.
10:49:30 <sm[m]> Aha. I had a seriously hard time reading that :)
10:50:08 <boxscape> that map concat looks like there should be some canonical single function that combines them, but I suppose concatMap does something else...
10:55:12 <sm[m]> Annoying little puzzle!
10:55:28 <boxscape> > map concat . groupBy (curry (\case ([_], [_]) -> True; _ -> False)) $ (split . keepDelimsL . whenElt) isUpper "CamelCaseLOL"
10:55:32 <lambdabot>  ["","Camel","Case","LOL"]
10:57:48 <boxscape> hm I wonder if it would be possible to exploit typeclasses somehow to make a single curry function that works no matter how many parameters a function has
10:58:42 <boxscape> didn't even realize until now that base doesn't even have curry3
11:01:27 <sm[m]> look away now ironhaven from this massive spoiler..
11:01:36 <sm[m]> > map (map head) $ groupBy (\a b -> not $ isLower (last a) && isUpper (head b)) $ map (take 2) $ init $ tails "CamelCaseLOL"
11:01:39 <lambdabot>  ["Camel","Case","LOL"]
11:01:56 <sm[m]> lol
11:05:29 * hackage to 1.0.0 - Simple, safe, boring type conversions  https://hackage.haskell.org/package/to-1.0.0 (Artyom)
11:06:49 <sm[m]> fails on "LOL"! Back to GHCI!
11:07:39 <sm[m]> oh no it doesn't, I mistyped. Total success!
11:08:47 <boxscape> nice
11:10:24 <wroathe> Shake is neat
11:10:45 <wroathe> I wonder if the creators/maintainers of Make have read the papers on it
11:10:54 <boj> > groupBy (\a b -> and [isUpper a, isLower b]) "CamelCaseLOL"
11:10:56 <lambdabot>  ["Camel","Case","L","O","L"]
11:11:37 <boxscape> any particular reason for `and [x, y]` instead of just `x && y`?
11:11:59 <boj> i like to use composable functions
11:12:04 <boxscape> okay
11:12:25 <boxscape> @pl \a b -> and [isUpper a, isLower b] -- just out of curiousity
11:12:25 <lambdabot> (and .) . (. (return . isLower)) . (:) . isUpper
11:12:49 <Cale> @pl \a b -> isUpper a && isLower b
11:12:50 <lambdabot> (. isLower) . (&&) . isUpper
11:13:00 <boxscape> that's.. almost readable
11:13:25 <Cale> almost
11:13:28 <Cale> haha
11:13:52 <boxscape> kind of annoying that it flips isLower and isUpper
11:14:37 <glguy> boj: group doesn't promise which two elements its going to compare when adding things to the group
11:17:24 <sm[m]> glguy: doesn’t it scan through the list, comparing the pair starting at each element ?
11:17:29 <Ariakenom> readable could mean "I can understand what the author meant" but a lot better is "I can understand what the author said"
11:17:34 <boxscape> presumably it assumes reflexivity, symmetry and transitivity 
11:17:41 <boxscape> of the equality function
11:18:09 <glguy> sm[m]: It assumes you gave it an equality function. It doesn't promise that it's comparing neighbors or all elements to the first in the group or some other scheme
11:18:09 <boxscape> that might be what it *does*, sm[m], but not necessarily what it *promises* to do
11:18:15 <Cale> boxscape: It's natural for it to do that, it's preserving the order in which the arguments are provided to (&&)
11:19:26 <sm[m]> Hm. In that case I don’t know how you could use it.
11:21:05 <boxscape> @pl \a b -> isLower b && isUpper a
11:21:05 <lambdabot> flip ((&&) . isLower) . isUpper
11:21:45 <Cale> Oh, on the discussion about group, I honestly believe that it was a mistake for the Haskell Report not to simply leave out that comment about its behaviour being unspecified for non-equivalence-relations
11:22:15 <boxscape> what difference would that make? Seems like if you don't mention that it's unspecified, it's still unspecified
11:22:27 <Cale> It is specified, there's an implementation.
11:22:30 <boxscape> ah
11:22:51 <Cale> ... and that implementation is useful even without an equivalence relation
11:22:58 <boxscape> yeah that's true
11:23:29 <Cale> It forms groups by picking the first element from those which remain, and then comparing *that* element against successive elements of the list until it finds one for which the relation fails.
11:23:33 <sm[m]> I ”know” group and groupBy work for me if (and only if) I sort first. If it ever compared pairs in some other scheme, I wouldn’t know what to do..
11:23:39 <Cale> (at which point, it starts a new group)
11:24:07 <glguy> Yeah, it could be good to write down that as the documentation for what it's intended to do
11:24:08 <sm[m]> Interesting!
11:25:24 <boj> glguy: i guess i don't understand, did i misuse it somehow?
11:25:27 <glguy> especially if it was: groupByLike :: (a -> a -> Bool) -> [a] -> [(a,[a])] -- emphasizing the distinguished group elements and capturing that the list isn't empty
11:25:59 <glguy> boj: Your function isn't a valid equality function
11:26:14 <Cale> Yeah, that's a more exact type for what it produces
11:27:01 <boxscape> I was wondering earlier if there was a nicer way to do "map head . group" - with that type it would at least get rid of the partial function
11:27:28 <Cale> Yeah, it's always safe to use map head . group, but it might not look safe if you're unfamiliar with the idiom
11:27:58 <hyperisco> There is the NonEmpty variant of group you can use
11:28:02 <Cale> (and if someone changes the code later so that there's another operation in between)
11:28:45 <boj> glguy: huh, i get it. yet i abused it, which is a problem, yeah?
11:29:01 <Cale> boj: It's a more theoretical problem than a practical one
11:29:10 <boj> gotcha
11:29:58 <boxscape> I'm guessing if they changed the implementation at this point they'd be breaking a lot of code
11:30:36 <glguy> implementations of things like this have changed, sometimes to make things consistent across the regular and -By variant
11:30:37 <Cale> Yeah, and they have, and people (myself included) complained, and it got fixed :D
11:30:44 <glguy> it's not a theoretical concern
11:30:54 <glguy> and it makes your code less readable to rely on undocumented behaviors
11:31:26 <Cale> So little of base is "documented" by the Report that it's almost a moot point what it says about base by now
11:31:30 <boxscape> is the regular variant not typically just xxxBy (==)?
11:32:01 <boxscape> (i mean, implemented as, not just semantically)
11:32:48 <dmwit> > map concat . groupBy (\x y -> case (x, y) of ([_],[_]) -> True; _ -> False) . split (keepDelimsL (whenElt isUpper)) $ "CamelCaseLOLerskates"
11:32:49 <Cale> > groupBy (<) [1,2,3,2,2,1,2,3,4] -- this behaviour is super-useful for splitting a document into a tree by section heading depth (imagine that the numbers are the lengths of "1.12.4" style section numbers)
11:32:50 <lambdabot>  ["","Camel","Case","LO","Lerskates"]
11:32:51 <lambdabot>  [[1,2,3,2,2],[1,2,3,4]]
11:33:17 <dmwit> > map (map head) $ groupBy (\a b -> not $ isLower (last a) && isUpper (head b)) $ map (take 2) $ init $ tails "CamelCaseLOLerskates"
11:33:19 <lambdabot>  ["Camel","Case","LOLerskates"]
11:33:34 <dmwit> boxscape: ^ unclear which of these is right from the spec so far
11:33:44 <dmwit> err
11:33:47 <dmwit> sm[m]: ^
11:34:00 <boxscape> For how I personally write variable names the first one would be it but yeah
11:34:05 <glguy> Cale: I find that example more clever/cute than clean or obvious
11:34:10 <dmwit> boxscape: same
11:34:51 <Cale> glguy: I guess it does rely on a more precise understanding of groupBy than most people have
11:35:26 <boxscape> so you'd recursively apply that the the result to get the actual tree Cale?
11:35:58 <Cale> yeah
11:36:00 <boxscape> okay
11:36:26 <cpucpucpu> as i understand it at&t uses haskell for (text?) spam filtering. does anyone have a contact with that group? i am having trouble with a specific type of text which is quite obnoxious, it has been going on for weeks, and i have found forum posts with other people complaining of this same phenomenon
11:37:40 <Cale> cpucpucpu: I was unaware of that, but Facebook does the same.
11:38:29 <cpucpucpu> cale: yeah i am aware of facebook (incidentally, i get zero spam on fb)
11:41:05 <merijn> <3 whoever thought to define "instance Semigroup Void"
11:43:14 <Boarders> is there any library for doing continuation passing style folds or would one normally just do that by hand with recursion?
11:43:23 <Boarders> or do you use Cont and foldM?
11:43:32 <Boarders> I couldn't seem to find much information online about it
11:43:53 <Cale> all of the above?
11:44:22 <Boarders> I see
11:44:28 <Cale> > foldr (\x xs s -> s : xs (s + x)) (\s -> [s]) [1,2,3,4,5,6,7] 0 -- foldr can take as many arguments as you like
11:44:33 <lambdabot>  [0,1,3,6,10,15,21,28]
11:44:55 <Cale> (there I used it to implement scanl)
11:45:35 <Cale> Well, that's not what foldM would do in Cont though of course
11:47:18 <Cale> :t (\f z -> runCont . foldM f z . map cont)
11:47:20 <lambdabot> (a1 -> Cont r1 a2 -> ContT r2 Identity a1) -> a1 -> [(a2 -> r1) -> r1] -> (a1 -> r2) -> r2
11:47:34 <Cale> hm, kind of weird
11:48:42 <Cale> I don't know about that, but I have used this one:
11:48:43 <Boarders> is there a good resource to better under your first example?
11:48:53 <Cale> :t runCont . sequence . map cont
11:48:57 <lambdabot> [(a -> r) -> r] -> ([a] -> r) -> r
11:49:04 <dmwit> Boarders: There is https://hackage.haskell.org/package/folds which may interest you.
11:49:27 <Cale> (useful if you have a bunch of withFoo-style functions and want to acquire a bunch of resources at once)
11:49:55 <Boarders> dmwit: thank you
11:49:56 <Cale> Boarders: Well, we're constructing a function there, and it's going to be applied to the initial "state"
11:50:17 <Cale> (or "environment" if you prefer to think of this as being like Reader with a bunch of nested locals)
11:51:22 <Cale> and so we have that additional s parameter, which we "update" in the function we're passing as the first argument to foldr, by simply passing along a new value to "xs" (which is actually a function)
11:52:53 <Cale> xs is the function which represents the processing of the remainder of the list, and we just pass along an altered value to it
11:53:17 <Cale> Does that make sense?
11:53:44 <Boarders> I think so yes
11:53:51 <Boarders> I'm just messing in ghci to better understand it
11:55:12 <Cale> The (\s -> [s]) is how the empty list at the end is handled -- in this case, we finish up by producing a singleton with our final state (which will be the sum of all the elements of the input list)
11:57:07 <Cale> If you were under the notion that foldr starts processing a list at the right, it's best to stop thinking like that -- it's impossible to start processing a list at the right. The 'r' only stands for how the resulting expressions are associated as a right-leaning tree.
11:57:44 <EvanR> the is funny because i always thought it "starts" at the "left"
11:58:08 <Boarders> I was under the recursion schemes lite notion that the accumulator is what the computation gives back from the tail of the list etc
11:59:07 <Cale> Which is true, but it's important to note that it doesn't necessarily compute the result for the tail "first"
11:59:30 <Cale> > foldr (\x xs s -> s : xs (s + x)) (\s -> [s]) [1..] 0 -- otherwise, this would never work
11:59:34 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
11:59:52 <Boarders> yes! the fold is guard recursive
12:00:04 <Boarders> do you know of any resources with more examples like this?
12:02:00 <Cale> I think one of the first times I saw it was in https://www.willamette.edu/~fruehr/haskell/evolution.html
12:02:13 <Cale> But that's not really what you're asking for
12:07:57 * hackage classify-frog 0.2.4.3 - Classify sounds produced by Xenopus laevis  https://hackage.haskell.org/package/classify-frog-0.2.4.3 (HenningThielemann)
12:17:03 <dramforever> Another example of a 'funny foldr' so to speak is the implementation of foldl with foldr
12:17:49 <EvanR> how about implementation of foldr with foldl
12:18:29 <dramforever> foldl doesn't handle infinite lists but foldr can
12:18:58 <EvanR> right so i suspect it's impossible but i also wouldn't be surprised if some bozo does it anyway
12:25:57 <portnov> hi all.
12:26:12 <boxscape> well, *technically*, this is an implementation of foldl that uses foldr
12:26:13 <boxscape> > let myfoldl f a l = foldr const (let x = x in x) [foldl f a l] in myfoldl (flip (:)) [] [1..5]
12:26:15 <lambdabot>  [5,4,3,2,1]
12:26:57 <boxscape> wait
12:27:00 <boxscape> the goal was the opposite
12:27:01 <boxscape> oops
12:27:09 <portnov> https://github.com/portnov/hpview
12:28:12 * shapr hops cheerfully
12:37:47 <portnov> (one who is interested in profiling may be also interested in https://github.com/portnov/ghcprofview-hs)
12:37:49 <portnov> ;)
12:41:21 <day> is there really no XSD xml validation support in haskell?
12:41:49 <day> i cant find a single xml lib that offers this :|
12:44:14 <portnov> uh
12:44:29 <portnov> there should be libxml2 bindings somewhere
12:44:40 <portnov> or you can write your own if there is no still
12:44:44 <day> kek
12:44:50 <portnov> not very haskellish way, but should work
12:44:51 <day> im happy if i can use the library
12:45:01 <day> manage to use*
13:07:58 <sm[m]> portnov: thank you very much for these tools, I will be trying them out
13:10:33 <sm[m]> I liked how profiterole simplifies the call stack
13:13:13 <boxscape> https://hackage.haskell.org/package/libxml are libxml2 bindings
13:14:57 * hackage th-lift-instances 0.1.14 - Lift instances for template-haskell for common data types.  https://hackage.haskell.org/package/th-lift-instances-0.1.14 (BennoFuenfstueck)
13:35:57 * hackage hedgehog-classes 0.2.3 - Hedgehog will eat your typeclass bugs  https://hackage.haskell.org/package/hedgehog-classes-0.2.3 (chessai)
13:43:06 <inkbottle> "GHC uses the haskell-src-exts library to parse Haskell code (https://github.com/antlr/grammars-v4/issues/210)" Is that a fact? Or is GHC using a parser of its own.
13:44:01 <inkbottle> Because I read somewhere that GHC was *not* using haskell-src-exts library.
13:45:03 <dminuoso> inkbottle: Perhaps they were referring to https://gitlab.haskell.org/ghc/ghc/wikis/implementing-trees-that-grow
13:46:14 <dminuoso> inkbottle: GHC certainly comes with its own parser.
13:46:37 <dminuoso> inkbottle: https://gitlab.haskell.org/ghc/ghc/tree/master/compiler/parser
13:57:50 <travis_> can somone point me to a gentle tutorial on making sense of ghc error messages?
14:00:27 <inkbottle> dminuoso: Thanks
14:06:58 * hackage nonempty-lift 0.1 - nonempty structure  https://hackage.haskell.org/package/nonempty-lift-0.1 (chessai)
14:08:05 <dminuoso> travis_: http://ics.p.lodz.pl/~stolarek/_media/pl:research:stolarek_understanding_basic_haskell_error_messages.pdf this is something google provided quickly
14:08:40 <dminuoso> travis_: Aside from that, understanding how type unification works can go a long way of understanding what GHC is doing.
14:08:54 <travis_> dminuso: thx.  it's more of "what's worked for you kind of question"
14:09:33 <dminuoso> travis_: I focused on understanding why GHC provoked those error messages from its perspective, rather than understanding what was wrong in my code.
14:09:42 <dminuoso> It was harsh but it mostly worked.
14:10:56 <travis_> dminuoso: much appreciated! 
14:11:50 <dminuoso> travis_: Also searching on stackoverflow for diagnostic messages, and then looking for answers that explain why GHC complains (rather than the problem in the source code). There's usually 1-2 in many threads.
14:12:22 <dminuoso> I suppose any common diagnostic has dozens of stackoverflow questions with many solid answers in between.
14:14:56 <travis_> dminuoso: re: stackoverflow sometimes I need to hear my  own advice from someone else  
14:15:30 <dminuoso> travis_: Im not asking you to post a question, but usually someone has asked "What does ambiguous type variable" before, and you'd usually find an indepth explanation of what GHC is doing.
14:16:21 <dminuoso> Of course if all resources have been exhausted, asking here/mailing list/SO/reddit is fine.
14:22:48 <cohn> hi, I'm a bit new to Haskell. I'm trying to make something an instance of Monoid and I'm getting an odd error
14:22:59 <cohn> is there anything I need to import in order to do so?
14:23:19 <cohn> using GHCi version 8.6.5
14:23:24 <glguy> cohn: If you have questions about error messages you should share the error message. If the message is longer than a line or two you can use a pastebin
14:25:43 <cohn> glguy: http://paste.boxonthe.net/paste/hAUor0F9#1oawvQZ79zBoRnv9D9J7VStMoRU1JuDEFEArq+qlFiX
14:25:45 <dmwit> To answer the direct question: no, there is nothing you need to import to be able to create a Monoid instance.
14:26:05 <cohn> dmwit: thanks
14:26:05 <dmwit> You will need to write a Semigroup instance for your DiffLists.
14:26:18 <cohn> dmwit: not sure what that is
14:26:53 <int-e> . o O ( instance Semigroup (DiffList a) where (<>) = mappend )
14:27:07 <dmwit> cohn: Semigroup is like Monoid, but without mempty.
14:27:15 <cohn> dmwit: ah, okay
14:28:14 <glguy> The default implementation for mappend is Semigroup's (<>)
14:28:20 <dminuoso> cohn: There is currently an ongoing progress to change the typeclass hierarchy a bit. It used to be that Monoid had no superclass, we are adding Semigroup as a superclass at the moment.
14:29:18 <cohn> dminuoso: okay. I'm working through the "Learn you a Haskell..." book and there's no mention of that. Must be something relatively new?
14:29:30 <dminuoso> cohn: Somewhat, LYAH is rather old... :)
14:29:44 <cohn> 2011... 
14:30:05 <cohn> I wish the author would release a 2nd edition
14:30:11 <dminuoso> cohn: 8 years is a long time. Anyway, there are 4 phases to the proposal, the first was implemented in 8.2, the second phase was implemented in 8.4.
14:30:12 <int-e> dminuoso: The grammar is still as painful as it was back then.
14:31:05 <cohn> are Monoids the only typeclass requiring a Semigroup instance?
14:31:23 <dminuoso> cohn: There could be others.
14:31:53 <cohn> dminuoso: heh, I'll have to keep an eye out as I write more code
14:31:58 <cohn> :D
14:32:52 <cohn> looks like quite a few typeclasses:  https://hackage.haskell.org/package/semigroups-0.18.1/docs/Data-Semigroup.html
14:33:12 <Tuplanolla> You could reasonably see `Semilattice` in the wild, cohn.
14:33:40 <Tuplanolla> It's a subclass of `Semigroup` that's distinct from `Monoid`.
14:33:40 <geekosaur> many things that had required Monoid would have been changed to require Semigroup if they were only interested in mappend originally (that is, hadn't cared about an identity)
14:34:17 <dminuoso> Though it would be rude to only define a Semigroup instance and not also a Monoid instance, should one exist.
14:35:22 <geekosaur> orphan instances thing means only the Semigroup ones would be in Data.Semigroup
14:36:00 <dminuoso> cohn: Generally, before writing an instance for a typeclass, its useful to consult its haddoc documentation (generally you can find packages on hackage/stackage, searching for them is easy with hoogle). That would tell you about superclasses, what methods you need to implement - and also what laws are expected to hold.
14:36:40 <dmwit> cohn: Anybody can just sit down and write a new class that subclasses Semigroup. So even if the answer to "are Monoids the only typeclass requiring a Semigroup instance?" is "no" right now, it's not possible to rely on that being true going forward. Better to just assume the answer is "yes".
14:37:37 <dminuoso> cohn: https://hoogle.haskell.org/?hoogle=Monoid for example quickly shows you everything you need to know about Monoid, if you click on the first result. :)
14:50:19 <cohn> dminuoso: perfect, thank you!  : )
14:54:23 <fragamus> Howdy I have a big question. First some basics. We all generally agree that concision is desirable in our code.
14:55:29 <fragamus> We have many techniques such as higher order functions to achieve this in functional programming.
14:56:02 <fragamus> One technique we try to stay away from is meta-programming.
14:56:49 <fragamus> Still, we use that when it leads to more concise expression of our ideas.
14:56:49 <wroathe> fragamus: I don't agree. I prefer writing assembly and not using jumps of any kind.
14:57:01 <wroathe> Just one straight sequence of assembly instructions
14:57:08 <fragamus> Right
14:58:24 <fragamus> My question is: is there a simple example of a situation where meta-programming is the best approach to concision?
15:00:39 <fragamus> Does the use of meta-programming indicate failure on the part of the language or of the coders using it?
15:01:59 <MarcelineVQ> what is meta-programming here?
15:02:31 <fragamus> Macros and the like
15:02:49 <rubik> you mean real macros like in lisp i hope
15:02:55 <fragamus> Yes
15:04:06 <fragamus> I’m trying to convince myself one way or the other that lisp macros or something like them is essential to concision.
15:04:13 <nullnullnull> is there any alternative package (other than Network) to check for open tcp connections? 
15:04:24 <rubik> don't have the experience yet to say if TemplateHaskell is as mighty as Lisp macros
15:04:49 <rubik> nullnullnull: do you miss a feature?
15:05:42 <nullnullnull> rubik, yeah I miss the old version of haskell, it comes pre-installed (with network)
15:06:10 <nullnullnull> but I dont wanna install any external package cuz im using a bash script to execute some scripts with haskell
15:06:16 <nullnullnull> if the package is not exist: the script will fail
15:06:39 <nullnullnull> trying to write only native code
15:06:40 <rubik> i think now it is System.Network (?)
15:06:52 <nullnullnull> hmm
15:07:05 <nullnullnull> sec let me check
15:08:24 <fragamus> For example, with macros and the like it is possible to write memoization code which can be automatically applied to any pure function
15:09:29 <fragamus> Is this the existence proof? Are there better ways to do this?
15:14:54 <jle`> fragamus: i don't necessarily think that concise code is always better, but it can be useful as a means to an ends
15:15:07 <jle`> but sometimes concise code betrays the things that we actually desire
15:15:25 <jle`> so it's sort of like if "turning left" is desirable.  sometimes it is, sometimes it doesn't; it depends on how it serves our destination
15:15:56 <jle`> the goal of higher order functions isn't to make code more concise; the conciseness is a coincidental side effect (heh)
15:17:25 <fragamus> Well concision simultaneously makes code easier to understand for those familiar with the symbols and harder for those who don’t
15:17:47 <jle`> in some cases
15:17:50 <MarcelineVQ> that's terseness, concision carries a burden of being understandable
15:19:03 <fragamus> Yeah but can you take a swing at the main question
15:19:06 <MarcelineVQ> But to ignore the word-game because it runs deep, ti's also just how minds work, you need to know things to know more things
15:19:23 <jle`> i think maybe a better question would be a situation where meta-programming is the best approach to readable, understandable, refactorable, correct code
15:19:42 <MarcelineVQ> I can't I don't know what meta-progamming means because it's macros here and I don't know what they are
15:19:42 <jle`> you are using conciseness as an unreliable proxy for those qualities, which it may or may not always serve
15:19:56 <nullnullnull> rubik, hmm it's working now, strange, the Network.Socket comes pre-installed with haskell and that's what I wanted to use
15:20:29 <rubik> nice
15:20:53 <MarcelineVQ> if meta-programming is about staging then I don't consider it a language or programmer failure to need or use it, staging is just like how minds work above
15:21:16 <glguy> Generating lenses with TH via makeLenses is an example of meta-programming that I think is the right solution to the problem it solves
15:21:18 <nullnullnull> rubik, some weeks ago I remember it was not exist there, dunno
15:21:34 <nullnullnull> rubik, like: need to be installed as external package
15:21:45 <jle`> a lot of the advancements in GHC over the past decades has been in the service of eliminating explicit meta-programming in haskell and replacing it with things you can do within the language
15:21:53 <jle`> Data.Data and Data.Generic, for instance
15:22:56 <rubik> phew
15:23:01 <fragamus> So meta-programming is the trail blazer for language features
15:23:50 <glguy> I agree that Data.Data and Data.Generic try to hide the metaprogramming (some meta-programming happens once and then these things try to provide an in-laguage interface to that metaprogramming, but this isn't an obvious improvement on the situation
15:23:55 <glguy> GHC.Generic*
15:24:12 <wroathe> fragamus: Run every haskell program you write through pointfree before checking your work into git, wait a week, then return to what you were working on
15:24:31 <glguy> By moving the task into the language we lose the benefits of staging and the implementation gets contorted to fit within the new abstraction
15:24:34 <wroathe> For example of when conciseness would be undesirable 
15:24:57 <dminuoso> wroathe: This would be a fun extension to stylish-haskell.
15:25:28 <MarcelineVQ> wroathe: concise has an actual meaning :X
15:25:33 <jle`> this is perhaps a cultural thing in Haskell; we treat TH often as a necessary evil until we invent something that can replace specific usages of it
15:25:53 <jle`> because it can break expectations with result to compilation, staging, referring to names within a module...
15:26:00 <wroathe> MarcelineVQ: Huh?
15:26:15 <wroathe> It is a word, and words do have meanings
15:26:17 <glguy> jle`: Then we get a whole new field of research around making the replacing thing efficient and general
15:26:19 <jle`> but in languages without those sorts of expectations (like lisp), metaprogramming doesn't really break those expectations
15:26:51 <jle`> yeah, often times most of the TH-replacing things we have in haskell are much less efficient than the TH versions
15:27:12 <MarcelineVQ> wroathe: pointfree is terse but I'm not sure it's concise, if it was concise then you could come back to it in a week and do alright
15:27:58 <wroathe> MarcelineVQ: Potato potato lasagna
15:28:00 <jle`> also one issue in Haskell in specific is that haskell's syntax and AST at this point is extremely complex ... 
15:28:14 <jle`> so metaprogramming has to deal with that complexity
15:28:27 <jle`> we aren't in lisp where all syntax structures have a uniform nicety
15:28:28 <MarcelineVQ> "words have meanings, just not right now" ?
15:28:42 <wroathe> https://www.merriam-webster.com/dictionary/concise
15:28:47 <wroathe> mw agrees with me
15:31:48 <infinisil> Earlier I wanted to ask how to pass multiple -rts-opts in a cabal file
15:31:58 <infinisil> But I figured it out when I looked up online
15:32:11 <infinisil> The answer is to use "-rts-opts=-foo -bar"
15:32:41 <infinisil> I mean like this: `ghc-opts: -rtsopts "-with-rtsopts=-foo -bar"`
15:32:54 <fragamus> Ok can anyone say that Haskell will someday allow us to write code like the aforementioned memoization macro? If not then I will declare that as my existence proof.
15:34:18 <jle`> i mean, it's possible to write a memoization higher order function within haskell
15:34:27 <jle`> as a pure function without metaprogramming
15:34:50 <fragamus> Ok cool
15:35:14 <maralorn> I use putStrLn in a context where sometimes subprocesses also write to stdout. The stuff I am writing sometimes only appears minutes after the call to putStrLn. I remember problems like this from python when stdout did not get flushed correctly. Any hints on how to work around this?
15:35:20 <jle`> memoize :: (a -> a) -> (a -> a)
15:35:26 <jle`> er, memorize :: (a -> b) -> (a -> b)
15:35:31 <jle`> take an (a -> b) and return a memoized (a -> b)
15:36:00 <jle`> you *could* then wrap momoize in a macro if you wanted...but it would not be necessary
15:36:21 <jle`> maralorn: putStrLn should force a flush because of the newline, but you can always also manually flush
15:37:08 <fragamus> jle`: can that work for abitrary number of arguments and arbitrary types of arguments and return types
15:37:39 <maralorn> jle`: How do I flush manually? I thougt so two but it seems like it doesn‘t happn.
15:38:00 <jle`> fragamus: not in the form i have, but yeah, it can be overloaded to do so
15:38:04 <jle`> *form i gave
15:38:11 <jle`> fragamus: of course, not all input types make sense to be memoized
15:38:30 <jle`> maralorn: there should be some functions in System.IO i think
15:38:41 <fragamus> Nice then it looks like meta-programming is on the ropes
15:38:58 <jle`> i wouldn't necessarily think of it as a competition in the general sense
15:40:43 <fragamus> Meta-programming sucks because it’s difficult to reason about
15:41:44 <jle`> i don't think that's true in general?  in haskell it does break some common expectations with compilation, but i don't think it's necessarily more difficult to reason about than other similar tools that do similar jobs
15:41:44 <fragamus> But I still can’t conclude that we don’t really need it
15:42:36 <fragamus> Well it easily breaks out of our equational reasoning
15:42:43 <jle`> in languages like lisp that are designed from the ground-up with metaprogramming, it is a powerful tool for reasoning
15:42:51 <jle`> fragamus: how so?
15:42:56 <MarcelineVQ> maralorn: you'd use https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#v:NoBuffering on stdout you can also set LineBuffering or NoBuffering with hSetBuffering to get the desired output behavior. I think it's something like hSetBuffering stdout NoBuffering
15:43:11 <MarcelineVQ> oops that link was supposed to go to https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#v:hFlush
15:44:17 <fragamus> How so: one can write macros which run arbitrary code to generate code. Arbitrary code is subject to the halting problem.
15:44:36 <jle`> what does that have to do with equational reasoning?
15:45:33 <jle`> arbitrary functions also cannot be statically analyzed in a general way in a sense that bypasses the halting problem
15:45:38 <fragamus> If such a macro was part of our source code then we can’t reason about it because we can’t know what it will produce as output
15:46:22 <jle`> isn't normal non-macro code also susceptible to that?
15:47:02 <fragamus> The output of our macro becomes part of our program
15:47:31 <jle`> and our non-macro code is also part of our program
15:47:53 <fragamus> The macro represents a computation the output of which we can’t predict but our proof needs to reason about
15:47:56 <jle`> both are parts of our program that can resist static analysis
15:53:57 <fragamus> We can’t even prove that a meta-program will compile
15:55:15 <freeman42x> anyone know how to use setImportsQ to import the current file/module? setImportsQ from hint
16:01:17 <infinisil> So I ran my program with +RTS -s, and it says "Productivity  95.4% of total user, 74.4% of total elapsed"
16:01:38 <infinisil> This is a multi-threaded program
16:02:01 <infinisil> I'm also noticing that out of the 8 available cores, only about 6 are used at a time (even though 8 threads are running)
16:02:29 <infinisil> And this seems to correspond with the 74.4% productivity "of total elapsed"
16:03:08 <infinisil> I turned off parallel GC with -qg
16:03:32 <infinisil> Is this ~6/8 cores related to the productivity?
16:03:57 <infinisil> Does this mean my program is allocating too much?
16:05:45 <infinisil> I should probably show the full -s output, hold on..
16:07:19 <infinisil> Well my internet connection is really flakey right now, but "430,131,754,040 bytes allocated in the heap" sure does sound like a lot..
16:07:53 <wroathe> The GHC source is a fascinating beast
16:08:51 <nullnullnull> exitImmediately(ExitFailure 1);
16:09:00 <nullnullnull> error: parse error on input ‘exitImmediately’
16:11:23 <wroathe> missing a space
16:11:50 <wroathe> exitImmediately (ExitFailure 1)
16:12:00 <nullnullnull> hmm
16:12:39 <wroathe> Function application in haskell uses spaces, instead of the parens and commas thing you see in other languages
16:12:47 <nullnullnull> no, I think im missing an import , I tried  import System.Posix(exitImmediately) but not working
16:13:10 <nullnullnull> I added space
16:13:12 <wroathe> post your code in a gist
16:13:19 <nullnullnull> ok sec
16:13:38 <jle`> sin(1+2) and sin (1+2) should both work
16:13:56 <jle`> most likely the parse error is caused by something before exitImmediately
16:14:29 <nullnullnull> https://pastebin.com/S1siFHeF
16:14:40 <nullnullnull> I included all the imports 
16:14:56 <dminuoso> nullnullnull: So if "foo" is missing (perhaps not imported), you'd get "Variable not in scope: foo"
16:15:12 <nullnullnull> oh
16:15:21 <jle`> the parse error is because 'exitImmediately' is not indented enough
16:15:23 <dminuoso> (Which is quite explicit about what the error is)
16:15:31 <jle`> the first line after the 'do' determines the indentation of the entire do block
16:15:31 <nullnullnull> oh the spaces
16:15:47 <jle`> in this case it's the 'threadDelay 2000000'
16:15:47 <dminuoso> nullnullnull: So frequently, with GHC, taking a moment and really reading the error can do wonders to your problem solving abilities. :)
16:15:48 <nullnullnull> I put only 1 space there
16:15:53 <jle`> all of the other lines in the block have to be lined up with the 't'
16:16:04 <winny> do with something to the right feels strange, no?
16:16:05 <nullnullnull> dminuoso, yeah sry mate ;)
16:16:21 <dminuoso> nullnullnull: No worries. :)
16:16:28 <nullnullnull> thanks guys :) 
16:16:43 <dminuoso> winny: Dunno, there's some strange folks.
16:17:02 <dminuoso> winny: SPJ for example has a quite peculiar preference when it comes to do-notation.
16:17:14 <winny> interesting ;) i learn something every day here
16:17:15 <dminuoso> But he is.. an odd person. :)
16:18:15 <dminuoso> winny: https://gitlab.haskell.org/ghc/ghc/blob/master/compiler/typecheck/TcHsSyn.hs#L495-501
16:20:05 <winny> this reminds me of multiline javascript var/const/let style
16:20:46 <dminuoso> It's consistent with how we usually span lists across multiple lines, though.
16:21:01 <nullnullnull> btw I used the threading to make the max-timeout there, there's no timeout option with sock "connect", am I right?
16:21:22 <wroathe> Also the fact that he's using the word zonk here
16:21:33 <wroathe> Which, I have no idea what it means to "zonk" something
16:21:46 <winny> i like it, despite also having no clue
16:22:00 <dminuoso> wroathe: https://git.haskell.org/ghc.git/commitdiff/c32bb5d0c09a7e55197191f152c6875b398717cf
16:22:08 <dminuoso> wroathe: That commit message is priceless. :)
16:22:11 <fragamus> I favor zonk as well
16:22:31 <wroathe> "Remember to zonk the skolems of an implication" wat
16:23:07 <winny> if i make my own PL, zonk will be the entrypoint of the program
16:23:18 <int-e> "zonk" is a technical term meaning... something.
16:23:46 <int-e> (I never found out.)
16:24:45 <wroathe> I actually found this exact file about an hour earlier while familiarizing myself with GHC's source a bit, saw the word zonk, and then immediately closed the file
16:25:06 <wroathe> Decided to punt on coming to an understanding of zonking
16:25:25 <MarcelineVQ> a quick google on zonking skolems does reveal useful info tho
16:25:35 <dminuoso> wroathe: https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/type-checker#types-variables-and-zonking
16:26:01 <dminuoso> Just be aware that it might take gitlab a fair 10 seconds to render that page.
16:26:29 <wroathe> Yeah, I figure the information was out there, but I'm already like 16 layers deep on detours from solving my original problem
16:26:33 <MarcelineVQ> infinisil: At a fairly blind guess since I haven't done that stuff in awhile I would suppose that you're losing 25% in gc, but gaining back to the 95% from the multiple threading, and that the count of busy cores isn't particularly related. This also means that you're not gaining a whole lot of % from those threads.
16:28:26 <infinisil> Hm, not quite getting that
16:28:59 <wroathe> Huh, apparently GHC can compile Haskell down to C
16:29:23 <c_wraith> not good C
16:29:53 <c_wraith> I mean, it's valid, but it's *slow*
16:29:53 <dminuoso> Does that backend still exist?
16:30:10 <c_wraith> the unregisterized version does.
16:30:24 <infinisil> MarcelineVQ: The only thing I could think of that would make cores not fully utilized is I/O
16:30:28 <dminuoso> "unregistered"?
16:30:37 <infinisil> Disk/RAM access
16:30:49 * infinisil thinks about whether that's reasonable for his program
16:30:50 <c_wraith> that's not what I remember the word being, but I could be wrong.
16:31:16 <wroathe> I see it mentioned in the AOSA book, but this article is from like 2011
16:31:20 <jgt> those people who avoid FP because they think the word "monad" sounds weird — let's never tell them about "zonking skolems"
16:31:22 <wroathe> the GHC man page doesn't seem to have it listed anymore
16:31:36 <c_wraith> wroathe, oh, that one was removed.
16:32:03 <wroathe> drats, I wanted to see how some of this would look translated into C
16:32:10 <c_wraith> the one that still exists is mostly for porting ghc to new platforms (that have C compilers)
16:32:59 <wroathe> c_wraith: That's literally what the AOSA article says about it
16:33:11 <wroathe> "GHC can produce ordinary C code. This route produces significantly slower code than the other two routes, but can be useful for porting GHC to new platforms."
16:33:36 <dminuoso> jgt: It's weird we get so much bad reputation for monad, but Java is praised while having AbstractSingletonProxyFactoryBean and the liks.
16:33:41 <c_wraith> maybe -fvia-c was already removed by then.
16:33:45 <dminuoso> jgt: It's beyond me.
16:33:57 <c_wraith> anyway, the existing C backend isn't a compiler flag.
16:34:01 <jgt> dminuoso: I had never thought about it, but you are so right
16:34:09 <c_wraith> it's a build flag when compiling ghc
16:34:47 <josiah_sama> what's the second function argument for in the `fold` function in the `Pipes` library? https://hackage.haskell.org/package/pipes-4.3.11/docs/Pipes-Prelude.html#g:5
16:35:49 <c_wraith> it's the initial state.
16:36:21 <josiah_sama> I'm sorry, the way I asked my question was confusing
16:36:23 <c_wraith> note that the fold is a little weird. it's done over a state that is a different type than the input or the output of the fold
16:36:28 <josiah_sama> I meant the second argument that is a function
16:36:37 <josiah_sama> i.e. the third argument to `fold`
16:36:40 <c_wraith> oh, whoops. it converts the state to the output
16:37:50 <c_wraith> that is, in that signature, a is the type of the input elements, b is the type of the fold result, and x is the type of the intermediate states
16:38:16 <josiah_sama> aah, okay
16:38:19 <josiah_sama> makes total sense now
16:41:37 <MarcelineVQ> "<infinisil> Hm, not quite getting that" actually I've probably gotten myself backwards, what's the full -s output?
16:43:02 <infinisil> Hard to post right now because of my internet troubles, I'll come back later
17:06:02 <dmwit> dminuoso: Imagine this bet: you walk up to a random English speaker. A wins the bet if they have heard all of the words "abstract", "singleton", "proxy", "factory", and "bean" before. B wins if they have heard the word "monad" before. Which side you taking?
17:06:11 <dmwit> Despite the huge conjunction, I'm still taking side A.
17:06:40 <dmwit> (Precision: A wins if they've heard all the Java words and not monad. B wins if they've heard monad but not all of the Java words. It's a tie otherwise.)
17:09:55 <dminuoso> dmwit: Mmm, that's a tough one. I guess it boils down to whether singleton is more likely to be known than monad..
17:11:52 <jle`> bean is a free win
17:12:28 <jle`> proxy isn't too uncommon
17:12:38 <jle`> abstract probably is also a free win
17:12:46 <jle`> ah i just basically re-derived dminuoso's point
17:13:36 <dmwit> A related irony: the more common the word, the less related its common meaning is to its Java meaning.
17:13:57 <jle`> it wouild be harder but not impossible if the word was AbstractSIngletonProxyFactoryBean
17:13:58 <dmwit> Abstract? Proxy? Spot-on. Bean, though...
17:14:03 <Axman6> @hoogle zDecode
17:14:03 <lambdabot> Encoding zDecodeString :: EncodedString -> UserString
17:14:03 <lambdabot> Network.AWS.Data.Headers hAMZDecodedContentLength :: HeaderName
17:14:03 <lambdabot> Network.AWS.Prelude hAMZDecodedContentLength :: HeaderName
17:14:56 <dmwit> dminuoso: https://www.googlefight.com/singleton-vs-monad.php
17:15:00 <dmwit> =P
17:15:29 <dminuoso> dmwit: Successfully proving that Java has more websites. :p
17:15:38 <dmwit> yes =)
17:16:17 <dmwit> I suppose to make the point useful, we should add a precondition that we walk up to a random English-speaking non-programmer.
17:16:40 <dmwit> Otherwise perhaps the vastly higher popularity of Java skews the result.
17:17:39 <dminuoso> dmwit: That was my implicit assumption already, otherwise it would be a silly discussion.
17:18:05 <dmwit> v. good
17:19:34 <dminuoso> dmwit: Now, instead of a google fight I offer a wiki fight: https://en.wikipedia.org/wiki/Monad https://en.wikipedia.org/wiki/Singleton
17:20:16 <dminuoso> The probably winning argument for singleton is that there exist several commonwealth cities named Singleton.
17:20:47 <dminuoso> But if we preclude cities, then Monad seems to be more likely to have been heard.
17:20:57 <dminuoso> (Perhaps via the philosophy route)
17:22:22 <EvanR> i'm trying to backtrack and understand the basis of a fight between singleton and monad
17:24:17 <dminuoso> EvanR: 01:33:13     dminuoso | jgt: It's weird we get so much bad reputation for monad, but Java is praised while having AbstractSingletonProxyFactoryBean and the liks.
17:24:58 <EvanR> ah my mind was running wild between app design based on a giant monad and one based on singleton objects
17:25:51 <dminuoso> EvanR: Funny, and you thought we'd settle the argument using googlefight?
17:26:15 <dminuoso> Why haven't I considered googlefight for picking patterns and designs.
17:26:42 <EvanR> glad to hear someone is using google for anything at all 
17:26:58 <EvanR> i can't get it to work anymore
17:34:27 <unclechu> hey guys, can i somehow describe `Monoid` superclass like this `instance Monoid (f a) => Applicative (Foo f)` for type `data Foo f a`?
17:35:17 <unclechu> i want to use `mempty` inside that instance 
17:35:39 <unclechu> but `a` is ambiguous here
17:40:45 <dminuoso> unclechu: That won't work.
17:41:14 <dminuoso> If you use InstanceSigs and ExplicitForAll, then you will notice the following
17:41:26 <Axman6> does FlexibleContexts help?
17:41:37 <Axman6> probably not
17:42:28 <dminuoso> ⌜instance Applicative (Foo f) where pure :: forall a. a -> Foo f a; (<*>) :: forall a b. Foo f (a -> b) -> Foo f a -> Foo f b⌝
17:43:56 <dminuoso> unclechu: See how "a" and "a/b" are universally quantified over?
17:44:11 <dminuoso> Applicative demands it works for *all* choices of a/b, not just those that are Monoid.
17:45:20 <dminuoso> unclechu: You could however make a ⌜class Monoid1 f where mappend1 :: f a -> f a -> f a; mempty1 :: f a⌝
17:45:41 <dminuoso> unclechu: And then write ⌜instance Monoid1 f => Applicative (Foo f)⌝, and then use mappend1 inside.
17:46:06 <unclechu> hmm.. i'll try, thanks
17:46:30 <dminuoso> unclechu: (Of course, if you prefer you can also make some Semigroup1)
17:47:31 <dminuoso> unclechu: Of course at this point I wonder whether you are perhaps taking about an Alternative, rather than Monoid1.
17:47:56 <unclechu> Alternative depends on Applicative
17:48:23 <dminuoso> unclechu: So?
17:48:56 <dminuoso> unclechu: I mean assuming your Monoid structure you are thinking satisfies the expected Alternative laws, that shouldn't be a problem.
17:49:11 <dminuoso> But it's just a thought.
17:56:45 <unclechu> i think i've solved it, i created new `class Empty f where empty :: f a; default empty :: Monoid (f a) => f a; emtpy = mempty` and then i depended on it `instance Empty f => Applicative (Foo f)`
18:03:50 <dmwit> unclechu: Would you be willing to share what you arrived at more fully? Something smells fishy here.
18:04:41 <unclechu> i'll post it when i done it, it's not yet ready and tested
18:06:57 <lyxia> fishy like sushi
18:10:32 * hackage hw-ip 2.3.2.0 - Library for manipulating IP addresses and CIDR blocks  https://hackage.haskell.org/package/hw-ip-2.3.2.0 (haskellworks)
18:27:55 <PotatoRick[m]> dmwit: here is what i came up with https://pastebin.com/fz8gQhPX
19:06:28 * hackage raft 0.4.0.0 - Miscellaneous Haskell utilities for data structures and data manipulation.  https://hackage.haskell.org/package/raft-0.4.0.0 (BrianBush)
19:16:16 <Axman6> :t traverse Just
19:16:18 <lambdabot> Traversable t => t b -> Maybe (t b)
19:16:41 <Axman6> :t foldMap Just
19:16:43 <lambdabot> (Foldable t, Semigroup a) => t a -> Maybe a
19:21:18 <MarcelineVQ> :t foldMap (First . Just)
19:21:20 <lambdabot> Foldable t => t a -> First a
20:23:58 * hackage mono-traversable 1.0.12.0 - Type classes for mapping, folding, and traversing monomorphic containers  https://hackage.haskell.org/package/mono-traversable-1.0.12.0 (MichaelSnoyman)
20:41:06 <dmwit> PotatoRick[m]: I think you should reconsider using Alternative instead of Monoid1.
20:42:19 <dmwit> Or at least document the laws you expect of Monoid1.
20:42:45 <dmwit> e.g. to prove that `return x >>= f = f x`, you need `mempty1 >>= toList . f = mempty1` maybe? Or what?
20:51:07 <dmwit> The associativity law seems like it gets a bit complicated about what it demands, too.
20:58:27 * hackage hw-ip 2.3.3.0 - Library for manipulating IP addresses and CIDR blocks  https://hackage.haskell.org/package/hw-ip-2.3.3.0 (haskellworks)
21:08:54 <crestfallen> hi why wouldn't the following return [15]    ?  ..
21:09:04 <crestfallen> > pure ((*3) 5)
21:09:06 <lambdabot>  error:
21:09:07 <lambdabot>      • Ambiguous type variable ‘f0’ arising from a use of ‘show_M535413171008...
21:09:07 <lambdabot>        prevents the constraint ‘(Show (f0 Integer))’ from being solved.
21:09:39 <crestfallen> > pure ((*3) 5) :: Integer
21:09:41 <lambdabot>  error:
21:09:41 <lambdabot>      • Couldn't match expected type ‘Integer’
21:09:41 <lambdabot>                    with actual type ‘f0 Integer’
21:10:00 <crestfallen> weird the first try works in ghci
21:10:25 <crestfallen> pure (*3) 5)  returns 15, not [15]
21:10:27 <mniip> it does so in the IO applicative
21:10:30 <Axman6> it'll be using f ~ IO in ghci
21:10:39 <mniip> % pure ((*3) 5)
21:10:40 <yahb> mniip: 15
21:10:52 <Axman6> try pure ((*3) 5) :: [Integer]
21:11:25 <crestfallen> so the list needs to be specified
21:11:28 <Axman6> the type you're actually getting (which :t it should confirm) will be IO Integer
21:12:12 <crestfallen> > pure ((*3) 5) :: [Integer]
21:12:13 <Axman6> remembe rthat GHCi will execute IO actions
21:12:15 <lambdabot>  [15]
21:13:02 <jle`> crestfallen: remember that pure is an example of "return-type polymorphism", where the type of the return type of the function dictates which instance is dispatched
21:13:09 <jle`> another common example is 'read'
21:13:13 <jle`> > read "5" + 2
21:13:16 <lambdabot>  7
21:13:19 <jle`> > read "True" || False
21:13:21 <lambdabot>  True
21:13:36 <mniip> % let x = traceShow (typeOf x) $ pure 123 in x
21:13:36 <yahb> mniip: IO Integer; 123
21:13:54 <jle`> read is actually a bunch of different functions under the same name, and each type has a different implementation of read
21:14:04 <jle`> so the return type determines which implementation to use
21:15:14 <crestfallen> ok so when we have a case where the return could be impure, we need to specify if we want a functor like [15], or Integer IO etc
21:16:09 <crestfallen> or is IO also pure at that stage?
21:17:09 <jle`> return is never impure
21:17:15 <jle`> er, pure is never 'impure'
21:17:43 <jle`> in this case we have `pure :: Applicative f => a -> f a`, so the choice of 'f' (in the return type) determines which implementation of pure to use
21:17:57 <jle`> so it's not really a pure/impure sort of distinction
21:18:47 <crestfallen> ok yeah your comment "the return type of the function dictates which instance is dispatched is helpful...
21:19:35 <crestfallen> so once again its a case where studying the type signature is KEY. thanks Axman6 mniip jle`   alot    also
21:19:47 <crestfallen> ..
21:20:47 <crestfallen> if you could look at my final draft of Sundays evaluation by hand..
21:21:14 <crestfallen> to tell me if you'd do it differently.
21:22:41 <crestfallen> https://paste.ee/p/go0ej   jle` et al
21:23:31 <jle`> i wouldn't say "is sugar for", but rather "evaluates to"
21:23:48 <jle`> just from the definition of <*>
21:23:53 <jle`> for lists
21:24:16 <jle`> if you want to be explicit with the evaluation, i think you do skip a few steps
21:26:29 <crestfallen> I start on lines 11 and 24. where do I skip steps?
21:28:28 <crestfallen> (I used sugar since you mentioned it sunday, though only for the (\x -> (\y z .. )    and used the term inner lambda
21:28:32 <crestfallen> )
21:29:16 <jle`> (\x y z -> ..) is sugar for (\x -> \y z -> ..), but the application of <*> is not sugar
21:29:33 <jle`> well, the full steps to evaluating [f] <$> [1,2] <*> [3,4] <*> [5,6]
21:29:48 <jle`> would probably be [f 1, f 2] <*> [3,4] <*> [5,6]
21:29:58 <jle`>  = [f 1 3, f 1 4, f 2 3, f 2 4] <*> [5,6]
21:30:27 <jle`> = [f 1 3 5, f 1 3 6, f 1 4 5, f 1 4 6, f 2 3 5, f 2 3 6, f 2 4 5, f 2 4 6]
21:32:11 <crestfallen> ok so my evaluation order is actually wrong
21:32:12 <jle`> i guess that does skip some steps within the implementation of <*>, however it is implemented
21:35:33 <crestfallen>  [f 1 3, f 1 4, f 2 3, f 2 4]   << so here f 2 is evaluated first, before all 4 (f 1)'s are evaluated ?
21:36:11 <jle`> if we are talking about order of evaluation, it doesn't matter
21:36:21 <crestfallen> hmm
21:36:26 <jle`> if you want to eventually force the entire list and evaluate every item, it doesn't matter what order they are evaluated in
21:37:07 <jle`> if we are talking about the order of the items in the list...then yeah, the order i think is how it works
21:37:13 <jle`> > [f] <*> [1,2] <*> [3,4] <*> [5,6]
21:37:15 <lambdabot>  error:
21:37:16 <lambdabot>      • Ambiguous type variable ‘b0’ arising from a use of ‘show_M922800072687...
21:37:16 <lambdabot>        prevents the constraint ‘(Show b0)’ from being solved.
21:37:19 <jle`> > [f] <*> [1,2] <*> [3,4] <*> [5,6] :: [Expr]
21:37:22 <lambdabot>  [f 1 3 5,f 1 3 6,f 1 4 5,f 1 4 6,f 2 3 5,f 2 3 6,f 2 4 5,f 2 4 6]
21:37:27 <jle`> phew
21:37:28 * hackage hw-ip 2.3.4.0 - Library for manipulating IP addresses and CIDR blocks  https://hackage.haskell.org/package/hw-ip-2.3.4.0 (haskellworks)
21:39:08 <crestfallen> ok yeah that's what I had in mind
21:40:09 <crestfallen> see jle` I figured I'll never get this stuff until I really master the evaluation and appropriate notation to express it, to say a young person.
21:40:49 <crestfallen> especially(?) in the case of recursive evaluation
21:41:29 <crestfallen> there's also the question of how the evaluation should look with impure objects..
21:41:49 <jle`> what is an 'impure object' ?
21:42:49 <crestfallen> well, for example:   ...
21:43:21 <crestfallen> https://paste.ee/p/mtC66
21:43:46 <crestfallen> maybe what I mean is IO, return, etc.
21:44:11 <jle`> neither IO nor return nor etc. are 'impure objects' :)
21:44:31 <crestfallen> etc isn't? :)
21:44:35 <jle`> ;)
21:44:49 <Lycurgus> only foreign
21:45:09 <crestfallen> but how to write it out..
21:45:32 <crestfallen> for example the above more recent paste
21:45:47 <crestfallen> how to write out the evaluation steps
21:46:21 <crestfallen> where they use replicate with a function which seems odd to me
21:46:22 <jle`> for which one?
21:46:33 <crestfallen> getChars'
21:47:10 <crestfallen> lines 11,12
21:47:27 <jle`> just follow normal rules
21:47:35 <jle`> are you familiar with 'evaluation by substitution' ?
21:47:47 <crestfallen> yeah
21:47:48 <jle`> basically: every time you see something like 'f x', replace it with the definition of f
21:48:09 <jle`> do you see how this applies to getChars ?
21:48:13 <jle`> (the first one)
21:48:34 <jle`> try evaluating 'getChars 2' by hand
21:50:59 <crestfallen> getChars 2 = pure (:) <*> getChar <*> getChars (2-1)
21:51:41 <crestfallen> H:  <*> getChar <*> getChars (1)
21:52:33 <crestfallen>  or is it       H:[]  <*> getChar <*> getChars (1)
21:53:17 <jle`> `pure (:) <*> getChar <*> getChars 1`
21:53:24 <jle`> and from there you can expand getChars 1 again
21:53:52 <crestfallen> so there's no [] of course
21:54:02 <jle`> not that i see yet
21:54:26 <jle`> nothing we have yet seen introduces a []
21:54:29 <crestfallen> but do you not do:     H:i   ->   Hi
21:54:42 <jle`> are you talking about 'pure' here?
21:55:01 <jle`> pure here is :: a -> IO a, it is a completely different function than pure for lists
21:56:32 <crestfallen> oh so pure (:) is Cons for IO but doesn't actually denote Cons operator?
21:56:44 <Axman6> :t (:)
21:56:45 <lambdabot> a -> [a] -> [a]
21:56:50 <Cale> pure (:) :: IO (a -> [a] -> [a])
21:56:51 <Axman6> :t pure (:)
21:56:53 <lambdabot> Applicative f => f (a -> [a] -> [a])
21:57:05 <jle`> crestfallen: it (:) denotes the cons operator, but the 'f' here is IO, not []
21:57:12 <Axman6> a.k.a IO (a -> ([a] -> [a]))
21:57:31 <jle`> note the type of pure, a -> f a
21:57:37 <Cale> So then pure (:) <*> getChar :: IO ([a] -> [a])
21:57:38 <jle`> a and f are allowed to vary independently
21:57:54 <Cale> er
21:58:01 <Cale> So then pure (:) <*> getChar :: IO ([Char] -> [Char]) -- rather
21:58:28 <Cale> (a gets specialised to Char, because getChar can only get us a Char to supply as the first argument to (:))
21:59:23 <crestfallen> ok so in terms of writing out by hand, the (:) can be used in the way of convention
21:59:44 <crestfallen> just don't add list brackets
22:00:03 <crestfallen> correct?
22:00:07 <Axman6> I don't understand that sentence at all
22:00:24 <jle`> (:) is a function, like negate or abs or not, etc.
22:00:32 <jle`> it's just like 'negate' doesn't add list brackets to anything
22:00:52 <crestfallen> convention meaning to convey the consing
22:01:10 <Axman6> There's nothing special about (:), other than it is also a constructor, like Just. both of these are just functions
22:01:14 <jle`> well, it's not a convention
22:01:18 <jle`> that's what the function is
22:01:29 <jle`> just like 'negate' being a negation function isn't a "convention"
22:01:35 <jle`> that's...what it actually is, in the standard libraries
22:01:35 <crestfallen> but you do this ie
22:01:37 <jle`> > negate 3
22:01:40 <lambdabot>  -3
22:01:52 <crestfallen> > 1:2:[]
22:01:54 <lambdabot>  [1,2]
22:01:59 <crestfallen> to convey what the result is
22:02:07 <Axman6> > let cons x xs = (:) x xs in cons 3 []
22:02:10 <lambdabot>  [3]
22:02:18 <jle`> crestfallen: you might be mixing up the function and the result of the function
22:02:23 <jle`> 'negate 3' returns -3
22:02:26 <jle`> it doesn't mean that negate is -3
22:02:46 <jle`> negate is a function that takes a number and returns its negation
22:02:57 <Axman6> crestfallen: are you ok with the fact that the syntax [1,2,3] is syntax sugar for 1:2:3:[]?
22:02:59 <jle`> but it would be incorrect to say that 'negate' == -3
22:03:07 <crestfallen> yeah Axman6 
22:03:14 <jle`> (:) is a function that takes an item, and a list, and returns a new list
22:03:23 <MarcelineVQ> "how do I denote the reduction of using pure on (:) for IO, if it was a list I could just write [ ]"
22:04:32 <crestfallen> right but the return is printed, so I'm talking about in lieu of having the output in brackets, how would you write it out?
22:05:44 <crestfallen> printed to the screen, so I'm just looking for a notational convention, if I make any sense
22:07:32 <jle`> ah
22:07:46 <jle`> IO is an 'abstract' data type, so i would just reduce `pure (:)` to `pure (:)` for IO
22:07:55 <jle`> just like how i'd reduce `Just (:)` to `Just (:)`, for Maybe
22:08:12 <jle`> some people also like to reduce it to 'return' instead of 'pure', just for consistency
22:09:18 <jle`> in the end when you fully redice getChars 2 in this way, you get:
22:09:43 <jle`> pure (:) <*> getChar <*> (pure (:) <*> getChar <*> (pure (:) <*> getChar <*> pure []))
22:10:15 <jle`> so how to examine this requires understanding how <*> works for IO
22:10:35 <crestfallen> working..
22:10:36 <jle`> IO is a normal data type, just like any other one
22:10:54 <jle`> (<*>) for IO is pure, just as pure as it is for lists
22:11:10 <jle`> so like how for lists, to understand <*>, we understand how lists define <*>.  here, for IO, to understand <*>, we understand how IO defines <*>
22:11:53 <jle`> so how `iof <*> iox` works is that it takes two IO actions iof and iox, and returns a new IO action whose effects are the effects of iof, followed by the effects of iox
22:12:08 <jle`> and, the important thing, 'pure x' has no IO effects
22:12:54 <jle`> oh, and that <*> is associative with respect to effects combination
22:13:14 <jle`> the effects of (ioa *> iob) *> ioc are the same as the effects of ioa *> (iob *> ioc)
22:13:29 <jle`> but i guess that's something you could deduce from what i said before -- it's just sequencing one after the other
22:13:45 <jle`> so when you look at `pure (:) <*> getChar <*> (pure (:) <*> getChar <*> (pure (:) <*> getChar <*> pure []))`, you can see a bunch of chained <*>'s
22:13:54 <jle`> and each one "combines" the effects on both sides
22:14:17 <jle`> remembering that pure (:), pure [], has no effects...what can you say about the 'effects' of that final giant result?
22:14:36 <jle`> if you look at all the non-pure values being <*>'d, you see there are only three: getChar, getChar, and getChar
22:14:53 <jle`> so 'getChars 3' resuls in an IO action that does getChar three times
22:15:31 <crestfallen> but <*> with pure will make each one pure as the result 
22:16:05 <jle`> remember, <*> combines effects one-after-the-other
22:16:17 <jle`> so `pure f <*> iox` will have the effects of pure f, then the effects of iox
22:16:26 <jle`> but since pure f has no effects, then pure f <*> iox just has the effects of iox
22:17:45 <crestfallen> oh man
22:17:57 * hackage hw-ip 2.3.4.1 - Library for manipulating IP addresses and CIDR blocks  https://hackage.haskell.org/package/hw-ip-2.3.4.1 (haskellworks)
22:19:53 <jle`> so this is 'kind of like' reading 0 + x + (0 + x + (0 + x + 0)) and seeing that it is just 3*x
22:20:19 <jle`> or 1 * x * (1 * x * (1 * x * 1)) and seeing that it is just x^3
22:22:52 <crestfallen> jle`, so an IO return has been manipulated mathematically so to speak, so that haskell sees it as "pure", being expressed mathematically in a way that is appealing to haskell?
22:23:21 <dmwit> blech
22:23:30 <dmwit> Don't anthropomorphize languages, they hate that.
22:23:47 <Axman6> Ruby doesn't
22:24:44 <crestfallen> sorry I can't follow. if pure f <*> iox just has the effects of iox, it still has effects after it is combined, right?
22:25:08 <jle`> crestfallen: remember <*> is a function
22:25:14 <jle`> it takes two IO actions and returns a new IO action
22:25:26 <nullnullnull> args <- getArgs      how can I get the second arg only?
22:25:28 <jle`> so if i do `let ioy = pure f <*> iox`
22:25:37 <jle`> nullnullnull: you can pattern match on 'args', it's just a normal list :)
22:25:41 <jle`> or use any other sort of list function
22:25:48 <nullnullnull> hmm
22:25:57 <nullnullnull> cant use something like arg[2]?
22:26:11 <jle`> crestfallen: then in that case, ioy is a new IO action. and its effects are exactly the same as the effects of iox
22:26:29 <jle`> nullnullnull: you can do arg !! 1, for the second item, but remember !! is partial
22:26:57 <nullnullnull> it can work for 3 items at least? to do the !! 
22:27:06 <Axman6> nullnullnull: case args of (_:_:x:_) -> <do something with x)
22:27:09 <nullnullnull> 3 args
22:27:25 <nullnullnull> ah then I need to save them into variables right?
22:27:54 <jle`> it depends on what you want to do with them :)
22:28:01 <crestfallen> I'm reading back, I missed plenty (5 kind people helping) but what does this mean? "  <*> is associative with respect to effects combination "
22:28:22 <jle`> crestfallen: i mentioned it earlier, (ioa *> iob) *> ioc has the same effects as ioa *> (iob *> ioc)
22:28:23 <nullnullnull> I wanted to do some math stuff for each arg passed
22:28:27 <nullnullnull> like a + b + c
22:28:39 <jle`> yeah, it can be convenient to bind them to a name
22:29:27 <dmwit> nullnullnull: After your snippet, `args` is just a plain old list of strings. You can do whatever complicated computation on them you want, with the full power of Haskell's list-processing functions at your fingertips.
22:29:42 <jle`> crestfallen: more specifically, if i set test1 = (ioa *> iob) *> ioc, and test2 = ioa *> (iob *> iob), then test1 and test2 are both io actions that have the same effects
22:30:03 <MarcelineVQ> but jle`, what is an effect :D
22:30:19 <jle`> the reason why i mention that is to say that we can ignore the parenthesization when reasoning about effects in the expression we were looking at
22:30:19 <MarcelineVQ> and is it different than a value
22:30:31 <sm[m]> a:b::c:_ <- getArgs, if you don’t want to handle anything but three arts
22:30:35 <sm[m]> args
22:32:50 <nullnullnull> thanks guys :) 
22:34:52 <crestfallen> " each one "combines" the effects on both sides"
22:37:35 <crestfallen> so does it essentially mean that that context that contains an IO effect is pure, after pure and <*> are applied. to use the word, the functions return the character/characters in a "container"
22:41:39 <crestfallen> the functor container makes the output viable in some way for the way haskell is designed. jle`  ?
22:43:30 <nullnullnull> another small question:
22:43:45 <nullnullnull> how can I make my args global? (I have some threads and main)
22:44:04 <nullnullnull> (h:p:t:_) <- getArgs
22:47:27 <cocreature> nullnullnull: don’t make them global, just pass them around (or if that gets too annoying consider something like ReaderT that takes care of passing it around behind the scenes)
22:48:25 <Axman6> those threads will be forked fro main anyway, so you just need to pass them to the threads when you fork them
22:48:27 <nullnullnull> but the thread starts before main
22:48:40 <Axman6> no?
22:49:21 <Axman6> main is the first thing that starts, by definition
22:49:48 <dminuoso> crestfallen: What if I told you that Applicative didn't have ⌜<*>⌝, but some method ⌜><⌝ instead, with the following type signature ⌜(><) :: Applicative f=> f a -> f b -> f (a, b)⌝
22:50:09 <nullnullnull> T=do       threadDelay 2000000; exitImmediately(ExitFailure 1);       main=do   etc
22:50:10 <dminuoso> crestfallen: And equivalently, instead of ⌜pure⌝ you had ⌜unit :: Applicative f => f ()⌝
22:50:43 <crestfallen> MarcelineVQ   " but j..le`, what is an effect :D     and is it different than a value "
22:50:48 <crestfallen> good question ^
22:50:50 <nullnullnull> ah u mean I need to call that thread from main
22:50:50 <dminuoso> crestfallen: I think in a lot of way, Applicative is confusing because there's that notion of function application to it - but in reality the function application is not the point.
22:51:13 <nullnullnull> to send args to thread
22:51:23 <dminuoso> crestfallen: The point is that (><) that somehow merges together two effects and their results.
22:51:50 <Axman6> nullnullnull: t doesn't do anything (alsi it can't be called T, that's not a valid variable name)
22:52:25 <nullnullnull> ok mate, so I need to pass arg to the thread right? :)
22:52:36 <crestfallen> dminuoso, but do the effects go away? I mean, what are effects?
22:52:40 <Axman6> yes
22:53:00 <cocreature> t args = …; main = do args <- getArgs; forkIO (t args); …
22:53:04 <dminuoso> crestfallen: "effect" is a lose term that somehow describes that sort of "context" that separates "T A" from juts "A"
22:53:25 <dminuoso> crestfallen: For each choice of T, you would think of T as having some effect in a lose notion.
22:54:01 <Cale> crestfallen: It might be clearer to start with Monad, because it's not necessary to think of these things which are producing functions as their results.
22:54:21 <nullnullnull> thanks guys again :)
22:54:35 <crestfallen> Cale I think j.l.e' suggested that as well, or was it you?
22:54:51 <Cale> Could have been me even :D
22:55:00 <crestfallen> !!
22:55:02 <dminuoso> Cale: The strangest thing is, this superclass relationship is fairly misleading - I feel that Applicative is so much more orthogonal to Monad.
22:55:36 <Cale> I mean, Applicative is something you can get for free if you have Monad, so I don't find it very orthogonal
22:56:00 <dminuoso> That is, Semigroup and Monoid are related differently than Applicative and Monad.
22:56:16 <dminuoso> Cale: Sure, but that's just because Monad give rise to a canonical Applicative instance via Yoneda.
22:56:40 <dminuoso> If you compare say Ord with Eq, where Ord is pretty much Eq plus some stuff, or Monoid which is Semigroup plus some stuff.
22:56:42 <MarcelineVQ> dminuoso: my man you didn't example any effects :O
22:56:47 <Cale> I don't know why it's Yoneda, but okay :)
22:57:04 <crestfallen> but wait what are we trying to do with taking effects and transforming them? ultimately, it makes them mathematically in step with the rest of haskell, right?
22:57:21 <Cale> crestfallen: Well, that's part of it, yeah
22:57:46 <Cale> Specifically, it's necessary to have *some* type for describing IO effects
22:58:38 <Cale> and then it so happens that the operations we want for those types that describe "computations having results", like IO actions, end up being patterns that happen over and over again
22:59:09 <Cale> So we end up defining these type classes like Applicative and Monad to capture the pattern which is common across many libraries (IO being just one of them)
22:59:40 <Cale> Like any abstraction, it'll make a whole lot more sense as you pick up more and more examples
23:00:00 <phadej> I think dminuoso tries  to say that Applicative and Monad superclass relationship is more of accidental
23:00:08 <Cale> There are not many relevant examples of instances of Applicative which are not also instances of Monad though
23:00:12 <phadej> e.g. Arrow and Monad aren't related
23:00:23 <phadej> but both can be used to describe effects
23:00:43 <dminuoso> phadej: Right. Unlike a Monoid where you would think of it as an upgraded Semigroup.
23:01:24 <dminuoso> phadej: Unless of course there was some sort of free monad with a forgetful adjoint that somehow downgraded Monad to Applicative. Is that even a thing?
23:01:50 <crestfallen> A functor is a context that stores data in a distinct form. so we need to be able to handle them like they were more standard values, so they are a particular kind of ADT essentially
23:02:25 <Cale> crestfallen: That first sentence is a bit word-saladish to me... I don't know what the word "context" means there
23:02:29 <phadej> no, in general (CT), the requirements [to applicative like thing and monad to be related] on a category are quite strong
23:02:33 <Axman6> :t guard
23:02:35 <lambdabot> Alternative f => Bool -> f ()
23:03:12 <Cale> crestfallen: At least for the case of Haskell, a functor is a parametric data type F for which we can define a function  fmap :: (a -> b) -> F a -> F b
23:03:31 <Axman6> > guard True (Just 1)
23:03:35 <lambdabot>  error:
23:03:35 <lambdabot>      • No instance for (Alternative ((->) (Maybe Integer)))
23:03:35 <lambdabot>          arising from a use of ‘guard’
23:03:36 <Cale> crestfallen: Lists are a good first example of that, since everyone comes across map early on
23:03:54 <Axman6> > guard True *> Just 1
23:03:57 <lambdabot>  Just 1
23:04:04 <crestfallen> I was watching bartosz milewski who was talking about their (functors) efficiency in memory
23:04:16 <Cale> crestfallen: But also, we can have more interesting things. Let's define our own type for representing IO actions
23:04:23 <dminuoso> Lists are also an interesting concept because the "effect" they model is the one of non-determinism. By that I mean that [1,2,3] doesn't mean a sequence of three numbers. It rather means "It's some number (out of three), but we dont know which one exactly"
23:04:53 <Cale> data TermIO a = Done a | PutStr String (TermIO a) | GetLine (String -> TermIO a)
23:04:58 <Cale> Let's just start with this one :)
23:04:59 <dminuoso> So the difference between 2 and [1,2,3] is that the list adds some sort of "fuzziness", and that's the effect the Applicative and Monad instances talk about.
23:05:07 <Cale> Are you familiar with this syntax?
23:05:27 <Cale> We're defining a data type with three constructors, Done, PutStr, and GetLine
23:05:40 <dminuoso> phadej: Interesting, what kind of constraints are those?
23:06:01 <crestfallen> dminuoso, sorry if that is for my benefit I don't follow . very sorry
23:06:17 <crestfallen> Cale one sec
23:06:53 <Cale> The idea is, that any action (whose result has type a) is either going to be Done, along with a value of type a that it finishes with, or it will start off by printing a string to the terminal (followed by some other action whose result will have type a)
23:07:24 <Cale> ... or it will start by getting a line of text from the user, and then based on the String result of that, decide which action to perform next
23:07:32 <MarcelineVQ> The terminology overload is getting steamy in here.
23:07:36 <Cale> (and that action will have a result of type a)
23:11:29 <crestfallen> ok thanks Cale I follow that pretty well
23:12:07 <Cale> crestfallen: Okay, so we could write a Functor instance for this too
23:12:18 <Cale> instance Functor TermIO where
23:12:32 <Cale>   fmap f (Done a) = Done (f a)
23:13:00 <Cale>   fmap f (PutStr str x) = PutStr str (fmap f x)
23:13:34 <Cale>   fmap f (GetLine k) = GetLine (\str -> fmap f (k str))
23:13:37 <jle`> crestfallen: IO is not a container
23:13:55 <jle`> oh, i should have read scrollback
23:13:58 <Cale> Well, I'm kind of in the middle of showing the sense in which IO is kind of container-ish
23:14:05 <jle`> yes, please igore me :)
23:14:23 <crestfallen> thanks so much jle` for everything!
23:14:53 <Cale> crestfallen: Does that implementation of fmap make sense? The end result is that we're applying f to the results of our TermIO action
23:15:41 <Cale> The first line there says that if our action is simply the trivial one which produces a result, then fmap f will transform it into a similar one, but with f applied to the result
23:16:27 <Cale> The second line says that if our action starts off by printing a string, then it still will start off that way, but we'll fmap f over the action which follows that
23:17:11 <crestfallen> the action?
23:17:25 <crestfallen> fmap f x    ?
23:17:26 <Cale> Well, I'm going to refer to values of type TermIO a as "actions"
23:17:48 <Cale> and in particular, the action I was referring to was the x in fmap f x, yeah
23:18:48 <Cale> Values of type TermIO a are simply describing things to be done -- if we want to actually print strings on the terminal, or get text from a user, we'll need to implement a way of executing them
23:18:48 <crestfallen> ok
23:20:20 <Cale> The last line there, fmap f (GetLine k) = GetLine (\str -> fmap f (k str)) says that if the given action starts off by getting a line of text from the user, and then proceeds to use k to decide what steps to take next
23:20:52 <Cale> then our resulting action will get a line of text from the user, and then, given the string the user typed is str,
23:21:11 <Cale> apply k to str to get an action to be performed next, but fmap f over that
23:21:26 <Cale> (so as to transform the eventual result)
23:21:38 <Cale> Make sense?
23:21:50 <crestfallen> what is k ?
23:22:09 <Cale> So, GetLine :: (String -> TermIO a) -> TermIO a
23:22:27 <Cale> Takes a function which will decide how to proceed given the user's input
23:22:52 <Cale> Of course, that's just how I'm interpreting it, it's really just an arbitrary function
23:23:41 <Cale> So that we can eventually encode actions which proceed differently based on what the user types
23:23:58 <Cale> (which is something you often want programs to be able to do)
23:24:40 <Cale> We can write an interpreter which will transform our TermIO actions into plain Haskell IO actions:
23:24:48 <Cale> execute :: TermIO a -> IO a
23:24:55 <Cale> execute (Done v) = return v
23:25:15 <Cale> execute (PutStr str x) = do putStr str; execute x
23:25:33 <Cale> execute (GetLine k) = do str <- getLine; execute (k str)
23:26:31 <Cale> You can imagine that IO is similar to our TermIO type, and that inside the Haskell runtime there is a similar program which is pattern matching on the constructors of IO and carrying out the steps described.
23:26:57 <Cale> (It's not actually, it's an ugly hack for performance and ease of compiler implementation, but it *could* be)
23:27:57 <crestfallen> shall Plan A be to start reading about Monads?
23:28:13 <Cale> Well, I'm getting there :)
23:28:21 <Cale> Let's start with a few *particular* monads
23:28:31 <Cale> and then worry about the abstraction a bit after
23:28:49 <Cale> We could look at how (>>=) is implemented for this TermIO type
23:29:12 <Cale> (>>=) :: TermIO a -> (a -> TermIO b) -> TermIO b
23:29:19 <Cale> The idea with this type
23:29:28 <crestfallen> I'm not sure I'm capable at this moment tbh
23:29:30 <Cale> is that we're giving an action of type TermIO a to start off with
23:30:04 <Cale> and then a function which will take the result of that first TermIO action, (which has type a), and produce an action of type TermIO b to continue with
23:30:18 <Cale> and (>>=) is going to glue those together into a single action
23:30:49 <Cale> crestfallen: Totally lost?
23:31:09 <Cale> Maybe we could just start with other examples of monads, if you're not having an easy time with this one
23:31:17 <crestfallen> yeah sorry I'm pretty lost. I understand the cases based on the user input
23:31:29 <Cale> okay
23:32:58 <Cale> So yeah, the idea here is just that we can make data types whose values represent "computations" or "actions" to be performed. This is a common strategy across many Haskell libraries. What those computations are allowed to do varies...
23:33:28 <Cale> For example, we might have a type  Parser a  for things which try to consume the start of an input string, and, if successful, produce a result of type a
23:34:15 <crestfallen> so each action needs to ultimately be pure, right?
23:34:38 <Cale> Our description of what is to be done is
23:34:45 <Cale> Actually carrying out the steps might not be
23:35:30 <Cale> Yeah, the real thing I'm getting at with the TermIO example was to try to give some sense that IO action values are just ordinary values, even though IO is an opaque type
23:36:55 <crestfallen> opaque
23:37:06 <Cale> as in, its implementation is hidden from us
23:37:14 <Cale> We can't pattern match on its constructors
23:37:35 <Cale> "abstract" would be another word for it
23:37:56 <Lycurgus> and definitely not as a shoehorned kludge to get IO in FP
23:38:27 <crestfallen>  We can't pattern match on its constructors    << sorry pretty confused
23:38:58 <Cale> Like, normally, if we define some data type like:
23:39:09 <Cale> data List a = Empty | Cons a (List a)
23:39:30 <Cale> We can see the constructors Empty and Cons, and use them to take apart values of type List a
23:39:41 <crestfallen> right
23:39:44 <dminuoso> Cale: You can only pattern match on a constructor if the implementor gives it to you. Hiding the data constructor is a mechanism of hiding implementation (such that you cant just arbitrarily break it apart and look inside)
23:39:44 <Cale> But imagine they're not exported from the module in which they're defined
23:39:59 <dminuoso> So it's encapsulation. :)
23:40:26 <Cale> We could export just some basic lists and ways of working with them, without exposing our specific implementation of lists
23:40:52 <Cale> If you look at Data.Sequence, it's very much like that, actually
23:41:15 <Cale> From outside, it's something which looks like a list, internally, it's a weird tree thingy
23:41:33 <Cale> (with some really nice asymptotics for concatenating and splitting)
23:42:27 <nullnullnull> I sent variable to thread:   thread t;       how can I receive it from the thread? is it like this:  thread:: t -> Int()
23:42:45 <Cale> IO is also like that, we can't tell from what the IO library gives us how the data type is implemented -- we're just given a bunch of basic IO actions and ways of combining them together.
23:43:27 <Cale> nullnullnull: Which thread library is this?
23:43:40 <nullnullnull> Cale, ah no libraries mate ;)
23:43:50 <Cale> nullnullnull: How did you send the variable? I don't understand.
23:44:03 <Cale> Are you using forkIO?
23:44:18 <nullnullnull> from main I received the args like this:   (h:p:t:_) <- getArgs
23:44:23 <Cale> okay
23:44:27 <nullnullnull> and I wanted to send the t arg to thread
23:44:36 <Cale> Is thread just a function?
23:44:51 <nullnullnull> tr=do     stuff
23:45:21 <Cale> Or do you actually want to start a new thread?
23:45:36 <crestfallen> Cale really appreciate it . I have time this week to work hard on this.
23:45:38 <Cale> You can just pass t as an argument.
23:45:40 <nullnullnull> hmm not sure if it's a function but I put this there  threadDelay 20000
23:45:44 <Cale> crestfallen: cool
23:45:57 <crestfallen> many thanks
23:46:31 <Cale> nullnullnull: That's almost no delay at all. The argument to threadDelay is in microseconds
23:46:49 <nullnullnull> 200000
23:47:04 <Cale> okay, that's 1/5 of a second :)
23:47:09 <nullnullnull> oh
23:47:29 <nullnullnull> ok add another 0 :P
23:48:14 <nullnullnull> but the thing is: I'm trying to receive the sent variable from there (I tried like this but didnt work: tr:: t -> Int()
23:49:10 <Cale> Well, t in the land of types will be a type variable
23:49:21 <Cale> and you're saying that tr takes an argument of any type at all, it doesn't care
23:49:31 <nullnullnull> hmm
23:49:40 <Cale> which basically means "I promise not to look at my argument"
23:49:41 <nullnullnull> I want to receive it as integer
23:50:06 <Cale> Right, so you perhaps want tr :: Int -> IO Int
23:50:54 <nullnullnull> "Couldn't match type ‘[Char]’ with ‘Int’"
23:51:05 <nullnullnull> ah I need to convert it
23:51:07 <nullnullnull> to int
23:51:08 <Cale> Okay, well, yeah
23:51:20 <Cale> You can use  n <- readLn t
23:51:28 <Cale> er, sorry
23:51:36 <nullnullnull> I sent it from args (so it's a string)
23:51:44 <Cale> readIO t
23:52:12 <Cale> Or you can just freewheel it and write  tr (read t)
23:52:32 <Cale> (which is similar, but it's harder to catch the exception if the parse fails)
23:52:36 <nullnullnull> hmm
23:52:54 <nullnullnull> like this? tr (read t) :: Int -> IO Int
23:53:06 <Cale> nono, I mean where you're using tr
23:53:35 <Cale> Since tr takes an Int
23:53:44 <Cale> the (read t) will have type Int
23:53:59 <nullnullnull> I have this:   tr=do   ___something__       main=do  ____something____
23:54:10 <Cale> tr should probably have an argument
23:54:25 <Cale> Given that you want to pass it one
23:54:31 <Cale> A parameter, I should say
23:54:38 <Cale> tr t = do ...
23:54:45 <nullnullnull> yeah that's what im trying to do, to give it an argument
23:56:17 <nullnullnull> ok I added tr t=do 
23:56:25 <nullnullnull> I only need to fix the IO() above it
23:57:13 <Cale> ah, if you had tr :: IO () before
23:57:19 <Cale> then probably tr :: Int -> IO ()  now
23:58:45 <nullnullnull> Couldn't match type ‘[Char]’ with ‘Int’     seems like I need to convert it before sending arg?
23:58:55 <nullnullnull> cuz I want it as int
23:59:14 <Cale> yes, that's what you might use read for
23:59:18 <Cale> :t read
23:59:21 <lambdabot> Read a => String -> a
23:59:43 <Cale> It can turn Strings into various other sorts of values, depending on what type of value you need.
