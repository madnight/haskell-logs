01:50:58 * hackage extensible 0.6.1 - Extensible, efficient, optics-friendly data types and effects  https://hackage.haskell.org/package/extensible-0.6.1 (FumiakiKinoshita)
02:30:37 <jgt> in the Esqueleto docs, there are lots of snippets like this: http://ix.io/1Qzg
02:30:48 <jgt> I noticed the code under the `do` is not indented
02:30:58 <jgt> is that valid? Or is that an extension?
02:41:40 <int-e> jgt: ghc has a NondecreasingIndentation extension which it enables by default
02:42:11 <int-e> (it's disabled if you use -XHaskell2010)
02:45:34 <jgt> is it a good idea? Or do you think it's just less clear?
02:50:26 <int-e> I don't like it, though I guess the FFI example at https://prime.haskell.org/wiki/NondecreasingIndentation has some merit. I definitely wouldn't do it at the top level.
02:51:02 <jgt> ok, thanks
03:08:00 <merijn> int-e: you can accomplish the same by wrapping the alloc's in ContT
03:08:20 <merijn> int-e: Then you still avoid the increasing indent and doesn't require an extension
03:31:57 * hackage mbox-utility 0.0.3.1 - List contents of an mbox file containing e-mails  https://hackage.haskell.org/package/mbox-utility-0.0.3.1 (HenningThielemann)
04:14:57 * hackage haskell-gi-base 0.23.0 - Foundation for libraries generated by haskell-gi  https://hackage.haskell.org/package/haskell-gi-base-0.23.0 (inaki)
04:16:57 * hackage haskell-gi 0.23.0 - Generate Haskell bindings for GObject Introspection capable libraries  https://hackage.haskell.org/package/haskell-gi-0.23.0 (inaki)
04:17:57 * hackage gi-atk 2.0.21 - Atk bindings  https://hackage.haskell.org/package/gi-atk-2.0.21 (inaki)
04:18:58 * hackage gi-ggit 1.0.8, gi-gdkx11 3.0.9, gi-gdkpixbuf 2.0.23, gi-gdk 4.0.1, gi-gdk 3.0.22, gi-dbusmenugtk3 0.4.8, gi-dbusmenu 0.4.7, gi-cairo 1.0.23 (inaki)
04:19:58 * hackage gi-gsk 4.0.1, gi-graphene 1.0.1, gi-gobject 2.0.22, gi-glib 2.0.23, gi-girepository 1.0.22, gi-gio 2.0.25 (inaki)
04:20:58 * hackage gi-gtk-hs 0.3.8.0, gi-gtk 4.0.1, gi-gtk 3.0.32, gi-gstvideo 1.0.22, gi-gsttag 1.0.21, gi-gstpbutils 1.0.21, gi-gstbase 1.0.22, gi-gstaudio 1.0.21, gi-gst 1.0.22 (inaki)
04:21:35 <xsperry> hi. what tor library is usually recommended for haskell? I want to grab a couple of web pages through tor
04:21:58 * hackage gi-secret 0.0.11, gi-poppler 0.18.21, gi-pangocairo 1.0.23, gi-pango 1.0.22, gi-ostree 1.0.12, gi-notify 0.7.21, gi-javascriptcore 4.0.21, gi-handy 0.0.6, gi-gtksource 3.0.22 (inaki)
04:22:58 * hackage gi-xlib 2.0.8, gi-wnck 3.0.7, gi-webkit2webextension 4.0.24, gi-webkit2 4.0.25, gi-vte 2.91.25, gi-soup 2.4.22 (inaki)
04:49:57 * hackage monad-validate 1.0.0.0 - A monad transformer for data validation.  https://hackage.haskell.org/package/monad-validate-1.0.0.0 (lexi_lambda)
04:56:25 <reactormonk> xsperry, just set socket settings, and I'd guess your off-the-mill libraries will pick it up - I guess
04:59:13 <reactormonk> Hm, http-client seems to be doing http proxies only
04:59:49 <reactormonk> This one fails with "parse error" on line 11 - https://gist.github.com/reactormonk/1c62b695a61729456c37f107b43f9776 - anyone got a clue as to why? Apparently it worked with an older GHC version
06:03:30 <Eduard_Munteanu> What is diagrams' concept of measurement units for absolute stuff? I want to draw stuff that prints to scale.
06:09:02 <xdxd> @nh2: did you see my reply https://github.com/nh2/static-haskell-nix/issues/39#issuecomment-513516733 ?
06:09:02 <lambdabot> Unknown command, try @list
06:09:49 <nh2> xdxd: had seen it, but just came back from holiday, will try to take a look!
06:10:02 <xdxd> okay :)
06:10:58 <AndreasK> Is there a equivalent of maxBound at the type level?
06:28:27 * hackage reflex-dom-helpers 0.2.0.0 - Html tag helpers for reflex-dom  https://hackage.haskell.org/package/reflex-dom-helpers-0.2.0.0 (Jappie)
06:55:14 <jusss> data Tree a = Leaf a | Node (Tree a) (Tree a)  is this related with Reader Monad?
06:59:54 <int-e> No, except in the usual holistic way (everything is connected to everything else).
07:21:57 * hackage gi-gtkosxapplication 2.0.17 - GtkosxApplication bindings  https://hackage.haskell.org/package/gi-gtkosxapplication-2.0.17 (inaki)
07:29:28 * hackage reflex-dom-helpers 0.2.0.1 - Html tag helpers for reflex-dom  https://hackage.haskell.org/package/reflex-dom-helpers-0.2.0.1 (Jappie)
07:37:57 <oats> jusss: I'm not sure I understand your question, could you rephrase it please?
07:44:29 <infinisil> AndreasK: Got an example?
07:46:09 <AndreasK> infinisil: So what I want to do is pack a bunch of bounded enums into a as few bits as possible. That works already using maxBound. But I wondered if I could lift the size computation into the type system.
07:47:07 <AndreasK> But I'm happy to admit that I have little experience with type level computations. But it would be nice to have a guarantee that it doesn't happen at runtime,
07:50:10 <infinisil> AndreasK: Got an example?
07:50:37 <AndreasK> <<loop>>
07:51:15 <erisco> I am not aware of a ready-to-go type level kind reflection solution, but with some TH you could generate the information
07:56:12 <AndreasK> The goal would be something like `getEnum :: (KnownNat n, Enum a) => Proxy# n -> Bitfield -> a` where n tells us how many bits to take from the bitfield.
07:57:06 <AndreasK> Currently I use bounded instead: `fromBits :: forall a. BoundedEnum a => Bitfield -> a` since maxBound carries that information. And usually that will get specialized and all that by the simplifier. But there is no guarantee
08:00:43 <jusss> oats: is this related to Reader 'cause they both do flattern
08:06:52 <atk> can haskell stop binding me? I feel very pinged.
08:09:27 * hackage arithmetic 1.4 - Natural number arithmetic  https://hackage.haskell.org/package/arithmetic-1.4 (JoeHurd)
08:13:07 <wikiemol> Hello, I am new to Haskell. I am learning by creating a "PitchClass" type as seen here https://pastebin.com/zDpW0Ayv . This works fine (actually fine is an understatement, I am enamored by the power of this). However, I want to create another type "Interval" which represents the musical intervals (kind of like this https://pastebin.com/yZbppv3U). Really, its not really new type, algebraically I want it to behave exactly like
08:13:07 <wikiemol> the PitchClass type, so its more of a new name for the same notes. I want you to be able to add PitchClasses to Intervals. Is there an elegant way to do this in Haskell?
08:15:07 <erisco> wikiemol, yeah, you define a function like  addPitchToInterval :: Pitch -> Interval -> Interval
08:16:18 <erisco> wikiemol, if you were looking for a more sophisticated abstraction then what you have is a vector space
08:16:30 <erisco> pitches are points, and intervals are vectors
08:16:48 <oats> jusss: did you mean "flatten"?
08:17:01 <wikiemol> erisco: Is there any relation to the mathematical vector space?
08:17:15 <erisco> wikiemol, that is the vector space I am referring to
08:17:38 <erisco> well how about an affine space https://hackage.haskell.org/package/vector-space-0.16/docs/Data-AffineSpace.html
08:18:06 <oats> jusss: I'm unable to find any function "flatten" that operates on Readers, if that's what you're referring to
08:18:25 <erisco> this library seems far more popular https://hackage.haskell.org/package/linear-1.20.9/docs/Linear-Affine.html
08:18:28 <wikiemol> erisco: Well my question is, how do you get Interval and PitchClass to behave as the same type
08:18:35 <erisco> you don't
08:19:03 <wikiemol> Here is something I tried https://pastebin.com/W6myU2z3 but it didn't work
08:19:42 <erisco> I am not sure what I am supposed to be looking at in that example. What is it supposed to do and what did it do instead?
08:21:38 <wikiemol> erisco It was supposed to define + and * to take two NoteNames, which is either an Interval or a pitch class, and then convert each one to its int representation, add or multiply mod 12, then convert to the enum that is the first argument.
08:23:06 <wikiemol> So I could write C + IP5 == G and it would evaluate to true
08:23:29 <erisco> that will never happen
08:23:39 <erisco> because + requires the same type for both operands
08:23:56 <wikiemol> :(
08:24:02 <erisco> an affine space however does not require that
08:24:13 <erisco> it makes a distinction of points and vectors
08:24:51 <wikiemol> Hm okay, I will look into that
08:25:34 <erisco> C .+^ IP5 == G   would be true
08:26:13 <erisco> :t \x y -> toEnum ((fromEnum x + fromEnum y) `mod` 12)
08:26:15 <lambdabot> (Enum a1, Enum a2, Enum a3) => a2 -> a3 -> a1
08:27:36 <erisco> You can use  fromEnum (maxBound :: PitchClass)  rather than 12
08:27:50 <wikiemol> Okay cool thanks! That makes sense! 
08:28:10 <wikiemol> Should I have PitchClass be bounded? 
08:28:24 <erisco> that is advisable
08:29:01 <wikiemol> Makes sense
08:29:11 <jusss> oats: my misunderstand
08:33:31 <wikiemol> erisco: Another question, is there a way to take the Num class instance I made for PitchClass and generalize it so I can easily come up with other classes that are similar? Or do I have to copy the instance to each new type? (For example, do I have to copy and paste the instance and change PitchClass to Interval to be able to write `IR + IP5 == IP5`? If I wanted to create a new solfege type `Do | Re | Me | ... `would I have
08:33:31 <wikiemol> to copy it yet again?)
08:35:21 <infinisil> AndreasK: What's BoundedEnum?
08:36:00 <infinisil> AndreasK: No idea how to get what you want though
08:36:23 <erisco> wikiemol, yes, but there may be other definitions you could make.
08:37:02 <erisco> wikiemol, you could, for example, just define mod12 arithmetic, then give different names to each number.
08:37:09 <erisco> Lovelace-style
08:37:30 <wikiemol> Okay, but there isn't an inhouse way to do this?
08:37:41 <erisco> I don't know what you have in your house
08:38:09 <wikiemol> Lol I mean like, there is nothing in the language itself that does this type of thing automagically?
08:40:05 <wikiemol> erisco: Like maybe a way to create my own derivable class or something?
08:41:22 <erisco> This just isn't the way you'd achieve that kind of reusability in Haskell.
08:42:22 <wikiemol> Hm okay
08:55:42 <AndreasK> infinisil: BounedEnum a is just (Bounded a, Enum a)
09:18:37 <srid> How can I tell which version of hspec is included by a certain GHC version?
09:19:37 <glguy> srid: GHC doesn't include hspec
09:32:28 * hackage bulmex 1.0.0 - Reflex infused with bulma (css)  https://hackage.haskell.org/package/bulmex-1.0.0 (Jappie)
10:02:28 * hackage githud 3.0.0 - More efficient replacement to the great git-radar  https://hackage.haskell.org/package/githud-3.0.0 (gbataille)
10:20:25 <EvanR> pitches are not the kind of thing you can add
10:20:48 <EvanR> but you can subtract them to get a difference, which you can add, and add to pitches to get pitches
10:21:06 <EvanR> same as day numbers. day - day = integer, day + integer = day
10:21:15 <EvanR> this isn't captured by Num
10:22:03 <monochrom> This is captured by monoid actions or group actions. >:)
10:23:01 <EvanR> i see the day + integer = day is a group action sort of thing. But the difference?
10:23:44 <EvanR> i still not sure what the go to algebra topic is for that
10:24:17 <d34df00d> Might be group actions as well sorta.
10:24:23 <d34df00d> It's just a different difference.
10:24:38 <d34df00d> (and days don't form a group at all — what does it mean to add two days? I don't want that to  typecheck)
10:24:48 <lavalike> the group is the integers in that case
10:25:10 <d34df00d> So, day - day is an integer such that the action of that integer applied to the second day gives the first one.
10:25:52 <d34df00d> But, yeah, if you just consider days as a set and integers as a group and the action as  the action of integers on the days... That woks.
10:26:02 <d34df00d> Is there a package for that?
10:26:05 <EvanR> day isn't a group, integer is
10:26:39 <EvanR> what is day... baez has a page that calls this a "torsor" but... i haven't seen anyone else call it that
10:27:05 <d34df00d> Torsors are way over my algebra.
10:27:32 <d34df00d> Or actually not... nlab has a better description.
10:28:33 <EvanR> in this situation it turns out you can assign a unique integer to each day and define a corresponding + operation on the days that respects the integer group, but the choice of "zero point" is not unique
10:29:00 <d34df00d> But any such choice is isomorphic to any other, I guess?
10:29:04 <EvanR> yes
10:30:33 <nshepperd> no
10:31:07 <d34df00d> Well, "modulo the zero point".
10:31:19 <nshepperd> if you convert days to integers, add them together, then convert back the result depends on the zero point
10:31:40 <EvanR> the choice of zero point corresponds to the choice of "day group", theres one choice for each integer
10:31:49 <EvanR> you obviously wouldn't convert back using the wrong mapping
10:32:14 <nshepperd> the fact that there is no distinguished unique zero point is why you can't add days together
10:32:54 <wroathe> Anyone know how to get color output with cabal v2-test?
10:33:03 <wroathe> And maybe turn off the cabal chatter around the test output?
10:34:55 <cocreature> wroathe: depends on your test suite, cabal doesn’t actively turn off colors. what it does is redirect the output which causes some test suites to not emit colors. Often there is something like a --color=always option
10:35:33 <nshepperd> Monday + Tuesday = Tuesday if you assign Monday to 0. If you assign Sunday to 0, you get Wednesday instead.
10:35:40 <wroathe> cocreature: Perfect. Thanks!
10:36:15 <cocreature> wroathe: new-run doesn’t redirect the output so if you run your test suite via that you usually get color output
10:37:11 <EvanR>  why would you assign 0 to jan 1 2000 and 0 to jan 2 2000 ... this is not one of the valid "integer like" groups, since it's not even a group
10:37:37 <wroathe> cocreature: Yeah, I actually just discovered that in parallel to you writing that message
10:37:43 <EvanR> i was saying you could do this, i didn't say you should. Abstracting the day by removing + is better
10:40:37 <cocreature> wroathe: might be worth pointing out that new-run and new-test aren’t quite equivalent. in particular, new-run won’t change the working directory to the root of your package which can break things if you rely on things like extra-source-files. but that’s usually fixable by cd’ing to the package root before running new-run
10:41:28 * hackage elm-bridge 0.5.2 - Derive Elm types and Json code from Haskell types, using aeson's options  https://hackage.haskell.org/package/elm-bridge-0.5.2 (SimonMarechal)
10:41:29 <EvanR> i should have said you can define a + on days that preserves ordering 
10:43:06 <wroathe> cocreature: Thanks
10:43:15 <nshepperd> if you assign the unix epoch as 0, adding together Monday and Tuesday gives you Saturday, March 9th 2069
10:50:45 <ski> <https://en.wikipedia.org/wiki/Group_action_(mathematics)> mentions "Regular (or simply transitive or sharply transitive)", also mentioning "torsor"
10:53:16 <EvanR> cool
11:02:28 <sclv> wroathe cocreature there's a --show-details=streaming flag but i don't remember which version of cabal it landed in for v2-test https://github.com/haskell/cabal/issues/4766
11:03:01 <cocreature> sclv: I recall trying it on 2.4 fairly recently and it didn’t work but it worked in HEAD
11:08:45 <SolarAquarion> for some reason my "runhaskell setup copy" is copying nothing
11:19:27 * hackage ft-generator 1.0 - implementation accompanying a WFLP'19 submission  https://hackage.haskell.org/package/ft-generator-1.0 (JanisVoigtlaender)
11:23:58 * hackage bulmex 2.0.0 - Reflex infused with bulma (css)  https://hackage.haskell.org/package/bulmex-2.0.0 (Jappie)
12:19:28 * hackage dependent-sum 0.6 - Dependent sum type  https://hackage.haskell.org/package/dependent-sum-0.6 (abrar)
12:20:28 * hackage dependent-sum-template 0.1.0.0 - Template Haskell code to generate instances of classes in dependent-sum package  https://hackage.haskell.org/package/dependent-sum-template-0.1.0.0 (abrar)
12:29:28 * hackage reflex-vty 0.1.1.0 - Reflex FRP host and widgets for vty applications  https://hackage.haskell.org/package/reflex-vty-0.1.1.0 (abrar)
12:45:03 <turab> I have the following type showing up in a lot of places (with a constraint on type c): (StateT Int (StateT (DList Exp) (State c)) K
12:46:04 <turab> It's difficult to read/write this over and over again, so I thought about making a type synonym but not sure how to deal with the type constraint when making a type synonym
12:46:21 <turab> Is there anything else that can be done?
12:46:45 <bgamari> turab, why is the constraint problematic?
12:47:59 <turab> I tried the following: type AppCPSer = Collector c => StateT Int (StateT (DList Exp) (State c)) K
12:48:09 <dminuoso> Oh yeah that will lead to fun situations. :
12:48:30 <bgamari> indeed
12:48:31 <dminuoso> turab: Make it `type AppCPser c = StateT Int (StateT (DList Exp) (State c)) K`
12:50:07 <nil> is there a standard library function with type  Alternative f => [a] -> f a  that does something like  foldr (<|>) empty . fmap pure  ?
12:51:01 <dminuoso> nil: Is that not just Monoid?
12:51:20 <bgamari> Monoid for Alt
12:51:46 <nil> well that's not a function
12:51:46 <turab> Thanks! That seems to work
12:51:57 <bgamari> but if your type doesn't have a monoid instance or you don't want to use Alt then...
12:51:57 <bgamari> hmm
12:52:52 <bgamari> I don't think there is such a thing, sadly
12:52:56 <bgamari> ahh
12:52:59 <bgamari> nil, msum
12:53:06 <bgamari> and asum
12:53:24 <dminuoso> % :t asum . fmap pure
12:53:24 <yahb> dminuoso: (Foldable t, Alternative f, Functor t) => t a -> f a
12:53:46 <nil> bgamari: that doesn't seem to have the "fmap pure" part
12:54:05 <dminuoso> nil: I dont think that would pass the Fairbairn threshold.
12:54:08 <bgamari> oh, whoops, I had missed that
12:54:22 <dminuoso> nil: Thing is, with that "pure" ontop you're basically just asking for a plain Monoid.
12:54:37 <dminuoso> % :t concat
12:54:38 <yahb> dminuoso: Foldable t => t [a] -> [a]
12:54:48 <nil> dminuoso: i had to google that :) oh well
12:54:48 <dminuoso> Uhh 
12:55:07 <dminuoso> % :t mconcat
12:55:07 <yahb> dminuoso: Monoid a => [a] -> a
13:05:28 * hackage express 0.1.0 - Express  https://hackage.haskell.org/package/express-0.1.0 (rudymatela)
13:22:09 <Synthetica> Hey, I'm using `diagrams`, but I'm getting `No instance for (TrailLike [QDiagram B V2 Double Any])`
13:27:32 <lyxia> Synthetica: can you share your code somewhere?
13:31:17 <Synthetica> lyxia: https://github.com/Synthetica9/picturehanging/blob/master/Draw.hs#L61
13:46:23 <excelsiora> hi!!
13:46:39 <turab> !
13:59:16 * dmwit waves at excelsiora 
13:59:28 <excelsiora> hi
14:13:24 <lyxia> Synthetica: the error message is much more accurate with the monomorphism restriction on.
14:13:34 <Synthetica> lyxia: Yeah, I fixed it
14:14:15 <Synthetica> Turned out I did `[a -> b] <*> a` instead of `[a -> b] <*> [a]`
14:17:58 * hackage speculate 0.4.0 - discovery of properties about Haskell functions  https://hackage.haskell.org/package/speculate-0.4.0 (rudymatela)
14:35:38 <cr3> hi folks, I'm trying to `stack install alex-3.2.3` with lts-9.21 and ghc-8.0.2 on ubuntu but I get a linker errors like stack/snapshots/x86_64-linux/lts-9.21/8.0.2/lib/x86_64-linux-ghc-8.0.2/random-1.1-9tceXaeYIMZ4JrKq20Egog/libHSrandom-1.1-9tceXaeYIMZ4JrKq20Egog.a(Random.o):(.data.rel.ro+0x10b0): undefined reference to `timezm1zi6zi0zi1_DataziTimeziClockziCTimespec_getCTimespec1_closure'
14:36:07 <cr3> the .a file indeed has those symbols as U, undefined, but I don't know what to do about it :(
14:36:18 <shapr> are you able to upgrade to a later version of stack and/or ghc?
14:37:42 <cr3> shapr: I tried 13.15 but other dependencies are not available at all in that stack
14:50:58 * hackage dependent-sum 0.6.1 - Dependent sum type  https://hackage.haskell.org/package/dependent-sum-0.6.1 (abrar)
15:01:57 * hackage sexp-grammar 2.1.0 - Invertible grammar combinators for S-expressions  https://hackage.haskell.org/package/sexp-grammar-2.1.0 (EugeneSmolanka)
15:11:00 <wikiemol> Is there a way to specify which Enum toEnum should return?
15:14:09 <wikiemol> In a pointless way?
15:17:18 <jackdk> % :set -XTypeApplications
15:17:19 <yahb> jackdk: 
15:17:25 <pyan> foo . bar . (toEnum :: Int -> MyEnum) . qux . mux -- ?
15:17:26 <jackdk> % :t toEnum @Bool
15:17:27 <yahb> jackdk: Int -> Bool
15:18:20 <pyan> I guess the syntax with TypeApplications is more pleasant. However, if a function has multiple type parameters, which one should be applied first?
15:20:35 <wikiemol> pyan: Yours makes sense I am too new at Haskell to understand jackdk's
15:22:54 <pinecamp> hello all! I am a new (but courageous) haskeller, trying to write an API client library for a legacy php / ajax API. the client will need to maintain a session, since auth is based on a cookie returned from the login endpoint
15:24:09 <pinecamp> I wasn't quite able to figure out servant's generalized auth, so I switched over to Req, but I'm having trouble figuring out where a Manager fits into things. anyone familiar with one or both of these libraries that I could ask some questions to?
15:24:31 <pyan> wikiemol: In System F and its various extensions (on which Haskell is ultimately based), a parametrically polymorphic value is literally a function that takes a type as argument. So, for instance, “map :: forall a b. (a -> b) -> [a] -> [b]” is a function that takes the type “a” as argument, then returns a function that takes another type “b” as argument, then takes a function of type “a -> b” as argument, and finally returns a function
15:24:31 <pyan> of type “[a] -> [b]” as a result.
15:26:05 <pyan> wikiemol: However, ordinary Haskell makes the application of “map” to the types “a” and “b” implicit, so you can apply “map” directly to the argument of type “a -> b”, since the types “a” and “b” can be inferred from the argument of type “a -> b” anyway.
15:26:30 <pyan> wikiemol: The TypeApplications extension allows you to make explicit these usually implicit type applications.
15:29:52 <jackdk> pinecamp: I haven't used req, but it looks like all a Manager does it track connections so it can reuse kept-alive ones. something like `withReqManager $ \m -> do ...` looks like the easiest way to get one
15:32:09 <wikiemol> pyan: I think I see what you are saying
15:32:16 <wikiemol> Thanks
15:36:23 <pinecamp> jackdk: that makes sense, thanks for explaining. I don't quite understand the `withReqManager` call, though. I see from the type signature that it has a parameter that is a function receiving a Manager and returning a MonadIO; should I look for a function like this in the library, or is it more likely I'd need to create one?
15:36:46 <wikiemol> pyan: Are extensions super important to Haskell? I am starting to hear them pop up a lot even though most (if not all) of the resources I am using to learn Haskell don't mention them
15:37:19 <AndreasK> wikiemol: Yes, but they are nothing fancy.
15:37:26 <AndreasK> Well most are not :)
15:37:35 <pyan> wikiemol: Some extensions are very important for everyday Haskell programming, but I'd bet TypeApplications is not one of them.
15:38:54 <jackdk> pinecamp: No, you'll have to write one. The easiest way to do that is with a lambda like I mentioned above (the `m` argument is the `Manager`). Generally, a `withFoo` function will expect as its argument a function that takes a `Foo` and does something with it, and the `withFoo` function will also handle any setup and teardown for that `Foo`.
15:40:33 <pinecamp> jackdk: ohh, I think I see... so I'm passing it this function of one parameter, to which it will then apply an internally-provided manager?
15:41:36 <jackdk> pinecamp: yes. the result being that you then have a space to work where you have access to the `Manager` from the `req` library.
15:41:55 <jackdk> pinecamp: what other languages do you know? Maybe I can find an analogy
15:42:02 <pinecamp> jackdk: awesome! that's very cool :)
15:42:14 <pinecamp> I'm familiar with Python, Go, and a bit of C#
15:42:58 * hackage extrapolate 0.4.0 - generalize counter-examples of test properties  https://hackage.haskell.org/package/extrapolate-0.4.0 (rudymatela)
15:44:12 <jackdk> pinecamp: so the problem that a `withFoo :: (Foo -> IO a) -> IO a` function solves is a similar problem that python's `with foo as f:` syntax solves. But it does it in a different way, and without having to go through the PEP process to get new syntax approved.
15:44:34 <jackdk> instead, we just take a function as our first argument
15:46:18 <pinecamp> jackdk: that makes total sense! now I've just gotta dig in a bit and figure out how to use the manager it provides :) 
15:47:12 <jackdk> pinecamp: glad to hear it. I need to close irc for a bit, so good luck.
15:47:25 <pinecamp> thanks!
15:55:43 <dmwit> pyan: If there are multiple type parameters, then they are only available for type applications if the type is given by a programmer annotation. Then the order is left-to-right from the annotation.
15:56:53 <dmwit> (In fact, even if there are 0 or 1 type parameters, they are still only available for type application if the type is given by a programmer annotation.)
16:08:59 <pyan> dmwit: Is this left-to-right order determined before or after expanding type synonyms?
16:09:31 <pyan> Actually, please only answer in the “before” case. in the “after” case, a silent answer is better than an explicit one.
16:12:07 <pyan> Ah, thank goodness the answer was really “before”.
16:16:58 * hackage dependent-map 0.3 - Dependent finite maps (partial dependent products)  https://hackage.haskell.org/package/dependent-map-0.3 (abrar)
16:36:16 <dmwit> pyan: I'm not sure! But I bet the documentation has the full details.
16:37:11 <dmwit> If I had to guess, my guess would be that it just traverses the raw parse tree of the type in left-to-right order without doing anything at all fancy.
16:55:01 <lyxia> I think depending on that order is a recipe for disaster. For base we might be stuck with it, but other type-heavy libraries should really fix the order explicitly.
17:19:14 <turab> I am working on a small program where I would like it to use different data structure based on the flags passed to the executable. The plan was that if the flag is not passed, the data structure I passed will not do anything, but if the flag is passed, then I pass in the data structure that does the work I want
17:19:40 <turab> I thought that would work until I got done making changes and encountered the following beauty:
17:19:52 <turab> if defineFree then FAS [] [] else U
17:20:04 <turab> Which ofc doesn't work since the two types are different
17:20:53 <turab> But, I feel like there is a way to do what I am trying to do, not sure how tho
17:22:42 <turab> I think somewhere between my planning, I went back to the OOP mind set
18:29:23 <crestfallen> @let fmap3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d; fmap3 g x y z = pure g <*> x <*> y <*> z
18:29:26 <lambdabot>  Defined.
18:30:01 <crestfallen> how in the holy buddha's mind do I utilize this . anyone thanks
18:30:28 <Cale> How do you make use of fmap3?
18:30:39 <crestfallen> yes thanks
18:30:52 <crestfallen> sorry for my silly preamble
18:31:00 <Cale> We could use it with the list monad to play Mad Libs
18:31:23 <crestfallen> monads come next in my book
18:32:23 <Cale> Basically, it's a way to apply a function to the results of 3 actions.
18:33:11 <Cale> I wouldn't recommend learning Applicative before Monad, since the things which are instances of Applicative but not Monad are few and far between and you almost never have to deal with something in that way.
18:33:33 <lyxia> > fmap3 (\x y z -> x + y + z) (Just a) (Just b) (Just c)
18:33:36 <lambdabot>  Just (a + b + c)
18:33:57 <Cale> > fmap3 (\x y z -> x + y + z) [1,2,3] [40,50,60], [700,800,900]
18:34:00 <lambdabot>  <hint>:1:47: error: parse error on input ‘,’
18:34:03 <Cale> > fmap3 (\x y z -> x + y + z) [1,2,3] [40,50,60] [700,800,900]
18:34:06 <lambdabot>  [741,841,941,751,851,951,761,861,961,742,842,942,752,852,952,762,862,962,743...
18:34:51 <crestfallen> Dr Hutton is known for solid pedagogic methods . oh thanks studying that lyxia Cale 
18:35:15 <Cale> Yeah, I wouldn't agree on this one in particular though
18:36:04 <crestfallen> so the operator (addition) is the same for three variables of the same type...
18:36:49 <jackdk> Cale: interesting you'd say that. I bounced off Monad a few times, but going via Applicative broke it down into manageable steps. It's not a perfect experiment, since that was the time where I actually wrote out all the instances along the way...
18:37:23 <crestfallen> I'll say one thing kind people... I'm gonna learn this stuff if it kills me
18:37:49 <crestfallen> I just had a horrible hour. that wasn't in the introduction :)
18:38:39 <Cale> jackdk: I would suspect it's the instances (and just having examples in general) which helped more than Applicative itself. Understanding the examples is way more important than anything else.
18:39:16 <Cale> The type of (<*>) is a little fancier than (>>=), because it involves an application of the functor to a function type
18:39:20 <Cale> :t (<*>)
18:39:23 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
18:39:26 <Cale> :t (>>=)
18:39:29 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:40:04 <jackdk> I only recently noticed the following teaching pattern which I quite like: 1. present the typeclass. 2. what things have instances? 3. knowing only that we have an instance, what useful things can we say?
18:40:33 <crestfallen> thanks anyway I can run with (\x y z -> x + y + z)  hey can you write any of this stuff in terms of lambda calculus? I still don't understand the first chapter of haskellbook
18:40:44 <crestfallen> but I want to go back to what jackdk just said
18:41:03 <Cale> Maybe even present the instances first, and give the eventual type class methods without talking about the class at first :)
18:41:25 <crestfallen> all the stuff about free and bound variables
18:43:11 <crestfallen> "  it involves an application of the functor to a function type "   so that takes the lambda expression you wrote above Cale and turns it into an Applicative?
18:43:38 <Cale> What lambda expression?
18:44:01 <crestfallen> (\x y z -> x + y + z)
18:44:12 <Cale> Well, first we applied pure to it
18:44:20 <Cale> pure :: a -> f a
18:44:57 <crestfallen> Cale so that is a "computational context" for the expression
18:45:08 <Cale> That's a pretty terrible word for it
18:45:19 <Cale> But yeah, if you prefer to call it that
18:45:21 <crestfallen> oh better than container though?
18:45:31 <crestfallen> I read it, I didn't make it up :)
18:46:09 <crestfallen> so <*> needs to take that functorial , it can't be a "naked" function
18:46:17 <Cale> I mean, "container" can be an okay analogy, but the sorts of "container" we end up dealing with are rather weird.
18:46:37 <Cale> "Computational context" usually doesn't mean anything to anyone starting out though
18:47:02 <Cale> and probably has an even worse chance of being misinterpreted than "container" tbh
18:47:31 <crestfallen> well "computational context" from what I understand is a structure that is more easily stored in memory, because of its inherent structure
18:47:34 <Cale> I like referring to the values being manipulated in these cases as "actions"
18:47:51 <crestfallen> not sure I follow that
18:48:05 <Cale> So, we can describe pure (or return, from Monad) as taking a value, and producing the action which does nothing except to have that value as its result.
18:48:36 <Cale> and (<*>) :: Applicative f => f (a -> b) -> f a -> f b
18:48:55 <Cale> takes an action which produces a function as its result, and an action which produces a potential argument to that function
18:49:10 <crestfallen> yikes
18:49:12 <Cale> and combines them together into an action which does both things and applies the function to the argument
18:49:22 <Cale> in order to produce its result
18:50:31 <crestfallen> ie <*> needs the curried function to be in the form of a functorial already
18:50:51 <Cale> In the case of lists, "performing" or "running" a list, means to pick one element from the list in all possible ways
18:50:59 <Cale> Let's take a look at an example:
18:51:17 <Cale> > [id, (+2), (*2), (^2), (2^)] <*> [5]
18:51:20 <lambdabot>  [5,7,10,25,32]
18:51:30 <Cale> > [id, (+2), (*2), (^2), (2^)] <*> [5, 100]
18:51:33 <lambdabot>  [5,100,7,102,10,200,25,10000,32,1267650600228229401496703205376]
18:52:09 <crestfallen> thanks so in those cases...
18:52:18 <Cale> > [f x | f <- [id, (+2), (*2), (^2), (2^)], x <- [5, 100]]
18:52:21 <lambdabot>  [5,100,7,102,10,200,25,10000,32,1267650600228229401496703205376]
18:52:34 <crestfallen> the list is already in list structure so we don't need pure
18:52:39 <Cale> yeah
18:52:48 <Cale> > pure 5 :: [Integer]
18:52:49 <crestfallen> ok copy that. that is cool
18:52:50 <lambdabot>  [5]
18:53:06 <crestfallen> this is key
18:53:15 <Axman6> > [id, (+2), (*2), (^2), (2^)] <*> [a,b]
18:53:21 <lambdabot>  mueval-core: Time limit exceeded
18:53:26 <Axman6> > [id, (+2), (*2), (^2), (2^)] <*> [a,b] :: [Expr]
18:53:32 <lambdabot>  mueval-core: Time limit exceeded
18:53:34 <Cale> hmm
18:53:39 <crestfallen> perdon?
18:53:42 * Axman6 glares
18:53:45 <Cale> Ohh, (2^)
18:53:53 <Cale> is probably problematic with Expr?
18:53:58 <Axman6> > [id, (+2), (*2), (^2)] <*> [a,b] :: [Expr]
18:54:00 <lambdabot>  [a,b,a + 2,b + 2,a * 2,b * 2,a * a,b * b]
18:54:12 <Cale> yeah, it's actually *performing* the exponentiations :D
18:54:31 <crestfallen> hold on please..
18:54:48 <crestfallen> how do we get that first entry: a,b,a  ?
18:55:01 <Cale> That's the first two entries and part of the third
18:55:47 <Axman6> > map Just $  [id, (+2), (*2), (^2)] <*> [a,b] :: [Maybe Expr]
18:55:51 <lambdabot>  [Just a,Just b,Just (a + 2),Just (b + 2),Just (a * 2),Just (b * 2),Just (a *...
18:55:55 <crestfallen> don't follow that. dang the cafe is closing :(
18:56:06 <crestfallen> keep letting them come! fire when ready!
18:56:32 <lyxia> amazing enthusiasm
18:56:32 <crestfallen> wait the first 2 entries and part of the third? Cale
18:56:43 <Cale> List elements are separated by commas
18:58:16 <crestfallen> thanks kindly I gotta go Cale Axman6 lyxia 
18:58:28 <crestfallen> that is interesting
19:11:11 <turab> What is the simplest way to debug haskell? 
19:11:49 <Axman6> that's an extremely broad question
19:12:11 <jackdk> HHOS: write more precise types and work through the errors
19:12:12 <turab> Sorry. I am thinking of something like Debug.trace, but are there more options
19:12:15 <c_wraith> and so I provide a broad answer: pure functions, test in ghci if you're uncertain
19:12:32 <turab> Trace*
19:12:39 <Axman6> "Thnk very hard", "use the GHCi debugger", "Use Debug.Trace", "Use types that prevent bugs" are just some of the answers
19:12:51 <Axman6> Think*
19:13:29 <turab> Haven't used the GHCi debugger before so I can try that
19:19:42 <dmwit> step 1. cut your input size in half step 2. repeat
19:20:11 <dmwit> by the time you have a 3-byte input that still gets the wrong answer it will be... well, easy is too strong. But a lot easier, anyway.
19:21:42 <lyxia> "+RTS -xc" prints stack traces on every exception thrown https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html#rts-flag--xc
19:27:24 <turab> Whatever is causing this bug is probably something obvious which I am struggling to see rn :/
19:27:32 <turab> Thanks for the suggestions!
19:29:25 <turab> Ah ofc
19:31:38 <turab> I just got lost in my thicc monad stack :)
19:40:48 <turab> @pl \x -> p $ "" ++ x
19:40:48 <lambdabot> p . ([] ++)
19:40:53 <turab> @pl \x -> p $ "txt" ++ x
19:40:54 <lambdabot> p . ("txt" ++)
19:52:54 <turab> Okay, finally I can ask a question that I meant to ask last week. I have the following program:  https://github.com/trajafri/Pref/blob/master/src/CpsApp.hs
19:53:52 <turab> What I wanted to do was have my program decide what data structure to use based on the flags passed to the executable
19:54:49 <turab> However, I can't do that since it won't allow my programs to type check
19:55:31 <turab> So currently, I decide whether I utilize the work done by my data structure depending on the passed flag
19:55:40 <infinisil> turab: How about creating a class for the data structures, abstracting their functionality, then using this class for all your algorithms
19:55:52 <turab> That's basically what I was trying to do
19:56:11 <erisco> foo
19:56:29 <infinisil> Ah, the Collector class?
19:56:31 <turab> Yes
19:56:49 <turab> What I was imagining my self doing was something like the following:
19:57:46 <turab> if defineFree then DataStructure1 else DataStructure2
19:58:09 <turab> I didn't realize my mistake until I actually typed that and realized my mistake
19:58:50 <turab> So, my question is what's the correct way to do this and do I have other options?
19:59:21 <turab> My original motivation to try this change was to somehow bring in type families but I don't think that's necessary here
20:02:12 <infinisil> turab: How about adding a functor for creating the datastructure to the class
20:02:31 <infinisil> Hm that just moves the problem up though..
20:03:29 <infinisil> turab: You could do `if defineFree then doTheThing DataStructure1 else doTheThing DataStructure2`
20:03:40 <turab> Ouu yes
20:03:46 <turab> Wait
20:03:48 <turab> Maybe
20:04:54 <infinisil> turab: Oh, or you can make an existential wrapper for a generic data structure
20:05:06 <infinisil> data TheStructure = forall a . Collector a
20:05:21 <infinisil> I mean `data TheStructure = forall a . TheStructure (Collector a)`
20:05:47 <turab> I think that's kind of what I was looking for :)
20:06:22 <infinisil> Probably :)
20:06:36 <infinisil> turab: Oooor
20:06:59 <turab> I would like to know more ways to achieving this :D
20:07:17 <infinisil> You can make this part of the function signature directly: `doTheThing :: (forall a . Collector a => a) -> Result`
20:07:34 <turab> I was actually going to discuss this some other day since my change took longer than I expected
20:07:44 <dmwit> turab: :t cpser?
20:07:50 <turab> Ah I guess that allows me to play around with ranked 2 types too
20:07:52 <infinisil> (TheStructure from before should be `data TheStructure = forall a . Collector a => TheStructure a` btw)
20:08:23 <turab> cpser :: Collector c => Exp -> State c Exp
20:08:33 <turab> https://github.com/trajafri/Pref/blob/master/src/Transform/CPS.hs
20:08:55 <dmwit> Then I don't understand why there's trouble here. Both collector and defineFreeVar are producing Exps, so why do you say there would be a type error?
20:11:03 <turab> That's because I was being stupid and something like this:
20:11:21 <crestfallen> I wonder if Cale is still on or Axman6 https://paste.ee/p/qNztJ
20:11:35 <crestfallen> and/or lyxia 
20:11:45 <turab> do { let collector = if flag then DS1 else DS2 }
20:12:01 <crestfallen> still don't see what's going on in that paste
20:12:22 <Axman6> > map Just $  [id, (+2), (*2), (^2)] <*> [a,b] :: [Maybe Expr]
20:12:27 <lambdabot>  [Just a,Just b,Just (a + 2),Just (b + 2),Just (a * 2),Just (b * 2),Just (a *...
20:13:05 <dmwit> turab: Hm. Does "I was being stupid" imply "I am no longer being stupid and have solved my problem", or should I talk some more?
20:13:58 * hackage RSolve 2.0.0.0 -   https://hackage.haskell.org/package/RSolve-2.0.0.0 (ice1000)
20:14:05 <turab> I currently have a work around but it doesn't really use two different data strucutres
20:14:35 <dmwit> Okay, I don't really understand why you want to use two different data structures.
20:14:56 <dmwit> I'm also not super certain whether "two different data structures" means "values of two different types" or just "two different values of the same type".
20:16:05 <turab> Let me ask my question in a different way
20:16:05 <dmwit> My current operating assumption is that the thing you don't like about this code is the repeated `intercalate "\n" . map show`. Is that actually the case, or is it something else?
20:16:32 <crestfallen> @let fmap3 :: Applicative f => (a -> b -> c -> d) ->       f a -> f b -> f c -> f d; fmap3 g x y z = pure g <*> x <*> y <*> z
20:16:33 <lambdabot>  .L.hs:179:1: error:
20:16:33 <lambdabot>      Duplicate type signatures for ‘fmap3’
20:16:33 <lambdabot>      at .L.hs:176:1-5
20:16:56 <crestfallen> @let fmapp :: Applicative f => (a -> b -> c -> d) ->       f a -> f b -> f c -> f d; fmap3 g x y z = pure g <*> x <*> y <*> z
20:16:57 <lambdabot>  .L.hs:179:1: error:
20:16:57 <lambdabot>      The type signature for ‘fmapp’ lacks an accompanying binding
20:16:57 <lambdabot>      |
20:17:01 <turab> Lets say I was writing a graph traversal program, but I want to be able to decide whether I should use BFS or DFS based on arguments to an executable
20:17:11 <crestfallen> @let fmapp :: Applicative f => (a -> b -> c -> d) ->       f a -> f b -> f c -> f d; fmapp g x y z = pure g <*> x <*> y <*> z
20:17:12 <lambdabot>  Defined.
20:17:32 <crestfallen> Axman6, that's what I started with .. not sure if you saw that ^
20:17:59 <turab> My inituition is that I will either pass in a queue or a stack
20:18:19 <dmwit> If so... `let {(cspedExps, FAS free _) = ...; freeExps = map defineFreeVar free; definitions = (if defineFree then freeExps else mempty) <> cpsedExps}; writeFile op . unlines . map show $ definitions`
20:18:36 <crestfallen> Axman6, was your example just now essentially the same?
20:21:07 <turab> I will continue this discussion again. I feel sleepy and I would rather ask better questions instead of asking bad ones
20:21:11 <dmwit> (I... wouldn't expect to have to pass a queue or a stack to a search routine. But I'm willing to proceed under the assumption that for some reason the graph library's API has been written to demand this.)
20:22:37 <dmwit> crestfallen: His example was not particularly related to your fmap3 or fmapp.
20:23:36 <Axman6> > map Just $  [(+), (*), (^)] <*> [a,b] <*> [1,2,3] :: [Maybe Expr]
20:23:38 <lambdabot>  [Just (a + 1),Just (a + 2),Just (a + 3),Just (b + 1),Just (b + 2),Just (b + ...
20:23:54 <Axman6> > [(+), (*), (^)] <*> [a,b] <*> [1,2,3] :: [Expr]
20:23:57 <lambdabot>  [a + 1,a + 2,a + 3,b + 1,b + 2,b + 3,a * 1,a * 2,a * 3,b * 1,b * 2,b * 3,a,a...
20:24:06 <turab> dmwit: I see. I think what i am looking for is... how would an experienced haskeller do what I am trying to do
20:25:33 <dmwit> I think you haven't said what you're trying to do yet!
20:25:45 <dmwit> Or, you have, but I don't understand it.
20:26:09 <turab> No I am just kindof exhausted :(
20:26:26 * dmwit nods sympathetically.
20:26:36 <turab> I will definitely talk about this again. Thanks for the feedback so far, I really really appreciate it
20:28:03 <crestfallen> >fmapp  [(+), (*), (^)] <*> [a,b] <*> [1,2,3] :: [Expr]
20:28:21 <crestfallen> > fmapp  [(+), (*), (^)] <*> [a,b] <*> [1,2,3] :: [Expr]
20:28:23 <lambdabot>  error:
20:28:23 <lambdabot>      • Couldn't match expected type ‘[Expr -> Integer -> Expr]’
20:28:23 <lambdabot>                    with actual type ‘f0 a0 -> f0 b0 -> f0 c0 -> f0 d0’
20:29:16 <crestfallen> I don't understand this then
20:30:31 <crestfallen> > [(+), (*), (^)] <*> [a,b] <*> [1,2,3] :: [Expr]
20:30:34 <lambdabot>  [a + 1,a + 2,a + 3,b + 1,b + 2,b + 3,a * 1,a * 2,a * 3,b * 1,b * 2,b * 3,a,a...
20:31:40 <crestfallen> > pure (+), (*), (^)
20:31:42 <lambdabot>  <hint>:1:9: error: parse error on input ‘,’
20:32:05 <crestfallen> > pure ((+) (*) (^))
20:32:08 <lambdabot>  error:
20:32:09 <lambdabot>      • Ambiguous type variable ‘f0’ arising from a use of ‘show_M588739310295...
20:32:09 <lambdabot>        prevents the constraint ‘(Show
20:32:31 <crestfallen> > pure [(+), (*), (^)]
20:32:34 <lambdabot>  error:
20:32:34 <lambdabot>      • Ambiguous type variable ‘f0’ arising from a use of ‘show_M139633020093...
20:32:34 <lambdabot>        prevents the constraint ‘(Show
20:33:32 <crestfallen> Axman6, how do you use fmapp with your example?
20:33:51 <dmwit> You don't.
20:33:55 <crestfallen> if the functions are not in a list
20:37:14 <crestfallen> dmwit, but what was he trying to show Me?
20:37:55 <dmwit> I suspect he was trying to add enough "stuff" to the result to clear up whatever confusion it was that led you to believe that "a,b,a" was a single result in an earlier query.
20:38:24 <dmwit> From your previous visit to #haskell.
20:38:51 <crestfallen> yeah sorry I was rushing in a cafe that was closing so I'm a bit stumped
20:39:23 <fog> i was a bit worried about the idea of backpack being used to "rip off" other peoples software. i guess that if the software isnt proprietary its ok right?
20:39:47 <Axman6> > fmapp (\x y z -> x * y + x) (Just 10) (Just 3) (Just 7)
20:39:49 <lambdabot>  Just 40
20:39:50 <dmwit> What the heck? How could backpack be at all to blame for something like that?
20:40:03 <Axman6> wait what?
20:40:12 <MarcelineVQ> fog: if that's not bait it's something special, what makes you ask this?
20:40:31 <Axman6> o.O
20:40:36 <dmwit> Axman6: (Perhaps you meant ...+z instead of ...+x ?)
20:40:47 <Axman6> > fmapp (\x y z -> x * y + z) (Just 10) (Just 3) (Just 7)
20:40:50 <lambdabot>  Just 37
20:40:56 <fog> like, if i use matlab algorithms as a guideline for a haskell implementation (swapping out using FFI and backpack tool being developed) matlab doesnt *own* the *algorithms* do they? like, when they charge users its for support and the interface which then shouldnt be ripped  
20:41:13 <Axman6> > fmapp (\x y z -> x * y + z) [10,100,1000] [3,4,5] [7,8,9]
20:41:16 <lambdabot>  [37,38,39,47,48,49,57,58,59,307,308,309,407,408,409,507,508,509,3007,3008,30...
20:41:37 <Axman6> fog: what are you talking about
20:41:39 <dmwit> Presumably you would consult the license for whatever algorithm you're looking at. This is true no matter how you were planning to reproduce that algorithm, with backpack or otherwise. It's completely orthogonal.
20:41:43 <MarcelineVQ> backpack is for writing your code generically over haskell libraries
20:41:59 <fog> well the algorithms are just maths
20:42:08 <MarcelineVQ> if some given library is violating something that's nothing to do with backpack
20:42:14 <fog> so it kind of defines some kind of "commons"
20:42:17 <dmwit> It turns out that "just maths" can still be copyrighted. That is a fact about our world.
20:42:34 <fog> but if its published or has long open source history
20:42:47 <fog> like, standard linear algebra... 
20:43:12 <dmwit> "Open source" does not save you. However, "free" (not "gratis") can save you. But the difference between "open source" and "free" is in the license.
20:43:25 <crestfallen>  > fmapp (\x y z -> x * y + z) (Just 10) (Just 3) (Just 7)
20:43:27 <fog> i dont know about matlab actually paying royalties to anyone, so i guess they *only* use this kind of maths...
20:43:59 <crestfallen> > fmapp (\x y z -> x * y + z) (Just 10) (Just 3) (Just 7)
20:44:04 <lambdabot>  Just 37
20:44:15 <fog> dmwit: but maths algorithms dont have a licence, often they can be algebraically derived from optimality criteria 
20:44:22 <dmwit> 1. I reject the assumption that if the folks that matlab were paying royalties to someone, you would definitely know about it. 2. I don't see how it's relevant anyway, and I'm starting to lose the thread of what you're asking and how it's related to Haskell.
20:44:47 <fog> ok
20:44:56 <Axman6> I ask again, what are you on about fog
20:44:59 <dmwit> The categorical statement "maths algorithms don't have a licence" is, frankly, wrong.
20:45:30 <Axman6> there's a lot of premises missing from your questions, and seemingly a fundamental lack of understanding of I'm not sure what
20:45:30 <fog> its about developing the haskell mixins FFI tool that would basically be to facilitate ripping off other epoples software and i really want to make sure there is a legitimate use for it which does not violate copyright law
20:45:54 <fog> i could describe that tool more if it was sure it was a good idea...
20:46:06 <dmwit> Certainly there is a legitimate use that does not violate copyright law: when the license for the thing you are "ripping off" is sufficiently free.
20:46:08 <Axman6> fog: have you ever written software?
20:46:36 <fog> not published with a licence and revenue
20:46:41 <dmwit> Or when, for example, you have paid whatever licensing fee is needed in case the license is both not free and not gratis.
20:46:55 <Axman6> languages have had foreign function interfaces for decades - backpack has nothing to do with this. Licensing is what differentiates between "ripping off" and having permission to use other people's software
20:47:47 <fog> dmwit: ok, so then the real question is specifically about matlab which i know is liscenced but i know incorperates linear algorithms which are specifically the thing i want to translate to haskell
20:48:07 <dmwit> Perhaps you should speak with an actual lawyer.
20:48:09 <Axman6> Also, linking to someone's else's code does not have anything to do with copyright - publishing it and claiming it as your own may but that's different
20:48:33 <Axman6> we already have linear algebra libraries in Haskell
20:48:45 <fog> Axman6: backpack was just for "swapping" the backend between the actual code (via FFI) and the haskell implementation being developed for use with quickcheck 
20:48:49 <Axman6> that make use of stanrd interfaces like blas and lapack
20:49:08 <Axman6> standard*
20:50:04 <dmwit> Now I have twice as many questions. For example: why wouldn't you be able to use the actual code with quickcheck?
20:50:04 <Axman6> some implementations of blas and lapack are proprietary and require a license to use (like Intel's MKL), but there are also open source implementations like OpenBLAS and a plethora of others
20:50:44 <fog> im assuming there are algorithms implemented in matlab and nowhere else, by people employed by the company and specifically licensed and that copying them would be tantamount to theft, but that also if it can be deemed that the algorithms is "commons" then it is safe to directly translate without reference
20:50:50 <crestfallen> > [id, (+2), (*2), (^2)] <*> [a,b] :: [Expr]
20:50:53 <lambdabot>  [a,b,a + 2,b + 2,a * 2,b * 2,a * a,b * b]
20:51:20 <fog> dmwit: quickcheck was for both backpack signature implementations
20:51:29 <crestfallen> dmwit sorry to bother you .. a,b,a  comes from what exactly?
20:51:34 <dmwit> I think you are assuming too many things, and should speak with a lawyer, who will be able to set you straight on the actual facts of how matlab's license works.
20:51:50 <fog> i have
20:52:03 <Axman6> crestfallen: there're from a package that lambdabot has imported, I can't remember which package it is though
20:52:03 <MarcelineVQ> crestfallen: not a,b,a a,b and a + 2, b + 2 etc
20:52:04 <dmwit> crestfallen: "a,b,a" is not a chunk. "a" is a chunk. "b" is a chunk. "a + 2" is a chunk.
20:52:04 <fog> not about this, but its on legal advice that i suppose what i do
20:52:22 <fog> i know *basically* how this stuff works
20:52:30 <dmwit> crestfallen: These chunks are separated by commas, because that is the Haskell syntax for lists: square brackets around the whole list, commas between list elements.
20:52:48 <Axman6> > a:b:c:[]
20:52:51 <lambdabot>  [a,b,c]
20:53:05 <Axman6> that is a list with three elements, a, b and c
20:53:14 <Axman6> > a:b:c:a+2:[]
20:53:16 <lambdabot>  [a,b,c,a + 2]
20:53:38 <Axman6> that is a list with four elements, a, b, c and a + 2
20:53:52 <fog> and its pretty straitforward. they down *own* matrix multiplication, yet it forms part of their code, and copying their implementation would be just fine, but if there is a sophisticated proprietary implementation they distribute, translating it would not be ok - by definition of its being proprietary. thats all that a lawyer could say
20:54:21 <crestfallen> Axman6, dmwit thanks kindly I'll get it when I'm fresh in the morning. pax
20:54:31 <MarcelineVQ> fog: what else do you need to hear?
20:54:46 <dmwit> That's... not even right.
20:54:54 <dmwit> Copying their implementation may not be fine.
20:54:57 <MarcelineVQ> "and copying their implementation would be just fine" sounds a bit spicy
20:55:09 <Axman6> yeah that's definitely not correct
20:55:09 <MarcelineVQ> a hot take, as the kids say
20:55:15 <dmwit> (N.B. Writing your own implementation, and then discovering later that it turns out to be identical to theirs, *might* be fine depending!)
20:55:27 <Axman6> unless there are patents
20:55:36 <dmwit> As I said: depending.
20:57:36 <crestfallen> ok duh yeah I see it thanks again
20:57:46 <fog> ok so two threads just emerged. MarcelineVQ asks why consider this, and is it a question. basically the motivation is just that i would feel more comfortable discussing the development of tools that *could* be misused to directly translate proprietary code if its established to a reasonable extent that there is a legitimate use for the tool so that
20:57:47 <fog>  it is not being developed dubiously
20:57:52 <Axman6> fog: can you give any more details about what in particular in matlab you're interested in?
20:58:09 <fog> then there is a question about copying an implementation of a "commons" algorithm... 
20:58:26 <dmwit> But backpack doesn't even help with this process of copying!
20:58:47 <dmwit> So for the purposes of "should I be ethically ok with helping develop backpack" who gives a flying... ?
20:58:50 <MarcelineVQ> No I'm asking what else you need to know if a lawyer has layed it out
20:59:04 <Axman6> I'd be pretty surprised if there were a need to copy anything to be honest, if the problem is just linear algebra algorithms - use an existing, appropriately licensed implementation
20:59:11 <fog> sure it does! being able to develop this comparison quickcheck of variable backpack signature implementations is the whole tool
20:59:47 <Axman6> you definitely don't need backpack for this btw
21:00:11 <Axman6> even if you want to compare two imeplementations of the same thing, where one is in Haskell and another is calling the FFI
21:00:31 <Axman6> records of functions give you this, so do type classes
21:00:41 <fog> well no backpack is like a class! you could say someone would use a function to do wrong by that logic... thats taking it too far, we are specifically talking about a tool designed to ease the direct translation of code, which *is* at least possibly contentious  
21:01:17 <Axman6> I still have no idea what you're talking about then
21:01:19 <fog> Axman6: the comparison between classes records and backpack signatures has been discussed and there is utility of backpack
21:01:19 <maerwald> when you change a file that is listed in extra-source-files cabal does not rebuild the modules that use TH to include it seems
21:01:30 <Axman6> of course there is
21:02:20 <fog> Axman6: sorry that was in response to dmwits comment about if backpack itself could be considered a tool specifically for translation, to which the answer is no
21:02:21 <Axman6> maerwald: I think there's a way in TH to specify that its result depends on another file. I'm like 80% sure I didn't just imagine that
21:03:33 <fog> i guess thats the simplest hypothetical realisation - literally just a drag and drop C to haskell translator. and sure, that could be deemed dubious because of the ease that it facilitates copyright infringement. 
21:04:11 <maerwald> Axman6: and what would that be?
21:05:13 <fog> but anyway, that would be down to the user, and then the point is that as both the user and developer of a less extreme (and less useful!) version of this (a kind of assistant for human translation) with the intent to use it on matlab - which is liscenced, the question really is about which parts of matlab i can translate
21:05:28 <fog> then you can observe the existence of an open source version called octave
21:05:54 <fog> and make a similar comparison between openoffice and microsoft word - ie they dont *own* the idea of a word processor 
21:06:15 <dmwit> I don't get it. Backpack presumably would let you easily switch between a translation and an original. But it wouldn't help you create the translation in the first place.
21:06:29 <Axman6> I think deciding that you are going to translate matlab as a starting point is likely to get you into trouble
21:06:32 <fog> i want to emulate matlab functionality in haskell - so i think the parts i would be copying do not strey into their property 
21:07:04 <fog> as this is basically just a convinient language syntax built around common maths
21:07:23 <Axman6> then copy the maths
21:07:27 <fog> its precisely because of its common nature that it is desirable to copy
21:07:49 <fog> yeah, i would, by running a tool over the matlab code that implemented it to use it as a standard
21:08:05 <fog> ensuring it didnt accidentally rip off their aerospace packages...
21:08:56 <fog> anyway, its not just matrix multiplication, its specifically some tools for greedy sparse optimisation i want to implement from papers
21:09:18 <fog> there are standard references for how to implement SVD for example, but it might be easier to just copy the matlab code
21:09:26 <fog> its easier to read than the fortran blas...
21:10:12 <Axman6> I don't think the translation from the papers into Haskell should be too difficult, I've done that plenty of times
21:10:14 <fog> so thats a good example, i can be sure they down own SVD
21:10:41 <fog> Axman6: certainly more work than a semi-automated translator from an existing implementation
21:11:24 <fog> do i have to *copy* from an open source implementation?
21:11:45 <fog> i guess thats the point that was raised before
21:11:59 <fog> about *their implementation* 
21:12:54 <fog> i think the idea is that as long as there is no *novelty* to their implementation then they cant claim ownership
21:14:48 <fog> like, if you gain nothing from the readability (it being written in matlab and not fortran not being a property of the implementation itself - like they still multiply everything together in the same order, even if it has nicer syntax) in terms of implementation details, then i think its ok
21:17:04 <fog> so with that, it establishes a reasonable good faith intention, and i think it could be ok to copy their SVD implementation  
21:17:29 <Axman6> They can claim copyright, and copying from their implementation would probably violate their copyright. copying from a publicly available source may not vialoate any copyright, and academic papers are usually a pretty good source. IANAL though (despite being a former patent examiner)
21:17:38 <dmwit> I have never seen a license that had a "good faith intention" clause in it.
21:18:03 <fog> well it helps if your not going out of your way to put someone out of business and taking care not to!
21:18:11 <Axman6> "I think it's ok" and "it's legal" are very different things
21:18:28 <Axman6> that's irrelevant
21:18:32 <dmwit> It may help with them not caring to enforce the law. It does not help make the thing you're doing legal.
21:19:02 <dmwit> And even then, I only say it *may* help. It may not. Is that a risk you're into?
21:19:08 <fog> compared to copying the algorithm i need, a project like Octave which is more or less a whole sale rip off is way more contentious and establishes  a precedent as far as i can tell
21:20:34 <Axman6> "But but but, they did something I think is worse" is not a good defence...
21:20:59 <fog> like, clearly a matlab torrent with fake licence number is illegal, and anyone using such a thing is blatantly aware of that - but using octave, or eg open office, i dont think the same applies. the proprietary aspect is more to do with support, active development, being bug0free etc
21:21:16 <dmwit> Indeed. Even "but but but, they did something I think is more illegal" is not a good defense.
21:21:36 <dmwit> And I don't think you have grasped the law well enough to judge whether what the octave developers did was illegal or not.
21:21:49 <Axman6> your views on the law sound very disconnected from the realities of the law
21:22:18 <Axman6> Pro tip: what Octave have done is almost certainly not illegal
21:22:43 <fog> Axman6 in an open source software community, tools like open office set a widely held understanding as what constitutes fair practice. i dont think Apache, as microsoft *competitors* that decided to open-source their code, could be seen as violating any part of the law. 
21:22:52 <chew2> hello, I was reading https://en.wikibooks.org/w/index.php?title=Haskell/Denotational_semantics&stable=1#Partial_Functions_and_the_Semantic_Approximation_Order and I was wondering why it's not the case that 1 ⊑ 2 and 2 ⊑ 1. Are these numbers not the same in informational quantity as the article says?
21:23:50 <fog> but then maybe if they were reading directly from microsoft-word source code during development that wouldnt be the case...
21:24:04 <fog> but thats not matrix multiplication...
21:24:44 <Axman6> that would almost cvertainly be copyright infringement, so may be illegal. 
21:24:54 <dmwit> chew2: I find the sentence that includes "equal in terms of information quantity" highly suspect, and to have a dangling pointer (what is the "this" in "a quick way to remember this"?). I would ignore that entire sentence if I were you.
21:24:56 <fog> this is a special consideration concerning mathmatically established syntax and algorithms that matlab cant just suddenly acquire from established commons, and the law supports that 
21:25:10 <fog> so its a case of using that to fight the other thing and seeing where is the lne
21:25:54 <Axman6> reading matlab's implementation of implementing it would also be the same, and liklely violates the license you have with matlab. reading from a publicly available paper something which doesn't have any other protections would probably be ok though
21:26:25 <dmwit> chew2: The one that says "Here, a [ b denotes that b is more defined than a. Likewise, a [= b will denote that either b is more defined than a or both are equal." is much better.
21:26:49 <fog> then, there is defiantly the case of intentions, being reasonably well convinced by justifiable logic, combined with playing it safe, i dont think there could be any cause for concern.
21:26:50 <dmwit> chew2: Since 1 and 2 are not equal, and 1 is not more defined than 2, we don't have 1 [= 2.
21:27:22 <chew2> dmwit: 1 is not more defined than 2 and 2 is not more defined than 1, so they are equally defined right?
21:27:28 * hackage monoidal-containers 0.5.0.1 - Containers with monoidal accumulation  https://hackage.haskell.org/package/monoidal-containers-0.5.0.1 (abrar)
21:27:32 <Axman6> the law is all about intentions - and I'd warn you that this channel is public, and probably recorded, so your intentions are publicly known
21:27:33 <dmwit> chew2: That does not follow, no.
21:27:35 <fog> Axman6: what about plugging both into quickcheck and using it as a black box to test functionality?
21:27:48 <Cale> chew2: They're incomparable in the definedness order.
21:28:04 <chew2> oh interesting
21:28:09 <Cale> (it's not a total ordering)
21:28:13 <Axman6> fog: that depends on what you license for matlab says
21:28:15 <Axman6> your*
21:28:31 <Cale> chew2: If we use something like [Bool] as an example
21:28:36 <dmwit> chew2: Maybe there's some sensible meaning of "equally defined" for which 1 and 2 are equally defined. But it does not follow from "a is not more defined than b" and "b is not more defined than a" that "a is equally defined to b".
21:28:57 <fog> so if i do a matrix inversion with matlab and use that to check if my implementation is correct i could be breaking the law?
21:29:01 <fog> doesnt sound right to me
21:29:06 <Cale> _|_ (a value which represents a nonterminating computation) is at the bottom of the order, and then immediately above it are [] and _|_ : _|_
21:29:15 <Cale> (which are incomparable)
21:29:17 <dmwit> chew2: And moreover [= is not defined to be "less defined than or equally defined as", it is defined to be "less defined than or *equal to*".
21:29:37 <Axman6> Is (),_) more defined than (_,())? (where _ means not defined)
21:29:40 <dmwit> fog: That is probably not breaking the law.
21:30:00 <Cale> and then above _|_ : _|_ lies (False : _|_), (True : _|_), (_|_ : []) and (_|_ : (_|_ : _|_))
21:30:18 <chew2> ok this is starting to make more sense
21:30:19 <dmwit> fog: But that's also not what Axman6 said.
21:30:24 <chew2> thanks both of you
21:30:30 <dmwit> fog: What he said is that whether it's illegal or not depends on what your license for Matlab says.
21:30:53 <fog> right, but taking their hyper advanced fluid simulations and doing black box system identification on them is pretty much as blatantly intrusive as you could get. so its literally about where the boundary is on what can reasonably be  considered as commons
21:31:26 <Cale> chew2: And when it comes to function types, you have that f <= g when f x <= g x for every x. (There is a little extra weirdness in Haskell's case because of seq, but I'll ignore that for now)
21:31:38 <Axman6> I was talking about copying matlab's implementation, not using it
21:31:50 <dmwit> Black-box observations of their fluid simulations is not as intrusive as *I* could get. And what's more, even if it were, it does not follow that the boundary is on what can reasonably be considered as commons.
21:32:02 <fog> well, regardless of the process of how this reverse engineering is done...
21:32:25 <fog> if its reverse engineering matrix vector multiplication, im sure thats fine
21:32:31 <chew2> cale: interesting!
21:32:32 <Cale> chew2: an important property of Haskell-definable functions is that they are monotone, i.e. when x <= y in the definedness ordering, then f x <= f y
21:32:42 <Axman6> if you have a license for matlab, and that allows you to call matlab from other software, then there is no problem
21:32:42 <dmwit> fog: You seem to be sure of a great many incorrect things.
21:32:53 <fog> its commons! 
21:32:55 <fog> thats a thing
21:32:57 * Axman6 strongly agrees with dmwit
21:33:59 <fog> they cant encroach onto commons. they cant just steal math syntax and algorithms. what they can own and what they cant is a thing that can be established - that is for certain
21:34:24 <Axman6> what they do own is their software
21:34:36 <fog> what does that prove?
21:34:47 <fog> a very pessimistic bound...
21:35:22 <fog> i think the arguments given are those relavent and establish a much better idea about where this boundary is
21:35:38 <dmwit> fog: I think you should take a read of https://ansuz.sooke.bc.ca/entry/23
21:36:19 <fog> im not sure if your trying to be constructive
21:36:36 <dmwit> I am.
21:37:29 <Axman6> it means that copying their software would likely be copyright infringement. copying an implementation which is not theirs (such as matlab code written by someone else, which has explicitly made it available in a way which doesn't restrict the use by others) would not be. translating the algorithm from say an academic paper would also likely be ok, if there are not other mechanisms which restrict the use of that algorithms, specifically paten
21:37:30 <Axman6> ts
21:38:46 <dmwit> You keep saying that the method that you use to build your thing doesn't matter because it's common math. But that is not how the law sees it.
21:38:52 <dmwit> The method you use to create a thing *matters*.
21:39:11 <dmwit> If the method you used to create it was "I read a publically-available paper, and then sat down and wrote some code", that is fine.
21:39:39 <dmwit> If the method you used to create it was "I got my hands on a copy of matlab's source code, and stared at it in one window as I typed into another", that isn't.
21:39:50 <dmwit> Even if the two methods produce *the exact same result*, one is okay and the other isn't.
21:40:31 <alexfmpe[m]> huuuh the `sbv` repo is gone?
21:40:49 <alexfmpe[m]> http://hackage.haskell.org/package/sbv points to 404-ing https://github.com/LeventErkok/sbv
21:42:00 <dmwit> (And this is a point that is repeatedly hammered home in the linked article on Colour.)
21:42:07 <ski> maybe <https://github.com/LeventErkok/sbvPlugin> ?
21:42:37 <dmwit> I don't think so, no.
21:42:47 <dmwit> The repo really has disappeared. It is a bit mysterious, definitely.
21:52:56 <fog> dmwit: i agree, the legal argument is about establishing it as commons
21:53:03 <dmwit> No!
21:53:10 <dmwit> Commons or not doesn't matter.
21:54:06 <dmwit> That is again misunderstanding that it is only the *product* that matters. But both the product *and the method used to create the product* matter.
21:54:22 <fog> its confused because its part human part machine, so the human aspect of understanding enters. eg "i knew what vectors were all along, i didnt glean that by detailed study of the matlab code"
21:54:44 <fog> thats what commons is - you are aware of its specification by its existence in commons
21:56:12 <fog> so if the matlab code says, truncate the principal eigenvalues, and you understand what that means, matlab having devised a language as close to human readable as possible *precisely because of the existence of mathematical syntax in commons* renders it non-proprietary.
21:57:43 <fog> also, there are 2 different aspects, one is to do with using their implementation to understand an algorithm, the other is to do with using their implementation to check a result
21:59:52 <fog> also, I can be specific about the algorithm details, so as to confirm they are part of common knowledge, for instance the intuitive notion of gradient descent, where the notion of the path taken by water to find the quickest way downhill is commons 
22:00:39 <fog> i guess then the central issue is would you have known how to implement that without reading the matlab code...
22:01:19 <fog> where then the nature of the tool being developed as a quickcheck comparison facilitator and not a direct translator is the key distinction 
22:02:23 <fog> the copying from one window to another is basically a machine assisted translation - which i think we agree is where run into difficulty. 
22:02:53 <fog> which is good because i really dont like writing or using parsers.. 
22:03:15 <fog> the tool of "swapping the backpacks" just allows the user to compare implementations
22:03:38 <fog> if they produce their implementation by copying directly then that is their fault not that of the tool
22:04:01 <fog> so i can safely develop a comparison assistant  
22:06:26 <fog> ah right, that was the point, its about being able to segment an implementation 
22:07:06 <fog> so you take the backpack and FFI quickcheck comparison over smaller and smaller chunks of code, and that *results in* a translation tool (bad)
22:09:05 <fog> so you have to do it in a fairly zoomed out way over parts which are indistinguishable from common implementations to avoid probing too deeply into their implementation. the task then is identifying blocks of code which can be emulated without encroaching on their copyright. again, like i can test a matrix inversion, but i cant test each function c
22:09:06 <fog> all of an aerofoil optimiser  
22:10:12 <fog> it was because of that possibility that i was worried
22:10:35 <fog> and i think thats the reassuring conclusion. 
22:12:25 <fog> it should be possible to compare the outputs in a non-invasive way, by taking sufficiently coarse blocks consisting only of common component functions code that are composed together in a way which is not novel.
22:23:59 <crestfallen> @let f = map Just $ [(+), (*), (^)] <*> [a,b] <*> [1,2,3] :: [Maybe Expr]
22:24:04 <lambdabot>  Defined.
22:24:17 <crestfallen> > f
22:24:20 <lambdabot>  error:
22:24:20 <lambdabot>      Ambiguous occurrence ‘f’
22:24:20 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.f’,
22:24:33 <crestfallen> @let ff = map Just $ [(+), (*), (^)] <*> [a,b] <*> [1,2,3] :: [Maybe Expr]
22:24:36 <lambdabot>  Defined.
22:24:38 <crestfallen> ff
22:24:47 <crestfallen> > ff
22:24:51 <lambdabot>  [Just (a + 1),Just (a + 2),Just (a + 3),Just (b + 1),Just (b + 2),Just (b + ...
22:25:55 <crestfallen> sorry in ghci I get error: Not in scope: type constructor or class 'Expr'
22:26:02 <hask-bry> I want to fix a broken link on wiki.haskell.com but my account is non-existent now. last time I used it was to update the haskell.org home page 7~ yrs ago.. did accounts get wiped at some point?
22:26:14 <crestfallen> when I run the above
22:26:41 <Cale> crestfallen: That's from the simplereflect package iirc.
22:27:10 <MarcelineVQ> yes https://hackage.haskell.org/package/simple-reflect
22:27:21 <crestfallen> ok thanks Cale MarcelineVQ checking it..
22:27:21 <Cale> hask-bry: You mean .org?
22:27:44 <hask-bry> Cale: yes.
22:27:44 <Cale> hask-bry: My account still seems to exist...
22:28:18 <hask-bry> does the wiki and the old wiki and www share the same user db?
22:28:50 <Cale> There was a moinmoin wiki that had different user accounts, but I'm pretty sure that was over 7 years ago
22:29:34 <Cale> yeah, I put my license text on my user page in 2006, so the moinmoin wiki would have been just before that
22:30:37 <crestfallen> I tried import Debug.SimpleReflect.Expr and import Debug.SimpleReflect   ..  do I install those via cabal?
22:30:49 <hask-bry> Cale: ahh.. i'll just create a new account might be faster than trying to figure out which user/email I used.. my password file says one thing but the error I'm getting says another.. THanks!
22:33:19 <Cale> crestfallen: Yeah, you need to be in an environment where the simple-reflect package is installed in order to have those modules
22:34:46 <Cale> crestfallen: if you're using nix, you can use  nix-shell -p 'haskellPackages.ghcWithPackages (pkgs: with pkgs; [ simple-reflect ])'   to enter a temporary shell in which you have a GHC with that package installed (I recommend making that into a shell script or alias of some sort)
22:35:20 <hask-bry> Cale: It looks like the wiki is closed for registration? If this is the case, to who should I contact for permissions?
22:35:28 <Cale> If not, you can install it with cabal install simple-reflect -- though you might want to set up a sandbox for that.
22:36:37 <sclv> hask-bry: the reg page gives the email address
22:36:58 <Cale> (or the login page)
22:37:35 <hask-bry> NOTE: Automatic wiki account creation has been disabled. If you would like an account please email "wiki-account-request" (at the domain haskell dot org) or, if you find that unresponsive, on the haskell-cafe mailing list.
22:37:39 <hask-bry> I got my answer :)
22:38:20 <hask-bry> such a small fix, i'll probably end up forgetting about this once granted in a few days.. :(
22:38:27 <crestfallen> Cale just saw above. thanks working..
22:38:56 <Cale> hask-bry: I can get it if you want
22:39:27 * hackage witherable 0.3.2 - filterable traversable  https://hackage.haskell.org/package/witherable-0.3.2 (FumiakiKinoshita)
22:39:43 <hask-bry> Cale: sure.. i'll explain shortly
22:40:38 <crestfallen> quick way to set up a sandbox? you mean in ghci right?
22:40:55 <Cale> I mean a cabal sandbox...
22:41:54 <Cale> cabal sandbox init
22:42:00 <Cale> from a new directory
22:42:15 <crestfallen> ok trying thank you
22:42:20 <Cale> and then cabal install simple-reflect will just install the package into the sandbox in that directory
22:42:28 <crestfallen> cool
22:43:04 <Cale> and then you can  cabal repl  to get a ghci which uses the sandbox
22:43:19 <crestfallen> very cool
22:44:10 <Cale> There will be lots of warnings about how these are v1 commands, but they're convenient for this kind of trying out packages anyway.
22:44:39 <Cale> (I don't know why there's not a new version of this, or if there is, why it's not so obvious)
22:45:35 <hask-bry> Cale: https://pastebin.com/P5uY4iNi
22:48:09 <Cale> done
22:48:14 <crestfallen> Cale warnings pertaining to me?
22:48:24 <Cale> crestfallen: You can ignore them
22:48:46 <crestfallen> no warnings, got everything to work but still doesn't have Expr in scope Cale
22:49:10 <Cale> okay, so you installed simple-reflect into the sandbox and it succeeded? Try cabal repl
22:49:24 <Cale> and see if that makes  import Debug.SimpleReflect  possible
22:49:31 <crestfallen> tried it I have a ghci
22:49:42 <Cale> Haha, that social network diagram from 2008
22:49:57 <Cale> I'm right in the middle :D
22:50:01 <crestfallen> > map Just $ [(+), (*), (^)] <*> [a,b] <*> [1,2,3] :: [Maybe Expr]
22:50:05 <lambdabot>  [Just (a + 1),Just (a + 2),Just (a + 3),Just (b + 1),Just (b + 2),Just (b + ...
22:50:14 <crestfallen> so  Icant do that^
22:50:45 <crestfallen> oh sorry hold on pls
22:50:52 <sicklorkin1> Cale: all very nostalgic 
22:51:51 <crestfallen> thanks kindly Cale that works. why the sandbox though?
22:53:44 <Cale> crestfallen: Just a good practice to not clutter your package database with things installed for temporary use. If you'd like it to be more permanent, you can just cabal install from outside the sandbox and it'll be registered in ~/.ghc
22:54:23 <Cale> If your user package DB ends up with multiple versions of the same package installed over time, things can get confusing.
22:54:47 <crestfallen> cool ok thank you Cale. check you later.   ok, good advice I copy that.
22:58:11 <sicklorkin1> Cale: if you havn't already made those changes, I got my account details now..
22:58:52 <Cale> I changed the one link
22:58:59 <sicklorkin1> oh,link works! cheers
23:00:02 <sicklorkin1> hpaste.org is no longer?
23:00:21 <sicklorkin1> i'll movethis discussion elsewhere
23:08:57 <Montrage> Hi folks! I see `stack image container` is gone. How do I deploy a very simple yesod app with docker? Is this still the way to go? https://www.fpcomplete.com/blog/2017/12/building-haskell-apps-with-docker
23:10:02 <Montrage> I tried using `--docker` with stack but I don't think that's meant for deployment and I get an error when I run the resulting image
23:13:01 <jgt> Good morning
23:14:44 <dminuoso> Good morning, jgt.
23:31:57 * hackage boots 0.1 - IoC Monad in Haskell  https://hackage.haskell.org/package/boots-0.1 (leptonyu)
23:32:57 * hackage boots-app 0.1 - Startup factories using IoC monad  https://hackage.haskell.org/package/boots-app-0.1 (leptonyu)
23:41:58 <sicklorkin1> Montrage: Have you read the stack docs recently?
