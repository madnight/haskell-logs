00:29:55 <aditya> @unpl (zipWith (-) =<< tail)
00:29:55 <lambdabot> (tail >>= zipWith (-))
00:31:00 <aditya> :t (>>=)
00:31:03 <lambdabot> Monad m => m a -> (a -> m b) -> m b
00:31:14 <aditya> :t tail
00:31:17 <lambdabot> [a] -> [a]
00:31:25 <aditya> :t (>>=) tail
00:31:29 <lambdabot> ([a] -> [a] -> b) -> [a] -> b
00:32:46 <lavalike> % :t (>>=) @((->)_)
00:32:47 <yahb> lavalike: (w -> a) -> (a -> w -> b) -> w -> b
00:32:48 <aditya> [a] -> [a] -> b = ma and [a] = a-> mb ???
00:32:53 <lavalike> @djinn (w -> a) -> (a -> w -> b) -> w -> b
00:32:53 <lambdabot> f a b c = b (a c) c
00:33:42 <aditya> % :t (>>=) tail
00:33:42 <yahb> aditya: ; <interactive>:1:7: error:; Ambiguous occurrence `tail'; It could refer to either `Data.List.NonEmpty.tail', imported from `Data.List.NonEmpty'; or `Prelude.tail', imported from `Prelude' (and originally defined in `GHC.List')
00:33:58 <lavalike> aditya: m = ((->) e) = (e ->)
00:34:11 <aditya> m = arrow
00:34:18 <lavalike> if you want :)
00:36:18 <Axman6> \xs -> zipWith (-) xs (tail xs) -- I think this is the unpl'd version
00:39:03 <Axman6> new GHC proposal: newtype Foo = Foo BAr derive newtype everything except (TheClasses, IIntendTo, Replace)
00:39:46 <lavalike> f a b c = b (a c) c; a=tail b=zipWith(-) so the other way around: zipWith (-) (tail xs) xs
00:41:03 <Axman6> uh, yes, indeed
00:43:12 <MarcelineVQ> Axman6: -XWildcardDeriving
00:43:41 <Axman6> :o
01:09:16 <dminuoso> MarcelineVQ: Its quite amusing that you find a few hits on google that almost look like that this is a thing.
01:09:31 <dminuoso> https://www.google.com/search?client=firefox-b-d&q=ghc+wildcardderiving
01:09:57 <jgt> :set -XApplicativeDont
01:10:12 <jgt> :set -XNamedFieldDadJokes
01:10:15 <dminuoso> jgt: http://hackage.haskell.org/package/acme-dont-1.1/docs/Acme-Dont.html
01:10:38 <dminuoso> jgt: You mean an extension to augment that package?
01:10:38 <jgt> hahahaha
01:11:31 <jgt> I don't know; I thought we were just coming up with silly extension ideas
01:12:02 <jgt> I'm just here to make jokes anyway; my Haskell skills are atrocious :P
01:14:51 <dminuoso> Is there a way to have GHC not visibly produce object/interface files?
01:15:10 <jgt> dminuoso: do you mean stuff them away in some other location?
01:15:39 <jgt> or just not place in them in the file system at all?
01:15:46 <dminuoso> jgt: I guess I could specify odir/ohi, but I was hoping for some "-x" type of flag that just deletes them after producing the final artifact.
01:15:57 <dminuoso> (Or something equivalent)
01:15:59 <cocreature> Is a weak ptr to an Any equivalent to a weak ptr to the original value or are there some gotchas here?
01:16:15 <jgt> oh, that's interesting. I didn't know those could be specified. In my case, I just have this in my Makefile
01:16:30 <jgt> .PHONY: clean
01:16:32 <jgt> clean:
01:16:34 <jgt>  find app src test -name '*.hi' -type f -delete
01:16:35 <jgt>  find app src test -name '*.o' -type f -delete
01:16:37 <jgt>  find app src test -name '*.dyn_hi' -type f -delete
01:16:40 <jgt>  find app src test -name '*.dyn_o' -type f -delete
01:16:41 <jgt>  find static/css -name 'autogen*' -type f -delete
01:16:43 <jgt>  find static/tmp -name 'autogen*' -type f -delete
01:16:55 <jgt> I'm sure I could have done that in like three lines not eight, but oh well
01:16:57 <dminuoso> You know better, jgt. :)
01:17:00 <MarcelineVQ> luck the spamfilter didn't nuke you just there for similar lines :X
01:17:24 <jgt> didn't know there was such a feature in this channel
01:17:37 <dminuoso> jgt: freenode has that feature.
01:17:50 <jgt> #TIL
01:20:49 <[exa]> flood filter is off on #haskell? elsewhere I'm getting kicked for like 4 lines
01:21:36 * jgt will be a good kid from now on
01:23:17 <[exa]> (contrary to popular belief, irc kick doesn't hurt)
01:24:05 <merijn> jgt: Why are all those build artifacts littered throughout your source tree anyway? cabal/stack should build out of tree, no?
01:24:18 <merijn> (or, at least in a single subdir within your tree...)
01:26:10 <[exa]> cocreature: AFAIK the architectures where this kind of pointer conversion hurts are extinct, or at least completely disjoint from haskell architectures
01:26:41 <jgt> merijn: this is from building with GHCi, and the following config which I will _not_ paste directly here, this time
01:27:02 <jgt> merijn: http://ix.io/1KPT
01:28:05 <merijn> jgt: If you launch ghci via stack/cabal that should avoid littering the source tree, I think?
01:28:22 <merijn> Then you also don't need the -i flags, etc.
01:29:55 <jgt> I'm now at a point where I'm very happy with my existing workflow, for better or worse
01:30:14 <jgt> which I realise sounds like I'm being obtuse and refusing to do it the right way
01:31:40 <merijn> jgt: Are you using cabal-install or stack? Because it might be as little work as running "cabal (v2-)repl" instead if ghci :)
01:32:17 <jgt> I'm using neither currently (unless Nix uses cabal-install under the hood)
01:34:16 <jgt> merijn: http://ix.io/1Ro6
01:34:46 <merijn> ah, I don't know anything about nix :)
01:35:11 <merijn> jgt: Looks like you have an old cabal-install
01:37:27 <jgt> I think to upgrade I'd need to move a more recent nixpkgs. Not sure if that would also necessitate a GHC upgrade; perhaps not.
01:37:59 <merijn> jgt: cabal-install has pretty long term backwards compatibility with GHC
01:38:21 <koz_> Hi folks, I am doing something mildly mad. I have written this: https://gist.github.com/kozross/64ec803c0bd2a8e5fe259e3f2081d182 and it emits errors which I don't quite understand the reasons behind.
01:38:24 <merijn> jgt: Pretty sure cabal-install HEAD still supports anything GHC from 7.0 on
01:38:27 <koz_> Would someone be able to help me figure this out?
01:38:38 <jgt> merijn: it's not cabal-install I'm worried about; it's making sure all the packages still work together
01:42:01 <cocreature> [exa]: great, thanks
02:47:27 * hackage elliptic-curve 0.1.0 - Elliptic curve library  https://hackage.haskell.org/package/elliptic-curve-0.1.0 (sdiehl)
02:51:01 <dminuoso> Using servant, what's the canonical way to validate some input? Would that happen inside the handler, or is there some type magic to mark some argument as needing validation?
03:01:28 * hackage pairing 0.4.2 - Bilinear pairings  https://hackage.haskell.org/package/pairing-0.4.2 (sdiehl)
03:24:45 <sm[m]> A nice new monad tutorial: https://news.ycombinator.com/item?id=20673506
03:30:58 * hackage wai-extra 3.0.28 - Provides some basic WAI handlers and middleware.  https://hackage.haskell.org/package/wai-extra-3.0.28 (MichaelSnoyman)
03:31:21 <dminuoso> sm[m]: Honestly I dont think good monad tutorials cant exist.
03:33:20 <dminuoso> sm[m]: Ive started to use the model of "Look, if you consume monad polymorphic code the word monad is meaningless to you" when explaining monad to folks.
03:35:28 <dminuoso> Since beginners generally dont write Monad polymorphic code, they dont need to concern themselves with that abstraction in the first place.
03:35:34 <dminuoso> At least early on.
03:35:55 <dminuoso> Its more important they understand, when looking at a type signature like (>>=) - that they know *they* decide what m/a/b are going to be.
03:36:12 <dminuoso> And that any particular choice of m/a/b leads to some type signature that is easy to understand.
03:37:57 <tdammers> indeed
03:38:18 <tdammers> IMO the underlying problem that causes the monad tutorials out there to be harmful is that they get the problem-solution ordering wrong
03:38:48 <tdammers> the problem is not "I don't understand monads", the problem is "I have these seemingly unrelated things that all seem to follow a common pattern"
03:39:19 <tdammers> most of the tutorials out there try to go from the former, and end up in all sorts of awkward corners
03:39:53 <tdammers> but if you approach it from the latter angle, it's much easier to avoid incorrect metaphors and such
03:40:17 <sm[m]> Ok, but might I ask if you’ve read this one ? IMHO it’s objectively useful and among the better attempts
03:40:45 <sm[m]> YMMV for sure
03:40:55 <dminuoso> sm[m]: Yes, at least in parts.
03:41:07 <maerwald> tdammers: well, given that, people might never ask the questions what monads are, because you don't necessarily need them in your own code ;)
03:41:23 <merijn> IMO the best Monad tutorial is just Wadler's paper
03:41:26 <dminuoso> tdammers: I think its even more difficult. The motivation behind abstracting over that interface is hard to understand unless you have been there.
03:41:31 <merijn> It's clean, simple, has actual usecases already
03:41:50 <dminuoso> tdammers: Until you understand that motivation "here is 10 different instances" is just more likely to confuse you.
03:42:06 <dminuoso> Because it begs the question "whats the point here"
03:42:49 <sm[m]> merijn: it is good indeed.. one useful thing this one adds is a bridge to some more familiar examples
03:42:49 <nil> merijn: but it's not a fancy blog post with an engaging title and food-related analogies!
03:42:50 <merijn> I wonder why everyone always links 10 different blog tutorials, but no one ever refers to Wadler in their monad tutorials
03:43:27 <sm[m]> This tutorial does link to a timeline of past tutorials which hopefully starts with Wadler’s :)
03:43:47 <merijn> It doesn't
03:43:59 <merijn> It mentions the "you could have invented monads" blog post as first thing
03:44:09 <jgt> merijn: I think there's a certain perceived inaccessibility around anything described as a "paper"
03:44:28 <sm[m]> The timeline does
03:44:34 <fendor> merijn, you mean Monads for Functional Programming?
03:44:41 <dminuoso> jgt: Who knows, perhaps that paper is behind a paywall infact!
03:44:48 <dminuoso> (Which would be a valid assumption to make, considering its a paper)
03:44:51 <merijn> jgt: Sure, but if we're going to break that stigma we won't do it by ignoring papers
03:44:55 <merijn> fendor: Yeah
03:45:25 <merijn> Most Haskell papers are available for free via citeseer or free link found via Google Scholar, though
03:47:18 <fendor> also there is this sci-hub.tw which can create access to a lot of stuff. Although there are legal problems, i think.
03:48:02 <jgt> merijn: I didn't say that stigma is justified :)
03:48:49 <dminuoso> fendor: By that logic we should abolish the notion that "software is inaccessible because its proprietary" since we have TPB and friends. :p
03:49:26 <merijn> dminuoso: Google Scholar is pretty good at finding preprints/open access copies
03:49:32 <alp> dminuoso, you've got a "rigid" way, to validate as part of the decoding, i.e to decode in two steps, first to unvalidated value and then to validated value
03:50:33 <alp> the second way is to do it in the handlers, where you can use whatever monad you like and report problems in the most appropriate way
03:51:12 <dminuoso> alp: That "rigid" way, do you mean inside my FromJSON implementation?
03:52:45 <fendor> dminuoso, i just wanted to point out the existence and to potential usage :)
03:58:20 <sicklorkin> fendor: Do you know what the difference is between sci-hub.tw and sci-hub.se? .tw seach doesn't work for me
03:58:51 <fendor> sicklorkin, no, sorry, I can imagine that they are different mirrors so they dont get blocked
04:08:01 <Insanity_> Most likely just mirrors indeed, like tpb does
04:16:04 <alp> dminuoso, right, for JSON that'd be in the FromJSON impl
04:18:57 <alp> but frankly unless you're just taking the "quick and dirty" route to getting something done, I'd recommend the other approach. it's a lot easier for dealing with a dedicated error type, accumulating several errors when appropriate, etc
04:19:42 <alp> whereas with the "in decoding instance" approach you're bound to go back to some variant of 'Either String a'
04:19:44 <dminuoso> alp: Oh yeah, besides it would be mixing responsibilities (namely that of decoding syntactically valid data and determinig semantically valid data)
04:32:58 <tdammers> dminuoso: well, I do acknowledge that not everyone is like me in that regard - when I see a pattern, I do often feel at least a mild urge to solidify it into an abstraction, but apparently not everyone is like that
04:33:28 <dminuoso> tdammers: On that ground, would you use Magma?
04:34:28 <tdammers> dminuoso: sure
04:35:44 <tdammers> although in practice, more restrictive algebraic structures like Semigroup or Monoid tend to be more useful
04:38:27 * hackage lapack 0.3.1 - Numerical Linear Algebra using LAPACK  https://hackage.haskell.org/package/lapack-0.3.1 (HenningThielemann)
04:43:57 * hackage resistor-cube 0.0.1.2 - Compute total resistance of a cube of resistors  https://hackage.haskell.org/package/resistor-cube-0.0.1.2 (HenningThielemann)
04:50:29 * hackage linear-circuit 0.1.0.2 - Compute resistance of linear electrical circuits  https://hackage.haskell.org/package/linear-circuit-0.1.0.2 (HenningThielemann)
04:55:28 * hackage galois-field 0.4.1 - Galois field library  https://hackage.haskell.org/package/galois-field-0.4.1 (sdiehl)
05:05:29 * hackage elliptic-curve 0.2.1 - Elliptic curve library  https://hackage.haskell.org/package/elliptic-curve-0.2.1 (sdiehl)
05:06:28 * hackage patat 0.8.2.4 - Terminal-based presentations using Pandoc  https://hackage.haskell.org/package/patat-0.8.2.4 (JasperVanDerJeugt)
05:19:58 <nil> in  instance (Functor m, Monad m) => Applicative (StateT s m)  , what's the point of the Functor constraint?
05:20:57 <merijn> nil: Nothing, afaict
05:21:22 <Taneb> nil: historical reasons
05:21:28 <nil> ok
05:21:42 <Taneb> For the past few years it's been implied by the Monad constraint
05:22:28 <Taneb> Prior to that, Monad didn't have a Functor (or Applicative) superclass, and the Functor instance for StateT m required Functor m, but the Applicative instance (which did have Fucntor as a superclass) needed Monad m
05:26:19 <nil> so did the Monad class also provide fmap?
05:26:48 <tdammers> no, only return, (>>=) and fail
05:27:03 <tdammers> but there is mapM, implemented in terms of those
05:27:06 <tdammers> :t mapM
05:27:09 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
05:27:09 <nil> i see, so no join
05:27:21 <tdammers> no, join can be expressed in terms of those 3 also
05:27:29 <nil> oh, right
05:27:31 <lavalike> :t liftM
05:27:32 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
05:27:33 <lavalike> this?
05:27:43 <nil> join m = m >>= id
05:27:59 <dminuoso> merijn: There's a simple context reduction rule ⌜{S a, T a} -> {T a}⌝ if S is a superclass of T.
05:37:27 * hackage haskoin-store 0.17.0 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.17.0 (xenog)
06:40:57 * hackage strongswan-sql 1.3.0.1 - Interface library for strongSwan SQL backend  https://hackage.haskell.org/package/strongswan-sql-1.3.0.1 (erick)
07:06:45 <gq> hello, anyone here works with LLVM
07:07:10 <gq> i have some questions
07:07:32 <gq> i am getting this error
07:07:33 <gq> EncodeException "Null pointer constant must have pointer type but has type IntegerType {typeBits = 32}."
07:17:59 <dminuoso> megatr0nz: Doing what exactly?
07:18:02 <adjofun> megatr0nz, http://hackage.haskell.org/package/llvm-hs-pure-8.0.0/docs/LLVM-AST.html#t:Type
07:18:23 <[exa]> megatr0nz: could you post a bit of code that creates the error?
07:18:34 <[exa]> (pastebin preferably)
07:22:27 * hackage unagi-chan 0.4.1.2 - Fast concurrent queues with a Chan-like API, and more  https://hackage.haskell.org/package/unagi-chan-0.4.1.2 (BrandonSimmons)
07:42:34 <Boarders> Does anyone know why if I build with cabal I always get: Build profile: -w ghc-8.6.5 -O1
07:42:43 <Boarders> even if I have O2 in my ghc options
07:43:00 <dmj`> Boarders: is it in your cabal.config
07:43:50 <Boarders> my config file looks almost entirely commented out
07:44:25 <dmj`> almost? :)
07:44:45 <Boarders> just stuff like repository and etc
07:44:52 <merijn> Boarders: Which build method are you using?
07:45:12 <Boarders> I am just invoking cabal new-build or new-repl (with ghcid)
07:45:14 <merijn> stack, cabal...
08:01:06 <d0liver> Is there an explicit relationship between <*> and >>= in any given monad besides that they work with the same monad?
08:01:26 <merijn> d0liver: I'm not sure what you mean by that?
08:02:35 <maerwald> Boarders: yes, because you don't put optimisation level in ghc options, but on top-level
08:02:50 <maerwald> then cabal new-build can cache different optimisations levels without you getting weird linker errors
08:03:27 <maerwald> https://www.haskell.org/cabal/users-guide/nix-local-build.html#cfg-field-optimization
08:03:48 <merijn> maerwald: Putting it in ghc-options works fine
08:03:59 <maerwald> yes, sometimes
08:04:08 <merijn> maerwald: The optimisation field applies to all local packages, ghc-options applies to just one
08:04:13 <Boarders> maerwald: where is that supposed to go, in the cabal.project file?
08:04:21 <maerwald> merijn: you can do optimisation per package
08:04:26 <maerwald> Boarders: yes
08:04:38 <merijn> Boarders: Are you sure you don't accidentally have a cabal.project.local lying around?
08:05:13 <Boarders> merijn: I do! It just says the compiler to use
08:05:20 <Boarders> is that what is causing it?
08:05:38 <merijn> Boarders: I was just wondering if you had optimisation set in there
08:05:47 <maerwald> Boarders: Build profile: -w ghc-8.6.5 -O1 -- the O1 here is not referring to ghc-options, but to 'optimization' field in cabal.project
08:06:14 <Boarders> d0liver: it should be the case that <*> = ap where ap is defined for any monad though I would need to clarify precisely what I mean by equal
08:06:15 <maerwald> if you compile with llvm -O2 it will still say O1, because cabal doesn't understand such specific flags
08:06:25 <d0liver> merijn: The docs say that we can define <*> like this. But is there any reason that it needs to be defined like that? Is there any law that says we can't do something totally random and counterintuitive with <*> so that the monad follows the monad laws and the applicative functor laws in an incompatible way? Like having <*> treat an array like a zip list and having >>= have normal monadic behavior for an array?
08:06:25 <d0liver> https://www.irccloud.com/pastebin/js1REbf0/
08:06:34 <Boarders> ap                :: (Monad m) => m (a -> b) -> m a -> m bap m1 m2          = do { x1 <- m1; x2 <- m2; return (x1 x2) }
08:06:43 <merijn> d0liver: Yes, there's a law that says that
08:06:51 <Boarders> that is badly formatted
08:07:03 <Boarders> its defined here: http://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#ap
08:07:04 <maerwald> regardless, compilation will work, but you will get mixed results when switching ghc-options, possibly resulting in linker errors and skewed cache
08:07:20 <merijn> d0liver: It is theoretically possible to define lawful applicative and monad instances that don't match, but that's a good way to get crucified by your users :)
08:07:36 <merijn> d0liver: Then again, it's also possible to define unlawful instances in the first place
08:07:43 <Boarders> it's also a good way for a re-factor to totally throw off your code
08:08:14 <Boarders> I would in general re-factor do-blocks without binding to applicative if it is clearer
08:08:21 <merijn> d0liver: Generally if you want different implementations you'd use a newtype to do so, see, for example, [] and ZipList
08:08:21 <Boarders> which would break with any such example
08:09:14 <d0liver> merijn: Okay, awesome, thanks. That's kinda what I figured but I'm just feeling for the boundaries of "good behavior by convention" versus what's explicitly outlined.
08:09:44 <merijn> d0liver: Sometimes the line gets blurry (see the recently released monad-validate)
08:10:32 <merijn> (see the "ValidateT and the monad laws" section here: https://hackage.haskell.org/package/monad-validate-1.2.0.0/docs/Control-Monad-Validate.html)
08:10:39 <dminuoso> d0liver: So regarding your initial question, strictly speaking Applicative is quite orthogonal to Monad. It just so happens that every Monad gives rise to a "trivial/canonical" Applicative instance.
08:11:36 <dminuoso> d0liver: For coherence it is required that if you define a Monad instance that the Applicative instance must be the same that is that canonical/trivial instance induced by Monad. 
08:12:33 <d0liver> dminuoso: Makes sense
08:12:35 <dminuoso> This coherence for example is what allows refactoring to occur. Say you have an API and you write some Monad polymorphic interface. Now imagine what happened if you realized "hey I dont need the full power of Monad, Applicative is enough", and you weaken the constraint to Applicative.
08:13:00 <dminuoso> d0liver: So if the Applicative instance was not that instance, then suddenly by merely weakening the constraint you'd cause consumer code to suddenly behave differently.
08:14:14 <dminuoso> d0liver: If we didn't enforce this the superclass relationship wouldn't make any sense.
08:14:43 <dminuoso> enforcing in the sense that its a specified law.
08:27:38 <dminuoso> d0liver: Take a given Monad modelling some effect/behavior. Now, if we didn't impose any restrictions on what that Applicative instance looked like, what could  you tell me about its Applicative instance?
08:30:22 <d0liver> I can't find anything that actually relates them in the docs - I'm probably just missing it?  But assuming that nothing was enforced there I couldn't really tell you anything about it besides that it follows the laws for Applicative and it works with the same monad. The behavior for fmap could be totally different though.
08:30:51 <dminuoso> d0liver: If thats the case the superclass relationship is useless, isnt it?
08:30:59 <dminuoso> d0liver: I mean at that point they might as well be completely unrelated.
08:31:02 <dmwit> d0liver: https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Monad has the law (<*>) = ap
08:31:04 <d0liver> Right
08:31:10 <dmwit> d0liver: (and pure = return)
08:31:32 <dminuoso> dmwit: I was requiring him to imagine those restrictions be gone.
08:31:51 <dmwit> I am responding to "I can't find anything that actually relates them in the docs".
08:31:59 <d0liver> Ah, okay. I was looking here: https://wiki.haskell.org/Monad_laws
08:32:03 <dminuoso> Ah, I see.
08:32:18 <dminuoso> d0liver: If in doubt the haddock documentation is the best source of truth.
08:32:25 <d0liver> Gotcha
08:32:38 <dmwit> The source is the best source.
08:32:44 <d0liver> lol
08:32:47 <dmwit> The haddocks are usually quite good, though.
08:33:11 <tdammers> and that is not in the last place because half of it comes from the code itself
08:33:27 * hackage autoexporter 1.1.14 - Automatically re-export modules.  https://hackage.haskell.org/package/autoexporter-1.1.14 (fozworth)
08:35:20 <dminuoso> dmwit: Well not for laws (yet?).
08:39:19 <mpickering> Can anyone think why Control.Concurrent.Async would allocate 12mb worth of cons cells?
08:41:38 <dminuoso> mpickering: Curious, why cant you be more precise than the module?
08:42:02 <mpickering> I could be..
08:42:06 <mpickering> but need to then add cost centres
08:45:56 <dminuoso> mpickering: Is that in some cabal/stack project?
08:45:58 <maerwald> Cabal-3 is out, but cabal-install-3 not? :)
08:46:15 <dminuoso> mpickering: Im just thinking whether you could auto generate cost centers to async only with ⌜-fprof-auto⌝
08:46:46 <mpickering> yes you can in cabal
08:46:47 <merijn> maerwald: cabal-install-3 will be released later
08:46:48 <mpickering> I am doing that night
08:46:55 <mpickering> it just takes a little effort to generate them 
08:46:58 <merijn> maerwald: Cabal has to ship before any GHC using
08:53:45 <mpickering> dminuoso: defaultLiftBase apparently
08:53:51 <mpickering> now I need to find where that is defined
08:55:49 <mpickering> that seems like it's the thing run inside that action which is allocating
09:00:14 <turab> @pl \f g a b -> f (g a b)
09:00:14 <lambdabot> (.) . (.)
09:00:22 <turab> @pl \f g a b c -> f (g a b c)
09:00:22 <lambdabot> (.) . (.) . (.)
09:03:08 <turab> @pl \a f -> f a
09:03:08 <lambdabot> flip id
09:04:28 <turab> succ <$> (+ 2) $ 3
09:04:32 <turab> whoops
09:38:22 <A-Non> help
09:50:00 <infandum> I'm trying to stream parse a tsv.gz. I'm using streaming, streaming-utils, streaming-bytestring, and streaming-cassava. I have "S.decodeWith·csvOpts·S.NoHeader .·S.gunzip .·(contents·::·BS.ByteString·(ExceptT·S.CsvParseException·Managed)·())" but when S.map over the results with a function that takes a list, it looks to cut short a line (there should be 5 columns and it gives 3). Why would this be? I have the same process with
09:50:00 <infandum> uncompressed .tsv and that's the same but no S.gunzip and it works fine, but that's a different format (3 columns). Does it have to do with bytestring chunks?
10:07:28 <dmwit> infandum: Seems like standard debugging procedure applies. Does gunzip produce the right sequence of bytes? If not, how small a sequence can you gzip and maintain that problem? If yes, how small a tsv-file can you produce for which decodeWith gets the wrong answer?
10:07:39 <dmwit> minimize minimize minimize
10:08:03 <dmwit> Minimize the code (figure out whether to blame gunzip or decodeWith), minimize the data (find the smallest file that makes the error).
10:44:27 <infandum> dmwit: It has to be decompression (gunzip), as I relaced the decodeWith with a manual one and it runs into the same issue
10:44:34 <infandum> Unfortunately I have no idea what the bug would be
10:44:54 <tdammers> minimize further
10:44:56 <tdammers> isolate
11:08:27 * hackage either-both 0.1.1.1 - Either or both  https://hackage.haskell.org/package/either-both-0.1.1.1 (MatthewFarkasDyck)
11:23:30 <dmwit> infandum: I find your argument that it is decompression unconvincing.
11:23:40 <dmwit> For whatever that's worth.
11:24:28 <dmwit> You change two variables and then blame one of the variables you didn't change.
11:25:03 <shapr> I blame variables.
11:25:12 <shapr> They should no longer vary.
11:25:15 * shapr makes the decree
11:25:23 <dmwit> (The sentence "no S.gunzip and it works fine, but that's a different format. Does it have to do with bytestring chunks?" has the same problem. You changed two variables (no gunzip, different format) and then... blame bytestring chunks, which was not one of the variables?)
11:25:27 * hackage shake-literate 0.1.0.1 - Rules for building literate programs in shake  https://hackage.haskell.org/package/shake-literate-0.1.0.1 (vmchale)
11:25:49 <shapr> Computers. Probably a bad idea.
11:25:57 <dmwit> Good tests change just one variable, and then blame that variable if the behavior changes from good to bad or vice versa.
11:26:11 <dmwit> s/tests/experiments/ I guess
11:26:13 * shapr blames self
11:27:05 <dmwit> "I changed this variable and the behavior didn't change" doesn't mean "that variable over there is at fault".
11:28:35 <turab> Hi dmwit I finally have time to continue my question I asked about a week ago (got busy with wrapping up internship so couldn't do it earlier (you also probably don't remember my question haha))
11:30:30 <turab> I have a program that converts simple lisp like programs to CPS. After playing around with a bit, I realized I could add another feature that will define cpsed version of functions that are not in scope. However, I want the user to pass in a flag of some sort to opt in
11:31:10 <turab> This is what I am currently doing: https://github.com/trajafri/Pref/blob/master/src/CpsApp.hs
11:33:21 <turab> My idea is to pass in different data structures based on what flags are passed to the program. My main concern was what's the best way to make my program behave in two different ways
11:37:05 <turab> *make my program behave differntly based on what flags are passed
11:41:27 * hackage shake-ats 1.10.2.2 - Utilities for building ATS projects with shake  https://hackage.haskell.org/package/shake-ats-1.10.2.2 (vmchale)
11:46:41 <merijn> turab: Any specific reason why you're reinventing the commandline parsing wheel?
11:47:56 <merijn> Ah, wait, those are from argparser and I just didn't notice :)
11:48:57 <turab> Np :)
11:50:48 <merijn> turab: Anyway I'd just define a sum type "data Config = MyConfig1 ... | MyConfig2 ..." then have your main program be "Config -> IO ()" or whatever and just have 1 behaviour for MyConfig1 and another for MyConfig2
11:53:40 <turab> That would work, but I felt like experimenting with typeclasses so instead of "Config -> IO ()", my program is more like "Config c => c -> IO ()
11:55:06 <merijn> turab: Honestly, I'd say that's probably a terrible idea
11:55:48 <turab> merijn: I would like to understand why so I can do it the right way :)
11:55:57 <tdammers> what would that Config typeclass look like? what would its methods be?
11:56:02 <merijn> ^^
11:56:16 <tdammers> by all means try it, but you'll end up with something that is more or less that sum type anyway
11:56:36 <turab> I have a definition here: https://github.com/trajafri/Pref/blob/master/src/Transform/CPS.hs
11:57:08 <merijn> turab: tbh, I also really dislike argparser after looking it up, I think the typeclass usage there is also a mistake :)
11:57:09 <turab> It seems really bad which is why I thought I should get some advice instead of realizing later that my attempt was terrible
11:57:40 <tdammers> as a general rule of thumb, whenever you wonder "do I want to use a typeclass for this", the answer is usually "no"
11:57:50 <merijn> turab: Basically, the super short TL;DR on why to avoid typeclasses is that datatypes are easy to inspect and manipulate
11:58:10 <tdammers> also, Haskell tends to be insanely refactorable, and you can always generalize things to typeclasses later
11:58:19 <tdammers> but start with concrete things
11:58:22 <turab> I see
11:58:43 <merijn> turab: Typeclass instances cannot be inspect or manipulated, only used as-is. The added downside is that excessive the typeclass polymorphism generally also results in terrible error message 
11:59:07 <merijn> > 1 2 -- classic example of confusing errors
11:59:10 <lambdabot>  error:
11:59:10 <lambdabot>      • Could not deduce (Num t0)
11:59:10 <lambdabot>        from the context: (Num t, Num (t -> t1))
11:59:27 <turab> That is indeed annoying sometimes
11:59:32 <merijn> > (1 :: Int) (2 :: Int)
11:59:35 <lambdabot>  error:
11:59:35 <lambdabot>      • Couldn't match expected type ‘Int -> t’ with actual type ‘Int’
11:59:35 <lambdabot>      • The function ‘1 :: Int’ is applied to one argument,
12:00:35 <turab> So, say later I want to introduce another functionality which needs "MyConfig3" (based on merijn 's example above).
12:00:36 <merijn> turab: I find typeclasses are most useful when you can write truly generic code with them (so Monoid, Monad, Applicative, Functor, etc.) when you will rely on polymorphic recursion and a handful of things like that
12:00:52 <tdammers> IMO the killer feature of typeclasses is that they're open
12:00:59 <turab> Then the better way is to add the extra cases for those in my program?
12:01:10 <merijn> turab: You'd add a "| MyConfig3" and if you compile with -Wall you'd immediately get a warning what to fix
12:01:41 <merijn> turab: Well, with the typeclass approach you'd *still* have to add all the extra cases, except they'd be in the instance definition, instead of the main code
12:02:02 <turab> That makes sense
12:02:21 <merijn> turab: The alternative approach is to have the argument parser return the code to run directly
12:02:37 <turab> As tdammers said, typeclasses being open is what made me go for that instead of a sum type
12:02:50 <tdammers> but I don't think you need this to be open
12:02:54 <merijn> turab: But anyway, the whole "one case per behaviour" is really not that ba
12:03:25 <merijn> turab: Consider this example: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/model-src/Main.hs#L63-L134
12:04:38 <turab> Ahh I see
12:05:53 <turab> Thanks for the feedback people! :D
12:06:40 <turab> I am still a bit confused about when to use typeclasses.
12:07:49 <merijn> turab: I'd say 80-90% of my code doesn't involve any class definitions, merely instances
12:07:55 <turab> tdammers: If the answer is usually 'no' when someone feels like creating typeclasses, then is there a case when I should really consider typeclasses?
12:08:27 <turab> merijn: instances of classes defined by someone else?
12:08:35 <merijn> turab: Generally there's a curve when people learn Haskell. Phase 1: I don't know what typeclasses are..., Phase 2: Typeclass all the things!, Phase 3: typeclasses in moderation
12:09:10 <merijn> turab: Yeah, mostly the common ones from base (like Applicative/Monad/etc.)
12:09:35 <merijn> turab: Or things like MonadLogger and similar mtl-style instances
12:09:45 <tdammers> turab: yes, but at least once you're somewhat experienced, it'll be almost obvious when you do want one
12:10:01 <turab> Okay!
12:10:22 <turab> Next time I feel like defining a class, I will make sure I ask #haskell first :)
12:10:54 <merijn> turab: I mean it doesn't hurt to play around with defining classes, best way to learn when/why things don't work is to try and see ;)
12:11:23 <tdammers> agree
12:11:26 <turab> Yea, I did learn the difficulty in my case since I couldn't get something very simple to work right away
12:11:49 <tdammers> this "if unsure, avoid typeclasses" is really just a rehash of "KISS"
12:12:44 <turab> Alright, time to simply things
12:12:57 <tdammers> anyway, if you want an example of a typeclass that does need to be open, consider Show (disregarding its questionable and somewhat debated purpose for now)
12:13:13 <merijn> tdammers: Or Pretty ;)
12:13:19 <tdammers> merijn: yeah, same thing basically
12:14:28 <tdammers> for example, if you want to write a function that takes a something that can be rendered as a string, and puts it between backticks, things get ugly without a typeclass
12:15:01 <tdammers> you can write a -> String, but given only this type signature, you can only write pathological implementations (throw away the argument and return a constant)
12:15:26 <tdammers> so the caller somehow needs to provide a way for you to conjure up a String from whatever it is they're passing int
12:15:29 <tdammers> s/int/in/
12:16:01 <tdammers> one way to do that is to actually pass that conversion function in: addBackticks :: (a -> String) -> a -> String
12:16:06 <tdammers> but that's kind of inconvenient
12:16:45 <tdammers> another way is to write a separate addBackticks function for every type we want to convert to a string: addBackticksToString :: String -> String; addBackticksToInteger :: Integer -> String; ...
12:16:55 <tdammers> but that's even worse
12:17:18 <tdammers> what we need is a way to pass that (a -> String) function implicitly, and that's exactly what typeclasses do
12:17:38 <tdammers> so we go addBackticks :: Show a => a -> String
12:18:04 <Boarders> Does anyone know if I am updating a vector at only a few entries if it is better to use (//) or modify?
12:18:08 <turab> With that example, my usage of typeclasses seems awkward
12:18:14 <tdammers> note, btw., that this looks almost like addBackticks :: Show a -> a -> String -- that is, it's almost as if we were saying that we'll pass the Show instance as an argument
12:18:29 <Boarders> I plan to write some benchmarks but I would be interested if anyone has more insight on what should be better
12:18:52 <tdammers> and at some intermediate compilations stage in GHC, it actually does become that (!)
12:18:54 <merijn> I would expect very little difference
12:19:06 <merijn> Boarders: Both cases you have to copy the entire thing
12:19:41 <Boarders> fair enough, is there a better approach or is this just life with vector
12:20:07 <merijn> Boarders: The better approach is to try and batch your updates :)
12:20:34 <Boarders> :) 
12:20:43 <Boarders> hopefully laziness somehow helps me out
12:21:02 <Boarders> or fusion or some other magic
12:21:02 <merijn> Boarders: vector has quite a lot fusion stuff to fuse away intermediate vectors
12:21:41 <MarcelineVQ> so much so that it inspired other libraries to do similar
12:22:12 <tdammers> unfortunately also so much that it routinely ends up hitting performance edge cases in GHC
12:23:01 <merijn> hmmm
12:23:54 <merijn> Is there no safe version of maximum?
12:25:31 <merijn> > mempty :: Data.Monoid.Max Int -- I'm betting this is not what I want
12:25:34 <lambdabot>  error:
12:25:34 <lambdabot>      Not in scope: type constructor or class ‘Data.Monoid.Max’
12:25:34 <lambdabot>      Perhaps you meant one of these:
12:25:45 <merijn> oh wait, that's semigroup now
12:25:55 <merijn> > mempty :: Data.Semigroup.Max Int -- I'm betting this is not what I want
12:25:58 <lambdabot>  error:
12:25:59 <lambdabot>      Not in scope: type constructor or class ‘Data.Semigroup.Max’
12:25:59 <lambdabot>      No module named ‘Data.Semigroup’ is imported.
12:26:16 <Boarders> I thought it was just equal to maxBound
12:26:21 <Boarders> is that not what you want?
12:26:27 <merijn> Boarders: No, it's minBound
12:26:41 <merijn> maxBound isn't identity for max ;)
12:26:45 <Boarders> oh sorry you are doing Max :)
12:27:08 <merijn> I just want 0 if the collection is empty, but I'm getting an Int, not a Word, so now everything is awkward >.>
12:27:31 <MarcelineVQ> listToMaybe . sortBy (comparing Down) . toList ehehe
12:28:27 <dmwit> merijn: http://hackage.haskell.org/package/monoid-extras-0.5/docs/Data-Monoid-Inf.html#v:maximum
12:29:00 <merijn> dmwit: Yeah, but that's also a hassle in my case. I think I'll have just convert to Word and then use Max
12:29:24 <dmwit> I think it would be reasonable to have a newtype for the max/minBound monoid.
12:29:38 <dmwit> I don't know of one in any existing standard-ish libraray.
12:29:41 <merijn> dmwit: There is one
12:29:47 <merijn> dmwit: Data.Semigroup.Max
12:29:52 <dmwit> That's only a semigroup.
12:29:55 <merijn> dmwit: No
12:29:58 <dmwit> oh?
12:30:04 <merijn> "instance Bounded a => Monoid (Max a)"
12:30:17 <dmwit> Cool!
12:30:26 <dmwit> Then that seems to be the answer to your question, or...?
12:30:29 <merijn> dmwit: Just awkward the length returns Int
12:30:33 <merijn> s/the/that
12:30:49 <dmwit> merijn: Ah. Consider `maximum . (0:)`.
12:31:02 <merijn> dmwit: My input is an IntSet :)
12:31:12 <merijn> eh, IntMap
12:31:14 <dmwit> `maximum . S.insert 0`, then.
12:31:44 <dmwit> ...ok
12:31:55 <merijn> I think foldMap is the best I can do
12:32:27 <aoeu256> isn't foldMap just map . fold?
12:32:32 <merijn> aoeu256: No
12:32:35 <merijn> :t foldMap
12:32:38 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
12:32:56 <merijn> aoeu256: So more like "fold . map" ;)
12:32:58 <dmwit> It is just `(fold.) . fmap`. But it is usually implemented in a more efficient way (one pass instead of two).
12:33:06 <aoeu256> err by using monoid you don't have to pass in the zero element?
12:33:12 <merijn> aoeu256: Right
12:33:25 <merijn> aoeu256: Or a combining function
12:33:40 <dmwit> (And fmap doesn't necessarily exist for all Foldables.)
12:33:46 <merijn> dmwit: wut
12:33:49 <merijn> dmwit: It literally does
12:33:59 <merijn> dmwit: Functor is a superclass of Foldable
12:34:10 <merijn> Oh wait, not anymore?
12:34:16 <dmwit> Hm. Not listed here: https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Foldable
12:34:18 <merijn> I guess I'm thinking of Traversable
12:34:23 <dmwit> I don't think it ever was.
12:34:55 <aoeu256> traverse is mapM right?
12:35:01 <dmwit> yes
12:35:19 <aoeu256> or mapA
12:35:31 <dmwit> yes
12:37:30 <aoeu256> i wish there was a way that haskell/hlint? could automatically generalize and "specialize" things to make them easier to understand
12:38:14 <koz_> aoeu256: What do you mean by that?
12:39:35 <aoeu256> koz: like if you don't know the generalization its hard to understand the code and terms
12:40:10 <koz_> aoeu256: Could you give me an example?
12:40:23 <boj> > :t traverse
12:40:26 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
12:40:33 <boj> oh
12:40:35 <aoeu256> koz: like monoid is a generalization of (+, 0) (++, []), (*, 1) in fold
12:40:37 <boj> :t traverse
12:40:39 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
12:41:15 <koz_> aoeu256: Yeah... that's just the definition of Monoid. I recommend reading the Typeclassopedia a few times if these things aren't clear.
12:41:21 <aoeu256> koz: fmap is the generalization of map
12:41:24 <koz_> Every language has a conceptual barrier.
12:41:54 <koz_> Have you read the Typeclassopedia?
12:41:57 <boj> i second reading typeclassopedia. i wish i had known how important understanding it was when i started learning haskell
12:42:04 <koz_> It _really_ helped me back then.
12:42:06 <aoeu256> koz: ill read it afterwords
12:42:11 <koz_> (I still check in on it occasionally)
12:43:53 <aoeu256> koz: i mean isn't it possible in general by using substitution rules to show a concrete version of things by substitution sort of like
12:43:56 <aoeu256> Lisp's macroexpand-1
12:44:04 <aoeu256> but used on lazy functions rather than macros
12:44:21 <koz_> aoeu256: That's really not the same thing.
12:44:37 <koz_> (also, in Haskell _all_ functions are lazy - I don't think it means what you think it does)
12:44:37 <aoeu256> lazy functions and macros are very similar though
12:44:56 <koz_> No, they're really not. Lazy functions don't get executed at compile time, for a start.
12:45:45 <koz_> Yes, you can use macros to delay evaluation. But that's a bit like saying that integers are kinda like characters, because you can store UTF-8 codepoints in both.
12:45:46 <aoeu256> yeah, but for example to create your own if statement in lisp you would use a macro
12:45:49 <aoeu256> similar to lazy evaluation
12:46:08 <koz_> aoeu256: Agreed, but I think that's not a useful parallel. You're conflating two fairly unrelated things, which will only cause confusion.
12:46:24 <koz_> The closest analog to Lisp macros in Haskell is TH.
12:47:34 <Ferdirand> hello #haskell, little question about GADTs and type equality constraints
12:47:45 <aoeu256> but i mean as long as functions are pure can't they be substituted just like macroexpand-1?
12:48:24 <Ferdirand> i'm trying to define a type for lists of two alternating types
12:48:42 <Ferdirand> data Chain a b l where
12:48:42 <Ferdirand>     Nil  :: Chain a b b
12:48:43 <Ferdirand>     (:@) :: a -> Chain b a l -> Chain a b l
12:48:58 <Ferdirand> l represents the statically-known type of the last element
12:50:22 <Ferdirand> now, for the type Chain (a b a), which has the same type for the first and last element, i know that if a and b are different types, then the list cannot be empty
12:50:42 <Ferdirand> and i'd like to write a type-safe `last` function that reflects that
12:51:36 <aoeu256> Im not very good with Haskell, but maybe you can have two different "Cons" constructors
12:51:45 <aoeu256> one from A -> B, then another from B -> A
12:52:27 <boj> :t fmap (<>) [1..3]
12:52:28 <lambdabot> (Semigroup a, Num a, Enum a) => [a -> a]
12:52:35 <boj> :t fmap (<>) ["h","i"]
12:52:38 <lambdabot> [[Char] -> [Char]]
12:52:48 <iqubic> How does that work?
12:52:53 <boj> aoeu256: perhaps that is what you want?
12:53:20 <boj> you can ask something like ghci for the type of a generalized function, specialized to your parameters
12:54:11 <iqubic> ghci is like the greatest thing ever
12:54:19 <aoeu256> boj: I'll try to remember that hahah
12:54:23 <boj> :t (<>)
12:54:25 <lambdabot> Semigroup a => a -> a -> a
12:54:33 <boj> :t mappend
12:54:35 <lambdabot> Monoid a => a -> a -> a
12:54:43 <boj> you were asking about monoids
12:55:11 <aoeu256> Does GHCI allow you to camp at a breakpoint and let you access the locals though like the repl of the Dynamic languages (Lisp, Python, JavaScript?)
12:55:13 <dmwit> Ferdirand: There is no convenient way to express the constraint "these two types are not equal".
12:55:16 <lavalike> > fmap (<>) [1,2,3] <*> [4,5,6] :: [Sum Int]
12:55:19 <dmwit> Ferdirand: (Bummer!)
12:55:21 <lambdabot>  [Sum {getSum = 5},Sum {getSum = 6},Sum {getSum = 7},Sum {getSum = 6},Sum {ge...
12:55:45 <dmwit> Ferdirand: There are hacks that you can find online. But they are hacks, and generally broken in subtle ways; so I don't recommend relying on them.
12:56:40 <dmwit> aoeu256: There is a ghci debugger. You can read about it in the GHC manual. But...
12:56:44 <dmwit> ?quote debugger
12:56:45 <lambdabot> dons says: disable the type checker in ghc for 6 months and we'd have 5 debuggers at the end of it :)
12:57:49 <dmwit> Hm. Well, there's a quote in there somewhere about how using the ghci debugger is like trying to follow a kid on drugs. =P
12:58:29 <aoeu256> I mean can't you do: data alterList = AlterNil | AlterConsA a b | AlterConsB b a
12:58:57 <aoeu256> is the debugger only for monadic code?
13:00:21 <dmwit> No, it is only for pure code. =P
13:01:07 <dmwit> Your proposed AlterList has some problems. But even after fixing them, what you get only tells you statically what the *first* element of the list is, not the last.
13:01:10 <Ferdirand> dmwit: well, broken in subtle ways is probably better than a partial function ?
13:01:29 <Ferdirand> (i found some post on stackoverflow using a type family, seems to work)
13:01:39 <dmwit> (Ferdirand's version tells you statically the types of *both* the first and the last element.)
13:01:52 <dmwit> (So it's not enough to just interpret your AlterList "in reverse", so to speak.)
13:02:32 <dmwit> Ferdirand: I don't think "broken in subtle ways" and "partial function that typechecks" are mutually exclusive. =)
13:02:44 <Ferdirand> yes that's the question
13:03:16 <dmwit> I guess what I'm trying to say is that "broken in subtle ways" specifically means "partial function that typechecks".
13:03:23 <Ferdirand> if the breakage is only that it refuses to compile because it cannot prove types are different in some specific context, it's fine
13:03:25 <jgt> iqubic: GHCi is so underrated. We don't go on about it anything like the Lispers go on about their REPl.
13:03:40 <dmwit> Right. That is not all that broken means in this case.
13:03:44 <Ferdirand> dmwit: i'd be really curious to see a test case for that
13:04:12 <dmwit> I... don't remember where it lives.
13:04:21 <Ferdirand> probably a scenario where the constraint get checked too early, before two types are unified ?
13:04:50 <dmwit> Something like that, yeah. I seem to recall it involves some type families getting instantiated after the check is done, specifically.
13:05:12 <aoeu256> wait can TemplateHaskell be used to create macros?  Macros run in static time so you can throw exceptions
13:05:28 <iqubic> jgt: Emacs is the best Lisp REPL ever, don't you try and disagree with me.
13:05:37 <dmwit> Yes, TH can be used to create macros.
13:05:39 <iqubic> The above is sarcasm.
13:06:11 <aoeu256> so you can use TH when you don't know how to use the advanced type thingies to statically check your code?
13:06:30 <dmwit> No, TH-generated code is still subject to typechecking.
13:06:42 <Ferdirand> well, partial in subtle broken cases is probably better than partial in trivial cases :|
13:07:19 <Ferdirand> though i'm not sure about the usablility of the error messages
13:07:50 <Ferdirand> "cannot match 'True to 'False", that's so helpful :)
13:08:09 <dmwit> Ferdirand: Have you considered `type Even a b = [(a,b)]; type Odd a b = (a, [(b,a)])`? =P
13:08:25 <dmwit> (Obviously make real types for these, and a real API. But you get my point, I think.)
13:08:26 <iqubic> Hehehe.
13:09:14 <iqubic> dmwit: let's golf that a little bit: `type Even a b = [(a,b)]; type Odd a b = (a, Even b a)`
13:09:18 <Ferdirand> dmwit: that.. may actually work fine
13:10:21 <Ferdirand> it's ugly, but..
13:10:25 <dmwit> > (length "Even b a", length "[(b,a)]")
13:10:28 <lambdabot>  (8,7)
13:10:34 <dmwit> iqubic: Reverse golf? =)
13:11:04 <turab> merijn: tdammers: Thanks for the feedback, took no time to get everything working :)
13:11:05 <Ferdirand> just call them E and O
13:11:11 <dmwit> yeah =D
13:15:24 <merijn> turab: Nice
13:16:00 <Ferdirand> actually
13:16:49 <Ferdirand> type Even a b = Maybe (a, Odd a b); type Odd a b = (b, Even a b)
13:21:29 <turab> merijn: Why do you dislike argparser? is there a package that you like?
13:22:31 <boj> turab: optsparse-applicative is nice
13:22:36 <turab> Also, do all command line parsing packages utilize System.Environment?
13:22:42 <iqubic> That the thing that I like.
13:22:46 <fendor> +1 for optparse-applicative
13:22:52 <iqubic> optparse-applicative
13:23:02 <merijn> optparse-applicative ;)
13:23:23 <turab> Thanks all :D, I will switch to that instead of argparser
13:23:42 <merijn> turab: I was just glancing over it and seeing all the ParamSpec class stuff, also the ParserSpec seems severely limited
13:24:16 <merijn> optparse-applicative looks a lot more flexible in terms what parsers you can define and it's got a lot of features
13:24:38 <fendor> optparse-applicative has great documentation, normally I just copy the examples and change the names.
13:24:45 <merijn> Also the readme is quite good at showcasing the most common cases
13:25:07 <turab> I already see some features that i kinda had to hack with argparser
13:25:49 <merijn> turab: It's *slightly* more verbose than some of the more "magic" option parsers, but in exchange you get very exact control over everything
13:28:27 <Athas> I just use System.Console.Getopt.  Am I missing out?
13:28:57 * hackage array-chunks 0.1.0.0 - Lists of chunks  https://hackage.haskell.org/package/array-chunks-0.1.0.0 (andrewthad)
13:31:07 <merijn> Athas: I don't think that handles things like subcommands, does it?
13:32:11 <Athas> You need to add your own stuff on top, but it's not so bad.  I do that.
13:32:31 <merijn> Athas: optparse renders more detailed/accurate help, it has support for subcommands with their own options (like "stack <command>" and "cabal <command>", etc.)
13:33:27 <merijn> Athas: I don't think you can really do something like mutually exclusive sets of flags/options with Getopt?
13:34:42 <merijn> Athas: optparse-applicative also does things like let you autogenerate bash/zsh/fish autocompletion scripts, option disambiguation (so letting you shorten unambigous options, etc.)
13:35:40 <iqubic> That's so wicked
13:35:58 <merijn> Athas: So all in all I'd say it does quite a bit of stuff getopt doesn't. Is that enough to drop/rewrite an existing adequate getopt parser? Maybe not, but I'd say it does have a quite a few bells and whistles/polish that getopt doesn't
13:36:32 <merijn> iqubic: Out of the 10 or so languages I've written commandline option parsers in I've never found a library as pleasant, powerful, and complete as optparse-applicative
13:56:28 * hackage patat 0.8.2.5 - Terminal-based presentations using Pandoc  https://hackage.haskell.org/package/patat-0.8.2.5 (JasperVanDerJeugt)
14:10:14 <wroathe> https://stackoverflow.com/questions/31412444/template-haskell-is-there-a-function-or-special-syntax-that-parses-a-string-a
14:10:32 <wroathe> Piggy backing on this, is there a way to use quasi quotes to parse a string?
14:10:48 <merijn> wroathe: You can run arbitrary code via quasi quotes, so yes
14:10:57 <wroathe> I'm looking to do something like: 
14:11:37 <merijn> wroathe: You can just use arbitrary libraries in the implementation of your quasiquoter, so you could just write and use a Megaparsec parser
14:11:40 <wroathe> parse $ "if isTrue x then " <> "\"x is true\"" <> " else " <> "\"x is false\""
14:12:26 <wroathe> Oh, you're suggesting a custom quasi quoter?
14:12:36 <aoeu256> Btw is there a name for things that are both Monads and CoMonads?
14:12:43 <merijn> wroathe: Why not? :)
14:13:14 <merijn> aoeu256: Not afaik, because that's not a set that's commonly talked about?
14:13:14 <wroathe> Because this doesn't seem to work OOTB: foo = "Just 3"; $([| $foo |])
14:13:29 <merijn> wroathe: stage restriction
14:13:30 <wroathe> probably for a very good reason
14:13:56 <merijn> wroathe: You cannot use code in a quasiquoter that's in the same module as the quasiquoter
14:14:02 <wroathe>     • Couldn't match type ‘Text’ with ‘Q Exp’
14:14:49 <merijn> wroathe: So is the goal to quote the string literal or the variable name?
14:14:50 <wroathe> foo in this case is text, and obviously splicing requires a Q expr
14:15:34 <wroathe> The goal is to parse a file, use that to construct a haskell expression as a string, and then have the quasi quoter parse it for me
14:15:56 <wroathe> and then splice the result into my program
14:16:42 <merijn> wroathe: Why do you want to construct the Haskell expression as a string and then parse?
14:16:52 <merijn> Why not just construct an AST directly?
14:17:02 <merijn> That just seems like needless work
14:17:07 <wroathe> More parsing work on my end
14:17:17 <merijn> How so?
14:17:34 <merijn> wroathe: I'm assuming you want to fill in some largely existing "template"?
14:17:35 <wroathe> This relates to what I was talking about yesterday with that gist I shared: https://gist.github.com/JustinChristensen/222ec9d3a75e90b9c1bedbc05a996d6d
14:17:44 <wroathe> This is just a rough outline with some mistakes
14:18:24 <wroathe> But I'm trying to figure out how I could parse a file that looks like the first 18 lines of that file into a function that takes a scope and returns Text
14:18:53 <wroathe> And ideally the delimiters would allow for arbitrary haskell, so long as the result is an expression that can be converted to text
14:19:28 <isovector1> can i run brick over a custom monad? seems like it's baked directly into IO
14:19:39 <wroathe> So a comment would look like: </% {- foo bar -} ()%/>
14:19:58 <wroathe> and the result of that delimited piece would be toText ()
14:20:20 <merijn> isovector1: Could you maybe get by with MonadUnliftIO?
14:20:49 <Cale> You can probably get by with even less, given that it's the top level of your program
14:21:03 <isovector1> merijn: gross. i'd rather die :)
14:21:05 <merijn> wroathe: I don't really have enough experience with quasiquoting to answer that
14:21:08 <merijn> isovector1: How so?
14:21:32 <wroathe> and going further, it would then behave like this: foo </% {- it works -} ()%/> bar, would become: "foo" <> toText () <> "bar"
14:22:15 <isovector1> merijn: unliftio is a scourge upon the ecosystem imo
14:22:23 <merijn> isovector1: Why?
14:23:26 <isovector1> merijn: it forces you to decompose any interesting monad stack you can think of into IO and ReaderT
14:23:40 <merijn> isovector1: Wel, what alternative do you suggest?
14:23:45 <isovector1> merijn: polysemy :)
14:23:50 <merijn> isovector1: MonadBaseControl? Talk about a scourge...
14:24:15 <wroathe> merijn: See, the problem with your suggestion is that I'd need to implement a parser from an arbitrary haskell string to the TH AST type
14:24:24 <merijn> isovector1: polysemy is a pretty giant tactical warhead for most problems :)
14:24:37 <merijn> (hammer didn't seem adequate a description :p)
14:24:46 <wroathe> merijn: Whereas if I had access to the parser the existing [e| quasi quote uses I could just use that to get my TH AST
14:24:58 <isovector1> merijn: why do you say that? it's no bigger of a dependency than mtl
14:25:04 <Cale> Is polysemy really aimed at solving that problem?
14:25:15 <Cale> I thought it was solving a similar problem as transformers
14:25:37 <merijn> isovector1: Not in dependency, but complexity
14:25:56 <isovector1> Cale: yeah. that problem is a biproduct of the fact that transformers are a shit abstraction
14:26:06 <isovector1> byproduct* been doing too much CT apparently :)
14:26:19 <Cale> I think the correct solution to the problem that MonadBaseControl/MonadUnliftIO represent is more meaningful classes for the higher order operations, which can constrain the monad in question.
14:27:01 <isovector1> the only reason MBC/MUIO exist is that `bracket` is invariant in its monad, so you're stuck to dealing with IO. but it's not a real limitation
14:27:19 <Cale> and if you're using transformers, then you just implement instances of your new class for each transformer one at a time, and that really lets you think about what it is that you're doing properly
14:27:32 <Cale> That is, if you need a polymorphic operation at all, which often people don't.
14:28:14 <isovector1> that sentiment baffles me. polymorphism is like our best tool in hs
14:28:16 <isovector1> anyway
14:28:26 <isovector1> back to brick. it looks like "no, i can't run it in a monad stack"
14:28:31 <Cale> There's MonadAsyncException for bracket
14:29:20 <isovector1> i don't want to get into a fight here. if you're happy with monad transformers all the power to you
14:29:24 <isovector1> i wasn't, so i did something about it :)
14:29:28 <merijn> isovector1: I mean, polysemy requires I learn a bunch of new type level stuff, use a GHC plugin, and hope things get optimised sufficiently. Meanwhile, I just want to use MonadLogger within a bracket :)
14:30:06 <merijn> isovector1: Don't get me wrong, polysemy looks cool, but to call MonadUnliftIO a scourge just because you think people should use polysemy seems a little excessive :)
14:30:21 <Cale> isovector1: I actually have no reason to be opposed to polysemy, haven't tried it yet, and I dislike the performance characteristics of transformers, so if you're managing to solve that problem, that's great.
14:30:34 <Cale> But I don't think of my monad as being a pile of transformers, ever.
14:30:41 <Cale> Even if it is implemented as such.
14:31:01 <Cale> I *hate* the term "monad stack"
14:31:01 <isovector1> i'm off to be productive. tootles!
14:37:43 <merijn> There's no real way to cleanup "... <*> (foo <$> bar)" besides lifting the "foo <$> bar" out and naming it, is there?
14:38:05 <Ferdirand> first time i've heard of polysemy but it looks like a christmas present
14:38:36 <merijn> Ferdirand: That means you need to subscribe to haskell-cafe, lurk /r/haskell, or read Haskell Weekly News more often ;)
14:39:07 <Ferdirand> meh. I just want to lurk on irc :/
14:39:08 <fog> there seems to be a problem with backpack and hackage
14:40:33 <fog> the backpacks would have to go in their own packages, and this would quickly lead to most of the packages being backpacks
14:41:18 <wroathe> The fact that [e|, [p|, [d|, and [t| aren't exposed as a QuasiQuoter seems like a problem to me
14:41:28 <merijn> wroathe: They should be
14:41:35 <fog> as they number NxM where N is the number of signature packages and M is the number of implementations of these signatures by different packages
14:42:17 <merijn> fog: There's already a solution :p
14:42:23 <fog> a user should not be forced to download all the dependencies (every backpack implementing a signature)
14:42:42 <fog> merijn: oh!?
14:42:44 <merijn> fog: Cabal-3 supports multiple public libraries per package, so you can have multiple implementations of a signatures in one package
14:42:55 <merijn> fog: At least, I recall that was the goal
14:43:04 <fog> then the problem remains
14:43:09 <merijn> fog: Cabal-3 was just released, cabal-install-3 should follow shortly after 8.8
14:43:29 <dmwit> merijn: You can modify `...` to include `foo`.
14:43:37 <dmwit> (Sometimes.)
14:43:39 <fog> you just want to be able to get the deps you need, not every package implementing the signature
14:43:56 <merijn> dmwit: It's a 3 argument function or so, so that' tricky/awkward
14:45:39 * dmwit nods sadly
14:45:42 <fog> then you would *have* to have one package per signature, with just the deps of the desired backpack 
14:46:19 <fog> sorry, one package per implementation of a signature
14:46:26 <merijn> fog: Why?
14:46:46 <fog> so you didnt have to install the other packages implementing the signature
14:46:55 <merijn> fog: The entire idea of multiple public libraries per package is that you can build their dependencies independently
14:47:21 <merijn> fog: You can depend on just one public library out of a package with multiple and only incur the dependencies for that one library
14:47:32 <fog> ah thats perfect!
14:47:54 <merijn> fog: You'll have to wait until the full release of GHC 8.8 and cabal-install-3 to use it, though
14:48:01 <fog> so i cant push to hackage a specific backpacks package and only install the part of it needed
14:48:32 <fog> there is still a question about if this package should be seperate from the signature...
14:49:12 <wroathe> merijn: Hah, that isovector1 guy beat us to it: https://gitlab.haskell.org/ghc/ghc/issues/16896
14:49:31 <fog> how do other people add their own backpacks? ie if they write a module implementing the signature, how can they add it to this multiple public libraries package?
14:50:47 <fog> if they were just supposed to implement the backpack as part of their package, then if another signature it could implement was written, they would have to update their package to have to implement these new signatures as they appear
14:50:49 <wroathe> That scallywag
14:52:29 <fog> if the idea is to place all these implementations in a central backpack package, probably along with the signature itself, then would the maintainer of that package have to be aware of all the possible backapacks implementing the signature as they appear?
14:54:27 <fog> its as if as well as needing multiple public libraries per package, you would need maintainer privilages as if they were seperate packages all in one package directory
14:57:35 <fog> so then, even with the new "multiple libraries per package" where you can just build the part of the package you need, and only incur a subset of the dependencies, there is still a motivation for people to bloat hackage by adding their own similar packages, if they are unable to add to the multiple public libraries package supposed to be used to de
14:57:35 <fog> ploy the backpacks
15:02:03 <fog> it makes more sense then to place the signature in a package of its own, and all the implementations also in separate packages submitted by different people, but all placed in a file corresponding to the signature.
15:02:25 <fog> file/hackage directory
15:03:15 <fog> just so the browse page doesnt end up having M packages per signature
15:19:48 <winny> Is there a better way to write this: filter (\(x,y) -> x == y) $ zip a b
15:21:17 <MarcelineVQ> it's not neccesarily better, but another way to write the lambda is uncurry (==)
15:21:42 <MarcelineVQ> I like the lambda more tbh
15:22:33 <merijn> winny: There's nothing obviously better, but depending on context there might b
15:22:42 <jackdk> I am indifferent to either from the provided context.
15:23:27 <merijn> mapMaybe, zipWith, etc. might be candidates for improving things, but that depends on context
15:23:44 <winny> no, i rather like this uncurry function. Thanks :)
15:25:00 <merijn> Is there a library for guessing the unicode encoding of a text file?
15:26:18 <c_wraith> be careful... not all text files are even encoded unicode.
15:26:49 <c_wraith> you can still find files encoded in Big5, for instance.
15:27:14 <merijn> c_wraith: Honestly, I'm okay with telling users of those files to suck it
15:30:19 <jle`> winny: you can use zipWith instead of zip and uncurry
15:30:29 <jle`> oh, i didn't realize it was a filter
15:35:29 <wroathe>  <- just found out that GHC is exposed as a library, parser included
15:35:31 <wroathe> mind blown
15:36:36 <phadej> it's not the easiest to use library though
15:38:36 <wroathe> phadej: Yup, I'm seeing that.
15:39:25 <EvanR> many things use shift-jis
15:39:38 <EvanR> japanese encoding
15:53:02 <zeta_0> does `emacs-ipython-notebook` support `ihaskell`, i don't see haskell as one of the supported languages? does `emacs-ipython-notebook` support `ihaskell`, i
15:53:17 <zeta_0> sorry i pasted twice
15:53:24 <zeta_0> by accident
15:53:33 <zeta_0> https://github.com/millejoh/emacs-ipython-notebook/tree/52f304d038019f3eed6e1afbccc31878e161183a
16:08:23 <mycroftiv> learner here, i seem to be embedding a large amount of state into tuples that are passed from function to function, is this often just 'how it goes' or are there alternative patterns for maintaining and mutating data?
16:09:45 <boj> mycroftiv: the Reader monad is a good start
16:10:01 <boj> or State, if you need to track changes
16:10:21 <mycroftiv> boj: thanks, ill look at those
16:10:32 <boj> mycroftiv: take a look at Typeclassopedia if you have't yet
16:10:42 <mycroftiv> first time ive heard of it! :)
16:10:58 <boj> it may seem confusing at first, but i have found that if you keep going back to it over and over it starts making more sense each time
16:13:43 <EvanR> depending on what your program vaguely does, there may be other more convenient ways to manage your state, if any
16:14:19 <EvanR> a small pure program may not need state. A large "app" may have so much state that you need a database
16:17:06 <mycroftiv> yeah just to make it specific, what i have is a database/fs engine in forth, and i want to generate valid typechecked (there are a lot of pointer types in it) forth from haskell, so representing the state of the forth stack and the state of an output token stream is in play
16:17:57 <mycroftiv> i have it all working, but since i am a newcomer i am smelling that im probably evolving some mis-patterns
16:19:59 <EvanR> yeah in that case i like the idea of creating an API to access the state, make this API part of your "app monad" perhaps
16:20:17 <EvanR> there are many ways to implement the state but the convenience would come from this API
16:24:07 <mycroftiv> thanks, reading boj's references now, a lot of landscape for me to survey.
16:28:22 <wroathe> phadej: you were not lying https://gist.github.com/JustinChristensen/d25f9b390346396a9d09ab0d1953f3c5
16:28:30 <wroathe> phadej: All that just to print an AST
16:29:36 <zeta_0> how do i open ihaskell in my terminal?
17:01:00 <Boarders> how do I write a parser that does one thing if it encounters the word "let" but doesn't consume "let" if the word is "letter" using megaparsec
17:01:42 <Boarders> I tried: "f <$ (chunk "let")" which is not correct
17:13:00 <EvanR> you'd have to use `try' right
17:13:41 <dmwit> Boarders: try (chunk "let" <* notFollowedBy (chunk "ter"))
17:13:51 <MarcelineVQ> notFollowedBy is also an option, depending on how things are structured overall
17:14:24 <Boarders> sorry I phrased my problem poorly, "letter" could be any word prefix with let
17:14:29 <MarcelineVQ> try, lookAhead, and notFollowedBy are going to be the tools of the trade for this sort of thing
17:14:54 <EvanR> try (chunk "let " >> ...) <|> somethingElse
17:14:56 <Boarders> thanks, looks like notFollowedBy is what I need
17:15:39 <sicklorkin> Boarders: let is always followed by a space?
17:15:42 <MarcelineVQ> have you removed whitespace ahead of time? if not then there's, string "let" <* space1
17:15:53 <Boarders> It might be followed by a newline
17:15:58 <sicklorkin> symbol "let"
17:16:30 <MarcelineVQ> newline is a whitespace character
17:16:37 <sicklorkin> and tell megaparse what to do between parser (how to deal w/the whitespace)
17:16:40 <MarcelineVQ> well, I should doublecheck that, but afaik
17:16:58 <sicklorkin> MarcelineVQ: i think that should right.
17:17:05 <sicklorkin> s/should be right
17:17:09 <Boarders> yes, though I want to treat newline specially
17:17:14 <MarcelineVQ> "Parse a Unicode space character, and the control characters: tab, newline, carriage return, form feed, and vertical tab."
17:17:20 <MarcelineVQ> ok
17:17:37 <sicklorkin> Boarders: what is special about newline?
17:18:06 <Boarders> In what I am writing I am parsing line by line to keep track of indentation information
17:18:13 <MarcelineVQ> If you want special whitespace treatment, possibly including handling blocks of text and indentation, you'll probably want to look at sicklorkin's route, which is https://hackage.haskell.org/package/megaparsec-7.0.5/docs/Text-Megaparsec-Char-Lexer.html
17:18:18 <EvanR> ironically the unicode newline character is not in that list
17:18:44 <sicklorkin> Boarders: manyTill p eof
17:19:45 <MarcelineVQ> https://markkarpov.com/megaparsec/megaparsec.html
17:51:29 <d34df00d> Hi!
17:51:42 <d34df00d> Web UI: Servant vs Yesod?
17:54:08 <Axman6> yes
17:54:13 <Axman6> but maybe no
17:54:48 <d34df00d> Can't unify "yes" and "maybe no".
17:57:11 <Axman6> True \/ False
18:22:10 <pong> :t foldr
18:22:12 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
19:00:51 <dmj`> d34df00d: servant
19:09:38 <___laika> anyone had success using phoityne-vscode and haskell/ghci-dap with vscode to debug haskell programs? im trying to use it with cabal new-*, but i get an error that cabal fails to determine the version of the program when i pass `--with-ghc=haskell-dap`
19:39:13 <manjaroi3__> hi there! can somebody help me out with a function im trying to write?
19:42:47 <manjaroi3__> lets say i have a string "abcd" and i want to sort it based on the string "educfgbah"
19:43:00 <manjaroi3__> so it would give me "dcba"
19:44:13 <manjaroi3__> how can i achieve this? i did it using dictionary for the "educfgbah" string (mapping each char to an index) and then i wrote a version Insertion Sort that accomplishes this 
19:44:47 <manjaroi3__> but i'm sure there already some sorting functions around there that might be way more efficient and occupy less space then my own sorting algorithm
19:44:51 <manjaroi3__> any hint?
19:56:55 <lyxia> manjaroi3__: there's sortBy
19:57:09 <lyxia> :t sortBy
19:57:11 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
19:57:24 <lyxia> :t sortOn
19:57:27 <lambdabot> Ord b => (a -> b) -> [a] -> [a]
19:58:04 <manjaroi3__> lyxia: i am trying to use sortOn 
19:59:11 <manjaroi3__> im thinking of creating a function that gives you the index of a char on the "educfgbah" string
19:59:20 <manjaroi3__> a use that as the argument for sortOn
19:59:24 <manjaroi3__> and*
19:59:39 <lyxia> yes
20:00:17 <manjaroi3__> do you think that it makes more sense for the "educfgbah" string be a dictionary ? (just like i decribed above)
20:00:49 <manjaroi3__> or is there a function on the prelude that gives the index of a char in a string? 
20:00:54 <manjaroi3__> like you would pass in c 
20:00:58 <manjaroi3__> and it would give 4 
20:01:01 <manjaroi3__> (on "educfgbah") 
20:01:33 <lyxia> there's findIndex
20:01:58 <manjaroi3__> :t findIndex
20:02:00 <lambdabot> (a -> Bool) -> [a] -> Maybe Int
20:02:28 <lyxia> but a Map might be more efficient.
20:02:59 <manjaroi3__> very well 
20:03:04 <manjaroi3__> thanks a lot, i will se what i can do
20:26:29 <ysangkok> why is https://github.com/haskell-crypto/cryptonite/blob/master/Crypto/ECC.hs not defining instances for P256K1, but for P256R1?
20:33:22 <lyxia> sounds like a good question for their issue tracker
21:03:27 * hackage shh 0.7.0.2 - Simple shell scripting from Haskell  https://hackage.haskell.org/package/shh-0.7.0.2 (lukec)
21:05:21 <jle`> that's definitely not a typo waiting to happen, heh
21:07:50 <MarcelineVQ> what if it already is, should be called sssh
21:08:52 <glguy> sssfh?
21:10:09 <MarcelineVQ> shhhushhh
21:42:37 <nshepperd> is there a way to make cabal new-build explain why it's trying to build a certain transitive dependency
21:44:18 <nshepperd> (it's failing to solve for process-1.6.5.1 because my ghc version provides process==1.6.5.0)
22:28:52 <nshepperd> huh? and now after deleting .ghc/x86_64-linux-8.6.5/environments/default, running cabal new-update and re-running 'cabal new-install --lib (the libraries i had installed before)' it rebuilt a bunch of stuff and generated a new .ghc/x86_64-linux-8.6.5/environments/default with a bunch of duplicate packages
22:28:58 * hackage functor-products 0.1.0.0 - General functor products for various Foldable instances  https://hackage.haskell.org/package/functor-products-0.1.0.0 (jle)
22:29:20 <nshepperd> like, both text-1.2.3.1 and text-1.2.4.0-bcc81...
22:31:34 <nshepperd> ah right, the first one comes from the system ghc...
22:37:31 <nshepperd> so the answer was to remove 'text' and 'mtl' from my new-install --lib command, so that it stays with the system versions
22:39:57 * hackage sv-core 0.5 - Encode and decode separated values (CSV, PSV, ...)  https://hackage.haskell.org/package/sv-core-0.5 (qfpl)
22:40:58 * hackage sv 1.4 - Encode and decode separated values (CSV, PSV, ...)  https://hackage.haskell.org/package/sv-1.4 (qfpl)
22:52:17 <koz_> Can anyone help me figure out what's happening here? I'm not sure why GHC gives me this error message. https://gist.github.com/kozross/64ec803c0bd2a8e5fe259e3f2081d182
22:56:35 <jle`> koz_: just because you have a Finite 256 Word8 instance doesn't mean that there wouldn't be a Finite 1000 Word8 instance
22:56:46 <jle`> koz_: so just because you know `Finite n Word8`, it doesn't let you infer n
22:57:15 <jle`> would things help if you add the FunDep to Finitary?
22:57:22 <jle`> class Finitary n a | a -> n
22:59:42 <glguy> For relying on using default methods I'd have expected "deriving instance Finitary 258 Foo" to be "instance Finitary 258 Foo"
22:59:52 <jle`> koz_: because of the Generic structure, ghc knows that 258 ~ (?? + ?? + ??), but it isn't sure how to break 258 into three parts 
23:00:01 <glguy> I guess you're relying on DeriveAnyClass?
23:00:13 <jle`> for instance, should it be (100 + 100 + 58)?
23:00:58 <jle`> you would think that knowing you have Word8 would force the last addend to be 256.  *but* we don't know it *has* to be 256, because someone could define an instance for Finitary 100 Word8.  Adding the fundep will mean that knowing we have Word8 will let us know the last item has to be 256
23:04:25 <jle`> pretty much any time you use MTPC's without fundeps, type inference will be a nightmare
23:04:55 <jle`> or if not a nightmare, it'll be something you have to explicitly deal with usually :)
23:08:29 <koz_> Hmm, good point.
23:08:35 <koz_> Thanks, I will add said fundep and try again.
23:08:52 <koz_> Now that you put it that way, I understand why GHC is being extra-conservative here.
23:10:14 <___laika> can i pattern match on nonempty lists similarly to standard lists, perhaps with some combination of extensions?
23:10:50 <dminuoso> ___laika: Well yes.
23:11:05 <dminuoso> f (x :| xs) = ...
23:11:13 <dminuoso> f (1 :| [2,3,4]) = ...
23:11:41 <___laika> oh, somehow i missed that data constructor
23:11:50 <MarcelineVQ> koz_: What are you up to there :>
23:12:13 <___laika> is that data constructor any different from `Data.List.NonEmpty.(<|)`?
23:12:18 <dminuoso> ___laika: Pattern matching generally always works by specifying the pattern exactly how you would have constructed it. :)
23:12:35 <dminuoso> ___laika: Thats not a data constructor.
23:12:40 <koz_> MarcelineVQ: Having fun with mathematically-obvious constructions. :P
23:13:13 <dminuoso> ___laika: If you check the haddoc documentation, then data constructors are always inside their respective data/newtype declarations.
23:13:28 <dminuoso> ___laika: So https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-List-NonEmpty.html#t:NonEmpty lists the data constructors for NonEmpty
23:14:13 <___laika> i think what i meant was, is <| a functional equivalent to that :| constructor?
23:14:16 <koz_> jle`: That helps, but only slightly: https://gist.github.com/kozross/64ec803c0bd2a8e5fe259e3f2081d182
23:14:37 <___laika> the source seems to indicate so
23:14:41 <dminuoso> ___laika: Well to be exact, :| is a function too! :)
23:14:54 <dminuoso> ___laika: But :| doesnt compose nicely because
23:15:06 <dminuoso> (:|) :: a -> [a] -> NonEmpty a
23:15:29 <dminuoso> ___laika: So its slightly different in that <| demands a NonEmpty to its right, and :| demands a list to its right (which could be empty)
23:15:34 <koz_> Is that why it looks like an emoji expressing disappointment, dminuoso?
23:16:04 <___laika> ahhhh
23:16:06 <___laika> dminuoso++
23:16:10 <dminuoso> ___laika: <| is rather the NonEmpty equivalent of (:) in lists (except its not a data constructor)
23:18:02 <dminuoso> ___laika: ⌜1 :| 2 : 3 : 4 : 5 : []⌝ -- this should visualize what I mean.
23:18:37 <dminuoso> % 1 <| 2 <| 3 <| 4 :| 5 : 6 : 7 : []
23:18:38 <yahb> dminuoso: ; <interactive>:338:3: error:; Ambiguous occurrence `<|'; It could refer to either `Data.List.NonEmpty.<|', imported from `Data.List.NonEmpty'; or `Control.Lens.<|', imported from `Control.Lens' (and originally defined in `Control.Lens.Cons'); <interactive>:338:8: error:; Ambiguous occurrence `<|'; It could refer to either `Data.List.NonEmpty.<|', imported from 
23:18:59 <dminuoso> #=> 1 :| [2,3,4,5,6,7]
23:32:30 <dminuoso> What's the closest thing to mimic a big case-of + guards with fallthrough mechanics?
23:33:49 <jle`> koz_: you might need to add it to the GFinitary too
23:33:59 <koz_> The fundep?
23:34:11 <jle`> yeah
23:34:31 <koz_> That did it!
23:34:36 <jle`> basically, be extremely suspicious of any MPTC without a fundep :p
23:34:48 <jle`> they pretty much never infer correctly
23:34:50 <koz_> Lesson firmly learned.
23:34:50 <jle`> without extra help
23:34:52 <jle`> :D
23:34:59 <koz_> Now I have my clever scheme working, thanks!
23:35:03 <jle`> clever indeed :)
23:35:04 <koz_> Time to write a whole tonne of instances.
23:35:35 <MarcelineVQ> dminuoso: I don't understand youe question :X
23:36:30 <dminuoso> MarcelineVQ: What I'd ideally like is somet: ⌜traverse_ ($ Just 25) [(\(Just x) -> print "its a just"), (\(Just x | x > 10) -> "and its bigger than 10"), (\Nothing -> print "its nothing")]⌝
23:37:11 <dminuoso> Oops
23:37:16 <dminuoso> ⌜traverse_ ($ Just 25) [(\(Just x) -> print "its a just"), (\(Just x | x > 10) -> print "and its bigger than 10"), (\Nothing -> print "its nothing")]⌝
23:37:17 <dminuoso> Sort of.
23:37:57 * hackage decidable 0.2.0.0 - Combinators for manipulating dependently-typed predicates.  https://hackage.haskell.org/package/decidable-0.2.0.0 (jle)
23:38:53 <jle`> are those lambdas supposed to be like data structures?
23:38:59 <jle`> or can they be actual functions
23:39:20 <jle`> because you can do (a -> First Res) and then foldMap on all of them maybe
23:40:37 <jle`> i guess it all depends on what you want to do with it
23:41:07 <dminuoso> jle`: Heh that'd just be regular pattern matching.
23:41:08 <dminuoso> jle`, MarcelineVQ: https://gist.github.com/dminuoso/7aa6bf42669c046e8e0e0e65c4ba3059 I'd like something visually as clean but such that each case is tested separately (sort of like a multi-way when)
23:41:08 <dminuoso> Or rather a when-of, if that makes sense. :P
23:41:54 <dminuoso> Such that if you did "f (Just 12)" you'd get "It'a a Just\nIt's an even number\nIt's a large number
23:42:04 <jle`> are you trying to write a DSL or something maybe?
23:42:17 <jle`> because right now it just sounds like you are asking "what is the closest thing to X?", without any restrictions
23:42:25 <jle`> it's hard to know why X itself is not adequate
23:42:56 <jle`> the way i'm reading it maybe you're designing a language implementation with an AST and you want to define a way for that AST to represent case statements?
23:43:01 <dminuoso> jle`: I have this struct, and I want to pattern match multiple times on each. Each time a pattern match succeeds, I want to execute some action.
23:43:35 <jle`> what's the fallthrough mechanic here?
23:43:53 <dminuoso> jle`: Always. There's no sort of "break"
23:44:38 <jle`> so you mean if the first statement matches, then all of the statements will be "run"?
23:44:58 <dminuoso> jle`: Well basically imagine each case being wrapped inside "when"
23:45:21 <MarcelineVQ> jle`: he wants to run every statement that matches
23:45:26 <dminuoso> jle`: Sort of like: when (thingHasOddNumberOfCards c) (print "its odd"); when (blah) (do something else)
23:45:27 <jle`> will it skip over statements that don't match?
23:45:31 <jle`> ah, okay
23:45:37 <jle`> so not "fallthrough", but "jumparound"?
23:45:39 <dminuoso> Except I cant bind the patterns with just issueing many when
23:46:15 <koz_> :t fromIntegral
23:46:18 <lambdabot> (Integral a, Num b) => a -> b
23:46:45 <jle`> dminuoso: i'd just maybe make a list of actions and then sequence_ them
23:47:13 <jle`> also you can use list's MonadPlus instance maybe
23:47:43 <jle`> hm
23:48:10 <jle`> because you can do [ print "It's a just" | Just _ <- x ], and that'll be empty if it fails, and just the print IO otherwise
23:50:03 <jle`> so \x -> do sequence_ [ print "It's a just" | Just _ <- x]; sequence_ [ print "it's bitter than 10" | Just y <- x, y > 10 ]; sequence_ [ print "It's nothing" | Nothing <- x ]
23:50:10 <jle`> or mconcat them all and sequence_ it all at once, maybe
23:50:37 <jle`> sequence_ $ [ ... ] <|> [ ... ] <|> [ ... ]
23:54:33 <koz_> Hmm, Int and Word instances of Finitary are going to be an issue.
23:57:29 <jle`> koz_: the only way that would make sense might be to have it compile differently for different architectures, unfortunately maybe
23:57:53 <koz_> jle`: Yeah, that's unfortunate. I might punt that one for later.
23:58:30 <jle`> you could do that using some inline TH splices i think?
23:58:35 <koz_> jle`: Also, I'm now getting a different kind of issue: https://gist.github.com/kozross/64ec803c0bd2a8e5fe259e3f2081d182
23:59:13 <jle`> koz_: b could be coercible to more than one other type
23:59:29 <jle`> so if you coerce it to X, it might have a different 'n' than if you coerce it to Y
23:59:42 <koz_> Is this me assuming GHC knows more than it actually does again?
23:59:53 <jle`> the error here is that it can't infer 'n' from 'b', which is what b -> n means
