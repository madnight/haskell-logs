00:00:43 <glguy> Because spj doesn't trust fun deps
00:01:18 <glguy> And for a while bugs in GHC would have made that behavior unsound
00:38:04 <jle`> if the bugs already exist then wouldn't this not cause anything to break that was previously working?
00:38:17 <jle`> hm that was weirdly phrased
00:38:41 <jle`> i guess it acts like an airlock on bad behavior
00:38:50 <jle`> (from bugs)
01:30:14 <haasn> Given two sorted lists of integers A and B, can you come up with a creative/short way to find all pairs (a, b) <- A × B such that the difference |a - b| ≤ d?  The obvious brute force is to compute the actual cross product, but this is wasteful
01:31:29 <jgt> haasn: I guess a list comprehension counts as brute force, right?
01:32:15 <haasn> The most straightforward "efficient" approach would be to crawl through both lists, removing the smaller of the two heads until the condition is satisfied, although it's not immediately clear to me what the correct way to continue after that is
01:33:15 <haasn> jgt: If you mean [ (a, b) |  a <- as, b <- bs, abs (a - b) <= d ] then yes, that's brute force :p
01:34:02 <jgt> yeah that's what I would have done
01:34:07 <jgt> but I'm rubbish at computers
01:35:41 <haasn> Hmm. If both lists are of the form `replicate n 1`, then there will be n^2 results, so in some sense, the worst case is O(n^2) which the brute force approach matches
01:36:10 <haasn> But I can also assert that they are strictly ascending, i.e. no duplicates
01:37:05 <haasn> Or I could simply modify the problem to claim that the output should contain no duplicate pairs, which makes `nub [ ... ]` the wasteful approach
01:37:32 <merijn> haasn: Do you care about preserving order?
01:37:39 <haasn> No
01:37:55 <merijn> haasn: Probably a combination of dynamic programming + IntSet is the way to go?
01:38:02 <haasn> In some sense, the input and result can be made Set
01:38:08 <merijn> IntSet should have a way to query the minimum element
01:39:47 <merijn> Although, if the goal is to be fast, it might be substantially faster to just convert the list into two sorted vectors and write the naive logic
01:40:00 <merijn> Because the naive logic has pretty good locality
01:40:12 <lavalike> :t Data.Set.lookupMin
01:40:15 <lambdabot> S.Set a -> Maybe a
01:40:38 <merijn> And continuously manipulating IntSet is still going to result in lots of copying and pointer chasing
01:42:42 <merijn> In conclusion: Arrays are the universal HPC data structure
01:43:53 <haasn> Yeah, I think that's the best approach here. I guess something like  go (x:xs) ys = takeWhile (< x + d) ys' ++ go xs ys' where ys' = dropWhile (< x - d) ys
01:44:27 <haasn> plus whatever tuple finagling
01:44:37 <merijn> That, but with Vector ;)
01:45:24 <haasn> Actually the worst case is O(n^d) even with not caring about duplicates
01:45:27 <haasn> Just pick `d` large enough
01:45:40 <haasn> I guess that makes this the optimal algorithm
01:45:51 <haasn> In the best case it matches the expected O(n)
01:54:27 * hackage apecs-gloss 0.2.2 - Simple gloss renderer for apecs  https://hackage.haskell.org/package/apecs-gloss-0.2.2 (jonascarpay)
02:09:13 <pie_> implementation: hey, are you the maintainer of haskell libzfs?
02:48:17 <implementation> pie_: hey, yes I am!
02:48:19 <implementation> pie_: let me guess, it needs some updates? :D
02:49:30 <pie_> implementation i wish i was that far :P
02:49:44 <pie_> my question is how much coverage it has / how well it works
02:50:04 <pie_> i had the terrible idea of trying to write some sort of edsl for dealing with some zfs stuff
02:50:27 <pie_> im not even sure what im doing but obviously its going to need some sort of zfs binding
02:50:28 * hackage hdocs 0.5.3.2 - Haskell docs tool  https://hackage.haskell.org/package/hdocs-0.5.3.2 (AlexandrRuchkin)
02:56:31 <implementation> pie_: i have to confess that i didn't touch it any more for two years, and cannot guarantee it works with current versions. But back then, all the functions that are listed in the haddocks worked. So that includes creating, mounting and destroying zpools and datasets, and iterating through them. Some edge cases may lack proper handling though.
02:57:30 <implementation> pie_: one of the problems i faced is that (the original C) libzfs isn't really extensively documented, and i spent a lot of time crawling through the source code of the command line tools
02:59:59 <implementation> (oh, and be careful when testing it. destroyZpool really does destroy your pool without any further questions)
03:03:49 <pie_> yeah im not liking the documentation...
03:04:01 <pie_> i hope you added notes to your code :P
03:04:23 * jgt feels the tension rising
03:04:36 <pie_> heh, i need to be very careful to run that in a vm then
03:05:08 <pie_> well im assuming zfs 0.8 is a major release so....
03:05:12 <pie_> probably needs updates
03:05:28 <pie_> implementation do you know if anyone uses your library?
03:06:18 <implementation> pie_: i have no idea, you're the first one ever mentioning it
03:06:39 <pie_> wooohoo... xD
03:09:15 <implementation> ok, i'll make myself a coffee now, update zfs to 0.8 on my machine and try if the library still works for me
03:30:29 * hackage hsdev 0.3.3.3 - Haskell development library  https://hackage.haskell.org/package/hsdev-0.3.3.3 (AlexandrRuchkin)
03:34:27 * hackage text 1.2.4.0 - An efficient packed Unicode text type.  https://hackage.haskell.org/package/text-1.2.4.0 (HerbertValerioRiedel)
03:38:28 * hackage parsec 3.1.14.0 - Monadic parser combinators  https://hackage.haskell.org/package/parsec-3.1.14.0 (HerbertValerioRiedel)
03:53:57 * hackage cabal-fmt 0.1 - Format .cabal files  https://hackage.haskell.org/package/cabal-fmt-0.1 (phadej)
03:59:57 * hackage graphql-w-persistent 0.5.0.0 - GraphQL interface middleware for (SQL) databases.  https://hackage.haskell.org/package/graphql-w-persistent-0.5.0.0 (jasonsychau)
04:03:44 <haasn> implementation: thanks for this
04:03:56 <haasn> `destroyZpool` will now replace `launchMissiles` in my examples
05:20:48 <saulzar_> If I have some transitive dependency which does not compile - does anyone know if I can get cabal to tell me the "path" to that dependency?
05:27:52 <sicklorkin> saulzar_: are you getting a linker error?
05:28:26 <saulzar_> sicklorkin, No just a compile error because a package must have added a new instance
05:29:16 <sicklorkin> saulzar_: in that case could you check the search paths?
05:30:18 <saulzar_> sicklorkin, I don't mean the filesystem path I mean the transitive dependency path... i.e. what library which I directly depend on brought in this other library (which fails to compile)
05:32:50 <sicklorkin> I see. hummm
05:34:51 <juri_> does anyone really know their optparse-applicative? I need to accept some "-Dvar=val" options...
05:35:37 <sicklorkin> saulzar_: https://packdeps.haskellers.com/reverse doesnt do you any good does it?
05:36:52 <saulzar_> Not really - I guess the problem is maybe more complex than I thought though..
05:36:57 <saulzar_> I think I figured it out, text released a new version with a new instance which conflicts with one in th-lift-instances
05:37:45 <saulzar_> But my library does not even depend on text, which is annoying - do you then make it a dependency just to have the upper bound?
05:40:39 <sicklorkin> saulzar_: if everyone depends on text anyway, which i'm not saying they do, then does it make it acceptable?
05:42:02 <saulzar_> yeah, it probably doesn't change much, but still. Maybe a cabal.project.freeze is the right way to do it
05:42:21 <sicklorkin> then ofc the burden of carrying dead weight
06:11:56 * juri_ stares at optparse-applicative documentation.
06:23:27 * hackage modern-uri 0.3.1.0 - Modern library for working with URIs  https://hackage.haskell.org/package/modern-uri-0.3.1.0 (mrkkrp)
06:27:49 <lavalike> juri_: have you reached enlightenment
06:28:26 <juri_> negative.
06:31:45 <juri_> i've confirmed that the author thinks what i'm wanting to do is possible...
06:32:04 <c_wraith> that's an excellent start
06:33:45 <lavalike> as long as it is not parsing options in an applicative manner
06:33:54 <CoolerZ> perhaps this is offtopic but are there any advantages to using haskell over rust?
06:34:12 <lavalike> no
06:34:24 <CoolerZ> seems like rust has most of the abstractions and guarantees that haskell has
06:34:36 <CoolerZ> including meta programming
06:35:54 <CoolerZ> is it better to write haskell because you don't have to worry about 3rd party code doing unsafe operations?
06:38:38 <juri_> https://github.com/pcapriotti/optparse-applicative/issues/284
06:38:57 <juri_> so, they seem to think -c name=value is possible...
06:38:59 <sarahzrf> rust isnt pure & is less naturally functional
06:39:07 <sarahzrf> s/naturally/idiomatically
06:39:17 <juri_> but i have no idea how to do it.
06:39:31 <sarahzrf> it also isnt lazy, which may be a bonus depending on your pov
06:39:58 <sarahzrf> bbl
06:40:57 <lyxia> juri_: in the language of optparse-applicative that could be a -c option with a "name=value" argument
06:41:00 <CoolerZ> yeah laziness is a big difference
06:41:20 <c_wraith> CoolerZ: you give up precise memory control so that your program doesn't need to be dominated by thinking about precise memory control
06:41:33 <juri_> lyxia: sure, but how do i have multiple '-c' options?
06:42:05 <CoolerZ> c_wraith, it doesn't need to be, rust has abstractions to take care of that if you don't want o
06:42:06 <CoolerZ> to
06:42:46 <CoolerZ> precise memory control in rust is more like a feature than a requirement
06:43:24 <c_wraith> That's like saying being well-typed is not a requirement of haskell
06:44:12 <CoolerZ> c_wraith, no
06:44:51 <CoolerZ> c_wraith, where exactly are you required to think explicitly about memory layout in rust?
06:44:58 <c_wraith> not layout, lifetime
06:45:15 <c_wraith> the whole point of rust is that you must always be precise about ownership and lifetime
06:45:15 <CoolerZ> right lifetime is another big difference
06:47:17 <lyxia> juri_: I see.. sorry I don't know.
06:47:41 <c_wraith> Also, rust is definitely lacking in abstraction features like higher-rank types and abstraction over higher-kinded types.  You can't write something like the ST type (along with runST) in rust.  You can't write something like the Traversable class in rust.
06:48:15 <c_wraith> It doesn't even have an IO type!
06:48:30 <c_wraith> so procedures are just sort of always implicitly there, whether you want them or not
06:49:27 <c_wraith> Rust is a fantastic replacement for C or C++, when you want to work close to the metal and have a lot of control.
06:49:44 <juri_> lyxia: thanks anyways.
06:51:00 <CoolerZ> c_wraith, " You can't write something like the ST type (along with runST) in rust." you mean without macros?
06:51:35 <c_wraith> CoolerZ: I mean at all.  You can't brand a type such that values of that type created in one context are unusable in other contexts
06:53:32 <CoolerZ> "You can't write something like the Traversable class in rust" they have iterators
06:53:39 <CoolerZ> and type traits
06:53:53 <c_wraith> but they can't express Traversable
06:56:52 <c_wraith> Traversable is more than just linear iteration.  It also provides constructing new values.
07:02:45 <CoolerZ> c_wraith, uh so what is the issue?
07:02:45 <c_wraith> > traverse (\x -> [x, -x]) [1, 2, 3] -- CoolerZ: for instance, you can't do this with an iterator.  Maybe a bunch of them, but not in a single iteration
07:02:48 <lambdabot>  [[1,2,3],[1,2,-3],[1,-2,3],[1,-2,-3],[-1,2,3],[-1,2,-3],[-1,-2,3],[-1,-2,-3]]
07:03:47 <c_wraith> CoolerZ: rust doesn't have the abstraction over higher-kinded types necessary to express what Traversable does
07:04:29 <CoolerZ> but with macros the type system is turing complete
07:05:09 <c_wraith> it's not about computing types
07:05:23 <c_wraith> :t traverse
07:05:25 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
07:08:10 <c_wraith> it's about being able to abstract over the types t and f in that signature, even though they are higher-kinded.  That is, they're type constructors that need additional type arguments to be complete enough that you can actually create values.
07:09:11 <c_wraith> Rust has higher-kinded types all over the place - whenever a type takes a parameter, it's higher kinded.  What the language doesn't have is any way to write abstractions that apply to the higher-kinded type directly, instead of when it's been fully-applied
07:10:57 * hackage stache 2.1.0 - Mustache templates for Haskell  https://hackage.haskell.org/package/stache-2.1.0 (mrkkrp)
07:11:44 <c_wraith> Traversable is sort of a double-whammy here.  Many other common examples of abstracting over higher kinded types, like monads, can be done in Rust if you don't care about abstracting over all of them at once.
07:12:20 <c_wraith> But Traversable, by design, requires you to write an instance of traverse for a particular type t that works for all types f.
07:13:07 <c_wraith> Which therefore means you can only even express the idea if you can abstract over all applicative functors at once.
07:25:02 <lavalike> juri_:  many <$> strOption (short 'c')  gives  <<loop>>  as a value, perfect! (and fails with multiple -c's) I have no idea
07:45:56 <duncan> I am not getting very relevant results when searching Hoogle. Is there a way to search for an absolute term, similar to how one can put things in quotation marks on search engines?
07:46:12 <duncan> E.g. "tasty map" vs what I assume would search for tasty and/or map
07:46:22 <duncan> (as an example. I don't really want to find tasty maps.)
07:59:27 <fendor> duncan, for functions, you can use "is:exact" e.g. "take is:exact"
07:59:56 <fendor> works also for function signatures
08:00:27 <fendor> you can also limit the packages you want to search in
08:01:53 <duncan> I think I made a mistake there - I was referring to Hackage :/ sorry!
08:02:01 <duncan> but that is useful too, thanks!@
08:10:38 <fendor> duncan, what are you exactly looking for? A package category? 
08:11:24 <duncan> Well, for instance, if one searches "topic maps", one finds various packages that mention just one of them (be they "topic", or "maps").
08:11:35 <duncan> It might be a "me" thing though
08:12:15 <fendor> isnt hoogle doing about that? 
08:12:26 <fendor> isnt hoogle roughly doing that?
08:12:31 <duncan> Ah, I am talking about Hackage right now..
08:12:57 <duncan> Just to clarify, I did not mean to write Hoogle, but wrote it by mistake.
08:14:22 <duncan> It is a slightly obscure standard that is used for storing data about things and I was curious if anyone had made anything already.
08:16:19 <duncan> and, I find it difficult to believe all the packages that are returned are relevant, given they are mostly about a different type of map.
08:48:17 <aoeu256> Are there easy to use compiler functions that take in abstract Haskell code and then use substitution/rewrite rules to get rid of the abstractions?  It would be nice if there was an IDE that let you automatically see your code in different ways, that would be a killer app for pure functional programming.
08:48:44 <infinisil> That would be pretty cool yeah..
08:49:45 <aoeu256> wasn't there a bot here that did something like that?  I'm a Haskell noob.
08:50:24 <infinisil> @src foldl
08:50:25 <lambdabot> foldl f z []     = z
08:50:25 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
08:50:33 <infinisil> Maybe you're thinking of this?
08:51:15 <wroathe> http://hackage.haskell.org/package/template-haskell-2.14.0.0/docs/Language-Haskell-TH-Quote.html Anyone know where the default QuasiQuoters are initialized? I can't seem to find them in the source.
08:51:18 <aoeu256> how do you use lambdabot from within ghci?
08:51:26 <wroathe> d, e, t, and p?
08:52:29 <merijn> aoeu256: You don't? lambdabot isn't related to ghci at all
08:53:34 <aoeu256> i mean is there a template haskell library out there that has all the quasiquote lambdabot thingies haha
08:53:56 <merijn> aoeu256: Which quasiquote thingies of lambdabot?
08:54:35 <wroathe> If you really wanted to talk to lambdabot from ghci you could install lambdabot and define a command to access it... :def hoogle \s -> return $ ":! hoogle --count=15 \"" ++ s ++ "\""
08:54:53 <aoeu256> like a library to add sugar and remove sugar from your code
08:54:57 <merijn> wroathe: It'd be more logical to install Hoogle
08:55:05 <lyxia> wroathe: they aren't regular quasiquotes
08:55:08 <merijn> aoeu256: I only know about undo, tbh
08:55:21 <wroathe> lyxia: Ah, so the default ones don't use this API
08:55:24 <merijn> aoeu256: @src is just "Map String String" that lists code copied from the Haskell2010 report
08:55:39 <merijn> aoeu256: It doesn't give you the actualy source used by GHC/base
08:56:26 <wroathe> lyxia: Regardless, do you happen to know which part of GHC they're defined in off the top of your head? If not I'll keep poking around.
08:56:34 <aoeu256> GHC base is the desugared syntax tree of haskell?
08:56:53 <merijn> aoeu256: base is the standard library that ships with GHC
08:57:14 <merijn> aoeu256: i.e. the library that has things like map, foldr, and tons of other stuff in it
08:57:15 <aoeu256> oh yeah that
08:57:23 <merijn> @src sort
08:57:23 <lambdabot> sort = sortBy compare
08:57:35 <lyxia> wroathe: I don't know :/
08:57:48 <merijn> Oh, wait I meant
08:57:50 <merijn> @src sortBy
08:57:50 <lambdabot> -- The actual definition used by GHC is an optimised mergesort.
08:57:50 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
08:57:56 <aoeu256> @src (>>=)
08:57:56 <lambdabot> Source not found. Sorry.
08:58:02 <merijn> aoeu256: Compare with the *actual* implementation: https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.OldList.html#sort
08:58:28 <infinisil> Brings me back to wanting to see how an ST would perform
08:58:46 * infinisil looks for libraries implementing different sorts
09:02:30 <infinisil> There's https://hackage.haskell.org/package/vector-algorithms
09:02:55 <infinisil> Unfortunately those can't be used with lazy ST
09:03:21 <EvanR> that sortBy is so cute
09:07:37 <wroathe> Heh, GHC uses alex/happy for lexing/parsing. That's kind of neat.
09:07:42 <wroathe> I was expecting more Bison
09:07:52 <merijn> wroathe: Why would it use bison?
09:08:22 <EvanR> flex is the gnu version of alex right
09:08:37 <merijn> I'd say alex is the Haskell version of flex, but yes
09:08:39 <EvanR> bison is the gnu yacc
09:08:41 <wroathe> merijn: Just because of popularity/ubiquity 
09:09:13 <merijn> wroathe: That'd require a parser written in C or using FFI, though, because that'd what bison exposes
09:09:30 <merijn> Which is problematic, because for the first versions of GHC there was no standardised FFI :p
09:09:47 <merijn> Since that was added as an addendum to Haskell98
09:10:08 <wroathe> merijn: I'm guessing the first incarnations of GHC were written in C
09:10:22 <EvanR> thankfully no
09:10:27 <wroathe> merijn: Also maturity, Yacc being like 50 years old or so
09:10:27 <merijn> wroathe: No, in Haskell
09:10:39 <merijn> GHC has never been written in C
09:10:47 <merijn> (runtime excepted)
09:10:47 <EvanR> it was originally in a version of lazy ML
09:10:51 <merijn> EvanR: No
09:11:06 <EvanR> no?
09:11:10 <merijn> EvanR: The first Haskell compiler was written in lazy ML
09:11:16 <merijn> EvanR: GHC was not the first Haskell compiler
09:11:16 <EvanR> oh
09:11:24 <EvanR> HBC
09:11:25 <merijn> EvanR: Lennart's HBC was the first Haskell compiler
09:11:32 <wroathe> merijn: I'm confused. How does one write a compiler for a language in a language that the compiler is designed to compile for the first time ever?
09:11:35 <EvanR> right
09:11:41 <wroathe> Ah
09:11:42 <wroathe> I see
09:11:44 <merijn> wroathe: By having another compiler for that language already :)
09:12:22 <wroathe> This makes more sense now
09:12:31 <wroathe> Did happy/alex predate GHC?
09:12:47 <merijn> I would guess so, but I'm not sure
09:13:02 <merijn> wroathe: Before the era of GHC dominance there was quite some competition for Haskell compilers
09:13:06 <EvanR> it seems absurd now to have libraries that don't need GHC
09:13:20 <merijn> HBC, then Gofer, which became Hugs, there's UHC too
09:16:57 <vaibhavsagar> I tried building Hugs with a newer Cabal the other day, and all my attempts failed
09:17:10 <merijn> vaibhavsagar: Why would that work?
09:17:11 <vaibhavsagar> even versions of Cabal that ostensibly still supported Hugs
09:17:25 <merijn> vaibhavsagar: Hugs can't be compiled with Cabal, because it's not written in Haskell
09:17:30 <vaibhavsagar> merijn: even version 1.8.0.4
09:17:36 <merijn> vaibhavsagar: Cabal versions that support Hugs support using Hugs as a compiler
09:17:50 <vaibhavsagar> merijn: Hugs also bundles its own Cabal
09:18:11 <merijn> vaibhavsagar: So does GHC, in fact, that's the way you implement the CABAL spec as a compiler
09:19:08 <vaibhavsagar> merijn: sure, but you should be able to update the bundled Cabal, no?
09:19:26 <merijn> I don't know, tbh
09:19:38 <vaibhavsagar> anyway, it was just an experiment
09:19:56 <vaibhavsagar> it would have been nice if it had worked
09:20:33 <vaibhavsagar> I'm curious how much of Hugs I can update and still have it compile correctly
09:20:47 <vaibhavsagar> e.g. `array` only dropped support for Hugs a few versions ago
09:32:09 <ski> wroathe : "How does one write a compiler for a language in a language that the compiler is designed to compile for the first time ever?" -- one possibility is to write the initial version in the intersection of the new language and the old (perhaps with some CPP sprinkling)"
09:32:28 <ski> (the Melbourne Mecury Compiler did that)
09:33:16 * geekosaur wonders how much LML counts here
09:33:17 * ski misses having augustss on the channel, a bit
09:33:27 <merijn> There's really only two ways to bootstrap a compiler: 1) Use an existing compiler for your target language, or 2) write it in a different language, then rewrite
09:33:32 <merijn> ski: Yeah
09:34:21 <wroathe> In other news I'm pretty unimpressed with the landscape of Haskell template engine libraries
09:35:42 <wroathe> This seemed to be a good option: http://hackage.haskell.org/package/heterocephalus, but the author is wasting time debating the intrinsic value of having comments in the template syntax: https://github.com/arowM/heterocephalus/issues/21
09:36:56 <freeman42x> does this look like idiomatic Haskell or can the code be further improved? https://github.com/fairy-tale-agi-solutions/fairy-tale-artificial-general-intelligence-solutions/blob/master/Sources/Razvan%20Flavius%20Panda/Haskell/artificial-general-intelligence/src/Lib.hs#L8-L14
09:38:09 <wroathe> I think Haskell mustache is what it's going to have to be
09:39:08 <merijn> freeman42x: I'd say prefer case of if/then/else there
09:39:23 <merijn> freeman42x: That'd also get rid of the let
09:40:23 <freeman42x> merijn, why would it get rid of the let? I mean I can get rid of the let right now by inlining
09:40:55 <merijn> freeman42x: Something along the lines of: https://paste.debian.net/1095246/
09:41:34 <freeman42x> merijn, ohhhhhhhhhhh, yeah that's nice. thank you
09:41:50 <geekosaur> it's more natural to "inline" with case, because you're not possibly obscuring things with a comparison op
09:42:06 <merijn> freeman42x: Has the added bonus of case always working, == doesn't always
09:42:40 <merijn> freeman42x: i.e. if a datatype contains something without an Eq instance, case on the other hand always works
09:44:48 <freeman42x> merijn, that's fascinating. makes me wonder HOW would case work without Eq? I mean, it still needs to compare the value to the case branch value
09:45:11 <geekosaur> case matches constructors
09:45:31 <merijn> freeman42x: case is builtin and fundamental part of how datatypes are defined, Eq is just a library function
09:45:31 <geekosaur> that doesn't require Eq because every value has a constructor tag somewhere underneath
09:46:02 <merijn> geekosaur: Well, some unlifted values don't, but then GHC knows about all possible types of unlifted values :)
09:46:03 <geekosaur> (==) requires an Eq instance to tell it what to do, whereas consturctor tag checking is intrinsic
09:46:17 <geekosaur> these days that's hidden in the kind
09:46:32 <geekosaur> or sort, maybe
09:46:48 <geekosaur> then again with TypeInType it's all confuzzled :)
09:47:43 <merijn> freeman42x: I guess the simplest answer is "the spec defines case such that it must always work and figuring out how is the compiler's problem" :p
09:47:45 <freeman42x> I understand, thank you for the improvements. I made those changes and removed the Eq constraint since it is not needed anymore
09:56:12 <freeman42x> is there any way to get the worldLine to use a reference instead of a value? that would be for space storage issues https://github.com/fairy-tale-agi-solutions/fairy-tale-artificial-general-intelligence-solutions/blob/master/Sources/Razvan%20Flavius%20Panda/Haskell/artificial-general-intelligence/src/Lib.hs#L39
09:58:36 <merijn> freeman42x: What do you mean by that, exactly?
09:58:38 <dmwit> What is a reference?
09:59:43 <dmwit> (I mean, I know what is usually meant by a reference. But the usual meaning doesn't appear useful to me for addressing space concerns, so I wonder what reference means to you.)
09:59:56 <merijn> freeman42x: Keep in mind that, since everything is immutable, passing values to functions is generally *always* by reference, and not by copying
10:00:26 <freeman42x> a reference as in an object reference in C#. The issue is that there are going to be multiple WorldState values containing exactly identical WorldState values in their worldLine. This would lead to huge waste of memory. Having references instead would save on the space consumption
10:00:46 <dmwit> This will already be done automatically for you.
10:01:08 <merijn> freeman42x: Values are generally never copied when you store them in containers, pass them to functions, etc.
10:01:25 <merijn> freeman42x: Since they can never change, there's no real point in bothering to copy them
10:01:49 <freeman42x> yeah, that is not the problem
10:01:56 <freeman42x> the problem is storing the exact same data multiple times
10:01:59 <merijn> freeman42x: (The compiler *may* decide to copy them if it thinks it's worth it for speed, so that'd generally apply to Int, etc.)
10:02:16 <merijn> freeman42x: You mean your constructing the same values repeatedly and want to deduplicate them?
10:02:22 <freeman42x> yes
10:03:14 <merijn> freeman42x: Is this some kinda dynamic programming-y thing where you want to memoise function results?
10:03:19 <dmwit> freeman42x: If I write `foo x = [x, x, x]`, the resulting list does not use three times as much memory as the input does.
10:03:26 <dmwit> It is already a list with three references to the same x.
10:03:41 <freeman42x> worldLine is used to store past world states. Which means that if you access the worldLine of the present and the worldLine of the first world state inside the worldLine of the present you are going to get lots of duplicated worldstates
10:03:55 <merijn> dmwit: No, I think what he means is that he has a function "foo :: a -> b -> X" and he ends up returning lots of X's that are equivalent but constructed independently
10:04:12 <dmwit> I'm not so sure that's true.
10:04:23 <merijn> Sounds like me like a case for memoisation or one of those dynamic programming-y tricks of storing things in a data structure and performing lookups
10:04:29 <dmwit> I understand that concern, but that isn't what freeman42x appears to be describing in his latest message.
10:04:36 <merijn> hmm
10:05:31 <dmwit> freeman42x: Could you cook up a small (<10-12 lines or so) example that you think produces a lot of duplicate objects, so we can talk about something concrete?
10:06:07 <dmwit> I think it's most likely that just writing the obvious code will do the deduplication you want to do automatically. But it's tough to say for sure with such abstract descriptions of the code.
10:06:47 <dmwit> (I think it goes without saying that the example, though stripped down, should more or less capture the behavior your bigger example will have.)
10:10:52 <freeman42x> it's much easier to give an example than to write code to explain this. Consider the following. You have 2 world states: 1 in the present and 1 world state taken 5 minute ago. Each of those worldstates will contain a worldline which is basically the history of all that happened in let's say... the last 10 days. The vast majority stored in the worldline data of those 2 world states is the same since it is the exact same 
10:10:52 <freeman42x> history.
10:12:32 <CoolerZ> why does this compile? https://repl.it/repls/BriskCapitalPrinter
10:13:04 <freeman42x> My issue is how to avoid wasting space. In C# that could be avoided by using references: worldstates inside the worldlines that are the same would reference to the same worldstate
10:14:02 <freeman42x> CoolerZ, why would it not compile? I don't see any issues
10:15:38 <orzo> it's missing Blue case
10:15:44 <orzo> but haskll alows that
10:16:09 <CoolerZ> orzo, why
10:16:32 <CoolerZ> I distinctly remember getting a incomplete pattern match error on compilation some years ago
10:16:38 <freeman42x> oh, I see what the problem is. Missing treating one of the cases
10:16:40 <smatchcube> CoolerZ, you can tell the compiler to warn you about incomplete pattern matching
10:16:44 <CoolerZ> was that in another language? I could have sworn it was haskell
10:17:08 <freeman42x> there is some compiler setting which you can enable so it doesn't build if you don't handle all the cases iirc
10:17:23 <CoolerZ> orzo, was there a recent change?
10:17:42 <CoolerZ> why would haskell allow this?
10:18:57 <CoolerZ> freeman42x, I think your world state world line example is really not helpful
10:19:24 <CoolerZ> you have not given any actual code that creates all these copies you are talking about
10:19:27 <freeman42x> CoolerZ, 1. Haskell assumes that the coder knows what they are doing and that there can be no other cases that need to be handled 2. bad language design 3. both of the previous reasons
10:19:30 <orzo> well, sometimes you know cases wont occur
10:19:50 <CoolerZ> orzo, but this is a very simple case that should probably be checked
10:20:00 <CoolerZ> I saw that example here https://www.fpcomplete.com/blog/2018/10/is-rust-functional
10:20:07 <CoolerZ> Rust checks this
10:20:23 <orzo> so does haskell with Wincomplete-patterns
10:20:24 <CoolerZ> I think it might be worthwhile to check this for enums and very simple cases
10:20:31 <CoolerZ> orzo, by default
10:20:37 <CoolerZ> as an error, not a warning
10:20:47 <orzo> it's too late for that
10:20:58 <CoolerZ> I mean here it even knows that the input will miss all the patterns
10:21:09 <orzo> it's always been this way
10:21:18 <CoolerZ> static analysis should be able to find that easily
10:22:50 <orzo> having head in the Prelude is bad too
10:22:54 <orzo> do you want it out?
10:23:10 <freeman42x> CoolerZ, use -fwarn-incomplete-patterns . Haskell has some bad default as I said. Next thing you could ask is why head function throws on empty list. There are lots of issues like this and there are lots of fixes for the problems also
10:23:17 <CoolerZ> orzo, that might break code
10:23:21 <CoolerZ> if you remove head
10:23:43 <freeman42x> orzo, lol, we gave the same example
10:24:08 <CoolerZ> this change shouldn't break code that isn't broken already
10:24:52 <CoolerZ> specifically I am talking about when you know the input at compile time and can see with simple static analysis that it will miss all patterns
10:25:02 <CoolerZ> you know very very simple cases
10:25:45 <CoolerZ> usually happens when you refactor some parts of your code but not everything\
10:36:17 <orzo> I don't see the difference between using head and not saturating a pattern space
10:50:50 <glguy> orzo: better error message and a warning to fix it later when using Wall
10:54:25 <CoolerZ> orzo, I think you missed a important point
10:55:17 <CoolerZ> if you know the input and know that input will miss all the patterns then the compiler should give an error
10:55:58 <CoolerZ> for example: head [] should give a compile time error
10:56:26 <CoolerZ> head foo probably shouldn't unless you can somehow prove foo will always be empty
10:56:59 <CoolerZ> the problem with the code example I gave earlier was that the compiler can tell that Blue would not get handled
10:57:44 <CoolerZ> I am saying you can change the behavior of the compiler to give an error message in those cases without breaking code that is not already broken
10:59:09 <CoolerZ> orzo, yes in general you trust the programmer that they know what they are doing and the missing cases will never occur
10:59:29 <CoolerZ> but sometimes you can tell the programmer made a semantic mistake and the compiler can give an error
11:00:05 <CoolerZ> changing the warning to an error in those cases should not break code that is not already broken
11:04:44 <EvanR> then you wouldn't be able to implement undefined as head [] :P
11:12:28 * hackage express 0.1.1 - Dynamically-typed expressions involving applications and variables.  https://hackage.haskell.org/package/express-0.1.1 (rudymatela)
11:18:28 * hackage haskell-postgis 0.1.0.2 - A haskell library for PostGIS geometry types.  https://hackage.haskell.org/package/haskell-postgis-0.1.0.2 (petefrance)
11:19:27 * hackage haskell-postgis 0.1.0.1 - A haskell library for PostGIS geometry types.  https://hackage.haskell.org/package/haskell-postgis-0.1.0.1 (petefrance)
11:20:38 <oats> anybody know where I could find prebuilt linux hie binaries? Not super keen on compiling 225 deps...
11:20:44 <oats> I'm on arch linux, if it matters
11:20:57 * hackage cursor-brick 0.0.0.0 -   https://hackage.haskell.org/package/cursor-brick-0.0.0.0 (Norfair)
11:22:58 * hackage cursor 0.1.0.0 - Purely Functional Cursors  https://hackage.haskell.org/package/cursor-0.1.0.0 (Norfair)
11:23:58 * hackage cursor-gen 0.1.0.0 - Generators for Purely Functional Cursors  https://hackage.haskell.org/package/cursor-gen-0.1.0.0 (Norfair)
11:25:31 <fendor_> oats, there arent
11:25:58 <fendor_> oats, the only way to obtain prebuilt binaries is currently via nix package manager
11:26:00 <davean> oats: ugh, Arch breaks Haskell packages with how they package them so even building it will be annoyin
11:26:36 <merijn> No one likes how Arch packages Haskell. Arch users don't and Haskell users don't, so I wonder why they keep insisting on it...
11:28:05 <davean> merijn: But one size always fits all!
11:28:30 <merijn> It's also harder to do it this way than the sane way >.>
11:28:44 <davean> Oh yes, but clearly everything in the world works via dynamic linking
11:29:07 <oats> yeah, I've only got stack installed from the official repos. I just use stack to download everything else per-package
11:34:27 * hackage geos 0.2.2 - Bindings for GEOS.  https://hackage.haskell.org/package/geos-0.2.2 (petefrance)
13:46:34 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org'
13:46:34 --- topic: set by glguy on [Sat Jan 05 07:21:52 2019]
13:46:34 --- names: list (clog johnw Kundry_Wag jgt Goplat Fubar^ Vq fphilipe_ UpstreamSalmon opqdonut carlomagno wildlander wroathe jose_zap gabiruh Lord_of_Life heatsink_ cosimone1 wroathe_ Gurkenglas xcmw brschkv aarvar chalkmonster sqrt2 slack1256 merijn crestfallen kupi bolichep Frobozz Mrbuck laem trcc notzmv phreedom linarcx ddellacosta pavonia pyan Amras wildtrees beng-nl yyy gienah_ alicemaz alx741 fizbin literall1Crevice fendor_ xkapastel captjakk_ qwertytest crobbins_ pera)
13:46:34 --- names: list (nineonine dispanser revprez_anzio meck lambda-11235 CoolerZ noexcept Tesseraction_i freeman42x Quetzal2 thunderrd Insanity_ subttle aphprentice__ inkbottle lnostdal Ariakenom darjeeling_ dansho machinedgod xff0x_ jeltsch BoneTone zx__ urodna seanparsons hegge acidjnk Sgeo_ APic jao rzmt sicklorkin reactormonk shutdown_-h_now Rudd0 dddddd stepnem mkoenig_ Guest4074 poljar catsup ralejs rruizt s00pcan nullifidian pie_ danvet aesi asymptotically thc202)
13:46:34 --- names: list (albertus1 henriksod ht_ cynick Azel irclogger_com [Leary] khisanth_ jchia otto_s_ lagothrix theDon devopsdeluxe lemmih pi_ xplat SCHAPiE keep_learning cocreature Profpatsch sterni pfurla MarcelineVQ ericsagnes _dga acarrico gxt kipras leothrix dminuoso nahra _deepfire bind lkurusa ahri Cthalupa eof_ vaibhavsagar xalek[m] vikraman tmallard[m] Tom[m]7 reconmaster[m] ovigren[m] mattia[m] Grgoire[m] joenase[m] jochens[m] krhubert[m] jumzi[m] jwerner[m])
13:46:34 --- names: list (jhgarner[m] Kenneth[m] vorbex[m] kgadek[m] wildtrees[m] sghir_med[m] sudorebootsudor4 midi[m] sayukimans[m] sriehl[m] mujx[m4 ldesgoui[m] luisjira[m] nartir[m] josef[m] vkleen jibby[m]1 intellection3to3 nybble41[m] patonw[m] neat72[m] krowlan3[m] Vincent[m]2 Jonathan[m]2 corin[m]1 somni[m] rowan[m] kumarbis[m] M|GNUisnotLinux[ Lite[m] lmolr[m] imposs[m] imp0s5ible JoGoSi[m] contrun[m] jonreeve[m] kerru[m] potato44[m] edwel[m] ghastfilms[m] gandi[m])
13:46:34 --- names: list (glothit7ok[m] PotatoRick[m] eckt[m] deikatsuo[m] dxml[m] pothyurf[m] godva[m] pschooom[m] dice[m]1 adaizen[m] arianvp[m] LasEspuelas asayers[m]1 adziahel[m] lapav[m] haskelllisp[m] apurvapavaskar cbg[m] abc123zzz[m] brandon123[m] dag[m] d1mur4tdj[m] cosson[m] corin[m] JoelMcCracken[m] fulgjon Ericson2314 sujeet siraben sielicki jonge[m] stan[m] mmynsted[m] macerbi[m] maigel[m] simbergm kadoban GregKNicholson[m iceychris[m] lierdakil[m] kaychaks[m] fgaz)
13:46:34 --- names: list (ClownMaster[m] EuAndreh[m] hdurer[m] domenkozar[m] giuseppe[m] gmind[m] alexfmpe[m] atopuzov[m] aloiscochard[m] humanwire[m] Digitteknohippie M0ddba11[m] whoops CSP-SOFTWARE dequbed jonatan t7 RecursiveG __Myst__ revprez_stg spion srnty_ Unhammer Ewout teardown xelxebar haasn dennisb RusAlex zariuq Anthaas jb55 vk3wtf kori sagax DTZUZU glamas tromp hive-mind Nik05 atraii tomboy64 moldybits abra0 Jesin winny polman jle` ClaudiusMaximus nicoulaj dqd Boarders)
13:46:34 --- names: list (sw1nn_ byorgey metalrain erikd dxtr OnkelTem albel727 dTal Chousuke sis7 barrenbass eyenx ManiacTwister perrier-jouet monochrom ruffy_ glguy miklcct dmwit drewbarbs dustinm- cpup YongJoon laxask revprez_ody p0lyph3m jwynn6 Vtec234 sim590 dopplergange verement jdt orion dazage uberj _ashbreeze_ andreas303 mnrmnaugh mountaingoat divVerent xorander mceier thonkpod riatre jix Twey jlpeters troydm marek raek higherorder jkachmar drewr tabaqui cheater entel avn)
13:46:34 --- names: list (tombusby jameekim jlamothe MonkeyNOS Firedancer raoulb kAworu kapilp raoul tdammers enragedjam tnks enemeth79 devurandom Saulzar maralorn vin-ivar hiptobecubic theorbtwo treehaqr Dabo sms bolverkr zmlww nek0 nesqi xcthulhu xstill ftop devalot mikolaj Ornedan mimi_vx maerwald ephemera_ tms_ texasmynsted Foritus bydo atk abrar kraem dixie_ Robin_Jadoul nitwit wikiemol amx bbear butterthebuddha thaumavorio phaazon Niamkik clynamen_ kav sphalerite Nikotiini)
13:46:34 --- names: list (Ranhir yitz yaroot rom1504 NightA Tourist SquidDev cartwright aplainzetakind duairc moocow_ AWizzArd micro betawaffle andreabedini shadowdaemon srid sdx23 rizary_ Konehaltia Hotbees jokester dpn` rodlogic jonrh monad_cat dongcarl hsiktas simony scav arsdragonfly billstclair pent eruditass glowpelt Shun131 coot alexknvl sebastianrkg AfC alunduil NemesisD cyjiao__ v0d1ch Neuromancer Folkol bartavelle Bergle_1 Clint bbear_ jfredett hackage DDR UserOO7 jophish)
13:46:34 --- names: list (tomku amiri daissgr pcoutin niklasb_ ctag nckx tazjin i7c xorpse spamlessj PyroLagus vqrs jzl Jaxan_ obfusk__ casdr_ carter tsahyt_ sethetter EduardoBautista sppky gonz_ caasih bjs alexelcu iravid spinda alextes jstolarek ixian rotty fionnan rembo10 milli juri_ Remavas joehillen nil defanor cyphase Putonlalla klntsky Geekingfrog obiwahn dolio sukbeom9 hvr Ferdirand Someguy123 Blkt strangeglyph Randy nkaretnikov aramiscd coius__ Forkk Paks mulk NinjaTrappeur)
13:46:34 --- names: list (kungp ZoFLo J_Arcane jrslepak milessabin Tuplanolla malthe hpc Natch adadelta mccoyc Ring0` Mon_Ouie acro yorick Entroacceptor _ht jonge Mo0O noko_ Ckat bollu mjlee scinawa fliife artem bendo arw ziman remexre banjiewen fingerzam SrPx bradparker liquorice ryzokuken nbouscal Jabbslad dukedave zabracks cemerick AndreasK d0liver ebutleriv reyu [exa] Arahael Remy^ bandali fryguybo1 e2 michalisko pingiun pingu_ mjrosenb Jacoby6000 wadadli fantasti` Adeon w1d3m0d3)
13:46:34 --- names: list (violeta lowryder edwtjo rubik urdh sea-gull dyl_ noCheese gspia dcoutts gregberns paf31_ unsymbol edmundnoble datapup_ leah2 MatrixBot3 chirpsalot Chobbes Axman6 forell chin-tastic markus1189 ap5 infinity0 dan64 systemfault natim87 dave_uy earthy wagle m1dnight_ phaul raatiniemi hjozwiak infinisil sdrodge teej flebron reorder_ Sose robogoat nurupo waskell lassulus tv tinwood styledash trebuh boj morgib dibblego datajerk Deadhand mniip bengt_ yahb alp kaol)
13:46:34 --- names: list (bgamari megaTherion Seich phlym beka lachenmayer otulp ByronJohnson Tene sandman13 andyo mikeplus64 Cale monokrome nibbling_ saidinwot1 xtsee abuss bsima rj1 hiredman mtjmullen jdevlieghere brisbin alanz umachan rosalux wtw Enigmagic hc statusbot Hijiri vzdraz ion pdxleif dilinger dashkal charukiewicz w1gz nivpgir_ theophil893 polux7 Klumben xacktm SolarAquarion mudri petermw droplet totte mupf recj tessier_ jrm TimWolla matheus xante m4lvin aveltras grumble)
13:46:34 --- names: list (petercommand hongminhee int-e lambdabot habbah ft swalladge ycheng cods tomjaguarpaw cp nh telser jackdk Moyst jesyspa tolt nshepperd1 michaelpj Madars_ quarters intelux cjh` Unode ekleog TMA Tristan-Speccy Jello_Raptor amuck tstat implementation aristid VSpike arkeet aib a3f dsal feepo kip parseval ajmcmiddlin joel135 sebhoss srhb zzz nyuszika7h Drezil fiQ2 thebnq liff bjobjo stylewarning bitonic averell arianvp quaestor Ke spoonm DustyDingo fredcy- Ulrar)
13:46:34 --- names: list (mxf TallerGhostWalt lispy giraffe cjwelborn a3Dman cjay- cheers Kiruwa qzo mjuad topos stilgart lukelau twk- catern xnyhps xyggos no-n jackhill raid lpsmith vjoki pierrot bananagram SegFaultAX `slikts myme affinespaces mitchellsalad linduxed typedrat mingc mstruebing nitrix verlet64 dolanbatar Majiir sbrg haroldwu sud0 rootnode bspar akermu Cathy beaky Netwolf thjread nshepperd2 pong azahi vimto rotaerk kqr ysangkok chindy Ankhers pdgwien madnight nikivi)
13:46:34 --- names: list (dysfigured duncan atomi freeside jol TommyC andromeda-galaxy S007 dexterfoo zerokarmaleft PierreM aldum heath lugh tigerchops jvanbure luite dstolfa swater Kamuela jsatk stux|RC DigitalKiwi Liskni_si comboy nekomune teehemkay Arguggi sarahzrf qz statusfailed oats Athas linoge Intensity Dykam dmj` wildsebastian amatecha thi newhoggy_ nh2 integral edwardk dumptruckman ibloom elvishjerricco Lermex roflik tsani asm89 el Franciman sm codedmart agrif)
13:46:34 --- names: list (marble_visions yumh ski e bdw interruptinuse Philonous mikolaj_ winkill thallada _janne DrDuck daGrevis mrus h30 seventh__ dxld vktec s4msung MindlessDrone zymurgy SlashLife Patternmaster Logio cyberlard nyaomi epta tristanC fr33domlover Meanirelli ent CindyLinz srk Adluc GGMethos canta digia __4matter_ jtcs silverneedle Squarism PlasmaStar tehidiot stiell griddle cpape @Sigyn Firedancer_ tA- Igloo bcmiller restrictedchoice bitemyapp noan tureba hsyl20)
13:46:34 --- names: list (zenzike lemald evilmonads AkhILman phadej absence greeny__ deu krystianbajno shapr __name__ ambrosia_ gothos klugez debugloop gargawel_ aidecoe uwap_ rslima___ sgraf terrorjack__ dgpratt koankeeper seliopou Flonk nisstyre mrsbear loc kini wayne Annihitek ynyounuo rkrishnan vodkaInferno bs lyxia zxrf graingert adius gilbertw1 @ChanServ ereu benl23 echoreply tumdedum Heffalump chivay travv0 simon elcaro stefan-__ koz_ sigmundv- Maxdamantus johnstein n3t pacak)
13:46:34 --- names: list (kark Batholith esph wrengr_away akr stvc aweinstock PragCypher bob_twinkles nemesit|znc steell_ shreyasminocha Zemyla lavalike cross JSharp drdo kipras`away zv georgew ullbeking jbetz d6e dh freusque apoc mankyKitty andjjj23 ephemeron Jon rootmos Rembane c_wraith lstdgtfp joeyh rann m-renaud sclv Nevoic Ekho dfordivam subfacto1 newhoggy kyagrd__ ocharles glowcoil Guillaum immae nopf kubrat oleks adamse mmaruseacph2 cbarrett lightandlight jetpack_joe pasukon)
13:46:34 --- names: list (nonzen Sparadox energizer_ yushyin M2tias johs so suzu _guios exarkun orzo apeyroux_ diginet bcoppens RoguePointer bwe ab9rf AJTJ noctux feuerbach Phyx- haveo Taneb greymalkin runawayfive MasseR dredozubov c-rog Tspoon__ michalrus gsingh93 ecx86 Peter_Storm jmsx abbe flogfr hodapp heyj mrd scal PHO connrs_ Jonno_FTW Nascha scivola Eliel locallycompact gluegadget saurik ammar2 blackdog t36s gambpang hexagoxel deni connrs- PtxDK lortabac Reisen exferenceBot)
13:46:34 --- names: list (lurkless [df] Aleksejs coldpress carbolymer exio4 puffnfresh fiddlerwoaroof sivs _flow_ Deewiant lieven tchakka kosmikus barrucadu rodgzilla koala_man eldritch geal luigy jorj Willis furnost adamCS joeytwiddle kloeri wraithm iron_houzi davean DwarfMaster idupree markhuge jinblack solarus djanatyn anderson _6a68 avp Kneiva sssilver pharaun fiatjaf wz1000 Xandaros eagleflo adarshaj d3lxa crooked EvanR)
13:50:40 <crestfallen> one moment pls thanks MarcelineVQ 
13:51:54 <crestfallen> so pure is not required since the pattern match effectively does the same.
13:53:30 <MarcelineVQ> I don't see how pure is related to that example at all so you might want to reread the conversation you saw that example in
13:55:09 <crestfallen> because pure would convert the tuple into a list of functions ie [(*),(+)]
13:55:22 <MarcelineVQ> no, it would not
13:55:27 * hackage grafana 0.1 - grafana datatypes for dashboards  https://hackage.haskell.org/package/grafana-0.1 (chessai)
13:55:52 <merijn> crestfallen: What makes you think it does that?
13:56:01 <MarcelineVQ> pure when f is a list would turn (f,g) into [(f,g] which is the list containing one element, a tuple (f,g), not a list of two functions [f,g]
13:56:20 <MarcelineVQ> *turn (f,g) into [(f,g)]
13:56:30 <crestfallen> > pure (*)
13:56:32 <lambdabot>  error:
13:56:33 <lambdabot>      • Ambiguous type variable ‘f0’ arising from a use of ‘show_M384790521747...
13:56:33 <lambdabot>        prevents the constraint ‘(Show
13:56:49 <crestfallen> geez
13:58:08 <crestfallen> > pure (*) <*> [1,2] <*> [10,20]
13:58:10 <lambdabot>  [10,20,20,40]
14:00:08 <MarcelineVQ> % :t pure @[] (*) -- @[] is an extention telling pure that our f is [] (a list)
14:00:08 <yahb> MarcelineVQ: Num a => [a -> a -> a]
14:00:24 <MarcelineVQ> % :t pure @[] ((*), (+))
14:00:25 <yahb> MarcelineVQ: (Num a1, Num a2) => [(a1 -> a1 -> a1, a2 -> a2 -> a2)]
14:01:15 <MarcelineVQ> it's not obvious just from the types here that the list is just a single item, but that stems from how pure is defined for [], pure a = [a]
14:02:14 <trcc> in case anyone interested in my scotty issue, i found a solution here: https://www.reddit.com/r/haskell/comments/comqh9/scotty_spa_website_fallback_for_invalid_get/
14:02:22 <trcc> or found one and posted it..
14:02:35 <crestfallen> thanks a lot I need to study that. I tend to get in trouble. I should probably just stick to the book MarcelineVQ .. 
14:03:08 <MarcelineVQ> Yes and a person should even go back a bit if things don't make sense, books aren't made to be read just once
14:03:56 <EvanR> wait books aren't basically old style live streams?
14:05:04 <MarcelineVQ> pshh this EvanR guy here, doesn't even watch vods
14:09:56 <crestfallen> what's a vod
14:10:12 <MarcelineVQ> a recorded stream
14:19:12 <merijn> "Video On Demand"
14:57:27 * hackage cabal-debian 4.38.7 - Create a Debianization for a Cabal package  https://hackage.haskell.org/package/cabal-debian-4.38.7 (ClintAdams)
14:59:31 <orzo> If i have my own alternative numeric tower of type classes, is there anyway I can get numeric literals to work without implementing Num ?
14:59:54 <orzo> Integers in particular
15:00:09 <orzo> integer types
15:00:12 <hpc> it's called overridable syntax, or something like that
15:00:26 <orzo> i thought that was only for do/arrow syntax
15:00:41 <hpc> should work for numeric literals too
15:00:57 <hpc> it uses fromInteger or fromRational under the hood, same as do notation uses (>>=)
15:01:25 <hpc> extensible syntax, that's what it was
15:02:14 <orzo> RebindableSyntax?
15:02:38 <orzo> excelent, it's documented for RebindableSyntax.  THanks!
15:02:45 <hpc> oh cool
15:02:58 <hpc> i'll just go back to factorio now, since my brain is halfway to being mush ;)
15:10:57 * hackage cabal-debian 4.38.8 - Create a Debianization for a Cabal package  https://hackage.haskell.org/package/cabal-debian-4.38.8 (ClintAdams)
15:33:19 <freeman42x> is there a shorter way to write this? sortBy (\a b -> compare (fst a) (fst b)) [(3, "b"), (1, "a"), (2, "b"), (0, "f")]
15:34:34 <MarcelineVQ> :t comparing fst
15:34:36 <lambdabot> Ord a => (a, b) -> (a, b) -> Ordering
15:35:38 <freeman42x> oh, I got it: sortBy (comparing fst) [(3, "b"), (1, "a"), (2, "b"), (0, "f")]
15:35:40 <freeman42x> yeah, thank you
15:36:21 <MarcelineVQ> ah and there's sortOn fst I think
15:37:17 <MarcelineVQ> freeman42x: but tuple already sorts by fst it turns out
15:37:27 <MarcelineVQ> so you can just write sort
15:38:28 <freeman42x> MarcelineVQ, oh, that is awesome, thank you very much. It's like with what I'm used from C#
15:38:29 <MarcelineVQ> well not by 'fst' but it compares each spot in order from the first
15:40:30 <implementation> pie_: i cannot say anything about the python library, but the haskell bindings still work with zfs-0.8.0-170_gc81f1790
15:41:37 <implementation> (at least everything i tested so far, which is listing of properties, creating pools + datasets, destroying pools)
15:45:23 <Boarders> How common is it to write a custom lexer for use with megaparsec?
15:45:55 <Boarders> The examples seem to assume you are combining lexing and parsing that I have come across
15:46:01 <pie_> implementation cool
15:47:27 <sim590> I don't want to be told that it's not good practice, but just how to do it. https://paste.debian.net/1095293/ The first line works OK, but the second doesn't. I understand that both right sides of the equations are not of the same type. How could I achieve the second one? This will help me understand better the right side of the equation of the second one..
15:47:49 <c_wraith> Boarders, I want to do that every time I use it, but it really is unfriendly to custom token streams. it is (or at least used to be, last time I tried it) a lot of work.
15:48:08 <Boarders> c_wraith: do you have a good alternative that you use?
15:48:41 <sim590> Also. I'm, sorry. I didn't include the imports. Indeed, there is the line `import qualified Data.Maybe as Maybe` also.
15:49:46 <c_wraith> sim590, what are you *trying* to do?
15:49:46 <Boarders> also is there any good lex library other than Alex?
15:50:05 <sim590> c_wraith: In short, I want to replace Maybe.Just by somethign else. Like a type alias, but I understand that I can't do that with Just but I don't know why.
15:50:23 <c_wraith> sim590, it's not a type. that would be the main reason.
15:50:48 <sim590> Isn't it a "data" type?
15:51:07 <c_wraith> no. it's a data constructor. constructors are values.
15:51:15 <sim590> Wouldn't `Just x` come from `data Just = Just a` or something.
15:52:16 <c_wraith> it seems like you're trying to make everything into a hierarchy. Haskell doesn't work like that.
15:52:40 <sim590> I just want to substitute the word Just for something else.
15:52:56 <c_wraith> Boarders, believe it or not, I used megaparsec as the lexer, too. I just ran it twice.
15:53:01 <sim590> I want to translate "Just" in another language.
15:53:14 <sim590> Human language.
15:53:19 <Boarders> c_wraith: ah ok, I think I will just use token combinators or something like that
15:53:57 <c_wraith> sim590, as a pattern that can be used in pattern matching, or just as a function to construct values?
15:53:58 <Boarders> Though it was for parsing with layout which seems like a lexer is useful
15:54:13 <sim590> c_wraith: Everywhere in my file.
15:54:40 <c_wraith> I don't know what's in your file.
15:54:43 <sim590> c_wraith: May be I can just recreate Just ? Like `Gxuste = Gxuste a | Nenio` or something?
15:55:22 <sim590> Oh. That's the Maybe
15:56:39 <c_wraith> you can certainly do that. it is likely to be the best option, especially if you are working on stuff for beginners to use.
15:57:02 <sim590> I simply wrote this: `data Eble a = Gxuste a | Nenio`.
15:57:02 <dmwit> sim590: You might like `pattern Gxuste a = Just a`.
15:57:26 <sim590> pattern? Oh.
15:58:29 <dmwit> (You will need to turn on the PatternSynonyms language extension.)
16:01:12 <jle`> it's common to define custom versions of types like Maybe for teaching/educational purposes
16:01:55 <c_wraith> yes, but it's common to actually define custom versions, not just aliases for the existing stuff. 
16:02:42 <jle`> yeah, i'm justifying something like data Aybemay a = Othingnay | Ustjay a
16:02:51 <jle`> for education in a pig latin society
16:03:13 <xcmw> Silly question: when does fromJSVal from GHCJS return Nothing? I've been looking at the definitions but they seem to all return Just. http://hackage.haskell.org/package/ghcjs-base-stub-0.2.0.0/docs/src/GHCJS.Marshal.html#line-91
16:04:50 <sim590> dmwit: I tried this: https://paste.debian.net/1095294/, but it doesn't like that. I'm surely not using it correctly.
16:07:25 <bpaterni> the haskellbook has some material on the 'checkers' package, but I can't seem to get it included in the dependencies of a project bootstrapped with stack :[ (stack ghci ch17:ch17-test) keeps reporting "cannot satisfy -package checkers-0.5.0" Please let me know what I'm doing wrong
16:08:31 <c_wraith> I'd assume when the JSVal provided can't be converted to the type. like if it's a string and you try to make it an Int, or the like.
16:08:44 <c_wraith> xcmw, ^
16:09:29 <sim590> If you're curious, I have translated my Tower of Hanoi solution into Esperanto: https://gist.github.com/sim590/7da323d06699d9e06a49b41b2f51d71f. So, I have the version `data Eble a = Gxuste a | Nenio` working fine. I can't make the pattern version work.
16:10:34 <xcmw>   c_wraith: Where is the code does it do the check? If I look at the link of definitions I can't see it.
16:10:56 <sim590> redefining Just and Maybe is fine here, but what if I had words for which their definition were more complicated. I wouldn't like to rewrite that in my code. So, pattern PatternSynonyms would work right?
16:11:33 <c_wraith> xcmw, the code isn't entirely in the source there. it's split between those modules and the ghcjs js ffi
16:14:53 <xcmw> c_wraith: https://pastebin.com/ECNnbEjm It seems to always return Just
16:15:19 <sim590> dmwit: I made it work! Thanks for the tip about patternSynonyms
16:21:49 <xcmw> c_wraith: Is my reasoning correct or is there some weird way it returns Nothing?
16:22:04 <dmwit> xcmw: The tuple instance can return Nothing, at the very least.
16:23:48 <xcmw> dmwit: I agree
16:23:56 <freeman42x> is there any Haskell type for Double-like values that are >=0 ?
16:24:06 <dmwit> freeman42x: no
16:24:26 <freeman42x> dmwit, why isn't there? any technical reasons?
16:24:48 <dmwit> freeman42x: https://stackoverflow.com/q/11910143/791604
16:25:15 * dmwit ponders Ratio Natural
16:25:51 <freeman42x> I guess a technical reason might be the way the processing unit might handle them
16:39:58 <bpaterni> any help for my above question on the 'checkers' package? I'm new to haskell/stack, and feel the solution is something simple that I'm just not understanding?
16:40:36 <MarcelineVQ> bpaterni: I wasn't able to reproduce the problem you outlined in #haskell-beginners, what do your stack.yaml and project.yaml look like?
16:41:39 <Mrbuck> Hi little weird but very useful can I know you programmers daily schedule ? I am just curious and also taking notes for some online research on programmers habbits
16:42:04 <Mrbuck> If you guys answer I will just take some points and present in a blog
16:42:23 <Mrbuck> if possible
16:43:48 <MarcelineVQ> er package.yaml
16:44:07 <bpaterni> MarcelineVQ: package.yaml - https://pastebin.com/6cFV41Xj
16:44:58 <bpaterni> MarcelineVQ: stack.yaml - https://pastebin.com/KbADBTfE
16:47:35 <MarcelineVQ> same as mine, hmm, not sure what the issue could be then since I don't have it. try a stack upgrade, note where it puts it new binary since you'll need to have that on your path
16:52:52 <bpaterni> hrm, that is really weird. I did a stack upgrade and recreated the project, and still the same error ;[
16:53:33 <MarcelineVQ> yeah no clue :(
17:07:57 <bpaterni> well, replicated the same issue inside an ubuntu docker container... *commence banging head against wall*
17:30:00 <lyxia> bpaterni: can you paste the full error message
17:32:50 <bpaterni> lyxia: full verbose output of (stack -v ghci ch17:ch17-test): https://pastebin.com/PnXupN3r
17:40:22 <lyxia> bpaterni: I get the same error on a fresh project, and it goes away after running "stack test" once (which builds and runs the tests, after *installing the dependencies*)
17:50:15 <bpaterni> lyxia: That's exactly what I needed to do! In past chapters I remember doing the same exact thing to get it to work, but completely forgot that step this time. Sorry for the newb question, but thanks so much for your help in getting me running again. I appreciate it very much! :-]
17:56:43 <lyxia> you're welcome :)
18:01:05 <orzo> Is this doable?  A class' default method is inneficient and i expect it to be overridden.  But it's implementation is straight-forward and elegant.  I'd like RULES to replace instances where a user manually wrote the code that is serving as the default implementation with a call to the class method.  My concern is that I don't want the default implementation itself to be rewritten to become
18:01:11 <orzo> recursive.
18:02:42 <orzo> This sounds like probably a typical snafu with RULES optimizing
18:04:25 <orzo> maybe i need to put the RULES in another module not in scope?
18:51:08 <orzo> Probable fix: add an INLINE[n] or NOINLINE[n] pragma for ‘e_’
18:51:43 <orzo> I don't know how to turn this off, i've tried all kinds od variations of INLINE and NOINLINE with various phase numbers
18:57:58 * hackage hsdev 0.3.3.4 - Haskell development library  https://hackage.haskell.org/package/hsdev-0.3.3.4 (AlexandrRuchkin)
18:58:58 * hackage cabal-debian 4.39 - Create a Debianization for a Cabal package  https://hackage.haskell.org/package/cabal-debian-4.39 (ClintAdams)
19:08:49 <freeman42x> for the line linked here, what would be the best way to return Nothing when head would explode? https://github.com/fairy-tale-agi-solutions/fairy-tale-artificial-general-intelligence-solutions/blob/master/Sources/Razvan%20Flavius%20Panda/Haskell/artificial-general-intelligence/src/Lib.hs#L37
19:15:58 * hackage debian 3.95.1 - Modules for working with the Debian package system  https://hackage.haskell.org/package/debian-3.95.1 (ClintAdams)
19:19:10 <orzo> listToMaybe
19:21:38 <freeman42x> orzo, no, that is not what I mean. I'm looking for shorter code that does that. I recall there was some function that could do that
19:24:49 <orzo> your sortOn fst should probably come after mapMaybe rather than before
19:25:06 <orzo> why sort Nothing values
19:26:32 <orzo> also, why sort when you could use minimum
19:27:10 <orzo> lastlog http
19:30:20 <orzo> https://paste.ee/p/w8FT9 -- Why don't these rules fire?
19:31:01 <MarcelineVQ> freeman42x: filter (isJust . fst) is mapMaybe fst, I think, but which part are you asking about with your question about head?
19:31:35 <MarcelineVQ> oh I'm blind
19:33:44 <orzo> RULES just dont seem to work, i'm just trying to make a simple demo to figure out how to use them and even in this toy program they just don't work
19:35:21 <MarcelineVQ> :t fmap (snd . fst) . uncons
19:35:24 <lambdabot> [(a, b)] -> Maybe b
19:37:27 <freeman42x> orzo, "your sortOn fst should probably come after mapMaybe rather than before" what mapMaybe are you talking about?
19:37:28 <MarcelineVQ> which I think is equivalent enough to "fmap snd . listToMaybe" which orzo was suggesting, so it's unclear what you're after
19:37:59 <freeman42x> MarcelineVQ, I'm just looking for a more concise way to write that code
19:39:23 <freeman42x> MarcelineVQ, I was looking for a more concise version of: if null proximitiesAndActions then Nothing else Just $ snd $ head proximitiesAndActions
19:39:59 <freeman42x> imagine a function with signature: [a] -> b -> b -> b which returns the 2nd argument when null [a] otherwise the 3rd argument
19:40:06 <freeman42x> unfortunately I couldn't find such a function
19:43:10 <freeman42x> if it existed, it would be called like: unexistingFunction proximitiesAndActions Nothing (Just $ snd $ head proximitiesAndActions)
19:43:43 <glguy> :t foldr const
19:43:45 <lambdabot> Foldable t => b -> t b -> b
19:53:31 <freeman42x> MarcelineVQ, "filter (isJust . fst) is mapMaybe fst" that's actually not correct
19:54:54 <MarcelineVQ> ah yeah you're right
19:56:11 <orzo> fmap (fst . minimumBy (comparing snd) . uncurry (:)) . uncons . mapMaybe (\(x,y) -> x >>= Just . (,) y)
19:57:30 <orzo> that has type: Ord a => [(Maybe a, b)] -> Maybe b
19:57:41 <orzo> and accomplishes what freeman42x wantss
19:58:18 <freeman42x> MarcelineVQ, this doesn't do it either: "fmap (snd . fst) . uncons $ [(Nothing, 41), (Just 10, 42), (Just 32, 43)]" it returns Just 41, instead of Just 42
19:59:08 <orzo> > fmap (fst . minimumBy (comparing snd) . uncurry (:)) . uncons . mapMaybe (\(x,y) -> x >>= Just . (,) y) $ [(Nothing, 41), (Just 10, 42), (Just 32, 43)]
19:59:10 <lambdabot>  Just 42
19:59:22 <MarcelineVQ> I thought you filtered the nothing's already
19:59:41 <glguy> > (fmap snd . find (isJust . fst))   [(Nothing, 41), (Just 10, 42), (Just 32, 43)]
19:59:44 <MarcelineVQ> If you're asking for a better version of the whole function you should ask for that instead of a line :>
19:59:45 <lambdabot>  Just 42
19:59:58 * hackage mssql-simple 0.4.0.2 - SQL Server client library implemented in Haskell  https://hackage.haskell.org/package/mssql-simple-0.4.0.2 (tkmsm)
20:00:01 <orzo> find  eh
20:00:13 <orzo> i never use that one
20:00:38 <freeman42x> MarcelineVQ, this does it: "fmap snd . listToMaybe $ filter (isJust . fst) $ [(Nothing, 41), (Just 10, 42), (Just 32, 43)]"
20:00:40 <freeman42x> thank you
20:00:52 <orzo>  > (fmap snd . find (isJust . fst)) []
20:01:11 <orzo> > (fmap snd . find (isJust . fst)) []
20:01:15 <lambdabot>  Nothing
20:01:29 <orzo> well that's way better than my monster
20:02:56 <freeman42x> glguy, your version is better, thank you!
20:03:06 <glguy> You’re welcome.
20:04:22 <orzo> glguy: do you know why my RULES example doesn't work?
20:04:38 <orzo> pasted here, https://paste.ee/p/w8FT9
20:05:10 <glguy> I didn't understand what you were trying to achieve
20:05:13 <orzo> i matched the exact expression i wrote a few lines down
20:05:46 <orzo> So (v `dot` e_ 2) which occures in main should be rewritten to (niceMethod v 2)
20:07:20 <orzo> i'm trying to construct a rewrite rule that lets you do efficient indexing using math-like dot product syntax with basis vectors
20:07:29 <glguy> I find this surprising: forall (v::(NiceClass v, Dimmed v)=>v) i.
20:07:33 <glguy> I'd expect just: forall v i.
20:07:52 <orzo> i tried it that way first
20:07:55 <orzo> no difference
20:08:47 <orzo> i wasn't sure how class methods intteract so i put apostrpohies on all od them an aliased them with top level functions
20:09:19 <orzo> it seems like i *have* to do that to get rid of a warning about the rule probably not firing
20:09:31 <orzo> now i have no warnings, but the rules dont fire either
20:11:17 <orzo> i just want some way to accomplish the (v `dot` e_ 2) -> (niceMethod v 2) rewrite
20:11:25 <orzo> using RULES
20:34:59 <orzo> is there an example that is just a toy demo that illustrates rewrite rules being triggered?
20:35:21 <orzo> everything wants to exmplain it using list fusion or some actual optimization example
20:35:41 <orzo> but i just want to see the semantics illustrated
20:36:38 <orzo> i'd like a probram that writes "hello" on the screen but a rewrite rule added makes it write "goodbye"
20:36:52 <orzo> can anyone paste that somewhere for me?
20:39:17 <rajivr___> I am learning haskell - I was wondering why the kind of  `(forall a. (Int -> Int -> a))` is a `*` and not a `* -> *` like `Maybe` 
20:42:00 <orzo> https://paste.ee/p/dDxLf
20:42:25 <orzo> very small paste, simplest possible example of using a rwrite rule, doesn't work.
20:43:44 <glguy> rajivr___: Two things: (Int -> Int -> a) :: *, and (forall a. (Int -> Int -> a)) isn't something you could apply to another type like you can with Maybe
20:45:13 <orzo> is my version of ghc just broken?
20:45:25 <MarcelineVQ> orzo: https://gist.github.com/MarcelineVQ/53167d556af23ffdd0699ed513a0f0c4 ghc -O Main.hs -ddump-rule-firings to see firing, ./Main to see "goodbye"
20:46:28 <MarcelineVQ> orzo: just as a quick check, you are turning on -O yes?
20:47:55 <rajivr___> glguy:  Could you please elaborate a bit more on what you mean by "apply to another type".
20:48:08 <orzo> i thought -O1 is default
20:48:16 <glguy> rajivr___: f x is 'f' applied to 'x'
20:48:42 <rajivr___> Okay. Thanks. That makes sense. 
20:48:47 <orzo> missing -O is the reason the rules dont work
20:49:03 <orzo> what's ghc default ? -O0
20:49:13 <MarcelineVQ> idk if -O anything is default, fwiw I can't get your latest rule to fire
20:49:46 <orzo> i got your rule to fire with -O
20:49:52 <orzo> i wasn't using it before
20:50:07 <MarcelineVQ> The rules section does say to enable -O or to enable -fenable-rewrite-rules which -O implies
20:50:18 <MarcelineVQ> rules section of the ghc manual that is
20:51:04 <orzo> does SPECIALIZE also not work then without that?
20:52:47 <MarcelineVQ> I think so, given this line "A SPECIALIZE has the effect of generating (a) a specialised version of the function and (b) a rewrite rule (see Rewrite rules) that ..."
20:53:21 <MarcelineVQ> strongly suggests you need rewrite rules on to have something happen
20:54:12 <CelestialLake> Hi there, fellow Haskellers. I'd like to get some recommendations on resources providing challenges regarding type-level programming. Saw one with Nats and inductive proofs of their oddity. Would really like some large list of problems like that. If not that, I'd like at least some individual problems or papers regarding anything on the topic, trying to study the topic thoroughly.
20:55:21 <MarcelineVQ> CelestialLake: if you can get a copy of Thinking with Types by Sandy Maguire it might have some relevant stuff for you
20:55:34 <MarcelineVQ> they're on to us
20:55:36 <MarcelineVQ> CelestialLake: if you can get a copy of Thinking with Types by Sandy Maguire it might have some relevant stuff for you
20:57:51 <CelestialLake> MarcelineVQ: Considered buying the book, actually planning on having it in a week or so, thanks. Anything else?
21:02:11 <MarcelineVQ> idk, I've not done much of that stuff myself in haskell, definitely don't know of any list of challenges. There's a couple resources I can think of but they involve dependent types rather than type-level programming in haskell
21:03:10 <CelestialLake> Dependent types are cool too
21:03:16 <MarcelineVQ> in particular https://softwarefoundations.cis.upenn.edu/ and https://plfa.github.io/
21:03:29 <CelestialLake> Thanks
21:12:33 <MarcelineVQ> orzo: seems like putStrLn inlines too quickly to rewrite
21:12:44 <MarcelineVQ> At least that's nearest I can figure
21:16:55 <MarcelineVQ> oh I didn't -fforce-recomp so it was re-using old stuff, my tests are useless
21:17:58 <MarcelineVQ> mmyeah putStrLn is inlined at the very very first core pass
21:18:15 <MarcelineVQ> or at least changed into something other than putStrLn
22:05:17 <sim590> I have installed this plugin https://github.com/haskell/haskell-ide-engine. It works fine, but it doesn't find libraries I have installed using my package manager. That's because it using some ~/.stack/programs/x86_64-linux/ghc-tinfo6-8.6.4/bin/ghc to compile in the background. When I use /usr/bin/ghc, it compiles fine. So, I would like to know if there's a way to tell ghc where are the libs or should I use
22:05:19 <sim590> stack for e.g. to configure my project?
22:09:43 <sim590> Can I use the ~/.stack/programs/.../ghc-pkg to update its database of packages to include the ones in /usr/lib ?
23:51:17 <jle`> is there an easy way to make a newtype BiEndo a = BiEndo (a -> a -> a) out of basic combinators in base, or do i have to make my own throwaway type
23:59:23 <jle`> wouldn't it be nice to have anonymous indexed types
