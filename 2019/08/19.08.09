00:43:52 <dminuoso> Why is there no And or Or in Data.Monoid?
00:48:12 <jle`> dminuoso: they're called All and Any
00:51:52 <dminuoso> jle`: I feel so silly now. :(
00:52:54 <dminuoso> Thanks.
00:57:02 <pyan> Purely out of curiosity, are those Monoid instances actually used in practice, or are they there for the sake of completeness?
00:57:26 <dminuoso> pyan: They are.
00:58:22 <dminuoso> pyan: The main point of it is if you are interfacing with some code that is parametrized over a polymorphic Monoid.
00:59:26 <pyan> Right, that was precisely my point: How often do people write polymorphic code, parameterized over a Monoid, and then specialize it to work with All and Any?
01:00:10 <dminuoso> pyan: lens would be a good candidate.
01:01:04 <dminuoso> pyan: I reckon one of the primary reasons for this is this instance
01:01:26 <dminuoso> instance Monoid m => Applicative (Const m :: Type -> Type)
01:02:32 <dminuoso> pyan: Another usecase I can think of, is if you are using say Validation where the error is just a flag that can activated without shortcircuiting.
01:02:52 <pyan> Oh.
01:02:52 <pyan>  
01:02:59 <pyan> The last one actually seems useful.
01:04:19 <dminuoso> pyan: In case of lense, just think about any Fold really.
01:04:47 <dminuoso> % allOf folded (>=2) [1..10]
01:04:48 <yahb> dminuoso: False
01:05:03 <dminuoso> allOf :: Getting All s a -> (a -> Bool) -> s -> Bool 
01:05:17 <pyan> Ah!
01:06:11 <dminuoso> pyan: The point usually is when someone else writes code parametrized over Monoid (in the sense of "I dont care, you pick the monoid"), and you want to use their code with your choice of monoid.
01:06:44 <dminuoso> type Getting r s a = (a -> Const r a) -> s -> Const r s 
01:07:10 <chloekek> In the RTS, is it bad if a megablock group contains more than one object?
01:07:11 <dminuoso> If you ponder about this for a short moment, you'll realize that in order to pass a Fold, you need Monoid r
01:07:12 <fendor> @type folded
01:07:14 <lambdabot> (Indexable Int p, Contravariant f1, Foldable f2, Applicative f1) => p a (f1 a) -> f2 a -> f1 (f2 a)
01:33:42 <sm[m]> g’day all. I’d like to remove lambdabot from #hledger. It isn’t that easy to find out who maintains it. Who should I ping ?
01:35:53 <dminuoso> sm[m]: int-e probably
01:41:40 <int-e> sm[m]: done
01:42:16 <sm[m]> Thank you!
01:42:28 <sm[m]> we just having been using it, and it keeps interrupting :)
01:42:37 <sm[m]> haven’t
01:43:23 <int-e> no worries
01:55:35 <basic> what's the word origin of thunk?
01:57:41 <Batholith> who'd've thunk it
01:58:45 <basic> thought and chunk?
02:00:15 <Taneb> drink => drunk :: think => thunk
02:01:13 <__monty__> basic: http://foldoc.org/thunk
02:02:15 <basic> well that doesn't explain why he named it that way
02:02:24 <basic> ah okay didn't read the last paragraph
02:03:11 <fendor> how can I get stack traces in cabal v2-repl? Is it enough to build with profiling enabled?
02:29:58 <Arahael> Out of interest...  Is there a good haskell library that lets me import python modules and use it as a kind of embedded DSL?
02:30:09 <Arahael> A high level binding of the CPython api, so to speak?
02:33:37 <basic> can i tell ghci to drop everything that is "cached" ?
02:34:23 <jgt> basic: what's cached?
02:34:34 <basic> values of infinite lists
02:35:08 <jgt> ah, I'm not sure then
02:35:21 <jgt> I'm guessing you know about :r
02:35:32 <basic> yeah doesn't help
02:36:13 <jgt> maybe also :set +r
02:36:22 <basic> what does that do?
02:36:27 <jgt> https://stackoverflow.com/a/15536084/704015
02:37:00 <basic> great.
02:37:03 <basic> thanks
02:37:43 <basic> wait no, doesn't seem to help :p
02:38:25 <jgt> ¯\_(ツ)_/¯
03:15:10 <asheshambasta> Under what circumstances does this kind of derivation fail? https://gist.github.com/asheshambasta/2edb4877f143ae52f85bb8663ca49958 
03:17:11 <asheshambasta> (I've changed the inner workings of JsRead stack; which was a much simpler JsRead a = JsRead { runJsRead :: Value -> Either Err a }); where the derivations used to work for simple newtypes; however, changing this to a more complex monad transformer stack seems to have broken these derivations for me. I'm probably doing something wrong; but if someone can break down the error message there that will help me underst
04:44:29 <Unhammer> is Applicative's "pure" the least restrictive typeclass that lets me wrap something up in a list or NonEmpty?
04:47:25 <cocreature> Unhammer: it’s at least the one that is by far the most popular. There is Pointed https://hackage.haskell.org/package/pointed-5.0.1/docs/Data-Pointed.html but it’s barely used
04:48:27 * hackage gnome-keyring 0.3.1.1 - Bindings for libgnome-keyring  https://hackage.haskell.org/package/gnome-keyring-0.3.1.1 (NickPershyn)
04:48:40 <Unhammer> aha, thanks cocreature. I'll use pure then, since I don't already have Pointed in my deps
05:04:27 * hackage alsa-gui 0.1.0.1 - Some simple interactive programs for sending MIDI control messages via ALSA  https://hackage.haskell.org/package/alsa-gui-0.1.0.1 (HenningThielemann)
05:04:43 <infinisil> Unhammer: There's MonoPointed in mono-traversable: https://hackage.haskell.org/package/mono-traversable-1.0.11.0/docs/Data-MonoTraversable.html#t:MonoPointed
05:05:31 <infinisil> And mono-traversable is fairly popular
05:07:00 <infinisil> And MonoPointed is more general than Applicative, it also allows instances for things like Text
05:14:59 <Unhammer> interesting 
05:15:52 <cocreature> I am not sure I have ever seen an API that requires a MonoPointed constraint
05:16:48 <dminuoso> cocreature: Reverse search via hoogle suggests its not really used either.
05:16:49 <cocreature> the issue with Pointed/MonoPointed/… is somewhat similar to Default. You can’t really really reason about what it does in any way
05:16:58 <hpc> i wonder if it's got the same kind of mathematical uselessness as splitting pure out from Applicative
05:19:13 <dminuoso> Edward put it nicely "A slightly less simplified version of my position is that Pointed has no useful laws and almost all applications people point to for it are actually abuses of ad hoc relationships it happens to have for the instances it does offer"
05:19:50 <dminuoso> The only valid usecase for Pointed seems to be having affine traversals.
05:28:46 <dminuoso> nil: Did you catch our talk about Compose earlier by the way? Perhaps some useful insights for you after yesterdays discussion.
05:29:48 <nil> yep
05:30:53 <dminuoso> nil: Did you construct the EFMonoid for Sum and Product? :)
05:33:19 <jgt> anyone know how best to go about Data.Text.Internal.Builder.Builder -> Data.ByteString.Lazy.Internal.ByteString
05:33:30 <nil> dminuoso: let me write them down
05:37:42 <infinisil> Unhammer: What are you using this for
05:37:44 <infinisil> ?
05:39:10 <Unhammer> oh, just had some sort&group functions that did the same for lists and nonempties
05:39:30 <Unhammer> did not mean to start a huge discussion =P
05:42:02 <simon> I'm toying around with HLint, and I wonder why a custom hint like: - hint: {lhs: mod, rhs: rem} will trigger for the code 'mod x y', but not 'x `mod` y' with the latest HLint.
05:53:45 <nil> dminuoso: this is the Sum instance https://up.monade.li/WYopo2
05:53:56 <nil> i'm struggling with the Product one
05:57:33 <nil> i picked  i ~ Const ()  because  Product f (Const ()) ~~~ f  and  Product (Const ()) f ~~~ f
05:57:40 <nil> but then i have no idea how to write unit and join
06:01:46 <dminuoso> nil: Here's a hint, you are allowed to impose additional constraints.
06:01:59 <nil> i thought of imposing Monoidal f
06:02:05 <nil> (or Applicative or equivalent)
06:02:09 <nil> but that doesn't help me
06:02:12 <dminuoso> nil: Well, that's sort of what you are writing in the first place.
06:02:31 <dminuoso> nil: What would the type of join be?
06:02:34 <nil> wait, constraints on a?
06:02:52 <nil> i feel like if i constraint a to have monoidal structure, then i can write this
06:02:56 <nil> constrain*
06:03:06 <nil> dminuoso: join :: Product f f a -> f a
06:03:16 <dminuoso> nil: Except that's not entirely true, is it?
06:03:27 <nil> i don't follow
06:03:56 <dminuoso> nil: Let me give you a hint, you made an irrelevant mistake in your Sum example.
06:04:10 <dminuoso> It's relevant in the sense you were thinking wrong, but irrelevant in that it doesnt have any impact.
06:04:11 <p53> hello, can someone tell me which software is used for the Haskell Wiki?
06:04:16 <dminuoso> Well actually it has a lot of impact. ;)
06:04:23 <nil> a mistake in the type signatures? or implementation?
06:04:39 <dminuoso> nil: It wouldnt even type check at all.
06:04:51 <dminuoso> Oh wait shoot, too fast.
06:05:30 <dminuoso> nil: So the Functor f constraint is useless.
06:05:41 <dminuoso> nil: We already have: class Functor f => EFMonoid t i f where
06:05:45 <dminuoso> nil: But the real point is
06:06:39 <nil> yeah, i was wondering if it was necessary
06:06:47 <dminuoso> nil: You might not be able to write a generic type that works for any f.
06:06:55 <dminuoso> nil: It's rather you would write
06:07:10 <dminuoso> instance EFMonoid Sum (Const Void) []
06:07:20 <merijn> p53: phpwiki, afaik
06:07:22 <dminuoso> instance EFMonoid Sum (Const Void) IO
06:07:26 <dminuoso> Or something like that.
06:08:50 <dminuoso> Well. In case of Sum you actually *can* write it polymorphic because its always the same implementation.
06:08:56 <dminuoso> But for Product you'd have different implementations.
06:10:22 <nil> well that's disappointing.
06:11:14 <p53> ah ok, thx; I'm just asking, because there is also a wiki software in haskell: gitit
06:16:46 <nil> dminuoso: so, supposing we're trying to define instance EFMonoid Sum (Const Void) [], we still need constraints on a, right?
06:19:46 <dminuoso> nil: Do you?
06:20:01 <dminuoso> nil: By additionionally constraining the type I meant in the sense you could assume f ~ [] ;)
06:20:24 <dminuoso> nil: The thing is, the constraint you are hoping for is actually the entire *set* of instances you are writing.
06:21:09 <nil> right, got it
06:21:12 <nil> https://up.monade.li/NMgkjc
06:21:48 <nil> i feel like you could still generalise that by imposing Monoid f
06:21:58 <nil> er, wrong kind
06:22:04 <dminuoso> nil: Right! And thats the point really.
06:22:17 <dminuoso> nil: "EFMonoid Sum Void1" is Monoid1 
06:22:20 <nil> you'd have to have Monoid (f a) for all a?
06:22:23 <dminuoso> A "higher ranked monoid" so to speak.
06:22:27 <nil> can you have such a constraint?
06:22:37 <dminuoso> nil: Yes. "EFMonoid Sum Void" is that constraint.
06:22:39 <dminuoso> ;)
06:22:46 <dminuoso> *EFMonoid Product (Const ())
06:22:49 <dminuoso> Sorry
06:23:04 <dminuoso> Or "EFMonoid Product Proxy" for better readability
06:23:54 <nil> dminuoso: so basically i want to write this https://up.monade.li/wEwAxn
06:24:05 <dminuoso> nil: Any chance you can use gist or something else? My firewall is a bit hateful
06:24:11 <nil> sorry, yes
06:25:01 <dminuoso> nil: Again, what you want is the thing you are writing, actually. :)
06:25:11 <dminuoso> nil: You could say that:
06:25:23 <nil> https://gist.github.com/naim42/d4d7d6d8fc05d8bbab38b83677d11c4f
06:25:56 <dminuoso> class Monoid1 f where mappend1 :: f a -> f a -> f a; munit1 :: f a; and then constrain f by Monoid1 I suppose
06:26:14 <dminuoso> In that case
06:26:29 <nil> i see
06:26:36 <dminuoso> "EFMonoid Product Proxy" is to "Monoid1" like "EFMonoid Compose Identity" is to "Monad"
06:26:51 <dminuoso> followed by "EFMonoid Day Identity" -> "Applicative"
06:27:02 <nil> Void1 is Const Void, correct?
06:27:05 <dminuoso> nil: Yes.
06:27:20 <dminuoso> nil: So you get a sort of "higher ranked monoid" by setting the tensor to product.
06:27:31 <nil> i see
06:28:31 <nil> not sure what Proxy is, from the definition i'd say it's just another name for Void1?
06:28:43 <dminuoso> nil: Proxy is just (Const ())
06:28:48 <dminuoso> data Proxy a = Proxy
06:28:49 <nil> ah yes
06:28:52 <dminuoso> from Data.Proxy
06:29:09 <nil> data Void1 a
06:29:12 <nil> data Proxy a = Proxy
06:29:13 <dminuoso> nil: Yes. :)
06:29:48 <dminuoso> data Δ_Void a
06:30:08 <dminuoso> data Δ_Unit a = Δ_Unit
06:30:34 <dminuoso> nil: This might be the more CT inclined way.
06:30:51 <dminuoso> Or Δ0 and Δ1 perhaps
06:31:55 <nil> initial and terminal, right?
06:32:09 <nil> not sure in what category exactly
06:32:28 <nil> End_Hask?
06:32:39 <dminuoso> nil: Void is 0, () is 1. And Δ is usually the name for a const functor
06:33:05 <dminuoso> nil: https://hackage.haskell.org/package/these-1.0.1/docs/Data-Functor-These.html#t:These1
06:33:11 <dminuoso> nil: this is, supposedly, another fun tensor for EFMonoid
06:33:23 <dminuoso> Going to look at it tonight myself. :)
06:35:25 <nil> interesting
06:35:30 <nil> f + f + f*f
06:36:03 <dminuoso> (When it comes to tensors, Day is probably quite exotic in comparison)
06:45:50 <isovector1> where is the repository for `base`?
06:45:59 <isovector1> i want to send some PRs but don't know where!
06:47:53 <yushyin> https://gitlab.haskell.org/ghc/ghc/tree/master/libraries/base
07:11:34 <__Myst__> in llvm-hs, why do most instructions that in the spec optionally allow align instead have it mandatory in the function def?
07:26:12 <fizbin> So I want to write something with type Either String (Maybe (Word64, [Maybe (Word8, Word32, Word8, Word32)])) -> Either String (Maybe (Word64, [Maybe (Word32, Word32)])) and my first instinct leads to (fmap . fmap . fmap . fmap . fmap $ \(_, a, _, b) -> (a,b)) and I think that there's got to be a better way.
07:27:13 <merijn> fizbin: Not really sure how you could make that cleaner (other than maybe replacing the original datatypes with something more semantics)
07:28:37 <infinisil> Well there's lens you could use
07:30:01 <fizbin> I suppose - at least with lens it'd be a different function for "look inside Maybe" vs "look inside list" 
07:31:13 <infinisil> Yeah and you could reuse this chain for accessing those inner components
07:40:07 <fizbin> It's a little verbose, but (fmap @(Either String) . fmap @Maybe . fmap @((,) Word64) . map . fmap @Maybe $ \(_, a, _, b) -> (a,b)) is at least a bit explicit about the types.
07:44:07 <literall1Crevice> I have a duration :: Maybe Int, and am composing a request using wreq. I want to add a param "duration" to my request if the duration isn't a Nothing. What's the cleanest way to do so?
07:44:11 <jgt> isovector1: how's the world travelling
07:45:12 <merijn> literall1Crevice: Depends a bit on what the API you need to use to add a parameter is?
07:46:04 <literall1Crevice> Adding a regular (non-maybe) param looks like this: defaultParams & param "key" .~ ["value"]
07:46:33 <literall1Crevice> I'm essentially looking to create a Maybe function I guess
07:46:35 <merijn> literall1Crevice: One idea that comes to mind is this (let's assum "setParam :: Int -> Request -> Request" for the example: Then you could do "setDuration = maybe id setParam maybeDuration"
07:46:43 <merijn> :t maybe
07:46:46 <lambdabot> b -> (a -> b) -> Maybe a -> b
07:47:22 <merijn> literall1Crevice: So you have id as "noop" "Request -> Request" and if the maybeDuration is just you use setParam to get a (non noop) "Request -> Request"
07:47:52 <merijn> literall1Crevice: And then you have a straightforward function you can always use regardless of Just or Nothing
07:48:09 <merijn> There might be other/nice variations of that idea depending on the exact api
07:48:21 <literall1Crevice> :t maybe id (undefined :: Int -> req -> req) (undefined :: Maybe Int)
07:48:23 <lambdabot> a -> a
07:48:30 <literall1Crevice> That's cool wow
07:48:41 <fizbin> merijn: wreq is all lens-based as its API.
07:49:07 <isovector1> jgt: it's excellent! only about a week in so far though
07:49:31 <jgt> isovector1: where are you now?
07:49:47 <merijn> literall1Crevice: Simplest solution for dealing with 'conditional" operations/APIs is always to just turn them into something you can use unconditionally :)
07:50:27 <isovector1> jgt: toronto; heading over to vancouver tonight
07:51:33 <jgt> weren't you based in Vilnius at some point? Any plans heading that direction?
08:14:27 <dmwit> literall1Crevice: If you have `mkParams :: Int -> Params` and `Params` are monoidal, then `foldMap mkParams duration` will do the trick.
08:15:40 <dmwit> Ah, yeah, looks like wreq uses `[Text]`, so that will do just fine.
08:16:11 <dmwit> req & param "key" .~ foldMap (\n -> [pack (show n)]) duration -- eg
08:23:55 <merijn> hmmm, I can't mix NamedFieldPuns and matches on one or two fields, can I?
08:29:28 * hackage miso-examples 1.2.0.0 - A tasty Haskell front-end framework  https://hackage.haskell.org/package/miso-examples-1.2.0.0 (DavidJohnson)
08:31:56 <kleisli> is there a word for the number of arguments of a function? something like "order" ?
08:32:06 <dmj`> arity
08:32:07 <merijn> kleisli: arity?
08:32:16 <dmj`> merijn: jinx
08:32:34 <jgt> "Aaaaaaaaarity then!" — Ace Ventura
08:32:34 <kleisli> yes, thank you
08:33:59 <xstill> merijn: like foo X { a = 5, b, c } = …? That seems to work
08:39:11 <merijn> xstill: oh, cool!
08:39:38 <merijn> Now if only it combined with RecordWildCards
08:40:56 <merijn> :O
08:41:20 <merijn> Wait, it does I just need to put .. last...how did I not try this before now? It always failed because I put .. first >.<
08:43:49 <geekosaur> heh
08:44:28 * hackage GPipe-GLFW 1.4.1.2 - GLFW OpenGL context creation for GPipe  https://hackage.haskell.org/package/GPipe-GLFW-1.4.1.2 (plredmond)
08:54:17 <kleisli> do literals have arity 0 or 1?
08:54:33 <merijn> kleisli: Define literal?
08:55:25 <kleisli> anything that has a type without an `->` in it
08:55:44 <merijn> Those aren't functions, so they don't have an arity
08:55:58 <kleisli> another way of asking the question is: does `id` have arity 1 or 2?
08:56:37 <merijn> kleisli: id's arity is 1
08:56:48 <kleisli> thanks
08:57:03 <geekosaur> this gives you some idea of why arity's a complex topic in Haskell, though
08:57:10 <merijn> kleisli: I feel this line of questioning might also be related to this topic: http://conal.net/blog/posts/everything-is-a-function-in-haskell
08:59:00 <kleisli> merijn: thank you
09:01:31 <infinisil> kleisli: Well really, there's no such thing as arity, because functions taking multiple arguments are really just functions returning yet another function
09:01:50 <infinisil> Function application always works on a single argument
09:02:34 <kleisli> hmm. well you might define arity as "number of applications it takes to get a value that is not a function"
09:03:24 <merijn> kleisli: Well, it becomes a tricky question when you consider expressions like: What's the arity of "id (+)"?
09:03:32 <merijn> :t id (+)
09:03:34 <lambdabot> Num a => a -> a -> a
09:05:26 <kleisli> sorry, i'm not seeing why that's a problem. `a -> a -> a` looks like it has arity 2, and that's exactly what i'd expect
09:05:58 <kleisli> oh, nevermind
09:06:01 <kleisli> i understand what you mean
09:06:03 <wagle> where's waldo?  I mean, where's the documentation of the mysterious runGhc function?  google appears to only want to tell me about the command
09:07:38 <merijn> wagle: Where did you find/encounter this function?
09:07:46 <kleisli> let me try to revise my definition of arity. "arity = number of applications to values that are not functions that yields a value that is not a function"
09:08:10 <merijn> kleisli: That's how it's commonly used within haskell, yeah
09:08:18 <jumper149> @undo { do x <- reader <$> readLn ; if isJust x then return $ fromJust x else readIOSafe reader }
09:08:18 <lambdabot> <unknown>.hs:1:1:Parse error: {
09:08:52 <merijn> jumper149: isJust followed by fromJust is a bad sign
09:09:03 <jumper149> @undo do { x <- reader <$> readLn ; if isJust x then return $ fromJust x else readIOSafe reader }
09:09:04 <lambdabot> reader <$> readLn >>= \ x -> if isJust x then return $ fromJust x else readIOSafe reader
09:09:08 <merijn> jumper149: Presumably you wanted "maybe readIOSafe return"
09:09:16 <merijn> :t maybe
09:09:18 <lambdabot> b -> (a -> b) -> Maybe a -> b
09:09:31 <jumper149> ty, im still working on it :)
09:09:54 <oats> what does this pattern-matching syntax mean?
09:10:02 <oats> fooBar game@Game {..} = ……
09:10:05 <merijn> jumper149: Whenever you think you want to use fromJust you should have a good luck at "maybe" and "fromMaybe" and see if you can use those instead
09:10:28 <merijn> oats: Which part is the part you don't get? The @, the braces, the .., or all of the above?
09:10:35 <jumper149> I tried a lot already and got kind of frustrated with maybe and fromMaybe
09:11:13 <oats> merijn: iirc, the `game@` means bind the whole term to `game`, but I don't know what the {..} means
09:11:44 <merijn> oats: Those are RecordWildCards, the GHC user guide should have a good explanation of what it does
09:11:51 <merijn> @where userguide
09:11:51 <lambdabot> I know nothing about userguide.
09:11:53 <merijn> aww
09:12:09 <merijn> @where+ userguide https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/
09:12:09 <lambdabot> Done.
09:13:07 <oats> merijn: oh, so it introduces bindings for the fields!
09:13:09 <oats> that's really neat
09:13:27 <merijn> oats: Can be confusing when you have to understand it again months from now
09:13:41 <merijn> oats: There's also NamedFieldPuns, which is a sort of middleground
09:14:21 <merijn> (I shouldn't slag RecordWildCards too much while I'm sprinkling them all over my code... >.>)
09:14:38 <oats> lol, thanks for the tips
09:15:23 <jumper149> Yey I was able to make it really short :)
09:15:29 <jumper149> readIOSafe reader = do reader <$> readLn >>= maybe (readIOSafe reader) return
09:16:16 <lavalike> I wonder why they are called puns
09:16:16 <jumper149> I guess that is why `maybe` is in Prelude and `fromJust, ...` are not
09:23:35 <dsfg> sdf
09:23:39 <dsfg> Hey guys
09:44:38 <merijn> ah, ffs
09:44:52 <merijn> Why do bigger tuples not have Foldable/Traversable instances?!
09:46:13 <sicklork1n> merijn: ?
09:51:50 <infinisil> > fmap (+1) (0, 1, 2)
09:51:53 <lambdabot>  error:
09:51:53 <lambdabot>      • No instance for (Functor ((,,) Integer Integer))
09:51:53 <lambdabot>          arising from a use of ‘e_11012’
09:52:18 <infinisil> Wait, why would you want Foldable/Traversable on a big tuple?
09:52:29 <jumper149> merijn: Because they are polymorphic?
09:52:43 <ski> @let instance Functor ((,,) w0 w1) where fmap f (w0,w1,a) = (w0,w1,f a)
09:52:46 <lambdabot>  Defined.
09:52:51 <ski> > fmap (+1) (0,1,2)
09:52:55 <lambdabot>  (0,1,3)
09:53:48 <infinisil> A MonoFoldable instance for tuples might be nice
09:57:34 <sicklork1n> ski: why the last and not the last two?
09:58:30 <infinisil> sicklork1n: Try writing that instance
09:58:51 <sicklork1n> infinisil: I can't.. 
09:59:07 <infinisil> Yea
09:59:16 <infinisil> With MonoFoldable <https://hackage.haskell.org/package/mono-traversable-1.0.11.0/docs/Data-MonoTraversable.html#t:MonoFoldable> it could work
10:00:01 <infinisil> `instance MonoFoldable (a, a, a)` and `type instance Element (a, a, a) = a`
10:11:28 * hackage dependent-sum 0.6.2.0 - Dependent sum type  https://hackage.haskell.org/package/dependent-sum-0.6.2.0 (abrar)
10:13:06 <dmwit> merijn: I, too, would like to have them. It is super dumb they don't exist.
10:13:39 <dmwit> I am against the MonoFoldable instances because it is not clear whether they should hit all the parts of the tuple, or just the last to be consistent with the Foldable instance.
10:14:26 <dmwit> Perhaps somebody should put a tiny package up on Hackage that just serves as a canonical dependency for the Functor/Foldable/Traversable orphan instances.
10:16:59 <Digitteknohippie> hi.  the content on https://wiki.haskell.org/Fixity_declaration needs work (found link from https://wiki.haskell.org/Learn_Haskell_in_10_minutes#Topics_that_don.27t_fit_in_10_minute_limit )
10:17:29 <Digitteknohippie> oh, even https://wiki.haskell.org/Operator
10:20:14 <Digitteknohippie> and idk if this is just me but, "ListT done right" ironically keeps jumping from bottom of last line, and start of first line on https://wiki.haskell.org/Category:Monad
10:29:36 <int-e> Digitteknohippie: yes it does that here as well... that's amazingly annoying. (Firefox 68.0.1)
10:30:40 <int-e> (triggered by hovering over any of the page names)
10:31:21 <MarcelineVQ> ah odd, I don't see that with chromium
10:39:59 <int-e> hmm, another factor: it only happens if the window is wide enough for 3 columns of pages here
10:40:25 <Digitteknohippie> s/last line/first column/ & s/first line/second column/  but you got what i meant anyway.
10:43:05 <int-e> Anyway, it's a glitch in the rendering engine... the CSS adds  text-decoration: underline  for a:hover in the CSS, which somehow affects the column layout without visibly changing the vertical spacing. Oh and it depends on the magnification too.
10:53:22 <dmj`> phadej: ping
10:58:17 <lyxia> Digitteknohippie: those two dead links seem like they could just be removed since they would be redundant with the one that exists.
11:00:23 <lyxia> Here, I removed them.
11:04:37 <Digitteknohippie> :/
11:16:45 <jle`> pyan: a little late, but i use Writer pretty often, and All/Any is useful for "did this happen at any time during the computation?" (ie, tell Any = it happened)
11:17:06 <jle`> pyan: also I use a lot of Applicative-polymorphic code, and All/Any is useful with Const there too
11:17:53 <jle`> ie, elem x = getConst . foldMap (\y -> Const (Any (y == x)))
11:18:03 <jle`> to see if x occurs any time in a Foldable
11:18:32 <jle`> and also a lot of times I auto-derive Monoid instances for my type (mappend every field in a record)
11:18:54 <jle`> for those sorts of record types, just having a Bool won't cut it.  you also need to say All or Any to tell how those Bools will be automatically combined
11:20:32 <geekosaur> int-e, fwiw, I've seen pango-based irc apps have problems with things that are underlined because they're different sizes for whatever reason (this seems easily triggered with font substitution). conceivably this can happen with web rendering as well
11:22:37 <MarcelineVQ> ye gods
11:24:50 <geekosaur> can't tell now, have to use webchat :/
11:26:04 <geekosaur> it's noticeable for me when (a) link underlined (b) then selected, it's rendered at a different size and messes up the rest of the line. (and there is a supposedly compatible bold font, but I can imagine metrics are wrong or mismatch rendering…)
11:30:02 <jgt> in WAI, I can use pathInfo to go from a WAI Request to just the path slugs, like /foo/bar/baz
11:30:16 <jgt> but how can I do the same without a request, just some string-like thing>
11:30:18 <jgt> ?
11:31:51 <vaibhavsagar> What would WAI's Application type look like with rank-2 types? I see that they introduced ResponseReceived to work around this.
11:34:10 <lyxia> My guess:  forall r. Request -> (Response -> IO r) -> IO r
11:34:34 <vaibhavsagar> does that require rank-2 types?
11:34:40 <vaibhavsagar> I would imagine that explicit foralls are enough
11:34:44 <geekosaur> jgt, I believe that's in network-uri package?
11:34:57 <lyxia> vaibhavsagar: not if any function takes an application as an argument
11:35:15 <lyxia> well Middleware would then be rank 2.
11:35:21 <vaibhavsagar> lyxia: that makes sense, thanks :)
11:36:16 <jgt> geekosaur: ah, I see. Thanks.
11:40:24 <phadej> dmj`: pong
11:43:59 <dmj`> phadej: can I get your bless on a servant PR
11:45:18 <srid> How long does it normally take to get upload rights on Hackage? No response to my email since 2 days ago :/
11:46:05 <merijn> srid: According to my inbox someone emailed you that you mailed the wrong address 2 minutes ago :p
11:46:32 <srid> Haha, just received it
11:55:06 <jgt> uriQuery from Network.URI gives me a String. Is there another commonly-used function that gives me a query string from a URL in the form of [(String, String)]?
11:55:15 <jgt> (of course not necessarily String)
11:55:44 <Athas> So, when is cabal-install 3 coming out?
11:56:08 <merijn> Athas: Soon, presumably?
11:56:08 <sclv> when its ready
11:56:31 <sclv> Cabal the library needs to be released before new ghc
11:56:41 <sclv> cabal-install typically comes out around the same time
11:57:45 <jgt> hmm… Maybe I can use Network.Wai.Parse.parseQueryString
11:58:41 <jgt> no, I was looking at a super old version on Hackage
11:58:42 <jgt> dammit
12:01:33 <infinisil> sclv: Cabal 3 the library has been released yesterday :) https://hackage.haskell.org/package/Cabal-3.0.0.0
12:02:10 <jgt> parseQuery . encodeUtf8 . pack . uriQuery <$> parseURI "http://localhost:3000/users?page=2"
12:02:14 <jgt> -_-
12:02:30 <Athas> That's why I asked.  I assumed that Cabal and cabal-install have semi-synchronised release schedules.
12:02:44 <Athas> Especially since the Cabal 3 ChangeLog mentions command-line options!
12:02:58 <merijn> Athas: Setup.hs has command-line options too
12:03:34 <Athas> Right.  But I am not a barbarian.
12:03:49 <merijn> Athas: Just pointing out the changelog might be referring to those :)
12:05:54 <phadej> dmj`: I have noted the PR, it's on my list
12:08:03 <vaibhavsagar> Athas: AFAICT Nix will be using Setup.hs for the foreseeable future
12:15:58 <jgt> catMaybes . fmap sequence . parseQuery . encodeUtf8 . pack . uriQuery <$> parseURI "http://localhost:3000/users?page=2"
12:16:00 <jgt> lol
12:16:07 <sclv> i meant the "same time" as ghc
12:16:11 <sclv> vs the lib which is prior
12:18:07 <dmj`> phadej: ok, I also have rights to merge, just didn’t want there to be any surprises
12:29:07 <ski> sicklork1n : wonder still ?
12:43:57 <dmwit> jgt: Wow. catMaybes . fmap sequence is truly terrible.
12:44:22 <dmwit> That code snippet is like... recursively frustrating.
12:45:06 <MarcelineVQ> dmwit: does mapMaybe sequence make you feel any better?
12:45:13 <dmwit> fold, why not?
12:45:38 <merijn> Now I wanna see this code :)
12:46:45 <dmwit> :t catMaybes . fmap sequence
12:46:47 <lambdabot> Traversable t => [t (Maybe a)] -> [t a]
12:50:39 <dmwit> (Answer to "why not fold?": because it isn't even close to similar. dmwit's mental typechecker just has bugs.)
12:53:24 <jgt> in truth, all I want to do is turn "https://www.foo.com/bar/baz?spam=eggs" into `(["bar", "baz"], [("spam", "eggs")])`
12:53:50 <jgt> but I suck at programming, and it's Friday night after a long week
12:53:50 <phadej> dmj`: feel free to, but I won't release it any time soon either
12:54:18 <phadej> dmj`: fwiw, I hope it's fair for people to be few weeks on a holiday
12:54:24 <phadej> like e.g. right now
12:54:43 <jgt> dmwit: you're welcome to have a go at a less frustrating implementation :P
12:55:03 * dmwit bows graciously
12:55:38 <dmj`> phadej: of course :) I don’t mind helping out with maintenance burden as well if people are on vacation
12:56:09 <merijn> dmj`: Fortunately we have v2-build now and you can depend on git commits! ;)
12:56:20 <phadej> dmj`: maintainence burden comes from reviewing others PRs and answering & solving their issues
12:56:33 <phadej> actual merging and releasing is really the smallest part of the job
12:56:46 <phadej> merging as in "pressing the green button"
12:58:34 <dmj`> merijn: cabal v2?!
12:58:38 <dmj`> Where have I been
12:59:21 <merijn> Well, not in cabal files directly, but at least locally/in your repo
13:00:59 <dmj`> phadej: ok had answered a few questions but hadn’t had a commit to the repo proper until today ;)
13:01:22 <dmj`> merijn: that’s pretty sweet, it’s hard I just never use cabal the executable anymore, always use runghc
13:02:00 <dmj`> clever got me on writing bash functions to build Haskell projects in the shell hook of a shell.nix that use runghc
13:02:10 <dmj`> It’s very nice
13:02:22 <dmj`> nix-shell —run repl
13:02:24 <monochrom> I would use the network-uri package to parse URLs.
13:02:34 <dmj`> nix-shell —run ghcid
13:18:20 <dmj`> doesn't seem like github has sponsored any haskell developers yet
13:20:05 <fendor> design question: we want to implement a system on a server that creates about 350 users, generates passwords for them and sends each participant an email with the password in plaintext. If we get interrupted in the process (internet dies, unexpected termination), we dont want to send the emails again, or create users twice. Ideally, we woud like to implement some kind of --resume flag that knows from somewhere where we left off. We 
13:20:05 <fendor> thought about extensive logging and parsing it on resume, restoring the state in the process, does that make sense?
13:20:17 <petercommand> dmj`: github sponsors developvers?
13:21:19 <fendor> some of the premises may be dumb but we cant change them right now
13:22:08 <dmj`> petercommand: Github matches any donation to developers who are in their sponsors program
13:22:48 <petercommand> interesting
13:23:09 <__monty__> fendor: Sounds like journaling and atomic operations in general.
13:23:23 <lavalike> fendor: a lot of sql systems have a long track record of transaction support you can leverage, I guess
13:24:50 <fendor> lavalike, so, instead of logging, insert into sql database? makes sense.
13:25:09 <fendor> __monty__, smtp mails will hardly be ever atomic, i think
13:25:49 <lavalike> fendor: exactly, there are a lot of designs you can employ, which is more of an sql discussion than a haskell discussion
13:25:59 <geekosaur> but once you hand the message off to the local smtp server, it's out of your hands
13:26:15 <geekosaur> (hint: you really do want to do this rather than send directly)
13:26:43 <__monty__> fendor: Yeah, you'd do the logging atomically "@omic starting to send mail xyz" "smtp send xyz" "@omic sent mail xyz", etc.
13:27:28 <lavalike> something as simple as having 2 tables, to-send and sent, and you move records from one to the other when things are processed, so --resume would be built in the default mode of operation
13:27:32 <geekosaur> also said local server may be a remote one, e.g. gmail, but yu want to discuss that with whoever runs said; gmail in particular will be prone to block you
13:28:25 <petercommand> geekosaur: because of all the settings that an smtp server needs to have to make sure that the email is not filtered by a spam filter?
13:28:37 <fendor> geekosaur, it is a university server, that should work
13:28:58 <geekosaur> I'll also note that sqlite supports transactions, but read the docs
13:29:32 <geekosaur> petercommand, because the remote might be transiently unavailable and you want something else to deal with resends in that case
13:29:53 <petercommand> geekosaur: right
13:29:54 <geekosaur> why conditionalize creation of the account on that when you can hand that part off to something that already knows how to deal?
13:30:23 <geekosaur> unless there's good reason to conditionalize that way, which sometimes (secure systems maybe) might happen
13:30:25 <fendor> __monty__, when is logging atomic? or is there an atomic logging library?
13:30:39 <__monty__> fendor: Consider that homework.
13:31:06 <geekosaur> mostly because your notion of atomic might not match someone else's; logging is really good at causing such mismatches
13:31:18 <geekosaur> everyone has their own preferences, it seems
13:31:30 <__monty__> My first thought was using sqlite as a journal. But lavalike's suggestion's even better.
13:31:34 <fendor> lavalike, sql sounds pretty reasonable.
13:32:01 <merijn> SQLite <3
13:32:34 <monochrom> I prefer nuclear logging. >:)
13:33:06 <geekosaur> stage trees :p
13:33:52 <monochrom> (Cryptic pun)  To take logs you must cut branches.
13:35:03 <int-e> monochrom: that sounds very complex
13:35:12 <monochrom> Yes!
13:41:12 <fendor> thank you for all your input! helped me a lot!
13:57:28 <merijn> ugh...there's no way to line wrap the LHS of a function that doesn't suck :\
13:57:58 * hackage unix-compat 0.5.2 - Portable POSIX-compatibility layer.  https://hackage.haskell.org/package/unix-compat-0.5.2 (JacobStanley)
13:58:38 <Rembane> Why do you have a LHS that's so long? 
13:58:49 <monochrom> Use shorter names >:)
13:59:04 <merijn> monochrom: They're already about as short as I can
13:59:29 <merijn> Rembane: lots of arguments and some super verbose fieldnames that are persistent's fault
14:00:13 <Rembane> merijn: Got it. Put them all in a record! 
14:00:28 <Rembane> merijn: Or a reader. 
14:01:34 <monochrom> Use 132 columns. 1990 graphics cards and dot matric printers supported 132 columns. >:)
14:01:46 <merijn> monochrom: Heresy!
14:11:27 * hackage ron 0.8 - RON  https://hackage.haskell.org/package/ron-0.8 (cblp)
14:12:02 <geekosaur> so very helpful, that
14:28:37 <monochrom> Haha it may be most useful for just its RON.Prelude
14:33:58 * hackage ron-rdt 0.8 - Replicated Data Types (RON-RDT)  https://hackage.haskell.org/package/ron-rdt-0.8 (cblp)
14:36:58 * hackage ron-schema 0.8 - RON-Schema  https://hackage.haskell.org/package/ron-schema-0.8 (cblp)
14:40:28 * hackage ron-storage 0.9 - RON Storage  https://hackage.haskell.org/package/ron-storage-0.9 (cblp)
14:40:35 * geekosaur wonders if that's a reaction to un"Fold"ing, or to the laws and docs (laws for Integral, what will they think of next)
14:41:22 <geekosaur> and Num!
14:41:30 <monochrom> Laws for Default.
14:41:49 <merijn> ...
14:41:58 <merijn> monochrom: What the hell is the law for Default?
14:42:21 <monochrom> I don't know yet! But they will think up something next. I hope.
14:42:59 <monochrom> At least I am not depraved enough to suggest laws for methodless classes. >:)
14:43:13 <merijn> monochrom: Wouldn't those laws be trivial?
14:43:54 <geekosaur> (would it be lawsy?)
14:45:18 <jle`> merijn: id def = def
14:45:52 <monochrom> hehehehe
14:46:29 <merijn> I'm going to go back to my Zen refactoring and pretend I didn't see that...
14:47:21 <__monty__> Thought that was id gaf = gaf for a second there.
14:57:21 <jle`> i haven't heard that abbreviation in a long time
14:57:41 <jle`> but id gaf = gaf sounds pretty philosophical
15:02:23 <NemesisD> is it possible to promote a value Z to its type via DataKinds, 'Z?
15:05:56 <NemesisD> i think i'm looking for `f :: a -> Proxy 'a` where `a` the `a` is statically specified
15:08:02 <merijn> NemesisD: Magic 8-ball says: Sounds like you want singletons
15:08:12 <merijn> @hackage singletons
15:08:12 <lambdabot> http://hackage.haskell.org/package/singletons
15:08:39 <NemesisD> damn, thought there was a way to do this with base. it is officially too much work for what I'm trying to do to use singletons
15:09:03 <jle`> you don't ever 'need' singletons
15:09:35 <jle`> NemesisD: well, note that f :: a -> Proxy 'a doesn't quite make sense
15:10:16 <jle`> NemesisD: but yeah, the main problem is that to GHC, the data type and its promoted type aren't linked or associated with each other
15:10:51 <jle`> what singletons does is provide a typeclass that links the two, so you can do this in a polymorphic way
15:11:04 <jle`> but you can do it for specific types without singletons if you don't care about a unifying interface for all different types
15:11:30 <NemesisD> do tell. this is a very specific use case
15:12:11 <jle`> well, another issue is that your function has to return an existentially quanitified type
15:12:29 <jle`> since the type is 'dynamically' generated from the value
15:12:46 <jle`> you don't want f :: a -> Proxy a, but rather f :: a -> (exists (x :: a). Proxy x)
15:13:12 <jle`> you don't want to promote 'a, you want to promote *a value* of type a
15:13:39 <jle`> so you have to use one of the two main ways to encode an existential type in haskell
15:13:53 <NemesisD> ccccccjfhjcucdbekbilenbfghbleibgkuhhcifjkhjt
15:13:53 <jle`> you can do f :: a -> (forall (x :: a). Proxy x -> r) -> r
15:14:03 <NemesisD> whoops, bumped my key
15:14:07 <jle`> which returns the existential in a rank-n continuation
15:14:23 <jle`> or you can create an existential data type
15:14:40 <NemesisD> i think im gonna back away slowly from this
15:14:41 <jle`> but also in the end a lot depends on what you want to *do* with the value you promote, so Proxy might not cut it in most situations.
15:15:01 <jle`> maybe that would have been a better starting place, heh. what do you want hope to accomplish by doing this?
15:24:13 --- mode: ChanServ set +o glguy
15:24:13 --- mode: glguy set -jo glguy
15:30:41 <hololeap> does the order of a pattern match change the order of the items being compared behind the scenes? is it best to but the most likely case first?
15:32:09 <selfsymmetric-mu> hololeap: I think the compiler might optimize it for you: https://github.com/ghc/ghc/blob/master/compiler/cmm/CmmSwitch.hs#L324
15:33:36 <lyxia> There is an "order" set by the language (i.e., the report) and it can often be optimized.
15:37:23 <merijn> It depends on how we're defining order too
15:37:48 <merijn> Are we talking between branches/cases or within a branch?
15:38:12 <merijn> hololeap: I think the most accurate answer is "Yes, but you probably shouldn't think about it"
15:39:03 <tolt> I'm trying to watch the amount of data sent through a TLS socket. Does anyone have any ideas on how to do that?
15:39:18 <merijn> hololeap: This'd be like the equivalent of replacing your C code with hand-rolled inline assembly, it might work, but unless you know what you're doing and have already optimised the hell out of everything else you should probably ignore it
15:44:35 <hololeap> ok, thanks
15:45:52 <merijn> hololeap: Note that there's not even any requirement that GHC evaluates patterns in the order you write them. The only restriction is that the result behaves *as if* it did
15:46:36 <merijn> hololeap: That means that, at least theoretically, it's allowed to completely reorder and shuffle comparisons around to simplify code generation, as long as it doesn't change the semantics
16:04:48 <wroathe> Anyone here have any opinions on the current landscape of haskell template engines? Specifically ones that aren't tightly coupled to HTML or CSS or anything like that
16:05:00 <wroathe> I'm looking for something ERB-like
16:40:35 <hpc> wroathe: shakespeare is pretty alright
16:41:26 <hpc> it's not a full language the way erb has access to ruby though
16:41:40 <hpc> oh wait, NOT tied to html
16:42:22 <Rembane> I think Lucid is a good library, but I don't know if it's what's needed.
16:42:50 <hpc> too tied to html
16:43:20 <hpc> it's hard to think of anything that isn't specialized to a format
16:43:46 <hpc> dhall is closer to full programming, but it's more for configs than templating...
16:44:31 <Rembane> I have used dhall for templating and it works well if you can handle some of its excentrities regarding whitespace. 
16:45:04 <hpc> and its refusal to support certain data types
16:45:27 <Rembane> I haven't run into them, so I'm happily ignorant of that.
16:46:01 <hpc> (can't compare anything but booleans, can't do much with integers)
16:46:30 <hpc> i thought there was something weird with associative data structures too, but it's not in the caveats section of hackage
16:46:33 <hpc> maybe i am misremembering
17:10:37 <mpiechotka> Is there a generalized lift? I.e. I'd like a function liftTC = id ∪ lift ∪ lift . lift ∪ ...
17:12:40 <hpc> that would be lift
17:13:27 <hpc> :t (lift :: IO a -> ListT (MaybeT IO) a)
17:13:30 <lambdabot> error:
17:13:30 <lambdabot>     Not in scope: type constructor or class ‘ListT’
17:13:30 <lambdabot> error:
17:13:42 <hpc> pretend that worked ;)
17:15:24 <mpiechotka> hpc: :t lift :: IO Bool -> StateT Int (ReaderT Char IO) Bool -> Couldn't match type ‘IO’ with ‘ReaderT Char IO’
17:15:45 <int-e> :t liftIO
17:15:47 <lambdabot> MonadIO m => IO a -> m a
17:15:48 <hpc> yeah, just realized i was confusing it with the more specific lift functions
17:16:11 <int-e> (there's a reason why that exists even though we have lift)
17:16:16 <mpiechotka> Yeah. I want liftIO... for general monad.
17:16:44 <hpc> if you use the MonadState/MonadReader/etc class methods, you shouldn't need to lift
17:16:44 <mpiechotka> For now I'm carrying (forall a. m a -> n a) but that's a bit annoying
17:18:14 <MarcelineVQ> that's reminiscent of hoist
17:18:55 <mpiechotka> hpc: I don't (or rather - I do in general but this doesn't solve the particular problem as I don't care about any class that m and n have as code is generic to them)
17:19:37 <int-e> https://hackage.haskell.org/package/transformers-base-0.4.4/docs/Control-Monad-Base.html generalises liftIO to several base monads.
17:24:50 <mpiechotka> int-e: Thanks
18:04:33 <orzo> Is this supposed to work? https://pastebin.com/Be5GFZre
18:06:33 <orzo> and if Typeable is all that is required to get the an (Int::*) from a (n::Nat) then is there a more staight forward way to accomplish it without read/show?
18:08:09 <lyxia> (KnownNat n) is the more straightforward way
18:09:39 <orzo> well, in broader terms, i don't even have kind Nat known.  I want to dispaatched based on type reflection and some cases might have Nat arguments while others don't
18:10:55 <orzo> maybe using this stuff, http://hackage.haskell.org/package/base-4.12.0.0/docs/Type-Reflection.html
18:11:06 <orzo> I could use splitApps
18:11:16 <orzo> and pick a nat out of that
18:11:27 <orzo> but i need to get the actual number at some point
18:11:58 <orzo> the only idea i have atm is this read.show hack
18:15:29 <lyxia> I don't think you can do better than that
18:17:36 <orzo> i guess a bug should be filed
18:17:41 <lyxia> The only remainder of a TypeRep's source is a string.
18:17:45 <lyxia> a bug?!
18:18:14 <orzo> yeah, either read.show shouldn't work or they should give me a more direct way
18:18:39 <orzo> it's silly to make read.show the official way to get a nat value from reflection
18:18:58 <lyxia> KnownNat is the official way.
18:19:50 <orzo> maybe there's some magic that causes Typeable to imply KnownNat once the kind is known
18:19:54 <lyxia> Even if you are using polykinds that doesn't mean there is no way to fit KnownNat
18:20:32 <lyxia> The only thing Typeable is good for is to show and compare the underlying TypeRep.
18:20:53 <orzo> that's apparently not true though
18:21:21 <orzo> i used read.show to get the Int from a Typeable Nat
18:21:52 <orzo> so Typeable is logically as good as KnownNat in the case that the kind Nat is known
18:22:05 <orzo> and reflection gives the means to make the kind known
18:22:53 <orzo> eqTypeRep
18:24:21 <orzo> don't you think thought ought to go just one step further and let me do it without read.show ?
18:24:29 <lyxia> It's only natural that a Nat is going to be Shown as a numeric string, so it can be Read, but that doesn't mean it's a good thing to do.
18:25:20 <orzo> it's the only way to accomplish what i'm trying to do
18:25:35 <lyxia> I highly doubt it is.
18:27:22 <orzo> i have some code that uses type classes for specialization, but these type classes are not understandable to anyone but the library author and they end up propogating all the way to the library user.  I want to replace the type class with generics to accomplish the specialization that way.  If that could be done efficiently, then theres no theoretical reason why it's a "bad thing to do".	Only
18:27:28 <orzo> the fact that i'd end up needing read.show makes it bad.
18:30:25 <lyxia> If you don't know the kind of n, you could still have both a (TypeRep k) for its kind k, and another constraint that reduces to KnownNat n in the event that k is Nat.
18:33:03 <orzo> is there some reason why that's better than ghc giving me KnownNat directly via the Type.Reflection library?
18:33:53 <orzo> I think i'd rather use my read.show hack than make another constraint for the user to squint at
18:35:53 <lyxia> Actually maybe that would be ok... fair enough.
18:37:17 <lyxia> I just find it so fishy that one would use Type.Reflection to know anything more than equality constraints, and maybe ordering to put in a Map.
18:38:13 <lyxia> And I'm not sure squinting at Typeable is any different than another class.
18:39:00 <lyxia> If that other class is documented, that works just as well.
18:40:43 <orzo> it's not documented
18:41:17 <orzo> documenting the current contstraint is more work than the reflection based design
18:41:41 <orzo> of course, i coul dmix reflection and thne have a more trivially documented constraint
18:48:29 <orzo> is there a way i can use type equality to arrive at a run-time witness that is polymorphic in the Nat?
18:48:58 <orzo> so i can apply a polymorphic function that will let me avoid read.show
18:49:15 <lyxia> What do you mean
18:51:26 <lyxia> Looking at the definition of TypeRep, there is no Integer value to be found. I think the proper way to get a KnownNat out of a Typeable constraint would be to change that definition.
18:59:36 <orzo> the show instance looks wild
19:00:10 <orzo> showsPrec invokes showTyCon which invokes shows
19:00:22 <orzo> hm, nm, type different
19:06:32 <lyxia> So I now think you were initially right, that read.show is the most straightforward hack, and that maybe Typeable should represent Nat as an actual Integer.
19:07:10 <lyxia> I wouldn't call read.show "the official way" even if it's the only one, though the boundary between "hack" and "proper solution" is really subjective.
19:12:21 <boxscape> Just to make sure I'm not completely misremembering because I just saw Java now supports it for primitive values - in haskell there's no way to do something like `case n of 4, 5 -> something`, right? I.e. multiple patterns in a single branch of case.  (not counting guards with equality checks because that's semantically different)
19:13:03 <MarcelineVQ> does that mean "4 or 5"?
19:13:14 <boxscape> yeah
19:13:23 <MarcelineVQ> no haskell doesn't have or-patterns currently
19:13:28 <boxscape> ok
19:13:30 <boxscape> I suppose it makes sense that it doesn't exist because I'm not sure how something like `case e of Left l, Right r` should be handled
19:13:37 <boxscape> with the different variables that have to be bound
19:14:12 <boxscape> (although, I guess you could allow it only in those cases where all patterns bind the same variables)
19:14:28 <boxscape> but that would be a bit messy, maybe
19:15:20 <MarcelineVQ> There might be an or pattern proposal somewhere where someone has hashed out what they should mean and how they work, you'd have to search around
19:15:41 <boxscape> okay
19:16:31 <boxscape> curious how Java will handle this once they implement pattern matching given that they allow it for primitive types
19:19:04 <boxscape> there was a proposal https://github.com/ghc-proposals/ghc-proposals/pull/43
19:19:56 <boxscape> and there's this library which only allows patterns that bind the same variables https://hackage.haskell.org/package/OrPatterns
19:24:16 <monochrom> Java primitive values are trivial to support.
19:24:43 <boxscape> yes, but there are proposals to extend Java's switch expression (not statement) to all sorts of classes
19:24:49 <monochrom> It is like saying "C has pattern matching too!" on the count of merely supporting it for integers.
19:24:50 <boxscape> with pattern matching
19:25:34 <boxscape> ( https://cr.openjdk.java.net/~briangoetz/amber/pattern-match.html )
19:25:57 <monochrom> or-patterns only become thorny when running into sum types.
19:27:06 <boxscape> maybe a silly example but `case i of Id a, x -> ...` also seems problematic
19:27:39 <boxscape> or even `case x of y, z -> ...`
19:28:36 <boxscape> s/Id/Identity
19:41:58 * hackage traction 0.2.1 - Tools for postgresql-simple.  https://hackage.haskell.org/package/traction-0.2.1 (MarkHibberd)
19:45:38 <oats> > case 4 of x | x `elem` [4, 5] -> Just x | otherwise -> Nothing
19:45:43 <lambdabot>  Just 4
19:46:01 <oats> not multiple patterns, but if you want to test specific values...
19:46:16 <boxscape> yeah but that requires Eq
19:46:23 <oats> tru
19:46:44 <boxscape> which admittedly is implemented for the haskell equivalents of java primitives
19:47:54 <___laika> im following aarne rante's "implementing programming languages" book for implementing a basic c-like language in haskell. i have a statement type SIfThenElse Expr Stmt Stmt, and im trying to work out how to typecheck it
19:48:46 <___laika> first is obviously just checking that the Exp is Bool typed, but im unsure how i can "decide" in the type checker between the two branches
19:49:02 <___laika> i have checkStm :: Env -> Type -> Stm -> Err Env
19:50:43 <boxscape> the two branches of the if statement? Why do you need to decide between them? Shouldn't you just check both?
19:51:30 <___laika> each check would give me a new typing environment: which one do i return? do i compose them?
19:52:36 <___laika> do the branches constitute new scopes? should i just return the environment that encloses the ifthenelse?
19:55:34 <boxscape> not sure if I'm understanding this completely, but afaik if statements in C (if you want to follow that specifications) are new scopes, so I think you should just continue with the environment enclosing it, but of course making sure to collect potential errors
19:55:51 <___laika> that makes sense :)
19:56:38 <___laika> yeah i just tried with replit/c and it seems to indicate that without braces, the branches to an if must be expressions
19:57:12 <boxscape> that doesn't sound right to me. It's just either a single statement or a block of statements
19:57:51 <boxscape> it just also happens to be the case that you can treat expressions as statements
19:57:58 <___laika> its reported by "cquery"
19:58:07 <___laika> im not sure if thats a c linter or a compiler diagnostic?
19:58:12 <boxscape> I don't know
19:58:27 <___laika> oh its the c language server
19:59:21 <___laika> might be that replit is using some dialect of C that requires that "if (expr) a else b" be the same as "expr ? a : b" if its all on one line? unsure
19:59:27 * hackage traction 0.3.0 - Tools for postgresql-simple.  https://hackage.haskell.org/package/traction-0.3.0 (MarkHibberd)
20:02:27 <MarcelineVQ> are you implementing c or just something like it? maybe your learning material can provide some clues
20:06:47 <boxscape> ___laika: does something like if (1) i = 4; else i  = 3; work?
20:06:54 <boxscape> (assuming you declare i first)
20:06:59 <boxscape> or wait
20:07:03 <boxscape> I guess those are still expressions
20:07:24 <___laika> yes, those work. what failed was if (1) int i; else int n;
20:08:01 <boxscape> hm, yeah, true, gcc says the same
20:08:14 <boxscape> well, maybe it really is either an expression or a block statement then
20:09:08 <boxscape> (keep in mind though that the if statement itself is still a statement, not an expression)
20:13:18 <boxscape> (actually all that's disallowed is variable declaration, every other statement I can think of (return, if, etc.) is allowed)
20:14:55 <___laika> interesting! boxscape++
20:30:57 * hackage monad-validate 1.2.0.0 - A monad transformer for data validation.  https://hackage.haskell.org/package/monad-validate-1.2.0.0 (lexi_lambda)
22:59:16 <jle`> hm if i have fundeps MyClass a c | a -> c, why can't ghc figure out (MyClass a c, MyClass b d, a ~ b) implies (c ~ d) ?
23:02:20 <suzu> you can just add c ~ d i guess
23:03:24 <jle`> my problem here is that i can't use c ~ d as a constraint because d is existentially quantified
23:04:32 <jle`> time for unsafeCoerce
