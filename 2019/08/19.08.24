00:02:12 <orzo> i implemented a class for converting to either
00:04:07 <orzo> maerwald: i have some code that looks like this: functorToEither :: FunctorToMaybe f => f a -> Either (f b) a
00:05:04 <orzo> the FunctorToMaybe class allows you to identify trivial cases that don't include the argument type
00:06:14 <orzo> but the functorToEither thing converts back to the original functor (rather than Nothing) in the case that the argument type is not present
00:06:21 <orzo> using that fmap trick
00:07:09 <orzo> so if the functor /f/ is an error code, it will go left, but if it is a success value it goes right and extracts the value
00:09:44 <orzo> i called it a null-preserving cast
00:29:10 <arsdragonfly> What's the best Haskell interactive shell?
00:39:29 <hololeap> ghci
00:42:12 <maerwald> s/the best/the only/
00:45:43 * hackage haskell-holes-th 2.0.0.0 - Infer haskell code by given type.  https://hackage.haskell.org/package/haskell-holes-th-2.0.0.0 (klntsky)
01:01:44 <arsdragonfly> I mean, does turtle provide a wrapper around ghci so that it could be used as a standalone shell a la bash?
01:03:07 <int-e> 'The last statement in an 'mdo' block must be an expression' -- I'm adding so many 'return ()' actions to my code because of this right now...
01:54:49 <ski> int-e : hm, how would you like to write it, without those ?
01:55:14 <c_wraith> I understand the feeling.  It'd be nice if the last binding was also the implicit value
01:56:04 <int-e> ski: I'm entertaining the idea that a default 'return ()' when the last statement is a binding might be a good idea for `mdo`.
01:57:27 <int-e> ski: I mean it's probably not, but in contrast to `do`, binding the final expression in and `mdo` may actually be useful, since it can be used earlier on in the same `mdo` block. (mdo x <- f x)
02:19:39 <koz_> mniip: Any chance you could add exponentiation of Finites?
02:39:13 * hackage linnet 0.1.0.1 - Lightweight library for building HTTP API  https://hackage.haskell.org/package/linnet-0.1.0.1 (sergeykolbasov)
02:40:43 * hackage linnet-aeson 0.1.0.1 - Aeson JSON support for Linnet  https://hackage.haskell.org/package/linnet-aeson-0.1.0.1 (sergeykolbasov)
03:00:23 <Guest_51> hello guys, I am totally new on Haskell, I just installed it, and got a little issues about the configuration: In order to run ghc and cabal, you need to adjust your PATH variable.You may want to source '/Users/h/.ghcup/env' in your shellconfiguration to do so (e.g. ~/.bashrc).
03:00:48 <Guest_51> could anyone do me a favour?
03:01:10 <Guest_51> I don't know how to adjust my PATH
03:07:44 <lavalike> Guest_51: hi, if you do  echo $PATH  you'll see your current PATH
03:08:44 <lavalike> then try   source "${HOME}/.ghcup/env"   and   echo $PATH   again, you should see it having grown to list the ghcup binaries directory
03:09:20 <lavalike> the last step is avoid having to source that file every time by hand, by putting that line in an "rc" file that your shell runs every time it starts up
03:09:55 <lavalike> if your setup is not that custom the provided example of .bashrc in your home directory might just work
03:17:11 <Guest_51> thank you very much! 
03:17:36 <Guest_51> what does {HOME} here mean
03:18:00 <lavalike> Guest_51: ${..} is the shell syntax for substituting the value of the variable named ".."
03:19:58 <lavalike> "$name" and "${name}" are almost equivalent, there are edge cases I forget!
03:30:18 <Guest_51> hs-MacBook-Pro:~ h$ /Users/h/.ghcup/env-bash: /Users/h/.ghcup/env: Permission denied
03:30:39 <Guest_51> h is my user name of may mac
03:30:49 <Guest_51> *my
03:31:14 <Guest_51> why is the permission denied
03:33:13 <Guest_51> hs-MacBook-Pro:~ h$ $/Users/h/.ghcup/env-bash: $/Users/h/.ghcup/env: No such file or directory
03:37:13 * hackage lsp-test 0.6.1.0 - Functional test framework for LSP servers.  https://hackage.haskell.org/package/lsp-test-0.6.1.0 (luke_)
03:58:06 <jakalx> Guest_51: don't write $/Users. Try with "source /Users/h/.ghcup/env"
03:59:16 <jakalx> The file is most likely not executable and that's intended, since you have to load it into your running shell via "source" 
04:01:38 <jakalx> And to avoid writing the full path to your home, you should put something like "source $HOME/.ghcup/env" into your bashrc (without the quotation marks) 
04:04:55 <Guest_51> Thanks a lot for your answerIn order to run ghc and cabal, you need to adjust your PATH variable.You may want to source '/Users/h/.ghcup/env' in your shellconfiguration to do so (e.g. ~/.bashrc).Detected ~/.bashrc on your system...If you want ghcup to automatically fix your ~/.bashrc to include the required PATH variableanswer with YES and press EN
04:04:56 <Guest_51> TER (at your own risk).Otherwise press ctrl-c to abort.YEShs-MacBook-Pro:~ h$ /Users/h/.ghcup/env-bash: /Users/h/.ghcup/env: Permission deniedhs-MacBook-Pro:~ h$ source $HOME/.ghcup/envhs-MacBook-Pro:~ h$ 
04:05:22 <Guest_51> "In order to run ghc and cabal, you need to adjust your PATH variable.You may want to source '/Users/h/.ghcup/env' in your shellconfiguration to do so (e.g. ~/.bashrc).Detected ~/.bashrc on your system...If you want ghcup to automatically fix your ~/.bashrc to include the required PATH variableanswer with YES and press ENTER (at your own risk).Othe
04:05:22 <Guest_51> rwise press ctrl-c to abort.YEShs-MacBook-Pro:~ h$ /Users/h/.ghcup/env-bash: /Users/h/.ghcup/env: Permission deniedhs-MacBook-Pro:~ h$ source $HOME/.ghcup/envhs-MacBook-Pro:~ h$ "
04:06:59 <Guest_51> HOME means Users/my username,  right?
04:07:53 <Guest_51> I don't know, what does HOME refer to?
04:10:17 <jakalx> HOME is the environment variable that points to your home directory (/Users/.h in your case). To get the actual value of it, you need to dereference it, i.e. put a $ in front of it - or ${HOME} 
04:10:59 <jakalx> your last attempt did not fail, so it looks like it woked
04:11:40 <jakalx> Permission denied is thrown at you, since you tried to execute the file
04:13:07 <jakalx> You should have ghci and such in your PATH now
04:19:19 <Guest_51> it worked!  
04:19:21 <Guest_51> thanks a lot
04:19:38 <Guest_51> your answer is super clear
05:21:14 <forsenhead> good fucking morning bajs
06:31:41 <oo_miguel> I am reading https://wiki.haskell.org/All_About_Monads#Definition_7 and wonder If it should not be "instance MonadReader e (Reader e) where" instead of "instance MonadReader (Reader e) where" ?
06:34:50 <merijn> oo_miguel: The latter definitely looks wrong, so "probably" :p
06:35:24 <oo_miguel> merijn: Heh, so Ill change it to "my" version. 
06:36:16 <oo_miguel> thanks for confirming
07:11:20 <bwe> Hi, how can I define a type instance for a type synonym correctly? https://bpaste.net/show/NG7K -- warning: [-Worphans]
07:12:11 <merijn> bwe: Correctly? You can't :p
07:12:35 <merijn> bwe: First of all, type is equivalent to Int in that example
07:12:53 <merijn> bwe: So defining ToHtml for MyType is literally the same as defining one for Int
07:13:19 <merijn> type is only for aliases, they behave (effectively) as textual substitutions
07:14:02 <merijn> bwe: If you want to create a new type that's different from Int you want newtype (hence the name), which will also solve your orphan warning, because defining the newtype and instance in the same module means there's no orphan
07:17:35 <bwe> merijn: okay, I want newtype =).
07:17:37 <bwe> thanks
07:20:06 <bwe> :r
07:30:51 <ski> int-e : hm, okay
07:31:58 <ski> i suppose i might've been thinking of cases with nested `do's, where one'd like a binding in an inner one to be made available in an outer one, without having to explicitly use `return'/`pure' at the end of the inner one, then catch it with a `<-' in the outer one
08:11:56 <int-e> ski: hmm. that didn't come up for me; I even used some nested mdo-s to scope bindings :)
09:26:56 <fresheyeball> morning weekend haskellers?
09:31:23 <ski> int-e : *nod*. i was curious about the kind of situation you were having, i suppose, whether it might fit what i was thinking about
09:32:37 <kageyoni> hey haskell noob here 
09:32:50 <int-e> ski: Just some meta-programming. https://gist.github.com/int-e/57eefc6cce29ed47ddaaca13a0774533#file-quine-hs
09:35:29 <int-e> ski: So basically, I'm using `mdo` for managing and resolving labels in a assembler-like DSL.
09:44:59 <ski> hm, seems `digit' is the only one with nested `do'/`mdo', that also has this extra `return' added at the end ?
10:15:30 <int-e> ski: I had more at some point, then went back...
10:17:16 <int-e> ski: So yeah, this isn't representative of that idea anymore. (At some point I had an inlined and adapted if-then-else somewhere. Then I went back and abstracted from that modification, and with it went the local mdo...)
10:19:28 <int-e> ski: and indeed `digit` is the only place that does non-trivial knot-tying of any kind.
10:20:09 <int-e> (but I didn't expect you to look this closely!)
10:47:51 * ski nods
11:03:01 <mnrmnaugh> there once was a man from nantucket
11:03:21 <mnrmnaugh> whose spacebar was so fixed he might fuck it?
11:03:31 <mnrmnaugh> wew thats eh
11:03:52 <mnrmnaugh> well idk why its plastic anyway
11:04:34 <mnrmnaugh> i added extra rubbery domes inside the scissors. before it was just one dome in the middle
11:04:39 <mnrmnaugh> !glare
11:05:22 <mnrmnaugh> oops
11:05:35 <mnrmnaugh> completely.. wrong.. channel...
11:09:30 <iqubic> Yes. Yes it is.
11:10:44 * hackage decidable 0.2.1.0 - Combinators for manipulating dependently-typed predicates.  https://hackage.haskell.org/package/decidable-0.2.1.0 (jle)
11:17:33 <Rich[m]11> Hi. I'm trying to enable profiling in my cabal new style project. It does not seem to be able to build my project, it says: "Perhaps you haven't installed the profiling libraries for package ‘base-4.11.1.0’?".
11:17:44 <Rich[m]11> Has someone else had this issue? I can't seem to find much information about this.
11:18:59 <Rich[m]11> As far as I understand, the new style building should build all libraries with profiling automatically once passed "--enable-profiling" to "cabal new-build".
11:23:04 <cocreature> Rich[m]11: base is special since it comes with GHC and cabal doesn’t know how to rebuild it. Usually GHC should come with a profiling version of base but it looks like you don’t have one. Where did you get GHC from?
11:28:02 <Rich[m]11> cocreature: ah, I wrongfully assumed cabal new style downloads its own ghc (similar to stack). I now installed the ghc-prof package in debian and it seems to be building, thanks.
11:32:46 <merijn> Rich[m]11: Yeah, cabal just uses whatever GHC is on your PATH (or whatever GHC you explicitly tell it to use)
11:56:19 <infinisil> Let's say I have some opaque function, and I'd like to cache results of this function to disk for later reuse. How can I make sure that later versions of the function don't reuse the old caches?
11:56:42 <infinisil> One way is to just give it a name/identifier and change this every time I do a change to the function, but that's error-prone
11:57:39 <infinisil> An alternative I looked into previously was to generate a hash from the implementation with TemplateHaskell, but it turned out to be impossible (because you can't inspect definitions with TH as of now)
11:57:59 <gentauro> finally home after ICFP :)
11:58:19 <infinisil> Now an alternative that might actually work is to just throw a bunch of random data at the function, see what it produces, and generate a hash based on that, which I can then use for caching
11:58:38 <merijn> infinisil: So I had the exact same problem and in the end I just gave up
11:58:41 <infinisil> Does that sound reasonable or am I not seeing something more obvious?
11:59:06 <merijn> infinisil: If you can segregate the function into a separate file you could write TH that, at compile time, checks the last git commit that changed that function's file
11:59:07 <slack1256> infinisil: that last one seems reasonable
11:59:11 <merijn> Which is, roughly, what I do now
11:59:30 <gentauro> (from now should be called "Mr. Math" cos Daniel Friedman says so (he noticed the "math" in my surname) xD
11:59:47 <infinisil> merijn: Hm yeah or even just hash the whole file's contents directly
11:59:54 <merijn> infinisil: Right
12:00:22 <infinisil> slack1256: Of course with this idea of throwing random data at it, you can never be sure if all paths of the function were taken and such
12:00:38 <infinisil> But it would be the neatest in a way
12:00:40 <merijn> infinisil: That's less accurate, but should at least rule out false negatives (i.e. wrongly not recomputing) at the cost of sometimes unnecessarily recomputing when you change imports or something
12:01:03 <merijn> infinisil: Essentially, there is no real way to prove extensional equality in general :p
12:01:11 <infinisil> Yeah, I wouldn't mind the occasional recompute
12:03:32 <infinisil> Idea: Parse the file the function is in to an AST (from the ghc package or so, not sure how I could do that), then extract the subtree for only the function, and hash it
12:03:44 <infinisil> And that all with TH
12:04:00 <merijn> ghc is...not a lightweight dependency :)
12:06:24 <infinisil> With this I suppose: https://hackage.haskell.org/package/ghc-8.6.5/docs/Parser.html#v:parseModule
12:07:05 <infinisil> Might be the cleanest solution
12:07:30 <merijn> infinisil: That will still give you false positives, though
12:07:43 <infinisil> You mean false recomputes?
12:07:46 <merijn> Yeah
12:07:49 <infinisil> How so?
12:08:06 <merijn> infinisil: Who guarantees the AST will be the same across GHC versions?
12:08:19 <infinisil> Ah well, that's fine
12:08:20 <merijn> So even if the code hasn't changed, if the GHC version has you'll detect it as a change
12:08:31 <merijn> Seems like it'd be considerably less effort to just hash the source code
12:08:33 <infinisil> GHC version won't get changed often
12:08:37 <infinisil> Probably :P
12:11:13 <infinisil> Also I'd have to make the whole AST be hashable..
12:12:45 <infinisil> Although, it does have instances for Data and Outputtable, maybe those could be used
12:13:23 <merijn> Public service announcement: No one has *ever* regretted including version numbers in their schema/protocol/file format (this message brought to you by my appreciation for past me including a version number...)
12:13:47 <infinisil> Hehe
12:16:40 <infinisil> merijn: Another approach I thought about was to encode the whole computation as a data structure, but that would be really painful
12:16:53 <merijn> infinisil: Yes
12:16:56 <infinisil> And wouldn't work for arbitrary functions
12:17:17 <merijn> infinisil: Like I said, there's a reason why, after spending weeks pondering this, I just ended up querying the git commit for specific files :p
12:18:05 <infinisil> I often do lots of experiments before committing anything, so I'd probably use the file hash if I go this route
12:18:09 <infinisil> But yeah maybe that's the way to go
12:19:20 <infinisil> Ohh another idea: A GHC plugin
12:19:46 <infinisil> Why parse the file with TH and extract information for it when I could just reuse ghc's parsed result
12:20:32 <turab> Suppose that I have test cases in a text file. What's the recommended way to testing these cases? I have looked in golden testing but that seems opposite to what I am doing
12:20:35 <infinisil> Of course I have no idea how to write a GHC plugin, and not sure if it's even possible to have it output some data to be used in your program (probably not now that I think about it)
12:20:54 <turab> Is it okayu if I just stick with HUnit or is there something better?
12:25:33 <arpl1> Error: "Constraint is no smaller than the instance head". What is the instance head?
12:28:59 <merijn> arpl1: The constraint onf the instance
12:29:20 <merijn> arpl1: Lemme guess, you're trying to use constraints to select between multiple overlapping instances?
12:32:11 <arpl1> Dank je Merijn.      I knew it had to be something simple because when I googled the term was simply used without explanation.
12:32:11 <arpl1> No, I was just using the error message that I found online. I was actually trying to make sense of the following: ¨ And, by the way, specifying the type of fmap in thisinstance, or more generally, of any method in any instance, isunnecessary. It’s fully determined from the instance head, where wesaid that Parser is who we are giving this instance to.¨
12:42:12 * hackage monoidal-containers 0.6 - Containers with monoidal accumulation  https://hackage.haskell.org/package/monoidal-containers-0.6 (abrar)
12:58:13 * hackage replace-megaparsec 1.0.0.0 - Stream editing with parsers  https://hackage.haskell.org/package/replace-megaparsec-1.0.0.0 (JamesBrock)
13:31:13 * hackage reflex 0.6.2.4 - Higher-order Functional Reactive Programming  https://hackage.haskell.org/package/reflex-0.6.2.4 (abrar)
13:57:22 <iqubic> koz_: To assign a different Finite to each possible inhabitants of a `Vec (n :: Nat) (x :: Type)` I'd use base n positional notation, where n is the number of inhabitants of the type x. So, Bools could be assigned using binary adjacent numbering scheme, and Orderings could use a trinary analog. Of course this means that if you need `Instance (Finitary n x, KnownNat m, k ~ (n ^ m)) => Finitary (Vec m x) where ...` or something like that
13:57:36 <iqubic> But I'm sure you could have figured that out yourself.
13:58:48 <iqubic> I just had this thought late last night, when lying in bed. I was way to tired to get out my laptop and type it up.
13:59:22 <iqubic> `Instance (Finitary n x, KnownNat m, k ~ (n ^ m)) => Finitary k (Vec m x) where ...` is what I meant to type.
13:59:46 <iqubic> I forgot to add the k on the right of the fat constraint arrow.
14:04:11 <iqubic> Not sure that I got the KnownNat constraint right, but hopefully the compile will yell at you and give the fix.
14:07:47 <iqubic> :k Eq
14:07:49 <lambdabot> * -> Constraint
14:07:58 <iqubic> I hate the star is type thing.
14:08:29 <koz_> iqubic: Thanks - I had that figured out, don't worry. :P
14:08:57 <koz_> For fixed-length vectors of Finitaries, it's basically 'strings over an alphabet with n symbols' in lex order.
14:09:08 <koz_> (which is also how you get the n ^ m thingo)
14:09:15 <iqubic> Right. Yes.
14:09:32 <koz_> I also realized I could use Finitary to define a very efficient set structure.
14:09:35 <iqubic> But you don't have to restrict the type of the elements of vector that much.
14:09:36 <koz_> Possibly also a map structure.
14:09:55 <koz_> iqubic: Hence the 'basically'.
14:10:04 <koz_> You can treat any Finitary as an alphabet with n symbols.
14:10:07 <koz_> (essentially)
14:10:08 <iqubic> All you need to do is ensure that what ever the type of element your vector is storing, it has a Finitary instance.
14:12:14 * koz_ also needs to write proper documentation for finitary.
14:12:28 <iqubic> The way I think about it is thusly: There are n choices for what element comes first, followed by n choices for what element comes second, followed by n choices for what element comes third... all the way up to M elements.
14:12:52 <iqubic> It works out to be n * n * n * n * n... = n ^ m inhabitants.
14:13:53 <koz_> Yup. To get a mapping into Finite n^m, you just treat that as if it were a string over an alphabet with n symbols, and use lex ordering.
14:14:01 <koz_> (which is what I meant, lol)
14:15:40 <iqubic> Meanwhile, I'm reading through Thinking with Types and noticing that the examples for Eq applied to type level lists are incomplete. Page 59 is what I'm looking at. Sandy leaves off the two case where you compare a list made with (:#) to a list constructed with HNil and get False as the answer.
14:16:08 <iqubic> This is Heterogeneous type level lists mind you.
14:16:35 <koz_> iqubic: You can email him and ask what the deal is with that.
14:16:46 <koz_> He's fairly responsive, and will correct things if pointed out.
14:16:50 <koz_> (speaking from experience)
14:17:35 <iqubic> Like the code doesn't have a case for dealing with (HNil == 5 :# True :# HNil)
14:18:18 <iqubic> Which should clearly be false, but you can't prove that from just the single base case and inductive case.
14:18:41 <iqubic> the code written assumes that the two lists you are comparing were made from the same constructor.
14:20:00 <iqubic> Like he writes this cool type family to check if a constraint holds for every type of element in the list, and then goes ahead and writes an incomplete Eq function.
14:20:24 <iqubic> The code on page 59 really bothers me.
14:20:28 <koz_> Let me have a look.
14:21:01 <EvanR> you might be misreading it, incomplete-looking functions can happen when the case are impossible (would be ill typed)
14:21:37 <koz_> I think I've got a stale version, lol, since my page 59 doesn't contain any code.
14:21:41 <koz_> Let me update that real quick.
14:21:55 <iqubic> Oh. I see. Also, I might be the one with a stale version.
14:22:08 <koz_> Yours is purchased _yesterday_ no?
14:22:13 <koz_> So likely the stale version is mine.
14:22:18 <koz_> Since I bought _literally_ on release.
14:22:19 <iqubic> Well, yeah. I assume so.
14:22:21 <iqubic> Oh.
14:22:57 <iqubic> I'm looking at the Eq instance defined on heterogenous lists in chapter 5.
14:23:04 <iqubic> I don't think that's page 59.
14:23:10 <iqubic> I don't have the book open.
14:23:24 <iqubic> I'm just trying to recall the page number from memory.
14:23:50 <koz_> OK, seems like mine is current.
14:24:08 <iqubic> Yeah. I don't recall what page this was on.
14:24:09 <iqubic> Sorry.
14:24:18 <iqubic> it's near the end of chapter 5.
14:24:31 <iqubic> Like I said, going from memory.
14:24:55 <iqubic> I'm away from the computer where I downloaded the book.
14:25:13 <koz_> Well, if you find the page some time, let us know and we'll see what's happening there.
14:25:23 <iqubic> I will.
14:28:13 <iqubic> Wait... I see the issue.
14:28:22 <iqubic> :t Eq
14:28:24 <lambdabot> error:
14:28:24 <lambdabot>     • Data constructor not in scope: Eq
14:28:24 <lambdabot>     • Perhaps you meant one of these:
14:28:29 <iqubic> :t (==)
14:28:31 <lambdabot> Eq a => a -> a -> Bool
14:28:45 <iqubic> See, that requires the two inputs to be the same type.
14:28:57 <koz_> Yep.
14:29:59 <iqubic> So (HNil == 5 :# HNil) is a type error, because the type of the lhs is '[] and the type of the rhs is '[ Int ]
14:30:08 <koz_> Indeed.
14:30:08 <iqubic> So you can't actually compare those.
14:30:10 <EvanR> that's probably not the same ==
14:30:19 <iqubic> It is.
14:30:32 <EvanR> type family (a :: k) == (b :: k) :: Bool
14:31:36 <iqubic> No. Sandy's code is showing the Eq instance for type level heterogenous lists.
14:32:02 <EvanR> the fact that you are saying "type level list" says to me (==) on the value level is not happening
14:32:20 <iqubic> Oh. I see.
14:32:32 <iqubic> I might be misunderstanding what's going on here.
14:32:50 <iqubic> And not having the book in front of me is a bit of an issue.
14:33:06 <iqubic> Trying to recall this chapter from memory isn't happening.
14:35:32 <EvanR> there's a standardish type level equality which allows the two sides two be any two types, not necessarily the same. Called heterogenous equality
14:37:15 <iqubic> I see.
14:57:43 * ski . o O ( "John Major equality" <http://strictlypositive.org/dtp99/07jmeq.html> )
14:58:10 <iqubic> I don't actually think this is a type level list, but this is what was refering to: http://dpaste.com/3T6ZFWV
14:58:54 <iqubic> No way to compare like this: `HNil == (5 :# True)`
15:01:37 <koz_> ski: That's both brilliant and hilarious.
15:03:55 <iqubic> Sandy then goes on to rewrite the instance as this: http://dpaste.com/3HCWE4K
15:04:07 <iqubic> It is this second version that I think is missing a few cases.
15:05:16 <iqubic> I think it should be rewritten to include `HNil == _ = False` and `_ == HNil = False` as two more cases sandwiched in between the two already existing cases.
15:05:42 <iqubic> But I'm not skilled enough to know why those cases were not included.
15:06:21 <iqubic> Of course, I omitted a ton of langauge pragmas there.
15:06:51 <iqubic> Would anyone clever like to tell me what I'm missing?
15:07:15 <iqubic> This is in the last few pages of Chapter 5.
15:09:25 <ski> koz_ : McBride is great :)
15:10:38 <iqubic> So, am I missing something fundamental in that code that makes `HNil == (5 :# True)` invalid?
15:10:49 <iqubic> It seems like we should be able to add that to the code.
15:11:00 <iqubic> Except I don't think we can.
15:12:27 <iqubic> Because the type of (==) is a -> a -> Eq and HNil :: '[] and (5 :# True) :: '[ Int, Bool ] which makes that impossible to compare.
15:13:05 <iqubic> Because calling `HNil == (5 :# True)` is like asking for (==) :: a -> b -> Bool
15:13:12 <iqubic> Which is wrong.
15:13:29 <merijn> Pfft
15:13:37 <iqubic> Seems like a bit of a restriction if you ask me.
15:14:17 <iqubic> I mean, the All type family is a wicked cool way of simulating existential types, but it seems to fall short to me.
15:14:36 <merijn> @define compareAllTheThings :: (Typeable a, Typeable b, Eq b) => a -> b -> Bool; compareAllTheThings x y = cast x == Just y
15:14:38 <lambdabot>  Defined.
15:14:45 <merijn> > compareAllTheThings 1 True
15:14:48 <lambdabot>  False
15:14:50 <iqubic> Huh? How does that work?
15:14:51 <merijn> > compareAllTheThings 1 1
15:14:54 <lambdabot>  True
15:15:00 <merijn> > compareAllTheThings 'c' 'a'
15:15:03 <lambdabot>  False
15:15:07 <merijn> iqubic: Mad hax
15:15:09 <merijn> ;)
15:15:25 <iqubic> And can we use that with the heterogenous lists defined in the pastes above?
15:15:29 <merijn> > cast 'c' :: Maybe Bool
15:15:32 <lambdabot>  Nothing
15:15:35 <merijn> > cast 'c' :: Maybe Char
15:15:38 <lambdabot>  Just 'c'
15:15:50 <merijn> iqubic: Maybe...Typeable is a pretty giant hammer, though...
15:16:12 <iqubic> Would that allow us to finally compare HNil to (5 :# True)?
15:17:23 <iqubic> As it stands, we can't even do `(5 :# HNil) == `(True :# HNil)`
15:17:48 <Gigabitten> I swear I'll get Reflex working someday but apparently not yet
15:17:50 <iqubic> Also, I just now realized that I had been leaving off the final HNil in my examples from before.
15:17:57 <merijn> iqubic: I mean, you can compare those lists that way, IFF you require Typeable constraint on all elements in the list
15:18:03 <Gigabitten> oh wrong chat
15:18:34 <iqubic> merijn: (All Typable ts) is the constraint I'll use.
15:18:47 <iqubic> All being defined here: http://dpaste.com/3HCWE4K
15:19:12 <iqubic> I'm leaving off the langauge pragmas for easier readability.
15:24:33 * ski . o O ( "A Case for Dependent Families" by Conor McBride at <http://strictlypositive.org/a-case/> (.. don't just press "next") )
15:26:31 <EvanR> iqubic: there is another kind of equality in haskell, TestEquality, which allows you to effectively do a test on two things and get a maybe back of the proof
15:31:38 <iqubic> How does that work?
15:33:59 <EvanR> depends on the implementation of the class
15:34:34 <EvanR> this is haskell's version of Decidable
15:35:26 <iqubic> Ah. I see.
15:35:35 <iqubic> Sounds interesting.
15:35:58 <EvanR> probably not what you were looking for, i'm just going by what you said
15:39:37 <iqubic> What I was looking for was probably not actually helpful tbh.
15:40:06 <iqubic> I really love the fact that you can create things like the All higher ordered constraint.
15:45:07 <laika___> what would be a sensible definition for `Alt` in this core AST? http://dev.stephendiehl.com/fun/007_path.html#core
15:45:55 <laika___> GHC's Core allows an `AltCon` which can be a data constructor or a literal, but i actually can't plainly see how data constructors fit into this AST at all ...
15:49:05 <laika___> i assumed `Placeholder` was meant for bottom values, but would it also cover algebraic datatypes?
15:53:24 <laika___> or perhaps `Var` could, but that doesn't seem exactly sensible ... it would make for an easy `AltCon` datatype (a sum type to combine Literals and Vars) but it still seems like there should be something that fits better
15:55:57 * ski . o O ( <http://strictlypositive.org/a-case/images/jm-equal.jpg> )
16:11:36 <EvanR> is John Major well known outside the british sphere
16:12:17 <merijn> As non-Brit I feel fairly confident in saying "no" :p
16:12:35 <merijn> It tooks me a substantial amount of googling to figure out what he was referring to in that paper
16:14:51 <EvanR> ok he was prime minister between thatcher and blair... i guess that's worth knowing
16:15:59 <laika___> between a rock and a hard place
16:32:59 <iqubic> What does John Major have to do with equality?
16:33:19 <merijn> iqubic: Pretty sure it was a critique of politics/economic policy
16:34:02 <ski> "\"John Major equality,\" a name coined by Conor McBride as an inside joke about British politics."
16:35:15 <laika___> "“It is now time to reveal the definition of ≃, the ‘John Major’ equality relation. (Footnote 2: John Major was the last ever leader of the Conservative Party to be Prime Minister (1990 to 1997) of the United Kingdom, in case he has slipped your mind.) John Major’s ‘classless society’ widened people’s aspirations to equality, but also the gap between rich and poor. After all, aspiring to be equal to others
16:35:16 <laika___>  than oneself is the politics of envy. In much the same way, ≃ forms equations between members of any type, but they cannot be treated as equals (ie substituted) unless they are of the same type. Just as before, each thing is only equal to itself.”"
16:35:37 * ski was just about to say that :)
16:35:37 <laika___> from comments on https://homotopytypetheory.org/2012/11/21/on-heterogeneous-equality/
16:35:49 <ski> "(Of course, Conor’s prediction in the footnote was refuted with the election of David Cameron in 2010.)"
16:35:59 <iqubic> I see.
16:36:34 <ski> s/aspirations/aspirations/
16:37:11 <ski> (i'd like to hear about presbyterian and catholic indices, some time)
16:44:00 <iqubic> :t runCont
16:44:01 <lambdabot> Cont r a -> (a -> r) -> r
16:44:15 <iqubic> Uh...
16:51:43 <koz_> :t foldr
16:51:45 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
16:52:09 <ski> @let evalCont :: Cont o o -> o; evalCont = (`runCont` id); evalContT :: Applicative i => ContT o i o -> i o; evalContT = (`runContT` pure)
16:52:10 <lambdabot>  Defined.
16:52:39 <ski> @type [cont . flip f | f <- [all,any]]
16:52:41 <lambdabot> Foldable t => [t a -> Cont Bool a]
16:54:25 <koz_> :t foldM
16:54:27 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
16:54:42 <koz_> I can never, for the life of me, remember the order of those fold{r,l,M} arguments.
16:56:29 <Rembane> Me neither. Having the types of them on a very small cheetsheat in front of me helps a lot. 
16:56:57 <koz_> Rembane: I'm sure there's some kind of clever mnemonic.
16:57:08 * koz_ recently heard one for the C-style ternary operator which still makes me lol.
17:00:05 <iqubic> What?!?! Why?
17:00:16 <iqubic> That's just if, then, else.
17:00:33 <iqubic> Bool ? a : a
17:04:56 <iqubic> data Any = forall a. Any a
17:05:03 <koz_> iqubic: I always forget the 'then, else' part. The mnemonic in question is W ? T : F.
17:05:03 <iqubic> Why is such a thing useful?
17:05:20 <koz_> iqubic: It allows us to have dynamic typing, but in a much safer and more controlled way.
17:05:22 <iqubic> That's really really great.
17:05:37 <iqubic> koz_: I assume you can add constraints to a?
17:06:01 <koz_> iqubic: If you read Sandy's book a bit further, you'll see what else we can do.
17:06:08 <iqubic> I will.
17:06:15 <iqubic> I only just started this chapter.
17:06:28 <iqubic> I knew most of everything that came before this.
17:06:54 <koz_> :t traverse_
17:06:55 <lambdabot> (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
17:07:37 <iqubic> That is a interesting type.
17:07:49 <koz_> :t foldM_
17:07:50 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m ()
17:07:56 <iqubic> Looks like it just doesn't return the final value.
17:07:59 <koz_> Nearly identical.
17:08:08 <iqubic> Is that only useful for IO?
17:08:11 <koz_> Nope.
17:08:15 <koz_> It's also useful for ST.
17:08:20 <iqubic> Ah.
17:08:22 <iqubic> right.
17:08:26 <koz_> (which is exactly how I'm using it here)
17:08:42 <iqubic> Memory manipulation shenanigans
17:09:05 <koz_> More like 'mutable state manipulation shenanigans'.
17:09:13 <iqubic> Right.
17:09:23 <iqubic> So like mutable array and stuff.
17:09:28 <koz_> Yep.
17:10:29 <iqubic> Testing
17:11:08 <iqubic> Are functions of type "forall a. a -> r"? Why or why not?
17:11:43 <koz_> Are functions of type 'forall a . a -> r'... what?
17:11:45 <iqubic> The question is supposed to be asking if such a function is interesting or not.
17:11:59 <iqubic> Interesting / useful / worth looking at.
17:12:08 <iqubic> My IRC client bugged out.
17:12:24 <iqubic> I claim that eliminators of this type are not all that useful.
17:12:50 <iqubic> Am I wrong about this?
17:13:37 <koz_> iqubic: Read on, lol.
17:13:55 <koz_> Sandy addresses your queries much better than I can, mostly because I kinda skimmed that section.
17:14:09 <no-n> What book?
17:14:17 <koz_> no-n: Thinking with Types.
17:14:29 <iqubic> Thinking With Types. Written by Sandy Maguire.
17:14:31 <laika___> https://leanpub.com/thinking-with-types
17:15:21 <iqubic> koz_: You know when I asked if we could put a constraint on the type of a in "data Any = forall a. Any a"? It turns out you can.
17:17:17 <laika___> "data ShowAny = forall (Show a) => a. ShowAny a"?
17:17:35 <iqubic> I don't know the normal way you'd do it.
17:17:42 <iqubic> I only know how to do it with GADTs.
17:18:19 <iqubic> data ShowAny = forall a. (Show a) => ShowAny a
17:18:26 <iqubic> That's the normal way to do it.
17:18:28 <laika___> ++
17:19:12 <iqubic> And then you can do "map show (xs :: [ShowAny])"
17:19:37 <laika___> thats the idea, i think!
17:19:54 <laika___> ive seen it implemented in the wiki as ShowList i think
17:20:13 * koz_ just got the 'GHC doesn't yet support impredicative polymorphism' error from runST argh.
17:21:05 <iqubic> laika___: data ShowList = ShowList [ShowAny]
17:21:22 <iqubic> koz_: What are you doing?
17:21:40 <laika___> or more conveniently just `type ShowList = ...`
17:22:04 <iqubic> It would be "type ShowList = [ShowAny]"
17:22:09 <koz_> iqubic: Basic mutable vector things.
17:22:26 <koz_> runST requires a few hacks in the GHC typechecker, which don't always play nice.
17:22:31 <iqubic> It can't be too basic if you are trying to use an unsupported feature.
17:23:12 <iqubic> laika___: "data ShowList = forall a. Show a => [a]" also works.
17:23:44 <laika___> still curious if anyone can point me in the direction of a sensible way to model `Alt` in stephen diehl's Core grammar in WYAH http://dev.stephendiehl.com/fun/007_path.html#core
17:38:56 <ski> @where TwT
17:38:56 <lambdabot> I know nothing about twt.
17:38:59 <ski> @where+ TwT "Thinking with Types: Type-Level Programming in Haskell" by Sandy Maguire in 2019-01-10 at <https://leanpub.com/thinking-with-types>
17:38:59 <lambdabot> Done.
17:53:01 <koz_> ski: Thanks!
18:01:54 <koz_> :t foldr
18:01:57 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
18:02:05 <no-n> It looks good. I'm reading the sample.
18:09:38 <koz_> Could someone give me a conciseness hint? https://gist.github.com/kozross/5f15061bafa3b3bd17417ad3e2e817cb
18:10:34 <koz_> (yes, it is more Finitary shenanigans)
18:17:06 <ski> np :)
18:36:41 <koz_> Is set difference associative?
18:39:10 <koz_> Never mind, found it, it's not, sads.
19:31:11 <koz_> Where did unfoldr go?
19:31:52 <koz_> Oh, never mind, misread Hoogle.
20:02:15 <dmwit> koz_: Presumably your deeply-nested `if` at least can be simplified a lot.
20:02:25 <koz_> dmwit: Surprisingly, I missed a case. :P
20:02:30 <dmwit> e.g. by setting an appropriate ordering on SetRelation and then using minimum or similar.
20:02:38 <dmwit> (A safe version of minimum, I mean.)
20:02:44 <iqubic> What is this issue here?
20:02:56 <koz_> I ended up using MultiWayIf.
20:03:03 <koz_> I might try and boil it down some more by using ordering.
20:03:08 <koz_> iqubic: Very wordy code.
20:03:09 <iqubic> What is MultiWayIf?
20:03:15 <koz_> (and, as it turned out, _incorrect_ wordy code)
20:03:20 <koz_> https://stackoverflow.com/questions/50788238/haskell-multi-way-if-expressions-need-multiwayif-turned-on
20:03:24 <koz_> ^ see code for example)
20:04:41 <iqubic> Why would you use MultiWayIf, if guards exist?
20:04:58 <koz_> You can't use guards after a let-bind, which is what I'm doing there.
20:06:33 <iqubic> I just returned from getting food. I have no idea what code snippet we are talking about.
20:06:36 <iqubic> Sory.
20:06:44 <koz_> iqubic: Don't worry about it, lol.
20:07:34 <iqubic> While I was away, I came to the conclusion that Existential types are to FP/Haskell as Interfaces are to OOP. I think. I might be wrong about that.
20:07:50 <iqubic> But that's something clever I came up with while I was away.
20:08:07 <dmwit> koz_: Can you just do a Set.fromList on `VUS.zip left right`?
20:08:37 <slack1256> I thought Interfaces on OOP were just a way to avoid the diamond problem on subclassing.
20:09:06 <iqubic> slack1256: That's one use for them.
20:09:07 <dmwit> koz_: Then e.g. `if member (True, True) results then ... else Just Disjoint`
20:09:15 <koz_> dmwit: Yeah, that might work.
20:09:20 <iqubic> But also, a type class is like an interface.
20:09:53 <iqubic> Because a type class provides a list of type signatures, just like an interface does.
20:09:55 <dmwit> koz_: (And again, a suitable minimumBy or maximumBy should simplify the nested if-then-else.)
20:10:09 <slack1256> Yep
20:10:09 <koz_> Yeah, I should have a suitable Ord instance in any case.
20:15:37 <iqubic> :t fromMaybe
20:15:38 <lambdabot> a -> Maybe a -> a
20:15:44 <iqubic> :t Asum
20:15:46 <lambdabot> error:
20:15:46 <lambdabot>     • Data constructor not in scope: Asum
20:15:46 <lambdabot>     • Perhaps you meant one of these:
20:15:51 <iqubic> :t asum
20:15:53 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
20:24:14 <mac10688> I'm trying to make a "Game Of Life" haskell program with reactive-banana and ncurses but I have a problem combining the two monads :/
20:24:34 <mac10688> ncurses is a Monad and MomentIO is a monad
20:24:39 <mac10688> is this a common problem?
20:25:24 <EvanR> there might be a way to convert IO to MomentIO so you can execute it
20:25:45 <mac10688> yeah there is with liftIO and I thought that was going to solve my problem
20:26:18 <mac10688> but as soon as Ncurses executs and leaves the monad, it clears the screen. So I need to wrap reactive banana in ncurses Monad
20:26:39 <mac10688> it's going ok until reactimate needs an `Even(IO()) -> MomentIO
20:26:43 <freeman42x> finished creating the easy Haskell editor / IDE setup steps specific for Windows: https://github.com/razvan-flavius-panda/haskell-editor-setup/blob/master/README.md#Windows
20:26:56 <mac10688> I'll post broken code to show what i'm trying
20:26:56 <EvanR> hmm. ncurses and reactive banana might both have a "everything in my monad loop" architecture
20:27:35 <mac10688> yeah that's what i'm thinking too
20:27:39 <EvanR> if they are incompatible you can always run ncurses in one thread and reactive banana in another
20:28:11 <mac10688> https://pastebin.com/kejZsPJt
20:28:45 <mac10688> I think that code will compile but it runs the printScreen and runs `runCurses` and exits and clears the screen and it looks like nothing ever happened
20:29:25 <mac10688> and yeah it will compile
20:29:49 <mac10688> i'm about to toss reactive banana away
20:30:29 <mac10688> oh sorry it looks like i missed your message about running in seperate threads
20:42:13 * hackage ms-tds 0.3.0.1 - TDS Protocol implemented in Haskell  https://hackage.haskell.org/package/ms-tds-0.3.0.1 (tkmsm)
20:45:37 <MarcelineVQ> freeman42x: "Type Windows key" do you mean Windows key + r, or has that changed in newer windows?
20:45:40 <dmwit> koz_: I commented on your gist. I think you'll like the comment a lot.
20:46:32 <koz_> dmwit: That's really cool, thanks!
20:47:53 <dmwit> Just 9 lines if you're okay returning a Venn instead of a Maybe SetRelation.
20:48:15 <dmwit> And can be even less if you're willing to use (Any, Any, Any) instead of Venn. ;-)
20:48:48 <koz_> I think Venn is actually a good idea. I'll go with that.
20:51:16 <dmwit> Oh. You can even have another field, neither, which you fill in toVenn with `not l && not r`.
20:51:20 <dmwit> That makes things very symmetric.
20:51:43 <koz_> So that makes the fields l, r, both, neither?
20:51:54 <dmwit> right
20:52:01 <dmwit> Whether you want that field or not I guess depends on your goals.
20:52:07 <freeman42x> MarcelineVQ, I think that typing something after opening the Windows menu will also work for anything you would type in the Win + R pop-up
20:52:23 <MarcelineVQ> freeman42x: alright then
20:53:10 <freeman42x> MarcelineVQ, and since it is the same thing obviously you would rather press 1 key less :)
20:53:12 <MarcelineVQ> I wonder if that works the same if you're not on an admit account
20:53:18 <MarcelineVQ> *admin
20:53:28 <freeman42x> MarcelineVQ, what do you mean?
20:53:32 <dmwit> koz_: I guess this is just another way of spelling my set union idea from earlier. Hah!
20:53:43 <dmwit> Silly dmwit.
20:55:06 <MarcelineVQ> When I used windows somie things related to system settings required the user doing it to have a certain level of privelleges, or for the setting application to be opened with admin permissions sometimes via an option on a right click menu
20:55:34 <MarcelineVQ> So like in windows7 if you type win+r and it doesn't say "the thing you run will run with admin privelleges" then the settings might not take
20:57:20 <MarcelineVQ> idk much about that stuff now, I just wonder if the instructions change at all if your user hasn't been set up with admin level power or whatever that was called
20:58:24 <freeman42x> anyone good with github flavored markdown? I run into this issue: https://github.com/razvan-flavius-panda/haskell-editor-setup/issues/26
20:58:56 <freeman42x> MarcelineVQ, the setup instructions are for a user with user privileges
20:59:13 * hackage ms-tds 0.4.0.0 - TDS Protocol implemented in Haskell  https://hackage.haskell.org/package/ms-tds-0.4.0.0 (tkmsm)
21:01:36 <MarcelineVQ> users are allowed to change how paths are interpreted? hmm
21:11:46 <MarcelineVQ> freeman42x: note the link symbol to the left of "Leksah (setup difficulty hard)" https://github.com/razvan-flavius-panda/haskell-editor-setup/tree/9426d09ec59fe74aabbde666a3d058954963e9c0 it shows you what you type to reach that link, it doesn't actually contain ( )
21:14:32 <MarcelineVQ> To be clearer, I would guess the correct way to write that link to be [using Leksah](#leksah-setup-difficulty-hard)
21:19:05 <freeman42x> MarcelineVQ, cheers, will have a look later, gotta go now
21:53:49 <slack1256> Has anyone made xterm icon show up on taffybar?
21:54:32 <iqubic> How is that haskell related?
22:01:19 <slack1256> I just want to see if it's a local issue of mine or other people can reproduce. I'll try to make a patch to it.
22:18:51 <MarcelineVQ> iqubic: https://hackage.haskell.org/package/taffybar
22:23:09 <iqubic> I see.
22:23:12 <iqubic> Makes sense.
22:23:29 <iqubic> Who here uses Emacs to edit Haskell code?
22:23:48 <no-n> I use vim :(
22:23:53 <iqubic> What emacs packages do you guys use to edit Haskell code?
22:31:03 <slack1256> Whatever ships with spacemacs
22:31:36 <no-n> is there anything wrong with lyah
22:31:50 <no-n> should i read haskellbook instead
22:32:29 <slack1256> no-n: lyah is old but it has "soul". Until it introduces Monad is a good tutorial.
22:32:51 <no-n> it has a bad explanation of monad?
22:33:46 <iqubic> slack1256: Do you like the way that spacemacs haskell editing work?
22:35:54 <slack1256> It's OK. I don't like having ghci on a emacs panel, I use ghci on a terminal via nix-shell. But at least for editing the combo of projectile + magit + vim keybinding is good for any prog lang.
22:36:59 <slack1256> Also helm-jump-in-buffer works out of the box.
22:40:35 <iqubic> Nice.
22:43:42 <slack1256> no-n: Not a bad explanation per se, but doesn't make it justice on a combinatorial level nor type-classy level. I remember skipping those chapters when I read it because I didn't understand how it did fit in the whole picture.
22:44:11 <no-n> ok
22:44:14 <slack1256> I was happy writing little functions to solve project euler problems, so `interact` was good engough for me.
22:54:15 <iqubic> Should I use ghc-mod?
22:55:16 <MarcelineVQ> not if you have hie working
22:55:34 <iqubic> I don't have that working.
22:55:55 <iqubic> What is the HIE?
22:56:36 <MarcelineVQ> https://github.com/haskell/haskell-ide-engine#haskell-ide-engine-hie
22:57:14 <iqubic> What is hie good for?
22:57:28 <MarcelineVQ> the same things ghc-mod is
22:57:59 <iqubic> Which is?
22:59:08 <MarcelineVQ> most typically it's nice for immeditaly getting the types of things you've highlighted or your cursor is over
22:59:14 <iqubic> I see.
22:59:25 <iqubic> Does it do repl stuff?
22:59:27 <MarcelineVQ> as opposed to ghcid where you'd insert a hole or a spurious type anotation to check the type of something
22:59:40 <iqubic> Also, how do I use it with Emacs?
22:59:45 <MarcelineVQ> idk
22:59:49 <MarcelineVQ> which it
23:00:08 <iqubic> How do I use hie with emacs.
23:00:28 <MarcelineVQ> have a gander at the earlier link
23:00:39 <iqubic> I will.
23:00:59 <iqubic> MarcelineVQ: What do you use for writing Haskell code?
23:01:46 <MarcelineVQ> atom and ghcid, I'd like to try vscode at some point though and then see what adding hie to that is like
23:02:09 <iqubic> Why do you use ghcid?
23:02:14 <MarcelineVQ> actually I use atom ghcid and ghci at once
23:02:51 <iqubic> I see.
23:03:12 <MarcelineVQ> ghcid is essentially ghci that automatically reloads and typechecks things when you save something so I use it for typechecking as I work
23:03:19 <slack1256> The use of ghcid + type-holes is clever.
23:03:19 <iqubic> do you recommend ghcid? Do you recommend hie?
23:03:43 <MarcelineVQ> I strongly reccomend ghcid, I don't have enough experience with modern hie to reccomend it or not
23:04:23 <iqubic> What benefits does ghcid give you?
23:04:27 <MarcelineVQ> see above
23:04:59 <MarcelineVQ> automatic type checking of a project when I hit save
23:05:28 <iqubic> I see.
23:05:39 <iqubic> Is that all that you use it for?
23:05:55 <MarcelineVQ> yes that's what it's for :>
23:06:09 <iqubic> Is that all it can be used for?
23:06:46 <MarcelineVQ> An inventive person might be able to do more with it but that's the common use
23:07:54 <iqubic> How does ghcid deal with external libraries installed via cabal/stack
23:08:06 <slack1256> reloading
23:08:18 <slack1256> it's ghci basically
23:08:48 <iqubic> but doesn't it have to be run from the right directory?
23:10:08 <slack1256> You can run on the base directory of the project. At least cabal v2-install will write a .ghc-environment hidden file which ghci will pick up for the search path of the installed libs.
23:10:46 <iqubic> I see.
23:12:10 <iqubic> does ghcid work with nix-shells?
23:14:51 <slack1256> I write a shell.nix file with the dependencies (generated from cabal2nix) and the launch ghcid. It's not common to change dependencies on a project after all.
23:15:23 <iqubic> How do you launch ghcid?
23:16:33 <slack1256> Just write ghcid on the terminal.
23:17:41 <iqubic> But don't you have to run ghcid from inside the the nix-shell, so that ghcid finds all the libraries you have installed?
23:17:44 <MarcelineVQ> yes, though if you use stack it's easiest to write stack build ghcid && stack exec ghcid from in your project
23:17:49 <MarcelineVQ> for nix I've no idea
23:18:45 <slack1256> iqubic: Yes, it's a two steps thing.
23:19:14 <slack1256> First get nix-shell to get the correct environment and then ghcid
23:19:33 <iqubic> I see.
23:19:36 <slack1256> You could also do it on a single step `nix-shell --command 'ghcid'`
23:19:44 <iqubic> I see.
23:19:52 <iqubic> That makes a whole lot of sense.
