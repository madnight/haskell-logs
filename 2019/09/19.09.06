00:01:00 * hackage elm-street 0.1.0.0 - Crossing the road between Haskell and Elm  https://hackage.haskell.org/package/elm-street-0.1.0.0 (shersh)
00:41:51 <maerwald> is there a way to make a lawful monad instance for a sum type that has multiple success constructors without dependent types?
00:47:42 <phadej> maerwald: you just have to pick a constructor to be `return`
00:48:46 <phadej> and it might be lawful, it depends what behaviour you want with "multiple success constructors"
00:54:00 <maerwald> phadej: https://gist.github.com/hasufell/1b195fd911e9519c385cc2b5bad9a9a6
00:54:25 <maerwald> afais I'll be at least break one of the applicative laws
01:17:30 * hackage kuifje 0.1.0.0 - A Quantitative Information Flow aware programming language.  https://hackage.haskell.org/package/kuifje-0.1.0.0 (martonbognar)
01:21:30 * hackage type-equality 1 - Data.Type.Equality compat package  https://hackage.haskell.org/package/type-equality-1 (phadej)
01:22:14 <sshine> breaking the law, br-br-breaking the law
01:24:49 <no-n> you don't know what it's liiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiike
01:27:49 <absence> i want to fold a vector, but treat the first item differently. with a list, i'd just pattern match the first item and fold the tail, but that's rather cumbersome with vectors. is there a clever way around it, or should i just use toList?
01:33:39 <merijn> absence: Pretty sure vector has uncons
01:33:39 <merijn> hmm, maybe not :O
01:33:40 <sshine> absence, f (v ! 1) (tail v)?
01:33:44 <sshine> absence, you want something non-partial, right?
01:34:29 <merijn> absence: Time to make a PR to vector for "uncons :: Vector a -> Maybe (a , Vector a)" and "unsnoc :: Vector a -> Maybe (a, Vector a)" :p
01:34:32 <suppi> could use drop 1 instead of tail
01:34:48 <merijn> suppi: That's not gonna make any performance difference, tbh
01:35:28 <sshine> or 'splitAt 1'
01:35:29 <absence> drop isn't partial i think
01:35:34 <suppi> merijn tail may fail, drop will not
01:36:05 <merijn> the ! or head is gonna be partial anyway
01:36:12 <suppi> so use !? instead
01:36:23 <sshine> splitAt n = take n &&& drop n
01:36:36 <suppi> splitAt is probably the best yeah
01:36:37 <merijn> sshine: Then you get a Vector, rather than a first element
01:36:50 <suppi> oh yeah, that's true
01:36:53 <sshine> merijn, you do, but he doesn't want partial functions, and he doesn't know if it's empty or not.
01:36:54 <merijn> No, the best would be to, as I suggested, add uncons/unsnoc :)
01:37:15 <sshine> sorry. I don't know if he doesn't want partial functions. I'm speaking for myself here. I assume (!) and tail are insufficient. :)
01:37:28 <sshine> right
01:37:29 <suppi> merijn, that's true and the first thing i went to look for in the api, but it's not currently present
01:37:37 <sshine> Data.Text has them IIRC.
01:38:07 <sshine> maybe it's because uncons is O(1)?
01:38:18 <sshine> O(n) I mean
01:38:26 <merijn> sshine: Both uncons and unsnoc are either O(1) *or* O(n)
01:38:47 <merijn> sshine: Vector supports slicing so you can make an O(1) limited view/slice of an existing vector
01:38:53 <sshine> oh!
01:38:57 <sshine> nice, thanks.
01:39:09 <suppi> uncons vec = fmap (, drop 1 vec) (vec !? 0)
01:39:19 <merijn> sshine: See the 'slice' function (and the related 'force' function for breaking sharing)
01:39:26 <suppi> uncons vec = fmap (\hd -> (hd, drop 1 vec)) (vec !? 0)
01:39:33 <sshine> merijn, makes sense!
01:39:41 <suppi> i keep forgetting TupleSections is not haskell 98
01:39:50 <merijn> sshine: Since you probably don't want your 4 element sub-vector to prevent a 2 GB vector from being GCed ;)
01:41:25 <absence> when folding a vector, is there a performance disadvantage to just toList it?
01:42:23 <suppi> absence, I don't know, but toList api says it's an O(N) operation
01:42:23 <merijn> absence: If things get fused away? No. If they don't, probably but whether it matters depends on the size of your vector, etc.
01:42:39 <merijn> suppi: The problem with laziness is that things are never that simple
01:43:03 <merijn> suppi: In a strict language toList would be O(n), just like "map" would be
01:43:29 <merijn> In Haskell the complexity of map depends on the context it's consumed in
01:43:30 <suppi> I know how it works
01:43:46 <sshine> I know that it works
01:43:46 <suppi> If performance matter, I'd be conservative and not use toList
01:44:06 <merijn> The combination of fold and toList will just merge into a single O(n) traversal in most uses of Foldable
01:44:09 <suppi> If it doesn't and it makes the code simpler, use toList by all means
01:45:28 <absence> merijn: if i pattern match on the resulting list and fold the tail, would that still fuse?
01:46:18 <merijn> absence: I don't think anyone knows without looking at the Core :p
01:46:44 <merijn> absence: Are you sure you aren't microoptimising here? Just write it with toList. You can always replace the fold with a more efficient fold later if it's too slow
01:47:41 <suppi> absence, I'd recommend defining uncons and use it
01:47:55 <suppi> which I think is basically this line? uncons vec = fmap (\hd -> (hd, drop 1 vec)) (vec !? 0)
01:53:04 <suppi> I suggest that because the code will look almost identical in structure whether you pattern match on toList or on the result of uncons, so might as well go with the one that's supposed to be faster
01:53:04 <suppi> does that make sense?
01:53:04 <merijn> absence: I mean, this is the beauty of no side-effects if you write "myVectorFold :: Vector a -> Foo" using toList now, you can always safely rewrite it to something smarter later, since there's no side-effects!
01:54:32 <maralorn> Do most of you use custom preludes? I wounder how you manage it via different projects. Do you copy them in? Do you symlink them?
01:55:27 <jgt> maralorn: I use ClassyPrelude which comes scaffolded with Yesod apps
01:55:43 <Taneb> I don't like using custom preludes
01:55:56 <Taneb> (although I did once write one, as @quote might tell you)
01:56:09 <Ariakenom> @quote taneb prelude
01:56:09 <lambdabot> No quotes for this person. My pet ferret can type better than you!
01:56:26 <Taneb> @quote Taneb Prelude
01:56:26 <lambdabot> Taneb says: I'm doing the thing that every bored haskeller does one day and rewriting Prelude
01:56:44 <Taneb> (sadly it's case sensitive)
01:57:27 <suppi> I don't use a custom prelude but do define a Utils module with common functions I use and add things there when I need to 
01:57:28 <Ariakenom> how did it turn out?
01:57:59 <Taneb> Ariakenom: it was a fun exercise
01:58:06 <Taneb> Didn't actually use it for anything, though
01:58:07 <maralorn> suppi: And you do a know Utils for every project?
01:58:30 <suppi> no, but every so often, also depends on how big the project is
01:58:43 <maralorn> ofc
01:58:43 <suppi> and they usually turn out fairly different from one another
01:58:49 <merijn> maralorn: I rarely find myself needing the exact same stuff across projects, and if I do I try and find a place in a library to get it in ;)
01:59:20 <maralorn> merijn: Thatâ€˜s a good answer.^^
01:59:27 <merijn> maralorn: I don't really use custom preludes because I feel they break more in compatibility then they get you. Although for bigger projects I do often end up writing a sort of "Prelude specific answer"
01:59:53 <merijn> Speaking of finding a place for custom functions...help me campaign to get "Monoid m => Bool -> m -> m" into base! ;)
01:59:59 <suppi> oh, was the question if i create a new Utils for every project? if so the answer is yes for those that I need one.
02:00:13 <merijn> That's the one function I keep reimplementing across projects, because it's amazing
02:00:44 <suppi> what is the name you gave that function?
02:01:04 <merijn> suppi: Right now I'm using "mIf" but I'm not happy with that, so I'm open to better names...
02:01:12 <merijn> Others have suggested mwhen
02:01:25 <suppi> hmm
02:01:49 <merijn> Maybe "mguard"?
02:02:28 <suppi> i can't think of a good name
02:03:29 <maralorn> merijn: What do you need it for?
02:04:54 <merijn> maralorn: Tons of stuff, it's super useful once you see the light and realise like 90% of your problems can be simplified by throwing more Monoid at it ;)
02:06:22 <merijn> maralorn: I use it for: Conditionally prepending things to SQL queries: https://github.com/merijn/GPU-benchmarks/blob/c03154370dfde85923b69c127a7750a54a9f1004/benchmark-analysis/src/Query.hs#L72-L76 simplifying pretty printing logic for inserting linebreak https://github.com/merijn/GPU-benchmarks/blob/28f863e585e6c18e92b8f988349f3b123a340abb/benchmark-analysis/src/OptionParsers.hs#L52 conditional output 
02:06:28 <merijn> https://github.com/merijn/GPU-benchmarks/blob/d79ee962a0206fd41895dcdcd14c8047d9203d59/benchmark-analysis/model-src/Evaluate.hs#L395-L399
02:07:46 <merijn> maralorn: In Cabal I used special cases of that for version gating certain filters: https://github.com/haskell/cabal/blob/master/Cabal/Distribution/Simple/Program/GHC.hs#L61-L69
02:09:04 <merijn> maralorn: In general it allows you to special case output/functions/collection/etc. without having to split your output logic into two or more separate versions for each combination of options
02:09:46 <maralorn> merijn: Yeah, looks cool.
02:09:57 <merijn> maralorn: For example, I *really* like how the "from" and "to" usage worked out with the option filtering in Cabal. Things are neatly in one place and it's immediately obvious what's filtered out when
02:10:00 * hackage hie-bios 0.1.0 - Set up a GHC API session  https://hackage.haskell.org/package/hie-bios-0.1.0 (mpickering)
02:10:42 <merijn> maralorn: It's one of those tiny patterns I just keep finding small uses for everywhere :)
02:18:41 <absence> merijn: in this case it's not so much about performance as getting a general gut feeling, but i guess there's no way to be sure without looking at the core in those cases where performance does matter
02:38:30 * hackage geoip2 0.4.0.0 - Pure haskell interface to MaxMind GeoIP database  https://hackage.haskell.org/package/geoip2-0.4.0.0 (ondrap)
02:51:01 <asheshambasta> is there a way to make brittany ignore arrow syntax instead of adding `--brittany-disable-next-binding` on blocks that use arrows? 
02:51:15 <asheshambasta> this gets really messy and error prone for large modules. 
02:52:13 <asheshambasta> especially because the error messages from Brittany have no indication of where the error happend; so you end up having to scan through the entire module looking for a missed disable comment. 
02:52:47 <asheshambasta> also; the behaviour is quite inconsistent; for reasons I don't understand, Brittany doesn't error out if the offending block is in a typeclass instance implementation. 
02:53:19 <merijn> asheshambasta: To ignore it, it would probably have to understand arrow syntax and I'm not sure it does?
02:53:33 <merijn> And if it understood arrow syntax you probably wouldn't have to ignore it :p
02:53:44 <jusss> what is lift?
02:53:46 <jusss> :t lift
02:53:48 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
02:53:51 <dminuoso> I wish there there was a working convention of where monad transformers are located.. :<
02:54:13 <merijn> dminuoso: What do you mean?
02:54:30 <dminuoso> merijn: Oh things like LoggingT are not in Control.Monad.Trans.Logging
02:54:47 <dminuoso> (Or Control.Monad.Trans.Logger rather)
02:54:52 <asheshambasta> merijn: maybe brittany should have an option to ignore 'blocks' that, when formatted as per brittany's implementation, lead to syntactially invalid code? 
02:54:52 <merijn> jusss: It lifts a value in Monad 'm' into a transformer over 'm'
02:55:03 <asheshambasta> merijn: right now, it just quits leavning the entire module in the previous state, 
02:55:19 <merijn> asheshambasta: Maybe, but someone would have to write that :)
02:55:39 <jusss> merijn: what monad transformers are used to?
02:55:41 <dminuoso> Though it seems most seem to place them into Control.Monad.Trans - but Ive had at least 2 monad transformers that didnt follow that pattern.
02:55:45 <asheshambasta> merijn: yeah, I use brittany for my daily driver, so I wouldn't mind diving into that. 
02:55:57 <dminuoso> jusss: They are our way of composing monads together (because monads themselves generally dont compose)
02:56:16 <jusss> dminuoso: what its meaning?
02:56:28 <asheshambasta> I'm asking to see if this my be feasible and my assumptions corrct. 
02:56:28 <merijn> jusss: Monad transformers are used to wrap another monadic effect around an existing monad
02:56:28 <asheshambasta> correct*
02:56:29 <merijn> asheshambasta: Probably better of asking that in an issue on the brittany repo
02:56:30 <jusss> I don't know where I should use it
02:56:32 <dminuoso> jusss: Let's pretend for a second IO had no exceptions.
02:57:08 <dminuoso> jusss: The Monad interface of Maybe models exceptions. And IO models side-effects (interacting with the outside world, database calls, http, etc)
02:57:43 <dminuoso> jusss: So you might want to have code that has exceptions *and* side-effects at the same time. So you sort of would want to combine the effects of Maybe with the effects of IO, such that you have a combination of both.
02:57:45 <jusss> dminuoso: so MaybeT IO a, is MaybeT is Nothing so we can avoid to handle IO?
02:57:56 <dminuoso> jusss: Not quite.
02:58:58 <dminuoso> jusss: It's rather that conceptually every combutation is some `IO (Maybe a)` - and if any IO computation produces a `Nothing`, then no further IO actions will be considered - shortcircuiting like an exception.
02:59:02 <dminuoso> *computation
02:59:54 <jusss> dminuoso: and MaybeT IO a?
03:00:05 <dminuoso> jusss: MaybeT IO a is, internally, IO (Maybe a)
03:00:25 <dminuoso> jusss: So MaybeT is a way to add the "exception" effect to an arbitrary monad.
03:00:44 <dminuoso> (By exception I mean the capability to shortcircuit)
03:00:54 <jusss> dminuoso: wait a sec, IO (Maybe a) is valid?
03:01:01 <dminuoso> jusss: Absolutely. Why wouldnt it? :)
03:01:04 <merijn> jusss: Why wouldn't it be?
03:01:19 <jusss> dminuoso: merijn then why we need MaybeT IO a?
03:01:29 <dminuoso> jusss: You dont, strictly speaking.
03:01:36 <dminuoso> jusss: Except here's the bit:
03:01:38 <merijn> define "need"
03:02:01 <jusss> merijn: dminuoso if one is enough, why we create two stuff to do the same?
03:02:10 <merijn> It doesn't do the same, though
03:02:40 <dminuoso> jusss: `MaybeT IO a` lets you sort of "pretend" that there's no Maybe. Every time you do `do { f <- action; use f}` then `f` is not of type `Maybe Something`, but just `Something`
03:02:56 <dminuoso> jusss: So the monad instance automatically does the "check if the result is nothing, and if it is, dont proceed. if it is, proceed"
03:03:11 <jusss> dminuoso: and IO (Maybe a)?
03:03:35 <dminuoso> jusss: That doesnt. You get something of value `Maybe a` handed to you, every time.
03:03:42 <jusss> detect Maybe a is Nothing, so no IO actions?
03:03:45 <jusss> future
03:04:48 <dminuoso> jusss: Oh I phrased that wrong: I wanted to say "check if the result is nothing. If it is, dont proceed, and if its `Just x`, then hand `x` as the result 
03:05:03 <dminuoso> jusss: In case of `IO (Maybe a)` its no different from say `IO Int`
03:06:09 <dminuoso> jusss: The reason is that the behavior does not depend on the "whole" in `IO _`. The behavior is the same for all `IO Int`, `IO Bool`, `IO Char`, `IO (Maybe Bool)` etc..
03:06:45 <dminuoso> jusss: So the question is not about "IO (Maybe a)" vs something, but rather "IO" vs "MaybeT IO"
03:07:02 <dminuoso> jusss: `MaybeT IO` gives you a sort of IO version back with exceptions.
03:07:29 <dminuoso> Its done in such a way that you get a primitive to "throw an exception" and you get a way to "catch an exception"
03:10:30 * hackage elm-street 0.1.0.1 - Crossing the road between Haskell and Elm  https://hackage.haskell.org/package/elm-street-0.1.0.1 (shersh)
03:21:27 <nil> i was just thinking: maybe GHC could provide an IOT transformer that would look like:  newtype IOT m a = IOT { runIOT :: State# RealWorld -> m (# State# RealWorld, a #) }
03:22:18 <tdammers> nil: that would kind of allow you introduce effects pretty much anywhere though, wouldn't it?
03:22:29 <dminuoso> nil: `IOT []`
03:22:35 <nil> (i have no idea whether this is doable in practice, it just occured to me)
03:22:37 <dminuoso> nil: This would make for a hilarious and buggy transformer. :-)
03:22:46 <nil> hmmm yeah
03:23:07 <nil> i'm sure people would find sensible applications :D
03:24:12 <dminuoso> nil: The problem is that the `State# RealWorld` internals is not to be understood to modelling a "real world state transformer"
03:24:20 <tdammers> well, you would either have to introduce some sort of runIOT :: IOT m -> m a, but that would amount to unsafePerformIO; or it would have to somehow connect to IO, e.g. runIOT :: IOT m a -> IO (m a), but then that wouldn't really be very useful either, because then essentially what you get is that you have to manually turn your m into a monad transformer and manually flip your monad stack upside down
03:24:24 <dminuoso> nil: It's only a very very sketchy analogy that breaks the moment you think about forkIO
03:24:31 <tdammers> also this, yes
03:25:05 <tdammers> RealWorld is not really the state of the real world, but rather kind of like a type-level proof of being allowed to be a stateful computation, if that makes any sense
03:25:56 <nil> yeah, i've read about that
03:26:02 <dminuoso> The way I understand it, the reason is because internally GHC ties side effects into evaluation of thunks. But it creates a barrier to not evaluate the internals of `IO Int` because you need a magic secret non-existing (!) token that you can't (simply) create out of thin air.
03:26:06 <nil> it just allows sequencing computations
03:26:09 <dminuoso> Right.
03:31:16 <nil> anyway, i've been thinking about monad transformers lately, and i think i got it boiled down to: in order to stay monadic, you have to keep "distributive" functors on the left of the composition chain, and "traversable"/"codistributive(?)" functors on the right of the composition chain
03:32:53 <nil> e.g. State S (Reader S :.: Writer S) isn't a monad because you can't "swap" the middle Writer and Reader layers in Reader S :.: Writer S :.: Reader S :.: Writer S
03:33:50 <nil> i phrased that wrong
03:36:49 <nil> i meant the "naive" State functor defined by  newtype State s a = State (Reader s (Writer s a))
03:37:17 <nil> or  newtype State s a = State (s -> (a, s))
03:39:13 <nil> the "State" from the transformers library, defined as  type State s = StateT s Identity  , is a monad because then you have  State s :.: State s ~~~ Reader s :.: Reader s :.: Writer s :.: Writer s  and you can join each layer separately
03:42:04 <nil> i mean "distributive" as in: a functor f is distributive if there is a function  distribute :: Functor g => f (g a) -> g (f a)  , as defined in the Distributive class
03:42:21 <ski> nil : even to the extent that `IO' can be thought of as a "real world state transformer", the problem is that the state is supposed to be unique (as in uniqueness types in Clean, or uniqueness insts in Mercury)
03:42:30 <nil> and "codistributive" as the dual of that, which seems to be the Traversable class
03:42:50 <nil> ski: yeah, i see that now
03:43:21 <ski> nil : and `IOT []' violates that, because `[]' doesn't use its type argument only once. you'd need, i think, linear kinds, in order to be able to express the desired distinction
03:44:02 <nil> ok
03:45:06 <ski> (`Either a a' (additive disjunction, in linear logic terminology) will be considered to only use `a' once, while `(a,a)' will be considered to use `a' twice. at least if we're modelling the multiplicative conjunction type, rather than the additive conjunction, which is a potential "pick one alternative" thing)
03:45:29 <nil> does my rant on transformers make any beginning of sense? it's really just an intuition for now
03:45:48 * ski didn't get that far, yet .. will look now
03:46:07 <nil> i should also add that  Reader s  isn't distributive itself, but "flip Reader a" is
03:46:32 <nil> (newtype FlipReader a = Reader s a)
03:46:48 <nil> er
03:46:57 <nil> (type FlipReader a s = Reader s a)
03:47:30 <nil> (in the same way, FlipWriter is traversable/codistributive)
03:47:43 <ski> `State S (Reader S :.: Writer S)' looks like a kind error, to me
03:48:08 <nil> yeah, the parentheses aren't meant to be part of the code
03:48:14 <ski> oh
03:48:22 <nil> "State S (which we might define as Reader S :.: Writer S)
03:48:24 <nil> "
03:48:59 <freeman42x> for parsing command line arguments which is best: optparse-applicative or options?
03:49:35 <ski> how did you go from `State s :.: State s' to `Reader s :.: Reader s :.: Writer s :.: Writer s' ?
03:50:03 <nil> let me see
03:51:23 <ski> `FlipReader a' is contravariant, so how can it be distributive ?
03:51:59 <nil> ughhh you're right, i confused myself there
03:52:06 <Taneb> Hmm, are there any Applicatives with two (or more) distinct compatible Monad instances?
03:52:25 <nil> i think my earlier reasoning was that FlipReader was contravariant, which i then refined to "Reader is distributive"
03:52:36 <nil> forget about FlipReader *facepalm*
03:53:03 <ski> ok
03:53:08 <nil> State s :.: State s  is also not what i meant, i think
03:53:20 <nil> i was thinking of  StateT s (State s)
03:55:01 <nil> (or  StateT s (StateT s Identity)  )
03:57:53 <Athas> I just realised that regex-base has been unmaintained for 9 years and is apparently the foundation for the regex libraries.  Oh, and it doesn't build on GHC 8.8.
03:57:59 <Athas> This one will take a while to unravel, I fear.
03:58:22 <merijn> Athas: Maybe it will finally get people to reconsider using regexes :p
04:00:49 <nil> ski: ok so,  StateT s m a ~ s -> m (a, s) ~~~ Reader s (m (Writer s a))
04:01:38 <merijn> Incidentally, package maintenance tip: Did you know there's an RSS feed that notifies you when your dependencies have new releases so you need to check your upperbounds? :D
04:01:49 <nil> and  State s a ~ StateT s Identity a
04:02:24 <boxscape> Is there a haskell equivalent to the word "pythonic
04:02:24 <boxscape> "?
04:02:36 <merijn> boxscape: Not really
04:02:44 <boxscape> oka
04:02:46 <boxscape> y
04:02:47 <sicklorkin> Athas: are you able to swtich to something like `formatting`?
04:02:53 <merijn> boxscape: At least not that's commonly used as adjective for "good"
04:03:23 <merijn> sicklorkin: formatting doesn't look like an alternative for regexes?
04:03:51 <merijn> sicklorkin: Like, not even remotely close?
04:04:03 <boxscape> "Idiomatic haskell" is the most apt phrase that comes to my own mind (though not a word, of course)
04:04:04 <sicklorkin> merijn: why was i thinking printf when I read regex
04:04:34 <sicklorkin> merijn: indeed 
04:04:38 <merijn> boxscape: That also assumes there's some agreement on what constitutes idiomatic :)
04:04:40 <nil> so  StateT s (State s) a ~ StateT s (StateT s Identity) a ~~~ Reader s (StateT s Identity (Writer s a)) ~~~ Reader s (Reader s (Writer s (Writer s a)))
04:04:52 <boxscape> that's true, but I think there is *some* agreement
04:05:06 <nil> hence  StateT s :.: State s ~~~ Reader s :.: Reader s :.: Writer s :.: Writer s
04:05:15 <merijn> boxscape: Well, I think there is mostly agreement on what is *not* idiomatic :p
04:05:26 <boxscape> that's fair
04:06:30 * hackage replace-megaparsec 1.1.1.0 - Stream editing with parsers  https://hackage.haskell.org/package/replace-megaparsec-1.1.1.0 (JamesBrock)
04:06:47 <Taneb> nil: I don't agree with State s ~ Reader s (Writer s)
04:07:05 <Taneb> They have very different behaviour
04:07:28 <nil> no, it's  State s a ~ Reader s (Writer s a)
04:07:57 <nil> Taneb: what do you mean by different behaviours?
04:08:53 <nil> State s a ~ s -> (s, a) ~ Reader s (s, a) ~ Reader (Writer s a)
04:08:57 <nil> er
04:08:59 <nil> State s a ~ s -> (s, a) ~ Reader s (s, a) ~ Reader s (Writer s a)
04:09:07 <Taneb> nil: the monad and applicative instances are completely different
04:09:26 <Taneb> With Reader s (Writer s a), you don't get chained updates. You get one input and then a log
04:09:26 <nil> Taneb: sure, i'm only talking about similarities of the types themselves
04:09:44 <Taneb> In that case, I'll uncomfortably accept
04:09:46 <nil> i'm not concerned about how they are used, at this level
04:10:12 <nil> but yes, you're right. they indeed have different "meanings" in the practical world
04:10:52 <absence> > fmap fst . drop 1 $ scanl (\(_, scale) a -> (a*scale, scale+1)) (undefined, 1) [1,2,3]
04:10:54 <lambdabot>  [1,4,9]
04:10:58 <Athas> sicklorkin: I am not depending on regex-base myself, it's a transitive dependency.
04:10:59 <absence> is there a way to avoid undefined in cases like this?
04:11:05 <Ferdirand> the implementation of >>= would be completely different
04:11:19 <Ferdirand> that's not only about meaning
04:11:49 <ski> nil : `StateT s :.: State s' is ill-kinded. `StateT s (State s)' or `StateT s (StateT s Identity)' or `(StateT s :.: StateT s) Identity' works, though
04:12:01 <Athas> Actually, I'm stunned that regex-base worked so far.  No releases since 2010!
04:12:02 <nil> ski: ok
04:12:07 <sicklorkin> Athas: indeed!
04:12:18 <merijn> Athas: What are you using that depends on it?
04:12:28 <ski> nil : or, you could said `(StateT s :.: StateT s) m' is equivalent to `Reader s :.: Reader s :.: m :.: Writer s :.: Writer s'
04:13:00 <Athas> merijn: probably regex-tdfa.
04:13:09 <merijn> Athas: Also, no upperbounds on Futhark à² _à² 
04:13:33 <ski> nil : or, that `StateT s :.: StateT s' is equivalent to `(Reader s :.:) :.: (Reader s :.:) :.: (:.: Writer s) :.: (:.: Writer s)', or somesuch
04:13:33 * hackage kuifje 0.1.1.0 - A Quantitative Information Flow aware programming language.  https://hackage.haskell.org/package/kuifje-0.1.1.0 (martonbognar)
04:13:42 <Athas> merijn: yeah, I think upper bounds are a design mistake.
04:13:57 <Athas> I prefer freezing myself.
04:14:28 <merijn> Athas: For executables sure, but that's super annoying for people depending on it
04:15:33 <Athas> merijn: I think that issue is still up for debate (but also so debated that it's probably not worth rehashing it).
04:15:37 <nil> ski: i see
04:15:37 <Athas> It will concede that I might add upper bounds if Futhark was not primarily an executable.
04:16:56 <merijn> Athas: The main problem I had in the past with maintaining upperbounds was tracking when to relax them, but now that I've found a trivial to do that I'm happy
04:25:41 <dminuoso> Taneb: NonEmpty
04:26:20 <Taneb> dminuoso: what are the monad instances?
04:26:35 <dminuoso> Taneb: https://mail.haskell.org/pipermail/haskell-cafe/2017-February/126199.html
04:26:42 <dminuoso> And the canonical one
04:28:07 <Taneb> dminuoso: that#s a different Applicative instance, isn't it?
04:29:12 <dminuoso> Taneb: Are you talking about two different monad instances sharing (via coherence) the same applicative instance?
04:29:27 <dminuoso> And yes.
04:31:41 <Taneb> I'm talking about two types with isomorphic applicative instances but non-isomorphic monad instances
04:31:59 <dminuoso> I see
04:32:02 <Taneb> Like [] and ZipList have isomorphic functor instances but non-isomorphic monad instances
04:32:08 <Taneb> s/monad/applicative/
04:32:34 <dminuoso> Could in theory such a construction exist? 
04:32:46 <dminuoso> I mean ap = <*> imposes a fairly strong connection already
04:33:16 <Taneb> That's what I'm wondering
05:17:04 <willsewell> I just updated to the latest version of stack. I'm not sure what I was using previously. It now appears that my extra-dep on time-1.9.2 is causing errors like
05:17:15 <willsewell> In the dependencies for base-compat-0.10.5:
05:17:15 <willsewell>     unix needed, but the stack configuration has no specified version  (latest matching version is 2.7.2.2)
05:17:16 <willsewell> needed due to my-package-1.5.1.9 -> base-compat-0.10.5
05:17:43 <willsewell> Which is weird because base-compat is in the snapshot I am using `nightly-2019-05-21`
05:17:52 <willsewell> And I don't depend on it directly
05:18:59 <willsewell> And it's only aeson that depends on it
05:19:16 <willsewell> If I remove the extra-dep of time-1.9.2 then these errors go away
05:19:28 <willsewell> Was there same kind of breaking change in stack that I could be pointed to?
05:19:37 <willsewell> Thank you
05:20:52 <boxscape> why does ghci say "undefined :: a" when the type is really `forall (r :: RuntimeRep). forall (a :: TYPE r). HasCallStack => a `? Is it specially handled?
05:21:49 <boxscape> Or maybe Constraint solving gets rid of the HasCallStack constraint, and the other stuff disappears in similar ways?
05:23:42 <merijn> willsewell: The newest unix doesn't support time-1.9 yet
05:24:20 <merijn> oh
05:24:38 <merijn> I take that back, the latest version of unix *does* support time-1.9 now
05:24:58 <merijn> However, that bounds restriction was done via a revision
05:25:25 <merijn> And if I recall correctly stack intentionally ignores revisions, so it uses the bounds of unix at release time (which didn't support time-1.9)
05:25:26 <willsewell> I have also set allow-newer: true
05:26:36 <merijn> I don't actually know stack, so no idea what that does :)
05:26:47 <willsewell> For reference, my stack file is
05:26:48 <willsewell> https://github.com/WillSewell/pusher-http-haskell/blob/master/stack.yaml
05:26:57 <willsewell> cabal file is https://github.com/WillSewell/pusher-http-haskell/blob/master/pusher-http-haskell.cabal
05:27:29 <willsewell> If I remove the line time-1.9.2 it works, and it also worked with an older version of stack
05:28:36 <willsewell> merjin, allow-newer means that you can use dependencies outside of the version version ranges of the depending packages
05:28:59 <merijn> I know what it means for cabal(-install), I just don't know how it interacts with stack
05:29:52 <willsewell> It works that way for stack too (I'm assuming it just passes it through to cabal)
05:30:28 <domenkozar[m]> phadej: are you at munihac?
05:30:39 <merijn> ugh...why is naming things so hard? >.>
05:34:15 <dminuoso> Taneb: Okay I think I have it, with a bit of waving hands.
05:34:16 <phadej> domenkozar[m]: i do not admit anything ;)
05:34:25 <phadej> oh crap, this was #haskell...
05:36:22 <domenkozar[m]> :D
05:44:32 <dminuoso> Taneb: If we consider the category theory perspective: From Yoneda we get `FA ~= nat(Hom(A, B), FB)` which gives us some `FA -> B^A -> FB` - The Monad induced Applicative instance is justified by considering a specialized case of `FA -> F(B^A) -> FFB`, which is composed with `Î¼ : FFB -> FB` from the Monad to produce a nt  `FA -> F(B^A) -> FB`
05:44:48 <exarkun> wrote up my stack / nixos / c library problem from yesterday: https://stackoverflow.com/questions/57822288/how-do-i-supply-a-c-library-to-stack-on-nixos
05:45:14 <dminuoso> Taneb: So from that it'd have to be the same Î¼ that the Monad is equipped with.
05:46:38 <Taneb> dminuoso: I can't really comprehend tha tright now, but thanks
05:47:00 * hackage aeson-injector 1.1.2.0 - Injecting fields into aeson values  https://hackage.haskell.org/package/aeson-injector-1.1.2.0 (NCrashed)
05:50:51 <infinisil> merijn: Maybe we need some construct where you can input some rules and behavior, and it outputs whether this concept or something related is known and has a name
05:52:11 <infinisil> E.g. you could input "An f such that if you have only f(x) it's very hard to know x", and it would output "That's called a hash function you dummy"
05:53:36 <EvanR> an engine of some sort, for searching...
05:53:36 <EvanR> call it... a question answerer
05:53:36 <infinisil> And if it can't find anything it outputs "You just invented a new thing, a patent has been created automatically for you, and a name has been picked for you, it's called a florp"
05:53:43 <infinisil> EvanR: But like, more mathematical than the existing ones!
05:54:04 <exarkun> EvanR: if you had it, you could put the description of it into it
05:54:04 <EvanR> you just invented a new thing, psyche, i just patented it for myself
05:54:04 <exarkun> EvanR: and it would tell you it's an "oracle" ;)
05:54:04 <infinisil> Not this Neural network recommendations crap
05:54:06 <EvanR> (real late night TV is exactly this)
05:55:21 <infinisil> Like Hoogle in a way, where you can search for a type!
06:19:41 <yoneda> dminuoso++
06:21:54 <Athas> Which regex libraries do people use for Haskell?  Since I appear to be the first one to notice that regex-base is incompatible with GHC 8.8, I assume that I must have missed the bus.
06:22:05 <yoneda> karma+ dminuoso
06:22:36 <merijn> Athas: tbh, I generally just use the various parsecs instead... (or is the problem that users are providing regex inputs?)
06:23:07 <Athas> merijn: yes, I obviously don't use regexes myself!  I have a tool that needs to process simple user-provided regexes.
06:23:50 <merijn> Athas: I recall seeing a library that parsec regex strings into parser combinator parser, but I don't recall the name
06:23:56 <Guest20> Is it ok to declare an instance as e.g `instance Pretty (Dict a) where pretty = error "This should be internal..."`
06:23:58 <EvanR> problem: regex lib is broken
06:24:06 <EvanR> solution: don't use regex? seems wrong
06:24:29 <merijn> EvanR: Sounds like the right solution to me, tbh ;)
06:24:32 <Athas> And regex-base is maintained on Sourceforge!  I wonder what my old account was called...
06:25:40 <yoneda> preflex: dminuoso++
06:27:09 <merijn> Athas: Depending on how complex regexes you need to support you could write a quick and dirty "Parser (Parser Foo)" that parses a regex into a parser >.>
06:27:31 <Athas> I really don't want to maintain yet another parser.
06:27:32 <tdammers> regex-tdfa?
06:27:39 <merijn> tdammers: It's broken
06:27:44 <merijn> tdammers: That was the entire discussion :)
06:27:46 <Athas> tdammers: that's what I'm using.
06:27:52 <tdammers> oh, ok
06:28:04 <yoneda> <dminuoso>++
06:28:06 <Athas> But the regex-* hierarchy has regex-base at the bottom, which is apparently some long-forgotten unmaintained thing.
06:28:23 <Athas> It's hosted on Sourceforge (under the name "regex-lazy" for some reason, with no activity for nine years, and no source repository either).
06:28:41 <Athas> Er, "lazy-regex".
06:29:24 <yoneda> !help karma
06:29:34 <tdammers> uploaded 2010... oh dear...
06:29:36 <boxscape> If I don't add ! after {-# UNPACK #-} (which gives warning), does ghc add one automatically?
06:30:06 <boxscape> @help karma
06:30:06 <lambdabot> karma <polynick>. Return a person's karma value
06:30:13 <tdammers> someone should step up and offer taking over as maintainer
06:30:21 <boxscape> ^ yoneda
06:30:22 <EvanR> hey, a perfect library doesn't need updates : )
06:30:23 * tdammers coughs awkwardly
06:30:26 <Athas> I'm considering it.
06:30:43 <Athas> EvanR: I'm shocked that it has been kept working for nine years without changes!
06:30:46 <tdammers> so tbc, the breakage is that it doesn't compile on GHC 8.8?
06:30:54 <merijn> Athas: A testament to Haskell ;)
06:30:55 <tdammers> because it seems to work fine on 8.6.5
06:30:57 <Athas> That's through both the Monad/Applicative and the Traversable changes!
06:31:14 <Athas> It's a negative testament to Haskell that I'm surprised, I'd say.
06:31:56 <merijn> Athas: tbh, most other languages packages don't stay working without updates that long even without big changes >.>
06:32:18 <dmwit> ?karma <dminuoso>
06:32:18 <lambdabot> <dminuoso> has a karma of 1
06:32:19 <boxscape> and yet java still supports raw types
06:32:24 <dmwit> funny
06:32:59 <maralorn> asheshambasta: Trying to reformat a file of which one does not understand the complete syntax seems like a dangerous default.
06:33:31 <maralorn> I think teaching brittany arrow syntax would be a much better idea.
06:34:10 <tdammers> merijn: or, put differently, in other languages, even tiny changes are big
06:36:00 <merijn> tdammers: Well, and so buggy that the idea of going 9 years without bugfixes is unthinkable
06:36:13 <dmwit> I think the real testament here is we've gone like 30 years without having any two extensions conflict with each other.
06:36:20 <dmwit> This still blows my mind sometimes.
06:37:00 * hackage ron 0.9 - RON  https://hackage.haskell.org/package/ron-0.9 (cblp)
06:37:41 <Athas> regex-base is just an interface package.  I can imagine a Java library that is just a bunch of interfaces having zero bugs as well.
06:39:31 <yoneda> ?karma+ <dminuoso>
06:39:31 <lambdabot> <dminuoso>'s karma raised to 2.
06:39:45 <boxscape> I would think that you have to do it without the <>s
06:50:20 <boxscape> is there something like showIntegerAtBase, akin to showIntAtBase?
06:50:43 <boxscape> ah wait
06:50:58 <boxscape> showIntAtBase acutally just has an Integral constraint
06:51:16 <boxscape> now I just need to figure out why it produces an empty String with my input Integer
06:51:19 <Ariakenom> boxscape: yes :) here let me implement it for you
06:51:20 <Ariakenom> showIntegerAtBase = showIntAtBase
06:51:29 <boxscape> :) nice
06:53:00 <boxscape> (hm made it work by putting the intermediate result in a variable, guess it was some ghci type inference shenanigans)
06:53:50 <Ariakenom> the dreaded monomorphism restriction strikes again
06:54:31 <boxscape> indeed
06:57:18 <Ariakenom> boxscape: you can do "default ()" to disable type defaulting. you may get ambiguous type error instead but that's usually not too annoying
06:58:21 <Ariakenom> probably depends on what one is doing. you can try and see
07:02:30 * hackage ron-rdt 0.9 - Replicated Data Types (RON-RDT)  https://hackage.haskell.org/package/ron-rdt-0.9 (cblp)
07:03:27 <boxscape> Ariakenom Ah, good to know
07:03:30 * hackage ron-storage 0.10, ron-schema 0.9 (cblp): https://qbin.io/ports-shelf-7vnx
07:03:34 <boxscape> what is ghci's default set to?
07:04:25 <boxscape> for regular programs it's (Integer, Double, String) I think? But ghci seems to have some strange rules about assuming () as well
07:05:35 <Ariakenom> boxscape: yes. im unsure about the details https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#type-defaulting-in-ghci
07:05:49 <boxscape> ok, thanks
07:07:19 <tejok[m]> hey there, I have a haskell project that I build on my NixOS using `cabal2nix`, so far so good, but now I added a new dependency `haskell-postgis` and it tells me ` called without required argument 'haskell-postgis'` when trying to open a nix shell... it's weird as I see this package is available in NixOS when looking on hackage. Any idea tips to fix this?
07:08:08 <jgt> tejok[m]: did you run cabal2nix again after adding the dependency?
07:09:00 <tejok[m]> jgt: yes indeed! I did run it again, and I see changes (a priori properly) reflected
07:09:22 <Ariakenom> boxscape: looks like maybe default ((),[],Integer,Double,String)
07:09:32 <boxscape> tejok[m] haven't used cabal2nix by itself in a while, but from what you're saying it sounds like it generates a nix file that expects that you give it haskell-postgis as an arguement
07:09:38 <boxscape> Ariakenom ah, good to know, thanks
07:10:02 <tejok[m]> here is the diff: https://pastebin.com/zh6FsKDB
07:10:15 <tejok[m]> indeed it adds it as argument, but like any other dependency, right?
07:10:41 <boxscape> tejok[m] there is buildHaskellPackage or something like that in nixpkgs that calls cabal2nix for you and is a lot more convenient to use, let me see if I can find it
07:11:23 <tejok[m]> oooh, sounds yummy ðŸ™‚
07:12:48 <boxscape> tejok[m]: here's an example default.nix from one of my haskell projects https://github.com/JakobBruenker/assembler/blob/master/default.nix
07:12:59 <boxscape> the repository also contains a shell.nix file which might be useful
07:13:09 <boxscape> https://github.com/JakobBruenker/assembler/blob/master/shell.nix
07:13:28 <boxscape> you can then run nix-shell and use cabal repl and cabal build for development
07:13:56 <tejok[m]> this is wonderful, thanks for your help boxscape I'll give this approach a try, that looks like a nice integration.
07:14:11 <boxscape> yeah it's quite convenient
07:17:31 <boxscape> tejok[m] If you want to use a package.yaml instead of a .cabal by the way that works too, but I'm not sure if cabal2nix does that automatically or if you have to call hpack in the shell-hook in the shell.nix file
07:17:54 <boxscape> .cabal file, that is
07:18:57 <boxscape> (uh that might be misleading; to be clear, shell-hook is in shell.nix)
07:19:22 <dminuoso> Mmm. I sometimes wish more things were written MonadIO/MonadUnliftIO polymorphic.. its annoying to sprinke liftIO and withRunInIO all over my code.
07:20:44 <tejok[m]> no worries @box
07:20:57 <tejok[m]>  * no worries @boxscape I use only a `.cabal` file here
07:21:01 <boxscape> ok
07:27:14 <merijn> dminuoso: That's why my own IO heavy library has everything prelifted ;)
07:27:39 <merijn> dminuoso: Especially now that MonadIO is in base, instead of transformers
07:27:58 <dminuoso> merijn: yeah.. I mean I could live with not everything having MonadUnliftIO, but MonadIO at least..
07:31:24 <dminuoso> merijn: especially things like sqlite-simple that have a high chance of being used in transformer stacks ;)
07:34:30 * hackage cabal2spec 2.3 - Convert Cabal files into rpm spec files  https://hackage.haskell.org/package/cabal2spec-2.3 (PeterSimons)
07:54:41 <srandon111> hello all guys, is there a framrwork like pandas for haskell
07:54:47 <srandon111> for dataframes and data analysis
07:56:36 <merijn> srandon111: Not something standard, but depending on the details it may be really easy to put something together
07:56:47 <sshine> srandon111, https://tweag.github.io/HaskellR/ ? ;)
08:00:32 <freeman42x> shameless self plug, streaming about setting up Haskell on Widows 10 and then working on free and open source projects at Fairy Tale: https://www.twitch.tv/freeman42x
08:05:30 * hackage hspec-wai 0.10.0 - Experimental Hspec support for testing WAI applications  https://hackage.haskell.org/package/hspec-wai-0.10.0 (SimonHengel)
08:06:30 * hackage hspec-wai-json 0.10.0 - Testing JSON APIs with hspec-wai  https://hackage.haskell.org/package/hspec-wai-json-0.10.0 (SimonHengel)
08:07:00 <AviD> Anyone have know who run the logging software on this channel or the tunes.org site?
08:08:48 <dminuoso> With libraries like cassave
08:08:48 <dminuoso> Wow oops.
08:10:19 <dminuoso> AviD: Mmm I know that at least chrisdone is involved with the project responsible for that website.
08:10:56 <AviD> dminuoso: Thanks
08:11:13 <dminuoso> AviD: Presumably http://hackage.haskell.org/package/clogparse is still the software used to drive that website, so perhaps that author might also be a good start
08:11:14 <sm[m]> I don't think so.. Chris's was http://ircbrowse.net
08:11:23 <sm[m]> I want to say tunes.org was Brian Tracy
08:11:38 <jumper149> Are there valid (respecting the laws) examples of a monad, where `liftM /= fmap`?
08:11:38 <dminuoso> sm[m]: Absolutely, Im merely saying that chris done was involved with TUNES
08:11:46 <phadej> ajirx[m]: no
08:11:47 <dminuoso> jumper149: No.
08:12:08 <dminuoso> jumper149: Well, strictly speaking you could do that. But you lose the benefits of the typeclass hierarchy.
08:12:40 <phadej> other one can be faster than other, but results are the same
08:12:46 <dminuoso> Although... Im not sure whether multiple functor instances are ever possible?
08:12:50 <phadej> (because fmap is unique)
08:12:50 <dminuoso> (In Haskell)
08:12:55 <phadej> you cannot
08:13:00 <dminuoso> phadej: free theorem?
08:13:04 <phadej> dminuoso: yes
08:13:32 <sm[m]> correction: Brian Rice
08:14:50 <EvanR> multiple functor insteads are not possible in haskell, right. but not in general
08:14:54 <EvanR> instances*
08:14:58 <sm[m]> Avid: http://www.briantrice.com . I don't think there's any public log of the channel right now other than the matrix room
08:15:49 <merijn> jumper149: There are no lawful monads like that, no
08:15:56 <jumper149> dminuoso: With only `fmap id = id` and `fmap (f . g) = fmap f . fmap g` the Functor instance is not totally determined, if that is what you mean.
08:16:57 <sm[m]> oh! I take it back, http://tunes.org/~nef/logs/haskell/ is still going strong. Just no longer in /topic
08:17:21 <sm[m]> sigh, wrong again sm. :)
08:17:33 <EvanR> i wonder why it's not in the topic
08:17:43 <EvanR> and stupid gist is :(
08:17:50 <phadej> jumper149: it is. https://stackoverflow.com/a/19775139/1308058
08:19:01 <sm[m]> it's in the topic on IRC ("Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D"), just not in the room description on Matrix
08:19:35 <sm[m]> and the "/?C=M;O=D" part seems unnecessary and could be trimmed
08:19:48 <EvanR> i see it now
08:20:04 <sm[m]> "nef" looks like the maintainer
08:20:35 <jumper149> What about `instance Functor ([]) where { fmap f (x:xs) = (f x) : xs }`?
08:20:51 <jumper149> Isnt that a valid Functor instance?
08:21:01 <merijn> jumper149: No
08:21:08 <merijn> jumper149: Well, define "valid"
08:21:23 <merijn> jumper149: Does it typecheck? Yes. Does it obey the laws? No.
08:21:34 <jumper149> `fmap id = id` and `fmap (f . g) = fmap f . fmap g`
08:21:51 <jumper149> or am I missing something?
08:21:54 <merijn> jumper149: Actually, I take it back
08:21:58 <merijn> jumper149: It doesn't typecheck
08:22:10 <merijn> jumper149: Yes. What happens if I do "fmap even"?
08:22:12 <merijn> :t even
08:22:13 <jumper149> ahhhh, ty 
08:22:14 <lambdabot> Integral a => a -> Bool
08:23:19 <exarkun> So ... now Tasty.  The type error is indeed simpler: testProperty here, https://github.com/PrivateStorageio/PaymentServer/blob/12.ristretto-privacypass/test/SpecStuff.hs#L132-L143 failing because no instance `Test.QuickCheck.Property.Testable (Test.Hspec.Wai.Internal.WaiSession ()))`.  So ... Tasty QuickCheck properties for Wai ... any hope there?
08:23:47 <geekosaur> I'm not sure what it means for a WaiSession to be Testable
08:23:55 <jumper149> well but that means liftM is obsolote right?
08:24:00 * hackage ron-rdt 0.9.1 - Replicated Data Types (RON-RDT)  https://hackage.haskell.org/package/ron-rdt-0.9.1 (cblp)
08:24:01 <merijn> jumper149: Yes
08:24:12 <merijn> jumper149: The reason it exists is historical mistakes
08:24:51 <merijn> jumper149: Originally Functor was not a superclass of Monad, so you couldn't use fmap when all you knew was that something was a Monad, because that didn't guarantee there was also a Functor instance
08:25:02 <merijn> jumper149: So liftM existed as "Monad only" version of fmap
08:25:16 <merijn> jumper149: Now that Functor *is* a superclass of Monad, there's no reason not to just use fmap
08:25:53 <jumper149> There should be something about stuff being unnecessary in the docs! I had multiple occasions where I thought there was something I didn't understand, when it was just part of a superclass.
08:26:11 <exarkun> geekosaur: oh right.  WaiSession () is WaiExpectation
08:26:57 <exarkun> but I guess this code might be incorrectly mixing Hspec and Tasty ...
08:27:00 * hackage git-brunch 1.0.6.0 - git checkout command-line tool  https://hackage.haskell.org/package/git-brunch-1.0.6.0 (andys8)
08:28:00 * hackage ron-storage 0.10.1, ron-schema 0.9.1 (cblp): https://qbin.io/camp-trips-8wsc
08:29:40 <exarkun> but generally I wonder if `testProperty` and `testWai` can be used together
08:30:33 <exarkun> They both *return* a TestTree.  Neither accepts a TestTree.  So superficially ... no
08:34:00 * hackage pipes-safe 2.3.2 - Safety for the pipes ecosystem  https://hackage.haskell.org/package/pipes-safe-2.3.2 (GabrielGonzalez)
08:37:42 * sm[m] wonders how cabal v1-install could be picking a 7 year old version despite correct bounds in cabal file (https://github.com/Homebrew/homebrew-core/pull/43927#issuecomment-528903197)
08:40:14 <sm[m]> no loophole in these hledger/hledger-lib bounds, right ? http://hackage.haskell.org/package/hledger-web-1.15/src/hledger-web.cabal
08:41:48 <merijn> sm[m]: v1-install prefers versions already installed in the global database if within bounds
08:42:07 <merijn> sm[m]: Which means it build-plan selection is utterly unpredictable
08:42:33 <sm[m]> and yet, http://hackage.haskell.org/package/hledger-web-0.18.2/src/hledger-web.cabal clearly requires hledger-0.18
08:42:55 <merijn> Well, is it building hledger-web-0.18.2 or some older version?
08:43:33 <sm[m]> at least, the executable does. Strangely the library has no build-depends at all.
08:43:59 <sm[m]> homebrew's CI is trying to build hledger-web-0.18.2 as a dependency of hledger-1.15.2
08:44:11 <sm[m]> or so it appears
08:45:27 <sm[m]> no, that can't be right. hledger-web-1.15.2 is also mentioned in the brew formula as an additional item. I don't know why it's trying to build hledger-web-0.18.2.
08:45:40 <merijn> sm[m]: Try running -v3
08:47:52 <sm[m]> it's not doing it for me. I'll suggest that to them. :/
08:48:32 <sm[m]> also I'll suggest they clean their global cabal v1 package db.. though I forget how
08:49:03 <merijn> Or tell them to switch to v2-build :p
08:49:40 <sm[m]> that too. Or stack.
08:49:42 <devalot> Is there a way to write Haddocks for functions generated with TH (i.e. makeLenses)?
08:50:06 <merijn> sm[m]: v2-build will always try the latest version allowed by bounds, so it's build plans are predictable
08:50:18 <sm[m]> thanks merijn
08:50:24 <merijn> sm[m]: Additionally for something like homebrew they can use v2-freeze to fix a working dependency set and always use that
08:50:41 <merijn> sm[m]: Which will stop future releases from breaking a working build
08:52:18 <sm[m]> I'll note it
08:53:30 * hackage checkers 0.5.2 - Check properties on standard classes and data structures.  https://hackage.haskell.org/package/checkers-0.5.2 (ConalElliott)
08:57:57 * sm[m] wonders where the homebrew haskell packaging team hangs out
09:02:39 <exarkun> When https://hackage.haskell.org/package/tasty-quickcheck-0.10.1/docs/Test-Tasty-QuickCheck.html says "For best results, generate all random values before calling ioProperty" what is it suggesting?  How do you generate random values outside of the property?
09:20:30 * hackage harg 0.2.0.0 - Haskell program configuration using higher kinded data  https://hackage.haskell.org/package/harg-0.2.0.0 (alexpeits)
09:28:30 * hackage harg 0.1.3.0 - Haskell program configuration using higher kinded data  https://hackage.haskell.org/package/harg-0.1.3.0 (alexpeits)
09:57:30 * hackage sproxy2 1.97.1 - Secure HTTP proxy for authenticating users via OAuth2  https://hackage.haskell.org/package/sproxy2-1.97.1 (ip1981)
10:00:03 <AWizzArd> In WAI I can use a vault to store data: https://hackage.haskell.org/package/wai-3.2.2.1/docs/Network-Wai.html#v:vault  Now if I create a key under which I place a value in the vault in some middleware â€-- then how can I lookup this data in a handler?
10:01:13 <AWizzArd> It seems that a vault Key is just some nameless thing. Between middleware and handler I can't communicate the Key. So how could the handler reproduce exactly that one Key that would be required to lookup the data?
10:07:38 <Cale> AWizzArd: you can't just pass it along?
10:09:21 <AWizzArd> Cale: I could - but if I did that then I could just pass the value along that I want to transport via the Vault, from middleware to handler.
10:10:04 <Cale> Perhaps, but isn't the vault there stateful?
10:10:07 <AWizzArd> The whole point of this excercise is that the middleware can pass through a req value that is modified (i.e. not the original one). A req in which there is a vault from which handlers can later then take pre-computed information.
10:10:40 <Cale> Actually, I'm not sure, maybe it's not somehow
10:11:20 <AWizzArd> Cale: I think I just discovered the "trick". I need to introduce some types without values.  `data Username`  for example. And then I can say:    (k :: Key Username) <- newKey
10:12:17 <AWizzArd> I can't just use DataKinds and do   data MyKeys = KeyA | KeyB | KeyC  as the kind `Type` is required. So it will have to be a bunch of datas, such as  `data KeyA`,  `data KeyB`  and `data KeyC`.
10:12:22 <cocreature> That doesnâ€™t make sense. You canâ€™t use `insert` with that key since you canâ€™t have a vale of type `Username`
10:12:51 <AWizzArd> cocreature: good point, I see this now.
10:13:02 <Cale> Also, each execution of newKey will get you a distinct key regardless
10:13:20 <Cale> So if you do it again for the same type, you won't get the key that's required to look up the thing
10:13:38 <AWizzArd> Cale: I thought so too, that each bind creates a fresh Key.
10:14:18 <cocreature> yeah just create a new key on application startup with newKey and then use that in your middleware and in your handler
10:14:20 <AWizzArd> Cale: But now I thought that there exists just one Key per type. So I could place only one value of one certain type in a Valut.
10:14:53 <AWizzArd> cocreature: okay, so all the keys that I need I can create and place them in a hashmap which I store in my Context.
10:15:11 <cocreature> or just pass the keys around
10:15:36 <AWizzArd> But in that case the whole concept of the Vault is unnecessary. If I have such a collection of Keys in my Context I could then as well simply have a TVar-ed map in which I transport my data in the first place. And that whole Vault thing is no longer required.
10:15:52 <Cale> Yeah, pretty much
10:16:09 <AWizzArd> The truly interesting aspect here would be if I would _not_ have to communicate the Keys explicitly, but could recreate the same Keys in middlerware and handler.
10:16:13 <Cale> Unless there's something we're completely missing
10:17:39 <AWizzArd> Cale: si. My hope was that `newKey` can only produce one specific key for one call. If I do  `(k :: Key User) <- newKey` then I can insert one single User, but recreate that exact same key in the handler then, where I want to lookup the data.
10:19:55 <nshepperd2> you could do a top-level "myKey = unsafePerformIO newKey"
10:20:09 <nshepperd2> not sure that's how it's supposed to be used though
10:20:53 <cocreature> https://www.yesodweb.com/blog/2015/10/using-wais-vault has some examples
10:21:19 <cocreature> I think it just tries to provide a somewhat uniform API here. It doesnâ€™t provide functionality that you couldnâ€™t achieve without builtin support.
10:22:14 <cocreature> it does have the advantage that you donâ€™t have to be in IO to change the Vault I guess but given that handlers and middlewares both are in IO Iâ€™m not sure that gives you much
10:22:55 <AWizzArd> cocreature: Yeah, it seems so. I will then just go with a TVar in my Context and simply make some more progress.
10:23:17 <AWizzArd> Cale is unfortunately right that each call of newKey _really_ creates a new fresh/unique key.
10:25:54 <AWizzArd> I really wonder why there is no API call to recreate keys. Then I can have   data MyKey = K1 | K2 | K3   and do    k <- namedKey K2    and wouldn't have to communicate it.
10:28:16 <nshepperd2> I think it's intended to enable middlewares to put extra information in Request without changing the type
10:30:50 <AWizzArd> nshepperd2: I can indeed put extra info into the Req... the challenge here is to get it out again. And this is not possible without communicating the Key itself to the handler. But as soon as I have to do this manually I could as well solve the communication challenge from middleware to handler via a TVar in my Context.
10:31:36 <jgt> tbh I just pass data around in headers
10:31:48 <jgt> in my case its all stringy stuff anyway
10:32:05 <cocreature> AWizzArd: thatâ€™s somewhat tricky if your information is specific to your request though, right? Request doesnâ€™t really have any useful instances to use it as part of the key in your TVar
10:32:12 <nshepperd2> You could create the key at toplevel with an unsafePerformIO
10:32:14 <AWizzArd> jgt: Hmm yes, that could also be an approach. Not deeply typesafe, but pragmatic :)
10:32:37 <AWizzArd> nshepperd2: yes, this might be an exceptional case where uPIO really is fine to use.
10:32:42 <nshepperd2> You're not supposed to create a new key each request, only once at the start of the program
10:32:56 <jgt> AWizzArd: did you see also per-request caching?
10:33:22 <AWizzArd> nshepperd2: yes, that's a very good summary
10:33:28 <AWizzArd> jgt: nope, link?
10:33:58 <jgt> AWizzArd: https://hackage.haskell.org/package/yesod-core-1.6.16/docs/Yesod-Core-Handler.html#g:28
10:35:27 <jgt> per-request caching is super useful in my case
10:36:11 <jgt> I use it for generating nonces for CSP reasons, and then recalling my set of nonces (for all my scripts and stylesheets) to then build a CSP header
10:37:47 <AWizzArd> jgt: Ah, Servant here.
10:38:18 <jgt> I'm afraid I have zero experience with Servant
10:40:00 <AWizzArd> The most pragmatic way, if I want to use the Vault, would be nshepperd2's suggestion to solve it with some global Keys, created via unsafePerformIO.
10:41:15 <cocreature> I donâ€™t see why you need global keys so badly. Why canâ€™t you just create the key on startup and pass it to your middleware?
10:41:17 <shapr> Anyone else having problems with the unix-time cabbage in the configure stage?
10:41:50 <shapr> for no reason I can discern I'm getting: //home/shae/build/spookel/dist-newstyle/tmp/src-12806/unix-time-0.4.5/configure: line 553: 0: Bad file descriptor
10:42:25 <shapr> I've tried downgrading to 0.4.3 and also rebooting, but no change. Any ideas?
10:46:36 <nshepperd2> fd 0 is stdin, isn't it? How can it be 'bad' o_0
10:47:16 <int-e> nshepperd2: you can close stdin and then invoke the configure script?
10:47:58 <int-e> the line in question is: test -n "$DJDIR" || exec 7<&0 </dev/null
10:48:03 <int-e> (wtf is DJDIR?)
10:48:55 <int-e> shapr: anyway, seems to work fine with plain cabal-install
10:49:29 <int-e> (ah, that would be version 2.4 still)
10:49:38 <tdammers> sounds like a remnant from djgpp, the first (?) port of the gcc toolchain to the DOS (and later Windows) platform
10:49:43 * int-e wonders whether that makes a difference.
10:50:09 <tdammers> IIRC MinGW / Cygwin inherited some of the djgpp codebase, and I believe $DJDIR is part of that heritage
10:53:35 <AWizzArd> cocreature: also an option, yes.
10:55:39 <AWizzArd> cocreature: though... then the keys will have to be put into some container, and for each use I would have to extract them first. If they were globals then I could comfortably just use them.
10:56:26 <cocreature> I would always go for the simpler solution first and passing things around seems simpler than unsafePerformIOing a bunch of global keys.
10:57:01 <AWizzArd> cocreature: I think the global constants are the simpler way.
10:57:40 <cocreature> Iâ€™m hesitant to call things involving unsafePerformIO â€œsimpleâ€. â€œconvenientâ€ might be a better name :)
10:58:04 <AWizzArd> Yeah.
10:59:10 <cocreature> ReaderT might be convenient but I wouldnâ€™t say itâ€™s simpler than just passing things around and unless Iâ€™m sure that the convenience matters I tend to opt for the simpler option.
11:11:00 * hackage urbit-hob 0.1.0 - Hoon-style atom manipulation and printing functions  https://hackage.haskell.org/package/urbit-hob-0.1.0 (JaredTobin)
11:12:54 <day> how can i map a csv string to a custom data type? e.g. str="first;second;third"  the first one is simple i can simply do a "first = head $ splitOn ";" str"
11:15:41 <day> normally i would hop with recursion through the list, but i dont see how i can use that in conjunction with the custom data type fields
11:18:01 <EvanR> a more robust way would be to use a "parser" to consume each field of the csv in order, attempting to convert the field or else bail out because the format is wrong
11:18:19 <EvanR> Applicative style is really good for this pattern
11:18:47 <EvanR> on success return your data type
11:19:19 <EvanR> a well formed CSV file may none the less have bad data in it
11:21:30 * hackage tree-sitter 0.2.0.0 - Unstable bindings for the tree-sitter parsing library.  https://hackage.haskell.org/package/tree-sitter-0.2.0.0 (aymannadeem)
11:23:15 <EvanR> if you have data Triple = Tr A B C, then the final form of the parser might look like Tr <$> getFirst <*> getSecond <*> getThird
11:24:00 <EvanR> where getWhatever is a specialized parser expecting specific format in that cell
11:25:55 <dmj`> big data', big problems'
11:30:42 * merijn resets the "It has been N days since I was last annoyed by someone creating "pretty" Show output" to 0
11:32:30 * hackage tree-sitter-python 0.2.0.0 - Tree-sitter grammar/parser for Python  https://hackage.haskell.org/package/tree-sitter-python-0.2.0.0 (aymannadeem)
11:43:27 <jakov> hi ! what's the right syntax to create from an array a datatype, f.e with "Bar = Bar {magicnumber :: Double, difftime :: Double }" where i have an array with [Double, Double]. the type signature would have to be something like  ' [a] -> (a -> a -> b) -> b '. Is there a common way, or is it easiest to write "Bar (arr !! 0) (arr !! 1)" ?
11:46:04 <infinisil> jakov: Try to use pattern matching on the [a] argument
11:46:06 <day> EvanR: thanks. i shall look into that
11:46:23 <infinisil> jakov: This should get you to a better solution
11:48:44 <merijn> argh...
11:49:04 <merijn> So does anyone know where optparse-applicative generates the available options help?
11:49:29 <jle`> jakov: by the way, just to prevent some future confusion, [a] is not quite an array, but a list, so it's implemented in terms of conses and nil's
11:49:45 <jle`> jakov: so a list with two doubles is literally just `x:y:[]`
11:49:53 <geekosaur> that question sounded confused. [Double, Double] isn't a thing as such; [Double] is a list of zero or more Double-s
11:50:16 <jle`> judging from the context they meant [someDouble, someOtherDouble]
11:50:18 <jle`> i think
11:50:25 <jle`> to represent a list literal
11:50:36 <geekosaur> hm, maybe
11:50:43 <jle`> jakov: you can also directly pattern match on list literals too, myFunc [x,y] = Bar x y
11:50:56 <jle`> but keep in mind that function would be undefined for lists of lengths different than 2
11:51:01 <jakov> ? Sorry, as you see, i am rather a newcomer. Yeah, i mean [Double]. infinisil, is it possible to implement such a function for an arbitraty length of "Bar" ?
11:51:22 <geekosaur> not readily. (what would its type be?)
11:51:24 <jle`> jakov: Bar is your data type, what do you mean by arbitrary length?
11:51:39 <jle`> jakov: it is fixed with two Double's (magicnumber, difftime)
11:52:15 <jakov> my bar has " data Bar = Bar {a :: Double, b :: Double, c :: Double, d :: Double, e :: Double}"
11:52:34 <jle`> hm, you could write something like myFunc [a,b,c,d,e] = Bar a b c d e
11:52:43 <jle`> or myFunc [a,b,c,d,e] = Bar{..} if you enable -XRecordWildCards
11:52:50 <infinisil> jakov: Unless you want to dive into TemplateHaskell (which you don't), no way to get a general function for that no
11:53:03 <jakov> okay, thanks a lot !
11:53:25 <jle`> it's not easy or recommended to implement one function that will work for all different shapes and sizes
11:53:32 <jle`> but it is easy to implement a function for a specific arbitrary shape or size
11:53:59 <jakov> thank you infinisil ans jle`
11:54:05 <jakov> ** and
11:54:07 <jle`> jakov: if you do write something like `myFunc [a,b,c,d,e] = Bar{..}`, remember to add another case to handle the other sorts of lists :)
11:54:12 <jle`> like myFunc _ = Bar 0 0 0 0 0
11:55:38 <jakov> I'll do that :)
11:55:44 <jakov> Thanks again!
11:56:06 <pfurla> does Sandro LovniÄki hang around here?
11:57:52 <nanoz> hi
12:05:20 <trcc> anyone using hie-core with vscode? getting an error: Starting Client Failed - Launching server using command hie-core failed.
12:10:37 <MarcelineVQ> merijn: iiuc you write the help yourself, in a way, as you define the various parsers and descriptions but they seem to be combined in https://hackage.haskell.org/package/optparse-applicative-0.15.0.0/docs/src/Options.Applicative.Help.Core.html#parserHelp and made printable via https://hackage.haskell.org/package/optparse-applicative-0.15.0.0/docs/src/Options.Applicative.Help.Types.html#renderHelp
12:11:03 <merijn> MarcelineVQ: Yeah, I've seen all those, but none of them seem to generate the list of options >.>
12:11:39 <merijn> MarcelineVQ: Because if you use those it'll only show headers/footers and subcommands, not the "Available options" bit
12:13:21 <MarcelineVQ> really? weird. parserHelp says "with_title "Available options:" (fullDesc pprefs p)"
12:13:24 <merijn> MarcelineVQ: Basically, I was trying to workaround https://github.com/pcapriotti/optparse-applicative/issues/294 by manuall including generated help text in subcommands
12:13:48 <merijn> MarcelineVQ: I know, but if I run parserHelp on my parsers there is no "Available options" in the output!
12:13:52 <merijn> It's supper confusing!
12:14:48 <merijn> MarcelineVQ: I'm slowly working my way through the API by trying all those functions and reading through the code and I'm honestly baffled where it's managing to add those
12:15:58 <merijn> mm
12:16:33 <merijn> Seems like it might be coming from with_context in parserFailure, which is a bit inconvenient, because that suggests I can't extract the help without a failed parse
12:23:00 <merijn> ok, seems like this is just utterly doomed, because the Context relies running the parse completely somehow
12:45:51 <merijn> MarcelineVQ: Well...I managed to rip the usage out of the guts of optparse, but it's...as pretty as you'd expect from guts >.>
12:47:07 <EvanR> optparse slumps over into a worthless pile as merijn leaves the room with its guts
12:47:46 <merijn> I hate it when I know much, *much* more about a libraries internals than I wanted >.>
12:47:52 <MarcelineVQ> ãŠå‰ã¯ã‚‚ã†æ­»ã‚“ã§ã„ã‚‹
12:56:44 <dmj`> optparse-applicative works well, but is not intuitive
12:57:49 <merijn> dmj`: I find it rather intuitive as long as you don't look under the hood
12:58:12 <dmwit> It's intuitive if you sit in exactly the collection of command-line languages it was designed for.
12:58:14 <merijn> Of course, if you try and work around outstanding feature request via internals that...is not an option >.>
12:58:25 <dmwit> If you try to step out of that collection *at all*, it becomes ridiculous.
12:58:37 <dmj`> merijn: I end up copying and pasting this every time I work with it https://ro-che.info/articles/2016-12-30-optparse-applicative-quick-start
12:58:57 <dmj`> API design is like a joke, if you have to explain it, it probably isn't good
12:59:36 <merijn> dmj`: Structured like that it looks unreadable yes, but if you write parsers like that you have rather simple parsers anyway
13:00:18 <merijn> dmj`: I find most of the alternatives (including other languages) dramatically inferior in terms of documentation, features, or both
13:01:43 <merijn> dmwit: Do you have an example of something you'd *want* to do, but can't with it?
13:09:48 <jgt> domenkozar[m]: ping
13:14:02 <dmj`> yea anytime someone uses join I always suspect they'r doing something unnecessary
13:15:17 <merijn> dmj`: That join is due to have a parser producing "IO ()" and execParser also doing IO
13:15:23 <koz_> MarcelineVQ: That's not very nice.
13:15:44 <merijn> In generaly I don't understand why the hell everyone follows the example of using () and <> for making options/etc with optparse
13:15:59 <merijn> We have a perfectly adequate method for combining lots of Monoid values...freaking mconcat
13:17:00 <koz_> Are there any good optparse-applicative alternatives (no pun intended)?
13:17:03 <iqubic> :t foldr
13:17:05 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
13:17:10 <dmj`> foldMap is underrated
13:17:14 <koz_> dmj`: Agreed.
13:17:15 <iqubic> foldMap is great.
13:17:16 <merijn> dmj`: That too
13:17:30 <merijn> dmj`: I'm using foldMap quite a bit in my current commandline parser rewrite
13:17:35 <merijn> koz_: IMO, no
13:17:40 <merijn> koz_: Not even in other languages
13:17:46 <koz_> merijn: Hmm, OK.
13:17:53 <merijn> koz_: Although, of course it depends on how you define "good"
13:18:06 <dmj`> deriving Monoid via (Sum Int), then just foldMap it, so good
13:18:18 <iqubic> mconcat = foldr (<>) mempty -- right?
13:18:31 <iqubic> I know that might be slow for some monoids, but it should work.
13:18:34 <koz_> iqubic: mconcat = fold. :P
13:18:35 <koz_> :t fold
13:18:37 <lambdabot> (Foldable t, Monoid m) => t m -> m
13:18:48 <merijn> koz_: I think optparse has *a bit* more boilerplate when writing trivial commandline parsers (compared to some of the others), but it makes up for that by being more future proof (i.e. it has room for expansions/growth of your parser)
13:19:00 * hackage sequence-formats 1.4.0.1 - A package with basic parsing utilities for several Bioinformatic data formats.  https://hackage.haskell.org/package/sequence-formats-1.4.0.1 (stephan_schiffels)
13:19:12 <iqubic> koz_: I feel like my definition of mconcat is equally valid. Is it not?
13:19:18 <merijn> iqubic: It is
13:19:20 <koz_> iqubic: Yes, it is.
13:19:22 <iqubic> Cool.
13:19:35 <koz_> In fact, fold is definable as foldr (<>) mempty.
13:19:37 <koz_> Also as foldMap id.
13:20:08 <iqubic> foldMap id????
13:20:12 <iqubic> How?!?!
13:20:12 <koz_> Yeah.
13:20:13 <merijn> :t foldMap
13:20:13 <koz_> Why not.
13:20:14 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
13:20:27 <merijn> :t foldMap `asAppliedTo` id
13:20:28 <lambdabot> (Foldable t, Monoid m) => (m -> m) -> t m -> m
13:20:32 <merijn> :t foldMap id
13:20:34 <lambdabot> (Foldable t, Monoid m) => t m -> m
13:20:39 <koz_> merijn beat me to it.
13:20:41 <iqubic> :t `asAppliedTo`
13:20:43 <lambdabot> error: parse error on input â€˜`â€™
13:20:49 <koz_> :t asAppliedTo
13:20:51 <lambdabot> (a -> b) -> a -> a -> b
13:20:56 <merijn> iqubic: asAppliedTo = const with a funky type signature :p
13:20:59 <iqubic> Oh.  see.
13:21:11 <koz_> :t foldr `asAppliedTo` (+)
13:21:13 <lambdabot> (Foldable t, Num b) => (b -> b -> b) -> b -> t b -> b
13:21:18 <ski> @src asAppliedTo
13:21:19 <lambdabot> f `asAppliedTo` a = f where _ = f a
13:21:19 <lambdabot> infixl 0 `asAppliedTo`
13:21:25 <koz_> Such use, very explain.
13:21:26 <ski> @src asTypeIn
13:21:27 <lambdabot> a `asTypeIn` f = a where _ = f a
13:21:27 <lambdabot> infixl 0 `asTypeIn`
13:23:01 <koz_> ski: Where are those two defined?
13:23:15 <ski> @type map `asTypeIn` \map -> map intToDigit [2,3,5,7]
13:23:17 <lambdabot> (Int -> Char) -> [Int] -> [Char]
13:23:20 <ski> koz_ : lambdabot
13:23:26 <koz_> Ah, OK.
13:24:08 <ski> i invented `asTypeIn', some years ago, and someone else invented `asAppliedTo', iirc. then someone added them into lambdabot
13:24:27 <MarcelineVQ> asTypeOf?
13:24:36 <ski> that's a standard one
13:24:44 <ski> @type asTypeOf
13:24:46 <lambdabot> a -> a -> a
13:24:48 <geekosaur> in Prelude even, iirc
13:24:50 <ski> @src asTypeOf
13:24:50 <lambdabot> asTypeOf = const
13:25:11 <geekosaur> it's the old way of doing ScopedTypeVariables, sort of
13:25:26 <ski> they (the previous two) are occasionally useful, when showing the type of something, in a particular context, in here
13:32:00 * hackage entropy 0.4.1.5 - A platform independent entropy source  https://hackage.haskell.org/package/entropy-0.4.1.5 (ThomasDuBuisson)
13:46:01 <iqubic`> Just doing some testing, don't mind me.
13:55:04 <jamestmartin> Is there any way to make `toEnum'` compile without distributing `Exists` over every case (as I did in `toEnum''`)? https://gist.github.com/jamestmartin/acba7fbabf3a22af17343bc1db7f5521
13:58:55 <pavonia> I guess not, those are different Exists
14:01:49 <jamestmartin> oh yeah, I guess they are
14:02:04 <pigmej[m]> ok, folks, I'm giving up sadly on Haskell, I've lost motivation to do anything usefull with it. Thank you guys for your support. It was really great.
14:02:41 <jamestmartin> it just seems like it really ought to work
14:02:45 <jgt> see you again next year :)
14:02:53 <monochrom> I did that to Perl two decades ago.
14:03:08 <monochrom> Except s/sadly/gladly/
14:03:47 <jamestmartin> it'd work if a case statement could return an existential type, but the entire point of `Exists` is to work around Haskell not supporting existential types
14:03:57 <jamestmartin> er, existential quantification?
14:04:12 <pigmej[m]> jgt maybe when tooling + docs will be better ;-)
14:04:25 <jamestmartin> is there any GHC extension that would let me return an `exists b. SBool b` directly without the wrapper?
14:05:01 <monochrom> Ah, no, GHC's existential type requires defining your own type and data constructor.
14:06:02 <EvanR> there's impredicative types...
14:06:29 <monochrom> No, impredicativity is unimplemented in GHC.
14:06:38 <EvanR> really
14:06:43 <monochrom> Yeah.
14:06:50 <EvanR> what happens when you enable it
14:07:01 <jgt> pigmej[m]: I remember giving up Haskell a couple of times. It definitely isn't as hand-holdy as Ruby, for example
14:07:10 <monochrom> Nothing apart from the most trivial examples.
14:07:10 <jamestmartin> an error occurs telling you that GHC doesn't support impredicative types
14:07:21 <jgt> but then my needs changed â€” I no longer found Ruby an appropriate tool for building a software business
14:07:23 <EvanR> interesting
14:07:28 <iqubic> I just learned about custom type errors, and it's the coolest thing ever.
14:07:28 <pigmej[m]> jgt I don't know Ruby :D
14:07:46 <pigmej[m]> The issue that I'm having with haskell is really crappy documentation
14:07:52 <jgt> pigmej[m]: in my case, my complaints weren't specific to Ruby, it just happened to be the dynamic scripting language that I was familiar with
14:07:53 <vaibhavsagar> it would be pretty cool if GHCi had syntax highlighting
14:07:58 <pigmej[m]> I mean like really crappy, it's pretty much non existing
14:08:06 <pigmej[m]> even if it exists its usually written in cryptic form
14:08:29 <monochrom> Impredicativity in GHC is going the way of FFI's "jvm" calling convention. It has a provision in the docs, the docs promising "future work", and after two decades it still hasn't happened. Don't hold your breath.
14:08:30 <jgt> pigmej[m]: that's not always the case; I've been pretty happy with most of the libraries I use
14:08:57 <pigmej[m]> I can imagine, I'm judging from n00b position
14:09:15 <jgt> pigmej[m]: hey, it takes time. Maybe you'll come back to it.
14:09:47 <dmj`> pigmej[m]: you're not giving up man
14:09:52 <dmj`> pigmej[m]: you're sticking with it
14:10:13 <dmj`> pigmej[m]: nothing is perfect, but the alternatives are far worse
14:10:31 <dmj`> pigmej[m]: it's the only language that lets you refactor well.
14:10:38 <monochrom> The libraries I use have non-crappy docs. But perhaps the causality is the other direction.
14:10:44 <koz_> When I'm definiting an instance of a type class for the purposes of a default (for another type class) using Generics, I've defined instances for U1, V1, K1, :+:, :*:, and M1. Should I have any others?
14:11:02 <pigmej[m]> you know, a simple task that I had to do, "12.45" to decimal send via json, it took me shitload of time to write something that kinda works, and then I've read that there is some Data.Scientific that somehow maybe works with aeson, then I've spend some minutes reading it's doc and well... nothing obvious
14:11:11 <pigmej[m]> monochrom I'm looking from n00b perspective
14:11:20 <monochrom> If you uniformly randomly pick a library on hackage, yes you have very high probability you run into crappy or non-existent doc.  But I don't do random.
14:11:23 <EvanR> Scientific is pretty cool
14:11:32 <EvanR> is that was aeson uses now?
14:11:42 <pigmej[m]> usually there is 0 examples, 0 "guides" 0 nothing, mostly list of methods
14:11:46 <dmwit> merijn: For example, having sane help output with subcommands. ;-)
14:11:54 <jamestmartin> well, that's disappointing
14:11:56 <pigmej[m]> EvanR idk, I wasn't able to glue something usefull with it :)
14:12:00 <jamestmartin> at least I have an answer now
14:12:15 <monochrom> Well I was a "n00b" once, and docs were more incomplete back then.
14:12:18 <jgt> pigmej[m]: did you read this? It's really good: https://artyom.me/aeson
14:12:24 <EvanR> yes well, i like that better than the standard ruby situation where you have a 5 line "tutorial" which does the simplest possible thing, and no other docs, including no method list
14:12:35 <pigmej[m]> jgt I did ;)
14:12:41 <EvanR> and the code is indecipherable
14:12:50 <monochrom> And hackage didn't exist, but perhaps that was a blessing.
14:13:24 <pigmej[m]> monochrom as a n00b I don't have a skills to judge what package is good or what is bad
14:13:32 <pigmej[m]> i have to kinda "guess" or try/fail/repeat thingy
14:14:04 <pigmej[m]> and internet is full of bullshit about haskell, tons of totally broken solutions that usually lead to dead-ends
14:14:44 <EvanR> there needs to be more bullshit about more languages
14:15:00 <dmwit> EvanR: aeson has been using Scientific for 5 years. =P
14:15:22 <EvanR> thats what i thought, so using it to send "12.45" shouldn't be so bar
14:15:30 <monochrom> EvanR: Don't worry, they exist. I know because I taught a C course and I certainly saw students using internet bullshit solutions for my C assignments.
14:15:53 <EvanR> ok good
14:16:00 <pigmej[m]> Send "12.45" and then make it a "number" that you can divide or compare with "23.45"
14:16:10 <pigmej[m]> monochrom well yeah but at least I can judge C solutions better than haskell ones
14:16:17 <monochrom> Yes OK aeson assumes intermediate-level ideas such as Applicative.
14:16:24 <pigmej[m]> take a rust for example, or nim or go
14:16:37 <koz_> I teach C programming right now, and I can 100% confirm what monochrom just said.
14:16:38 <monochrom> This is why I keep saying that dive-in projects are utterly disastrous for Haskell.
14:16:42 <koz_> To a _depressing_ level.
14:16:49 <jgt> monochrom: I still don't quite grok applicative, and yet I'm a pretty heavy aeson user
14:17:04 <iqubic> Applicative is kinda important to learn.
14:17:15 <jgt> monochrom: and I would not still be doing Haskell if it weren't for dive-in projects
14:17:37 <jgt> like, I'm sorry, but I can't maintain interest in a programming language unless I can do something with it
14:17:50 <jgt> and by do something I mean build software that puts food on the table
14:18:11 <jgt> and now it's the case that Haskell does this for me better than anything else I've used
14:18:25 <jgt> iqubic: not saying it isn't important to learn
14:18:50 <jim_p> Hi there! Haskell newb looking for a little help with haskell install here. I've followed some instructions for a haskell course I'm attending next week to install haskell via https://www.haskell.org/ghcup/ but after running this script and trying to run ghc from the terminal I get command not found... 
14:19:05 <iqubic> What OS are you using?
14:19:08 <jim_p> osx
14:19:35 <pigmej[m]> check the path, and probably source the ghcup env file
14:19:38 <glguy> jim_p: Does this command work? ~/.ghcup/bin/ghc --version
14:19:41 <pigmej[m]> afair it prints you it on the screen at the end of the setup
14:19:51 <c_wraith> ghcup uses the wrong config file on os x
14:19:58 <monochrom> jgt, when that happens (a Haskell library built on a mathematical abstraction), it comes down to two kinds of personality.  One kind is like you and me, we don't ask "but what, really [sic], is Applicative", we let go of intuition and just use according to rules. That's why we are OK.  But the other kind of people who not start doing anything until someone answers "what, really [sic], are numbers?"
14:20:16 <glguy> c_wraith: like the wrong .bash_* file?
14:20:21 <c_wraith> yes
14:20:41 <jim_p> glguy, pigmej[m] ~/.ghcup/bin/ghc --version works
14:20:57 <monochrom> The irony is that, like Chess, the way to understand is precisely to stop asking to understand and start playing.
14:21:06 <jim_p> So I probalbly need to fix my path in .bashrc?
14:21:16 <pigmej[m]> yup :)
14:21:34 <c_wraith> you should source ./.ghcup/env
14:21:52 <c_wraith> that takes care of all the appropriate path entries 
14:21:56 <glguy> c_wraith: What generates that file? I don't have one.
14:21:58 <monochrom> But Applicative is not that easy either, even if you only look forward to using.  Wait for crestfallen to show up next time, you'll see... >:)
14:22:14 <pigmej[m]> the other issue that I have with HS is terribly huge binaries (ok I can pack and strip them but still)
14:22:18 <EvanR> now i'm getting side tracked into what are numbers really
14:22:24 <c_wraith> glguy: I think in my case it was generated by rvm. it's not there by default 
14:22:38 <EvanR> unask that question immediately
14:22:53 <c_wraith> glguy: but its presence is enough to confuse ghcup 
14:23:19 <glguy> What's rvm?
14:23:29 <pigmej[m]> the language tooling is also pretty awkward and adding stack vs cabal vs cabal2 vs cabal3 doesn't make stuff easier
14:23:34 <c_wraith> ruby environment manager
14:23:38 <monochrom> (Last time they were like "I'm trying to generate two random numbers and put them in a list, I'm trying 'random <*> random', why is it wrong and how to fix it?  Do I need concat?"
14:24:02 <pigmej[m]> then you find that "recommended" LSP does not even work with recent cabal etc etc
14:24:15 <glguy> What's LSP?
14:24:16 <monochrom> Oh I made my life easier by ignoring stack. >:)
14:24:26 <petercommand> language server protocol?
14:24:29 <pigmej[m]> monochrom I did it too
14:24:46 <pigmej[m]> but then cabal3  was released and stuff became confusing
14:24:52 <monochrom> But cabal isn't easy either. Leaky abstraction.
14:25:09 <monochrom> OK currently I'm avoiding v3 too.
14:25:16 <pigmej[m]> at least it works :D
14:25:16 <iqubic> The current state of haskell build tools is a bit of a mess.
14:25:22 <iqubic> I use Nix + Cabal.
14:25:27 <c_wraith> the fewer ide-like tools you use, the easier Haskell is. 
14:25:32 <iqubic> I know.
14:25:45 <pigmej[m]> oh yeah.. how could I forgot about nix in my sentences.. :D
14:25:57 <iqubic> That's why I use Emacs, and Dante as the way I interact with Haskell.
14:26:09 <pigmej[m]> yeah Dante is nice :)
14:26:18 <petercommand> iqubic: can you specify ghc version with Nix + Cabal?
14:26:19 <iqubic> It's excellent.
14:26:20 <glguy> between ghcid and cabal-install-3 I'm feeling pretty good about builds
14:26:21 <pigmej[m]> I'm using it too because it just works (usually)
14:26:21 <jim_p> pigmej[m], glguy, @c_w
14:26:29 <iqubic> petercommand: Yes. Yes you can.
14:26:42 <iqubic> I don't recall how, but I know you can specify GHC version.
14:26:53 <jim_p> pigmej[m], glguy, c_wraith thanks! That sorted it!
14:27:00 <petercommand> iqubic: what tools did you use to use cabal with nix?
14:27:28 <iqubic> cabal2nix is the main tool to integrate the two tools.
14:27:49 <petercommand> ah
14:27:51 <monochrom> Actually I should look into Dante, now that haskell-mode looks dead.
14:28:14 <petercommand> iqubic: I've only tried nix + stack
14:28:29 <monochrom> There is also haskell mode next generation but I deplore how it's cabal-only.  But maybe I should contribute and help it ghci-happy.
14:28:31 <pigmej[m]> monochrom https://gitlab.com/tseenshe/haskell-tng.el  that effort is promising
14:28:38 <monochrom> Yeah
14:28:42 <pigmej[m]> oh yeah so you know it already :)
14:29:24 <jgt> pigmej[m]: I also just use Nix. I'm not interested in tooling; I just want it to work good. Nix has its own learning curve, but I'm pleased with what it does for me.
14:29:29 <iqubic> I'm just going to stick to Dante.
14:29:47 <iqubic> https://github.com/jyp/dante
14:29:53 <petercommand> when I tried nix + stack, because some versions of ghc are missing in nixpkgs, I had to manually change the resolver of a package I was trying to compile with stack
14:31:18 <petercommand> which was a little bit annoying
14:35:07 <monochrom> \âˆ©/ BlockArguments allows me to write "withCurrentDirectory mydir case foo of"
14:35:38 <petercommand> jgt: you said you are not interested in tooling, and yet you tried nix :D
14:35:59 <monochrom> Perhaps nix is versioning rather than tooling.
14:36:29 <koz_> With Hedgehog, if I do something like 'checkParallel $ Group "Foo" [...]' inside a Main which I run with cabal new-test, I get very uninformative output if everything works fine. Is there a way to make this output a bit wordier?
14:36:51 <jgt> petercommand: yeah, but Nix also takes care of all the other system dependencies, and also provisions and deploys my machines on AWS
14:36:59 <dmwit> % const () \x -> x
14:37:00 <yahb> dmwit: ; <interactive>:120:10: error:; Unexpected lambda expression in function application:; \ x -> x; You could write it with parentheses; Or perhaps you meant to enable BlockArguments?
14:37:05 <dmwit> % :set -XBlockArguments
14:37:06 <yahb> dmwit: 
14:37:09 <dmwit> % const () \x -> x
14:37:10 <yahb> dmwit: ()
14:37:20 <pigmej[m]> also I'm pretty disapointed with runtime haskell errors ;/
14:37:26 <jgt> so rather than stack + terraform + blah + blah + blah, it's _just_ Nix
14:37:28 <iqubic> What?!?! What does Block Arguments?
14:37:41 <iqubic> pigmej[m]: When do you ever run into those?
14:37:44 <dmwit> monochrom: ^ no block exists there. BlockArguments has quite a name. =P
14:38:00 <pigmej[m]> iqubic simple 2/3 :: Scientific
14:38:11 <petercommand> jgt: ah
14:38:13 <pigmej[m]> it will compile fine, but produce ```fromRational has been applied to a repeating decimal which can't be represented as a Scientific! It's better to avoid performing fractional operations on Scientifics and convert them to other fractional types like Double as early as possible.```
14:38:14 <jim_p> If you guys are able to help with stack installation as well? ... I had stack installed already so I ran stack upgrade... but now when I try stack new or stack init I get an error "AesonException "Error in $['system-info']: key \"os\" not present"" google isn't much help?
14:38:16 <iqubic> That's not a run time error, is it?
14:38:35 * pigmej[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/HVPYIDSVoBLbtAmKxTfIynDd >
14:38:39 <pigmej[m]> it is runtime error :)
14:38:44 <iqubic> I see.
14:39:07 <iqubic> Scientific should turn that into a custom type error.
14:39:18 <iqubic> Using GHC.TypeLits
14:39:45 <MarcelineVQ> iqubic: Are you sure it's not?
14:39:50 <monochrom> Huh? GHC.TypeLits has type-level fractions? Or are you making it up?
14:39:51 <sm[m]> jim_p: is your platform one that the stack website says is supported ?
14:40:10 <iqubic> No. I'm saying that GHC.TypeLits has TypeError.
14:40:18 <jgt> sm[m]: I think he said earlier he's on OSX/MacOS
14:40:25 <jim_p> correct osx
14:40:27 <EvanR> pigmej[m]: yeah, converting 1/3 to scientific is like dividing by zero
14:40:35 <EvanR> it makes sense
14:40:41 <pigmej[m]> EvanR sure it is :)
14:40:51 <pigmej[m]> BUT in that exact case haskell knew it during compilation
14:40:58 <EvanR> really
14:41:08 <sm[m]> next: searched the web and the stack issue tracker for that error message ?
14:41:13 <pigmej[m]> yeah I know nittpicking ;P
14:41:20 <dmwit> iqubic: It cannot be a type error: 1/2 :: Scientific is fine.
14:41:50 <monochrom> Everyone is assuming that everything can be checked at type-checking time.
14:41:52 <jim_p> sm[m] searched google, not the error tracker...
14:42:04 <sm[m]> I usually have good luck there
14:42:06 <dmwit> (And as far as the type-checker is concerned, there is *no* difference in any of the types involved in the two expressions (1/3 :: Scientific) and (1/2 :: Scientific).
14:42:09 <dmwit> )
14:42:17 <jgt> jim_p: I found this: https://www.reddit.com/r/haskellquestions/comments/coqsin/stack_repl_error/
14:42:18 <MarcelineVQ> jim_p: What is your stack version?
14:42:18 <iqubic> Ah. I see.
14:42:23 <iqubic> Makes sense.
14:42:30 <jgt> jim_p: which leads mee to ask: how did you install Stack?
14:42:48 <jgt> jim_p: did you install it from a package manager? Or from the script on the website?
14:42:54 <monochrom> Actually no. Everyone is assuming that checking what they want checked at type-checking time is someone else's responsibility and should have been done yesterday.
14:43:11 <monochrom> This is what's wrong with FOSS.
14:43:12 <jim_p> jgt yeah I foudn that too.. It was a while ago but I reckon I used that script. My brew list doesn't include slack so I didn't use that to install it
14:43:42 <jim_p> MarcelineVQ Version 1.3.2, Git revision 3f675146590da4f3edf768b89355f798229da2a5 (4395 commits) x86_64 hpack-0.15.0
14:43:55 <jgt> monochrom: not sure if the problem is with FOSS, or with humans, markets, incentives, etc
14:44:01 <MarcelineVQ> probably a good time to see if stack upgrade will fix your problem
14:44:09 <jgt> monochrom: I do agree with you though
14:44:16 <MarcelineVQ> note where it puts the upgraded bin since you'll need to have that on your path
14:44:16 <sm[m]> the brew package is called install haskell-stack, FWIW
14:44:22 <pigmej[m]> monochrom that's true
14:44:36 <EvanR> yeah, 1/0 is a value error not a type error
14:45:02 <EvanR> and the way it is ghc can't check for value errors before runtime
14:45:24 <koz_> What should I put into my cabal file so that my test binary gets built to run in parallel?
14:45:31 <koz_> I forget the options I need to pass for that all the time.
14:45:56 <monochrom> Does "ghc-options: -threaded" help?
14:45:56 <MarcelineVQ> koz_: -threaded -N but it depends on more than that
14:46:08 <jim_p> sm[m] thanks... no haskell-stack either
14:46:09 <MarcelineVQ> oh the -N is a rts-opt so that' not quite right
14:46:21 <koz_> monochrom: I guess that helps yes.
14:46:27 <sm[m]> jim_p: brew update; brew install haskell-stack ?
14:46:28 <MarcelineVQ> -threaded -rtsopts -with-rtsopts=-N
14:46:54 <koz_> MarcelineVQ: Thank yoU!
14:47:46 <MarcelineVQ> but remember that there's no automatic parallelisation, your test executable needs to be written to do that already
14:48:04 <MarcelineVQ> or use a lib which does that
14:48:08 <koz_> MarcelineVQ: Yeah, checkParallel is what makes this work, but obviously if I don't pass that in, it'll get compiled to serial code anyway.
14:48:15 <koz_> Hedgehog for the win. :)
14:48:28 <koz_> I just wish it could give me more informative output than what I'm getting right now.
14:48:34 <koz_> May not be Hedgehog's fault though.
14:50:50 <koz_> Namely, I'm not seeing the output it says I'd get from running in GHCi here: http://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog.html
14:51:08 <koz_> Instead, cabal new-test just says that everything passes in about two lines.
14:52:00 * hackage base-compat 0.11.0 - A compatibility layer for base  https://hackage.haskell.org/package/base-compat-0.11.0 (ryanglscott)
14:53:00 * hackage base-compat-batteries 0.11.0 - base-compat with extra batteries  https://hackage.haskell.org/package/base-compat-batteries-0.11.0 (ryanglscott)
14:54:00 * hackage profunctors 5.5 - Profunctors  https://hackage.haskell.org/package/profunctors-5.5 (ryanglscott)
14:55:42 <monochrom> You're kidding me.  BlockArguments supports this too:
14:55:46 <jim_p> looks like I had to add ~/.local/bin to my path thanks all!
14:55:53 <monochrom> % sin if True then 0 else 1
14:55:53 <yahb> monochrom: 0.0
14:56:10 <nshepperd2> even yahb is surprised
14:56:18 <monochrom> (It pays to actually read the GHC user's guide and see the actual modified grammar!)
14:57:09 <monochrom> Now I wonder about mixing it with MultiWayIf
14:57:48 <nshepperd2> BlockArgument makes me uncomfortable. I actually prefer withStuff $ do ...
14:58:12 <monochrom> % :set -XMultiWayIf
14:58:12 <yahb> monochrom: 
14:58:27 <glguy> BlockArgument is my default now
14:58:39 <monochrom> % sin if | 1>0 -> 0 | otherwise -> 1
14:58:39 <yahb> monochrom: 0.0
14:58:43 <monochrom> \âˆ©/
14:58:57 <monochrom> This is wild!
14:59:00 * hackage hadolint 1.17.2 - Dockerfile Linter JavaScript API  https://hackage.haskell.org/package/hadolint-1.17.2 (lorenzo)
14:59:18 <glguy> I like being able to write: for xs \x -> ...
14:59:23 <monochrom> nshepperd2: I hate $ that's why.
14:59:25 <glguy> the $ wasn't doing anything to improve readability
14:59:58 <monochrom> In fact $ is doing something to encourage beginners to stop thinking.
15:00:30 * hackage distributive 0.6.1 - Distributive functors -- Dual to Traversable  https://hackage.haskell.org/package/distributive-0.6.1 (ryanglscott)
15:00:36 <petercommand> monochrom: why is that?
15:01:05 <monochrom> I don't know why. I know it's true.
15:01:32 <nshepperd2> can you give an example
15:01:44 <monochrom> Beginners cargo-cult throwing in more $'s every time they think a syntax error or type error is caused by wrong parenthesizing.
15:02:17 <monochrom> Also they ask "what's the difference between $ and ."
15:02:28 <pigmej[m]> or `.` ;P
15:02:30 <pigmej[m]> or "arrow magic" :)
15:02:47 * pigmej[m] been there, done that
15:03:08 <monochrom> Ironically after throwing in more $'s they get more syntax errors and type errors.
15:03:10 <nshepperd2> how odd
15:03:22 <petercommand> lol
15:03:22 <EvanR> looking at papers on syntax... seems like @ would be more conventional than $ for "apply"
15:03:48 <EvanR> ((+) @ 2) @ 2
15:03:50 <nshepperd2> when I think a type error is caused by wrong *infix operator precedence* I add more parentheses
15:03:57 <koz_> EvanR: I wonder why it's @ that's the convention.
15:04:08 <koz_> It's not 'at-ply'.
15:04:09 <EvanR> @pp nodes
15:04:09 <lambdabot> nodes
15:04:12 <glguy> @ -> a -> apply?
15:04:23 <EvanR> wait what
15:04:28 <petercommand> % id @Int 1
15:04:29 <monochrom> Using real parentheses, perhaps redundantly, would have solved all their problems, but the whole point they ask is "but I'm getting rid of parentheses".
15:04:29 <yahb> petercommand: 1
15:04:44 <nshepperd2> koz_ "value of function **at** point x"
15:04:51 <koz_> nshepperd2: Oh, yeah, that makes sense.
15:04:59 <petercommand> % id @ Int
15:05:00 <yahb> petercommand: ; <interactive>:130:1: error:; * No instance for (Show (Int -> Int)) arising from a use of `print'; (maybe you haven't applied a function to enough arguments?); * In a stmt of an interactive GHCi command: print it
15:05:36 <petercommand> sadly, @ can only be used to apply type arguments
15:15:00 * hackage constraints 0.11.2 - Constraint manipulation  https://hackage.haskell.org/package/constraints-0.11.2 (ryanglscott)
15:16:45 <dansho> does anybody know how i can do normal operations with hmatrix-backprop? https://paste.ee/p/Hvihi
15:22:24 * koz_ rings the jle` bell.
15:22:54 <idrick> Is it possible to get the constructor for an type in it's instance? For example, I have `Instance FromJSON A where parseJSON = b`, I want to know the constructor A
15:22:57 <pigmej[m]> Ok. Given aeson and assuming that Iâ€™m sending â€œ12.34â€ and I want it in Scientific then what should be done I tried several and somehow ending with ugly errors
15:23:17 <pigmej[m]> (cant paste tjem now because iâ€™m trying to make my little boy asleep)
15:23:32 <c_wraith> idrick: which constructor is "the" constructor? 
15:27:36 <idrick> @c_wraith A, in the above example, say I have record `data A` and am declaring `Instance FromJSON A`, I want to know A in the instance (What I'm trying to do is use Constructor name in a generic parseJSON function. Easy to write the generic toJSON as the type is the input to genericToJSON, but genericFromJSON takes Value and returns Result a
15:27:36 <lambdabot> Unknown command, try @list
15:28:52 <c_wraith> idrick: my point is that types can have hundreds of different constructors. just saying "there would be a way to refer to the constructor" ignores a lot of complexity that's present in real code. 
15:29:46 <glguy> idrick: What do you want to do with "A"? Use it in type signatures?
15:34:37 <idrick> What I'm trying to do is write the inverse of `camelToJSON a = genericToJSON (aesonPrefix (getCamelConName a) camelCase) a`, where camelToJSON drops the record name as a prefix from fields. Where getConName is `getConName :: (Typeable a) => a -> String` `getConName = tyConName . typeRepTyCon . typeOf`
15:38:22 <c_wraith> oh. just pass the result (roughly) to getConName, instead of the argument. 
15:39:00 <c_wraith> yes, it's circular, but that's fine because typeOf doesn't actually use its argument 
15:40:52 <pigmej[m]> https://gist.github.com/pigmej/68607f2e201fa7257c5885cd1e98ed4b does that make sense guys ?
15:40:56 <idrick> Thanks! I'll give that a shot
15:41:29 <c_wraith> you need to be a bit careful to get the types right, but it can be done. 
15:57:17 <MarcelineVQ> pigmej[m]: I don't know what the edge cases are for using Read with Scientific, it might be a good idea to use aeson's Scientific parser instead, https://hackage.haskell.org/package/aeson-1.4.4.0/docs/Data-Aeson-Parser.html#v:scientific
15:58:00 <pigmej[m]> Iâ€™m passing values as strings
16:02:16 <pigmej[m]> MarcelineVQ regardless of all that, how can I use that parser in my case?
16:08:01 <jle`> petercommand: you can use evalBP to run a (BVar s a -> BVar s b) as a (a -> b)
16:08:32 <jle`> petercommand: but really if you aren't using any backprop stuff you could just import the normal functions from hmatrix
16:09:07 <EvanR> the fact that you are going through json string to send decimal numbers, which aeson also uses to represent numbers is ...
16:09:26 <jle`> petercommand: if you are playing around with using hmatrix-backprop though, you'll also have to use auto :: R 2 -> BVar s (R 2) to use it with #>
16:09:36 <jle`> the #> from hmatrix-backprop, at least
16:09:52 <dansho> jle` you talkin to me?
16:10:00 <petercommand> jle`: I think you pinged the wrong person :D
16:10:14 <jle`> ah, sorry, that was meant for dansho yes
16:10:17 <jle`> not sure how that happened :)
16:10:42 <dansho> ok thanks, i figured it was some kind of lifting that had to be done
16:11:05 <jle`> dansho: yeah, lifting to get into BVar, and 'unlifting' to run from BVar
16:11:10 <dansho> i'm trying to convert an hmatrix implementation with manual backprop with one with auto backprop and ran into trouble
16:11:47 <jle`> backprop really works around writing your thing as a function, so unless your thing is structured as a function it doesn't make tooo much sense
16:13:00 <jle`> dansho: if you paste your original implementation i can try to help convert it :)
16:13:25 <jle`> for the most part it's just ok to drop in #>, and 'auto' any "static" literals that aren't function arguments
16:13:33 <jle`> any constant values, that is
16:14:12 <MarcelineVQ> pigmej[m]: I'm not sure actually, allthough I see that FromJSON has a Scientific instance, is it reasonable to have braw be Scientific in your MarketSymbol datatype and let json do the conversion for you?
16:18:03 <dansho> jle`: actually the original didn't use static, so i've had rewrite it
16:18:45 <pigmej[m]> MarcelineVQ  but then I endup with json with number as number, I want it as number inside a string
16:19:01 <pigmej[m]> Because then iâ€™m kinda sure that noone will use it as float
16:19:40 <jle`> dansho: ah yeah, i suspected so :) in that case it should work sort of drop-in, just maybe you would have to change your type signatures to take BVar s a instead of a
16:20:30 * hackage lens 4.18 - Lenses, Folds and Traversals  https://hackage.haskell.org/package/lens-4.18 (ryanglscott)
16:23:18 <sshine> I'm unsure: HIE vs. Intero? I've just always used haskell-mode in Emacs.
16:24:35 <sshine> and is this a religious question I better not have asked?
16:27:54 <MarcelineVQ> sshine: No, but mostly it depends on what you can get working for you :> try hie and if it's trouble to get going try intero but also consider trying dante somewhere in there
16:28:49 <sshine> MarcelineVQ, I started with Intero, but I'm honestly having problems with it from the very beginning.
16:28:59 <MarcelineVQ> next to ghcid, which is all I use for haskell, dante is the most straightforward thing around
16:29:13 <sshine> shoot, I'm just going to try ghcid. this is getting annoying. :(
16:29:23 <MarcelineVQ> But it won't set up your environemnt for you like intro is supposed to
16:29:50 <MarcelineVQ> At least not generally, it is stack-aware though iirc
16:30:40 <sshine> Installing intero-0.1.39 for GHC 8.6.5 ... Invalid flag specification: - Package 'haskeline' not found (specified on command line)
16:31:23 <MarcelineVQ> weird, that's a ghc lib I thought, tried stack setup just before that?
16:32:15 <infinisil> HIE doesn't have support for cabal 3.0.0.0 or newstyle builds as of yet unfortunately, but other than that I can really recommend it, it's working pretty well for me recently
16:35:34 <MarcelineVQ> sshine: also where are you typing that and what did you type? ime things like intero and ghc-mod should be built per-project to make sure a compatible version in on your project's path, so in your project root you'd type: stack build intero
16:36:20 <sshine> MarcelineVQ, that was probably my mistake. I did it globally and crossed my fingers.
16:36:47 <sshine> MarcelineVQ, that was printed in an error buffer in Emacs after I opened a project-specific .hs file after having built a global intero.
16:38:25 <MarcelineVQ> installation instructions probably differ but my own experience found it best to make the tools for each project seperately
16:38:55 <sshine> for some strange reason it seems to work now, even though I only ran M-x package-list-package and picked it again. maybe it ran some `stack install` function for me in the project directory.
16:39:13 <sshine> MarcelineVQ, I'll keep that in mind next time. thanks!
16:40:04 <dansho> jle`: what is s supposed to be in a BVar?
16:40:09 <MarcelineVQ> even for the simple stuff I'll "stack build ghcid" per project and not have a global one, so if I go to type ghcid and it says, "not found" I know that I didn't build it for this project yet
16:40:31 <MarcelineVQ> And it's not going to load something expecting different ghc version or other lib issue
16:40:37 <sshine> MarcelineVQ, do you modify PATH for each project?
16:40:59 <jle`> dansho: a BVar keeps track of the backwards refernces used to construct it; it's an opaque type though
16:41:05 <MarcelineVQ> I don't, stack will put stuff you build in the path for you
16:41:13 <jle`> dansho: usually you'd write functions that "expect" a BVar, and do stuff with that BVar
16:41:27 <jle`> not sure if you have looked at https://backprop.jle.im ?
16:41:49 <MarcelineVQ> That it so say "stack build ghcid" will make ghcid visible to things like "stack exec ghcid"
16:41:54 <dansho> yeah, i haven't got the examples to run
16:42:26 <jle`> oh that sounds like an issue
16:43:28 <dansho> at least, not the getting started section, maybe i will be able to figure it out if i move on
16:43:50 <jle`> which example isn't running?
16:44:21 <jle`> the sample+results there are actually generated automatically from the library using the docs
16:45:00 * hackage criterion 1.5.6.0 - Robust, reliable performance measurement and analysis  https://hackage.haskell.org/package/criterion-1.5.6.0 (ryanglscott)
16:52:26 <jle`> i rather like criterion
16:59:22 <dansho> jle`: https://paste.ee/p/2HlJV
17:03:00 * hackage trifecta 2.1 - A modern parser combinator library with convenient diagnostics  https://hackage.haskell.org/package/trifecta-2.1 (ryanglscott)
17:05:07 <jle`> dansho: ah yeah, that's because you need runNet to take a BVar s Net and an BVar s (R 2)
17:05:14 <jle`> but right now it takes a Net and an (R 2)
17:05:33 <jle`> hm, i suppose this contradicts what i said earlier about being a drop-in replacement
17:06:25 <jle`> also i did misread your question earlier, i thought you asked "what is supposed to be in a BVar", but it looks like you actuallywrote "what is s supposed to be"; the s can be thought of as a context for backprop, maybe. the same way the s works for ST
17:06:54 <jle`> dansho: you want a runNet :: BVar s Net -> BVar s (R 2) -> BVar s (R 1)
17:07:02 <jle`> but right now as you wrote it, it is Net -> R 2 -> R 1
17:07:36 <jle`> so if you try to replace the type signature,it gets you closer to the source of the error
17:08:01 <jle`> the problem then is that you no longer can use weights1 :: Net -> L 2 2
17:08:22 <dansho> i just tried writing what is shown under https://backprop.jle.im/01-getting-started.html
17:08:32 <jle`> instead you need a way to access the weights2 field in a BVar s Net
17:08:39 <dansho> under 'Heterogenous Backprop'
17:09:09 <jle`> dansho: yeah, note i don't use the field accessor there
17:09:23 <jle`> instead of weights1 net, i do `net ^^. nWeights1`
17:10:00 * hackage lens-aeson 1.1 - Law-abiding lenses for aeson  https://hackage.haskell.org/package/lens-aeson-1.1 (ryanglscott)
17:10:36 <dansho> oh, ^^. is a lift of some sort?
17:10:59 <jle`> it's a way of lifting access, yeah
17:11:17 <jle`> the problem is that we can't use normal accessor functions, because we don't have a Net, but a BVar s Net 
17:11:37 <jle`> so if you have a lens into the field, you can use `myNet ^^. lensIntoWeight1`
17:12:22 <jle`> in the example we generated the lenses automatically with makeLenses ''Net
17:13:34 <argent0_> Is there another way of doing `case maybeValue of { Nothing -> []; Just v -> [v] }`?
17:13:47 <jle`> dansho: https://backprop.jle.im/03-manipulating-bvars.html has more examples of ways to do this
17:13:58 <jle`> argent0_: people usually use maybeToList
17:14:04 <jle`> but also you can just use toList
17:14:21 <argent0_> jle`: Sounds good, thanks
17:14:40 <jle`> np!
17:17:07 * josiah_sama sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/oDOrsRwVFPgSbRqyVqkVbOUp >
17:17:31 <josiah_sama> I'm not sure how to create a list of that type where `b` is different for each function in the list
17:18:38 <jle`> josiah_sama: the main usability issue is...what would you want to do with that list?
17:19:06 <jle`> the answer to that question will determine if this makes any sense, or also if there are any alternatives that let you do what you want to do in the end
17:19:22 <josiah_sama> I have a DataFrame in memory, and I need to run a computation on every column in that DataFrame
17:20:03 <dansho> eh, any idea what is going on with this? https://paste.ee/p/OrvB3
17:20:33 <josiah_sama> so this function takes the functions that would get passed to the `Data.Lens.Micro.view` function (I think that's the module it's in), hence the List of `view` functions
17:20:45 <dansho> source: https://paste.ee/p/05KnU
17:20:53 <jle`> dansho: ah, you need to enable TemplateHaskell
17:20:56 <jle`> i should probably add that to the docs
17:22:16 <jle`> josiah_sama: ah, then you can reduce your problem to just passing in a list of view functions, [Record rs -> b]
17:22:30 <jle`> your problem is still the same, but it's a little clearer to see now
17:22:41 <jle`> do you want to use a differetn function for each column of your frame?
17:23:07 <josiah_sama> no, same function
17:24:03 <josiah_sama> I'm writing the ID3 algorithm, which needs to be able to compute the information gained when the frame is split on each column to know which column yields the most information about predicting the target feature
17:24:20 <josiah_sama> so I'm basically running the informationGain function I wrote on every column in the Frame
17:24:49 <josiah_sama> and then taking the max of those results
17:24:53 <jle`> if it's the same function, how can they all return different b's ?
17:25:10 <josiah_sama> they don't return `b`s
17:25:17 <josiah_sama> `b` is the type of the data in the column
17:25:34 <jle`> so they all 'take' different b's ?
17:25:42 <josiah_sama> yes
17:25:50 <jle`> so if they are all the smae function, they must all take the same input value
17:25:59 <josiah_sama> no
17:26:09 <josiah_sama> sorry, I think I misunderstood you at first
17:26:16 <josiah_sama> teh functions in the list are all different
17:26:27 <josiah_sama> they are column accessor functions
17:26:28 <dansho> ok, i guess i'm back to the problem of how to actually declare my inputs: https://paste.ee/p/Z5Gy8
17:27:19 <jle`> dansho: ah okay, slightly different problem here, it's that you want the non-backprop versions of matrix/vector
17:27:31 <jle`> so the easiest way wouild be to import the normal module qualified
17:27:38 <jle`> and use the qualified functions
17:28:21 <jle`> josiah_sama: so what are you trying to do, exactly, by putting them all in a list?
17:28:39 <josiah_sama> I want this agorithm to be generic
17:29:02 <josiah_sama> so the way the Frames library works, is it uses TemplateHaskell to look at a CSV file and generate types for working with the data in that file
17:29:21 <dansho> jle`: excellent, it works
17:29:25 <jle`> dansho: nice :)
17:29:35 <josiah_sama> among the things generated are these Lens functions, one for each column of the data
17:30:01 <jle`> it generates those lens functions generically, right?
17:30:05 <jle`> so what do you gain from putting them in a list?
17:30:18 <josiah_sama> so I want to be able to put these column accessor functions into a list so that I can run a computation over every column in the DataFrame
17:30:31 <jle`> ah, a list won't help you run a computation over every column in a data frame
17:30:45 <jle`> are you thinking of, say, the first item in the list being the accessor for the first column
17:30:49 <josiah_sama> No, it does not
17:30:53 <jle`> the second item in the list being an accessor to the second column, etc. ?
17:31:20 <josiah_sama> the functions generated by TemplateHaskell each specifically access one particular column
17:31:56 <josiah_sama> jle`: yes, exactly
17:32:15 <josiah_sama> the first function in the list accesses the first column of the dataframe
17:33:05 <jle`> ah. yeah, in that case, a list can't really help you, because the only way you can access a list is in a monomorphic way
17:33:17 <jle`> for example, head :: [a] -> a; you only get the same type for any item you access in a list
17:33:30 <josiah_sama> yes, so that's my problem
17:33:34 <jle`> so even if you managed to put items of different types in a list, when you eventually extract them, it's all uniform
17:33:41 <josiah_sama> I'm not sure if there is a way to do this in Haskell
17:33:46 <jle`> one thing you can do is put all of these functions in a Record
17:33:58 <josiah_sama> and then iterate over the Record?
17:34:12 <jle`> yeah. well, in the end the easiest way to do this is based on what you eventually do
17:34:29 <josiah_sama> When I was looking through the Vinyl docs, it looked like there might be a function that enables you to iterate over a Record
17:34:37 <jle`> but if you really just wanted some sort of list-like container of accessor functions based on your data frame, you would use a Rec
17:34:41 <jle`> because it looks like Frames is based on Rec
17:34:55 <jle`> yeah, you can even 'zip' two rec's together if they have the same row types
17:35:06 <josiah_sama> yes, Frames uses Vinyl Recs under the hood
17:35:35 <josiah_sama> hmm, okay
17:35:44 <jle`> so if you really wanted to store your accessor functions in a way that works with your columns, you'd use a Rec
17:35:53 <josiah_sama> I guess I'll have to dig into the Vinyl documentation and figure out how to map over a Rec
17:36:13 <josiah_sama> that helps, thanks
17:36:21 <jle`> you can use rmap :: (forall a. f a -> g a) -> Rec f as -> Rec g as
17:36:28 <jle`> there's also rtraverse if you want to map an affectful function
17:36:34 <josiah_sama> ah, that's the one
17:36:42 <josiah_sama> I don't think the fxn is effectual
17:36:48 <jle`> if you define a 'wrapper' over your accessor functions, like data Accessor a = Accessor (MyType -> a)
17:37:12 <jle`> then `Rec Accessor '[Int, Bool, String]` would be a record containing MyType -> Int, MyType -> Bool, MyType -> String
17:37:18 <jle`> *newtype, not data
17:37:29 <jle`> that's how you can fit values of arbitrary 'shape' into your record
17:38:44 <jle`> and yeah i'd definitely also recommend storing those values as monomorphically as possible, so storing the accessors instead of the full lenses, if possible...if anything it helps the error messages look a little nicer to help you figure out what is going on :)
17:39:24 <jle`> but, i think at the high level, storing accessors can probably be bypassed
17:39:33 <jle`> there might be a way to just directly map over every row in your Rec
17:39:46 <jle`> every column in your data frame, i mean
17:39:47 <josiah_sama> I'm not sure, I can't think of another way to accomplish what I want
17:40:38 <jle`> for example you can directly fold over every item in a Rec, instead of folding over all of their accessors
17:40:47 <jle`> and a data frame looks to just be a bunch of Rec's
17:41:03 <josiah_sama> I can't do that
17:41:19 <josiah_sama> the computation aggregates the entire Frame each time
17:41:24 <koz_> Is there a way to inform cabal that a particular library I want can be found on a git repository instead of Hackage?
17:43:51 <josiah_sama> jle` in other words, the computation doesn't really run record by record, but more column by column
17:47:06 <jle`> hm, in that case i wonder if there is a way to turn a Frame of Records into a Record of Frames
17:47:48 <josiah_sama> the gist of the algorithm is compute the entropy for the entire Frame as it is, then split the Frame after the manner of a groupBy on one of the columns and compute the weighted sum of each of the entropy of each of those subgroupings of the Frame, and informationGain is then the originalEntropy minus the combined entropies of all of the grouped subFrames.  Do that for each column and keep the column which yields the
17:47:48 <josiah_sama> greatest informationGain.
17:48:15 <koz_> josiah_sama: Are you, by chance, doing something ID3-related?
17:48:37 <josiah_sama> that's exactly the algorithm I'm trying to implement with the Frames library
17:48:41 <koz_> Ah.
17:48:55 <josiah_sama> I'm studying ML right now, and I also need to learn Haskell
17:49:04 <josiah_sama> trying to kill 2 birds with 1 stone
17:49:19 <jle`> i did my id3 homework in haskell, fwiw. but not while also learning how to use Frames, heh
17:49:24 <jle`> this might be 3 birds with 1 stone ;)
17:49:27 <josiah_sama> also, really enjoying it even though I'm slowed down a bit trying to figure stuff like this out (I don't mind it)
17:50:23 <josiah_sama> well, I suppose if I really wanted to give-up, I could just settle for having an ID3 algorithm that's specific to my test dataset
17:50:36 <josiah_sama> buut, I'm pretty set on coming up with a generic solution
17:51:10 <jle`> ah, i found it again. i wrote it in 2015. fun to see how my haskell coding style has changed since then
17:51:13 <josiah_sama> the ultimate plan is to modify the Frames TH component so that it generates the Rec of Lens view functions for me
17:51:16 <jle`> or, not changed, i suppose heh
17:51:41 <josiah_sama> yah, I don't have that comparison avail. to me yet
17:52:06 <josiah_sama> I learned the bare basics of Haskell back in 2014, but what I built was completely different than what I'm building, now
17:52:40 <josiah_sama> no Lenses or Vinyl necessary, just your basic types that you can read about in any Haskell book
17:52:54 <jle`> ah, i exactly did put all of the accessors in a list
17:52:57 <jle`> haha
17:53:23 <josiah_sama> yah, I don't really see a way around that if you want to keep the algo. generic to the dataset being worked on
17:53:29 <josiah_sama> I think Frames is really rad
17:53:39 <josiah_sama> but the TH component is missing a few useful components
17:53:58 <jle`> the idea of Frames is really rad, but reading through the docs is a bit of a wild ride
17:54:05 <josiah_sama> it would actually be nice if a SQL-like DSL were implemented for working with Frames, much like they did for Pandas
17:55:36 <jle`> here's my Stringly typed implementation if you ever would want to take a look -- https://gist.github.com/mstksg/bfa4a1bcb0ca883eb1bd08dd4324737a
17:56:01 <jle`> yeah, there's something about pandas that's so instantly usable. i envy it
17:56:17 <jle`> maybe Frames is the same and i just have to go through a tutorial
17:56:26 <josiah_sama> I've got your repo open on one of my chrome tabs
17:56:27 <koz_> Is there a Monoid for Bool under && defined anyplace?
17:56:31 <josiah_sama> I'll have to get to it a bit later
17:56:53 <jle`> josiah_sama: yeah, it's And in Data.Monoid
17:57:02 <jle`> er sorry, that was for koz_ 
17:57:07 <koz_> jle`: Thanks, though I'm not josiah_sama. :P
17:57:29 <koz_> Uhh, are you sure? My GHC doesn't agree.
17:57:33 <jle`> josiah_sama: okay, so one thing you *can* do is store accessors in a list if all you care about is the fact that they can be used for equality
17:57:51 <jle`> koz_: ah, it's called All i think
17:58:28 <josiah_sama> well, I can't because that `b` type parameter colud be any of Bool, Int, Double, String, Date, ...
17:58:39 <koz_> Yep, that works.
17:58:48 <josiah_sama> I don't really think I can get around using a Rec
17:58:52 <jle`> josiah_sama: i mean, there's a way to store accessors 'polymorphically' if all you care about is the fact that tehy can be compared
17:59:07 <koz_> Also, I'm currently having to do something to the tune of 'fmap (foldMap All)' - is there a shorter way?
17:59:18 <koz_> (the effect is IO if that's of any consequence)
17:59:25 <jle`> you can create a type data CompAccess r = forall a. Ord a => CompAccess (r -> a)
17:59:41 <jle`> koz_: 'all', maybe?
17:59:47 <koz_> :t all
17:59:49 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
17:59:52 <koz_> Oh wow lol.
18:00:16 <jle`> josiah_sama: then if you have [CompAccess r], it's a list of ways to "get" an a out of r, but if you ever use it, you cannot use any property about 'a' other than the fact that it has an Ord instance
18:00:58 <jle`> this is called an existential data type, and it's not really a trick people use in normal Haskell. but it might be something that is helpful in the case of Frames, which uses some advanced techniques already
18:01:06 <josiah_sama> well, in that case, I would need Eq and Ord
18:01:12 <jle`> yeah, Ord implies Eq
18:01:13 <josiah_sama> but other than that, I don't care what the type of the data is
18:01:26 <josiah_sama> then that would work fine
18:01:27 <jle`> you might also want Show
18:01:56 <josiah_sama> the only thing I need to be able to do is split the frame by distinct values in a column
18:02:01 <jle`> to 'use' a `CompAccess r`, you'd pattern match on it to get the function (r -> a), but you aren't allowed to use the 'a' in any way other than using Ord/Eq methods on it.  And Show if you also add it on
18:02:03 <josiah_sama> all the requires is Eq
18:02:19 <jle`> all that requires is Eq yes, but Ord makes it a little more efficient :)
18:02:25 <jle`> then you can use Data.Map from containers
18:02:40 <josiah_sama> you want to see what I have so far?
18:02:43 <josiah_sama> maybe that will help
18:02:55 <jle`> sure :)
18:03:22 <koz_> :t fmap and . sequence
18:03:24 <lambdabot> (Traversable t, Monad f) => t (f Bool) -> f Bool
18:03:24 <jle`> also be aware that you might be running into a premature abstraction trap; unless you've already implemented your program normally and are just trying to abstract/generalize it
18:03:34 <koz_> Can I write this more concisely?
18:03:41 <jle`> josiah_sama: premature abstraction in Haskell is particularly dangerous because the sky is the limit for Haskell abstractions
18:03:55 <jle`> so it's easy to turn a one hour project into a one month project
18:03:56 <josiah_sama> https://github.com/josiah14-MachineLearning/ID3-and-Derivatives/blob/master/ID3/haskell/sequential/hid3-and-seq/src/Lib.hs#L122
18:04:33 <jle`> koz_: do you want to short-circuit on the first False ?
18:04:39 <koz_> jle`: Yes, ideally.
18:04:50 <jle`> koz_: then that implementation wouldn't help
18:05:01 <koz_> What would you suggest instead?
18:05:04 <josiah_sama> well, sure, but really, I'm just looking to create an ID3 function that can work on any dataset
18:05:14 <josiah_sama> I want it to ultimately act like a library function
18:05:29 <EvanR> define the API your ID3 function needs to work
18:05:45 <jle`> josiah_sama: it helps to start writing out the logic in a specific way, then generalize after you've gotten it to work.  but i'm not here to tell you want to do in the end, i suppose
18:05:46 <EvanR> make that API into a record of functions (or non-functions)
18:05:55 <josiah_sama> EvanR: well, that's what I'm trying to do
18:05:56 <EvanR> accept this record into your function
18:06:13 <EvanR> ok good : )
18:06:45 <josiah_sama> the function needs a few things.  First, the `Frame` that holds the dataset, then the `targetFeatureColumn` that we're trying to predict, and then the list of `descriptiveFeatureColumns`
18:07:19 <jle`> working generically with Frames is definitely late intermediate/advanced haskell, i think. it's no easy feat, and i think the usability of Frames might be designed for non-generic usage
18:07:34 <josiah_sama> the problem is the list of `descriptiveFeatureColumns`, because in Frames, those column accessors are functions whose types depend on the datatype of the column they access
18:07:43 <jle`> i'm not saying this to discourage you from doing it....just to help give context to the task in terms of a 'learning haskell' scale :)
18:07:45 <EvanR> Frame looks like a concrete type ctor, instead you can parameterize your API using an arbitrary f
18:07:56 <josiah_sama> no, on the contrary
18:07:59 <josiah_sama> I'm encouraged by it
18:08:09 <josiah_sama> sounds like by diving into this, I'll learn a lot about Haskell
18:08:16 <josiah_sama> and that's one of my goals with this project
18:08:36 <josiah_sama> I mean, I've learned a lot about Pipes, Lenses, Vinyl already
18:09:42 <koz_> jle`: What would you suggest I use instead of 'fmap and . sequence' if I wanna short-circuit out on the first False?
18:10:27 <koz_> foldM?
18:11:05 <jle`> findM id, if findM exists
18:11:46 <jle`> or also asum (guard . lift @MaybeT)
18:12:06 <jle`> % :t asum . ((guard =<<) . lift @MaybeT)
18:12:06 <yahb> jle`: ; <interactive>:1:29: error:; Not in scope: type constructor or class `MaybeT'; Perhaps you meant `Maybe' (imported from Prelude)
18:12:15 <jle`> % import Control.Monad.Trans.Maybe
18:12:16 <yahb> jle`: 
18:13:00 <jle`> but yeah probably findM (fmap not), maybe :)
18:13:21 <koz_> Or monad-loops' andM.
18:13:25 <sm[m]> and <$> sequence [...]. ?
18:13:46 <jle`> that doesn't short-circuit
18:13:55 <koz_> jle`: It does according to the docs.
18:13:58 <sm[m]> It seems to
18:14:13 <jle`> ah, referring to and <$> sequence [..]
18:14:46 <koz_> Oh, my bad.
18:14:57 <sm[m]> > and <$> sequence [ return $ trace â€œaâ€ True, return $ trace â€œbâ€ False, return $ trace â€œcâ€ True ]
18:14:59 <lambdabot>  <hint>:1:35: error: lexical error at character 'a'
18:15:04 <jle`> % and <$> sequence [False <$ putStr "hi", False <$ putStr "bye"]
18:15:04 <yahb> jle`: hibyeFalse
18:15:47 <jle`> :t runMaybeT . asum . fmap ((guard =<<) . lift)
18:15:49 <lambdabot> error:
18:15:49 <lambdabot>     Variable not in scope: runMaybeT :: t1 m () -> c
18:15:58 <jle`> @let import Control.Monad.Trans.Maybe
18:15:59 <lambdabot>  Defined.
18:16:09 <jle`> :t runMaybeT . asum . fmap ((guard =<<) . lift)
18:16:10 <lambdabot> (Foldable t, Monad m, Functor t) => t (m Bool) -> m (Maybe ())
18:16:13 <sm[m]> /msg lambdabot @ and <$> sequence [ return $ trace â€œaâ€ True, return $ trace â€œbâ€ False, return $ trace â€œcâ€ True ]
18:16:22 <jle`> that should do it but it's probably low on the readability scale heh
18:16:30 <jle`> sm[m]: it short-circuits evaluation, but not monadic effects :'(
18:16:55 <jle`> because 'fmap' only works "fater" all the effects are already decided/done
18:17:02 <jle`> *after
18:17:20 <sm[m]> jle`: interesting, ok
18:17:38 <jle`> it's actually a 'feature' of fmap, it's necessarily effects-preserving
18:18:43 <jle`> % let andM = runMaybeT . asum . fmap ((guard =<<) . lift)
18:18:44 <yahb> jle`: ; <interactive>:134:24: error:; * Ambiguous type variable `m0' arising from a use of `asum'; prevents the constraint `(Monad m0)' from being solved.; Relevant bindings include andM :: [m0 Bool] -> m0 (Maybe ()) (bound at <interactive>:134:5); Probable fix: use a type annotation to specify what `m0' should be.; These potential instances exist:; instance [safe] Monad Q.G
18:20:02 <Nolrai> So I have these two different functions that both have this sort of awkward structure of `do {a <- a'; c <- c'; return (a <+> b <+> c)}` do you think I should abstract it out or not? (paste = https://pastebin.com/xF9DEznZ )
18:21:59 <koz_> Could someone suggest a way to write this in a less repetitive way? https://gist.github.com/kozross/b032675a379b2ca6a180d557954be45b
18:22:22 <koz_> :t liftA3
18:22:24 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
18:22:45 <koz_> Or something analogous.
18:23:34 <koz_> Sorry, relevant line of thing that needs de-boilerplating: https://gist.github.com/kozross/b032675a379b2ca6a180d557954be45b#file-main-hs-L47
18:24:07 <jle`> koz_: you can make a function that generates each item of the list based on the type, maybe. since you can get "()"/"Bool"/etc. from showing a typeRep
18:24:31 <koz_> I can't fmap @ sadly.
18:24:43 <jle`> then something like Group "End" [checkEnd @(), checkEnd @Bool, checkEnd @Ordering]
18:25:20 <koz_> That still forces me to rewrite this for each Group.
18:25:35 <koz_> Like, ideally, what I'd like is a list of types which I can then just fmap over repeatedly.
18:25:42 <koz_> (well, traverse, but who's counting?)
18:26:43 <jle`> hm, in that case you can use a [SomeTypeRep] i think. but it's kind of weird that SomeTypeRep is polymorphic on k
18:26:56 <koz_> Where's SomeTypeRep from?
18:27:08 <jle`> base, Type.Reflection
18:27:46 <jle`> then you can traverse (\(SomeTypeRep t) -> checkEnd t)
18:27:52 <jle`> if checkEnd is parameterized on a `TypeRep a`
18:28:12 <jle`> you might need to guard on k ~ Type though
18:29:03 <jle`> i wish there was a version with k as a parameter
18:29:10 <koz_> jle`: After seeing that, this is what I thought: https://imgflip.com/i/39wnk2
18:29:33 <jle`> heh, nice picture :)
18:29:36 <jle`> it actually kind of is
18:29:49 <jle`> s/kind of//
18:30:02 <koz_> I dunno why I thought of _this_ meme specifically.
18:30:06 <koz_> But it seemed appropriate.
18:30:13 <jle`> since your list of types at runtime determines what code/logic you dispatch
18:30:55 <koz_> Dependent types: helping de-boilerplate property-based testing since 2019.
18:31:47 <jle`> alternatively you can do this using typeclasses in a sort of silly way
18:31:55 <jle`> but i like values instead of typeclasses normally
18:31:58 <koz_> Me too.
18:32:05 <koz_> Especially if it involves some kind of lawless typeclass.
18:32:12 <koz_> In the style of HasInt.
18:33:09 <jle`> yeah the silly way would be to make a typeclass for every test
18:33:19 <koz_> Oh dear sweet Azathoth no.
18:33:33 <koz_> Give me SomeTypeRep over that any day.
18:33:49 <jle`> class BijectivityTests (ks :: [Type]) where bijectivityTests :: [IO ()]  -- or whatever the input to Group is
18:33:59 <jle`> instance BijectivityTests '[] where bijectivityTests = []
18:34:48 <jle`> instance (Cardinality a n, Show a, Eq a, BijectivityTests as) => BijectivityTests (a ': as) where bijectivityTests = isBijection @a : bijectivityTests @as
18:35:16 <jle`> checkBijectivity = checkParallel $ Group "Bijectivity" (bijectivtyTests @'[Int, Bool, String])
18:35:29 <jle`> (where '[Int, Bool, String] can be type-aliased and re-used
18:35:29 <MarcelineVQ> koz_: is this some sort of christian magic?
18:35:31 <jle`> yeah don't do this lol
18:35:47 <koz_> jle`: I GOT JUST THE THING FOR YOU
18:36:16 <jle`> it's horrifying to imagine but it's technically possible
18:36:30 <jle`> it's the kind of solution i think would be tempting to think is very clever
18:36:47 <koz_> jle`: https://imgflip.com/i/39wo41
18:37:03 <koz_> Wait, hold on, that's a bit unsightly.
18:37:25 <jle`> the unsightliness adds to it i think
18:37:30 <koz_> This is better: https://imgflip.com/i/39wo69
18:37:37 <koz_> I wish what you just posted fitted into that meme.
18:37:46 <koz_> Since this is like... exactly the thought I had.
18:38:01 <jle`> does imgflip do sequential id's
18:38:07 <jle`> that's sort of troubling
18:38:13 <koz_> jle`: Possibly.
18:38:15 <koz_> I'm not sure.
18:38:44 <jle`> yeah, i just tried 39wo68 and got a valid image
18:38:52 <nshepperd_> make a list of some kind of existential GADT
18:39:00 <MarcelineVQ> You two are going to get silly in here when quantified constraints comes along.
18:39:14 <jle`> nshepperd_: yeah, that's pretty much what SomeTypeRep is
18:39:27 <koz_> MarcelineVQ: ... they're not here already?
18:39:29 <nshepperd_> with the constraints you need added
18:39:33 <nshepperd_> data T where { T :: forall (a :: Type) (n :: Nat). (Cardinality a n, Show a, Eq a, 1 <= n) => Proxy a -> Proxy t -> T }
18:39:55 <nshepperd_> just make a big ol list of those, and a mapper function to apply your function at each of the types in the list
18:40:13 <nshepperd_> oh, (Typeable a) too, so you can print the type
18:40:54 <MarcelineVQ> Oh so they are :>
18:41:28 <jle`> oh ah yeah, you do need to include the constraints in the type. so SomeTypeRep won't work
18:42:04 <koz_> So will I have to do something like what nshepperd_ is suggesting?
18:42:32 <koz_> SomeFinitaryRep. :P
18:43:02 <koz_> And what's the t proxy for?
18:49:02 <nshepperd_> whoops, should be Proxy n
18:49:14 <koz_> Ah, so you keep both the type and its cardinality.
18:50:03 <nshepperd_> the Proxys are just something so you can get the type in scope in your mapper function
18:50:21 <koz_> nshepperd_: Let me try that real quick.
18:50:28 <nshepperd_> you probably don't need the Proxy n actually, since I assume Cardinality has a fundep from a -> n?
18:50:33 <koz_> Correct./
18:50:43 <koz_> (it turns inference into custard otherwise)
18:51:12 <nshepperd_> i love custard, but not in my computers
18:51:23 <koz_> nshepperd_: Likewise x 2.
19:04:35 <Guest20> Is it ok to have: `F :: (s ~ s, Bla a) => a -> F s`?
19:04:44 <koz_> nshepperd_ and jle`: I got this far, but I am unsure where to go from here: https://gist.github.com/kozross/489fa6d7ac16025aef7877a6d380289c#file-main-hs-L59
19:04:54 <Guest20> I mean the constraint `s ~ s` to facilitate TypeApplications.
19:05:19 <Guest20> Then I'll be able to do: `F @"This is what i want s to be" a`
19:14:14 <nshepperd_> koz_: 'go (SomeFinitaryRep p) = testFunc p' might even work
19:14:31 <nshepperd_> if you update your test functions to accept a proxy as the first argument
19:14:39 <koz_> Ah, I see.
19:15:21 <koz_> Something something rigid Skolem.
19:22:30 <koz_> nshepperd_: Latest attempt: https://gist.github.com/kozross/489fa6d7ac16025aef7877a6d380289c#file-main-hs-L60
19:22:40 <koz_> (error message is below)
19:23:04 <nshepperd_> maybe give your constructTest function a type
19:23:13 <koz_> Uhh, I did?
19:23:31 <nshepperd_> oh, i was looking at the old one
19:24:05 <koz_> Wait, does the type of testFunc need to be like
19:24:11 <koz_> (forall a . Proxy a -> ...) ?
19:24:28 <nshepperd_> it needs to be rank2 yeah
19:24:34 <koz_> Yeah, I get why.
19:24:48 <koz_> I can scarcely believe it, but _I get why_.
19:26:12 <nshepperd_> first argument should be like 'forall (a :: Type) (n :: Nat) . (Cardinality a n, Show a, Eq a, 1 <= n) => Proxy a -> Property'
19:26:24 <nshepperd_> basically the whole type of your test function
19:26:52 <koz_> Yeah, I get why. The original type said 'caller can specify a'. _This_ type says 'you better be able to handle any damn Proxy and you get no say in it'.,
19:27:25 <nshepperd_> oh and then... go (SomeFinitaryRep p) = (show (typeRep p), testFunc p)
19:28:16 <nshepperd_> oh no ignore that last line
19:28:35 <koz_> Wait why?
19:28:38 <nshepperd_> the testFunc should probably produce the test name itself, yeah. using typeable
19:28:42 <koz_> OK.
19:35:18 <koz_> nshepperd_: OK, now I've gotten this far, but it's still not convinced: https://gist.github.com/kozross/489fa6d7ac16025aef7877a6d380289c#file-main-hs-L62
19:36:59 <nshepperd_> needs (n :: Nat) in the inner forall too
19:37:00 <koz_> Does that mean I have to proxy _both_?
19:37:05 <koz_> Oh whoops lol.
19:37:53 <jle`> Guest20: people would probably write forall s a. Blah a => a -> F s
19:38:07 <jle`> you can control the order of type applications by your foralling
19:38:16 <koz_> nshepperd_: That did it, thanks!
19:38:24 <Guest20> I have no explicit for alls etc. But thats good.
19:38:28 <koz_> Now I can boil out even more boilerplate.
19:38:37 <Guest20> jle`: thanks!
19:38:55 <jle`> Guest20: hm enalbing -XScopedTypeVariables or -XRankNTypes should allow you to write explicit foralls
19:39:04 <Guest20> Yes.
19:39:13 <Guest20> Don't want any. xd
19:39:16 <koz_> :t uncurry
19:39:18 <lambdabot> (a -> b -> c) -> (a, b) -> c
19:39:21 <Guest20> -XGADTs is what im using.
19:39:46 <nshepperd_> koz_: nice
19:39:49 <jle`> ah. yeah, explicit foralls can be useful :) it's actually the "encouraged" way to control order of type applications, in a sense
19:39:57 <jle`> without them it's kind of silly
19:40:20 <jle`> but it can complicate documentation sometimes admittedly
19:40:58 <Guest20> That's good to know.
19:43:19 <koz_> OK, _that_ bit of boilerplate I sadly can't remove it seems.
19:43:23 <koz_> Impedicativity needed.
19:44:31 <koz_> https://gist.github.com/kozross/489fa6d7ac16025aef7877a6d380289c#file-main-hs-L86
19:46:09 <hololeap> how does everyone feel about the ST monad? it seems to me that everything written using the ST monad could be re-written without using it, and the main advantage of using ST is that it translates well to imperitive code.
19:46:27 <nshepperd_> koz_: you could stuff the test itself in a newtype to hide the polymorphism of it
19:46:28 <koz_> hololeap: I am a big fan.
19:46:39 <koz_> nshepperd_: SomeTestFunction?
19:46:46 <koz_> Then unpack and apply?
19:47:20 <nshepperd_> newtype SomeTestFunction = F (forall (a :: Type) (n :: Nat) . (Cardinality a n, Show a, Eq a, 1 <= n) => Proxy a -> Property)
19:47:22 <nshepperd_> yeah
19:47:37 <koz_> nshepperd_: Yo dawg, we heard you like impedicativity...
19:47:54 <jle`> i don't think it's necessarily true that everything written in ST can be written without it while keeping the same readability and performance
19:47:55 <nshepperd_> it would simplify the type of constructTest a bit too, since it can just accept a SomeTestFunction then
19:48:10 <koz_> nshepperd_: Yeah, that makes sense.
19:48:27 <koz_> For me, the main advantage of ST is that I can have mutable arrays without having to drag in the whole jungle that is IO.
19:48:42 <koz_> It clearly states 'hey, there's mutable state here _and absolutely no other funny business_'.
19:48:45 <Nolrai> Huh. I seem to need a constructTest thats almost the same as yours.
19:48:51 <hololeap> jle`: i guess my worry is that i might get tempted to "cheat" and use ST instead of learning something cool like an idea from category theory
19:49:19 <koz_> hololeap: I... can't say this is something I've ever felt. Working with ST is awkward in my experience because runST is a typechecker hack.
19:49:32 <koz_> Try to compose it with anything? Err, nope.
19:49:42 <koz_> Try to use it in a higher-order context? Err, nope.
19:49:44 <koz_> Etc etc etc.
19:49:52 <hololeap> koz_: for runST specifically?
19:50:01 <koz_> hololeap: Yes, which ultimately you _will_ have to call at some point/.
19:50:22 <nshepperd_> koz_: although would that actually save much over just writing allTests = [constructTest isBijection "bijectivity", constructTest startIsCorrect "start", constructTest endIsCorrect "end"]?
19:50:34 <koz_> nshepperd_: There'll be more.
19:50:45 <koz_> And having to keep typing 'constructTest' over and over is annoying.
19:50:55 <hololeap> so `print . runST :: Show a => ST a -> IO ()` won't type check?
19:51:03 <Nolrai> Koz: Yeah, but you wont need runST in those contexts if you just push it into your definitions?
19:51:25 <koz_> Nolrai: Sure, but I somehow doubt that ST is the first, second or tenth thing I will reach for if I can help it.
19:51:42 <koz_> hololeap: It _might_. In my experience, any attempt to compose runST with anything went somewhat pear-shaped.
19:51:48 <koz_> Especially if it's something like 'runST . f'.
19:52:52 <Nolrai> koz_: I guess, It feels like such a spicific tool to me. You grab a screwdriver when you need to unscrew something. You grab ST when you need mutable state.
19:53:02 <Nolrai> * I guess. It
19:53:24 <koz_> Nolrai: Agreed, but hololeap's concerns seem to be like, the direct opposite of that.
19:53:24 <hololeap> well, the last time i needed ST was for a toy program that could parse a scrabble board
19:53:32 <koz_> It's a 'will I reach for my screwdriver when I want to slice bread'.
19:53:52 <ski> hololeap : `ST a -> IO ()' won't kind check
19:53:53 <hololeap> i tried using comonads, but the scope was too broad. so i ended up using ST and it _worked_
19:53:55 <koz_> I'm saying 'no, because in my experience, ST is inconvenient enough that I won't reach for it unless I really feel it's necessary'.
19:54:13 <koz_> As in 'I will try every other thing first'.
19:54:27 <ski> koz_ : "runST is a typechecker hack" -- i guess you mean that it's rank-2, and we don't have working impredicative types ..
19:54:28 <Nolrai> koz_: yeah, but I think your inconvience is because you are using it wrong.
19:54:36 <koz_> ski: Yes, I mean exactly that.
19:54:42 <Nolrai> Or wrong is a bit strong.
19:55:21 <Nolrai> The only reasons its wrong is because of the inconvience you encountered.
19:55:29 <ski> hololeap : i used `ST' to implement logic variables (efficiently)
19:55:53 <pinecamp> hey all, hopefully straightforward question... how can I represent a list of one type (let's say type A) that is always terminated by a value of a different type (let's say type B)?
19:56:11 <Nolrai> ([a],b)?
19:56:13 <koz_> pinecamp: MyList a b = More a (MyList a b) | Done b
19:56:23 <hololeap> ([a],b)
19:56:35 <koz_> I guess those also work. :P
19:56:54 <pinecamp> ([a],b) is probably what I'm looking for--thanks! :)
19:57:10 <pinecamp> koz_: where do More and Done come from?
19:57:25 <koz_> pinecamp: They're just data constructor names.
19:57:33 <koz_> I could have made them anything else.
19:57:37 <hololeap> it's an ad-hoc data type that koz_ made up
19:57:38 <pinecamp> ahh I see
19:57:52 <Nolrai> "data MyList a b = More a (MyList a b) | Done" defines them.
19:58:04 <pinecamp> y'all rock. thank you!
19:58:09 <ski> (missed `b' at end)
19:58:18 <Nolrai> I did.
19:58:21 <Nolrai> >.<
19:59:10 <Nolrai> koz_: could you gist or paste what you ended up with, I think I need to do basicly the same thing.
19:59:34 <koz_> Nolrai: Sure, let me fix up a bit.
19:59:47 <Nolrai> Thanks! :)
20:04:22 <koz_> Nolrai: https://gist.github.com/kozross/1c585c0ac9a8bc40ee3062cf9aa7b34d
20:04:32 <koz_> Relevant line: https://gist.github.com/kozross/1c585c0ac9a8bc40ee3062cf9aa7b34d#file-allboilerplatemustdie-hs-L36
20:05:04 <koz_> I can probably burn this down even more by having the property generators give back SomeTestFunctions.
20:05:45 <koz_> I also suspect that I can do more concisely with that main.
20:06:06 <dmwit> You heard it here first, folks. There are 13 types, no more, no less.
20:06:20 <koz_> dmwit: Yep, indeed. A very suitable number.
20:06:31 <hololeap> does that include bottom?
20:06:32 <dmwit> If you're gonna use TypeApplications, why you got a proxy?
20:06:42 <EvanR> will there be an epic quest to find them all, which gets cancelled after they only find 10
20:06:48 <koz_> dmwit: So that I can have SomeFinitaryRep do its thing.
20:07:01 <dmwit> But you defined SomeFinitaryRep.
20:07:07 <dmwit> Why not define it to not need a Proxy?
20:07:22 <koz_> Wait, I can do that?
20:07:34 <koz_> I guess the GADT match will drag those constraints into scope anyway.
20:07:35 <dmwit> I don't see why not.
20:08:05 <koz_> nshepperd_ suggested it, so I assumed there was a good reason.
20:09:27 <dmwit> Perhaps you need it for constructTest because we don't have a way to bring types into scope on a pattern match (yet).
20:09:38 <dmwit> Supposedly we will soon.
20:09:44 <koz_> dmwit: Won't a pattern match drag those constraints into scope?
20:09:51 <pinecamp> follow-up on the previous question... so I have a list of JSON objects that are being returned from an API. n-1 of those objects are all of my desired type. but the nth object is always a metadata object, of a different type
20:10:13 <dmwit> The match on SomeFinitaryRep will bring the constraints into scope, but not the type; therefore you can't supply it to testFunc.
20:10:22 <koz_> Ah yeah, I have no way to refer to it.
20:10:24 <pinecamp> I'm trying to find a way to tell Aeson how to parse that, at a high level. the ([a],b) solution unfortunately doesn't work, because it's not being returned as a tuple
20:10:26 <koz_> That makes sense.
20:10:38 <koz_> pinecamp: Use MyList!
20:10:48 <koz_> Then give it an instance of whatever magical typeclass Aeson wants it to have.
20:11:07 <koz_> And have its fromJSON (or whatever it's called) parse whatever JSON you need there.
20:12:28 <dmwit> pinecamp: Are you having trouble because you don't have a type to hang a FromJSON instance off of, or having trouble because you don't know what code to put to parse the thing you want?
20:12:46 <hololeap> or use or use TypeSynonymInstances >:p
20:12:51 <dmwit> The solution to the first problem is what koz_ says (or use a newtype). The second we can chat about, and is solved in a different way.
20:13:10 <koz_> Yeah, a newtype over ([a], b) would also work.
20:13:10 <pinecamp> koz_, dmwit: I can do the definition and the magical typeclass, but I'm not quite sure about the parsing
20:13:29 <koz_> pinecamp: Then my suggestion is unhelpful, and I'm sorry for not asking you to clarify.
20:14:12 <dmwit> pinecamp: Something like `foo :: (FromJSON a, FromJSON b) => Value -> Parser ([a],b); foo (Array vs) = liftA2 (,) (fromJSON (V.init vs)) (fromJSON (V.last vs))`
20:14:48 <koz_> dmwit: So Aeson uses a magical typeclass _and_ applicative parsing?
20:14:51 <dmwit> pinecamp: Toss a second pattern on there to report a sane error; e.g. `foo v = typeMismatch v "expected a Frobnosticated Widget"` or whatever.
20:15:15 <dmwit> koz_: I don't find the typeclass magical at all, and yes, it is a parsing combinator library.
20:15:23 <koz_> Good to know.
20:15:55 <dmwit> oops
20:16:07 <dmwit> `fromJSON (Array (V.init vs))`, not `fromJSON (V.init vs)`.
20:16:13 <hololeap> haskell is magic
20:16:24 <koz_> hololeap: My Little .... Pony?
20:16:36 <hololeap> Control.Pony.MyLittle
20:16:40 <pinecamp> dmwit: what is V in this case?
20:16:48 <dmwit> Data.Vector
20:17:09 <pinecamp> okay, cool. I'm gonna have to look up what some of this is doing :) 
20:17:35 <dmwit> You can see the definition of Value here: https://hackage.haskell.org/package/aeson-1.4.4.0/docs/Data-Aeson.html#t:Value
20:17:46 <pinecamp> so in this case, foo is a parsing method for my ([a],b) type?
20:17:47 <dmwit> If you click on Array, you'll see it's just a Vector Value.
20:18:04 <dmwit> yes...
20:19:56 <pinecamp> and liftA2 takes (a -> b -> c) -> f a -> f b -> f c... does this essentially put the ([a],b) value into the Parser type?
20:20:54 <koz_> pinecamp: More exactly, it takes a function which combines an a and a b into a c, and gives you something that can combine a _parser_ for a and _parser_ for b into a _parser_ for c.
20:21:09 <koz_> It can help to see its type as liftA2 :: (a -> b -> c) -> (f a -> f b -> f c)
20:22:32 <Nolrai> Okay I might have asked this already, but can I use template haskell to get all the identifiers defined in a module?
20:24:04 <pinecamp> thanks dmwit and koz_
20:25:14 <pinecamp> so far I had only written aeson parsers in the `withObject "MyObject" $ \o -> MyObject ...` style, so I'll dig a bit more into what it's doing with the Array and vector types
20:28:08 <pinecamp> dmwit: wow, V.init and V.last are exactly what I needed here
20:28:25 <pinecamp> how useful! :) 
20:28:48 <koz_> pinecamp: In general, knowing how to use stuff from vector will come in handy for a lot of cases.
20:28:54 <koz_> Worth learning in the long term, big-time.
20:29:31 <pinecamp> koz_: good to know! I appreciate the liftA2 explanation as well, that helped
20:29:54 <koz_> pinecamp: You're welcome. Another thing which might help - read the Typeclassopedia. It'll be a huge, long-term help to your understanding of lots of things.
20:30:32 <pinecamp> ooh, nice! I hadn't heard of this yet
20:36:13 <dmwit> pinecamp: Wait, what goes in the `...` in your style comment?
20:36:45 <dmwit> pinecamp: Is it not basically `liftA2 MyObject parserForMyObject'sFirstField parserForMyObject'sSecondField`?
20:37:00 <dmwit> pinecamp: And then just think of `(,)` as being `MyObject` and off you go.
20:37:17 <jle`> hololeap: it's true that putting constraints on yourself to help you learn can be useful for learning. but not necessarily when just doing work day to day
20:37:47 <pinecamp> dmwit: possibly! for me it typically looks like `<$> o .: "field1" <*> o .: "field2"`
20:42:00 <hololeap> jle`: fair enough. but i thought it was worth asking. it could have been that some blog post had proven ST to be irrelevant in light of new language features or something
20:42:13 <MarcelineVQ> like linearity
20:42:15 <dmwit> ?src liftA2
20:42:15 <lambdabot> liftA2 f a b = f <$> a <*> b
20:42:17 <dmwit> pinecamp: ^
20:42:43 <pinecamp> ah, you're absolutely right
20:43:00 <dmwit> See? You already know this stuff! You're a Haskell WIZARD
20:43:16 <hololeap> MarcelineVQ: what do you mean?
20:44:58 <koz_> hololeap: Linear types make ST unnecessary, because they can designate that something is not going to be re-used.
20:45:04 <koz_> Therefore, we're free to mutate in that case.
20:45:10 <hololeap> oh, wow
20:45:11 <koz_> (since we can't see the change anyway)
20:45:36 <pinecamp> dmwit: there's still something I'm missing with how to wire this together
20:45:45 <MarcelineVQ> hololeap: if you like papers https://arxiv.org/pdf/1710.09756.pdf
20:45:58 * dmwit thought it was already wired together
20:46:20 <dmwit> But anyway, shoot. We'll all try to answer your question.
20:46:30 <pinecamp> I have `data MyFinalType = MyFinalType { result :: ([a],b) }`, the function you gave above, and FromJSON instances for a and b
20:46:32 <EvanR> simultaneously
20:46:52 <EvanR> or what was it, in contrapuntal fugue
20:47:09 <pinecamp> but I'm struggling to put together the parseJSON function for MyFinalType
20:47:25 <hololeap> i love arxiv's favicon
20:47:26 <dmwit> (Oof, don't do that. Either `newtype MyFinalType = that` or `data MyFinalType = MyFinalType { whatever :: [a], whateverElse :: b }`. This way is No Bueno.)
20:48:09 <pinecamp> dmwit: the reason it's this way is because the API returns the array I want in a "result" field
20:48:19 <pinecamp> but I am happy to refactor to make it better
20:48:55 <dmwit> But why would what the API returns have any influence at all on what a good Haskell type definition is?
20:49:05 <spoonm> savage
20:50:27 <pinecamp> lol! I have no answer for this other than trying to make my data structures line up with my program structure, due to a newbie intuition for parsing
20:50:31 <dmwit> Anyway: data Thingy = Thingy { blargo :: [Int], whammy :: String }; instance FromJSON Thingy where parseJSON (Array vs) = Thingy <$> parseJSON (Array (V.init vs)) <*> parseJSON (V.last vs); parseJSON _ = typeMismatch {- ... -}
20:50:43 <pinecamp> sorry, data structures line up with the API response structure
20:51:01 <dmwit> Which... is exactly the same as what I wrote about 40 minutes ago just with different names.
20:51:35 <iqubic> what is typeMismatch?!?!
20:51:53 <dmwit> If only there were some tool or something that would answer questions like those in an automated way.
20:52:07 <dmwit> (Hecking RTFM, mate.)
20:52:09 <iqubic> :t typeMismatch
20:52:12 <lambdabot> error: Variable not in scope: typeMismatch
20:52:32 <dmwit> https://hoogle.haskell.org/?hoogle=typeMismatch
20:53:28 <iqubic> Eww... Runtime errors.
20:54:01 <dmwit> That... is not a runtime error in the way most people mean runtime error.
20:54:52 <nshepperd_> an error in the runtime of the heart
20:55:02 <dmwit> Just like `Left "foo"` is not what most people would call a runtime error.
20:55:18 <iqubic> I see. Oh. Makes sense.
20:58:08 <hololeap> a total eclipse of the typechecker?
20:58:28 <iqubic> Huh?!?
20:58:49 <hololeap> rofl
20:59:17 <EvanR> Left is like an exception
20:59:25 <EvanR> pure exception
20:59:36 <iqubic> I know.
20:59:38 <dmwit> Is there a Haskell interface to the getrandom syscall?
20:59:54 <iqubic> I think you could use FFI.
21:00:40 <hololeap> isn't that what randomIO uses?
21:01:58 <dmwit> No.
21:02:18 <hololeap> i'm looking at this and it seems to imply it
21:02:19 <hololeap> http://hackage.haskell.org/package/random-1.1/docs/src/System.Random.html#randomIO
21:02:39 <dmwit> Doesn't imply it to me.
21:02:57 <dmwit> What's more, I know the answer, and the answer is no. So whatever that implies is irrelevant.
21:03:10 <hololeap> look for globalrng
21:03:19 <hololeap> There is a single, implicit, global random number generator ...
21:03:33 <hololeap> It is
21:03:35 <hololeap> initialised automatically in some system-dependent fashion, for example,ny
21:03:37 <jle`> hololeap: that's a pure RNG
21:03:43 <hololeap> ugh... sorry
21:03:48 <jle`> but it doesn't call getrandom(2)
21:03:52 <hololeap> ... or Linux's kernel random number generator
21:04:02 <MarcelineVQ> suposedly getrandom draws from urandom, there are wrappers on urandom around
21:04:12 <jle`> hololeap: so once it does the first initialization, the rest is pure haskell
21:04:21 <dmwit> Even if that were literally true (that it were initialized via getrandom), that doesn't give *me* an interface to getrandom.
21:04:27 <hololeap> jle`: i see
21:04:47 <nshepperd_> if there were such an interface i guess it might appear in the 'unix' package
21:04:52 <nshepperd_> but i don't see it
21:06:41 <dmwit> Okay, I'll read from /dev/urandom myself.
21:08:47 <hololeap> dmwit: do you mind me asking, purely for curiosity's sake, why you need direct access to urandom and can't use haskell's pure randomness?
21:09:25 <jle`> ljlkjlljljlj
21:09:46 <dmwit> I would like to seed a pure generator.
21:09:52 <jle`> ah sorry, ssh lag
21:09:54 <dmwit> With high-quality randomness.
21:09:56 <MarcelineVQ> dmwit: https://hackage.haskell.org/package/entropy-0.4.1.5/docs/System-Entropy.html has a wrapper for urandom, but is slightly more generic
21:10:12 <dmwit> (randomIO is not high quality)
21:10:26 <nshepperd_> cryptonite has getEntropy, which reads from either rdrand (some hardware entropy cpu instruction?) or /dev/urandom
21:10:28 <dmwit> MarcelineVQ: cool!
21:11:22 <hololeap> does anyone know what randomIO uses to initialize itself in linux?
21:11:28 <MarcelineVQ> There's another somewhat generic urandom wrapper but I'm not sure how easy to use it is, https://hackage.haskell.org/package/random-source-0.3.0.6/docs/src/Data-Random-Source-DevRandom.html
21:11:32 <dmwit> hololeap: nice
21:11:48 <MarcelineVQ> Oh that's older than I expected
21:12:13 <dmwit> Opening a file just seems so roundabout compared to doing a syscall. =P
21:13:09 <dmwit> oh lmao, System.Entropy opens a file too
21:13:19 <jle`> % withBinaryFile "/dev/urandom" ReadMode hGetLine
21:13:20 <yahb> jle`: "\217\157rA\162&:\175D>G\181\187\194\239\221M\188 \198\222\135\DC1\GS\ESC\226\197\249{\184\&2\ENQ\aw\255\NUL\219\214z\164\251*\172\214\210\180\169|2\129Sq^)\181\198\149\156\226n\216\173\SI\144\DC4\240\157\ETBv\150mT\150\156\SUBSV\160\132bE\163\SO\207S\251\224[5\213\164\184\&6\137I\SO72p=\156<\192A\DC1\223\175\142t5\213\174\SOH\247\138\239\SYNP\142\228\130a\253R\143\165\151]`\225\155\240\DC3\193\17
21:13:35 <MarcelineVQ> Maybe the limitations of the syscall made the file more attractive, the things mentioned in man getrandom
21:13:51 <jle`> % withBinaryFile "/dev/urandom" ReadMode $ putStrLn <=< hGetLine
21:13:52 <yahb> jle`: ÂºÃÃˆÃÃ˜eÂ Â¾Ã’Ã‘jÃ«Â¢okÃ™Â¦Q@Â¦8ÂˆÂ6yOÂ¥Â«Ã«Âš!lÂ¬(Â˜Ã­Â, Â´Â¨Ã¿Ã³Ã†'mÃÂ¢lÃ¿Â¶Ã‰ÂšÃˆI,Ã¿iÃ€Ã£Â–Â©#ChÃ”Â¬tÃ hÂ†!Ap!tÃ„.Ã‰ÃšÂ‡Â¿HTÃ†ÃªXÃxÂÂ’;iÂÃ¹Â‰Ã¦Â¶ÃºÂ‰&w-Ã­3T{ZÃ’Ã™`ZYÃ_ÃIÃ”*@Âˆ Ã®#Â§wÂÂ”Ã¡|k:mÂ°0ÂˆÃµÂ¦Â  |Ã›G>Â‹Â«Â»piÂ­kÃºÂ¾Â§dÃ¨Â»Ã¥Âµ~m*ÂµNÃŸ^PGdÂ–Ã‚}ÃƒÃ¥Â½Â„ÂÃ‹Â‰ZyÂ¬ÂŠÃƒ7 hYÂ¹dÃ¨Â¾FÃ¢bÃ±Ã¤Ã‚`Ã£Ã³Â–Ã»< Ã£fÃ‡ÂFÃ¼ÂŸ Â–BÂ“Ã¤?:+Ã’ÃˆÃ§PWÃ¨Ã€Ã¶{Â·Ã›E U7Â½WÃ
21:14:04 <MarcelineVQ> nlarthep
21:14:27 <hololeap> cthulu?
21:16:16 <jle`> % withBineryFile "/dev/urandom" ReadMode $ putStrLn <=< hGetLine
21:16:16 <yahb> jle`: Ph'nglui mglw'nafh Cthulhu R'lyeh wgah'nagl fhtagn
21:17:08 <dmwit> % import Control.Concurrent
21:17:09 <yahb> dmwit: 
21:17:25 <dmwit> % forkIO (threadDelay 1000000 >> putStrLn "Surprise!")
21:17:26 <yahb> dmwit: ThreadId 120
21:17:40 <hololeap> haha, me thinks that jle` has been PMing yahb
21:17:55 <nshepperd_> Binery, the forbidden radix
21:17:59 <dmwit> % ()
21:17:59 <yahb> dmwit: Surpris(e)!
21:18:08 <dmwit> haha what
21:18:29 <spoonm> lol
21:18:32 <dmwit> computers (tm)
21:18:53 <spoonm> % ()
21:18:53 <yahb> spoonm: ()
21:19:00 <MarcelineVQ> % :q
21:19:01 <yahb> MarcelineVQ: 
21:19:32 <spoonm> % forkIO (threadDelay 90000000 >> putStrLn "I'll just leave this here for the next person.")
21:19:34 <yahb> spoonm: ThreadId 72
21:19:49 <jle`> % killThread it
21:19:49 <yahb> jle`: 
21:19:54 <spoonm> o no
21:20:04 <jle`> >:)
21:20:10 <spoonm> rude
21:20:51 <dmwit> I have two questions: 1. How did the () get interleaved with the surprise? I waited way more than one second. 2. There should be two newlines, one from the surprise and one from the legit output. How come I only got one?
21:21:32 <dmwit> % putStr "Surprise(e)!\n\n"
21:21:32 <yahb> dmwit: Surprise(e)!
21:21:42 <dmwit> Ah, perhaps this is yahb prettifying the output some.
21:22:00 <dmwit> % putStr "a\n\n\nb"
21:22:01 <yahb> dmwit: a; b
21:22:03 <MarcelineVQ> yes, though you sometimes see ; instead
21:22:06 <dmwit> Okay. That's question 2 sorted.
21:22:15 <dmwit> Blank lines get tossed.
21:22:56 <jle`> i only just now noticed that you wrote Surprise! and it outputted Surpris(e)!  -- i had thought that was a part of your original print
21:23:31 <MarcelineVQ> it's a wonder of timing that you didn't get Surpris(e); !
21:24:08 <dmwit> No, I don't think it is.
21:24:20 <dmwit> ...Oh, yes, I do think it is.
21:24:48 <jle`> % putStr "Surpris(e)\n!\n"
21:24:49 <yahb> jle`: Surpris(e); !
21:24:59 <dmwit> But I'm still weirded out by the printing of Surprise! not being finished by the time the () started.
21:25:39 <jle`> maybe there is some suspension of the process/clock going on?
21:25:51 <dmwit> oh
21:25:54 <MarcelineVQ> buffers are weird, we could demand that mniip explain his shame
21:25:56 <jle`> maybe the impl of threadDelay is based on reading system clock
21:26:10 <jle`> and as soon as it 'woke up' from the % (), it was like "oh shoot, i'm late...better do it now."
21:26:25 <dmwit> That seems as plausible an explanation as any.
21:26:31 <jle`> orrr..maybe buffering was disabled between wakeups
21:26:39 <jle`> er i mean, buffering was happening between wakeups
21:26:51 <jle`> and as soon as it tried to read output, it got what was buffered
21:27:10 <jle`> in conclusion, computers (tm)
21:27:16 <dmwit> yeah =)
21:27:33 <argent0> How to use `Controal.Monad.Random.getRandom` inside a "do block" to get e.g a Bool? I'm getting `... m1 is not MonadRandom...`
21:28:25 <dmwit> % import Control.Monad.Random
21:28:26 <yahb> dmwit: ; <no location info>: error:; Could not find module `Control.Monad.Random'; Perhaps you meant; Control.Monad.Reader (from mtl-2.2.2); Control.Monad.Base (from transformers-base-0.4.5.2); Control.Monad.Catch (from exceptions-0.10.0)
21:28:28 <dmwit> too bad
21:28:38 <argent0> when I try to do `getRandom :: m Bool`
21:28:48 <dmwit> Anyway, you just do it. Perhaps you should toss a MonadRandom constraint on your type signature. Tough to say much without seeing the wrong code.
21:29:38 <dmwit> argent0: What monad do you want to run this in?
21:29:48 <dmwit> If you don't care, perhaps try `getRandom :: IO Bool` instead.
21:29:52 <nshepperd_> could be something to do with how stdout is sandboxed (so that writing is suspended while the virtual stdout is unready because there's no one to reply to)
21:30:01 <argent0> dmwit: I've the constraint on m but it is asking for a constraint on m1. That is the m in `m Bool` is not the same as the one on the signature (MonadRandom m)
21:30:20 <dmwit> argent0: You can make them the same with ScopedTypeVariables.
21:30:30 <dmwit> Don't forget to add a `forall` to bring the type variable into scope.
21:30:31 <nshepperd_> the writing thread is suspended, rather. until there's enough buffer space
21:30:56 <argent0> dmwit: have that too
21:31:12 <dmwit> (Or you can use the result in a way that clearly forces it to be a Bool, and put no type ascription on getRandom.)
21:31:17 <dmwit> argent0: Better show us the code.
21:31:28 <dmwit> I can keep staring into my crystal ball, but it's mostly frustrating for both of us.
21:31:31 <argent0> dmwit: It worked when I added the explicit forall m
21:31:53 <argent0> dmwit: Thanks for the help.
22:50:49 <koz_> I'm trying to use TH to splice a specific Nat into a top-level (specifically type class instance) definition. However, GHC isn't too fond of that - it says that the name of this type (which is a string of digits) is not a legal type variable name.
22:51:00 <koz_> Am I not supposed to construct a Q Type in such a case?
22:54:22 <dmwit> Q Type is fine. What Type constructor are you using?
22:54:36 <dmwit> % :set -XTemplateHaskell -XDataKinds
22:54:37 <yahb> dmwit: 
22:54:46 <dmwit> % import Language.Haskell.TH
22:54:46 <yahb> dmwit: 
22:54:51 <dmwit> % runQ [t|32|]
22:54:51 <yahb> dmwit: LitT (NumTyLit 32)
22:54:57 <koz_> Oh that's how.
22:54:59 <dmwit> Are you using LitT?
22:55:02 <koz_> I used VarT instead.
22:55:07 <koz_> I guess that's not what I want.
22:55:11 <dmwit> indeed
22:55:13 <koz_> THanks!
22:56:29 <koz_> Works like a charm.
23:04:56 <koz_> :t fromIntegral
23:04:58 <lambdabot> (Integral a, Num b) => a -> b
23:05:05 <koz_> :t subtract
23:05:06 <lambdabot> Num a => a -> a -> a
