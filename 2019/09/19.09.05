00:02:31 <EvanR> iqubic: forall f, forall t around the whole thing
00:02:43 <EvanR> caller decides f and t
00:04:43 <iqubic> Cool. Nice.
00:04:46 <iqubic> I was right.
00:22:44 <iqubic> I find this super cool: http://dpaste.com/3YTQ2FZ
00:24:10 <iqubic> And if I ask for a String from that OpenSum, it gives me a compiler error.
00:25:36 <EvanR> try '[Bool, Bool, Bool]
00:26:43 <iqubic> I will.
00:27:30 <WASD> Are there less verbose ways to write this? Modifying one field in the State monad where my state is an ADT: "modify (\state -> state {myCounter = myCounter state + 1})". Can you make a function like "modifyField myCounter (+1)"?
00:28:05 <iqubic> I just added a function "weaken :: OpenSum f ts -> OpenSum f (x ': ts)" which lets me expand the list of possible types.
00:28:21 <iqubic> http://dpaste.com/270JH1N
00:29:27 <iqubic> Proving that this sum really is open.
00:31:02 <EvanR> WASD: yes... lenses
00:31:27 <WASD> Ah... I was afraid of that answer ;)
00:31:35 <EvanR> or something similar
00:31:47 <WASD> thanks
00:31:51 <lavalike> template haskell >:)
00:31:58 <EvanR> in the end whatever you do will require writing or generating helper functions
00:31:59 <WASD> I have not tried them yet but I'm starting to get an understanding of what they are for
00:32:30 <iqubic> EvanR: These OpenSums have no issue with duplicates.
00:32:31 <iqubic> http://dpaste.com/3351E53
00:33:59 <EvanR>  so... is that basically the first Bool is present, second two are not?
00:34:24 <EvanR> what if you wanted to inject True as the second Bool
00:34:33 <iqubic> Let me test some things.
00:38:47 <iqubic> Seems to just store the first index. See this: http://dpaste.com/368WHXQ
00:39:15 <iqubic> EvanR: This data type only stores one element.
00:39:34 <iqubic> It's like an Either a b. It only has one value.
00:40:45 <iqubic> However, you can change it from having only two possibilities of what type the one value has, to having three or four or five possibilities for what the type of the one value is.
00:43:27 <EvanR> iqubic: an important property of Either Bool Bool is that, even though it "stores" one value, you can distinguish Left True and Right True
00:43:38 <EvanR> a sum of Bool Bool Bool has 6 possible values
00:43:41 <EvanR> not 2
00:44:55 <EvanR> if your type can't pull that off... doesn't seem like much of a sum
00:44:55 <iqubic> Ah. We aren't storing which position was used. I don't think we are.
00:45:57 <iqubic> Well, I guess it isn't much of a sum in that regard.
00:48:16 <EvanR> it has the same problem as javascript having only 1 "null", so you can't (using just null), distinguish Nothing and Just Nothing
00:48:28 <iqubic> Yeah.
00:48:36 <EvanR> in the type Maybe (Maybe Int)
00:48:41 <iqubic> Right.
00:49:23 <iqubic> Next chapter is about making an OpenProduct. Which sounds a whole lot more scary than what I just did.
00:49:24 <ski> EvanR : aka "domain contagion"
00:49:47 <ski> hm, i wonder whether one could call it `OpenLub'
00:51:15 <iqubic> What does Lub mean?
00:52:23 <iqubic> Is this function even useful? http://dpaste.com/3MDAX4Y
00:55:32 <iqubic> Like I suppose you could have an OpenSum with an [a] in it, and then transform that into something else.
00:55:32 <ski> iqubic : "least upper bound", aka "supremum" (or "join", apparently, not "meet". i can't recall which of those is which)
00:56:00 * hackage hasql-transaction 1 - A composable abstraction over the retryable transactions for Hasql  https://hackage.haskell.org/package/hasql-transaction-1 (NikitaVolkov)
00:56:00 <iqubic> But why would that be a better name for this OpenSum?
00:56:20 <ski> because lub is idempotent ?
00:56:37 <ski> `lub {a,a} = a'
00:56:48 <iqubic> Ah I see.
00:57:17 <boxscape> Seems a lot like a union as opposed to a tagged union
00:57:49 <iqubic> I also wrote: 'weaken :: OpenSum f ts -> OpenSum f (x ': ts)'
00:57:56 <ski> (the "other side" of the order would be `glb', being "greatest lower bound", aka "infimum" (or "meet"))
00:58:05 <boxscape> (where I mean union in the set theoretic sense, I suppose)
00:58:09 <ski> (in the finite case, these two are just "maximum" and "minimum")
00:58:37 <iqubic> Weaken mainly just exists to prove that the list of possibilities for types really is open.
00:58:37 <ski> iqubic : oh, i suppose with that, it may not be a lub
00:59:07 <iqubic> That function is literally just a single line.
00:59:25 <iqubic> weaken :: OpenSum f ts -> OpenSum f (x ': ts)
00:59:52 <iqubic> weaken (UnsafeOpenSum n t) = UnsafeOpenSum (n + 1) t
01:00:11 <iqubic> the n there is the index of the type of t.
01:01:02 <iqubic> It's literally just updating the runtime information to match the new type.
01:04:03 <iqubic> ski: How does my weaken function prevent this from being lub?
01:07:24 <ski> iqubic : well, i haven't read the chapter, so i'm only guessing
01:08:34 <ski> iqubic : but it seemed to me that in  OpenSum Maybe '[Bool,Bool,Bool]  only the first alternative could be populated, meaning that we basically have just `Maybe Bool' in this case
01:09:11 <iqubic> Yes. That is true.
01:09:29 <iqubic> Wait. No. that's long.
01:09:31 <ski> iqubic : but by using that `weaken', you could get around that, unless you make sure to compare `x' to each type in `ts', and changing the index to `0' in case they compare equal
01:09:32 <iqubic> *wrong
01:10:20 <iqubic> inj only allows you to make the value contained have a type that is in the list.
01:11:15 <ski> yea, but what does `FindElem' do, in case there's multiple matches ? gives the first one ?
01:12:04 <merijn> Man...all these Clash announcements are triggering while I sit here fighting Intel's braindead OpenCL to VHDL stuff >.>
01:12:30 <ski> what's that, you say ?
01:13:02 <iqubic> FindElem uses the hackage package First Class Families. Specifically it uses FindIndex to do the actual searching. https://hackage.haskell.org/package/first-class-families-0.5.0.0/docs/Fcf.html#t:FindIndex
01:13:09 <iqubic> You can view the source there.
01:13:31 <iqubic> I actually don't know how it handles duplicates.
01:14:06 <iqubic> I just looked at the code.
01:14:31 <ski> it finds the first, but the spec is
01:14:32 <iqubic> It returns the index of the first element that satisfies the predicate.
01:14:33 <ski> -- | Find the index of an element satisfying the predicate.
01:14:41 <iqubic> Yeah.
01:14:50 <ski> so, it doesn't guarantee you that you find the first, which is interesting
01:14:58 <iqubic> The spec is a bit ambiguous.
01:15:05 <ski> i wonder how this is to be interpreted
01:15:15 <ski> where is the existential placed ?
01:15:55 <ski> hm, this ties into issues with mobile code, i suppose
01:15:55 <iqubic> In what bit of code?
01:16:14 <iqubic> Which existential are you refering to?
01:16:14 <ski> no, not in code. in formal spec, i was wondering about
01:16:28 <iqubic> Ah.
01:16:47 <ski> the existential that says that it'll give you back *some* index of a type in the list matching the given type
01:16:53 <iqubic> I don't know what an existential is in that context. Seems like a linguistic thing there.
01:17:20 <ski> my question was more or less whether this is a choice which is made once and for all (but you don't get any guarantees about what that choice is)
01:17:21 <iqubic> ski: The first matching index is valid in that case.
01:17:28 <ski> or, otoh, it's a choice that's made in each case
01:17:48 <ski> oh, this is interesting
01:18:11 <ski> the latter would allow it to give different choices, in each case
01:18:15 <iqubic> The answer is simple. There never was a choice. You only ever get the first matching element.
01:18:19 <ski> (that's not the interesting bit, though)
01:18:34 <ski> i'm not talking about the implementation. i'm talking about the intended specification
01:19:58 <ski> anyway, in a language with side-effects, you'd just say that the implementation is allowed to pick a different index, for each call, with the same arguments
01:20:48 <ski> that's indeterminacy for you, in this case coming from library underspecification, rather than from say randomness, or from concurrency (races and so)
01:20:55 <iqubic> I have to restart my WM. Be back soon.
01:22:42 <ski> so
01:23:03 <ski> in Haskell, calling a function with same inputs is supposed to give same outputs
01:26:28 <iqubic> I'm back.
01:27:00 <iqubic> I accidentally ran a fork bomb on my machine and froze it up. Had to do a hard reboot. I didn't lose any data though.
01:27:19 <iqubic> Maybe I shouldn't have ran the file called forkbomb.sh
01:28:40 <maerwald> xD
01:30:14 <iqubic> look, I accidentally typed "sh *.sh" in my home directory. I was 90% certain there was only a single executable in that directory. I forgot I still had the forkbomb.sh around.
01:34:45 <ion> This one? :(){:|:&};:
01:35:33 <iqubic> That's the one.
01:36:29 <merijn> Oh! oh! Are we finally getting non-broken impredicative types? :D
01:37:32 <Taneb> merijn: ???!
01:38:24 <iqubic> What are those, and why would I want those?
01:38:30 <evelyn> ?quit
01:38:30 <lambdabot> Not enough privileges
01:40:38 <Taneb> iqubic: https://gitlab.haskell.org/ghc/ghc/wikis/impredicative-polymorphism has some explanation
01:41:02 <merijn> Taneb: ghc-dev list someone posted that they're new branch has non-broken impredicative types that covers a lot of the desired usecases
01:41:34 <iqubic> Taneb: That page isn't loading on my machine.
01:41:45 <merijn> iqubic: Impredicative types (like RankN types) are easiest/best explained when you try and do something that requires them and find out that you can't :)
01:41:46 <iqubic> Oh wait... There it goes.
01:41:49 <boxscape> Interestingly, even though -XImpredicativeTypes is broken, ghci autocompletes it, which it doesn't for -XOverlappingInstances
01:41:50 <Taneb> iqubic: it's slow I'm afraid
01:41:51 <merijn> Explaining in a vacuum is tricky
01:42:10 <merijn> boxscape: The problem with -XImpredicativeTypes isn't that it's broken
01:42:19 <merijn> boxscape: It's that we have no way to even decide if it's broken
01:42:25 <koz_> Oh wow, so will I finally be able to use runST without constantly having GHC complain when I try to compose it?
01:43:07 <boxscape> merijn in the "undecidable" sense?
01:43:40 <merijn> boxscape: In the sense that it's not really well-defined what it's *supposed* to do, so how can you say it's wrong
01:43:45 <boxscape> I see
01:43:51 <Taneb> In the "is this art?" sense
01:44:17 <merijn> boxscape: It's like saying a program doesn't follow a spec if you don't know what spec it's supposed to follow
01:44:27 <boxscape> ok
01:44:55 <merijn> Part of the new work is "finding a set of things we can actually properly define and then implementing that, hopefully catching as many usecases as possible"
01:45:00 <iqubic> Oh. I see what the issue is
01:45:11 <iqubic> I understand this a lot better now.
01:45:49 <koz_> Yeah, that example they have on the wiki? That's my runST gripe in short.
01:46:48 <iqubic> The one with foo and bar and the way that the eta reduced version fails to type check?
01:46:54 <merijn> My big problem is "I wanna send rankn functions/values through datatypes (like Chan)
01:47:14 <koz_> Yeah, because if you try to compose runST with basically anything, GHC goes 'NOPE IMPREDICATIVE STAHP'.
01:47:46 <iqubic> I see.
01:47:52 <koz_> It confused the absolute hell out of me when I first tried using mutable arrays in ST.
01:48:31 <iqubic> Just use extra parens.
01:49:12 <koz_> iqubic: Which is fine _if you know about this thing_.
01:49:17 <koz_> I didn't at the time.
01:49:39 <merijn> Worse is that it sometimes works, when you use $
01:49:52 <merijn> Because $ has an evil hack in the typechecker to make it work
01:50:18 <ski> meep
01:50:22 <ski> iqubic, ok
01:50:38 <koz_> merijn: Yeah, forgot about that one lol.
01:53:54 <ski> oh, "Perhaps this justifies the terminology: the joining of two sets is their union, the meeting of two sets is their intersection."
01:54:02 <ski> anyway
01:54:07 <ski> <ski> anyway, in a language with side-effects, you'd just say that the implementation is allowed to pick a different index, for each call, with the same arguments
01:54:19 <koz_> This is also of some relevance: https://www.microsoft.com/en-us/research/publication/guarded-impredicative-polymorphism/
01:54:24 <ski> <ski> that's indeterminacy for you, in this case coming from library underspecification, rather than from say randomness, or from concurrency (races and so)
01:54:30 <ski> <ski> in Haskell, calling a function with same inputs is supposed to give same outputs
01:54:34 <ski> iow, we're talking about functions, rather than relations, where the output would be arbitrarily (in some fashion) chosen from the available possible outputs
01:54:50 * ski :/
02:13:31 <boxscape> before Type :: Type, what was the output of `:k Type`?
02:13:43 <boxscape> or `:k *`, as it were
02:14:49 <boxscape> as I understand it the sort of `*` was `BOX`? But I'm not sure if ghci displayed that
02:15:09 <boxscape> I don't think I ever saw it, but maybe I just never entered `:k *`
02:31:51 <rhylx> Hi there :D
02:33:29 <rhylx> jgt: is this :http://shop.oreilly.com/product/0636920035664.do  a good starting point to have a first working whatsapp like web app?
02:35:34 <jusss> :t ReaderT
02:35:36 <lambdabot> (r -> m a) -> ReaderT r m a
02:36:00 * hackage casing 0.1.4.1 - Convert between various source code casing conventions  https://hackage.haskell.org/package/casing-0.1.4.1 (TobiasDammers)
02:37:47 <jusss> what is the >>= and return definition for ReaderT?
02:41:19 <ski> perhaps you could figure that out for yourself, jusss ?
02:42:57 <boxscape> ski: that could be interpreted as something like "Why ask here if you can just google it" (Which I'm guessing is not what you mean)
02:45:30 <maerwald> @hoogle ReaderT
02:45:30 <lambdabot> Control.Monad.Trans.Reader newtype ReaderT r m a
02:45:30 <lambdabot> Control.Monad.Trans.Reader ReaderT :: (r -> m a) -> ReaderT r m a
02:45:30 <lambdabot> Control.Monad.Reader ReaderT :: r -> m a -> ReaderT r
02:45:59 <maerwald> https://hoogle.haskell.org/?hoogle=ReaderT
02:46:06 <maerwald> from there you should be able to find the source code
02:46:53 <Rembane> The transformers one is almost readable. 
02:46:57 <boxscape> jusss might be a good learning experience to try and implement it by yourself first though
02:48:05 <Rembane> Hm... there is only one... nevermind. 
02:49:01 <ski> that's not what "figure out" means, at least to me
02:49:24 <boxscape> ski that's fair - I don't think what I said is the obvious interpretation
02:50:04 <boxscape> (i.e. what you in fact meant *is* the obvious one)
02:52:12 <Guest_72> Detected ~/.bashrc on your system...If you want ghcup to automatically fix your ~/.bashrc to include the required PATH variableanswer with YES and press ENTER (at your own risk).Otherwise press ctrl-c to abort.
02:52:24 <Guest_72> can anybody helps me please :)
02:52:42 <jusss> I hope we have a document like python.org
02:53:12 <jusss> everything is simple and there're lots of examples for it in docs.python.org
02:53:32 <jusss> so people don't need to ask in stackoverflow.com
02:56:26 <maerwald> Guest_72: press enter
03:04:50 <jusss> :t lift
03:04:52 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
03:34:22 <nil> ski: could one write the general type of natural transformations like this? (using your *> notation for the "producer" variant of =>)
03:34:25 <nil> exists f g. (Functor f, Functor g) *> forall a. f a -> g a
03:35:45 <jgt> rhylx: sorry; busy with meetings
03:35:56 <jgt> rhylx: but yeah, that book is free to read online
03:36:20 <jgt> and it helped me in the beginning, and I do still refer to it
03:36:53 <rhylx> jgt: np. okok. Tbh, the book is kind of long ^^
03:37:14 <jgt> rhylx: I think a good chunk of it is just example applications
03:38:54 <rhylx> jgt : ok, and are there more specific examples concerning my needs?
03:39:47 <jgt> rhylx: iirc there's a chat example, which is somewhat related to what you were going after
03:40:13 <jgt> rhylx: what you're trying to do is also somewhat similar to a blog application
03:48:16 <DariusTheMede> ghc: panic! (the 'impossible' happened)
03:48:17 <DariusTheMede>   (GHC version 8.6.5 for x86_64-apple-darwin):
03:48:17 <DariusTheMede>         Data.Binary.Get.runGet at position 8: Invalid magic number "\202\254\186\190\NUL\NUL\NUL\STX"
03:48:17 <DariusTheMede> CallStack (from HasCallStack):
03:48:20 <DariusTheMede>   error, called at libraries/binary/src/Data/Binary/Get.hs:351:5 in binary-0.8.6.0:Data.Binary.Get
03:48:23 <DariusTheMede>  
03:48:26 <DariusTheMede> Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
03:55:27 <aplainzetakind> I tried to reproduce a computation from a paper for the largest eigenvalue of a matrix, but the result I got was very slightly off. I used hmatrix. The entries of the matrix are ratios of large integers, so at first I though I could keep them as Rationals until the very end, but hmatrix does not support matrices of Rationals. Any ideas what could be at fault?
03:57:01 <infinisil> Floating point math?
03:58:05 <Ariakenom> as in floating point math does not give the same result for different computers/languages/phases ofthe moon
03:59:02 <aplainzetakind> Are there any libraries to work with rational matrices?
03:59:39 <Ariakenom> aplainzetakind: is the answer from the paper exact?
04:01:44 <DariusTheMede> aplainzetakind: What is the reciprocal condition number for the matrix?
04:03:02 <aplainzetakind> No, it's roughly > 4.0020, it's maximizing a quadratic form which needs to be >4, and it's commented that it can be verified by taking a rational approximation to the eigenvector it can be verified exactly.
04:03:06 <DariusTheMede> aplainzetakind: how off is off? I would expect differences at the floating point precision level but depending on how close the matrix is to being singular the difference could be a lot worse
04:04:14 <DariusTheMede> aplainzetakind: what is 4.0020? the reciprocal condition number?
04:04:20 <aplainzetakind> I get 3.997, so small but not very I guess.
04:04:25 <aplainzetakind> The paper eigenvalue.
04:04:45 <DariusTheMede> The difference will depend on how close the matrix is to being singular
04:05:06 <DariusTheMede> You can look at the reciprocal condition number
04:05:22 <aplainzetakind> How do I do that?
04:05:42 <DariusTheMede> https://scicomp.stackexchange.com/questions/31016/condition-number-of-a-matrix
04:05:51 <DariusTheMede> It might exist in hmatrix
04:05:55 * DariusTheMede goes to look
04:05:55 <Ariakenom> the multiplication method will also make a difference
04:06:05 <aplainzetakind> Ah hmatrix has it
04:07:07 <Ariakenom> it's a small matrix?
04:07:38 <DariusTheMede> https://hackage.haskell.org/package/hmatrix-0.20.0.0/docs/Numeric-LinearAlgebra.html#v:rcond\
04:07:48 <aplainzetakind> rcond: roughly 7e-25
04:07:58 <aplainzetakind> Ariakenom: 42x42
04:08:30 <aplainzetakind> Should I look for errors in my code or is likely to be a precision issue?
04:09:11 <DariusTheMede> aplainzetakind: that looks fine to me so we can't blame the matrix itself
04:10:16 <DariusTheMede> How big are the integers? Are you losing precision when you convert to floating point?
04:12:08 <aplainzetakind> Denominators are huge usually, n! where n~100
04:13:20 <DariusTheMede> Well you only get about 15 digits in double
04:14:18 <DariusTheMede> hmatrix is a binding to blas / lapack which I think is entirely floating point
04:15:31 <DariusTheMede> What library do the authors of the paper use?
04:15:34 <aplainzetakind> I think I might be able to multiply out all the denominators by something like 100! before conversion, let me see.
04:15:57 <aplainzetakind> The author says he did the computation in Mathematica.
04:16:47 <Ariakenom> 42x42 with [[Rational]] should work out fine I think?
04:19:05 <aplainzetakind> I got up to 4.0004 by multiplying out by a huge number.
04:19:54 <aplainzetakind> Ariakenom: How do you mean? Hand roll eigenvalue computations, etc?
04:20:17 <DariusTheMede> https://gitlab.haskell.org/ghc/ghc/issues/16130 but that was 8.6.3 and I was using 8.6.5
04:20:21 <Ariakenom> yeah
04:20:24 <DariusTheMede> Maybe the fix didn't make it
04:20:52 <Ariakenom> the library linear should work afaik
04:22:01 <DariusTheMede> I'd be interested to see how it copes
04:22:25 <aplainzetakind> I'll give it a shot. Thanks.
04:23:33 <DariusTheMede> What version of ghc should I try?
04:26:50 <Ariakenom> aplainzetakind: im not sure it's hte easiest. it's the first I found on hoogle
04:28:15 <ski> nil : no
04:29:03 <ski> (you're mixing up existentials and presuppositions. usually people would mix up universals and presuppositions, though, so i guess this is new)
04:31:45 <merijn> aplainzetakind: Sounds like you wanna be in #numerical-haskell ? :)
04:35:15 <nil> ski: not sure i understand :/
04:35:38 <nil> how would you alter my proposition? (or is it just fundamentally wrong?)
04:40:46 <aplainzetakind> merijn: I didn't know it existed, but I think I got this. The matrix A is of the form A=B^(-1)C, where B and C have very small entries but A not so much of course. So I'll form B^(-1)C using exact rationals with the matrix library, then convert the entries to Double and have hmatrix give me the eigenvalue.
04:51:58 <ski> nil
04:52:05 <nil> ski
04:52:14 <ski>   type NatTransf f g = exists f g. (Functor f, Functor g) *> forall a. f a -> g a
04:52:19 <rhylx> jgt: because, if I understand the thing correctly, first of all is trying to create a server, on which I can as a client create a chat room
04:52:24 <ski> makes no sense, would you agree ?
04:53:20 <ski> presumably when you asked for "general type of natural transformations", you meant "natural transformations from specified source/domain functor to specified target/codomain functor" ?
04:53:44 <ski> perhaps you meant something more like "any natural transformation, between any two functors"
04:54:28 <ski> in which case something like you wrote would make more sense. but one shouldn't be using a blind existential, in that case ..
04:54:31 <nil> oh yeah, it starts making sense once you remove the f and g parameters. type NatTransf = exists ...
04:55:03 <nil> that's what i meant, yeah
04:55:16 <ski> sometimes people will say that (e.g.) `sort' accepts an input of type `Ord a => [a]'. this is an example of what i meant by "mix up universals and presuppositions"
04:55:34 <nil> i understand that this is wrong
04:56:29 <ski> anyway, the default interpretation to me is "with specified source and target"
04:57:31 <jgt> rhylx: yeah, first you should get a decent understand of the request cycle. Send some data into the system, persist it, read the data out.
04:58:09 <ski> a presupposition is a condition on the well-formedness of something
04:59:04 <ski> in the sentence "The king of France is bald.", "There is a king of France." is a presupposition
04:59:28 <nil> i see
04:59:43 <ski> in some attempts to deal with the former, it would be elaborated into "There is a king of France, and he is bald.". however, i don't think this is a good idea
05:01:23 <ski> because the apparent negation of the former, "The King of France is not bald." would, according to this elaboration, become "There is a king of France, and he is not bald."
05:01:57 <ski> so, we break compositionality, in the sense that what appears as a negation doesn't yield two elaborations which are each others negations
05:03:28 <ski> so, at least in the context of math and programming, i prefer thinking of it as "The king of France is bald." being meaningless/illformed, unless we already know that "There is a king of France." holds
05:03:28 <aplainzetakind> Yes, I got exactly what's in the paper (7 significant digits).
05:03:53 <ski> similarly, `f(1/x)' is not well-formed, unless we know `x =/= 0'
05:04:13 <ski> what's nice, now, is that we can discharge presuppositions, iow they can be local, not only global
05:05:55 <ski> consider `Pi x : T. P x', which i'll write as `(x :) T -> P x'. this is wellformed if `T' is well-formed, and `P x' is well-formed under the assumption `x : T'
05:06:57 <ski> now, erase the name `x', exchanging `U' for `P x', getting `(_ :) T -> U', or just `T -> U', but *keep* the extra introduced condition
05:07:46 <ski> iow, `T -> U' is to be well-formed if `T' is well-formed, and `U' is well-formed under the assumption `_ : T', iow `T' is provable/true
05:08:24 <ski> similarly, `Sigma x : T. P x', iow `(x :) T /\ P x' is well-formed if `T' is, and `P x' is under the assumption `x : T'
05:08:51 <ski> and here we also get that `T /\ U' is well-formed if `T' is, and `U' is under the assumption that `T' is true
05:09:26 <ski> so you can state `x =/= 0 /\ f(1/x) > 1', and this *doesn't* have `x =/= 0' as a presupposition
05:09:36 <ski> (and now you can quantify `x')
05:10:03 <ski> nil : i hope that sufficiently explains what i mean by "presupposition", in this context
05:11:02 <Ariakenom> aplainzetakind: nice!
05:15:04 <nil> ski: i get the general idea; what are Pi and Sigma?
05:15:26 <aplainzetakind> Ariakenom, DariusTheMede: Thanks.
05:15:55 <ski> nil : dependent quantifiers
05:16:22 <nil> ski: right, i'll read up on those
05:16:39 <ski> you can think of them as being more or less `forall' and `exists'
05:17:06 <ski> only, you can bind not only type variables with them (as is the case in Haskell), but also value variables
05:18:50 <ski> nil : in any case, `exists f g. (Functor f, Functor g) *> forall a. f a -> g a' would not be of much use in Haskell, because of the "blind" nature of `exists' (and `forall') here
05:20:11 <ski> nil : if you have `forgotten :: exists a. a', then this isn't really any better than `forgotten :: ()', since you have no way to recover/discover which type was hidden behind the name `a'
05:20:18 <nil> "blind" in what sense? as in, no restriction about the kind?
05:20:30 <ski> (but there can be cases where that can be recovered, with GADTs, e.g.)
05:20:53 <nil> ah
05:20:54 <ski> blind in the sense that we allow type erasure in an implementation
05:21:37 <ski> also, there's no way to state that `forgotten.witness = Int' (or something like that)
05:22:04 <ski> we can't externally to `forgotten', refer to the witness part of the abstract value
05:22:30 * hackage linnet 0.3.0.0 - Lightweight library for building HTTP API  https://hackage.haskell.org/package/linnet-0.3.0.0 (sergeykolbasov)
05:23:02 <ski> (if `witness : T' and `proof : P witness', then one can derive `(witness,proof) : Sigma x : T. P x')
05:23:30 * hackage linnet-aeson 0.3.0.0 - Aeson JSON support for Linnet  https://hackage.haskell.org/package/linnet-aeson-0.3.0.0 (sergeykolbasov)
05:23:38 <ski> nil : however, in Agda, if you define an existential quantifier, then you can refer to the witness "externally", like this
05:24:30 * hackage linnet-conduit 0.3.0.0 - Conduit-backed support for streaming in Linnet  https://hackage.haskell.org/package/linnet-conduit-0.3.0.0 (sergeykolbasov)
05:28:40 <ski> (btw, the obvious kind of quantifiers that one'd like to add to e.g. C would also be blind in this way. e.g. something like `struct { typedef T; T *env; int (*foo)(T *env,size_t N,int *blah); }' in the existential case)
05:29:28 <fr33domlover> o/
05:30:44 <fr33domlover> Is there a common way to make my Haskell program installable to system dirs? Like, executable to /usr/bin or /usr/local/bin etc. and configs to /etc or .config and data to /var/lib or .local/share and so on
05:31:07 <nil> ski: ok
05:31:32 <fr33domlover> I've seen some hacky makefiles for that but I'm wondering if there's a common way to do this,
05:31:43 <fr33domlover> Using cabal/stack as much as possible ^_^
05:39:30 * hackage jvm-binary 0.6.0 - A library for reading Java class-files  https://hackage.haskell.org/package/jvm-binary-0.6.0 (kalhauge)
05:39:53 * fr33domlover sees relevant stuff in Cabal user guide, will try stuff
05:39:59 <s0lucien> Hello everyone ! Is it possible to pattern match functions?
05:40:36 <[exa]> s0lucien: how would that work?
05:41:31 <[exa]> s0lucien: (rigorous answer attempt: because the type ((->) a b) has (afaik) no data constructors, you can't patternmatch it)
05:41:41 <fr33domlover> s0lucien, if you need to pass and match against some set of functions, you could define a sum type to represent the choice
05:42:05 <fr33domlover> and then map each data constructor to the actual function etc.
05:42:36 <s0lucien> https://gist.github.com/s0lucien/47d9eeb4253980b6e45cb8f414b3f4ab
05:43:40 <s0lucien> i'm trying to write this functor for the last hour or so, but not sure how to go around matching the runSubsM function
05:44:57 <s0lucien> okay i understand it's not possible, i'll go around it some other way
05:45:26 <s0lucien> by running the function on some Context
05:45:45 <ski> s0lucien : put the lambda outside the `case'
05:46:14 <boxscape> s0lucien have you tried writing the Functor instance for ((->) e) before?
05:46:20 <[exa]> s0lucien: mathematical intuition: comparing functions is like comparing blackboxes. But you can delay the comparison a bit
05:46:54 <s0lucien> boxscape no i have not. any help is appreciated
05:47:17 <ski> a function of type `T -> Either U0 U1' needn't be of either the form `\x -> Left (f0 x)' or of the form `\x -> Right (f1 x)'
05:47:54 <boxscape> s0lucien I think trying to write that (which should be a bit easier) could give you some intuition for how to write this one
05:50:49 <boxscape> (or, somewhat more similarly to your actual problem, you could try writing an instance for newtype Reader e a = Reader (e -> a))
05:52:33 <s0lucien> the intention of the reader is to read elements of some type `e` and turn them into `a`s  ?
05:53:09 <boxscape> sort of. The intuition is that you have some environment `e`, and you can use info from that environment to make an a.
05:53:32 <s0lucien> okay i think i know how to do this one
05:54:00 * hackage lambdabot-xmpp 0.1.0.1 - Lambdabot plugin for XMPP (Jabber) protocol  https://hackage.haskell.org/package/lambdabot-xmpp-0.1.0.1 (SergeyAlirzaev)
05:55:44 <boxscape> s0lucien to be clear the actual instance is then "instance Reader e where", since a functor can only take a single argument (So `Reader e` is a Functor taking a as arguiment)
05:56:00 <boxscape> uh
05:56:12 <boxscape> `instance Functor (Reader e) where`, rather
06:02:23 <s0lucien> boxscape can I PM you ?
06:02:58 <boxscape> Don't actually have much time right now, sorry :/
06:03:12 <s0lucien> no worries, thanks !
06:03:14 <boxscape> (there should be plenty of people here who can help you though)
06:03:54 <ski> (it's generally considered better to ask in-channel because then (a) other people can suggest advice; and (b) other people can lurk and learn)
06:05:43 <s0lucien> alright, I found a nice article explaining the reader, so i'll read that carefully https://gist.github.com/twopoint718/c02164137c6fca9e0c4c
06:07:33 <boxscape> (In case you don't yet know what Applicative Functors or Monads are, don't bother reading those section of the article yet, s0lucien )
06:27:00 * hackage small-bytearray-builder 0.2.1.0 - Serialize to a small byte arrays  https://hackage.haskell.org/package/small-bytearray-builder-0.2.1.0 (andrewthad)
06:51:29 <merijn> Anyone know of projects with *really* complex optparse-applicative parsers? I'm trying to figure out how to make the help look appealing when you have subcommands with their own subcommands
06:52:59 <__monty__> Have to say I like git's approach of splitting it across manpages you can reach with git help.
06:53:50 <merijn> __monty__: I'm not talking about man pages or external documentation
06:54:23 <merijn> What I really want is the help to show (for each command) a group of (some of) the subcommands
06:55:47 <__monty__> No, I understand. Git's approach is to have git help subcommand just open up a manpage. Because there's far too much info to usefully fit in a terminal without paging.
06:56:05 <__monty__> Imo, any help message that overflows an 80x24 window is too long.
06:56:09 <merijn> That's kinda orthogonal
06:56:47 <merijn> My problem is: The optparse-applicative docs are not very clear how exactly the help message is constructed for complex parsers, so I wanna see examples of complex parsers so I can figure out how it works
07:10:18 <phadej> merijn: stack is one of extremes
07:10:29 <phadej> (of optparse-applicative users)
07:10:32 <phadej> even `haskell-ci`
07:12:51 <merijn> phadej: stack's parser creation looks...a bit horrific at quick glance xD
07:17:22 <phadej> yes
07:17:25 <phadej> it is
07:18:13 <merijn> phadej: haskell-ci's also looks rather complex and I can't really see/understand why?
07:18:35 <merijn> phadej: i.e. what's all the OptparseGrammar stuff for?
07:19:03 <maerwald> The only useful command line argument library I've seen (in any language) is "click" in python
07:19:24 <maerwald> Everything else I just tend to ignore and just write something up when I need it, because API is usually overloaded complexity
07:19:38 <merijn> maerwald: optparse-applicative is amazing, tbh. My main gripes are (ultimately) really superficial gripes about how the help is formatted/printed
07:20:31 <phadej> merijn: to have only one definition for configuration file / cli arguments
07:20:38 <phadej> -> and
07:20:40 <phadej> / -> and
07:20:45 <merijn> ah
07:23:28 <merijn> I guess I can actually get what I want if I can get the help output from a ParserInfo
07:23:47 <merijn> Because then I could just inline the parts I want into the output
07:25:24 <merijn> Ah, I think I can actually generate what I want with the stuff exported from Help to just generate (parts) of the help of my subcommands and inline
07:26:09 <pigmej[m]> Heya, I'm a bit lost (again...) if I have `IO Integer` how can I substract `Integer` from it? (or do some math with other `Integers`)
07:26:48 <pigmej[m]> IO Integer comes form `round <$> getPOSIXTime`
07:29:07 <pigmej[m]> all haskell "fun" ends with IO .... that's my impression
07:30:16 <merijn> pigmej[m]: With some practice you'll see through that and start to love IO :)
07:30:43 <pigmej[m]> So.... I need help with explaining it it seems
07:31:05 <merijn> pigmej[m]: The basic idea with IO is to stop thinking "how do I stuff "IO a" into some function I have?" but start thinking in terms of "pushing your pure functions into IO"
07:31:11 <pigmej[m]> I have a timestamp (Integer send over Json, works fine) and I want to compare it against current timestamp and do some logic against it (yes I know time skew etc)
07:31:28 <merijn> pigmej[m]: Presumably you know to write the pure logic of what you wanna do with that Integer, right?
07:31:38 <pigmej[m]> sure
07:31:57 <pigmej[m]> I even had it "hardcoded" and now I want to use real getPOSIXTime
07:32:17 <merijn> pigmej[m]: You just write "Integer -> Foo" containing whatever logic you need. And then "push" that pure logic into IO via (usually) fmap
07:32:19 <pigmej[m]> and for some reason I can't progress
07:32:50 <merijn> pigmej[m]: I mean, you even already do that with "round <$> getPOSIXTime", the only missing stuff is to (essentially) expand "round" to more complex logic :)
07:33:29 <merijn> so if you have "foo :: Integer -> Bar" just make if "foo . round <$> getPOSIXTime" (or "fmap (foo . round) getPOSIXTime")
07:34:58 <merijn> pigmej[m]: Now, probably you'll eventually end up with some type "Bar" that you want to print/output (like JSON or something), in which you probably have something like "Bar -> IO ()". How do you combine that with the "IO Bar" you get from your previous "just fmap pure logic into IO"? That's where:
07:35:03 <merijn> :t (>>=) -- comes in
07:35:04 <lambdabot> Monad m => m a -> (a -> m b) -> m b
07:35:16 <merijn> :t (>>=) `asAppliedTo` (undefined :: IO a)
07:35:18 <lambdabot> IO a -> (a -> IO b) -> IO b
07:35:55 <pigmej[m]> ok, so the solution essentially is to write shitload of small functions
07:36:34 <merijn> pigmej[m]: Well, whether you need a shitload depends on the problem, but "writing lots of small simple functions" is a pretty decent starting point for almost any problem :)
07:37:05 <pigmej[m]> my issue is that somehow I can't wrap my head around the IO vs non IO stuff
07:37:22 <merijn> @quote shachaf ls
07:37:22 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
07:37:48 <boxscape> pigmej[m]:  they're really simple functions, you don't need to explicitly define them either - ro example note how merijn wrote `foo . round` rather than making an extra function that calls both
07:37:54 <boxscape> s/ro/for
07:38:46 <merijn> pigmej[m]: This blogpost clears up a lot of common misconceptions about IO:  https://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity.html (i.e. how do purity and IO relate and why do we care?)
07:39:50 * pigmej[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/jFuxBlyZVUGKrmzXCbdCzQkv >
07:39:51 <pigmej[m]> wrrrrr
07:40:06 <pigmej[m]> https://gist.github.com/pigmej/cb3b917db84cc3ded946d011e828beca
07:40:36 <pigmej[m]> given that, how to make "st" `round `fmap` getPOSIXTime`
07:40:40 <pigmej[m]> crap
07:41:54 <pigmej[m]> given the code from the link (sorry for paste erros, something wrong with my xsel...) how can I modify it to be the same but st to be result of "round `fmap` getPOSIXTime"
07:42:50 <hyperisco> Haskero does not work with my multi-package project, only giving IDE support to one out of the two packages. Anyone have a fix?
07:43:23 <boxscape> pigmej[m]: convert your `if` expression into a function that takes st as an argument, then call `thatFunction . round <$> getPOSIXTime`
07:43:55 <merijn> pigmej[m]: That exact way can't/won't work. The way you'd structure it normally is to move you if expresion into a function "Integer -> ??" (where ?? is whatever you happen to want to do 
07:44:34 <merijn> pigmej[m]: Two options: 1) you only want to do something pure and your function becomes "Integer -> Foo", in that case use fmap as boxscape wrote to apply your logic to getPOSIXTime
07:45:22 <merijn> pigmej[m]: Option two, you want to do some IO as result of the posix time, then your function becomes "Integer -> IO Foo" you write your logic exactly as it is now and use >>= to apply it to getPOSIXTime
07:46:47 <merijn> The doSomething/doSomethingElse suggests you probably intend to do something IO-y (like print) so the latter is probably the most logical thing
07:47:48 <merijn> "processPOSIXTime st = if abs (dt - st) > 1 then doSth else doOther" and then "getPOSIXTime >>= processPOSIXTime" would "Just Work" (assuming 'doSth :: IO ()' and 'doOther :: IO ()'
07:48:20 <maralorn> Is there actually a list of all primitive IO operations in Haskell?
07:48:33 <merijn> pigmej[m]: Within the processPOSIXTime it's completely unimportant and invisible that the Integer you get comes from IO or not
07:48:41 <merijn> maralorn: Yes, no, maybe, it depends? ;)
07:48:55 <merijn> maralorn: It's actually possible to write new ones, so it's hard to say
07:49:07 <merijn> maralorn: So it depends on what you want to do
07:51:37 <pigmej[m]> ..
07:51:40 <pigmej[m]> ok will try to understand
07:55:05 <merijn> pigmej[m]: Minimal-ish example: https://paste.debian.net/1098926/
07:55:56 <merijn> pigmej[m]: By moving the logic into a function like that I separate the logic of "what do I do with a POSIXTime?" from the logic of "how do I get it?" (i.e. asking the system clock)
07:56:04 <pigmej[m]> ok,
07:56:30 <maralorn> merijn: I‘d like to say all "IO a" values are either in this list of primitive operations which ghc implements natively or a combination of those written in pure Haskell.
07:56:34 <pigmej[m]> I have no idea though wy it works :(
07:56:45 <pigmej[m]> I se ethat it does but without understanding
07:57:09 <merijn> pigmej[m]: Does the type of >>= make sense to you?
07:57:21 <merijn> :t (>>=) `asAppliedTo` (undefined:: IO a)
07:57:22 <lambdabot> IO a -> (a -> IO b) -> IO b
07:57:25 <maralorn> merijn: I realize that I probably need to include at least ffi somewhere in there, not sure.
07:57:38 <pigmej[m]> yeah that's easy
07:57:58 <pigmej[m]> I don't get why it does not complain about abs now
07:57:59 <merijn> maralorn: It's even worse, because GHC actually exposes the constructor of IO so you can write your own stuff via that, and you can also write your own Cmm primops directly
07:58:30 <maralorn> merijn: Have a pointer to how that works?
07:59:05 <merijn> maralorn: https://gitlab.haskell.org/ghc/ghc/wikis/commentary/prim-ops#foreign-out-of-line-primops-and-foreign-import-prim
07:59:24 <merijn> maralorn: Also, if you wanna dive into gory low level details, have you browsed ghc-prim?
07:59:34 <merijn> :t abs
07:59:36 <lambdabot> Num a => a -> a
08:00:19 <merijn> pigmej[m]: abs works on numbers (stuff like Integer, etc.) "IO Integer" is not "an integer" it's "a description of a program that, when run, will produce an Integer (somehow)"
08:00:31 * hackage describe 0.1.1.0 - Combinators for describing binary data structures  https://hackage.haskell.org/package/describe-0.1.1.0 (riuga)
08:00:52 <pigmej[m]> merijn Yeah I know, but then why it works :D
08:01:09 <merijn> pigmej[m]: You shouldn't think of "IO Foo" as "It's a Foo but some confusing IO around it" but think of it as "IO Foo is a recipe on how to create a Foo by doing some IO"
08:01:19 <merijn> Now, if we look at >>=
08:01:22 <merijn> :t (>>=)
08:01:24 <lambdabot> Monad m => m a -> (a -> m b) -> m b
08:02:02 <pigmej[m]> hmmm
08:02:06 <merijn> It says "given an 'IO a' (i.e. a recipe for making 'a') and a function 'a -> m b' (i.e. just a regular function), I will give you a new recipe for making 'b'"
08:02:14 <pigmej[m]> ok, so when I did IO (>>=) then it become real integer
08:03:01 <merijn> pigmej[m]: Right, the function on the right of >>= doesn't get an "IO Integer" it just gets "Integer", as long as it promises that the result of using that Integer is still IO
08:03:28 <maralorn> merijn: But primops do not need to be impure, do they?
08:04:04 <merijn> pigmej[m]: So basically, you can't get something "out" of IO, but you *can* take code that needs something non-IO and ask >>= "please combine these two"
08:04:11 <merijn> maralorn: They don't have to be, no
08:04:35 <merijn> @hackage ghc-prim -- maralorn
08:04:35 <lambdabot> http://hackage.haskell.org/package/ghc-prim -- maralorn
08:04:53 <merijn> maralorn: Lots of cool stuff there if you wanna look into compiler primitives, etc.
08:05:14 <merijn> Including stuff like SIMD vector instructions
08:05:53 <s0lucien> boxscape I managed to do it myself for the (Reader e) a , very insightful ! Thanks a lot! Now SubsM does not seem that intimidating
08:06:57 <EvanR> the SIMD stuff works?
08:07:11 <merijn> EvanR: I think you need to use the LLVM backend, but sure
08:07:22 <boxscape> s0lucien nice!
08:07:46 <merijn> EvanR: The main problem with the SIMD stuff is not so much "getting it working" but "getting a useful API that has good performance"
08:08:12 <merijn> EvanR: But if you're interested in that stuff you should ping carter in #numerical-haskell, he knows most of the "going on" stuff related to SIMD
08:08:58 <carter> And works sanely across different cpus
08:09:38 <carter> Turns out simd code that is performant is literally the only thing that matters :)
08:09:38 <maralorn> merijn: Well I was actually wondering about something a little different. I hoped that I could somehow formalize IO as "a programing/instruction language" and tried to get a feeling from where the atomic operations in that language come.
08:10:04 <carter> Atomic in which sense ? CPU or physics or semantics or logic or concurrency ?
08:10:06 <merijn> maralorn: Ah, that's actually super hard :p
08:10:35 <merijn> maralorn: There's no real formal semantics of what IO even means :)
08:10:39 <EvanR> that is what i meant, like, actually maps to real SIMD instructions
08:10:48 <maralorn> carter: Semantics I guess?
08:11:14 <carter> maralorn: ask me next week and I or merijn can give you some good quality reading on semantics
08:11:25 <merijn> maralorn: This may be interesting: https://hackage.haskell.org/package/ghc-prim-0.5.3/docs/GHC-Types.html#t:IO
08:11:28 <carter> Gotta finish some simple fancy stuff for work
08:11:55 <merijn> maralorn: Also there's the "Lazy Functional State Threads" paper which is somewhat related
08:12:27 <maralorn> merijn: Oh that constructor is nice to read.
08:12:43 <merijn> maralorn: The implementation (note, implementation, not semantics) of IO is basically just "tracking and enforcing computational dependencies"
08:13:29 <merijn> maralorn: The Lazy Functional State Threads paper is the one that explains ST and briefly covers the fact that both IO and ST in Haskell or just thin specialisations of State# which is a sort of "primitive level State monad"
08:14:00 * hackage data-interval 1.3.1 - Interval datatype, interval arithmetic and interval-based containers  https://hackage.haskell.org/package/data-interval-1.3.1 (MasahiroSakai)
08:14:09 <merijn> maralorn: You could also ask around in #ghc or on the ghc-devs/haskell-cafe mailing list if anyone has more pointers
08:14:39 <maralorn> merijn: When I look at the prim source file I only see type declarations. Where are the actually implementations of that function?
08:14:43 <maralorn> *functions
08:15:00 <merijn> maralorn: Inside the compiler, that's why they're primitive ;)
08:15:35 <merijn> maralorn: The implementation of wired in primitives is "this name is hardcoded in the compiler so it knows what to generate for this"
08:16:29 <merijn> And they way you create new ones is "just write code in the compiler to do so" (although the Cmm and C FFI interfaces basically let you add things without modifying the compiler, since the compiler knows how to generate boilerplate for interacting with that code)
08:16:34 <maralorn> merijn: I guess they are actually defined in the specific backend? i.e. ghcjs needs to define them all on it’s own?
08:16:44 <merijn> maralorn: Essentially, yes
08:16:56 <merijn> maralorn: Parts of them are defined in the runtime system
08:17:40 <merijn> maralorn: The problem with primitives is the harder you look where they are, the fuzzier it gets ;)
08:19:42 <maralorn> So merijn, can I conclude that every "primitve" IO is either a primop or an ffi implementation? Or is making an ffi call also just an IO operation?
08:20:04 <merijn> I don't know the answer to that question or whether it even has one :)
08:21:09 <carter> maralorn: what makes forks and spoons forks and spoons. 
08:21:30 <carter> At some point definitions and axioms are whatever you define them to be.  Subject to self consistency
08:22:46 <maralorn> Well Haskell should not only be (somewhat) consistent, but it actually has to run.
08:24:08 <pigmej[m]> merijn ok but what you shown kinda more or less works only in IO functions anyway... so I'm still having kinda the same issue but in other place now
08:24:19 <pigmej[m]> I think I need more learning first because I have a feeling that I lack sth..
08:24:31 <merijn> pigmej[m]: Did you read the blogpost I linked?
08:25:55 <pigmej[m]> not yet
08:27:08 <maralorn> merijn: Well it seems to me that FFI actually has it‘s own syntax and it also generates IO values. So now I know about at least two ways to generate a primitive IO value. primops and ffi. https://wiki.haskell.org/FFI_Introduction
08:28:44 <AviD> (unsafeCoerce (unsafeCoerce (1::Int) :: String) :: Int) Is this safe? What if  the String is stored in a structure, but only used after being coerced back into an Int?
08:29:35 <Taneb> AviD: I believe it's not safe
08:30:44 <Taneb> Int -> Any -> Int works (and Any is a special type for pretty much this purpose)
08:31:44 <dmj`> pigmej[m]: what's good
08:32:12 <glguy> The behavior of unsafeCoerce on GHC is available here: http://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Exts.html#v:unsafeCoerce-35-
08:34:06 <isovector1> does TH always force recompile? can i prevent it from doing that?
08:36:17 <pigmej[m]> I'm affraid that I have to give up with Haskell for now
08:36:29 <pigmej[m]> It seems that I have waaaaaaaaaaaay too less time to spare to learn it ;/
08:46:27 <pigmej[m]> I was hoping that I will be able to learn it gradually but seems that not ;D
08:46:30 * hackage semirings 0.5 - two monoids as one, in holy haskimony  https://hackage.haskell.org/package/semirings-0.5 (chessai)
08:47:47 <dmj`> pigmej[m]: you can't give up
08:47:53 <dmj`> pigmej[m]: you gotta do it, you're so close
08:49:19 <dmj`> pigmej[m]: just let ghc slap you around until it makes sense
08:49:54 <pigmej[m]> I have literally 2h per day to play with it :) It would take infinite amount of time to complete something usefull
08:51:04 <EvanR> if you find it interesting enough the 2h will grow
08:51:20 <EvanR> perhaps at the detriment to your friends and family : )
08:51:31 <pigmej[m]> yeah
08:54:18 <pigmej[m]> the thing is that it's interesting but the more I use it the more feeling I have that it's "useless" :D
08:55:03 <EvanR> you're not far off https://www.youtube.com/watch?v=iSmkqocn0oQ "SPJ Haskell is Useless"
08:55:17 <pigmej[m]> I saw that :)
08:55:48 <Cale> pigmej[m]: I work at a company where we use Haskell to build web and mobile applications for a variety of clients.
08:56:24 <dmj`> pigmej[m]: what part did you get stuck on, servant is pretty dead simple, just define some types and it works
08:56:41 <pigmej[m]> dmj` it works fine
08:56:53 <pigmej[m]> the problem is with "the other part" I have to do some MQ stuff (Nats probably) etc
08:57:02 <pigmej[m]> servant part works fine.
08:57:06 <dmj`> pigmej[m]: messaging queue ?
08:57:12 <pigmej[m]> yeah
08:57:13 <dmj`> what is MQ here
08:57:26 <pigmej[m]> so parallel / concurrent stuff is the next part
08:57:32 <dmj`> which message queue service were you thinking of using
08:57:36 <pigmej[m]> (I have it already semi working)
08:57:37 <pigmej[m]> Nats
08:57:57 <pigmej[m]> the problem is that to write even simple thing it takes 10x more than even in rust
08:58:08 <dmj`> @package nats-queue
08:58:08 <lambdabot> http://hackage.haskell.org/package/nats-queue
08:58:13 <dmj`> pigmej[m]: does this guy work?
08:58:42 <pigmej[m]> yes
08:58:46 <pigmej[m]> and there is one other which also works
08:58:56 <dmj`> pigmej[m]: yea I'd just copy and paste the example code, looks good to go
08:59:04 <ski> pigmej[m] : learning a new programming paradigm will naturally be more like learning to program all over again, from scratch, than like learning a programming language in a paradigm you already know
08:59:05 <dmj`> pigmej[m]: so sounds like it all works
08:59:32 <poultrylabour> pigmej[m]: Haskell may not be used as much as other programming languages outside of academia, but there are countless projects that are using it (pandoc, purescript, compiler-explorer to name a few)
08:59:57 <dmj`> pigmej[m]: it sounds like you're having a wild success
09:00:01 <pigmej[m]> ski: Well... I can do multiple languages (even FP) but only haskell makes me super frustrated
09:00:20 <ski> that may indicate you have more to learn, then
09:00:36 <poultrylabour> pigmej[m]: I actually find it easier to read (and understand) than Python
09:00:49 <pigmej[m]> I can't imagine that one... :)
09:01:13 <ski> i've heard several people in here say they're using Haskell, because they're too dumb to use Python (e.g.)
09:01:35 <Cale> Me as well, but I haven't really written significant amounts of code in an imperative language in over a decade.
09:01:39 <pigmej[m]> well python is dynamic and interpreted so you know...
09:01:55 <dmj`> pigmej[m]: (->), Maybe, Identity, State, Reader, Writer, Either, [] if you can do Functor, Applicative and Monad on these guys you'll be a lot less frustrated
09:02:17 <dmj`> pigmej[m]: just do it all from scratch, and you'll have many a-hah moments
09:02:23 <Cale> The thing about trying to write code in something like python is that you have to keep all the types in your head because the compiler isn't going to make sure anything makes sense for you.
09:02:27 <glguy> My experience using Python is that it's extremely frustrating figuring out what the behaviors of different classes are, what methods are available, what kind of value I can expect to get as a return value from a method, what kind of values the methods accept
09:02:42 <glguy> lots of hand-written documentation that doesn't really tell me how to use packages
09:03:19 <Cale> In Haskell, I can write something approximate, and the compiler will often tell me if it's rubbish, or there's some step which is missing.
09:03:48 <poultrylabour> To be fair, Python is my favourite imperative programming language... but debugging is so much easier in haskell...
09:04:02 <pigmej[m]> thats probably true :)
09:04:07 <Cale> This is extremely useful if I'm working on code that I'm unfamiliar with (which I do all the time, because I'm working with other people)
09:05:10 <dmj`> pigmej[m]: what part gets your frustrated the most
09:05:12 <dmj`> you*
09:06:12 <dmj`> pigmej[m]: just drill yourself with these exercises https://wiki.haskell.org/All_About_Monads
09:06:35 <pigmej[m]> Purity vs Impurity
09:07:41 <dmj`> pigmej[m]: like, you just want to print in places where you're unable to
09:08:08 <Cale> pigmej[m]: Are you familiar with how the IO type works generally?
09:08:28 <pigmej[m]> to me all the haskell "magic" wanishes when there is IO involved
09:08:32 <Cale> Like, that IO String is to String what /bin/ls is to a list of files in your home directory?
09:08:42 <pigmej[m]> dmj` or yeah "debug print" in some places
09:08:44 <pigmej[m]> etc.
09:09:00 * hackage lambdabot-xmpp 0.1.0.2 - Lambdabot plugin for XMPP (Jabber) protocol  https://hackage.haskell.org/package/lambdabot-xmpp-0.1.0.2 (SergeyAlirzaev)
09:09:04 <Cale> You can use Debug.Trace.trace to do some quick hacky debug printing
09:09:32 <pigmej[m]> I learned that already :P but yeah
09:09:38 <dmj`> pigmej[m]: are you using a REPL, like emacs haskell-mode, what's your situation
09:09:45 <dmj`> from an IDE perspective
09:09:57 <pigmej[m]> emacs with dante
09:10:03 <poultrylabour> Ah... that reminds me... emacs vs vim?
09:10:04 <pigmej[m]> because... all other are broken
09:10:06 <pigmej[m]> because of cabal 3
09:10:20 <pigmej[m]> ghc simple for vscode works with it too
09:10:21 <Cale> Usually the main thing you want to use trace for is to get the arguments to a function so you know how it's being applied when it's not working
09:10:39 <pigmej[m]> That's an easy part
09:10:41 <EvanR> the cool part of IO is that haskell magic still works
09:10:44 <Cale> So something like a guard that will always fail and prints a trace can be a convenient thing
09:10:47 <pigmej[m]> i have tooltips in emacs or error buffer
09:10:52 <dmj`> pigmej[m]: that sounds good, are you using C-c C-l to send to repl, haskell-interactive 
09:11:08 <pigmej[m]> but just the problem that I had, I've spend like 1h trying to pass timestamp
09:11:15 <pigmej[m]> dmj` from time to time
09:11:24 <Cale> foo x y z | trace (show ("foo",x,y,z)) False = undefined
09:11:32 <pigmej[m]> but I rather build stuff
09:11:42 <dmj`> pigmej[m]: what was the type error
09:11:57 <dmj`> oh, like Data.Time.getCurrentTime ?
09:12:01 <dmj`> but it's in IO
09:12:02 <pigmej[m]> no
09:12:05 <pigmej[m]> getPOSIXTime
09:12:07 <pigmej[m]> I know
09:12:14 <pigmej[m]> and i've spend shitload of time trying to pass it
09:12:30 <Cale> It shouldn't be harder than passing an argument of any other type...
09:12:39 <pigmej[m]> well
09:12:44 <dmj`> getPOSIXTime >>= \posixTime -> print (yourPureFunctionThatDoesSomething posixTime)
09:13:04 <dmj`> pigmej[m]: is this with your web server?
09:13:10 <pigmej[m]> I had to substract it from Integer ;)
09:13:12 <pigmej[m]> and then all the fun started
09:13:38 <pigmej[m]> yeah I'm trying to compare current timestamp against timestamp sent in json data
09:13:49 <dmj`> pigmej[m]: this is a very good haskell time tutorial: https://two-wrongs.com/haskell-time-library-tutorial.html
09:13:51 <Cale> ah, it gives you a POSIXTime
09:14:10 <Cale> which is apparently a synonym for NominalDiffTime
09:14:13 <pigmej[m]> so I wrote a stuff with "hardcoded" timestamp as :: Integer
09:14:24 <pigmej[m]> then it was complete waste of time
09:14:26 <Cale> and so you just have to convert your Integer to a NominalDiffTime
09:14:28 <pigmej[m]> because I did it wrong
09:14:44 <Cale> which should be doable with fromIntegral
09:15:04 <Guest65973> hello. I have some state and I want to iterate over a traversable with it and update it and stop based on an arbitrary condition and return the final state. Right now I'm using the State monad and foldr but is there another way?
09:15:23 <pigmej[m]> well not really Cale
09:15:31 <pigmej[m]> I've been given https://paste.debian.net/1098926/ this as example
09:15:36 <EvanR> the time types really stand out as making more sense in haskell than ye olde popular scripting language
09:15:37 <Cale> Provided it's in seconds
09:16:06 <pigmej[m]> https://gist.github.com/pigmej/cb3b917db84cc3ded946d011e828beca
09:16:14 <dmj`> Guest85317: could probaly do it with a lens
09:16:37 <Cale> pigmej[m]: Ah, you went the other way with round
09:16:39 <EvanR> you will be so frustrated going back to "everything is some DateTime that can be added subtracted scaled and mutated field by field"
09:16:43 <pigmej[m]> Cale so I've had that, and i've literally spend hour trying to alter the code
09:16:59 <Guest85317> dmj`: I guess this is a good time to learn about lenses
09:17:05 <Cale> pigmej[m]: fromIntegral :: Integer -> POSIXTime
09:17:28 <pigmej[m]> getPOSIXTime is IO Integral
09:17:42 <Cale> It's IO POSIXTime
09:18:09 <Cale> What's the type of dataTimeGen?
09:18:20 <Cale> Perhaps it can just produce a POSIXTime in the first place
09:18:49 <Cale> If it currently produces an Integer, you can convert that integer to POSIXTime with fromInteger/fromIntegral
09:19:09 <pigmej[m]> it's integer from Json
09:19:59 <dmj`> Guest39039: what is the type you're trying to traverse over
09:20:10 <dmj`> Guest85317: **
09:20:31 <dmj`> pigmej[m]: are you using aeson?
09:20:46 <pigmej[m]> sure
09:20:48 <pigmej[m]> I know I can convert
09:20:57 <pigmej[m]> but it's not about solving that issue in particular
09:21:04 <Cale> pigmej[m]: Does this code not work for some reason?
09:21:12 <pigmej[m]> its about group of problems that are similar and solving them seems to be super duper PITA
09:21:17 <Cale> hmm
09:21:21 <pigmej[m]> which one?
09:21:27 <Cale> the one you linked
09:21:29 <pigmej[m]> the one from debian paste?
09:21:32 <Cale> yeah
09:21:47 <pigmej[m]> it moves my problem to other places
09:21:48 <pigmej[m]> :D
09:21:56 <pigmej[m]> because then these functions are IO
09:21:59 <Cale> What problem are you having now?
09:22:05 <Cale> Well, they do I/O, so that's natural
09:22:19 <EvanR> fromIntegral, realToFrac, and floor are pretty much all you need to know about converting numbers
09:22:24 <Cale> What does the program you're trying to write do?
09:23:15 <Cale> Note that you can apply any pure functions you write from the IO actions, so it's easy to get back into writing code that doesn't involve IO
09:23:19 <pigmej[m]> let's say that it receives some json data with stock infos and then does some "math" then sends it to other stuff via message queue
09:23:40 <Cale> So, the thing you want to send depends on some math
09:24:01 <Cale> The math probably is a pure function, the sending will be part of the IO action you're writing there
09:24:11 <pigmej[m]> and that part works flawlessly because yeah writing PURE stuff in haskell is neat
09:24:22 <pigmej[m]> but when it clashes with IO it smells like doing hacks
09:24:31 <Cale> Nah
09:24:39 <Cale> Haskell is pretty great at effectful stuff too :)
09:24:46 <bno1> dmj`: A Data.Sequence. To be more specific, I have a Seq containing prime numbers and I want to factorize an integer. I traverse the primes Seq, divide the integer when I find a factor and recompute the limit for stopping. I stop traversing when a factor exceeds the limit
09:26:03 <Cale> It's just that you have to express how the effectful stuff works a little differently because it's important to keep track of the order in which actions are taking place for instance. So we use a data type IO that can encode the effects and what order they should happen in explicitly.
09:27:05 <Cale> A function Integer -> IO String is still "pure" in the sense that for each Integer, you'll get the same IO String action -- but then the resulting String when you run that action might be different each time.
09:27:37 <dmj`> pigmej[m]: are you trying to compute the amount of time that has transpired from receiving quotes to what the machine reports ?
09:28:38 <pigmej[m]> no
09:28:39 <pigmej[m]> :)
09:28:41 <dmj`> bno1: yea I'd probably just define a recursive function
09:28:44 <pigmej[m]> more like "is that data in json still actual or wtf"
09:29:12 <pigmej[m]> because I had problems with laggy network in the past so sometimes I was receiving newer reports first
09:29:43 <sm[m]> That time tutorial is pretty nice, indeed
09:29:54 <pigmej[m]> and then some old dangling stuff. So timestamp is added as protection there
09:29:55 <pigmej[m]> a crappy one but better than nothing :)
09:31:28 <bno1> dmj`: that would be easy with a list, but for Seq the constructors are hidden and indexing has log complexity, so the most efficient option is traversing it and stopping somehow. State monad + foldr work well, I'm just curious if there is something simpler
09:32:28 <dmj`> bno1: why put the primes in a Seq.
09:32:56 <pigmej[m]> other super cryptic thing is
09:32:56 <dmj`> pigmej[m]: that's cool, you can unpack the Text to a String and use parseTimeM 
09:33:04 <dmj`> to make a UTCTime
09:33:10 <dmj`> then diff it with getCurrentTime
09:33:11 <pigmej[m]> given https://paste.debian.net/1098926/ I have honesly no idea how to add more arguments to processPOSIXTime
09:33:39 <dmj`> getPOSIXTime >>= processPOSIXTime arg1 arg2
09:34:01 <pigmej[m]> and then ghc complains about IO again ; D
09:34:13 <dmj`> processPOSIXTime :: a -> b -> POSIXTime -> IO ()
09:34:20 <dmj`> pigmej[m]: it shouldn't
09:35:38 <bno1> dmj`: because I generate them with a sieve algorithm that can be invoked multiple times to generate more primes, so I want fast appending (because the primes have to be ordered when using them). Alternatively, I could use a Vector or Array
09:35:49 <sm[m]> pigmej: for faster help, include the compiler error with your paste
09:35:50 <pigmej[m]> as I was saying, I can add IO everywhere
09:36:07 <pigmej[m]> but then I'm effectively moving my issue to other place
09:36:08 <pigmej[m]> ;D
09:38:58 <sm[m]> re IO.. a strategy is to get it compiling, then look for ways to refactor.. you will find places to move things out of IO, and gradually your code will take a natural shape
09:39:30 <sm[m]> with more practice, you’ll write it optimally the first time
09:42:00 <sm[m]> Having a live hlint running on your code is another good source of tips
09:42:43 <pigmej[m]> I do have it
09:42:43 <pigmej[m]> :)
09:43:05 <sm[m]> pigmej++ !
09:43:32 <pigmej[m]> for example I'd love to have: https://gist.github.com/pigmej/ba772a2e863d59ace5ad0bd4c7186802
09:43:37 <pigmej[m]> but obviously it will not work
09:43:52 <pigmej[m]> (I have no idea YET how to fix it though)
09:44:31 <sm[m]> You wouldn’t really love it, because then you’d have random side effects possible throughout your codebase :)
09:44:36 <pigmej[m]> https://gist.github.com/pigmej/35cc1a7011a20bbc19ef61101036e009 with errors
09:44:38 <ski> (`hlint' can be opinionated)
09:47:58 <pigmej[m]> and the problem for me is to understand / feel how to fix it
09:57:14 <pigmej[m]> I seem to fail to see a pattern
09:57:16 <pigmej[m]> Basically
09:59:22 <Cale> pigmej[m]: Well, if you have an IO thing, and you want a thing, then you probably want to execute the IO action to get its result
09:59:58 <Cale> pigmej[m]: Oh, the problem is that processItems produces a Bool
10:00:27 <Cale> pigmej[m]: If that is indeed what you want, you don't need >>=
10:00:34 <Cale> pigmej[m]: You can write something like
10:00:47 <Cale> processData :: SendData -> IO Bool
10:00:50 <Cale> processData = do
10:00:57 <Cale>   now <- getPOSIXTime
10:01:09 <Cale>   return (processItems sdata now)
10:01:29 <EvanR> sdata variable not found
10:01:43 <Cale> oh, oops, yeah, that's supposed to be an argument to processData there
10:01:51 <Cale> processData sdata = do
10:02:16 <sm[m]> pigmej: it’ll get easier with a little more practice. GHC is telling you there’s an IO line in processData, which doesn’t have an IO type signature. (Because getPOSIXTime is IO.) That makes sense I expect.
10:02:16 <sm[m]> This is telling you that processItems, and processData, must be in IO. Which is actually the truth.
10:02:41 <Cale> processItems doesn't need to be (at least unless dataTimeGen does IO)
10:02:56 <Cale> But processData executes getPOSIXTime, so it certainly does
10:03:56 <pigmej[m]> Well I know I can make it all IO
10:04:10 <Cale> processItems doesn't look like it does IO to me
10:04:13 <pigmej[m]> But thats what i said, it’s moving my issue to other functions
10:04:16 <Cale> So its type is fine
10:04:32 <pigmej[m]> So i’ll endup with the same issue in other places
10:04:39 <Cale> processData does IO, in the form of getting the current time, so it's going to have IO in its type
10:04:56 <Cale> If you don't want it to have IO in its type, well, you can delete it and just use processItems instead.
10:05:15 <Cale> (but eventually you'll need to get a POSIXTime from somewhere!)
10:05:48 <Cale> Even if that's just at the top of main
10:06:06 <pigmej[m]> Brb
10:06:49 <sm[m]> a strategy is to get it compiling, then look for ways to refactor.. you will find places to move things out of IO, and gradually your code will take a natural shape. Don’t worry about it all being in IO to start.
10:08:12 <Cale> Well, thinking about what actually ought to be in IO or not is probably good
10:08:26 <Cale> If a function doesn't do any IO at all, its type shouldn't say that it does
10:09:32 <Cale> You can always let-bind its result inside of the do-block for another IO action
10:09:33 <sm[m]> it can be more enjoyable to think about that when you have running code
10:09:53 <ski> (and don't do `foo :: IO Blah -> IO Bleh; foo act = do blah <- act; ..blah..', just do `foo :: Blah -> IO Bleh; foo blah = do ..blah..')
10:11:48 <Cale> Yeah, it's pretty rare to need to write a function which takes another IO action as an argument, often beginners will do that accidentally. It can be very useful in general though -- you can build your own control structures that way.
10:25:32 <iqubic> how is life for you all?
10:27:31 <int-e> ongoing
10:31:15 <maerwald> Cale: it's like callbacks :)
10:45:19 <iqubic> Callbacks are hell
10:49:45 <maerwald> you don't like 'bracket'?
10:49:45 * hackage constr-eq 0.1.0.0 - Equality by only Constructor  https://hackage.haskell.org/package/constr-eq-0.1.0.0 (kelemzol)
11:01:38 <iqubic> what is bracket?
11:01:49 <shapr> :t bracket
11:01:51 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
11:01:54 <shapr> @src bracket
11:01:54 <lambdabot> bracket before after thing = block $ do
11:01:54 <lambdabot>     a <- before
11:01:55 <lambdabot>     r <- catch (unblock (thing a)) (\e -> after a >> throw e)
11:01:55 <lambdabot>     after a
11:01:55 <lambdabot>     return r
11:02:02 <shapr> :index bracket
11:02:28 <shapr> ok, I forget the command that finds the cabbage associated with the function
11:02:36 <lavalike> @index bracket
11:02:36 <lambdabot> Control.Exception.Base, Control.Exception, System.Console.Haskeline.MonadException, System.Console.Haskeline
11:02:37 <lavalike> you had it
11:02:55 <cocreature> huh, did we ever have block/unblock instead of mask and this is just terribly outdated or is this just wrong?
11:03:11 <exarkun> aaaaaa.  I need to make trivialIssue return an IO now but https://github.com/PrivateStorageio/PaymentServer/blob/master/test/SpecRedemption.hs#L143-L154 am I totally screwed again
11:03:26 <shapr> lavalike: thanks
11:04:35 <lavalike> exarkun: what is screwing you?
11:04:55 <exarkun> I'm not smart enough to use QuickCheck and Servant and IO at the same time
11:05:10 <exarkun> or maybe s/Servant/Wai/
11:05:39 <exarkun> I don't know how to have the lambda on line 145 be allowed to return IO
11:06:19 <exarkun> `property` doesn't work with IO.  `monadicIO` works with `IO`.  `monadicIO` doesn't work with Wai.
11:07:15 <lavalike> hmm https://www.stackage.org/haddock/lts-14.4/QuickCheck-2.13.2/Test-QuickCheck.html#v:ioProperty
11:07:49 * exarkun boggles
11:08:07 <lavalike> fair
11:10:28 <exarkun> that would have been nice but it also doesn't work with Wai
11:10:55 <lavalike> wai, why
11:11:43 <exarkun> or Servant?  Or Hspec?  I can't really tell.  https://gist.github.com/exarkun/14fa94742c7dcddab40b0510f0c1087c
11:12:26 <exarkun> because "Arg Property" isn't "Application" but I couldn't say where any of those things come from...
11:13:07 <lavalike> ping: cannot resolve gist.github.com: Unknown host
11:13:18 <lavalike> I don't know what to say
11:13:40 <lavalike> ah it fixed itself, spooky
11:13:52 <exarkun> ~~~ asynchronous networks ~~~
11:15:42 <lavalike> ok so ioProperty expects an IO action that returns a prop, not a prop that returns an IO action
11:16:25 <lavalike> try feeding ioProperty with a do block that returns a lambda of the correct type
11:19:33 <exarkun> Where "prop" means "an instance of Testable" (not, say, a Property), right?
11:20:04 <lavalike> exarkun: exactly
11:20:04 <exarkun> What does the lambda that's there now return?  I guess it returns whatever propertyRedeem returns... which is a WaiExpectation
11:20:11 * exarkun goes to look up what a WaiExpectation is again
11:20:20 <jamestmartin> how can I debug a `<<loop>>`? I've tried using `stack run --trace`, but that's been running for some minutes now and still hasn't returned anything.
11:20:29 <exarkun> a WaiSession () of course
11:20:34 <exarkun> here's where I lose the plot
11:20:56 <exarkun> oh but forget WaiSession.  WaiExpectation has a Testable instance.
11:21:10 <exarkun> oh nooo
11:21:13 <exarkun> it doesn't
11:21:35 <exarkun> it has a Test.Hspec.Wai.QuickCheck.Testable instance
11:21:42 <exarkun> which is not in any way the same thing?
11:21:48 <lavalike> mumble
11:21:52 <iqubic> :t monadUnliftIO
11:21:54 <lambdabot> error: Variable not in scope: monadUnliftIO
11:22:58 <lavalike> class Testable a where toProperty :: a -> WaiProperty
11:23:10 <lavalike> data WaiProperty = WaiProperty {unWaiProperty :: Application -> Property}
11:23:48 <lavalike> unWaiProperty . toProperty :: a -> Property -- may be
11:24:34 <lavalike> must say making different a class with the same name is somewhat rude, but there seems to be the escape hatch
11:24:36 <exarkun> so I can get a Test.QuickCheck.Property (which has a Test.QuickCheck.Testable instance) from a Test.Hspec.Wai.QuickCheck.Testable by using unWaiProperty . toProperty
11:24:45 <exarkun> lavalike: okay I'm glad I'm not the only one who thinks that is rude
11:24:52 * lavalike nods
11:25:24 * exarkun tries it
11:26:50 <exarkun> Hm
11:28:05 <exarkun> but I don'
11:28:05 <exarkun> t have an Application?
11:28:27 <exarkun> `unWaiProperty :: Application -> Property` instead of `:: WaiProperty -> Property`
11:29:25 <lavalike> what do you have
11:30:21 <exarkun> Test.Hspec.Core.Example.Arg Test.QuickCheck.Property.Property
11:30:24 <aisn> Anyone using emacs with intero? I keep having this problem https://paste.ubuntu.com/p/bJhJR4WP9f/ not sure what to do about it, as i tried reinstalling the intero package, cleaning stack.yaml.lock, tmp/intero* etc. 
11:31:36 <Zer0xp> Why doesn't this work ? 
11:31:36 <Zer0xp> prime p = 2 : [a | a <- a `mod` [a-1,a-2..2] /= 0]
11:31:56 <gentauro> Zer0xp: shouldn't it be recursive?
11:32:34 <gentauro> I'm guessing that you aim to implement "Sieve of Eratosthenes" amirite?
11:32:59 <Zer0xp> gentauro: So that isn't recursive ?
11:33:15 <exarkun> it looks like `unWaiProperty . toProperty == property`
11:33:22 <lavalike> yeah
11:33:54 <gentauro> Zer0xp: you are never calling `prime` so I'm guess not ...
11:36:16 <gentauro> the way to implement natural numbers can be done as: `nat = 1 : map (+ 1) nat`
11:36:16 <gentauro> it might give you a hint ;)
11:37:01 <Zer0xp> gentauro: Okay what about this one. prime p = [n | n <- [2..], product [1..n-1] `rem` n == n-1]
11:38:06 <lavalike> exarkun: my head is spinning but I noticed wai's hspec example has with outside and describe (and shouldRespond) inside https://github.com/hspec/hspec-wai#readme
11:38:32 <lavalike> oh you have multiple levels of with
11:38:57 <lavalike> but that doesn't really matter, nevermind
11:39:08 <exarkun> they aren't supposed to overlap with each other, just provide different apps to different parts of the spec
11:39:35 <exarkun> (which I don't really like either, it's all a consequence of this exact difficulty)
11:40:43 <exarkun> If ioProperty really works for regular IO / Testable interaction then it seems like someone has to implement the equivalent of ioProperty for IO / Test.Hspec.Wai.QuickCheck.Testable?
11:40:59 <exarkun> I briefly glanced at the implementation of ioProperty and quickly looked away.
11:43:20 <lavalike> "ioRose" 🌹 
11:43:42 <exarkun> or could I write a Test.Hspec.Wai.QuickCheck.Testable instance for WaiExpectation?
11:44:06 <exarkun> Ugh, all I'm doing is making wild guesses
11:44:12 <exarkun> I'm clueless
11:44:30 * exarkun tries to find out what "Test.Hspec.Core.Example.Arg Test.QuickCheck.Property.Property" is
11:44:55 <exarkun> Arg is a "type family", great :/
11:45:02 <comerijn> tbh, this is why I dislike hspec, so much typeclass pseudo DSL nonsense it's hard to figure out what it's actually doing
11:45:20 <lavalike> it really is jiminy cricket
11:46:02 <gentauro> Zer0xp: I dunno. I implemented a few months ago like this -> http://blog.stermon.com/articles/2019/02/12/haskell-pretty-printed-primes-sieve-of-eratosthenes.html
11:46:09 <gentauro> (no list comprehension though)
11:46:47 <exarkun> merijn: What do you use?
11:46:50 <dmj`> hspec is really just a wrapper around IO
11:46:57 <merijn> exarkun: tasty
11:47:23 <dmj`> Arg is a type family in hspec that can create a function that has an argument to IO, or IO itself
11:48:00 <shapr> is there a collection of generic test suites for hspec, hedgehog, and others?
11:48:21 <merijn> shapr: What do you mean?
11:48:45 <dmj`> shapr: there's a project that can generate tests for functor, monad, etc. and other instances of classes on your types
11:48:57 <dmj`> chessai: ping
11:49:25 <shapr> I think I want a generic hspec demo that I can easily modify and add my own tests
11:49:36 <shapr> same for the other major testing frameworks
11:49:41 <chessai> dmj: ping
11:49:45 <chessai> whats up?
11:49:50 <chessai> oh you mean knuckles
11:49:53 <dmj`> chessai: what's that project you use
11:49:54 <dmj`> yea
11:49:57 <dmj`> that one
11:50:16 <chessai> yeah thats a WIP. yoou give it a cabal project, and it generates a hedgehog-classes test suite for you
11:50:29 <shapr> oooh , really?
11:50:37 <iqubic> Sounds cool
11:50:38 <chessai> it works for some stuff, but its still majourly WIP
11:50:39 * dmj` swoons
11:50:46 <shapr> gosh that sounds cool
11:50:50 <chessai> lots of bugs
11:50:57 <chessai> github.com/chessai/knuckles
11:51:47 <chessai> https://github.com/chessai/knuckles/blob/master/test-proj/test/test.hs
11:52:02 <chessai> here is some example output of an actual cabal project it punched
11:52:07 <chessai> knuckle punched
11:52:54 <chessai> `Integerx0`, nice. i am the best 
11:53:00 <iqubic> Does it work well?
11:53:16 <dmj`> knuckles was always my favorite, compared to sonic and tails
11:53:29 <dmj`> sega game gear
11:54:00 <chessai> yeah it works just fine on what ive tested it with, but i think i broke the codegen in some of the last few commits
11:54:33 <chessai> if your type has a generic instance it can also supply a default generator using hedgehog-generic, though that generator will not  be suitable in a lot of cases
11:55:51 <chessai> also i cant really create a generator otherwise, so most of the time it just defaults to `_GenTyN = error "knuckles could not supply a generator"
11:56:05 <pigmej[m]> I'm back :D
11:56:23 <chessai> but its still very useful for actually bootstrapping the test suite, and making sure you have coverage of all types/instances
11:57:48 <chessai> something im interested in doing/seeing is using RyanGlScott's verified-classes (or whatever it's called) library in a ghc plugin, so for every type that has a generic instance and another typeclass instance which has a counterpart in that library, it will generate the instance for the counterpart, which won't typecheck if the instance is unlawful
11:58:25 <poultrylabour> Hi! Quick Question: Haskell uses strong (or static) typing, while programming languages like Perl use weak (or dynamic) typing. Which one do you prefer, and why?
11:58:42 <iqubic> I prefer Haskell's type system.
11:59:00 <iqubic> Usually if something type checks, then it is going to do the right thing.
11:59:00 <poultrylabour> iqubic: care to elaborate?
11:59:14 <sm[m]> poultrylabour: now seriously, which answer do you think you'll get in here :)
11:59:35 <poultrylabour> Don't worry... I'm just joining the javascript IRC...
11:59:45 <poultrylabour> ;-)
11:59:47 <Ferdirand> strong and weak are very inadequate terms for this
11:59:47 <iqubic> I also, like being about to do tons of type level programming to make it harder for an incorrect program to type check.
12:00:31 <poultrylabour> Ferdirand: I think that definition dates back to the 80s
12:01:51 <Ferdirand> there is a definition but it's not about being static or dynamic
12:02:05 <exarkun> Does Tasty support QuickChecking Wai applications?
12:02:13 <exarkun> I see Tasty supports QuickCheck and I see Tasty supports Wai
12:03:23 <exarkun> I don't see much evidence of Tasty QuickCheck for Wai
12:03:28 <sm[m]> https://en.wikipedia.org/wiki/Type_system#Static_and_dynamic_type_checking_in_practice
12:03:28 <poultrylabour> Ferdirand: Most of the time it's the same thing (weak gets at runtime)
12:05:36 <poultrylabour> I am aware of the difference though. thank you
12:06:09 <exarkun> lavalike: seems to be a convention, https://hackage.haskell.org/package/tasty-quickcheck-0.10.1/docs/Test-Tasty-QuickCheck.html#t:Testable
12:08:14 <dmj`> pigmej[m]: there he is
12:08:30 <dmj`> pigmej[m]: knew you'd come back
12:08:40 <pigmej[m]> I didn't give up yet
12:08:58 <pigmej[m]> but the feeling is stronger and stronger ;P
12:10:38 <dmj`> pigmej[m]:  that's good
12:11:18 <dmj`> pigmej[m]: that means it's a challenge
12:11:36 <dmj`> pigmej[m]: eventually you'll be able to write haskell purely based on instinct
12:11:46 <dmj`> and you won't even need to use your brain anymore
12:11:57 <pigmej[m]> I'll code my brain in haskell
12:15:32 <dmwit> That question is not quick. It's also been done to death.
12:15:40 <dmwit> uh
12:15:48 <dmwit> Sorry, was scrolled up quite a bit.
12:17:50 <poultrylabour> dmwit: No problem
12:18:18 <dmwit> poultrylabour: Anyway, I like my coworker's way of saying this. If somebody joined your open source project, and they said, "Hey, I'm not really a good coder, but I love TDD. I'm going to write five tests for every line of code you write." What you telling that guy? Dunno about you but I'm high fiving him and getting him a seat and a big monitor.
12:19:15 <dmwit> Even if he's only mediocre at writing tests, he's gonna catch some bugs and save you some time.
12:19:40 <poultrylabour> dmwit: I'm just gonna write that down...
12:20:10 <exarkun> you have to maintain your test suite
12:20:23 <exarkun> a brittle test suite is a good way to make developers hate tests
12:21:01 <poultrylabour> Btw I just posted it on the JS channel, and the only answer I got was: "lol" (Dunno if it was related to my question though) :)
12:21:33 <dmwit> exarkun: Don't worry. This guy is crazy fast, and he maintains his tests for you even as you're writing your code.
12:21:40 <exarkun> ah, well.
12:21:56 <exarkun> oh you're talking about the type checker
12:22:01 * dmwit winks
12:22:18 <exarkun> that guy keeps stopping me from compiling my programs
12:22:27 <exarkun> total downer
12:22:42 <exarkun> and he only speaks middle english
12:22:53 <dmwit> yeah =(
12:24:32 * hackage hedgehog-classes 0.2.4 - Hedgehog will eat your typeclass bugs  https://hackage.haskell.org/package/hedgehog-classes-0.2.4 (chessai)
12:27:33 <shapr> neat, if I give a long list of binaries to a single "cabal new-install" command it *can* use a bunch of ram
12:28:35 <voyons_osti> poultrylabour: re: Most of the time it's the same thing (weak gets at runtime)
12:28:48 <voyons_osti> this isn't true, see python (strong, dynamic) or C (weak, static) 
12:30:18 <dmj`> pigmej[m]: if brains could be coded, then I hope they would be coded with a strongly typed static language
12:32:06 <shapr> dmj`: I suspect my brain is written in FORTH
12:32:43 <merijn> shapr: Not colour forth?
12:32:50 <shapr> I wish
12:41:19 <iqubic> My brain is definately written in FORTH.
12:41:29 <dmj`> shapr: that's pretty cool, some days my brain feels like it was written in C, segfaulting all over the place
12:43:27 <exarkun> why can't cabal find my pkg-config, https://gist.github.com/exarkun/5ffa02d844400d169289c1699b51f383
12:44:37 <lavalike> exarkun: I guess I just don't get it
12:45:06 <exarkun> lavalike: Tomorrow I'll try rewriting this test with Tasty and see what happens
12:45:15 <exarkun> lavalike: I guess it won't work but maybe it will fail with a simpler problem.
12:45:29 <exarkun> I do tend to agree that hspec causes massive type confusing.
12:45:38 <exarkun> I meant to stop using it but somehow I forgot to.
12:46:54 <sm[m]> dmwit: that was a pretty good analogy!
12:47:09 <sm[m]> I was thinking hmm, I'm not sure about this guy...
12:47:55 <merijn> exarkun: You can run cabal with -v3 to figure out where it looks for tools (like pkg-config)
12:48:13 <merijn> oh, wait, that's stack...not sure what to use to make stack verbose
12:49:41 <exarkun> I have a .cabal for this project, I can try to figure out how to run cabal directly I guess
12:49:50 <exarkun> stack has a `--cabal-verbose` option but it looks like it only goes up to 1.
12:51:06 <exarkun> `cabal v2-build -v3` tells me the requested package isn't in the pkg-config database
12:51:17 <exarkun> wonder if that's different behavior or if stack is misreporting the pkg-config error
12:52:21 <exarkun> fixing the package name makes `cabal v2-build -v3` get further but stack still fails the same way
12:52:48 <merijn> At least that means you're pkg-config is now working :)
12:55:10 <exarkun> indeed
12:56:06 <exarkun> Looks like something is failing to parse `pkg-config --modversion` output and that's where it dies
12:56:15 <exarkun> probably my fault since I wrote the .pc for this library...
12:59:08 * exarkun goes to read the pkg-config docs
13:02:02 <exarkun> wait I don't have enough drugs for this
13:02:29 <merijn> exarkun: that sounds about right for tools like pkg-config :p
13:03:53 <phadej> exarkun: you have cabal-install-3.0 don't you?
13:04:12 <phadej> exarkun: it should parse pkg-config versions just fine. as in "accept virtually anything"
13:04:42 <merijn> phadej: He just said he wrote the pkg-config file himself and potentially messed up :)
13:04:48 <exarkun> it got angry at "1.0.0-pre.1"
13:05:12 <phadej> https://hackage.haskell.org/package/Cabal-3.0.0.0/docs/src/Distribution.Types.PkgconfigVersion.html#line-42
13:05:12 <exarkun> And I have cabal-install 2.4
13:05:26 <phadej> 2.4 doesn't like that kind of versions
13:06:04 <exarkun> dang.  nor "1.0.0.rc1"?
13:06:18 <phadej> nor that
13:06:33 <phadej> probably just "x.y.z"
13:06:37 <exarkun> how about 0.9.9.999
13:06:41 <exarkun> too many .s?
13:06:50 <phadej> that would work, but I recommend just using newer cabal-install
13:07:21 <exarkun> a yak too far atm
13:07:44 <exarkun> but thank you for the explanation and the advice
13:08:19 <phadej> (2.4 reused "Version" for haskell-package-versions and pkg-config versions; which was bad thing to do)
13:08:49 <phadej> luckily pkg-config is quite readable C-code
13:10:09 <exarkun> dang it is still failing with 0.9.999
13:10:13 <exarkun> and I am out of time for today
13:19:28 <iqubic> I'm back.
13:39:10 <bifunc2> thread 1 ships an IO () off to thread 2, waiting for an mvar to signal completion
13:39:30 <bifunc2> but  how should thread 1 catch an exception if it happens while the io action causes exception on  thread 2?
13:41:12 <merijn> bifunc2: This question sounds like "I should be using async"
13:41:12 <merijn> @hackage async
13:41:12 <lambdabot> http://hackage.haskell.org/package/async
13:42:03 <bifunc2> merijn i don't think this works here because i  have a fixed thread i  want to  keep open to put io actions on.
13:42:06 <bifunc2> so i made a channel
13:42:56 <merijn> The answer is "doing it properly is super tricky"
13:42:57 <bifunc2> async will create thread for each action.  i want one thread..
13:42:59 <bifunc2> oh
13:43:51 <merijn> bifunc2: Any specific reason why 1 thread per action is a problem?
13:45:01 <bifunc2> merijn, talking to a C library that requires stuff to happen on one thread
13:45:15 <merijn> bifunc2: Then you're using the wrong solution anyway :)
13:45:39 <merijn> bifunc2: Because forkIO threads are allowed to migrate between OS threads, so running something in a single forkIO thread is not sufficient
13:45:51 <bifunc2> i use bound thread..
13:45:55 <merijn> ah
13:45:58 <bifunc2> (the c lib requires bound in fact)
13:46:49 <bifunc2> I'm just surprised nobody has created a convenient abstraction for "one thread"
13:47:00 <bifunc2> seems like a common thing to do..
13:47:17 <merijn> bifunc2: You'll basically want to setup an exception handler in the child thread that will notify the parent
13:47:42 <merijn> bifunc2: I know there's some people who've worked on creating Erlang style "supervision" threads in libraries but I dunno what their called
13:48:43 <bifunc2> here, https://tech.fpcomplete.com/haskell/tutorial/exceptions
13:48:43 <bifunc2> they mention "Asynchronous exceptions: allow cleanup, but disallow recovery"
13:48:44 <bifunc2> the question is, how long do i have to do cleanup?
13:48:51 <bifunc2> does the runtime have any time limits?
13:48:52 <merijn> bifunc2: I can highly recommend Simon Marlow's (free!) book "Parallel and Concurrent Haskell"
13:49:34 <merijn> bifunc2: That will teach you all you need to know about, well, parallel and concurrent haskell, including async exceptions and threads
13:50:00 <merijn> bifunc2: There's no time out, it's just that it's hard to do anything sensible besides cleanup resource after you get async excepted
13:50:11 <bifunc2> ok
13:50:19 <bifunc2> okay, i'll read this book :)
13:50:25 <bifunc2> thanks for the tip
13:50:28 <Ariakenom> is good book
13:50:36 <merijn> bifunc2: I have some code where I setup multiple child threads to spread work items over that I cleanup on exceptions, but the code is...not easy to follow
13:50:41 <bifunc2> it's old. still everything is solid?
13:50:48 <merijn> bifunc2: https://github.com/merijn/broadcast-chan/blob/master/broadcast-chan/BroadcastChan/Extra.hs#L108-L179
13:51:15 <merijn> bifunc2: Most of the core libraries (STM, Control.Concurrent, etc.) have changed very little in the past 2 decades
13:51:29 <bifunc2> nice
13:51:48 <merijn> bifunc2: They're low-level building blocks to build higher level stuff on top of, so like 90-95% should be unchanged
13:52:01 <bifunc2> :)
13:53:30 <Ariakenom> merijn: is async not useful for that code?
13:54:36 <merijn> Ariakenom: Not quite, because I don't want to fork of a new thread for every item
13:54:53 <merijn> Ariakenom: And, for example, mapConcurrently makes rate limiting tricky
13:55:10 <Ariakenom> I can see that
13:55:29 <merijn> Ariakenom: Additionally I want different exception handling than async provides
13:55:52 <merijn> Ariakenom: i.e. I don't want to necessarily abort child and parent
13:56:37 <bifunc2> merijn, would it work to just put a Maybe into my mVar, and put Nothing into it if an exception happens? then thread 1 could detect the Nothing and throw exception there
13:56:42 <bifunc2> too easy to be true
13:56:48 <merijn> Ariakenom: I allow exception handling via "dropping", "retrying", "aborting" or some custom handling
13:57:32 <merijn> Ariakenom: For example, for my phd experiments I use it to do bounded retries (since some of my failures are transient) so it will retry items 5-10 times before dropping them
13:57:54 <merijn> bifunc2: You can browse the async code to see how it works. The library itself is surprisingly short
13:58:00 * hackage xmonad-spotify 0.1.2.0 - Bind media keys to work with Spotify  https://hackage.haskell.org/package/xmonad-spotify-0.1.2.0 (vmchale)
13:58:24 <merijn> bifunc2: I mean, the entire thing is a single 889 line module :)
13:58:26 <Ariakenom> merijn: nice. I have to sleep
13:58:58 <Ariakenom> shouldnt ask questions with interesting answers before bed :)
13:59:30 <merijn> Ariakenom: I even have a wrapper for conduit so you can do run a function "a -> IO b" in parallel N types as a conduit step ;)
14:01:01 <bifunc2> i'll sleep on it hehe
14:01:31 <bifunc2> thanks for the tips
14:01:32 <bifunc2> i'm just going  to  read marlow's book
14:02:03 <merijn> bifunc2: tbh, that's where I learned like 90% of the stuff I used in that example, so :)
14:03:22 <merijn> BEd time here too :)
14:04:02 <bifunc2> gn
14:20:30 * hackage xmonad-spotify 0.1.2.1 - Bind media keys to work with Spotify  https://hackage.haskell.org/package/xmonad-spotify-0.1.2.1 (vmchale)
14:24:00 * hackage xmonad-spotify 0.1.2.2 - Bind media keys to work with Spotify  https://hackage.haskell.org/package/xmonad-spotify-0.1.2.2 (vmchale)
14:36:04 * hackage ansi-terminal 0.10 - Simple ANSI terminal support, with Windows compatibility  https://hackage.haskell.org/package/ansi-terminal-0.10 (mpilgrem)
15:41:07 <sm[m]> why on earth does stack haddock --no-haddock-deps have to do a full rebuild of my just-built packages
15:44:00 * hackage hledger-lib 1.15.2 - Core data types, parsers and functionality for the hledger accounting tools  https://hackage.haskell.org/package/hledger-lib-1.15.2 (SimonMichael)
15:45:00 * hackage hledger 1.15.2 - Command-line interface for the hledger accounting tool  https://hackage.haskell.org/package/hledger-1.15.2 (SimonMichael)
15:45:37 <phaazon> plop
15:45:58 <phaazon> what’s the command again to get a list of outdated packages given a local .cabal file?
15:46:38 <phaazon> cabal outdated, as simple as that :D
15:49:21 <koz_> According to the PVP, what is considered a _non_-breaking API addition?
15:49:52 <phaazon> path and minor
15:51:50 <phaazon> anyone using ghc and cabal on Archlinux?
15:51:50 <phaazon> that stuff has been driving me crazy so many times
15:51:50 <phaazon> at every fucking update something is messing up
15:51:51 <VaNilLa[m]> I'm running ghc + stack
15:51:51 <VaNilLa[m]> on arch
15:51:54 <phaazon> argh, stack
15:52:32 <VaNilLa[m]> I don't know better, is stack bad :(
15:52:32 <koz_> VaNilLa[m]: Huge can of worms, lol.
15:52:32 <monochrom> archlinux's dynamic linking religion drives every crazy
15:52:39 <phaazon> monochrom: yes.
15:52:44 <koz_> monochrom: On that, we are in agreement.
15:54:21 <phaazon> their haskell-* packages…
15:54:38 <phaazon> IIRC there’s a way to get static ghc
15:54:38 <VaNilLa[m]> oh yeah I installed -static packages
15:54:39 <VaNilLa[m]> and none of the haskell-packagename
15:54:39 <VaNilLa[m]> because at one point it couldn't find some lib installed by some haskell package and it was a huge mess
15:54:40 <phaazon> VaNilLa[m]: but hm
15:54:40 <phaazon> pacman -S ghc-static
15:54:40 <phaazon> it brings ghc, ghc-libs and ghc-static
15:54:40 <phaazon> with all the haskell-* dependencies
15:55:15 <VaNilLa[m]> I can't tell you exactly how I managed to set it up, but I know for sure I have ghc and `pacman -Q | grep haskell-` doesn't report anything
15:55:27 <VaNilLa[m]> I'm also not on my dev machine right now, so I can't tell you more :(
15:56:35 <phaazon> I mean
15:56:35 <phaazon> holy fuck Archlinux
15:56:42 <phaazon> you need to install ghc-pristine from the AUR
15:57:09 <VaNilLa[m]> to quote a person from my research group, > use NixOS
15:57:36 <VaNilLa[m]> I haven't gone down that rabbit hole yet, but I'm getting ready to
15:57:41 <phaazon> yeah it’s a rabbit hole
15:57:51 <phaazon>  I have other plans for the last half part of my life
15:57:52 <phaazon> so thank you but no
15:58:21 <VaNilLa[m]> I played with it in a VM. It worked surprisingly well
15:58:57 <VaNilLa[m]> only problem was that some of the options felt "magic", and I liked to know what my machine is doing ""under the hood""
15:58:57 <lyxia> I'm happy with stack on arch
15:59:03 <phaazon> I dislike stack
15:59:28 <phaazon> for various reasons
15:59:28 <phaazon> I’ll just install cabal-install the old way
15:59:30 <phaazon> or maybe use that ghc-pristine shit 
15:59:43 <VaNilLa[m]> lyxia: I'm happy with stack on arch, too. I did mange to install the static stuff, and I only pretty much need it to run research code, so I'm not really a "power user"
16:00:06 <phaazon> cabal configure --with-compiler=/usr/share/ghc-pristine/bin/ghc
16:00:09 * phaazon smh
16:00:47 <phaazon> maybe I’ll go with stack finally, even though I don’t like it
16:01:04 <lyxia> you can set that option once for all in ~/.cabal/config
16:08:06 <koz_> :t guard
16:08:08 <lambdabot> Alternative f => Bool -> f ()
16:09:47 <monochrom> Perhaps "stack on archlinux" works well just because stack fetches non-problematic GHC rather than archlinux's problematic GHC. In that case ghcup does the same thing.
16:09:49 <koz_> I need something of the form (a -> Bool) -> a -> Maybe a, which gives Nothing if the function as applied to the second arg gives False, and Just the second arg if true. Does this thing exist?
16:09:50 <jgt> anyone know why my hspec hooks are in the wrong order? http://ix.io/1Uoq
16:10:19 <jgt> test output is at the botto there. I'd expect "after" to be printed _after_ the spec is run.
16:10:32 <jgt> s/botto/bottom/
16:12:24 <koz_> Guarded from protolude.
16:12:44 <koz_> (which is more general)
16:15:22 <jgt1> got disconnected. Did someone respond to my hspec question?
16:15:33 <monochrom> No.
16:16:17 <jgt1> ok, thanks
16:16:52 <jgt1> wasn't expecting such a reaction time, but I didn't want to unknowingly ignore someone as a result of loss of connectivity :)
16:21:30 * hackage haskell-src-meta 0.8.3 - Parse source to template-haskell abstract syntax.  https://hackage.haskell.org/package/haskell-src-meta-0.8.3 (DanBurton)
16:36:45 <jrpark> anyone know a tutorial on whitespace sensitivity in haskell? 90% of my experience with haskell is trying to get things to compile by randomly moving them around the screen and adding semicolons and parentheses until it works, then i'm terrified to modify the code  
16:39:11 <hololeap> semicolons?
16:40:20 <boj> jrpark: switch to spaces if you aren't already. there are a couple cases where tabs ruin your day
16:40:20 <monochrom> I would go to https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7 (part of the Haskell 2010 Report) and read the 3rd paragraph "Informally stated," very carefully.
16:40:20 <hololeap> it's mostly ruled by indentation. if you indent correctly, it's pretty intuitive
16:42:19 <koz_> Can someone help me figure out why this deduction is failing? https://gist.github.com/kozross/6193876d672f9f511f73503a8a56b35c
16:43:30 * hackage checkers 0.5.1 - Check properties on standard classes and data structures.  https://hackage.haskell.org/package/checkers-0.5.1 (ConalElliott)
16:48:12 <lyxia> koz_: GHC doesn't derive KnownNat constraints for arithmetic operations. There's a plugin for that https://hackage.haskell.org/package/ghc-typelits-knownnat
16:48:19 <koz_> lyxia: I am using it.
16:48:25 <koz_> That's my whole issue lol.
16:49:05 <lyxia> oh lol
16:49:19 <koz_> This is what has me confused - as far as I can tell, it _should_ be able to figure this out, but it doesn't.
16:49:29 <lyxia> Does it solve it if you add KnownNat explicitly
16:49:32 <jrpark> monochrom thank you i'll ready through that
16:49:37 <koz_> For which type variables?
16:49:40 <koz_> If it's n and or m, no.
16:49:49 <lyxia> huh
16:49:55 <koz_> Yeah, why I'm asking.
16:50:50 <lyxia> sorry then, I have no idea
16:50:59 <koz_> Makes two of us lol.
16:51:12 <koz_> I can add a KnownNat k constraint no problem, but it's a bit weird that it can't figure this out.
16:52:08 <koz_> Does the ~ not give it enough direction or something?
16:52:11 <jrpark> on another note, is it possible to express a char literal with a combining diacritical mark? this causes a syntax error: 'e\0301'
16:52:58 <koz_> lyxia: https://github.com/clash-lang/ghc-typelits-knownnat/issues/25
16:53:02 <hpc> jrpark: there might be a codepoint that already combines those
16:53:02 <koz_> Uhh, lol.
16:53:29 <lyxia> koz_: also #13
16:54:33 <jrpark> hpc i was trying to pattern match on that, but i guess i could do unicode normalization and use the combined form é 
16:54:46 <koz_> lyxia: According to that one this has been patched.
16:55:18 <hpc> yeah, it's kind of unfortunate
16:55:25 <jrpark> i also wanted a function that could add the combining diacritic to any vowel, but i could have a function that only supports a range of vowels and hardcodes their corresponding composed representation
16:56:20 <hpc> you're technically "doing it wrong" anyway by having code that cares about the difference, and there's probably a better way somewhere in the various text packages
16:58:28 <jrpark> well, if there's code that exists that adds diacritics to any script - greek, latin, cyrillic, then i'd obviously use it, but i'd still be curious if it's a wall of pattern matching or lookup table, or if it's using combining diacritics in some way
17:01:36 <koz_> lyxia: https://github.com/clash-lang/ghc-typelits-knownnat/issues/13#issuecomment-528652316
17:01:39 <koz_> Let's see if this goes anywhere.
17:07:23 <koz_> Is there an equivalent to either (the function) for :+: from GHC.Generics?
17:09:50 <koz_> lyxia: Perhaps in your all-singing, all-dancing Generics library?
17:11:49 <koz_> Interestingly, there's an instance of Bifunctor for Either, but _not_ :+:.
17:18:23 <lyxia> not that I now of
17:18:43 <koz_> I'm a bit surprised :+: isn't a Bifunctor while Either is.
17:19:58 <lyxia> https://hackage.haskell.org/package/functor-combinators-0.1.1.1/docs/Data-Functor-Combinator.html#v:biget
17:20:26 <koz_> LOL thanks jle`!
17:20:34 <koz_> (well, and lyxia for finding that)
17:23:26 <iqubic> koz_: You wouldn't happen to know which library Sandy uses for Vectors in his OpenProducts section, would you? He imports Data.Vector at the bottom of 146.
17:23:47 <koz_> I'm guessing vector, unless you have reason to suspect otherwise.
17:24:01 <iqubic> I don't. I really don't.
17:30:10 <nshepperd2> :+: as in sum of functors? It can't be a Bifunctor
17:30:36 <koz_> :+: as in http://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Generics.html#t::-43-:
17:30:57 <koz_> Ah, I see what you mean now.
17:31:08 <koz_> I didn't realize its kind differed from Either.
17:33:15 <nshepperd2> It is a bifunctor in a different category though
17:33:47 <koz_> Yeah, I keep forgetting that big-letter things (like Functor, Bifunctor, etc) are all on Hask.,
17:34:03 <AviD> What is MutVar# under the hood? Is it just a pointer or is more complex? How is atomicModifyMutVar# implemented?
17:34:11 <koz_> I guess I could use jle`'s library to make this a bit nicer.
17:35:17 <nshepperd2> bimap' :: (f ~> g) -> (h ~> i) -> (f :+: h) ~> (g :+: i) or something
17:35:29 <koz_> Where ~> is?
17:35:41 <nshepperd2> Natural transformation
17:35:44 <koz_> Ah yeah.
17:38:57 <iqubic> How common is this qualified import? "import qualified Data.Vector as V"
17:39:05 <koz_> Like, everywhere.
17:39:15 <koz_> At least in code I've seen and/or written.
17:39:48 <iqubic> Why?
17:40:03 <iqubic> Also, what does qualified mean there?
17:40:04 <koz_> Because a lot of the stuff in Vector (and Vector.Storable, and Vector.Unboxed, etc etc) clashes with Prelude names.
17:40:10 <iqubic> Ah. I see.
17:40:13 <koz_> The 'qualified' means 'you can use anything from here, but you gotta prefix it with V'.
17:40:16 <koz_> (in this case)
17:40:47 <iqubic> Ah. So the unqualified name is the standard prelude function?
17:41:34 <koz_> What do you mean?
17:42:53 <iqubic> Well, if there's a name clash, I either add V. to us the vector function, or I don't and get the prelude function.
17:43:02 <koz_> Yep, that's right.
17:43:21 <iqubic> I was using "unqualified" to mean, "without the V. prefix"
17:43:37 <iqubic> IDK if that's proper.
18:20:32 <koz_> :t const
18:20:34 <lambdabot> a -> b -> a
18:43:47 <koz_> :t maybe
18:43:49 <lambdabot> b -> (a -> b) -> Maybe a -> b
18:45:24 <Guest78> hi!
18:46:03 <Guest78> someone here uses emacs?
19:03:09 <koz_> mniip: Any chance you could add exponentiation to Data.Finite?
19:07:46 <dmwit> Imagine a programming channel with no emacs users. Hell, I bet even #vimscript has emacs users.
19:08:16 <suzu> lol
19:08:18 <koz_> dmwit: evil-mode _is_ a thing.
19:15:56 <suzu> i.. i use evil mode
19:16:04 <suzu> i use vim keys in emacs
19:16:05 <suzu> <_<
19:16:06 <koz_> Such evil.
19:16:11 <koz_> Very interface.
19:16:15 <suzu> Much wow
19:16:18 <koz_> Amaze.
19:16:23 <suzu> Woof
19:16:28 * koz_ ded.
19:16:57 <no-n> I user vim because it's the only thin gi've tried
19:17:08 <no-n> I like it though, so who cares
19:17:25 <koz_> I've used Emacs in the past.
19:17:31 <koz_> I use vim now.
19:17:34 <koz_> I can see arguments for both.
19:17:36 <koz_> I like the latter more.
19:17:37 <no-n> I used gedit before that, heh
19:17:49 <koz_> Ehh, there was a time when I used Sublime and Notepad++. :P
19:18:12 <no-n> I don't want to spend 10 years learning an editor
19:18:20 <no-n> I've got other stuff to learn
19:19:27 <suzu> thats actually
19:19:32 <suzu> why i switched
19:19:53 <suzu> vim was the only thing i used and so i was thinking i should try the other side of things
19:36:55 <koz_> How are GADTs represented? Are they just the same as ordinary ADTs underneath?
19:38:46 <c_wraith> at runtime, yes
19:38:51 <c_wraith> The magic in GADTs is at compile time
19:38:59 <koz_> c_wraith: Oh, neat.
19:59:10 <koz_> :t fromIntegral
19:59:12 <lambdabot> (Integral a, Num b) => a -> b
19:59:59 <Silent_Alex> [1,2]
20:07:43 <koz_> :t (*>)
20:07:45 <lambdabot> Applicative f => f a -> f b -> f b
20:07:54 <koz_> :t ($>)
20:07:57 <lambdabot> Functor f => f a -> b -> f b
20:10:58 <koz_> Is it normal for Hoogle to give me 504s?
20:12:13 <remexre> any way to do development in haskell like w/ slime? where you can define + redefine functions in a running process?
20:13:20 <styledash> once you learn to use vim its like using a car instead of walking... productivity boost you can never go back from
20:13:33 <remexre> yeah, I'm actually a slimv user, not a slime user :P
20:13:37 <remexre> people have actually heard of slime tho
20:15:11 <remexre> work ppl got me hooked on doing "live development" on lisp :P
20:18:53 <dmj`> koz_: are you using https://hoogle.haskell.org/
20:19:11 <koz_> dmj`: Yes.
20:20:47 * ski . o O ( Slime48 )
20:21:35 <dmj`> koz_: hrm
20:29:52 <dmwit> remexre: You might like dyre.
20:32:47 <remexre> dmwit: hm, sounds possibly like what I want
20:33:43 <remexre> I guess I'm not a huge fan of needing to serialize + deserialize the state
20:34:02 <remexre> oh, and wait, that definitely wouldn't work
20:34:08 <remexre> I can't serialize an opengl context lol
20:35:17 <sarahzrf> your just not trying hard enuf
20:36:52 <remexre> easy solution: relaunchWithBinaryState (readFile "/dev/mem")
20:36:59 <remexre> lazy io means it'll be fast /s
20:43:00 <dmwit> ?hoogle Functor f => f (a -> b) -> a -> f b
20:43:01 <lambdabot> Control.Lens.Lens (??) :: Functor f => f (a -> b) -> a -> f b
20:43:01 <lambdabot> Control.Lens.Operators (??) :: Functor f => f (a -> b) -> a -> f b
20:43:01 <lambdabot> DBus.Generation (??) :: Functor f => f (a -> b) -> a -> f b
20:44:47 <koz_> OMG wtf did I just encounter...
20:44:57 <koz_> ghc: panic! (the 'impossible' happened) <-- halp...
20:45:09 <dmwit> If it's the latest GHC, congrats! You found a bug.
20:45:14 <koz_> dmwit: It's not the latest.
20:45:17 <dmwit> The message says so, I'm sure.
20:45:17 <koz_> It's 8.6.5
20:45:27 <dmwit> Oh, in that case, congrats! You get to upgrade GHC.
20:45:34 * koz_ tries on 8.8.
20:46:17 <koz_> Same thing lol.
20:46:22 <koz_> I think I can find it on 8.4 also.
20:47:14 <koz_> Yep, confirmed.
20:47:24 <MarcelineVQ> you monster
20:47:31 <koz_> Alrighty, time to find a minimum test case and file some bug reports.
20:51:07 <koz_> Hmm, I think the _solvers_ broke.
20:58:23 <koz_> MarcelineVQ: This is what happens with me. All the corner cases find me.
20:58:27 <koz_> It's like Soviet Russia.
21:27:17 <dmwit> More than 10% of this program is imports and pragmas.
21:27:22 <dmwit> <3 Haskell
21:27:29 <koz_> dmwit: _Only_ 10%?
21:27:31 <koz_> I'm shocked. :P
21:30:45 <EvanR> yeah seems low
21:53:17 <cocreature> The real danger with using a custom prelude and default-extensions is that your line count goes down so much that you’ll get fired.
21:59:00 <ion> Make a custom Prelude for everything and all you need are one import and one definition.
22:09:59 <nshepperd2> The do what i mean operator
22:11:51 <jle`> there's that one ghc plugin that basically inserts the code corresponding to a type signature automaticlaly
22:12:27 <dmwit> koz_: So I just did a survey of all the files in this project to check. Besides two outliers (a 5% and a 29%), it's amazingly consistent at 10% +/- 3 lines of module header across the whole project.
22:12:57 <koz_> 29% sounds like 2019 GHC Haskell. :P
22:13:20 <nshepperd2> jle`: hah, really? I was playing with the idea of doing that with exference
22:14:03 <dmwit> The 29% is a module that, practically speaking, just defines a class. So it's such a high percentage because there's very little code, not because there's a lot of header.
22:14:18 <nshepperd2> A template haskell splice that can implement any value
22:15:47 <koz_> dmwit: What if you just counted lines of pragmata?
22:16:00 <dmwit> Oh, you're going to get much more variability there.
22:16:14 <dmwit> That just tells you how crotchety I was feeling the day I wrote that module.
22:16:57 <dmwit> Some days I'm all, "Haskell98 oughta be enough for anybody" and other days I'm more like "haha, extensions are great! I wonder if I can find another one to use".
22:17:00 <MarcelineVQ> when you'r crotchety do you put them all on one line?
22:55:30 * hackage llvm-hs-pure 9.0.0 - Pure Haskell LLVM functionality (no FFI).  https://hackage.haskell.org/package/llvm-hs-pure-9.0.0 (cocreature)
23:06:30 * hackage llvm-hs 9.0.0 - General purpose LLVM bindings  https://hackage.haskell.org/package/llvm-hs-9.0.0 (cocreature)
