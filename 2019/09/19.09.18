00:00:03 <sicklorkin> Not sure if anyone has much experience using esqueleto, but I'm trying to write a join `on (f.^FooId :: Key Foo ==. b.^FooId :: Int)`
00:00:55 <sicklorkin> i'm almost convinced this is not possible 'cause of how PersistValue converts from/to Key but just wanted to see if I'm wrong
00:01:22 <atralheaven> jle`: how would you have control flow in haskell?
00:02:24 <jle`> control flow in haskell can...look a lot different. but it manifests in a lot of different ways
00:02:39 <jle`> for pure values we have control driven by evaluation
00:02:59 <jle`> when we write IO and talk about control flow for IO effects, then we have first-class control flow
00:03:23 <jle`> since in Haskell we can have values that represent IO actions, we can combine these values in a way that respects the control flow we want
00:04:32 <jle`> it's...not something that can be easily explained quickly without going deeper into haskell, i think
00:05:21 <dminuoso> atralheaven: An `if/then/else` is rather in the sense of `isPositive x | x > 0 = True; isPositive x | otherwise = False
00:12:14 <atralheaven> to my understanding, FP is a totally different way to problem solving, it sees the problem solving process very differently 
00:14:41 <jle`> atralheaven: i think that is a popular sentiment yes :)
00:14:55 <jle`> i think ultimately in the end a lot of the high-level ways end up being very similar
00:15:08 <jle`> but it's hard to see these similarities until you understand what is different
00:15:37 <jle`> that's a part of the magic of the journey i think
00:15:53 <jle`> everything is different until all of a sudden everything is similar, in a way you didn't expect
00:18:02 <atralheaven> it's not a long time that I got somehow good at python programming, I liked somethings that were from FP world, and I tried to use them in my works
00:18:50 <atralheaven> jle`: I guess I understand that, it's different ways to same goals
00:18:59 <dminuoso> atralheaven: They are not so different, really.
00:20:02 <atralheaven> I really like python, but I'm not sure if I can have more FP in python, I mean, applying the FP mindset to python codes that I write
00:22:02 <[exa]> atralheaven: there are various functional tricks that you may enjoy in python as well (mostly related to function composition and various list-crunching idioms)
00:22:47 <[exa]> atralheaven: OTOH 80% of haskell is taking these tricks and putting them on generic steroids using the type system, which you're probably not going to be able to enjoy very much in Python
00:23:56 <atralheaven> I wanted good things from both worlds, but apparently most of FP is not possible to have in python 
00:24:14 <[exa]> and, well, laziness
00:24:17 <sshine> has anyone here experienced Emacs haskell-mode hang when typing out a quasi-quoted expression like [r||], placing the cursor between the pipes and typing '['?
00:24:48 <[exa]> atralheaven: btw you're welcome to ask here about any particular tricks and porting them to .py :]
00:25:29 <atralheaven> [exa]: Thank you ^^
00:25:54 <sshine> there is another situation where haskell-mode also hangs. I think it also relates to an opening bracket or brace somewhere.
00:27:49 <jle`> atralheaven: i think the main thing to worry about is how much the language helps or hinders your programming in a certain style
00:27:52 <atralheaven> do you think haskell is good choice for me as a FP language? I'm mostly working with data, I've heard of clojure and elixir too, but I'm not familiar with them
00:28:14 <jle`> atralheaven: while it's possible to program functionally in python, the language itself is not going to help you in any way -- and often times it'll get in your way
00:28:29 <atralheaven> jle`: exactly 
00:29:08 <[exa]> atralheaven: do try. :] (After some common initial struggle, there is no way back)
00:30:43 <atralheaven> I did try haskell tutorials but honestly the syntax was so weird to me that I didn't understand even very basic things :D
00:31:09 <atralheaven> I think I should have come here and ask
00:31:26 <[exa]> yes, that's what #haskell is good for :]
00:31:38 <atralheaven> this channel seems very firendly :)
00:33:08 <atralheaven> do you know about clojure and elixir?
00:33:55 <jusss> I just heard them
00:34:45 <jusss> clojure is a scheme dialect on jvm
00:35:00 <[exa]> asheshambasta: clojure is scheme for java VM, elixir is like Caml on erlang VM
00:35:20 <jusss> [exa]: do you know CPS?
00:35:27 <[exa]> CPS?
00:35:29 <sshine> I thought Elixir was more like Ruby on Erlang VM.
00:35:35 <sshine> continuation-passing style
00:35:42 <[exa]> yes
00:35:51 <jusss> I took two days to see some articles about CPS, still don't get it
00:36:22 <sshine> jusss, there's not a lot to get, I think.
00:36:27 <jusss> so what is the definition about "continuation" at first?
00:36:42 <[exa]> jusss: let's have a small code example and you will try to rewrite it without a return statement, okay?
00:36:53 <jusss> sshine: but I lack comprehension
00:37:13 <jusss> [exa]: ok
00:38:14 <[exa]> jusss: https://pastebin.com/wqjM8jpR
00:38:50 <[exa]> the aim is to rewrite the code so that it does the same thing, but you can never 'return' from any function
00:39:05 <jusss> [exa]: ok, I'll try it
00:39:06 <[exa]> (don't mind any semantic details of the pseudolanguage, I just made it up)
00:39:52 <[exa]> you can assume that someone will call main() from outside, just like in C's and haskells.
00:42:32 <sshine> jusss, there are some examples in JavaScript here: http://matt.might.net/articles/by-example-continuation-passing-style/
00:43:15 <[exa]> jusss: btw I don't want to give hints if they are not necessary but ask if you get stuck anyhow
00:43:15 <jusss> [exa]: https://pastebin.com/j93R8XdN
00:43:21 <jgt> atralheaven: spread the word; we're a friendly bunch
00:43:22 <atralheaven> Rust also seems intresting, do you know how capable it is for FP?
00:43:44 <atralheaven> jgt: sure :D
00:43:46 <[exa]> rust is barely capable of C++ :D
00:44:08 <jusss> FP is bound to Static Type languages?
00:44:31 <jgt> atralheaven: re: rust https://lobste.rs/s/2cw6ov/say_something_you_dislike_about_language#c_o7v9ud
00:44:48 <[exa]> jusss: ok that's one possibility, you've inlined half of the main function to somefun(). What if main() was tragically long?
00:45:03 <[exa]> jusss: hint: try splitting main in 2 halves, before and after the call
00:47:12 <jusss> [exa]: https://pastebin.com/bcgRvzYr
00:47:38 <jusss> [exa]: is this what you want?
00:48:13 <sshine> jusss, FP != statically typed languages. Lisp is the classic example of a dynamically typed FP language.
00:48:33 <jusss> sshine: and Lisp is not a pure FP language
00:49:06 <pepito18>  how to remove all warnings?  (hi)
00:49:10 <[exa]> jusss: getting closer. Let me modify the assignment a bit
00:50:11 <[exa]> jusss: https://pastebin.com/jByiCNqT
00:50:25 <sshine> jusss, and it isn't named after a mathematician, either.
00:50:29 <jgt> pepito18: why would you want to do that?
00:51:25 <[exa]> jusss: ok sorry, simpler version first: https://pastebin.com/jWTmAmMD
00:51:29 <sshine> pepito18, the best way is to fix the things that the compiler warns about. ;-)
00:51:35 <[exa]> (you don't need to care about 'a' there)
00:52:30 * hackage sequenceTools 1.4.0.4 - A package with tools for processing DNA sequencing data  https://hackage.haskell.org/package/sequenceTools-1.4.0.4 (stephan_schiffels)
00:52:50 <sshine> pepito18, otherwise, -fno-warn-...
00:53:52 <pepito18> sshine at least how to remove deprection warnings. the network library produces a lot of then and I have no intention to upgrade the version
00:55:21 <pepito18> sshine thanks !
00:55:55 <jgt> wouldn't that involve disabling those warnings for that library? i.e. not in your own cabal file?
00:56:44 <[exa]> jusss: (hint: keep the code modifications as small and as local as possible; CPS is kindof meant to be simplistic
00:58:14 <jusss> [exa]: y
00:58:27 <jusss> [exa]: https://pastebin.com/csDVBuef
00:58:41 <jusss> https://pastebin.com/csDVBuef
00:58:51 <[exa]> jusss: cool
00:59:07 <[exa]> notice you can just take 'k' out of main and it will still work
01:00:17 <jusss> [exa]: yeah, and?
01:00:38 <[exa]> after that, the code is basically in the same language as before, but uses no returns, and CPS is done, and that's it :]
01:01:35 <[exa]> jusss: Q: what is it good for? A1: You don't need the underlying system to remember "return addresses" itself, so e.g. tail recursion is much easier to implement
01:02:05 <jusss> [exa]: and A2?
01:02:07 <[exa]> jusss: A2: you've got 'goto' for free in a nicely looking functional language
01:03:28 <[exa]> let's try exceptions for example: Instead of calling 'somefun(x,y,k)', you would call 'somefun(x,y,k,e)' where 'e' is the landing point for whenever something goes wrong. No other language modifications needed.
01:03:44 <jusss> ok
01:04:21 <[exa]> jusss: in short, the whole point of CPS is 'tremendous jumping power with no underlying system required'
01:04:48 <[exa]> s/no/minimal/
01:05:39 <jusss> [exa]: I hate to say the word, "context", is it shows up here again?
01:05:51 <jusss> s/is/
01:06:01 <[exa]> context?
01:06:10 <jusss> jumping with context
01:06:41 <[exa]> hm what do you mean by context now?
01:06:59 <jusss> [exa]: the stack stuff? 
01:07:05 <[exa]> ooh so
01:07:21 <jusss> [exa]: environment stuff? name space?
01:08:04 <[exa]> the thing is that you actually don't need stack for this because the main purpose of stack (return addresses) are now handled directly by the code
01:08:25 <[exa]> (with the extra cool possibility of them getting optimized out, which is nice for getting some speed)
01:08:35 <jusss> [exa]: and can it jump back?
01:08:59 <[exa]> yes, if it gets the continuation that gets back
01:09:08 <jusss> [exa]: through function call?
01:09:42 <[exa]> ofcourse in a normal language you'd get stack overflow by calling too much functions in each other, but there's no stack and tail calls get eliminated (converted to actual jumps)
01:10:35 <jusss> [exa]: I remember other languages use trampoline to do stack overflow if they don't support TCO
01:10:55 <jusss> is that trampoline stuff related to CPS?
01:13:52 <[exa]> jusss: https://pastebin.com/pZM1tRt5  this is CPS with recursion
01:14:22 <[exa]> I used _ to make a lambda (advantage of thinking up your languages)
01:15:05 <[exa]> jusss: anyway trampolines are usually low-level primitives for handling far jumps, syscalls, interrupts and whatnot, but generally there's a lot of jumping too
01:15:38 <[exa]> jusss: if you have a particular language where it's used I guess I can have a look
01:16:56 <jusss> [exa]: haha, scheme
01:17:38 <[exa]> oh they call 'trampoline' a thing that repeatedly calls thunk evaluation
01:18:09 <jusss> [exa]: sorry, scheme support TCO, 
01:18:13 <[exa]> this is probably what you meant? https://stackoverflow.com/questions/189725/what-is-a-trampoline-function#489860
01:19:31 <jusss> [exa]: https://pastebin.com/C5pp9b1c
01:20:19 <[exa]> yes, basically an engine for evaluating whatever gets returned again and again until there's an actual value
01:20:52 <jusss> [exa]: is this CPS?
01:21:10 <[exa]> no, but CPS makes this pretty simple -- after CPS there is no stack, so you don't need to keep any intermediate "state" of the functions being evaluated
01:21:26 <[exa]> but still you can perfectly "interrupt" them
01:21:39 <tdammers> the basic idea is simple. instead of making a recursive call and returning its value, you return the equivalent continuation, and then you have a "trampoline" function at the top level that calls your function, and keeps calling the return value until it is not a continuation anymore
01:21:43 <jusss> [exa]: so how to do this if it uses CPS?
01:22:25 <merijn> jusss: You give f an extra argument which is the function that will use the result of f
01:22:30 * hackage prometheus-proc 0.1.2.0 - Export metrics from /proc for the current process  https://hackage.haskell.org/package/prometheus-proc-0.1.2.0 (OliverCharles)
01:23:15 <jusss> merijn: code?
01:23:48 <[exa]> jusss: mind if we switch to haskell?
01:24:55 <jusss> [exa]: I'm afraid it may take me more time to read it in haskell... and of cource you can
01:25:19 <jusss> and I heard there's call/cc in haskell
01:26:04 <merijn> jusss: Something like: https://paste.debian.net/1101388/
01:26:34 <merijn> jusss: So instead of "result = f(0); print(result)" you'd simply do "f(0, print)"
01:27:02 <merijn> jusss: Note that at not point do you actually need to "return" so the code can continue, because you're explicitly passing the "continue" as argument
01:27:31 <merijn> jusss: If you never have to return, then you don't have to remember where to return to, and if you don't have to remember where to return to, you don't need a function call stack
01:28:01 <merijn> (which, of course, means you can't overflow your function call stack either!)
01:28:07 <jusss> merijn: wow!
01:30:51 <merijn> jusss: Now imagine your entire program is just a giant expression (like Haskell programs effectively are) you can always just pass in a continuation that is "the rest of the program" which means you never have to "return" and, indeed, GHC compiles function calls to assembly jumps, rather than assembly calls
01:31:16 <merijn> jusss: Even compiler in imperative languages secretly do this internally
01:32:14 <merijn> jusss: A common compiler technique is to turn imperative code into "Static Single Assignment" form, where each variable is only ever assigned once (which makes code much easier to optimise/simplify), which has basically the same effect
01:32:36 <koz_> I think there was even a paper saying that SSA is CPS in disguise.
01:32:57 <merijn> koz_: It's not even really in disguise
01:33:17 <merijn> CPS and SSA are quite obviously "the same thing from a slightly different viewpoint"
01:34:23 <merijn> jusss: The wikipedia page on SSA seems to have some ok examples (for as far as I can tell from quickly skimming)
01:34:41 <jusss> merijn: ok
01:36:00 * hackage amqp-utils 0.3.7.1 - Generic Haskell AMQP tools  https://hackage.haskell.org/package/amqp-utils-0.3.7.1 (woffs)
01:58:31 <kuribas> tdammers: I uploaded another (unfinished) orchestration piece of the opera: http://kuribas.hcoop.net/apollonide11.mp3
01:58:38 <kuribas> tdammers: comments welcome :)
01:59:21 <jusss> merijn: I run your code https://paste.debian.net/1101388/  and "RuntimeError: maximum recursion depth exceeded"
01:59:46 <merijn> jusss: Right, because python use a callstack for call because it can't tell it's not needed there
02:00:01 <kuribas> tdammers: sorry, meant for off-topic...
02:04:56 <Kartha> merijn, is call stack part of a heap?
02:05:45 <merijn> Kartha: "Yes, no, maybe, it depends"
02:06:23 <__monty__> On the language or even in GHC haskell?
02:06:40 <merijn> __monty__: Well, GHC Haskell doesn't have a call stack, so :)
02:07:05 <__monty__> I was thinking of the stacktrace functionality.
02:07:49 <merijn> __monty__: Well, that exists only by explicitly creating it (or by the RTS "simulating" one in profiling mode)
02:17:30 * hackage secp256k1-legacy 0.5.5 - fork of secp256k1  https://hackage.haskell.org/package/secp256k1-legacy-0.5.5 (fommil)
03:45:30 * hackage hie-bios 0.2.0 - Set up a GHC API session  https://hackage.haskell.org/package/hie-bios-0.2.0 (mpickering)
04:28:46 <hoppfull> Is there something in haskell where we describe that there is a back-and-forth thing? Like BackAndForth String Int where forth = fromString and back = show and back . forth = id and forth . back = id
04:30:12 <Taneb> hoppfull: what's «(back . forth) "not an int"» with your definitions?
04:30:23 <merijn> hoppfull: You mean isomorphisms?
04:30:29 <Taneb> The general term, by the way, is "isomorphism", but there's no isomorpism typeclass
04:30:58 <merijn> An isomorphism typeclass would be useless anyway, since instances must be unique, but isomorphisms are far from unique
04:31:33 <hoppfull> merijn: An isomorphism is too strict in that there has to be a 1-to-1 correspondence between the two types. Sometimes several values in one type maps to the same in the other type.
04:32:13 <merijn> "morphism", then :p
04:32:46 <hoppfull> merijn, a pair of morphisms where neither has to be monic or epic (I think are the terms)
04:33:33 <hoppfull> Anway, it's not super important. I was just curious.
04:35:02 <hoppfull> I'm using Haskell in production and we're learning how to use some of the mathematical structures to great effect.
04:35:51 <hoppfull> The ability to "travel" between equivalent problems have already proved itself to be extremely valuable.
04:57:00 * hackage warp-systemd 0.1.0.0 - Socket activation and other systemd integration for the Warp web server (WAI)  https://hackage.haskell.org/package/warp-systemd-0.1.0.0 (domenkozar)
06:02:30 * hackage shakespeare-sass 0.1.4.1 - SASS support for Shakespeare and Yesod  https://hackage.haskell.org/package/shakespeare-sass-0.1.4.1 (brcha)
06:59:30 * hackage scanner 0.3.1 - Fast non-backtracking incremental combinator parsing for bytestrings  https://hackage.haskell.org/package/scanner-0.3.1 (YurasShumovich)
07:29:13 <catchme>   writeSTRef i 0
07:29:13 <catchme>   let loop = do
07:29:13 <catchme>         it <- readSTRef i
07:29:13 <catchme>         let v = nums !! it
07:29:13 <catchme>         updateVal v
07:29:13 <catchme>         p <- readSTRef pos
07:29:14 <catchme>         nn <- readSTRef neg
07:29:14 <catchme>         modifySTRef' ansp (+p)
07:29:15 <catchme>         modifySTRef' ansn (+nn)
07:29:15 <catchme>         modifySTRef' i (+1)
07:29:15 <catchme>         if it+1 >= n then (return ())
07:29:16 <catchme>           else loop
07:29:17 <catchme>   loop
07:29:18 --- mode: ChanServ set +o glguy
07:29:19 --- kick: catchme was kicked by glguy (catchme)
07:29:30 * hackage urbit-hob 0.2.0 - Hoon-style atom manipulation and printing functions  https://hackage.haskell.org/package/urbit-hob-0.2.0 (JaredTobin)
07:30:14 <glguy> catchme: You can use gist.github.com or another (not pastebin.com) pastebin if you'd like to share code
07:31:08 <catchme> shouldn't that run in linear time and space? https://www.irccloud.com/pastebin/2uAeyIT8/
07:36:24 <nil> why is (<$>) left-associative, and not right-associative like ($) ?
07:37:04 <Rembane> I guess without thinking that it is to play nice with (<*>)
07:37:12 <ski> why isn't `$' and `$!' left-associative, like application, and `<$>' ?
07:37:13 <Rembane> Does it play nice with (<*>)?
07:37:45 <phadej> ski: the associativity of $ is really matter of taste
07:37:49 <Taneb> > (,) <$> [1,2,3] <*> ['a','b','c']
07:37:52 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
07:37:53 <nil> Rembane: that shouldn't be the case as they have different precedences
07:37:54 <phadej> sometimes I define some operator to be left associative
07:38:04 <phadej> so one could write foo $$ asdad asdasd $$ bar bar
07:38:39 <ski> @type \f ia ib ic -> f <$> ia <*> ib <*> ic
07:38:40 <lambdabot> Applicative f => (a1 -> a2 -> a3 -> b) -> f a1 -> f a2 -> f a3 -> f b
07:38:47 <ski> @let let infixr 4 <$$>; (<$$>) :: Functor f => (a -> b) -> f a -> f b; (<$$>) = (<$>)
07:38:47 <lambdabot>  Parse failed: Parse error: EOF
07:38:53 <ski> @let infixr 4 <$$>; (<$$>) :: Functor f => (a -> b) -> f a -> f b; (<$$>) = (<$>)
07:38:55 <lambdabot>  Defined.
07:38:58 <ski> @type \f ia ib ic -> f <$$> ia <*> ib <*> ic
07:38:59 <lambdabot> error:
07:38:59 <lambdabot>     Precedence parsing error
07:38:59 <lambdabot>         cannot mix ‘<$$>’ [infixr 4] and ‘<*>’ [infixl 4] in the same infix expression
07:39:23 <ski> both `<$>' and `<*>' are at level `4'
07:39:28 <nil> i guess having ($) left-associative just like normal application would make sense, but i can't see that being useful for (<$>)
07:39:37 <ski> @src foldl'
07:39:38 <lambdabot> foldl' f a []     = a
07:39:38 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
07:39:41 <nil> ski: you mean <$$> ?
07:39:45 <ski> the latter line can be written as
07:39:57 <Rembane> nil: Okay, oh well.
07:40:06 <ski>   foldl' f a (x:xs) = (foldl' f $! f a x) xs
07:40:14 <nil> oh no you're right, they're both 4
07:40:16 <ski> if `$' were left-associative, we could write
07:40:21 <nil> Rembane: nevermind
07:40:23 <ski>   foldl' f a (x:xs) = foldl' f $! f a x $ xs
07:40:46 * ski . o O ( and who in their right minf uses `$' right-associatively, anyway ? )
07:40:49 <nil> ski: yes indeed. but i find this hard to apply to <$>
07:41:09 <ski> see the above precedence error ?
07:41:18 <nil> (a <$> b) <$> c  seems weird, since it forces the first (<$>) to refer to the ((->) r) functor
07:41:39 <lyxia> catchme: maybe, what makes you think it doesn't?
07:42:48 <nil> ski: having a right-associative <$> would mean it having higher precedence than <*>, i guess
07:44:30 <ski> hm, i suppose
07:45:01 <catchme> lyxia: this is a problem on codeforces and it gives `time limit error` and I am translating c++ solution
07:45:02 <catchme> https://codeforces.com/contest/1215/problem/B
07:45:02 <catchme> error when input is of length `200000`
07:45:13 * nil isn't a huge fan of the `f . g $ x` (or `f . g <$> x`) style
07:47:07 * ski usually prefers `(f . g) x' to the former
07:51:33 * EvanR hopes that this can be done whenever (f . g) x appears:    a b ((f . g) x) d  =>  a b (h x) d where h = f . g
07:51:44 <EvanR> but alas
07:51:57 <lyxia> catchme: you are using (!!) which takes linear time
07:52:33 <heatsink> Why not f $ g x
07:52:42 <EvanR> yeesh
07:53:06 <nil> heatsink: ok, simplistic example. i meant more like `f . g $ some long expression`
07:53:08 <hyperisco> Why not  g x & f
07:53:22 <lyxia> why make it simple when you can make it complicated
07:53:35 <EvanR> let f = my . long . func . chain in f x
07:53:52 <nil> hyperisco: you mean `x & g & f`
07:53:55 <EvanR> down with the brackets and the $
07:55:20 <catchme> lyxia: aha!
07:55:20 <catchme> if you won't mind some other questions 
07:55:20 <catchme> what is the best alternative for !!
07:55:20 <catchme> should I use arrays? how can I expand an array without using vector?
07:56:15 <hyperisco> Usually you start from the top to figure how the problem can be solved without indexing as such
07:56:23 <lyxia> catchme: you can write a recursive function which traverses the list
07:57:05 <hyperisco> But you may get stuck with Map anyways.
07:57:12 <EvanR> or IntMap
07:57:48 <lyxia> if your goal is to practice using Haskell, don't use references at all for this kind of problem
07:59:01 <catchme> so I should use all needed values as function arguments all the time
08:00:37 <lyxia> that's an odd way to look at it but I guess it's one way a more functionl solution might look like.
08:02:51 <catchme> what is the better solution? 
08:06:04 <hyperisco> catchme, What is your program?
08:07:24 <merijn> hmm
08:07:44 <merijn> -ddump-splices seems to not be working when I' building via v2-build
08:08:19 <catchme> I use STref to store bebug info https://www.irccloud.com/pastebin/WqhBFBVf/
08:08:25 <merijn> ah, no it just puts them hidden far away in the build dir...
08:08:32 <catchme> debug**
08:08:57 <hyperisco> I haven't rigorously solved the problem but I think you can do it with a single pass, and so probably a foldl' works fine
08:14:42 <catchme> I will try foldr1
08:18:20 <dmwit> > fold $ scanl (\(n,p) v -> case compare v 0 of LT -> (p+Sum 1,n); EQ -> (0,0); GT -> (n,p+1)) (0,0) [4,2,-4,3,1,2,-4,3,2,3]
08:18:23 <lambdabot>  (Sum {getSum = 28},Sum {getSum = 27})
08:19:02 <dmwit> Oh, they say no zeros. Well my solution handles zeros anyway. ;-)
08:21:04 <catchme> dmwit: wow
08:25:35 <dmwit> (On my machine, this handles 20k inputs in 0.03s 9M, well under the 2s 256M limit, though perhaps my machine is a bit more recently built than theirs.)
08:26:05 <c_wraith> dmwit: Sum has a Num instance..  You don't need Sum 1 unless it's for type hinting...
08:26:11 <dmwit> It is for type hinting.
08:26:20 <dmwit> Note that I didn't use it in the GT branch. ;-)
08:27:38 <c_wraith> that looks too lazy to me, though.
08:27:56 <dmwit> Oh, I'm sure it can be done more efficiently with some effort.
08:28:10 <dmwit> e.g. by carrying around a 4-tuple and doing the additions immediately.
08:28:22 <hyperisco> It is intriguing. I feel like there is a simplification, but it escapes me.
08:28:32 <dmwit> But this way is simple, obviously correct, and costs very little programmer time.
08:28:58 <c_wraith> I'm not even looking at the scanl.  I'm just looking at fold using the (a, b) instance.  Already too lazy.
08:29:26 <dmwit> Wouldn't using a 4-tuple and doing the additions immediately fix that?
08:30:08 <c_wraith> probably, but now I've sidetracked myself on the question of whether fold is ever appropriate for a strict monoidal operation.
08:30:10 <dmwit> (Hell, you're not even complaining about the actual inefficient part of my solution, which is to call `map read`.)
08:30:43 <dmwit> FWIW I believe GHC's strictness analysis and inlining is up to the task of making this efficient here, because 9M is too small for a 20k-long list (or 20k-deep nested thunk).
08:31:44 <dmwit> Hm, maybe not. Never mind.
08:31:53 <hyperisco> Ah yes, I think I am on it now
08:31:54 <dmwit> Anyway yes, a little effort will likely improve the situation a lot.
08:32:07 <hyperisco> Quite often with these problems there is a way to dramatically reduce the complexity
08:32:22 <hyperisco> The idea being that naive solutions will violate the time or memory constraint
08:32:39 <dmwit> Well... the complexity of this solution is linear. I don't think you can reduce it below that; you certainly have to at least look at every element.
08:33:31 <hyperisco> If you already have it at linear then I agree
08:34:13 <dmwit> Oh, I just saw catchme's original solution.
08:34:36 <dmwit> It's basically the same, up to using ST instead of pure calculation, and up to iterating over indices rather than elements which is easy to fix.
08:34:57 <dmwit> Just the latter fix would improve his runtime from quadratic to linear, like mine.
08:36:08 <dmwit> ...I changed my mind. I don't understand their original solution. For one, it doesn't include the definition of updateVal.
08:38:39 <hyperisco> I didn't see it could be solved recursively like that so simply. Nice solution.
08:40:56 <dmwit> > let update (n,p,sumn,sump) = sumn `seq` sump `seq` (n,p,sumn+n,sump+p) in foldl' (\(n,p,sumn,sump) v -> update $ case compare v 0 of LT -> (p+1,n,sumn,sump); EQ -> (0,0,sumn,sump); GT -> (n,p+1,sumn,sump)) (0,0,0,0) [4,2,-4,3,1,2,-4,3,2,3] -- for you, c_wraith
08:40:59 <lambdabot>  (4,6,28,27)
08:41:53 <catchme> what is the equivalent of `foldl1` for `foldM`?
08:42:32 <c_wraith> I'm still busy being concerned about all the times I've used foldMap.  I think it can't actually be made correct in terms of strictness
08:42:44 * dmwit nods agreement
08:43:17 <merijn> c_wraith: You mean "you can't really make the accumulator strict"?
08:46:38 <c_wraith> merijn: I mean that there is no way to use it without creating some nested thunk that mirrors the shape of the structure being folded.  Correct strictness means giving the caller control over how thunks are nested.  Sadly, this often requires something like the foldl'/foldr split to achieve
08:48:43 <c_wraith> hmm.  technically foldl' can be written as foldr, so maybe there's a clever solution somewhere.
08:50:23 <lyxia> GHC has a pretty good strictness analyzer
08:50:36 <catchme> Thanks guys, this work https://www.irccloud.com/pastebin/QdylDmwD/
08:50:37 <lyxia> if you write sum with foldl or foldMap it will optimize that nicely
08:52:46 <c_wraith> with enough inline annotations...
08:53:18 <c_wraith> which is fine when they're coming from a library.  More annoying when I have to write them myself.
08:59:00 * hackage discord-haskell 1.1.2 - Write bots for Discord in Haskell  https://hackage.haskell.org/package/discord-haskell-1.1.2 (Aquarial)
08:59:31 <michalrus> Ummm, can I use `deriving instance Generic ExternalLib.SomeDT` in my Orphans.hs?… :o
08:59:36 <michalrus> It seems to work…
09:10:20 <peters> I have a problem to understand the type definition of a foldtree function. I know the type is foldtree :: (a -> a -> a) -> (Integer -> a) -> Tree -> a but I don´t understand how to get this type definition if I only have the function in code. I know that (a -> a -> a) is a function that takes 2 parameters and returns a type a. but i don´t know
09:10:21 <peters> where the (a -> a -> a) and the other parts come from. can anyone help me, please? here is the code: https://gist.github.com/dansa7/b167a8602876d1dd8ffe97452684106c
09:12:01 <merijn> peters: They're argument of the foldtree function
09:12:14 <merijn> peters: So "where they come from" is "the person who calls foldtree"
09:12:58 <merijn> peters: Do you understand "map"?
09:13:00 <merijn> :t map
09:13:01 <lambdabot> (a -> b) -> [a] -> [b]
09:13:17 <peters> ok but does this mean that (a -> a -> a) is the f part in my function? foldtree f g (Node a b) = ...
09:13:18 <merijn> peters: If so: "where does the (a -> b) come from?"
09:13:33 <merijn> peters: Yes
09:16:20 <peters> ok but why do I have only a and no b? maybe a studid question. and then I guess that (Integer -> a) is the "g" part of the foldtree. but how do I know that "g" is that function? The "Tree" part then probably is the (Node a b) | (Leaf n) part. But I don´t understand where I can see that the return type is a (last -> a)
09:17:05 <merijn> peters: The variables in your function definition just correspond to the type "in order"
09:17:34 <merijn> peters: 'f' is the first variable/argument to foldtree, so it corresponds to the (a -> a -> a), 'b' is the 2nd, so it corresponds to (Integer -> a), etc.
09:19:35 <peters> ok I think I understand this part. But I don´t understand why f is (a -> a -> a) when the map has the definition (a -> b) -> [a] -> [b]
09:20:00 * hackage eventlog2html 0.4.0 - Visualise an eventlog  https://hackage.haskell.org/package/eventlog2html-0.4.0 (mpickering)
09:21:06 <monochrom> foldTree should be compared to list's foldr rather than map.
09:24:01 * hackage mergeful 0.0.0.0 -   https://hackage.haskell.org/package/mergeful-0.0.0.0 (Norfair)
09:24:04 <monochrom> For beginners it may be even better to not compare at all, just do the honest type inference. Beginner analogies are always wrong (by definition of "beginner").
09:24:22 <monochrom> Well, either wrong or not even wrong.
09:25:00 * hackage genvalidity-mergeful 0.0.0.0 -   https://hackage.haskell.org/package/genvalidity-mergeful-0.0.0.0 (Norfair)
09:26:55 <monochrom> According to "f (foldtree f g a) (foldtree f g b)", both arguments of f come from calling foldtree again, so they have the same type, let's call it "a". So f :: a -> a -> ??? we know this much now.
09:28:38 <monochrom> And according to "foldtree f g (Node a b) = f ... ...", foldtree's codomain is the same as f's codomain. We have just let "a" be foldtree's codomain, so this is also f's codomain.  f :: ??? -> ??? -> a we know this much.
09:28:49 <monochrom> Putting it together f :: a -> a -> a
09:29:06 <monochrom> map's story is different and enjoys more freedom.
09:29:19 <monochrom> Analogies are like insider jokes.
09:29:33 <peters> oh ok. and "g" is (Integer -> a) because of ... = g n 
09:32:27 <peters> the return type of foldtree is "a" because of the left side of the "=" from foldtree f g (Leaf n) = g n? 
09:34:43 <monochrom> No, we give it a name "a" and see where it brings us.
09:36:37 <monochrom> Type inference uses the same skill as solving word problems for algebra classes.  "John's is 5 years older than Mary" OK we still don't know their ages but we can name John's age j, Mary's age m, and right away j = m+5 we know this much.
09:40:58 <peters> but the "a" in (a -> a -> a) is the same "a" as in the (Integer -> a) and "... -> Tree -> a" part?
09:42:04 <monochrom> According to "foldtree f g (Leaf n) = g ..." g's codomain has to be foldtree's codomain too, so g :: ??? -> a
09:43:11 <monochrom> According to "g n", "Leaf n", and "data Tree = ... Leaf Integer", n :: Integer, so g :: Integer -> ???
09:44:16 <monochrom> According to "foldtree f g (Node blah blah)" and/or "foldtree f g (Leaf whatever)", foldtree's 3rd argument ought to be Tree.  foldtree :: ? -> ?? -> Tree -> a
09:45:28 <monochrom> In every sentence I said you have no choice, apart from what name you give to foldtree's codomain. Once you have chosen a name you have to stick to it.
09:46:31 <peters> ah ok now I do understand where the "a" comes from. it is just the defined name for the foldtree result
09:46:53 <geekosaur> or picked randomly becaause it has to be called something
09:52:43 <peters> thank you very much for the help. it is the first time I have seen a haskell snippet. so i was a little confused about some parts. I think i am going to buy some good books. but know at least i understand where the parts come from the type definition. thank you
09:54:16 <geekosaur> :t let eyedee x = x in eyedee -- current ghc likes to pick "p" when it doesn't know anything else. humans tend to use "a"
09:54:17 <lambdabot> p -> p
09:54:35 <geekosaur> it's been known to use "t" as well
10:07:01 <dminuoso> geekosaur: What algorithm does GHC use to pick those?
10:08:05 <geekosaur> dunno in detail. it picks letters for fresh type variables, and then derived types tend to have numrals attached (which is why those annoying t vs. t0 type errors when it doesn't unify something you were expecting it to)
10:08:31 <dminuoso> What do you mean by "derived type"?
10:08:37 <geekosaur> it also tries to reuse any type variables it gets via existing type signatures
10:08:47 <dminuoso> Is that types that come from the type inference?
10:08:59 <geekosaur> yes
10:09:38 <geekosaur> either because it's doing inference, or because it found itself (say) using a type signature in two different places with possibly different types, so it differentiates between them with a numeral
10:10:21 <geekosaur> :t (+)
10:10:23 <lambdabot> Num a => a -> a -> a
10:11:08 <geekosaur> if it's typechecking an expression which uses it twice and can't prove they're the same type (maybe one is inside a fromIntegral and the other is Double), one of them gets a0 instead of a
10:11:15 <Guest_80> Hello. I succesfuldt installed ghc and cabal-install from ghcup. I also installed the stack from haskell's site. However when I type ghci the commend is not found. It has to do with my path variable but I don't get it. 
10:12:20 <sclv> Ghcup recommends how to change your path when you run it
10:12:45 <geekosaur> $HOME/.ghcip/bin needs to be in $PATH, then you need to run "ghcup set" to specify which ghc version to make available there
10:12:55 <geekosaur> which you can change later if needed with another "ghcup set"
10:13:25 <Guest_80> so haw am I going to do that
10:13:28 * glguy plays the iterate your .travis.yml file and wait a couple minutes game
10:14:15 <Guest_80> In order to run ghc and cabal, you need to adjust your PATH variable.You may want to source 'this this this' in your shellconfiguration to do so (e.g. ~/.bashrc).
10:14:16 <phadej> glguy: just use haskell-ci! (though you may still want to play that game anyway)
10:14:22 <glguy> phadej: That's what I'm doing
10:14:29 <phadej> glguy: nice :)
10:14:31 <glguy> start with haskell-ci and then iterate until it works
10:14:36 <glguy> and it just worked! yay
10:14:48 <Guest_80> ?
10:14:57 <phadej> glguy: manually editing haskell-ci is a "CI smell", there's plenty of configuration knobs, so you won't need to
10:15:09 <glguy> What's the knob for it to use my submodules?
10:15:19 <phadej> the one I haven't implemented :/
10:15:20 <glguy> (the answer isn't --submodules)
10:16:25 <glguy> editing the haskell-ci output smells better than writing this stuff out by hand :)
10:16:38 <phadej> oh, there is --submodules
10:16:41 <phadej> why it doesn't work?
10:16:47 <glguy> It doesn't put the submodules in cabal.project
10:17:03 <phadej> have you haskell-ci cabal.project ?
10:17:51 <glguy> No, I gave it the .cabal file. Would this work if I gave it cabal.project then?
10:18:06 <phadej> yes
10:18:10 <glguy> yay!
10:18:16 <phadej> it takes cabal.project files for multi-package projects
10:18:50 <sclv> Guest_80 just google how to modify your path in bashrc
10:28:25 <iqubic> Well, I completed dminuoso's challenge.
10:28:28 <iqubic> How do I tell lambdabot to send a message to someone?
10:28:37 <glguy> You don't
10:28:44 <iqubic> Huh?
10:29:10 <iqubic> So why does lambdabot sometimes send me a pm with: "you have N messages"?
10:29:39 <glguy> Ah, that's ?tell
10:29:53 <glguy> I was referring to having it send a /msg directly
10:29:57 <novum> just want to make sure this is not impossible. group project for school. neither of us (group of 2) know too much about coding haskell. team mate is very fluent in maths and functional programming. I know a little practical haskel. we want to make a package manager in haskell that uses SQL stuff and also front-end website to be able to view package archives. Obviously the name is pacmon, short for
10:29:58 <iqubic> Ah.
10:30:00 <novum> pacmonad and a play on pacman from arch. but is that doable? we also want to use haskell to model the ER diagram in the database
10:30:56 <novum> hi, glguy! you are everywhere. are you God? :o
10:30:59 <iqubic> msg lambdabot test
10:31:43 <glguy> novum: I guess that depends on if you believe in me
10:36:20 <iqubic> @ping
10:36:20 <lambdabot> pong
10:40:48 <iqubic> Well, I have now sent my messages to dminuoso
10:41:33 <iqubic> newtype Pretext s a = Pretext { runPretext :: forall f. Functor f => (s -> f s) -> f a }
10:42:02 <iqubic> Believe it or not, that is a valid comonad. It was hard to write the instance functions, but I did it.
10:52:28 <novum> glguy, I firmly maintain an agnostic viewpoint. How can one claim the existence or absence of you? it is not possible, in my insignificant opinion
10:52:45 <kky> why
10:52:56 <glguy> kky: There's no way to know
10:53:18 <iqubic> This doesn't list the laws for a ComonadStore instance: https://hackage.haskell.org/package/comonad-5.0.5/docs/Control-Comonad-Store.html
10:53:37 <iqubic> In fact, it doesn't tell you what any of those functions are supposed to do.
10:54:03 <novum> glguy, do you think the project is doable?
10:54:26 <glguy> novum: I think it will be quite a big challenge if you aren't already comfortable programming in Haskell
10:54:40 <kky> haskell is <3
10:56:53 <geekosaur> agreed. haskell can certainly do it, whether you know how is another question. and if you're not comfortable with Haskell already you have quite the learning experience upcoming
10:56:59 <novum> glguy; God; whoever, well, thanks for the honest input.
10:58:16 <novum> I mean---I have read half of learn you a haskell; so, doesn't that make me a Haskell pro?! ;)
10:58:31 <EvanR> lol
10:58:46 <iqubic> Becoming a Haskell pro is hard.
10:59:03 <novum> where would you start?
10:59:07 <iqubic> I spent 2 hours last night just trying to write a single function.
10:59:51 <iqubic> Granted, I was using comonads, which is hard.
11:00:03 <novum> sounds accurate. I am not daunted---too much, at least.
11:00:57 <glguy> iqubic’s past performance is not indicative of future results
11:01:14 <iqubic> glguy: What is that supposed to mean?
11:02:40 <EvanR> disclaimer at the bottom of iqubic 's haskell commercial
11:03:12 <iqubic> novum: Stay away from comonads for a long while. You don't need them yet.
11:04:02 <glguy> No one needs them, but I don't think novum mentioned them
11:04:13 <iqubic> No.
11:04:25 <iqubic> I'm just sharing what I've been working on for the past while.
11:05:15 <nshepperd2> Programming is hard. Haskell is easy. Therefore haskell is not programming.
11:05:33 <iqubic> Not quite!
11:10:54 <novum> glguy, iqubic, got it! So use only comonads. Thanks for the tips.
11:12:26 <novum> seriously, however, where would you all start for learning haskell in a proper sense? writing actual programs? reading some sort of tutorial or documentation from a particular source? reading a particular book? Meditating and hoping that the universe somehow feeds you haskell knowledge that you can soak up through your spiritual pores? ...?
11:13:07 <glguy> I think it's good to start with a book like "Programming in Haskell" to learn the basics and then start writing a program you're interested in
11:13:48 <Ariakenom> meditate with a effigy of Church
11:13:48 <novum> Yes. I just found that from some youtube video which illustrated the author of said book.
11:14:53 <novum> I am a potential member of the Curry-Turing Church
11:16:17 <novum> https://news.ycombinator.com/item?id=17813344 ... ok.
11:17:01 <saml> i learned haskell by books
11:17:11 <saml> i learned romance by books
11:17:36 <Ariakenom> ... I don't really know how I learned haskell
11:17:51 <saml> you should learn by coding, not by books
11:25:23 <iqubic> I learned Haskell by being in here and asking questions about the things I wanted to learn about.
11:26:39 <mozzarella> I haven't learned haskell
11:29:57 <iqubic> What a cheesy answer.
11:30:37 <srid> Cheese omelette is the best omelette.
11:32:09 <tdammers> how about all of those
11:32:18 <tdammers> books, coding, asking people
11:32:24 <tdammers> also cheese omelette
11:33:02 <sm[m]> By any means necessary !
11:34:11 <dmj`> thinking is hard, just code haskell
11:34:28 <novum> is there a permissibly free pdf for "Programming in Haskell" by Graham Hutton?
11:34:49 <novum> If not, I will go look for it in this library; if I find it not, I shall order it.
11:34:52 <sm[m]> Include: keeping an eye on the discussions here and on stack overflow
11:35:28 <sm[m]> No, novum
11:35:56 <novum> okie dokie. thank you. I will go look for it in the library, then.
11:36:36 <sm[m]> A different, lighter book that I also like is:
11:36:37 <sm[m]> @where HTAC
11:36:38 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
11:40:11 <novum> this library - and apparently all of the libraries in Florida - do not have this book. oh, misfortune! how you have befallen me.
11:40:30 <sm[m]> Novum, I didn’t see an answer to your earlier q - personally I would say no, a package manager is too hard
11:41:03 <novum> sm[m], I mean it should be only 10 sleepless nights, right?
11:41:23 <sm[m]> ack, now I see the answer :)
11:41:26 <novum> you're probably right, but I guess we can be reckless a few times in our lives
11:41:30 <sm[m]> Nope
11:41:51 <novum> "Nope" regarding what?
11:42:05 <novum> "more than 10 sleepless nights"?
11:42:12 <sm[m]> Package management is a hard problem especially for Haskell
11:42:26 <novum> why is that the case?
11:42:35 <novum> is it not possible to build a dependency tree?
11:42:57 <geekosaur> I don't think they're handling Haskell packages. (which have some complications)
11:43:27 <sm[m]> You seemed to be saying you two newbs want to build Hackage in 10 days ?
11:43:37 <novum> not a pkg manager for haskell, no. a package manager in the light of "pacman" "from" archlinux.
11:43:44 <sm[m]> Maybe I misunderstood :)
11:43:51 <novum> and it's a purely academic endeavour - for learning!
11:43:55 <geekosaur> but package management is always a harder problem than it looks. then again you have something to work from, and presumably aren't doing the whole job (e.g. building packages)
11:44:09 <novum> yes. we are aware of the difficulty.
11:44:25 <novum> perhaps we underestimate it. but such is life.
11:46:56 <sm[m]> It’s true that cloning something is easier, and I don’t know how fast you’ll level up but I’m still going with no. But I’d love to follow along as you try
11:48:09 <sm[m]> Could be a valuable ecosystem feedback project
11:55:23 <novum> our plan is to get our power level over 9000 by the end of the week. Soon after, Freeza is sure to knock us on our butt. Then we should go super sayan one within the next two weeks, but first we will just need kirllin to die. Then rather quickly, we should achieve super sayan two and super sayan three and then super sayan god super sayan and then our project will be completed.
11:56:35 <novum> (for what it is worth, I am not this knowledgable about dragon ball z, but rather my friend helped me fill in the details for completeness. I hope it brightens someone's day even just a little bit.)
11:57:20 <novum> thank you all for the pointers. I'm sure I will be in here at some point, dumb founded yet hopefully not completely miserable.
12:05:24 <iqubic> @pl \x -> f y
12:05:24 <lambdabot> const (f y)
12:17:30 * hackage gi-gtk-declarative 0.6.0 - Declarative GTK+ programming in Haskell  https://hackage.haskell.org/package/gi-gtk-declarative-0.6.0 (owickstrom)
12:18:30 * hackage gi-gtk-declarative-app-simple 0.6.0 - Declarative GTK+ programming in Haskell in the style of Pux.  https://hackage.haskell.org/package/gi-gtk-declarative-app-simple-0.6.0 (owickstrom)
12:19:16 <sm[m]> novum: lol now I want to see the anime version
12:22:34 <monochrom> haha super sayan
12:29:04 <novum> :] bye thanks again. [:
13:28:22 <tabaqui2> does anyone have a Setup.hs that translate all found .lhs sources into pdf files?
13:30:42 <Rembane> tabaqui2: I use a Makefile for that.
13:31:08 <tabaqui2> line "find -name "*.lhs" --exec translate {} \;"?
13:31:32 <tabaqui2> nah
13:32:22 <tabaqui2> but probably, I cannot do this with custom setup
13:32:52 <tabaqui2> as I see, there is no hooks that deal with source files
13:33:10 <tabaqui2> even confHook deals with Components already
13:33:50 <tabaqui2> what a shame, it would be great to compile .lhs somewhere between haddock hooks
13:37:30 * hackage linnet 0.4.0.1 - Lightweight library for building HTTP API  https://hackage.haskell.org/package/linnet-0.4.0.1 (sergeykolbasov)
13:39:30 * hackage linnet-aeson 0.4.0.1 - Aeson JSON support for Linnet  https://hackage.haskell.org/package/linnet-aeson-0.4.0.1 (sergeykolbasov)
13:40:30 * hackage linnet-conduit 0.4.0.1 - Conduit-backed support for streaming in Linnet  https://hackage.haskell.org/package/linnet-conduit-0.4.0.1 (sergeykolbasov)
13:44:25 <tabaqui2> ah, nevermind
13:44:37 <tabaqui2> lhs2TeX is just unfinished
13:45:28 <tabaqui2> I have to mark for ignore every haddock comment, because lhs2tex cannot parse | correctly
13:54:21 <jgt> anyone know of a library for rendering numbers in a human-readable way? I'm thinking 1234 -> 1.2k, 5,678,901 -> 5.7MM, etc
13:54:39 <[exa]> MM?
13:54:55 <jgt> [exa]: millions are often denoted that way
13:55:09 <[exa]> locale-aware or not?
13:55:28 <jgt> [exa]: which I find a bit weird, but supposedly it's to not confuse anything with roman numerals
13:55:53 <[exa]> (MM is 2000 so well... :D )
13:56:10 <jgt> [exa]: ideally locale-aware, but I'll settle for less
13:56:41 <monochrom> Perhaps 5.6MM = 5.6m = 5.6 x 10^6  just to be annoying :)
13:57:58 <tabaqui2> it's not really hard to implement
13:58:10 <[exa]> jgt: surprisingly there's no package that would wrap the locale number printing
13:58:23 <[exa]> at least I can't find any now
13:58:36 <jgt> tabaqui2: I know, but I'd still like to know if someone has already done that work
13:59:25 <tabaqui2> I solved similar task
13:59:27 <tabaqui2> https://pastebin.com/jpU9bMjy
14:00:02 <tabaqui2> pretty printing for bytes
14:00:38 <jgt> I've never seen an indent style like that for your derived instances
14:00:55 <tabaqui2> I have a bunch of newtypes around
14:01:06 <tabaqui2> so I indent deriving on 41 column
14:01:15 <[exa]> jgt: maybe something like https://hackage.haskell.org/package/prefix-units-0.2.0/docs/Data-Prefix-Units.html
14:01:27 <tabaqui2> *51
14:02:27 <tabaqui2> basicall, I've started to learn haskell inspecting this code: https://github.com/corsis/PortFusion/blob/master/src/Main.hs#L172
14:02:54 <tabaqui2> so a lot of my habits are inherited from this guy
14:03:07 <jgt> [exa]: that looks pretty good!
14:04:01 <jgt> tabaqui2: it just looks like that guy likes to align absolutely everything he can
14:04:22 <tabaqui2> so do I :)
14:05:17 <tabaqui2> but I don't appreciate of using unicode symbols in source code
14:05:58 <EvanR> blasphemy.. at least for agda source code
14:06:08 <tabaqui2> s/appreciate/approve/g
14:06:29 <jgt> I wouldn't go as far as this guy has with alignment, but it's nice to make things look nice
14:06:41 <tabaqui2> well, it doesn't concern math articles ofc :)
14:07:21 <jgt> I also don't use unicode characters, but if I did, I'd be all in
14:07:27 <jgt> like, not just flirt with it
14:07:33 <mycroftiv> EvanR: nice to see a mention of agda, ive gone quiet in this channel because ive become totally obsessed with agda and have spent the past two weeks trying to penetrate its somewhat inscrutable mysteries
14:07:38 <tabaqui2> I agree
14:08:17 <tabaqui2> declare every significant function with unicode or none at all
14:08:42 <monochrom> I'm already using unicode.
14:08:51 <jgt> "penetrate its somewhat inscrutable mysteries" sounds so much like a line from Tim & Eric talking about the universe
14:08:56 <tabaqui2> monochrom: in which IDE do you work?
14:08:56 <monochrom> If I write "foo x = x" it's already unicode.
14:09:00 <EvanR> lol
14:09:02 <monochrom> emacs
14:09:03 <EvanR> knew that was coming
14:09:11 <tabaqui2> is it convinient?
14:09:29 <monochrom> If you're not already using unicode, what else could you be using? EBCDIC?
14:09:39 <monochrom> Yes.
14:09:45 <tabaqui2> koi8-r :)
14:10:41 <tabaqui2> it was a great encoding in 90th
14:12:22 * tabaqui2 is out
14:23:00 * hackage monadLib 3.10 - A collection of monad transformers.  https://hackage.haskell.org/package/monadLib-3.10 (IavorDiatchki)
14:56:04 <glguy> shapr: The other day you were saying config-value looked complicated (or something like that). I'm working on it today and wondered what you found complicated so I can see about addressing that
15:23:00 * hackage config-value 0.7.0.0 - Simple, layout-based value language similar to YAML or JSON  https://hackage.haskell.org/package/config-value-0.7.0.0 (EricMertens)
15:24:00 * hackage config-schema 1.2.0.0 - Schema definitions for the config-value package  https://hackage.haskell.org/package/config-schema-1.2.0.0 (EricMertens)
15:26:00 * hackage hookup 0.3 - Abstraction over creating network connections with SOCKS5 and TLS  https://hackage.haskell.org/package/hookup-0.3 (EricMertens)
15:27:00 * hackage glirc 2.33 - Console IRC client  https://hackage.haskell.org/package/glirc-2.33 (EricMertens)
15:58:15 <catchme> does `//` operator work with IOArray?
15:58:32 <glguy> what type does it have?
15:58:33 <monochrom> No.
15:58:50 <catchme> m <- IOA.newArray ((1, 1), (n, n)) 0 :: IO (IOArray (Int, Int) Int)
15:58:55 <monochrom> OK I spoke too soon, I don't know. :)
15:59:12 <glguy> catchme: No, what type does (//) have?
16:00:04 <catchme> IArray, but is there any for IOArray?
16:00:32 <jle`> catchme: https://hackage.haskell.org/package/array-0.5.4.0/docs/doc-index.html
16:00:55 <catchme> @type (//)
16:00:57 <lambdabot> Ix i => Array i e -> [(i, e)] -> Array i e
16:01:12 <glguy> catchme: Click on the 'IArray' link and it will show a list of the instances of that class
16:02:42 <catchme> glguy: I did, so there is no `//` for MArray
16:03:07 <glguy> @type (Data.Array.IArray.//) :: Data.Array.IO.IOArray i e -> [(i,e)] -> Data.Array.IO.IOArray i e
16:03:09 <lambdabot> error:
16:03:09 <lambdabot>     • No instance for (Data.Array.Base.IArray GHC.IOArray.IOArray e1)
16:03:09 <lambdabot>         arising from a use of ‘Data.Array.Base.//’
16:03:29 <glguy> catchme: OK, then you can't use // with IOArray
16:03:46 <glguy> That should also be apparent from the type of (//) without knowing the instances
16:04:00 <glguy> Since there's no IO in the final result of that function it wouldn't be able to sequence any updates
16:04:23 <catchme> Thanks, I think I got that
16:09:30 * hackage config-value 0.7.0.1 - Simple, layout-based value language similar to YAML or JSON  https://hackage.haskell.org/package/config-value-0.7.0.1 (EricMertens)
16:20:00 * hackage vega-view 0.3.1.5 - Easily view Vega or Vega-Lite visualizations.  https://hackage.haskell.org/package/vega-view-0.3.1.5 (DouglasBurke)
16:37:25 <catchme> import qualified Data.Array.IO.Safe as IOA
16:38:45 <catchme> Why does  `IOA.freeze  m` give wrong type? https://www.irccloud.com/pastebin/yDsTGCso/
16:45:00 * hackage hvega 0.4.1.0 - Create Vega-Lite visualizations (version 3) in Haskell.  https://hackage.haskell.org/package/hvega-0.4.1.0 (DouglasBurke)
16:49:55 <iqubic> So, I was working with this data 'newtype Pretext s a = Pretext { runPretext :: forall f. Functor f => (s -> f s) -> f a }' And I just figured out, after a long process that it is isomorphic to a 'Store s a' with Store being 'data Store (s -> a) s'
16:50:02 <iqubic> I just find that so so very cool
16:51:56 <mniip> it is
16:52:55 <monochrom> catchme: Carefully study the type of freeze again? Especially "m (b i e)" not simply "b i e"?
16:54:24 <iqubic> Also, I love the way that I ended up writting 'duplicate :: Comonad w => w a -> w (w a)' for a 'Pretext s'
16:55:37 <iqubic> I'll share the code if anyone wants me to.
16:55:42 <mniip> % :t \p -> store (`Control.Comonad.Store.peek` p) (pos p)
16:55:43 <yahb> mniip: ComonadStore s w => w a -> Store s a
16:55:45 <mniip> % :t \s -> Pretext (`experiment` s)
16:55:45 <yahb> mniip: ; <interactive>:1:7: error: Data constructor not in scope: Pretext :: ((s0 -> f0 s0) -> f0 a) -> t
16:55:55 <mniip> % :t \s -> Control.Lens.Context.Pretext (`experiment` s)
16:55:55 <yahb> mniip: ; <interactive>:1:7: error:; Not in scope: data constructor `Control.Lens.Context.Pretext'; No module named `Control.Lens.Context' is imported.
16:56:04 <mniip> % :t \s -> Control.Lens.Internal.Context.Pretext (`experiment` s)
16:56:04 <yahb> mniip: ComonadStore b w => w t -> Control.Lens.Internal.Context.Pretext (->) b b t
16:56:06 <iqubic> mniip: That's basically what I ended up writing.
16:56:50 <iqubic> pretextToStore g = Store (`peek` g) (pos g)
16:58:29 <shachaf> The real question is why, though.
16:59:30 <iqubic> Because I think it has strengthened my haskell skills.
16:59:55 <shachaf> The question is why (forall f. Functor f => (a -> f b) -> f t) is the same information as (a, b -> t)
17:01:04 <iqubic> The second one should be (a, a -> t) not (a, b -> t)
17:01:32 <shachaf> No, it should what I wrote.
17:02:08 <iqubic> Yes, you are right.
17:03:07 <catchme> monochrom: Thanks`m_i <- IOA.freeze m :: IO (Array (Int, Int) Int)`
17:25:00 * hackage warp 3.3.2 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.3.2 (KazuYamamoto)
17:27:25 <remexre> is there a way to get cabal-install to install something globally? (like to /usr/local, I mean)
17:29:32 <davean> remexre: absolutely - you can set the install directly
17:29:40 <davean> *directory
17:31:06 <remexre> will --prefix do that?
17:33:41 <sshine> why are Haskell IDE engines so hard to install?
17:34:43 <sshine> I see that ghcide has practically no package constraints; is that a feature? https://github.com/digital-asset/ghcide/blob/master/ghcide.cabal
17:34:54 <lyxia> because nobody got around to package them up properly?
17:35:03 <sshine> (ghcide is also known as hie-core)
17:36:07 <lyxia> they use stack which is one way to fix the versions of your dependencies
17:36:10 <sm[m]> sshine we’ve got to slow down the haskellers somehow
17:37:42 <lyxia> they also mention cabal in their instructions but I have no idea how that could ever work.
17:38:32 <sm[m]> It looks unusually loose, a temporary state of affairs
17:41:39 <sshine> I'll try and use stack nightly-2019-09-16 and use the exact same extra-deps as they do.
17:43:55 <sm[m]> sshine, another answer: Ghc evolves fast, ides and editors are many/fragmented, how to build performant ghc/ide integration has been a research problem, and corporate funding/support is still ramping up
17:44:38 <sshine> sm[m], tell me about it. I tried to look at ghc-mod, and between versions there appears rampant mutations in the module structure.
17:46:03 <sm[m]> It’s a well known issue. Ghcid is the reliable fallback solution and ghcide & friends is the current new hope
17:47:49 <sshine> right. I've been using flycheck-haskell on emacs, which I think just uses ghc?
17:48:45 <Heffalump> sshine: I use cabal and ghcide worked for me without significant problems
17:49:01 <Heffalump> though I did have to share a freeze file with someone else to help them work around problems
17:49:12 <remexre> this is maybe idris-specific, but cabal install --prefix /usr/local idris results in an idris binary, but unless I use sudo it can't find Prelude/Builtins
17:54:19 <sshine> hrm, if I just git clone their repo and 'stack build' it, that works. so yay.
17:57:40 <sshine> next, installing nodejs. ubuntu's npm --version is 3.5.2, and 'npm ci' is apparently available in "version 6". I wonder if that's 3.6 or if ubuntu is that much behind.
17:59:46 <sshine> haha. Unable to install extension 'digitalasset.ghcide' as it is not compatible with VS Code '1.34.0'.
17:59:55 <sshine> so my npm is too old, and my vscode is too new.
18:03:29 <sshine> if I'm going to use the Emacs LSP plugin, it seems that I probably have to upgrade Emacs from 25 to 26.
18:24:44 * sshine echo -e '#!/bin/sh\nstack ghc -- $@' >~/bin/ghc # full retard
18:53:00 * hackage antiope-shell 7.3.4 - Please see the README on Github at <https://github.com/arbor/antiope#readme>  https://hackage.haskell.org/package/antiope-shell-7.3.4 (arbornetworks)
18:54:07 * hackage antiope-sns 7.3.5 - Please see the README on Github at <https://github.com/arbor/antiope#readme>  https://hackage.haskell.org/package/antiope-sns-7.3.5 (arbornetworks)
18:55:01 * hackage antiope-messages 7.3.5, antiope-contract 7.3.5, antiope-dynamodb 7.3.5, antiope-s3 7.3.5, antiope-swf 7.3.5, antiope-optparse-applicative 7.3.5, antiope-athena 7.3.5, antiope-shell 7.3.5, antiope-sqs 7.3.5, antiope-core 7.3.5 (arbornetworks)
19:00:52 <novum> is hackage written in haskell
19:01:20 <sm[m]> Yup
19:02:19 <novum> this makes me happy. I saw a web page on a/the haskell site about how to make an irc bot in haskell.
19:03:51 <lyxia> "roll your own irc bot" on the haskell wiki?
19:05:33 <novum> probably
19:18:55 * novum feels a strong urge to learn category theory in hopes that monads simply make more sense. Is this urge folly? or will this urge prove tremendously useful?
19:20:26 <Axman6> It probably won't help much. the best thing to do is just use several monads.
19:21:07 <Axman6> novum: I fiound that this does a good job of explaining what the comon pattern monads represent is without using haskell: https://codon.com/refactoring-ruby-with-monads
19:23:05 <novum> scale 1-10, how complex is category theory? I been up to calc III. How long would it take to learn it, if dedicated? eg, how many hours?
19:23:13 <dmwit> novum: For IO specifically, I really like sigfpe's IO Monad for People Who Simply Don't Care. For monads generally, I really liked sigfpe's You Could Have Invented Monads (and Maybe You Already Have).
19:24:09 <dmwit> I spent two semesters in a Category Theory reading group (a few hours per week of reading/discussing) and got the basics. If you are very clever, perhaps you can pick it up quicker.
19:24:16 * novum just watched a youtube video: "Brian Beckman: Don't fear the Monad" and I watched the man hisself before: Graham Hutton on Computerphile (who didn't explain it well)
19:24:46 <dmwit> Your calculus knowledge will likely not help very much.
19:25:06 <novum> I'll look into these examples. That seems rather time consuming to learn category theory
19:25:07 <dmwit> (Though the practice it gives you at being rigorous, if you were taught in the right way, may help you.)
19:26:10 <dmwit> The definition of a category can be taught in ten minutes or less. But like with many languages, the thing that makes it useful is the big collection of libraries that people import, not the core computational substrate.
19:26:23 <novum> I want to learn things the proper way in the most rigorous sense, so that do not have to piece things together. But I also want to do it relatively quickly. I don't know if that is possible.
19:27:14 <dmwit> It is possible if 1. you have an excellent teacher and 2. you are willing to work very hard and 3. you are Euler.
19:27:58 <novum> are those ANDs or ORs
19:28:14 <dmwit> They are "and"s. Which is why I wrote "and".
19:28:31 <novum> I can't read AND I am rather tired.
19:29:03 <dmwit> I suppose it is also possible if 1. things 1-3 above or 2. you relax what the "relatively" in "relatively quickly" means enough. ;-)
19:29:35 <dmwit> But yeah, I really do think that learning it solidly requires a serious time commitment.
19:29:38 <novum> well, I will look into changing my last name to Euler. Do you think there are any girls that have said last name and would be willing to marry me in the next few days? I find the probability rather low.
19:29:41 <dmwit> I think this is true of just about everything, though.
19:30:12 <dmwit> (I find myself in pretty strong agreement with the ideas in https://www.norvig.com/21-days.html .)
19:30:25 <novum> relatively_quickly = a_few_weeks
19:31:43 <novum> 84.7% of individuals that are seeking to learn how to program have nothing close to 10 years to learn programming
19:32:48 <dmwit> Hm. I did.
19:33:05 <dmwit> In fact I had closer to 20, I think.
19:34:11 <novum> well, it doesn't exactly seem like anyone learns all of what they know about programming in a short amount of time and then never learn anything else. But, of course, many people need to learn how to program within a finite amount of time for, eg, school projects, etc
19:34:34 <dmwit> I started in middle school, continued through high school, an undergraduate degree, and a graduate degree. Now I am on the job, and still gaining expertise in new areas.
19:34:42 <novum> we all, hopefully, continue developing, however. And learning over the course of many years
19:35:24 <novum> but I need to have a grasp on these concepts, I feel, so that I can implement code to achieve what I need
19:35:42 <novum> but yes it's a learning process. I don't expect to learn everything in a few weeks. Just what I need.
19:36:28 <novum> so, I have gathered that category theory may not be much help for learning haskell?
19:37:22 <dmwit> I believe that you can get most (maybe 99%) of the value of Haskell-the-language without ever learning category theory.
19:37:51 <dmwit> I believe that you can use essentially all of Haskell-the-library-collection without ever learning category theory.
19:39:03 <novum> okie dokie. thanks for the input. I shall take it into consideration. would you recommend learning anything prior to learning haskell, regarding math[s] or any other theory?
19:39:16 <dmwit> I know that I can understand and use monads and monad transformers without ever learning category theory.
19:40:08 <novum> my friend was reading a book on functional programming and category theory seemed rather important, so .. I thought maybe I ought to give it a go
19:40:46 <dmwit> I think you can learn the maths in a demand-driven way: when you discover that you need to understand some corner of math to make sense of a blog post that seems like it does something you want to do or similar, learn it then.
19:41:00 <sshine> novum, a fellow student of mine had gotten really good with Standard ML (another functional language like Haskell), and for some reason had decided to not learn Haskell for a long time. when he picked it up, he realized that most of the very intricate code he'd written with parameterised modules in ML were, in fact, monads. it helps to learn abstraction when you have concrete fundamentals: when you've writ
19:41:06 <sshine> ten a recursive function with an accumulating result argument, you'll better understand how Reader and State monad work.
19:42:02 <sshine> novum, so I'd rather focus on getting stuff done in the least abstract way you can imagine, and then ask for feedback on how to improve readability, and soon enough you'll run into the more advanced programming patterns. :)
19:42:12 <dmwit> ^
19:42:45 <sshine> novum, it's like explaining what a species is to someone who's never seen an animal.
19:43:05 <monochrom> Plants have species too.
19:43:20 <monochrom> Beyond Meat(TM) species :)
19:43:33 <novum> okie dokie, dmwit. sshine, I find it hard to start implementing haskell code. beyond ghci and very simple programs, I have not programmed in haskell. I am searching for an entry point. Also, tempus fugit and I have many tireds and must do the sleeping thing that humans do.
19:43:34 <sshine> this hypothetical character is a basement dweller.
19:44:11 <monochrom> Also the "someone" would have to be a computer because they have seen themselves, an animal.
19:44:17 <sshine> novum, https://exercism.io/tracks/haskell may be of value
19:44:42 <sshine> monochrom, okay, my metaphor wasn't well-prepared. I won't try to save it.
19:44:52 <sshine> monochrom, at least it didn't include burritos.
19:45:29 <novum> ok I will open it, find the videos that people said 'bout monads and stuffs, then I sleep for a reasonable amount of hours to consider it sleep, but I should be leaving now I guess. So, if anyone else wants to help the least haskell-inclined person in the channel currently, speak now or forever hold your peace---at least until I wake up.
19:45:51 <sshine> forget monads
19:45:53 <novum> thank you, all
19:46:01 <novum> what are monads?
19:46:04 * novum has forgotten monads
19:46:05 <sshine> what are what?
19:46:35 <EvanR> men in black flashy thing
19:46:49 <novum> I am not actually that stupid. I know what monoids are, and I am kind of familiar with monads, but implementing them seems ... unfamiliar
19:47:27 <dmwit> Ah, well, if you know monoids you should be set.
19:47:32 <novum> but! I will definitely start at these exercism .. strange name .. web page
19:47:37 <dmwit> Monads are just monoids in the category of endofunctors.
19:47:39 <dmwit> ;-)
19:47:55 <novum> haha. yes. I can at least get the reference. very quaint.
19:48:20 <monochrom> I don't know whether this applies to you but: Too many people wonder about advanced math like category theory when they don't even respect the basics: If f(x)=x+x then f(2) does not "return" 4 and f does not "return" an Integer. If you respect the basic math then f(2) equals 4 and f's codomain is Integer.
19:49:41 <monochrom> And if you know function composition and respect that it's associative and have \x->x as identity, you already know enough category theory to start.
19:51:13 <sshine> in other news: I actually got ghcide (aka hie-core) to work in VSCode. sorta. not in test/, but in src/!
19:54:12 <novum> real programmers use butterflies to code
19:55:34 <novum> monochrom, I do "respect" the basics and am rather familiar with those concepts. So, I guess, as others have suggested as well, I will jump head first into programs
19:57:24 <novum> and obviously monads are just monoids in the category of endofunctors where the product is replaced by the composition of endofunctors and unit set by the identity endofunctor. It's quite simple, really.
19:58:25 <novum> I actually sort of do understand what that is saying except for the "in the category of" because I do not know what category theory really is all about, but I do know what endofunctors are and what the uunit and identity endofunctor is.
19:59:53 <novum> I believe it is more complicated than this, but to my knowledge, an endofunctor is a function that take a function (or functions?) and returns a function. right?
20:02:48 <monochrom> No it's simpler than that. A functor from a category to the same category.
20:03:37 <Axman6> none of this will heklp you in using Monads in Haskell (as opposed to monads in category theory)
20:03:44 <Axman6> help*
20:04:06 <novum> huh ok. also what is >>= called. I believe the type is something like  Mb -> (\a -> Ma) -> Ma but I don't know what it is called besides "shove" or something?
20:04:30 <Axman6> bind
20:04:48 <novum> right. thanks
20:05:40 <Axman6> did you look at the link I gave you on monads in ruby?
20:06:56 <novum> not yet. I was reading some pdf (that someone suggested was a more programmer-friendly view into monads) that I found in a more mathematically inclined article.
20:07:02 <novum> I will right now
20:24:30 * hackage rank2classes 1.3.1 - standard type constructor class hierarchy, only with methods of rank 2 types  https://hackage.haskell.org/package/rank2classes-1.3.1 (MarioBlazevic)
20:26:00 * hackage grammatical-parsers 0.4.0.1 - parsers that combine into grammars  https://hackage.haskell.org/package/grammatical-parsers-0.4.0.1 (MarioBlazevic)
20:29:00 <rajivr___> I am new to and learning Haskell. I am trying to develop an understanding around how Haskellers use the terminology - "lift". Reading https://wiki.haskell.org/Lifting it says - Lifting is the concept which allows you to transform a function into a corresponding function within another (usually more general) setting. (This makes some sense to me, but I don't claim to fully understand it).
20:29:36 <rajivr___> However on the wiki page there is `lift0 :: a -> Pair a`. I don't quite understand why it is called `lift0`?
20:30:09 <rajivr___> When it does not take a function and return a function. Its just a data constructor. Isn't it?
20:30:25 <Axman6> lift0 :: a -> f a
20:30:44 <shachaf> The page is making up the idea of an n-argument function being lifted. It's treating "a" as a "0-argument function".
20:30:46 <Axman6> lift1 :: (a -> b) -> (f a -> f b)
20:31:04 <Axman6> lift2 :: (a -> b -> c) -> (f a  -> f b -> f c)
20:33:18 <Axman6> is in in some ways fiundamentally different from liftN where N > 0, but it is useful with those functions: lift2 (+) somethingWhichReturnsANumber (lift0 10) -- add 10 to the result in some context
20:33:59 <Axman6> it is in some ways*
20:38:06 <rajivr___> Thanks Axman6 and shachaf  . I need to spend sometime thinking about how a corresponds to "0-argument function".  (I remember a similar idea mentioned most likely in Category Theory for Programmers, though I didn't understand it at that time).
20:38:31 <dmwit> rajivr___: I think one reasonable fix would be to replace "function" in the description of what lifting means with "value". So: "Lifting is the concep which allows you to transform a value into a corresponding value within another (usually more general) setting.".
20:38:42 <novum> I read. ok night I can't prop eyes open with splinters any longer
20:39:02 <dmwit> rajivr___: Then you don't need these references to 0-argument functions and stuff.
20:39:08 <Axman6> novum: did it make any sense?
20:39:39 <novum> I don't do much ruby, but it reflects what I have generally read about monads, and it made sense
20:40:17 <Axman6> yeah ruby isn't thwe point, it's the notion of "and then" in different contexts
20:41:44 <slack1256> Hi, quick FRP question for reactive-banana. `Behaviour a` are denoted by `Time -> a`, that doesn't mean actual implementation will be continously propagating values updating constant values each time, it just mean it will "act" as if did so, right?
20:41:50 <rajivr___> Thanks dmwit . 
20:41:56 <novum> I was thinking that error handling nils/nulls with this "and then" is important. Am I wrong? That is how hutton described it, as well.
20:42:02 <slack1256> The actual implementation will be some kind of event propagation framework.
20:42:27 <novum> if it is null, it should return null. otherwise, shove it to the next part. or am I not understanding?
20:42:38 <dmwit> slack1256: Right.
20:42:56 <dmwit> novum: Sounds right to me.
20:43:14 <dmwit> novum: Admittedly I didn't read the article. But it sounds very similar to what Maybe (and its Monad instance) does in Haskell.
20:43:27 <dmwit> ?src (>>=) Maybe
20:43:27 <lambdabot> Source not found. Are you on drugs?
20:43:28 <slack1256> Cool, thanks!
20:43:31 <dmwit> ?src Maybe (>>=)
20:43:32 <lambdabot> (Just x) >>= k = k x
20:43:32 <lambdabot> Nothing  >>= _ = Nothing
20:43:49 <dmwit> ^ "if it is null, it should return null. otherwise, shove it to the next part."
20:44:08 <Axman6> the article covers defining an and_then function for possibly null values, arrays and futures and shows how this abstracts the idea of doing something after something else has (possibly) produced result(s)
20:44:29 <novum> cool. I am 40% there. Now I need to do those exercism.io things tomorrow after I finish homework, and then once I write a few of em I should be 60% there. thanks I have to go to bed
20:44:36 <dmwit> g'luck!
20:44:54 <Axman6> May your dreams be full of monads
20:45:03 <Axman6> are dreams a monad? perhaps!
20:45:19 * novum mumbles stuff sleepily about monads and pain and functions as he brushes teeth and passes out cold
20:47:42 <EvanR> something about a mutually recursive pair of monads that run each other
20:48:07 <dmwit> Axman6: I think the movie Inception is proof they are not.
20:48:28 <Axman6> there was some definite joins going on there
20:48:36 <EvanR> inception breaks the monad laws somehow?
20:49:18 <Axman6> join . fmap join seems possible but not sure join . join is
20:51:19 * novum wakes up from a nightmare about comonads and category theory
20:51:31 <Axman6> since you can produce memories from dreams, you have Dream Memoty. Memories produced in a dream in a dream is just Dream (Dream Memory), which becomes Dream Memory when you leave the inner dream. Since we can also extract memories from a dream, dreams a re probably also comonads
20:51:44 <Axman6> Memory*
20:52:03 <novum> jk gnight. thanks again for help. I shall return but probably remain more silent unless I am unable to understand something. see ya
20:57:50 <EvanR> Dream and Memory should take an argument so you can cycle them
20:58:18 <EvanR> turn off the "no infinite types" reality flag
21:04:12 <jusss> I don't understand why this cause infinite type https://paste.ubuntu.com/p/kfJvrMMjbR/
21:05:41 <Axman6> fact (n-1)
21:06:04 <Axman6> what you've written is (fact n) - (1 (\t -> ret $ n * t))
21:06:51 <jusss> Axman6: oh
21:08:28 <jusss> Axman6: ghci really need a good repl ...
21:09:39 <Axman6> There's only so much help a repl can give for errors like that, since what you wrote is perfectly valid (apart from the infinite type)
21:10:38 <jusss> Axman6: does it enable TCO?
21:11:18 <Axman6> IIRC TCO isn't a specific optimisation in GHC< it basically comes for free from other optimisations
21:11:47 <Axman6> but you may need to start ghci with -O2 -fobject-code to get optimisations in GHCi
21:11:59 <jusss> ok
21:15:19 <c_wraith> yeah, any time an expression reduces to a function call, it's called in place - there's no new stack frame created for that.
21:15:43 <c_wraith> that serves to eliminate all tail calls
21:16:52 <jusss> c_wraith: that CPS can not solve stack overflow when do recursion, right?
21:17:07 <shachaf> I don't think tail call optimization is even a thing that makes sense to talk about with a non-strict evaluation model.
21:17:26 <c_wraith> stack frames are only allocated for nested evaluation
21:17:40 <c_wraith> and that need not have anything to do with function calls
21:18:12 <jusss> both crash, https://paste.ubuntu.com/p/zqVHVpgc97/
21:18:29 <c_wraith> the thing is, you need to get rid of nested evaluation
21:18:39 <jusss> by how?
21:19:03 <c_wraith> Oh, wait, you're talking about non-haskell code?  Yeah, python and javascript don't handle recursion very well.
21:19:30 <jusss> c_wraith: they don't have TCO
21:19:39 <monochrom> Wait, how are you transitioning from infinite types to stack overflows?
21:19:57 <c_wraith> yep.  they don't.  TCO isn't anything special in Haskell, though.
21:20:31 <monochrom> And why are you talking about python and javascript?
21:20:37 <c_wraith> It also isn't very helpful by itself in Haskell
21:20:38 <jusss> monochrom: this is the haskell version, I forget put () on (n-1)
21:21:00 <shachaf> Unpopular opinion: Tail call elimination is a bad optimization.
21:21:07 <shachaf> Oops, that's not a Haskell opinion.
21:21:47 <samspace> so this evening I read https://kcsongor.github.io/ambiguous-tags/ and it made me think about the difference between term level type signatures and type level kind signatures: an implementation of the type "forall a b. a -> b" on the term level is a total function mapping types "a" and "b" to a term of type "a -> b", whereas a type family
21:21:48 <samspace> implementation of the kind signature "forall i j. i -> j" is a partial function which says that for some types "i" and "j", we have a type level function "i -> j". This is obviously useful, as shown in this article, but you lose a lot too: for instance you don't get free theorems from polymorphic kind signatures. Is there any talk of having a "type
21:21:48 <samspace> function" feature which has the total function behavior for type level functions?
21:22:01 <zacts> is scheme tail call optimized?
21:22:09 <jusss> zacts: yeah
21:22:26 <jusss> zacts: written in the protocal
21:22:45 <zacts> shachaf: why would tail call elimination be a poor optimization technique for Haskell?
21:22:59 <shachaf> It's not even an optimization technique for Haskell, I don't think.
21:23:06 <zacts> oh
21:23:07 <shachaf> Haskell is evaluated by graph reduction. It has other problems.
21:23:29 <samspace> zacts: tail call optimization is only really useful in a stack based programming language, cause it prevents you from building more stacks
21:23:34 <shachaf> (Function calls are evaluated from the outside in, with no call stack.)
21:23:54 <zacts> shachaf: is this due to the lazy nature of Haskell?
21:24:00 <heatsink> samspace: There was a paper from rae about making type functions total over members of a type class
21:24:20 <zacts> I would be curious as to how Racket evaluates and optimizes their Haskell-in-s-expr-syntax mini-language.
21:25:00 <zacts> https://lexi-lambda.github.io/hackett/
21:26:10 <samspace> heatsink: their one on constrained type families?
21:26:16 <heatsink> samspace: Since type functions are often associated with classes, as in class Cls a where T a :: *, you can stipulate that T is total over the domain of the class
21:26:21 <heatsink> yes, that one
21:26:44 <samspace> that makes sense, but you still lose free theorems
21:27:23 <samspace> it would be nice to have free theorems for type functions
21:28:26 <samspace> heatsink: I guess I am looking for parametrically polymorphic type functions
21:29:07 <samspace> but perhaps the only really interesting ones are data types...
21:31:15 <heatsink> I don't know.  Type functions have to be limited so that type checking can terminate
21:31:20 <Axman6> is there a name for a Travertsal which will always return at least one result (so it unifies with Lens)?
21:32:05 <Axman6> Traversal*
21:32:44 <shachaf> Sometimes people say "relevant traversal".
21:32:50 <shachaf> There's no type for it in lens.
21:32:59 <Axman6> :'(
21:34:33 <dmwit> What motivates the adjective "relevant"?
21:35:18 <Axman6> there will always be relevant data perhaps?
21:36:39 <shachaf> dmwit: Relevant logic, I think?
21:37:36 <shachaf> Which is a substructural logic with no weakening.
21:38:00 * hackage antiope-sqs 7.4.0 - Please see the README on Github at <https://github.com/arbor/antiope#readme>  https://hackage.haskell.org/package/antiope-sqs-7.4.0 (arbornetworks)
21:39:00 * hackage antiope-dynamodb 7.4.0, antiope-optparse-applicative 7.4.0, antiope-s3 7.4.0, antiope-sns 7.4.0, antiope-swf 7.4.0, antiope-contract 7.4.0, antiope-shell 7.4.0, antiope-messages 7.4.0, antiope-athena 7.4.0, antiope-core 7.4.0 (arbornetworks)
21:42:17 <dmwit> People have invented some weird logics.
21:43:00 * hackage conferer-provider-json 0.1.0.1 - Configuration for reading json files  https://hackage.haskell.org/package/conferer-provider-json-0.1.0.1 (ludat)
21:43:36 <shachaf> dmwit: If you like "linear" and "affine" I think filling in the blank is pretty reasonable.
21:45:01 <dmwit> I also find linear and affine logics weird.
21:45:24 <dmwit> Maybe useful and certainly worth studying.
21:45:28 <dmwit> But also weird. =)
21:46:26 <shachaf> I didn't say anything about logic that time!
21:46:34 <shachaf> You could also like linear and affine maps.
21:47:40 <jle`> Axman6: you can write it, at least; type RelTrav s t a b = forall f. Apply f => (a -> f b) -> s -> f t
21:48:11 <jle`> and i think you should be able to use this with view
21:48:25 <Axman6> noice
21:48:57 <jle`> i think because Apply is not technically a superclass of Applicative you might have issues using it as a traversal though
21:49:04 <jle`> even though technically it should be able to be
21:49:15 <Axman6> yeah, toListOf is probably where I'd like to use it
21:49:35 <jle`> ah you can use it with *specific* traversals
21:49:39 <jle`> i think it should work with toListOf
21:49:50 <jle`> *specific traversal usages, that is
21:49:56 <Axman6> lens needs more semigroup
21:50:15 <jle`> the issue i think is more with 'base'
21:51:12 <jle`> oh, if you mean giving a name to RelTrav then yeah
21:52:04 <Axman6> just in general, I didn't see much which dealt with NonEmpty
21:52:43 <jle`> @let type RelTrav s t a b = forall f. Apply f => (a -> f b) -> s -> f t
21:52:44 <lambdabot>  Defined.
21:54:06 <jle`> @let travNE :: RelTrav (NE.NonEmpty a) (NE.NonEmpty b) a b; travNE = traverse1
21:54:07 <lambdabot>  Defined.
21:54:16 <jle`> > toListOf travNE (1 NE.:| [2,3,4])
21:54:18 <lambdabot>  [1,2,3,4]
21:54:25 <jle`> so yeah toListOf should work fine with it
21:54:37 <dansho> ghc installer says i need realpath. what is it?
21:56:07 <jle`> hm, i guess you can't use it directly with view because the choice of "which" a to pick is ambiguous
21:56:44 <jle`> but you can do it if you specify which one
21:56:57 <jle`> > view (travNE . to SG.First) (1 NE.:| [2,3,4])
21:56:59 <ttttt> hello does anyone a static analysis library for ecmascript?
21:56:59 <lambdabot>  First {getFirst = 1}
21:57:05 <jle`> > view (travNE . to SG.Last) (1 NE.:| [2,3,4])
21:57:07 <lambdabot>  Last {getLast = 4}
21:57:21 <Axman6> :t traverse1
21:57:22 <lambdabot> (Traversable1 t, Apply f) => (a -> f b) -> t a -> f (t b)
21:57:30 <Axman6> nice
21:57:38 <Axman6> @hoogle traverse1
21:57:38 <lambdabot> Control.Lens.Combinators traverse1 :: (Traversable1 t, Apply f) => (a -> f b) -> t a -> f (t b)
21:57:38 <lambdabot> Control.Lens.Traversal traverse1 :: (Traversable1 t, Apply f) => (a -> f b) -> t a -> f (t b)
21:57:38 <lambdabot> Data.Semigroup.Traversable traverse1 :: (Traversable1 t, Apply f) => (a -> f b) -> t a -> f (t b)
21:57:49 <jle`> i didn't need to use traverse1 but i just was too lazy to re-implement it in lambdabot
21:57:51 <Axman6> I assume it's the last one there?
21:58:20 <jle`> i used the last one but i presume it's the same as the lens one since they all have the same type signature
21:58:54 <jle`> oh way, lens library does have 'Traversal1', which is exactly what i wrote RelTrav as up there.
21:59:15 <jle`> *oh hey
21:59:23 <shachaf> Oh, so it does.
21:59:49 <shachaf> I guess I misremembered!
21:59:52 * Axman6 celebrates
22:00:06 <pacak> Did anyone managed to get haskell-ide-engine working with ghc 8.8?
22:00:08 <shachaf> It's AffineTraversal that it doesn't have.
22:00:30 <shachaf> For slightly silly but ultimately plausible reasons.
22:01:39 <jle`> i remember missing affine traversals a few times in the past. i suppose that is life.
22:03:42 <dansho> oh i guess it already exists on my system in coreutils
22:04:02 <shachaf> If you like: "affine" means "?", and "relevant" means "+"
22:04:27 <nshepperd> which one is affine traversal? 'at most one target'?
22:04:34 <shachaf> Yes.
22:05:28 <Axman6> it's that Prism?
22:05:35 <jle`> Prism is stronger
22:05:48 <jle`> Prism means you can construct
22:05:59 <Axman6> so the Getter version of Prism
22:06:01 * hackage conferer-snap 0.1.0.1 - Configuration for reading json files  https://hackage.haskell.org/package/conferer-snap-0.1.0.1 (ludat)
22:06:39 <nshepperd> a composition of prisms and lenses
22:07:19 <jle`> Axman6: i'm not sure how to interpret that. but yeah it would be somewhere in-between a Prism without review and Traversal
22:08:17 <jle`> if you look at the lens diagram here https://hackage.haskell.org/package/lens it would exist in that space along the arrow between Prism and Traversal, but before it joins up with Lens
22:08:46 <jle`> just to the left of the Review box
22:10:06 <Axman6> yeah I gues I meant something like a read only Prism (where a Getter is a read only lens)
22:11:18 <shachaf> It's not read-only, though. You can write to it.
22:11:41 <nshepperd> if you compose a Prism and a Lens currently, you get a Traversal
22:12:55 <nshepperd> but that's only because there isn't a superclass of Applicative which has only 'pure', i think
22:12:56 <jle`> oh yeah i see i am wrong, it exists 'above' where the Lens joins that arrow
22:13:32 <jle`> i might as well refer to phadej's diagram http://oleg.fi/gists/posts/2017-04-18-glassery.html#s:1
22:15:49 <jle`> that little cube on the top left is really pretty. i wonder if there is any meaning to the spatial structure of how it is laid out.
22:16:09 <jle`> i see that going up-left is somewhat semantically related to "only the gettering parts"
22:17:31 <jle`> alas my colorblindness prevents me from interpreting the coloring of the arrows.
22:18:12 <nshepperd> down = 'at most 1'; down-right = 'you can write'; down-left = 'at least 1'
22:18:14 <nshepperd> i think
22:18:15 <pie_> arianvp: can you comment on this library? https://www.reddit.com/r/haskell/comments/d3qdql/whatever_happened_to_open_data_types_and_open/f04xrks/
22:18:21 <nshepperd> are the three axes
22:18:31 <pie_> arianvp: alternatively, are your advisors aware of it?
22:20:32 <jle`> nshepperd: ah, that makes sense :O
22:20:37 <jle`> thanks :)
22:21:21 <jle`> that's neat, this paints a Lens as a Traversal1 with at most 1 target...which is not a way i would have thought to look at it, but seems true nonetheless
22:22:00 * hackage conferer-provider-json 0.1.0.2 - Configuration for reading json files  https://hackage.haskell.org/package/conferer-provider-json-0.1.0.2 (ludat)
22:22:05 <shachaf> That's certainly what it is.
22:22:18 <shachaf> "relevant" means "at least 1" and "affine" means "at most 1"
22:23:56 <shachaf> At one point I used the names Lens Lens+ Lens? Lens*
22:24:36 <jle`> Lens+ = Traversal1, Lens? = AffineTraversal, Lens* = Traversal
22:24:39 <jle`> that does simplify things a bit
22:24:58 * nshepperd . o O (the java name of Lens: AffineRelevantWriteableFold)
22:25:00 * hackage conferer-snap 0.1.0.2 - conferer's FromConfig instances for snap Config  https://hackage.haskell.org/package/conferer-snap-0.1.0.2 (ludat)
22:25:32 <jle`> ha
22:27:19 <Axman6> It's a shame those aren't valid names :(
22:28:12 <Axman6> nshepperd: not enterprisy enough. needs more UnfailableGetterFactory
22:29:34 <Axman6> what's the simplest lensy way to get the head of a NonEmpty list
22:31:15 <jle`> view (to NE.head)
22:31:37 <jle`> (this is a joke don't do this, my point is to just use NE.head)
22:31:58 <dmwit> to is a terrible name
22:32:01 <Axman6> well it's nested - I think traverse1 is probably it
22:32:04 <Axman6> it is
22:32:08 <Axman6> and I use it all the time
22:32:29 <jle`> what do you really want?
22:32:34 <jle`> do you want a traversal into the head of a NonEmpty list?
22:33:06 <jle`> "it's nested" suggests there is more to it than you are revealing
22:34:24 <Axman6> foo ^? _Just . traverse1 . someOtherLens is what I'm after
22:34:39 <jle`> ah you want an optic/etc. into the first item in a NonEmpty list
22:34:40 <Axman6> (accessing a Maybe (NonEmpty Foo))
22:34:41 <jle`> you can use 'head1'
22:35:28 <jle`> head1 is a lens into the first item in a NonEmpty list
22:35:36 <jle`> > view head1 (1 NE.:| [1,2,3])
22:35:38 <lambdabot>  error:
22:35:38 <lambdabot>      • Variable not in scope: head1 :: Getting t (NE.NonEmpty Integer) t
22:35:38 <lambdabot>      • Perhaps you meant one of these:
22:35:49 <jle`> but it's not a Traverse1, it's just a regular ol' Lens
22:35:51 <Axman6> sadly not exported by Control.Lens
22:36:00 <jle`> it is exported by Control.Lens.Lens
22:36:14 <jle`> if you're willing to spare an extra line for an import, or if the import list is in your control :)
22:36:34 <Axman6> I'll just use traverse1 since it is exported =)
22:36:45 <Axman6> gotta save those precious characters
22:36:59 <jle`> traverse1 doesn't get you into the head of a NonEmpty list
22:37:00 * hackage conferer-warp 0.1.0.1 - conferer's FromConfig instances for warp settings  https://hackage.haskell.org/package/conferer-warp-0.1.0.1 (ludat)
22:37:13 <nshepperd> it doesn't seem to be in the lens package i have installed
22:37:16 <jle`> it gets you every item in the NonEmpty list
22:37:29 <Axman6> sure, but if using ^? it will give me the first
22:37:45 <nshepperd> i was kind of thinking NonEmpty would just have a Field1 instance
22:37:50 <jle`> hm, if you're using ^? then you can just use traverse
22:37:57 <jle`> or folded
22:38:29 <jle`> > preview folded (1 NE.:| [2,3,4])
22:38:32 <lambdabot>  Just 1
22:39:10 <jle`> benefit of traverse, it's exported from Prelude :)
22:39:39 <Axman6> this is true, even more characters saved!
22:40:59 <jle`> but using ^? with _Just and a bunch of lenses suggests you can just use mapping
22:41:18 <jle`> er, mapped
22:41:30 <jle`> or, you are just trying to fmap foo
22:44:34 <Axman6> yeah fmap is probably simpler
23:06:43 <nshepperd> head1 f(x:|s)=(:|s)<$>f x is only one character longer than import Control.Lens.Lens
23:08:31 * hackage conferer 0.1.0.2 - Configuration management library  https://hackage.haskell.org/package/conferer-0.1.0.2 (ludat)
23:09:30 * hackage conferer-snap 0.1.0.3 - conferer's FromConfig instances for snap Config  https://hackage.haskell.org/package/conferer-snap-0.1.0.3 (ludat)
23:12:02 <dminuoso> @tell iqubic What does your implementation look like?
23:12:03 <lambdabot> Consider it noted.
23:12:30 <dmwit> nshepperd: Too bad, f`head1`x:|s=... doesn't work.
23:55:43 <Welkin> what ghv version are we on?
23:55:45 <Welkin> ghc*
23:55:47 <Welkin> I've been away
23:56:06 <Welkin> my god
23:56:08 <Welkin> 8.8.1
23:58:26 <Axman6> I remember when we were on 6.4. those were the days
23:59:09 <Welkin> I came around when it was 7.4 I think, or 7.6
