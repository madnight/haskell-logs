00:37:24 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org'
00:37:24 --- topic: set by glguy on [Sat Jan 05 07:21:52 2019]
01:08:32 <iqubic> :t sum
01:08:33 <lambdabot> (Foldable t, Num a) => t a -> a
01:08:42 <iqubic> :t genericLenght
01:08:43 <lambdabot> error:
01:08:43 <lambdabot>     • Variable not in scope: genericLenght
01:08:43 <lambdabot>     • Perhaps you meant ‘genericLength’ (imported from Data.List)
01:08:50 <iqubic> :t genericLength
01:08:52 <lambdabot> Num i => [a] -> i
01:09:00 <iqubic> Huh?!?! Why is that a thing?
01:09:30 <iqubic> What is the point of genericLength?
01:10:39 <shachaf> To be used with this type: data Nat = Zero | Succ Nat
01:10:51 <shachaf> There's no other point to it.
01:11:06 <iqubic> But that doesn't have an instance of Num, does it?
01:11:24 <iqubic> I'm sure you could write an instance of Num for Nat.
01:11:36 <shachaf> (Also, when you put your questions like that it makes me not want to answer them, and I suspect I'm not alone there.)
01:11:51 <iqubic> I'm sorry.
01:12:13 <iqubic> Is there anything I can do to be less intrusive?
01:14:22 <shachaf> Yes, you can write a Num instance, and it would effectively make genericLength a foldr with Succ and Zero.
01:16:21 <shachaf> Probably, but I don't feel like putting the energy into explaining it right now. I oughtn't have said anything at this hour.
01:31:02 <koz_> iqubic: The fact that length is always coming back as an Int can be annoying if you just end up fromIntegral-ing it all the time.
01:31:15 <koz_> genericLength allows you to avoid having to call fromIntegral.
01:34:02 <iqubic> I see.
01:47:30 <rhylx> I installed cabal with ghcup, and still, the default commands aren't the v2 ones, I have to manually add v2- before every cabal argument. Is it normal?
01:57:38 <dmwit> rhylx: What does `cabal --version` say? What does `which cabal` say?
01:58:29 <dmwit> rhylx: cabal-install 3 and up have v2 as default. Anything earlier does not. The "which" check is to find out if you're using the cabal that ghcup installed or unintentionally using something else.
02:03:25 <rhylx> I have version 3.0.0.0. And I'm using the one installed by ghcup
02:03:28 <rhylx> Thanks.
02:03:50 <rhylx> dmwit: do you usually use sandboxes?
02:15:58 <maerwald> rhylx: if you have a cabal in ~/.cabal/bin, then that would most likely (and should) "overwrite" the ghcup one
02:16:42 <maerwald> in which case 'cabal new-install cabal-install' would solve the problem
02:37:32 <Fimmind> > liftM2 (/) sum length $ [1, 2, 3]
02:37:34 <lambdabot>  error:
02:37:34 <lambdabot>      • No instance for (Fractional Int) arising from a use of ‘/’
02:37:34 <lambdabot>      • In the first argument of ‘liftM2’, namely ‘(/)’
02:38:26 <Fimmind> > liftM2 (/) sum length $ [1.0, 2.0, 3.0]
02:38:28 <lambdabot>  error:
02:38:28 <lambdabot>      • No instance for (Fractional Int) arising from a use of ‘/’
02:38:28 <lambdabot>      • In the first argument of ‘liftM2’, namely ‘(/)’
02:39:18 <Fimmind> liftM2 ((/) `on` realToFrac) sum length
02:40:16 <Fimmind> > liftM2 ((/) `on` realToFrac) sum length $ [1, 3, 3]
02:40:19 <lambdabot>  2.3333333333333335
02:40:40 <Fimmind> > liftM2 ((/) `on` realToFrac) sum length $ [1, 2, 3]
02:40:42 <lambdabot>  2.0
02:41:43 <Fimmind> @let (//) = (/) `on` realToFrac
02:41:46 <lambdabot>  Defined.
02:42:22 <madjestic> wait.  Why are the 2 results differ?
02:47:56 <nil> different lists
02:47:57 <madjestic> why the two2 liftM2 expressions above return different results?
02:48:00 <madjestic> ah
02:48:15 <madjestic> missed that :|
02:52:16 <nil> > liftA2 (/) sum genericLength [1, 3, 3]
02:52:18 <lambdabot>  2.3333333333333335
03:55:00 * hackage symbols 0.2.0.2 - Symbol manipulation  https://hackage.haskell.org/package/symbols-0.2.0.2 (kcsongor)
04:01:01 * hackage symbols 0.2.0.3 - Symbol manipulation  https://hackage.haskell.org/package/symbols-0.2.0.3 (kcsongor)
04:43:26 <dmwit> ?tell rhylx I do not usually use sandboxes. I do find it strange that you have cabal-install 3 and also the v2-* commands are not default. How do you know the v2-* commands are not default?
04:43:26 <lambdabot> Consider it noted.
04:52:31 * hackage eventlog2html 0.3.0 - Visualise an eventlog  https://hackage.haskell.org/package/eventlog2html-0.3.0 (mpickering)
04:54:32 <michalrus> Hey, so I’m trying to create a generic extractor for a field of certain type. So I defined:
04:54:33 <michalrus> instance ExtractUserId (G.K1 i UserId) where genericExtractUserId (G.K1 c) = Just c
04:54:33 <michalrus> instance ExtractUserId (G.K1 i c)      where genericExtractUserId _        = Nothing
04:54:38 <michalrus> But that’s an overlapping instance…
04:55:03 <michalrus> How should this be done?
04:59:45 <michalrus> I mean, I can just allow them to be overlapping… but is this the correct solution?
05:01:07 <[exa]> michalrus: wouldn't it be better to fail noisily at type level when the field is missing? (since the result is known at compilation)
05:01:54 <[exa]> if not, I guess allowing flexible instances isn't a problem
05:02:49 <michalrus> Mmmm… I want to it fail sometimes, because this is for logging events. If they have a UserId *somewhere*, then I want to save that info for later indexing
05:02:59 <michalrus> OK :)
05:03:01 <michalrus> Thanks!
05:03:24 <[exa]> also, there are several ways to do this "properly", closed type families are probably the best
05:03:32 <[exa]> see here https://kseo.github.io/posts/2017-02-05-avoid-overlapping-instances-with-closed-type-families.html
05:03:57 <michalrus> Oh, great, thanks. :}
05:04:39 <michalrus> Hmmmm, nice :o
05:04:56 <michalrus>   F Char  = 'True
05:04:56 <michalrus>   F a     = 'False
05:05:01 <michalrus> So that’s really non-overlapping, right!
05:05:15 <michalrus> Thanks :)
05:06:03 <[exa]> btw there are more solutions if you'd want to build larger stuff with this, including generics and SYB, but that's likely over-engineering for now
05:08:50 <hpyCdr> is it safe to remove the .stack and .cabal folders / wipe them to save disk space?
05:09:19 <tdammers> yes, with a few caveats
05:09:27 <tdammers> first, you will need to rebuild everything
05:09:34 <tdammers> and second, you will also be wiping your ~/.cabal/config
05:10:19 <tdammers> (and "you will have to rebuild everything" includes programs you installed with cabal, such as say hoogle, hasktags, etc.)
05:10:58 <hpyCdr> alright, thanks
05:44:00 * hackage list-singleton 1.0.0.2 - Easily and clearly create lists with only one element in them.  https://hackage.haskell.org/package/list-singleton-1.0.0.2 (fozworth)
06:02:00 * hackage reanimate-svg 0.9.1.0 - SVG file loader and serializer  https://hackage.haskell.org/package/reanimate-svg-0.9.1.0 (DavidHimmelstrup)
06:07:22 <sm[m]> hpyCdr: I usually dig into them with ncdu and remove just the big folders
06:08:02 <sm[m]> it would be great if someone added this feature to them
06:08:46 * sm[m] wonders if nix and brew have that feature
06:08:55 <merijn> What feature?
06:09:05 <sm[m]> freeing up disk space
06:09:29 <merijn> sm[m]: I missed the context, I assume we're talking about cabal-install's global store or something?
06:10:15 <sm[m]> yep.. I mean something like apt-get autoremove or brew cleanup for cabal and stack
06:10:54 <merijn> sm[m]: For v2-build there is something like that
06:11:33 <merijn> sm[m]: I totally forget what it was called, but you gave it a number of "active" cabal.project directories and then anything in the global store that wasn't a dependency of those roots would get nuked
06:12:30 <sm[m]> cool.. I'm not finding it in --help
06:12:52 <merijn> sm[m]: It's not part of cabal-install, it's a separate program
06:13:12 <merijn> sm[m]: But I can't recall the name. Which is annoying because I need it too :p
06:13:14 <sm[m]> ah. It should have an easy UI, it's something every new user needs
06:13:42 <merijn> sm[m]: The reason it's separate is because it's rather experimental trying to figure out the right UI
06:13:44 <maerwald> merijn: what, find it quickly?!
06:14:04 <merijn> hvr: You're needed, because I'm pretty sure you showed me this thing :p
06:15:59 <merijn> sm[m]: See also https://github.com/haskell/cabal/issues/3333
06:16:16 <maerwald> https://github.com/lspitzner/pkgdbgc ?
06:16:32 <maerwald> this one looks abandoned
06:16:59 <merijn> sm[m]: I agree that an easy UI is needed, but as long as it's experimental and may break things it's probably best not to expose it in the main UI (since people will then think it's safe to use and not now how to unbreak if anything goes wrong)
06:17:59 <sm[m]> oh, certainly agreed
06:18:13 <exarkun> sm[m]: nix doesn't know if you still want your random .stack-work directory or not
06:18:55 <sm[m]> exarkun: I meant can it clean its own stored stuff. I'm sure it can
06:19:05 <exarkun> sm[m]: yes it can do that.
06:21:28 <sm[m]> it seems like https://github.com/commercialhaskell/stack/issues/133 kind of gave up
06:22:16 <sm[m]> slackers.
06:23:58 <merijn> I think this isn't really high on anyone's priority list, though. Since with GHC's new increased release schedule it might be simpler to just nuke the store of each GHC as you update since disk is cheap anyway
06:24:14 <sm[m]> I think that
06:24:52 <sm[m]> I think that's what we all have been doing.. and disk isn't cheap in my experience (a typical macbook)
06:25:28 <sm[m]> but you're right, it's easy enough for an expert to do, so hard to motivate
06:25:55 <sm[m]> or even a non-expert who doesn't mind nuking config (rm -rf .stack .cabal .ghc)
06:27:22 <merijn> sm[m]: I mean, getting any amount of significant space in your store requires some pretty large amount of haskell (either lots of hackage updates or building huge projects)
06:28:34 <merijn> sm[m]: I think everyone agrees it's needed, just that there's more important issues for the cabal-install maintainers to address first (I, for one, wouldn't mind not having a "gc" for the next 5 years if it means show-build-info gets finished and useful so we can fix the IDE tooling situation...)
06:28:58 <merijn> So unless someone is sufficiently annoyed to implement something and make a PR, it's going to be "future work" :)
06:29:50 <fendor> merijn, show-build-info has been merged into Cabal at least
06:30:13 <sclv> i think we tried to do gc for gsoc this summer and the student got sick
06:30:18 <merijn> fendor: \o/
06:30:45 <sm[m]> perhaps we're thinking of different usage patterns. If you're interested in haskell like me you probably try building lots of cool projects. If so, soon you'll have multiple GHC versions cached (1G each) and multiple large collections of built libs (one per stackage lts, and all the same libs built again by cabal, and your mac will be constantly nagging you about a full disk
06:30:54 <fendor> merijn, the pr for cabal-install is missing though, due to a test failure (withRepo) and how to actually invoke the command
06:31:10 <merijn> sm[m]: "multiple GHC versions" sounds more like a stack thing than cabal-install, so I can't say
06:31:37 <merijn> sm[m]: Since cabal-install only produces lots of libraries which are comparatively small
06:32:05 <sclv> well with cabal, supposing you’re a library author, you still may want to test against multiple ghcs
06:32:20 <merijn> sclv: Sure, but at that point you need that much disk space anyway
06:32:30 <merijn> sclv: It's not garbage, because you're using it
06:36:42 <merijn> sm[m]: If you mac nags you about lack of diskspace it seems unlikely that it's haskell taking up all that disk. I've got 3 different GHC versions building a project with something like 218 (transitive) dependencies on my university cluster where I only get something like 20 GB of disk space in home...
06:37:44 <merijn> sm[m]: Or you must be hitting some superweird edge cases...
06:40:02 <sm[m]> It’s not, of course. I’m just giving some counter-data to the “disk is cheap” belief, which I think is not the experience of many laptop users
06:40:41 <merijn> sm[m]: It depends on the amount of disk, sure, but ~5GB is nothing, even on many laptops
06:41:00 <maerwald> the things that are most disk-space hungry are docker, nix and haskell, ime
06:42:07 <sm[m]> When you run around ~10G free, 5G looks more expensive. And as you say, I’m talking about stack + cabal + ghc, now not just cabal
06:43:43 <merijn> sm[m]: Maybe, OTOH, just clang already takes up like 4 GB (20 GB if you build it yourself) so GHC is comparatively small still
06:43:44 <sm[m]> all disk hungry tools should implement a cleanup command, and ours seem to be the only ones that don’t, which isn’t a great UX
06:45:26 <tdammers> when you're working on ghc and have multiple trees checked out and built, things can eat up quite a bit of disk space on that front
06:46:00 <tdammers> stack and cabal can both accumulate horrible amounts of what is essentially stale build caches too, if you keep using them on enough projects long enough
06:46:10 <tdammers> (and through enough GHC versions)
06:46:54 <tdammers> e.g., one thing that happens routinely is you build a bunch of projects, upgrade your ghc, build your projects again; now you have two copies of every (transitive) dependency in any of your projects in cabal's cache
06:47:21 <tdammers> changing version bounds will add more cache entries
06:48:27 <tdammers> and none of those ever get "garbage collected", because technically they never go stale - it's always possible that you might want those specific versions again at some point in the future, cabal doesn't know that you have decided to not use your old ghc versions anymore
07:00:05 <maerwald> cleaning up an entire ghc version is pretty easy though
07:20:11 <merijn> I forgot how magic laziness and tying the knot was...
08:22:30 <sshine> wow. I had this problem I was going to ask here. but it grew out of a single line, so I wrote a StackOverflow question. but out of respect for those who provide answers, I started researching a little into "does my idea for a solution even make sense?" and eventually found a module that, basically, does *exactly* what I wanted.
08:22:41 <sshine> that module was: https://hackage.haskell.org/package/aeson-diff-generic
08:23:15 <sshine> I would have been content with just aeson-diff, but this module takes it all the way.
08:24:31 <gentauro> sshine: did you write the module?
08:26:39 <Rich[m]> hi, can the following be solved without specifying a concrete type or using the ScopedTypeVariables language extension? https://paste.debian.net/hidden/fe11f343/
08:27:13 <Rich[m]> this has been bugging me for a while, but I always just work around it or use the ScopedTypeVariables language extension, but it also must be possible without.
08:27:16 <Rich[m]> (I assume)
08:29:51 <ClaudiusMaximus> without any annotation the type of r is ambiguous, possibly defaulting to Double
08:31:11 <merijn> Rich[m]: It doesn't work because without scoped type variables, type variables aren't, well, scoped
08:31:12 <int-e> Rich[m]: in this particular case you can get away with giving a type signature to the use of r. But this could well serve as a motivating example for the ScopedTypeVariables extension.
08:31:20 <ClaudiusMaximus> i would probably write   round (r * 100 :: Float)
08:31:27 <merijn> Rich[m]: So the 'g' in your where block is a *different* 'g' from the one in the top level
08:32:24 <merijn> Rich[m]: Type signatures in where/let/expressions etc have no way to refer to type signatures at the top level, which is why it's complaining
08:32:45 <int-e> Rich[m]: or possibly PatternSignature which would allow you to write  (r :: Float, g) = random gen
08:34:23 <Rich[m]> merijn: ah, thanks for clarifying. makes sense.
08:49:23 <sshine> gentauro, no, I didn't write the module.
08:49:33 <sshine> gentauro, I'm writing something that would greatly benefit from me using that module.
09:02:37 <lleksah> i'm reading haskell from first principles and it states that a function with type a -> a can only have the definition that is the same as 'id' (excluding impure functions), as an intellectual exercise is there a proof of this I could read?
09:07:36 <EvanR> intellectual exercise, prove it yourself!
09:08:15 <monochrom> The only known proofs are very advanced.
09:09:49 <monochrom> But a gist for beginners is that you go through all Haskell features and you find no combination that allows you to ask "what is the type of the parameter I'm receiving? I ask because I want to be naughty and say, if x is an int then 5 else x"
09:10:45 <geekosaur> that, and there's no way to say "give me some value of this type"; you need to know that type to know what, if any, values it has
09:11:23 <geekosaur> (there are ways to do so for specific types and specific subsets of types, but not for any type at all)
09:11:37 <geekosaur> ignoring undefined, which isn't a value as such
09:13:37 <maerwald> what about 'error'?
09:14:36 <maerwald> :t const (error "foo")
09:14:37 <lambdabot> b -> a
09:17:23 <jzyamateur> had a question: why is Prelude.length returning Int instead of Integer ? Is list length bounded?
09:19:20 <geekosaur> best anyone can figure is speed, since Int is a machine word vs. Integer which is usually via gmp
09:20:05 <geekosaur> in a certain sense, the practical size of a list is bounded by memory, but lazy lists complicate this
09:20:28 <jzyamateur> Got it
09:22:26 <ClaudiusMaximus> if Int is 32bit, length can overflow on really long lists that are GC'd as length traverses them
09:22:38 <ClaudiusMaximus> 64bit Int should be big enough
09:23:00 <geekosaur> famous last words :p
09:23:14 <lleksah> could one say that assume there is an f :: a -> such that f is not 'id' which implies that there is at least one x such that x != f x, then working within a system which has only one available type, T, which only has a single instantiable value a, then f (a :: T) != a so either T has two instantiable values or the type of f is not a -> a
09:27:05 <monochrom> No. You have a logic error.
09:28:14 <EvanR> when do you have only 1 available type
09:28:21 <EvanR> er, why
09:38:29 <lleksah> my reasoning was that if you wanted an f :: a -> a that does something other than id then every type must have a common operation (like f :: Num a => a -> a could use within it any operation defined on Nums, to say that there isn't such an operation i went with a single type which really has no operations available to it at all. i couldve worked it in a similar fashion by saying assume every type does have a common operation then you could introduce a new 
09:38:29 <lleksah> type with an operation that has nothing in common with those of other types
09:38:52 <geekosaur> lleksah, I gave you the core of the answer a couple minutes ago. I'd say you're trying to do it backwards here
09:41:02 <dmwit> ?free id :: a -> a
09:41:02 <lambdabot> f . id = id . f
09:41:58 <EvanR> not sure what role the universe of types with a common operation, that we will be ignoring, plays
09:42:30 <EvanR> we are left with a universe of types with no common operation
09:42:52 <EvanR> i.e. we walked out of the java room
09:54:18 <lleksah> i guess its role is to exist by virtue of our f doing something other than giving back its argument but intuitively we know that all types in haskell dont have any operation in common so f couldnt be anything other than id
09:55:52 <lleksah> i dont expect my reasoning to be rigorous but its fun to think about :)
09:57:11 <geekosaur> what I would say is: every value in Haskell has a specific type, therefore there is no value that inhabits more than one type. therefore there is no value that inhabits all types, and the only way you can get a value of an unspecified type is to be given one. therefore the only thing (a -> a) can do is produce the value it has been given, which is
09:57:12 <geekosaur> the definition of id :: a -> a
09:58:27 <lleksah> thats a great take geekosaur
09:58:38 <geekosaur> this is complicated slightly by typeclasses, because you can have a value of type (Num a => a) — but the only thing you can do with this is apply methods from the Num typeclass to it, you still can't produce one and it still doesn't tell you anything about an unspecified type a with no constraint
09:59:21 <int-e> :t fromInteger 1
09:59:22 <lambdabot> Num a => a
09:59:35 <EvanR> hmm. so from a polymorphic functions perspective, i am dealing with "unspecified type" heh
09:59:59 <EvanR> rather than, waiting to be told the type to specialize to
10:00:08 <geekosaur> `(Num a => a)` will generally have its type specified more completely when it's actually used. If all else fails, defaulting will be applied when possible, otherwise ghc will complain that it doesn't know what type the value is.
10:00:12 <monochrom> More specifically, parametric polymorphism.
10:00:33 <monochrom> It is the "parametric" part that says you aren't told and you can't ask.
10:00:58 <geekosaur> defaulting is generally used to make numbers easier to work with, because nobody wants to have to write (0 :: Integer) all the time
10:01:04 <EvanR> from this perspective it seems astonishing you can do anything
10:01:24 <monochrom> Compare with various ad-hoc and subtype/subclass polymorphisms which allow you various degrees of being told, can ask, or some other dependence.
10:01:51 <EvanR> like working on a software project, and there are no requirements yet
10:02:09 <geekosaur> f = id, done :p
10:02:33 <jzyamateur> What is inferred type of numbers in "(/) 6 2" ? It does not seem to be Int otherwise it would fail.
10:02:48 <geekosaur> that's the stuff about defaulting I was just talking about
10:02:54 <EvanR> 6/2 is an integer...
10:03:06 <monochrom> @type (/) 6 2
10:03:08 <lambdabot> Fractional a => a
10:03:40 <geekosaur> the "default default" is (Integer, Double), meaning that if ghc can't figure a type it will try to solve it with Integer and then with Double. here, Integer will fail but Double will succeed so it will infer Double as the final type
10:04:10 <EvanR> though monochrom just proved it doesn't infer Double
10:04:27 <geekosaur> until it needs to do that, it will work with the Fractional constraint, but at some point it needs to knw what actual operation to do and therefore fix a concrete type instead of just the constrained one
10:04:46 <EvanR> defaulting must happen at some later date
10:04:53 <geekosaur> so ti knows which instance of Fractional to use to do (/). it does not have wired in some knowledge of what division is
10:05:29 <sm[m]> I've got "type TextParser m a = ParsecT CustomErr Text m a". I wanted to put some constraints on m, so I tried "type TextParser m a = MonadFail m => ParsecT CustomErr Text m a". GHC then suggested RankNTypes or Rank2Types. Enabling those broke other type signatures. Is what I'm trying to do reasonable ?
10:05:51 <geekosaur> "@type" just shows you typechecker output. eventually it must generate runnable code, and at that point it needs to know an actual type / what instance's methods to call
10:06:26 <monochrom> @type print ((/) 6 2)
10:06:28 <lambdabot> IO ()
10:06:44 <EvanR> o_O
10:07:16 <geekosaur> sm[m], not really. you would nomally put the constraint on uses, not on the type itself.
10:07:26 <monochrom> This one doesn't fail because defaulting happens. Without defaulting it would be an error message in scary speak that merely means "I don't know which instance of Fractional you prefer".
10:07:28 <geekosaur> and in this case I feel like you;re trying to do the wrong thing
10:07:35 <sm[m]> geekosaur: thanks. I was hoping to avoid that
10:07:45 <EvanR> and Show
10:08:07 <EvanR> that example just threw me for a loop
10:08:17 <sm[m]> very probably. I'm exploring options for fixing my use of fail, which has become hard to support compatibly as of base-compat-0.11
10:09:00 <jzyamateur> How do I make "(/) 6 (length [1,2])" work?
10:09:44 <sm[m]> (/) 6 (fromIntegral $ length [1,2])
10:09:47 <monochrom> If you have not been doing "type TextParser m a = Monad m => ParsecT CustomErr Text m a" then I don't see why you suddenly need MonadFail and have never needed Monad in the first place.
10:10:52 <monochrom> @quote monochrom fromIntegral
10:10:52 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
10:11:06 <monochrom> Actually realToFrac works too.
10:11:30 <EvanR> encodeFloat!
10:11:32 * geekosaur guesses (Mega?)Parsec has not been updated for MonadFail; it should have an instance
10:11:38 <monochrom> Function fight: Which one is better, fromIntegral or realToFrac?
10:11:59 <geekosaur> the right fix here might be to stick to the older ghc until the ecosystem catches up; 8.8 hasn't been out for that long
10:12:03 <sm[m]> monochrom: I can't write that Monad m => constraint, so I never did that. I do call fail in some places, which I guess has implied m was a Monad.
10:12:39 <monochrom> Supposedly you have also been using do-notation heavily and should have required Monad.
10:13:17 <sm[m]> geekosaur: that sounds wise. It has popped up as an issue in stackage nightly, so I'm trying to stay ahead of it. I'm not sure that there's anything coming that will make this easier, other than me clarifying my code/ideas
10:14:23 <geekosaur> I think once they add the missing instance things will just work. right now, since there isn't a MonadFail instance for ParsecT, it's telling you it needs a MonadFail constraint and it's only after you add it somewhow that it will bother to point out there isn't one
10:14:32 <EvanR> encodeFloat (S# myInt) 0 :)
10:14:40 <maerwald> all the number conversions in haskell are confusing. I always have to look them up
10:15:21 <EvanR> length returns Int but encodeFloat takes Integer `:|
10:15:28 <sm[m]> oh, that's interesting. MonadFail instance for ParsecT.
10:15:52 <merijn> geekosaur: I saw Mark Karpov saying on twitter he's taking a week of work in october to work on megaparsec, so maybe it'll happen then
10:16:11 <sm[m]>  monochrom yes I'm using do notation, and fail, but never specified Monad explicitly; things just worked. Should I have added Monad m => to all those type sigs ?
10:16:18 <merijn> sm[m]: Lots of crucial infrastructure needs parsec, so of course it supports MonadFail already
10:16:38 <geekosaur> interesting. thought megaparsec was trying to be the new parsec
10:16:43 <geekosaur> so much for that
10:16:50 <merijn> geekosaur: How so?
10:16:52 <sm[m]> True. And I guess I have been using it.
10:17:00 <dmwit> For Int -> Double specifically, I'm willing to bet fromIntegral and realToFrac compile to the exact same code.
10:17:02 <merijn> geekosaur: megaparsec is much nicer and advanced for many things
10:17:36 <monochrom> Fork it and add it >:)
10:17:37 <merijn> geekosaur: but lots of ancient stuff uses parsec and no one has the time to update them all and/or doesn't want to increase the dependency footprint
10:17:39 <geekosaur> right, that was my impression. but it should have had MonadFail already since 8.6 supported it (not used by default, granted)
10:17:40 <jzyamateur> I understand that realToFrac will work . But fromIntegral signature returns a Num, and technically Num does not have "(/)", Still it works?
10:17:57 <dmwit> Num does not have (/). But some Num instances have (/).
10:18:05 <dmwit> Specifically, Double is a Num instance, and Double has (/).
10:18:24 <dmwit> Since you, the caller of fromIntegral, get to choose which Num instance fromIntegral returns, you may choose Double.
10:18:24 <sm[m]> yeah, megaparsec does have MonadFail: https://hackage.haskell.org/package/megaparsec-7.0.5/docs/Text-Megaparsec.html#t:ParsecT
10:18:28 <o1lo01ol1o> I'm looking for a package for dealing with (okasaki?) queues, I'm primarily interested in being able to cons from the head and "evict" the last element.  Can anyone recommend a package?
10:18:45 <monochrom> jzyamateur, we're using fromIntegral for very specifically Int->Double.
10:18:49 <jzyamateur> then fromIntegral converts it to Double ? How would one now
10:18:56 <jzyamateur> *know?
10:19:06 <monochrom> Type inference in human head?
10:19:11 <dmwit> jzyamateur: You might like "Why can a Num act like a Fractional?". https://stackoverflow.com/q/42820603/791604
10:19:13 <geekosaur> jzyamateur, Fractional requires Num, so if there's a constraint Num a => a and a constraint Fractional a => a, the latter will "win" and it'll pick a consistent type
10:19:40 <geekosaur> it's a more constrained, but compatibly constrained, type
10:19:45 <jzyamateur> Will have read up on this stuff.
10:19:52 <jzyamateur> Thanks
10:20:05 <monochrom> This is one of those times you have to be really savvy in logic.
10:20:56 <EvanR> when the computer is better at logic than you, and doesn't show it's work, how do you know it's working
10:21:31 <EvanR> time to turn the nuclear keys over to AI
10:21:59 <monochrom> Good riddance.
10:22:07 <geekosaur> "I need a type (a) with (Num a => a) and (Fractional a => a). (Fractional a) requires (Num a) already, so that part is redundant and I can proceed with just the (Fractional a)"
10:22:13 <erisco> If its behaviour "isn't even wrong" then what's the problem?
10:22:24 <geekosaur> so it picks a reasonable instance of Fractional via defaulting, which gives it Double
10:22:35 <dmwit> I have a very simple AI which determines whether it is best for humanity to fire the nuclear weapons or not to which I would be happy to hand the keys.
10:22:52 <EvanR> lol
10:22:55 <dmwit> > const "It is not best for humanity to fire the nuclear weapons."
10:22:57 <lambdabot>  error:
10:22:58 <lambdabot>      • No instance for (Typeable b0)
10:22:58 <lambdabot>          arising from a use of ‘show_M533261165456660142817730’
10:23:14 <geekosaur> heheh
10:23:56 <EvanR> let me back track and suggest that "showing it's work" be a thing
10:23:59 <EvanR> its*
10:24:18 <EvanR> i find a lot of automated features in haskell and idris inexplicable
10:24:36 <monochrom> Yeah well GHC hasn't been designed or optimized to show its type inference steps. Patches welcome.
10:25:22 <sm[m]> FWIW my original problem was not that fail is missing, it's that now there are multiple places to import it from (Control.Monad for a while longer, and Control.Monad.Fail in future, not to mention both Prelude.Compat and Control.Monad.Compat in base-compat-0.11.0), and I need to disambiguate the import in a way that works across GHC/package versions. And the solution suggested in base-compat's changelog just leaves me
10:25:23 <sm[m]> confused. :)
10:25:32 <monochrom> Most people's priority is "how to make it faster and accept more dependent types" not "how to slow it down by explaining more".
10:26:15 <geekosaur> anyone still maintaining helium?
10:26:21 <monochrom> or "how to slow down my progress of my dependent type thesis by coding up more explanations in GHC".
10:26:29 <geekosaur> (granting I feel like I',m, suggesting WATFIV >.> )
10:27:20 <davean> geekosaur: there was a talk on helium at HIW
10:27:24 <merijn> sm[m]: What do you not understand of the base-compat changelog?
10:28:18 <geekosaur> sm[m], that changelog is about writing *your own* MonadFail instances
10:28:23 <sm[m]> I think it's aimed people implementing fail, whereas I just want to import it. This seemed simple at first but is leading me down a rabbit hole.
10:28:26 <geekosaur> you don't care about the confusing part
10:28:40 <merijn> sm[m]: If you want to import it, import Control.Monad.Fail.fail, done
10:28:48 <geekosaur> ^
10:28:54 <sm[m]> I need to support older GHC/base
10:29:01 <merijn> sm[m]: Unless you need to support GHC versions older 8.0
10:29:03 <geekosaur> ti goes back to 8.0.1. if you need older, I suggest you need help
10:29:11 <EvanR> monochrom: so basically moving in the direction of drag racer and not safety award winning 4 door sedan
10:29:15 <sm[m]> I can #ifdef all my imports, but I started to think if I should be using something other than fail anyway.
10:29:48 <sm[m]> ok, so dropping support for GHC < 8.0 could be an option, that might work
10:29:55 <geekosaur> because 7.x is beyond ancient. but if you really need to support it, there's likely to be a way involving cabal flags and a custom module
10:29:56 <merijn> sm[m]: The entire reason Control.Monad.Fail has been shipping in base for a long time now is so that when the switch finally happens people won't need to support versions of base that predate the availability of 8.0
10:30:08 <geekosaur> I think at that point I go ask *why* someone wants ghc7 though
10:30:10 <merijn> geekosaur: Not even that, just CPP is sufficient
10:30:40 <hvr> it's no big deal often to support GHC 7.x
10:31:15 <hvr> unless you're using Stack
10:31:36 <geekosaur> they did mention stackage mightly
10:31:39 <geekosaur> nightly
10:32:49 <sm[m]> let me ask this: fail is often described as a misfeature of Monad. Is it still a reasonable thing to be writing a principled way, or should I be using something more explicit like say mzero or throwError ?
10:32:50 <merijn> sm[m]: The official policy for GHC should be that any backwards incompatible changes have at least 3 releases lead time, so people can support the last 3 GHC versions without extra effort
10:32:52 <geekosaur> and yeh, for this one at least it ought to be trivial enough not to need the extra foofery
10:33:05 <geekosaur> sm[m], MonadFail is the fix for that misfeature
10:33:23 <merijn> sm[m]: The reason why fail is a misfeature is because that there isn't always a way to handle failure in a specific Monad
10:33:27 <merijn> sm[m]: Consider Identity
10:33:36 <merijn> sm[m]: What is "fail" for Identity going to do?
10:33:41 <geekosaur> the problem is not that fail is associated with Monad. it's that it's mandatory as part of the basic Monad interface
10:33:48 <geekosaur> thus, MonadFail
10:34:40 <merijn> sm[m]: fail in turn is used for binds with partial patterns. i.e. "do { Just x <- foo; bar x }" desugars too "foo >>= \foo -> case foo of Just x -> bar; Nothing -> fail "Error on line X" }"
10:34:54 <hvr> ...and some maintainers made their code compatible w/ GHC 8.8 by defining a MonadFail instance with `fail = error`  ;->
10:35:22 <merijn> sm[m]: What's changing is that a partial pattern like that will now infer "MonadFail m" instead of "Monad" which means it will work for *some* Monads, but not all
10:35:37 <merijn> sm[m]: i.e. a partial match in Identity will trigger a type error
10:35:48 <merijn> hvr: Really? Have you seen this happen?
10:36:19 <davean> merijn: I had back in 8.6 at least. A lot
10:36:52 <merijn> davean: And then you beat those maintainers with a stick until they changed their vile ways?
10:36:54 <hvr> merijn: https://github.com/haskell-suite/haskell-src-exts/commit/7fa5173ba097693febf15d90e95ad06bb2edce4a ;-)
10:37:11 <geekosaur> sigh
10:37:18 <sm[m]> great, this all makes sense. So I think I'm seeing my plan: it's fine to keep using fail, but start declaring MonadFail in lots of type sigs, and drop support for GHC 7
10:37:39 <davean> merijn: No, they were mostly already on my blacklist of 'I will not use packages where these people are the primary maintainer' 
10:38:54 * geekosaur suddenly wonders where xmonad is on this spectrum. although it may be "justified" there as application. but.
10:39:12 * geekosaur is out of the loop…
10:39:47 <sm[m]> thank you, folks
10:42:30 * hackage milena 0.5.4.0 - A Kafka client for Haskell.  https://hackage.haskell.org/package/milena-0.5.4.0 (adamflott)
10:58:40 <sm[m]> would it be nice if GHC detected that two imports are actually the same, and didn't complain about it ?
10:59:18 <sm[m]> such as Prelude.Compat (fail), Control.Monad.Fail.Compat (fail), and Control.Monad.Fail (fail)
10:59:46 <sm[m]> base-compat conflicts not only with base, but with itself..
11:00:49 <sm[m]> meaning, it's a delicate and error-prone dance to get the imports just right for a range of GHC versions & packages. Could GHC be a bit more helpful and less complainy here ?
11:00:55 <merijn> 10 years of haskell and I still need to open ghci to check which way filter works...
11:01:16 <cocreature> merijn: mapMaybe makes it more obvious :)
11:01:42 <sm[m]> cocreature: wow, not for me :)
11:01:44 <erisco> How crazy is it to make a whole program an optic, do you think?
11:02:12 <tdammers> what would that even mean?
11:02:14 <cocreature> sm[m]: the types force you to keep the elements that return Just
11:02:37 <cocreature> sm[m]: whereas for filter it would be reasonable to keep the elements for which the predicate returns True or the other way around
11:03:41 <sm[m]> I see. I thought merijn was talking about order of arguments or something. PHP style. And I was surprised. :)
11:04:02 <erisco> tdammers, an optic is a function on profunctors, right?
11:07:31 <EvanR> maybe it's a good afternoon to learn lens
11:08:37 <sm[m]> add Control.Monad.State.Strict (fail) to the list. Libs really really want to give me fail.
11:09:24 <merijn> sm[m]: That one shouldn't export fail
11:09:32 <infinisil> EvanR: I'd check out the new optics library https://hackage.haskell.org/package/optics
11:09:43 <merijn> oh bugger
11:10:01 <merijn> Why the hell does mtl re-export Control.Monad...
11:10:05 <dmwit> sm[m]: uh?
11:10:22 <dmwit> When I `import Data.List (intercalate); import GHC.OldList (intercalate)` I don't get an error.
11:10:22 <infinisil> optics seems to focus (hah) much more on good error messages
11:10:23 <nshepperd> sm[m]: ghc does do that, though
11:10:26 <infinisil> Which are definitely lacking in lens
11:10:26 <merijn> dmwit: It re-exports all of Control.Monad >.>
11:10:46 <dmwit> sm[m]: So I think GHC already does detect when two imports are actually the same.
11:13:15 <EvanR> optics, brand spanking new
11:13:21 <dmwit> sm[m]: It also works fine if I `module Test1 where class Foo a where foo :: a -> Int` and `module Test2 (module Test1) where import Test1` and then `import Test1 (foo); import Test2 (foo)`.
11:13:46 <dmwit> sm[m]: So... what is the exact error you're seeing? How sure are you that the two imports you think are causing it are causing it? How sure are you the two imports really are the same?
11:14:06 <sm[m]> dmwith: well I'm confused then. Some of these fails seem to be the same ones, eg the one exported in two places by base-compat-batteries (the first two I listed)
11:14:26 <merijn> sm[m]: Right "some" of them
11:14:29 <geekosaur> iirc you don't see the error at import time but when you try to use it and it says conflicting definitions
11:14:30 <sm[m]> but GHC isn't happy about importing them both
11:14:33 <merijn> sm[m]: So presumably not *all* of them
11:16:01 <dmwit> geekosaur: I know. I used them.
11:16:57 <geekosaur> but yes, if they ultimately come from the same place ghc knows it and won't show a conflict. otherwise all the Control.Monad.* modules would conflict with each other because they all reexport parts of Control.Monad
11:17:41 <dmwit> sm[m]: Well, it isn't obvious to me at all that the first two modules you listed are actually exporting the same fail.
11:17:46 <dmwit> This CPP is a bit complicated.
11:17:56 <geekosaur> note that it's also not enough to simply have the same definition; it has to be from the same place ultimately
11:18:02 <sm[m]> dmwit, geekosaur, here's an example error: https://termbin.com/iomo . Ah, I see these are different ?
11:18:39 <sm[m]> GHC.Base.fail vs Control.Monad.Fail.fail ?
11:18:53 <dmwit> Right, those are really different. So GHC is correct to complain.
11:20:41 <merijn> hmm, there's no String equivalent of Text's toTitle?
11:21:23 <nshepperd> bad life pro tip: instead of adding MonadFail to the context of your function, you can attach a ~ to make your partial pattern match lazy, which makes it call 'error' on failure instead of 'fail'
11:22:09 <sm[m]> whereas in this case, I'm hiding GHC.Base.fail, and importing Control.Monad.Fail.fail twice, which is fine, just a warning. https://termbin.com/6aum . Ok, making sense
11:23:07 <merijn> nshepperd: Time to submit here: https://twitter.com/EvilHaskellTips
11:23:15 <sm[m]> nshepperd: la la la can't hear you
11:23:30 * nshepperd has done that for cases where she didn't need proper error handling, or rather wanted to crash the program anyway
11:24:22 <dmwit> Somebody told me about that when I was complaining that `[a,b,c,d] <- mapM foo [e,f,g,h]` didn't work.
11:24:33 <dmwit> So it might have some legitimate uses, too. ;-)
11:25:19 <nshepperd> yep!
11:25:29 <merijn> dmwit: You are a bad person and you should feel bad ಠ_ಠ
11:25:43 <dmwit> Oh?
11:25:55 <dmwit> You want `data Four a = Four a a a a deriving Traversable`, or what?
11:26:07 <merijn> dmwit: Much better ;)
11:26:07 <dmwit> If so, then I am a lazy person and I feel lazy, but I don't feel bad.
11:27:19 <lavalike> merijn: not as simple as stealing the impl, since it's stream based :/ https://www.stackage.org/haddock/lts-14.4/text-1.2.3.1/src/Data-Text-Internal-Fusion-Common.html#toTitle
11:28:10 <merijn> lavalike: It's trivial enough that there's little point in stealing it, I'm just lazy
11:28:51 <davean> merijn: The true solution is to move to Text for everything, its just better :)
11:28:54 <lavalike> just like Haskell! perfect match
11:30:08 <merijn> davean: I would, but optparse-applicative still uses ansi-wl-pprint, which still uses String, so until I can finally help quchen convince the switch to prettyprinter for it I'm stuck with String
11:30:50 <davean> merijn: aw :( Any idea how much work is needed for that switch? It seems very worth it.
11:31:07 <merijn> davean: The switch itself is easy, the problem is its position in the ecosystem
11:31:35 <merijn> davean: https://github.com/pcapriotti/optparse-applicative/issues/273
11:32:01 <merijn> Ironically the criterion ticket for prettyprinter is blocked on...optparse-applicative >.>
11:35:48 <Athas> prettyprinter does look good...
11:36:09 <Athas> Unfortunately, I depend on the language-c-quote micro-ecosystem, which uses mainland-pretty.
11:36:24 <Athas> I never quite figured out why Geoffrey Mainland felt the need to create that one.
11:36:25 <merijn> Athas: The entire point of it was to be basically wl-pprint, but without the conflicting operators and more modular so we didn't need 10 different versions
11:36:44 <merijn> Athas: Write an adapter to prettyprinter ;)
11:37:12 <Athas> merijn: I think my life is about ten billion years too short to spend it on writing pretty printer adapters.
11:38:10 <merijn> That's why were stuck with 20 different ones >.>
11:38:51 <Athas> Looks like mainland-pretty's unique selling point is the ability to automatically inject #line pragmas.
11:39:02 <EvanR> not sure i would want my name forever attached to pretty printer tech
11:39:14 <merijn> EvanR: If it's good pretty printer tech!
11:39:35 <EvanR> pythagorean theorem, k thats cool. EvanR's yet another template language!
11:39:43 <merijn> hmm
11:40:16 <EvanR> for one thing, all pretty printers are geared toward ascii grid 
11:40:26 <nshepperd> the fundamental pretty printer of calculus
11:40:26 <EvanR> the pain...
11:41:03 <Athas> The restriction to an ASCII grid is power, not weakness.  The Emacs Truth.
11:41:25 <MarcelineVQ> "now presenting the latest in pretty printing tech libraries, Evanesence"
11:41:33 <EvanR> NO
11:42:46 * EvanR boots up the graven altar to the software gods, and wishes for technology to take hand written (well formed) syntax and make it compute
11:43:02 <EvanR> basically the opposite of pretty printing
11:43:15 <merijn> EvanR: So...parsing? :p
11:43:16 <EvanR> pretty parsing
11:43:38 <EvanR> and make it reversible, then you solved the pretty printer with 1 stone
11:45:14 <infinisil> I think that's called invertible grammar or so
11:46:02 <infinisil> https://hackage.haskell.org/package/invertible-syntax
11:46:18 <infinisil> https://hackage.haskell.org/package/invertible-grammar
11:46:32 <infinisil> https://hackage.haskell.org/package/boomerang
11:46:35 <infinisil> And probably more
11:46:40 <EvanR> by hand written i mean, written by hand, on paper
11:46:59 <EvanR> with proper formatting
11:47:46 <MarcelineVQ> "my latest prety printer parser OCRnavE"
11:49:23 <EvanR> in the book "The Little Typer" the sections that show code to be run by a computer are in ascii grid format, where as the rest is nicely type set. Clearly theoretical computer science has committed itself to having all code be on an ascii grid for eternity
11:50:24 <MarcelineVQ> preferring grid (monospaced) is the same reason to prefer spaces over tabs
11:51:13 <merijn> MarcelineVQ: Sane and morally righteous?
11:52:05 <MarcelineVQ> deus vult
11:52:07 <EvanR> alignment between lines is one thing, but your grid stops you from using subscript
11:52:16 <merijn> MarcelineVQ: Indeed
11:52:41 <EvanR> and good luck with italic
11:52:57 <MarcelineVQ> Why does it stop subscript?
11:53:18 <EvanR> subscript is in a smaller font for one thing
11:53:18 <geekosaur> didn't Knuth have something to say about this (in some sense)?
11:53:37 <EvanR> it's on a smaller grid, if you will
11:53:46 <geekosaur> hm, and the Algol 68 language committee
11:53:48 <EvanR> not to mention placing the subscript underneath something
11:54:10 <MarcelineVQ> hmm. Your grid dilineations might be different than mine. a³ takes up the same bounding box space as ab on my editor screen
11:54:18 <EvanR> 3 is only 1 character
11:55:26 <EvanR> yeah i'd be interested in hearing the justification, however ancient
11:57:13 <geekosaur> justification for which? fixed cells is punch cards; probably blame IBM
11:57:24 <EvanR> does anyone read music, imagine if music notation was entirely designed to fit in a grid. Perhaps allowing multiple symbols "stamped" in a single cell. I'm thinking it would not work 
11:57:35 <merijn> EvanR: Hah
11:57:40 <merijn> EvanR: Have you not seen tabs?
11:57:56 <EvanR> isn't that just for guitar chords
11:58:03 <geekosaur> and percussion
11:58:06 <merijn> Most modern guitar players don't bother with traditional music notation because it's a PITA for guitar
11:58:12 <merijn> EvanR: No, also for melody
11:58:22 <EvanR> alright
11:58:44 <merijn> EvanR: In fact, tabs aren't great for chords, so while the notation is used for chord diagrams, it's not used for writing out chords within a song
11:59:19 <merijn> As a kid I learned music notation for guitar, but it's super ambiguous so when I restarted with guitar I just stuck to tabs
11:59:40 <sm[m]> justification ? a character grid was just a simplifying constraint, that reduced complexity & cost and unlocked a lot of creativity
12:01:00 * hackage vega-view 0.2.0.0 -   https://hackage.haskell.org/package/vega-view-0.2.0.0 (DouglasBurke)
12:01:33 <EvanR> would then not a grid that may only display perfect squares of only 2 colors, no characters be even simpler and unlock even more?
12:01:48 <sm[m]> ooh, sweet
12:03:14 <sm[m]> EvanR: maybe in some cases. Cellular automata, eg
12:03:46 <EvanR> yes... reading wolfram "a new kind of science" right now
12:05:17 <sm[m]> ha!
12:06:24 <sm[m]> Every task involves constraint,
12:06:25 <sm[m]> Solve the thing without complaint;
12:06:52 <sm[m]> There are magic links and chains
12:06:53 <sm[m]> Forged to loose our rigid brains.
12:07:05 <sm[m]> Structures, strictures, though they bind,
12:07:05 <sm[m]> Strangely liberate the mind.
12:10:54 <MarcelineVQ> or in one line, Art from adversity.
12:15:25 <literall1Crevice> Hey, I was wondering how I can simplify this piece of code (perhaps using the Maybe Ord instance, however it isn't exactly what I need) http://ix.io/1UC8
12:17:21 <turab> :t maybe
12:17:23 <lambdabot> b -> (a -> b) -> Maybe a -> b
12:17:35 <turab> Perhaps: maybe True (> y)
12:20:49 <nil> well, in the Ord instance, Nothing is the minimum, not maximum
12:21:39 <literall1Crevice> Exactly
12:21:50 <EvanR> newtype
12:22:19 <literall1Crevice> turab: That solution sounds good but I just realized I asked the wrong question. What transformations can I apply to X and Y in order to make f x > f y behave as I need it?
12:22:35 <nil> i think the best you can do is  nothingIsMaxGT = maybe (const True) (>)
12:22:59 <nil> :t (>)
12:23:01 <lambdabot> Ord a => a -> a -> Bool
12:23:15 <nil> literall1Crevice: you can't match `a` with `Maybe a`
12:23:33 <literall1Crevice> well, f x > g y
12:23:50 <literall1Crevice> But I just realized that would take making f turn Nothing to a max value
12:24:04 <literall1Crevice> so I'll look into that however not sure it would work
12:24:11 <nil> are you tied to Maybe?
12:24:31 <nil> you could define your own data type and make its Ord instance behave as you want
12:25:40 <EvanR> in the FRP paper he makes a type like this, a wrapper that adds a "point at infinity" greater than any element of the wrapped type
12:25:59 <literall1Crevice> I'll explain my problem with more context, that'll probably help. I'm making a system sort of like a market. Someone could say "I want to buy a thing" and it'll be added to the DB. Now, I want them to have the possibility of saying "I want to buy a thing, but don't contact me if it's after the 20th of April." in which case when searching the DB for matches after that date it won't show up. So I 
12:26:02 <EvanR> so its morally different from Maybe
12:26:05 <literall1Crevice> currently have listingExpiration :: Maybe UTCTime.
12:26:17 <EvanR> coincidentally he uses this for time
12:26:49 <geekosaur> literall1Crevice, maybe this is the wrong way to think abut it
12:27:02 <literall1Crevice> EvanR: Are you referring to this? http://conal.net/papers/push-pull-frp/
12:27:13 <geekosaur> events with expiration dates might be a use for priority queues
12:27:57 <EvanR> yes AddBounds
12:28:11 <EvanR> maybe only a future point in the previous paper
12:29:39 <nil> literall1Crevice: so then why do you have to use (>) ?
12:29:49 <nil> just use your own comparison function with the required logic
12:30:29 <literall1Crevice> nil: Because I'm tied to using (>.) from Database.Persist
12:30:34 <literall1Crevice> EvanR: I'll look into that, thanks
12:31:08 <literall1Crevice> geekosaur: Wouldn't that kill the DB's performance? Inserting sorted by time
12:31:52 <geekosaur> not if it's worth anything
12:35:26 <EvanR> inserting sorted by time, inserting and having an index on time... should be the same
12:36:25 <literall1Crevice> I don't plan on having an index for time
12:37:40 <EvanR> welp
12:37:55 <EvanR> got nothing
12:38:31 <literall1Crevice> I guess I'll go the dumb way and do an OR between expiry being a Nothing or Just x where x < currentTimie
12:39:14 <literall1Crevice> Thanks for all the attempts, sorry for being to stubborn
12:41:01 * hackage vega-view 0.2.0.1 -   https://hackage.haskell.org/package/vega-view-0.2.0.1 (DouglasBurke)
12:56:14 <ski> sm[m] : nice
12:58:06 <merijn> literall1Crevice: There's a wrapper for adding a max upper bound to an element type for ordering
12:58:30 <merijn> literall1Crevice: Inf from monoid-extras
12:58:36 <merijn> @hackage monoid-extras
12:58:36 <lambdabot> http://hackage.haskell.org/package/monoid-extras
13:00:18 <aviD> How does GC handle data containing unboxed tuples.
13:00:19 <aviD> data UT4 a = UT (# a, a, a, a, #)
13:00:19 <aviD> Is a forwarding pointer attached to the containing boxed data (E.g UT4)?
13:00:44 <merijn> aviD: Eh, it doesn't ahve to, because you can't store unboxed tuples in data structures? :)
13:01:02 <merijn> aviD: Does that datatype even compile?
13:01:48 <aviD> I got something like it to compile. I'll have to post the actual code when not on my phone
13:02:40 <merijn> aviD: Quoth the GHC user guide: "Unboxed tuples are used for functions that need to return multiple values, but they avoid the heap allocation normally associated with using fully-fledged tuples. When an unboxed tuple is returned, the components are put directly into registers or on the stack; the unboxed tuple itself does not have a composite representation."
13:02:55 <merijn> aviD: That strongly suggests that datatype cannot/should not compile
13:04:16 * ski . o O ( type synonyms )
13:05:45 <aviD> Yeah I had read that and the all the other stuff I could find on Unboxed tuples. Hence the question.
13:13:35 <jmcarthur> I would think that a constructor containing an unboxed tuple would just expand the tuple into multiple fields.
13:15:01 <jmcarthur> Kind of like the UNPACK pragma.
13:18:30 * hackage tensorflow 0.2.0.1 - TensorFlow bindings.  https://hackage.haskell.org/package/tensorflow-0.2.0.1 (gnezdo)
13:21:30 * hackage tensorflow-logging 0.2.0.1 - TensorBoard related functionality.  https://hackage.haskell.org/package/tensorflow-logging-0.2.0.1 (gnezdo)
13:22:31 * hackage tensorflow-ops 0.2.0.1, tensorflow-opgen 0.2.0.1 (gnezdo): https://qbin.io/bureau-folks-lvl2
13:24:24 <koz_> > sizeof (undefined :: Char)
13:24:27 <lambdabot>  error:
13:24:27 <lambdabot>      • Variable not in scope: sizeof :: Char -> t
13:24:27 <lambdabot>      • Perhaps you meant one of these:
13:24:31 <koz_> > sizeOf (undefined :: Char)
13:24:33 <lambdabot>  error:
13:24:33 <lambdabot>      • Variable not in scope: sizeOf :: Char -> t
13:24:34 <lambdabot>      • Perhaps you meant one of these:
13:28:48 <mniip> MarcelineVQ, what haooen
13:28:48 <mniip> happen
13:28:55 <mniip> merijn, it does compile
13:28:58 <mniip> at least sometimes
13:33:01 <koz_> What's the story with Char in Haskell? sizeOf (undefined :: Char) gives 4, but fromEnum (maxBound :: Char) gives something far smaller than what this would suggest.
13:33:14 <koz_> UTF-32 or something?
13:33:25 <merijn> koz_: Those two things are very different
13:33:49 <merijn> koz_: maxBound gives you the maximum value it can contain, which is completely unrelated to the size something takes to store in memory
13:34:31 <koz_> merijn: Yeah, you make a good point. Let me try and ask this question in a better way - how many valid values of type Char are there, excluding bottom?
13:34:47 <merijn> koz_: And the answer is: GHC (almost) never uses representation smaller than a machine word, because reading machine words tends to be faster than reading subword sizes of bytes
13:34:58 <MarcelineVQ> mniip: people were wondering about some weirdness related to the string you got after something like forkIO $ threadDelay 1000000 >> putStr "()" followed by putStrLn "something", which I can't currently reproduce, but you'd get "somethi(n)g"
13:35:03 <MarcelineVQ> er in yahb
13:35:31 <MarcelineVQ> The weirdness was that much more than 1000000 has passed between
13:35:38 <merijn> koz_: "fromEnum (maxBound :: Char)" is probably the right answer
13:35:40 <koz_> merijn: Yeah, I think only Word* is exempted from this as far as I can tell.
13:35:49 <koz_> merijn: +1 right, since first value is 0?
13:35:52 <merijn> koz_: (plus or minus one, because thinking is hard)
13:36:12 <mniip> well, the output goes to a file descriptor, so any and all weirdness is deferred to that of GHC
13:37:48 <mniip> > fromEnum 0x110000 :: Char
13:37:51 <lambdabot>  error:
13:37:51 <lambdabot>      • Couldn't match expected type ‘Char’ with actual type ‘Int’
13:37:51 <lambdabot>      • In the expression: fromEnum 0x110000 :: Char
13:37:58 <mniip> > toEnum 0x110000 :: Char
13:38:00 <lambdabot>  *Exception: Prelude.chr: bad argument: 1114112
13:38:26 <koz_> mniip: I see.
13:38:47 <mniip> Char is a type for unicode codepoints
13:38:56 <mniip> which there are 0x110000
13:45:26 <merijn> mniip: *now* ;)
13:46:12 <mniip> no I tested it
13:46:13 <koz_> merijn: I guess new codepoints being added is kind of a big deal that takes a lot of committee time?
13:46:30 <mniip> koz_, that's not how unicode works
13:46:55 <koz_> mniip: OK, so how does it work?
13:46:58 <mniip> it's not being extended at the end, it has characters allocated in reserved areas
13:47:06 <mniip> which there's plenty of
13:47:07 <MarcelineVQ> The commity meeting about poop emoji's was pretty great
13:47:54 <mniip> for a reasonably amount of time from now there are only going to be 1114112 valid unicode codepoints
13:48:00 <mniip> however some of them do not map to any character
13:48:12 <mniip> *that* is slowly being filled in
13:48:24 <koz_> mniip: Ah, I see.
13:48:28 <koz_> Thanks for the clarification.
13:48:39 <merijn> Due to a unicode related oversight in the Haskell report my favourite package should technically compile (although GHC has a bug where it deviates from the report so that it does compile)
13:49:51 <Rembane> Is it a bug that will be fixed, or more of a feature-bug?
13:50:19 <merijn> Rembane: I doubt anyone will "fix" it, since the real fix is to remedy the report's oversight (if we ever get a new report...)
13:51:18 <mniip> as of right now there are 64 unallocated characters in the basic multilingual plane
13:51:22 <mniip> that's actually pretty low...
13:51:43 <mniip> but we also have like 12 other planes that are completely unused
13:51:47 <Rembane> merijn: Sweet. Well, are there any chance of an errata? 
13:51:57 <merijn> I speak of course of
13:52:07 <merijn> @hackage acme-lookofdisapproval
13:52:07 <lambdabot> http://hackage.haskell.org/package/acme-lookofdisapproval
13:52:34 <koz_> merijn: Lawl.
13:52:50 <merijn> I don't suppose we have a name for "guard . not"?
13:53:13 <monochrom> I think "data U a = U (# a, a #)" is made equivalent to "data U a = U a a" after I have looked at generated Cmm code, including functions like "f (U (# x, _ #)) = x", "g x = U (# x, x #)".
13:53:40 * ski suspected that could be it
13:53:45 <koz_> merijn: sleepOnWatch ?
13:53:55 <merijn> koz_: hmm?
13:53:56 <Rembane> merijn: robinhood = guard . not 
13:54:03 <koz_> Rembane's suggestion is funnier.
13:54:14 <mniip> no, that's not . guard
13:54:18 <mniip> does not commute
13:55:49 <literall1Crevice> merijn: Interesting, thanks
13:56:56 <literall1Crevice> Another question, why does stack only complain for *some* packages when they don't exist in the cabal file? I have about 20 dependencies for my project, I just now added smtp-mail and am asked to add its hash to stack.yaml's extra-deps
13:58:26 <Rembane> literall1Crevice: Because it isn't on stackage but hopefully exists on hackage. 
13:59:24 <MarcelineVQ> simply that the pacakge you specified is not included in the resolver/snapshot your project uses, https://docs.haskellstack.org/en/stable/stack_yaml_vs_cabal_package_file/ https://docs.haskellstack.org/en/stable/yaml_configuration/#extra-deps
13:59:29 <literall1Crevice> Rembane: thanks!
14:00:28 <monochrom> And if you insist on "h (U t) = t" then it is what you normally expect of a function of type "Foo -> (# X, Y #)" meaning the "return value" occupies two registers (and so the caller expects two parameters in those two registers), e.g., "myfunc (h whatever)" evaluates to "myfunc x y".
14:00:29 <Rembane> literall1Crevice: No worries. Good luck! 
14:02:21 <monochrom> And if you have a large n-tuple and too few registers, then I presume it's like what the GHC user's guide says, you get n items pushed on the stack.
14:03:59 <monochrom> Hey, I think it's not too far from truth that you can model unboxed tuples exactly like SML tuples in practically all aspects. >:)
14:04:27 <monochrom> Like, if you were to write your own SML compiler, you would do the same!
14:05:07 <monochrom> "Newsflash: GHC reinvents 1980s ML compiler techniques" >:)
14:07:25 <monochrom> Anyway, I thought robinhood = not . adamWestBelly
14:08:31 * hackage lsp-test 0.7.0.0 - Functional test framework for LSP servers.  https://hackage.haskell.org/package/lsp-test-0.7.0.0 (luke_)
14:12:04 <hololeap> i'm investigating the source of randomness from randomIO and i can't figure out where it's defined. i cloned http://git.haskell.org/packages/random.git and randomIO's definition is commented out
14:13:07 <hololeap> http://git.haskell.org/packages/random.git/blob/HEAD:/src/System/Random.hs#l303
14:13:10 <monochrom> Look for StdGen and its RandomGen instance.
14:13:58 <monochrom> But it's a pretty simplistic PRNG that actually no one has really studied how good it is.
14:14:19 <monochrom> Even a pretty simple linear-congruential one.
14:15:45 <hololeap> is it just me or is that instance commented out as well?
14:15:57 <monochrom> I don't know, haven't looked
14:17:01 <monochrom> There is also the unsettling possibility that it's hardcoded in GHC, and the "random" package is just a facade. This happens to stm already.
14:17:16 <hololeap> maybe the repo's HEAD isn't supposed to be working code... because so much in that file is commented out
14:17:30 <hololeap> monochrom: interesting thought
14:21:12 <monochrom> Hey wait what, Haskell2010 has disowned System.Random?!
14:23:11 <monochrom> I think https://hackage.haskell.org/package/random-1.1/docs/src/System.Random.html is more enlightening. At least it removes my hypothetical worry :)
14:31:00 * hackage symbiote 0.0.0 - Data serialization, communication, and operation verification implementation  https://hackage.haskell.org/package/symbiote-0.0.0 (athanclark)
14:31:23 <hololeap> ok, it looks like it just seeds the PRNG with the system time
14:31:57 <hololeap> i was trying to understand why people were saying that it was no good for quality randomness, but i'm starting to see
14:34:41 <hexagoxel> maerwald: you are correct, https://github.com/lspitzner/pkgdbgc is abandoned. I started that with too low of a time budget and with slightly wrong preconceptions of what kind of package db I was dealing with.
14:35:39 <hexagoxel> Rewriting it to make it work would be an estimated 2-day job.
14:39:38 <monochrom> oohhh ghcup always put GHC under $HOME/.ghcup
14:44:13 <monochrom> Hrm actually it's a bit more complicated than that.
14:46:48 <monochrom> OK it uses the environment variable GHCUP_INSTALL_BASE_PREFIX.
14:48:44 <hexagoxel> @tell asheshambasta brittany-0.12+ will at least give you error locations for such cases.
14:48:45 <lambdabot> Consider it noted.
14:50:18 <monochrom> Magic! How does ghcup know that GHC 8.8 is best paired with cabal-install 3?
14:50:46 <Phyx-> why is that magic? It's just a dependency.. chocolatey does the same
14:53:59 <monochrom> Wait, Bourn shell supports nested function definitions?!
14:55:14 <lihram> I just watched a PluralSight tutorial on Haskell - are records still generally to be avoided? (The video is from 2013)
14:56:41 <Phyx-> git pull --rebase
14:59:34 <monochrom> No, ghcup always refers to gitlab.haskell.org/haskell/ghcup/raw/master/.available-versions (and defaults to "recommended")
15:03:06 <monochrom> (and there is an environment variable for overriding a prefix of that, too)
15:25:00 * hackage tensorflow-core-ops 0.2.0.1 - Haskell wrappers for Core Tensorflow Ops.  https://hackage.haskell.org/package/tensorflow-core-ops-0.2.0.1 (gnezdo)
15:26:01 <dmwit> lihram: Records are fine.
15:26:08 <dmwit> Always have been.
15:26:30 <dmwit> Could there be something better? Maybe. Nobody's really found something that has all the nice features of existing records and also some nice feature that records don't have.
15:27:01 <dmwit> There are definitely alternatives that are better in some ways and worse in others. It's complicated. Welcome to programming.
15:29:27 <monochrom> What dmwit says. Plus, I've never heard of PluralSights.
15:35:05 <EvanR> i like records from the book TAPL
15:42:54 <Phyx-> grrr stupid PR workflow
15:44:51 <sim590> I have some simple function which has the signature [Int] -> [Int]. It's defined by a do block which works fine, but then I want to put a print between two lines and I have the problem arising from the fact it's not the same monads (IO and list)... How can I solve that?
15:45:00 * hackage tensorflow-proto 0.2.0.1 - TensorFlow protocol buffers.  https://hackage.haskell.org/package/tensorflow-proto-0.2.0.1 (gnezdo)
15:45:22 <monochrom> Depends on why you need to print.
15:45:32 <sim590> I just want to print a value
15:45:59 <monochrom> Debugging messages (that hopefully will be removed in production code) belong to Debug.Trace
15:46:24 <monochrom> Real output that's really required by the specification belongs to IO.
15:47:03 <monochrom> Pure idle curiosity can be treated as debugging messages.
15:48:03 <dmwit> sim590: http://hackage.haskell.org/package/list-t-1.0.3.1/docs/ListT.html
15:50:30 * hackage svgcairo 0.13.2.0 - Binding to the libsvg-cairo library.  https://hackage.haskell.org/package/svgcairo-0.13.2.0 (HamishMackenzie)
15:52:58 <sim590> DwarfMaster: ghci said that Control.Monad.Trans.List is deprecated.
15:53:01 <sim590> oops
15:53:03 <sim590> dmwit: ^
15:53:54 <pikajude> is there a separate channel for HIE or should i just ask here
15:54:15 <sim590> pikajude: #haskell-ide-engine
15:58:31 * hackage vega-view 0.2.0.2 - Easily view Vega or Vega-Lite visualizations.  https://hackage.haskell.org/package/vega-view-0.2.0.2 (DouglasBurke)
16:00:58 <sim590> dmwit: I wasn't looking at the same page I though I was.
16:01:20 <cole-k> anyone have pointfree alternatives to curry? pointfree.io gives (. (,)) . (.), but i want more obfuscation
16:01:54 <cole-k> er, i have uncurry
16:02:08 <monochrom> You really want more obfuscation?  Use (<$>) to replace (.)
16:03:32 <cole-k> monochrom: just for fun :) , i was hoping for something more funky like ap, but couldn't come up with anything good
16:20:35 <infinisil> We need a Haskell obfuscator that does things like naming everythnig with random symbols with weird predecence, always uses pointfree style, and more
16:20:59 <infinisil> (not sure what more could be though)
16:21:21 <koz_> infinisil: Write everything using S, K and I.
16:22:35 <infinisil> Hehe, but that would also probably slow it down considerably
16:22:58 <nil> cole-k: translate to SK, then replace S with ap and K with const
16:23:03 <koz_> You never said it had to be an efficient-code-generating obfuscator.
16:24:18 <infinisil> Oh, an efficient different technique would be to write everything with TemplateHaskell lol
16:24:51 <infinisil> Like the full data constructors, not the quasiquote thing
16:25:34 <EvanR> an obfuscator without using quasiquote? why
16:26:04 <infinisil> Ah yes, how about mixing quasiquotes with non-quasiquotes
16:26:19 <nisstyre> infinisil: most obfuscators at the assembly level work by inserting jmp instructions all over the place
16:26:26 <nisstyre> so that you can't figure out wtf the control flow is doing
16:26:35 <nisstyre> so you'd do the same thing, maybe with continuations
16:26:55 <EvanR> also exceptions
16:27:13 <EvanR> async exceptions
16:27:15 <infinisil> Very nice
16:28:03 <EvanR> unsafePerformIO obv
16:28:08 <infinisil> Also how about using RebindableSyntax with weird functions
16:28:25 <koz_> So basically, your whole output is like 'runContT (wtf . bbQ . unsafePerformIO foo . ....);
16:28:27 <koz_> '
16:28:28 <infinisil> OverloadedLists too
16:28:43 <nil> cole-k: curry = ap (ap (const ap) (ap (const const) (ap (const ap) const))) (const (,))
16:29:02 <koz_> nil: It sounds like a Pokemon wrote code.
16:29:14 <nil> tested and approved
16:29:15 <infinisil> koz_: Except . will be renamed to <.%# with inverted associativity
16:29:21 <koz_> infinisil: Yes.
16:29:27 <infinisil> And opposite precedence
16:29:43 <koz_> infinisil: So it'll look like idiomatic lens code? :P
16:29:50 <infinisil> Lol
16:29:55 <koz_> (or perhaps idiomatic singletons code)
16:29:56 <infinisil> touche
16:30:49 <infinisil> Oh and also, we need compiler plugins that report weird warnings and make weird transformations
16:30:50 <monochrom> You can use throw-catch for CPS.
16:31:33 <EvanR> use both applicative do and monad do but implement the classes in different ways
16:31:49 <infinisil> Hmm very nice
16:31:56 <infinisil> We need all kinds of law violations
16:33:04 <infinisil> Oh, another idea, let's use a type family to replace all types
16:33:24 <infinisil> Like, instead of `[Bool]` we use `TheFamily '0`
16:33:44 <infinisil> Actually that might make it simpler lol
16:33:54 <infinisil> All types would be in one place
16:34:04 <koz_> infinisil: Weak. Family should be named T, and it should be indexed by a Peano-style natural.
16:34:06 <EvanR> what is the most obfuscated you can write a variable name
16:34:19 <koz_> So instead of [Bool], it's T S(S(S(S(S(S(S(S(S(S(Zero))..).
16:34:50 <koz_> Except 'S' and 'Zero' need to be named something more 'appropriate'.
16:35:00 <EvanR> and the naturl is computed with obfuscted type level code
16:35:28 <infinisil> Let's use type-level prime factorizations to encode numbers
16:36:20 <EvanR> then hit it all with CPP
16:36:32 <EvanR> this is like epic meal time
16:36:41 <koz_> EvanR: If we're using CPP, we might as well just make it look like Javascript.
16:36:49 <koz_> That's next-level obfuscation right there.
16:37:02 <EvanR> make sure it looks like obfuscated js
16:38:16 <koz_> EvanR: So what's the Haskell equivalent of bacon?
16:38:36 <EvanR> sodium? dunno
16:39:24 <Guest_64> I'm trying to install on OSX 10.14. I've updated xcode. I get this: See `config.log' for more detailsFailed to install, consider updating this script via: ghcup upgrade"ghcup --cache install" failed!
16:39:46 <Guest_64> How do I do ghcup upgrade?
16:40:21 <Guest_64> Also says: checking for gcc... gccchecking whether the C compiler works... no, but I can run gcc at the terminal.
16:40:22 <sim590> I don't understand how to use http://hackage.haskell.org/package/list-t-1.0.3.1/docs/ListT.html. I simply want to use the function "print" inside my function. I know about Debug.Trace, but I want to understand how to use "print" also. 
16:41:05 <sim590> That's what I'm trying to do: https://paste.debian.net/1099582/
16:42:42 <koz_> sim590: The type of themselvesTimes is [Int] -> [Int], which means _no side effects of any kind_.
16:42:51 <koz_> You would want a type of [Int] -> IO [Int].
16:43:08 <koz_> Since that says 'oh, and bee tee dubs, we can do things involving the outside world, like printing'.
16:44:27 <cole-k> nil: I love it, thank you. hehe gonna replace const with pure
16:44:51 <nil> and ap with <*>? :P
16:45:38 <cole-k> of course, who wouldn't make use of infix operators when the opportunity presents itself
16:46:58 <sim590> koz_: OK. I thought that I should use ListT. When should I use that instead? I thought I needed to change the signature to [Int] -> ListT IO Int.
16:47:34 <EvanR> what are you really trying to do
16:47:35 <koz_> sim590: That is also possible.
16:47:42 <koz_> But EvanR's question is valid too.
16:47:58 <koz_> ListT IO Int means 'I want nondeterminism, but also to interact with the outside world'.
16:48:12 <koz_> Is it _specifically_ nondeterminism you want? Or do you just wanna use lists as containers of stuff?
16:50:19 <sim590> EvanR: I just wanted to print the variable. I'm learning monads right now.
16:50:40 <cole-k> sim590: I get the sense that you don't need ListT here. If you want to see the results of your code, you probably want to decouple your IO code from your pure code
16:51:00 <sim590> I saw that I was in the list monad and I wanted to have some IO in there, then I thought that I needed to transform something to get into the IO monad temporarly to get back to the list monad afterwards.
16:51:08 <sim590> But I found that very complicated for a single print.
16:51:37 <cole-k> so write themselvesTimes :: [Int] -> [Int] and then write main :: IO () with a defintion of like main = print $ themselvesTimes [1,2,3]
16:52:45 <sim590> cole-k: but what if I want to print between two instructions in the monad.
16:53:06 <koz_> sim590: What you pasted does not do that.
16:53:09 <sim590> I don't want to print only the result. ghci does that for me at the moment.
16:53:12 <cole-k> sim590: could you give an example?
16:53:42 <sim590> The same thing I pasted but with another isntruction after the print.
16:55:05 <cole-k> seems like mapM_ :: Monad m => (a -> m b) -> [a] -> m () might do the job
16:55:18 <cole-k> (i simplified the type a little here)
16:55:50 <cole-k> in general, i like keeping my IO code to one part of the program
16:56:13 <cole-k> and themselvesTimes makes most sense as a function of type [Int] -> [Int]
16:56:57 <cole-k> so if you kept it like that, you could write something like main = mapM (\ll -> print ll >> putStrLn "another message") $ themselvesTimes [1,2,3]
16:57:24 <cole-k> i meant mapM_ for the above
16:57:24 <EvanR> theres no such thing as entering the IO monad temporarily
16:57:26 <dmwit> sim590: `themselvesTimes :: [Int] -> ListT IO Int; themselvesTimes l = do { x <- fromFoldable l; ll <- fromFoldable (replicate x x); lift (print ll); return ll }`
16:57:38 <EvanR> you begin there, stay there, and never leave
16:58:21 <dmwit> sim590: In other words: use `fromFoldable` to lift lists into `ListT IO`, and use `lift` to lift IO into `ListT IO`.
16:58:26 <EvanR> you never can enter, in the sense that there is no runIO function
16:59:21 <grandpascorpion> Hello, I recently recently a new version to Hackage of a library I wrote: canon.  I installed using the command cabal new-install on a clean machine.  I then tried to update the cabal version for a to work on a new version.   From the local directory, "cabal new-build" worked fine.  When I tried "cabal new-install", I got this error message:
16:59:22 <grandpascorpion> https://pastebin.com/eFQ9TS7S
16:59:34 <dmwit> (Or liftIO instead of lift if you prefer.)
17:00:03 <grandpascorpion> (I had installed version 0.1.1.4 and was trying to create a new version 0.1.1.5.  Any ideas why I would get this error? )
17:00:58 <dmwit> grandpascorpion: cabal update to synch your cache of what packages Hackage has with what Hackage actually has
17:02:35 <dmwit> fromMVar is a weird primitive to offer.
17:11:25 <grandpascorpion> dmwit, I did run an update beforehand as was I able to install the latest version of my library.    I tried running it again after running "cabal new-update" and got the same error. 
17:24:28 <jle`> grandpascorpion: what command are you using exactly?
17:24:45 <jle`> with the full arguments you are giving it
17:48:52 <sm[m]> following this morning's discussion of Control.Monad.Fail and base-compat 0.11 migration: here's my notes and interim solution for the madness, maybe it helps someone: https://github.com/simonmichael/hledger/commit/499e20c0b233c4b2911d79d43e9d9d56d3aff6b5
17:51:54 <sm[m]> (related: https://github.com/commercialhaskell/stackage/issues/4802)
18:05:03 <jusss> why there's no IOT, but there's liftIO?
18:05:59 <jle`> liftIO lifts IO into another monad transformer
18:06:04 <jle`> or some other monad
18:06:07 <jle`> IO a -> m a
18:06:27 <jle`> it doesn't require any sort of concept of IOT to exist
18:14:32 <koz_> IO is infinitely powerful. Anything you can do in any other monad can be done in IO instead.
18:14:50 <koz_> (in fact, this is how a lot of programming languages do things - everything is implicitly in IO)
18:18:18 <jusss> jle`: I don't understand, if there's IOT, that would be different?
18:18:31 <jle`> IOT is a type
18:18:33 <jle`> liftIO is a function
18:18:38 <jle`> so of course it's different :)
18:19:09 <jusss> koz_: I wonder if other languages programmer know monad's existence
18:19:31 <jusss> jle`: IOT with lift
18:19:36 <jusss> jle`: like others
18:19:39 <koz_> jusss: They usually don't. I think there was some post from someone recently about how Golang accidentally monads. :P
18:20:05 <koz_> I dunno who said it or where, but it was something like 'you're gonna be monading anyway, might as well be honest about it'.
18:20:40 <jusss> koz_: implement monad in other laguages, it's useful? 
18:20:47 <koz_> jusss: Some folks have.
18:21:03 <koz_> I've seen an implementation for C# recently, with a lot of other Haskelly goodness to boot.
18:21:13 <koz_> Me I just write Haskell in the first instance. :P
18:21:25 <jusss> koz_: like I know, only Maybe Either stuff can do something to instead of if-else, I saw that in js
18:21:41 <koz_> jusss: I cannot parse that sentence.
18:22:38 <mycroftiv> when i finally got monads, i discovered that the major piece of software i have written in the past 10 years is actually a 'shell-level monadification' tool to 'monadize' arbitrary textual plan 9 programs into 9pfs
18:22:43 <jusss> koz_: there're lots of if-else statement in the code, and they implement Maybe Monad to instead of that
18:23:00 <jusss> koz_: in javascript
18:23:15 <koz_> jusss: That's... certainly one thing Maybe gets us away from. However, I don't think that's really the point of Maybe.
18:23:28 <koz_> Maybe is an _explicit_ yell going 'HEY THIS THING MAY NOT RETURN A VALUE DEAL WITH IT'.
18:23:45 <koz_> Much like Either e is an _explicit_ yell going 'HEY THIS THING MAY THROW AN E DEAL WITH IT'.
18:23:56 <jusss> koz_: yeah, but Monad seems useless in other languages...
18:24:03 <koz_> And IO is an _explicit_ yell going 'HEY THIS WILL DO SPOOKY THINGS WITH THE OUTSIDE WORLD DEAL WITH IT'.
18:24:06 <koz_> jusss: How do you reckon that?
18:24:15 <koz_> Why is being explicit about effects ever 'useless'?
18:25:32 <jusss> koz_: 'cause I never saw them in others
18:25:37 <mycroftiv> the structural pattern of what monads *do* - acting as a kind of container/context for computation, where you 'proxy' things into that context via the monad - is something that is just 'fundamentally useful' whether it is labeled as 'monad' or not
18:26:07 <koz_> jusss: I never saw pattern matching till I got to Haskell either. I would hardly argue that there's no use for it.
18:26:26 <koz_> s/it/it outside of Haskell./
18:26:37 <koz_> In fact, lots of languages now have (analogues to) pattern matching.
18:27:00 <jusss> koz_: js and python?
18:27:07 <jusss> koz_: scheme?
18:27:45 <koz_> jusss: What are you referring to here? The fact those languages lack monads? The fact they lack pattern matching? The fact monads aren't 'useful' in them? Something else?
18:28:01 <jusss> koz_: pattern matching
18:28:38 <koz_> I would argue that their lack of pattern matching is a misfeature that makes it much harder to work in them than it would otherwise be.
18:28:58 <koz_> Now, I dunno about Python or JS, having made a conscious decision to avoid both, but Scheme has SRFIs about pattern matching stuff I think.
18:29:26 <koz_> (this is even without going into 'what do you mean by Scheme?')
18:29:43 <koz_> (since 'Scheme' ranges between 'R5RS incompletely implemented' and 'Racket')
18:30:06 <turab> And Racket definitely has pattern matching :)
18:30:23 <jusss> koz_: scheme even has SRFIs about Environment Monad, so what, who cares SRFIs...
18:30:49 <koz_> jusss: Uhh.
18:30:54 <koz_> A lot of people care about SRFIs.
18:31:23 <koz_> Not least of all because this gives us portability across implementations, as well as the ability to extend the language without having a new R*RS?
18:31:30 <koz_> s/?/\./
18:31:52 <jusss> koz_ : multiple-threading, GUI, socket, co-routine, which one implementation cares SRFIs about those?
18:32:05 <koz_> jusss: I cannot parse that sentence, sorry.
18:32:27 <koz_> In any case, I think at this point we're firmly off-topic, since this is #haskell, not #scheme or #srfi.
18:32:46 <MarcelineVQ> what is an SRFI
18:32:48 <jusss> koz_: sorry, my bad English, I mean no implement cares those in SRFIs
18:33:19 <aviD> Why does unsafeCoerce "lead to a loss of inlining"?
18:34:33 <turab> On the topic of monad, I was curious why Cont doesn't have something similar to `get` or `ask` (yes we have callCC but why not something that just gives us the continuation?)
18:34:34 <jusss> koz_: all the implements, like chez, racket, guile, what ever, they all have their implement for GUI, socket, multiple-threading, co-routin, they don't care about SRFIs
18:35:02 <turab> My guess is that that's because such an attempt would create an infinite type but I am not sure if that is correct
18:35:33 <koz_> turab: Could you elaborate on what exactly you mean by an 'infinite type' there?
18:35:45 <turab> Sure, one second
18:35:52 <Cale> You can write getCC
18:36:19 <Cale> getCC :: MonadCont m => m (m a)
18:36:19 <Cale> getCC = callCC (\c -> let x = c x in return x)
18:36:19 <Cale> getCC' :: MonadCont m => a -> m (a, a -> m b)
18:36:19 <Cale> getCC' x0 = callCC (\c -> let f x = c (x, f) in return (x0, f)
18:38:31 * hackage influxdb 1.7.1.1 - Haskell client library for InfluxDB  https://hackage.haskell.org/package/influxdb-1.7.1.1 (MitsutoshiAoe)
18:39:16 <turab> koz_: I think I am wrong but I meant a type like (a -> (a -> (...))
18:39:48 <turab> where ... is (a -> (...))
18:39:56 <turab> Very poorly written so apologies
18:40:17 <turab> Cale: Interesting!
18:40:48 <turab> Cale: What I was expecting was something that would return c instead of x. Why can't that be done?
18:41:09 <koz_> Cale: So you get a Cont of a Cont of a?
18:43:21 <turab> Ahhh wait this is exactly how goto is also implemented
18:44:36 <monochrom> My http://www.vex.net/~trebla/haskell/cont-monad.xhtml has an explanation how and why getCC works (I call it "setjmp").
18:44:39 <turab> So my follow up question is, how does one intuitively understand why we need to return `fix c` to capture the continuation?  
18:45:02 <monochrom> That.
18:45:34 <monochrom> Except s/intuitive/logical/
18:45:41 <turab> Thanks! I typed my msg as soon as I received yours :)
18:45:58 <koz_> monochrom: Thanks, shall read.
18:46:01 <turab> I kind of understand it but not well enough to explain it to someone else
18:47:15 <grandpascorpion> Sorry for the delay, jle'.  In order I ran, "cabal new-build" and "cabal new-install" from my local directory.  
18:47:52 <grandpascorpion> jle` 
18:49:16 <turab> monochrom: Would you be willing to answer some follow up questions?
18:49:30 <monochrom> Yes.
18:50:39 <turab> Cool, I am gonna read the link you posted first carefully so brb
18:53:19 <dmwit> This is, like, a beautiful song for monochrom.
18:53:30 * hackage describe 0.1.2.0 - Combinators for describing binary data structures  https://hackage.haskell.org/package/describe-0.1.2.0 (riuga)
18:53:37 <dmwit> First read carefully and think, then ask questions? Woof. Salivating over here.
18:53:44 <monochrom> heheh
18:59:02 <turab> Lol I feel under pressure now.
19:00:22 <turab> Under the Setjmp section, you mention that "c still needs to be applied to some argument". Why is this application necessary?
19:00:39 <turab> Why can't I just return c?
19:01:01 <monochrom> If you return c, the user has to supply a parameter.
19:01:28 <monochrom> Someone has to use "fix c". Either the implementer or the user.
19:01:58 <monochrom> More directly, yes you can, now the user finds it less convenient.
19:03:21 <monochrom> c has a function type "a -> m b" so someone has to supply a parameter to obtain "m b" and perform the jump effect.
19:04:06 <turab> So let's say I want to control what the continuation is applied to instead of letting Cont handle that. In that scenario, I think returning c will do the trick.
19:04:31 <koz_> monochrom: That's a really cool writeup.
19:04:38 <monochrom> thanks
19:05:48 <koz_> I'm using the Clash solvers to determine KnownNat constraints for my code, and it compiles fine with cabal new-build. However, when I try cabal new-haddock, it fails due to not deriving those same constraints.
19:05:53 <koz_> Am I supposed to pass it something else?
19:06:38 <monochrom> @type callCC return
19:06:39 <lambdabot> error:
19:06:39 <lambdabot>     • Occurs check: cannot construct the infinite type: a ~ a -> m b0
19:06:39 <lambdabot>       Expected type: (a -> m b0) -> m a
19:06:55 <monochrom> Yeah, that problem actually.
19:07:25 <turab> koz_: That's what I was guessing
19:08:51 <turab> monochrom: setjmp's type actually made me realize that by `return (fix c)`, `l`'s type is (m b)!
19:09:02 <monochrom> Yes.
19:09:27 <turab> Pretty cool!
19:10:12 <turab> I really wanted `callCC return` to work and I am not sure if there is some other way
19:11:22 <monochrom> It incurs an infinite type. You can pacify it by a newtype wrapper. But then you're building more infrastructure than "return (fix c)".
19:11:56 <turab> What if we say "return (c c)" instead of "return (fix c)" ?
19:12:51 <monochrom> I think that's both a simple type error and a pretty serious thinking error.  You want, conceptually, c (c (c (c ...
19:13:06 <koz_> Never mind I figured it out.
19:13:49 <monochrom> @type callCC (\c -> return (c c))
19:13:52 <lambdabot> error:
19:13:52 <lambdabot>     • Occurs check: cannot construct the infinite type: b ~ m b
19:13:52 <lambdabot>       Expected type: m b
19:15:41 <turab> monochrom: Correct, I am still getting used to the Cont monad
19:15:45 <monochrom> Aw I'm a bit disappointed that while ghcup makes the directory prefix configurable, it's only to the point of <prefix>/.ghcup --- it's always <something>/.ghcup, I cannot make it /usr/local/ghcup
19:19:01 * hackage describe 0.1.2.1 - Combinators for describing binary data structures  https://hackage.haskell.org/package/describe-0.1.2.1 (riuga)
19:27:43 <turab> monochrom: Thanks for the insight! I think your post brought me a step closer to understanding the intuition behind (fix c).
19:28:00 <monochrom> thanks too
19:37:14 <maerwald> monochrom: hmm, why do you need that
19:38:18 <maerwald> the main reason for that behavior is, because it's hard to guarantee that the directory is *exclusively* managed by ghcup if it can be any path
19:39:46 <maerwald> you could create a symlink you know ;)
19:45:23 <koz_> How do Generics-based defaults (using DefaultSignatures) interact with MINIMAL pragmata? I'd ideally like a situation where people can either 1) use Generics, or 2) Define two methods and get the others based on that, or 3) define everything they feel they want.
19:48:45 <aviD> How does compiling with DWARF annotations affect runtime performance?
19:55:01 * hackage dbus 1.2.9 - A client library for the D-Bus IPC system.  https://hackage.haskell.org/package/dbus-1.2.9 (blaze)
20:17:49 <jle`> jusss: i had to leave for a bit, but i think you are mixing up the direction of lift.  What do you mean like "IOT with lift"?  do you have any other monad transformers you are trying to draw an analogy to?
20:18:06 <jle`> liftIO lifts *from* IO, not *to* IO
20:18:23 <jle`> for example we can have a liftMaybe as well, that has nothing to do with MaybeT
20:18:28 <jle`> they are unrelated concepts
20:19:28 <jusss> jle`: I mean can we lift something into IO a
20:19:34 <jle`> can we?
20:19:43 <jle`> liftIO lifts something *from* IO a
20:19:47 <jle`> not *to* IO a
20:20:43 <jusss> jle`: like lift IO String :: MaybeT IO String, we will have a value like IO (Maybe String), right?
20:20:51 <jle`> that's the opposite of lifting into IO , heh
20:21:02 <jle`> that's lifting into MaybeT
20:21:38 <puffnfresh> can imagine it like IO String -> IO (Maybe String)
20:21:51 <jusss> jle`: yeah, so if there's IOT, like lift Maybe String :: IOT Maybe String, we will have a value like Maybe (IO String), right?
20:22:23 <jle`> jusss: we'd have a value IOT Maybe String
20:22:35 <jle`> but are you sure that that would be equivalent to `Maybe (IO String)` ?
20:22:37 <puffnfresh> jusss: in theory but IOT can't exist
20:22:44 <puffnfresh> you can't transform IO
20:22:55 <jle`> what makes you think that IOT m a would be defined as m (IO a) ? 
20:23:08 <jle`> note that this isn't true for most monad transformers
20:23:42 <puffnfresh> jle`: it is true for most???
20:23:42 <jle`> many monad transformers aren't just a straightforard composition of monads
20:23:48 <jle`> hm, i can only think of a few where it is true
20:24:00 <jle`> MaybeT, ExceptT
20:24:35 <jle`> ah, WriterT too
20:24:40 <jle`> that's all i can think of
20:24:47 <jle`> IdentityT if we are looking for esoteric examples :)
20:25:20 * nshepperd . o O (ProxyT?)
20:25:48 <jle`> hm, i think ProxyT would not be defined that way
20:25:50 <literall1Crevice> I'm using stack for the imap package (from hackage), but it has old dependencies. Is there a way to force stack to try building anyway or do I have to clone and modify it?
20:26:00 <jle`> i'd expect data ProxyT m a = ProxyT
20:26:09 <jle`> which is different from m (Proxy a)
20:26:40 <jle`> jusss: in any case, you can't really say that the fact that 'liftIO' exists means that IOT exists; liftIO is actually backwards from the type you would need for IOT to exist
20:26:47 <nshepperd> yeah on second thoughts i think m (Proxy a) would be unlawful
20:27:08 <jle`> data ProxyT m a = ProxyT makes sense because then ProxyT becomes the zero for monad transformer composition
20:27:12 <jusss> jle`: ok
20:27:17 <jle`> just like how IdentityT is the identity
20:27:38 <jle`> analogous to how Proxy is the zero for functor composition and Identity is the identity
20:27:47 <jle`> hm, Proxy is only the left zero nvm
20:28:57 <dmwit> IOT m a definitely can't be m (IO a), or else we would have e.g. \x f -> Just x >>= f :: IO a -> (a -> Maybe (IO b)) -> Maybe (IO b). This would be bad, because it would mean we could observe whether the function returned Just or Nothing without doing any IO.
20:28:59 <iqubic`> Do we have a right zero?
20:29:44 <jle`> puffnfresh: but yeah, StateT, ContT, ReaderT, ListT (the real one), AccumT/SelectT (the new ones) are all not equal to the composition of their associated monads
20:29:58 <puffnfresh> yeah good point jle`
20:30:48 <sm[m]> literall1Crevice: search the docs for allow-newer. I think it must go in a stack.yaml file (perhaps the global one)
20:32:58 <nshepperd> I wonder if sometimes people get confused about the direction that 'lift / liftIO' lifts because of the fact that using it usually puts you, the programmer, into the base monad / into IO.
20:34:07 <jle`> it's also weird too because haskell function namings are a bit inconsistent with whether or not they are named after what they take vs. being named after what they return
20:36:49 <nshepperd> ie. you start by typing 'liftIO (' and now you are trying to come up with an IO action
20:41:43 <jle`> heh, yeah. it shifts the direction you change your thinking in
21:06:05 <monochrom> maerwald: I forgot symlinking! Yes that's does it.
21:45:30 * hackage ghc-prof 1.4.1.6 - Library for parsing GHC time and allocation profiling reports  https://hackage.haskell.org/package/ghc-prof-1.4.1.6 (MitsutoshiAoe)
21:56:01 * hackage viewprof 0.0.0.30 - Text-based interactive GHC .prof viewer  https://hackage.haskell.org/package/viewprof-0.0.0.30 (MitsutoshiAoe)
21:56:03 <koz_> GHC Prof <-- SPJ, maybe. :P
22:33:06 <cheater> hi
22:33:19 <cheater> does anyone know how to log something to stdout in a yesod handler? just for debugging
22:36:26 <sm[m]> Debug.Trace
22:38:04 <cocreature> There is no need for Debug.Trace if you’re already in IO
22:38:13 <cocreature> "hPutStrLn stderr" does the trick just fine
22:38:27 <cocreature> or use the proper logging facilities provided by yesod (it has MonadLogger) instances
22:41:26 <cheater> i just did liftIO $ putStrLn
22:41:45 <cheater> yesod has some logging facilities, that is what i was asking about, but putStrLn is ok i guess
22:43:33 <sm[m]> You can stick trace into more places.. but yes
22:48:35 <cheater> i'm in a MonadIO so it's good enough
22:49:19 <cheater> so my issue is now that somehow yesod isn't parsing my json body, and i've no idea how to make it tell me what's wrong
22:49:59 <dminuoso> cheater: What do you mean by "isn't parsing my json body"? Is it throwing an error? Is it producing incorrect output? Is it just doing nothing and not responding to a request?
22:55:32 <cheater> so, i have started with the yesod-sqlite template, and i added a model that has two Text fields, a unique key on one of them, and a foreign key to the User model. It's basically the Comment model but i added one more Text field and it has a unique key. i created a handler for submitting via post, just like the CommentR handler, made all the other stuff work so that the handler actually does receive ...
22:55:38 <cheater> ... the json. the json contains the values for the both Text fields. the handler does get started (which I know via print debugging at the top of the function) but the print statement right after a call to requireJsonBody does not print out.
22:56:13 <cheater> the console output for that request says "Status: 400 Bad Request 0.002181982s"
22:56:26 <Silent_Alex> J
22:57:11 <cheater> and when i look at what my ajax received (pretty much the same ajax as exists for the comment submission), that received a http 400 error page in full html.
22:58:42 <tomjaguarpaw> Does anyone know a Functor subclass with this function `((z -> a) -> b) -> (z -> f a) -> f b`, or equivalently `(z -> f a) -> f (z -> a)`.  It's a bit like Applicative but preserves exponentials rather than products.
23:00:35 <cheater> dminuoso: can i provide any more information?
23:04:39 <dminuoso> cheater: I dont know yesod.
23:06:28 <dminuoso> cheater: Is there anything further in the log?
23:14:09 <cheater> oh, looks like the html spam actually contains an error message (but the log doesn't)
23:14:20 <cheater> so it's complaining about a field missing in the json.
23:22:18 <cheater> however, i only get what should be in the field when i'm on server side.
23:26:28 <cheater> so, i have a yesod model with three fields, two are provided by a json form submission and one is figured out on server side, and i don't know how to create the model from those things put together.
23:57:22 <jle`> tomjaguarpaw: hm, that's interesting; i'm not sure if i recognize it from anywhere.  what are some instances you had in mind?
23:57:40 <tomjaguarpaw> The only ones I know of are `(->) r`
23:57:47 <tomjaguarpaw> I'm wondering if there are any more
23:57:56 <jle`> i can see Identity, but that's not too interesting
23:58:03 <tomjaguarpaw> It doesn't seem easy to prove that the two are equivalent
23:58:25 <tomjaguarpaw> If f a ~ r -> a for some r then r ~ (forall a. f a -> a)
23:58:46 <tomjaguarpaw> but even with that I can't work out how to prove equivalence, so I'm wondering if they're not equivalent.
