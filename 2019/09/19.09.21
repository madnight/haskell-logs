00:12:51 <ski> iqubic : `FunList a b t' is an "irregular" type (irregular in `t'), because the recursion doesn't use the same type as parameter (for `t')
00:25:10 <sicklorkin> what tools are there for finding unwanted lazy evaluation - GHC.vacuum is nice but having something simple like trace where it would print if either the graph nodes below were evaluated, or not, would be nice.
01:01:12 <incrypto> Haii guyz
01:01:18 <incrypto> Iam New to IRC
01:15:30 <ski> incrypto, heya
01:16:00 <ski> incrypto : do you have any (Haskell-related) questions ?
01:16:30 <incrypto> Not now..! Ive joined so that i can ask when i get stick
01:27:00 * hackage simple-sql-parser 0.6.0 - A parser for SQL.  https://hackage.haskell.org/package/simple-sql-parser-0.6.0 (JakeWheat)
01:31:47 <epta> incrypto: here is your stick mister :)
01:32:56 <ski> mhm
01:36:36 <no-n> types!
01:42:30 * hackage github-webhooks 0.11.0 - Aeson instances for GitHub Webhook payloads.  https://hackage.haskell.org/package/github-webhooks-0.11.0 (onrock_eng)
01:55:06 <koz_> LOL
03:20:00 * hackage cabal-flatpak 0.0 - Generate a FlatPak manifest from a Cabal package description  https://hackage.haskell.org/package/cabal-flatpak-0.0 (HenningThielemann)
03:52:30 * hackage ghcide 0.0.3 - The core of an IDE  https://hackage.haskell.org/package/ghcide-0.0.3 (cocreature)
04:02:59 <jgt> is there a clearer way to write this? http://ix.io/1Wbg
04:15:02 <maerwald> looks ok
04:19:15 <jgt> it looks a bit verbose to me, but I'm not sure it'll be any clearer if it's whittled down
04:19:40 <maerwald> verbose isn't bad.
05:06:30 * hackage mm2 0.1.1.0 - The library that can be used for optimization of multiple (Ord a) => a -> b transformations  https://hackage.haskell.org/package/mm2-0.1.1.0 (OleksandrZhabenko)
05:07:10 <duncan> ghcide :o
05:08:23 <higherorder> Hi! Is there a general pattern in Haskell for traversing a tree while keeping some context based on the parents of the node being traversed?
05:12:42 <dibblego> a tree zipper?
05:14:10 <h3nr1c0> Hi everyone
05:16:25 <higherorder> dibblego: ah; I'll look at that; thanks!
05:18:29 <ski> @type ?cacheGet >>= \case Just nonce -> return nonce; Nothing -> do uuid <- liftIO ?nextRandom; let {nonce = ?mkNonce uuid}; ?cacheSet nonce; return nonce
05:18:31 <lambdabot> (MonadIO m, ?cacheGet::m (Maybe b), ?cacheSet::b -> m a, ?mkNonce::t -> b, ?nextRandom::IO t) => m b
05:18:39 <ski> @let import Control.Monad.Trans.Maybe
05:18:40 <lambdabot>  Defined.
05:18:49 <ski> @type MaybeT ?cacheGet <|> do uuid <- liftIO ?nextRandom; let {nonce = ?mkNonce uuid}; lift (?cacheSet nonce); return nonce
05:18:50 <lambdabot> (MonadIO m, ?cacheGet::m (Maybe a1), ?cacheSet::a1 -> m a2, ?mkNonce::t -> a1, ?nextRandom::IO t) => MaybeT m a1
05:18:57 <ski> @type MaybeT ?cacheGet <|> lift (do uuid <- liftIO ?nextRandom; let {nonce = ?mkNonce uuid}; ?cacheSet nonce; return nonce)
05:18:59 <lambdabot> (MonadIO m, ?cacheGet::m (Maybe a1), ?cacheSet::a1 -> m a2, ?mkNonce::t -> a1, ?nextRandom::IO t) => MaybeT m a1
05:19:08 <ski> @type fromJust <$> runMaybeT (MaybeT ?cacheGet <|> do uuid <- liftIO ?nextRandom; let {nonce = ?mkNonce uuid}; lift (?cacheSet nonce); return nonce)
05:19:09 <lambdabot> (MonadIO f, ?cacheGet::f (Maybe b), ?cacheSet::b -> f a, ?mkNonce::t -> b, ?nextRandom::IO t) => f b
05:19:19 <ski> @type fromJust <$> runMaybeT (MaybeT ?cacheGet <|> lift (do uuid <- liftIO ?nextRandom; let {nonce = ?mkNonce uuid}; ?cacheSet nonce; return nonce))
05:19:20 <lambdabot> (MonadIO f, ?cacheGet::f (Maybe b), ?cacheSet::b -> f a, ?mkNonce::t -> b, ?nextRandom::IO t) => f b
05:19:27 <ski> @type maybe
05:19:29 <lambdabot> b -> (a -> b) -> Maybe a -> b
05:19:40 <ski> @let maybeT :: Monad m => m b -> (a -> m b) -> MaybeT m a -> m b; maybeT nothing just act = maybe nothing just =<< runMaybeT act
05:19:41 <lambdabot>  Defined.
05:19:51 <ski> @type maybeT (do uuid <- liftIO ?nextRandom; let {nonce = ?mkNonce uuid}; ?cacheSet nonce; return nonce) return (MaybeT ?cacheGet)
05:19:52 <lambdabot> (MonadIO m, ?cacheGet::m (Maybe b), ?cacheSet::b -> m a, ?mkNonce::t -> b, ?nextRandom::IO t) => m b
05:19:58 <ski> @type fromMaybe
05:19:59 <lambdabot> a -> Maybe a -> a
05:20:07 <ski> @let fromMaybeT :: Monad m => m a -> MaybeT m a -> m a; fromMaybeT def = maybeT def return
05:20:08 <lambdabot>  Defined.
05:20:15 <ski> @type (`fromMaybeT` MaybeT ?cacheGet) $ do uuid <- liftIO ?nextRandom; let {nonce = ?mkNonce uuid}; ?cacheSet nonce; return nonce
05:20:16 <lambdabot> (MonadIO m, ?cacheGet::m (Maybe a1), ?cacheSet::a1 -> m a2, ?mkNonce::t -> a1, ?nextRandom::IO t) => m a1
05:21:05 <Lycurgus> ur hella active for marked away
05:21:20 <ski> @hoogle Maybe a -> a -> a
05:21:21 <lambdabot> Test.Framework.Providers.API orElse :: Maybe a -> a -> a
05:21:21 <lambdabot> Control.Error.Util (?:) :: Maybe a -> a -> a
05:21:21 <lambdabot> Universum.Monad.Maybe (?:) :: Maybe a -> a -> a
05:21:23 <ski> @hoogle+
05:21:23 <lambdabot> Relude.Monad.Maybe (?:) :: Maybe a -> a -> a
05:21:23 <lambdabot> Control.FromSum fromMaybeOr :: Maybe a -> a -> a
05:21:23 <lambdabot> FMP.Picture getDefault :: Maybe a -> a -> a
05:21:28 <ski> jgt ^
05:46:01 * hackage selda-json 0.1.1.0 - JSON support for the Selda database library.  https://hackage.haskell.org/package/selda-json-0.1.1.0 (AntonEkblad)
05:51:23 <jgt> oh wow, thanks ski. I'll try out a few different approaches.
05:57:20 <_deepfire> Is there something fundamental that prevents GADTs from having a context at the top level, instead of per-constructor?
05:57:30 * hackage ttl-hashtables 1.4.0.0 - Extends hashtables so that entries added can be expired after a TTL  https://hackage.haskell.org/package/ttl-hashtables-1.4.0.0 (erick)
06:11:30 * hackage selda 0.5.0.0 - Multi-backend, high-level EDSL for interacting with SQL databases.  https://hackage.haskell.org/package/selda-0.5.0.0 (AntonEkblad)
06:15:30 * hackage text-format-heavy 0.1.5.3 - Full-weight string formatting library, analog of Python's string.format  https://hackage.haskell.org/package/text-format-heavy-0.1.5.3 (IlyaPortnov)
06:16:50 <d12frosted> Is there a good algorithm for finding shortest path in pointed lists ([a] a [a])? Mostly interested in the two-dimensional case. 
06:20:09 <d12frosted> I've implemented a function just for this, but it's doesn't work as fast as I wish :)
06:23:56 <sicklorkin> d12frosted: are you using cartesian coords?
06:26:12 <sicklorkin> if by pointed list you mean a list of (x,y) I would calc into polar then find the two points that hav ethe closest sum of 0
06:26:52 <sicklorkin> but i have no idea how effient it is to convert from cart to polar - 
06:26:55 <d12frosted> my output is list of directions (N, S, W, E), but during calculations I am using (Int, Int) to quickly find if the point was visited or not.
06:27:11 <d12frosted> pointed list is data U a = U [a] a [a]
06:27:28 <d12frosted> Maybe that's not the right name for this data structure :/ 
06:27:42 <sicklorkin> the a in ([a] `a` [a]) would be your center
06:27:48 <d12frosted> yeah
06:30:33 <d12frosted> so what I did first - I've created a function paths :: (a -> Bool) -> (a -> Bool) -> Board a -> [Path], where first predicate is for checking if the cell is valid to move there and second predicate is a check for target (cell I am looking for). And Path is reversed list of Direction, Coordinates (Int, Int)
06:30:39 <d12frosted> Meh, maybe it's better to show the code
06:31:16 <sicklorkin> i think you just want the polars
06:32:02 <sicklorkin> then it's just a scan of the second list
06:32:23 <sicklorkin> assuming you know which node you are on..
06:33:04 * sicklorkin doesn't know the best algo, but is just trying to help
06:33:37 <d12frosted> https://gist.github.com/d12frosted/3c9cd506bee6947f60021964c5f7bb66 (just don't laugh too hard lol, there is engineering happening there)
06:34:18 <d12frosted> since I am shifting on every step, I know where I am. Also Path structure keeps track of where I am from the initial location
06:34:31 <lyxia> how does a pointed list represent a graph/grid?
06:35:52 <d12frosted> lyxia: if I understood your question, grid is just U (U a)
06:36:48 <d12frosted> I call it Board a, because it's actually a game board :) 
06:39:01 <lyxia> ok I see now
06:41:30 * hackage language-nix 2.2.0 - Data types and functions to represent the Nix language  https://hackage.haskell.org/package/language-nix-2.2.0 (PeterSimons)
06:43:44 <d12frosted> The problem with my solution is that once I have a board that is 7x7 it takes more than 10 seconds to find a solution :( 
06:44:08 <sicklorkin> do you do a lot of back tracking?
06:49:17 <sicklorkin> Take point 0 and point n, where n is the final destination.  find the middle point between those those two point. then calculate the path from the middle point back to the start and another from the middle to the end.  if it's distance is unacceptable choose a new middle point and try again.
06:50:09 <sicklorkin> polar coords give you (radians and distance)
06:50:59 <d12frosted> hm, interesting idea
06:51:29 <sicklorkin> I can't remember which is north but it's either -180 or 180
06:51:35 <d12frosted> right now I am just doing the brute force search :) like, start with empty path and then try all the directions, concat and repeat
06:52:27 <d12frosted> I don't really understand how I can choose the n
06:52:40 <sicklorkin> you do't know where you're going?
06:53:03 <d12frosted> I know only two thigs: how my target should look like (predicate a -> Bool)
06:53:12 <d12frosted> (and there can be many targets)
06:53:36 <sicklorkin> so you can have a list of end points?
06:53:41 <d12frosted> and I know if it's cell is acceptable for the movement
06:53:53 <d12frosted> yes, there can be many end points
06:54:08 <d12frosted> so to give you more perspective
06:54:40 <sicklorkin> d12frosted: i'm working so can't help ya much i'm afraid
06:54:41 <d12frosted> there is a game board with different cells, there is a main character (initial focus of the board) and there are other cells (say, walls) and things that I want to walk to
06:54:51 <d12frosted> sicklorkin: no problem
06:55:06 <d12frosted> thank you for trying to help ;) 
06:55:18 <d12frosted> in any case gonna investigate the idea with polar points
07:22:47 <tomjaguarpaw> I have a bizarre situation where lens is linked against profunctors-5.4 but I can use profunctors-5.5 with that lens in the same GHCi.  Is this expected?
07:23:09 <tomjaguarpaw> It's pretty annoying because it assumes that the definitions of Profunctor conflict.
07:39:53 <geekosaur> loading them at the same time isn't the problem, trying to use them together is. as you're seeing via the type errors
07:40:26 <geekosaur> (note that there's no guarantee of compatibility, so if you somehow found a way around the type errors you can see core dumps instead)
07:40:50 <geekosaur> in fact the types differing is why you can load them at the same time
07:54:00 * hackage distribution-nixpkgs 1.3.0 - Types and functions to manipulate the Nixpkgs distribution  https://hackage.haskell.org/package/distribution-nixpkgs-1.3.0 (PeterSimons)
07:55:30 * hackage hackage-db 2.1.0 - Access cabal-install's Hackage database via Data.Map  https://hackage.haskell.org/package/hackage-db-2.1.0 (PeterSimons)
07:59:29 <tomjaguarpaw> geekosaur: Well yes, I know, but I want them to be the same!
07:59:56 <tomjaguarpaw> If I import Control.Lens and Data.Profunctor unqualified then Profunctor is ambiguous
08:00:16 <tomjaguarpaw> I can see why this behaviour could be useful in rare cases, but why on earth is it the default?
08:00:17 <geekosaur> you can't have that unless you build everything with no optimization and unsafeCoerce it all
08:00:40 <geekosaur> as for why it's default, it's because ghci itself is dumb. this is more or less why cabal repl and stack ghci
08:00:47 <tomjaguarpaw> Huh?  I just want GHCi to load compatible packages by default
08:00:52 <geekosaur> exactly
08:01:20 <geekosaur> you want everythng to magically figure it all out. stack and cabal do thefiguring out; ghci an d ghci by themselves just grab the first things they see
08:01:23 <tomjaguarpaw> Is it even possible to use cabal repl without a cabal file?
08:01:40 <geekosaur> unless told otherwise, usually by cabal or stack. you can use explicit -package parameters to force things yourself
08:02:11 <geekosaur> not really, but you need something like that anyway. guessing does not work; this is the lesson of cabal v1, which did that
08:02:22 <geekosaur> it will guess wrong things because it cannot read your mind
08:03:44 <geekosaur> as for version mismatching, there's a complicated reason for that that comes down to you get this, or you get *really slow* code
08:04:32 <geekosaur> which is why building with no optimizations lets you force the issue with unsafeCoerce (you'll get weird errors or core dumps otherwise)
08:04:59 <tomjaguarpaw> I don't see how unsafeCoerce can work in general.  Those types may genuinely be implemented differently.
08:05:00 <geekosaur> cross-module optimization means faster code but secret dependencies all over the place and internals leaking out everywhere
08:05:24 <tomjaguarpaw> Anyway, at least there should be an option in ghci to load no more than one version of any given module, amongst all transitive dependencies.
08:05:33 <tomjaguarpaw> Or fail with an explanation if that is impossible.
08:06:18 <geekosaur> the way things are don e is wrappers like cabal and stack do this; ghc, including ghci, is just a compiler and does what it's told and tries to guess what you didn't tell it
08:06:23 <geekosaur> but only tries, and not that hard
08:06:33 <tomjaguarpaw> In fact I think some of this behaviour is a holdover from the days when it was impossible to have two packages installed which had the same version.
08:10:47 <jsomedon> I am trying to setup vscode and I see hie, ghcide, haskero, which one do you guys recommend?
08:11:03 <tomjaguarpaw> Having said that, I suppose that GHCi pretends that it doesn't know that cabal exists.
08:12:05 <geekosaur> because if it pretends cabal exists then it can't play with stack
08:12:45 <geekosaur> and conversely if it pretends stack exists it can't play with cabal. there is not One True Way, it turns out, there's at least two. so ghc / ghci is caught in the middle and plays dumb and lets each one tell it what to do
08:13:17 <geekosaur> .ghc_environment files were an attempt to work around this, but cause their own issues
08:13:45 <geekosaur> (do one build with your tool, it leaves those around for ghci to find and use later. at least in theory)
08:19:21 <nshepperd2> Environment files seem to work quite well for me
08:21:44 <geekosaur> they seem to work quite well for some folks and cause endless problems for others
08:22:54 <nshepperd2> Interesting. What kind of problems should i look out for?
08:22:56 <geekosaur> it's like cabal vs. stack, but built into ghc so harder to deal with.
08:24:09 <geekosaur> I had a problem with m,ultiple versions of ghc (hvr's repo vs. nix) and the wrong ghc seeing an environment. others have reported other issues, which led to cabal.project being given a setting to tell ghc to disable them
08:25:09 <geekosaur> suspect it's mostly those of us who work with multiple ghc versions from different places for various reasons (I would not be surprised if nix / nixos is a common factor for many)
08:26:59 <orzo> i sympathise with the anti-implicit-state view, but once i knew about environment files, they've become more helpful than harmful to me
08:28:58 <orzo> i have scripts to do manual edits to them though
08:29:18 <orzo> like, to search a packagedb and add the package-id to the current environment file
08:29:27 <orzo> maybe that functionality should be part of ghc-pkg directly
08:31:17 <orzo> or even ghc directly
08:32:07 <orzo> anyone else use environment files this way?
08:32:25 <monochrom> I am even more extreme.  cabal v1's "global" and "user" are extremely helpful to me, not sandboxing or the v2 system.
08:32:54 * geekosaur has found uses for all three modes
08:34:09 <orzo> i'e switched to the v2 system, but then i also use stack which seems to be mroe like the v1 system
08:35:25 <orzo> when i have a project that i use stack to build, i create an environment file manually that points at the stack in-place built library similar to what cabal v2- would do
08:36:04 <monochrom> The difference between v1 and v2 most visible to me (whenever I don't care about using more disk space) is that v1 gives stable predictable doc location, v2 gives unstable unpredictable.
08:37:05 <monochrom> Yes I am one of those old-geezers who still build and read local docs and assume the worst about not having wifi for accessing hackage.
08:37:56 <orzo> i do that too, but i use os-packages or stack-snapshot to manage my docs and don't usually need access to the in-place docs
08:39:00 <orzo> i wish hoogle had a more incremental update system
08:39:27 <orzo> the os-packaged way of doing docs is slow as hell as every install means rebuilding the hoogle db
08:56:23 <enternalconfusio> Hello. Can I get some help on a syntax understanding issue?
08:56:42 <enternalconfusio> In https://github.com/seantalts/hasktrip/blob/master/src/MicroKanren.lhs#L87
08:57:10 <enternalconfusio> Given function that has signatur  --  fresh :: (Term -> Goal) -> Goal
08:57:46 <enternalconfusio> and implementation -- fresh f (subs, idx) = (f (Var idx)) (subs, (idx + 1))
08:58:34 <geekosaur> Haskell is pretty loose about how it lallows you to work with functions
08:58:42 <enternalconfusio> Does these two actually match? or is there a mistake in the code?
08:59:16 <enternalconfusio> I don't understand where the (subs, idx) part comes from
08:59:19 <geekosaur> so, (Term -> Goal) describes a function. It then takes something which it will eventuallt apply the function to
08:59:34 <geekosaur> you need to expand all the types, and pay close attention
09:00:20 <geekosaur> (note that Goal is also a function type)
09:01:49 <jzyamateur> Is a function same as data constructor in haskell?
09:01:50 <enternalconfusio> Ok, I see. What I gather is Haskell let's you destructure Goal pattern match on that input as well?
09:01:55 <geekosaur> also note that in Haskell, if you have something whse value is a function, you can simply apply it as is. you don't need to capture it and/or use special syntax to apply it
09:02:00 <geekosaur> yep
09:02:20 <geekosaur> haskell doesn't care where it came from or what you do with it as long as everything ultimately matches up
09:02:25 <geekosaur> this can be very confusing at first
09:03:04 <jzyamateur> I concluded it from "pattern = expr" seems to be saying the function naming/binding in pattern part is a data constructor
09:03:29 <enternalconfusio> yep, very confusing!
09:04:27 <geekosaur> jzyamateur, some data constructors can be used as functions, if they take parameters.
09:04:39 <geekosaur> :t Just
09:04:40 <lambdabot> a -> Maybe a
09:05:09 <geekosaur> in expression context it's a function that takes some value and produces that value "lifted" into Maybe
09:05:24 <lavalike> geekosaur: why "some"?
09:05:29 <geekosaur> in pattern context it deconstructs a Maybe value and optionally gives you the value
09:05:48 <geekosaur> Nothing isn't a function, since it doesn't take a parameter
09:06:05 <geekosaur> it's more like a constant value
09:06:55 <lavalike> oh yeah some don't have arrows in them ok
09:07:41 <jzyamateur> I am saying when we define something like a base case "factorial 0 = 1" we define a function factorial, My assumption is patterns are made from Data constructors.  
09:08:01 <geekosaur> aside from the wired-in ones like tuples and lists, yes
09:08:15 <geekosaur> patterns operate on structure, as specified in data constructors
09:10:11 <jzyamateur> Let me put it this way: Are all functions considered data constructors? Or is it wrong intuition and one should not rely on the same.
09:11:46 <geekosaur> not all functions are data constructors, no. your factorial example did not define a data constructor
09:11:48 <merijn> jzyamateur: No, I would even say most functions *aren't* data constructors
09:14:30 <glguy> data constructors are the capitalized names introduced by a data type declaration
09:14:39 <jzyamateur> How does interpreter differentiate in an example like "factorial 0 = 1"? If not already defined, bind the name to function? Also case sensitivity?
09:15:30 <merijn> jzyamateur: Constructors are only defined in data definitions, so "data Foo = Constructor1 Int Bool | Constructor2", etc.
09:15:43 <merijn> jzyamateur: They are never defined at the top level
09:16:22 <merijn> jzyamateur: Top level definitions have patterns, but patterns never *define* constructors, they only ever reference existing ones
09:16:30 <geekosaur> ...if you do use it at top level, it's a pattern match as part of an assignment or function definition
09:17:15 <jzyamateur> got it. 
09:26:37 <ski> jzyamateur : there are two different kinds of defining equations (for values), pattern bindings, and function bindings
09:28:05 <jzyamateur> ski I thought each and every definition follows "pattern = expr" rule and introduces bindings using pattern matching.
09:28:33 <ski> basically, the former look like `<pat> = <expr>', while the latter look like `<id> <pat> ... <pat> = <expr>' (at least one pattern)
09:28:57 <jzyamateur> ah, got it
09:28:59 <geekosaur> until you define infix operators :)
09:29:52 <ski> a pattern (`<pat>') can be a variable, `<id>', a (fully applied) data constructor `<con> <pat> ... <pat>' (zero or more patterns), and a few other cases
09:30:15 <ski> geekosaur : yep, i said "basically" (also, i'm ignoring guards and `where's)
09:30:47 <ski> `<con>' being a data constructor, a capitalized identifiers, while `<id>' is a variable, a lower case identifier
09:31:23 <ski> so, if you have a variable, applied to at least one parameter, in your definiendum (iow to the left of the `='), then it's a function binding
09:31:35 <ski> if you don't have that, it's a pattern binding
09:33:06 <ski> with a pattern binding, `<pat> = <expr>' you're *defining* the variables that occur in `<pat>'. a by-need implementation will probably demand `<expr>' (caching the value for the next demand), whenever you demand one of those identifiers
09:34:03 <ski> so, `Node myRoot myChildren = buildTree blah' will define `myRoot' and `myChildren' for you, making use of `buildTree' and `blah', which must be in scope at the site of this defining equation
09:34:49 <ski> however, with a function binding `<id> <pat> ... <pat> = <expr>', you're *not* defining any of the identifiers in the patterns `<pat>',...,`<pat>' !
09:35:02 <ski> you're defining `<id>' (to be a function value)
09:37:07 <ski> such that, whenever you call `<id>', with arguments / actual parameters (the same number as the `<pat>', and, obviously, of matching types), those actual parameters will be matched with the patterns / formal parameters `<pat>',...,`<pat>', *locally* binding the identifiers in those to the respective parts of the actual parameters / arguments, those *local* bindings scoping *only* over `<expr>', whose value is the value of that function call
09:38:34 <ski> so, in `foo (Node myRoot myChildren) = frobnicate myRoot (reverse myChildren)', you're defining `foo', "exporting" that binding from this declaration
09:39:07 <ski> however, *locally*, you're defining `myRoot' and `myChildren', so that, although the body, `frobnicate myRoot (reverse myChildren)', depends on all of `frobnicate',`myRoot',`reverse',`myChildren'
09:40:28 <ski> in the whole declaration, the (local) bindings for `myRoot' and `myChildren' "cancel/discharge" those dependencies (because of the local binding), so that, ultimately, this declaration only depends on `frobnicate' and `reverse' being in scope at the sire of the defining equation
09:40:41 <ski> jzyamateur : does that make any sense to you ?
09:41:51 <ski> in a pattern binding, `<pat> = <expr>' you're ("globally") defining the identifiers in `<pat>' (or rather, you're defining them at the level that this defining equation occurs. it could occur in a `let' or `where', inside a larger declaration)
09:43:05 <ski> while, in a function binding, `<id> <pat> ... <pat> = <expr>', you're *not* ("globally") defining identifiers in `<pat>',...,`<pat>', but only `<id>' (but those previous identifiers *are* *locally* bound within `<expr>')
09:43:30 <jzyamateur> got it, id is binding introduced at top level, where as the parameter bindings exist in the scope of the function expression only.
09:44:51 <ski> (aside comment : from a logical / type-theoretical view, pattern-bindings only have introduction forms to the left of `=', while function-bindings also have elimination forms (application). defining an object, in an OO-language, like e.g. O'Caml, by specifying how it's to respond to messages, is another case of such definition-via-elimination)
10:08:47 <rsoeldner> Is there an xml lib which allows validating against a xsd ?
10:26:21 <rotaerk> hmm... this library I'm using, the author has decided to stop including .cabal files in their git repo
10:26:38 <rotaerk> instead they just have the .yaml file, so I need to run hpack to generate my .cabal file
10:27:09 <c_wraith> I mean, that's the right way to do things in git
10:27:19 <c_wraith> you should only commit the source of truth to the repo
10:27:44 <c_wraith> If you're using hpack to auto-generate the package.cabal file, then don't check that file in.
10:27:48 <csimple> Hey, just started learning Haskell, and I have no idea why this is not working: https://bpaste.net/show/QquG
10:27:56 <csimple> Help would be appreciated!
10:28:20 <c_wraith> csimple: I recommend writing your code in a file then using :load in ghci to manipulate it
10:28:36 <c_wraith> csimple: the reason you're having trouble is that ghci doesn't play nicely with multiline definitions.
10:28:42 <rotaerk> yeah, it just adds more work for me when using the library with cabal
10:29:07 <rotaerk> and I'll end up with a submodule pointing to that library, and then have a .cabal file layered on top of it
10:29:09 <c_wraith> csimple: the second line shadows the first line, instead of both being used as the definition
10:29:23 <csimple> Thanks c_wraith
10:29:31 <c_wraith> csimple: there are ways to make it work in ghci, but there are a lot of advantages to putting it in a file
10:30:49 <csimple> Huh, I would have expected it to be default behaviour, but you learn something new everyday!
10:32:52 <geekosaur> it's hard to do that sensibly
10:33:13 <geekosaur> how doeos it guess the difference between "fib 1 = 1; fib n = ...
10:33:20 <geekosaur>  and "x = 5" "oops
10:33:24 <geekosaur>  "x=6"
10:33:33 <geekosaur> sorry for hitting return by accident :/
10:33:52 <geekosaur> how does it guess the difference between "fib 1 = 1; fib n = ..." and "x = 5" /oops/ "x = 6"?
10:33:56 * ski returns the hit
10:34:48 <geekosaur> there is a multiline mode where you can hit return twice to end a binding group, or :{ :} for grouping
10:35:30 <c_wraith> or as geekosaur also demonstrated, you can put them all on one line with ; between them.
10:35:35 <rotaerk> is there some way for a cabal project (with new-* commands) to automatically run hpack on one of my project references
10:35:52 <c_wraith> But I stand by my assertion that there are advantages to using a file that make it worthwhile, especially while just starting.
10:36:06 <rotaerk> if that library I'm using just has a .yaml file, I probably should just generate the ccabal file when I build it, rather than manually generating and committing it
10:36:18 * ski notices csimple is MIA
10:36:38 <c_wraith> rotaerk: I don't think so.  The place you'd configure something like that is the .cabal file
10:37:04 <rotaerk> so if my project A is referencing project B, and B has a .yaml, I can put running hpack into A.cabal?
10:37:17 <rotaerk> how?
10:37:22 <c_wraith> I'm not sure about that
10:37:45 <c_wraith> I don't think there's a build hook for before checking dependencies
10:41:40 <c_wraith> this sounds like the sort of thing you'd go to shake to handle
10:42:01 <c_wraith> "two build systems not working together?  add a third one!"
10:42:05 <rotaerk> ugh
10:45:38 <EvanR> build systems act like an accumulating cellular automaton. If the behavior spelled out a serpinski triangle it be tolerable
10:46:54 <csimple> Thanks geekosaur for explanation
10:52:14 <csimple> so c_wraith, I tried with file, and stuck zero. https://bpaste.net/show/oyyn
10:52:58 <c_wraith> oh.  ` isn't a valid character in an identifier
10:53:06 <c_wraith> The thing you're seeing are using ' instead
10:53:25 <c_wraith> straight single-quote, instead of angled single quote
10:54:00 <csimple> Oki, cool
10:55:51 <csimple> Worked nicely, thanks. Is there Grammar like BNF for Haskell which I can see so I don't make these mistakes?
10:57:56 <c_wraith> https://www.haskell.org/onlinereport/haskell2010/
10:58:04 <c_wraith> There is a grammar in there :)
10:58:45 <c_wraith> the syntax reference section
10:59:15 <csimple> Got it. Bookmarked!
11:12:22 <merijn> rotaerk: My recommendation would be to stop using hpack, tbh
11:12:55 <rotaerk> merijn, yeah, it's not my project that's using hpack, it's a library I'm using
11:13:05 <rotaerk> he used to have cabal files, but switch to hpack...
11:13:09 <rotaerk> switched *
11:13:18 <merijn> rotaerk: This is why I'm in favour of *everyone* stopping with this hpack nonsense >.>
11:13:22 <rotaerk> hehe
11:13:41 <merijn> At the very least anyone using hpack should commit their generated cabal files
11:15:03 <rotaerk> it seems my only options are 1) manually generate hpack every time I clone my project; 2) fork his repository, add the generated .cabal to it, point my submodule to my fork, and re-generate the .cabal every time I pull changes from him, or 3) add another build tool to the mix (e.g. switching to stack, or adding shake)
11:15:44 <csimple> Whew, Pattern matching, cases and guards seem to be very similar, but not completely. Are there any conventions when one should use one?
11:15:59 <cocreature> rotaerk: 4. make a PR that commits the generated cabal file and kindly explain why this is useful for you
11:16:27 <merijn> csimple: pattern matching and cases are basically the same
11:16:27 <rotaerk> heh true; I do have an open issue with his project about this, and I explained the dilemma... will see what he says
11:16:44 <merijn> csimple: i.e. the compiler will turn all function pattern matches into case-of
11:16:58 <merijn> csimple: So it's just for ease of reading/writing
11:17:25 <csimple> That is useful to know! What about guards?
11:17:47 <merijn> csimple: guards have a slightly different purpose in that you can use functions within the guards which you can't do directly in pattern matching
11:18:19 <merijn> csimple: for example, "myFun (Foo i) | even i =" <- can't write that directly, because you can't use functions on 'i' in a pattern match
11:18:30 <csimple> merijn  mean while matching? 
11:18:34 <merijn> csimple: Yeah
11:19:07 <csimple> Oki, nice to know
11:19:16 <merijn> csimple: Whether to use multiple function patterns of case-of is usually a matter of "which is more readable" (multiple function patterns means you have to type each name and argument multiple times)
11:19:44 <merijn> csimple: where blocks are also scoped over a single function pattern, so if you wanna use the same where block over multiple cases, you might decide to use case-of instead
11:20:06 <merijn> csimple: Note that you can also use guards inside case-of
11:20:10 <csimple> So, pattern matching is kind of syntactic sugar for cases, and guards are more useful when one wants to do match by functions
11:20:41 <merijn> > case Just 5 of Just n | even n -> "whoo!"; _ -> "Not even!"
11:20:43 <lambdabot>  "Not even!"
11:21:09 <merijn> csimple: Most people would also use "pattern matching" to refer to case-of
11:21:35 <merijn> csimple: But yes, the function patterns are syntactic sugar for case-of and guards are actually part of the pattern matching syntax
11:21:46 <aiowej> Looking for tutor/pair-programmer - WILLING TO PAY $500 (bitcoin or SEPA). In Copenhagen (DK) or via video chat. I want to be able to transform a simple functinal lang into CPS, then closure convert it, and then output tail call optimized C (a la 90 minute scheme-to-c). Prefer implementing in Elm, Haskell, OCaml. Struggling with self-studying and want to grok it. Please message here or by electronic mail freenodecompiler _a.t_
11:21:46 <aiowej> martinjosefsson _dot_ com. Many thanks. 
11:33:44 <csimple> Are recursions tail-call optimized?
11:34:33 <merijn> Yes, no, maybe
11:34:38 <Cale> csimple: It's a weird question, because most Haskell implementations (including GHC's) don't really have a call stack to begin with
11:34:39 <EvanR> ^ needs an FAQ question
11:34:50 <merijn> csimple: Basically, the question itself doesn't make a lot of sense :)
11:35:04 <merijn> (In the context of GHC Haskell, that is)
11:35:25 <Cale> csimple: Instead, the stack is primarily used to keep track of pattern matches that are waiting for an expression to be sufficiently evaluated to match a pattern.
11:35:45 <ski> it's better to ask whether "tail-calls" are a relevant thing to take into account (yes, they are. but perhaps not to the same extent as in a strict language)
11:36:25 <csimple> Okay, let me understand this with classical problem
11:36:31 <Cale> It's possible to write tail recursive functions which blow up the stack, but also writing functions tail-recursively can be part of the solution to such problems.
11:36:36 <csimple> fib x = fib (x-1) + fib (x-2)
11:36:57 <merijn> csimple: That will blow up, but not because of stack usage ;)
11:37:00 <Cale> So, if we apply fib to 5 or something
11:37:11 <csimple> So, what will happen with this provided I give proper base conditions
11:37:11 <Cale> (+) is going to pattern match both its arguments
11:37:40 <Cale> probably its left argument first (let's say)
11:37:45 <Cale> and that pattern match will wait on the stack until fib (x-1) is evaluated
11:38:43 <csimple> Wait, I thought someone above said there is no call stack
11:38:52 <Cale> I said that, yes
11:38:58 <ski> there's no call stack
11:39:10 <Cale> The stack is used more for pattern matches waiting to happen.
11:39:23 <ski> that doesn't mean there is (in a typical implementation) no stack
11:39:30 <Cale> (and function applications where the function is not yet a lambda)
11:40:23 <ski> (also cf. the difference between `ma >>= amb = Cont (\k -> runCont ma (\a -> runCont (amb a) (\b -> k b)))' and `ma >>= amb = Cont (\k -> runCont ma (\a -> runCont (amb a) k))')
11:40:45 <merijn> ski: I don't think bringing in Cont is helpful for someone with these questions :p
11:40:45 <Cale> wha...
11:41:05 <merijn> I don't think Cont(T) has ever made anyone *less* confused
11:41:48 <csimple> I dont understood that :ski... well, to be honest, I am still trying to understand what you guys are saying about recursion
11:42:00 <merijn> csimple: I'd just ignore that bit :)
11:42:11 <Cale> csimple: Let's look at this implementation of sum:
11:42:19 <Cale> sum xs = sum' 0 xs
11:42:23 <EvanR> csimple: your code isn't tail recursive anyway...
11:42:26 <Cale> sum' n [] = n
11:42:35 <Cale> sum' n (x:xs) = sum' (n+x) xs
11:42:38 <csimple> :evanr I know
11:42:41 <Cale> i.e. the usual tail recursive thing
11:43:13 <Cale> So if we evaluate sum' 0 [1,2,3], what's going to happen?
11:43:26 <Cale> sum' 0 [1,2,3]
11:43:33 <Cale> -> sum' (0+1) [2,3]
11:43:49 <Cale> and now remember that lazy evaluation is outermost-first, so we don't evaluate that (0+1) right away
11:44:01 <Cale> instead, we proceed with the sum'
11:44:04 <csimple> Okay, so it will evaluate till end
11:44:05 <mpickering> merijn: https://github.com/mpickering/hie-bios/pull/53
11:44:12 <csimple> and only return me result when it is forced to
11:44:18 <mpickering> It showed up a few places where the current API is wrong 
11:44:22 <csimple> As i remember it is completely lazy
11:44:26 <Cale> and because the list is already evaluated, nothing has to go on the stack before we can pattern match (x:xs) in the definition of sum'
11:44:42 <Cale> -> sum' ((0+1)+2) [3]
11:44:52 <Cale> -> sum' (((0+1)+2)+3) []
11:44:57 <Cale> -> ((0+1)+2)+3
11:45:00 <Cale> but now...
11:45:11 <merijn> mpickering: \o/
11:45:14 <Cale> The outermost (+) is applied to ((0+1)+2) and 3
11:45:42 <Cale> It's going to pattern match on those arguments (internally)
11:45:55 <mpickering> `ghcide` also won't be able to use this kind of configuration yet so... not that useful at the moment
11:45:58 <Cale> and so this addition will wait on the stack while (0+1)+2 is evaluated
11:46:14 <Cale> and then *that* addition will wait on the stack while 0+1 is evaluated
11:46:29 <Cale> and it will evaluate to 1
11:46:40 <Cale> pop the stack, and 1+2 will evaluate to 3
11:46:42 <csimple> Which will then pick +2 and then +3?
11:46:54 <Cale> pop again and 3+3 will evaluate to 6
11:47:22 <rotaerk> merijn, thinking on it, I might need to start using shake anyway
11:47:40 <rotaerk> e.g. to build shader files
11:47:42 <Cale> If the list were millions of elements long, we might blow up the stack then
11:47:58 <rotaerk> so I can just add the generation of .cabal from .yaml to that...
11:48:21 <EvanR> hey if you have a list millions of elements long materialized, in memory, whats 2x that :)
11:48:28 <Cale> So, in order to ensure this doesn't happen, we can hint to ghc that it ought to evaluate the sums as it traverses the list in the first place (though in practice, it will be smart enough to realise this for itself if you have -O turned on)
11:48:30 <EvanR> chump change
11:48:58 <Cale> EvanR: Depends on whether there's a maximum stack size
11:49:13 <EvanR> ^ optimization that changes whether a program is merely slow or crashes
11:49:37 <EvanR> to one that is fast
11:49:50 <Cale> So, if we want to hint that it should evaluate the argument early, we can use seq
11:49:52 <ski> merijn : it wasn't really a comment for csimple, i suppose ..
11:50:11 <ski> (csimple : sorry, i didn't mean to confuse you)
11:50:20 <Cale> seq x y behaves like pattern matching on x and producing y as the result regardless of the outcome
11:50:23 <EvanR> it would be nice if optimizations didn't "fix" a broken program
11:50:26 <rotaerk> though, I don't wanna use shake... being able to use cabal new-build, new-repl, etc is just so simple
11:50:41 <Cale> i.e. if the evaluation of x doesn't terminate, then seq x y doesn't terminate, but the result of seq x y is y
11:50:43 <Cale> otherwise
11:51:19 <merijn> rotaerk: No alternative for this package?
11:51:20 <Cale> sum' n (x:xs) = let m = n+x in seq m (sum' m xs)
11:52:37 <Cale> If we write sum' this way, the compiler will be much more likely to evaluate m before it begins to recurse, avoiding generating a large unevaluated expression in memory whose evaluation would blow the stack
11:52:50 <rotaerk> well, the package in question is easytensor, which was developed by the same person who developed the vulkan-api bindings, and they really go hand-in-hand
11:52:56 <Cale> Another option which is equivalent is to use a bang pattern:
11:53:00 <rotaerk> replacing them would be quite a hassle; I'm pretty committed
11:53:11 <Cale> sum' !n (x:xs) = sum' (n+x) xs
11:53:22 <Cale> I suppose this is actually equivalent to
11:53:33 <Cale> sum' n (x:xs) = seq n (sum' (n+x) xs)
11:53:53 <rotaerk> I'll just hpack manually for now, and wait for his response before I make a decision
11:54:00 <Cale> i.e. ensure that n is evaluated before proceeding
11:55:02 <Cale> It's somewhat important to know that the compiler doesn't absolutely have to take this advice, all that seq x y *really* says is that both x and y must be evaluated before the result of evaluating y can be used.
11:57:07 <Cale> So a pessimising compiler would still be within its rights to always evaluate y first, and that would create a problem. However, in practice, this additional knowledge that the evaluation of x is eventually required is enough of a hint to get it to do it sooner.
11:57:25 <Cale> There is an additional primitive pseq which is more rigid in its definition, and forces the order
11:58:05 <csimple> Wait a moment Cale, let me read that over again, and see if I understood everything
11:58:19 <Cale> Yeah, I kind of dropped a lot of stuff on you there :D
12:05:56 <csimple> Okay, so I got all that! 
12:06:53 <csimple> seq is hint to compiler that I am going to give you two arguments, x and y, and while I need y, -- x might be needed, so it would be better if you evaluate x first
12:07:21 <csimple> while pseq strictly tells compiler to evaluate x first and then y 
12:07:33 <Cale> yes
12:09:06 <Cale> There's also par x y which evaluates to y, but adds x to a queue of items to be evaluated in parallel on some processor, if time permits before the result is needed
12:09:29 <csimple> I am ignoring the bangs bit for now, because it does seem like it is syntactic sugar ;)
12:09:42 <Cale> yeah, that's just syntactic sugar
12:10:22 <csimple> Great! Thanks so much for help
12:18:00 * hackage louis 0.1.0.0 - Turning images into text using Braille font  https://hackage.haskell.org/package/louis-0.1.0.0 (tsoding)
12:22:00 * hackage louis 0.1.0.1 - Turning images into text using Braille font  https://hackage.haskell.org/package/louis-0.1.0.1 (tsoding)
12:25:13 <wildtrees> is Data.ByteString.Char8 strict ? 
12:25:55 <Cale> yes
12:26:09 <merijn> Also evil
12:26:22 <wildtrees> yea I am having missing output after an append 
12:26:27 <merijn> https://github.com/quchen/articles/blob/master/fbut.md#bytestringchar8-is-bad
12:27:05 <merijn> wildtrees: Is that appended output ascii?
12:28:21 <wildtrees> it should all be ascii, its from windows console, using BS.getLine where BS is Data.ByteString.Char8 
12:28:32 <iqubic> I'm looking for a function with the signature: (Traversalble t, Applicative f) => t (f a) -> f (t a)
12:28:41 <merijn> wildtrees: Why aren't you using Text's getLine?
12:28:54 <merijn> iqubic: sequence?
12:28:57 <merijn> :t sequence
12:28:58 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
12:29:06 <wildtrees> is that what I should be using? is it strict as well? 
12:29:07 <merijn> Oh, wait sequenceA, I guess
12:29:10 <merijn> :t sequenceA
12:29:11 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
12:29:27 <merijn> wildtrees: If you input is text then you should be using Text, yes. And Data.Text is strict, yes
12:29:44 <iqubic> What do I need to import to use that?
12:29:54 <merijn> wildtrees: (see aforementioned Char8 is bad link)
12:30:04 <merijn> @hoogle sequenceA
12:30:05 <lambdabot> Prelude sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
12:30:05 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
12:30:05 <lambdabot> Test.Hspec.Discover sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
12:30:14 <merijn> iqubic: Nothing, apparently :p
12:35:00 * hackage HsYAML 0.2.0.0 - Pure Haskell YAML 1.2 processor  https://hackage.haskell.org/package/HsYAML-0.2.0.0 (HerbertValerioRiedel)
12:36:41 <iqubic> Bazaar is a weird data type.
12:38:50 <wildtrees> switch to Data.Text and Data.Text.IO from Data.ByteString.Char8 and it works fine now, thanks merjin :) seems the bs was dropping some of the data in an append
12:38:56 <wildtrees> switched to 
13:04:42 <ski>   seq !_ x = x
13:10:49 <yqt> hi, i am not understanding how cabal 3 install works. i would just need to get a library from hackage and have it available, but it seems cabal doesn't register the package for ghc and i can't find what to do to register it. any help?
13:11:43 <slack1256> yqt: Are you using v2-install and/or v2-build?
13:12:19 <yqt> slack1256,  just "cabal install" and i'm assuming it's the equivalent of new-install being version 3. am i assuming wrong?
13:12:33 <yqt> *v2-install sorry
13:12:49 <merijn> yqt: install is v2-install in cabal-install 3.0, yes
13:13:06 <merijn> yqt: What do you mean by "have it available"?
13:13:29 <sclv> yqt: if you put the libs in the deps of your project then new-build builds and makes it available when you new build your project
13:13:33 <yqt> slack1256 i mean what i was used to happening some time ago. ghc-pkg list listing it for example
13:13:41 <yqt> i have no project
13:13:42 <slack1256> yqt: I am on cabal 2.4 so, install is the legacy install for me.
13:13:44 <yqt> i just want the lib :D
13:13:45 <sclv> And also in the repl when you new-repl
13:14:07 <sclv> when you new-install a lib it goes into the store, not the global db
13:14:16 <sclv> So ghc-pkg list doesn’t see it
13:14:19 <yqt> i thin i got that
13:14:23 <yqt> but how to make it available then?
13:14:42 <sclv> But it goes in the global ghc env file
13:14:52 <sclv> So ghci and ghc do “see” it
13:14:58 <slack1256> When you new-install a library and you are on a project folder, there is a hidden dot file that is written on the base of the project. That file informs ghc-pkg and ghci where the libraries for the current environment are located.
13:15:08 <yqt> mmh.. what is the global ghc env file?
13:15:20 <sclv> google “ghc environment file”
13:15:36 <yqt> slack1256 since i don't have a project, how do i just know what would be written in those files?
13:15:51 <sclv> slack1256: i think it always goes in the global env file, not project local
13:16:07 <slack1256> sclv: That can be right.
13:16:07 <sclv> Project local ones are generated when you new build with the flag to gen it
13:16:42 <sclv> yqt: its somewhere in your ~/.ghc folder iirc
13:17:18 <yqt> oh
13:17:19 <yqt> yes
13:17:23 <slack1256> You can probably find it with `find ~/.ghc -cmin -30 -type f`
13:17:28 <yqt> thanks sclv
13:17:30 <yqt> it seems to be there
13:19:53 <yqt> i guess that should be mentioned somewhere in the doc (at least i didn't find it)
13:20:15 <rotaerk> merijn, I think that problem really only applies if I'm getting his package as a submodule.  it works fine (i.e. has a .cabal file) if I pull it from hackage
13:20:29 <merijn> rotaerk: Well, yes
13:20:31 <rotaerk> I might just need to install stack and use that if I ever do development directly on his project
13:38:30 * hackage louis 0.1.0.2 - Turning images into text using Braille font  https://hackage.haskell.org/package/louis-0.1.0.2 (tsoding)
13:42:00 * hackage setlocale 1.0.0.9 - Haskell bindings to setlocale  https://hackage.haskell.org/package/setlocale-1.0.0.9 (Kritzefitz)
14:05:18 <blacklor> watsup guys
14:06:57 <blacklor> hey guys
14:08:54 <pavonia> Welcome! If you have a Haskell-related question, do ask
14:09:24 <blacklor> this place is damn silent
14:11:17 <jle`> yeah, for irc, it's usually everyone idles until someone asks a question or brings up some relevant news or something
14:15:06 <tdammers> lots of people here also just leave their IRC client connected and check back hours later
14:15:25 <blacklor> what am i supposed to ask..am kinda new here n i think some questions cant be asked
14:15:50 <jle`> any questions about haskell would be relevant :)
14:18:00 <EvanR> speakable and unspeakable in #haskell
14:18:40 <jle`> blacklor: irc is sort of divided into different channels by topic, so if you have any sort of topic you want to discuss there is usually a channel for it
14:18:51 <dmj`> blacklor: what don't you think can be asked about ?
14:19:26 <monochrom> Would you rather prefer busy polling?
14:19:32 <monochrom> Hello any questions?
14:19:36 <monochrom> Hello any questions?
14:19:42 <monochrom> (repeat every 3 seconds)
14:20:00 <tdammers> no nono
14:20:40 <tdammers> not every 3 seconds. start with a small delay, say 100 milliseconds, then increase by a randomized factor, up to some upper limit
14:21:30 <EvanR> the fact that polling and interrupt driven neither perfectly model IRC convos leads to a question
14:22:16 <monochrom> Polling doesn't model IRC convos at all. Polling models IRC spamming.
14:22:22 <Clint> EvanR: is it a question that can't be asked?
14:22:36 <EvanR> probably
14:23:54 <monochrom> The perfect model though is message passing. Tautologically.
14:24:23 * Rembane passes a message to monochrom 
14:25:55 <jgt> tdammers: I imagine this would cause a Thundering Herd effect. After long periods of no questions being asked, 1,000 people in this room would all say "HELLO ANY QUESTIONS?" in perfect unison
14:27:07 <Rembane> And then the servers die
14:27:28 <jle`> in an ideal world we would have a steady and predictable rate of questions, inversly proportional to the average length of question answer times
14:27:49 <jle`> so if it takes an average of T seconds to answer a question, the ideal situation would be to have the question asking rate be a poisson process with lambda parameter T
14:28:23 <EvanR> given infinite time, all questions will be repeated
14:28:35 <EvanR> actually, make that daily
14:29:07 <jle`> given that most languages so far have not lasted an infinite amount of time, we can presume haskell will not be around infinitely long
14:29:23 <tdammers> jgt: that's why you randomize the delay a little
14:29:44 <EvanR> haskell isn't immortal yet, like SPJ "languages that unfortunately can't be allowed to die"
14:30:07 <jle`> so far we have observed no infinite-age programming languages
14:30:27 <EvanR> if you throw a haskeller with a computer into a black hole
14:30:55 <hpc> if you think about it, we haven't observed any finite-age programming languages either :P
14:31:57 <jle`> clearly you haven't seen my folder of dead end programming languages i've tried to write :'(
14:32:10 <hpc> they're not dead if you still have the folder
14:32:16 <hpc> you never know when you might go back to it
14:32:56 <jgt> if a programming language falls in a folder does it make a sound
14:33:24 <jgt> that joke would have been better if I wrote "fails"
14:34:44 <jle`> if a compiler pipes an error to /dev/null, does it even indicate a bug in the program
14:35:08 <hpc> i learned programming from bob ross
14:35:14 <hpc> there are no bugs, only happy accidents
14:35:49 <int-e> hpc: those would be when the program does what you want it to do?
14:36:20 <hpc> oh no, that's worst case scenario
14:36:31 <hpc> in that case the program has a fatal problem but you haven't found it yet
14:36:34 <jumper149> How would I best define a Matrix data type while only using base? 
14:37:14 <jle`> https://impurepics.com/quiz/
14:37:27 <jle`> jumper149: it depends on what sort of operations you are planning on doing with it
14:37:36 <jle`> accesses, modifications, streaming, etc.
14:37:44 <jumper149> solving a linear equation system
14:39:05 <jgt> jle`: I'm a traversable
14:39:37 <jgt> jle`: but I think I'm only that because whoever devised this quiz is too kind to call me a charlatan
14:39:43 <jle`> jumper149: ah so you want random accesses and stuff
14:39:52 <jle`> jumper149: unfortunately you aren't really going to find anything suitable in base
14:39:57 <jumper149> jle`: sounds about right
14:40:04 <jle`> well, unless you have a fixed size of elements
14:40:13 <jle`> is your matrix sized known and fixed?
14:40:36 <jumper149> n times n , n elem N?
14:40:42 <jle`> unless, you are willing to extend your search to the standard libraries that are included with ghc, in which case i can recommend vector or array
14:40:59 <jle`> jumper149: i mean, if you're only ever going to solve 3x3 matrices, or 4x4 matrices, but never or more than one size
14:41:17 <jumper149> Nay, I have used vector before
14:41:25 <jumper149> What is the main difference to array?
14:41:53 <jle`> ah okay. vector and array aren't in base, but they're pretty standard libraries
14:42:04 <jle`> in that every installation of haskell can be expected to have access to it
14:42:27 <jle`> jumper149: array's api is a little more bare-bones than vector, so it can be harder to write clearly
14:42:49 <jle`> but array has built-in support for "2d" arrays, whereas for vector you either have to use nested vectors or manual flattening
14:43:39 <jumper149> Then I will probably go with Vector since clarity is number one priority. I'm just writing stuff to learn right now anyways.
14:44:19 <EvanR> basically a vector of length 16 is how graphics libs all implement a 4x4 matrix
14:45:09 <jle`> alternatively you can use Map (Int, Int) from containers for sparse vectors
14:45:13 <jle`> *sparse matrices
14:45:28 <EvanR> which is completely silly give that RAM is 2-dimensional
14:46:34 <jumper149> EvanR: Are you trying to tell me that I should implement a matrix as a single vector or nested vectors??!
14:51:00 <EvanR> i was joking about 2 dimensional RAM. I do think a vector of length 16 is the best way
14:51:18 <EvanR> you will of course have software on top of that to make it look like a 4x4
14:51:39 <jellostahps> quick question. Fib :: Integre -> Integer explicitly states a functions type, but
14:52:28 <jellostahps> fib(n,m) = (n+1,m+m) without any '::' declaration, can be extended to many types depending on how its use?
14:52:46 <hpc> it still has a single type, but it gets inferred
14:52:47 <jle`> you can check in ghci, at least
14:52:56 <jle`> :t \(n,m) -> (n+1,m+m)
14:52:58 <lambdabot> (Num a, Num b) => (a, b) -> (a, b)
14:52:59 <jellostahps> yeah its just a bunch of variables in type
14:53:09 <jumper149> jellostahps: You can use type variables (lower case words) in the type declaration
14:53:13 <jellostahps> but variables can be replaced with any type?
14:53:16 <jle`> it is a polymorphic type, and a and b can be instantiated into many different possible types
14:53:21 <jle`> yeah, as long as they are instances of Num
14:53:31 <hpc> in this case at least
14:53:35 <jellostahps> so yes to my q then
14:53:41 <hpc> there are other constraints besides Num
14:53:42 <hpc> :t id
14:53:43 <lambdabot> a -> a
14:53:49 <hpc> and sometimes there's no constraint at all
14:54:01 <jellostahps> ok
14:54:08 <EvanR> fordModelT :: forall color . (color ~ Black) => Car color
14:54:09 <jle`> jellostahps: it has a single type, but that single type cna be instantiated as many different types, yes
14:54:33 <jellostahps> ok, it was confusing, since it was the first time i saw an expression without  afunction definition
14:54:36 <jellostahps> now i get it
14:57:32 <jumper149> Is it possible to bring integers to the type level? I basically want only right sized vectors to pass type checking.
14:58:31 <EvanR> there's a library vector-sized
14:58:40 <jle`> we have nat's, and you can use vector-sized, yeah
14:58:42 <EvanR> it seems to do that legwork already
14:59:11 <jle`> vector-sized would be mostly standard haskell to use, as long as you don't ever do anything like have lengths that aren't known until runtime
15:00:07 <jle`> and even then the library has a lot of tools to make that as easy as possible
15:05:24 <jgt> what's one part of a record called? A row?
15:06:23 <jgt> a field?
15:06:24 <dmj`> field
15:06:28 <jgt> ah, ok. Thanks.
15:16:40 <jellostahps> I have a function type Num b => (b,b) -> (b,b)  ...... Could I have an input/output such as (String, Int) -> (Char, Float)?
15:16:53 <jellostahps> oh wait, sorry they have to be Num class
15:17:00 <jellostahps> Can I have 4 different Num Types
15:17:04 <jle`> yes, but also the two things of the tuples have to be the same
15:17:06 <jle`> since they are all 'b'
15:17:26 <jle`> so in the case of Num b => (b,b) -> (b,b), you have to pick a single instantiation for all the b's
15:17:38 <jle`> so (Int, Int) -> (Int, Int), but not (Int, Double) -> (Int, Double)
15:18:06 <jellostahps> ookay i was told otherwise
15:18:24 <jellostahps> by an insstructor who seems to be winging it
15:18:26 <hpc> you could instantiate the type (a, b) -> (c, d) as (String, Int) -> (Char, Float)
15:18:41 <hpc> but once you pick a... well, value for b
15:18:49 <hpc> you can't be inconsistent about it
15:19:00 <jle`> yeah, that's the 'point' of having variable names here, it allows us to constrain which ones have to be the same
15:19:02 <jle`> in a clean way
15:24:23 <EvanR> the idea that forall a . (stuff with a in it) is really a kind of lambda waiting for a to be substituted in the body... is really where haskell's type system started to click for me
15:26:34 <EvanR> a better name than lambda here would be a binding tree, polymorphic types and lambdas are both binding trees
15:36:46 <dmj`> jle`: which typeclass are you ?
15:37:01 <int-e> EvanR: "lambda term" is standard terminology though
15:37:38 <jle`> dmj`: i got Traversable
15:37:43 <int-e> EvanR: in contrast I've never even heard about a "binding tree" (apparently it's an actual plant though :) ) so it's confusing.
15:37:47 <jle`> you?
15:37:52 <dmj`> jle`: me too :) 
15:37:58 <dmj`> jle`: great minds mapM_ alike I guess
15:38:01 <jle`> ^5
15:38:03 <EvanR> try abstract binding tree
15:38:38 <EvanR> lambda sounds like "function" to me, but Pi, Sigma, Forall, and whatever else aren't necessarily functions
15:38:51 <int-e> mm
15:38:58 <EvanR> or letrec, or anything that introduces variables
15:39:25 <jle`> 'abstractions' maybe
15:40:45 <EvanR> abstractions might be accepted, but you have to admit... "abstraction" covers a huge zone of philosophical real estate
15:41:46 <int-e> EvanR: Hrm. Is this compiler writer slang?
15:42:10 <EvanR> it's chapter 0 in harper's textbook... uh... Practical Foundation of Programming Languages
15:42:55 <int-e> But okay it's standard terminology in some context... I wasn't aware. Sorry.
15:44:49 <EvanR> he may have just made it up, but i'm glad he didn't call it a lambda heh
15:45:11 <int-e> EvanR: the operative word was "term", not "lambda".
15:45:45 <EvanR> yeah, usually you have 1 kind of lambda term in a language right
15:46:13 <int-e> "lambda" just makes it somewhat more specific (indicating that there are abstractions). I don't know of a concise way to distinguish between the flavours of lambda calculi (i.e. whether there are type abstractions or not) on that level.
15:48:25 <jle`> lambda calculods
15:48:45 <jle`> * calculode
15:49:30 * hackage net-mqtt 0.5.1.0 - An MQTT Protocol Implementation.  https://hackage.haskell.org/package/net-mqtt-0.5.1.0 (dustin)
15:56:03 <jgt> I wrote a short article explaining how to implement a nonce-based content security policy in Yesod. Is anyone interested in proofreading? https://jezenthomas.com/implementing-csp-in-yesod/
15:58:21 <mycroftiv> im sleepless and have little domain experience but id spell out content security policy in yesod in the title and url because 'communicating sequential processes' is what i will always think of first
16:00:36 <jellostahps> https://pastebin.com/X0vpy5Fu   ... (1) Line 8, how does 'fst' know to reference the tuple of line 6 (2) Line 9, how come fibstep isn't provided input parameters and this code still works?
16:01:38 <dsal> jellostahps: what's the type of pfib?
16:01:57 <jgt> jellostahps: https://wiki.haskell.org/Eta_conversion
16:02:44 <jellostahps> dsal: :t pfib says not in scope
16:03:33 <dsal> jellostahps: No, it's only in scope in that function.  But you should be able to see by looking at it.  :)    pfib :: Integer -> (Integer, Integer) -> Integer
16:03:41 <jgt> jellostahps: you can probably figure out the type of pfib by looking at line 6
16:03:51 <dsal> Anyway, it's η-reduced, as mentioned.
16:04:21 <jellostahps> yeah ok
16:04:22 <dsal> You can specify the type in that function.  I do that sometimes when I get confused.
16:05:06 <jellostahps> but a 'fst' without parameters. Is this syntax specific?
16:05:39 <dsal> What do you meant without parameters?  It has a parameter.
16:05:58 <jellostahps> how is it reaching that parameter
16:06:11 <jellostahps> its all blank spaces after 'fst'
16:06:30 <jgt> jellostahps: did you read the extremely short article I linked you to?
16:06:30 <dsal> >   let  f = fst  in        f (0,1)
16:06:32 <lambdabot>  0
16:06:43 <jellostahps> i did, not familiar with n-conversion
16:07:00 <dsal> It's η, not n.  :)
16:07:08 <jgt> you don't even need to know what it's called to grok what it looks like and how it works
16:07:22 <jle`> jgt: fst is a function
16:07:34 <jle`> it's saying that (pfib 0) is equivalent to fst
16:07:41 <jle`> so every time you see `pfib 0`, you can replace it with fst
16:08:04 <jle`> er sory, that was for jellostahps 
16:08:11 <jgt> :)
16:08:12 <jle`> jellostahps: remember that in haskell, you can return functions
16:08:19 <jle`> so pfib 0 is fst
16:08:50 <jle`> @let myFunc 0 = fst; myFunc n = snd
16:08:51 <lambdabot>  Defined.
16:09:02 <jle`> > (myFunc 0) (1,2)
16:09:04 <lambdabot>  1
16:09:08 <jle`> > (fst)   (1,2)
16:09:09 <jellostahps> so u can use the names pfib and fst after that declaration?
16:09:10 <lambdabot>  1
16:09:21 <jellostahps> use the names interchangably*
16:09:32 <jle`> you can use `pfib 0` and fst interchangeably
16:09:43 <jle`> that's what it means to say `pfib 0 = fst`
16:09:47 <jle`> pfib 0 *is* fst
16:10:08 <jellostahps> so that line is a declaration more than an expression?
16:10:23 <jellostahps> definition, more than an expression *
16:10:31 <jle`> yes
16:10:34 <jle`> in fact, all of your lines are definitions :)
16:10:44 <jle`> except for line 2 and line 7
16:11:16 <jle`> and i suppose line 3 too depending on how you interpret it
16:11:41 <jellostahps> but then... is pfib overloading? it has 2 arguments before the 'where' and then '1' after
16:11:57 <jle`> pfib is a function
16:12:00 <jle`> if you give it 0, you get fst
16:12:14 <jle`> if you give it any other number, you get pfib (r-1) . fibstep
16:12:28 <jle`> another example of a function would be, say:
16:12:31 <jle`> myFunc 0 = "hi"
16:12:34 <jle`> myFunc n = "bye"
16:12:54 <jle`> myFunc is a function that takes a number and returns a string. if you give it 0, it is "hi".  if you give it any other number, it is "bye"
16:12:58 <jle`> so myFunc 0 *is* "hi"
16:13:30 * hackage serverless-haskell 0.8.11 - Deploying Haskell code onto AWS Lambda using Serverless  https://hackage.haskell.org/package/serverless-haskell-0.8.11 (AlexeyKotlyarov)
16:13:47 <jellostahps> okay i understand up to there now, but the 'otherwise' statement has 2 parameters. Why isn't the definition of pfib written as pfib 0 _ or pfib r _?
16:14:18 <dsal> jellostahps: This is why I suggested adding the type definition above pfib.  I think it's confusing you.
16:14:37 <jle`> jellostahps: try re-writingthe otherwise branch as (pfib n) (0,1)
16:14:49 <jle`> then you can see that you're trying to return something for (pfib n)
16:15:25 <jle`> basically, | otherwise = (????) (0,1)
16:15:31 <jle`> and you're trying to figure out what to put in that ???? part
16:15:36 <jle`> if n = 0, then put fst
16:15:36 <jellostahps> jle: that makes sense now
16:15:52 <jle`> otherwise, but (pfib (n-1) . fibstep)
16:15:52 <jellostahps> but damn that can get pretty confusing
16:16:08 <jle`> it helps if you start to shift your focus to 'functions' instead of 'applications'
16:16:25 <jle`> in a lot of languages, functions only make sense in terms of what values you apply them to, and how they are applied
16:16:34 <jle`> but in haskell, we like to think of the functions themselves as the things we are building
16:16:58 <jle`> so applying it to (0,1) isn't the "important" part; rather, it's *what* we want to apply to (0,1)
16:17:37 <jellostahps> I can try, but that in itself is quite the task. Functions have so many properties of their own, its hard to remember all that stuff from so many years ago
16:18:13 <jle`> indeed, it can be tricky at first. but my point is that it is something that will take time, but also something that will learn eventually with just more exposure :)
16:18:50 <dsal> What do you mean "functions have so many properties"?  They take a thing and return a thing (possibly the same kind, possibly a different kind).
16:19:01 <jellostahps> yeah im glad i have u guys here to explain this more complicated stuff. IDK how I would have found an answer to that in my textbook or notes without the correct terms, etc.
16:19:28 <jle`> for what it's worth, this isn't necessarily the cleanest way to write pfib
16:19:34 <jle`> you could also write
16:19:40 <jle`>   pfib 0 (x,_) = x
16:19:59 <jle`>   pfib r xy = pfib (r - 1) (fibstep xy)
16:20:08 <jle`> honestly this feels a lot more clean and readable to me
16:20:22 <jle`> but maybe the point of the course was to 'force' you to look at things in a new way
16:20:33 <jellostahps> not cleanest in terms of unecessarily ambiguous, or clean in terms of compactness?
16:20:36 <dsal> Point freedom isn't free.
16:20:50 <jle`> cleanest in terms of readability
16:20:56 <jle`> so i suppose i was being redundant, heh
16:21:10 <jle`> in both cases i wouldn't consider them ambiguous
16:21:29 <jle`> but this one at least it's more clear where the information is traveling
16:21:38 <jellostahps> very true. That was presented in lecture#1 with zero explanation to a group who's first introduction to functional programming was this course
16:21:38 <dmwit> pfib r xy = iterate fibstep xy !! r
16:22:00 <jle`> yes that's the even better way ... no explicit recursion
16:22:01 <dmwit> Uh, with maybe a fst tossed on the front.
16:22:19 <jle`> explicit recursion is something to be avoided whenever possible. i don't know why intro to fp classes are so obsessed with it
16:23:10 <jellostahps> then we get into more prelude functions which I rather stay away
16:23:21 <jellostahps> for now at least
16:27:57 <EvanR> if you don't know how to do explicit recursion, your workday just got a lot worse
16:28:15 <EvanR> the recursion scheme doesn't always present itself
16:29:16 <jle`> you should know how, but it sounds more like a late-beginner technique than a "day 1" sort of thing
16:30:31 * hackage haskseg 0.1.0.2 - Simple unsupervised segmentation model  https://hackage.haskell.org/package/haskseg-0.1.0.2 (TomLippincott)
16:53:33 <no-n> jle`, why is explicit recursion to be avoided?
16:56:16 <hpc> the same reason for functions in general
16:56:22 <jle`> it's like GOTO in imperative programming
16:56:34 <jle`> the reason why you'd use a for loop or a while loop instead of a GOTO
16:56:41 <hpc> when solving problems with a recursive element to them, a lot of things tend to repeat themselves
16:57:01 <hpc> but instead of repeating yourself in the code, you can write that way of doing things as another function
16:57:03 <jle`> explicit recursion is a huuuuuuge opportunity to introduce bugs, and bugs of the nastiest sort
16:57:15 <hpc> like using map instead of looping over a list
16:57:31 <jle`> and yeah, using established higher-order patterns like map, foldr, etc. not only reduce the space for potential bugs, but also improves readability
16:58:23 <jle`> because it can convey intent and control flow better than having to jump your eyes around to what is recursing when
16:59:21 <jle`> writing map (+1) xs is a lto more readable than increment [] = []; increment (x:xs) = (x+1) : increment xs, and also there is a lot less rooms for potential bugs
17:00:32 <hpc> getting even more interesting with it, you can make that yet another parameter
17:00:41 <hpc> because map is itself a function
17:02:31 <quiet_laika[m]> can anyone help me figure out why running `cabal new-update` (in a nix shell) produces `newParallelJobControl: not a sensible number of jobs: 0`?
17:05:15 <quiet_laika[m]> where would that job control number be coming from?
17:05:56 <quiet_laika[m]> in ~/.cabal/config, i have `jobs: $ncpus`
17:06:06 <quiet_laika[m]> i also tried setting it to `jobs: 4` but no dice
17:34:00 <ANJ> wats up?
17:34:13 <jellostahps> is there a compiler command to look at information of data types such as Bool, similar to command :t?
17:34:42 <jellostahps> to show their consstructors
17:35:35 <nopenope> hi
17:36:19 <quiet_laika[m]> jellostahps: `:i` will show you general information about a term or type 
17:36:29 <nopenope> :i
17:36:43 <quiet_laika[m]> for `Bool`, it shows constructors, but im not sure how much detail it will show for more complicated types?
17:37:08 <jellostahps> all I got was  data Bool       -- Defined at <interactive>:30:1
17:37:21 <jellostahps> no constructors shown
17:38:12 <quiet_laika[m]> defined at interactive? did you define your own `Bool`?
17:38:27 <quiet_laika[m]> (i believe) that indicates it was defined within ghci
17:39:43 <jellostahps> forgot to save and :r, ty thats all i neded
17:47:14 <Guest_28> hi 
17:47:23 <Guest_28> this channels has rules?
17:47:43 <Guest_28> ok, found the link already
17:48:34 <Cale> Guest_28: Feel free to ask any questions you might have about Haskell
17:56:17 <jellostahps> In a source file you could do (&&) True _
17:56:31 <jellostahps> But I cant seem to use _ in the compiler, is there special syntax for _ in the compiler
17:57:19 <jellostahps> ghci
18:04:01 <nyc> What's a less messy way to memoize/tie-the-knot for a 2D recurrency than e.g. (Lanczos approximation let { n = 7 ; a = array ((1,1),(n,n)) [((i,j),if (i,j) == (1,1) || (i,j) == (2,2) then 1 else if i > 2 && j == 1 then negate (a ! (i-2,1)) else if i == j && i > 1 then 2 * (a ! (i-1,j-1)) else if i > j && j > 1 then 2 * (a ! (i-1,j-1)) - (a ! (i-2,j-1)) else 0) | i <- [1..n], j <- [1..n]] } in mapM_ print $ groupBy (\(u,_) (v,_) -> fst u == fst v) [z | z <- asso
18:09:10 <dmwit> jellostahps: I challenge your claim that in a source file you can do (&&) True _.
18:09:33 <dmwit> nyc: Perhaps you could use an online pastebin and send us a link.
18:09:43 <dmwit> It's hard to read inline code like that, and also it got cut off partway through.
18:10:15 * nyc actually wrote it at the ghci prompt in real-life usage.
18:10:25 <jellostahps> https://pastebin.com/eNk1YPHG
18:11:32 <quiet_laika[m]> thats whats expected when you use a type hole
18:12:00 <quiet_laika[m]> i think you want `(&&) True undefined`
18:12:29 <quiet_laika[m]> err
18:12:35 <quiet_laika[m]> maybe `(||)`
18:12:50 <quiet_laika[m]> im unclear what youre trying to do, but that error message represents GHC trying to tell you what can fill that hole
18:13:58 <jellostahps> well the way Prelude defined (&&) is with those type holes
18:14:20 <quiet_laika[m]> oh
18:14:25 <jellostahps> and (&&) False _ will always be False. I am wondering if there is a parameter for _ in ghci
18:14:32 <quiet_laika[m]> `_` has a different meaning when its used int pattern matching
18:14:47 <quiet_laika[m]> `_` just means, match on something but ignore it
18:14:52 <quiet_laika[m]> (in a pattern)
18:15:00 <quiet_laika[m]> in an expression, it represents a typed hole
18:15:12 <quiet_laika[m]> https://wiki.haskell.org/GHC/Typed_holes
18:15:14 <jellostahps> yes, and ghci and compute expressions
18:15:22 <jellostahps> yes and ghci can compute expressions
18:15:58 <jellostahps> ill give that a read
18:16:20 <quiet_laika[m]> when you say `False && _ = False`, the _ means something different from when you do `(&&) False _`
18:16:22 <quiet_laika[m]> oh
18:16:27 <quiet_laika[m]> :eyes
18:16:38 <quiet_laika[m]>  * 👀
18:30:14 <nyc> Mostly a coding style question since I'm rusty: n :: Integer = 7
18:30:14 <nyc> a :: Array (Integer, Integer) Integer
18:30:14 <nyc>    = array ((1,1),(n,n)) [((i, j), c (i, j)) | i <- [1..n], j <- [1..n]]
18:30:14 <nyc> c (i :: Integer, j :: Integer)
18:30:14 <nyc>          | (i, j) == (1, 1) || (i, j) == (2, 2)
18:30:14 <nyc>          = 1
18:30:14 <nyc>          | i > 2 && j == 1
18:30:15 <nyc>          = negate (a ! (i-2, 1))
18:30:15 <nyc>          | i == j && i > 1
18:30:16 <nyc>          = 2 * (a ! (i-1, j-1))
18:30:16 <nyc>          | i > j && j > 1
18:30:17 <nyc>          = 2 * (a ! (i-1, j-1)) - (a ! (i-2, j-1))
18:30:37 <nyc> Oh dear, I was supposed to have copied the pastebin URL.
18:30:52 <nyc> https://pastebin.com/M4uVhfya
18:32:02 <nyc> Super sorry about the flood.
18:36:30 <dmwit> Looks basically fine to me. Though I'd lift all the pattern type signatures up to top-level signatures.
18:36:40 <dmwit> i.e. `n :: Integer = 7` -> `n :: Integer; n = 7`.
18:37:46 <nyc> That's probably a leftover of me not having written this stuff in a few years and mixing SML style into things.
18:39:05 <dmwit> You might get a negligible speed boost from using Int instead of Integer for the indices. I think it makes sense to leave the values as Integer so you don't have to bother thinking about overflow, but the indices are no bigger than 7 so.
18:39:59 <nyc> It came from an interactive session where I just entered n as a sort of input.
18:40:21 <dmwit> In the `i == j && i > 1` branch, I think the `&& i > 1` condition is redundant?
18:42:07 <nyc> It probably is.
18:43:34 <dmwit> nyc: You might consider writing c this way: https://gist.github.com/dmwit/c5f7de411db9295e8628957494e93b96
18:43:41 <dmwit> But it's a stylistic choice.
19:04:55 * nyc was out of touch with the latest developments in Haskell a significant number of years ago. Arrows, lenses, type families, generalized data types, template haskell, etc. are all things I've lost track of.
19:08:49 <dansho> is classy-prelude still a thing?
19:13:36 <jellostahps> I have a lot of confusions about how the second parameter is traced on line 12 https://pastebin.com/7DeHHT9N
19:14:14 <dsal> traced?
19:14:26 <jellostahps> From line 12 Are myiterates parameters going to be n fibstep and (0,1)?
19:15:14 <dsal> I don't understand the types.  What's SS and FF?
19:15:22 <jellostahps> oh sorry forgot to include that
19:15:23 <jellostahps> brb
19:15:57 <jellostahps> https://pastebin.com/6U5NypHV
19:16:24 <dsal> Oh, SF is Maybe.  :)
19:17:15 <jellostahps> yeah im super confused on that otherwise = :(
19:17:35 <dsal> I don't quite understand what's confusing.
19:18:08 <jellostahps> this part: ((fst.myiterate n fibstep) (0,1))
19:18:26 <dsal> So, first we need to figure out what myiterate is.
19:18:51 <jellostahps> takes in an integer and a tuple from fibstep, as well as the tuple (0,1). Tjat is my understanding?
19:19:10 <dsal> Looks like .     Integer -> ((Integer, Integer) -> (Integer, Integer)) -> Integer -> Integer  ?
19:19:30 <dsal> er, no, I messed that up.
19:19:34 <dsal> a is  (Integer, Integer)
19:20:17 <jellostahps> if u r asking me, idk
19:20:23 <dsal> OK.  yeah.  So     myiterate has to take an int and then a function that converts an (I,I) to another (I,I) and then an (I,I) and returns an (I,I).  Then you call fst on that.
19:20:53 <jellostahps> i follow, except whats the second last (i,i) going to be
19:21:21 <jellostahps> before the return (i,i)
19:21:45 <dsal> Well, it's (0,1) first, but then myiterate recurses.
19:22:06 <dsal> So it's       fst (myiterate n fibstep (0,1))
19:22:54 <jellostahps> how is myiterate operating with its input
19:23:02 <jellostahps> what is line 9 doing
19:23:22 <dsal> Well, let's look at line 8 first.
19:23:46 <dsal> If you η-uh, expand it.  You get    myterate 0 f v = v
19:24:15 <jellostahps> aw idk what n's are yet, can u explain it in more laymans
19:24:23 <dsal> Then you can do the same for the next line .    myiterate n f v = myiterate (n - 1) f (f v)
19:25:11 <dsal> not n, η.  It's like basic algebra.           f a b c =  g a b c     is the same as    f a b = g a b   is the same as   f a = g a    is the same as f = g
19:25:35 <jellostahps> everyone keeps aying not n, n. but if i knew how to type n, i wouldnt type n
19:25:37 <dsal> myiterate 0 f    takes one more value and passes that value to id, which returns its input.
19:25:54 <dsal> Heh.  You're confusing me with n, if it makes you feel any better.  :)
19:26:30 <jellostahps> perhaps u could tell me how to type that greek letter here
19:26:48 <dsal> I don't know where here is.  But it's not important.  You could spell it in english 'eta'
19:27:28 <jellostahps> η. <-- is ther an easier way to type this then copy-paste
19:27:43 <dsal> The important part is understanding that every function takes one argument and returns one value.  Currying gives you the illusion of multiple parameters.  Once you get past that, you can start dropping them.  People do fancy things to make code point free that aren't necessarily adding clarity.  Sometimes it helps.  Often it makes things confusing.
19:27:57 <dsal> Depends on your input mechanism.  It's super easy to type in emacs.  :)
19:28:56 <Cale> jellostahps: There's a way to set a key to switch keyboard layouts while held, I have my left windows key remapped to switch to a Greek keyboard layout.
19:28:59 <jellostahps> aorry, i struggle to see how that may be relevant to the understanding of my posted code, if it was meant to be relevant
19:29:16 <Cale> So Left Win + h = η
19:29:22 <jellostahps> ok thx
19:29:37 <jellostahps> okay so myiterate, still not sure how its working
19:29:38 <Cale> However, you could also just type "eta" if you're not being pretentious :D
19:29:47 <dsal> jellostahps: The η-reduction is relevant, but as I said, the actual spelling of η isn't that important.  This is why I suggested starting on line 8 and adding the missing parameter.
19:30:18 <jellostahps> is there any other way u could explain it, without mentioning eta-reduction?
19:30:28 <dsal> Yes.  Rewrite line 8 without 'id'
19:30:31 <dsal> ignore line 9
19:32:08 <dsal> The signature shows it's a "Integer -> (a -> a) -> a -> a" -- so name all the parameters and you'll end up with step one.
19:32:36 <quiet_laika[m]> anyone successfully using ghcide? im running into an issue with my cabal project: `ghcide: <command line>: cannot satisfy -package-id relude-0.5.0-IilVdiUKSDE6mRqTfZAX48`
19:32:37 <quiet_laika[m]> it looks like https://github.com/digital-asset/ghcide/issues/82, except i can run my build and repl commands as expected, so i can't get a figure on why ghcide is having issues
19:32:42 <jellostahps> wiki on eta states "\x -> abs x" .. what is the hypen?
19:32:48 <jellostahps> sorry i mean the backslash
19:32:53 <dsal> That's a lambda.
19:33:02 <jellostahps> :( : (
19:33:07 <dsal> Apparently it's too hard for some people to type λ so they use \ instead.  :)
19:33:10 <jellostahps> kill me now
19:33:33 <quiet_laika[m]> you dont like `\ ->`?
19:33:33 <jellostahps> to understand eta, i have to understand lambda.. ahh jeez
19:33:43 <quiet_laika[m]> do you prefer `lambda` from python? 😛
19:33:50 <dsal> I don't prefer much from python.
19:34:20 <quiet_laika[m]> i was taking to jello
19:34:21 <dsal> jellostahps: Well, lambda is just a function without a name.  Naming is hard, so they didn't.  They could've called it      checkOutMyAbs x = abs x      which is the same as    checkOutMyAbs = abs
19:34:27 <quiet_laika[m]> im personally in the ascii-lookalike fan club
19:34:29 <dsal> Oh.  He's welcome to prefer python.
19:34:52 <quiet_laika[m]> (i was just trying to point out that lambda is not unique to haskell, sorry for confusion)
19:35:10 <dsal> Yeah, I added ≫ and ⊕ functions to a program once.  They were nice, but not *that* nice.
19:35:14 <c_wraith> spelling it as \ might be unique to haskell
19:35:40 <c_wraith> (and languages directly haskell-derived)
19:35:45 <jellostahps> okay could u explain line 8 in terms of eta then, il try to understand
19:36:34 <dsal> jellostahps: I've been trying.
19:36:53 <jellostahps> sorry
19:37:09 <nyc> It's kind of a pain for me to type λ butI can do it when pressed.
19:37:09 <dsal>  jellostahps: The η-reduction is relevant, but as I said, the actual spelling of η isn't that important.  This is why I suggested starting on line 8 and adding the missing parameter.    and    The signature shows it's a "Integer -> (a -> a) -> a -> a" -- so name all the parameters and you'll end up with step one.
19:37:56 <jellostahps> is f in line 8 the missing parameter, aka all of "Integer -> (a -> a) -> a -> a"
19:38:37 <jellostahps> is f in line 8 the missing parameter, aka all of "(a -> a) -> a -> a"
19:39:10 <dsal> 'myiterate:: Integer -> (a -> a) -> a -> a'  says  myinteger takes an Integer (0) a function (f) and another value of type 'a' and returns a value of type 'a'
19:39:27 <dsal> You didn't name the final parameter there because of η-reduction, so make it less fancy and name it.
19:40:51 <jellostahps> name the last parameter?
19:41:03 <dsal> Yeah.  I think that'd help your understanding.
19:41:19 <jellostahps> okay, finalParam?
19:41:29 <dsal> If you like.  It doesn't matter what you name it.
19:41:36 <dsal> Right now, it's not there at all.  So add it there.
19:41:48 <jellostahps> okay,, but whats 'there'?
19:41:57 <jellostahps> the parameters of line 8?
19:41:58 <dsal> How many parameters does myterate want?
19:42:16 * dsal can't spell myiterate.  Should name it something easy like µ
19:42:38 <jellostahps> it wants 3, we have 2 in line 8, the 3rd is missing
19:42:45 <dsal> Yes.  Make it not be missing.
19:42:57 <iqubic> Mu is easy to type: μ
19:43:06 <iqubic> So is lambda: λ
19:43:08 <dsal> Yeah.  Now try typing myiterate
19:43:15 <jellostahps> instead of editing the code, i rather understand it as it is, or theres no point if i cant understand future similar code? or is changing it going to help me understand the original better?
19:43:49 <jellostahps> if I add a 3rd param, then idk what the right side of line 8 would change to
19:43:49 <dsal> jellostahps: I don't know exactly what will help you understand, but understanding things from different perspectives helps me, so that's what I'm doing.
19:43:57 <jellostahps> okay sure
19:44:09 <dsal> :t id
19:44:10 <lambdabot> a -> a
19:44:25 <jellostahps> i looked at that earlier, but cant understand it in this context
19:44:38 <dsal> Well, how might you implement id?
19:44:42 <jellostahps> is it saying all the parameters return exactly the same
19:45:07 <dsal> Well, it has one parameter and returns a value of the same type for any input.  There aren't many ways to do that.
19:45:07 <iqubic> jellostahps: How would you write the id function yourself?
19:45:10 <jellostahps> i wouldn't know how in any context tbh
19:45:22 <jellostahps> f(x) = f(x)
19:45:25 <jellostahps> on paper
19:45:44 <dsal> That doesn't look correct.
19:46:14 <dsal> That's infinite recursion.
19:46:15 <iqubic> No. That's not quite right on paper.
19:46:26 <jellostahps> wiki is a function that always returns the same value that was used as its argument.
19:46:31 <jellostahps> wiki : 'is a function that always returns the same value that was used as its argument.'
19:46:35 <jellostahps> so f(x) = x
19:46:46 <iqubic> That's right.
19:46:49 <dsal> Well, yeah.  So what does your line 8 do?
19:46:56 <nyc> The Lanczos approximation works by carrying out partial fractions on some nonsense.
19:47:23 <jellostahps> the function is myiterate. so it returns all 3 of its parameters as they are: 0 f lastParam?
19:47:44 <iqubic> In Haskell you could write that as "f x = x" and it would create a function 'f' with type signature 'a -> a'
19:48:00 <dsal> jellostahps: that's not what it was doing.
19:48:30 <jellostahps> whats 'it'? the function myiterate?
19:48:34 <iqubic> Can someone give a link to the code? I can't seem to find it.
19:48:37 <dsal> And you can't return three values, so conceptually, that's not a thing.  A function takes one value and returns one value.
19:48:45 <dsal> iqubic:  https://pastebin.com/6U5NypHV
19:49:07 <iqubic> Ah. I see.
19:49:30 <dsal> Attempting to understand line 15, which was blocked a little on line 9.  I figured understanding line 8 would be helpful here.
19:50:05 <iqubic> Understanding line 8 is important here.
19:50:05 <jellostahps> hmm... the return has to be a type a
19:50:17 <nyc> I think there's a partial fraction thing somewhere in the Numeric Prelude.
19:50:26 <jellostahps> so it returns a tuple?
19:50:37 <jellostahps> so id returns a tuple
19:50:49 <dsal> The return value of your function i sa
19:50:52 <dsal> is type 'a'
19:50:54 <iqubic> What is the input to id on line 8?
19:51:29 <iqubic> 'myiterate 0 f x = id x' is the same thing, but might be easier to understand.
19:51:54 <dsal> Oh yeah, that's the logical first step of expansion.
19:52:27 <jellostahps> ooh so line 8 returns x then. which is 'a' the last parameter tht myiterate uses
19:52:36 <iqubic> Correct.
19:53:01 <dsal> Yes.   And the reason that's important here is that you can't have different shaped heads on functions for some reason, so you  also have to supply that parameter to line 9.
19:53:06 <jellostahps> so from line 15, in its first iteration, if n-0, then myiterate line 8 would return (0,1)?
19:53:18 <jellostahps> if n=0
19:53:23 <iqubic> correct again.
19:53:49 <jellostahps> idk what u mean by different shaped heads
19:53:52 <dansho> i have module Mymod in src/mymod.hs, how can i tell cabal to find it? do i need to capitalize the filename?
19:54:07 <dsal> jellostahps: If you have 0 f whatever on one myiterate definition, you have to have it on all of them.
19:54:17 <dsal> So the right side of the = is no longer waiting for the 'a' value.
19:54:57 <jellostahps> myiterate has 2 definitions right?
19:55:20 <dsal> Well, it has two heads matching two patterns.  I don't know that I'd call that two definitions.
19:55:28 <dsal> I'm bad at terminology, though.
19:56:10 <jellostahps> is it the 'id' that allows u to just drop a param like that on line 8, or can u do it in general?
19:57:11 <jellostahps> not 'drop' i guess, but not explicitly state
19:57:19 <jellostahps> state/type
19:57:25 <dsal> You can use id anywhere you want a function to return its input.  It's a slightly weird thing here, just added so you can η-reduce for the other case.
19:58:29 <novum> I am new to haskell. When I make a file like Foo.hs then how do I import that if it has a module Foo at top level inside of Bar.hs?
19:58:36 <jellostahps> okay i think im getting the hag of this. In this very same context, if the last param of myIterate was of type b, but the return type was type a, then this syntax of line 8 wouldnt work right?
19:58:37 <dsal> id and const are basically hacky adaptor functions you shove into things that want functions for a case you don't care about.  :)   id always returns its input and (const x) ignores the next parameter and always returns x.
19:58:57 <dsal> jellostahps: Right.  You could do something with const, but id wouldn't compile.
19:59:02 <novum> I think I am getting errors using Test, and should I be using stack to install packages?
19:59:14 <dsal> novum: I use stack in general.  It builds a useful layout.
19:59:50 <dsal> I wouldn't 'use stack to install packages' as much as declare my dependencies and let stack grab them in the local project.  (your question sounded like you were talking about doing it globally)
20:00:36 <dsal> jellostahps: So, do you understand line 9?
20:00:44 <jellostahps> now before i get to that
20:00:58 <heatsink> novum:  `import Foo` imports the module from Foo.hs
20:01:00 <mike11> lambdabot (((a->Bool)->Bool)->Bool)->(a->Bool)
20:01:34 <novum> heatsink, the file is named 01_Foo.hs and I can't import it because apparently it is a syntax error, which I find rather ridiculous
20:01:54 <jellostahps> so hypothetically lets assume myiterate has type int -> (int -> int) -> int -> int. Then would this work for line 8: myiterate o f = double
20:01:55 <heatsink> For a file to be importable, the filename has to be a valid module name
20:01:58 <dsal> novum: That's an odd name for a module.
20:01:58 <novum> I tried renaming the file too but I think it still broke
20:02:13 <mike11> @djinn (((a->Bool)->Bool)->Bool)->(a->Bool)
20:02:13 <lambdabot> f _ _ = False
20:02:14 <novum> it's what I want. it's not very conforming and a little too rigid imo
20:02:34 <dsal> novum: fighting the platform never leads to happiness.
20:02:42 <mike11> @djinn (((a->b)->b)->b)->(a->b)
20:02:43 <lambdabot> f a b = a (\ c -> c b)
20:02:45 <novum> not fighting just complaining
20:03:05 <dsal> jellostahps: what's 'double' ?
20:03:06 <novum> I know you don't mind. I do.
20:03:46 <jellostahps> assume its a prelude function  Int-> Int that doubles an Int's value
20:03:59 <jellostahps> i saw it earlier, thought it was a prelude.. sry
20:04:12 <dsal> Oh.  Yeah, sure.  You can ask for the type of a partially applied function and fit anything that matches.
20:04:19 <dsal> :t (1 +)
20:04:21 <lambdabot> Num a => a -> a
20:04:28 <novum> the reason I want to do it is because they are exercises not modules. but I want to test them.
20:04:45 <novum> I want /\d\{2}_/ prefix
20:05:52 <dsal> novum: You've made that clear.  I'm sure some languages and build systems let you do things like that.  Many don't.  I'm not sure it's worth the effort to fight things that work.
20:06:17 <novum> am I fighting?
20:06:24 * novum lays down sword if so
20:07:21 <heatsink> novum, Do the filenames matter for how your code works?  For example, are you sorting the filenames to decide what order to run tests?
20:07:33 <dsal> Exercise01 is a valid module name.
20:07:34 <novum> no
20:07:55 <novum> Ex01_HelloWorld.hs will maybe have to do
20:08:15 <novum> I want prefixes to be logically sort-able with ranger and such
20:08:22 <novum> I sometimes hope on ranger
20:08:29 <novum> and like the ls to be sorted
20:08:34 <heatsink> What is ranger?
20:09:12 <novum> python cli file browser kinda meh kinda nice
20:09:23 <MarcelineVQ> it's nice :>
20:09:26 <jellostahps> dsal: disregard the earlier quesiton. So for line #9, we are calculating myiterate n f = myiterate (n-1) f lastParam. f lastParam?
20:09:39 <jellostahps> https://pastebin.com/6U5NypHV
20:10:14 <dsal> jellostahps: No, it's not doing that...
20:10:21 <jellostahps> :(
20:10:44 <dsal> The operator precedence can be mildly confusing.
20:10:45 <novum> [offtopic] best thing about ranger is :bulkrename  (which also happens to be implemented as a script but meh) [/offtopic]
20:11:06 <dsal> I just use emacs for that...
20:11:13 <dansho> can cabal handle source files with lowercase names or???
20:11:27 <jellostahps> dsal: what about: myiterate n f = myiterate (n-1) . f lastParam
20:11:41 <jellostahps> wait i meant
20:11:46 <jellostahps> myiterate n f = myiterate (n-1) f. f lastParam
20:12:02 <dsal> jellostahps: Yes... almost exactly right, except the thing is mildly confusing in terms of how the operator precedence works.
20:12:22 <jellostahps> what am i missing?
20:12:34 <heatsink> dansho: Maybe, since it needs to work on case-insensitive filesystems
20:12:40 <dsal> jellostahps: It's logically right, that just wouldn't compile.
20:12:59 <dsal> (myiterate (n-1) f) (f lastParam)
20:14:56 <jellostahps> okay so i learned (1) n-reduction means u don't have to show the last parameter of a function, but then all function expressions can't show that 3rd parameter (its implicitly implied that its still there). (2) if u remove the last parameter like that, it is also implicitly implied  on the rights side of the expression and u dont have to show it there either
20:15:11 <jellostahps> last = 3rd
20:15:23 <dsal> Yeah, that's not a bad way to think about it.
20:16:02 <dsal> The other way to think about it is that all functions take one parameter and return one value.
20:16:32 <novum> I am a little confused. I have a file: Leap.hs. It has no main in it. But I did `stack ghc Leap` then when I do `stack ghci` then `import Leap` I get "no module"
20:16:38 <jellostahps> the help was much appreciated :) thx. dsal iqubic
20:16:39 <dsal> There's some syntax magic that makes it a little easier to have what looks like a function with multiple parameters, but you can "partially apply" them and stop at any point.
20:16:56 <novum> I decided to get rid of prefixes despite losing the ordering
20:16:59 <dsal> novum: :r Leap.hs
20:17:18 <heatsink> novum, does Leap.hs begin with "module Leap"?
20:17:19 <novum> but in something like Main.hs I would use import Leap, then I could use Leap.someFunction?
20:17:23 <novum> yes
20:17:32 <dsal> Or make sure you have Leap.hs in your srcs, which should automatically be brought in by stack ghci
20:17:54 <novum> line 1: module Leap (someFunction) where
20:17:54 <dsal> novum: It'd probably just be someFunctions -- does that exist?
20:18:03 <novum> of course
20:18:15 <dsal> Well if it exists, then your stuff is working.
20:18:26 <novum> here is Leap.hs http://ix.io/1WjM
20:18:39 <novum> let me try to write a main and import it
20:19:21 <heatsink> Leap.hs looks fine.  I'm guessing the directories aren't configured correctly in stack.  But I haven't used stack much.
20:21:22 <heatsink> novum: where is Leap.hs relative to the current directory when you run stack ghci?
20:21:36 <novum> this is Main.hs http://ix.io/1WjO and running stack ghc Main then ./Main works so... I guess it's just ghci
20:22:18 <dsal> "stack ghci" should load your modules. Is it not?
20:23:24 <heatsink> novum: While it's better to debug the configuration that stack is using, there is a workaround in ghci
20:23:52 <dansho> why is Prelude still being used when i set NoImplicitPrelude? https://paste.ee/p/BWWYZ
20:23:58 <heatsink> In ghci's interactive mode, you can tell it to search directory 'src' by typing :set -i src 
20:24:29 <heatsink> Whatever directory Leap is in, you could add that directory and then try to import
20:25:33 <heatsink> dansho: other-extensions says that your code may use the extension.  It doesn't activate the extension
20:25:48 <heatsink> You still need to add {-# LANGUAGE NoImplicitPrelude #-} in the file
20:26:25 <dansho> ty
20:27:07 <novum> heatsink, I am not sure if this helps https://asciinema.org/a/CXMM5HFfEsuJy7EXVYX4tlwfQ
20:27:12 <heatsink> dansho: To activate the extension in all modules, use default-extensions
20:28:00 * hackage witherable 0.3.4 - filterable traversable  https://hackage.haskell.org/package/witherable-0.3.4 (FumiakiKinoshita)
20:29:04 <heatsink> This is the first time I've seen that feature where you scroll through command-line options and select one
20:30:57 <nyc> Hmm. Rounded is difficult to attempt a series of precisions and to see what precision converges sufficiently.
20:31:00 <novum> heatsink, https://gitlab.com/dylnmc/dotfiles/blob/new/.zshrc#L239
20:32:30 * hackage waargonaut 0.8.0.1 - JSON wrangling  https://hackage.haskell.org/package/waargonaut-0.8.0.1 (qfpl)
20:33:14 <heatsink> novum, I don't recognize the problem.  I'd expect that both `import Main` and `:load Main.hs` would work in ghci
20:34:23 <novum> I don't know either. ghci hates me.
20:35:34 <novum> :load does work, however.
20:46:09 <dsal> novum: Are you sure it didn't automatically load with 'stack ghci'?  It should.
20:47:17 <novum> do I need to decorate the file with anything or have a main in it? no it obviously didn't load any of the modules, as you saw in the asciinema. when I do :load Leap  then I have Leap as a module. If I import Leap after :load leap, then I see "Leap Leap" in the ghci prompt string, which is weird to me
20:47:48 <novum> the first time I do :load Leap, the prompt string changes to "Leap "
20:48:20 <dsal> Oh.  I didn't even look at the thing.  That looks like a strange project layout.
20:48:43 <novum> what should it look like
20:48:52 <dsal> How did you make it?
20:48:55 <novum> it's not really a project
20:49:07 <novum> I just did  vim Leap.hs  save+quit.  stack init
20:49:10 <novum> what should I do
20:49:15 <dsal> stack new whatever
20:49:29 <dsal> That'll give you a project with srcs and mains and tests and the stuff you need to link them altogether and all that.
20:49:35 <novum> that sounds like a good idea. let me try that. I didn't realize that's how one should make projects
20:49:55 <dsal> Well, if you use stack, it'll get a few things going more quickly.
20:50:21 <dsal> I should probably do a custom template, since I use different test stuff than the default, at least.  I also don't like the -exe thing it does, so I end up editing that.
20:50:30 * hackage Diff 0.4.0 - O(ND) diff algorithm in haskell.  https://hackage.haskell.org/package/Diff-0.4.0 (SterlingClover)
20:52:26 <novum> ok. stack ghci in proj root after doing stack new does allow me to import Lib (the default stack new stuff)
20:52:58 <dsal> It should just do it automatically because it's the default thing to do.
20:52:59 <rajivr___> I am new to Haskell. I was working on an haskell book exercise when by _mistake_ I entered the following in ghci. https://gist.github.com/rajivr/6f530dfdfe1b827eddc68d98b527b5e8 This seems to indicate that Haskell treats `m a` and a function `b -> c` interchangeably? Also what seems to be happening is that `b ->c` is turning out to be just a function that takes in any value and extracts out `a` from `m a`. Am I 
20:52:59 <rajivr___> understanding this correspondence correctly?
20:53:29 <novum> I don't want to make a new project for each exercism.io exercise, but should I?
20:53:42 <dsal> I've not done exercism lately.  I thought it just did that for me.
20:53:55 <novum> I guess I can just append to test/test.hs to run the tests?
20:54:07 <dsal> Yeah, I seem to have a project per exercise from last time I did stuff.
20:54:16 <novum> o.o
20:54:33 * novum sighs
20:55:04 <heatsink> rajivr___: `b -> c` matches `m a`.  The m part is `b ->`, and the a part is `c`
20:55:08 <dsal> I'm sure there are ways you can make it harder, but I found that quite pleasant.
20:56:08 <rajivr___> Haskell simply continues to blow my mind! :-) I see it now.
20:56:15 <heatsink> rajivr___: `b ->` isn't valid syntax.  You can write `b -> c` as `(->) b c`, then you can see that `(->) b` is m
20:56:49 <rajivr___> heatsink:  got it. Thanks! :-)
20:59:51 <iqubic> There's an instance of Monad for '(->) b'
21:00:09 <iqubic> forall b. There are no restrictions on b.
21:01:02 <rajivr___> iqubic: Yes, even though I don't yet undestand monads (haven't gotten to that part of the book), I figured it out from type signature as to why it type checks. 
21:02:03 <dsal> I don't fully understand the function monad, but I've used it once.
21:02:15 <iqubic> :t (<*>) `asAppliedTo` Const
21:02:17 <heatsink> dsal: It's the reader monad
21:02:17 <lambdabot> error:
21:02:17 <lambdabot>     • Couldn't match type ‘Const a b0’ with ‘a1 -> b’
21:02:17 <lambdabot>       Expected type: a -> a1 -> b
21:02:41 <iqubic> :t (<*>) `asAppliedTo` (Const Int)
21:02:41 <dsal> @check read.show >>= (==)
21:02:42 <lambdabot> error:
21:02:42 <lambdabot>     • Data constructor not in scope: Int
21:02:42 <lambdabot>     • Perhaps you meant one of these:
21:02:44 <lambdabot>  +++ OK, passed 100 tests.
21:02:46 <rajivr___> I should have done a `:info Monad` before asking the question.  :-) Thanks for the pointer. 
21:03:13 <iqubic> :t (<*>) `asAppliedTo` Const
21:03:14 <lambdabot> error:
21:03:14 <lambdabot>     • Couldn't match type ‘Const a b0’ with ‘a1 -> b’
21:03:14 <lambdabot>       Expected type: a -> a1 -> b
21:03:38 <iqubic> :t (<*>)
21:03:40 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
21:03:40 <dsal> Kind of wondering what @check did above there...
21:03:49 <iqubic> it ran quickcheck.
21:03:54 <dsal> On like.. what, though?
21:04:02 <iqubic> GHC has weird defaulting.
21:04:07 <iqubic> :t read . show
21:04:08 <lambdabot> (Read c, Show a) => a -> c
21:04:19 <iqubic> Well, I have no idea.
21:04:30 <dsal> Something with Read, Show, and Eq
21:04:32 <iqubic> :t show . read
21:04:34 <lambdabot> String -> String
21:04:43 <iqubic> I'd assume it defaulted to String.
21:04:50 <dsal> That's different, though.
21:05:22 <dsal>  :t read.show >>= (==)
21:05:40 <iqubic> :t \f -> read.show >>= f
21:05:42 <lambdabot> (Read a1, Show a2) => (a1 -> a2 -> b) -> a2 -> b
21:05:56 <dsal> :t read.show >>= (==)
21:05:57 <lambdabot> (Read a, Show a, Eq a) => a -> Bool
21:06:20 <dsal> @check (read.show >>= (==))  :: Float -> Bool
21:06:22 <lambdabot>  +++ OK, passed 100 tests.
21:06:28 <iqubic> Alright.. I have no idea what 'a' QuickCheck chose.
21:06:41 <iqubic> @check (read.show >>= (==))  :: [Int] -> Bool
21:06:44 <lambdabot>  +++ OK, passed 100 tests.
21:06:49 <jle`> :t (=<<) =<< (=<<)
21:06:50 <lambdabot> (a -> a -> a) -> a -> a
21:07:19 <dsal> Your walrus parade puzzles me.
21:07:41 <iqubic> jle`: What the heck is that doing there?
21:08:04 <dsal> > ((=<<) =<< (=<<)) (+) 3
21:08:06 <lambdabot>  9
21:08:07 <jle`> it's an operator application
21:08:15 <jle`> x + y, is sugar for (+) x y
21:08:20 <jle`> it applies the operator (+) to x and y
21:08:37 <iqubic> :t (\f a -> f a a)
21:08:38 <lambdabot> (t1 -> t1 -> t2) -> t1 -> t2
21:08:39 <jle`> in this case it is applying (=<<) to (=<<) and (=<<)
21:09:01 <iqubic> Wait?!?! what? Why is mine (a -> a -> b) -> a -> b?
21:09:10 <jle`> your what?
21:09:16 <iqubic> My function.
21:09:28 <jle`> ah. well the f can provide anything in result
21:09:31 <dsal> Because you didn't say what it can do.
21:09:31 <iqubic> I was trying to create a function with the same type as your triple bind.
21:09:34 <jle`> > (\f a -> f a a) compare "hello"
21:09:37 <lambdabot>  EQ
21:09:47 <jle`> see, compare here is string -> String -> Ordering
21:09:53 <jle`> the result of 'f' doesn't have to be the same type as its inputs
21:10:19 <iqubic> > (\f a -> f a a) + 3
21:10:21 <lambdabot>  error:
21:10:21 <lambdabot>      • No instance for (Typeable t0)
21:10:21 <lambdabot>          arising from a use of ‘show_M65375684438900883428943’
21:10:28 <jle`> it can be any (a -> a -> b), the return type doesn't have to be the same as its input types
21:10:30 <iqubic> > (\f a -> f a a) (+) 3
21:10:32 <lambdabot>  6
21:10:57 <iqubic> Huh? My function and your triple bind produce different results.
21:11:06 <jle`> indeed, that is because they are different functions
21:11:23 <iqubic> > ((>>=) >>= (>>=)) (+) 3
21:11:25 <lambdabot>  error:
21:11:25 <lambdabot>      • Occurs check: cannot construct the infinite type: t ~ t -> b0
21:11:25 <lambdabot>        Expected type: (((t -> t) -> t -> b0) -> t -> b0)
21:11:57 <iqubic> > ((=<<) =<< (=<<)) (+) 3
21:11:59 <lambdabot>  9
21:12:04 <iqubic> How does that work?
21:12:11 <iqubic> :t (=<<)
21:12:12 <lambdabot> Monad m => (a -> m b) -> m a -> m b
21:12:16 <jle`> the answer is a lot less interesting than you probably think
21:12:21 <jle`> you can just expand the definition of (=<<)
21:12:26 <jle`> for the appropriate instances of Monad
21:12:47 <iqubic> What is the Monad being used though?
21:13:57 <iqubic> > let 1+1 = 3 in (1+1) * 2
21:13:59 <lambdabot>  6
21:14:07 <iqubic> That's so weird.
21:14:15 <teardown> so is haskell a LISP?
21:14:17 <iqubic> > (1+1) * 2
21:14:19 <lambdabot>  4
21:14:34 <jle`> > let 1 &*^&*#$ 1 = 3 in (1 &*^&*#$ 1) * 2
21:14:36 <lambdabot>  6
21:14:43 <jle`> teardown: hm, i wouldn't call it a lisp
21:15:04 <iqubic> jle`: I see.
21:15:13 <jle`> i don't really know what qualifies something as lisp-like exactly, but i don't think haskell really fits any of the qualities
21:15:14 <iqubic> It's an incomplete pattern match.
21:15:21 <iqubic> Very very incomplete.
21:15:23 <jle`> maybe it's 'functional'
21:15:56 <iqubic> 'let 1+1 = 3 in (1+1) * 2' is both a very very very incomplete pattern match, and shadowing an existing definition.
21:16:10 <jle`> indeed, it's the perfect storm of potential confusion
21:16:22 <teardown> jle`: okay, cool thanks. 
21:16:43 <iqubic> I know. I didn't understand how it worked until just now, when writing that sentence.
21:16:47 <jle`> teardown: yeah, i think as far as languages go, haskell and lisp don't have much in common other than being generally listed as 'functional'
21:17:30 <jle`> teardown: but pretty much every other aspect is almost directly opposite :)
21:17:40 <teardown> jle`: all the parenenthsis above looked very lisp-like. but does haskell build on the predicate calculus, as lisp does?
21:17:50 <jle`> it does not
21:17:53 <teardown> ha ha ha okay
21:17:59 <jle`> the code snippet above is actually somewhat of a degenerate case
21:18:10 <jle`> it was written to be obfuscatory, heh
21:18:13 <dsal> Many languages support using parenthesis, though.
21:18:35 <iqubic> I know.
21:18:37 <teardown> dsal: very true
21:18:45 <jle`> i see no lies here
21:19:20 <jle`> many languages support parentheses, but lisps are sort of built around s-expressions as a fundamental core concept
21:19:54 <jle`> so there is a high parentheses-char ratio
21:20:16 <jle`> i can see why something like ((=<<)=<<(=<<))(+)3 can be 'detected' as a potential lisp statement
21:20:23 <jle`> given its unusual parentheses-to-character ratio
21:20:29 <heatsink> teardown: I'd say that Haskell builds on the typed lambda calculus
21:20:44 <teardown> thanks for your answers, jle`
21:21:10 <jle`> no problem!
21:21:22 <teardown> heatsink: ok, yes doesn't haskell staticly typed
21:21:32 <iqubic> I jut found this, and it is hell on Earth: https://wiki.haskell.org/Obfuscation
21:23:29 <novum> well, it just does ?? and ???? and ??????? and ????????? and outputs ??????????. it's rather straight forward.
21:23:57 <jle`> just be careful not to [redacted] because it can cause [redacted] in some systems
21:24:37 <iqubic> One of the reasons this obfuscation contest was: "to boldly go where no Haskell programmer has ever wanted to be!"
21:24:57 <teardown> i'm going to work through bird and wadler's book this winter. im currently weighing whether to use the scheme version or bite the bullet and learn haskell for the revised edition
21:25:53 <jle`> is the revised version in a new language? that's interesting
21:26:09 <jle`> i think philosophically, haskell and lisp are very different from me because they derive their main 'power' from two different places
21:26:42 <jle`> lisp derives its power and expressiveness from its homoiconicity, the fact that its programs are basically first-class things that manipulate themselves
21:27:02 <jle`> haskell derives its expressiveness from its type system, enforced purity, and to an extent, implicit laziness
21:27:29 <nyc> Various more special functions aren't available for high-precision arithmetic.
21:27:40 <jle`> you can see this illustrated in the way that you'd implement if-then-else in one or the other
21:28:06 <jle`> so while they're both 'functional', i think these fundamental difference really shifts the way you approach most problems in practice
21:28:09 <iqubic> I like Haskell's verion of laziness is the default, but you can explicitly chose strict if needed.
21:28:43 <iqubic> Idris does the exact opposite of this, using something they call the 'Lazy a' datatype.
21:29:42 <heatsink> jle`, I thought if-then-else was primitive in both haskell and lisp.  Or minor variations, case and cond.
21:30:09 <jle`> i meant, the way you could implement it 'yourself'
21:30:13 <jle`> within the language
21:30:16 <iqubic> It is a primitive, but I can right something similar.
21:30:47 <jle`> if/then/else is a syntactic structure that provides layouting, but if you don't mind losing layouting you could write your construct with the same sort of control flow properties
21:30:52 <iqubic> ifThenElse True x _ = x
21:31:01 <iqubic> ifThenElse False _ y = y
21:31:06 <teardown> jle`: i see. can't wait to look at haskell in a while, regardless of which version of the text i end up reading
21:31:25 <jle`> teardown: i think, if it's for a 'functional programming' book, you might not end up going into too many of the differences
21:31:52 <heatsink> All the alternatives in Haskell boil down to case, maybe with syntactic sugar
21:31:53 <jle`> and maybe the difference between haskell and lisp aren't much when you compare it to say, java
21:32:21 <heatsink> I suppose all the alternatives boil down to a primitive decision operator in lisp too 
21:32:25 <jle`> maybe it's just because i work so closely with them, the differences become exaggerated in my mind
21:32:31 <iqubic> Well, yes. But case is still lazy.
21:32:35 <jle`> heatsink: yeah, my point was, laziness vs. macros
21:32:49 <heatsink> I see
21:32:52 <jle`> or rather: how do you short-circuit a computation?
21:33:12 <iqubic> and False _ = False
21:33:20 <iqubic> and True x = x
21:33:26 <heatsink> It's more about what language features you use to make it convenient 
21:33:32 <iqubic> or True _ = True
21:33:36 <heatsink> Those would be different between haskell and lisp
21:33:39 <iqubic> or False x = x
21:33:47 <iqubic> Two ways to short circuit.
21:33:53 <iqubic> Laziness is cool
21:34:00 <jle`> yeah, that guides the philosophy behind a lot of how you would approach lots of problems
21:34:11 <jle`> lisp is a world that ended up being built around macros, and haskell, not so much
21:34:21 <jle`> haskell metaprogramming is still considered a dirty word by many ...
21:34:35 <iqubic> Haskell has TH, but not many people like it.
21:39:50 <iqubic> I still don't understand how TH works
21:40:00 * hackage lzlib 0.2.0.1 - lzlib bindings  https://hackage.haskell.org/package/lzlib-0.2.0.1 (vmchale)
21:41:00 <heatsink> TH basically lets you write, instead of an expression, some Haskell code that returns an expression
21:41:52 <heatsink> The compiler runs your code, gets the expression your code returns, and compiles it
21:41:53 <jle`> it could be used to do lisp-style metaprogramming, if it wasn't for the weird staging limitations
21:42:20 <jle`> ah yeah and also the fact that it can't do anything that depends on runtime values
21:42:50 <heatsink> Sure it can.  unsafePerformIO. >:)
21:42:58 <iqubic> No. No. No. No. No.
21:43:08 <jle`> hm, i think that's the wrong direction
21:43:23 <jle`> you can't do something like myFunc n = $( ... something that uses n ), i think
21:43:37 <jle`> ah, but you can do something that refers to the variable 'n'
21:43:41 <heatsink> You have quasiquoting as in lisp
21:43:43 <jle`> but you can't directly inspect it
21:43:56 <jle`> right i'm saying that lisp's metaprogramming is more expressive than haskell's
21:44:14 <jle`> that's because lisp runtime bundles its evaluator with it, but haskell's runtime doesn't contain ghc
21:44:20 <iqubic> Don't write a program that randomly deletes one file on the user's system each time it is compiled. I know unsafePerformIO lets that happen, but don't do it.
21:44:38 <iqubic> That would be a shitty thing to do.
21:44:55 <jle`> you don't even need unsafePerformIO to do that ... TH allows for arbitrary IO already
21:45:14 <jle`> the TH monad is MonadIO
21:45:27 <mycroftiv> ive been working hard learning dependent types in Agda and it feels very related to metaprogramming. Is this intuition something that has a precise mathematical meaning or is it just related via reflexivity?
21:45:55 <iqubic> Oh, I didn't know that at all.
21:46:02 <iqubic> I'm stupid.
21:46:19 <jle`> i wouldn't go that far :) a lot of non-stupid people don't know that
21:47:23 <iqubic> Why is it MonadIO? That seems like a recipe for disaster, in exactly the way I described above.
21:47:24 <heatsink> I didn't know that either.  liftIO seems like too much power for what TH metaprogramming is supposed to do
21:49:12 <jle`> people like to use it to embed files at compiletime
21:49:33 <jle`> also to inspect properties of the system/architecture that might not be available via the ghc api
21:52:25 <heatsink> jle`, I'm curious what lisp macros are doing with the values they capture.  Are some macros inspecting the run-time value of captured variables?
21:52:56 <iqubic> They can do, yeah
21:53:54 <jle`> yeah. and because the runtime contains the language interpreter/compiler itself (depending on impl) it's basically constantly re-compiling/re-interpreting as you go
21:54:29 <jle`> in order for haskell to do the same thing, the ghc runtime would have to basically contain a full ghc
21:55:42 <jellostahps> :t map
21:55:43 <lambdabot> (a -> b) -> [a] -> [b]
21:55:51 <jellostahps> a and b cant be the same type right?
21:55:53 <jle`> but this sort of actually feels somewhat reminiscent of the evaluation-IO fundamental loop that Haskell runtime code obeys
21:56:00 <jle`> jellostahps: they can be the same type if you want
21:56:12 <jle`> it doesn't mean that they have to be different, just that they don't have to be the same
21:56:22 <jle`> jellostahps: it's analogous to `myFunc x y = x + y`
21:56:30 <jle`> x and y can be different numbers
21:56:37 <jle`> but nothing is stopping you from calling myFunc 1 1
21:56:38 <jellostahps> ok
21:56:48 <jle`> > map negate [1,2,3]
21:56:50 <lambdabot>  [-1,-2,-3]
21:56:54 <jellostahps> but if we had all a's they HAVE to be the same type?
21:57:03 <jle`> yeah, that would be analogous to myFUnc x = x + x
21:57:15 <jellostahps> ok great example ty
21:57:29 <jle`> if they were all a's then yeah, the input and output of the function you pass in would have to be the same type
21:58:27 <jzyamateur> Wondering why I am getting incomplete patterns? - https://gist.github.com/chetnashah/b72f6f48bdac38f3917bb2653f69f46e My guards check all possibilities.
21:59:05 <jle`> jzyamateur: GHC isn't smart enough to deduce that
21:59:25 <jle`> jzyamateur: the rules it follows for deducing this are pretty simple
21:59:37 <jle`> jzyamateur: remember that the exhaustiveness checker is just a program that humans write that check your cases to verify they are exhaustive
21:59:46 <iqubic> jellostahps: If 'a' is Int then [a] would be a list of Ints. And all the elements of the list would be Int. If 'a' is Char, then every single element in [a] has to be a Char.
21:59:53 <jle`> and it apparently doesn't include special-case rules for ==/</> type guards
22:00:12 <jle`> jzyamateur: one thing you can do is pattern match on `compare n d`
22:00:22 <jle`> divBy n d ans = case compare n d of
22:00:31 <jle`>   LT -> (fst ans, n)
22:00:33 <jzyamateur> so compare is covered and `>` etc are not?
22:00:42 <jle`>   EQ -> (fst ans + 1, nd ans)
22:00:53 <jle`> jzyamateur: well, it's not compare that is covered
22:00:57 <jle`> it's the fact that it's a case statement
22:01:07 <jle`> and if you have a case statement, ghc can just check that every constructor is handled
22:01:19 <jle`> the same way you can do map _ [] = ... map f (x:xs) = ...
22:01:25 <jle`> the list type has two consturctors, [] and :
22:01:32 <jzyamateur> jle` I am using guards, not case expr, are they one and the same?
22:01:33 <jle`> so if you match on both constructors, ghc can be happy
22:01:39 <jle`> jzyamateur: they are different
22:01:45 <jellostahps> In laymans :t map, would be: parameter 1: a function that takes a type a and returns a type b...results in a function that takes a type [a] and returns a type [b]?
22:01:47 <jellostahps> :t map
22:01:48 <lambdabot> (a -> b) -> [a] -> [b]
22:01:50 <iqubic> I think that using compare and a case statement is easier to reason about.
22:02:01 <jle`> jzyamateur: case statements let you pattern match on values
22:02:03 <iqubic> jellostahps: That is correct.
22:02:09 <jle`> jzyamateur: but guards take boolean conditions
22:02:15 <jellostahps> i cant even think of an example where i could use map
22:02:28 <jle`> jzyamateur: with case statements, you pattern match on all the possible constructors, and ghc knows what constructors a type has
22:02:56 <jle`> jellostahps: it comes up pretty often -- one thing i recently did was for a hangman game
22:03:06 <jle`> > map (\c -> if c == 'a' then 'a' else '_') "hangman"
22:03:08 <lambdabot>  "_a___a_"
22:03:24 <jle`> there i use it to censor out characters that aren't 'a'
22:03:39 <jle`> but yeah map is one of the more common list processing functions out there
22:03:43 <jzyamateur> Then it seems, guards are harder for the interpreter to reason about, regarding exhaustiveness?
22:04:07 <jle`> jzyamateur: indeed. there isn't much you can do except for check for special cases
22:04:13 <iqubic> Is there a better way to write this: 'map (map getFinite) towers'
22:04:14 <jle`> jzyamateur: the main way to say a guard is exhaustive is by using 'otherwise'
22:04:26 <jzyamateur> ah ok.
22:04:30 <jle`> jzyamateur: for example in the third guard you can write | otherwise = ..
22:04:36 <jle`> and ghc would be happy with that, because otherwise is a catch-all
22:04:48 <iqubic> where 'towers :: [[Finite n]]'
22:05:10 <iqubic> is there a better way to write my nested map?
22:05:19 <jle`> iqubic: the way you wrote it is already probably as clean as it's going to get. alternatively (map . map) can be used to write arbitrarily nested maps
22:05:26 <jle`> (map . map) getFinite towers
22:05:31 <jle`> but i don't think it's much of an improvement
22:05:54 <iqubic> Neither do I.
22:06:04 <heatsink> GHC's exhaustiveness checker recognize otherwise specially.  I never noticed before.
22:06:16 <iqubic> why does intercalate exist?
22:06:25 <iqubic> :t intercalate
22:06:26 <lambdabot> [a] -> [[a]] -> [a]
22:06:29 <heatsink> > intercalate 'a' "bnns"
22:06:29 <jle`> i'm not sure if it recognizes otherwise specifically, or just anything that it can recognize is True
22:06:31 <lambdabot>  error:
22:06:31 <lambdabot>      • Couldn't match expected type ‘[a]’ with actual type ‘Char’
22:06:31 <lambdabot>      • In the first argument of ‘intercalate’, namely ‘'a'’
22:06:34 <jle`> > intercalate "," ["hello","world"]
22:06:36 <lambdabot>  "hello,world"
22:06:38 <heatsink> > intercalate "a" "bnns"
22:06:40 <lambdabot>  error:
22:06:40 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Char]’
22:06:40 <lambdabot>        Expected type: [[Char]]
22:06:53 <iqubic> > intercalate 'a' "bnns"
22:06:54 <jle`> unlines is soooooorta equivalent to intercalate "\n"
22:06:55 <lambdabot>  error:
22:06:55 <lambdabot>      • Couldn't match expected type ‘[a]’ with actual type ‘Char’
22:06:55 <lambdabot>      • In the first argument of ‘intercalate’, namely ‘'a'’
22:07:13 <jle`> unlines xs = intecalate "\n" xs ++ "\n"
22:07:14 <heatsink> Oh, it needs a list
22:08:16 <jle`> % putStrLn $ intercalate "\n" ["hello","world"]
22:08:17 <yahb> jle`: hello; world
22:08:27 <jle`> heh, the ; should be a newline
22:08:40 <iqubic> I wrote '(concat $ intersperse ", ") xs' and hlint suggested itercalate there.
22:09:01 <iqubic> I was shocked, because I had never ever seen that function before.
22:09:02 <jle`> well, doesn't that answer your question?
22:09:17 <jellostahps> Please help me understand the map function, line 3: https://pastebin.com/96itn5uv
22:09:17 <jle`> (about why it exists)
22:09:40 <EvanR> iqubic: there are a lot of list processing operations... not all of them have a name. No need to be shocked
22:09:47 <iqubic> jellostahps: What is your question about that function?
22:10:02 <jellostahps> figuring out how line 3 operates
22:10:25 <jle`> jellostahps: hm, are you familiar with how lists are constructed in haskell?
22:10:27 <iqubic> What part of line 3 is confusing you?
22:10:32 <jle`> jellostahps: and how they can be pattern matched?
22:10:36 <jellostahps> how is the result even a function ([a]->[b]) let alone a single list
22:10:46 <jle`> ah. the result isn't a function
22:10:47 <jellostahps> well we could star twith what (f x) is doing
22:10:49 <jle`> 'f' is a function
22:10:55 <jle`> it *takes* a function
22:11:04 <jle`> it doesn't return a function in this case
22:11:10 <jle`> see if you can understand this function:
22:11:15 <jle`> @let doTwice f x = f (f x)
22:11:16 <lambdabot>  Defined.
22:11:20 <jellostahps> oooh the result is a single list of type [b]
22:11:25 <iqubic> Yes.
22:11:26 <jle`> > doTwice (+1) 3
22:11:28 <lambdabot>  5
22:11:36 <jle`> it *takes* a function, and then does something with that function
22:11:41 <iqubic> Do you understand how doTwice works?
22:11:45 <jellostahps> and there are 2 input parameters to the mymap function?
22:11:51 <jle`> indeed, an (a -> b) and an [a]
22:11:54 <iqubic> Yes there are.
22:12:19 <jellostahps> that second bracket really screwed me up then, why even have the second pair of brackets
22:12:40 <jle`> which brackets?
22:12:53 <jle`> oh ah, i see
22:13:04 <iqubic> myMap :: (a  -> b) -> ([a] -> [b])
22:13:12 <jle`> well, sometimes it's useful to think of map in terms of a function-transformer
22:13:16 <jellostahps> yeah
22:13:25 <jle`> but *usually* people would write it as (a -> b) -> [a] -> [b]
22:13:32 <jellostahps> yeah exactly
22:13:44 <jellostahps> okay let me rethink this now
22:13:55 <jle`> there are some things that can be easier understand if you imagine it as an (a -> b) -> ([a] -> [b])
22:14:03 <iqubic> Like what?
22:14:06 <jle`> but usually people would write it by default as (a -> b) -> [a] -> [b]
22:14:11 <jle`> well, the map . map example earlier
22:14:16 <jellostahps> the latter i understand best
22:14:21 <iqubic> Oh, yeah.
22:14:32 <jle`> if we think of (a -> b) -> ([a] -> [b]), then we can imagine what would happen if we do (map . map)
22:14:41 <jle`> but that's not always the most relevant interpretation or concern
22:14:45 <jellostahps> i can understand both of them, when im not at the 12th of 12 hours straight into studying haskell
22:15:42 <monochrom> Don't study anything for straight 12 hours. Cap it at 6 hours. Diminishing return and burnout.
22:15:55 <jle`> cap it at 3 tbh
22:16:01 <jle`> ...if you have a choice
22:16:18 <jellostahps> yes, choice
22:16:28 <jle`> :t map
22:16:29 <lambdabot> (a -> b) -> [a] -> [b]
22:16:30 <jellostahps> so in my pastebin.(f x) is running the function with paramter a=x?
22:16:37 <jellostahps> https://pastebin.com/96itn5uv
22:16:41 <jle`> x :: a, yeah
22:17:26 <jellostahps> now i can sleep, thank you u lovely ppl
22:17:43 <jle`> have a good night :)
22:17:49 <iqubic> (fmap . fmap) screws up my brain so much
22:17:50 <jellostahps> ty!
22:18:05 <monochrom> Consider fmap fmap fmap.
22:18:11 <jle`> fmap turns an (a -> b) into an (f a -> f b)
22:18:17 <iqubic> Right.
22:18:28 <jle`> so it should also turn an (g a -> g b) into an (f (g a) -> f (g b))
22:18:49 <jle`> it "adds" an 'f' on both sides of the ->.
22:18:49 <iqubic> where the 'f' and 'g' can be different functors?
22:18:55 <monochrom> Maybe I should put that on my exam.
22:18:56 <jle`> so doing it twice would "add" an 'f' twice
22:19:03 <jle`> you can look at it visually
22:19:19 <EvanR> :t fmap . fmap
22:19:20 <lambdabot> (Functor f1, Functor f2) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
22:19:22 <iqubic> So the two fmaps in (fmap . fmap) can target different functors?
22:19:27 <jle`> yeah in general
22:19:31 <EvanR> a tale of two functors
22:19:39 <jle`> (fmap @[] . fmap @Maybe)
22:19:47 <jle`> % :t fmap @[] . fmap @Maybe
22:19:48 <yahb> jle`: forall {a} {b}. (a -> b) -> [Maybe a] -> [Maybe b]
22:19:49 <iqubic> I see.
22:19:59 <heatsink> It is mystifying how the type of (fmap fmap ...) transforms as you keep applying more fmaps
22:20:02 <jle`> % :unset -fprint-explicit-foralls
22:20:03 <yahb> jle`: 
22:20:06 <jle`> % :t fmap @[] . fmap @Maybe
22:20:06 <yahb> jle`: (a -> b) -> [Maybe a] -> [Maybe b]
22:20:16 <iqubic> I see how that works.
22:20:30 <iqubic> % :t fmap @[] . fmap @[]
22:20:30 <yahb> iqubic: (a -> b) -> [[a]] -> [[b]]
22:20:44 <iqubic> Is fmap @[] just the same as map?
22:20:45 <jle`> heatsink: the way i like to think of it is that <$> is associative
22:20:56 <iqubic> why do we have map, when fmap exists?
22:20:58 <jle`> (f <$> g) <$> x = f <$> (g <$> x)
22:21:02 <jle`> iqubic: it can help with type inference
22:21:06 <jle`> and readability
22:21:10 <iqubic> I thinks so.
22:21:26 <jle`> almost the same reason why we have (.) when (<$>) exists
22:21:43 <iqubic> I did not know that <$> was associative
22:21:44 <jle`> (that one is slightly more useful because they have different fixities)
22:21:50 <jle`> iqubic: it's not, that was a joke :)
22:21:55 <iqubic> Oh. I see.
22:22:06 <jle`> it's "true"
22:22:12 <jle`> but for a deceptive reason
22:22:22 <iqubic> So why does your <$> thing work?
22:22:25 <jle`> > (negate <$> subtract 1) <$> Just 3
22:22:27 <lambdabot>  Just (-2)
22:22:34 <jle`> > negate <$> (subtract 1 <$> Just 3)
22:22:36 <lambdabot>  Just (-2)
22:22:48 <jle`> iqubic: follow the types ~
22:23:44 <iqubic> fmap f (fmap g x) ~ f <$> (g <$> x)
22:24:04 <heatsink> One way transforms Just 3  to Just 2, then transforms it to Just (-2)
22:24:11 <iqubic> Sure.
22:25:12 <koz_> :t floor
22:25:13 <lambdabot> (RealFrac a, Integral b) => a -> b
22:25:24 <iqubic> koz_: What are you doing?
22:25:32 <koz_> iqubic: Finitary things.
22:26:22 <heatsink> (negate <$> subtract 1) is using Applicative ((->) Int)
22:26:50 <iqubic> Why do you need to floor a finitary value?
22:26:51 <heatsink> So it's the same as (negate . subtract 1)
22:28:57 <ski> @type intToDigit
22:28:58 <lambdabot> Int -> Char
22:29:10 <ski> @type map intToDigit
22:29:11 <lambdabot> [Int] -> [Char]
22:29:15 <ski> @type map (map intToDigit)
22:29:16 <lambdabot> [[Int]] -> [[Char]]
22:29:20 <iqubic> ski: What are you doing?
22:29:34 <jle`> pretty ascii art
22:29:50 <koz_> iqubic: Who says that I'm going to be flooring a finitary value?
22:30:09 <iqubic> I made an assumption.
22:30:17 <ski> oh, i was scrolled up, a little bit, i suppose
22:30:19 <koz_> Anyone who understands statistics: U(0,1) is the uniform distribution of all reals from 0 to 1 inclusive _at both ends_, right?
22:30:19 <jle`> i'm also pretty sure finitary values wouldn't be instances of RealFrac, heh
22:30:45 <EvanR> does it matter if it's inclusive?
22:30:53 <EvanR> 0 and 1 have no chance
22:31:21 <koz_> EvanR: OK, thanks.
22:31:31 <EvanR> i guess it matters for doubles
22:32:34 <MarcelineVQ> why do 0 and 1 have no chance?
22:32:46 <jle`> wikipedia suggests that it's a closed interval but yeah observably there is no difference
22:33:09 <jle`> MarcelineVQ: P(x=0) = 0 in either case
22:33:16 <heatsink> It's a continuous distribution, so the probability of any specific value is zero
22:33:18 <jle`> and x=1 as well
22:33:21 <MarcelineVQ> What does that mean ^^;
22:33:39 <jle`> the probabability of sampling 0 from U(0,1) is 0
22:33:48 <EvanR> P(x between 0 and 0) = 0
22:34:06 <koz_> :t log
22:34:07 <lambdabot> Floating a => a -> a
22:34:21 <jle`> MarcelineVQ: basically for continuous distributions, you don't have a probability distribution, but a probability density function
22:34:38 <jle`> MarcelineVQ: where the probaiblity of a number being sampled within some range (a,b) is the integral of the PDF between a and b
22:34:51 <ski> iqubic : did you see the `zipWith . zipWith' thing ?
22:35:02 <jle`> for example if you have a normal distribution, the probability of getting a positive number is the integral from 0 to infinity of the PDF
22:35:39 <jle`> MarcelineVQ: in this case the probability of sampling 'exactly zero' is basically integrating the PDF between 0 and 0
22:35:40 <EvanR> also, if you keep picking binary bits randomly, probability of them being 0 forever is 0
22:36:11 <EvanR> ( nothing special about 0 itself in any of these explanations)
22:36:31 <jle`> yeah, or about the distribution itself either
22:36:41 <jle`> well, unless it has some mass points
22:37:18 <ski> MarcelineVQ : it doesn't matter that it's `0' or `1'. *any* number in the (continuous) interval will have zero probability of being picked (which is not the same as it being impossible that that one is picked. a subset of measure zero doesn't have to be empty)
22:38:05 <EvanR> yeah its kind of a paradox, P(any x)=0... but if you keep picking bits randomly, you land *somewhere* after all
22:38:39 <jle`> math is weird
22:40:10 <heatsink> Iago could have used a mathematician's help to explain the impossibility of extracting exactly one pound of flesh
22:40:58 <heatsink> What, that was Antonio
22:41:05 <heatsink> *Wait
22:41:24 <koz_> heatsink: Shylock.
22:41:37 <dmwit> Perhaps the extraction process was not random.
22:41:43 <koz_> #haskell: From analysis to Shakespeare in 10 seconds. :P
22:46:40 <koz_> :t modify
22:46:41 <lambdabot> MonadState s m => (s -> s) -> m ()
22:46:46 <ski>   ∀ x : A. P(X = x) = 0
22:46:51 <ski> but
22:47:00 <ski>   P(∃ x : A. X = x) = 1
22:47:06 <ski> (for ⌜X⌝ being a continuous stochastic/random variable, ranging over ⌜A⌝, with no infinite density points)
22:47:14 * ski . o O ( <https://en.wikipedia.org/wiki/De_dicto_and_de_re> )
22:47:18 <MarcelineVQ> is the issue with continous that it's infinite possibilities? if so, why is the probability 0 and not instead infinitesimal?
22:47:47 <jle`> well, let's say we're considering probabilities as real numbers
22:47:49 <jle`> between 0 and 1
22:48:26 <EvanR> the size of the possibility is 0, looks like "dust"
22:48:33 <EvanR> no volume
22:48:38 <jle`> hm, i'm not sure if that's strictly formally correct. but it should at least convince you that "infinitesimal" is not a valid answer
22:49:17 <EvanR> integrals give a 0, not infinitesimals
22:49:20 <jle`> MarcelineVQ: if you actually try to compute the probaiblity of picking 0, you'll get 0
22:49:22 <MarcelineVQ> No, in fact it's the basis for my question so I'm missing something
22:49:32 <jle`> MarcelineVQ: 'infinitesimal' is not a real number
22:49:49 <jle`> you can check all of them, none of them are 'infinitesimal' :)
22:51:19 <heatsink> It might seem intuitively to be very small but nonzero.  But there's no consistent way to describe it as anything other than zero.
22:51:22 <jle`> MarcelineVQ: but yeah, we can do the math out without regarding the 'meaning' of what's going on; P(X in [0,0]) = integral_0^0 1 => P(X in [0,0]) = 0 - 0 = 0
22:51:27 <EvanR> similar to how the sum of 1/(2^n) is not 1-infinitesimal
22:53:16 <ski> MarcelineVQ : "why is the probability 0 and not instead infinitesimal?" -- that's a good question. i wonder whether in NSA, or in SDA, whether you could have infinitesimal integrals (and thus probabilities) like that
22:54:12 <heatsink> What is SDA?
22:54:21 <ski> (in SDG, an infinitesimal (of first degree) is a number whose square is zero. using constructive logic reasoning, it doesn't follow that the number is zero. it does follow that the number is not not zero, though)
22:55:01 <EvanR> smooth infinitesimal analysis
22:55:25 <ski> "Synthetic Differential Geometry" (2nd ed.) by Anders Kock in 2006 at <http://home.imf.au.dk/kock/sdg99.pdf>
22:55:59 <koz_> https://gist.github.com/kozross/522fec1e8595489edcb6ad3a5e08fcb0 <-- what am I missing here?
22:56:14 <ski> (iirc, first chapter isn't too bad to get the gist of, if you know basics of derivatives)
22:56:38 <ski> heatsink : sorry, s/SDA/SDG/
22:56:46 <EvanR> i think they have a slightly different notion of constructive logic and 'not'
22:56:56 <ski> they're working in a topos, sure
22:56:59 <EvanR> from e.g. agda
22:57:45 <ski> (or, they're "secretly" working in a topos, in first part of the book)
22:57:48 <heatsink> koz_: choose is declared to return m a, but it calls runStateT, whose return value is not a monad type
22:58:18 <koz_> heatsink: Oh, so do I have to spell that I'm giving back a StateT Double m (Finite n) or something?
22:58:24 <koz_> (in foo)
22:58:26 <glguy> :t runStateT
22:58:27 <lambdabot> StateT s m a -> s -> m (a, s)
22:58:56 <EvanR> there's some kind of disconnect though between differential geometry and volumes of the sort that come out of integrals
22:58:58 <koz_> Oh wait, right.
22:59:01 <heatsink> Oh, I was thinking runState
22:59:09 <koz_> I know what my issue is, thanks.
22:59:12 <heatsink> That's not the problem then
22:59:12 <glguy> runStateT is returning an   m(a,s)  but you claimed that choose returns any m a
22:59:54 <EvanR> differentials are like linear approximations and volumes are a different species of thing
23:00:22 <ski> hm, i suppose
23:00:47 <koz_> I should really not code when I'm tired lol.
23:00:55 * ski wanted to figure out typing of stuff like surface integrals, at some point ..
23:01:20 <EvanR> i heard the greeks considered length, area, volume to all be different... but that's literally hearsay
23:02:13 <koz_> I keep getting runState(T?) and evalState(T?) confused.
23:02:15 <MarcelineVQ> as in literally some greek told you that
23:02:31 <EvanR> probably had some greek in them
23:02:36 <koz_> EvanR: Are you a time traveller?
23:06:26 * ski travels to the future, at the speed of 3600 seconds per hour
23:07:04 <koz_> Whoa, that's 3.6 kiloseconds!
23:07:43 <dmwit> ksph
23:07:57 <EvanR> time is an illusion history is crystalized in a spacetime hypercube
23:14:16 * ski . o O ( 4-simultaneous 24-hour Days within a single rotation of Earth )
23:15:12 <EvanR> turns out he was just trying to remember the word for time zones
23:15:25 <heatsink> lol
23:16:25 <EvanR> we probably went to similar elementary schools in the US, where they only teach you 4 time zones
23:17:11 <int-e> ski: ah time, where you have to travel faster in order to move more slowly :)
23:17:15 <heatsink> So Alaska and Hawaii are foreign countries
23:17:19 <EvanR> right
23:17:39 <EvanR> educated stupid
23:18:02 <int-e> heatsink: all countries are foreign (as viewed by a majority of people)
23:18:55 <heatsink> There's a book series, "Clockwork Rocket", about a universe where time and space are symmetrical
23:19:22 <heatsink> So time dilation works in the opposite way from our universe
23:20:39 <koz_> Will I confuse mtl if I have something like (MonadState Int m, MonadState Float m, ...) => ... ?
23:20:59 <heatsink> I get the feeling the author worked out all the physics, and then just wrote a work of fiction in the universe as a follow-up project
23:21:12 <EvanR> so lorentz transformation would be literally a euclidean rotation of space time... i heard 4d rotations are... interesting
23:22:41 <heatsink> koz_: MonadState has a functional dependency.  A given monad type can have only one state type 
23:22:54 * koz_ is disappoint.
23:22:59 <koz_> Guess I have to lug around a tuple.
23:23:38 <koz_> Or even lift, bro.
23:24:15 <heatsink> EvanR: yes, it's called "rotational physics" in the novel.  There's a section on quaternions
23:30:05 <quiet_laika[m]> does anyone use tfausak's flow?
23:30:09 <quiet_laika[m]> https://github.com/tfausak/flow
23:30:58 <ski> koz_ : yes, i agree it's disappointing
23:31:19 <koz_> ski: I guess otherwise type inference turns to custard?
23:32:47 <ski> (the correct way might be to be able to associate identifers with the different `MonadX Blah m' constraints, and then be able to refer to those identifiers in the code, to determine which effect was intended to interact with, in a particular case)
23:34:35 <ski> (`lift' does the same thing, for a determined transformer stack .. except that it's using peano numbers (iow de Bruijn indices) to refer to the transformer effects, rather than referring to them by name. however, perhaps the type system should also be able to keep track of an ordering (in the cases where it matters) ..)
23:36:35 <ski> koz_ : yes. it's a bit like referring to any variable by `it', and expecting the system to figure out which of them you intend, in each case (perhaps based on types of variables, and type of the context of the occurance of `it')
23:36:55 <koz_> ski: I guess I
23:36:59 <koz_> will have to do a bit of lifting.
23:37:07 <koz_> It's all hidden from the user, so it shouldn't be too awful.
23:37:44 <ski> that onlu works if you're being concrete, fixing a particular transformer stacking (at least up to some tail of that stack
23:37:47 <ski> )
23:37:50 <koz_> I am.
23:37:53 <koz_> (in this case)
23:39:30 * hackage conferer 0.1.0.4 - Configuration management library  https://hackage.haskell.org/package/conferer-0.1.0.4 (ludat)
23:49:31 <sicklorkin> quiet_laika[m]: I cannot imagine why anyone would want to use flow.
23:50:21 <quiet_laika[m]> sicklorkin: personally, i prefer the way elm code looks, to haskell, particularly around `.` and `$`
23:50:32 <quiet_laika[m]> and flow emulates that pretty well
23:50:55 <sicklorkin> maybe there's a specific use case, but I think people should be confortable w/haskell syntax. 
23:51:09 <sicklorkin> also it's advised to important as qualified
23:51:26 <quiet_laika[m]> well, im certainly comfortable reading it
23:51:34 <quiet_laika[m]> i just rather prefer writing it like elm
23:51:59 <sicklorkin> I think `f x` is easier than `apply x f`
23:52:18 <quiet_laika[m]> yeah, i dont think `apply` and `compose` are actually meant to be used in the wild
23:52:24 <sicklorkin> or as the author intends `Flow.apply x f`
23:52:26 <quiet_laika[m]> based on what ive seen the author saying
23:52:46 <quiet_laika[m]> well, the package says to import _un_qualified
23:53:47 * quiet_laika[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/GHkoallbDRZQApPlKsWiybxe >
23:53:58 * quiet_laika[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/ekMCECeVBHcwOjMpNZRcDUEU >
23:54:41 <Cale> (apply x f) reads strangely, because you apply functions to arguments, not arguments to functions -- so especially the partial application will be a bit odd.
23:54:57 <sicklorkin> quiet_laika[m]: it's a subjective topic, those are just my opinions. I say use whatever you  feel comfortable with
23:55:27 <Cale> It should be named applyTo
23:55:32 <sicklorkin> a |> b look slike a list operation to me
23:55:32 <quiet_laika[m]> totally 😁 i certainly think haskell has its established standards, and thats not going to change any time soon
23:56:09 <quiet_laika[m]> i got used to `|>` and `<|` in elm, but apparently theyre popular in f# as well?
23:56:59 <quiet_laika[m]> seems like its definitely a niche package for people with predefined notions of what ML-ish syntax should look like
23:57:03 <ski> quiet_laika[m] : i generally tend to prefer using `$' as little as possible
23:57:24 <ski> (with maybe a few relatively uncommon specific exceptions)
23:58:31 * sicklorkin hides his code off to the side as ski approaches
23:59:18 <quiet_laika[m]> i tend to use it in something like `Foo a $ mkBar (b c)` or `Foo a (mkBar $ b c)` 
23:59:20 * ski is mainly thinking of `foo $ bar . baz . quux' (over multiple lines), here, now that we have `BlockArguments'
23:59:26 <quiet_laika[m]> i never know how i decide between them
23:59:54 <sicklorkin> `f . b . c. d $ e`
