00:23:45 <dminuoso> Say I have some `[(Bool, String, Int)]` and some `String -> Maybe T`, is there some elegant way to do a traversal `[(Bool, String, Int)] -> Maybe [(Bool, T, Int)]` without using lens?
00:24:35 <c_wraith> sure.  use some other library that does the same thing
00:24:43 * dminuoso smiles
00:24:54 <dminuoso> c_wraith: So optics is the only short way?
00:25:11 <dminuoso> Short of transforming that function into `(Bool, String, Int) -> Maybe (Bool, T, Int)`
00:25:36 <c_wraith> yeah, it's a traverse with a modified version of that function
00:25:37 <phadej> you can write `_2` for 3-tuple manually
00:25:55 <phadej> does it comes from `lens` or somewhere else: irrelevant
00:56:00 * hackage boots 0.2.0.1 - IoC Monad in Haskell  https://hackage.haskell.org/package/boots-0.2.0.1 (leptonyu)
01:02:30 * hackage happy 1.19.12 - Happy is a parser generator for Haskell  https://hackage.haskell.org/package/happy-1.19.12 (SimonMarlow)
01:03:30 * hackage boots-app 0.2.0.1 - Factory for quickly building an application  https://hackage.haskell.org/package/boots-app-0.2.0.1 (leptonyu)
01:09:00 * hackage boots-web 0.2.0.1 - Factory for quickly building a web application  https://hackage.haskell.org/package/boots-web-0.2.0.1 (leptonyu)
01:14:39 <dminuoso> Why is there no "UNRESTRICTED" pragma. :(
01:14:49 <merijn> To do what?
01:15:03 <dminuoso> To mark a binding as unrestricted, in order to selectively disable MMR
01:15:21 <merijn> dminuoso: That's just called "a type annotation"
01:15:51 <dminuoso> merijn: Strictly speaking a type annotation might not be enough.
01:16:04 <merijn> dminuoso: Eh...why?
01:16:20 <dminuoso> merijn: non-simple bindings are exempt from that
01:18:27 <dminuoso> merijn: Or in other words, a decl group is unrestricted iff every variable in that binding is a function binding or a simple pattern binding, and an explicit type signature is given. So something like `f :<|> g = ...` is not a simple pattern binding and subject to MMR, even if you annotate it with a type signature.
01:19:31 <dminuoso> Let me be sure whether that example is correct. :)
01:19:54 <dminuoso> Yeah Im confident.
01:20:43 <merijn> dminuoso: Can you paste an example where it fails?
01:20:58 <dminuoso> merijn: Well I could cite the example from the Report
01:21:13 <dminuoso> [(n,s)] = reads t
01:25:06 <dminuoso> % f :: Num a => a -> a -> a; g :: Num b => b -> b -> b; (f,g) = ((+),(-)) -- merijn 
01:25:06 <yahb> dminuoso: ; <interactive>:64:1: error: Overloaded signature conflicts with monomorphism restriction f :: forall a. Num a => a -> a -> a
02:18:30 * hackage cachix 0.3.0 - Command line client for Nix binary cache hosting https://cachix.org  https://hackage.haskell.org/package/cachix-0.3.0 (domenkozar)
02:19:30 * hackage cachix-api 0.3.0 - Servant HTTP API specification for https://cachix.org  https://hackage.haskell.org/package/cachix-api-0.3.0 (domenkozar)
02:19:32 * hackage these-optics 1 - Optics for These  https://hackage.haskell.org/package/these-optics-1 (phadej)
02:46:22 <trcc> Hi. I am trying to create a docker image with a haskell application that uses stack. But it takes a lot of memory and a long time to build my application, is there any way to have prebuilt libraries in Haskell?
02:47:12 <dminuoso> trcc: Stack does caching itself surely. You can bind-mount the relevant directories.
02:47:15 <merijn> trcc: Haskell libraries/executables are "just libraries" in the same way C/C++/Rust applications/libraries are, so yes
02:47:20 <jgt> trcc: If you use Nix you get to take advantage of binary caches, but I don't know what the equivalent is in the Docker world
02:48:13 <dminuoso> trcc: Here we use cabal and build inside docker containers. We have a per-build node cabal cache, which we bind-mount into each container.
02:48:18 <merijn> trcc: So the answer is "Yes" and the answer to "how?" is "the same way all the C/C++/etc. people do it" (which, admittedly is probably the painful way...)
02:48:47 <merijn> trcc: If you only have to support a small set of OSes you can just build once for each and then ship the resulting binary
03:08:02 <trcc> Okay thank you
03:08:11 <trcc> Was hoping there was some online place with prebuilt binaries
03:08:17 <trcc> but that is Nix I guess
03:16:08 <dminuoso> Mmm, lets say I have a cabal project and its failing on a servant type error. Id like to have GHC fully expand the type synonym without recompiling everything.
03:21:08 <asheshambasta> current stack user here, I use emacs + intero for my setup. But as my project has grown larger, intero has started to really hog mem. + performance. I'm also a new NixOS user so I've been meaning to make the switch to a fully nix driven development setup. Is there some place I can read on how to approach this? 
03:24:49 <jgt> asheshambasta: I'm not sure there's a single resource that covers everything
03:25:08 <jgt> there's plenty written on the topic; just need to google for it
03:25:52 <asheshambasta> jgt: yeah, thats what I figured, but was hoping to find a resource that defined an example approach from start to finish. 
03:26:23 <jgt> asheshambasta: did you look at Gabriel Gonzalez's haskell/nix repository?
03:26:48 <jgt> asheshambasta: https://github.com/Gabriel439/haskell-nix
03:28:07 <asheshambasta> cool, thanks 
03:32:50 <homebeach[m]> Is Haskell useful for graphics programming?
03:33:29 <[exa]> depends on what kind. Image processing? Ray tracing? Interactive/games?
03:33:52 <[exa]> (but basically yes, there are nice Hs applications for all of these)
03:37:39 <maerwald> homebeach[m]: hard
03:37:49 <maerwald> not much coverage in terms of libraries/frameworks
03:40:04 <homebeach[m]> Will I get any benefits using Haskell?
03:40:15 <homebeach[m]> For graphics
03:52:21 <simon> is it bad to call a function 'fromList' when it has the type '[x] -> Maybe (MyType x)'? I mean, wrt. the Maybe.
03:52:56 <simon> so Data.Set.fromList, Data.Map.fromList will all produce a result with no chance of errors.
03:53:39 <jgt> simon: how could either of those cases fail?
03:53:45 <tdammers> homebeach[m]: you will get the usual benefits: type safety, purity, the ability to reason about code and have that reasoning verified by the compiler, safe refactoring
03:54:30 <tdammers> homebeach[m]: but you will also run into Haskell's downsides, especially that optimizations involving in-place mutations require more ceremony, and that it is difficult in general to reason about performance
03:55:15 <simon> jgt, they can't. but I'm building a module called ForumThread with a 'fromList :: [Record] -> Maybe ForumThread'.
03:55:29 <simon> jgt, I wonder if calling it 'fromList' is breaking with some convention of always producing a result.
03:55:56 <phadej> you don't
03:56:41 <jgt> simon: I wouldn't worry about it. We lean on the type-checker more than naming conventions anyway.
03:57:10 <jgt> I mean, it's still good you're concerned with naming things appropriately
03:57:17 <jgt> but in this case I wouldn't worry about it
03:57:32 <phadej> e.g. https://hackage.haskell.org/package/vec-0.1.1.1/docs/Data-Vec-Lazy.html#v:fromList is similar fromList ::  [a] -> Maybe ...
04:09:45 <dminuoso> phadej: Regarding earlier, how would I construct a simple version of `each`? The lens implementation seems quite convoluted to the point that I cant make sense of it.
04:11:31 <dminuoso> OHh wait it just instantly hit me.
04:11:42 <dminuoso> each :: Traversal [a] [b] a b; each = traverse; 
04:11:44 <dminuoso> o.o
04:12:24 <dminuoso> (Im even more confused about what this lens implementation with conjoined is about)
04:14:30 * hackage ghc-lib-parser 0.20190903 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-parser-0.20190903 (shayne_fletcher)
04:15:30 * hackage ghc-lib 0.20190903 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-0.20190903 (shayne_fletcher)
04:15:46 <dminuoso> phadej: You meant something like this, right? https://gist.github.com/dminuoso/b88c953cf23e7d87aed2c9c5d9fcbed5
04:23:53 <phadej> dminuoso: each? Did you mean _2? "traverse"
04:25:00 <dminuoso> phadej: Oh, I didn't copy paste enough, `each = traverse`
04:26:22 <dbaldwin> \join #haskell-beginners
04:26:34 <dminuoso> The revelation here is that lenses and traversals are basically just traversal-like functions that I can apply to things.
04:27:24 <dminuoso> Before that, I thought you could only use Const and Identity.
04:27:25 <phadej> traversals are traversal-like functions" ;)
04:27:38 <dminuoso> Oh heh.
04:27:44 <dminuoso> Well, *traverse-like! :)
04:27:52 <dminuoso> % :t traverse
04:27:53 <yahb> dminuoso: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
04:28:08 <phadej> @src traverseOf
04:28:08 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
04:28:27 <phadej> https://hackage.haskell.org/package/lens-4.17.1/docs/src/Control.Lens.Traversal.html#traverseOf
04:28:36 <dminuoso> traverseOf ≡ id
04:28:37 <dminuoso> o_o
04:30:12 <dminuoso> What kind of consistency is it that the lens documentation says?
04:30:42 <dminuoso> Is it that in general you have some sort of combinator that "applies an optic to some data" (say `set`, `get` or `over`)?
04:32:00 * hackage witherable 0.3.3 - filterable traversable  https://hackage.haskell.org/package/witherable-0.3.3 (FumiakiKinoshita)
04:32:17 <maerwald> lens: strongly typed duck typing :o
04:40:32 <yorick> phadej: can you tag servant v0.16.2 on github?
04:41:32 <phadej> yorick: I can, a sec
04:41:37 <yorick> thanks! :)
04:41:46 <yorick> phadej: 5285011233575354ded4df2a022af4b2ad24cf6b
04:43:06 <phadej> yorick: yes, I know. done.
04:43:26 <yorick> phadej: wonderful
04:43:29 <phadej> (as in, yes I know which commit I made release from)
04:44:25 <yorick> I had it in my clipboard already, so I thought it might save you time looking it up
05:01:23 <jumper149> Hi, I want to read a list from StdIn and reorder it within a 3 second time span. What do I have to look into, will `threadDelay` be enough?
05:01:53 <merijn> I'm not really sure how the problem statement and threadDelay relate?
05:04:24 <jumper149> Something along the lines of `do { in <- readList ; threadDelay 3 ; putStrLn (reOrder in) }`
05:04:54 <jumper149> But I have a feeling that wouldn't help
05:05:25 <dmwit> I'm with merijn.
05:05:58 <dmwit> If you have a deadline, you can only make your chances of hitting the deadline worse by not doing stuff for a while.
05:06:23 <merijn> threadDelay 3 will definitely not work, regardless of your intentions since threadDelay doesn't take input in seconds ;)
05:07:00 <merijn> That will block for 0.000003 s (probably more, on account of overhead)
05:07:26 <jumper149> My other idea was to have two threads running and an MVar as a sort of buffer
05:07:38 <merijn> jumper149: You still haven't described what you want to do
05:07:49 <merijn> What does "within a 3 second time span" mean?
05:08:14 <merijn> What do you want to do within those 3 seconds? What should happen if it takes longer/shorter? etc.
05:08:48 <dmwit> And especially: what don't you like about `readList >>= putStrLn . reOrder`?
05:12:17 <jumper149> dmwit: I was thinking, that would wait until the input was completely read?
05:13:53 <jumper149> I want to order packets Im receiving via a PcapHandle and reOrder them with the data they are containing which is a time
05:15:34 <trcc> I need to print the current working directory to the console, and I was hoping to just do something like trace Dir.getCurrentDirectory, but the issue is that Dir.getCurrentDirectory is IO (Filepath). So how could I insert it something like here: https://github.com/CThuleHansen/HsBeFMI/blob/master/src/Lib.hs#L32?
05:17:31 <merijn> trcc: You can just to "liftIO Dir.getCurrentDirectory >>= traceM" or something along those lines, assuming that the scotty monad is a MonadIO instance
05:17:37 <jgt> trcc: getCurrentDirectory >>= print
05:17:47 <merijn> Or just print, I suppose, yeah
05:18:27 <Ariakenom> or: dir <- getCurrentDirectory; print dir
05:18:39 <merijn> Still needs liftIO, though :p
05:19:25 <trcc> I tried something like that but got https://pastebin.com/p7iK4QQZ
05:19:38 <dmwit> jumper149: uh
05:20:00 <trcc> sorry sec
05:20:00 <dmwit> jumper149: How do you know that all the packets are going to arrive within three seconds?
05:20:06 <jgt> trcc: did you use liftIO like merijn said? :)
05:21:06 <trcc> expected type Scotty.ScottyT TL.Text IO () actual type: IO () in a stmt of a 'do' block: liftIO getCurrentDirectory >>+ print
05:21:24 <phadej> liftIO (getCurrentDirectory >>= print)
05:21:33 <dmwit> jumper149: Do you mean you want, like, a sliding window of 3 seconds of packets that you have not yet sorted, and want to output any older than 3 seconds in sorted order, or something like that?
05:21:50 <trcc> no instance for monadIO (Scotty...) jgt
05:21:52 <dmwit> jumper149: I guess I really don't understand your goals.
05:21:53 <trcc> no instance for monadIO (Scotty...) phadej
05:22:05 <phadej> trcc: then you are out of luck
05:22:18 <trcc> darn
05:22:27 <merijn> Then you're stuck unsafePerformIO'ing your way through
05:22:29 <jumper149> dmwit: Yes that's exactly what I mean
05:22:42 <exarkun> Using tasty-discover I often get "test/Driver.hs:17:18: error: parse error on input `#'" which is pretty annoying to debug.  any tricks for dealing with this?  or should I just stop using tasty-discover?
05:22:53 <jgt> Yesod makes this so much easier… hint hint
05:22:54 <dmwit> jumper149: Okay. I don't think threadDelay is useful for that at all.
05:23:07 <dminuoso> exarkun: On what input? What does the source file contain?
05:23:11 <phadej> exarkun: impure preprocessors are a bit fishy :/
05:23:18 <exarkun> dminuoso: "lots of stuff"
05:23:29 <dminuoso> exarkun: That's very unspecific.
05:23:31 <dmwit> jumper149: Consider using a priority queue instead. Every so often, pop the oldest one off the heap until you see one that's too new, then push that one back on.
05:23:37 <exarkun> dminuoso: I know
05:23:41 <dmwit> jumper149: Push them on the heap as they arrive.
05:23:46 <dminuoso> exarkun: I doubt that tasty-discover chokes with that error message on the basis of your file having "lots of stuff"
05:24:05 <exarkun> dminuoso: But it does have lots of stuff
05:24:07 <dmwit> jumper149: Sorry, s/heap/queue/g. Heaps are just one implementation technique.
05:24:10 <exarkun> dminuoso: I can't fit it into one IRC message
05:24:21 <dminuoso> exarkun: Then use gist?
05:24:34 <trcc> unsafeperformio it is. Thanks merijn
05:24:39 <trcc> and others :)
05:24:44 <exarkun> dminuoso: The point isn't that I *can't* find the error.  The point is that the error message tells me nothing about where the error is and thus finding the error takes a lot of effort.
05:24:55 <Ariakenom> jumper149: I tihnk you need to describe more of your situation. where are you getting your data from?
05:24:55 <exarkun> dminuoso: I don't want anyone to tell me what the error is, I want someone to tell me how to make finding the error easier.
05:25:24 <dminuoso> exarkun: What kind of help do you expect from this channel, if you neither tell us why you get the error message, nor show us the code provoking the error message?
05:25:43 <dminuoso> exarkun: How can we possibly tell you how to get better diagnostics, if you dont provide the necessary information to understand the surroundings of that diagnostic?
05:25:47 <exarkun> dminuoso: Okay.  Driver.hs is this line: {-# OPTIONS_GHC -F -pgmF tasty-discover #-}
05:26:01 <exarkun> dminuoso: because, as I understand it, that's how you use tasty-discover
05:26:08 <exarkun> I did mention I was using tasty-discover
05:26:16 <dminuoso> Yes.
05:26:47 <exarkun> I did assume one implied the other but I could be wrong about that, sorry.
05:27:41 <jumper149> I'm getting the data from `Network.Pcap.openLive` atm
05:29:07 <exarkun> phadej: Is there another test discovery tool you like?
05:29:59 <dminuoso> exarkun: I think I understand what your question is about. It seemed to me like you wanted to understand how to use tasty-discover better.
05:30:24 <dminuoso> exarkun: I wouldnt rely on discovery to begin with. Why not engineer your tests and tie them together via imports?
05:30:54 <exarkun> Tying them together with imports seems like it involves a lot of repetition on my part
05:30:55 <phadej> exarkun: I don't use test-discovery tools
05:31:08 <exarkun> I like to avoid repetition.  So, that's why discovery.
05:31:20 <phadej> (+ problems :)
05:31:20 <dminuoso> exarkun: There's nothing wrong with repitition in principle.
05:31:25 <exarkun> Really?
05:31:29 <dminuoso> Yes really.
05:31:30 <exarkun> Interesting.
05:31:45 <exarkun> Maybe you can explain that a little more.
05:32:09 <phadej> exarkun: if I'd be annoyed by repetition, i'd probably run some discovery tool "offline"
05:32:58 <dminuoso> exarkun: Overall I think some software developers have deep fears of writing repetitive code. But realistically, why do you dislike it much? Do you think it takes too much time to write? Does it impact your ability to reason about how it works?
05:33:20 <jumper149> I think I can maybe get it working with a queue and `Network.Pcap.nextBS` as a way to keep the recursion going, that would unfortunately mean that the last packet will wait until the next one arrives (sorry, I can't explain it better x))
05:34:00 <dminuoso> exarkun: The price of finding some abstraction/generalization can cost more to implement that "repitition removal" and it can create unreadable and unmaintainable abstraction layers.
05:34:45 <exarkun> dminuoso: It does take time to write.  It's also another thing to remember to do.  Also, offhand, I'm not sure what tools are available to help avoid mistakes (like accidentally forgetting to import a test).  So it's more work and another opportunity for mistakes.
05:35:00 <dminuoso> exarkun: The time to write is a poor argument, since realistically typing speed is not the limiting factor. ;)
05:35:23 <exarkun> dminuoso: I can only stare at a screen for so many hours a day.  I like to make the most of them.
05:35:50 <dminuoso> exarkun: Then phadej's suggestiopn to run offline discovery tools is probably your best bet.
05:35:56 <exarkun> dminuoso: Also, test discovery is no problem in other languages that I'm familiar with so of course I start with a perspective (right or wrong) in my Haskell development that says I should look for test discovery tools.  And I find some!  So I am vindicated (correctly or incorrectly).
05:36:45 <dminuoso> exarkun: I think any language with strong compile-time modules will have the same problems.
05:36:46 <exarkun> And the weight of my experience isn't swayed by "just repeat yourself, it's not that bad" (but I'm quite interested in hearing other arguments than that)
05:36:57 <exarkun> Are there offline discovery tools for Haskell?
05:41:05 <phadej> exarkun: I think you can even run tasty-disover
05:41:10 <phadej> e.g. hspec-discover when run:
05:42:01 <dminuoso> exarkun: Im merely pointing out that programmers tend to have an irrational fear of repeitition. Discovery mechanisms for instance add an invisible magic flavour to your tests.
05:42:17 <exarkun> phadej: Ah, didn't realize that
05:42:24 <dminuoso> exarkun: Once compile-time auto discovery is enabled, you cant trivially even reason about your tests anymore. You cant say for certain what is being run.
05:42:42 <exarkun> dminuoso: That seems weird.
05:43:06 <exarkun> dminuoso: in contrash, "Once you compile your Haskell source code, you can't trivially even reason about your code anymore.  You can't say for certain what is being run."
05:43:40 <phadej> https://gist.github.com/phadej/2867e745a565341fe793916d4f11104e
05:43:41 <dminuoso> exarkun: A more appropriate comparison would be TemplateHaskell
05:44:08 <dminuoso> exarkun: The thing is, with Haskell I can still inspect Core code.
05:44:24 <dminuoso> exarkun: With auto-discover there's no trivial way to just see what the output of your magic compiler plugin is.
05:44:47 <exarkun> There's some flag that makes tasty-discover spit out what it generated.  I got it to work one time.
05:45:22 <dminuoso> exarkun: Its sort of why TemplateHaskell is somewhat annoying to use. You splice some code into your module, but if you open the file with your editor, you have no idea what this codes.
05:45:46 <dminuoso> You just see some $(foo). What does this do? It can have wide ranging impacts on your entire module.
05:46:04 <exarkun> Sure.  I won't argue with that.
05:46:15 <dminuoso> The Haskell 2010 semantics sort of disappear, and you cant employ standard Haskell reasoning techniques anymore.
06:19:49 <tabaqui1> is it true that for any "Monad m => fmap f $ pure x == pure $ f x"?
06:20:51 <merijn> tabaqui1: Yes
06:21:01 <merijn> tabaqui1: Well, for any *lawful* Monad :)
06:21:13 <tabaqui1> no, it is not :)
06:21:15 <tabaqui1> look
06:21:31 <tabaqui1> data Foo = Foo { foo :: forall x. x -> () }
06:21:45 <tabaqui1> newFoo :: Monad m => (forall x. x -> Int) -> m Foo; newFoo wrap = fmap Foo $ pure wrap
06:21:49 <tabaqui1> Couldn't match type ‘x0 -> Int’ with ‘forall x. x -> Int’
06:21:53 <merijn> tabaqui1: Foo cannot be a Functor it has the wrong kind
06:21:53 <tabaqui1> newFoo :: Monad m => (forall x. x -> Int) -> m Foo; newFoo wrap = pure $ Foo wrap
06:21:55 <tabaqui1> OK
06:22:13 <tabaqui1> Foo is not a functor, but just a function
06:22:18 <tabaqui1> it is a data constructor, right?
06:24:05 <merijn> tabaqui1: Only datatypes with kind "* -> *" can be monads. Your Foo datatype has kind * and thus cannot be a Functor, Applicative, or Monad
06:24:21 <tabaqui1> Foo is not a Functor nor a Monad
06:24:32 <tabaqui1> let's use IO for example
06:24:48 <tabaqui1> newFoo :: (forall x. x -> Int) -> IO Foo; newFoo wrap = fmap Foo $ pure wrap
06:25:26 <merijn> That's a type error
06:25:47 <tabaqui1> but "pure $ Foo wrap" is not
06:25:50 <merijn> Yes it is
06:26:06 <tabaqui1> check it
06:27:23 <merijn> tabaqui1: You had "wrap :: (forall x . x -> Int)" and "Foo :: forall x . x -> ()" that doesn't match
06:27:37 <tabaqui1> oh, sorry, bad copy paste
06:27:49 <tabaqui1> replace it with forall x. x -> (), please
06:28:30 <merijn> The problem is that you're trying to pass a RankN typed function to pure, which requires ImpredicativeTypes, which isn't possible
06:28:41 <tabaqui1> yeah, probably
06:28:56 <tabaqui1> so I cannot juse use applicative law here?
06:29:37 <tabaqui1> *Applicator law?
06:31:07 <merijn> tabaqui1: "pure wrap" will already be a problem
06:33:31 <tabaqui> There is a page on the wjki
06:33:43 <tabaqui> Ok, thanks I'll read it
06:37:58 <exarkun> Does anyone know of an example of using QuickCheck with hspec-wai with an IO input?  I've been trying to construct a minimal example but this is about as close as I can get, https://github.com/exarkun/QuickCheckIOApplication/blob/master/test/Spec.hs
06:38:12 <exarkun> I know `prop` there is a load of gibberish but I dunno what else to do
06:54:35 <dminuoso> Servant question. What'd be an elegant way to maintain an up-to-date markdown documentation of the API in a gitlab repo? Would you simply rely on manually updating some API.md file? Pre-push hook?
06:57:11 <exarkun> Seems like just about all projects maintain their API docs outside of their Git repo.  eg on readthedocs or something else similar.
06:58:15 <simon> dminuoso, https://hackage.haskell.org/package/servant-pandoc ?
06:58:31 <simon> dminuoso, https://hackage.haskell.org/package/servant-swagger seems even more swag.
06:59:26 <dminuoso> simon: The issue is not the rendering part, Ive included the standard servant-doc markdown renderer as a command of my program.
06:59:44 <dminuoso> \So I can simply run `cabal v2-run app -- generate-docs` and it will print the API docs and exit.
06:59:55 <simon> dminuoso, ah, you're wondering when to call this.
07:00:21 <lyxia> exarkun: make prop a function Backend -> Property and run openBackend in main?
07:00:46 <dminuoso> simon: Oh wait a second, I think I have an idea!
07:01:00 <dminuoso> simon: Surely there must be some way to push markdown files into gitlab from a CI worker!
07:01:28 <simon> dminuoso, I'd think so.
07:02:23 <dminuoso> simon: Though.. this is racy as heck. No I dont like it.
07:02:30 <dminuoso> (Imagine to concurrent workers running)
07:02:54 <dminuoso> No matter how I churn it, this must land inside the repository, so pre-push seems to be the only sensible way
07:16:10 <Geekingfrog> I found in a few library (req, http-client-tls) the following pattern: a global thing (http manager) in an IORef. This is done with unsafePerformIO and the NOINLINE pragma. Why wrap it in an IORef and not simply expose the thing bare bone ?
07:16:43 <merijn> Geekingfrog: How would you change it?
07:16:45 <Geekingfrog> that is: globalThing :: MyGlobal   instead of globalThing :: IORef MyGlobal  
07:17:00 <Geekingfrog> the MyGlobal still requires unsafeperformIO because it runs some IO code
07:17:22 <merijn> Geekingfrog: How would you update the manager?
07:17:29 <Geekingfrog> it's not meant to be updated.
07:17:41 <dminuoso> Geekingfrog: In that case the IORef is fairly pointless.
07:17:44 <merijn> Geekingfrog: Based on what?
07:18:00 <EvanR> Managers usually have some state variables in it
07:18:09 <EvanR> and resource handles
07:18:15 <EvanR> not static values
07:18:30 * hackage hedis 0.12.8 - Client library for the Redis datastore: supports full command set,pipelining.  https://hackage.haskell.org/package/hedis-0.12.8 (k_bx)
07:18:34 <merijn> Geekingfrog: There's litterally a "setGlobalManager" in http-client-tls
07:19:42 <Geekingfrog> merijn, yes, but not in req, which uses another mechanism. Also, my usecase is slightly different, I only need a read-only thing
07:20:01 <merijn> Geekingfrog: If it's read only why do you need unsafePerformIO?
07:20:18 <Geekingfrog> because I need some IO to initialise the value (which won't change ever after)
07:20:27 <merijn> What sort of IO?
07:21:10 <Geekingfrog> and yes, I am aware of the other way to do similar thing. This was more a curiosity question about potential interplay between unsafePerformIO, IORef and toplevel declarations.
07:21:41 <EvanR> theres IVar for a variable you can update, perhaps with IO, once
07:21:54 <EvanR> everything that reads it (purely) would block until its set
07:22:24 <EvanR> if theres unsafePerformIO anywhere (unsafeInterleaveIO?) then you don't see it
07:22:55 <Geekingfrog> from control.monad.par ?
07:23:00 <EvanR> no
07:23:22 <EvanR> theres a few packages with different APIs... data-ivar ivar-simple at least
07:23:30 * hackage PyF 0.8.1.0 - Quasiquotations for a python like interpolated string formater  https://hackage.haskell.org/package/PyF-0.8.1.0 (guibou)
07:23:58 <exarkun> lyxia: yea ... seems like I can get that to work.  But it seems like it unpleasantly smears details about test implementation widely across the code base
07:26:50 <simon> dminuoso, at (non-Haskell) work we have some file containing checksums of .js files that were changed. we have a unit test that checks that the checksums add up. ideally we'd have a commit hook, but the amount of testing and validation is so overwhelming we'd rather do it at the CI level. but then CI'd fail and I'd have to go and update that file with checksums and push it for testing again.
07:28:17 <simon> dminuoso, so maybe you get tired of having documentation generating every time you commit something and you push the check that you did in fact generate the docs to CI, but you avoid race conditions by having the generated docs committed along with API changes.
07:28:23 <dminuoso> simon: Yeah... I just checked, gitlab cant do this in a ci-runner by the way. The technical reason is that you have effectively read-only access to the repo.
07:28:36 <dminuoso> simon: Its an interesting thought.
07:28:50 <simon> dminuoso, I think a CI runner with write access is a potential infinite loop :)
07:29:02 <dminuoso> simon: So basically I could simply run the doc generation in the ci pipeline, compare with whats checked in, and fail the pipeline otherwise.
07:29:09 <dminuoso> (Perhaps with a failable stage)
07:29:35 <dminuoso> simon: Im not suggesting write access to the git repo itself. Just say the wiki.
07:30:09 <simon> right
07:30:15 <dminuoso> simon: So I think a pre-commit hook is the smartest idea. The build should be instant, after all I should be running tests and compiling code before checking it in... ;)
07:30:33 <dminuoso> So it'd add maybe 2-3s to a commit because cabal has to do its things..
07:30:57 <simon> if you can get the commit hook down to that little and have it not grow proportional to the code base, that'd be excellent.
07:31:25 <simon> I mean, I suppose all you really need to check is "if I ran this compile command, would it say that I'd need to do something?" -- and without doing it, fail because you had to.
07:32:17 <dminuoso> I mean it just creates a new nightmare because of nix.
07:32:49 <merijn> dminuoso: Why woulc cabal take 2-3s? no-op v2 invocations are pretty fast*
07:33:22 <merijn> * - unless you're triggering a common bug because you subtly broke your environment without noticing :p
07:33:40 <dminuoso> merijn: Well okay perhaps its closer to 1s.
07:33:58 <dminuoso> merijn: (Unless I run it two times in a row - so I think it might be file caches/buffers doing their job)
07:34:07 <dminuoso> It just sometimes feels slower.
07:34:56 <merijn> dminuoso: Just for shits and giggles, can you "echo $PKG_CONFIG_PATH" and tell me what it is?
07:35:09 <dminuoso> merijn: not set.
07:35:28 <merijn> aww, then it's not my favourite super annoying problem >.>
07:36:08 <dminuoso> merijn: I think the delay might be due to my moderate dependency size.
07:36:12 <merijn> dminuoso: On my code "cabal v2-build" with no required recompilation only takes 0.3 wall clock time
07:36:19 <dminuoso> merijn: Is that after caches are hot?
07:36:27 <dminuoso> *primed
07:36:48 <merijn> dminuoso: I can't tell because the first run had to recompile something :)
07:37:13 <merijn> So the second run files were hot already
07:37:33 <merijn> dminuoso: My freeze file is 218 dependencies big, so I doubt that's it?
07:37:37 <dminuoso> merijn: I mean if my caches are primed, its about 0,25-0.3s too
07:47:20 <boxscape> It there a guide to ghc's core somewhere?
07:47:40 <merijn> boxscape: The GHC wiki on gitlab?
07:50:07 <boxscape> merijn Found the page on it, thank you
07:50:26 <boxscape> ( https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/core-syn-type )
07:51:43 <exarkun> I guess I don't really understand how https://github.com/exarkun/QuickCheckIOApplication/blob/master/test/Spec.hs#L68-L73 works.  How does post' find the application?
07:51:53 <tabaqui1> hmm
07:52:10 <tabaqui1> data Foo where Foo :: Constraint x => { foo :: x } -> Foo
07:52:13 <tabaqui1> is not the same as
07:52:23 <tabaqui1> data Foo where Foo :: { foo :: Constraint x => x } -> Foo
07:53:02 <tabaqui1> the last one is mostly useless
07:54:24 <dminuoso> tabaqui1: Gah wait a second. You can mix GADT with fields?
07:54:27 <dminuoso> o.o
07:54:47 <dminuoso> tabaqui1: Is it really useless?
07:55:10 <tabaqui1> dunno, I can't just pass it in the function that requires Constraint
07:55:14 <dminuoso> tabaqui1: Say `data Foo where Foo { num :: Num x => x } -> Foo` allows you carry a polymorphic number around..
07:55:21 <tabaqui1> GHC wants me to define constraint explicitly
07:55:43 <tabaqui1> *declare
07:56:52 <tabaqui1> dminuoso: you can try to run some "f :: Num x => x -> ()" with "num yourFoo" and get a type error
07:57:00 * hackage syb-with-class 0.6.1.11 - Scrap Your Boilerplate With Class  https://hackage.haskell.org/package/syb-with-class-0.6.1.11 (JeremyShaw)
07:57:05 <boxscape> ugh these field type annotations are really confusing when the real type is `Foo -> (forall x . Constraint x => x)` (is that right even?)
07:57:35 <dminuoso> boxscape: Foo :: forall x. Constraint x => x -> Foo
07:57:42 <merijn> dminuoso: You didn't know that? :)
07:57:45 <boxscape> right, that's the constructor
07:57:47 <dminuoso> merijn: No.
07:57:48 <boxscape> I meant the field
07:57:53 <merijn> dminuoso: The syntax for GADT records is kinda ugly, but still
07:58:00 <dminuoso> merijn: I honestly assumed you couldn't have fields.
07:58:15 <dminuoso> boxscape: Ohh wait, I see whatu mean
07:58:33 <dminuoso> boxscape: You can float out the forall to the left.
07:58:34 <tabaqui1> hah
07:58:46 <tabaqui1> % data Foo where Foo :: { foo :: Num x => x } -> Foo
07:58:46 <yahb> tabaqui1: 
07:58:48 <boxscape> oh, okay
07:58:50 <tabaqui1> % :t foo
07:58:51 <yahb> tabaqui1: ; <interactive>:1:1: error:; * Cannot use record selector `foo' as a function due to escaped type variables; Probable fix: use pattern-matching syntax instead; * In the expression: foo
07:58:56 <dminuoso> what
07:59:06 <dminuoso> Oh!
07:59:09 <dminuoso> This makes perfect sense.
07:59:17 <tabaqui1> % data Bar where Bar :: Num x => { bar :: x } -> Bar
07:59:17 <yahb> tabaqui1: 
07:59:21 <tabaqui1> % :t bar
07:59:22 <yahb> tabaqui1: ; <interactive>:1:1: error:; * Cannot use record selector `bar' as a function due to escaped type variables; Probable fix: use pattern-matching syntax instead; * In the expression: bar
07:59:44 <dminuoso> Since when doesnt GHC talk about scary skolem golems anymore?
07:59:52 <boxscape> it did to me yesterday
07:59:56 <tabaqui1> % :t succ . foo
07:59:56 <yahb> tabaqui1: ; <interactive>:1:8: error:; * Cannot use record selector `foo' as a function due to escaped type variables; Probable fix: use pattern-matching syntax instead; * In the second argument of `(.)', namely `foo'; In the expression: succ . foo
07:59:59 <tabaqui1> % :t succ . bar
08:00:00 <yahb> tabaqui1: ; <interactive>:1:8: error:; * Cannot use record selector `bar' as a function due to escaped type variables; Probable fix: use pattern-matching syntax instead; * In the second argument of `(.)', namely `bar'; In the expression: succ . bar
08:00:02 <tabaqui1> uh
08:01:07 <boxscape> % runST (newSTRef "test")
08:01:08 <yahb> boxscape: ; <interactive>:72:8: error:; * Couldn't match type `a' with `STRef s [Char]'; because type variable `s' would escape its scope; This (rigid, skolem) type variable is bound by; a type expected by the context:; forall s. ST s a; at <interactive>:72:1-23; Expected type: ST s a; Actual type: ST s (STRef s [Char]); * In the first argument of `runST',
08:01:14 <boxscape> rigid skolem golem
08:01:28 <dminuoso> % unbox :: Num x => Foo -> x; unbox (Foo f) = f
08:01:29 <yahb> dminuoso: ; <interactive>:73:45: error:; * Couldn't match expected type `x' with actual type `x1'; `x1' is a rigid type variable bound by; a pattern with constructor: Foo :: forall x. (Num x => x) -> Foo, in an equation for `unbox'; at <interactive>:73:36-40; `x' is a rigid type variable bound by; the type signature for:; unbox :: forall x. Num x => Foo -> x; 
08:01:53 <dminuoso> % unbox :: Foo -> (forall x. Num x => x); unbox (Foo f) = f
08:01:53 <yahb> dminuoso: ; <interactive>:74:57: error:; * Couldn't match expected type `x' with actual type `x1'; `x1' is a rigid type variable bound by; a pattern with constructor: Foo :: forall x. (Num x => x) -> Foo, in an equation for `unbox'; at <interactive>:74:48-52; `x' is a rigid type variable bound by; the type signature for:; unbox :: Foo -> forall x. Num x => x; 
08:02:18 <dminuoso> boxscape: I think GHC is very inconsistent wrt to how it calls skolems.
08:02:35 <dminuoso> It should either use this (rigid, skolem) everywhere, or just call them rigids everywhere.
08:02:54 <dminuoso> As far as I understand it, rigid means skolem.
08:03:10 <boxscape> skolem IIRC means "exists" encoded with "forall"
08:03:34 <dminuoso> boxscape: No. skolems are very different from existentials
08:04:00 <boxscape> hm, I read that in a footnote in the thinking with types yesterday, but I might have misunderstood or be misremembering
08:04:00 * ski smiles
08:04:11 <dminuoso> ski: You smile because it was you who taught me this! :)
08:04:17 <ski> yea :)
08:05:42 <dminuoso> boxscape: One perspective I learned was, skolems is what you get by consuming existentials or producing universals.
08:06:04 <dminuoso> (as a very rough, short and handwaving notion)
08:06:10 <boxscape> okay
08:06:39 <merijn> To me skolems are just "I screwed up something" :p
08:10:39 <dminuoso> boxscape: So the dual notion of skolem is sometimes called metavariable. So if we consider an existential or a univeral quantified type variable, then we have both a corresponding skolem or metavariable for both, depending on whether we take the perspective of the consumer or the producer.
08:11:10 <dminuoso> Ah they just left.
08:11:37 <dminuoso> Where is solonarv anyway, haven't seen them around.
08:16:05 <EvanR> skolems are a thing to be zonked
08:16:39 <Zemyla> The skolem has escaped! Alert the wizards and evacuate the village!
08:22:14 <tabaqui1> I have an issue, but I'm not sure that can solve it without constraints package
08:22:26 <tabaqui1> I want to wrap some function in such way
08:23:17 <tabaqui1> data Wrapper p = Wrapper { func :: forall x. Num x => x -> (Num (p x) => p x) }
08:23:23 <tabaqui1> so we can wrap any function
08:23:54 <tabaqui1> that can accept any Numeric and guarantee that (p x) is a Numeric too
08:24:46 <tabaqui1> at first I tried such signature "func :: forall x. (Num x, Num (p x)) => x -> p x)" but it means that function can deal with any Numeric x, such that p x is also Numeric
08:24:51 <tabaqui1> it is not what I want
08:25:27 <tabaqui1> probably I can deliver the proof inside a Wrapper with constraints, but I don't want it
08:25:41 <EvanR> isn't x -> (Num _ => _) the same as Num _ => x -> _
08:25:52 <tabaqui1> it seems so
08:26:28 <EvanR> which then can coalesce back into (Num x, Num _)
08:26:33 <tabaqui1> but I want to restict the set of possible functions, not theirs arguments
08:26:42 <tabaqui1> *their
08:27:07 <lyxia> who should provide the Num (p x) instance?
08:27:18 <lyxia> the function?/
08:27:20 <tabaqui1> yes
08:28:25 <AviD> \n When will 8.8 hit stack nightly
08:30:00 * hackage canon 0.1.1.4 - Arithmetic for Psychedelically Large Numbers  https://hackage.haskell.org/package/canon-0.1.1.4 (grandpascorpion)
08:30:13 <lyxia> tabaqui1: what's wrong with a Wrapper with constraints
08:30:17 <tabaqui1> yes
08:30:24 <tabaqui1> oh, sorry
08:30:28 <tabaqui1> missclick:)
08:30:43 <tabaqui1> I never used constraints before
08:31:21 <tabaqui1> I'm afraid that I will drown in the code that I hardly understand
08:31:39 <lyxia> I don't think the constraints library is necessary from what you told us so far.
08:32:07 <tabaqui1> Right now, I'm trying to add simple Proxy holding the proof
08:33:15 <lyxia> what I understood from "a Wrapper with constraints" would be just a GADT but maybe I understood what you meant wrong? In which case my question is "have you tried using GADTs"
08:34:12 <lyxia> I'm confused because a Proxy can't hold anything
08:34:59 <tabaqui1> sure, it is a GADT
08:35:21 <tabaqui1> but later I get an error like "Could not deduce (Num (p t))"
08:36:23 <tabaqui1> problem is that "forall x. (Num x, Num (p x)) => ..." mostly is a restriction on possible 'x', but not the function
08:37:09 <tabaqui1> like our wrapper can accept only very specific x's, but how can I guarantee that my arbitrary "y" implies "Num (p y)"?
08:37:26 <tabaqui1> sorry for the grammar
08:37:55 <boxscape> dminuoso don't worry I still read your message :)
08:38:32 <lyxia> tabaqui1: is this what you're looking for   (Num x, forall y. Num (p y)) => ...   ?
08:39:01 <tabaqui1> but is is no polymorphic on 'x'
08:39:13 <tabaqui1> let me try
08:39:19 <lyxia> what is not polymorphic on 'x'
08:39:40 <lyxia> It's an extension (QuantifiedConstraints) that's only available since GHC 8.6
08:40:02 <tabaqui1> uh, isn't "forall x. (Num x, forall y. Num y)" the same as "forall x y. (Num x, Num y)"?
08:40:09 <lyxia> no
08:40:50 <tabaqui1> 8.6.1 to be precise
08:41:00 <tabaqui1> I didn't know about it, thanks
08:41:35 <boxscape> dminuoso I just checked by the way, and what Sandy Maguire says in Thinking with Types is "A *skolem* is, for all intents and purposes, any existential type. [1]" and footnote 1: "Mathematically, it's an existentially quantified variable expressed in termss of a forall quantifier. [...]" So is that just wrong?
08:42:08 <geekosaur> loose, I think.
08:46:33 <boxscape> could (forall y . Num y) ever be solved? Seems like it would require every type to be an instance of Num
08:47:10 <tabaqui1> lyxia: it helps, thanks
08:47:36 <tabaqui1> still need to write some pattern-matching code, and there is an issue with constructor
08:47:42 <tabaqui1> but I think, I can solve it
08:49:52 <EvanR> (forall y . Num y) => A -> B, what can this function do with the constraint
08:50:47 <boxscape> nothing?
08:50:49 <EvanR> is that a sort of existential?
08:51:08 <EvanR> you can build "dunnos" from an Integer maybe?
08:51:25 <EvanR> seems like skolem would escape
08:51:41 <tabaqui1> I see no problems here
08:52:04 <tabaqui1> % foo :: (forall x. Num x) => Int -> Int; foo = (+) 2
08:52:05 <yahb> tabaqui1: 
08:52:08 <tabaqui1> % foo 5
08:52:08 <yahb> tabaqui1: ; <interactive>:80:1: error:; * No instance for (Num x) arising from a use of `foo'; Possible fix: add (Num x) to the context of a quantified context; * In the expression: foo 5; In an equation for `it': it = foo 5
08:52:14 <tabaqui1> oh, I see
08:52:23 <tabaqui1> % foo @Int 5
08:52:23 <yahb> tabaqui1: ; <interactive>:81:1: error:; * Cannot apply expression of type `Int -> Int'; to a visible type argument `Int'; * In the expression: foo @Int 5; In an equation for `it': it = foo @Int 5
08:54:27 <boxscape> you can't apply a type to foo because the scope of the forall is only within the constraint
08:56:06 <tabaqui1> right
08:56:29 <glguy> (you can't apply foo to a type...)*
08:56:34 <tabaqui1> so it is a sort of absurd function
08:56:35 <boxscape> oh, right
08:57:04 <boxscape> "TypeApplication" just makes it feel like applying types is what we're doing
08:57:29 <EvanR> foo @ type, @ is applying stuff together symmetrically :P
08:57:29 <boxscape> s/feel/sound
08:58:45 <tabaqui1> there was an extension to write aliases for constraints
08:58:50 <tabaqui1> can you remind it, please?
08:59:09 <lyxia> ConstraintKinds, doesn't GHC tell you that?
08:59:20 <tabaqui1> Expected a type, but ‘T.Protocol (p y)’ has kind ‘Constraint'
08:59:36 <tabaqui1> uh, and I declared ConstraintKinds already
08:59:52 <lyxia> that's a different error
09:00:06 <tabaqui1> type ArbitraryProtocol p = forall y. T.Transport y => T.Protocol (p y)
09:00:39 <tabaqui1> (Transport and Protocol are type classes of course)
09:00:45 <lyxia> I think you have to annotate it ... :: Constraint
09:01:27 <tabaqui1> parse error
09:01:36 <tabaqui1> type A p = blah :: Constraint
09:01:44 <tabaqui1> and "type A p :: Constraint = blah"
09:01:59 <tabaqui1> (replace blah with the correct line)
09:02:26 <tabaqui1> type families, probably
09:03:15 <boxscape> or you could make a new class instead of a type synonym, but if you can do it with type families that's probably better
09:04:22 <lyxia> tabaqui1: parentheses   = (forall p ... => ... :: Constraint)
09:04:24 <tabaqui1> type families, probably
09:04:27 <tabaqui1> ah, sorry
09:05:04 <tabaqui1> gtk raises a notification just before I want to run build :)
09:05:12 <tabaqui1> so I press Up and Enter automatically
09:06:02 <tabaqui1> lyxia: yeah, that works
09:06:06 <tabaqui1> thanks again
09:18:03 <exarkun> How do I reach the VoucherDatabase from https://github.com/PrivateStorageio/PaymentServer/blob/7.redeem-interface/test/SpecRedemption.hs#L84 down at line 94?
09:19:28 <lavalike> exarkun: I guess you have to move the argument of 'before' out and give it a binding
09:20:01 <exarkun> There seem to be two challenges related to that solution
09:20:20 <exarkun> Putting it in `before` means `getDatabase` is evaluated for every iteration of QuickCheck property evaluation, right?
09:20:53 <exarkun> If there's only one evaluation then it'll collect state and complicated defining the properties, I think
09:20:54 <lavalike> I'm unfamiliar with the specifics of `before'
09:21:04 * exarkun nods
09:22:06 <exarkun> The other challenge is just that I can't seem to figure out the mechanics of that transformation
09:23:05 <exarkun> my attempt and the error is here - https://gist.github.com/exarkun/1ff3857a98b12b348e965c8f7587e298
09:23:31 <lavalike> exarkun: make_spec_db getDetabase = do database <- runIO getDatabase; ...
09:24:42 <exarkun> I get a syntax error on the `d` of the describe following the `before` call
09:25:00 <exarkun> and I can't see the problem
09:25:12 <lavalike> you need to indent describe at the very least
09:26:01 <exarkun> dang.  I still have so many blinds spots.
09:27:54 <c_wraith> runIO seems like it'll still have the same issue with only running once. 
09:28:25 <Zemyla> :t \t f s -> runMaybeApply $ unConfuse (((id :: LensLike f s t a b -> LensLike f s t a b) t) (\a -> Confuse $ \y -> MaybeApply $ Left $ either (Data.Functor.Apply.<.>) fmap (runMaybeApply $ y id) (f a)) s) (\y -> MaybeApply $ Right $ y id)
09:28:25 <c_wraith> but you can create an action to clear the memory database and put it in a before
09:28:26 <lambdabot> Apply f => LensLike (Confuse (MaybeApply f)) s a1 a2 b -> (a2 -> f b) -> s -> Either (f a1) a1
09:28:27 <lavalike> yeah I was just demonstrating that half the problem, well solution
09:30:39 <exarkun> fixing indentation and then fixing the property (adding liftIO) gets it compiling and running, thanks for that.
09:30:45 <exarkun> probably need to refresh my understanding of indentation rules
09:30:59 <exarkun> since I have no idea what difference that particular bit of indentation makes
09:32:58 <lavalike> I wonder, if you were to write the do block in the more baroque way, as do { a; b; .. } if it would still complain about that indentation
09:33:55 <lavalike> (or if, once you opt out of the meaningful indentation, you are then allowed to write it like you did)
09:36:50 <c_wraith> indentation works by inserting the implicit {;} during parsing. if they're already explicitly present, they're not inserted. 
09:45:04 <lavalike> that's how do blocks are written in ghc's sources, if you like that style you can have your preferred indentation (:
09:48:00 <Athas> I think it's just SPJ's style.
09:48:07 <Athas> He does it like that in non-GHC code as well.
09:48:43 <jgt> this "SPJ" must be a Haskell beginner
09:48:58 <lavalike> yup, he's only just getting started >:)
09:49:37 * jgt is waiting for someone to shoot him
09:49:43 <boxscape> you could say he's *the* haskell beginner (though there were some others as well I suppose)
09:51:14 <hc> =)
09:58:00 * hackage jailbreak-cabal 1.3.5 - Strip version restrictions from Cabal files  https://hackage.haskell.org/package/jailbreak-cabal-1.3.5 (PeterSimons)
09:59:30 * hackage plugins 1.6.0 - Dynamic linking for Haskell and C objects  https://hackage.haskell.org/package/plugins-1.6.0 (JeremyShaw)
10:07:56 <d34df00d> Hi!
10:08:27 <d34df00d> Let's say I have a `newtype SomeId tag = SomeId { getId :: Int }` in one module, and I'd like to derive some class `FromHttpApiData` for this newtype in another module.
10:08:46 <d34df00d> If I  do `deriving newtype ...` I get a warning about orphan instances (which makes sense).
10:09:28 <d34df00d> But I cannot wrap that newtype into yet another newtype and use GND on that because the underlying newtype doesn't implement that class.
10:09:45 <d34df00d> So what should I do if I want to both avoid orphan instances as well as avoid writing the instance by hand?
10:11:34 <Cale> Is it a library or executable?
10:11:45 <Cale> If it's an executable, don't worry about orphan instances at all.
10:11:53 <d34df00d> Executable for now, so I guess I could ignore orphans, but I'm planning to move that to a lib.
10:11:59 <hyperisco> hashtag misused type classes
10:12:11 <d34df00d> hyperisco: why?
10:12:25 <hyperisco> hmm no  hashtag type class misuse
10:12:30 <Cale> Can you just move the instance into the same module as the type?
10:12:35 <Cale> Or the same module as the class?
10:13:34 <d34df00d> That kind of breaks modularity, I think. The DB layer shouldn't know anything about its types being later used with Servant.
10:13:43 <d34df00d> One might argue, though, that I'm already breaking that modularity to some extent.
10:14:24 <lyxia> IMO it's fine to turn off the warning, and if you really want to avoid the problem "avoid orphans" is meant to avoid, you can still make whatever module that users import to get SomeId also import the instances.
10:14:44 <Cale> Is it coercible?
10:14:44 <hyperisco> Type classes should not be used to encode or decode data.
10:14:50 <Cale> Maybe you can use DerivingVia?
10:14:56 <d34df00d> Cale: yep, it's just a newtype.
10:15:07 <d34df00d> Hmm... Let me try that.
10:15:22 <Cale> (via Int)
10:15:42 <d34df00d> hyperisco: From/ToJSON? From/ToCSV (or whatever cassava does)? Endless number of From/To classes in DB layers?
10:16:17 <hyperisco> Shocking isn't it?
10:16:44 <Cale> I dunno, I think it's sane to have some default encoding for things
10:16:56 <Cale> It perhaps shouldn't be the *only* way though.
10:17:15 <Cale> Aeson in particular makes it a little bit annoying not to use its classes to define the encoding.
10:17:34 <hyperisco> I came to Haskell to escape this sort of misguided magic but it found its way in anyhow. Web frameworks are a poison wherever they find themselves.
10:18:42 <exarkun> How should encoding and decoding be done?
10:18:57 <hyperisco> In just the right situation it can make sense. But programmers cling to them regardless, because it is easier, until it isn't. Like d34df00d's problem exemplifies.
10:22:52 <d34df00d> Uh... The tiny bit I don't like about DerivingVia is that it makes me spell out the underlying type that it's coercible to.
10:23:21 <d34df00d> While the GND automagic seems to hide this from me and makes me avoid this repetition.
10:23:31 <d34df00d> But otherwise it works. Thanks Cale!
10:27:12 <hyperisco> exarkun, essentially the same way, without the type class.
10:50:00 * hackage text-show-instances 3.8.2 - Additional instances for text-show  https://hackage.haskell.org/package/text-show-instances-3.8.2 (ryanglscott)
11:08:33 <exarkun> What about `Show`?
11:11:40 <hyperisco> Convenient for the REPL
11:12:20 <hyperisco> Also for debugging with print
11:15:49 <exarkun> so, eg, Crypto.Hash.Digest from cryptonite is erroneous because the interface it exposes for the string representation of digests is Show?
11:17:38 <hyperisco> Probably not a good use of Show, but I have not used the library.
11:18:00 * hackage haskell-src-exts 1.21.1 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer  https://hackage.haskell.org/package/haskell-src-exts-1.21.1 (DanBurton)
11:21:28 <mycroftiv> is it possible/expected for a command like 'cabal install hakyll' to consume several gigs of memory and sit for an extended period of time in the 'resolving dependencies' phase or is that a sign that something has gone wrong with my installation?
11:21:38 <jle`> exarkun: do you mean marshalling/unmarshalling?
11:21:48 <jle`> exarkun: like saving something to disk to load again later?
11:22:22 <exarkun> jle`: The question was in the context of an earlier discussion about type classes for encoding/decoding being a mistake
11:22:24 <jle`> mycroftiv: hm i haven't used cabal install in a while, but i know stack install gives a loooot of feedback
11:22:34 <jle`> exarkun: ah, ok
11:23:49 <jle`> typeclasses aren't too bad for opaque encoding/decoding, but for things like JSON and CSV there are potentially issues I think. typeclasses can be convenient for deeply nested types
11:25:52 <tabaqui1> how can I show an integer with leading zero chars?
11:26:29 <tabaqui1> like (show' 3 1 == "001") (show' 5 99 = "00099")
11:26:51 <tabaqui1> I don't see such function in Numeric module
11:30:06 <tabaqui1> and without printf-like functions
11:31:14 <mycroftiv> trying to use stack tells me AesonException "Error in $['system-info']: failed to parse field system-info: key \"os\" not present" so i assume something about my debian install has gone wrong
11:32:22 <tabaqui1> you could try to point it directly in your "~/.stack/config.yaml" or ".stack/global/stack.yaml"
11:34:25 <jle`> tabaqui1: are you trying to avoid Text.Printf ?
11:35:15 <tabaqui1> yeah, last time I was very disappointed by it
11:35:30 <tabaqui1> printf "%d" 0.0
11:35:39 <tabaqui1> % printf "%d" 0.0
11:35:39 <yahb> tabaqui1: *** Exception: printf: bad formatting char 'd'
11:35:56 <tabaqui1> oh, even worse
11:36:01 <tabaqui1> % printf "%f" 0
11:36:01 <yahb> tabaqui1: *** Exception: printf: bad formatting char 'f'
11:36:29 <boxscape> You *can
11:36:31 <boxscape> oops
11:36:41 <sm[m]> There are (much less convenient) compile-time-checked alternatives for printf
11:36:43 <boxscape> You *can* make typesafe printf, but I imagine you want something that's not too obscure?
11:37:14 <jle`> tabaqui1: it should work if you test out your literal and input before hand. or you can do a type-safe one
11:37:39 <jle`> the nice thing about printf errors is that it happens regardless of the value given for the most part at least
11:37:51 <tabaqui1> yeah, I was hoping that there is an alternative to showFFloat
11:37:53 * sm[m] couldn’t live without printf
11:37:59 <tabaqui1> but for prefixes and for ints
11:38:07 <jle`> > printf "%05d" 12
11:38:09 <lambdabot>  error:
11:38:09 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M566398342807...
11:38:09 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
11:38:15 <jle`> > printf "%05d" 12 :: String
11:38:17 <lambdabot>  "00012"
11:39:00 * hackage optima 0.4 - Simple command line interface arguments parser  https://hackage.haskell.org/package/optima-0.4 (NikitaVolkov)
11:40:02 <tabaqui1> oh, I just forgot this
11:40:14 <tabaqui1> I need to print it in hexadecimal:)
11:40:33 <hyperisco> > printf "%05x" 12 :: String
11:40:35 <lambdabot>  "0000c"
11:40:39 <hyperisco> I've still got it!
11:40:42 <tabaqui1> oh, ok
11:40:44 <tabaqui1> thanks :)
11:41:34 <jle`> you can make it 'verified safe' by assigning it to a function, `showHexFive :: Int -> String; showHexFive = printf "%05x"`
11:41:43 <jle`> then at least you won't ever have any runtime errors from it
11:42:15 <jle`> provided you test it at least once. not super ideal, but not too much worse than the alternatives
11:42:16 <ClaudiusMaximus> what's wrong with  leftPad c n = reverse . take n . (++ repeat c) . reverse
11:42:21 <tabaqui1> ok, I'll add a signature
11:42:50 <tabaqui1> nah, String type sucks
11:43:01 <jle`> better yet import Data.Text.LeftPad
11:43:34 <hyperisco> String type doesn't suck. It is just a bad Text.
11:43:37 <tabaqui1> % :i justifyLeft
11:43:38 <yahb> tabaqui1: ; <interactive>:1:1: error: Not in scope: `justifyLeft'
11:43:40 <tabaqui1> still O(n)
11:44:07 <tabaqui1> but with O(n) concatenation, length and reverse operations
11:45:10 <jle`> i feel like i vaguely remember a drop-from-end that doesn't involve reversing twice
11:45:17 <tabaqui1> and with really weird encoding
11:46:09 <jle`> er, take-from-end
11:46:31 <tabaqui1> without list change?
11:46:42 <jle`> not sure what you mean by list change
11:46:42 <tabaqui1> f x:[] = x; f x:xs = f xs?
11:47:10 <jle`> takeFromEnd 3 "hello" = "llo"
11:47:25 <tabaqui1> hmm
11:47:53 <jle`> maybe i'm remembering incorrectly
11:48:04 <tabaqui1> takeFromEnd n ls = go (length ls - n) ls where { go 0 x = x; go n (x:xs) = go (n - 1) xs }
11:48:13 <jle`> yeah i mean without taking the length
11:48:20 <jle`> so with only one traversal
11:48:28 <tabaqui1> is it even possible?
11:48:37 <tabaqui1> what if the list is infinite?
11:48:45 <jle`> hm, i mean i know there's a way to do it using a continuation on foldr, but i remember there was a nice simple way to do it using some combination of drop/take and zipWith
11:48:49 <jle`> maybe i'm remembering wrong
11:48:51 <MarcelineVQ> then taking from the end doesn't make sense anyway
11:48:57 <mycroftiv> i added os: linux in .stack/config.yaml but i still get the same stack error of key os not present, i know it parsed that file though because when i typod it errored, but it seems field system-info: key \"os\" is something different
11:50:03 <jle`> hm maybe i'm wrong, i must be thinking of something else done with zipWith/drop/take
11:50:20 <mycroftiv> i feel like im down the wrong track and should try to reset to some known good state rather than mashing keys at errors that probably reflect something broken
11:50:27 <ClaudiusMaximus> > let dropFromEnd xs = zipWith const xs (drop n xs) in dropFromEnd 3 "hello" -- this, jle
11:50:30 <lambdabot>  error:
11:50:30 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘Expr’
11:50:30 <lambdabot>      • In the first argument of ‘drop’, namely ‘n’
11:50:36 <ClaudiusMaximus> > let dropFromEnd n xs = zipWith const xs (drop n xs) in dropFromEnd 3 "hello" -- this, jle
11:50:39 <lambdabot>  "he"
11:50:42 <jle`> ah yeah i must have been thinking of dropFromEnd
11:50:48 <jle`> thanks ClaudiusMaximus 
11:52:00 <jle`> but now i want to try doing takeFromEnd in one traversal
11:54:18 <MarcelineVQ> how about halfway?
11:54:33 <MarcelineVQ> takeFromEnd n xs = listToMaybe . drop n . reverse . tails $ xs
11:54:53 <jle`> nice :)
11:56:39 <jle`> hm, is that a single traversal?
11:57:35 <jle`> you can do it in a O(len*n) with foldl' and a cons-drop loop
11:58:25 <jle`> > let takeFromEnd n = foldl' (\xs x -> take n (x:xs)) []
11:58:27 <lambdabot>  <no location info>: error:
11:58:27 <lambdabot>      not an expression: ‘let takeFromEnd n = foldl' (\xs x -> take n (x:xs)) []’
11:58:35 <jle`> > let takeFromEnd n = foldl' (\xs x -> take n (x:xs)) [] in takeFromEnd 3 "hello"
11:58:37 <lambdabot>  "oll"
11:58:42 <jle`> oh :'(
11:59:11 <ClaudiusMaximus> isn't   reverse . take n . reverse   O(len * n) anyway
11:59:28 <jle`> yea but it's the constant factor i guess
11:59:52 <jle`> oh, the issue is that it keeps the entire list in memory, i think
12:00:08 <ClaudiusMaximus> oh, hm
12:00:46 <jle`> whereas a "streaming" implementation is able to be constant memory
12:01:32 <jle`> actually i'm not 100% sure that reverse . drop n . reverse isn't constant memory either
12:01:44 <c_wraith> and remember, gc runtime is proportional to the live set. if the list is long, keeping it in memory can make gc O(n^2) 
12:02:00 <c_wraith> I am. reverse is not constant memory. 
12:02:28 <jle`> > let takeFromEnd n = reverse . foldl' (\xs x -> take n (x:xs)) [] in takeFromEnd 3 "hello"
12:02:30 <lambdabot>  "llo"
12:02:41 <jle`> this one at least is constant-memory on the list length
12:02:47 <c_wraith> err, can make *total* gc O(n^2). each individual run will be O(n) 
12:04:37 <c_wraith> yes, that's constant in the output size, though it has a *lot* of allocation going on. 
12:05:18 <c_wraith> hmm, actually... that's too lazy. 
12:05:34 <c_wraith> you still keep the entire input around in the nested thinks. 
12:06:22 <c_wraith> foldl' doesn't help, since it only forces the first (:) 
12:06:41 <c_wraith> *thunks
12:13:33 <jle`> i suppose you would need to force the entire list every time?
12:14:07 <jle`> > let takeFromEnd n = reverse . foldl' (\xs x -> force (take n (x:xs))) [] in takeFromEnd 3 "hello"
12:14:10 <lambdabot>  "llo"
12:15:49 <c_wraith> is force deep? 
12:16:04 <c_wraith> but yes, you need to force the entire list at each step 
12:16:07 <jle`> force turns a shallow eval into a deep eval
12:16:21 <hr[m]> Is there a commonly used library in haskell for command line applications? Providing argument and flag parsing, I'm coming from [clap-rs](https://docs.rs/clap/2.33.0/clap/) for rust
12:16:26 <jle`> from Control.DeepSeq
12:16:37 <jle`> hr[m]: the typical one is optparse-applicative
12:16:55 <jle`> but there are some alternatives here and there; optparse-applicative just has the major market share
12:17:02 <c_wraith> it's really not great for allocation counts, but it preserves the memory use you want. 
12:17:21 <hr[m]> Thanks
12:17:37 <jle`> among the alternatives, ghc's base library also has a little module for it
12:17:56 <shapr> is there a changelog for cabal 3 and cabal-install 3?
12:18:24 <shapr> oh, too easy https://github.com/haskell/cabal/blob/master/cabal-install/changelog
12:18:39 <c_wraith> shapr: doesn't fix the bug with no-project v2-repl, which is the only change I'm looking for. :) 
12:19:13 <shapr> oh this is exactly what I was about to ask: 	* Add support for generating test-suite via cabal init. (#5761)
12:19:19 <jle`> i wonder if we are anywhere closer to being able to have a reasonable exporting/documentation story for pattern synonym records
12:19:23 <shapr> c_wraith: what's that?
12:19:30 <shapr> is that roughly ghci?
12:20:26 <c_wraith> shapr: yes. the bug is that :load doesn't really work without a project. so it's still not a substitute for v1-install + ghci
12:20:52 <shapr> aw
12:21:14 <c_wraith> I will stop using v1-install when this finally works. :) 
12:26:34 <shapr> c_wraith: did you check to see if it's an easy fix?
12:26:41 <shapr> I haven't looked at cabal source in years, so I have no idea
12:32:12 <infinisil> Is there a way to tell GHC "No this pattern match *is* exhaustive, you just don't see it"
12:32:30 <infinisil> To get rid of the error?
12:32:35 <infinisil> s/error/warning
12:33:04 <jle`> infinisil: use a wildcard at the end
12:33:24 <jle`> case myBool of True -> 3; _ -> error "why would it be false?"
12:33:27 <infinisil> Was hoping for some special annotation or so
12:33:45 <infinisil> But I guess a wildcard won't hurt
12:33:47 <merijn> infinisil: It depends on why you happen to know it's exhaustive?
12:33:50 <jle`> at least this way if the pattern match actually isn't as exhaustive as you think, there's a reasonable error
12:33:59 <c_wraith> shapr: it's not easy. no-project was an afterthought in v2 land. I reported it a while ago and was told that was very hard to make work with the v2 architecture. when 3.0.0 came out, hvr asked me (and the other person to report it) to check to see if things had improved. it's not even a thing they're set up to check on. :) 
12:34:20 <infinisil> merijn: It's guaranteed by the algorithm, and it would be hard to encode this in the type system
12:34:55 <merijn> c_wraith: What do you mean by no-project?
12:35:40 <c_wraith> no .cabal file. no special directory. just playing around in the repl
12:35:54 <merijn> ah
12:36:21 <merijn> I recall there was a way to have global environments (files) that you could install into, but I forgot the workflow for it
12:37:01 <c_wraith> there is a workflow, it just breaks :load
12:37:48 <c_wraith> when you :load a module, it gets built but not imported. :browse shows its contents, but trying to import it gets an error message 
12:38:24 <merijn> ah, unfortunate
12:52:15 <_xor> Hello :) I'm a total noob to hs. I'm going to work my way through some tutorials here next week when I have some spare time.
12:52:50 <_xor> Currently though, I'm trying to build a project to evaluate it. Stack builds it and all, but I'd like to know where it outputs the binaries.
12:53:11 <_xor> It seems that most of these projects want you to just run stack install, which is fine, but I'd like to take a look at the binaries.
12:53:17 <_xor> It's also going to be copied to another system as well.
12:53:19 <jgt> _xor: I think you're meant to use stack exec <program_name>
12:53:47 <jgt> _xor: also iirc, stack install is generally *not* what you want
12:54:09 <jgt> I'm not much of a stack user though
12:54:16 <_xor> What exactly does stack install do?  I figured it builds it and then installs it locally somewhere like ~/.stack/bin or something.
12:54:37 <jgt> yeah, I think that's right
12:54:52 <jgt> but do you want to install your project locally?
12:55:02 <_xor> Not ideally, but it's not a huge deal.
12:55:14 <jgt> try stack build and stack exec first
12:55:18 <_xor> It's hasura (the graphql server).  I want to evaluate it, which I will do on my local box.
12:55:42 <_xor> ...but if I like it, I'll run it on one of my servers, which means I'd have to copy it there (same os, version, libs, etc).
12:59:06 <shapr> I want a generic cabal init that lets me create new packages quickly for prototyping, so far I have: cabal init -m -l BSD3 -a "$(git config --get user.name)" --version=0.1.0.0 -e "$(git config --get user.email)" --libandexe --tests --language=Haskell2010
12:59:11 <shapr> any suggestions for improving that?
13:04:44 <ClaudiusMaximus> package name based on pwd? or is that automatic already?
13:05:24 <shapr> ClaudiusMaximus: unspoken assumption that I'm in a dir I just created, good point
13:08:28 <shapr> is there some way to get hackage style docs for all the packages I have downloaded/installed? I think I want a local hackage in my browser or something?
13:08:45 <shapr> I really just want a way to read docs when I don't have an internet connection
13:09:37 <merijn> shapr: If you set documentation: True in ~/.cabal/config it already installs docs locally
13:09:45 * shapr checks
13:09:49 <merijn> Although where v2-build leaves them is still a bit confusing
13:10:44 * shapr looks
13:11:11 <shapr> under program-default-options I have: ghc-options: -O2 -j12 +RTS -A128m -n4m -RTS
13:11:24 <shapr> ghc still doesn't use much ram though
13:15:13 <hyperexpression> Hello, I'm having an issue using "cabal new-install".  It gives me this error : After searching the rest of the dependency tree exhaustively, these were thegoals I've had most trouble fulfilling: directory, ghc
13:15:41 <hyperexpression> I don't have any issue running "cabal new-build"
13:15:48 <koz_> While we're on cabal new-install - I just had it complain that installdir is not defined, but my Cabal config file doesn't have any option by that name. Where does it go?
13:15:54 <sclv> check for a ghc env file?
13:16:05 <merijn> koz_: Did you update the config file for the new version?
13:16:12 <koz_> merijn: Nope. How do I do that?
13:16:35 <merijn> koz_: Consult the help for "cabal user-config"
13:16:40 <koz_> merijn: Thanks, will do.
13:17:19 <shapr> cabal user-config update
13:18:40 <shapr> I can't find any docs under ~/.cabal , though "cabal new-install feed" claimed it generated a bunch of haddocks
13:18:44 <shapr> any idea where I might look?
13:20:15 <hyperexpression> Hmm, any ideas, folks?
13:20:32 <shapr> hyperexpression: what command are you running?
13:22:52 <hyperexpression> I'm running "cabal new-install" from the directory where my .cabal file resides.   I also tried running it for a particular package to get it from Hackage.  Same error message about "directory" and "ghc".
13:23:20 <sclv> hyperexpression: check for a ghc environment file
13:23:45 <hyperexpression> There's nothing set
13:24:46 <hyperexpression> Should it be GHC_DOT_APP, sclv?
13:25:35 <sclv> if there’s nothing set that’s ok? You can also just delete it or disable it to be sure tho
13:25:55 <sclv> do you mean the local or the global env file?
13:26:25 <sclv> Often if new-build works but new-install doesn’t then its the global env file to blamw
13:26:42 <hyperexpression> Global, I believe. Where is that located.?
13:27:06 <hyperexpression> Thanks for your help, sclv
13:27:58 <sclv> hyperexpression: https://ghc.gitlab.haskell.org/ghc/doc/users_guide/packages.html#envvar-GHC_ENVIRONMENT
13:30:15 <shapr> hyperexpression: does your package depend on ghc?
13:30:31 <hyperexpression> It doesn't
13:33:10 <hyperexpression> Should the default file not have a reference to the ghc package?
13:35:42 <shapr> hyperexpression: I don't think so
13:37:00 <shapr> I can paste the cabal file I just created: https://gist.github.com/shapr/03c78d9e410cb6db033b27d71ef34447
13:47:37 <shapr> hyperexpression: are you able to pastebin your cabal file?
13:52:00 * hackage pure-zlib 0.6.5 - A Haskell-only implementation of zlib / DEFLATE  https://hackage.haskell.org/package/pure-zlib-0.6.5 (AdamWick)
13:59:50 <dmj`> cassava and aeson don't parse "NaN" into a Double it seems
14:00:58 <EvanR> > read "NaN" :: Double
14:01:00 <lambdabot>  NaN
14:01:04 <EvanR> phew
14:01:55 <dmj`> goes to show nobody uses haskell for data science
14:03:21 * shapr is sad
14:03:37 <shapr> dmj`: seems round trip should be a thing?
14:04:11 <jle`> technically NaN cannot be used in json
14:04:17 <lyxia> https://github.com/bos/aeson/issues/679
14:04:28 <hyperexpression> Here's my cabal file `slikts: https://pastebin.com/2U3Yg2J4
14:04:40 <dmj`> iattoparsec doesn't parse the string NaN into a double
14:04:42 <jle`> so parsing NaN into Double would break json compatibility
14:04:48 <jle`> (for aeson at least)
14:05:00 <jle`> https://www.json.org/
14:05:10 <hyperexpression> Sorry, shapr
14:06:27 <jle`> so i suppose one conclusion is 'nobody uses json for storing data science data'
14:06:51 <dmj`> nor CSVs 
14:07:11 <jle`> CSV's are a pretty common thing, there is no CSV standard that disallows NaN
14:07:26 <jle`> so it would make sense for a csv parser to do the right thing here
14:08:24 <jle`> does the Frames library work? it's more geared for numerical data analysis i think
14:10:50 <dmj`> never heard of it, will check it out
14:11:06 <dmj`> but yea, cassava just uses attoparsec under the hood, which doesn't account for NaN
14:11:11 <jle`> hm, it looks like it doesn't work either, since it uses the text library's Data.Text.Read
14:11:14 <dmj`> when parsing Double
14:11:30 <jle`> might be worth raising in the data haskell lobby, https://gitter.im/dataHaskell/Lobby
14:11:59 <dmj`> parseDouble :: B.ByteString -> Parser Double
14:11:59 <dmj`> parseDouble s = case parseOnly (ws *> double <* ws) s of
14:11:59 <dmj`>     Left err -> typeError "Double" s (Just err)
14:11:59 <dmj`>     Right n  -> pure n
14:12:09 <dmj`> that's the code for cassava's FromField Double instance
14:12:16 <dmj`> whitespace checks
14:17:30 <shapr> hyperexpression: are you using a clean checkout of https://github.com/grandpascorpion/canon ?
14:19:05 <jle`> dmj`: it looks like aeson decodes null as NaN for Double
14:19:18 <jle`> which i think is actually the json-compatible way a lot of data sets encode NaN
14:20:12 <jle`> and this roundtrips properly too
14:21:07 <EvanR> i don't think most jsons do NaN at all
14:21:14 <jle`> there is only 'one' json
14:21:20 <dmj`> jle`: ah, ok, so it does round trip, we're good.
14:21:22 <jle`> and it disallows NaN
14:21:24 <dmj`> on the aeson front
14:21:29 <dmj`> but cassava ain't out the trap
14:21:43 <EvanR> well then i'm right
14:21:58 <EvanR> forall json, most of them (all 1 of them) don't do NaN
14:22:03 <jle`> but some data sets by convention encode NaN as null, [2.3, -1,3. null]
14:22:30 <EvanR> 2 . 3 , - 1 , 3 . null ?
14:22:37 <jle`> heh. switching from different i18n
14:22:56 <jle`> it's not too uncommon to have a data set given as something like [2.3, -1.3, null, 4, 6, 10]
14:23:06 <jle`> this is a workaround to be compatible with json
14:37:08 <dmj`> aeson does try to parse "NaN" with FromJSONKey
14:38:14 <shapr> wow, when did hoogle start returning the haddock entry with --info ?
14:54:49 <__monty__> Seems kinda weird to have a serialisation format that works for some but not all values.
14:58:47 <phadej> dmj`: fromjsonkey is for parsing keys of objects
14:59:07 <phadej> if someone puts doubles as keys, they are calling for troubles; but yes, aeson supports that
14:59:45 <int-e> phadej: As long as you avoid NaN...
15:00:53 <int-e> phadej: Oh "double trouble" is a fun thing to say, thanks for that!
15:01:16 <phadej> :)
15:02:00 * hackage emd 0.1.5.1 - Empirical Mode Decomposition and Hilbert-Huang Transform  https://hackage.haskell.org/package/emd-0.1.5.1 (jle)
15:08:41 <dmwit> __monty__: JSON's numbers are not a serialization format form IEEE754. They're their own thing.
15:09:34 <dmwit> -form +for
15:10:36 <__monty__> dmwit: Yeah but JSON *is* a serialization format, right? Originally for JS? And JS has nothing but doubles, so should those serialize properly?
15:12:02 <dmwit> I agree that the situation is a bit weird and unfortunate.
15:15:20 <jle`> __monty__: json's purpose is technically as a data interchange format
15:15:26 <jle`> so basically meant for communication, not for serialization
15:15:54 <jle`> the standard is written for that purpose.  but admittedly a lot of people use it for serialization
15:16:16 <__monty__> Isn't that still serialization? Just not optimized for archival but for transferability?
15:16:50 <jle`> ah, i suppose you're correct there. serialiation doesn't necessarily mean data storage
15:17:22 <jle`> i wouldn't really characterize it as "some values, but not all", since IEEE Doubles can be considered a superset/extension of just "numbers" in general
15:17:39 <jle`> json supports "numbers", just not the full range of IEEE Double, a specific standard
15:18:24 <jle`> it's also meant to be language-independent, so nothing specifically from JS
15:19:31 <__monty__> Does JSON have +/-inf?
15:19:56 <jle`> it does not; https://www.json.org/
15:25:47 <__monty__> Hmm, so basically, real numbers? With a specific format.
15:26:05 <pigmej[m]> Hmmmm
15:26:30 <jle`> rational numbers probably
15:27:39 <__monty__> I guess, since you can't have an infinite file.
15:28:22 <jle`> well i mean to say that the format represents exactly a decimal representation of a rational number, mathematically
15:36:06 <day> in which direction should I look when i want to deal with mutable data in haskell or work around the mutability in another way? my concrete example being a spaced repetition dataset that needs to be modified based on user input
15:39:40 <c_wraith> day: that doesn't sound like something that requires mutation. 
15:40:10 <day> well my initial idea was to recursively create new lists, until the lists are empty 
15:40:32 <c_wraith> day: it sounds more like you want a function that takes the current data set and the input and returns a new data set. 
15:41:11 <day> but you may end up seeing datasets multiple times
15:41:33 <day> e.g. you failed to answer one correctly, thus you get to see it again in the same session
15:41:49 <c_wraith> none of this says mutation. 
15:42:15 <c_wraith> mutation is for when you have things like one thread needing to make changes anither thread can see. 
15:43:18 <c_wraith> you're describing logic for updating state. the rules might be complex, but they don't require mutability. 
15:53:17 <sm[m]> different uses of the word mutation I think
16:09:01 <EvanR> json supports decimal numbers basically, no 1/3 for you
16:09:31 <EvanR> which is funny because the financial APIs always use a decimal string instead of numbers
16:12:33 <MarcelineVQ> helps to avoid rounding errors I guess
16:12:48 <MarcelineVQ> If you mean "123.456"
16:13:30 <EvanR> since decimal libs for web take a string in the ctor, i guess it makes more sense than going from json to double to string to decimal
16:13:55 <EvanR> or even json to double to decimal
16:14:25 <EvanR> but the thing is... json contains decimal numbers already just do json -> decimal heh... *gets fired immediately for thinking such thoughts*
16:16:02 <Jonathan59> Using Floats (or Doubles) does not really make sense for currency.
16:16:38 <EvanR> agreed
16:16:48 <Jonathan59> Using fix point numbers (`int` number of cents) makes the most sense.
16:16:55 <Jonathan59> Or string, I guess.
16:17:05 <EvanR> the point is, in json form numbers are defacto decimal
16:17:19 <Jonathan59> Oh, right, yeah.
16:17:31 <Jonathan59> Overly simplistic...
16:17:41 <EvanR> so simple it hurts
16:17:46 <Jonathan59> XD
16:18:04 <rom1504> EvanR: {"n":1, "d": 3} here you go
16:18:17 <EvanR> nickel and dimes?
16:18:26 <Jonathan59> Yes!
16:18:37 <rom1504> yeah nickel divided by dimes
16:18:37 <Jonathan59> Perfect.
16:18:52 <EvanR> {balance: "buck fifty"}
16:19:00 <MarcelineVQ> don't forget your {"b":2}
16:19:28 <MarcelineVQ> For the shave and a hair cut
16:19:59 * EvanR checks NPM for egyptian fraction package
17:17:02 <mycroftiv> ive been having good luck with hugs in plan 9 but im having issues getting the ghc ecosystem set up in debian stetch and i think i should try to build a clean dev environment from the ground up
17:17:44 <mycroftiv> is there a recommended linux distro + approach to getting everything set up in the way that matches standard practices of people actually making the tools, so i can try to have a best-practices foundation?
17:31:00 * hackage lenz 0.4.0.0 - Van Laarhoven lenses  https://hackage.haskell.org/package/lenz-0.4.0.0 (MatthewFarkasDyck)
17:31:29 <EvanR> recommend anything but arch linux. Unless you have the will power to ignore the package management system for haskell development
17:33:17 <mycroftiv> well im assuming its better to go to the current release tip rather than use distro packages in general? i feel like maybe that was part of the issue with debian, mismatch between old debian and trying to update the tools using the tools
17:36:36 <EvanR> that's true but only the tip of the issues on arch
17:39:03 <mycroftiv> ok, noted. im wanting to make a setup entirely devoted to haskell development and get the tools installed in whatever way makes them happiest, im fine with building everything from source or whatever makes the most sense
17:43:58 <EvanR> don't build GHC from source, get the latest binary
17:45:50 <mycroftiv> ok, thanks for that advice - i noticed when i tried to do a -C compile that it told me i needed an 'unregistered' ghc which made me think of stolen handguns but then i figured it out
17:46:20 <mycroftiv> at least what it meant, not exactly how to acquire it
17:49:46 <EvanR> the ghc loophole!
17:50:03 <mycroftiv> random unrelated observation: Haddock is absolutely wonderful. One of the nicest pieces of software ive ever used.
18:02:22 <Guest_49> Hi. I'm trying to install the latest Haskell on MacOS by running "curl" as suggested, but get an immediate failure when the installer attempts to create a temporary directory (with mktemp). Has anyone experienced this issue beofre / has any suggestions of what to do? Thanks.
18:13:22 <dmwit> What's the exact error you get?
18:27:07 <suzu> is your system out of space?
18:27:19 <suzu> Guest_49
18:54:30 * hackage pointfree-fancy 1.1.1.14 - Tool for refactoring expressions into pointfree form  https://hackage.haskell.org/package/pointfree-fancy-1.1.1.14 (vmchale)
18:57:00 * hackage waargonaut 0.8.0.0 - JSON wrangling  https://hackage.haskell.org/package/waargonaut-0.8.0.0 (schalmers)
19:04:25 <koz_> > subtract 3 5
19:04:27 <lambdabot>  2
19:19:58 <koz_> :t flip randomR
19:20:00 <lambdabot> (Random a, RandomGen g) => g -> (a, a) -> (a, g)
19:21:36 <jusss> is there a IDE for haskell? run ghci in the teminal is not easy to input
19:24:35 <maerwald> jusss: emacs has fairly good support, then there is leksah (which is the only haskell-specific IDE)
19:24:52 <maerwald> then you have all sorts of tools like intero, haskell-ide-engine etc
19:24:59 <maerwald> but those are tools, not IDEs
19:25:52 <EvanR> theres (for some value of "there is") haskforce for intelliJ
19:26:16 <maerwald> tbh, I don't use any such tools, since none of them scale on big projects. I only use codex with hasktags, which scales properly and lets me navigate code (even in dependencies)
19:26:41 <maerwald> but since it's just ctags under the hood, it isn't as reliable as you might want
19:26:48 <maerwald> but good enough
19:28:03 <jusss> EvanR: I failed to config stack for intellij idea plugin
19:28:40 * EvanR unsurprised
19:29:23 <jusss> maerwald: I use emacs's haskell-mode on windows, and got a issue, Compilation failed, and then I input some code into repl, and Some flags have not been recognized: prompt2, 
19:31:05 <jusss> ok, I just installed leksah 
19:31:46 <EvanR> if emacs plugin like that broke down, you may have an old version of something
19:32:11 <maerwald> does anyone know if GHC is guaranteed to only have 3 version components?
19:34:05 <EvanR> might as well just split on '.' and use a proper comparison between [Int] :P
19:34:44 <jusss> EvanR: is there an out-of-the-box editor or IDE?
19:36:12 <EvanR> out of what box
19:36:18 <EvanR> the haskell box?
19:37:55 <EvanR> for editors in general i have nothing to add beyond was others already said above. Besides I tried atom and found it was glacial slow
19:38:11 <jusss> EvanR: it's a metaphor, it means no any config is be need
19:38:17 <jusss> been
19:38:55 <EvanR> vim requires no config, only a drag and drop of my already-config-ed config file :P
19:49:50 <koz_> I use vim, together with ALE.
19:50:04 <koz_> I can beam you my project-local .vimrc if you want, jusss.
19:50:10 <koz_> It works pretty well.
19:50:14 * koz_ is using it right now in fact.
20:03:58 <jusss> koz_: ok, please
20:04:05 <maerwald> EvanR: ?
20:04:30 * hackage servant-waargonaut 0.7.0.0 - Servant Integration for Waargonaut JSON Package  https://hackage.haskell.org/package/servant-waargonaut-0.7.0.0 (schalmers)
20:06:16 <maerwald> I split on '.' and do proper Int comparison. But if you don't know how many version components there are you have to treat it like a possibly infinite array of version components. Which is awful in shell.
20:07:17 <koz_> :t foldM
20:07:19 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
20:09:13 <MarcelineVQ> koz_: it's still b first :>
20:09:28 <koz_> MarcelineVQ: I will never remember that one, I swear. :P
20:10:26 <koz_> I need to produce a value in the range (0,1) as a Double. The default for random is [0, 1), which is almost, but not quite, what I need. Can someone suggest how I can get what I want?
20:12:08 <MarcelineVQ> do the different brackets imply something?
20:12:41 <koz_> MarcelineVQ: (0,1) means 'any value between, but not including, 0 or 1'. [0, 1) means 'any value between, including 0, but not including 1'.
20:12:47 <koz_> (interval notation)
20:13:14 <EvanR> maerwald: shell! ... use haskell!!!!111
20:13:35 <koz_> If you must, write your shell _using_ Haskell. There's a few libraries for this.
20:13:42 <maerwald> EvanR: ghcup is in POSIX sh
20:14:00 <maerwald> switching language for version comparison isn't... reasonable...
20:14:10 <maerwald> especially since I will use all portability
20:14:15 <maerwald> s/use/lose/
20:14:17 <koz_> maerwald: Fair enough then.
20:14:22 <EvanR> koz_: so uh... wrap the generation function somehow in a thing that detects a zero and responds by emitting a 0.5 instead
20:14:29 <MarcelineVQ> koz_: there might be a weighted choice operator sitting around somewhere, in which case you could write, liftA2 (,) (pure 0) (randomIO @Double) and choose one of the two with a bias
20:14:44 <MarcelineVQ> or that, roll again on a bad roll
20:14:49 <koz_> EvanR: That makes it non-uniform.
20:14:56 <koz_> I should have said I needed it to be uniform.
20:14:58 <EvanR> barely, but yeah. re-roll
20:14:59 <koz_> (my bad)
20:15:14 <koz_> Yeah, I guess re-roll it is.
20:16:19 <EvanR> theres no continuous map from [0,1) to (0,1) heh
20:16:37 <koz_> EvanR - I will take your word for it.
20:16:50 <koz_> Since my knowledge of real analysis fits on like, a postage stamp. :P
20:16:57 <EvanR> not that it matters, this is Double
20:17:03 <koz_> This is true.
20:17:08 <EvanR> but we usually write Double code like its Reals
20:18:56 <EvanR> ok there is a continuous map, but no onto continuous map
20:19:41 <koz_> EvanR: What is a continuous map?
20:19:45 <EvanR> this is topology not analysis, if you wanna google it
20:20:12 <EvanR> a morphism between topological spaces
20:20:14 <EvanR> heh
20:20:18 <koz_> I dunno topology either.
20:21:36 <EvanR> a donut is teh same as a coffee cup, (0,1) is the same as the whole real line, and [0,1) is an infinite ray starting at an endpoint
20:21:38 <buhman> do any libraries exist that handle git's remote protocols? nothing I could find on hackage seemed complete enough for 'git fetch'/'git push' except maybe the libgit2 bindings
20:26:20 <EvanR> doh. heres an onto map... f x = x * sin x. clearly not uniform like you wanted, which amounts to a 1 to 1 onto map. And since in the Double case you have finite points, N in one, N-1 in the other, you can't do it
20:26:24 <koz_> EvanR: Why is [0, 1) not the same as the whole real line?
20:26:39 <EvanR> it has a dead end
20:26:45 <koz_> Explain?
20:27:02 <EvanR> would require a semester</handwave>
20:27:31 <koz_> LOL
20:27:34 <koz_> Fair.
20:28:06 <koz_> Is there a cardinality difference there I'm not seeing or something?
20:33:30 * hackage pure-zlib 0.6.6 - A Haskell-only implementation of zlib / DEFLATE  https://hackage.haskell.org/package/pure-zlib-0.6.6 (AdamWick)
20:37:16 <jusss> haskell use main = as program enter point?
20:38:08 <EvanR> yes
20:38:11 <jusss> if I want to print Hello world, I should use `main = putStrLn "hello world"` in a.hs?
20:38:22 <jusss> then I run `ghci a.hs` ?
20:38:55 <jusss> but I found out it started a ghci repl...
20:39:24 <jusss> it shouldn't be like "python a.py" just output the result of the script?
20:40:38 <glguy> No, GHCi isn't python
20:41:11 <glguy> If you want to run the script's main action without compiling it you can use the runghc command
20:41:55 <glguy> ghci will always start up a repl from which you can check types and evaluate expressions with your module in scope
20:42:51 <jusss> glguy: ok
20:44:44 <jusss> glguy: runghc can take a file name without hs?
20:44:56 <jusss> like runghc a.hs.tmp is ok?
20:45:14 <glguy> I'd guess not, but you might try
20:45:22 <jusss> ok
20:46:03 <jusss> glguy: about the keyword "import" and "module" , can I use it both?
20:46:10 <dmwit> koz_: No cardinality problem. But you want an isomorphism (because you want to preserve uniformity), and all the nice maps have the property that they preserve whether a sequence's convergent is in the set or not. [0,1) has one convergent not in the set, but (0,1) has two.
20:47:25 <dmwit> EvanR: I don't think f x = x * sin x even has the right codomain, does it?
20:47:58 <EvanR> yeah i didnt map back to (0,1)
20:48:17 <iqubic> Well, I'm getting confused here.
20:48:33 <dmwit> koz_: Anyway, rejection sampling is going to be fine. You are vanishingly unlikely to get 0, so you reroll almost never.
20:49:32 <EvanR> f x = (atan (x * sin x) + pi/2) / pi
20:49:50 <jle`> rejection sampling is such a negative mood
20:50:01 <jle`> i'm going to call it acceptance sampling from now on
20:50:21 <EvanR> golden sampling
20:51:04 <jle`> "try before you buy" sampling
20:51:52 <dmwit> free samples
20:52:03 <jle`> goldilocks sampling
20:53:22 <EvanR> "song taking"
20:53:53 <iqubic> https://hackage.haskell.org/package/first-class-families has a module called Fcf, which defines a type synonym as such "type Exp a = a -> Type." Why is this type even useful?
20:54:24 <dmwit> I have developed the idiom `tail [undefined\n, foo\n, bar\n, baz\n]`. This way all entries in the list have the same "shape", so if you want to swap them around you can do that freely, even if one of the ones you want to swap is the first element of the (resulting) list.
20:54:41 <dmwit> There's something deliciously subvertive about combining two partial things to get something total like that.
20:54:49 <dmwit> subversive? whatever
20:55:01 <iqubic> koz_: this package is very very similar to the code described in Sandy's book in chapter 10.2.
20:55:35 <EvanR> iqubic: a -> Type is sometimes called a type family (parameterized by a)
20:55:45 <nshepperd> dmwit: you're a monster
20:56:04 * dmwit takes a bow
20:56:07 <iqubic> Right... But then what is the point of the Eval type family?
20:56:15 <EvanR> its used to make a property, represented by a type, with a variable in it
20:56:41 <EvanR> oh Exp, its probably where you insert your expression type
20:56:53 <EvanR> a would be the payload type
20:57:20 <iqubic> Why is an exp of type 'a -> type'?
20:57:58 <iqubic> I have no idea why it can't just be "type Exp a -> a"
20:58:06 <EvanR> i'm wrong, docs clearly state a is the result type (presumably of evaluating the expression)
20:58:31 <EvanR> type Exp a -> a doesnt look valid
20:59:13 <iqubic> I mean this: "type Exp a = a"
20:59:20 <iqubic> Why is isn't it that?
20:59:57 <EvanR> so Exp would essentially do nothing
21:00:17 <iqubic> What does the "a -> Type" even do?
21:01:03 <jle`> you can think of it basically like for documentation purposes
21:01:32 <EvanR> the Type target here is relevant because (haskell) type families can match on what type something is
21:01:40 <EvanR> which the Eval family is heavily doing
21:01:46 <iqubic> How so?
21:01:53 <EvanR> look at the instances for Eval
21:02:07 <jle`> iqubic: ideally you want the 'kind' of something like FromMaybe to be k -> Maybe k -> k
21:02:16 <jle`> but that's not possible to write in Haskell
21:02:16 <iqubic> Right...
21:02:26 <iqubic> But why can't you do that in Haskell?
21:02:26 <jle`> since all data types have to return -> Type in the end
21:02:36 <jle`> otherwise it wouldn't be a valid data type declaration
21:03:01 <iqubic> In Haskell, the best you can do is "data FromMaybe :: a -> Maybe a -> Exp a"
21:03:02 <jle`> data Either :: Type -> Type -> Type, for instance
21:03:19 <EvanR> can you really not? even with polykinded type synonyms
21:03:20 <jle`> yeah, essentially the 'real' type of FromMaybe is k -> Maybe k -> k -> Type
21:03:29 <jle`> but the last parameter is the kind of the 'result'
21:03:41 <jle`> so it makes it easier to write FromMaybe :: k -> Maybe k -> Exp k
21:03:52 <jle`> even though you really "want" to be able to write FromMaybe :: k -> Maybe k -> k
21:04:04 <iqubic> So is "type Exp a = a -> Type" just a way to trick Haskell into accepting our data declarations?
21:04:23 <jle`> that's one way to think of it, yeah
21:04:38 <jle`> but also you can think of `Exp a` as being the kind of expressions you can evaluate with Eval
21:04:52 <jle`> because you essentially have `Eval :: Exp a -> a`
21:05:02 <jle`> in that sense it's used as purely for documentation/readability
21:05:30 <iqubic> Why do you want "Eval :: a -> Type -> a"?
21:05:38 <iqubic> Why is that helpful at all?
21:05:46 <jle`> `Eval :: Exp a -> a` is easier to read for documentation/readability
21:05:58 <iqubic> I see.
21:06:02 <jle`> it's saying "given something that represents an expression of kind 'a', return an 'a'"
21:06:07 <jle`> kind of like runIdentity :: Identity a -> a
21:06:26 <jle`> the actual literal a -> Type isn't being used for what it is; it's just being used to improved readability
21:06:31 <jle`> it's an abstraction
21:06:45 <EvanR> what is the advantage of first class families
21:06:50 <iqubic> But why is "type family (Eval :: a -> Type -> a)"
21:07:11 <iqubic> EvanR: Higher Ordered type level functions.
21:07:22 <EvanR> really...
21:07:32 <iqubic> Yes, actually.
21:07:42 <jle`> iqubic: that's not what it is; it's not (a -> Type -> a), it's (Exp a) -> a, or (a -> Type) -> a
21:08:05 <jle`> the a -> Type is never used directly as a data constructor or type function, it's just there for ease in readability
21:08:30 <jle`> iqubic: it makes it plain to understand `Eval :: Exp a -> a`
21:08:41 <jle`> which mirrors things like `evaluateExpresion :: Expr a -> a`
21:08:54 <jle`> or `runIdentity :: Identity a -> a`
21:09:18 <jle`> you never actually 'use' any `a -> Type`, it's there purely for documentation/readability
21:09:51 <jle`> things like `evalExpr :: Expr a -> a` is a pretty common idiom in Haskell
21:10:18 <jle`> if you can, ignore the underlying implementation of Exp completely, it isn't ever used
21:10:57 <jle`> it's the same deal as `a ~> b` in singletons fwiw
21:11:38 <jle`> the underlying implementation doesn't mean anything, it's just used to make code easier to read/signal to the reader what the intent is
21:12:00 <jle`> so pretend it's opaque
21:13:47 <jle`> it's just not possible to literally have it be an opaque type because all data constructors in Haskell are forced to return -> Type
21:14:21 <iqubic> Sorry, internet cut out for a moment.
21:14:38 <iqubic> You said that this was similar to a ~> b from singletons?
21:15:02 <jle`> yeah, not similar in implementation, but similar in its purpose in the library
21:15:06 <iqubic> That's the last thing I caught before internet broke.
21:15:39 <iqubic> jle`: But singletons also has a lot more stuff that's useful for dependent types.
21:15:42 <jle`> the underlying implementation doesn't mean anything; ideally we'd be able to directly return things of kind a or whatever in a data type, but that's disallowed in Haskell
21:15:53 <iqubic> For now.
21:16:01 <iqubic> I hope that gets changed soon.
21:16:08 <jle`> that's not the point i was making; the point is that it is just a convenient type alias to signal to the reader what the person 'means'
21:16:38 <jle`> it's not possible right now to have a data type return something other than Type.  if it was possible, we wouldn't need Exp/~> defined the way they are
21:16:57 <jle`> if we could directly have a kind data Exp a = Exp a; and have FromMaybe :: a -> Maybe a -> Exp a, then it'd be ideal
21:17:16 <iqubic> So, how does this mechanism allow for the ability to create things like type level map?
21:17:26 <iqubic> Or just higher order functions in general?
21:17:28 <jle`> (a -> Type) does not allow for anything
21:17:38 <jle`> or unless you're talking about Eval
21:17:41 <iqubic> Yeah.
21:17:54 <jle`> you would just define the result of your function as an instance of Eval
21:18:02 <jle`> data Snd :: (a, b) -> Exp a
21:18:14 <jle`> type instance Eval (Snd '(x,y)) = x
21:18:29 <jle`> data Map :: (a -> b) -> [a] -> Exp [b]
21:18:41 <lyxia> Type-level map, like this? https://hackage.haskell.org/package/first-class-families-0.5.0.0/docs/Fcf-Classes.html
21:18:50 <jle`> er, data Map :: (a -> Exp b) -> [a] -> Exp [b]
21:18:52 <iqubic> yes.
21:18:58 <jle`> type instance Eval (Map f '[]) = '[]
21:19:04 <iqubic> lyxia: We are discussing your library actually.
21:19:11 <lyxia> I know :)
21:19:14 <jle`> type instance Eval (Map f (x ': xs)) = Eval f x ': Eval (Map f xs)
21:19:20 <jle`> and that's it :)
21:19:51 <iqubic> But f is just a data constructor, in this istance, right?
21:20:10 <jle`> yeah it's just something of kind (a -> Exp b)
21:20:18 <iqubic> Like Snd?
21:20:25 <iqubic> Does Snd have the right kind?
21:20:46 <jle`> indeed it does :) it's (a, b) -> Exp b.  although i accidentally wrote Fst up there
21:20:56 <iqubic> Right.
21:21:07 <jle`> but yeah, if you type this all into GHC and to :kind Map Snd, you'll get Map :: [(a,b)] -> Exp [b]
21:21:49 <jle`> and you can do it by hand too if you don't trust ghci
21:22:13 <iqubic> Why are we applying f to each element, and then "Eval"ing each element too?
21:22:39 <jle`> on a low level, it's the only way to get it to kind-check
21:22:45 <jle`> since f x :: Exp a, but we want an 'a'
21:22:50 <iqubic> "type instance Eval (Map f (a ': as)) = Eval (f a) ': Eval (Map f as)"
21:23:12 <iqubic> So Eval is just a type level function that goes from "Exp a -> a"?
21:23:31 <jle`> i mean i wouldn't say 'just' necessarily, but yeah
21:23:43 <iqubic> Why wouldn't you say 'just'?
21:23:57 <jle`> because that's like saying "so 'negate' is just a function that goes from Int to Int?"
21:24:03 <iqubic> Oh. Right.
21:24:05 <jle`> i mean yeah, it is a function...but there is more to it than just its type signature
21:24:50 <jle`> it's somewhat similar in spirit to something like runIdentity :: Identity a -> a, or flip runReader x :: Reader r a -> a
21:24:59 <iqubic> So, why is it that we can't partially apply type families, but we can partial apply this sort of type level function?
21:24:59 <jle`> well, it's meant to evoke the same kind of imagery
21:25:12 <jle`> iqubic: well these aren't type families, these are just normal data types
21:25:16 <jle`> so you can partially apply them all you want
21:25:20 <iqubic> I see.
21:26:22 <lyxia> there's work to allow type families to be partially applied that came out this year too
21:26:47 <iqubic> I'm reading Sandy Maguire's book "Thinking With Types" where he makes use of this package.
21:27:03 <iqubic> I wanted to understand the package before I moved on too far.
21:27:52 <iqubic> lyxia: Will the work to allow partial application of type families remove the need for your library to be used?
21:28:19 <lyxia> I think so
21:29:08 <iqubic> Will you be disappointed that your work goes to waste?
21:29:24 <jle`> if we're using it now, it's not a waste
21:30:06 <iqubic> I'm only using now because Sandy is using it, and I want to follow along with his book.
21:30:08 <jle`> that's like saying that our current tank of gas is a waste because we'll eventually get more gas in the future. but that future gas isn't going to help us drive to the grocery store today.
21:30:30 <iqubic> I understand.
21:30:35 <EvanR> future gas has made present gas obsolete!
21:37:49 <iqubic> I'm so glad that I got Dante to work well with Nix.
21:38:04 <iqubic> Dante is an emacs package made by jyp.
21:38:22 <iqubic> https://github.com/jyp/dante
21:38:48 <iqubic> It's a really great emacs haskell package.
21:40:18 <iqubic> The current file is checked every time I save. Compiler errors are underlined with red, and warnings are orange. HLint suggestions are cyan.
21:40:50 <iqubic> It's really really nice.
21:57:46 <suppi> iqubic, dante is back to using temp files so if you update you can get flycheck to update without having to save your file :)
21:59:11 <jackdk> suppi: since when? the saving all the time made me sad, and I just get whatever versions of emacs libs that trickle into nixpkgs :)
21:59:44 <Lycurgus> nix makes me sad
21:59:53 <Lycurgus> or would if I cared
21:59:59 <suppi> A week or too ago
22:00:58 <suppi> two*
22:08:30 * hackage pg-transact 0.2.0.1 - Another postgresql-simple transaction monad  https://hackage.haskell.org/package/pg-transact-0.2.0.1 (JonathanFischoff)
22:09:27 <iqubic> jackdk: I am in the same boat as you.
22:10:23 <iqubic> So I won't get the new version of dante, until it hits nixpgks unstable.
22:10:33 <iqubic> Also, the saving all the time is annoying.
22:11:51 <iqubic> So it may be a while before I get to stop saving everytime I want to see flycheck errors.
22:12:00 <koz_> I actually prefer lint-on-save.
22:12:03 <koz_> s/lint/check/
22:12:07 <koz_> But perhaps I'm just odd.
22:13:58 <iqubic> I have hlint run as part of the flycheck checking of the file. It's shown to me as a warning though.
22:14:08 <iqubic> So I can often ignore it.
22:14:34 <iqubic> But I chose not to ignore it, because HLint gives me good advice.
22:15:41 <iqubic> Like I had "fmap f (fmap g x)" in my source code. HLint told me I could rewrite it as "fmap (f . g) x" I assume that's a functor law of some sort which I was not aware of.
22:16:14 <iqubic> Is that true?
22:16:15 <koz_> iqubic: It's implied by parametricity from 'fmap id == id'.
22:16:25 <iqubic> what is parametricity?
22:16:37 <koz_> There's a paper called 'Theorems for Free' which explains this concept.
22:16:44 <koz_> (better than I could)
22:16:47 <iqubic> I'll look at it later.
22:16:51 <jle`> iqubic: it is indeed a general functor law yeah
22:17:06 <jle`> it represents the idea that a functor is a category homomorphism
22:17:10 <jle`> id is preserved and so is (.)
22:17:20 <jle`> map-and-compose is the same as compose-and-man
22:17:23 <jle`> *compse-and-map
22:17:30 <iqubic> But I assume that HLint's advice is usually good advice.
22:17:44 <jle`> it's good general advice for the most part yes :)
22:17:49 <jle`> it was really helpful for me
22:18:03 <jle`> it helped me get out of the habit of a lot of my weird parentheses, like writing sin(x)
22:18:24 <koz_> HLint is awesome.
22:19:16 <jle`> sometimes i wish life had an hlint
22:19:21 <iqubic> It actually introduced me to concatMap. I didn't know it existed until HLint told me to use it.
22:19:32 <koz_> :t concatMap
22:19:34 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
22:19:36 <sm[m]> Neil Mitchell is awesome
22:19:39 <koz_> :t traverse
22:19:40 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
22:20:07 <koz_> Not quite argh.
22:20:07 <iqubic> Also, at one point, HLint suggested I could refactor something to use a foldr.
22:20:13 <koz_> Not the generalization I was thinking of.
22:20:15 <jle`> :t foldMap
22:20:16 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
22:20:19 <koz_> YES THAT ONE
22:20:25 <koz_> How could I forget, I wrote a whole blogpost on it...
22:20:40 <koz_> The one where I realized 'toList = foldMap pure'.
22:20:52 <iqubic> Where is that post located?
22:20:54 <jle`> or hopefully soon, foldMap singleton
22:20:57 <iqubic> I wish to read it.
22:20:59 <koz_> iqubic: Let me dig up a link.
22:21:02 <MarcelineVQ> % getConst . traverse Const $ [[1,2,3],[4,5,6]]
22:21:03 <yahb> MarcelineVQ: [1,2,3,4,5,6]
22:21:10 <iqubic> jle`: What is the foldMap singleton?
22:21:16 <jle`> singleton x = [x]
22:21:21 <jle`> it's a new proposed function for Data.List
22:21:28 <iqubic> Ah. I see.
22:21:30 <koz_> iqubic: https://retro-freedom.nz/haskell-magic-from-semigroup-to-foldable.html
22:21:42 <koz_> jle`: Yeah, to match vectors, sets of all stripes, etc.
22:21:59 <iqubic> I thought you were talking about an addition to the Singletons library.
22:22:01 <koz_> :t foldMap pure
22:22:02 <lambdabot> (Foldable t, Monoid (f a), Applicative f) => t a -> f a
22:22:07 <jle`> hah. yeah the term is a little overloaded
22:22:10 <jle`> :t foldMap (:[])
22:22:12 <lambdabot> Foldable t => t a -> [a]
22:22:23 <iqubic> Will "singleton x = [x]" cause name clashes with the Singleton library?
22:22:27 <jle`> for now we just have good ol' robot monkey
22:22:29 <koz_> iqubic: Nope.
22:22:42 <koz_> jle`: So that would be pronounced 'fold map robot monkey'?
22:22:53 <koz_> (that sounds like the most weird electronic music duo ever)
22:23:02 <jle`> it sounds like a plaintext OTP
22:23:06 <iqubic> Singleton = (:[])
22:23:10 <MarcelineVQ> % :t (\f xs -> getConst . traverse (Const . f ) $ xs) -- koz_ traverse is okay too :O
22:23:11 <yahb> MarcelineVQ: (Traversable t, Monoid c) => (a -> c) -> t a -> c
22:23:15 <iqubic> For a pointfree style.
22:23:22 <koz_> MarcelineVQ: Yeah, I guess traverse is magical.
22:23:44 <koz_> The Const-based traverse is also somehow related to one of Edward's lens explanations if memory serves.
22:23:54 <koz_> The one involving fmap . fmap . fmap I think.
22:24:05 <jle`> one of my favorite foldables is `data Replicate a = Replicate Int a`
22:24:07 <MarcelineVQ> traverse is science, Const is magic
22:24:17 <iqubic> What does Replicate do?
22:24:18 <jle`> where toList (Replicate n x) = replicate n x
22:24:24 <jle`> but it cannot have a Traversable instance alas
22:24:40 <koz_> It's an excellent example of a Foldable that can't be a Traversable.
22:24:47 <iqubic> How so?
22:24:51 <koz_> (in fact, it's the exact one someone in here threw at me when I asked that question)
22:25:03 <iqubic> Can you not traverse it because it's infinite?
22:25:03 <koz_> iqubic: Are you asking how it's an excellent example, or how it can't be a Traversable?
22:25:04 <jle`> 'technically' there are a bunch of Foldables that can't be Traversables, because Foldable pretty much has no laws
22:25:08 <koz_> iqubic: It's quite finite.
22:25:11 <jle`> any * -> * can be a Foldable with toList _ = []
22:25:22 <koz_> jle`: Foldable is rather fast and loose like that yes.
22:25:29 <iqubic> But why can't it be traversable?
22:25:37 <jle`> iqubic: try writing traverse :)
22:25:50 <iqubic> :t traverse
22:25:51 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
22:26:05 <koz_> iqubic: A hint: because traverse is effectful, the values in the result don't depend on the values of the 'source' entirely.
22:26:05 <iqubic> It seems really simple.
22:26:12 <iqubic> Where's the challenge in this?
22:26:12 <koz_> But Replicate requires _all_ the values to match.
22:26:23 <iqubic> Huh???
22:26:33 <jle`> the basic higher-level concept is that Foldable lets you collapse aout of a container, but Traversable must allow you to reconstruct the original container
22:26:37 <jle`> with new items
22:27:06 <jle`> you cannot really reconstruct a Replicate with whatever items you want
22:27:10 <iqubic> You can't create new items.
22:27:15 <koz_> Since they must _all_ be the same.
22:27:24 <iqubic> All the items must be the same.
22:27:25 <koz_> And your effect f could do pretty much whatever.
22:27:33 <koz_> If it's say, IO.
22:27:43 <koz_> Or RandT g m a
22:27:47 <iqubic> If you change one element, then all the elements must change in the same way.
22:27:47 <jle`> @let data Replicate a = Replicate Int a deriving (Show, Functor, Eq)
22:27:49 <lambdabot>  Defined.
22:28:05 <jle`> @let instance Foldable Replicate where toList (Replicate n x) = replicate n x 
22:28:06 <lambdabot>  .L.hs:190:10: error: [-Wmissing-methods, -Werror=missing-methods]
22:28:06 <lambdabot>      • No explicit implementation for
22:28:06 <lambdabot>          either ‘foldMap’ or ‘foldr’
22:28:22 <jle`> @let instance Foldable Replicate where toList (Replicate n x) = replicate n x; foldMap f = foldMap f . toList
22:28:23 <lambdabot>  .L.hs:192:33: error:
22:28:23 <lambdabot>      Ambiguous occurrence ‘toList’
22:28:23 <lambdabot>      It could refer to either ‘F.toList’,
22:28:30 <jle`> @let instance Foldable Replicate where toList (Replicate n x) = replicate n x; foldMap f = foldMap f . F.toList
22:28:32 <lambdabot>  Defined.
22:28:40 <iqubic> And now how do you use it?
22:28:43 <jle`> > toList (Replicate 3 'a')
22:28:45 <lambdabot>  error:
22:28:45 <lambdabot>      Ambiguous occurrence ‘toList’
22:28:45 <lambdabot>      It could refer to either ‘F.toList’,
22:28:51 <jle`> > F.toList (Replicate 3 'a')
22:28:53 <lambdabot>  "aaa"
22:29:02 <jle`> a `Replicate 3 'a'` is basically like a container with three a's
22:29:04 <koz_> > F.toList (Replicate 3 'A')
22:29:06 <lambdabot>  "AAA"
22:29:11 <koz_> In a very compact form.
22:29:15 <koz_> It's basically run-length encoding.
22:29:15 <iqubic> What the heck would the foldr do?
22:29:26 <jle`> iqubic: foldr would be equivalent to foldr-ing on a list of three a's
22:29:34 <jle`> > foldr (+) 0 (Replicate 3 100)
22:29:35 <iqubic> Oh. I see.
22:29:36 <lambdabot>  300
22:29:48 <koz_> Or
22:29:52 <koz_> > sum (Replicate 3 100)
22:29:54 <iqubic> But why can't you make a traversable?
22:29:55 <lambdabot>  300
22:30:19 <iqubic> What happens if you turn DerivingTraversable on and try to use this?
22:30:27 <jle`> iqubic: 'traverse' requires you to map an effectful function over every 'item' (in this case, the three x's), and then replace them with the result of each
22:30:41 <jle`> iqubic: you get a different instance, the one where traverse and foldMap don't align
22:30:47 <iqubic> Ah. I see.
22:31:05 <jle`> one way to think of it is void . sequence should be sequence_
22:31:19 <jle`> sequence_ (Replicate 3 (putStrLn "hi")) would print "hi" three times
22:31:42 <koz_> :t (>>=)
22:31:43 <lambdabot> Monad m => m a -> (a -> m b) -> m b
22:31:48 <koz_> I can never remember that one either.
22:32:00 <jle`> but it's weird when you think about what sequence (Replicate 3 getLine) should be
22:32:00 <MarcelineVQ> pssh, it's easy, it's the opposite of =<<
22:32:22 <koz_> MarcelineVQ: Yes, because I can totally remember arbitrary orderings as long as they're backwards. :P
22:32:32 <MarcelineVQ> Well there you go, just do that then
22:32:34 <jle`> since sequence_ (Replicate 3 getLine) will run getLine three times, we'd expect sequence (Replicate 3 getLine) to do the same thing
22:32:53 <pycer> sometimes i wish life had an hlint
22:32:54 <jle`> but sequence has to return a new Replicate, but...what would the values in that Replicate be?  it'd have the same n, but...
22:33:57 <iqubic> What if the effectful computation is 'generating a random number'?
22:34:11 <jle`> exactly, there's no way to represent that as a new Replicate
22:34:19 <koz_> iqubic: That's the immediate counter-example I thought of when someone showed me Replicate.
22:34:26 <iqubic> How do you return the same random number N times?
22:34:32 <sm[m]> Shellcheck vs Hlint; which would win ?
22:34:38 <iqubic> That's not really random in that case.
22:34:43 <iqubic> What is Shellcheck?
22:34:56 <jle`> `Replicate 3 getLine` also has the same issue, you ask the user for three inputs and you're supposed to store all three inputs into the new Replicate
22:35:11 <jle`> but...Replicate can only hold one uniform value
22:35:34 <iqubic> Well, can't traverse over that.
22:36:01 <jle`> you can traverse_, but not traverse
22:36:06 <jle`> you can 'consume', but not 'reconstruct'
22:37:11 <iqubic> yeah.
22:37:27 <iqubic> But you can't have traverse_ only.
22:38:12 <jle`> traverse_ is Foldable
22:38:36 <iqubic> oh. weird.
22:39:00 <jle`> yeah, it allows you to 'consume', but not 'reconstruct'. that's the essense of FOldable vs. Traversable
22:40:33 <iqubic> Ah, I see.
22:40:43 <iqubic> is Replicate a functor?
22:40:54 <iqubic> is it an applicable?
22:40:57 <jle`> if you think of it as a list of repeated items, yeah :)
22:41:06 <iqubic> I think it should be a monad.
22:41:13 <koz_> iqubic: Applicative right?
22:41:35 <iqubic> What kind of monad isn't Applicative?
22:41:45 <jle`> its Applicative instance is basically Writer (Product Int), yeah. and so too is its Monad
22:41:50 <koz_> I meant it in response to you calling Applicatives applicables. :P
22:42:02 <koz_> jle`: So what, its monad is diagonalization?
22:42:11 <iqubic> How does that work?
22:43:07 <jle`> no it'd be the same as for list
22:43:31 <iqubic> Isn't the list monad a bit broken?
22:43:32 <koz_> Ah, right.
22:43:42 <iqubic> Or am I thinking of ListT being broken?
22:43:45 <koz_> I've been looking at sized vectors too long. :P
22:43:48 <jle`> return = Replicate 1; Replicate n x >>= f = let Replicate n' y = f y in Replicate (n * n') y
22:43:59 <jle`> which is exactly the instance for Writer (Product Int) which is kind of neat
22:44:09 <iqubic> How would join work?
22:44:29 <koz_> You get one really huge Replicate.
22:44:40 <jle`> i'll give you a hint; for Writer, join (Writer w (Writer v x)) = Writer (w <> v) x
22:44:52 <iqubic> join (Replicate n (Replicate m x)) = Replicate (n * m) x
22:44:55 <iqubic> Is that right?
22:45:34 <jle`> yeah :)  it matches the behavior of join-ing a list of constnat lists
22:45:42 <jle`> er, a constant list of constant lists
22:45:46 <iqubic> Cool.
22:45:52 <jle`> > join [[1,1,1],[1,1,1],[1,1,1],[1,1,1]]
22:45:54 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1]
22:46:28 <dminuoso> 07:45:36      iqubic | [05:41:14] What kind of monad isn't Applicative?
22:47:02 <iqubic> How do you construct (>>=) using join/
22:47:07 <dminuoso> iqubic: So strictly speaking monad is quite orthogonal from applicative. It just so happens that every monad induces a trivial applicative that, for all intents and purposes is just the monad effect that happens to be modellable with applicative.
22:48:16 <maerwald> :t \f -> join . fmap f
22:48:17 <lambdabot> Monad m => (a1 -> m a2) -> m a1 -> m a2
22:48:52 <iqubic> jle`: Does my version of join for Replicate work with this definition?
22:49:07 <jle`> yes it does :)
22:49:30 <koz_> iqubic: Yes. Think of it like this - you take a Replicate, and from each thing in it, make another Replicate. Then smoosh all the resulting Replicates into one big Replicate.
22:49:58 <iqubic> Cool.
22:50:12 <jle`> neat thing is that fold = join, just like for lists
22:50:23 <jle`> * join = fold, i suppose
22:50:28 <dminuoso> % :t fold
22:50:29 <yahb> dminuoso: (Foldable t, Monoid m) => t m -> m
22:50:41 <iqubic> is that true?
22:51:20 <iqubic> :t join
22:51:22 <lambdabot> Monad m => m (m a) -> m a
22:51:29 <iqubic> the types don't really line up.
22:51:30 <jle`> oh, actually that's not an accurate characterization
22:51:46 <jle`> forget i said that :)
22:51:55 <iqubic> Yeah. The types are too distinct.
22:52:24 <iqubic> The kind of "m (m a)" and "t m" are different, regardless of what constraints you add.
22:52:35 <dminuoso> jle`: By the way, I should some day spend some thought on how to construct "EFMonoid Identity Day" from "EFMonoid Identity Compose" using category theory. :|
22:52:38 <jle`> ah, but join = fold for lists
22:52:44 <iqubic> Or something like that?
22:52:48 <jle`> it's just not true for Replicate
22:52:58 <iqubic> jle`: How does "join = fold" for lists?
22:53:15 <iqubic> The types still don't line up.
22:53:24 <dminuoso> iqubic: Assuming you have a list of lists?
22:53:29 <jle`> > join [[1,2,3],[4,5,6],[7,8,9]]
22:53:32 <lambdabot>  [1,2,3,4,5,6,7,8,9]
22:53:35 <dminuoso> iqubic: Then `t ~ []` and `m ~ []`
22:53:36 <jle`> > fold [[1,2,3],[4,5,6],[7,8,9]]
22:53:38 <lambdabot>  [1,2,3,4,5,6,7,8,9]
22:53:45 <iqubic> :t fold
22:53:46 <lambdabot> (Foldable t, Monoid m) => t m -> m
22:53:49 <jle`> :t [join, fold]
22:53:51 <iqubic> Oh. I see.
22:53:51 <lambdabot> (Monad m, Foldable m, Monoid (m a)) => [m (m a) -> m a]
22:53:55 <iqubic> that makes sense.
22:54:08 <dminuoso> jle`: cunning trick!
22:54:11 <jle`>  :t [x,y] is a trick i use to see how two types unify
22:54:20 <dminuoso> I love that.
22:54:30 <iqubic> I love that.
22:54:35 <dminuoso> jle`++
22:54:35 <jle`> :t [join, fold, concat]
22:54:37 <lambdabot> [[[a]] -> [a]]
22:54:42 <iqubic> What is that?!?!
22:54:45 <jle`> :t head [join, fold, concat]
22:54:47 <lambdabot> [[a]] -> [a]
22:54:55 <jle`> it's saying that join, fold, and concat can all be the same type
22:54:59 <iqubic> Huh? how do those all have the same types?
22:55:01 <jle`> and they're actually all equal too when they have the same type
22:55:17 <jle`> well, they apparently all unify with [[a]] -> [a] :)
22:55:17 <iqubic> Weird. That's so weird.
22:55:19 <dminuoso> jle`: Oh and because hindley milner always gives you the most general type, you still get to see the most general type in which they are the same.
22:55:27 <dminuoso> Brilliant. :)
22:55:34 <jle`> i didn't think of the trick :O
22:55:38 <iqubic> Who did?
22:55:53 <MarcelineVQ> <-
22:55:55 <jle`> i'm not sure, i picked it up some time in my past six years on this channel heh
22:56:16 <iqubic> I think MarcelineVQ figured out the trick.
22:56:30 <koz_> Wow, that's pretty handy.
22:56:39 * koz_ quickly resumes writing finitary some more.
22:56:43 <iqubic> If the functions can't be unified, then you'll get a type error, right?
22:56:45 <koz_> I'll publish it one day!
22:56:49 * MarcelineVQ collects this fake evidence of having figured it out
22:56:55 <jle`> > [True, "hello"]   -- iqubic 
22:56:57 <lambdabot>  error:
22:56:57 <lambdabot>      • Couldn't match expected type ‘Bool’ with actual type ‘[Char]’
22:56:57 <lambdabot>      • In the expression: "hello"
22:57:07 <jle`> :t [[], "hello"]
22:57:09 <dminuoso> iqubic: What else should it do?
22:57:09 <lambdabot> [[Char]]
22:57:20 <iqubic> Yeah. So you'll see the two functions types that Haskell is trying to unify.
22:58:13 <mycroftiv> finally i have an actual fully working up to date ghc/stack/haskell environment, it feels amazing to not have everything be 60% broken like it was for the past couple weeks of fighting with old debian packages
22:58:20 <jle`> mycroftiv: congrats :)
22:58:42 <koz_> jle`: Yep, that's a feeling.
22:59:10 <jle`> > :t [join, fold, concat, head, (!! 3)]
22:59:10 <mycroftiv> jle: thanks, i appreciate the couple tips you gave, helped keep me on track.
22:59:12 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
22:59:15 <jle`> :t [join, fold, concat, head, (!! 3)]
22:59:17 <lambdabot> [[[a]] -> [a]]
22:59:30 <jle`> mycroftiv: no problem :)
22:59:49 <jle`> not sure i remember these tricks i supposedly shared though
23:00:26 <mycroftiv> the main thing was telling me to just grab the current binary releases and not try to build ghc from source, once i had picked a distro foundation, so that has worked out well
23:00:58 <jle`> ah, glad it all worked out then :)
23:05:07 <mycroftiv> ive been more or less full-time coding for 15 years and the past couple months of haskell ive finally broken through to actually feeling like im getting a clue about what its really all about...now i just need another decade of functional coding time
23:06:15 <jle`> mycroftiv: that's a good way to temper your expectations :)
23:06:47 <jle`> a lot of people get frustrated for not grasping functional programming after a few days or weeks, even though it took them many years to get that far in an 'imperative' mindset 
23:07:10 <jle`> however i don't really feel like both extremes (very short vs. equal to your traditional programming background) represent the reality for most people in the end
23:10:20 <dminuoso> I think its understandable, because once you have a trained imperative mindset, you can pick up other imperative languages relatively quickly.
23:10:31 <mycroftiv> there is so much diversity in what people are trying to do. im using haskell to 1) generate typechecked Forth and 2) build trees of parameterized searches of infinite function spaces - and both of these things are more or less new 'kinds' of coding to me, relative to what ive done before
23:11:04 <iqubic> Typechecked Forth sounds complicated.
23:11:33 <mycroftiv> im only typechecking a subset, its actually pretty easy in theory, forth words just eat stack items and i need to verify they are eating the right kind of stack items, especially pointer types
23:11:40 <dminuoso> mycroftiv: After maybe a year of Haskell, I realized that Haskell is not so different from other languages. There's so much striking similarity in how you structure code, so transferring knowledge between languages is very easy after you reach a certain threshold.
23:12:07 <dminuoso> But it's hard to see how similar say Haskell and <pick your favourite imperative language> are until you properly understand Haskell.
23:13:11 * koz_ just writes Haskell because it's the most fun.
23:13:23 <mycroftiv> well, what i do see is that shell pipelines are well-known to be 'functional' and that filesystem trees are recursive mappable structures, so a lot of what i do in plan 9 does have some high level concept-parallels to haskell stuff
23:14:02 <mycroftiv> the vital difference is getting strong types rather than everything being an untyped bytestream
23:14:29 <c_wraith> well, purity is a pretty big difference too
23:14:46 <mycroftiv> in a shell pipeline context sed is a pure function though right?
23:14:56 <c_wraith> depends on the command line options.
23:15:09 <dminuoso> mycroftiv: sed can create or manipulate files.
23:15:11 <mycroftiv> i mean, what sed does depends entirely on what flags i give it and what input i send through
23:15:25 <c_wraith> and for some flags, the contents of the filesystem
23:15:52 <mycroftiv> i understand, im just thinking of the most naive |sed 's/foo/bar/g'
23:15:55 <c_wraith> you can use sed purely, but you don't have to
23:16:57 <c_wraith> Haskell doesn't give you an option.  (->) is the type constructor for pure function.
23:18:14 <c_wraith> so yes, thinking of things in terms of transforming data from an input state to an output state is a good start.  But there's more.  :)
23:22:43 <mycroftiv> i have had several experiences with haskell where i have felt the type system 'writing the code for me' which have been borderline spooky
23:24:04 <mycroftiv> where im not sure exactly what im trying to express, and typing partially formed version of it in and getting the type errors back point me toward how i should actually be composing my functions and data
23:24:33 <c_wraith> This is what we call "using the compiler as a mental force-multiplier"
23:24:46 <koz_> I do this all the time.
23:24:57 <koz_> GHC has found my logic wanting on _many_ an occasion. :P
23:25:00 <c_wraith> You could spend a bunch of time understanding code, or you could just have the compiler ensure you're using it correctly.
23:25:10 <koz_> Basically, your compiler is an assistant.
23:26:28 <mycroftiv> the really cool thing is when you have found some composition/object and do :t thisThing and then see that it is actually the same type as another object, and you realize a new useful composition because you hadnt realized that foo() could process both baz and buppos
23:26:30 <jle`> yeah, my relationship with ghc has been 'why is it always telling me what i'm doing wrong' to 'how can i get ghc to write my code for me'
23:26:45 <jle`> *has transformed from
23:26:45 <koz_> LOL
23:27:05 <jle`> and i feel like this was shaped by my experiences of typecheckers from other languages, which only really worked to slow me down, not speed me up
23:27:09 <jle`> like it does in haskell
23:27:13 <EvanR> rather than types being guard rails or straight jacket, types lead you to the proper code like treasure map
23:27:42 <iqubic> Huh?? What did I miss?
23:27:44 <mycroftiv> and the way currying/partial application works multiplies this hugely, because you often realize you have the tool you need just by 'leaving out' a parameter
23:28:05 <c_wraith> I wrote an article about this...  wow, 5 years ago.  It made a lot of people angry.  Unfortunately, School of Haskell no longer supports the interactive code bits that were fun.
23:28:09 <koz_> jle`, or anyone else: Can someone tell me what I'm lying to GHC about here? https://gist.github.com/kozross/10c240c4e22d9bbf5aa35830f4c324eb
23:28:11 <c_wraith> https://www.schoolofhaskell.com/user/chowells79/types-not-tutorials
23:29:20 <mycroftiv> "how to not math" is a great section heading
23:29:27 <c_wraith> (It makes people angry because I'm very actively critical of tutorials.  I consider them to be straightjackets that create cargo-cult programmers)
23:30:00 <jle`> koz_: looks like you might need more type clues in your invocation of (==)
23:30:13 <koz_> So what, I need to use TypeApplications a bit?
23:30:25 <jle`> yeah or just a type annotation
23:30:38 <koz_> So wait, how do I annotate the type of (==)?
23:30:38 <jle`> or maybe applications for over2 would work too
23:30:48 <jle`> ((==) :: ... -> ... -> Bool), whatever you intended it to be
23:30:51 <koz_> Ah.
23:31:05 <jle`> or over2 as well, maybe, although i'm not sure where that function is from
23:31:11 <koz_> CoercibleUtils.
23:31:25 <koz_> It's Conor McBride's Epigram stuff, based on Coercible.
23:31:33 <jle`> ah that's a nice module
23:31:44 <EvanR> c_wraith: i figured people got mad because it says "to hell with docs, all you need is the type!"
23:32:01 <jle`> over2 could probably be given type applications too instead of (==), that might work better
23:32:13 <koz_> I think it might, since a type annotation on (==) fails to convince GHC.
23:32:27 <jle`> yeah, i didn't realize over2 was a coercible type of thing
23:32:37 <jle`> you'd need annotations for (==) and Set too i think.  over2 would cover both
23:32:58 <jle`> but yeah the error "The type variable n1 is ambiguous" usually just means you need more annotations
23:33:48 <mycroftiv> c_wraith: thanks, that was a really excellent post that captures exactly what I have been experiencing myself already at an earlier stage of learning
23:34:27 <koz_> jle`: Still not helping even if I do this: https://gist.github.com/kozross/10c240c4e22d9bbf5aa35830f4c324eb
23:34:54 <koz_> I don't think I can be much more specific about what I want than that, lol.
23:35:24 <jle`> does it work when you manually pattern match and reconstruct isntead of using coercible?
23:35:30 * koz_ tries.
23:36:00 <koz_> Nope, same issue.
23:36:04 <jle`> also i wonder where the 256 comes from
23:36:18 <koz_> PackWord8 has an Unbox instance only in that case.
23:36:41 <jle`> but PackedWord8 doesn't use n anywhere
23:36:56 <bolver> i have this code: let f x = print . sqrt x
23:36:58 <koz_> It comes from a Finitary n constraint on its contents.
23:37:07 <koz_> Let me paste for context.
23:37:28 <jle`> but that constraint isn't being used is it?
23:38:02 <koz_> https://gist.github.com/kozross/06c15a684974a5626ef1f6c0ac7bced7
23:38:21 <bolver> i know how to fix this code -- like let f x = print . sqrt $ x -- but i want to understand the error message, specifically why ghc infers the type of f the way it does
23:38:42 <jle`> koz_: oh ah, it looks like it's a different n
23:38:48 <koz_> Wait what.
23:38:57 <koz_> I have ScopedTypeVariables on.
23:39:07 <koz_> OH WAIT NO I GET IT.
23:39:07 <jle`> koz_: the n in Set isn't realted to the n related to a
23:39:14 <koz_> I need a Finitary constraint right?
23:39:21 <jle`> you'd need maybe Finatary n a => ...
23:39:26 <jle`> to link the Set's n with a's n
23:39:33 <koz_> Thanks GHC, for making me not assume silly things.
23:39:43 <bolver> the inferred type for f in the error message is  f :: forall a a1. (Floating (a -> a1), Show a1) =>  (a -> a1) -> a -> IO ()
23:40:11 <jle`> bolver: how are you getting that error message?
23:40:20 <bolver> running in ghci
23:40:29 <jle`> are you just typing `let f x = print . sqrt $ x` ?
23:40:38 <dminuoso> % :t sqrt
23:40:39 <yahb> dminuoso: Floating a => a -> a
23:40:39 <jle`> because that works just fine for me
23:40:46 <jle`> when i try it in my ghci
23:41:02 <dminuoso> bolver: I think you meant `f x = print . sqrt x` right?
23:41:17 <koz_> jle`: Could you elaborate what you meant by a 'different' n in that context? I think I understand, but I just want to be sure.
23:41:45 <jle`> koz_: the 'k' in the constraint of the Binary instance comes from Finitary k a
23:41:55 <jle`> so maybe for some X you have Finitary 10 X
23:42:09 <jle`> so now nothing is stopping you from doing `Set 25 X`
23:42:19 <jle`> even though you have Finitary 10 X, you can still put it in a Set 2
23:42:21 <jle`> *Set 25
23:42:30 <koz_> Ah, right.
23:42:34 <jle`> the n in the Set n and the k in Finitary k X aren't linked
23:42:40 <koz_> Unless I say they are.
23:42:44 <jle`> unless you require (Fintary n X) => ...
23:42:47 <koz_> Which is what I'm doing by providing a constraint.
23:42:49 <jle`> then k ~ n
23:43:17 <jle`> so you'd only have an Eq instance for Set 10 X, and not for Set 25 X
23:43:59 <jle`> whereas right now you're writing an Eq instance that is meant to be valid for all Set 0 X, Set 1 X, Set 2 X, ... Set 255 X
23:44:24 <jle`> but you only want to define one for Set 10 X
23:44:28 <koz_> Indeed.
23:44:58 <jle`> the error message is admittedly a little weird
23:45:14 <koz_> Yeah, it's not really an issue of _ambiguity_.
23:45:22 <koz_> But I guess GHC can't read minds.
23:45:25 <koz_> Yet.
23:45:42 <HaskellNoob> Hello How can I (or is it possible) to parameterize functions over their type to avoid different functions for each potential type to avoid awkward code like this: https://pastebin.com/raw/AHqZbwAt ?
23:46:28 <koz_> The type of X (the data constructor) is already a -> Int -> X a
23:46:28 <jle`> koz_: yeah, it's technically not 'ambiguous' in the case of fundeps. but maybe withotu an explicit typeclass constraint, the fundep never gets invoked?
23:46:49 <koz_> jle`: Yeah, I guess not - it can't assume anything without the constraint there to tell it things.
23:47:22 <jle`> HaskellNoob: i think the way you have it is the least awkward way
23:47:29 <jle`> otherwise you'd have different behavior based on different types
23:47:39 <jle`> er i mean, you have different behavior based on different types
23:47:43 <jle`> so you'd want them to have different names
23:48:18 <HaskellNoob> Ok I guess I'm just used to dependent types and being able to pass types into functions
23:48:28 <jle`> this is a principle of Haskell -- parametric polymorphism -- that says you can't branch based on different types for polymorphic types
23:48:46 <VaNilLa[m]> This does seem like a dependent types situation.
23:49:00 <jle`> HaskellNoob: if you pass in Typeable you can branch on it, but it's not really a good way to write readable/understandable code
23:49:14 <jle`> initializeX :: Typeable a => a -> X a
23:49:30 <jle`> er
23:49:35 <jle`> initializeX :: forall a. Typeable a => a -> X a
23:49:55 <jle`> intializeX x
23:50:34 <VaNilLa[m]> jle': The code has String -> X Char and Bool -> X Bool, which don't fit a -> X a... am I missing something?
23:50:56 <orzo> it might be better if X is a GADT with multiple constructors
23:51:15 <jle`> ah, yeah. in that case the only way you could unify those of different types is with a typeclass, type family, GADT, etc.
23:51:36 <jle`> instance Initializeable a b | a -> b where
23:51:40 <jle`>   initializeX :: a -> X b
23:51:58 <bolver> jle`: i just typed let f x = print . sqrt x in ghci and got the error message
23:52:08 <jle`> instance Initializeable Bool Bool where initializeX = ...; instnace Initializeable String Char where initializeX =..
23:52:20 <jle`> but it's not quite a way people usually recommend you to write haskell
23:52:30 <jle`> bolver: ah, you wrote let f x = print . sqrt $ x earlier
23:52:38 <VaNilLa[m]> initializeX :: Initializeable a b => a -> X b ?
23:52:51 <jle`> that would be the final type of the method, yeah
23:53:12 <jle`> you could also use an associated type
23:53:15 <VaNilLa[m]> nice
23:53:22 <jle`> but again usually common style is to give these functions different names
23:53:40 <jle`> it's possible but not recommended and usually leads to code that is difficult to maintain or read
23:54:25 <jle`> and the fundep is necessary for useful type inference
23:55:54 <bolver> jle`: i know how to fix the code, but i want to understand the error message, specifically why ghc infers the type of f the way it does
23:56:22 <bolver> why does ghc say the type of f is  (a -> a1) -> a -> IO ()?
23:58:57 <c_wraith> bolver: try inlining the (.) operator in the incorrect version to see if that makes it any clearer
23:59:08 <VaNilLa[m]> Well, you're composing print and sqrt x. the type of (.) is (b -> c) -> (a -> b) ->  (a -> c), so at the very least the result has to be a function, and since print is a -> IO(), that's where that comes from
23:59:13 <jle`> bolver: use the definition of (.):
23:59:29 <jle`> (f . g) = \x -> f (g x)
23:59:41 <bolver> yes
23:59:43 <jle`> so when you write print . (sqrt x)
23:59:52 <jle`> that's equivalent to \y -> print (sqrt x y)
23:59:58 <bolver> yes
