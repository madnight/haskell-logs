00:26:06 <iqubic> dminuoso: You still there?
00:35:08 <dminuoso> iqubic: Not quite.
00:35:30 <dminuoso> iqubic: Dont construct Pretext by hand.
00:36:04 <dminuoso> iqubic: Here's an additional tip: Make use of the fact that Pretext is a Functor.
00:36:10 <iqubic> Oh.
00:36:25 <dminuoso> (Or rather, `Pretext s` is)
00:36:30 <iqubic> How can I do this?
00:37:21 <dminuoso> iqubic: What does sell do?
00:38:32 <iqubic> duplicate = getCompose . experiment (Compose . fmap sell . sell)
00:38:38 <iqubic> I made it work.
00:40:07 <iqubic> The right most sell creates a Pretext s s and then we fmap sell over that to get a Pretext s (Pretext s s).
00:41:31 <dminuoso> There you go.
00:41:41 <dminuoso> iqubic: The relationship is as follows now:
00:41:51 <dminuoso> The joke read: lenses are coalgebras for the costate comonad.
00:42:02 <dminuoso> Costate is just an older name for Store
00:42:33 <dminuoso> type Algebra f a = f a -> a
00:42:38 <dminuoso> type Colgebra f a = a -> f a
00:42:55 <dminuoso> Now if you consider your traverseZ we'll do the following trick:
00:43:02 <dminuoso> traverseZ :: (Functor f) => (a -> f a) -> V3 a -> f (V3 a)
00:43:03 <dminuoso> Flip the arguments
00:43:15 <dminuoso> traverseZ :: (Functor f) => V3 a -> (a -> f a) -> f (V3 a)
00:43:20 <dminuoso> Understand that we could write this as: 
00:44:23 <iqubic> traverseZ :: V3 a -> Pretext a (V3 a)
00:44:30 <iqubic> I think that's valid.
00:44:55 <dminuoso> iqubic: Right, so there's just a newtype wrapper in there. 
00:45:04 <iqubic> Right.
00:45:10 <dminuoso> And since Pretext is just a different encoding for Store, you could say that:
00:45:23 <koz_> (yay for PLTborat)
00:45:48 <iqubic> traverseZ :: V3 -> Store a (V3 a) is also valid.
00:46:07 <iqubic> Write it in either way, and then just use one of these:
00:46:11 <iqubic> storeToPretext s = Pretext (`experiment` s)
00:46:15 <iqubic> pretextToStore = experiment (Store id)
00:46:18 <iqubic> As needed.
00:46:36 <dminuoso> iqubic: Or in terms of coalgebra: `traverseZ :: Coalgebra (Pretext a) (V3 a)` if Im not mistaken
00:46:46 <iqubic> I'm not sure the pretextToStore is right though.
00:46:54 <iqubic> Is it supposed to have id there.
00:47:17 <dminuoso> iqubic: Think about what experiment does.
00:47:20 <iqubic> data Store s a = Store (s -> a) a
00:48:05 <dminuoso> iqubic: So indeed, the way you wrote lens already a long while ago, is using the Pretext encoding.
00:48:19 <dminuoso> *your lenses
00:48:30 <iqubic> experiment takes a 'Pretext s a' and runs the function with a given input.
00:49:26 <dminuoso> iqubic: Well its rather that Pretext is a suspended experiment where we have decided on the store already
00:49:27 <iqubic> experiment on Pretexts just runs the function 'forall f. Functor f => (s -> f s) -> f a'
00:49:40 <iqubic> Right. That's correct.
00:49:42 <dminuoso> iqubic: So that function you run the experiment with, that's the crucial part.
00:49:57 <dminuoso> So your experiment function is `\x -> Store id x`
00:50:02 <dminuoso> What kind of experiment is that?
00:50:03 <iqubic> Correct.
00:50:19 <iqubic> I'm not sure what kind of experiment that is.
00:51:22 <dminuoso> (\x -> Store id x) `experiment` (Store f s)
00:51:25 <koz_> dminuoso: Remind me how Store is defined?
00:51:45 <iqubic> koz_: data Store s a = Store (s -> a) a
00:52:15 <koz_> So wait, Store id ~ Identity?
00:52:30 <iqubic> Oh, yeah. I guess it does.
00:52:45 <dminuoso> koz_: Not quite?
00:52:58 <dminuoso> Oh. Well yes.
00:53:36 <iqubic> So, what now?
00:53:54 <dminuoso> iqubic: What does Store's experiment do?
00:54:34 <iqubic> experiment f (Store g s) = g <$> f s
00:54:39 <iqubic> It does that.
00:55:42 <dminuoso> iqubic: So a store has some location, encoded by its first type argument. The idea is now this:
00:56:30 <iqubic> I thought the first argument was a function of type: (s -> a).
00:56:38 <iqubic> How is that a location?
00:56:47 <dminuoso> iqubic: Oh, we keep flipping the arguments around I suppose
00:57:07 <dminuoso> iqubic: `experiment f (Store s g) = g <$> f s`
00:57:08 <iqubic> It's fine.
00:57:12 <iqubic> Sure.
00:58:05 <dminuoso> iqubic: You can think of experiment as a rich form of peeks.
00:58:24 <iqubic> peeks f (Store g s) = g $ f s
00:58:28 <iqubic> experiment f (Store g s) = g <$> f s
00:58:39 <iqubic> That's an interesting connection.
00:58:47 <dminuoso> iqubic: Instead of just saying "use this delta/offset function and give me the result", you can perturbate it with computational context
00:58:54 <dminuoso> for example
00:59:24 <dminuoso> (\x -> [x - 1, x, x - 2]) `experiment` someStore
00:59:55 <dminuoso> This gives you non-deterministic access into the contianer
01:00:09 <iqubic> What would that do?
01:00:27 <dminuoso> iqubic: It gives you a sort of "fuzzy" result.
01:00:59 <iqubic> :t (<$>)
01:01:00 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:03:12 <iqubic> so instead of just querying the Store at one location, you first use a function 'Functor f :: (s -> f s)' to get a functor full of all the locations you want to query.
01:03:19 <dminuoso> % :t someStr
01:03:19 <yahb> dminuoso: Store Int Char
01:03:29 <dminuoso> iqubic: I have hidden from you how I constructed this.
01:03:38 <iqubic> Yes you have.
01:03:40 <dminuoso> iqubic: This is a container of characters, indexed by integers.
01:03:48 <iqubic> I see.
01:04:11 <iqubic> % pos someStr
01:04:11 <yahb> iqubic: 0
01:04:38 <iqubic> % peek someStr 0
01:04:38 <yahb> iqubic: ; <interactive>:173:1: error:; Ambiguous occurrence `peek'; It could refer to either `Control.Comonad.Store.peek', imported from `Control.Comonad.Store' (and originally defined in `Control.Comonad.Store.Class'); or `Foreign.Storable.peek', imported from `Foreign.Storable'
01:04:42 <dminuoso> iqubic: Use Co.
01:04:46 <dminuoso> iqubic: `Co.peek` :-)
01:04:54 <iqubic> % Co.peek someStr 0
01:04:54 <yahb> iqubic: ; <interactive>:174:1: error:; * Ambiguous type variable `w0' arising from a use of `it'; prevents the constraint `(ComonadStore (Store Int Char) w0)' from being solved.; Probable fix: use a type annotation to specify what `w0' should be.; These potential instances exist:; instance [safe] ComonadStore s w => ComonadStore s (EnvT e w) -- Defined in `Control.Comonad.Store.Cla
01:05:09 <iqubic> Erm...?!?
01:05:27 <dminuoso> Ahh wait
01:05:31 <dminuoso> Heh
01:05:40 <iqubic> I'm going to see if you can fix this.
01:05:58 <dminuoso> iqubic: You flipped the arguments aroud.
01:06:03 <dminuoso> % Co.peek 0 someStr
01:06:03 <yahb> dminuoso: 'f'
01:06:28 <iqubic> % Co.peek 1 someStr
01:06:28 <yahb> iqubic: 'o'
01:06:35 <dminuoso> iqubic: But lets ignore peek, its not what we want.
01:06:39 <dminuoso> iqubic: Lets focus on peeks, it can do more.
01:06:45 <iqubic> Peeks
01:06:59 <dminuoso> because `peek` doesn't make use of the containers current location
01:07:05 <dminuoso> we can recover peek from peeks trivially
01:07:10 <iqubic> Yeah.
01:07:36 <dminuoso> % Co.peeks id someStr
01:07:36 <yahb> dminuoso: 'f'
01:07:41 <dminuoso> % Co.peeks (const 1) someStr
01:07:41 <yahb> dminuoso: 'o'
01:08:18 <dminuoso> iqubic: So all `experiment` does, is give us effectful access/access with computational context into the container. Sort of.
01:08:44 <dminuoso> % Co.experiment (\x -> [10, x, x+1]) someStr
01:08:44 <yahb> dminuoso: "afo"
01:08:47 <iqubic> peek s = peeks (const s)
01:08:51 <dminuoso> Right.
01:09:07 <dminuoso> iqubic: Do note how `id` and `const` play a large role, just like the Const and Identity functors do. :-)
01:09:16 <iqubic> % Co.experiment (const [0..10]) someStr
01:09:16 <yahb> iqubic: "foobarfooba"
01:09:20 <iqubic> I see.
01:09:38 <iqubic> I think I have some idea how you created this.
01:09:51 <dminuoso> iqubic: The relevant part is, it doesnt matter how I created it.
01:09:59 <iqubic> No. It really doesn't.
01:10:23 <dminuoso> iqubic: (And this is sort of the beauty of the Store interface, because it lets you separate the implementation details of the access)
01:10:37 <iqubic> % Co.seek 0 someStr
01:10:37 <yahb> iqubic: ; <interactive>:185:1: error:; * No instance for (Show (StoreT Int Identity Char)) arising from a use of `print'; * In a stmt of an interactive GHCi command: print it
01:10:40 <dminuoso> (I could switch out the implementation with whatever efficient encoding I wanted, and you wouldn't be any wiser)
01:10:46 <iqubic> Alright. Makes sense.
01:11:21 <iqubic> Wait. Seek just changes the current position that the structure is looking at.
01:11:22 <dminuoso> iqubic: And Pretext is just a different encoding. If you think back, it all started by trying to specialize Traverse for "traverse over a single element"
01:11:50 <dminuoso> If we now look at something fancy:
01:12:02 <iqubic> "traverse over a single element" that's called a lense.
01:12:07 <iqubic> *lens
01:12:19 <dminuoso> newtype Pretext s a = Pretext { runPretext:: forall f. Functor f => (s -> f s) -> f a }
01:12:33 <iqubic> That's the same as what we had before.
01:12:41 <iqubic> Exact same.
01:13:56 <iqubic> dminuoso: Not sure where you are going from.
01:14:18 <iqubic> *from here.
01:14:44 <dminuoso> type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
01:15:11 <iqubic> Alright... Looks a bit similar.
01:15:25 <dminuoso> iqubic: Lets consider just monomorphic lenses for simplicities sake
01:15:38 <dminuoso> Then you'd have `Lens' s a ~ a -> Pretext a s`
01:16:05 <dminuoso> type Traversal s t a b = forall f. Applicative f => (a -> f b) -> s -> f t 
01:16:21 <dminuoso> If you compare that with Lens, you'll notice that the only difference is that the Functor constraint is upgraded to Applicative.
01:16:29 <iqubic> Sure.
01:16:33 <iqubic> That makes sense.
01:16:51 <iqubic> Can we upgrade our Pretext in the same way?
01:16:58 <dminuoso> iqubic: Yes.
01:17:06 <dminuoso> iqubic: We call this version Bazaar
01:17:09 <dminuoso> newtype Bazaar s a = Bazaar { runBazaar :: forall f. Applicative f => (s -> f s) -> f a }
01:17:28 <iqubic> What a bizarre name.
01:17:33 <dminuoso> Which is exactly like Pretext, except there's an Applicative. This is no longer isomorphic to Store, the corresponding data type is highly exotic actually.
01:17:50 <iqubic> Why is it no longer isomorphic?
01:18:04 <dminuoso> iqubic: Because not all Functors are Applicative? :<
01:18:19 <dminuoso> iqubic: Or rather because Applicative is different from Functor?
01:18:29 <iqubic> Oh. Right.
01:18:45 <iqubic> Applicative adds pure.
01:18:53 <dminuoso> Well its rather about <*> actually...
01:19:47 <dminuoso> iqubic: Or look at this:
01:19:47 <iqubic> A quick google search for Haskell and Bazaars leads me to this weird type:
01:19:49 <iqubic> data FunList a t = Done t | More a (FunList a (a -> t))
01:19:57 <dminuoso> type Fold s a = forall f . (Contravariant f, Applicative f) => (a -> f a) -> s -> f s
01:20:07 <dminuoso> iqubic: As you can see, all these optics have the same shape, they just differ in the constraints.
01:20:10 <iqubic> It's the same thing.
01:20:18 <dminuoso> iqubic: Indeed.
01:20:39 * ski likes "empty considerations"
01:21:07 <iqubic> This is like that one jle` article where he talks about the Strong and Choice profunctors in relation to lenses.
01:21:19 <iqubic> https://blog.jle.im/entry/lenses-products-prisms-sums.html
01:21:29 <dminuoso> iqubic: And sometimes lens sort of "collapses" the polymorphism to create strong restrictions
01:21:32 <dminuoso> type Getting r s a = (a -> Const r a) -> s -> Const r s 
01:21:48 <dminuoso> But that form/shape remains the same.
01:21:51 <iqubic> Sure.
01:22:03 <iqubic> That's just (f ~ Const r)
01:22:09 <dminuoso> So Pretext really just fully captures the interface you have already used when you came up with traverseZ etc.. :)
01:22:16 <iqubic> Yes. Yes it does.
01:22:45 <iqubic> This is really really cool
01:23:22 <iqubic> What is the point of all this?
01:23:49 <dminuoso> iqubic: I just wanted to give you some perspective of how your original excercises connect to the actual lens library.
01:24:13 <iqubic> Ah. I see. I love this connection.
01:25:21 <iqubic> I think that both Bazaar and FunList can be Comonads and also ComonadStores, but I don't want to be the one that writes those instances.
01:25:42 <dminuoso> iqubic: Actually Bazaar is simpler than Pretext. :-)
01:25:51 <dminuoso> Even more so since you have already written Bazaar.
01:25:54 <iqubic> Why?!?!
01:26:38 <iqubic> Why are the Comonad and ComonadStore instances easier for Bazaar?
01:26:58 <dminuoso> iqubic: Mmm, ComonadStore?
01:27:11 <iqubic> Also, couldn't you just use the same instance definitions for both Pretext and Bazaar?
01:27:25 <dminuoso> iqubic: Im not sure you can write a ComonadStore instance.
01:27:48 <iqubic> Why not?
01:28:41 <dminuoso> iqubic: Because a Bazaar is nothing like Store.
01:28:52 <iqubic> I see.
01:30:00 <iqubic> That FunList type seems very weird.
01:30:10 <dminuoso> Well it's non regular.
01:30:24 <iqubic> data FunList a t = Done t | More a (FunList a (a -> t))
01:30:39 <iqubic> Non Regular and recursive.
01:32:14 <iqubic> It's interesting that you can get different sorts of functions just by varying the constraint.
01:32:50 <jellostahps> How would u implement this in haskell: https://stackoverflow.com/questions/2652536/reverse-factorial
01:33:39 <jellostahps> Can you do it simply with a function that is f::Int->Int and no more parameters?
01:34:19 <iqubic> Yes. I'm sure you could do it.
01:34:27 <jellostahps> f x = if (product[1..x] <= x) then invFac(x-1) else x
01:34:44 <jellostahps> I tried that, but x will update its value every recursion call so its no good
01:35:09 <jellostahps> ive been at this for several hours now, any tips would be appreciated
01:36:01 <iqubic> That seem correct.
01:36:07 <jellostahps>   f x = if (product[1..x] <= x) then f(x-1) else x
01:36:19 <jellostahps> its not
01:36:35 <iqubic> Why makes you think that's wrong?
01:36:42 <jellostahps> testing it
01:37:05 <jusss> java has type erasure to handle generics, and what haskell use?
01:37:13 <jellostahps> and again, x val updates every recursion call, im relating pointless things
01:37:24 <jusss> type variables
01:38:37 <iqubic> jusss: Haskell uses type variables. But you can't really compare Java's generics with Haskell's polymorphism
01:39:11 <jusss> iqubic: it's very different?
01:39:15 <iqubic> yes.
01:47:37 <Ariakenom> jellostahps: it may help you to build an infinite list of all factorials in f. [0!, 1!, 2!, 3!, ...]
01:47:56 <jellostahps> hmm
01:48:12 <jellostahps> im not quite sure how that helps
01:50:28 <iqubic> :t findIndex
01:50:30 <lambdabot> (a -> Bool) -> [a] -> Maybe Int
01:51:25 <iqubic> f x = findIndex (== x) (map fac [1...])
01:51:35 <iqubic> Where fac is the factorial function.
01:52:50 <iqubic> Actually, that's an infinite loop. Don't use that.
01:55:42 <wstomv> @pl a - (b/2)
01:55:42 <lambdabot> a - b / 2
01:56:09 <wstomv> @pl \a b -> a - (b/2)
01:56:10 <lambdabot> (. (/ 2)) . (-)
01:57:27 <wstomv> @pl \a b -> b - (a/2)
01:57:27 <lambdabot> subtract . (/ 2)
01:57:52 <wstomv> @pl \a b -> b / (a-2)
01:57:52 <lambdabot> flip (/) . subtract 2
02:02:09 <jellostahps> iqubic: ......im new at haskell...throwing out incorrect info is gunna throw me in long research loops. plz dont...
02:09:54 <martijnV2> jellostahps: factorial is a monotonic function and for all x > 2, x! is never <= x and so you only ever go to the false branch. for x = 1, x! = 1 and so there you take the true branch
02:10:30 <jellostahps> thats a single case
02:10:47 <jellostahps> ive handled the cases x=1 and x=2
02:11:13 <martijnV2> ok, so then your f will always be the identity function
02:11:16 <jellostahps> I understand that my code is wrong...I have noooo idea how to fix it
02:13:03 <jellostahps> fix it so that the function returns the largest integer, whose factorial is less than or equal to the value of the input integer
02:13:12 <jellostahps> is what I am trying to do
02:14:18 <jellostahps> so input 5 would return 2 because 3!=6 > input is too large
02:14:24 <merijn> jellostahps: Can you pastebin the code you have so far?
02:14:29 <jellostahps> sure
02:14:49 <martijnV2> if you are given an N that you _know for sure_ is a factorial number, then you could do f x = findIndex (==x) [ product [1..n] | n <- [1..]]
02:16:02 <martijnV2> more or less, you might have to (+1) the result. There is a direct mapping between the index and the factorial of that index anyway
02:16:19 <dminuoso> iqubic: The best thing about this constraint part, is that that composition effectively merges them together.
02:16:33 <dminuoso> % :t each
02:16:33 <yahb> dminuoso: (Each s t a b, Applicative f) => (a -> f b) -> s -> f t
02:16:36 <dminuoso> % :t _1
02:16:36 <yahb> dminuoso: (Field1 s t a b, Functor f) => (a -> f b) -> s -> f t
02:16:40 <dminuoso> % :t _1 . each
02:16:41 <yahb> dminuoso: (Field1 s t a1 b1, Each a1 b1 a2 b2, Applicative f) => (a2 -> f b2) -> s -> f t
02:17:56 <dminuoso> (You could imagine that there was an additional Functor f constraint there, but GHC recognizes that constraint as redundant because its implied by Applicative's superclass)
02:18:25 <dminuoso> Or.. entailed rather? My logic is really poor, I cant tell the difference.
02:18:53 <jellostahps> martijnV2: https://pastebin.com/bwMAec98
02:18:57 <jellostahps> I'm not even close
02:19:39 <jellostahps> As someone earlier said, I have the identity function here. I don't know how to take a single integer argument and get the result I desire
02:21:03 <merijn> jellostahps: Right, so the problem is that you need to compare a factorial against your original number, right?
02:21:29 <Silent_Alex> j
02:22:33 <merijn> jellostahps: The problem here is that your recursive invocation has no way to refer to "the original number", so the obvious solution is to fix that. Consider this: Do you know how to solve this problem if your function had two arguments? (i.e. the target number your factorial should be smaller than and the current factorial you're trying)
02:23:29 <jellostahps> merijn: yes, you stated my problem correcty, with 2 arguments i would...
02:23:58 <merijn> jellostahps: Hint: What if you define said 2 argument version as a helper for your current function?
02:24:53 <jellostahps> sry this is gunna take me a minute to process
02:27:04 <martijnV2> jellostahps: you are thinking too imperative. You must think like you do in mathematical formulas: if you have f(x), you can choose a value for that x, but there is no notion of reassigning x. If you make a recursive call then the x is not rebound, it is a new x, with a new value, completely separate from the original
02:27:12 <jellostahps> fctn a b = if  product[1..b] > a then fctn (a (b-1)) else b
02:28:11 <merijn> jellostahps: Well, the second call is wrong (you're applying 'a' to 'b-1', it should be "fctn a (b-1)"), but other than that it looks right
02:28:11 <dminuoso> merijn: So you inspired me to use prettyprinter, and I must say once I use AvailablePerLine for layouting, I get a big mess out of it.
02:28:13 <jellostahps> martijnV2: yes I know my initial solution was flawaed because there was a new x everytime
02:28:27 <dminuoso> Unbounded works fine.
02:28:34 <merijn> dminuoso: How so?
02:28:59 <merijn> jellostahps: So, the next question is "can you somehome implement invFac using fctn?"
02:29:13 <jellostahps> merijn: so how should i approach this then. I have not the lsightest clue of how to deal with it using just a single argument
02:29:32 <merijn> jellostahps: The answer is: You can't deal with it using a single argument, so don't
02:30:17 <jellostahps> merijn: hmm the instructor expects us to do so and says its possible
02:30:36 <merijn> jellostahps: The problem is you're trying to solve the problem in 1 step
02:30:41 <dminuoso> merijn: Mmm, so when trying to print to stderr with AvailablePerLine, the output is completely misaligned (it starts at the *bottom* of my terminal and the first character of the output is on the last column of the terminal.
02:30:57 <merijn> jellostahps: fctn solves your problem, now you just need to figure out how to implement invFac using fctn
02:30:58 <dminuoso> merijn: So I get visually some "\n\n\n\n\n                  E\nrror while doing thing"
02:31:06 <dminuoso> And it's completely beyond me why.
02:31:13 <dminuoso> It only happens when I feed it to stderr
02:31:21 <dminuoso> And also only when its with AvailablePerLine
02:31:36 <merijn> dminuoso: Let me guess, you're using ansi-terminal to query terminal size?
02:31:40 <jellostahps> merijn: using 1 or 2 arguments?
02:31:43 <dminuoso> merijn: Yes.
02:31:55 <merijn> dminuoso: https://github.com/feuerbach/ansi-terminal/issues/87
02:32:01 <merijn> jellostahps: Using 1
02:32:18 <dminuoso> merijn: Oh. My. Wow.
02:32:24 <dminuoso> merijn: Thanks! You're a saver!
02:33:10 <jellostahps> merijn: idk what u mean by implement invFac using fctn. Do you mean I have two different functions working to solve the single problemm?
02:33:17 <merijn> jellostahps: Yes
02:33:33 <jellostahps> okay thanks ill try that out
02:33:38 <dminuoso> merijn: How did you even find this? Ive been debugging at this for hours.
02:34:04 <merijn> dminuoso: Sheer accident of it sometimes working and never failing in the codepath that didn't have getTerminalSize
02:34:37 <merijn> dminuoso: So I started looking how getTerminalSize is implemented, thought things were suspicious so basically did some guess work based on my knowledge of terminals and guessed right :p
02:35:25 <merijn> dminuoso: So the answer is: The several hours/days I spent on "Advanced Programming in the UNIX Environment" on terminals and stuff was worth it :p
02:37:17 <merijn> dminuoso: All terminal operations (including colours and cursor manipulation) are just special byte/control sequence in the terminal protocol, so if you see ansi-terminal testing the size by going out of bounds and then resetting it's just a matter of thinking "hmmm, what if the terminal reset never reaches the terminal?"
02:37:55 <merijn> Also, I'm the god of triggering obscure edge cases, so I've got years of practice fixing obscure edge cases ;)
02:41:57 <jellostahps> I downloaded Haskell Platform from haskell.org     Now I am trying to set up VS Code Haskelly....The installation instructions from this page say that I need to install Stack. I am wondering if, through haskell.org, I already did install stack? https://marketplace.visualstudio.com/items?itemName=UCL.haskelly
02:42:21 <jusss> [exa]: the code you shared yesterday, https://pastebin.com/pZM1tRt5 , the main2 function don't have a "return", so what  factorial(n, main2(_,k)); will receive?
02:42:22 <merijn> jellostahps: iirc Haskell Platform should install stack, yes
02:43:25 <jellostahps> so no need to redundantly follow that instruction, k thx
02:56:35 <[exa]> jusss: oh I used the _ as for lambda, it's like \x -> main2(x,k)
02:57:17 <[exa]> jusss: you call the factorial, and give it a continuation that shoves its result into main2 (which continues with the original continuation from main, k)
02:57:53 <[exa]> jusss: sorry for confusion though, I should have annotated the _ better
02:58:23 <jusss> [exa]: what it confused me is not that _
02:58:43 <jusss> [exa]: it's that function main2 will not return something, right?
02:59:09 <jusss> [exa]: and in  factorial(n, main2(_,k));  what this main2 return?
02:59:36 <jusss> and function factorial(n,k) { }
02:59:58 <jusss> this main2(_,k) will as k in factorial(n,k) right?
03:01:03 <jusss> or what I'm missing?
03:01:07 <dminuoso> merijn: Mmm, what kind of channel is used to extract the terminal size then?
03:04:11 <dminuoso> merijn: I mean I understand that terminals are controlled via commands (Ive always understood ASCII as a terminal control protocol that way), but that always appears as a unidirectional channel to me.
03:07:32 <dminuoso> (What is even more confusing how hFlush would move the cursor at all)
03:08:07 <[exa]> jusss: you're missing the lambda there
03:08:40 <[exa]> jusss: with _ I meant this: factorial(n, \result -> main2(result,k) )
03:09:28 <[exa]> jusss: you create a tiny function that just takes its argument and puts it to main2, and give it to factorial as a continuation
03:09:59 <[exa]> trick: main2() receives continuation from the original main(), so that they virtually behave as a single function
03:10:05 <jusss> [exa]: oh, it's a lambda
03:10:22 <jusss> [exa]: this lambda will eval to main2(result,k)
03:10:43 <jusss> and main2(result,k) is the k
03:11:27 <jusss> and in the factAcc , main2(result,k)(acc), right?
03:12:18 <[exa]> (\r -> main2(r,k))(acc)  --more precise I believe
03:12:23 <[exa]> which evaluates to main2(acc,k)
03:12:44 <[exa]> so that the factAcc simply jumps to main2
03:16:05 <jusss> [exa]: wow, 
03:17:29 <jusss> [exa]: but  factorial(n, main2(_,k)); is equl to factorial(n, r => main2(r,k)) ?  
03:17:36 <jusss> in javascript, of course
03:18:09 <jusss> I know there's beta conversion, like f x = f x, so we get f = \x -> f x
03:22:56 <[exa]> jusss: yes, basically
03:23:51 <[exa]> jusss: btw the thing you shown is η-conversion
03:23:58 <[exa]> (double)
03:24:18 <jusss> [exa]: is there a k I can use in this code?
03:24:35 <[exa]> how do you mean it
03:24:58 <jusss> [exa]: main(?) to run this up
03:27:16 <jusss> [exa]: we pass what to main()?
03:29:35 <[exa]> jusss: main needs a continuation. It can't return, what would it do with the result?
03:29:55 <[exa]> in case of main, the continuation may be something like system.exit(0)
03:32:49 <jusss> [exa]:  k() in main2, and   else k(acc) in factAcc, this k's parameter is not ...
04:44:34 <merijn> Does anyone know how good GHC is at inlining functions that come from datatypes? So, say I have "data Foo = Foo { bar :: Int -> Char -> Bool; baz :: Text -> IO () }" and a function "doStuff :: Foo -> IO ()" that uses those functions internally. If I apply doStuff to some (known at compile time) record, is there any chance GHC will inline away the entire data structure?
04:46:36 <martijnV2> merijn: i know that ghc /can/ do it, no idea if it always does it or how to make it
04:47:10 <martijnV2> merijn: perhaps {-# INLINE bar #-} will do it
04:47:31 <merijn> Maybe more of a #ghc question
04:51:56 <martijnV2> in the end everything is untyped right, all these type conversions or constructors don't make your program inefficient because that is discarded after compilation
04:54:38 <merijn> martijnV2: Constructors exist at runtime
04:54:51 <merijn> martijnV2: Newtypes are completely non-existent at runtime, though
04:55:15 <[exa]> merijn: the most common obstacle to inlining is (non-)totality of the functions; you can help it a lot with strictness annotations
04:55:36 <merijn> martijnV2: For example, if we have "data Maybe a = Nothing | Just a" there needs to be *something* at runtime that lets us know whether we have a Nothing or a Just to decide what to do, so you can't blindly throw away constructors
04:55:57 <merijn> [exa]: Why would totality impact inlining?
04:57:15 <[exa]> merijn: exactly for this kind of inlining (dropping a parameter) it needs to know whether you'll be forcing the Foo in doStuff
04:58:26 <[exa]> btw the thing you asked for is probably more like value propagation and function specialization (for data), right?
04:59:13 <[exa]> oh it's compile time, even constant propagation, great
05:00:04 <merijn> [exa]: Basically, I have a function that needs to work for a handful of different inner loop implementations, so I (obviously) want those applications to be inlined, but it's nicer to operate on a record of functions than having multiple function arguments
05:01:07 <[exa]> oh so. If the record is an obvious constant it's almost surely gonna get propagated (and optimized out)
05:02:29 <[exa]> there are some non-obvious things that can prevent that (mostly work duplication) described in a paper ("architecture of glasgow haskell inliner" iirc?)
05:03:23 <[exa]> but you shouldn't hit these here at all
05:03:24 <merijn> [exa]: Yeah, I will basically have a handful of top-level values of that record with different sets of functions inside
05:06:09 <[exa]> I'd mark them as INLINE to make double sure the compiler chooses to put the definitions near to where you pick the functions, and that should work
05:08:23 <merijn> Relatedly, is there a foldMap that does strict accumulation?
05:13:05 <[exa]> merijn: can you give it a stricter semigroup?
05:13:48 <merijn> [exa]: hmm?
05:19:22 <[exa]> merijn: I hoped there'd be some semigroup wrapper for making <> force the result, (similar to eg. Backwards for applicatives) but there seems to be none
05:21:39 <AWizzArd> What package do I want to use if I want pub/sub behaviour? One publisher, possibly many subscribers.
05:22:46 <merijn> AWizzArd: Across processes? Within the same process?
05:22:54 <merijn> What should happen if there's 0 subscribers?
05:23:01 * hackage urbit-hob 0.3.0 - Hoon-style atom manipulation and printing functions  https://hackage.haskell.org/package/urbit-hob-0.3.0 (JaredTobin)
05:23:33 <merijn> How performance sensitive are you?
05:24:16 <[exa]> AWizzArd: Control.Concurrent.Chan might be a nice first choice if that's just in one application
05:25:08 <merijn> Depending what he wants in case of 0 subscribers Chan might be bad
05:26:03 <AWizzArd> Inside the same process.
05:26:28 <AWizzArd> 0 subs could discard the msg
05:26:43 <merijn> @hackage broadcast-chan
05:26:43 <lambdabot> http://hackage.haskell.org/package/broadcast-chan
05:27:21 <merijn> AWizzArd: I wrote that to fix the 0 subscriber leak you get with Chan and then build a bunch of utils on top that I kept reinventing
05:27:52 <AWizzArd> thx
05:28:34 <Ariakenom> merijn: oh utils? sounds interesting
05:28:52 <merijn> Ariakenom: Basically parallel processing with back pressure
05:29:56 <Ariakenom> give links
05:29:59 <merijn> Ariakenom: See broadcast-chan-conduit, I have been using it for a while in my own stuff and it's been months or more since the last time I ran into a bug, so it should be fairly robust now
05:30:35 <merijn> Ariakenom: BroadcastChan itself has Foldable/Traversable based stuff that's similar
05:30:56 <merijn> The Prelude module is still a bit of a work in progress
05:31:32 <merijn> I think a bracket-style channel allocator that guarantees closing the channel in the presence of async exception is useful too, but I haven't had much time to tinker more
05:32:06 <merijn> Ariakenom: But parMapM alone is <3 https://hackage.haskell.org/package/broadcast-chan-conduit-0.2.0.2/docs/BroadcastChan-Conduit.html#v:parMapM
05:33:38 <Ariakenom> need to afk a bit
06:05:48 <jumper149> Hi, I was just looking through the source of Data.Complex and was wondering why `(0 :+ 0) ** (0 :+ 0) == 1 :+ 0`?
06:06:06 <jumper149> You can have a look for yourselves: http://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.Complex.html#line-157
06:07:20 <merijn> jumper149: because x to the 0th power is defined as 1?
06:07:55 <pikajude> that should be defined for any Complex shouldn't it?
06:08:00 <pikajude> not just 0 :+ 0
06:08:22 <pikajude> i mean to say, _ ** (0 :+ 0) = 1 :+ 0
06:08:36 <jumper149> Yes but 0 to any power is 0 ? Is there any better argument than 1 is cooler than 0
06:08:45 <merijn> jumper149: No it's not
06:08:53 <jumper149> pikajude: It's defined exaclty that way
06:09:04 <pikajude> oh yeah, it is
06:09:08 <pikajude> i didn't read the source :D
06:09:25 <merijn> jumper149: x^0 = 1, because then you can define x^n = x * (x^(n-1))
06:10:14 <merijn> x^1 = x, which follows from the above definition via: "x^1 = x * x^(1-1)" -> "x * x^0" -> "x * 1" -> "x"
06:10:21 <__monty__> merijn: Ah, thanks. That's even better than my intuition of "The one's the only factor left over if you multiply something by itself 0 times."
06:11:12 <pikajude> does hindent format data decls? brittany doesn't but it's my favorite formatter
06:11:25 <rsoeldner> Hi, I need to create a proto file from an existing xml file using hxt, is there some package for protoc to write something like `toProto :: XmlTree -> Proto` ?
06:11:52 <pikajude> ah yeah it does
06:19:40 <merijn> cocreature: ping?
06:24:32 <cocreature> merijn: pong?
06:25:47 <merijn> cocreature: You were on the ghcide team, right? From what I can gather from the repo there's been a switch to a new hie-bios which didn't get a corresponding ghcide release?
06:26:28 <merijn> cocreature: I think, at the very least, ghcide should get a hackage revision setting an upperbound on hie-bios, since as it is now the package is unbuildable
06:26:50 <cocreature> merijn: I’ll make a new release next week, haven’t had much time this week
06:27:37 <merijn> cocreature: Yeah, I saw that, I realise releases take time, but I figured just revisioning the upperbound might be small enough for someone on the team to do before then :)
06:28:20 <merijn> Actually, maybe that's an optimistic assumption if hie-bios also doesn't bound it's dependencies...
06:29:06 <mpickering> hie-bios does bound it's dependencies 
06:30:24 <merijn> Oh goodie...good to see I haven't lost my touch for breaking things >.>
06:32:34 <hyperisco> Goood morning
06:35:43 <merijn> mpickering: ah...hie-bios needs explicit configuration for which component to use in v2-build projects?
06:36:19 <mpickering> yes, because cabal doesn't support querying to find out which component a file belongs to
06:36:25 <mpickering> when cabal supports it, it won't require it
06:36:56 <merijn> mpickering: Right, so if you're mixing which components you work on it can't work?
06:37:01 <merijn> Rats :(
06:37:04 <mpickering> Not currently
06:37:27 <mpickering> If someone implemented better support in cabal then it could
06:37:38 <mpickering> or you can try creating a direct cradle
06:37:47 <mpickering> which passes `-i` and `-package` manually
06:37:50 <merijn> My own shitty tool has a hacky way to do this, but that might be to hacky to consider for hie-bios >.>
06:37:51 <mpickering> to create one "super component"
06:38:11 <mpickering> well the current way is hacky
06:38:28 <mpickering> With the hope that one day, all the build tool maintainers will catch up and make it not hacky
06:39:10 <merijn> mpickering: i.e. I track files in a component when the component is loaded and cache that info, if there's no known mapping (or the known one is broken) then it tries all components in sequence >.>
06:39:48 <mpickering> You can specify your own program to provide the options
06:39:52 <mpickering> If you want to try that
06:40:06 <mpickering> That's what I use to support hadrian
06:40:44 <merijn> mpickering: Got a pointer on how that works?
06:41:36 <mpickering> Hopefully I documented it?
06:41:54 <mpickering> Basically you write a program which takes a file path as a arg
06:42:05 <mpickering> And gives back some ghc options
06:43:07 <merijn> hmm
06:44:56 <merijn> mpickering: That seems tricky to do, there's no way to, e.g. specify component per path?
06:45:22 <merijn> That seems much easier to do
06:46:12 <mpickering> yeah you could do that
06:46:20 <mpickering> but then you have to invoke cabal to get the options still
06:46:53 <mpickering> basically, if you want a different interface and implement it then I will merge it into hie-bios
06:47:13 <merijn> mpickering: I mean, like extend hie-bios mapping so that it stores a component per path (prefix), rather than a single component for cabal
06:47:55 <mpickering> yes, sounds ok
06:48:03 <mpickering> I'm not sure how well ghcide supports multiple components yet
06:48:08 <mpickering> that would work for h-i-e
06:49:10 <merijn> mpickering: No clue, I just want *something* that gets me back error highlighting/type querying with v2-build :)
06:49:20 <merijn> I'll see how hard it looks to add this to hie-bios
06:50:02 <mpickering> it will be easy, it's a very simple program, the hard but has been keeping it as simple as possible
06:50:21 <mpickering> It sounds like you want to implement a cradle which can specify a different cradle for each prefix
06:50:32 <mpickering> "multi" perhaps
06:51:51 <mpickering> In nix syntax, `{ multi = [ { path = "/prefix1"; cradle = cabal { component = "lib:lib1"; }; } ]; }`
06:53:04 <merijn> hmm, perhaps, I'd have to see how it actually creates the session
06:57:25 <merijn> mpickering: Actually doesn't seem like it'd be so hard. I'll see what I can make of it
07:06:49 <jboy> I'm on NixOS and I'm trying to `stack build` something that requires GHC 7.10.3 (lts-4.2). How do I best go about getting an old version?
07:11:58 <boxscape> Just found out that signature files exist. Is this conceptually sort of like a big typeclass, where you define operations that implementations must support and then multiple implementations can exist?
07:12:29 <merijn> boxscape: They're basically "trying to steal ML's module system"
07:12:49 <boxscape> I'm not really familiar with ML's module system
07:13:02 <merijn> boxscape: I mean, sorta like what you said, but...also not?
07:13:47 <merijn> boxscape: The limitation of typeclasses is that all instances must be similar in terms of type (so, all instance must be *, or they must all be * -> *, or...)
07:13:52 <boxscape> wikipedia compares them with both C headers and Java Interfaces
07:14:07 <boxscape> ah, ok
07:14:39 <merijn> boxscape: This is problematic when you want to write things like Foldable (which requires * -> *), since, for example Text or ByteString are (conceptually) foldable, but not quite, since they've got the wrong kind
07:15:04 <merijn> boxscape: You might wanna browse http://blog.ezyang.com/category/haskell/backpack/ for the "why and how"
07:15:10 <boxscape> okay, thanks
07:17:33 <boxscape> jboy: if you don't get an answer maybe try #nixos
07:17:52 <jboy> thanks boxscape, will do
07:34:52 <boxscape> Why does ($) have levity polymorphism, but other common functions like (.) dont?
07:35:08 <merijn> boxscape: You can only be levity polymorphic in return value
07:35:22 <merijn> boxscape: So which part of (.) would be levity polymorphic?
07:35:27 <boxscape> the return value?
07:35:45 <boxscape> %  (...) :: forall r a b (c :: TYPE r) . (b -> c) -> (a -> b) -> a -> c; f ... g = \x -> f (g x)
07:35:45 <yahb> boxscape: 
07:36:03 <boxscape> % f x = 4#
07:36:03 <yahb> boxscape: 
07:36:15 <boxscape> % :t f ... (+1)
07:36:15 <yahb> boxscape: Num p => p -> Int#
07:36:19 <dminuoso> % :i ($)
07:36:20 <yahb> dminuoso: ($) :: (a -> b) -> a -> b -- Defined in `GHC.Base'; infixr 0 $
07:36:34 <boxscape> % :t f . (+1) -- compare with
07:36:34 <yahb> boxscape: ; <interactive>:1:1: error:; * Couldn't match a lifted type with an unlifted type; When matching types; c :: *; Int# :: TYPE 'GHC.Exts.IntRep; Expected type: p -> c; Actual type: p -> Int#; * In the first argument of `(.)', namely `f'; In the expression: f . (+ 1)
07:37:06 <boxscape> % :i (...)
07:37:06 <yahb> boxscape: (...) :: (b -> c) -> (a -> b) -> a -> c -- Defined at <interactive>:199:73
07:38:02 <boxscape> does seem a bit strange that those get removes by from what it looks like all ghci actions that show a type
07:38:09 <boxscape> s/removes/removed
07:38:20 <merijn> boxscape: Because else ($) would be terrifying to beginners
07:38:32 <merijn> You can make it very verbose via an option, iirc
07:38:41 <boxscape> that's fair but it seems like a good idea to have *some* way to show it
07:38:49 <merijn> boxscape: There is
07:38:52 <dminuoso> boxscape: My best guess is, either not important enough or an oversight.
07:38:53 <boxscape> what it is?
07:38:54 <merijn> I just don't remember what it was
07:38:59 <boxscape> ah 
07:39:13 <dminuoso> boxscape: Levity Polymorphism (extended version) by Eisenberg and Jones suggests that its perfectly fine and safe.
07:39:16 <merijn> @where user-guide
07:39:16 <lambdabot> I know nothing about user-guide.
07:39:22 <denbrahe[m]> Is there an explanation to Scotty's name?
07:39:22 <denbrahe[m]> On the hackage page it says "As for the name: Sinatra + Warp = Scotty."
07:39:23 <merijn> @where userguide
07:39:23 <lambdabot> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/
07:39:28 <denbrahe[m]> But I don't seem to get it
07:39:32 <boxscape> dminuoso perfectly fine and save to leave it out?
07:39:42 <dminuoso> boxscape: No it'd be a safe to levity generalize (.)
07:39:45 <boxscape> ah
07:40:09 <merijn> denbrahe[m]: Star Trek, probably? (warp + scotty) No clue how Sinatra fits in, though :p
07:40:23 <boxscape> % :set -fprint-explicit-runtime-reps
07:40:23 <yahb> boxscape: 
07:40:26 <dminuoso> boxscape: https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/levity-pldi17.pdf
07:40:31 <boxscape> % :t ($)
07:40:31 <yahb> boxscape: (a -> b) -> a -> b
07:40:40 <denbrahe[m]> It's got the "Scotty, beam me up" reference indee
07:40:42 <denbrahe[m]> indeed
07:40:49 <boxscape> % :t +v ($)
07:40:49 <yahb> boxscape: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
07:40:54 <boxscape> okay there we are
07:40:58 <boxscape> thanks dminuoso
07:41:01 <boxscape> and merijn
07:41:06 <dminuoso> denbrahe[m]: sinatra fits in because its inspired by a framework called sinatra from Ruby
07:42:27 <Taneb> dminuoso: that explains why it mentions sinatra but not how sinatra influenced the name "Scotty"
07:59:00 * hackage language-c 0.8.3 - Analysis and generation of C code  https://hackage.haskell.org/package/language-c-0.8.3 (BenediktHuber)
08:16:52 <uberj> pprint is to python as ? is to haskell
08:18:35 <merijn> uberj: It would probably help to specify what pprint does, exactly?
08:18:54 <uberj> oh, sure! one sec
08:19:49 <novum> pretty print
08:20:26 <novum> https://duckduckgo.com/?q=!py+pprint
08:20:57 <uberj> novum: this page has good examples https://docs.python.org/3/library/pprint.html
08:21:19 <merijn> @hackage prettyprinter
08:21:19 <lambdabot> http://hackage.haskell.org/package/prettyprinter
08:21:33 <novum> there is also skylight for pdf, uberj
08:22:00 <novum> @hackage skylighting
08:22:00 <lambdabot> http://hackage.haskell.org/package/skylighting
08:22:00 <merijn> novum: prettyprinter is probably the most modern/flexible one
08:22:13 <uberj> I'm just looking for one used for debugging in  ghci (thats mostly what pprint is for)
08:22:46 <merijn> Oh, then you probably want
08:22:52 <merijn> @hackage pretty-show
08:22:52 <lambdabot> http://hackage.haskell.org/package/pretty-show
08:23:00 <merijn> uberj: And you might *also* want
08:23:04 <merijn> @hackage tree-diff
08:23:04 <lambdabot> http://hackage.haskell.org/package/tree-diff
08:23:19 <merijn> Which lets you diff (and pretty print those diffs) for complex nested datatypes
08:23:40 <zacts> do ghc binaries rely on ghc to run?
08:23:47 <zacts> do they rely on ghc being installed to run
08:23:50 <merijn> zacts: No
08:23:54 <zacts> ok, cool
08:24:09 <novum> very nice. good morning, merijn et al. How fare thee? I have begun the exercism.io/tracks/haskell/exercises just now.
08:24:19 <merijn> zacts: By default GHC also links all Haskell libraries statically, so you don't even rely on the haskell libs being installed
08:24:40 <zacts> oh neat
08:24:55 <novum> that is really nice that ghc links the libs statically. they are not dynamic?
08:24:59 <merijn> zacts: So if you don't have any FFI dependencies you usually only link against (g)libc
08:25:06 <zacts> ok
08:25:51 <merijn> novum: You can build dynamic libraries, but it's not the default behaviour and generally not really recommended unless you have Good Reasons (TM)
08:29:05 <Shoubit> Is there an existing combinator for the pattern `f >=> g >>> pure`, i.e. a way to get rid of the `pure` at the end?
08:30:57 <merijn> Shoubit: "fmap g . f"?
08:31:47 <novum> merijn, awesome. thanks for the response and brief, useful explanation. :)
08:32:25 <dmj`> void (f >=> g)
08:32:29 <merijn> You could even build completely static executables that don't even depend on C libs (by using a statically linked libc like musl), but that can be a bit of a hassle to set up the first time
08:32:39 <maralorn> Didn‘t Arch Linux switch to linking all of hackage dynamically some years ago?
08:32:42 <merijn> dmj`: That doesn't typecheck, probably
08:32:54 <dmj`> merijn: yea, but something with void
08:32:57 <merijn> maralorn: Yes, and since then their Haskell environment has been basically unusable
08:33:18 <maralorn> The result was people I know stopping to use Haskell software because it were to many dependencies for them.
08:33:24 <dmj`> :t void $ \f g x -> f >=> g $ x
08:33:25 <lambdabot> Monad m => (a -> m b) -> ()
08:33:39 <maralorn> So on nixos we also always build statically?
08:33:41 <merijn> dmj`: Then his use of pure doesn't really make sense
08:33:52 <zacts> I'm on NixOS
08:34:27 <dmj`> maralorn: NixOS tries to maximize dynamic linking afaik, to reuse stuff in the store.
08:34:27 <merijn> maralorn: There's also no point, since you can independently update Haskell dynamic libraries like you can with C, so if one updates you have to update everything *anyway*, so why bother with dynamic
08:34:52 <glguy> can't* ?
08:35:05 <dmj`> the granularity of a derivation from a haskell perspective in nix is an entire package, so you'd have to rebuild from scratch anyways
08:35:17 <merijn> glguy: eh, yeah >.>
08:35:21 <uberj> merijn: where in the docs for pprinter (https://hackage.haskell.org/package/prettyprinter) does it define what its API is?
08:35:48 <merijn> uberj: Data.Text.Prettyprint.Doc has an overview
08:45:22 <monochrom> I request dynamic linking to save space. I have 200 students submitting Haskell programs, and I'm compiling them all to exes to save time.
08:46:54 <zacts> NixOS does eat up space pretty quickly. I recently did a garbage collect and it saved over 10GB
08:47:51 <jgt> zacts: I did a GC today and it freed up 34GB
08:47:53 <monochrom> For production exes I stick to the default which is exactly right: dynamic linking for C libs and static linking for Haskell libs so the exe is usable standalone on almost any x86-64 linux platform. What docker? I have just one exe that's ready to go!
08:49:43 <monochrom> archlinux has a bug in their dynamic linking religion.
08:50:13 <monochrom> There are correct ways to implement the dynamic linking ideology but archlinux is not one of them.
08:51:42 <zacts> I can see why NixOS might want to save space
08:51:58 <zacts> so it's probably justified to dynamically link for that distro, if that's the justification for it
08:52:10 <zacts> but I'm not an expert.
08:52:37 <zacts> I'm just a newbie to Haskell, and I've been on NixOS for a couple of months.
08:52:58 <epta> what happend to the binary-orphans package? all the instances are gone with the version 1
08:53:25 <jumper149> Setting up static linking on ArchLinux was necessary for a working cabal setup for me.
08:53:31 <glguy> monochrom: Does having students submit dynamically linked executables require you to specify a particular GHC version and no external package dependencies?
08:53:44 <merijn> epta: Consut the changelog?
08:54:31 <monochrom> No, they submit source code, I compile.
08:55:06 <glguy> Oh, I interpreted "I request" to mean you requested that from the students
08:55:06 <monochrom> Ah but no external package dependencies. Sometimes I don't even allow unordered-containers.
08:55:19 <monochrom> Heh I request GHC to do it!
09:00:22 <topos> what's the deal with lpaste/hpaste these days.
09:00:39 <topos> It seems to be locked down
09:00:53 <monochrom> Gone.
09:01:21 <topos> apparently not. Apparently i'm supposed to contact a Daniel Pršala on slack :P
09:01:30 <topos> (whoever that is)
09:01:57 <monochrom> And you know that Daniel Pršala has anything at all to do with the Haskell community?
09:03:09 <monochrom> As opposed to a random someone else completely unrelated but acquired the domain name and does whatever they feel like?
09:08:30 <monochrom> If "Daniel Pršala" means https://github.com/droow do you still have faith?
09:11:31 <monochrom> or this: https://www.linkedin.com/in/droow/
09:12:32 <acowley> Anyone try ghcide with nix? I have hie available as a fallback, but wanted to give ghcide a try, but it's not finding things known to ghc-pkg.
09:13:18 <maralorn> acowley: I use it. I love it.
09:13:35 <acowley> maralorn: Any suggestions on helping it find dependencies?
09:14:09 <maralorn> acowley: Have you had a look at hie-bios and the hie.yaml file?
09:14:09 <nshepperd> dynamically linking a program into a set of 100 library files, then statically 'linking' those files into one docker file so you can actually run it...
09:15:04 <maralorn> acowley: They have a long list of ways how to discover the correct dependencies but it does not always work whithout configuration.
09:15:07 <acowley> maralorn: Yes, but I can't find docs on the hie.yaml
09:15:18 <jumper149> What are the best advantages of hie or ghcide compared to just a texteditor and ghcid?
09:18:00 <maralorn> acowley: I think the docs don‘t look like docs because there are very few options. There is a point in the README where it says "The complete configuration is a subset of …" 
09:18:41 <maralorn> jumper149: The Feedback is faster and more easily connected to positions in Code.
09:19:33 <maralorn> jumper149: Especially when you still have a lot of errors floating around you can just focus on the one your interested in and don‘t have to finde it between the other ones.
09:20:10 <maralorn> jumper149: Showing types of values quickly is also nice.
09:22:52 <maralorn> Fascinatingly for me ghcide works even more reliable then ghcid. (But I did invest more time in trying to get it to run.)
09:23:49 <maralorn> And code actions for inserting signatures and imports are usefull, too.
09:23:52 <acowley> I used my old hie environment variables so ghcide no longer has any errors
09:24:00 <acowley> But it's not offering to complete qualified names
09:24:15 <shapr> whoa, acowley is present on IRC!
09:24:17 <maralorn> acowley: It doesn‘t have completion yet.
09:24:18 * shapr hops cheerfully
09:24:41 <acowley> shapr: I know, right?! It's been too long. I was on a tough project.
09:24:56 <acowley> maralorn: Aha, thank you
09:24:56 <shapr> acowley: welcome back? congrats on ending a tough project?
09:25:04 <shapr> I figured you were doing something awesome
09:25:17 <topos> monochrom no, i don't, that's why I'm asking. It doesn't seem dead, it seems locked down by someone
09:25:29 <acowley> shapr: https://youtu.be/5iQX0NGVsO4
09:25:38 <topos> and also how did this happen
09:25:45 <acowley> shapr: I only used Haskell in prototyping a few pieces of that stuff, though :/
09:25:47 <topos> I'm asking because i'd be happy to take it over
09:25:57 <shapr> acowley: wow! cool!
09:26:51 <maralorn> There is feature list in the README on https://github.com/digital-asset/ghcide. It can already do nearly everything ghcid could and a bit more. I am really looking forward to more features being implemented.
09:27:17 <monochrom> Well now you have to wrangle it out of Daniel Pršala's hands
09:27:48 <monochrom> I actually suspect that he positively hates Haskell because why else would he acquire both hpaste.org and lpaste.net
09:28:50 <monochrom> (given that his github and linkedin show javascript and wordpress and no haskell)
09:29:44 <monochrom> As for how it happened, that's only good to know for "future reference". Someone lost interest and let the domain name expire.
09:30:02 <acowley> Alright, I'll stick to HIE for the time being. It has its own pretty significant drawbacks, but at least I know them. Completion is also a handy feature.
09:33:00 * hackage jvm-binary 0.7.0 - A library for reading Java class-files  https://hackage.haskell.org/package/jvm-binary-0.7.0 (kalhauge)
09:33:19 <maralorn> acowley: It sure is.
09:35:04 <maralorn> jumper149: But the correct answer to your question is: The biggest advantage is, that the typechecking is incremental and really fast. A fraction of a second.
09:39:39 <heatsink> For a personal project, I'm thinking of writing a code generator for algebraic data type definitions in C++.  So you don't have to define boilerplate constructor functions, visitors, etc.  Or has someone done that already?
09:40:19 <hyperisco> monochrom, "You are a sad, strange little man and you have my pity." — Buzz Lightyear
09:40:27 <jumper149> maralorn: ty, for your thorough explanation! I might change up my workflow if I find time to do so in the future :p
10:31:56 <glguy> shapr: Still around?
10:32:03 <shapr> maybe?
10:32:20 <glguy> The other day you said config-value looked complicated. I wondered if you could elaborate so I could fix that
10:32:21 <shapr> glguy: what's up? Should I put up the PRs I'm considering for config-* ?
10:32:53 <shapr> glguy: turns out it's not complicated at all, if you pick up from config-schema and .. config-load ?
10:33:11 <shapr> my problem was that I was in a hurry, and thought that I had to build all that machinery myself
10:33:39 <shapr> in fact, the PR I was considering putting up was nothing more than a line at the top of config-value README that said "You probably want to start reading in config-schema and .."
10:34:02 <shapr> glguy: part of my confusion is that the various libs are in different github accounts/organizations
10:34:20 <glguy> config-value and config-schema should both be just on my normal github
10:34:29 * shapr looks
10:34:45 <glguy> But it's true that config-value doesn't mention config-schema
10:35:02 <shapr> and config-schema eases all the picky details of config-value
10:35:09 <shapr> makes it a joy to use even
10:35:30 <shapr> if I'd paid attention and tried the live online demo I would have known that
10:35:45 <shapr> glguy: ok, you've convinced me to put up that one line PR with included link to config-schema and friends
10:36:39 <glguy> shapr: I did a release this week updating how config-value does numbers that makes things simpler
10:36:55 <shapr> ooh, is there a changelog?
10:36:59 * shapr looks for docs
10:37:00 <glguy> If you were just using it via config-schema then you won't notice the difference too much
10:37:13 <glguy> as I updated config-schema to know how to use the new stuff just the same
10:37:32 <shapr> well, *now* I'm using via config-schema. I was previously frustrated and confused when I didn't realize the easy way is to start with config-schema instead of using config-value directly
10:38:49 <glguy> It's in the changelog, but the short version is there aren't separate constructors anymore for integer and floatingpoint numbers
10:38:55 <shapr> oh nice
10:39:17 <glguy> It's just all hidden away in a new Number type that knows how to do represent any of the numbers and in any of the radixes
10:39:30 <glguy> and then there are some conversion functions provided when you want to forget those details
10:40:09 <glguy> http://hackage.haskell.org/package/config-value-0.7.0.1/docs/Config.html#t:Value
10:42:25 <glguy> I need to poke dmj` at some point to help me rebuild the live demo website
10:42:57 <shapr> glguy: I had a bunch of frustration trying to unwrap Value by hand in various ways. I finally started searching for examples and THEN realized I should have been using config-schema and ValueSpec 
10:43:43 <shapr> now my config reading code is four lines (eight lines if you include the config definition)
10:43:56 <glguy> can I see??
10:44:29 <shapr> https://gist.github.com/shapr/adacaf9445c3bff4a3eb276e48f9c6e1
10:44:40 <shapr> right now my config is just a github username and an oauth token
10:45:49 <shapr> glguy: I was a bit confused because I incorrectly expected that to require a top header "github:" and then indented "username:" and "oauth:"
10:47:20 * dmj` peeks in
10:47:30 <dmj`> glguy: I’ll make a PR :)
10:47:41 <glguy> dmj`: I might need you to *build* it
10:47:50 <glguy> I don't remember how we did that last time
10:48:04 <shapr> glguy: are there lots of users for config-value?
10:48:09 <shapr> it's really cool
10:48:21 <glguy> shapr: I don't know. We use it at work and I use it in my IRC client.
10:48:30 <shapr> oh, fair enough
10:51:09 <shapr> glguy: but afaiu, sectionSpec takes a name for a chunk of config, not a header, right? Is that for later composition of named config chunks?
10:51:32 <glguy> Yeah, it's for generating documentation and errors http://hackage.haskell.org/package/config-schema-1.2.0.0/docs/Config-Schema-Spec.html#v:sectionsSpec
10:51:42 <shapr> oh that makes sense
10:52:26 <glguy> The error handling is kind of fun, you get a value that describes all the way things failed when matching fails: http://hackage.haskell.org/package/config-schema-1.2.0.0/docs/Config-Schema-Load-Error.html
10:52:48 <glguy> and then I have some logic for pruning that down to give you a shorter explanation for why the schema didn't fit and which lines the problems were on
10:53:13 <shapr> huh, does the live demo include that?
10:53:18 <glguy> no
10:53:23 <shapr> cause I don't get it immediately
10:53:23 <glguy> it has an old version of it
10:53:36 <glguy> part of why I need to update the website
10:53:57 <glguy> The old version errors were harder to understand for sure
10:57:26 <glguy> The error messages still aren't English language sentences, though
10:57:39 <shapr> glguy: How would I create a github: top level that had "username:" and "oauth:" ? Is there a demo for nested sections?
10:57:59 <glguy> Make another top-level sectionsSpec for your config
10:58:15 <shapr> oh that makes sense
10:58:20 <glguy> and have a reqSection' "github" for it
10:58:24 <dmj`> @glguy: I’ll build it for sure, can make deployment scripts too if need be (thought we used GitHub pages). It should build super fast since we can use @domenkozar’s cachix project
10:58:24 <lambdabot> Unknown command, try @list
10:58:42 <glguy> dmj`: I'm getting it to build on my mac right now
10:58:48 <glguy> for the webkit version of the demo
10:59:45 <dmj`> glguy: oh boy, not sure if nixpkgs caches Darwin ghcjs, could be a while, but it will build .. eventually
11:00:46 <dmj`> I have a cached ghcjs 8.6
11:00:55 <shapr> glguy: thanks for writing config-value and config-schema, they're great!
11:01:08 * dmj` slowly opens up dark trench coat side pocket
11:03:44 * lavalike peeks
11:03:50 <ANJ> hi
11:03:51 <dmj`> Yea config value has some fantastic Alex and happy code
11:03:58 <ANJ> i want to learn haskell
11:04:03 <dmj`> It’s good to read *and* use
11:04:20 <dmj`> ANJ: look no further, you’ve come to the right place
11:04:24 <ANJ> is this a good place to ask doubts regarding haskell?
11:04:33 <ANJ> yesssssssssss
11:04:38 <dmj`> ANJ: yes
11:04:56 * dmj` bestoweths monads upon ANJ
11:05:28 <shapr> ANJ: I want to hear your doubts!
11:05:39 <shapr> sometimes I have doubts about Haskell also
11:05:58 <shapr> though it's more  that I doubt I'll get another Haskell job at any point :-/
11:05:59 <dmj`> May your binds be pure my child, and all your bools become True
11:06:21 <EvanR> when you doubt haskell, you haskell your doubts
11:06:35 <shapr> sequence $ doubts haskell
11:06:46 <dmj`> ANJ: Haskell is an anvil that has worn out many hammers
11:06:59 <MarcelineVQ> You boys are full of beans today.
11:07:03 <EvanR> really, you are doubting your haskell job?
11:07:33 <dmj`> shapr: just make your own Haskell job. Simply declare yourself employed
11:08:28 <dmj`> ANJ: what don’t you think it is capable of
11:08:30 <shapr> dmj`: that's good idea
11:09:12 <duncan> ANJ, you might find #haskell-beginners useful for beginner questions (they sometimes get lost here)
11:09:51 <duncan> you'll probably find a book or tutorial helpful, the haskellbook is pretty good I think as far as books go though (warn: paid)
11:10:01 <duncan> it is a good book
11:11:00 <shapr> @where cis194
11:11:01 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
11:11:05 <shapr> I'm a fan of cis194 as well
11:11:17 <shapr> or if you're in Brooklyn, come to my Haskell intro!
11:11:23 <argent0> but what's the best free (as in freedom) way to learn haskell? And What's the easiest way to start? (installl a compiler, and packages)
11:11:39 * argent0 2- stack?
11:12:23 <lavalike> I suggest doing advent of code with it, for some fun (:
11:12:34 <shapr> argent0: I like ghcup : https://github.com/haskell/ghcup
11:12:46 <shapr> that's my favorite way to install a compiler
11:12:57 <yushyin> AoC is nice!
11:12:57 <lavalike> seconded
11:13:07 <jellostahps> Does this 7-line program work? And if it does, then how is line 4 acting on a recursive call: https://pastebin.com/wg7tHCsD
11:13:38 <glguy> dmj`: I just pushed a fix to config-app to build against the current stuff
11:13:49 <jellostahps> For line 4, x is a input list parameter, so why isn't it returning True for any entered list
11:13:54 <shapr> argent0: once you've installed ghcup and added it to your $PATH, then "ghcup install 8.6" and "cabal update"
11:13:56 <shapr> and you're good
11:14:05 --- mode: glguy set -o glguy
11:14:15 <lavalike> jellostahps: because [x] matches *only* one-element lists, not all lists, and binds that one element to the name 'x'
11:14:41 <lavalike> jellostahps: to match any list it'd have to be just a name, no square brackets
11:15:28 <dmj`> glguy: ok great
11:15:31 * dmj` clones config-app
11:15:44 <jellostahps> oooh, so it would have to be x
11:15:52 <jellostahps> to be any list, thx
11:16:04 <lavalike> jellostahps: yeah, usually one writes 'xs' in haskell, to indicate it's a "plural x"
11:17:02 <argent0> shapr: looks cool, and what about windows?
11:17:26 <jellostahps> lavalike: for line 5 onward, what I attempted to say is x=fst, y=scnd and ys= the rest of the list. If fst >scnd then return False, otherwise return the list [scnd,ys...]
11:17:53 <jellostahps> did I do that correctly, is there more precise, or accurate syntax for it?
11:18:24 <lavalike> the example's syntax is pretty good in my opinion
11:19:09 <jellostahps> woah, that was a a shot in the dark for me and I didn't get any compile error on the first go. awesome
11:50:13 <WilliamHamilton> question about the beam library: could someone explain how to deal with an error like `couldn't match QueryInaccessible with  QNested (QNested QueryInaccessible))` where the nested layers are introduced by limit_ and offset_?
11:51:07 <WilliamHamilton> I'm interested in your thought process when you encounter such an error, since the types in beam 7.2.2 don't help me that much
11:54:58 <lyxia> I would look at operations involving QNested, looking for one that lets me access the "wrapped" type
11:59:03 <WilliamHamilton> lyxia thanks! I'll look into that, although I don't think there's a way for me to unwrap that, I think that is supposed to be controlled by beam's type-level machinery
12:03:17 <jellostahps> cheapItems :: [(String,Int)] -> Int -> [String]
12:03:20 <jellostahps> cheapItems x z
12:03:41 <jellostahps> If I have a guard |[x] = ["Hi"]
12:04:07 <jellostahps> then id [x] referring to the list [(String,Int)] with only a single item?
12:04:12 <jellostahps> is*
12:04:22 <jle`> yes
12:04:33 <jle`> but note that guards have to have Bools in them
12:04:35 <jellostahps> I keep getting a compile error as follows:
12:04:53 <jle`> if you want to only go down that branch if x has lenght 1, try:
12:04:56 <jle`> cheapItems [x] z = ...
12:05:03 <jle`> or cheapItems x z = case x of
12:05:13 <jle`>     [theOneItem] -> ...
12:05:28 <jle`> for a guard, the conditional has to be a Bool
12:05:50 <jellostahps> is [x] not a Bool condition- True if the list has only one item, False otherwise?
12:06:04 <jle`> no, [x] has type [(String,Int)]
12:06:06 <jle`> not Bool
12:06:37 <lyxia> don't confuse patterns and guards
12:06:58 <jle`> if you want to go down a branch depending on a matched pattern, you would have to use pattern matching, in a case statement or in your argument patterms
12:07:10 <jle`> but you can tell if something is a Bool or not based on its type
12:07:16 <jle`> if it has type Bool, then it is a Bool
12:07:19 <jle`> if not, then it isn't :)
12:07:44 <jellostahps> thanks that gives me something to work on
12:07:45 <jle`> remember that Bool's in haskell are actually a specific type
12:07:47 <jellostahps> great explanations
12:08:09 <jle`> not like their fuzzy counterparts in python, c, javacsript, etc.
12:09:12 <jellostahps> I could also do cheapItems [x] _ = .. for pattern matching correct?
12:10:26 <jle`> yes :)
12:10:31 <jellostahps> ty
12:10:57 <jle`> if you realllly wanted to use guards, you can use 'length x == 1'.  but note that that doesn't give you a binding to the single item in the list
12:11:11 <jle`> using a pattern match lets you refer to the single item in the list
12:11:32 <jellostahps> its a bit confusing when to use guards and when to use pattern matching
12:11:59 <jle`> it can be tricky at first i agree
12:12:02 <jellostahps> is it the case, that you can have pattern matching with several guards per expression, and that this may be common
12:12:30 <jle`> yeah, pattern matches are usually more common -- you use them when you want to match on the structure of the input, and want to bind names to parts of the input
12:12:30 <jellostahps> not common, a useful way of designing your code**
12:12:47 <jle`> guards are a little more specialized because Bool's aren't that common in Haskell
12:13:09 <shapr> argent0: I don't know anything about installing Haskell on windows, sorry :-(
12:13:36 <jle`> jellostahps: but usually it's more useful to ask about aspects of something's structure, instead of just a "yes or no" sort of question
12:13:46 <jle`> it's related to a concept we like to call Boolean Blindness
12:13:55 * shapr searches google for that term
12:13:56 <jellostahps> thats something ill haeve to wrap my head awround, still new at this
12:14:31 <shapr> ohh
12:14:40 <jle`> basically by pattern matching you get a lot of 'information' to use and take advantage of
12:14:59 <jle`> but if you use just a yes/no Bool, you basically only have one bit of information: yes, or no
12:15:07 <shapr> that's neat
12:15:46 <jle`> so bools in haskell are rarer than in other languages because, with patterns available, we can often use patterns for control flow instead of bool, and be more effective
12:16:08 <shapr> that's a good viewpoint, hadn't really considered that before
12:24:16 <dmj`> glguy: config-value requires a /very/ recent happy
12:25:07 <dmj`> getting Setup: filepath wildcard 'HappyTemplate' does not match any files. for happy-1.19.12
12:25:37 <glguy> dmj`: Where isn't the current version of happy supported?
12:25:52 <glguy> You can weaken that and it should be fine
12:27:53 <dmj`> glguy: ok cool, that should be all that's left... https://github.com/glguy/config-app/pull/1/files, bumped revs on kan-extensions and other config-* packages as well.
12:29:03 <dmj`> glguy: this hash of nixpkgs has a working ghcjs 8.6 on darwin
12:29:33 <dmj`> glguy: and its the same hash miso uses, so you can use miso's cache if you don't want to build with ghcjs. 
12:29:42 <dmj`> nix-env -iA cachix -f https://cachix.org/api/v1/install && cachix use haskell-miso && nix-build
12:30:01 <dmj`> don't want to build *ghcjs*
12:35:36 <dmj`> glguy: I'll let you know when it's building on my mac tonight
12:35:52 <glguy> Thanks for the PR
12:38:30 * hackage woe 0.1.0.0 - Convenient typeclass for defining arbitrary-index enums.  https://hackage.haskell.org/package/woe-0.1.0.0 (riuga)
12:38:56 <dmj`> glguy: np
13:09:00 * hackage lens-regex-pcre 1.0.0.0 - A lensy interface to regular expressions  https://hackage.haskell.org/package/lens-regex-pcre-1.0.0.0 (ChrisPenner)
13:10:00 * hackage otp-authenticator 0.1.1.0 - OTP Authenticator (a la google) command line client  https://hackage.haskell.org/package/otp-authenticator-0.1.1.0 (jle)
13:16:21 <NemesisD> is there a way to get `cabal new-update` to not update if the package list is up to date *after a certain point*? i thought `cabal new-update hackage.haskell.org,@1569010481` would do it but it seems to always download the latest and then reverts
13:51:30 * hackage woe 0.1.0.1 - Convenient typeclass for defining arbitrary-index enums.  https://hackage.haskell.org/package/woe-0.1.0.1 (riuga)
13:58:30 * hackage woe 0.1.0.2 - Convenient typeclass for defining arbitrary-index enums.  https://hackage.haskell.org/package/woe-0.1.0.2 (riuga)
14:02:22 <Guest_5> what do i do to source /users/.ghcup/env in my shell\
14:02:39 <Guest_5> it says e.g. ~/.bashrc
14:03:10 <EvanR> you put source /users/.ghcup/env in ~/.bashrc    (assuming .bashrc runs at login)
14:03:39 <EvanR> it may not, e.g. if you have ~/.bash_profile
14:03:44 <Guest_5> i enter that line?
14:04:02 <EvanR> yes... source my/path/to/file
14:04:11 <Guest_5> so do i open a new terminal window and it should be in ~/.bashrc 
14:04:50 <EvanR> you... open a new terminal and it may have autoran
14:12:00 * hackage woe 0.1.0.3 - Convenient typeclass for defining arbitrary-index enums.  https://hackage.haskell.org/package/woe-0.1.0.3 (riuga)
14:13:23 <koz_> That package amuses me.
14:22:00 * hackage hs-ix 0.1.1.0 - Indexed monads  https://hackage.haskell.org/package/hs-ix-0.1.1.0 (MatthewFarkasDyck)
14:56:00 * hackage Map 0.1.2.0 - Class of key-value maps  https://hackage.haskell.org/package/Map-0.1.2.0 (MatthewFarkasDyck)
15:13:00 * hackage semantic-source 0.0.0.0 - Types and functionality for working with source code  https://hackage.haskell.org/package/semantic-source-0.0.0.0 (robrix)
15:29:05 <aplainzetakind> Is there a comprehensive numerical math library which includes common special functions?
15:30:42 <duncan> Could you clarify what sort of functions you're looking for?
15:31:22 <aplainzetakind> logarithmic integral, exponential integral, gamma, for instance
15:40:23 <jle`> aplainzetakind: i use math-functions sometimes i think
15:40:30 <jle`> it has a SpecFunctions module even
15:40:36 <jle`> but usually i use 'statistics' if statistics has the function i want
15:49:07 <aplainzetakind> jle`: It doesn't have the integrals, I'll just use the integration library I guess. My use case is pretty trivial.
16:24:01 <jle`> aplainzetakind: alas
16:25:19 <dmwit> I have a cunning plan.
16:25:31 <dmwit> I will write numbers after the decimal point in a shifting base.
16:25:42 <dmwit> The first digit is in base 2. The next in base 3. Then base 4, 5, 6...
16:25:58 <jle`> how about, each base is determined by the value of the digit before
16:26:05 <dmwit> This way no rationals need infinitely many digits, and we don't suffer from 0.9999999999... = 1.
16:26:16 <int-e> dmwit: yay. e = 2.1111111...
16:26:38 <int-e> dmwit: but it will suffer from 0.123456789(10)(11)(12)... = 1
16:26:42 <jle`> seems sound to me
16:26:50 <dmwit> Well. "no rationals need infinitely many digits" is right, but "we don't suffer from 0.9999..... = 1" isn't. =(
16:27:02 <dmwit> int-e: yeah =(
16:28:20 <dmwit> int-e: e = 2.111111.... is beautiful.
16:28:31 <dmwit> I can't believe that rolled off the tip of your tongue instantly.
16:30:41 <dmwit> "each base is determined by the digit before it" seems like trouble: the base will monotonically decrease until you hit 0 and then suddenly everything goes wonky
16:31:04 <int-e> dmwit: I've sneaked down this road before :)
16:31:12 <int-e> snuck?
16:31:16 <dmwit> I suppose there's no reason the determination has to be the identity function.
16:31:47 <dmwit> Don't worry, nobody corruct you.
16:31:48 <int-e> dmwit: this is also related to a spigot algorithm for e.
16:32:39 <int-e> and by "related" I mean it starts out exactly like that, 2.1111, but then it messes things up by repeatedly multiplying by 10.
16:33:33 <dmwit> Okay, corollary: nobody knows whether or not the representation of pi in this format eventually ends up going n, n+1, n+2, n+3, n+4, ...
16:33:51 <dmwit> (where n is the depth of the start of this sequence)
16:34:51 <pavonia> > (2+) . sum . map (\x -> 1/x*1/10**(x-1)) $ [2..1000]
16:34:53 <lambdabot>  2.053605156578263
16:37:01 <dmwit> int-e: If I make the first base 1 instead of 2, then e = 1.11111111....
16:37:10 <dmwit> ...sort of
16:37:42 <pavonia> I don't follow, how does that add up to e?
16:38:21 <dmwit> > (2+) . sum . map (\x -> 1/product [1..x]) $ [2..20]
16:38:22 <lambdabot>  2.718281828459045
16:38:36 <int-e> > 1.9 - log 0.9
16:38:38 <lambdabot>  2.0053605156578262
16:38:44 <int-e> ah
16:38:58 <int-e> > 1 - 10*log 0.9
16:39:00 <lambdabot>  2.053605156578263
16:39:36 <dmwit> pavonia: Think about it. In base n, the first digit after the decimal is worth 1/n; the next 1/n*n; the next 1/n*n*n.
16:40:03 <dmwit> pavonia: If the base is shifting, starting from n, the first is worth 1/n; the next 1/n*(n+1); the next 1/n*(n+1)*(n+2).
16:40:40 <int-e> Oh well, mixed base representations *are* fun.
16:41:11 <pavonia> Ah yeah, that's confusing
16:43:03 <pavonia> But it makes sense, in pure base 2 0.01 is 1/4 not 1/40
16:43:21 <dmwit> more to the point, not 1/20
16:43:35 <pavonia> Or that :p
16:43:58 <int-e> 01:42:59 <-- mixed base (alternating betweenb 6 and 10)
16:44:49 * dmwit . o O ( 25:00:00 )
16:45:31 <int-e> dmwit: yeah. it's not perfect
17:05:35 <jellostahps> grow :: String -> Striing
17:05:36 <jellostahps> grow (x:xs) = x:grow [xs]
17:05:55 <jellostahps> if (x:xs) is just an array of Chars, why is my compiler throwing errors
17:06:42 <jellostahps> the compiler underlines [xs] saying it got[char] but expected char
17:07:28 <hpc> your issue is (grow [xs])
17:07:43 <jellostahps> yes
17:07:55 <hpc> look at the types of xs and [xs] in particular
17:08:12 <jellostahps> if xs is a list of chars, then [xs] should be a String?
17:08:18 <argent0> [xs] is [[Char]]
17:08:26 <hpc> String = [Char]
17:08:32 <hpc> so [[Char]] = ...
17:08:43 <jellostahps> oh that fixed it
17:08:58 <jellostahps> what would be the syntax to double each char in a string?
17:09:12 <hpc> double how?
17:09:26 <jellostahps> "string" to "ssttrriinngg"
17:10:00 <hpc> so you have x already, which is say, 's'
17:10:04 <hpc> and xs is "tring"
17:10:15 <hpc> so you want a list that's x twice at the start
17:10:17 <hpc> then xs
17:10:20 <hpc> or, grow xs
17:10:39 <jellostahps> ooh so it would be x:x:grow xs recursively
17:10:59 <hpc> yep
17:11:07 <jellostahps> interesting
17:11:08 <jellostahps> thx
17:14:06 <iqubic> I just finished proving that Lenses are the coalgebra for the costate comonad.
17:14:24 <pikajude> > fix (\f xs -> case xs of [] -> []; (x:xs) -> x:x:f xs) "string"
17:14:26 <lambdabot>  "ssttrriinngg"
17:15:06 <iqubic> Now I'm entering the bizarre world of bazaar traversals.
17:15:16 <koz_> iqubic: You mean the _bazaar_ world?
17:15:21 <koz_> *ba-dum-psh*
17:15:24 <pikajude> heh, gotem
17:15:53 <iqubic> koz_: That was stupid.
17:15:59 <koz_> iqubic: I couldn't agree more.
17:16:01 <MarcelineVQ> pow
17:16:14 <koz_> :t pow
17:16:15 <lambdabot> error: Variable not in scope: pow
17:16:18 <koz_> Aww.
17:16:25 <iqubic> "newtype Bazaar a s = Bazaar { runBazaar :: forall f. Applicative f => (a -> f a) -> f s }"
17:16:31 <int-e> t (**)
17:16:33 <int-e> t (**)
17:16:35 <int-e> :t (**)
17:16:36 <lambdabot> Floating a => a -> a -> a
17:16:57 <iqubic> type Traversal' s a = s -> Bazaar a s
17:16:59 <int-e> (I'm too stupid to use my fingers!)
17:17:13 <int-e> MarcelineVQ: (**) is pow.
17:17:14 <koz_> int-e: We need a mind-interface for Haskelling.
17:17:25 <koz_> That way, you can pump thoughts directly into GHC for verification.
17:17:28 <iqubic> And that type there is isomorphic to what the lens library uses.
17:17:46 <iqubic> Writting the Applicative instance for Bazaar was tricky.
17:17:57 <dmwit> > "string" >>= replicate 2
17:17:59 <lambdabot>  "ssttrriinngg"
17:18:08 <iqubic> got 'em
17:18:31 <koz_> > "string >>= replicate 1
17:18:33 <lambdabot>  <hint>:1:24: error:
17:18:33 <lambdabot>      lexical error in string/character literal at end of input
17:18:37 <koz_> > "string" >>= replicate 1
17:18:39 <lambdabot>  "string"
17:18:43 <koz_> > "string" >>= replicate 0
17:18:45 <lambdabot>  ""
17:18:48 <koz_> :D
17:18:49 <int-e> MarcelineVQ: In fact we have three exponentiation operators: ^ (natural exponent, Num arguments), ^^ (integer exponent, Fractional argument) and ** (Floating exponent and argument)
17:21:00 <pikajude> id for string should be defined as (>>= replicate 1) for maximum efficiency
17:23:14 <MarcelineVQ> int-e: integer? but it was an interjection!
17:23:14 <iqubic> I am slowly learning how the lens library works internally.
17:25:30 <int-e> this way madness lies
17:28:36 <koz_> pikajude: Lol.
17:31:30 <jellostahps> so doubling every char of a String is grow :: String -> String
17:31:38 <jellostahps> grow(x:xs) = x:x:grow(xs)
17:31:57 <jellostahps> what about every index of a character is repeated that many times
17:32:34 <jellostahps> input=string output = s t t r r r i i i i n n n n n g g g g g g
17:32:50 <pikajude> grow "string" = "sttrrriiiinnnnngggggg"
17:32:54 <pikajude> may not work for all inputs
17:33:24 <jellostahps> yeah, wondering what i can do to fix it
17:33:31 <jellostahps> would it definitely require a second function
17:34:38 <dmwit> > concat (zipWith replicate [1..] "string")
17:34:40 <lambdabot>  "sttrrriiiinnnnngggggg"
17:35:11 <dmwit> ...but more helpfully:
17:35:32 <dmwit> jellostahps: Try writing a function which takes *two* arguments: the current index, and the input string starting at that index.
17:35:50 <jellostahps> I have to do it with a single string input
17:35:52 <dmwit> So `foo n (x:xs) = ???`.
17:36:12 <dmwit> Then you can write a single top-level wrapper like `wrapper = foo 1`.
17:36:50 <dmwit> (Or `wrapper xs = foo 1 xs` if that's more clear to you.)
17:38:07 <jellostahps> is a wrapper just f(g(x))
17:38:34 <jellostahps> or wrapper . foo 1 xs in this case
17:38:39 <dmwit> No.
17:38:49 <dmwit> It is `wrapper xs = foo 1 xs`. Which is why I wrote that.
17:39:49 <jellostahps> foo runs with parameter 1 and xs=string, and returns a string i imagine
17:40:28 <dmwit> Sounds right.
17:40:48 <koz_> > bool 1 2 True
17:40:50 <lambdabot>  2
17:41:32 <jellostahps> wouldnt a variable be better than using '1' here
17:41:45 <jellostahps> since u have to iterate 1 for the next letter(s)
17:42:39 <iqubic> Iterating 1 for the next letter(s) is done in foo.
17:42:57 <iqubic> wrapper is the call you do the first time.
18:00:15 <jellostahps> quick quesiton. I have a function called gcd, a name already defined in the prelude. So i put this at the top of my file.hs
18:00:17 <jellostahps> import Prelude hiding (gcd)
18:00:32 <jellostahps> it allowed me to name my function gcd, but now it screws up all my calculations
18:01:03 <jellostahps> Am I missing something?
18:02:01 <EvanR> do they have different types
18:02:13 <jellostahps> let me check
18:02:19 <MarcelineVQ> sounds like your gcd function is incorrect if your calcs are coming out wrong when you use it
18:02:37 <EvanR> oh... yeah
18:02:37 <jellostahps> NO, actually it works fine if i rename my function to something else
18:03:35 <epta> can DerivingVia help with defining Semigroup/Monoid instance for a wrapper-like data type like 'newtype A = A { unA :: X }' ?
18:04:18 <jellostahps> EvanR: they have the same type, albeit Prelude gcd is of type Integral and my gcd is of type Int
18:06:16 <EvanR> then.... they seem to NOT have the same type after all
18:06:22 <jellostahps> also not sure if its important but  i dont have a module statement at the top of my .hs
18:14:28 <epta> btw, the answer for my own question is "deriving (Semigroup, Monoid) via A" :)
18:17:09 <MarcelineVQ> jellostahps: bst to share your file, what you type to test it, and what you expected to see
18:21:55 <jellostahps> MarcelineVQ: Here you go, including compiler error    https://pastebin.com/csvcSaL4
18:24:40 <dmwit> Module names must start with an upper case letter.
18:25:34 <dmwit> I also challenge the claim that "actually it works fine if I rename my function to something else", if "it" is the file you just showed us.
18:25:51 <iqubic> Yeah. Me too.
18:27:43 <jellostahps> dmwit:you are right i was accidentally testing with prelude gcd :(
18:35:46 <ski> jellostahps : hm, try to work out, on paper, what happens with e.g. `gcd 3 2' ior `gcd 4 2', using your definition
18:37:37 <jellostahps> it messes up horribly
18:37:54 <jellostahps> i think i fixed it by removing the 2*
18:42:18 <ski> where did the `2*'s come from ?
18:46:40 <jellostahps> 3am confidence
18:46:49 <jellostahps> im trying some other things, hopefully i can work it out
18:46:53 <ski> heh
18:51:04 <iqubic> So, I just recently learned how Lenses work internally, and it is really really cool.
18:51:21 <iqubic> Traversals are quite literally Bazaar.
18:52:28 <koz_> iqubic: Those puns though.
18:53:43 <int-e> koz_: have you found the time travel/back to the future references yet...
18:53:53 <koz_> int-e: In what?
18:54:00 <koz_> I'm not the one going through learning how lenses work. :P
18:54:26 <jellostahps> ski: I think I got it. https://pastebin.com/M0K9FAgq
18:55:00 <int-e> koz_: https://hackage.haskell.org/package/bifunctors-5.5.4/docs/Data-Bifunctor-Tannen.html (at least I though that was the etymology, I'd be happy to be wrong)
18:56:08 <koz_> int-e: Oh, those. Yeah, I saw those pretty quickly.
18:56:18 <koz_> There's also Biff.
18:56:39 <int-e> koz_: Yeah I know (or rather, I just rediscovered it)
18:57:26 <dmwit> jellostahps: A puzzle (related to the "write a wrapper" suggestion from earlier): this implementation of `gcd` checks whether `x > y` on every step of the recursion. But on every step after the first, we actually already know that `y < x`, so we should really only need to check it once. Can you write a version that only checks once?
19:00:21 <jellostahps> Thinking about it , no
19:00:31 * hackage abides 0.0.0 - Simple boolean tests to see if a value abides by certain properties  https://hackage.haskell.org/package/abides-0.0.0 (athanclark)
19:00:40 <jellostahps> either the wrapper or inner would have to check > <
19:01:07 <jellostahps> and limiting that to a single check... not sure how
19:01:58 <ski> jellostahps : what's wrong with (only) the wrapper checking it ?
19:02:47 <koz_> Hackage abides, lol.
19:03:12 <jellostahps> ambiguity arises on where the result value is obtained. If its obtained without the wrapper class reiterating, then i could see that as a solution
19:04:24 <iqubic> ski: I'd make a mutually recurisive set of functions.
19:04:46 <ski> why ?
19:04:50 <iqubic> One wrapper that does the first check, then one for even calls, and one for odd calls.
19:05:13 <iqubic> Or rather, just have a boolean that tracks if the first input is larger, and switch based on that.
19:05:27 <EvanR> o_O
19:05:45 <ski> why ?
19:05:47 <iqubic> Or even better, just always call the function with larger value in the first argument.
19:05:56 <ski> yea, that sounds simpler, to me ..
19:06:15 <iqubic> Because "gcd 4 2 == gcd 2 4"
19:06:47 <iqubic> Anyways, I have to go now.
19:06:53 <iqubic> Be back later.
19:08:41 <ski> > unfoldr (\(x,y) -> if y == 0 then Nothing else Just (join (,) (y,x `mod` y))) (33,21)
19:08:43 <lambdabot>  [(21,12),(12,9),(9,3),(3,0)]
19:08:46 <ski> > unfoldr (\(x,y) -> if y == 0 then Nothing else Just (join (,) (y,x `mod` y))) (21,33)
19:08:48 <lambdabot>  [(33,21),(21,12),(12,9),(9,3),(3,0)]
19:08:56 <ski> > unfoldr (\(x,y) -> if y == 0 then Nothing else Just (join (,) (y,x `mod` y))) (-33,21)
19:08:59 <lambdabot>  [(21,9),(9,3),(3,0)]
19:09:04 <ski> > unfoldr (\(x,y) -> if y == 0 then Nothing else Just (join (,) (y,x `mod` y))) (-33,-21)
19:09:06 <lambdabot>  [(-21,-12),(-12,-9),(-9,-3),(-3,0)]
19:09:09 <ski> > unfoldr (\(x,y) -> if y == 0 then Nothing else Just (join (,) (y,x `mod` y))) (33,-21)
19:09:11 <lambdabot>  [(-21,-9),(-9,-3),(-3,0)]
19:09:17 <ski> > unfoldr (\(x,y) -> if y == 0 then Nothing else Just (join (,) (y,x `mod` y))) (-21,33)
19:09:19 <lambdabot>  [(33,12),(12,9),(9,3),(3,0)]
19:09:21 <ski> > unfoldr (\(x,y) -> if y == 0 then Nothing else Just (join (,) (y,x `mod` y))) (21,-33)
19:09:23 <lambdabot>  [(-33,-12),(-12,-9),(-9,-3),(-3,0)]
19:09:24 <ski> > unfoldr (\(x,y) -> if y == 0 then Nothing else Just (join (,) (y,x `mod` y))) (-21,-33)
19:09:26 <lambdabot>  [(-33,-21),(-21,-12),(-12,-9),(-9,-3),(-3,0)]
19:09:30 <ski> (ok, done)
19:52:24 <jellostahps> dmwit: im trying to understand your wrapper stuff
19:52:39 <jellostahps> my wrapper class is w:Int -> Int
19:52:51 <jellostahps> wrapper function *
19:53:23 <jellostahps> my function that the wwrapper function uses is also Int -> Int
19:53:53 <jellostahps> the wrapper can only take in one parameter, so the other function can also only use that parameter... soI dont get the point of using a wrapper
19:54:10 <jellostahps> u r just passing the same parameter to the inner function for it to do things... why not just do that in the wrapper
19:54:18 <jellostahps> Do you have any simple examples of what you are talking about
20:08:11 * ski idly wonders what code jellostahps is talking about
20:11:30 <MarcelineVQ> ski: "<dmwit> jellostahps: A puzzle (related to the "write a wrapper" suggestion from earlier): this implementation of `gcd` checks whether `x > y` on every step of the recursion. But on every step after the first, we actually already know that `y < x`, so we should really only need to check it once. Can you write a version that only checks once?"
20:12:50 <MarcelineVQ> ski: https://gist.github.com/MarcelineVQ/1e969753cd6d8d94400a1d19bdcfa9b6
20:13:54 <dmwit> I wonder what code jellostahps is talking about, too.
20:14:44 <dmwit> Neither the original wrapper suggestion (which was for a function operating on lists) nor the gcd puzzle involve Int -> Int as either the top-level or wrapped type.
20:15:28 <ski> oh. ty, MarcelineVQ :)
20:16:00 <dmwit> jellostahps: What is `w` and why does it have (or why do you want it to have) type Int -> Int?
20:30:51 <ysangkok> % ([(42, "hello")],"world") & ((_2 %~ ((++) "abc")) . (_2 %~ const "james"))
20:30:51 <yahb> ysangkok: ([(42,"hello")],"abcjames")
20:31:05 <ysangkok> how do i pull out the common _2 part so that i don't have to duplicate it?
20:35:50 <jellostahps> dmwit: i thought u were describing a very general and abstract problem. I specified it on a whim and then presented it to. i can understand the confusion
20:35:58 <jellostahps> thats enough hasell for me today
20:42:19 <shapr> no
20:42:22 <shapr> there is not enough
20:42:29 <koz_> There is never enough.
20:43:07 <shapr> I spend a surprising amount of time explaining things about Haskell here at Recurse Center.
20:43:31 <MarcelineVQ> During the meetings about taking over the world?
20:44:22 <dmwit> % ([(42,"hello")],"world") & (_2 %~ ((++) "abc" . const "james")) -- ysangkok
20:44:23 <yahb> dmwit: ([(42,"hello")],"abcjames")
20:44:53 * ski wraps a worker in a burrito
20:45:19 <dmwit> ...burrito transformer!
20:45:34 <dmwit> Or else how could it possibly sensibly be called the worker-wrapper transform?
20:45:45 <Welkin> anything exciting in 8.8.1?
20:47:22 <ysangkok> dmwit: well, i guess my example is too simplified. the problem is that the two branches need to do some further drilling down. in the example you gave, the functions themselves have been composed, which you can do since they drilled down to the same target
20:47:51 <ysangkok> so there is a shared part of drilling down, and there is a non-shared part...
20:48:07 <Welkin> what is this drilling you speak of?
20:48:12 <dmwit> ysangkok: Then you cannot share.
20:48:12 <MarcelineVQ> shapr: That's what I thought.
20:49:22 <dmwit> ysangkok: I mean, you can still do `foo & _2 %~ ((foo %~ f) . (bar %~ g))` of course.
20:49:40 <ysangkok> aaaah, that looks good
20:50:31 <ysangkok> Welkin: by drilling i just mean unpeeling layers of things you can go though with optics
20:50:50 <ysangkok> Welkin: i am sure there are more correct terms for this
20:51:16 <Welkin> you could just say you are using lens
20:51:22 <dmwit> But there is no %%~%~%~ which would let you do `_2 . (foo %%~%~%~ bar) %~ (f *** g)`.
20:51:49 <jle`> not with that attitude there isn't
20:52:30 * hackage ats-pkg 3.2.6.0 - A build tool for ATS  https://hackage.haskell.org/package/ats-pkg-3.2.6.0 (vmchale)
20:52:44 * dmwit . o O ( "the problem is that the two branches need to do some further you are using lens"? )
20:53:05 <dmwit> "drilling down" seems perfectly cromulent to me.
20:54:14 <Welkin> sounds like a video game
20:54:17 <Welkin> digdug
20:54:21 <Welkin> or some other japanese game
20:54:27 <Welkin> what's that one with the drill guy?
20:55:03 <jle`> dug dig
20:55:45 <MarcelineVQ> megaman :>
20:56:22 <Welkin> no there is another one
20:58:17 <turab> @pl \k a b -> (k, b <> a)
20:58:17 <lambdabot> (. flip (<>)) . (.) . (,)
21:00:41 <turab> @pl \k a b -> a <> b
21:00:41 <lambdabot> const (<>)
21:17:56 <Nolrai> So I want to basically do a Sudoku solver, not quite, but the structure of the problem is similar. The issue I am having is that I am not sure what data structure to use. Right now I am using a vector of vectors of mutable bit vectors. But then I have to undo everything when I backtrack, which ends up making the control flow really hard to follow
21:17:56 <Nolrai> as I have to use bracket.
21:20:18 <Nolrai> But if I switch to using Immutable vectors or sets or something wont that end up pretty awful performance wise?
21:24:01 <Welkin> have you seen richard bird's sudoku solver?
21:24:06 <heatsink> A rule of thumb is that for immutable data structures, each data structure access operation has an extra O(log N) overhead.
21:24:07 <Welkin> it is elegantly simple using lists
21:24:34 <heatsink> If you have advance knowledge about what part of the data will be accessed, you can make it more efficient
21:24:35 <Welkin> heatsink: that is not true
21:25:01 <Welkin> immutable vectors or arrays are both constant time access, same with mutable
21:25:14 <Welkin> mutability has nothing to do with that
21:25:34 <heatsink> How long does it take to update one element of an immutable vector, though
21:25:52 <Welkin> for a vector, you make a new copy with the changes
21:25:56 <heatsink> If you use the kind that has O(1) read, then it's an O(N) update because you copy the entire vector
21:26:03 <Welkin> for a linked structure, it could be constant
21:26:44 <heatsink> What do you mean by a linked structure?  If it's a linked list, it's O(1) to update one end and O(N) to update the other end
21:29:32 <Welkin> what is this odd error I'm getting in emacs? Flycheck complains about something and mentions haskell-stack-ghc
21:29:41 <Welkin> wtf is that? I don't even have it installed. I don't even use stack
21:29:53 <Welkin> is this a haskell-mode thing or what?
21:30:35 <rajivr___> Is there a GHCi option that shows `:t  return` as  `return :: forall (a :: *) (m :: * -> *). Monad m => a -> m a` instead of `return :: Monad m => a -> m a`?
21:30:38 <Welkin> there is a flycheck checker for it
21:30:43 <Welkin> what the hell
21:31:06 <Welkin> stack has a global project setting
21:31:08 <dmwit> heatsink: Can you reuse a standard solver, like one of the exact set cover solvers or SAT solvers available on Hackage?
21:31:12 <Welkin> time to purge my system of all stack related things
21:31:25 <dmwit> heatsink: They're generally going to have already done a lot of the work about getting efficient mutable backtracking set up.
21:31:41 <jle`> rajivr___: :set -fprint-explicit-kinds maybe?
21:31:46 <dmwit> Nolrai: Sorry, I meant to say that to you, not heatsink.
21:31:57 <heatsink> rajivr__: -fprint-explicit-foralls
21:32:02 <jle`> rajivr___: ah, that combined with -fprint-explicit-foralls
21:32:19 <jle`> % :set -fprint-explicit-kinds
21:32:19 <yahb> jle`: 
21:32:23 <jle`> % :set -fprint-explicit-foralls
21:32:23 <yahb> jle`: 
21:32:26 <jle`> % :t return
21:32:26 <yahb> jle`: forall {m :: * -> *} {a}. Monad m => a -> m a
21:32:33 <jle`> hm, why doesn't it show the kind of a?
21:33:16 <jle`> :t pure
21:33:18 <lambdabot> Applicative f => a -> f a
21:33:21 <jle`> % :t pure
21:33:22 <yahb> jle`: forall {f :: * -> *} {a}. Applicative f => a -> f a
21:33:26 <dmwit> % :t +v pure
21:33:26 <yahb> dmwit: forall (f :: * -> *) a. Applicative f => a -> f a
21:33:32 <rajivr___> Thanks jle` . Let me try it. As a haskell newbie who is still coming up to speed with all its magic :-) I find seeing explicit kind signatures as  a handy tool to grasp what is happening under the hood.
21:33:53 <rajivr___> Thanks heatsink :-)
21:33:54 <jle`> yeah it can definitely be useful to 'query' for the kinds of things
21:33:59 <dmwit> % :t id
21:33:59 <yahb> dmwit: forall {a}. a -> a
21:34:07 <dmwit> jle`: I think it just never prints kinds that are *.
21:34:11 <jle`> one issue is that it sometimes clutters error messages if it's *always* on
21:34:19 <jle`> % :t Const
21:34:19 <yahb> jle`: forall {k} {a} {b :: k}. a -> Const k a b
21:34:27 <jle`> hm, that's a good theory dmwit 
21:34:57 <jle`> oh man did that k in Const k a b come up because i did -fprint-explicit-kinds? i wonder if i can turn it off and it'll still print hte kinds int he foralls
21:35:19 <jle`> % :set -fno-print-explicit-kinds
21:35:19 <yahb> jle`: 
21:35:22 <jle`> % :t Const
21:35:23 <yahb> jle`: forall {k} {a} {b :: k}. a -> Const a b
21:35:29 <jle`> oh ok. yeah don
21:35:34 <iqubic> Is there a way to get GHC to print "Type" instead of "*"?
21:35:36 <jle`> don't turn on print-explicit-kinds heh, just listen to heatsink 
21:35:46 <jle`> % :set -XNoStarIsType
21:35:46 <yahb> jle`: 
21:35:58 <jle`> % :set -XTypeInType
21:35:58 <yahb> jle`: 
21:36:07 <jle`> % :t return
21:36:07 <yahb> jle`: forall {m :: Type -> Type} {a}. Monad m => a -> m a
21:36:10 <dmwit> from future import Type
21:36:17 <jle`> hooray but i'm not sure which extension is the one that did it
21:36:22 <iqubic> Why do youo need to turn on TypeInType there?
21:36:28 <jle`> i'm not sure which one of those did the magic
21:36:33 <jle`> i am not good at science
21:36:41 <iqubic> % :unset -XTypeInType
21:36:41 <yahb> iqubic: 
21:36:51 <iqubic> % :t return
21:36:51 <yahb> iqubic: forall {m :: Type -> Type} {a}. Monad m => a -> m a
21:37:05 <iqubic> It's NoStarIsType that did it.
21:37:10 <dmwit> You don't know that.
21:37:16 <dmwit> You only know that NoStarIsType did it.
21:37:16 <jle`> is that what unset does?
21:37:38 <dmwit> (TypeInType might *also* do it!)
21:38:04 <iqubic> What does TypeInType even do?
21:38:25 <jle`> it flattens types and kinds
21:38:51 <jle`> so kinds are no different than types, they exist at the same level for all things for the most part
21:39:44 <iqubic> Doesn't that allow for weird paradoxes and things?
21:40:08 <jle`> yup, but haskell has sort of historically errored on the side of allowing paradoxes if you really want them, for producitvity's sake
21:40:39 <jle`> erred ?
21:40:45 <jle`> that sounds better
21:40:55 <iqubic> The changes described below are intended to be controlled by a new extension -XTypeInType, which will imply -XPolyKinds and -XDataKinds
21:41:18 <heatsink> TypeInType paradoxes manifest as nonterminating code
21:41:47 <jle`> i like to think of Haskell as the "as safe as you want" language
21:41:47 <iqubic> If anyone wants to read about TypeInType I can link the site that I'm looking at.
21:41:56 <iqubic> https://gitlab.haskell.org/ghc/ghc/wikis/dependent-haskell/phase1
21:42:04 <iqubic> jle`: I agree.
21:42:15 <iqubic> % :t unsafePerformIO
21:42:15 <yahb> iqubic: forall {a}. IO a -> a
21:42:25 <iqubic> It's as safe as you want it to be.
21:43:11 <heatsink> :t reallyUnsafePtrEquality#
21:43:12 <lambdabot> error:
21:43:13 <lambdabot>     Variable not in scope: reallyUnsafePtrEquality#
21:43:21 <iqubic> What does that do?
21:43:29 <jle`> it's pointer equality
21:43:34 <jle`> but in a way that is particularly unsafe
21:43:49 <jle`> unsafePtrEquality will provide false positives and false negatives
21:43:56 <jle`> reallyUnsafePtrEquality will launch nuclear missiles
21:44:17 <iqubic> Oh. So it both does what you want, and doesn't do what you want at the esame time.
21:44:18 <heatsink> It will force the pointers to be equal, even if they weren't before
21:45:10 <heatsink> 0x8020 is now equal to 0x8040
21:47:08 <iqubic> That is terrible as all hell.
21:47:17 <iqubic> Is there safePtrEquality?
21:47:54 <iqubic> Is there an Eq instance for pointers that compares the memory locations that the two point to?
21:48:25 <heatsink> There is an instance for foreign pointers, which is useful for interacting with C code
21:48:31 <iqubic> Nice.
21:49:04 <iqubic> I know next to nothing about Haskell's FFI. I also know next to nothing about C.
21:49:42 <iqubic> Why would you ever need to call C code? Haskell can do everything for you, can't it?
21:50:48 <heatsink> It's useful for incrementally porting heretic-authored programs into Haskell
21:51:26 <javier_> Hi, beginner question, Is there a way to pattern match a Maybe to a value kinda like this? contains x (Just x) = True
21:52:03 <heatsink> javier_, no, you can't use pattern matching to check whether two variables are equal
21:52:17 <heatsink> You can write a guard, contains x (Just y) | x == y = true
21:52:49 <koz_> @pl \x -> (x,x)
21:52:49 <lambdabot> join (,)
21:52:56 <jle`> and of course if you're just returning a Bool you could do contains x (Just y) = x == y
21:53:01 <iqubic> heatsink: javier_: You'd also need to handle the Nothing case.
21:53:27 <iqubic> contains x maybeX = Just x == maybeX.
21:53:47 <iqubic> That will work, and handle Nothing quite nicely.
21:53:58 <jle`> contains x = any (== x)
21:54:20 <iqubic> And that works any foldable. That's quite nice.
21:54:38 <iqubic> @pl \x -> any (== x)
21:54:38 <lambdabot> any . (==)
21:54:47 <heatsink> :t any
21:54:48 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
21:54:53 <iqubic> That's not really any nicer.
21:55:21 <iqubic> :t fold
21:55:22 <lambdabot> (Foldable t, Monoid m) => t m -> m
21:55:32 <javier_> cool, thanks
21:56:03 <Axman6> javier_: just as an aside, you _can_ do that in Erlang
21:56:07 <iqubic> @src any
21:56:07 <lambdabot> any p = or . map p
21:56:11 <jle`> i think these are called ... linear patterns?
21:56:27 <heatsink> yes
21:56:31 <jle`> you can sort of fake it in Haskell too but not in a super nice way
21:56:36 <iqubic> I don't think that version of any will work for foldables.
21:56:45 <heatsink> dunno how they're related to other notions of linearity tho
21:56:47 <jle`> contains x (Just ((== x)->True)) = True
21:57:02 <dmwit> > 3 `elem` Just 4
21:57:03 <iqubic> What is that arrow doing there?
21:57:03 <Axman6> the definitions in lambdabot are not the actual definitions'
21:57:04 <lambdabot>  False
21:57:06 <jle`> if you replace the second occurence of 'x' with '(== x)->True'
21:57:06 <dmwit> > 3 `elem` Just 3
21:57:08 <lambdabot>  True
21:57:12 <jle`> it's a ViewPattern
21:57:32 <iqubic> I don't know about that GHC Language Pragma
21:57:40 <iqubic> Should I learn how to use it?
21:57:48 <dmwit> (...so my implementation of choice is `contains = elem`. ;-)
21:57:53 <jle`> it cna be useful; it "pre-applies" a function to a parameter
21:57:57 <jle`> but i'm using it here in a degenerate way
21:58:07 <jle`> i'm abusing it here to do things it wasn't supposed to do heh
21:58:24 <iqubic> > 3 `elem` Nothing
21:58:26 <lambdabot>  False
21:58:30 <iqubic> :t elem
21:58:31 <lambdabot> (Foldable t, Eq a) => a -> t a -> Bool
21:58:48 <iqubic> I see. That is a good way of doing that.
21:58:54 <Axman6> >  3 `elem` Proxy
21:58:56 <lambdabot>  False
21:59:02 * Axman6 shocked
21:59:06 <jle`> > 3 `elem` (3, 4)
21:59:09 <lambdabot>  False
21:59:10 <jle`> D:
21:59:17 * Axman6 less shocked
21:59:29 <iqubic> jle`: Why is that False?
21:59:39 <Axman6> :t elem
21:59:40 <lambdabot> (Foldable t, Eq a) => a -> t a -> Bool
21:59:41 <jle`> > toList (3,4)
21:59:43 <lambdabot>  error:
21:59:43 <lambdabot>      Ambiguous occurrence ‘toList’
21:59:43 <lambdabot>      It could refer to either ‘F.toList’,
21:59:51 <jle`> > F.toList (3,4)
21:59:53 <lambdabot>  [4]
21:59:58 <iqubic> What the hell?
22:00:03 <jle`> (x,y), as a Foldable, only "contains" y
22:00:04 <Welkin> fmap for tuple only looks at the second element
22:00:14 <dmwit> iqubic: https://stackoverflow.com/q/36460833/791604
22:00:17 <jle`> if you think about it, it only makes sense because the first parameter is allowed to freely vary
22:00:17 <Axman6> what's the type of ("Hello", True)
22:00:25 <jle`> > F.toList ("hi",4)
22:00:27 <lambdabot>  [4]
22:00:38 <Axman6> it's ((,) String) Bool
22:00:48 <Axman6> (ish)
22:00:49 <iqubic> Right it can only look at the first element because none of these typeclasses have multiple parameters.
22:00:54 <jle`> anyway the Foldable instance for tuples is something I wish didn't exist
22:01:00 <jle`> but it's a necessary evil because the Traversable instance is so useful
22:01:03 <jle`> alas.
22:01:03 <iqubic> s/first/second/
22:01:03 <Welkin> a tuple is a record!
22:01:08 <Welkin> D:<
22:01:11 <Welkin> anonymous record
22:01:14 <dmwit> Meanwhile, I wish we had Foldable and Traversable for all the tuple lengths.
22:01:24 <Axman6> :t _2
22:01:25 <iqubic> What does Traversable do for tuples?
22:01:25 <lambdabot> (Field2 s t a b, Functor f) => (a -> f b) -> s -> f t
22:01:31 <Axman6> We do! :o
22:01:33 <dmwit> iqubic: What do you think it does?
22:01:51 <iqubic> Lets you access both elements of a tuple?
22:02:05 <Axman6> does that make sense?
22:02:14 <iqubic> I think so, yes.
22:02:16 <Axman6> given what we know about the Foldable instance?
22:02:16 <Welkin> use bimap
22:02:22 <Welkin> or the Arrow functions
22:02:50 <jle`> for the * -> * abstractions for tuple, you can sort of think of (Int,a) as an a that's "tagged" with an Int
22:02:55 <dmwit> iqubic: I encourage you to write `data IQubicTuple a b = IQubicTuple a b` and implement `Foldable` and `Traversable` for it.
22:03:33 * jle` . o ( data IQubicTuple w a = IQubicTuple w a )
22:03:37 <iqubic> :t traverse
22:03:38 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
22:04:04 <iqubic> Wait... It still can only look at the snd element of a tuple
22:06:50 <iqubic> So what good is it even?
22:07:12 <jle`> it's the same as the Traversable instance for, say, data MyRecord a = MyRecord String a
22:07:21 <jle`> you get to map over the 'a' and keep it "tagged" with a String
22:07:43 <iqubic> And you can't do that with Foldable?
22:07:50 <jle`> data Named a = Named { nNamed :: String, nVal :: a }
22:07:59 <jle`> well the mapping part you can do with Functo
22:08:15 <jle`> but remember Foldable is "leave-only", you can only collapse the structure
22:08:20 <jle`> you can't re-create the structure or modify it
22:08:41 <iqubic> Right.
22:08:49 <jle`> you need Functor to do that 'purely', and Traversable to do that 'effectuflly'
22:09:22 <iqubic> A fold loses the value of the first element, but a Traversal doesn't.
22:09:52 <jle`> yeah, the tag can stay attached
22:10:36 <iqubic> but only with a traversal
22:11:30 <iqubic> so this type of traversal is different from the traversals you get from the lens package I believe.
22:13:35 <jle`> traversals from the Traversable typeclass are the same as traversals from the lens package
22:13:50 <jle`> class Traversable t where traverse :: Traversal (t a) (t b) a b
22:14:26 <c_wraith> in fact, it's accurate to say that Traversable is a precursor to the lens package 
22:15:14 <iqubic> But can't you user the lens package traversals to create a traversal over both elements in a tuple?
22:15:37 <Axman6> :t both
22:15:39 <lambdabot> (Data.Bitraversable.Bitraversable r, Applicative f) => (a -> f b) -> r a a -> f (r b b)
22:15:41 <c_wraith> yes, if both elements have the same type. lens is more flexible. 
22:16:01 <jle`> iqubic: Traversals in lens are a concept 
22:16:14 <jle`> the Traversable typeclass is a way to associate specific Traversals with some specific types
22:16:16 <Axman6> :t (_1 . _Show <> _2)
22:16:18 <lambdabot> (Semigroup (f t), Field1 s t String String, Read a, Show a, Applicative f, Field2 s t a a) => (a -> f a) -> s -> f t
22:16:34 <jle`> iqubic: so instead of writing traverseList :: Traversal [a] [b] a b, traverseMaybe :: Traversal (Maybe a) (Maybe b) a b, etc.
22:16:41 <jle`> we make a typeclass to unite some Traversal's together
22:16:45 <jle`> under the same name
22:16:46 <Axman6> > toListOf (_1 . _Show <> _2) (True, "Hello")
22:16:48 <lambdabot>  error:
22:16:48 <lambdabot>      • Couldn't match type ‘[Char]’ with ‘Bool’
22:16:49 <lambdabot>          arising from a functional dependency between:
22:16:56 <jle`> iqubic: but Traversable isn't the only way to generate a Traversal
22:16:59 <Axman6> > toListOf (_1 . re _Show <> _2) (True, "Hello")
22:17:01 <lambdabot>  ["True","Hello"]
22:17:02 <jle`> iqubic: just like, Show isn't the only way to generate a String
22:17:07 <Axman6> =)
22:17:15 <jle`> iqubic: Show generates Strings, but there are more ways to create Strings than just the Show typeclass
22:17:31 <jle`> likewise, Traversable provides Traversals, but there are other ways to create Traversals than just the Traversable typeclass
22:17:45 <iqubic> Right makes sense.
22:17:57 <iqubic> Also, today I wrote my own lenses.
22:18:24 <jle`> congrats :)
22:19:01 <Axman6> Did they break the law?
22:19:04 <iqubic> data Pretext s a = { runPretext :: forall f. Functor f => (s -> f s) -> f a}
22:19:20 <iqubic> type Lens' s a = s -> Pretext a s
22:19:24 <Axman6> gotta be careful you don't end up in lens jail
22:19:50 <iqubic> I wrote the Comonad and ComonadStore instances for Pretext myself.
22:20:15 <iqubic> I then wrote over, view, and set for that version of a lens
22:20:51 <jle`> ah, you didn't just write your own lenses
22:20:56 <jle`> you wrote your own lens abstraction :O
22:21:05 <iqubic> I also wrote "lens :: (s -> a -> s) -> (s -> a) -> Lens' s a"
22:21:40 <iqubic> I know understand the inner workings of lenses a lot better than I did before.
22:22:21 <iqubic> However, I am having a bit of trouble generalizing this to 'Lens s t a b'
22:22:37 <iqubic> I'll just keep working on this myself.
22:23:15 <iqubic> I love knowing how things work.
22:24:20 <iqubic> Also, yes, I did write both 'Store s a -> Pretext s a' and 'Pretext s a -> Store s a'
22:26:04 <iqubic> So, I now understand what people mean when they claim that 'Lens is the coalgebra for the costate comonad
22:27:30 <iqubic> I'm also stepping into the Bazaar world of traversals.
22:30:41 <iqubic> Bazaar is a Pretext with an Applicative constraint as opposed to a Functor. Which allows you to write 'instance Applicative (Bazaar s) where ...'
22:31:46 <jle`> here's something to pondor
22:31:47 <javier_> > Just 2 > Just 1
22:31:48 <lambdabot>  True
22:31:52 <heatsink> Where do these type names even come from?
22:31:57 <javier_> :t (>)
22:31:58 <lambdabot> Ord a => a -> a -> Bool
22:31:59 <jle`> Store is like a Rank1 version of Pretext
22:32:11 <jle`> or Pretext is like a RankN version of Store
22:32:20 <jle`> is there an analogous Rank1 version of Bazaar?
22:32:29 <iqubic> There is.
22:32:32 <iqubic> I know what it is.
22:32:35 <jle`> :D
22:32:41 <javier_> How confirm with ghci that Just 2 is an Ord ?
22:32:49 <iqubic> But only from internet research
22:32:51 <jle`> javier_: you can do :i Ord
22:32:56 <jle`> iqubic: it's a fun journey to go down
22:33:19 <iqubic> data FunList a b t = Done t | More a (FunList a b (b -> t))
22:33:53 <iqubic> That's such a weird type.
22:34:25 <iqubic> I find it hard to believe that what I have there is isomorphic to a Bazaar.
22:34:33 <javier_> instance Ord a => Ord (Maybe a) -- Defined in ‘GHC.Base’
22:34:38 <javier_> ty
22:38:44 <iqubic> Here's what I wrote today: http://dpaste.com/253VH76
22:40:44 <iqubic> jle`: If you'd care to see what I've been up to.
23:07:30 * hackage finitary 1.1.0.0 - A better, more type-safe Enum.  https://hackage.haskell.org/package/finitary-1.1.0.0 (koz_ross)
23:22:00 * hackage finitary-derive 1.0.0.1 - Easy and efficient Unbox, Storable, Binary and Hashableinstances for Finitary types.  https://hackage.haskell.org/package/finitary-derive-1.0.0.1 (koz_ross)
23:34:00 * hackage finitary 1.1.0.1 - A better, more type-safe Enum.  https://hackage.haskell.org/package/finitary-1.1.0.1 (koz_ross)
23:41:24 <jle`> iqubic: it's only isomorphic for finite traversals :)
23:54:42 <koz_> jle`: Finite things are all the rage. :P
