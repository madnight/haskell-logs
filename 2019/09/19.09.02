00:06:11 <dminuoso> jusss: Your question is flawed.
00:06:21 <dminuoso> % :i Monad
00:06:21 <yahb> dminuoso: class Applicative m => Monad (m :: * -> *) where; (>>=) :: m a -> (a -> m b) -> m b; (>>) :: m a -> m b -> m b; return :: a -> m a; fail :: String -> m a; {-# MINIMAL (>>=) #-}; -- Defined in `GHC.Base'; instance [safe] Monad Q.Gen -- Defined in `Test.QuickCheck.Gen'; instance Monad STM -- Defined in `GHC.Conc.Sync'; instance [safe] forall k (r :: k) (m :: k -> *). Monad (ContT r m) -- Defined
00:06:50 <dminuoso> jusss: Let's, for the sake of discussion, write the instance for just one choice of `e` (this is to avoid confusion regarding type variables)
00:07:01 <dminuoso> Let's pick e to be Int.
00:07:13 <dminuoso> So we'd write `instance Monad ((->) Int where ...`
00:07:16 <dminuoso> jusss: So far with me?
00:09:16 <dminuoso> `instance Monad ((->) Int) where ...` of course
00:49:31 <boxscape> I usually pronounce -> as "to". But how do you pronounce =>?
00:50:32 <dminuoso> % :t fmap
00:50:33 <yahb> dminuoso: Functor f => (a -> b) -> f a -> f b
00:50:44 <opqdonut> when teaching, I pronounce "Class c => t" as "If c is a Class, then t"
00:50:46 <opqdonut> or something like that
00:51:02 <dminuoso> For any choice of types f, a and b, given Functor f, fmap has `type (a to b) to f a to f b`
00:51:03 <boxscape> okay
00:51:30 <boxscape> "given" isn't bad in terms of brevity
00:51:54 <boxscape> bit weird that the order is reversed from where the arrow is, but that's not too bad, I suppse
00:52:34 <simon> I have this function, f :: Foo a => Int -> [a] -> Bool, f x xs = g x xs, and I'd like to extend the Foo type class with a default [a] so that I can write: f :: Foo a => Int -> Bool, f x = g x (defaultXs :: [a]) and call f like 'f x @Something'... mostly to play around with this feature, not because I can honestly defend that it's a good use-case.
00:53:05 <dminuoso> boxscape: It kind of depends on what the perspective is. If you think of `Functor f` as a dictionary, you could actually just say `Functor f to ...` - this sort of works since we could assume the function taking an extra argument for the dictionary of Functor f.
00:53:22 <boxscape> yeah, good point
00:53:23 <dminuoso> boxscape: But I'd say it depends on the situation and what your emphasis is.
00:54:03 <dminuoso> (And it assumes a particular implementation)
00:57:19 <n0v4> hi, i'm tryign to setup intero on windows (to use with haskero + vscode) but having problems: i'm following the guide here https://gitlab.com/vannnns/haskero/blob/master/client/doc/installation.md
00:58:37 <n0v4> i've installed the Haskell Platform for Windows 8.6.5 with stack. in step 2 of the haskero guide it says run the command "stack new my-project new-template"
00:59:02 <n0v4> but this gives an error message: " "C:\\sr\\build-plan\\lts-14.4.yaml" (Response {responseStatus = Status {statusCode = 404, statusMessage = "Not Found"},..."
01:00:06 <n0v4> also that file (lts-14.4.yaml) does not exist on that path
01:19:01 * hackage optics-core 0.1 - Optics as an abstract interface: core definitions  https://hackage.haskell.org/package/optics-core-0.1 (AdamGundry)
01:20:31 * hackage optics-extra 0.1 - Extra utilities and instances for optics-core  https://hackage.haskell.org/package/optics-extra-0.1 (AdamGundry)
01:21:31 * hackage optics-vl 0.1, optics 0.1, optics-th 0.1 (AdamGundry)
01:24:57 <jusss> dminuoso: sorry, I was busy
01:26:34 <jusss> dminuoso: >>= :: (Int->a) -> (a->(Int->b)) -> (Int -> b)
01:26:56 <n0v4> also tried 'stack build intero' and get the same error... tried uninstalling and reinstalling everything, no difference...
01:26:58 <dminuoso> jusss: Alright! Do you see how the question of "what if the second function has 1-arity" does not make sense?
01:27:33 <dminuoso> jusss: >>= demands that its second argument has 2-arity
01:27:43 <dminuoso> At least for that instance.
01:28:33 <jusss> dminuoso: why not Int -> a-> b?
01:28:47 <jusss> (Int->a) -> (Int->a->b) -> (Int->b)
01:28:59 <dminuoso> % :t (>>=)
01:29:00 <yahb> dminuoso: Monad m => m a -> (a -> m b) -> m b
01:29:02 <merijn> jusss: Because that doesn't fit the type signature of >>=
01:29:05 <dminuoso> jusss: Because that's simply how >>= is defined.
01:29:16 <jusss> dminuoso: merijn ok, 
01:29:19 <dminuoso> jusss: If we set `m` to equal `Int ->`, then you cant just flip around things.
01:29:36 <jusss> I wonder what that fits
01:30:05 <jusss> dminuoso: ok
01:30:57 <jusss> but how this connect to Reader
01:31:29 <dminuoso> jusss: Reader is merely a newtype for exactly the same thing.
01:32:12 <jusss> dminuoso: if they're same, what's the point
01:32:34 <merijn> Reader is just a special case of ReaderT
01:32:41 <boxscape> You could ask that about newtypes in general, no?
01:32:55 <dminuoso> jusss: Honestly there's not much of a point to Reader apart from "symmetry". :-P
01:33:11 <dminuoso> boxscape: No, Reader in particularly is not very useful.
01:33:39 <boxscape> hm okay. I admit I've never used it, whereas I've used the ((->) e) instance quite a lot
01:33:41 <dminuoso> Might as well use the instance on `((->) e)` directly. Though I could see Reader perhaps being used to be very explicit about instance selection.
01:36:19 <merijn> And better errors
01:37:54 <boxscape> the errors are made a bit worse though by Reader being defined in terms of ReaderT
02:06:23 <boxscape> So, there's proposals for top level kind signatures and for unsaturated type families. Are there any considerations for allowing something like `type family F :: Type -> Type where F Int = String`? I like how this syntax would mirror term-level function.
02:07:51 <boxscape> (And I'm not really sure why it's not currently allowed, but I assume there's some difficulty in doing so)
02:10:48 <olligobber> I thought all monads could fail, what's this about `Could not deduce (Control.Monad.Fail.MonadFail Data.Functor.Identity.Identity)'
02:11:09 <Taneb> olligobber: not all monads can fail now
02:11:16 <olligobber> :(
02:11:33 <no-n> fail means what here
02:11:50 <Taneb> :t fail
02:11:55 <lambdabot> Monad m => String -> m a
02:11:58 <Taneb> That &
02:12:01 <no-n> oh that
02:12:04 <merijn> olligobber: There's work in progress to move fail out of Monad and into MonadFail (and with the right extension GHC will already do this) so any failable pattern in do notation will infer a MonadFail signature
02:12:11 <olligobber> I'm trying to do something like `do { Just x <- optional }'
02:12:31 <merijn> olligobber: Right, so what would happen if optional is Nothing?
02:12:44 <boxscape> The work is completed in ghc 8.8, isn't it?
02:12:47 <olligobber> I can guarantee it won't be, so I would expect an exception to be raised
02:13:23 <merijn> olligobber: You could just do "fromMaybe (error "whoops!") optional" then
02:14:46 <ClaudiusMaximus> if you love incredibly hard to diagnose bugs, you could try ~(Just x) <- ...
02:14:50 <boxscape> or fromJust if you don't care to give it a descriptive error message
02:15:14 <olligobber> ClaudiusMaximus, what is ~?
02:15:19 <ClaudiusMaximus> > do { ~(Just heh) <- Nothing; heh }
02:15:22 <lambdabot>  Nothing
02:15:32 <no-n> whoa
02:15:43 <ClaudiusMaximus> > do { ~(Just heh) <- pure Nothing; heh }
02:15:46 <lambdabot>  error:
02:15:46 <lambdabot>      • Ambiguous type variables ‘m0’,
02:15:46 <lambdabot>                                 ‘b0’ arising from a use of ‘show_M78655598651...
02:15:47 <merijn> That example is confusing because it doesn't do what you expect :p
02:15:54 <ClaudiusMaximus> > do { ~(Just heh) <- pure Nothing; heh :: String }
02:15:58 <lambdabot>  "*Exception: <interactive>:3:6-32: Non-exhaustive patterns in Just heh
02:16:11 <olligobber> > do { ~(Left x) <- [Right 1]; return x }
02:16:14 <lambdabot>  [*Exception: <interactive>:3:6-27: Non-exhaustive patterns in Left x
02:16:32 <ClaudiusMaximus> mm, it gives th esource location which is better than using fromJust
02:16:48 <boxscape> true
02:17:06 <olligobber> I just made a method to extract the appropriate value which gives a descriptive error when it fails
02:19:14 <boxscape> (you probably made a function rather than a methos, unless it's part of a type class)
02:19:21 <boxscape> s/methos/method
02:26:35 <cpressey> > let q :: [Int] -> Bool ; q = (\xs -> (length xs) == (length $ reverse xs)) in quickCheck (q)
02:26:38 <lambdabot>  error:
02:26:38 <lambdabot>      • Couldn't match expected type ‘Test.QuickCheck.Random.QCGen’
02:26:38 <lambdabot>                    with actual type ‘[Int] -> Bool’
02:27:09 <cpressey> ^ Is lambdabot's QuickCheck support incomplete? This works for me when I try it locally.
02:30:01 <Taneb> :t quickCheck
02:30:03 <lambdabot> STestable prop => Test.QuickCheck.Random.QCGen -> prop -> String
02:30:29 <cpressey> *Main> :t quickCheck
02:30:31 <cpressey> quickCheck :: Testable prop => prop -> IO ()y
02:30:39 <cpressey> s/y//
02:31:12 <Taneb> I think it's to work around lambdabot not doing IO
02:31:51 <cpressey> Ah
02:32:21 <cpressey> That makes some sense then, thanks.
02:43:44 <tdammers> does anyone know if Cabal 3 introduced new checks that make it stricter in terms of selecting viable package versions? A project I'm working on that built cleanly with 2.4 no longer builds unless I relax some constraints
02:45:44 <dminuoso> tdammers: What exact issue are you getting?
02:49:18 <tdammers> cabal reports conflicts between the main project and the unix and process libraries
02:49:47 <tdammers> (well, and the test suite)
02:50:08 <merijn> tdammers: Are you running build or test?
02:50:11 <tdammers> build
02:50:14 <tdammers> with --enable-tests
02:50:24 <tdammers> specifically, v2-build
02:51:15 <merijn> tdammers: I don't think anything changed that could break an existing build, but did you by any chance run update between building with 2.4 and 3.0?
02:51:34 <tdammers> yes, I nuked all of ~/.ghc and ~/.cabal and did a fresh install of cabal-install
02:52:17 <merijn> tdammers: Then it sounds like something doesn't have a proper upper bound and you got a newer version from Hackage that's breaking your build-plan
02:52:18 <tdammers> it's just that I'd expect cabal to still find the solution it had before - a newer hackage shouldn't lead to a previously solvable situation to become unsolvable, right?
02:52:54 <tdammers> interestingly, downgrading the lower bound for bytestring from 0.10.8 to 0.10.0 allows it to build
02:54:17 <tdammers> also, shouldn't cabal downgrade packages all the way down to the lower bound in order to find a solutioN?
02:54:29 <maerwald> tdammers: you are using a freeze file?
02:54:42 <tdammers> maerwald: nope
02:54:59 <tdammers> I'm developing a library, I don't want to lie to myself
02:55:30 <merijn> tdammers: Up until max-backjump, yes
02:55:39 <maerwald> well, the only thing that can introduce those problems are hackage revisions I think
02:56:10 <tdammers> merijn: aaaah, maybe that's the problem then
02:56:22 <tdammers> although, no, it doesn't say "max backjumps reached"
02:56:24 <tdammers> hmm
02:56:55 <merijn> tdammers: pastebin the error?
02:57:25 <merijn> But yeah, a revision could break that, but generally revisions are/should be only when the existing situation was already broken anyway
03:00:05 <tdammers> http://tdammers.ignorelist.com/tobias/cabal-build-fail-2019-09-02.txt
03:43:03 <yorick> hvr: can you update packunused on hackage?
03:43:09 <libertyprime> hey guys :) could someone please help me to write a simple function? given two strings i need to ensure that the second string contains the same number of 'trailing' line endings as the first. basically, I need something which reverses a possible string chomp
03:44:15 <yorick> phadej: can you put servant-client-ghcjs on hackage?
03:55:15 <olligobber> I was about to ask a question and then realised the answer is `mapM'
03:57:51 <boxscape> hm I only now realized that traverse and mapM are basically the same thing. Seems unfortunate that the names are so different (compare with `for` vs `forM`)
03:59:54 <boxscape> also seems strange that traverse_ is defined in Data.Foldable rather than in Data.Traversable
04:02:35 <Taneb> boxscape: traverse_ only needs a Foldable constraint on the container :)
04:05:10 <lavalike> > (curry $ uncurry (\n -> map (++ replicate n '\n')) . first getMax . uncurry (<>) . join (***) ((Max . length *** ((:[]) . reverse)) . span ('\n'==) . reverse)) "foo\n\n" "bar\n\n\n\n"
04:05:12 <lambdabot>  error:
04:05:13 <lambdabot>      Variable not in scope: getMax :: b0 -> Interror:
04:05:13 <lambdabot>      • Data constructor not in scope: Max :: Int -> b0
04:09:30 <lavalike> > (curry $ uncurry (\n -> map (++ replicate n '\n')) . first getMax . uncurry (<>) . join (***) ((Max . length *** ((:[]) . reverse)) . span ('\n'==) . reverse)) "foo\n\n" "bar\n\n\n\n"
04:09:33 <lambdabot>  ["foo\n\n\n\n","bar\n\n\n\n"]
04:09:48 <boxscape> Taneb oh, good point
04:30:20 <olligobber> the magic of monads: `eqMapping = (!) . (startEqTable >>= (flip solveTable) >>= (flip convertTable))'
04:32:53 <yorick> mikolaj: could you push the threadscope version bumps to hackage?
04:46:08 <yorick> int-e: could you update the quickcheck bound on term-rewriting?
04:47:14 <yorick> actually, PR'd
05:00:01 <rsoeldner> Morning, for my servant server I would like to add a "current system monitor" endpoint showing current cpu usage, used memory of the entire machine, hdd space, ... is there some existing package which provides this information with a single call ?
05:00:24 <jgt> rsoeldner: that doesn't sound like a Haskell-specific thing
05:00:24 <alp> rsoeldner, you might want to look into servant-ekg
05:00:38 <jgt> rsoeldner: you probably want to look at collectd
05:01:45 <dminuoso> collectd, node_exporter for prometheus..
05:02:34 <rsoeldner> thanks guys :)
05:03:33 <hoppfull> In PureScript I can define in a type that I require a record that atleast has a certain member, then that type will match on all records with that type. Can we do the same in Haskell?
05:06:40 <tdammers> hoppfull: Haskell doesn't have extensible records built into it like that, but there are a few packages out there that try to approach this with minimal boilerplte
05:08:18 <pigmej[m]> what's best resource to read about concurrent and parallel haskell nowadays?
05:08:45 <hoppfull> tdammers: So the feature is called "extensible records"?
05:09:30 <merijn> pigmej[m]: Simon Marlow's book
05:09:38 <merijn> pigmej[m]: "Parallel and Concurrent Haskell" ;)
05:10:03 <olligobber> hoppfull, I think generic types might be able to help you to do this in haskell
05:10:05 <pigmej[m]> 2013 still up to date?
05:10:14 <tdammers> hoppfull: yes
05:10:23 <merijn> pigmej[m]: Not much has fundamentally changed
05:10:32 <pigmej[m]> oki, thx ;)
05:10:39 <hoppfull> On this page are a couple of examples under "Record Patterns" https://github.com/bjornkihlberg/PureScript-Tutorials
05:10:40 <yorick> joeyh: could you relax the 'github' constraint on github-backup?
05:11:19 <merijn> pigmej[m]: The API of the async library might have changed a bit, but the various primitives in base/stm haven't
05:11:34 <pigmej[m]> oki
05:11:39 <pigmej[m]> thx ;)
05:24:57 <olligobber> merijn, I finished my implementation of unionfind in haskell: https://gist.github.com/olligobber/f2b3f172c6a88c0f93ed560ea48fdfc5
05:26:04 <olligobber> unionfind is a very mutable data type, so the State monad was very useful
05:29:02 <myname_> hi
05:31:09 <uzver> hi
05:31:44 <olligobber> hi
05:32:44 <uzver> What is the general advice on when to use MonadIO m over IO? Looking to avoid liftIO boilerplate in application code
05:47:15 <dmj`> no easy way around it, you can alias "liftIO" to "io" and cut down on a few characters
05:54:23 <int-e> yorick: I think so...
05:54:58 <yorick> int-e: https://github.com/haskell-rewriting/term-rewriting/pull/15
06:00:00 * hackage rattletrap 9.0.2 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-9.0.2 (fozworth)
06:01:00 * hackage term-rewriting 0.4.0.2 - Term Rewriting Library  https://hackage.haskell.org/package/term-rewriting-0.4.0.2 (BertramFelgenhauer)
06:01:27 <int-e> yorick: ^^ (Oh, forgot the changelog. oh well, it's not a big change.)
06:02:03 <yorick> int-e: great! :)
06:02:08 <yorick> I guess it could've been a cabal revision
06:02:30 <int-e> True.
06:02:52 <int-e> Too late for that now :)
06:04:16 <int-e> yorick: Thanks to you too!
06:07:45 <boxscape> Are there ghc versions that end in odd numbers? Like internal development versions or something?
06:09:41 <jgt> boxscape: I'm using 8.4.3
06:10:12 <boxscape> ok sorry I should have clarified that I mean the.. I think it's called minor version? The second number
06:10:39 <jgt> https://downloads.haskell.org/~ghc/7.0.3/docs/html/users_guide/version-numbering.html
06:11:12 <boxscape> (ok turns out the first two numbers together are called the major version)
06:11:16 <boxscape> thanks jgt
06:28:21 <Guest_97> Hello I was trying to install and got the following error message
06:28:23 <Guest_97> Installing GHC-8.6.5 for Darwin on architecture x86_64  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                 Dload  Upload   Total   Spent    Left  Speed100  151M  100  151M    0     0  12.9M      0  0:00:11  0:00:11 --:--:-- 12.3Mchecking build system type... x86_64-apple-darwin18.7.0checkin
06:28:24 <Guest_97> g host system type... x86_64-apple-darwin18.7.0checking target system type... x86_64-apple-darwin18.7.0Build platform inferred as: x86_64-apple-darwinHost platform inferred as: x86_64-apple-darwinTarget platform inferred as: x86_64-apple-darwinGHC build  : x86_64-apple-darwinGHC host   : x86_64-apple-darwinGHC target : x86_64-apple-darwinLLVM targe
06:28:24 <Guest_97> t: x86_64-apple-darwinchecking for path to top of build tree... /var/folders/53/h3xxpg7x78d4lcm32kv0sdhw0000gn/T/tmp.OLkgXtfh/ghc-8.6.5checking for perl... /usr/bin/perlchecking for a BSD-compatible install... /usr/bin/install -cchecking for gfind... nochecking for find... /usr/bin/findchecking whether ln -s works... yeschecking for gsed... sedchec
06:28:24 <Guest_97> king XCode version... xcode-select: error: tool 'xcodebuild' requires Xcode, but active developer directory '/Library/Developer/CommandLineTools' is a command line tools instancenot found (too old?)checking for gcc... gccchecking whether the C compiler works... noconfigure: error: in `/var/folders/53/h3xxpg7x78d4lcm32kv0sdhw0000gn/T/tmp.OLkgXtfh/gh
06:28:25 <Guest_97> c-8.6.5':configure: error: C compiler cannot create executablesSee `config.log' for more detailsFailed to install, consider updating this script via: ghcup upgrade"ghcup --cache install" failed!
06:28:47 <Guest_97> I'm a bit of a noob van anyone help?
06:28:50 <hyperisco> Guest_97, please use a paste service such as Gist or pastebin instead of flooding the channel.
06:29:05 <Guest_97> sorry
06:29:54 <Guest_97> https://pastebin.com/TnDQTfZz Here's the pastebin
06:30:30 * hackage shakespeare 2.0.21 - A toolkit for making compile-time interpolated templates  https://hackage.haskell.org/package/shakespeare-2.0.21 (MichaelSnoyman)
06:32:21 <hyperisco> I haven't a clue, but it does say this:  Failed to install, consider updating this script via: ghcup upgrade
06:33:29 <hyperisco> Also it had an error finding a suitable XCode install. Perhaps updating the install script will fix that though. Or maybe changing XCode version will fix that.
06:33:48 <hyperisco> Been a long time since I did anything on a Mac but I do recall that XCode is extremely finnicky.
06:38:01 <merijn> Guest_97: Did you install the commandline tools?
06:38:18 <merijn> Just XCode is not sufficient
06:38:25 <Guest_97> No sorry didn't realise I needed that first
06:38:29 <Guest_97> I'll try now!
06:38:51 <merijn> Guest_97: Running "xcode-select --install" in the terminal should give you a popup to install them
06:39:30 <Guest_97> this is looking like it's done the trick
06:39:53 <Guest_97> should I try haskell again from the original command line?
06:40:50 <tabaqui1> I declared "-Werror" in stack.yaml in ghc-options: $targets and "-Wwarn" in specific package.cabal
06:40:56 <merijn> Personally I always just use the GHC bindist to install on macOS, but not everyone is enough of a stubborn commandline person to do that :)
06:40:58 <tabaqui1> but stack install ignores -Wwarn
06:41:21 <tabaqui1> but if I run "stack install --ghc-options -Werror --ghc-options -Wwarn" then it will uses the second one
06:41:48 <tabaqui1> oh, ok, looks like ghc always takes the last one
06:42:14 <tabaqui1> and stack appends its flags instead of prepend
06:44:16 <Guest_97> "Installation done!"
06:44:21 <Guest_97> Thanks you set of legends
06:47:14 <boxscape> https://pvp.haskell.org/ says to have a major version bump whenever behavior is changed. Does that include bug-fixes, which technically change the behavior but don't change the intended/documented behavior?
06:47:47 <maerwald> merijn: what is that xcode-select --install thing?
06:48:34 <maerwald> boxscape: if the old behavior was a bug, then the bugfix doesn't really "change behavior", but fixes wrong behavior (and so now aligns with what is 1. documented and 2. expected), no?
06:49:19 <boxscape> I'd say every fix is necessarily a change
06:49:33 <boxscape> it
06:50:05 <boxscape> it's not impossible that someone relied on an undocumented bug, so it seems like every bugfix is potentially a breaking change
06:50:32 <maerwald> undocumented is different from "behavior that doesn't align with documentation and that I'm going to fix now"
06:50:46 <boxscape> that's fair
06:52:25 <merijn> maerwald: It installs the xcode command-line tools
06:52:43 <maerwald> merijn: and what happens then?
06:52:57 <maerwald> is that something everyone wants to do who wants to install ghc?
06:53:09 <merijn> maerwald: The default xcode install only installs stuff you need to develop with xcode directly, so there's no linkers, compilers, etc. available in your terminal
06:53:16 <hyperisco> I'd do a major version bump, so long as it was possible to build beforehand.
06:53:35 <hyperisco> There is no universal agreement on how version numbers should work though, so.
06:53:49 <merijn> maerwald: Yes, but you can't easily script it, because it runs GUI code that requires user interaction, which ghcup (afaik) explicitly does not want
06:54:26 <maerwald> merijn: correct, but it could be documented here: https://gitlab.haskell.org/haskell/ghcup/blob/master/.requirements/ghc/darwin
06:54:49 <maerwald> it seems "in the course of running ghcup you will be given a dialog box to install the command line tools" doesn't apply for everyone on mac?
06:55:12 <merijn> maerwald: That note suggest it should already be running xcode-select --install, no clue why it didn't work then
06:56:29 <boxscape> hyperisco do you mean agreement about whether or not to adhere to Haskell PVP in its current form, or agreement about what it should say, or agreement about details that it leaves out?
06:58:41 <hyperisco> boxscape, case in point: if you take it literally, you require a major version bump. Yet you just received advise to the contrary. So, there is no universal agreement, despite a standards document.
06:58:59 <boxscape> ok, I see
06:59:09 <maerwald> no one advised against it
06:59:18 <maerwald> it depends on the circumstances exactly
07:00:27 <hyperisco> Your exemption is not part of the PVP
07:01:15 <boxscape> (FWIW this is a hypothetical, I'm not actually maintaining any hackage packages, it's just something I got curious about while reading the PVP)
07:01:28 <maerwald> hyperisco: that is obvious :)
07:03:32 <maerwald> if you do a major bump, you're more likely to not distribute your bugfix, because people still believe upper bounds are a good thing ;)
07:04:54 <boxscape> that makes sense
07:05:12 <hyperisco> Every discussion about version numbers leads me closer to package sets
07:06:30 <maerwald> I think worrying about people relying on the opposite of documented behavior is less important than worrying about people getting the bugfix. The decision is harder about *undocumented* behavior though. I guess in C-world people are more radical about it and would say "scre 'em".
07:07:16 <hyperisco> I dunno, I think Linus has a strong word for you.
07:07:41 <maerwald> I think he got better after therapy, no?
07:08:03 <maerwald> and relying on UB was never a good idea :)
07:08:28 <maerwald> but yeah, undocumented and undefined isn't the same, heh
07:08:29 <maerwald> or is it...
07:09:57 <boxscape> intuitively I would say "undocumented" refers to a detail of an implementation that's not in the documentation, whereas "undefined" is just a statement about the documentation without referring to the actual implementation
07:10:04 <maerwald> would you do a major version bump if one of your IO functions might now throw a new exception?
07:10:50 <maerwald> (I would)
07:10:56 <boxscape> I think so
07:11:25 <maerwald> but... do you document your exceptions?
07:12:18 <boxscape> That sounds like a good idea? Tbh I haven't really had to use eceptions much in haskell so I don't know how people usually do it
07:12:33 <boxscape> s/eception/exception
07:13:33 <maerwald> Most people don't document them
07:13:39 <boxscape> I see
07:13:52 <maerwald> Some base packages do (such as directory)
07:19:21 <Brekker> Hey guys, I'm sorting a large list of Doubles (~65000 elements) and it seems to take an extremely long time (a couple minutes). Is this normal or am I doing something wrong?
07:24:32 <dminuoso> Brekker: Did you profile your code?
07:24:37 <dminuoso> With RTS instrumentation that is.
07:24:52 <holygril> hi
07:26:23 <sm[m]> Brekker: did you write your own sorting function ?
07:26:50 <merijn> List is pretty bad for sorting anyway
07:27:12 <merijn> maerwald: People who don't document their exceptions are scum >.<
07:27:30 <merijn> maerwald: Also, people who don't create a hierarchy for all exceptions corresponding to their library are too >.<
07:28:08 <merijn> Control.Exception actually supports some pretty complex inheritance like hierarchies of exceptions, but almost no one ever uses it >.>
07:29:23 <boxscape> Is Data.List.sort in O(nlogn)?
07:29:39 <Brekker> dminuoso: No, I'll do so now
07:29:45 <merijn> boxscape: Yes, no, maybe
07:29:48 <Brekker> sm[m]: I'm using Data.List.sort
07:29:53 <boxscape> Ah, okay :)
07:29:57 <merijn> boxscape: Oh, I forgot the crucial "It Depends (TM)"
07:30:15 <merijn> boxscape: Big O notation is a giant lie so the truth on that statement depends on whether you believe the lie
07:30:26 <Brekker> dminuoso: I do know that it's the sort however
07:30:29 <boxscape> I see
07:30:47 <Brekker> dminuoso: If it helps, the Doubles are around 15 decimal places
07:31:44 <dminuoso> Brekker: Without knowing the code, and ideally seeing good cost center information, it's not worth my time to guess what's wrong.
07:31:55 <monochrom> dminuoso++
07:32:15 <merijn> Brekker: Doubles have a constant size, there is no "number of decimal places"
07:32:33 <sm[m]> Then, “minutes” doesn’t sound normal to me. It takes no time in GHCI here (sorting 65000 1’s)
07:32:34 <monochrom> Unfortunately the only reason most people are on IRC is precisely because they have too much time, so they feel like perpertually speculating.
07:32:47 <boxscape> sort by itself definitely shouldn't take a couple minutes though, with 65k Doubles. Not even a couple seconds.
07:33:43 <boxscape> (oops I missed sm[m] message)
07:36:45 <sm[m]> It sounds like the slowness is not where you think. Profiling is good, but sometimes throwing in some Debug.trace statements is quicker
07:37:39 <Brekker> I'll run a profile with RTS and throw in some Debug.trace statements and get back to you if I can't figure it out :) thanks for the help guys
08:10:00 <AWizzArd> Anyone here who is doing Scrum and is using Jira? Possibly for some Haskell-related project.
08:14:16 <bolver> this code let g x = print . sqrt x throws Non type-variable argument in the constraint: Floating (a -> a)
08:14:25 <Brekker> So haskell's lazy evaluation made me *think* it was the sort that was slow. I'm still kinda new to this lol
08:14:39 <dminuoso> bolver: Indeed.
08:14:46 <dminuoso> bolver: What type does g have?
08:14:52 <dminuoso> bolver: Or rather, what do you think it does?
08:15:10 <bolver> and reports g's inferred type as g :: forall a a1. (Floating (a -> a1), Show a1) =>  (a -> a1) -> a -> IO ()
08:15:39 <bolver> i know how to fix it, but i would like to understand why it has this type for g
08:15:44 <geekosaur> bolver: do you know what . does?
08:15:50 <monochrom> Shouldn't it be print (sqrt x) ?
08:15:55 <bolver> how to fix the code
08:16:21 <bolver> i know that, but i want to understand the error message
08:16:25 <geekosaur> :t (.)
08:16:27 <lambdabot> (b -> c) -> (a -> b) -> a -> c
08:17:13 <bolver> g's type should g :: a -> IO ()
08:17:39 <merijn> bolver: How many argument does sqrt take?
08:17:46 <bolver> 1
08:18:12 <merijn> bolver: Right, so how many arguments does "sqrt x" take?
08:18:40 <bolver> none
08:19:25 <merijn> bolver: That one is actually a trick question whose answer is "it depends"
08:19:31 <merijn> :t sqrt
08:19:33 <lambdabot> Floating a => a -> a
08:19:48 <bolver> yes
08:20:09 --- mode: monochrom set -o monochrom
08:20:51 <merijn> bolver: sqrt returns a value whose type is an instance of Floating. The right hand side of (.) wants a function. Inference dumbly fills in the holes and goes "well, this has to be an instance of Floating *and* a function"
08:21:33 <bolver> ok
08:22:16 <merijn> bolver: Of course there is no Floating instance for functions, hence you get the error that there's no instance "Floating (a -> a)" (well, the actual error seems like it's complaining that "Floating (a -> a)" isn't a valid constraint, because FlexibleContexts isn't enabled
08:22:22 <dminuoso> bolver: Function application has highest precedence, so that associates as "print . (sqrt x)
08:22:33 <dminuoso> bolver: And then type inference happens
08:22:37 <dminuoso> % :t (.)
08:22:37 <yahb> dminuoso: (b -> c) -> (a -> b) -> a -> c
08:22:39 <bolver> yes
08:22:55 <merijn> bolver: If you enable FlexibleContexts I'm fairly sure the resulting error will become "no instance Floating for (a -> a1)"
08:23:05 <dminuoso> With a bit of handwaving, it tries to unify `_a -> _b` with the type of (sqrt x)
08:23:36 <dminuoso> % :t sqrt
08:23:36 <yahb> dminuoso: Floating a => a -> a
08:23:44 <bolver> yes
08:24:15 <bolver> i see
08:26:37 <bolver> i see -- i got it now
08:26:57 <bolver> i forgot to look at the type of (.)
08:28:01 <dminuoso> bolver: The general protocol for type checking is: instantiate tyvars with ridigs, instanciate tyvars in used identifiers with unifications, solve equations.
08:28:33 <dminuoso> bolver: The idea is that, if you make a mistake, then some of these equations wont line up - so at some point the type checker doesnt procoeed and just stops.
08:29:26 <dminuoso> Sometimes, it errors out not at the source of the mistake, but rather at some remote part.
08:29:40 <bolver> i see 
08:29:54 <bolver> that was the problem
08:30:11 <bolver> the erroring out at some 'remote' part
08:30:47 <dminuoso> bolver: its sort of how if you construct something with lego and make a mistake, that single mistake might translate into many other errors in your final build. :)
08:30:51 <bolver> what ar ridigs, btw?
08:31:11 <bolver> yeah
08:31:13 <dminuoso> bolver: So a type variable can be thought of "the consumer can freely pick this"
08:31:16 <dminuoso> Right?
08:31:23 <bolver> yes
08:31:24 <dminuoso> So its sort of like an argument that the consumer has to supply.
08:31:32 <bolver> yes
08:31:33 <dminuoso> Which means, the consumer has the freedom to pick anything.
08:31:37 <dminuoso> now take the implementors perspective
08:31:40 <bolver> correct
08:31:48 <dminuoso> for *him* that same type variable behaves different
08:31:55 <dminuoso> its some rigid/concrete, but unknown, type
08:32:12 <bolver> i see
08:33:11 <bolver> ah, i see -- i think you had a typo before -- you meant "rigid"
08:33:21 <dminuoso> Oh.
08:33:42 <dminuoso> bolver: Rigids can be observed and played with using ScopedTypeVariabels by the way
08:33:55 <bolver> i see
08:34:31 <dminuoso> bolver: If you reuse a type variable from an outer scope, that type variable is completely rigid. You cant grab that outer `a` and turn it into Int because its rigid (its some type we dont know, because our caller/consumer is going to pick it)
08:34:43 <dminuoso> % :set -XScopedTypeVariables
08:34:43 <yahb> dminuoso: 
08:35:46 <bolver> yeah, i will check it out
08:35:54 <dminuoso> % let f :: forall a. a f = g where g :: a; g = (1 :: Int)
08:35:55 <yahb> dminuoso: ; <interactive>:48:5: error:; * You cannot bind scoped type variable `f' in a pattern binding signature; * In the pattern: f :: forall a. a f; In a pattern binding:; f :: forall a. a f; = g; where; g :: a; g = (1 :: Int); <interactive>:48:26: error:; * Couldn't match expected type `forall (a1 :: k -> *). a1 f' with actual type `a'; 
08:36:04 <dminuoso> % let f :: forall a. a; f = g where g :: a; g = (1 :: Int)
08:36:04 <yahb> dminuoso: ; <interactive>:49:48: error:; * Couldn't match expected type `a' with actual type `Int'; `a' is a rigid type variable bound by; the type signature for:; f :: forall a. a; at <interactive>:49:5-20; * In the expression: (1 :: Int); In an equation for `g': g = (1 :: Int); In an equation for `f':; f = g; where; g :: a; 
08:36:21 <dminuoso> bolver: ^- there. From the inner scope `a` is rigid (sometimes also called a skolem type variable)
08:38:35 <bolver> i see
08:43:13 <bolver> thanks, btw
09:25:00 * hackage inspection-testing 0.4.2.2 - GHC plugin to do inspection testing  https://hackage.haskell.org/package/inspection-testing-0.4.2.2 (JoachimBreitner)
09:47:21 <AWizzArd> Is there a version of Show for Text, without adding any dependency?
09:48:13 <AWizzArd> And second question: is there some special magic that the compiler can perform to make (pack . show) very efficient to translate some  a -> Text ?
09:50:16 <EvanR> the efficiency would have to come from not using the String renderers at all
09:50:38 <EvanR> i.e. using direct Text rendering, and probably via a builder
09:51:09 <EvanR> the compiler can't just generate all that code for each type because it has a String shower
09:51:20 <AWizzArd> EvanR: yeah, thought so - if I first have to create a list of Char values and then make a Text out of it, then that’s a lot of unnecessary work.
09:52:03 <AWizzArd> EvanR: I thought tho that there might be a type class that comes to the rescue.
09:52:12 * EvanR plays the "Show is ultimately for debugging and not production code" card
09:52:16 <AWizzArd> I only see such classes in explicit dependencies.
09:52:36 <AWizzArd> EvanR: yes, that’s fine.
09:52:48 <EvanR> basically you need something like those HTML renderer libs
09:53:31 <AWizzArd> I just wanted to derive RenderText and have a showText and be done (:
09:54:28 <EvanR> that probably exists in the form of generics
09:55:09 <AWizzArd> EvanR: yes, inside some dependencies. And I guess this is what I have to do, using such a dep.
09:55:56 <EvanR> or you could write all the deriving code yourself ? : )
09:56:35 <EvanR> is the Text speedup worth it?
09:57:07 <AWizzArd> EvanR: btw, when using OverloadedStrings with string literals - will the compiler place literal Text values in the compiled code?
09:58:42 <EvanR> that is based on the IsString class 
09:59:11 <EvanR> the code that converts a String to whatever must run at runtime
09:59:17 <EvanR> i mean, in general
09:59:42 <EvanR> i'm not sure how you could optimize it away
10:01:00 <AWizzArd> EvanR: by running it at compile-time.
10:01:08 <EvanR> you could solve the halting problem, analyze the implementation of IsString, see that it computes something and just put the answer in the code
10:01:43 <EvanR> but even if you did that, your implementation for Text uses the text library, pretty complex and based on primitives
10:01:44 <AWizzArd> EvanR: it should be possible to create a Text literal "abc" at compile time.
10:02:09 <EvanR> i agree, but i don't see how it would work with haskell / ghc as it is
10:02:20 <AWizzArd> `foo "abc"`   with   foo :: Text -> Int
10:02:22 <EvanR> the same issue exists with numeric literals
10:02:32 <EvanR> they are Integers at heart, then converted, with code
10:03:15 <Ariakenom> or Rationals
10:03:32 <EvanR> with OverloadedStrings, foo "abc" is equivalent to foo (fromString "abc") where "abc" is a String
10:03:38 <EvanR> then compiled
10:04:26 <AWizzArd> Yes, though why can't this be done at compile time already, and the (fromString "abc") get's replaced by a literal Text value?
10:04:33 <geekosaur> hypothetically something could deteremine its monomorphic and generate a literal in-place. it's occasionally discussed
10:04:52 <geekosaur> it's a fair amount fo work but doable with a plugin… then someone has to maintain said
10:05:00 <EvanR> fromString "abc" elaborates into the raw code to convert "abc" to Text
10:05:13 <geekosaur> because Text is not a built-in type with literal values the compiler knows anything about
10:05:15 <EvanR> you could introduce a special case for Text i guess
10:05:44 <EvanR> you trust the Text library to not crash or freeze
10:05:51 <AWizzArd> Isn't it possible for an extension to discover at compile time which concrete type is required, such as Text? And then instead of placing a fromString call there it inserts the literal?
10:05:52 <EvanR> run it at compiled time, if thats even a thing
10:06:19 <AWizzArd> Text might be a lib that is widely used.
10:06:37 <EvanR> i mean, a string type that works sanely as part of the language would be nice
10:06:45 <AWizzArd> EvanR: +1
10:07:23 <EvanR> but i also see the advantages of having text be a library that can be swapped out or fixed
10:08:14 <EvanR> laziness should render the finite number of fromString whatevers in your code a one-time cost?
10:08:45 <AWizzArd> The JVM has done some awesome amount of work. Internally they have multiple types, hidden from the user. They analyse if all chars in a string are latin1, and if that is the case (code analysis showed that this IS the case) they can use the more efficient implementation.
10:09:21 <AWizzArd> https://www.baeldung.com/java-9-compact-string
10:09:35 <EvanR> that sounds like some dark magic that i would expect to obliterate my soul as i trusted it
10:10:28 <AWizzArd> EvanR: nah, it works very stable. The effect is just that working with Strings takes much less memory and is faster.
10:10:52 <EvanR> what happens when a latin1 secretly optimized string collides with a string containing unicode, but the programmer thinks of them as the same
10:11:09 <EvanR> all optimizations in history disappear?
10:11:21 <EvanR> everything explodes?
10:11:47 <EvanR> additional cost is introduced?
10:12:04 <AWizzArd> EvanR: If you compare those they can't be the same, such as a Text is never == to some String. And otherwise: additional costs.
10:12:10 <geekosaur> it being java, they're the same type / autocoerced / such magic
10:12:53 <AWizzArd> On the surface they are the same, but internally they are byte[] vs char[].
10:13:00 <EvanR> stepping for the moment into free form land, since when is Text never equal to a String
10:13:10 <EvanR> value wise
10:13:34 <AWizzArd> And the thing is: in practice it simply doesn't occur often. I know about some tree/trie implementations that are backed by arrays for up to, say, 10 elements, and only then use a tree representation.
10:14:19 <AWizzArd> The data store gets translated under the hood, by the implementation. Very small maps/trees are really efficient. Quick enough to traverse (up to) 10 cells in an array.
10:15:22 <AWizzArd> It was well worth to improve on Strings, because benchmarks of production apps showed that 30+ percent of memory is storing Strings.
10:16:04 <EvanR> this lesson supports a language's string just being implemente as a utf8 blob
10:17:58 <EvanR> back to wrecklessly running the code at compile time, does java do this?
10:18:21 <AWizzArd> Hmm, I think they can't do this.
10:18:36 <AWizzArd> Clojure can do it, via macros, and that compiles to byte code.
10:18:57 <EvanR> the programmer is doing it on purpose in clojure though
10:19:04 <AWizzArd> exacto
10:19:28 <EvanR> with extra information available to the compiler, just running stuff at compile time could really do cool stuff
10:19:30 * hackage doctemplates 0.6 - Pandoc-style document templates  https://hackage.haskell.org/package/doctemplates-0.6 (JohnMacFarlane)
10:19:57 <EvanR> but most people don't have that info
10:20:07 <AWizzArd> I noticed though that many macros were just used to introduce lazyness, and you wouldn't need them in Haskell.
10:34:10 <cowsAndBulls> Hi, I am a haskell beginner. To teach myself, I code a version of cows and bulls (aka mastermind) but my code is very slow. I wonder if anyone is interested in discussing the code
10:34:56 <jgt> cowsAndBulls: ask your question and post a gist/pastebin to the code
10:34:58 <dmwit> You could paste it online and send us a link.
10:35:22 <dmwit> I don't promise to help, but people are generally pretty friendly towards doing code reviews if the code isn't, like... a 1M-line production codebase or something.
10:35:51 <AWizzArd> https://books.goalkicker.com/HaskellBook/
10:35:54 <cowsAndBulls> cool... thanks, the code is 143 lines, but a bunch of those lines are just comments
10:36:13 <EvanR> yeah you may have a memory leak of sorts, which can slow things down
10:36:44 <jgt> EvanR: how did you guess that without seeing any code?
10:38:57 <EvanR> i didn't guess it yet, i might be wrong
10:43:48 <cowsAndBulls> I am not sure if i did this right, but
10:43:49 <cowsAndBulls> https://repl.it/repls/AdmirableGoldenrodExternalcommand
10:46:35 <koz_> That URL is hilarious.
10:46:46 <koz_> 'Admirable golden rod' lol.
10:47:18 <cowsAndBulls> i guess it is a random name given by the online compiler
10:50:03 <EvanR> Goldenrod, a standard videogame flower
10:55:23 <dmwit> cowsAndBulls: I would make the base case of wordToList 0 rather than 1.
10:55:37 <dmwit> I'd consider checking it via pattern matching rather than guards, too.
10:56:15 <dmwit> You write `[x] ++ blah`. This is fine, because GHC is smart; but keep in mind that the idiomatic way (and the thing GHC will actually put in its generated code) is `x : blah`.
10:57:58 <dmwit> cowsAndBulls: I have not attempted to run the code.
10:58:49 <sim590> In this small code: https://paste.debian.net/1098431/, I recover a double number from IO. I wanted to avoid to use an unsed named binding (mbNbr). I have commented the version of the region where I would use it and put the best alternative I have found. Is there another way? My concern is that I'm using too many language extension while it may not be mandatory.
10:58:59 <cowsAndBulls> got it, i just created a main function, so if you run it, it is supposed to give you the average number of guesses to find a word with 6 symbols and length 4
10:59:02 <dmwit> cowsAndBulls: getCluePartial looks like it's basically duplicating the logic of wordToList.
10:59:25 <dmwit> cowsAndBulls: I would recommend calling wordToList, then iterating over the list it produces, instead.
10:59:42 <dmwit> (e.g. pass it in from getClue)
10:59:56 <cowsAndBulls> i only  use wordToList for visualization purposes... in general, working with ints should be faster than with the list
11:00:37 <aisn> how would i go about tracking state from a callback function, the type of which i cannot modify as i'm using it with a library?
11:00:43 <dmwit> cowsAndBulls: How do you know this?
11:01:19 <dmwit> aisn: IORef or similar?
11:01:23 <cowsAndBulls> i have coded the same program in python and c++, and when i use list there it is slower than using ints
11:01:44 <aisn> i read somewhere that IORef is considered hacky - is that true?
11:01:46 <cowsAndBulls> though, i don't know if the haskell compiler works differently
11:02:15 <dmwit> Exactly.
11:02:47 <dmwit> aisn: It is almost certainly true. Damn near all opinions are held by somebody somewhere.
11:03:53 <aisn> i guess i will try this option as i don't really have any other ideas
11:08:19 <dmwit> cowsAndBulls: Ooof, that getAverageGuesses is... rough.
11:09:28 <cowsAndBulls> dmwit: yes, it has to try all possible secret words to see how long does the guesser take to discover the word, and then average it
11:10:00 <dmwit> Yes, but the way you do it is awful.
11:10:21 <cowsAndBulls> dmwit: hmmm, any suggestions?
11:10:55 <dmwit> You 1. pick a number of guesses, 2. recompute the number of guesses it takes for each secret, 3. count the number of secrets that take that number of guesses, 4. multiply the guess count by the number of secrets that require that many guesses.
11:11:21 <dmwit> Instead, why not 1. compute the number of guesses it takes for each secret, 2. add up all the numbers in that list.
11:11:26 <Ariakenom> aisn: to clarify. dmwit doesn't hold that opinion and probably doesn't know anyone who does. same for me
11:11:44 <dmwit> aisn: What Ariakenom says is correct.
11:13:02 <cowsAndBulls> dmwit: i don't think i follow
11:13:31 <dmwit> cowsAndBulls: Let's say the secrets are 1,2,3,4. And let's say it takes 5, 7, 3, 9 guesses, respectively, for each of those secrets.
11:13:42 <cowsAndBulls> dmwit: yes
11:14:04 <dmwit> cowsAndBulls: Your algorithmi is: iterate over 1,2,3,4,5,6,7,8,9. Name the current number we're iterating over x.
11:14:38 <dmwit> In this iteration, compute [5,7,3,9]. Then keep the zero or one elements of [5,7,3,9] that is equal to x. Then multiply x by 0 or 1.
11:15:01 <cowsAndBulls> i got it... yes that should improve the computation
11:15:34 <dmwit> So we compute [[], [], [3], [], [5], [], [7], [], [9]], then [0*1, 0*2, 1*3, 0*4, 1*5, 0*6, 1*7, 0*8, 1*9].
11:15:37 <dmwit> Then add them up.
11:16:00 <cowsAndBulls> yes, I understand now
11:16:02 <dmwit> But we could just add up the numbers in the original list instead, and then we'd only need to compute [5,7,3,9] once, not 9 times (once for each choice of x).
11:16:05 <dmwit> Okay, cool.
11:16:21 <cowsAndBulls> let me make that change... it might make it fast enough
11:21:30 <cowsAndBulls> dmwit: Amusingly that change does not make it much faster... but it is more readable
11:22:51 <dmwit> Can I see the change?
11:23:03 <cowsAndBulls> sure, let me save it on the file
11:24:13 <cowsAndBulls> dmwit: I saved it on the shared file... it also seems that it is worth to create a function for that lambda function i am using there, since it is the same used in two different functions
11:24:37 <cowsAndBulls> dmwit: but, i think that what i am doing now should be what you suggested... i might be wrong though
11:28:15 <tabaqui1> do you know a tool to generate dependencies list for cabal based on source files?
11:28:33 <tabaqui1> it would be highly useful
11:28:53 <dmwit> If the dependencies are already installed, cabal init will do that.
11:34:40 <tabaqui1> strange
11:34:52 <tabaqui1> weird
11:35:06 <tabaqui1> indeed, it generated some list but it is far from full
11:41:19 <dmwit> ah
11:41:33 <dmwit> I bet it hasn't been updated to be v2-* aware yet.
11:41:45 <dmwit> So it's probably only looking in your user and global database for installed packages, but not the store.
11:42:00 <dmwit> You might consider filing a bug about it and see what the cabal devs think.
11:43:18 <tabaqui1> yeah, it would be not so simple, because my actual command was like "PATH=~/.stack/programs/..:$PATH cabal init"
11:43:37 <tabaqui1> I'm not sure that I can reproduce it without stack
11:43:45 <tabaqui1> but I'll try
11:48:24 <Yasuke> Hello haskell channel, I am having a problem modelling nested types and pulling them from a db using postgres-simple. I have a types that can be serialized from the database (instancing FromRow). If I want to nest that type in another one I can be playing with the applicative nature of RowParsers, but if I want that type to be nested as a Maybe <Ro
11:48:24 <Yasuke> wType> I cannot.
11:50:51 <aisn> i tried using IORef, but i think i am misunderstanding something https://paste.ubuntu.com/p/WtyzsStZxg/
11:51:06 <aisn> what am i doing wrong here?
11:51:33 <EvanR> you are creating a new IO ref each time the callback happens
11:51:50 <EvanR> you're not somehow summoning the same one 
11:52:19 <EvanR> the name mutableValue might be misleading you, rather it is createNewMutableCell
11:52:28 <aisn> how do i not do that?
11:52:51 <EvanR> one way is to add a new parameter to the callback, first argument is the mutable cell it use
11:53:02 <aisn> i cannot change the callback
11:53:04 <EvanR> when you register the callback, pass in a cell, once
11:53:07 <aisn> it depends on the library 
11:53:24 <EvanR> right, you add an extra first parameter, then apply it to a cell before passing the CB to the library
11:53:43 <EvanR> basically storing the cell in the closure of the callback
11:54:58 <aisn> is there an example somewhere, that i could use for reference?
11:55:17 <aisn> i did not find much about IORef and callbacks
11:55:21 <EvanR> you can rename the callback to be more evocative. makeSomeCallback. then ref <- newIORef 0; register (makeSomeCallback ref)
11:56:07 <EvanR> well if you pastebin some more of your code, and allow people to annotate it, it would help 
11:56:28 <aisn> heh, there is no more code
11:56:36 <aisn> i left the type of callback intact
11:56:37 <EvanR> where is this callback being used?
11:56:52 <aisn> i pass it to a midi listening function 
11:57:01 <EvanR> well.. that is code that is not shown
11:57:26 <aisn> ok, just a second
11:58:28 <aisn> https://paste.ubuntu.com/p/JGySwDqR7N/
11:58:41 <buhman> I want to transform json keys to algebraic types in aeson, but what I came up with feels slightly awkward https://gist.github.com/buhman/d70311f1f0ac3741a546c497d7bca966
11:58:45 <EvanR> what kind of pastebin doesn't let you edit...
11:59:00 * hackage dl-fedora 0.6 - Fedora image download tool  https://hackage.haskell.org/package/dl-fedora-0.6 (JensPetersen)
11:59:48 <aisn> probably this one, heh. There used to be a haskell one here, but i can't find it anymore
12:01:04 <EvanR> aisn: https://gist.github.com/evanrinehart/05dfd2c1929afdb8105df136701b8799
12:01:38 <EvanR> topic recommends gist... but even though i have a github account i had to find my phone and do two factor auth to do a gist :'(
12:01:56 <aisn> i only have a gitlab account
12:02:38 <EvanR> haskell highlighting https://gist.github.com/evanrinehart/615c4105a33b63848fd21d3027852d79
12:03:05 <EvanR> and it's wrong.... hold on
12:03:18 <midi[m]> <aisn "i pass it to a midi listening fu"> aisn: I am not a function. I'm an object ;)
12:03:40 <EvanR> https://gist.github.com/evanrinehart/615c4105a33b63848fd21d3027852d79
12:05:13 <aisn> ok, this works
12:05:19 <aisn> i will try to understand why now
12:05:21 <aisn> thanks
12:05:54 <EvanR> doesn't have as much to do with IORef as it does with closures
12:12:45 <aisn> ok, i think i understand this
12:13:04 <aisn> i don't understand how i knew about closures but this kind of thing did not pop into my head even once
12:13:22 <aisn> seems really useful
12:13:39 <EvanR> yeah comes in handy in many situations
12:14:49 <aisn> thanks for the help
12:28:30 * hackage hledger-lib 1.15.1 - Core data types, parsers and functionality for the hledger accounting tools  https://hackage.haskell.org/package/hledger-lib-1.15.1 (SimonMichael)
12:29:30 * hackage hledger 1.15.1 - Command-line interface for the hledger accounting tool  https://hackage.haskell.org/package/hledger-1.15.1 (SimonMichael)
12:29:56 <dmwit> buhman: `do { Object o <- c .: "jobs"; Object o' <- o .: "component"; ComponentJob <$> o' .: "triggers" }` -- ?
12:30:54 <dmwit> Uh, maybe `ComponentJob . pure <$> ...` at the end.
12:31:13 <dmwit> No, I'm confused.
12:31:35 <dmwit> Well, I'm confused, but I think I'm right anyway.
12:32:26 <dmwit> Oh, neat, `Object` has a FromJSON instance.
12:33:05 <dmwit> So it can be even simpler: `do { o <- c .: "jobs"; o' <- o .: "component"; ComponentJob . pure <$> o' .: "triggers" }`
12:36:47 <rndd> hi everyone. can anybody tell what's the difference between '=' and '<-'?
12:39:16 <[exa]> rndd: <- looks better and = is more modern
12:40:09 <boxscape> rndd: it'd be helpful to know in which context
12:40:14 <[exa]> the main difference is that = is special (must be parsed as assignment) but <- can be used basically anywhere
12:40:26 <merijn> [exa]: what?
12:40:33 <[exa]> oh noes
12:40:39 <[exa]> I thought I'm in #R channel
12:40:45 <boxscape> he
12:40:45 <[exa]> seriously
12:40:47 <boxscape> h
12:40:47 <[exa]> sorry
12:40:52 <merijn> = isn't assignment, there isn't even an assignment operator
12:41:22 <merijn> rndd: = is for introducing bindings (i.e. names for expressions), <- is syntactic sugar for >>= in do notation
12:41:28 <[exa]> this confused me unbelievably :]
12:42:13 <[exa]> (in fact = vs <- is a valid question even in R :D )
12:42:18 <tabaqui1> uh, can anybody help me with Cabal?
12:42:24 <merijn> rndd: So "foo = 2 + 2" gives the name "foo" to the expression "2 + 2"
12:42:29 <tabaqui1> I declared a library and a test-suite together
12:42:57 <merijn> rndd: "do { x <- foo; bar x }" is syntactic sugar for "foo >>= (\x -> bar x)"
12:43:00 <tabaqui1> but when I run "stack install" and "stack test", then it starts to rebuild the library
12:43:31 <merijn> tabaqui1: That sounds like more of a stack question than a cabal one? :)
12:43:53 <tabaqui1> "common-2.4.0: unregistering (dependencies changed)"
12:43:53 <sclv> that's not a cabal question
12:43:53 <tabaqui1> I have separated source-dirs for tests and the library
12:43:53 <sclv> that's a stack question
12:43:54 <tabaqui1> why do you think so?
12:44:09 <tabaqui1> uh, can anybody help me with Stack? :)
12:44:28 <rndd> oh common, I find explanations like that everywehe. Maybe there any 101 guide to variable declarations in haskell &
12:45:09 <merijn> tabaqui1: Well, because the confusing behaviour occurs when running the stack command? ;)
12:45:31 <tabaqui1> reasonable
12:45:36 <tabaqui1> give me a sec
12:45:46 <sclv> tabaqui1: i don't have a good answer offhand. i can tell you when its supposed to say that
12:45:59 <sclv> which is when you edit the file to add or remove deps
12:46:23 <tabaqui1> well, I used extra-source-dirs to point on Thrift files for preprocessing
12:46:35 <[exa]> rndd: these are not variables (you can't really change them). The main difference is that '<-' expanded to '>>=' usually carries some extra meaning, additionally to assigning a name to a value
12:46:49 <sclv> my _guess_ is that stack comes up with a local packagedb when you run "install" that doesn't include the test-suite deps
12:46:50 <tabaqui1> it is global parameter, and I would like to use some component specific, but didn't find any
12:46:54 <sclv> and then when you run "test" that has more deps
12:47:04 <sclv> so it notices a difference between the first db and the one you need
12:47:09 <sclv> and then it goes and starts from scratch
12:47:18 <sclv> so it could well be "working as intended"
12:47:30 <boxscape> rndd: in what context did you encounter <- ?
12:48:26 <tabaqui1> sclv: now I've commented out all dependency in test-suite except of the library itself
12:48:26 <[exa]> rndd: example: you can do 'a <- readLn' (which correctly reads the line because '<-' triggers the IO monad operations for you.) Instead, 'a = readLn' will just create another name for 'readLn'
12:48:29 <tabaqui1> let me check
12:48:40 <tabaqui1> *dependencies
12:49:35 <tabaqui1> hah
12:49:41 <tabaqui1> common-2.4.0: unregistering (components added: test:tests)
12:49:57 <tabaqui1> but it doesn't build the library which is good
12:50:26 <tabaqui1> it's about hspec
12:50:49 <tabaqui1> sclv: yeah, thanks
12:50:57 <sclv> :-)
12:51:53 <tabaqui1> dunno, I'll try to build the library with hspec as a dependency and exclude it later
12:52:17 <tabaqui1> the problem is that I can't build test suite in this context right now
12:52:25 <tabaqui1> because of preprocessors
12:54:25 <tabaqui1> nah, didn't help
12:55:20 <tabaqui1> I have to duplicate all test-suite deps in the library deps list
12:58:00 * hackage fused-effects 0.5.0.1 - A fast, flexible, fused effect system.  https://hackage.haskell.org/package/fused-effects-0.5.0.1 (robrix)
12:59:07 <buhman> dm~
13:00:08 <buhman> dmwit: hmm, I just realized I can use Alternative too
13:01:30 * hackage versions 3.5.1.1 - Types and parsers for software version numbers.  https://hackage.haskell.org/package/versions-3.5.1.1 (fosskers)
13:01:50 <buhman> but, that still won't work because neither of those are producing lists of Job (which has multiple constructors)
13:09:34 <buhman> https://gist.github.com/buhman/2ba802c3c61f6533c2cb520288f46b3e is this more clear?
13:20:36 <dmwit> buhman: It's... sort of okay as a specification (I think I can guess what you mean the pattern to be), but it's lousy as a question. What part of parsing that format are you having trouble with?
13:25:00 * hackage aura 2.0.2 - A secure package manager for Arch Linux and the AUR, written in Haskell.  https://hackage.haskell.org/package/aura-2.0.2 (fosskers)
13:33:22 <dmwit> I'm loving cabal's new common stanzas.
13:33:28 <buhman> dmwit: the best I have come up with is manually parsing that as: https://gist.github.com/buhman/2ba802c3c61f6533c2cb520288f46b3e . It seems a bit awkward to call parseJSON like that though
13:35:14 <buhman> I think it would be better, at a minimum, to rewrite that somehow to make Job an instance of FromJSON
13:35:39 <MarcelineVQ> dmwit: they're not so new by now iiuc but I agree :>
13:36:02 <buhman> but, my parser is Value -> [Job], not Value -> Job
13:50:43 <droplet> I feel like I'm going crazy - I'm running stack build --profile, then stack exec squares.exe and it's saying not found on path...
13:56:47 <mikolaj> yorick: https://github.com/maoe is the recent unofficial ThreadScope maintainer, please ask him (and he's brewing some other patch); if he's busy I'll do it instead
14:02:13 <dmwit> buhman: parseJobs v = pure <$> parseJob v; parseJob v = (AJob <$> parseAJob v) <|> (BJob <$> parseBJob v); parseAJob (Object o) = do { o' <- o .: "job-type-a"; o' .: "foo" }; parseBJob (Object o) = do { o' <- o .: "job-type-b"; o' .: "eggs" }
14:02:25 <sm[m]> droplet: that’s tricky - —profile means a completely separate binary & path
14:02:29 <dmwit> But I wouldn't even bother with parseJob, preferring just parseJob.
14:02:53 <sm[m]> Do stack exec —profile
14:03:55 <droplet> That's it, thanks!
14:04:08 <droplet> Is this a recent change in stack? I'm pretty sure I didn't have to do this before
14:04:11 <sm[m]> made me crazy too
14:04:16 <dmwit> buhman: Might make sense to move the pattern match up to `parseJob` maybe. `parseJob (Object o) = (AJob <$> parseAJob o) <|> (BJob <$> parseBJob o); parseAJob o = ...; parseBJob o = ...`. That way you can share the call to typeMismatch between the two.
14:04:46 <sm[m]> Probably
14:05:20 <sm[m]> It’s for good reason, but it’s very easy to miss
14:06:06 <droplet> Yeah I understand the change 
15:39:28 <crestfallen> hi I've been trying to write the last function using <*> instead of the liftA2 (lifter) function. the exercise oddly asked to do a single Die roll and return a list (rollNDieIO). the rollNDiceIO function I just added the list of tuples. is it possible? I don't understand replicateM and liftA2 well enough to do it, thanks.   https://termbin.com/bi37
15:40:06 <crestfallen> if its possible
15:40:30 * hackage hvega 0.4.0.0 - Create Vega-Lite visualizations (version 3) in Haskell.  https://hackage.haskell.org/package/hvega-0.4.0.0 (DouglasBurke)
15:43:45 <crestfallen> also if concat is possible to use to return a list similar to single die toss-    :: Int -> IO [Int] 
15:51:00 * hackage happstack-server 7.5.2 - Web related tools and services.  https://hackage.haskell.org/package/happstack-server-7.5.2 (JeremyShaw)
15:52:06 <MarcelineVQ> I'm not quite sure what you're asking, is what possible?
15:53:05 <MarcelineVQ> Since I'm confused it might be a good idea to share the exercise's text for clarity if you think you explained well enough already
15:55:47 <MarcelineVQ> n_blownapart: is the exercise to roll x number of dice y number of times?
15:56:53 <MarcelineVQ> crestfallen: what is the exercise text? or an example of the output you should be producing
15:58:41 <MarcelineVQ> Asking that because I'm not quite sure what you're asking, you said "is it possible?" but I'm not sure what 'it' is here
15:59:40 <crestfallen> sorry I was disconnected if anyone responded. oh thanks MarcelineVQ the output should be as in the first two functions. the third one I wanted to change to a list of tuples, because I thought rollNDieIO (a single die , n times) was odd
16:00:30 * hackage getopt-generics 0.13.0.4 - Create command line interfaces with ease  https://hackage.haskell.org/package/getopt-generics-0.13.0.4 (SoenkeHahn)
16:00:53 <crestfallen> the 3rd one works at the moment, but I was trying to flatten the tuples into a list, using concat and such, but I'm a bit foggy
16:01:43 <dmwit> There are two questions here.
16:02:16 <dmwit> 1. Can I do without lifter? 2. Can I turn an IO [(Int, Int)] into an IO [Int] that includes all the Int's in the input's result?
16:02:38 <crestfallen> I was hoping to do something like (randomRIO (1,6)) <*> (randomRIO (1,6))    but I know that's wrong. 
16:03:13 <dmwit> For 1. you can just inline the definition of lifter. lifter f u x = f <$> u <*> v, so lifter (,) (randomRIO (1,6)) (randomRIO (1,6)) = (,) <$> (randomRIO (1,6)) <*> (randomRIO (1,6))
16:03:22 <dmwit> s/x/v/ obviously
16:04:34 <dmwit> For 2. I recommend that you first write a function of type (Int, Int) -> [Int]. Then write [(Int, Int)] -> [Int]. Then write IO [(Int, Int)] -> IO [Int].
16:04:42 <dmwit> Let us know where along that path you have trouble.
16:05:30 <crestfallen> thanks dmwit that looks rough. I'm really struggling with applicative
16:07:27 <dmwit> I'm gonna go out on a limb here and say this has nothing to do with applicative.
16:08:36 <dmwit> If I write a function definition in math like f(x) = 5*x^2/2 + 3*x + x, and then ask you what f(5) is, you don't need to even know how (*) or (+) or (^) work to answer that f(5) = 5*5^2/2 + 3*5 + 5
16:09:44 <dmwit> This is exactly the same thing. When you write `lifter f u v = f <$> u <*> v`, then that means when you see `lifter (complicated expression 1) (c. e. 2) (c. e. 3)`, you don't need to know anything about how `(<$>)` and `(<*>)` work to know that's *exactly* the same thing as `(c. e. 1) <$> (c. e. 2) <*> (c. e. 3)`.
16:10:11 <dmwit> You just plug in the argument expressions in the spots where the variables appear.
16:10:28 <MarcelineVQ> where c. e. is short for complicated expression
16:11:42 <crestfallen> ok but I was hoping to do away with lifter, I believe that was my intent.
16:12:07 <crestfallen> I was tinkering, but concat is not the way I guess
16:12:11 <dmwit> Yes. And the text "lifter" does not appear in the result `(c. e. 1) <$> (c. e. 2) <*> (c. e. 3)`.
16:13:28 <crestfallen> what is going on? last night I needed a sandbox to run randomRIO. today on a 32bit machine I do not....
16:13:32 <dmwit> (Yes, yes, fellow denizens, I know: complicated expressions might mention lifter. Please don't sidetrack us with this unenlightening quibble.)
16:14:34 <dmwit> crestfallen: That is explainable. Is it the thing you are most interested in understanding right now?
16:15:00 <dmwit> I'm going to bet no, and so let's ignore it.
16:15:08 <crestfallen> no I'm just tripping. really appreciate it. you are deep dmwit I'm working on what you've said
16:23:35 <MarcelineVQ> crestfallen: made any progress based on what dmwit mentioned?
16:24:42 <crestfallen> MarcelineVQ, I'm having logistical troubles in this blasted cafe.
16:27:07 <Guest20> https://pastebin.com/r8j48Y3G
16:27:11 <Guest20> Is this bad practice?
16:27:53 <Guest20> Too convoluted?
16:29:23 <Guest20> I'm new to Haskell, I'd like to have that SingTransfusionPieceI constraint in the BloodDonor datatype.
16:29:34 <Guest20> A GADT is better in this case or is Dict passing ok?
16:30:31 <Guest20> I know I can just require the constraint in functions, but I'd like it to be mandatory and preferentially at the datatype.
16:36:54 <crestfallen> If you could give a hint, do I need concat to do (Int,Int) -> [Int]    ?
16:37:55 <boxscape> Guest20 why not juts write `data BloodDonor (idx :: Symbol) a = SingTransfusionPieceI idx a => BloodDonor <...>`?
16:38:48 <Guest20> boxscape: any downsides to that?
16:39:09 <Guest20> The WIP code is: https://pastebin.com/4YMcHVz5
16:39:39 <boxscape> to be honest I haven't done much with explicit dictionaries so I'm not entirely sure if they have any specific advantages, but I'm not aware of any real downsides
16:39:59 <Guest20> I'm new to Haskell, so I'd appreciate any feedback.
16:40:20 <Guest20> First time I dabble with "intermediate haskell" and many of these language extensions.
16:51:32 <dmwit> crestfallen: Let me turn the question around on you. If your (Int,Int) -> [Int] uses concat, presumably it will be at the type [[Int]] -> [Int]. So if you want to use concat, then you have changed your problem from implementing (Int,Int) -> [Int] to implementing (Int,Int) -> [[Int]]. Does that seem easier to you?
16:53:37 <sm[m]> is it possible to correct a changelog (extra-source-files) on hackage, through the web UI, without a release ?
16:54:13 <crestfallen> dmwit, I'm just in the dark. I can't keep it all in my head
16:56:40 <crestfallen> no I don't want to use concat if not needed
17:00:41 <crestfallen> the other thing is dmwit , there's no IO in the signature like (Int,Int) -> IO [Int]     ?
17:01:05 <dmwit> Do you think it would be easier if there were?
17:01:30 <dmwit> sm[m]: I don't think so.
17:01:45 <sm[m]> thx
17:03:34 <sim590> https://paste.debian.net/1098475/. I want to make a sum of a given number of doubles I get on the command line. I want the code to be easily maintainable (easy to add support for anohter number) and avoid using intermediary numbers (like definition of doublesSum'''). Can it be done?
17:03:45 <sim590> See the alternatives I have gone through in https://paste.debian.net/1098475/.
17:04:30 <sim590> Alternatives are named doublesSum (with quotes at the end or not).
17:04:56 <sim590> doublesSum' and doublesSum'' are just horrible. 
17:06:16 <sim590> doublesSum is OK (reminds me of imperative code, while I know that it's not the case and that it's all syntaxic sugar of the do block for the Applicative type class.
17:06:22 <sim590> )
17:07:11 <sim590> However, doublesSum shows a warning saying I'M shadowing "s" which is obvious, but it behaves in the way that I want it (kind of like imperative style).
17:07:36 <dmwit> doublesSum = go 0 where go s [] = pure s; go s (i:is) = do { n <- askForDouble i; go (s+n) is }
17:07:54 <dmwit> Call it like `doublesSum ["premier", "second", "troisieme", "quatrieme"]`.
17:08:24 <dmwit> You'll probably want some strictness thing in there at some point, too, maybe `go !s (i:is) = ...` or similar.
17:08:46 <dmwit> :t foldM
17:08:48 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
17:09:11 <crestfallen> dmwit I don't understand the line of your question
17:09:41 <dmwit> :t foldM (\s i -> (s+) <$> (putStrLn i >> readLn)) 0 ["premier", "second", "troisieme", "quatrieme"]
17:09:43 <lambdabot> (Num b, Read b) => IO b
17:09:59 <dmwit> sim590: ^ even better. replace putStrLn/readLn with your askForDouble
17:10:18 <dmwit> No idea what that does about strictness though.
17:10:22 <dmwit> Consult the source to be sure.
17:11:10 <dmwit> crestfallen: You ask, "Why not use the type signature (Int,Int) -> IO [Int] instead?". I answer, "Go ahead, if you think that will make your job easier.".
17:13:53 <EvanR> things are hard, one may think adding IO might make things easier, then it doesn't. Therefore haskell is hard
17:15:07 <sim590> dmwit: thanks. I'm just learning about monads and all. Actually, I'm only at functors and applicatives. The answer you're giving me is quite naturally consistent with my knowledge about foldables.
17:15:49 <dmwit> I can spell my answer in terms of Applicative instead if you want.
17:17:12 <dmwit> Wait, no, I'm confused.
17:17:28 <dmwit> You say you want only Applicative, not Monad. But your example code uses Monad.
17:18:05 <sim590> It's alright. I don't mind about monads. I may not be really accurate about what I'm using.
17:19:00 <sim590> I thought I was only using applicatives with IO, but yeah I'm using >>=.
17:19:03 <dmwit> ?src foldM
17:19:03 <lambdabot> foldM _ a []     = return a
17:19:03 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
17:19:29 <crestfallen> EvanR, depressing
17:19:54 <EvanR> my proof was satirical
17:55:00 * hackage ghc-events 0.9.1 - Library and tool for parsing .eventlog files from GHC  https://hackage.haskell.org/package/ghc-events-0.9.1 (MitsutoshiAoe)
17:59:54 <jonathan46> I could use a hand, this should be so easy but I am pulling my hair out.  Anybody around?
18:00:35 <shapr> jonathan46: what's up?
18:01:47 <jonathan46> I am trying to use some code compiled from D.  I have the `.a`/`.o` files and I got it to work using ghc directly.  How add link files `.a`/`.a` files to a cabal/hpack?
18:02:14 <jonathan46> I figured `extra-source-files` was it--but it does not work.
18:05:13 <jonathan46> Well, I guess that is encouraging...  I am not the only one who doesn't know how to do it XD
18:05:26 <dmwit> ld-options or ghc-options, I guess?
18:05:51 <dmwit> extra-libraries looks especially promising
18:05:54 <shapr> yeah, not something I know off the top of my head
18:07:35 <dmwit> So you'll likely add the name of the library (the <bar> in <foo>/lib<bar>.a) to extra-libraries, and the path (the <foo> in <foo>/lib<bar>.a) to ld-options with -L preceding it.
18:08:20 <dmwit> And yes, you should either include <foo>/lib<bar>.a in your extra-source-files, or include the D files there and have a custom Setup.hs that builds your .a files from them.
18:08:26 <jonathan46> Um, okay, let me try some of that.
18:11:57 <jusss> :t return
18:11:58 <lambdabot> Monad m => a -> m a
18:12:09 <shapr> :t pure
18:12:10 <lambdabot> Applicative f => a -> f a
18:12:36 <jusss> but in Reader, return x = \_ -> x
18:12:50 <jusss> this return is not a->e->a?
18:13:47 <hpc> :t \x -> \_ -> x
18:13:48 <lambdabot> p1 -> p2 -> p1
18:14:30 <jusss> :t \_ -> x
18:14:32 <lambdabot> p -> Expr
18:14:57 <hpc> \_ -> x :: a -> (whatever the type of x is)
18:15:08 <hpc> lambdabot defines x though, for some nice symbolic stuff
18:15:09 <hpc> > x
18:15:11 <lambdabot>  x
18:15:14 <hpc> > f x :: Expr
18:15:17 <lambdabot>  f x
18:15:50 <jusss> :t (+1) (>>=) return
18:15:52 <lambdabot> (Num ((a -> m a) -> (m a -> a -> b) -> a -> b), Monad m) => (m a -> a -> b) -> a -> b
18:16:24 <hpc> :t (+1) >>= return -- i think you meant this?
18:16:25 <lambdabot> Num b => b -> b
18:17:02 <jusss> hpc: that's different?
18:17:25 <jusss> :t (+1) >>= return
18:17:27 <lambdabot> Num b => b -> b
18:18:05 <jusss> hpc: but this return, what its function definition here?
18:18:19 <jusss> it supposes to be a binary function
18:18:22 <hpc> it's precisely what you gave above
18:18:25 <hpc> :t (>>=)
18:18:27 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:18:47 <hpc> when applied to (>>=), return takes the position of the (a -> m b) argument
18:18:50 <hpc> but!
18:18:59 <jusss> hpc: but return x = \_ -> x IIRC
18:19:08 <hpc> m b = (e -> b) because of the instance it's using
18:19:30 <jonathan46> That is weird.  I tried listing the `.a` files as `c-sources` and I get the error "the following files would be used as linker inputs, but linking is not being done"
18:19:45 <hpc> so here we have several constraints on that type
18:20:07 <jusss> hpc: ok, and this return?
18:20:14 <hpc> we unify return's type, (a -> m a) with its position in (>>=) and get b = a
18:20:32 <hpc> then with instance resolution expand out m
18:20:37 <dmwit> jonathan46: Well, .a files are definitely not C sources.
18:20:50 <hpc> so cutting out (+1) here, we have
18:21:06 <jusss> hpc: return should has a->e->b, right?
18:21:10 <jusss> or a->e->a
18:21:17 <hpc> a -> e -> a
18:21:26 <jusss> ok, return should be a binary function
18:21:34 <hpc> yes
18:21:37 <dmwit> For this instance, yes.
18:21:42 <jusss> but return x = \_ -> x is an unary
18:21:46 <dmwit> Nah, it's binary.
18:21:52 <hpc> remember currying
18:21:57 <jusss> dmwit: wait, unless x is a unary
18:22:09 <hpc> f a b = blahblah
18:22:11 <hpc> is the same as
18:22:13 <dmwit> It takes two arguments. The first it names x. The second it doesn't give a name to.
18:22:17 <hpc> f a = \b -> blahblah
18:22:35 <jusss> wait a sec
18:22:45 <jusss> dmwit: who takes two?
18:23:01 <dmwit> All of these are different spellings of the same function: `return = \x _ -> x`, `return x = \_ -> x`, `return x _ = x`. Also all the same: `return = \x a -> x`, `return x = \a -> x`, `return x a = x`.
18:23:53 <jusss> I forgot that
18:23:56 <hpc> or for maximum expansion
18:24:04 <hpc> return = \x -> \_ -> x
18:24:16 <jonathan46> Ha HA!
18:24:19 <jusss> return x = \_ -> x is return = \x -> \_ -> x
18:24:30 <jonathan46> I got it, thanks for the help!
18:24:39 <dmwit> cheers
18:24:50 <dmwit> Can the solution be summarized in a sentence or two?
18:25:08 <wwwww> anyone knows how can i cross-compile haskell?
18:25:53 <jonathan46> I put in an `extra-libraries` (like you said) and added the `.a` to the `ld-options` with the `-L` and cabal told me to use `extra-lib-dirs` instead of `ld-options: "-L"`.
18:26:45 <jusss> flood?
18:28:33 <jusss> hpc: this return x = \_ -> x , is like const ?
18:28:35 <jusss> :t const
18:28:37 <lambdabot> a -> b -> a
18:29:35 <jusss> dmwit: is const = return ? in Reader
18:30:01 <dmwit> yes
18:30:11 <jusss> ok
18:30:43 <dmwit> jonathan46: Great!
18:32:27 <jusss> is f x = \x -> (f x) ?
18:32:52 <jusss> no
18:33:47 <jusss> f x can get f = \x -> ?
18:34:39 <hpc> the equivalence of (f x) and (x -> f x) is eta-reduction - https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B7-conversion
18:35:34 <EvanR> f = \x -> f x
18:36:22 <hpc> er, yeah that
18:36:25 <jusss> ok
18:36:43 <EvanR> in what sense... that for all y, f y = (\x -> f x) y
18:37:14 <EvanR> maybe then = has a better chance of meaning anything :P
18:39:37 <jusss> f >>= return   =    f >>= \x -> return x
18:40:24 <EvanR> and f >>= return   =    f
18:40:54 <jusss> yeah
18:41:30 <EvanR> i expect to see "f" on the right of >>= and a non-function on the left
18:41:44 <EvanR> though you can use the function monad
18:41:45 <jusss> the f's input as the context pass to return as the second input 
18:42:51 <jusss> right?
18:42:56 <EvanR> i er uh, return has no second input usually
18:43:19 <jusss> but this return is a binary function
18:43:23 <EvanR> or are we doing function monad
18:43:41 <jusss> (+1) >>= return
18:43:42 <dmwit> EvanR: (we are)
18:43:49 <EvanR> oh
18:44:46 <jusss> ( (+1) >>= return ) 2   -- this one, the (+1)'result is 3, we pass 3 to return as its firt input, and the context is 2, we pass 2 as return's second input, right?
18:45:22 <jle`> jusss: one way to find out --- you can just expand all of the definitions
18:45:28 <jle`> of (>>=) and return
18:45:50 <jle`> ( (+1) >>= (\r _ -> r) ) 2
18:46:21 <jusss> jle`: that would be (+1) >>= return = \x -> return ((+1) x) x 
18:47:03 <jle`> yeah, which is \x -> const (x + 1) x, which is \x -> (x + 1)
18:49:27 <jusss> jle`: I want the intuition...
18:51:03 <jusss> my intuition is ok? 
18:51:15 <jle`> if you think of it as monadic actions, the "result" of (+1) is 3, and the "result" of `return 3` is then therefore 3 as well
18:51:18 <EvanR> lambdas are the intuition, >>= return are notation
18:51:46 <jle`> if you want to think of reader actions as monadic actions with results, the "result" of the (+1) action there is 3 yes, when you apply the whole thing to 2
18:52:32 <jle`> consider another example using do notation, if you are trying to get away from the literal function applications:
18:52:50 <jle`> one = do x <- sin; y <- cos; return (x^2 + y^2)
18:54:06 <jle`> if you do `one 0.2`, for instance, the "result" of the `sin` action is 0.199, the "result" of the `cos` action is 0.980
18:54:31 <jle`> and the final result is then 0.199^2 + 0.980^2
18:54:40 <jle`> @let one = do x <- sin; y <- cos; return (x^2 + y^2)
18:54:42 <lambdabot>  Defined.
18:54:48 <jle`> > one 0.2
18:54:50 <lambdabot>  1.0
18:54:53 <jusss> and return 0.199^2+0.980^2 0.2
18:55:10 <jle`> the final result is 0.199^2 + 0.980^2, which is approcimately 1.0
18:55:15 <jle`> > 0.199^2 + 0.980^2
18:55:17 <lambdabot>  1.000001
18:55:49 <jle`> the result of `return blah` is `blah`
18:57:24 <jle`> this is the abstract intepretation in terms of monadic actions and results.  written in do notation it hides what is going on underneath to emphasize the "action/result" interpretation, but you can recover what is going on by doing the desugaring
18:58:31 <jle`> writing 'sin'/'cos' inline like that, though, is pretty bad for readability.  so sometimes we use something like 'ask' to help remind us that we are thinking in terms of monadic actions
18:58:42 <jle`> in this case ask = id
18:58:46 <jusss> jle`: the term "action", what is it?
18:59:09 <jle`> it's somewhat meaningless, but it's a way to interpret lines of a do block
18:59:28 <jle`> where you imagine each line is sequencing some series of monadic actions (values of type `M a`)
18:59:42 <jle`> and each line has a result, and the result of the final line is the result of the entire do block
18:59:58 <jle`> *result of the final action
19:00:44 <jle`> more generally it is an abstract word to help us interpret values of type `M a` for some monad M...also known as monadic values or motes etc.
19:01:21 <jle`> but choosing the word 'action' emphasizes the fact that we're sequencing a bunch of them, potentially using the results they produce
19:01:40 <jle`> choosing to use the word 'action' in a particular explanation/interpretation, i mean
19:02:22 <jle`> for example in do x <- getLine; putStrLn ("hello " ++ x), we have two actions sequenced one after the other on each line of the do block, and the result of the first action is called x (and is the reuslt of getLine)
19:03:06 <jle`> in do x <- [1,2,3]; y <- [4,5,6]; return (x + y), we have three actions sequenced, where the result of the first action is bound to x, and the result of the second action is bound to y
19:03:13 <jle`> and the result of the third action is (x + y)
19:03:35 <jle`> it's just one way of interpreting the things you are sequencing in a do block, or >>'s/>>='s
19:05:02 <jusss> ok
19:38:43 <jonathan46> So, `extra-lib-dirs` works great until I move it into an internal library.  It says I cannot use a relative directory and use `${pkgroot}` to be relative to the package database.  I don't want to be relative to the package database, I want to be relative to the `.cabal` file.
19:39:43 <jonathan46> I cannot find anything in the cabal user-guide about `${pkgroot}`.
19:40:38 <jonathan46> I that a bug with Cabal, or am I missing something?
19:43:14 <sclv> jonathan46: i think its just underdocumened.
19:43:16 <sclv> eg https://mail.haskell.org/pipermail/libraries/2009-May/011772.html
19:43:24 <sclv> you may want to open a ticket to add that to the docs!
19:45:09 <jonathan46> Okay (:
19:45:18 <sclv> also potentially related issue https://github.com/haskell/cabal/issues/1317
19:46:31 <jonathan46> Yup, that looks like the issue I am facing.
21:24:54 <olligobber> I'm curious if there's a typeclass for mappables like Array, Map, (->), etc?
21:25:42 <EvanR> fmappable? (Functor)
21:26:52 <olligobber> not that, I mean things that have an index type and a value type
21:27:55 <olligobber> I'm imagining class (Mapping m i) where { (!) :: m i v -> i -> v; (//) :: m i v -> (i,v) -> m i v }
21:28:13 <olligobber> and some other methods too
21:28:41 <EvanR> you dont really need a class for this, you could always require a (k -> a), which all the lookup functions satisfy
21:28:55 <EvanR> if you close over the table object itselk
21:29:10 <EvanR> oh now you want more methods
21:29:14 <EvanR> no
21:29:38 <olligobber> ok, I guess I'll make the class myself
21:30:48 <olligobber> ty EvanR
21:38:24 <jle`> olligobber: it's kiiinda like At or Ix from Lens
21:38:33 <jle`> s/Lens/lens
21:38:54 <jle`> At is pretty close, except it's Maybe v instead of v for all of those
21:39:27 <jle`> and there's no instance for Array because it wouldn't be sensible either necessarily (what if you // something out of bouds)
21:40:23 <jle`> but yeah At is pretty much what you have there except for the Maybe v vs. v, and it uses associated types instead of type parameters
21:41:24 <olligobber> hmm, it's not quite what I want, I don't require keys to be deleted, and I don't care about the behavior when modifying something out of bounds
21:41:46 <jle`> what about out-of-bounds access?
21:42:23 <olligobber> there was going to be a (!?) method to give a Maybe, but the behaviour on out of bounds access is also something I don't care much about
21:42:45 <olligobber> I was thinking it should have a mapWithKey method, though Array doesn't have one of those for some reason
21:42:52 <jle`> if so then maybe what you have is close to lens's Ixed
21:43:03 <jle`> Ixed can be used to implement those functions
21:43:28 <jle`> xs ! i = xs ^?! ix i
21:43:40 <jle`> xs // (i, v) = set (ix i) v xs
21:44:25 <olligobber> I'm finding the documentation for Lens very confusing
21:44:45 <jle`> of course the higher-level question is why you are looking for a general abstraction for concepts that might not meaningfully be unitable under such an abstraction
21:45:25 <olligobber> jle`, I want my unionfind implementation to be generalised to elements that aren't necessarily Data.Array.Ix
21:46:50 <olligobber> so it can work with Ord types if it uses a Map, or Eq types if it uses a function, though those would be less efficient than the Array
21:49:37 <jle`> hm. usually for me, making a typeclass is a last resort. in this case you could have your function take (m i v -> i -> v) and (m i v -> i -> v -> m i v) as inputs maybe
21:49:55 <jle`> but yeah, i don't know if there is one common one that exists atm
21:50:03 <jle`> there might be one in mono-traversable
21:50:52 <jle`> olligobber: i guess one reason why you won't find a typeclass like that in a common library is that it's not really well-defined
21:51:11 <olligobber> I suppose
21:51:17 <jle`> and by that i mean in the literal sense; (!) is partial for Array and Map
21:51:34 <jle`> and typeclasses with partial methods is a very big no-no in haskell ecosystem
21:51:46 <olligobber> I see
21:51:52 <jle`> (besides the ones we are stuck with in base)
21:52:05 <olligobber> like what?
21:52:08 <jle`> so if such a class exists, it's unlikely it would be made public or common because it breaks a lot of ecosystem idioms
21:52:29 <jle`> typeclasses with partial methods in base like Read, Enum
21:52:35 <olligobber> ah I see
21:52:47 <jle`> Ix even
21:53:00 <olligobber> Ix is partial?
21:53:09 <jle`> > index (1,3) 4
21:53:11 <lambdabot>  *Exception: Ix{Integer}.index: Index (4) out of range ((1,3))
21:53:21 <olligobber> huh
21:53:45 <jle`> we're stuck with these in base, but if people are making new libraries within the past twenty years or so, they probably are discouraged from partial methods in typeclasses
21:54:28 <olligobber> Ok, I guess I'll go with the (m i v -> i -> v) and (m i v -> i -> v -> m i v) solution
21:54:30 <jle`> this is my hunch for why you might not find a common typeclass for your situation; so you'd probably have to either make your own ad-hoc typeclass or take the functions as parameters :/
21:54:53 <jle`> nothing tooo immoral about an ad-hoc typeclass here i don't think
21:55:48 <olligobber> I think I'd prefer to take the functions as parameters
21:56:46 <EvanR> definitely
21:56:58 <jle`> that's the way i'd do it too :)  but my stance on this has softened over the years
21:57:02 <olligobber> though for real, why doesn't Array have a mapWithIndex method? I don't need it, just curious
21:57:16 <jle`> the array API is very famously super bare
21:57:33 <jle`> i'm not sure if there's any reason for it but that's sort of the reputation it has
21:57:40 <olligobber> weird
21:57:49 <jle`> sometimes i do wonder too
21:58:08 <EvanR> you can build something like that from the 1 super-function on Array
21:58:21 <jle`> most people use 'vector' unless they want the variable-index-type property
21:58:27 <EvanR> convenience methods were never written
21:58:42 <jle`> and some people even use vector and build their own the variable-index on top of it ...
21:59:14 <jle`> yeah i suppose the 'array' philosophy is "you can write it using the 1 super-function so why bother to offer a convenience function"
21:59:32 <olligobber> maybe I should look into using vector instead of array
22:01:09 <jle`> in a way unrelated to how we last referred to it, 'lens' offers a mapWithIndex
22:01:20 <jle`> it has a FunctorWithIndex typeclass and Array has an instance
22:01:34 <olligobber> interesting
22:01:40 <jle`> imap :: (i -> a -> b) -> Array i a > Array i b
22:02:06 <jle`> i wouldn't mind a general FunctorWithIndex typeclass out there in the ecosystem
22:06:33 <olligobber> ok, taking in the functions doesn't work as I'd hoped
22:06:46 <olligobber> `error: Not in scope: type variable ‘v’'
22:07:36 <olligobber> I guess I'll go with the ad-hoc typeclass option :(
22:08:05 <EvanR> not in scope variable v seems like a fixable problem
22:08:53 <olligobber> I want to take in one function of type m i v -> i -> v but use it for multiple different types v
22:09:36 <olligobber> so I guess I want something of type forall v. m i v -> i -> v
22:11:00 * hackage xml-hamlet 0.5.0.1 - Hamlet-style quasiquoter for XML content  https://hackage.haskell.org/package/xml-hamlet-0.5.0.1 (MichaelSnoyman)
22:12:00 * hackage githash 0.1.3.2 - Compile git revision info into Haskell projects  https://hackage.haskell.org/package/githash-0.1.3.2 (MichaelSnoyman)
22:13:08 <EvanR> olligobber: right
22:14:25 <EvanR> (if you wrote that as an argument in parens)
22:14:30 <EvanR> and enable RankNTypes
22:20:42 <jle`> this reminds me of how typeclasses are actually a way to encode RankNTypes within normal Haskell98
22:21:08 <jle`> s/are actually/can actually be used as
22:42:15 <typetetris> Isn't there a slack or something for munihac 2019?
22:43:00 * hackage shh 0.7.0.5 - Simple shell scripting from Haskell  https://hackage.haskell.org/package/shh-0.7.0.5 (lukec)
22:46:46 <olligobber> EvanR, oh, if all I need is RankNTypes then that works
22:47:03 <dminuoso> typetetris: Yes.
22:47:23 <dminuoso> typetetris: Last year there was #munihac
22:47:35 <typetetris> dminuoso: That seems dead.
22:47:59 <typetetris> Sad. Didn't got a ticket yet and thought I could at least participate remotely :)
22:48:25 <dminuoso> typetetris: Munihac hasnt started yet, so...
22:49:21 <EvanR> RankN. It's a beautiful thing. MASTERCLASS
22:50:28 <dminuoso> jle`: How can you encode RankNTypes with typeclasses?
22:52:20 <kosmikus> typetetris: there is/will be a slack
22:56:45 <jle`> dminuoso: i forgot where i read a blog post explaining exactly
22:56:57 <jle`> but note how you can transform a function like:
22:57:34 <jle`> fmapper :: (forall a b. (a -> b) -> f a -> f b) -> f Bool -> f String
22:57:52 <jle`> fmapper fm x = fm show x
22:58:00 <jle`> into:
22:58:17 <jle`> fmapper :: Functor f => f Bool -> f String
22:58:24 <jle`> fmapper x = fmap show x
22:59:09 <jle`> basically typeclass methods are essentially 'passed' as Rank-N types through typeclass dictionaries
22:59:26 <jle`> so you can go backwards too
23:01:08 <dminuoso> jle`: But that's severely limited, isnt it? I mean the caller/consumer of fmapper no longer has the option of passing an `fm` function of his chosing.
23:02:42 <dminuoso> jle`: I mean let's set f ~ [], I can pass an infinite number of (law-breaking) fm functions into fmapper. But after the transformation to take a typeclass, that choice is gone entirely (though in effect I suppose I could mimic it with newtypes?)
23:03:42 <EvanR> i don't think f can be universal in jle`'s example
23:06:08 <EvanR> ah yeah, caller chooses f, then chooses the fmap implementation (law breaking or not, just like typeclasses), then callee chooses how to use it
23:08:45 <EvanR> it's true that typeclasses restrict you to 1 per type, but that is only to facilitate type checking / instance selection (idris lets you pass in as many different instances for a type you want)
23:09:17 <jle`> dminuoso: essentially you can perform a defunctionalization
23:09:26 <EvanR> (but for rebuttal, see "type classes vs the world")
23:09:45 <jle`> for example everyone's favorite rank-n type example:
23:10:00 <jle`> useList :: (forall a. [a] -> Int) -> (String, Bool) -> Int
23:10:06 <jle`> useList f (x,y) = f x + f y
23:10:09 <jle`> um
23:10:17 <jle`> useList :: (forall a. [a] -> Int) -> (String, [Bool]) -> Int
23:10:52 <jle`> we can call `useList length` or `useList (length . drop 2)`
23:11:02 <jle`> so now we can defunctionalize:
23:11:11 <jle`> class UseList a where
23:11:22 <jle`>   fn :: p a -> [b] -> Int
23:11:41 <jle`> data Length; instance UseList Length where fn _ = length
23:11:56 <jle`> data LengthDrop2; instance UseList LengthDrop2 where fn _ = length . drop 2
23:12:10 <jle`> useList :: p a -> (String, Bool) -> Int
23:12:24 <jle`> useList user (x, y) = fn user x + fn user y
23:12:57 <jle`> now instead of passing a Rank-N function into useList, you instead pass an ad-hoc type that is an instance of UseList
23:13:27 <jle`> ( dminuoso )
23:13:35 <jle`> oh, i already pinged
23:14:05 <jle`> but this is a mechanical process you can use to turn any RankN function into a Rank1 one with typeclasses
23:16:06 <jle`> * [Bool]
23:17:03 <dminuoso> jle`: Is `p a` supposed to be some form for `Proxy a`?
23:17:12 <jle`> defunctionalization is a pathway to many abilities some consider to be ... unnatural
23:17:26 <nshepperd2> That does mean that the function you pass has to be definable as a type class instance though
23:17:33 <jle`> dminuoso: yeah it can be used as Proxy, but since we never actually pattern match on Proxy there's no reason to specialize it
23:17:44 <nshepperd2> Ie. Not capturing any local variables
23:18:04 <jle`> you can make the data type parameterized to cover local variable capture, i believe
23:18:18 <EvanR> unless you create new instances at runtime 
23:18:46 <nshepperd2> I guess you can fix that by just passing am auxiliary variable
23:19:38 <jle`> i can't figure out the words i need to search to find that blog post, heh
23:20:32 <jle`> but yeah if you have local variables you could just have `data DefuncSym a` instead of `data DefuncSym`
23:20:56 <jle`> oh, that last signature should have been useList :: UseList a => p a -> (String, [Bool]) -> Int
23:21:13 <nshepperd2> Though... I feel like you need an extension to express the type of the auxiliary variable
23:21:18 <dminuoso> Yeah I figured
23:21:46 <jle`> i feel like this is all haskell98 compatible; none of the instances or classes should require FlexibleInstances
23:21:59 <nshepperd2> FkexibleInstances to write "instance UseList (DefuncSym Int)"
23:22:19 <jle`> if it's variable capture then UseList would have DefuncSym as an instance
23:22:25 <jle`> since it has to be parametrically polymorphic
23:22:38 <jle`> it'd be * -> *
23:23:36 <jle`> replacing: foldMyStuff :: Monoid m => (forall a. [a] -> m) -> (String, [Bool]) -> m
23:24:41 <jle`> hm
23:25:29 <jle`> that's not a good function i think since the caller decides m
23:25:45 <jle`> or maybe it is
23:26:40 <jle`> or maybe it's just not a good example because there aren't that many interesting functions (forall a. [a] -> m)
23:27:20 <dminuoso> jle`: Well you could change the order
23:27:24 <nshepperd2> LengthDropN?
23:27:43 <dminuoso> At the very least "foldMap" and "foldMap . reverse" seem interesting?
23:27:53 <jle`> i mean nothing that would be more interesting than what was already done with the -> Int version
23:28:04 <jle`> foldMap doesn't work i think
23:28:13 <jle`> the only thing you could do is foldMap constant functions
23:34:55 <EvanR> LengthsBDropN
23:35:28 <jle`> maybe the problem is (forall a. [a] -> r) is essentially isomorphic to Natural
23:36:08 <jle`> hm, did i phrase that right
23:37:24 <dminuoso> jle`: Mmm, isnt it rather isomorphic to [r] ?
23:37:57 <dminuoso> My thinking here is, that the only thing you can use from [a] is its length, so you might as well think of it as `Nat -> r`
23:38:48 <nshepperd2> Ah, class UseList a where { fn :: a -> [b] -> Int }
23:39:21 <nshepperd2> Then you pass local variables by stuffing them in the a
23:42:45 <nshepperd2> data LengthDropN = LengthDropN Int; instance UseList LengthDropN where fn (LengthDropN n) = length . drop n
23:43:39 <jle`> oh you meant local value variables
23:43:49 <jle`> *term variables
23:44:08 <jle`> yes, that's it :)
23:44:23 <nshepperd2> Yes
23:44:30 <jle`> dminuoso: ah yeah, isomorphic to (Nat -> r) makes sense
23:49:36 <jusss> dminuoso: good afternoon
