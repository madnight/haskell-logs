00:30:20 <nwoob> are higher order function and currying same thing?
00:31:31 <ski> no
00:32:06 <ski> one is a property of a thing, the other is process
00:33:11 <nwoob> semantic difference?
00:34:51 <jgt> nwoob: not really
00:35:15 <jgt> higher order functions is being able to pass functions into other functions as values
00:35:31 <jgt> currying is more related to partial application
00:40:32 <c_wraith> currying isn't possible without at least a limited form of higher-order functions
00:41:30 <c_wraith> but currying is just a syntactic thing.  higher-order functions are the interesting semantic part.
00:43:56 <ski> higher-order functions is also about being able to have a function yield a function as result
00:47:23 <jgt> I'll defer to everyone else's wisdom. My job here is cliff notes and shaky analogies.
00:48:02 <MarcelineVQ> using analogies is a lot like eating shrimp
00:48:28 <jgt> MarcelineVQ: that's genius
00:50:21 <MarcelineVQ> Great, so you got my point exactly.
00:50:54 <MarcelineVQ> And so you can then clearly see that's why we need to avoid the same three things happening here or we'll end up like ancient rome did.
00:51:30 <jgt> MarcelineVQ: …Flamboyant?
00:52:05 <MarcelineVQ> Oh no, you mean you didn't know exactly what I meant? Damn you analogies!
00:53:07 <jgt> :D
01:14:53 * ski . o O ( someone remarked that we mostly pretend to understand each other, out of politeness )
01:45:00 * hackage hie-bios 0.1.1 - Set up a GHC API session  https://hackage.haskell.org/package/hie-bios-0.1.1 (mpickering)
01:54:00 * hackage lambdabot-xmpp 0.1.0.3 - Lambdabot plugin for XMPP (Jabber) protocol  https://hackage.haskell.org/package/lambdabot-xmpp-0.1.0.3 (SergeyAlirzaev)
03:03:35 <wrunt[m]> I'm stuck trying to write a lens that can target every table element in an html string and add a 'class="table"' to it. E.g. `"<html><body><p><table /></p><table /></body></html>" & packed . html . deep elements . named (only "table) . attr "class" ?~ "table"`, except that doesn't work. I'm using Text.Taggy.Lens and Control.Lens.Plated. Can anyone tell me if this is even possible with lenses?
03:19:07 <sshine> question regarding .cabal files: can I have an 'executable' that has 'hs-source-dirs: src' and a library that also has 'hs-source-dirs: src', or will those conflict? I recall seeing some project templates where the executable is put inside an 'app' directory instead.
03:19:31 <dibblego> wrunt[m]: you probably want a traversal not a lens
03:21:06 <wrunt[m]> dibblego: thanks, yeah I was being a bit imprecise saying lens. My problem seems to be that my traversals only go to top-level tags, despite my use of `deep`
03:24:20 <wrunt[m]> Text.Taggy.Lens *almost* has what I want, in `allNamed`, but it's a Fold, not a Traversal, so I can't set it
03:36:06 <__monty__> sshine: Afaik it's fine. It defaults to . and I'd expect a default to work in any case (so I'd expect the entry's name as a default if it couldn't be shared).
03:36:46 <phadej> sshine you can, but if executable uses library, than GHC will pick recompile the module and not use the compiled module from a library
03:36:58 <phadej> will choose to recompile*
03:37:18 <phadej> i.e. you can, but i'd recommend not to
03:39:42 <__monty__> Oh, good to know. Phadej, would this be appropriate to add to the docs?
03:52:05 <sshine> __monty__, phadej: thanks.
03:53:51 <phadej> __monty__: maybe some not for hs-source-dirs would be good yes
03:53:55 <phadej> some note*
04:27:00 * hackage patat 0.8.3.0 - Terminal-based presentations using Pandoc  https://hackage.haskell.org/package/patat-0.8.3.0 (JasperVanDerJeugt)
04:35:09 <sshine> with Text.Megaparsec, instead of doing x <|> y <|> z, is there some kind of 'foldr1 (<|>) [x, y, z]'?
04:35:59 <sshine> I understand that Megaparsec doesn't have specialized combinators when the generic ones in e.g. Control.Applicative are sufficient.
04:38:47 <cocreature> sshine: asum
04:38:55 <cocreature> :t asum
04:38:57 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
04:39:52 <sshine> cocreature, thanks!
04:42:56 <sshine> and is there a better alternative to 'T.pack <$> many letterChar'?
04:45:46 <cocreature> sshine: takeWhileP Nothing isLetter
04:55:33 <__monty__> phadej: Should I mention you in the PR?
04:58:17 <sshine> cocreature, thanks! now that I search for it, I realize the Megaparsec tutorial gives this example.
05:15:04 <phadej> __monty__: if you wish
05:18:05 <__monty__> Sounds more like a no than a yes, no worries.
05:41:52 <wrunt[m]> I found the answer to my question: `"<html><body><p><table /></p><table /></body></html>" & packed . html . elements . deep (named (only "table")) . attr "class" ?~ "table"`
05:51:00 * hackage foundation 0.0.25 - Alternative prelude with batteries and no dependencies  https://hackage.haskell.org/package/foundation-0.0.25 (VincentHanquez)
06:15:00 * hackage massiv 0.4.1.0 - Massiv (Массив) is an Array Library.  https://hackage.haskell.org/package/massiv-0.4.1.0 (lehins)
07:43:00 * hackage hie-core 0.0.1 - The core of an IDE  https://hackage.haskell.org/package/hie-core-0.0.1 (cocreature)
07:45:35 <ysangkok> what, i thought neil did hie-core
07:46:06 <phadej> someone else can upload the packages too
07:51:52 <cocreature> ysangkok: Neil’s team at digital asset (which I am part of) did it. Neil is no longer working for digital asset so I’m uploading it.
07:52:28 <sm[m]> hie++ !
07:53:23 <sm[m]> Neil’s zurihac video on it is well worth watching
07:53:35 <cocreature> s/zurihac/munihac/
07:54:06 <sm[m]> oops, thanks
07:54:40 <phadej> zurimuni, munizuri
07:55:47 <tdammers> semidemimunizuricohac
07:57:36 <sm[m]> https://www.reddit.com/r/haskell/comments/d0frl8/neil_mitchell_making_a_haskell_ide_munihac_2019/
07:57:47 <Batoeh> Morning.
08:10:29 <_CcC_> Hey, would anybody be able to give me advice on what is going on? I am trying to calculate fibonacchi numbers using haskell. I copy and paste the Naive def from here: https://wiki.haskell.org/The_Fibonacci_sequence#Naive_definition and I get a long hang and then a stack overflow? 
08:11:03 <_CcC_> fib 0 = 0
08:11:07 <_CcC_> fib 1 = 1
08:11:19 <_CcC_> fib n = fib (n-1) + fib (n-2)
08:11:47 <EvanR> this is where it pays to write out the evaluation steps by hand to see what happens
08:12:04 <EvanR> start with like, fib 100
08:12:27 <merijn> _CcC_: What number are you trying to compute when you get the stack overflow?
08:12:36 <geekosaur> _CcC_, did you do this into ghci?
08:12:52 <geekosaur> because you need to enter it all on one line there, or it won't work
08:13:26 <merijn> geekosaur: oooh!
08:13:28 <geekosaur> (in a file, it'll combine the equations; ghci can't know you're going to paste something else on the next line)
08:13:35 <merijn> geekosaur: Clever one, I hadn't thought about that
08:14:45 <_CcC_> geekosaur: I just put it into a file and used ":l" to load it. The function seems to work perfectly now
08:15:05 <_CcC_> Thank you all for your help!
08:15:33 <_CcC_> I am guessing that only the final line was taken into account, and it was calling fib n constantly?
08:16:39 <geekosaur> it only saw the third line, so it was recursing infinitely
08:17:37 <EvanR> fib 2 ===> fib (2-1) + fib (2-2) ===> (fib ((2-1)-1) + fib ((2-1)-2)) + fib (2-2) ===>
08:18:05 <geekosaur> they all have to be combined together in one line in ghci to work right: "fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-2)" -- and it'll know they all work together instead of overwriting fib with a new definition
08:18:26 <geekosaur> ghci can't tell what you'll be giving it next so it has to assume each input line is a complete set of equations
08:19:01 <ArthurStrong> Hi all. Am I right type classes are similar to algebraic structures like rings, semi-rings, etc?..
08:20:27 <geekosaur> not directly related
08:20:27 <EvanR> when only the last equation exists, there is no reason to ever do the n-1 or n-2, since it doesn't care what n is
08:21:02 <geekosaur> a typeclass can be used to describe algebraic structures, among other things
08:21:27 <_CcC_> geekosaur: This makes sense. Thank you :) EvanR: Got it :)
08:21:42 <ArthurStrong> geekosaur: thanks
08:22:28 <tydeu> Why does Haskell/GHC not check contexts for when select an instance of a class?
08:22:43 <tydeu> *contexts when selecting
08:24:24 <geekosaur> contexts are runtime, not compile time. there's a value passed that is a witness for the context being valid.
08:24:34 <geekosaur> it can't know at compile time, so can't select it at compile time
08:27:05 <ski> _CcC_ : you can also wrap it in `:{' (sad face) and `:}' (happy face), in the interactor, to be able to enter multiple lines at a time
08:27:42 <stepcut> Is there something like haskell-src-meta that uses the ghc-api instead haskell-src-exts? Or to put things differently, is there a library that will turn a HsExpr into an ExpQ?
08:27:44 <geekosaur> when you have a context Eq a => ..., you have a value that tells it (a) there is an Eq instance for a (b) how to make use of that instance (in ghc, it's a record of the instance methods)
08:28:00 * hackage scotty 0.11.5 - Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp  https://hackage.haskell.org/package/scotty-0.11.5 (ryanglscott)
08:28:47 <stepcut> or, perhaps even simpler if I have a variable `foo :: String`, what is the best way to turn that into an ExpQ ?
08:29:05 <EvanR> i think the question was why is the context in an instance head does not come into play when selecting instances
08:29:21 <EvanR> rather than in type sig
08:29:57 <EvanR> or class head, or something
08:30:36 <geekosaur> context's still not available then. but that one iirc is because you have to compile the entire source code at the same time to be certain the context is valid; if you are making a library, someone may use it in a program with instances you hadn't thought of a year later
08:32:01 <tydeu> geekosaur: and that reminds me once again why I think closed type classes would be a great idea
08:32:30 <geekosaur> I don't think typeclasses as such can be closed. but tht's what they added type families for — and those can be closed
08:34:24 <_CcC_> ski: cheers, i was just looking for something like this
08:34:57 <EvanR> the idea that selection does not happen at compile time doesn't sound right. Since instances are not a first class thing you can choose and pass in, some mechanism looks at your code and decides to say use the Text implementation of IsString in such and such location
08:40:29 <ski> _CcC_ : you still need to align that-which-need-to-be-aligned, though
08:48:00 <monochrom> Instance selection does happen at compile time. This is precisely enabled by refusing to use instance heads to help select instances.
08:48:55 <geekosaur> that was what I was trying to say...
08:49:16 <monochrom> Yes.
08:50:51 <monochrom> People need repetitions. The first time they aren't even listening.
08:53:50 <lavalike> what's an instance head?
08:54:25 <monochrom> "instance Eq a => Eq [a] where ..."
08:56:09 <lavalike> what part of that is not used to select instances?
08:56:17 <monochrom> "Eq a"
08:57:25 <lavalike> so if you are using (==) on a list, it picks that instance and adds the constraint, not the other way around, find an 'a' that has Eq a
08:58:03 <monochrom> Yeah. Except s/find/require/
08:58:12 * lavalike nods
08:58:42 <monochrom> There is no backtracking search, there is only love on first sight and commit and impose.
08:59:10 <lavalike> 😘
08:59:51 <EvanR> since the variable must appear right of => there is no question of what on the left can be
09:00:27 <EvanR> the direction of => in all these syntaxes doesn't make sense anymore when you think about
09:00:30 <EvanR> it
09:01:14 <monochrom> Yes on the surface.
09:03:39 <EvanR> at this point i'm not sure it should be a directional symbol?
09:04:36 <lavalike> you do get an 'Eq [a]' out of any 'Eq a'
09:05:02 <rhylx> Hi there :D
09:05:55 <EvanR> ok true
09:06:29 <rhylx> jgt: I tried to use yesod, but it seems a bit to heavy for my project. I prefer to start from scratch and start with this : https://wiki.haskell.org/Implement_a_chat_server
09:06:52 <EvanR> and this "function" is injective, does that imply you can compute an inverse
09:07:46 <rhylx> jgt: do you think it makes sense?
09:08:07 <EvanR> yes (justified to myself)
09:41:00 * hackage list-singleton 1.0.0.0 - Easily and clearly create lists with only one element in them.  https://hackage.haskell.org/package/list-singleton-1.0.0.0 (fozworth)
09:41:43 <merijn> Is this how it started with npm? >.>
09:43:50 <EvanR> hey, at least there are docs
09:44:02 <EvanR> (hypothetically, not on hackage yet)
09:44:25 <EvanR> npm would be if somehow 60% of hackage depends on list-singleton
09:45:53 <EvanR> you have to admit it would be hard to break this package with a modification
09:46:15 <EvanR> singleton :: a -> [a]; singleton x = [x]
09:51:17 <iqubic> no. no. no.
09:52:10 <iqubic> better implementation of singleton is "singleton = \a -> [a]"
09:53:37 <iqubic> because that more closely resembles the type signature.
09:58:17 <EvanR> singleton a = [a] closely resembles the computation rule
09:58:30 * hackage hasbolt-extras 0.0.0.20 - Extras for hasbolt library  https://hackage.haskell.org/package/hasbolt-extras-0.0.0.20 (ozzzzz)
09:59:46 <EvanR> (it's exactly matching...)
10:01:15 <dmwit> yeesh, https://mail.haskell.org/pipermail/libraries/2019-August/thread.html#29801
10:01:22 <dmwit> I've never seen so many mailing list messages.
10:02:00 <dmwit> It's a +0 from me because who gives a care.
10:02:20 <EvanR> which law is this
10:02:22 <merijn> dmwit: exactly
10:02:32 <cocreature> judging by the number of messages a lot of people care :)
10:02:35 <EvanR> the more insignificant the more opinions there are
10:02:42 <merijn> Wadler's law :p
10:03:13 <Lycurgus> what was the net result, in favor or opposed?
10:03:54 <merijn> Lycurgus: The net result was "over to the committee as controversial issue"
10:04:01 <Lycurgus> ah
10:04:10 <merijn> Lycurgus: libraries@ is not a democracy, so the overall count is not necessarily relevant
10:04:24 <dmwit> On April 1 I'm going to make a proposal and demand that responses be *-1 and /-1 instead +1 and -1.
10:04:36 <Lycurgus> but i meant were more for or against
10:04:50 <EvanR> I'm +2 here
10:05:21 <EvanR> the committee must be annoyed
10:06:58 <EvanR> https://twitter.com/taylorfausak/status/1159264862247280640
10:06:59 <michalrus> If I have `Generic a => a`, can I easily extract a list of values of, say `newtype UserId` inside `a`’s structure?
10:08:00 * hackage oeis2 1.0.3 - Interface for Online Encyclopedia of Integer Sequences (OEIS).  https://hackage.haskell.org/package/oeis2-1.0.3 (23prime)
10:08:12 <EvanR> basically it started as a joke on twitter
10:09:09 <lyxia> michalrus: "inside a's structure" is too vague
10:09:26 <michalrus> ik :(
10:09:54 <merijn> michalrus: You sound like you want something like uniplate
10:10:34 <merijn> Lycurgus: That answer is for quitters :p
10:10:40 <merijn> s/lycurgus/lyxia
10:11:28 <Lycurgus> well I was waiting to see if the channel would make the subjective leap on what michalrus finds easy
10:11:58 * michalrus ^.^’’’
10:12:21 <michalrus> merijn: thank you, I’ll look at that! But the tutorial seems offline. :( http://community.haskell.org/~ndm/darcs/uniplate/uniplate.htm
10:13:48 <merijn> michalrus: The github repo has a readme with a bunch of stuff
10:19:20 <iqubic> the tutorial is offline.
10:20:13 <buhman> this seems way more awkward than it should be. https://gist.github.com/buhman/7ebaa519a29d70be990eb5fcc2db074d 
10:21:05 <merijn> buhman: That does seem very awkward :p
10:21:19 <merijn> ick...Char8
10:21:35 <buhman> I'm not quite understanding the lack-of-magicness of mT. aren't MaybeT IO String and IO (Maybe String) the same type?
10:21:48 <merijn> No
10:22:08 <merijn> MaybeT is a newtype, which means it has the same representation, but it is a different type
10:22:20 <merijn> Where is System.Environment.Blank from?
10:22:28 <buhman> base?
10:22:35 <merijn> heh
10:23:02 <merijn> Once again base's foolish use of String where it needs bytestring rears it's ugly head
10:23:29 <buhman> so, how do I magic IO (Maybe String) into the newtype without my ugly solution?
10:23:44 <merijn> buhman: oh, I see what you're doing weird
10:23:53 <cocreature> apply the MaybeT constructor
10:23:56 <merijn> buhman: liftIO turns it into "MaybeT IO (Maybe String)"
10:23:59 <merijn> buhman: You want
10:24:00 <merijn> :t MaybeT
10:24:02 <lambdabot> m (Maybe a) -> MaybeT m a
10:24:06 <buhman> oh
10:24:39 <merijn> I think you're entire code turns into "pack <$> MaybeT (getEnv k)"
10:24:51 <buhman> isn't that MaybeT IO (Maybe String) though?
10:25:06 <merijn> No
10:25:07 <dmwit> `m >>= pure . f` can also be spelled `f <$> m`.
10:25:23 <merijn> buhman: "getEnv k :: IO (Maybe String)", right?
10:25:28 <merijn> :t MaybeT
10:25:28 <buhman> yes
10:25:30 <lambdabot> m (Maybe a) -> MaybeT m a
10:25:44 <merijn> :t MaybeT `asAppliedTo` (undefined :: IO (Maybe String))
10:25:45 <lambdabot> IO (Maybe String) -> MaybeT IO String
10:25:55 <buhman> interesting
10:26:11 <merijn> buhman: I mean, that's the entire point of MaybeT :p
10:28:58 <buhman> wow, that's cool
10:31:56 <lukelau> is it possible to request a bounds revision on hackage for a package you do not mantain?
10:33:27 <lyxia> you can ask the hackage trustees
10:33:41 <merijn> ^^ that
10:33:45 <merijn> and/or the maintainers
10:37:17 <lukelau> hvr: can we get a base bounds bump for hslogger? :)
10:37:55 <merijn> lukelau: There's a trustees repository for these things
10:38:01 <lukelau> lyxia: merijn: cool, was just wondering if there was an official forum for this
10:38:02 <lukelau> oh
10:56:43 <sm[m]> lukelau: there's #hackage, too
10:57:17 <hvr> lukelau: I thought I had already done so; but apparently not; it's done *now* :-)
11:04:17 <hvr> lukelau: https://matrix.hackage.haskell.org/#/package/hslogger
11:05:14 <buhman> how do I lift a (m1T e1 m1 a1) into a (m1T e1 (m2T e2 m2) a1) ?
11:05:57 <buhman> err, where m1=m2
11:06:22 <lyxia> you can't always do that
11:06:35 <lyxia> some transformers (not ContT) have a hoist* function somewhere
11:07:15 <merijn> @hackage mmorph
11:07:15 <lambdabot> http://hackage.haskell.org/package/mmorph
11:07:15 <dmwit> buhman: 1. Use the mmorph package, 2. design your m1T e1 m1 a1 action to be mtl-class-polymorphic in a way that m1T e1 (m2T e2 m2) is an instance of the appropriate class.
11:07:49 <dmwit> Those are options. Pick one; you don't need to do both (though you are free to if you want).
11:20:52 <lukelau> hvr: thanks, that was quick!
11:27:49 <buhman> wow, this is real magic
11:29:16 <EvanR> nice... with O2 (:[]) = singleton
11:29:36 <EvanR> where = means outputs equal core
11:29:57 <EvanR> (when used in the same composition chain of functions)
11:30:33 <iqubic> toList = foldMap (:[])
11:36:08 <buhman> dmwit: thanks!
11:37:05 <dmwit> What did you end up with?
11:40:22 <buhman> hoist lift $ f a
12:04:12 <Home> ciao a tutti
12:04:15 <Home> !list
12:04:15 <monochrom> Home: http://hackage.haskell.org/packages/
12:26:23 <iqubic> :t hoist
12:26:24 <lambdabot> error: Variable not in scope: hoist
12:29:53 <_CcC_> :t test
12:29:55 <lambdabot> error:
12:29:55 <lambdabot>     • Variable not in scope: test
12:29:55 <lambdabot>     • Perhaps you meant one of these:
12:30:14 <_CcC_> :t doubleMe n = n * 2
12:30:16 <lambdabot> error:
12:30:16 <lambdabot>     parse error on input ‘=’
12:30:16 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
12:30:31 <merijn> :t is for querying the type of an expression
12:30:33 <lambdabot> error: parse error on input ‘type’
12:30:34 <merijn> Not running them
12:31:08 <_CcC_> ah okay :') 
12:34:30 * hackage reflex-vty 0.1.2.0 - Reflex FRP host and widgets for vty applications  https://hackage.haskell.org/package/reflex-vty-0.1.2.0 (abrar)
12:37:27 <dmwit> But:
12:37:32 <dmwit> :t let doubleMe n = n * 2 in doubleMe
12:37:33 <lambdabot> Num a => a -> a
12:39:33 <koz_> dmwit: I never quite understood the whole 'let foo = ... in foo' construction.
12:45:30 <dmwit> Does that mean you don't understand why people choose to do it or you don't understand what it means?
12:55:00 * hackage aeson-picker 0.1.0.5 - Tiny library to get fields from JSON format  https://hackage.haskell.org/package/aeson-picker-0.1.0.5 (ozzzzz)
12:55:50 <koz_> dmwit: Both?
12:59:53 <EvanR> let a b c d = e in x y (a b c d) z ===SIMPLIFY===>  x y e z :)
13:00:15 <kaol> koz_: Is it about how let foo = 1 in foo looks like a no op? Would this be a better motivated example of the same syntax? let foo = [1..] in zip foo (tail foo)
13:00:50 <koz_> kaol: It is about how it looks like a no-op.
13:00:58 <koz_> I get the syntax of let-bindings no problem.
13:01:00 <dmwit> koz_: Okay. I find "what it means" so simple I don't know how to explain that. It's no different than any other binding you make in the language for the purpose of "what does it mean".
13:01:12 <koz_> dmwit: Let me rephrase my questions slightly.
13:01:30 <dmwit> koz_: For why people choose it: naming things is good documentation, and I (and I think most others) find let-based recursion easier to read than fix-based recursion.
13:01:31 <EvanR> let doubleMe n = n * 2 in doubleMe doesnt seem like a no op... since you can't just write :t n * 2
13:01:48 <dmwit> (You can just write :t \n -> n * 2, though.)
13:02:08 <koz_> dmwit: What do you mean by 'fix-based recursion' here
13:02:11 <koz_> ?
13:02:14 <EvanR> then i may confuse you and say "i dont understand why people write \n -> n * 2 instead of (*2) :)
13:02:25 <rhylx> Hi. I'm trying to configure my haskell environment but I'm struggling a bit with cabal and ghc-pkg
13:02:25 <dmwit> koz_: I find `let xs = 1 : xs in xs` easier to read than `fix (\xs -> 1 : xs)`.
13:02:27 <EvanR> seems like a no op
13:02:55 <koz_> dmwit: Does that just create an infinitely long list of 1s?
13:02:58 <dmwit> Yes.
13:03:06 <koz_> OK, _that_ at least I get.
13:03:12 <dmwit> I just picked a particularly simple example of recursion.
13:03:16 <dmwit> But recursion is all around us in Haskell.
13:03:40 <EvanR> recursion is just one reason to use variables
13:03:55 <EvanR> it also can make a complex expression easier to grok, naming pieces
13:03:59 <dmwit> So to make a more complicated example, I find `let fib 0 = 1; fib 1 = 1; fib n = fib (n-1) + fib (n-1) in fib` easier to read than `fix (\fib n -> case n of 0 -> 1; 1 -> 1; n -> fib (n-1) + fib (n-2))`.
13:04:03 <rhylx> So I've installed ghc, and cabal-install. The thing is that when I'm doing ghc-pkg list, I have old packages like network 2.8. How can I update or remove these packages?
13:04:16 <dmwit> EvanR: As I said: "naming things is good documentation". =)
13:04:22 <EvanR> i saw that
13:05:11 <dmwit> And by the time we get to a mutually-recursive definition, the readability win of `let` is even bigger.
13:05:14 <koz_> dmwit: OK, _that_ example I get the benefits of.
13:05:27 <EvanR> heres a straw man for you, if let bindings (without recursion) are utterly useless, then you should move the other way and do everything with no variables at all
13:06:00 <koz_> EvanR: Something something pointfree. :P
13:06:05 <EvanR> (the result would look insane)
13:06:40 <kaol> Naming things helps to avoid computing values twice.
13:06:42 <dmwit> rhylx: cabal install network, I guess
13:06:49 <shachaf> Hmm, can you use fix to do polymorphic recursion?
13:06:50 <EvanR> (the top level of haskell which has all the basic stuff defined is essentially a big let binding without the word let)
13:06:52 <dmwit> rhylx: Some packages that come with the compiler can't reasonably be upgraded.
13:07:10 <dmwit> rhylx: But with modern cabal v2-*, it's generally not necessary to update or remove packages.
13:07:36 <rhylx> dmwit: ok, yes I did install network, but then I've still the old one
13:07:41 <EvanR> let (everything ever in haskell) in main
13:07:43 <dmwit> % data Lol a = Nil a | Lol (Lol (a,a))
13:07:43 <yahb> dmwit: 
13:07:47 <merijn> dmwit: hah...depends on how often you run v2-update :p
13:07:48 <dmwit> rhylx: Why is that a problem?
13:08:22 <rhylx> dmwit: don't know, I don't really like to have outdated stuff on the computer :p.
13:08:41 <dmwit> % fix (\lol x -> case x of Nil _ -> 0; Lol y -> 1 + lol y) (Nil ())
13:08:42 <yahb> dmwit: ; <interactive>:7:6: error:; * Occurs check: cannot construct the infinite type: a0 ~ (a0, a0); Expected type: Lol (a0, a0) -> p; Actual type: Lol a0 -> p; * In the first argument of `fix', namely; `(\ lol x; -> case x of; Nil _ -> 0; Lol y -> 1 + lol y)'; In the expression:; fix; (\ lol x; -> case 
13:08:52 <dmwit> shachaf: Well, the obvious way doesn't cut it. =)
13:09:25 <rhylx> dmwit: ok, and it is adviced to use cabal v2 no?
13:09:49 <dmwit> rhylx: Okay. Well, you can use ghc-pkg describe to get detailed information on where the package is stored on your disk. Then you may use ghc-pkg unregister to tell GHC to forget it exists, and rm and friends to tell your filesystem to forget it exists.
13:10:23 <merijn> Or just nuke .cabal/.ghc once every year to clean up ;)
13:10:26 <dmwit> rhylx: However, I recommend doing this only if you want to learn in a highly detailed way how GHC and cabal interact by figuring out how to fix things when they break. =)
13:10:55 <dmwit> rhylx: Yes, the v2-* stuff is the recommended way now. In new enough cabal's, they are the default.
13:11:49 <rhylx> dmwit: ok, I won't mess things up in this case. On Arch Linux, it does not seem to be default
13:12:13 <merijn> Arch's haskell packages are completely broken anyway
13:12:38 <rhylx> merijn: ok. Which distro is the most uptodate?
13:12:58 <rhylx> merijn: *concerning haskell
13:13:00 <merijn> No clue, I always install GHC directly myself
13:13:03 <dmwit> Arch is fine so long as you get GHC yourself rather than through the package manager.
13:13:12 <dmwit> e.g. ghcup is popular for this.
13:13:21 <merijn> (to avoid being affected by differences across different unices)
13:13:40 <dmwit> Personally I still just grab the official release tarballs from the GHC website and do the ./configure && make install thing.
13:14:20 <rhylx> Ok. And concerning cabal?
13:14:50 <merijn> If you have a working GHC it's fairly easy to build directly from github, but there's official binaries too, I think
13:15:30 * hackage list-singleton 1.0.0.1 - Easily and clearly create lists with only one element in them.  https://hackage.haskell.org/package/list-singleton-1.0.0.1 (fozworth)
13:15:30 <rhylx> Ok. The only thing right now cabal seems to be useful for me is for installing packages.
13:15:49 <merijn> rhylx: And building whatever you work on...
13:16:42 <rhylx> Right now I've as project (for learning haskell) to build a chat app and I need to use the network package.
13:17:21 <rhylx> Do you install every package by hand?
13:17:27 <merijn> No
13:17:50 <merijn> tbh, I never install packages at all. I just have cabal build my code and take care of installing things when needed
13:18:06 <dmwit> same
13:18:53 <dmwit> Well, almost same. I guess I'm in the minority these days, but I do still maintain a sandbox that I toss random packages in for when I want to just try something real quick without cooking up a full project infrastructure.
13:19:11 <dmwit> So I'll install into that sandbox, and never feel bad about nuking and repaving it.
13:19:22 <dmwit> But for normal project development, I'm not installing anything manually.
13:19:23 <merijn> dmwit: I recall there was a way to do that with v2- too, but I can't recall how. Ask hvr
13:19:28 <rhylx> Yes Okok. And so you also build cabal directly without using pacman
13:19:42 <dmwit> Yeah, environments are the way you're supposed to be able to do that now.
13:19:46 <merijn> dmwit: You can install "in" .ghc.environment files explicitly too
13:20:12 <dmwit> rhylx: Yes, the simplest is to avoid pacman entirely for Haskell things.
13:20:22 <merijn> rhylx: You can probably install cabal via your package manager just fine. It's just that a lot of machines I work on I don't have root, so I can't use package managers anyway :)
13:20:29 <dmwit> It is possible to make the pacman stuff work, but it's frustratingly hard. The Arch wiki has a page on it.
13:21:31 <rhylx> Ok. So I will try to build ghc and cabal  by hand
13:22:27 <merijn> rhylx: I wouldn't build GHC by hand (that's kinda tricky, since you need a GHC to do so), dmwit was referring to the official pre-built binaries you can download
13:22:43 <MarcelineVQ> I'd be inclined to go the ghcup route, it's available on the aur
13:23:51 <dmwit> merijn nailin' it, as usual
13:24:47 <rhylx> Ok. Yes MarcelineVQ, I will first try ghcup. It also provides a way to manage haskell packages?
13:25:05 <merijn> rhylx: ghcup is just a script to install GHC and cabal
13:25:46 <rhylx> merijn: ok. I will try it then
13:27:22 <dmwit> Oh, maybe you thought I was recommending building GHC because I said I do the ./configure && make install thing.
13:27:32 <dmwit> If so, you are the 1,000,000th visitor to this troll.
13:27:34 <rhylx> Oh, and I have an other question. Do you guys think that this is a good starting point for building the server for my app : https://wiki.haskell.org/Implement_a_chat_server
13:28:03 <dmwit> GHC binary releases use configure and make for choosing installation locations without the GHC devs having to learn a second tool than what they already use for building. ^_^
13:28:31 <rhylx> dmwit: yep, sorry was reading to fast. At least I'm not the only one :p
13:30:38 <rhylx> ghcup still install ghc 8.6.5
13:31:58 <merijn> "still"
13:32:12 <merijn> GHC 8.8 hasn't been out for more than a week or so...
13:32:23 <lavalike> if you do "ghcup list" you'll see it tagged 8.6 as recommended but lets you install 8.8 (tagged latest)
13:32:24 <rhylx> Okok :).
13:32:33 <rhylx> Nethermind
13:32:36 <merijn> rhylx: Personally I wouldn't recommend upgrading to 8.8 for the next half year or so, especially if you're a beginner
13:33:09 <merijn> rhylx: Upgrading to very new GHC releases is a great way to discover how all the packages all the books and stuff talk about haven't been updated yet :p
13:41:06 <dmwit> "Nethermind" translation: I give up on Haskell. =P
13:43:38 <MarcelineVQ> Maybe, it's not their first time in here though, they'd like to make a messaging app of some kind
13:47:13 <MarcelineVQ> lexi-lambda: https://lexi-lambda.github.io/blog/2018/02/10/an-opinionated-guide-to-haskell-in-2018/ can you put an anchor in for "Understanding stack’s model and avoiding its biggest gotcha" so I can link that every single time someone asks about stack install in here :>
13:47:36 <MarcelineVQ> I wish that alias would just be removed
14:05:05 <shapr> I fought with that that weird error with unix-time for hours, but "cabal new-clean" solved the problem. I'm beginning to wonder if I should have gotten ECC RAM
14:07:33 <shapr> oh, they're back when I force use of unix-time >= 0.4
14:07:39 <shapr> but it worked before, vafan?
14:29:00 * hackage generic-random 1.3.0.0 - Generic random generators  https://hackage.haskell.org/package/generic-random-1.3.0.0 (lyxia)
14:40:15 <buhman> if I have a  ExceptT e (ReaderT e1 m) a  and a  ExceptT e (ReaderT e2 m) a  , is there an easy way to run one inside the other, provided an e2?
14:47:35 <lavalike> :t mapExceptT . withReaderT . const
14:47:37 <lambdabot> r -> ExceptT e' (ReaderT r m) b -> ExceptT e' (ReaderT r' m) b
14:48:02 <koz_> lavalike: Should be named 'reread'. :P
14:48:11 <lavalike> ^^
14:59:16 <buhman> wow, much simpler than what I was attempting
14:59:56 <lavalike> those transformers are nice enough to provide functions to fiddle with the non-last type param stuff
15:02:25 <koz_> What does the PVP say about adding new type class instances to an existing (new)type and affecting the version?
15:02:31 * hackage lambdabot-xmpp 0.1.0.4 - Lambdabot plugin for XMPP (Jabber) protocol  https://hackage.haskell.org/package/lambdabot-xmpp-0.1.0.4 (SergeyAlirzaev)
15:05:31 <dmwit> koz_: if only new bindings, types, classes, non-orphan instances or modules (but see below) were added to the interface, then A.B MAY remain the same but the new C MUST be greater than the old C. 
15:05:42 <koz_> dmwit: Thanks.
15:12:19 <sm[m]> Marceline: whereas I use stack install all the time
15:23:56 <MarcelineVQ> sm[m]: But I would bet you understand it
15:28:03 <sm[m]> Certainly, it’s pretty simple
15:28:38 <sm[m]> “Copy the result of stack build to somewhere I can run it”
15:32:30 <MarcelineVQ> And implicitly make available the lib related to that build to the specific resolver in scope.
15:42:49 <sm[m]> Sure, but who cares :)
15:50:10 <MarcelineVQ> Because that latter part occasionally making libs available to ghci causes newbies to think install is doing what they think it is, which leads to confusion/anguish when it doesn't.
15:50:54 <MarcelineVQ> I think install not being a thing would lead to better questions
15:51:53 <MarcelineVQ> And, this is a forlorn and surely unrequited hope, maybe slightly closer examination of documentation.
15:54:39 <sm[m]> I don’t think that’s a problem common or serious enough to remove the command, but YMMV
15:55:18 <sm[m]> Docs and UX can always be improved, though
15:55:58 <MarcelineVQ> I don't think the docs are in bad shape for this issue, I meant it could lead to newbies actually reading them
15:57:07 <MarcelineVQ> stack install is by far the command most asked about in this channel, when I'm paying attention anyway
15:58:41 <MarcelineVQ> I'd rather someone asked how they use/get libraries than ask why stack install isn't working right, the first one has a much more direct answer and requires less re-questioning to get started answering it
15:59:41 <MarcelineVQ> Not that I'm starting some crusade, just my thoughts at this time :>
16:16:29 <sm[m]> I hear you :)
16:33:48 --- mode: ChanServ set +o monochrom
16:37:28 --- mode: monochrom set -o monochrom
17:22:00 * hackage gauge 0.2.5 - small framework for performance measurement and analysis  https://hackage.haskell.org/package/gauge-0.2.5 (VincentHanquez)
17:33:31 * hackage vega-view 0.1.0.0 -   https://hackage.haskell.org/package/vega-view-0.1.0.0 (DouglasBurke)
17:51:00 * hackage haskell-lsp-types 0.15.0.1 - Haskell library for the Microsoft Language Server Protocol, data types  https://hackage.haskell.org/package/haskell-lsp-types-0.15.0.1 (luke_)
17:52:00 * hackage haskell-lsp 0.15.0.1 - Haskell library for the Microsoft Language Server Protocol  https://hackage.haskell.org/package/haskell-lsp-0.15.0.1 (luke_)
18:20:31 * hackage haskell-lsp-types 0.16.0.0 - Haskell library for the Microsoft Language Server Protocol, data types  https://hackage.haskell.org/package/haskell-lsp-types-0.16.0.0 (luke_)
18:22:01 * hackage haskell-lsp 0.16.0.0 - Haskell library for the Microsoft Language Server Protocol  https://hackage.haskell.org/package/haskell-lsp-0.16.0.0 (luke_)
18:36:58 <Guest20> Hey. I created a datatype `ValidationTaggedNel` and derived some instances using -XDerivingVia
18:37:26 <EvanR> f 0 = 0; f n = f (n-1) + 2 -- so apparently this function doubles it's argument (n >= 0)
18:37:35 <EvanR> i wonder what happens if you change the 2 to 1
18:37:40 <Guest20> I'd like to know if this datatype and what I'm doing makes sense.
18:38:47 <Guest20> https://pastebin.com/twR4Q6iJ
18:38:50 <iqubic> If you change the 2 to a 1 then you get a much slower version of id over Num a
18:39:14 <EvanR> ah
18:40:16 <EvanR> wait
18:40:23 <EvanR> ok yeah
18:42:20 <iqubic> f 0 _ = 0; f n x = f (n-1) x + x -- is the same as n * x
18:47:08 <jle`> Guest20: maybe? what are you trying to use it for, heh
18:48:23 <Guest20> jle`: I have instances for the Tagged errors.
18:48:51 <Guest20> e.g `Pretty (Tagged '(SomeType, "Exn") ...)`
18:50:18 <Guest20> So I'd either write a type synonym to get this "dispatching mecanism".
18:50:53 <Guest20> Or write it by hand (repetitive, error prone ...).
18:51:32 <Guest20> Or use a newtype (extra safety guarantee that the error actually references what it tags).
18:58:46 <dansho> does anyone know how to declare a vector with hmatrix-backprop? this doesn't seem to work https://paste.ee/p/Q0dmG
19:01:49 <jle`> dansho: it looks like you're not using any backprop things, so you would just use the ones from hmatrix i think
19:02:28 <jle`> hmatrix-backprop only handles the backprop, but the data types all come from hmatrix
19:03:13 <dansho> vector is from backprop
19:06:11 <lyxia> vector $ convert $ ...
19:06:51 <lyxia> https://hackage.haskell.org/package/vector-sized-1.2.0.1/docs/Data-Vector-Generic-Sized.html#v:convert
19:07:06 <dansho> convert is not in scope?
19:08:23 <lyxia> import Data.Vector.Generic.Sized (convert)
19:10:54 <dansho> that didn't quite work: https://paste.ee/p/76PWr
19:12:35 <jle`> dansho: vector from hmatrix-backprop is a way to construct a vector in a "backprop-aware" way, from a vector of BVars to a BVar of a vector
19:12:49 <jle`> Vector n (BVar s Double) -> BVar s (Vector n Double)
19:13:08 <jle`> it's a way to represent a backpropagatable vector creation
19:13:21 <jle`> but it's not a way to construct a vector compatible with hmatrix :)
19:14:12 <jle`> you can create a vector from vector-sized with something like `VS.fromTuple (1,2)`
19:14:35 <jle`> or you can create a vector from hmatrix using hmatrix methods and then convert it to a vector-sized vector using rVec
19:15:12 <jle`> dansho: but in this case it looks like you just want to create a vector and show it, so you don't really need any backprop stuff
19:15:16 <dansho> what i am trying to write is evalBP0 $ constVar $ H.vector [1.0, 2.0]
19:15:34 <dansho> but i can't seem to declare the right type
19:16:02 <dansho> that should give back the R 2?
19:16:28 <jle`> that should work, evalBP (constVar (H.vector [1.0,2.0])) :: R 2 should give you back the original vector
19:16:49 <jle`> in general evalBP (constVar x) should be x
19:16:56 <jle`> * evalBP0
19:17:41 <dansho> https://paste.ee/p/lHCHp
19:18:07 <jle`> dansho: ah, that's because there is no information on what size vector type you want
19:18:18 <jle`> you can do (H.vector [1,2] :: H.R 2)
19:18:42 <jle`> or you can use something like H.vec2 :: Double -> Double -> H.R 2, so ghc knows the size of the type
19:18:53 <dansho> oh, needed some type annotation =)
19:19:05 <jle`> ah, were you using the 'unsized'/unstatic hmatrix interface earlier?
19:19:20 <jle`> hmatrix-backprop should ideally also support it too, but i haven't had the time to port over the interface
19:19:38 <jle`> i've only made my way through the static module at this point unfortunately
19:19:43 <dansho> yes i was asking about it yesterday
19:20:31 * hackage which 0.1.0.0 - Determine the full path to an executable.  https://hackage.haskell.org/package/which-0.1.0.0 (abrar)
19:21:20 <jle`> it'd be nice to have the unsized interface ported as well. it's just a lot of functions to just go in and mechanically port :'(
19:38:43 <remexre> what're people's favorite "intro to comonads" resource(s)?
19:41:43 <jle`> hmm i always liked tomas petricek's phd thesis, which is an interactive demo
19:41:54 <jackdk> remexre: I found the diagrams in https://www.youtube.com/watch?v=6eiS2QTQKPE you'll have to translate the scala as you read it but that's fine
19:42:01 <jle`> oh that's more coeffects than comonads
19:42:16 <remexre> jackdk: heh, I'm actually at 5:30 of that right now
19:42:20 <jackdk> sorry, I accidentally a word. I found the diagrams in <link> *helpful*
19:42:28 <jle`> i always liked the late ertesx's incomplete blog post on the matter, let me see if i can find it
19:43:24 <jle`> here we go https://hub.darcs.net/ertes/articles/browse/media-processing.lhs
19:43:45 <remexre> jle`: Okay, I'll give that a read after the vid; thanks!
19:52:11 <ArthurStrong> Hi all. What math background do you recommend to be learnt to get better on Haskell type system? Set theory?
19:52:54 <jle`> i think it depends on what your goal is
19:53:12 <jle`> if you want to get better so that you can write programs effectively...then i don't think there is too much math background necessary
19:53:13 <EvanR> monochrom has a webpage for this
19:53:22 <jle`> maybe algebra (addition, multiplication)
19:53:31 <EvanR> can't find it on google
19:53:42 <jle`> if you want to get better so you can explore creating new abstractions in haskell, then maybe abstract algebra or cat theo
19:54:02 <ArthurStrong> jle`: thanks
19:54:14 <jle`> but yeah, nothing relaly needed to actually write programs in haskell
19:55:06 <EvanR> on that page, it claims you all you really need is to be able to substitute stuff in for variables
20:00:51 <MarcelineVQ> EvanR: http://www.vex.net/~trebla/haskell/prerequisite.xhtml
20:10:48 <ArthurStrong> Am I right I can simulate Haskell-like lazy evaluation in Scheme if I add "lazy" on every function's argument?
20:12:34 <EvanR> it won't fully simulate it
20:13:12 <EvanR> another lazy aspect of haskell is record fields, data field, and the two things in a pair are also lazy
20:13:25 <ArthurStrong> EvanR: OK, but it is close?
20:13:31 <EvanR> also check out that link MarcelineVQ pasted
20:13:35 <EvanR> close?
20:13:40 <ArthurStrong> close to it?
20:15:39 <EvanR> theres also the feature of lazy pattern matching, which adds even more laziness
20:15:59 <ArthurStrong> If I delay all evaluations, at the very end, I'm getting a big expression tree, which can be evaluated from root. Isn't it lazy evaluation?
20:16:04 <EvanR> and i might be remembering this wrong, but theres a flag for "full laziness" maybe
20:16:16 <EvanR> that might be something unrelated to what youre asking though
20:17:30 <EvanR> yeah if you do that you will get the same results as haskell
20:17:44 <EvanR> assuming its a pure computation, no I/O
20:17:47 <ArthurStrong> EvanR: thanks
20:17:47 <EvanR> no side effects
20:18:57 <EvanR> well. it still leaves the question of how you do that evaluation
20:19:19 <EvanR> delaying is one thing, but after that order matters
20:20:23 <ArthurStrong> EvanR: order of what?
20:20:29 <EvanR> order of evaluation
20:25:33 <EvanR> eager and lazy evaluation both begin with an expression tree and differ in what order sub expressions are evaluated in
20:37:48 <remexre> jackdk, jle`: after seeing both of those, I feel like I get comonads now; thanks!
20:40:19 <koz_> Such comonad, very extract.
20:40:45 <EvanR> the ratio of comonad tutorials to monad tutorials is approximately the same as the ratio of usefulness of comonads to monads
20:40:50 <jle`> 'i know kung fu'
20:55:41 <remexre> :P I wanted to grok https://brianmckenna.org/blog/type_annotation_cofree
22:08:39 <mpiechotka> If I combine indexed fold with unindexed one I get indecies from the inner one - a ^@.. ifolded . folded --> [(0,(Just 'a',1)),(1,(Just 'b',0)),(0,(Just 'b',0))] instead of [(0,(Just 'a',1)),(0,(Just 'b',0)),(1,(Just 'b',0))] where a = V.fromList [V.fromList [(Just 'a', 1), (Just 'b', 0)], V.fromList [(Just 'b', 0)]]. What am I doing wrong?
22:09:33 <mpiechotka> Ok. <. worked I don't know why I haven't noticed it.
22:18:31 * hackage polysemy-zoo 0.6.0.0 - Experimental, user-contributed effects and interpreters for polysemy  https://hackage.haskell.org/package/polysemy-zoo-0.6.0.0 (isovector)
22:21:16 <kaol> I found myself writing do { (a,b) <- id; return $ ... }. Perhaps I should just use a lambda instead.
22:22:17 <jle`> ...i can imagine literally no reason why i would ever write that instead of a lambda, heh.  maybe layouting?
22:22:27 <jle`> i'm curious
22:24:24 <kaol> I was using something like "(&&) <$> fst <*> not . snd" next to it and I had another case where I needed to reuse a value and "naturally" moved over to using a monad. Until I saw how silly I was being.
