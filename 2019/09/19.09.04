00:00:03 <jle`> which is nonsense :)
00:00:08 <bolver> correct
00:00:37 <jle`> so f x = \y -> print (sqrt x y), or f x y = print ((sqrt x) y)
00:00:51 <HaskellNoob> cool, I think GADTs will solve my specific problem thanks guys
00:00:59 <jle`> so that's why the type of f has two parameters, (a -> a1) and a
00:01:24 <jle`> now, as to why the (a -> a1) comes up --- look at the type of sqrt.  it's sqrt :: Floating t => t -> t
00:01:37 <bolver> correct
00:01:39 <jle`> and we're applying (sqrt x) to y
00:01:58 <jle`> so that means that (sqrt x) has to be (a -> b), since it has to be a function
00:02:15 <jle`> and because sqrt takes something of the same type it returns, it means that x must also be (a -> b)
00:02:30 <jle`> so, f x y = print ((sqrt x) y); f :: (a -> b) -> a -> IO ()
00:02:51 <jle`> er well, f :: Floating (a -> b) => (a -> b) -> a -> IO ()
00:02:58 <VaNilLa[m]> why doesn't this error when there's no instane for Floating (a -> b) ?
00:03:27 <jle`> because there could potentially be an instance for Floating (a -> b) at the point where someone calls f
00:03:57 <jle`> you could import it and define instance Floating (String -> Double), and then call it with (String -> Double)
00:03:58 <VaNilLa[m]> makes sense
00:04:43 <VaNilLa[m]> Can you actually do that? I once tried to define a monad instance for a function, and I don't remember that succeeding.
00:05:02 <jle`> you can define a Floating instance associated with any Applicative f
00:05:11 <jle`> sqrt = fmap sqrt
00:05:17 <jle`> pi = pure pi, etc.
00:05:42 <VaNilLa[m]> huh. neat
00:05:48 <jle`> so we can have instance Floating a => Floating [a], for instance, where sqrt = fmap sqrt; pi = pure pi; logBase = liftA2 logBase, etc.
00:06:11 <bolver> jle`: suppose i type print . sqrt 9 in ghci
00:06:44 <jle`> if you just type print . sqrt 9 into ghci, the first thing it'll try to do is 'Show' it (if it's not an IO action)
00:06:50 <bolver> it reports an error message with type as  (Floating (a -> a1), Show a1) => a -> IO ()
00:06:56 <jle`> and by default there is no Show instance for functions
00:07:16 <jle`> bolver: do you see how we got the type of 'f' up there?
00:07:37 <bolver> sorry i typed :t print . sqrt 9 in ghci
00:07:48 <jle`> hm, it shouldn't be an error
00:07:53 <jle`> it works fine on my ghci :)
00:08:13 <jle`> but yeah, print . sqrt 9 = \y -> print (sqrt 9 y)
00:08:26 <jle`> so it's a function that takes some (a -> b), square roots it, and prints it
00:08:41 <bolver> so in this case why does ghc not say the type is (a -> a1) -> a -> IO ()?
00:08:45 <jle`> er sorry, it takes some y, applies (sqrt 9) to it, then prints it
00:08:59 <bolver> i am just reasonong from your explanation before
00:09:01 <jle`> `\x -> print . sqrt x` would have (a -> b) -> a -> IO ()
00:09:09 <jle`> but print . sqrt 9 has a -> IO ()
00:09:12 <jle`> you pre-apply the x, essentially
00:09:19 <jle`> you're providing 9 as your (a -> b)
00:09:37 <bolver> i see
00:09:50 <jle`> so if you have a function X -> Y -> Z, and you give it an X, then you get a Y -> Z in return
00:09:52 <bolver> so what is the 'a' in the type then?
00:10:07 <jle`> in the full form we had \x y -> print ((sqrt x) y)
00:10:12 <jle`> the y is the thing you apply (sqrt x) to
00:10:21 <VaNilLa[m]> whatever the a is in 9 :: a -> b, right?
00:10:28 <jle`> or for \y -> print ((sqrt 9) y), the y is the thing you apply (sqrt 9) to
00:11:27 <bolver> jle`: i see
00:11:46 <VaNilLa[m]> why does this unify? `Int` can't unify with `(a->b)`, so print . sqrt 9 would infer 9 to be a -> b, no? 
00:13:17 <bolver> jle`: thanks
00:13:28 <bolver> that was very clear
00:13:44 <bolver> i have 1 more sort of dumb question
00:14:32 <bolver> just playing around to understand error messages, especially inferred type signatures by ghc
00:14:41 <bolver> i typed  :t 5 6 in ghci
00:14:55 <dminuoso> bolver: The thing is, forget the constraints for a second.
00:14:58 <dminuoso> % :t 5
00:14:59 <yahb> dminuoso: Num p => p
00:15:02 <dminuoso> bolver: Do you see that type variable?
00:15:04 <bolver> and it gave 5 6 :: (Num a, Num (a -> t)) => t
00:15:20 <bolver> yes
00:16:02 <bolver> so my question is -- why does ghc infer this type signature?
00:16:24 <dminuoso> bolver: So because they are juxtaposed, it assumes that the left hand side must be a function
00:16:34 <bolver> it sees 5 as both Num and a function and it comes up Num(a->t)?
00:16:55 <dminuoso> bolver: Because 5's type is just `p` (constrained by Num p), it can specialize `p` into say a function.
00:16:58 <dminuoso> And thats a perfectly valid thing to do.
00:17:11 <bolver> i see
00:17:22 <bolver> but 5 is also Num p
00:17:30 <dminuoso> bolver: The Num is a constraint!
00:17:30 * hackage clash-prelude 1.0.0 - CAES Language for Synchronous Hardware - Prelude library  https://hackage.haskell.org/package/clash-prelude-1.0.0 (QBayLogic)
00:17:40 <bolver> yes
00:17:47 <bolver> sorry, i mis-typed
00:17:49 <dminuoso> bolver: So 5 is not Num p.
00:18:12 <bolver> 5 :: Num a => a
00:18:15 <VaNilLa[m]> 5 :: Num a, 6 :: Num b. they're specialized separately
00:18:30 * hackage clash-ghc 1.0.0, clash-lib 1.0.0 (QBayLogic): https://qbin.io/token-jacket-0y9u
00:18:37 <VaNilLa[m]> 5 :: Num a => a, 6 :: Num b => b *
00:18:39 <dminuoso> bolver: Lets consider something without constraints for a second.
00:18:42 <dminuoso> Because they add additional confusion.
00:18:47 <dminuoso> % :t ($)
00:18:48 <yahb> dminuoso: (a -> b) -> a -> b
00:18:53 <dminuoso> % :t id
00:18:54 <yahb> dminuoso: a -> a
00:18:56 <dminuoso> % :t flip
00:18:57 <yahb> dminuoso: (a -> b -> c) -> b -> a -> c
00:18:59 <dminuoso> % :t flip id
00:18:59 <yahb> dminuoso: b -> (b -> c) -> c
00:19:26 <dminuoso> bolver: id can be specialized into ($), iow id and ($) can unify together.
00:19:28 <bolver> ok
00:19:36 <dminuoso> % :t [id, ($)]
00:19:36 <yahb> dminuoso: [(a -> b) -> a -> b]
00:19:58 <dminuoso> bolver: The reason is that `id` is a very general type. `a -> a` - we can freely pick what `a` is going to be.
00:20:08 <bolver> ok, i see
00:20:26 <dminuoso> So `(p -> q) -> p -> q` is a valid specialization of `id`
00:20:39 <bolver> i see
00:21:00 <bolver> same with Num p, we can pick whatever we want for p, then?
00:21:16 <dminuoso> bolver: In principle yes. There's just that additional constraint that whatever you pick for it, it must satisfy Num!
00:21:21 <Ariakenom> with some additional parens: (p -> q) -> (p -> q)
00:21:24 <dminuoso> iow: there must exist an instance Num for whatever you pick
00:21:42 <dminuoso> bolver: You can pick a function for it too, which just causes GHC to look for an instance.
00:21:42 <VaNilLa[m]> bolver: if `6 :: Num a => a`, we can pick a to be `b -> c`
00:21:45 <bolver> correct, which in this case is invalid -- you can't have Num (a->t)
00:21:50 <dminuoso> bolver: Sure you can!
00:21:54 <dminuoso> You can define an instance.
00:22:04 <dminuoso> And then GHC wont complain.
00:22:06 <bolver> i see
00:22:22 <Lears> You can and frankly we aught to have one where 5 6 == 5.
00:22:23 <dminuoso> (Although writing a correct instance is not possible, you can just throw undefined everywhere)
00:22:37 <bolver> i see
00:22:56 <VaNilLa[m]> Lears: why 5 6 == 5?
00:23:44 <bolver> so how do you explain the type signature reported by ghc for 5 6?
00:24:04 <dminuoso> bolver: The type inference deduces that if you juxtapose two things, that the left thing must be a function.
00:24:14 <bolver> correct
00:24:28 <dminuoso> % :t 5 6
00:24:28 <yahb> dminuoso: (Num t1, Num (t1 -> t2)) => t2
00:25:08 <VaNilLa[m]> bolver:  5 :: Num a => a, 6 :: Num b => b. Since 5 is applied to something, a = c -> d. since c -> d  is applied to b, c = b, and a = b -> d. 
00:25:20 <dminuoso> bolver: It further deduces, that if thats a function, it must return something. GHC furthermore knows that since `5 :: Num p => p`, we must keep a constraint Num on whatever we specialize p to be.
00:25:45 <dminuoso> bolver: And it also knows that `6 :: Num q => q`, so the input type is also constrained by Num
00:26:00 <dminuoso> bolver: And thats expressed by the type signture.
00:26:09 <VaNilLa[m]> bolver: thus, we get that 5 :: Num (b -> d) => b -> d  and 6 :: Num b -> b
00:26:25 <VaNilLa[m]> Num b => b *
00:27:04 <bolver> so 5 6 :: (Num a, Num (a -> t)) => t
00:27:18 <dminuoso> bolver: Yup.
00:27:34 <bolver> the 'a' refers to 6 then?
00:27:44 <VaNilLa[m]> yep
00:27:46 <dminuoso> bolver: Yes.
00:27:58 <Lears> VaNilLa[m]: Interpreting a number as a function, I don't see a good altertative to having it be the constant function producing that number. It's also works out and is used by mathematicians already.
00:29:16 <VaNilLa[m]> Lears: What about church encoded integers, where `5 = \f -> f . f . f . f . f`
00:29:17 <bolver> dminuoso: i see
00:29:50 <VaNilLa[m]> obviously these can't represent negatives
00:29:54 <bolver> i have to go now
00:30:01 <bolver> thansks for the help
00:30:14 <bolver> will continue the conversation another time
00:30:26 <Lears> Really, the core of the instance is `(f + g) x = f x + g x` and `(f * g) x = f x * g x`. Needing 0 and 1 to be identities respectively, they *must* always produce 0 and 1 in the target type.
00:31:13 <dminuoso> Now that bolver is gone, why exactly does `5 6` itself not complain about a `missing instance for Num (a -> t)` ?
00:31:54 <VaNilLa[m]> probably because :t doesn't care about what instances are visible?
00:31:59 <VaNilLa[m]> that would be my guess.
00:32:28 <dminuoso> VaNilLa[m]: You can create a binding with that fine
00:32:32 <dminuoso> % :set -XAllowAmbiguousTypes
00:32:32 <yahb> dminuoso: 
00:32:36 <dminuoso> % :set -XFlexibleContexts
00:32:37 <yahb> dminuoso: 
00:32:39 <dminuoso> % x = 5 6
00:32:39 <yahb> dminuoso: ; <interactive>:102:5: error:; * No instance for (Num (Integer -> t0)) arising from the literal `5'; (maybe you haven't applied a function to enough arguments?); * In the expression: 5; In the expression: 5 6; In an equation for `x': x = 5 6
00:32:46 <dminuoso> Huh! It worked for me.
00:33:24 <dminuoso> % :set -XNoMonomorphismRestriction
00:33:24 <yahb> dminuoso: 
00:33:25 <dminuoso> % x = 5 6
00:33:26 <yahb> dminuoso: 
00:33:27 <dminuoso> There we go.
00:33:59 <VaNilLa[m]> huh. What's Monomorphism Restriction?
00:34:44 <dminuoso> VaNilLa[m]: It's a feature that sometimes causes types to be monomorphized, even though they should be kept generalized according to HM.
00:34:55 <dminuoso> VaNilLa[m]: It's basically an important optimization feature.
00:35:16 <Lears> Also, the church encoded naturals are `forall a. (a -> a) -> a -> a` if my thinking is right. But that's just an encoding of the nats that happens to use functions; it doesn't give you utility in working with functions that produce numbers of arbitrary type.
00:37:06 <VaNilLa[m]> Lears: you're right. It would work in the context of 5 6, though.
00:37:43 <VaNilLa[m]> dminuoso: thanks
00:38:00 <dminuoso> % f1 x = show x
00:38:00 <yahb> dminuoso: 
00:38:09 <dminuoso> :set -XMonomorphismRestriction
00:38:12 <dminuoso> % :set -XMonomorphismRestriction
00:38:12 <yahb> dminuoso: 
00:38:18 <dminuoso> % f2 = \x -> show x
00:38:19 <yahb> dminuoso: 
00:38:21 <dminuoso> % :t f1
00:38:22 <yahb> dminuoso: Show a => a -> String
00:38:23 <dminuoso> % :t f2
00:38:24 <yahb> dminuoso: () -> String
00:38:37 <dminuoso> VaNilLa[m]: ^- this is the monomorphism kicking in (because f2 is not a function binding and it doesnt have a type signature)
00:39:48 <VaNilLa[m]> dminuoso: that's cool, thank you! this helps with writing specialized functions with optimizations that can only be done for a known type, right?
00:40:15 <dminuoso> VaNilLa[m]: The intention is rather, that memoization would unexpectedly not work in many cases.
00:41:15 <dminuoso> VaNilLa[m]: The thing is, as long as a binding is polymorphic, it can't be memoized/shared. This would cause (potentially expensive) recomputation of bindings when you would expect sharing instead.
00:42:44 <VaNilLa[m]> oh! so instead of reconstructing a global variable a = [1,  2, 3, 4, 5] which is of type Num a => [a], it monomorphizes it to a :: [Int], and thus it doesn't need to rebuild the graph for a? 
00:43:10 <dminuoso> VaNilLa[m]: Well [Integer], but yes.
00:43:45 <dminuoso> VaNilLa[m]: [1,2,3,4,5] is of course not an expensive thing, but perhaps `a` binds to some expression that calculates a list of numbers.
00:43:47 <VaNilLa[m]> that's clever. Thanks!
00:44:05 <dminuoso> VaNilLa[m]: So if you force `a` and it evaluates that list, if it was polymorphic, it would have to re-evaluate the list every time (assuming no other optimizations kicked in)
00:44:19 <dminuoso> If its monomorphic, it would be almost guaranteed to be shared.
00:44:26 <dminuoso> (That is, memoized)
00:45:09 <VaNilLa[m]> makes sense
00:45:36 <pigmej[m]> Heya, Why does `data` type declaration have to be in the same file as fuctions using it? Is there any way to avoid it? (I need Show and Generic)
00:45:42 <dminuoso> It was a deliberate choice between either "introduce a non-obvious gotcha in the type system" or "introduce a non-obvious gotcha in performance"
00:45:45 <pigmej[m]> Can anyone point me to some explaination?
00:46:09 <VaNilLa[m]> although, I thought optimizations were not supposed to alter the meaning of programs; in your GHCi example, an invalid expression was made valid?
00:47:19 <dminuoso> VaNilLa[m]: Well the semantics of the MonomorphismRestriction are defined in the Haskell report itself. 
00:47:27 <VaNilLa[m]> pigmej: I don't think a data type declaration has to be in the same file as functions using it; you might need to use imports from one file / module to another?
00:47:57 <pigmej[m]> Well then you have some error about constructor not in the scope
00:47:59 <dminuoso> VaNilLa[m]: Now you could say "Adding a type signature changes code? What" - and indeed, that's a surprising *feature* of Haskell. Not our finest, but its part of the semantics of the language.
00:48:00 <VaNilLa[m]> oh, it's defined at the semantics level. 
00:48:19 <pigmej[m]> I've imported it correctly I think.. (and exported too)
00:48:36 <dminuoso> VaNilLa[m]: Arguably its better to have the occasional type error (because those are fast to fix) rather than the occasional performance bug (those can take quite a while to track down)
00:48:54 <Lears> pigmej[m]: Perhaps you only exported the type, and not the constructors.
00:49:07 <pigmej[m]> Hmmmmm
00:49:34 <jle`> @tell bolver fwiw i feel like the issue here is a wart/bad spot of the way haskell's type system and libraries is set up.  it comes from a lot of things that should give errors, but don't -- for example, usually using a number as a function is not what people want, and shouldn't typecheck.  the fact that it checks and is happy is not that great usability wise
00:49:34 <lambdabot> Consider it noted.
00:49:35 * VaNilLa[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/NBISgHXNlCNoPoybWNAdXnfv >
00:49:49 <dminuoso> VaNilLa[m]: Or I should rephrase. "In some cases, removing or adding a type signature with the same type that is inferred, can alter the meaning of code"
00:49:50 <Lears> pigmej[m]: You can try `Foo(Con1, Con2)`, or `Foo(..)`.
00:49:54 <pigmej[m]> MyData ( MyData ) will be the correct form Lears ?
00:50:02 <Lears> Yeah.
00:50:41 <VaNilLa[m]> dminuoso: That's an interesting gotcha. Thank you!
00:55:14 <ski> (occasionally, function numerals can be handy)
00:55:56 <dminuoso> So regarding the earlier example
00:56:00 <dminuoso> % a = 5 6
00:56:00 <yahb> dminuoso: ; <interactive>:112:5: error:; * No instance for (Num (Integer -> t0)) arising from the literal `5'; (maybe you haven't applied a function to enough arguments?); * In the expression: 5; In the expression: 5 6; In an equation for `a': a = 5 6
00:56:17 <dminuoso> Well, ignoring the MMR this would typecheck. Why exactly does this type check at all and not complain about a missing instance?
00:56:22 * ski idly wonders whether dminuoso forgot to reply earlier, or whether ski missed the response
00:56:33 <dminuoso> ski: Huh?
00:56:54 <dminuoso> ski: To which situation are you referring to?
00:57:21 <VaNilLa[m]> dminuoso: I'm sorry if you disproved this prior, but couldn't it be because :t doesn't search the scope for `instance` declarations?
00:57:52 <VaNilLa[m]> I can see `:t` just computing the "best guess" for a type
00:58:07 <ski> <ski> dminuoso : hm, can you tell me more about this "identity is not perfectly respected in some monad instances" thing ?  <ski> dminuoso : "do you know whether there's a semigroup equivalent of a monoid in a category?","is it enough to assume a semigroupoidial category as one equipped with a bifunctor that is assoc up to natural iso?" -- hm, i think so ?
00:58:25 <ski> <ski> dminuoso : hm, might've been "Sacrificing the Calf of Flexibility on the Altar of Reliability" by Peter J. Denning in 1976 at <https://dl.acm.org/citation.cfm?id=807704> (pdf),<https://app.box.com/s/dhztnnmr997auzkw8gxy> (djvu)
00:58:55 <ski> (see <http://tunes.org/~nef/logs/haskell/19.08.30>)
00:58:58 <dminuoso> ski: Oh. Well I think I did send you a thank you regarding the second, but indeed I did miss the response on the former.
00:59:15 <dminuoso> ski: My bouncer has a tendency to eat up messages, so sometimes responses are lost for me.
00:59:30 <ski> ah, i see
01:00:00 * hackage math-functions 0.3.2.0 - Collection of tools for numeric computations  https://hackage.haskell.org/package/math-functions-0.3.2.0 (AlexeyKhudyakov)
01:00:06 <ski> dminuoso : but there's no hurry. if you're in the middle of explaining or talking about something, you could come back to this, later
01:00:41 <dminuoso> ski: Oh that's fine, I can handle concurrent conversations I think! I suppose Bind is that semigroup in the semigroupoidial category of endofunctors equipped with endofunctor composition?
01:03:23 <pigmej[m]> ok it was about these Constructor exports... I was wondering what am I doing wrong :|
01:03:44 <pigmej[m]> Thanks/
01:03:49 <VaNilLa[m]> pigmej: glad to hear you figured it out
01:06:36 <ski> dminuoso : hmm, i suppose i hadn't thought of that (with `Bind' rather than `Join'), but with a little co-Yoneda sprinkled over the functor, it seems to make sense
01:20:58 <boxscape> dminuoso: Don
01:21:01 <boxscape> oops
01:21:19 <boxscape> don't know if you saw my message yesterday, so I'll send it again:
01:21:37 <boxscape> dminuoso: I just checked by the way, and what Sandy Maguire says in Thinking with Types is "A *skolem* is, for all intents and purposes, any existential type. [1]" and footnote 1: "Mathematically, it's an existentially quantified variable expressed in termss of a forall quantifier. [...]" So is that just wrong?
01:23:11 <merijn> boxscape: fyi, if you're not sure if someone is paying attention you can use lambdabot's @tell command to leave a message for later :)
01:23:42 <boxscape> merijn what does that do exactly if they're currently in the channel?
01:24:04 <ski> nothing, until they show activity, i think
01:24:11 <boxscape> I see, neat
01:24:15 <ski> @tell boxscape message from the past
01:24:15 <lambdabot> Consider it noted.
01:24:22 <boxscape> test
01:24:40 <ski> or you may have to say `@messages-public', hm
01:24:50 <boxscape> okay I'm not acutally sure if I got the lb message before or after I wrote test
01:24:51 <ski> (perhaps it PMs you that you have a message, i don't recall)
01:24:56 <boxscape> but it did send me one
01:25:22 <ski> @messages?
01:25:22 <lambdabot> Sorry, no messages today.
01:25:25 <ski> @messages-public
01:25:25 <lambdabot> Unknown command, try @list
01:25:34 <ski> oh
01:25:38 <ski> @messages-loud
01:25:38 <lambdabot> You don't have any messages
01:25:42 <ski> that's the command
01:25:51 <boxscape> ah, ok, thanks
01:26:24 <ski> (if you got the message in public, it may be nice to redisplay it in public, before you respond in public. otherwise, with `@messages', you'll get it in private)
01:26:40 <boxscape> @messages-loud dminuoso I just checked by the way, and what Sandy Maguire says in Thinking with Types is "A *skolem* is, for all intents and purposes, any existential type. [1]" and footnote 1: "Mathematically, it's an existentially quantified variable expressed in termss of a forall quantifier. [...]" So is that just wrong?
01:26:40 <lambdabot> You don't have any messages
01:26:45 <boxscape> ahh
01:26:51 <boxscape> I misunderstood
01:26:54 <ski> use `@tell' to send a message
01:27:03 <boxscape> and messages-loud to display it in public
01:27:05 <boxscape> right?
01:27:09 <ski> yep
01:27:11 <boxscape> ok
01:27:18 <boxscape> @tell dminuoso I just checked by the way, and what Sandy Maguire says in Thinking with Types is "A *skolem* is, for all intents and purposes, any existential type. [1]" and footnote 1: "Mathematically, it's an existentially quantified variable expressed in termss of a forall quantifier. [...]" So is that just wrong?
01:27:18 <lambdabot> Consider it noted.
01:27:21 <ski> (and `@messages?' to query)
01:27:25 <boxscape> ok
01:35:07 <dminuoso> boxscape: I dont know the full context. Perhaps there is a perspective in which this makes sense.
01:35:57 <dminuoso> boxscape: The way I learned it, skolem and unificational type variables/metavariables are artifacts that happen during type unification.
01:38:21 <boxscape> dminuoso: fair enough (btw I saw your comment about metavariables you sent yesterday seconds after I logged out)
01:38:33 <ski> boxscape : i'd say it's incomplete
01:38:39 <boxscape> ok
01:39:11 <ski> "skolem" vs. "metavariable" is about behaviour, semantics (static semantics, but still)
01:39:23 <ski> "existential" vs. "universal" is just syntax
01:39:55 <boxscape> Hm, okay
01:40:05 <ski> depending on in which kind of context that syntax is interpreted, it may correspond to one or the other (static) behaviour
01:40:53 <ski> if you're computing a value of existential type, then you're free to select/pick/choose which type you want, and so you have the "metavariable" behaviour
01:41:13 <dminuoso> boxscape: To a consumer of a universally quantified thing, a type variable gets represented a metavariable - to its implementor its represented as a skolem type variable.
01:41:31 <boxscape> okay
01:41:36 <ski> but also, if you're *using*/consuming a value of universal type (aka a polymorphic value), you get to pick a type, so you also get the "metavariable" behaviour there
01:41:42 <dminuoso> boxscape: And equivalently an existentially type variable would be represented as a skolem type variable to its consumer, but as a metavariable to its implementor.
01:41:57 <boxscape> I see
01:42:46 <ski> otoh, when you're computing/producing/defining/implementing a value of *universal* type, then you *don't* get to pick the type, you have to treat the type you get as abstract/hidden/forgotten/opaque, you can assume nothing about it. and so you get the "skolem" behaviour
01:42:50 <dminuoso> boxscape: In type unification a skolem type variable wont match any concrete type, whereas a metavariable would. :)
01:43:18 <ski> finally, when you're *consuming* a value of existential type, you also don't know which type was hidden inside it, and so you also get the "skolem" behaviour
01:43:23 <dminuoso> (A skolem can only match with itself or other metavariables)
01:43:27 <ski> boxscape : does that make any sense ?
01:43:56 <boxscape> it does kinda make sense, yes
01:44:13 <ski> (the more full name of "skolem", in logic, is "skolem constant/function", btw)
01:44:43 <boxscape> okay
01:44:49 <boxscape> and skolem is just the name of a person, right?
01:44:53 <dminuoso> boxscape: solonarv once put it nicely:
01:44:54 <dminuoso> 2019-06-19 17:43:28     solonarv        note also that "consuming an existential" and "producing a universal" are in some sense the same thing: forall a. F a -> B ~ (exists a. F a) -> B
01:45:10 <dminuoso> So it seems intuitive in fact that they should behave the same.
01:45:18 <ski> in logic programming, metavariables are called "logic variables" (or "dataflow variables", in concurrent logic programming), while "atoms" (which behave like symbols in the Lisps) behave (more or less) as skolems (though you can't locally scope them in Prolog)
01:46:15 <boxscape> dminuoso yeah I noted that equivalence down a couple days ago after I saw it on stackoverflow
01:47:19 <ski> btw, metavariables (logic variables) can be regarded as a ("lazy") optimization to type checking (proof search / goal solving)
01:47:38 <boxscape> interesting
01:47:54 <ski> if we're typing `length [False,True,False]', then we start from
01:48:02 <ski>   length :: forall a. [a] -> Int
01:48:03 <dminuoso> merijn: By the way, Im falling in love with sqlite-simple. It's the best thing there is! :)
01:48:11 <ski>   [False,True,False] :: [Bool]
01:48:44 <ski> but then instead of using the "oracle method" of guessing which type to replace `a' with, which would be jumping directly to
01:48:52 <ski>   length :: [Bool] -> Int
01:49:24 <ski> we introduce a metavariable `_a', that we replace the universally quantified (object) variable with
01:49:25 <merijn> dminuoso: I'm mostly in love with SQLite, because I'm still stuck with persistent, but I've got a pretty decent setup for pushing raw SQL through it :p
01:49:29 <ski>   length :: [_a] -> Int
01:49:56 <ski> and then we *unify* `[_a]' with `[Bool]', leading to the solution `_a = Bool'
01:50:09 <boxscape> So _a has a concrete type but we don't yet know which one?
01:50:12 <dminuoso> merijn: I even realized how simple even things like migrations are. I just maintain a simple [Migration] datatype, and add a big comments "dont ever delete/reorder/change things from here, just preprend"
01:50:20 <merijn> dminuoso: The only thing that really annoys me is the ability to use a window function and aggregate in a single query (so window first, then aggregate) right now I have to do the window in a subquery :\
01:50:27 <ski> boxscape : yes, Thoralf Skolem was a norwegian logician
01:50:31 <AMDphreak> Hello, I am from Memphis, TN and wondering if there are any other Haskellers near me.
01:50:44 <boxscape> okay
01:51:00 <ski> boxscape : "skolemization" was named after him, and "skolem" in the above sense comes from that
01:51:16 <ski> (also, it's related to (one formulation of) axiom of choice)
01:51:20 <dminuoso> merijn: I kept thinking so much how to make migrations right, and ended up realizing writing 20 lines of Haskell code gives me the most robust and mostly painfree solutions. :)
01:51:27 <merijn> dminuoso: I have my own setup to wrap persistent's basic migrations with more complex stuff when needed :)
01:51:34 <dminuoso> Ah I see
01:51:54 <ski> @remember solonarv note also that "consuming an existential" and "producing a universal" are in some sense the same thing: forall a. F a -> B ~ (exists a. F a) -> B
01:51:55 <lambdabot> I will never forget.
01:52:01 <merijn> dminuoso: FYI: Did you know SQLite has a "version" field reserved for application specific use?
01:52:13 <merijn> dminuoso: I just store my schema version in there and lookup required migrations that way
01:52:15 <dminuoso> merijn: No really? How do I tap into that?
01:52:25 <dminuoso> That's perfect, it removes the last sting in my eye!
01:52:37 <ski> boxscape : "So _a has a concrete type but we don't yet know which one?" -- yep
01:52:47 <merijn> dminuoso: https://www.sqlite.org/pragma.html#pragma_user_version
01:53:09 <dminuoso> merijn: That's downright perfect for this. :)
01:53:14 <merijn> dminuoso: I know!
01:53:26 <boxscape> ski okay, cool, thanks for the explanation (also thanks dminuoso )
01:53:45 <merijn> dminuoso: Means I can also easily do "destructive" migrations where I move/alter existing columns
01:54:02 <ski> boxscape : in OCaml, sometimes, you can end up with a metavariable in the type of an operation you defined (because of DVR), then, (usually) as soon as you use that operation, that metavariable will be pinned down, so that the type of the operation is "backpatched" to not include that metavariable any longer :)
01:54:13 <dminuoso> merijn: I wont allow the concept of rollbacks. Ill just force you to add more migrations.
01:54:21 <ski> ("DVR" being the "Dreaded Value Restriction")
01:54:25 <dminuoso> So each migration is just some Query
01:54:42 <boxscape> okay
01:54:44 <merijn> dminuoso: I don't allow rollbacks to older versions either, only upgrades from previous versions to new ones
01:54:55 <dminuoso> Perhaps even some `Connection -> IO ()` in order to allow for data level migrations
01:55:52 <dminuoso> merijn: Im quite annoyed how Rails teaches people to use tens of thousands of lines of magic abstraction features to do things you could have solved better by just manually thinking about your problem for 5 minutes and writing down a simple solution.
01:55:55 <dminuoso> (Rails and friends)
01:56:00 <merijn> dminuoso: It starts out simple and before you know it you've invented: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/src/Migration.hs :p
01:56:37 <dminuoso> At least you can reason about that. :)
01:56:48 <dminuoso> But cheers, once Im done Ill compare mine with yours.
01:57:09 <dminuoso> merijn: Curious though, where is MonadMigrate defined?
01:58:02 <merijn> dminuoso: Basically, I've got my persistent schema split up into different modules rather than a single big schema (makes it recompiles faster when only changing little bits), then combine the individual persistent datatypes into a single schema that persistent can migrate. Then I basically have some logic that takes a schema version and looks up the persistent schema for that version and (optionally) any 
01:58:08 <merijn> required non-persistent migration logic
01:58:20 <merijn> dminuoso: It's just a type alias for a bunch of constraints that were annoying to write all the time
01:58:41 <merijn> dminuoso: "type MonadMigrate m = (MonadIO m, MonadReader (RawSqlite SqlBackend) m)"
02:00:06 <merijn> dminuoso: So I can do things like this: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/src/Schema/Graph.hs
02:01:52 <merijn> dminuoso: At the bottom you see the lookup logic which, for each schema version returns the relevant persistent schema (I deal with name clashes of datatypes by simply moving the TH/persistent logic for old datatypes into a new module and importing qualified), plus any custom SQL to deal with changes persistent can't handle automatically (like inserting default values, etc.)
02:03:17 <merijn> It means I could also theoretically keep supporting old schemas (after all, I still have all the old datatypes, etc.) but so far I haven't needed to
02:13:26 <dminuoso> merijn: Mmm I like the idea of logThrowM
02:13:30 <ski>   # let transpose = (fun k xs -> k xs (init (fold_right min (map length xs) max_int) (fun _ -> []))) (fold_right (map2 (fun x xs -> x :: xs)));;
02:13:33 <ski>   val transpose : '_weak5 list list -> '_weak5 list list = <fun>
02:13:38 <ski>   # transpose [[1;2;3];[4;5;6];[7;8;9]];;
02:13:39 <merijn> dminuoso: It still needs some work
02:13:44 <ski>   '- : int list list = [[1; 4; 7]; [2; 5; 8]; [3; 6; 9]]
02:13:55 <ski>   # transpose;;
02:14:01 <ski>   - : int list list -> int list list = <fun>
02:14:06 <merijn> dminuoso: Because right now it sometimes reports exceptions twice (i.e. if they reach the outer exception handler)
02:14:10 <ski> that shows what i was talking about
02:14:17 <ski> (although it's a bit silly example ..)
02:14:28 <ski> boxscape,dminuoso ^
02:14:50 <ski> (that's the DVR in action)
02:15:59 <boxscape> hm, my client apparently doesn't ping me if there's a comma after the name
02:16:18 <dminuoso> merijn: Presumably this could be tackled if you used LevelOther and some identifier, and then log into some TChan backend that sorts out duplicates?
02:16:49 <merijn> dminuoso: Yeah, I need to rework logging anyway
02:17:05 <merijn> dminuoso: Right now stderr logging messes up the haskelline prompt
02:17:36 <boxscape> ski so does that mean you can only use transpose with int lists after that point?
02:17:55 <merijn> dminuoso: haskelline is also pretty amazing, tbh. Not only do I have proper terminal editing now, but I also have tab completion from the database ;)
02:18:48 <merijn> Now I just need to figure out how to hack up optparse so I can have bash completion that supports querying the database too :p
02:19:26 <ski> boxscape : yes
02:19:30 <boxscape> okay, got it
02:19:36 <merijn> Which is kinda tricky, because the optparse completion doesn't know about any of the other provided arguments, but the database is specified as commandline argument too...
02:19:55 <merijn> So I probably need to preprocess the commandline args to find the database so I know how to query for completions...
02:19:56 <ski> the original version of `transpose' was also monomorphic, it's just that we didn't know yet what some part of its type was
02:20:01 <ski> boxscape ^
02:20:06 <boxscape> right, I see
02:20:13 <boxscape> no implicit foralls
02:20:28 <ski> no `forall' at all, implicit or explicit
02:20:32 <boxscape> right
02:20:44 <ski> metavariables are about deferring choice
02:21:48 <ski> (just like variable environments are about deferring substitition, they're "reified substitutions". and laziness (and by-name in general) is about deferring reduction/evaluation)
02:22:25 <dminuoso> boxscape: It's somewhat similar to how an argument `\x -> ...` has two roles. One role is from the outside, it can be freely picked (and is from that perspective knowable), and from inside its some value but you dont know which you get.
02:23:10 <boxscape> and in Core both forall and term level functions are both just lambdas, right? Making it even more similar?
02:23:43 <ski> instead of going from `(\x y -> x^2 - y^2) 3' to `\y -> 3^2 - y^2', we go to `\y -> x^2 - y^2' with an attached environment `x = 3'. one might depict this as \y -> x^2 - y^2  where  x = 3'
02:23:54 <dminuoso> boxscape: Indeed.
02:24:03 * ski nods to dminuoso
02:24:33 <ski> `forall' is not lambda. but `forall' would be a type of a kind of lambda, in Core
02:24:57 <dminuoso> boxscape: Rather than lambda, what we have is a variation of System FC.
02:25:07 * ski flails about helplessly in search of a nontechnical word to replace "kind" with
02:26:11 <boxscape> dminuoso: not sure what you mean by "rather than". Isn't system FC a lambda calculus?
02:26:31 <boxscape> and yeah ski that makes sense
02:27:29 <dminuoso> boxscape: Lets just talk about System F for simplicities sake.
02:27:42 <dminuoso> boxscape: System F is an extended typed lambda calculus.
02:28:15 <boxscape> okay
02:28:21 <dminuoso> boxscape: So just like how lambda calculus has binders/variables over terms, system f has variables/binders over types in addition.
02:28:30 <boxscape> right
02:29:11 <dminuoso> Λα.λx^α.λy^α.x
02:29:25 <dminuoso> For example is the System F encoded typed church boolean for True.
02:29:50 <boxscape> okay
02:29:57 <boxscape> that makes sense
02:30:30 <dminuoso> Or an identity function is: Λa.λx^α.x
02:31:04 <dminuoso> If we use ascii approximation, then you might write: /\a.\x^a.x
02:31:18 <dminuoso> And if we use :: rather than ^ because its the Haskell convention, then you arrive at:
02:31:35 <dminuoso> / /\a. \(x :: a). x
02:31:49 <boxscape> uh why are there two /
02:31:58 <dminuoso> boxscape: Oh I was just trying to force weechat into submission.
02:32:04 <boxscape> ah
02:32:08 <dminuoso> boxscape: I thought weechat behaved like irssi, ignore the first slash.
02:32:21 <dminuoso> boxscape: https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/fc
02:32:24 <day> what is /\
02:32:34 <dminuoso> boxscape: If you take a quick peek, then this should make sense now.
02:32:43 <ski> day : upper case lambda
02:32:54 <merijn> day: hacky ascii way of writing Λ
02:33:02 <merijn> (i.e. capital lambda)
02:33:24 <day> and what does it do differently than \?
02:33:44 <ski> (aka majuscule)
02:33:57 <ski> day : it binds a type variable, rather than a value variable
02:34:22 <day> i see
02:34:52 <ski> if `id' is `/\a. \(x : a). x', then `id Bool False' is `False'
02:35:20 <ski> (or, sometimes it would be written `id [Bool] False', with the square brackets indicating a type argument)
02:35:34 <dminuoso> In plain haskell we can make this also explicit
02:35:41 <dminuoso> % id @Bool False
02:35:41 <yahb> dminuoso: False
02:35:53 <merijn> dminuoso: s/plain/GHC/
02:36:00 <dminuoso> merijn: Was just about to fix that. Thanks! :)
02:36:44 <dminuoso> day: If you squint a bit and write explicit foralls, and use ∀ instead of forall, then `∀x.` kind of looks like Λx... :P
02:37:03 <AWizzArd> There is the `vault` library, which is also used in Servant. When I add 2-3 key/value pairs of data into my vault and pass an updated Request on to the next middleware/handlers... how can they lookup data in the vault? They would need to know my keys, but it seems I can't name them, no?
02:37:06 <dminuoso> Although I think that's more of a coincidence.
02:37:21 <ski> (they are of course completely different, though, albeit related)
02:38:25 <dminuoso> It's rather that:  Λa.λx^α.x :: ∀t. t -> t
02:39:46 <ski> yep
02:40:13 <ski> (i remember talking to someone, who insisted on comflating lambdas with function types ..)
02:40:43 * dminuoso wonders whether that might have been himself
02:40:56 <ski> no, it wasn't
02:41:19 <ski> (this was after multiple attempts to elucidate the difference)
02:41:29 <AWizzArd> How can I communicate different keys in Servant, when using the data vault?
02:41:57 <ski> (one could say they "knew enough to be dangerous". they were attempting to develop their own version of the lambda calculus)
02:42:45 <dminuoso> ski: Although I think I misread. How does one confuse a lambda with a function type exactly?
02:43:02 <dminuoso> I mean that's akin to confusing True with `x -> x`, isnt it?
02:43:13 <dminuoso> (Or True with Bool)
02:44:08 <boxscape> Sounds like pretty much what I did earlier when I said a forall is a lambda
02:44:32 <dminuoso> boxscape: I found that the lambda cube resolved much confusion for me.
02:44:45 <dminuoso> boxscape: It puts all these things like lambda, type level functions, forall and dependent types into a coherent picture.
02:45:03 <boxscape> I've seen that once but haven't tried to understand it, maybe I should do that
02:45:31 <ski> dminuoso : they were insisting on treating `\x. ..x..' as the same thing as `x -> ..x..' (go figure ..)
02:45:51 <ski> boxscape : yes, that's why i mentioned it
02:46:00 * hackage universum 1.6.0 - Custom prelude used in Serokell  https://hackage.haskell.org/package/universum-1.6.0 (gromak)
02:46:07 <dminuoso> So terms binding terms give you lambda. types binding types give you type level functions. terms binding types (remember `id @Bool` !) gives you polymorphism, types binding terms gives you dependent types.
02:46:27 <dminuoso> boxscape: So if take this universe of "terms binding terms" as our starting universe, then the rest are extra dimensions you could add to a language.
02:48:26 <dminuoso> boxscape: The fact that polymorphism (forall quantification on types) is actually terms binding types is not obvious until you tap into TypeApplications and imagine they were mandatory.
02:48:38 <dminuoso> (Im conflating GHC and Haskell here by the way)
02:49:05 <ski> (and in "pure second-order" predicate logic, you have formulae binding formulae, but not binding any individuals)
02:49:58 <Ariakenom> ski's SKI logic?
02:50:32 <ski> ?
02:50:54 <Ariakenom> it just reminded me of combinators but with logic
02:51:32 <ski> well, that's why the combinators were invented, iirc, to help with binding in logic
02:51:32 <dminuoso> boxscape: It also shows that forall quantification and Pi quantification are sort of.. flipped around inverses. In dependent types, position yourself in the type level, take some suitable type-level construct `T` you can then apply that to a value level construct. We cant do that in Haskell.
02:52:15 <dminuoso> The only thing we have is that you can apply terms to types.
02:52:26 <dminuoso> And you can apply terms to terms and types to types
02:53:07 <ski> dminuoso : hm, i suppose that also holds for the usual (non-dependent) function arrow, like `Nat -> Set'
02:54:02 <boxscape> dminuoso (I'll read that later, have to go)
02:55:04 <dminuoso> ski: What do you mean?
02:56:49 <ski> i mean you don't need the dependency in the type `(n :) Nat -> Vec Bool n -> Set', to be able to apply a function of such a type to terms, getting back a type
02:57:31 <dminuoso> ski: I have to ask. What's with that bizarre parenthesis placement?
02:58:42 <dminuoso> Is that to visualize the type universes better? E.g. if you had `((n :) T ... :) Q` that the nesting of universes is visually easier to capture?
03:01:30 <ski> it's so that it's more readily apparent what is "the main part" and what is "the details"
03:02:38 <ski> so that `(_ :) T -> U' is the same as `T -> U'. `T' is the argument type in `(x :) T -> P x', the `(x :)' part is "oh, btw, we're going to refer to the input of this type as `x'"
03:03:28 <ski> similarly, in a type ascription, instead of `x + (y : Nat)', one could decide to write that as `x + y (: Nat)'
03:03:40 <ski> (while type signatures would still be in the `x : T' form)
03:04:12 <ski> dminuoso, ok ?
03:07:40 <yorick> maybe I should pass --enable-gold to the nixpkgs ghc
03:08:41 <yorick> oh, it already does this on aarch32
03:09:04 <yorick> bgamari: is it recommended to make gold default for everything?
03:21:40 <phadej> ~where it works
03:24:27 <yorick> phadej: I think it's a ghc configure flag to make it the default
03:24:40 <yorick> also I think it's not supposed to break anything
03:41:40 <Bish> how would i apply a tuple of functions to a tuple of parameters
03:41:55 <Bish> a.e. (id,(+1)) (0,0) ⇒ (0,1)
03:42:33 <merijn> Bish: Biapplicative?
03:43:25 <Bish> didn't know that's a thing
03:43:26 <merijn> :t uncurry bimap -- or this, I suppose
03:43:28 <lambdabot> Bifunctor p => (a -> b, c -> d) -> p a c -> p b d
03:43:33 <Bish> :D how long does that go
03:43:39 <Bish> triapplicative
03:43:44 <Bish> pentapplicative?
03:44:08 <merijn> Bish: Theoretically you can extend it indefinitely, I think. But I think Bifunctor is the only somewhat frequently used one
03:44:31 <Bish> why can't something like this be expressed generaly(is that a word?)?
03:45:31 <ski> because "tuple" isn't a first-class concept in Haskell
03:46:03 <ski> only "pair","triple","quadruple",&c.
03:46:37 <merijn> ski: I think means nary-applicative
03:47:11 <merijn> ski: i.e. why can't we have "Applicative :: Nat -> (? -> *) -> Constraint"
03:47:21 <ski> yes, but it would need to depend on such a tuple concept, no ?
03:47:29 <merijn> ski: I don't think so?
03:47:50 <merijn> ski: It's just that you need the arity of the type argument to depend on some Nat
03:47:55 <ski> hm, perhaps not, with a `Nat' there
03:48:08 <merijn> Bish: Haskell just doesn't have the flexibility to encoded this sorta thing
03:48:08 <Bish> should i do it with an array instead?
03:48:21 <ski> Bish : how about lists ?
03:48:21 <Bish> list i mean, ofc
03:48:27 <merijn> Bish: Alternatively you could use ZipList, yes
03:48:32 <Bish> how would first class touble look like?
03:48:37 <Bish> tuple*
03:48:57 <ski> > getZipList (ZipList [id,pred,succ] <*> ZipList [0,1,2])
03:48:58 <merijn> Bish: The normal list instance of applicative doesn't do what you want, so be aware of that
03:48:59 <lambdabot>  [0,0,3]
03:49:12 <merijn> > [id, (+1)] <*> [0,1]
03:49:14 <lambdabot>  [0,1,1,2]
03:49:19 <ski> > [id,pred,succ] <*> [0,1,2]
03:49:21 <lambdabot>  [0,1,2,-1,0,1,1,2,3]
03:55:19 <boxscape> dminuoso just read your last few messages, that is a pretty nice way to sum it up, thanks
03:58:38 <Bish> asdasduncurry bimap ((+1),(+0)) (0,1)
03:58:40 <Bish> (1,1)
03:58:44 <Bish> looks good, thanks
04:01:00 * hackage sequence-formats 1.3.3 - A package with basic parsing utilities for several Bioinformatic data formats.  https://hackage.haskell.org/package/sequence-formats-1.3.3 (stephan_schiffels)
04:20:17 <lavalike> @pl \((a,b),(c,d)) -> ((a,c),(b,d))
04:20:17 <lambdabot> uncurry (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (,)) . flip . (((.) . (,)) .) . (,)))
04:20:34 <boxscape> @unpl uncurry (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (,)) . flip . (((.) . (,)) .) . (,)))
04:20:35 <lambdabot> uncurry (uncurry (\ x y0 b0 -> (snd >>= \ x2 -> return (((,)) (((,)) x (fst b0)) (((,)) y0 x2))) b0))
04:21:06 <lavalike> the entropy is rising and rising
04:21:12 <boxscape> hm lambdabot puts redundant brackets around (,)
04:21:32 <boxscape> (though only in unpl, I guess)
04:26:51 <absence> if i have data A = A Int String and data B = B Int String, why can't i coerce between them?
04:29:20 <cpressey> absence: The meaning of the Int and the String in A might be very different from what they mean in a B.
04:29:54 <merijn> Why would you expect to be able to coerce them?
04:30:13 <merijn> absence: Note that those two aren't even guaranteed to have the same in memory representation
04:30:40 <absence> to me they look like the same type, so i don't quite understand how the meaning of Int and String might differ between them
04:31:20 <absence> is there another way to convert one to the other without having to write the code for it?
04:31:21 <merijn> absence: The Haskell report makes 0 guarantees of how datatypes are compiled and, as a result, also doesn't guarantee that two identical datatypes will compile to the same code
04:31:35 <cpressey> absence: Maybe in A they represent an age and a name, while in B they represent a height in inches and a street address.
04:31:53 <merijn> cpressey: That's true, but also not the best argument why it doesn't work, imo :)
04:32:39 <cpressey> merijn: Mine is more of a software engineering reason, yes, but it's one reason why disjointess is a nice property in data types.
04:36:00 <merijn> absence: You could use generics/TH, but honestly that'd involve writing more code than "just writing the code"
04:36:00 * hackage th-orphans 0.13.8 - Orphan instances for TH datatypes  https://hackage.haskell.org/package/th-orphans-0.13.8 (ryanglscott)
04:36:03 <absence> cpressey: Sum 3 and Product 3 represent different interpretations as well, but it's fine to coerce between them, so i don't think that's a technical reason why it doesn't work
04:36:46 <merijn> absence: Sum and Product are newtypes. Newtypes are *guaranteed* to have the same memory representation as the original types
04:37:15 <merijn> absence: So "Sum Int" is guaranteed to have the same memory representation as Int (and the same goes for Product Int), hence they can be coerced safely
04:39:06 <absence> merijn: i did try a simple "to . from" after deriving Generic, but it doesn't compile because the type constructors have different names
04:40:01 <absence> if i have to map the names, i agree that there's not much benefit over writing it out
04:44:45 <dminuoso> ski: Ah I see. Ill ponder about it for a while and see if it makes sense.
04:45:29 <boxscape> merijn do you know if GHC makes any guarantees about the memory representation of those? (I just checked and unsafeCoerce works, but of course that doesn't mean anything)
04:46:00 <merijn> boxscape: "of those" = ?
04:46:09 <boxscape> data A and data B
04:46:23 <boxscape> A Int String and B Int String being the constructors
04:46:35 <boxscape> (ghc as opposed to the haskell report)
04:46:36 <merijn> boxscape: I don't think GHC currently does anything that will break it
04:46:55 <merijn> boxscape: But "does not currently break it" /= "guarantees they won't break it in the future"
04:47:00 <boxscape> yeah that makes sense
04:50:14 <dminuoso> boxscape: https://en.wikipedia.org/wiki/Lambda_cube#/media/File:Lambda_Cube_img.svg in that diagram Haskell resides on λω
04:50:33 <dminuoso> And I think Idris resides on λC
04:50:45 <dminuoso> (Since they add types binding terms to that mix)
04:52:13 <boxscape> I see
04:52:13 <dminuoso> (here going up means adding terms binding types (polymorphism), going right means adding types binding types (dependent types)  and going into the picture means adding types binding types (type operators)
04:53:11 <dminuoso> boxscape: Of course its strictly not entirely true, since that cube is talking about mere lambda calculus, and languages like Haskell or Idris are much richer than the lambda calculus forms this picture describes.
04:54:24 <dminuoso> Though if I understand it correctly that cube can be used in looking at type systems in general.
04:58:00 * hackage sequence-formats 1.4.0 - A package with basic parsing utilities for several Bioinformatic data formats.  https://hackage.haskell.org/package/sequence-formats-1.4.0 (stephan_schiffels)
04:58:46 * ski nods to dminuoso
05:31:00 * hackage servant-kotlin 0.1.1.9 - Automatically derive Kotlin class to query servant webservices  https://hackage.haskell.org/package/servant-kotlin-0.1.1.9 (matsubara0507)
05:45:20 <boxscape> (I was away, but thanks, good explanation)
06:22:34 <fendor> is the config in ~/.cabal/config kind of a template for cabal.project files?
06:23:53 <merijn> fendor: Depends on what you mean by, "kind of" and "template" :p
06:24:10 <fendor> like, does it define default values for cabal.project?
06:24:43 <merijn> fendor: ~/.cabal/config defines the default configuration for the cabal executable, including some that may affect building and could be overridden by cabal.project
06:25:25 <fendor> ok, makes sense. Can I query that with cabal-install or is there some ticket that tracks such an issue?
06:27:45 <merijn> fendor: What do you want to query?
06:27:55 <fendor> for example the extra-prog-path
06:27:58 <fendor> or installdir
06:28:19 <merijn> fendor: Why? That's almost certainly *not* what you want to do
06:29:19 <fendor> well, for example, I want to install an executable and rename it. 
06:29:48 <merijn> "install and rename" from where? A cabal package?
06:30:42 <fendor> yes, e.g. install hsimport, but want to add a suffix, ".8.6.4" so I know I installed it with ghc 8.6.4. Contrived example, but interesting if install a package with multiple ghc versions, right?
06:31:08 <merijn> Packages are already automatically installed in GHC version specific paths
06:31:23 <merijn> So packages installed with different GHC versions cannot collide
06:32:00 <Ariakenom> I tried finding what settings to use with powerManagement.cpuFreqGovernor. "performance" for my newish intel according to https://wiki.archlinux.org/index.php/CPU_frequency_scaling
06:32:16 <fendor> but I want to use them as executables
06:32:43 <fendor> isnt that the reason we use v2-install in the first place? 
06:33:13 <merijn> fendor: If you want to install the same executable multiple times you should do that via OS packaging tools, not from cabal, that would break everyone's expectations
06:33:24 <Ariakenom> ... this is not the right channel :D
06:34:37 <merijn> fendor: If you want different install/naming convetions from cabal-install, then you should explicitly package those executables before distributing. Additionally, v2-install already supports multiple installs of executables, it's just that you can only ever have one version installed/symlinked in ~/.cabal/bin
06:37:46 <fendor> merijn, why not? Why shouldn't I install the same package with different ghc versions at the same time? I also doubt that package managers are helpful in that situations
06:38:54 <merijn> fendor: I'm not saying you shouldn't. I'm saying cabal isn't setup to deal with that, and somehow hacking something together to force it to do that anyway is bad and you shouldn't do it.
06:41:15 <merijn> If you want your executable to be tagged with a GHC version and install multiple at the same time, that's fine. But then you should, for example, create an apt-get (or whatever package manager) package for each of those versions (probably building them via cabal) and then install them that way.
06:41:51 <merijn> Alternatively, manually create the relevant symlinks to various store installations
06:47:30 * hackage acquire 0.3 - Abstraction over management of resources  https://hackage.haskell.org/package/acquire-0.3 (NikitaVolkov)
06:48:58 <fendor> merijn, I think I understand, thank you!
06:50:01 <merijn> fendor: If you install a symlink via v2-install you will see that it just links to a binary in the global store
06:50:55 <fendor> merijn, yes, but it is not possible to get that location programmtically, right?
06:51:40 <merijn> fendor: No, because it depends on the exact set of dependencies it was build with. But then the version you want is probably not tied to a specific dependency set but something else...
06:52:07 <fendor> i meant, the location of the global store. 
06:53:08 <merijn> fendor: No, the entire idea of the way cabal builds executables is that people doing packaging (i.e. the people updating apt-get, etc.) can easily change the relevant locations to match the system things are installed too
06:54:56 <fendor> why does not being able to programmitcally get the location of the global bin, e.g. `~/.cabal/bin` help packagers to change the relevant locations? 
06:56:25 <merijn> fendor: I mean that none of the location executables/packages (should) access depend on the ~/.cabal/config, because if they did, packagers couldn't move things. And since things don't use those locations there's mostly no point in querying them
06:59:35 <fendor> ok, yeah, that makes perfect sense. However, ~/.cabal/bin isnt kind of independent of that and rather about convenience?
07:00:40 <merijn> fendor: ~/.cabal/bin is more a kind of convenience for developers, so you can easily install a tool you're working on, it's not really meant for general purpose packaging, since cabal itself isn't really for general purpose packaging
07:03:30 * hackage mpi-hs 0.5.2.0 - MPI bindings for Haskell  https://hackage.haskell.org/package/mpi-hs-0.5.2.0 (eschnett)
07:05:13 <fendor> merijn, fair.
07:18:00 * hackage natural-arithmetic 0.1.0.0 - Arithmetic of natural numbers  https://hackage.haskell.org/package/natural-arithmetic-0.1.0.0 (andrewthad)
07:28:16 <pigmej[m]> Heya again, I need servant to store some stuff in memory, I'm using https://docs.servant.dev/en/stable/cookbook/using-custom-monad/UsingCustomMonad.html as guide. All works as expected. But when I try to add another "url" that is meant only to reply "pong" when hit, I'm getting error that translates to "You need to have state in every handler"
07:28:23 * pong
07:28:37 <pigmej[m]> is there any way to make two different types of handlers in Servant ? That one would be able to use state and second would be "normal" one?
07:36:00 <dmj`> pigmej[m]: you can just return Pong from your custom monad
07:36:18 <merijn> hmm, there's no convenient version of Text.break that drops the element that matches the predicate?
07:37:15 <pigmej[m]> dmj` hmm I don't understand :(
07:37:19 <dmj`> merijn: Data.Text.filter ?
07:37:39 <merijn> dmj`: That doesn't seem remotely similar to break?
07:37:59 <dmj`> merijn: you'd like to drop an element that does or doesn't match a predicate, sounds like filter
07:38:02 <merijn> I guess "splitOn", but that returns a list :\
07:38:09 <pigmej[m]> dmj` I have custom monad (I think) but it seems to me that I have to apply it to all handlers
07:38:10 <dmj`> breakOnAll ?
07:38:21 <merijn> dmj`: No, I wanted *break* but without the splitting element included
07:38:23 <dmj`> pigmej[m]: yes, you do, but what's wrong with that
07:38:56 <pigmej[m]> I don't know, just doing something "everywhere" while it's needed only in few places sounds like I did something  wrong
07:38:59 <pigmej[m]> I'm still learning
07:39:15 <dmj`> pigmej[m]: would you mind pasting your code?
07:39:28 <merijn> dmj`: breakOnAll just gives me *lots* of strings starting with the splitting element >.> I guess I'll have to go with splitOn and deal with the return list
07:40:07 <pigmej[m]> dmj` yeah, let me clean it a bit first :)
07:40:16 <dmj`> pigmej[m]: I won't judge :)
07:41:11 <dmj`> merijn: splitOn *does* drop the element that matches the predicate though
07:41:22 <dmj`> you just didn't want a list ?
07:42:18 <merijn> Yeah, because now I need to handle a bunch of cases I don't care about :\
07:42:30 <pigmej[m]> dmj` https://gist.github.com/pigmej/91fa31a7ea6653ac52a4e63009951f13
07:42:39 <pigmej[m]> MyApi.Symbol == Symbol.hs if sth.
07:43:15 <dmj`> merijn: can you just concat it back into a single text ?
07:43:22 <dmj`> after the splitaroo
07:44:22 <merijn> dmj`: Ah...looks like it might be ok, since the list is always at least 1 element...
07:44:41 <dmj`> pigmej[m]: try changing  `pong :: Handler String` -> `pong :: AppM String`
07:44:47 <pigmej[m]> Yeah
07:44:48 <pigmej[m]> I know ;)
07:44:50 <pigmej[m]> that's what I'm heading too
07:44:56 <dmj`> see, you got it
07:45:01 <dmj`> merijn: swag
07:45:04 <pigmej[m]> I understand that I have to do it, I was just wondering if three is another way
07:45:16 <pigmej[m]> because AppM is alias for State Handler 
07:45:17 <pigmej[m]> that's clear
07:45:29 <merijn> dmj`: The problem with concating is that even if it can't happen now you're suddenly forced to handle the empty list case, etc. to appease the whining type checker >.>
07:45:31 <pigmej[m]> but I had a feeling that I can have kinda multiple types on that level
07:45:36 <dmj`> pigmej[m]: well, Handler a ~ ExceptT IO ServantError a
07:46:00 * hackage kind-apply 0.3.2.0 - Utilities to work with lists of types  https://hackage.haskell.org/package/kind-apply-0.3.2.0 (AlejandroSerrano)
07:46:17 <dmj`> pigmej[m]: you don't really want to be using a state monad in a web server, since forking new threads will copy the state, but any subsequent changes to the state are isolated to the thread in which they occur, you'd need to employ a synchronization primitive like an MVar or IORef 
07:46:48 <dmj`> pigmej[m]: ReaderT Config Handler a can do this, where Config contains the synchronization primitives
07:47:43 <pigmej[m]> I was planning single thread there but yeah, safer
07:48:01 * hackage kind-generics 0.4.0.0 - Generic programming in GHC style for arbitrary kinds and GADTs.  https://hackage.haskell.org/package/kind-generics-0.4.0.0 (AlejandroSerrano)
07:49:29 <pigmej[m]> but hmm... wait
07:49:32 <pigmej[m]> atomically would not help there?
07:49:36 <dmj`> pigmej[m]: every request in warp gets handled in a new thread
07:49:40 <pigmej[m]> and stm
07:49:46 <dmj`> pigmej[m]: you could use STM too, put a TVar in the Config
07:50:17 <dmj`> pigmej[m]: there's many cats, and many different ways to skin them, but each one has its own up / down sides
07:50:19 <pigmej[m]> hmm
07:50:30 * hackage kind-generics-th 0.2.0.0 - Template Haskell support for generating `GenericK` instances  https://hackage.haskell.org/package/kind-generics-th-0.2.0.0 (AlejandroSerrano)
07:50:44 <pigmej[m]> that Cookbook says `Note that we can’t use State monad here, because state will not be shared between requests.`
07:50:53 <dmj`> pigmej[m]: that's good
07:51:02 <dmj`> that's a good thing to say
07:51:56 <pigmej[m]> ```          State{books = p} <- ask
07:51:57 <pigmej[m]>           liftIO $ atomically $ readTVar p```
07:51:59 <pigmej[m]> wrr sorry
07:52:32 <dmj`> pigmej[m]: so State here is not the State monad type
07:52:46 <pigmej[m]> mine also?
07:52:55 <dmj`> pigmej[m]: yea, but that's fine
07:53:12 <pigmej[m]> I was following 1:1 (I think) https://docs.servant.dev/en/stable/cookbook/using-custom-monad/UsingCustomMonad.html
07:53:17 <dmj`> pigmej[m]: you can do that too, your liftIO . atomically . readTVar $ p
07:53:43 <pigmej[m]> that was the plan, I have nothing ready to access the state yet
07:54:06 <dmj`> pigmej[m]: that's ok, but be warned, state on the server is lost if the process restarts
07:54:15 <pigmej[m]> sure :)
07:54:24 <pigmej[m]> that's very cool because that's exactly what I need ;D
07:54:31 <pigmej[m]> I'm just n00b with Haskell
07:55:16 <dmj`> pigmej[m]: that's ok, there's a lot to unpack
07:55:28 <pigmej[m]> Already noticed ;)
08:00:30 * hackage unbound-kind-generics 0.2.0.0 - Support for programming with names and binders using kind-generics  https://hackage.haskell.org/package/unbound-kind-generics-0.2.0.0 (AlejandroSerrano)
08:06:07 <dmj`> pigmej[m]: simple haskell is usually best, at least for real world stuff
08:06:30 <dmj`> don't have to hide your lack of understanding about the domain in your ivory tower types
08:06:45 <dmj`> not saying you do or anything
08:14:30 * hackage dependent-monoidal-map 0.1.1.0 - Dependent map that uses semigroup mappend  https://hackage.haskell.org/package/dependent-monoidal-map-0.1.1.0 (abrar)
08:22:16 <merijn> Well...that's interesting
08:22:47 <merijn> I updated to cabal-install and suddenly my code is...conflicting with an extension? o.O
08:23:03 <c_wraith> to 3.0.0?
08:23:07 <merijn> c_wraith: Yeah
08:23:19 <c_wraith> that's a new and exciting error class. :)
08:23:38 <merijn> "(conflict: requires ViewPatterns)"
08:25:17 <merijn> hvr: Any clue what's going on? o.O
08:25:48 <c_wraith> that looks like some error is being handled incorrectly and its message is getting propagated to the wrong handler
08:26:50 <dminuoso> merijn: mind my asking, why do you use persistent?
08:27:13 <merijn> dminuoso: Because I started out with persistent before I realised that was not ideal and by then removing it was a lot of work for little gain
08:28:06 <merijn> c_wraith: Ah! Looks like faulty logic in reading the existing dist-newstyle
08:28:29 <c_wraith> oh.  easy fix then, but that's an unpleasant upgrade path
08:28:32 <merijn> c_wraith: Nuking that and starting again seems to do something
08:28:37 <infandum> I'm going crazy. Using Streaming.Prelude, I can load all the data into a HashMap using Fold with almost no memory usage. Then reading that same data into a Data.Sparse.SpMatrix using Fold with ^+^ as the accumulation step, I get large memory usage such that the program is killed. I tried deepseq in the accumulation step, but that didn't work! Why would this be?
08:28:46 <merijn> c_wraith: Well, it might just break again once it's done building dependencies... >.
08:28:51 <dminuoso> merijn: I see. Well thanks for that repo by the way, I took a look at some parts, and finally understood how exceptions can be structured into hierarchies. :)
08:29:14 <merijn> dminuoso: You could also just read the paper linked in Control.Exception, which is where I learned this from ;)
08:29:26 <dminuoso> merijn: Cheers, will definitely do.
08:32:29 <dminuoso> merijn: But yeah, your migrations <> persistent interface was somewhat strange.
08:33:35 <merijn> dminuoso: Yeah, it's working around the limitations of persistent's own migrations, which can only really add columns or alter them from not null to nullable
08:34:29 <dminuoso> I think Ill go for a simple list of some custom data type `data Migration = Migration { migPreAction :: Connection -> IO (); migPostAction :: Connection -> IO (); migQuery :: Query }` and maintain some Haskell module with some `migrations :: [Migration]`
08:34:35 <dminuoso> (And then use that PRAGMA you mentioned to store the index of the list Im currently at)
08:34:45 <merijn> dminuoso: But dropping persistent means reimplementing all the datatypes, writing my own setup code, reworking any bits that happened to use persistent all over the codebase. Just seemed like a lot of hassle to remove, rather than just working around it
08:34:57 <dminuoso> merijn: Yeah perfectly understandable.
08:35:05 <merijn> dminuoso: The mess is still nicely contained, so
08:36:33 <dminuoso> merijn: By the way, I find your style of `True <$ ...` quite curious.
08:37:11 <dminuoso> Why do you prefer it over some `pure True` at the end?
08:38:18 <merijn> Means I don't have to read all the logic to see what things return :p
08:39:13 <merijn> There's no real concious decisionmaking behind that. Just what seemed obvious to write
08:39:51 <dminuoso> Fair enough. Im frequently curious what motivates people to employ certain idioms.
08:40:34 <dminuoso> Id find it a bit inconsistent because if the return was non-constant, then you sort of have to scan both the beginning and the end block to know what happens.
08:40:43 <merijn> dminuoso: The nice thing of <3 is that it works on many more things than pure :p
08:40:57 <dminuoso> If only <3 was a valid operator! It make for lovely Haskell code.
08:41:10 <merijn> eh <$ :p
08:41:10 <dminuoso> =P
08:41:42 <merijn> c_wraith: Well, at least it looks like everything compiled succesfully after nuking, so the day is saved! \o/
08:42:39 <Taneb> dminuoso: you could write "(<3) 0 <$ ..."
08:45:45 <ski> dminuoso : hm, and this "identity is not perfectly respected in some monad instances" ?
08:46:22 <merijn> Anyone know why binary-0.9 and 0.10 are deprecated?
08:46:24 <int-e> ski: is this about bottoms again?
08:46:29 <dminuoso> int-e: yes
08:47:39 <dminuoso> int-e: I mean if code transformations based on monad laws are only correct up to strictness, then a mechanical transformation could break or unbreak code.
08:47:46 <dminuoso> This in effect also ties GHCs hands.
08:48:13 <int-e> Thanks. (As usual I only have fragments of the context. :-/ )
08:48:20 <dminuoso> (Or, in other words, a mechanical code transformation employed by an optimization would alter a programs behavior)
08:48:55 <dminuoso> int-e: Heh, I think ski is going through his logs and responding to questions from quite a while ago. :-p
08:49:11 <dminuoso> Or their logs, rather, seeing as Im not familiar about their gender.
08:49:35 <AviD> What is the best workaround for bytecode compilers, ghci and ghc-mods inability to handle unboxed tuples?  "-fobject-code, or compile this module to .o separately."  Is there a way to make cabal compile a single module separately or does it need to be broken into a separate package?
08:51:20 <pigmej[m]> dmj` Thanks for the input and really appreciate the help.
08:54:02 <dmj`> pigmej[m]: no problem !
08:54:55 <pigmej[m]> btw where is the boundary of "simple haskell" ?:D
08:55:21 <ski> int-e : i don't know
08:55:28 <ski> dminuoso : oh
08:55:30 * hackage pipes-ordered-zip 1.1.0 - merge two ordered Producers into a new Producer  https://hackage.haskell.org/package/pipes-ordered-zip-1.1.0 (stephan_schiffels)
08:56:44 <ski> int-e : why fragments ? lossy bouncer ?
08:57:23 <ski> dminuoso : nah, this was among the question which i repeated a few hours ago :)
08:57:30 <int-e> ski: Nah, I'm just overwhelmed by the sheer mass of messages.
08:57:32 <dminuoso> ski: Heh, I do have a lossy bouncer too. Let me check again.
08:57:48 <ski> s/question/questions/
08:58:14 <dminuoso> ski: If I recall correctly, someone else provided examples of this in the moment.
08:58:54 <ski> dminuoso : if you're referring to the monad laws vs. strictness thing, then it's possible, yes
08:59:00 <dminuoso> ski: Yes I am.
08:59:08 <dminuoso> Or it was you even, I dont remember.
09:00:29 <int-e> > let !x = (undefined >> return ()) :: IO () in ()
09:00:31 <lambdabot>  ()
09:00:39 <ski> dminuoso : however, when i asked that question
09:00:41 <ski> <ski> dminuoso : hm, can you tell me more about this "identity is not perfectly respected in some monad instances" thing ?
09:00:48 <ski> which was in response to
09:00:49 <int-e> (and the same thing in the state monad, is what I recall)
09:00:49 <ski> <dminuoso> ski: Im still annoyed that you showed to me, how identity is not perfectly respected in some monad instances. :(
09:01:02 <ski> i didn't know what you were referring to
09:01:21 <dminuoso> ski: Ohh I understand now
09:01:21 <int-e> (but I don't recall who provided the IO example)
09:01:37 <ski> dminuoso : i think i provided examples. perhaps also someone else
09:01:43 <dminuoso> ski: Yeah you demonsrated that the identity law is only satisfied up to strictness by some monads like function based monads like State.
09:06:15 <nshepperd2> Many functors only obey the functor law under fast and loose reasoning
09:06:51 <nshepperd2> Such as data.map.strict
09:08:10 <int-e> Ah if you do things like... fmap (const () . const undefined)
09:08:31 <nshepperd2> Exactly
09:13:30 <ski> int-e : i provided `IO' example, then someone (you) `State', i think
09:13:47 <voyons_osti> i missed how this question began but it looks interesting, could somebody provide me some context?
09:13:48 <int-e> ski: yeah that was me
09:13:51 <ski> (s/you/you ?/)
09:14:23 <ski> dminuoso : yea, i didn't connect what you were referring to, when you just said "identity"
09:14:42 <ski> (also, i tend to refer to them as "neutral element laws")
09:15:29 <merijn> dminuoso: You need to read "Fast and loose reasoning is morally correct" if this upsets you :p
09:16:24 <int-e> merijn: it's upsetting that moral correctness is not sufficient permission for a compiler.
09:16:39 <merijn> dminuoso: The conclusion of which is "ignoring strictness in laws will never turn working code into broken code, but may turn some broken code into working code, so all is well in the world"
09:17:30 * hackage acquire 0.3.1 - Abstraction over management of resources  https://hackage.haskell.org/package/acquire-0.3.1 (NikitaVolkov)
09:17:41 <int-e> merijn: If you do it yourself. And it doesn't apply to undefined >> return (), where the law would make the value less defined.
09:18:23 <merijn> int-e: Assuming >> is defined as >>= (which it is) that's not true
09:18:26 <int-e> (If a compiler were to optimize code and make it more defined, that could hide bugs that only manifest when that optimization is disabled...)
09:19:34 <int-e> merijn: see above. Depending on the monad, undefined >> return () may have a (non-bottom) whnf.
09:20:09 <int-e> merijn: whereas the monad laws demand that this is equal to undefined, which doesn't have a whnf.
09:20:51 <int-e> so playing fast and loose with them /may/ be dangerous.
09:22:20 <merijn> I recall there being a v2-build garbage collector (i.e. wiping stale dependencies from the store) anyone remember what it's called?
09:23:35 <dmj`> pigmej[m]: depends on who you ask :) 
09:24:05 <pigmej[m]> ;D
09:24:25 <dmj`> pigmej[m]: it's relative to your familiarity with abstractions, hence why 2 haskell people can never agree, and why the older a haskell person gets, the more set in their ways they get
09:25:36 <pigmej[m]> Understood
09:29:32 <merijn> hmm, the newest version of network removed iNADDR_ANY and says to use getAddrInfo instead, but I'm not sure how getAddrInfo would replace iNADDR_ANY?
09:29:57 <pigmej[m]> What I don't understand (somehow/still) how am I supposed to use newTVar with Data.HashMap.Strict from unordered-containers
09:30:14 <pigmej[m]> I have all the types but somehow I'm unable to construct valid haskell from all that :(
09:30:39 <dmj`> `tvar <- newTVarIO (mempty :: HashMap Key Value)`
09:31:58 <pigmej[m]> holy moly
09:33:21 <EvanR> merijn: maybe get addr info on "::"
09:33:53 <dmj`> `newState <- State <$> newTVarIO mempty`
09:34:04 <dmj`> pigmej[m]: ^
09:34:06 <exarkun> Why does `stack test --coverage` generate a report that always says my `deriving (Eq)` is uncovered when my tests do compare these values for equality?  is coverage measurement/reporting for derived typeclasses meaningful?
09:34:21 <pigmej[m]> dmj` thx, the first one seems to be working too somehow ;D
09:35:18 <dmj`> :D
09:35:38 <merijn> EvanR: hmm, seems like that might work
09:36:17 <pigmej[m]> btw haskell compiller messages are somewhat cryptic
09:38:24 <merijn> EvanR: ugh, but then it always returns AF_INET *and* AF_INET6 and adding a family type breaks it *sigh*
09:39:06 <merijn> Seems a bit odd that the most common way to bind a port isn't directly supported AND there's no documentation on how to do it...
09:39:55 <EvanR> getAddrInfo man page has information. But filtering by family is supposed to work. Of course behavior depends on individual system
09:40:16 <EvanR> in either case you can filter through results yourself
09:40:21 <merijn> EvanR: I'm talking about the haskell API
09:40:30 <EvanR> ... THE haskell api?
09:40:37 <merijn> EvanR: the network package
09:40:45 <EvanR> the ambiguously deprecated package?
09:40:58 <merijn> EvanR: Deprecated for what?
09:41:00 <EvanR> its still getting new versions?
09:41:24 <merijn> EvanR: The last release was June 20 this year...
09:41:33 <merijn> EvanR: Also, which other viable networking package even exists?
09:41:35 <EvanR> are you talking about the module which is just direct bindings to socket
09:41:44 <merijn> EvanR: Yes
09:41:55 <EvanR> OMG STOP HIGHLIGHTING ME
09:42:04 <exarkun> merijn: getAddrInfo on Nothing?
09:42:14 <EvanR> the direct bindings should be explained by man pages
09:42:22 <merijn> EvanR: No, that's an error
09:42:46 <merijn> EvanR: Except that in the manpage (and C) I have the INADDR_ANY constant to do that, which they removed in the latest release
09:42:50 <merijn> EvanR: Hence my question
09:42:57 <merijn> exarkun: No, that's an error
09:42:58 <EvanR> that makes no sense
09:43:13 <merijn> EvanR: In C you don't have to use get_addr_info, because you can directly bind to INADDR_ANY
09:43:30 <merijn> EvanR: Well, obviously that makes no sense, hence my question and frustration
09:43:37 <dmj`> pigmej[m]: wait until you see the rigid skolem errors
09:43:42 <EvanR> however in C you have been encouraged to always use get addr info for everything, for a while now
09:43:47 <dmj`> pigmej[m]: I'd just stay away from existential types in general
09:43:53 <EvanR> directly binding is a no no 
09:44:27 <pigmej[m]> dmj`: how can I say away from them? Any patterns?
09:44:33 <EvanR> its specifically because of the v4 vs v6 family issue
09:44:54 <dmj`> pigmej[m]: Add abstraction incrementally, and really weigh the cost-benefit analysis to yourself. It's really an art not a science. Aesthetically, cognitive overhead, bus factor, performance, compilation speed, readability.
09:45:42 <merijn> EvanR: meh, I'll just switch to older version of network then
09:45:47 <dmj`> pigmej[m]: the only real way to gain maturity in what you should do is to try everything and experience the pain / benefit of each thing.
09:45:49 <EvanR> if the system does not have an ipv4 connection (possible now) then binding to ipv4 socket wont work, on another system binding to v6 any address may work for both v4 and v6
09:46:09 <EvanR> on another system, you may have to use two server sockets for both families
09:46:21 <EvanR> (netBSD iirc)
09:47:04 <dmj`> pigmej[m]: a lot of haskell extensions were from academia and didn't consider industry concerns, some are a great boon, others only are great in specific scenarios, and some are completely worthless
09:47:42 <merijn> @where existential-antipattern
09:47:42 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
09:48:08 <merijn> It's not very hard to avoid existentials, they're only very rarely needed for very niche usecases
09:48:42 <merijn> However, if you come from an OOP background people are very often trigger happy in thinking "oh, I'll use existentials, it'll be like working with OO!"
09:49:34 <merijn> Because it seems like it should sorta work like interface inheritance or something, but it doesn't :)
09:50:12 <EvanR> but it makes stuff private!
09:50:41 <EvanR> (as does internal modules)
09:51:06 <EvanR> (which does so in a way that the client can bypass if necessary, so is better)
09:51:28 <dmj`> pigmej[m]: there's many ways to do the same thing, and realizing the simplest thing that completely solves your problem is a combination of deep domain expertise and GHC haskell usage / corner case. So being ready to justify why you did something requires knowledge of all of the other things that you could have done. 
09:51:55 <dmj`> and why they fall short, and you have to weight that.
09:52:00 <dmj`> weigh*
09:52:21 <EvanR> justification: #haskell said so
09:52:38 <merijn> "the fewer extensions the better for beginners" is a good heuristic :p
09:54:33 <pigmej[m]> <EvanR "(which does so in a way that the"> dmj`: thx
09:54:45 <pigmej[m]> Thx
09:55:08 <dmj`> pigmej[m]: If you want to do web stuff, I'd say you should know abstractions vertically up to monad transformers. Grabmueller has a good paper on this that is easy to step through (pun intended), and still compiles. From there your learning will branch out horizontally in library discovery / extension usage, research text, bytestring, aeson, concurrency. 
09:55:25 <dmj`> pigmej[m]: https://page.mi.fu-berlin.de/scravy/realworldhaskell/materialien/monad-transformers-step-by-step.pdf
09:55:51 <dmj`> pigmej[m]: https://ocharles.org.uk/pages/2014-12-01-24-days-of-ghc-extensions.html
09:55:56 <dmj`> ^ extensions
09:56:25 <EvanR> existential antipattern seems like a well known blog post, but why is "existentials = OOP" well known? is there a blog post?
09:56:47 <dmj`> pigmej[m]: https://simonmar.github.io/pages/pcph.html (only the second half of the book will be relevant)
09:56:53 <pigmej[m]> i’m not doing web ;) i’m doing microservice backend for some financial thingy
09:57:01 <pigmej[m]> Oki
09:57:45 <dmj`> ok, RESTy stuff :) 
09:58:32 <dmj`> I'm doing microservice stuff for financial things too, w/ servant
09:58:41 <dmj`> so jinx
09:58:46 <pigmej[m]> Kinda ;) I don’t care about rest but I do care about types ;d
09:58:49 <pigmej[m]> Hehe ;)
09:59:13 <EvanR> are you two doing financial microserver haskell in the same city?
09:59:22 <EvanR> same company perhaps?
09:59:29 <EvanR> check your cubical neighbor for each other
09:59:41 * dmj` turns around, taps pigme on the shoulder
10:00:02 <EvanR> (if so which city)
10:02:01 <dmj`> types are great
10:04:41 <pigmej[m]> haskell is my choice there. Wanted to give it a try.
10:05:08 <pigmej[m]> I have it already partially done in python, nim, golang and erl
10:08:11 <jgt> I've been doing web on Haskell for some years now and I still haven't bothered to learn transformers
10:08:19 <jgt> I'm lazy/stupid
10:08:23 <EvanR> wow really
10:08:36 <jgt> credit to the language really
10:08:52 <jgt> everything works great even though I don't know how
10:20:39 <rhylx> Hi :)
10:21:03 <jgt> rhylx: Hello
10:21:35 <rhylx> I just wanned to know if some has already tried to build a wire server : https://github.com/wireapp/wire-server?files=1
10:22:16 <rhylx> *someone
10:24:07 <rhylx> I am kind of new to haskell (have read learn you a Haskell) and wanned to develop a WhatsApp like app in haskell to practice this langage
10:26:49 <sm[m]> jgt++
10:27:21 <jgt> rhylx: seems like a worthwhile endeavour, but any reason not to start from scratch?
10:27:30 <sm[m]> no need to meddle with things under the hood
10:29:08 <jgt> rhylx: maybe take a look at whatsapp's whitepaper?
10:29:47 <rhylx> jgt: I don't really know where to start :p
10:29:47 <dmj`> pigmej[m]: its a good choice
10:30:27 <pigmej[m]> Let’s see ;)
10:30:54 <jgt> rhylx: it seems like building a whatsapp clone is a few different problems — there's the HTTP server, secrets sharing, client-side encryption/decryption, general infrastructure
10:32:27 <jgt> rhylx: I'd start somewhere simpler, like a community notice board or discussion forum type of thing
10:32:56 <rhylx> jgt: ok. Like an irc server?
10:33:13 <jgt> rhylx: like Twitter
10:33:26 <lavalike> irc is more fun
10:33:31 <jgt> (but fewer crazy people)
10:34:32 <rhylx> jgt: that's also why wire was a geat starting point , because there is already an app and I could learn how the app is coded while using it
10:36:27 <dmj`> pigmej[m]: heh
10:36:44 <dmj`> pigmej[m]: it's very pleasant imo
10:36:53 <jgt> rhylx: if it's helpful, I have some minimal infrastructure stuff available as an example here: https://github.com/jezen/minimal-hs-nix-aws
10:37:05 <jgt> rhylx: you could combine that with a more thoroughly scaffolded Yesod site
10:37:37 <rhylx> jgt: do you think a Twitter like app is simpler to code than a whatsapp like one?
10:38:55 <rhylx> jgt: ok, I'll have a look at it
10:39:30 <jgt> rhylx: yeah, definitely. Unless I am misunderstanding how closely you want to mimic WhatsApp, but one of their USPs is E2EE.
10:40:00 <jgt> and I'd take encryption as a separate study topic from Haskell
10:43:23 <rhylx> jgt : Okok. Yes, I would like first of all to code an appli that is an instant messaging app. And I don't really care about the VoIP part
10:45:09 <jgt> is there a way to discover where the performance bottlenecks are in a hspec/yesod-test test suite?
10:45:20 <rhylx> jgt: yes I have to check encryption, but first of all I would like to have a very basic working  app, and add features to it (the only thing is that I don't have or don't really know how to build this)
10:45:59 <jgt> rhylx: in that case, I think a fine place to start is getting a Yesod/Postgres app running
10:48:07 <rhylx> jgt: Ok. Could you please quickly tell me a bit more about it?
10:50:29 <jgt> rhylx: it's a Haskell web framework, which has a bit more included out of the box than other Haskell web frameworks. Different people have different opinions on how much stuff you should get out of the box. I'm of the opinion that a scaffolded Yesod app is a great starting point, and that's what I run all three of my businesses on. https://www.yesodweb.com
10:51:27 <rhylx> jgt: ok thanks a lot :D. I will give it a look!
11:19:30 * hackage polysemy 1.2.0.0 - Higher-order, low-boilerplate, zero-cost free monads.  https://hackage.haskell.org/package/polysemy-1.2.0.0 (isovector)
11:20:30 * hackage polysemy-plugin 0.2.3.0 - Disambiguate obvious uses of effects.  https://hackage.haskell.org/package/polysemy-plugin-0.2.3.0 (isovector)
11:34:30 * hackage mpi-hs 0.5.3.0 - MPI bindings for Haskell  https://hackage.haskell.org/package/mpi-hs-0.5.3.0 (eschnett)
11:36:30 * hackage small-bytearray-builder 0.2.0.0 - Serialize to a small byte arrays  https://hackage.haskell.org/package/small-bytearray-builder-0.2.0.0 (andrewthad)
11:37:44 <iqubic> testing.
11:56:35 <koz_> iqubic: Your test has failed.
12:01:58 <iqubic> On the contrary, my good sir. My test was testing to see if I was still logged into IRC. It succeeded in that regard.
12:10:19 <duncan> I'm looking for a reasonable library for checking the status of keyboard keys, as getChar doesn't express this. So far, vty looks promising albeit limited to Unix. Is there any alternative I should consider?
12:16:02 <merijn> duncan: For the terminal vty is the way to go, otherwise something like SDL?
12:16:15 <merijn> It depends what "status of keyboard keys" means?
12:16:59 <duncan> Mainly, I need to check if a key continues to be pressed.
12:17:17 <duncan> or if it suddenly becomes unpressed. etc.
12:17:27 <merijn> In what context? When your program is active? At all times? Should users be able to use other programs?
12:18:35 <duncan> At the moment, it just runs in the terminal, so I am only considering when it is running. 
12:19:06 <merijn> duncan: In the terminal you can't really check "is key held down" anyway
12:19:29 <merijn> That's not an API that is possible
12:20:43 <duncan> Well, it is sufficient to check the status of a given key at some point in time. It seems like vty is fine for that.
12:26:38 <dmwit> Sorry, how do you do that with vty?
12:28:15 <dmwit> I only see an interface for detecting "unpressed->pressed" edges. Nothing for the other edge or the current state. Have I missed it?
12:28:36 <merijn> dmwit: You can't even detect unpressed->pressed edges
12:28:55 <merijn> dmwit: Because if you keep a key pressed you will just get multiple repeated press events
12:29:05 <dmwit> Sorry, yes, I should have been more precise.
12:29:47 <dmwit> duncan: I think the correct answer to your question is "there is no alternative, not even vty".
12:31:27 <merijn> dmwit: There are alternatives, just not in the terminal
12:31:34 <merijn> something like SDL can do what he wants just fine
12:32:03 <merijn> This is because it's literally impossible in the terminal
12:34:34 <dmwit> "it runs in the terminal" -- duncan, 16 minutes ago
12:35:26 <duncan> Well, the current demo runs in the terminal. My main goal is to be able to check for combinations of keys at a given point in time, and plug that in to the reactive-banana.
12:35:38 <dmwit> Then again, detecting current key state is probably just an instrumental goal for something else that *can* be done.
12:35:50 <duncan> Currently I can use getchar to do that but that doesn't let me check combinations that way.
12:36:43 <duncan> I wouldn't be opposed to SDL if that would be helpful, but vty seems to be simpler at this point
12:37:01 <merijn> duncan: Right, it's simpler, on account of not being able to do what you want ;)
12:38:02 <duncan> Well, I'm not sure - the approach I was thinking of taking would check key status between states; but checking combinations of keys would appear to avoid that.
12:39:05 <sm[m]> You can check for combinations of an ordinary key and modifier keys in vty, at least
12:39:28 * dmwit feels like he's taking crazy pills
12:39:51 <dmwit> 2 of the 4 of us are definitely wrong.
12:40:55 <dmwit> At this point I feel like the only response left is to say "go forth and write code". You will soon know that it is you two, and not us two. =P
12:41:21 <sm[m]> Which 2 am I in then ? :)
12:41:42 <merijn> sm[m]: You are in the "close, but still wrong" camp :p
12:41:58 <sm[m]> Example: checking for combination of Up and Shift, https://github.com/simonmichael/hledger/blob/master/hledger-ui/Hledger/UI/AccountsScreen.hs#L340
12:42:06 <merijn> You can indeed check whether a modifier is held while a key is pressed
12:42:18 <dmwit> sm[m]: That does not check whether Up and Shift are pressed.
12:43:01 <merijn> sm[m]: But you cannot check whether the modifier is held/released nor can you detect whether the regular key is held or released
12:43:18 <sm[m]> Oh sure, I’m not claiming that
12:44:00 * hackage cryptol 2.8.0 - Cryptol: The Language of Cryptography  https://hackage.haskell.org/package/cryptol-2.8.0 (AaronTomb)
12:44:21 <dmwit> sm[m]: (...that registers to be informed when a key is pressed. But it does not check, Right Now, what the state of the keyboard is.)
12:44:46 <dmwit> (and even then "pressed" means something subtly different than what I think duncan wants it to mean.)
12:44:59 <merijn> dmwit: I was about to out-pedant you ;)
12:45:52 <sm[m]> Agreed. Regarding that, checking instantaneous keys state, I wanted to add that even with SDL etc. the accuracy is limited by your hardware.
12:45:54 <dmwit> Maybe: that registers to be informed when the terminal converts information about whether the key is pressed or not into an event for applications to handle.
12:48:49 <sm[m]> (Ie, don’t expect to check that all letter keys are currently pressed. I’m sure you weren’t going to do that.)
12:51:44 <merijn> Anyone know how briefDesc and fullDesc differ in optparse? I don't quite understand the difference, tbh
12:55:25 <EvanR> detect key up key down events and track the state yourself, if library X doesn't do it for you
12:55:53 <dmwit> EvanR: vty doesn't provide key up events
12:56:28 <EvanR> then i am sad
12:56:31 <merijn> And it is, in fact, as mentioned a number of times already, fundamentally impossible to get key up events on terminals, because it's literally impossible
12:56:38 <duncan> I have the means to track state, just not detecting key up/down events.
12:56:58 <duncan> Presumably, then, sdl is the answer.
12:56:59 <EvanR> right, events can implement state, but polling state cant implement events
12:57:12 <EvanR> thus events are fundamentally better
12:58:55 <merijn> EvanR: The real problem is that terminal application don't communicate with the user/user input, but with the pseudo terminal in kernel (which your terminal emulator talks to) and the only interface for pseudo terminals is "bytestreams", so you terminal emulator just inserts actualy characters into that bytestream, rather than key events
12:59:21 <merijn> EvanR: So if you hold 'a' your terminal emulator will just insert a sequence of 'a' bytes with configured repeat delay
12:59:28 <EvanR> ah so were not talking about vagaries of terminal hardware
12:59:40 <duncan> On hackage there is a library called key-state but I'm not sure about it.
13:00:09 <EvanR> yeah so terminal sounds like a bad interface for many purposes
13:00:30 * hackage discord-haskell 1.1.0 - Write bots for Discord in Haskell  https://hackage.haskell.org/package/discord-haskell-1.1.0 (Aquarial)
13:00:52 <EvanR> despite what i learned in computer science 101: "the keyboard is a file"
13:44:06 <merijn> I wish optparse used prettyprinter instead of ansi-wl-pprint :\
13:46:47 <merijn> It desperately needs something like "reflow"
14:23:21 <merijn> ansi-wl-pprint doesn't have a way to limit the width of a subsection of the Doc, does it?
14:40:20 <dmwit> merijn: I'm not sure of the answer to your question. But you might like the paragraph function that optparse exposes.
14:41:07 <merijn> dmwit: Oh, I already rolled my own reflow without go through Chunk :)
15:59:39 <mightybyte> The NY Haskell meetup will be streaming live in a few minutes at https://youtu.be/JOKwnsFP_BU
16:07:06 <EvanR> saw canon come through here yesterday i think
16:30:55 <EvanR> i wonder how canon's implementation relates to tarau recursively run length encoded natural numbers https://www.cse.unt.edu/~tarau/research/2014/RCN.pdf
16:36:20 <iqubic> koz_: I'm reading Sandy's book and I'm unsure of what an OpenSum is.
16:38:00 <iqubic> Which is a bit of an issue when I'm no at that chapter.
16:38:29 <koz_> iqubic: An open sum is a sum that can be extended with new values.
16:38:42 <koz_> For example, Either a b is a 'closed' sum, because it can only have Left as or Right bs.
16:39:02 <koz_> s/sum/sum type/g
16:39:35 <iqubic> So are you saying I can take it from a sum type with n parametrs to a sum type with n + 1 parameters?
16:39:44 <iqubic> How does it work?
16:39:57 <koz_> iqubic: Sandy's book explains that. It's a bit extensive though.
16:40:04 <iqubic> I know.
16:40:05 <koz_> (as in 'I can't easily describe this over IRC')
16:40:06 <iqubic> I know.
16:40:35 <koz_> It's not about _parameters_; it's about 'possible values'.
16:40:50 <koz_> Again, if you think about Either a b, I can't later decide 'I also wanna have Both a b'.
16:40:57 <koz_> With an _open_ sum, I could if I so wanted.
16:41:05 <iqubic> This OpenSum doesn't store values does it?
16:41:09 <iqubic> http://dpaste.com/3RDBSAM
16:41:22 <koz_> ('later' meaning 'once I'm using it as a library and I didn't write it')
16:41:23 <iqubic> It's just a list of possible types, isn't it?
16:42:26 <koz_> No?
16:42:36 <iqubic> Huh!?! Why not?
16:42:56 <koz_> For the same reason [a] isn't 'just a list of possible types'.
16:43:19 <koz_> I really recommend just carefully reading the relevant section.
16:43:41 <iqubic> What does that OpenSum repersent?
16:44:29 <koz_> It represents a sum type where we can add new possible values after it's been defined.
16:44:33 <koz_> (as I just said)
16:44:38 <iqubic> I see.
16:44:53 <koz_> As opposed to, say, Either a b, which can only have Left as or Right bs as inhabitants.
16:45:05 <iqubic> How do we define the initial OpenSum?
16:45:11 <koz_> Here, the user (not the author) is free to add as many or as few 'options' to it as they want.
16:45:38 <iqubic> How does the user add more options?
16:45:43 <koz_> Can you give me a page reference for where you first see that?
16:45:52 <koz_> I need to refresh my memory if I'm gonna explain this correctly.
16:45:56 <EvanR> iqubic: one way to define an open sum is relative to a given universe of available constructors
16:46:10 <EvanR> an empty open sum is like Void, it allows nothing
16:46:26 <EvanR> you can extend it with any of the constructors, along with a type of payload
16:46:57 <EvanR> in javascript... this universe of constructors is your field names
16:47:17 <iqubic> koz_: It's just chapter 11 of Sandy's Book.
16:47:37 <iqubic> He starts talking about it in 11.2, which is one or two pages into chapter 11.
16:47:52 <jle`> iqubic: the OpenSum you gave literally stores an 'f t', heh
16:48:29 <iqubic> jle`: This is the implementation Sandy Maguire shows in his book "Thinking With Types."
16:48:46 <jle`> just answering your question earlier, asking if it stored values or not
16:49:02 <iqubic> And is an "f t" a value
16:49:06 <iqubic> ??
16:49:14 <jle`> indeed, this is GADT syntax
16:49:28 <jle`> in normal syntax it'd be data OpenSum f ts = UnsafeOpenSum Int (f t)
16:49:35 <jle`> *normal data declaration syntax
16:49:48 <koz_> iqubic: Pages 141 and 142 explain it very clearly. Is there something specific you're not following here?
16:53:57 <jle`> admittedly the unsafeness scares me
16:54:08 * jle` runs away to his hide with his inductive open sums
16:54:21 <koz_> jle`: I think Sandy gives an example of a safe one later.
16:54:49 <jle`> i'm sure; it's just that this one gives me the heebie jeebies
16:54:52 <koz_> It's been a while since I had to look into that though.
16:54:55 <koz_> Lol.
16:55:16 <koz_> Do you get such heebie-jeebies from vector-sized? :P
16:55:30 * hackage stratosphere 0.42.0 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.42.0 (jdreaver)
16:55:52 <EvanR> jle`: where is your inductive open sum
16:57:15 <jle`> koz_: it's slightly less extreme since it doesn't involve any unsafecoercing of Type-based types
16:57:36 <jle`> EvanR: i was speaking metaphorically but there are a few i've used
16:57:37 <koz_> Yeah, I guess. As far as I understand it, the unsafe OpenSum Sandy uses is for efficiency?
16:58:07 <jle`> it's similar to a list vs vector kind of thing yea
16:58:13 <jle`> EvanR: a common one people use is:
16:58:22 <jle`> data Sum :: (k -> Type) -> Type -> Type where
16:58:33 <jle`>   Here :: f a -> Sum (a ': as)
16:58:40 <jle`>   There :: Sum as -> Sum (a ': as)
16:58:57 <koz_> Is that basically a typelevel Swierstra (sp?) data type a la carte?
16:58:59 <jle`> but i don't really like this one because it nests the f under a bunch of layers
16:59:03 <EvanR> where does the f go... why is this like a list
16:59:28 <jle`> EvanR: it's a sum, it contains exactly one f a
16:59:45 <jle`> a `Sum Identity '[Int, Bool, String]` contains either an Int, a Bool, or a String
16:59:54 <EvanR> ok you just left out some args on Sum
16:59:59 <jle`> oh :O i did
17:00:33 <jle`> the one i like to use more separates the inductive type information from the value
17:00:44 <EvanR> and [Int,Int,Bool] would be possible, but theres no "handle" to the cases
17:01:04 <jle`> not sure what you mean; you can handle the cases by consuming each branch
17:01:09 <EvanR> its like a numeric index, which is invalidated as soon as you extend it for some reason 
17:01:37 <jle`> the nice thing is that it's type-safe in its usage
17:01:42 <EvanR> you handle the cases, but there is no visual cue to which cases is which
17:01:54 <EvanR> like Left Right, Worked Failed...
17:02:19 <iqubic> "By definition, an open sum is a container of a datawhose type isn’t known statically."
17:02:20 <jle`> hm, i'm not sure what you mean.  you'd have to go down each case inductively, yeah
17:02:25 <iqubic> How does that work?
17:02:27 <EvanR> in the use case of "extensible exceptions" youd probably want t cue
17:02:47 <EvanR> jle`: in terms of the usual closed sum, there are no ctor names
17:03:05 <MarcelineVQ> Could you pretend some with pattern synonyms
17:03:09 <jle`> ah yeah, the constructor names aren't there.  but in OpenSum it's similarly so, it's based on Int
17:03:11 <EvanR> maybe you encode them into newtypes that go in the list
17:03:33 <EvanR> newtype StupidError1 = StupidError1 ()
17:03:33 <jle`> the inductive sum i use more often is more closely related to OpenSum
17:03:42 <EvanR> newtype StupidError2 = StupidError2 String
17:04:01 <jle`> data Index :: [a] -> a -> Type where IZ :: Index (a ': as) a; IS :: Index as a -> Index (b ': as) a
17:04:17 <jle`> data Sum :: (k -> Type) -> [k] -> Type where Sum :: Index as a -> f a -> Sum f as
17:04:51 <jle`> so it's pretty much identical to the OpenSum case except instead of Int, we have an inductive Nat type basically that indexes into as to get a
17:04:53 <EvanR> does this avoid the layering thing
17:05:03 <jle`> yeah, the 'f a' is available nakedly
17:05:11 <EvanR> sexy
17:05:24 <jle`> but you do need to inductively go down the Index to get the witness that the 'f a' is indeed in 'as'
17:05:44 <jle`> i suppose you could use it unsafely too by just ignoring the Index as a and unsafe-coercing, so you get the best of both worlds maybe?
17:05:45 <EvanR> at runtime?
17:06:02 <jle`> yeah, you have to match on the Index inductively to figure out "which a" 'f a' is
17:06:13 <jle`> but if you're comfortable just ignoring 'a' you can just use it directly forall a. f a
17:06:27 <EvanR> the only reason you need to run the proof would be if the proof froze up...
17:06:57 <EvanR> i'm not sure if thats worse than indexing blinding causing a segfault
17:07:03 <EvanR> blindly
17:07:36 <jle`> it's not necessarily a 'proof', because it also tells you "which" a is in as, if there is more than one
17:07:40 <EvanR> always thinking of ways that fancy types can be exploited for performance
17:07:43 <jle`> so it's basically a smart Int
17:07:53 <jle`> well, a smart [()]
17:08:38 <iqubic> koz_: In the middle of page 142, Sandy writes: "Once t enters an Open Sum, it can never be recovered. Knowledge of what t is is lost forever." However, on page 144 the function 'prj' is written to recover a certain t.
17:08:53 <EvanR> i guess that can't be avoided, case analysis is a sequential thing
17:08:57 <iqubic> With the type of t being known to the 'prj' function.
17:09:03 <iqubic> koz_: How does that work?
17:09:27 <Zer000> What should I use for interacting with PostgreSQL? There are a lot of choices in haskell. I have a web service that will gather data and I will have an application server that will allow people to search the data with full text search. I want to keep things simple and fast.
17:12:00 <EvanR> postgresql-simple ?
17:15:12 <iqubic> koz_: Do you know why Sandy says that the type of t is lost, but then procceeds to recover it in 'prj'?
17:15:21 <iqubic> What allows him to do that?
17:15:51 <Zer000> EvanR, the reason I didn't immediately go with it is because hasql is supposed to be "a lot faster" but I don't know how true that is
17:19:38 <EvanR> simple, fast, pick 2 : )
17:21:57 <iqubic> Also, I have no idea what the Int parameter is doing in the UnsafeOpenSum constructor.
17:22:17 <MarcelineVQ> Then read on 2 paragraphs where it's explained :>
17:22:35 <MarcelineVQ> Though if you got to prj it's been exlpained already
17:22:51 <MarcelineVQ> And relates to your questions
17:24:10 <dycan> Hi all, Is there any other way to make Yesod have https in nixos?  Keter seems not working in nixos.
17:24:37 <iqubic> Oh. Wait... The Int is what allows you to recover the value of t.
17:26:16 <iqubic> Is that right?
17:26:52 <Zer000> dycan, why don't you put your app behind nginx? Then configure nginx to serve on https with letsencrypt
17:26:57 <Zer000> this is pretty easy on nixos
17:29:00 <dycan> Zer000: sounds great! I'll look into nginx. Thank you!
17:30:05 <zeta_0> `
17:32:39 <zeta_0> what is the best programming problem website for `functional` programming, the only website that i have found so far that has support for functional programming is hackerrank?
17:34:20 <iqubic> Technically any programming problem can be done with functional programming.
17:35:41 <zeta_0> iqubic: so what is the best one in general?
17:36:17 <EvanR> some problems lend themselves to a functional solution more than others
17:37:14 <EvanR> embarrassingly functional problems
17:38:44 <koz_> iqubic: Yeah, exactly. In general, I would say a good strategy for any reading is 'read everything first, then consider if your question has been answered'.
17:38:45 <EvanR> why did my message on NY haskell livestream trollbox get deleted :'(
17:38:50 <koz_> It applies very much here.
17:39:41 <EvanR> "someone told me the answer is somewhere in this chapter, i read 8 out of 9 of the pages and didn't find it. What gives"
18:37:17 <dmwit> ?tell zeta_0 The Advent of Code problems are nice and completely language independent.
18:37:18 <lambdabot> Consider it noted.
19:00:49 <koz_> Is there a convenient library or function that lets me separate a Word32 into two Word16s?
19:04:41 <lyxia> No idea, fromIntegral and div?
19:05:46 <koz_> lyxia: I guess I could use that.
19:16:01 <wwwww> anyone knows how can we compiile haskell to windows from linux?
19:16:38 <EvanR> virtual machine windows
19:17:33 <wwwww> no thats not i mean and you know that
19:28:48 <EvanR> as of now yeah
19:30:37 <hololeap> hi everyone. i'm trying to understand when it isn't appropriate to use the strict state monad (as opposed to the lazy version). this explains that the strict version can misbehave when traversing over an infinite list. are there any other examples?
19:30:39 <hololeap> https://kseo.github.io/posts/2016-12-28-lazy-vs-strict-state-monad.html
19:32:16 <hololeap> it seems like in most use cases, you wouldn't have something stored in State that would stay as a thunk
19:32:48 <hololeap> so you might as well use the strict version, or am i missing something?
19:33:41 <lyxia> you're right
19:38:07 <hololeap> =)
19:38:27 <lyxia> another use case might be some knot-tying technique where you use state "from the future"
19:38:40 <lyxia> but I'm not sure that's much more than a good party trick
19:39:06 <hololeap> how do i get invited to THOSE parties??
19:39:25 <hololeap> ;)
19:41:13 <blankhart> psychic paper
19:44:10 <hololeap> well, what about the use case where you have `StateT (a,b)` and have actions that only use `a` or `b`. would the strict version force the evaluation of the unneeded argument?
19:44:47 <hololeap> (or would it only be forced to WHNF)
20:00:35 <EvanR> hololeap: well, (a,b) is a lazy pair
20:01:00 <EvanR> you can force the pair all day and the two contents are unaffected
20:02:04 <EvanR> i imagine if you wanted strict state with multiple items youd use strict pair, or more likely a record with strict fields
20:10:30 * hackage fast-logger 2.4.17 - A fast logging system  https://hackage.haskell.org/package/fast-logger-2.4.17 (KazuYamamoto)
20:27:34 <Guest_32> Hello
20:56:41 <buhman> I was looking at the definition of mapMaybeM, after struggling to do the same transformation with mapMaybe. catMaybes <$> mapM makes complete sense, but I still wonder: In general, is there really no way to ~directly transform (a -> m b) -> (a -> b) -> m b ?
20:57:00 <buhman> just looking at that type I realize that makes no sense, but hopefully someone understands what I mean
21:05:03 <dmwit> Well I for one don't understand what you mean.
21:06:14 <monochrom> @type catMaybes <$> mapM
21:06:16 <lambdabot> error:
21:06:16 <lambdabot>     • Couldn't match type ‘[a] -> m [b]’ with ‘[Maybe a1]’
21:06:16 <lambdabot>       Expected type: (a -> m b) -> [Maybe a1]
21:06:18 <MarcelineVQ> (catMaybes .) . mapM perhaps, I also don't understand the question though
21:06:33 <monochrom> @type (catMaybes .) . mapM
21:06:35 <lambdabot> (a1 -> [a2]) -> Maybe a1 -> [a2]
21:06:55 <jle`> buhman: transform `(a -> m b) -> (a -> b) -> m b` into what?
21:06:58 <MarcelineVQ> like, which mapMaybeM
21:08:09 <dmwit> :t \f xs -> catMaybes <$> mapM f xs -- almost certainly what was meant
21:08:10 <lambdabot> Monad f => (a1 -> f (Maybe a2)) -> [a1] -> f [a2]
21:08:46 <dmwit> But even if that was the type (and implementation) buhman intended, I still don't understand the question.
21:10:21 <dmwit> Maaaaybe they're asking if you can do this without constructing an intermediate list. But I don't know. So I will wait for clarification.
21:13:39 <jle`> we may never know
21:16:16 <iqubic> koz_: What makes the 'inj' function defined on page 143 of Thinging With Types a safe function?
21:16:28 <iqubic> *safe ctor.
21:16:41 <buhman> dmwit: so, if my type is (a -> m Maybe b), can I pass that directly to mapMaybe ?
21:16:48 <buhman> "directly"
21:17:18 <buhman> also yes, without constructing an intermediate list
21:17:49 <buhman> (a -> m (Maybe b)), sorry
21:18:30 <buhman> though, I think it would be valid to rewrite that function as some kind of monad transformer, I just don't have an intuition for how
21:19:16 <iqubic> :t mapMaybe
21:19:18 <lambdabot> (a -> Maybe b) -> [a] -> [b]
21:21:21 <jle`> buhman: it doesn't make too much sense for a function to be a monad transformer
21:21:32 <jle`> monad transformers are type constructors, not value-level functions
21:21:40 <buhman> jle`: I am bad af asking questions precisely, sorry
21:21:55 <jle`> oh, that wasn't meant to admonish you or tell you you did anything wrong
21:21:59 <jle`> so no need to apologize?
21:22:05 <jle`> i'm just trying to help guide your intuition :)
21:22:58 <buhman> I mean, rewrite the type/definition of (a -> m (Maybe b)) as a MaybeT m b or mT Maybe b
21:23:21 <jle`> i suppose you could, but i don't think there would be any benefit to doing so
21:24:04 <jle`> `MaybeT m a` a newtype wrapper for `m (Maybe a)`, so you could just substitute it in `a -> m (Maybe b)` as `a -> MaybeT m b`
21:24:31 <jle`> just like you could also sbustitute it as Identity (Identity a -> m (Maybe (Identity b))
21:24:35 <buhman> oh really? I thought it was some other magic
21:24:40 <jle`> since `Identity a` is a newtype wrapper over `a`
21:24:45 <jle`> but like...what's the point, you know?
21:25:00 * hackage memory 0.15.0 - memory and related abstraction stuff  https://hackage.haskell.org/package/memory-0.15.0 (VincentHanquez)
21:25:01 <buhman> ... the point is to implement mapMaybeM without making an intermediate list
21:25:36 <jle`> ah, i was talking about 'rewriting the type' to use MaybeT m b
21:25:46 <buhman> ah :)
21:25:52 <jle`> but yeah, it's just a newtype wrapper, there is no actual difference logically
21:28:10 <jle`> buhman: so yeah, changing the type signature won't give you any different of a function, it's just a newtype wrapper over m (Maybe b), so you can just replace them back and forth
21:28:26 <jle`> buhman: using newtype wrappers or monad transformers doesn't allow you to do anything you couldn't already do
21:28:31 <jle`> they don't enable any extra or magical functionality
21:28:49 <buhman> that is actually surprising, somehow
21:28:53 <jle`> if you can't write the function using normal pattern matching, function application, etc., then using a newtype wrapper like MaybeT won't give you any abilities you didn't already have
21:29:14 <jle`> really it's mostly just for convenience/to remove extra noise, and maybe also to help your code be more self-documenting in some cases
21:29:49 <dmwit> I mean... transformers are implemented in Haskell. Not some more basic language. So of *course* they can be implemented using normal pattern matching, function application, etc.
21:31:34 <dmwit> Anyway. The core of your question is an interesting and frustrating one. As far as I know, converting pure lazy computations into their monadic counterparts (without sacrificing their laziness/allocation properties) cannot be generically done in Haskell.
21:31:55 <dmwit> It is a source-to-source transformation, and there do not currently exist tools that will do that transformation for you, so it is a by-hand process.
21:32:36 <dmwit> (I believe it is possible to create such tools. Just nobody has, yet. I did a proof-of-concept start of one to teach myself how HM works, but it would take a pretty serious engineering effort to make it actually useful.)
21:34:56 <buhman> huh, that's good to know. I'll stop trying to do that then
21:35:43 <buhman> thanks all!
21:47:50 <jle`> dmwit, buhman: i think also one thing that complicates issues is that there might be more than one way to 'convert', so it might not make much sense to automate
21:47:59 <libertyprime> is there a document whcih explains the difference between ~/.ghci and normal haskell synatx?
21:48:19 <jle`> for example consider find :: (a -> Bool) -> [a] -> Maybe b
21:48:39 <jle`> but there is more than one way to implement findM :: (a -> m Bool) -> [a] -> m (Maybe b)
21:48:49 <jle`> libertyprime: afaik ~/.ghci is just normal ghci syntax
21:49:05 <jle`> like a script of things typed into ghci
21:49:29 <sm[m]> yes, so GHCI chapter in the GHC user guide
21:50:22 <Zer000> bye
22:45:23 <libertyprime> jle`: thanks.
22:48:55 <dmwit> jle`: Certainly. But if you just handed somebody that type signature and asked them to guess what the implementation was, I bet they'd all guess the same thing.
22:49:26 <iqubic> I don't know of any implementation. I also don't know what function we're talking about.
22:49:35 <dmwit> jle`: Just like folks would be wildly surprised to find out that you chose to implement `find :: (a -> Bool) -> [a] -> Maybe a` (not `b`, I assume that was just a typo) by iterating from the end.
22:49:49 <jle`> hehe. yes it was a typo
22:49:58 <iqubic> dmwit: Want to test your theory on me?
22:50:02 <dmwit> No.
22:50:25 <libertyprime> hey guys. im trying to compile a simple function and having trouble understanding the error it's giving me: http://ix.io/1UjZ
22:50:39 <iqubic> You don't want to give me the type signature, and get me to write an implementation?
22:51:05 <iqubic> :t matchRegex
22:51:07 <lambdabot> error: Variable not in scope: matchRegex
22:51:30 <iqubic> libertyprime: Can you give me the type signature for matchRegex?
22:51:39 <jle`> libertyprime: my guess is that matchRegex returns [String], and not (String,?)
22:51:41 <ion> Looks like matchRegex :: String -> [String]
22:51:48 <ion> judging from the error message
22:51:50 <dmwit> libertyprime: Yes, b0 is a placeholder for a type. No, not a type not yet inferred, but a type not yet constrained.
22:52:13 <dmwit> libertyprime: matchRegex presumably is the thing which is producing the [String] expectation.
22:52:20 <iqubic> I was going to state basically the same exact thing.
22:52:40 <dmwit> iqubic: I think String -> Maybe [String], actually.
22:52:44 <dmwit> sorry, misnick
22:52:46 <dmwit> ion: ^
22:52:49 <libertyprime> thanks a lot :)
22:53:18 <jle`> libertyprime: and yeah, doing Just (x,y) -> readMaybe x, it can infer that x is supposed to be String, but not what y is expected to be
22:53:40 <jle`> libertyprime: usually a lower case name + a number after it signifies a 'placeholder' variable name
22:53:42 <dmwit> libertyprime: And a quick look at the documentation confirms that matchRegex returns a Maybe [String], so this pattern match against a tuple definitely isn't right.
22:53:57 <ion> dmwit: Ah, you are right.
22:54:44 <jle`> well, all lowercase identifier types will be type variables instead of actual known types, but usually ghc will try its best to match some known situation where someone used a type variable in a similar place
22:58:26 <ski> > let mfind = (mconcat .) . mapMaybe in getFirst (mfind ((First . Just <$>) . \n -> guard (even n && n > 0) *> pure n) [0,1,1,2,3,5,8,13])
22:58:29 <lambdabot>  Just 2
22:58:30 <ski> > let mfind = (mconcat .) . mapMaybe in getLast (mfind ((Last . Just <$>) . \n -> guard (even n && n > 0) *> pure n) [0,1,1,2,3,5,8,13])
22:58:32 <lambdabot>  Just 8
23:00:45 <jle`> huh i never realized that . associates that way with lambdas until now. makes sense, it'd be the same as for $
23:01:13 <jle`> > (negate . \case Just x -> x; Nothing -> 0) Just 3
23:01:15 <lambdabot>  error:
23:01:15 <lambdabot>      • Couldn't match expected type ‘Maybe (Integer -> t)’
23:01:15 <lambdabot>                    with actual type ‘a0 -> Maybe a0’
23:01:27 <jle`> oh it must be my semicolon
23:01:36 <jle`> > (negate . \case Just x -> x; Nothing -> 0) (Just 3)
23:01:39 <lambdabot>  -3
23:01:43 <jle`> oh ho ho
23:01:54 <ski> it's occasionally hand to do that
23:01:55 <MarcelineVQ> :>
23:02:00 <ski> s//y/
23:02:24 <MarcelineVQ> yes, it's occasionall hand
23:02:34 <ski> ye
23:02:40 * jle` . o O (ski: yiyty'ysy yoycycyaysyiyoynyaylylyyy yhyaynydy ytyoy ydyoy ytyhyayty)
23:03:00 <ski> ytyhyaynyky yyyoyuy
23:04:02 <ski> @type catMaybes (zipWith ($) (cycle [const Nothing,Just])
23:04:04 <lambdabot> error:
23:04:04 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
23:04:09 <ski> @type catMaybes . zipWith ($) (cycle [const Nothing,Just])
23:04:10 <jle`> i still am waiting to be able to make the jump into full on -XBlockArguments
23:04:11 <lambdabot> [a] -> [a]
23:04:12 <iqubic> what is going on here?
23:04:48 <iqubic> jle`: What is a Block Argument?
23:05:02 <jle`> -XBlockArguments is a ghc syntax extension
23:05:19 <ski> when you stop GHC from having an argument with you about syntax
23:06:04 <jle`> -XNoBlockArguments just gives ghc permission to let you have it
23:06:14 <jle`> and never hear the end of it
23:06:54 <iqubic> I see.
23:07:01 <dmwit> BlockArguments is a terrible name
23:07:25 <koz_> UndecidableInstances is also pretty bad.
23:07:29 <koz_> Needlessly scary.
23:07:31 <iqubic> ski: try this instead "s/d/dy/"
23:07:43 <dmwit> But BlockArguments is not even correct.
23:07:58 <dmwit> e.g. it enables `f \x -> ...` but lambdas are not blocks.
23:07:58 <ski> what's "dyo" ?
23:08:01 <ski> japanese ?
23:08:42 <MarcelineVQ> ohohojoudyo
23:08:59 <iqubic> I didn't notice the d in 'do'
23:10:02 * ski . o O ( <https://en.wikipedia.org/wiki/R%C3%B6varspr%C3%A5ket> )
23:13:10 <jle`> id :: a -> a
23:13:15 <jle`> id =\ a -> a
23:13:34 <jle`> makes sense, (=\) = (::)
23:14:07 <MarcelineVQ> ::::)
23:14:11 <jle`> oh huh i guess the space is necessary
23:14:41 <iqubic> koz_: I'm reading "Thinking With Types" and I have a question. How is the function 'inj' (defined on page 143) a safe constructor for an OpenSum.
23:14:49 <jle`> id :: a -> a
23:14:55 <jle`> id= \ a -> a
23:15:05 <jle`> fst :: (a, b) -> a
23:15:11 <jle`> fst= \ (a, b) -> a
23:15:17 <iqubic> I love this.
23:15:25 <jle`> i wonder what other functions are lexically identical to their types
23:15:26 <iqubic> It doesn't work for all functions though.
23:15:35 <iqubic> jle`: snd
23:16:00 <jle`> singleton :: a -> [a]
23:16:04 <jle`> singleton= \ a -> [a]
23:16:31 <iqubic> Heh.
23:16:42 <jle`> conclusion: every function works
23:16:58 <iqubic> try making map.
23:17:44 * ski . o O ( "Now you're thinking with types." )
23:18:26 <iqubic> I was already thinking with types. Do you know what book I've been reading.
23:18:37 <MarcelineVQ> iqubic: it's safe in that the typechecker accepts it and it doesn't use undefined or error or unsafeCoerce
23:18:55 <iqubic> I see.
23:19:08 * ski idly wonders what's the type of this `inj'
23:19:11 <iqubic> But how does this extend the OpenSum succeessfully?
23:19:15 <jle`> runIdentity :: (Identity a) -> a
23:19:22 <jle`> runIdentity= \(Identity a) -> a
23:19:26 <jle`> that's all i got
23:20:02 <MarcelineVQ> iqubic: by adding another type to the type-level list of OpenSum, and thus another possibility of what it could contain
23:20:35 <MarcelineVQ> At least that's my impression looking at it, to be fair I haven't read the chapter
23:21:12 <dmwit> jle`: Of course frst and first and firrst and so on also work.
23:21:23 * ski idly wonders whether this `inj' is a `void' type of thing
23:21:54 <dmwit> unsafeCoerce :: a -> undefined
23:21:57 <ski> @djinn forall a. Void -> a
23:21:57 <lambdabot> f = void
23:22:02 <dmwit> unsafeCoerce= \ a -> undefined
23:22:11 <iqubic> Hehe.
23:22:26 <ski> now, that's not ok
23:22:32 <iqubic> Why not?
23:22:44 <dmwit> I think ski might be talking to me. =)
23:22:55 <jle`> it's technically ok on a theoretical implementation of haskell where no types share any representational similarities
23:22:59 <ski> ya
23:23:14 <MarcelineVQ> ski: https://gist.github.com/MarcelineVQ/342ef0704312c07be6fa37e28a0975cd
23:23:45 <dmwit> Ah, and how can we forget
23:23:48 <dmwit> unit :: ()
23:23:54 <iqubic> This uses First Class Families.
23:23:56 <dmwit> unit= \()... oh wait
23:24:22 <iqubic> Which is a hackage package
23:24:38 <iqubic> https://hackage.haskell.org/package/first-class-families
23:24:57 <iqubic> You should add import Fcf to the top of that file.
23:25:13 <jle`> toUnit :: a -> ()
23:25:14 <ski> MarcelineVQ : that looks fun :)
23:25:32 <jle`> toUnit= \ a -> ()
23:25:33 <MarcelineVQ> it's just meant as an overview to the structure involved to get ski some info rather than a runnable example
23:25:57 <iqubic> I have no idea how one successfully calls 'inj'
23:25:57 <MarcelineVQ> but yeah Fcf would get you there, probably providing that Stuck type
23:26:33 <jle`> `inj (Just True) :: Maybe Bool -> OpenSum Maybe '[Int, Bool, String]`
23:26:45 <jle`> um i accidentally a 
23:26:55 <jle`> inj :: Maybe Bool -> OpenSum Maybe '[Int, Bool, String]
23:27:10 <jle`> etc.
23:27:49 <jle`> huh, Stuck is clever.
23:28:11 <iqubic> And Fcf provides all the type families used to make the type FindElem work
23:28:55 <jle`> that's how you'd call it, iqubic. for fun, try thinking of ways you can instantiate the type variables so that it can be called.
23:28:59 <iqubic> jle`: What does this do exactly? `inj (Just True) :: Maybe Bool -> OpenSum Maybe '[Int, Bool, String]`
23:29:07 <jle`> iqubic: i corrected it later
23:29:16 <jle`> but it injects a Maybe Bool into an OpenSum Maybe '[Int, Bool, String]
23:29:21 <iqubic> Ah. I see.
23:29:33 <jle`> an OpenSum Maybe '[Int, Bool, String] can be thought of as either a Maybe Int, a Maybe Bool, or a Maybe String
23:29:49 <iqubic> And then `prj` is show, and used to fetch out the value later.
23:30:25 <iqubic> It uses the Int in 'UnsafeOpenSum' to look up the type index and do an unsafeCoerce with that info.
23:30:48 <jle`> 'inject' here is used in the way that `Left` injects an `a` into `Either a b`
23:32:14 <iqubic> http://dpaste.com/2SVWSCB
23:32:31 <iqubic> And I assume project is used to fetch the value out?
23:32:46 <iqubic> When would Project ever return Nothing/
23:33:23 <iqubic> Also, what makes the unsafeCoerce there actually safe?
23:33:33 <iqubic> project is defined in my paste.
23:33:59 <MarcelineVQ> when the type at the index that Int points to doesn't match t
23:34:02 <jle`> prj :: OpenSum Maybe '[Int, Bool, String] -> Maybe (Maybe String)
23:34:19 <jle`> so it'd fail if you  tried to prj into String, what you had previously injected as Bool
23:34:28 <iqubic> Ah. I see.
23:34:31 <jle`> it's the same situation where fromLeft or fromRight would fail
23:34:36 <iqubic> Ah. I see.
23:34:39 <ski> but `prj' looks more like a partial inverse of `inj' rather than a projection (in the sense of `fst :: (a,b) -> a', or even in the sense of an idempotent, which could split into a retraction (split epi) and a section (split mono))
23:34:56 <iqubic> What makes the unsafeCoerce safe here?
23:34:59 <jle`> yeah, i'm a bit iffy on it, also because the list might have duplicates
23:35:34 <MarcelineVQ> That should probalbly be an exercise for you for the chapter, though others might feel differently
23:35:50 <jle`> hm i suppose duplicates shouldn't matter
23:36:16 <MarcelineVQ> The exercise being to understand what's happening well enough to determine if this is safe, or why it is safe
23:36:17 <jle`> iqubic: if you had OpenSum Maybe '[Int,Bool,String], and the index stored as 2, then you'd expect to be holding a Maybe String
23:36:35 <jle`> if the index stored is 1, you'd expect to be holding a Maybe Bool
23:36:42 <jle`> it would be unsafe if these expectations are incorrect
23:36:51 <jle`> s/unsafe/incorrect
23:37:06 <iqubic> The look up is done with FindIndex, as defined here: https://hackage.haskell.org/package/first-class-families-0.5.0.0/docs/Fcf.html#t:FindIndex
23:37:34 <iqubic> So, you can look at that source to see how duplicates are handled.
23:37:58 <jle`> iqubic: think about what situations would cause unsafeCoerce to be unsafe/wrong, and how those situations are avoided and prevented from happening
23:42:26 <iqubic> Let's say you an 'OpenSum Maybe '[Int,Bool,String]', and the index stored as 2, and then the unsafeCoerce is only safe if the element being stored has type 'Maybe String'
23:43:38 <jle`> right, so could we ever have a situation where the index is 2 and the element *isn't* a Maybe String ?
23:43:50 <iqubic> Yes.
23:44:26 <jle`> if the answer is yes, the unsafeCoerce is not safe/valid
23:44:31 <jle`> if the answer is no, then it is.
23:45:33 <iqubic> If we call this project function and specify that the return type should Maybe Int, then we'd get index 1 chosen. Which makes the unsafeCoerce unsafe.
23:46:26 <iqubic> the 'i == findElem @t @ts' checks to see if the type of the element being stored is the same as the type of element we are expecting to receive.
23:47:16 <iqubic> With a type signature of 'prj :: forall f t ts. Member t ts => OpenSum f ts -> Maybe (f t)' it is the caller that decides what the 'Maybe (f t)' is.
23:47:51 <jle`> iqubic: if i is not the same as the stored item, we return Nothing
23:47:54 <jle`> so unsafeCoerce is never used
23:47:59 <iqubic> I know.
23:48:05 <jle`> is there a situation where unsafeCoerce would be used, where it is unsafe?
23:48:17 <iqubic> Not that I can think of.
23:48:23 <jle`> so it's safe
23:48:57 <iqubic> Am I right that the caller gets to decide the the return type here?
