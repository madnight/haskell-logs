00:04:16 <ski> > evalCont (do m <- L.forAll [2,3,5,7]; n <- L.forSome [1,2,4,8]; return (abs (m - n) <= 1))
00:04:18 <lambdabot>  True
00:04:19 <ski> > evalCont (do n <- L.forSome [1,2,4,8]; m <- L.forAll [2,3,5,7]; return (abs (m - n) <= 1))
00:04:21 <lambdabot>  False
00:04:32 <ski> (s/forAll = cont . flip any/forAll = cont . flip all/)
00:07:48 <iqubic> What is the point of that?
00:08:05 <ski> avoiding nesting
00:08:11 <iqubic> I see.
00:08:20 <iqubic> What does that query prove though?
00:08:30 * hackage haiji 0.3.1.0 - A typed template engine, subset of jinja2  https://hackage.haskell.org/package/haiji-0.3.1.0 (NoriyukiOhkawa)
00:09:26 <ski> % (`all` [2,3,5,7]) \m -> (`any` [1,2,4,8]) \n -> abs (m - n) <= 1
00:09:26 <yahb> ski: True
00:09:28 <ski> % (`any` [1,2,4,8]) \n -> (`all` [2,3,5,7]) \m -> abs (m - n) <= 1
00:09:28 <yahb> ski: False
00:10:05 <jle`> forall m in [2,3,5,7]. exists n in [1,2,4,8] s.t. |m - n| <= 1
00:10:06 <ski> it holds that : for all numbers in `[2,3,5,7]', there is a number is `[1,2,4,8]' with distance at most one to the former number
00:10:49 <iqubic> monochrom: I'm going to ask the one guard this question: (\n -> even n && odd n) If the response is true, then you are a liar. If the response if false, than you are a truth teller.
00:10:50 <ski> it does not hold that : there is a number in `[1,2,4,8]', such that for all numbers in `[2,3,5,7]', the distance is at most one to the former number
00:11:25 <jle`> evalCont (do m <- L.forAll [1..]; n <- L.forSome (iterate hailstone m); return (n == 1))
00:11:40 <ski> `> ' ?
00:12:08 <ski> (also, that'll either be `False', or not terminate, obviously)
00:12:13 <jle`> @let hailstone n | even n = n `div` 2 | otherwise = 3 * n + 1
00:12:14 <lambdabot>  Defined.
00:12:21 <iqubic> ski: My thing?
00:12:23 <iqubic> Why?
00:12:30 <jle`> it won't terminate heh, it was a bad joke about trying to cheat computability with your clever conting
00:12:31 <ski> infinite list
00:12:59 <iqubic> Hailstone is like the Collatz Cojecture.
00:13:29 <jle`> the evalCont thing i did was the collatz conjector
00:13:33 <ski> `unfoldr' ?
00:13:34 <jle`> jecture
00:13:50 <ski> (doesn't really matter here, though)
00:14:08 * ski . o O ( "njecture" )
00:14:11 <jle`> > evalCont $ do m <- L.forAll [1..100]; n <- L.forSome (iterate hailstone m); return (n == 1)
00:14:13 <lambdabot>  True
00:14:20 <jle`> welp that settles that
00:14:49 * ski is reminded of a book called "A = B"
00:14:49 <jle`> > evalCont $ do m <- L.forAll [1..1000000]; n <- L.forSome (iterate hailstone m); return (n == 1)
00:14:51 <iqubic> What is?
00:14:55 <lambdabot>  mueval-core: Time limit exceeded
00:14:56 <iqubic> What is L?
00:15:05 <jle`> lambdabot's @let context
00:15:13 <jle`>  ski defined it earlier
00:15:25 <jle`> > evalCont $ do m <- L.forAll [1..1000]; n <- L.forSome (iterate hailstone m); return (n == 1)
00:15:25 <ski> @where L.hs
00:15:25 <lambdabot> what lambdabot has in scope is at http://silicon.int-e.eu/lambdabot/State/Pristine.hs
00:15:27 <lambdabot>  True
00:15:36 <ski> (not including local `let's in lambdabot)
00:15:51 <ski> @type forAll
00:15:52 <lambdabot> error:
00:15:52 <lambdabot>     Ambiguous occurrence ‘forAll’
00:15:52 <lambdabot>     It could refer to either ‘Lambdabot.Plugin.Haskell.Eval.Trusted.forAll’,
00:15:58 <jle`> @let exists = L.forSome
00:15:58 <ski> (that's why i said `L.')
00:16:00 <lambdabot>  Defined.
00:16:18 <jle`> @let suchThat = return
00:16:19 <lambdabot>  Defined.
00:16:23 <ski> @type forSome  -- is ok, though
00:16:24 <lambdabot> Foldable t => t a -> Cont Bool a
00:16:36 <iqubic> I see.
00:16:53 <ski> @type Lambdabot.Plugin.Haskell.Eval.Trusted.forAll
00:16:54 <jle`> > evalCont $ do m <- L.forAll [1..1000]; n <- exists (iterate hailstone m); suchThat (n == 1)
00:16:55 <lambdabot> (Show a, STestable prop) => Gen a -> (a -> prop) -> Test.QuickCheck.Safe.SProperty
00:16:56 <lambdabot>  error:
00:16:56 <lambdabot>      Ambiguous occurrence ‘suchThat’
00:16:56 <lambdabot>      It could refer to either ‘Lambdabot.Plugin.Haskell.Eval.Trusted.suchThat’,
00:16:57 * ski slaps QC
00:17:02 <ski> @type Lambdabot.Plugin.Haskell.Eval.Trusted.suchThat
00:17:03 <jle`> > evalCont $ do m <- L.forAll [1..1000]; n <- exists (iterate hailstone m); L.suchThat (n == 1)
00:17:04 <lambdabot> Gen a -> (a -> Bool) -> Gen a
00:17:05 <lambdabot>  True
00:17:13 <ski> (QC strikes again !)
00:17:32 <jle`> for all m in [1..1000], there exists n in the hailstone sequence from m such that n == 1
00:17:55 <iqubic> Is that just going to keep generating
00:18:00 <jle`> nah
00:18:00 <iqubic> Gen a -> (a -> Bool) -> Gen a
00:18:04 <jle`> > evalCont $ do m <- L.forAll [1..1000]; n <- exists (iterate hailstone m); L.suchThat (n == 1)
00:18:06 <jle`> see, it stops
00:18:06 <lambdabot>  True
00:18:11 <jle`> we proved collatz
00:18:19 <jle`> time to pack it up and go home
00:18:20 <ski> we didn't disprove it
00:18:35 <iqubic> Is that going to keep generating random 'a's until you get one that meets a certain property?
00:18:49 <iqubic> Gen a -> (a -> Bool) -> Gen a
00:18:51 <ski> iqubic : the QC one, or ?
00:19:04 <iqubic> The suchThat with the Gen a -> ...
00:19:05 <ski> (hm, or that may be SmallCheck, actually ..)
00:19:05 <jle`> maybe but we aren't using that one, we're using the unrelated ones that we just defined right now
00:19:19 <iqubic> I know. I noticed.
00:19:40 <iqubic> Where do those forAll and suchThat come from?
00:19:55 <ski> i and jle` defined them, just above
00:20:31 <iqubic> Where does  ‘Lambdabot.Plugin.Haskell.Eval.Trusted.forAll’ come from?
00:26:12 <ski> <https://github.com/lambdabot/lambdabot/blob/master/lambdabot-trusted/src/Lambdabot/Plugin/Haskell/Eval/Trusted.hs>,<https://hackage.haskell.org/package/QuickCheck-2.13.2/docs/src/Test.QuickCheck.html>,<https://hackage.haskell.org/package/QuickCheck-2.13.2/docs/src/Test.QuickCheck.Property.html#forAll>,<https://hackage.haskell.org/package/QuickCheck-2.13.2/docs/src/Test.QuickCheck.Gen.html#suchThat>
00:51:00 <dminuoso> Mmm, Im starting to dislike the style of using typeclasses like FromField and FromRow for parsers.
00:51:23 <dminuoso> It appears like you have to use a newtype for every custom field...
00:52:37 <Axman6> look at the approach taken by the sv and waargonaut packages
00:52:57 <Axman6> they don't use type classes
00:54:00 <jle`> i'm not a huge fan either, but i can see why people might have thought it was a good idea initially
00:54:49 <Axman6> it's not a bad idea when there is onlt ever going to be a single canonical format for a thing
00:55:02 <Axman6> but things become difficult when you no longer have that
00:56:45 <sayola> is there some lightweight haskell-like lang and interpreter as lib? something like lua, but sane. 
00:57:01 <dminuoso> Axman6: cassava not even appears to give you access to handcraft a parser.
00:57:17 <dminuoso> Axman6: So I can't just write `x <- myDateParser =<< rec .! 5`
01:00:30 * hackage network-messagepack-rpc 0.1.1.2 - MessagePack RPC  https://hackage.haskell.org/package/network-messagepack-rpc-0.1.1.2 (igrep)
01:03:00 * hackage alg 0.2.11.0 - Algebraic structures  https://hackage.haskell.org/package/alg-0.2.11.0 (MatthewFarkasDyck)
01:07:00 * hackage network-messagepack-rpc 0.1.1.4 - MessagePack RPC  https://hackage.haskell.org/package/network-messagepack-rpc-0.1.1.4 (igrep)
01:10:28 <jusss> is there some webframes are easier to use for newbies?
01:10:54 <jusss> I look at the yesod docs, it's a little complete to me...
01:11:06 <jusss> complex
01:15:15 <dminuoso> jusss: Do you wan to serve html webpages?
01:15:43 <jusss> dminuoso: yes, also javascript
01:16:00 * hackage math-functions 0.3.3.0 - Collection of tools for numeric computations  https://hackage.haskell.org/package/math-functions-0.3.3.0 (AlexeyKhudyakov)
01:16:17 <jusss> dminuoso: that's what a webframe do, right?
01:21:08 <MarcelineVQ> Spock or scotty are fairly simple things to learn from
03:07:59 <delYsid`>  delYsid
04:26:30 * hackage ftp-client 0.5.1.2 - Transfer files with FTP and FTPS  https://hackage.haskell.org/package/ftp-client-0.5.1.2 (miscyb)
04:27:30 * hackage ftp-client-conduit 0.5.0.5 - Transfer file with FTP and FTPS with Conduit  https://hackage.haskell.org/package/ftp-client-conduit-0.5.0.5 (miscyb)
04:52:30 * hackage reactive-banana-gi-gtk 0.4.0.2 - Simple reactive programming with GTK GObject Introspection  https://hackage.haskell.org/package/reactive-banana-gi-gtk-0.4.0.2 (miscyb)
05:08:30 * hackage distribution-nixpkgs 1.3.1 - Types and functions to manipulate the Nixpkgs distribution  https://hackage.haskell.org/package/distribution-nixpkgs-1.3.1 (PeterSimons)
05:16:35 <phil81> hey guys! why does `Num` *not* have a instance of `Fractional` ? 
05:17:19 <phadej> that question doesn't make sense. `Num` is a type-class, it cannot be an instance of `Fractional`
05:17:55 <phil81> phadej ```
05:17:58 <phil81> λ> :info Numclass Num a where  (+) :: a -> a -> a  (-) :: a -> a -> a  (*) :: a -> a -> a  negate :: a -> a  abs :: a -> a  signum :: a -> a  fromInteger :: Integer -> a  {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}  	-- Defined in ‘GHC.Num’instance Num Word -- Defined in ‘GHC.Num’instance Num Integer -- Defined in
05:17:59 <phadej> in fact, Num is a super-class of Fractional: https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Fractional
05:17:59 <phil81> ‘GHC.Num’instance Num Int -- Defined in ‘GHC.Num’instance Num Float -- Defined in ‘GHC.Float’instance Num Double -- Defined in ‘GHC.Float’
05:18:30 <phil81> phadej it has Num Double and Num Float
05:18:43 <merijn> phil81: What is the "it" in that sentence?
05:19:09 <phil81> merijn thats just `:info Num`
05:19:26 <merijn> phil81: I'm not sure how that relates to Fractional?
05:19:52 <merijn> ":info Num" lists types that are instances of Num, Double and Float have Num instances
05:20:09 <merijn> Therefore, they are listed
05:23:23 <phil81> to put in in other words: why is this possible `f :: Float`;  with implementation of `f = 1.0` but not with `f :: Num a => a` ? 
05:24:20 <merijn> phil81: "f :: Num a => a" says "f can be *any* Num type"
05:24:46 <merijn> phil81: "1.0 :: Fractional a => a" so "1.0 can be *any* Fractional type"
05:25:10 <merijn> phil81: Not all Num types are *also* Fractional, so "f = 1.0" can't have "f :: Num a => a"
05:25:31 <merijn> phil81: If it did, then I could use 'f' as if it was "Int", which doesn't make sense if 'f' is 1.0
05:25:56 <phil81> merijn, thanks a lot
05:26:38 <merijn> phil81: The fact that Double/Float are instances of Num means that we can do for example:
05:26:41 <merijn> :t 1
05:26:42 <lambdabot> Num p => p
05:26:44 <merijn> > 1 :: Double
05:26:45 <lambdabot>  1.0
05:27:06 <merijn> (i.e. 1 can be any Num type, therefore 1 can be Double)
05:27:18 <phil81> as well as Float
05:27:20 <ski> > pi - 3
05:27:21 <lambdabot>  0.14159265358979312
05:27:26 <merijn> phil81: Right
05:27:56 <ski> > 1/3 :: Rational
05:27:56 <phil81> merijn, ok, thanks (y) 
05:27:57 <lambdabot>  1 % 3
05:28:09 <ski> > 21/15 :: Rational
05:28:11 <lambdabot>  7 % 5
05:28:23 <ski> > 1/2 + 1/3 :: Rational
05:28:25 <lambdabot>  5 % 6
05:28:44 <Ariakenom> Rational is nice
05:28:59 <sshine> Scientific is also nice.
05:29:59 <merijn> phil81: Essentially in most inheritance based languages you get used to thinking of "is a Foo" to mean "is *some* (unknown) Foo", whereas with typeclasses it generally means "is *any* Foo" (i.e. "you can pick anything as long as it's a Foo")
05:31:26 <Ariakenom> sshine: can you have 1/3 with Scientific?
05:32:18 <phil81> merijn, i think this is the exact reason for messing up - coming from inheritance based languages (OOP) =L 
05:33:22 <sshine> Ariakenom, no :)
05:33:27 <sshine> > 1/3 :: Scientific
05:33:28 <sshine> *** Exception: fromRational has been applied to a repeating decimal which can't be represented as a Scientific! It's better to avoid performing fractional operations on Scientifics and convert them to other fractional types like Double as early as possible.
05:33:29 <lambdabot>  error:
05:33:29 <lambdabot>      Not in scope: type constructor or class ‘Scientific’
05:34:42 <Ariakenom> sshine: ok I read the docs but wasnt entirely sure. im thinking it can represent decimal rational numbers that dont have too many digits?
05:34:55 <sshine> I wonder if it'd make sense to have a type that can hold both kinds and just switches between the optimal representation. I guess it comes at the cost of being able to UNPACK.
05:35:50 <merijn> I think I'd prefer Fixed and Rational over Scientific
05:35:54 <sshine> Ariakenom, as long as the decimals don't repeat, it can represent them, so in a sense it's orthogonal to Rational. I suppose it depends on the number which representation is most efficient.
05:36:55 <Ariakenom> sshine: but it uses an Int for the coefficient so the digits should be limited?
05:37:42 <sshine> Ariakenom, yes, and the author says he should be doing something about that.
05:38:40 <Ariakenom> merijn: Fixed is fairly ergonomic in haskell afaict. is it nice in any other language?
05:38:56 <merijn> Ariakenom: Who cares about other terrible languages? ;)
05:39:53 <sshine> I thought Scientific was a good candidate for representing arbitrary JSON numbers, but the coefficient being Int is bad here. since JSON numbers are always represented in decimal (with optional scientific notation), I thought that'd be ideal. but if one should want to e.g. calculate division on them, I realize that's kind of bad.
05:41:53 <Ariakenom> (the issue in many languages is that 0.1 is a double, so can't write accurate literals)
05:42:53 <dminuoso> sshine: The best part is that JSON numbers use "decimal notation", despite JavaScript numbers being IEEE 754 numbers..
05:43:16 <dminuoso> sshine: So roundtripping `fromJSON . toJSON` has the chance of giving you something else back.
05:43:36 <Ariakenom> haskell's annoying number definitions are still so much better than the rest
05:44:16 <dminuoso> % :t fromIntegral
05:44:16 <yahb> dminuoso: (Integral a, Num b) => a -> b
05:44:35 <dminuoso> Ariakenom: Honestly in Haskells numeric system I just randomly apply things like fromIntegral until GHC stops complaining.
05:44:59 <merijn> dminuoso: pffft
05:45:05 <merijn> that's only half of it
05:45:13 <merijn> The other half is realToFrac
05:46:03 <merijn> Ariakenom: You can, you just have to use HexFloat notation :p
05:46:12 <sshine> Ariakenom, I agree.
05:46:23 <dminuoso> Perhaps the problem domain is just so messy because programmers seem to think that "Number things" is a pretty precise and unambiguous thing.
05:46:37 <dminuoso> And the reality is just so much different, especially when it has to run on hardware *and* usually fast.
05:46:51 <dminuoso> Not unlike "strings"
05:47:05 <sshine> I heard the universe is made of strings.
05:47:16 <Ariakenom> merijn: that doesnt help. the issue is that you can only express valid doubles. which 0.1 isn't
05:47:26 <dminuoso> Ariakenom: Why is 0.1 not a valid double?
05:47:33 <dminuoso> Ariakenom: You can represent 0.1 perfectly using IEEE 754.
05:47:43 <dminuoso> (Depending on your implementation...)
05:48:10 <dminuoso> ((And in all fairness, I have never ever seen a base 10 implementation of IEEE754, but hey - specs are specs))
05:48:14 <fweht> https://twitter.com/typeswitch/status/1176269193177718785 this sounds interesting, can anyone point me to some reference discussing those gradients?
05:49:02 <dminuoso> fweht: Why not simply... ask on twitter? :p
05:49:20 <Ariakenom> dminuoso: doubles are binary per the spec afaik. there are decimal parts of the spec to but those are different no?
05:49:29 <fweht> true...  i thought here id get a response quicker
05:50:17 <dminuoso> Ariakenom: A IEEE754 number is basically a radix, precision and exponent. The radix can be either 2 or 10.
05:50:47 <dminuoso> (and the exponent range can vary too)
05:51:35 <dminuoso> Ariakenom: So usually people talk about binary32 and binary64 when they talk about single/double precision, but other encodings like decimal32 are valid too.. :)
05:52:03 <dminuoso> (Its possibly very hard to implement efficiently in hardware when you use base10)
05:53:06 <Ariakenom> dminuoso: id say float double is the same as binary 32|64. nobody but evil (C spec writers) ppl would mean anything else
05:54:06 <sshine> dminuoso, maybe until they invent the 5-state transistor.
05:56:14 <Ariakenom> bounded decimal floating point seems poinless to me. is there any use case?
05:59:30 * hackage vector-th-unbox 0.2.1.7 - Deriver for Data.Vector.Unboxed using Template Haskell  https://hackage.haskell.org/package/vector-th-unbox-0.2.1.7 (phadej)
06:09:33 <dminuoso> Ariakenom: Why pointless?
06:10:00 <dminuoso> Ariakenom: Its not really different from base 2 IEEE 754, semantically.
06:10:00 * hackage vformat 0.9.0.0 - A Python str.format() like formatter  https://hackage.haskell.org/package/vformat-0.9.0.0 (gqk007)
06:10:24 <dminuoso> So its as useful as base 2 representations, albeit not as fast.
06:26:33 <Ariakenom> dminuoso: bianry but slower sounds pointless to me. speed is a critical feature too. I'd guess they also have worse precision.
06:31:00 * hackage net-spider-rpl 0.2.3.0 - NetSpider data model and utility for RPL networks  https://hackage.haskell.org/package/net-spider-rpl-0.2.3.0 (debugito)
06:42:30 * hackage bytesmith 0.2.0.0 - Nonresumable byte parser  https://hackage.haskell.org/package/bytesmith-0.2.0.0 (andrewthad)
06:50:13 <nickfurry> guys, how do you implement the cons operator?
06:50:33 <nickfurry> sorry if it sounds stupid ._.
06:50:45 <dminuoso> nickfurry: So create a data type, and do the natural thing.
06:51:00 <dminuoso> nickfurry: Create some `data List a = ...` and imagine how to make a list by hand.
06:52:01 <syd> you mean `cons :: a -> List a -> List a`, right? Not `const :: a -> b -> a`?
06:52:19 <nickfurry> yeah the former one
06:52:34 <dminuoso> nickfurry: Or maybe my instruction is not helpful.
06:52:52 <dminuoso> nickfurry: Haskells list is, basically, `data List a = Cons a (List a) | Nil`
06:53:16 <dminuoso> nickfurry: You could think of it as: `data [] a = a : [a] | []`
06:53:25 <dminuoso> nickfurry: So : is actually a data constructor implementing the cons behavior.
06:53:35 <syd> that's rigth
06:53:39 <dminuoso> And [] is a data constructor representing the empty list.
06:53:39 <syd> `cons = (:)`
06:54:24 <dminuoso> nickfurry: So the notion of "cons" is how we construct a list to begin with. "A list is either an element prepended to a list, or an empty list"
06:54:25 <nickfurry> thanks for helping dminuoso, I'll ask again later
06:55:26 <dminuoso> nickfurry: In fact, pattern matching always works on data constructors. So if you pattern match on `(x:xs)`, you actually match that the list was constructed with (:), while binding the "element" and "the tail" to x and xs respectively. So if we did
06:55:33 <dminuoso> % data List a = Cons a (List a) | Nil
06:55:33 <yahb> dminuoso: 
06:55:39 <dminuoso> We could pattern match as follows:
06:56:01 <dminuoso> % safeHead :: List a -> Maybe a; safeHead (Cons x _xs) = Just x; safeHead Nil = Nothing
06:56:01 <yahb> dminuoso: 
06:56:34 <dminuoso> Which is exactly the same as `safeHead (x:_xs) = Just x; safeHead [] = Nothing`, except that Cons is in prefix position, and (:) is in infix position.
06:58:00 * hackage hinterface 0.11.0 - Haskell / Erlang interoperability library  https://hackage.haskell.org/package/hinterface-0.11.0 (SvenHeyll)
07:08:27 <boxscape> % (\(~Nothing) -> 4) (Just 5)
07:08:28 <yahb> boxscape: 4
07:08:40 <boxscape> is there any way to have a right hand side that makes this crash?
07:09:09 <Taneb> boxscape: do you mean, replacing the "4", or replacing the "Just 5"?
07:09:18 <boxscape> replacing the 4
07:09:44 <Taneb> If you replace it with "undefined", say, or «error "foo"»
07:10:01 <boxscape> okay, I should have been more specific
07:10:10 <Taneb> But nothing sensible
07:10:47 <Taneb> Only things which themselves through errors in isolation
07:10:49 <sshine> boxscape, https://wiki.haskell.org/Avoiding_partial_functions
07:11:00 <boxscape> to be more specific and more general at the same time: Can an lazy pattern of a constructor without a field ever fail to match? (But from whay you're saying it sounds like the answer is no)
07:11:23 <ski> % (\(~x@Nothing) -> 4) (Just 5)
07:11:23 <yahb> ski: 4
07:11:24 <ski> % (\(~x@Nothing) -> x) (Just 5)
07:11:25 <yahb> ski: *** Exception: <interactive>:345:2-19: Non-exhaustive patterns in x@Nothing
07:11:50 <boxscape> hm okay that works I suppose
07:12:16 <ski> it it doesn't contain any variable, then it can't fail
07:12:21 <boxscape> okay
07:14:09 <ski> % (\ ~(!Nothing) -> 4) (Just 5)
07:14:09 <yahb> ski: 4
07:14:14 <ski> % (\ !(~Nothing) -> 4) (Just 5)
07:14:14 <yahb> ski: 4
07:14:28 <boxscape> relatedly, is !(~(pattern)) the same as ~(!(pattern))? Seems like they both are the same as ~(pattern)
07:14:45 <ski> yes
07:14:49 <boxscape> (heh, I acutally started typing that before your examples)
07:14:50 <boxscape> okay
07:17:58 <dminuoso> boxscape: the idea is as follows. A pattern can either be refutable or irrefutable. irrefutable patterns always match, irrespective of whether the value matched against is 
07:18:00 <dminuoso> _|_
07:18:20 <dminuoso> At the same time matching a refutable pattern is strict in the value
07:19:02 <dminuoso> boxscape: ~ lets you turn any pattern into an irrefutable pattern
07:19:29 <boxscape> okay
07:20:31 * hackage safecopy 0.10.1 - Binary serialization with version control.  https://hackage.haskell.org/package/safecopy-0.10.1 (JeremyShaw)
07:20:43 <dminuoso>   The irrefutable patterns are as follows: a variable, a wildcard, N apat where N is a constructor defined by newtype and apat is irrefutable,var@apat where apatis irrefutable, or of the form  ̃apat (whether or not apat is irrefutable). All other patterns are refutable.
07:20:53 <dminuoso> This is the way the Haskell report phrases it.
07:21:30 * hackage acid-state 0.15.2 - Add ACID guarantees to any serializable Haskell data structure.  https://hackage.haskell.org/package/acid-state-0.15.2 (JeremyShaw)
07:21:48 <boxscape> does ! make patterns refutable or only strict?
07:24:02 <ski> > case undefined of !_ -> ()
07:24:04 <lambdabot>  *Exception: Prelude.undefined
07:24:11 <ski> "All other patterns are refutable."
07:24:40 <dminuoso> ski: For what its worth, BangPatterns is a language extension.
07:24:41 <boxscape> > case undefined of ~_ -> ()
07:24:43 <lambdabot>  ()
07:24:52 <dminuoso> So citing the haskell report does no good here.
07:25:04 <ski> yes, but in this case no amendment to that is needed
07:25:07 <dminuoso> Right. :)
07:25:24 <dminuoso> boxscape: To say that "a pattern is strict" means "the pattern is refutable
07:25:28 <boxscape> okay
07:25:46 <ski> (then one can talk about patterns, whose matching can't possibly fail (as opposed to can't diverge). e.g. matching on tuples)
07:26:42 <dminuoso> boxscape: So essentially something like `f !() = ...` is a redundant !, because () is already a refutable pattern.
07:26:50 <ski> (e.g. in `<pat> <- <expr>' in a `do', if `<pat>' is a "failable" pattern, then we need a `MonadFail' constraint, but if it isn't, then such wouldn't be needed)
07:27:27 <ski> @type \x -> do () <- x; return ()
07:27:28 <lambdabot> Monad m => m () -> m ()
07:27:30 <dminuoso> boxscape: So ~ in effect turns an arbitrary pattern into an irrefutable pattern, and ! turns an arbitrary pattern into a refutable pattern.
07:27:32 <ski> @type \x -> do False <- x; return ()
07:27:33 <lambdabot> Control.Monad.Fail.MonadFail m => m Bool -> m ()
07:27:51 <ski> @let data Unit = U
07:27:52 <lambdabot>  Defined.
07:27:52 <boxscape> I can see why a refutable pattern has to be strict, but the vice versa isn't obvious. Could they have designed it such that strict irrefutable patterns could have existed?
07:27:56 <ski> @type \x -> do U <- x; return ()
07:27:57 <lambdabot> Monad m => m Unit -> m ()
07:28:02 <dminuoso> boxscape: Note the weight of "arbitrary" here. It means you can add ~ to an already refutable pattern, or ! to an already irrefutable pattern.
07:28:14 <dminuoso> boxscape: Lose the word "strict" there. ;)
07:28:22 <boxscape> > let !!!!!5 = 5 in 4
07:28:23 <lambdabot>  <hint>:1:5: error: parse error on input ‘!!!!!’
07:28:24 <dminuoso> boxscape: The strictness is implied by the fact that its refutable.
07:28:26 <boxscape> :(
07:28:37 <boxscape> yeaj
07:28:41 <dminuoso> boxscape: The only way to refute a pattern, is by carrying out the pattern match. In order to do that, you have to bring the value into WHNF first.
07:28:41 <boxscape> s/j/h
07:28:52 <ski> > let !(!(!(!(!5)))) = 5 in 4
07:28:54 <lambdabot>  4
07:29:12 <hyperisco> A fair dice roll
07:29:13 <boxscape> I realize that, but the opposite directions is the part that isn't obviously necessary to me, dminuoso
07:29:19 <boxscape> s/directions/direction
07:29:25 <dminuoso> boxscape: You mean ~ ?
07:29:29 <boxscape> no,
07:29:39 <ski> > let False = True in ()
07:29:39 <boxscape> I mean, why does a strict pattern have to be refutable
07:29:41 <lambdabot>  ()
07:29:43 <ski> > let !False = True in ()
07:29:45 <lambdabot>  *Exception: <interactive>:3:5-17: Non-exhaustive patterns in False
07:29:49 <dminuoso> boxscape: There is no such thing as a "strict pattern"
07:30:05 <dminuoso> Or.. I should check the Haskell report first I guess.
07:30:31 <dminuoso> But Im fairly confident that "strict" is not an adjective that the Haskell report attributes to patterns.
07:30:33 <nshepperd2> ! is for strictness, yes
07:31:59 <nshepperd2> As ski just demonstrated, it does make a difference to have !, even if the pattern is just a constructor
07:32:08 <dminuoso> I suppose the strictness is rather an attribute of the function or the pattern matching itself.
07:32:32 <dminuoso> Ah mmm
07:33:07 <dminuoso> 16:29:17         ski | > let False = True in ()
07:33:10 <dminuoso> This is surprising.
07:33:38 <geekosaur> laziness
07:33:47 <boxscape> I suppose what I'm thinking is you could have a pattern in `f Nothing = 4, f (Just _) = 6`, where Nothing is irrefutable (so the second equation will never be chosen), but still fails if matched with undefined
07:33:48 <geekosaur> nothing uses the result, it's never evaluated to be found false
07:34:02 <dminuoso> nshepperd2: actually, the trick comes from the Haskell report.
07:34:09 <ski> pattern-bindings in `let' and `where' act as if they're wrapped in a `~' -- without a variable to force, nothing happens
07:34:37 <nshepperd2> ! is from BangPatterns, so is it even in the report?
07:34:41 <dminuoso> nshepperd2: It turns out that `let False = True in ()` is translated into `case True of ~False -> ()`
07:34:47 <dminuoso> nshepperd2: So everything fits stlil.
07:35:10 <nshepperd2> Indeed, let is not case
07:35:14 <boxscape> (I suppose something like `f ~(a@Nothing) = a `seq` 5` might do that)
07:35:56 <ski> otoh, in `case' (and parameter matching in function-bindings), it does not act as if wrapped in a `!'. if you match on an irrefutable pattern (`_' or variable or "as"-pattern, or lazy pattern), nothing gets forced
07:36:15 <ski> > case undefined of _ -> ()
07:36:17 <lambdabot>  ()
07:36:44 <boxscape> (and in fact what I just wrote also fails if f is called with a Just)
07:36:53 <ski> boxscape : `Nothing' is not irrefutable
07:37:07 <boxscape> but I put a ~ in front of it?
07:37:28 <dminuoso> nshepperd2: `let False = True ()` is syntax sugar for an irrefutable pattern. ;)
07:37:41 <ski> then it automatically becomes irrefutable, yes
07:38:10 <ski> "The irrefutable patterns are as follows: .., or of the form  ̃apat (whether or not apat is irrefutable)."
07:38:32 <boxscape> is there a difference between ~(a@Nothing) and ~(a@~Nothing)?
07:38:57 <ski> > case Just () of ~(a@Nothing) -> [a]
07:38:58 <lambdabot>  [*Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in a@Nothing
07:39:01 <ski> > case Just () of ~(a@ ~Nothing) -> [a]
07:39:03 <lambdabot>  [Just ()]
07:39:08 <boxscape> ah, thanks
07:39:55 <ski> forcing `a' won't force the match on `Nothing', if it's wrapped in another `~'
07:40:13 <ski> forcing `a' will force the match on `a@...'
07:40:37 <geekosaur> fwiw it looks like your client composed dead-tilde with the "a" of "apat", ski
07:40:58 <dminuoso> boxscape: "var@apat where apat is irrefutable"
07:41:31 <boxscape> dminuoso I'm not sure what to make of that, the whole pattern is already irrefutable thanks to the outer ~
07:41:38 <ski> geekosaur : hm, you mean "of the form  ̃apat" ? -- i copied that from dminuoso's quote, twenty minutes ago
07:41:53 <geekosaur> oh
07:42:02 <geekosaur> so previously incorrect :)
07:42:05 <dminuoso> boxscape: So if apat is irrefutable, then var@apat is irrefutable too.
07:42:06 <dminuoso> boxscape: Nothing is not a refutable pattern
07:42:06 <dminuoso> *Nothing is a refutable pattern.
07:42:07 <dminuoso> Double negation error.
07:42:13 * geekosaur wasn't around 20 minutes ago
07:42:27 <ski> (to me, it looks like a variant of the usual tilde (not composed with the "a"). i didn't notice the difference before you said it, though)
07:42:48 <geekosaur> I see a ã with the tilde slightly offset
07:43:18 <ski> ah, i see, it's "U+0303 COMBINING TILDE", rather than "U+007E TILDE"
07:43:23 <geekosaur> yep
07:43:35 <ski> (but it didn't combine, here)
07:43:40 <dminuoso> 16:41:42         ski | forcing `a' won't force the match on `Nothing', if it's wrapped in another `~'
07:43:48 <geekosaur> I think it wants to combine with the preceding space
07:43:54 <boxscape> well, in any case, I think what I meant when I said "strict but irrefutable" is in fact ~(a@pat) followed by `seq a`, but I'm guessing it wouldn't be terribly useful to have a pattern variant specifically for that
07:44:00 <geekosaur> which makes it weird
07:44:21 <ski> dminuoso, yes ?
07:44:26 <geekosaur> it was offset partially over the "a" because I use a proportional font so the space is fairly narrow
07:44:30 <ski> geekosaur, could be
07:44:34 <dminuoso> ski: Thanks, I didn't think about this subtle edge case.
07:45:28 <ski> dminuoso, shows that it could occasionally be handy to nest `~'s
07:45:44 <nshepperd2> > let !_ = undefined in ()
07:45:47 <lambdabot>  *Exception: Prelude.undefined
07:45:51 <geekosaur> well, I should say the web client uses a proportional font, I don't get any choice in it because I can't run a proper client on this network (IRC and most other non-web ports blocked, sigh)
07:46:03 <dminuoso> ski: Though arguably `~(a@~Nothing)` is just `a`
07:46:45 <ski> (and one could just as well use `~(a,~Nothing)', rather than `~(a@ ~Nothing)'. the important part was that we had variable sandwiched inbetween)
07:46:55 <ski> yes, of course, dminuoso :)
07:48:32 <dminuoso> With the chance of generating worse code if GHC doesn't see this.
07:48:40 <dminuoso> % case Just () of ~(a, ~Nothing) -> [a]
07:48:40 <yahb> dminuoso: ; <interactive>:377:18: error:; * Couldn't match expected type `Maybe ()' with actual type `(a, Maybe a0)'; * In the pattern: (a, ~Nothing); In the pattern: ~(a, ~Nothing); In a case alternative: ~(a, ~Nothing) -> [a]; * Relevant bindings include it :: [a] (bound at <interactive>:377:1)
07:48:46 <boxscape> tbh this whole irrefutable vs refutable naming scheme is a bit confusing - when I initially heard about it I would have expected that all the patterns in a lambda parameter are irrefutable because there can't be any alternative patterns
07:49:28 <boxscape> (as opposed to having multiple equations in a top-level definition)
07:49:37 <dminuoso> boxscape: pattern matching can diverge!
07:49:48 <boxscape> elaborate?
07:50:05 <dminuoso> > case Just 1 of Nothing -> ()
07:50:07 <lambdabot>  *Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
07:50:20 <ski> > (\Nothing -> ()) (Just ())
07:50:21 <dminuoso> > (\(Just x) -> x) Nothing
07:50:22 <lambdabot>  *Exception: <interactive>:3:2-15: Non-exhaustive patterns in lambda
07:50:23 <lambdabot>  *Exception: <interactive>:3:2-15: Non-exhaustive patterns in lambda
07:50:59 <ski> matching an irrefutable pattern can never diverge
07:51:00 <boxscape> I'm not quite sure what point you're making here exactly
07:51:09 <boxscape> oh
07:51:16 <boxscape> i misinterpreted diverge I think
07:51:18 <nshepperd> here's an exciting trick:
07:51:22 <nshepperd> :t do { Just x <- return (Just 4); return x }
07:51:23 <lambdabot> (Num b, Control.Monad.Fail.MonadFail m) => m b
07:51:29 <nshepperd> <> :t do { ~(Just x) <- return (Just 4); return x }
07:51:30 <hyperisco> The reinterpret cast of pattern matching…
07:51:31 <nshepperd> :t do { ~(Just x) <- return (Just 4); return x }
07:51:32 <lambdabot> (Monad m, Num b) => m b
07:51:39 <nshepperd> :t do { !(~(Just x)) <- return (Just 4); return x }
07:51:41 <lambdabot> (Monad m, Num b) => m b
07:51:46 <ski> matching on `_', or `x', or `x@<irrpat>' or `~<pat>' (where `<irrpat>' is irrefutable) will never diverge
07:51:47 <boxscape> but yeah that makes sense I suppose
07:51:54 <dminuoso> nshepperd: That looks almost like an oversight.
07:52:18 <nshepperd> it looks entirely expected to me
07:52:24 <hyperisco> Here you can play with my toy
07:52:30 <dminuoso> boxscape: Essentially every time you apply a function, pattern matching occurs. However, in the usual case of `f x = ...` the pattern "x" is irrefutable, so it will always match. :)
07:52:38 <hyperisco> @define inf ~(x:xs) = x : inf xs
07:52:40 <lambdabot>  Defined.
07:52:44 <dminuoso> nshepperd: Can you elaborate?
07:53:03 <dminuoso> nshepperd: It should generate a MonadFail constrait because its most definitely a refutable pattern. No?
07:53:08 <ski> ("diverge" here means "go into infinite loop" or "trigger partiality in the matched value". as opposed to "fail" which just means that the pattern doesn't match, and the next (if any) is tried)
07:53:10 <nshepperd> When I use !, I mean 'please make this strict'
07:53:15 <hyperisco> > (length . take 100 . inf) undefined
07:53:16 <lambdabot>  100
07:53:22 <nshepperd> not 'please apply some monad-specific semantics to failure'
07:53:25 <boxscape> (whoops I got disconnected)
07:53:34 <hyperisco> It is how you tell the compiler a list is actually infinite ;)
07:53:39 <ski> nshepperd : nice :)
07:53:54 <dminuoso> nshepperd: But then why should ~ not do the same thing?
07:54:06 <dminuoso> nshepperd: I mean if ! doesn't add a MonadFail constraint, then ~ shouldnt strip it.
07:54:31 <Cale> ~ makes the pattern not failable though
07:54:41 <ski> > (length . take 100 . inf) []
07:54:43 <lambdabot>  100
07:54:51 <nshepperd> there's no way for a ~ pattern to *use* a MonadFail constraint
07:55:03 <nshepperd> it would be a pointless constraint
07:55:23 <Cale> Yeah, the idea is that MonadFail should only get involved when it's possible for the pattern match to fail
07:55:30 <hyperisco> You can make functions less strict this way, which is what I used it for
07:55:41 <ski> failable implies refutable
07:55:57 <ski> tuple patterns are not failable, but are still refutable
07:56:53 <Cale> If you're only matching against constructors of types that only have a single constructor, or variables, or patterns made irrefutable by ~ then there can be no failure, so the generated code should just use lambda and not case.
07:57:19 <dmwit> :t do { (a,b) <- return ('a','b'); return a }
07:57:21 <lambdabot> Monad m => m Char
07:57:40 <ski> @undo do (x,y) <- foo; bar x y
07:57:40 <lambdabot> foo >>= \ (x, y) -> bar x y
07:57:41 <ski> @undo do Node x y <- foo; bar x y
07:57:41 <lambdabot> foo >>= \ a -> case a of { Node x y -> bar x y; _ -> fail ""}
07:58:03 <ski> @undo do ~(Node x y) <- foo; bar x y
07:58:03 <lambdabot> foo >>= \ ~(Node x y) -> bar x y
07:58:05 <dminuoso> ski: depends on what you mean by failable. matching (a,b) against _|_ certainly does diverge..
07:58:05 <dminuoso> 16:52:59   nshepperd | not 'please apply some monad-specific semantics to failure'
07:58:05 <dminuoso> nshepperd: The monad-specific semantics to failure are introduced by pattern matching in do-notation, but by making it refutable.
07:58:08 <nshepperd> it would also be a bit ridiculous for do { !x <- return undefined; bar } to add a MonadFail constraint that catches the pure exception and turns it into Nothing
07:58:21 <nshepperd> or whatever mzero is for the monad
07:58:47 <dmwit> To be fair, the Report actually doesn't distinguish between refutable and irrefutable patterns.
07:58:55 <dmwit> You *always* get a function with two cases.
07:59:01 <ski> dminuoso : by "failable" i means that matching a value with the pattern can possibly fail (so that the next pattern, if any, is tried) (as i indicated above)
07:59:47 <Cale> Back in 1.4, the report *did* distinguish failable from irrefutable patterns, as I recall
07:59:52 <ski> nshepperd : hm, i wonder what `ApplicativeDo' does there
08:00:01 <dminuoso> ski: Ahh I see.
08:00:26 <Cale> That distinction got lost when MonadZero and MonadPlus got unified, and the translation of do-notation was changed to use fail instead of mzero
08:00:34 <ski> dminuoso : which is distinct from triggering some divergance in the value being matched
08:01:14 <dminuoso> ski: How is failable different from refutability then?
08:01:32 <ski> dminuoso : see the lines where i said "implies" ?
08:02:29 <dmwit> dminuoso: I guess refutability is what you had in your mind, for which bottom refutes most patterns.
08:02:50 <dmwit> (Other than _, variables, newtype constructors, and ~pats.)
08:02:58 <ski> dminuoso : tuple types, and `data' types with a single data constructor
08:03:09 <dminuoso> Ah...
08:03:33 <ski> it would be silly if `do (x,y) <- foo; bar x y' invoked a `MonadFail' constraint
08:03:48 <dminuoso> I see, so MonadFail is about failable patterns, rather than refutable patterns.
08:03:58 <dminuoso> Sorry, this took a while to understand.
08:04:15 <ski> one could perhaps argue that single-constructor `data' types shouldn't be treated differently from other `data' types. but they are
08:05:18 <ski> (one can conceptually distinguish between `data' types (e.g. using record syntax), which are never supposed to have any other number of ata constructors than one, from ones that just happens to currently have one, but which could in principle have some other number)
08:05:31 <ski> dminuoso : yes
08:05:42 <ski> (i perhaps should have stated that more directly)
08:08:28 <ski> (sometimes i wonder at how i've apparently managed to work out and absorb all these fine details ..)
08:09:22 <sshine> I guess if you have acid-state instances for your 'data' type and it got extended from one to two constructors, and 'data' types with one constructor were like 'newtype's, then the serialization would go from something that's unpacked to something that's packed. maybe I'm wrong about this, I don't really know how acid-state serializes.
08:10:32 <ski> well, even if "non-sibling" `data' constructors are non-failable, there's still a difference to `newtype' constructors
08:15:30 <tdammers> so I want to "fan out" a stream of events onto an arbitrary number of consumers using TBChans
08:15:53 <tdammers> basically, one chan for the consumer to write into, and then a number of duplicates for consumers to read from
08:16:07 <tdammers> with plain TChans, I can use dupTChan, but there is no dupTBChan
08:16:33 <tdammers> (and also no newBroadcastTBChan)
08:17:33 <sicklork1n> tdammers: Is TChan unbounded?
08:17:38 <tdammers> yes
08:17:43 <tdammers> that's why I don't want to use it
08:17:49 <sicklork1n> so make sure you have consumers
08:18:00 <tdammers> I have consumers
08:18:06 <tdammers> but I can't make sure they're faster than the producer
08:18:22 <sicklork1n> yes i have run into this many times.
08:19:09 <sicklork1n> tdammers: unagi-chan is nice iirc
08:19:16 <sicklork1n> https://hackage.haskell.org/package/unagi-chan
08:20:53 <tdammers> yeah, already found it
08:20:58 <tdammers> looks promising
08:21:17 <tdammers> "The library may be of limited usefulness outside of x86 architectures where the fetch-and-add instruction is not available." <- this makes me slightly uneasy though
08:22:58 <nshepperd> O_O
08:28:47 <sicklork1n> https://hackage.haskell.org/package/broadcast-chan
08:31:36 <nshepperd> ski: I think probably ApplicativeDo would translate that using Monad, since there's no way to write 'seq x bar' with Applicative
08:32:00 <nshepperd> 'seq <$> return undefined <*> bar' is possible, but not the same thing
08:32:57 <gwern> a haskell memory usage question: I was running some dynamic programming/memoization code on an AWS high-mem instance (~3.75tb RAM): https://pastebin.com/0vTN5A72 (latest version using Int128 https://pastebin.com/0vTN5A72 ) I noticed each haskell process seemed to get up to only ~700-800GB RAM use before OOMing, and I never wound up using the whole 3.75TB. uglymemo just goes through data.map,...
08:33:03 <gwern> ...and the data.map docs don't seem to discuss any resize strategies which might account for this. any ideas? it's hard for me to investigate because I can't afford to spend $26/hr to rent high-mem instances often and my workstation only has ~70GB to play with, which is too small to trigger premature OOMs
08:34:56 <sicklork1n> gwern: you're creating a map of thunks?
08:35:03 <ski> nshepperd : hm, i don't follow. what has `seq' got to do with it ?
08:35:15 <sicklork1n> gwern: are you using Data.Map.Strict?
08:35:17 <gwern> sicklork1n: yes, this is topdown memoization so it's a lazy map. uglymemo doesn't support strict maps anyway
08:35:36 <EvanR> gwern: have you tried ghc flags and runtime flags to increase the heap size limit
08:36:23 <sicklork1n> gwern: just the other day i found my issue w/GHC-Vaccum
08:36:26 <gwern> EvanR: no. let's see what the ghc manual says about this... I wouldn't expect some arbitrary limit on how much memory I can use but perhaps 700GB is too high for anyone to care
08:36:43 <geekosaur> heap should be unlimited these days? but this sounds like the kernel OOM killer, not heap overflow. which makes me wonder if 2-stage allocation confuses AWS's memory tracking
08:37:27 <sicklork1n> gwern: soryr i'm in outer space, i understand now what your asking
08:38:44 <gwern> geekosaur: it looked on the CLI like a standard OOM; it was only when watching RAM use in htop that I realized that I was never going above ~20% of the instance's RAM but the processes were 'OOMing' anyway. it's possible they actually do OOM legitimately but so fast I couldn't see it in htop. I'm doubtful because the memory growth is fairly gradual usually and I can't see why it'd change at...
08:38:50 <gwern> ...~700GB
08:38:59 <nshepperd> ski: I can see how to translate do { !x <- return undefined; bar } as 'return undefined >>= \x -> seq x bar'
08:39:00 <gwern> while something like 'resizing an array as a power of 2' somewhere might do this
08:39:10 <dmwit> gwern: You should ask in #ghc. I know recently there was some hubbub about reserving 1TB of address space when the RTS starts, perhaps the 700GB limit is related to this.
08:39:23 <geekosaur> right, that's the kind of thing that makes me wonder if this is 2-stage allocation confusing things
08:39:24 <nshepperd> ski: that seq is a problem for applicative because it's an evaluation dependency between x and bar
08:39:30 <dmwit> gwern: You may need to build a modified GHC from source that bumps this 1TB reservation up.
08:39:32 <geekosaur> or, what dmwit just said (that's the 1TB thing)
08:39:36 <gwern> :(
08:39:55 <sshine> I just hate it when my RAM allocations exceed 1TB.
08:40:00 <geekosaur> but I don't think 1TB limit itself is the issue, I'm wondering if how it uses the address space is confusing it
08:40:00 <dmj`> gwern: If it makes you feel better, I've been getting this error a lot with 8.6.5, "internal error: Unable to commit 1048576 bytes of memory" :( 
08:40:18 <gwern> sshine: well, when you pay good money for those terabytes of ram, you *do* want to use them
08:40:20 <geekosaur> dmwit, "processes" plural, so I think the 1TB limit itself is not the issue
08:40:24 <dmwit> gwern: GHC used to dynamically reserve more space as it was discovered it was needed. This was deemed Very Complicated, and so now it just reserves 1TB of address space and sticks everything in that space.
08:40:38 <dmwit> gwern: So now that I've said this aloud I'm almost certain this is what's going wrong for you.
08:40:43 <geekosaur> but it grows that as needed
08:41:00 <sshine> gwern, my old job had a 384GB RAM machine, and I ended up being the Windows Server guy just because I wanted to insert the RAM bricks. :P~
08:41:10 <ski> % :set -XApplicativeDo
08:41:11 <yahb> ski: 
08:41:13 <ski> % :t \foo bar -> do x <- foo; y <- bar; pure (x,y)
08:41:13 <yahb> ski: Applicative f => f a -> f b -> f (a, b)
08:41:17 <ski> % :t \foo bar -> do Just x <- foo; y <- bar; pure (x,y)
08:41:18 <yahb> ski: Monad m => m (Maybe a) -> m b -> m (a, b)
08:41:20 <ski> % :t \foo bar -> do (x,y) <- foo; z <- bar; pure (x,y,z)
08:41:21 <yahb> ski: Monad m => m (a, b) -> m c -> m (a, b, c)
08:41:31 <dmwit> geekosaur: I think part of the justification for the crazy-looking 1TB reservation was that it would no longer be necessary to grow it as needed.
08:41:41 <dmwit> geekosaur: So... how sure are you of "it grows that as needed"?
08:41:46 <gwern> well, I'll ask in #ghc...
08:42:03 <geekosaur> most of the time it's not, but I do know it will map more memory when needed for e.g. large bytestrings in pinned memory
08:42:04 <dmwit> gwern: Sorry you bumped into this!
08:42:05 <ski> nshepperd : i guess i was wondering whether it would make sense to have an `ApplicativeFail' in the middle of those (and the other two just using `Applicative' constraints)
08:42:15 <dmwit> Oh, yeah, pinned memory may well be different.
08:42:15 <geekosaur> and bytestring's code relies on this
08:42:18 <ski> nshepperd : i think you're thinking of something else, though
08:42:40 <gwern> dmwit: np. it only cost like $160... and the original code was wrong anyway so even if there wasn't this error I'd have to consider running it again anyway
08:42:46 <geekosaur> in any case, that's 1TB per process and it's only using ~700GB, I think it''s not directly relevant
08:42:55 <ski> (i possibly didn't state my query that well)
08:43:18 <geekosaur> but 2-stage allocation confuses a lot of stuff that expects standard GNU malloc-style allocation
08:43:53 <dmwit> geekosaur: A common strategy is to double the size of your heap when it runs out. 350->700GB wouldn't hit that problem, but trying to go 700GB->1.4TB would cross the threshold.
08:44:00 <dmwit> Dunno if GHC uses that strategy, but it seems reasonable enough.
08:45:42 <geekosaur> in any case this is OOM killer, this is the kernel thing, right? not a ghc allocation error?
08:46:00 <nshepperd> ski: what methods would ApplicativeFail have?
08:46:04 <geekosaur> because exhausting the 1TB would be the latter. not the former, that's the kernel saying ENOUGH!
08:46:29 <geekosaur> and the kernel won't do that for exhausting the heap, it will segfault you instead of OOM SIGKILL
08:46:40 <ski> nshepperd : basically same as `MonadFail' (but not being a subclass of `Monad', only of `Applicative')
08:47:43 <ski> (hm, i suppose one could argue to rename `MonadFail' to `ApplicativeFail', maybe ? unless there's coherence laws wrt `(>>=)' ? i suppose there could well be)
08:47:46 <nshepperd> 'fail :: String -> f a' won't help, because you need >>= to let fail depend on the value which is matching against
08:48:05 <nshepperd> you'd need something like 'afail :: f (Either String a) -> f a'
08:48:19 * ski isn't following at all
08:48:23 <EvanR> there are multiple ways for the kernel to kill you for running out of memory?
08:48:39 <EvanR> i only knew about OOM killer
08:49:02 <geekosaur> true OOM killer sends SIGKILL with a message to syslog. accessing unallocated memory gets SIGSEGV, this is the usual C "wild pointer crash"
08:49:26 <geekosaur> (or Haskell+FFI+pointer "oops")
08:49:33 <nshepperd> ski: how would you translate '\foo bar -> do Just x <- foo; y <- bar; pure (x,y)' using only applicative operators and 'fail'?
08:50:06 <merijn> geekosaur: I thought GHC could grow beyond 1TB but it just has to fallback to the slightly less efficient old GC algorithm?
08:50:15 <merijn> geekosaur: I'll admit I'm not sure, though
08:50:19 <geekosaur> so if you exhausted the 1TB allocated-but-unmapped heap area and ghc didn't handle it, the result would be SIGSEGV or possibly SIGBUS (I think not on Linux, only traditional Unix would do that)
08:50:29 <ski> nshepperd : hmm .. ok, i see what you mean. ty
08:50:52 <geekosaur> merijn, dmwit was the one saying it wouln't, my own understanding is it just maps more memory and keeps going
08:51:00 * ski still wonders why the last example above didn't require merely `Applicative', though ..
08:51:30 <geekosaur> so I'm saying what would happen if it in fact doesn't map the additional memory. either way, it's not the kernel OOM killer sending SIGKILL, it'd be a segfault
08:52:14 <geekosaur> OOM killer is the kernel saying the machine (or here, AWS instance) itself running short on memory. which shouldn't be happening in this situation
08:54:32 <EvanR> shouldn't be happening is best kind of happening :)
08:54:56 <merijn> How'd this discussion start? I missed that part
08:55:08 <exarkun> Can I have stack keep more in the binary cache?  If I build X and then change build flags (eg to collect coverage) then I have to rebuild X.  Fine.  If I change build flags again (eg to stop collecting coverage) then I have to rebuild X again.  Not so cool.
08:56:22 <geekosaur> merijn, http://tunes.org/~nef/logs/haskell/19.09.24 at 08:32:57
08:56:51 <geekosaur> (utc timestamp)
08:59:42 <nshepperd> > do (x,y) <- Just undefined; z <- Just 3; pure (x,y,z)
08:59:43 <lambdabot>  *Exception: Prelude.undefined
09:00:24 <nshepperd> > (\(x,y) z -> (x,y,z)) <$> Just undefined <*> Just 3
09:00:27 <lambdabot>  Just *Exception: Prelude.undefined
09:01:20 <nshepperd> ski: ^^ same sort of reason
09:05:11 <ski> nshepperd : yea, so with monadic do, it's just `Monad', not `MonadFail', so why, with `ApplicativeDo', is it still `Monad`, rather than `Applicative' ?
09:05:14 <ski> % :t \foo bar -> do x <- foo; y <- bar; pure (x,y)
09:05:14 <yahb> ski: Applicative f => f a -> f b -> f (a, b)
09:05:16 <ski> % :t \foo bar -> do (x,y) <- foo; z <- bar; pure (x,y,z)
09:05:16 <yahb> ski: Monad m => m (a, b) -> m c -> m (a, b, c)
09:06:18 <ski> also
09:06:21 <ski> % :t \foo bar -> do x <- foo; pure (x,x)
09:06:21 <yahb> ski: Functor f => f b -> p -> f (b, b)
09:06:26 <ski> % :t \foo bar -> do (x,y) <- foo; pure (y,x)
09:06:26 <yahb> ski: Monad m => m (b, a) -> p -> m (a, b)
09:06:34 <ski> why is that `Monad', rather than `Functor' ?
09:07:30 * hackage cabal2nix 2.15.0 - Convert Cabal files into Nix build instructions.  https://hackage.haskell.org/package/cabal2nix-2.15.0 (PeterSimons)
09:08:18 <nshepperd2> Because refutable patterns in a do context create a data dependency between the *result* of the first action, and the subsequent actions themselves
09:09:01 <nshepperd2> The result of my first Maybe example there was undefined, not Just undefined
09:09:37 <nshepperd2> But applicative says that if all inputs are Just, the result must be Just
09:09:38 <ski> yea, but these examples aren't about refutable vs. irrefutable patterns, but failable vs. non-failable patterns
09:09:53 <ski> (these ones being non-failable)
09:10:41 <ski> i do see that with a failable pattern, we do need the dynamic sequencing, so `Monad' over `Applicative' (or `Functor')
09:11:02 <ski> but these last four examples are non-failable
09:11:19 <ski> (as opposed to the `Maybe'-examples earlier)
09:13:39 <ski> hmm
09:14:52 <ski> nshepperd : ok, i think i see what you're saying ..
09:15:20 <ski> so, the issue, here, seems to be that tuple patterns themselves force
09:15:45 <ski> (making them not really categorical products, iirc)
09:16:08 <EvanR> is haskell broken again
09:16:40 <ski> i think i was toying, at some point, with the idea that perhaps `(<pat>,<pat>)' should be irrefutable, whenever the child patterns all are irrefutable
09:16:52 <ski> iow, `(_|_,_|_) = _|_'
09:17:13 <jotaro_shizza> can anyone explain me the syntax of type annotation
09:17:31 <dmj`> :t (undefined :: Int)
09:17:32 <lambdabot> Int
09:17:33 <ski> (so, operationally, one'd only force the pair computation, in case there was a subpattern which caused forcing)
09:17:56 <ski> nshepperd : thank you
09:17:57 <jotaro_shizza> I can't wrap my mind using a function and then using ::
09:18:30 <geekosaur> :t (read :: String -> Int)
09:18:32 <lambdabot> String -> Int
09:19:02 <geekosaur> the tricky part os that the :: will extend as far to the left as it can, so you often need parentheses
09:19:08 <ski> (for a short while i was red-herringed by my having `Just' in patterns in earlier examples. but in your examples, you had `Just' in the expressions, instead. so, i didn't look that close at your examples at first. now i did)
09:19:27 <jotaro_shizza> whammu
09:20:06 <ski> > (reads :: ReadS Integer) "123.45"
09:20:07 <jotaro_shizza> can we use :: to infer 2 or more typevariable ?
09:20:08 <lambdabot>  []
09:20:12 <ski> > (reads :: ReadS Double) "123.45"
09:20:14 <lambdabot>  [(123.45,"")]
09:22:13 <nshepperd2> ski: :)
09:23:26 <nshepperd2> % :t \foo bar -> do ~(x,y) <- foo; z <- bar; pure (x,y,z)
09:23:27 <yahb> nshepperd2: Applicative f => f (a, b) -> f c -> f (a, b, c)
09:23:29 <jotaro_shizza> please can anyone elaborate ...
09:23:44 <jotaro_shizza> I'm having difficulty understanding who answers who
09:23:51 <nshepperd2> Nice
09:25:21 <boj> jotaro_shizza: can you give an example of what confuses you?
09:26:26 <jotaro_shizza> can I pm ?
09:26:32 <boj> sure
09:28:52 * ski nods
09:29:00 * hackage streaming 0.2.3.0 - an elementary streaming prelude and general stream type.  https://hackage.haskell.org/package/streaming-0.2.3.0 (chessai)
09:38:30 * hackage pandoc-types 1.17.6.1 - Types for representing a structured document  https://hackage.haskell.org/package/pandoc-types-1.17.6.1 (JohnMacFarlane)
10:52:30 * hackage webby 0.2.0 - A super-simple web server framework  https://hackage.haskell.org/package/webby-0.2.0 (AdityaManthramurthy)
11:52:30 * hackage webby 0.3.0 - A super-simple web server framework  https://hackage.haskell.org/package/webby-0.3.0 (AdityaManthramurthy)
12:03:30 * hackage bytesmith 0.2.0.1 - Nonresumable byte parser  https://hackage.haskell.org/package/bytesmith-0.2.0.1 (andrewthad)
12:04:23 <koz_> @pl f <$> (x >>= g)
12:04:23 <lambdabot> f <$> (g =<< x)
12:08:56 <infinisil> If I declare a type like `type Foo i = '[SomeEffect i]`, and then pass it to some data type type like `bar :: Bar Foo`, I get an error that "The type synonym Foo should have 1 argument, but has been given none"
12:10:35 <Ariakenom> infinisil: bar :: Bar (Foo Int) should work
12:10:37 <infinisil> Bar is :: (* -> [(* -> *) -> * -> *]) -> *, so it can pass any i to the given type-constructing function
12:10:39 <ski> how's `Bar' defined ?
12:10:59 <infinisil> ^^
12:11:00 <ski> is `Bar' also a synonym ?
12:11:43 <infinisil> Bar is defined something like this: `data Bar r = Bar (forall i . Sem (r i))`
12:11:51 <ski> ok, so not a synonym
12:11:51 <infinisil> Bar is defined something like this: `data Bar r = Bar (forall i . Sem (r i) ())`
12:12:08 <ski> then you can't pass `Foo', being a synonym, unapplied, to `Bar'
12:12:20 <infinisil> Is there something I can do instead?
12:12:37 <hyperisco> Compose [] SomeEffect
12:13:04 <ski> well, `Compose' gives a `*' as result, right ?
12:13:19 <ski> (that's not the list type, but rather a list of types, i think ?)
12:13:45 <infinisil> Not sure how Compose could work
12:14:00 <hyperisco>  :k Compose :: (* -> *) -> (* -> *) -> * -> *
12:14:15 <ski> @kind Compose
12:14:16 <lambdabot> (k -> *) -> (k1 -> k) -> k1 -> *
12:14:31 <hyperisco> Amazed it is in scope
12:14:39 <ski> i did `@let import Data.Functor.Compose'
12:14:47 <hyperisco> Amazed lambdabot does imports
12:15:03 <hyperisco> Amazed Compose is in Data.Functor
12:15:08 <hyperisco> I've been away a long time
12:16:25 <infinisil> My usecase is that Bar is an algorithm that can work on any i's (and has to for correctness guarantees), but the effects it can do also depend on i
12:16:53 <hyperisco> newtype Foo i = Foo [SomeEffect i]
12:16:58 <hyperisco> Take your pick
12:17:19 <hyperisco> A question of whether Foo is worth naming or not
12:17:56 <ski> hyperisco : that's the list type, not a singleton list of types
12:18:02 <infinisil> hyperisco: Expected type but '[SomeEffect i] has kind '[(* -> *) -> * -> *]
12:18:32 <hyperisco> Oh I just ran right over '[
12:19:04 <infinisil> I want to be able to do `bar :: Bar (\i -> Foo i)`
12:20:14 <infinisil> Wait isn't there a ghc proposal for partially applied kinds
12:20:20 <hyperisco> Is '[] even inhabited?
12:20:49 <infinisil> https://github.com/ghc-proposals/ghc-proposals/pull/242
12:21:38 <ski> hyperisco : it's not inhabitable
12:22:01 <hyperisco> Okay, so Sem, whatever that is, makes some special use of this list
12:22:03 <ski> (`Void' is inhabitable, although not inhabited (discarding bottoms))
12:22:54 <hyperisco> There is nothing stopping you from having a list of * -> * types, but this interferes with whatever Sem is
12:22:54 <ski>   Sem :: [(* -> *) -> * -> *] -> * -> *  -- ?
12:23:12 <infinisil> Sem =~= Eff in extensible-effects
12:23:18 <infinisil> ski: Yeah
12:23:22 <hyperisco> ohh
12:23:28 <hyperisco> you could have said that
12:23:30 * hackage mmsyn2 0.1.2.0 - The library that can be used for optimization of multiple (Ord a) => a -> b transformations  https://hackage.haskell.org/package/mmsyn2-0.1.2.0 (OleksandrZhabenko)
12:23:36 <infinisil> I probably should have yeah, sry
12:23:44 <ski> hyperisco : it was more or less inferrable from the previous stuff
12:24:49 <infinisil> I think I might just drop the correctness guarantee by removing the forall i stuff
12:25:23 <hyperisco> infinisil, there are too many moving pieces. I don't know how to give any particular recommendation
12:25:43 <hyperisco> But I think you may need to rethink the design of Bar and or Sem
12:26:24 <vaibhavsagar> I'm in cabal hell
12:26:27 <hyperisco> I am not sure if '[* -> *] is a kind but if not then you can use a proxy (* -> *) -> * to satisfy '[*]
12:26:39 <ski> hyperisco : it is a kind, yes
12:26:54 <vaibhavsagar> `ghc-pkg list` is giving me two different entries for `monad-control`
12:27:09 <vaibhavsagar> how do I debug further?
12:27:15 <dmwit> That by itself is not a problem.
12:27:17 <sclv> well you probably have two different entries
12:27:23 <sclv> also why aren't you just using new-build
12:27:25 <sclv> nix?
12:27:32 <vaibhavsagar> yes
12:27:44 <vaibhavsagar> I do have two different entries
12:27:44 <vaibhavsagar> but I don't know why
12:28:02 <sclv> is this a nix-generated pkgdb?
12:28:20 <vaibhavsagar> how do I get a graph of which things have which dependency?
12:28:22 <sclv> also, as dmwit says, why is that a problem?
12:28:31 <sclv> i.e. are you trying to use it and it can't pick which one?
12:28:56 <sclv> there's no tool that does a dep-graph of things in your package-db and their relations afaik
12:29:09 <vaibhavsagar> I'm trying to use ghcid and it is barfing because of the different versions
12:29:10 <vaibhavsagar> that's why it's a problem
12:29:50 <hyperisco> Then I'd be thinking to have a list of * -> * types
12:30:00 <sclv> wait why is ghcid barfing? is it running a command that barfs?
12:30:14 <sclv> you could just `ghc-pkg hide` one or the other...
12:30:33 <vaibhavsagar> I'm using `ob run`, which uses ghcid under the hood afaict
12:30:46 <infinisil> hyperisco: Ah proxy might work, lemme see..
12:31:10 <exarkun> is anything like this haddock markup allowed/possible?  can you document tuple elements?  https://github.com/PrivateStorageio/PaymentServer/blob/12.ristretto-privacypass/src/PaymentServer/Ristretto.hs#L65-L72
12:31:51 <Cale> vaibhavsagar: And you're using ob shell to get the shell to check which packages you have?
12:32:11 <dmwit> exarkun: I don't think so. Use a real data type instead.
12:32:15 <vaibhavsagar> Cale: no, I was using `nix-shell -A shells.ghc`
12:32:37 <vaibhavsagar> I didn't know we had an `ob shell`
12:32:40 <Cale> Try ob shell just to be sure
12:32:51 <vaibhavsagar> Cale: same output
12:32:54 <Cale> okay
12:33:14 <dmwit> exarkun: Also, for lines 110-150, you might like https://stackoverflow.com/q/33005903/791604
12:33:15 <Cale> Maybe I can get on a call and help you out, this is for work?
12:33:33 <vaibhavsagar> Cale: it's not for work, so not urgent
12:33:36 <Cale> ah, okay
12:33:48 <exarkun> dmwit: thanks.  I know those lines suck and I've been working on learning what to do about it separately.
12:34:13 <exarkun> I thought it might have something to do with ExceptT, so glad that seems to be the right track.
12:42:30 * hackage webby 0.3.1 - A super-simple web server framework  https://hackage.haskell.org/package/webby-0.3.1 (AdityaManthramurthy)
12:57:00 * hackage lzlib 0.2.0.2 - lzlib bindings  https://hackage.haskell.org/package/lzlib-0.2.0.2 (vmchale)
13:59:00 * hackage scientific-notation 0.1.0.0 - Scientific notation intended for tokenization  https://hackage.haskell.org/package/scientific-notation-0.1.0.0 (andrewthad)
14:01:17 <ANJ> hi folks
14:01:21 <koz_> ANJ: Sup>
14:01:28 <ANJ> i have doubt
14:01:33 <ANJ> if you have a function like foo a = bar b a, you can
14:01:39 <ANJ> how?
14:01:48 <ANJ> need some explaination
14:01:53 <koz_> ANJ: You can ... what?
14:01:59 <koz_> I don't think I understand the question, sorry.
14:02:24 <ANJ> foo and bar are functions
14:02:36 <ANJ> foo a= bar b a
14:02:46 <ANJ> is same as foo = bar b
14:02:55 <ANJ> can u explain  how?
14:03:06 <koz_> ANJ: Basically, all Haskell functions can be partially applied.
14:03:30 <merijn> koz_: I don't think that point is particularly relevant, tbh
14:03:52 <koz_> merijn: In what sense?
14:03:56 <ANJ> hm...need some explaination
14:04:00 <merijn> The real answer is "every function is single argument and sometime returns another function"
14:04:12 <koz_> merijn: Yeah, that's a better way of putting it.
14:04:20 * koz_ lets merijn explain things.
14:04:22 <merijn> koz_: Well, for one, define "partially applied" without handwaving ;)
14:04:37 <ANJ> then...how is a passed?
14:04:46 <ANJ> "a"
14:04:48 <merijn> ANJ: Let's rewind
14:04:52 <merijn> ANJ: Consider:
14:04:53 <merijn> :t map
14:04:55 <lambdabot> (a -> b) -> [a] -> [b]
14:05:02 <ANJ> ok
14:05:11 <mycroftiv> ANJ: when you make a haskell function that looks like it takes parameters A B C - this is a shorthand way of expressing a function which takes A and then makes a new function, which will then take B and make a new function, and then apply the composition to C
14:05:13 <merijn> ANJ: How many arguments does "map" take?
14:05:36 <ANJ> function and list
14:05:47 <ANJ> okay...go on
14:05:48 <merijn> ANJ: That's one answer, yes
14:06:25 <merijn> ANJ: Keep in mind that -> at the type level is right associative, so "(a -> b) -> [a] -> [b]" is equivalent to "(a -> b) -> ([a] -> [b])"
14:07:02 <merijn> ANJ: So, we can also argue (more correctly too) that "map" takes 1 argument, a function. And that it's return value is a new function with type "[a] -> [b]"
14:07:41 <merijn> :t map even
14:07:42 <lambdabot> Integral a => [a] -> [Bool]
14:07:44 <ANJ> okay..yes got it
14:08:09 <merijn> ANJ: Now, back to "foo a = bar b a"
14:08:25 <ANJ> yup
14:08:41 <merijn> ANJ: Instead of saying "bar is a function of two arguments" we can see "bar is a function that takes an argument 'b' that returns a new function which takes an argument 'a'"
14:08:59 <merijn> i.e. "foo a = bar b a" is the same as "foo a = (bar b) a"
14:09:55 <merijn> ANJ: So if "bar b" is just a function that gets returned, we can simply say "foo = bar b" to say "foo is the result of 'bar b'" (which happens to be "a function that takes an 'a'")
14:10:09 <ANJ> great...
14:10:15 <ANJ> got it...
14:10:26 <ANJ> that's great explaination
14:11:11 <ANJ> thank you guys....
14:11:19 <ANJ> gotta go to algo class
14:11:20 <ANJ> bye
14:11:31 <merijn> np
14:15:30 * hackage texmath 0.11.2.3 - Conversion between formats used to represent mathematics.  https://hackage.haskell.org/package/texmath-0.11.2.3 (JohnMacFarlane)
14:31:03 <koz_> Is there a pre-baked 'one or both' type? I mean something like 'data Foo a b = One a | Both a b'?
14:31:29 <merijn> koz_: There's one for "One a | Two b | Both a b", not sure that helps
14:31:45 <koz_> merijn: Yeah, it's 'These', but that's more than I need.
14:31:55 <nil> `Either a (Maybe b)` ?
14:32:07 <nil> er, `(a, Maybe b)`
14:33:50 <ski> @hackage these
14:33:50 <lambdabot> http://hackage.haskell.org/package/these
14:33:59 <ski> koz_ : i suppose not that ^, then ?
14:34:12 <ski> ok
14:42:11 <jle`> koz_: sounds like a "non-empty Maybe"
14:42:13 <jle`> https://hackage.haskell.org/package/nonempty-alternative
14:42:29 <jle`> or https://hackage.haskell.org/package/nonempty-lift
14:43:05 <jle`> or https://hackage.haskell.org/package/non-empty too, neat. i wonder if any of them are commonly used
14:44:49 <koz_> jle`: a and b can be different types.
14:44:57 <koz_> All of your suggestions are homogenous I think.
14:45:10 <jle`> ah i see, yeah that's a difference
14:45:45 <jle`> sounds like (a, Maybe b) would make the most sense as a structure, but it doesn't have the nice instances
14:46:03 <jle`> if you want a bifunctor instance you can use Biff (,) Identity Maybe
14:46:03 <koz_> (a, Maybe b) is actually an instance of quite a few things if properly newtyped.
14:46:33 <jle`> yeah but if you newtype and write instances for your newtype you might as well just use data Foo a b = One a | Both a b
14:47:05 <jle`> hm, but actually if you newtype (a, Maybe b) you maybe can derive Bifunctor (Foo a b) via Biff (,) Identity Maybe
14:47:16 <jle`> *Bifunctor Foo
14:47:52 <koz_> jle`: Could I just newtype over Biff (,) Identity Maybe?
14:48:01 <koz_> Would that award me any good instances?
14:48:26 <jle`> i don't think there's any real point to doing so now that we have DerivingVia
14:49:05 <jle`> but yeah look over the instances for Biff if you want to see what kidn of instances you can derive in terms of it
14:49:49 <jle`> but defining it as a newtype of Biff would make it a lot harder to use practically and pattern match on, without some extra pattern synonyms maybe
14:52:34 <koz_> jle`: Yeah, fair point.
14:52:44 <koz_> What package is Biff from again?
14:54:29 <koz_> Never mind, found it.
15:06:48 <koz_> :t forM_
15:06:49 <lambdabot> (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
15:07:16 <koz_> @src forM_
15:07:16 <lambdabot> forM_ = flip mapM_
15:07:22 <koz_> @where forM_
15:07:22 <lambdabot> I know nothing about form_.
15:08:23 <MarcelineVQ> @index forM_
15:08:23 <lambdabot> Data.Foldable, Control.Monad
15:08:31 <koz_> Oh, that's the command I want, thanks.
15:13:32 <syd> Hey! Is there a way to add a `Bool` field to a persistent model such that it gets initialised with False in migrations?
15:13:36 <syd> I tried `default=False` but that inserts the text `False`.
15:14:52 <crestfallen> hi I'm learning about conversion functions and isomorphism. I guess tt = f . g is wrong here. what do these functions do ( I cannot get g to work alone ) thanks   https://termbin.com/0yx0
15:16:01 <syd> aha, ` default=0` seems to wokr
15:17:07 <jle`> crestfallen: f is a -> () -> a, it takes an 'a' and a (), and returns an 'a'
15:17:07 <lyxia> crestfallen: g takes a function k and applies it to (), which part of that is confusing?
15:17:28 <jle`> g should work if you give it any (() -> a) function
15:17:37 <jle`> for example g (\_ -> "hello")
15:18:17 <crestfallen> I see thanks hold on please
15:19:30 * hackage git-lfs 1.1.0 - git-lfs protocol  https://hackage.haskell.org/package/git-lfs-1.1.0 (JoeyHess)
15:20:33 <crestfallen> jle`: so is tt correct there ?
15:20:58 <jle`> i'm not sure what you mean by 'correct'
15:21:03 <jle`> like, morally?
15:21:13 <iqubic> crestfallen: does it type check?
15:21:40 <jle`> what is right/wrong here? is this a homework assignment maybe, where right and wrong have a clearly defined answer?
15:22:47 <crestfallen> jle`: no this is a guy with no programming background and no clue :)
15:22:53 <jle`> hm
15:22:58 <jle`> so how do you want us to answer this question?
15:23:05 <jle`> we don't know what is wrong or right, because we aren't sure what you want to do
15:23:12 <comerijn>  /quit
15:23:14 <jle`> that's like saying if x = 3 is right or wrong, without telling us what you're using x for
15:23:24 <crestfallen> no thank you it does type check and I see how it works, or at least that it works
15:23:38 <iqubic> It looks like f and g are two sides of an isomorphism. And it looks like like he's trying to prove that 'f . g = id'.
15:23:46 <crestfallen> so the context is a tutorial on isomorphism
15:24:10 <jle`> x = 3 is right if you're, say, calculating the number of letters in "abc"
15:24:23 <jle`> x = 3 is wrong if you're, say, calculating the population of the earth
15:25:25 <jle`> is tt = f . g right or wrong? it depends on what you want to do with tt, or what you expect tt to be
15:25:31 <crestfallen> the first example was swap :: (a -> b) -> (b -> a); swap (x,y) = (y,x). so the comment was that data is not lost in a "safe conversion"
15:26:00 <jle`> if you want tt to run a twitter clone as a web server, it's wrong :)
15:27:33 <crestfallen> so  I see how tt = f . g is id. so in the type def, how does taking (() -> a) and () as arguments make it isomorphic?  
15:29:35 <crestfallen> . :t tt               tt :: (() -> a) -> () -> a
15:30:17 <crestfallen> I think I get it actually
15:30:37 <iqubic> jle`: He's trying to prove that 'f . g' is 'id'
15:31:27 <jle`> crestfallen: the fact that the types match isn't what makes it isomorphic
15:31:49 <jle`> crestfallen: there are a lot of functions where the types match up correctly, but they do'nt form an isomorphism
15:31:57 <jle`> so the types aren't really the important thing here
15:32:19 <jle`> crestfallen: the important property is that for all inputs, it returns the same input unchanged
15:32:33 <crestfallen> yeah thanks iqubic  jle`       the function is what makes it isomorphic right?
15:32:41 <crestfallen> a conversion function like:
15:32:46 <jle`> yeah. so try feeding it some sample inputs, and seeing what outputs you get
15:32:58 <jle`> for example, feed it (\_ -> "hello").  what function do you get back out?
15:33:00 <crestfallen> f :: A -> B    and    g :: B -> A
15:33:06 <crestfallen> hold on
15:33:16 <iqubic> this is isomorphic if and only if 'f . g = g . f = id' for all inputs.
15:33:33 <crestfallen> yeah it works it's just identity : "hello"
15:33:54 <jle`> it has to return (\_ -> "hello")
15:33:56 <jle`> not "hello"
15:34:12 <jle`> if you feed it (\_ -> "hello"), the result has to also be (\_ -> "hello")
15:34:24 <crestfallen> ok but I was using tt
15:34:29 <jle`> that's what i mean
15:34:39 <jle`> if you give tt (\_ -> "hello"), it has to give back (\_ -> "hello") as an output
15:34:43 <jle`> that's the only way it can be an isomorphism
15:34:55 <jle`> if it gives back anything else, it's not an isomorphism
15:34:57 <crestfallen> tt (\_ -> "hello") ()    returns "hello"
15:35:10 <jle`> yeah, but it's not important what tt (\_ -> "hello") () gives back
15:35:17 <jle`> what's important is what tt (\_ -> "hello") gives back
15:35:29 <jle`> that's the 'point' of an isomorphism
15:35:39 <jle`> if you give it an input, it has to return the same input unchanged, as output
15:35:51 <crestfallen> sorry I'm getting a print error with that input
15:36:12 <jle`> yeah, the output `() -> String` can't be shown, becuase it has no Show instance
15:36:14 <iqubic> yes. of course.
15:36:23 <iqubic> You can't print a function.
15:36:24 <jle`> so you have to look at it analytically
15:36:31 <jle`> or like, 'think' about what it does
15:36:45 <jle`> maybe give it a name, newHello = tt (\_ -> "hello")
15:36:55 <crestfallen> ok
15:36:57 <jle`> what is the type of newHello, and how does it behave?
15:37:16 <jle`> maybe to make it more explicit, newHello = tt (\() -> "hello")
15:37:18 <crestfallen> let newHello = tt (\_ -> "hello")
15:37:22 <crestfallen> sorry
15:37:35 <jle`> so newHello is an isomorphism if and only if it is equivalent to the function (\() -> "hello")
15:37:54 <jle`> er, tt is a valid isomorphism candidate if newHello is equivalent to (\() -> "hello") 
15:38:19 <crestfallen> blushing
15:38:45 <jle`> so, what is the type of newHello, and how does it behave when you give it different inputs?
15:39:59 <crestfallen> the type is [Char]
15:40:11 <iqubic> Not quit.
15:40:29 <jle`> crestfallen: you don't need to guess
15:40:32 <jle`> that's the magic of Haskell
15:40:34 <jle`> you can just ask ghci :)
15:41:18 <crestfallen> is something amiss? > :t newHello           newHello : [Char]
15:41:54 <jle`> let newHello = tt (\() -> "hello")
15:42:10 <jle`> hm, are you using the same tt that you gave in the paste?
15:43:24 <crestfallen> one moment please
15:43:37 <crestfallen> yeah its the same...
15:44:30 <jle`> hm, can you paste the line you are using in ghci to define newHello?
15:45:07 <crestfallen>  λ > newHello = tt (\_ -> "hello")
15:45:32 <iqubic> and what does ':t newHello' return?
15:45:50 <crestfallen> ..     newHello :: [Char]
15:46:29 <iqubic> Something isn't right here.
15:46:31 <jle`> hm ... are you ... using ghc? this is  interesting
15:46:40 <jle`> % ff x () = x
15:46:40 <yahb> jle`: 
15:46:45 <jle`> % gg k = k ()
15:46:45 <yahb> jle`: 
15:46:56 <jle`> % tt = ff . gg
15:46:56 <yahb> jle`: 
15:47:10 <iqubic> % :t tt (\_ -> "Hello")
15:47:10 <yahb> iqubic: () -> [Char]
15:47:14 <jle`> % newHello = tt (\() -> "hello")
15:47:14 <yahb> jle`: 
15:47:18 <jle`> % :t newHello
15:47:19 <yahb> jle`: () -> [Char]
15:47:42 <jle`> are you using the latest version of ghc maybe?
15:47:45 <iqubic> That is the expected output of ':t newHello'
15:47:54 <crestfallen> weird hold on pls
15:47:55 <iqubic> And lambdabot is down.
15:57:34 <crestfallen> @let f :: a -> () -> a; f = \x _ -> x
15:57:36 <lambdabot>  Defined.
15:57:50 <crestfallen> @let g :: (() -> a) -> a; g k = k ()
15:57:52 <lambdabot>  Defined.
15:58:07 <crestfallen> @let tt = f . g
15:58:08 <lambdabot>  .L.hs:179:6: error:
15:58:08 <lambdabot>      Ambiguous occurrence ‘f’
15:58:08 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.f’,
15:58:24 <jle`> f and g are already defined for lambdabot, so i used ff and gg earlier
15:58:26 <crestfallen> @let ff :: a -> () -> a; ff = \x _ -> x
15:58:27 <lambdabot>  Defined.
15:58:42 <crestfallen> @let gg :: (() -> a) -> a; gg k = k ()
15:58:43 <lambdabot>  Defined.
15:58:57 <crestfallen> @let tt = ff . gg
15:58:59 <lambdabot>  Defined.
15:59:50 <crestfallen> @let conversion = tt (\_ -> "hello")
15:59:51 <lambdabot>  Defined.
16:00:00 <crestfallen> > conversion
16:00:00 <iqubic> :t coversion
16:00:01 <lambdabot> error:
16:00:02 <lambdabot>     • Variable not in scope: coversion
16:00:02 <lambdabot>     • Perhaps you meant ‘conversion’ (line 185)
16:00:02 <lambdabot>  <() -> [Char]>
16:00:17 <iqubic> :t conversion
16:00:18 <lambdabot> () -> [Char]
16:00:21 <crestfallen> > conversion
16:00:24 <lambdabot>  <() -> [Char]>
16:00:27 <jle`> you can't show conversion
16:00:29 <iqubic> It works properly.
16:00:30 <jle`> but you can ask for its type
16:00:33 <jle`> :t conversion
16:00:35 <lambdabot> () -> [Char]
16:00:37 <iqubic> :t conversion
16:00:39 <lambdabot> () -> [Char]
16:00:40 <crestfallen> hmm
16:00:45 <jle`> crestfallen: is this different than the behavior you have in your own ghci?
16:01:13 <crestfallen> I'm looking for the error...
16:01:22 <jle`> if so, then i'd maybe file a bug report with ghc
16:01:56 <dmwit> mmmm
16:01:57 <jle`> (only one difference, ghci by default doesn't 'show' conversion if you ask it to, like lambdabot does here.  but :t conversion should be the same)
16:02:07 <dmwit> I'd place a pretty strong bet on user error over GHC bug for something this simple.
16:02:09 <jle`> dmwit: apparently after entering all of this, :t conversion => [Char]
16:03:08 <dmwit> Maybe... 60:1.
16:03:32 <EvanR> alright then. Let's see everyones $
16:03:39 <EvanR> i'll hold onto it until this issue is resolved
16:05:03 <jle`> you should suggest we hand over the money to completely non-suspicious and totally trustworthy user RnavE
16:06:14 <crestfallen> ok I did conversion = ff . gg    and ...
16:06:28 <jle`> hold on, tt = ff . gg
16:06:34 <jle`> and conversion = tt (\() -> "hello")
16:06:44 <crestfallen> myconversion = conversion (\_ -> "hello")
16:06:45 <crestfallen> yeah
16:07:13 <crestfallen> I changed it but yeah I get the correct typecheck
16:07:16 <jle`> and what was :t myconversion ?
16:07:19 <jle`> ah hooray
16:07:23 <jle`> i guess no bug in ghc
16:07:31 <crestfallen> so how to print that
16:07:32 <jle`> i wonder what was happening before
16:07:39 * dmwit collects his $0
16:07:43 <jle`> crestfallen: you can't print it, it has no Show instance
16:07:46 <EvanR> ohhhhh
16:08:02 <crestfallen> EvanR has it out for me
16:08:03 <jle`> crestfallen: but we can think about what it does
16:08:22 <jle`> crestfallen: `myconversion :: () -> String`, yes?  so, what does this function do, do you think?
16:08:51 <jle`> you can test it out by feeding it some sample inputs and seeing how it behaves on those sample inputs
16:08:53 <EvanR> to visualize an arbitrary function, visualize the results for your chosen input
16:09:06 <EvanR> then vary the input. (in case of ()... kind of hard... but still)
16:10:30 <EvanR> disclaimer, warranty voided on this technique if you try to visualize Void -> A
16:10:43 <crestfallen> thanks all, sorting this out...
16:11:03 <iqubic> EvanR: That's absurd.
16:11:18 <jle`> that's sparta
16:11:31 <hpc> and don't think you can just do Void -> (Void -> A), that's a classic mistake
16:12:44 <MarcelineVQ> LEMme tell MU all about it
16:13:31 <crestfallen> getting more confused 
16:13:49 <MarcelineVQ> only listen to the people using your name
16:14:18 <hpc> following irc conversations is a legitimate skill sometimes ;)
16:17:04 <crestfallen> so what it does jle`    is ...
16:17:19 <crestfallen> ff :: A -> B and gg :: B -> A
16:17:20 <EvanR> i'm serious https://www.youtube.com/watch?v=faJ8N0giqzw
16:17:47 <jle`> crestfallen: don't think about what it is made up of
16:17:52 <jle`> crestfallen: just try exploring it in ghci
16:18:00 <jle`> try observing it as if it were a black box
16:18:20 <jle`> % conversion ()
16:18:20 <yahb> jle`: ; <interactive>:403:1: error: Variable not in scope: conversion :: () -> t
16:18:25 <jle`> > conversion ()
16:18:27 <lambdabot>  "hello"
16:18:46 <jle`> if you were someone who had no idea what this conversation was about, and just joined #haskell two seconds ago
16:18:56 <jle`> what would you tell me about what you thought about that function `conversion` ?
16:19:10 <jle`> based on the fact that we observe `conversion () => "hello"`
16:20:09 <freeman42x> I am looking for a web framework / libraries (combo) that meets the following criteria: https://github.com/razvan-flavius-panda/blog/blob/master/Optimal%20Haskell%20web%20framework.md Any suggestions?
16:20:42 <crestfallen> hold on sorry jle` I can't run conversion ()
16:21:12 <jle`> it looks like you called it `myconversion` earlier
16:21:33 <jle`> i originally called it newHello, newHelo = tt (\() -> "hello")
16:21:44 <crestfallen> yeah but conversion is still defined in the buffer
16:21:49 <crestfallen> register
16:22:04 <jle`> sure, so call it newHello = tt (\() -> "hello")
16:22:08 <jle`> and try seeing what newHello () does
16:25:55 <crestfallen> jle`: so yeah that works .. I mean it works just like const
16:26:10 <jle`> it doesn't work just like const, does it?
16:26:15 <jle`> const takes two inputs, but newHello takes one input
16:27:16 <crestfallen> but isn't it like currying with the first parameter defined as (\_ -> "hello)   ?
16:27:28 <jle`> it works like `const "hello"`, maybe
16:27:28 <crestfallen> "
16:27:32 <jle`> is that what you mean?
16:27:43 <crestfallen> I guess yeah
16:27:59 <jle`> see if you can make yourself more sure of it :)
16:28:11 <jle`> because the next step will only make sense fi you understand why it's the same as const "hello"
16:29:14 <crestfallen> this is the tutorial it's the second example under basics: https://kseo.github.io/posts/2016-12-25-type-isomorphism.html
16:29:38 <jle`> so, do you see why `newHello` is the same as `const "hello"`?
16:29:53 <crestfallen> working..
16:32:02 <crestfallen> yeah because you're inputting () to newHello, which is ignored, or not ignored but the isomorphism is completed when you input () jle`
16:32:23 <crestfallen> so "hello" is all that is left
16:33:15 <jle`> the isomorphism is already 'completed' before you give the ()
16:33:24 <jle`> remember, we are talking about isomorphisms between functions, not isomorphisms between strings
16:33:37 <jle`> so, tt (const "hello") == const "hello", right?
16:35:42 <crestfallen> hold on that's trippy I'm not sure I get that
16:36:11 <jle`> crestfallen: okay, so `newHello = tt (const "hello")`, right?
16:36:21 <jle`> and you just told me that newHello == const "hello"
16:36:38 <jle`> so, by transitive property, if tt (const "hello") == newHello, and newHello = const "hello"
16:36:45 <jle`> then that means that tt (const "hello") == const "hello"
16:36:56 <jle`> if x == y and y == z, then x == z
16:38:54 <crestfallen> yeah because (\_ -> "hello") is interchangeable with const "hello" because  \_ is a wildcard that returns "hello"
16:40:55 <jle`> yeah. so do you see how `tt (const "hello")` returns `const "hello"`. it just returned our original input, unchanged
16:41:06 <orzo> Is there a list package providing a lazy spine with strict unboxed elements?
16:41:12 <jle`> and because nothing special is going on with "hello", you can maybe also see that `tt (const x) = const x`
16:41:41 <jle`> and, since all functions from () are a constant function, this is like saying `tt blah == blah`
16:41:54 <jle`> so tt = id.  since whatever function you give it, it'l return the same function in return
16:42:00 <jle`> if you give it const "hello", it'll give back const "hello"
16:42:10 <jle`> if you give it const 123, it'll gibe back const 123
16:42:17 <jle`> if you give it const True, it'll give back const True, etc.
16:42:32 <jle`> tt = id :)
16:46:47 <crestfallen> so id is 'const "hello"' but what about the type of tt      :t tt  () -> [Char]    where is the function const in that type signature jle`   ?
16:46:58 <jle`> id is not const "hello"
16:47:07 <jle`> and that is not the type of tt
16:47:10 <crestfallen> its just hello
16:47:23 <jle`> crestfallen: i'm saying that `tt = id`, which means `tt (const "hello")` is the same as `id (const "hello")`
16:47:27 <jle`> which is the same as `const "hello"`
16:47:41 <jle`> tt (const "hello")
16:47:45 <jle`> = id (const "hello")
16:47:48 <jle`>  = const "hello"
16:48:26 <jle`> and tt :: (() -> a) -> (() -> a), not whatever type you wrote out, heh
16:50:24 <crestfallen> trippy I think I have it. thanks kindly jle`
16:50:35 <jle`> np :)
16:51:25 <anup> hi folks
16:51:30 <anup> i wanted help for a programme
16:52:01 <Guest22388> about permutations in haskell
16:52:22 <Guest22388> input is: distribute 1 [2,3]
16:52:29 <Guest22388> output required : [[1,2,3], [2,1,3], [2,3,1]]
16:52:56 <Guest22388> any help is appreciated
16:56:32 <c_wraith> take it one step at a time. can you write something that outputs [[1,2,3]]?
16:58:30 * hackage emd 0.1.6.0 - Empirical Mode Decomposition and Hilbert-Huang Transform  https://hackage.haskell.org/package/emd-0.1.6.0 (jle)
17:01:24 <Axman6> @unmtl RWST (ExceptT e m)
17:01:24 <lambdabot> Plugin `unmtl' failed with: `RWST (ExceptT e m)' is not applied to enough arguments, giving `/\A B C D. ExceptT e m -> B -> C (D, B, A)'
17:01:39 <Axman6> @unmtl RWST r w s (ExceptT e m) a
17:01:39 <lambdabot> r -> s -> ExceptT e m (a, s, w)
17:02:11 <Axman6> @unmtl ExceptT e (RWST r w s m) a
17:02:11 <lambdabot> ExceptT e (RWST r w s m) a
17:02:15 <Axman6> :'(
17:02:25 <Axman6> @unmtl ErrorT e (RWST r w s m) a
17:02:26 <lambdabot> r -> s -> m (Either e a, s, w)
17:02:38 <Axman6> that's the one, thanks lambdabot
17:04:09 <c_wraith> just remember that when you apply a transformer, its effects have to be jammed inside of what it's wrapping. 
17:14:08 <Axman6> yeah it always feels backwards but makes sense
17:15:25 <anj> distribute 1 [2,3] should return [[1,2,3], [2,1,3], [2,3,1]].
17:18:06 <anj> any idea?
17:18:29 <Axman6> anj: c_wraith is trying to get you to work towards the solution through a series of logical steps. if that is all the requirement is, then you can just write: distribute 1 [2,3] = [[1,2,3], [2,1,3], [2,3,1]]
17:19:09 <Axman6> "c_wraith: take it one step at a time. can you write something that outputs [[1,2,3]]? "
17:42:52 * dmwit . o O ( Just nondeterministically choose l,r such that l++r = [1,2,3] and form l++[1]++r, what could be easier? )
17:50:49 <chesscipher> can someone help me installing haskell on openbsd?
17:51:16 <chesscipher> I mean, stack;
17:51:41 <chesscipher> rn I've done: pkg_add ghc cabal-install; cabal update; cabal install stack
17:51:51 <chesscipher> tho in this last step it 'breaks'
17:52:17 <chesscipher> ``cabal: The following packages are likely to be broken by the reinstalls: ghc-8.2.2. Use --force-reinstalls if you want to install anyway.''
17:52:49 <chesscipher> and doing so it can't compile a couple of packages
17:53:09 <jle`> chesscipher: usually you can use stack to install cabal-install, but i don't think it's normal to go the other way around
17:53:35 <jle`> have you tried installing stack directly first?
17:53:41 <jle`> instead of getting cabal-install first
17:54:29 <Chaoxu> What is the standard way to work with things that have multiple typeclass implementations? for example integers are monoids over + and *. There are times I feel it's easier to just define a function `useMappend: (a->a->a)->a->a->a`, and just pass the `mappend` function into it. 
17:54:59 <chesscipher> jle`: from where? I couldn't find it in the openbsd repo
17:55:18 <jle`> chesscipher: hm, does https://docs.haskellstack.org/en/stable/README/ help any?
17:55:45 <jle`> Chaoxu: usually we work with the functions specifically, yeah, like 8 * 3 vs. 8 + 3
17:55:52 <chesscipher> jle`: (1) ``Sorry, this installer does not support your operating system: OpenBSD.''
17:56:02 <jle`> Chaoxu: the main issue is when you have to use typeclass-polymorphic abstractions
17:56:04 <jle`> oh they left :'(
17:56:10 <jle`> chesscipher: ah :'(
17:56:58 <chesscipher> jle`: (2) there is no subtitle with ``openbsd'' in it in the /install_and_upgrade/
17:58:24 <jle`> hm, i'm sorry, i'm not sure how to help in this case then. although, you should be able to get full haskell functionality with just cabal-install
17:58:43 <jle`> (instead of needing stack)
18:02:56 <dmwit> chesscipher: What does `cabal install stack --dry-run` say?
18:03:13 <dmwit> chesscipher: Perhaps you can just pin the versions of whichever packages it's reinstalling to the installed versions.
18:03:32 <dmwit> chesscipher: Or at least the versions of the packages that come with GHC.
18:04:32 <sclv> I’m not even sure if stack supports openbsd?
18:04:51 <sclv> If there’s no ghc binaries for it that stack packages
18:05:05 <sclv> Then having a stack binary is useless
18:05:37 <chesscipher> dmwit: https://0x0.st/zthg.txt
18:06:13 <chesscipher> sclv: ghc exists on openbsd, infact I have it installed, tho I'd like to install stack too
18:07:33 <sclv> yes. But stack installs its OWN ghc
18:07:38 <sclv> Not the system one
18:07:43 <dmwit> chesscipher: Something like `cabal install stack --constraint 'directory installed' --constraint 'process installed'`.
18:07:54 <sclv> and idk if it packages one for bsd
18:08:00 <dmwit> But yes, this consideration about whether stack will even work once you're done with that is worth thinking about.
18:08:15 <sclv> Given it doesn’t even give you a binary of stack itself
18:09:38 <dmwit> (directory and process are the two packages marked by "new version" in your paste but that ship with GHC)
18:15:06 <chesscipher> dmwit: trying now
18:16:05 <chesscipher> dmwit: the last part: https://0x0.st/zthl.txt
18:16:33 <Silent_Alex> s
18:24:52 <chesscipher> option B, how do I compile stack?
18:26:36 <anj> hi
18:26:43 <anj> how to proove map f (filter p l) = filter p (map f l)
18:27:57 <Axman6> anj: we're not going to do all your homework for you - have you tried anything?
18:42:40 <iqubic> How does one get started with Brick?
18:45:54 <ysangkok> how do i specify build flags for dependencies in a cabal file?
19:27:20 <remexre> is an optimizer a good place for recursion-schemes?
19:27:32 <remexre> like an AST optimizer in a compiler
20:15:30 * hackage franz 0.2.1 - Append-only database  https://hackage.haskell.org/package/franz-0.2.1 (FumiakiKinoshita)
20:26:30 * hackage winery 1.1.3 - A compact, well-typed seralisation format for Haskell values  https://hackage.haskell.org/package/winery-1.1.3 (FumiakiKinoshita)
20:33:30 * hackage servant-jsonrpc 1.0.0 - JSON-RPC messages and endpoints  https://hackage.haskell.org/package/servant-jsonrpc-1.0.0 (IanShipman)
20:34:30 * hackage servant-jsonrpc-client 1.0.0, servant-jsonrpc-server 1.0.0 (IanShipman): https://qbin.io/smoke-marina-9slv
21:07:59 <jle`> remexre: i think it's tricky, because recursion-schemes often works best when you have a clear picture of some operation you want to do, but optimization can be a hairy messy beast
21:08:35 <jle`> remexre: i say, there's no downside to just writing your type recursively and auto-generating the pre-fixed functor using recursion-schemes TH, writing your explicit recursion, and then seeing if you can state it in terms of some recursion scheme afterwards
21:12:26 <dmwit> chesscipher: `cabal install stack` *is* how you compile stack.
21:12:42 <remexre> jle`: I guess my "clear picture" is, I want to apply some Expr -> Expr rewrites everywhere they apply in the tree, and then compute the fixed point of doing soo
21:12:55 <dmwit> chesscipher: The real error for "...failed during the building phase. The exception was: ExitFailure 1" will be higher up in the output.
21:13:12 <dmwit> chesscipher: Most likely some kind of missing C library dependency or similar.
21:13:56 <jle`> remexre: do you already have the Expr -> Expr ready and written?
21:14:09 <remexre> I've got a half-dozen of them
21:14:11 <jle`> this is what i mean
21:14:13 <dmwit> iqubic: Have you tried reading the fine documentation?
21:14:43 <Axman6> oh oh, I know this one!
21:15:47 <remexre> jle`: Like, most of these optimizations are part of constant evaluation, and are fairly trivial; I want to interleave some of the ones that reduce AST size by a lot with the constant evaluation
21:15:59 <jle`> remexre: ah, ok. then yeah i think it might make sense to leverage recurscion-schemes to help
21:16:00 * hackage dhall 1.26.1 - A configuration language guaranteed to terminate  https://hackage.haskell.org/package/dhall-1.26.1 (GabrielGonzalez)
21:16:35 <jle`> hm, i'm not sure exactly what that would look like
21:16:40 <remexre> jle`: Okay, is there a better way to learn them than rereading Bananas, ... for the (n+1)th time? Didn't stick the previous n>=3...
21:18:27 <jle`> hm. i think actually the easiest way might not be with rec-schemes, but maybe plated-like techniques
21:19:17 <jle`> https://hackage.haskell.org/package/uniplate-1.6.12/docs/Data-Generics-Uniplate-Operations.html
21:19:46 <jle`> in particular 'transform' would do that sort of 'replace everything frmo the bototm up' you are thinking of
21:19:56 <jle`> transform :: (Expr -> Expr) -> (Expr -> Expr), in your case
21:20:08 <remexre> huh, okay, I'll look at this; thanks!
21:20:09 <ski> @where uniplate
21:20:09 <lambdabot> <https://www.haskell.org/haskellwiki/Uniplate>,<https://hackage.haskell.org/package/uniplate>,<http://community.haskell.org/~ndm/uniplate/>,<http://community.haskell.org/~ndm/darcs/uniplate/uniplate.
21:20:09 <lambdabot> htm>,<https://github.com/ndmitchell/uniplate>,<https://ndmitchell.com/#uniplate_09_oct_2013>,<http://www-users.cs.york.ac.uk/~ndm/uniplate/>
21:20:33 <jle`> or you can even use transformM, rewriteM, etc. with Writer that tells an 'Any True' if you ever fire an optimization
21:20:45 <jle`> then you can run it repeatedly until the writer log returns False
21:21:40 <remexre> okay, I'll try that
21:21:48 * ski ( fixed-point iteration )
21:21:49 <jle`> i think you could do something similar with cata from recursion-schemes. but using this makes more sense to me because this is one of the examples uniplate is always using
21:22:15 <remexre> though I guess my control-flow here kind of wants gotos, heh; if any stage does rewrites I wanna rerun the previous ones
21:22:37 <jle`> that sounds like something more complex than just running Expr -> Expr's :P
21:22:54 <remexre> each Expr->Expr is one stage
21:23:26 <remexre> the AST I'm getting ends up having lots of terms that can be more intelligently rewritten than constant-folding alone would do
21:24:16 <ski> remexre : rerun from start, or rerun previous one (backtracking, sortof) ?
21:24:18 <jle`> right, these sort of complicated things are what i was talking about earlier
21:24:35 <remexre> ski: probably from the start
21:24:45 <ski> mhm
21:25:09 * ski . o O ( retrying transactions )
21:25:48 <remexre> jle`: I can just do optimizeM :: ErrorT () (State Expr) ()
21:26:15 <remexre> or StateT Expr (Either ()) (); I always forget the way transformers commute
21:26:34 <ski> @unmtl ErrorT () (State Expr) ()
21:26:35 <lambdabot> Expr -> (Either () (), Expr)
21:26:44 <remexre> oh nice
21:26:45 <ski> @unmtl StateT Expr (Either ()) ()
21:26:45 <lambdabot> Expr -> Either () ((), Expr)
21:26:48 <remexre> the former
21:26:57 <ysangkok> i remember a project that could find a value for an arbitrary type in haskell
21:27:07 <ysangkok> does somebody remember what the project was called?
21:27:16 <ski> hm, so keep state, in case of exception
21:27:21 <heatsink> djinn?
21:27:31 <ski> @where djinn
21:27:31 <lambdabot> darcs get http://darcs.augustsson.net/Darcs/Djinn
21:27:48 <remexre> ski: yeah, where an exception == "I did an optimization"
21:27:52 <ski> @djinn (a -> b) -> ((a -> o) -> o) -> ((b -> o) -> o)
21:27:52 <lambdabot> f a b c = b (\ d -> c (a d))
21:27:53 <ysangkok> heatsink: ah yes, thanks!
21:27:56 <ski> remexre : right-o
21:28:06 <remexre> and just rerun it in a State Expr () until it passes
21:28:16 <iqubic> ski: That's just fmap on (Cont o)
21:28:25 <ski> @djinn-add type NotNot a = Not (Not a)
21:28:28 <ski> yes, iqubic
21:28:43 <ski> @djinn Not (Either a b) -> (Not a,Not b)
21:28:44 <lambdabot> f a = (\ b -> a (Left b), \ c -> a (Right c))
21:28:49 <iqubic> Cont s great
21:29:01 <iqubic> It's the Mother of All Monads.
21:29:12 <EvanR> no that's free monad
21:29:19 <iqubic> Really?
21:29:33 <EvanR> and the father is Wadler
21:29:37 * ski . o O ( someone's been reading sigfpe )
21:30:14 <ski> and Moggi is the father of the bride ?
21:30:24 <EvanR> which part suggests sigfpe
21:30:31 <ski> "Mother of All Monads"
21:31:01 <EvanR> and the godfather is Leibniz
21:31:12 <iqubic> I did just read this: http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
21:31:13 <ski> <http://blog.sigfpe.com/2008/12/mother-of-all-monads.html> by sigfpe aka dpiponi
21:31:43 <ski> (dpiponi was in here, at some point)
21:32:32 * ski points iqubic in the general direction of Andzej Filinski, and his represented monads
21:32:51 <ski> s/Andzej/Andrzej/
21:33:15 <heatsink> @djinn (forall a b. f a -> f b) -> (a -> b) -> (b -> c) -> f a -> f c
21:33:15 <lambdabot> -- f cannot be realized.
21:34:10 <iqubic> ski: Got a link, or shall I just google for it?
21:34:19 <ski> djinn doesn't understand higher-rank
21:34:35 <heatsink> ah.
21:34:38 <iqubic> Can we teach it?
21:34:51 <ski> iqubic : <http://hjemmesider.diku.dk/~andrzej/papers/>
21:35:21 <ski> "Representing Monads" in 1994-01, and "Representing Layered Monads" in 1999-01
21:35:43 <iqubic> I'll read those when I have a moment. It's 10:30 PM here.
21:36:14 <ski> iqubic : also "Fun with Linear Implicit Parameters" by TheHunter (Thomas Jäger) in 2005-05 at <https://wiki.haskell.org/The_Monad.Reader/Issue2/FunWithLinearImplicitParameters>
21:36:21 * ski misses TheHunter :/
21:36:43 <ski> (they disappeared, without a trace ..)
21:37:22 <iqubic> And I have class early in the morning
21:38:34 <ski> iqubic : oh, also "Abstracting Control" by Olivier Danvy,Andrzej Filinski in 1990-06 and "Representing Control: A Study of the CPS Transformation" by ditto in 1992-01 are worth to check out, imgo
21:38:39 <ski> s/imgo/imgo/
21:38:41 <ski> argh
21:38:43 <ski> s/imgo/imho/
21:38:57 <ski> iqubic : that's where i better learned CPS, from ..
21:39:22 <ski> (still on Filinski's page, above)
21:40:07 <iqubic> Do I want the DVI version or the PostScript version?
21:40:19 <ski> i picked PS
21:40:29 <iqubic> how do I view the content of a PS file?
21:40:44 <ski> try a PDF viewer ?
21:40:53 <ski> or `gv' or something like that
21:42:04 <ski> (there is apparently also a program `dvipdf' which you could try, to convert DVI to PDF)
21:42:05 <iqubic> First I need to remember how to extract something from a .gz file.
21:42:09 <ski> `gunzip'
21:42:27 <ski> `gunzip blah.ps.gz'
21:43:07 * ski recalls downloading more papers in PS format, than in PDF format, those days
21:43:49 <iqubic> I don't have a good pdf viewer.
21:44:28 <heatsink> There's a ps2pdf program
21:44:37 <heatsink> Oh, nevermind
21:45:19 * ski idly wonders how iqubic usually displays papers
21:45:30 <iqubic> ski: What program do you use to disply papers?
21:45:38 <ski> `gv', usually
21:45:43 <iqubic> I just use firefox.
21:45:48 <ski> sometimes `xpdf', or `evince' if i have to
21:48:06 <iqubic> Installing gv now.
21:50:54 <enikar> zathura and okular know how read ps, iirc
21:54:19 <EvanR> ski: i like the random 2008 era edk comment "you can view codensity monad as the right kan extension of a functor along itself"
21:54:35 <ski> on dpiponi's blag ?
21:54:44 <EvanR> yeah
21:54:55 * ski didn't look at it, in awhile
21:55:04 <sclv> that's in maclane iirc
21:55:43 <ski> yea, i think so
21:56:00 <ski> (i suspect that's where ed first got those terms ?)
21:57:07 <EvanR> so codensity is basically a tricked out continuation monad which can be used to do free-like stuff
21:57:40 <iqubic> I suspect so.
21:57:55 <EvanR> the fun never stops around here
21:59:35 <sclv> its sort of a restricted continuation, not a tricked out one
22:01:03 <EvanR> nice, 2016 phil wadler left a comment
22:01:29 <ski> `Yoneda Identity'/`Codensity Identity' enforces CPS. `Codensity m' enforces CPS, upto `m', which is nqCPS. but you can't do "funny things" with the answer / final result type, as you can with `Cont o' & `ContT o m'
22:08:02 <iqubic> So you can't do callCC with the Yoneda or Codensity?
22:08:09 <ski> right
22:09:29 <iqubic> But callCC is awesome.
22:09:46 <ski> you could still apply arbitrary `forall o. m o -> m o' stuff, "directly after" or "at the tail end", though
22:09:56 <ski> `shift'&`reset' is often nicer
22:10:09 <EvanR> Yoneda Identity sounds like a Tom Clancy book
22:10:15 <ski> and monadic reflection, which Filinski talks about in those papers, uses `shift'&`reset'
22:10:53 <ski> (the "layered monads" papers. not the CPS ones)
22:11:43 <ski> monadic reflection turns any user-defined monad into a side-effect, given composable continuation (`shift' & `reset') side-effects
22:12:12 <iqubic> zathura works wonderfull.
22:12:13 <ski> (that's also what that TheHunter article was about)
22:12:24 * ski never heard of `zathura'
22:12:26 <iqubic> how do shift and reset work?
22:12:33 <iqubic> ski: It's a pdf viewer.
22:12:42 * ski figured
22:12:46 <ski> captures partial continuations
22:13:44 <Welkin> it's a weird scifi movie
22:13:56 <iqubic> ski: I have no idea how that works.
22:14:02 <ski> `reset' establishes a delimited. `shift' captures the part of the continuation, upto that delimiter
22:14:39 <iqubic> I still am not understanding
22:14:50 <ski> `1 + reset (10 * shift (\c -> c 2))' is just `21'
22:15:02 <ski> `c' gets bound to `\x -> 10 * x'
22:15:20 <iqubic> I don't see why that is useful ever.
22:15:21 <ski> `1 + reset (10 * shift (\c -> 2))' is just `3', the captured continuation gets deleted
22:15:33 <ski> it's useful for turning internal iteration into external iteration
22:15:41 <iqubic> I see.
22:15:48 <iqubic> So what does reset do there?
22:15:56 <iqubic> And why do you need a call to shift?
22:16:02 <ski> if you have a library exposing a `map' or `forEach' type of operation, you can turn that into a stream of elements, using this
22:16:11 <iqubic> Oh???
22:16:30 <ski> `reset' puts a mark on the stack. `shift' captures (and removes) the part of the continuation, upto that mark
22:16:45 <ski> instead of capturing the whole continuation, you only captures a delimited part of it
22:16:58 <ski> hence : delimited / composable / partial / sub- continuations
22:17:08 <ski> (dear child has many names)
22:17:47 <iqubic> `1 + reset (10 * shift (\c -> c 2))' is just `21'
22:17:54 <iqubic> `c' gets bound to `\x -> 10 * x'
22:18:05 <iqubic> Doesn't the value of c depend on the value of x?
22:18:38 <ski>   1 + reset (10 * shift (\c -> c 2))  =  1 + reset (let c x = 10 * x in c 2)  =  1 + reset (10 * 2)  =  1 + reset 20  = 1 + 20  =  21
22:18:51 <javier_> Is there a more idiomatic way to "reverseMap" a list of functions to a single value than: `reverseMap (f:fs) i = (f i):(reverseMap fs i)` ?
22:19:01 <ski>   1 + reset (10 * shift (\c -> 2))  =  1 + reset (let c x = 10 * x in 2)  =  1 + reset 2  =  1 + 2  =  3
22:19:26 <ski>   1 + reset (10 * shift (\c -> c (c 2)))  =  1 + reset (let c x = 10 * x in c (c 2))  =  1 + reset (10 * (10 * 2))  =  1 + reset 200  = 1 + 200  =  201
22:20:04 <ski>   1 + reset (10 * shift (\c -> 3 + c 2))  =  1 + reset (let c x = 10 * x in 3 + c 2)  =  1 + reset (3 + 10 * 2)  =  1 + reset 23  = 1 + 23  =  24
22:20:59 <ski> with normal continuations (CPS), you can never do "somthing after calling the continuations", that would be nqCPS (not-quite-CPS, where not quite every call is a tail call)
22:21:36 <ski> all these examples are in a hypothetical language with `shift'&`reset' side-effects
22:21:43 <ski> (e.g. Scheme, or SML/NJ)
22:22:38 <ski> (also there's an efficient implementation for O'Caml. it would be interesting if there'd be special support in GHC for this type of thing. might make using monads sometimes more efficient, less "interpretative overhead" ?)
22:22:53 <EvanR> the reset remained until the end... so whatever effect it had must have been acausal :)
22:23:27 <ski> yea, `reset' disappears once you have a value inside (no `shift'-effects left)
22:24:11 <ski> consider using `((ma >>= amb) >>= bmc) >>= cmd' with `Either Integer' .. if `ma' is `Left n', then `ma >>= amb', gives `Left n'. then the next `(>>=)' check again, and percolates the failure, upwards, step-by-step
22:24:56 <ski> with monadic reflection (and also with `Codensity (Either Integer)'), you just "jump ahead to the next exception handler", skipping the intermediate layers
22:25:33 <EvanR> with exception heavy code i can see that mattering
22:26:10 <EvanR> (which is an apparent contradiction in terms)
22:26:21 <EvanR> you'd have to rename exceptions to rules
22:26:36 <ski> (note how `((ma >>= amb) >>= bmc) >>= cmd' is similar to `((as0 ++ as1) ++ as2) ++ as3'. no coincidence. same basic problem. this also happens with expression monads, getting `O(n^2)', rather than expected `O(n)')
22:26:50 <iqubic> Yes. That makes sense.
22:27:16 <ski> (and you saw expression monads, the other day)
22:27:16 <iqubic> ski: List are a monad.
22:27:22 <iqubic> I did indeed.
22:27:35 <iqubic> They are really cool.
22:28:08 <EvanR> ok, for a minute i tough `amb' was about to be something else
22:28:13 <iqubic> no.
22:28:26 <michaelb_> Hi, I'm doing https://www.cis.upenn.edu/~cis194/spring13/lectures.html in roder to learn Haskell. And I'm about to do homework 7, and there I should run `runhaskell StringBufEditor.hs`, but I get the following error https://pastebin.com/jy4YBDsP
22:28:27 <iqubic> amb :: a -> mb
22:28:40 <iqubic> bmc :: b -> m c
22:28:45 <ski> `((expr >>= subst0) >>= subst1) >>= subst2' will traverse to the leaves of `expr', applying `subst0', then retraverse again to the leaves (from the root), applying `subst1', and so on
22:28:46 <iqubic> * m b
22:28:52 <iqubic> Yes it will.
22:28:57 <ski> (just like `((as0 ++ as1) ++ as2) ++ as3' does, with appending)
22:28:57 <iqubic> That's true.
22:29:04 <michaelb_> It gives me a hint on how to resolve it, but I'm not sure how to do it. Could someone help me to just get it running?
22:29:04 <iqubic> What's the point of all of this/
22:29:28 <heatsink>  michaelb_: Add Applicative to the list of deriving classes that's shown in the error message
22:29:44 <EvanR> that continuations let you skip sections of "useless" computation
22:29:57 <ski> `expr >>= \x0 -> subst0 x0 >>= \x1 -> subst x1 >>= subst2', otoh, continues applying `subst1' at the leaves of the newly grafted subtrees, without retraversing from the root all over again
22:30:28 <michaelb_> Oh, that was easy. Thanks heatsink! :)
22:30:29 <ski> and `Codensity Expr', and also monadic reflection, achieves this, automatically, from `((ma >>= amb) >>= bmc) >>= cmd'
22:30:57 <iqubic> What is Codensity again?
22:31:25 <ski>   newtype Codensity m a = MkCodensity (forall o. (a -> m o) -> m o)
22:31:27 <EvanR> it sounds pretty amazing
22:31:47 <iqubic> Right.
22:31:48 <ski> it's similar to diff-lists, for list appending
22:31:49 <iqubic> That
22:31:56 <iqubic> oh? How so?
22:32:01 <EvanR> if it had a name like FuzzyBunnies it might be more popular
22:32:09 <ski> where we use `newtype DiffList a = MkDL ([a] -> [a])'
22:32:23 <iqubic> Right.
22:32:42 <ski> the input "tail list" of type `[a]' is basically a "continuation", just like the one above, of type `a -> m o'
22:33:48 <iqubic> sure.
22:33:49 <ski> (this is also related to Cayley's theorem for representing groups (and also rings, iiuc ?) in algebra, in some way, iiuc .. i haven't really grokked that yet, though. probably related to something yonedaish)
22:33:53 <iqubic> I'd buy that.
22:35:06 * ski heard SPJ (?) mention it, at some talk
22:37:24 <iqubic> Lamdba World 2020 in Seattle looks really interesting.
22:37:40 <iqubic> I live in Seattle, so I'm thinking I'd like to go.
22:38:10 <EvanR> all these computer science ideas... i feel like it's a repeat of electromagnetic science. 1980s all this stuff was known. 1880s electromagnetic science was known. 2019 we are barely using any of it. 1919 electromagnetic technology was in relative infancy
22:39:31 * ski would also like to better understand polynomial monads
22:39:33 <EvanR> maybe in 2119 codensity will be taken for granted
22:40:34 <ski> (you know, like an expression monad, except you add the usual algebraic laws of polynomials, such as commutativity of addition, and distributivity. "monadic results" are the variables/unknowns of the polynomials, just as for expression monads)
22:41:13 <ski> (and bind is substituting in other polynomials, for the variables/unknown, in one .. what is `liftA2' ?)
22:42:54 <ski> (it's not a commutative monad, in any case .. there's two ways of representing polynomials, one is as an evaluation function, the other is as a "list" of coefficients)
22:43:45 <Nevoic> Why is the implementation of `readMaybe` *always* Read a => String -> Maybe a?
22:44:04 <Nevoic> I've tried 2 or 3 custom preludes that do that. Relude specifically says **forget** String.
22:44:07 <Nevoic> And then they have that function.
22:44:18 <iqubic> Because that's what the type signature dictates.
22:44:22 <ski> s/implementation/signature/ ?
22:44:32 <Nevoic> Yeah, signature.
22:44:51 <EvanR> ski: what's pure
22:45:04 <Nevoic> I'm asking why Preludes that say things like "forget String" and "we never use String" export a function explicitly that isn't in the Prelude that uses String.
22:45:24 <Nevoic> In protolude they had a similar function, and they actually removed the ability to return `String` from a function (that's how against String they were)
22:45:29 <Nevoic> So I literally could not use the function.
22:45:55 <Nevoic> I tried passing in a `IsString a => a` and then `show`ing it, but I got ambiguous type errors because it wasn't a concrete type.
22:46:22 <Nevoic> so I must just be missing something crucial about `Read` in general, and why it can't parse Text or any of the other 4 kinds of non-String strings.
22:47:20 <Nevoic> by "removed the ability to return `String`" I mean the Prelude stopped exporting `String`. You had to either use `[Char]` or reimport it manually.
22:47:26 <ski> EvanR : `pure x' is the polynomial `0 + 1 * x'
22:47:36 <EvanR> k
22:48:03 <ski> (zero constant term, coefficient `1' on the term with just one `x', not other indeterminates. zero on all other terms)
22:48:55 <Nevoic> ClassyPrelude didn't have this problem with `readMay`, but their type classes got confusing as hell. The inference algorithm would convert what was a simple polymorphic type with a single constraint in another prelude to a type with literally 5 constraints on it.
22:49:15 <Nevoic> And I'm just like na bro I aint having that so I've been trying other Preludes and am blown away by the `readMaybe` idiom.
22:49:33 <EvanR> removing the String synonym is a pretty decisive and undestructive way to begin the rehabilitation process for 'strings'
22:49:54 <Nevoic> Sure, that may be something I agree with. I wasn't advocating for them to do it.
22:50:11 <Nevoic> I was simply saying that a prelude that is **that** against Strings still had a function `readMaybe :: Read a => String -> a`
22:50:15 <Nevoic> and that was just absolutely mind boggling.
22:50:32 <Nevoic> especially since it wasn't a one off occurrence. It's common across multiple custom preludes.
22:50:33 <EvanR> did they also have read :: Read a => String a
22:50:40 <EvanR> String -> a
22:50:46 <Nevoic> no, they removed `read`.
22:50:54 <EvanR> well that seems like an oversight
22:51:05 <Nevoic> I'm talking about Relude specifically rn.
22:51:15 <int-e> what about the defining methods of the Read class, readsPrec readList
22:51:36 <ski> `readsPrec' is the normal way to make an instance of `Read'
22:51:40 <int-e> (I imagine "deriving Read" is something you think very hard about giving up)
22:51:55 <Nevoic> Point five in their migration guide, "forget String"
22:52:26 <int-e> (And then you gulp and relent and include Read and a safe way of using it in your own alternative Prelude.)
22:53:36 <int-e> (I expect a similar story for Show)
22:54:28 <EvanR> i like `String' but not String = [Char]
22:54:39 <EvanR> i won't forget
22:55:26 <iqubic> How do you think String should be defined?
22:55:30 <MarcelineVQ> EvanR will remember that.
22:55:57 <Axman6> uint8_t*
22:55:58 * ski idly wonders whether Irssi can be configures to do italics
22:56:17 <Nevoic> strings are still the thing I hate the most about Haskell. Pretty much the entire rest of the language is something I enjoy, but that alone is nearly enough to drive me away.
22:57:09 <Nevoic> I'm doing exactly the same kind of web development I do in other languages (Rust, Python, Kotlin, Java, Ruby, probably a few others as well) and for some reason I never ran into more than one String type.
22:57:12 <EvanR> string is clearly a primitive concept on the order of "sets in set theory". If you gotta ask you'll never know. You know one when you see one
22:57:36 <EvanR> (just kidding)
22:57:44 <Nevoic> I know other languages have multiple strings, but I never encountered them in the wild. My only exposure to them is through this chat saying "well they exist in other languages too"
22:57:52 <Axman6> String actually does an extremely good job of dealing with unicode, much better than most other languages (though not so much with some of the mor modern features which require multiple code points per glyph)
22:58:30 <EvanR> many languages also don't have multiple number types, or container types
22:58:43 <ski> @quote stark
22:58:43 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
22:58:48 <Nevoic> I never had issues expressing unicode on any JVM language, I've sent unicode messages to Discord through Kotlin and Java (haven't tried Scala, but I'd be surprised if they had an issue).
22:59:12 <Nevoic> I've never had any unicode issues in other languages, but I don't remember explicitly messing around with emojis or some weird non-ASCII character.
22:59:46 <EvanR> i definitely appreciate a difference between ByteString and strings
23:00:21 <Nevoic> I think String, strict Text, lazy Text, strict ByteString, and lazy ByteString are simply too much to manage, compared to the 1 string type I've experienced everywhere else.
23:00:21 <iqubic> What is a ByteString?
23:00:21 <Axman6> String is a pretty sillyu thing to consider not using Haskell for, since it's never used for heavy lifting in real apps. the distinction between ByteString and Text is an important and useful one
23:00:31 <Nevoic> It's too bad I like everything else about this language lol
23:00:42 <Axman6> I never end up using lazy text
23:01:18 <EvanR> oh there's plenty else to not like besides String
23:01:27 <EvanR> don't worry about that
23:02:50 <monochrom> I agree about the number types parallel.
23:03:54 <monochrom> If I step into ##c do I hear someone say "I like every other aspects of C but {unsigned, signed} x {char, short, int, long, long long} + {float, double, long double} are too much"?
23:04:25 <monochrom> "plus you never know for sure whether 'char' unqualified is signed or unsigned"
23:05:29 <monochrom> "I have been using Javascript at work and it just has one single number type to worry about, I don't need C's options"
23:06:25 <monochrom> "Actually I have been using Bourne shell at work and it unifies the string type and the number type too"
23:09:02 <EvanR> strings = numbers is a real idea, ime. After all, how do you know what number you have without knowing what base it's written in!
23:10:44 <EvanR> the fact is somehow we've been finding ways to work with 1 string and 1 number... miraculous
23:11:14 <EvanR> and PHP 1 container
23:11:33 <iqubic> I prefer to work in Base 32
23:11:38 <EvanR> not even javascripts wealth of 2 containers
23:11:48 <iqubic> no actually I prefer Base 36.
23:12:11 <iqubic> Everytime I get a string, I convert it from a base 36 number to a binary number.
23:13:00 * hackage hw-uri 0.1.1.5 - Supports IO on URIs  https://hackage.haskell.org/package/hw-uri-0.1.1.5 (haskellworks)
23:13:33 <EvanR> 12-bit bytes do seem kind of cool in theory
23:13:55 <iqubic> Why would you want those?
23:14:00 * ski . o O ( "If you add a base `m' number and a base `n' number, how do you know what base the sum will end up in ?" )
23:14:14 <monochrom> m+n :)
23:14:22 <EvanR> lcm m n
23:14:38 <iqubic> Answer, take the floor of the average of m and n
23:14:57 <monochrom> Also, teacher's fraction arithmetic: x/m + y/n = (x+y)/(m+n) because adding marks. >:)
23:14:57 <MarcelineVQ> base p :>
23:15:32 <iqubic> No. No. No. That's not how fractions work.
23:15:44 <EvanR> sqrt(a + b) = sqrt(a) + sqrt(b)
23:15:49 <jle`> looks good to me
23:15:57 <iqubic> Again... That's not how that works.
23:16:05 <monochrom> You don't get the joke?
23:16:11 <jle`> (a+b)^2 = a^2 + b^2
23:16:13 <glguy> Wow that is easier than I remembered
23:16:21 <jle`> ^ true if either a or b is zero
23:16:27 <iqubic> Yes.
23:16:34 <iqubic> true if both are 0.
23:16:38 <EvanR> or if 2 is zero
23:16:49 <jle`> yes, both being zero falls under either being zero
23:16:54 <glguy> Aren't they always zero? Wouldn't it be harder if they weren't?
23:17:06 <jle`> yeah, who works with numbers that aren't zero anyway
23:17:12 <jle`> sounds like a hassle
23:17:24 <monochrom> I do.
23:17:28 <monochrom> I work with 0 and i.
23:17:35 <iqubic> i?
23:17:37 <glguy> And me
23:17:38 <jle`> too risky. what happens if you square i
23:17:43 <jle`> then you're back to square 1
23:17:46 <jle`> or hm
23:17:48 <monochrom> hahahaha
23:18:03 <iqubic> jle`: Negative on the square 1 thing.
23:18:10 <glguy> Err, and myself :)
23:18:21 <monochrom> "back" accounts for the minus, don't worry >:)
23:18:41 <monochrom> (I rescused your joke. You owe me a wine or someting!)
23:18:51 <jle`> i set the joke up for your recusal
23:19:10 <jle`> but i'll still offer wine
23:19:17 <jle`> :)
23:19:48 <EvanR> iqubic: well, 12 fits into 36 in case you needed a 36-bit word. And if you don't need the extra 4 bits for value, it could be used for flags
23:20:24 <iqubic> I see.
23:20:28 <monochrom> Yeah how about a number type that has a couple of parity bits? >:)
23:20:58 * ski offers a whine
23:21:47 * ski multiplies a number ⌜a⌝ in ⌜ℤ ⁄ (m ⋅ ℤ)⌝, with a number ⌜b⌝ in ⌜ℤ ⁄ (n ⋅ ℤ)⌝, gets a number ⌜a⋅b⌝ in ⌜ℤ ⁄ (gcd {m⋅b,a⋅n,m⋅n} ⋅ ℤ)⌝
23:23:06 <EvanR> tensor product of numbers
23:23:34 <ski> (now, to figure out how to do heterogenous division ..)
23:24:00 <EvanR> it's just repeated subtraction
23:24:17 <ski> yes, but the types, man !
23:24:32 * ski . o O ( Won't anyone think of the types !? )
23:25:18 <iqubic> I will.
23:25:21 <iqubic> I always do.
23:25:47 <EvanR> i want a division theorem to reverse putting a and b into (a,b)
23:26:24 * ski . o O ( <https://homepages.inf.ed.ac.uk/wadler/gj/> (bottom of page) )
23:26:53 <ski> well, ⌜gcd⌝ is idempotent, so tough luck ..
23:28:06 * ski idly ponders how division in relational algebra is an adjoint
23:29:54 <monochrom> I thought the premise of less static check and less testing was "after you ship, you take the money and disappear, no one can make you fix bugs found after"
23:32:00 <jle`> "if it typechecks, ship it" - typechecking = "ship it"
23:32:21 <jle`> life without a typechecker seems so much simpler
23:33:20 * ski idly wonders whether that subtraction is also an adjoint
23:33:28 <monochrom> haha
23:41:00 * hackage schemas 0.1.0.0 - schema guided serialization  https://hackage.haskell.org/package/schemas-0.1.0.0 (PepeIborra)
23:46:00 * hackage emd 0.1.7.0 - Empirical Mode Decomposition and Hilbert-Huang Transform  https://hackage.haskell.org/package/emd-0.1.7.0 (jle)
23:47:34 <dminuoso> ski: So after pondering a while, I think ⌜do { !(~(Just x)) <- f }⌝ should incur a MonadFail constraint because the pattern is failable.
23:48:34 <ski> how's it failable ?
23:49:47 <jle`> > case Nothing of !(~(Just x)) -> x; _ -> "never"
23:49:49 <lambdabot>  "*Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in Just x
23:49:53 <jle`> ^ it's not failable
23:50:12 <dminuoso> Uhh. Huh.
23:50:17 <dminuoso> What just happened there
23:50:55 <jle`> i think roughtly it's sugar for case Nothing of ~(JUst x) -> Just x `seq` x; _ -> "never"
23:50:59 <ski> we strictly match `Nothing' to `~(Just x)', iow we lazily match `Nothing' to `Just x', iow only matching `Nothing' to `x', when `x' is forced
23:51:00 <jle`> so it's still a lazy pattern match
23:51:23 <dminuoso> ! is truly magic.
23:51:35 <jle`> the way i presented it made it clearly non-magical i feel
23:51:52 <jle`> since it's just a mechanical transformation to 'desugar'
23:51:54 <dminuoso> jle`: My point is just that this is very non-obvious.
23:52:12 <dminuoso> But I suppose I understand your point.
23:52:30 <jle`> i think the only reason this might have surprised someone is that you might think that ! and ~ are opposites, and so they cancel each other out
23:52:35 <jle`> but actually they do somewhat distinct things
23:52:39 <dminuoso> Yeah indeed.
23:52:43 <jle`> so they can work together no problem
23:52:51 <int-e> ski: irssi supports italics (%I format string) but getting tmux to support italics is hard (https://medium.com/@dubistkomisch/how-to-actually-get-italics-and-true-colour-to-work-in-iterm-tmux-vim-9ebe55ebc2be) and for screen it's apparently impossible?!
23:52:55 <ski> yea, i suppose the `!' also forces `Nothing' (before committing to that branch)
23:53:00 * hackage hw-uri 0.1.1.6 - Supports IO on URIs  https://hackage.haskell.org/package/hw-uri-0.1.1.6 (haskellworks)
23:53:09 <jle`> they both behave in well-defined and observable ways that are mechanical to work out
23:53:13 <dminuoso> Perhaps the interaction is strange, because it seems a silly thing to strictly pattern match an irrefutable pattern.
23:53:31 <jle`> and you can work it out directly locally without worrying about anything else in the system
23:53:41 <dminuoso> Though I suppose in the more general sense you rae right
23:53:51 <jle`> 'strictly pattern match' isn't what ! does
23:53:56 <dminuoso> `f !x = ...` is not much different really
23:53:57 <jle`> pattern matches are normally strict already
23:54:08 <jle`> dminuoso: it's the same pretty much
23:54:15 <jle`> ! doesn't mean strict pattern match
23:54:26 <jle`> in fact using ! on the outer layer of a pattern is sort of redundant
23:54:26 <dminuoso> right
23:55:04 <jle`> so ~ affects pattern matching, but ! affects evaluation -- they're different and unrelated things
23:55:43 <dminuoso> jle`: Well to some degree they are related, because by making a pattern irrefutable, you change strictness.
23:55:51 <jle`> yeah, incidentally i suppose
23:55:55 <jle`> and indirectly
23:56:02 <ski> int-e : i suppose one might tweak `sitm' and `ritm' for `screen.xterm*' to use DCS in Screen to directly control outer terminal ?
23:59:23 <jle`> > case Nothing of !(~(Just x)) -> (); _ -> "never"
23:59:26 <lambdabot>  error:
23:59:26 <lambdabot>      • Couldn't match expected type ‘()’ with actual type ‘[Char]’
23:59:26 <lambdabot>      • In the expression: "never"
23:59:26 <jle`> oops
23:59:31 <jle`> > case Nothing of !(~(Just x)) -> "sometimes"; _ -> "never"
23:59:33 <lambdabot>  "sometimes"
23:59:39 <iqubic> What?!?!
23:59:43 <dminuoso> jle`: Heh, I did the *exact* same thing with the exact mistake in a pm too.
23:59:53 <jle`> the dangers of copy and paste, heh
