00:00:51 <jusss> EvanR: what's wrong with it?
00:46:02 <dotKuro> :q
00:46:19 <u-ou> $
01:19:00 * hackage gamgee 1.2.0 - Tool for generating TOTP MFA tokens.  https://hackage.haskell.org/package/gamgee-1.2.0 (rkaippully)
02:08:48 <edward_> Hey all! I'm playing around with Haskell at work for some repetitive tasks and it's been going surprisingly well! I'm a bit stuck on something now though. I'm trying to process a text file and pass each line to a function which uses it in a get request (checking for equality between a new and old API endpoint). I'm tangled up in error messages at the moment and was wondering if someone could point out my why/where I'm 
02:08:48 <edward_> going wrong? https://pastebin.com/Xnzdebvu 
02:10:30 <merijn> Char8 *hiss*
02:11:14 <merijn> edward_: It would probably help to give some hint as to what error messages are the issue ;)
02:11:52 <edward_> Sure, I thought it might be something obvious with how I'm calling the function. I'll put the errors into another pastebin file quickly. 
02:12:24 <c_wraith> you probably want mapM_ instead of map
02:12:41 <c_wraith> also, you probably should have a type on checkEquality
02:12:48 <merijn> edward_: Incidentally, you probably want to get rid of readFile on line 12 and stop using String for "serious" work
02:13:01 <merijn> edward_: String is a god awful type if you want some form of performance
02:13:13 <earthy> it *is* easy though.
02:13:28 <merijn> earthy: Text isn't significantly harder, though :)
02:13:31 <edward_> What would you suggest using instead of String? 
02:13:33 <edward_> Text?
02:13:39 <merijn> edward_: Text, definitely
02:13:45 <c_wraith> Text is a lot harder :P
02:13:59 <merijn> edward_: Basically: String may take up to 24 bytes *per character* for your data
02:14:10 <earthy> yeah, do the damn import and use Text. Unless what you're really after is bytestrings.
02:14:24 <merijn> edward_: Text will average 2-3 bytes per character (plus some overhead every few kilobyte..)
02:14:28 <c_wraith> You mean the two imports and spamming "T." everywhere in your code?
02:14:43 <earthy> c_wraith: I didn't say it was pretty
02:14:55 <merijn> earthy: I think he's being sarcastic ;)
02:14:59 <earthy> ;)
02:15:15 <c_wraith> Actually, I'm not sarcastic.  qualified names are *terrible*
02:15:25 <merijn> edward_: Don't even have to change much, just use Data.Text.IO.readFile instead of readFile and Data.Text.lines instead of lines
02:16:07 <merijn> c_wraith: Don't look at Henning Thielemann's packages, then >.>
02:16:16 <c_wraith> I looked at them once.
02:16:48 <merijn> tbh, over time I've come to appreciate qualified names a bit more, but you need to find a system that works for yourself
02:17:32 <merijn> edward_: Text also gives you Data.Text.Encoding for converting between Text and ByteString *properly* instead of the atrocity that is Char8 :)
02:18:41 <c_wraith> edward_: there are also things like lines 20 and 24 are going to parse differently than you mean
02:18:42 <merijn> c_wraith: Depending on how large is input is I might even consider not even bothering with mapM_ and going straight for conduit, but that does add some complexity, so it depends on the problem size whether it's worth it for a beginner :)
02:19:05 <edward_> It's going to be maybe 20k lines max? 
02:19:08 <edward_> Nothing big
02:19:11 <merijn> c_wraith: oh, nice catch
02:19:22 <edward_> 150k if I did the entire test set 
02:19:42 <edward_> but I won't need to do that I don't think
02:19:47 <merijn> edward_: conduit will basically let you "stream" the file one line at a time so you get relatively constant memory usage (instead of loading the entire file into memory)
02:20:08 <merijn> edward_: Should be relatively easy to retrofit once you fix the naive version, though. So maybe don't make things to complex for now :)
02:20:15 <edward_> so happy to suffer performance issues for clarity (I normally write Python/C# so this is my first time of writing Haskell outside of Euler problems)
02:20:46 <merijn> edward_: I find that Haskell gets...unrepresentatively ugly for Project Euler :)
02:21:36 <merijn> edward_: conduit is pretty easy to read, but it does mean reading a bunch more docs instead of finishing the first version, so put it on your todo list for later :)
02:21:43 <c_wraith> you certainly use fromIntegral way more in project euler than real code
02:22:14 <merijn> c_wraith: project euler always hyper focuses you on the numeric hierarchy which is just objectively one of the most ugly corners of haskell around
02:22:58 <c_wraith> It's not a problem most of the time.  It just doesn't let you get sloppy with numeric types the way C-derived languages do, and the way some programming problems expect
02:23:03 <merijn> edward_: Anyway, I think c_wraith nailed it in the problem being "map" instead of "mapM_" and lines 20-24 not parsing as you expect.
02:23:15 <merijn> c_wraith: Hah...it totally encourages being sloppy with numeric types
02:23:52 <merijn> c_wraith: Evidence: see the time I submitted a numeric related fix to the RTS, reviewed by several people and the first 2 committed patches *still* managed to be wrong >.>
02:24:00 <c_wraith> ouch
02:24:31 <merijn> c_wraith: The current version has more comments arguing it's correctness than code in the final patch :p
02:24:48 <c_wraith> that's straight C, not C--, right?
02:24:55 <edward_> So thinking about my issue, the problem is going from a list of strings, passing it to a function, and concatenating it to another string. The API code works when I manually enter the full URL. I'll give it another go and come back if it goes horribly. I will take the Data.Text comments on board for later :) 
02:25:02 <merijn> c_wraith: No, the Haskell code of the RTS :)
02:25:08 <c_wraith> Oh!
02:25:11 <c_wraith> wow, ok
02:25:15 <edward_> Thanks! 
02:25:39 <merijn> edward_: I also recommend adding a type signature for checkEquality as c_wraith suggested
02:26:04 <merijn> edward_: Note that function application *always* binds tighter than operators do when you write stuff like: parseRequest "http://api_path.com/apiv1/summary/" ++ x
02:26:20 <merijn> edward_: So that ends up as (parseRequest "http://api_path.com/apiv1/summary/") ++ x
02:26:25 <merijn> Which is probably not what you meant
02:27:01 <edward_> Ah!
02:27:06 <edward_> Good point, thank you
02:32:54 <edward_> merijn: You were right about the function application binding tighter than I expected, making that one change stopped all but one error which is the map. https://pastebin.com/Mae0qQ0E
02:33:03 <edward_> Lesson learnt! :P 
02:34:02 <merijn> edward_: The map one is also pretty straightforward, checkEquality is something like "String -> IO ()"
02:34:11 <merijn> :t map `asAppliedTo` putStrLn
02:34:12 <lambdabot> (String -> IO ()) -> [String] -> [IO ()]
02:34:25 <merijn> :t mapM_ `asAppliedTo` putStrLn -- <- probably what you want
02:34:26 <lambdabot> Foldable t => (String -> IO ()) -> t String -> IO ()
02:38:36 <merijn> Heh, you could probably turn this into a constant memory streaming version in about 3-4 lines (including imports) and another 2-3 to parallelise your http requests :p
02:39:21 <edward_> If you want to put that in a pastebin I'd love to see what you mean, it could be useful if I start working on some of the larger data sets! 
02:43:09 * ski glanced very brifly above, missed a "k"
02:43:34 <c_wraith> heh, I did initially too
02:46:42 <Rembane> Me too. Brain is way too fast.
02:47:43 <merijn> edward_: Using conduit something like: https://paste.debian.net/1100048/
02:48:38 <merijn> I think that's conduit for most things, plus conduit-extra for the text decoding stuff (which also has more decoding options than just utf8)
02:48:58 <merijn> conduit is like a superpower compared to other languages :D
02:52:27 <merijn> edward_: That will incrementally stream data from the file to keep the pipeline going, so you will only have the minimum amount of data required in memory, so that should work for files of any size, even if it's millions of lines. Only "problem" is that checkEquality does HTTP requests (which are slow) and it only runs the function "one element at a time". Which, fortunately for you, is basically the 
02:52:33 <merijn> exact same problem I had at some point, so I wrote: https://hackage.haskell.org/package/broadcast-chan-conduit-0.2.0.2/docs/BroadcastChan-Conduit.html#v:parMapM_ which runs a function (like checkEquality) N times in parallel within your stream
02:54:41 <edward_> That is a lot nicer written than mine :P
02:54:45 <edward_> Happily I got mine to work though :) 
02:54:59 <edward_> mapM_ worked immediately
02:55:25 <edward_> Will need to dive into some docs, but happy to be productive and have finshed a task in Haskell by 11am! :)
03:21:00 * hackage hasbolt-extras 0.0.0.21 - Extras for hasbolt library  https://hackage.haskell.org/package/hasbolt-extras-0.0.0.21 (ozzzzz)
03:34:37 <entel> is there a better way to get the value of fizz?(like maybe an operator): (Foo {fizz}) = (Foo {fizz="hi"})
03:35:51 <lavalike> entel: there're some extensions that help with record access and updates, but a simple way to get fizz out of a Foo is just using the fizz :: Foo -> .. function that is implicitly defined when you define data Foo = Foo { fizz :: ... }
03:37:14 <jgt> worth mentioning also that the convention is for that function to be called unFoo
03:38:20 <lavalike> that's more the case when you're working with newtypes, so Foo goes a direction and unFoo the other, if Foo is a record with multiple data inside you wouldn't call unX unY unZ each of them
03:40:06 <entel> oh right i forgot it automatically defines the fizz function
03:40:14 <entel> sorry im new working my way through learn you a haskell
03:40:21 <entel> its alot to take in all at once
03:40:24 <lavalike> welcome to haskell!
03:40:25 <entel> thanks guys
03:42:52 * ski . o O ( `MkFoo' vs. `unFoo' )
03:43:18 <ski> (sometimes `runFoo',`getFoo',`appFoo')
03:44:18 <c_wraith> unMakeFoo for eldritch horrors
04:38:09 <iqubic> Well, Singletons have me quite confused right now.
04:38:55 <merijn> iqubic: That's the only correct response to singletons
04:40:44 <iqubic> I know.
04:41:09 <fizbin_> Anyone know of a tool to find unnecessary dependencies in one's .cabal file?
04:41:10 <iqubic> Mainly I'm just staring at this error, wondering what the heck is going on here: http://dpaste.com/323XTSY
04:44:14 <iqubic> merijn: Do you know why that error occurs?
04:44:45 <jgt> fizbin_: weeder
04:44:52 <jgt> fizbin_: but I haven't used it
04:45:36 <merijn> iqubic: no, and I'm pretty sure the answer will cost some sanity and involve rituals to elder gods :)
04:46:51 <iqubic> I know.
04:47:23 <iqubic> I'm just trying to prove that 'toSing . fromSing' truely is an isomorphism.
04:47:32 <iqubic> Well, approximately that.
04:54:32 <absence> are there drawbacks to TupleSections?
04:55:10 <merijn> absence: The fact that you'll become increasingly annoyed that no one added them to Haskell2010? >.>
04:57:17 <absence> merijn: ok so nothing technical :)
05:02:15 <Taneb> absence: if you accidentally leave a trailing comman in a long tuple you'll get a different confusing error message to normal
05:04:56 <boxscape> merijn why is that annoying? I can't remember the last time I wrote a .hs file without ghc extensions anyway
05:05:49 <merijn> boxscape: Because it's a trivial thing to have included in the report and one less thing to add at the top
05:06:00 <boxscape> hm, okay
05:06:19 <merijn> Usually things aren't included in the report because standardising is/was too tricky, but that's no excuse here
05:06:19 <Taneb> merijn: maybe it'll be in Haskell-whenever-they-get-a-new-report-out!
05:06:52 <boxscape> iqubic No idea what the problem is but since it complains about an ambiguous type variable maybe you could try adding as many type annotations as possible
05:09:01 * hackage ghcide 0.0.1 - The core of an IDE  https://hackage.haskell.org/package/ghcide-0.0.1 (cocreature)
05:09:12 <palo> I'm seeking information about servant or http-client{,-tls} on how to send client certificates. The keywords would be client-certificate and mtls.
05:15:32 <Fimmind> @pl \size -> replicate size $ replicate size ()
05:15:32 <lambdabot> ap replicate (flip replicate ())
05:52:00 * hackage eventstore 1.3.1 - EventStore TCP Client  https://hackage.haskell.org/package/eventstore-1.3.1 (YorickLaupa)
06:08:00 * hackage ghcide 0.0.2 - The core of an IDE  https://hackage.haskell.org/package/ghcide-0.0.2 (cocreature)
06:12:57 <lavalike> :t join (flip replicate . flip replicate ())
06:12:59 <lambdabot> Int -> [[()]]
06:27:05 <iqubic`> what?!?!
06:28:21 <lavalike> ðŸ˜±
06:31:12 <exarkun> in the context of `stack build --haddock-internal`, what is an "internal module"?
06:35:09 <exarkun> found it in the cabal docs, it's an "unexposed module"
06:35:27 <exarkun> which I guess has to do with `exposed-modules` in the cabal config
07:00:50 <sm[m]> Go ghcide !
07:03:37 <iqubic> I prefer the Emacs package Dante.
07:07:10 <sm[m]> cocreature: whatâ€™s still in haskell-ide-engine thatâ€™s not covered by ghcide + hie-bios ?
07:08:06 <Uniaika> instructions for vim?
07:08:06 <Uniaika> :P
07:08:20 <maralorn> Whatâ€™s ghcide?
07:09:20 <sm[m]> Here you are, you crazy vim user: https://github.com/digital-asset/ghcide#using-with-vimneovim
07:10:20 <maralorn> Oh, itâ€™s a renaming of hie-core.^^ How confusing.
07:10:50 <fendor> sm[m], hsimport support
07:11:48 <sm[m]> maralorn: see comments at https://www.reddit.com/r/haskell/comments/d0frl8/neil_mitchell_making_a_haskell_ide_munihac_2019/
07:14:45 <jumper149> Hi, I just stumbled upon the guard function (:: Alternative f => Bool -> f ())
07:14:56 <maralorn> I mean before I watched that talk I was greatly confused about hie vs. hie-core.
07:15:03 <jumper149> I am not sure why this example doesnt always return the Just value:
07:15:12 <Uniaika> sm[m]: okay fair enough :)
07:15:14 <maralorn> Now people will be greatly confused about ghcid vs. ghcide.
07:15:16 <jumper149> Î»> safeDiv2 x y = guard (y /= 0) >> Just (x `div` y)
07:15:35 <Taneb> > 0 == 0
07:15:37 <lambdabot>  True
07:15:40 <Taneb> > guard (0 == 0) :: Maybe ()
07:15:43 <lambdabot>  Just ()
07:15:47 <Taneb> > guard (0 /= 0) :: Maybe ()
07:15:50 <lambdabot>  Nothing
07:15:53 <Taneb> > Nothing >> Just 1
07:15:55 <lambdabot>  Nothing
07:16:01 <Taneb> jumper149: does that help?
07:16:11 <jumper149> The last one confuses me
07:16:11 <sm[m]> True ;)
07:16:29 <Taneb> jumper149: so, >> is implemented in terms of >>=
07:16:34 <jumper149> I thought >> discards the previous value
07:16:40 <Taneb> > Just 4 >>= \y -> 4 * 9
07:16:42 <lambdabot>  error:
07:16:42 <lambdabot>      â€¢ No instance for (Num (Maybe ())) arising from a use of â€˜e_1449â€™
07:16:42 <lambdabot>      â€¢ In the expression: e_1449
07:16:49 <Taneb> > Just 4 >>= \y -> Just (y * 9)
07:16:52 <lambdabot>  Just 36
07:17:07 <Heffalump> maralorn: no more so than between ghci and ghcid, I'd think
07:17:09 <Taneb> jumper149: what should Nothing >>= \y -> Just (y * 9) be?
07:17:21 <jumper149> Nothing ?
07:17:28 <Taneb> Yes
07:17:42 <Taneb> a >> b is implemented (roughly) as a >>= \_ -> b 
07:18:09 <Taneb> The idea is it discards the value. It doesn't discard the information of whether there was a value or not
07:18:42 <jumper149> On hackage its: m >> k = m >>= \_ -> k 
07:18:47 <maralorn> Heffalump: Fair enough.^^
07:18:53 <sm[m]> ghcidea could be the intellij IDEA plugin
07:18:59 <Taneb> jumper149: yes, that's what I wrote just with different variable names
07:19:10 <jumper149> Taneb: Well, I can see that x)
07:19:24 <Taneb> So, Nothing >>= f is always Nothing
07:19:25 <maralorn> sm[m]: I was more thinking in the direction of ghcident â€¦
07:19:35 <Taneb> And therefore Nothing >> x is always Nothing
07:20:18 <maralorn> We need a github client gh and a google macro g. Then you can execute all prefixes of ghcide.^^
07:20:36 <Taneb> It's similar to putStrLn "hello" >> someotherstuff will print hello, even though you discard the value
07:20:41 <Taneb> jumper149: does this help clear things up?
07:26:30 * hackage cdeps 0.1.2.4 - Extract dependencies from C code.  https://hackage.haskell.org/package/cdeps-0.1.2.4 (vmchale)
07:26:47 <srid> Here's an illustration how category theory can help with the intuition behind comprehending Haskell notions: "The end of this video is the BOMB. Best explanation of monads." https://youtu.be/i9CU4CuHADQ (Bartosz explains this towards the end)
07:26:50 <jumper149> I guess I was just used to the IO monad which in practice never has an empty value
07:27:09 <srid> So, although CT is not *needed* it does seem to *help* with an intuitive understanding.
07:27:15 <merijn> jumper149: Eh, it does if you use forever :p
07:28:04 <Taneb> jumper149: it might help you if you look up the definition of the Monad instance for Maybe and work through "Nothing >> f" by hand
07:28:09 <duncan> I sometimes dip into the category theory for programmers book if I want to learn a bit more about some of the CT stuff
07:28:46 <jumper149> Taneb: It's not that I dont understand it anymore, I just dont have an intuition
07:28:51 <jumper149> I will look into it
07:29:25 <Heffalump> ghcide is really great, btw. I haven't tried haskell-ide-engine but my understanding from people who have tried both is that ghcide is faster and more reliable.
07:29:35 <Ariakenom> merijn: throw e is a good empty too
07:30:05 <merijn> Ariakenom: Surely you mean throwIO and not the evil throw....
07:31:16 <Ariakenom> oh yes. I had repressed the existence of throw.
07:31:32 <jumper149> The definitions for Maybe are clearly a lot more intuitive than anything for IO ^^
07:31:59 <merijn> jumper149: How so? :)
07:32:23 <Ariakenom> simpler yes. people could be more familiar with exceptions though
07:32:40 <jumper149> http://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#line-1363
07:33:17 <jumper149> >>= for IO just references some weird stuff
07:33:18 <merijn> jumper149: The solution is to realise that the implementation of IO is unimportant
07:33:45 <merijn> jumper149: Sure, but understanding the implementation of IO doesn't really help you understand IO (and vice versa), best not to look
07:34:07 <jumper149> Yes thats why the Maybe definition was useful to look into, thats what i meant
07:34:49 <Ariakenom> % empty :: Maybe ()
07:34:50 <yahb> Ariakenom: Nothing
07:34:53 <Ariakenom> % empty :: IO ()
07:34:53 <yahb> Ariakenom: *** Exception: user error (mzero)
07:34:58 <merijn> jumper149: "IO Int" is "a program that when executed produces an Int", ">>=" means "given a program that produces 'a' when executed, and a function that takes an 'a' and returns a program that when executed produces 'b', create a program that produces 'b'"
07:37:54 <jumper149> I really dont have a problem with bind merijn, still ty :)
07:38:39 <Ariakenom> and program includes the idea that it may not produce 'a' but instead throw an exception
07:40:37 <maerwald> Yeah, look at it as a binary :P
07:41:11 <maerwald> I've heard metaphors like "recipe" etc, but "program" is really the most accurate description of "IO a"
07:42:39 <Ariakenom> <CODE> as nix says ('it' isn't actually IO but whatever)
07:43:21 <Ariakenom> I see ... I edited that parenthesis into nonsense
07:44:18 <maerwald> Ariakenom: it may throw an exception... or not. We will never know :P
07:44:26 <jumper149> 'b' never gets executed, when 'a' fails though, thats where my wrong intuition for (>>) came from.
07:44:54 <minusoneplusone> henlo
07:44:55 <jumper149> Oups, I mean the part of the program that produces 'b'
07:45:24 <minusoneplusone> im writing yet another scheme in haskell
07:46:05 <minusoneplusone> i wrote an stdlib.scm file and id like to know if there's any way to specify to stack that i'd like to copy that file too to ~/.local/lib/toy-scheme/ when running `stack install`
07:46:38 <minusoneplusone> half an hour of googling and searching the docs yielded no result yet
07:47:56 <maerwald> jumper149: 'b' doesn't get executed, it gets evaluated at best when 'IO b' is executed
07:48:13 <maerwald> > (pure undefined :: IO Int) >> pure 3
07:48:16 <lambdabot>  <IO Integer>
07:48:35 <maerwald> you can't see it, but this doesn't force undefined
07:48:40 <Ariakenom> maerwald: "the part of the program that produces 'b'"
07:48:48 <maerwald> because you never look at the value that the program produces
07:51:53 <dmwit> % (pure undefined :: IO Int) >> pure 3
07:51:53 <yahb> dmwit: 3
07:52:05 <dmwit> but...
07:52:06 <jumper149> a >> b = a >>= (\ _ -> b)    , undefined vanishes in _ :)
07:52:13 <dmwit> % (undefined :: IO Int) >> pure 3
07:52:13 <yahb> dmwit: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:20:2 in interactive:Ghci8
07:52:38 <maerwald> yep, the difference between the action and the value the action produces
07:53:07 <maerwald> >> doesn't discard an action, only the value
07:57:01 <ski> % evaluate (undefined :: Int) >> pure 3
07:57:01 <yahb> ski: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:26:11 in interactive:Ghci8
07:59:52 <jumper149> But in IO monad (>>) never has to really handle an empty value like Nothing in the Maybe Monad, because the program never reaches the point after throwing an exception
08:00:23 <jumper149> Im kind of bummed, that there is no link to source for `Monad []`
08:00:31 <jumper149> on Hackage
08:01:16 <Taneb> jumper149: http://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#line-966 has Functor, Applicative, and Monad instances
08:01:50 <Taneb> I found this from the list of instances underneath the "Monad" typeclass
08:02:14 <ski> jumper149 : `Nothing' in `Monad Maybe' (and `Left exn' in `Monad (Either exn)') is like throwing an exception
08:02:21 <ski> @src [] return
08:02:21 <lambdabot> return x = [x]
08:02:24 <ski> @src [] (>>=)
08:02:24 <lambdabot> xs >>= f = concatMap f xs
08:03:48 <jumper149> Taneb: Oups I shouldve found it too, was blind x)
08:33:37 <exarkun> is there a thing like Test.Tasty.Wai.testWai that returns an Assertion instead of a TestTree
08:36:08 <Lycurgus> u can't just wrap stuff w assert?
08:38:03 <exarkun> I don't know.  Can I?
08:38:11 <exarkun> Which assert do you mean?
08:38:58 <Lycurgus> https://downloads.haskell.org/~ghc/6.12.2/docs/html/users_guide/assertions.html
08:39:28 <exarkun> If I have a TestCase, what would I assert about it?
08:53:48 <merijn> Lycurgus: That's a way different things
08:54:13 <merijn> Lycurgus: Assertion is a type from HUnit, not a compiler assert
08:55:06 <Lycurgus> if u say so merijn, yeah way diff
08:55:54 <Lycurgus> the clearest of apples and oranges
08:56:12 <Lycurgus> my bad
09:04:25 <shapr> good morning!
09:05:44 <Lycurgus> moin shapr
09:16:08 <exarkun> shapr: if you're in ny then you missed it by 4 minutes
09:17:23 <shapr> exarkun: Are you in NYC?
09:17:29 <exarkun> shapr: no :)
09:17:46 <exarkun> shapr: Are you?  I thought you mentioned that
09:19:18 <shapr> exarkun: I am!
09:19:21 <shapr> until Halloween
09:19:30 <pikajude> oo, spooky
09:30:00 * hackage overloaded 0.1.1 - Overloaded pragmas as a plugin  https://hackage.haskell.org/package/overloaded-0.1.1 (phadej)
09:45:04 <ZoFLo> daily reminder that haskell is the javascript of C++
09:46:27 <lavalike> unsubscribe
09:46:36 <metalrain> coffeescript
09:49:22 <portnov1> hi all
09:50:03 <dmwit> Hiya, portnov1.
09:50:16 <portnov1> any ideas how -prof option can affect memory profile?
09:50:42 <portnov1> *with* profiling: http://pasteall.org/pic/show.php?id=c1bedd24c98285dcbb9d5731b55bbcbb
09:50:42 <portnov1> *without* profiling: http://pasteall.org/pic/show.php?id=bd8d5413b0b38bd4efedb2199dd76c06
09:50:58 <portnov1> note that it takes much more memory without profiling
09:51:04 <portnov1> -O2 is used in both cases
09:51:08 <portnov1> what is going on? :)
09:51:49 <sm[m]> quite possible.. profiling is known to change the runtime behaviour a lot
09:51:50 <sm[m]> currently
09:53:06 <sm[m]> PS nice charts, what is that app ?
09:53:17 <portnov1> https://github.com/portnov/hpview :)
09:53:32 <sm[m]> aha! It's on my list to try
10:05:03 <exarkun> How do I make `stack build` not build several things concurrently?
10:09:49 <dmwit> exarkun: The traditional flag for build tools is -j1. Perhaps stack also supports this.
10:10:58 <exarkun> sigh, yes, and it's even in --help output, just lost in the forest of other stuff
10:11:46 <exarkun> ty
10:22:26 <dsal> I have a type that I wanted to make Foldable, but it's the wrong kind (it's a container of a predefined type).  Kind of annoying.
10:24:59 <jumper149> dsal: What exactly is the problem? Cant you just write an instance of Foldable?
10:25:48 <dsal> jumper149: my type is the wrong kind. * vs. * -> *
10:28:35 <dsal> It's basically a list of a particular type. I wonder if I can go the other way and just make it a type alias of a list of the stuff.  It has to satisfy another class, though.
10:28:36 <jumper149> Cant you use something like `instance Foldable (Type a)`
10:28:51 <dsal> It doesn't have an a
10:29:50 <jumper149> Can you show me the source? Im kind of curious
10:30:10 <EvanR> it's a monomorphic list
10:30:43 <EvanR> are you sure you can't abstract the payload type
10:30:45 <dsal> data Properties = Properties [Property]
10:31:20 <dsal> The important parts are the other instances that deal with parsing and serialization.
10:32:09 <EvanR> when you need to operate on the list directly, you can use a wrapper
10:32:29 <dsal> I can do stuff, but not of huge value. I just wanted to fold it twice.  I unwrap to fold.
10:32:38 <EvanR> asList :: ([Property] -> a) -> Properties -> a
10:32:51 <EvanR> or something
10:33:13 <EvanR> though that is what Foldable is basically
10:34:05 <dsal> Yeah. It'd be slightly nicer to make it foldable.  I've not looked lately to understand why * -> * is important.
10:34:26 <EvanR> the type variable there is important to the laws of the data structure
10:35:04 <dsal> Yeah, I just mean I don't know why in particular. It's not important to me. :)
10:35:06 <EvanR> there exists monotraversable
10:35:41 <EvanR> but its usually only necessary when the collection type really doesn't contain indiviual values, like ByteString
10:36:20 <EvanR> it has a MonoFoldable class
10:37:19 <dmwit> dsal: You could `newtype Properties a = Properties [a]` or you could use the mono-foldable package.
10:37:25 <dmwit> dsal: I'd strongly prefer the former.
10:37:59 <dmwit> dsal: Even if you go the mono-foldable route, you should probably switch from data to newtype unless you have a specific reason not to.
10:38:29 <EvanR> then you'd need to put Properties Property everywhere :)
10:38:30 <dsal> But then I need to specify that my Properties contains Property values which seems silly.
10:38:39 <dmwit> You can make a type alias if you must.
10:38:55 <EvanR> newtype MySpecialSnowflakeList a = MkSpecialSnowflakeList [a]
10:39:06 <EvanR> type Properties = MySpecialSnowflaeList Property
10:39:10 <dsal> I'm probably using newtype.  I'm on my phone now.
10:39:39 <jumper149> EvanR: That looks nice imo
10:40:01 <EvanR> now SnowflakeList can be foldable, but it still leaves the question of those classes which dont want a variable
10:40:16 <dmwit> EvanR: Yep. If the newtype just exists to hang an instance on, that seems completely reasonable tot me.
10:40:23 <dsal> It works, but the value is kind of low.  I fold it twice right now.  The type exists for parsing and serializing.
10:41:09 <dsal> Though really, it would probably be good for users if it were foldable.
10:41:15 <dmwit> dsal: What if you just store it as a [Property] everywhere, and only apply the newtype wrapper/unwrapper in your parser and serializer?
10:41:19 <EvanR> ^
10:41:39 <dsal> I'll go back and figure out why I didn't do that...
10:41:41 <EvanR> +1 to [Property] 
10:41:48 <dmwit> Or, like... don't even bother with that and just call a non-typeclass-polymorphic parser/serializer at the right moment.
10:42:37 <dsal> It might be that I was just reusing too hard and went the wrong way.
10:42:53 <dsal> (to dmwit's point)
10:43:53 <dmwit> I think there are a couple parser/serializer libraries out there that emphasize the "use a typeclass for everything" approach so much that people lose sight of the fact that you can just define parsers and serializers that *aren't* class methods.
10:45:28 <EvanR> make everything a class, you know you can. And it works in java (tm)
10:46:31 <dsal> Nah, this is my typeclass.  I'm just going to remove the type and see what breaks.
10:47:47 * dmwit approves this plan
10:48:07 <EvanR> deleted code is best code
10:48:18 <dmwit> Thank mankind for revision control, hey?
10:48:28 <jumper149> EvanR: => no bloat at all
10:49:15 <EvanR> no bloat, no bugs, no performance bottlenecks :)
10:49:24 <EvanR> no support tickets
10:52:01 <dmwit> no features tho =(
10:52:23 <EvanR> features are passÃ©
10:55:08 <dsal> Well this made my code a lot easier to deal with.
10:55:33 <EvanR> lesson learned, new types suck
10:56:01 * hackage pusher-http-haskell 1.5.1.10 - Haskell client library for the Pusher HTTP API  https://hackage.haskell.org/package/pusher-http-haskell-1.5.1.10 (willsewell)
10:58:32 <dsal> 4 files changed, 54 insertions(+), 72 deletions(-)     --  all tests pass.  SHIP IT
10:59:03 <dsal> Yeah, this is way less dumb.
10:59:35 <EvanR> 5 points per line of new code, 25 points per line of code deleted
10:59:43 <dsal> :)
11:00:20 <EvanR> you may now pick your prize, an eraser for 9000 points
11:02:16 <jumper149> Î» Prelude > 5 * 54 + 25 * 72
11:02:18 <jumper149> 2070
11:02:30 <dsal> > 5 * 54 + 25 * 72
11:02:32 <lambdabot>  2070
11:03:02 <jumper149> > 5 * 54 + 25 * 72 > 9000
11:03:03 <lambdabot>  False
11:05:48 <dsal> Oh, I just realized there was some code in there I didn't change because Properties was a monoid already.   That was in the "this really isn't important, but kind of neat, so I'll do it anyway" category that ended up accidentally saving time.
11:06:19 <dsal> ...actually, quite a bit, because it mempty is all over the place.
11:10:30 <EvanR> i just learned how to convert a mutually recursive set of functions to one singlely recursive function...
11:10:57 <EvanR> how did i not know this already
11:12:44 <dsal> I still have some dumb thing in this client somewhere that converts a protocol error into an STM error.
11:14:07 <jumper149> What is a free monad?
11:14:48 <EvanR> for any functor you can get a monad with a special universal property
11:15:12 <PotatoRick[m]> hey there. could someone explain to me my runtime stuff called term-level? there are term-level, type-level and kind-level, right?
11:15:15 <PotatoRick[m]> what does "term" in "term-level" refer to?
11:15:31 <EvanR> it's like the stem cell of monads
11:15:44 <EvanR> it hasn't decided yet what it does
11:16:48 <int-e> PotatoRick[m]: expressions
11:16:52 <exarkun> an insightful explanation for any audience with an understanding of the biology of stem cells, assuming the explanation is created by someone with an understanding of the biology of stem cells
11:17:14 <EvanR> lol
11:17:57 <dmwit> PotatoRick[m]: When describing a language, it is traditional to give a grammar for the language. Any grammatically-correct thing is called a term.
11:18:34 <dmwit> PotatoRick[m]: (For this reason, "term-level" is an awful name that I have been actively seeking an alternative for. There are computational terms and type terms and kind terms, because each of those things has an associated grammar.)
11:18:49 <EvanR> "value level" ?
11:18:54 <dmwit> (So I prefer "computation level".)
11:19:01 <dmwit> EvanR: No, not all computation-level terms are values.
11:19:06 <jumper149> EvanR: So what is this universal property and is it trivial for any functor?
11:19:26 <dmwit> "value" is another technical term that means "a term that's been evaluated enough", for some definition of "enough" that varies from system to system.
11:20:03 <kezimo> oh my god
11:21:34 <Fimmind> @pl \[info, "PRIVMSG", chan, ":Hello"] -> Msg (takeWhile (/= '!') . drop 1 $ info) "Hello"
11:21:34 <lambdabot> (line 1, column 2):
11:21:34 <lambdabot> unexpected "["
11:21:34 <lambdabot> expecting pattern
11:21:44 <EvanR> jumper149: for any other monad you could make, there is a unique monad morphism which maps your free monad to that other specific monad. Disclaimer i probably butched this explanation
11:21:58 <PotatoRick[m]> dmwit: thanks a lot!
11:23:02 <EvanR> none of this is really going to make sense without looking at a few examples
11:23:25 <jumper149> Yep that's what I feel like^^
11:31:18 <dsal> Kind of wish I had some magic to tell me what was going on during "thread blocked indefinitely in an STM transaction"
11:32:08 <c_wraith> it means no other thread is holding a reference to a TVar that your transaction is waiting on a change from.
11:32:26 <EvanR> maybe threadscope can help?
11:34:22 <dsal> Yeah, I'm just wondering what's even waiting.  This happens when I send a semantically invalid packet, after which the server sends me a message telling me I did that and then hangs up.  I am not seeing the bit about the invalid packet.  I'm wondering if conduit is doing something weird.
11:41:27 <dsal> It looks like conduit might be bailing when the socket closes without finishing the stuff that it's already got.
11:56:57 <fendor> if I compile an application with profiling enabled and `+RTS -xc` will I get stack traces in case of `error` calls? Or in other words, how can I get a stack trace of the `error` call?
11:57:58 <dsal> I filed a bug.  Now someone will fix my issue and I can move on with life.
12:00:40 <exarkun> that's been my experience
12:03:48 <kezimo> What are you all doing today?
12:05:06 <fendor> debugging
12:05:08 <mozzarella> closing browser tabs until I get to a number that is reasonable, hopefully
12:05:20 <mozzarella> I'm currently at 1459
12:07:43 <kezimo> debugging what
12:12:08 <kezimo> Please do not end my existance. 
12:12:29 <fendor> merging hie-bios into haskell-ide-egine
12:13:13 <fendor> alright, now I compiled it with cabal v2-build --enable-profiling, but when I try to run it, it complains that the program has not been compiled with -prof? 
12:16:48 <dppes[m]> Am I in the right place to get help with deploying a yesod app to an apache server?
12:17:19 <dsal> Apache... I remember that
12:17:29 <dppes[m]> Either, the yesod book is remarkably usesless in this particular regard or I am remarkably stupid.
12:26:47 <iqubic> Hello?
12:28:06 <iqubic> :t ($ True)
12:28:07 <lambdabot> (Bool -> b) -> b
12:28:25 <iqubic> :t \x -> ($ x)
12:28:26 <lambdabot> a -> (a -> b) -> b
12:28:48 <iqubic> :t flip id
12:28:50 <lambdabot> b -> (b -> c) -> c
12:29:29 <dmwit> dppes[m]: Mmm... I think normally yesod apps are their own HTTP server, not something that runs under Apache.
12:29:42 <dmwit> (Assuming you mean Apache's HTTP server here.)
12:31:04 <sm[m]> Normally they are put behind apache, nginx, caddy etc. for production
12:31:32 <sm[m]> Itâ€™s not really yesodâ€™s problem - maybe the book doesnâ€™t cover it ?
12:32:28 <iqubic> Why are singletons so confusing?
12:32:46 <iqubic> I can't understand this error at all.
12:32:50 <iqubic> http://dpaste.com/0Q4EE0B
12:34:04 <dppes[m]> According to the book, Yesod apps can run as CGI under Apache (which seems to be the most reasonable deployment option in my particular circumstances).
12:34:59 <dppes[m]> Unfortunately, the explanation of how to configure this feels a lot like a tutorial that might be posted on reddit.com/r/restofthefuckingowl
12:37:38 <dppes[m]> The Book: https://www.yesodweb.com/book/deploying-your-webapp
12:38:02 <nshepperd2> iqubic: what's the type of withSomeSing?
12:38:50 <dminuoso> iqubic: Its not singletons, its just very simple type system basics..
12:39:32 <iqubic> What is the issue here?
12:39:36 <dminuoso> iqubic: Read the error message slowly.
12:39:43 <dminuoso> iqubic: It's very very explicit. :-)
12:40:03 <iqubic> withSomeSing has a scary type.
12:40:07 <iqubic> SingKind k => Demote k -> (forall (a :: k). Sing a -> r) -> r
12:40:22 <dminuoso> iqubic: Dont be scared, dont pay attention to what they mean. :-)
12:40:34 <dminuoso> iqubic: Whats the type of the arguments you apply this function to?
12:41:13 <iqubic> a Demote k and an eliminator that takes any Sing of the same kind as the Demote.
12:41:28 <dminuoso> iqubic: Hold on.
12:41:33 <dminuoso> iqubic: Is it?
12:41:38 <dminuoso> iqubic: GHC is claiming something different.
12:41:41 <iqubic> I think so.
12:41:52 <dminuoso>     â€¢ Couldn't match expected type â€˜Demote k0â€™
12:41:58 <dminuoso> This means, it expected something o type 'Demote k0'
12:42:03 <dminuoso>                   with actual type â€˜SomeSing TimeOfDayâ€™
12:42:10 <dminuoso> But the thing actually was of type SomeSing TimeOfDay
12:42:15 <iqubic> toSing :: Demote k -> SomeSing k
12:42:18 <dminuoso>     â€¢ In the first argument of â€˜withSomeSingâ€™, namely         â€˜(toSing Morning)â€™
12:42:28 <dmwit> iqubic: dminuoso is not asking what types `withSomeSing` *wants* its arguments to be. They're asking what the types of the *actual arguments you chose* are.
12:42:40 <nshepperd2> Note that Demote is a type family
12:42:59 <nshepperd2> The error message is saying it doesn't know what k is
12:43:11 <iqubic> toSing Morning :: SomeSing TimeOfDay
12:43:42 <iqubic> that's the argument I gave here: 'withSomeSing (toSing Morning) fromSing'
12:44:09 <iqubic> But withSomeSing expects its first argument to be of type Demote k.
12:44:46 <dminuoso> % f :: Int -> Bool; f x = x > 10
12:44:47 <yahb> dminuoso: 
12:44:52 <dminuoso> % f "foo"
12:44:53 <yahb> dminuoso: ; <interactive>:29:3: error:; * Couldn't match expected type `Int' with actual type `[Char]'; * In the first argument of `f', namely `"foo"'; In the expression: f "foo"; In an equation for `it': it = f "foo"
12:45:00 <dminuoso> iqubic: Do you understand the error message here?
12:45:08 <iqubic> Yes.
12:45:50 <iqubic> f wants its first argument to be of type Int, but you tried to give it a [Char]
12:46:01 <dminuoso> iqubic: Now read your error message.
12:46:28 <iqubic> Oh. I see.
12:46:36 <dmwit> Next up:
12:46:39 <dmwit> :t show . read
12:46:40 <lambdabot> String -> String
12:47:07 <dmwit> rip my demo
12:47:11 <iqubic> Wait... I know where this is going.
12:47:32 <iqubic> Which typeclass instance are you using for show and read?
12:47:40 <iqubic> % :t show . read
12:47:40 <yahb> iqubic: String -> String
12:47:56 <dmwit> I forgot about defaulting. I wanted it to complain that the type was ambiguous.
12:47:58 <nshepperd2> Oh, i thought there might be an ambiguity problem with Demote but it's actually injective
12:48:01 <iqubic> > (show . read) "1"
12:48:03 <lambdabot>  "*Exception: Prelude.read: no parse
12:48:11 <dmwit> So that you could have a similar reason-by-analogy example to look at for when you fix your first error.
12:48:18 <iqubic> dmwit: I see.
12:48:32 <iqubic> 'withSomeSing Morning fromSing' works actually.
12:48:39 <iqubic> And returns Morning.
12:48:53 <dmwit> Oh, is Demote injective?
12:48:55 <iqubic> I have no idea how withSomeSing is supposed to work now.
12:49:55 <dmwit> I guess it makes sense for it to be.
12:51:37 <dminuoso> iqubic: withSomeSing is basically a convenience 
12:51:57 <iqubic> convenience for what exactly?
12:52:19 <dminuoso> iqubic: "Convert a normal datatype (like 'Bool') to a singleton for that datatype, passing it into a continuation."
12:52:25 <dminuoso> iqubic: Which part of that eludes you?
12:52:55 <dminuoso> It's sort of `flip ($)`
12:53:07 <dminuoso> Except with that bit of "convert it into a singleton first"
12:53:20 <iqubic> Well, in my example above I thought I had to do the "Convert a normal datatype (like 'Bool') to a singleton for that datatype" myself.
12:53:48 <iqubic> Which is why I tried to pass (toSing Morning) in as the first parameter.
12:53:51 <dminuoso> iqubic: I see. The documentation was not an instruction, it was a specification of what it does. :)
12:54:08 <iqubic> I know. I feel dumb now.
12:54:17 <exarkun> how many dollars do I need to pour into a computer to have intero startup not hang emacs for a geological age?
12:54:41 <dminuoso> exarkun: Use ghcid instead?
12:54:48 <exarkun> dminuoso: okay great
12:54:49 <iqubic> Use Dante instead?
12:54:53 <exarkun> no no
12:54:56 <exarkun> I don't want two options
12:55:04 <exarkun> what is the single correct answer
12:55:04 <dminuoso> exarkun: I see.
12:55:12 <iqubic> Dante is another emacs package for haskell code editing.
12:55:20 <iqubic> And there is no single correct option.
12:55:28 <exarkun> how disappointing
12:55:34 <iqubic> I like Dante, an dminuoso likes ghcid.
12:55:37 <dminuoso> exarkun: haskell-ide-engine is currently the best working integration I know of, ghcid is the most solid and fastest solution.
12:55:53 <iqubic> I like Dante myself.
12:56:03 <iqubic> https://github.com/jyp/dante
12:56:04 <dminuoso> (Ive hooked ghcid into compile-mode, so I get quick hyperlinks into source code on errors)
12:56:18 <dminuoso> *compilation-mode
12:56:31 <nshepperd2> Throw your computer on a bonfire
12:56:33 <exarkun> What does "solid" imply?
12:56:39 <iqubic> Now, time to watch this talk by jle`
12:56:41 <exarkun> How does it compare to "best working"?
12:56:52 <iqubic> "Enhancing your Haskell with Dependently Typed Programming - Î»C 2017"
12:57:05 <dminuoso> exarkun: Well ghcid wont randomly break, it doesnt require special tooling...
12:57:19 <monochrom> You should pour dollars into a human, not a computer...
12:57:23 <dminuoso> exarkun: Essentially ghcid buys you painless compability across any ghc version, future proof...
12:57:42 <dminuoso> You just give up on some of the more advanced IDE features. But most can be worked around with raw emacs features.
12:58:14 <iqubic> dminuoso: Dante is very similar to ghcid. Dante runs a ghci instance in the background to do all your type checking and give compiler errors.
12:58:30 <iqubic> dminuoso: What advanced IDE features does ghcid lack?
12:59:19 <iqubic> IOW, what were you thinking of when you said: "You just give up on some of the more advanced IDE features."?
13:00:56 <dminuoso> iqubic: Things like type inference on hovering, auto-completion, etc..
13:01:09 <dminuoso> At least the auto-completion can be worked around to some degree with hasktags.
13:02:12 <iqubic> I have a fairly solid autocomplete system.
13:03:28 <exarkun> looks like dante doesn't like new cabal yet
13:04:29 <iqubic> I have it set-up so that when I type "import Data.Sing" company gives options for all the different modules from the Singletons library.
13:04:42 <iqubic> not sure where that info comes from, but it's there.
13:04:56 <dminuoso> exarkun: You could probably configure it to use `cabal v2-repl` since the command line appears to be customizable.
13:05:47 <iqubic> It is customizable.
13:06:07 <iqubic> I might actually submit a Pull Request to the code. Not sure if I should though.
13:08:00 <iqubic> What version of Cabal is it that really really pushes you towards using 'cabal v2-repl'?
13:08:14 <iqubic> 3.0?
13:08:56 <exarkun> 2.4 I think
13:09:02 <dminuoso> iqubic: Its not necessarily a question of cabal but whether you use v2/new-*
13:09:11 <iqubic> Ah. Which is better?
13:09:28 <dminuoso> iqubic: What do you mean?
13:09:39 <dminuoso> I dont think old-style has any benefits at all.. :-)
13:09:44 <dminuoso> (Unless you use nix)
13:09:46 <exarkun> docs for customizing dante repl command don't make sense, when I do what they say I get type errors
13:10:26 <dmwit> v2-* is default in cabal-install 3.0 and higher.
13:10:34 <iqubic> dminuoso: and I do nix.
13:11:00 <dmwit> That means `cabal repl` means `cabal v2-repl` in 3.0 and up; in previous versions it meant `cabal v1-repl`.
13:11:04 <dminuoso> iqubic: In that case v2-* might not be interesting to you, depending on whether you want to deploy with nix as well.
13:11:11 <dmwit> Both v1-* and v2-* are still available with explicit prefixes.
13:14:05 <iqubic> I'm fine just letting Dante run whatever it wants to. And I'll fix it when stuff breaks.
13:42:41 <functor-extract> Hi everyone!
13:46:03 <functor-extract> Recently I've been playing around with data type `data U a = U [a] a [a]`. And it's easy to define a function `extract :: U a -> a`. But after some time I've got promoted to the new level and was toying around with `U (U a)` and quite fast I found the need of `extract2 :: U (U a) -> a` (just `extract . extract`). And then I got promoted again and
13:46:03 <functor-extract> the new function was created - `extract3`. So I stopped and asked myself if it's possible to write a function `deep_extract ` that will apply extract `N` times, where `N` is count of `U` in the type :) 
13:47:15 <functor-extract> So I started to play around with `RankNTypes` and spawning `forall` here and there. But I always stumble at the infinite expansion. E.g. `a ~ U a` in 
13:47:25 <functor-extract> ```deep_extract :: forall w a. (forall a. w a -> a) -> w (w a) -> adeep_extract f = f . f```
13:48:35 <functor-extract> Also I've tried: `deep_extract :: forall w a. (forall a. w a -> a) -> w a -> a` with definition `deep_extract f = let g = mist2 f in g . f` (but this one is infinite) :)  
13:48:46 <functor-extract> Is it possible to define and implement such a function?
13:55:29 <lyxia> there are some tricks with typeclasses that sound relevant
13:55:58 <iqubic> I can't think of any.
13:56:35 <lyxia> like stuff in this small package https://github.com/oisdk/arity-generic-liftA#readme
13:58:18 <lyxia> I can't think of a resource that will teach you this overnight...
13:59:00 <lyxia> the book Thinking with Types is relevant https://leanpub.com/thinking-with-types
14:00:24 <functor-extract> Thank you for the links
14:00:47 <functor-extract> While I was waiting for any answers I've also stumbled upon some type class hackery :)  
14:01:00 <functor-extract> https://hackage.haskell.org/package/tuple-0.3.0.2/docs/src/Data.Tuple.Curry.html#Curry
14:01:25 <iqubic> Thinking With Types is great, but I don't see how that applies to this here.
14:01:25 <lyxia> :)
14:05:37 <lyxia> Well it will give you some tools for type-level programming, it doesn't go all the way to give you recipes for arbitrary problems, but for example if you're handed a solution to a similar problem you are more likely to be able to understand it to repurpose it.
14:07:47 <iqubic> I see.
14:09:43 <dmwit> data N = Z | S N; class ExtractN n where type UN n a; extractN :: UN n a -> a; instance ExtractN Z where type UN Z a = a; extract = id; instance ExtractN n => ExtractN (S n) where type UN (S n) a = U (UN n a); extractN = extractN @n . extract
14:10:05 <dmwit> with suitable extensions ;-)
14:12:14 <iqubic> Just import GHC.TypeNats. Don't bother with defining your own nats.
14:13:08 <c_wraith> they're not really interchangeable 
14:13:15 <iqubic> Why not?
14:13:39 <dmwit> iqubic: Try it and see.
14:13:42 <iqubic> What makes user defined Peano nats better than TypeNats in this scenario?
14:14:05 <c_wraith> ghc doesn't know that (n + 1 ~ m + 1) implies (n ~ m) 
14:14:37 <c_wraith> but it does know (S n ~ S m) implies (n ~ m) 
14:14:44 <iqubic> Weird.
14:14:50 <dmwit> There's a couple problems. One is that GHC doesn't know that `n + 1 ~ m` means `m` is not `0`.
14:15:04 <iqubic> Is there a way to prove these things?
14:15:19 <dmwit> Another is that there's no easy way to go from `KnownNat (n+1)` to `KnownNat n`.
14:15:34 <dmwit> iqubic: Yes: Peano nats. ;-)
14:15:50 <c_wraith> it's the difference between using constructors and functions. 
14:15:51 <merijn> Or GHC typechecker plugins :p
14:16:02 <EvanR> i was just proving n+1<m+1 => n<m... it's annoyingly not trivial
14:16:28 <c_wraith> ghc knows what constructors do. it's pretty clueless about arbitrary functions. 
14:16:53 <iqubic> EvanR: Did you ever get that proof to work?
14:18:08 <EvanR> yeah
14:18:20 <dsal> Infinite STM bugs are kind of annoying.  Is there a not very intrusive way to find out what it's even stuck on?  I don't think it's incorrect, but it happens when my client is hung up on and I'm cleaning up, so I'd like to avoid it.
14:19:07 <EvanR> i like using Async threads for things, where you don't care if a particular thing crashes
14:19:15 <Ariakenom> what isn't incorrect in what way?
14:19:31 <dmwit> lyxia: Shame about that definition of lift. Should be `lift f = apply (pure f)` so that you can have liftA0 = pure.
14:19:37 <EvanR> like, you are cleaning up, thing over there crashes, so when you "join" it you either get () or the error, but doesn't matter which
14:19:55 <EvanR> whole program does not die
14:20:20 <dsal> EvanR: I've linked up a couple threads here, and bracketed to clean up the rest.  The annoying thing is somewhere in the middle of that, STM gets angry and I lose my actual cause.
14:20:32 <dmwit> lyxia: (And be able to apply `lift` to things that aren't functions.)
14:20:37 <EvanR> yep sounds about right
14:20:52 <iqubic> EvanR: Care to share with me the proof you came up with for (n+1 > m+1) implies (n > m)? I'd like to see that.
14:21:08 <EvanR> really?
14:21:10 <EvanR> lol
14:22:05 <iqubic> I just want to see it for academic reasons.
14:22:37 <EvanR> it's not in haskell so it's out of scope, but i can send it to you
14:23:31 <iqubic> Oh. What did you write it in??
14:24:13 <EvanR> pen and paper
14:25:13 <Ariakenom> STM could|can loop forever on correct code without ghc flag -fno-omit-yields
14:25:13 <iqubic> Oh. Don't bother sending it to me in that case.
14:25:35 <EvanR> k
14:26:09 <dmwit> EvanR: What definition of < did you choose? If you define it the usual way, it should just be induction on the witness of n+1 < m+1.
14:27:13 <dmwit> uh
14:27:15 <dsal> iqubic: hackers don't need proofs
14:27:16 <dsal> @check (\n m -> n + 1 > m + 1 || n <= m)
14:27:18 <lambdabot>  +++ OK, passed 100 tests.
14:27:22 <dsal> PROOF
14:27:37 <EvanR> <_0 : 0 < n+1; <_+ : m < n -> m+1 < n+1
14:27:46 <dmwit> Hrm, maybe not. You have to show a side lemma that if n+1 = S n', then n = n'. =P
14:28:02 <EvanR> the induction is easy
14:28:19 <dmwit> EvanR: Okay, so why isn't the proof just \x -> case x of <_+ p -> p; <_0 -> absurd?
14:28:21 <EvanR> choosing the statement and having it type check is...
14:28:23 <iqubic> :t fmap
14:28:24 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:28:27 <EvanR> several lines
14:29:19 <dmwit> (to be completely explicit, absurd (m+1 = 0))
14:29:40 <EvanR> dmwit: if you mean to say, all the invisible things here, including the argument to absurd, are correct, agreed. It's just that :)
14:29:53 <EvanR> m+1=0 is a type not a value
14:30:04 <iqubic> But you did this with pen and paper. Why?!
14:30:09 <dmwit> absurd (Refl : m+1=0)
14:30:18 <EvanR> because on the computer things end up looking like dmwit's code :)
14:30:48 <EvanR> "absurd (Refl : m+1=0)" man if that worked, you could do anything!
14:31:20 <dmwit> ...no?
14:31:22 <EvanR> also there are no equalities anywhere
14:31:28 <EvanR> Refl doesn't apply
14:31:29 <dmwit> The pattern match on <_0 brings an equality into scope.
14:31:37 <EvanR> if you say so :)
14:32:07 <EvanR> i don't have pattern matching here or a theory for how it works
14:32:25 <dmwit> We know `x : m+1 < n+1`, so the match on `<_0` will introduce a new variable `n'` and two equations, `m+1=0` and `n+1=n'+1`.
14:32:41 <EvanR> as the story goes
14:33:20 <EvanR> it is interesting to require that doing anything first requires a theory of equality types
14:33:33 <EvanR> which this problem has nothing to do with
14:33:48 <dmwit> Well, you don't *have* to prove it in type theory. You could prove it in set theory instead. =P
14:34:05 <sicklorkin> how would one build a list conditionally? ive got this guck `execWriterT $ case () of _ | a && b -> tell lista >> tell listb ; | a -> tell lista ; | True -> tell defList`. any nice ways of doing this kinda thing? 
14:34:08 <dmwit> I went with type theory because you told me a definition of < that was phrased in terms of type theory.
14:34:34 <EvanR> proof works without pattern matching or equalities or a type inference mechanism
14:34:43 <dmwit> [citation needed]
14:34:55 <EvanR> right, that is what iqubic` was asking about
14:35:51 <dsal> sicklorkin: I'd probably not mix the writer monad and the other logic in the middle.
14:36:25 <dmwit> sicklorkin: Well, I'd probably write essentially that, but with `let` instead. `let foo = if | a && b -> lista ++ list b | a -> lista | otherwise -> defList`.
14:36:28 <sicklorkin> dsal: concat [ [lista | a ] ]?
14:36:42 <dmwit> That's with MultiWayIf, though your case () of _ is fine, too.
14:37:23 <sicklorkin> [ lista <* guard a ]
14:37:31 <sicklorkin> i want something monoidy
14:37:38 <dsal> monoid or monad?
14:37:51 <dsal> It's totally possible to write haskell without having monads in every line.  I kind of prefer it that way most of the time.
14:37:58 <dsal> But it's a monoid, so I'd make use of that, probably.
14:38:17 <EvanR> replace monads with applicatives and i agree
14:38:41 <dsal> You don't like applicatives?
14:38:48 <dmwit> [v | (list, p) <- [(lista, a), (listb, b)], p, v <- list] -- depending on what defList and any missing cases you forgot look like
14:38:50 <dsal> I mean, I just try to do the simplest thing at any given point.
14:39:27 <sicklorkin> ther's a lot of syntax there that i don't wannt
14:39:42 <pikajude> Is there a way to hide the "legacy v1 style" cabal warning header?
14:39:50 <pikajude> I'm forced to use 2.4 for the time being because cabal-helper isn't 3.0-ready
14:39:59 <dmwit> pikajude: Well, you can explicitly write v1- in front of your command. =P
14:40:09 <boxscape> Could it make sense to have a (almost) Monad but without pure?
14:40:14 <dmwit> pikajude: As a bonus, then your scripts and stuff won't break when you do upgrade to 3.0!
14:40:23 <pikajude> I don't have any scripts that use it
14:40:24 <pikajude> just me
14:40:47 <dmwit> pikajude: As a bonus, then your just you and stuff won't break when you do upgrade to 3.0!
14:41:06 <pikajude> yeah I suppose
14:41:09 <sicklorkin> how would you write a conditional listwith lenses?
14:41:39 <dsal> Are we doing an obfuscated haskell contest?
14:41:48 * dmwit = dsal
14:41:50 <sicklorkin> challenges accedpted
14:42:17 <pikajude> v1- might do it, I had no idea that prefix existed
14:42:25 <pikajude> neat(tm)
14:43:09 <dmwit> pikajude: Why do you prefer v1-* to v2-*?
14:43:26 <dmwit> :t filterM
14:43:27 <lambdabot> Applicative m => (a -> m Bool) -> [a] -> m [a]
14:43:29 <pikajude> <pikajude> I'm forced to use 2.4 for the time being because cabal-helper isn't 3.0-ready
14:43:40 <dmwit> So?
14:43:54 <pikajude> not sure what other info i can provide
14:43:59 <sicklorkin> dmwit: :)
14:44:35 <dmwit> pikajude: I don't understand. Why does needing to use cabal-install-2.4 imply a preference for v1-* over v2-*?
14:44:45 <sicklorkin> (flip((.)(>>)guard).return)
14:44:52 <pikajude> because cabal-helper issues commands like "build" or "configure"
14:45:04 <dmwit> ah
14:45:04 <pikajude> so those use the v1 implementation of commands
14:45:12 <pikajude> if I use v2 myself, it creates all the configuration files in a totally different place
14:45:14 <pikajude> as it should
14:46:01 <sicklorkin> :t (flip((.)(>>)guard).return)
14:46:03 <lambdabot> (Monad m, Alternative m) => b -> Bool -> m b
14:46:37 <sicklorkin> where's monadplus
14:52:21 <nil> @src guard
14:52:21 <lambdabot> guard True  = pure ()
14:52:21 <lambdabot> guard False = empty
14:52:40 <nil> :t guard
14:52:41 <lambdabot> Alternative f => Bool -> f ()
14:55:28 <davr0s> how is  haskell adoption these days
14:58:31 * hackage tree-sitter 0.2.1.0 - Unstable bindings for the tree-sitter parsing library.  https://hackage.haskell.org/package/tree-sitter-0.2.1.0 (patrick_thomson)
14:59:13 <sm[m]> davr0s: still growing..
14:59:37 <jle`> sicklorkin: i usually use something like `x <$ guard b`
15:00:38 <sicklorkin> jle`: that's the syntax i've decided on 
15:01:38 <dsal> davr0s: haskell adopted me and has been a pretty good parent except for ARM being behind.
15:01:51 * dsal is tired of having his ARMs tied
15:03:01 <davr0s> oh because it has an unusual runtime.. it doesn't have good support outside of x86, right
15:03:30 <davr0s> whats the story with haskell and parallelism these days.. i always remember big hopes that functional programming is the way to make easily paralleizable programs
15:03:54 <davr0s> i'm from the C++ camp and have been impressed with the semi-functional approach in rust
15:04:10 <davr0s> 'rayon' library.. parallel iterators
15:05:13 <davr0s> i kind of need to fire my brain up with something new..i've dabbled with haskell on and off
15:05:26 <davr0s> it made more sense after rust.
15:05:45 <davr0s> but doing thigns like graphics in it (interacting with opengl) seemed an uphill struggle
15:06:02 <davr0s> i guess there's some tasks it's going to suit less
15:06:58 <sm[m]> that's true. But still, do it
15:07:02 <dsal> ghc works fine on ARM.  They just don't do distributions well.
15:07:07 <sm[m]> I bet you'll be glad
15:07:19 <dsal> haskell parallelism and concurrency are both pretty pleasant.
15:07:34 <sm[m]> you'll find a few opengl options on hackage
15:07:37 <dsal> (Â± my STM error I was complaining about above)
15:14:56 <merijn> davr0s: There's lots of good primitives around to build higher level concurrency/parallelism abstractions on, but there aren't too many off-the-shelve packages providing those yet
15:15:33 <davr0s> right i'm aware of the differnec between concurrency and parallelism
15:15:45 <davr0s> what i'd traditionally been more interested in was the latter.
15:16:02 <davr0s> "writing stuff in a way that can be easily be made to leverage multicore systems"
15:16:06 <merijn> davr0s: tbh, interacting with OpenGL seems like it shouldn't be *that* painful, I mean, sure you'll feel the fact that the API of OpenGL is rather low level and there's no nice high level wrappers yet
15:16:31 <merijn> davr0s: The tools are there, but people are still figuring out what sort of high level API people want to build with them
15:17:07 <davr0s> i can see haskell being great for manipulating geometry
15:17:47 <davr0s> when it comes down to the nitty gritty of building rendering commands etc.. it might just be that an low level imperative language is more closely aligned to that task
15:17:52 <merijn> tbh, something like an OpenGL monad seems like it'd make perfect sense, since all OpenGL operation should be sequence anyway
15:18:08 <merijn> davr0s: Haskell is my favourite imperative language, though ;)
15:18:17 <davr0s> hah i hear some people say that
15:18:43 <merijn> davr0s: I write a lot of code that does tons of IO, and honestly just writing imperative IO heavy code is perfectly pleasant :)
15:18:55 <davr0s> i guess you're just a lot more used to it
15:19:08 <davr0s> was it you in #programming telling me about vtables being an immplementation detail 
15:19:11 <davr0s> r.e. rust.
15:19:18 <davr0s> the nick seems familiar.
15:19:23 <dsal> Yeah, the stuff I've been most interested in lately isn't very functional...  MQTT clients observing and changing the world.
15:19:25 <merijn> davr0s: Probably :)
15:19:47 <davr0s> i know rust-traits and haskell typeclasses have strong parallels
15:20:36 <davr0s> but in rust switch between runtime and compile time polymorphism is explicit (inline with the language philosophy, closer to C,C++)
15:20:38 <merijn> davr0s: Thing is, once you spend a bit of time working with mutable vectors, IORef/MVar and IO, you realise "wait...I can literally write the exact same code as I'd write in C, but in Haskell" and then you quickly start thinking "well, what would I need C for anyway?"
15:20:44 <dsal> I've not done anything with rust (I tried years ago, but nothing was ready), but I get the impression people working on rust had familiarity with haskell.
15:21:07 <dsal> I do similar, but with STM and "I couldn't write this in C."
15:21:15 <davr0s> yes its definitely haskell inspired, but has a very different target
15:21:28 <davr0s> C++ <-->   Rust <-->  Haskell
15:22:12 <merijn> dsal: Yeah, for concurrency STM makes more sense, but I was thinking more single-threaded mutable stuff :)
15:22:12 <dsal> I've been doing go for a long time.  It's not really in that diagram, but it's been pretty good for solving problems I've had.
15:22:31 <dsal> I think I've used IORef like, once.  I should do that again sometime.
15:22:59 <davr0s> go doesn't excite me as much, but it seems to be a practical compromise hence it's handling it's target niches well
15:23:04 <merijn> dsal: IORef I don't use too often, but mutable vectors are nice :)
15:23:08 <dsal> I like go because it's not particularly exciting.
15:23:11 <merijn> Even better with ST
15:23:15 <davr0s> hAHAH
15:24:08 <davr0s> rust interests me because it really can handle the same niches as C++
15:24:13 <dminuoso> I too find it interesting how Ive not used IORef even once in almost 2 years of haskell. It seems that mutability in general is not something we rely on much.
15:24:17 <davr0s> i realise most programming work doesn't need that
15:24:23 <dminuoso> Mutable vectors though, indeed.
15:24:49 <davr0s> lambdacube looked rather interesting
15:25:01 <davr0s> (regarding graphics)
15:25:13 <jle`> i was just using IORefs/MVars the other day, they can be useful for a lot for doing IO with external systems 
15:25:15 <davr0s> shaders embedded right inside cpu side code
15:25:15 <iqubic> What is lamdacube?
15:25:31 <davr0s> http://lambdacube3d.com/
15:25:34 <merijn> rats, I'm trying to extract some C++ code so I can constrast my Haskell and C++ implementation, but it's generated and my generator isn't playing nice :p
15:25:42 <davr0s> http://lambdacube3d.com/editor.html << this impressed me
15:25:55 <jle`> ah i thought you were talking about the theme park
15:26:26 <boxscape> ooh I like the mouse-over type signatures
15:31:16 <merijn> Ah, finally
15:31:52 <merijn> davr0s: My C++ version of binary decision trees: https://paste.debian.net/1100173/
15:31:59 <merijn> davr0s: The same, but in Haskell: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/src/Model.hs#L46-L55
15:33:25 <merijn> davr0s: The Haskell version is somewhat slower than the C one (about 1.5x of the C version), but since the C version has runtimes measured in tens to hundreds of nanoseconds, that's not too bad.
15:33:41 <davr0s> of course there is a speed:convenience tradeoff
15:34:27 <davr0s> an interesting metric is performance after a given amount of programmer time
15:34:39 <merijn> davr0s: Funnily enough, the Haskell version is actually faster in the overall code, since I run it inside a conduit pipeline and GHC can inline it into the conduit pipeline, resulting in it being about 20% faster than FFI (unsafe of course, so no overhead) calling the C version :)
15:35:00 <davr0s> like i'd expect C to win everything, but the questoin is how fast is somethign after moderate programmer effort.. i know haskell is pretty amazing at making code composable
15:36:22 <merijn> davr0s: IMO, Haskell might actually be a better C than C :p See, often you just want to alias/type-pun a bunch of stuff, but you can't in C, because undefined behaviour
15:37:07 <davr0s> IMO.. 2 very different niches and reasons for existing
15:37:18 <merijn> davr0s: Using the FFI you can just write the exact same pointer code as you'd write in C, but since GHC isn't trying to mimic some weird abstract machine and just treats memory as "a large sequence of bytes" (like people like to pretend with C) all that "Just Works"
15:37:24 <davr0s> the fact you can do C ffi from haskell makes it complete
15:38:24 <davr0s> where things get interesting is in todays parallel world
15:38:36 <merijn> Anyway, bed time :)
15:38:58 <davr0s> moderate performance but more parallelizable might be better
15:55:50 <EvanR> C-complete, the property that your language contains a copy of C semantics, or can otherwise directly communicate with a program written in C
15:56:37 <EvanR> does C stand for continuum now?
16:06:41 <nedlo> hello 
16:06:48 <nedlo> hello 
16:06:56 <lyxia> nedlo: hello
16:07:23 <nedlo> fdsfd 
16:19:15 <pikajude> indeed
16:31:21 <iqubic> I agree
16:37:53 <dansho_> class Foo (s :: k) where ... means that s cannot be higher kinded?
16:38:27 <monochrom> No, that's not what it means.
16:38:53 <jle`> dansho_: it means the the class Foo is poly-kinded
16:38:56 <iqubic> I assume that uses PolyKinds/
16:39:22 <jle`> so you can define an instance for Int, an instance for Maybe, an instance for StateT, an instance for Eq, an instance for Monad ...
16:39:55 <jle`> in fact you could even define instance Foo Foo ;)
16:40:33 <jle`> dansho_: contrast to class Foo (s :: Type), which would only allow instances for Int, Bool, String, etc., but not Maybe/Eq/Monad/etc.
16:40:37 <dansho_> i couldn't do that if it was declared class Foo s where ... ?
16:40:52 <jle`> with -XPolyKinds i think (s :: k) is the case by default
16:40:57 <jle`> :: is what we call a type annotation
16:41:10 <jle`> it "helps" ghc
16:41:12 <iqubic> not a kind annotation, in this case?
16:41:20 <jle`> it doesn't necessarily provide new information
16:41:32 <monochrom> I wonder what methods you actually have that either benefits from or conflicts with polykind s.
16:41:59 <dansho_> without the annotation then it does not allow higher kinded instances?
16:42:03 <jle`> ah yeah, usualyl the kind of s would come from kind inference, so how you use s in the methods would change how s's kind is inferred
16:42:11 <jle`> dansho_: no, you don't need annotations for higher kinded instances
16:42:13 <dansho_> ah
16:42:19 <iqubic> Why do you want higher kinded instances?
16:42:20 <monochrom> Because if you write like "mymethod :: s -> s" that's going to nail s to kind Type.
16:42:21 <jle`> they're just there to help with inference
16:42:53 <jle`> look at for example the Functor typeclass, which is higher-kinded
16:43:06 <jle`> the definition is `class Functor f where fmap :: (a -> b) -> f a -> f b
16:43:14 <jle`> kind inference infers that f :: Type -> Type
16:43:34 <jle`> (because a :: Type and b :: Type, and also f a :: Type)
16:43:48 <jle`> in this case we don't need a type/kind annotation, because it is inferred
16:44:29 <jle`> the annotation is mostly only needed if we want to specialize further in a way that kind inference is too general for, maybe in some cases where kind inference doesn't work
16:44:37 <jle`> same as the situation for term values as well
16:44:53 <iqubic> Like what? When would we need to specialize more?
16:44:54 <jle`> you can write `map f [] = []; map f (x:xs) = f x : map f xs`, without a type signature or type annotation
16:45:19 <jle`> you don't *need* a type annotation to make map higher-order...it already *is*, just from its definition
16:45:29 <jle`> same for Functor; you don't need an annotation, since it's already higher-order just from its definition
16:46:02 <jle`> (technically i'm mixing a few terms here, :: i think is a type delcaration when used as map :: ...)
16:46:25 <jle`> iqubic: you might not need to, it just can be useful for documenting or directing how users use your code
16:46:33 <iqubic> Ah. I see.
16:50:12 <ski> (type signature)
16:50:54 <ski> (in `class Foo (s :: k) where ...', it would be a kind ascription)
16:51:00 * hackage astar-monad 0.2.0.0 -   https://hackage.haskell.org/package/astar-monad-0.2.0.0 (ChrisPenner)
16:53:00 * hackage astar-monad 0.2.1.0 -   https://hackage.haskell.org/package/astar-monad-0.2.1.0 (ChrisPenner)
17:04:28 <koz_> I'm looking at https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.Typeable.Internal.html#TypeRep to try and understand TypeRep a bit. Under what circumstances would a TypeRep be built from TrType versus TrTyCon?
17:07:35 <iqubic> I also want to learn about that too.
17:14:01 * hackage lzlib 0.1.0.0 - lzlib bindings  https://hackage.haskell.org/package/lzlib-0.1.0.0 (vmchale)
17:15:06 <lyxia> koz_: TrType represents Type
17:15:52 <lyxia> * <- this thing
17:16:09 <koz_> lyxia: So basically, if whatever I get a TypeRep of anything with kind Type, it'd be built with TrType?
17:16:21 <lyxia> No they get built with TrTyCon
17:16:28 <lyxia> I'm not talking about things of kind Type
17:16:32 <koz_> Ah, I see.
17:16:33 <lyxia> I'm talking about Type itself
17:16:54 <koz_> So basically, the only time we build from TrType is when we take a TypeRep of _literally_ Type?
17:18:38 <koz_> OK, that makes sense.
17:18:45 <lyxia> yeah
17:20:02 <koz_> And what's a TyCon?
17:20:39 <dmwit> Maybe, Int, Either, Bool, Monad are TyCons
17:21:30 <alphonse23_> anybody here know how to use the lambdabot here?
17:21:40 <dmwit> ?where justask
17:21:40 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
17:22:10 <alphonse23_> ?help
17:22:10 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:22:13 <iqubic> > let 1 + 1 = 3 in 1 + 1
17:22:15 <lambdabot>  3
17:22:24 <iqubic> I love that.
17:22:36 <alphonse23_> ?list
17:22:36 <lambdabot> What module?  Try @listmodules for some ideas.
17:22:49 <alphonse23_> listmodules I guess there's a lot
17:22:52 <alphonse23_> how do you run code?
17:23:11 <alphonse23_> ?help run
17:23:11 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
17:23:13 <dmwit> You may prefix a pure expression with `> `.
17:23:16 <koz_> dmwit: So it's... a representation of the name of a (possibly higher-kinded) type?
17:23:18 <alphonse23_> >(\x y z -> x * y + z) 2 3 5
17:23:20 <iqubic> start your message with >
17:23:41 <alphonse23_> ?run (\x y z -> x * y + z) 2 3 5
17:23:43 <lambdabot>  11
17:23:56 <alphonse23_> okay, there just ?run then expression, and the answer is correct
17:24:05 <iqubic> yes.
17:24:33 <alphonse23_> ?run (\x y z -> x * y + z) 2 3 6
17:24:34 <lambdabot>  12
17:25:30 <dmwit> koz_: Not any old type, specifically a type constructor. That is, the new names declared by `class`, `data`, or `newtype`.
17:25:44 <koz_> Ah.
17:25:46 <dmwit> koz_: For example, `Either Int` is not a type constructor, because it is not *just* the name.
17:25:55 <koz_> dmwit: What about 'Int'?
17:26:09 <dmwit> Int is a type constructor. That's why I included it in my list of examples at the beginning. =)
17:26:56 <koz_> dmwit: Yeah, I guess I should read more carefully. Thanks!
17:27:01 <dmwit> (There's probably also a TyCon for `[]` and the various tuple type constructors, even though those technically don't have a corresponding `data` declaration.)
17:28:07 <dmwit> koz_: If it helps, think by analogy to "data constructor". The data constructors for `Maybe ()` are `Nothing` and `Just`. `Just ()` is a fine term, but not a data constructor.
17:28:53 <koz_> So, if I understand it correctly, TypeRep Int would be something like TrTyCon <fingerprint thingo> <TyCon for Int> <an empty list> TrType?
17:30:11 <dmwit> That looks right to me.
17:30:29 <koz_> OK, good to know.
17:39:32 <koz_> Where can I report issues with base documentation?
17:40:41 <hpc> http://hackage.haskell.org/package/base has a maintainer email and bug tracker listed :D
17:40:59 <koz_> hpc: Lol, thanks, I guess I need to lern 2 reed.
17:41:20 <koz_> Said link 404s.
17:41:24 <koz_> Guess that's _two_ issues now...
17:41:39 <hpc> lmao
17:41:50 <hpc> btw, the only reason i knew to look there is package databases in other languages that lack the info when i wanted it to be there
17:41:51 <koz_> In Soviet Russia, bugs find you! <-- my life
17:42:03 <hpc> i looked at hackage for comparison and it had everything i could have hoped ffor
17:42:15 <hpc> for all the crap cabal gets, we really are spoiled packaging-wise
17:42:46 <dmwit> Some people think ./configure works well. Man.
17:42:52 <dmwit> I'll take cabal over that any day.
17:46:00 <orzo> Is there a way to make stack behave as if there is no stack.yaml?
17:46:42 <orzo> particularly with the "hoogle" command which I am not confident behaves consistently with the "build" command
17:47:10 <lyxia> koz_: https://gitlab.haskell.org/ghc/ghc
17:47:20 <koz_> lyxia: Never mind found it.
17:47:29 <lyxia> np
17:57:16 <koz_> OK, ended up turning into _three_ documentation bugs lawl.
17:57:30 * hackage vega-view 0.3.0.2 - Easily view Vega or Vega-Lite visualizations.  https://hackage.haskell.org/package/vega-view-0.3.0.2 (DouglasBurke)
17:58:44 <lyxia> nice
17:58:48 <iqubic> hw?
17:59:02 <koz_> iqubic: Hot water?
17:59:06 <koz_> iqubic: Hardware?
17:59:09 <iqubic> *how?
17:59:35 <iqubic> how did you find documentation errors?
17:59:37 <koz_> iqubic: Missing link to a paper which is available, broken link under 'Bug tracker' for base... and no bug template for submission of documentation issues. :P
17:59:42 <koz_> iqubic: By accident.
17:59:58 <koz_> I live in Soviet Russia - bugs find me.
18:00:08 <iqubic> Are these GHC/Base issues?
18:00:26 <koz_> Yes, they are all to do with base, except the last, which is to do with the bug reporting structure around GHC/base.
18:00:36 <iqubic> I see
18:01:53 <iqubic> koz_: I finished reading Thinking With Types last night.
18:01:59 <koz_> iqubic: Once, I take it?
18:02:16 <iqubic> I still have no clue what a Sigma type is, but I guess that means I need to re-read it.
18:02:25 <koz_> Sigma is a dependent pair I think.
18:02:29 <iqubic> Yes, this was the first time I finished reading it.
18:02:32 <koz_> You will need to do a _lot_ of re-reading.
18:02:41 <koz_> I'm on reading four at least, more for some sections.
18:02:42 <iqubic> koz_: That's correct.
18:02:57 <iqubic> A sigma type is a dependand pair.
18:03:07 <iqubic> I have no idea what a dependent pair is though.
18:03:25 <EvanR> a pair where the type of the right element depends on the value of the left element
18:03:46 <koz_> Introduction to Singletons actually mentions this concept.
18:03:52 <koz_> (in the very first part even)
18:04:12 <EvanR> as opposed to a normal, non-dependent pair type, A x B. All 1st elements have type A, all 2nd elements have type B, period
18:04:51 <iqubic> What is an example of a simple dependent pair.
18:04:53 <iqubic> ???
18:04:56 <iqubic> :t filter
18:04:57 <lambdabot> (a -> Bool) -> [a] -> [a]
18:04:58 <EvanR> for pairs (a,b) of type Sigma[x:A] P(x), a:A and b:P(a)
18:05:01 <koz_> iqubic: (n, Vector n a)
18:05:15 <koz_> (with a tonne of simplification)
18:05:38 <hpc> a perhaps uselessly simple one is
18:05:53 <EvanR> maybe not
18:05:56 <hpc> ((b :: Bool), (if b then Int else String))
18:06:08 <hpc> that's equivalent to Either Int String
18:06:12 <EvanR> if an algorithm returns an unknown length Vector, you may want to know the runtime value, so you pair it
18:06:20 <EvanR> oh
18:06:21 <koz_> Example: serialization.
18:06:29 <hpc> EvanR: slow typer ;)
18:07:03 <orzo> How is it that hoogle for stack lts-5.4 gives me hits for ghc api for ghc 8.6.5?  I don't think that compiler would have existed when lts-5.4 was released.
18:07:25 <iqubic> filterVec :: (KnownNat n, KnownNat m, n => m) => (a -> Bool) -> Vec n a -> (m, Vec m a)
18:07:30 <iqubic> I think that's right.
18:07:59 <EvanR> in this situation, it seems like you are picking m. It's polymorphic
18:08:12 <iqubic> Oh. Yeah. You don't get to pick m.
18:08:37 <iqubic> I'm not sure how to write the type of filterVec to be honest.
18:08:55 <hpc> oh, is that (>=) as well?
18:09:00 <iqubic> Yes.
18:09:05 <koz_> iqubic: It'd be more like filterVec :: (KnownNat n) => (a -> Bool) -> Vec n a -> (exists m . (KnownNat m, m <= n) => m, Vec m a)
18:09:18 <koz_> (admittedly that's not quite correct)
18:09:25 <hpc> or perhaps
18:09:30 <EvanR> at least you can see you don't get to pick m
18:09:32 <iqubic> How do you encode exist in haskell with Singletons?
18:09:46 <koz_> iqubic: Singletons has a Sigma specifically for cases such as these.
18:09:51 <koz_> But that's got nothing to do with it.
18:09:56 <iqubic> Really?
18:10:13 <hpc> exists isn't quite the thing here
18:10:21 <koz_> hpc: Oh?
18:10:34 <hpc> there's a concept in dependent type systems of having (value :: type) in the type signature, and referring to value later
18:11:05 <iqubic> So how would you write this in Haskell?
18:11:35 <hpc> filterVec :: (a -> Bool) -> Vec n a -> Sigma (m :: Nat) (m <= n, Vec m a)
18:11:38 <hpc> or something like that?
18:11:41 <koz_> iqubic: Either use a CPS-style thing, or write SomeVec which 'hides' this information.
18:11:50 <EvanR> whats wrong with exists m there
18:11:53 <koz_> Again, that's in Introduction to Singletons.
18:11:57 <koz_> Part 2 I believe.
18:12:17 <koz_> (well, actually, there's a third option in _this specific case_, which is what vector-sized uses)
18:12:31 <iqubic> What does it do?
18:12:33 <EvanR> i should pull out the dependent haskell guide
18:12:35 <hpc> EvanR: well, maybe it is right but it doesn't quite show off dependent pairs i think
18:12:37 <koz_> (which is to write a pattern around Vector called 'SomeVec' which lets us treat a Vector as if it were sized, but we don't know the size)
18:12:45 * hpc is bad at higher-ranked types
18:12:51 <iqubic> Ah. I know what SomeVec does.
18:13:11 <EvanR> so SomeVec is a form of fake sigma
18:13:24 <koz_> EvanR: Yeah, specifically possible in this case because Vector knows its size at runtime.
18:13:34 <koz_> It's more efficient than packaging it up with an existential.
18:13:43 <iqubic> So when would you ever want to use Sigma?
18:13:47 <iqubic> data Sigma (s :: Type) :: (s ~> Type) -> Type where
18:13:53 <iqubic> (:&:) :: forall s t fst. Sing (fst :: s) -> (t @@ fst) -> Sigma s t
18:14:00 <EvanR> when your syntax for it doesn't suck
18:14:01 <koz_> iqubic: Serialization is one time.
18:14:02 <iqubic> That's a mouthful.
18:14:05 * hackage antiope-s3 7.3.2 - Please see the README on Github at <https://github.com/arbor/antiope#readme>  https://hackage.haskell.org/package/antiope-s3-7.3.2 (arbornetworks)
18:14:39 <koz_> (again, example from Introduction to Singletons lol)
18:14:45 <koz_> (am I the ghost of jle`?)
18:14:48 <iqubic> That Sigma type is a mouthful.
18:14:59 <koz_> iqubic: Welcome to 'Haskell isn't really a dependently-typed language yet'.
18:15:01 * hackage antiope-core 7.3.2, antiope-swf 7.3.2, antiope-messages 7.3.2, antiope-contract 7.3.2, antiope-sns 7.3.2, antiope-optparse-applicative 7.3.2, antiope-athena 7.3.2, antiope-dynamodb 7.3.2, antiope-sqs 7.3.2 (arbornetworks)
18:15:34 <EvanR> sigma syntax https://imgur.com/a/QnFtbyg
18:15:41 <iqubic> koz_: I really want better dependent types.
18:15:47 <EvanR> sigma introduces variable x
18:15:54 <EvanR> similar to forall x
18:15:54 <koz_> I am also contractually obliged to mention Idris at this point. :P
18:16:09 <iqubic> Idris is great.
18:16:16 <hpc> oh, that's a good way of putting it
18:16:21 <iqubic> But I don't want to learn another langauge right now.
18:17:10 <koz_> I am amused that all the issues I've ever reported to the GHC team have been documentation-related.
18:17:12 <hpc> in "forall vars. the rest of the type", "the rest of the type" depends on the types that "vars" are
18:17:29 <hpc> in "sigma var. the rest of the type", "var" is something like Int
18:17:41 <hpc> but then "the rest of the type" depends on the value of it
18:17:49 <EvanR> no var is something like 5
18:17:49 <hpc> so in the rest of the type it's concerned about 0, 1, etc
18:17:55 <hpc> rather than Int or such
18:17:57 <EvanR> something like an Int
18:18:18 <hpc> er, correction - "sigma (var :: type). the rest of the type"
18:19:48 <EvanR> yeah so that is what is wrong with exists
18:19:50 <hpc> without any syntax sugar, it's something like "sigma type (\var -> the rest of the type)", but nobody likes to write it that way
18:20:24 <koz_> EvanR: Yeah, I guess that's what I meant there - you don't actually _need_ dependent pairing for this case.
18:20:58 <koz_> You can just do filterVec :: (KnownNat n) => (a -> b) -> Vec n a -> (exists m . (KnownNat m, m <= n) => Vec m a))
18:21:18 <koz_> (again, assuming exists were a thing.
18:21:21 <koz_> )
18:21:28 <iqubic> what is an example of a function that would be a whole lot better with Sigma.
18:21:37 <koz_> iqubic: Serialization, lawl.
18:22:15 <EvanR> for pairing a length with a Vec you have SomeVec 
18:22:22 <iqubic> I see.
18:22:31 <hpc> printf is a good one
18:22:38 <hpc> the type of printf depends on the value of a format string
18:22:49 <EvanR> that would be a Pi
18:23:01 <iqubic> What is Pi?
18:23:08 <EvanR> the opposite of sigma
18:23:14 <iqubic> Huh? How?!?!
18:23:29 <koz_> iqubic: A dependent product.
18:23:36 <koz_> Sigma and Pi show up together in maths. A lot.
18:23:42 <iqubic> How is Sigma a dependent sum?
18:23:48 <EvanR> ... a function f that has type Pi[x:A] P(x) takes any value of type A but the return type depends on the value of x
18:23:48 <koz_> iqubic: By definition.
18:24:02 <koz_> We can just say 'Sigma means dependent sum' and have that be a thing.
18:24:06 <iqubic> And what is a dependent product?
18:24:17 <koz_> iqubic: Read what EvanR just posted.
18:24:18 <EvanR> don't say dependent product, everyone will be confused
18:24:43 <iqubic> I'm just echoing what koz_ said.
18:25:05 <EvanR> Pi is dependent functions, Sigma is dependent pairs
18:25:18 <koz_> EvanR: Why is 'dependent product' confusing terminology?
18:25:25 <EvanR> A x B is a product... pairs
18:25:33 <EvanR> which is Sigma...
18:25:37 <hpc> iqubic: say you had data Three = One | Two | Three, and so on for One, Two, Four, etc
18:25:47 <koz_> EvanR: Oh yeah, derp.
18:25:53 <koz_> I'll just be quiet now. :P
18:25:55 <hpc> iqubic: when you write Sigma (x :: Three) (f x)
18:26:15 <hpc> iqubic: the number of values that type has is the number of values in the type (f One)
18:26:20 <hpc> plus the number of values in the type (f Two)
18:26:22 <hpc> plus etc etc
18:26:29 <iqubic> I see.
18:26:38 <hpc> and when you loop like that with regular numbers over a function, that's a big-sigma sum
18:26:48 <iqubic> I get it.
18:27:12 <iqubic> I think I'm going to need a large tuturial when Dependent Haskell arrives.
18:27:33 <EvanR> i was going to say, we talk a lot of dependent stuff in here, but have to make up the syntax each time
18:27:34 <hpc> "algebraic types" implying the entirety of algebra is sometimes rather overwhelming ;)
18:27:40 <EvanR> maybe we should learn dependent haskell
18:27:59 <hpc> i still need to wrap my head around taking the derivative of a type
18:28:20 <EvanR> hmm. which type is its own derivative
18:29:00 <iqubic> Somehow lists repersent a Taylor Expansion, or something like that.
18:29:15 <EvanR> a geometric series
18:29:23 <EvanR> 1 + a + a^2 +...
18:29:26 <iqubic> Oh.
18:29:28 <iqubic> Right.
18:29:56 <koz_> Dependent Haskell is still a while off.
18:30:08 <iqubic> Also, trees are still weird in my book.
18:30:11 <EvanR> still there syntax we could be using
18:30:49 <iqubic> data Tree a = Leaf a | Node (Tree a) a (Tree a)
18:30:56 <iqubic> How many inhabitants?
18:32:15 <EvanR> data Identity a = Identity a how many inhabitants?
18:32:26 <iqubic> EvanR: 1.
18:32:31 <iqubic> Or rather a.
18:32:38 <EvanR> not buying it
18:32:45 <iqubic> it has as many inhabitants as 'a' does.
18:32:58 <EvanR> so maybe we only ask about concrete types
18:33:07 <iqubic> I see.
18:33:18 <EvanR> inhabitants of [()], infinite
18:33:22 <hpc> if you're talking about the inhabitants of a type, it has to be a (type-level) expression
18:33:24 <EvanR> or Integer
18:33:31 <hpc> not a data declaration
18:33:47 <hpc> if you then say "what about (Identity a)", then it depends on how you quantify it
18:35:34 <iqubic> I feel like this is where koz_ comes in and says "just use my Finitary library, derive Generic, and derive my GFinitary class, then just get the Cardinality of your type."
18:35:36 <lyxia> You can go pretty far by treating types as combinatorial species, that's what those series do.
18:36:03 <koz_> iqubic: This only works if your type has finitely-many inhabitants.
18:36:05 <koz_> HOWEVER
18:36:15 <koz_> Studying how GFinitary is defined can give you some useful insights.
18:36:58 <koz_> (in fact, this was my primary motivation for even writing it)
18:37:01 <koz_> (theoretically at least)
18:37:19 <iqubic> oh. hehe
18:41:15 <dmwit> EvanR: If you want it to be its own derivative you're gonna need a division operation so you can have a^0/0! + a^1/1! + a^2/2! + a^3/3! + ...
18:41:59 <dmwit> Now there's a great paper about what fractional types could mean. But I'm not sure it preserves the intuition about derivatives being zippers.
18:43:06 <iqubic> data Zipper a = Zipper [a] a [a]
18:43:26 <iqubic> is that the Zipper you are talking about?
18:43:46 <dmwit> That is the type for zippers of lists. But other type formers have zippers, too.
18:44:21 <lyxia> I wonder whether there's some way to fit quotient types in this picture (it's not the same use of "quotient" but, still...)
18:44:27 <iqubic> that zipper forms a comonad if I recall correctly.
18:57:46 <koz_> :t countTrailingZeroes
18:57:48 <lambdabot> error:
18:57:48 <lambdabot>     â€¢ Variable not in scope: countTrailingZeroes
18:57:48 <lambdabot>     â€¢ Perhaps you meant one of these:
19:00:20 <iqubic> countTrailingZeroes :: String -> Int
19:00:22 <iqubic> I think.
19:00:30 <iqubic> Unless I am sorely mistaken.
19:00:46 <koz_> iqubic: Nope, it's a spelling error on my part.
19:00:50 <iqubic> Oh?
19:00:58 <iqubic> :t countTrailingZeros
19:00:59 <lambdabot> FiniteBits b => b -> Int
19:01:05 <iqubic> Oh. I see.
19:17:56 <EvanR> dmwit: i'm glad someone took my question seriously :)
19:18:27 <EvanR> it does make sense, since derivative of list accumulates these factors of n 
19:18:31 <EvanR> n!
19:31:30 * hackage vega-view 0.3.0.3 - Easily view Vega or Vega-Lite visualizations.  https://hackage.haskell.org/package/vega-view-0.3.0.3 (DouglasBurke)
19:38:00 * hackage varying 0.8.0.0 - FRP through value streams and monadic splines.  https://hackage.haskell.org/package/varying-0.8.0.0 (SchellScivally)
19:39:30 * hackage dhall 1.26.0 - A configuration language guaranteed to terminate  https://hackage.haskell.org/package/dhall-1.26.0 (GabrielGonzalez)
19:41:00 * hackage dhall-json 1.4.1 - Convert between Dhall and JSON or YAML  https://hackage.haskell.org/package/dhall-json-1.4.1 (GabrielGonzalez)
19:41:03 <ysangkok> wow dhall has dependent types now :O
19:42:00 * hackage dhall-lsp-server 1.0.1, dhall-nix 1.1.8, dhall-bash 1.0.23 (GabrielGonzalez)
19:42:16 <iqubic> How did dhall get dependent types before Haskell?
19:44:24 <koz_> What's the difference data Foo = Foo !Word8 !Word8 and data Foo = Foo Word8 Word?
19:44:27 <iqubic> Also, what is dhall?
19:44:33 <koz_> s/Word?/Word8?/
19:44:41 <koz_> iqubic: It's a very Haskelly configuration language.
19:44:48 <koz_> Kinda like JSON/YAML/etc.
19:44:52 <iqubic> The ! makes the fields strict.
19:45:02 <koz_> iqubic: What does it mean for a field to be strict?
19:45:09 <iqubic> So the values of those parameters can't ever be thunks.
19:45:19 <iqubic> I know nothing beyond that. Sorry.
19:45:36 <koz_> What's the advantage of that? I kinda vaguely see it, but not clearly enough to really be sure.
19:46:35 <iqubic> I don't actually know.
19:46:44 <ysangkok> predictable performance, i'd say
19:46:44 <maerwald> iqubic: is it turing complete?
19:46:57 <iqubic> is what turing complete?
19:47:02 <koz_> maerwald: Deliberately not by design.
19:47:05 <maerwald> dhall
19:47:06 <koz_> I assume you were asking me?
19:47:10 <maerwald> koz_: good!
19:47:15 <koz_> ysangkok: What do you mean by that?
19:47:31 <koz_> maerwald: In fact, it's even stronger - every Dhall file has a normal form.
19:47:47 <koz_> (well, every _valid_ Dhall file)
19:48:23 <maerwald> I like their design philosophy.
19:48:28 <maerwald> https://github.com/dhall-lang/dhall-lang#design-philosophy
19:48:30 <ysangkok> well since it can't contain thunks, you know it will evaluate when you construct it. let's say one of the fields is very expensive to evaluate, you'd be surprised to see the computation occur only when you extract the value
19:48:38 <koz_> ysangkok: Ah, I see.
19:48:43 <koz_> OK, that makes sense, thanks.
19:49:28 <ysangkok> but i am simplifying of course... merely extracting the value won't necessarily force it to be evaluated :P
19:53:33 <ysangkok> here is a thread about the different normal forms of haskell : https://www.reddit.com/r/haskell/comments/9z6v51/whats_the_difference_between_head_normal_formhnf/ea6vuz3/
19:57:07 <maerwald> I feel dhall philosophy is opposite of nix: Simplicity, Beginner-friendliness, Consistency ;D
19:57:48 <koz_> % sizeOf (undefined :: Word)
19:57:49 <yahb> koz_: ; <interactive>:41:1: error:; * Variable not in scope: sizeOf :: Word -> t; * Perhaps you meant one of these: `S.size' (imported from Data.Set), `IS.size' (imported from Data.IntSet), `IM.size' (imported from Data.IntMap)
20:03:37 <pikajude> so base-compat doesn't add the Semigroup superclass to Monoid
20:03:46 <pikajude> i'm guessing there's realistically no way to actually do that
20:04:22 <pikajude> do people just use CPP to avoid compiler warnings in this case?
20:07:53 <koz_> pikajude: It's basically what we had to do for vector-sized.
20:08:16 <pikajude> i don't have any philosophical problems with CPP, except for the one where it occasionally causes my formatter to lose its marbles
20:10:33 <koz_> pikajude: Assuming your formatter even supports it at all.
20:10:40 * koz_ squints at ormolu.
20:10:47 <pikajude> well formatters aren't really "supposed" to support CPP as far as i know
20:10:52 <pikajude> they're just supposed to pretend like the lines don't exist
20:11:00 <pikajude> or at least that's what i've read in the issue threads
20:11:01 * hackage vega-view 0.3.0.4 - Easily view Vega or Vega-Lite visualizations.  https://hackage.haskell.org/package/vega-view-0.3.0.4 (DouglasBurke)
20:11:37 <koz_> pikajude: For me, CPP is a regrettable, but necessary, thing. I've had to use it in finitary, and we have to resort to it in vector-sized, in order to support 'not-the-latest' GHC.
20:11:55 <pikajude> yep, sometimes that's how it goes
20:12:09 <pikajude> i guess it's not that bad to be honest. i already have to disable brittany on one of my source files because it doesn't like my quasiquoter usage
20:12:12 <koz_> (in my case, NoStarIsType and the fact that Down only went Generic relatively recently)
20:12:55 <pikajude> in this specific case, i'm pretty sure all my CPP defs could be stuck in a separate include file
20:41:10 <dmwit> koz_: data Foo = Foo !Word8 !Word8 means "everywhere the data constructor Foo appears, replace it with \x y -> x `seq` y `seq` Foo x y"
20:41:45 <dmwit> (N.B. not \x -> x `seq` \y -> y `seq` Foo x y)
20:42:22 <dmwit> (Why not? I don't know.)
20:44:18 <jle`> for me i think of it in a way that i believe is equivalent ... "everywhere you pattern match on Foo x y -> z, replace it with Foo x y -> x `seq` y `seq` z"
20:44:53 <dmwit> It's similar but not identical: if you put the seq's in your lambda, they are "done" only once.
20:55:44 <pikajude> so I'm writing a printf library, right
20:56:28 <pikajude> if I wrap Data.Text.Lazy.Builder in a newtype of (Builder, Int) to track its length (for zero-padding and such), will it then completely ignore all the append-related optimization rules that are defined in the text package due to the newtype wrapping?
20:57:29 <pikajude> or better yet, how do I teach myself to figure these things out
21:08:04 <dmwit> "append-related optimization rules"?
21:11:00 <pikajude> yea like at the bottom of http://hackage.haskell.org/package/text-1.2.4.0/docs/src/Data.Text.Internal.Builder.html
21:15:12 <dmwit> Yep, you'll need to inline stuff that calls append if you want those rules to fire.
21:15:30 <pikajude> ok
21:15:39 <dmwit> And maybe stuff that calls ensureFree/writeAtMost as well.
21:15:41 <jle`> pikajude: you can also manually check if rules fire when you think they do
21:15:45 <jle`> trial and error
21:15:57 <dmwit> There's a tool out there that lets you assert that rules are firing, let me see if I can remember what it's called...
21:17:08 <dmwit> http://hackage.haskell.org/package/inspection-testing
21:17:35 <pikajude> oh cool! thanks
21:56:39 <pikajude> is there a way to check hackage for doc build status?
21:59:30 * hackage lio 0.11.7.0 - Labeled IO Information Flow Control Library  https://hackage.haskell.org/package/lio-0.11.7.0 (DeianStefan)
22:03:09 <quiet_laika[m]> i have what is very probably a dumb question
22:04:10 <quiet_laika[m]> when is and isn't (P)HOAS applicable when writing a functional PL?
22:05:06 <quiet_laika[m]> sdiehl's WYAH leads me to believe that PHOAS isn't strictly necessary for native compilation, and helps more in an interactive interpreter, but that doesn't seem obvious to me
22:05:37 <quiet_laika[m]> because i would imagine that translating from source code to machine code would still, at some level, require resolving name bindings? have i just misunderstood WYAH?
22:06:49 <iqubic> What is WYAH?
22:09:04 <ski> @where WYAH
22:09:04 <lambdabot> "Write You a Haskell" (unfinished) by Stephen Diehl in 2015- at <http://dev.stephendiehl.com/fun/>
22:20:00 * hackage network-byte-order 0.1.1.1 - Network byte order utilities  https://hackage.haskell.org/package/network-byte-order-0.1.1.1 (KazuYamamoto)
22:58:52 <Digit> hi #haskell.  i saw this https://hackaday.com/2019/09/11/lambdas-for-c-sort-of/ and thought of you.  n_n
23:02:05 <dmwit> Lambdas are cool and all, but they don't really come into their own unless they can close over things, and these ones can't.
23:04:15 <dmwit> (This is the usual problem with "just pass function pointers, C is a functional programming language lol". It can be done, but you need a protocol and the usual trick uses void*, and it gets very ugly very fast.)
23:06:10 <Rembane> Can you make a sweet macro that emul... why not just write a LISP? 
23:06:45 <dminuoso> Im sure there's some compiler extension in GCC that is turing complete..
23:14:06 <jgt> in `all (`elem` (map toLower t)) ['a'..'z']` I was told that `elem` is slow because it works on lists, and that I should pick a faster data structure. I was thinking of using a map, but if I understand correctly, `elem` is O(n) and Map.lookup is O(log n). Is that right?
23:14:56 <jle`> you can get something better with Set, yeah, which is log n instead of n.  with 'member', not 'elem'. but, neither is as fast as t >= 'a' && <= 'z'
23:15:05 <dminuoso> jgt: Sure. Depending on the size the drastic memory overhead of lists might be noticeable too.
23:15:23 <dminuoso> (They are implemented rather inefficiently for large data sets)
23:15:33 <jle`> * t >= 'a' && t <= 'z'
23:15:35 <jle`> or isAlpha t
23:16:10 <jgt> jle`: yeah I looked at Set.member too, but it has the same performance as Map.lookup
23:16:19 <jle`> hm, i misread the original problem
23:16:39 <jle`> jgt: `Set a` is just `Map a ()` 
23:16:46 <cheater> hi
23:16:50 <jle`> so you'd just be using set vs. map to save the redundant leaf
23:16:50 <jgt> jle`: ah, of course
23:17:37 <jgt> dminuoso: I wouldn't normally care about the performance here, but I'm going through the Haskell course on Exercism to fill gaps in my knowledge (of which there are many). Oh, the perils of having no formal education and being self-taught.
23:18:16 <jle`> looks like it's a function to check for pangrams?
23:18:17 <jgt> the question from my mentor is "Do you know of a data structure that would be faster for this?"
23:18:23 <jgt> jle`: yes, exactly
23:19:29 <jle`> hm yeah, just replacing elem, i'd use Set if you're just looking fo ra better structure
23:19:43 <jle`> in fact you can turn both t and alphas into a set
23:20:01 <jle`> to replace all as well
23:20:43 <jle`> but yeah, a quick single-change improvement would pobably be all (`S.member` S.fromList (map toLower t)) ['a'..'z'], since this also eliminates duplicates from t
23:20:47 <jle`> making the search quicker
23:21:10 <jle`> whereas (`elem` map toLower t) would require searching over potential duplicate letters as well 
23:21:47 <jgt> jle`: turning lists into sets is what I normally do to improve performance (since list is the wrong choice usually anyway), but I'm confused about the performance characteristics of each approach
23:22:14 <jgt> if Set.member is O(log n), then what is `elem`? I thought it was O(n)? Isn't that better?
23:22:19 <jle`> yeah, the first one would be O(n) in the length of t, but the set way would be constant-time
23:22:39 <jle`> after the initial converting-to-set
23:23:04 <jle`> jgt: log n, without considering constant times, better than n
23:23:05 <jgt> is constant-time synonymous with O(1)?
23:23:27 <pikajude> yes
23:23:40 <jle`> yes 
23:23:47 <jle`> O(log n) is "better" than O(n), in the asymptotic case
23:23:59 <jle`> but also remember that `member` is O(log n) in the size of the set, not in the length of t
23:24:06 <jle`> and the size of the set is always going to be around 26
23:24:15 <jle`> so member is essentially constant-time in the length of t here
23:24:36 <jle`> it's O(1) in the length of t
23:24:37 <jgt> right
23:24:42 <jgt> thanks for the explanation
23:25:01 <jle`> but, constructing the set itself is going to be O(log n) in length of t. but you only have to do this once
23:25:06 <jgt> I wouldn't have guessed that O(log n) is better than O(n), but then I don't even have a high-school maths grade
23:25:32 <pikajude> the smaller the number inside O the better
23:25:53 <jle`> jgt: here's the intuition that i teach for helping comparing different asymptotics: think of the behavior under doubling of n
23:25:53 <pikajude> unless you're writing a comedy sorting algorithm
23:25:54 <dmwit> You can do even better than using Set.
23:25:59 <dmwit> Can you think of a way?
23:26:07 <jle`> jgt: for O(n), doubling n will double the operations
23:26:15 <jle`> jgt: for O(log n), doubling n will increase the operations by a fixed amount
23:26:22 <dmwit> (You can do an O(1) thing instead of O(log n).)
23:26:36 <jle`> ie if log base 2, 1,2,4,8,16 => 0,1,2,3,4
23:26:49 <dmwit> (Which... should be a pretty strong hint, actually. There's not so many things you can do at all that are O(1). =P)
23:27:03 <jle`> jgt: for O(1), doubling n will not change the number of operations
23:27:14 <jle`> jgt: for O(n^2), doubling n will quadrule the operations, etc.
23:27:52 <dminuoso> It should be said that when you use this big-O notation, at least mention with respect to what cost. So `O(1)` is that a statement about space? time? operations?
23:27:58 <jgt> dmwit: I don't know what the O(1) way would be. I thought that would be set/map, but I was wrong.
23:28:07 <pikajude> hashmap is o(1)
23:28:09 <dminuoso> (jle` did just imply number of operations)
23:28:33 <jle`> dmwit: i don't think you can get away with inspecting an unbounded number of items in the pangram
23:28:38 <jgt> pikajude: not according to the docs? http://hackage.haskell.org/package/unordered-containers-0.2.10.0/docs/Data-HashMap-Strict.html#v:member
23:28:44 <jle`> consider "aaaaa ... aaaabcdefg"
23:28:46 <pikajude> oh really?
23:28:49 <jgt> or maybe I'm looking at the wrong thing
23:28:52 <jle`> where .. is 1000000 characters long
23:28:57 <pikajude> in a google interview the interviewer told me that lookup in a hashmap is constant time
23:29:15 <jle`> ah yeah, constructing the set is O(n), not O(log n), i was wrong earlier
23:29:29 <dminuoso> pikajude: That first depends on the hashmap, and how pick you are about complexity.
23:29:30 <jle`> the lower-bound in operations here is going to be linear on the length of the pangram
23:29:40 <pikajude> yeah i don't know how you could construct a set in less than O(n)
23:30:00 <jle`> but, at least if we turn it into a Set, the 'member' operations will be constant time
23:30:04 <dminuoso> pikajude: If we are taking it to real precision, then essentially most things we consider as having an upper bound O(1) actually have O(sqrt(1))
23:30:14 <dminuoso> Err *O(sqrt(n)) where n models the size of the container.
23:30:20 <dminuoso> (For time complexity)
23:30:28 <dmwit> Okay. Being more careful about the asymptotics: I claim that the elem solution is already O(n).
23:30:38 <dmwit> I mean, the whole damn thing, not just the call to elem.
23:30:52 <dmwit> So switching to a Map does not change the asymptotics.
23:31:01 <jle`> so it turns from O(n*alpha) (the elem solution) to O(n + alpha)
23:31:03 <dmwit> or Set or whatever
23:31:10 <dminuoso> pikajude: And this is justified by the fact that complexity analysis is about asymptotics. Memory access is not constant time, its bounded by the speed of light.
23:31:13 <jle`> but i guess alpha is a constant turn so it's O(n) vs O(n)
23:31:16 <jgt> dmwit: doesn't it? Would it not go from O(n) to O(log n)?
23:31:18 <jle`> *constant term
23:31:24 <pikajude> lol, was gonna say
23:31:29 <dmwit> jle`: No, be precise. It goes from O(n*alpha) to O(n*log n + alpha)
23:31:30 <pikajude> O(sqrt(1)) isn't too bad
23:31:37 <dminuoso> (And blackhole thermodynamics give us an upper limit to how much memory we can stuff inside some volume, so speed of light is the bounding factor of memory access)
23:31:42 <dmwit> jle`: That way I get to make my claim that you can go to O(n + alpha). =)
23:31:49 <jle`> dmwit: not O(n*log(alpha) + alpha) ?
23:31:58 <dmwit> jle`: Sure, if  you're careful.
23:32:00 <jle`> alpha = 26, the size of the alphabet
23:32:05 <dmwit> O(n + alpha) is still better than that.
23:32:31 <jle`> hm. yeah, i suppose now i am not convinced that a change to Set would improve the asymptotics
23:32:52 <dmwit> Right. =)
23:33:20 * jgt wonders if he should feed this discussion back to his mentor
23:33:33 <dmwit> BUT!
23:33:54 <dmwit> Set will almost certainly still be faster than elem, even though the asymptotics are no different. ^_^
23:33:55 <jle`> if we consider *just* the search part, and discount the "assemble into a set" pre-processing, then it goes from O(n*alpha) to O(alpha log alpha)
23:34:09 <dmwit> And using an array with bounds ('a', 'z'), as I've been hinting, will likely be faster still.
23:35:31 * hackage bindings-GLFW 3.3.0.0 - Low-level bindings to GLFW OpenGL library  https://hackage.haskell.org/package/bindings-GLFW-3.3.0.0 (Mokosha)
23:36:16 <jgt> dmwit: thanks. I've never tried using arrays in Haskell. I'll give that a try.
23:36:22 <jle`> hm okay, so overall just turning into a set, it goes from O(n*alpha) to O(n log n + alpha log alpha)
23:36:38 <jle`> so it looks like asymptotically, turning into a set is actually worse
23:36:57 <jle`> unless you are careful
23:37:08 <biggie_smalls> hello Meepsheep i have 1440 gb of quality footage
23:37:27 <biggie_smalls> rafael is with little donald in the camden mc donalds bathroom
23:37:31 <biggie_smalls> 4k and 3d ready
23:37:40 <jgt> â€¦wrong channel?
23:37:45 <jle`> hm no, it should be O(n*alpha) => O(n log alpha + alpha log alpha)
23:37:54 <jle`> even in the naive way
23:38:00 <jle`> so, the same asymptotics either way
23:38:19 <dmwit> You have to be careful: you have to filter out non-alphabetic characters. But it is easy to be careful.
23:38:34 <Meepsheep> sup biggie_smalls
23:38:35 <dmwit> Otherwise it's O(n log unicode + alpha log unicode)
23:38:35 <jle`> jgt: i think your mentor is just asking about the 'all' part, so discounting the pre-processing
23:38:48 <Meepsheep> you gonna have the stream ready soon?
23:38:53 <biggie_smalls> yeah'
23:38:55 <Meepsheep> like next 10 min?
23:38:57 <Meepsheep> sweeet
23:39:00 <biggie_smalls> streaming the cheesy pizza
23:39:07 --- mode: ChanServ set +o dmwit
23:39:11 --- mode: dmwit set +b *!*pop@185.244.215.*
23:39:12 --- kick: biggie_smalls was kicked by dmwit (biggie_smalls)
23:39:16 --- mode: dmwit set +b *!*Meepsheep@*.trippy.lsdfor.fun
23:39:16 --- kick: Meepsheep was kicked by dmwit (Meepsheep)
23:39:23 <jle`> spambots have gotten to the point of tag-teaming now, interesting
23:39:28 --- mode: dmwit set -o dmwit
23:40:44 <jle`> could have done a nice three card monte kind of hustle
23:55:35 <jgt> jle`: well he specifically mentioned `elem`
23:56:44 <jgt> jle`: here's exactly what he said
23:56:46 <jgt> Awesome solution! Syntactically, you don't need parentheses in the operator section. Functions always bind tighter than operators, so it is fine to write: `(`elem` map toLower t)` The only problem with this is that elem :: Eq a => a -> [a] -> Bool is slow on lists - it has to search each element. Do you know of a data structure that would be faster for this?
23:58:33 <dmwit> I'm certain your mentor was hoping you'd consider Set or HashSet. I am less certain they had an Array in mind, but I'm very certain they'd be delighted if you answered with that even if they didn't.
23:58:54 <dmwit> (...even if they didn't have it in mind.)
