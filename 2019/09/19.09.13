00:00:15 <MarcelineVQ> Why so much Just? unfoldr (\n -> if n == 0 then Nothing else Just (swap (quotRem n (fromIntegral @Word8 maxBound)))) (10000 :: Int) ++ [minBound]
00:00:58 <int-e> MarcelineVQ: Because 0 is supposed to produce a non-empty list, but yeah doing it afterwards is arguably clearer.
00:01:31 <int-e> MarcelineVQ: But since my point was that unfoldr makes code less readable... ;-)
00:02:58 <MarcelineVQ> I tend to only combine it with span/break/splitOn for quick dirty parsing
00:03:05 <MarcelineVQ> actually uncons is fun with it too
00:03:32 <koz_> % alignment (undefined :: Word64)
00:03:32 <yahb> koz_: 8
00:04:17 <int-e> > unfoldr (ap ((>>) . guard . (>0)) (pure . swap . flip quotRem (fromIntegral (maxBound :: Word8)))) (10000 :: Int)
00:04:19 <lambdabot>  [55,39]
00:04:36 <koz_> int-e: Dear sweet Cthulhu wat.
00:04:47 <koz_> Did you run that though @pl or something?
00:04:58 <int-e> koz_: no, where'd be the fun in that?
00:06:23 <int-e> @pl (\x -> guard (x > 0) >> pure (swap (quotRem x (fromIntegral (maxBound :: Word8))))
00:06:23 <lambdabot> (line 1, column 83):
00:06:23 <lambdabot> unexpected end of input
00:06:23 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or ")"
00:06:52 <int-e> @pl (\x -> guard (x > 0) >> pure (swap (quotRem x (fromIntegral maxBound)))
00:06:52 <lambdabot> (line 1, column 72):
00:06:52 <lambdabot> unexpected end of input
00:06:52 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or ")"
00:07:03 <int-e> whatever
00:07:53 <int-e> @pl \x -> guard (x > 0) >> pure (swap (quotRem x (fromIntegral maxBound)))
00:07:53 <lambdabot> ap ((>>) . guard . (> 0)) (pure . swap . flip quotRem (fromIntegral maxBound))
00:08:30 <int-e> koz_: But apparently I can't prove that I did that manually :)
00:08:38 <koz_> int-e: Lol.
00:09:08 <koz_> Is being able to @pl by hand the weirdest Haskell flex?
00:09:27 <int-e> koz_: Anyway, ap is the S combinator (when used with the reader monad).
00:10:51 <koz_> Yeah, I recall that one. K is const.
00:10:54 <koz_> And I is id of course.
00:11:19 <int-e> koz_: I learned abstraction elimination for programming Unlambda. And @pl is basically that with some simplifications because there are some fancier combinators like (.) = B around, not just S K and I.
00:11:38 <koz_> int-e: Makes sense.
00:18:31 * hackage protocol-radius-test 0.1.0.1 - testsuit of protocol-radius haskell package  https://hackage.haskell.org/package/protocol-radius-test-0.1.0.1 (KeiHibino)
00:21:01 * hackage some 1.0.0.3 - Existential type: Some  https://hackage.haskell.org/package/some-1.0.0.3 (phadej)
00:38:56 <dminuoso> % :t \g -> do { G a <- g; undefined }
00:38:56 <yahb> dminuoso: Monad m => m G -> m b
00:39:02 <dminuoso> Mmm, shouldn't this incur a MonadFail constraint?
00:39:15 <dminuoso> (Assuming G is a data type of course and not a newtype
00:39:30 <Axman6> It'll just be using Monad's fail
00:55:31 * hackage haskell-src-exts-simple 1.21.1.0 - A simplified view on the haskell-src-exts AST  https://hackage.haskell.org/package/haskell-src-exts-simple-1.21.1.0 (BertramFelgenhauer)
01:08:48 <dminuoso> Ah.
01:11:01 <int-e> dminuoso: if G is the sole constructor of the data type it won't.
01:11:53 <int-e> :t do ((),()) <- undefined; return ()
01:11:54 <lambdabot> Monad m => m ()
01:12:00 <int-e> :t do Just () <- undefined; return ()
01:12:01 <lambdabot> Control.Monad.Fail.MonadFail m => m ()
01:13:33 <int-e> dminuoso: https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail has the (ugh) beautiful concept of an "unfailable pattern" for this.
01:55:36 <day> isn't the library Data.List.Split part of a standard ghc installation?
01:56:31 <merijn> day: No
01:56:43 <merijn> It's from the split package
01:57:10 <sshine> if I do Test.QuickCheck.elements . filter (not . isLetter) $ ['\0'..'\127'], is it likely that the filtering happens at compile-time or is memoized at runtime? how do I reason about this?
01:57:31 <int-e> day: it's shipped with the Haskell Platform though
01:58:11 <merijn> sshine: I would say the answer to both is "probably not" and "no", followed by "why do you think that's important?"
01:58:59 <Ariakenom> sshine: ghc doesnt really evaluate much at compile time
01:59:25 <sshine> merijn, well, okay, I'm happy with any of those answers. I'm comparing this to arbitraryASCIIChar `suchThat` (not . isLetter) which, is my impression at least, is worse because it retries the generator unnecessarily and potentially even gives up along the way.
02:00:03 <merijn> sshine: I mean, if you *really* want it at compile time, you could use TH, but that's a big hammer :)
02:01:19 <sshine> merijn, haha yes.
02:02:29 <cpressey> Hello. Is there a (prescriptive) set of guidelines for or a (descriptive) survey of naming conventions of Haskell modules, particularly how the hierarchy is arranged?
02:03:06 <merijn> cpressey: Not really, afaik
02:03:12 <Ariakenom> badly \end_snideness
02:03:38 <merijn> cpressey: I would say that the "everything under Data/Control" approach is pretty widely regarded as a bit of a mistake :p
02:06:36 <cpressey> merijn: That's unfortunate, but kind of what I expected after searching. Followup question: if one wanted to make such a survey, what would be the best way to get bulk data from hackage.haskell.org?
02:06:53 <sshine> merijn, I always forget that it's Data.Foldable and Control.Applicative.
02:07:17 <merijn> cpressey: I think there's scripts/programs to mirror Hackage locally, but don't ask me which, you can ask around in #hackage
02:07:29 <Rembane> cpressey: This looks fun! http://hackage.haskell.org/api
02:07:34 <Rembane> cpressey: And possibly useful
02:08:06 <merijn> cpressey: I think packages with descriptive names should just use that as top level module
02:08:21 <merijn> cpressey: See, for example, https://hackage.haskell.org/package/pipes
02:08:21 <cpressey> Rembane: aha!
02:08:38 <merijn> cpressey: Or https://hackage.haskell.org/package/turtle
02:09:23 <merijn> cpressey: Keep in mind that module names are, in principle, a global namespace, though. So best to not unnecessarily claim overly "general" module names because that makes it a hassle for them to be used by others
02:11:37 <cpressey> Rembane, merijn: thanks for the pointers, I'll follow them.
02:13:52 <Rembane> cpressey: No worries. Good luck! 
02:14:01 * hackage TotalMap 0.1.1.1 - A total map datatype  https://hackage.haskell.org/package/TotalMap-0.1.1.1 (edwardwas)
02:37:56 * Bish would like to tryout ghcjs but the required haskell version seems to be not supported by gentoo
02:40:40 <lavalike> Bish: what's the required version?
02:42:25 <yoneda> csa
02:42:39 <marrrk> Bish why ghcjs over Purescript?
02:43:59 <sshine> why doesn't 'quickCheck (pure True `suchThat` const False)' give up?
02:44:54 <phadej> sshine: because it doesn't
02:44:58 <phadej> ever
02:45:03 <merijn> sshine: Why would you expect it too?
02:47:10 <Bish> lavalike: 8.2+ i think
02:47:35 <sshine> I thought that `suchThat` could make the generator give up, but I realize that it resizes the generator with (+1) and keeps trying forever.
02:47:38 <Bish> marrrk: well, if i was going to use ghcjs for clientside, it would be to use one language for everything
02:49:56 <lavalike> Bish: if you just need a recent ghc you could try ghcup, its whole install dir is some directory in your user's home
02:50:32 <merijn> You can just install ghc bindists in your home dir too
02:58:57 <Bish> guess i'll need to do something like that
03:15:14 <Bish> did someone ever learn haskell as a first language?
03:15:31 * hackage sized-grid 0.2.0.1 - Multidimensional grids with sized specified at compile time  https://hackage.haskell.org/package/sized-grid-0.2.0.1 (edwardwas)
03:19:28 <jgt> Bish: Julie Moronuki?
03:19:44 <__monty__> There's definitely been people.
03:21:00 <Bish> im super curious how those people react to C
03:21:03 <Bish> or even java
03:21:10 <Bish> when first seeing it
03:21:24 <Bish> wish i knew a person that is open for mental torture
03:22:09 <jgt> my girlfriend is learning JavaScript, and it's quite painful hearing her ask "why is x now 9? I thought x was 10?"
03:22:47 <Bish> there, line 3 says x = 10
03:22:55 <jgt> yeah, pretty much exactly that
03:23:01 <Bish> well, was she studying math before?
03:23:09 <jgt> no
03:23:14 <jgt> but then, neither have I
03:23:27 <Bish> because i only really understood the difference between <=> and = in university
03:23:55 <Bish> and when i started coding = always meant "set" to me
03:24:47 <Bish> .oO(maybe i never understood equal signs because i started coding with 8)
03:41:30 * hackage HsOpenSSL 0.11.4.17 - Partial OpenSSL binding for Haskell  https://hackage.haskell.org/package/HsOpenSSL-0.11.4.17 (VladimirShabanov)
03:53:41 <duncan> I have a question about the containers package. The synopsis suggests that it is suitable for declaring tree-like structures. There is nothing explicit I can find in the documentation, but it seems that using Sequence from it would be a good place to start.
03:54:24 <duncan> Is that a good assumption? The only information I can find in the documentation relates to the implementation of Sequence, which is based on FingerTrees
03:58:08 <lavalike> This package contains efficient general-purpose implementations of various immutable container types including sets, maps, sequences, trees, and graphs.
03:59:48 <lavalike> most of its exported datatypes are trees: Map, Sequence, Set, Tree, for example (check out the .Internal modules for their actual structure)
04:01:51 <duncan> huh, I didn't notice Data.Tree(that was a bit silly of me)
04:02:37 <duncan> Data.Tree and Data.Graph happen to be exactly what I'm looking for :>
04:02:41 <duncan> thanks.
04:02:53 <lavalike> they sometimes are! np
04:22:44 <d12frosted> Hi everyone! Right now I am toying with quickcheck + quickcheck-classes and I have stumbled upon a problem I am unable to solve by myself. So maybe someone here could help me? :) 
04:23:12 <d12frosted> So basically, I have a data type `Parser` defined as `newtype Parser a = Parser { parse :: String -> Result a }`. And I want to check functor/applicative laws for it.
04:24:20 <d12frosted> Writing Arbitrary instance is easy, but `functorLaws (Proxy :: Proxy Parser)` requires `Eq` and `Show` instances for a `Parser`. And this is where I am stuck. Maybe I am missing something trivial. How can I provide these instances? :) 
04:24:29 <tejok[m]> hey there, i have the following `.cabal` file https://pastebin.com/YUA5iF64 which I'm trynig to build on NixOS using `cabal2nix`, but when I do `cabal build` I'm getting `Encountered missing dependencies: postgresql-simple ==0.6.*`, any idea why? (I see nix downloaded the dep when opening the shell... so I'm confused...)
04:24:57 <d12frosted> I've tried using `Function` from https://www.stackage.org/haddock/lts-14.4/QuickCheck-2.13.2/Test-QuickCheck-Function.html#v:functionMap, but `:->` doesn't provide Eq/Show.
04:29:11 <merijn> tejok[m]: Which version of cabal do you have installed?
04:29:33 <tejok[m]> merijn: 2.4.1.0
04:29:52 <merijn> I wonder if cabal2nix relies on build bein v2-build
04:30:02 <merijn> otoh, I know nothing of Nix, so...
04:30:27 <tejok[m]> mmm.. I do'nt think so, because before I did add the dep it was working even thought it was showing a warning about v2
04:30:32 <dminuoso> Mmm. Say I have two large sets of some data that have fields. I want to produce a complete listing how they differ in the sense of `data Record = Record ...`, `data Change = Deleted | Added | Modified`, having some `diffSets :: Set Record -> Set Record -> Set (Record, Change)`
04:30:34 <tejok[m]> thanks for investigating anyway :)
04:30:44 <dminuoso> Does containers have some primitive suitable for this?
04:31:08 <merijn> @hackage tree-diff -- dminuoso 
04:31:08 <lambdabot> http://hackage.haskell.org/package/tree-diff -- dminuoso
04:31:56 <merijn> tree-diff is freaking magic for visualising diffs between complex records :)
04:32:42 <dminuoso> merijn: Mmm, gdiff is mentioned on that and might actually fit my bill nicely. Cheers. :)
04:33:13 <dminuoso> (tree-diff is rather dependency heavy sadly)
04:33:33 <dminuoso> Or is there some tree-diff package around for just plain `diff :: Eq a => [a] -> [a] -> [Edit a]` ?
04:33:53 <merijn> Diff?
04:34:55 <dminuoso> Ohh wait I see. Yes.
04:34:58 <dminuoso> I didnt read the API right.
04:35:32 <d12frosted> Ok, show is easy: show (Parser p) = show $ function p. Didn't run, so not sure if it works. But still can't find a solution for Eq :( 
04:36:20 <dminuoso> d12frosted: Functor laws is as simple as showing `fmap id = id`
04:36:50 <dminuoso> d12frosted: (This would be easiest on paper/in a comment)
04:37:14 <dminuoso> (The other law is not necessary to prove, it comes from a free theorem in Haskell)
04:39:35 <d12frosted> dminuoso: yeah, I know that :) but applicative is not that simple :) 
04:39:55 <d12frosted> dminuoso: regarding free theorem - I always tend to forget why it so, need to refresh my memory
04:41:51 <dminuoso> d12frosted: https://hackage.haskell.org/package/checkers-0.5.2/docs/Test-QuickCheck-Classes.html#v:functor
04:42:45 <dminuoso> d12frosted: The Eq instance is going to be tricky because you have an infinite domain.
04:43:34 <boxscape> did the free theorem have something to do with the fact that the behaviour is independent of the types a and b? (assuming fmap :: (a -> b) -> f a -> f b)
04:43:37 <dminuoso> d12frosted: Perhaps writing out the proofs in comments is indeed easier.. even for applicative. :)
04:43:45 <dminuoso> boxscape: https://www.schoolofhaskell.com/user/edwardk/snippets/fmap
04:43:54 <boxscape> thanks
04:48:35 <d12frosted> dminuoso: indeed :) at least I can write these tests for specific domain (e.g. Parser String), but not using the classes lib.  
04:51:57 <d12frosted> btw, as far as I understand there can be only one valid definition of functor. what about the applicative? 
04:56:12 <dminuoso> d12frosted: Depending on the data type, multiple can exist.
04:56:23 <dminuoso> d12frosted: [] for example gives rise to several Applicative instances.
04:59:35 <d12frosted> ok, that's what I thought; my attempt to write applicative laws test started with this question - can any type have multiple different valid instances of applicative; my intuition was that the answer is yes, because applicatives are indentical to monoidal functor, and types usually have more than one monoid instance ... but instead of starting with something simple, I've started with String -> f a
04:59:37 <d12frosted> :D 
05:00:04 <dminuoso> d12frosted: Consider this a challenge.
05:00:18 <dminuoso> d12frosted: Without consulting google, try to come up with another Applicative instance.
05:00:27 <dminuoso> (This is actually an easy one, you can trivially come up with at least 2)
05:00:57 <d12frosted> dminuoso: :) it is a challenge, and I accept it
05:01:12 <d12frosted> dminuoso: re 2: are you talking about [] or parser?
05:01:16 <dminuoso> _flow_: Yes, for []
05:01:18 <dminuoso> Err d12frosted :)
05:04:48 <Fimmind> @pl \m n -> m * 10 + n
05:04:48 <lambdabot> (+) . (10 *)
05:09:50 <dminuoso> d12frosted: If you want to do this *very* easily, you could implement it in terms of `class Functor f => Monoidal f where plus :: f a -> f a -> f (a, a), unit :: f ()` (which is nearly isomorphic to Applicative)
05:10:27 <dminuoso> (This can also be easier to verify laws in, since you can directly test for associativity and identity laws)
05:10:58 <dminuoso> Sorry, `where plus :: f a -> f b -> f (a, b)` :)
05:19:17 <sshine> what does '@rev:1' after a Stackage version mean?
05:19:49 <__monty__> sshine: Maybe it's talking about hackage revisions?
05:21:14 <sshine> __monty__, ah, it was uploaded multiple times with the same version attached? quite possibly.
05:38:45 <nil> dminuoso: why "nearly"?
05:39:28 <d12frosted> dminuoso: oki, will think about it
05:40:15 <d12frosted> dminuoso: using Monoidal is a nice trick
05:43:26 <merijn> sshine: Revisions aren't uploads with the same version, Hackage doesn't allow that
05:43:53 <merijn> sshine: Hackage just allows you to update package metadata (most usefully, version bounds)
05:51:47 <d12frosted> dminuoso: hm, I've tried to zip + apply in the <*> definition, but can't come up with a pure for this
05:52:05 <d12frosted> dminuoso: ah wait, it's easy :D lol
05:52:11 <d12frosted> dminuoso: endless list haha
05:52:32 <sm[m]> They’re like.. a version of a version
05:55:06 <d12frosted> dminuoso: wow, really nice
06:01:29 <d12frosted> dminuoso: ah, and the other one is also obvious, at first I tried to play with another order of the <*> result, using reverse, but it didn't work. And now I thought - hey, I apply all functions to first elelement and concat with result of all functions <*> tail of the elements
06:01:56 <d12frosted> dminuoso: basically, `fs <*> (Cons x xs)   = conc (($ x) <$> fs) (fs <*> xs)`
06:03:59 <d12frosted> dminuoso: thanks for the nice task ;) 
06:27:39 <ddk> Hi All
06:28:04 <ddk> I have a confusion in understan
06:29:07 <ddk> I have a confusion in understanding the notion of hedgehog's state machine based test would some one help me understand the `Update` function in `Command`?
06:30:47 <ddk> ??
06:30:58 <iqubic> :t scanl
06:30:59 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
06:31:05 <iqubic> :t scanr
06:31:06 <lambdabot> (a -> b -> b) -> b -> [a] -> [b]
06:31:26 <iqubic> :t unfoldr
06:31:27 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
06:31:45 <ddk> some one with state machine based tests hedgehog ?
06:35:03 <iqubic> > foldr f [a, b, c]
06:35:05 <lambdabot>  error:
06:35:05 <lambdabot>      • Could not deduce (FromExpr [Expr]) arising from a use of ‘f’
06:35:05 <lambdabot>        from the context: (Foldable t, Show a)
06:37:27 <ddkkddkk> Hello All is this the write Haskell irc channel ?
06:37:56 <iqubic> ddkkddkk: Yes it is.
06:38:53 <ddkkddkk> iqubic: Thanks, I have a question about Hedgehog's State Machine Based Tests, about the function Update, if someone can help me get the intuition ?
06:43:58 <ddkkddkk> I see the channel is not as active as before
06:44:55 <ddkkddkk> no one came for help
06:46:26 <ddkkddkk> ok leaving everyone seems busy doing their own work
06:54:00 * hackage I1M 0.0.3 - Code for the Haskell course taught at the University of Seville.  https://hackage.haskell.org/package/I1M-0.0.3 (Jose_A_Alonso)
06:56:01 * hackage lens 4.18.1 - Lenses, Folds and Traversals  https://hackage.haskell.org/package/lens-4.18.1 (ryanglscott)
07:05:47 <c_wraith> oh hey.  is that lens update for ghc 8.8?
07:07:25 <c_wraith> it seems it was.  Dependency check no longer fails
07:07:31 <Taneb> c_wraith: 4.18 was ghc 8.8, this fixes profiling builds
07:07:40 <c_wraith> ah, cool
07:08:06 <c_wraith> ... how does a haskell package mess up its profiling builds?
07:08:23 <Taneb> By setting "cpp-options: traditional" on GHC 8.8
07:10:16 <tabaqui2> I need to build some library from source
07:10:20 <tabaqui2> and it requires runhaskell
07:10:31 <tabaqui2> but I want to make it in my stack environment
07:10:35 <c_wraith> that is a strange requirement
07:10:41 <tabaqui2> which doesn't provide runhaskell
07:10:59 <tabaqui2> I tried to replace it with alias "stack runghc --" but it didn't help
07:11:03 <c_wraith> it needs runhaskell at build time?
07:11:15 <tabaqui2> yeah, it is Apache Thrift
07:11:31 <tabaqui2> it makes preprocessors for different languages
07:12:33 <tabaqui2> what is runhaskell at all?
07:12:51 <c_wraith> it's equivalent to runghc
07:13:02 <c_wraith> Just another name for the same ghc wrapper
07:13:27 <tabaqui2> oh, I found it inside of global .stack-work dir
07:13:47 <tabaqui2> I could parse "stack path" output and make a symlink on it
07:14:24 <Peachpath> oh no I kept changing my nicks and I was logged in this channel 
07:17:48 <tabaqui2> yes, somewhat "PATH=$(stack env --compiler-bin):$PATH ./configure"
07:19:55 <sm[m]> stack exec — runhaskell ...
07:20:49 <sm[m]> or stack exec bash, (do my whole build in here)
07:21:11 <sm[m]> (tabaqui2)
07:21:31 <tabaqui2> like "stack exec ./configure..."
07:22:02 <sm[m]> Yep, but I always write the — to prevent flag confusion
07:22:10 <tabaqui2> stack exec "which runhaskell"
07:22:19 <tabaqui2> Executable named which runhaskell not found on path: ["/home/...
07:23:30 <sm[m]> your quotes are confusing it
07:28:01 <tabaqui2> sm[m]: thanks
07:28:16 <tabaqui2> there are still errors in build, but at least it tries
07:28:55 <tabaqui2> cabal: Use of GHC's environment variable GHC_PACKAGE_PATH is incompatible with
07:28:57 <tabaqui2> Cabal. Use the flag --package-db to specify a package database (it can be used
07:28:59 <tabaqui2> multiple times).
07:29:17 <tabaqui2> do you know anything about this error?
07:29:54 <merijn> Sounds like you (or stack) as setting GHC_PACKAGE_PATH and it's telling you that's not compatible
07:29:59 <merijn> s/as/are
07:30:26 <tabaqui2> stack exec -- echo $GHC_PACKAGE_PATH
07:30:28 <tabaqui2> (empty)
07:34:01 * hackage builder 0.2 - bounded ByteArray builder type  https://hackage.haskell.org/package/builder-0.2 (chessai)
07:35:18 <tabaqui2> "stack exec --no-ghc-package-path" helped
07:38:30 * hackage ideas 1.8 - Feedback services for intelligent tutoring systems  https://hackage.haskell.org/package/ideas-1.8 (BastiaanHeeren)
07:39:31 * hackage ideas-math-types 1.0 - Common types for mathematical domain reasoners  https://hackage.haskell.org/package/ideas-math-types-1.0 (BastiaanHeeren)
07:43:01 * hackage lens-action 0.2.4 - Monadic Getters and Folds  https://hackage.haskell.org/package/lens-action-0.2.4 (ryanglscott)
07:47:16 <hvr> tabaqui2: wouldn't it be easier to use cabal directly? :-)
07:47:46 <tabaqui2> I'm making Dockerfile for future builds
07:48:00 <tabaqui2> and projects will be compiled in stack environment
07:49:42 <sm[m]> tabaqui: alas not everything is happy running inside a stack exec, that message means it's too much
07:49:50 <sm[m]> exec-ing
07:50:20 <sm[m]> aha, you found a fix. Nice.
07:50:30 * hackage sequence-formats 1.4.1 - A package with basic parsing utilities for several Bioinformatic data formats.  https://hackage.haskell.org/package/sequence-formats-1.4.1 (stephan_schiffels)
07:51:30 * hackage sequenceTools 1.4.0.3 - A package with tools for processing DNA sequencing data  https://hackage.haskell.org/package/sequenceTools-1.4.0.3 (stephan_schiffels)
07:51:47 <tabaqui2> anyway, thrift uses Network module from network package without upper dependency bound
07:52:12 <tabaqui2> and right now "make" is failed on this step, so I have to go into the lib dir and run cabal manually
07:52:23 <tabaqui2> not a big deal, actually
08:04:28 <zacts> is Haskell good for writing command line tools?
08:04:31 <zacts> UNIX command line
08:04:45 <merijn> zacts: Yes
08:04:56 <merijn> In fact, I would go as far as calling it great
08:05:03 <zacts> oh nice
08:05:12 <zacts> so can it also do ncurses kinds of things?
08:05:42 <merijn> zacts: For command line parsing there's optparse-applicative, which is by far the nicest/most powerful option parsing library I've used in any language
08:06:02 <zacts> oh nice nice
08:06:09 <merijn> zacts: For terminal UI's there's brick and (recently new) reflex-vty
08:06:16 <zacts> ok
08:06:43 <EvanR> can haskell do command line tools? Yes! Haskell can do that!.... can haskell do ncurses? ...uh.. lunch time!
08:06:57 <tdammers> well, technically ncurses interfaces aren
08:06:58 <merijn> EvanR: It can, you just don't want to use ncurses
08:07:00 <tdammers> 't command line
08:07:09 <geekosaur> nothing can do ncurses sensibly :p
08:07:16 <tdammers> I've seen the acronym "TUI" thrown around occasionally
08:07:17 <merijn> EvanR: Then again, you don't want to use ncurses in other language either, cause it's interface is shit
08:07:18 <zacts> I don't have to use ncurses, but some sort of Terminal UI
08:07:19 <tdammers> ("terminal UI")
08:07:29 <zacts> I have various ideas for command line tools
08:07:56 <merijn> zacts: I actually saw recent package release that should help convince you: https://github.com/mstksg/interactive-plot#readme ;)
08:07:59 <zacts> some might involve audio
08:08:06 <tdammers> I usually start with a CLI to nail the functionality, and then I might either call it quits entirely, or skip right to a web UI
08:08:09 <merijn> Just watch the demo gif
08:08:59 <zacts> cool
08:08:59 <merijn> zacts: I haven't done any audio myself, so no clue how easy that is. OTOH, FFI bindings to C are trivial, so you could always wrap whatever C library people normally use
08:09:11 <zacts> ok
08:09:29 <zacts> how about something like WWW::Mechanize for web stuff?
08:09:52 <zacts> I have lots of different ideas
08:09:59 <zacts> many are textual or web based
08:10:00 * hackage aeson-optics 1.1 - Law-abiding optics for aeson  https://hackage.haskell.org/package/aeson-optics-1.1 (phadej)
08:10:00 <merijn> zacts: reflex-vty also has some demos: https://github.com/reflex-frp/reflex-vty 
08:10:27 <zacts> https://metacpan.org/pod/WWW::Mechanize <-- just in case you aren't familiar with Mechanzie
08:11:07 <merijn> There's a bunch of different http libraries around and multi-threading/concurrency is also pretty easy
08:12:00 <zacts> well, Mechanize has particular fufnctionality. Like, I can submit forms and complete text boxes and navigate pages and stuff, textually.
08:12:46 <zacts> I found this http://hackage.haskell.org/package/hs-scrape
08:13:45 <EvanR> i've done audio a few ways in haskell
08:14:03 <tabaqui2> LeiraSarvo
08:14:06 <EvanR> there are bindings to different libs
08:14:28 <zacts> Ok, I think I will go ahead and learn Haskell.
08:14:37 <EvanR> and some DSLs for generating complex audio
08:14:55 <EvanR> (given some mechanism to play audio)
08:15:02 <zacts> I like Clojure's Overtone
08:15:07 <zacts> into Supercollider I think it is
08:15:15 <EvanR> probably
08:16:34 <merijn> There's some livecoding projects in Haskell too
08:17:04 <EvanR> i tried to find some livecoding videos... coulding
08:17:11 <EvanR> couldnt... probably because they were live :)
08:17:37 <orzo> Why when I output core from ghc do I see case statements that look like haskell case statements when I know that core has a more complicated syntax that includes things like a return type?
08:20:56 <EvanR> maybe you're seeing a simplified version
08:20:56 * hackage hspec-golden 0.1.0.1 - Golden tests for hspec  https://hackage.haskell.org/package/hspec-golden-0.1.0.1 (stackbuilders)
08:21:16 <orzo> but simplified by what simplification rule?
08:23:13 <orzo> i see it with -ddump-simpl and no other options besides -O0
08:23:32 <orzo> how to i see a more raw version?
08:24:39 <orzo> In particular I see "case ds_d1cB of {" which seems to lack the return type annotation
08:25:20 <dmwit> zacts: For ncurses kinds of things, I've been really enjoying my time with brick.
08:25:23 <dmwit> ?hackage brick
08:25:23 <lambdabot> http://hackage.haskell.org/package/brick
08:25:30 <EvanR> orzo: ill check for other options
08:25:36 <zacts> cool re: brick
08:26:56 <zacts> https://github.com/elaye/mushu <-- this looks similar to one idea I have
08:29:28 <EvanR> orzo: yah... dump-simpl dumps "simplifier output", there are other options https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/debugging.html#core-representation-and-simplification
08:36:12 <spoonm> before I give up preparing slides, does anyone here think it's possible to explain functors, applicatives, and monads in under 5 minutes to people who don't really know functional programming?
08:37:08 <Taneb> spoonm: if they know some programming, and are prepared to listen, I believe it is
08:37:42 <spoonm> it's important to explain the three of them in under 5 minutes
08:37:59 <ski> why is it important ?
08:38:47 <ski> you can certainly try to hint at what they're for, i think
08:39:18 <spoonm> well, the really important part is that it can be done in a way people would understand, but the thing is I'm preparing a presentation on those three in a present-something-cool-in-5-minutes thing at uni
08:40:27 <ski> i think you probably need more experience to draw on, to appreciate the point, at least for the latter two
08:40:54 <exarkun> spoonm: What _do_ they know?
08:41:05 <spoonm> exarkun: C and Java, basically
08:41:11 <exarkun> I think there are very few random non-functional programmers who could understand any <=5 min explanation of all those things.
08:41:15 <exarkun> very very few
08:41:46 <spoonm> :(
08:41:46 <ski> if you were told to explain dogs to someone who'd never seen a dog, could you do it in under five minutes ?
08:42:35 <exarkun> people would go away having some general ideas about hair and poop and loud noises
08:42:38 <ski> (including that people take them out for walks, that they need to feel someone is in control, or they'll try to assert control themselves, &c. &c.)
08:42:39 <Taneb> ski: maybe I could if they had experience with other animals, like cats or lizards
08:42:40 <exarkun> it would be a start, probably
08:42:50 <spoonm> depends on the level of understanding you expect me to impart upon that someone, and whether they would be satisfied with something along the lines of "a four legged mammal of this genus and species"
08:42:54 <exarkun> a start is probably what you can hope for in 5 minutes
08:43:00 * ski nods to Taneb
08:43:30 <ski> yea
08:46:51 <spoonm> I see, exarkun 
08:47:00 * hackage happstack-server 7.5.3 - Web related tools and services.  https://hackage.haskell.org/package/happstack-server-7.5.3 (JeremyShaw)
08:47:06 <spoonm> I guess I'll stick to functors and maybe applicatives, then introduce monads the next week
08:47:21 <spoonm> though obviously I won't be able to impart much in 5 minutes
08:48:29 <ski> if you think of functors as "lifting a function operating on elements, to operate on collections/structures", then idioms can be thought of as doing "the same" (in some vague sense), but for multiple-input functions (so given multiple "structures")
08:49:25 <ski> the "collections" thing may be a good thing to start from, but perhaps not to stop there. you might mention parsers, e.g. (without talking about how they're implemented)
08:49:49 <Taneb> Computations that can fail, computations that can log
08:51:27 <spoonm> the examples I chose involve "discovering" Maybe and lists, then making a tree a functor
08:51:51 <ski> those are good to go more in-depth about
08:53:14 <ski> when introducing monads, or even idioms, it may also be good to first show the boiler-plate code that you get when you don't use the idiomatic or monadic operations, and compare with how more neatly you can express yourself, when using them
08:54:04 <Taneb> Like nested for loops vs. the list monad!
08:54:18 <ski> practically speaking, they're about spotting recurring patterns of code, and abstracting those away, noticing that many disparate situations can be covered with the same small set of "sequencing" operations
08:54:34 <ski> yea, that's a nice one :)
08:54:51 <Taneb> (well, a fairly small subset of nested for loops)
08:57:50 <ski> (i'd try to avoid most of the monadic analogies that float around. some of them can be nice, like "collection","computation","action","recipe", but you have to realize that, to a large extent, these only help a little bit, you have to impart more understanding of what you mean by those terms in any casae)
08:58:00 <ski> (perhaps also "context", i'm not sure about that one)
09:09:40 <exarkun> "lifting"
09:09:53 <exarkun> a metaphor that probably helps less often than people seem to think :)
09:11:36 <dmj`> "getting high"
09:14:44 <c_wraith> my favorite metaphor replacements are types. "this operation takes these things and returns one of those!" 
09:30:16 <ski> yes, "lifting" is just another of those words that only help slightly, at the start
09:33:53 <monochrom> Most of these vague words (posing as "intuitive" because oh so "plain English") and analogies don't work until after you understand the concept. Analogies are like insider jokes.
09:34:25 <monochrom> But what can you do to students who insist on "plain English" and reject axioms and laws?
09:34:54 <monochrom> Hell, axioms and laws and examples.
09:37:36 <monochrom> Recall how you learned "queue" or "lining up".  No one explained it in more words.  Instead your parents showed by example, bringing you to line up in Disneyland or something.
09:38:37 <monochrom> But suddenly when people learn functors or monads they want words not examples.
09:40:17 <glguy> Well sure, you'd demand examples if the examples involved going to disneyland, too
09:41:04 <hyperisco> Wasn't everyone drilled on how to do this in elementary school? Each grade had its own line. Little soldiers from the age of 5.
09:41:12 <glguy> Skiing? I don't get it, can you show me? But manual labor, I think I can get that from the words
09:41:30 * hackage quickcheck-classes 0.6.4.0 - QuickCheck common typeclasses  https://hackage.haskell.org/package/quickcheck-classes-0.6.4.0 (andrewthad)
09:44:12 * ski nods to monochrom
09:44:49 * ski can't show skiing
09:44:55 <monochrom> haha
09:47:24 <hyperisco> I'm sorry; please submit your explanation in a more ignorable format.
09:50:34 <ski> (one could question to which extent "lifting" helps more than slightly, after a while, too)
09:51:35 <ski> hyperisco, oh, you mean spoonm is actually listening, but trying to ignore us ?
09:52:27 <Lycurgus> e's marked away
09:55:00 * hackage acid-state 0.15.1 - Add ACID guarantees to any serializable Haskell data structure.  https://hackage.haskell.org/package/acid-state-0.15.1 (JeremyShaw)
09:55:41 <sshine> I'm going through my third package trying to make it work on GHC 8.6. I'm a little deep in syntax I don't completely understand: https://gist.github.com/sshine/4878d0b76c0fe81d1d8289fc4227eb2d -- I'm not sure what the fix is. I think it's caused by OverlappingInstances, which was deprecated. reading https://kseo.github.io/posts/2017-02-05-avoid-overlapping-instances-with-closed-type-families.html I've trie
09:55:47 <sshine> d instance {-# OVERLAPPING #-} ... where ...
09:56:01 * hackage git-annex 7.20190912 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-7.20190912 (JoeyHess)
10:01:09 <nshepperd2> sshine: read the part of the ghc manual about functional dependencies
10:06:36 <sshine> nshepperd2, thanks!
10:06:45 <elimirks> Hello! I'm currently reading category theory for programmers. I was wondering. Is the cardinality of "Int | Integer" the same as the cardinality of "Integer"?
10:06:45 <elimirks>  
10:07:43 <elimirks> Or does the coproduct type have an "extra" set, the size of Int? (I think it's 32 bit ints right?)
10:09:11 <suppi> elimirks actually you need a constructor to make a datatype
10:09:24 <suppi> data MyData = MyInt Int | MyInteger Integer
10:09:43 <suppi> so you can have both `MyInt 1` and `MyInteger 1`
10:10:00 <suppi> which are both different values :)
10:11:53 <suppi> though theoretically Integer is unbound so the cardinality is unbound
10:11:57 <suppi> i think
10:13:41 <elimirks> Oh interesting
10:14:50 <elimirks> I don't think they have the same cardinality then... unless there is some clever bijection
10:16:35 <elimirks> Ah actually, I just thought of that clever bijection. Yeah nevermind, they have the same cardinality
10:16:36 <elimirks>  
10:18:34 <ski> elimirks : you could ask about `Int + Integer', but `|' is just syntax belonging to `data' type declarations, doesn't have meaning on its own
10:19:06 <ski> (and by `Int + Integer' we basically mean `Either Int Integer', or suppi's `MyData', if you prefer)
10:20:05 <elimirks> Oh ok
10:20:05 <ski> "unbound" (or "unbounded") isn't a thing, with cardinalities. presumably you meant "infinite" or "uncountable" (not the same thing) ?
10:21:54 <suppi> probably meant infinite
10:22:19 <ski> sounds right, then
10:23:33 <suppi> it's definitely countable heh
10:24:00 * hackage brick 0.50 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.50 (JonathanDaugherty)
10:29:01 * hackage safecopy 0.10.0 - Binary serialization with version control.  https://hackage.haskell.org/package/safecopy-0.10.0 (JeremyShaw)
10:33:01 * hackage semirings 0.5.1 - two monoids as one, in holy haskimony  https://hackage.haskell.org/package/semirings-0.5.1 (chessai)
10:34:10 * ski nods
11:11:35 <merijn> You know that feeling when you browse through some source code and then see something you really wish you hadn't?
11:12:28 <merijn> The fuck is this nonsense: https://github.com/yesodweb/persistent/blob/master/persistent/Database/Persist/Sql/Migration.hs#L102-L106
11:12:57 <merijn> You're in IO! You can literally just throwIO and do the sane thing! Why, god...why
11:14:36 <hyperisco> Because the exception would be caught and wouldn't make it to the user. Just a guess.
11:14:55 <merijn> Caught by whom?
11:15:10 <hyperisco> Those who call runMigration'
11:16:00 <merijn> hyperisco: The ability to reliably catch problems in code is the entire point
11:17:48 <hyperisco> There could be some error handler that does something else, and the easiest way to avoid that is to not use an exception.
11:18:10 <hyperisco> Easiest when it is 16:45 on a Friday and you want to go home.
11:21:01 * hackage matterhorn 50200.5.0 - Terminal client for the Mattermost chat system  https://hackage.haskell.org/package/matterhorn-50200.5.0 (JonathanDaugherty)
11:25:10 <maerwald> errors "short-circuit". Why would you catch a database migration error? You cannot recover programmatically, can you?
11:25:40 <merijn> maerwald: That depends how and where you're trying to migrate
11:26:12 <merijn> Also, define "recover" that output isn't something a non-programmer should ever see
11:26:24 <merijn> maerwald: I wanna provide actually useful diagnostics
11:27:11 <boj> the assumption seems to be the entire thing can't run period and bails with why
11:27:36 <boj> no point in being fancy and handling it nicely
11:27:53 <merijn> boj: I know, but "dumping SQL in the face of non-programmers" is not a useful diagnostic
11:28:10 <monochrom> No, a library does not have the right to presume that you want to abort the whole program.
11:28:17 <boj> how would a non-programmer be involved here? isn't this something that is ran by a programmer, or at least operations person?
11:28:24 <merijn> boj: No
11:29:06 <monochrom> Only the author of main has the right to decide when and how to terminate the whole program.
11:29:18 <maerwald> monochrom: oh sorry, I just read "yesod" and assumed it isn't a library :P
11:29:41 <merijn> boj: I have an application that uses SQLite as file format and allows users to upgrade older files to newer version. If that migration errors for whatever reason dumping SQL into the face of my application's user is less than useful
11:29:52 <monochrom> It doesn't matter that the library author "can't see what other options you might have".
11:29:58 <boj> i was assuming "literally nothing can work anyways unless this migration runs". not saying it is right, but it's not terrible either
11:30:27 <boj> merijn: fair enough, i don't use yesod so i am happy to be off base here
11:30:32 <maerwald> Yeah, I've never written "error" in a library.
11:30:49 <merijn> boj: I don't use yesod either :p
11:47:20 <tdammers> I have actually used `error` in a "library" - but only for things that are truly horrible and should never occur if the caller does anything remotely resembling sanity
11:48:38 <dmj`> error is a great way to get things to typecheck
11:50:23 <merijn> dmj`: So are typed holes :p
11:50:33 <merijn> dmj`: Except those are strictly better :p
11:51:04 <dmj`> typed holes throw errors though
11:51:14 <merijn> dmj`: Which you can stop
11:51:26 <dmj`> that requires thinking though
11:51:35 <merijn> dmj`: How so?
11:52:26 <dmj`> how can you plug the holes
11:52:28 <tdammers> {-#LANGUAGE DeferTypeErrors #-} -- magic!
11:52:34 <merijn> tdammers: Heretic
11:52:39 <dmj`> tdammers: that's where I thought this was going
11:52:41 <merijn> -fdefer-typed-holes, duh
11:52:46 <dmj`> merijn is known for his blasphemy
11:52:48 <merijn> Which only defers typed holes
11:53:15 <tdammers> but there's no need for it, really, because you can write all your code in `RWST Dynamic Dynamic Dynamic IO Dynamic` and call it a day
11:53:31 <merijn> Just develop with -fdefer-typed-holes -fno-warn-typed-holes, when you're done, delete those flags and if you forget anything GHC will remind you
11:54:07 <Rembane> Did you just turn Haskell into Python?
11:54:12 <tdammers> Just develop in Python, and when you're done, delete all your code and rewrite it in Haskell
11:54:27 <merijn> tdammers: Ah, you've heard of my phd thesis? :p
11:54:40 <tdammers> merijn: no, and I don't think I'd want to
11:54:55 <monochrom> error is acceptable for partial functions if you also provide a total Maybe alternative.
11:55:07 <merijn> I've reached the joyous turning point where I have more SLOC Haskell than C++ :)
11:55:22 <tdammers> merijn: lifetime totals?
11:55:39 <monochrom> But database migration is an effect not a function.
11:55:51 <merijn> tdammers: Current state, but the Haskell hasn't replaced any C++, they live side by side
12:09:50 <dmj`> RWST and Dynamic sounds like a lot of fun
12:13:08 <merijn> dmj`: Not even MagicHash/unsafe :p
12:14:37 <dmj`> now I've heard it all
12:15:17 <merijn> dmj`: I thought that was how you were supposed to make things fun? :)
12:15:32 <dmj`> that is one way to make things fun, yes
12:40:35 <EvanR> so... lets say you want a data type for codes that map to types, such as a code for Char, a code for Text, a code for Integer. But also a code for list of any type with a code, a code for any record where fields carry values of type with a code... etc
12:41:04 <EvanR> question 1 would be, how would you do this. question 2 would be, is there something like this out of the box
12:41:56 <EvanR> a code for functions from one codable type to another
12:42:19 <EvanR> Typeable exists but i don't understand where its limits lie
12:43:19 <merijn> EvanR: You need a Typeable constraint/dictionary whenever you wanna use it
12:43:43 <merijn> That's the limit
12:44:01 <merijn> Typeable + Generic will get you pretty for towards "do whatever the fuck you want"
12:44:07 <EvanR> no i mean, what does the entire universe of things that are Typeable look like
12:44:21 <EvanR> right i don't want "whatever the fuck i want"
12:45:02 <merijn> EvanR: Your description is rather vague, so hard to see exactly what you want
12:45:35 <EvanR> i don't think its rather vague
12:46:21 <EvanR> as a simple example, define the universe inductively like, data U = C | Fun U U
12:46:45 <EvanR> define the mapping to types like, f C = Char; f (Fun a b) = f a -> f b
12:47:46 <EvanR> now pretend the codes have to represented as numbers :)
12:48:13 <EvanR> so that they are easy to compare for equality
12:49:05 <b_jonas> I'd like to understand how the question-mark constraint feature works
12:49:09 <b_jonas> @type ?fv
12:49:11 <lambdabot> (?fv::t) => t
12:49:22 <EvanR> you mean implicit parameters?
12:49:23 <b_jonas> ^ this value requires an ?fv question-mark constraints
12:49:35 <b_jonas> @type let { wr c g = let { ?fv = "red"; } in c g; } in wr
12:49:36 <lambdabot> (p1 -> p2) -> p1 -> p2
12:49:56 <b_jonas> and I thought that wr provides a question-mark constraint to the function c, but the type command doesn't seem to say so above
12:50:43 <b_jonas> as in, instead of just a (p1 -> p2) function, I thought it would accept the more general ((?fv::String) => p1 -> p2) function
12:50:53 <b_jonas> but the type doesn't show that, so I probably got the syntax wrong
12:51:00 <b_jonas> EvanR: yes, that's probably what it's called
12:51:53 <koz_> How does one make an Int#?
12:51:55 <b_jonas> but if so, then what's the correct syntax?
12:52:08 <koz_> I see a lot of functions for operating on Int# in GHC.Exts, but seemingly no way to actually make one.
12:52:13 <b_jonas> @type 1#
12:52:14 <lambdabot> GHC.Prim.Int#
12:52:22 <koz_> Oh is _that_ how it works. OK.
12:53:44 <EvanR> @type 1##
12:53:45 <lambdabot> GHC.Prim.Word#
12:53:57 <EvanR> @type 1.0#
12:53:58 <lambdabot> GHC.Prim.Float#
12:54:02 <EvanR> @type 1.0##
12:54:03 <lambdabot> GHC.Prim.Double#
12:54:06 <EvanR> wow...
12:54:22 <pikajude> @type 1e309##
12:54:23 <lambdabot> GHC.Prim.Double#
12:54:26 <pikajude> :o
12:54:31 <b_jonas> I think you might also be able to get one from an Int by pattern matching its contents
12:54:40 <EvanR> @type NaN##
12:54:42 <lambdabot> error: Data constructor not in scope: NaN##
12:54:43 <b_jonas> @src Int
12:54:43 <lambdabot> data Int = I# Int#
12:54:47 <EvanR> goddamit
12:55:17 <b_jonas> but I don't know how unboxed types and unboxed values work in general so I couldn't use them 
12:56:26 <nshepperd2> I remember discussing in here the possibility of making Num levity polymorphic once
12:56:57 <nshepperd2> it could be done, so that you could just write (1 + 2) :: Int# and get 3#
12:59:33 <b_jonas> > let { wr c = let { ?fv = (); } in c; } in wr (Just ?fv)
12:59:35 <lambdabot>  mueval-core: internal error: PAP object entered!
12:59:35 <lambdabot>      (GHC version 8.6.5 for x86_64_unknown_linux)
12:59:35 <lambdabot>      Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
12:59:36 <b_jonas> hmm
12:59:44 <b_jonas> that looks even worse than just the unexpected type
13:00:06 <b_jonas> just getting the syntax wrong shouldn't give that error message
13:00:14 <merijn> koz_: You need -XMagicHash
13:00:20 <koz_> Yeah, using these types gives me all kinds of fun levity-related errors.
13:00:24 <koz_> merijn: Yeah, I had that.
13:00:33 <koz_> It's like 'No Koz, no $ for you'.
13:00:47 <koz_> And 'No Koz, no naming of certain operations that return unlifted stuff for you'.
13:00:50 <merijn> koz_: You can't pass unboxed values to generic functions
13:01:13 <merijn> You can only polymorphically *return* unboxed values
13:01:14 <koz_> merijn: Yeah, I know - I think the levity polymorphism paper spells it as 'you can't move or store an unlifted value'.
13:01:33 <merijn> I'm curious what you're doing with them :)
13:01:53 <merijn> EvanR: Of course there's no NaN constructor, as there are, in fact, multiple NaN values
13:01:57 <b_jonas> hmm, that stuff sounds scarier than my question. what's the other channel, #haskell-beginners ?
13:02:08 <koz_> merijn: Two things - defining some rather efficient wider words (Word128 and friends) in preparation for implementing posits.
13:02:29 <koz_> It's good practice for me, since it means I'll know how to work with this stuff if I ever need to.
13:02:35 <merijn> b_jonas: It's fine to ask here :)
13:02:47 <koz_> (I'm waiting on Hedgehog to get 8.8 support before I can do any updates to finitary)
13:03:04 <merijn> b_jonas: boxed vs unboxed is pretty simple. Types have different size in memory, right?
13:03:11 <EvanR> merijn: then by reversing your specious argument, i'd expect to find a negative 0 constructor because there is only 1
13:03:27 <merijn> b_jonas: So if you have a polymorphic function like "id :: a -> a" you have basically 2 ways of implementing it
13:03:31 <EvanR> @type -0.0##
13:03:33 <lambdabot> GHC.Prim.Double#
13:03:47 <EvanR> is that real
13:03:56 <b_jonas> koz_: it's fine if you want to learn that, but you also know that it's worth to know the basics of the haskell foreign call interface, and then you can write the optimized parts of the code that deal with unboxed values in C or some other language, and call them using ffi, right?
13:04:00 <geekosaur> b_jonas, I think you have a bug in lambdabot. doing it in ghci gives me an error because you have things backwards, you're defining it after you need it
13:04:09 <merijn> b_jonas: 1) generate one version of id for each different type you ever use it with (possible problematic considering there's an infinite number of types), this is the approach, e.g. C++ templates take
13:04:10 <koz_> b_jonas: I'm quite aware, yes.
13:04:43 <merijn> b_jonas: 2) You make everything the same size (by instead of working directly on values you just replace every value by a pointer to said value)
13:05:30 <b_jonas> merijn: sure, the haskell approach is to assume that every type that can match an ordinary variable has the same binary interface, which is sort of a pointer to a value or thunk, and in particular, it's always the same size and gc'ed the same way, so if you try to substitute an unboxed type in them, it would break the gc even if it would fit in the size
13:05:31 <merijn> b_jonas: The process of hiding values behind pointers is called "boxing" (since you have to "open the pointer" to see what it actually was). This technique used in many language (for example, Java's generics)
13:06:07 <merijn> b_jonas: This, btw, is why you can't store Java's "int" inside generic containers. Objects in Java are boxed, but "int", etc. are unboxed
13:06:08 <b_jonas> merijn: I don understand why you can't just use unboxed values easily. what I don't understand is how you can still use them in Haskell 
13:06:40 <merijn> b_jonas: Well, why wouldn't you be able to use them? You can still use "int" in Java, no?
13:06:54 <geekosaur> the normal boxed values are made from unboxed ones
13:06:59 <merijn> Note, that technically Int# isn't Haskell as it's not in the report </pedantic>
13:07:01 <b_jonas> merijn: I don't know Java, so I can't use that comparison much
13:07:05 <EvanR> the only reason anything is boxed is for polymorphism, if your code isn't polymorphic, they no reason it can't operating directly on the runtime ints
13:07:12 <merijn> ^^^ that
13:07:28 <geekosaur> and unboxed ones are what things compile to when possible, because they're faster. which, see what EvanR said
13:07:31 <EvanR> well also for shuffling around large data structures
13:07:31 <b_jonas> I do know that Java boxed types are allocated on the heap alone, so you're always handling pointers to them, but I don't know how you can use unboxed values in Java either
13:07:41 <b_jonas> I know very little about Java, and luckily I never had to program it so farf
13:08:00 <b_jonas> (I have ran java programs, but I don't need to know Java for that.)
13:08:05 <EvanR> i can't believe people are pointing to what i said, and i have like 5 typos :(
13:08:08 <geekosaur> at some level there's a thing that holds a value. that value might be an actual value (unboxed) or a pointer (boxed)
13:08:17 <b_jonas> geekosaur: ok, so I have to try this outside of lambdabot
13:08:52 <geekosaur> (this thing is often called a register, for what it's worth, but memory locations generally work the same way)
13:08:53 <koz_> merijn: In Java, _everything_ that's not a primitive type is boxed. Not just generics.
13:09:06 <EvanR> "in the end, there are only integers, and pointers (which are integers)" ... and then floats come along
13:09:08 <merijn> koz_: I know, that's what I said, no?
13:09:26 <koz_> merijn: Oh, I see now. Should have read further back, sorry.
13:09:28 <merijn> koz_: I said objects are boxed and anything not primitive in Java is an object :)
13:09:29 <b_jonas> EvanR: um... aren't there other reasons for boxing, as in having data types with more than one constructor, or required lazy evaluation?
13:09:47 <geekosaur> but now we're getting into details of how things are actually evaluated on hardware or emulations thereof (like the JVM)
13:09:49 <EvanR> yeah, and garbage collection
13:10:03 <EvanR> and blackholing
13:10:04 <EvanR> and
13:10:04 <EvanR> ...
13:10:15 <merijn> b_jonas: Laziness is actually a good reason too, because a pointer could be "poitner to unboxed value", "pointer to boxed value", or "pointer to unevaluated thunk"
13:10:23 <geekosaur> there are lots of reasons for boxing. and one big reason not to: eveyrthing gets slower because you have to chase through pointers all the time
13:10:33 <monochrom> unboxed sums have happened, so having more constructors does not imply boxing
13:10:33 <EvanR> by definition all reasons you want to box are not relevant when you want to unbox
13:11:20 <monochrom> Nonetheless, it could be more convenient for a compiler writer to box everything.
13:11:26 <EvanR> because wanting to box and wanting to unbox proves False
13:11:27 <geekosaur> so you have languages where almost everything is conceptually boxed, and th compiler goes to a lot of effort to unbox everything it can
13:11:29 <b_jonas> monochrom: there are unboxed sums? ok
13:11:45 <merijn> Unboxed tuples too :)
13:11:59 <b_jonas> unboxed tuples make more sense, sure
13:12:03 <koz_> monochrom: Wait, unboxed _sums_?
13:12:07 <EvanR> unboxed sums also make sense
13:12:07 <merijn> koz_: Yeah
13:12:13 <b_jonas> I guess so
13:12:17 <EvanR> for example in a database implementation
13:12:21 <koz_> I have not heard of this - only unboxed tuples.
13:12:23 <b_jonas> some non-lazy languages have unboxed sums too
13:12:23 <merijn> koz_: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unboxed-sums
13:12:26 <geekosaur> they're recentish
13:12:29 <merijn> koz_: Because they're new!
13:12:34 <b_jonas> so I shouldn't act like they're strange
13:12:36 <merijn> -ish
13:12:39 <koz_> TIL.
13:12:45 <koz_> Could come in very useful for me, thank you!
13:13:02 <monochrom> Parametric polymorphism aka generics could be implemented one of two ways. One way is template cloning, which is C++'s; another way is boxing, which is SML's.
13:13:17 <b_jonas> are there unboxed closures too? or is that a future extension?
13:13:28 <merijn> monochrom: You're too late, I just explained that a bit back ;)
13:13:33 <monochrom> Oh heh
13:13:43 <monochrom> Well some people need to see it 3 times.
13:14:04 <b_jonas> nah, I guess you just use an unboxed tuple for that, or a sum of those, since to be unboxed, you want the set of function bodies to be a set that's determined in advance
13:14:14 <b_jonas> an unboxed open sum doesn't make much sense
13:14:33 <b_jonas> or a newtype around an unboxed tuple or sum I guess
13:17:06 <monochrom> To a large extent I get the feeling that GHC uses boxing to optimize compiler writer's time.
13:17:49 <merijn> monochrom: Also the time of people compiling things :p
13:18:08 <geekosaur> compiler writers spend a lot of time figuring out when to unbox. I'd say language designer instead
13:18:15 <geekosaur> isn't that a pessimization?
13:18:32 <merijn> geekosaur: Hmm?
13:18:44 <geekosaur> re people compiling things
13:18:47 <monochrom> The STG paper is basically like "OK we chose this design, but here are 3 other designs that other lazy functional compilers chose... and they all require the compiler and/or the RTS to handle more cases"
13:19:01 <merijn> geekosaur: unboxed duplication == more code == longer compiles usually
13:19:06 <b_jonas> monochrom: partly, but it probably also helps teaching a usable subset of the language to some new people. just like the lack of variable length arrays and alloca in C, or the lack of unsized local variables and arguments and structures with unsized last element in rust
13:19:47 <monochrom> To be sure by the time you worry about code optimization you confront the same more cases (maybe even worse) again.
13:19:49 <geekosaur> I was thinking more time spent analyzing the code to see what could be unboxed safely
13:20:28 <monochrom> But the STG work wasn't emphasizing code optimization.
13:21:10 <geekosaur> in any case, current ghc spends more time in the typechecker than anywhere else
13:21:19 <merijn> tbh, I could use faster compile times with GHC >.>
13:21:20 <monochrom> Language designers would not take side on boxing or not.
13:22:01 <monochrom> Even for non-strictness you don't need lazy evaluation. The alternative is crazy evaluation.
13:22:20 <merijn> monochrom: Try everything until timeout, thunk it on timeout!
13:22:27 <monochrom> Yeah!
13:22:53 <monochrom> If you see "const x y" just evaluate x and y in parallel and wait for x to finish.
13:23:26 <monochrom> equivalent bottoming behaviour as lazy evaluation
13:23:30 <merijn> monochrom: If I ever start and finish my "maximally malicious C compiler" we can collaborate on a "maximally malicious Haskell compiler" ;)
13:23:38 <monochrom> haha
13:24:31 <merijn> I first saw that idea as a thought experiment in a security discussion, but I love the idea as a tool for forcing student to confront the reality that they don't know C.
13:24:38 <monochrom> Hey Haskell 2010 does not require modules to be on the same computer!
13:25:35 <monochrom> So for example it is legal to say "import Data.List" means contacting https://www.haskell.org/cloud/data.list
13:25:58 <geekosaur> javascript model?
13:26:04 <merijn> geekosaur: Dhall :p
13:26:43 <b_jonas> that sounds even more scary
13:32:25 <b_jonas> merijn: if you ever make that maximally malicious C compiler, show us, I'll be interested in it. not for using it to compile programs for production of course, just for the learning value. 
13:33:38 <EvanR> or learning lack of values :)
13:34:20 <monochrom> haha
13:35:03 <b_jonas> merijn: wait, does maximally malicious mean that if I ever run into undefined behaviour, it will then try its best to infect my browser, steal my bank account access, send it to you, and reflash the BIOS so that reinstalling the OS doesn't clean it from my computer?
13:35:57 <EvanR> i'm sure you can think of worse, so no
13:36:00 <merijn> b_jonas: In my case I was thinking more like things such as "sizeof (int) == 1", etc.
13:36:09 <geekosaur> defined behavior can be worse than undefined
13:36:23 <geekosaur> because people make silly assumptions that don't necessarily hold
13:36:27 <b_jonas> merijn: oh, only that? 
13:36:27 <merijn> (Note, this is a real example from a real compiler)
13:36:31 <b_jonas> ok
13:36:42 <merijn> b_jonas: No, but tons of tiny things like that that no one ever remembers
13:37:01 <b_jonas> I thought at least the optimizer would try to actively find ub and do stupid things when it happens
13:37:03 <merijn> b_jonas: For example: Is pointer arithmetic performed signed or unsigned?
13:37:13 <b_jonas> not only when it's convenient for optimizing, but when it's less convenient
13:37:25 <merijn> b_jonas: Sure, that too. But people already fuck up lots of things that aren't UB :p
13:37:41 <b_jonas> I mean, even a normal compiler does things on ub that are inconvenient to me, as I know from that stupid bug in urxvt that I spent days to hunt down
13:38:19 <merijn> b_jonas: Here's a fun question for you, what does this print? "void foo() { char c = 137; printf("%d\n", c); }" :)
13:38:31 <b_jonas> I eventually found in the assembly output that gcc with optimization generated code for an array access that didn't use the array index. it turned out that the array was mistakenly declared to have 1 element instead of 2.
13:38:42 <hyperisco> merijn, depends on the platform doesn't it?
13:38:47 <merijn> hyperisco: Ssssh!
13:38:59 <hyperisco> But… I'm not an expert… can't I answer? lol
13:39:12 <b_jonas> merijn: I definitely can't tell anything about the code unless the code starts with some magic incantations involving defines and includes
13:39:34 <geekosaur> depends on the compiler. assuming all compilers for a platform agree as to how things should behave is another such mistake
13:39:35 <merijn> b_jonas: Well, assume printf is regular old printf :p
13:40:09 <geekosaur> (hello msc vs. gcc)
13:40:23 <merijn> But yeah, the great thing about that code is that it *might* be undefined behaviour
13:40:38 <merijn> But you can't be sure unless you check your implementation
13:40:43 <monochrom> But sometimes "platform" refers to the open tuple of (hardward, OS, compiler, config flags, account name, moon phase, ...)
13:40:52 <merijn> Because it's implementation defined whether that code is undefined >.>
13:40:58 <b_jonas> merijn: then either it's a compile error because the 137 overflows the char, or an ub because the 137 overflows the char, or it prints "-119"
13:41:06 <b_jonas> but I don't know which of those
13:42:01 <merijn> b_jonas: Two options: 1) char is unsigned, the code is fine and prints 137, or 2) char is signed, it overflows which is UB
13:42:52 <merijn> Because, oh joy of joys, unlike every other numeric type in C (which default to signed), the signedness of char is implementation defined
13:42:54 <b_jonas> merijn: isn't char being unsigned really unlikely, unless you use strange compiler options?
13:43:09 <geekosaur> nope
13:43:23 <monochrom> I don't think "unlikely" is relevant.
13:43:42 <EvanR> i only code in likely-C
13:43:43 <monochrom> Unless you actually offer a bet.
13:44:23 <monochrom> Everyone every time they say "unlikely" or "I don't believe it" they should offer a bet.
13:44:36 <jle`> we're talking about undefined behavior here, so we're not asking what would happen in a probabilistic situation where you sample from a random compiler
13:44:42 <jle`> we're talking about what the c standard would dictate
13:44:58 <geekosaur> and a maximally malicious compiler
13:44:59 <jle`> and it doesn't dictate any sort of probability distribution
13:45:02 <geekosaur> not gcc
13:45:13 <hyperisco> merijn, I like to think "char" is a type for characters, so talking about "char numbers" is nonsense in the first place.
13:45:13 <geekosaur> or even msc
13:45:22 <jle`> according to the standard: "undefined behavior is be good 99% of the time and bad 1% of the time"
13:45:27 <jle`> *is to be
13:45:31 <merijn> hyperisco: Then you're even more screwed ;)
13:45:35 <EvanR> without dictating any probability distribution, then we must assume that all possibilities have equal probability
13:45:45 <b_jonas> merijn: luckily 
13:45:55 <b_jonas> luckily C offers unsigned char and some other unsigned integer types
13:45:56 <merijn> hyperisco: You know what the type of 'c' in "char foo = 'c';" is?
13:46:00 <EvanR> statistical mechanics said so
13:46:18 <monochrom> hyperisco: The problem is that C treats char as a number type that happens to have some kind of %c support.
13:46:25 <hyperisco> It could be many things because C has implicit conversions
13:46:42 <merijn> hyperisco: No, it can be converted to many things but it has a rigidly defined type in the standard
13:46:56 <hyperisco> I don't understand then
13:47:01 <hyperisco> I thought 'c' was a variable
13:47:02 <monochrom> A language that truly has a dedicated character type would not make it easy for you to do character arithmetic.
13:47:10 <geekosaur> no, it'd a character constant
13:47:18 <geekosaur> the quotes are part of it
13:47:20 <merijn> hyperisco: No, like:
13:47:21 <merijn> > 'c'
13:47:24 <lambdabot>  'c'
13:47:34 <jle`> 'implicit conversion' is different than 'isn't a specific type'
13:47:42 <merijn> If it was C, what is it's type?
13:47:47 <merijn> s/it's/its
13:47:59 <b_jonas> merijn: I've known that for long, but I only found out a few years ago that the type of (0<1) also has similar strange properties
13:48:05 <hyperisco> I didn't see the quotes, sorry. I would have guessed  char  but that is probably not true then.
13:48:08 <merijn> The answer is, of course, the completely obvious: "int"
13:48:21 <jle`> type Char = Int
13:49:00 <b_jonas> luckily this very rarely makes a difference, and in the very few cases when it does make a difference, it usually helps
13:49:18 <voyons_osti> the maximally malicious compiler is codenamed the DeathStation 9000 
13:49:42 <jle`> Generally Cruel Compiler
13:50:28 <b_jonas> merijn: C gets much weirder than that though, for some programs where pointers are involved
13:50:36 <hyperisco> "character arithmetic"
13:50:53 <hyperisco> Converting case by adding or subtracting a constant!
13:50:53 <b_jonas> especially in programs where you try to dereference pointers
13:51:01 <geekosaur> 2["abc"]
13:51:15 <hyperisco> Or decoding digits to numbers and back
13:51:39 <monochrom> Oh the beauty is that C doesn't even imply ASCII
13:51:58 <b_jonas> hyperisco: we can do those just fine
13:52:48 <merijn> geekosaur: I've got a good one for you, but I should maybe move this discussion to -offtopic :p
13:53:35 <hyperisco> Well at one point C was considered too high-level, so cut it some slack.
13:54:18 <juri_> believe it or not, i still work with someone who considers C too high-level.
13:54:54 <merijn> C is both too high level and too low
13:55:01 <b_jonas> hyperisco: you uppercase x like (x + ('a' <= x && x <= 'i' || 'j' <= x && x <= 'r' || 's' <= x && x <= 'z' ? 'A' - 'a' : 0)
13:55:06 <merijn> Can't write meaningfull high level code, can't control generated assembly either
13:55:34 <b_jonas> )
13:56:04 <hyperisco> b_jonas, you mean that survives the signed ambiguity?
13:56:15 <b_jonas> hyperisco: I think so
13:56:30 <hyperisco> ASCII is 0 through 127, so there shouldn't be a problem
13:56:45 <b_jonas> hyperisco: you aren't modifying the sign bit of the character
13:56:50 <hyperisco> Assuming ASCII
13:56:54 <iqubic> I did not know there was an Ord instance for Char
13:57:14 <hyperisco> b_jonas, sure, so why not just add and subtract 32, or w/e it is
13:57:37 <jle`> iqubic: we need one so we can compare strings :)
13:57:51 <hyperisco> > chr (ord 'a' - 32)
13:57:52 <lambdabot>  'A'
13:57:53 <geekosaur> that comparison looked like it also does ebcdic?
13:57:56 <b_jonas> it doesn't survive arbitrary hypothetical charsets, such as Hollerith-based ones, but it does work on ASCII and EBCDIC-based charsets, including things like PETSCII that have upper and lowercase swapped compared to ASCII
13:58:05 <jle`> and we need to compare strings becase we like to put them in Data.Map.Map
13:58:09 <hyperisco> See? Intro to C was worth something after all
13:58:23 <b_jonas> hyperisco: because you don't know in advance whether you need to add 32 or subtract 32
13:58:35 <hyperisco> You mean to toggle case?
13:58:43 <b_jonas> hyperisco: in ASCII, you have to subtract 32; in some versions of EBCDIC or PETSCII you have to add it
13:58:55 <EvanR> iqubic: you never learned the "A B C"'s ?
13:58:59 <iqubic> I did.
13:59:06 <b_jonas> you could probably xor with 32, but I think adding 'A'-'a' works better for unexpected character sets
13:59:06 <EvanR> that's basically the ordering
13:59:12 <nshepperd2> > chr (ord 'a' `xor` 32)
13:59:14 <lambdabot>  'A'
13:59:25 <hyperisco> So, you mean a conversion that survives different character encodings
13:59:31 <iqubic> EvanR: doesn't it just use the ASCII ordering?
13:59:33 <monochrom> I learned "C D E F G A B"
13:59:38 <geekosaur> some different encodings
13:59:42 <EvanR> iqubic: unicode
13:59:56 <jle`> i remember when i learned the alphabet, 'A' was bigger than 'a'
14:00:02 <jle`> > max 'A' 'a'
14:00:04 <lambdabot>  'a'
14:00:06 <EvanR> monochrom: cyclic order
14:00:07 <jle`> i have been lied to
14:00:18 <EvanR> F between C and A
14:00:21 <b_jonas> monochrom: ? space E T I A N M S U R W D K G I H V F ? L ? P J B X C Y Z Q ? ? 
14:00:39 <b_jonas> or the Hollerith one, but I never learned that one
14:00:58 <iqubic> Oh. So I can compare λ and ∀ if I wanted to?
14:01:08 <EvanR> sure why not
14:01:19 <iqubic> > compare
14:01:22 <lambdabot>  <() -> () -> Ordering>
14:01:24 <hyperisco> I like the version where we stipulate the encoding of data and decode accordingly.
14:01:46 <iqubic> > compare Π ∀
14:01:48 <lambdabot>  error: Data constructor not in scope: Π :: ()error:
14:01:49 <lambdabot>      • Variable not in scope: forall :: ()
14:01:49 <lambdabot>      • Perhaps you meant ‘forAll’ (imported from Lambdabot.Plugin.Haskell.Eva...
14:01:56 <b_jonas> iqubic: try some quotes
14:02:03 <hyperisco> > max 'τ' 'π'
14:02:05 <lambdabot>  '\964'
14:02:11 <iqubic> > compare 'Π' '∀'
14:02:13 <lambdabot>  LT
14:02:19 <hyperisco> *anxiety intensifies*
14:02:42 <iqubic> According to Haskell, forall is greater than pi.
14:03:10 <geekosaur> forall pi. ...
14:03:12 <merijn> iqubic: You mean according to unicode
14:03:22 <iqubic> Dependent types aren't needed. forall is better. It was good knowing you guys.
14:03:54 <b_jonas> > compare 0 1
14:03:56 <lambdabot>  LT
14:03:59 <iqubic> I hope you all know that I was joking.
14:04:09 <jle`> > foldr compare LT "hello"
14:04:10 <monochrom> I didn't.
14:04:12 <lambdabot>  error:
14:04:12 <lambdabot>      • Couldn't match type ‘Char’ with ‘Ordering’
14:04:12 <lambdabot>        Expected type: [Ordering]
14:04:15 * geekosaur got the joke, yes
14:04:26 <iqubic> I still really really want dependent haskell
14:05:06 <EvanR> be careful what you wish for
14:05:15 <jle`> > foldr (compare . compare LT) LT "hello"
14:05:17 <lambdabot>  error:
14:05:17 <lambdabot>      • Couldn't match type ‘Char’ with ‘Ordering’
14:05:17 <lambdabot>        Expected type: [Ordering]
14:05:22 <iqubic> Why do you say that?
14:05:25 <jle`> > foldr (compare . compare 'l') LT "hello"
14:05:27 <lambdabot>  EQ
14:05:47 <iqubic> > head $ sort "hello"
14:05:48 <EvanR> make sure you wish for dependent types by asking will smith as the genie of the lamp and not from the monkey's paw
14:05:49 <lambdabot>  'e'
14:06:12 <iqubic> jle`: How the heck do that work?
14:06:16 <monochrom> Wait what's monkey's paw?
14:06:26 <EvanR> the edgar allen poe story
14:06:29 <jle`> iqubic: inline the definition of foldr
14:06:32 <jle`> @src foldr
14:06:32 <lambdabot> foldr f z []     = z
14:06:32 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:06:56 <iqubic> It's a short story about a magical monkey paw that grants wishes in the worst, most demented way.
14:07:05 <iqubic> :t (compare . compare LT)
14:07:06 <lambdabot> Ordering -> Ordering -> Ordering
14:07:12 <iqubic> How does that work?!?!
14:07:21 <jle`> inline the definition of (.)
14:07:24 <jle`> @src (.)
14:07:24 <lambdabot> (f . g) x = f (g x)
14:08:07 <monochrom> I think the right question is "what does it do?"
14:08:07 <iqubic> :t \x -> compare (compare LT x)
14:08:09 <lambdabot> Ordering -> Ordering -> Ordering
14:08:52 <jle`> \x y -> compare (compare LT x) y
14:09:02 <iqubic> that's what it's doing.
14:09:05 <jle`> it compares `compare LT x` with y
14:09:09 <monochrom> And it's possible the answer is "I'm going to a code obfucastion contest and I need a complicated way to say EQ"
14:09:14 <EvanR> dependent types where the simplest task requires a months worth of manual labor, only to find out it's impossible after all
14:09:19 <iqubic> But why does that return EQ?
14:09:39 <jle`> iqubic: well, there are only 3^3 possible inputs
14:09:48 <jle`> try looking at all of them :)
14:09:57 <jle`> er, 3*3
14:10:29 <jle`> draw a truth table, but for Ordering
14:10:45 <iqubic> > max "hello"
14:10:47 <lambdabot>  <[Char] -> [Char]>
14:10:54 <iqubic> Huh?!?!
14:11:00 <iqubic> :t max
14:11:02 <lambdabot> Ord a => a -> a -> a
14:11:12 <iqubic> > maximum "hello"
14:11:14 <lambdabot>  'o'
14:11:39 <iqubic> @check \x -> foldr (compare . compare $ maximum x) LT [x] == EQ
14:11:41 <lambdabot>  error:
14:11:41 <lambdabot>  • Couldn't match type ‘Ordering’ with ‘Ordering -> Ordering’ Expected type: ...
14:11:51 <iqubic> Effing heck.
14:12:13 <iqubic> I think it only produces EQ because "hello" has a repeated character.
14:12:30 <iqubic> foldr (compare . compare "o") LT "hello"
14:12:38 <iqubic> > foldr (compare . compare "o") LT "hello"
14:12:40 <lambdabot>  error:
14:12:40 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Char]’
14:12:40 <lambdabot>        Expected type: [[Char]]
14:13:00 <iqubic> > foldr (compare . compare 'o') LT "hello"
14:13:02 <lambdabot>  GT
14:13:08 <iqubic> Yeah. I was right.
14:13:58 <jle`> > foldr (compare . compare 'l') LT "helo"  -- no repeated character
14:14:00 <lambdabot>  EQ
14:14:16 <iqubic> No I am so confused.
14:14:24 <iqubic> *now.
14:14:39 <iqubic> > foldr (compare . compare 'h') LT "hello"
14:14:41 <lambdabot>  LT
14:14:45 <iqubic> Huh?!?!
14:14:51 <jle`> as you ponder this with experiments on your own, consider that foldr (f . g) z is foldr f z . map g
14:16:22 <iqubic> > foldr compare LT "hello"
14:16:24 <lambdabot>  error:
14:16:24 <lambdabot>      • Couldn't match type ‘Char’ with ‘Ordering’
14:16:24 <lambdabot>        Expected type: [Ordering]
14:16:28 <iqubic> What?!?!
14:16:46 <Clint> :t foldr
14:16:47 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
14:17:24 <iqubic> > foldr (compare 'l') LT "hello" . map (compare)
14:17:24 <jle`> iqubic: note foldr takes a -> b -> b, so if you pass in 'compare'. b has to be Ordering. so 'a' has to be Ordering
14:17:26 <lambdabot>  error:
14:17:26 <lambdabot>      • Couldn't match expected type ‘[a -> Ordering] -> c’
14:17:26 <lambdabot>                    with actual type ‘Ordering’
14:17:31 <iqubic> I give up.
14:17:38 <jle`> iqubic: try checking these on your own in ghci or by messaging lambdabot
14:17:40 <iqubic> > foldr (compare 'l') LT "hello"
14:17:42 <lambdabot>  error:
14:17:42 <lambdabot>      • Couldn't match type ‘Ordering’ with ‘Ordering -> Ordering’
14:17:42 <lambdabot>        Expected type: Char -> Ordering -> Ordering
14:17:50 <iqubic> Yeah. I give up/
14:17:57 <Clint> what are you trying to do?
14:18:05 <jle`> note that in general you can't just pass anything into foldr and it'll typecheck
14:18:06 <iqubic> This is some tricky and confusing Haskell trickery.
14:18:09 <jle`> you have to pass something of the right type
14:18:30 <iqubic> :t scanl
14:18:31 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
14:18:56 <iqubic> > let fibs = 1:(scanl (+) 0 fibs) in fibs
14:18:57 <jle`> i wouldn't really call it haskell trickery because you can get the same silly behavior in any language
14:18:57 <lambdabot>  [1,0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,1094...
14:19:13 <iqubic> > let fibs = 1:(scanl (+) 1 fibs) in fibs
14:19:15 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
14:19:21 <iqubic> Nice.
14:19:45 <iqubic> > let pows = 2:(scanl (*) 2 pows) in pows
14:19:47 <lambdabot>  [2,2,4,8,32,256,8192,2097152,17179869184,36028797018963968,61897001964269013...
14:20:07 <iqubic> Wait?!?! What?!?!
14:20:29 <amateur_hour> what's the standard way to combine monad transformers? I've heard that mtl style isn't recommended generally (though I could have remembered wrong)
14:20:47 <iqubic> > map (\x -> x^2) [0..]
14:20:47 <jle`> iqubic: the result of foldr (compare . compare 'l') is basically a 1.6-bit hash, it gives you a random Ordering, essentially
14:20:48 <lambdabot>  [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,4...
14:21:01 <jle`> iqubic: *pseudo-random
14:21:12 <iqubic> > map (\x -> 2^x) [0..]
14:21:14 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
14:21:31 <iqubic> Nice. I was trying to generate that with scanl, but I failed.
14:21:35 <jle`> iqubic: so there is no pattern in the output
14:21:58 <iqubic> Oh.
14:22:05 <jle`> it isn't haskell trickery, it's just a bunch of functions applied to values in a way that gives seudo-random results
14:22:16 <duncan> > map (flip (^) 2) [0..]
14:22:19 <lambdabot>  [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,4...
14:22:28 <duncan> :)
14:22:35 <duncan> (it works!)
14:22:36 <b_jonas> > let { x = 1 : scanl1 (+) x; } in x -- powers of two
14:22:38 <lambdabot>  [1,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072...
14:22:48 <jle`> > let pows = 1 : map (*2) pows in pows
14:22:51 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
14:23:01 <iqubic> fibs = unfoldr (\(a,b) -> Just (a,(b,a+b))) (0,1)
14:23:12 <iqubic> > fibs = unfoldr (\(a,b) -> Just (a,(b,a+b))) (0,1)
14:23:14 <lambdabot>  <hint>:1:6: error:
14:23:14 <lambdabot>      parse error on input ‘=’
14:23:14 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
14:23:19 <monochrom> amateur_hour: mtl style is the standard way
14:23:28 <iqubic> > let fibs = unfoldr (\(a,b) -> Just (a,(b,a+b))) (0,1) in fibs
14:23:30 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
14:23:35 <iqubic> WTF is that?!?!
14:23:52 <jle`> inline the definition of unfoldr
14:23:52 <iqubic> Oh, wait... I see how that works.
14:23:55 <jle`> @src unfoldr
14:23:55 <lambdabot> unfoldr f b = case f b of
14:23:55 <lambdabot>     Just (a, b') -> a : unfoldr f b'
14:23:55 <lambdabot>     Nothing      -> []
14:23:59 <iqubic> I see how that works.
14:24:31 <iqubic> I find these tricks really odd and bemusing
14:24:31 <jle`> amateur_hour: the question is sort of tricky, mtl style is mostly for programming generically on different types of effectful monads
14:24:57 <jle`> amateur_hour: it's not encessarily a way to combine monad transformers. but it's not necessarily a bad way to program/structure your applications either
14:25:14 <amateur_hour> monochrom, jle` ah right, thanks for answering, guess I'll do it that way then
14:25:22 <amateur_hour> I wonder what I misremembered as being not recommended
14:25:26 <jle`> amateur_hour: 'combining monad transformers' is done by just...combining trasnformers
14:25:30 <jle`> remember that monad transformers naturally chain
14:25:31 * hackage urbit-hob 0.1.1 - Hoon-style atom manipulation and printing functions  https://hackage.haskell.org/package/urbit-hob-0.1.1 (JaredTobin)
14:26:05 <jle`> monad transformers are Monad -> Monad functions, so they can be chained as much as you want
14:26:15 <dmwit> jle`: I don't think it's a very good pseudorandom hash.
14:26:32 <jle`> amateur_hour: but i think the heart of what you are asking is what is the best way to combine effects, maybe 
14:26:37 <amateur_hour> just getting back into Haskell after quite a while, so forgive me for just being wrong about stuff :)
14:26:40 <dmwit> jle`: Most of the 9 possible outputs are LT.
14:26:59 <dmwit> (and only 1 is GT)
14:27:01 <jle`> okay, so maybe a little less than 1.6 bits of entropy ;)
14:27:25 <amateur_hour> yeah I suppose that's more like what I meant
14:27:31 <monochrom> Oh, so you meant 3x3 rather than 3^3 after all.
14:27:32 <jle`> amateur_hour: no worries, i didn't mean to say that you were wrong about anything
14:27:54 <jle`> dmwit: i meant foldr (compare . compare 'l') LT, which has infinite inputs :o
14:28:14 <iqubic> https://willamette.edu/~fruehr/haskell/evolution.html
14:28:20 <iqubic> That always confuses me.
14:28:35 <jle`> that's ok, it's written to confuse people :)
14:28:38 <iqubic> Like every time I come back here, I understand a little more of the page.
14:29:22 <b_jonas> iqubic: yeah, and I still say that I'm not in that list of programmers, because www.math.bme.hu/~ambrus/pu/Bin.hs is how I implement factorial
14:29:55 <iqubic> combinatory programmer is the first one I don't understand
14:30:03 <monochrom> What is Mone?!
14:30:11 <dmwit> jle`: `compare . compare 'l'` is also pretty bad. 2228007 LT's, 1114112 EQ's, and only 217 GT's.
14:30:44 <iqubic> compare GT EQ
14:30:57 <iqubic> > compare GT EQ
14:30:59 <lambdabot>  GT
14:31:09 <iqubic> Does ordering form a monoid?
14:31:13 <monochrom> And so many explict {;}s
14:31:29 <iqubic> with (<>) = compare; and mempty = EQ?
14:31:43 <dmwit> monochrom: minus one, apparently
14:32:03 <b_jonas> iqubic: Combinatory refers to https://esolangs.org/wiki/Combinatory_logic
14:32:53 <dmwit> (But why is it there? I have no idea.)
14:33:01 <jle`> dmwit: ah so 0.637 bits of entropy
14:33:11 <jle`> i've seen worse
14:33:27 <monochrom> Hell, I have invented worse (on purpose).
14:33:36 <jle`> * a 0.637-bit hash
14:33:59 <b_jonas> monochrom: minus one
14:34:05 <jle`> ah! i was using the wrong log base
14:34:12 <jle`> it's a 0.919-bit hash
14:34:16 <monochrom> On exams I make jokes like "Mr. Bean is learning hashing. He proposes to hash URLs by taking the first 4 characters..."
14:34:30 <jle`> 0.919-bit hash, almost as good as a 1-bit hash
14:34:35 <b_jonas> monochrom: (Oh x) represents 2*x, and (One x) represents 1+(2*x)
14:35:01 * hackage approximate 0.3.2 - Approximate discrete values and numbers  https://hackage.haskell.org/package/approximate-0.3.2 (ryanglscott)
14:35:11 <jle`> monochrom: what could go wrong
14:35:35 <b_jonas> the list of digits is terminated by either Zero for an infinite leading sequence of zeroes at the start of the binary repr of a nonnegative number, or Mone for an infinite leading sequence of ones at the start of the (one's complement) binary repr of a negative number
14:35:35 <monochrom> Then on the next year's exam I make a sequel like "Johnny English is learning hashing too. He has 'learned' from Mr. Bean's mistake, and he proposes to hash email addresses by taking the last 4 characters..."
14:36:25 <jle`> that's...an improvement, technically
14:36:37 <iqubic> This is the best way to explain Monads. Just compare them to monsters: https://mail.haskell.org/pipermail/haskell-cafe/2006-November/019190.html
14:36:57 <iqubic> I just discovered this page on Haskell humor and love it. https://wiki.haskell.org/Humor
14:37:58 <b_jonas> jle`: sure, email addresses can end in "@gmail.com" or in "@GMAIL.COM", the latter in stupid javascript forms that assume that email addresses must be case-insensitive when in reality only their domain part is
14:38:02 <dmwit> b_jonas: You might consider `data Pos = One | TwoX Pos | TwoXPlusOne Pos; data Bin = Bin Pos Pos` with `instance Eq Bin where Bin pos neg == Bin pos' neg' = pos + neg' == pos' + neg`.
14:38:03 <b_jonas> and force them to uppercase
14:38:10 <dmwit> b_jonas: It reduces the number of special cases you need by a lot.
14:38:35 <b_jonas> dmwit: that would be another method, it could work, but it's not really what I wanted here
14:38:37 <jle`> b_jonas: of my email addresses i use, some are .edu, some are .im, some are .com
14:38:46 <jle`> i've used a .org before too
14:38:59 <jle`> i have a few .edu from being faculty/students at different institutions
14:40:16 <iqubic> My favorite quote ever, from shapr: "GHC has more flags than the UN"
14:41:15 <b_jonas> dmwit: if I wanted to have fewer special cases, I'd use https://www.perlmonks.com/?node_id=849296
14:41:17 <koz_> iqubic: LAWL
14:41:25 <koz_> GCC probably has even more.
14:41:27 <b_jonas> although I guess that's an unfair comparison because it only handles nonnegative numbers
14:42:26 <dmwit> I'd probably laugh if I could understand perl.
14:45:13 <b_jonas> dmwit: it's not particularly funny. I represent nonnegativenumbers as a string of decimal digits, dalu implements addition/subtraction/comparison of such numbers by the usual algorithm. the rest of the code converts an integer from decimal to binary by successive doubling, subtraction and comparisons
14:45:36 <b_jonas> well, actually it converts to hexadecimal
14:46:07 <b_jonas> so it does the doubling 4 times and the subtraction up to 16 times
14:46:19 <b_jonas> it's not the most efficient way, just an interesting implementation
14:46:31 * hackage compensated 0.7.3 - Compensated floating-point arithmetic  https://hackage.haskell.org/package/compensated-0.7.3 (ryanglscott)
14:47:47 <b_jonas> https://www.perlmonks.com/?node_id=989716 is the sequel to it, it converts from binary to zeckendorf by implementing addition in zeckendorf
14:48:38 <b_jonas> and one of these days I really ought to write another arithmetic implementation that I've been planning for a while, but I'm lazy
14:48:46 <iqubic> what is Zeckendorf?
14:50:51 <koz_> iqubic: https://en.wikipedia.org/wiki/Zeckendorf%27s_theorem
14:53:40 <iqubic> I see.
14:53:59 <koz_> Maths is magic.
14:54:26 <iqubic> Haskell is magic. That much is true.
14:54:45 * dmwit jots down "that much" in his list of axioms
14:54:52 <iqubic> Huh?!?!
14:55:00 <koz_> iqubic: dmwit is making a logic joke.
14:55:10 <iqubic> I know.
14:55:20 <iqubic> intros thatMuch
14:55:20 <koz_> An 'axiom' is something which is taken as a priori true.
14:55:24 <iqubic> I know.
14:55:32 <koz_> |- 'that much'
14:55:38 <koz_> Or rather, |= 'that much'
14:55:46 <iqubic> intros thatMuch
14:55:53 <iqubic> refl
14:55:57 <iqubic> QED
14:57:40 <koz_> Such prove.
14:57:45 <koz_> Very soundness.
14:57:46 <koz_> Amaze.
14:57:56 <iqubic> I know. It was a great proof.
14:58:36 <koz_> iqubic: https://i.imgur.com/aZZSBgu.jpg
15:09:18 <koz_> Why is the 'unpacker' of Down not 'getDown'.
15:09:23 <koz_> Missed opportunity there.
15:09:46 <monochrom> haha
15:10:11 <koz_> monochrom: Should I file a bug? :P
15:10:32 <monochrom> I wonder if it should be getUp instead.
15:10:49 <koz_> 'getDown' fits a (sort-of) established pattern.
15:10:57 <koz_> The other option would be 'runDown' or 'unDown'.
15:11:08 <koz_> s/option/options/
15:11:11 <monochrom> I prefer runDown then!
15:11:30 <koz_> 'run*' is usually used with transformers I think.
15:11:42 <koz_> Although yeah, definitely filing.
15:11:50 <koz_> (as a feature request)
15:12:04 <monochrom> No, I like the image of running down or mowing down something with a bulldozer or something.
15:12:54 <monochrom> Soundness proofs are usually pretty involved and are best read in a sound-proof room.
15:13:20 <jle`> the unpacker of getDown should be 'up'
15:13:26 <jle`> er, unpacker of 'Down'
15:13:36 <jle`> just like how the unpacker of Backwards is forwards
15:13:51 <nil> iqubic: was that Coq?
15:14:15 <monochrom> Although, it is still debated whether a 10-proof drink is a good company or not.
15:14:21 <jle`> up . sort . map Down
15:14:27 <jle`> um...types
15:14:44 <monochrom> map up?
15:15:10 <monochrom> What is the unpacker called currently?
15:17:37 <jle`> there is none
15:17:50 <jle`> aka coerce
15:19:01 * hackage hyperloglog 0.4.3 - An approximate streaming (constant space) unique object counter  https://hackage.haskell.org/package/hyperloglog-0.4.3 (ryanglscott)
15:30:00 * hackage key 0.1.2.0 - Type-safe unconstrained dynamic typing  https://hackage.haskell.org/package/key-0.1.2.0 (MatthewFarkasDyck)
15:38:29 <shapr> I have a question about how to do a join with persistent: https://gist.github.com/shapr/1b391fb28b757e7afda331c698ed72f7
15:39:22 <tabaqui2> sorry, I cannot find any documentation on local cabal.config file
15:39:30 <tabaqui2> can you provide it to me, please?
15:39:51 <tabaqui2> actually, I want to disable a flag OR add new dependency to the test-suite
15:39:57 <shapr> tabaqui2: https://www.haskell.org/cabal/users-guide/installing-packages.html
15:40:15 <shapr> do you mean the system wide cabal config? or per-project config?
15:40:20 <tabaqui2> per-project
15:40:35 <iqubic> I am really starting to hate doors right now.
15:40:37 <shapr> that should be the .cabal file in your project dir
15:40:40 <koz_> iqubic: Lolwut.
15:40:42 <shapr> iqubic: all doors?
15:41:09 <tabaqui2> shapr: yeah, but... well, it is much easier to modify build process with cabal.config
15:41:22 <iqubic> I'm reading jle` depenedent types blog post.
15:41:30 <iqubic> I am so so so confused.
15:41:35 <shapr> tabaqui2: What do you need to change about the build process?
15:41:40 <iqubic> And now doors are pissing me off.
15:41:42 <monochrom> Oh, dependently typed doors.
15:41:48 <koz_> iqubic: What's confusing you?
15:41:57 <tabaqui2> disable a flag (that is enabled by default), or add new dependency to the test-suite
15:42:10 <iqubic> See, I was confused, so I decided to look into Idris.
15:42:15 <monochrom> Sometimes reading these blogs require the talent of reading Aesop fables.
15:42:16 <koz_> iqubic: LOLOL
15:42:22 <koz_> Not quite the strategy I'd advise.
15:42:38 <iqubic> I just found a talk by Edwin Brady, creator of Idris, where he uses doors too.
15:42:41 <shapr> tabaqui2: you can add a new dependency by modifying build-depends, here's an example: https://gist.github.com/shapr/03c78d9e410cb6db033b27d71ef34447
15:42:51 <koz_> iqubic: It's a standard example from dependent typing I believe.
15:42:53 <koz_> Or so jle` told me.
15:42:59 <monochrom> The Lion, The Witch, and The Closet Door.
15:43:00 <shapr> your projectname.cabal file should have a test-suite stanza
15:43:07 <tabaqui2> shapr: sure, but it is a part of CI
15:43:20 <koz_> monochrom: The Lion, The Witch, and the Door (t :: DoorState). :P
15:43:23 <shapr> tabaqui2: can you explain further?
15:43:45 <tabaqui2> ok, I have sources provided by FB to build a Thrift compiler
15:44:00 <tabaqui2> by tutorial, I have to just run make && make install
15:44:18 <tabaqui2> but inside there is a cabal project
15:44:22 <shapr> What's the right way to do inner join in persistent? I want to set a Text field as primary key, but then it doesn't seem to exist inside the Template Haskell splice
15:45:07 <tabaqui2> and it is much easier to call "echo something > cabal.config" than "awk ... thrift.cabal"
15:45:21 <sclv> do you have a link to the repo?
15:45:36 <sclv> the cabal.config isn't ever local
15:45:39 <sclv> its only global
15:45:40 <tabaqui2> https://github.com/apache/thrift/tree/master/lib/hs
15:45:48 <koz_> There _is_ cabal.config.local
15:45:49 <sclv> you have a "local version" of it, but that's named `cabal.project`
15:46:02 <sclv> and i believe, cabal.project.local
15:46:03 <koz_> Sorry, cabal.project
15:46:07 <koz_> .local
15:46:12 <tabaqui2> check out the .cabal file: the test-suite imports Network somewhere, but they didn't declare network in build-depends
15:46:12 * koz_ can't think this morning.
15:46:29 <tabaqui2> it can be avoided disabling the network-uri flag
15:47:10 <shapr> are you able to modify the test-suite chunk to add that part about the network-uri flag?
15:47:17 <sclv> the test-suite depends on the main libn
15:47:25 <sclv> and the main lib depends on network
15:47:35 <sclv> anyway the makefile just wraps normal cabal commands
15:47:42 <sclv> so you can use cabal just like normal with this lib
15:48:28 <tabaqui2> [4 of 4] Compiling Main             ( TestServer.hs, TestServer.o )
15:48:30 <tabaqui2> TestServer.hs:30:1: error:
15:48:32 <tabaqui2>     Could not load module ‘Network’
15:48:34 <tabaqui2>     It is a member of the hidden package ‘network-2.5.0.0’.
15:48:56 <sclv> ah i see
15:49:03 <sclv> just add network to the build-depends in the cabal file
15:49:06 <sclv> for the testsuite
15:49:26 <tabaqui2> I can modify anything, but it requires the sacred mystical knowledge of awk
15:50:03 <tabaqui2> again, it is a part of some shell script running in docker
15:50:16 <tabaqui2> no interactive tools
15:50:35 <sclv> oh i see!
15:50:47 <sclv> you can't just fork the repo and fix. ugh
15:51:26 <nshepperd2> heheh, i made a package manager out of cabal new-build
15:51:40 <nshepperd2> cabbage manager*
15:51:45 <shapr> yay cabbage!
15:52:42 <koz_> nshepperd2: Cabbage manager?
15:53:03 <koz_> cabal new-install cabbage-roll
15:53:06 <koz_> ?
15:53:24 <shapr> cabal package -> cabbage!
15:53:47 <sclv> tabaqui2: so you can have a cabal.project file for a "local" cabal.config and it should be modifiable
15:53:51 <nshepperd2> it's just a shell script which manages a list of installed cabbages. and whenever the list is changed it uses new-build to build a whole new ghc environment file with those cabbages and copies it into .ghc/$version/environments/default
15:53:56 <tabaqui2> btw, cabal.config is pretty local
15:53:58 <sclv> and that _should_ let you set flags, at least
15:54:08 <tabaqui2> at least, I can change bounds with "constraints" field
15:54:21 <sclv> yeah, i just mean that it tends to live in ~/.cabal
15:54:30 <sclv> although the location can be overridden
15:55:05 <sclv> freeze files also can take constraints iirc
15:55:10 <sclv> if anything we have too many ways to set stuff
15:55:15 <shapr> oh man, my problem was really simple, I forgot to add that second parameter to selectFirst :-(
15:55:38 <sclv> nshepperd2: nice!
15:55:59 <sclv> i think we definitely need "porcelain" around all our neat new features to generate idiomatic workflows
15:57:20 <maralorn> ghcide: (ExitFailure 1,"cabal: No targets given and there is no package in the current directory. Use\nthe target 'all' for all packages in the project or specify packages or\ncomponents by name or location. See 'cabal build --help' for more details on\ntarget options.\n\n","")
15:57:39 <maralorn> Wondering how to deal with that …
15:58:04 <nshepperd2> i think what I need to do next is make it manage cabbage versions a bit better
15:58:45 <hpc> nshepperd2: for better backwards tomatobility, of course
15:58:55 <nshepperd2> precisely!
15:59:40 <nshepperd2> right now the cabbage list just has the package names, but i should make it freeze versions too, so you don't get unexpected upgrades
16:00:21 <hpc> hmm
16:00:39 <hpc> it'd be neat to have a thing where if it knows you're doing a development build
16:00:45 <hpc> it picks random package versions within your constraints
16:00:52 <hpc> instead of latest or whatever is pinned
16:00:58 <hpc> to constantly test that you have it right
16:01:28 <maralorn> Can I tell cabal to use "all" as default?
16:01:33 <tabaqui2> ah, great cabal.config works only with new-configure
16:01:45 <tabaqui2> it is not an option
16:02:03 <sclv> sigh
16:02:42 <nshepperd2> (the actual installation is done by creating a dummy cabal project in a temp directory with all the cabbages dumped in the deps of its cabal file. because I couldn't see a way to make cabal to turn constraints passed on the command line directly into an environment file)
16:03:00 <tabaqui2> sed/awk then
16:04:30 * hackage table-layout 0.8.0.5 - Layout text as grid or table.  https://hackage.haskell.org/package/table-layout-0.8.0.5 (muesli4)
16:07:06 <nshepperd2> hpc: meta quickcheck. your tests only truly pass if they build and pass with all valid dependency versions
16:07:44 <monochrom> Heh I like randomized testing!
16:14:33 <koz_> I too am a fan.
16:14:37 <koz_> Which is why I use Hedgehog all the time.
16:21:57 <zeta_0> i am getting a `could not find module error` even though the module file i am importing is in the same directory as the main.hs where i am importing it?
16:23:24 <glguy> How are you building your program? What's the name of the module? What's the module's filename?
16:23:46 <monochrom> glguy++
16:26:40 <zeta_0> the name of the module is: `Custom` and the file name is `main.hs`, i am following the instructions from this tutorial(the custome module example is at the bottom) https://www.tutorialspoint.com/haskell/haskell_modules.htm
16:27:13 <glguy> > To implement this custom module, we will create a separate file called "custom.hs" along with our "main.hs".
16:27:15 <lambdabot>  <hint>:1:26: error: parse error on input ‘module’
16:27:35 <glguy> The Custom module should be in a file named "Custom.hs"
16:27:40 <glguy> case matters
16:27:42 <zeta_0> maybe the instructions are missing somethin?
16:28:11 <zeta_0> glguy: so `Custom.hs` instead of `custom.hs`?
16:28:15 <glguy> Yes
16:29:25 <zeta_0> oh thanks, lets see if it works now, one second
16:33:33 <koz_> How do I do formatted hyperlinks in Haddock?
16:33:36 <zeta_0> is threw another error when i tried to load it?
16:36:07 <zeta_0> Custom.hs:13:15: error:
16:36:08 <zeta_0>     parse error on input ‘=’
16:36:08 <zeta_0>     Perhaps you need a 'let' in a 'do' block?
16:36:08 <zeta_0>     e.g. 'let x = 5' instead of 'x = 5'
16:36:08 <zeta_0>    |
16:36:08 <zeta_0> 13 | showBoolean c = do 
16:36:08 <zeta_0>    |               ^
16:36:09 <zeta_0> Failed, no modules loaded.
16:37:35 <zeta_0> i am thinking the indentation is off?
16:39:46 <EvanR> can vinyl records be nested
16:42:07 <dmwit> zeta_0: This tutorial is terrible.
16:42:16 <dmwit> Anyway, yes, the indentation is incorrect.
16:42:57 <dmwit> The single-quotes around rem should be backticks, too.
16:43:54 <zeta_0> dmwit: and the indentation?
16:44:05 <dmwit> Yes, it's incorrect.
16:44:11 <shachaf> My recommendation is that you burn this web page and never visit tutorials point dot com again.
16:44:49 <zeta_0> it runs fine on ihaskell but horrible when pasted into a created .hs file
16:45:10 <zeta_0> and loaded with ghci
16:45:53 <srid[m]> offtopic question - is Matrix as reliable an alternative to irccloud (mainly, persists logs)?
16:46:15 <dmwit> zeta_0: Here: https://gist.github.com/dmwit/1b8a7674cd3c86bb7e0a56306d368c35
16:49:54 <zeta_0> dmwit: is works, thanks
16:50:46 <sm[m]> srid[m]: seems so, though it isn’t really equivalent (not fully public, eg)
16:51:01 <dmwit> > fromEnum True
16:51:03 <lambdabot>  1
16:51:17 <dmwit> showBoolean = fromEnum -- hrm
16:51:56 <dmwit> What are these names, though? In what sense are "showEven" and "showBoolean" showing anything?
16:52:23 <zeta_0> ihaskell is working great but `haskell-ide-engine` is slow, does strange things, and it's auto-completion does not seem to be working, why is this?
16:52:35 <monochrom> Meaningful names that mislead.
16:52:53 * dmwit consults his crystal ball
16:53:21 <monochrom> I attribute it to the high possibility that the author lives in India.
16:53:32 <dmwit> zeta_0: "it is decidely so"
16:53:35 <kerru[m]> :D
16:54:10 <zeta_0> dmwit: and what did that c parameter mean?
16:55:53 <ysangkok> if I have a function returning a maybe, that would need to propagate a maybe from it's callee, i could do in do-notation: "guard (not $ isNothing calleeResult); let Just x = calleeResult". but isn't there a better solution?
16:56:53 <zeta_0> have you guys tried `ihaskell` and `haskell-ide-engine` ? what was your experience with them :
16:57:07 <monochrom> I haven't tried them and I'm so glad.
16:58:24 <zeta_0> monochrom: ihaskell is great, especially for learning and experimenting, but i am having issues with the haskell-ide-engine
17:01:51 <monochrom> ysangkok: calleeResult >>= \x -> ...
17:02:15 <monochrom> >>= for Maybe already checks for nothingness.
17:02:40 <EvanR> i wonder which record lib allows nesting
17:04:01 <monochrom> Any lens-style record story has a good nesting story. Because the whole point is composable lenses.
17:04:42 <zeta_0> thanks guys, later
17:06:11 <EvanR> extensible records i mean
17:06:31 <monochrom> Then IIRC none.
17:06:38 <EvanR> nice
17:06:50 <dmwit> ysangkok: `x <- calleeResult`
17:06:51 <monochrom> But Hugs has an extensible record extension.
17:07:06 <EvanR> ill check that out
17:07:35 <dmwit> ...unless the do block you're doing this in is for some other monad, I guess.
17:08:57 <ysangkok> dmwit: no, it is in that monad! perfect! didn't think about <- works differently depending on monad, but of course it does :)
17:09:03 <ysangkok> thanks so much 
17:09:35 <ysangkok> monochrom: i guess to realize this i have to getting used to checking >>= documentation
17:09:59 <zeta_0> what does the parameter `c` mean in this example?
17:10:08 <zeta_0> showBoolean :: Bool->Int 
17:10:08 <zeta_0> showBoolean c = do 
17:10:08 <zeta_0> if c == True 
17:10:08 <zeta_0>    then 1 
17:10:08 <zeta_0> else 0 
17:10:09 <monochrom> No, >>= documentation doesn't say this.  But every real Haskell textbook does.
17:11:10 <monochrom> I also recommend not using do-notation until you can translate between do-notation and >>= back and forth by hand.
17:11:54 <monochrom> c is the Bool parameter.
17:12:08 <monochrom> I don't know what it means because this is a toy example not a meaningful example.
17:12:17 <zeta_0> `
17:12:45 <zeta_0> monochrom: oh so `c` is just randomely used then?
17:12:56 <monochrom> It's a toy function to map True to 1, False to 0.  Someone has to give some name to the parameter.  Not supposed to be meaningful.
17:13:22 <monochrom> I would choose "b" to be honest.
17:13:51 <monochrom> But there is also no point writing "do" there.  And no point writing "== True" there either.
17:14:05 <monochrom> Please stop using this "tutorial" site.
17:14:37 <zeta_0> monochrom: so kind of like using lambda when it does not need a name, same with parameters?
17:14:58 <dmwit> uh?
17:15:06 <dmwit> I don't see a similarity between those two things.
17:15:09 <monochrom> Wrong. Lambda requires a name.
17:15:37 <monochrom> "\c -> if c then 1 else 0" right there I need the name "c".
17:15:55 <dmwit> monochrom: (Perhaps the "it" in "it does not need a name" is "the function we are creating with the lambda".)
17:16:04 <zeta_0> oh, thanks for the clarification
17:16:48 <monochrom> Up to now you haven't seen a single function that doesn't need you to name your parameter.
17:19:56 <zeta_0> anyways, learning category theory has really helped me make sense of some of the things in haskell
17:20:36 <zeta_0> category theory is actually very natural to learn but the abstraction gets to me sometimes
17:21:27 <monochrom> Oh, I should resume reading "category theory in context".
17:22:13 <monochrom> Gah, so many books I want to read.
17:22:59 <zeta_0> monochrom: i am learning from this person: https://www.youtube.com/user/DrBartosz/playlists
17:24:40 <zeta_0> there is still a lot of things that are confusing me but i am getting there
17:26:10 <srid> I'm learning category theory from Bartosz too. And yes, I do find that it helps with an intuitive understanding of some concepts behind Haskell. zeta_0 
17:26:44 <srid> I'm watching the lectures as well as reading the book. Bartosz is a great teacher.
17:27:55 <EvanR> against all recommendations of learning CT in order to learn haskell, people keep doing it :)
17:28:04 <EvanR> and apparently it works?
17:28:20 <monochrom> I think I have an explanation of that.
17:29:49 <monochrom> Haskell requires a math aptitude. Some people lost their math aptitude they were supposed to have acquired from highschool --- I'm thinking functions and equational reasoning here --- picking up category theory has the side effect of restoring that.
17:29:58 <zeta_0> srid: cool, i am currently watching his second category course, getting there
17:30:18 <srid> In school and college I always enjoyed learning math, so that's another motive behind my learning CT (in conjunction with my desire to never stop learning as I age).
17:30:52 <zeta_0> monochrom: the highscholl and college i went to were horrible, i am glad we have the internet though
17:33:55 <monochrom> Perhaps also they don't see disjoint union except in Haskell and category theory.
17:34:25 <zeta_0> is the `category theory for programmers` book by `bartosz milewski` fully complete?
17:34:45 <zeta_0> i haven't seen the book on amazon, why is that?
17:34:52 <monochrom> Recall that neither OOP nor Scheme has disjoint union, and most programmers do not take a math course that brings it up either. (Hell, fairly few math courses do.)
17:37:17 <nil> disjoint union, as in sum types?
17:37:45 <monochrom> Yes
17:37:59 <monochrom> Hey I like his frog story!
17:38:16 <srid> zeta_0: the "book" is indeed complete; Bartosz wrote it as a series of blog post, and Igal compiled it in book format: https://github.com/hmemcpy/milewski-ctfp-pdf
17:38:39 <srid> I have the hardcover version of it (link in github).
17:43:38 <zeta_0> srid: oh cool, does the book go more in depth and cover more topics/concepts then the youtube videos?
17:46:59 <srid> zeta_0: i'm still in part I; but so far seems like more or less 1-on-1 mapping with some exceptions (like epimorphism is not discussed in the book).
17:47:53 <srid> reading the book after watching each lecture can be a nice way to 'review' what was learned
17:50:58 <zeta_0> srid: i'm currently in part II in the youtube videos, i think i am going finish watching the videos and then read the book
17:51:35 <srid> sounds good. i wish there was an online study group for this book.
17:53:47 <zeta_0> i just ask all my category theory questions here
17:54:10 <meu76[m]> is all the message centralized in this thread?
17:54:37 <zeta_0> i don't know
17:57:53 <dmwit> meu76[m]: I don't understand the question.
17:58:40 <EvanR> he who questions understanding understands questions
18:02:01 * hackage project-m36 0.7 - Relational Algebra Engine  https://hackage.haskell.org/package/project-m36-0.7 (agentm)
18:09:33 <meu76[m]> <dmwit "meu76: I don't understand the qu"> dmwit: I meant does all discussion happen in here? isn't there other categories to filter discussion?
18:12:48 <dmwit> On a worldwide scale, approximately none of the discussion happens in here.
18:13:11 <dmwit> But to be less snarky: I still don't understand the question.
18:14:30 <dmwit> (What is a "category", for example?)
18:14:33 <nil> /msg alis list haskell
18:15:28 <nil> i believe all topics related to haskell are welcome here, in any case
18:18:42 <meu76[m]> I'm confused, what you don't understand in my question? sounds like you're just being pedantic at this point
18:22:44 <maralorn> meu76[m]: There is no concept of threads in irc.
18:22:51 <dmwit> What does "category" mean to you? What categories do you wish there were?
18:22:56 <maralorn> Are you talking about different rooms?
18:26:43 <meu76[m]> kind of like the gitter of haskell-chat: Beginners, Study, Code challenges and so on
18:26:55 <meu76[m]> <maralorn "meu76: There is no concept of th"> Alright thanks
18:29:26 <nil> how would you name this function?:  asum . fmap pure :: (Functor f, Foldable f, Alternative g) => f a -> g a
18:31:40 <nil> meu76[m]: you should run the command above and find out what haskell-* channels exist
18:31:56 <sarahzrf> nil: "choice", maybe
18:32:05 <koz_> :t asum
18:32:06 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
18:32:19 <koz_> What does asum do exactly?
18:32:31 <pikajude> asum [a,b,c] = a <|> b <|> c
18:32:32 <pikajude> roughly
18:32:38 <koz_> pikajude: Ah.
18:32:50 <koz_> So 'fail out' if anything fails, otherwise... ??
18:33:09 <pikajude> left to right i believe
18:33:18 <pikajude> i've used it when writing parsers, for example
18:33:37 <nil> <koz_> So 'fail out' if anything fails, otherwise... ?? 
18:33:39 <nil> wrong
18:33:52 <sarahzrf> > asum ["hello", "world"]
18:33:54 <lambdabot>  "helloworld"
18:33:55 <nil> if something fails, just move on to the next thing
18:34:05 <koz_> nil: Ah.
18:34:11 <koz_> skipFailures?
18:34:35 <sarahzrf> no, that'd be more like asum itself
18:34:36 <nil> (<|>) is (++) on lists, so asum is concat on lists
18:34:36 <sshine> depends on the Alternative
18:34:39 <sarahzrf> none of the things will fail
18:34:40 <sshine> :t (<|>)
18:34:41 <sarahzrf> because they're all pure
18:34:41 <lambdabot> Alternative f => f a -> f a -> f a
18:35:59 <sshine> > Nothing <|> Just 42
18:36:01 <lambdabot>  Just 42
18:36:04 <sshine> > Just 42 <|> Just 43
18:36:07 <lambdabot>  Just 42
18:36:26 <sshine> > Left "Not this one" <|> Right "But this one" <|> Right "And not this one"
18:36:27 <lambdabot>  Right "But this one"
18:36:47 <ski> @hoogle [a] -> Gen a
18:36:48 <lambdabot> Test.QuickCheck elements :: [a] -> Gen a
18:36:48 <lambdabot> Test.QuickCheck growingElements :: [a] -> Gen a
18:36:48 <lambdabot> Test.QuickCheck.Gen elements :: [a] -> Gen a
18:36:52 <ski> hm
18:37:11 <pikajude> > asum [Nothing, Nothing, Just "hello"]
18:37:13 <lambdabot>  Just "hello"
18:37:15 <pikajude> oh we covered this already
18:37:34 <pikajude> i was in the bathroom
18:37:54 <dmwit> :t foldMap Alt
18:37:55 <lambdabot> forall k (t :: * -> *) (f :: k -> *) (a :: k). (Foldable t, Monoid (Alt f a)) => t (f a) -> Alt f a
18:38:21 <dmwit> :t (foldMap .) (Alt .)
18:38:22 <lambdabot> forall k (t :: * -> *) (f :: k -> *) (a1 :: k) a2. (Foldable t, Monoid (Alt f a1)) => (a2 -> f a1) -> t a2 -> Alt f a1
18:38:40 <nil> o_ô
18:38:49 <ski> nil : hmm. i was thinking maybe `oneOf', but
18:38:50 <ski> @hoogle oneOf
18:38:51 <lambdabot> Test.QuickCheck oneof :: [Gen a] -> Gen a
18:38:51 <lambdabot> Test.QuickCheck.Gen oneof :: [Gen a] -> Gen a
18:38:51 <lambdabot> Text.Parsec.Char oneOf :: (Stream s m Char) => [Char] -> ParsecT s u m Char
18:38:52 <pikajude> :t ((foldMap .) .) . ((Alt .) .)
18:38:53 <lambdabot> error:
18:38:53 <lambdabot>     • Couldn't match type ‘Alt f a2’ with ‘a3 -> m’
18:38:53 <lambdabot>       Expected type: f a2 -> a3 -> m
18:38:56 <pikajude> aw
18:38:59 <ski> nil : how about `alternatives' ?
18:39:19 <ski> (or `alternative', `alts', or `alt')
18:39:29 <nil> ski: possibly
18:40:17 <nil> or liftAlt
18:40:25 <pikajude> is there anything else that's list-ish and an instance of Alternative? because i can only think of examples where "asum" === "first non-failure value"
18:40:39 <nil> (maybe i should stop abusing "lift")
18:40:55 <ski> pikajude : probably `LogicT' stuff ?
18:41:09 <pikajude> scary *shivers*
18:41:10 <sshine> koz_, so wrt. 'fail out', if you think of Nothing as a failure, Nothing <|> Just "Something" would be an alternative to failure. calling it 'skipping' would depend on what the Nothing represents.
18:41:49 <koz_> sshine: OK, that makes sense.
18:41:50 <sshine> koz_, if you do 'f x <|> g x', you're not 'skipping' f.
18:42:16 <sshine> koz_, but f may 'skip' on something if that makes sense for what f does.
18:42:48 <pikajude> > Right () <|> Left ()
18:42:50 <lambdabot>  error:
18:42:50 <lambdabot>      • No instance for (Control.Monad.Trans.Error.Error ())
18:42:50 <lambdabot>          arising from a use of ‘<|>’
18:42:56 <pikajude> what
18:43:45 <pikajude> oh, the Alternative instance is only defined if Error e => Either e _
18:46:45 <dmwit> Wait, really?
18:46:59 <pikajude> probably some screwy old implementation detail
18:47:44 <nil> apparently prelude doesn't have an Alternative instance for Either
18:48:14 <dmwit> Meanwhile the haddocks for base don't mention the instance either under the documentation for Either or under the documentation for Alternative. Weird.
18:48:27 <pikajude> it's in Control.Monad.Trans.Error
18:48:33 <nil> because its from transformers
18:48:35 <nil> it's*
18:49:23 <dmwit> I see. The Error constraint is needed for empty.
18:49:29 <nil> http://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Error.html#v:-36-fAlternativeEither
18:49:33 <pikajude> https://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Error.html#i:o:ic:Alternative:Alternative:1
18:49:36 <pikajude> aww someone beat me to it
18:50:15 <pikajude> it could really just be Monoid e => Alternative (Either e) couldn't it
18:50:48 <nshepperd2> transformers has an orphan Alternative instance for Either? O_O
18:51:08 <nil> i don't think it even needs a constraint?
18:51:22 <pikajude> yeah it does
18:51:27 <nil> Left _ <|> r = r
18:51:37 <pikajude> and if r is also Left _
18:51:38 <nil> Right r <|> _ = Right r
18:51:38 <nshepperd2> There are two plausible instances for Alternative (Either e)
18:51:50 <nil> pikajude: ah, indeed
18:51:56 <pikajude> > asum [Left "foo"]
18:51:58 <lambdabot>  Left ""
18:52:01 <pikajude> it has to return something
18:52:05 <nil> pikajude: could just drop one and use the other, though
18:52:06 <pikajude> okay, that makes NO sense to me
18:52:32 <pikajude> no, alternative requires empty to be defined
18:52:43 <dmwit> pikajude: It is Left "foo" <|> empty.
18:52:44 <pikajude> you can't make empty = Left x without knowing something about x
18:52:48 <dmwit> pikajude: And empty is Left "".
18:52:56 <dmwit> pikajude: ...and Left x <|> y = y.
18:53:00 <pikajude> yeah
18:53:08 <pikajude> it now makes some sense to me
18:53:17 <dmwit> I mean it's not great.
18:53:24 <pikajude> or I guess you could do empty = Left undefined :)
18:53:39 <pikajude> nobody would mind that
18:53:57 <nil> ouch
18:54:11 <dmwit> I think Monoid e => Alternative (Either e) is probably the best. Then if folks want the last error they can use Last.
18:54:23 <pikajude> thanks, i like that one too
18:54:24 <dmwit> ...or the first one or whatever.
18:54:42 <pikajude> attoparsec doesn't append the error messages anyway
18:54:58 <pikajude> so i don't know if it'd be sensible behavior
18:57:27 <pikajude> @hoogle asum1
18:57:28 <lambdabot> Data.Semigroup.Foldable asum1 :: (Foldable1 t, Alt m) => t (m a) -> m a
18:57:28 <lambdabot> Rebase.Prelude asum1 :: (Foldable1 t, Alt m) => t (m a) -> m a
18:57:48 <pikajude> i just need sum1 to love...
19:00:58 <nshepperd2> this orphan instance is deeply upsetting anyhow
19:01:05 <nshepperd2> i hope it goes away some day
19:02:26 <nshepperd2> relatedly, I always wish I had instance (Ord k, Semigroup v) => Monoid (Map k v)... but it ain't
19:07:35 <dmwit> nshepperd2: Yes, that is the obviously correct instance. The one that exists is an abomination.
19:22:47 <koz_> Is there a way I can get a list of all the things in base with Eq1 instances?
19:23:18 <pikajude> i think you have to import all of base for that
19:23:31 <koz_> Lol.
19:23:35 <pikajude> i don't believe that haddock is able to generate that list
19:23:36 <nil> https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Classes.html#t:Eq1
19:23:47 <nil> see Instances
19:23:55 <koz_> nil: There's _way_ more than this.
19:24:01 <pikajude> yeah there's your problem
19:24:09 <pikajude> no way to find instances other than importing the module they're in :)
19:24:10 <nil> o_O
19:24:23 <nil> koz_: example?
19:24:56 <pikajude> btw is it possible for something to have Eq1 but not (constrained) Eq? i don't understand why those classes exist
19:25:38 <dmwit> It is possible but unusual.
19:26:04 <pikajude> do you know any examples?
19:26:10 <dmwit> The class exists to enable Eq instances for types that are parameterized by containers.
19:26:26 <dmwit> No. It would be dumb to do it. I'm just saying the rules of Haskell allow it.
19:26:29 <pikajude> oh okay
19:26:29 <hololeap> pikajude: Cofree
19:26:33 <koz_> I was getting conflicting instance problems due to that for a whole lotta types, but for some reason, none of them appear to be Eq1s.
19:26:34 * koz_ weird.
19:26:58 <pikajude> ohh, Cofree has Eq1 f => Eq1 (Cofree f)
19:27:11 <hololeap> err, sorry Cofree requires the functor to have a Eq1 instance
19:27:12 <pikajude> that's what dmwit meant by parameterized by containers
19:27:34 <pikajude> that kinda makes sense. Eq1 f => Eq1 (Foo f)
19:27:50 <pikajude> and it wouldn't make any sense to define Eq (f a) => Eq (Foo f a)
19:29:18 <dmwit> You would need `(Eq a, Eq (f (Cofree f a))) => Eq (Cofree f a)`. But then you run afoul of the instance decidability conditions.
19:29:19 <hololeap> it does have  (Eq1 f, Eq a) => Eq (Cofree f a) though
19:29:56 <pikajude> so before Eq1, people just didn't define eq for containers like that?
19:30:28 <dmwit> I don't know much about the stone ages.
19:30:44 <pikajude> the only thing i know is people primarily used stone tools
19:30:57 <hololeap> the only function was id
19:31:06 <pikajude> i believe GHC 6.8 counts as one but I don't know
19:35:57 <ski> @instances-importing Data.Functor.Classes Eq1
19:35:59 <lambdabot> ((,) a), (M.Map k), Const a, Either a, IM.IntMap, IdentityT f, S.Set, Seq.Seq, Tree
20:04:01 * hackage vega-view 0.3.1.1 - Easily view Vega or Vega-Lite visualizations.  https://hackage.haskell.org/package/vega-view-0.3.1.1 (DouglasBurke)
20:06:18 <iqubic> I wish Singletons coult do automatic proof searches, like in Idris.
20:31:37 <learningc> Why is haskel so popular on irc but not as much in the industry?
20:33:01 <koz_> learningc: I question whether it's even 'popular' on IRC, for almost any sensible definition of 'popular'.
20:37:56 <learningc> Well if I compare then number of users as compared to the top language as C and extrapolate I would say it number 2 language behind python
20:38:10 * dmwit yawns
20:38:21 <koz_> That's some super-questionable methodology right there. :P
20:44:45 * ski . o O ( Haskell is pretty fun )
20:45:07 <monochrom> My economic view is why are there many lawyers, doctors, accountants in industry but none on IRC.
20:46:50 <dmwit> I don't... what?
20:48:54 <monochrom> They have no incentive to spend time on IRC giving out free advice.
20:50:31 <monochrom> Economically, whenever you see a group of people spending more time in industry and less time on IRC, it's because their time is better spent on getting paid or real fulfilling life.
20:51:19 <monochrom> Even I didn't have time for IRC when I was busy teaching in the summer term.  I am here now precisely because I have no job this term.
20:53:30 <monochrom> It also turns out that experience I gain from watching and participating Q&A here will benefit my paid teaching jobs in the future.  I won't pose it as cause-effect or motivation because a long time ago when I first participated here I didn't thought of the benefit.  But the benefit is real.  Also when I first participated here I had no job anyway.
20:53:57 * koz_ just Haskells for fun these days.
20:54:23 <iqubic> Heh. Me too.
20:59:29 <nshepperd2> perhaps it's not haskell that is popular on irc, but irc that is popular on haskell
21:01:08 <iqubic> Yes. That is true.
21:12:34 <EvanR> this is a large (?) channel
21:12:50 <EvanR> and freenode is like ... the supermassive blackhole at the center of IRC networks
21:13:31 <dmwit> monochrom: Suppose I then conclude the... converse(?)... namely, that when I see a group of people spending more time on IRC and less in industry, it's because their time is not better spent on getting paid. Then this doesn't really answer anything, because the obvious next question is, why do Haskellers not find their time is better spent on getting paid?
21:14:04 <monochrom> They don't get a lot of Haskell jobs.
21:14:25 <EvanR> if there was a lawyer irc channel... i bet lawyers would use it. QED
21:15:25 <monochrom> Notice how dons, manatee, chrisdone, dolio, even jaffecake and spj aren't here anymore.
21:15:31 <dmwit> monochrom: I see. Then is your claim that Haskell is popular on IRC precisely because it is not popular in industry.
21:15:42 <monochrom> Yes.
21:16:13 <dmwit> Brainfuck is not popular in industry.
21:16:13 <iqubic> monochrom: I don't know those people, and I have been in here for quite some time.
21:16:23 <iqubic> nearly 3 years I have spent in here.
21:17:00 <Gigabitten> It seems pretty clear that a Haskell IRC has some significant advantages in terms of sheer numbers. Haskell users are more likely to seek support since Haskell is difficult *and* more likely to be enthusiastic about Haskell, so they'd be more likely to come here. These factors must be considered before marking it all down as Haskellers being unemployed with relation to Haskell, though that is probably also generally true.
21:17:27 <Gigabitten> It was also a language made when IRC was really popular, which I'm sure helps.
21:17:39 <EvanR> manatee still exists somewhere?
21:17:56 <monochrom> He got a job.
21:18:09 <monochrom> Hell he was most active here when he was unemployed.
21:18:45 <EvanR> i can corroborate this correlation
21:19:26 <dmwit> (...but brainfuck is not popular on IRC, to connect all the dots of the point I'm trying to make.)
21:19:52 <Gigabitten> It also doesn't have an enthusiastic userbase.
21:19:53 <VaNilLa[m]> brainfuck also is more a turing tarpit than a language
21:19:57 <monochrom> Brainfuck is brought up more often than normal in #haskell.
21:19:57 <VaNilLa[m]> I don't think that's a fair comparison.
21:19:58 <EvanR> you can't connect dots, homotopically speaking
21:20:26 <VaNilLa[m]> how about another language that isn't big in industry?
21:20:38 <VaNilLa[m]> Scala? I haven't heard much about that
21:20:38 <EvanR> digital mars D
21:20:59 <monochrom> Brainfuck is likely very popular on IRC but just manifesting in a sneaky way by permeating throughout all channels that programmers hang out in.
21:21:22 <VaNilLa[m]> do we know how big D is on IRC?
21:21:31 <VaNilLa[m]> I don't know enough about IRC to check
21:21:31 <EvanR> check the stats
21:21:41 <EvanR> either #d or ##d
21:21:43 <monochrom> Like how the functional programming channel doesn't get traction but that's because the traction is in #haskell
21:22:00 <iqubic> I would love to make a type safe Brainfuck interpreter in Haskell. It might be a fun thing to do.
21:22:09 <EvanR> wait theres a functional programming channel?
21:22:23 <monochrom> Yeah!
21:22:55 <monochrom> I went there for a little bit and then left. The activities are all in here instead.
21:22:58 <VaNilLa[m]> #d on freenode has 140 users
21:23:21 <VaNilLa[m]> which probably indicates that popularity in industry is not a strong predictor of IRC channel size
21:23:36 <EvanR> um
21:23:56 <monochrom> If brainfuck were not popular in the way I described, lambdabot would not have brainfuck.
21:24:09 <koz_> :t when
21:24:11 <lambdabot> Applicative f => Bool -> f () -> f ()
21:24:38 <monochrom> Like, there's got to be a reason why lambdabot supports only Haskell and Brainfuck but not Scheme, SML, Lisp, C, Java, ...
21:24:45 <dolio> monochrom: No one talks about cubes here.
21:25:15 <VaNilLa[m]> there's a non-negligible increase in difficulty between implementing brainfuck and implementing Scheme
21:25:52 <VaNilLa[m]> brainfuck is certainly much better known in the general circles than scheme, SML, or Lisp
21:26:11 <EvanR> where are you getting all these facts
21:26:18 <EvanR> uncyclopedia?
21:26:18 <dolio> Can't spend my free time on something as ordinary as Haskell anymore.
21:26:42 <VaNilLa[m]> EvanR: #d channel size is from https://netsplit.de/channels/?net=freenode&chat=%23d , if that was part of your question 
21:26:52 <EvanR> 140 is nothing
21:26:59 <EvanR> and D is unpopular as hell
21:27:09 <EvanR> scheme and lisp are incredibly well known
21:27:21 <EvanR> brainfuck and "a lisp" are trivial to implement
21:27:22 <VaNilLa[m]> I...
21:27:25 <VaNilLa[m]> don't know about that, either
21:28:05 <VaNilLa[m]> frankly, the general audience is not any more familiar with Lisp than brainfuck
21:28:13 <VaNilLa[m]> (anecdotal)
21:29:05 <EvanR> one day the boss's kid was wandering through the office, and randomly showed me the webapp that his school was teaching programming with... it was a lisp
21:29:30 <Gigabitten> idk, emacs is *fairly* popular and most people who use emacs are at least aware of lisp, which is a start
21:29:31 <EvanR> with types
21:29:34 <monochrom> dolio: Wait, what are cubes?
21:29:51 <dolio> https://arxiv.org/pdf/1611.02108.pdf
21:30:27 <VaNilLa[m]> emacs lisp, fair enough
21:30:51 <VaNilLa[m]> my sample is the "new generation" I suppose, since I'm mostly talking about people in university 
21:30:53 <monochrom> And I thought people were tired of cubicles...
21:31:11 <dolio> Now it's hip because everyone is doing open plan.
21:31:56 <VaNilLa[m]> and largely (around 9/10 people), the language of choice is JavaScript and some C++ from class projects. I'm not happy about it, but that's how it is right now
21:32:00 <EvanR> normal TT plus an interval HIT proves function extensionality... so they put a bunch of intervals together to make cubes?
21:32:06 <Gigabitten> hey, I'm in uni and nobody's said anything I would say "no" to the respective question "have you heard of this." n=1 though
21:32:38 <koz_> My university is a Java and Windows shop. Frankly, people give me the side-eye if I even mention that anything else exists.
21:32:38 <VaNilLa[m]> Gigabitten: I'm sorry, can you rephrase that? I'm not sure I understand
21:32:46 <Gigabitten> it was worded awfully, I agree
21:32:56 <koz_> I'm at least fortunate in that I have to interact not-at-all with the former and only very tangentially with the latter.
21:33:22 <VaNilLa[m]> koz_: me too. I'm in the PL research group and here it's Haskell and Idris, but the moment you take a step outside, those fade far into the background.
21:33:39 <koz_> VaNilLa[m]: If only my university _had_ a PL research group.
21:33:41 <koz_> I'd like, live there.
21:34:10 <Gigabitten> the point is that I'm just one person, so I'm not much evidence, but I'm a uni student who's heard of all the things mentioned in this conversation - lisp, brainfuck, scheme, D, SML, etc.
21:34:12 <VaNilLa[m]> hehe
21:34:40 <EvanR> but have you heard of... OCAML
21:34:44 <VaNilLa[m]> Gigabitten: but you're also in the #haskell IRC, that's a bit of a sampling bias :D
21:34:45 <Gigabitten> uhm
21:34:49 <VaNilLa[m]> I for one, have
21:34:51 <koz_> VaNilLa[m]: Was about to say.
21:34:53 <EvanR> just kidding
21:34:55 <Gigabitten> goddamnit I've definitely heard of it
21:35:04 <VaNilLa[m]> Rust's compiler was originally written in OCaml
21:35:25 <EvanR> makes sense
21:35:29 <Gigabitten> sampling biases are irrelevant with such a small sample size lol
21:35:45 <Gigabitten> which is to say that the size is so much more of a problem 
21:36:22 <VaNilLa[m]> Gigabitten: I'll take your word for it, I don't know much stats :D
21:36:36 <VaNilLa[m]> EvanR: I'm actually thinking computer science education researchers tend to be more aware of languages such as Lisp, since they're in academia (this is going back to boss' kid)
21:38:29 <Gigabitten> I mean, if I was teaching a computer science class, I'd probably go with C++ honestly. It lets you shoot yourself in the foot a lot, but it has a lot of the things other high-level languages have and has a huge ecosystem, and also makes you use pointers which is good to understand conceptually. 
21:38:40 <EvanR> this kid was like 8... and it was a commercial lisp educational tool. But yeah his middle school must have a computer science education researcher
21:38:48 <koz_> Gigabitten: As someone who is involved in teaching first-year programming, and has been for a while, I _categorically_ disagree.
21:39:05 <Gigabitten> I was just about to send a message about how I don't know what I'm talking about
21:39:22 <nshepperd2> the danger of implementing lisp in lambdabot is that it might turn out to be useful to someone
21:39:23 <VaNilLa[m]> I would absolutely not teach C++
21:39:50 <EvanR> you can probably get away with not ever mentioning C++... considering how ubiquitous it is and how much material is freely available on it
21:39:59 <koz_> Also, could someone help me figure out this polymorphic recursion problem? https://gist.github.com/kozross/cc5130dd208f32884174e2a2ecdebb7b
21:40:04 <Gigabitten> hmm. you might be right about that. 
21:40:05 <koz_> (I can add context if needed)
21:40:11 <EvanR> teach something more obscure (and better), and C++ will be automatic. As far as that can happen
21:40:22 <Gigabitten> I hadn't considered that.
21:40:53 <VaNilLa[m]> EvanR: even commercial teaching tools tend to have some research done into them. I'm __not__ saying your boss' kid had a CS research in his middle school - that's much stronger than what I was claiming.
21:40:55 <koz_> (before anyone asks, no I can't use a fold, since 'k' constantly changes)
21:40:57 <koz_> (as in, the type)
21:41:58 <VaNilLa[m]> I'm not at all involved in teaching first year CS, but C++ is an amazing example of needless complexity.
21:42:08 <VaNilLa[m]> now that I think about it, I'd consider Racket.
21:42:10 <VaNilLa[m]> (a lisp!)
21:43:11 <iqubic> I'm going to be taking a Computer Science course starting on Monday where I'll be required to use Java. It's going to be a hard quarter.
21:43:23 <koz_> iqubic: You ahve all my sympathies and then some.
21:43:35 <VaNilLa[m]> iqubic: I'm sorry.
21:43:36 <iqubic> I really really really despise OOP. And Java is just the worst.
21:43:58 <iqubic> koz_: It's a prerequisite for more advanced CS courses.
21:44:06 <koz_> iqubic: Yeah, I understand.
21:44:17 <koz_> My university has a similarly mis-advised policy.
21:44:31 <VaNilLa[m]> I tend to find a way to wiggle functional programming into my class projects. teachers tend to be happy to compromise - I was allowed to use Elm rather than JavaScript in one instance.
21:45:03 <VaNilLa[m]> Additionally, they let me implement a compiler for a functional language rather than for a tiny python subset. There may be room for you to get away from Java!
21:45:13 <monochrom> Java is not that hard.
21:45:28 <iqubic> koz_: I used to think Java was great, but then I learned Haskell and now I find it hard to think in an OOP paradigm.
21:45:30 <VaNilLa[m]> hard? no. it's just unpleasant
21:45:36 <koz_> monochrom: Hard? No. Annoying and repetitive and full of cruft and nonsensical? Definitely.
21:45:55 <monochrom> It is bearable.
21:46:10 <VaNilLa[m]> Java was my first language, I can still write it pretty well. but it's not good. 
21:46:14 <iqubic> Getters and Setters are the worst. Just let me pattern match on my objects.
21:46:16 <koz_> monochrom: To each their own opinion.
21:46:33 <koz_> But since this is #haskell and not #java, I will refrain from posting ten-screen long monologues.
21:46:37 <monochrom> Also you can try using parametric polymorphism and see if you confuse the hell out of your prof and TAs.
21:46:55 <VaNilLa[m]> you can write java pretty functionally
21:47:07 <VaNilLa[m]> but...
21:47:14 <iqubic> monochrom: How would I use parametric polymorphism in Java?
21:47:36 <VaNilLa[m]> void <T> doSomething(T whatever) { ... } or something
21:48:05 <VaNilLa[m]> or does the <T> go after the function name? I don't remember anymore.
21:48:19 <iqubic> That's just the Java Generics stuff.
21:48:23 <VaNilLa[m]> you have to explicitly specify generic / polymorphic arguments.
21:48:32 <monochrom> public class BSTNode<k,v> { public k key; public v value; public BSTNode<k,v> left, right; }
21:48:36 <VaNilLa[m]> well, that's how Java does parametric polymorphism
21:48:47 <VaNilLa[m]> that's what generics are
21:49:06 <nshepperd> sometimes the <T> goes before the function name, but i can't remember when
21:49:29 <iqubic> And if I recall correctly you can have the scope of the type varible be an entire class. I think.
21:49:32 <EvanR> while we're tangentially writing haskell in java in here... monochrom has some lazy list code that uses java exceptions
21:49:48 <monochrom> Exactly when you would state "forall t" in Haskell under RankNTypes.
21:50:09 <nshepperd> java's time/date api is enlightened now though, that's good
21:50:38 <iqubic> Yes. They finally admitted that Japan has enterd the "Reiwa" era
21:50:58 <monochrom> If you see "void foo(T param)" it means the "T" comes from an outer scope. Think ScopedTypeVariables in Haskell.
21:51:24 <iqubic> Right. I see.
21:51:38 <monochrom> But if you see "void <T> foo(T param)" it means foo comes with its own "forall T".
21:51:39 <nshepperd> i'd like haskell's time package to get closer to how java does it
21:52:03 <VaNilLa[m]> I've never had to deal with time and I'm a happier person because of it.
21:52:08 <iqubic> "public static <T extends Comparable<T>> T maximum(T x, T y, T z)"
21:52:23 <VaNilLa[m]> that looks valid
21:52:23 <EvanR> nshepperd: what... blasphemy
21:52:36 <EvanR> though i have not seen the new java time api
21:52:37 <monochrom> haha
21:52:48 <VaNilLa[m]> iqubic: do this, but for every function you have to write
21:53:41 <iqubic> That's similar to "maximum :: (Ord t) => t -> t -> t -> t"
21:53:48 <iqubic> It's basically the same thing.
21:53:58 <VaNilLa[m]> ye
21:54:54 <nshepperd> a sword is blasphemy in the gungeon
21:55:00 <iqubic> "public class Box<T> { ... }" lets you use T inside of the class where ever you want.
21:55:01 <monochrom> Well, apart from Java having subclassing and Haskell doesn't, so the two are not quite comparable (hee hee)
21:55:20 <iqubic> Haskell doesn't have subclassing?
21:55:32 <monochrom> No?
21:55:55 <iqubic> class Semigroup m => Monoid m where ...
21:56:00 <iqubic> Is that subclassing?
21:56:14 <nshepperd> haskell has sub'class'ing but it's not subclassing
21:56:15 <shachaf> Haskell has that, so presumably the answer is going to be no.
21:57:09 <nshepperd> it's a totally different thing which happens to use the word 'class'
21:58:44 <iqubic> And there's also the Java streams API which is basically just conduits/pipes.
21:59:07 <EvanR> java and haskell both have generics
21:59:17 <EvanR> now they are comparable
21:59:28 <iqubic> It was at the time that Java added the streaming API that they also had to add lambdas.
21:59:39 <monochrom> I thought in Haskell it's "generic" without "s".
21:59:47 <iqubic> No.
21:59:55 <iqubic> It's GHC.Generics with an 's'
22:00:02 <monochrom> Oh oops
22:00:09 <iqubic> Which is actually in base.
22:00:12 <EvanR> also, intrinsics
22:00:21 <iqubic> What are those?
22:01:13 <EvanR> nevermind, those really are comparable
22:01:18 <nshepperd> it's GHC.Generics.Generic
22:02:29 <iqubic> the comparable interface in Java is similar to the Ord typeclass.
22:03:20 <iqubic> It's just that Java uses -1, 0, and 1 instead of LT, EQ, and GT
22:04:15 <c_wraith> Similar to in purpose, but with such a massive difference that I'm surprised anyone thinks java interfaces and Haskell classes have anything in common: Haskell requires both arguments to be the same type.  Java says "eh, whatever, throw a ClassCastException if the types don't line up.  Or just pretend they do.  It's all good."
22:05:03 <iqubic> I cannot believe that I once had the entire Java base library documentation downloaded on my computer as a bunch of HTMLs.
22:05:39 <VaNilLa[m]> iqubic: I still do. C++ and Rust, as well.
22:05:45 <EvanR> java is checking the types at runtime?
22:05:52 <iqubic> c_wraith: Java takes that stance about many things.
22:06:15 <iqubic> There's even an infix keyword, 'instanceof'
22:06:33 <iqubic> instanceof :: a -> b -> Bool
22:06:37 <monochrom> I know that a lot of people rate similarity by purpose similarity because they can't deal with semantics.
22:06:55 <c_wraith> EvanR: Yep.  Even java "generics" just insert implicit casts at the JVM level
22:07:07 <c_wraith> EvanR: and java casts are checked at runtime
22:07:49 <EvanR> i can see why so many dynamic languages went the way they did, "we're going to do java done right" (no type system)
22:08:15 <iqubic> Java does have compile time errors, but those are mostly things like missing semicolon or mis-matched brackets.
22:08:23 <EvanR> lol
22:08:26 <EvanR> at least theres that?
22:12:28 <iqubic> There are a handful of other compile time errors too, like "symbol not found"
22:14:26 <iqubic> Which is for things like trying to access an a non-existant varible or calling a function that doesn't exist.
22:14:51 <EvanR> ok then it beats ruby
22:15:03 <iqubic> How so?
22:15:18 <EvanR> bad variable is a runtime error (or not, if that part of the code is skipped at runtime)
22:15:25 <iqubic> Oh, wow.
22:15:31 <monochrom> You speak like you really need that Java course to find out how wrong you are.
22:15:39 <EvanR> lol
22:15:55 <VaNilLa[m]> well, python also doesn't to bad variable name checking
22:16:00 * hackage wide-word 0.1.0.9 - Data types for large but fixed width signed and unsigned integers  https://hackage.haskell.org/package/wide-word-0.1.0.9 (ErikDeCastroLopo)
22:16:01 <EvanR> right
22:16:02 <VaNilLa[m]> java to ruby or python is apples to oranges
22:16:28 <EvanR> you can totally judge all languages for when it catches before the program runs
22:16:46 <EvanR> you can totally judge all languages on what it catches before the program runs
22:17:22 <VaNilLa[m]> I prefer static typing too, but different things for different people \_(:/)_/
22:17:31 <VaNilLa[m]> \\_(:/)_/
22:17:31 <EvanR> maybe i should just omit connector words and do subject verb object from here on
22:17:53 <EvanR> this isn't just a static typing thing
22:18:24 <VaNilLa[m]> true.
22:19:44 <VaNilLa[m]> that reminds me how Dropbox' python codebase is suffering, and they have to use a third-party tool to statically analyze their program
22:20:32 <EvanR> hands down i think the worst is phantomjs
22:21:06 <VaNilLa[m]> how so?
22:21:07 <EvanR> it runs your file no matter what, javascript or not, and if it fails, no output
22:21:18 <EvanR> and doesn't exit :)
22:21:39 <VaNilLa[m]> glorious. 
22:21:51 <EvanR> if it is javascript, you have a chance of getting a normal runtime error, but it still may freeze
22:21:55 <VaNilLa[m]> I remember having to write Java for a class, and we had to use a web framework called ninja
22:22:09 <VaNilLa[m]> its errors were kind of like you describe
22:22:33 <VaNilLa[m]> it had some built-in JSON deserializer. if it failed, no error would be reported, status code 200 returned, and business code will silently fail
22:22:39 <VaNilLa[m]> fail to run, I should say
22:23:35 <pikajude> that'll drastically reduce the error rate though which is pretty cool
22:24:00 <EvanR> right, calls into question the existential nature of a problem
22:24:33 <VaNilLa[m]> problem is clearly not with the server - no errors are reported!
22:24:39 <pikajude> that's why i wrap every haskell program i write in `catch` \ _ -> return ()
22:24:50 <EvanR> if customers don't know about it, your boss doesn't know about it, it doesn't exist. if customers know about it but can't notify anyone about it, it doesn't exist
22:25:00 <pikajude> well it's not about the customers
22:25:03 <VaNilLa[m]> and add a "throws Exception" to all `static void main` functions in Java :)
22:25:09 <pikajude> if the metrics don't indicate that users are affected by it, it doesn't exist
22:25:26 <EvanR> you think this is a joke
22:25:49 <monochrom> @quote monochrom hugs
22:25:49 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
22:26:00 <monochrom> @quote monochrom runghc
22:26:00 <lambdabot> monochrom says: just add #! /usr/bin/runghc to your haskell file. then type errors occur at runtime only.
22:26:15 <iqubic> @quote jle` zzz
22:26:15 <lambdabot> jle` says: let sleep = pure "zzz" in getSum sleep
22:26:17 <pikajude> @quote pikajude
22:26:17 <lambdabot> pikajude says: fibonacci numbers are quite common in nature; some examples include 1, 2, and 3
22:26:22 <pikajude> oh yeah i remember that
22:26:38 <monochrom> Oh! Get some sleep. Haha.
22:26:41 <iqubic> >>> let sleep = pure "zzz" in getSum sleep
22:26:55 <iqubic> > let sleep = pure "zzz" in getSum sleep
22:26:57 <lambdabot>  "zzz"
22:27:03 <iqubic> It actually works.
22:27:06 <pikajude> good night lambdabot
22:27:08 <pikajude> *pats*
22:29:31 <monochrom> @type getSum
22:29:32 <lambdabot> Sum a -> a
22:31:06 <monochrom> I guess Sum is the identity monad again.
22:33:31 <iqubic> > mconcat (map Sum [1, 2, 3, 4, 5])
22:33:33 <lambdabot>  Sum {getSum = 15}
22:33:46 <iqubic> > mconcat (map Product [1, 2, 3, 4, 5])
22:33:49 <lambdabot>  Product {getProduct = 120}
22:34:41 <iqubic> > foldMap Sum [1..10]
22:34:43 <lambdabot>  Sum {getSum = 55}
22:35:21 <iqubic> > let fac n = > foldMap Product [1..n] in fac 6
22:35:23 <lambdabot>  <hint>:1:13: error: parse error on input ‘>’
22:35:34 <iqubic> > let fac n = foldMap Product [1..n] in fac 6
22:35:36 <lambdabot>  Product {getProduct = 720}
22:35:59 <iqubic> I could unwrap the newtype, but you get the idea.
23:25:33 <koz_> Could someone help me make this thing typecheck? https://gist.github.com/kozross/cc5130dd208f32884174e2a2ecdebb7b
23:25:45 <koz_> (yes I have to do it this way due to the way the 'k' type argument changes as I recurse)
